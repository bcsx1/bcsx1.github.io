<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b284d3f1a72da68e6d4e04591c052cfb/" rel="bookmark">
			mysql 常用时间函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 当前日期当前时间当前时间戳（日期时间）日期运算 当前日期 CURRENT_DATEcurdate mysql&gt; select current_date(),curdate(); +----------------+------------+ | current_date() | curdate() | +----------------+------------+ | 2020-11-03 | 2020-11-03 | +----------------+------------+ 当前时间 CURRENT_TIMEcurtime mysql&gt; select current_time(),curtime(); +----------------+-----------+ | current_time() | curtime() | +----------------+-----------+ | 11:11:21 | 11:11:21 | +----------------+-----------+ 当前时间戳（日期时间） CURRENT_TIMESTAMPnow mysql&gt; select current_timestamp(),now(); +---------------------+---------------------+ | current_timestamp() | now() | +---------------------+---------------------+ | 2020-11-03 11:11:49 | 2020-11-03 11:11:49 | +---------------------+---------------------+ 日期运算 DATE_ADD(date,INTERVAL expr type)DATE_SUB(date,INTERVAL expr type)
date 是一个 DATETIME 或DATE值，用来指定起始时间。
expr 是一个表达式，用来指定从起始日期添加或减去的时间间隔值。 Expr是一个字符串;对于负值的时间间隔，它可以以一个 '-'开头。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b284d3f1a72da68e6d4e04591c052cfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0dedf89399e8319700f2249da91d6ad/" rel="bookmark">
			cv--action入门调查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		human action分类： 范围很广，从基本手势到人类团体事件。
gesture（肢体运动）actions（单人行为）interaction（多方交互）group activity（群体事件） 研究方向 action recognition（video classification） 输入已经分割好的视频片段，输出一个标签，多分类问题
核心环节： action feature extraction：在原始视频中，使用特征提取模型在视频中提取有区分度的行为特征，输出适合分类的向量形式，该步骤是行为识别中至关重要的一步，特征向量的鲁棒性和区分度直接影响行为识别的准确率。action representation：根据某种规则将提取的行为特征有序地组织起来，使其具有更高层的表示意义action classification temporal action detection（action detection） 和action recognition只关注what相比，temporal action detection还多关注一个where问题，temporal action detection：action location + action recognition
核心环节： feature extraction：特征提取步骤从视频中提取动态和静态行为特征。proposal：提名机制筛选出行为可能发生的时间位置并记录classification：对提名片段上的行为特征进行分类 action segmentation 和action detection相比，action segmentation是frame-label的
action parsing 商汤提出的新问题，在一段动作视频中，定义一连串子动作（sub-action），动作解析即定位这些子动作的开始帧。该任务可更好的进行动作间和动作内部的视频理解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183ce5f7185e0dcd4845742bbc64937f/" rel="bookmark">
			【第2条】遇到多个构造器参数时要考虑使用构建器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当构造方法参数过多时使用builder模式 静态工厂和构造器有个共同的局限性:它们都不能很好地扩展到大量的可选参数。比如用一个类表示包装食品外面显示的营养成分标签。这些标签中有几个域是必需的:每份的含量、每罐的含量以及每份的卡路里。还有超过20个的可选域:总脂肪量、饱和脂防量、转化脂防、胆固醇、钠，等等。大多数产品在某几个可选域中都会有非零的值。
对于这样的类，应该用哪种构造器或者静态工厂来编写呢?程序员一向习惯采用重叠构造器（telescoping constructor）模式，在这种模式下，提供的第一个构造器只有必要的参数，第二个构造器有一个可选参数，第三个构造器有两个可选参数，依此类推，最后一个构造器包含所有可选的参数。下面有个示例，为了简单起见，它只显示四个可选域：
public class NutritionFacts { private final int servingSize; // (mL) required private final int servings; // (per container) required private final int calories; // (per serving) optional private final int fat; // (g/serving) optional private final int sodium; // (mg/serving) optional private final int carbohydrate; // (g/serving) optional public NutritionFacts(int servingSize, int servings) { this(servingSize, servings, 0); } public NutritionFacts(int servingSize, int servings, int calories) { this(servingSize, servings, calories, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat) { this(servingSize, servings, calories, fat, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) { this(servingSize, servings, calories, fat, sodium, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/183ce5f7185e0dcd4845742bbc64937f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c475a4a87f39295371cbd5d4043ef95/" rel="bookmark">
			数据结构和算法：11.二叉树序列化、优先级队列和堆排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树序列化、优先级队列和堆排序 1. 二叉树的序列化和反序列化1.1 序列化1.2 反序列化 2. 优先级队列3. 堆排序(升序采用大根堆，降序采用小根堆) 具体代码请看：NDKPractice项目的datastructure36heapsorting
1. 二叉树的序列化和反序列化 1.1 序列化 /** * 序列化 */ void serializeTree(TreeNode&lt;char&gt; *pNode, string &amp;str) { if(!pNode){ str.append("#"); return; } // 先添加根节点 str.append(string(1,pNode-&gt;data)); // 再左节点 serializeTree(pNode-&gt;left,str); // 再右节点 serializeTree(pNode-&gt;right,str); } 1.2 反序列化 /** * 反序列化 (ABD##E##C#F##) * 注意：必须要传 2 级指针，如果是一级指针这只是传过来的数组，++的时候是不会对数组有影响的 */ TreeNode&lt;char&gt; *deserializeTree(char **str) { if(**str == '#'){ *str += 1; return NULL; } TreeNode&lt;char&gt; *node = new TreeNode&lt;char&gt;(**str); *str += 1; // 解析左边的 node-&gt;left = deserializeTree(str); // 解析右边的 node-&gt;right = deserializeTree(str); return node; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c475a4a87f39295371cbd5d4043ef95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f0260693be66a94f13d7bcf38a4b110/" rel="bookmark">
			qt的反射用法（新版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qt的反射用法，直接上代码
Animal.h
#ifndef ANIMAL_H #define ANIMAL_H #include&lt;QString&gt; #include&lt;QObject&gt; class Animal : public QObject{ //Q_OBJECT，这个为什么注释，因为后面发现一只提示方法重复定义，所以取消父类的标记 public: explicit Animal(QObject *parent = 0); //Animal(); virtual QString getName() const=0; virtual int getAge() const=0; }; #endif // ANIMAL_H Animal.cpp
#include "Animal.h" Animal::Animal(QObject *parent) : QObject(parent) { } Dog.h
#ifndef DOG_H #define DOG_H #include"Animal.h" //#include&lt;QString&gt; //#include&lt;QObject&gt; class Dog : public Animal{ Q_OBJECT Q_PROPERTY (QString name READ getName WRITE setName); Q_PROPERTY (int age READ getAge WRITE setAge); Q_ENUMS(Type); public: Q_INVOKABLE Dog(); Q_INVOKABLE void setAge(const int age); Q_INVOKABLE void setName(const QString&amp; name); Q_INVOKABLE QString getName() const; Q_INVOKABLE int getAge() const; enum Type{ ERHA,SHAMOYE,ALASIJI,TIANYUAN }; Q_INVOKABLE Type getType() const; Q_INVOKABLE void setType(Type suit); QString getTypeString(); private: Type type; QString name; int age; }; Dog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f0260693be66a94f13d7bcf38a4b110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8b2e141fb224cb2dcbcee03fa03e69d/" rel="bookmark">
			JQuery文档操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.内部添加
1.在指定元素内部底部添加
// 在指定元素内部底部添加 $('.parent').append($son); $son.appednTo('.parent')); 2.在指定元素内部顶添加
// 在指定元素内部顶添加 $('.parent').prepend($son); $son.prependTo('.parent')); 2.外部添加
3.在指定元素外部的前面添加元素
// 在指定元素外部的前面添加元素 $('.parent').after($son); $son.insertAfter('.parent')); 4.在指定元素外部的前面添加元素
// 在指定元素外部的后面添加元素 $('.parent').before($son); $son..insertBefore('.parent')); 3.删除节点
// 删除指定节点 $('div').remove(); // 删除指定节点中含有 .active 类的节点 $('div').remove('.active'); // 删除指定节点的内容与子元素 $('div').empty(); // 删除指定节点 $('div').detach(); $('div').detach('.active'); PS
remove与detach的区别：
remove不仅会清除指定节点，节点上绑定的事件、数据也会一并清除；
detach只会清除节点，绑定的事件以及数据不会被清除。
替换节点
&lt;h1&gt;h1&lt;/h1&gt; &lt;h1&gt;h1&lt;/h1&gt; let $h6 = $('&lt;h6&gt;h6&lt;/h6&gt;'); $('h1').replaceWith($h6); $h6.replaceAll('h1'); 克隆节点
1.浅复制，只会复制内容，不会复制事件
// 浅复制，只会复制内容，不会复制事件 let $newDiv = $('div').clone(false); 2.深复制，即会复制内容，也会复制事件
// 深复制，即会复制内容，也会复制事件 leT $newDiv = $('div').clone(true); 内容操作：
html() 该方法获取html元素的内容，如：var var1=$(“p”).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8b2e141fb224cb2dcbcee03fa03e69d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87382c2fc942fd2483bb822494dfedd8/" rel="bookmark">
			ElementUI如何拿到table里每一行的数据status
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中表格里有一列option，根据status的状态，显示或者隐藏button 1、button的显示与隐藏，样式如下：status是active的，后面才有可点击的uploadbutton，否则没有~ 2、通过console.log 拿到res数据,进而操作数据
可以看到，active对应的字段是userStatus
3、拿到每一行的数据，判断userStatus的值，控制button的显示与隐藏
本人亲测，ok
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf4159c9b7eae1c7c9aefb66b111d620/" rel="bookmark">
			Android -- Demo（三） 循环任务的三种实现方法：Timer， Thread,  Handler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android – Demo（三） 循环任务的三种实现方法：Timer， Thread, Handler 源代码：
public class Demo_Loop_Task_Activity extends AppCompatActivity implements View.OnClickListener { private static final long INTERVAL_TIMER = 3 * 1000l; private static final long INTERVAL_THREAD = 5 * 1000l; private static final long INTERVAL_HANDLER = 7 * 1000l; private static final int MSG_CODE_TASK = 0; private static final int MSG_CODE_ADD_LOG = 1; private TextView tvLog; private Button bStartTimer, bStartThread, bStartHandler; private Button bStopTimer, bStopThread, bStopHandler; private Timer timer; private TimerTask timerTask; private boolean cancelThread = true; private StringBuilder builder; private final String FORMAT = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf4159c9b7eae1c7c9aefb66b111d620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/540903f6fe16473982a00248f0f0b6d3/" rel="bookmark">
			python中引入名称中带有横杠模块的时候出现：SyntaxError: invalid syntax
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先使用pip3 list查看pyhton中存在哪些模块 通过上图可知，我们有模块de-core-news-sm
然后，在python中import带有横杠的模块的时候，会报错：SyntaxError: invalid syntax
Python 3.6.9 (default, Oct 8 2020, 12:12:24) [GCC 8.4.0] on linux Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import en-core-web-sm File "&lt;stdin&gt;", line 1 import en-core-web-sm ^ SyntaxError: invalid syntax 如果，如何在pyhton中引入*-*-*格式的模块呢？
答案是把*-*-*变成*_*_*的格式，即把横杠的位置从中间落到底部。
&gt;&gt;&gt; import en_core_web_sm &gt;&gt;&gt; 在本例中，把 import en-core-web-sm变为 import en_core_web_sm即可解决问题。
当然，同样也可以在spacy中使用：
spacy_de = spacy.load('de_core_news_sm') 参考：https://stackoverflow.com/questions/54334304/spacy-cant-find-model-en-core-web-sm-on-windows-10-and-python-3-5-3-anacon
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9c90a7194a94a24748800ce207c4f12/" rel="bookmark">
			1到2020的数字中有多少个2？C语言代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
int main()
{
int sum=0,i,j,n;
for (i = 1; i &lt;= 2020; i++)
{
for (j = i; j &gt; 0; j=j / 10)
{
n = j % 10;
if (n == 2)
{ sum++;
printf("%d\t", i);
}
}
}
printf("\n%d\n",sum);
return 0;
}
结果：624
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4058c828ec48da4ae3d91e49e4a33872/" rel="bookmark">
			SNMPWALK命令解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SNMPWALK SNMPWALK是一个通过SNMP GET-NEXT类型PDU，实现对目标AGENT的某指定MIB分支信息进行完整提取输出的命令工作。
命令行：
snmpwalk [选项] agent [oid] 选项参数：
由于SNMP协议中，不同的协议版本存在不同的参数选项，以下参数按协议分开说明。
1. 普通选项
a) –h 显示帮助
b) –v 1|2c|3 指定SNMP协议版本
c) –V 显示当前SNMPWALK命令行版本
d) –r RETRIES 指定重试次数，默认为0次。
e) –t TIMEOUT 指定每次请求的等待超时时间，单为秒，默认为3秒。
f) –Cc 指定当在WALK时，如果发现OID负增长将是否继续WALK。
2. V1、V2C选项
a) –c COMMUNITY 指定共同体字符串
3. V3选项
a) –l LEVEL 指定安全级别：noAuthNoPriv|authNoPriv|authPriv
b) –u USER-NAME 安全名字
c) –a PROTOCOL 验证协议：MD5|SHA。如果-l指定为authNoPriv或authPriv时才需要。
d) –A PASSPHRASE 验证字符串。如果-l指定为authNoPriv或authPriv时才需要。
e) –x PROTOCOL 加密协议：DES。如果-l指定为authPriv时才需要。
f) –X PASSPHRASE 加密字符串：如果-l指定为authPriv时才需要。
示例：
1. SNMPWALK V1版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4058c828ec48da4ae3d91e49e4a33872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/784ca948a20dd77217081f5cd0181783/" rel="bookmark">
			【技巧】windows 和Linux 检验paddlepaddle百度深度学习框架是否安装成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当按照一些指示在线或者离线方式安装百度深度学习框架paddlepaddle时，
如何知道自己是否安装好了呢？很简单！
命令行中进入python环境，敲下如下代码
&gt;&gt;&gt;import paddle.fluid as fluid &gt;&gt;&gt;fluid.install_check.run_check() 将出现一些提示信息，成功的末尾的信息如下：
.... Your paddle Fluid works well on MUTIPLE GPU or CPU. Your paddle Fluid Fluid is installed successfully! Let's start deep Learning with Paddle Fluid now 本人是通过离线whl安装了paddle,在Windows和linux上均实验成功，且安装了CPU版本和GPU版本。
如有问题欢迎留言，或者私我微信:ai_hellohello
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa577f82e06d9ba71df3d116a41eaef/" rel="bookmark">
			织梦搭网站-漏洞复现&#43;漏洞影响范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介漏洞复现环境安装DeDeCMS下载渗透测试环境准备需要的phpstudy下载DeDeCMS安装dedecms DeDeCMS（织梦）建站复现过程漏洞影响范围 简介 织梦内容管理系统(DedeCms) 以简单、实用、开源而闻名，是国内 最知名的 PHP 开源网站管理系统，也是使用用户最多的 PHP 类 CMS 系统， 在经历多年的发展，目前的版本无论在功能，还是在易用性方面，都有了长 足的发展和进步，DedeCms 免费版的主要目标用户锁定在个人站长，功能 更专注于个人网站或中小型门户的构建，当然也不乏有企业用户和学校等在 使用该系统。
漏洞复现环境 PHP 5.6
Apache 2.4.39
MySQL 5.7
DeDeCMS V5.7 SP2正式版(2018-01-09)
安装DeDeCMS 下载渗透测试环境准备需要的phpstudy 下载渗透测试环境准备需要的phpstudy：
phpstudy下载链接（点击）
跳转页面如图所示：
下载DeDeCMS 下载DeDeCMS
DeDeCMS下载链接（点击）
跳转页面如图所示：
安装dedecms 安装dedecms
先我们将下载好的安装包解压，然后再将uploads这个文件拷贝到D:\phpStudy_pro\WWW或者D:\PHPstudy\PHPTutorial\WWW里（格式统一这样子哟）
然后启动.phpstudy的apache与mysql
点击网站，再点击创建网站（www.+自己起的名字+com)
DeDeCMS（织梦）建站 运行 http://域名/install/index.php
域名是你所建的网站（如：www.ldfx.com)
输入网址 http://域名/install安装页面出现dir,没有出现安装界面怎么回事，把install文件夹下的index.html删掉，，你再看看install文件夹下有没有install_lock.txt 和index.php.bak 这2个文件，如果有把install_lock.txt 文件删掉，index.php.bak 改名改为index.php
填写参数配置
数据库密码为：root
恭喜你安装完成啦，但是还没有结束哟~
复现过程 登录网站后台
（在系统左边的最下面的那一项打开，就是上图的界面，把第一项的是否打开会员的否改为是） 再后退一步，并退出之前的admin帐号，重新注册一个test的帐号
注册测试账户 test，并不设置安全问题
成功啦：
这个是我自己根据老师和大佬的提示的操作过程，希望能帮到大家！搭网站虽然是个枯燥的过程，但过程中也能学到很多，大家一起冲冲冲 * ^ *
漏洞影响范围 DeDeCMS基于PHP+MySQL的技术开发，支持Windows、Linux、Unix等多种服务器平台，从2004年开始发布第一个版本开始，至今已经发布了五个大版本。DedeCms以简单、健壮、灵活、开源几大特点占领了国内CMS的大部份市场，目前已经有超过二十万个站点正在使用DedeCms或居于 DedeCms核心，是目前国内应用最广泛的php类CMS系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fa577f82e06d9ba71df3d116a41eaef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59545093b96606f0c951e49d56847933/" rel="bookmark">
			Java中的binarySearch方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是雄雄，今天我们来看看java中的binarySearch方法！
前言：我们都知道，如果我们想要在一个集合中查找某个元素所在的位置时，可以使用list类自带的indexOf方法，简单方便还快捷。不过，Collections类也给我提供了个查找集合中元素的方法——binarySearch，但是这个方法和indexOf方法无论从检索原理还是返回值上来说，都有很大的差距！
IndexOf方法 我们先来看看indexOf是怎么检索集合内元素的，示例代码如下：
public static void main(String[] args) { List&lt;Integer&gt; lists = new ArrayList&lt;Integer&gt;(); lists.add(3); lists.add(6); lists.add(8); lists.add(7); lists.add(1); System.out.println("集合中的元素："); for (Integer str : lists) { System.out.print(str+" "); } int index = lists.indexOf(2); System.out.println("\n2所在的位置是："+index); } 其运行结果：
下面我们再来查找一下“8”所在的位置，稍微改一下代码：
int index = lists.indexOf(8);
其运行结果如下：
两个案例说明不了问题，我们再来一个，比如查找一下“4”
这下很清楚,使用indexOf方法查找集合中的元素，简单方便，如果有，返回该元素的下标（下标从0开始），如果没有，则返回的是-1。
binarySearch方法 binarySearch方法采用二分法的方式来对集合元素进行检索，二分法搜索说的简单点，就是“折半折半再折半”！简单，而且在效率方面要比idnexOf的方法要高出不少！下面我们就来看看binarySearch方法是如何检索数据的。
首先，需要说明的是，使用binarySearch方法检索（二分法）的前提是要对集合内数据进行排序，否则返回的值是不准确的！要是不排序，怎么能知道值是在比中间值小的区域或者比中间值大的区域呢？
下面我们使用代码来看看：
public static void main(String[] args) { List&lt;Integer&gt; lists = new ArrayList&lt;Integer&gt;(); lists.add(3); lists.add(6); lists.add(8); lists.add(7); lists.add(1); // 原来的集合 System.out.println("原来的集合："); for (Integer str : lists) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59545093b96606f0c951e49d56847933/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b518f1f4bf3957f07730763f714d21/" rel="bookmark">
			es6的重点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		promise对象
因为回调地狱
一种是各种回调函数互相依赖，关系错综复杂，容易在造成错误
另一种是各种回调里嵌套各种回调，关系错综复杂，麻烦的很
为了解决这种问题promise就来了
三种状态：pending 初始状态 fullfilled 成功状态 rejected 失败状态 再恰当时机就会改变成成功或失败
*****promise是同步的，遇到了直接等待执行就可以，不需要像异步一样跳过然后再回来的时候回调。
let pormise = new Promise((res,rej)=&gt;{
//初始化promise状态：pending
console.log(‘111’)
***
//一般这个时候都要执行异步操作，通常是发送ajax请求，开启定时器（因为这个地方下写的异步就res，rej两种结果所以使回调变得简单）
setTimeout(()=&gt;{
console.log(‘333’)
//根据异步任务的返回结果来修改promise的状态
//异步任务执行成功
res(‘this is success’); //修改promise状态为fullfilled
//异步执行失败
rej(‘this is defeat’) //修改promise状态为rejected失败 注意两者只能执行一个
},2000)
})
console.log(‘222’)
promise.then((data)=&gt;{console.log(data,‘succes’)},(err)=&gt;{console.log(err,‘defeat’)}) //promise的回调会产生两个函数前者是成功的回调如果状态为fullfilled则执行第一个箭头函数
状态为rejected则执行第二个回调函数
.then可以链式操作，前提是前面的then返回一个promise对象供其接收
*****前面res和rej里面可以传递参数给后面promise的回调接收。
–111-222-333
***ajax里的success和error也是这个思想
promise练习
function getNews(url){
let promise = new Promise((res,rej)=&gt;{
//发送ajax请求（这个地方用原生的）
let xmlHttp = new XmlHttpRequest()
xmlHttp.onreadystatechange = function(){ //原生的话这个方法是监听ajax的状态改变一共有0-4 5种状态
if(xmlHttp.responseText=4){
if(xmlHttp.status200){
res(xmlHttp.responseText) //获取到的数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02b518f1f4bf3957f07730763f714d21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea4e35cb89153a16b3ccff18d52301bb/" rel="bookmark">
			【组合数学】 普通型母函数（整数拆分问题，多重集的组合问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.母函数概念2.普通型母函数3. 整数拆分问题（多重集的组合问题）4.母函数是如何应用于多重集组合问题的？5.模板（数N的划分方案数）6.练手题目 1.母函数概念 母函数是数学中的一个概念，又称为生成函数，是计数方面的一个重要理论和工具。
母函数分为普通型母函数和指数型母函数，前者用于解决多重集的组合问题，后者用于解决多重集的排列问题。
多重集可以理解为同一个元素可以出现多次的集合
2.普通型母函数 简单来说：
对于一个序列 a 0 , a 1 , a 2 , ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ a n a_0,a_1,a_2,\cdot\cdot\cdot\cdot\cdot\cdot a_n a0​,a1​,a2​,⋅⋅⋅⋅⋅⋅an​，我们称 a 0 a_0 a0​+ a 1 x a_1x a1​x+ a 2 x 2 a_2x^2 a2​x2 ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ + a n x n \cdot\cdot\cdot\cdot\cdot\cdot+a_nx^n ⋅⋅⋅⋅⋅⋅+an​xn为该序列的普通型母函数
3. 整数拆分问题（多重集的组合问题） 给定一个数N，问N有几种划分方式。
比如N=4，则有：
4 = 4；
4 = 3 + 1；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea4e35cb89153a16b3ccff18d52301bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4df195c5c58ee2c1fd303030f3167155/" rel="bookmark">
			python文件可以用什么软件打开-py文件用什么可以打开.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2005-02-25
请问你们的PY可以用吗？我的不显示啊，急
。。。。。。。。 8888:::::::::::顶 888888。。。。。。。。 888888::::::::顶 8。。。。。。。。。 888888::::::顶 888。。。。。 。。。 ::88888:::::顶 88888。。。。。。 8:::88888::::顶 8888。。。。。 8:::88888::::顶::*顶*o: 88。。。。 8:::8888:::::顶::::::::::: 8 8。 。。 8::::88::::::顶::::::::::::: 8。。 888:::8::::::顶::aAa::::::::顶 8。888。。 88::88:...全部
。。。。。。。。 8888:::::::::::顶 888888 。。。。。。。。 888888::::::::顶 8 。。。。。。。。。 888888::::::顶 888 。。。。。
。。。 ::88888:::::顶 88888 。。。。。。 8:::88888::::顶 8888 。。。。。 8:::88888::::顶::*顶*o: 88 。。。。 8:::8888:::::顶::::::::::: 8 8 。
。。 8::::88::::::顶::::::::::::: 8 。。 888:::8::::::顶::aAa::::::::顶 8 。888。。 88::88::::8:::::顶::::::::::::: 888888 。
88。。 888:::8:::::::::顶:::::::::::: 8 。8。。 88888:::::::::::顶::"@@@@@@@"::::顶 。。 888:888::::::::::顶:::::"@a@":::::顶 88 。
88::::88:::::::::顶88:::::::::::::顶 8888 :::::8:::::::::顶88888:::::::::顶 :::::8:::::::::顶 顶顶顶顶 8888 888888。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4df195c5c58ee2c1fd303030f3167155/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9bc27c4841507c7e832583052af04f1/" rel="bookmark">
			python循环语句-详解Python中的循环语句的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介
Python的条件和循环语句，决定了程序的控制流程，体现结构的多样性。须重要理解，if、while、for以及与它们相搭配的 else、 elif、break、continue和pass语句。
二、详解
1、if语句
Python中的if子句由三部分组成：关键字本身、用于判断结果真假的条件表达式以及当表达式为真或者非零时执行的代码块。if 语句的语法如下：
if expression:
expr_true_suite
if 语句的expr_true_suite代码块只有在条件表达式的结果的布尔值为真时才执行，否则将继续执行紧跟在该代码块后面的语句。
（1）多重条件表达式
单个if语句可以通过使用布尔操作符and、or和not，实现多重判断条件或是否定判断条件。
（2）单一语句的代码块
如果一个复合语句（例如if子句、while或for循环）的代码块仅仅包含一行代码，那么它可以和前面的语句写在同一行上。如if make_hard_copy: send_data_to_printer()，这样的单行语句是合法的， 尽管它可能方便，但这样会使得代码更难阅读， 所以推荐将这行代码移到下一行并合理地缩进。另外一个原因就是如果你需要添加新的代码, 你还是得把它移到下一行。
2、else语句 Python提供了与if语句搭配使用的else语句，如果if语句的条件表达式的结果布尔值为假，那么程序将执行 else 语句后的代码。其语法如下：
if expression:
expr_true_suite
else:
expr_false_suite
在C语言中，不会在条件语句范围外发现else语句， 但Python不同，可以在while和for循环中使用else语句，在循环中使用时，else子句只在循环完成后执行，也就是说break语句也会跳过else块。
例：显示出10到20中的数字的最大约数
在CODE上查看代码片派生到我的代码片
#!/usr/bin/env python
def showMaxFactor(num):
count = num / 2
while count &gt; 1:
if (num % count == 0):
print 'largest factor of %d is %d' % (num, count)
break
count = count - 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9bc27c4841507c7e832583052af04f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4616d2f5db450c97ab5427d835d9fd5/" rel="bookmark">
			FPGA 频率计实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：正点原子开拓者 FPGA 开发指南
数字频率计是一种基本的测量仪器，被广泛应用于航天、电子、测控等领域。基于传统测频原理的频率计的测量精度将随被测信号频率的下降而降低，在使用中有较大的局限性，而等精度频率计不但具有较高的测量精度，而且在整个频率区域能保持恒定的测试精度。
一、等精度频率计简介 频率测量在电子设计和测量领域中经常用到，因此对频率测量方法的研究在实际工程应用中具有重要意义。常用的频率测量方法有两种：周期测量法和频率测量法。
周期测量法是先测量出被测信号的周期T，然后根据频率f = 1/T求出被测信号的频率。频率测量法是在时间t内对被测信号的脉冲数N进行计数，然后求出单位时间内的脉冲数，即为被测信号的频率。 但是上述两种方法都会产生±1个被测脉冲的误差，在实际应用中有一定的局限性。根据测量原理，很容易发现周期测量法适合于低频信号测量，频率测量法适合于高频信号测量(因为周期越大或者频率越高那么所测得的周期或者脉冲数N的相对误差就会越小)，但二者都不能兼顾高低频率同样精度的测量要求。
等精度测量的一个最大特点是测量的实际门控时间不是一个固定值，而是一个与被测信号有关的值，刚好是被测信号的整数倍。在计数允许时间内，同时对基准时钟和被测信号进行计数，再通过数学公式推导得到被测信号的频率。由于门控信号是被测信号的整数倍，就消除了对被测信号产生的±l周期误差，但是会产生对基准时钟±1周期的误差。 等精度测量原理如下图所示：
从以上叙述的等精度的测量原理可以很容易得出如下结论：首先，被测信号频率clk_fx的相对误差与被测信号的频率无关；其次，增大测量时间段“软件闸门”或提高“标频”clk_fs，可以减小相对误差，提高测量精度；最后，由于一般提供基准时钟clk_fs的石英晶振稳定性很高，所以基准时钟的相对误差很小，可忽略。假设基准时钟的频率为100MHz，只要实际闸门时间大于或等于1s，就可使测量的最大相对误差小于或等于10^(-8)，即精度达到1/100MHz。等精度测量的核心思想在于如何保证在实际测量门闸内被测信号为整数个周期，这就需要在设计中让实际测量门闸信号与被测信号建立一定的关系。基于这种思想，设计中以被测信号的上升沿作为开启门闸和关闭门闸的驱动信号，只有在被测信号的上升沿才将上图中预置的“软件闸门”的状态锁存，因此在“实际闸门”Tx内被测信号的个数就能保证整数个周期，这样就避免普通测量方法中被测信号的±1的误差，但会产生高频的基准时钟信号的±l周期误差，由于基准时钟频率远高于被测信号，因此它产生的±1周期误差对测量精度的影响十分有限，特别是在中低频测量的时候，相较于传统的频率测量和周期测量方法，可以大大提高测量精度。
等精度测频的原理图如下图所示。图中，预置软件闸门信号GATE是由FPGA的定时模块产生，GATE的时间宽度对测频精度的影响较小，故可以在较大的范围内选择，GATE信号经被测时钟clk_fx同步化（图中的D触发器）到被测时钟域下。另外，为了方便处理，这里选择预置闸门信号的长度由参数GATE_TIME设置。图中的fs_cnt和fx_cnt是2个可控的32位高速计数器，fs_cnt_en和fx_cnt_en分别是其计数使能端，由同步化后的GATE信号控制，基准时钟信号clk_fs从时钟输入端clk_fs输入，待测信号clk_fx从时钟输入端clk_fx输入。测量时，生成的GATE信号，在被测时钟同步化后用来控制启动和关闭2个计数器，2个计数器分别对被测信号和基准时钟计数。若在一次实际闸门时间GATE_TIME中，计数器对被测信号的计数值为fx_cnt，对基准时钟的计数值为fs_cnt，而基准时钟的频率为CLK_FS，则被测信号的频率为clk_fx，则由公式：
二、实验任务 板载50MHz的时钟通过分频产生某一频率的时钟信号，作为被测时钟，然后用Verilog HDL编写的等精度测量模块测量被测时钟，并通过数码管显示。
三、程序设计 根据实验任务，我们可以大致规划出系统的控制流程：首先我们设计一个测试时钟模块用于生成被测的时钟，然后用等精度频率计模块测量被测时钟的频率，并将测得的时钟频率值送入数码管显示模块进行显示。由此画出系统的功能框图如下所示：
由系统框图可知，FPGA部分包括四个模块：顶层模块（top_cymometer）、等精度频率计模块（cymometer）、时钟产生模块（clk_test）、以及数码管显示模块（seg_led）。各模块功能如下：
顶层模块（top_cymometer）：顶层模块完成了对其它三个模块的例化，实现各模块之间的数据交互。时钟产生模块产生被测时钟输出，并从外部接入至等精度频率计模块，以进行频率测量，将测量的结果传输给数码管驱动模块进行显示。顶层模块的原理图如下图所示：
等精度频率计模块（cymometer）：等精度频率计模块测量输入的被测时钟的频率。并将测得的频率结果输出。
时钟产生模块（clk_test）：时钟产生模块产生被测的时钟。
数码管显示模块（seg_led）：将等精度频率计测得的时钟频率值在数码管上显示出来。
1、顶层模块的代码如下： module top_cymometer( //system clock input sys_clk , // 时钟信号 input sys_rst_n, // 复位信号 //cymometer interface input clk_fx , // 被测时钟 output clk_out , // 输出时钟 //user interface output [5:0] sel , // 数码管位选 output [7:0] seg_led // 数码管段选 ); //parameter define parameter CLK_FS = 26'd50000000; // 基准时钟频率值 //wire define wire [19:0] data_fx; // 被测信号测量值 //***************************************************** //** main code //***************************************************** //例化等精度频率计模块 cymometer #(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4616d2f5db450c97ab5427d835d9fd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb3c7ba526904ffc860643af98171245/" rel="bookmark">
			知识图谱嵌入经典方法（Trans系列、KG2E）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 知识图谱嵌入 相关内容部分来自：https://zhuanlan.zhihu.com/p/147542008，https://mp.weixin.qq.com/s/Cb-CP1Tf2bv_hlyusRN6zA，https://zhuanlan.zhihu.com/p/80149671
2. 知识表示的一些背景知识 通常，我们使用三元组(head, relation, tail)来表示知识。在这里，头和尾是实体。例如，(sky tree, location, Tokyo)。我们可以用独热向量来表示这个知识。但实体和关系太多，维度太大。当两个实体或关系很近时，独热向量无法捕捉相似度。受Wrod2Vec模型的启发，我们想用分布表示来表示实体和关系。
3. 下游任务的应用 连接预测
连接预测通常被称为预测某个实体与另一个给定实体是否具有特定关系的任务。比如，给定 h h h 预测 ( r , t ) (r,t) (r,t) 或者给定 t t t 预测 ( h , r ) (h, r) (h,r)，前者表示为 ( ? , r , t ) (?,r,t) (?,r,t)，后者表示为 ( h , r , ? ) (h,r,?) (h,r,?)。例如，(?, 导演,惊魂)，是预测电影的导演，(毒液,导演,?)，就是预测某个电影被某个人导演。这本质上是一个知识图谱的完善的任务。
推荐系统
推荐系统为用户提供他们可能想要购买或查看的物品的一些建议。在不同的推荐策略中，协同过滤技术取得了显著的成功。但是，并不总是有效，因为用户-物品的交互可能非常稀少。在这种情况下，混合推荐系统通常可以取得更好的性能，混合推荐系统将用户-物品的交互作用与用户或物品的辅助信息相结合。
利用知识图提高协同过滤的质量。具体来说，他们使用存储在KG中的三种类型的信息，包括结构化知识(三元组)、文本知识(例如，一本书或一部电影的文本摘要)和视觉知识(例如，一本书的封面或电影的海报图像)，来推导物品的语义表征。为了对结构化知识进行建模，提出了一种典型的知识图谱的嵌入技术。TransR 为每个物品学习了一个结构化的表示。对于另外两种类型的信息，可以使用堆叠去噪自动编码器和堆叠的卷积自动编码器分别提取物品的文本表示和视觉表示。
也有一些应用利用到了知识图谱的嵌入，如实体解析，关系提取，问题回答等。你可以从这篇文章中找到更多的信息：Knowledge Graph Embedding: A Survey of methods and Applications(2017)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb3c7ba526904ffc860643af98171245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b85bf78ac029b70003f6f44049c0c8a/" rel="bookmark">
			C&#43;&#43;类的静态成员和this指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态成员： 概述：C++类中的静态成员一共有两种，静态成员变量和静态成员函数，被关键字 static 声明为静态的，称为静态成员。 不管这个类创建了多少个对象，静态成员只 有一个拷贝，这个拷贝被所有属于这个类的对象共享。
静态成员变量：
在一个类中，若将一个成员变量声明为 static，这种成员称为静态成员变量。与一 般的数据成员不同，无论建立了多少个对象，都只有一个静态数据的拷贝。静态成 员变量，属于某个类，所有对象共享。 静态变量，是在编译阶段就分配空间，对 象还没有创建时，就已经分配空间。 静态成员变量必须在类中声明，在类外定义。 静态数据成员不属于某个对象，在 为对象分配空间中不包括静态成员所占空间。 静态数据成员可以通过类名或者对 象名来引用。
静态成员函数：
在类定义中，前面有 static 说明的成员函数称为静态成员函数。静态成员函数使用 方式和静态变量一样，同样在对象没有创建前，即可通过类名调用。静态成员函数 主要为了访问静态变量，但是，不能访问普通成员变量。 静态成员函数的意义， 不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封 装。静态成员函数只能访问静态变量，不能访问普通成员变量 静态成员函数的使用和 静态成员变量一样 静态成员函数也有访问权限 普通成员函数可访问静态成员变 量、也可以访问非静态成员变量。
静态成员形式如下：
class Person { public: int a;/*普通成员变量*/ static int b;/*静态成员变量声明*/ private: void test_fun()/*普通成员函数的定义*/ { cout &lt;&lt; "C++的普通成员函数"&lt;&lt;endl; } static void test_s_fun();/*静态成员函数的声明*/ }; /*静态成员变量的定义*/ int b = 10; /*静态成员函数的定义*/ void test_s_fun() { cout &lt;&lt; "C++类的静态成员函数"&lt;&lt;endl; } 注：静态成员函数和静态成员变量也是有访问权限的，类外不能访问private和protect权限的静态成员。
C++成员变量和函数存储 C++成员变量和函数分开存储的基础概念：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b85bf78ac029b70003f6f44049c0c8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/778deebe762a6c207379fc95417368e0/" rel="bookmark">
			python之class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python之class class 的定义格式 class的组成 名称： 类名，注意其首字母需要大写属性:一组数据方法：能进行操作的方法 class书写的格式 class 类名：
​ 类的属性
​ 类的方法
注意缩进
class 成员与方法 数据成员和成员方法 数据成员:创建类时用变量的形式表示对象特征的成员
成员方法:用函数的形式表示对象行为的成员
二者统称：类的成员
私有成员和公有成员 私有成员：在类的外部不能直接访问，可在内部访问，形式上，两个下划线开头但是不以两个下划线结束则表示是私有成员,对象名._类名__xxx 也可以在外部程序中访问私有成员。 self.__name = “name” 这是类中私有成员的书写方式
公有成员：可以公共访问的成员
额外补充：
_xxx：受保护成员；
xxx：系统定义的特殊成员；
__xxx：私有成员，只有类对象自己能访问，子类对象不能直接访问到这个成员，但在对象外部可以通过“对象名._类名__xxx”这样的特殊方式来访问。
成员方法、类方法、静态方法、抽象方法 方法一般指与特定实例绑定的函数，通过对象调用方法时，对象本身将被作为第一个参数自动传递过去，普通函数并不具备这个特点。
静态方法和类方法都可以通过类名和对象名调用，但不能直接访问属于对象的成员，只能访问属于类的成员。
静态方法和类方法不属于任何实例，不会绑定到任何实例，当然也不依赖于任何实例的状态，与实例方法相比能够减少很多开销。
类方法一般以cls作为类方法的第一个参数表示该类自身，在调用类方法时不需要为该参数传递值，静态方法则可以不接收任何参数。
抽象方法一般在抽象类中定义，并且要求在派生类中必须重新实现，否则不允许派生类创建实例。
类与对象的动态性、混入机制 python可以动态地为自定义类和对象增加或删除成员
Python类型的动态性使得我们可以动态为自定义类及其对象增加新的属性和行为，俗称混入（mixin）机制
例如系统中的所有用户分类非常复杂，不同用户组具有不同的行为和权限，并且可能会经常改变。这时候我们可以独立地定义一些行为，然后根据需要来为不同的用户设置相应的行为能力。
代码：
import types class Person(object):#括号中是派生的其它基类，若有多个用逗号隔开 _counts = 0 #受保护的变量 def __init__(self, color, name):#这是构造方法，当创建类的（实例）对象时，会自动调用，从而实现对类进行初始化操作 #self类似Java里面的this，代表对象自己。 #在类中的方法里self永远是第一个参数 self.url = "www.baidu.com" self.color = color self.__name = name Person.__name1 = "你好" self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/778deebe762a6c207379fc95417368e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ef0f29e174e4e54c22e930ef37f4405/" rel="bookmark">
			Balls poj3783(dp,最坏情况最优解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 poj3783 Balls 题意： 有一些鸡蛋，我们现在想知道这些鸡蛋的硬度。然后现在有一座很高很高的大楼里，我们现在要在这座大楼上测试鸡蛋的硬度。每个鸡蛋的硬度相同，鸡蛋的硬度定义为：如果鸡蛋从第 m 层上掉下来没有破裂，而从第 m+1 层上掉下来就破裂了，那么这个鸡蛋的硬度就是 m 。某个鸡蛋如果在实验中破裂了就永远的损失了。我们现在有 n 个鸡蛋。那么在最坏情况下我们最少需要做多少次实验呢？
思路： 这是一个很经典的dp问题，设dp[n,m]是第i层楼，有k个鸡蛋时找到符合条件的最少测试次数
则一个鸡蛋从第 i 层扔下，如果碎了，还剩 m−1 个鸡蛋，为确定下面楼层中的安全位置，还需要dp[i−1,m−1] 次（子问题）；不碎的话，上面还有 n−i 层，还需要 dp[n−i,m]次（子问题，实体 n 层楼的上 n−i 层需要的最少判断次数和实体 n−i 层楼需要的最少判断次数其实是一样的）
这里因为是要找最坏情况的最优解
所以在遍历每层楼的时候，应该要选择每一层楼中两种情况的最大值，然后再去比较其中的最小值
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define __int128 LL using namespace std; typedef long long ll; const int mod = 1e9; const int maxn = 1e3 + 5; const int INF = 1e9 + 7; int dp[maxn][60];//dp[i][j]:表示在 i 层楼 还有 j 个鸡蛋的最小判断次数 void DP(int n,int m) { memset(dp,0,sizeof dp); //对于一个鸡蛋，只能一层一层的试 for(int i = 1; i &lt;= n; i++){ dp[i][1] = i; } //对于只有一层,肯定有且仅有一次 for(int i = 1; i &lt;=m; i++){ dp[1][i] = 1; } for(int i = 1; i &lt;= n; i++){ for(int j = 2; j &lt;= m; j++){ dp[i][j] = i;//初始最坏结果是i次 for(int k = 1; k &lt;= i; k++) dp[i][j] = min(dp[i][j] ,max(dp[k - 1][j - 1] + 1,dp[i - k][j] + 1)); } } } int main() { int t; cin&gt;&gt;t; while(t--){ int op,n,m; cin&gt;&gt;op&gt;&gt;m&gt;&gt;n; DP(n,m); cout&lt;&lt;op&lt;&lt;' '&lt;&lt;dp[n][m]&lt;&lt;endl; } return 0; }``` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970f97e04cabbaa127a0bad1ead69e2e/" rel="bookmark">
			组合逻辑的毛刺与消除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#毛刺
任何信号在FPGA 器件内部通过连线和逻辑单元都会有一定的延时，正如通常所说的走线延时和门延时。延时的大小与连线的长短、逻辑单元的数目有关，同时受器件本身的制造工艺、工作电压、温度等条件的影响。信号的高低电平转换也需要一定的上升时间和下降时间。由于存在诸多因素的影响，多个信号的电平值发生变化时，在信号变化的瞬间，组合逻辑的输出并非同时，而是有先有后，因此往往会出现一些不正确的信号，比如一些很小的尖端脉冲信号，称之为“毛刺”。如果一个组合逻辑电路中有毛刺出现，那么就说明该电路中存在“冒险”。
#消除毛刺的方法
通常有两个办法消除毛刺，一个是并联一个电容，将脉冲很小的毛刺滤除。另一种方法是引入时序逻辑，用寄存器多输出信号打一拍，这其实也是时序逻辑优于组合逻辑的特性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1972a22f9636f1c27d2861c2198b45e2/" rel="bookmark">
			使用OpenCV实现图像覆盖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		颜色通道说明 每张图像都包括RGB三个通道，分别代表红色、绿色和蓝色，使用它们来定义图像中任意一点的像素值，红绿蓝的值在0-255之间。
例如：一个像素值[255,0,0]代表全部为红色，像素值[255, 255，0]是红色和绿色的混合，将显示为黄色。
但是，如果使用OpenCV读取图像，它将以BGR格式生成图像，那么[255,0,0]将代表蓝色。
使用OpenCV读取一张图像 任何图像都可以通过OpenCV使用cv2.imread()命令读取。不过，OpenCV不支持HEIC格式的图像，所以不得不使用其它类型的库，如Pillow来读取HEIC类型的图像（或者先将它们转换为JPEG格式）
img = cv.imread('image.png') 当读取图像之后，如果有必要的话可以将其从BGR格式转换为RGB格式，通过使用cv2.cvtColor()命令实现。
# 图片转换为RGB模式 img_rgb = cv.cvtColor(img, cv.COLOR_BGR2RGB) # 图片转换为灰度图 img_gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY) 覆盖 图像可以看作是是一堆像素值以类似矩阵的格式存储。任何像素的值都可以独立于其他像素进行更改。这里有一张图像，使用OpenCV读取图像：
打印图片可以得到一系列类矩阵数据：
[[[107 108 105] [107 108 105] [107 108 105] ... [ 77 78 75] [ 77 78 75] [255 255 255]] [[107 108 104] [107 108 104] [107 108 104] ... [ 77 78 75] [ 77 78 75] [255 255 255]] [[107 108 104] [107 108 104] [107 108 104] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1972a22f9636f1c27d2861c2198b45e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f11b1430ef498092e0aaa4fc9c44f6/" rel="bookmark">
			签名体制的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比较RSA签名体制和EIGamal签名体制的异同 相同点：都能用于加密，也能用于数字签名
不同点：（1）RSA的安全性依赖于大数分解，EIGamal的安全性主要依赖于p和g
（2）EIGamal体制中的随机参数的取值每次均不同，所以即使使用相同的私钥对相同的明文进行加密，每次加密后得到的签名也各不相同，而RSA体制产生密钥较麻烦，受到素数的影响，因而难以做到一次一密
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00bd07e8d50e5bdf87068e9d5af76d7b/" rel="bookmark">
			漏洞复现实验报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞复现实验报告
一、 概述
1.1项目背景
织梦内容管理系统(DedeCms) 以简单、实用、开源而闻名，是国内最知名的 PHP 开源网站管理系统，也是使用用户最多的 PHP 类 CMS 系统，在经历多年的发展，目前的版本无论在功能，还是在易用性方面，都有了长足的发展和进步，DedeCms 免费版的主要目标用户锁定在个人站长，功能更专注于个人网站或中小型门户的构建，当然也不乏有企业用户和学校等在使用该系统。 2018 年 1 月 10 日，锦行信息安全公众号公开了一个关于 DeDeCMS前台任意用户密码修改漏洞的细节。2018 年 1 月 10 日，Seebug 漏洞平台收录该漏洞，漏洞编号为 SSV-97074，知道创宇 404 漏洞应急团队成功复现该漏洞。
1.2实施目的
（1）熟悉用DeDeCMS搭建网站；
（2）熟悉Burp工具的使用方法；
（3）会使用工具进行主机漏洞的抓包；
（4）通过实验了解如何提高主机的安全性；
漏洞是指用户的Windows操作系统程序或者其它应用程序在逻辑设计上的缺陷或在编写时产生的错误，这个缺陷或错误可能被不法者或者电脑黑客利用，通过植入木马、病毒等方式来攻击或控制电脑，窃取用户电脑中的重要资料、信息以及虚拟财产等，甚至会破坏整个系统。漏洞复现的目的在于便于我们发现漏洞以及及时修复漏洞。而修复漏洞最基本的目的是及时有效的修复系统、软件漏洞，避免黑客通过植入木马\病毒等方法控制用户的电脑，窃取账号、密码等重要信息。保障用户的电脑安全。
我们相信，凭借小组成员的共同努力，能够圆满地完成本次漏洞复现测试实验。同时，我们也希望能通过这次实验加深对网络信息安全的了解并怀着浓厚的兴趣参与到更多的网络渗透实验中去。
1.3服务目标
脚踏实地小组在本次漏洞复现测试实验中将达到以下目标：
（1）通过漏洞复现测试全面检测织梦内容管理信息系统直接暴露在互联网上的安全隐患，并提供实际可行的安全修复建议；
（2）通过本次测试实验使小组全体成员对漏洞复现有了全方面的认识。
二、 漏洞复现测试介绍
2.1漏洞复现实验原理
漏洞复现实验过程主要依据已掌握的安全漏洞信息，打开浏览器访问我们在DeDeCMS上自行搭建的网站，对指定的文件进行修改或者删除，再次访问该网，通过抓包原理，实现漏洞复现。
2.2漏洞复现实验流程
方案制定
脚踏实地小组在指导老师的带领下，开始进行对漏洞复现测试实验的实施。并且将实施范围、方法、时间、人员等具体的方案与指导老师进行交流，并得到了指导老师的认同。
在实验实施之前，我们进行了小组成员的明确分工：
2.3渗透测试的风险规避
在渗透测试过程中，虽然我们会尽量避免出现系统崩溃的操作，也会实施风险规避的计策，但是由于测试过程变化多端，渗透测试服务仍然有可能对网络、系统运行造成一定不同程度的影响，严重的后果是可能造成服务停止，甚至是宕机。比如测试人员实施漏洞抓包操作时，突遇系统崩溃，可能会出现原本的浏览器无法使用等。
因此，我们会在渗透测试前详细地讨论了渗透方案，并采取如下多条策略来规避渗透测试带来的风险：
（1）测试策略：
为了防范测试意外中断，在非常不解的领域我们不做深入的测试，避免意外崩溃而造成不可挽回的损失；测试过程中，最终结果可以由测试人员做推测，而不实施具体操作步骤加以验证。
（2）备份策略：
为防范渗透过程中的异常问题，测试时我们事先做了一个完整的数据备份，并且我们在进行漏洞复现测试时采用三人同时进行测试的方法，以便在问题发生后能及时备份数据恢复工作。
（3）应急策略：
测试过程中，如果目标系统出现浏览器无响应、中断或者崩溃等情况，我们会立即中止渗透测试，并进行修复处理等。在确认问题、修复系统、防范此故障再重演后，再继续进行其余的测试。
在本次测试中我们出现了浏览器崩溃的情况，如下图显示：
庆幸的是，我们最终解决了这个意料之中的问题。
2.4渗透测试的收益
1.安全缺陷：
从攻击者的角度发现了DeDeCMS的角度安全系统防护存在的漏洞，为其下一步安全系统升级维护提供了方向。
2.测试报告：
能帮助DeDeCMS以实际案例的形式来说明目前安全现状，从而增加其对信息安全的认知度，提升维护人员的风险危机意识，从而实现内部安全等级的整体提升。
（以上是通过DeDeCMS的漏洞直接进入管理者界面）
2.5渗透工具介绍
2.5.1 系统自带工具
1.System
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00bd07e8d50e5bdf87068e9d5af76d7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b187cdaa2fe6718a07efe3ad241bb4d/" rel="bookmark">
			使用webpack打包nodejs 后台端环境|NodeJs 打包后台代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用webpack打包nodejs 后台端环境
第一步、安装webpack包，初始化项目应用
npm install webpack webpack-cli --save-dev 第二步、修改编译配置
1.增加webpack.config.js文件，配置输入输出，重点制定target 运行环境为node
const path = require('path'); module.exports = { entry: './src/main.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, target: 'node' // 这是最关键的 }; 2.修改 package.json 的编译命令： "build":"webpack"
{ "name": "Test4", "version": "1.0.0", "description": "", "main": "index.js", "dependencies": { "webpack": "^5.3.2", "webpack-cli": "^4.1.0" }, "devDependencies": {}, "scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "build":"webpack" }, "keywords": [], "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b187cdaa2fe6718a07efe3ad241bb4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0ebdaf808fd040b89e037dbe33b33d0/" rel="bookmark">
			meshroom在不使用显卡的情况下，通过命令行进行三维重建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		meshroom在不使用显卡的情况下，通过命令行进行三维重建 背景思路具体步骤结语参考文章 背景 meshroom是一个开源的三维重建软件。meshroom默认配置是需要通过使用显卡进行处理来进行三维重建。
但是目前遇到了这样的需求：需要在一个没有GPU的服务器上将其作为服务的一个功能模块，来自动处理用户发过来的请求，并进行三维建模。这是就需要我们进行一些设置来实现meshroom在不使用显卡的情况下，通过命令行进行三维重建。
思路 首先我们可以通过搜索关键词meshroom without gpu，可以找到官方文档对于这种情况的解决方法。文档中Draft Meshing部分说明可以通过删除整个三维重建流程中的部分节点来避免使用显卡处理。
其次，在meshroom软件中的meshroom_photogrammetry命令行程序中有一个参数-p( --pipeline photogrammetry/panoramaHdr/panoramaFisheyeHdr/MG_FILE)，可以通过设置该参数对该命令行的具体执行过程进行设置。可以通过上一部分的方法，在图形界面中将三维重建的节点进行设置后导出.mg文件，然后再命令行中使用参数-p设置该文件路径从而实现meshroom在不使用显卡的情况下，通过命令行进行三维重建。
具体步骤 设置节点文件
打开meshroom图形界面，下方多个矩形连接的区域就是三维重建的节点图。这些节点表示三维重建过程具体要执行的步骤。
删除图中的PrepareDenseScene， Depthmap 和 DepthmapFilter三个节点。连接节点StructureFromMotion 的output到Meshing的input再最后添加上Publish节点，并将Texturing的outputMesh、outputMaterial、outputTextures连接到Publish的inputFiles上。
（PS:加入 Publish 节点是对应命令行程序必须要执行这一步；如果在图形界面中进行三维重建则可以不需要该节点） 完成上述步骤后节点图如下图所示：
导出.mg文件，通过命令行执行对应程序并加上相应参数，meshroom则可以在不使用显卡的情况下，通过命令行进行三维重建。
命令样例如下： meshroom_photogrammetry.exe --input pathToInput --output pathToOutput -p pathToMgFile 结语 该方法可以在没有显卡的情况下进行三维重建。但是在没有推过上述需要GPU的三个步骤处理得到的效果要差上许多，所以还是尽可能在有支持CUDA的显卡的情况下进行三维重建。
参考文章 在服务器上使用meshroom进行3D重建 https://zhuanlan.zhihu.com/p/82556459
Can I use Meshroom without an NVIDIA GPU? https://meshroom-manual.readthedocs.io/en/latest/faq/needs-cuda/needs-cuda.html
Draft Meshing https://github.com/alicevision/meshroom/wiki/Draft-Meshing
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90ac7132e013f6ccccac1e22adada80c/" rel="bookmark">
			Hi3559AV100芯片内部温度检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		芯片集成温度传感器(T-Sensor)，用于获取芯片内部温度。
参考文档 《Hi3559A╱C V100 ultra-HD Mobile Camera SoC 用户指南.pdf》3.12.5.2 工作方式，芯片内部温度检测。
采集模式 MISC 寄存器基址是 0x1203_0000。MISC_CTRL28 为 Tsensor 控制寄存器，Offset Address: 0x0070，设置循环采集。
采集周期 设置采集周期10ms
开始采集 读取温度 MISC_CTRL30 为 Tsensor 温度记录值寄存器 0，Offset Address: 0x0078。
高低16为分别存储温度数据。
计算温度 测试 ~ # himm 0x12030070 *** Board tools : ver0.0.1_20121120 *** [debug]: {source/utils/cmdshell.c:168}cmdstr:himm ====dump memory 0X12030070==== 0x12030070: 0xC0500000【使能，循环，5x2=10ms周期】 ~ # himm 0x12030078 *** Board tools : ver0.0.1_20121120 *** [debug]: {source/utils/cmdshell.c:168}cmdstr:himm ====dump memory 0X12030078==== 0x12030078: 0x02240225【温度值0x224和0x225】 T = ((( 0x224 - 116) / 806) x 165) -40，就是48.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90ac7132e013f6ccccac1e22adada80c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df23f8cf21ac621a4ef644738cd0d7aa/" rel="bookmark">
			二极管基础及等效电路分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二极管的组成 点接触：结面积小，结允许电流小，结电容小，最高工作频率高
面接触性：结面积大，结允许电流大，结电容大，最高工作频率低
平面型：结面积可小、可大，小的工作频率高，大的结允许的电流大
二极管的伏安特性 二极管的电流与其端电压的关系 i=f (u)称为伏安特性。是一种非线性关系。
工作区域划分 当外加正向电压很低时，由于外电场还不能克服PN结内电场对多数载流子扩散运动的阻力，故正向电流很小几乎为零。这一区域称之为死区。
外加正向电压超过死区电压时，内电场大大削弱，正向电流迅速增长，二极管进入正向导通区。电压再继续增加时，电流迅速增大，而二极管端电压却几乎不变，此时二极管端电压称为导通压降。
在二极管两端加反向电压时，将有很小的、由少子漂移运动形成的反向饱和电流（Is）通过二极管。
材料反向饱和电流硅Si1µA以下锗Ge几十µA ★随温度的上升增长很快
★在反向电压不超过某一范围时，反向电流的大小基本恒定
外加反向电压超过反向击穿电压UBR时，反向电流突然增大，二极管失去单向导电性，进入反向击穿区。
★电击穿（可逆）
雪崩击穿（掺杂浓度低）
齐纳击穿（掺杂浓度高）
★热击穿（不可逆）
二极管的电流方程 伏安特性受温度的影响 温度升高，载流子速度加快，在电压不变的情况下，电流增大，正向特性左移；反向饱和电流增大，反向特性下移。
二极管动态电阻和静态电阻 二极管的主要参数 最大整流电流 IF
二极管长期使用时，允许流过二极管的最大正向平均电流。
最高反向工作电压UR
是保证二极管不被击穿而给出的反向峰值电压，一般是UBR的一半或三分之二。
反向电流IR
指二极管加规定工作电压时的反向电流。
最高工作频率fM
主要决定于PN结的结电容的大小。 若二极管的工作频率超过该值，则二极管的单向导电性能将变得较差。
二极管选择的原则 ★ 要求导通压降较小时选锗管，要求反向电流小时选硅管。
★ 要求工作电流大时选面接触型，要求工作频率高时选点接触型。
★ 要求反向击穿电压高时选硅管。
★ 要求温度特性好时选硅管。
二极管电路分析 静态：放大电路没有输入信号时，电路中各点的电流和电压是直流信号，称为直流工作状态或静止工作状态，简称静态。
动态：放大电路有输入信号时，电路中的电压和电流随交流信号而变化，称为动态。
重要理念：先静态后动态
符号规定 电路中各处的往往由直流量和交流量叠加而成
IB 直流分量（符号大写、下标大写）
ib 交流分量瞬时值（符号小写、下标小写）
iB 电流的总瞬时值（符号小写、下标大写）
Ib 交流有效值（符号大写、下标小写）
Ibm 交流幅值
二极管电路图解分析方法 图解分析是利用器件的伏安特性曲线和外电路的特性曲线，通过作图的方法求解电路问题。
步骤：
（1）静态分析。 假设交流信号为0，得到直流通路。结合外电路的特性曲线，得到静态工作点Q（ID，VD）。
（2）动态分析。 直流电源置0，得到交流通路。在静态工作点基础上，进行小信号分析。
优点：直观，帮助理解电路参数对性能的影响；
缺点：有作图误差，某些参数无法求取；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df23f8cf21ac621a4ef644738cd0d7aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a695bd21cc140712945848360fcad62/" rel="bookmark">
			欧拉函数及欧拉函数表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欧拉函数
Phi（n）=n(1-1/p1) (1-1/p2)…… (1-1/pk)
其中p1， p2 ，pk是n的所有素数因子
Phi（n）：所有小于等于n的且与n互素的数的个数
(1)直接实现
int oula(int n) { int rea=n; for(int i=2; i&lt;=n; i++) if(n%i==0)//第一次找到的必为素因子 { rea=rea-rea/i; while(n % i == 0) n/=i;//把该素因子全部约掉 } return rea; } (2)欧拉函数表
void lin() { for(int i=2; i&lt;1000001; i++)//欧拉公式，计算比j小且和j互斥的数的个数 { if(d[i]==0)//如果是素数 { for(int j=i; j&lt;1000001; j+=i)//所有能整除i的j，在下面公式中先运算，最后可以运算完满足j的素数 { if(d[j]==0) d[j]=j; d[j]=d[j]/i*(i-1); } } } mp[1] = 1; for(int i=2; i&lt;1000001; i++) mp[i]=mp[i-1]+d[i]; } 例题Farey Sequence Length
欧拉函数表的裸题
但是要注意mp[1]的初值是2,因为规定了0/1也是一个
#include&lt;stdio.h&gt; #include&lt;string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a695bd21cc140712945848360fcad62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93957d05fdc7249f886eccd24bec3aa0/" rel="bookmark">
			解决IDEA中maven无法引进okhttp依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚开始一直无法引进，进过查阅资料
&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;4.9.0&lt;/version&gt; &lt;/dependency&gt; 是这里的问题去掉勾选就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90346031a143c6c5515f4faa675f4d13/" rel="bookmark">
			LayaAir 3D插件使用者必读，重大升级与调整要来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LayaAir引擎计划于下周一（11月2日）推出2.8.0正式版和2.9.0beta版。2.8.0在两个月的时间内经历4个beta之后终于迎来了正式版，正式版修复了开发者反馈的若干BUG，这将是比较稳定的一个版本，建议开发者升级。
而对于喜欢体验新功能的开发者，2.9.0beta版也有着大量的3D新功能增加，下周一将发布全面的新功能版本说明。
下面，我们先剧透一下LayaAir2.9.0beta版与3D插件相关的重要更新。
支持反射探针
反射探针是用来模拟反射周边物体的光照信息的一种解决方案，让物体受周围物体的光照或材质影响的一种模拟光照效果。简单来说，就是为了在不同的区域，可以得到不同的反射而实现的区域反射功能。
LayaAir PBR材质中的IBL环境反射是基于场景的，在没有探针之前，所有PBR材质物体使用的反射立方体贴图（textureCube）都来自于场景设置的反射立方体贴图，无法根据不同区域产生不同反射效果。
在LayaAir 2.9.0beta版开始，开发者可以根据不同的区域来烘培不同的反射天空盒，以此来得到更多更丰富的反射效果，并且反射探针的BoxProject反射会在一些情况下增加反射的真实度，可以得到更加好的场景效果。
在使用的时候，开发者需要使用对应引擎版本的LayaAir Unity导出插件（例如LayaAir 2.9.0beta），然后去Unity需要使用反射探针的地方，创建一个空节点，在空节点的Inspector中增加一个ReflectionProb的组件，如下图所示：
在LayaAir引擎中，反射探针的Type只支持Bake模式与Custom模式。另外，由于图片槽数对于小游戏来说非常的紧张，LayaAir引擎也没有做反射探针的blend（混合模式）支持，只是简单的simple模式和off模式。除了这两点，其它的Unity反射探针属性，LayaAir引擎中都是支持的。如下图所示，红框内都是支持导出使用的属性。
一些常规的属性使用就不在这里介绍了，开发者可以查看相关文档。重点说一下Box Projection（是否支持盒式偏移反射），该选项允许在距探针有限距离处创建反射立方体贴图，从而允许对象根据它们与立方体贴图墙壁的距离，显示不同大小的反射。周围立方体贴图的大小由探针效果区域决定。例如，如果一个探针在房间内部反射，应使设置的大小与房间的尺寸匹配。
开启和关闭Box Projection的效果如下图所示。
还需要注意的是，反射探针和全局光照一样，只会反射静态的物体。所以在Unity中使用反射探针时候，要先把需要反射的物体设置成静态物体。操作很简单，就是点一下Reflection Probe面板下面的Bake按钮就可以。或者在Unity的菜单栏Window--&gt;Rendering--&gt;Lighting Settings打开Lighting面板，点击最下方的Generate Lighting按钮。然后直接导出就好了。
当前的版本，使用了反射探针的物体不能进行静态合并以及instance动态合并，未来的引擎版本会优化。
批量导出场景 2.9.0以前的LayaAir插件每次只能导出一个场景，2.9.0beta版开始支持批量导出场景，可以加快多场景的导出效率。
该功能在其它设置中，如下图所示，勾选批量导出场景，可使用该功能。
需要提醒的是，批量导出的是Unity层级视图（Hierarchy）下的场景，如果需要导出，需要将场景添加到Hierarchy下。
LayaAir专属3D粒子编辑面板 用过LayaAir引擎Unity导出插件的都知道，LayaAir引擎虽然支持在Unity中编辑并导出，但是由于LayaAir引擎并非支持Unity中的所有属性，所以当不熟悉LayaAir引擎的导出规则时，可能会由于在Unity面板中使用了LayaAir引擎不支持导出的属性功能，从而使得运行效果与Unity中编辑的效果不一致。尤其是3D粒子这种由美术或者技术美术频繁调整的功能。很容易一不留神就使用了不支持的属性，导致要反复重调输出，影响开发效率。
因此，2.9.0beta版开始，我们在插件中推出LayaAir自己的3D粒子编辑面板，选择使用LayaAir面板后，编辑面板中仅有LayaAir引擎支持的功能属性。美术在调整的时候再也会由于不小心或者不熟悉规则而出错了。
下图是3D粒子编辑面板界面效果图。
未来，还会推出更多LayaAir功能面板来替换Unity功能界面。提升会员功能的易用性。
推出服务版工具会员种类 自2018年推出插件会员以来，众多开发者购买了插件工具的会员权益，在此我们先对广大的购买者表示感谢，你们的支持正是我们持续发展的动力。
在这两年中，有很多开发者在购买工具会员后，也在咨询能否提供更多的技术服务。经过引擎团队的讨论商议，我们从2.9.0beta版开始推出工具会员的服务版权益。服务版其实是插件工具企业会员权益与个人版引擎共享技术服务的组合套餐，价格比分别单独购买更实惠。
注意：每个服务版帐号仅限1名开发者享受技术服务权益，具体可与商务对接人沟通咨询
推出多个工具会员新权益 LayaAir引擎工具会员的权益都是不影响开发者使用的增值性功能，会员功能主要是体现在易用性提升以及第三方可替代的工具方案整合。所以尽管引擎工具一直在免费升级，但工具会员的权益升级的次数并不多。
以往的LayaAir工具会员权益分别是：
3D模型压缩：降低模型文件尺寸约60%；
3D动画压缩：降低3D动画文件尺寸约40%；
纹理压缩：降低纹理的显存占用约75%，减少纹理图片解码卡顿；
文件合并：可合并JSON与二进制文本文件，减少文件下载交互数量，提升游戏加载效率；
本次版本开始，新增的会员权益为：
3D骨骼预烘焙压缩：降低预烘焙文件尺寸与显存占用约50%；
批量导出3D场景：支持将Unity中的多个场景同时导出；
LayaAir 3D粒子面板：与LayaAir引擎功能完全对应的粒子编辑面板，大幅提升粒子的编辑效率；（该权益为企业版会员与服务版会员的特色权益）
从2.9.0beta版开始，我们不仅全面升级了工具会员权益。还针对企业版工具会员进行了专项升级，提供了专属于企业版会员的特色权益。如果有2.9.0beta版推出前购买个人版工具会员的开发者想升级企业版会员，可以联系商务补差价升级。
薅羊毛的机会 LayaAir插件推出以来，插件会员的优惠活动一直在持续着。从下周一发版之日起，会员价格优惠活动将终止，恢复到原价。并且下架季付会员，推出服务版工具会员。因此，建议没有采购服务套餐的开发者，可以在下周一之前薅一把羊毛。在优惠活动结束前提前续费或者购买工具会员。
END
引擎案例分享：
3D研发经验分享：50多款3D小游戏的炫稷游戏创始人程银斌分享3D研发经验！
3D技术分享：有着30多款3D小游戏产品的长沙嗨鹿互动科技资深研发工程师分享3D游戏研发经验
132款3D跑酷极限运动主题的微信小游戏分享
LayaAir引擎78款3D射击主题微信小游戏分享，看看玩过几款！
推荐阅读：
显存优化：纹理压缩功能介绍与使用说明
LayaAir引擎的未来规划 #BIGC#
3D场景编辑导出-LayaAir引擎Unity插件使用详解
有效解决3D游戏边缘锯齿现象及全面理解LayaAir引擎游戏屏幕适配！
如何使用及参与维护Github的LayaAir引擎源码
VSCode高效开发工作流配置指南
科普：零基础了解3D游戏开发
应对苹果iOS新规，Layabox再次成功过审HTML5的APP包，同时推出iOS过审协助服务
Layabox推出低价位共享技术服务活动！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9652b197738588d9f68b2fe0f66abcb8/" rel="bookmark">
			Jetson Nano 关闭开启图形界面减少内存占用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果希望一直保持桌面关闭，则可以使用下述命令，然后，重新启动后，桌面将保持禁用或启用状态：
# ubuntu关闭图形用户界面 sudo systemctl set-default multi-user.target sudo reboot # ubuntu启用图形用户界面 sudo systemctl set-default graphical.target sudo reboot 如果只是临时关闭，重启后会自动开启可以用以下命令：
sudo init 3 #关闭桌面 sudo init 5 #重启桌面 然后检查下内存使用情况：
free -m 增加Swap空间：
1）新增swapfile文件大小自定义
sudo fallocate -l 6G /var/swapfile 2）配置该文件的权限
sudo chmod 600 /var/swapfile 3）建立交换分区
sudo mkswap /var/swapfile 4）启用交换分区
sudo swapon /var/swapfile 5）设置为自动启用swapfile
sudo bash -c 'echo "/var/swapfile swap swap defaults 0 0" &gt;&gt; /etc/fstab' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28e0fefb48fdc2697f9e9af0de021c13/" rel="bookmark">
			DFS 深度优化搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DFS 深度优化搜索 DFS 算法 思想：一直往深处走，直到找到解或者走不下去为止 类似于树的先根遍历。就是不撞南墙不回头
模板一： DFS(dep,..)//dep代表目前DFS的深度 { if(找到解||走不下去) { ... return; } DFS(dep+1,..)//枚举下一种情况 } 模板二： DFS(dep,..) {	if(判断条件) return; for(扩展转态) { 判断合法； 记录； DFS(dep+1,...) 回溯； } } DFS遍历图 1.从图中v0出发，访问v0。
2.找出v0的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤，直至刚访问过的顶点没有未被访问的邻接点为止。
3.返回前一个访问过的仍有未被访问邻接点的顶点，继续访问该顶点的下一个未被访问领接点。
4.重复2,3步骤，直至所有顶点均被访问，搜索结束。
v0-&gt;v2-&gt;v4-&gt;v6-&gt;v1-&gt;v5-&gt;v3
v0 v2 v1 v3 v4 v5 v6 DFS 题型 一：数据型 Prime Ring Problem 题意 已知一个数n，将数字1~n围成一个圆环，要求： 相邻两个数之和为素数。
0&lt;n&lt;20
输出：
数字的方向一致（同顺时针或同逆时针），并保证排列不重复只有一个数（n==1）时，输出1输出Case k:（k为数据组数），每一组输出（第一个除外）之前都有一个空行 思路 每次递归前判断前两个数之和是否为素数，因为是环，最后一个数和第一个数也要满足
DFS前可以先用素数筛，求50内的素数，n最大20,最大的两个素数和&lt;50
代码 #include&lt;bits/stdc++.h&gt; using namespace std; const int MAX=50; int prime[25];//素数数组 bool vis[25]; //访问数组 int n;// 个数 int ans[MAX];//解答输出数组 void Prime_set() //筛法求素数 { //Isprime 0、 IsNotprime 1 for(int i = 2; i&lt;=sqrt(MAX) ;++ i) if(prime[i] == 0) { for(int j = 2;i*j&lt;=MAX;++j) prime[i*j] = 1; } prime[1] = 0,vis[1]=true;//1虽然不是素数，但在此假设为0，将vis[1]设为true即不会遍历到1 } void DFS(int depth) { if(prime[ans[depth-1]+ans[depth-2]]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28e0fefb48fdc2697f9e9af0de021c13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50b4ff0079f7f6887f1fde713f2fd404/" rel="bookmark">
			[Style Transfer]——Analyzing and Improving the Image Quality of StyleGAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Style Transfer]——Analyzing and Improving the Image Quality of StyleGAN
Style GAN2:分析和改善StyleGAN的图像质量
from NVIDIA CVPR2020 Paper
Code
Abstract StyleGAN在数据驱动的无监督生成模型中达到了SOTA效果。我们分析了这一模型的特点，通过实验进行了验证。本文重新设计了生成网络的归一化、正则化，从而促进从隐空间到图像的映射。除了提升图像质量,这种路径长度归一化还带来了其他好处，就是生成器可以更容易发生反转，这样可以用来检测某一生成图像来自于哪一种生成网络。
本文还进一步探究了生成网络如何调整分辨率、如何训练更大的网络提升模型的容量。总的来说，本文做的改进在无监督生成的图像质量和评价指标等方面都做到了SOTA。
Section I Introduction 目前生成模型合成的图像尤其是在高分辨率图像方面，StyleGAN达到了SOTA的水平，本文的目的是修复StyleGAN存在的一些不足、伪影，进一步提升图像质量。
StyleGAN的创新之处在于将原始的图像输入改为输入经过一定映射后的latent code，并且通过AdaIN控制style信息，并且通过加入随机噪声引入随机变化。并且W的隐空间比Z的隐空间变量之间的耦合松的多，因此本文将主要分析W相关的隐空间。
许多研究者注意到了StyleGAN生成的图像中带伪影的问题，我们确认了造成伪影的两大原因：
一是关于斑点状伪影的原因，主要是生成网络为了规避结构缺陷从而产生的；因此本文重新设计了生成网络的正则化从而去除这部分伪影；
二是随着分辨率逐渐增长产生的伪影，这种伪影在高分辨率的GAN训练中十分突出。
本文提出一种交替设计的方法，最开始只聚焦于低分辨率图像诉后逐渐关注与越来越高的分辨率，但并不会在训练过程中改变网络的拓扑结构。这种新设计就可以帮助我们分析为什么生成图像的质量比预期要低。 另一方面就是评价指标。FID距离测量的是两种图像经InceptionV3的高频特征的分布差距；此外precision和Recall分别测量的是生成图像与训练数据的相似性以及与能够生成的训练数据的百分比，本文基于这些量化指标来进行优化。 而FID以及P&amp;r指标主要侧重于纹理而不是形状，因此无法准确的评测图像质量的方方面面。而之前引入的感知路径长度PPL用于衡量隐空间的质量，可作为形状一致性和稳定性分的度量。
基于此，我们对网络进行了正则化优化从而产生更加平滑的映射，显著提升了图像质量。为了尽可能不增加计算成本，我们尽可能少的使用正则化，在不影响效率的情况下进行。 最后在StyleGAN2中，借助上述改进使得图像到W隐空间的映射效果更好，甚至可以判断是否由哪一个特定的生成器产生了这一图像，比Style GAN1更具实际意义。
Section II Removing normalization artifacts 伪影的去除 Fig 1中可以看出，StyleGAN中很多生成图像都有这种水滴状的伪影，有的可能在最终的生成图中不明显，但如果我们看中间的一些激活值的输出就会发现问题所在。这是一个StyleGAN中的系统性问题，几乎从分辨率64之后就会出现。
如Fig1所示，我们在大多数生成图像中观察到水滴状的斑点状伪影，即使有的伪影在最终的图像中并不明显但是也会在生成网络中间层的特征图谱中出现。这些伪影大多从分辨率=64时开始出现的。 这种伪影的出现着实令人困惑，因为判别器应该能够检测出来。 最后我们将问题定位到是由于AdaIN运算导致的，AdaIN会对输入的特征图的均值和方差进行归一化，这样就严重破坏了特征图谱之间相互依赖的各种特征信息，我们假定这种斑点状伪影是生成器故意将图像强度信息归一化后的结果，通过创造一个局部的强的尖峰来控制统计信息，这样生成器就可以在任意地方对信号进行有效的缩放。我们的假设基于这样的现象支撑： 在后续的实验中，我们删除了这一步的归一化操作，因此之后所有的水滴状伪影就消失了。
Part A Generator architecture revcisited
首先让我们再次回顾一下StyleGAN生成网络的结构，从而让我们更好的设计归一化操作。Fig2(a)中显示了原始的StyleGAN中的生成网络部分，2b则进一步展示了细节信息，包括输入的权重、添加的【偏置，以及AdaIN模块分两步进行：归一化模块和调制模块。
这样可以将网络很明显的划分为一个一个级联的style block风格模块。
有趣的一点是，在StyleGAN1中输入权重和偏置的方式，对style的调控是由反作用的，因此将这些操作移到style block之外，对归一化后的数据进行操作。这样就可以消除权重、偏置、噪声和归一化等对输入的影响，因此调整之后的结构参见2（c) 。
Part B Instance normalization revisited 下面再来回归一下AdaIN结构，StyleGAN的魅力之一就是对于style风格信息的调控，通过在推断时向不同层喂入不同的latent W可以进行风格混合。实际上风格的调制会将某种特征放大很多，如果不能在每一个样本上抵消这种过度放大，剩下的其它层就无法进行有意义的生成了。 如果我们放弃对央视调控的追求，这样仅仅通过移除掉归一化操作就可以移除前面提到的伪影，同时提升FID等指标，但这就丧失了风格调控的能力了。
因此本文在保证度风格具有足够调控能力的前提下进行优化，主要思想是基于特征图归一化后的预期统计数据进行归一化。
回顾一下2©中style block的结构，包含modulation+conv+normalization(调制、卷积和归一化）。
首先考虑调制的作用，就是将输入的style信息以比例因子的形式乘以输入的特征图谱，这可以通过对卷积的权重进行缩放实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50b4ff0079f7f6887f1fde713f2fd404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec00a248d61cec5f43ffa864c4e51cd4/" rel="bookmark">
			SSM升级为SpringBoot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSM升级为SpringBoot 前段时间把原来的JavaWeb项目架构升级为了Maven项目。技术栈则是从原生的Jdbc+Servlet升级到了SSM，现在准备把项目升级为SpringBoot。
目前项目架构：
升级步骤
改POM改项目结构主启动类合并配置文件 改POM POM文件导入的jar包非常的多，使用SpringBoot的场景启动器来简化。
目前是一个单体项目，所有的功能都写在一个模块里面。所以我们可以使用&lt;parent&gt;标签来做jar包版本的仲裁。然后根据需要添加starter，这里我主要是SSM架构，所以添加如下几个即可。
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 改项目结构 目前的项目长这样，其中我们的页面要从webapp转移到resources里面，然后其他的基本上差别不大。
如图，我们的SpringBoot项目应该是这个结构，其中resources里面默认自带两个文件夹，一个是templates，一个是static。templates是个特殊的目录，不能直接访问，一般存放着是一些模板引擎，比如JSP,themeleaf这类的。由于我目前的项目都是HTML页面发送Ajax请求来完成的，所以我们可以不必创建templates这个目录，创建一个static即可，然后把我们的webapp的文件都转移过去。
改造完毕，其实SpringBoot这是在Maven的基础上添加了一些东西，并没有修改已有的。
主启动类 在我们的com.kaikeba.express目录右键创建主启动类，对于大家而言，只要保证这个类的路径和我们的各个文件夹同一层即可。
创建主启动类
@SpringBootApplication public class ExpressMainApplication { public static void main(String[] args) { SpringApplication.run(ExpressMainApplication.class, args); } } 保证和我们创建的各个文件夹同一目录即可。
合并配置文件 目前我们主要有：数据库配置文件，log4j配置文件，spring配置文件，springmvc配置文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec00a248d61cec5f43ffa864c4e51cd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f54a416cf6b54ec0da0010ef7622e76c/" rel="bookmark">
			WordPress前后台都可以随意切换主题的插件Theme Switcha
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果我们建立的 WordPress 站点有很多主题切换，想要让所有用户或管理员或密码用户可以在随意切换主题，那么建议考虑安装这款 Theme Switcha 主题切换插件。该插件可以让我们在 WordPress 后台或前台直接切换主题，而且还可以通过 URL 方式分享给其他用户切换到指定的主题。Theme Switcha 插件具有以下功能：
在访客使用默认主题的同时开发新主题控制谁可以切换主题（管理员、带密码或每个人）管理员可以直接通过 WP Admin 区域切换主题使访问者可以在前端切换和预览主题每个访客都可以选择自己的主题通过密码将预览链接发送给客户为预览链接选择自己的自定义密码设置切换主题的持续时间（cookie 超时）在管理区域中启用/禁用主题预览启用/禁用所有主题切换而无需停用插件提供一些短代码，以使访问者可以切换主题简码将主题显示为列表，选择菜单或缩略图处理切换主题时，更改的选项将保存仪表板小部件可通过选择菜单切换主题简单，时尚的 UI，具有每个主题的屏幕截图适用于任何主题，父主题和子主题带有或不带有 Gutenberg 块编辑器的作品与 WP Multisite 一起使用 Theme Switcha插件的安装及启用 登录 WordPress 后台 &gt;&gt; 插件 &gt;&gt; 安装插件 &gt;&gt; 搜索“Theme Switcha”，点击该插件右上角的【现在安装】按钮，稍等片刻安装完毕后点击【Activate】或【启用】按钮启用该插件（PS：或前往插件 &gt;&gt; 已安装的插件 &gt;&gt; 找到该插件后点击【启用】按钮）。
如果无法在后台直接安装就前往 WordPress 官方插件页面Theme Switcha中下载，然后在后台 &gt;&gt; 插件 &gt;&gt; 安装插件 &gt;&gt; 点击【上传插件】&gt;&gt; 点击【选择文件】按钮后选择刚才下载的插件安装包 &gt;&gt; 点击【现在安装】按钮 &gt;&gt; 成功安装后点击【启用插件】按钮。
Theme Switcha插件的设置和使用 1、插件的设置 登录 WordPress 后台 &gt;&gt; 设置 &gt;&gt; Theme Switcha，即可进入到该插件的设置页面。重点是“允许的用户”设置：如果是所有用户，则可以通过短代码或者 URL 方式分享到站点前端给任何用户切换主题；如果是密码用户，则可以通过分享带有密码的 URL 地址给任何用户切换主题；如果是管理员，则只有管理员可以切换主题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f54a416cf6b54ec0da0010ef7622e76c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3353b7ebc5acebc62babcbc124d18329/" rel="bookmark">
			定时刷新页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、页面自动刷新：把如下代码加入区域中
&lt;meta http-equiv="refresh" content="3"&gt; 其中3指每隔3秒刷新一次页面.
2、js版页面自动刷新
&lt;script language="JavaScript"&gt; function myrefresh() { window.location.reload(); } setTimeout('myrefresh()',3000); //指定3秒刷新一次 &lt;/script&gt; 3、页面自动跳转（类似于52破解的登录成功之后三秒之后跳转只首页的操作）：
页面自动跳转：把如下代码加入区域中
&lt;meta http-equiv="refresh" content="20;url=http://www.baidu.com"&gt; 其中20指隔20秒后跳转到 http://www.baidu.com/页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ea8c76002a6abb9878f8b358416fe2/" rel="bookmark">
			【erlang】Intellij IDEA中 使用REBAR3配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在插件库里找到erlang 插件，下载并安装erlang插件
下载Rebar3插件
创建项目,创建后当前目录结构
在src目录下创建文件*.app.src
创建*_sup.erl模块
创建*_app.erl模块，该模块是应用程序启动调用的模块
添加rebar.config文件
添加编译命令
编译好的文件的目录结构
继续添加一个运行的命令
可以看到已经在运行了，点击红色方块可以停止
可以通过observer:start()看到应用程序已经启动
接下来试下发布命令
添加一个执行cmd文件的命令
可以看到同样启动成功了
更多操作请查看Rebar3官方文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b316c8868e1dcd66c720046e43e121cd/" rel="bookmark">
			Win10双系统安装Ubuntu16.0.4问题汇总（安装教程，BIOS，致命错误，EFI分区，easyBCD）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1：能用的教程 首先是大步骤大差不差的完整教程：
参考：https://blog.csdn.net/hitzijiyingcai/article/details/81627816
注意自己的硬盘和BIOS的格式，同时注意Secure Boot项选择Disabled:
参考：https://www.cnblogs.com/masbay/p/10844857.html
问题2：报错没有预留BIOS区域，或者报错执行xxx失败，这是一个致命错误 等到分区结束进行安装的时候，如果你前面挂载的是/boot，可能会提醒你没有预留BIOS区域，后面会发生致命错误（我的电脑是这样）
参考：https://www.cnblogs.com/zzb-Dream-90Time/p/8258604.html
文章中关于“分配启动引导空间中”写道：
有同学可能要问了，为什么选择这个“保留BIOS启动区域”，而不是挂载“/boot”？这里需要说明下，因为该笔记本是支持UEFI的，之前博主就是采用的传统方法，挂载“/boot”，这样做的结果是，无论如何无法进入刚安好的Ubuntu系统，就连EasyBCD也不起作用，找不到Ubuntu的引导启动项。后来看到了一篇文章，大意说是UEFI启动模式下，Ubuntu的引导挂载应该是biosgrub，否则出错。在博主亲自试验之后，证实了这个说法。
当然，如果笔记本不支持UEFI模式启动，使用的是CSM兼容模式的话，倒是可以用挂载“/boot”的方式，这也实验成功过。
插曲：你可能会看到EFI分区的相关疑问
参考: https://blog.csdn.net/wangyuankl123/article/details/100532620
问题3：Failed to open \EFI\BOOT\mmx64.efi问题 参考: https://blog.csdn.net/qq_39431829/article/details/97310556
问题4：安装成功，但没有引导项或者引导项错误： 1.尝试采用easyBCD2.3
参考：https://segmentfault.com/a/1190000014523888?utm_source=tag-newest
我用easyBCD会报错，所以尝试了easyBCD2.2
2.easyBCD2.2引导后选择进入系统后报错
图片类似这种的（把Windows换成Ubuntu）：
解决方式：
我的解决方式是不用win10引导Ubuntu，改成Ubuntu引导Win10:
参考：https://blog.csdn.net/weixin_44677876/article/details/88794630
成功以后长这样：
图片引用的参考也是一个教程：
https://blog.csdn.net/fengxinzioo/article/details/92791566
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00d67abac410ed589f0c045c04901c9/" rel="bookmark">
			js高级进阶-重点难点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js高级进阶部分
数组类型：
typeof能判断的部分只有 number/String/boolean/undefine/Array/function/Object
判断是否null或undefined直接用===判断就好不需要typeof,不能判断object与null、object与array
a instanceof b a类型是不是b类型的实例 instanceof返回truefalse
aa={
a:function(){
return function(){
return ‘aaa’
}
}
}
console.log(a()()) -&gt;aaa
相关问题
undefined：定义了未赋值
null：定义了也赋值了，只不过赋值的是null
函数里
obj.name=‘A’
obj = {name:A} 这两者是不一样的，前者可以改变变量里的值，后者并不能改变变量里的值
js管理内存
释放内存（清空内存中的数据，标识内存可以分配使用（不释放就不能复用））
变量在定义后会暂时存储，在执行完函数后会自动释放（栈空间的局部变量），最后用完之后会成为垃圾对象=&gt;被垃圾回收器回收
内存分类：栈（全局变量、局部变量（空间较小））、堆（对象（空间较大）） 对象里的函数
setName:funtion(){} 调用的时候也是setName()调用
**如果对象里有特殊字符 - 空格(就是里面属性名是有特符的)
调用里面的属性要 p={} p[‘content-type’] = ‘text/json’ console.log(p[‘content-type’])
**变量名不确定时也要这样调用
函数
let a = {}
function b(){ this.xxx = ‘123’}
a.b() --不能直接调用，根本就没有
b.call(a) console.log(a.xxx) -&gt;123 这就是js强大之处可以让任意函数成为制定任意对象的方法进行调用
回调函数
你定义的、你没有调、但最终他执行了就是回调
比如dom事件触发函数、定时器、ajax函数、生命周期函数
一般原生的js动作很多都是on开头的 比如onclick、onmouseover等 其他的框架也好jQuery等也好都是click这样的 IIFE（匿名函数自调用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a00d67abac410ed589f0c045c04901c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6abc0133a7c1e5dc9d73b6b1b0536a8/" rel="bookmark">
			router-view学习篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在写路由跳转时，遇到了一个问题，今天来记录下这个问题
问题发现：
我在写路由跳转时，用的是 router-link实现跳转
&lt;router-link :to="{ path: '/question',query:{id:id} }"&gt; &lt;span&gt;跳转到A界面&lt;/span&gt; &lt;/router-link&gt; 这个是没有问题的，可以实现，但是我在写的过程中遇到，页面B—&gt;页面B（详情页面点击列表跳转到详情页），这个时候用router-link实现就会有些问题无法实现跳转，所以这个时候我们转换个思路，点击实现跳转就可以啦
解决方案：
&lt;span @click="goPageB"&gt;跳转到A界面&lt;/span&gt; goPageB(id) { this.$router.push({ path: '/pageB', query: { id: id }}) } 具体vue路由传参我们可以参考官网上的来学习《路由组件传参》
我们改完之后依然会发现问题，此时id是根据我们点击动态变化
- http://localhost:8808/#/pageB?id=56 我们发现可以实现页面跳转，因为链接地址（id）发生了变化，但是页面内容却没有发生变化，所以造成的这个原因就是在路由页面存在页面缓存。所以要解决这个问题在router-view 中加入 key 就好了，因为在路由页面存在页面缓存。
在router-view 中加入 key 就好了
&lt;router-view :key="this.$route.fullPath"&gt;&lt;/router-view&gt; 下面了解一下$route
vue路由对象（$route）参数简介 路由对象 在使用了 vue-router 的应用中，路由对象会被注入每个组件中，赋值为 this.$route ，并且当路由切换时，路由对象会被更新。
so , 路由对象暴露了以下属性：
1.$route.path 字符串，等于当前路由对象的路径，会被解析为绝对路径，如 “/home/news” 。
2.$route.params 对象，包含路由中的动态片段和全匹配片段的键值对。
3.$route.query 对象，包含路由中查询参数的键值对。例如，对于 /home/news/detail/01?favorite=yes ，会得到$route.query.favorite == ‘yes‘ 。
4.$route.router 路由规则所属的路由器（以及其所属的组件）。
5.$route.matched 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。
6.$route.name 当前路径的名字，如果没有使用具名路径，则名字为空。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6abc0133a7c1e5dc9d73b6b1b0536a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8fa8b602d4d074345ca62d7762b3359/" rel="bookmark">
			【前沿】2020年10月24日马云外滩金融峰会演讲吃瓜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【前沿】2020年10月24日马云外滩金融峰会演讲吃瓜 内容 2020.10.24 马云外滩金融峰会演讲完整版
马 云 最 新 演 讲
专家和学者的定义挺有意思。实践的理论，而不是办公室实践的理论。
引用一下评论的内容：
观点一：
昨天马云刚讲完 财政部副部长 就讲了三个防止
防止金融科技诱导过度金融消费,
防止金融科技成为非法套利手段，
防止金融科技助长赢者通吃的垄断
就差点名道姓了。
观点二：
几个核心要点，或者说要求，全是为他个人的核心资本，支付宝和蚂蚁金服索要特权。
反对巴塞尔协议、互联网金融创新脱离现有监管制度，批评当铺式旧银行体系，推动纯信用风控。
都是直接围绕着蚂蚁目前的核心索求或者困难。稍微有心，还可以对应上近期国家把金控集团列入金融类企业，划归央行、银监会监管，以及人民币数字货币开始试点推行。
可以轻易读出马云发言要点的对应要求：
1、“互联网金融”企业不必遵循巴塞尔协议，主要应该包括：企业自行制订风控标准；不必缴纳存款准备金、存款保险。
2、“互联网金融”企业不按银行、金控集团类企业制度监管。央行、保监会等金融监管机构不得以金融风险为理由，干涉“创新”。（很可能还有一条，第三方支付平台存款余额从央行监管账户，归还支付宝管理支配。）
3、允许私企加入中国未来合法数字货币的竞争。或者直接说，取消国家对法定货币的垄断权。
每条都是穷图匕见啊。
凡是过往，皆为序章。
热点事情过去了，再讲就挺没意思了。
总结 看不懂门道，没有基准去说对错。继续学习，让自己有完整的分析视角去分析这事件的背后。
更新地址：GitHub（https://blog.csdn.net/weixin_42875245）
更多内容请关注：CSDN、GitHub、掘金
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed0ec1bb2c45195932d2ddcb0c7a8198/" rel="bookmark">
			wireshark介绍、使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 Wireshark介绍2 功能介绍3 图形界面抓报文3.1 选择网卡抓报文3.2 显示报文抓取时间3.3 Wireshark界面布局3.4 报文过滤条件3.4.1 常用过滤条件3.4.2 Wireshark expression3.4.3 高级过滤条件3.4.4 Wireshark capture filter 4 命令行抓报文4.1 选择网卡4.2 命令行过滤条件4.3 常用过滤条件 5 批量转换报文格式 1 Wireshark介绍 Wireshark 是开源网络包分析工具，支持Windows/Linux/Unix环境。网络包分析工具的主要作用是尝试捕获网络包，并尝试显示包的尽可能详细的情况。可以从网站下载最新版本的Wireshark (http://www.wireshark.org/download.html 。 Wireshark通常在4-8周内发布一次新版本。目前我司主流的版本是wireshark 3.0.0,主要是试用该版本进行协议分析。
2 功能介绍 Wireshark支持图形和命令行两种抓报文方式。
3 图形界面抓报文 3.1 选择网卡抓报文 第一步 打开wireshark抓包软件，点击“Capture–&gt;Interfaces”,如图3-1
图3-1选择网卡
第二步 选择抓包的网卡，点击”Strart“开始抓包，这样将抓取流经此网卡的所有报文，并临时保存在内存中。因此，如果持续抓包将消耗掉系统所有内存。如图3-2和图3-3
图3-2启动抓包
图3-3抓包界面
图标 说明
重新抓报文
停止抓报文
表1-1
3.2 显示报文抓取时间 打开wireshark抓包软件，点击“View–&gt;TimeDisplay Format–&gt;Date and Time of Day”，如图3-4和图3-5
图3-4
效果图：
图3-5
3.3 Wireshark界面布局 Wireshark界面主要分为三部分（如图3-6），区域一显示抓取的报文，区域二显示选中报文的包头详细信息，区域三显示选中报文的详细信息，默认以十六进制显示。
图3-6
功能 说明
区域一 显示抓取的报文
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed0ec1bb2c45195932d2ddcb0c7a8198/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dd9f28805c917e23a6e9a426b16fd72/" rel="bookmark">
			win10家庭版调出组策略_Win10打开软件提示&amp;quot;为了对电脑进行保护,已经阻止此应用&amp;quot;解决方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先确定你的系统版本是家庭版，还是专业版。为了方便理解，咱们先介绍专业版的解决办法。
一，win0专业版的解决办法
首先我们按下Win+R“”组合快捷键打开“运行”，在运行中输入“ gpedit.msc”并确定即可打开组策略编辑器。
在本地组策略编辑器界面中依次展开【计算机配置】→【Windows设置】→【安全设置】→【本地策略】→【安全选项】，在右侧栏找到并双击打开【用户账户控制：以管理员批准模式运行所有管理员】，如下图所示。
双击打开后，选择点选“已禁用”并确定，即可完全关闭用户账户控制，如下图所示。
电脑重新启动，即可生效并解决该问题。
二、win10家庭版的解决办法
首先win10家庭版，没有组策略工具，需要我们手动添加一下。
1、首先在Win10桌面建立一个记事本文件，然后将以下代码粘贴到记事本中；
@echo off
pushd "%~dp0"
dir /b C:WindowsservicingPackagesMicrosoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt
dir /b C:WindowsservicingPackagesMicrosoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt
for /f %%i in ('findstr /i . List.txt 2^&gt;nul') do dism /online /norestart /add-package:"C:WindowsservicingPackages%%i"
pause
然后操作选择 文件-另存为，如下图所示。
2、另存为操作时，在名称后面加一个 .bat ,然后下方的文件类型选择为“所有文件”，之后点击“保存”即可，如下图所示。
3、接下来在桌面上就可以看到一个 .bat 命令运行文件，右键“以管理员身份运行”，点击打开运行，就可以为Win10家庭版新加入组策略功能了；如下图
4、最后验证一下，首先使用 Win+R 打开运行对话框，然后输入打开组策略命令 gpedit.msc 然后点击“确定”就可以成功打开组策略了。
5、之后的配置和第一种win10专业版的解决方法一样。
是不是很神奇，希望能帮到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c87073de138fa23efa61bd9bb1004dff/" rel="bookmark">
			API Monitor简介（API监控工具）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		API Monitor是一个免费软件，可以让你监视和控制应用程序和服务，取得了API调用。 它是一个强大的工具，看到的应用程序和服务是如何工作的，或跟踪，你在自己的应用程序的问题。
64位支持 API监控支持监控的64位应用程序和服务。 64位版本只能用来监视64位应用程序和32位版本仅可用于监测的32位应用程序。 要监视在64位Windows的32位应用程序，您必须使用32位版本。 请注意，64位安装程序的API监测包括64位和32位版本。
摘要视图与语法高亮 摘要窗口显示的API调用的信息。 这包括线程ID，并且作出API调用，与所有的参数和返回值的语法高亮API调用的DLL的名称。 如果API调用失败，也显示有关错误的信息。
13000 API定义，1,300多种COM接口 API显示器自带的API定义为超过13,000 API的几乎200 DLL的和超过17,000方法从1,300多种COM接口（Shell，Web浏览器，DirectShow，DirectSound，DirectX，Direct2D，DirectWrite，Windows图像处理组件，调试器引擎，MAPI等）。 API的被组织成类别和子类别（如MSDN中指定）。 该API捕获过滤器允许您选择的API进行监视。
结构，联合，枚举和标志 API Monitor可以解码和显示2000种不同的结构和联合，1000+枚举数据类型，800+标志。 数组内的结构，缓冲器和数组，也可以观看。
缓冲区查看 API监视器可以显示输入和输出缓冲区。 显示的数据的量是从其他参数的API，或从所述API返回值自动计算。 数据的被捕获的最大量是可配置的。 下面的屏幕截图显示了ReadFile的 API调用后缓冲区。 长度lpBuffer通过查看lpNumberOfBytesRead的值的API调用已经执行后计算。 在这种情况下，返回的值是174，这是所显示的缓冲区的长度。
调用树 API监测显示一个调用树，显示API调用的层次结构。 下面的屏幕截图显示了CoGetClassObject调用由Visual Basic应用程序加载微软的Winsock ActiveX控件打了一个调用树。 ActiveX控件MSWINSCK.OCX使得调用WSAStartup和CreateWindowExA从DllMain中。
解码参数和返回值 两个参数和返回值可以显示为一个用户友好的格式。 下面的第一张截图，为参数值正常观看。 第二个屏幕显示经解码的参数值。 对于dwShareMode，API监视器显示FILE_SHARE_DELETE | FILE_SHARE_READ，而不是5，当解码参数值启用选项。此选项无论在参数窗格和摘要窗格可用。
断点 API监视器可以让你通过API调用设置断点控制目标应用程序。 断点可以在API调用前被触发，在API调用后，在API故障，或如果API生成异常。 预调用断点允许你修改它们的参数传递给API之前，还是跳过API调用，并指定返回值和过去的错误代码。 后打电话错误断点允许你修改参数，返回值和过去的错误代码它们传递给调用者之前。 异常断点使你可以捕捉异常，以防止一个目标应用程序可能的崩溃。 全球断点也可以在API错误和异常引发的。 全部自动完成支持适用于所有支持枚举数据类型和标志。
监控，而无需创建定义 API监控器现在可以监控任何DLL任何API，而无需XML定义来创建的。 新添加的外部DLL筛选允许DLL的添加和一个根据需要去除。 一旦DLL被添加，过滤器的工作原理完全一样，捕获过滤器; 个别的API可以被选择用于监测和断点可以设置。 此外，可任意指定从它们这些API的捕获参数的数目。 外部DLL过滤器也可以保存到一个文件中，允许多个集的DLL的基于目标应用程序加载。
进程内存编辑器 API监测包括内存编辑器，可以让你查​​看，编辑和在任何过程中分配内存。 内存编辑器还允许您更改的内存区域的保护。 在一个断点，内存编辑器可用于在目标进程查看和修改缓冲区。 在运行过程中的窗口上的任何程序或服务右键单击启动内存编辑器。
调用过滤 API监控包括动态调用过滤功能，它允许您隐藏或显示基于一定的标准API调用。 超过25个不同的领域可以根据被过滤。 过滤可以用于，例如，发现时间超过50毫秒，以执行或以查看失败并返回错误代码2的Unicode API调用调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c87073de138fa23efa61bd9bb1004dff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5983185950c541068f54e7fb0c7a912d/" rel="bookmark">
			KMP算法&amp;next数组详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KMP算法详解 文章目录 KMP算法详解 前言一、示例二、用朴素的字符串匹配算法三、KMP算法实现1、KMP算法思路2、next数组的本质3、next数组带入思路实现4、next数组的求法 四、代码实现C语言实现Java语言实现 前言 KMP算法是目前字符串算法里面最高校效的一种算法，相较于朴素的字符串匹配算法，其时间复杂度低得多
提示：以下是本篇文章正文内容，下面案例可供参考
一、示例 给定一个字符串s = “abcabcabd” 另一字符串t = “abcabd”，在s中查找t是否存在，若存在返回t[0]在s中对应的下标（本例应当返回3）
二、用朴素的字符串匹配算法 朴素字符串匹配算法实现：
abcabcabdabcabd abcabcabdabcabd abcabcabdabcabd abcabcabdabcabd 返回a的下标3 低效原因：
字符串s中元素被多次重复比较，通过第1步，我们就能知道s[2]是b, s[3]是c，s[4]是a，而t串串首元素是a，所以t串可以直接移动到第4步的样子，第2、3步完全多余，可以省略。
三、KMP算法实现 1、KMP算法思路 KMP算法就是为了解决上述问题而发明的，其思想核心就是t串在比对后移的过程中不是一位一位的移动，而是按照自身规律向后跳转，如上例，直接实现从第一步到第四步的跳转。而我们怎么知道自己应该往后跳几步呢，这就涉及到KMP算法的另一个重要部分，next数组。
2、next数组的本质 next数组是t串的一个属性，next[i]表示字符串前i+1位前缀跟后缀相同的位数(有些参考资料上的表示方式不同，但是内核相同)，比如上例abcabd，next[0] = 0, next[1]为前两位ab,前后缀无相同项, next[1] = 0，next[2]表示abc，也为0, 而next[3]表示abca前缀a与后缀a相等next[3] = 1, next[4]表示abcdab, 其中ab相等，next[4] = 2,next[5]表示abcabd, 无相等项，next[5] = 0.
所以t的next数组为
indexnext001020314250 3、next数组带入思路实现 引入两个指针（这个指针不是指指针类型）i在s串上移动，j在t上移动。上例经过第一次循环
iabcabcabdabcabdj 朴素的字符串匹配算法此时的j就需要回溯到t[0]的位置i要回溯到s[1]的位置。如下图
iabcabcabdabcabdj 而kmp算法的i不需要回溯，j只需要回溯到 next[j-1] 就行
为什么是next[j-1]而不是next[j]，因为当循环退出的时候，j还++了一下，而next记录的是它++前的数值，所以要减一下
即
//（上图为朴素字符串匹配算法，此图接上上图）此时j等于5则next[4] = 2 while(j&gt;0 &amp;&amp; t[j] != s[i]){ j = next[j]; } //意思就是，如果回溯一次还是不匹配的话，就回溯两次，我这次回溯一次后 //t[j]等于t[2]等于c刚好与此时的s[i]相等，就不用继续回溯了，退出循环 iabcabcabdabcabdj 然后i、j往后移动，直到j到达最后一位且匹配成功或者是i超过了范围，前者匹配成功，后者匹配失败。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5983185950c541068f54e7fb0c7a912d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ddf00adef6d55a1e241eaf2271e059/" rel="bookmark">
			Linux TeX Live 安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Tex Live官网
一.获取Tex Live的iso镜像文件 北京交通大学开源软件镜像站：https://mirror.bjtu.edu.cn/ctan/systems/texlive/Images/
在Linux环境下可通过浏览器进入网站进行下载，也可以在Windows下访问网站将iso文件下载好，拷贝到linux下也是可以的。
二.Tex Live的安装 安装过程以Deepin 20安装Tex Live2020为例：
1.为了使用图形化界面进行安装Tex Live，需要安装perl-tk
sudo apt-get install perl-tk 2.挂载iso镜像文件
进入到你下载好的iso文件所在目录下
sudo mount -o loop texlive2020.iso /mnt #将iso文件挂载到mnt文件夹下，要挂载到哪个文件夹可以自己指定 cd /mnt #进入到到挂载后的文件夹下，才会找到install.tl文件 ./install-tl -gui #执行install.tl这个文件，-gui使用图形界面开始安装 执行 ./install-tl -gui 命令后跳出的安装界面如下（图片来源于网络，仅供参考），点击安装texlive 开始安装
安装路径一般就默认路径：/usr/local/texlive/2020/…
安装完成后如下图所示（图片来源于网络，仅供参考）
3.环境配置
通过命令vim ~/.bashrc 进入.bashrc文件，在文件最后添加如下信息
# TeXLive2020-path export PATH=/usr/local/texlive/2020/bin/x86_64-linux:$PATH export MANPATH=/usr/local/texlive/2020/texmf-dist/doc/man:$MANPATH export INFOPATH=/usr/local/texlive/2020/texmf-dist/doc/info:$INFOPATH #另外一种写法（没有测试过） export TexMan="/usr/local/texlive/2020/texmf-dist/doc/man" export TexInfo="/usr/local/texlive/2020/texmf-dist/doc/info" export TexLive="/usr/local/texlive/2020/bin/x86_64-linux" export MANPATH="$MANPATH:$TexMan" export INFOPATH="$INFOPATH:$TexInfo" export PATH="$PATH:$TexLive" 环境配置完成后执行source ~/.bashrc使配置的环境生效，或者重启。
4.测试是否安装成功
输入tex --version 或者 tex -v 指令查看是否有texlive的信息，有则表示安装成功了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3ddf00adef6d55a1e241eaf2271e059/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/407/">«</a>
	<span class="pagination__item pagination__item--current">408/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/409/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>