<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5feba6ee467e8bc509626efa92e74e98/" rel="bookmark">
			远程桌面复制粘贴过程异常中断后，无法使用复制粘贴的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文链接：https://blog.csdn.net/csdndenglu/article/details/83175845
如果使用远程桌面复制粘贴过程中异常中断，接下来很可能无法再使用复制粘贴，重新连接远程桌面也不管用，试试以下办法：
首先检查远程电脑上rdpclip.exe进程是否在运行，如果运行可以结束进程再重新运行。运行方法：使用win+r调出运行框，输入rdpclip回车即可运行rdpclip.exe。
如果不行，在本地电脑执行相同的操作
————————————————
版权声明：本文为CSDN博主「csdndenglu」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/csdndenglu/article/details/83175845
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b842802acfb8428964f4f2c6d4a5f0/" rel="bookmark">
			Linux--网络层常用命令汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux–网络常用命令汇总 一、文件下载 1、curl和wget curl和wget都是Linux下面的文件下载命令，都支持HTTP POST请求，可以向网站发送表单数据。
wget：相对比较简单，就是单纯的用来下载网站上面的文件。
curl：全称（CommandLine Uniform Resource Locator），不仅仅可以下面网站上面的文件，还可以做一些其他的事情，相当于一个没有可视化功能的浏览器。
二、网络接口和路由 1、iwconfig和ifconfig ifconfig：全称（network interfaces configuring），显示或者配置网络接口。
iwconfig：显示或者配置无线网络接口，和ifconfig一样，但是针对无线网使用。
2、route、traceroute和tracepath route：显示和操作主机的路由表。
traceroute：检测发出数据包的主机到目标主机之间所经过的网关数量的工具，使用的原理是以TTL（存活时间）来实现的。
tracepath：追踪数据到达目标主机的路由信息，和traceroute类似，但是必须使用超级用户特权才可以执行。
三、网络连接 1、ping ping： ping通过ICMP协议来工作，可以用来判断当前主机和目标主机之前是否可以连接。
2、netstat netstat：用于统计各种网络层和传输层相关的数据，检查本机各个端口的连接状态。
3、tcpdump tcpdump：是一个强大的网络抓包工具，可以帮助我们分析和调试主机的网络状态。
四、域名IP查询 1、host和nslookup host：查询某个域名或主机所对应的所有IP地址。
nslookup：用来查询一台机器的IP地址和其对应的域名。
五、远程连接 1、telnet和ssh telnet：是一种在UNIX平台上最为人所熟知的网络协议，telnet默认使用23端口，它采用明文传送报文，没有使用任何验证策略及数据加密方法，因此它的安全性不好，存在很大的安全威胁。
ssh：是通过互联网访问网络设备和服务器的主要协议，ssh的默认使用22端口。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ca1cdb537b21716ae5aa4b0d88438f1/" rel="bookmark">
			Windows10 WiFi列表不显示 且启动QQ报错“initialization failure:0x0000000C”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记本 发现Windows10 WiFi列表不显示了首先看看QQ能不能正常启动 如果QQ启动也报错“initialization failure:0x0000000C”
①管理员运行CMD
（此电脑—Windows10©—windows—system32—cmd—右击—以管理员身份运行）
②输入：netsh winsock reset catalog
③回车
④重启
ps：本人也是近期遇到的这个问题，现将方法总结在这里，希望对大家有帮助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f26637992d01218ba2dae3212ac4b00a/" rel="bookmark">
			Windows10中vscode运行代码出现以下错误：Unable to start debugging. Unable to establish a connection to GDB. Debug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.某天使用vscode，链接代码的时候出现如下错误：Unable to start debugging. Unable to establish a connection to GDB. Debug output may contain more information.
2.并且在编译和链接的时候都弹出了terminal，并且在vscode的terminal中也显示了编译的结果。即使我在launch.json中设置"externalConsole": false，
3.当然主要还是链接出现错误，导致没法看代码结果
4.看有人说是将"externalConsole": false,设置为True就行。那么设置好："externalConsole": true,
5.这把不报错了，但是在链接的时候没有弹出terminal，vscode内部的terminal中也没有结果。但是在编译的时候还是会弹出terminal并且在vscode内部的terminal中也显示编译。
6.同时链接完之后在vscode的右下角发现了下图这样一个提示（错误）：
7.看他的意思是我是用了旧的console，取消勾选使用旧的console就可以了。
8.好的，那么先取消勾选旧的console
9.要想取消勾选console，首先打开cmd，
10.在cmd中右键选择“属性”：
11.出现属性设置面板：
12.取消勾选使用旧版控制台选项
13.点击确定，再回到vscode再试试
14.这把好了。在编译和链接阶段都不弹出terminal了，只在vscode内部的terminal中显示编译和链接信息。
15.运行之后直接在vscode中显示结果。
解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5de27bbb1a6bc24011cab826d3c3577c/" rel="bookmark">
			win10小课堂：桌面快捷方式小箭头去除与恢复方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10小课堂：桌面快捷方式小箭头去除与恢复方法 方法一方法二恢复小箭头方法 电脑桌面的快捷方式图标默认都带有小箭头，不知道是不是自己心情不好，总之越看越不爽，本节课教大家如何专门对付这个小箭头。 去除或者保留？由我做主。 方法一 1.在键盘上按【win+R】，输入【regedit】，点击【确定】。
2.鼠标右击【HKEY_CLASSES_ROOT】选择【查找 】。
3. 查找目标输入【lnkfile】只勾选下方【项（K）】 和【全字匹配】，然后点击【查找下一个】。
4.鼠标右击【IsShortcut】选择【删除】。
5.点击【是】。
重启电脑，快捷方式小箭头消失！
方法二 1.在键盘上按【win+R】，输入【cmd /k reg delete “HKEY_CLASSES_ROOT\lnkfile” /v IsShortcut /f &amp; taskkill /f /im explorer.exe &amp; start explorer.exe】（输入【】里面的代码） 点击【确定】。
2.小箭头去除成功。
恢复小箭头方法 1.新建一个txt文档，在文本中输入：
Windows Registry Editor Version 5.00
[HKEY_CLASSES_ROOT\PIPFile]
“IsShortcut”=""
[HKEY_CLASSES_ROOT\lnkfile]
“IsShortcut”=""
2.点击【文件】选择【另存为】，文件名填写【恢复小箭头.reg】（注意：.reg后缀一定要加上）点击【保存】。
3.双击桌面【恢复小箭头】，弹出对话框选择【是】，点击【确定】。
重启电脑，小箭头恢复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d99fb5a7558206000db41d17eeb9d607/" rel="bookmark">
			UE4-（UI）第七十三课Tree View树形结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Tile View需要提供树形结构数据，TreeView 和Tile View 都是继承自List View。
二、创建方法，与ListView创建方法一致，需要TreeEntry控件蓝图实现接口UserObjectListEntry，需要TreeItem基于Object的蓝图类。与Test用来显示UI到显示器中的控件蓝图。
区别：1.在TreeEntry中添加水平盒并放置Text（用于后面不同层级显示不同的缩进效果），水平盒选择根据内容大小自动调节大小
2.TreeItem蓝图中声明一个整数型变量。
三、详细操作流程：
1.应用UserObjectListEntry接口后，在Test控件蓝图中，选择创建TreeView控件，并将细节面板中的EntryWidgetClass选择TreeEntry
2.因为是树形结构，在一层下面有第二层，第二层具体的结构下面还有第三层。想要实现这个效果，需要有数据的填入，
所以在TreeItem中增加变量类型为TreeItem类型的数组变量，命名为Children。
3.先实现第一层逻辑：
在TreeItem蓝图在创建函数 名称为InitChildren，当变量生成后调用init方法进行对数据的填充，双击函数进入到函数内，创建局部变量Base，
实现逻辑：id值*10赋值给base变量，利用forloop节点循环从0-9，取值后与base相加，从而得到新值，添加到Children数组中。(如果想要实现树形展开根据不同的层级出现不同的首行缩进效果，可以在TreeItem蓝图类中声明一个用来传递层级的变量Level)
并将id与level设置为公共变量并且可以在生成时设置
蓝图逻辑：
4.在TreeEntry控件蓝图面板，使用OnListItemObjectSet事件节点实现当创建控件时，就要将对应的值设置到UI面板中。并且根据第几层控制水平盒中的Text控件的左侧留白。
注意：SetPadding时将Padding 分割脚本就可以出现设置四个方向上的留白属性
5.在Test 控件蓝图中创建InitTreeData函数，并使用Construct事件节点调用
在初始化函数中，根据类生成对象，选择TreeItem，并且将获取到的数据添加到TreeView中，并且调用InitChildren初始化数据
注意：id的值为1，否则后面id*int的方法结果始终为0；
调用InitChildren函数，是为了使Item中有子集可以打开第二层数据。
运行：
可以设置鼠标显示节点将鼠标显示，然后点击1，发现没有任何树结构效果。
最重要的一步：
6.在Test 蓝图控件中，选中TreeView，在细节面板的事件栏中，一定要设置OnGetItemChildren：意义为 当要获得该Item中的子元素时触发事件。
选择创建绑定事件，跳转到图表界面。根据创建的函数中传入的Item获取到该Item中存储的Children数组并将数组返回
编译运行：点击1后出现第二层
四、实现可多层点击效果
1.根据上面的流程，可知通过点击不同层的具体数字Item，获取到对应Item中的Children数组，就可以进行下一层的展开，所以要在一开始初始化InitChildren方法中，利用递归方法将多层的数据传入。
注意：使用递归可能造成死循环，甚至是一直循环下去，无法结束循环，此示例中就是循环无法终止，
因为创建一个TreeItem就要进入到TreeItem的InitChildren方法中进行再次创建该类并且初始化数据，会一直创建下去，无法结束循环，所以进行一个条件设置，当第四层以后就不在有子集。正确逻辑如下：
2.运行，点击不同数字，打开不同的树结构。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d8997decbb56f08b40e73223a3eaa3/" rel="bookmark">
			高德、百度地图瓦片下载地址汇总和瓦片下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：高德瓦片地图下载地址
矢量图（含路网、含注记） http://wprd0{1,4}.is.autonavi.com/appmaptile?x={x}&amp;y={y}&amp;z={z}&amp;lang=zh_cn&amp;size=1&amp;scl=1&amp;style=7 矢量图（含路网，不含注记） http://wprd0{{1,4}}.is.autonavi.com/appmaptile?x={x}&amp;y={y}&amp;z={z}&amp;lang=zh_cn&amp;size=1&amp;scl=2&amp;style=7 影像底图（不含路网，不含注记） http://wprd0{{1,4}}.is.autonavi.com/appmaptile?x={x}&amp;y={y}&amp;z={z}&amp;lang=zh_cn&amp;size=1&amp;scl=1&amp;style=6 影像底图（不含路网、不含注记） http://wprd0{1,4}.is.autonavi.com/appmaptile?x={x}&amp;y={y}&amp;z={z}&amp;lang=zh_cn&amp;size=1&amp;scl=2&amp;style=6 影像路网（含路网，含注记） http://wprd0{1,4}.is.autonavi.com/appmaptile?x={x}&amp;y={y}&amp;z={z}&amp;lang=zh_cn&amp;size=1&amp;scl=1&amp;style=8 影像路网（含路网，不含注记） http://wprd0{1,4}.is.autonavi.com/appmaptile?x={x}&amp;y={y}&amp;z={z}&amp;lang=zh_cn&amp;size=1&amp;scl=2&amp;style=8 参数说明:
1. {1,4}选一个数字，{x}、{y}、{z}需要替换为相应的层级。lang=zh_cn 标注语言为中文。
2. 一个正确的瓦片地址格式如下:
http://wprd01.is.autonavi.com/appmaptile?x=6&amp;y=3&amp;z=4&amp;lang=zh_cn&amp;size=1&amp;scl=1&amp;style=7 二：ArcGIS上对外开放的瓦片地址网站（点我进入网站）
ChinaOnlineCommunity_Mobile 格式地址: https://map.geoq.cn/arcgis/rest/services/ChinaOnlineCommunity_Mobile/MapServer/tile/{z}/{y}/{x} ChinaOnlineCommunityENG 格式地址： https://map.geoq.cn/arcgis/rest/services/ChinaOnlineCommunityENG/MapServer/tile/{z}/{y}/{x} 3 ChinaOnlineStreetGray 格式地址
https://map.geoq.cn/arcgis/rest/services/ChinaOnlineStreetGray/MapServer/tile/{z}/{y}/{x} ChinaOnlineStreetPurplishBlue 格式地址 https://map.geoq.cn/arcgis/rest/services/ChinaOnlineStreetPurplishBlue/MapServer/tile/{z}/{x}/{y} ChinaOnlineStreetWarm 格式地址 https://map.geoq.cn/arcgis/rest/services/ChinaOnlineStreetWarm/MapServer/tile/{z}/{x}/{y} 三：百度地图瓦片地址：
1.黄色底图
http://api0.map.bdimg.com/customimage/tile?&amp;x={x}&amp;y={y}&amp;z={z}&amp;udt=20191205&amp;scale=1&amp;ak=5ieMMexWmzB9jivTq6oCRX9j 2.夜深色地图，蓝色地图
http://api0.map.bdimg.com/customimage/tile?&amp;x={x}&amp;y={y}&amp;z={z}&amp;udt=20191205&amp;scale=1&amp;ak=5ieMMexWmzB9jivTq6oCRX9j&amp;customid=midnight 3.百度个性化地图模板(个性化地图网站点我)
只需要修改customid参数分别为:midnight、light、normal、grassgreen等待。
三：参数说明
x={x}&amp;y={y}&amp;z={z}均为占位符，需要替换为相应图层的数字如: x=5&amp;y=6&amp;z=7
四：根据瓦片地址下载瓦片地图。
1.先来预览一下下载的地图瓦片，加载后的效果
2.教你通过java如果下载瓦片地址:
代码见码云上的托管:https://gitee.com/dyh1183/video_live_online 点我直接进码云托管
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98aeba4d43b3ba745f4a3b931e61f75/" rel="bookmark">
			Java集合之HashMap 1.8 源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文源码基于HashMap 1.8,下载地址：Java 8
另外本文不分析红黑树相关的源码
前言 在对HashMap进行源码解析前，我们很有必要搞清楚下面这几个名词，这对于下文的阅读有很大的帮助。
哈希表：这里指的就是HashMap哈希桶：HashMap的底层数据结构，即数组链表：哈希桶的下标装的就是链表节点：链表上的节点就是哈希表上的元素哈希表的容量：元素的总个数哈希桶的容量：数组的个数，由于当发生哈希冲突时，采用链地址法解决冲突，故哈希桶的容量&lt;=哈希表的容量 注意：一定要区分哈希表的容量和哈希桶的容量，一开始很容易将这两个定义搞混淆
一、链表节点 HashMap.Node
static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash;//哈希值 final K key; V value; Node&lt;K,V&gt; next;//下一个结点 Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d98aeba4d43b3ba745f4a3b931e61f75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fc65064df6998b060126434b7d7ad9a/" rel="bookmark">
			Python定时库APScheduler原理及用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. APScheduler简介 APscheduler全称Advanced Python Scheduler
作用为在指定的时间规则执行指定的作业。
指定时间规则的方式可以是间隔多久执行，可以是指定日期时间的执行，也可以类似Linux系统中Crontab中的方式执行任务。
指定的任务就是一个Python函数。
2. APScheduler组件 APScheduler版本 3.6.3
2.1. APScheduler中几个重要的概念 2.1.1. Job 作业 作用
Job作为APScheduler最小执行单位。 创建Job时指定执行的函数，函数中所需参数，Job执行时的一些设置信息。 构建说明
id：指定作业的唯一ID name：指定作业的名字 trigger：apscheduler定义的触发器，用于确定Job的执行时间，根据设置的trigger规则，计算得到下次执行此job的 时间， 满足时将会执行 executor：apscheduler定义的执行器，job创建时设置执行器的名字，根据字符串你名字到scheduler获取到执行此 job的 执行器，执行job指定的函数 max_instances：执行此job的最大实例数，executor执行job时，根据job的id来计算执行次数，根据设置的最大实例数 来确定是否可执行 next_run_time：Job下次的执行时间，创建Job时可以指定一个时间[datetime],不指定的话则默认根据trigger获取触 发时间 misfire_grace_time：Job的延迟执行时间，例如Job的计划执行时间是21:00:00，但因服务重启或其他原因导致 21:00:31才执行，如果设置此key为40,则该job会继续执行，否则将会丢弃此job coalesce：Job是否合并执行，是一个bool值。例如scheduler停止20s后重启启动，而job的触发器设置为5s执行 一次，因此此job错过了4个执行时间，如果设置为是，则会合并到一次执行，否则会逐个执行 func：Job执行的函数 args：Job执行函数需要的位置参数 kwargs：Job执行函数需要的关键字参数 2.1.2. Trigger 触发器 Trigger绑定到Job，在scheduler调度筛选Job时，根据触发器的规则计算出Job的触发时间，然后与当前时间比较 确定此Job是否会被执行，总之就是根据trigger规则计算出下一个执行时间。 Trigger有多种种类，指定时间的DateTrigger，指定间隔时间的IntervalTrigger，像Linux的crontab 一样的CronTrigger 目前APScheduler支持触发器：
DateTrigger IntervalTrigger CronTrigger 2.1.3. Executor 执行器 Executor在scheduler中初始化，另外也可通过scheduler的add_executor动态添加Executor。 每个executor都会绑定一个alias，这个作为唯一标识绑定到Job，在实际执行时会根据Job绑定的executor 找到实际的执行器对象，然后根据执行器对象执行Job Executor的种类会根据不同的调度来选择，如果选择AsyncIO作为调度的库，那么选择AsyncIOExecutor，如果 选择tornado作为调度的库，选择TornadoExecutor，如果选择启动进程作为调度， 选择ThreadPoolExecutor或者ProcessPoolExecutor都可以 Executor的选择需要根据实际的scheduler来选择不同的执行器 目前APScheduler支持的Executor：
AsyncIOExecutor GeventExecutor ThreadPoolExecutor ProcessPoolExecutor TornadoExecutor TwistedExecutor 2.1.4. Jobstore 作业存储 Jobstore在scheduler中初始化，另外也可通过scheduler的add_jobstore动态添加Jobstore。每个jobstore都会 绑定一个alias，scheduler在Add Job时，根据指定的jobstore在scheduler中找到相应的jobstore， 并将job添加到jobstore中。 Jobstore主要是通过pickle库的loads和dumps【实现核心是通过python的__getstate__和__setstate__重写实现】， 每次变更时将Job动态保存到存储中，使用时再动态的加载出来，作为存储的可以是redis，也可以是数据库【通过 sqlarchemy这个库集成多种数据库】，也可以是mongodb等 目前APScheduler支持的Jobstore：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fc65064df6998b060126434b7d7ad9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20a052a8e3cdc751d67272a090e0fba8/" rel="bookmark">
			将android反编译apk生成的代码里的id数字替换成public.xml文件里对应的name
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有过反编译经验的人都会发现这个问题：反编译了一个apk，但是代码里的id全是数字，
这是代码里的内容，id是十进制：
this.mHeaderTextView.setText(2131428266);
localTextView.setText(getResources().getString(2131428311));
对应的name在生成的另一个public.xml文件里，
这是public里的内容，id是十六进制：
&lt;public id="0x7f010042" name="layout_widePaddingRight" type="attr" /&gt;
&lt;public id="0x7f020000" name="ab_dropdown_navigation_item_background" type="drawable" /&gt;
&lt;public id="0x7F0B03AA" name="exporting_contact_failed_title" type="string" /&gt;
代码有点多，所以一个个手动代码有点不现实，
问题来了，请问这个怎么弄个脚本或批处理将代码里的数字代码成像R."type"."name"这种格式？
如：this.textView.setText(2131428211)
代换成this.textView.setText(R.string.title)
这有个参考帖，
http://blog.csdn.net/annkie/article/details/7790026
但他是R.java，我的是public.xml，
而且用的是perl，不会perl，
所以不知道怎么改。
解决方案：找个批量十进制转十六进制的工具逐个转换，对照替换就ok，这里附上一个在线转进制的网站：https://tool.lu/hexconvert/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b948775a83752fa70faf24ef8843e59/" rel="bookmark">
			xilinx 3种pcie ip 区别分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 win10 64bit
vivado 2017.4
xilinx pcie ip core xilinx 提供了3种PCIe 相关的ip core，分别为
1）7 series intergrated block for pci express -&gt; 对应的用户接口为 AXI4-stream 2) axi memory mapped to pci express -&gt;对应的用户接口为 AXI4
3) dma/bridge subsystem for pci express(pcie) -&gt;对应的用户接口为AXI4或者AXI4-stream
7 series intergrated block for pci express 系统框图 功能分析 将PCIe的TLP包转换成AXI Stream信号，然后对TLP包进行解析，从而实现PCIe的通信接口；由于AXI4-stream没有地址线的概念，因此如果要添加一些现成的接口，比如AXI协议的IP核，显得十分无力，缺乏相应的灵活性。
由于用户逻辑接口为AXI-stream接口，用户完全TLP报文格式，使用起来比较复杂。
网上常用的应用解决方案可以采用移植Riffa，结合Riffa的上位机实现高速数据通信，适合于传输大量数据。
example仿真 仿真流程可参考 7 series integrated block for pci express 仿真示例
AXI Memory Mapped to PCI Express 系统框图 功能分析 相比于第一个IP核，这种方法就比较简单，可以做到不写一行代码的方式，实现PCIe的数据传输，通过添加 AXI Memory Mapped to PCI Express，生成example例程，约束下时钟和复位信号，生成比特流文件，下载到板子上就可以发现新设备。然后在PC上使用WinDriver生成驱动(windrver自动生成pcie驱动)，就可以实现对RAM的读写。我对这种方案的理解是思路简单清晰，由于使用了AXI协议，因此可以使用现成的IP核， 并且AXI协议携带地址属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b948775a83752fa70faf24ef8843e59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40628eb652dd961207d050078560220f/" rel="bookmark">
			vue，通过点击子级页面按钮触发父级元素的显示与隐藏。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 父级页面：
&lt;template&gt; &lt;div&gt; &lt;v-sidebar @parentPopme="popTimeline"&gt;&lt;/v-sidebar&gt; &lt;!--步骤条--&gt; &lt;el-footer v-if="lesteps"&gt; &lt;step-for-build&gt;&lt;/step-for-build&gt; &lt;/el-footer&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return { lesteps:false, } }, methods:{ popTimeline(val){ this.lesteps= !this.lesteps; } } } &lt;/script&gt; 子级页面：
&lt;template&gt; &lt;el-tooltip content="步骤条" placement="top" effect="light"&gt; &lt;el-button icon="el-icon-edit" @click="articlesteps"&gt;&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;/template&gt; &lt;script&gt; export default { methods:{ articlesteps(){ this.$emit("parentPopme",''); }, } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70e2e82b8cec44c4d692cb440d82203/" rel="bookmark">
			AXI memory mapped to PCI Express 理解及仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		验证环境 win10 64bit
modelsim 10.6d 64bit
vivado 2017.4
KC705开发板
AXI memory mapped to PCI Express 系统框图 功能分析 此ip可以分为两部分， AXI MM/S bridge + AXI-S Enhanced pcie.
AXI MM/S bridge
用户侧逻辑接口为标准AXI4总线，通过 AXI MM/S bridge 模块，转换成 AXI-stream 数据流
AXI-S Enhanced pcie
相当于 “7 series intergrated block for pci express” 这个ip core。
由于AXI-stream 协议不携带地址属性，转换成AXI4总线后，用户接口直接对接AXI4，可以很方便使用很多现成AXI4接口的ip核，应用起来更方便。
register block 包含桥核中用于动态映射AXI4的寄存器使用AXIBAR参数将内存映射(MM)地址范围提供给一个地址作为PCIe地址 slave bridge only support the INCR burst type .
链接到 axi interconnect 作为一个slave设备，处理axi master（例如CPU）的读写请求。
slave bridge 提供一种AXI memory address 到pcie address转换的方法，axi master的写请求被转换成1个或者多个MemWr TLP,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d70e2e82b8cec44c4d692cb440d82203/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da1c32fa90c1634c7c3309de033cb1df/" rel="bookmark">
			Android反编译笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反编译代码 要想将APK文件中的代码反编译出来，我们需要用到以下两款工具：
dex2jar 这个工具用于将dex文件转换成jar文件
下载地址：http://sourceforge.net/projects/dex2jar/files/
jd-gui 这个工具用于将jar文件转换成java代码
下载地址：http://jd.benow.ca/
解压dex2jar压缩包后，你会发现有很多个文件，如下图所示：
其中我们要用到的是d2j-dex2jar.bat这个文件，当然如果你是linux或mac系统的话就要用d2j-dex2jar.sh这个文件。
然后我们将Demo.apk文件也进行解压，如果不知道怎么直接解压的可以先将文件重命名成Demo.zip，然后用解压软件打开。解压之后你会发现里面有一个classes.dex文件，如下图所示：
这个classes.dex文件就是存放所有java代码的地方了，我们将它拷贝到dex2jar解压后的目录下，并在cmd中也进入到同样的目录，然后执行命令语句：
d2j-dex2jar classes.dex 执行结果如下图所示：
没有报任何错误，这就说明我们已经转换成功了。现在观察dex2jar目录，你会发现多了一个文件，如下图所示：
可以看到，classes-dex2jar.jar这个文件就是我们借助工具之后成功转换出来的jar文件了。但是对于我们而言，jar文件也不是可读的，因此这里还需要再借助jd-gui这个工具来将jar文件转换成java代码。
先看眼jd-gui文件目录
双击jjd-gui.exed-gui.exe运行jd-gui工具打开classes-dex2jar.jar这个文件，结果如下图所示：
OK，由此可见，我们的代码反编译工作已经成功了，MainActivity中的代码非常清晰，基本已经做到了90%以上的还原工作。但是如果想要做到100%的代码还原还是非常有难度的，因为像setContentView()方法传入的参数，其实就是一个资源的id值而已，那么这里反编译也就只能将相应的id值进行还原，而无法变成像R.layout.activity_main这样直观的代码展示。
另外，除了MainActivity之外，还有很多其它的代码也被反编译出来了，因为当前项目有引用support-v4和support-v7的包，这些引用的library也会作为代码的一部分被打包到classes.dex文件当中，因此反编译的时候这些代码也会一起被还原。
好的，学完了反编译代码，接下来我们看一下如何反编译资源。
反编译资源 要想将APK文件中的资源反编译出来，又要用apktool 工具，它的作用是最大幅度地还原APK文件中的9-patch图片、布局文件等一系列的资源：
下载地址：http://ibotpeaches.github.io/Apktool/install/
接下来的工作就很简单了，我们将test.apk拷贝到和这两个文件同样的目录当中，然后cmd也进入到这个目录下，并在cmd中执行如下命令：
apktool d test.apk 其中d是decode的意思，表示我们要对Demo.apk这个文件进行解码。那除了这个基本用法之外，我们还可以再加上一些附加参数来控制decode的更多行为：
-f 如果目标文件夹已存在，则强制删除现有文件夹（默认如果目标文件夹已存在，则解码失败）。
-o 指定解码目标文件夹的名称（默认使用APK文件的名字来命名目标文件夹）。
-s 不反编译dex文件，也就是说classes.dex文件会被保留（默认会将dex文件解码成smali文件）。
-r 不反编译资源文件，也就是说resources.arsc文件会被保留（默认会将resources.arsc解码成具体的资源文件）。
常用用法就这么多了，那么上述命令的执行结果如下图所示：
这就说明反编译资源已经成功了。
现在你会发现在当前目录下多了一个test文件夹，这个文件夹中存放的就是反编译的结果了。进到目录打开资源文件，布局文件都不再是乱码了，这就成功了。
重新打包 首先声明将别人的程序进行破解，再打包不是怎么光荣的事情。这里只是站在技术的角度来学习一下重新打包的相关技术知识。
首先我们来看一下通过apktool反编译后的包目录情况，如下图所示：
其中，original文件夹下存放的是未反编译过、原始的AndroidManifest.xml文件，res文件夹下存放的是反编译出来的所有资源，smali文件夹下存放的是反编译出来的所有java代码，smali文件其实也是真正的源代码，只不过它的语法和java完全不同，AndroidManifest.xml则是经过反编译还原后的manifest文件。
我们现在来把反编译后的test文件夹重新打包成APK吧，其实非常简单，只需要在cmd中执行如下命令：
apktool b test-o New_test.apk 其中b是build的意思，表示我们要将Demo文件夹打包成APK文件，-o用于指定新生成的APK文件名，这里新的文件叫作New_test.apk。执行结束后你会发现在同级目录下面生成了一个新的名字叫New_test的APK文件。
到这一步这个New_test.apk还是不能安装，因为它还没有进行签名。那么如果这是别人的程序的话，我们从哪儿能拿到它原来的签名文件呢？很显然，这是根本没有办法拿到的，因此我们只能拿自己的签名文件来对这个APK文件重新进行签名，但同时也表明我们重新打包出来的软件就是个十足的盗版软件。这里大家学学技术就好了，希望不要有任何人去做什么坏事情。
用jdk命令生成一个签名文件。
1. 生成签名证书
使用JDK自带的keytool工具， 运行下面的命令
keytool -genkey -alias test -keyalg RSA -validity 20000 -keystore test.jks
/*解释：keytool工具是Java JDK自带的证书工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da1c32fa90c1634c7c3309de033cb1df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/009899275c424b36cdfb54d57884b32a/" rel="bookmark">
			【基础篇】PyTorch入门指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是对 Neural Network Programming - Deep Learning with PyTorch 系列博客的翻译与整理，英语基础比较好的同学推荐阅读原汁原味的博客。
文章目录 1. PyTorch简介2. GPU相关介绍3. CUDA相关介绍4. 张量定义5. 张量的秩、轴和形状6. CNN中的张量7. torch.Tensor类8. 创建Tensor的方法对比9. tensor的reshape、squeeze和cat操作10. flatten操作11. element-wise操作12. reduction操作 PyTorch是一个深度学习框架和一个科学计算包，这是PyTorch核心团队对PyTorch的描述，PyTorch的科学计算方面主要是PyTorch张量(tensor)库和相关张量运算的结果。A tensor is an n-dimensional array (ndarray)。PyTorch的torch.Tensor对象就是由Numpy的ndarray对象创建来的，两者之间的转换十分高效。PyTorch中内置了对GPU的支持，如果我们在系统上安装了GPU，那么使用PyTorch将张量在GPU之间来回移动是非常容易的一件事情。
1. PyTorch简介 PyTorch的首次发布是在2016年10月，在PyTorch创建之前，还有一个叫做Torch(火炬)的框架。Torch是一个已经存在了很长时间的机器学习框架，它基于Lua编程语言。PyTorch和这个Lua版本(称为Torch)之间的联系是存在的，因为许多维护Lua版本的开发人员也参与了PyTorch的开发工作。你可能听说过PyTorch是由Facebook创建和维护的，这是因为PyTorch在创建时，Soumith Chintala(创始人)在Facebook AI Research工作。
下表列出了PyTorch包及其相应的说明。这些是我们在本系列中构建神经网络时将学习和使用的主要PyTorch组件。
PackageDescriptiontorch顶层的PyTorch包和tensor库torch.nn一个子包，用于构建神经网络的模块和可扩展类torch.autograd一个子包，支持PyTorch中所有微分张量运算torch.nn.functional一种函数接口，包含构建神经网络的操作，如损失函数、激活函数和卷积操作。torch.optim一个子包，包含标准优化操作，如SGD和Adamtorch.utils一个子包，包含数据集和数据加载器等实用工具类，使数据预处理更容易torchvision提供对流行数据集、模型体系结构和图像转换的访问的包 为了优化神经网络，我们需要计算导数，为了进行计算，深度学习框架使用所谓的计算图(computational graphs)，计算图用于描述神经网络内部张量上发生的函数运算操作。
PyTorch使用一个称为动态计算图的计算图，这意味着计算图是在创建操作时动态生成的，这与在实际操作发生之前就已完全确定的静态图形成对比。正因为如此，许多深度学习领域的前沿研究课题都需要动态图，或者从动态图中获益良多。
2. GPU相关介绍 GPU是一种擅长处理特定计算(specialized computations)的处理器。这与中央处理器(CPU)形成对比，中央处理器是一种善于处理一般计算(general computations)的处理器。CPU是在我们的电子设备上支持大多数典型计算的处理器。
GPU的计算速度可能比CPU快得多。 然而，这并非总是如此。 GPU相对于CPU的速度取决于所执行的计算类型。最适合GPU的计算类型是可以并行完成的计算。
并行计算(paraller computing)是一种将特定计算分解成可以同时进行的独立的较小计算的计算方式，然后重新组合或同步计算结果，以形成原来较大计算的结果。
一个较大的任务可以分解成的任务数量取决于特定硬件上包含的内核数量。核心是在给定处理器中实际执行计算的单元，CPU通常有4个、8个或16个核心，而GPU可能有数千个。
有了这些工作知识，我们可以得出结论，并行计算是使用GPU完成的，我们还可以得出结论，最适合使用GPU解决的任务是可以并行完成的任务。如果计算可以并行完成，我们可以使用并行编程方法和GPU加速计算。
现在我们把目光转移到神经网络上，看看为什么GPU在深度学习中被大量使用。 我们刚刚看到GPU非常适合并行计算，而关于GPU的事实就是深度学习使用GPU的原因。
Neural networks are embarrassingly parallel.指的是一个任务分解为几个子任务之后，在不同处理器上执行该子任务，而这些子任务之间不会相互依赖，也就说明该任务十分适合于并行计算，也被称为embarrassingly parallel.
我们用神经网络所做的许多计算可以很容易地分解成更小的计算，这样一组更小的计算就不会相互依赖了。卷积操作就是这样一个例子。
蓝色区域（底部）: Input channel阴影区域（底部）: Filter绿色区域（顶部）: Output channel 对于蓝色输入通道上的每个位置，3 x 3过滤器都会进行计算，将蓝色输入通道的阴影部分映射到绿色输出通道的相应阴影部分。在动画中，这些计算一个接一个地依次进行。但是，每个计算都是独立于其他计算的，这意味着任何计算都不依赖于任何其他计算的结果。因此，所有这些独立的计算都可以在GPU上并行进行，从而产生整个输出通道，加速我们的卷积过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/009899275c424b36cdfb54d57884b32a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b62b0dd8b8ac5d2adf7dea563417c1bc/" rel="bookmark">
			Visual Studio2019&#43;Cmake编译配置OpenCV4.1.2&#43;Contrib4.1.2（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本文以OpenCV41.2 为例子，opencv有一些函数包是以第三方的形式存在，统一在opencv_contrib-4.1.2里面，如何将整个contrib和OpenCV本身的功能统一在一起进行编译呢？本文是自己操作的结果，与网上的较多教程类似，编译完成之后，怎么使用，请参见前面的OpenCV在VS中的使用：
VS2017配置OpenCV4.1.1超详细教程（项目配置与永久配置）（一）
一、源代码下载以及必备软件安装 1.1 源代码下载
Opencv源代码下载:
https://opencv.org/releases/ 官网下载
https://github.com/opencv/opencv/releases GitHub下载
Opencv_contrib源代码下载:
https://github.com/opencv/opencv_contrib/releases
1.2 必备软件安装
安装Cmake：
Cmake下载地址为: https://cmake.org/download/
安装Visual Studio 2019
安装完成之后配置环境变量这里不再赘述。
二、Cmake相关配置 我的源代码解压地址为：
OpenCV解压地址：D:\OpenCV_Contrib_Source\opencv4.1.2\opencv-4.1.2
里面的类容如下：
OpenCV_contrib解压地址：D:\OpenCV_Contrib_Source\opencv_contrib-4.1.2
里面的类容如下：
那我要将OpenCV项目编译到哪个地方呢？比如我编译到下面的文件夹：
D:\Program Files\Opencv4.1.2
2.1 第一步configure
打开cmake-gui，设置如下，然后点击configure：
第一步configure完成之后会得到如下界面：
2.2 第二步configure
再次点击configure，上面的红色界面会变成白色，这里我不是特别清楚为什么要进行两次，应该是第二次进行验证的意思，若有大佬知晓，望告知，如下：
其中我们可以看一下下面产生的配置信息，到底是一些什么内容：
...省略了前面的 General configuration for OpenCV 4.1.2 ===================================== Version control: unknown Platform: Timestamp: 2019-12-04T08:53:39Z Host: Windows 10.0.18363 AMD64 CMake: 3.16.0-rc3 CMake generator: Visual Studio 16 2019 CMake build tool: D:/Program Files (x86)/Microsoft Visual Studio/2019/Community/MSBuild/Current/Bin/MSBuild.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b62b0dd8b8ac5d2adf7dea563417c1bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6cce83e630ba4e22df14b77acf6a184/" rel="bookmark">
			工控测试---协议---IEC_MMS 61850--request类型协议报文解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 MMS跑在应用层之上，MMS报文如下，MMS遵循OSI标准，所以很多TCP/IP熟悉的人，开始看到会有点疑惑
IP的load包含：
IP TCP TPKT COTP OSIsessioon OSIsessioon OSI MMS载荷
IP IP长度字段分解 = IP 头长度 + TCP头长度+ TCP段载荷大小
TCP TCP头这段比较简单 ：
TCP（单纯头20字节），加上TCP option，就是TCP
目的端口是102，这个是必须的，协议规定，这个端口保留给TPKT（但是没有说必须使用TPKT，存在使用其它端口可能性）
TCP段载荷内容就是OSI层相关信息：TPKT COTP OSIsessioon OSI会话层 OSI表示层 MMS载荷
TPKT 包含 tpkt头+TPDU
tpkt头：8位版本号，8位保留位，16位TPKT总长度（tpkt头+TPDU）
TPDU是由ISO 8073标准定义的 也就是COTP
COTP Connection oriented transport protocol specification
head就三个“双字“ 最常见的就是02 f0 80 分别是长度，pdu类型，COTP分片及是否为最后一片的标识
OSI会话层 MMS 两个会话层字段一般都为 01 00 即
01 00
01 00
OSI表示层 即是MMS载荷的关键部分
61每次都不变 xx长度，后续的内容长度 30每次都不变 xx后续字段全部长度 02每次不变 01每次不变 03代表mms a0每次不变 xx后续MMS数据的长度 MMS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6cce83e630ba4e22df14b77acf6a184/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfba5c4dcc9ac0b94a371fcda71a7614/" rel="bookmark">
			Unity获取模型对应的贴图中的像素点，修改颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中，出现一个非常变态的需求：用户使用鼠标点击某个物体，在物体上滑动鼠标，鼠标在物体上所过的地方贴图像素会变成其他贴图。类似于这种效果：
首先先准备两个模型或者创建两个Cube，然后创建两个带贴图的材质球分别给物体。
注意：贴图可读写要勾上
下面开始贴完整的代码：
/*
获取模型对应的贴图中的像素点，修改颜色
*/
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
public class Pen : MonoBehaviour
{
public Camera modelCamera;
public GameObject obj;
public GameObject obj1;
public Material mat;
//[HideInInspector]
public bool isDrawBegin;
private GameObject _m_obj;
public GameObject m_obj
{
get { return _m_obj; }
set
{
if (_m_obj != null)
{
ReSetTexutre();
}
if (value != null)
{
GetMatTextureOnModel(value);
}
_m_obj = value;
}
}
private Material m_material;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfba5c4dcc9ac0b94a371fcda71a7614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d34998387394eccf656c4bc80e164cc/" rel="bookmark">
			指定typora图片保存路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记本电脑实在太慢了…公司配了台主机使用…要转移备份之前在笔记本上的笔记 = =
之前md的图片都是保存在默认的路径，转移过来的图片都是裂的，还要重新的替换路径
【图片保存在md旁边，我觉得有点乱，所以就指定路径保存了】
所以现在想指定图片保存路径，下次笔记转移的时候 图片也能一起显示…
注意！！ 自动提示的路径的斜杠要换成 / 【我是windows的环境】
OK！！ 下次只用把MD文件和指定路径下的图片复制过去就可以了- -
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6fa2d648dafb6071732281770c514a5/" rel="bookmark">
			java中int相除取后两位小数及百分数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java两个整数相除保留两位小数： java中，当两个整数相除时，由于小数点以后的数字会被截断，运算结果将为整数，此时若希望得到运算结果为double，必须将两整数其一或是两者都强制转换为double。
例如：
(double)a/b // 将整数其中一个强制转换为double，再与另一个整数相除
a/(double)b
(double)a/(double)b // 将两个整数同时强制转换为double后再相除
Java代码：
double num = (double)2/3; cimalFormat df = new DecimalFormat("0.00");//格式化小数 String s = df.format(num);//返回的是String类型 System.out.println(s); Java将小数转化为百分数： Java代码：
int a = 5; int b = 8; double c = (double)a/b; //获取格式化对象 NumberFormat nt = NumberFormat.getPercentInstance(); //设置百分数精确度2即保留两位小数 nt.setMinimumFractionDigits(2); //最后格式化并输出 System.out.println("百分数：" + nt.format(c));//输出结果62.50% 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de5b29848f5740141923ab1f7ed6a1e2/" rel="bookmark">
			idea突然不能粘贴外面的东西
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题: idea突然不能粘贴外面的东西,但内部能正常的粘贴复制
出现的原因: 快捷键冲突了,微软自带的输入法跟idea冲突了
在网上查找的时候发现还有人是因为 进入了vim模式 等等无法使用的问题.
解决办法 禁用微软输入法,或修改微软输入法的快捷键
退出vim模式 tools -&gt;Vim Emulater 把勾选去掉.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de707534acfde8e3c460bcb24a001d96/" rel="bookmark">
			JRebel激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://jrebel.qekang.com/eb89f4d6-2b66-4c6f-9a7f-bec88a1a5ab6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c148ab9a6ca5c29eecc0c314bca0d29/" rel="bookmark">
			SpringBoot RestTemplate 中文乱码解决过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 今天在对接第三方接口的时候，发现通过restTemplate post请求提交过去的中文数据会乱码。
排查 首先，我方的编码全部使用utf8。请求第三方获取数据的接口，发现刚刚提交的数据是乱码，而更早提交的几条数据则正常。因此基本可以排除对方的问题，和response的问题。
于是，问题大概率在restTemplate发送请求的时候编码格式不正确。
根据返回的乱码数据，用vscode基本可以推测对方系统编码是GBK（后来沟通后确实是GBK）
然后，使用网上见得最多的方法：
List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters(); messageConverters.set(1, new StringHttpMessageConverter(Charset.forName("GBK"))); 乱码还是存在。
继续debug，跟踪到RestTemplate.class中的doWithRequest方法后，发现问题所在：
public void doWithRequest(ClientHttpRequest httpRequest) throws IOException { ...... ...... messageConverter.write(requestBody, requestContentType, httpRequest); ...... } 这里把requestBody写入的时候，用的messageConverter是AllEncompassingFormHttpMessageConverter，而此时它的默认编码是utf8。刚才去修改StringHttpMessageConverter是牛头不对马嘴。
（这里粗心了，我明明是用MultiValueMap传参的，为什么要去改StringHttpMessageConverter呢。。。）
解决 到这里，问题就已经解决了：
// 处理请求中文乱码问题 List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters(); for (HttpMessageConverter&lt;?&gt; messageConverter : messageConverters) { if (messageConverter instanceof AllEncompassingFormHttpMessageConverter) { ((AllEncompassingFormHttpMessageConverter) messageConverter).setCharset(thirdRequest); } } 获取restTemplate的代码：
/** * 第三方请求要求的默认编码 */ private final Charset thirdRequest = Charset.forName("GBK"); /** * 第三方RestTemplate * * @return */ @Bean(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c148ab9a6ca5c29eecc0c314bca0d29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89ed7de4a6ecfe67386a9fdabcd8fd67/" rel="bookmark">
			Typescript 之 Mixin (混入)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 Mixin 为对象引入附加的方法或属性，从而达到修改对象结构的目的，即为 mixin.
function applyMixins(derivedCtor: any, baseCtors: any[]) { baseCtors.forEach(baseCtor =&gt; { Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; { derivedCtor.prototype[name] = baseCtor.prototype[name]; }) }); } 在Typescipt 之前，很多框架都提供了 Mixin 这个概念，我自己在 Extjs 和 早期的 React 中就学习过混入。
以下代码是 Mixin 在 React 中的使用方法，通过配置，组件可以像调用自己的方法一样调用外部对象的方法。
注: Mixin 在React 16 中已经被废弃了。 废弃的原因在文章的最后会提及。
var myMixin = { mixinMethod: function() { ... }; var createReactClass = require('create-react-class'); var TickTock = createReactClass({ mixins: [myMixin], // 使用 mixin componentDidMount: function() { this.mixinMethod(); // 调用 mixin 上的方法 }, render: function() { return .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89ed7de4a6ecfe67386a9fdabcd8fd67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a8101d6eb7c30b9c3243964e9ec3cfc/" rel="bookmark">
			mui监听返回以及返回页面代码（经典）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mui.oldback = mui.back; mui.back = function(event) { //-------------end监听返回--------------- var openerPage = plus.webview.currentWebview().opener(); var shuaxin = 1; mui.fire(openerPage,'ziwuopingjia',{shuaxin:shuaxin}); //传递 mui.currentWebview.close();//这个就是让他回到上一层 (当为app模式时这个有用) //------------end传值到父页面--------------(用来刷新) } //---------返回过来的数据------------ window.addEventListener('ziwuopingjia',function(data){ //传回的数据 login(); if(event.detail.shuaxin == 1){ yuyanqiehuan(); //语言切换 } }); //---------end返回过来的数据------------ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e2febea8c7988cfa9f21c6b31d0a2a5/" rel="bookmark">
			Office Word 之画肘形箭头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用word 画跨职能流程图时，经常会用到肘形箭头画回字形，但默认提供的肘形箭头如下图所示，无法实现上下边左对齐。
解决方法如下：
改用任意多边形 拖动箭头，配合shift 键（取直线）、单击（换方向）、双击（停止） ，依次按1、2、3、4顺序画回形，修改箭头末端类型即可，效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dab903be00debede0b2afd86e9718e07/" rel="bookmark">
			MyBatis中#{}占位符与${}拼接符的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、关于#{}占位符 先来看以下的示例，该示例是MyBatis中的SQL映射配置文件（Mapper配置文件），在该配置中使用了#{}占位符。
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="test"&gt; &lt;!-- 根据用户编号，查询单个用户实体 --&gt; &lt;select id="findUserById" parameterType="int" resultType="com.pjb.mybatis.po.User"&gt; SELECT * FROM tb_user WHERE id = #{id} &lt;/select&gt; &lt;!-- 新增用户 --&gt; &lt;insert id="insertUser" parameterType="com.pjb.mybatis.po.User"&gt; INSERT INTO tb_user(user_name,blog_url,remark) VALUES(#{userName},#{blogUrl},#{remark}); &lt;/insert&gt; &lt;/mapper&gt; 在SQL映射配置文章中，输入参数需要用占位符来标识对应的位置。在传统的JDBC编程中，占位符用“?”来标识，然后在加载SQL之前按照“?”的位置设置参数。而“#{}”在MyBatis中也代表一种占位符，该符号接受输入参数，在大括号中编写参数名称来接受对应参数。“#{}”接受的输入参数的类型可以是简单类型、普通JavaBean或者HashMap。当接受简单类型时，“#{}”中可以写“value”或者其他任意名称。如果接受的是JavaBean，它会通过OGNL读取对象中的属性值。
2、关于${}拼接符 再来看以下的示例，该示例是MyBatis中的SQL映射配置文件（Mapper配置文件），在该配置中使用了${}拼接符。
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="test"&gt; &lt;!-- 根据用户名称，模糊查询用户列表 --&gt; &lt;select id="findUserByUserName" parameterType="java.lang.String" resultType="com.pjb.mybatis.po.User"&gt; SELECT * FROM tb_user WHERE user_name LIKE '%${value}%' &lt;/select&gt; &lt;/mapper&gt; 在SQL映射配置文件中，有时候需要拼接SQL语句。例如在模糊查询的时候，就需要在查询条件的两侧拼接两个“%”字符串，这个时候如果使用“#{}”占位符是不行的。在MyBatis中，“${}”在SQL配置文件中代表一个“拼接符号”，可以在原有SQL语句上拼接新的符合SQL语法的语句。但是要注意的是，使用“${}”拼接的SQL语句，会引起SQL注入，所以一般不建议使用“${}”。“${}”接受输入参数的类型可以是简单类型、普通JavaBean或者HashMap。当接受简单类型时，“${}”中只能写“value”，而不能写其他任意名称。如果接受的是JavaBean，它会通过OGNL读取对象中的属性值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dab903be00debede0b2afd86e9718e07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9976d10c84a4d0a3976ffe237ebe2fa1/" rel="bookmark">
			windows&#43;mingw&#43;msys2编译x264 报错No working C compiler found解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法：
./configure 编译选项添加 --hos=mingw32
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/067cd85f794eebd6042c8075d5b7c693/" rel="bookmark">
			图像重建后由于图像块拼接出现图像块效之优化方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
介绍
方案一：
介绍 随着深度学习的发展，神经网络已经深入各行各业，这里主要介绍下神经网络对图像的重建问题，这里图像重建可以是图像超分辨，图像增强，图像去噪等等。由于现在的显卡显存的限制，对于分辨率比较大的图像来说，直接将原图作为输入往往会导致显存不够，通常的处理的办法是将原图进行切块处理，对图像块进行重建，然后将图像块进行拼接。下面将一一介绍其方案以优化的方案。
方案一： 一个很暴力直接的方案就是图像直接非重叠的进行切块，其图解如下图所示：
假设上图黑色边界表示原图像的大小，图像的分辨率为1024x1024，现以将图像均切成四等份为例，可以切成上图四个512x512大小的图像块，以上切块像块处理方案没有进行重叠。此时的图像块输入大小为512x512。其图像块作为输入得到重建后的图像块，最后将其进行拼接。这样会导致图像重建后每个图像的边界信息处理后不一致，然后拼接后的图像很明显的出现块效应。如下图所示：
可以观察此重建后的图像的局部信息，如下图所示：
很明显的看到会出现图像块效应。
因此需要对其进行改进。
方案二 对于拼接处进行重叠超分重建，然后对重叠部分进行取平均值，具体图解如下：
以将图像切成4等份的patch为例，蓝色边界表示原图大小，这样会形成红色重叠部分假设红色重叠部分为16个像素宽度，实际每个图像块大小为蓝色图像块大小504x504。此时图像块的输入大小仍然为520x520（512+8）（蓝色部分504加红色重叠部分16），重建后进行原位像素拼接，拼接后对于红色重叠部分进行取平均值。
方案三 通过对实际图像大小的块对外扩充一些像素然后对扩充后的图像进行图像重建，图像块重建后对于重叠部分进行切除舍弃处理。具体图解如下图所示：
蓝色的边界仍然表示原图大小，其中黑色实线表示图像中轴线。首先将图像四周进行padding，padding大小为红色重叠部分16个像素，padding后的图像大小为1056x1056。将padding后的图像进行进行切块，此时的输入图像块大小为548x548(512+16*2)进行重建，然后将重建后的图像块切除四周16个像素得到512x512，最后将其依次拼接起来。对于图像块1，重建后将红色部分切除。对于图像块2，左边部分切除黄色部分。
总结 通过实验表明，通过对方案一改进后的方案二、三能够很好的去除块效应，同时，方案三的效果要比方案二更佳。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/547e02e5547ddc480d186adea56a6eeb/" rel="bookmark">
			关于@EnableBatchProcessing注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果用java config的方式配置spring batch中的相关bean，则可能会遇到@EnableBatchProcessing这个注解。
这个注解的用法一般出现在配置文件的上方，如下所示：
@Configuration @EnableBatchProcessing public class BatchConfig { @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public FlatFileItemReader&lt;CreditBill&gt; flatFileItemReader(){ ...... } ...... } @EnableBatchProcessing 这个注解的作用，和spring 家庭中的@Enable* 系列注解功能很类似。顾名思义，就是让我们可以运行Spring Batch。
在配置类上打上这个注解，spring 会自动 帮我们生成一系列与spring batch 运行有关的bean，并交给spring容器管理，而当我们需要这些beans时，只需要用一个@autowired就可以实现注入了。
自动生成的bean及名称如下：
JobRepository - bean name "jobRepository" JobLauncher - bean name "jobLauncher" JobRegistry - bean name "jobRegistry" PlatformTransactionManager - bean name "transactionManager" JobBuilderFactory - bean name "jobBuilders" StepBuilderFactory - bean name "stepBuilders" 如果用过 .xml 文件配置过spring batch 的同学肯定知道，一个spring batch 要运行起来，需要配置 jobRepository、JobLauncher等，还有定义Job以及其相应的步骤，也需要大量的xml代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/547e02e5547ddc480d186adea56a6eeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb30a311de3da56ba8fb3afa81a75219/" rel="bookmark">
			神经网络中episode、epoch、iteration、batch_size的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		epoch、bath_size、iteration、episode在DNN中的解释： 1、epoch：
one forward pass and one backward pass of all the training examples, in the neural network terminology，重点就是所有的训练数据都要跑一遍。假设有6400个样本，在训练过程中，这6400个样本都跑完了才算一个epoch。一般实验需要训练很多个epoch，直到LOSS稳定后才停止。
2、batch_size：
中文名称是批大小，之前的6400个样本，如果送一个样本进去，就更新一次网络的权重，也就是在线学习。与之对应的，我们可以把一个epoch的数据，分批送进网络，可以加快训练时间。每次送多少进去，就是batch_size，假设把6400个样本，分成50次送进去，那么每一次就要送128个样本进去，即batch_size=128。
3、iteration：
我们把一个epoch的所有数据分成了很多批，批数就是iteration，按上面的假设，iteration=50，每经过一个iteration，参数更新一次，可以理解为batch的个数。
样本总数=batch_size * iteration
4、episode：
one a sequence of states, actions and rewards, which ends with terminal state. 这个概念主要是在few-shot或者zero-shot这样的小样本学习中。小样本学习在训练时，会分成很多次训练，每一次都要从所有类中随机选择一些类别来train。一个episode，就是一次选择support set和query set类别的过程，即用选择的某几个类训练一次模型，下一个episode，再选择其他几个类训练模型。一个epoch中存在多个eposide。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28414d14ab9a6d301c6cf9734fc27405/" rel="bookmark">
			JAVA笔记：算法与数据结构【冒泡排序】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 冒泡排序（Bubble Sorting）的基本思想是：通过对待
排序序列从前向后（从下标较小的元素开始）,依次比较
相邻元素的值，若发现逆序则交换，使值较大
的元素逐渐从前移向后部，就象水底下的气泡一样逐渐
向上冒
package com.sort; import java.util.Arrays; /** * @author GodLike * @create 2019-12-02-13:52 */ public class Sort { public static void main(String[] args) { int[] arr = new int[]{2, 4, 1, 9, 3}; System.out.println("排序前："); System.out.println(Arrays.toString(arr)); maoPaoSort(arr); System.out.println("排序后："); System.out.println(Arrays.toString(arr)); System.out.println(Arrays.toString(arr)); } //冒泡排序 public static void maoPaoSort(int[] arr) { boolean flag = false; //改进，可删 int temp = 0; for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28414d14ab9a6d301c6cf9734fc27405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba826bea3d0405ad1ab775d59483bd35/" rel="bookmark">
			FM算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.FM背景与简介
1.1 稀疏数据
1.2为什么进行特征组合
1.3如何组合特征
1.4二次项参数求解方法
1.5公式推导
1.6关于隐向量
2:FM代码实现
3:xlearn流程以及抽取embeding向量
3.1:数据处理
3.2:训练模型
3.3抽取向量
1.FM背景与简介 FM目的主要是为了解决稀疏数据下的特征组合问题。2010年，日本大阪大学(Osaka University)的 Steffen Rendle 在矩阵分解(MF)、SVD++[2]、PITF[3]、FPMC[4] 等基础之上，归纳出针对高维稀疏数据的因子机(Factorization Machine, FM)模型[13]。因子机模型可以将上述模型全部纳入一个统一的框架进行分析[1]。目前，FM被广泛的应用于广告预估模型中，相比LR而言，效果强了不少。
1.1 稀疏数据 高维的稀疏矩阵是工程中常见的问题，比如下图：
图中每一个样本对应多个属性，分别是User,Movie,Other Movies rated,Time,Last Movie rated，由于这些属性都是categorical类型，所以一般进行One-hot编码转换为数值类型，但是由于每个属性都有多个离散的取值，所以One-hot编码之后样本空间相比原来变大了许多，而特征矩阵也会变得非常稀疏。假设有10000部电影，有10000个用户，单看前两条，每个样本的特征维度就是两万维，但是每个特征中只有两维取值不为0，非常稀疏。在CTR/CVR预测时，One-Hot编码常会导致样本的稀疏性，样本的稀疏性是实际问题中不可避免的挑战。
1.2为什么进行特征组合 下面以一个示例引入FM模型。假设一个广告分类的问题，根据用户和广告位相关的特征，预测用户是否点击了广告。源数据如下：
“Clicked?”是label，Country、Day、Ad_type是特征。由于三种特征都是categorical类型的，需要经过独热编码（One-Hot Encoding）转换成数值型特征。
由上表可以看出，经过One-Hot编码之后，大部分样本数据特征是比较稀疏的。上面的样例中，每个样本有7维特征，但平均仅有3维特征具有非零值。
同时通过观察大量的样本数据可以发现，某些特征经过关联之后，与label之间的相关性就会提高。例如，“USA”与“Thanksgiving”、“China”与“Chinese New Year”这样的关联特征，对用户的点击有着正向的影响。换句话说：来自“China”的用户很可能会在“Chinese New Year”有大量的浏览、购买行为；而在“Thanksgiving”却不会有特别的消费行为。这种关联特征与label的正向相关性在实际问题中是普遍存在的，如&lt;“化妆品”类商品，“女”性&gt;，&lt;“球类运动配件”的商品，“男”性&gt;，&lt;“电影票”的商品，“电影”&gt;品类偏好等。因此，引入两个特征的组合是非常有意义的。
1.3如何组合特征 SVM就曾通过多项式核函数来实现特征的交叉。实际上，多项式是构建组合特征的一种非常直观的模型。我们先看一下二阶多项式的建模，只有两个特征都是非零的时候组合特征才有意义：
从公式来看，模型前半部分就是普通的LR线性组合，后半部分的交叉项即：特征的组合。单从模型表达能力上来看，FM的表达能力是强于LR的，至少不会比LR弱，当交叉项参数全为0时退化为普通的LR模型。
从公式(1)可以看出，组合特征的参数一共 个，任意两个参数都是独立的。然而，在数据稀疏性普遍存在的实际应用场景中，二次项参数的训练是很困难的。其原因是：每个参数 wij 的训练需要大量xi 和 xj都非零的样本；由于样本数据本来就比较稀疏，满足xi 和 xj都非零”的样本将会非常少。训练样本的不足，很容易导致参数 wij 不准确，最终将严重影响模型的性能。
1.4二次项参数求解方法 矩阵分解提供了一种解决思路。在model-based的协同过滤中，一个rating矩阵可以分解为user矩阵和item矩阵，每个user和item都可以采用一个隐向量表示。比如在下图中的例子中，我们把每个user表示成一个二维向量，同时把每个item表示成一个二维向量，两个向量的点积就是矩阵中user对item的打分。
任意的 N×N 实对称矩阵都有 N 个线性无关的特征向量。并且这些特征向量都可以正交单位化而得到一组正交且模为 1 的向量。故实对称矩阵 A 可被分解成：
1.5公式推导 引入辅助向量V之前，计算复杂度为O(n2)，引入V之后，为O(kn)，通过交叉项求解，我们知道，计算复杂度为O(kn)。一般来说k远小于n。
之后就可以用梯度下降法求解了，FM模型的梯度为：
1.6关于隐向量 这里的 vi 是 xi 特征的低纬稠密表达，实际中隐向量的长度通常远小于特征维度N，在实际的CTR场景中，数据都是很稀疏的category特征，通常表示成离散的one-hot形式，这种编码方式，使得one-hot vector非常长，而且很稀疏，同时特征总量也骤然增加，达到千万级甚至亿级别都是有可能的，而实际上的category特征数目可能只有几百维。FM学到的隐向量可以看做是特征的一种embedding表示，把离散特征转化为Dense Feature，这种Dense Feature还可以后续和DNN来结合，作为DNN的输入，事实上FNN的CTR也是这个思路来做的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba826bea3d0405ad1ab775d59483bd35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a1c8b60b681859e6393af46c4096327/" rel="bookmark">
			springboot 整合apollo时引用apollo-client后报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot 整合apollo时引用apollo-client后报错 java.lang.NoSuchMethodError: org.yaml.snakeyaml.Yaml.&lt;init&gt;(Lorg/yaml/snakeyaml/constructor/BaseConstructor;Lorg/yaml/snakeyaml/representer/Representer;Lorg/yaml/snakeyaml/DumperOptions;Lorg/yaml/snakeyaml/LoaderOptions;Lorg/yaml/snakeyaml/resolver/Resolver;)V at org.springframework.boot.env.OriginTrackedYamlLoader.createYaml(OriginTrackedYamlLoader.java:70) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at org.springframework.beans.factory.config.YamlProcessor.process(YamlProcessor.java:132) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE] at org.springframework.boot.env.OriginTrackedYamlLoader.load(OriginTrackedYamlLoader.java:75) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at org.springframework.boot.env.YamlPropertySourceLoader.load(YamlPropertySourceLoader.java:50) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.loadDocuments(ConfigFileApplicationListener.java:570) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.load(ConfigFileApplicationListener.java:526) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.loadForFileExtension(ConfigFileApplicationListener.java:503) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.load(ConfigFileApplicationListener.java:470) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.lambda$null$6(ConfigFileApplicationListener.java:451) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at java.lang.Iterable.forEach(Iterable.java:75) ~[na:1.8.0_91] at org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.lambda$load$7(ConfigFileApplicationListener.java:450) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at java.lang.Iterable.forEach(Iterable.java:75) ~[na:1.8.0_91] at org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.load(ConfigFileApplicationListener.java:447) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.load(ConfigFileApplicationListener.java:336) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at org.springframework.boot.context.config.ConfigFileApplicationListener.addPropertySources(ConfigFileApplicationListener.java:215) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at org.springframework.boot.context.config.ConfigFileApplicationListener.postProcessEnvironment(ConfigFileApplicationListener.java:198) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at org.springframework.boot.context.config.ConfigFileApplicationListener.onApplicationEnvironmentPreparedEvent(ConfigFileApplicationListener.java:185) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at org.springframework.boot.context.config.ConfigFileApplicationListener.onApplicationEvent(ConfigFileApplicationListener.java:171) ~[spring-boot-2.0.6.RELEASE.jar:2.0.6.RELEASE] at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127) ~[spring-context-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a1c8b60b681859e6393af46c4096327/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aac63910e064b79b5403ae04c83dd18/" rel="bookmark">
			sklearn库的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上有很多关于sklearn的学习教程，大部分都是简单的讲清楚某一个方面。其实最好的教程就是官方文档（http://scikit-learn.org/stable/），但是官方文档讲述的太过于详细，同时很多人对官方文档的理解和结构认识上都不能很好的把握。我写这篇文章的目的是想用一篇文章讲清楚整个sklearn库，我会讲清楚怎么样用这个库，而不是讲清楚每一个知识点。（授人以鱼不如授人以渔）（本文很多都是从实践的角度出发，也仅仅只代表我个人的认识） 本篇文章主要从两个方面出发：1，介绍sklearn官方文档的类容和结构；2，从机器学习重要步骤出发讲清楚sklearn的使用方法。
一、sklearn官方文档的类容和结构 1，机器学习的认识：从实践的角度出发，机器学学习要做的工作就是在我们有的一个数据集上建立一个或者多个模型，然后对我们的模型进行优化和评估。我们将会在sklearn中看到下图各个模块到底是什么，怎么用。 2，sklearn库官方文档结构： 下图表示：官方文档有很多模块： tutorials：是一个官方教程，可以理解快速上手教程，但是看完感觉并没有很快。 user guide(用户指南）：这里对每一个算法有详细的介绍 API：这里是库调用的方法 FAQ：常见问题 contributing:贡献，还介绍最新的一些代码，功能。 （下面三个就跟没有用了） 总结：一般的做法是API里面找到你要调用的方法，然后可以查看方法参数的情况和使用情况。也可以在指南里面找到具体的解释。
3，sklearn库的结构： （1）结构： 由图中，可以看到库的算法主要有四类：分类，回归，聚类，降维。其中：
常用的回归：线性、决策树、SVM、KNN ；集成回归：随机森林、Adaboost、GradientBoosting、Bagging、ExtraTrees常用的分类：线性、决策树、SVM、KNN，朴素贝叶斯；集成分类：随机森林、Adaboost、GradientBoosting、Bagging、ExtraTrees常用聚类：k均值（K-means）、层次聚类（Hierarchical clustering）、DBSCAN常用降维：LinearDiscriminantAnalysis、PCA （2）图片中隐含的操作流程： 这个流程图代表：蓝色圆圈内是判断条件，绿色方框内是可以选择的算法。你可以根据自己的数据特征和任务目标去找到一条自己的操作路线，一步步做就好了。
二、机器学习主要步骤中sklearn应用 1，数据集：面对自己的任务肯定有自己的数据集，但是对于学习来说，sklearn提供了一些数据，主要有两部分：现在网上一些常用的数据集，可以通过方法加载；另一种sklearn可以生成数据，可以生成你设定的数据。（设定规模，噪声等） 下面是一段python实例：
from sklearn import datasets from sklearn.linear_model import LinearRegression import matplotlib.pyplot as plt #使用以后的数据集进行线性回归（这里是波士顿房价数据） loaded_data=datasets.load_boston() data_X=loaded_data.data data_y=loaded_data.target model=LinearRegression() model.fit(data_X,data_y) print(model.predict(data_X[:4,:])) print(data_y[:4]) #使用生成线性回归的数据集，最后的数据集结果用散点图表示 X,y=datasets.make_regression(n_samples=100,n_features=1,n_targets=1,noise=10) #n_samples表示样本数目，n_features特征的数目 n_tragets noise噪音 plt.scatter(X,y) plt.show() 2，数据预处理：数据预处理包括：降维、数据归一化、特征提取和特征转换（one-hot）等，这在sklearn里面有很多方法，具体查看api。这里用归一化（preprocessing.scale() ）例子解释一下：
from sklearn import preprocessing #进行标准化数据时，需要引入个包 import numpy as np from sklearn.cross_validation import train_test_split from sklearn.datasets.samples_generator import make_classification from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aac63910e064b79b5403ae04c83dd18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b730101ca81d327d217edff2e058d343/" rel="bookmark">
			存储空间都去哪了？占用空间比文件大太多？可能是文件系统和默认簇大小惹的祸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记本仅有的内置的256GB的SSD实在是伤不起，于是我又买了一块SSD移动硬盘，把不太常用的大软件和学习软件 （STEAM）装在了它上面。
但是当我装了OCTAVE（MATLAB的开源替代）之后我发现事情并没有那么简单。
OCTAVE的安装包只有286MB，可是当我安装以后，占掉了我移动硬盘少了18G多。
查看软件所在的文件夹，发现文件夹的“大小”显示为5.25GB，可是占用空间却达到18.4GB
占用空间比文件本身大小大的因是“簇”这个概念的存在，是分配用来保存文件的最小磁盘空间量。即使一个单独的文件再小，也会占用一个“簇”的大小。“簇”在Windows中也被称为“分配单位”，当我们格式化硬盘的时候也是有这个选项的。
可为什么这样的现象只是出现在我的移动硬盘上，而在我的内置硬盘上占用空间与文件大小相差不大呢？
莫非是因为我的移动硬盘的“簇”太大的缘故吗？
确实。我的移动硬盘出厂时的文件系统是exFAT
微软官方对不同的文件系统的默认簇大小进行详细的介绍：
https://support.microsoft.com/zh-cn/help/140365/default-cluster-size-for-ntfs-fat-and-exfat
可以看到，16TB以下的NTFS格式的硬盘的默认簇大小都是4KB。而对于32GB以上的exFAT的硬盘，其默认的簇大小是128KB，这也就意味着不论文件有多小，都得占用128KB。
NTFS文件系统是“日志式”的，会进行大量的擦写工作，有可能会缩短闪存的寿命。exFAT格式是适合于闪存的文件系统，为了解决FAT32等不支持4G及其更大的文件而推出。
而如今SSD移动硬盘甚至是U盘大于32GB已经是很常见的了。如果是想像我一样向SSD移动硬盘或者U盘里装软件、存储很多的小文件的话，建议买来以后重新格式化，将簇大小设置为4KB。
我不得不先把文件都拷出去，格式化时将簇大小设置为4KB，再把文件都拷回来，最终相比之前要多出了30GB左右的可用空间，效果还是很明显的。
p.s.复制的时候可以用factcopy这个小软件，可以无人值守，速度也应该要比资源管理器快。
觉得有用的话，不要吝惜评论点赞分享哦，希望大家多多包涵，有任何问题欢迎指正、讨论。
本文基于CC-BY-SA 4.0协议，欢迎转载
（博客看累了？去我的B站瞧一瞧？）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7334e980aba560743f0061b983985147/" rel="bookmark">
			【计算机组成原理】大端模式，小端模式，字节，高地址，低地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做毕业设计，做着做着发现最熟悉的东西变成了最陌生的东西。学完计算机组成原理就知道了大端模式是低地址存高位，小端模式是低地址存低位。上面加粗的文字死记硬背当然比较难了，如果联想一下我们十进制数的表示，比如就987这个数字吧。我们习惯上会从左边开始读书或者是读一个数字，那么我们就认为左边是低地址，从左到右地址编址从小到大。而我们这个数字它的最高位是百位，该位上对应的值是9，我们就发现数字9是最高位，而存放它的地址是低地址。所以我们就认为所谓大端模式就是人们习惯使用的模式。记住了大端模式，小端模式当然不难记了，就是人们不习惯用的模式。我们在研究这两种模式之前，先来看下什么是字节，以及字节内部的数值表示方式： 一、字节 首先众所周知，一个字节（1 byte)等于八个位（8 bits)。也就是说所谓一个字节，不过是连续的8个位。那么一个数字是如何存储在这个字节中的呢？ 首先我要说，下面的例子是为了能够理解字节，而真正数据存储是要按照补码来存。其实很简单，比如说数字6，存储在一个字节中就是0000 0110，化成16进制就是06。 上面的解释没有什么疑问吧？如果有欢迎在评论区指正或提问。下面再来看下什么是地址： 二、地址 首先，我们知道了字节中能够存放数据，那么我们怎么知道我们的哪个数据对应存放在哪个字节中呢？这就需要地址来帮助我们，在计算机中每一个字节都有一个编号，我们把这个编号称为是地址，就是这么简单。举个例子，下面是计算机里面的存储单元，一个方框代表一个位。8各位组成一个字节，每个字节都有其地址：
下面我们再来看什么是小端模式： 三、小端模式 我们在回忆一下，小端模式是。。。。。。。。。。。。。。。。思考。。。。思考。。。。。。。。。。思考。。。。。。。。。思考。小端模式是我们不习惯使用的模式，就是低地址存储低位。好那我们具体看下，比如说我们要存储一个int类型的数字6。首先，众所周知，int类型需要4 bytes来存放，也就是需要32 bits来存放。好的那我们先把它需要的内存空间给列出来，如下图中，四个字节，每个字节从小到大进行编号后，将编号作为地址： 空间有了，那么我们要怎么样存放呢？。。。。。。。思考。。。。。。。思考。。。。。。思考。。。。。首先，计算机不可能把十进制的6直接存储下来，是吧。所以我们先把他写成二进制形式，注意，它是int类型，需要用32 bits来表示，结果就是0.......110,省略号表示28个零。然后，我们知道存储的最小单位是字节，而一个字节是8位，所以我们再次把这个二进制数，8位为一组，分成4组。也就是按照字节来写，那就是四个字节，分别是0000 0000, 0000 0000, 0000 0000, 0000 0110。好了到这一步，应该没有什么问题吧？有问题的话，欢迎在评论区指针或者提出。下一步就要思考，如何把上面这四个字节存放在我们之前已经准备好的内存中。这一步也是最关键的一步。我们在来回忆一下什么是小端模式。。。。。。。。。思考。。。。。。。。思考。。。。。。。。思考。。。。。。。思考。。。。。。。。。思考。。。。。。。。思考。也就是说，我们需要把数字的低位存放在内存的低地址。
- 首先，数字从左至右，是从高位到低位，那么我们的最低位，就是最后一个字节，也就是0000 0110。
- 然后地址的低地址，当然就是编号比较小的地址了，也就是0。
- 最后，就是说，我们要把0000 0110这个字节，存放在0所指向的内存空间。如下图：
其它的依次类推，最终结果如下图，
四、大端模式 详细讲了小端模式，大端模式就不详细说了，和小端模式相反，把高位存储在低地址，也就是把0000 0110这个字节，存储在地址为3的空间中。 五、举个例子 上面说了这么多，不来点实际的谁知道你是不是在瞎扯呢。
好那就把引发我研究这个知识点的问题拿出来和大家分享下。
下面这个是wireshark抓包后的数据，大家不需要看其他的，只需要看我标出来的部分东西：
红框框住的东西，是我写进去的两个数字分别是0和6，图中使用16进制来显示。我就不做分析了，欢迎各位在评论区给出答案，这是用大端还是小端，哪几个数字表示了0，哪几个数字表示了6，等等。
我会及时回复评论的。
最后做一下总结，说了这么多，其实就是说，大端和小端，不影响字节内部如何存储数据，影响的只是字节在内存中的摆放顺序。大端，就顺着摆，小端就反着摆。
文章存在bug或者有问题，欢迎在评论区讨论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f4507e12d956fb4218f6017089f7e0/" rel="bookmark">
			线索二叉树(建立与遍历)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线索二叉树的建立很需要思维能力，尽量把原理弄懂在去查看代码。
二叉树线索化
二叉树的遍历是按照一定的规则把二叉树中的节点按照一定的次序排列成线性序列进行访问的，实质上就是对一个非线性结构进行线索化操作，使得每个节点（除第一个和最后一个外）都有前驱和后继节点，有时为了运算方便需要记录这些前驱和后继节点，称为二叉树线索化，而对于不同的遍历规则，又分为先序线索二叉树，中序线索二叉树(常用)，后序线索二叉树。
思路:
一颗具有n个节点的二叉树，有n-1条指向左孩子或右孩子的分支，对于二叉链表来说，2n个指针只用了n-1个，所以可以利用另外n+1个指针作为指向前驱节点和后继节点的指针。
图一是InThreading函数所做的事情(通过中序遍历的方式把所有节点连接起来)
图二是addmiddleNode函数所做的事情,一般是增加头节点后再取调用InThreading函数。
#include &lt;bits/stdc++.h&gt; using namespace std; typedef char Elemtype; typedef int Elemtvar; /** 定义结构体 */ typedef struct BitNode{ Elemtype data; Elemtvar ltag,rtag;	//0代表左/右孩子 1代表前驱/后驱 BitNode *lchilid,*rchild;	//左节点,右节点 }BitNode,*BitTree; /** 创建链表 */ void createBitTree(BitTree &amp;p){ char data; scanf("%c",&amp;data); if(data=='#'){ p=NULL; }else{ p=new BitNode;	//分配指针存储空间 p-&gt;data=data; p-&gt;ltag=0; p-&gt;rtag=0; createBitTree(p-&gt;lchilid); createBitTree(p-&gt;rchild); } } /** 打印链表 中序打印 */ void printTree(BitTree &amp;p){ if(p){ printTree(p-&gt;lchilid); cout&lt;&lt;p-&gt;data; printTree(p-&gt;rchild); } } /** 线索化二叉树 类似中序遍历(作用是把普通的二叉树叶子节点上增加前驱与后驱,这样就变成了线索二叉树) */ BitTree pre=NULL; void InThreading(BitTree &amp;tree){ if(tree!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f4507e12d956fb4218f6017089f7e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/879055ec1a8176960fbd7aaade4f49c9/" rel="bookmark">
			Toybrick RK3399Pro安装ROS系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS(Robot Operating System)是一个适用于机器人软件开发的元操作系统。它提供了操作系统应有的服务，包括硬件抽象、底层设备控制、常用函数实现、进程间消息传递以及包管理。它是一系列工具、库和准则，旨在简化在各种机器人平台上创建复杂而强大的机器人行为的任务。
Toybrick RK3399Pro使用的固件是ubuntu 18.04，百度云盘:https://pan.baidu.com/s/16ckBFs_HNwZuvzm46EaXNQ 提取码pa6u。选择系统对应的ROS版本。
系统版本ROS版本Ubuntu Trusty (14.04 LTS)、Debian WheezyROS Indigo Igloo(ROS Jade Turtle )Ubuntu Wily (15.10)ROS Kinetic KameUbuntu Xenial (16.04 LTS)、Debian JessieROS Kinetic KameArtful (17.10)ROS Melodic MoreniaBionic (18.04 LTS)、Debian StretchROS Melodic Morenia 1、设置Ubuntu的sources.list以便安装packages.ros.org中的软件 。
sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list' 2、设置密钥
sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 3、确保ubuntu软件包索引是最新的
sudo apt update 4、安装
ROS提供了3种默认配置，一般研究为主选择完全安装。
桌面-完全安装(推荐)：包括ROS核心、rqt、rviz、机器人通用库、2D/3D模拟器等。
sudo apt install ros-melodic-desktop-full 桌面安装：包括ROS核心、rqt、rviz、机器人通用库。
sudo apt install ros-melodic-desktop 基础版：包括ROS核心、构建和通信库，没有GUI工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/879055ec1a8176960fbd7aaade4f49c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f920ecf3ee9b977ed31e1350cd6a18/" rel="bookmark">
			FileNotFoundError: [Errno 2] No such file or directory:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.原因是os.mkdir 只能生成下一级的目录文件. 若要想生成多个子路径下的文件，需要将os.mkdir 改成 os.makedirs。
2.路径错误，代码中文件路径改为绝对路径，盘符什么的全都带上。
3.出现 **FileNotFoundError: [Errno 2] No such file or directory:**时，如果路径正确的情况下，可以考虑将前面的代码进行检查是否存在错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12f921c901a5c56173c68cfb538e89e5/" rel="bookmark">
			客户端没有使用websocket协议:&#39;upgrade&#39;令牌未在&#39;Connection&#39;头中找到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误：websocket: the client is not using the websocket protocol: ‘upgrade’ token not found in ‘Connection’ head
当反向代理或负载平衡器未正确传递WebSocket请求时，就会出现此问题。以下是解决此问题的说明。
For Nginx
proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection upgrade For Apache:
&lt;Location /ws&gt; ProxyPass ws://localhost:8000 ProxyPassReverse ws://localhost:8000/ &lt;/Location&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6d0f73d52dd4ab758cd991c1fd196d/" rel="bookmark">
			Scrapy之Selector详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、简介二、xpath三、获取值四、css选择五、xpath扩展 一、简介 前面介绍了scrapy命令和Scrapy处理流程与重要组件 这里介绍一下Scrapy的Selector，Scrapy的Selector和Beautifulsoup非常像，关于Beautifulsoup可以参考BeautifuSoup实用方法属性总结 和BeautifulSoup详解
先来看一下Selector的知识点：
二、xpath 我们先介绍一下xpath，因为xpath语法比较简洁，并且如果能够灵活应用的话，可以简化我们提取HTML内容的复杂度。
符号说明/从根节点选取，使用绝对路径，路径必须完全匹配//从整个文档中选取，使用相对路径.从当前节点开始选取…从当前节点父节点开始选取@选取属性 光看说明有些抽象，我们通过一个例子来简单说明一下：
# -*- coding:utf-8 -*- from scrapy import Selector content = ''' &lt;div&gt; &lt;p&gt;out inner div p&lt;/p&gt; &lt;div id="inner"&gt;&lt;p&gt;in inner div p&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;p&gt;out div p&lt;/p&gt; ''' selector = Selector(text=content) # 在整个文档中选取id为inner的div节点 inner_div_sel = selector.xpath("//div[@id='inner']") # 获取整个文档中的p节点的文本 print(inner_div_sel.xpath('//p/text()').getall()) # 从inner div节点的父节点开始获取所有p节点的文本 print(inner_div_sel.xpath('..//p/text()').getall()) # 从inner div节点开始获取所有p节点的文本 print(inner_div_sel.xpath('.//p/text()').getall()) Scrapy的Selector和BeautifulSoup一样，可以通过字符串来构造相应的对象，然后就可以使用xpath相关的语法来解析HTML。
inner_div_sel = selector.xpath("//div[@id='inner']") 首先@在xpath中表示选取属性，@id就表示选取id属性，//div[@id=‘inner’]就表示，选取id属性值为inner的div标签。
inner_div_sel.xpath('//p/text()').getall() 上面的语句的输出是：
['out inner div p', 'in inner div p', 'out div p'] 很奇怪，我们已经在inner的div节点选取p，为什么获取到了所有的p？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6d0f73d52dd4ab758cd991c1fd196d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5615d8e9d6eee399ae78f464b7a4d35b/" rel="bookmark">
			python unittest.TestCase
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unittest.Testcase : https://docs.python.org/zh-cn/3/library/unittest.html
测试样例， 文档
函数名需要 “test” 开头，才能被应用 Ran 0 tests in 0.000s 这个测试样例 没有 被应用
import unittest class test_myClass(unittest.TestCase): # def testgetNameEmpty(self): ## 函数名需要 “test” 开头，才能被应用 def getNameEmpty(self): self.assertEqual("love","peace") # self.assertEqual("love","love") if __name__ == "__main__": unittest.main() daiyi:daiyi$ python ./daiyi-b.py ---------------------------------------------------------------------- Ran 0 tests in 0.000s OK 函数名需要 “test” 开头
Ran 1 tests in 0.000s 有一个测试样例被应用
import unittest class test_myClass(unittest.TestCase): def testgetNameEmpty(self): ## 函数名需要 “test” 开头，才能被应用 # def getNameEmpty(self): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5615d8e9d6eee399ae78f464b7a4d35b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0edca3dc26d2c98cd5de126b5af33555/" rel="bookmark">
			反卷积(Deconvolution)、上采样(UNSampling)与上池化(UnPooling)加入自己的思考（pytorch函数）（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ps:最近在做分割在github上找代码看模型时老发现尺度从小到大那部分，有的是采用上采样（双线性插值）＋卷积，有的用反卷积。为什么不相同能，我查阅相关资料发现这位知乎大神根据外网大佬文章总结原因。知乎地址：https://www.zhihu.com/question/328891283。先放下我之前一二中都会放的图：
这次我们重点关注下反卷积和上采样＋卷积的结果对比。借用上面知乎大神的示例代码：
import mxnet as mx batch_size = 1 in_channel = 1 height = 2 width = 2 data_shape = (batch_size, in_channel, height, width) data = mx.nd.ones(data_shape) print(data) out_channel = 1 kernel_size = 2 deconv_weight_shape = (in_channel, out_channel, kernel_size, kernel_size) deconv_weight = mx.nd.ones(deconv_weight_shape) stride = 2 up_scale = 2 data_deconv = mx.nd.Deconvolution(data=data, weight=deconv_weight, kernel=(kernel_size, kernel_size), stride=(stride, stride), num_filter=out_channel) print(data_deconv) data_upsample = mx.nd.contrib.BilinearResize2D(data=data, scale_height=up_scale, scale_width=up_scale) print(data_upsample) conv_weight_shape = (out_channel, in_channel, kernel_size, kernel_size) conv_weight = mx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0edca3dc26d2c98cd5de126b5af33555/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf5d10bde348783844171af1cfb60b9/" rel="bookmark">
			node&#43;express 基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单介绍下node+express的基本使用 1：安装node环境 2：加载express 依赖 npm install express --save 3：新建index.js 入口文件
4：具体目录结构
# 目录 - data ---------- 静态数据库 - index.js ---- 统一导出导出 - login.js ----- 具体接口内容 - list.js ----- 具体接口内容 - newsList.js ----- 具体接口内容 - config.js ----- 接口映射文件 - index.js ----- 入口文件 - router.js ----- 具体接口代码 5：具体代码如下： config.js文件
/** * 接口统一处理 * */ module.exports = { list:"/list", newsList:"/newsList", login:"/login", } index.js
var express = require("express"); var app = express(); var router = require("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caf5d10bde348783844171af1cfb60b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4fcce8b89c45b515e3af0135401b22/" rel="bookmark">
			Docker基础之docker来源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章定位于基础：
本文将从如下几个方向，来梳理docker的起因、经过、结果。
一、什么是docker
二、docker经历了怎样的发展？
三、docker解决了什么问题
一、什么是docker 1、在docker出生以前，通过虚拟机的形式实现服务器的合理利用。 2、Docker 是 PaaS 提供商 dotCloud 开源的一个基于 LXC 的高级容器引擎（已存在技术，想开发个优秀的） 3、开发过程中发现如果剑走偏锋还有妙用： 传统LXC 的高级容器引擎： 包含完整的操作系统，是一个系统容器。 dotCloud 公司的 LXC引擎： 将应用和其依赖环境全部打包到一个单一对象中，在不包含完整的操作系统的情况下就能运行普通应用，更加轻量级，可移植性更好。 至此主角 docker诞生。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61eac77ab78db370b5f44a2309f974f0/" rel="bookmark">
			菜鸟初次接触框架逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 图书管理系统 一.变量，动态内存，结构体的准备。 一些程序中需要用到的工具，我会放在同一个头文件中，包括函数的声明，结构体的定义，宏定义，变量的外部声明，这样做的好处就是方便调用，在程序编写过程中，减少了无定义变量或结构体的错误。 2.整体逻辑框架的构思 根据需求分为几大模块，界面三个功能分为三大板块，三个功能函数入口放在同一个文件中，也是main函数下面的第一个文件。main函数担任启动的角色，main文件中越少越好，全局结构体和变量的定义还可以放在main文件下面的文件中。main文件后面的文件担任总指挥的功能，具有实现各个大功能板块的权限，我习惯用surface.c 来命名。各个功能分别用不同的ch组合来实现，各个组合下面连接着各自的分支。整体框架分模块，功能板块再分模块，功能板块分为终端操作功能模块，和计算机底层实现模块，不同属性的功能放在不同的文件中，能方便管理，有效的减少错误。 在编程过程中，我习惯一边写一边检查错误而不是等到最后再来检查，每个文件结束时都检查文件的错误，防止最后错误成堆。 对于初次接触项目，虽然很简单，但对于新手还是有所收获，这种写项目的方法，大大减少了段错误的概率，整个编程过程还算是顺利的，收获也很多，以后的学习中还会掌握更多的逻辑框架构建方法，而且我认为项目一开始的方向思路和步骤，至关重要，虽然是第一次写项目，但已经认识到了这一点，没想好方向千万别动手。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6abbff2665ef169d600c72c035b470f/" rel="bookmark">
			JVM快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、类加载机制： PS:关于双亲委派机制，扩展类加载器在JDK1.9中改为了平台加载器，如下图所示 2、JVM内存模型 JDK1.7版本 （方法区=Non-Heap, hotspot中为永久代） 在JDK1.8中，永久代改为元数据空间，直接由操作系统分配，不再受限于JVM。 方法区在逻辑上属于堆内存，表现在： 线程共享；都可以被GC所管理。 关于JDK1.7与JDK1.8的堆内存具体差异，可以看下图 JDK1.8 JDK1.7 计算伸缩区是否使用，将会耗费一定的计算资源，又因为使用JVM肯定要尽可能的往大设置，在我们工作中伸缩区的存在意义不大，所以一般设置"-Xmx512M -Xms512M"，其中512M根据自己需要设定，单位可以是M，也可以是G，二者应该设置相同的数值。 -Xmx设置的为JVM最大堆内存，默认物理内存的1/4； -Xms设置的为JVM初始堆内存，默认物理内存的1/64； 3、对象可以回收的依据——对象不可用 引用计数器和可达性分析算法两种。
引用计数器记录对象是否被引用，当计数器为零时，说明对象已经不再被使用，可以进行回收。java中的对象有复杂的引用关系，如两个对象互相引用，引用计数器无法判定这种情况，所以sun jdk中并没有实现这种GC方式。
可达性分析：从GC Roots作为起始点，向下搜索，搜索所走过的路径成为引用链（Reference Chain）。当一个对象到GC Roots不存在引用链时，证明此对象不可用。
4、内存回收算法 1）三种回收算法的介绍 复制：从根集合搜扫描出存活的对象，然后将存活的对象复制到一块新的未使用的空间中，当要回收的空间中存活的对象较少时，比较高效。年轻代使用这种算法；
标记清除：从根集合开始扫描，对存活的对象进行标记，比较完毕后，再扫描整个空间中未标记的对象，然后进行回收，不需要对对象进行移动；
标记整理：基于“标记清除”，但是回收不存活的对象后，会把所有存活的对象在内存空间中进行移动，好处是减少了内存碎片，缺点是成本比较高。老年代使用这种算法；
PS:会发生STW（Stop-The-World）问题，暂时挂起所有的执行线程，标记可以回收的对象。
2）复制算法的应用——年轻代垃圾回收机制 年轻代 Eden 伊甸园区
占年轻代80%空间
新建的对象放这里，如果过大直接放老年代。S0 10%空间S1 10%空间 回收时，伊甸园+S0存活的对象，放入S1；清空伊甸园+S0；再次回收时，伊甸园+S1存活的对象，放入S0；清空伊甸园+S1；1-4步循环进行，必定有10%的年轻代空间被浪费掉；S0或者S1放不下对象时（分配担保），或对象年龄（存活一次回收+1）够大时，或新生对象过大时，或动态年龄比例满足条件时（根据年龄划分，低龄对象所占空间占比达到50%，送走高龄），将对象放入老年代。 5、GC处理流程 1、新对象都会在伊甸园区开辟，伊甸园区的内存空间不足会发生MinorGC。 Member mem = new Member()，很小，直接保存在伊甸园；过大，放入老年代。 2、有些对象执行了N次的MinorGC后还会存在，那么这些对象将进入到存活区（S0+S1，永远都有一个空着）； 3、根据大小、年龄、动态年龄比例，或者存活区放不下了，把相应的对象放入老年代； 4、若干次MinorGC回收之后空间依然不够使用，那么则进行老年代GC回收，执行了MajorGC（Full GC，性能很差），如果可以回收空间，则继续进行MinorGC； 5、如果MajorGC失败，则继续内存已经占用完满，则抛出OOM异常； 6、G1算法 支持大内存（4G-64G）；支持多CPU；减少STW停顿时间；可以保证并发状态下的程序执行；采用分片的思想，每个片区都有自己独立的年轻代、老年代，独立进行自己的垃圾回收。开启命令 -XX:+UseG1GC 7、jvm性能调优 java内存分析工具： jmap -heap PIDtomcat/bin/catalina.sh（8G机器）添加JAVA_OPTS="-Xms4096m -Xmx4096m -Xss1024K -XX:+UseG1GC” 8、其他资料 为什么要有GC（垃圾回收）？ JVM通过GC来回收堆和方法区中的内存，GC的基本原理就是找到程序中不再被使用的对象，然后回收掉这些对象占用的内存。
主要的收集器有哪些？ 引用计数器和跟踪计数器两种。
引用计数器记录对象是否被引用，当计数器为零时，说明对象已经不再被使用，可以进行回收。java中的对象有复杂的引用关系，不是很适合引用计数器，所以sun jdk中并没有实现这种GC方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6abbff2665ef169d600c72c035b470f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78d1ad3d16417f6e6dde18175729da25/" rel="bookmark">
			Android 如何正确的重写 onDestroy() 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道大家在写 Android 的时候有没有遇到过这样的一个疑惑：当你在重写 onDestry() 的方法时，有没有犹豫过，我们自己的方法，是应该放在 super.onDestroy() 方法的上面呢？还是应该放在 super.onDestroy() 方法的下面呢？如下所示：
@Override protected void onDestroy() { //是将我们的方法放在这呢？ super.onDestroy(); //还是将我们的方法放在这呢？ } 带着这样的一个疑惑，我踏上了，解惑之旅！
1. 回头学习一下 super 关键字 super 是 Java 中的一个关键字，指代父类，用于调用父类中的普通方法和构造方法。 在 Java 中子类可以继承父类中所有可访问的数据域和方法，但不能继承父类中的构造方法，所以需要利用 super 来调用父类中的构造方法。
public class Father {	public Father() { System.out.println("I'm father, I have a car."); } } public class Son extends Father{ public Son() { super(); System.out.println("I'm son, my father will send him car to me."); } } public class JereTest { public static void main(String[] args) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78d1ad3d16417f6e6dde18175729da25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/864ca5607f60adccd68b5c18df29db01/" rel="bookmark">
			python循环删除列表和字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、循环删除列表中的元素 lis = [11,22,33,44,55] for i in range(len(lis)): del lis[i] 删除报错，因为删除过程中，列表的下标会自动补齐到0
2、将偶数从列表中删掉 lis = [11,22,33,44,55] for i in range(len(lis)): if len[i] % 2 == 0: print (lis) 3、将字典里面键名称含有K的键值对删掉 dic = {'k1':'v1','k2':'v2','a3':'v3'} for i in dic: if 'k' in i: del dic[i] 报错信息：
Traceback (most recent call last):
File “C:/python/diangotest/20191125.py”, line 23, in for i in dic:
RuntimeError: dictionary changed size during iteration
解决方案1：生成一个新的字典，将键值不包含’k’的加入进去 dic1 = {} for i in dic: if 'k' not in i: dic1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/864ca5607f60adccd68b5c18df29db01/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/453/">«</a>
	<span class="pagination__item pagination__item--current">454/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/455/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>