<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e08dc3a4f6b30fbc7760b0383912baf/" rel="bookmark">
			Nginx代理Tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
首先由于资源有限，我采用虚拟机的形式向大家进行演示，虚拟机中的ip都是一致的，通过改变端口的形式来展示不同的服务器，从而实现用Nginx来代理多态Tomcat。
在Linux中安装两台Tomcat 主要是修改tomcat的配置文件，第一个tomcat配置文件不变，改变第二个，主要改变以下三项
进行反向代理 修改nginx/conf/nginx.conf文件：代理一台
代理多台tomcat（负载均衡） 1、在http节点上添加一个upstream
2、修改location /下的反向代
负载均衡策略 1、权重
2、ip_hash
根据IP进行计算， 随后确定固定的服务器 ，url也同理
动静分离 配置nginx的nginx.conf
location ~* \.(gif|jpg|png|jpeg)$ {
root /usr/upload/images;
}
如果没有这个文件夹需要创建
随后可以测试访问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18cc9a76620685996b3f5b1fee2c8a11/" rel="bookmark">
			《移动软件开发》实验六：安卓APP首页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目标 做一个APP首页，包括顶部图片、顶部菜单栏、中部消息模块、底部Tab按钮。
学习 ScrollView、RelativeLayout以及插件之间的穿插使用。
二、实验步骤 1. 逻辑梳理 ​ 做一个app首页，包括顶部图片、顶部菜单栏、中部消息模块、底部Tab按钮。
2. ScrollView layout_width:宽，layout_height:高，ScrollView内部有且仅有一个控件
3. 父布局种类 LinearLayout(线性布局)、RelativeLayout(相对布局)、AbsoluteLayout(绝对布局)、TableLayout(表格布局)、FrameLayout(框架布局)
4. RelativeLayout布局 ​ RelativeLayout，顾名思义，相对布局，也是非常常用的布局，他比LinearLayout更加灵活，可以实现非常复杂的UI。
参数如下：
相对其他控件对齐方式
5. 代码实现 5.1 创建父布局 新建ScrollView，创建ScrollView 内部父布局。 5.2 创建顶部图片 ​ 设置宽高、src加载图片、设置边距。
5.3 菜单栏模块 ​ 首先我们创建一个横向的tLinearLayout来作为菜单栏的父布局；再次创建一个LinearLayout作为单个按钮的父布局；创建上边的图片按钮,并设置其属性；设置按钮底部文字并赋予其属性。
​ 使用四个LinearLayou创建四个菜单图标。
5.4 消息模块 ​ 首先我们创建一个横向的LinearLayout来作为菜单栏的父布局；创建待办Textview；创建更多Textview。
​ 创建消息管理小图标
创建图标下方消息框文字
钥匙管理区域代码如下：
&lt;LinearLayout android:layout_width="match_parent" android:layout_height="25dp" android:background="#dcdcdc"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="25dp" android:layout_marginRight="10dp" android:layout_marginLeft="10dp" android:background="#ffff"&gt; &lt;LinearLayout android:layout_width="80dp" android:layout_height="25dp" android:background="#0000ff"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:text="钥匙管理" android:textColor="#ffff" android:textStyle="bold" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; 图标下方消息框文字代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18cc9a76620685996b3f5b1fee2c8a11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/234d156302abd7ef5c94a1a4d0719ca7/" rel="bookmark">
			游戏设计模式----单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义 单例模式是指在内存中只会创建且仅创建一次对象的设计模式。在程序中多次使用同一个对象且作用相同时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象。
C# 单例模式主要分两种
饿汉式 在类加载时已经创建好该单例对象。
public class Test_Instan { private static Test_Instan instant=new Test_Instan(); public static Test_Instan Instant { get { return instant; } } private Test_Instan() { } } 懒汉式 在真正需要使用对象时才去创建该单例类对象
public class Test_Instan { private static Test_Instan instant; public static Test_Instan Instant { get { if (instant==null) { instant = new Test_Instan(); } return instant; } } private Test_Instan() { } } 不足之处：如果两个线程同时判断instant为空那么它们都会去实例化一个Test_Instan对象，这就变成双例了。
改进:利用锁
public class Test_Instan {	private Test_Instan() { } private static Test_Instan instant; private static object syncRoot = new object(); public static Test_Instan Instant { get { if (instant == null) // 假如线程A和线程B同时看到instant为null { lock (syncRoot)//线程A或者线程B获得该锁进行初始化，另一线程阻塞 { if (instant == null)//其中一个线程进入该分支创建单例对象，另外一个阻塞线程，阻塞结束后进入该分支则会发现instant已被创建 { instant = new Test_Instan(); } } } return instant; } } } 加双锁
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/234d156302abd7ef5c94a1a4d0719ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d15ba20472101601f68adce604c30cfa/" rel="bookmark">
			模仿微信页创建列表布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目标 1、模仿微信“发现”页创建列表布局；
2、学习使用Textview，imageview，LinearLayout。
二、实验步骤 1.逻辑梳理 ​ 页面上包含五组列表，每组包含1-2个列表项，设计方式如下：首先首先设计一个外部总垂直布局,包含所有的列表组，然后写五个LinearLayout来构建这五个列表组，最后进行列表组之间的间隔样式搭建。
2.代码实现 （1）创建父布局，然后对对父布局设置背景色和垂直方向。
（2）构建第一个列表组，设置设置宽高，背景色以及垂直方向。
（3）创建列表组里的第一个图标，设置宽高、背景色、距离左边的距离等。
（4）创建列表组中的汉字，设置汉字宽高、字体颜色、字体样式、字体大小、与左侧的距离等。
（5）创建列表组右边的箭头，设置宽和高，背景，与右边的距离等。
（5）根据第一个列表组创建其他的列表组。
（6）设计间隔样式，在需要间隔的列表中添加android:layout_marginTop属性。
三、程序代码 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:background="#C0C0C0" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;LinearLayout android:background="#fff" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="60dp"&gt; &lt;ImageView android:layout_margin="15dp" android:layout_gravity="center_vertical" android:background="@mipmap/icon_pengyou" android:layout_width="40dp" android:layout_height="40dp"&gt; &lt;/ImageView&gt; &lt;TextView android:layout_marginLeft="10dp" android:textStyle="bold" android:textColor="#333" android:textSize="18dp" android:gravity="center_vertical" android:layout_weight="1" android:text="朋友圈" android:layout_width="0dp" android:layout_height="match_parent"&gt; &lt;/TextView&gt; &lt;ImageView android:layout_marginRight="15dp" android:layout_gravity="center_vertical" android:background="@mipmap/right" android:layout_width="wrap_content" android:layout_height="wrap_content"&gt; &lt;/ImageView&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_marginTop="15dp" android:layout_width="match_parent" android:layout_height="120dp" android:orientation="vertical"&gt; &lt;LinearLayout android:background="#fff" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="60dp"&gt; &lt;ImageView android:layout_margin="15dp" android:layout_gravity="center_vertical" android:background="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d15ba20472101601f68adce604c30cfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d492f878b48b041e109f0da50a7159a/" rel="bookmark">
			进程的状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇我们继续讲解进程相关的内容。
文章目录 1. 进程状态1.1 运行态1.2 终止状态1.3 阻塞态1.4 挂起态 2. Linux下的进程状态2.1 R和S状态2.2 D状态2.3 X和Z状态2.3.1 模拟僵尸进程2.3.2 僵尸进程危害 2.4 孤儿进程2.5 T和t状态 3. 进程优先级3.1 查看系统进程3.2 用top命令更改已存在进程的nice 1. 进程状态 进程的状态也在task_struct里，它其实就是一个整数，用不同整数来代表各个状态。
我们先讲解4个状态：
1.1 运行态 运行态
这个我们上一篇文章说过，tack_struct会现在运行队列中等待，然后CPU会调度某个进程。那么运行态是进程正在CPU上运行，还是进程只要在运行队列中叫做运行态呢？
答案是：只要在运行队列中就叫做运行态，代表我已经准备好了，随时可以调度。
1.2 终止状态 终止状态
终止状态是进程已经被释放，叫做终止状态？还是该进程还在，只不过不运行了，随时等待被释放？
答案是：该进程还在，只不过不运行了，随时等待被释放。
那么为什么进程都终止了，不立刻释放对应的资源，而是要维护一个终止态呢？原因就是：释放是需要花费时间的，但此时你的操作系统很忙，没有时间去释放你的资源，所以会有一个终止态。
1.3 阻塞态 阻塞态
要说阻塞态，我们先补充一些知识点：
我们知道一个进程，使用资源的时候，不仅仅是在申请CPU资源。进程可能申请更多的其它资源，比如：网卡，显卡，磁盘，显示器，声卡等资源。
如果我们申请CPU资源，暂时无法得到满足，是需要排队的(运行队列)，但CPU运行速度很快，我们感受不到。那么我们申请其它慢设备资源也是一样的，也是需要排队的。
在前面我们说过，操作系统进行"管理"是要先描述，再组织。所以像CPU，网卡，磁盘等也会有相应的结构体来描述。
假如现在有一些进程需要CPU调度，假设现在需要从磁盘中读取1G数据，但此时磁盘比较繁忙，该怎么办呢？进程还在CPU中等待吗？肯定不是。
它会把进程放到磁盘队列中等待，然后让CPU去调度其它的进程。
结论：当进程访问某些资源(磁盘，网卡)，该资源如何暂时没有准备好，或者正在给其它进程提供服务。此时，当前进程要从runqueue中移除，然后将进程放入对应设备的描述结构体中的等待队列。
此时进程在等待的时候，该进程的代码，不会被执行了。这就被叫做进程阻塞。而我们用户看到的情况是如果我们平时进程开的比较多的时候，某些进程就会卡住，此时的状态就是进程阻塞。
然后当磁盘已经准备就绪时，进程就会再被放回runqueue中，然后等待CPU的调度，完成磁盘的工作。
阻塞态定义：进程等待某种资源(非CPU)，资源没有就绪的时候，进程需要在该资源的等待队列中进行排队，此时进程的代码并没有运行，进程所处的状态就叫做阻塞。
1.4 挂起态 挂起态
上图是我们的内存和磁盘，然后内存里面有许多进程被管理起来。其实我们知道内存是有大小的，并不是特别大，操作系统也会加载到内存，然后在不断加载其它进程。但此时内存不足了怎么办？我们知道操作系统是管理软硬件资源的，所以操作系统此时就会帮我们辗转腾挪。就是短期内不会被调度的进程，它的PCB虽然在其它设备的等待队列排队中，但它的代码和数据依旧在内存中，所以会白白浪费内存的空间。那么此时操作系统就会把该进程的代码和数据置换到磁盘上。
此时的状态被称为进程挂起。这四个状态我们理解清楚了，剩下的状态我们也能进行组合理解。
2. Linux下的进程状态 我们看一下Linux内核里面是代码：
static const char * const task_state_array[] = { "R (running)", /* 0 */ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d492f878b48b041e109f0da50a7159a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35f9d81e19381d4c61a79a75a4d9ba18/" rel="bookmark">
			关于swagger3 /v3/api-docs文档路径前缀问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在配置nacos实现聚合swagger时由于/v3/api-docs引起的网关路由找不到具体服务器的api-docs文档，导致swagger生成文档失败
运行环境
springfox-boot-starter:3.0.0
spring-boot-starter-parent:2.3.2.RELEASE
spring-cloud-dependencies：Hoxton.SR9
spring-cloud-alibaba-dependencies：2.2.6.RELEASE
1、此处是由于swagger官方的3.0.0版本的bug引起的
导致在application.yaml中补全找不到
解决方法：可以直接在application.yaml配置后，网关路由正常
springfox:
documentation:
open-api:
v3:
path: /${spring.application.name}/v3/api-docs
源码地址（持续更新）：https://github.com/dragonSaberCaptain/wisdom-parent.git
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95e9da5d85d49e8e9c1db32cb63a8b2e/" rel="bookmark">
			AttributeError: ‘Upsample‘ object has no attribute ‘recompute_scale_factor‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 运行python语言实现的深度学习模型【选用pytorch】代码时，代码报错
AttributeError: 'Upsample' object has no attribute 'recompute_scale_factor' 方案 将报错文件“D:\Anaconda3\envs\yolov5-6.0\lib\site-packages\torch\nn\modules\upsampling.py”【具体路径请查看报错信息】大体类似
里边的forward方法修改一下，改成以下
def forward(self, input: Tensor) -&gt; Tensor: return F.interpolate(input, self.size, self.scale_factor, self.mode, self.align_corners) 修改后程序运行正常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/487f3ccb0dd28f86da06b2578bd0add7/" rel="bookmark">
			《移动软件开发》实验五：第一个安卓应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目标 模仿微信“发现”页创建列表布局。学习Textview、imageview、LinearLayout的使用。 二、实验步骤 1. TextView 相关参数如下：
match_parent: 自适应满屏wrap_content: 自适应大小 layout_width: 宽 layout_height: 高 text: 所展现的字 textSize: 字体大小 textColor: 字体颜色textStyle:字体样式 (italic:倾斜,bold:加粗,) gravity: 在控件内部的位置(通用) layout_margin: 与其他控件的距离 (通用) padding: 内部间隔距离 layout_width:宽 layout_height:高 background:背景 src:加载图片,不会拉伸 2. 父布局之LinearLayout ​ 布局特点：放主要提供控件水平或者垂直排列的模型，每个子组件。
​ 相关参数如下：
layout_width:宽 layout_height:高 orientation:垂直方向 (vertical:纵向,horizontal横向) 3. 逻辑梳理 页面上主要包含5组列表，每组列表包含1-2个列表项。具体内容解释如下：
• 列表组1：“朋友圈”单行列表项； • 列表组2：“扫一扫”和“摇一摇”两行列表项； • 列表组3：“看一看”和“搜一搜”两行列表项； • 列表组4：“购物”和“游戏”两行列表项； • 列表组5：“小程序”单行列表项。 4. 代码实现 （1）首先我们创建他们的父布局，对父布局进行设置背景色，设置父布局的垂直方向。
（2）构建第一个列表组，设置宽高，设置背景色，设置垂直方向。
（3）将相关图片复制粘贴至layout下的mipmap文件夹里，创建列表组里的第一个图标，设置宽高，设置背景色，设置与左边的距离，设置居中。
(4)创建列表组中的汉字，设置汉字，设置宽高，设置字体颜色，设置字体样式，设置字体大小，设置与左侧的距离，设置字体居中。
（5）创建列表组右边的箭头，设置宽和高，设置背景，设置水平居中，设置与右边的距离。
（6）用marginTop设置上边距，并建立多个LinearLayout,最终实现效果如下图所示。
三、程序运行结果 最终设计效果如下图所示 四、问题总结与体会 问题总结 问题：右侧箭头无法正确显示大小。
解决方法：将图片直接拖入miptap后图片没有进行压缩，需要将图片复制，粘贴至miptap文件夹，选择xxxhdpi的压缩格式，问题解决。
心得体会 ​ 通过此次实验，我模仿微信“发现”页创建了列表布局。并学习了Textview、imageview、LinearLayout的使用，初步学习了使用AndroidStudio进行开发的过程。。此次实验，对于我《移动软件开发》这门课的学习有非常大的帮助，同时也为我以后计算机专业的学习打下了坚实基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4066a3a013cd0d47825681074964da9c/" rel="bookmark">
			Seata介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。
对业务无侵入：即减少技术架构上的微服务化所带来的分布式事务问题对业务的侵入高性能：减少分布式事务解决方案所带来的性能消耗 官方文档：https://seata.io/zh-cn/index.html
seata的几种术语：
TC（Transaction Coordinator）：事务协调者。管理全局的分支事务的状态，用于全局性事务的提交和回滚。TM（Transaction Manager）：事务管理者。用于开启、提交或回滚事务。RM（Resource Manager）：资源管理器。用于分支事务上的资源管理，向 TC 注册分支事务，上报分支事务的状态，接收 TC 的命令来提交或者回滚分支事务。 AT模式 seata目前支持多种事务模式，分别有AT、TCC、SAGA 和 XA ，文章篇幅有限，今天只讲常用的AT模式。
AT模式的特点就是对业务无入侵式，整体机制分二阶段提交（2PC）
一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。二阶段： 提交异步化，非常快速地完成回滚通过一阶段的回滚日志进行反向补偿。 在 AT 模式下，用户只需关注自己的业务SQL，用户的业务SQL 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。
一个典型的分布式事务过程：
TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID；XID 在微服务调用链路的上下文中传播；RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖；TM 向 TC 发起针对 XID 的全局提交或回滚决议；TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。 搭建Seata TC协调者 seata的协调者其实就是阿里开源的一个服务，我们只需要下载并且启动它。
下载地址：http://seata.io/zh-cn/blog/download.html
陈某下载的版本是1.3.0，各位最好和我版本一致，这样不会出现莫名的BUG。
下载完成后，直接解压即可。但是此时还不能直接运行，还需要做一些配置。
创建TC所需要的表 TC运行需要将事务的信息保存在数据库，因此需要创建一些表，找到seata-1.3.0源码的script\server\db这个目录，将会看到以下SQL文件：
陈某使用的是Mysql数据库，因此直接运行mysql.sql这个文件中的sql语句，创建的三张表如下图：
修改TC的注册中心 找到seata-server-1.3.0\seata\conf这个目录，其中有一个registry.conf文件，其中配置了TC的注册中心和配置中心。
默认的注册中心是file形式，实际使用中肯定不能使用，需要改成Nacos形式，改动的地方如下图：
需要改动的地方如下：
type：改成nacos，表示使用nacos作为注册中心application：服务的名称serverAddr：nacos的地址group：分组namespace：命名空间username：用户名password：密码 最后这份文件都会放在项目源码的根目录下，源码下载方式见文末
修改TC的配置中心 TC的配置中心默认使用的也是file形式，当然要是用nacos作为配置中心了。
直接修改registry.conf文件，需要改动的地方如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4066a3a013cd0d47825681074964da9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b2832829acc4df6d65def437aae8500/" rel="bookmark">
			Linux文件权限修改、用户设置命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文件类型
文件权限
修改文件权限chmod
文字设定法
数字设定法
常用命令
useradd与userdel
chgrp命令
chown命令
用户设置命令
su命令
passwd命令
文件类型 Linux 不以文件的扩展名区别文件类型，而是在文件属性中有一列专门记录文件类型。
最前面总共是10位，第一位表示文件的类型：
‘-’：普通文件‘d’ ：目录文件（即文件夹）‘p’：管道文件‘l’：链接文件设备文件（块设备 ’b’ 、字符设备 ‘c’）‘s’：套接字文件 文件权限 最前面总共是10位，第一位表示文件的类型，剩余9位是文件权限，被划分为3组；
分别代表：
文件属主的访问权限（创建文件的用户），用字母u表示与文件主人同组用户的访问权限，用字母g表示其他用户的访问权限，用字母o表示 注意：如果用字母a表示，a代表的是所有人
访问权限主要有：读取、写入和执行
r：代表文件可以被读取
w：代表文件可以被写入
x：代表文件可以被执行
还可以用数字表示权限：
4：读取
2：写入
1：执行
没有权限就是0
修改文件权限chmod chmod命令：用来修改文件或目录的权限
命令格式：chmod u/g/o/a+或-权限名 文件名
“+” 表示增加权限
“-”表示去掉权限
注意：u/g/o/a 与“+”“-”之间没有空格。
文字设定法 数字设定法 采用数字设定法时，权限通常由三位数字组成，每位数字代表一种角色的权限。每个角色的数值由其所具有的权限对应的数值之和构成。
例如7就代表可读、可写、可执行
格式：chmod 对应的权限（eg:777） 文件名
常用命令 useradd与userdel 功能描述：添加用户、删除用户。
格式：useradd [用户名]
userdel [参数] [用户名]
注意：userdel删除用户时，虽然用户被删掉了，但是被删用户所在的目录以及残留的文件依然保存着
要想彻底删除用户以及用户残留的文件，就需要加上参数**-r**
chgrp命令 作用:用于变更文件或目录的所属组。
命令格式：chgrp 组名 文件名
chown命令 作用:将文件的拥有者改为指定的用户或组.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b2832829acc4df6d65def437aae8500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b9f12e1a09987feaddd10f3692a0e18/" rel="bookmark">
			《移动软件开发》实验一：第一个微信小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年夏季《移动软件开发》实验一：第一个微信小程序 一、实验目标 1、学习使用快速启动模板创建小程序的方法；2、学习不使用模板手动创建小程序的方法。
二、实验步骤 1.自动生成小程序 1.1 项目创建 ​ 双击微信开发者工具图标，使用管理员微信扫码二维码后进入菜单画面，选择菜单中的“小程序”选项进入小程序项目管理页面。依次填写项目名称（开发者自定义的名称，小程序用户用户不可见) 、目录（用于存放小程序项目）、AppID(管理员在微信公众平台上注册的小程序ID)，AppID可通过微信公众平台左侧菜单中的“开发”选项，切换至“开发设置”面板，查看“开发者 ID ”下方的 AppID （小程序 ID )进行查看，我的AppID如下图所示。
后端服务选择不适用云服务，语言选择JavaScript，然后单击创建按钮，进入页面，如下图所示。 2. 手动创建小程序 2.1 项目创建 同步骤1 2.2 页面配置 2.2.1 创建页面文件 项目创建完毕后，在根目录中会生成文件夹pages用于存放页面文件。一般来说首页默认命名为index，表示小程序运行的第一个页面，本项目只需要保留首页（index）即可。 ​ 具体操作如下：
​ (1）将 app.json 文件内 pages 属性中的“ pages / logs / logs ”删除，并删除上一行末尾的
逗号。
(2）按快捷键 Cirl + S 保存当前修改。
2.2.2 删除和修改文件 具体操作如下：
(1) 删除utils文件夹及其内部所有内容。
(2）删除 pages 文件夹下的 logs 目录及其内部所有内容。
(3）删除 index.Wxml 和 index.Wxss 中的全部代码。
(4）删除 index.js 中的全部代码，并且输人关键词“ page ”找到第二个选项按回车键让其自动补全函数。
(5）删除 app.wxss中的全部代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b9f12e1a09987feaddd10f3692a0e18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a67aaa7ccb21b79114fc7c94264840aa/" rel="bookmark">
			《移动软件开发》实验三：视频播放小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年夏季《移动软件开发》实验三：视频播放小程序 一、实验目标 1、掌握视频列表的切换方法；2、掌握视频自动播放方法；3、掌握视频随机颜色弹幕效果。
二、实验步骤 1. 项目创建 ​ 创建选择空白文件夹存放小程序项目：此处我创建的文件夹为lab3_video。
2. 页面配置 2.1 创建页面文件 ​ (1）将 app.json 文件内 pages 属性中的“ pages / logs / logs ”删除，并删除上一行末尾的
逗号。
(2）按快捷键 ctrl + s 保存当前修改。
2.2 删除和修改文件 (1) 删除utils文件夹及其内部所有内容。
(2）删除 pages 文件夹下的 logs 目录及其内部所有内容。
(3）删除 index.wxml 和 index.wxss 中的全部代码。
(4）删除 index.js 中的全部代码，并且输人关键词“ page ”找到第二个选项按回车键让其自动补全函数。
(5）删除 app.wxss中的全部代码。
(6）删除app.js中的全部代码，并且输入关健间app找到第一个选项按回车键让其自动补全函数。
2.3 创建其他文件 创建文件夹images用于存放图片素材。
3. 视图设计 3.1 导航栏设计 ​ 使用windows创建，背景颜色置为金棕色，名称设置为校史。
"window": { "navigationBarBackgroundColor": "#987938", "navigationBarTextStyle": "black", "navigationBarTitleText": "校史 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a67aaa7ccb21b79114fc7c94264840aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/543237d81603685910bb1c3a196d2d26/" rel="bookmark">
			【无标题】Python包管理必备--pip命令&amp;设置镜像源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期周围很多朋友询问，Python如何管理包和模块，并且很多常用的包使用pip安装的时候，总是因为网络问题中断，在学习新包时造成了很大的挫败感，这些问题也是之前自己在学习过程中，遇到的痛点，所以抽出精力，整理了下之前关于这块的学习笔记，形成文章，希望给其他python道友以帮助，也给自己后续查阅带来方便。
Python语言的核心能快速上手并且极具吸引力的是其异常丰富和强大的包，这些包给我们封装好了日常工作中遇到的问题或需求的各种解决方案，所以在python基础知识较为牢固时，遇到具体问题，具体学习对应的包即可。
而学习各种包的第一步，就是将这个包安装到本地或部署到服务器上，本文主要说明在使用pip安装和管理包时遇到的较为常见的问题和解决方案，尤其是镜像安装（因为众所周知的原因，国内访问pipy可能会出现问题等）
特别注意：以下示意代码，均是在电脑终端内完成执行。
一、pip基础讲述
1.1 概述
在电脑上安装完毕python后（不会的自行百度，类似安装常规软件），其会自动安装pip命令，并会包含常用的内置包和模块，对于学习python基础知识而言，再安装个sublime等便可以直接学习了，但如果希望安装其他的包，则需要使用pip命令，以下会详述关于pip命令相关知识。
以下命令，均在终端执行
1.1.1 pip常用命令
一般在学习和使用Python的时候，最常用的是安装或者删除指定的包。
pip常用命令
命令 说明 示意
install 安装包，后面跟需安装的包名，可一次性安装多个包
可安装已下载到本地的包
也可用于升级pip 命令
pip install packagename1 packagename2 pip install pillow-4.2xxxxxxx.whl
pip install --upgrade pip
uninstall 卸载包，后面跟需卸载的包名，可一次性卸载多个包 pip uninstall packagename1 packagename2
list 罗列当前已安装的包，会包含包名和版本号 pip list
1.1.2 获取帮助
如果需要获取帮助，或者想进一步了解一些命令的使用信息，可以使用help获取信息。
命令 说明 示意
pip --help 获取关于pip命令的帮助信息，会罗列pip所有的命令 pip --help
pip help command 获取关于指定pip命令的帮助信息 pip help install
1.2 依赖打包和部署
一般在自己电脑或者本地服务器上完成某个python项目的开发，或者自己希望将平时的python开发环境（主要是包依赖）完全的copy到另一台电脑时，则需要对某项目的依赖包进行打包，然后在新的服务器或者电脑上重新部署，这样就可以实现自己编写的python代码，在新服务器或电脑上可以运行正常。
1.2.1 依赖包打包
第一步，使用freeze命令，将当前电脑上已经安装的包，收集报名和版本号，并导出为txt文件，并可对导出的txt文件进行二次编辑，删除明确不需要的包，不过一般不建议如此，因为实际开发项目时，都是在指定的虚拟环境内完成，该环境只会安装项目依赖的包。
pip freeze &gt; path_name #以下为示例，即将依赖文件导出到当前文件夹内，文件名为requirements.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/543237d81603685910bb1c3a196d2d26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f8bb4e821745c946032c8c7b1698286/" rel="bookmark">
			深入理解Flink滑动窗口机制与延迟数据处理策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Flink窗口概述 流式计算是一种用于处理无界数据流的数据处理引擎，而无界数据流是指一种不断增长的本质上无限的数据集，而窗口是将无界数据流切割成有界数据流的一种手段，Window就是其中的核心。
二、窗口类型 Window主要可以分为TimeWindow（按照时间生成窗口）和CountWindow（按照指定的数据量生成窗口）两种，这里分析的窗口类型主要以TimeWindow为主。
滚动窗口（Tumbling Window）： 滚动窗口依据固定的窗口长度对数据进行切片，将每个元素分配到一个指定大小的窗口中，滚动窗口大小是固定的且窗口中的数据不会出现重叠，适合做每个时间段的聚合统计（滚动窗口是滑动窗口的一种特殊情况）
🌟 代码实现：
WindowedStream&lt;Tuple2&lt;String, Integer&gt;, String, TimeWindow&gt; window = map.keyBy(t -&gt; t.f0).window( // 第一个参数表示窗口长度，第二个参数表示时区的偏移量 TumblingProcessingTimeWindows.of(Time.seconds(3), Time.seconds(1)) ); 滑动窗口（Sliding Window）： 滑动窗口由固定的窗口长度和滑动间隔组成，将数据分配到固定长度的窗口中，窗口的大小可以通过参数来配置，另一个参数控制滑动窗口开始的频率。因此，若滑动参数小于窗口大小时窗口会发生重叠，在这种情况下会存在重复数据。
🌟 代码实现：
WindowedStream&lt;Tuple2&lt;String, Integer&gt;, String, TimeWindow&gt; window = map.keyBy(t -&gt; t.f0).window( // 第一个参数表示窗口长度，第二个参数表示窗口的滑动频率 SlidingProcessingTimeWindows.of(Time.seconds(3), Time.seconds(1)) ); 会话窗口（Session Window）： 会话窗口由一系列事件组合一个指定时间长度的间隙组成，即一段时间没有接收到新数据就会生成新的窗口，此时之前的窗口的数据会进行计算。
🌟 代码实现：
WindowedStream&lt;Tuple2&lt;String, Integer&gt;, String, TimeWindow&gt; window = map.keyBy(t -&gt; t.f0) // 设置一个时间间隔，超过这个时间间隔就会产生一个新的窗口，而旧的窗口会执行计算 .window(ProcessingTimeSessionWindows.withGap(Time.seconds(2))); 三、延迟数据处理策略 时间语义： 窗口的作用是为了周期性获取数据，所以需要将原始数据流切分成多个窗口，由于网络抖动和数据传输的不稳定性，可能会导致数据迟到、乱序等延迟数据的问题，为了解决这个问题Flink引入了时间相关的概念：
① EventTime：事件时间即数据产生的时间，一般存储在数据内容之中（Flink1.12版本之后数据默认的时间语义）
② Ingestion Time：即数据进入Flink的时间
③ Processing Time：即数据处理的当前时间，与机器相关（Flink1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f8bb4e821745c946032c8c7b1698286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1521e3a82303028d9074f662285f3aad/" rel="bookmark">
			Node.js是什么？能做什么？终于有人讲明白了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读：本文我们来认识一下Node.js，了解它能帮助我们完成哪些工作。
作者：史文强
来源：大数据DT（ID：hzdashuju）
在JavaScript语言努力摆脱“玩具语言”这个标签的进化历程中，Node.js绝对能记下浓墨重彩的一笔。Node.js并不是一个用于实现具体功能的第三方工具库，而是JavaScript程序的运行环境。
在Node.js出现之前，使用JavaScript语言编写的脚本需要在网页中被&lt;script&gt;标签引用后才能执行，这就使得前端开发人员编写的程序无论怎么看都像是界面的一种附属品。而Node.js的出现打破了这个枷锁，它提供的运行时能够让JavaScript程序在桌面、命令行终端、手机、平板电脑甚至嵌入式系统上运行，这不仅极大地丰富了JavaScript的应用场景，也为后来的前端工程化发展和中间层架构模型的兴起奠定了基础。
十多年的技术沉淀和演进使得Node.js早已经不再是一项扩展阅读范畴的新兴技术，而是前端开发人员必须掌握的技能，那句“不懂Node的前端是不完整的”也早已不再是一句玩笑话。
Node.js的出现使得前端开发人员可以不必切换语言就能完成客户端和服务端的开发，了解它的人往往对它爱不释手，而不了解它的人则常会把它看作前端工程师自娱自乐的玩具，认为Node.js能做到的事情Java都能做而且更加成熟。那么Node.js到底能做什么，又适合做什么呢？
01 Node.js是什么
Node.js是一个基于Chrome V8引擎的JavaScript运行环境。Node.js使用了一个事件驱动的、非阻塞式I/O的模型，轻量又高效，它的底层是用C/C++编写的。这是Node.js的官方描述，对前端开发人员来说，想要搞清楚其中所包含的“引擎”“运行环境”“事件驱动”以及“非阻塞I/O模型”到底是什么意思，并不是一件容易的事情。
那么Node.js到底是什么？我们先用一个类比的示例来进行解释。比如，有人向你发送了一个扩展名为docx的文档，你想要查看其中的内容，于是打开记事本，把该文档拖到记事本的窗口里，然后就看到了一大堆乱码。这是因为记事本程序并不能识别这种格式的文档，你需要先安装Microsoft Office 2007以上版本的软件，然后用Word程序打开，这样才能看到正确解码的内容。
如果把示例中的docx文件看作程序，那么Word就是它的运行环境，这就像JavaScript程序与浏览器的关系一样。如果你了解过现代浏览器的结构，就会知道其中包含了JavaScript引擎。
以前，想要查看docx文件的内容，几乎只能依赖于Microsoft Office，后来金山公司也推出了办公软件工具WPS Office，它也能够解释和运行docx文件，于是docx文件就有了多个可运行环境，而Node.js对于JavaScript语言的意义也是如此。
为了更加直观地理解运行时的概念，你可以尝试一个有趣的实验，自己创造一种简单的编程语言，规定一些简易的语法，然后使用JavaScript来编写能够解释这些语法的代码。
例如，用自创的语言编写一些简单的程序，最后通过Node.js运行JavaScript程序，并在程序中用Node.js提供的文件读写接口（File API）读入你用自创的编程语言编写的程序，看看它能否被正确地解释和执行。待你了解了JavaScript是如何完成对自创编程语言的解释和执行的，自然就能明白在Node.js运行环境中，C/C++对JavaScript脚本做了什么事情。
当然，真实的代码解释执行过程要复杂得多，很多关键的思想和技术也被应用在前端框架的设计中，这些可以在今后的学习中慢慢消化。
相较于技术上的亮点，Node.js设计者的开发思想或许更值得学习，这一点正是大多数初级开发者所缺少的。Node.js的开发初衷是更方便地实现一个高性能的Web服务器，但当它最终问世时，并没有宣称自己是“实现高性能Web服务器的技术”，而是为开发人员提供了一个工具，这个工具的能力之一是实现高性能的Web服务器。
这种思想差距在初级和高级开发人员之间表现得尤为明显：初级开发人员往往会针对具体的业务需求采用面向过程的风格进行开发，这使得他们编写的程序几乎无法灵活应对任何需求变更；而有经验的开发人员面对需求时，通常会先设计一个类，或者抽象一个与业务逻辑无关的工具方法，然后在自己的程序中调用这个方法。
要想成为优秀的程序设计师，就要不断地培养自己设计程序的能力，而不是仅仅完成语言层面的翻译工作。
02 Node.js能做什么
在Node.js的诸多功能中，与前端开发人员关系最紧密的就是创建Web服务器和本地文件的读写能力。
1. 创建高性能Web服务器
许多Node.js的初学者应该都见过那段只用了不到10行代码就建立了一个Web服务器的经典示例。尽管对于前端开发人员而言，他们依然需要学习基本的Web服务器知识，才能更加得心应手地进行服务端开发，但与配置Apache或Nginx来实现同样的功能相比，这样的学习成本已经非常低了，毕竟前端开发人员可以使用自己最熟悉的JavaScript语言来构建应用。
另一方面，在Node.js中，代码可以与各类数据库进行交互，这就意味着前端工程师可以直接使用JavaScript语言编写与数据库进行交互的代码（尽管在大型应用中并不推荐这样做），且编写业务逻辑代码时，Node.js与其他后端语言没有明显的差别，因此前端开发人员不用切换开发语言就可以掌握全栈开发的技能。
由于Node.js底层使用的是异步非阻塞的I/O机制，因此它更适合于I/O密集、少量业务逻辑和计算消耗的场景。尽管解释型脚本语言本身并不适合执行计算型任务，但Node.js底层是由C/C++代码编写的，并且提供了JavaScript代码层与C/C++代码交互的接口，面对计算密集型任务时，Node.js只需要作为启动脚本调用底层C/C++程序来完成计算密集型任务就可以了。
服务端执行的任务大体可分为读写密集型任务和计算密集型任务。对于读写密集型任务而言，CPU更多的时间是在等待磁盘读写，使用率并不高，在Web服务器上进行的网络通信、信息传输和磁盘读写等都属于读写操作，它对磁盘的响应速度和传输效率有着更高的需求。
相较而言，计算密集型任务对CPU的运算能力要求更高，但对磁盘读写造成的性能负担很小，计算过程中通常也不需要与I/O接口进行交互，可直接、高效地在内存中执行，这类任务的计算过程通常比较复杂，例如需要实现某些加密算法或者矩阵计算等。
大型架构的后端技术选型需要考虑的因素更为复杂，Node.js设计之初并没有准备承担这项任务，就连Node.js之父Ryan Dhal自己也说，在面对大型服务端应用开发时，Node.js的开发体验不如Go语言。
但是，全世界目前有600多种编程语言，没有任何一种语言能够解决所有问题，语言只是承载和传递程序设计思想的媒介，如何为目标场景选择一项合适的技术，或许是开发人员更应该关注的问题。
当你在前端领域有一定的积累时，很多前辈都会推荐你继续学习Java或C++等更为完备也更为复杂的语言，这样做的目的并不仅仅是扩展能力边界，更多的是希望你能够跳出一种编程语言的束缚，学习和体会编程语言背后的思想。
2. 本地文件的读写功能
文件读写功能的底层所要解决的问题其实有很多。如果文件里的内容比较多，读入内存的过程比较耗时，应该怎么处理呢？是等待读入操作完成还是先去执行其他任务？如果客户端请求的资源是一部高清电影，文件比程序可用的总内存还大，那么该文件是否就一定无法读取了呢？
Node.js的fs模块几乎为每个文件操作接口都提供了同步和异步两种方法，同时也支持以流的方式对读写过程实现更细粒度的控制，甚至还可以监测指定文件或文件夹的变动。文件可读写意味着开发人员可以通过程序分析另一个程序中文件的内容，并对其进行检查和纠错，甚至可将其编译成另一种语言，这便是前端工程化的能力基石。
03 招黑的JavaScript全栈工程师
Node.js凭借创建高性能Web服务器以及与数据库通信的能力，为前端开发人员提供了服务端开发的机会。早在几年之前，开发人员就可以使用MEAN（MongoDB + Express + Angular.js + Node.js）这种纯JavaScript技术栈完成闭环的业务逻辑开发，很多前端工程师也因此自诩为全栈工程师。
不可否认当年这样的技术栈确实可以使许多中小型团队以更少的人力和时间就把产品从创意阶段推进到线上，但这也使得JavaScript开发人员成为业内最招黑的全栈工程师，因为业务逻辑的实现并不足以撑起全栈工程师进行后端开发。
在企业级开发中，后端开发仍然以Java工程师为主力军。
由于Java本身具有强类型和完整的面向对象的特性，因此后端工程师的编码质量和程序设计意识整体要高于前端工程师，再加上与Java开发体验非常相似的Angular技术栈的支持（Angular本身就是一项由Google的Java工程师开发和维护的技术），后端工程师很容易就能编写出规范性和可维护性都不输于前端开发人员的代码，这大大提升了Java全栈工程师的竞争力。
如果不是工程化配置和CSS实战经验形成的门槛，前端工程师在面对后端全栈工程师时很难体现其自身价值。然而，前端开发出身的工程师在使用Node.js技术栈进行服务端开发时却没有那么顺利，最流行的Express和Koa框架，仅仅提供了框架和基本中间件，要想实现更多的功能，还需要引入或者自行开发大量中间件。
这时开发人员之间的差别就会表现得非常明显，即使完全不懂Node.js，后端开发人员也很清楚自己应该寻找具备日志记录、错误追踪、会话管理、安全校验、性能监控、对象关系映射（ORM）、数据库连接等功能的模块或中间件，而普通的前端开发人员却除了业务逻辑的增删改查外，往往连使用“try...catch...”语句捕获运行时错误的意识都没有。
前端工程师很容易只考虑业务逻辑一切正常的情况，只要主流程能够正常运行，就觉得万事大吉了，然而在真实的开发过程中，往往是那些没有覆盖到的边界情况需要花费更多的精力。
把后端开发等同于编写业务逻辑代码，就好像把前端开发等同于编写静态页面代码一样。如果真的想成为全栈工程师，需要用一颗谦虚求知的心，踏踏实实地去学习那些陌生的知识，学习的过程可能充满艰辛，但你一定会受益于所学的结果。
关于作者：史文强，前端资深技术专家，现任字节跳动幸福里团队前端工程师、西安交通大学航天学院特聘软件工程师，华为云云享专家，曾受Google GDG（Google开发者社区）邀请进行技术分享。拥有丰富的实战经验，擅长大型前端系统架构设计、性能优化及工程化体系建设。
本文摘编自《前端跨界开发指南：JavaScript工具库原理解析与实战》，经出版方授权发布。（ISBN：978-7-111-70804-9）
延伸阅读《前端跨界开发指南》
点击上图了解及购买
转载请联系微信：DoctorData
推荐语：本书是字节跳动资深前端工程师呕心沥血之作，也是目前市场上少有的从原理到实战深度剖析JavaScript生态中经典工具库的技术图书。
刷刷视频👇
干货直达👇
Roblox、Epic Games和Meta，详解三巨头如何引爆元宇宙
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1521e3a82303028d9074f662285f3aad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddf1b267a9b24e899832aac57d1e8d9e/" rel="bookmark">
			Qpython读取手机短信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境: 手机RedMi Note 9 Pro 系统MIUI12
自带应用商店下载 QPython OP
在设置中要打开Qpython OP 的相关权限, 否则会空指针
QPython OP 使用手册
读取短信代码如下
一个简单示例
from android import Android d = Android() # 获取短信的数量 c = d.smsGetMessageCount(False) # False表示读取所有的短信 True表示读取未读 print("所有短信的数量", c) # 获取短信ID ids = d.smsGetMessageIds(False) print("短信ids",ids) 完整代码
# 使用QPython读取手机短信并保存为csv from androidhelper import Android import csv d = Android() # 读取短信的具体内容， 默认读取收件箱内容 sms_data = d.smsGetMessages(False, "inbox") #print(sms_data.result) iflytek = [] for sms in sms_data.result: # 只保存特定号码的短信 if sms['address'] == '106814830000148': iflytek.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddf1b267a9b24e899832aac57d1e8d9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb3f1f0b17d40aadc14aa9435836a0c1/" rel="bookmark">
			[Java] VSCode Maven项目提示java.lang.NoClassDefFoundError的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言环境现象原因调查Maven依赖项检查Maven本地库jar包检查检查ClassPathJVM文件传参方式检查参数文件的内容打印运行时ClassPath值 原因总结解决方案临时性解决方案根本性解决方案（暂无，仅提供思路） 结语 前言 笔者在个人电脑上使用VSCode开发Java的时间并不多，当时脑子抽抽了用了VSCode加插件的方式刷力扣题。后续在使用Maven管理项目依赖时出现了编译通过但VSCode运行出现java.lang.NoClassDefFoundError的错误。故使用本文来记录该问题的现象、调查过程及其解决方案。
环境 Visual Studio Code: v1.70.2VSCode插件 Language Support for Java™ by Red Hat: v1.10.202281904Maven for Java: v0.37.2022081003 Maven: 3.8.6OS: Win10Java: OpenJDK 11 现象 笔者想用通过Maven依赖的第三方库的JOL（Java Object Layout）来查看Java虚拟机里的对象内存分布。代码如下：
上述代码运行时呢则会出现NoClassDefFoundError错误。
也就是所谓的虽然编译通过了，但是在运行时Class Loader找不到指定类。这就很匪夷所思了，以前在别的IDE Maven项目可从来没出现过这种问题。
原因调查 Maven依赖项检查 pom.xml依赖项，可以看到并没有指定scope，也就是默认的compile级别。可以排除是pom的问题。
Maven本地库jar包检查 既然pom没有问题，那么运行时找不到三方库里的类就是Maven本地库的jar包或者运行时classpath出了问题导致找不到。首先我们检查Maven本地库jar包是否有问题。
我们在maven的本地库里找到了对应jar包可以排除是Maven本地库出了问题。
检查ClassPath 此时笔者只能怀疑是VSCode调用Java传参时出了问题。VSCode的调用命令如下：
PS C:\myEP\GithubRepos\Demonstration&gt; c:; cd 'c:\myEP\GithubRepos\Demonstration'; &amp; 'C:\Program Files\Java\jdk11.0.16_8\bin\java.exe' '@C:\Users\虎猫儿\AppData\Local\Temp\cp_564pls627a8vasz6pulnt3q6z.argfile' 'per.eicho.demo.sdk.Test' 传递给java.exe的参数呢有两个
‘@C:\Users\虎猫儿\AppData\Local\Temp\cp_564pls627a8vasz6pulnt3q6z.argfile’‘per.eicho.demo.sdk.Test’ 后者是我们的Main类，也就是程序入口了。前者呢是一个临时文件路径前面加个@，这是个什么玩意儿呢？
JVM文件传参方式 笔者的环境是OpenJDK11，通过java --help就可以看到@argument这部分是通过文件来传递参数给jvm。
PS C:\WINDOWS\system32&gt; java --help ...省略... @argument 文件 一个或多个包含选项的参数文件 ...省略... jvm的调用者可以通过 ‘@filePath’ 的方式来实现通过文件给jvm传递参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb3f1f0b17d40aadc14aa9435836a0c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/837307f017473114271392383445c05a/" rel="bookmark">
			答辩要点和答辩常见问题及作答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		答辩要点
1、 回答简洁明了。评委老师通常来自各个专业或者是一个学科的不同方向，术业有专攻，隔行如隔山，答辩时与其讲得高大上，让老师一头雾水，不如讲得简洁明了，让老师知道你讲的是什么。尤其是在项目背景、意义和内容的介绍上，这一部分内容较为冗长，最好在讲完后做个短暂的总结。
2、 项目经费有理有据。这一点几乎是评委老师必问的，因为经费申请需要严格的审核，在写预算时要有理有据，不能单纯在PPT里放一张表格让老师自己算，要展示计算过程，比如做某个实验需要什么设备和材料，单次实验要花费多少钱以及预计做多少次实验。对于一些办公耗材如A4纸、打印机、移动硬盘等，写清楚需要的数量以及市场价格（不要买太贵的），让老师放心你不是通过项目混经费的。
3、 项目预期成果合理。在预期成果方面一定要符合本科生的实际科研能力，不能为了申请到更高等级的立项放卫星，设置一些难以完成甚至是离谱的预期成果，比如发几篇顶会。
答辩常见问题及作答
1、 你的项目研究意义是什么？你希望从项目中获得什么？
我们研究这个项目是为了解决xx问题，这个问题在xx领域有xx的意义；我对这个问题和这个方向很感兴趣，希望通过做大创加深了解，方便未来更加深入地研究xx问题，也希望通过大创学习一些新的知识和技能，锻炼自己的科研能力。
2、 目前国内外研究现状如何？谈谈你对项目的认识。
我们调研了大量的文献，这个问题来源于xx，xx年xx学者提出了经典的xx方法，后人在其基础上做出改进，提出了xx方法，目前最新的研究方法是xx，但xx方法有xx的缺点，为了弥补这些缺点，我们计划做这个项目，提出新的解决方案或者改进旧的方法（要回答好这个问题务必做好文献调研工作，对问题研究的发展了然于胸）。
3、项目目前进展如何？预期目标是不是过高？
我们目前已经完成了基础知识的学习，并且做了一些实验，这几天正在做xx（和答辩内容要对应），预期目标是我们团队和指导老师商量后共同提出的，目标太低不能充分激励我们，目标太高会挫伤积极性，这个目标很适合我们。而且团队成员分别来自xx专业和xx专业，大家优势互补，我们有信心完成预期目标。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cfe1c33833e2d593217eb106275c045/" rel="bookmark">
			Android Studio实践——实验2安卓APP首页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目准备 一个App首页主要包括顶部图片，顶部菜单栏，中部消息模块，底部Tab按钮
在本次实验中主要掌握ScrollView 使用，RelativeLayout 使用，插件之间的穿插使用
ScrollView：除具有宽和高外，其内部有且仅有一个控件
RelativeLayout：相对布局
二、功能实现 1. 创建父布局 整个页面各个控件之间应该使用垂直布局
创建一个ScrollView,指定其宽高和权重
ScrollView内部也应该使用垂直布局
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:orientation="vertical" android:layout_height="match_parent"&gt; &lt;ScrollView android:layout_width="match_parent" android:layout_weight="1" android:layout_height="match_parent"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt; &lt;/LinearLayout&gt; 2.创建顶部首页显示栏 &lt;TextView android:text="首页" android:textSize="18dp" android:textColor="#333" android:textStyle="bold" android:gravity="center" android:layout_width="match_parent" android:layout_height="50dp"/&gt; 3.创建顶部图片 &lt;ImageView android:layout_marginRight="10dp" android:layout_marginLeft="10dp" android:src="@drawable/page" android:layout_width="match_parent" android:layout_height="200dp"/&gt; 图片原因，实际整张图距两边框只有10px
4.菜单栏模块 a. 先创建一个横向的LinearLayout来作为菜单栏的父布局
b. 再次创建一个LinearLayout作为单个按钮的父布局
c. 创建上边的图片按钮,并设置其属性
d. 设置按钮底部文字并赋予其属性
&lt;LinearLayout android:layout_marginRight="10dp" android:layout_marginLeft="10dp" android:weightSum="4" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;LinearLayout android:orientation="vertical" android:layout_weight="1" android:layout_width="0dp" android:layout_height="100dp"&gt; &lt;ImageView android:layout_marginTop="10dp" android:layout_gravity="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cfe1c33833e2d593217eb106275c045/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/784b99717a30f7befd0888b8442e1515/" rel="bookmark">
			【JVM-java虚拟机】简单知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介 1.1 对java的了解 在JDK的安装目录下有一个JRE目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是JVM，lib中则是JVM工作所需要的类库，而jvm和 lib合起来就称为jre。
JDK(Java Development Kit) ：是 Java 语言的软件开发工具包（SDK）
JRE(Java Runtime Environment)：Java运行环境
JVM（Java Virtual Machine）：简单来说，作用是用于编译java代码成二进制，变成电脑系统能够识别的文件
是一个虚构出来的计算机，是通过在实际的计算机上来仿真模拟各种计算机功能来实现的。JVM是整个java实现跨平台的最核心的部分，能够运行以Java语言写的程序。跨平台：编译java代码生成中间字节码，然后通过Java的开发团队针对不同的平台开发出了对应版本的java虚拟机解析执行。就能够实现各种平台上运行。（不同系统，比如win跨linux），但c不行，c有特定的cpu识别，所以没办法都兼容 JDK–&gt;JRE–&gt;JVM
1.2 java文件编译的过程 程序员编写的.java文件由javac编译成字节码文件.class：（为什么编译成class文件，因为JVM只认识.class文件）在由JVM编译成电脑认识的文件 （对于电脑系统来说 文件代表一切） 1.3 为什么要学 假如：内存出现问题了，出现了内存溢出 ，内存泄漏问题怎么办–&gt;研究java内部运行机制
1.4 JVM体系结构图 1.4.1 本地方法栈（Native） 线程私有。本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 1.4.2 方法区（Method Area） 与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息（构造方法、接口定义）、常量、静态变量、即时编译器编译后的代码（字节码）等数据。方法区是JVM规范中定义的一个概念，具体放在哪里，不同的实现可以放在不同的地方。 运行时常量池
运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 1.4.3 程序计数器 线程私有。一块较小的内存空间，可以看作当前线程字节码的指示器。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空。是个非常小的内存空间。几乎可以忽略不记 1.4.4 Java虚拟机栈 Java方法执行的内存模型：每个方法执行都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表：存放的是有些局部变量值的内存空间。在方法中定义的局部变量操作数栈：就是一个先入后出的栈动态链接：动态的获取class文件里面的变量和引用方法出口：方法的返回方式 1.4.5 Java堆 线程共享。对大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 1.5 常量池 class常量池 中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询 字符串常量池 ，以保证 运行时常量池所引用的字符串与字符串常量池中所引用的是一致的。
1.5.1 Class常量池-方法区中 常量池（Constant Pool），也叫 class 常量池（Class Constant Pool）
用于存放编译器生成的各种字面量（ Literal ）和 符号引用（Symbolic References）
1.5.2 字符串常量池-堆中（String Pool） 也叫全局常量池，String Pool 中存的是引用值，而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。字符串常量池在每个VM中只有一份。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/784b99717a30f7befd0888b8442e1515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2a9724a2f4da57770c1a9c6d7ad7b80/" rel="bookmark">
			程序员面试书籍 4本 共264M （部分文字版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址
链接：百度网盘 请输入提取码
提取码：gcej
《程序员面试宝典 欧立奇 第五版》
《程序员面试宝典 第6版 英文》
《程序员面试金典》（第6版）
《剑指offer》 名企面试官精讲典型编程题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55e12ab50b4dfaeb8379a079355ac2d1/" rel="bookmark">
			戴尔G15-5520蓝屏解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于戴尔网卡的原因，会导致蓝屏，更新驱动无用，进入BIOS解决
问题如下可用：
蓝屏代码 DRIVER_VERIFIER_DMA VIOLATION 解决方案：
机器关机 开机连续按F2 选择倒数第三个选项 把Enable Pre-Boot DMA Support 改为OFF 把Enable OS Kernel DMA Support 改为OFF 最后点击APPL保存即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c06694bd8ccdf505eceea094e24e8508/" rel="bookmark">
			TIOBE 8 月编程语言排行榜：没有一门语言能比得上 Python！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读：最新一期的编程语言榜单重磅发布！
本文经授权转自公众号CSDN（ID：CSDNnews）
整理：苏宓
01 达到历史新高度的 Python 在众多编程语言中，似乎已经没有什么能够阻挡 Python 的步伐。据 8 月最新 TIOBE 榜单显示，脚本语言 Python 相比上个月增加了 2%，市场份额达到 15.42，创下了历史新高。
对此，TIOBE 软件公司 CEO Paul Jansen 评价道：
现在很难找到一个没有广泛使用 Python 的编程领域。可能唯一存在的例外是（安全性至关重要）的嵌入系统，由于 Python 是动态类型的，速度太慢了，不太适合嵌入式领域。当然，这也是为什么性能优异的 C、C++ 目前越来越受欢迎的主要原因。
除此之外，在 Top 10 榜单中，PHP 上升一位，进入 Top 10。苹果的 Swift 语言下降了一个名次，占比 1.27%，排名第 11 位。同时，还有一些值得关注的其他变化：
Go 语言从上月的第 12 位跌落到本月的 15 位，下降 3 个名次。其名次与市场份额有所跌落，也有不少人猜测是与 Google 推出的新语言 Carbon 有关，当前，此语言排在第 192 位；
Ruby 市场份额有所下降，目前排名第 18 位；
作为一门安全性极高的编程语言，Rust 近年来受到了各大公司的欢迎，如微软、Google、亚马逊等，它可以更安全地处理内存管理和其他对安全性有着极高要求的任务。在此广泛应用的趋势下，Rust 在 TIOBE 榜单也接近 Top 20，当前排在第 22 位；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c06694bd8ccdf505eceea094e24e8508/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3946415ee06f1e83db874b1b36d8f3f2/" rel="bookmark">
			单例设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：什么是单例设计模式 单例例模式便是创建型设计模式的一种，它确保某一个类在系统中只有一个实例，并自行实例化，同时向外部提供获取这个唯一实例的接口。 单例设计模式主要有以下三个特点：
1、只能有一个实例。 2、必须自己创建自己的唯一实例。 3、必须给所有其他对象提供这一实例。
二：单例设计模式种类 饿汉设计模式：类加载就会导致改单例实例对象被创建 饿汉设计模式分为两种：
1.静态成员变量的方式
2.静态代码块方式
懒汉设计模式：类加载不会创建对象，首次使用才会创建对象 懒汉设计模式分为六种：
1.懒汉设计模式 （线程不安全）
2.懒汉设计模式 （线程安全，效率低）
3.懒汉设计模式 （双重检查锁模式）volatile 关键字
4.懒汉设计模式（静态内部类模式）
5.懒汉设计模式（序列化破坏单例）readResolve()方法
6.懒汉设计模式（反射破坏单例）
7.懒汉设计模式（枚举）
三：饿汉设计模式 1.静态成员变量的方式：
/** * 饿汉设计模式 （静态成员变量的方式） */ public class ThehungryDemo { //私有构造方法，外界不能创建对象 private ThehungryDemo() { } // 静态变量进行创建声明 private static ThehungryDemo thehungryDemo=new ThehungryDemo(); //通过公共方法进行创建返回， public static ThehungryDemo getInstance(){ return thehungryDemo; } } 2.静态代码块方式：
/** * 饿汉设计模式 （静态代码块方式） */ public class ThehungryDemo2 { //私有构造方法，外界不能创建对象 private ThehungryDemo2(){ } // 静态变量进行创建声明 private static ThehungryDemo2 thehungryDemo; static { thehungryDemo=new ThehungryDemo2(); } //通过公共方法进行创建返回， public static ThehungryDemo2 getInstance(){ return thehungryDemo; } } 饿汉设计模式总结： 缺点： 以空间换时间，在实例化时就创建，灵活性不高，空间使用率不高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3946415ee06f1e83db874b1b36d8f3f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c02c636b1079d2667c5c0d1bc7c7fb06/" rel="bookmark">
			【onnx转tensorrt报错】IShuffleLayer applied to shape tensor must have 0 or 1 reshape dimensions: dimensi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
完整报错：
前言：
原因：
完整报错： IShuffleLayer applied to shape tensor must have 0 or 1 reshape dimensions: dimensions were [-1,2])
前言： 在做 pytorch框架 下面的 分类模型 转换的时候遇到的问题。
torch模型转tensorrt有两种方法：
一个是直接转成tensorrt；一个是先转成onnx，再将onnx转换成tensorrt。
我使用的是通过onnx转换的间接转换办法。
但是再onnx转tensorrt的时候遇到了这个bug。
解决步骤：
1.pth --&gt; onnx (mmclassification tools里面的pytorch2onnx.py)
2.onnx --&gt; engine (mmdeploy 里面的 onnx2tensorrt.py)
注：
1.这里不使用mmdeploy直接转换的原因就是他可能会报这个错误！
2.我使用的分类模型是mmclassification里面的，但不是从mmclassification里面训练的（他封装的太好了，，导致我很多操作很难去更改），只是借助了里面的模型转换 API 进行模型转换而已。
原因： 在网上搜了好长时间都没有结果~~于是决定写一篇来记录一下！
错误的原因是因为：
pth转onnx的时候没有进行 simplify 操作。
注：这个参数是在 mmclassification 里面的。
再pth转onnx的时候把这个参数加上去。他就不报这个错误了！（这个解决方法我是试出来的，，暂时没有理论依据。。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f8868e310d45d9f807cf7262ef5828/" rel="bookmark">
			python import自己写的本地模块报错No module named 获取当前(的上(上)级)目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件结构如下：
根路径 &gt;&gt;&gt;t4.py &gt;&gt;&gt;m3 &gt;&gt;&gt;t3.py &gt;&gt;&gt;m1 &gt;&gt;&gt;t1.py &gt;&gt;&gt;m2 &gt;&gt;&gt;t2.py 代码如下：
//t4.py import os,sys from m1 import t1 from m1.m2 import t2 from m3 import t3 print('t4',os.path.abspath(os.path.join(os.getcwd()))) //m3\t3.py import os,sys # sys.path.append('..') sys.path.append(os.path.abspath(os.path.join(os.getcwd()))) from m1 import t1 from m1.m2 import t2 print('t3',os.path.abspath(os.path.join(os.getcwd()))) //m1\t1.py import os,sys # sys.path.append('..') sys.path.append(os.path.abspath(os.path.join(os.getcwd()))) from m1.m2 import t2 from m3 import t3 print('t1',os.path.abspath(os.path.join(os.getcwd()))) //m1\m2\t2.py from django.test import TestCase import os,sys # sys.path.append('..') sys.path.append(os.path.abspath(os.path.join(os.getcwd()))) from m1 import t1 from m3 import t3 print('t2',os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5f8868e310d45d9f807cf7262ef5828/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4525d01b64b050fab2008694aad5b82d/" rel="bookmark">
			关于selenium3.14与4.0以上版本查找元素的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、先准备好浏览器的驱动器。
然后输入以下代码:（我用的是谷歌浏览器的驱动器）
#引入浏览器的驱动 from selenium import webdriver #生成浏览器，或打开浏览器 driver=webdriver.Chrome() 二、准备与代码相关的环境：
1.安装selenium
win + R → 输入cmd → pip install selenium 默认下载最新版本的selenium 三、selenium 3.14
查看元素的指令：
例如通过，id和类名查找：
driver.find_element_by_id('id名')
driver.find_element_by_class_name('类名')
四、selenium 4.0以上的版本：
先导入这个By这个包
from selenium.webdriver.common.by import By 查看元素的指令：
例如，通过id查找。
driver.find_element(By.ID，'id名')
注意 By. 后面都是大写的！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf7ff5e8aaa9d94e771b75a63b12b3b/" rel="bookmark">
			华为 huawei img 解密vendor.img userdata.img system.img解包 提取APP 文件 加密镜像文件提取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为 huawei img 解密vendor.img userdata.img system.img解包 提前APP 文件 加密镜像文件提取
通常华为的卡刷包镜像可以作为线刷包来刷机比如 update.app 666666
可以先用工具提取解包，解压出相关的img镜像文件
如图这样 ，解压出个个镜像 ，这是又update.app 大包后 解压出来的。
怎么解压 update.app提取img 镜像，这个方法相信你百度 一下 很多方法
这里提供一个工具 文件自行百度下载
（所有版本&lt;=v0.9.9.3都需要.Net Framework 3.5）
最新版本使用.Net Framework 4.6.1
安装
将zip文件的内容解压缩到系统中的某个文件夹中。
执行HuaweiUpdateExtractor.exe
我计划什么时候创建一个安装程序。
用法
按浏览（…）按钮并选择更新。应用程序文件。选择一个设备或未知设备，然后按“打开”按钮。
您将看到更新的内容。listview中的应用程序文件。
选择一个或多个文件并单击鼠标右键。从关联菜单中选择“提取选定项”。
选择输出文件夹，然后按ok。
或者右键单击列表并选择“全部提取”，再次选择输出文件夹，然后按“确定”。
按“提取”窗口上的“关闭”。
您可以按顺序、文件名和大小对列表进行排序。只需按下所需的列标题。
命令行：
HuaweiUpdateExtractor提取输入输出[配置文件]
HuaweiUpdateExtractor重新打包输入输出配置文件
轮廓
配置文件。xml文件用于标识更新中的文件。应用程序文件。更新中的每个文件。应用程序有一个序列或类型，它也是
如列表中所示。这些序列或类型用于标识文件/设备分区。
至此 你已经提取了相关的 img镜像，但是遗憾的是 华为的img镜像是加密的，您无法自助通过途径来解包img镜像文件，但是我们已经攻克了此技术问题，可以自由提取相关img镜像内的文件，
对于无法root 和解锁Bl的机器。但是开发的时候 又需要 相关镜像内的文件，是一个很好的解决办法
以上内容又 公众号：数字云信息技术 提供
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef8088a51bce0a6b1330d6b96ca3f03/" rel="bookmark">
			基于Quartus II 的PLL IP核模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建PLL IP核
Tools — MegaWizard Plug-In Manager — 于如下页面进行相关设置
ps： 若进行仿真，需添加altera_mf模块
二、顶层模块编写
module pll_ip( input sys_clk, input sys_rst, output clk_100m, output clk_100m_180d, output clk_50m, output clk_25m ); wire locked_sig; wire rst_n; assign rst_n = sys_rst &amp; locked_sig; // reset signal for other modules // pll_clk with high reset pll_clk	pll_clk_inst ( .areset (~ sys_rst ), .inclk0 ( sys_clk ), .c0 ( clk_100m ), .c1 ( clk_100m_180d ), .c2 ( clk_50m ), .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bef8088a51bce0a6b1330d6b96ca3f03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b977370ba1e7acf7e03eb83f57a88032/" rel="bookmark">
			pthon 字符串比较法则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在写代码时发现了字符串比较的问题，python在字符串比较中暗藏玄机。
c语言中字符串比较会看ascii码的大小。
python中比较如下：
strs = ['fly','flypod','sbc','abcd'] print(max(strs)) # input: sbc print(min(strs)) # input: abcd 这就奇了怪了，是什么原因呢？
原来python中的string比较的不是字符串长度大小，而是比较使用的字典序，而不是单纯的长度比较。和c语言中的ASCII比较相似。
因为：'s' &gt; 'f' &gt; 'a' 第一个字符比较完大小就不比较后续字符了，所以'abcd'最小，'sbc'最大。
如果是 'fly' &amp; 'flypod' 谁先结束谁最小，故前者小于后者。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ea7e8d35b5622c4843b6c4620c5522b/" rel="bookmark">
			HC_SR04超声传感器——通用定时器TIM4_CH1单通道输入捕获_寄存器开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超声波 （HC_SR04）检测模块 现在基本没有BUG
效果RUN
模块分析
引脚：
VCC-5V
GND-接地
Trig:接收来自单片机 发出的 激活脉冲（超过10us的高电平）
Echo:发送脉冲给单片机处理。
原理
单片机 通过GPIO口 给Trig发送一个超过10us的高电平激活SR04开始工作发出超声波
传感器 发送一个超声波 此时传感器的Echo变为高电平 ，当接收到物体返回给超声波的时候，转为低电平，只要测出高电平的时间t 即可算出距离。
距离公式：V(声速)*t/2.0=l
时间公式：time_Sammary=ARR(计数器的计数周期)*count(计数器有轮巡次数)—time_Data1（上升沿的时间）+time_Data2（下降沿的时间）;
程序分析
1通过TIM7的定时中断给 每100ms给传感器发送1个15us的高电平
/要输出高电平的GPIO初始化/
/TIM7基本定时器初始化/
ARR，PSC输入的值要减去1，因为ARR是从0开始算的
/NVIC中断控制器配置/
/中断服务函数/
2通用定时器TIM4_CH1单通道输入捕获初始化
/接收传感器发送数据的IO口的初始化/
/TIM4_CH1通用定时器的初始化/
// 使能，中断记得放下面 ，
/NVIC中断控制器的初始化/
/更新中断/
//计数器轮询累加
/捕获中断/
//检测到上升沿触发
//检测到下降沿触发
遇到错误 1.超声波 的Trig 的激活函数
TIM6(定时中断 无法进入 ------没写NVIC控制器函数
一个定时器 即做延时又做定时中断-----NO
3 ) 输出数据是浮点型 ，但是并未定义 浮点型变量，导致测距 不准确
4 ） —捕获中断 无法进入)---------没有捕获中断使能
**
代码： **
1基本定时器的定时中断
2 通用定时器 输入捕获
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ea7e8d35b5622c4843b6c4620c5522b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91fbe4dc0912b8f23620a4f407642e70/" rel="bookmark">
			linux安装rocketMq,测试消息发送和接收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装jdk1.8
2.配置jdk环境：
让配置生效：
source /etc/profile
3.检测java环境是否配置成功 java -version 或 javac ,如果出现权限问题，修改权限：chmod +x /usr/java/jdk1.8.0_161/bin/javac
4.上传rocketmq压缩包
5.因为rocketmq初始化配置占用内存比较大，需要在解压后的bin目录下面，修改runbroker.sh 、runserver.sh 两个文件内存大小：
vim runserver.sh
JAVA_OPT="${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn512m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"
vim runbroker.sh
-server -Xms128m -Xmx128m -Xmn128m
在brocket.conf配置文件中加入本机ip地址
nameserver启动命令：
nohup sh bin/mqnamesrv 1&gt;/dev/null 2&gt;&amp;1 &amp;
broker启动命令：
nohup sh bin/mqbroker -n localhost:9876 1&gt;/dev/null 2&gt;&amp;1 &amp;
broker停止命令：
./bin/mqshutdown broker
nameserver停止命令：
./bin/mqshutdown namesrv
6.在bin目录下执行：
生产者发送消息：
export NAMESRV_ADDR=127.0.0.1:9876
sh tools.sh org.apache.rocketmq.example.quickstart.Producer
消费者接受消息：
sh tools.sh org.apache.rocketmq.example.quickstart.Consumer
7.rocketmq-console控制台下载地址：
Releases · apache/rocketmq-externals · GitHub
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91fbe4dc0912b8f23620a4f407642e70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48a89df7d945ce1f4785483b45745cc0/" rel="bookmark">
			【Java】双重检查锁模式的单例模式（DCL懒汉式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先给出代码：
class Cat { private String name; //volatile 能够防止指令重排造成的问题 private volatile static Cat cat; //声明唯一实例 private Cat(String name) { this.name = name; } public static Cat getInstance() { if (cat == null) { //保证加锁之前只有一个对象 synchronized (Cat.class) { //获取锁 if (cat == null) { cat = new Cat("DCL懒汉猫"); } } } return cat; } } 单例模式的特点： 单例类只能有一个实例对象；单例类必须自己创建这个实例；单例类必须提供获取之一实例的方法：getInstance()。 两次判断对象是否为 null 的目的分别是什么？ 最外层的 if 判断很好理解嘛，如果对象已经不为空了，已经创建过了，那您就甭费劲抢锁了，直接拿着实例返回吧。
那为什么在抢到锁之后还要再加一层判断呢？大家来考虑这样一种情况：
两个线程 A 和 B 来获取对象，此时对象还没被创建，A 和 B 都通过了第一层判断，两个线程开始竞争锁，A 抢到了锁，因此 B 进入同步队列阻塞等待。**当 A 创建完对象并且释放了锁，B 拿到了锁，又去执行 new Cat(“DCL懒汉猫”)，此时就创建了两个对象。**因此，必须在加锁之后再来一次判断，才能保证只创建一次对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48a89df7d945ce1f4785483b45745cc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93afdad03f55ea5f0b614813e6d17352/" rel="bookmark">
			volatile关键字的作用及底层原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		volatile是什么？有什么作用？ volatile 是 java 虚拟机提供的轻量级同步机制，主要有两个特性：
保证可见性，也就是被 volatile 修饰的变量如果被一个线程修改，那么其他线程能够及时看到这个修改；禁止指令重排。 volatile 是如何保证可见性的？ 想要了解保证可见性的底层原理，首先我们需要对 CPU 读取内存的机制有所了解。
CPU 在处理数据时，线程首先把数据从内存读取到自己的缓存，再从缓存读到寄存器进行计算。如果我们的变量没有被 volatile 修饰，那么对变量的更改只会先被保存到缓存，再根据操作系统的策略定期推送回内存。这就导致有时候别的线程不能及时看到变量的修改，因为每个线程都有自己的缓存，不同缓存中同一个数据可能会不一致。
此时 volatile 来了，如果一个变量被volatile 修饰，那么在编译阶段，JVM 会在变量被修改的语句前面加一条 lock 语句，这个 lock 语句主要有两个作用：
把对该变量的更改推送到内存；其他 CPU 可以嗅探到该指令，并把自己缓存中的该变量置为不可用，下次使用时需要从内存中读取。
Easy，线程间的可见性解决。 volatile 是如何禁止指令重排的？ 先简单概括一下：为了实现 volatile 的内存语义，编译器在生成字节码时，通过在指令序列中插入内存屏障来禁止特定类型的处理器重排序。
具体操作如下：
在每个 volatile 写操作前面插入一个 StoreStore 屏障；在每个 volatile 写操作后面插入一个 StoreLoad 屏障；在每个 volatile 读操作后面插入一个 LoadLoad 屏障；在每个 volatile 读操作后面插入一个 LoadStore 屏障； 面试能答出这些感觉应该够了。
关于JMM的一些同步约定： 线程解锁前，必须把共享变量立刻刷回主存。线程加锁前，必须读取主存中的最新值到工作内存（高速缓存）中。加锁和解锁必须是同一把锁。 private static int num = 0; public static void main(String[] args) { new Thread(()-&gt;{ while (num == 0) {} }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93afdad03f55ea5f0b614813e6d17352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e63c74c97aba0f1dcf884bf78b3329bf/" rel="bookmark">
			pytorch tranpose与permute函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		transpose和permute都是转置函数，可以交换Tensor的维度。
1. transpose torch.transpose(input, dim0, dim1, out=None) → \rightarrow →Tensor
transpose函数用于交换input的维度dim0和dim1，只能交换两个维度，且dim0和dim1的参数位置没有顺序而言。
例子：
a = torch.arange(6).reshape((2, 3)) a, a.transpose(1, 0) # shape从(2, 3)变成(3, 2) Out:tensor([[0, 1, 2], [3, 4, 5]]) tensor([[0, 3], [1, 4], [2, 5]]) a.transpose(1, 0)与a.transpose(0, 1)相同，都是将第0个维度和第1个维度交换。
a.transpose(1, 0) == a.transpose(0, 1) Out: tensor([[True, True], [True, True], [True, True]]) 作用于高维：
b = torch.arange(24).reshape((2, 3, 4)) b.transpose(1, 2)	# shape从(2, 3, 4)变成(2, 4, 3) b.transpose(0, 1, 2)	# 报错，只能输入两个维度进行交换 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e63c74c97aba0f1dcf884bf78b3329bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e882bd3beae92991fe3ccbc1f06fc486/" rel="bookmark">
			【Android 屏幕适配】屏幕适配通用解决方案 ⑥ ( 约束布局 ConstraintLayout 百分比布局方案 | 将设计稿尺寸自动转为约束布局百分比标签属性 | 将输出结果设置到组件标签中 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、将设计稿尺寸自动转为约束布局百分比标签属性二、将输出结果设置到组件标签中 参考文档 :
设备兼容性概览屏幕兼容性概览支持不同的像素密度声明受限屏幕支持 约束布局 bias 计算公式参考 【约束布局】ConstraintLayout 偏移 ( Bias ) 计算方式详解 ( 缝隙比例 | 计算公式 | 图解 | 测量图 + 公式 ) 方案 ;
约束布局 百分比 屏幕适配案例参考 【约束布局】ConstraintLayout 屏幕适配案例 ( 使用代码生成约束布局控件属性 ) 博客 ;
一、将设计稿尺寸自动转为约束布局百分比标签属性 美工给出的设计稿尺寸 720 × 1280 720 \times 1280 720×1280 像素 ;
在 caculate_constraint 方法中 , width 和 height 的高度就是设计稿的 宽度 720 和 高度 1280 ;
// 相对于父类 比例计算 的原始数据 : 屏幕 宽高 , 其比例肯定是相对于父控件进行计算 float width = 1280, height = 720; width_inner 和 height_inner 是用于计算组件在约束布局中的位置的 , 一般情况下这两个值就是布局的宽高 , 也就是 宽度 720 和 高度 1280 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e882bd3beae92991fe3ccbc1f06fc486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a6f5428463724d8beed1dd367682ae9/" rel="bookmark">
			C&#43;&#43;、基于Qt和Qwt实现交互式曲线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在很多调试场景下，我们需要配置一条参数曲线给某些模块使用。比如在各种图像处理软件中，我们都可以看到一个 Gamma 曲线调整的功能，里面的曲线可以通过鼠标随意地拖动，十分的方便。如果你有接触过硬件调试，那么就会知道配置曲线基本是通过预设几个数据点，然后通过线性插值获取的，每次想更改曲线的形状就得把数据点一个一个地通过键盘修改，可以说低效至极，因此得想办法实现以上的效果。
对于曲线作图，很多语言基本都有相关的函数工具库，比如 Python 里面就有 matplotlib.pypplot，可以完成各种复杂的数据显示效果。然而，这种作图一般是静态的，也就是只能显示由已知数据点所连成的曲线，而不能自由地增减数据点，以及拖动已有的数据点，同时相应地改变曲线形状。很显然，要实现这种效果，我们必须要和鼠标事件进行交互，同时也离不开窗体应用的开发。在这方面，Qt 是具有比较明显的优势的，一方面其本身绝大部分功能都是开源的，而且大多数属于 LGPL 协议，这就意味这只要我们通过动态链接的方式使用这些 Qt 库，就可以实现代码的闭源，这对于商业用途是十分友好的；另外，Qt 是基于 C++ 的，只要你对 C++ 面向对象的概念有基本的理解，那么你只需要知道 Qt 里面有哪些工具，工具里面有哪些方法，就可以十分流畅地使用。同时，Qt 也有一些现成的曲线作图工具，比如 QChart 和 Qwt。其中 QChart 功能比较丰富，在安装 Qt 时一般都有直接安装 QChart 的选项，但问题在于 QChart 是 GPL 协议的，其缺点就是沾上了 GPL 协议的代码也得按 GPL 开源。而 Qwt 则是 LGPL 协议的，虽然功能上要比 QChart 有所逊色，但实现本文的效果已经是绰绰有余了，因此这里选择的是 Qt + Qwt 的方案。Qt 和 Qwt 可选择以下的下载链接。编译安装流程相对比较简单，但是要先安装一个 VS2019，可以选择社区版，主要是提供一个编译环境，实际开发的时候还是在 Qt Creator 内的。貌似 VS2019 以下版本容易编译不过。Qwt 编译成功后会在 plugins 下生成相应的 Qt Designer 插件 qwt_designer_plugin.dll，把它复制到 Qt 安装目录相应的位置，比如我的是 F:\Qt\5.15.2\msvc2019_64\plugins\designer，那么在 Qt Creator 项目的 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a6f5428463724d8beed1dd367682ae9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef97f09254ebdf2c1ebc9199161b349/" rel="bookmark">
			c#Web Api入门案例一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、成果展示
二、项目创建
看图
MVC架构的话，它会有view-model-control三层，在web api中它的前端和后端是分离的，所以只在项目中存在model-control两层。
1、我们在model文件夹中添加一个类
在movie类中添加代码
using System; using System.Collections.Generic; using System.Linq; using System.Web; namespace test_api_1.Controllers { public class movie { public string name { get; set; } public string director { get; set; } public string actor { get; set; } public string type { get; set; } public int price { get; set; } } } ```csharp model层中的代码，个人习惯理解为你是将要展示的数据去拟定一个大纲，然后在大纲中操作```
2、在control层中添加控制器，命名为testControls
using System; using System.Collections.Generic; using System.Linq; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cef97f09254ebdf2c1ebc9199161b349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c44901c58ac46e4b1bb89032534c1f1/" rel="bookmark">
			OpenGL ES 3.0管线渲染流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenGL ES 3.0 实现了具有可编程着色功能的图形管线，由两个规范组成：
OpenGL ES 3.0 API规范OpenGL ES 着色语言3.0规范 下图概述了OpenGL ES 3.0 图像管线的各个阶段：
1、顶点缓冲区/数组对象 顶点缓冲区在应用程序中是可选的，对于某些在整个场景中顶点数据基本不变的情况，可以在初始化阶段将顶点数据经基本处理后送入顶点缓冲区，在绘制每一帧想要的图像时就省去了顶点数据IO的步骤，直接从顶点缓冲区中获取顶点数据即可。
例子：画三角形，在Java层构建缓冲区。
// 开辟本地内存，目的将数据从Dalvik传进OpenGL var triangleCoords = floatArrayOf( // in counterclockwise order: 0.0f, 0.622008459f, 0.0f, // top -0.5f, -0.311004243f, 0.0f, // bottom left 0.5f, -0.311004243f, 0.0f // bottom right ) private var vertexBuffer: FloatBuffer = // (number of coordinate values * 4 bytes per float) ByteBuffer.allocateDirect(triangleCoords.size * 4).run { // use the device hardware's native byte order order(ByteOrder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c44901c58ac46e4b1bb89032534c1f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fd26309af567a207d47943e2ef0386d/" rel="bookmark">
			Android 插件化技术应运而生出的 Apk 动态加载技术的开源框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们在平时的开发过程中，会经常遇到产品需求的变更或者出现bug； 在传统的模式中，我们需要首先需要修改代码，然后重新打包Apk再上线，用户在打开应用的时候就会进行更新了
但是这种模式有几个缺点：
一是上线周期长，从修改代码到用户更新需要较长的时间，二是用户更新代价较大，每次用户更新都需要下载整个Apk包； 整个Apk包包括了一个应用的所有代码，要消耗用户较多的流量，并且，如果是一些重要的更新，为了确保用户都能更新到，还需要用到强制更新，即用户打开App后如果不更新应用则退出应用，这种对用户来说是极其不友好的
还有另外一种情况： 某些较大的App功能很多，比如支付宝、微信等，如果将这些功能全部塞到一个Apk中，那将会是一个巨型Apk，用户在安装或者更新Apk时将会经过漫长的等待时间
基于以上两点，Android的 插件化技术 应运而生；插件化技术即将Apk按照功能模块划分，不同的功能打包成不同的Apk，然后应用的主Apk按需加载对应功能的Apk，用户只需要安装应用的主Apk即可，主Apk相当于一个壳，它会按需加载其他功能模块的Apk
通过这种模式，不仅解决了巨型Apk的问题，而且当某个功能模块需要变化时，也只需要修改对应功能的代码，打包功能Apk并更新即可，这样不仅可以让用户及时更新，而且更新的代价也很小
但是，我们知道， 在Android中，没有安装的apk是不能直接运行的，那么要想实现插件化，我们就必须能够让主Apk能够加载功能Apk并运行
插件化的开源框架 插件化发展到现在，已经出现了非常多的框架，下图列出部分框架：
我们在选择开源框架的时候，需要根据自身的需求来； 如果加载的插件不需要和宿主有任何耦合，也无须和宿主进 行通信，比如加载第三方 App，那么推荐使用 RePlugin，其他的情况推荐使用 VirtualApk
动态加载技术： 在程序运行时，动态加载一些程序中原本不存在的可执行文件并运行起来； 随着应用技术的发展，动态加载技术逐渐派生出两个分支:热修复和插件化
热修复：用于修复bug插件化：解决应用庞大，功能模块解耦，复用其他apk的代码 插件化思想： 将复用的apk作为插件，插入另一个apk中，比如淘宝中会有咸鱼的页面，用淘宝为咸鱼引流； 使用插件化技术，可以直接使用咸鱼apk中的dex文件，这样省去再次开发一套咸鱼页面的成本，并且有效的降低了淘宝apk的耦合度
插件化原理 类加载机制和插件加载方法 我们熟悉的ClassLoader有：
BootClassLoader：加载系统的类PathClassLoader：加载已安装的apk类DexClassLoader：自定义加载jar、dex的类 &lt;pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="" cid="n91" mdtype="fences" style="box-sizing: border-box; overflow: visible; font-family: var(--monospace); font-size: 0.9em; display: block; break-inside: avoid; text-align: left; white-space: normal; background-image: inherit; background-position: inherit; background-size: inherit; background-repeat: inherit; background-attachment: inherit; background-origin: inherit; background-clip: inherit; background-color: rgb(248, 248, 248); position: relative !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fd26309af567a207d47943e2ef0386d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2681fcee44bfe199582fa95d0911769f/" rel="bookmark">
			box-sizing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概念：
box-sizing是一个盒子模型box-sizing有两个重要值，content-box和border-box box-sizing使用总结：
box-sizing的默认值为content-box子元素不会主动继承父元素的box-sizingborder-box限制了元素的宽高计算方式，宽高=内边距(padding)+边框(border)+自身高度(content) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef706d419e93ebb2eaefdf136d87968/" rel="bookmark">
			css 样式之 filter 滤镜属性 用法与示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		filter 属性值可以组合使用
filter: blur(5px);
filter: brightness(0.4);
filter: contrast(200%);
filter: saturate(30%);
filter: opacity(25%);
filter: grayscale(50%);
filter: hue-rotate(90deg);
filter: invert(75%);
filter: sepia(60%);
filter: drop-shadow(16px 16px 20px blue);
属性属性值释义默认值filter：–滤镜none–blur（ px ）高斯模糊，类似毛玻璃的样式,，数值越大越模糊，不接受百分比值0–brightness（%）增加图像 亮度，数值/百分比越接近 0 越黑，反之越亮，可超过100%1–contrast（%）调整图像的 对比度，数值/百分比越接近 0 越黑，反之越亮，可超过100%1–saturate（%）设置图像的饱和度，值越大颜色越鲜艳，可超过100%1–opacity（%）设置图像的透明度，值越小越透明，0%-100%之间1–grayscale（%）将图像转为灰度图像，值越大越灰，0%-100%之间，不支持负数0–hue-rotate(deg)调整元素的色相角度，没有最大值。每 360deg 一个变化周期0–invert（%）反转输入图像，值为 0%-100% 之间，值比例越大反转越明显0–sepia（%）将图像转换为深褐色，值越大越明显，0%-100%之间0–drop-shadow (offset-x offset-y blur color)给图像内容设置 阴影 ，与 box-shadow 属性类似，不过box…是对整个外轮廓打上阴影，而drop对针对图像内容打阴影1drop-shadow 属性值的参数如下：---–offset-x必须，X轴边偏移，负值阴影在左边，反之在右边，如果值为0，则在元素底下-–offset-y必须，Y轴边偏移，负值阴影在上边，反之在下边，如果值为0，则在元素底下-–blur可选，模糊效果，值越大越模糊，不允许负值0–color可选，滤镜颜色不设置为透明色 filter 滤镜属性示例 1. filter: blur( px) ---- 高斯模糊2. filter: brightness( %) ---- 亮度/曝光度3. filter: contrast( %) ---- 对比度4. filter: saturate( %) ---- 饱和度5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eef706d419e93ebb2eaefdf136d87968/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d92bd80c41901e5bfc450283542764/" rel="bookmark">
			使用Jmeter遇到随机取值的需求怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然Jmeter能用来做参数化的组建有几个，但是貌似都没有随机取值的功能，所以我们可以用函数__CSVRead()来实现：
*CSV file to get values from | alias：表示要读取的文件路径
*CSV文件列号| next| alias：表示当前变量读取第几列数据，注意第一列是0；
由此可见我们只需将参数化数据在csv中横向排列，然后用随机函数__Random()指定文件序列号即可。
KaTeX parse error: Expected group after '_' at position 2: {_̲_CSVRead(D:\t.t…{__Random(1,6,)})}
t.txt文件内容：a,s,d,f,g,h
搞定！这样即可随机取到t.txt文件中的数据啦。小伙伴们，Get到了吗？
最后感谢每一个认真阅读我文章的人，下面这个网盘链接也是我费了几天时间整理的非常全面的，希望也能帮助到有需要的你！
这些资料，对于想转行做【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴我走过了最艰难的路程，希望也能帮助到你！凡事要趁早，特别是技术行业，一定要提升技术功底。希望对大家有所帮助……
如果你不想一个人野蛮生长，找不到系统的资料，问题得不到帮助，坚持几天便放弃的感受的话，可以点击下方小卡片加入我们群，大家可以一起讨论交流，里面会有各种软件测试资料和技术交流。
敲字不易，如果此文章对你有帮助的话，点个赞收个藏来个关注，给作者一个鼓励。也方便你下次能够快速查找。
自学推荐B站视频： 零基础转行软件测试：38天自学完软件测试，拿到了字节的测试岗offer，堪称B站最好的视频！
自动化测试进阶：已上岸华为，涨薪20K，2022最适合自学的python自动化测试教程，自己花16800买的,无偿分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cade8886f4a1443f9a91b404f78a8e56/" rel="bookmark">
			HAL库ADC&#43;USART发送使用DMA遇到的问题点记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、DMA USART发送完成后，未关闭串口DMA会造成程序死机。
解决：需在串口DMA中断中关闭串口DMA，如下：
__HAL_DMA_CLEAR_FLAG(&amp;hdma_usart1_tx, DMA_FLAG_TC1); //清除传输完成标志 HAL_UART_DMAStop(&amp;huart1);	//传输完成以后关闭串口DMA,缺了这一句会死机 2、DMA USART发送字符串，只发送了部分字符串
printf("芯片flash的容量为: %dK \r\n", *(__IO uint16_t *)(0X1FFFF7E0));	HAL_UART_Transmit_DMA(&amp;huart1,(uint8_t *) "66666666666666\r\n",strlen("66666666666666\r\n")); 解决：发送长度改为原来的2倍，原因暂未找到。
printf("芯片flash的容量为: %dK \r\n", *(__IO uint16_t *)(0X1FFFF7E0));	HAL_UART_Transmit_DMA(&amp;huart1,(uint8_t *) "66666666666666\r\n",strlen("66666666666666\r\n")*2); 3、DMA ADC采集多组数据求均值，只获取到一次的采集数据
解决：存储数组改为二维数组，启动ADC转换和 DMA传输函数长度改为数组大小
uint16_t ADC_ConvertedValue[NUM][1]; // AD转换结果值 HAL_ADC_Start_DMA(&amp;hadc1,(uint32_t *)&amp;ADC_ConvertedValue,NUM); //启动AD转换并使能DMA传输和中断 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f0edef0c7f66feb95200d0dc86b4e5/" rel="bookmark">
			WXML 文件编译错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序编译崩溃
原因：是我在textarea的placeholder里面换行
这是需求图
h5可以运行成功，但是运行到小程序里面就会编译失败，不得不说小程序是真的矫情，一般来说在小程序运行没问题了以后h5也不会有问题，但是在h5里面运行没什么问题 小程序里面就不一定了
解决思路：
我重新写了一个textarea标签，然后再用其他的div给内容换行，如果textarea里面有值，那div就会隐藏
不过有个小bug，如果用的是中文来输入，拼音打出来了以后div还是会在，因为拼音打出来了并没有在textarea里面，所以也不会消失
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17bf7681b5c8d6cca6a3e294f5ec0869/" rel="bookmark">
			k8s KubeSphere流水线部署Vue前端项目 详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KubeSphere流水线部署Vue前端项目 1. 创建流水线项目2. 首先去流水线项目 创建三个凭证3. 创建流水线4. 流水线Jenkinsfile文件5. 可视化流水线设置说明- 粘贴以上Jenkinsfile文件,点编辑流水线- 拉取- 编译打包Dockerfile文件内容：nginx dream-yard-vue.conf配置文件： - 推送- 部署deploy.yaml文件： 6. 以上就完成啦 1. 创建流水线项目 2. 首先去流水线项目 创建三个凭证 kubeconfig类型：默认内容为当前用户的 kubeconfig 配置。 选择此类型创建默认有值用户名密码（my-login）：git账号和密码用户名密码（my-aliyun-docker）：阿里云容器镜像仓库账号密码 3. 创建流水线 4. 流水线Jenkinsfile文件 pipeline { agent { node { label 'nodejs' } } stages { stage('拉取') { agent none steps { container('nodejs') { git(url: 'https://gitee.com/wy521a/dream-yard-vue.git', credentialsId: 'my-login', branch: 'master', changelog: true, poll: false) sh 'ls ' } } } stage('编译') { agent none steps { container('nodejs') { sh 'ls' sh 'npm install --registry=https://registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17bf7681b5c8d6cca6a3e294f5ec0869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b0082922b2e1e2caefc183c8684ff54/" rel="bookmark">
			三个线程交替打印ABC100次问题思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题：使用三个线程交替打印ABC，直至100次代码实战 方法一： 使用notify()、wait()方法
public class PrintAbc { /** * 唤醒线程的状态值 state: threadA = 0, threadB = 1, threadC =2, */ int state = 0; /** * 循环技术，初始值0 */ int count = 0; public void print(PrintAbc printAbc) { Thread threadA = new Thread(() -&gt; { extracted(printAbc, "A", 0, 1); }); Thread threadB = new Thread(() -&gt; { extracted(printAbc, "B", 1, 2); }); Thread threadC = new Thread(() -&gt; { extracted(printAbc, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b0082922b2e1e2caefc183c8684ff54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90089532d0c0e8d18eb2f2cd03be0652/" rel="bookmark">
			使用命令行创建任意大小文件的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用命令行创建任意大小文件的方法 作为一个测试工程师，在工作中可能需要创建任意大小的文件。下面介绍下如何使用命令行创建任意大小的文件：
1、Linux - dd命令：
Linux下的dd命令很是强大，可以这样使用dd命令来创建指定大小的文件：
生成固定大小文件
dd if=/dev/zero of=/home/bluestorm/100M.img bs=1M count=1024(生成一个100M的文件，文件名为100M.img) 使用的格式如下：（从sina.html文件读取1024Byte字节生成一个文本文件mm0.txt） “dd if=/home/sina.html of=/home/mms0.txt bs=1024 count=1” if的参数是输入文件是新浪的主页,
of的参数是要生成的文件，
bs的参数是每次读入的block大小，这里就设为要生成的文件大小,
count的参数是读取的block个数，这里就设为1。
通过bs和count组合就可以生成指定大小的文件，根据if输入源的不同也内容也可以随机。
2、Windows - fsutil file createnew : fsutil file createnew f:\测试附件-10M.txt 10485760 以上命令是在F盘创建文件名为：测试附件-10M大小的txt文件 最后的数字10485760是Byte（字节）：10*1024*1024=10485760 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb3167705de259b41810bc5fc914b054/" rel="bookmark">
			OpenCV图像处理学习十六，解析图像卷积运算原理并应用Sobel算子，Scharr算子和拉普拉斯算子（Laplance）的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.卷积核的概念 卷积核，通常也叫算子。用一个设定数值模板去处理一张输入图片，进行卷积运算。目的是使目标与目标之间的差距变得更大。卷积在数字图像处理中最常见的应用为锐化和边缘提取。
边缘提取：
当前景目标像素值与周边背景目标的像素值有较大差异时，可以通过卷积核对原图矩阵中的这个位置进行卷积运算，得出的值和该像素点原来的灰度值会产生显著的差异。变化的值超过我们预设的范围后，就可以将图像进行阈值处理，将图像的差异最大化，可以得到了一黑色为背景，白色线条作为边缘或形状的边缘提取效果图。
锐化算子：
通过卷积运算，可以增大矩阵每一个元素与周边元素的反差，起到锐化作用。图像锐化是补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像变得清晰，分为空间域处理和频域处理两类。图像锐化是为了突出图像上地物的边缘、轮廓，或某些线性目标要素的特征，也被称为边缘增强。
对图像求它的一阶导数
delta = f(x) – f(x-1), delta越大，说明像素在X方向变化越大，边缘信号越强
=========================================================================
二.图像卷积的运算原理 卷积核作为一个设定数值模板矩阵，输入的待处理的图像作为原型矩阵，二者进行图像卷积运算，主要是使模板矩阵的中心像素点（称之为锚点）覆盖在待计算原型矩阵元素上面，中心像素点逐一对齐原型矩阵上的像素点（边缘像素无法对齐锚点，也就无法进行卷积计算，只能通过边缘像素处理后才能进行卷积），然后计算元素值与被覆盖的卷积核中的值的乘积和。将这个和赋值给当前锚点，这就是卷积的运算过程。 ​​​
--------------------------------------------------------------------------------------------------------------------------------
第一类：Sobel算子 Sobel算子的概念
Sobel算子是离散微分算子（discrete differentiation operator），用来计算图像灰度的近似梯度。sobel算子由两个3X3的卷积核构成，分别用于计算中心像素邻域的灰度加权差。分为垂直方向和水平方向的索伯滤波器Gx 和Gy。Soble算子功能集合高斯平滑和微分求导,又被称为一阶微分算子，求导算子，在水平和垂直两个方向上求导，得到图像X方法与Y方向梯度图像，如下图。
参数说明：
#参数说明： I 代表输入图像产生的图像矩阵， Gx及Gy 分别代表经横向及纵向边缘检测的图像灰度值 G 表示图像的每一个像素的横向及纵向灰度值，有两种计算方式，通常Gx和Gy开方运算比较复杂 ------------------------------------------------------------------------------------------------------------------- Sobel算子的卷积计算过程
为计算图像x方向上的梯度图像，我们需要一个卷积核kernel(Gx)和3*3的像素图片矩阵P。
#卷积核kernel和图像 P Mat kernel = (Mat_&lt;char&gt;(3, 3) &lt;&lt; -1，0，+1，-2，0，+2，-1，0，+1); Mat P = (Mat_&lt;char&gt;(3, 3) &lt;&lt;P1,P2,P3,P4,P5,P6,P7,P8,P9); 以卷积核模板的中心像素为锚点，将卷积核与图像上像素值一一对应进行像素遍历，卷积核上的数字相当于加权系数。利用如下公式即可计算出卷积核中心的x方向梯度。
卷积计算过程为：P5 = (P3-P1)+2*(P6-P4)+(P9-P7)
同样的原理，在Gy方向上的梯度计算也可以求取
卷积计算过程为：P5 = (P7-P1)+2*(P8-P2)+(P9-P3)，这样就得到了垂直方向和水平方向的图像梯度Gx 和Gy，就可以求出总的图像梯度，通常取|Gx| + |Gy|的和作为总的图像梯度。
---------------------------------------------------------------------------------------------------------------------------------
Sobel算子API函数接口： #函数API接口： cv::Sobel ( InputArray Src // 输入图像 OutputArray dst// 输出图像，大小与输入图像一致 int depth // 输出图像深度.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb3167705de259b41810bc5fc914b054/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15bef8e1cad2cdeefb8d746e6cb5e423/" rel="bookmark">
			1103 缘分数(20) vector对pair排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缘分数是指这样一对正整数 a 和 b，其中 a 和它的小弟 a−1 的立方差正好是另一个整数 c 的平方，而 c 正好是 b 和它的小弟 b−1 的平方和。例如 83−73=169=132，而 13=32+22，于是 8 和 3 就是一对缘分数。
给定 a 所在的区间 [m,n]，是否存在缘分数？
输入格式： 输入给出区间的两个端点 0&lt;m&lt;n≤25000，其间以空格分隔。
输出格式： 按照 a 从小到大的顺序，每行输出一对缘分数，数字间以空格分隔。如果无解，则输出 No Solution。
输入样例 1： 8 200 输出样例 1： 8 3 105 10 输入样例 2： 9 100 输出样例 2： No Solution #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;pair&lt;int,int&gt;&gt;v; int m,n; int Is_yuan(double num){ for(int i = 0;i&lt;=sqrt(num);i++){ if(i*i+(i-1)*(i-1) == num) return i; } return 0; } bool cmp(const pair&lt;int,int&gt;&amp;a, const pair&lt;int,int&gt;&amp;b){ return a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15bef8e1cad2cdeefb8d746e6cb5e423/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/240/">«</a>
	<span class="pagination__item pagination__item--current">241/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/242/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>