<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a14f7553fab14d51855e234205a4d5/" rel="bookmark">
			网办项目经验小结3-Ajax，获取URL参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：项目中，感觉这一句很有用：jsp中 String contextPath=request.getContextPath();
具体说明：
&lt;a href="&lt;%=request.getContextPath()%&gt;/XXXX.jsp"&gt;
指的是根目录下的xxxx.jsp
假设你的要目录http://localhost:8080,
你现在访问的页面为http://localhost:8080/admin/manage.jsp
则&lt;a href="&lt;%=request.getContextPath()%&gt;/XXXX.jsp"&gt;
指向的链接是：http://localhost:8080/xxxx.jsp
&lt;a href="XXXX.jsp"&gt;链接的是当前jsp文件路径下的xxxx.jsp
上例指向的链接是：http://localhost:8080/admin/xxxx.jsp:
2：Ajax说明
ajax异步传输，并实现动态为页面动态增加控件的功能，这里可以直接使用jQuery获取网页控件，如$("#gov"),通过id获取控件
例子；
function ajaxLoadGovs() {
var ajaxUrl = contextPath+"/sxzc/queryServFolder/ajaxLoadGovs.action";
$.ajax({
url:ajaxUrl, type:"GET", dataType:"json", beforeSend:function () {}, success:function (json) {
var target = document.getElementById("selectGovs");
for (var i = 0; i &lt; json.length; i++) {
var everyData = json[i];
var optionNode = document.createElement("option");
optionNode.value = everyData.divisionCode;
optionNode.innerHTML = everyData.divisionName;
optionNode.selectvalue = everyData.divisionCode;
optionNode.selectType = everyData.type;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0a14f7553fab14d51855e234205a4d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f1aa9ab37e6027a8c185c7acf2e1ced/" rel="bookmark">
			如何用OpenStack安全构建私有云？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【TechTarget中国原创】如果你已经决定投入并构建你自己的云，那么恭喜你！现在不是仅仅构建安全的图片、锁定实例并管理你的数据，你也要确保运行的整个基础架构的安全。
有人常常认为运行私有云来解决与公有提供商，像亚马逊和Rackspace相关的安全问题。但是仅仅因为你的源在防火墙之后并不意味着安全问题逐渐消失。你可能不必担心多租户的风险，但是先要对确保整个的物理硬件的安全负责。
在使用像OpenStack这样的较为年轻的平台的时候尤其困难，这个平台仅仅才两年而且文档不健全。我个人学习了一些OpenStack的内容，在这篇技巧中，我讲讨论下如何使用OpenStack构建私有云，基于我的研究以及一些亲身体验的测试，会覆盖一些安全部署的步骤。
OpenStack：如何构建私有云
第一步是设置正确的硬件和网络环境。尽管OpenStack允许我们在一个单一的平面网络上部署一切，从安全的角度来看并不安全。取决于你所使用的管理程序以及虚拟网络接口，它会允许guest虚拟机嗅探管理流量。我建议你至少使用两个网络：一个用来管理流量，一个用来进行虚拟机之间的对话。这意味着所有的云计算结点中你需要两个网卡（一个运行实例）和网络管理者。这些应该运行在不同的IP范围中。
计算结点和实例的网络也需要支持VLAN标记，因为这是在“项目”之间隔绝流量所使用的机制。一个项目等价于你的亚马逊EC2账户，除了你不能按照你所希望的数目创建和分配之外。每一个项目都有自己的管理员和用户，在既定项目中的所有实例可以彼此通信。通过指派每一个项目自己的VLAN以及内部和外部的IT地址池来执行。
一旦硬件和网络设置好，下一步就是确定在哪里部署所有的OpenStack组件。标准部署颖有一个控制器和一系列计算结点。控制器运行消息服务器，数据库和其他的组件来编排云，同时计算几点运行实例。但是你也可以分解控制器为地理的部分，从而改善性能，像把MySQL放在不同的物理盒中。对于安全而言，最关键的是确保每一部分都安装在安全的主机上，你只需要将其附加在网络上，让云运转即可。
只有两部分需要暴露给外面的世界（即使那只是你的企业网络）：API服务器/Web 控制台（如果开启）和网络管理者。这些服务器需要过硬，你甚至可以使用第三方网络接口来隔离后端管理用户连接产生的流量。
如果你遵循默认安装说明书，可能这些部分并不如他们应该的那样安全。下面是一些具体的改变：
* MySQL服务器使用指定的用户账户，不是根MySQL管理账户。这个账户和密码将会暴露在每一个云结点上，即使使用基于证书的认证，因此所有结点需要访问这个数据库服务器。
* MySQL配置文件中，限制访问服务器，OpenStack用户账户为唯一授权IP地址。
* 移除任何不需要的OS组件并确保你所设置的服务器只支持通过SSH的基于密钥的登陆。
* 默认MySQL和RabbitMQ（消息服务器）流量不加密。如果你隔离了管理网络和坚固的主机，这就不应该是一个很糟糕的风险。如果你的云网络易于嗅探（例如，它和其他服务器共享网络），你需要加密流量。你可以使用OpenSSL来进行MySQL 和RabbitMQ处理。（我个人还没进行测试，因此配置可能有点难。）
下一步，记住如果你支持Web管理控制台，默认不适用SSL。这要比其他的管理组件更成问题，因为通常是外部访问。你会最清楚希望使用Apache和SSL来配置。
这些仅仅是你开始做的一些基础。我们已经略过了像配置CloudPipe（专用VPN开发者可以用它访问项目实例），管理开发者证书，构建安全图片或者控制管理程序，但是这些步骤将会协助你开始项目，而且是一种安全的基础架构。
原文地址：http://www.searchcloudcomputing.com.cn/showcontent_59217.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/042dddaf7b9ced9da72dd3bbfeded5d8/" rel="bookmark">
			FRDM_KL26 虚拟串口安装失败的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正常情况下，只要安装好PEMicro驱动，将FRDM_KL26 和电脑连接后，系统就会自动查找相关驱动并安装。但是在某些电脑上有可能出现无法正确安装 PEMicro/Freescale – CDC serial Port 驱动的问题，这样就会导致虚拟串口无法使用，出现的现象如下：
解决这个问题的方法是：
step1：将usbser.sys 文件拷贝到无法安装驱动的电脑的c:\Windows\System32\drivers 目录中。usbser.sys文件的下载地址为：http://download.csdn.net/detail/wangwenxue1989/8274947 step2：修改FRDM-KL26Z盘中的SERCDC89.INF文件，删除掉其中的 CopyFiles=DriverCopyFiles.NTamd64 这句话并保存。
SERCDC89.INF默认为只读，先去掉只读属性才可以修改。
step3.：更新一下驱动程序即可
经过以上步骤以后，既可以正常使用虚拟串口了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e8d1f7e4221a1eb562bd53ccd0c08e/" rel="bookmark">
			什么乱七八糟的东西
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		偶然间发现iteye被灌水成这个样子了,管理员哪去了?
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f31f54bc63c03f45d79a525f25e9f585/" rel="bookmark">
			Android 源码解析 之 setContentView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处：http://blog.csdn.net/lmj623565791/article/details/41894125，本文出自：【张鸿洋的博客】
大家在平时的开发中，对于setContentView肯定不陌生，那么对其内部的实现会不会比较好奇呢~~~有幸终于能看到一些PhoneWindow神马的源码，今天就带大家来跑一回源码~~
1、Activity setContentView 首先不用说，进入Activity的setContentView
public void setContentView(int layoutResID) { getWindow().setContentView(layoutResID); initActionBar(); } 可以看到里面获取了Window，然后调用了Window的setContentView
2、PhoneWindow setContentView 这里的Window的实现类是PhoneWindow（package com.android.internal.policy.impl;），我们直接看它的实现：
@Override public void setContentView(int layoutResID) { if (mContentParent == null) { installDecor(); } else { mContentParent.removeAllViews(); } mLayoutInflater.inflate(layoutResID, mContentParent); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) { cb.onContentChanged(); } } 可以看到，首先判断mContentParent是否为null，是则调用installDecor()，否则移除其内部所有的子Views，然后通过LayoutInflater.inflate将我们传入的layout放置到mContentParent中。 从这里就能看出来mContentParent是个ViewGroup且包裹我们整个布局文件；而installDecor()估计就是去初始化我们这个mContentParent，一会我们会去验证。
接下来，通过getCallBack拿到了一个CallBack对象，其实这个获取到的这个CallBack就是我们Activity自己，你可以去看我们的Activity是实现了CallBack接口的。
这个Callback明显就是一个回调，当PhoneWindow接收到系统分发给它的触摸、IO、菜单等相关的事件时，可以回调相应的Activity进行处理。至于Callback可以回调哪些方法，自己看下这个接口的声明方法即可。当然了这里不是我们的关键，因为我们的setContentView里面只是回调了onContentChanged，而onContentChanged在Activity中是空实现。
好了，接下来去看我们的installDecor()
3、PhoneWindow installDecor private void installDecor() { if (mDecor == null) { mDecor = generateDecor(); mDecor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f31f54bc63c03f45d79a525f25e9f585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b98935f2b6736581d0d7acb43e794922/" rel="bookmark">
			CRT堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验环境：win764位旗舰版、VS2010旗舰版
每个进程都有一个默认堆，在进程初始化的时候会创建这个默认堆，可以通过GetProcessHeap()获取默认堆的句柄。使用CRT时，也会有一个CRT堆，VS项目属性 ~ C/C++ ~ 代码生成 ~ 运行库，如果选择多线程DLL，则CRT堆初始化在DLL中，如果选择多线程，则会在进入_tmain函数之前。 运行库连接方式设置：
CRT堆初始化：
位于VS目录Microsoft Visual Studio 10.0\VC\crt\src\heapinit.c文件中有一个_heap_init函数，可以设置断点查看CRT堆初始化过程。
int __cdecl _heap_init (void) { ULONG HeapType = 2; // Initialize the "big-block" heap first. if ( (_crtheap = HeapCreate(0, BYTES_PER_PAGE, 0)) == NULL ) return 0; #ifdef _WIN64 // Enable the Low Fragmentation Heap by default on Windows XP and // Windows Server 2003. It's the 8 byte overhead heap, and has // generally better performance charateristics than standard heap, // particularly for apps that perform lots of small allocations.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b98935f2b6736581d0d7acb43e794922/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a87555baf482df8280950e7dd0c525/" rel="bookmark">
			QMosaic软件更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QMosaic V3.2.2版本新功能：
1、优化“影像处理工具箱”中Pan Sharpening融合和HPF批量融合；
2、修复部分已知BUG;
------------------------------------------------- QMosaic V3.2.1版本新功能：
1、优化了色彩模板匀色功能；
2、镶嵌输出支持多种数据格式；
3、改变部分功能界面布局；
4、添加“影像处理工具箱”工具，“影像处理工具箱”提供影像重采样、分辨率融合、HPF批量融合和模板匀色功能；
-------------------------------------------------
QMosaic V3.1.1版本新功能：
1、镶嵌输出支持单景匀色输出；
2、镶嵌输出创建金字塔；
3、添加色彩模板映射批处理工具；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80a8f4aeddb5c1b02683f57612abd3ef/" rel="bookmark">
			@html.DropDowlistFor 和@Html.RadioButton使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/// &lt;summary&gt; /// 获取dropdowList集合 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public IEnumerable&lt;SelectListItem&gt; GetSelectList(string user_id,int classId) { string ClassId = classId.ToString(); var query = from p in entities.T_Category where p.User_Id == user_id &amp; p.ClassId == classId select p; var selectList = query.Select(a =&gt; new SelectListItem { Text = a.ClassName, Value = System.Data.Objects.SqlClient.SqlFunctions.StringConvert((double)a.Id) }); return selectList; }
定义 IEnumerable&lt;SelectListItem&gt; 得到集合 list_Education
@Html.DropDownListFor(m =&gt; m.Education, list_Education, new { @class = "usern-style" })
@Html.RadioButtonFor(m =&gt; m.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80a8f4aeddb5c1b02683f57612abd3ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43c738067c17e89476a2d36e438c8cb4/" rel="bookmark">
			史上最强大的浏览器嗅探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前端开发中经常会遇到一系列兼容性问题，怎样精准地识别出各个浏览器的版本是一件很头痛的问题，尤其是navigator有可能被厂商伪造的情况。虽然大神们建议要针对浏览器特性来处理而不是通过浏览器版本，但是实际操作过程中却有相当大的困难。
以下是大神们总结的各种浏览器嗅探的办法，亲测无误
IE篇：
ie=!!window.VBArray
ie678=!+"\v1";
ie678=!-[1,];
ie678='\v'=='v';
ie678=('a-b'.split(/(~)/))[1]=="b"
ie678=0.9.toFixed(0)=="0"
ie678=/\w/.test('\u0130') ie8=window.toStaticHTML
ie9=window.msPerformance
ie678=0//@cc_on+1;
ie67=!"1"[0] ie8=!!window.XDomainRequest;
ie9=document.documentMode&amp;&amp;document.documentMode===9;
ie10 = window.navigator.msPointerEnabled;
ie11 = !!window.MSInputMethodContext;
Firefox篇：
firefox=!!window.netscape;
firefox=!!window.updateCommands;
safari=window.openDatabase&amp;&amp;!window.chrome;
chrome=!!(window.chrome&amp;&amp;window.google);
移动设备篇：
iphone=/iphone/i.test(navigator.userAgent);
iphone4=window.devicePixelRatio&gt;=2;
ipad=/iPad/i.test(navigator.userAgent);
android=/android/i.test(navigator.userAgent);
IOS=iphone||ipad;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59d1e667d8236aa138c49519c0ae8fb5/" rel="bookmark">
			jQuery获取未选中的checkbox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var unCheckedBoxs = $("input[name='myCheckbox']").not("input:checked"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27903ca15f91d2ed6c92dadacf59fafe/" rel="bookmark">
			IOS开发知识体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f9d1034f120c3564ec09b1a39a8e64f/" rel="bookmark">
			Java 中的 long 与 byte 互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		long 占 8 个字节，在网络传输时经常用到！
public static byte[] LongToBytes(long values) { byte[] buffer = new byte[8]; for (int i = 0; i &lt; 8; i++) { int offset = 64 - (i + 1) * 8; buffer[i] = (byte) ((values &gt;&gt; offset) &amp; 0xff); } return buffer; } public static long BytesToLong(byte[] buffer) { long values = 0; for (int i = 0; i &lt; 8; i++) { values &lt;&lt;= 8; values|= (buffer[i] &amp; 0xff); } return values; } --------------------------转
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f9d1034f120c3564ec09b1a39a8e64f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afc0207dcb1c3061305fb2461a185cf8/" rel="bookmark">
			ServiceLoader服务提供者模式，实现动态插件加载，类责任链模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Edit ServiceLoader服务提供者模式，实现动态插件加载，类责任链模式 ServiceLoader的功能比ClassLoader简单，它可以帮我们获取所有实现了某接口或基类的类。当然前提是ClassLoader已经加载过的类。举个例子： 定义一个接口：
public interface IService { public String sayHello(); public String getScheme(); } 以及两个实现类：
public class HDFSService implements IService { @Override public String sayHello() { return "Hello HDFS!!"; } @Override public String getScheme() { return "hdfs"; } } public class LocalService implements IService { @Override public String sayHello() { return "Hello Local!!"; } @Override public String getScheme() { return "local"; } } 将 HDFSService 和 LocalService 打包成 jar，java包的 META-INFO/services 下以IService这个类的全名来新建立一个文件，文件中的内容为两个实现类的全名：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afc0207dcb1c3061305fb2461a185cf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d17db0c786a07cddef3910d675eb379/" rel="bookmark">
			创新是技术推动的源动力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创新是技术推动的源动力
作为两届讲师，今年很荣幸受邀以观察者的身份参加Top100Summit全球软件案例研究峰会，这次的大会主题是《技术团队创新变革》，这次主题和我近一年的工作目标也不谋而合，当我从技术团队的带头人转变为管理岗，从思考技术的创新转变为思考团队创新，在为期4天的峰会中收获颇多。
这次大会依然继承之前两期的管理，组委会从全国投稿的几百件案例中甄选出100件具有代表价值的案例，进行为期4天的分享，第一天开幕式，各路大拿纷纷登场，基于这次主题展开各个不同角度的观点进行了激情的碰撞。对于团队管理不公公司的理解和实践方式不一致，有讲求无为而治，来自猎豹网络开发者关系总监则有不同的实践方法，双方各有优点，以至于大家在茶歇的时候还在讨论到底是哪一种实践更适合自己，至于对或者不对暂且不论，毕竟这是一个IT技术百家争鸣的时代嘛。
第二天，五个分论坛正式开始了案例解读，一大早各路人马就齐聚国际会议中心，给我最大的感觉就是会场太小了，每个分会场都有大量的同学站着听分享，大厅里也是人来人往的串场的同学，每个休息区都有三五成群的同学在讨论着参加的分享的体验。
当然咱也有咱的目标，《微博feed分级缓存的极致优化带来50%的效率提升》，高端大气上档次，不能不听，去年咱也分享了基于大数据相关的主题，一直以来数据和用户体验的结合始终是我们技术团队需要努力的方向，来自新浪微博的架构师张小川分享了他们在对于微博这种并发访问量大、数据量大、同时要求低响应时间和高可用的系统中，缓存使用的方式，并且通过基于数据分析进行缓存分级之后，减少微博缓存容量1/3， 降低微博缓存带宽消耗1/3，并将缓存性能提高了1/3，这么高的成绩。
下午是咱十分关注的老朋友傅强同学关于从技术到管理的心历路程，对我的触动相当的大，毕竟我也是一个从技术到管理的路程，遇到的问题和傅强基本差别不大，学习他的心路历程让自己提高下。
作为从业务层面转型管理的技术人，傅强老师总结了专业岗转到管理岗时初期常见一些困惑，如时间碎片化、专业技能成长缓慢、团队员工工作质量如何保证等。以及针对这些困惑，所做的尝试。
了解到团队扩大，管理岗进阶的过程中，管理者仍然会遇到精力严重不足、关键点了解深度不足、团队工作质量失控等问题。这种情况下，作为管理者需要作出相应的调整。
面对因团队水平参差不齐，为保项目目标，自己身先士卒，但很容易陷入到个人心力憔悴+团队成长缓慢的状态，傅强老师给出了建议：短期压力再大，也要抬头看路。接受有短期高强度，也要有3-6个月的人才计划。投入在招聘方面的精力一定要重视；互联网人才抢夺战再激励，3-6个月还是有足够时间搭队伍了。或跨部门协调资源解决。如果资源就是客观不能到位，智能重新调整团队目标。
最重要的，作为管理者，一定要明确哪些重要且只能由“我”做的事，其他项尽量合理授权，从顶层至底层的优化团队效率。
摸着石头过河，也要抬头看路，大局观、战略观在项目中也不可缺少，组织架构的完善，清晰的目标也是让团队增强战斗力的一种方式。
团队人员增加相关的活动也要跟的上，内部的技术分享，外部的学习成长的机会，事情虽小但是收益确实很大。
其他参加的各个专题就不一一列举了，总之今年的案例分享让我学习了技术团队的创新方法、方式，完美中也有不足的地方，在大数据云计算热火的今天，网络安全和运维也变得日益重要了，这块的内容还是偏少，希望明年的案例分享能够增加网络安全和运维的专题，以满足大家对这块的需求。
以上是我对2014年Top100 Summit案例分享的体验，也是混合各位讲师分享主题的产物，欢迎拍砖。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/508cac55f20b92996150577d5972ae36/" rel="bookmark">
			VB循环语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.While...Wend 语句 只要指定的条件为 True，则会重复执行一系列的语句。 语法 While condition [statements] .. Wend 2.Do...Loop 2.1 第一种用法 用 Do 循环重复执行一语句块，且重复次数不定。Do...Loop 语句有几种演变形式，但每种都计算数值条件以决定是否继续执行。如同 If...Then condition 必须是一个数值或者值为 True（非零）或 False（零）的表达式。 在下面的 Do...Loop 循环中，只要 condition 为 True 就执行 statements。 Do While condition statements .. Loop 2.2 第二种用法 Do...Loop 语句的另一种演变形式是先执行语句，然后在每次执行后测试 condition。这种形式保证 statements 至少执行一次： Do statements Loop While condition 注:其它两种演变形式类似于前两个，所不同的是，只要 condition 为 False 而不是 True，它们就执行循环。 循环零次或多次 Do Until condition statements Loop 至少循环一次 Do statements Loop Until condition 3.For...Next 在不知道循环内需要执行多少次语句时，宜用 Do 循环。但是，在知道要执行多少次时，则最好使用 For.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/508cac55f20b92996150577d5972ae36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c02a82a45400fa40cf8644386797ea9/" rel="bookmark">
			神经网络（Neural Networks）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介 一般的回归和分类方式是基于线性模型，也就是固定的非线性的基函数（basis function）的线性组合，形式如下：
其中，如果f（.）是非线性的激活函数（activation function），这就是一个分类模型；如果f（.）是恒等函数（identity），则是回归模型。
根据自己的认识，我认为神经网络就是多层这样的模型的叠加，并引入非线性的activation function，提高模型的整体能力（因为每一个隐藏层可以对上一层的输出进行非线性变换，因此深度神经网络拥有比“浅层”网络拥有更加优异的表达能力）。神经网络的计算量相比于其他的回归和分类模型比较大，在早期并没有受到研究者的重视，随机近几年计算机设备的性能提升从而受到广泛的关注，也诞生了新的领域Deep learning。
上图是简单的三层神经网络，其中，相邻层之间是全联通的（即下一层的输入是上一层所有结点的线性组合），当然也有不是全联通的网络，典型代表是卷积神经网络（CNN），CNN在计算机视觉领域取得比较的成果，由于图像的维度比较高，如果采用全联通结构会导致模型会有非常多的参数，使得模型变得非常复杂。另外，一般情况下hidden layer 的结点数目会比input layer和output layer的结点多（稀疏自动编码，是一种hidden layer的结点数比其他的小，而input layer 和 output layer的结点数相同）。
此外，神经网络也可以分为监督神经网络和非监督神经网络，我们比较熟悉的是监督神经网络，该模型可以处理分类，回归问题；非监督神经网络最典型的的就是稀疏自编码器（Sparse Autoencoder）。
神经网络主要有三部分构成：正反馈（Feedforward），代价函数（cost function）,反向传播（Backpropagation），下面从这三部分介绍神经网络。
2.正反馈（Feedforward） 正反馈比较简单，计算过程可见上图。简单介绍下激励函数（activation function），最常用是sigmoid数和tanh函数。
sigmoid函数： tanh函数：
这个两个函数的特性就是它的导数比较特别，方面后面的计算。Sigmoid函数的导数是，tanh函数的导数是。
3.代价函数（cost function） 在线性回归中，我们使用sum-of-square cost function，在这里我们同样可以使用，代价函数为：
接下来，我们需要找到某个w使得代价函数最小。在回归问题中，我们可以得到参数w的解析解，但在该问题中由于activation function是非线性的，E(w)是一个非凸函数，我们无法得到解析解，但可通过迭代优化方法求解。
我们最熟悉的梯度下降（gradient descent），用梯度信息来更新参数w，每一次迭代按如下公式更新：
这是batch gradient descent，该方法的缺点是比较time-consuming，每更新一次参数需要计算整个数据集的数据。对于这种batch optimization，更高效的方法是共轭梯度（conjugate gradients）和拟牛顿（quasi-newton），这两种方法每次迭代cost function都会减小，除非w已经是局部或者全局最小值，这个和梯度下降不同。
另外一种是on-line 的方法，假设所有的观测值都是独立的，cost function 有每一个数据的cost组成：
我们采用on-line gradient descent，也被称为sequential或者stochasticgradient descent，这个方法每一次迭代都只基于一个数据数据，梯度下降中每一次迭代按如下公式更新：
Tip：为了得到足够好的最小值，我们往往需要运行多次优化算法，每一次都随机的取不同的初始参数，在validation set 上比较性能。
到目前为止，我们已经知道如何求解模型的参数了，但是cost function的梯度未知，如何求解梯度呢，神经网络通过后向传播来求解梯度，大大提高了计算效率。
4.反向传播（Backpropagation） 在这里，我以on-line的方法为例子，主要参照PRML，其中的一些符号与UFLDL 的tutorial有所不同，需要注意的是，其中z和a的意义正好相反。
现在考虑最简单的一层神经网络，也就是输出是输入的线性组合，即
，
对于某一个输入n，cost function为
，
然后我们求cost function关于wji的梯度，得到
。
现在考虑一般的神经网络结构，使用chain rule求解偏导数，得到，我们记，该值经常被称为error。由于，推到可以得到。现在，我们只需要知道delta_j和z_j，就可以求解cost function关于wji的偏导数了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c02a82a45400fa40cf8644386797ea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20e0bebcf2e372d0e38aef9eda8a3cdf/" rel="bookmark">
			Linux Ubuntu下运行startx的后果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天不小心在Ubuntu（14.04 LTS）命令行中运行startx命令，结果导致系统重新启动了。更严重的是，重启后再输入密码，然后又进入一个登陆界面，输入密码，然后又回到原来的登陆界面。。。这样一直下去，死循环了
没办法，在网上找了找解决办法。共享一下：
解决办法：
1. Alt+Ctrl+F3，进入控制台界面；
2. cd ~，进入你的用户目录
3. rm -rf .Xauth*，删除.Xauthority文件
4. Alt+Ctrl+F7，返回到登陆界面
5. 输入密码即可登入。
startx命令是用来启动X windows服务器的，运行后在用户目录下生成一个.Xauthority文件，正是该文件导致系统进入死循环。删除即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5986e3e90fb0b8ff7a08724971d4a2a9/" rel="bookmark">
			我又回来了，自己的站点维护太费力了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈哈，又回到csdn了，高估了自己维护站点的能力，还是csdn配置齐全，blog继续更新。
个人站点 ：http://1.hwcblog.sinaapp.com/ ，后续有经历会再维护的，也欢迎来访。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/804bade15bb6fcfe55354095bc346d6c/" rel="bookmark">
			el表达式保留两位小数、使用jstl &lt;fmt:formatNumber&gt;标签保留两位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %&gt; &lt;fmt:formatNumber type="number" value="${688.87 * 0.8 }" pattern="0.00" maxFractionDigits="2"/&gt; 上面代码输出结果为：551.10
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebc892756187cf2f6873ec36deea71e4/" rel="bookmark">
			curl CURLOPT_WRITEFUNCTION 的参数设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注册CSDN有十几年了，第一次发文。写博客不求有没有人看，最大的好处是可以记录一些心得。
最近研究CURL，第一步就卡了一天。代码如下：
string operation="";
curl_easy_setopt(curl,CURLOPT_URL, "http://localhost/index2.php?username=superdos&amp;password=123"); curl_easy_setopt(curl,CURLOPT_POST, true); curl_easy_setopt(curl,CURLOPT_POSTFIELDS,operation.c_str()); curl_easy_setopt (curl, CURLOPT_FOLLOWLOCATION , 1 L); curl_easy_setopt (curl, CURLOPT_WRITEFUNCTION ,&amp; HelloWorld :: writeFunction ); curl_easy_setopt (curl, CURLOPT_WRITEDATA , &amp;buffer); curl_easy_setopt (curl, CURLOPT_TIMEOUT_MS , 5000 ); ret = curl_easy_perform (curl); if (ret== CURLE_OK ) { log ( "ok" ); } curl_easy_cleanup (curl); 其中writeFunction的声明: size_t HelloWorld::writeFunction(void* ptr,size_t size,size_t number,void *stream);
调适过程中发现，虽然curl_easy_perform()返回正常，但是writeFunction函数中，输入参数的内容不正常。ptr，stream输入的不是内存地址，而是返回数据的长度及批次。number反而是一个内存地址。
后来想到在模块间传递类成员函数指针，必须是static的，于是在write Function的声明前加上static后正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f2c0fee3934024f0840ed78057ea7e7/" rel="bookmark">
			ceph存储  ceph中对crush算法的认知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ceph的CRUSH数据分布算法介绍
CRUSH是ceph的一个模块，主要解决可控、可扩展、去中心化的数据副本分布问题。
1、摘要
随着大规模分布式存储系统(PB级的数据和成百上千台存储设备)的出现。这些系统必须平衡的分布数据和负载(提高资源利用率)，最大化系统的性能，并要处理系统的扩展和硬件失效。ceph设计了CRUSH(一个可扩展的伪随机数据分布算法)，用在分布式对象存储系统上，可以有效映射数据对象到存储设备上(不需要中心设备)。因为大型系统的结构式动态变化的，CRUSH能够处理存储设备的添加和移除，并最小化由于存储设备的的添加和移动而导致的数据迁移。
2、简介
对象存储设备(object-based storage devices)管理磁盘数据块的分配，并提供对象的读写接口。在一些对象存储系统中，每个文件的数据被分成多个对象，这些对象分布在整个存储集群中。对象存储系统简化了数据层(把数据块列表换成对象列表，并把低级的数据块分配问题交给各个设备)。对象存储系统的基本问题是如何分布数据到上千个存储设备上。
一个robust解决方案是把数据随机分布到存储设备上，这个方法能够保证负载均衡，保证新旧数据混合在一起。但是简单HASH分布不能有效处理设备数量的变化，导致大量数据迁移。ceph开发了CRUSH（Controoled Replication Under Scalable Hashing），一种伪随机数据分布算法，它能够在层级结构的存储集群中有效的分布对象的副本。CRUSH实现了一种伪随机(确定性)的函数，它的参数是object id或object group id，并返回一组存储设备(用于保存object副本)。CRUSH需要cluster map(描述存储集群的层级结构)、和副本分布策略(rule)。
CRUSH有两个关键优点：
任何组件都可以独立计算出每个object所在的位置(去中心化)。只需要很少的元数据(cluster map)，只要当删除添加设备时，这些元数据才需要改变。 3、CRUSH算法
CRUSH算法通过每个设备的权重来计算数据对象的分布。对象分布是由cluster map和data distribution policy决定的。cluster map描述了可用存储资源和层级结构(比如有多少个机架，每个机架上有多少个服务器，每个服务器上有多少个磁盘)。data distribution policy由placement rules组成。rule决定了每个数据对象有多少个副本，这些副本存储的限制条件(比如3个副本放在不同的机架中)。
CRUSH算出x到一组OSD集合(OSD是对象存储设备)：
(osd0, osd1, osd2 … osdn) = CRUSH(x)
CRUSH利用多参数HASH函数，HASH函数中的参数包括x，使得从x到OSD集合是确定性的和独立的。CRUSH只使用了cluster map、placement rules、x。CRUSH是伪随机算法，相似输入的结果之间没有相关性。
3.1 层级的Cluster map
Cluster map由device和bucket组成，它们都有id和权重值。Bucket可以包含任意数量item。item可以都是的devices或者都是buckets。管理员控制存储设备的权重。权重和存储设备的容量有关。Bucket的权重被定义为它所包含所有item的权重之和。CRUSH基于4种不同的bucket type，每种有不同的选择算法。
3.2 副本分布
副本在存储设备上的分布影响数据的安全。cluster map反应了存储系统的物理结构。CRUSH placement policies决定把对象副本分布在不同的区域(某个区域发生故障时并不会影响其他区域)。每个rule包含一系列操作(用在层级结构上)。
这些操作包括：
tack(a) ：选择一个item，一般是bucket，并返回bucket所包含的所有item。这些item是后续操作的参数，这些item组成向量i。select(n, t)：迭代操作每个item(向量i中的item)，对于每个item(向量i中的item)向下遍历(遍历这个item所包含的item)，都返回n个不同的item(type为t的item)，并把这些item都放到向量i中。select函数会调用c(r, x)函数，这个函数会在每个bucket中伪随机选择一个item。emit：把向量i放到result中。 存储设备有一个确定的类型。每个bucket都有type属性值，用于区分不同的bucket类型(比如”row”、”rack”、”host”等，type可以自定义)。rules可以包含多个take和emit语句块，这样就允许从不同的存储池中选择副本的storage target。
3.3 冲突、故障、超载
select(n, t)操作会循环选择第 r=1,…,n 个副本，r作为选择参数。在这个过程中，假如选择到的item遇到三种情况(冲突，故障，超载)时，CRUSH会拒绝选择这个item，并使用r'(r’和r、出错次数、firstn参数有关)作为选择参数重新选择item。
冲突：这个item已经在向量i中，已被选择。故障：设备发生故障，不能被选择。超载：设备使用容量超过警戒线，没有剩余空间保存数据对象。 故障设备和超载设备会在cluster map上标记(还留在系统中)，这样避免了不必要的数据迁移。
3.4 MAP改变和数据迁移
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f2c0fee3934024f0840ed78057ea7e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f13e9de543d2ad108432ca5fc14eb6/" rel="bookmark">
			Toplogical Sort 拓扑排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Toplogical Sort
拓扑排序是对有向图的顶点的一种排序，它使得如果存在一条从Vm到Vn的路径，那么在排序中Vn出现在Vm后面。
如果图含有圈,或者初始入度没有为０的节点，那么拓扑排序是不可能完成的。
理论介绍去看&lt;DSAA&gt;或者《算法导论》，老话，这里还是介绍如何实现。
tls.h
/************************************************************ code file	: tls.h code writer	: EOF code date	: 2014.11.22 e-mail	: jasonleaster@gmail.com code description: Header file for toplogistic sort. ************************************************************/ #ifndef _TLS_H_ #define _TLS_H_ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define CONNECTED 1 #define DISCONNECTED 0 #define SUCCESS 0 #define FAILED -1 #define EMPTY_QUEUE -1 #define UNEMPTY_QUEUE 0 /* **	We use these macro as index for struct table */ #define KNOW_OFFSET 0 //vertex that have been found #define DIST_OFFSET 1 //distance of vertex #define PATH_OFFSET 2 //parent vertex of current vertex #define FOUND	1 #define NOT_FOUND 0 #define ENTRY_POINT 3 #define INFINITE -1 struct node { struct node* previous; struct node* next; int data; }; struct vertex { int value; int indegree; struct vertex* next; struct vertex* end; }; struct graph { int num_vertex; int num_edge; struct vertex adjacent[0]; }; struct table { int height; int width; int msg[0];//we store message of table in this array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23f13e9de543d2ad108432ca5fc14eb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3654c01b91571e5fb12f2fa2344f23b2/" rel="bookmark">
			centos yum的配置文件 repo文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是repo文件？ repo文件是Fedora中yum源（软件仓库）的配置文件，通常一个repo文件定义了一个或者多个软件仓库的细节内容，例如我们将从哪里下载需要安装或者升级的软件包，repo文件中的设置内容将被yum读取和应用！ YUM的工作原理并不复杂，每一个 RPM软件的头（header）里面都会纪录该软件的依赖关系，那么如果可以将该头的内容纪录下来并且进行分析，可以知道每个软件在安装之前需要额外安装 哪些基础软件。也就是说，在服务器上面先以分析工具将所有的RPM档案进行分析，然后将该分析纪录下来，只要在进行安装或升级时先查询该纪录的文件，就可 以知道所有相关联的软件。所以YUM的基本工作流程如下： 服务器端：在服务器上面存放了所有的RPM软件包，然后以相关的功能去分析每个RPM文件的依赖性关系，将这些数据记录成文件存放在服务器的某特定目录内。 客户端：如果需要安装某个软件时，先下载服务器上面记录的依赖性关系文件(可通过WWW或FTP方式)，通过对服务器端下载的纪录数据进行分析，然后取得所有相关的软件，一次全部下载下来进行安装。 vi /etc/yum.conf [main] cachedir=/var/cache/yum/$basearch/$releasever #cachedir：yum缓存的目录，yum在此存储下载的rpm包和数据库，一般是/var/cache/yum/$basearch/$releasever。
keepcache=1
#keepcache：是否保留缓存内容，0：表示安装后删除软件包，1表示安装后保留软件包
debuglevel=2 #debuglevel：除错级别，0──10,默认是2 貌似只记录安装和删除记录 logfile=/var/log/yum.log pkgpolicy=newest #pkgpolicy： 包的策略。一共有两个选项，newest和last，这个作用是如果你设置了多个repository，而同一软件在不同的repository中同时存 在，yum应该安装哪一个，如果是newest，则yum会安装最新的那个版本。如果是last，则yum会将服务器id以字母表排序，并选择最后的那个 服务器上的软件安装。一般都是选newest。 distroverpkg=centos-release #指定一个软件包，yum会根据这个包判断你的发行版本，默认是redhat-release，也可以是安装的任何针对自己发行版的rpm包。 tolerant=1 #tolerent，也有1和0两个选项，表示yum是否容忍命令行发生与软件包有关的错误，比如你要安装1,2,3三个包，而其中3此前已经安装了，如果你设为1,则yum不会出现错误信息。默认是0。 exactarch=1 #exactarch，有两个选项1和0,代表是否只升级和你安装软件包cpu体系一致的包，如果设为1，则如你安装了一个i386的rpm，则yum不会用1686的包来升级。 retries=20 #retries，网络连接发生错误后的重试次数，如果设为0，则会无限重试。 obsoletes=1 gpgcheck=1 #gpgchkeck= 有1和0两个选择，分别代表是否是否进行gpg校验，如果没有这一项，默认是检查的。 reposdir=/etc/yy.rm #默认是 /etc/yum.repos.d/ 低下的 xx.repo后缀文件 #默认都会被include 进来 也就是说 /etc/yum.repos.d/xx.repo 无论配置文件有多少个 每个里面有多少个[name] 最后其实都被整合到 一个里面看就是了 重复的[name]后面的覆盖前面的 exclude=xxx #exclude 排除某些软件在升级名单之外，可以用通配符，列表中各个项目要用空格隔开，这个对于安装了诸如美化包，中文补丁的朋友特别有用。 keepcache=[1 or 0] #　设置 keepcache=1，yum 在成功安装软件包之后保留缓存的头文件 (headers) 和软件包。默认值为 keepcache=0 不保存 reposdir=[包含 .repo 文件的目录的绝对路径] #　该选项用户指定 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3654c01b91571e5fb12f2fa2344f23b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d81d54970bdf804d99a122265ca265/" rel="bookmark">
			八皇后之回溯法解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
要在8*8的国际象棋棋盘中放8个皇后，使任意两个皇后都不能互相吃掉。规则是皇后能吃掉同一行、同一列、同一对角线的棋子。如下图即是两种方案：
、
解决方案：
8*8的棋盘要摆放8个皇后，且不能同行同列同对角线，那么每行必定会有一个皇后。我们可以设一个数组a用来存放每一行皇后的位置，元素值表示第几列（如a[1]=5表示第一行的皇后处于第五个格）。然后只需要求出数组a的值 问题就解决了，下面介绍三种回溯解法：
1、八个for循环。用枚举的办法，八个for循环分别枚举每一行的8个位置，但是我们不用全部枚举完，可以采用“剪枝策略”，即遇到不适合的情况就回溯。例如当a[1]=4,第二行a[2]=4与a[1]同列，不符合题意。接下来的六个循环就不用穷举下去了，直接"continue;"去检验a[2]=5.....具体代码如下：
void main() { int a[9]; int i,t=1; for(a[1]=1;a[1]&lt;9;a[1]++) for(a[2]=1;a[2]&lt;9;a[2]++) { if(!Check(a,2))	continue; for(a[3]=1;a[3]&lt;9;a[3]++) { if(!Check(a,3))	continue; for(a[4]=1;a[4]&lt;9;a[4]++) { if(!Check(a,4))	continue; for(a[5]=1;a[5]&lt;9;a[5]++) { if(!Check(a,5))	continue; for(a[6]=1;a[6]&lt;9;a[6]++) { if(!Check(a,6))	continue; for(a[7]=1;a[7]&lt;9;a[7]++) { if(!Check(a,7))	continue; for(a[8]=1;a[8]&lt;9;a[8]++) { if(!Check(a,8))	continue; else { printf("第%d种解法：\n",t++); for(i=1;i&lt;9;i++) printf("第%d个皇后：%d\n",i,a[i]); printf("\n\n"); }	}	}	}	}	}	}	}	} /Check函数功能：检验第n行的皇后是否和之前的皇后有冲突，没有的话返回1 int Check(int a[],int n) { for(int i=1;i&lt;n;i++) { if(abs(a[i]-a[n])==abs(i-n) || a[i]==a[n])//见下面注释 return 0; } return 1; } 代码注释：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49d81d54970bdf804d99a122265ca265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab37d73646c81e553c3c64e4fc25cf98/" rel="bookmark">
			51单片机基本组成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		51基本组成如图。
CPU：中央处理器，内含程序计数器PC（Program Count）。开始执行程序时，PC获得第一条指令的地址，每取一条指令PC的值就自动指向下一条指令的地址。单片机复位后PC=0000H，从此处开始执行程序。
数据存储器（内部RAM）：共256个RAM单元，前128个单元（00H~7FH）作为存储器使用，后128个单元被特殊功能寄存器占用。通常所说的内部数据存储器就是指前128个单元，简称内部RAM。
程序存储器（内部ROM）：存储程序、原始数据、表格
特殊功能寄存器（SFR）：特殊的RAM区，80H~FFH，管理片内各部件的控制寄存器和状态寄存器。
并行I/O：P0、P1、P2、P3
串行口：全双工
定时器：两个16位定时器，实现定时和计数，以其结果控制单片机
中断控制系统：5个中断源（外部中断2，定时/计数中断2，串行中断1）
振荡电路：内含振荡电路，外接石英晶体和微调电容即可构成51的时钟电路，系统最高晶振频率12MHz
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f6831d5b766b07b0a308de791de23b/" rel="bookmark">
			机房收费系统之报表篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的说，报表就是用表格、图表等格式来动态显示数据，详细请见这里
作者：九期 昌哥
（一）制作报表
首先打开锐浪报表设计器，界面如下 乍一看，什么都没有啊！不着急，咱们一步一步来DIY自己的报表：
定义报表头
1、插入报表头：执行菜单“插入-〉报表头”，新插入的报表头显示在报表布局窗口中。
2、插入一个静态框显示报表标题：执行菜单“插入-〉静态框”，用鼠标在报表头的显示区域拖放一个矩形区域，一个新的静态框显示在拖放的矩形区域位置。或者利用工具栏中的“静态框“部件手动画上
3、双击新插入的静态框，输入”机房收入日汇总表“作为标题，完成后按回车键，之后选中，利用工具栏上的相关按钮对字体和部件框的位置进行修改
4、调整报表头和静态框的大小。将鼠标放置部件上，对边框进行拖动，调到合适大小。
定义明细网格
1、插入明细网格：执行菜单“插入-〉明细网格”，新插入的明细网格显示在报表布局窗口中。
2、定义数据库连接串与查询SQL：在明细网格的工具栏上选择“数据库连接串与查询SQL”打开定义窗口 下面就到了重头戏上，这个关乎到数据库连接的成败
定义数据库连接串：执行窗口左下角的”创建数据库连接串......“ 然后按照上图中的顺序进行下一步
上图中：①反应比较慢，需要耐心等待，然后填写sql用户名与密码，选择连接的数据库，最后点击：”测试连接“，确定即可。需要说明的是：必须选中”允许保存密码“复选框，否则在其后的连接中会出现错误。
定义查询SQL并检测正确性 ：在查询SQL编辑框中录入“select * from CheckDay_Info”，点击“测试”
3、创建字段：执行菜单“编辑-〉根据查询生成字段”或者选择明细网格工具栏上的此时在右上角的对象浏览窗口的“记录集”节点下会有很多字段子节点。
4、创建列：执行菜单“编辑-〉根据字段生成列”，此时在明细网格上的“字段集合”按钮，会显示很多列
5、调整列宽：将光标移动到列的右边界位置进行拖放
6、改变表格标题的显示文字：按照上图中的提示进行即可
定义页脚显示页号
1、插入页脚：执行菜单“插入-〉页脚”，新插入的页脚会显示在报表布局窗口中。
2、插入一个综合文字框显示打印时间：
插入综合文字框：在部件框工具栏中选择“综合文字矿”，然后在页脚的左边拖放一个矩形，一个综合文字框已经插入。
设置显示内容：在右下位置的属性编辑窗口中选中“文本”行，点击“...”按钮打开文本编辑对话框。在编辑框中输入“打印时间：”。然后执行“插入域”按钮，引用类型选择“系统变量”，系统变量选择“CurrentDateTime”
当然，这个系统时间也可以放到其他具有综合文字框的位置。
然后，可以根据需要添加页眉，操作过程跟页眉相似，在此不再赘述。
查看设计结果
这个过程可以在添加任何部件的时候进行，最后对自己所DIY的报表进行美化，然后就可以大功告成了！ PS：1、该软件的“撤销”和“恢复”功能相当强悍，比VB和Word还牛。当然，最好还是养成一个随时保存的习惯，多按几次Ctrl+S即可。
2、很多操作都是在该软件的“帮助”下完成的。看来“帮助”真的是一款好软件的灵魂啊！这也给自己一个好的提示呢！
（二）vb与报表的交互
首先，安装Grid++Report 5.0报表设计器，具体过程如破解等在此不做涉及。然后打开VB程序，通过“Ctrl+T”快捷键调出“部件”窗口，勾选“Grid++Report Engine5.0 Type Library”,然后在工具箱窗口中会自动添加两个小部件，按照下图鼠标箭头提示在窗体中添加一个GRDisplayViewer1控件：
然后，再添加其他实际所需的控件。本例中实现三个功能：① 刷新 ② 打印 ③ 打印预览。
最后就是添加代码了。显示报表数据的结果如上图，其相关代码如下：
Dim WithEvents Report As grproLibCtl.GridppReport '实例化报表 Private Sub Form_Load() Dim strSQL As String, strMsg As String strSQL = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34f6831d5b766b07b0a308de791de23b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a79808cc251043841ddfda9f209b5229/" rel="bookmark">
			解决arcgis长时间打不开的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 客户的服务器，配置很高，但用一段时间后，启动arcmap很慢很慢。卸载重新安装也不行。 可怜的我，都怀疑到server头上了，把他也卸载了才找到问题所在。 ArcMap打开越来越慢，打开一次要10几分钟~~~ 今天终于找到原因了，原来是 C:\Users\Administrator\AppData\Roaming\ESRI\Desktop10.1\ArcToolbox下 ArcToolbox.dat文件过大了，都300多M了。每次打开ArcMap都去加载这玩意去了。 直接删掉这个文件就OK了。 起因是： 地理处理--地理处理选项--将地理处理操作记录到日志文件中 不勾选这个，也可以解决。 经过多人测试，连关闭慢的问题也解决了！ok，也涨知识了...... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/432f6e58358354d86d75224b3f9a8dce/" rel="bookmark">
			zTree之checkbox选中事件---获取状态改变的结点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zTree 简介
zTree 是一个依靠 jQuery 实现的多功能 “树插件”。优异的性能、灵活的配置、多种功能的组合是 zTree 最大优点。 zTree 是开源免费的软件（MIT 许可证）。如果您对 zTree 感兴趣或者愿意资助 zTree 继续发展下去，可以进行捐助。 主页：http://www.ztree.me
我要实现的是一个基于ztree的树状列表，如下图所示：
各个列表项用checkbox控制，可以选择或取消选择。
通过checkbox控制各个地图图层的显示与隐藏。
实现过程：
照搬demo\cn\excheck\checkbox.html里面的代码
重点一： setting 加上回调函数 zTreeOnCheck，对checkbox的点击进行响应。
重点二： setting.check.chkboxType = { "Y" : "s", "N" : "s" }; Y指的是勾选checkbox的时候对父结点或子结点产生的影响 N指的是取消checkbox的时候对父结点或子结点产生的影响 大小写是有区另的。s指子结点，p指父结点 重点三： zNodes中的数据自行输入，pId控制这个子结点的父结点是哪个。icon可以自定义。
重点四： clearCheckedOldNodes要在onCheck响应函数中执行一遍。 如下是其API中的解释。 （如果需要获取每次操作后全部被改变勾选状态的节点数据，请在每次勾选操作后，遍历所有被改变勾选状态的节点数据，让其 checkedOld = checked 就可以了。） 如果不这样，会出现第2次点击checkbox不产生onCheck的响应。 参见demo\cn\excheck\checkbox_count.html文件。 重点五：得到改变状态的checkbox var zTree = $.fn.zTree.getZTreeObj("treeWaterLayer");//换成实际的图层的id var changedNodes = zTree.getChangeCheckedNodes(); //获取改变的全部结点 for ( var i=0 ; i &lt; changedNodes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/432f6e58358354d86d75224b3f9a8dce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f5790411192b8d978c603099647da85/" rel="bookmark">
			C语言连连看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （1）定义一个矩阵，随机产生字符布置地图，例如下面这个4x4 的地图。 1 2 3 4 B C H C 1 C F B E 2 A E D F 3 C H A D 4 （2）游戏者通过坐标（1，2）、（3，4）判定第一行第二列的字符与第三行第四列的字符是相同的），判定争取则相应位置的字符消失，如判断错误给出相应的错误提示，允许重新判定。 （3）如果找不出配对的字符，提供restart 模式，给现存的地图重新排序。 （4）定义成绩排行榜，记录前五名的用户名及时间。 （5）提供菜单功能，定义不同等级的连连看地图供选择。 （6）设定有时间限定的游戏模式和无时间限定的游戏模式。 （7) 成绩排行榜以文件形式保存。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61407d724dc684048b15dfae89732c25/" rel="bookmark">
			radio、checkbox在使用iCheck后，绑定选中事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用on()方法绑定事件： $('input').on('ifChecked', function(event){ alert(event.type + ' callback'); }); ifCreated 事件应该在插件初始化之前绑定。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27491efe541ba472dafaff28471f6586/" rel="bookmark">
			这么认识递归，你会恍然大悟！如果你已经很透彻理解递归请飘过~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		递归算法概念是函数调用自己来实现的某种功能,按以下方法理解递归你会恍然大悟(如果你对递归有疑惑的话)，并
觉得递归是如此简单：
1.递归是高中数学中的数列那一章讲的内容。数列这章讲了一个概念叫递推公式：如果已知数列的第1项（或前几 项），且从第二项（或某一项）开始的任一An与它的前一项An-1（或前几项）间的关系可以用一个公式来表 示，那么这个公式就叫递推公式，递推公式是给出数列的一种方法。
2.例如斐波那契数列的递推公式就是：An=An-1+An-2（n&gt;2，a1=1，a2=1）
3.那么现在如果想用递归的方式表示斐波那契数列即可定义函数f(n):当n&gt;2时f(n)=f(n-1)+f(n-2);当n=1时f(n)=1，当n=2时f(n)=1;
即private static int fibonacciRe(int i) {
if(i == 1 || i == 2)
return 1;
else if(i&gt;2)
return fibonacciRe(i-1)+fibonacciRe(i-2);
else return 0;
}
4.解释：其实说白了递归函数就是一个递推公式，只要递推公式往纸上一写，把项A替换成函数名字，把n替换成函的 参数即可，最后用if处理一下特殊参数值时的结果值就欧了。
5.总结：我们为什么有些人很难理解递归函数呢，我个人觉得是我们在学计算机语言的时候都是在大学里学的，然后 此时的高中数学知识已经忘却了，取而代之的是我们把我们的大脑陷在了递归方法调用的过程中了，比如，要一 步步该怎么调用了。如果我们要结合高中数学中的这个概念的话就一点也不难理解递归，反倒觉得递归的算法一 眼看去就很明白，我个人以前难于理解递归是因为只要我看到了递归我的脑子就在循环的一层层的往下继续调 用，觉得很难理解，其实我们完全不要去想那一层层的调用关系，反而想到递归就把他抽象出来一个递推公式， 这样你就会恍然大悟的感觉，原来递归如此简单。我们以前不好理解递归是我们自己的给自己制造了理解它的障 碍。觉得理解这个就跟用眼在电脑上看懂三维立体画有异曲同工之妙。现在如果只要给你在纸上写出了一个 递推公式，你立马就可以用递归函数写出来。呵呵。。递归是不是很简单呢？！其实我们的计算机算法都来源于 数学，计算机算法是数学应用于生产的很好的一个例子！
6.附：斐波那契数列的非递归算法，由于递归很耗资源，所以不到迫不得已尽量不要用递归算法
public static int z(int n){
int a=1;
int b=1;
int c=0;
for(int i=3;i&lt;=n;i++){
c=a+b;
a=b;
b=c;
}
return c;
}
7.以上都是个人一己之见，有错误或者不当的，欢迎吐槽！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea160f0f350f81f3469ea8ccc85b9cb/" rel="bookmark">
			解决安装svn后出现Unable to connect to a repository at URL以及&#34;认证失败&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在ubuntu下安装了svn ：（ubuntu安装在虚拟机中）
sudo apt-get install subversion 然后创建了一个库： mkdir /home/lyh/svn cd /home/lyh/svn mkdir store svnadmin create store 然后配置svn： 进入store目录下的conf目录 cd store/conf 然后编辑passwd文件： [users] #harry = harryssecret #sally = sallyssecreta lyh = pass 增加了一个用户lyh 密码为：pass 然后配置 svnserve.conf 文件 anon-access = none auth-access = write password-db = passwd authz-db = authz 然后又在authz配置了： [groups] #harry_and_sally = harry,sally #harry_sally_and_joe = harry,sally,&amp;joe lyh = lyh 新建了一个用户组，有一个lyh的用户 然后启动svn服务： svnserver -d -r /home/lyh/svn/store 在window中通过tortoiseSVN上传一个目录： 结果没有弹出输入用户名和密码的对话框就直接显示： 解决没有弹出输入对话框，打开tortoiseSVN的设置，点击saveddata，点击clear，清除掉里面所有的选项： 如果弹出输入用户名和密码的对话框还是显示这个界面，首先看错误提示，连接不了svn，所以去看看是否配置好了库： 编辑authz文件： [repository:/baz/fuz/store] #@harry_and_sally = rw @lyh = rw 去掉前面的注释，并添加库store 重启svn，首先介绍svn进程 ps -A | grep "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ea160f0f350f81f3469ea8ccc85b9cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d4e81d8d669e344ff6ab223c9e94f9b/" rel="bookmark">
			ArcGIS数据生产与精细化制图之中国年降水量分布图的制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		楼主按：在今年的Esri中国用户大会上，我听了几场关于ArcGIS用于制图方面的讲座，也在体验区与Esri中国的技术老师有一些交流。一直觉得ArcGIS在空间数据管理和分析方面很强大，而在制图方面却表现得不怎么样。我看到在国内很多人制图用的是CorelDraw、AI（可能不仅仅是国内，国外的专业制图也是），诚然这些软件作为专门的图形软件，在很多方面有不可比拟的优势，但是对于地理信息制图来说，图形不能和地理信息相关联却是这些软件最大的软肋。而ArcGIS越来越注重在制图方面的发展与应用，每年举办的制图大赛就是推广之一。
讲座听完了我当然想自己有所实践，于是便产生了此文。本文以中国年降水量分布图的制作为例详细地介绍了数据的获取、预处理、空间降水插值直到最后成图的整个过程。共分为三个部分：
第一部分：底图的制作。这一部分介绍衬托专题图的底图的制作，这一部分的结果还可以作为其它专题图的底图；
第二部分：中国年降水量插值。这一部分介绍用ArcGIS的空间插值方法将气象站点的降水量数据插值得到全国范围内的降水分布；
第三部分：地图整饰。这一部分介绍添加地图要素和美化及最后出图。
所有的步骤都在ArcGIS10/10.1环境下，本文涉及到的数据，以及最后结果（包括本文）都可以在我的网盘(http://pan.baidu.com/share/link?shareid=61512&amp;uk=352462598)中下载。
第一部分：底图的制作 Step1-1：数据准备
（1）先在网上下载中国地图shp格式的文件以及中国省级行政中心的shp文件（网上一搜就有了，不过我还是建议在国家基础地理信息系统(nfgis.nsdi.gov.cn/nfgis/Chinese/c_xz.htm)上下载来保证数据的权威性，不过这个网站经常上不去）；
（2）世界国家图以及河流矢量图。如果大家安装了IDL，那么在IDL的安装目录下：D:\Program Files\ITT\IDL\IDL80\resource\maps\shape（我的IDL安装在D盘），可以找到cntry02.shp和rivers.shp；
以上数据可以从这里下载http://pan.baidu.com/share/link?shareid=54856&amp;uk=352462598
总共包含五个文件：
bou2_4l.shp：中国政区的线文件，在这个线文件里包含了南海的九段线
bou2_4p.shp：中国政区的面文件
rivers.shp：世界主要河流
cntry02.shp：世界国家面文件
省会城市.shp：中国省会城市点文件
注意：ITT提供的两个文件没有设置坐标系，需要先在Catalog中将这两个文件（rivers.shp和cntry02.shp）的地理坐标系设为WGS84。
Step1-2：设置投影
打开ArcMap将这些文件添加进去，接下来我们要给Dataframe设置一个投影坐标系。由于我们要做的是中国全国的降水量分布，我们使用等面积的Albers投影。右击Layers-&gt;Properties-&gt;Coordinate System选项卡-&gt;newProject System，选择Albers，设置中央经线105，标准纬线25度，47度，在地理坐标系中选择WGS84。设置如图：
Step 1-3：放大图我们可以看到，沿海一带有很多面积很小的岛屿，为了制图的美观，我们需要删掉一些面积小的岛屿，但是在这之前，我们必需把南海诸岛以及台湾周围的岛屿保留下来（原因大家都懂的）。
关闭其它图层（只留下政区图层bou2_4p），开始编辑进入编辑状态，选中南海的那些岛屿以及台湾周边岛屿，如图：
在bou2_4p图层上右击选择Selection-&gt;Create Layer From Selected Features。将选中的要素创建一个新的图层。
停止编辑，在刚刚产生的图层上右击选择Data-&gt;Export Data…，将选择的要素导出，命名为“南海诸岛及其它岛屿.shp”。
接下来我们就可以删掉面积小的岛屿了。继续进入编辑状态，打开bou2_4p的属性表，打开Select by Attribute对话框，输入"AREA"&lt; 0.01，点击apply，选中面积为小于0.01的多边形，删除。
Step1-4: 提取出中国的轮廓线
接下来我们要从政区文件(bou2_4p)中提取出中国的轮廓线。这一步的目的是我们要分开中国在陆地上的国界和在海岸线上的国界，因为这两者在制图的时候是不同的。之所不直接用政区线文件提取轮廓是因为经过一些处理以后用面文件提取会更方便（下面会细说）；而不用IDL中的国家(cntry02)是因为ITT提供的世界图是他们所认为的世界图（对比一下中国的藏南地区就会发现，在这个世界图上，中国的藏南地区是直接划给印度的，所以我们不用它，只把它作为底图）。
打开Toolbox-&gt;Data Management Tools-&gt;Features-&gt;Polygon to Line，将输出文件命名为“中国线.shp”。确保”Identifyand store polygon neighboring information(optional)”选中（保留每条线段两边的多边形信息是下一步提取轮廓线的关键；另外，Feature to Line也能实现面转线的功能，但是没有选项）。
打开“中国线.shp”属性表，选中LEFT_FID=-1或者RIGHT_FID=-1的所有要素，这个时候边界上的所有线要素就被选中了。如前所述的方法，将选中的要素创建图层，并导出成单独的图层，命名为“中国轮廓线.shp”。
Step1-5：提取陆上国界和海上国界
新建一个点文件（坐标系设为WGS84），进入编辑状态。在辽宁与朝鲜的入海口处、广西与越南的入海口处创建两个点，保存并停止编辑。
使用Toolbox-&gt;Data Management Tools-&gt;Features-&gt;Split Line atPoint工具，将线在点处打段。并且在编辑状态下，用Merge工具将两部分分别合并在一起；并新建一个字段用以区分陆上国界和海上国界。
Step1-6：提取出九段线
这一步我们从中国政区的线文件（bou2_4l）中提取出九段线。名称是叫九段线，但是实际上在现在地图出版物中都是10段的。这一步比较简单，在编辑状态下选出这10段线，导出成单独的文件，命名为“九段线.shp”。
到目前为止，我们已经整理出来我们的底图所需要的要素文件：
省会城市（点）
九段线（线）
中国轮廓线（线）
河流（线）
南海诸岛及其它岛屿（面）
中国政区（面）
国家（面）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d4e81d8d669e344ff6ab223c9e94f9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7110b6821e3f0add282f49b4211ac2cc/" rel="bookmark">
			Lua 学习笔记（4） -- 模块与包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。
创建模块
其实 Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。格式如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- 定义一个名为 module 的模块 module = {} -- 定义一个常量 module.constant = "this is a constant" -- 定义一个函数 function module.func1() io.write ( "this is a public function!\n" ) end local function func2() print ( "this is a private function!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7110b6821e3f0add282f49b4211ac2cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0b903cfb492bfcc02c6e741835af167/" rel="bookmark">
			lua编程 全局变量 环境 模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.全局变量与环境
lua中真正存储全局变量的地方不是在_G里面，而是在setfenv（i,table）的table中，所有当前的全局变量都在这里面找，只不过在程序开始时lua会默认先设置一个变量
_G=这个里面的table而已。所以在新设置环境后，如果还想找到之前的全局变量，通常需要附加上为新的table设置元表{_index=_G}
下面的几个例子：
a=1
print(a)
print(_G.a)
--正常情况，输出1,1
a=1
setfenv(1,{})
print(a)
print(_G.a)
--这时会出错说找不到print，因为当前的全局变量表示空的，啥也找不到的
a=1
setfenv(1,{_G=_G})
_G.print(_G.a)
print(a)
--这时_G.print(_G.a)可以正常吗，因为可以在新的table中找到一个叫_G的表，这个_G有之前的奈尔全局变量，但是下面的print(a)则找不到print，因为当前的table{_G=_G}没有一个叫print的东西
local mt={__index=_G}
local t={}
setmetatable(t,mt)
setfenv(1,t)
print(a)
print(_G.a)
--这是正确输出，因为新的全局表采用之前的表做找不到时的索引，原先的表里面存在print 、_G、 a这些东西
setfenv的第一个参数可以是当前的堆栈层次，如1代表当前代码块，2表调用当前的上一层，也可以是具体的那个函数名，表示在那个函数里。
每个新创建的函数都将继承创建它的那个函数的全局环境
2.require
require的意义就是导入一堆可用的名称，这些名称（非local的）都包含在一个table中，这个table再被包含在当前的全局表（“通常的那个_G”）中，这样访问一个模块中的变量就可以使用_G.table.**了，（刚开始学习lua时还以为模块里的名称在导入后直接就是在_G中的）
a=require("")的a取决于这个导入的文件的返回值，没有返回值时true，所以在标准的情况下模块的结尾应该return这个模块的名字，这样a就是这个模块的table了（当然不这样做也ok，只是a就不是这个模块名了）
本文出自：http://blog.csdn.net/leonwei/article/details/7739930
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8575dd6048b1139d4f8d2347b852a2ac/" rel="bookmark">
			PC机安装Qt以及QT交叉编译环境                                                    分类：            OpenCV          ...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PC： apt-get install qtcreator Qt Embedded for ZedBoard: 下载qt-everywhere-opensource-src-4.7.3.tar.gz，这里下载源码和Xilinx公司提供的Zynq的Qt配置文件qmake.conf，感谢别人的分享，这个的版本是4.7.3。 之前我们已经配置好了交叉编译环境使用的环境变量PATH和 CROSS_COMPILE,为了方便操作，还可以在设置如下几个环境变量。
export ZYNQ_QT_BUILD=/opt/zedboard/qt/build
export ZYNQ_QT_INSTALL=/opt/zedboard/qt/install
export PATH=$ZYNQ_QT_INSTALL/bin:$PATH
将源码包复制到build文件夹下面，并且解压：
cp /media/6EDC167CDC163F31/for\ ubuntu/QT/qt-everywhere-opensource-src-4.7.3.tar.gz /root/qt/build/
tar xf qt-everywhere-opensource-src-4.7.3.tar.gz
将qmake.conf复制到qt-everywhere-opensource-src-4.7.3/mkspecs/qws/linux-arm-gnueabi-g++目录下：
cp /media/6EDC167CDC163F31/for\ ubuntu/QT/qmake.conf qt-everywhere-opensource-src-4.7.3/mkspecs/qws/linux-arm-gnueabi-g++/
然后对QT进行配置，配置文件如下： ./configure \ -embedded arm \ -xplatform qws/linux-arm-gnueabi-g++ \ -little-endian \ -opensource \ -host-little-endian \ -confirm-license \ -nomake demos \ -nomake examples \ -prefix $ZYNQ_QT_INSTALL 其中-prefix $ZYNQ_QT_INSTALL是告诉系统，安装的路径在哪的
配置完成后进行编译： make 编译好了就可以进行安装（安装需要在root权限下进行，rainysky进入系统的时候就是root权限，这样很方便）： make install 焦急的等了快半个小时，终于编译完成了。在install文件夹下面，就是安装的文件。 之后将Xilinx交叉编译器中的基础C++库复制到安装目录的lib目录下： cp -P /path/to/cross/compiler/arm-xilinx-linux-gnueabi/libc/usr/lib/libstdc++.so* \
/usr/local/Trolltech/Qt-4.7.3/lib/ 这样就完成了Zynq的Qt Embedded for Linux的安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8575dd6048b1139d4f8d2347b852a2ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24725bb13e3f52ee585c5fdf74ce4dc2/" rel="bookmark">
			Matlab 三维视图的自动旋转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 figure plot3(...); xlabel('X轴'); ylabel('Y轴'); zlabel('Z轴'); title('标题'); grid on %打开网格 for i=1:2:360 %view(a,b):a是角度，b是仰视角 view(i,20); pause(0.06); end 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91b44971743f01237367cebe3c656b90/" rel="bookmark">
			android:descendantFocusability——父容器和子控件的焦点获取问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中会遇到这样的问题：自定义ListView的Item时，会出现点击每一项Item没有任何反应。我们重新来看一下自己定义的Item布局文件，一般这个时候自定义的Item布局文件中都会出现类似于Button、ImageButton、CheckBox等子控件。而这些子控件率先获取了ListView的Item的焦点，使得我们点击ListView的每一项Item的时候，就出现了点击哪一项都没有反应的情况。
我们来看Android官方文档是怎么给出解决方案的：
public static final int descendantFocusability Added in API level 1 Defines the relationship between the ViewGroup and its descendants when looking for a View to take focus.
Must be one of the following constant values.
Constant Value Description beforeDescendants 0 The ViewGroup will get focus before any of its descendants. afterDescendants 1 The ViewGroup will get focus only if none of its descendants want it. blocksDescendants 2 The ViewGroup will block its descendants from receiving focus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91b44971743f01237367cebe3c656b90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bbbc623b0a31e050f3439d811ab8766/" rel="bookmark">
			Arduino的详细介绍（基于Mega2560）（分文）——PWM的analogWrite()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arduino的PWM是我写Arduino系列博文的根本原因，因而肯定会更加详细地介绍。
一：PWM的介绍：
PWM是一种调制方式，那么为什么会有这种方式存在？大家可能知道Arduino有模拟输入引脚，这些引脚是通过A/D转换操作的，而一般的数字引脚却只能输入HIGH或LOW电平，那么中间电平可否输出呢？比如2v的电平如何输出？于是PWM应运而生。PWM的高明之处在于：它输出的仍然是HIGH或者LOW电平，但可以间歇性周期性输出，则利用取平均值的方法，可以达到满意的输出效果。一个简单的例子：在0~5s内输出5v的电平，那么0~5s的平均电压就是5v，而倘若我在0~2.5s输出5v，在2.5~5s输出0v（占空比50%），那么这5s内平均电平就是2.5v，显然可以达到我们想要的效果。但仍有问题：倘若你的周期很长，就像上面例子所说，周期5s，点亮一个LED灯（LOW亮，HIGH灭），那么LED灯显然是前2.5s灭，后2.5s亮，显然达不到调灯暗亮的效果。但当周期被缩小之后比如20ms，这时候亮与灭只是很短时间内的事，肉眼根本看不到亮灭的变化，因而LED灯表现的就是亮度变暗。于是我们知道：PWM调制的周期一般比较短。PWM只是用数字输出替代模拟量输出，因此单方面还是不行的，这就要求我们的设备还要支持PWM的调制。（比如舵机等）。因而PWM的周期也不能任意短，还需要满足我们设备的调制要求。
我这里只是非常通俗的理解，如果还有疑问请查阅相关资料。
二：analogWrite()
功能：
analogWrite()实现对引脚设置PWM的要求。可以被用来控制LED等，电机转动，舵机等。使用此函数后，引脚会产生稳定的方波，直到下一次对引脚做其他操作。大多数引脚的PWM频率大约为490Hz。在Uno以及相似的板子上，pin5和pin6有大约980Hz的频率。Leonardo板子的pin3和pin11也有980Hz的频率。
在大多数的Arduino板子上（用ATmega168或者ATmega328的板子），在引脚3,5,6,9,10和11有PWM功能；在Arduino Mega板子上，在2~13和44~46引脚有PWM功能。使用ATmega8的老板子只在9，10和11引脚支持analogWrite（）。
Arduino Due板子在2到13引脚和DAC0，DAC1引脚支持analogWrite（）。但是ADC0和DAC1是采用D/A转换的方式输出，它们确实输出的是模拟量而不是由PWM调制输出的。
另外，使用analogWrite（）不需要再用pinMode（）设置引脚为输出。
形式：
analogWrite（pin,value）
参数：
pin：写入的引脚；
value：占空比，在0~255之间。（0时候为关，即LOW；255为开，即HIGH）
返回值:none
注：5pin和6pin产生的PWM输出会比设置的占空比高，这是因为millis（）和delay（）函数与它们使用相同的内部时钟。
示例：
int ledPin = 9; // LED connected to digital pin 9 int analogPin = 3; // potentiometer connected to analog pin 3 int val = 0; // variable to store the read value void setup() { pinMode(ledPin, OUTPUT); // sets the pin as output } void loop() { val = analogRead(analogPin); // read the input pin analogWrite(ledPin, val / 4); // analogRead values go from 0 to 1023, analogWrite values from 0 to 255 } 现在我们来看看为何Servo库detach时候要连9或10pin。首先舵机需要20ms的控制周期，可见9，10脚在使用Servo库的时候其引脚PWM频率应该大概为1/0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bbbc623b0a31e050f3439d811ab8766/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a560df802f36798b724f0cd5806a873/" rel="bookmark">
			Arduino的详细介绍（基于Mega2560）（分文）——外部中断attachInterrupt()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		External Interrupts（外部中断）: 2 (interrupt 0), 3 (interrupt 1), 18 (interrupt 5), 19 (interrupt 4), 20 (interrupt 3), 21 (interrupt 2)。
函数：
attachInterrupt()：
功能：为中断发生时指定特定名称的中断服务程序。本函数可替代先前的任何中断功能。下图是各板子的中断介绍：
Boardint.0int.1int.2int.3int.4int.5Uno, Ethernet23 Mega25602321201918Leonardo32017 Due (see below) Due板子有强大的中断功能，使你可以在任何可获得的端口定义中断功能。你可以使用 attachInterrupt()函数直接指定引脚号。 形式：attachInterrupt(interrupt, ISR, mode)
attachInterrupt(pin, ISR, mode) (只在Arduino Due板子上是这种形式)
参数：
interrupt: 中断号 (int)；
pin:中断引脚(只在Arduino Due板子上要用，其他板子已经指定好了各中断的引脚)；
ISR: 中断发生时的中断服务程序。这个函数必须没有参数没有返回值；
mode:定义中断触发类型，有四种形式：
LOW：低电平触发；
CHANGE：电平变化触发；
RISING ：上升沿触发（由LOW变为HIGH）；
FALLING：下降沿触发（由HIGH变为LOW）； Due板子还支持高电平触发。
返回值：none；
示例：
int pin = 13; volatile int state = LOW; void setup() { pinMode(pin, OUTPUT); attachInterrupt(0, blink, CHANGE); } void loop() { digitalWrite(pin, state); } void blink() { state = !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a560df802f36798b724f0cd5806a873/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526733cd99dabe10ae0f9d72c9b82455/" rel="bookmark">
			shell date -d 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shell 的date命令在脚本中很常用，但是有一个知识点大家都知道，
date -d "$1 1 days ago" +%Y%m%d和date -d "$1 -1 days" +%Y%m%d是一样的，
这个是有局限性的，当第一个参数是YYYY-mm-dd时是一样的，但是第一个参数如果是“YYYY-mm-dd hh:MM”时这个就不一样啦……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a5163b745b5e96e8bd7cf9d1f545ba3/" rel="bookmark">
			popwindow显示后，点击返回键等不响应解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人最近遇到一个问题，显示导入文件，弹出pop后，点击返回键等键，pop不消失。
方法如下：popwindow中嵌套的View获取了焦点，所以设置view的setOnKeyListener方法：
view.setOnKeyListener(new OnKeyListener() {
@Override
public boolean onKey(View arg0, int arg1, KeyEvent arg2) {
// TODO Auto-generated method stub
if ((arg1 == KeyEvent.KEYCODE_BACK)
&amp;&amp; (popWin != null &amp;&amp; popWin.isShowing())) {
popWin.dismiss();// 点击返回键的popWin退出就行
return true;
}
return false;
}
});
之前参照其他人的方法：(但没有起作用)
（1）设置pop.等属性，但是没有起作用：
pop.setBackgroundDrawable(new BitmapDrawable()); /*设置触摸外面时消失*/ pop.setOutsideTouchable(true); pop.setFocusable(true);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6851470d1091c2f0cd4e5c42abd820f/" rel="bookmark">
			mac下erlang环境rebar（学海无涯）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写下来作记录等下次不用这么麻烦，不做深入研究只做了解erlang：（学海无涯）
(1) 下载erlang源码编译：地址http://www.erlang.org----&gt;./configure ---&gt;make ---&gt;make install 注意：如果看到crypto ，ssl等找不到就是缺少OpenSSl
解决：1.安装OpenSSl http://www.openssl.org/source/ 2.http://stackoverflow.com/questions/4742184/rebar-error-exit-on-create-app-crypto-start
3.http://www.sjsjw.com/kf_code/article/032953ABA020336.asp (2).安装rebar git clone git://github.com/rebar/rebar.git
cd rebar ./bootstrap 参考： http://dhq.me/build-compile-eunit-release-erlang-application-with-rebar
http://diaocow.iteye.com/blog/1776413
http://www.cnblogs.com/panfeng412/archive/2011/08/14/2137990.html --reabr基本操作：
1.创建：rebar create-app appid=名字 2.创建一个gen_server模板： rebar create template=simplesrv srvid=模板名字 （名字_server）
3.编译应用：rebar compile
4.清除: rebar clean
5.使用生产文档：rebar doc
6.eunit 测试。。。。。
7.发布：（1）在应用根目录下创建一个名为 rel 的文件夹，用来作为应用发布的文件夹：
mkdir -p rel cd rel
（2） 修改 rel/reltool.config 里的 lib_dirs 的值，默认是一个空列表 "[]"，改为应用所在的目录路径 '["../../"]'，不然到后面编译发布时会报 "Missing application directory" 的错误出来，修改后的 reltool.config 配置内容--》{lib_dirs, ["../../"]}, （3）返回应用的根目录，在 rebar.config 加上以下一行，把新建的 rel 文件夹放入到 rebar 可访问的子文件夹里，作为应用内容发布文件夹： {sub_dirs, ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6851470d1091c2f0cd4e5c42abd820f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f1c76cd5de784fc7b55164af4552d24/" rel="bookmark">
			java.lang.NoSuchMethodError: method &lt;init&gt;()V not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误：
java.lang.NoSuchMethodError: Graph: method &lt;init&gt;()V not found 原因：
一般是在函数中构造函数不完整
解决：
构造函数除了有参构造函数还有重写一个无参构造函数。如：
public User(String name,int age){ this.name = name ; this.age = age; } public User()	{ } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb3b04240e0994ee941990cb79c76e69/" rel="bookmark">
			C# 保留两位小数并实现千分位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做个页面需要在文本框显示金额，让其显示成千分位，保留两位小数。
代码如下：
decimal de=1235.1234 de = String.Format("{0:N2}",de); 显示结果为1,234.12
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c75e6f6eccdcbe62ab3788c30da20592/" rel="bookmark">
			iOS   图形编程总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IOS实现图形编程可以使用三种API（UIKIT、Core Graphics、OpenGL ES及GLKit）。
这些api包含的绘制操作都在一个图形环境中进行绘制。一个图形环境包含绘制参数和所有的绘制需要的设备特定信息，包括屏幕图形环境、offscreen 位图环境 和PDF图形环境，用来在屏幕表面、一个位图或一个pdf 文件中进行图形和图像绘制。在屏幕图形环境中进行的绘制限定于在一个UIView 类或其子类的实例中绘制，并直接在屏幕显示，在offscreen 位图 或 PDF图形环境中进行的绘制不直接在屏幕上显示。
1 、UIKIT API
UIKIT是一组Objective-C API，为线条图形、Quartz图像和颜色操作提供Objective-C 封装，并提供2D绘制、图像处理及用户接口级别的动画。
UIKIT包括UIBezierPath（绘制线、角度、椭圆及其它图形）、UIImage（显示图像）、UIColor（颜色操作）、UIFont和UIScreen（提供字体和屏幕信息）等类以及在位图图形环境、PDF图形环境上进行绘制和 操作的功能等, 也提供对标准视图的支持，也提供对打印功能的支持。
在UIKIT中UIView类本身在绘制时自动创建一个图形环境（对应Core Graphics层的CGContext类型）作为当前的图形绘制环境。在绘制时可以调用UIGraphicsGetCurrentContext 函数获得当前的图形环境。
2 、Core Graphics 与Quartz 2D API
Core Graphics是一套C-based API， 支持向量图形，线、形状、图案、路径、剃度、位图图像和pdf 内容的绘制。
Quartz 2D 是Core Graphics中的2D 绘制呈现引擎。Quartz是资源和设备无关的,提供路径绘制，anti-aliased呈现，剃度填充图案，图像，透明绘制和透明层、遮蔽和阴影、颜色管理，坐标转换，字体、offscreen呈现、pdf文档创建、显示和分析等功能。
Quartz 2D能够与所有的图形和动画技术（如Core Animation, OpenGL ES, 和 UIKit 等）一起使用。
Quartz采用paint模式进行绘制。
Quartz 中使用的图形环境也由一个类CGContext表示。
在Quartz 中可以把一个图形环境作为一个绘制目标。当使用Quartz 进行绘制时，所有设备特定的特性被包含在你使用的特定类型的图形环境中，因此通过给相同的图像操作函数提供不同的图像环境你就能够画相同的图像到不同的设备上，因此做到了图像绘制的设备无关性。
Quartz 为应用提供如下几个图形环境：
1）位图图形环境，用来创建一个位图。
使用函数CGBitmapContextCreate来创建。
2）PDF图形环境，用来创建一个pdf文件。
Quartz 2D API提供了两个函数来创建一个PDF图形环境：
CGPDFContextCreateWithURL，带有一个作为pdf 输出的位置的Core Foundation URL来创建一个pdf 图形环境。
CGPDFContextCreate, 当想PDF 输出到一个data consumer时使用该函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c75e6f6eccdcbe62ab3788c30da20592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7c6c09893edc80729f7b3eb9bfe6b1b/" rel="bookmark">
			面试题：赛马问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		据说，这是Google的面试题。面试题目如下：
一共有25匹马，有一个赛场，赛场有5个赛道，就是说最多同时可以有5匹马一起比赛。假设每匹马都跑的很稳定，不用任何其他工具，只通过马与马之间的比赛，试问，最少得比多少场才能知道跑得最快的5匹马？（不能使用撞大运的算法）
很明显这是一个算法题，网上有很多贴子在讨论这个问题，不过都没有给出一个明确的答案。我想了想，想到下面的一个算法：
1）分成5组A，B，C，D，E，比五场。然后根据每场结果分别给这五组内的五匹马排序（从快到慢）。
2）每组的头名再赛一场，取走第一名，然后该组第二名顶上。
3）重复第二步，直到选出前5名。
这个算法是比较笨的算法，总计需要赛10次，这个算法应该是万无一失的。现在的问题的就，如何优化这个算法，想了想，的确是有优化的空间的。也就是说，是可以少于10次的。
想了一想，上面的那个算法自从第6次开始就使用5个排序数组的头名做“冒泡法”，总是挑一个最优秀的出来，其实，在第6次以后除了挑出最优秀的，我们还可以在每次比赛后淘汰一些速度不行的，淘汰的马匹数自然会比选出的更多，所以，一方面在找，另一方面在淘汰，找出前5名的速度应该会更快。
比如：我们假设比赛完第六场后，我们得到下面的排序：（每组排序是——快马从左到右，各组头名的排序是——快马从上到下）
A组 A1 A2 A3 A4 A5
B组 B1 B2 B3 B4 B5
C组 C1 C2 C3 C4 C5
D组 D1 D2 D3 D4 D5
E组 E1 E2 E3 E4 E5
这样，我们不但知道，A1是25匹马里最快的马，而且我们可以淘汰近一半的马，比如E2，E3，E4，E5就可以全部淘汰了，为什么呢，因为比E2快的马有A1,B1,C1,D1,E1这五匹马，所以，E2后面的马是无法进入前五名了；同理，D3和其后面的也进入不了前5；同理，C4，C5，B5都可以淘汰。
于是，在第六轮后我们可以得知，除了A1外的Top 4必然在下面这些马中：
A组 A2 A3 A4 A5
B组 B1 B2 B3 B4 C组 C1 C2 C3 D组 D1 D2 E组 E1
接下来的过程应该不必我多说了。重复前面的方法，尽可能淘汰无法进前N名的马，于是后面的马就越来越少，你所需要的比赛也会越来越少。
那么，对于这个题，聪明的你知道最少要比赛几场了吗？
举一反三，如果有64匹马，8个赛道呢？不失一般性，如果有N匹马，M个赛道呢？N = M*M，那么公式是什么呢？
期待你的答案！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb6c0b613284e395cb3f2920753bc4a0/" rel="bookmark">
			Java中跳出for循环的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在介绍一下在Java中，如果想跳出for循环，一般情况下有两种方法：break和continue。
break是跳出当前for循环，如下面代码所示：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
public class RecTest { /**
* @param args
*/ public static void main(String[] args) { for(int i=0; i&lt; 10; i++){ if(i==5){ break; } System.out.print(i+" "); } } } 输出：0 1 2 3 4
也就是说，break会跳出（终止）当前循环。continue是跳出当前循环，开始下一循环，如下所示：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb6c0b613284e395cb3f2920753bc4a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a4da94693e652877f437c5fdeb34ed4/" rel="bookmark">
			Android中Intent详解(二)之使用Intent广播事件及Broadcast Receiver简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过第一篇的讲解，我们已经看到了如何使用Intent来启动新的应用程序组件，但是实际上他们也可以使用sendBroadcast方法来在组件间匿名的广播消息。
作为一个系统级别的消息传递机制，Intent可以在进程之间发送结构化的消息。因此，通过实现Broadcast Receiver来监听和响应应用程序内的这些Broadcast Intent。
通过使用Intent来广播一个事件，可以在不修改原始的应用程序的情况下，让我们开发人员对事件做出反应。Android大量使用了Broadcast Receiver来广播系统事件，如网络连接和短信通知等。
1.使用Intent来广播事件
在应用程序组件中，可以构建希望广播的Intent，然后使用sendBroadcast方法来发送它。
可以对Intent的动作、数据和分类进行设置，从而使Broadcast Receiver能够精确的确定他们的需求。在这种方案中，Intent动作字符串可以用来标识要广播的事件，所以他应该是能够标识事件的唯一的字符串。习惯上，动作字符串使用与Java包名相同的构建方式，如下：
&lt;span style="font-size:14px;"&gt;public static final String MY_INTENT_ACTION = "com.happy.demo.test";&lt;/span&gt; 如果希望在Intent中包含数据，那么可以使用Intent的data属性指定一个URI，也可可以包含extras来添加额外的基本值。
2.使用Broadcast Receiver来监听广播
Broadcast Receiver可以用来监听Broadcast Intent，但是需要对其进行注册，既可以使用代码方式来注册，也可以在应用程序的manifest.xml文件中进行注册，不管采用哪种方式，都需要使用一个Intent Filter来指定他要监听哪些Intent和数据。
对于包含在manifest.xml文件中的广播接收者 ，在Intent被广播出去的时候，应用程序不一定非要处于运行状态才能接收，他们会被自动的启动。
创建一个新的Broadcast Receiver，需要扩展Broadcast Receiver类并重写onReceive方法来进行自己的处理。比如：
&lt;span style="font-size:14px;"&gt;package com.happy.demo; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; public class MyBroadcastReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub } } &lt;/span&gt; 当接收到一个与在注册接收器时使用的IntentFilter相匹配的Broadcast Intent的时候，就会执行onReceive方法。onReceive处理程序必须要在5秒钟以内完成，否则会显示Force Close对话框。 一般情况下，Broadcast Receiver将会更新内容、启动Service、更新Activity UI或者使用Notification Manager来通知用户。
3.在代码中注册Broadcast Receiver
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a4da94693e652877f437c5fdeb34ed4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c76d4fad2f6d85ec7a5003b20699f0f/" rel="bookmark">
			光电耦合器简介以及作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		光电耦合器(简称光耦)全称为光电耦合器接口电路，是一种把发光元件和光敏元件封装在同一壳体内，中间通过电→光→电的转换来传输电信号的半导体光电子器件。
光电耦合器可根 据不同要求，由不同种类的发光元件和光敏元件组合成许多系列的光电耦合器。目前应用最广的是发光二极管和光敏三极管组合成的光电耦合器。 光耦以光信号为媒介来实现电信号的耦合与传递，输入与输出在电气上完全隔离，具有抗干扰性能强的特点。对于既包括弱电控制部分，又包括强电控制部分的工业 应用测控系统，采用光耦隔离可以很好地实现弱电和强电的隔离，达到抗干扰目的。但是，使用光耦隔离需要考虑以下几个问题： ① 光耦直接用于隔离传输模拟量时，要考虑光耦的非线性问题； ② 光耦隔离传输数字量时，要考虑光耦的响应速度问题； ③ 如果输出有功率要求的话，还得考虑光耦的功率接口设计问题。
学习笔记：光耦的主要作用就是隔离作用，如信号隔离或光电的隔离。隔离能起到保护的作用，如一边是微处理器控制电路，另一边是高电压执行端，如市电启动的电机，电灯等等，就可以用光耦隔离开。当两个不同型号的光耦只有负载电流不同时，可以用大负载电流的光耦代替小负载电流的光耦。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/557/">«</a>
	<span class="pagination__item pagination__item--current">558/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/559/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>