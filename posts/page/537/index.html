<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4835af47f63391886201c29b56587f59/" rel="bookmark">
			操作系统之处理机管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		处理机管理可归结为对进程的管理。
为什么需要进程？ 在单道程序系统中，程序只能够顺序的执行，即两个程序只能等一个执行完再执行下一个。这样就使程序的执行具有三个特型：顺序性、封闭性和可再现性。而到了多道程序系统中，允许程序并发的执行（宏观并行，微观串行）。此时程序并发执行就具有了：间断性、失去封闭性和不可再现性。为了解决程序并发执行的问题，并且可以对并发执行的程序加以描述和控制，人们就引入了进程的概念。
什么是进程？ 进程是程序的一次执行，是资源分配和调度的基本单位。进程 = 程序 + 数据 + 程序控制块(Process Control Block，PCB)。
PCB是进程最重要的数据结构，是进程存在的唯一标识。PCB中记录了系统所需的，用于描述进程的当前情况一起管理进程运行的全部信息。OS通过PCB就能够很好的控制进程。PCB中的记录的内容大致为：进程标识符、处理机状态、进程调度信息、进程控制信息。
进程的管理下面几个方面：
进程控制进程同步进程通信进程调度 进程的状态 就绪状态——进程所需要的资源都已经到位，只需要等待处理机调度
运行状态——进程获得处理机，正在执行
阻塞状态——进程等待某些事件的发生才能继续执行，所以不再占用处理机而转为阻塞状态
进程的三态图和五态图如下：
进程控制 进程的控制主要包括创建进程、撤销进程以及进程的状态转换。进程控制一般有OS的内核通过原语来实现。
内核(Kernel)：一些常驻内存，存在于紧靠硬件的软件层次中的模块的集合。例如中断处理程序、常用设备驱动程序及运行频率较高的模块（时钟管理、进程调度这些）。
内核一般都包含了支撑功能（中断处理、时钟管理和原语操作）以及资源管理功能（进程、存储器和设备的管理）。
原语——由若干条指令组成的，用于完成一定功能的一个过程。或者说是系统态下执行的某些具有特定功能的程序段。原语操作是一种“原子操作”，就是不可分的意思。即一个操作中的所有动作要么全做，要么全不做。
阻塞和唤醒的原语分别是 block 和 wakeup。挂机和激活的原语是 suspend 和 active 。
进程同步 进程同步机制的主要任务，是对多个相关进程在执行次序上进行协调，是并发执行的进程能按一定的规则（或时序）共享系统资源，并能很好的相互合作，从而使程序的执行具有可再现性。
进程之间的制约：
直接制约——共享缓冲区 同步
间接制约——互斥资源 互斥 临界区：进程中访问临界资源的代码。
进程必须互斥地进入自己的临界区，系统为此设置了专门的同步机构来协调。同步机制需要遵循十六字真言：空闲让进、忙则等待、有限等待、让权等待。
1965年Dijkstra提出信号量（Semaphores）机制是一种卓有成效的进程同步工具，这个机制有几种发展产物。我们通常使用记录型信号量。
记录型信号量只是在整形信号量的基础上增加了将进程阻塞和唤醒的操作，这样符合“让权等待”的规则。
信号量S是一个表示资源数目的东西，只有在wait(S)和signal(S)这两个原子操作中才能够修改，这就保护了信号量不被其它地方随意改变。这两个操作又称为PV操作。
P操作就相当于在访问资源之前，先对代表该资源的信号量进行判断，如果有就访问，没有的话该进程就被阻塞等待。
V操作就是在访问资源之后，释放一个资源，并唤醒一个等待该资源的进程。
信号量机制实现前驱图也经常考到，但很简单。对于前驱图中一个结点，有多少个箭头指向它，则在执行本身程序之前必须先进行多少次 P 操作来等待所有资源。有多少个箭头从它指出去，在本身程序执行后就要进行多少次 V 操作释放资源。
信号量机制实现互斥： 为临界资源设置一互斥信号量mutex，初始值为1。每个进程在进入临界区之前都要对该信号量进行P操作，判断mutex的值，如果为1则表示没有其它进程正在访问该资源，现在可以访问；如果为0则表示当前有进程在访问该资源必须等待。这就相当于用一个标识符给临界区上了锁，实现了互斥访问。
信号量机制实现同步： 两个进程共享缓冲池，想象生产者和消费者的问题。设缓冲池具有的可用空间为n，要为该缓冲池设置3个信号量，一个是互斥访问信号量S，初始值为1。一个是S1，初始值为n，表示缓冲池可用空间数。另一个是S2，初始值为0，表示缓冲池中已满空间数（相当于已有产品数）。在这个条件下：
对于生产者进程，在将产品放入到缓冲池（访问）之前必须先对 S1 进行 P操作，判断 S1 的值，如果不为0，就对 S 执行 P操作，判断该缓冲区中是否有其它进程正在访问。如果为 0，则表示该缓冲区已满不能再放产品，生产者进程只能等待。只有这两个 P操作都通过了，生产者才能将产品放入缓冲池。然后对 S 进行 V操作，释放访问，再对 S2（是S2,不是S1，因为放了一个产品是要给S2加1）进行 V操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4835af47f63391886201c29b56587f59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9677bb8c404287090b04b4ef3400c624/" rel="bookmark">
			六个原则，十个开发范式，二十三种模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计模式的六大原则 ： 1、开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里 氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现 抽象化的具体步骤的规范。
3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。
4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
5、迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
6、合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。
二、面向对象的开发范式 1、创建模式 创建模式封装了实例化的过程，客户对象不再关心这些创建的细节：应该使用哪个具体类，如何初始化和组装实例。这样，也为实例化提供了很大的灵活性：可以使用克隆方式加快创建过程和简化创建细节，也可以根据配置确定实例化的具体类型，还可以根据需求创建单例对象。
2、模板方式模式 封装了那些不变的方式步骤，把变化那部分交给子类去封装，对使用者隐藏了具体的子类型。
3、装饰器模式 装饰器模式隐藏了被装饰的对象，并且，由于装饰对象与被装饰对象具有相同的接口，客户在使用被装饰过的对象和未装饰过的对象时，不需要对它们区别对待，隐藏了装饰器的类型。
4、代理模式 和装饰模式一样，隐藏了被代理对象（目标对象），也实现了代理类型的隐藏。
5、适配器模式 隐藏了被适配的接口/类，客户对象并不知道请求会转发给被适配的对象。
6、外观模式 隐藏了子系统，封装了外观与子系统之间的复杂交互。(最少知识原则，比如:CPU,MEMERY,DISK 电脑启动)。
7、组合模式 实现了叶子类与分支子类的隐藏，客户对象操作叶子对象和分支对象不需要区分对待。(树形结构)。
8、策略模式 把独立变化的部分抽象出来，变化的部分是策略，不变的部分是Context。(加，减，乘，除算法)。
9、状态模式 每一个状态都封装了与一个特定状态相关的行为，Context隐藏了状态接口和实现，客户接口不知道它的存在。(就像QQ的状态变化及相关功能一样)。
10、观察者模式 不同的观察者对变化的处理是不同的，把这些变化封装在不同的观察者类型里，由于它们有相同的接口，观察者就能独立于主题而变化。另外如果为主题也抽象了接口，这样观察者和主题两方面就能独立变化与重用，而不会影响对方。
三、设计模式分为三种类型，共23种。 1、创建型模式： 1单例模式、Singletion 2抽象工厂模式、Abstract Factory 3建造者模式、Builder 4工厂模式、Factory 5原型模式。Prototype
2、结构型模式： 6适配器模式、Adapter 7桥接模式、Bridge 8装饰模式、Decorator 9组合模式、Composite 10外观模式、Facade 11享元模式、Flyweight 12代理模式。Proxy
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9677bb8c404287090b04b4ef3400c624/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d884bf4e23f3070e1ba516db130c840c/" rel="bookmark">
			Install Java on Ubuntu with Apt-Get
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //python-software-properties 提供add-apt-repository sudo apt-get install python-software-properties sudo add-apt-repository ppa:webupd8team/java //更新源 sudo apt-get update //java7 sudo apt-get install oracle-java7-installer 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b35e0d3ca365e795839e317a563065/" rel="bookmark">
			C&#43;&#43;中指针赋值三种比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 int *p=NULL 和int *p ;p=NULL 和*p = NULL 这三个的区别： int *p=NULL： 定义一个int型指针，并给它初始化为NULL，也就是个空指针，没有指向任何地方，就是个空的。 int *p ;p=NULL 定义一个int型指针，然后给指针赋值为NULL，指针指向NULL地址。 *p = NULL 给指针的值赋值为NULL，也就是给指针指向的内容赋值为0（也就是为空）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc2844cf7519e229893fece1b6433ce4/" rel="bookmark">
			C&#43;&#43;中的iostream输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;iostream&gt; #include 是个包含命令，就是把iostream这个文件里的内容复制到这个地方。 iostream是input output stream的简写，意思为标准的输入输出流头文件。它包含： 1、cin&gt;&gt;"要输入的内容" 2、cout&lt;&lt;"要输出的内容" 这两个输入输出的方法需要#include&lt;iostream&gt;来声明头文件。 #include&lt;iostream&gt;是标准的C++头文件，任何符合标准的C++开发环境都有这个头文件。注意，在VS编程时要添加： using namespace std; 原因：后缀为.h的头文件C++标准已经明确提出不支持了，早些的实现将标准库功能定义在全局空间里，声明在带.h后缀的头文件里，C++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。因此，当使用&lt;iostream.h&gt;时，相当于在c中调用库函数，使用的是全局命名空间，也就是早期的c++实现；当使用&lt;iostream&gt;的时候，该头文件没有定义全局命名空间，必须使用namespace std；这样才能正确使用cout。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a4c7a61a59ade62bf71ddc5fb51f320/" rel="bookmark">
			C&#43;&#43;中：：双冒号的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C++中::的用法：
1、作用域符号 前面一般是该类名称，后面是该类的成员名称。C++为避免不同的类有相同的成员而采用作用域的方式进行区分，eg：A，B表示两个类，在A，B中都有成员member，那么：A::member表示A中的成员member，B::member表示B中的成员member。 2、全局作用域符号 当全局变量在局部函数中与其中某个变量重名时，可以用::来区分，否则局部变量会屏蔽全局变量。 3、作用域分解运算符 比如声明了一个类A，类A里声明了一个成员函数void f()，但没有在类的声明里给出f函数的定义，那么在类外定义f时，就要写成void A::f()，表示这个f函数是类A的成员函数。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0879cf7377d1e9401d38e2dc5ca983df/" rel="bookmark">
			C&#43;&#43;的多文件结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 c++多文件结构 比如程序是这样的： a.h是类定义文件， a.cpp是类实现文件， 还有一个是主函数文件。 多文件结构方法： 1、首先建立一个项目 2、然后再新建a.h头文件 3、再新建a.cpp文件，在前面加上#include"a.h" 4、最后新建a.cpp文件,也需要在前面加上#include"a.h" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79e3e00c6a5b330f1b772976762f519b/" rel="bookmark">
			PAT-B 1030. 完美数列(25)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接在此。
本题目前有二分查找法、two pointers法。
题意 从N个正整数中选出若干个数，使得选出的这些数中的最大值M和最小值m满足M&lt;=m*p。问满足条件的选择方案中，选出的数的最大个数。
二分查找法 思路 首先需要对N个正整数从小到大排序，然后需要明白，选出的数个数最大的方案，一定是在该递增序列中连续的若干序列（这里不做证明，很好想）。
首先，很容易想到的是从左往右扫描，对于每个a[i]，在a[i+1]~a[n-1]中找到第一个大于a[i]*p的数的位置index，这样index-i就是满足条件的最远长度。
但是这样两遍线性扫描的时间复杂度太大，所以需要将在a[i+1]~a[n-1]找位置换成二分查找。
注意点： 1. 数据范围会超过int，索性都用long long 2. 当数组a[]中所有数都超过了a[i]*p的情况进行特判
AC代码 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; long long n, a[100010], p; int main(){ scanf("%lld %lld",&amp;n, &amp;p); for(int i = 0; i &lt; n; i++){ scanf("%lld",&amp;a[i]); } sort(a,a+n); //从小到大排序 int ans = 1; int i; int left, right; for(i = 0; i &lt; n; i++){ long long mp = a[i]*p; //mp 对应题干m*p left = i+1, right = n-1; if(a[right] &lt; mp){ //如果数组中最大的数都小于mp,则从i到最后一个数都满足 right = n; }else{ while( left &lt; right){ //二分查找 int mid = (left+right)/2; if(a[mid] &lt;= mp){ //a[mid]&lt;=要找的数，则说明第一个大于要找的数在mid的右边 left = mid+1; }else{ right = mid; } } } ans = max(ans,right-i); } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79e3e00c6a5b330f1b772976762f519b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d6c985752eda6661b9b49f3db9a9af/" rel="bookmark">
			【工作笔记】ElasticSearch从零开始学（五）—— Java_SearchAPI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		es允许执行搜索查询，返回结果匹配（hits)，甚至跨多个index和执行多个type
SearchSourceBuilder 所有参数都是可选的 import org.elasticsearch.action.search.SearchResponse; import org.elasticsearch.action.search.SearchType; import org.elasticsearch.index.query.QueryBuilders.*; SearchResponse response = client.prepareSearch("index1", "index2") //索引 .setTypes("type1", "type2") //类型 //检索方式 .setSearchType(SearchType.DFS_QUERY_THEN_FETCH) //查询条件query_string .setQuery(QueryBuilders.termQuery("multi", "test")) //多条件过滤filters .setPostFilter( QueryBuilders.rangeQuery("age").from(12).to(20) ) .setFrom(0) .setSize(60) .setExplain(true) .get(); SearchAPI参考
Scrollings in Java 返回整个”page”, 用来检索大量结果
import static org.elasticsearch.index.query.QueryBuilders.*; //queryString QueryBuilder qb = termQuery("multi", "test"); SearchResponse scrollResp = client.prepareSearch(test) .addSort(FieldSortBuilder.DOC_FIELD_NAME, SortOrder.ASC) //属性排序 .setScroll(new TimeValue(60000)) .setQuery(qb) //条件 .setSize(100) //每一页返回100条数据 .get(); //接收scrollResp响应结果 do { for (SearchHit hit : scrollResp.getHits().getHits()) { //输出结果（封装在hits属性中) } scrollResp = client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40d6c985752eda6661b9b49f3db9a9af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be28d615fd1d5708816daabec98294a1/" rel="bookmark">
			SQL中查询前几条或者中间某几行数据limit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset 使用查询语句的时候，要返回前几条或者中间某几行数据，用Llimit 可以实现： 1. LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)： 为了与 PostgreSQL 兼容，MySQL 也支持句法： LIMIT # OFFSET #。
2.mysql&gt; SELECT * FROM table LIMIT 5,10; //检索记录行6-15 3. //为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. 4. //如果只给定一个参数，它表示返回最大的记录行数目： mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行 //换句话说，LIMIT n 等价于 LIMIT 0,n。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5a0af4d7dae332f672140013e917c0/" rel="bookmark">
			如何对APP进行重新签名（使用命令签名）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于写好的Android程序，打成apk包，有时我们想更换下包里的资源，或者我们需要跑自动化测试，这时就得对这个apk包进行重新签名。
Java环境 方法一：需要删除apk包中的签名文件，META-INF（更改apk格式为压缩包形式，删除META-INF文件夹，改回.apk格式）；
将证书(debug.keystore)复制到与需要重新签名的apk文件相同的目录下（如：复制到桌面新建文件夹，C:\Users\fkq\Desktop\新建文件夹）；
cmd进入命令，定位到选中的文件夹：
运行下面的命令：
jarsigner -verbose -keystore debug.keystore -storepass android -signedjar sign.apk -digestalg SHA1 -sigalg MD5withRSA signed.apk androiddebugkey
/*解释：-jarsigner是Java的签名工具-verbose 参数表示：显示出签名详细信息 -keystore 表示使用当前目录中的debug.keystore签名证书文件 -storepass android 表示Keystore密码：“android” -signedjar signed.apk表示签名后生成的APK名称， sign.apk表示未签名的APK Android软件-digestalg SHA1 -sigalg MD5withRSA：这就是必须加上的参数，如果你是jdk 1.6也不受影响 -androiddebugkey表示Key别名，也可为 mysign.keystore 大功告成，看看文件夹吧；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db60dc88606b690d3eaad0b0f340a299/" rel="bookmark">
			CentOS下命令行实现普通用户和root用户切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS下实现普通用户和管理团员权限的切换
使用su命令实现用户属性的转换
普通用户切换到root用户：方法有多重 1）su-&gt;回车-&gt;输入root密码
2）su -root-&gt;回车-&gt;输入root密码
root用户切换到普通用户： su "普通用户名"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d49ff89eabc21601437b338ecba72024/" rel="bookmark">
			JPype入门实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://www.cnblogs.com/mumuli/p/5806963.html
因项目需要用python调用java程序，所以特意搜了搜JPype，但调了好几天才成功，尽管心好累，还是打算记录下，以此为鉴，避免再走弯路。
一、测试代码
1、编写HelloWorld.py脚本
#HelloWorld.py
from jpype import *
import os
startJVM(getDefaultJVMPath(),"-ea")
java.lang.System.out.println("HelloWorld")
os.system("pause")
shutdownJVM()
2、在cmd窗口运行HelloWorld.py
3、成功打印出“Hello world”，成功
二、引用jar包
1、创建如下结构的Test.java
Main.java是在主函数中调用了run方法
2、Test.java代码
代码如上所示
3、将其打包成jar
下面两种方法均可行：
a、 通过命令行的方法
1、CMD窗口，跳转到Test.java所在目录
2、运行javac Test.java
3、看到Test.java的同级目录下生成了一个Test.class
4、跳转到src所在目录运行jar cvf test.jar com
5、可以看到src目录下生成了test.jar
6、将test.jar拷贝到Python安装目录下的libs目录中
b、直接将工程打包成jar
项目à右键àExportàJava—&gt;Runnable Jar File，选择该项目的主函数，保存到Python安装目录下的libs目录中
4、编写Python调用脚本
# testJPype.py
from jpype import *
import os.path
jarpath=os.path.join(os.path.abspath('.'),"libs\\test.jar")
#print(jarpath)
startJVM(getDefaultJVMPath(),"-ea","-Djava.class.path=%s"% jarpath)
#Test=jpype.JClass("com.Test")
com=JPackage('com')
Test=com.Test
t=Test()
res=t.run("JPype,HelloWorld!")
print(res)
5、运行成功共成功
输出“JPype,Hello World!”,执行成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5359d70e4dea3878bf5b8808ef62d806/" rel="bookmark">
			关键路径算法 Java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果要对一个流程图活的最短时间，就必须分析他们的拓扑关系，并且找到当中最关键的流程，
这个流程的时间就是最短时间
AOE网（Activity On Edge Network）:
* 在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间。
* 注：与AOV网不同的是，AOV网是顶点表示活动的网，它值描述活动之间的制约关系，而AOE网是用边表示活动的网，边上的权值表示活动持续的时间。
结合 图1中的v3,v4理解事件的最早发生时间，v1理解事件的最晚发生时间比较好。
代码中的图
图1：
图1中事件的最早和最晚发生时间
图2：
图2中事件的最早和最晚发生时间
代码：
import java.util.ArrayList; import java.util.List; import java.util.Stack; /** * AOE网（Activity On Edge Network）:&lt;p&gt; * 在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间。&lt;p&gt; * 注：与AOV网不同的是，AOV网是顶点表示活动的网，它值描述活动之间的制约关系，而AOE网是 * 用边表示活动的网，边上的权值表示活动持续的时间。 */ public class CriticalPath { /** * 顶点数组 */ private List&lt;VertexNode&gt; vexList; /** * etv:earliest time of vertex 事件的最早发生时间&lt;p&gt; * ltv:latest time of vertex 事件的最晚发生时间 */ private int etv[], ltv[]; /** * 拓扑序列，保存各顶点拓扑排序的顺序 */ private Stack&lt;Integer&gt; stack2; /** * 创建图1（邻接表） */ public void createGraph1() { //v0 VertexNode v0 = new VertexNode(0, 0, null); EdgeNode v0e0 = new EdgeNode(3, 3, null); v0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5359d70e4dea3878bf5b8808ef62d806/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/402fbef4e7868744161c4aa240b041c2/" rel="bookmark">
			初学者如何从零开始学习人工智能？看完你就懂了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：oschina.net/news/78629/beginners-how-to-learn-from-zero-artificial-intelligence
每个项目产品都会让你加埋点，你是愿意花几天一个个加，还是愿意几分钟一个小时加完去喝茶聊天？来试试这520web工具, 高效加埋点，目前我们公司100号前端都在用，因为很好用，所以很自然普及开来了，推荐给大家吧
http://www.520webtool.com/
自己开发所以免费，埋点越多越能节约时间，点两下埋点就加上了，还不会犯错，里面有使用视频，反正免费 😄
此文是想要进入人工智能这个领域、但不知道从哪里开始的初学者最佳的学习资源列表。
一、机器学习
有关机器学习领域的最佳介绍，请观看Coursera的Andrew Ng机器学习课程。 它解释了基本概念，并让你很好地理解最重要的算法。
有关ML算法的简要概述，查看这个TutsPlus课程“Machine Learning Distilled”。
“Programming Collective Intelligence”这本书是一个很好的资源，可以学习ML 算法在Python中的实际实现。 它需要你通过许多实践项目，涵盖所有必要的基础。
这些不错的资源你可能也感兴趣:
Perer Norvig 的Udacity Course on ML（ML Udacity 课程）
Tom Mitchell 在卡梅隆大学教授的 Another course on ML（另一门ML课程）
YouTube上的机器学习教程 mathematicalmonk
二、深度学习
关于深度学习的最佳介绍，我遇到最好的是 Deep Learning With Python。它不会深入到困难的数学，也没有一个超长列表的先决条件，而是描述了一个简单的方法开始DL，解释如何快速开始构建并学习实践上的一切。它解释了最先进的工具（Keras，TensorFlow），并带你通过几个实际项目，解释如何在所有最好的DL应用程序中实现最先进的结果。
在Google上也有一个great introductory DL course，还有Sephen Welch的great explanation of neural networks。
之后，为了更深入地了解，这里还有一些有趣的资源：
Geoffrey Hinton 的coursera 课程“Neural Networks for Machine Learning”。这门课程会带你了解 ANN 的经典问题——MNIST 字符识别的过程，并将深入解释一切。
MIT Deep Learning（深度学习）一书。
UFLDL tutorial by Stanford （斯坦福的 UFLDL 教程）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/402fbef4e7868744161c4aa240b041c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/226521256828c4d86969819f256a407b/" rel="bookmark">
			osg截图示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;osgViewer/Viewer&gt; #include &lt;osgViewer/GraphicsWindow&gt; #include &lt;osg/Node&gt; #include &lt;osg/Geode&gt; #include &lt;osg/Group&gt; #include &lt;osg/Camera&gt; #include &lt;osg/Image&gt; #include &lt;osg/BufferObject&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgDB/WriteFile&gt; #include &lt;osgUtil/Optimizer&gt; #include &lt;iostream&gt; #include &lt;osgGA/GUIEventHandler&gt; #include &lt;osgGA/TrackballManipulator&gt; osg::ref_ptr&lt;osg::Image&gt; image_c = new osg::Image() ; struct CaptureCallback:public osg::Camera::DrawCallback { CaptureCallback(osg::ref_ptr&lt;osg::Image&gt; image) { image_ = image ; } ~CaptureCallback(){} virtual void operator()(const osg::Camera &amp;camera) const { //得到窗口系统接口 osg::ref_ptr&lt;osg::GraphicsContext::WindowingSystemInterface&gt; wsi = osg::GraphicsContext::getWindowingSystemInterface() ; unsigned int width , height ; //得到分辨率 wsi-&gt;getScreenResolution(osg::GraphicsContext::ScreenIdentifier(0) , width , height) ; //分配一个image image_-&gt;allocateImage(width , height , 1 , GL_RGB , GL_UNSIGNED_BYTE) ; //读取像素信息抓图 image_-&gt;readPixels(0 , 0 , width , height , GL_RGB , GL_UNSIGNED_BYTE) ; } private: osg::ref_ptr&lt;osg::Image&gt; image_ ; }; //抓图事件处理器 class ImageHandler:public osgGA::GUIEventHandler { public: ImageHandler() { } ~ImageHandler(){} bool handle(const osgGA::GUIEventAdapter&amp; ea , osgGA::GUIActionAdapter&amp; aa) { osg::ref_ptr&lt;osgViewer::Viewer&gt; viewer = dynamic_cast&lt;osgViewer::Viewer *&gt;(&amp;aa) ; if (viewer == NULL) { return false ; } //定义一个静态变量 static int _screenCaptureSequence = 0 ; switch (ea.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/226521256828c4d86969819f256a407b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7913349bf210e98259163c5bc38df387/" rel="bookmark">
			JQuery给iframe添加html
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;iframe id="qrcode-iframe" name="submitIframe" src="about:blank" &gt; &lt;/iframe&gt; &lt;script&gt; $(function() { var qrdiv = $("&lt;div&gt;&lt;/div&gt;").qrcode("URl：weixin：//wxpay/s/An4baqw"); $("#qrcode-iframe").contents().find("body").append(qrdiv); }); &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2515dfd061ec400f2969b0685e3c4b3f/" rel="bookmark">
			在iframe里面提交表单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;iframe id="qrcode-iframe" name="submitIframe" src="about:blank" width="100%" height="750px" frameborder="no" border="0" marginwidth="0" marginheight="0" &gt; &lt;/iframe&gt; &lt;script&gt; $(function() { var form = "&lt;form id="alipaysubmit" name="alipaysubmit" action="https://mapi.alipay.com/gateway.do?_input_charset=utf-8" method="get" target="submitIfram"&gt;&lt;/form&gt;&lt;script&gt;document.forms['alipaysubmit'].submit();&lt;/script&gt;"; $("#qrcode-iframe").append($(form)); }); &lt;/script&gt; 指定表单的target为iframe的name即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75342642204c3b7325453312f74031d4/" rel="bookmark">
			Graphics.Blit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：官方文档
https://docs.unity3d.com/ScriptReference/Graphics.Blit.html
public static void Blit(Texturesource,RenderTexture dest); public static function Blit( source: Texture, dest: RenderTexture, mat: Material, pass: int = -1): void; public static void Blit( Texture source, RenderTexture dest, Material mat, int pass = -1); public static function Blit( source: Texture, mat: Material, pass: int = -1): void; public static void Blit( Texture source, Material mat, int pass = -1); 需求注意第4个参数，用4个参数pass用于指定使用哪一个pass。默认值为-1，即使用所有的pass。 Description Copies source texture into destination render texture with a shader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75342642204c3b7325453312f74031d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bfc8eb446e1e80a8e4ae991fc806eda/" rel="bookmark">
			Opencv 图像融合（seamlessClone）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Opencv图像融合效果：
相关Opencv 图像融合API为seamlessClone：
1,2,3三个参数对应源文件、目标文件与mask文件，注意mask文件为src的ROI区域。
第四个参数为src要在dst上摆放的位置。
第五个参数为对应输出文件。
第六个参数为采用的融合方式，默认为NORMAL_CLONE。
三个融合方式为：
NORMAL_CLONE：常用的方法，符合大多数图像融合的需求。
MIXED_CLONE：可能导致不可期望的融合效果，不建议使用。
FEATURE_EXCHANGE：将src完全融入dst中，基本不保留src的颜色细节
src（下一图）与dst（下二图）
三种融合效果如下图（第一张NORMAL_CLONE、第二张MIXED_CLONE、第三张FEATURE_EXCHANGE）：
相关理论涉及泊松融合，详细请看如下论文：
相关论文（需要翻墙）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47868f29e88234e1fab724a465d2c480/" rel="bookmark">
			Opencv 去高光或镜面反射（illuminationChange）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下图片中间存在高光，需要消除高光：
涉及的Opencv API为illuminationChange：
处理后的效果如下：（图片顺序对应src, mask， dst三个参数）
最后处理完的感觉类似拿一块玻璃挡住mask所在的区域。
alpha，beta两个参数共同决定消除高光后图像的模糊程度（范围0~2，0比较清晰，2比较模糊）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6271c1be5ebe1059fcbffff31fa96b0c/" rel="bookmark">
			Opencv 颜色空间处理（Color space processing）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		颜色空间简介：
计算机领域对色彩的一种量化说明，主要有RGB，CMY，HSV，HSI等。
实际的图像处理过程中常常涉及二值化、色彩饱和度等需求，需要记性颜色空间的转换。
用到Opencv API:
cvtColor(InputArray src, OutputArray dst, int code, int dcn=0)
第一个参数为输入图像，第二个参数为输出图像，第三个参数为转换类型，第四个参数为指定输出图像的通道数，默认值为0，即与src的通道数一致。
需要注意的地方：
1、Opencv默认颜色空间为BGR，即蓝绿红。Opencv的大多数API都是基于此颜色模型。
故安卓bitmap读取的png图片（基于RGBA颜色空间）转换为Mat结构后，需要调用如下函数转为Opencv的标准 ：
Imgproc.cvtColor(src, dst, Imgproc.COLOR_RGBA2BGR); 2、图像位深度较大的图片，使用此API转换图像，有可能丢失图像信息，需要特殊处理。
3、主要用到的图像空间转换类型（即ColorConversionCodes枚举类型）有：（注意BRG转换后不能直接使用imwrite等函数直接处理图像，因为Opencv大多数函数都是基于BGR颜色空间的）
COLOR_BGR2BGRA 3通道转4通道
COLOR_BGRA2BGR 4通道转3通道
COLOR_BGR2GRAY 3通道转灰度图
COLOR_BGR2HSV RGB颜色空间转HSV颜色空间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f2d46c52e399450a833fce1bc1525e/" rel="bookmark">
			Android中5种app瘦身方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android中5种app瘦身方式 App瘦身的概念 App瘦身是指在不减少App功能的前提下，通过一些技巧将打包出来的apk体的体积尽可能减少。 这样做的好处有几个：加快用户下载速度，节省用户下载流量，提升用户下载体验。 如果不进行瘦身，默认打包的apk会包含所有未曾用到的源代码、资源文件等，极大的增加了apk的体积。 App瘦身的常用技巧 第一种：配置build.gradle文件，开启minifyEnabled，作用是启用混淆压缩模式，会过滤掉整个项目中未使用到的jar和class文件，对代码进行混淆，从而减少dex文件大小。但是，并不能减少图片资源。 buildTypes { //增加构建类型 releaseMinifyEnabled { //开启dex字节码压缩，舍去未使用的jar和class文件 minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'),'proguard-rules.pro' } //默认release构建类型 release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } 第二种：配置build.gradle文件，开启shrinkResources，作用是将res目录下未使用到的图片文件进行特殊处理，其具体做法是将未使用到的图片全部变成1x1像素的小图，从而减少res目录的大小。弥补minifyEnabled中的不足。 具体做法如下： shrinkResources { //启用res资源过滤，会将项目中未使用到的图片变成1x1的小图，从而减少体积 shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } 第三种：配置build.gradle文件，指定resConfigs，作用是指定打包时编译的语言包类型，未指定的其他语言包，将不会打包到apk文件中，从而减少apk体积的大小。 一般我们只支持中文和英文。 defaultConfig { applicationId "com.example.lxj.appthin" minSdkVersion 14 targetSdkVersion 24 versionCode 1 versionName "1.0" //配置打包时编译的语言类型，默认会编译value目录，此处再增加一个中文类型 resConfigs("zh") } 第四种：采用三方工具（如tinypng）来进一步压缩项目中的所有png图片，从而进一步减小apk体积。
首先，打开tinypng网站，将项目中的png图片拖拽网页中，自动进行压缩；然后，下载所有经过压缩的图片，替换项目中对应的png图片；总结：该种方式能够极大的减小图片的体积，基本上能减小50%左右，效果非常显著，强烈建议掌握。第五种：采用webp格式的图片替换png和jpg格式的图片
webp概念：
WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式，国内的京东，淘宝客户端都在使用。webp格式是未来图片格式的趋势。
对于服务器来说，webp格式可以说是必用的格式。对于客户端来说，可以将比较大的png图片替换为webp格式，从而减少apk的体积。
如何将得到webp格式的图片？
有2种方式，可以选择让美工在作图的时候直接做成webp格式；也可以选择使用一些webp格式转换工具对当前已有的png图片进行转换。
如何将webp格式的图片应用到项目中？
直接将得到的webp格式图片替换项目中的png图片即可。
webp使用注意事项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40f2d46c52e399450a833fce1bc1525e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db9729b6978dc6c271d79a5c1c14a746/" rel="bookmark">
			IEEE754浮点数表示，为什么偏移码是127？为什么偏移码范围是1～254？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以单精度浮点数为例
IEEE754规定，s作为符号位，用0（正），1（负）表示，E作为阶码用移码表示（后面解释为什么用移码），M作为尾数，并规定最高位总为1，因此将1省略，简称隐藏位。
填坑。为什么将E作为移码表示？
首先明确一个概念，什么移码？移码（增码）是为了某个目的存在，是符号位取反的补码。
例： X=+1011 [X]移=11011
X=－1011 [X]移=00101
回到主题
单精度浮点数（32位），阶码（后面的用偏移阶码表示，其实在IEEE754表示单精度浮点数都是一个概念）8位，那么原来8位二进制数有符号二进制表示范围是-127~127，但是IEEE为了不在阶码中引入符号位，且8位偏移阶码（阶码中二进制数为无符号数）范围是1～254（为什么不包括0和255？后面说），因此引入偏移码（移码），在有符号位的二进制基础上加127，那么就有了偏移阶码范围0～254，但是0不合法，后面说，因此偏移阶码范围是1～254。 为什么是127呢？？是不是很多人都有这个疑惑。 加上127不就从原来的二进制有符号转变为无符号了嘛。IEEE不就是为了不在阶码E中不引入符号位才加的127嘛。
填坑，为什么范围是1～254？
因为0用8位阶码用全0表示，255用8位阶码用全1。 出现全0，尾数M全0，符号位为0，为正0，符号位为1，为负0（IEEE754规定的浮点数有正0负0之分），偏移阶码出现全1，尾数M全0，符号位S为0，为正无穷大，符号位S为1，为负无穷大。 这就是为什么不把0和255放入偏移阶码范围中的原因。
我之前也在纠结这个问题，纠结在为什么是127不是128或者其他数，其实很简单，就是为了将有符号转换为无符号。 希望我这篇微博可以帮到还处于迷茫的小伙伴。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea620ae0fbbf91079858b655a67c332a/" rel="bookmark">
			C&#43;&#43; 11 三个线程打印ABC（顺序打印）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：有3个线程A，B， C， 请用多线程编程实现在屏幕上循环打印10次ABCABC...， 其中A线程打印“A”， B线程打印“B”， C线程打印“C”。
使用C++11 实做， 代码如下：
#include &lt;iostream&gt; #include &lt;thread&gt; #include &lt;condition_variable&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; std::mutex mtx; std::condition_variable cvar; char g_ch = 0; void print_fun(char ch) { int cyle_cnt = 10; char ch_ = ch - 'A'; for (int i = 0; i &lt; cyle_cnt; i++) { std::unique_lock&lt;std::mutex&gt;ulk(mtx); cvar.wait(ulk, [ch_] {return ch_ == g_ch; }); std::cout &lt;&lt; (char)(ch_ + 'A'); g_ch = (ch_ + 1) % 3; ulk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea620ae0fbbf91079858b655a67c332a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f683e214d160401f83639a32d63fc02d/" rel="bookmark">
			谁考了第k名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1011:谁考了第k名 查看 提交 统计 提问 总时间限制: 1000ms 内存限制: 65536kB 描述
在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第k名学生的学号和成绩。
输入 第一行有两个整数，分别是学生的人数n（1≤n≤100），和求第k名学生的k（1≤k≤n）。 其后有n行数据，每行包括一个学号（整数）和一个成绩（浮点数），中间用一个空格分隔。 输出 输出第k名学生的学号和成绩，中间用空格分隔。
我的程序：
/* * 程序的版权和版本声明部分: * Copyright (c) 2017, 信息学院 * All rights reserved. * 文件名称：谁考了第k名 * 作 者：邓华伟 * 完成日期：2017年3月4日 * 版 本 号：v1.0 * 对任务及求解方法的描述部分: * 输入描述：无 *问题分析：根据成绩来进行排名，建立结构体。 * 算法设计：略 */ #include&lt;stdio.h&gt; #include&lt;iostream&gt; using namespace std; struct studen//建立结构体 { char name[20];//姓名用字符数组来存储 double num;//成绩 }; int main() { struct studen student[100]; struct studen t; int n,k,i,j; cin&gt;&gt;n&gt;&gt;k; for(i=0;i&lt;n;i++) { cin&gt;&gt;student[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f683e214d160401f83639a32d63fc02d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38be17a6313aa72977cc9f88b707227b/" rel="bookmark">
			递归的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优点：
1. 简洁
2.在树的前序，中序，后序遍历算法中，递归的实现明显要比循环简单得多。
缺点：
1.递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而往栈中压入数据和弹出数据都需要时间。-&gt;效率
2.递归中很多计算都是重复的，由于其本质是把一个问题分解成两个或者多个小问题，多个小问题存在相互重叠的部分，则存在重复计算，如fibonacci斐波那契数列的递归实现。-&gt;效率
3.调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。-&gt;性能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3aa989500dd6bee456f61317b06ccdb/" rel="bookmark">
			双目视觉测距离（三维重建）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到好的东西就想转载和大家一起分享一起学习！！！ 来源：http://blog.csdn.net/tiemaxiaosu/article/details/51734667 一、三维重建概述 三维重建主要是研究如何从得到的匹配点中计算出相机的投影矩阵(如果是外部标定的话，就是求出相机的外部参数)以及如何计算出匹配点的三维坐标。 目前研究的进展与之还相差较远。研究人员为了能够表达三维空间信息，目前较多地采用三维矢量图形来替代三维位图。主要的重构方法有如下几种： (1)、空间点的重建 这是三维重构中的最基本的方法。空间任一点在两个摄像机中分别成像，得到该点在两个图像中的对应坐标，在知道两摄像机的参数矩阵的条件下，通过建立以该点的世界坐标为未知数的 4 个线性方程，可以用最小二乘法求解得该点的世界坐标。有一种简化计算的办法，选取两个内部参数完全相同的摄像机，将他们平行配置，使他们的光轴相互平行。这种方法计算相当简单，不需要进行外部参数标定。但一般情况下，两个摄像机的内部参数完全相同(包括两摄像机的拍摄状态也相同)是很难选到。摄像机安装时无法看到光轴和成像平面，故难以实施。 (2)、空间直线、空间二次曲线的重建 空间直线和空间曲线也是组成空间图形的主要基元。根据空间直线射影变换前后仍是直线的性质，以此来分析空间直线与图像中的直线之间的关系。空间直线在CCD上的成像可以这样认为，空间直线与摄像机光心构成的平面与成像平面的交线，两台摄像机有两个这样的平面，这两个平面的交线就是空间直线。空间二次曲线是空间二次曲面与平面的交线，因此二次曲线的平面曲线，在CCD上的成像可以认为是由空间二次曲线与光心组成的锥面与成像平面的交线。两台摄像机有两个这样的锥面，求这两个空间锥面的交线，就是空间曲线。 (3)、全像素的三维重建 对图像中的每个像素都进行三维重建，这当然是最理想的情况，目前要实施这种重构，需要相当严格的测量条件，且仅限于对某一具体对象，但效果并不理想。对此人们正在进行大量的研究，还有待于进一步的努力。 二、空间点的三维重建 1、基本模型 空间点三维重建的基本模型如图(4.1)所示，对于空间物体表面任意一点P，如果用C1摄像机观察，看到它在C1摄像机的图像点位于p1，但他们无法由p1得知P的三维位置，事实上，在O1P(O1为C1摄像机的光心)连线上任意一点P’的图像点都是p1，因此，由p1点的位置，我们只知道空间点位于O1P1与O2P2两条直线的交点，即它们的三维位置是唯一确定的。 假如我们能够得到物体表面上所有点的三维坐标，则三维物体的形状与位置就是唯一确定的，在某些简单场合，例如三维物体时一个多面体，我们只需要知道它的各个顶点的三维坐标与相邻关系，则该多面体的形状与位置是唯一确定的。因此，用立体视觉的方法获取三维点的坐标是十分基础的。 2、最小二乘法求解三维坐标值 下面我们来具体介绍求解三维点坐标的 算法。在进行讨论之前，我们要明确一下几点基本假设：空间任意点P在两个摄像机C1与C2上的图像点平p1与p2已经从两个图像中分别检测出来。即已知p1与p2为空间同一点P的对应点。至于对应点是如何找到的，这属于图像配准问题。还有一个假设就是，摄像机C1与C2已标定，他们的投影矩阵分别为M1与M2，于是有： 其中，(u1,v1,1)与(u2,v2,1)分别为P1与P2点在各自图像中的图像齐次坐标；(X,y,Z,1)为P点在世界坐标系下的齐次坐标；mijk为Mk的第i行第j列元素。式(4.1)与式(4.2)消去Zc1与Zc2得到关于X,Y,Z的四个线性方程： 由于空间点P是O1p1与O2p2的交点，它必然同时满足式(4.3)，式(4.4)，我们可以联立这四个式子，从而求出P点的坐标(X,Y,Z)。四个方程，三个未知数，也就是说这个方程组只有三个独立的方程，这是因为我们已经假设P1与P2点是空间同一点P的对应点，因此已经假设了直线O1p1与O2p2一定相交，或者说，这四个方程必定有解，而且解是唯一的。而实际应用中，由于数据总是有噪声的，我们可以用最小二乘法求出P的三维点坐标(X,Y,Z)。 3、视差测距法 以上我们介绍了空间点三维重建的一般方法，为了更清楚的了解上述过程的物理意义，下面我们讨论在一种简单的摄像机配置下的空间点重建方法，视差测距法。此方法要求选用两个内部参数完全相同的摄像机，将它们平行放置，使它们的光轴相互平行，另有一对坐标轴共线，两个成像平面共面，两摄像机的光心有一个固定的距离d，这样求解图像点的世界坐标时只涉及摄像机内参数。原理如图(4.2)所示： 在上述特殊摄像机配置下，假设C1坐标系为O1x1y1z1，C2坐标系为O2x2y2z2，焦距为f，摄像机间距为d，任何空间点P的坐标在C1下为(x1,y1,z1)，在C2坐标系下为(x2,y2,z2)，在左摄像机中的图像点左边为(u1,v1)，在右摄像机中的图像点坐标为(u2,v2)。 根据式(4.5)，式(4.6)的摄影比例关系，对于左右摄像机有如下关系： 世界坐标系与摄像机坐标系的关系可表述如下： 联立上两式可得： 进而可得： 由式(4.5)和式(4.8)可计算的空间点的三维坐标： 式(4.9)即为双目立体视觉重构三维空间点的方法，可见，通过图像对视差和像点坐标就可以恢复出物体的三维坐标。但是由于对设备配置的要求比较苛刻，只是被应用在一些简单的视觉系统。本文采用的还是针对一般摄像机参数的三维重建方法，这样大大扩展了带云台的摄像机的视野范围，从而增强了移动机器人视觉系统的灵活性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78308636e2ad9895b58523788083121/" rel="bookmark">
			本地源中有需要的rpm，yum不到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看光盘的版本和系统版本是否一致，32位和64位不兼容 2、配置本地源之后 需要清理干净，再重新缓存加载 yum clean all yum makecache 3、强制在本地包目录安装 yum localinstall vsftpd 来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/30236014/viewspace-2134608/，如需转载，请注明出处，否则将追究法律责任。 转载于:http://blog.itpub.net/30236014/viewspace-2134608/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb807c9a2dd43a3620ed468c7459831d/" rel="bookmark">
			C语言将十进制整数输出为八进制和十六进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一：
直接使用控制字符串
%o 八进制
%x %X 十六进制
方法二：
函数 char *itoa(int value, char *string, int radix)
返回值类型char
参数value 待转换的数字
参数string 转换后存储到string中
参数radix 转换到几进制
定义在 stdlib.h
代码如下：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MAX 100 int main() { int userinput; printf("Please enter a integer.\n"); scanf("%d",&amp;userinput); char octal[MAX],hex[MAX]; itoa(userinput,octal,8); itoa(userinput,hex,16); printf("Octal and Hex of the integer %d that you entered is %s and %s.\n",userinput,octal,hex); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f581395f6cc39f30902047222b5491ef/" rel="bookmark">
			js为Object对象动态添加属性和值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为Object对象动态添加属性和值
方式1：
var obj = {}; //或者 var obj=new Object(); var key = "name"; var value = "张三丰" obj[key] = value; console.info(obj); 方式2，使用eval() 动态解析字符串表达式 var obj = {}; var key = "name"; var value = "张三丰" eval("obj.p" + key + "='" + value + "'"); console.info(obj); 更多：
Js 取模运算、取商、取整方法
Jquery Md5加密-Jquery.md5.js CSS 样式异步加载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f89cdc8a318994db4ea741d770b35f/" rel="bookmark">
			Windows定时任务相关与常见异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 定时任务、计划任务、定时计划任务、任务计划程序........
一.找到定时任务
win10的话直接搜索就行
二.创建基本任务
由导航，输入名称（即这个定时任务的名字），描述，点击下一步；
选择执行的频率，这个可以后续进行详细的更改。
选择“启动程序”，点击下一步。
点击“浏览”，选择要启动的程序（bat或vbs或vbe），“参数”和“起始于”与程序有关，一般不填，请与程序提供者联系是否添加。
如果你是程序提供者，这里写启动参数，即，我们在命令行中向程序传递的参数，test.vbs 1这种。
单击“完成”，然后打开任务属性对话框。
此时已可启动定时任务，在任务属性框中，可以进行进一步的详细设置。
三.常见问题
我遇到的最多的问题，就是路径不对的问题。
用windows计划任务启动程序，工作路径发生改变。
有两种方案可以解决本问题：
1.用绝对路径不用相对路径。
2.修改工作路径为文件路径：
Set WshShell = CreateObject("Wscript.Shell") WshShell.CurrentDirectory = Left(WScript.ScriptFullName, InStrRev(WScript.ScriptFullName, "\") -1)另一种方法 WshShell.CurrentDirectory = fso.GetFolder(".").Path 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb16e5866d1966347b87bfe5e8ba7afe/" rel="bookmark">
			android绘制圆角矩形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android中可以绘制圆角矩形。
1.利用画布cavas绘制
如果提供了一个方法可以在画布上绘制圆角矩形：
函数名称：public void drawRoundRect (RectF rect, float rx, float ry, Paint paint)
参数说明：
rect：RectF对象。
rx：x方向上的圆角半径。
ry：y方向上的圆角半径。
paint：绘制时所使用的画笔。
示列： Paint _debugInfoPaint = new Paint(Paint.ANTI_ALIAS_FLAG); //设置无锯齿 也可以使用setAntiAlias(true) _debugInfoPaint.setColor(Color.GREEN);//设置画笔颜色 _debugInfoPaint.setAlpha(200); _debugInfoPaint.setStrokeWidth(1.5f);//设置线宽 _debugInfoPaint.setStyle(Paint.Style.STROKE);//设置样式：FILL表示颜色填充整个；STROKE表示空心 canvas.drawRoundRect(new RectF(0, 0, 300, 300), 10, 10, _debugInfoPaint); 2.xml中设置 建立 rect_gray.xml文件放在drawable文件夹下面 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;!-- 填充颜色 --&gt; &lt;solid android:color="#FFFFFF"&gt;&lt;/solid&gt; &lt;!-- 线的宽度，颜色灰色 --&gt; &lt;stroke android:width="1dp" android:color="#D5D5D5"&gt;&lt;/stroke&gt; &lt;!-- 矩形的圆角半径 --&gt; &lt;corners android:radius="0dp" /&gt; &lt;/shape&gt; 然后在使用的地方引用： &lt;LinearLayout android:id="@+id/activity_myhezu_wantchuzu" android:layout_width="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb16e5866d1966347b87bfe5e8ba7afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05ac49326ec2a9f201f9bd94c6938608/" rel="bookmark">
			IOS Error Domain=NSURLErrorDomain Code=-999 &#34;(null)&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Printing description of error: Error Domain=NSURLErrorDomain Code=-999 "(null)" 出现错误的原因是因为webview在之前的请求还没有加载完成，下一个请求开始发起了，因此webview会取消掉之前的请求，便会回调到didFailLoadWithError。
- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error { // 被取消 if([error code] == NSURLErrorCancelled) { return; } } /*! @enum NSURL-related Error Codes @abstract Constants used by NSError to indicate errors in the NSURL domain */ NS_ENUM(NSInteger) { NSURLErrorUnknown = -1, NSURLErrorCancelled = -999, NSURLErrorBadURL = -1000, NSURLErrorTimedOut = -1001, NSURLErrorUnsupportedURL = -1002, NSURLErrorCannotFindHost = -1003, NSURLErrorCannotConnectToHost = -1004, NSURLErrorNetworkConnectionLost = -1005, NSURLErrorDNSLookupFailed = -1006, NSURLErrorHTTPTooManyRedirects = -1007, NSURLErrorResourceUnavailable = -1008, NSURLErrorNotConnectedToInternet = -1009, NSURLErrorRedirectToNonExistentLocation = -1010, NSURLErrorBadServerResponse = -1011, NSURLErrorUserCancelledAuthentication = -1012, NSURLErrorUserAuthenticationRequired = -1013, NSURLErrorZeroByteResource = -1014, NSURLErrorCannotDecodeRawData = -1015, NSURLErrorCannotDecodeContentData = -1016, NSURLErrorCannotParseResponse = -1017, NSURLErrorAppTransportSecurityRequiresSecureConnection NS_ENUM_AVAILABLE(10_11, 9_0) = -1022, NSURLErrorFileDoesNotExist = -1100, NSURLErrorFileIsDirectory = -1101, NSURLErrorNoPermissionsToReadFile = -1102, NSURLErrorDataLengthExceedsMaximum NS_ENUM_AVAILABLE(10_5, 2_0) =	-1103, // SSL errors NSURLErrorSecureConnectionFailed = -1200, NSURLErrorServerCertificateHasBadDate = -1201, NSURLErrorServerCertificateUntrusted = -1202, NSURLErrorServerCertificateHasUnknownRoot = -1203, NSURLErrorServerCertificateNotYetValid = -1204, NSURLErrorClientCertificateRejected = -1205, NSURLErrorClientCertificateRequired =	-1206, NSURLErrorCannotLoadFromNetwork = -2000, // Download and file I/O errors NSURLErrorCannotCreateFile = -3000, NSURLErrorCannotOpenFile = -3001, NSURLErrorCannotCloseFile = -3002, NSURLErrorCannotWriteToFile = -3003, NSURLErrorCannotRemoveFile = -3004, NSURLErrorCannotMoveFile = -3005, NSURLErrorDownloadDecodingFailedMidStream = -3006, NSURLErrorDownloadDecodingFailedToComplete =-3007, NSURLErrorInternationalRoamingOff NS_ENUM_AVAILABLE(10_7, 3_0) = -1018, NSURLErrorCallIsActive NS_ENUM_AVAILABLE(10_7, 3_0) = -1019, NSURLErrorDataNotAllowed NS_ENUM_AVAILABLE(10_7, 3_0) = -1020, NSURLErrorRequestBodyStreamExhausted NS_ENUM_AVAILABLE(10_7, 3_0) = -1021, NSURLErrorBackgroundSessionRequiresSharedContainer NS_ENUM_AVAILABLE(10_10, 8_0) = -995, NSURLErrorBackgroundSessionInUseByAnotherProcess NS_ENUM_AVAILABLE(10_10, 8_0) = -996, NSURLErrorBackgroundSessionWasDisconnected NS_ENUM_AVAILABLE(10_10, 8_0)= -997, }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43cb6f2f60bd0ec0f8f9007799e0b2ce/" rel="bookmark">
			Criteria联合分组查询&#43;bject转对象，java实现Object转实体类备忘录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Criteria分组查询，拿到的结果集中只有id,recordDate,device_id三个值：
Criteria crit = deviceRecordDao.getSession().createCriteria(DeviceRecord.class); ProjectionList proList = Projections.projectionList(); crit.setFetchMode("device", FetchMode.JOIN); crit.setFetchMode("deviceRecord", FetchMode.JOIN); crit.createAlias("device", "device"); crit.createAlias("device.office", "office"); crit.add(dataScopeFilter(user, "office", "", true)); crit.add(Restrictions.eq(DeviceRecord.FIELD_DEL_FLAG, DeviceRecord.DEL_FLAG_NORMAL)); crit.add(Restrictions.eq("device.delFlag", DeviceRecord.DEL_FLAG_NORMAL)); crit.addOrder(Order.desc("recordDate")); proList.add(Projections.id()); proList.add(Projections.max("recordDate")); proList.add(Projections.groupProperty("device.id")); crit.setProjection(proList); List results = crit.list(); results返回的是一个Object类型，要把它转换成相应的实体类：
List&lt;DeviceRecord&gt; topicList2 = Lists.newArrayList(); for(int i=0;i&lt;results.size();i++){ DeviceRecord dr = new DeviceRecord(); Object[] obj = (Object[]) results.get(i); dr.setId(obj[0].toString()); topicList2.add(dr); } return topicList2; 完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f710b858e986f5922f195b7f46a1336/" rel="bookmark">
			udhcpc 和 udhcpd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载： http://blog.csdn.net/hshl1214/article/details/8684740
由于要使用网络通讯，所以不可避免的要用到dhcp。理想的网络通讯方式是下面3种都要支持:
1,接入已有网络。这便要求可以作为dhcp客户端。
2,作为DHCP服务器，动态分配IP。
3,指定固定IP
第3种情况没有什么好说的，简单说下前2种情况。
使用步骤：
（1）在内核的网络项里面把DHCP配置上；
（2）在busybox里面把[*]udhcp server(udhcpd)
[*]udhcp client(udhcpc)都选上。
udhcpd就是终端设备作为DHCP服务器
udhcpc就是终端设备作为DHCP客户端
busybox里面对dhcp都已经给出例子了，
[zhh@localhost busybox-1.14.1]$ ls ./examples/udhcp/
sample.bound sample.deconfig sample.nak sample.renew sample.script simple.script udhcpd.conf
比如使用udhcpc时
就可以直接把simple.script拿来使用，改不改名字都可以，busybox里面默认的目录文件是/usr/share/udhcpc/default.script
可以查看下帮助
# udhcpc --help
BusyBox v1.14.1 (2010-01-22 10:35:16 CST) multi-call binary
Usage: udhcpc [-Cfbnqtvo] [-c CID] [-V VCLS] [-H HOSTNAME] [-i INTERFACE]
[-p pidfile] [-r IP] [-s script] [-O dhcp-option]... [-P N]
-V CLASSID Vendor class identifier
-i INTERFACE Interface to use (default: eth0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f710b858e986f5922f195b7f46a1336/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29d7132a04db798986965e47cfcf9f0c/" rel="bookmark">
			【caffe学习笔记】Common Layers 普通层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内积／全连接 Inner Product InnerProduct 层（也被称作全连接层）将输入看成一个一向量，输出也为向量（输出 blob的高和宽都为1）。 层类型: InnerProductCPU 实现码: ./src/caffe/layers/inner_product_layer.cppCUDA GPU 实现代码: ./src/caffe/layers/inner_product_layer.cu 参数 Required（必须的参数） num_output (c_o): 层的输出节点数或者理解为滤波器的个数 Strongly Recommended（强力推荐） weight_filler [default type: 'constant' value: 0]: 参数的初始化方法 Optional（可选的） bias_filler [default type: 'constant' value: 0] bias_term [default true]: 指定是否给每个滤波器添加并训练偏置项 输入 n * c_i * h_i * w_i 输出 n * c_o * 1 * 1 例子： layer { name: "fc8" type: "InnerProduct" # learning rate and decay multipliers for the weights param { lr_mult: 1 decay_mult: 1 } # learning rate and decay multipliers for the biases param { lr_mult: 2 decay_mult: 0 } inner_product_param { num_output: 1000 weight_filler { type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29d7132a04db798986965e47cfcf9f0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99eb2b38eb8e547835d9a77ec1e18ef7/" rel="bookmark">
			MSP430
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初始化： 一个有4中复位和初始化：1.上电；2.RST脚拉低;3.看门狗超时4.WDTCTL寄存器写入时密钥不符。
上电的复位：
IO变成输入状态 IO标志全被复位
复位向量地址0FFFE指向的地址加载PC，CPU从这个地址开始运行
SR清除
用户程序要对出PC和SR的寄存器初始化，如SP、RAM
工作频率的系统时钟从DC0的最低频率开始工作。
复位脚的功能在上电后才能使用：
状态与上电复位的相似
中断： 共3类中断：
系统复位（上面的复位源），非屏蔽中断（NMI模式的上升源，振荡故障，），可屏蔽中断（看门狗定时模式溢出，其他模块中断）
越接近CPU的模块中断优先级越高。
RST/NMI引脚的功能选择在看门口定时器WDTCTL中的BIT5：0=RST，1=NMI 。bit6选择NMI的有效边沿，0升，1降。
振荡器在晶振失效时也能持续工作，但将运行在可能的最低频率上。
MSP430的中断可由处理机的运行状态来启，每个中断源都可用中断允许位单独关闭。可以设置中断允许位GIT的值来禁止全部中断在SR的bit3。
大多数中断控制位、中断标志和中断允许位都几种在少数几个SFR中，这些SFR以字节形式位于低地址区，只能以字节指令访问，0000-0005
中断允许1,2
IE1：bit0 WDTIE看门狗定时器模式允许位再看门狗模式无效，bit1OFIE 振荡器故障中断允许，bit2POIE.0 针对IO P0.0，bit3POIE.1针对IO P0.1或8位定时器/计数器,初始状态均为复位
IE2: bit0 URXIE，USART接收中断允许，bit1UTXRIE ，USART发送中断允许，bit2:ADC或定时器端口中断允许，bit3TPIE定时器/端口，bit7 BTIE basic timer中断允许，初始状态均为复位
中断状态寄存器1、2
IFG1：bit0 WDTIFG初始状态不变， 溢出或密钥不符时置位，VCC上电或RST/NMI引脚有复位条件。 bit1OFIFG,振荡器发生故障时置位（初始1）bit2，POIFG.0初始复位，针对IO/P0.0，bit3POIFG.1，初始复位，针对IO P0.1或8位定时器/计数器,bit4：NMIIFG RST/NMI的引脚信号，
IFG2：bit0：URXIFG串口接收标志，bit1：串口发送就绪标志。bit2:ADIFG:ADC转换结束置位，bit7BTIFG ：Basic Timer标志。
模块允许：
ME1：全未定义
ME2:bit0：串口接收允许，bit1：串口发送允许。
中断向量地址 中断向量和上电地址位于ROM中的0FFFF-0FFE0中
一个允许的中断唤醒MSP430就会进入中断程序开始处理，而从中断程序返回的方法有1：置位低功耗模式后返回（PC指向下一条指令）；2复位低功耗模式（程序对SR中的0sc0ff或CPU0ff置位的指令之后的地址继续执行）
外部中断：
P0，P1，P2的所有位都可以实现外部中断，外部中断信号必须具有至少1.5MCLK的脉冲宽度。
MSP430医用有5种运行模式，可以由软件组合。
而低功耗模式中各模块的选择也有多达5中可能的省电模式。
IO口 1.通用IO口P0：所以功能可以按引脚单独选择，每个信号可以作为中断源，6个寄存器用于IO端口IO引脚：
除了中断标志寄存器和中断允许寄存器的最低2位再SFR外（就是说是6位），其他寄存器值均为8位。 输入输出，方向都是每个位代表每一只脚。而中断标志寄存器只有对应P0.2-P0.7是否有中断，剩下两个位再SFR寄存器，中断允许寄存器也一样。中断触发选择寄存器也是对应每只IO脚，0为低跳高，1为高跳低。
P0.3-P0.7所有功能结构完全一样。
P0.2的区别是它的输出信号既可由P0UT.2寄存器决定，也可以由定时器/计数器的信号TXD决定。当输出控制寄存器的输出TXE位被置1时，TXD信号被选择成为输出信号，同时Pad逻辑切换输出，这时，引脚反向与P0DIR.2无关。
P0.1的区别是这个脚的中断源可以是该脚的输入，也可以是定时器/计数器的进位。当定时器/计数器控制器TCCTL中的中断源控制位ISCTL置位，中断源便从端口P0.1的输入信号切换至定时器/计数器的进位信号。也是自己一个中断向量
P0.3-P0.7都是用同一个中断向量，而P0.0是单独一个中断向量。
P1，P2多了一个读写的功能选择寄存器P1SEL,P2SEL，每个寄存器都有独立的8位定义IO口功能，0：端口功能，端口的输入输出，1：模块功能，模块的输入输出。P1，P2的所有脚功能没有区别，中断时标志位不会自动复位。
模块功能时，引脚输入的信号传入对应的外围模块，当PnSEL.x复位，输入模块的信号将保持最后输入的电平（钳住），将复位的控制置位，如果保持的电平与引脚电平同会改变输入模块的信号。
P3和P4只有4个寄存器，输入，输出，方向，端口功能选择。
LCD端口：用处驱动LCD显示，LCD控制器的3位LCDM5，6,7控制所有功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63468de78e8f08466e3d61635c7c0ed9/" rel="bookmark">
			采集数据命令备忘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 采集CPU数据，每隔2秒采集一次，采集500次。缺点是不知道哪个进程造成的CPU消耗 vmstat -n 2 500 &gt; cpu.txt &amp; 2. 采集网卡数据。每隔2秒采集一次，采集500次 sar -n DEV 2 500|grep eth0 &gt; net.txt &amp; 3. 采集内存数据。每隔5秒采集一次，采集200次。JAVA内存一般变化频率不大，采集间隔过小意义不大 该命令优点是可以看到JAVA进程内部内存的详细分配情况，缺点是看不到直接内存（堆外内存） jstat -gc ${java_pid} 5000 200 &gt; mem.txt &amp; 4. 采集CPU数据。每隔2秒采集一次，采集86400次。优点是能看到JAVA进程本身消耗的CPU，与vmstat命 令配合可以判断出CPU飙升到底是JAVA进程本身造成的还是其他进程造成的 pidstat -p ${java_pid} 2 86400 &gt; cpu2.txt &amp; 5. 采集内存数据。每隔5秒采集一次，采集34560次， 优点是包含了JAVA进程的直接内存，与jstat配合使用 可以获得JAVA内存的完整情况 pidstat -r -p ${java_pid} 5 34560 &gt; mem2.txt &amp; 以上命令采集到的数据可以直接复制到excel中，分列后 使用excel的图表功能生成折线图，看起来非常方便. 注意如果数据量比较大（几十M，几十万上百万数据）的话最好使用microsoft excel , wps 对于大文件可能直接崩溃或者打开非常缓慢简直弱爆了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f02947c422cc8ca2afdd8d6de5b0974/" rel="bookmark">
			阿贾克斯和jQueryui的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、localhost:8088
2、127.0.0.1
3、1~1024之内是被系统预留的，端口号是唯一的标识
4、每个程序员把不变的东西抽离出来了
5、做数据库链接时，做工具类能适配各种数据库，归根到底还是反射机制？
6、多线程、高并发、反射、
7、从服务器端把文件加载到本地，.url是选择器
8、load第三个参数是回调函数哦，第一个是参数路径
9、response是服务器给我返回的数据
10、返回值成功是success，否则是error
11、xhr包含了第一个和第二个参数哦
12、一般样式放在js下面
13、回调函数可以不写，可是没有用
14、post不能使用？传参，多个值使用花括号，中间隔个逗号，第四个参数是服务器返回的格式，一般不要指定，服务器知道返回什么，返回的是纯文本，写text或者html，这个是默认的
15、get的有多个参数，在第二个地方加一个&amp;符号，而且用冒号传参
16、底层刷新：Ctrl+F5
17、xml是用来存储和传输数据的标签语言，html是浏览器展示效果的标签语言
18、response正常情况下是xml对象
19、xml解析：$(response).find('root').find('url').text()
20、json解析:response[index].url
21、动态加载JS代码：$.getScript（'test.js'）从远程加载进来的，
22、从服务器端加载Js,有需要才加载，有利于节约资源
23、ajax只有路径参数是必须的，值之间用英文逗号隔开，叫无刷新页面数据格式技术
24、form input[type = button]选择器
25、原生js是.value,jQuery是.val()
26、 表单序列化以后会把所有数据都提交给服务器
27、input序列化了以后就是一个字节
28、decodeURIComponent() 把这个字节转回来 incodeURI
29、如何进行服务器端的编解码is 重要
30、$.ajaxSetup(),里面放的是需要重复用的东西，需要反复提交的东西用到，序列化一次就好了
31、浏览器存储不超过20k
32、 jQueryUI的知识 依附于jQuery的插件，高效且美观，兼容性好且好用
要导入jQuery、jQuery-ui两个js文档
33、 只要加一句选择器.使用样式就好了
34、demo:实例；doc是说明
35、 themeroller可以下载jQueryUI插件样式,放到css文档中，然后link进去的地方修改名称
36、accordion:折叠、百叶窗效果
Autocomplete：自动完成
37、Ajax默认get请求
转载于:https://www.cnblogs.com/ailsalin/p/6445078.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c47c91ab44445ed376cecd35034a843d/" rel="bookmark">
			linux下安装oracle客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		'1、下载地址 http://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html oracle-instantclient11.2-basic-11.2.0.4.0-1.x86_64.rpm oracle-instantclient11.2-devel-11.2.0.4.0-1.x86_64.rpm
2、安装
rpm -ivh oracle-instantclient11.2-basic-11.2.0.4.0-1.x86_64.rpm rpm -ivh oracle-instantclient11.2-devel-11.2.0.4.0-1.x86_64.rpm 3、在/etc/ld.so.conf里添加oracle客户端的lib路径 echo '/usr/lib/oracle/11.2/client64/lib/' &gt; /etc/ld.so.conf 4、添加环境变量 vim etc/profile export ORACLE_HOME=/usr/lib/oracle/11.2/client64/ export LD_LIBRARY_PATH=/usr/lib/oracle/11.2/client64:$LD_LIBRARY_PATH export NLS_LANG="AMERICAN_AMERICA.AL32UTF8" source /etc/profile 5、64位要添加32位的软链接 ln -s /usr/lib/oracle/11.2/client64 /usr/lib/oracle/11.2/client ln -s /usr/include/oracle/11.2/client64 /usr/include/oracle/11.2/client 6、PHP模块pdo_oci对oracle11支持不足需添加软链接 ln -s /usr/include/oracle/11.2 /usr/include/oracle/10.2.0.1 ln -s /usr/lib/oracle/11.2 /usr/lib/oracle/10.2.0.1 7、php连接oracle
php -r '$con = oci_connect("username","password","(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=192.168.1.10)(PORT=1521))(CONNECT_DATA=(SID=ora11g)))","utf8");var_dump($con);'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7c665838ffa83e30e05cde4b2b28a0b/" rel="bookmark">
			BeautifulSoup基本用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BeautifulSoup是Python的一个库，最主要的功能就是从网页爬取我们需要的数据。BeautifulSoup将html解析为对象进行处理，全部页面转变为字典或者数组，相对于正则表达式的方式，可以大大简化处理过程。
0x01 安装 建议安装BeautifulSoup 4版本 利用pip进行安装:
pip install beautifulsoup4 BeautifulSoup默认支持Python的标准HTML解析库，但是它也支持一些第三方的解析库：
序号解析库使用方法优势劣势1Python标准库BeautifulSoup(html,’html.parser’)Python内置标准库；执行速度快容错能力较差2lxml HTML解析库BeautifulSoup(html,’lxml’)速度快；容错能力强需要安装，需要C语言库3lxml XML解析库BeautifulSoup(html,[‘lxml’,’xml’])速度快；容错能力强；支持XML格式需要C语言库4htm5lib解析库BeautifulSoup(html,’htm5llib’)以浏览器方式解析，最好的容错性速度慢 0x02 创建对象 导入库：
from bs4 import BeautifulSoup 创建实例：
url='http://www.baidu.com' resp=urllib2.urlopen(url) html=resp.read() 创建对象：
bs=BeautifulSoup(html) 格式化输出内容：
print bs.prettify() 0x03 对象种类 BeautifulSoup将复杂的html文档转换为树形结构，每一个节点都是一个对象，这些对象可以归纳为几种：
（1）Tag
Tag相当于html种的一个标签：
#提取Tag print bs.title print type(bs.title) 结果：
&lt;title&gt;百度一下，你就知道&lt;/title&gt; &lt;class 'bs4.element.Tag'&gt; 对于Tag，有几个重要的属性：
name:每个Tag对象的name就是标签本省的名称； attrs:每个Tag对象的attrs就是一个字典，包含了标签的全部属性。
print bs.a.name print bs.a.attrs 输出：
a {u'href': u'/', u'id': u'result_logo', u'onmousedown': u"return c({'fm':'tab','tab':'logo'})"} （2）NavigableString
Comment是一种特殊的NavigableString，对应的是注释的内容，但是其输出不包含注释符。看这样的一个例子：
#coding:utf-8 from bs4 import BeautifulSoup html=''' &lt;a class="css" href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7c665838ffa83e30e05cde4b2b28a0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe5bb9d3f6b20e6d3bfa87cb8ce6ccb3/" rel="bookmark">
			JAVA中3种将byte转换为String的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 byte b = 65; （一） String s=Byte.toString(b); （二） String s=b + ""; （三） String s=new String(new byte[] {b}); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbb510708fe489b6a681a706243d1ed4/" rel="bookmark">
			win10界面僵卡，原来是这样原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚开始是W7，用激活软件成功激活，后来直接免费升级到10，中间一段时间挺好，也许过了有效期，总觉得电脑鼠标不能控制，只有移动，不能点击，窗口界面不能控制，就类似未激活的office,很多都是灰色选项，当时以为是中了灰鸽子，折腾了好久，把注册表，日志，都跟了2天。前提是，我电脑提示已激活，我并未想到，这个激活是无效的。后来发现有包不停的注入，跟踪了下，是美国的服务器，可能是更新吧，我想当然的以为是，但是后来简直每3秒就在卡，我就坐不住了，百度了一推卡死的原因，发现都提到激活。我已经激活了吗/，难道，我又找了一个，接着激活，现在几乎可以正常使用。但时，日志中依然有很多包发来，发出，但是没有太多关于安全策略更改的包了，最多就是网络发现。
第一：激活&lt;
第二，更新驱动
发现偶尔还是会有卡死的现象，但是不是很频繁，我又开始卸载软件，第一个就是360，然后打开系统的更新，然后病毒防护未打开，接着，电脑速度就特别快了，我内存2G,不仅安装了VS2012,还有ORACLE 11R2，是不是非常的厉害，这个操作系统除了开机快，重装的效率也是一流的。所以我会定时备份，然后尽量保持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e36bfa6ed0889d028ed9ddec5e27985c/" rel="bookmark">
			面向对象编程与面向过程编程的区别（翻译版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象编程与面向过程编程的区别（翻译版） 我们知道现在存在着两种不同的编程方式-1) 面向过程编程（POP）以及2）面向对象编程。我们可以任意选择一种方式来编写程序，但是我们得知道这两种编程方式的区别。这两种编程方式是软件开发历经几十年发展的结果。从计算机被发明起，人们尝试了很多方法来编写程序，例如a）自顶向下编程；b）自底向上编程；c）模块化编程；d）结构化编程等等。这些方法的根本目的只有一个-“使编程更加高效”-即让编写一个复杂的程序变得简单、自由、bug少、易于理解、易于扩展、易于修改等等。
简单来说，POP与OOP之间的区别可以这样解释：-一个程序员可以用POP编写一个困难程度一般的复杂程序，但是当程序变得更加复杂的时候，此时用POP将比较低效率，整个编程过程将更加艰难，花费更多时间，有更多的bug，花更多的时间debug等等。而在同样复杂度下，OOP比POP高效得多。在软件开发中，业界都遵循OOP原则，因为OOP使团队协作编程变得简单。同时，OOP具有较高的代码重用性。
面向过程编程 这里“过程”一次值得特别注意。过程可以理解为子程序的集合或者函数的集合。我们都知道C语言中的函数。C是一个典型的面向过程语言。在面向过程编程中，强调的是函数或者子程序。函数是指令的集合，用于执行某个特定的任务。在程序中，函数被重复调用来执行任务。例如，一个程序可能包括收集用户数据（读），对用户数据进行计算（计算），呈现计算结果（打印）。这三个读、计算、打印能通过3个不同的函数来实现。
面向过程编程示意图 面向过程编程最大的问题在于数据处理。面向过程完全不重视数据。这里的数据指从用户收集到的信息、程序的计算结果等等。如果你熟悉C语言，你可能会想起C语言中的存储类别。在C语言中，为了一个或者多个函数可以访问变量， 这个变量必须被声明为全局变量。如果这个程序有10个函数，每个函数都可以访问这个变量，那么其中一个函数就有可能不小心修改了这个变量，如果这个变量是程序的一个重要变量，那么任意一个不小心的操作就有可能毁了整个程雪。而且，当程序很庞大时，这种bug很难定位到是哪个函数出了问题。
面向过程编程中的数据以及函数示意 结构体是C语言的一个重要特性。结构体提供了一种把不同数据类型打包成一个新类型的方式。程序员可以用结构体把整数、浮点数、数组等类型打包成一个新的类型。结构体一引入C语言就收到了广泛的好评和认可。这是因为结构体很好地把现实世界的需求映射到程序当中。结构体的问题在于它只处理数据。 结构体不允许打包与数据相关联的函数，所有相关联的函数必须写在结构体之外。因此，C程序过度依赖于函数。
总的来说，在面向过程编程中，问题被看成过程的有序组合，例如读、计算、展示结果等等过程。以面向过程来思考为时，首先把问题分解成一系列过程，每个过程可以对应一个或者多个函数，实现所有的函数，问题就被解决了。
面向对象编程
面向对象编程与面向过程编程有本质的不同。面向对象编程保留每结构化编程的所有优点，并且引入了许多促提高编程效率的新特性。这些新特性使我们可以以一种全新的方式去编程。下面介绍这些新特性。
1） 面向对象编程的第一个特性是数据隐藏。面向对象编程很重视数据。采用面向对象编程，程序员可以避免核心数据暴露在外。类（class）是面向对象编程的基本概念，类类似于面向过程编程中的结构体。类用于打包不同的数据类型以及对这些数据的操作函数。类中的数据成员可以是私有的（private）或者公有的(public)。为了避免数据暴露在外，程序员可以把数据声明为私有的。类与C语言中的结构体很相似，都是打包不同的数据类型。它们之间的主要区别在于函数。结构体不允许一起打包数据以及相应的处理函数而类允许。并且结构体并不支持数据隐藏，结构体中的数据成员可以任意访问。面向对象编程中的数据隐藏称为数据封装。面向过程编程的主要缺陷（忽视数据）在面向对象编程中得到了解决。面向对象编程把数据绑定到类以及类的对象上去，因此也就不再需要全局数据类型，因此避免了全局变量的偶然修改导致的严重错误。
面向对象编程中的对象示意图 2）面向对象编程的另一个特点是代码重用。面向对象编程的继承特性使代码重用变得可能。通过继承，一个类能够获得另一个类的特性。除此以外，面向对象编程的新特性还有多态，动态绑定等等，这些都提高了代码的重用性。
以上翻译自http://www.circuitstoday.com/difference-between-procedure-oriented-and-object-oriented-programming
面向过程编程与面向对象编程的区别（个人理解）
1）从思维方式上来讲，是对现实问题的建模方式不同。面向过程编程把问题分解成一个个过程，一步步实现这些过程，问题就得到了解决。而面向对象编程把问题看成一系列对象之间的交互，设计出这些对象以及对象之间的交互，问题就得到了解决。
2）从程序的本质上来讲，是对算法以及数据的重视程度的不同。程序的本质是算法和数据。面向过程编程重视算法，忽视数据。面向对象编程侧重点在数据，对算法的重视程度不如面向过程编程。对数据的重视，使面向对象编程具有继承，封装，多态等特性，在各方面提高了编程的效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa261f44a79acb49320e7ddaf32570ef/" rel="bookmark">
			详细介绍opencv3.0&#43;visio studio2015&#43;win10环境配置至出成果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		opencv是一套图像处理应用十分广泛的计算机图像处理分析“开源计算机视觉库”
本篇介绍的是opencv3.0和vs2015的环境配置
1.下载opencv3.0和vs2015.下载链接我就不给了。上bing百度关键词就可以了。我都是官网下载的，我的vs是2015professional版本
opencv现在最新的应该是3.2，但是download点进去之后往下翻有3.0版本。找不到可以留言问我。因为每个版本配置都有细小差别，为了避免不必要的麻烦。最好就用这两个版本。
vs安装我就不说了，有的同学说安装时候卡在某个地方不动了，卡了好久，这个是因为你没挂vpn有些东西装不上，把网断了重连就好了，你等多久这个也装不上。
opencv直接双击找个路径extract
我选的是D:\programing_software。这个会自动创建一个名为opencv的文件夹东西extract到里面，所以我路径就到这。
2.接下来配置环境变量
我的电脑（计算机）右击-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量里的Path
win10可以直接新建环境变量，那么添加两个，这个跟你的路径有关，自己添加时候注意找下这个文件夹把路径复制过来就好了
D:\programing_software\opencv\build\x64\vc12\bin
D:\programing_software\opencv\build\x86\vc12\bin
3.打开vs2015，新建-&gt;项目-&gt;win32控制台应用程序
单击下一步之后把空项目选中，确认即可。
4.接下来就很重要了，我们要开始真正的难点了，先点击视图-&gt;其他窗口-&gt;属性管理器，把我截图左边这个东西调出来
然后直接在这个项目ConsoleApplication1上右击，选择属性，
4.1.1 vc++目录-&gt;可执行文件目录，编辑加入
D:\programing_software\opencv\build\x86\vc12\bin
D:\programing_software\opencv\build\x64\vc12\bin
这个在你点击后会可以自己添加然后找路径的，最好自己找到x86和x64下的vc12的两个bin文件夹，而不要复制我的
4.1.2 还是vc++目录-&gt;包含目录，添加这三个最好也是自己浏览出来的
D:\programing_software\opencv\build\include
D:\programing_software\opencv\build\include\opencv
D:\programing_software\opencv\build\include\opencv2
4.1.3 vc++目录-&gt;库目录
D:\programing_software\opencv\build\x64\vc12\lib
D:\programing_software\opencv\build\x64\vc12\staticlib
每一个界面大概都像这样
4.2现在转到配置属性的链接器-&gt;输入，添加这两个，300代表版本，有的攻略会在300后面加个d，加d是debug用到东西，不加我测试时候是debug和release都可用。暂时不加，如果发现debug不能跑，再补上也行。
opencv_ts300.lib
opencv_world300.lib
5.那么到这里配置就告一段落了，接下来我们来测试
刚才建好的项目源文件-&gt;右击添加-&gt;c++文件，随便取个名字我的是 main.cpp。然后写下下面这一段
#include&lt;iostream&gt; #include&lt;opencv2/opencv.hpp&gt; using namespace cv; int main(){ // 读入一张图片（游戏原画） Mat img = imread("F:\\img\\9.jpg.jpg"); // 创建一个名为 "游戏原画"窗口 namedWindow("游戏原画"); // 在窗口中显示游戏原画 imshow("游戏原画", img); // 等待6000 ms后窗口自动关闭 waitKey(6000); }注意把（）里面改成自己的图片路径，这个会显示你的图片，如果到这里都没问题，你就成功了。可以试试第六条，如果失败了也不要急，请看注意事项
6.这是opencv很有意思的一个组合技，调用摄像头并且用canny方法抽象成线条，代码如下
#include&lt;iostream&gt; #include&lt;opencv2/opencv.hpp&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa261f44a79acb49320e7ddaf32570ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c90ec39f0397f4fa74858859d1de315c/" rel="bookmark">
			ArcGIS Engine中如何往已有要素类中插入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		您在Engine程序开发过程中是否遇到过要将新获取的数据向已有要素类中插入？对于数据插入的几种方法您是否清楚？各种方法的效率您对比过吗？今天我们讨论的话题为Engine中如何往已有要素类中插入数据，上述问题的答案会为您一一揭晓。
一、往已有要素类中插入数据的几种方式及其优缺点： 1，IFeatureClass.CreateFeature配合IFeature.Store使用。该方法在调用Store时会触发所有与Feature相关的行为，不但会触发IObjectClassEvents，还会触发涉及网络、注记要素，以及参与拓扑的要素等特殊的行为（比如向参加拓扑的要素类中添加要素后会自动创建dirty area）。
该方法在调用CreateFeature方法时，创建要素的OID，执行Store时将要素存入数据库中。
优点：代码简单； 缺点：效率低，如果仅仅插入几个要素或者进行测试而不考虑性能的话可以考虑。
2，IFeatureClass.CreateFeatureBuffer配合insert cursor使用。不会触发事件，该方法常常用来一次性插入大量要素，比第一种方法效率高很多。此外，IFeatureClass.Insert(bool useBuffering)方法中参数useBuffering建议总将其设为true，这样数据会先缓冲在客户端，然后执行Flush时批量写入，以提升效率。
该方法创建的IFeatureBuffer可以进行多次赋值，在执行InsertFeature时，创建要素的OID，但是此时数据并没有写入到数据库中，只有在执行IFeatureCursor.Flush时数据才会真正写入到数据库中。注意Flush方法是需要手动调用的，如果不执行，在程序释放或者Buffer满了会自动执行，但这样会无法检测错误，比如要素类空间不够了就会报错。
优点：效率高，尤其是插入大量数据时。如果仅就性能而言，除非插入一个要素，其余情况都推荐使用该方法； 缺点：代码相比第一种，稍显复杂，注意需要释放ICursor和IFeatureBuffer对象。
这里提一下，该方法中涉及到cursor的释放，有两种方法释放游标： a， 直接使用ComReleaser.ReleaseCOMObject(cursor); 或者Marshal.FinalReleaseComObject(cursor);
b， 使用using(){ }方式，如下：
using(ComReleaser comReleaser = new ComReleaser()) { // Create a feature buffer. IFeatureBuffer featureBuffer = featureClass.CreateFeatureBuffer(); comReleaser.ManageLifetime(featureBuffer); // Create an insert cursor. IFeatureCursor insertCursor = featureClass.Insert(true); comReleaser.ManageLifetime(insertCursor); … } 执行完using后会自动释放insertCursor和featureBuffer，可以避免程序比较复杂时不确定在哪释放或者忘记释放的情况，是比较优秀的编程方式，推荐使用。
3，使用Load-Only模式插入数据（SDE以及FileGDB都支持）。这种方法是对第二种方法的升级，主要用来在插入数据量特别大的情况下提高性能。Load-Only模式仅能用来插入新的要素，而不能用于编辑已有要素。原理是开启Load-Only模式后，插入数据时会停止更新空间索引和属性索引，解除Load-Only后才重建索引（重建索引是重建该要素类所有要素的索引，如果已有要素类中含有大量要素，而插入数据量不太大时，重建索引可能会影响性能）。开启Load-Only模式时，其它程序不能访问该数据，可以在获取排它锁之后设置Load-Only。如下：
// Cast the feature class to the IFeatureClassLoad interface. IFeatureClassLoad featureClassLoad = (IFeatureClassLoad)featureClass; // Acquire an exclusive schema lock for the class.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c90ec39f0397f4fa74858859d1de315c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872d58d644a55b6dfedd2d77baf4db33/" rel="bookmark">
			C#中方法参数的引用传递、值传递。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、值类型和引用类型 C# 中的类型一共分为两类，一类是值类型(Value Type)，一类是引用类型(Reference Type)。
值类型包括结构体(struct)和枚举(enum)。 引用类型包括类(class)、接口(interface)、委托(delegate)、数组(array)等。
常见的简单类型如short、int、long、float、double、byte、char等其本质上都是结构体，对应struct System.Int16、System.Int32、System.Int64、System.Single、System.Double、Syetem.Byte、System.Char，因此它们都是值类型。但string和object例外，它们本质上是类，对应class System.String和System.Object，所以它们是引用类型。
1. 值类型 值类型变量本身保存了该类型的全部数据，当声明一个值类型的变量时，该变量会被分配到栈(Stack)上。
2. 引用类型 引用类型变量本身保存的是位于堆(Heap)上的该类型的实例的内存地址，并不包含数据。当声明一个引用类型变量时，该变量会被分配到栈上。如果仅仅只是声明这样一个变量，由于在堆上还没有创建该类型的实例，因此，变量值为null，意思是不指向任何类型实例(堆上的对象)。对于变量的类型声明，用于限制此变量可以保存的类型。
二、值传递和引用传递 C#中方法的参数传递默认的是值传递，引用传递和输出传递需要在参数类型前面对应加上ref、out限制符，由于输出传递和引用传递类似，这里只讨论引用传递。
值传递参数是原变量的拷贝，值传递参数和原变量的内存地址不同，因此方法中对值传递参数的修改不会改变原变量。
引用传递参数是原变量的指针，引用传递参数和原变量的内存地址相同，相应的方法中对引用传递参数的修改会改变原变量。
三、传递值类型参数 1. 通过值传递值类型 class PassingValByVal { private static void Change(int x) { x = 10; System.Console.WriteLine("The value inside the method: {0}", x); } public static void Execute() { int n = 5; System.Console.WriteLine("The value before calling the method: {0}", n); Change(n); System.Console.WriteLine("The value after calling the method: {0}", n); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/872d58d644a55b6dfedd2d77baf4db33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f36a0b0db04bb557990eee1e61c09a/" rel="bookmark">
			python利用LSTM进行时间序列分析预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键词：Python、Keras、LSTM、Time-Series-Prediction
关于技术理论部分，可以参考这两篇文章（RNN、LSTM），本文主要从数据、代码角度，利用LSTM进行时间序列预测。 时间序列（或称动态数列）是指将同一统计指标的数值按其发生的时间先后顺序排列而成的数列。时间序列分析的主要目的是根据已有的历史数据对未来进行预测。
时间序列构成要素：长期趋势，季节变动，循环变动，不规则变动
长期趋势（ T ）现象在较长时期内受某种根本性因素作用而形成的总的变动趋势季节变动（ S ）现象在一年内随着季节的变化而发生的有规律的周期性变动循环变动（ C ）现象以若干年为周期所呈现出的波浪起伏形态的有规律的变动不规则变动（I ）是一种无规律可循的变动，包括严格的随机变动和不规则的突发性影响很大的变动两种类型 （1）原始时间序列数据（只列出了18行）
1455.219971 1399.420044 1402.109985 1403.449951 1441.469971 1457.599976 1438.560059 1432.25 1449.680054 1465.150024 1455.140015 1455.900024 1445.569946 1441.359985 1401.530029 1410.030029 1404.089966 1398.560059 （2）处理数据使之符合LSTM的要求
为了更加直观的了解数据格式，代码中加入了一些打印（print），并且后面加了注释，就是输出值
def load_data(filename, seq_len): f = open(filename, 'rb').read() data = f.split('\n') print('data len:',len(data)) #4172 print('sequence len:',seq_len) #50 sequence_length = seq_len + 1 result = [] for index in range(len(data) - sequence_length): result.append(data[index: index + sequence_length]) #得到长度为seq_len+1的向量，最后一个作为label print('result len:',len(result)) #4121 print('result shape:',np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34f36a0b0db04bb557990eee1e61c09a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c16c9db69efe8cbac4be45f057e4b95/" rel="bookmark">
			Jupyter notebook远程访问服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景 一直苦恼于本地机器和服务器上都要配置一些机器学习方面的环境，今天花了点时间研究了下Jupter notebook远程访问服务器，所以记录一下。
有些步骤非必须，这里尽量写清楚，读者理解后自行决定如何安装，本文以非root用户安装。
2.安装步骤 （1）登录服务器
（2）检查是否有安装jupyter notebook,终端输入jupyter notebook,如果报错就是没有啦，那么就要用下面命令安装。
$sudo pip install pyzmq $sudo pip install tornado $sudo pip install jinja2 $sudo pip install jsonschema $sudo pip install jupyter （3）生成配置文件
$jupyter notebook --generate-config （4）生成密码（后续写配置文件、登录Jupyter notebook需要）
打开python终端
In [1]: from IPython.lib import passwd In [2]: passwd() Enter password: Verify password: Out[2]: 'sha1:0e422dfccef2:84cfbcbb3ef95872fb8e23be3999c123f862d856' （5）修改默认配置文件
$vim ~/.jupyter/jupyter_notebook_config.py 进行如下修改（这里可以自行配置）：
c.NotebookApp.ip='*' c.NotebookApp.password = u'sha:ce...刚才复制的那个密文' c.NotebookApp.open_browser = False c.NotebookApp.port =8888 #随便指定一个端口 c.IPKernelApp.pylab = 'inline' （6）启动Jupter notebook
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c16c9db69efe8cbac4be45f057e4b95/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/536/">«</a>
	<span class="pagination__item pagination__item--current">537/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/538/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>