<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af84cffec260aa6598cfb2a80aad1871/" rel="bookmark">
			女网红靠GPT-4交1000&#43;男朋友，聊天按分钟收费，一周收入50万！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击“开发者技术前线”，选择“星标”
让一部分开发者看到未来
来自：量子位 | 公众号 QbitAI 注意看，这个女人叫卡琳，靠着GPT-4，她现在同时谈着1000+男朋友。
对，我知道事情听上去有些离谱。就连GPT-4自己，都直呼“我一个AI都觉得非常不常见”。
但是先别急，因为更让人挠头的事情还在后面……
在与“卡琳”相处的过程中，男友们每聊一分钟天，就要支付给她1美元。
并且就在我敲字这档口，候选男友列表的排队时间已经来到了47小时。
你可能已经开始疑惑，这位海后到底是利用GPT-4编织了什么样的甜言蜜语，能有这么大吸引力？那么，你多少是有点把事情想简单了……
事实上，这位在Snapchat上坐拥180万粉丝的网红，已经利用包括GPT-4在内的一波最新AI技术，直接给自己打造了一个AI分身——CarynAI。
△“第一位转变为AI的网红” 能陪聊天，会发靓照，随时来段语音也不是问题。
不仅能陪男友们从诗词歌赋谈到人生哲学，聊一些更亲（ca）密（bian）的话题也不是不可以……
港真，这操作，一天天高速冲浪的网友们都看呆了：
这妥妥的黑镜时刻啊。
这个AI女友，一周挣了50万 具体来说，卡琳和她的团队，是用她自己2000小时的YouTube视频内容，训练出了CarynAI。
官方说法是：
CarynAI拥有卡琳独特的声音、迷人的性格和特别的行为，能带来一种动态的、独一无二的互动，跟她交流就像是直接在和卡琳本人交流。
在打造CarynAI的过程中，他们还用上了当今最强AI GPT-4，以让数字版的卡琳足够逼真。
《财富》杂志的女记者亚历山德拉亲自会了会CarynAI，发现这个AI分身着实是多才多艺：
能聊时事新闻，很懂养生之道，还会夸出“你很适合当妈”这种话。
另外，亚力山德拉还亲测发现，CaryAI确实会聊着聊着就开始涉及一些不能播出的话题……
网红卡琳本人也透露，CarynAI打从测试以来，用户疯涨，其中99%都是男性用户。
而这些用户，在一周之内，就给这位网红贡献了71610美元 （折合人民币约50万）的收入。
她本人还预测，自己的180万关注者中，会有2万人成为CarynAI的付费用户。如此一来，AI每个月会给她带来500万美元的收入。
对于CarynAI，卡琳本人是这样说的：
我和我的粉丝们非常亲近，但现实决定我不可能跟每一个人都聊上天。
CarynAI会填补这个空白，还能治愈人们的孤独感。
背后公司打造过AI乔布斯 帮助卡琳“转变为AI”的，是一家名为Forever Voices的公司。
这家初创公司致力于打造各种名人的数字版，让用户可以直接在Telegram上“名人”们对话。
现在，在他们的Telegram上，可以选择的角色包括：乔布斯、泰勒·斯威夫特、马斯克……甚至还有爱因斯坦。
以乔布斯为例，效果是酱婶的：
不过，像CarynAI这样的AI女友，他们也是头一次做。
我拿这事儿问了问GPT-4，它显得挺忧虑，表示这么一件新技术引发的新鲜事儿，实际上涉及一系列有关人工智能伦理和人际关系的问题。
（ChatGPT还特别谈到了AI权利和自主性的问题）
而Forever Voices本身，显然也已经注意到了这个问题。据《财富》消息，这家公司的CEO John Meyer透露，他们正在寻找合适的人选担任首席道德官。
网友：细思极恐 一面是快速增长的用户，另一面，网友们围绕AI女友这个话题的讨论，也迅速热络起来。
有人觉得商机如此明显，这说不定会成为网红们的下一个重点副业。
但也有不少人对此感到担忧，认为这对人类来说属实有点细思极恐。
我早说过，当AI女友这种事儿变得广为人知，她们的吸引力会很快超过人类女友。
而更“技术”一些的讨论，画风则有逐渐清奇的趋势……
先来看正常版：
现在，我们只需要加上全息影像……
再来看看真正的脑洞：
— 完 — 点这里👇关注我，记得收藏订阅哦～ 历史推荐
OPPO宣布放弃自研芯片，ZEKU 全部解散！涉及3000人...
前端框架Svelte放弃TypeScript，JS赢！
MiniGPT4，开源了
好文点个在看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f2adc77cb121818e65ce31937358ca3/" rel="bookmark">
			OpenGL高级-实例化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点 假如你有一个有许多模型的场景，而这些模型的顶点数据都一样，只是进行了不同的世界空间的变换。想象一下，有一个场景中充满了草叶：每根草都是几个三角形组成的。你可能需要绘制很多的草叶，最终一次渲染循环中就肯能有成千上万个草需要绘制了。因为每个草叶只是由几个三角形组成，绘制一个几乎是即刻完成，但是数量巨大以后，执行起来就很慢了。
像这样绘制出你模型的其他实例，多次绘制之后，很快将达到一个瓶颈，这是因为你glDrawArrays或glDrawElements这样的函数(Draw call)过多。这样渲染顶点数据，会明显降低执行效率，这是因为OpenGL在它可以绘制你的顶点数据之前必须做一些准备工作(比如告诉GPU从哪个缓冲读取数据，以及在哪里找到顶点属性，所有这些都会使CPU到GPU的总线变慢)。所以即使渲染顶点超快，而多次给你的GPU下达这样的渲染命令却未必。
for(GLuint i = 0; i &lt; amount_of_models_to_draw; i++) { DoSomePreparations(); //在这里绑定VAO、绑定纹理、设置uniform变量等 glDrawArrays(GL_TRIANGLES, 0, amount_of_vertices); } 如果我们能够将数据一次发送给GPU，就会更方便，然后告诉OpenGL使用一个绘制函数，将这些数据绘制为多个物体。这就是我们将要展开讨论的实例化(Instancing)。
实例化是一种只调用一次渲染函数却能绘制出很多物体的技术，它节省渲染物体时从CPU到GPU的通信时间，而且只需做一次即可。要使用实例化渲染，我们必须将glDrawArrays和glDrawElements各自改为glDrawArraysInstanced和glDrawElementsInstanced。这些用于实例化的函数版本需要设置一个额外的参数，叫做实例数量(Instance Count)，它设置我们打算渲染实例的数量。这样我们就只需要把所有需要的数据发送给GPU一次就行了，然后告诉GPU它该如何使用一个函数来绘制所有这些实例。
就其本身而言，这个函数用处不大。渲染同一个物体一千次对我们来说没用，因为每个渲染出的物体不仅相同而且还在同一个位置；我们只能看到一个物体！出于这个原因GLSL在着色器中嵌入了另一个内建变量，叫做gl_InstanceID。
在通过实例化绘制时，gl_InstanceID的初值是0，它在每个实例渲染时都会增加1。如果我们渲染43个实例，那么在顶点着色器gl_InstanceID的值最后就是42。每个实例都拥有唯一的值意味着我们可以索引到一个位置数组，并将每个实例摆放在世界空间的不同的位置上。
我们调用一个实例化渲染函数，在标准化设备坐标中绘制一百个2D四边形来看看实例化绘制的效果是怎样的。通过对一个储存着100个偏移量向量的索引，我们为每个实例四边形添加一个偏移量。最后，窗口被排列精美的四边形网格填满：
效果展示：
顶点着色器：
#version 330 core layout (location = 0) in vec2 position; layout (location = 1) in vec3 color; out vec3 fColor; uniform vec2 offsets[100]; void main() { vec2 offset = offsets[gl_InstanceID]; gl_Position = vec4(position + offset, 0.0f, 1.0f); fColor = color; } 片段着色器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f2adc77cb121818e65ce31937358ca3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/710bbef7659125b33c4cdd761a76e8fa/" rel="bookmark">
			java的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型 1.1. 数据类型有什么用?
数据类型用来声明变量,程序在运行过程中根据不同的数据类型分配不同大小的空间.
int i = 10 ;
double d = 1.23;
i 变量和 d 变量类型不同,空间大小不同.
1.2 数据类型在java 语言中包括两种:
第一种: 基本数据类型
​ 基本数据类型又可以划分为4大类8小种:
​ 第一类: 整数型
​ 第二类: 浮点型
​ 第三类: 布尔型
​ 第四类:字符型
8小种:
​ byte ,short,int ,long
​ float, double
​ boolean
​ char
第二种:引用数据类型
​ 字符串型string 属于引用数据类型
​ string 字符串不属于基本数据类型范畴.
​ java 中除了基本数据类型之外,剩下的都是引用数据类型.
​ 引用数据类型后期面向对象的时候才会接触
1.3. 8种基本数据类型
​ 关于计算机存储单位:
​ 1字节 = 8bit
​ 1bit 就是一个1或0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/710bbef7659125b33c4cdd761a76e8fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef90160a6d56e34d5d61ff266b989940/" rel="bookmark">
			etiger323
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;bits/stdc++.h&gt; using namespace std; int main() { freopen ("assignment.in", "r", stdin); freopen ("assignment.out", "w", stdout); map&lt;string,int&gt;d; map&lt;string,int&gt;::iterator it; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { string	name; int score; cin &gt;&gt; name &gt;&gt; score; if (d.count(name) == 0 || score &gt;=d[name]) { d[name] = score; } }int ans=0; for (it = d.begin(); it != d.end(); ++it) {ans++	; }cout&lt;&lt;ans&lt;&lt;endl; for (it = d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef90160a6d56e34d5d61ff266b989940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5249d2c260a5d892343afd01a188a1e5/" rel="bookmark">
			C语言--通过指针引用数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言–通过指针引用数组 文章目录 C语言--通过指针引用数组前言1.引用数组元素时指针的运算2.通过指针引用数组元素引用数组的方式示例：用三种方法输出元素中的全部元素。方法一：直接引用a[i]方法二：间接引用-通过数组名计算数组元素地址，找到元素的值方法三：间接引用-通过指针变量指向数组元素变3：间接引用-通过指针变量指向数组元素 易混点：`*(p++)`和`*(++p)`和`*p++` 3.用数组名作为函数参数例：将数组a中的n个整数按相反顺序存放方法1:利用数组作为形参方法2：利用指针变量作为形参方法3：利用指针变量作为实参 例：用指针方法对10个整数按由大到小的顺序排序 总结 前言 指针不仅可以指向变量，也可以指向数组，数组元素在内存中占用存储单元，因此他们都有相应的地址，用指针指向数组元素就是数组元素的地址。
int a[5] = {1,2,3,4,5};//定义5个整型数据的数组a int *p;//定义一个整型变量的指针 p=&amp;a[0];//把a[0]的地址赋给指针p 数组名代表数组的首地址，序号为0的元素，也代表数组的首地址
p=&amp;a[0];	//P的值是a[0]的地址 等价于 p=a;	//p的值是数组a首元素（即a[0]）的地址 数组名仅仅代表数组首元素的地址
对指针变量进行初始化
int *p=&amp;a[0]; 等价于 int *p; p = &amp;a[0]; 也可以写成 int *p = a;//把a数组的首地址(a[0])赋给指针变量p而不是*p; 提示：以下是本篇文章正文内容，下面案例可供参考
1.引用数组元素时指针的运算 在指针指向数组元素时，指针变量p指向数组元素a[0]，p+1表示指向下一个元素a[1]。这样对引用数组元素提供很大的方便。
可以做如下运算：
加一个整数（+或+=），如p+1;减一个整数（-或-=），如p-1;自加运算，如p++，++p;自减运算，如p- -，- -p; 两个指针相减，如p1-p2，只有在p1和p2都指向同一个数组中的元素才有意义
具体说明如下：
（1）如果指针变量P已指向数组中的一个元素，则P+1指向数组中的下一个元素，p-1指向同一数组的上一个元素，p+1并不是将p的地址简单的加1，而是加上一个数组元素所占用的字节数，例如，数组元素是float类型，每个元素占4个字节，p+1意味着使p的地址加4个字节，便于指向下一个元素。p+1所代表的地址实际上是p+pxd，d是一个数组元素所占的字节数。如p的地址是2000，则p+1的值是2000+4=2004，而不是2001。
在定义指针类型时，已经规定了该指针的类型，所以在进行加减时，是根据定义的数据来计算。
（2）当p指向&amp;a[0]时，p+i和a+i是数组元素a[i]的地址，即指向a数组序号为i的元素。计算方法和p+1相同，实际地址为a+1xd。例如，p+9等同于a+9都表示指向a[9]的地址。其值为&amp;a[9]。
（3）*（p+i）和*(a+i)是p+i或a+i所指向的数组元素，即a[i]。例如：*（p+5）或*(a+5)就是a[5]。即：*(p+5)等价于*(a+5)等价于a[5]。对数组元素a[i]就是按*(a+i)进行处理，数组首元素地址+相对位移==元素的地址，然后找出该单元中的内容。若数组a的首元素地址为1000，数组类型为float，则a[3]的地址是：1000+3x4=1012，从地址为1012的地方取出a[3]的值。
（4）如果p1和p2都指向同一数组中的元素，如执行p2-p1，结果是p2-p1的值（两个地址之差）除以数组元素的长度。假设，p2指向实型数组元素a[5]，p2的职位2020，p1指向a[3]，其值为2012，则p2-p1=（2020-2012）/4=2。这表示p2和p1相差2个元素。
两个地址不能相加，无意义
2.通过指针引用数组元素 引用数组的方式 直接引用—a[i]间接引用—*(a+i)和*(p+i)。a为数组名，p是执行数组元素的指针变量，其初值为p = a。 示例：用三种方法输出元素中的全部元素。 有一个整型数组a，10个元素，要求输出数组中的全部元素。
方法一：直接引用a[i] #include&lt;stdio.h&gt; int main() { int a[10]; int i; printf("please input 10 numbers:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5249d2c260a5d892343afd01a188a1e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a651c519031a22fe112685450395a787/" rel="bookmark">
			严平稳/宽平稳过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		严平稳/宽平稳过程 前言 严平稳（Strict Stationary）和宽平稳（Wide Sense Stationary）是时间序列分析中非常重要的概念。本文将详细介绍这两个概念以及相关的理论知识。
什么是平稳过程？ 在介绍严平稳和宽平稳之前，我们先来看看什么是平稳过程。
平稳过程指的是时间序列中各个时刻的统计特征不随时间发生变化的一类过程。简单来说，就是时间序列的均值、方差等统计特征都保持不变。这种过程是非常重要的，因为只有基于平稳过程的模型才能用来进行预测和估计参数。
严平稳过程 定义 严平稳过程又称为强平稳过程，是指任意时刻的联合分布都与时间无关，即：
P ( X t 1 = x 1 , X t 2 = x 2 , ⋯ , X t k = x k ) = P ( X t 1 + h = x 1 , X t 2 + h = x 2 , ⋯ , X t k + h = x k ) P(X_{t_1}=x_1,X_{t_2}=x_2,\cdots,X_{t_k}=x_k)=P(X_{t_{1}+h}=x_1,X_{t_{2}+h}=x_2,\cdots,X_{t_{k}+h}=x_k) P(Xt1​​=x1​,Xt2​​=x2​,⋯,Xtk​​=xk​)=P(Xt1​+h​=x1​,Xt2​+h​=x2​,⋯,Xtk​+h​=xk​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a651c519031a22fe112685450395a787/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8e9946252355bf7dc9686f045f8fd6/" rel="bookmark">
			git submodule项目子模块的管理一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 项目发展到一定的程度，基本都会使用一些公共组件和模块做精细化的拆分，尤其是多个项目使用同一组件或sdk，方便统一升级和管理，使用Git做版本控制管理，也就不可避免的使用到子模块作为管理，下面主要介绍一些子模块常用的管理命令
原文地址：https://www.ngxcode.com/archives/527.html 配置文件 .gitmodules：该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射。
# 示例： [submodule "vendor/sdk"] path = vendor/sdk url = ssh://git@git.ngxcode.com/intra/sdk.git [submodule "vendor/tools"] path = vendor/tools url = ssh://git@git.ngxcode.com/intra/tools.git 常用命令 # 查看帮助 git submodule --help # 初始化本地.gitmodules文件 git submodule init # 克隆代码时带上子模块；repository：父仓库地址； git clone --recurse-submodules &lt;repository&gt; # 拉取所有子模块 git submodule foreach git pull # 添加子模块 # repository：仓库地址；path：存放当前项目文件夹路径 git submodule add &lt;repository&gt; &lt;path&gt; # 更新子模块 git submodule update --init --recursive # 删除子模块；这个手续稍微有点多 rm -rf 子模块目录 # 删除子模块目录及源码 vi .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d8e9946252355bf7dc9686f045f8fd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e97d561917ce618bafe5aace8ae12341/" rel="bookmark">
			微机原理：虚拟仿真实验之8255控制LED显示实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用8255A扩展一组（3个）并行口，利用这些并行口连接24个发光二极管，使之组成
一个连环，然后通过编程控制这些发光二极管，使其按照一定规律交替闪亮。
;汇编语言程序
code segment
assume cs:code
portA equ 400H ; PA口地址
go: mov dx,porta+3
mov al,80h
Out dx,al ; 三端口均初始化为方式0输出
mov bx,5555H
mov cl,55H
L0: mov ah,0bH
Int 21h ; 有无按键
Cmp al,0ffH
Jz exit
mov dx,porta ; 输出24位数
mov al,bl
Out dx,al
Inc dx
mov al,bh
Out dx,al
Inc dx
mov al,cl
Out dx,al
Call delay05 ; 延时
Xor bx,0ffffH ; 各位取反
xor cl,0ffH
Jmp L0
Exit: mov ah,4ch
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e97d561917ce618bafe5aace8ae12341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf787d2482628f1c7e0b688f7534b394/" rel="bookmark">
			FreeRTOS-事件组详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：嵌入式入坑者，与大家一起加油，希望文章能够帮助各位！！！！
📃个人主页：@rivencode的个人主页
🔥系列专栏：玩转FreeRTOS
💬保持学习、保持热爱、认真分享、一起进步！！！
目录 前言一、事件组的简介二、事件组源码分析1.事件组的创建2.等待事件函数 xEventGroupWaitBits()3.事件组置位函数 xEventGroupSetBits()4.任务同步函数xEventGroupSync 三、总结 前言 很久没有更新了，主要是因为在实习，忙论文的事，最主要的是事把又模电重新完完整整学了一遍，感觉我对电路的理解得到了升华，接下来继续把FreeRTOS更新完，最后上STM32单片机大师篇，前面已经把FreeRTOS最重要的应用，队列与信号量讲解完了，核心其实已经OK了，接下来就是将Freertos其他应用讲解完，本文要讲解的事件组应用非常简单，所以我们直接源码讲解，理解到底是如何实现的。
一、事件组的简介 事件是一种实现任务/中断间通信的机制，主要用于实现多任务间的同步，但事件通信只能
是事件类型的通信，无数据传输。其实事件组的本质就是一个整数(16/32位)。
与队列/信号量的区别： 1.信号量/队列当事件发生时只会去唤醒一个任务，而事件组可以唤醒多个任务起到一个广播的作用。
2.信号量/队列是一个消耗性资源，即数据读走了则就减少，而事件组可以选择清除事件也可以选择保留事件。
3.事件组只能是起到一个同步的作用，并不能传递数据。
4.最重要的一点事件组可以实现多个任务之间的同步，队列/信号量则只能是两个任务之间的同步(看完源码你就懂了)。
全局变量的区别 其实事件组相当于多个全局变量flag组成的，但是在操作系统中，事件组的优势明显。
1.全局变量使用在操作系统中存在被多个任务同时读写(前面的文章讲过为什么不能同时操作一个变量)的风险，则事件组它会直接禁止任务调度来规避风险。
2.使用全局变量需要自己去实现阻塞机制(成本太高)。
3.使用事件组能更方便的实现多任务之间的同步。
事件组的特点：
1.一个 32 位的事件集合（EventBits_t 类型的变量，实际可用与表示事件的只有 24 位，还有8位用于管理事件），其中每一位表示一种事件类型（0 表示该事件类型未发生、1 表示该事件类型已经发
生）。
2.事件仅用于同步，不提供数据传输功能。
3. 与信号量/队列不同设置事件组不会阻塞，即多次向任务设置同一事件等效于只设置一次。
4. 支持事件等待超时机制，即等待该事件类型(该事件还未发生)的任务会进入阻塞态。
5.事件获取的时候，有两个选择：1.逻辑或:任务所期望的事件中只要有任意一个事件发生，任务即可被唤醒。2.逻辑或:任务所期望的事件必须全部发生，任务才能被唤醒。
二、事件组源码分析 我们只需要搞清楚事件组是一个什么样的结构体，以及xEventGroupCreate()、xEventGroupSetBits()、xEventGroupWaitBits()，这三个函数的源码实现，还要搞明白上文提到的那8位是怎样管理事件组的。
1.事件组的创建 1.事件组结构体
uxEventBits：EventBits_t类型的变量，在32位平台下(stm32)，其实就是一个32位的无符号整形，其中高8位是控制为，低24位则用来存储事件，每一位代表一个不同事件(1：事件发生 0：事件未发生)。
xTasksWaitingForBits：是一个用来挂载等待事件发生的任务(阻塞机制)
一个变量，一条链表就是一个事件组，多么的简单。
2.动态创建事件组
创建事件组非常简单：
1.为事件组结构体分配内存
2.初始化事件组
3.初始化等待链表
2.等待事件函数 xEventGroupWaitBits() 为什么要先讲解 xEventGroupWaitBits()这个函数，我们先明白前面8位控制位的作用，等后面的xEventGroupSetBits()就很好理解了。
xEventGroupWaitBits()函数原型：
函数参数：
1.xEventGroup：事件组的句柄(传入事件组结构体的指针)。
2.uxBitsToWaitFor：等待的事件标志位，可以用逻辑或等待多个事件标志位，例如某任务想等待事件1和事件3，即(0x01 | 0x03)传入即可。
3.xClearOnExit：
pdTRUE：当 xEventGroupWaitBits()等待到满足任务唤醒的事件
时，系统将清除由形参 uxBitsToWaitFor 指定的事件标志位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf787d2482628f1c7e0b688f7534b394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed4420a83f6a0767e872ecc22327bf7e/" rel="bookmark">
			pytorch冻结模型的权重，不反向传播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ｐｙｔｏｒｃｈ冻结模型权重，不进行梯度反向传播
在 PyTorch 中冻结模型权重，不进行梯度反向传播，可以通过以下几个步骤实现：
将模型的所有参数设置为不需要梯度更新，即设置 requires_grad 属性为 False。 pythonCopy code
for param in model.parameters(): param.requires_grad = False 2.对于需要更新的参数，将其 requires_grad 属性设置为 True。
pythonCopy code
for param in model.fc.parameters(): param.requires_grad = True 这里以 model.fc 为例，表示只对模型中最后一层全连接层的参数进行更新。
3.在训练过程中，将需要更新的参数传入优化器中。
pythonCopy code
optimizer = torch.optim.SGD(filter(lambda p: p.requires_grad, model.parameters()), lr=0.001) 在这里使用了 filter 函数，只选择 requires_grad=True 的参数进行优化，以避免对不需要更新的参数进行无效的计算。
4.在进行训练时，只对需要更新的参数进行反向传播和优化。
pythonCopy code
for inputs, labels in dataloader: optimizer.zero_grad() outputs = model(inputs) loss = criterion(outputs, labels) loss.backward() optimizer.step() 这里的 model(inputs) 表示对输入 inputs 进行前向计算，只有最后一层全连接层的参数需要更新，因此只对这一层的参数进行了反向传播和优化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed4420a83f6a0767e872ecc22327bf7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/340d223859d0e12ac353b393550b28ef/" rel="bookmark">
			Vben Admin 自学记录 —— 使用 mock 模拟数据以及模拟api联调接口（持续更新中...）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vben Admin —— 使用 mock 模拟数据以及模拟api联调接口 数据 mock&amp;联调相关概念及使用
练习 —— 在之前table基础上，使用mock模拟数据，替换原来的死数据，添加新增、查看、修改和删除api并添加逻辑，实现一个简单的、完整的增删改查页面 /mock文件夹下添加table文件夹，其中添加tableMock.ts /mock/table/tableMock.ts
import { time } from 'console'; import { MockMethod } from 'vite-plugin-mock'; import { resultSuccess, resultError, requestParams, getRequestToken } from '../_util'; const tableListData = { pager: { list: [ { contno: '610964224475996443', name: '张三', sex: '0', dt: '20200701', age: '22', tel: '13789890909', address: '北京市北京小区', }, { contno: '610964224475996442', name: '李四', sex: '1', dt: '20230507', age: '27', tel: '15477778888', address: '大连市大连小区', }, { contno: '610964224475996445', name: '王五', sex: '0', dt: '20221001', age: '26', tel: '15477778888', address: '大连市大连小区', }, { contno: '610964224475996446', name: '小明', sex: '0', dt: '20220701', age: '25', tel: '15477778888', address: '大连市大连小区', }, { contno: '610964224475996447', name: '小红', sex: '1', dt: '20180808', age: '28', tel: '15477778888', address: '大连市大连小区', }, ], }, }; export default [ { url: '/basic-api/table/getListData', timeout: 200, method: 'get', response: () =&gt; { return resultSuccess(tableListData); }, }, { url: '/basic-api/table/addListData', timeout: 1000, method: 'post', response: (request: requestParams) =&gt; { tableListData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/340d223859d0e12ac353b393550b28ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c1df8768adf1014b7eaa8098baf0b75/" rel="bookmark">
			编写C语言程序，模拟实现首次/最佳/最坏适应算法的内存块分配和回收，要求每次分配和回收后显示出空闲分区和已分配分区的情况。假设初始状态下，可用的内存空间为640KB。（江西师范大学软件学院 操作系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【操作系统】分区分配算法 （首次适应算法、最佳适应算法、最坏适应算法）（C语言实现） 为了实现动态分区分配，通常将系统中的空闲分区链接成一个链。所谓顺序查找是指依次搜索空闲分区链上的空闲分区，去寻找一个大小能满足要求的分区。 --------计算机操作系统（第四版）
可变分区也称动态分区，在指作业装入内存时，从可用的内存中划出一块连续的区域分配给他，且分区大小正好等于改作业的大小。
可变分区分配策略:
1.首次适应算法：地址递增，从链首开始
2.最佳适应算法：性能最差，容量递减，浪费最小
3.最坏适应算法：分区大小递减，整合碎片，提高利用率
首次适应算法的话可以不断的去遍历寻找空间是否为空余的。
最佳适应算法的话是要找到最佳适配的空余区域，但是也会导致空闲区被利用之后可能会有一下片内存没被利用，而这小的碎片也很难再次被利用。
最坏适应算法的话是要找到最大空间来分配内存，这样剩余的空间也会最大，这样的话可以更有效的去减少出现小碎片的情况。
分配内存的时候，总是会想到C语言有个malloc函数可以分配内存。所以我写这份作业的时候抱有这是理解malloc函数的成分在里面的。一开始本来是用vector来存放空闲链表，后来觉得要符合底层的话，还是得用纯的c语言来写更好一点。
#include &lt;stdio.h&gt; #define MEMORY_SIZE 640 // 内存大小（单位：KB） #define BLOCK_SIZE 1 // 内存块大小（单位：KB） // 内存块结构体 typedef struct { int size; // 大小（单位：KB） int is_free; // 是否空闲 } block_t; // 内存块数组 block_t memory[MEMORY_SIZE / BLOCK_SIZE]; // 初始化内存块数组 void init_memory() { int i; for (i = 0; i &lt; MEMORY_SIZE / BLOCK_SIZE; i++) { memory[i].size = BLOCK_SIZE; memory[i].is_free = 1; } } // 显示内存分配情况 void print_memory() { int i, free_blocks = 0, allocated_blocks = 0, free_size = 0, allocated_size = 0; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c1df8768adf1014b7eaa8098baf0b75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af6873c9d4622d8f08e2abda71bd16ac/" rel="bookmark">
			Scala 值类型与引用类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		讲讲scala的根类 Scala的根类是Any，它是所有Scala类的超类。在Scala中，每个类都直接或间接地继承自Any。Any类定义了一些通用的方法，如equals，hashCode和toString，这些方法可以在任何Scala对象中使用。
除了Any类，还有两个重要的子类：AnyVal和AnyRef。AnyVal是Scala中所有值类型的父类，包括Int，Double和Boolean等。而AnyRef则是所有引用类型的父类，包括String，List和自定义类等。
在Scala中，一般情况下我们不需要显式地指定某个类的超类，因为如果没有明确指定，Scala编译器会默认将该类继承自AnyRef。不过，如果我们想定义一个值类型，那么需要显式地将它继承自AnyVal。
讲讲AnyVal和AnyRef的区别。 在Scala中，AnyVal和AnyRef是Scala类层次结构的两个重要的分支，分别代表值类型和引用类型。它们之间最主要的区别在于它们的内存管理方式不同。
AnyVal是Scala中所有值类型的父类，包括Int、Double、Boolean等。它们在内存中以值的形式存在，而不是以对象的形式存在。因为值类型的实例是直接存储在栈中的，所以它们的创建和销毁比较快，而且占用的空间也比对象类型的实例小得多。同时，由于值类型的实例是不可变的，所以它们也比对象类型的实例更加安全。
而AnyRef则是Scala中所有引用类型的父类，包括String、List和自定义类等。引用类型的实例在内存中以对象的形式存在，它们的创建和销毁比较慢，而且占用的空间也比值类型的实例大得多。同时，由于引用类型的实例是可变的，所以在多线程环境下需要注意同步的问题。
尽管AnyVal和AnyRef在内存管理和性能方面有所不同，但是它们都有一些共同的特点，比如都可以使用通用的方法equals、hashCode和toString等，都支持类型参数化和模式匹配等功能。
哪些类型是AnyVal的子类？ 在Scala中，所有的值类型都是AnyVal的子类。具体包括以下几种类型：
Byte：8位有符号整数类型，取值范围为[-128, 127]。 Short：16位有符号整数类型，取值范围为[-32768, 32767]。 Int：32位有符号整数类型，取值范围为[-2147483648, 2147483647]。 Long：64位有符号整数类型，取值范围为[-9223372036854775808, 9223372036854775807]。 Float：32位IEEE 754单精度浮点数类型，取值范围为正负3.4028235 × 10^38，精度为6-7位小数。 Double：64位IEEE 754双精度浮点数类型，取值范围为正负1.7976931348623157 × 10^308，精度为15-16位小数。 Char：16位无符号Unicode字符类型，取值范围为[0, 65535]。 Boolean：逻辑类型，取值为true或false。 需要注意的是，尽管值类型的实例在内存中以值的形式存在，但是在Scala中它们仍然是对象。Scala编译器会自动将值类型的实例封装成对应的类，例如将Int类型的实例封装成scala.Int类的实例。这种封装过程称为装箱（boxing），将封装后的值类型的实例转换回原始值称为拆箱（unboxing）。
除了AnyVal和AnyRef 还有什么类 除了AnyVal和AnyRef，Scala还有另外两个重要的根类：Nothing和Null。
Nothing是Scala类层次结构中的最底层，是所有类型的子类型，但它没有实例。它通常用于表示程序异常的返回值。例如，如果函数抛出异常，则其返回值类型可以是Nothing。另外，由于Nothing是所有类型的子类型，因此可以将Nothing类型的值赋给任何其他类型的变量。
Null是所有引用类型的子类型，它只有一个实例，即null。在Scala中，null通常用于表示缺失值或空值。需要注意的是，null只能赋值给引用类型的变量，而不能赋值给值类型的变量。如果要表示一个不存在的值，可以使用Option类型来代替null。
需要注意的是，尽管Nothing和Null都是Scala类层次结构中的重要组成部分，但它们并不是Scala中常用的数据类型，因此在编写Scala程序时，我们一般不需要直接使用它们。
它们并不是Scala中常用的数据类型，因此在编写Scala程序时，我们一般不需要直接使用它们
是的，由于Nothing和Null并不是Scala中常用的数据类型，因此在编写Scala程序时，我们一般不需要直接使用它们。在实际编程中，我们更多地使用Any、AnyVal和AnyRef这些通用类型，以及具体的值类型和引用类型。例如，对于数值计算，我们可以使用Int、Long、Double等值类型；对于字符串操作，我们可以使用String类型；对于集合操作，我们可以使用List、Map等引用类型。
需要注意的是，虽然在实际编程中我们不需要直接使用Nothing和Null，但是它们在Scala的类型系统中扮演着重要的角色，例如在类型推导和隐式转换等方面都会涉及到它们的概念。因此，对于Scala开发者来说，理解Nothing和Null的概念是非常重要的。
举例说明Nothing和Null 下面分别举例说明Nothing和Null的使用。
Nothing
在Scala中，函数的返回值类型可以是任意类型，包括Nothing类型。如果函数抛出异常或者进入无限循环等情况，可以将其返回类型定义为Nothing。例如，下面的函数定义了一个返回类型为Nothing的方法，它抛出一个异常：
def error(message: String): Nothing = throw new RuntimeException(message) 可以看到，该函数返回类型为Nothing，表示它不会正常返回任何值，而是会抛出一个异常。在函数调用时，调用者可以使用类型推导自动推断出返回类型为Nothing，例如：
val result: Nothing = error("Something went wrong") Null
在Scala中，Null类型表示空值或缺失值，它有一个实例null。Null类型是所有引用类型的子类型，因此可以将null赋值给任何引用类型的变量。例如：
val str: String = null // 将null赋值给String类型的变量 需要注意的是，如果尝试将null赋值给值类型的变量，会发生编译错误。例如，下面的代码是不合法的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af6873c9d4622d8f08e2abda71bd16ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/665e03b9d2b74c9e64330acefd3f246c/" rel="bookmark">
			函数递归与迭代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
函数递归
什么是递归？
递归的两个必要条件
代码示例
函数迭代
什么是迭代？
代码示例
函数递归 什么是递归？ 程序调用自身的编程技巧称为递归。
递归作为一种算法在程序设计语言中广泛应用，一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需的多次重复计算，大大地减轻了程序地代码量递归的主要思考方式在于：把大事化小 递归的两个必要条件 存在限制条件，当满足这个限制条件的时候，递归便不再继续。每次递归调用结束之后越来越接近这个限制条件。 代码示例 利用函数递归在屏幕上打印C语言
#include&lt;stdio.h&gt; void print(int n) { if (n &gt; 0) { printf("C语言\n"); print(n - 1); } } int main() { int n = 0; scanf("%d", &amp;n); print(n); return 0; } 当我们打印的次数比较少时，程序运行结果如下： 当我们取消限制条件，就会造成数据栈溢出，如下图：
因此这段代码就说明，使用函数递归时，必须存在限制条件，不能让函数一直递归，否则会造成堆栈溢出。
同时每次递归调用结束之后要越来越接近这个限制条件，例如
if (n &gt; 0) { printf("C语言\n"); print(n - 1); } 调用一次print函数，需要n-1,这样形参就会越来越接近0。
函数迭代 什么是迭代？ 函数迭代是指通过反复应用某个函数来逐步逼近目标值的过程。说人话就是：非递归-不是递归的解决问题的方法，一般指循环的方法。
代码示例 这里我们还是以利用函数迭代在屏幕上打印C语言为例：
#include&lt;stdio.h&gt; void print(int n) { int i = 0; for (i = n; i &gt;= 1; i--) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/665e03b9d2b74c9e64330acefd3f246c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/348d2a2e7ff05f4de463432a996528d0/" rel="bookmark">
			Android 功耗分析方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读目录
1、底电流调试（Rock Bottom Current Optimization） 1.1 校准RF1.2 飞行模式1.3 使用perf_defconfig1.4 移除debugging APKs1.5 把应用尽量删除1.6 去掉CPU占用高的进程1.7 手动移除所有可以移除的外设1.8 移除驱动模块1.9 配置不用的GPIO1.10 检查power相关的NV items1.11 排查GPIO、LDO、总线1.12 rpm dump1.13 检查rpm_stats1.14 使用Trace322、待机电流优化（Standby Current Optimization） 2.1 通过adb log排查2.2 top2.3 正在运行2.4 wakeup debug mask2.5 wakelock2.6 powertop2.7 CPU freq log2.8 Hoplug cores2.9 Scaling governor2.10 Mpdecision2.11 Power feature enable/disable2.12 Check system alarm2.13 Kernel timer check3、其他功耗项的优化 3.1屏幕对功耗的影响3.2 CPU/GPU DVFS3.3 CPU占用率3.4 游戏功耗3.5 Camera功耗偏大 正文
回到顶部
1、底电流调试（Rock Bottom Current Optimization） 底电流在手机飞行模式下调试。每个平台的底电流数据可能不一样，具体可以参考release出来的Current Consumption Data文档或者release note。一般情况下的底电流参考数据上限是：
底电流在手机飞行模式下调试。每个平台的底电流数据可能不一样，具体可以参考release出来的Current Consumption Data文档或者release note。一般情况下的底电流参考数据上限是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/348d2a2e7ff05f4de463432a996528d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8e06bfcb37bbfac1aaad039156b74b5/" rel="bookmark">
			VS2019实用小操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
在.c文件中添加宏定义取消错误
代码的隐藏
在.c文件中添加宏定义取消错误 在使用vs编译器时，我们使用scanf函数，可能有些小伙伴会疑惑，为什么我的代码没有错误，vs依然报错。
这里有两种方式解决。
第一种方法解释，scanf来源于c语言标准库，vs2019中scanf函数被认为是不安全的，因为它不能保证输入数据的长度不会超过指定的缓冲区的大小，可能导致缓冲区溢出漏洞，为了解决这个问题vs2019提供一组安全版本的输入函数如scanf_s，它是基于c11和c＋＋标准引入的一组安全输入函数，不属于c语言标准库的一部分但是是属于可选的拓展库，stdio.h是c语言标准库中的一个头文件，scanf_s也被支持在此头文件中使用。scanf是C语言提供的，scanf_s是VS提供的，这里我用的是vs编译器，为了保证兼容性，这里可以使用scanf_s，但是如果你们使用的是别的编译器，例如gcc,vc就可以使用scanf.
但是假如一个程序里面大量使用scanf函数或者以后每次编程使用，我们都要一个一个将scanf改成scanf_s是不是过于麻烦了呢？这里我们还没有总结到宏定义，在这里就直接告诉大家一个小技巧。
第二种方法—使用宏定义的方法
例如：
#include&lt;stdio.h&gt; int main() { int a = 0; scanf("%d", a); printf("%d\n", a); return 0; } 把这串字符复制粘贴在代码的开头，加上：''#define _CRT_SECURE_NO_WARNINGS 6''。（一定要放在第一行！！！）#define是宏定义，这里的6是编译器随机给的一个数，这里把他改成任意数字都是可以的。可能你们的编译器上还会报一个scanf返回值被忽略的警告，这个是没关系，代码依然可以运行。
例如：
#define _CRT_SECURE_NO_WARNINGS 6 #include&lt;stdio.h&gt; int main() { int a = 0; scanf("%d", a); printf("%d\n", a); return 0; } 那么代码就能在vs中正常运行。
可是后面如果我每次使用scanf、strcpy、strcat...这些函数时，vs都会提示不安全，那我每次都要在.c文件中都加入''#define _CRT_SECURE_NO_WARNINGS 6''，有没有更方便的办法？我一创建项目就能自动添加这行代码呢？答案当然是能的！（不然我也不会在这里说，这不是打自己的脸吗。)
步骤：
1.这里我们先找到newc++file.cpp这个文件，在这个文件中加入''#define _CRT_SECURE_NO_WARNINGS 1''，以后新建的文件中都会自动加上''#define _CRT_SECURE_NO_WARNINGS 1''。（可以使用之前我分享的工具Everything进行查找文件newc++file.cpp）（Everything等工具讲解链接：http://t.csdn.cn/EJ62i）
例如：
2.接下来我们点击对应的newc++ file.cpp文件，右击鼠标，点击选项》打开路径(o)，然后跳到newc++ file.cpp这个文件的位置。例如：
千万不要把这个路径关闭，不然后面可能找不到了。 3.然后我们来到桌面，点击newc++ file.cpp，右击鼠标，选项》打开方式(H），选择一种打开方式，可以是记事本...，这里我就用vs2019打开，打开之后是下面这样空空如也的：
这个时候，我们把''#define _CRT_SECURE_NO_WARNINGS 1''，Ctrl+S保存就可以了。例如：
这个时候关闭vs，复制一下我们电脑桌面的newc++ file.cpp文件，回到我们的路径下面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8e06bfcb37bbfac1aaad039156b74b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ed628c0295d34a2dccc37e29332a645/" rel="bookmark">
			WIN11 打开文件夹卡顿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 说明已尝试办法及效果问题分析及解决办法最终解决方式 说明 WIN11在使用一段时间后，突然会出现打开 文件夹非常卡顿，甚至电脑无响应。打开任务栏文件夹、双击这台电脑、WIN+E打开 都很卡顿（5S以上）在已打开的文件夹上回退路径非常迅速。 已尝试办法及效果 修改注册表恢复WIN10效果 。实测无效，且样式也没有变成WIN10关闭OneDriver 。 实测无效在文件夹选项中切换为此电脑 PS：在截下图时 explorer 无法再操作，只能后台结束再启动····什么神仙BUG之前默认是 主文件夹，改成此电脑后 （也有教程从此电脑改成主文件夹），WIN+E和打开文件夹都很快，但是在文件夹中点击左侧 主文件夹时 还是非常卡顿
问题分析及解决办法 经过上述方法测试，感觉我的电脑是出在和主文件夹相关的一些设置上。对比打开主文件夹和此电脑的界面，多了快速访问下面的一些历史记录包含最近使用的文件、文件夹等等。因此在上一张图片中最下方的 隐私中把三个选项都取消，且清除历史记录后，无论设置设置为主文件夹和此电脑，没有再出现卡顿现象 最终解决方式 文件夹选项中，隐私设置可以全都不勾选，且清除一次。我经常需要多次打开相同文件，且路径都非常深，因此我只能在出现问题后点清除来手动解决问题啦 希望能帮助有相同情况的同学解决问题~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16a299f4b033e739528e9ad2ed2bf8e7/" rel="bookmark">
			Redisson看门狗原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redission锁原理
watchDog 只有在未显示指定加锁时间（leaseTime）时才会生效。（这点很重要）lockWatchdogTimeout设定的时间不要太小 ，比如我之前设置的是 100毫秒，由于网络直接导致加锁完后，watchdog去延期时，这个key在redis中已经被删除了。在调用lock方法时，会最终调用到tryAcquireAsync。调用链为：lock()-&gt;tryAcquire-&gt;tryAcquireAsync,详细解释如下： private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) { RFuture&lt;Long&gt; ttlRemainingFuture; //如果指定了加锁时间，会直接去加锁 if (leaseTime != -1) { ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG); } else { //没有指定加锁时间 会先进行加锁，并且默认时间就是 LockWatchdogTimeout的时间 //这个是异步操作 返回RFuture 类似netty中的future ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime, TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG); } //这里也是类似netty Future 的addListener，在future内容执行完成后执行 ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; { if (e != null) { return; } // lock acquired if (ttlRemaining == null) { // leaseTime不为-1时，不会自动延期 if (leaseTime !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16a299f4b033e739528e9ad2ed2bf8e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f14e41d8590c59088d7c53381d35ce/" rel="bookmark">
			Ubuntu20.4环境下，Android11(R)源码，下载，编译，Pixel4刷机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu20.04.2LTS 环境下，Android11（R）版本源码下载，编译，Pixel4刷机 前言：前段时间为了给Pixel4刷机，下载源码、编译、刷机，踩了无数个坑，也花了很多时间，在这里做个笔记，便于以后避坑，也给以后遇到同样问题的同学一些参考
一、源码下载 下载 android11 需要python3.9 1、sudo apt update 2、sudo apt install software-properties-common 3、sudo add-apt-repository ppa:deadsnakes/ppa 4、sudo apt install python3.9 //查看python版本号，确认是否安装成功 5、python3.9 -V 如果python还安装了其他版本需要切换版本到3.9版本
安装git sudo apt-get upgrade sudo apt-get install git sudo snap install git-repo git config --global user.email "xxxxxxx@gmail.com" git config --global user.name "xxxxx" 安装curl sudo apt-get install curl 配置环境变量，安装repo（使用清华镜像站下载） mkdir ~/bin PATH=~/bin:$PATH curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo chmod a+x ~/bin/repo 打开bin文件夹下的repo文件，将
REPO_URL = 'https://gerrit.googlesource.com/git-repo' 改为
REPO_URL = 'https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65f14e41d8590c59088d7c53381d35ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca3a5f24235b7d9f423ffc5da4140955/" rel="bookmark">
			Ubuntu Server搭建Git服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.配置 硬件：树莓派B4
硬盘：4T机械硬盘
系统：ubuntu-22.04.2-preinstalled-server-arm64+raspi（树莓派官网下载）
2.前期准备 根据树莓派官网设置烧录系统并运行起来。
3.挂载硬盘 参考：Ubuntu Server搭建SVN服务器_鱼听禅的博客-CSDN博客
4.安装Git 4.1 安装Git服务器 ubuntu@ubuntu:~$ sudo apt-get install git Reading package lists... Done Building dependency tree... Done Reading state information... Done git is already the newest version (1:2.34.1-1ubuntu1.8). git set to manually installed. The following packages were automatically installed and are no longer required: ibverbs-providers libboost-iostreams1.74.0 libboost-thread1.74.0 libcephfs2 libgfapi0 libgfrpc0 libgfxdr0 libglusterfs0 libibverbs1 libldb2 librados2 librdmacm1 libtalloc2 libtevent0 liburing2 libwbclient0 python3-dnspython python3-gpg python3-ldb python3-markdown python3-pygments python3-requests-toolbelt python3-samba python3-talloc python3-tdb samba-common samba-common-bin samba-dsdb-modules samba-libs samba-vfs-modules tdb-tools Use 'sudo apt autoremove' to remove them.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca3a5f24235b7d9f423ffc5da4140955/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cab54159a2e18e42d73a2189f22d17f/" rel="bookmark">
			vite将vue3打包成非type=“module“的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司的新需求，要将一个vue项目打包，丢进一个app里头，然后用iframe显示出来，结果前期一切正常，因为都是用苹果测的，后来试了一下安卓手机，发现打不开了，经过一番调试，最终发现是使用了module，引入的js文件压根就没有执行，最后经过一番折腾，改了一下打包方式，终于是解决了问题，在此做一下记录o(￣▽￣)ブ
安装@vitejs/plugin-legacy npm i @vitejs/plugin-legacy 配置vite.config.ts文件 import legacy from '@vitejs/plugin-legacy'; plugins: [legacy({ targets:['defaults','not IE 11'] }),uni()], 打包之后打开index.html，按以下步骤改一下
删除所有&lt;script type="module"&gt;的东西，一整块都删了
删除所有nomodule关键词
删除id="vite-legacy-entry" 所在script标签里的内容并把data-src改成src 然后就ok了，大功告成！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22e084e725ba2fc0243ef42d250810ba/" rel="bookmark">
			php获取未解码之前的原始接口请求参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 目前的几个项目，业务方基本都使用POST方式请求接口，本机磁盘会保留一份请求的原始参数用于请求分析和问题排查使用，一般有问题，也会基于seqid(请求唯一id)捞到日志，copy参数模拟请求看是否复现，但一直有个比较蛋疼的问题，PHP的$_POST，$_GET，$_REQUEST这些获取参数的方法获取到的数据都是经过编码后的，到时copy后可能无法直接使用，最近有同学吐槽，决定还是解决一下。
网上搜索很多解决方式，有通过file_get_contents，php input和自定义的一些方法，试了下都不大靠谱，要么根本不解决问题，要么太复杂不够灵活，突然想到了$_SERVERG和$_GLOBALS打印了一下：
$_SERVER['REQUEST_URI']：请求地址，GET请求会同时带上url及地址内的参数
$_SERVER['QUERY_STRING']：请求参数，但只限于GET方式请求，POST无法获取到
$_GLOBALS['_POST']： POST请求参数
$_GLOBALS['_GET']： GET请求参数
以上获取到的参数都为未编码的原始参数信息。
原文地址：https://www.ngxcode.com/archives/514.html $_SERVER Array ( [HOSTNAME] =&gt; 10.93.50.82 [SEARCH_ENV_IP] =&gt; 10.93.50.82 [TERM] =&gt; xterm [HISTSIZE] =&gt; 1000 [SEARCH_ENV_ENV] =&gt; online [USER] =&gt; daemon [LS_COLORS] =&gt; 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;' [SEARCH_ENV_GROUP] =&gt; aliyun [MAIL] =&gt; /var/spool/mail/root [PATH] =&gt; /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/php/bin [PWD] =&gt; /api [HISTCONTROL] =&gt; ignoredups [SHLVL] =&gt; 1 [HOME] =&gt; /sbin [LOGNAME] =&gt; root [SEARCH_ENV_IDC] =&gt; aliyun [_] =&gt; /usr/local/php/sbin/php-fpm [OLDPWD] =&gt; /data1/minisearch/magent [HTTP_CONTENT_LENGTH] =&gt; 10140 [HTTP_CONTENT_TYPE] =&gt; multipart/form-data; boundary=--------------------------309935001928920506739539 [HTTP_CONNECTION] =&gt; keep-alive [HTTP_ACCEPT_ENCODING] =&gt; gzip, deflate, br [HTTP_HOST] =&gt; 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22e084e725ba2fc0243ef42d250810ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf7ae2eaea6e2f4fface871ac840adfa/" rel="bookmark">
			【精华】2023年收录全网高级JAVA面试题全套（含答案）无套路！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 全套领取地址：在文章底部 Mysql 主键用uuid会有什么问题？索引数据结构（B+树），为什么要用b+树，不用二叉搜索树、平衡二叉树、红黑树、b树(b-树)？如何设计索引？索引失效场景？回表,索引下推，索引覆盖，索引合并？聚簇索引与非聚簇索引区别？b+索引与hash索引区别？为什么不选择hash索引？mysql如何保证事务？事务隔离级别以及解决的问题？MySQL怎么实现四种隔离级别？默认隔离级别？为什么选择这个级别？mysql锁的种类以及含义？mysql如何解决幻读？MVCC多版本并发控制是什么？底层实现？为什么有了MVCC还需要行级锁？数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁？innodb为什么并发读取性能高？mysql有哪些日志，分别有什么作用？数据库自增主键可能的问题？innodb与myisam区别以及对应的使用场景？一条sql执行慢如何处理？MySQL的优化手段有哪些？mysql主从复制原理以及常见问题和解决方案分表策略如何预估一个mysql语句的性能？慢查询怎么优化插入一条数据发生了什么？mysql删除数据，是立马就删除了吗？mysql order by排序底层算法mysql死锁问题排查思路Mysql数据为啥在千万级别会有性能问题?为啥不是百万级别?你们建表会定义自增id么，为什么，自增id用完了怎么办mysql多事务执行会产生哪些问题，怎么解决这些问题分库分表做过么，怎么做到不停机扩容，双写数据丢失怎么办，跨库事务怎么解决一千万的数据大概多少次io什么情况下产生死锁，怎么排查，怎么解决假如有个组合索引ABC，以A为查询条件，走不走索引，以B为条件呢？组合索引的索引结构是什么样子的插入sql会使用到哪些锁间隙锁是什么，具体什么时候会加锁Left Join 是怎么执行的索引为什么能加快查询效率说说Purge的过程？说说主从复制延时怎么解决？怎么分库分表才能均匀？分库分表后某些分片热点写入怎么解决？分库分表后怎么join怎么下推？100w数据的表的B+树的高度？（这是笔者遇到的问题）mysql把2000w规模数据库备份，库间备份的方式redis运行在16核与32核的机器上，性能有什么区别？（这是笔者遇到的问题） Redis 假如一个业务依赖单点redis，此redis故障将导致业务不可用，如何改进Redis单线程 为什么这么快？Redis6.0为何引入多线程？Redis应用场景有哪些？你在项目中应用了哪些场景Redis 数据类型有哪些？以及底层数据结构持久化机制RDB和AOF如何选择？过期键的删除策略？内存淘汰策略有哪些？缓存穿透 ,缓存雪崩 ,缓存击穿redis sharding有哪些做法当大量数据要求用redis保存，单机单点难以满足需要，设计一个负载均衡的方案当redis采用hash做sharding，现在有8个节点，负载方案是 pos = hash(key) % 8，然后保存在pos节点上。这样做有什么好处坏处？如何保证redis和数据库数据的一致性。比如用户名既保存在数据库，又保存在redis做缓存。有如下操作 update_db(username);redis常见性能问题和解决方案MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据Redis的同步机制了解么？是否使用过Redis集群，集群的原理是什么？redis集群如何保证一致性？keys命令存在的问题？Redis常见的部署方式有哪些？主从复制原理哨兵Sentinel原理redis哨兵机制有几个定时任务，分别是干什么的？哈希分区算法有哪些？Redis 怎么实现消息队列？Pipeline 有什么好处，为什么要用 pipeline？redis分布式锁redis LRU算法redis集群，我项目怎么部署的？（主从轮询），其他的集群方式了解么，说了哨兵模式、Cluster模式。问Cluster的优点特性？Cluster的槽位是怎么划分的？有多少个槽位？你们mysql和redis出现了数据不一致的情况如何解决？为什么使用双删策略？没觉得很慢吗？如果你mysql存入了, 但是redis删除失败了既然redis是单线程为什么还能处理大量的读请求呢？redis zset的数据结构？你们用的redis集群么，扩容的过程，各个节点间怎么通信的redis线程模型，单线程有什么优缺点，为什么单线程能保证高性能，什么情况下会出现阻塞，怎么解决一致性hash原理，解决什么问题，为什么是2的32次方，20次方可以么redis分布式锁，过期时间怎么定的，如果一个业务执行时间比较长，锁过期了怎么办，怎么保证释放锁的一个原子性讲讲Redlock（红锁算法）RDB具体是如何实现的，RDB生成快照的时候，Redis会阻塞掉吗？redis 字符串实现，sds和c语言字符串区别redis集群为什么是16384？哨兵模式选举过程，脑裂问题？redis的key过期会立即删除吗？为什么不支持事务回滚什么时候rehash？rehash过程为什么要渐进式rehashredis中的字符串与c语言中的有什么不同？为什么选择用跳跃表来实现有序集合而不是用红黑树？一个字符串的最大容量是多少？redis6的多线程实现机制Redis Cluster为什么不采用把key直接映射到实例的方式？如果只有三个结点，但是总共有10亿条数据在三个结点里面，有一个挂来，就要有三亿条数据转移，这显然不合理，Redis怎么处理这个情况？为什么redis哨兵集群只有2个节点无法正常工作在哨兵进行主从切换过程中，客户端能否正常地进行请求操作呢？Redis的key过期机制，如果存储已经满了继续存会发生什么？Redis大key有什么问题？ HashMap HashMap的底层数据结构是什么？说一下HashMap的特点解决hash冲突的办法有哪些?HashMap用的哪种？为什么要在数组长度大于64之后，链表才会进化为红黑树为什么加载因子设置为0.75，初始化临界值是12？哈希表底层采用何种算法计算hash值？还有哪些算法可以计算出hash值？当两个对象的hashCode相等时会怎样何时发生哈希碰撞和什么是哈希碰撞，如何解决哈希碰撞？HashMap的put方法流程HashMap的扩容方式一般用什么作为HashMap的key？为什么Map桶中节点个数超过8才转为红黑树？HashMap为什么线程不安全？计算hash值时为什么要让低16bit和高16bit进行异或处理hashMap 的get，put，resize过程HashMap如何解决Hash冲突为什么是8转红黑树什么时候扩容hashmap数组索引为什么分高低位1.7到1.8有什么优化，hash算法做了哪些优化头插法有什么问题计划用HashMap存1k条数据，构造时传1000会触发扩容吗计划用HashMap存1w条数据，构造时传10000会触发扩容吗HashMap为什么使用红黑树，是怎么扩容的，扩容时做了什么负载因子的作用为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？为什么使用红黑树，有什么其他数据结构代替红黑树吗？hashmap的容量为什么必须的2的n次方，这是为什么？计算key的hash值，是怎么设计的ConcurrentHashMap不支持key或者value为null的原因？ 并发 并发编程三要素如何在Linux 上查找哪个线程cpu利用率最高？创建线程的方式说一下 runnable 和 callable 有什么区别？线程生命周期Java 中用到的线程调度算法是什么？sleep() 和 wait() 有什么区别？
两者都可以暂停线程的执行为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？如何停止一个正在运行的线程？Java 中 interrupted 和 isInterrupted 方法的区别？同步方法和同步块，哪个是更好的选择？Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？一个线程运行时发生异常会怎样？synchronized 锁升级的过程？synchronized原理synchronized关键字最主要的三种使用方式：synchronized 和 ReentrantLock 区别是什么？volatile 关键字的作用final什么是不可变对象，它对写并发应用有什么帮助？什么是 CASCAS 的会产生什么问题？AQS 原理概览ReadWriteLock 是什么ConcurrentHashMap如何保证线程安全Java 中 ConcurrentHashMap 的并发度是什么？CopyOnWriteArrayList 是什么，可以用于什么应用场景？有哪些优缺点？ThreadLocal 是什么？有哪些使用场景？ThreadLocal造成内存泄漏的原因？ThreadLocal内存泄漏解决方案？线程池核心参数ThreadPoolExecutor饱和策略线程池原理如何实现阻塞队列ConcurrentHashMap为什么是线程安全的？为什么ConcurrentHashMap底层为什么要红黑树ConcurrentHashmap的get方法加锁了吗？put方法加锁了吗？sychronized和ReentrantLock的区别，说说如何ReentrantLock如何实现超时锁的等待？sychronized的自旋锁、偏向锁、轻量级锁、重量级锁，分别介绍和联系当某个线程获取ReentrantLock失败时，是否会从内核态切换回用户态？ReentrantLock在多线程环境下如何实互斥的逻辑？ReentrantLock获取锁失败的线程如何处理？ReentrantLock如何存储阻塞的线程呢？ReentrantLock当前线程释放锁之后，如何唤醒阻塞的？ReentrantLock公平锁与公平锁什么区别？ExecutorService用过吗？场景？FixedSizeThreadPool有哪些问题？FixedSizeThreadPool为什么会有OOM问题？AtomicInteger之类的原子类型用到过没？原理是什么？reentrantlock的实现原理，加锁和释放锁的一个过程，公平和非公平，可重入，可中断怎么实现的threadlocal用过么，什么场景下使用的，原理，内存泄漏产生原因，怎么解决线程池中使用threadlocal为什么容易造成内存泄漏？单核cpu用volatile有用吗AtomicInteger的原理可重入锁是什么，非可重入锁又是什么线程池的线程在执行完任务会立刻回收吗？（保留corePoolSize个核心线程）平时线程池的使用，如果让自己设计一个线程池如何设计（设计哪些组件以及对应执行什么功能，每个组件分别用什么类或容器实现）countDownLantch实现案例，其他线程执行到该位置后，主线程再执行，主线程是如何实现等待的线程池，为什么要用线程池？满了怎么办？如果我想换个方式，改为满了之后先扩充最大核心数呢？Java线程数过多会造成什么异常？ 微服务&amp;分布式 设计模式 JVM 计算机基础 场景题 算法题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/122f316eb7fb1f335703f091f5fd7c75/" rel="bookmark">
			小白到运维工程师自学之路 第十五集 （软件安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 1、软件分类 RPM包 DEB包 源码包 附带安装程序的软件包 二、RPM管理 首先创建一个挂载点mkdir /media/cdrom 将光盘重新挂载 mount /dev/sr0 /media/cdrom 查看已安装的软件列表rpm -qa 查看软件是否安装 rpm -q 查看安装后的文件列表 rpm -ql 查看安装后的配置文件信息 rpm -qc 未安装的软件 rpm -ivh （需要安装的软件） 三、yum安装 首先要先把网络连接 进入yum.repos.d文件中 找到CentOS-Media.repo 并用vim文本编辑器打开 将gpgcheck enabled修改成1 安装命令 yum install （需要安装的软件） 删除命令 yum remove （需要卸载的软件） 清除缓存yum clean all 建立缓存 yum makecache 四、源码安装 首先解压一个源码安装包 进入到解压后的文件 找到他的可执行文件 configure 输入./configure --prefix=/usr/local 如果报错的话根据提示输入 yum -y install gcc-c++
yum -y install pcre-devel
yum -y install zlib-devel
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/122f316eb7fb1f335703f091f5fd7c75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d15eb6fe8683e2f01cdc1c8f6d5ffe/" rel="bookmark">
			安徽省机器人大赛练习（C赛道）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的练习一下，题目要求如下：
用LCD屏显示温湿度驱动电机转动当湿度低于某个阈值时电机速度变快用LCD屏显示电机转速设置按钮A，使电机停止设置按钮B，使电机速度进入手动控制模式设置按钮C，每按一次电机速度发生变化设置按钮D，再次进入自动模式 代码如下：
LCD12864：
module lcd12864_drive ( input clock, input reset, input [63:0] data_buf, output lcd12864_rs, output lcd12864_rw, output lcd12864_en, output [7:0] lcd12864_data ); wire [63:0] data_buf; /**************************产生lcd12864时钟信号*************************/ reg clk_lcd12864; reg [19:0]cnt; always @(posedge clock or posedge reset) begin if (reset) begin cnt &lt;= 20'b0; clk_lcd12864 &lt;= 0; end else if(cnt == 20'd20000)	//时钟频率非常重要！！将近3k，经实测5k会在第0位出错。 begin cnt &lt;= 20'd0; clk_lcd12864 &lt;= ~clk_lcd12864; end else cnt &lt;= cnt +1'b1; end reg [1:0] clk_lcd12864_sync; always @(posedge clock or posedge reset) begin if (reset) clk_lcd12864_sync &lt;= 2'b00; else clk_lcd12864_sync &lt;= {clk_lcd12864_sync[0],clk_lcd12864}; end assign clk_lcd12864_pos = (clk_lcd12864_sync == 2'b01); //****************************lcd12864控制信号*****************************************/ reg [8:0] state; //State Machine code parameter IDLE = 4'd0; parameter CMD_WIDTH = 4'd1; //设置数据接口数量 parameter CMD_SET = 4'd2;	//选择指令集 parameter CMD_CURSOR = 4'd3; //设置光标 parameter CMD_CLEAR = 4'd4; //清屏 parameter CMD_ACCESS = 4'd5; //输入方式设置：数据读写操作后，地址自动加一/画面不动 parameter CMD_DDRAM = 4'd6; //DDRAM行地址 parameter DATA_WRITE	= 4'd7; //数据写入 parameter STOP = 4'd8; // reg lcd12864_rs_r; reg [7:0] lcd12864_data_r; reg [7:0] data_buff; reg [5:0] cnt_time; //输出管教配置 assign lcd12864_rs = lcd12864_rs_r; assign lcd12864_rw = 1'b0; assign lcd12864_en = clk_lcd12864_sync[1]; //与lcd12864时钟相同 assign lcd12864_data = lcd12864_data_r; always @(posedge clock or posedge reset) begin if(reset) begin lcd12864_rs_r &lt;= 1'b0; state &lt;= IDLE; //	lcd12864_data_r &lt;= 8'bzzzzzzzz;	//高阻态 lcd12864_data_r &lt;= 8'b11111111;	//高阻态 cnt_time &lt;= 6'd0; end else if(clk_lcd12864_pos) begin case(state) IDLE: begin lcd12864_rs_r &lt;= 1'b0; cnt_time &lt;= 6'd0; state &lt;= CMD_WIDTH; //	lcd12864_data_r &lt;= 8'bzzzzzzzz; lcd12864_data_r &lt;= 8'b11111111; end CMD_WIDTH: begin lcd12864_rs_r &lt;= 1'b0; state &lt;= CMD_SET;	lcd12864_data_r &lt;= 8'h30; //8位数据口 end CMD_SET: begin lcd12864_rs_r &lt;= 1'b0; state &lt;= CMD_CURSOR; lcd12864_data_r &lt;= 8'h30; //基本指令集 end CMD_CURSOR: begin lcd12864_rs_r &lt;= 1'b0; state &lt;= CMD_CLEAR; lcd12864_data_r &lt;= 8'h0c; // 关光标 end CMD_CLEAR: begin lcd12864_rs_r &lt;= 1'b0; state &lt;= CMD_ACCESS; lcd12864_data_r &lt;= 8'h01;	//清屏 end CMD_ACCESS: begin lcd12864_rs_r &lt;= 1'b0; state &lt;= CMD_DDRAM; lcd12864_data_r &lt;= 8'h06; //进入点设定 end CMD_DDRAM:	//行数命令 begin lcd12864_rs_r &lt;= 1'b0; state &lt;= DATA_WRITE; case (cnt_time) 6'd0:	lcd12864_data_r &lt;= 8'h80; 6'd16:	lcd12864_data_r &lt;= 8'h90; 6'd32:	lcd12864_data_r &lt;= 8'h88; 6'd48:	lcd12864_data_r &lt;= 8'h98; endcase end DATA_WRITE:	//写数据 begin lcd12864_rs_r &lt;= 1'b1; cnt_time &lt;= cnt_time + 1'b1; lcd12864_data_r &lt;= data_buff; case (cnt_time) 6'd15:	state &lt;= CMD_DDRAM; 6'd31:	state &lt;= CMD_DDRAM; 6'd47:	state &lt;= CMD_DDRAM; 6'd63:	state &lt;= STOP; default:	state &lt;= DATA_WRITE; endcase end STOP: begin lcd12864_rs_r &lt;= 1'b0; state &lt;= CMD_DDRAM; lcd12864_data_r &lt;= 8'h80;	//从第几行循环 cnt_time &lt;= 6'd0; end default: state &lt;= IDLE; endcase end end always @(cnt_time) begin case (cnt_time) 6'd0: data_buff &lt;= "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7d15eb6fe8683e2f01cdc1c8f6d5ffe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c3604ce12c9d6990748a3f2776e728e/" rel="bookmark">
			用ES搜索关键字并且返回模糊字段高亮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般来说，各个网站，首页的搜索，都会有进行全文搜索的示例，并且把模糊匹配的多个数据进行标记(高亮)，这样便于全局检索关键的数据，便于客户进行浏览。基于此，本文简单介绍这种功能基本java 的 实现
由于公司页面此功能隐藏了，本文就以接口调用返回看具体实现了
下面是最终的想要的结果，搜索内容代码 1， type 是 类型 类型ID: 1 线索、2 客户、3 商机、4 联系人、5 售前、6 订单、7 合同，
每一种类型代表一张表的数据
控制层 controller @ApiOperation("关键字搜索结果页聚合") @PostMapping("/pageListAgg") public R pageListAgg(@RequestBody @Valid GlobalSearchDataReqDTO globalSearchDataReqDTO) { return success(globalSearchService.pageListAgg(globalSearchDataReqDTO)); } 逻辑层 service public Map&lt;String, Object&gt; pageListAgg(GlobalSearchDataReqDTO globalSearchDataReqDTO) { Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;(); if (Objects.isNull(globalSearchDataReqDTO.getType())) { globalSearchDataReqDTO.setType(1); } NativeSearchQueryBuilder nativeSearchQueryBuilder = new NativeSearchQueryBuilder(); // 构建查询条件 &amp; 高亮 this.searchConditionBuild(globalSearchDataReqDTO, nativeSearchQueryBuilder); // 排序 nativeSearchQueryBuilder.withSort(SortBuilders.scoreSort()); nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort("type").order(SortOrder.ASC)); nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort("createTime").order(SortOrder.DESC)); // terms 指定分组的别名, field 指定要分组的字段名, size 指定查询结果的数量 默认是10个 TermsAggregationBuilder aggregation = AggregationBuilders.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c3604ce12c9d6990748a3f2776e728e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb842bb86b8ffceaa79a491a1c5adbf7/" rel="bookmark">
			【Doris】数据表设计 —— 在分区与分桶的设计上提高 [ 查询效率 ]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 分区(partition)说明RANGE分区LIST分区 HASH分桶(bucket)说明示例一、RANGE分区二、LIST分区 总结： 分区(partition)说明 分区是指将数据按照某个规则划分到不同的物理存储节点上，以实现数据的分布式存储和查询。在 Doris 中，可以通过指定分区键来进行数据的分区。分区键是指在表中用于划分数据的列或列组合。Doris 支持RANGE 分区和 LIST 分区两种方式。
逻辑上可以理解为将原始表划分成了多个子表。可以方便的按分区对数据进行管理，例如，删除数据时，更加迅速。
分区列支持 BOOLEAN, TINYINT, SMALLINT, INT, BIGINT, LARGEINT, DATE, DATETIME, CHAR, VARCHAR 数据类型，分区值为枚举值。只有当数据为目标分区枚举值其中之一时，才可以命中分区。
Doris在建立分区时，可以不等分，比如：历史数据可以用年来分区，近年的数据可以用月来分区
RANGE分区 业务上，多数用户会选择采用按时间进行partition, 让时间进行partition有以下好处：
可区分冷热数据可用上Doris分级存储(SSD + SATA)的功能 LIST分区 业务上，用户可以选择城市或者其他枚举值进行partition。
HASH分桶(bucket)说明 根据hash值将数据划分成不同的 bucket。
建议采用区分度大的列做分桶, 避免出现数据倾斜为方便数据恢复, 建议单个 bucket 的 size 不要太大, 保持在 10GB 以内, 所以建表或增加 partition 时请合理考虑 bucket 数目, 其中不同 partition 可指定不同的 buckets 数。 示例 一、RANGE分区 哈希分区10个（其中两个分区时间范围是1年，剩余分区时间范围是1个月），哈希分桶5个
CREATE TABLE `table05` ( `order_id` varchar(64) NOT NULL COMMENT "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb842bb86b8ffceaa79a491a1c5adbf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9b767ef01322fbb0b83cf674b719fdf/" rel="bookmark">
			pycharm最新版默认菜单栏等工具不见了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因 pycharm2022.3新版本，默认使用新UI（如下图），这让很多小伙伴来说不太适应，我还是习惯旧版本的界面。在网上搜了许多恢复旧版本界面的教程，说的解决方案都是由于“手贱把菜单栏给隐藏了”，这个本文章遇到的问题不一样。下面就说说如何恢复旧版本界面吧。
解决方法 1、点击左上角的红方框，选择“file”–setting调出设置界面
2、点击New UI，取消勾选Enable new UI，点击 OK
3、之后会问你是否重启 pycharm，点击restart，即可自动重启。
4、重启之后就恢复到以前的界面了，还是旧版本的界面一目了然
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a08a9bbeb5f5d35018cbe7817e0951a4/" rel="bookmark">
			HAL库是什么，HAL库的定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、HAL 库的定义 HAL是 Hardware Abstraction Layer 的缩写，中文名：硬件抽象层。HAL 库是 ST 为 STM32 最新推出的抽象层嵌入式软件，可以更好的确保跨 STM32 产品的最大可移植性。该库提供了一整套一致的中间件组件，如 RTOS，USB，TCP/IP 和 图形 等。
百度有一堆定义， HAL 库是基于一个非限制性的 BSD 许可协议（Berkeley Software Distribution）而发布的开源代码。 ST 制作的中间件堆栈（USB 主机和设备库，STemWin）带有允许轻松重用的许可模式， 只要是在 ST 公司的 MCU 芯片上使用，库中的中间件(USB 主机/设备库,STemWin)协议栈即被允许随便修改，并可以反复使用。
但是我简单通俗的来讲，就是HAL库可以使得用户将代码跨芯片使用，不同的MCU芯片（F1/F2...）都可以使用，体现了可移植性强！！
2、STM32CubeMX 说到 STM32 的 HAL 库，就不得不提 STM32CubeMX，其作为一个可视化的配置工具，对于开发者来说，确实大大节省了开发时间。STM32CubeMX 就是以 HAL 库为基础的，且目前仅支持 HAL 库及 LL 库！ STM32CubeMX软件的特点：
集成了ST的每一款型号的MCU/MPU的可配置的图形界面，能够自动提示IO冲突并且对于复用IO可自动分配；具有动态验证的时钟树；能够很方便的使用所集成的中间件；能够估算MCU/MPU在不同主频运行下的功耗；能够输出不同编译器的工程，比如能够直接生成MDK、EWARM、STM32CubeIDE、MakeFile等工程； STM32CubeMX的使用也比较简单：先下载STM32CubeMx软件及对应不同系列MCU/MPU的Packs。
确定要使用的MCU/MPU的型号；对所选的MCU/MPU的GPIO进行功能配置、配置时钟树及初始化相关参数；选择要用到的中间件进行配置；将配置好功能的MCU/MPU生成对应编译器的C语言工程文件； stm32cubemx官网下载
3、HAL库与标准库（SPL）的区别 文字性的东西我不宜过多赘述，这里直接上代码！
1、句柄 在STM32的标准库中，假设我们要初始化一个外设（这里以USART为例）
我们首先要初始化他们的各个寄
存器。在标准库中，这些操作都是利用固件库结构体变量+固件库Init函数实现的：
USART_InitTypeDef USART_InitStructure; USART_InitStructure.USART_BaudRate = bound;//串口波特率 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a08a9bbeb5f5d35018cbe7817e0951a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/458b323c06c26888f004d38801b0b7a9/" rel="bookmark">
			ChatGPT3.5使用体验总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优点 1.ChatGPT 能颠覆现有的搜索引擎（百度、谷歌）。
2.ChatGPT 的交互体验非常好，满足“智能助手”这种工具。
3.如何使用好ChatCPT？ 回到一个经典的问题“如何提问”，想高效率的使用好ChatGPT必须要清楚自己提的问题。
4.ChatGPT 支持了插件模式，使用场景会越来越多、功能越来越强。
5.ChatGPT 自然语言模型做的非常不错，自己问它问题的时候会觉得“它”好像真理解了我提的问题。
6.ChatGPT4 已经在内测了，官方介绍ChatGPT4比ChatGPT3.5 强很多还是实时联网的。
7.ChatCPT 迭代越来越快，用的人多越多反馈就越多功能就更强。
缺点： 1.ChatGPT大家普遍反应的问题是车轱辘话，很多回答给人感觉就是为了回答给回答。
2.ChatGPT 某些回答带有政治偏向。在国内被禁用不是没有道理的。
3.ChatGPT 某些领域的知识是错误的，并且它给出的答案是它编的。在使用过程中，还是要审视哈它给出的答案。
4.ChatGPT 模型中数据很可能知识侵权了，并且有肯能会泄漏个人、组织、公司的隐私。
ChatGPT是否能取代程序员？ ChatGPT 现有的数据都是来自互联网上的数据，一些常见的问题回答超过个人的经验。但是一些新的领域或者
特殊领域ChatGPT 就无能为力了。最核心的问题是ChatGPT需要一个懂提问题的人，你没有编程经验你无法提出
准确的问题。写过程序的人都知道写程序很简单，难在如何维护这些程序。ChatGPT 能给出回答，但出了问题还是需要
程序员修复、维护。ChatGPT + 程序员 &gt; 2 ChatGPT 是一个超强的生产力工具，必须学起啦。
使用ChatGPT、ChatGPT API（ChatGPT API普通用户注册送5美元的额度，三个月就过期了。所以注册要赶紧用了。
ChatGPT 网页跟ChatGPT API充值不是同一个账户哦。比如ChatGPT-Plus 一个月20美元，ChatGPT API 要另充钱）
需要上网魔法，大家可以自己网上找找。注册邮箱推荐是Gmail或者网易邮箱，并且需要一个国外手机号收取验证码。这
里推荐俄罗斯的接码平台 SMS-Activate，手机号推荐用马来西亚，基本每个验证码都能收到。之前用了印度、瑞士、美
国都收不到验证码，并且平台必须冲两美元，之前都是一美元的。详细教程看（https://www.i3zh.com/21773.html）这篇文章。
ChatGPT使用过程要注意： 1.官方网站不稳定，有时候登陆不上。不充值用户使用了一个小时会出现网络超时或者直接用不了（可以隔天再用或者重新登陆）。
2.上网魔法节点最好别用共享的，共享节点用多了的账号直接被封。上网魔法节点最好越快越好，不然一个问题还没回答完，直接给你网络超时了。
3.普通人使用ChatGPT 网页版已经够用了，程序员推荐使用ChatGPT API 接口比网页版稳定多了。
4.ChatGPT 卖账号的骗子太多了，小心哦。
这里又能看到（马斯克）的名字了，这人真牛。又是造电动车又是造火箭，结果还是Open AI的创始人之一。
更多ChatGPT 干货内容点击如下地址获取:
ChatGPT从基础到项目实战https://edu.csdn.net/course/detail/38557
我提问了一些编程的问题，因为内容太长了。一张图放不下，我贴出文字版。
PHP编程语言的优势与劣势 优势：
易于学习和使用：PHP 是一种简单易学的编程语言，语法与 C 和 Java 类似，因此对于初学者来说，学习 PHP 相对容易。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/458b323c06c26888f004d38801b0b7a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f747082b7545c8547306c1892071d0/" rel="bookmark">
			Redis系列--五种数据类型详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、String字符串 一、简介 String是Redis中的基本数据类型，是二进制安全的。也就是说Redis中，String可以存储任何数据。String中的value最多可以存储512M数据。
二、常用命令 set &lt;key&gt;&lt;value&gt;添加键值对
get &lt;key&gt;查询对应键值
append &lt;key&gt;&lt;value&gt;将给定的&lt;value&gt; 追加到原值的末尾
incr &lt;key&gt;
将 key 中储存的数字值增1
只能对数字值操作，如果为空，新增值为1
decr &lt;key&gt;
将 key 中储存的数字值减1
只能对数字值操作，如果为空，新增值为-1
三、数据结构 String的数据结构在redis中是简单的动态字符串。采用预分配冗余空间的方式来减少内存的频繁分配.
如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。
二、List列表 一、简介 单键多值，Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。底层实现是双向链表。
二、常用命令 lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; .... 从左边/右边插入一个或多个值。
lpop/rpop &lt;key&gt;从左边/右边吐出一个值。值在键在，值光键亡。 rpoplpush &lt;key1&gt;&lt;key2&gt;从&lt;key1&gt;列表右边吐出一个值，插到&lt;key2&gt;列表左边。 lrange mylist 0 -1 0左边第一个，-1右边第一个，（0-1表示获取所有）
三、数据结构
List的数据结构为快速链表quickList。
首先，当数据比较少的时候，会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。
当数据量比较多的时候才会改成quicklist。
因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。 Redis将链表和压缩列表结合起来使用，形成了一个快速列表。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。
三、Set集合 一、简介 set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动去重的，但是数据是无序的。
二、常用命令 sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ..... 将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略
smembers &lt;key&gt;取出该集合的所有值
sismember &lt;key&gt;&lt;value&gt;判断集合&lt;key&gt;是否为含有该&lt;value&gt;值，有1，没有0
spop &lt;key&gt;随机从该集合中吐出一个值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44f747082b7545c8547306c1892071d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c60622eee6515fbf323391d68755ff9/" rel="bookmark">
			CSDN AI 初步尝试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问：js class constructor是否可以不写
答：在 JavaScript 中，如果您不写构造函数，JavaScript 引擎会自动生成一个默认的构造函数。这个构造函数没有参数，也没有任何操作。因此，如果您不需要在实例化对象时执行任何操作，可以省略构造函数。但是，如果您需要在实例化对象时执行任何操作或传递参数，则需要编写构造函数。
总结
如果在class里面写了constructor，在vue3+vite+ts的环境下，constructor必须写参数，否则报错。
class Aexample{ aa:1 constructor(option){ this.aa=option.aa } } 感叹！AI，新时代的搜索工具！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83c3fa66ed05611888eecb28b8c75137/" rel="bookmark">
			（五）【小插曲】index.js文件关于参数隐式具有”any”类型的报错的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习表单组件时，根据网上教程，添加了如下代码。
1. index.wxml中添加如下。
&lt;form bindsubmit="formSubmit"&gt; &lt;view class="section section_gap"&gt; &lt;view class="section__title"&gt;slider&lt;/view&gt; &lt;slider name="slider" show-value &gt;&lt;/slider&gt; &lt;/view&gt; &lt;view class="btn-area"&gt; &lt;button formType="submit"&gt;Submit&lt;/button&gt; &lt;/view&gt; &lt;/form&gt; 2. index.ts中添加如下。
formSubmit: function (e) { console.log('form发生了submit事件，携带数据为：', e.detail.value) this.setData({ allValue:e.detail.value }) } }) 这时编译系统报错如下。
3. 问题解决：在index.ts文件中修改function中的“e”为“e:any”即可。
formSubmit: function (e:any) { console.log('form发生了submit事件，携带数据为：', e.detail.value) this.setData({ allValue:e.detail.value }) } }) 如果是index.js文件，使用function(e)即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/670859c56685d62e00a768132b445c71/" rel="bookmark">
			STM32H743无操作系统移植LVGL8.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概述
移植步骤
1. 准备材料
2.精简LVGL源码
3.向工程添加文件
4.修改工程文件
为LVGL添加时基
配置显示屏驱动
​编辑
配置触摸驱动
编写测试代码
问题记录（重点）
分配的堆栈空间太小了
程序优化等级对程序运行的影响
LVGL打点函数的几种方式（非LTDC、RGB屏）
运行官方Demo的方法：
​编辑
工程下载：
概述 本文章记录了本人使用正点原子F407和H743两块开发板移植LVGL8.2的说明，移植步骤安装正点原子的B站教程。
移植步骤 1. 准备材料 1.下载LVGL源码
LVGL 相关的源码和工程都是存放在 GitHub 远程仓库中，该 GitHub 远程仓库地址为https://github.com/lvgl/lvgl/，用户可以该仓库中下载 LVGL 图形库的源码，注意在仓库中选择8.2分支进行下载。（github比较慢，可以到gitee上面搜索下载） 2.LVGL文件夹简介
3.正点原子触摸屏实验例程和定时器例程，以F4为例。
2.精简LVGL源码 1.除了 examples 文件夹、 src 文件夹、 lv_conf_template.h 和 lvgl.h 文件，其他的文件和文件夹 均与移植无关，我们可以将它们删除，这样即可得到 LVGL 的精简源码，如下图所示（保留了 demos 文件夹，该文件夹中存放的是 LVGL 官方的演示例程，后续我们将移植其中的一些示例。 ） 2.将文件夹下的的 lv_conf_template.h 文件改名为 lv_conf.h，打开lv_conf.h修改条件编译如下：
3.examples 文件夹，仅保留其中的 porting 文件夹，其他的文件和 文件夹皆可删除，删减后如下图所示。
3.向工程添加文件 1》在工程 的 Middlewares 目录下新建 LVGL 文件夹，并在该文件夹下新建 GUI 文件夹和 GUI_APP 文件 夹，最后在 GUI 文件夹下新建 lvgl 文件夹。具体的文件夹结构如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/670859c56685d62e00a768132b445c71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/371da0f4a520eb8f1a500bf9536f4992/" rel="bookmark">
			【数据结构学习笔记】抽象数据类型（个人理解版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文只是自己学习笔记的整理，并不具有较强的专业性，对于知识点用的是自己的理解，如果有问题，欢迎指正和质疑。
一、理解数据类型 数据类型包括整型、浮点型、字符型、布尔型。
当然我在网上也看到一些其他的分类，我这里就不一个个列举了，主要是讲我个人对这个知识点的理解，希望可以给正在学习的小伙伴提供一种新的理解思路。
早在最初，程序猿写代码就是0101001······来表示各种各样的数据，但可能是因为懒，也可能是因为量变引起了质变，程序猿们就想着要不归个类吧，于是有了数据类型。（个人猜想，不是事实）
想详细了解数据类型发展史和编程语言发展史的可以自行搜索一下。
所以这世上本没有数据类型，用的人多了，也便有了数据类型。（狗头）
但我个人觉得这其实是个顺其自然的过程，就好比在很早很早以前，我们的祖先是没有锅碗瓢盆的概念的，只是知道用黏土制造这样一个容器很适合装东西，所以就拿它装东西。由于每次制作过程中未知数太多，比如人不一样就导致了和泥时加水量不一样，而且每个人的力气和喜好不同，就使得制作出来的容器大小不一。（这里就像是每个程序猿的编码习惯不同，所以代码样式不同，但结果都是一样的。）经过一段时间的使用，祖先发现在吃方面，小的容器更适合个人使用，中等容器适合盛放食物，大的容器适合炖煮食物，所以碗、盆、锅就诞生了，好耶！结构
所以在制作高级语言时，人们发现编码输入时说到底就这么几样东西，数字，字符，是非。于是干脆就分了类，考虑到数字有整数小数之分，所以分了两类，整型和浮点型，字符分成字符型，是非就是布尔型。
所以数据类型理解起来并不是很麻烦。
二、理解抽象数据类型 抽象数据类型其实是在数据类型的基础之上进行拓展，它其实更像是模板，进行了很模糊的定义，只定义了属性和操作。
就还是拿吃打比方，抽象数据就是菜谱的模板，一个菜谱包括食材和调料以及他们的量，还有步骤。要是一两道菜，你每一个所需要的食材或者调料（变量）可以单独记载一张纸上（单独进行变量命名）。但在大量食谱记录过后，你会发现他们冥冥之中好像有很多相同之处，于是你会开始将共性归纳起来并做成表格，第一列食材（应该用字符型），第二列标注食材的量（应该用整型【一般好像没什么食材会精确到小数吧】），以此类推，这样你就获得了一个抽象数据类型——菜谱的模板。所以抽象数据类型很多时候是通过分析大量数据找出其中的共性整理后形成的，可以一定程度上提高效率。
后续的突发奇想：上面的菜谱模板，其实可以简化为一道菜的制作。我们每个人的口味都有着不同的区别，有些人喜欢吃辣，有些人喜欢吃酸，有些人喜欢吃甜，这就会导致我们每个人做出来的相同的菜会有不同的风味，对应到抽象数据类型里面，就是你可以给它加各种你喜欢/需要的配菜和调料（各种成员变量和相对应配套使用的函数）。所以，为了你达到效果/目的，你就可以按照你的需求来配菜，调料，烹饪。
【加油，希望写完代码的你也能像成功做完一道精美的菜品一样快乐，代码和美食均不可辜负哦】
那么为什么数据结构的第一份笔记要写抽象树数据类型呢？ 原因很简单，因为数据结构里面每一种结构都是一种抽象数据类型，是程序员基于大量问题的解决方法总结出来的规律，是量变引起质变的结果，我觉得理解好这个初始概念对于之后学习数据结构里每一种结构的理解与想象都有所帮助。
总结 简单的介绍了什么是数据类型，什么抽象数据类型，一个是归类，一个是归纳。
最后，希望我写的理解能对你有所帮助，谢谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d7b6f3ef71b9774b3b8f468c5044559/" rel="bookmark">
			Doris的分区Partition和分桶Bucket介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Doris的分区Partition和分桶Bucket介绍 Doris数据库是一个分布式的列式存储数据库，它支持分区和分桶两种数据划分方式
分区：Doris数据库支持水平分区，即将数据按照某个字段的值进行分区，相同的值会被分配到同一个分区中。这种方式可以将数据均匀地分布到不同的节点上，提高查询效率和并行处理能力。分桶：Doris数据库支持垂直分桶，即将同一行数据的不同列分别存储在不同的桶中。这种方式可以将经常一起查询的列存储在同一个桶中，提高查询效率。节点负载均衡：Doris数据库可以将数据均匀地分布到不同的节点上，保证每个节点的负载均衡，提高系统的可扩展性和稳定性。数据压缩：Doris数据库支持多种数据压缩算法，可以将数据在存储时进行压缩，减少存储空间，降低存储成本。数据副本：Doris数据库支持数据副本，可以将数据复制到多个节点上，提高系统的容错能力和可用性。 ​ Doris 支持两层的数据划分。第一层是 Partition，支持 Range 和 List 的划分方式。第二层是 Bucket（Tablet），仅支持 Hash 的划分方式。
​ Doris数据划分也可以仅使用一层分区。使用一层分区时，只支持 Bucket 划分
1. Partition - 分区 Partition 列可以指定一列或多列，分区列必须为 KEY 列。不论分区列是什么类型，在写分区值时，都需要加双引号。分区数量理论上没有上限。当不使用 Partition 建表时，系统会自动生成一个和表名同名的，全值范围的 Partition。该 Partition 对用户不可见，并且不可删改。创建分区时不可添加范围重叠的分区。 Partition，支持 Range 和 List
1.1 Range 分区使用介绍 Range分区是一种基于分区键对表进行分区的方式，分区键指的是表中的某一列，而Range则是指这个列的值的范围。使用Range分区，可以将数据按照列的值的范围进行划分，将数据分散到不同的节点上，以实现分布式存储和查询
分区列通常为时间列，以方便的管理新旧数据
Partition 支持通过 VALUES LESS THAN (...) 仅指定上界，系统会将前一个分区的上界作为该分区的下界，生成一个左闭右开的区间。也支持通过 VALUES [...) 指定上下界，生成一个左闭右开的区间
当不使用Partition建表时，系统会自动生成一个和表名同名的，全值范围的 Partition。该Partition对用户不可见，并且不可删改
官方示例介绍
1.1.1 建Range Partition测试表 -- Range Partition use test_db; CREATE TABLE IF NOT EXISTS test_db.example_range_tbl ( `user_id` LARGEINT NOT NULL COMMENT "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d7b6f3ef71b9774b3b8f468c5044559/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dc697dee5a7a6928725e1077974ca3f/" rel="bookmark">
			ping和telnet命令的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ping 命令
作用：
打开 cmd 命令行可以测试某个 ip 是否可以连通。
查看 IP 方法:
window： ipconfig 命令：
ping ip
ping ip -t 一直ping，直至按Ctrl+c结束
二、telnet 命令
作用：
telnet 命令可以帮助我们去测试服务器上的某个端口是否可连接。 一般没开启 cmd 会提示无该命令。因此需要开启 telnet 命令，开启步骤如下：
开始 -&gt; 控制面板 -&gt; 程序 -&gt; 启用或关闭 Window 功能, 勾选 Telnet 服务器和 Telnet客户端（注意：电脑不同位置可能也不同，可自行百度）。
命令：
telnet ip 端口号
例如：
退出可输入logout,之后按enter
Telnet 还有其他常用的命令：
open ：使用 openhostname 可以建立到主机的 Telnet 连接。
close ：使用命令 close 命令可以关闭现有的 Telnet 连接。
display ：使用 display 命令可以查看 Telnet 客户端的当前设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dc697dee5a7a6928725e1077974ca3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91227aa2ccf2a7157e5b2d9082280285/" rel="bookmark">
			java Filter过滤器例外URL设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在web.xml声明的一个filter中：
&lt;!– session过滤filter –&gt;
&lt;filter&gt; &lt;filter-name&gt;SessionFilter&lt;/filter-name&gt; &lt;filter-class&gt; com.iqbon.jcms.web.util.SessionFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;excludedPages&lt;/param-name&gt; &lt;param-value&gt;/admin/login.do&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;SessionFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 可以看到url-pattern的设置里面过滤的url规则是/admin/*，如果要把/admin/login.do排除在过滤url之外。
可以结合init-param的初始化参数和HttpServletRequest的getServletPath()方法来判断。
&lt;init-param&gt; &lt;param-name&gt;excludedPages&lt;/param-name&gt; &lt;param-value&gt;/admin/login.do&lt;/param-value&gt; &lt;/init-param&gt; 其次在filter的Java代码中加上判断：
import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import org.apache.commons.lang3.StringUtils; import com.iqbon.jcms.util.KeyConstant; /** * session过滤器 */ public class SessionFilter implements Filter { /** * 需要排除的页面 */ private String excludedPages; private String[] excludedPageArray; /** * @see Filter#destroy() */ public void destroy() { return; } /** * 对session进行判断当前访问是否有登录 */ public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { boolean isExcludedPage = false; for (String page : excludedPageArray) {//判断是否在过滤url之外 if(((HttpServletRequest) request).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91227aa2ccf2a7157e5b2d9082280285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e703f4fdf6461a9826c09abf06387a/" rel="bookmark">
			swiper实现点击切换slide/图片效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		swiper的切换方式一般为拖拽切换，滑动切换。
如果想要实现点击每一个slide就切换成下一个slide，那么可以使用click方法实现。
click方法 ：回调函数，当你点击或轻触Swiper 后执行，相当于tap。
接受swiper实例和touchend事件作为参数。
注：Swiper5版本之前会有300ms延迟。
文档链接：swiper-click方法
当swiper开启循环模式：loop设置为 true 则开启循环(loop)模式。loop模式：会在原本slide 前后复制若干个slide (默认一个)并在合适的时候切换，让Swiper看起来像是循环的。 需要注意slide在开启循环模式与未开启循环模式的索引值变化。
以下swiper共有4个slide，当第一遍循环完成后，第二遍及以后循环时，第一个slide的索引值会变成5。第二个slide的索引值会变成2。
var swiper = new Swiper('.swiper-container', { effect: 'fade', loop:true, autoplay: { delay: 3000, disableOnInteraction: true, }, on:{ click: function(){ //当切换到第一个slide的时候 if(this.activeIndex == 5) { //控制Swiper切换到指定的slide swiper.slideTo(2); } else { // this.activeIndex返回当前活动块(激活块)的索引。loop模式下注意该值会被加上复制的slide数。 swiper.slideTo(this.activeIndex + 1); } }, }, }); 如果对你有所帮助，请记得一键三联哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b4ce62e881b6d4760822c33babf37f6/" rel="bookmark">
			Tkinter的update()和after()与mainloop()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# https://zditect.com/main-advanced/python/tkinter-after.html # 无意间查到上述网址，但程序代码略有问题，进行修正。 import tkinter as tk from tkinter import ttk import time class App(tk.Tk): def __init__(self): super().__init__() self.title('Tkinter `after()` Demo') self.geometry('300x100') self.style = ttk.Style(self) self.button = ttk.Button(self, text='Wait 3 seconds') self.button['command'] = self.start self.button.pack(expand=True, ipadx=10, ipady=5) def start(self): self.change_button_color('red') time.sleep(3) self.change_button_color('black') # tkinter更新颜色必须在主线程，由于没有返回主线程的路径，tkinter没能及时更改颜色，延时3秒后，又更改颜色为黑色，之后便立即执行，所以实际效果是始终为黑色 # 要想实现”变红色-延时3秒-变黑色“效果, 可以使用update函数强制执行一次主线程，以便处理挂起的事件（self.change_button_color('red')），然后延时3秒（用不加回调函数的after(3000)或者sleep(3)均可） # self.button.update() # self.button.after(3000) # 也可以直接使用带回调函数的after函数，该函数作用是向事件循环（待办列表）中添加一个事件（回调函数）以及（延时）运行它的时间，到时间mainloop会执行回调函数 # self.button.after(1, lambda: self.change_button_color('red')) # self.button.after(3000, lambda: self.change_button_color('black')) def change_button_color(self, color): self.style.configure('TButton', foreground=color) if __name__ == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b4ce62e881b6d4760822c33babf37f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/205d2a2fd0feddeac9d5af45d7d1d03d/" rel="bookmark">
			微信小程序多列选择器实现日期&#43;时间的选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.实现效果 2.实现原理 mode='multiSelector'多列选择器 自定义范围数组range 3.实现代码
&lt;!--pages/jsCase/multiTime/index4.wxml--&gt; &lt;view class="act_box"&gt; &lt;view class="act_item flex j_b"&gt; &lt;view class="nowp"&gt;&lt;text class="require"&gt;*&lt;/text&gt; 开始时间： &lt;/view&gt; &lt;picker mode="multiSelector" value="{{start_time}}" data-type="start_time" data-param='start_time_p' bindchange="changeDateTime" bindcolumnchange="changeDateTimeColumn" range="{{dateTimeArray}}"&gt; &lt;view class="flex-row act_right"&gt; &lt;text wx:if="{{!start_time_p}}"&gt;请选择&lt;/text&gt; &lt;text wx:else class="sel_text"&gt;{{start_time_p}}&lt;/text&gt; &lt;/view&gt; &lt;/picker&gt; &lt;/view&gt; &lt;view class="act_item flex j_b"&gt; &lt;view class="nowp"&gt;&lt;text class="require"&gt;*&lt;/text&gt; 结束时间： &lt;/view&gt; &lt;picker mode="multiSelector" value="{{end_time}}" data-type="end_time" data-param='end_time_p' bindchange="changeDateTime" bindcolumnchange="changeDateTimeColumn" range="{{dateTimeArray}}"&gt; &lt;view class="flex-row act_right"&gt; &lt;text wx:if="{{!end_time_p}}"&gt;请选择&lt;/text&gt; &lt;text wx:else class="sel_text"&gt;{{end_time_p}}&lt;/text&gt; &lt;/view&gt; &lt;/picker&gt; &lt;/view&gt; &lt;/view&gt; /* pages/jsCase/multiTime/index4.wxss */ .act_item { width: 702rpx; background: #FFFFFF; border-radius: 16rpx; margin-bottom: 24rpx; box-sizing: border-box; padding: 24rpx; position: relative; font-size: 28rpx; color: #4D4D4D; font-weight: 500; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/205d2a2fd0feddeac9d5af45d7d1d03d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5df68e184df71255f673a4fdbdbfbb75/" rel="bookmark">
			spark编写WordCount
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、在hdfs创建in.txt文件二、运行wordcount 一、在hdfs创建in.txt文件
1.在hdfs的/user/spark/in/目录下建一个in.txt文件
分析如下：
(1).我们需要现在hdfs中创建文件所需目录。
1&gt;创建文件夹
[e93b8f root@master ~]$ hdfs dfs -mkdir /user [e93b8f root@master ~]$ hdfs dfs -mkdir /user/spark/ [e93b8f root@master ~]$ hdfs dfs -mkdir /user/spark/in 2&gt;也可通过命令创建多级目录。
[ebdfc5 root@master ~]$ hdfs dfs -mkdir -p /user/spark/in/ [ebdfc5 root@master ~]$ hdfs dfs -ls /user/spark/in/ 3&gt;通过命令查看是否创建成功
[ebdfc5 root@master ~]$ hdfs dfs -ls /user/spark/ (2).在根目录创建in.txt文件并将其传到hdfs中
1&gt;首先创建txt文件
[e93b8f root@master ~]$ vim in.txt 在文件中输入内容
hello world ni hao 2&gt;通过pwd查看本地文件所在路径
[ebdfc5 root@master ~]$ pwd 3&gt;文件创建成功之后，将本地的in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5df68e184df71255f673a4fdbdbfbb75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c60b33689d05f8bf4f3cd7a593cfb99/" rel="bookmark">
			SpringBoot 整合 Shiro 常见配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. Shiro 基础解释过滤器+AOP 实现安全认证权限管理逻辑了解 Shiro 的组织架构 二. SpringBoot 整合 Shiro1. 在项目中使用 Shiro 需要配置的地方2. 代码示例引入依赖请求接口自定义 Realm自定义 SessionManager自定义 Filter配置类 一. Shiro 基础解释 Shiro 是 apache 下的权限安全框架,通过该框架可以完成安全认证,例如登入,权限认证等,并且增加了加密认证,并发执行,缓存设计等
过滤器+AOP 实现安全认证权限管理逻辑 提供用户表,存储代表当前用户的数据例如用户名,密码等提供权限表,存储权限码提供角色表,一个角色可以持有一个或多个不同权限用户表添加角色字段,存储当前用户的角色安全认证: 用户登录时将用户信息存储到Session中(注意分布式环境下Session一致性问题),后续访问通过拦截器拦截获取Session中当前用户信息与用户表中进行比对,通过则放行,不通过则重定向到指定页面权限认证: 对不同接口设置不同的权限码,用户访问该接口时通过前置通知获取用户角色权限,与接口上的进行比对,成功则放行,失败则在前置通知中拒绝提示用户没有该权限 了解 Shiro 的组织架构 Shiro 的核心三大对象: Subject 代表一个用户(当前用户),通过该对象进行交互, SecurityManager 用户管理器,管理所有用户, Realm获取存储的真实数据,与当前请求的用户进行比对认证授权等
二. SpringBoot 整合 Shiro 1. 在项目中使用 Shiro 需要配置的地方 自定义 Realm,编写用户登入认证的方法,与授权方法,当用户登入时,会调用认证方法与授权方法,查询数据库中真实用户数据,与当前发送请求的用户信息进行比对,比对成功认证通过,获取当前用户的真实权限信息存储起来,供用户访问权限接口时获取,与接口上需要的权限信息进行比对,成功则放行自定义 SessionManager (不是必须的,专门针对提供App端,微信小程序端,微信公众号等等不支持Session),重新编写获取sessionId的方法,用户登入后,会将用户信息保存到Session中,并对Session进行持久化等设置,将该Session的id返回给给前端,在后续的访问中需要携带这个sessionId,此处获取sessionId,通过sessionId获取Session,判断是否已登入等,由于此处指名了获取SessionId的方式,那么在登入后后续访问接口时携带sessionId的方式要与此处获取的方式对应自定义Filter(不是必须的,专门针对一个接口多个角色或权限访问问题,自定义角色相关过滤器,权限相关过滤器等),Shiro默认的校验规则是全部满足,自定义修改为只要当前用户持有其中一个即可创建配置类,配置使用自定义Realm,配置缓存,配置SessionDAO持久化,配置密码校验规则,配置Shiro监管的请求接口,与接口上的权限,或角色… 2. 代码示例 引入依赖 除了SpringBoot依赖以外,此处使用了redis作为缓存,redis依赖,Shiro整合redis插件依赖,还有Shiro支持不同模板的依赖模板不同依赖不同
&lt;!--Shir0 权限框架--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--Shiro 支持 thymeleaf模板--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c60b33689d05f8bf4f3cd7a593cfb99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f919664a1291052c5723b6a532e517e0/" rel="bookmark">
			预览后缀名为dwg的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预览后缀名为dwg的文件 预览后缀名为dwg的文件，如： xxx.dwg，时 后端会把dwg文件转化为vsf流文件。然后前端可以借助visualizeJS进行预览，具体实现如下：
在Vue3中 1、在public中引入Visualize预览工具及其相关依赖 2、在index.html中引入 3、在.vue文件中使用 &lt;template&gt; &lt;canvas id="dwg-canvas" style="width: 100%; height: 100%"&gt;&lt;/canvas&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; import { watch } from 'vue'; // dwgUrl： vsf流文件路径 // 该路径可以是：本地文件路径，如：/public/xxx.vsf // 也可以是：后端接口 http:xxxx/xxx.vsf const props = defineProps({ dwgUrl: { type: String, default: () =&gt; '', }, }); const previewDWG = (dwgUrl) =&gt; { // getVisualizeLibInst 全局方法，只要引入了VisualizeJS即可使用 const lib = window.getVisualizeLibInst(); const token = localStorage.getItem('TOKEN') as string; const headers = { Authorization: `Bearer ${JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f919664a1291052c5723b6a532e517e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2b9c718e0c87cb681f38dcef289cea/" rel="bookmark">
			一秒钟变身明星：用swapface软件体验星光熠熠的感觉！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 你是否曾经想过能够用电脑或手机来实时地将自己的面部与其他人或角色进行交换？你是否曾经想过能够用一款简单易用的软件来制作出有趣或惊艳的面部交换直播、视频或图片？如果你的答案是肯定的，那么你一定要试试swapface软件，这是一款由Swapface开发的面部交换软件，它可以让你用AI技术来快速地生成逼真的面部交换效果。
swapface软件是什么？ swapface软件是一款在线平台，它可以让你连接你的摄像头，并且点击开始按钮，就可以实时地将你的面部与图库中数千个高质量、随时可用的面孔进行交换。你可以选择任何你喜欢的人物或角色，比如明星、政治人物、动漫人物、动物等，然后将他们的面部与自己或其他人进行交换，创造出各种有趣或惊艳的效果。
swapface软件的特点是什么？ swapface软件有以下几个特点： 它可以让你实时地进行面部交换，无需等待生成或下载，只要连接摄像头并点击开始按钮，就可以看到即时的效果。它可以让你从图库中选择任何你想要交换的面孔，图库中有数千个高质量、随时可用的面孔，无论是具体的人物、风格、气氛，还是抽象的概念、情绪、主题，都可以尝试选择。它可以让你进行直播、视频通话或娱乐应用，比如在Twitch、YouTube、Zoom等平台上进行面部交换直播，或者在微信、WhatsApp等平台上进行面部交换视频通话，或者在Instagram、TikTok等平台上进行面部交换娱乐应用。它可以保证你的隐私和安全，所有的过程和数据都在你自己的机器上运行，所以只有你自己可以访问你的数据。它也不会收集或存储你的任何个人信息或图片。 设备和环境要求： 安装软件前，需要显卡和网络摄像头。如果你想获得完美的换脸直播效果，一个好的支持的网络摄像头建议使用 1080P 和兼容 DirectX12 的显卡 (RTX 20+)。
swapface软件如何使用？ swapface软件非常简单易用，只需要以下几个步骤： 访问https://swapface.org/，进入swapface软件的主页。在主页上方点击“Download for Windows”按钮，下载并安装swapface软件到你的电脑上。打开swapface软件，并且连接你的摄像头。如果你没有摄像头，也可以使用手机作为摄像头，并且通过WiFi或USB连接到电脑上。在swapface软件中点击“Start”按钮，并且从图库中选择一个你想要交换的面孔。你也可以点击“Random”按钮来随机选择一个面孔。等待几秒钟，就可以看到实时的面部交换效果出现在屏幕上。你可以点击“Stop”按钮来停止面部交换，并且点击“Save”按钮来保存生成的图片。如果你想要进行直播、视频通话或娱乐应用，只需要在相应的平台上选择swapface软件作为摄像头输入源，并且开始你的活动。例如，在Twitch上进行直播时，在设置中选择swapface作为摄像头设备，并且开始直播。 照片换脸： 切换到“Image Swapface”tabsheet页，点击“Upload Image”来上传准备被替换的图片。 选择一个准备替换的model图片，点击“Upload”按钮。 点击“Start”按钮。 换脸后的效果： 视频换脸： 1）切换到“Video Swapface”tabsheet页。2）点击视频缩略图来上传准备被替换的视频。3）选择被替换的人脸。4）点击“Choose”按钮。 选择替换的面部，按“Start”按钮。 C:\Users\Public\Documents\Swapface\user_file\11175957012338181\video
换脸后的效果： swapface软件有什么用途？ swapface软件可以为各种创意项目提供灵感和素材，比如： 你可以用swapface软件来制作出一个搞笑或惊悚的面部交换直播，并且在Twitch或YouTube等平台上吸引更多人的关注和喜爱。你可以用swapface软件来制作出一个有趣或美丽的面部交换视频通话，并且在微信或WhatsApp等平台上给你的朋友或家人带来惊喜或欢乐。你可以用swapface软件来制作出一个创意或艺术的面部交换娱乐应用，并且在Instagram或TikTok等平台上展现你的才华和风格。 总之，swapface软件是一个非常有趣和有用的平台，它可以让你用AI技术来实时地生成逼真的面部交换效果。无论你是一个直播主、视频爱好者、娱乐玩家，还是一个普通爱好者，都可以在swapface软件中发挥你的想象力和创造力，并且享受创作和分享的乐趣。快去试试吧！
下载地址：https://mega.nz/file/EaIkiKzJ#cGhOLVRCUspPrS22EIBglHFjkArfH1HI01xI40Y1h0E 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d879a86cae996055e63f6359811427e0/" rel="bookmark">
			【python三维深度学习】python三维点云从基础到深度学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从三维基础知识到深度学习，将按照以下目录持续进行更新。更新完成的部分可以在三维点云专栏中查看。https://blog.csdn.net/suiyingy/category_11740467.htmlhttps://blog.csdn.net/suiyingy/category_11740467.html 1、点云格式介绍（已完成） 常见点云存储方式有pcd、ply、bin、txt文件，以及格式互转。open3d读写pcd和ply点云文件。含数据与python源码。
2、数据形态（已完成） 点云法向量、质心、体素、三角面。含数据与python源码。
3、三维变换（已完成） 旋转、平移、 立体几何投影理论分析、投影变换、仿射变换、缩放等，特别是包含了基于法向量的点云旋转，可以将激光雷达地面点云旋转到与xoy平面平行。 含数据与python源码。
4、点云可视化（已完成） Python四种点云可视化方案：mayavi、matplotlib、CloudCompare、open3d。含数据与python源码。
《python点云可视化》，“https://blog.csdn.net/suiyingy/article/details/124015667”。
5、点云配准（已完成） 包括ICP配准方法基本介绍和open3d实现。
6、点云拼接（已完成） 含数据与python源码。
7、点云下采样（已完成） 体素下采样、随机下采样、均匀下采样，含数据与python源码。
8、坏点过滤（已完成） NaN剔除、无效值剔除、标准差剔除、近邻点剔除，含数据与python源码。
9、点云分割（已完成） 8种点云聚类方法，如DBSCAN、KMeans等，即RANSAC平面分割。含数据与python源码。
10、表面重建（已完成） 4种点云表面重建方法，如Alpha Shape、Ball Pivoting、Poisson、VoxelGrid。含数据与python源码。
11、深度学习点云预处理（已完成） 深度学习中点云基本数据处理和增强方式，包括点云归一化、随机打乱、随机平移、随机旋转、随机缩放和随机丢弃等，持续总结与更新 。含数据与python源码。
12、深度学习点云采样（已完成） 最远点采样FPS(Farthest Point Sampling)、点云特征上采样。含数据与python源码。
13、三维深度学习数据集（持续更新） 已完成KITTI、Mini KITTI、S3DIS、Modelnet40等数据集的详细分析与可视化。
14、KITTI数据集详细解析（已完成） KITTI数据集详细解析，包括坐标变换、鸟瞰图（BEV）、前视图（FV）等。
15、深度学习PointNet目标分类（已完成） PointNet、PointNet++、MSG三维点云分类模型数据集、模型结构和代码等详细分析 。含数据与python源码。
16、深度学习PointNet语义分割（已完成） PointNet、PointNet++三维点云语义分割模型数据集、模型结构和代码等详细分析 。含数据与python源码。
17、三维深度学习VoxelNet详细解析（已完成） 数据集、模型结构和代码等详细分析，含数据与python源码。
18、三维深度学习Complex_yolov4详细解析（已完成） 数据集、模型结构和代码等详细分析，含数据与python源码。
19、mmdetection3d三维点云算法框架安装与调试（已完成） mmdetection3d、mmdetection、mmclassification三维点云算法框架安装与调试，包括基本的训练步骤，含数据与python源码。
20、三维目标检测算法Second详细解析（已完成） 数据集、模型结构和代码等详细分析，含数据与python源码。
21、三维目标检测算法Pointpillars详细解析（已完成） 数据集、模型结构和代码等详细分析，含数据与python源码。
22、深度学习点云算法（持续增加算法） 更多三维、二维感知算法和金融量化分析算法请关注“乐乐感知学堂”微信公众号，并将持续进行更新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b02d7efc8746a749c382a8fc3e2dca78/" rel="bookmark">
			Unity2d：通过单双指移动放大图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和移动相机比较类似，更改的值换为了image的RectTransform
文中用到的GameManager在这篇文章：Unity学习笔记：在GameManager里记录手游操作框架_努力长头发的程序猿的博客-CSDN博客_gamemanager unity
using System.Collections; using System.Collections.Generic; using UnityEngine; public class ShowMove : MonoBehaviour { private RectTransform rect , canvasRect; public float scale; private Vector3 lastclickpos, lastmappos; private Vector2 nextpos, v; private Vector2 lastLeftHandPos, lastRightHandPos; private float handDistancke,lastHandDistance; private bool mapmove; private float minSizeChange; private float maxSize = 2.0f, minSize = 1.0f; private float maxPosX = 2250.0f , maxPosY = 1250.0f; void Start() { rect = transform as RectTransform; canvasRect = transform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b02d7efc8746a749c382a8fc3e2dca78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee6bd3a81744cb4f9c6c4f971965222/" rel="bookmark">
			unity3d 两指缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System.Collections; using System.Collections.Generic; using UnityEngine; //两指缩放 public class ZoomControl : MonoBehaviour { //旧的触摸点位置 Vector2 oldPos1; Vector2 oldPos2; public delegate void ZoomEvent(); public ZoomEvent ZommOutEvent; //放大事件 public ZoomEvent ZommInEvent; //缩小事件 // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { //判断触摸点的数量是否为两个 if(Input.touchCount == 2) { if(Input.GetTouch(0).phase == TouchPhase.Began||Input.GetTouch(1).phase==TouchPhase.Began) { oldPos1=Input.GetTouch(0).position; oldPos2=Input.GetTouch(1).position; } //判断两个触摸点的状态是否为手指进行了移动 if (Input.GetTouch(0).phase == TouchPhase.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ee6bd3a81744cb4f9c6c4f971965222/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b66f1b7f06a3a03b9fed70abe266eb7/" rel="bookmark">
			JETSON TX2 NX刷机&#43;烧录系统，挂载固态硬盘保姆教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备工具 一块JETSON TX2 NX的板子（这里笔者拿到的是装好亚力克板的了） 官方给的跳线帽 3. 一台装了Ubuntu的电脑（这里是用的是SDKManager软件，需要使用Ubuntu，这里不要推荐双系统的，笔者用双系统在后面确认会出现ip的问题，需要使用20.4版本以下的Ubuntu系统，太高版本没有SDKManage用的版本 4. 显示屏，键盘，鼠标，电源线 5. 电脑和板子连接同一个网 二、系统烧录 1、首先我们的ubuntu要安装SDKManager软件 下载网站：JetPack SDK | NVIDIA Developer
我们先把跳线帽安装到板子上让板子进入一个系统 REC 刷机模式
将跳线帽连接到 FC REC 和 GND 引脚，也就是连接到核心板下方载板的第二和第三个引脚，如 下图所示
将跳线帽安装在红框位置
2、将 HDMI 显示屏、鼠标、键盘和 microUSB 数据线连接到 Jetson TX2 NX 上，最后再 接入电源。由于上一步已经将跳线帽连接 FC REC 和 GND 引脚，所以上电开机后会自动进入 REC 刷机模式，进入刷机模式电脑会黑屏，黑屏说明进入刷机模式，（连接好就是下图这个样子） 3、这里需要拥有一个NVIDIAD的账号，没有就直接用qq邮箱注册一个，（这里是下载到我们的虚拟机里面） 4、将usb线连接到我们的电脑，（建议拔一下在插一下），这里会选择进入虚拟机还是主机，（选择进入虚拟机） 5.、这个时候就连接到虚拟机上了，下载SDKManager后会进入下图这个界面 取消勾选 Host Machine和DeepStream，Host Machine是在你主机或者虚拟机上也安装环境，耽误时间且没有卵用，DeepStream在后面安装Jetson SDK Components时我们在选择，大红框的位置因为连接了usb线会有提示，选择对应的型号
点击CONTINUE，我们进行下一步，因为板子自带SD卡只有16GB，所以我们先只安装Jetson OS。勾选Jetson OS和最下面的I accept the terms and conditions of the license agreements，路径不需要修改也没必要修改，点击CONTINUE。
记得勾选I accept the terms and conditions of the license agreements.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b66f1b7f06a3a03b9fed70abe266eb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/628a157a97d2382761226637a3c99ff0/" rel="bookmark">
			函数的声明和定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
函数声明 函数声明格式
函数声明的作用： 代码示例
头文件中的函数声明
函数定义
代码示例
代码的模块化
函数声明 在C语言中，我们知道，对于变量，需要先声明再使用；对于函数，我们也需要声明再使用。
函数声明格式 int add(int x,int y);//一定不要忘记带; 因为编译器是从上往下扫描执行代码的，因此函数声明需要放在该函数被调用之前，目的是告诉编译器有这么一个函数。虽然我这里对函数做了一个声明，告诉编译器有这么一个函数，但是是否定义（实现）该函数，或者是后面是否调用该函数，也不一定需要。
函数声明的作用： 告诉编译器有一个函数叫什么，参数是什么，返回类型是什么。但是具体是否存在，函数声明决定不了。函数的声明一般出现在函数的使用之前，要满足先声明后使用。函数的声明一般要放在头文件中的。 代码示例 #include&lt;stdio.h&gt; //声明加法函数 int add(int a, int b); int main() { int a = 0; int b = 0; scanf("%d %d", &amp;a, &amp;b); int ret=add(a, b);//ret接收函数返回值 printf("%d\n",ret); return 0; } //实现加法函数 int add(int a, int b) { return a + b; } 这里如果不加函数声明，编译器就识别不了add函数，程序无法运行。
头文件中的函数声明 另外，函数的代码一般要放在头文件中。
例如：我们实现代码的模块化时，对于自己写的函数，可以将函数的声明放在头文件中
函数定义 函数的定义是指函数的具体实现，交代函数的功能实现。
代码示例 #include&lt;stdio.h&gt; //加法函数 int add(int a, int b) { return a + b; } int main() { int a = 0; int b = 0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/628a157a97d2382761226637a3c99ff0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/141/">«</a>
	<span class="pagination__item pagination__item--current">142/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/143/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>