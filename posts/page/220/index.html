<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd95e4e86b33964b71f56eec41938799/" rel="bookmark">
			【1024】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fccdc448a7ec972cabdfb8e3737890fd/" rel="bookmark">
			JumpServer的部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Linux服务器准备：
硬件配置如下：
2cpu 4G内存 50G硬盘
2、想要运行jumpserver，后台相关，需要软件如下：
python2解释器
Linux的命令、bash解释器 ls命令 &gt; 交给bash解释器，进行翻译之后 &gt; 再告诉Linux去执行
jumpserver是由python编程语言开发的，旧的jumpserver是由python2开发的，新版本是由Python3开发的
得准备如下版本：
python = 3.6.x
mysql server 必须大于等于5.6
mariadb 必须大于等于5.6 ，在centos 7系统上，Mysql由于收费了，开源社区就诞生了mariadb数据库，是开源的
redis 缓存数据库
部署jumpserver实践
1、环境初始化
环境准备，关闭防火墙
iptables -F ###清空规则
systemctl disable firewalld ###关闭防火墙，禁止开机自启
systemctl stop firewalld ###停止防火墙
getenforce ###获取当前SElinux状态，disabled为关闭，可手动修改：vi /etc/selinux/config
2、配置阿里云的yum源，以及epel源
wget -o /etc/yum.repos.d/Centos-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
wget -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
yum clean all ###清除之前的yum缓存 yum makecache ###生成薪的yum缓存，便于加速软件下载 3、安装系统初始化所需要的软件
yum install -y bash-completion vim lrzsz wget expect net-tools nc nmap tree dos2unix htop iftop unzip telnet sl psmisc nethogs glances bc ntpdate openldap-devel gcc
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fccdc448a7ec972cabdfb8e3737890fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86a3ad8293fae942dba2033b664ab73/" rel="bookmark">
			1024 程序员节 我聊聊容器docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker 容器已经出现很久了，本人用的不多，最近使用后知道是怎么回事。
先说说，容器，你可以理解为开辟一个空间，这个空间放了你放的环境，数据等一切。
我们用过vm虚拟机的人知道，vm是可以创建一个虚拟机的，实现了多种windows ubunbut 等系统，使用者可以随意切换，空间是相互独立的，只需要分配好大小和位置即可。同时我们可以直接加载镜像，用别人的环境，系统，实现开发。
用过python的也知道，python有conda 可以创建虚拟环境，随意创建不同python版本的虚拟环境，在虚拟环境中安装深度学习框架，因为像tensorflow \pytorch是比较依赖python cuda cudnn等版本。
还有一种形式，做服务器运维的同事知道，集群也是可以用模板进行管理的，模板也是一个环境，包括了系统、其他包、文件，都可以用来进行复制，这样就非常适合做一些环境的保存和恢复。
容器 ，docker 一样，它其实是类似上面我说到的虚拟机、conda之类。
那不同是什么呢，应该说它可以很大，可以创建系统，但比windows上的虚拟机方便。其次它管理要好，有很多镜像可以直接通过网络获取即可，免除了安装，可以直接使用。
可以试试看，还不错。希望用的愉快，最好是有网的情况体验，没网也能完，离线安装费点劲。
用代码改变世界，希望所有程序员 今天快乐，码上幸福。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/087631fc7670dc86f8292c134d7fa36b/" rel="bookmark">
			JAVA基础（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		11、HashMap和Hashtable的区别。
HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。
HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。
HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。
Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。
最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。
Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。
12、final, finally, finalize的区别。
final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。
finally是异常处理语句结构的一部分，表示总是执行。
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。
13、sleep() 和 wait() 有什么区别?
sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。
wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。
14、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?
方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被"屏蔽"了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。
15、error和exception有什么区别?
error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。
exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。
16、同步和异步有何异同，在什么情况下分别使用他们？举例说明。
如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。
当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。
17、abstract class和interface有什么区别?
声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。
接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。
18、heap和stack有什么区别。
栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。
堆是栈的一个组成元素
19、forward 和redirect的区别
forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。
redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。
20、EJB与JAVA BEAN的区别？
Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于Java Bean是被容器所创建（如Tomcat）的，所以Java Bean应具有一个无参的构造器，另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f51d81ad5936bd0540fa0bec4876b64b/" rel="bookmark">
			C#之DES加密解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、DES简介 在线DES加密/解密工具
DES算法是一种最通用的对称算法，因为算法本身是公开的，所以其安全性在于的安全性。基于的算法通常有两类：对称算法和公开算法。对称算法的对称性体现在加能够从解推算出来，反之亦然。在大多数对称算法中，加解密的是相同的，DES就是这样。可见，对称算法的加解都是保密的。而公开算法的加是公开的，解是保密的。
二、C#使用DES加密解密 加密 public static string EncryptString(string str, string sKey) { byte[] inputByteArray = Encoding.Default.GetBytes(str); using (DESCryptoServiceProvider des = new DESCryptoServiceProvider()) { des.Key = Encoding.ASCII.GetBytes(sKey);// 秘钥 des.IV = Encoding.ASCII.GetBytes(sKey);// 初始化向量 using (MemoryStream ms = new MemoryStream()) { using (CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(), CryptoStreamMode.Write)) { cs.Write(inputByteArray, 0, inputByteArray.Length); cs.FlushFinalBlock(); } var retB = Convert.ToBase64String(ms.ToArray()); return retB; } } } 解密 public static string DecryptString(string pToDecrypt, string sKey) { byte[] inputByteArray = Convert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f51d81ad5936bd0540fa0bec4876b64b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2da5072a7aa1e96e4eb9c04aabd143e/" rel="bookmark">
			数据结构 - 双链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 知识点一、单链表和双链表的区别：二、双链表的初始化三、双链表的插入四、双链表的删除五、双链表的遍历 知识点 一、单链表和双链表的区别： 单链表：无法逆向检索，有时候不方便双链表：可进可退，存储密度更低 二、双链表的初始化 双向链表创建的过程中，每一个结点需要初始化数据域和两个指针域，一个指向直接前趋结点，另一个指向直接后继结点。
bool InitDLinkList(DLinklise &amp;L){ L = (DNode *) malloc (sizeof(DNode)); //分配一个头结点 if(L == NULL) //如果内存不足，分配失败 return false; L -&gt; prior = NULL; //头结点的prior永远指向NULL l -&gt; next = NULL; //头结点之后暂时没有节点 return turn; } typedef struct DNode{ ElemType data; struct DNode *prior,*next; }DNode,*DLinklist; void testDLinkList (){ //判断双链表是否为空 //初始化双链表 DLinkList L; InitDLinkList(L); } bool Empty(DLinklist L){ if(L -&gt; next == NULL) return true; else return false; } 三、双链表的插入 一般双链表的插入都有两个指针，一个指向中的一个结点（就是要插入的位置设为p指针），可以在这个结点的前面也可以在这个结点的后面插入。有一个结点指向要插入的结点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2da5072a7aa1e96e4eb9c04aabd143e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e697871f4bfd1f8cf0c749d05a8df9a/" rel="bookmark">
			7-293 计算一组x和y
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-293 计算一组x和y 分数 10
全屏浏览题目
切换布局
作者 伍建全
单位 重庆科技学院
输入30个整数a1,a2,a3,…,a30，计算所有的x与y。已知：
输入格式: 30个整数
输出格式: 计算得到的x1, x2,.......,x10
计算得到的y1, y2,.......,y10
所有输出精确到小数点后3位。
注意：
1、输出的每个“=”左右各有一个空格，输出的每个“,”后有一个空格。
2、输出的所有符号必须是用英文输入法输入的符号。
输入样例: 29 62 4 44 42 4 79 47 45 39 98 58 38 72 66 91 85 29 58 70 89 11 58 65 5 39 47 3 85 33 输出样例: 在这里给出相应的输出。例如：
x[1] = 39.250, x[2] = 33.000, x[3] = 54.500, x[4] = 73.250, x[5] = 62.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e697871f4bfd1f8cf0c749d05a8df9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12aa6586b38cb07219084398388851b/" rel="bookmark">
			数据结构进制转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022.10.24这题的0输入输出却让我很艰难。最后就把函数题变编程题了。题目2-9，这个2-16，找的高中同学。
进制转换 任务描述编程要求测试说明C++代码 任务描述 本关任务：将十进制非负整数 n 转换成 base（2≤base≤9）进制数，并按位输出。
例如，若输入8和2，则应输出1000（即十进制数8转换成二进制表示是1000）。
编程要求 根据提示，在右侧编辑器补充完整void ten2other(int n, int base)的代码，将十进制非负整数 n 转换成 base（2≤base≤9）进制数，并按位输出。
测试说明 平台会对你编写的代码进行测试：
输入格式
输入两个参数。第一个为n，第二个为base。
输出格式
n转换为base进制的结果。
输入输出样例
输入1
6 4
输出1
12
输入2
10 2
输出2
1010
开始你的任务吧，祝你成功！
C++代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; using namespace std; char s[10005]; int main() { int x,n; //scanf("%d%d",&amp;x ,&amp;n); while(cin&gt;&gt;x&gt;&gt;n) { int count = 0; if(x == 0) { cout&lt;&lt;"0"; } if(n &lt; 10) { int r; if(x &lt; 0) { int x1 = abs(x); while(x1 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e12aa6586b38cb07219084398388851b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85ee97fdc7132c10a42747ffbfb6678d/" rel="bookmark">
			5种常见反爬策略及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的发展，越来越多的公司需要爬取各种数据来分析出自己公司业务的发展方向。而目前许多目标网站也有各种各样的措施来反爬虫，越是数据价值高的网站反爬做得也就越复杂。给大家列举了几个常见的反爬措施以及解决方案。
1、通过user-agent字段来反爬
最常见的反爬策略就是检测用户的请求头。这个是比较容易实现的反爬，破解起来也是比较容易的，解决方法就是伪装header，只要合理添加请求头就可以正常访问目标网站获取数据。
2、利用代理ip反爬
目前一般网站都会检测某个ip在单位时间内的请求次数，如果单位次数超过了这个阈值就会停止其请求访问。所以一般在爬取的时候我们都会用到代理ip来模拟真实用户使用不同的ip来访问目标网站。
我们通过代理的原理就能够很好地进行了解。
ip代理池架构
3、通过cookies反爬
cookies也是一个比较常见的反爬手段之一，可以把它和登录放在一起。这里需要注意的是，有些不需要登录的网站也会通过cookies来过滤一些没有经过伪装的爬虫。解决方案就是进行模拟登陆，成功获取cookies之后再进行数据爬取。
cookie代理池模块一般架构
4、通过验证码反爬
验证码也是一种比较常见的反爬方式，有的目标网站服务器在同一ip地址访问到一定数量之后，可以返回验证码让用户进行验证。我们常见的验证码形式也是非常多的，比如数字验证码、字母验证码、字符图形验证码。简单的验证码我们可以通过打码平台进行破解。复杂的话我们可以尝试模拟用户的行为绕过去，但是通常比较繁琐难度可能会比较大。
5、动态页面的反爬
有部分目标网站，我们爬取的数据是通过ajax请求得到的，或者Java生成的。
Selenium 可以做到可见即可爬。对于一些动态页面来说，此种抓取方式非常有效。
PhantomJS ：一个没有图形界面的浏览器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3020c819716f42c3b7292ad0f4ff053/" rel="bookmark">
			python神经网络编程 豆瓣,Python神经网络训练很慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、怎么用python训练神经网络 Python 可以用scikit-learn、Theano、pybrain等库来做神经网络，详细的内容可以搜索相关的例子和官方文档。
谷歌人工智能写作项目：小发猫
2、Python，神经网络训练模型，报错是字符串不能转换为浮点，请问怎么解决？ 可能需要将csv中的数据改为数字，可能默认是文本类型
看起来read_csv读出来是一个numpy.array
可以试下
读完csv后下一行改为
train = numpy.array(train，dtype='int64')
3、关于神经网络 需要学习python的哪些知识？ 最基础的部分的话需要：线性代数，机器学习，微积分，优化等等。
几乎所有操作都有矩阵运算，所以至少最基础的线性代数需要掌握
建议从单一的感知机Perceptron出发，继而认识到Decision Boundary(判别边界),以及最简单的一些“监督训练”的概念等，有机器学习的基础最好。就结果而言，诸如“过拟合”之类的概念，以及对应的解决方法比如L1 L2归一，学习率等也都可以从单个感知机的概念开始入门。
从单层感知器推广到普通的多层感知器MLP。然后推广到简单的神经网络（激活函数从阶跃“软化”为诸如tanh等类型的函数），然后引入特定类型的网络结构，比如最基本的全连接、前向传播等等概念。进而学习训练算法，比如反向传播，这需要微积分的知识（Chain rule）,以及非线性优化的最基础部分，比如梯度下降法。
其次至少需要具备一些适用于研究的编程语言的技能，例如python，matlab，（C++也可行）等，哪怕不自己实现最简单的神经网络而是用API，也是需要一定计算机能力才能应用之。
4、怎样用python构建一个卷积神经网络 用keras框架较为方便
首先安装anaconda，然后通过pip安装keras
以下转自wphh的博客。
#coding:utf-8 ''' GPU run command: THEANO_FLAGS=mode=FAST_RUN,device=gpu,floatX=float32 python cnn.py CPU run command: python cnn.py 2016.06.06更新： 这份代码是keras开发初期写的，当时keras还没有现在这么流行，文档也还没那么丰富，所以我当时写了一些简单的教程。 现在keras的API也发生了一些的变化，建议及推荐直接上keras.io看更加详细的教程。 ''' #导入各种用到的模块组件 from __future__ import absolute_import from __future__ import print_function from keras.preprocessing.image import ImageDataGenerator from keras.models import Sequential from keras.layers.core import Dense, Dropout, Activation, Flatten from keras.layers.advanced_activations import PReLU from keras.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3020c819716f42c3b7292ad0f4ff053/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fa5ae334930ba297e7f5aaaa04f89ee/" rel="bookmark">
			基于Vue2的antDesign组件总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Vue2的antDesign组件总结 表格组件a-table一、带复选框的表格，用户点击按钮，实现选择的复选框清空二、点击表头排序触发接口最终：表格组件的开发bug总结一、样式二、逻辑 a-pagination分页组件一、分页控件英文显示的问题二、分页组件的分页事件 a-input组件一、取消a-input的默认样式 a-selected组件一、取消a-selected的聚焦默认样式 主要包括以下组件
表格 表格组件a-table 一、带复选框的表格，用户点击按钮，实现选择的复选框清空 &lt;a-table :rowKey="row=&gt;{return row.id}" :row-selection="rowSelection" &gt; &lt;/a-table&gt; data() { selectedRowKeys : [] // 清空选中的项 } computed: { rowSelection() { return { selectedRowKeys : this.selectedRowKeys, // 一定要加上这一行代码，清除才会有作用 // 这里不能加括号 onChange: this.selectedTableRows, // 内置的禁止选中 getCheckboxProps : (record) =&gt;({ props : { disabled : record.isInner } }), }; } }, methods: { // 勾选表格复选框 selectedTableRows(selectedRowKeys, selectedRows) { // 批量选中的key this.selectedRowKeys = selectedRowKeys; }, } 二、点击表头排序触发接口 &lt;a-table @change="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fa5ae334930ba297e7f5aaaa04f89ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2bff1c990cbd140ab4fce47ffb115a7/" rel="bookmark">
			MATLAB中颜色模型介绍级各模型之间转换（RGB、HSV、NTSC、YCbCr、HSI）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.颜色模型定义
2.各颜色模型简介
3.颜色模型的转换
一、颜色模型定义 颜色模型：某个三维颜色空间中的一个可见光子集，它包含某个颜色域的所有颜色。例如，RGB颜色模型就是三维直角坐标颜色系统的一个单位正方体。颜色模型的用途是在某个颜色域内方便地指定颜色。由于每一个颜色域都是可见光的子集，所以任何一个颜色模型都无法包含所有的可见光。大多数的彩色图形显示设备一般都是使用红、绿、蓝三原色，我们的真实感图形学中的主要的颜色模型也是RGB模型，但是红、绿、蓝颜色模型用起来不太方便，它与颜色概念如色调、饱和度和亮度等没有直接的联系。颜色模型主要有RGB、HSV、YCbCr、NTSC等。
二、各颜色模型简介 (1)RGB模型
RGB是从颜色发光的原理出发来设计的，RGB模型分成了3个颜色通道，即红(R）、绿(G)、蓝（B)，RGB色彩模式使用RGB模型为图像中每一个像素的RGB分量分配一个0～255范围内的强度值。
RGB图像只使用3种颜色，就可以使它们按照不同的比例混合，在屏幕上重现16777216种颜色，每个颜色通道每种色各分为255阶亮度，在0时“灯”最弱——是关掉的，而在255时“灯”最亮。
(2)HSV模型
HSV模型是一种复合主观感觉的颜色模型。H、S、V分别指的是色调（彩)(hue)、色饱(saturation)和度与明度（value)。在这个模型中，一种颜色的参数便是由H、S、V3个分量构成的三元组。
HSV模型不同于RGB模型的单位立方体，而是对应于一个圆柱坐标系中的一个立体锥形子集。在这个锥形中，边界表示不同的色彩。份量表示颜色的种类，取值范围为01，相应的颜色从红、黄、绿、蓝绿、蓝、紫到黑变化，且它的值由绕V轴的旋转角决定，每一种颜色和它的补色之间相差180。S分量的取值范围也是01，表示所选色彩的纯度与该色彩的最大纯度的比例。相应的颜色从未饱和（灰度)向完全饱和（无白色元素）变化，当S=0.5时表示所选色彩的纯度为1/2。份量取值范围同样是0～1，从锥形顶点0变化到顶部1，相应的颜色逐渐变亮，顶点表示黑色，顶部表示色彩强度最大。
（3）YCbCr模型
YCbCr模型又称为YUV模型，是视频图像和数字图像中常用的颜色模型。在YCbCr模型中，Y为亮度，Cb和Cr共同描述图像的色调(色差)，其中Cb、Cr分别为蓝色分量和红色分量相对于参考值的坐标。
YCbCr模型中的数据可以是双精度类型，但存储空间为8位无符号整型数据空间，且Y的取值范围为16~235, Cb和Cr的取值范围为16～240。在目前通用的图像压缩算法中（(如JPEG算法），首要的步骤就是将图像颜色空间转换为YCbCr空间。
(4)NTSC模型
NTSC模型是一种用于电视图像的颜色模型。NTSC模型使用的是Y.I.Q颜色坐标系，其中，Y为光亮度，表示灰度信息;l为色调，Q为饱和度，均表示颜色信息。因此，该模型的主要优点就是能将灰度信息和信息区分开来。
(5)HSI颜色空间
HSI色彩空间是从人的视觉系统出发，用色调（Hue)、色饱和度(Saturation或Chroma)和亮度(Intensity或Brightness）来描述色彩的。
HSI色彩空间可以用一个圆锥空间模型来描述。这种描述HIS色彩空间的圆锥模型相当复杂，但确实能把色调、亮度和色饱和度的变化情形表现得很清楚。
通常把色调和饱和度通称为色度，用来表示颜色的类别与深浅程度。由于人的视觉对亮度的敏感程度远强于对颜色浓淡的敏感程度，为了便于色彩处理和识别，人的视觉系统经常采用HSI色彩空间，它比RGB色彩空间更符合人的视觉特性。
在图像处理和计算机视觉中大量算法都可在HSI色彩空间中方便地使用，它们可以分开处理而且是相互独立的。因此，在HSI色彩空间可以大大简化图像分析和处理的工作量。HSI色彩空间和RGB色彩空间只是同一物理量的不同表示法，因而它们之间存在着转换关系。
三、颜色模型的转换 MATLAB中提供了一些色彩模型转换函数，下面将分别对其进行介绍。
（1）rgb2hsv函数
在MATLAB中，rgb2hsv函数用于将RGB模型转换为HSV模型。该函数的调用方法如下。
(1)HSVMAP=rgb2hsv(RGBMAP)%%表示将RGB色表转换成HSV色表。 (2) HSV=rgb2hsv(RGB)%%表示将RGB图像转换为HSV图像。 %%rgb2hsv函数将RGB模型转换到HSV模型。 clc;%clc的作用就是清屏幕 clear;%clear是删除所有的变量 close all;%close all是将所有打开的图片关掉。 I=imread('E:\我的桌面\MATLAB\练习\1.jpg');%绝对路径的 RGB=I; HSV=rgb2hsv(RGB); %将RGB模型转换为HSV模型 subplot(1,2,1), imshow(RGB), title('RGB图像'); subplot(1,2,2), imshow(HSV), title('HSV图像'); （2） hsv2rgb函数
在MATLAB中，hsv2rgb函数用于将HSV模型转换为RGB模型。该函数的调用方法如下。
(1) RGBMAP=hsv2rgb(HSVMAP)%%表示将HSV色表转换成RGB色表。 (2)RGB=hsv2rgb(HSV)%%表示将HSV图像转换为RGB图像。 %%利用hsv2rgb函数将HSV模型转换为RGB模型。 clc;%clc的作用就是清屏幕 clear;%clear是删除所有的变量 close all;%close all是将所有打开的图片关掉。 I=imread('E:\我的桌面\MATLAB\练习\1.jpg');%绝对路径的 RGB=I; HSV=rgb2hsv(RGB); %将HSV模型转换为RGB模型 RGB1=hsv2rgb(HSV); subplot(1,3,1), imshow(RGB), title('RGB图像'); subplot(1,3,2), imshow(HSV), title('HSV图像'); subplot(1,3,3), imshow(RGB1), title('还原的图像'); （3）rgb2ntsc函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2bff1c990cbd140ab4fce47ffb115a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e731815cdbbbc00978b4c4f2bfe83de/" rel="bookmark">
			vue2 功能：取消编辑表单显示原数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题解决思考case 1case 2 问题 如图点击修改之后对可修改的表单进行编辑。
要实现点击取消，恢复原数据显示。（这里的功能其实跟之前修改表格，取消导致原数据出现数据消失问题解决原理一样，都是要深拷贝数据之后再进行回显）
解决 data
data() { return { // userinfo form userForm: {}, // store old userinfo form editUserForm: {}, } }, html
&lt;el-form-item v-if="updateMark"&gt; &lt;el-button @click="stateOfUpdatechange($event)"&gt;修改&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;el-form-item v-else&gt; &lt;el-button type="primary" @click="updateUserInfo" plain&gt; 确认&lt;/el-button&gt; &lt;el-button type="danger" @click="stateOfUpdatechange" plain&gt; 取消&lt;/el-button&gt; &lt;/el-form-item&gt; js(使用JSON.parse(JSON.stringify())对数据进行深拷贝）
// state of edit change stateOfUpdatechange(e) { console.log(e.target) this.updateMark === true ? (this.updateMark = false) : this.updateMark = true // back to old form data this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e731815cdbbbc00978b4c4f2bfe83de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36458292215df088efb68f0319d768f1/" rel="bookmark">
			unity — 将海康SDK嵌入unity，发布后不能播放视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将海康的SDK嵌入unity后，在编辑器模式下可以很好的播放视频，但是发布为PC版后播放视频却失败了
原因如下，发布pc版后unity将海康SDK的库文件放到了此文件夹下
但是海康视频所用到的SDK，寻找路径时用的是绝对路径，所以虽然把SDK打包放到了pluings的文件夹下，但是仍找不到（应该是这个问题）
解决办法：
将海康的SDK直接考到电脑C盘，windows=&gt;System32的文件夹下即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8696add08783ca81bb668494f8329f20/" rel="bookmark">
			万字长文解析CV中的注意力机制（通道/空间/时域/分支注意力）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下方卡片，关注“自动驾驶之心”公众号
ADAS巨卷干货，即可获取
点击进入→自动驾驶之心技术交流群
后台回复【transformer综述】获取2022最新ViT综述论文！
注意力机制是机器学习中嵌入的一个网络结构，主要用来学习输入数据对输出数据贡献；注意力机制在NLP和CV中均有使用，本文从注意力机制的起源和演进开始，并主要介绍注意力机制以及在cv中的各类注意力机制。
前言
transformer从2020年开始在cv领域通过vision transformer大放异彩过后，让cv和nlp走入大一统成为可能，而后swin transformer,DETR等在目标检测等cv任务上的transformer系列迅速霸占榜首。
图源：https://paperswithcode.com
瞅瞅这个仗势，只要不考虑参数量，transformer可以在cv领域野蛮生长，今天给大家分享transformer中的核心部件：注意力机制，因大刀从事cv领域，因此在学习和整理注意力相关知识时，主要看注意力机制的前世今生，着力点在cv领域中，看看注意力机制怎么在cv领域散开花。
1
注意力机制来源
假设下班后的你，躺窝在沙发里，听着广播里的音乐，被旋律深深打动，你会持续的关注音乐旋律、歌词，而忽略掉楼下马路上的汽车鸣笛，这种自上而下有意识的聚焦称为聚焦式注意力；而这时你的猫跳到你身上，对你喵喵叫，你会从旋律中跳出来，转过身摸它，这种自下而上无意识、由外界刺激引发的注意力称为显著式注意力。
01 注意力机制的来源
注意力机制来源于上个世纪90年代，认知领域的学者发现，人类在处理信息时，天然会过滤掉不太关注的信息，着重于感兴趣信息，于是将这种处理信息的机制称为注意力机制。
在传统机器学习中，通过建立特征工程，将输入数据转换成数值向量，帮助模型选择有效、适当规模的特征，进而让模型可以有效且高效的提取特征，让下游任务更聚焦与和任务关系更密切的信号，这即是一种简单有效的注意力体现。
到2014年，Volodymyr的《Recurrent Models of Visual Attention》一文中将其应用在视觉领域，后来伴随着2017年Ashish Vaswani的《Attention is all you need》中Transformer结构的提出，注意力机制在NLP,CV相关问题的网络设计上被广泛应用。
02 注意力机制的分类
注意力机制主要分成软注意力机制（全局注意）、硬注意力机制（局部注意）、和自注意力机制（内注意）。
软注意力机制：根据每个区域被关注程度的高低，用0~1之间的概率值来表示；与硬注意力相比，软注意力是一个可微的过程，可以通过训练过程的前向和后向反馈学习得到；因为对每部分信息都有考虑，所以相对于硬注意机制，计算量比较大。
硬注意力机制：又称强注意力机制，即哪些区域是被关注的，哪些区域是不被关注的，是一个是或不是的问题，会直接舍弃掉一些不相关项，如在图像领域的图像裁剪，裁剪后留下的部分即被关注的区域；优势在于会节省一定的时间和计算成本，但是有可能会丢失一部分信息。值得注意的是，因其是一个不可微的过程，所以在cv领域，一般用在强化学习中；如在视频领域中，因为有时序性关系，每张图片即为某个时间点下的采样，强注意力机制则可以看成是否对该时间点的采样关注，可以通过强化学习来训练。
自注意力机制：自注意力是对每个输入赋予的权重取决于输入数据之间的关系，即通过输入项内部之间的相互博弈决定每个输入项的权重。与前两项机制相比，自注意力在计算时，具有并行计算的优势。
同时在计算机视觉领域，按照注意力关注的域，可以将其分成空间域注意力、通道域注意力、时间域注意力、混合域注意力和自注意力等。
引进一张cv领域一看就懂的综述性的图：
2
cv中的注意力机制
在cv领域，有各式各样的注意力机制，通过赋予空间中的不同通道或者区域以不同的权重，确定关注的权重，而不像之前如池化操作时，将局部空间中某块位置视为相同的权重，本文就去年注意力机制的一篇综述[1]，介绍cv中常见的带有注意力机制的网络。下图总结了目前常用的cv中的注意力机制，以及相互关系（建议收藏）。
本章就各种不同域的注意力机制选择其中一个重点讲解，其他的注意力机制会配上论文和对应代码，并简要解释。
通道注意力机制
通道注意力机制在计算机视觉中，更关注特征图中channel之间的关系，而普通的卷积会对通道做通道融合，这个开山鼻祖是SENet,后面有GSoP-Net，FcaNet 对SENet中的squeeze部分改进，EACNet对SENet中的excitation部分改进，SRM,GCT等对SENet中的scale部分改进。
SENet
paper：https://arxiv.org/abs/1709.01507 github: pytorch:https://github.com/moskomule/senet.pytorch
SENet《Squeeze-and-Excitation Networks》是CVPR17年的一篇文章，提出SE module。在卷积神经网络中，卷积操作更多的是关注感受野，在通道上默认为是所有通道的融合（深度可分离卷积不对通道进行融合，但是没有学习通道之间的关系，其主要目的是为了减少计算量），SENet提出SE模块，将注意力放到通道之间，希望模型可以学习到不同通道之间的权重：
SE模块由三个部分组成：squeeze、excitation和scale。首先对h*w*c2大小的feature map 做squeeze操作将其变成1*1*c2大小，这一步原文中使用简单粗暴的GAP(全局平均池化)；第二步excitation操作，对1*1*c2的特征图经过两次全连接，特征图大小1*1*c2→1*1*c3→1*1*c2，再对1*1*c2的特征图做sigmoid将值限制到[0,1]范围内；第三步scale,将1*1*c2的特征权重图与输入的h*w*c2的feature map在通道上相乘；完成SE模块的通道注意力机制。
值得注意的是，在squeeze部分，作者使用的是最简单的全局平均池化的方式，主要原因是作者基于通道的整体信息，关注通道之间的相关性，而不是空间分布的相关性，也尽可能的屏蔽掉空间分布信息；
在excitation部分，作者通过两个全连接实现1*1*c2→1*1*c3→1*1*c2，第一个全连接层将c2压缩到c3，用于计算量减少，在原文中作者做实验后发现c3=c2/16时，能实现性能和计算量的平衡。
SE模型同Inception，可以即插即用，理论上可以安插在任意一个卷积后面，简单方便，只会增加一点参数量和计算量。
GSoP-Net
paper：https://arxiv.org/abs/1811.12006
github:https://github.com/ZilinGao/Global-Second-order-Pooling-Convolutional-Networks
SE模块中squeeze部分用的是全局平均池化，GSoP-Net的主要创新点是将一阶全局平均池化替换成二阶池化，主要操作为对输入为h*w*c‘的特征图先通过卷积降维到h*w*c,然后通道之间两两计算相关性，得到c*c的协方差矩阵，第i行元素表明第i i个通道和其他通道的统计层面的依赖。由于二次运算涉及到改变数据的顺序，因此对协方差矩阵执行逐行归一化，保留固有的结构信息。然后通过激励模块对协方差特征图做非线性逐行卷积得到1*1*4c的特征信息，后面同SENet。相对于SNet,增加了全局的统计建模。
FcaNet
paper：http://arxiv.org/abs/2012.11879
github: https://github.com/cfzd/FcaNet
FCANet主要也是更新SE模块中squeeze部分，作者设计了一种新的高效多谱通道注意力框架。该框架在GAP是DCT的一种特殊形式的基础上，在频域上推广了GAP通道注意力机制，提出使用有限制的多个频率分量代替只有最低频的GAP。通过集成更多频率分量，不同的信息被提取从而形成一个多谱描述。此外，为了更好进行分量选择，作者设计了一种二阶段特征选择准则，在该准则的帮助下，提出的多谱通道注意力框架达到了SOTA效果。
ECA-Net
paper: https://arxiv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8696add08783ca81bb668494f8329f20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf24628edf1f2cd2306468407a8d6125/" rel="bookmark">
			【python数据处理】针对列表元素进行计数的多种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对列表元素进行计数的多种方法 0 测试数据1 使用第三方模块1.1 借助numpy模块1.2 借助pandas模块 2 借助本地collections模块3 仅使用python基础语法进行计数3.1 借助字典数据结构3.2 借助集合数据结构 手动反爬虫： 原博地址 https://blog.csdn.net/lys_828/article/details/127484453 知识梳理不易，请尊重劳动成果，文章仅发布在CSDN网站上，在其他网站看到该博文均属于未经作者授权的恶意爬取信息 0 测试数据 # 测试数据 ls = [1,2,3,2,1,2,4,5,4,5,2,5] 1 使用第三方模块 1.1 借助numpy模块 import numpy as np np.unique(ls,return_counts=True) 输出结果为：
1.2 借助pandas模块 import pandas as pd pd.Series(ls).value_counts().to_dict() 输出结果为：
2 借助本地collections模块 python中自带的collections模块可以实现很多关于数值的操作运算，比如里面的Counter方法，就可以实现快速计数
#方式三：使用python自带的标准模块 from collections import Counter c = Counter(ls) c c.most_common(2) dict(c) 输出结果如下：
3 仅使用python基础语法进行计数 3.1 借助字典数据结构 第一种： 核心是借助字典中的fromkeys()方法，创建一个各唯一元素对应值为0的字典
#第一种：先创建一个各唯一元素对应值为0的字典 dic = dict.fromkeys(ls,0) print('初始化的空值字典：',dic) for k in ls: dic[k] += 1 print('完成计数后的字典：',dic) 第二种：借助字典的get()方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf24628edf1f2cd2306468407a8d6125/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b40ef67942748fdfee44f1b9da20d44b/" rel="bookmark">
			小程序——下拉选择框组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、效果 二、说明 最近在开发微信小程序，但是用的lin-ui和@vant 都没有下拉选择框组件。在网上搜索一番后，发现了一个挺简单且很好用的下拉框组件。
链接在这里：https://blog.csdn.net/WeiflR10/article/details/121494131
原文中是直接写入数据，在此基础上我修改了一下，让它成为一个可复用的组件。
三、代码 my_select.js Component({ properties: { title:{ type: String, value: "" }, nameList: { type: Array, value: [], observer: function(){ //有的时候选项组是后端获取数据来的，初始化时可能为[]，所以这里使用obersver，当父组件中值改变时触发 this.processData(); } }, nowId: { type: Number, value: -1 }, nowName: { type: String, value: "", observer: function(){ this.setData({select: this. properties.nowName, selectId: this.properties.nowId,}); } }, placeholder: { type: String, value: "" } }, /** * 页面的初始数据 */ data: { selectcontent: [], changable: false, //箭头切换 select: undefined, //选中的值 selectId: undefined, //选中的id }, methods: { // 下拉框收起和展开 startChange(e) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b40ef67942748fdfee44f1b9da20d44b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a5d28652609ec42244bb6f295b4c73/" rel="bookmark">
			Qt 程序获取执行路径等各种路径方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 程序获取程序所在路径、用户目录路径、临时文件夹等特殊路径的方法 程序所在路径当前工作目录用户目录路径我的文档路径桌面路径程序数据存放路径临时文件路径QTemporaryFileQTemporaryDir Qt 项目获取程序所在路径、用户目录路径、临时文件夹等特殊路径的方法。 在我们的开发过程中，经常需要访问一些特殊的路径，比如程序所在的路径、用户目录路径、临时文件夹等。 在 Qt 中实现这几个功能所用的方法虽然都不难，但是各不相同，每次用到时还要现去查，很不方便，以下是各种路径的实现方式。 程序所在路径 获取程序所在路径，QCoreApplication 类里就实现了相关的功能：
QString QCoreApplication::applicationDirPath(); 比如我们有一个程序在：
C:/Qt/test/test.exe 那么 qApp-&gt;applicationDirPath() 的结果是：
C:/Qt/test 如果除了程序所在路径，我们还想要程序的完整名称。那么可以这么写：
qApp-&gt;applicationFilePath(); 还是上面的例子，结果是：
C:/Qt/test/test.exe 当前工作目录 QDir 提供了一个静态函数 currentPath() 可以获取当前工作目录，函数原型如下：
QString QDir::currentPath() 如果我们是双击一个程序运行的，那么程序的工作目录就是程序所在目录。
如果是在命令行下运行一个程序，那么运行程序时在命令行的哪个目录，那个目录就是当前目录。
用户目录路径 Qt 4 中的方法。
下面的方法只对 Qt 4 有效，Qt 5 已经删除了 storageLocation() 方法。
QDesktopServices::storageLocation(QDesktopServices::HomeLocation); Qt 5 中引入的方法:
QStandardPaths::writableLocation(QStandardPaths::HomeLocation); 或者
QStandardPaths::standardLocations(QStandardPaths::HomeLocation); 这两个方法的区别是 standardLocations() 返回值是 QStringList。当然对于 HomeLocation 来说这个 QStringList 中只有一个 QString。
还有另外一种方法，利用 QDir 类的一个静态函数：
QDir::homePath(); 执行上面的程序，结果是：
C:/Users/Administrator 我的文档路径 Qt 4 中的方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17a5d28652609ec42244bb6f295b4c73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0895298a6c08334623a19f3840e6cf0/" rel="bookmark">
			c语言基础题（笔记一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言基础题 1.输出倒三角图案 2.如果已知英制长度的英尺foot和英寸inch的值，那么对应的米是(foot+inch/12)×0.3048。现在，如果用户输入的是厘米数，那么对应英制长度的英尺和英寸是多少呢？别忘了1英尺等于12英寸。3.算术入门之加减乘除4.已知某位学生的数学、英语和计算机课程的成绩分别是87分、72分和93分，求该生3门课程的平均成绩（结果按整型输出）。5.世界上不同国家有不同的写日期的习惯。比如美国人习惯写成“月-日-年”，而中国人习惯写成“年-月-日”。下面请你写个程序，自动把读入的美国格式的日期改写成中国习惯的日期。6.如果今天是星期三，后天就是星期五；如果今天是星期六，后天就是星期一。我们用数字1到7对应星期一到星期日。给定某一天，请你输出那天的“后天”是星期几。7.有时候人们用四位数字表示一个时间，比如 1106 表示 11 点零 6 分。现在，你的程序要根据起始时间和流逝的时间计算出终止时间。8.BCD数是用一个字节来表达两位十进制的数，每四个比特表示一位。所以如果一个BCD数的十六进制是0x12，它表达的就是十进制的12。但是小明没学过BCD，把所有的BCD数都当作二进制数转换成十进制输出了。于是BCD的0x12被输出成了十进制的18了！9.计算符号函数的值10.成绩转换 1.输出倒三角图案 输出格式:
按照下列格式输出由“*”组成的倒三角图案。
#include&lt;stdio.h&gt; int main(void){ printf("* * * *\n * * *\n * *\n *"); } C语言scanf：读取从键盘输入的数据（含输入格式汇总表）
2.如果已知英制长度的英尺foot和英寸inch的值，那么对应的米是(foot+inch/12)×0.3048。现在，如果用户输入的是厘米数，那么对应英制长度的英尺和英寸是多少呢？别忘了1英尺等于12英寸。 输入格式：
输入在一行中给出1个正整数，单位是厘米。
输出格式：
在一行中输出这个厘米数对应英制长度的英尺和英寸的整数值，中间用空格分开。
输入样例：
170
输出样例：
5 6
#include&lt;stdio.h&gt; int main(void) { int cm=0; scanf("%d",&amp;cm); int foot=cm/30.48; int inch=((cm/30.48)-foot)*12; printf("%d %d",foot,inch); return 0; } 除法运算符" / "，如果是两个整数相除结果为整数 。
如果需要保留小数时 必须将其中一个除数转换为浮点数，（如运算q=a/b变成q=0.1a/b10把a先缩小10倍变成小数在运算后扩大10倍**
3.算术入门之加减乘除 对于输入的两个整数，按照要求输出其和差积商。
输入格式:
在一行内输入两个不超过100的非负整数a和b，中间以一个空格间隔，且保证b不为0。
输出格式:
共四行，格式是：
[a] + [b] = [a+b]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0895298a6c08334623a19f3840e6cf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f43a7cb76188156d06d358a1615463e6/" rel="bookmark">
			Redis 单线程为什么速度这么快
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结了四点原因
1、基于内存，操作速度更快，每条命令的执行时间很短。
2、执行命令采用的是单线程操作，省去了线程切换的时空消耗。
3、采用了I/O多路复用，利用了epoll，提升了redis的I/O利用效率。
4、优秀的底层数据结构，提升了数据处理速度，采用全局hash表，跳表、链表、压缩表等结构。
推荐一个可以画图的小工具:ProcessOn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c154223c38e3c10d771b79f98de26278/" rel="bookmark">
			centos7共享文件夹到windows访问教程 疑难问题解决--samba
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手把手教你 centos7共享文件夹到windows访问–samba 第一步：安装samba服务 yum install samba 第二步：启动samba服务 systemctl start smb 查看samba的状态 systemctl status smb 看到Active就说明在运行中了 第三步：关闭防火墙 systemctl stop firewalld.service //停止服务 systemctl disable firewalld.service //关闭开机启动 同时还有这一步（必须有，不然共享的目录没有写权限,通过getenforce命令可以查看修改后结果，必须为Disabled） 设置SELINUX=disabled（需要重启电脑） vi /etc/selinux/config文件中设置SELINUX=disabled ，然后重启服务器。 第四步：修改samba的配置文件 vi /etc/samba/smb.conf //进入配置文件 加入以下内容： [myshare] comment = Share Directories path = /home/myshare #有效地用户 valid users = root browseable = yes writeable = yes 第五步：需要添加一个用户来访问文件 也可以指定特定用户来访问
useradd test //添加用户 passwd test //修改密码 创建samba用户 smbpasswd -a test 第六步：添加共享文件夹 mkdir /home/test/myshare chmod -R 777 /home/test/myshare 涉及第五步时才需要更改共享的根目录文件夹属性 chown -R test:test /home/test 第七步：重启samba服务 systemctl restart smb 第八步：测试 在Windows系统上按下“win+r”键，输入"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c154223c38e3c10d771b79f98de26278/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9742d30adc482eb33b5e92a73b04ab1e/" rel="bookmark">
			嵌入式作业STM32采用串口DMA方式发送数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
要求
一.DMA的基本介绍
DMA的基本定义
DMA的主要特征
STM32F411x系列芯片DMA控制器
二.通过CubeMX配置项目
1.创建项目
2.选择芯片STM32F103C8T6
3.设置RCC 4.设置串口
5.设置NVIC Settings
6.DMA设置 7.DMA基础设置
8.时钟源设置 9.项目文件设置 三.在keil配置代码 1.打开通过CubeMX生成的项目
2.配置下载工具
3.添加代码 4.编译并烧录
5.程序实现
四.总结
五.参考资料
【STM32】HAL库 STM32CubeMX教程十一---DMA (串口DMA发送接收)
前言 软件版本:
STM32CubeMX:6.61
KEIl:5.61
mcuisp
firetools
硬件:
STM32F103C8T6
要求 STM32采用串口DMA方式，用115200bps或更高速率向上位机连续发送数据
一.DMA的基本介绍 DMA的基本定义 DMA，全称Direct Memory Access，即直接存储器访问。
DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。当CPU初始化这个传输动作，传输动作本身是由DMA控制器来实现和完成的。DMA传输方式无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场过程，通过硬件为RAM和IO设备开辟一条直接传输数据的通道，使得CPU的效率大大提高。
DMA的主要特征 ·每个通道都直接连接专用的硬件DMA请求，每个通道都同样支持软件触发，这些功能通过软件来配置。
·在同一个DMA模块上，多个请求间的优先权可以通过软件编程设置（共有四级：很高、高、中等和低），优先权设置相等时由硬件决定（请求0优先于请求1，依此类推）。
·独立数据源和目标数据区的传输宽度（字节、半字、全字），模拟打包和拆包的过程。源和目标地址必须按数据传输宽度对齐。
·支持循环的缓冲器管理。
·每个通道都有3个事件标志（DMA半传输、DMA传输完成和DMA传输出错），这3个事件标志逻辑或成为一个单独的中断请求。
·存储器和存储器间的传输、外设和存储器、存储器和外设之间的传输。
·闪存、SRAM、外设的SRAM、APB1、APB2和AHB外设均可作为访问的源和目标。
·可编程的数据传输数目：最大为65535（0xFFFF）。
STM32F411x系列芯片DMA控制器 DMA的工作框图如下图所示。DMA控制器和Cortex™-M4核心共享系统数据总线，执行直接存储器数据传输。当CPU和DMA同时访问相同的目标（RAM或外设）时，DMA请求会暂停CPU访问系统总线达若干个周期，总线仲裁器执行循环调度，以保证CPU至少可以得到一半的系统总线（存储器或外设）带宽。
DMA控制器传输作为AHB主设备操作直接存储器，它可以控制AHB总线的控制矩阵以启动AHB传送。它可以执行以下信息交换：
•外设到内存
•内存到外设
•内存到内存
DMA控制器提供两个AHB主端口：AHB内存端口（用于连接到内存）和AHB外设端口（用于连接到外设）。 但是，为了允许内存到内存的传输，AHB外设端口也必须可以访问内存。AHB从端口用于对DMA控制器的编程控制（仅支持32位访问）。
DMA处理
对于两个DMA控制器的系统实现如下图所示。DMA1控制器AHB外设端口没有像DMA2控制器那样连接到总线矩阵，所以只有DMA2能够执行内存到内存的数据传输。
DMA事务由给定数量的数据传输序列组成，可以传输的数据项的数量及其宽度（8位，16位或32位）可以通过软件编程实现。每个DMA传输都包含三个操作步骤：
·从外设数据寄存器或者从当前外设/存储器地址寄存器指示的存储器地址取数据，第一次传输时的开始地址是DMA_CPARx或DMA_CMARx寄存器指定的外设基地址或存储器单元；
·存数据到外设数据寄存器或者当前外设/存储器地址寄存器指示的存储器地址，第一次传输时的开始地址是DMA_CPARx或DMA_CMARx寄存器指定的外设基地址或存储器单元；
·执行一次DMA_CNDTRx寄存器的递减操作，该寄存器包含未完成的操作数目。
通道选择
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9742d30adc482eb33b5e92a73b04ab1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/794c8c09ecb4d90902beeca09aefc0d9/" rel="bookmark">
			mplab生态配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在MPLAB X IDE下配置XC编译器，需安装IDE和编译器。编译器应在MPLAB X IDE下自动配置。下面是配置步骤。
1. 1.从MPLAB X页面“microchip.com/mplabx”下载适用于您的OS的IDE并进行安装。
2. 2.从编译器页面“microchip.com/compilers”下载适用于您的OS的编译器并进行安装。
3. 3.打开IDE，在Tools &gt;&gt; Options &gt;&gt; Embedded &gt;&gt; Build Tools（工具 &gt;&gt; 选项 &gt;&gt; 已安装工具 &gt;&gt; 编译工具）下选中编译器。已安装工具将显示在“Tool-chain”（工具链）列表下。
如果出于某种原因，编译器未显示在“Tool-chain”列表下，请单击“Scan for Build Tools”（扫描编译工具），此操作将扫描计算机中的已安装工具，然后将扫描到的编译器添加到“Tool-chain”列表中。
也可以通过单击“Add”（添加）从“&lt;编译器目录&gt;/bin”路径手动添加编译器。
请注意，如果编译器未安装在其默认位置，您可能需要通过“Scan for Build Tools”使MPLAB X找到编译器
PIC Harmony组件安装、工程创建及烧录 3、PIC Harmony组件安装、工程创建及烧录_Huangtop的博客-CSDN博客_mplab x harmony3安装
PIC单片机入门教程（三）—— 安装编译器（MPLAB XC Compilers）_JYUNefe的博客-CSDN博客_怎么安装编译器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e884b3593c49b774a4d1fc96f9128d/" rel="bookmark">
			C&#43;&#43;学习（四九五）一个最简单的cmake工程文件（动态链接库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 生成的动态库为libpng.so
cmake_minimum_required(VERSION 3.12) # ---------------------------------------------------------------------------- # CMake file for libpng. See root CMakeLists.txt # # ---------------------------------------------------------------------------- project(libpng) # List of C++ files: include_directories(	${CMAKE_CURRENT_SOURCE_DIR} "${CMAKE_CURRENT_SOURCE_DIR}/include" ) # The .cpp files: file(GLOB lib_srcs *.c) file(GLOB lib_hdrs *.h) # ---------------------------------------------------------------------------------- # Define the library target: # ---------------------------------------------------------------------------------- set(the_target "png") add_library(${the_target} SHARED ${lib_srcs} ${lib_hdrs} ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fbcaeee68c097b0f99d2920a08f3054/" rel="bookmark">
			C&#43;&#43;学习（四九四）cmake从list从删除文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //生成文件列表 file(GLOB_RECURSE lib_srcs *.c) //输出文件列表，注意lib_srcs的写法（需要${}） MESSAGE(STATUS ${lib_srcs}) //从文件列表中删除文件，注意lib_srcs的写法（不需要${}），注意文件路径，不能写相对路径 #list(REMOVE_ITEM lib_srcs "src/autofit/aflatin2.c") list(REMOVE_ITEM lib_srcs "${CMAKE_CURRENT_SOURCE_DIR}/src/autofit/aflatin2.c") MESSAGE(STATUS "-----------------------------------------------------------------------------") MESSAGE(STATUS ${lib_srcs}) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa53b650d7821cdc44a2becbe5ce3e27/" rel="bookmark">
			Redis的拒绝策略Redis的key过期策略以及内存淘汰机制双写一致性问题 数据库缓存一致性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis的拒绝策略 Redis提供了5种数据淘汰策略：
volatile-lru(推荐)：使用LRU算法进行数据淘汰（淘汰上次使用时间最早的，且使用次数最少的key），只淘汰设定了有效期的key
allkeys-lru：使用LRU算法进行数据淘汰，所有的key都可以被淘汰
volatile-random：随机淘汰数据，只淘汰设定了有效期的key
allkeys-random：随机淘汰数据，所有的key都可以被淘汰
volatile-ttl：淘汰剩余有效期最短的key
Redis的key过期策略以及内存淘汰机制 博客
双写一致性问题 双写一致性问题
先更新数据库，后删除缓存
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60831d0e76ba3bba6e8c9ade8595c3ce/" rel="bookmark">
			2022数学建模国赛B题和C题高质量论文代码数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
B题论文
5.1 问题一的建模与求解
5.1.1 使用极坐标求解具体位置
C题论文
1.1 研究背景
1.2 问题的提
5.1 问题一的建模与求解
5.1.1 数据的预处理
B题论文 5.1 问题一的建模与求解 5.1.1 使用极坐标求解具体位置 假设圆周的半径为, .以无人机FY00为极点, 以FY00为端点且经过FY01的射线为极轴建立极坐标系.不失一般性, 假设在圆周上的其中一架发射信号无人机为FY01, 转化为极坐标后, 其对应的极坐标为 . 由于发射信号的无人机都是位置准确的, 所以另一架发射信号无人机的位置是根据编号固定的, 编号为FY0K, 由于理想状态下, 所有无人机均匀分布在圆周上, 则其对应的坐标为
点这里，获取​kdocs.cn/l/cpjzXWgD659Y
, 其中.接着, 假设接受信号的无人机的极坐标位置为 , 由于剩下无人机的位置略有偏差, 所以两个参数都需要进行确定. 接着, 我们去假设它与三架发射信号的无人机的夹角. 假设与FY00、FY01之间的夹角为, 与FY00、FY0K之间的夹角为, 与FY01、FY0K之间的夹角为.接下来需要通过已知信息来确定出相应接收信号无人机的极坐标.
我们将略有偏差的无人机与确定的无人机位置相连, 利用正弦定理, 通过联立方程组来解得极坐标
. 下面由于牵扯到角度, 还需要对K的不同值进行分类讨论：
情况i）当K=2时, 两个外围确定的无人机之间没有其他无人机：分布情况可视化如下图5.1所示：
​图5.1 两个外围确定的无人机之间没有其他无人机分布图，由上图5.1可知：若(绿色所示位置), 我们考察FY00、FY01、FY0K构成的三角形与FY00、FY02、FY0K构成的三角形, 根据正弦定理可得：
, （5-1）
由式（5-1）解得：
​
； （5-2）
根据图5.1可知：若(蓝色所示位置), 我们考察FY00、FY01、FY0K构成的三角形与FY00、FY02、FY0K构成的三角形, 根据正弦定理可得：
​
, （5-3）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60831d0e76ba3bba6e8c9ade8595c3ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3facdd75d19f5a8f8722aa53d5e2124f/" rel="bookmark">
			认识复杂度和简单排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		认识时间复杂度
常数时间的操作 一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。
时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作big O)来表示。具体
来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，
进而总结出常数操作数量的表达式。
在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那
么时间复杂度为O(f(N))。
已选择排排序为例子 [4, 5, 2, 3, 6, ..... , m] 有n个数 数据量 比较次数 交换次数 第一次：[0]~[n-1] n-2 1 第二次：[0]~[n-2] n-3 1 第三次：[0]~[n-3] n-4 1 ... ... ... 1 第n-1次 [0]~[1] 1 1 常数操作为：1+...+(n-3)+(n-2)+(n-1)+ 1+(n-4) +(n-3)+(n-2) + 1 + 1 + 1 最后表达式可表示为：f(N) = aN² + b N + c 去最高阶项，且忽略其系数，时间复杂度为O(N²) 评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行
时间，也就是“常数项时间”。
public static void prrocess1(){ // 时间复杂度 O(n) int N = 1000; int a = 0; for(int i=0; i&lt;N; i++){ a = 2+5; a = 4*7; a = 6*8; } } public static void prrocess2(){ // 时间复杂度 O(n) int N = 1000; int a = 0; for(int i=0; i&lt;N; i++){ a = 3 | 6; a = 3 &amp; 4; a = 4 ^ 785; } } // prrocess1和prrocess2的时间复杂度一样，实际运行时间决定算法流程的好坏 选择排序、冒泡排序细节的讲解与复杂度分析 /* [7,3,4,3,6,5] 0,1,2,3,4,5 第一次循环：[0]~[n-1] 排好1个数 [0]~[1] [3,7,4,3,6,5] [1]~[2] [3,4,7,3,6,5] [2]~[3] [3,4,3,7,6,5] [3]~[4] [3,4,3,6,7,5] [4]~[5] [3,4,3,6,5,7] 第一次循环：[0]~[n-3] 排好1个数 第一次循环：[0]~[n-4] 排好1个数 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3facdd75d19f5a8f8722aa53d5e2124f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fff036db4f14a2284e3d5b183257bcdc/" rel="bookmark">
			MybatisPlus注解多种方式实现一对一、一对多查询、增删改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境搭建 创建SpringBoot项目，引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 完成配置 server: port: 8089 spring: datasource: #数据源 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/jdbc?useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=UTC username: root password: root # mybatis-plus配置 mybatis-plus: configuration: map-underscore-to-camel-case: true # 开启自动驼峰映射 type-aliases-package: demo.domain # 别名扫描包 global-config: banner: off 创建数据库及表 Emp表
company表
项目结构图
实体类 员工实体 /** * 员工实体 */ @Data @NoArgsConstructor @AllArgsConstructor @TableName(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fff036db4f14a2284e3d5b183257bcdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/441d2c44cc83a2eb15ad99921b83303c/" rel="bookmark">
			解决 ArcMap 用户界面中多个对话框打开缓慢的性能问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在安装了大量字体的计算机上，此问题尤为严重。 受影响的对话框包括“图层属性”（用于要素图层）、“选项”、“符号属性编辑器”（用于字符标记）和“标注管理器”，然而所有带字体选择器控件的对话框的打开速度都会变慢。
Esri® 宣布推出 ArcGIS Desktop Dialog Initialization Performance Patch。 从 ArcGIS Desktop 10.5.1 起， 此修补程序专门处理此修补程序解决的问题下方列出的问题。
此修补程序解决的问题 BUG-000113336 - 带有字体选择器控件的对话框（包括“图层属性”、“选项”、“字符标记编辑器”和“标注管理器”）的打开速度都非常慢。 为避免在 10.6.1 中冲突，此修补程序还解决了以下问题：
BUG-000115147 - 在面上调用 ITopologicalOperator::Buffer 时，如果面退化为某个点，则缓冲区调用将崩溃。 为避免在 10.6 中冲突，此修补程序还解决了以下问题：
BUG-000117631 - 添加对 TLS 1.2 和 1.1 版本的支持下载链接Esri Support ArcMap 10.6 (10.6.1) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a1b5dd3c5222368ae5e43d2f1bc18db/" rel="bookmark">
			python刷题记录贴（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上贴链接: Python刷题记录帖
最近在问答里面刷提，遇到些有意思的问题，记录一下
一、如何判断用户输入的字符是哪种类型的 这里会用到python的几种内置函数isdigit()数字，isalpha()字母，isalnum()数字字母混合
代码如下：
str1 = input() if str1.isdigit(): a = "数字" elif str1.isalpha(): a = "字母" elif str1.isalnum(): a = "字母和数字的组合" else: a = "其他字符" print("输入的为{}".format(a)) 二、sin函数的变异 求1+1/3-1/5-1/7+1/9+1/11-…知道最后一项的绝对值小于10的-6次幂为止
注意符号位的变化规律，非一正一负，而是两正两负
结果保留6位小数
代码如下
sum1 = 0 j = 1 i = 1 s = 0 while 1/i &gt;= 10**-2:#小于10的-6次幂时条件为False,退出循环 if s == 2:#两次变换一次j的值(正负)并将s重置为0 j = -j s = 0 else: a = 1/i*j sum1 += 1/i * j i += 2 s += 1 print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a1b5dd3c5222368ae5e43d2f1bc18db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0aa95f248b25b5c241380bc21062447/" rel="bookmark">
			指针的定义方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简单的指针
数据类型 * 指针变量名； 如：
int *p ; // 定义了一个指针变量p 2、指针的运算符
&amp;（取地址） *（取值）
&amp;：获取一个变量的地址
* ：在定义一个指针变量时，起到标识作用，意思是定义了一个指针变量。除此以外，获取这个指针指向的地址内容。
例1
#include &lt;stdio.h&gt; int main() { //定义一个普通变量 int b =10; //定义一个指针变量 int *p; //给指针变量赋值 //将b的地址保存在p中 p = &amp;b; //p保存了b的首地址 //普通变量 printf("b = %d\n",b); printf("b=%p\n",&amp;b); //指针变量 printf("*p=%d\n",*p); //*p 表示获取指向该地址里面的值，即 10 printf("p=%p\n",p); //p是首地址了，无需再&amp;p return 0; } 运行结果
b = 10 b= 0x7ffcc45a8418 *p= 10 p= 0x7ffcc45a8418 扩展：如果在一行中定义多个指针变量，每一个指针变量前面都需要加 * 来修饰。 int *p , *q ; //定义了两个整形的指针变量p和q
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0aa95f248b25b5c241380bc21062447/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe48ed5a221e50164e2b1a13079291b/" rel="bookmark">
			dns手动模式功能详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		acme.sh的DNS手动模式生成证书
需要一个有公网ip的机器
一、安装
curl https://get.acme.sh | sh
二、确保服务器的nginx和apache没有运行，别占用80端口（DNS手动模式不需要）
三、动手
命令就一行，出现了报错，要求在dns解析里加入两行txt解析
root@david-test:~/.acme.sh# acme.sh --issue -d bombstory.com -d *.bombstory.com --dns dns-01
四、解析DNS五、再次执行命令，这次执行后面要加--renew参数
root@david-test:~/.acme.sh# acme.sh --issue -d bombstory.com -d *.bombstory.com --dns dns-01 --renew
六、其中，需要用到的文件有两个：
一个key：/root/.acme.sh/bombstory.com/bombstory.com.key
一个证书：/root/.acme.sh/bombstory.com/fullchain.cer
每天记录自己的
bigapples:aHR0cHM6Ly9hcGkuMTY3ODIxLmNvbSxodHRwczovL2FwaS44OGx4dW8uY29tLGh0dHBzOi8vYXBpLnFxb3Fxby5jb20=
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4242a520d4951732444df981138da33/" rel="bookmark">
			多元函数偏导数连续、存在与可微的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 偏导数连续、可微、偏导数存在三者之间的关系概念回顾多元函数求极限多元函数连续偏导数可微可微的充分条件（定义式）可微的必要条件（偏导数存在） 例题 偏导数连续、可微、偏导数存在三者之间的关系 注意，以上关系图中均为单向箭头，即全是必要条件（若 p &lt; = q ( p ≠ &gt; q ) p&lt;=q(p≠&gt;q) p&lt;=q(p=&gt;q)，则p是q的必要（不充分）条件，如p为矩阵A,B的秩相等，q为A~B（A相似于B），仅能有q推出p，而不能由p推出q，即p存在不一定能推q，但q存在一定能推出p）;
其中偏导数连续是最强条件，可以推可微，可以推偏导数存在，可以推连续（连续必然极限存在）;
概念回顾 多元函数求极限 除洛必达法则、单调有界准则不能照搬使用外，其他求极限的方法同一元函数求极限的一致。
多元函数求极限的具体例题、系统方法可参考：零蛋大——多元函数求极限方法总结
多元函数连续 即函数 f ( x , y ) 在 ( x 0 , y 0 ) f(x,y)在(x_0,y_0) f(x,y)在(x0​,y0​)上的极限值等于 f ( x 0 , y 0 ) f(x_0,y_0) f(x0​,y0​)
偏导数 可微 可微的充分条件（定义式） 可微的必要条件（偏导数存在） 若函数在某点(x,y)处的偏导数不存在，则一定不可微，即偏导数存在不一定能可微，但偏导数不存在一定不可微！
例题 2012 数学一真题：
选项A. 若 f ( x , y ) f(x,y) f(x,y)就取分母 ∣ x ∣ + ∣ y ∣ |x|+|y| ∣x∣+∣y∣，显然满足极限存在，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4242a520d4951732444df981138da33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee8bc01f09a9e1dae5dba0df989ec0b1/" rel="bookmark">
			$.ajaxPrefilter的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //注意：每次调用$.get() 或 $.post() 或 $.ajax()的时候 //会首先执行ajaxPrefiter 这个函数 //这个函数中，可以拿到我们给Ajax提供的配置对象 $.ajaxPrefilter(function(option){ // console.log(option,"请求到的结果") option.url=baseUrl+option.url; // console.log(option.url,"拼接的路径") //只针对用户信息设置权限 if(option.url.indexOf('/my')!==-1){ //统一为有权限的接口，设置headers请求头 option.headers={ Authorization:localStorage.getItem('token') || '' }; } // 全局统一挂载complete回调函数 option.complete=function(res){ // console.log(res,'complete') if(res.responseJSON.status==403){ //强制清空 localStorage.removeItem('token'); //强制跳转到登录页 location.href='/login.html' } } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18a39b0e9a047acaaf4b9b351d91d747/" rel="bookmark">
			ps2021神经网络滤镜不可用,ps神经网络滤镜用不了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		adobe 神经滤镜错误怎么办? adobe神经滤镜错误是因为adobe盗版不支持神经滤镜操作。而且神经AI滤镜是需要上传云端，由Adobe官方服务器人工智能运算的。所以导致错误，只能下载正版才能解决。
而且AI神经网络滤镜需要在服务端运行，所以你要想使用这个功能需要先登录 Adobe ID才可以，而且要保证在联网状态下使用，这个滤镜是用云端计算来完成的。
神经网路滤镜功能介绍：Photoshop 加入了全新的神经网路滤镜工作区，包含了由人工智能支持的多款各具特色的滤镜。用户可以非破坏性的方式套用滤镜效果，在弹指间探索创意。
这一艺术滤镜库将会不断丰富及改进，用户可在项目进行期间尝试多种以往需要花费很长时间才能实现的创意，并在应用神经网路滤镜的基础上充分利用Photoshop 的强大功能进行最后修饰。
谷歌人工智能写作项目：神经网络伪原创
ps2021神经AI滤镜运行错误？ PS 2021 版本的AI神经网络滤镜需要在服务端运行,所以你要想使用这个功能需要先登陆 Adobe ...退出登录是灰色的，你直接点击一下，看是否可以操作写作猫。
如果没有响应的话，那就是卡顿了，返回或者是复位重新操作一下。苹果退出登录是灰色的是由于手机开启了账户更改的限制，用户前往设置允许更改账号即可。
打开手机，点击【设置】按键；2/8进入设置，点击【屏幕使用时间】；3/8进入屏幕使用时间，点击【内容和隐私访问限制】；4/8进入【内容和隐私访问限制】；5/8向上滑动手机屏幕，点击【账户更改】；6/8进入账户更改，将【允许】更改为【不允许】；7/8返回账号管理，可以看见Apple ID变成灰色，完成；8/8以上就是【iPhone苹果手机怎么设置ID退出登录灰色】的步骤。
因为将账户更改设置成了不允许造成的，操作方法如下：1、首先打开苹果手机，点击【设置】按键，如下图所示。2、进入设置，点击【屏幕使用时间】，如下图所示。
3、进入屏幕使用时间，点击【内容和隐私访问限制】，如下图所示。4、进入【内容和隐私访问限制】，向上滑动手机屏幕，点击【账户更改】。5、进入账户更改，将【允许】更改为【不允许】，如下图所示。
6、这时返回ID页面中，可以看见Apple ID变成灰色，如下图所。
ps滤镜库怎么不能用 ps滤镜库不能用的原因：1、操作图层隐藏或锁定。2、图像模式是16位或32位或者是cmyk，导致部分滤镜不能用。3、滤镜被误删。4、所安装的版本是简化版。
AdobePhotoshop，简称“PS”，是由AdobeSystems开发和发行的图像处理软件。Photoshop主要处理以像素所构成的数字图像。
使用其众多的编修与绘图工具，可以有效地进行图片编辑工作。ps有很多功能，在图像、图形、文字、视频、出版等各方面都有涉及。
2003年，AdobePhotoshop8被更名为AdobePhotoshopCS。
2013年7月，Adobe公司推出了新版本的PhotoshopCC，自此，PhotoshopCS6作为AdobeCS系列的最后一个版本被新的CC系列取代。
截止2019年1月AdobePhotoshopCC2019为市场最新版本。
Adobe支持Windows操作系统、Android与MacOS，但Linux操作系统用户可以通过使用Wine来运行Photoshop。
ps滤镜中Cameraraw滤镜打开时出现“不能完成命令，因为程序错误”对话框这是怎么回事怎么解决 ps滤镜中Cameraraw滤镜打开时出现“不能完成命令，因为程序错误”，这是因为ps软件中的滤镜组件丢失导致的，需要通过重新安装ps软件的方式来解决问题，具体的操作步骤如下：1、首先在电脑上找到ps的安装包目录，然后点击启动其中的安装程序：2、然后会弹出一个新的窗口，直接点击忽略：3、然后ps的安装程序就会开始初始化了：4、初始化结束之后就会自动安装：5、安装完成之后ps就可以正常使用而不会出现无法使用ps滤镜的问题了：
我的Ps滤镜怎么突然不能用了？ 有几种可能：1.半年之中系统中毒，影响了处理速度（这种可能较大）------可以用卡巴斯基或金山毒霸查杀或重做系统;2.半年内在使用计算机的过程中产生大量系统垃圾，影响系统性能-----可以点“开始--程序--复件--系统工具--磁盘清理”3.电脑中有恶意软件占用大量内存------可以在桌面下边的任务栏右键--任务管理器，找到占用CPU较大的程序将其终止，然后卸载（可以用360）4.PS本身问题，如果以上几种都没问题，那你可以在PS菜单栏中点“编辑--首选项--内存与图像高速缓存”，把里面的数值设的大一些（按你说的半年没用PS了，这种可能小一些）最快的解决方法，就是重做系统和重安PS，并且百分百有效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c5eeb9ebb757e60a7ec994e074004b4/" rel="bookmark">
			字符串去除重复的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一：利用双层遍历做判断是否重复，如果重复就删除重复的
//将重复的删掉 var str='adsdsxsasdfdsgfedgfdgfd' //转数组 var arr=str.split('') for(var i=0;i&lt;arr.length-1;i++){ //arr[i]要跟它后面的每一个字符都2做比较 for(var b=i+1;b&lt;arr.length;b++){ if(arr[i]==arr[b]){ //如果重复就删除这个重复的 arr.splice(b,1) b-- } }} var str1=arr.join('') console.log(str1) 方法二：利用indexOf判断字符串是否存在，如果不存在就添加到新字符串中
var str='sdfsfdsfdsfdgfdgfhgfhgfhgtjytjwwerwe' //将不重复的字符放在新的字符串中 var str1='' //遍历str -判断每个字符串是否在str1中 for(var i=0;i&lt;str.length;i++){ //str[i]代表str中每一个字符 //str1中是否存在str[i] //利用indexOf判断 var index=str1.indexOf(str[i]) if(index&lt;0){ //小余零表示不存在，就可以把这个字符串拼接在str1中 str1 +=str[i] }} console.log(str1) 方法三：借助对象的键唯一性，把每个字符串追加到对象中因为对象的键唯一所以里面都是不重复的
var str='sdfsfdsfdsfdgfdgfhgfhgfhgtjytjwwerwe' //创建空对象接收 var obj={} for(var i=0;i&lt;str.length;i++){ obj[str[i]]=0 } //创建空字符串拼接 var str1='' //遍历对象 for(var key in obj){ //将obj中的键拼接在新字符串中 str1+=key } console.log(str1) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed626dc6afcd3f75dbcab709a34130c3/" rel="bookmark">
			SpringCloudAlibaba基础实战（Dubbo&#43;Nacos 服务注册与发现篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 在云原生时代，微服务、容器技术、DevOps，持续交付是四大元素。而对于开发人员微服务的掌握是重中之重。Java中SpringBoot凭借优秀的特性为构造Java应用带来了极大便利。因此，微服务构建是SpringCloud利用其生态，很好地建立起来SpringCloud系列的架构解决方案。而SpringCloud Netfflix由于停更，SpringCloudAlibaba凭借对第一代的兼容性以及极好的功能拓展、便利性提升，而占据了Java微服务较大市场。微服务的整个架构和SpringCloudAlibaba生态如下，而本文将进行一些简单Demo的实战记录，相关代码放在个人github。
二、服务注册&amp;发现 我们都知道微服务将应用的粒度划分很小，便于协作开发和故障迁移。那么粒度变小之后，必然服务的数量上来了，而且服务间也存在着一定关系，需要去调用，此刻微服务一般还部署在不同机器之上，因此不能像本地调用那样去调用，而需要通过网络通信方式去调用。因此复杂度瞬间上来，我们主要就需要去考虑以下复杂度：
服务调用与治理（如何保证复用的可用？对于大规模的服务如何治理、跟踪？服务的通信如何高效，通信带来的系列问题（如超时，一个服务调用失败导致其他服务雪崩式失败服务本身的健康状态（当服务本身不可用时如何处理？ 对于上面的系列问题，我定义为 多 的问题，相比 单体（少），我们无需协作管理，而对于 多，就犹如 人群 形成 了社会，此时我们则需要进行管理，而对于多的管理在计算机中有很多体现，例如：
进程\线程的多，带来了进程管理，高并发的协作问题文件\数据的多，带来了文件管理，数据库系统人\用户的多，带来了业务的管理，软件的管理（软件的复杂，来源于需求业务的复杂，人的需求） 所以说，解决该问题，我们也可如法炮制，采用中心机构进行管理。而微服务具体的管理方式，则是通过服务注册中心进行统一管理。有了统一的注册列表和各服务的信息，那么想去调用其他服务，检查服务状态等就更加容易，而对于常用的服务调用则是采用 REST Http通信和 RPC远程调用两种主要方式。
REST ：采用HTTP轻量级调用方式，十分方便，快捷，但是相对于RPC方式一般速度较慢，性能较差。RPC：远程调用，Java一般采用Netty通信框架，高性能的NIO底层，通信速度较快，性能较好。 对于SpringCloudAlibaba，RPC调用框架，Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。更多特性可以参考官网
对于SpringCloudAlibaba，服务注册与发现、配置中心，nacos具有很强的表现，随着2.0版本 gRpc的引入，通信性能极强，支撑百万实例。Nacos 支持几乎所有主流类型的“服务”的发现、配置和管理：
Kubernetes ServicegRPC &amp; Dubbo RPC ServiceSpring Cloud RESTful Service Dubbo+Nacos简单实战Demo 基本依赖 &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 结构目录 具体过程 在cloud-demo-discovery-dubbo-api模块中定义统一接口
创建cloud-demo-discovery-dubbo-provier 引入依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;cloud-demo-discovery-dubbo-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed626dc6afcd3f75dbcab709a34130c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b543a6a3f2d3dc1aef1543c6fbe444d/" rel="bookmark">
			算法设计与分析——背包问题（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题】给定n个物品和一个容量为C的背包，物品的重量是，其价值为，背包问题(Knapsack problem)是如何选择装入背包的物品，使得装入背包中物品的总价值最大。注意和0/1背包问题的区别，在背包问题中，可以将某种物品的一部分装入背包中，但不可以重复装入。
【想法】用贪心法求解背包问题的关键是如何选定贪心策略，使得按照一定的顺序选择每个物品，并尽可能的装入背包，直到背包装满。至少有三种看似合理的贪心策略：
（1）选择价值最大的物品，因为这可以尽可能地增加背包总价值。但是，虽然每一步选择获得了背包价值的极大增长，但背包容量却可能消耗得太快，使得装入背包的物品个数减少，从而不能保证目标函数达到最大。
（2）选择重量最轻的物品，因为这可以装入尽可能多的物品，从而增加背包的总价值。但是，虽然每一步选择使背包的容量消耗得太慢了，但背包的价值却没能保证迅速增长，从而不能保证目标函数达到最大值。
（3）以上两种贪心策略或者只考虑背包价值的增长，或者只考虑背包容量的消耗，而为了求得背包问题的最优解，需要在背包价值增长和背包容量消耗二者之间寻找平衡。正确的贪心策略是选择单位重量价值最大的物品。
【算法】设背包容量为C，共有 n 个物品，物品重量存放在数组 w [ n ] 中，价值存政仕组 v [ n ]中，问题的解存放在数组x[n]中，贪心法求解背包问题的算法如下。
输人：背包容量 C ，物品重量 w [ n ]，物品价值 v [ n ]
输出：数组 x [ n ] 1.改变数组w和v的排列顺序，使其按单位重量价值 v [ i ] / w [ i ] 降序排列；
2.将数组 x [ n ] 初始化为 O；
3.i = 0；
4.循环直到 ( w [ i ] &gt; C )
4.1 将第个物品放人背包： x [ i ] = 1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b543a6a3f2d3dc1aef1543c6fbe444d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f70690082646ddf32edc6323e31f9d2d/" rel="bookmark">
			软工第三周作业-猫狗大战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.原有代码 1.1导入相关的包 1.2数据标准化 1.3加载训练集和测试集 1.4创建VGG模型 1.5训练模型（训练集） ''' 第一步：创建损失函数和优化器 ​ 损失函数 NLLLoss() 的 输入 是一个对数概率向量和一个目标标签. 它不会为我们计算对数概率，适合最后一层是log_softmax()的网络. ''' criterion = nn.NLLLoss() ​ # 学习率 ​ lr = 0.001 ​ # 随机梯度下降 ​ optimizer_vgg = torch.optim.SGD(model_vgg_new.classifier[6].parameters(),lr = lr) ​ ''' 第二步：训练模型 ''' ​ def train_model(model,dataloader,size,epochs=1,optimizer=None): model.train() for epoch in range(epochs): running_loss = 0.0 running_corrects = 0 count = 0 for inputs,classes in dataloader: inputs = inputs.to(device) classes = classes.to(device) outputs = model(inputs) loss = criterion(outputs,classes) optimizer = optimizer optimizer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f70690082646ddf32edc6323e31f9d2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbbb62f2577afa8dfdcd7d8ae8451900/" rel="bookmark">
			安卓8.0&#43;图标适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安卓8.0起对通知图标、桌面图标都有了要求。若不符合要求就会出现奇怪的问题。
一、图标问题 如下是UI给的一组图：
把这组图放到安卓对应的资源目录后跑了一下发现不同手机上表现效果是不同的。
google的 pixel2 手机模拟器上（android 8.0）
vivo z1 （android 9.0）
红米 note6（android 8.0）
发现问题：
google的pixel2 上图标适配有问题安卓9.0上图标显示有问题 二、图标问题解决 1、显示默认安卓图标的解决方案 先看看安卓的mipmap目录：
其他的目录我们都知道了，那么这个v26 是啥呢？
其实Android 8.0或以上系统的手机，都会使用这个目录下的ic_launcher来作为图标。
知道为啥我们9.0手机为啥显示默认图片了吧，即你指定设置了app的图标。
解决方案
方案1直接删除v26文件夹，这样自己指定的就生效（简单粗暴）方案2适配一套v26的xxx.xml资源（参考下文图标适配方案） 2、图标适配 安卓8.0以后google规定了app图标组成
前景foreground，如上图中的白色安卓机器人。背景background，需要我们自己提供。如上图中的蓝色网格背景。mask，手机厂商提供。如上图中的透明覆盖物即为面具，不同厂商面具可能不同，有圆的，方的等等。 所以我们只需要提供前景背景即可，这里 Android Studio 提供了image Assets，mac 双击shift 搜索即可：
如下图：
红色标记1可为文件命名红色标记2这里可为对应图层命名（这里为 foreground layer 命名）红色标记3这里可选择要操作的本地图片
如上图从桌面选择一张图片，前景就是这张图片，然后设置Background 为白色： 点击finish
生成结果
这时我们设置为生成的my_icon就行了
结果：
可见“图标适配方案”也能解决默认图标显示问题，因为图标适配方案在v26中也会生成对应的xml
三 、通知栏Small Icon 不适配问题 最近在开发中碰到一个问题，公司领导反馈 国外的同事pixel 6 pro 上通知的small icon 显示有问题：显示为小白块、显示不出来，真是奇怪了？然后让测试同事帮忙在看了遍，手头上的测试机，三星、小米，一加等都没问题。最终自己在模拟器上复现了。
如上图：
红色框框框住的为修改后的正常通知icon蓝色框框框住的为非正常通知icon 原因是啥呢？这个可能Framework的同学们好探究一些，我也是通过一些文章找到的：
setSmallIcon api对图片有要求。google原生的手机通过setSmallIcon()方法设置的图片背景必须是透明的，所有不透明的点最终都会显示为白色。
国内手机基本都是通过底层修改过的，通过setSmallIcon()设置的图片没有任何显示，而且也是彩色的。所以暂时不修改此问题，因为像Pixel等的原生手机毕竟不多。
其实有一个地方可以验证，还记得上面的 “Image Assets” 工具吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbbb62f2577afa8dfdcd7d8ae8451900/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2306258e6eaec91221f72191034d7dfe/" rel="bookmark">
			数据结构代码块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 栈-[应用]（定义栈，初始化栈，判空，入栈，出栈）1.1 顺序栈1.2 链栈（单链，栈顶在链头） 2 队列-[应用]（定义，出队，入队，判空，判满）2.1 顺序存储队列2.2队列的链式存储结构 3 数组-[算法]3.1快速排序3.2 归并排序3.3排序拓展3.4 折半查找 1 栈-[应用]（定义栈，初始化栈，判空，入栈，出栈） 1.1 顺序栈 栈的顺序存储类型
#define MaxSize 50 typedef struct{ Elemtype data[MaxSize]; int top;//栈顶指针 }SqStack； 初始化栈
void InitStack(SqStack &amp;S){ S.top=-1; } 判断栈是否为空
bool StackEmpty(SqStack S){ if(S.top==-1) return true; else return false; } 入栈
bool Push(SqStack &amp;S,ElemType x){ if(S.top==MaxSize-1) return false; S.data[++S.top]=x; return true; } 出栈
bool Pop(SqStack &amp;S,ElemType &amp;x){ if(S.top==-1) return false; x=S.data[S.top--]; return true; } 读栈顶元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2306258e6eaec91221f72191034d7dfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c54f243ba2122c51ca5f40c32e38bd50/" rel="bookmark">
			Spring中常用的注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.注入类：
@Component：可注入任意类的注解；
@Controller：注入控制层Bean的注解；
@Service：注入业务层Bean的注解；
@Respority：注入数据访问层Bean的注解；
2.注入数据：
@Value：可以（动态）注入数据；
@Autowire：按照类型自动装配；
3.其他注解：
@Bean：标注方法上，表示该方法的返回值是Bean，并将其注入容器；
@ComponentScan：扫描添加注解的类并将其注入容器；
@Configuration：代表该类是配置类；
@Import：代表在配置类中导入其他配置类的内容；
@Transactional：可标注在泪上或者方法上，表示当前类的（所有）方法具有事物管理的功能；
@Primary：首选项（修饰类）；
@Qualifier：与@Autowired配合使用，
按照名称来装配；
@Resource：按照名称自动装配；
@Scope：作用域（修饰类）
属性- singleton（单例）
prototype（多例）
request（请求）
session（会话）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a7d7bb8cd609aea1223c555af8e1db5/" rel="bookmark">
			kali linux2022.3 win11双系统安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.系统盘制作 ★★★★★咱win11起手，kali起手包另外），准备一只U盘（最好是空的），不空的话去格式化一下
★★★★★格式化完毕后开始烧录系统盘，可以用上面那个Rufus,或者包包（包包放在后面了）里的balenaecher(linux,win都行)，usbwriter,都差不多，但是不一定哪个能用，本人用的balenaecher，第一个选镜像（kali官网有2022.3的包）★★★★★
★★★★★第二个选U盘，然后点第三个开刷，一会就finish了，关闭软件，弹出U盘★★★★★
第一步完成 ★★★★★然后留出一些空间来装kali，如果不缺空间直接新硬盘装就ok★★★★★
★★★★★然后准备工作完成，插U盘重启，进BIOS改顺序★★★★★
★★★★★把那个USB放到第一位★★★★★ ★★★★★把secure boot 改成disable★★★★★
★★★★★esc 退出保存★★★★★ ★★★★★选第一个，咱要图形化 ★★★★★
★★★★★选语言，选中文（略）★★★★★
★★★★★选否（这里我下过固件，但是识别不了）而且网上没有完整的这些，有几个是没找到的，也没准是只有我没找到，先过★★★★★
★★★★★联网，然后配置完地址★★★★★
★★★★★下一步下一步，下面哪个是用户名密码，根据自己需要来★★★★★ ★★★★★下面是核心内容，如果你有空硬盘就跟我这个走★★★★★
★★★★★选整个硬盘★★★★★
★★★★★选你要装的空硬盘（不是U盘），不要选错，后果就是G★★★★★ ★★★★★第一个即可 ★★★★★
★★★★★然后就敲回车，完成分区写入磁盘 ★★★★★
如果有人喜欢手动分盘，那就1G分区/boot，2G swap，剩下主分区就行
★★★★★三选一看你喜欢哪个界面 我选的gnome★★★★★
★★★★★ 漫长等待后stop，stop，stop★★★★★ 我知道你看到下图界面很急，迫不及待点继续，但是你先别急，先把启动U盘拔出来，等待五秒左右，再点继续
然后开机，密码登录
OK，进入系统
镜像以及烧录软件放在下面的盘里，go
链接: https://pan.baidu.com/s/1I_d0KhtNn-2JF5LZK1QOxA 提取码: 6666
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b92c0cccfbae43ed95fa6ce5186972e8/" rel="bookmark">
			C中printf()的常用输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、输出整数：%d
int a = 10; printf("%d\n",a); 2、输出无符号数：%u
unsigned int b = 25; printf("%u\n",b); 3、输出十六进制数：%x
int hex = 0x25; printf("%x\n",hex); 4、输出指针指向的地址：%p
int a = 0x12345678; int *p = &amp;a; printf("%p\n",p); 5、输出字符串：%s
//char str[] = "abcde"; char *str = "abcde"; printf("%s\n",str); 6、输出单个字符：%c
char c = '1'; printf("%c\n",c); 7、输出二进制格式
void print_bin(int number){ int bit = sizeof(int)*8; int i; for(i = bit - 1;i &gt;= 0;i--){ int bin = (number &amp; (1 &lt;&lt; i)) &gt;&gt; i; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b92c0cccfbae43ed95fa6ce5186972e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02206f2ac64b5fc79ba503def69ce59d/" rel="bookmark">
			ES索引优化方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定期Forcemerge 由于单个分片的开销取决于segment数量和segment大小,segment个数越多，单个shard内的搜索将会消耗更多的时间和内存，通过对索引进行forcemerge将shard里面的多个较小的segment合并为segment，减少segment个数有效的提升查询性能，降低时延。同时段合并也能够清除已经被标记为删除的文档，减少空间。
操作语句为 POST /index_name/_forcemerge?max_num_segments=1 注意：forcemerge是一个极其耗费资源的操作，建议在业务量降低的时候进行。
段合并过程中会占用磁盘IO，影响检索性能，如果系统已经查询比较慢了，此时进行段合并会加剧问题。
另外，段合并不是一锤子买卖，如果索引还有持续的数据写入或者更新，shard内的segment也会继续的多起来，这个时候就要进行例行的段合并操作了，可以定时的在业务低峰期自动执行。
如果集群负载比较重，可以只处理含删除数据的segment，不合并segment
POST /index_name/_forcemerge?only_expunge_deletes=true 数据删除时，Lucene只做标记删除，不实际删除segment的数据，设置only_expunge_deletes为true时，ES会创建一个新的不含删除数据的segment替换当前含删除数据的segment。
segment 归并的过程，需要先读取 segment，归并计算，再写一遍 segment，最后还要保证刷到磁盘。可以说，这是一个非常消耗磁盘 IO 和 CPU 的任务。所以，ES 提供了对归并线程的限速机制，确保这个任务不会过分影响到其他任务。
链接: 官方说明
Forcemerge提速 在 5.0 之前，归并线程的限速配置 indices.store.throttle.max_bytes_per_sec 是 20MB。对于写入量较大，磁盘转速较高，甚至使用 SSD 盘的服务器来说，这个限速是明显过低的。对于 Elastic Stack 应用，社区广泛的建议是可以适当调大到 100MB或者更高。
PUT /_cluster/settings { ""persistent"" : { ""indices.store.throttle.max_bytes_per_sec"" : ""200mb"" } } 链接: 官方说明
索引拆分或重构shard 查询结果匹配命中的数据越多，性能越差，时延耗时越高。
索引拆分主要是要从业务方面入手，缩小搜索的数据范围，降低查询结果匹配命中的数据。比如对于大索引，通过业务层次划分，每个业务数据独立为一个索引。对于时序数据，可以通过按照时间进行索引拆分，每天一个索引，搜索的时候默认只搜索最近几天的数据。
重构shard的主要目的是为了解决shard个数过多影响查询的场景，这种方案适合数据量小，基本没有写入的场景，比如索引的数据量比较小10GB，之前设置了10个shard，10个节点，其实可以通过reindex，将索引的shard调整为1个，配置9个副本来达到更好地效果。"
索引字段尽量用keyword 能够用keyword替换的数值型字段（byte, short, integer, long, float, double, ip and date）尽量用keyword替换
keyword类型的term query，ES使用的是倒排索引。倒排索引在内存中维护了词典和文档列表（Posting list）的关系，倒排索引本身是想通过精确匹配从词典中找到term，然后找到词的posting list合并。
数值类型为了能有效的支持范围查询，它的存储结构并不是倒排索引。从lucene6开始。数值型的存储结构使用的是一种BKD tree的结构，类似于mysql中的B+索引结构，但是BKD是针对多维空间的。如果是BKD tree，精确匹配需要通过树的查找算法进行查询，然后文档结果集合进行排序再返回，相比倒排索引的词典树+posting list+跳表还是要差不少。树形数据结构对范围查找非常友好，如果业务上使用了数值型字段但是又不使用范围查找，可以使用keyword替代。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02206f2ac64b5fc79ba503def69ce59d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/821a858502b7b7265774fed9a195207d/" rel="bookmark">
			Ansible的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ansible的安装 服务器规划
主机IP服务server1（主控端）192.168.10.133Ansibleserver2192.168.10.134server3192.168.10.135 1、安装Ansible 因为Ansible是由Python开发，所以安装Ansible的方式也有很多种，例如yum安装、编译安装、pip安装、Git安装，我们使用yum直接安装。
（1）配置epel源 yum -y install epel-release （2）安装ansible yum -y install ansible （3）查看ansible版本 ansible --version [root@server1 ~]# ansible --version ansible 2.9.27 config file = /etc/ansible/ansible.cfg configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules'] ansible python module location = /usr/lib/python2.7/site-packages/ansible executable location = /usr/bin/ansible python version = 2.7.5 (default, Oct 14 2020, 14:45:30) [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)] # 可以发现使用ansible是需要python环境的。 # 如果使用其他方式安装，服务器内务必要有Python环境。 2、Ansible的配置文件 Ansible配置文件 /etc/ansible/hosts	主机清单 /etc/ansible/ansible.cfg 主配置文件 /etc/ansible/roles/	存放角色目录 （1）/etc/ansible/hosts文件详解 可以看到hosts文件大多都是被注释了的，文件内容是告诉用户如何使用hosts文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/821a858502b7b7265774fed9a195207d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f187399bf463bf4f2e54a9a9e4804f/" rel="bookmark">
			离线地图瓦片下载 高德地图 谷歌地图 天地图 Mapbox地图 矢量 卫星地图下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用于地图瓦片下载离线，支持 高德地图瓦片 谷歌地图 Mapbox bingMap OpenStreeMap 自定义瓦片地址 下载 gitee项目地址 https://gitee.com/houlaidelu/map-tiles-downloader_node
GitHub项目地址 https://github.com/holai/MapTilesDownloader_Node
使用教程 npm installnode index.js打开 http://localhost:9100/index.html保存路径默认在项目目录 out/当前时间戳/ 下 截图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc14525373f49df38ef6c76e191aaafa/" rel="bookmark">
			制作安卓App首页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		## **一、实验目标**
做一个APP首页，包括顶部图片、顶部菜单栏、中部消息模块、底部Tab按钮。学习 ScrollView, RelativeLayout，以及插件之间的穿插使用。
## 二、实验步骤
### 1.创建父布局，新建ScrollView,新建ScrollView内部父布局
### 2.创建顶部首页显示栏，设置宽高、位置，字体大小、样式等
### 3.创建顶部图片，设置宽高，src加载图片，设置边距
### 4.菜单栏模块，最外层用线性布局，内层使用四个相对布局，使用权重weight属性使四个控件比例相同，平分空间
### 5.消息模块，创建相对布局为父布局，使用两个TextView控件
### 6.底部Tab模块，与菜单栏模块类似，以线性布局为父布局，内层使用4个相对布局，使用权重weight属性使四个控件比例相同，平分空间，相对布局内利用id属性控制文字控件在图片控件下方
## 三、程序运行结果
程序运行成功，最终截图如下：
## 四、问题总结与体会
- 问题及解决方式：最初菜单栏模块4个控件超出了屏幕范围，后来发现是对于`android:layout_weight="1"`，我给四个控件分别赋了1、2、3、4，显然这是不对的，这还是对于权重属性不够理解的问题。
- 收获与体会：本次实验熟悉了相对布局和ScrollView的使用，了解了id属性和weight属性的使用方式，能更加熟练地运用Android Studio来编写app前端。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba272619f35fa0c36206cfc9932d86f2/" rel="bookmark">
			图论 ——五种最短路算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、最短路是什么？二、朴素Dijkstra算法三、堆优化版Dijkstra算法四、Bellman-Ford算法五、Spfa算法六、Floyd算法总结 前言 本篇文章讲的是图论里的最短路问题，如果你还没有图论的基础知识，可以看看我之前的文章：
DFS（深度优先算法） BFS(广度优先算法）邻接表和邻接矩阵、树的遍历 （DFS和BFS）
这些都是关于图论的基本知识。
一、最短路是什么？ 最短路径： 从某个点A（位置）到另一个点B(位置)的最短距离，实现方法：点A途中可以经过很多个点C，然后通过不断更新点A到途中点 C 的最短距离，最后实现最短距离到达 点B。
A -&gt; C1 -&gt; C2 -&gt; C3 -&gt; B
最短路径的分类：
单源最短路：图中的一个点到其余各点的最短路径
多源最短路：图中每两个点的最短路径
框架图解：（如果看不清的话，放大浏览器再观看）
图中稠密图用邻接矩阵，稀疏图用邻接表，具体了解：
邻接表和邻接矩阵、树的遍历 （DFS和BFS）
二、朴素Dijkstra算法 Dijkstra算法（迪杰斯拉算法）：该算法的特点是从起始点开始，采用贪心算法的策略，采用加点的的方式，每次遍历到起始点距离最近且从未被访问过的顶点的邻接节点t，将该点t加入集合S中，直到扩展到终点位置。
时间复杂度：O（n ^ 2）
思想（操作）：
将图上的点分为两个集合：分别是S集合和N集合 S：表示访问过的点（用st数组存储）N：表示未访问过的点将N集合中的点按到S集合距离最短依次加入到S集合中用刚到S集合中的点t去更新集合N到起始点的距离（这一步也就是松弛操作） 图解：
步骤： dist[ ]：每个点到起始点的距离 st[ ]：是否加入到了s集合中
初始化距离：把每个点都初始化为0x3f3f3f3f（无穷大）进行n层循环：遍历dist数组，找到一个不在S集合中并距离S集合最短的点t，每一层循环都将找到的点t将它放入S集合中（st[t] = true）用找到的点t去更新N集合到起始点的距离（松弛操作） 代码 + 注释：
const int N = 1e5 + 10;//多少个点 int dist[N]; //每个点到起始点的距离 bool st[N]; //S集合 void dijkstra(){ memset(dist, 0x3f3f3f3f, sizeof dist);//初始化距离 dist[1] = 0; for(int i = 1; i &lt;= n; i ++){ //进行n次循环 int t = -1; //设找到的点初始化为1 for(int j = 1; j &lt;= n; j ++){ if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba272619f35fa0c36206cfc9932d86f2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/219/">«</a>
	<span class="pagination__item pagination__item--current">220/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/221/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>