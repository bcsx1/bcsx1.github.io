<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d98ed7971bd94863fc5e68949532556/" rel="bookmark">
			狂暴版——豌豆荚信息获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.webdriver.common.by import By import time def get_good(driver,number): try: time.sleep(5) js_code = ''' window.scrollTo(0,5000) ''' driver.execute_script(js_code) time.sleep(5) good_list = driver.find_elements_by_class_name('card') for good in good_list: good_name = good.find_element_by_class_name('app-title-h2').text good_url = good.find_element_by_css_selector('.app-title-h2 a').get_attribute('href') good_people_size = good.find_element_by_class_name('meta').text good_commit = good.find_element_by_class_name('comment').text good_content = f''' 序号:{number} 游戏名称：{good_name} 游戏链接：{good_url} 游戏下载人数_游戏大小：{good_people_size} 游戏评价: {good_commit} \n ''' print(good_content) with open('wandou1.text','a',encoding='utf-8') as f: f.write(good_content) number+=1 print("游戏信息写入成功！！") more_load=driver.find_element_by_class_name('load-more') more_load.click() time.sleep(2) get_good(driver,number) finally: driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d98ed7971bd94863fc5e68949532556/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f085004c0c436e9af609ba23facaea/" rel="bookmark">
			F2FS源码分析-1.1 [F2FS 元数据布局部分] F2FS文件系统的总体结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		F2FS源码分析系列文章 主目录 一、文件系统布局以及元数据结构 总体结构Superblock区域Checkpoint区域Segment Infomation Table区域(SIT)Node Address Table区域(NAT)Segment Summary Area区域(SSA) 二、文件数据的存储以及读写 三、文件与目录的创建以及删除(未完成) 四、垃圾回收机制 五、数据恢复机制 六、重要数据结构或者函数的分析 F2FS总体介绍 F2FS全称为Flash Friendly File System，是专门为flash设备设计的一个日志结构型文件系统(Log-structured File System, LFS)。相对于传统的日志结构型文件系统，F2FS在wandering tree和gc的高时间开销等问题，有一定的改进和优化。
wandering tree问题: 传统的LFS，在文件数据被更新或者写入到日志的末端的时候，指向文件数据保存地址的直接指针指针会被更新(flash设备的异地更新特性)，同时指向这个直接指针的间接指针也会更新，然后保存间接指针的inode、inode blockmap等结构也需要更新，这样就导致了频繁metadata的更新。这种问题称为wandering tree问题。
高gc开销问题: 由于LFS对于修改的数据是执行异地更新的特性，因此数据更新到一个新地址后，旧地址的回收和再利用的过程称为垃圾回收过程(GC)，这个过程会导致不可预期的高延迟，对于用户感知有很大影响。
F2FS系统特性 F2FS的基本数据单位 block: F2FS的数据存储的基本单位是block，大小为4KB，整个flash设备被格式化为多个block组成的结构。很多数据结构也被设计为4KB的大小，这是因为很多flash设备单次IO的读写都是基于4KB的倍数进行。segment: segment是管理block的结构，一个segment的大小是512个block，也就是2MB。section: 默认情况下一个segment等于一个section，section是GC的基本操作单位，每次GC都会从section中选出特定的segment进行回收。F2FS将section分为了6类，分别是hot-node，warm-node，cold-node，hot-data，warm-data，cold-data，hot-&gt;cold表示了数据的从高到低的修改频率，通过不同类型的section，进行gc的时候可针对使用hot的section进行gc，以降低gc的时间开销。zone: 默认情况一个zone等于一个section，与物理设备有关，大部分情况下用不上。 LFS异地更新特性 F2FS是一个Log-structured File System(LFS)，因此会使用异地更新策略。我们可以i用一个简单的例子去说明什么是异地更新。假设有一个文件，它的文件数据保存在物理地址100的位置中，此时用户对文件内容进行更新:
非LFS: 使用就地更新策略，将更新后的数据写入到物理地址100中。
LFS: 使用异地更新策略，首先会分配一个新的物理地址101，然后将数据写入新物理地址101中，接着将文件指针指向新的物理地址101，最后将旧的物理地址100进行回收再利用。
这种设计的好处是:
可以将随机写转换为顺序写以获得更好的性能提升;flash的颗粒program寿命是有限的，通过LFS的异地更新特性，可以自带磨损均衡。 但是LFS也有一些缺点，一个最明显的缺点是F2FS要对旧的物理地址进行回收，这个过程称为垃圾回收过程(GC)，不适当的GC时机会影响到系统的性能表现；另外一个缺点是LFS极端情况的安全性不像JFS(journal file system)那么好，因为LFS依赖Checkpoint保证一致性，但是Checkpoint不是每次写入数据都会进行(带来很大的开销)，而是隔一段时间才会进行一次Checkpoint，因此可能在Checkpoint之前系统宕机，会带来部分数据的丢失。
Multi-head Logging特性 Log区域指的是文件系统中用于分配free block(空闲的且没有写入数据的block)的区域，例如F2FS的一个文件需要写入新数据，它就要去Log区域请求free block，然后再将数据写入这个free block中。传统的LFS往往会维护一个大的日志区域，一切数据的分配都从这个大的日志区域中进行处理，而F2FS则根据数据的访问冷热特性差异，维护了6个Log区域，分别是:
HOT NODE区域：给目录的direct node使用，因为打开目录、读取目录是最频繁的操作。WARM NODE区域：给普通文件的direct node使用COLD NODE区域：给indirect node使用，一般而言只有较大的文件才会使用到这个log区域。HOT DATA区域：给目录的数据使用，目录数据记录了当前目录有多少个子文件、子文件夹。WARM DATA区域：给普通文件的数据使用，常规的fwrite/write函数写入的数据都是在这里分配。COLD DATA区域：给不频繁修改的数据使用，如多媒体文件(多为只读文件)，或者用户指定的只读文件，如GC产生写的数据(gc会挑热度最低的数据)。 注: direct node、indirect node的概念和作用会在第二章的第一节进行介绍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f085004c0c436e9af609ba23facaea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74027be612d8b54d0ddf83dbec4deffc/" rel="bookmark">
			在vue.js中mixin和页面执行顺序问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打个总结： 1. 对于creaetd，mounted 等生命周期函数 mixin中的代码先执行，单文件中的后执行。
2. 对于同名的变量和方法，只执行page中的代码。 示例如下：
1.两边同名的变量，获取后取得的是Page那边的值。
2.两边同时定义test()方法，只执行了page这边的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa2603d37c5cb4b4fc67720e42f3636/" rel="bookmark">
			小程序传统开发模式和云开发模式的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、小程序传统开发模式：
二、小程序云开发模式：
三、传统小程序开发与小程序云开发比较：
四、云开发三大基础能力支持：
五、小程序传统开发与云开发登录比较：
传统开发：
云开发：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d11195cba9985a6572a41c4acf6edb33/" rel="bookmark">
			面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python基础面试题 1.为什么学习Python？ Python是目前市面上，我个人认为是最简洁、最优雅、最有前途、最全能的编程语言，没有之一。 2.通过什么途径学习的Python？ 3.Python和Java、PHP、C、C#、C++等其他语言的对比？ Python：轻量级、易学、自由/开放源码软件、可移植性、支持面向对象、丰富的库、规范的代码。 Java：优点：开源性，功能强大，库多 缺点：编译速度 比较慢，不完全 PHP：优点：性能很强，配合简单，稳定，容易部署。 缺点：函数命名不规范，驼峰法和下划线，传参位置不一。 C： 优点：能操纵底层，能细粒度优化性能。 缺点：1、是面向过程的，2、运行时类型检查不可用，3、不提供命名空间功能，4、构 造函数和析构函数不可用。 C#： 优点： 强大的.NET Framework托管代码集合类，较简单的语言特性。WEB应用程序 开发速度快。 缺点：底层和高性能不合适，Windows平台以外支持有限。 C++: 优点：性能比较高，可进化型。 缺点： 难学，门槛高 4.简述解释型和编译型编程语言？ 解释型 在运行时才翻译 每个语句执行时候才翻译 效率比较低 跨平台性好 （python） 编译型 程序执行之前有一个专门的编译过程 把程序编译成机器语言的文件 程序执行效率高 跨平台性差 （c c++） 5.Python解释器种类以及特点？ CPython c语言开发的 使用最广的解释器 IPython 基于cpython之上的一个交互式计时器 交互方式增强 功能和cpython一样 PyPy 目标是执行效率 采用JIT技术 对python代码进行动态编译，提高执行效率 JPython 运行在Java上的解释器 直接把python代码编译成Java字节码执行 IronPython 运行在微软 .NET 平台上的解释器，把python编译成. NET 的字节码 6.位和字节的关系？ 8位（bit）=1字节（Byte）,1024字节=1KB； 7.b、B、KB、MB、GB 的关系？ 1TB = 1024GB 1GB = 1024MB 1MB = 1024B（字节） 1字节 = 1个英文字母或1个数字或一个字符 2字节 = 1个中文汉字 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d11195cba9985a6572a41c4acf6edb33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fe46eda268721b04ae90c5794130305/" rel="bookmark">
			Android下使用dlopen函数动态调用.so链接库 [转]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：http://hi.baidu.com/mcu99/blog/item/389a6fde38f69950cdbf1a75.html
在这篇文章（【09.03.25】Linux环境中dlopen函数的简单应用）中。实现了在UBUNTU LINUX环境下使用dlopen函数动态调用.so链接库。但是也提到了在Android下未能成功。由于Android也是使用linux内核，因此估计程序本身可能并没有什么错误，问题应该是出现在Android.mk文件中。今天早上试着修改了一下Android.mk，终于将这个问题解决了。
好在两个C程序和一个.mk文件并不是太长，现将它们贴一遍
/*************************** dl1.c *******************************/
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;dlfcn.h&gt;
int main()
{
int a,b;
void *p;
int (*func)(int,int);
scanf("%d%d",&amp;a,&amp;b);
p=dlopen("./dl2.so",RTLD_NOW);
if(p==NULL)
{
printf("dlopen error!\n");
exit(0);
}
else
printf("dlopen ok!\n");
func=dlsym(p,"max");
printf("%d与%d相比，%d为大数。\n",a,b,(*func)(a,b));
dlclose(p);
}
/*************************** dl1.c *******************************/
/*************************** dl2.c *******************************/
#include&lt;stdio.h&gt;
int max(int x,int y)
{
return x&gt;y?x:y;
}
/*************************** dl2.c *******************************/
/*************************** Android.mk *******************************/
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_SRC_FILES:= \
dl2.c
LOCAL_PRELINK_MODULE := true
#LOCAL_CFLAGS=-fPIC
LOCAL_MODULE:= dl2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fe46eda268721b04ae90c5794130305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c807afe02e7d33875309eb8c9a6ad9e/" rel="bookmark">
			Nginx如何配置根据cookie或header自定义字段进行跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做这个之前是我遇到的一个问题
，百度搜索了大量文章都是断断续续，没有完整的思路或者是讲解，以下是我如何解决的：
一、根据cookie中的值来判断跳转
$http_cookie这个关键词是读取cookie的全部信息，那么我们是需要判断cookie中包含的某个字段的值，比如我设置openid=5,我该如何获取那么，我们可以通过$cookie_openid，其中openid是你设置的，这里需要加前缀cookie就可以获取了。
在location中设置，注意此跳转支持post传输。
location / { #设置一个变量来接收跳转的地址 set $lodurl "http://xxx.xx.xx/xx"; #这里设置了默认地址 #注意if和（之间要又一个空格，否则无法执行，会出错 if ($cookie_openid = "5") { set $lodurl "http://www.www.com/xx";#需要跳转的地址 } proxy_pass $lodurl; #还有其他常用参数，可以根据自己的需要进行设置，这里就不一一说了 } 二、其实header和cookie设置是一样，只是获取字段的值不一样而已
如何获取hreader里字段的值，可以这样获取：$http_xx其中xx是你自定义的header的字段。那么如何在location中设置，可以参考一种得设置。
作者qq:403648571
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9e8fac38f61eb236de4e38a5e6a8aca/" rel="bookmark">
			bootstrapTable的父子配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.父子表
先上效果图，楼主写了一下午的文章有点累，没写完请谅解
集成配置还不会的请看作者的基础配置文章，这篇文章还在撰写
BootStrapTable的基础配置
上一篇文章的表格加载已经介绍了现在上子表代码
loadTable是加载表格的方法，在加载的时候设置子表
function loadTable(){ $("#selection-datatable123").bootstrapTable({ url : '/user/pageList', //请求后台的URL（*） method: 'POST', contentType:'application/x-www-form-urlencoded; charset=UTF-8',//post请求需设 sidePagination : "server", //分页方式：client客户端分页，server服务端分页（*） pagination : true, //是否显示分页（*） detailView: true, cache: false, clickToSelect: true,//点击行选中 queryParams :function (params) { return { pageSize: params.limit, pageIndex: params.offset / params.limit + 1 /*username: $userTableForm.find("input[name='username']").val().trim(), ssex: $userTableForm.find("select[name='ssex']").val(), status: $userTableForm.find("select[name='status']").val()*/ }; }, //分页 /*onClickRow : function(row, tr,flied){ console.log(row); },*/ pageSize : 5, //每页显示的记录数 pageNumber : 1, //当前第几页 pageList : [ 5, 10, 25, 50 ,100 ], //记录数可选列表*/ responseHandler: function(data){ return {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9e8fac38f61eb236de4e38a5e6a8aca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5774e966c7f9d4fa237fd7c2fcc2a58/" rel="bookmark">
			python学习——Anaconda及TensorFlow-GPU版本安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载安装Anaconda 官网的下载会很慢，可以在这里下载 http://download.zol.com.cn/detail/45/448706.shtml
然后运行安装包，一路默认安装，直到这一步，一定记得勾选添加anaconda到Path中，不然后面还有要自己手动添加path。
等待几分钟安装完成后，进入cmd，输入
conda -V 以测试anaconda是否成功安装
显示安装成功
2.安装TensorFlow-GPU版本 首先在cmd窗口在创建一个虚拟环境
conda create -n tensorflow pip python=3.6 #虚拟环境的名称为tensorflow 遇到y/n时选择y
安装完成后，使用命令
activate tensorflow 进入虚拟环境，我们将在此虚拟环境中安装tensorflow GPU版本
接下来利用anaconda的pip’工具安装TensorFlow的gpu版本，直接用清华源来下载，不然速度会很慢很慢，这里使用命令
python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple tensorflow-gpu 然后等待其自动下载安装
安装完成后在命令行tensorflow虚拟环境下键入
python 再键入
import tensorflow 系统会提示如下错误
因为用的是tensorflow的gpu版本，要用到NVIDIA的显卡，需要再安装与tensorflow和显卡相匹配的CUDA和cuDNN，一定注意要三者相匹配的版本，如果错装了其他版本的CUDA和cuDNN，建议卸载了，重装正确的版本，楼主之前装错了版本，把10.1，10.0和9.0都装了，但是仍然无法正常使用tensorflow，可能是多个版本之间有覆盖更新的部分，反而导致正确的版本不可用，所以建议卸载重装。
下面说下，如何确定应该安装的CUDA和cuDNN版本，假设tensorflow安装在F:\Technicalware\Anaconda3\envs\tensorflow目录下，
那么以文本方式打开F:\Technicalware\Anaconda3\envs\tensorflow\Lib\site-packages\tensorflow\python\platform\build_info.py这个文件，可以看到你的tensorflow所应该使用的CUDA 和cuDNN 版本：
cuda_version_number = ‘10.0’
cudnn_version_number = ‘7’
msvcp_dll_name = ‘msvcp140.dll’
nvcuda_dll_name = ‘nvcuda.dll’
cudart_dll_name = ‘cudart64_100.dll’
cudnn_dll_name = ‘cudnn64_7.dll’
这里的msvcp140.dll应该在C:\Windows\System32\下面，是通过安装vc 2005 redistribute提供的，nvcuda.dll也是在C:\Windows\System32\下面，cudart64_100.dll则是安装CUDA 10.0时产生的，cudnn64_7.dll是安装cuDNN 7时产生的,注意cudnn的版本要与CUDA版本对应，任何一个文件缺失或者版本不对都可能会导致tensorflow在import时报ImportError错
3.安装相应的CUDA 和cuDNN 版本 了解了所需要安装的CUDA 和cuDNN 版本，即可到NVIDIA官网下载相应的版本，这里给出网站链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5774e966c7f9d4fa237fd7c2fcc2a58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa890b90f056e51fd1d63398fbff6240/" rel="bookmark">
			Skyjoker前来报到。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是小组的组员黄杨，Skyjoker、Glede都是我的ID。略懂C++，有一些独立开发的经验，同时在学习iOS平台开发，在这个组里很可能变成美工。 我的博客园个人博客：http://www.cnblogs.com/skyjoker
希望在这个组里学到一些团队项目的经验。
转载于:https://www.cnblogs.com/buaashine/archive/2012/09/22/2698277.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ac68c08f65b051bd14eb00e3e153e4/" rel="bookmark">
			排序算法：快速排序（快排）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		期望时间复杂度：O(nlogn) 最坏：O(n^2)
最好: O(n)
快速排序，如果不自己写，可以用C++ 中的 函数qsort（）可以直接为目标数组排序。//不要因为太方便太好用了，就不继续阅读下面?的核心讲解
特点：（1）在内存中，最优秀的一种排序算法。速度快，效率高，顾名思义。
（2）不稳定性质，跟数据源有关系。//所以时间复杂度如上?，唯一优化的点在，支点选择，会影响排序效率 思想：二分法（分而治之）
快速排序（Quicksort）是对冒泡排序的一种改进。 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是： 通过一趟排序（快排的一次划分）将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法实践： （1）基本用法 //快速排序 void quick_sort(int s[], int l, int r) { if (l &lt; r) { int i = l, j = r, x = s[l]; //s[l]支点 while (i &lt; j) //快排的一次划分 { while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数 j--; if(i &lt; j) s[i++] = s[j]; while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数 i++; if(i &lt; j) s[j--] = s[i]; } s[i] = x; quick_sort(s, l, i - 1); // 递归调用 第一部分 quick_sort(s, i + 1, r); // 递归调用 第二部分 } } （2） //第k小元素,快速排列实现,返回数组下标。注意a[]中的顺序被改变
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2ac68c08f65b051bd14eb00e3e153e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0fa5ae8a967c2d1e59f38983d33665/" rel="bookmark">
			iOS 开发规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司来了大牛 是绝好的学习机会
今天分享了我们一个代码规范
比如UITableViewCell
1.首先根据这个cell 需要的数据源 建一个数据model ,只针对于 该cell 好处:数据独立化
2.对于cell里面的实例变量 使用setter getter 方法 初始化 一些定量的属性 都可以这个时候设置
3.在对当前视图进行赋值时候(用1 中创建的模型),再对对应的实例变量 进行赋值 在整个代码界面
代码用标记区分类别
#pragma mark - life cycle - (void)viewDidLoad … #pagma mark - protocols //代理方法 - (UITableViewCell ​*)tableView:(UITableView *​)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath … #pragma mark - event response - (void)didClickTabButton:(id)sender #pragma mark - private methods #pragma mark - getter and setter 转载于:https://www.cnblogs.com/someonelikeyou/p/4936007.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed8bc068c929a3ecd3e2ccef9a957b3c/" rel="bookmark">
			给label绘制下划线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UIlabel本身没有下划线的属性，使用绘制的方法，添加下滑下，并且赋给该label一个action作为响应方法，实现DIY超链接的效果。
//调用
#import "UnderLineLabel.h" UnderLineLabel *label = [[UnderLineLabel alloc] initWithFrame:CGRectMake(50, 200, 300, 30)]; [label setBackgroundColor:[UIColor clearColor]]; // [label setBackgroundColor:[UIColor yellowColor]]; [label setTextColor:[UIColor blueColor]]; [label setBackgroundColor:[UIColor yellowColor]]; label.highlightedColor = [UIColor redColor]; label.shouldUnderline = YES; [label setText:str andCenter:CGPointMake(200, 240)]; [label addTarget:self action:@selector(labelClicked)]; [self.view addSubview:label]; // [label release]; //"超链接执行的方法" - (void)labelClicked { NSLog(@"%@", NSStringFromSelector(_cmd)); UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"Clicked!" message:nil delegate:nil cancelButtonTitle:@"Ok" otherButtonTitles:nil, nil]; [alertView show]; [alertView release]; } UnderLineLabel.h
#import &lt;UIKit/UIKit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed8bc068c929a3ecd3e2ccef9a957b3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e1508f0a7eb717a5b1947dd2d410335/" rel="bookmark">
			OC 实现的几个排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和在VC++6.0里相比 在OC里面实现 不算困难 可是我用惯了C/C++呢 快速排序，冒泡排序，直接插入排序和折半插入排序，希尔排序，堆排序，直接选择排序
/*******************************快速排序 start**********************************/
//随即取 当前取第一个，首先找到第一个的位置，然后分成left和right两组子集 ，分别对left和right继续执行分割(同上操作)
-(void)QuickSort:(NSMutableArray *)list StartIndex:(NSInteger)startIndex EndIndex:(NSInteger)endIndex{
if(startIndex &gt;= endIndex)return;
NSNumber * temp = [list objectAtIndex:startIndex];
NSInteger tempIndex = startIndex; //临时索引 处理交换位置(即下一个交换的对象的位置)
for(int i = startIndex + 1 ; i &lt;= endIndex ; i++){
NSNumber *t = [list objectAtIndex:i];
if([temp intValue] &gt; [t intValue]){
tempIndex = tempIndex + 1;
[list exchangeObjectAtIndex:tempIndex withObjectAtIndex:i];
}
}
[list exchangeObjectAtIndex:tempIndex withObjectAtIndex:startIndex];
[self QuickSort:list StartIndex:startIndex EndIndex:tempIndex-1];
[self QuickSort:list StartIndex:tempIndex+1 EndIndex:endIndex];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e1508f0a7eb717a5b1947dd2d410335/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/528d493d4d21b5a31cb637b2fed7bbd9/" rel="bookmark">
			【转】awk、nawk、mawk、gawk的简答介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：http://blog.sina.com.cn/s/blog_3d2d79aa0100h47h.html
awk 是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出（即管道）。它支持用户自定义函数和 动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。
awk的处理文本和数据的方式是这 样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。如果没有指定处理动作，则把匹配的行显示到标准输出 (屏幕),即默认处理动作是print；如果没有指定模式，则所有被操作所指定的行都被处理，即默认指定模式是全部。awk分别代表其作者姓氏的第一个字母。因为它的作者是三个人，分别是Alfred Aho、Brian Kernighan、Peter Weinberger。gawk是awk的GNU版本，它提供了Bell实验室和GNU的一些扩展。
像shell一样，awk也有好几种，常见的如awk、nawk、mawk、gawk，其中
awk:最初在1 9 7 7年完成，1 9 8 5年发表了一个新版本的awk，它的功能比旧版本增强了不少,awk 能够用很短的程序对文档里的资料做修改、比较、提取、打印等处理,如果使用C 或P a s c a l 等语言编写程序完成上述的任务会十分不方便而且很花费时间，所写的程序也会很大;
nawk： 在 20 世纪 80 年代中期，对 awk语言进行了更新，并不同程度地使用一种称为 nawk(new awk) 的增强版本对其进行了替换。许多系统中仍然存在着旧的awk 解释器，但通常将其安装为 oawk (old awk) 命令，而 nawk 解释器则安装为主要的 awk 命令，也可以使用 nawk 命令。Dr. Kernighan 仍然在对 nawk 进行维护，与 gawk 一样，它也是开放源代码的，并且可以免费获得;
mawk：mawk 是 awk 编程语言的解释器。awk语言在多媒体数据文件以及文本的检索和处理，算法的原型设计和试验都有广泛的使用。mawk带给awk新的概念，它实现了在 《The AWK Programming Language》（Aho, Kernighan and Weinberger, The AWK Programming Language, Addison-Wesley Publishing, 1988.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/528d493d4d21b5a31cb637b2fed7bbd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb46f180bbd849c0821ecb3e0d37a3e/" rel="bookmark">
			Palindrome Partitioning
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Given a string s, partition s such that every substring of the partition is a palindrome.
Return all possible palindrome partitioning of s.
For example, given s = "aab",
Return
[ ["aa","b"], ["a","a","b"] ] 又是一道回文的题目，回文系列有非常多的题目，主要是DP＋search的思路。这题也是。
先用DP求一个是否回文的状态矩阵，之后根据这个状态矩阵做dfs+backtracking；当然也可以一边DP，一边组织结果，针对结尾位置保存一个数组，每次可以针对当前回文字符加上之前那个位置有的所有组合做一个组合（https://discuss.leetcode.com/topic/2884/my-java-dp-only-solution-without-recursion-o-n-2）。
我的代码如下：
class Solution(object): def partition(self, s): """ :type s: str :rtype: List[List[str]] """ #first find the 2 dimension dp state #then search and backtracking to generate result. #dp order is very important dp = [[False]*len(s) for i in xrange(len(s))] for i in xrange(len(s)-1, -1, -1): #start for j in xrange(i, len(s)): #end if s[i] == s[j] and (i+1&gt;j-1 or dp[i+1][j-1] == True): #核心判断语句 dp[i][j] = True res = [] self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cb46f180bbd849c0821ecb3e0d37a3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d491bc2d93d418a29d917656bfba221/" rel="bookmark">
			Majority Element出现次数超过一半的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
You may assume that the array is non-empty and the majority element always exist in the array.
这是一道编程之美和剑指offer上都有的题目。
直观的思路先对数组进行排序，则中间index上存储的数一定是该出现次数超过一半的数字。但是这种操作的时间复杂度为为排序的时间复杂度O(nlogn)，不是很理想。
另外一种思路是思路是对快排的改进，即我们不需要对数组进行彻底排序，只需要找到那个在最终排序完的数组中的中间index的那个元素。使用QuickSort的partition来完成这种任务很合适。每次partition会找到 pivot所在的index，可以通过不断二分选择，使最终的pivot的index为（left＋right)/2达到目的。
算法时间复杂度平均情况下为O(n)。也是devide and conquer分治的思想。
另外一种思路是既然该数字在数组中出现次数超过一半，则该数字的出现次数比其他所有数字的次数都多。则每次删除数组中两个不同的数，留下的数组中该数字的出现次数依然超过一半。
具体实现时并不是真正去两两删除，而是用一个times和一个result来模拟。result保存数组中的数字，times保存出现的次数。如果下一个数字和我们保存的result中的值不一样，则times的值减1，否则times加1，如果当前times为0，则将result的值赋为当前值，最终result的值为那个出现出现次数超过一半的数的值。代码如下：
class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: int """ times = 1 ＃开始times初始化 result = nums[0] ＃ for i in nums[1:]: if times == 0: result = i ＃重新开始 times = 1 ＃重新开始计数 else: if result == i: times += 1 else: times -= 1 return result 注意如何把这段代码和两两删除不同的元素对应上。实际上从result赋值，times为1，到times降为0这个过程，实现的就是删除元素的过程。比如1234，1到2时，times为0，3时times重新等于1，record为3，4时times又降为0，其实就是两两删除的过程。如果有连续值，555534216，则到1时，times也降为0，相当于（5，3），（5，4），（5，2），（5，1）两两删除了。所以在最后一个 times为1，record换值时，record就是那个出现超过一半的数字，一直到数组尾部，也没有那么多和record不同的元素来和它抵消。算法成立。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d491bc2d93d418a29d917656bfba221/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db7a8a2154722ca05c66a90c70c88599/" rel="bookmark">
			Pascal&#39;s Triangle II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Given an index k, return the kth row of the Pascal's triangle.
For example, given k = 3,
Return [1,3,3,1].
Pascal's Triangle为给出行数，求所有结果，这题是给出任意行号，求该行的结果。 Pascal's Triangle本身需要返回二维结果，可以在二维数组上直接操作。但是这题需要返回一维的结果，直接采用之前的思路是不太好的。所以此处采用一个滚动数组，用数组的变化去不断模拟从上到下的每一行。具体处理时的顺序值得处理，一种是从左到右，但是实际res[n][j]=res[n-1][j]+res[n-1][j-1]。从前往后走存在值覆盖的问题，需要用到中间变量。另外一种是，根据这种转化关系，从右往左扫。当前值的处理不会影响下一步的操作，因为下一步的操作只涉及到更之前的值。
从左到右，44ms,代码：
class Solution(object): def getRow(self, rowIndex): """ :type rowIndex: int :rtype: List[int] """ if not rowIndex: return [1] row = [1,1] for i in range(1,rowIndex): prev = 1 for j in range(1,i+1): tmp = row[j] row[j] += prev prev = tmp row.append(1) return row 从右到左，40ms,代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db7a8a2154722ca05c66a90c70c88599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2268578c699908d4caa4d57ad3daefb/" rel="bookmark">
			Wood Cut
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.lintcode.com/zh-cn/problem/wood-cut/
有一些原木，现在想把这些木头切割成一些长度相同的小段木头，需要得到的小段的数目至少为 k。当然，我们希望得到的小段越长越好，你需要计算能够得到的小段木头的最大长度。
注意事项 木头长度的单位是厘米。原木的长度都是正整数，我们要求切割得到的小段木头的长度也要求是整数。无法切出要求至少 k 段的,则返回 0 即可。
Lintcode上面的一道题目，很有意思，光看题可能想象不出是用二分来做。但是实际小段的长度可以使用二分来确定。left为0，right为原始木头的最长长度（注意不是最小长度）。但是这道题二分的复杂度也不是O(logn)而是和木头的数目也成正比关系（每次对于划分的长度，需要计算一遍所有的木头得到可以锯出的小段数目）。具体代码如下：
class Solution: """ @param L: Given n pieces of wood with length L[i] @param k: An integer return: The maximum length of the small pieces. """ def woodCut(self, L, k): if not L: return 0 l = 0 r = max(L) while l+1 &lt; r: mid = l + (r-l)/2 if sum([i/mid for i in L]) &gt;= k: l = mid else: r = mid if sum([i/r for i in L]) &lt; k: return l else: return r 转载于:https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2268578c699908d4caa4d57ad3daefb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e1d2f6e6ba815c0c9e051685c522297/" rel="bookmark">
			最大子段 copy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：http://xiaying-hefei.javaeye.com/blog/752299
动态规划法：
其与分治法类似，基本思想也是将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是独立的。
我们用一个表来记录所有已经解决的自问题的答案。动态规划法通常用于求解具有某种最优性质的问题。在这类问题中，每个解都对应一个值，我们希望找到具有最优值的那个解。
问题：
由给定的n个整数（可能为负整数）组成的序列a1，a2，...，an，求该序列的子段和最大值。当所有整数均为负数时定义其最大子段和为0。例如：（-2，11，-4，13，-5，-2）时，最大字段和为11 + -4 + 13 = 20
代码如下： #include &lt;stdio.h&gt; // 定义b[j]为a[i]...a[j]的最大子段和。则当b[j-1] &gt; 0时，b[j] = b[j-1] + a[j]，否则b[j] = a[j] int maxSum(int *v, int n) { int sum = 0, b = 0; int i; for(i = 1; i &lt;= n; i++) { if(b &gt; 0) b += v[i]; else b = v[i]; if(b &gt; sum) sum = b; } return sum; } void main() { int a[] = { 0, -2, 11, -4, 13, -5, -2 }; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e1d2f6e6ba815c0c9e051685c522297/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc0ef784510b8782efb68cdb1a26d938/" rel="bookmark">
			SQL作业一些笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1。设置连接查询的阀值后，有些慢查询作业执行失败
在作业开头加上下面以句可以解决该问题
-----------------------------------------
-- 当前查询关闭超时控制,只对此连接有效
SET QUERY_GOVERNOR_COST_LIMIT 0
-----------------------------------------
2。SQL存储过程中，连接MYSQL查询，莫名奇妙出现报错如下:
消息
已以用户 NT AUTHORITY\SYSTEM 的身份执行。 链接服务器 "(null)" 的 OLE DB 访问接口 "MSDASQL" 报错。提供程序报告了意外的灾难性错误。 [SQLSTATE 42000] (错误 7399) 无法初始化链接服务器 "(null)" 的 OLE DB 访问接口 "MSDASQL" 的数据源对象。 [SQLSTATE 42000] (错误 7303) SELECT @uid=uid,@username=username,@nickname=nickname,@email=email,@stat_date=dateadd(hour,8,dateadd(second,register_time,'1970-1-1')) FROM OPENROWSET('MSDASQL','DRIVER={MySQL ODBC 5.1 Driver};SERVER=10.0.0.11;PORT=3306;DATABASE=mysqldb;USER=test;PASSWORD=123456;STMT=set names UTF8;OPTION=11212','select uid,cast(username as char(100)) as username,cast(nickname as char(100)) as nickname,cast(email as char(50)) as email,register_time from user where uid&gt;100 order by uid asc limit 1') [SQLSTATE 01000] (错误 0).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc0ef784510b8782efb68cdb1a26d938/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a79877ff74869ec57e09e40227b969/" rel="bookmark">
			Learning Java language Fundamentals
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chapter 2 Learning Java language fundamentals
exercises: 1.What is Unicode?
Unicode is a computing industry standard for consistently encoding,representing,and handling text that's expressed in most of world's writing system
2.What is a comment?
A comment is language feature for embedding documentation in source code
3.Identify the three kinds of comments that Java supports.
single-line,multiline,javadoc
4.What is an identifier?
An identifier is a language feature that consist of letter (A-Z,a-z,or equivalent uppercase/lowercase letters in other human alphabets),digits (0-9 or equivalent digits in other human alphabets),connecting punctuation characters,and currency symbols.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62a79877ff74869ec57e09e40227b969/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba949d811e0b88e037cceeedf1158f9a/" rel="bookmark">
			How does java technology relate  to cloud computing?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java Paas shootout (@IBM developer)
Cloud computing is always a hot topic around IT field today.How can it bring to us ?How can it change our life? No answers...
"The Java ecosystem is rapidly expanding to support developers who want to build, test, or deploy Java applications on the cloud. Especially relevant is Platform as a Service (PaaS), in which the cloud provider delivers not only on-demand hardware and operating-system services, but also application platforms and solution stacks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba949d811e0b88e037cceeedf1158f9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/370c1ab141dc12cb9490a220ace22afa/" rel="bookmark">
			matlab 中的textscan
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		textread 与textscan的区别 textscan更适合读入大文件；
textscan可以从文件的任何位置开始读入，而textread 只能从文件开头开始读入；
textscan也可以从上一次textscan结束的位置开始读入，而textread不能；
textscan只返回一个数组（其实应该说是一个细胞矩阵），而textread要返回多个数组（嗯嗯）；
textscan提供更多转换读入数据的选择；
textscan提供给用户更多的配置参数。
来源：http://blog.sina.com.cn/s/blog_9e67285801010buf.html
textscan函数
功能：读格式的数据从文本文件或字符串。适用于具有多行文字说明文本数据文件。
————————————————————————————————————————
基本用法：
C = textscan(fid, 'format')
C = textscan(fid, 'format', N)
C = textscan(fid, 'format', 'param', value)
C = textscan(fid, 'format', N, 'param', value)
C = textscan(str, ...)
[C, position] = textscan(...)
——————————————————————————————————————
输入参数
fid 为fopen命令返回的文件标识符，这也是和textread的最大不同之处
需要注意的一点是，fid类似一个指针，其指向的位置会随着textscan的操作而改变，参见例9
format 是一个字符串变量，表示读取数据及数据转换的规则，具体见format.txt
N 读取N次，一般为行数
输出参数
输出一个细胞数组C
基本与textread语法相同
.............................................................................
例1：
'mydata1.txt文件如下
Sally Level1 12.34 45 1.23e10 inf Nan Yes 5.1+3i
Joe Level2 23.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/370c1ab141dc12cb9490a220ace22afa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0ee173c8e646bc9085983ac1d9c8352/" rel="bookmark">
			如何使用iText制作中文PDF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载itextpdf.jar
基础包：http://jaist.dl.sourceforge.net/project/itext/iText/iText5.5.2/itext-5.5.2.zip
附加包：http://cznic.dl.sourceforge.net/project/itext/extrajars/extrajars-2.3.zip
我们只下载基础包就可以
2. 创建工作文件夹
daniel@daniel-mint ~/itext $ ls daniel.java fonts itextpdf-5.5.2.jar run.sh 其中fonts是一个目录，用来存放我们用到的字体文件。
daniel@daniel-mint ~/itext $ cat run.sh javac -cp .:itextpdf-5.5.2.jar $1.java java -cp .:itextpdf-5.5.2.jar $1 rm $1.class daniel@daniel-mint ~/itext $ cat daniel.java import java.io.FileOutputStream; import java.io.IOException; import com.itextpdf.text.Document; import com.itextpdf.text.Font; import com.itextpdf.text.PageSize; import com.itextpdf.text.DocumentException; import com.itextpdf.text.Paragraph; import com.itextpdf.text.Chunk; import com.itextpdf.text.Rectangle; import com.itextpdf.text.pdf.PdfWriter; import com.itextpdf.text.pdf.BaseFont; public class daniel { public static final String RESULT = "daniel.pdf"; public static void main(String[] args) throws DocumentException, IOException { Document document = new Document(PageSize.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0ee173c8e646bc9085983ac1d9c8352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58577c4538f6f0a98efb0fbe30226a0f/" rel="bookmark">
			GHCi Prelude学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：http://www.cse.unsw.edu.au/~en1000/haskell/inbuilt.html
http://www.cse.unsw.edu.au/~en1000/haskell/hof.html
在GHCi中，可以使用:type来查看对象的类型，与http://www.cnblogs.com/long123king/p/3837686.html中说到的一样，
Haskell中，函数也是一种特殊的对象，对象就有类型，函数作为一种对象，可以作为参数传递，也可以赋值，创建和销毁。
Prelude&gt; :type (+) (+) :: Num a =&gt; a -&gt; a -&gt; a 这个类似要怎么解释呢，"::"的前面是函数的名称，后面是函数对象的类型，或者说原型。
"=&gt;"前面的Num a是表明参数的类型，
Prelude&gt; :type 1 1 :: Num a =&gt; a 后面是函数的输入与输出类型声明。
之所以会有多个-&gt;，那是因为(+)函数对象中其实包含一个更加简单的函数，比如(+) 2，这个函数的意思是“在使用(+)函数对象时，将第一个参数固定为2，这与boost中的bind类似”，而这个函数对象的类型是Num a =&gt; a-&gt;a，
再把另外一个参数传递给这个简单的函数，得到的结果也是a类型，因此(+)是一个复合函数。
凡是需要多个参数的函数对象，都可以分解成一步一步的简单函数组成的复合函数。
Prelude&gt; (+) 2 &lt;interactive&gt;:35:1: No instance for (Num a0) arising from a use of `+' The type variable `a0' is ambiguous Possible fix: add a type signature that fixes these type variable(s) Note: there are several potential instances: instance Num Double -- Defined in `GHC.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58577c4538f6f0a98efb0fbe30226a0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7162514e370148c1908b346e251b0234/" rel="bookmark">
			常用数据结构之二叉树的特性以及适用场景总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树 二叉树是一个特殊的树型结构，有一下的特点：
最多有 2 个子节点，称为左节点和右结点。左右节点的次序不能颠倒，即使只有一个节点也需要区分是左子节点或者右子节点。 没有子节点的节点称为叶子节点。
完全二叉树 在二叉树的基础上，n 层的完全二叉树，所有的叶子节点都在第 n 层或者 n - 1 层。
同时左右子节点需要连续。
满二叉树 在二叉树的基础上，所有的叶子节点都在最后一层。根节点的左右子树没有高度差。
二叉树的遍历 遍历的时候，中序、前序和后序遍历的时候，是看根节点出现在哪里来判断的。根节点第一个出现是前序遍历。
深度优先和广度优先 深度优先用栈实现。利用后进先出的特点。
广度优先用队列实现，利用先进先出的特点。
堆 堆，分为最小堆和最大堆。堆的特性是，首先是一个完全二叉树，然后向树里面添加节点的时候，需要调整这个二叉树，如果新加入的节点比堆父节点小或者大的，就和父节点交换，直到堆顶。
堆可以用数组表示，下标从 1 开始，左右子节点分别为 2 * i 和 2 * i + 1 。
堆适合查找一堆数据里面 top k 大或者小的数据的场景，比如从10亿数据里面找到前 100 大的数，这个时候就可以用最小堆来做，构造一个容量为 100 的最小堆，然后遍历 10 亿的数据，然后尝试往堆里面添加数据，当堆满了的时候，和堆顶比较，比堆顶小的话，什么都不做，当比对顶大的话，先查找堆里面是否已经有了这个数(看要求，如果允许重复的数，那么就不用查找，如果不允许重复，就需要去重)，如果有了就什么都不做，如果没有，就替换堆顶，调整堆。
二叉查找树 某个节点的值比他的左子节点的值大，比他的右子节点的值小。可以简单记忆为，父节点大于所有的左子树的节点，父节点小于所有的右子树节点。
基于这个特性查找某个数比较方便。
平衡二叉查找树 当一组数据有序的时候，二叉查找树会变成一个链表，失去了高效查询的效率。平衡二叉树规定，根节点的左右子树的高度差不超过 1 ，超过 1 的时候需要自旋，以保证左右子树高度差不超过 1.
AVL 树 AVL 树是平衡二叉查找树的一种实现，定义如下
每个节点的左子树和右子树都是 AVL 树左子树和右子树的高度差不超过 1 特性
添加删除节点后都需要从新平衡
红黑树 红黑树也是平衡二叉查找树的一种实现。红黑树的特性如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7162514e370148c1908b346e251b0234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87ee2926876a60e935e682413772a729/" rel="bookmark">
			wp8-xaml调试设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#项目右键属性-&gt;调试
修改托管为本机
转载于:https://www.cnblogs.com/moonbear/p/4012772.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/001503f4b4edc07c3f9ff45286595ee3/" rel="bookmark">
			Linq To Sql进阶系列（六）用object的动态查询与保存log篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态的生成sql语句，根据不同的条件构造不同的where字句，是拼接sql 字符串的好处。而Linq的推出，是为了弥补编程中的 Data != Object 的问题。我们又该如何实现用object的动态查询呢？
1，用object的查询是什么？
我们可以简单的举这么一个例子。我们到公安局查找一个人。首先，我们会给出他的一些特征，比如，身高多少，年龄多少，性别，民族等。那么，我们把这个人的一些特征输入电脑。我们希望，电脑能给我们返回这个人的信息。而实际上，有相同特征的人太多了，常常返回一个集合。那让我们把这个过程抽象到程式里。我们需要new出来一个对象。这个对象包含了我们能知道的基本信息。而后，把这个对象传给Linq To Sql，等待返回结果。
根据这些基本的需求，我们来定义下面的函数，为了实现这个函数对任何实体都是有用的，我们把它定义为generic的。为了不破坏Linq To Sql延迟加载的规矩，我们把它的返回类型定义为IQueryable。如下：
public IQueryable &lt; TEntity &gt; Find &lt; TEntity &gt; (TEntity obj) where TEntity : class 思路出来了，先new出来一个对象，然后把对象传给这个函数，我们渴望它能返回与这个对象匹配的结果集。为了让它和DataContext有关系，我们把这个函数放到DataContext的partial类里。鼠标右击Linq To Sql文件，选择view code，这个时候，vs会为你创造一个DataContext的partial类，其扩展名比影射文件少了中间的desiger。大家要注意，你如果想自己修改影射文件，请放到这个文件里。这样当影射code被刷新时，才不会冲掉你自己的修改。先大体描述下我们的思路。
NorthwindDataContext db = new NorthwindDataContext();
// 先new出一个对象 Customer c = new Customer();
// 添入我们知道的最基本的信息，可以从ui获得 c.City = " London " ;
c.Phone = " 23236133 " ;
// call函数find返回结果 var q = db.Find &lt; Customer &gt; (c); 2，原理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/001503f4b4edc07c3f9ff45286595ee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/514d34c623f0dac8045958959bb4529c/" rel="bookmark">
			Java阻塞式线程同步队列BlockingQueue，SynchronousQueue和TransferQueue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java阻塞式线程同步队列BlockingQueue，SynchronousQueue和TransferQueue BlockingQueue在队列读或取数据时候加锁。生产者向队列添加元素但队列已满时，生产者会被阻塞，反过来，当消费者从队列取出元素但队列为空时，消费者会被阻塞。BlockingQueue（和Queue）是Java 1.5加入的接口类，它是这样一种队列：当生产者向队列添加元素但队列已满时，生产者会被阻塞；当消费者从队列移除元素但队列为空时，消费者会被阻塞。
ArrayBlockingQueue有界阻塞式同步队列。内部用数组存放元素。
LinkedBlockingQueue不同于ArrayBlockingQueue，若不设定容量，默认为Integer.MAX_VALUE，即无界队列。LinkedBlockingQueue 实现 BlockingQueue 的接口。LinkedBlockingQueue内部用链表存放元素。LinkedBlockingQueue 以 FIFO顺序对数据元素存取。
SynchronousQueue实现BlockingQueue接口。常用于阻塞式的同步数据传递，类似“管道”。SynchronousQueue的队列长度为0，SynchronousQueue的队列状态只能有一个数据元素或没有没有数据元素。SynchronousQueue特别适用两个线程之间传递数据这种场景。
LinkedTransferQueue，Java 1.7新增，基于链表实现，它是ConcurrentLinkedQueue、SynchronousQueue、LinkedBlockingQueue的超集。LinkedTransferQueue采用一种预占的线程同步模式。当消费者线程从队列中取元素时，如果此时队列为空，就生成一个null节点放入队列，然后消费者线程就在这个null节点上等待；后面生产者线程若把数据元素放入队列时发现有一个元素为null的节点，生产者线程就不直接入队，而是直接将该数据元素填写到该节点，并唤醒在该节点上处于等待状态的线程，消费者线程被唤醒后，它就取走数据元素。
DelayQueue，延迟队列。用于延迟情况下的阻塞式队列元素存取。
PriorityBlockingQueue是BlockingQueue的子类。具有优先级的阻塞式同步队列。
Java 1.7中加入TransferQueue和其实现类LinkedTransferQueue。TransferQueue继承BlockingQueue（BlockingQueue又继承了Queue）并扩展一些新方法。
TransferQueue相比SynchronousQueue用处更广、更好用。TransferQueue更进一步，生产者会一直阻塞直到所添加到队列的元素被某一个消费者所消费（不仅仅是添加到队列就完事）。新增的transfer实现这一点。阻塞通常就是发生在元素从一个线程transfer到另一个线程过程中发生，它有效地实现元素在线程之间的传递。
TransferQueue还包括其他一些方法：两个tryTransfer方法，一个是非阻塞的，另一个带有timeout参数设置超时。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed0ea2ffeeca7a9a2cecddcb37cc279/" rel="bookmark">
			DIV与Table布局在大型网站的可用性比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DIV与TABLE本身并不存在什么优缺点，所谓web标准只是推荐的是正确的使用标签，好比说:DIV用于布局，而TABLE则本来就是转二维数据的。让TABLE做该做的事，并不是说页面里不出现TABLE就是多么多么牛。 用DIV进行排版的优势就是我不说，大家应该都比较清楚。DIV是标准，是大势所趋，但并不意味着所有的页面都适合用它来做。 中国的门户和国外的有很大的区别，中国网民并不喜欢信息量少的页面，YAHOO到了中国页面上的内容就多了不少，而上次改为简洁的页面后访问量下降的厉害以至于没过几天就又改了回来。正式由于中国的国情造就了搜狐、新浪这样门户。 为什么DIV不适合他们?下面我从几个方面来逐一说明: 精简代码: 大家都说DIV的布局精简代码，但是用DIV替代TABLE所节约的代码又被CSS(样式)所占用，而这些样式大多用于控制DIV的排版布局。那你会说了，CSS可以放在外部重用啊，要想得到这个问题的答案请往下看。 重用性与下载量: 统一使用一个.css的样式表文件，可以实现修改一次，全站修改的效果，这样使得维护的成本更低。但是请大家换一个角度想，如果所有页面在加载时都要访问一个文件，那这个文件每天的下载量，特别时在搜狐、新浪的网站平台上将达到几亿次，这就需要后面有很多台前端web服务器在做支撑，那后台的成本无形中也提高了很多。如果后台支撑没有做好，那么页面就会出现花屏，之前所作的工作也是白费。很多人会问，这样的几率太小了。我们所作的工作就是为了避免这一两次意外的发生，如果意外发生了，对于门户后果将是不堪设想的。 HTTP通讯: 统一的样式表文件采用外部调用的形式，这样每次加载单个页面都会多一次对服务器的http请求服务器都会增加一次响应，这样对前端web服务器会是很大的消耗。而原来很长时间都是将css和js写在页面前端(大家可以看看sohu和sina的页面，大多都是采用这样的形式)，而不是作为外部调用的形式，也是为了尽量避免给服务器增加消耗。 页面缓存: 每次用户访问的页面，都会在浏览器缓存中保存一定时间，以保证用户下次再访问该页面时能够大大提高页面显示速度。而每次修改都会使页面重新下载，对于每个外部导入的样式文件也是如此，如果CSS文件修改，那么访问网站的每一个页面都会重新下载，而以往的将样式写在页面中的方式，只是修改的页面需要重新下载。 兼容性: 对于CSS(样式表)并不是所有浏览器的所有版本都支持的很好，比如IE5以前的浏览器对于CSS的支持就不是很好。而现在使用IE5以前版本浏览器的用户不在少数，这样就使得在页面制作的过程中需要针对不同浏览器版本进行测试，以保证兼容性，无形中也增加很多工作量(至少我接触的开发人员制作div页面比table页面的标准时间要长一些)。 横切与延展性: 横切——传统的布局方式为了使页面下载的更快，把页面自上而下分成若干个块，但是往往采用DIV进行布局的页面都会出现这样的情况，由于每块中间栏或者其他栏内容条数不固定导致两边栏目没有同时自适应，而出现留白。 相比之下传统的table方式更容易规避这样情况的发生。 以上我们只是讨论某一技术在某一领域的可用性，而非技术本身。 说了这么多并不是说DIV这种布局方式不好，而是说我们应该正确的看待Table在以内容为基础的大型门户中的作用，而不是人云亦云。之所以DIV的布局方式没有在大型网站应用，不是说门户没有用DIV是技术落后，是里面的人没有前瞻性，而是多种原因决定的。网易之所以全部采用DIV的方式是因为内容并不是他们主攻方向。而对于其他门户来说，这样的决策是要靠时间来验证的。只是现在这个时机还不成熟而已。 转载于:https://www.cnblogs.com/jinrongju/archive/2007/04/18/717676.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/005ac27b7b0ce4b4818ef8e3e2ea0a1a/" rel="bookmark">
			i18n的实现–gettext的实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[NewEdit]i18n的实现(三)–gettext的实现原理 http://blog.donews.com/limodou/archive/2004/06/15/28961.aspx
附：gettext的实现原理
只是本人的理解!
gettext的功能其实挺简单：定义_()函数并安装，根据传入的翻译项从mo文件中取得译文，并根据uniocde标识进行应用的unicode编码处理。
一个gettext对象提供了两个基本的获得译文的函数：gettext和ugettext。一个用来获得未进行编码转换的译文，一个用来获得转成unicode的译文。根据unicode的标志，这两个函数之一将被引用到_()函数上。如果未安装任何译文，则缺省返回是只是翻译项，即原样返回。因此不安装任何译文，gettext一样是可以用的。
如何安装_()。
import __buildin__
__buildin__.__dict__['_']=unicode and self.ugettext or self.gettext
这样就将_()函数变成一个内置函数了，在其它的后续的模块中就可以直接使用它了。因此，使用gettext时，安装要很靠前，并且只需要在启动模块中装入即可。
后记：为什么 NewEdit 不动态更新界面
既然实现了国际化处理，如果用户改变了使用的语言，如果整个应用立即改变不是更好吗？当然是很吸引人，但对于 NewEdit 存在问题。一方面所有界面与国际化处理相关的地方，都要用代码去实现更新过程，工作量大。另外，除非测试，一个用户不会总是在各种语言之间切换来切换去，一般都是固定使用某种语言，因此，在重新启动后启用新的语言设置是可以接受的方案。还有一个重要的原因就是：使用_()这种方式只适合函数调用方式，对于全局变量或模块变量无能为力。为什么呢？比如：
message = _(‘Chinese’)
这样定义了一个变量。如果它是存在一个模块中，作为模块的全局变量的话，当导入这个模块时，这个语句会执行。并且导入过程只会执行一次。这样当语句执行完毕后message就是具体的值，而不再是message=_(‘Chinese’)这种语句了。这样，当我们改变了语言，message只会是上一个语言的译文，不会变成新的译文。这一点真是很难解决。而为什么在函数调用时可以呢？严格来说应该是这样的形式可以：
call(_(‘Chinese’))
这是因为，当调用函数时参数是动态计算的，因此每次调用call时都会重新计算参数的值，因此这种方式可以的。总的来说，如果在执行时可以每次调用_()函数的话，这样就可以实现动态语言切换。如果不行，则使用静态语言切换。因此 NewEdit 使用了静态语言的切换。
转载于:https://www.cnblogs.com/kungfupanda/archive/2012/07/29/2604948.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a7c7c672d1b2286d772ad319ad14d03/" rel="bookmark">
			eclipse php 环境及调试配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装和配置PDT
下载PDT: download.eclipse.org/tools/pdt/downloads/index.php, 选择最新版本
PDT是Eclipse的插件。
选择pdt-all-in-one版本, 否则需要另外下载eclipse和相关插件, 并手工集成.
2.安装debug环境
由于我用的是最新的xampp1.7.2，试了二天xdebug，出现如下如题：waiting for xdebug session，停止的了57%的进度上，程序无法调试。可能是xdebug和php5.3之间的问题。因此决定改用旧版xampp1.6.8，php的版本是5.2.6。结果还是出现了以上问题，让我不得其解，不得以，换成zend debugger。
xampp版本为1.6.8，从这里下载zend debugger 5.2.x。将文件解压后复制到\xampp\php\ext目录。
打开\xampp\apache\bin目录下的php.ini。的最后添加：
zend_extension_ts = "c:\xampp\php\ext\ZendDebugger.dll"
zend_debugger.allow_hosts=127.0.0.1/10,192.168.88.146
zend_debugger.expose_remotely=always 其中192.168.88.146是你机子上的IP地址。
3.设置PDT下的debug环境
启动Eclipse，将code目录设置为"xampp\htdocs"，这样代码直接放到apache的WEB目录下
从主菜单打开"Window &gt; Preferences &gt; PHP"，
先选中"PHP Excutables"节点，在右面的面板点"Add"按钮，在接下来的窗口中，
选中"Debug"节点，在右面的面板中，
"PHP Debugger"选择XDebug，
"Server"不用变
"PHP Executable"也选择你刚刚添加的那个"xampp-zend"
在PHP Debug透视图中可以点击Debug View中的图标或用快捷键来进行单步跟踪，比如：
F5: 单步跳入（可以跳入require()函数来跟踪到别的PHP文件哟）
F6: 单步跳过
F7: 单步跳出（可以从被require()的文件内跳回调用者哟）
F8: 继续执行（直到遇到下一个断点）
Ctrl+R: 执行到光标所在行（除非遇到断点）
转载于:https://www.cnblogs.com/kungfupanda/archive/2010/12/13/1887688.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d0b81f93dadcde0d1583ab425eaa4cd/" rel="bookmark">
			FreeBSD配置ip和开启SSH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先ifconfig -a 看下网卡名称，然后vi /etc/rc.conf 我先贴下我的图吧
主要是 ifconfig_le0这个的 #set ip ifconfig_le0="inet 192.168.1.213 netmask 255.255.255.0" #set gateway defaultrouter=192.168.1.1 #set hostname hostname WinLinKer 对了，还要设置下DNS vi /etc/resolv.conf 写入你们当地的dns服务器地址 nameserver 4.2.2.1 nameserver 4.2.2.2 以上是我示范的，大家可以根据自己的当地dns 来设置。 这样就行了，接着 /etc/netstart 下 就可以了。 然后，我们来设置下FreeBSD可以远程SSH 编辑/etc/rc.conf 最后加入:sshd_enable="yes" 再次打开/etc/ssh/sshd_config，修改以下设置 1.支持使用口令认证 # Change to yes to enable built-in password authentication. PasswordAuthentication yes PermitEmptyPasswords no 2.允许以Root身份远程登录 PermitRootLogin yes 3.避免提示后长期等待 UseDNS no 好了，大功告成。 转载于:https://www.cnblogs.com/kungfupanda/archive/2010/12/09/1901284.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abee1f5d3b93752d20a29f0da696ea0a/" rel="bookmark">
			[转自华尔街的强帖]怎样才能嫁给有钱人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个年轻漂亮的美国女孩在美国一家大型网上论坛金融版上发表了这样一个问题帖： 我怎样才能嫁给有钱人？ " 我下面要说的都是心里话。本人 25 岁，非常漂亮，谈吐文雅，有品位，想嫁给年薪 50 万美元的人。你也许会说我贪心，但在纽约年薪 100 万才算是中产，本人的要求其实不高。 这个版上有没有年薪超过 50 万的人？你们都结婚了吗？我想请教各位一个问题 —— 怎样才能嫁给你们这样的有钱人？我约会过的人中，最有钱的年薪 25 万，这似乎是我的上限。要住进纽约中心公园以西的高尚住宅区，年薪 25 万远远不够。我是来诚心诚意请教的。有几个具体的问题： 有钱的单身汉一般都在哪里消磨时光？（请列出酒吧、饭店、健身房的名字和详细地址。） 我应该把目标定在哪个年龄段？ 为什么有些富豪的妻子看起来相貌平平？我见过有些女孩，长相如同白开水，毫无吸引人的地方，但她们却能嫁入豪门。而单身酒吧里那些迷死人的美女却运气不佳。 你们怎么决定谁能做妻子，谁只能做女朋友？ ( 我现在的目标是结婚。 )
—— 波尔斯小姐 下面是一个华尔街金融家的回帖： " 亲爱的波尔斯：我怀着极大的兴趣看完了贵帖，相信不少女士也有跟你类似的疑问。让我以一个投资专家的身份，对你的处境做一分析。我年薪超过 50 万，符合你的择偶标准，所以请相信我并不是在浪费大家的时间。 从生意人的角度来看，跟你结婚是个糟糕的经营决策，道理再明白不过，请听我解释。抛开细枝末节，你所说的其实是一笔简单的 " 财 "" 貌 " 交易：甲方提供迷人的外表，乙方出钱，公平交易，童叟无欺。但是，这里有个致命的问题，你的美貌会消逝，但我的钱却不会无缘无故减少。事实上，我的收入很可能会逐年递增，但你不可能一年比一年漂亮。 因此，从经济学的角度讲，我是增值资产，你是贬值资产，不但贬值，而且是加速贬值！你现在 25 岁，在未来的五年里，你仍可以保持窈窕的身段，俏丽的容貌，虽然每年略有退步。但美貌消逝的速度会越来越快，如果它是你仅有的资产，十年以后，你的价值堪忧。 用华尔街术语说，每笔交易都是一个仓位，跟你交往属于 " 交易仓位 " （ trading position ），一但价值下跌就要立即抛售，而不宜长期持有 — 也就是你想要的婚姻。听起来很残忍，但对一件会加速贬值的物资，明智的选择是租赁，而不是购入，年薪能超过 50 万的人，当然都不是傻瓜，因此我们只会跟你交往，但不会跟你结婚。所以我劝你不要苦苦寻找嫁给有钱人的秘方。顺便说一句，你倒可以想办法把自己变成年薪 50 万的人，这比碰到一个有钱的傻瓜的胜算要大。 希望我的回帖能对你有帮助。如果你对 " 租赁 " 感兴趣，请跟我联系。 "
—— 罗波 · 坎贝尔（ J.P. 摩根银行多种产业投资顾问） 转载于:https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abee1f5d3b93752d20a29f0da696ea0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b6bd7fb792d81822f81cce6dd4ca4b1/" rel="bookmark">
			MySQL Cursor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL Cursor
Summary: in this tutorial, you will learn how to use MySQL cursor in stored procedures to iterate through a result set returned by a SELECT statement.
Introduction to MySQL cursor To handle a result set inside a stored procedure, you use a cursor. A cursor allows you to iterate a set of rows returned by a query and process each row accordingly.
MySQL cursor is read-only, non-scrollable and asensitive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b6bd7fb792d81822f81cce6dd4ca4b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21668ca6124af52f05cb60b1f61a28d3/" rel="bookmark">
			Eclipse快捷键 10个最有用的快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.open-open.com/bbs/view/1320934157953/ Eclipse中10个最有用的快捷键组合 一个Eclipse骨灰级开发者总结了他认为最有用但又不太为人所知的快捷键组合。通过这些组合可以更加容易的浏览源代码，使得整体的开发效率和质量得到提升。 1. ctrl+shift+r：打开资源
这可能是所有快捷键组合中最省时间的了。这组快捷键可以让你打开你的工作区中任何一个文件，而你只需要按下文件名或mask名中的前几个字母，比如applic*.xml。美中不足的是这组快捷键并非在所有视图下都能用。
2. ctrl+o：快速outline
如果想要查看当前类的方法或某个特定方法，但又不想把代码拉上拉下，也不想使用查找功能的话，就用ctrl+o吧。它可以列出当前类中的所有方法及属性，你只需输入你想要查询的方法名，点击enter就能够直接跳转至你想去的位置。
3. ctrl+e：快速转换编辑器
这组快捷键将帮助你在打开的编辑器之间浏览。使用ctrl+page down或ctrl+page up可以浏览前后的选项卡，但是在很多文件打开的状态下，ctrl+e会更加有效率。
4. ctrl+2，L：为本地变量赋值
开发过程中，我常常先编写方法，如Calendar.getInstance()，然后通过ctrl+2快捷键将方法的计算结果赋值于一个本地变量之上。 这样我节省了输入类名，变量名以及导入声明的时间。Ctrl+F的效果类似，不过效果是把方法的计算结果赋值于类中的域。
5. alt+shift+r：重命名
重命名属性及方法在几年前还是个很麻烦的事，需要大量使用搜索及替换，以至于代码变得零零散散的。今天的Java IDE提供源码处理功能，Eclipse也是一样。现在，变量和方法的重命名变得十分简单，你会习惯于在每次出现更好替代名称的时候都做一次重命名。要使 用这个功能，将鼠标移动至属性名或方法名上，按下alt+shift+r，输入新名称并点击回车。就此完成。如果你重命名的是类中的一个属性，你可以点击alt+shift+r两次，这会呼叫出源码处理对话框，可以实现get及set方法的自动重命名。
6. alt+shift+l以及alt+shift+m：提取本地变量及方法
源码处理还包括从大块的代码中提取变量和方法的功能。比如，要从一个string创建一个常量，那么就选定文本并按下alt+shift+l即可。如果同 一个string在同一类中的别处出现，它会被自动替换。方法提取也是个非常方便的功能。将大方法分解成较小的、充分定义的方法会极大的减少复杂度，并提 升代码的可测试性。
7. shift+enter及ctrl+shift+enter
Shift+enter在当前行之下创建一个空白行，与光标是否在行末无关。Ctrl+shift+enter则在当前行之前插入空白行。
8. Alt+方向键
这也是个节省时间的法宝。这个组合将当前行的内容往上或下移动。在try/catch部分，这个快捷方式尤其好使。
9. ctrl+m
大显示屏幕能够提高工作效率是大家都知道的。Ctrl+m是编辑器窗口最大化的快捷键。
10. ctrl+.及ctrl+1：下一个错误及快速修改
ctrl+.将光标移动至当前文件中的下一个报错处或警告处。这组快捷键我一般与ctrl+1一并使用，即修改建议的快捷键。新版Eclipse的修改建 议做的很不错，可以帮你解决很多问题，如方法中的缺失参数，throw/catch exception，未执行的方法等等。
更多快捷键组合可在Eclipse按下ctrl+shift+L查看。
让我们按照使用频率来看看我最爱用的一些热键组合。（注：以下内容在Eclipse3.02及一上版本通过测试）
1. Control-Shift-T: 打开类型（Open type）。如果你不是有意磨洋工，还是忘记通过源码树（source tree）打开的方式吧。用eclipse很容易打开接口的实现类的，按ctrl+t会列出接口的实现类列表
2. Control-Shift-R: 打开资源（不只是用来寻找Java文件）。小提示：利用Navigator视图的黄色双向箭头按钮让你的编辑窗口和导航器相关联。这会让你打开的文件对应显示在导航器的层级结构中，这样便于组织信息。如果这影响了速度，就关掉它。
3. F3: 打开申明（Open declaration）。或者，利用Declaration Tab（在Java视图模式下，选择Windows --&gt; Show View -- &gt; Declaration）。当你选中代码中的一个方法，然后按这个按键，它会把整个方法在申明方框里显示出来。
4. Alt-left arrow: 在导航历史记录（Navigation History）中后退。就像Web浏览器的后退按钮一样，在利用F3跳转之后，特别有用。（用来返回原先编译的地方）
5. Alt-right arrow: 导航历史记录中向前。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21668ca6124af52f05cb60b1f61a28d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e47325de8326ed0b41c5d391d384ab/" rel="bookmark">
			HTML CSS——margin和padding的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.cnblogs.com/fengyv/p/3789333.html 你在学习margin和padding的时候是不是懵了，——什么他娘的内边距，什么他娘的外边距。呵呵呵，刚开始我也有点不理解，后来通过查资料学习总算弄明白了，现在我来谈一下自己对margin和padding的理解： 一、什么是边距
CSS中的边距指的是当前元素border与周围其它元素border的距离（或者称为空间）。
二、什么是内边距，什么是外边距
代码2-1：
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-type" content="text/html; charset=UTF-8" /&gt; &lt;style type="text/css"&gt; body{ margin:0px; } .test1{ width:150px; height:150px; border:6px solid red; } .test2{ margin-top:40px; padding-top:40px; width:150px; height:150px; border:6px solid gray; } .test2_son{ width:80px; height:50px; border:12px solid blue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test1"&gt;test1&lt;/div&gt; &lt;div class="test2"&gt; &lt;div class="test2_son"&gt;test2_son&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 图01 说明：图01中灰色地带是class值为test2的div的边框，它是有宽度的；
①、外边距：外边距指的是margin作用元素（这里是class值为test2的div）边框外延距离另一个元素边框外延（如果另一个元素和margin作用元素同级（这里是class值为test1的div））或内延（如果另一个元素是margin作用元素父级）的距离，如上图；
②、内边距：内边距指的是margin作用元素（这里是class值为test2的div）边框内延距离其子元素边框外延的距离，如上图；
③、内边距和外边距是针对于其作用的元素和其他元素来讲的，某一元素的内边距在另一个元素看来有可能是外边距，比如：class值为test2 div的内边距在class值为test2_test div元素看来就是外边距，所以上面代码也可以这样写：将class值为test2的div样式列表中“padding-top:40px;”去掉，class值为test2_test div元素添加“margin-top:40px;”——这样的效果和代码2-1是一样的；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2e47325de8326ed0b41c5d391d384ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecee0127ea790b7ccce60f12e46bd25d/" rel="bookmark">
			分享一下我在东方时尚学车的经历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		楼主是4月26日报的名，7月22日拿的本，不算快的，不过也不算慢的。和大多数简子们一样，楼主也是个苦比的白领一族，白天上班，大多数都是晚上去学车，每一次请个小假还得胆战心惊的看经理大大的脸色，各种苦不堪言。特别是世界杯那段时间，楼主是白天上班，晚上学车，夜里看球，害得最后白天走路都打飘~~
好了闲话不多扯了，接下来说一下关于在东方时尚学车的经历以及经验，也希望给后来的简子们一些帮助。
先说科目一。其实吧科目一在学车里面算是最简单的一项了，可惜楼主那段时间报名的正是高峰期（话说东方时尚任何时间段都是高峰期），楼主等了四十天才被安排去上法培课，煎熬程度可见一斑。好了说下科目一。科目一这个科目吧，说白了，也没什么值得好说的。最主要的是要多练，因为考试的一百道题目是从1000道题里面抽取的，平时有事没事的时候，大家也只能多练多做题。推荐大家去驾校一点通练习或者在手机上下载个APP下来，选择那个科目一模拟考试，很简单的，高端大气上档次说的就是这个。当然了，这里不得不提的是，有些同学会以为在家多练练就好了就忽略了法培课的重要性。这种认识是片面的，想当初楼主平时没事在公司练习的时候，发现一些东西总是出错，看了答案解析也总是记不住，特别是交警手势那些东西，楼主真是欲哭无泪，不过去听了一次法培课，瞬间感觉茅塞顿开，练习起科目一的题目起来更是得心应手。所以楼主个人建议，大家最好都去听听那个法培课，都是一帮年轻讲师讲的，很风趣幽默的。虽然大部分法培课老师都不会点名，但你去了绝对不会吃亏。而这里面我们驾校的法培课又分为了两种情况，一种是只上一天的，从早到晚，还有一种是三个半天的，建议大家最好都选择那个一天就完事的，天天都往这边跑也是很麻烦的。好了接下来正式讲一下科目一考试当天的情况，一般驾校都会提前三天把考试短信发到我们的手机上来，这里有必要提醒大家一下，大家最好临时把那些屏蔽功能给取消了，要不然把驾校短信也一起当作垃圾短信给屏蔽了那可就得不偿失了。科目一考试一般都是让你早上九点或者下午一点之前到达科目一备考大厅等待考试，就在学校大门口，842车站那边，上面都有大牌子表明的。所以大家到时也无需惊慌，抬起头来仔细瞅一瞅就看见了。考试之前都是老师在讲台上点名的，然后大家排队，按照现场工作人员的指示依次进入考试场地的。对了，考试的时候要带好身份证，要不然可是不会让大家参加考试的哦。进入考场里面，现场工作人员（就是穿着绿马甲的那些个）会给你指定位置，你只需听从他们的指示就好了。坐上作为后，仔细看一下电脑是否完好，例如黑屏之类，出现问题举手示意一下就好了，不要大声喧哗，否则遇上个别较真的工作人员会把你当作作弊处理的，那可就六月飞雪无处喊冤了。一般你举手后，工作人员马上就会过来帮你解决相关疑问的。正式考试的时候，电脑屏幕的右边位置会出现一个确定按钮，大家或手动或鼠标点击进入就好了，然后就是输入身份证号码，这里建议大家用鼠标输入，因为它那个九宫格键盘输入和我们平时使用的不大一样，怕大家手速快了会出现问题，鼠标输入则会很好的解决这些问题，因为当时你的注意力比较集中嘛。如果输入过程中不慎输错号码，可以点击一下那个回退按钮，这样输错的那个数字就会被删除。如果输入的身份证号码错的比较多的话，点击那个重置按钮就万事大吉了。确定好身份证信息过后，就会让你输入指纹，应该是右边的位置，大家按一下自己的指纹就好了，一般搁那红光位置停顿三秒钟左右就可以了。接下来答题的话，楼主也建议大家用鼠标输入，虽然说那个电脑屏幕是触屏的，但还是觉着鼠标点击起来比较保险。做题时间是45分钟，这是足够的，一般正常情况下10分钟左右就会完成的。因为时间充裕，大家做题目的时候，也不用太着急，慢慢来，反正世间多的是，心急可是吃不了热豆腐的哦（怎么办，瞬间感觉自己邪恶了！！！）。如果遇见不会做的或者不大确定的，可以先不做，直接点击下一题就好了。对了考试的时候那个题目做完了是要自己点击下一题接着做题的，不是自动翻页的，这有必要跟大家说一下，可别到时候傻傻的搁那干等着。如果题目做错的话，屏幕上会直接弹出一个对话框，也就是你做错的那题的详细答案解释，看一下就好了。这时候问题来了，这个窗口弹出来后，你千万不能惯性的去点击右上角窗口处那个X号，你要一点可就完了，电脑会直接黑屏重启，你之前所做的一切都是白搭。你只需要点击左下角位置处那个继续考试就好了，一般它会停留三秒钟的时间。做到最后一题也就是第100道题的时候，由于系统原因，你需要点击一下上一题，然后点击交卷就好了。他会直接弹出窗口告知你考了多少分，也就是考试合格了。因为之前如果这一百道题你错了11题，电脑屏幕会直接弹出一个窗口，告知你考试不合格。你这时千万不要沮丧，点击交卷就好了。然后坐着在那等第二次考试机会就好了。这里有必要提一下，这个第一和第二次考试中间的间隔时间是5分钟，因为电脑这时候要上传你第一次考试的成绩，你不用示意工作人员就直接坐在那台机器上等就好了。千万要等五分钟，否则电脑又会死机，后果你懂得，遇见态度不好的工作人员可是要招骂的。所以大家稍安勿躁，等五分钟就好了。考场里面没有钟表，手机也是不能往外拿的，他要是说你作弊，你可就倒霉了。不光之前所有成绩无效，还会被公安部给你拉上黑名单，一年之内任何驾校都是不会收留你的。所以手机或者驾校发的那个小白本千万别往外拿，自己没办法在心中默念300或者多几十秒就好了。总之等着吧，第二次考试流程也是和第一次一样的，所有信息都是要重新输入的。第二次考试的话，千万不要紧张，记住时间可是大大的充足啊。考试合格后，工作人员会让你从前门出去，直接在前门外边左右的位置找到签字台就好了，按照工作人员的指示签上自己的名字，这样科目一考试就完成了。完了过后你可以直接去约车大厅约车。到了约车大厅过后，你直接告诉客服说你不需要模拟训练让他直接给你取消就好了。模拟那个真是可有可无，鸡肋的很，就是一台机器跟我们平日在电玩城玩的赛车游戏机器差不多。真是幼稚的没话说，无力吐槽。想当初楼主小白一个，就约了，耽误了工作时间损失了一天的工资加整个月的800块钱全勤奖不说，去了那些教练就跟你说些开车常识，然后就在你的小黄本上唰唰直接签上他们的大名，然后就会说，如果大家有事的话可以提前回去，没事的……坑的我无话可说。
好了，接下来就要跟大家说说最麻烦也是大家最关心的科目二。科目二总的分为两大类，第一是24个小时的散段，第二是18个小时的桩训。而这里面最麻烦的便是这二十四小时的散段。为什么说麻烦呢，主要还是因为东方时尚的人数真是太多了，RT无力吐槽，周一到周五每天都有一千多个左右的人拿本，大家脑部一下什么概念。不得不提下楼主当年心酸的经历，约个车那可真是要死要活要人老命，那时你便会彻底明白捡漏这个词的最终奥义，你会发现RP（人品）是多么的重要。驾校虽然说是有电话约车，告诉大家那个不要想了，电话打进去过后，永远都会说客服繁忙，请你等待，那等待的过程可是直接与话费挂钩的。网上约车的时间是早上九点钟，而我们驾校的约车时间便是从每天的早九点到晚九点，其他时间一律say no。九点那会如果没有吊炸天的网速，你会发现自己当时的心情是多么无奈，多么的崩溃，卡个三四分钟你一刷新直接都是一大片空白，七天时间没有一天任何时段会有车。所以你这时候只能选择捡漏，捡漏这个吧，也有特定时间段每天上午十一点左右和下午三点左右晚上8点过后都是捡漏大发财时机。这里不得不提的是，网上约车刷新频率不能太快，要不驾校就会直接封了你的号，两小时之内禁止登录……这尼玛不坑爹麽，卧槽！！！接下来要说一下现场也就是预约大厅约车，早上七点正式开始约车。如果你选择七点左右到，那你可真是too young。一般七点钟的时候，那个排队的人群会直接站到842公交站牌边，问过一大姐，人家早上五点就来了，你可有那个魄力……而且这还不一定能约得到，虽然大家都会说这个东西好坑。当然了还有一个方法，大家来这约车没约到车的也别沮丧，在这静静的等一会儿，然后在九点钟过后，大家杀去预约大厅，这时候好多人都会因为临时有事把自己当天约的车给退掉，你这时候去等着，会直接约到当天的9点到下午1点这四个小时的时间段，简直High翻天。相信我，这没有错，这使我无数次在网上这个时间段印证出来的真理。而当楼主苦比的学完散段这个项目的时候，居然有个人跟我说，淘宝网居然能买到东方时尚的约车软件。楼主不信特意去搜了一下，天杀的，果然有，还只要15元钱，真是气得我差点一口老血喷出来。那么到这时候大家就有福了，哎，我当初怎么就不知道，无奈。散段这个学习过程嘛，其实也没嘛好说的，主要就是不停地在训练场跑大圈，为你后面的科目三考试打基础。这里要说一下教练的问题，我相信东方时尚大部分的教练都还是挺不错的，不过也有少数败类，这里我就不点名了，楼主就遇见过。气的楼主差点拿车撞大石头，反正撞坏了算他的，还好楼主是个有素养的人。这其中无非就是学些加减挡，半联动，靠边停车，定点停车和坡起，曲线行驶，侧方位停车，直角转弯之类。多的楼主就不讲了，楼主就讲一下科目二需要考的五大项里面的，而这其中包含的四大项。
第一侧方位停车：先调两个镜子，然车门后把手在镜子中间就可以了。起步前先开右灯，对准马路中间的白色箭头，开到距离白色箭头大概一个拳头位置停下，挂倒档，讲方向盘向右打死，半联动缓缓向后倒车。这时候要注意观察左边镜子，当库位的直角和镜子的玻璃左侧中间重合的时候，或者记住那个后门车把在直角位置，大概是向后三四十公分的样子，脚踩刹车停住。然后将方向盘向坐打死，半联动向后，慢慢倒车，注意观察镜子，车身与黄色实线平行就可以了。踩刹车，挂一档起步（注意任何时候都是一挡起步），打开左灯，向外开去就可以了。
第二定点停车和坡起：先打开右灯，注意所有考试项目一定要记得打灯，而且都是先右后左，不打灯考试的时候可是要减十分的。方向盘中间分割点位置对准马路上的白色箭头，一挡起步，然后松掉离合器。到达驾驶台右侧位置与坡上的杆子对齐的时候，踩一脚刹车，注意一定要松掉离合器到达杆子前面，半联动的话是爬不上来的，还有最容易熄火。在刹车的时候，要迅速的拉手刹，防止溜车，档位就不用退空档了，直接一挡。这时候难度就会来了，先把左灯打开，注意离合器和油门的配合。左脚慢慢松离合器，切记过快，右脚慢慢给油门注意观察发动机转速表，到了2000转左右的时候，放下手刹，松掉离合器，走起就可以了。注意考试的时候千万不要慌。
第三直角转弯：到达直角位置前，先打开右灯，方向盘中心分割点对准马路山的白色箭头，慢慢开，等到车头将前边马路盖住或者注意观察左前车门中心点位置也就是灰色和黑色那中间对准与左边的黄色实线对齐，打开左灯，方向盘向左打死，慢慢开出去就好了。
第四曲线行驶：曲线形势没什么好讲的。主要就是讲求速度慢，压好半联动，不要压到实线就可以了。没什么特别技巧，一个字，慢。楼主当初考科目二的时候，从下午一点等到下午五点，也就是最后一个，在前边听对讲机的时候，好多人都是栽在曲线这个项目上的。所以别看这个简单，但是越简单越容易越容易出错，大家平时训练的时候，一定要注意。
散段完了便是桩训，这个好约。这时候有必要提醒大家一声，最后越下午五点到晚上九点这个时间段的，有的人会错以为这时候视线不好，影响倒车入库。其实这是错误的，现在这天气晚上八点还不见得很黑。而且不得不跟大家提的是，东方时尚虽然分为2个小时训练时间和4个小时时间，他都是提前30分钟下课的。尤其是这四个小时的训练，他中途也会休息三十分钟的。所以你也就不要像许多了，听楼主这个过来人的没错。白天在进行桩训的时候可是不允许开空调的，说是容易炸锅，楼主也不是很懂。总之晚上很不错啦，天高气爽，到处都是大白腿。咳咳，跑题了。这个桩训也是分为两种情况的，第一种是三个人一车训练四个半天的，还有一种是两个人训练三个半天的，效果嘛，大家都懂得，楼主就是好人。这里虽然说是18个小时的桩训时间，但都不会练到那个时间的，楼主就是三个下午十二个小时就出师了这里不得不提下楼主的桩训教练，东区240的徐正祥教练，不光为人正派和蔼，技术更是没话说，简子们若碰上他可是有福了。桩训嘛说简单也简单，说难也难，最主要是要遇上一位负责人的好教练。楼主说下我对于桩训的一些经验。考试的时候，车子会停在右边。照例大家还是要调下镜子的，大家上车后挂一档先起步压过黄色实现过后，挂倒档，半联动向后倒车，注意观察左边镜子。退到左边镜子下沿位置与前方那条黄色实线平行重合的时候，一脚踩住刹车就可以了。方向盘向右打死，继续半联动控制好车速往后倒车，继续观察镜子，直到右边那个直角位置出现在右边镜子中大概有一本书的距离的时候，脚刹停车。方向盘回正，向后倒退三秒，方向盘继续向右打死，接着半联动控制好车速向后倒车，镜子中观察到车身与黄色实线平行后，将方向盘回正，继续向后慢推，直到完全入库。接着进行左侧倒库，挂一档起步，这里需要的是，倒车入库过程中千万不要挂空档，那样直接不合格。半联动起步后直到车头距离前边白色实线一个拳头位置处停下，然后将方向盘向坐打死，直到车身与黄色实线平行，然后方向盘回正，继续向前开，压过黄色实线。然后挂倒档，观察左边镜子，向后慢慢倒车，直到左边镜子下沿位置与地上的黄色实线平行重合，然后脚刹停住，方向盘向左打死，半联动控制好车速倒车，直到看见左边黄色直角位置出现在在镜子中间的，也就是一本书的大概宽度的时候，脚刹停车，方向盘回正向后倒退三秒，继续将方向盘向左打死，直到车身与车库黄色实线重合就可以了，然后就是方向盘回正，将车控制好车速慢慢往回倒就好了。注意千万不要撞着后面那个铁闸或者黄色实线。这样倒车入库就完成了，然后开出去将车摆正后，打开左灯出去。这也是科目二五大项之中的最后一项。科目二考试之前也会收到短信，考试当天按照指定时间到达指定备考大厅（科目二备考大厅在中心校区也就是停着超级多的车的对面那个位置，那边还有个天桥，考试的时候走路用的）等待现场工作人员点名就行了。这里提醒大家一下，最好是要早到，因为人真的是特别特别多，去玩了连站的地方都没有。最好去早点，坐到前边位置，因为那几个工作人员普遍声音特别特别小，娘娘腔的感觉，有木有~~最后跟大家说下科目二的注意事项，一号车道和二号车道最难，这是大部分人总结出来的，估计是那边教练比较严格，三四五六，尤其是第六车道简直不说了，你们都懂得。不过在一二车道的时候也不要紧张，去得早的话记得跟教练问好，考试的时候每一个项目只要看见教练都要跟教练举手示意一下，当然手可千万不要出车窗，那样可是直接不合格的。你也就是意思一下，大家都懂得。这里也就不详细表述了。相当重要一点的是，上车一定要系安全带，否则直接下车不合格。
最后说下科目三。科目二考完过后，大家再去科目二那边签完字过后（注意一定要去签字，不签字的话就直接视为不合格，没考过也要去签，只有那了那个表，你才能预约下一次考试），大家就可以去约车大厅约车科目三的八个小时的综合训练和四个小时的考前集训，这个都是很好约的，晚上约也很轻松。等正式参加科目三训练后，教练便就会带大家上马路或者考试场地（就是驾校前方那条大路奔着卢城那一带方向三千米），大家要注意听教练讲解或者传授方法，有什么不懂得一定要问，否则可就亏大发了，毕竟这都是马上要拿本的节奏了。貌似科目三考试都是拿伊兰特的，所以我在这里跟大家简单说下打灯的问题。这个考试的时候是要考的，往左边拧一下是位置灯，拧两下是近光灯，在这个位置往下推一下，便是远光灯位置，也就是大灯。夜路考试的遇见那个黄色三角牌子则需要闪三下，只用用手将那个杆向怀里位置来回拉三下就好了。对了说一下，科目三约的车是在南校区，不用进去学校大门，面对着大门朝着左手边走过去就行，那边停的车就是科目三训练的车。
接着正式说科目三考试，简子们有什么不懂得可以直接回复问我，楼主绝对么么哒。科目三考试去南边校区备考大厅备考，从那个大楼进去后，直接往里走，会看见一个科目三备考大厅进去等着就行。接着讲科目三考试，因为科目三考试上面的教官是公交驾校的，上车后一定要问好，要面带微笑，要低调，千万不要自以为是，不要装比，那样你会死的很惨的。双手递上你的身份证，微笑问好，因为科目三考试是两个人一车考试的，一个人开出去，一个人开回来。先开的那个人，上车前先逆时针绕车观察一周，然后上车，教练说不用你就不用观察一周了，反正是那么个意思。上车调整座位，调下镜子，系好安全带，一定要听教练口令，不能抢口令或者听错口令，没听清楚一定要问，要不你自作主张你直接会挂的。起步前，先打开左灯，将身子向后方倾斜一下，意思是看起步安不安全，后面有木有车。有的教练在起步前，会考你打灯。这个简单，大家学的时候一定要问教练。EndFragment
-----------------------
一、上坡起步
1、车盖的左经对准上坡时地上画的箭头的左侧往上开，这样确保右边车轮不压黄线，与之隔30厘米左右；
2、开到坡上，车头盖过前面地上的三根线后，马上看左侧，等地上的线快接近左侧车门开关后马上踩离合、踩刹车；
3、一定记得打灯；
4、慢慢松离合至车身抖动，才开始慢慢松刹车；
提示：
考场的车性能比较好，上坡不要完全松开离合，甚至可以带点刹车。
不要一下把离合松得太高，这样容易熄火。
二、直角转弯
1、车速一定要慢；
2、车头快盖住黄线，迅速打方向盘，转弯时离合稍稍抬高一点，确保车子不停。
三、曲线行驶
1、车速一定要慢，车才进入弯道时，车身左缝对左弯线；
2、车身在每个弯道须出去三分之一或一半，迅速打盘子；
3、最后出弯道时，方向盘要回一圈，再往确定的路线去行驶。
提示：考场的弯道较短，边上有一圈花坛，车进入弯道后，一直要让左边的经对准花坛的边沿，这样才能让车轮不压线。(我们这里是这样的，各地特点可能不一样，自己观察总结)
四、大倒库
1、停车时一定要看左边车身距离与地面线大至1.5——2米；
2、倒车时左后视镜挡住地上的黄线后马上将方向盘往右打死；
3、从左右后视镜中看库与后车轮的宽窄来灵活地修方向盘，原则是哪边宽方向盘则往哪边修；
4、车身与库快平行时，方向盘马上回正，继续从左右后视镜中看库边线与车轮的宽窄来灵活地修方向盘；
5、倒退时看到左前库线被左后视镜挡住，则停车。
提示：
在进行大倒库时一定要检查左右两边的后视镜是否调好，要从镜中能看到车前门把手正好在镜中间位置为最佳。
在后退中，修完方向盘要马上将方向盘朝右或左库的方向打死，这样在车身平行时才能做到准确地将方向盘回正。
五、侧方位停车
1、车身前进时看车窗雨刷第二节处对准地上的黄线开过去，(右边地上的线离车右轮要很近，但不能压线)看到右边地上的车库角在右后视镜中出现就马上停车；
2、倒车，看右后视镜中库角快消失时，赶快将方向盘往右打死；
3、看左边后视镜中，库底线出现三分之二时，方向盘往左回正；
4、坐直身子看左后轮快压线时，方向盘往左打死；
5、看车身左经对准库内侧黄线时马上停车；
6、出库时必须先挂前进档再打灯。
提示：
为了能更好地观察左后视镜中库底的情况，建议在倒车前先将左侧的后视镜调到最高，这样才能更及时地看到左边库底线的出现。
其实最大的诀窍就是车速一定要放慢，最好时刻带点刹车，然后保持心态平稳(心态平稳非常重要)！
最后，祝大家考试顺利！一次过关！
转载于:https://www.cnblogs.com/kungfupanda/p/4423635.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b06f3eee3a8c8f10a88becdd5aaa8f3/" rel="bookmark">
			超能陆战队：迪士尼画风的漫威英雄
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.hjenglish.com/new/p718262/My little friend Seth, who is eight, pronounces this the best film he has ever seen. 我八岁的小伙伴，赛斯，声称这是他看过的最棒的电影。 And certainly, Disney have come up with a memorable superhero, in the highly improbable form of Baymax, a huge robot who is like the Michelin Man crossed with Florence Nightingale — a caring, sharing blob. 确实，迪士尼创造了一个有纪念意义的超级英雄，虽然它的机器人Baymax造型颇为匪夷所思，像是米其林品牌卡通形象和南丁格尔的合体——一个圆滚滚的，善解人意，乐于助人的大个子。 His human accomplice in the inevitable fight against evil is Hiro, a 14-year-old electronics prodigy, whose brother, Tadashi, bequeaths him Baymax after dying in a suspicious laboratory fire.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b06f3eee3a8c8f10a88becdd5aaa8f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f70433dc095a94ab7cab0620f7a0ed31/" rel="bookmark">
			html禁止清除input文本输入缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多数浏览器默认会缓存input的值，只有使用ctl+F5强制刷新的才可以清除缓存记录。 如果不想让浏览器缓存input的值，有2种方法：
方法一： 在不想使用缓存的input中添加 autocomplete="off"; eg: &lt;input type="text" autocomplete="off" name="test" /&gt;
方法二： 在 input 所在的form标签中添加 autocomplete="off"; eg:
&lt;form action="#" autocomplete="off"&gt;
&lt;input type="text" autocomplete="off" name="test" /&gt;
&lt;/form&gt;
转载于:https://www.cnblogs.com/kungfupanda/p/4077249.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a29ff268aae27b681f87a720f8ad7c/" rel="bookmark">
			dhcpd.conf(5) - Linux man page
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://linux.die.net/man/5/dhcpd.conf Name dhcpd.conf - dhcpd configuration file
Description The dhcpd.conf file contains configuration information for dhcpd, the Internet Systems Consortium DHCP Server.
The dhcpd.conf file is a free-form ASCII text file. It is parsed by the recursive-descent parser built into dhcpd. The file may contain extra tabs and newlines for formatting purposes. Keywords in the file are case-insensitive. Comments may be placed anywhere within the file (except within quotes). Comments begin with the # character and end at the end of the line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40a29ff268aae27b681f87a720f8ad7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f4dd122acc7d5ee739922c956a5419/" rel="bookmark">
			BusinessObject Port 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BO Port 고정
CMS Default : 6400, CMS 수신: 6411(고정)
Input FRS : 6415(고정)
Output FRS : 6416(고정)
转载于:https://www.cnblogs.com/kevinkim/archive/2011/05/10/2042527.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/217c69f7de459890ea3beb47f3fb9d9e/" rel="bookmark">
			前端工程师王者之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端工程师王者之路 战争背景等级设置等级解读 战争背景 随着IT行业就业人数的不断增加，前端岗位竞争力明显加大，各路大侠开始围绕不多的高薪职位展开厮杀。索性我们在这里给大家提供一份通关秘籍，帮助大家披荆斩棘，速上荣耀王者。【我们的口号是：拒绝当小兵！！】
等级设置 我们这里共设有八个阶段：
1、【倔强青铜】（JavaScript基础阶段）
2、【秩序白银】（JavaScript语言进阶）
3、【荣耀黄金】（HTML和CSS）
4、【尊贵铂金】（前端框架）
5、【永恒钻石】（前端工程化）
6、【至尊星耀】（性能优化）
7、【最强王者】（编程思维和算法 )
8、【荣耀王者】 ( 网络知识 )
分别对应前端成长过程中的八大阶段。每个阶段会分不同的小等级。每一个阶段的文章，我们会分到对应的文章分类当中。
等级解读 前三阶段：我们会着重介绍this、闭包、作用域、执行上下文、面向对象、原型与原型链、异步（Promise），ES演进
铂金阶段：着重介绍React如何学习。不仅仅停留在会用，更懂它的设计原理和思想演进。站在巨人的肩膀上看问题
钻石阶段：资深斗士的必经之路—项目架构。结合webpack，还原一线战场
星耀阶段：学习大量理论知识包括缓存、线程、浏览器渲染、Chrome DevTool火焰图、防抖与节流、资源合并与拆分等等
王者阶段：了解最基本的算法知识，使用JS来描述多种设计模式。
荣耀王者：探索互联网传输的奥秘，了解网络细节以及前后端写作等核心环节。
好了，让光法师把你们传送入战场吧~ E=MC2 ~~~~~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/484a0ddd7a4d24a7424b084d4a4786ec/" rel="bookmark">
			golang 长连接web socket原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.原理 WebSocket协议用ws表示。此外，还有wss协议，表示加密的WebSocket协议，对应HTTPs协议。
完成握手以后，WebSocket协议就在TCP协议之上，开始传送数据
websocket原理及运行机制
WebSocket是HTML5下一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。它与HTTP一样通过已建立的TCP连接来传输数据，但是它和HTTP最大不同是：WebSocket是一种双向通信协议。在建立连接后，WebSocket服务器端和客户端都能主动向对方发送或接收数据，就像Socket一样；WebSocket需要像TCP一样，先建立连接，连接成功后才能相互通信。传统HTTP客户端与服务器请求响应模式如下图所示：
WebSocket模式客户端与服务器请求响应模式如下图：
上图对比可以看出，==相对于传统HTTP每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket是类似Socket的TCP长连接通讯模式。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求==。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。
2.特点 相比HTTP长连接，WebSocket有以下特点：
是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。
Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据，这显然和原有的HTTP协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持HTML5）。
此外还有 multiplexing、不同的URL可以复用同一个WebSocket连接等功能。这些都是HTTP长连接不能做到的。
连接建立后定期的心跳检测
3.数据格式 在客户端，new WebSocket实例化一个新的WebSocket客户端对象，请求类似 ws://yourdomain:port/path的服务端WebSocket URL，客户端WebSocket对象会自动解析并识别为WebSocket请求，并连接服务端端口，执行双方握手过程，客户端发送数据格式类似：
GET /webfin/websocket/ HTTP/1.1
Host: localhost
可以看到，客户端发起的WebSocket连接报文类似传统HTTP报文
Connection: Upgrade
Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==
Origin: http://localhost:8080
Sec-WebSocket-Version: 13
可以看到，客户端发起的WebSocket连接报文类似传统HTTP报文
Upgrade：websocket参数值表明这是WebSocket类型请求，Sec-WebSocket-Key是WebSocket客户端发送的一个 base64编码的密文，要求服务端必须返回一个对应加密的Sec-WebSocket-Accept应答，否则客户端会抛出Error during WebSocket handshake错误，并关闭连接。 Upgrade: websocket
Connection: Upgrade
这个就是Websocket的核心了，告诉Apache、Nginx等服务器进行协议转换
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 首先，Sec-WebSocket-Key 是一个Base64 encode的值，这个是浏览器随机生成的，告诉服务器验证websocket协议。
然后，Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。
服务端收到报文后返回的数据格式类似：
HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8= Sec-WebSocket-Accept 的值是服务端采用与客户端一致的密钥计算出来后返回客户端的。
HTTP/1.1 101 Switching Protocols表示服务端接受WebSocket协议的客户端连接，经过这样的请求-响应处理后，两端的WebSocket连接握手成功, 后续就可以进行TCP通讯了。用户可以查阅WebSocket协议栈了解WebSocket客户端和服务端更详细的交互数据格式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/484a0ddd7a4d24a7424b084d4a4786ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a305f2bd0442e234156e5bd92800332b/" rel="bookmark">
			Ubuntu中一些好用的软件推荐以及安装方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 好记性不如烂笔头,好多手写在笔记本上的知识点、技巧都因为记录载体的丢失而丢失了,(来回搬家,东西不好带),用网络做一个备份应该会比较合适,这个系列挺多挺杂的,好多都是不知道什么时候从哪个地方摘抄下来的,权当知识点回顾了,那么下面就开始吧
XMind 1.官方下载地址
http://www.xmid.net/download/linux 2.下载完成后解压到指定目录下
mkdir XXX unzip xmind-8-update7-Linux.zip -d XXX chmod -R 777 XXX 3.安装相关依赖,在解压目录下执行
./setup.sh 4.运行程序
安装目录下有两个可执行的,一个是32位,一个是64位,运行对应目录下的Xmind即可
搜狗输入法 因为Ubuntu自带的输入法实在是太难用了!!!
1.去搜狗输入法的官网下载Linux系统的版本
http://pinyin.sougou.com/linux/ 记住自己下载的文件
2.找到文件然后在终端执行
sudo dpkg -i sougoupinyin_2.1.0.0082_amd64.deb 发现并没有安装成功,不要着急,看下错误提示,有什么依赖没有安装
关于 fcitx 的一些东西,fcitx是一个输入法系统(输入法系统还有ibus系统,一般默认的是这个),搜狗是基于这个系统的,所以我们还需要把这个fcitx搞定
(1) 先添加以下源
sudo add-apt-repository ppa:fcitx-team/nightly (2) 添加源后,更新一下系统
sudo apt-get update (3) 开始安装fcitx
sudo apt-get install fcitx 发现又有错误提示,但是告诉我们尝试
apt-get -f install 然后再进行fcitx的安装,好了成功
(4) 安装fcitx的配置工具
sudo apt-get install fcitx-config-gtk (5) 安装fcitx的table-all bao
sudo apt-get install fcitx-table-all (6) 安装im-switch 工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a305f2bd0442e234156e5bd92800332b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47cbc53df9ff06e71d5219b635ed6b80/" rel="bookmark">
			python logging通过json文件配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python logging通过json文件配置 logconfig.jsonlog_utility.py调用 logconfig.json { "version":1, "disable_existing_loggers":false, "formatters":{ "simple":{ "format":"[%(asctime)s - %(levelname)s - line(%(lineno)d) - %(filename)s]: %(message)s", "datefmt":"%Y-%m-%d %H:%M:%S" } }, "handlers":{ "console":{ "class":"logging.StreamHandler", "level":"DEBUG", "formatter":"simple", "stream":"ext://sys.stdout" }, "info_file_handler":{ "class":"logging.handlers.TimedRotatingFileHandler", "level":"INFO", "formatter":"simple", "filename":"../log/info.log", "when":"H", "interval":1, "backupCount":50, "encoding":"utf8" }, "error_file_handler":{ "class":"logging.handlers.TimedRotatingFileHandler", "level":"ERROR", "formatter":"simple", "filename":"../log/errors.log", "when":"H", "interval":1, "backupCount":50, "encoding":"utf8" } }, "loggers":{ "my_module":{ "level":"ERROR", "handlers":["info_file_handler"], "propagate":"no" } }, "root":{ "level":"INFO", "handlers":["console","info_file_handler","error_file_handler"] } } log_utility.py import os import json import logging import logging.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47cbc53df9ff06e71d5219b635ed6b80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a749fef99b60bccb6f6cce4395fc67a3/" rel="bookmark">
			swiper 自定义左右箭头样式 将箭头移出容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键点：
1.在".swiper-container"外层套一个父级容器“.swiper-father”，并让其position：relative；
2.重点：箭头相关的两行代码，要从“.swiper-container”移出来，放在“.swiper-father”下
css代码：
.swiper-father { position: relative; padding:0 37px; width: 100%; box-sizing:border-box; border:1px solid red; } .swiper-father .swiper-button-next,.swiper-father .swiper-button-prev { width: 37px; height: 108px; text-align: center; display: block; margin-top: -54px; } .swiper-father .swiper-button-prev { background: #fafafa url("../public/images/swiper-left.png") no-repeat center center; left:0 } .swiper-father .swiper-button-next { background: #fafafa url("../public/images/swiper-right.png") no-repeat center center; right:0 } .swiper-container { width:calc(100% - 30px); margin:auto; } .swiper-slide { height: 120px; width: 100%; box-sizing: border-box; border:1px solid #f00; } html代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a749fef99b60bccb6f6cce4395fc67a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb6f639aa65d67e63589d327def4d2c/" rel="bookmark">
			【Linux】一文搞定E: Could not get lock /var/cache/apt/archives/lock安装Git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		折腾了一个晚上，终于解决了给开分区新装的Ubuntu系统装Git，记录如下
打开terminal，按照以下步骤操作
【预备】
sudo su # 输入密码，进入root 【第一步】
依次输入以下5条指令
sudo killall apt-get sudo rm /var/lib/apt/lists/lock sudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock sudo dpkg --configure -a 【第二步】
cp /etc/apt/sources.list /etc/apt/sources.list.copy # 备份镜像配置文件，准备切换到阿里云国内镜像 # 某些原因导致国外的镜像不稳定，部分资源直接无法安装 gedit /etc/apt/sources.list 然后将以下内容拷贝并替换sources.list中的原内容，点击Save保存文件
# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties deb http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeb6f639aa65d67e63589d327def4d2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96de34644fa6a9b100914a25f702b409/" rel="bookmark">
			ubuntu下swap分区 boot分区 概念理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是个人在网络搜集到的较为容易理解的解释，若有不对或缺少之处，欢迎评论区纠正及补充，共同学习进步。谢谢！
swap是linux下的虚拟内存分区，作用是在物理内存使用完成之后，将磁盘空间（也即swap分区）虚拟成内存来使用。
swap和windows系统的交换文件作用类似，但是它是一段连续的磁盘空间，并且对用户不可见。
swap分区能够作为“虚拟”的内存，但其速度比物理内存慢，因此若需要更快的速度的话，并不能寄厚望于swap，最好的办法是加大物理内存，swap分区只是临时的解决办法。
swap分区的合理值一般是内存的2倍左右，可适当加大。实际上具体以实际应用为准。
linux可以创建两种类型的交换空间，一种是swap分区，一种是swap文件。前者适合有空闲的分区可以使用，后者适合于没有空的硬盘分区，硬盘的空间都已经分配完毕。
linux是一个树形文件系统，根分区是它的root节点，任何的目录，文件都会挂在根节点一下。swap分区是一个遗留，在原来内存比较小，不能满足需要。当内存资源不足的时候，linux就会把一些短期内不会用到的内存数据转储到磁盘上，以空出足够的空间。现在swap分区存在，但是实际上会很少使用到。不排除当启动内存消耗比较大的程序的时候，会使用它。现在swap分区还有一个用处，就是sleep on disk ，sleep可以在memory上也可以在disk。当在disk上时，也可以指定为swap分区。
boot 分区
早期为什么会分单独的boot分区？
在2000年左右那会儿，硬盘容量快速发展（实际上也就10G、20G），但是一部分旧式的BIOS还不支持LBA模式，不支持引导距离MBR太远的硬盘分区，现在的小朋友们根本无法想象吧！当时的 Linux 还是极少数 GNU 爱好者的玩具，一般都是作为第二系统和 Windows 共存，而且Linux在硬盘中的位置大都靠后。有时候因为安装的根分区距离MBR太远无法引导，于是流行在 C: 盘后面紧跟着建立一个100、200M的 “/boot” 分区，以防无法启动。
在现在的硬件条件下，完全没有必要划分boot分区，那只会带来麻烦，容量如果太小，会使你无法安装、升级新内核。现在实际上只需要一个根分区挂在“/”，一个HOME分区挂在“/home”，连 swap 分区都可有可无，因为完全可以用 swapfile 代替。
单独的HOME分区是为了保护你的个人文件安全，防止系统崩溃时丢失文件。
如果只是尝鲜的，只分一个30G的/分区就可以了，如果准备长期用的，应该单独分HOME分区，保护个人数据安全
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/473/">«</a>
	<span class="pagination__item pagination__item--current">474/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/475/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>