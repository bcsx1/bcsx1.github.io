<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971aacc38bb5509b6593cc7359767864/" rel="bookmark">
			WinFrom，C#.NET开源实战——用户登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本专栏的前面几篇博客中我们了解了WIn From的基本结构和基本原理，本篇博客我将开始介绍实战项目，今天就来开发第一个项目——用户登陆界面。
目录
直接上效果图
首先创建一个窗体项目，打开VS，新建项目
控件的添加：
控件属性设置：
该项目的窗体完整代码如下
直接上效果图 首先创建一个窗体项目，打开VS，新建项目 控件的添加： 点击“视图”—“工具箱”在控件工具箱中拖拽2个Button控件，2个label控件，2个Textbox控件到From1窗体中，根据效果图调整好每个控件的布局，大小
控件属性设置： 又击各个控件点击属性和窗体为其添加属性值（因为属性值比较多，大家可以仔细找一下）
窗体和控件属性属性值From1TextQQ(可以是你想的任意字符串)label1Text用户名 label2
Text密码textBox1NametxtNametextBox2NametxtpasswordUseSyteamPasswordCharTurebutton1NamebtnLoginText登录button2NamebtnResetText重置 这个时候我们的窗体应用就有雏形了
窗体设计好了之后现在开始添加控件的事件：
双击登录按钮将以下代码添加到函数private void btnLogin_Click(object sender, EventArgs e)下
if (txtName.Text == "3139423588" &amp;&amp; txtPassword.Text == "dbjl991029.") { MessageBox.Show("登录成功"); } else { MessageBox.Show("用户名或密码错误"); }//txtName.Text == 用来判断用户名的值 //txtPassword.Text == 判断密码的值 双击重置按钮将以下代码添加到函数private void btnreset_Click(object sender, EventArgs e)下
foreach (Control item in this.Controls) { if (item is TextBox) { item.Text = ""; } } 运行程序就完成了该项目的开发。 该项目的窗体完整代码如下 using System; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/971aacc38bb5509b6593cc7359767864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c718d1a3e68da27c5391210708f33d51/" rel="bookmark">
			用sklearn进行PCA降维——基于python语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. sklearn的PCA类 在sklearn中，与PCA相关的类都在sklearn.decomposition包中，主要有：
sklearn.decomposition.PCA
最常用的PCA类，接下来会在2中详细讲解。KernelPCA类，主要用于非线性数据的降维，需要用到核技巧。因此在使用的时候需要选择合适的核函数并对核函数的参数进行调参。IncrementalPCA类，主要解决单机内存限制。有时候样本量可能是上百万，维度可能也是上千，直接拟合数据可能会让内存爆掉， 此时可以用IncrementalPCA类来解决这个问题。IncrementalPCA先将数据分成多个batch，然后对每个batch依次递增调用partial_fit函数，这样一步步的得到最终的样本最优降维。SparsePCA和MiniBatchSparsePCA。二者和其他PCA类的区别主要是使用了L1正则化，这样可以将很多非主要成分的影响度降为0，这样在PCA降维的时候仅仅需要对那些相对比较主要的成分进行PCA降维，避免了噪声对PCA降维的影响。
SparsePCA和MiniBatchSparsePCA二者之间的区别是MiniBatchSparsePCA通过使用一部分样本特征和给定的迭代次数来进行PCA降维，以解决在大样本时特征分解过慢的问题，当然，代价就是PCA降维的精确度可能会降低。
使用SparsePCA和MiniBatchSparsePCA需要对L1正则化参数进行调参。 2.sklearn.decomposition.PCA PCA类基本不需要调参，只需给出需要降维到的维度，或者希望降维后的主成分的方差和占原始维度所有特征方差和的比例阈值就可以了。
sklearn.decomposition.PCA的主要方法及其参数如下：
PCA方法：新建一个pca对象时必用方法，主要参数有n_components：指定希望PCA降维后的特征维度数目，默认值为min(样本数，特征数)，三种常用设置。
第一种，直接指定降维到的维度数，此时n_components是一个大于等于1的整数；
第二种，指定主成分的方差和所占的最小比例阈值，PCA类自己根据样本特征方差来决定降维到的维度数，此时n_components是一个（0，1]之间的小数；
第三种，设置为"mle", 此时PCA类会用MLE算法根据特征的方差分布情况自己去选择一定数量的主成分特征来降维。
copy:类型：bool，默认为True。表示是否在运行算法时，将原始训练数据复制一份。若为True，则在原始数据的副本上运行PCA算法，原始训练数据的值不会有任何改变；若为False，在原始数据上运行PCA算法，原始训练数据的值会改。
whiten ：判断是否进行白化。默认值是False，即不进行白化。所谓白化，就是对降维后的数据的每个特征进行归一化，让方差都为1。对于PCA降维本身来说，一般不需要白化。如果降维后有后续的数据处理动作，可以考虑白化。
svd_solver：即指定奇异值分解SVD的方法，由于特征分解是奇异值分解SVD的一个特例，一般的PCA库都是基于SVD实现的。有4个可以选择的值：{‘auto’, ‘full’, ‘arpack’, ‘randomized’}。randomized一般适用于数据量大，数据维度多同时主成分数目比例又较低的PCA降维，它使用了一些加快SVD的随机算法。 full则是传统意义上的SVD，使用了scipy库对应的实现。arpack和randomized的适用场景类似，区别是randomized使用的是scikit-learn自己的SVD实现，而arpack直接使用了scipy库的sparse SVD实现。默认是auto，即PCA类会自己去在前面讲到的三种算法里面去权衡，选择一个合适的SVD算法来降维。一般来说，使用默认值就够了。fit_transform()方法，传入的参数为需要降维的numpy.ndarray数组，并返回降维后的数据，降维后的数据与原数据不可能一一对应，比如一个4维的数据，降到2维后，这里的2维并不是原来4维中的某2个维度，而是4个维度综合起来得到的2个维度。inverse_transform()方法，传入的参数为降维后的数据，返回原始数据，很多时候转换回去的原始数据都有偏差。explained_variance_方法，返回主成分的贡献率，代表降维后的各主成分的方差贡献绝对值。方差值越大，越是重要的主成分。explained_variance_ratio_方法，返回降维后的各主成分的方差贡献占比，比例越大，越是重要的主成分。 3.实例 本代码基于python3.7，编译器是pycharm，亲测没问题。
import numpy as np from sklearn.decomposition import PCA # PCA步骤：对原始数据零均值化，求协方差矩阵，对协方差矩阵求特征向量和特征值，特征向量组成了新的特征空间 X = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]]) pca = PCA(n_components=1) # 把二维的原数据降成一维 newX = pca.fit_transform(X) #把原数据X传入方法，返回降维后的数据，等价于pca.fit(X) pca.transform(X) invX = pca.inverse_transform(newX) #将降维后的数据转换成原始数据 print(X) print(newX) print(invX) print(pca.explained_variance_ratio_) # 返回保留的n个成分各自的方差贡献比 运行结果： print(X):原数据 [[-1 -1] [-2 -1] [-3 -2] [ 1 1] [ 2 1] [ 3 2]] print(newX)：降维后的数据 [[ 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c718d1a3e68da27c5391210708f33d51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac608b94b700dd4c91d346f1fa452cc/" rel="bookmark">
			练习题【C&amp;java】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接受一个整型值（无符号），按照顺序打印它的每一位。
例如：
输入：1234，输出 1 2 3 4
void print(int n) { if (n &lt;= 9) { printf("%d ", n); return; } else { print(n / 10); printf("%d ", n % 10); } } int main() { int n = 0; scanf("%d", &amp;n); print(n); return 0; } 编写函数不允许创建临时变量，求字符串的长度。
#include&lt;stdio.h&gt; #include&lt;assert.h&gt; int my_strlen(const char* arr) { assert(arr); const char* ret = arr; if (*ret == '') { return 0; } else { ret++; return 1 + my_strlen(ret); } } int main() { char arr[] = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ac608b94b700dd4c91d346f1fa452cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b8059508cbf826a66a982fb4ecf6fbf/" rel="bookmark">
			Flask之多个应用接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考资料
(211条消息) Python-flask同时启动两个端口服务-2021.10.27_孔胖的博客-CSDN博客_flask多端口
(211条消息) python flask多个app应用组合_weixin_30515513的博客-CSDN博客
python flask多个app应用组合 - 北风之神0509 - 博客园 (cnblogs.com) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8134e25d95bde407ea1fcf5335ecbcaa/" rel="bookmark">
			CSS3的变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：认识css3自定义属性
在需要的作用域中定义变量(在任意的全局css文件或者style中定义即可)，如：
//:root作用于全局 :root{ --theme-color:red; // 这里定义了一个--theme-color变量， 值为black } //#app作用于id为app的节点内 #app{ --theme-back-color: black; // 这里定义了一个--theme-back-color变量，值为black } 使用方式：1.在css中使用，如：在.title中使用：
.title{ color: var(--theme-color) } 使用方式：2.在js中使用，如：
// document.documentElement 代表相关的容器如：#box //js中获取--theme-color的值 var value = getComputedStyle(document.documentElement).getPropertyValue("--theme-color"); //js中更改--theme-color的值 document.documentElement.style.setProperty("--theme-color","black"); 优点：只需一套CSS文件； 换肤不需要延迟等候；对浏览器性能要求低；可自动适配多种主题色；
缺点： 兼容性问题、不支持IE， 2016年前的chrome，safari;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c29ea7fd912ae2e1a4f6cbe8addcf5e4/" rel="bookmark">
			Node.js 安装配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载 查询Node.js 中文网即可下载，速度比较快。
https://nodejs.org/zh-cn/
下载最新版本即可，也可按需求下载历史版本。
二、安装 默认下一步即可。
三、测试是否安装成功 控制台输入以下命令：
node -v 控制台打印所安装 Node.js 版本即代表安装成功。
四、配置 npm 使用淘宝镜像 以提高下载速度
npm config set registry http://registry.npm.taobao.org/ 五、VsCode使用 npm 1、打开项目使用 npm 初始化
VsCode终端运行以下命令：
npm install ① 若提示 npm 命令不能用，以管理员身份打开项目，再执行即可解决
② 如果 npm install 安装依赖出现 chromedriver 之类问题，先在项目里运行下面命令 npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver 然后再运行 npm install
2、启动项目
VsCode终端运行以下命令：
npm run dev ① 若报错
Node Sass could not find a binding for your current environment: Windows 64-bit with Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c29ea7fd912ae2e1a4f6cbe8addcf5e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25a7f38d0e82a7709f4b0ec5a508080f/" rel="bookmark">
			JavaScript基本知识总结(全)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一,什么是JS
JS是JavaScript的简称，这是一门最流行的运行在浏览器的脚本语言。
JavaScript 与 Java 是两种完全不同的语言，无论在概念还是设计上。
JS是一种轻量级的编程语言，可由所有的现代浏览器执行
二,JS的作用
DOM操作: 增删改查HTML元素 可以直接操作HMTL
动效: 可以通过JS完成各种动效 让网页动起来
交互: 让用户和网页形成交互 (点击、滑动、拖拽等)
三,JS嵌入页面的方式有三种
1、行间事件（主要用于事件）:
&lt;input type="button" name="" onclick="alert('ok！');"&gt;
2、页面script标签嵌入:
在当前网页的script标签对之间编写
script 标签对可以放在body或head中,或者同时存在于两个部分中
标签对代表JS在何处开始和结束 &lt;script type="text/javascript"&gt; alert('ok！'); &lt;/script&gt; 3、外部引入
把脚本保存到外部.js后缀文件中。外部文件通常包含被多个网页使用的代码
使用外部文件，请在script标签的 “src” 属性中设置该 .js 文件
&lt;script type="text/javascript" src="js/index.js"&gt;&lt;/script&gt;
在head和body引入文件都可以，外部脚本不能包含script标签
注意: 用了外部样式，就不要再用页内样式，不会执行
四,JS基本语法
1、输出弹出框
document.write()
仅仅向文档输写内容
如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖
alert(“hello world !”)
弹出框会停止代码往下执行，当点击确定之后才继续执行
2、分号
分号用于分隔 JavaScript 语句 通常我们在每条可执行的语句结尾添加分号。
使用分号的另一用处是在一行中编写多条语句（一行中编写多条语句必须使用分号）
3、JS对大小写是敏感的
4、JS会忽略多余的空格
5、可以在文本字符串中使用反斜杠对代码行进行换行
document.write("Hello \ World!"); 不过不能这样换行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25a7f38d0e82a7709f4b0ec5a508080f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da15350070fe723c825899f94b7de7bf/" rel="bookmark">
			Altium Designer(AD)的简易使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、绘制原理图、原理图库
首先来说明原理图的概念。
根据百度百科，原理图，顾名思义就是表示电路板上各器件之间连接原理的图表。也就是表示芯片上的引脚连接什么元件，各个元件谁和谁相连，电源电压的大小之类的。
​
再来说一下原理图和原理图库的区别和联系。
原理图是某个产品的原理图设计文件；原理图库是设计原理图时用到的电子元件的电路符号的集合。绘制PCB板时先设计原理图即建立原理图文件，而在原理图文件中设计原理图前必须将原理图库文件加载到原理图编辑环境才能使用其中的电路符号。
接下来说明如何做原理图库。
建立：首先打开AD软件，单击左上角的File-&gt;New-&gt;Library-&gt;schematic library ​
​
改名字：左上角工具栏 Tools-&gt;Rename Component
​
放引脚：左上角工具栏Place-&gt;Pin
要点：没有数字的一端是连接端；在不放下的时候按空格键顺时针旋转，按X键水平转换；双击引脚可以更改引脚属性（长度等）。​
放芯片主体：左上角工具栏Place-&gt;Rectangle；覆盖之后，左上角工具栏Edit-&gt;Move-&gt;Send To Back,再点击黄色长方形，就让下面的字在上面了。
设置缺省名称和默认注释。
双击左侧Component，进行修改。
在这个原理库中再建一个元件：
左上角工具栏 Tools-&gt;New Component
原理图库元件的封装：
将等待封装的原理图元件和封装图放在一个工程下。
回到MP2359原理图库，双击左侧MP2359，点击右下方Add...,选择需要的PCB图。
最后保存就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/713f95b5832bcf51314f1ae3e4711c96/" rel="bookmark">
			HTML5网页小游戏（HTML5、CSS、JS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏页面：
主要代码：
下载链接：https://download.csdn.net/download/weixin_49861340/85020269
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ad9136c142c3b589be681e43c1b0386/" rel="bookmark">
			本文来探讨java 1.8开始的lamda(λ)表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		λ表达式是什么呢？ java是面向对象的语言。什么都是对象，对象是类的实例（通过类new出来的）。这样做的好处就是用面向对象的思想来写代码。
但是，大家写程序的时候，往往是写一个方法然后去执行这个方，面向对象的处理的步骤就显得繁锁。步骤如下：
1.定义一个类。2在类里写对应的方法。3.调用这个类的方法（如果是静态方法，直接 类名.method;如果非静态方法，还需要new一个对象）
上面三个步骤是针对类里面的方法来说的。如果是接口里面的方法。本来接口是不能new的。但是java为了简化上面的步骤，new 接口，就相当于创建了一个匿名类。因此可以省略步骤1.
举几个例子如下：
1.线程的创建。Thread 的构造方法中需要传入一个Runnable接口。
利用接口创建Thread,代码如下：
Thread thread = new Thread(new Runnable() { @Override public void run() { while(true){ System.out.println("线程在运行中"); } } }); thread.start(); 利用λ表达式创建Thread，代码如下：
Thread thread = new Thread(()-&gt;{while(true){ System.out.println("线程在运行中"); }}); thread.start(); 2.集合类排序
利用接口排序代码如下:
List&lt;Integer&gt; list = Arrays.asList(34,23,5,67,43); list.sort(new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1-o2; } }); 利用λ表达式简化，代码如下：
List&lt;Integer&gt; list = Arrays.asList(34,23,5,67,43); list.sort((o1, o2) -&gt; o1-o2); 通过上面两个例子，可以发现。java中方法的入参可以是一个接口。比如list.sort方法，入参就是Comparator接口。有兴趣的同学可以跟踪jdk源码发现，list的排序，主要是利用了Comparator接口的compare方法。由于java是面向对象的语言，他的方法的入参只能是一个对象而不能是一个方法。但是编程需要入参是方法。那么这个问题是怎么解决的呢？由于java的方法的定义最简洁的方式是定义在接口中，因此当java中某个方法需要传入方法时，可以new一个接口，new一个接口相当于一个匿名类的对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ad9136c142c3b589be681e43c1b0386/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b07b3f5b2f6d449260d19db8c97b2d8/" rel="bookmark">
			Zookeeper实现分布式锁（Java客户端）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原理 ZK实现分布式锁的原理：每当加锁时，在ZK中创建临时有序节点作为锁节点。而节点的创建代表要加锁，而节点的删除代表锁被释放。
锁进一步细粒度分为读锁和写锁。两者的伪代码分别如下：
（一）读锁
创建一个临时序号节点，节点为值read表示读锁。
获取当前ZK中序号比自己小的所有节点
判断最小的节点是否是读锁：（因为如果中间出现写锁，是不会加锁成功的，所以只需要判断最小的即可。）
如果不是读锁，则上锁失败，为最小节点设置监听。阻塞等待。ZK的watch机制会当最小节点发生变化时通知当前节点，再执行第二步流程。
如果是读锁的话 上锁成功。
（二）写锁
创建一个临时序号节点，节点值为write表示写锁。 获得zk中所有的子节点
判断自己是否是最小的节点：
如果是，则上锁成功
如果不是，则上锁失败，监听最小节点。当最小节点发生变化，则回到第二步。
二、代码实现 加锁、释放锁的代码实现
//加读锁 public String lockReadLock() throws Exception{ //1、创建临时节点 String createZnode = zooKeeper.create(znodePath, readLockValue.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); Thread thread = Thread.currentThread(); //如果加锁失败 被唤醒后需要从这步开始再做 while(true) { //2、获得所有子节点 List&lt;String&gt; children = zooKeeper.getChildren(lockPath, null); //3、排序 TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;(children); while (!treeSet.isEmpty()) { //4、获得最小节点,并从set中删除 String smallestZnode = treeSet.first(); treeSet.remove(smallestZnode); //5、如果是刚创建的临时节点，说明前面没有任何锁，可以直接加锁。 if (createZnode.equals(lockPath + "/" + smallestZnode)) { //加锁成功 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b07b3f5b2f6d449260d19db8c97b2d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/913158b0dd99194bf488400a062f4ce9/" rel="bookmark">
			打家劫舍（力扣）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打家劫舍（力扣）——扩展输出由哪些所偷金额组成 条件：不可以连续的偷。
分析思路： 假设一个有n间房，第i间房放有Mi金额的钱。
步骤一：定义原问题和子问题
原问题：从全部 n 间房中能够偷盗的最大金额；子问题：从前 k 个(k&lt;=n) 间房中能够偷的最大金额； 步骤二：定义状态
我们记 f(k) 为小偷能从前k间房中偷到的最大金额，这里k就表示这个小偷在子问题时的一个状态，即小偷仅能偷前 n 间房 步骤三：寻找状态转移方程
就是 寻找子问题之间的一个递推关系，
情况1：
k=1时，只有第1间房可以偷，没得选。 情况2：
k=2时，只有第一间和第二间房，可以偷，因为不能连偷，所有选金额较大的房偷。 情况3：
k&gt;=3时，分两种情况讨论：
（1）小偷已经偷了第k-1间房，这时小偷不能再偷第k间房，所有此时最多获取f（k-1）的钱财。
（2）小偷没有偷第 k-1 间房，根据定义 小偷在前 k-2 间房 能偷到的最打钱财为 f（k-2），又因为没有偷第 k-1 间房，所有小偷一定会去偷第 k 间房 因此，小偷出去两次情况下较大的金额去偷，即 f()=max{ f(k-1),f(k-2)+Mk}
java代码实现： public int thief_DP(int[] arr) { if (arr == null || arr.length == 0) { return 0; } int len = arr.length; if(len==1) return arr[0];	//创建DP数组，来存储 前面所偷的金额 int[] dp = new int[len]; //初始条件 dp[0] = arr[0];	dp[1] = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/913158b0dd99194bf488400a062f4ce9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99cb9c5e8446a7c43daa0cb759bb32fc/" rel="bookmark">
			【PHP】HTTP请求工具使用文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该工具仅仅只是将php自带的curl功能，进行了一层封装。使得一些日常使用http请求时，不需要去重复的配置curl信息，减少开发工作量。
导入使用 下载链接：https://download.csdn.net/download/d745282469/85030673
如果是用的TP框架，则可在public/index.php中按照以下方式进行导入：
namespace think; require __DIR__ . '/../vendor/autoload.php'; // HTTP请求工具，具体的路径以实际为准 require __DIR__. '/../extend/HttpTool/AutoLoad.php'; // 执行HTTP应用并响应 $http = (new App())-&gt;http; $response = $http-&gt;run(); $response-&gt;send(); $http-&gt;end($response); 非TP框架的话，在需要使用到的php文件中，在顶部加入以下代码即可：
require __DIR__. '/../extend/HttpTool/AutoLoad.php';
具体的路径，以实际为准。
使用前须知 确定当前的php已经开启了curl扩展！！！
每个请求，主要涉及到以下两个类：
DHttpClient：请求客户端，主要用于配置代理、https验证、ssl证书、http版本等，具体可查看该类提供的方法。
DRequestBuilder：请求体构造器，主要用于配置请求相关的参数，如：请求地址、请求方式、请求头、请求cookie等。
DRequest：由DRequestBuilder构造得出，没啥用，只是给DHttpClient去使用的，和Builder基本一样。
发送请求 get请求 // 请求地址 $url = 'htts://www.baidu.com'; // 请求参数，如果为get请求，会自动把参数拼接到请求地址中 $param['wd'] = 'PHP官方文档'; // 请求构造器 $requestBuilder = new DRequestBuilder($url); // 可以采用链式写法。paramData()是用于设置请求参数的，接收的是数组类型。 // get()表示该请求使用get方式，同理还有post()。如果不指定请求方式，默认为get $requestBuilder-&gt;paramData($param)-&gt;get(); // 实例化请求客户端 $client = new DHttpClient(); // 执行请求并获取结果 $response = $client-&gt;execute($requestBuilder-&gt;build()); post请求 // 请求地址 $url = 'htts://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99cb9c5e8446a7c43daa0cb759bb32fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8aefd1f7ff744dce18d57fffc077896/" rel="bookmark">
			go语言map底层学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 map数据结构bucket 数据结构键值对存储（key, value）查找过程hash冲突负载因子扩容扩容的条件增量扩容 map数据结构 Golang的map使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。
map数据结构由runtime/map.go:hmap定义:
type hmap struct{ count int //当前保存的数据元素 ... B uint8 // buckets 的对数 ... buckets unsafe.pointer //bucket 数组指针，数组的大小为2^B ... } 下图展示一个4个bucket的map案例
bucket很多时候被翻译为桶，所谓的哈希桶实际上就是bucket。
bucket 数据结构 type bmap struct { tophash [8]uint8 //存储哈希值的高8位 data byte[1] //key value数据:key/key/key/.../value/value/value... overflow *bmap //溢出bucket的地址 } tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放是为了节省字节对齐带来的空间浪费。overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。
键值对存储（key, value） 哈希表通常会有一堆桶来存储键值对，一个个键值对来了必然要选择一个桶，先通过hash函数将“键”处理一下，得到一个hash值，利用hash值从m的个中选择一个，桶编号区间为[0,m-1]
如何从m个桶中选择：
第一种:
取模法（hash%m） 第二种：
与运算法（hash &amp; (m-1)） 若想确保运算结果落在区间[0,m-1]而不会出现空桶，就要限制桶的个数m必须是2的整数幂，这样m的二进制数肯定只含一个1（比如：m = 4 二进制表示:0000 0100，m-1 二进制表示:0000 0011）,如果桶的数目不是2的整数次幂，就会出现有些桶不会被选中，如果后来又有新的键值对选择这个桶，就会发生hash冲突,后续将介绍到.
Go语言中是通过与运算法来确定桶的位置，通过拉链法来解决hash冲突。
基本过程如下（与运算法）
假设当前 B=4 即桶数量为2^B=16个，要从map中获取k4对应的value
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8aefd1f7ff744dce18d57fffc077896/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1932eeb74f90df03b836c7d4c3b3b59/" rel="bookmark">
			ubuntu18.04安装Sophus踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Sophus前要先安装：eigen、fmt才可以装Sophus。
这边安装的是模板类的。
一、安装eigen
eigen是代数库，一定要安装3.3以上，不可以直接用sudo apt-get install libeigen3-dev这个代码，下来也用不了。
1.先卸载老版本
可以先检查有没有老版本，代码为：
sudo updatedb locate eigen3 有的话用sudo rm -rf 把locate的地址都清了，最后再重复上面代码，应该都没有了。
2.安装新版本
进入官网下载eigen3.4-rc1
Eigen
下载完后
wget https://gitlab.com/libeigen/eigen/-/archive/3.4-rc1/eigen-3.4-rc1.zip unzip eigen-3.4-rc1.zip cd eigen-3.4-rc1 mkdir build cd build cmake .. sudo make install 至此，eigen安装完成。
二、安装fmt
在github直接搜fmt，克隆下载
git clone https://github.com/fmtlib/fmt.git cd fmt mkdir build cd build cmake .. make sudo make install 三、安装Sophus
一开始我直接在github搜Sophus，下载了报错为：
static assertion failed: Cannot format an argument. To make type T formattable provide a formatter&lt;T&gt; specialization: https://fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1932eeb74f90df03b836c7d4c3b3b59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a1e8cc187c2dc69c5eb47f39176b0b/" rel="bookmark">
			vue中点击按钮实现全屏功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要为大家详细介绍了vue-cli点击实现全屏功能，文中示例代码介绍的非常详细，具有一定的参考价值，感兴趣的小伙伴们可以参考一下 本文实例为大家分享了vue-cli点击实现全屏功能的具体代码，供大家参考，具体内容如下
项目中有点击按钮实现全屏功能
方式一：js实现全屏
代码如下：
&lt;template&gt; &lt;div&gt; &lt;a-button type="primary" @click="screen"&gt;全屏&lt;/a-button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "index", data(){ return{ fullscreen: false } }, methods:{ screen(){ let element = document.documentElement; if (this.fullscreen) { if (document.exitFullscreen) { document.exitFullscreen(); } else if (document.webkitCancelFullScreen) { document.webkitCancelFullScreen(); } else if (document.mozCancelFullScreen) { document.mozCancelFullScreen(); } else if (document.msExitFullscreen) { document.msExitFullscreen(); } } else { if (element.requestFullscreen) { element.requestFullscreen(); } else if (element.webkitRequestFullScreen) { element.webkitRequestFullScreen(); } else if (element.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42a1e8cc187c2dc69c5eb47f39176b0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb42672f970f2eea78ecba82fed781d2/" rel="bookmark">
			XFRM-IPsec内核实现框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
XFRM介绍
XFRM初始化
XFRM Policies
XFRM States (Security Associations)
XFRM介绍 IPsec被XFRM(发音为transfrom)框架实现，起源于USAGI项目，旨在提供一种产品级的IPv6和IPsec协议栈。transform就是指根据一些IPsec规则在内核协议栈传输进来的包和出去的包。XFRM框架在Linux内核2.5版本被引用进来。XFRM基础结构是独立于协议族的，也就是说对于IPv4和IPv6来说是个通用独立的部分，在net/xfrm目录下可见。针对ESP，AH和IPCOMP，IPv4和IPv6都有他们自己的实现，例如IPv4的ESP模块是net/ipv4/esp4.c， 而IPv6的ESP模块是net/ipv6/esp6.c。除此之外，IPv4和IPv6为了支持XFRM基础结构实现了自己特有的模块，比如net/ipv4/xfrm4_policy.c或net/ipv6/xfrm_poilcy.c。
XFRM框架支持网络命名空间，一种轻量级进程虚拟化可以使能一个单独的进程或者一组进程拥有他们自己的网络协议栈。每一个网络命名空间（struct net的实例）包括了一个成员叫xfrm，xfrm是结构体netns_xfrm的实例，该结构体如下：
struct netns_xfrm { struct hlist_head *state_bydst; struct hlist_head *state_bysrc; struct hlist_head *state_byspi; . . . unsigned int state_num; . . . struct work_struct state_gc_work; . . . u32 sysctl_aevent_etime; u32 sysctl_aevent_rseqth; int sysctl_larval_drop; u32 sysctl_acq_expires; }; (include/net/netns/xfrm.h) struct net { . . . #ifdef CONFIG_XFRM struct netns_xfrm xfrm; #endif . . . }; (include/net/net_namespace.h) XFRM初始化 在IPV4中， XFRM初始化是通过调用xrm_init()来完成的。xfrm4_init()方法又被ip_rt_init()方法调用，见实现代码net/ipv4/route.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb42672f970f2eea78ecba82fed781d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/382748452b6ddc17d436498327069d58/" rel="bookmark">
			【补档】2020年前端秋招面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		年代较远，很多都是简单写了下
阿里一面
自我介绍
实习经历 实习项目
const let var
AMD CMD
position
Promise 事件循环相关
Promise.all
状态码
Vue data为什么是函数不是对象
Vue哪种数据类型不能被监听（Object） 为什么
Vue3.0如何解决这个问题
垂直居中 水平居中
判断数组
TCP UDP
数组去重
阿里二面
自我介绍
实习项目经历 细聊
position
box-sizing
HTTP和HTTPS
HTTPS有3个随机数（不会
二叉树遍历
跨域 CORS 还有什么办法跨域POST
订阅发布模式 跟观察者模式什么区别
鞭尸 为什么转正没过(QAQ
过了的那些同学你觉得有什么可学习的
字节一面
自我介绍 实习经历 实习项目
position
清除浮动
两侧固定中间自适应的布局
flex布局 flex:1什么意思
数据类型 引用类型和基本类型的区别
RegExp.exec()（用得少，忘了……
两数之和 leetcode第一题。。
看代码说结果 事件循环相关
看代码说结果 this指向相关 加了个throw Erorr()后的结果
一个Promise应用，实现一个singlePipe()方法(前一个请求没完成，拒绝之后的请求)
字节二面
聊实习经历实习项目聊了半小时。。
你觉得实习做的东西有哪些地方还能改进的
移动端适配
你如果项目delay了会怎么办
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/382748452b6ddc17d436498327069d58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6603f7196be455fdf1072483ca7e0a5/" rel="bookmark">
			STM32学习记录——MD300二维码扫描模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 该模块是博主在做工程实训的物流小车所用，当时因为某些特殊原因，不得不放弃视觉识别，因此想到用模块去代替功能。该模块就是当时在淘宝买的。虽然不如openmv那些效率高，但还是可以完成功能，当时用得也还不错，接上电源后，直接就可扫描，给的例程实在复杂，作为新手的我很多地方不是很懂，就自己试着搞了，还好最后实现了功能，使用的是正点原子stm32f1开发板。
模块接线图（MD300） 其他的就不放了。
代码 其实这个模块主要问题还是在数据的接收处理上。我用的是串口调试助手，显示我要的数据的提取、测试。因为工训的二维码内容位数字，如123，所以测试时自己生成了一个二维码123+321这种，故一下代码均以此来写的。
首先usart.c串口重定向 //在usart.c中重定向fputc函数 int fputc(int ch, FILE *f) { while((USART1-&gt;SR&amp;0X40)==0);//循环发送,直到发送完毕 USART1-&gt;DR = (u8) ch; return ch; } 方便串口调试助手调试
数据接收 char e[10]; char f[10]; int i=0; int j=0; void USART1_IRQHandler(void) //串口1中断服务程序 { #if SYSTEM_SUPPORT_OS //如果SYSTEM_SUPPORT_OS为真，则需要支持OS. OSIntEnter(); #endif if(USART_GetITStatus(USART1,USART_IT_RXNE)) // 中断标志,判断中断标志位非空 { e[i] = USART_ReceiveData(USART1);//定义一个数组接收数据 if (e[i]!= '+')//跳过‘+’ { f[j]=e[0]; //这里小编测试了许多次，发现数据总是接收到数组的第一位，这里真的搞了好久才发现 j++; printf("数据是%s",f[j]); } // 串口3中断服务函数 void USART3_IRQHandler(void) { if(USART_GetITStatus(USART3,USART_IT_RXNE)) // ÖÐ¶Ï±êÖ¾,ÅÐ¶ÏÖÐ¶Ï±êÖ¾Î»·Ç¿Õ { a[m] = USART_ReceiveData(USART3); if (a[m]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6603f7196be455fdf1072483ca7e0a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1344108a9445266b23fbdc4cfe6e2601/" rel="bookmark">
			微信小程序 获取经纬度、图片加水印上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序获取经纬度 const queryAuthority = () =&gt; { // 可以通过 Taro.getSetting 先查询一下用户是否授权了 "scope.record" 这个 scope Taro.getSetting({ success: function (res) { if (!res.authSetting["scope.userLocation"]) { Taro.authorize({ scope: "scope.userLocation", success: function () { // 用户已经同意小程序使用录音功能，后续调用 Taro.startRecord 接口不会弹窗询问 queryLocation(); }, fail: () =&gt; { rejectModal(); }, }); } else { queryLocation(); } }, }); }; const rejectModal = () =&gt; { Taro.switchTab({ url: `../workOrder/index`, }); Taro.showModal({ title: "提示", content: "请开启定位权限后重试", success: () =&gt; { Taro.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1344108a9445266b23fbdc4cfe6e2601/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb338bf59f45382cc530e01a2029dd43/" rel="bookmark">
			VisualStudio &#43; QT build environment setup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Visual Studio version :v2022
Install the QT Plugins Restart the Visual Studio open the extenstion plugins tool
Download the QT.exe https://download.qt.io/archive/qt/5.12/5.12.12/
Install the QT.exe for example:
Set QT version then,
Test the QT Creator Keep Go On 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce2ff306e14a4e7401debee9d868106c/" rel="bookmark">
			System.ArgumentException: 无法找到字体“?”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近调试软件无法启动的问题，报错信息为：System.ArgumentException: 无法找到字体“?”。
经长时间调试，发现是调用了SetDefaultDllDirectories的Windows
API后，导致无法查找到System.Drawing接口（有的问题描述为：破环了系统字体？）
解决方案，在SetDefaultDllDirectories之前，手动的调用一下System.Drawing的接口，让软件手动加载了System.Drawing和它依赖的dll，然后再调用SetDefaultDllDirectories，发现就不会有问题了。
代码：
var font = System.Drawing.SystemFonts.DefaultFont;//先加载上 int flags = LOAD_LIBRARY_SEARCH_APPLICATION_DIR | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS | LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_USER_DIRS;//这里的预定义是抄windows中的C接口的定义 bool isOk = setDefaultDllDirectories(flags); 当然，这个解决方法并不科学，但因为这个bug并不影响太大，就没有去继续深究深层次原因。如果有其他系统库仍然加载不上的，还是需要找到具体问题的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80afdb7e7fb942477d934063c7494a5a/" rel="bookmark">
			HJ54 表达式求值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述 给定一个字符串描述的算术表达式，计算出结果值。
输入字符串长度不超过 100 ，合法的字符包括 ”+, -, *, /, (, )” ， ”0-9” 。
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;stack&gt; using namespace std; bool big(char a, char b)//a比b优先级高就直接进栈，a只能是+-*/ { //a,b优先级相同 if ((a == '+' || a == '-') &amp;&amp; (b == '+' || b == '-')) return false; if ((a == '*' || a == '/') &amp;&amp; (b == '*' || b == '/')) return false; //a比b高 if (a == '*' || a == '/') return true; if ((a == '+' || a == '-') &amp;&amp; b == '(') return true; //b比a高 if ((a == '+' || a == '-')) return false; return false; } void compute(stack&lt;double&gt; &amp;n, stack&lt;char&gt; &amp;c) { double b = n.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80afdb7e7fb942477d934063c7494a5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fe91af1c0f5f650830b2f0a0474e2eb/" rel="bookmark">
			git cherry-pick 冲突解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cherry pick
1、作用：把A分支的commit同步更新（提交）到B分支
2、使用步骤
1）git checkout B 2）git cherry-pick -n [A分支中的commitId] 3）git status 查看是哪些文件发生冲突（红色的为有冲突的文件） 4）解决冲突 5）git add 这些文件（git add相当于标记为已解决） 6）接下来可以继续cherry pick下一个需要同步的commit，如若不继续，即可在B分支提交同步 转自：https://blog.csdn.net/sinat_40701859/article/details/99410060
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b487aeab1858ff17f4db3aee44c87c/" rel="bookmark">
			Typora编辑数学公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结常用的Markdown数学公式编辑方法 Typora支持Markdown编辑器，个人感觉用起来挺顺手的，在此记录一下常用的数学公式编辑方法，方便之后查阅。 1.Typora插入公式块（三种方法） 第一种：“段落”——“公式块”
第二种：输入“$$”，然后回车
第三种：快捷键方式 Ctrl+Shift+m
2.常用的公式代码 公式编辑 x 2 x^2 x2x^2 e − x e^{-x} e−xe^{-x} x 1 x_1 x1​x_1 1 / 2 1/2 1/21/2 1 2 \frac{1}{2} 21​\frac{1}{2} ⋯ \cdots ⋯\cdots 2 \sqrt{2} 2 ​\sqrt{2} a ⃗ \vec{a} a \vec{a} 积分
公式编辑 ∫ x d x \int{x}dx ∫xdx\int{x}dx ∫ a b x d x \int_{a}^{b}{x}dx ∫ab​xdx\int_{a}^{b}{x}dx 极限
公式编辑 lim ⁡ x \lim{x} limx\lim{x} ∞ \infty ∞\infty lim ⁡ x → 0 + x \lim_{x\rightarrow0^+}{x} limx→0+​x\lim_{x\rightarrow0^+}{x} lim ⁡ x → 0 − x \lim_{x\rightarrow0^-}{x} limx→0−​x\lim_{x\rightarrow0^-}{x} lim ⁡ x → + ∞ x \lim_{x\rightarrow+\infty}{x} limx→+∞​x\lim_{x\rightarrow+\infty}{x} lim ⁡ x → − ∞ x \lim_{x\rightarrow-\infty}{x} limx→−∞​x\lim_{x\rightarrow-\infty}{x} 累加累乘
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b487aeab1858ff17f4db3aee44c87c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd5224841b210cc961dfeec3e3473c39/" rel="bookmark">
			零钱兑换（力扣）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零钱兑换（力扣） 分析： 原问题：凑成总金额S所需的最少硬币个数；
子问题：可凑成目标金额x（x&lt;=S）所需的最少的硬币个数；
// c 表示硬币价值
状态转移方程：f(x)=min{ f(x-c1), f(x-c2), … , f(x-c2) }+1
// +1表示有一枚c值的硬币
注意：当 x-ci &lt; 0，表示，硬币价值比要凑的目标金额还要大，排除不选。
当 x-ci = 0，即目标金额为0，不需要硬币。
题目说，没有任何一种硬币组合，S就返回-1，因此最好我们需要判断一下f(S)是否为正无穷。
从前开始，避免重复计算。
java代码实现 public int coinChange(int[] coins, int amount) { int max = amount+1; int[] dp = new int[amount+1]; Arrays.fill(dp, max);	//快速初始化数组	dp[0] = 0;	//表示 coins的第一个元素 ，需要一枚硬币组成，就是自己。 for(int i=1;i&lt;=amount;i++) { for(int j=0;j&lt;coins.length;j++) { //硬币价值比要凑的目标金额要小， 如果大于，就看下一个硬币 if(coins[j]&lt;=i) { dp[i] = Math.min(dp[i],dp[i-coins[j]] + 1); } }	} return dp[amount]&gt;amount?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd5224841b210cc961dfeec3e3473c39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba413a8c2c28190968e936973252ea03/" rel="bookmark">
			vue&#43;springboot前后端传值常用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.get传输多个参数，后端使用实体类接收
前端： let query ={ id:1, name:'小红' } export function workMakeupList(query) { return request({ url: '/work/makeup/list', method: 'get', params: query }) } 后端控制层： @GetMapping("/list") public List list(Student s){ List s = null; return s; } //实体 public class Student{ private Long id, private String name } 2.get传输多个参数，后端分别接收
前端 let query = { id: 1, name:'小红' } export function workMakeupList(query) { return request({ url: '/work/makeup/list', method: 'get', params: query }) } 后端控制层： @GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba413a8c2c28190968e936973252ea03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf6ab32097c18496175d4709609499d/" rel="bookmark">
			机器人走格子——路径问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器人走格子——路径问题（简单） 从二维坐标，一个大小为m*n的网格，左上角到右下角，有多少种走法；
机规定器人只能向下或向右移动。
java代码实现： //	机器人走地图的到右下角 有多少种方法 public int DP_uniquePaths(int x,int y) { if(x&lt;=0||y&lt;=0) return 0; //定义数组 ， 数组表示 机器人到 (x,y) 位置 有 dp[x][y]种方法 int[][] dp = new int[x][y]; //初始化 // 最上面一排 向右走 所有只有1种走法 //最左边一行 向下走 for(int i=0;i&lt;x;i++) { dp[i][0] = 1; } for(int i=0;i&lt;y;i++) { dp[0][i] = 1; }	for(int i=1;i&lt;x;i++) { for(int j=1;j&lt;y;j++) { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[x-1][y-1]; } 完~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa1e1e7f93bdfcf22296fa84d64624b9/" rel="bookmark">
			【蓝桥杯】——DS18B20模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、DS18B20基本概念
（一）、DS18B20的基本概念
（二）、DS18B20的基本信息
二、DS18B20介绍
（一）DS18B20内部存储结构
（二）DS18B20系统配置寄存器数据格式
（三）DS18B20温度数据格式与处理
（五）DS18B20的读/写时序
（六）DS18B20的几个重要指令
三、DS18B20的底层驱动代码
四、DS18B10的应用
一、DS18B20基本概念 （一）、DS18B20的基本概念 DS18B20是Dallas公司生产的、具有one-Wire协议的数字式温度传感器，具有体积小，硬件开销低，抗干扰能力强，精度高的特点。
one-Wire（单线制串行总线）是Dallas公司研制开发是一种协议，由一个总线主节点、一个或多个从节点组成系统，通过一根信号线对芯片进行数据读取。
（二）、DS18B20的基本信息 测温范围：-55摄氏度~+125摄氏度
转换精度：9~12位二进制数（含1位符号位）
测温精度：9位精度为0.5摄氏度；12位精度为0.0625摄氏度。
转换时间：9位精度时为93.75ms；10位精度时为187.5ms；12位精度时为750ms。
通信方式：单总线，数据线接上拉电阻，使总线空闲时处于高电平。
二、DS18B20介绍 （一）DS18B20内部存储结构 DS18B20内部有9字节的高速寄存器
对应功能讲解：
对应的字节
寄存器编址
功能作用
第0字节
00H
温度转换值低8位
第1字节
01H
温度转换值高8位
第2字节
02H
温度上限寄存器TH
第3字节
03H
温度下限寄存器TL
第4字节
04H
系统配置寄存器
第5字节
05H
保留(FFH)
第6字节
06H
保留(0CH)
第7字节
07H
保留(10H)
第8字节
08H
CRC校验
（二）DS18B20系统配置寄存器数据格式 DS18B20系统配置寄存器有8位，低5位值永远为1，最高位为TM，TM是测试模式为，用于设置DS18B20在工作模式还是测试模式。在出厂时被设置为0，需要时可以修改，R1和R0用于设置分辨率（DS18B20在出厂时被设置为12位的分辨率，需要时可以修改）。DS18B20系统配置寄存器数据格式如下：
DS18B20分辨率设置如下：
（三）DS18B20温度数据格式与处理 DS18B20可完成对温度的测量，下面以12位精度为例。以16位带符号位扩展的二进制补码形式读出。低4位为小数部分，中间7位为整数部分，高5位为扩展符号位，
其中，S为符号扩展位，S=1 表示温度为负值，S=0表示温度为正值。
输出数据和实际温度值之间的关系如下：
注：DS18B20的温度数据是以补码形式表示。
计算方法：
DS18B20的12位精度的分辨率为0.0625。当读出数据为正温度时，将LSB和MSB整合成的16位整数，再分辨率（即0.0625）即可；当读出数据为负温度时，将LSB和MSB整合成的16位整数，再取反加1后，最后乘以0.0625即可。
（四）DS18B20时序复位设计
下面为蓝桥杯官方提供的底层驱动代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa1e1e7f93bdfcf22296fa84d64624b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a2609828ba589056ebcd97ea7f63608/" rel="bookmark">
			EqualsAndHashCode让对象比较更简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、回顾下==和equals的区别
二、再复习下equals()和hashCode()的关系
三、来看看EqualsAndHashCode（lombok）
四、来看看@Data
分享一道实习生的面试题，大家是否真的搞清楚了这块知识？
一、回顾下==和equals的区别 如上图所示，简单来说，==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同。
二、再复习下equals()和hashCode()的关系 重写equals() 大部分使用场景里面，2个对象比较，更多的是关注对象的各个字段值是否相等。这时候就需要重写equals()方法。
重写hashCode() 为什么需要重写hashcode()呢？因为我们不知道对象在内存中的存放方式。
试想一下，如果有10000个元素，用遍历方式去寻找的话，效率就太低了；为了解决这一问题，哈希算法诞生了。
哈希算法的核心思想是：
将集合分成若干个存储区域（可以看成一个个桶），每个对象可以计算出一个哈希码，可以根据哈希码分组，每组分别对应某个存储区域，这样一个对象根据它的哈希码就可以分到不同的存储区域（不同的区域）。
理想情况下我们只需要比较hash值，就可以确定对象是否相等；但是，学过数据结构的都会知道哈希冲突这个概念，简单理解就是多个对象的哈希值可能相等，所以就需要我们再比较哈希值的基础之上，在进行equals()方法比较；
综上所述，元素比较的流程就是：先比较哈希值，再调用equals()。
这也是为什么equals()方法要和hashcode()一起重写；因为equals()中需要比较哈希值，而哈希值的生成方式又涉及hasdcode()方法。
三、来看看EqualsAndHashCode（lombok） @EqualsAndHashCode
默认对类的所有字段实现equals()和hashCode()方法
@EqualsAndHashCode(of={"id", "age"}, exclude = {"name"})
指定字段，排除字段
@EqualsAndHashCode(callSuer=true)
覆盖父类字段
四、来看看@Data 简单来说，@Data就是以下5个注解的集合。但是如果需要自定义一些特征，就需要分别使用各个注解。
/** * @see Getter * @see Setter * @see RequiredArgsConstructor * @see ToString * @see EqualsAndHashCode * @see lombok.Value */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.SOURCE) public @interface Data { 参考文章：
​​​​​​Equals()与hashcode()方法_高冷小伙的博客-CSDN博客【lombok】@EqualsAndHashCode - 相等更简单：从对象的字段生成hashCode和equals实现_Amos-Chen的博客-CSDN博客​​​​​​Equals()与hashcode()方法_高冷小伙的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea14ea6de3fb7a5be9eddbae4780085e/" rel="bookmark">
			java8 streamlist转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 利用stream进行类型转化 List&lt;String&gt; stringList = new ArrayList&lt;&gt;(); stringList.add("a11"); stringList.add("b11"); stringList.add("c11"); stringList.add("d11"); stringList.add("e11"); List&lt;Map&lt;String,String&gt;&gt; stringList1 = stringList.stream().map(item-&gt; { Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put("name", item.toUpperCase()); return map; } ).collect(Collectors.toList()); List&lt;Long&gt; longList = new ArrayList&lt;&gt;(); longList.add(1L); longList.add(2L); longList.add(3L); List&lt;String&gt; stringList = longList.stream().map(item -&gt; String.valueOf(item.intValue())).collect(Collectors.toList()); System.out.println(stringList); // 将实体类的list，转换为map List&lt;User&gt; userList = new LinkedList&lt;&gt;(); Map&lt;Integer,User&gt; userMap = userList. stream(). collect(Collectors.toMap( item -&gt; item.getId(),// 操做map的key item-&gt; item,// 操做map的value (v1,v2)-&gt;v1 )); // 更简单的方式 Map&lt;Integer,User&gt; userMap1 = userList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea14ea6de3fb7a5be9eddbae4780085e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48493c360bfd56afa5a08a1db27cf453/" rel="bookmark">
			Games101作业补全--所有作业含提高项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
作业完整代码地址：
作业0：
作业1：
展示：
普通要求：
提高项：
作业2
展示：
未抗锯齿：
抗锯齿：
普通要求：
提高项：
作业3：
展示：
normal：
BlinnPhone:
texture:
bump:
displacement:
textureBilinear:
普通要求：
提高项：
作业4：
展示：
未抗锯齿：
抗锯齿：
普通要求：
提高项：
作业5：
展示：
要求：
作业6：
展示：
普通要求：
提高项：
作业7：
展示：
spp=16:
spp=1 Without MutiThread:
spp=1 With MutiThread:
spp=1 With MutiThread And Microfacet:
普通要求：
提高项：
多线程加速：
Microfacet:
作业8：
要求：
大作业：
新坑：
作业完整代码地址： https://github.com/1393650770/Games101-Homework
包含作业零、作业一、作业二、作业三、作业四、作业五、作业六、作业七、作业八、大作业
作业0： 作业1： 展示： 普通要求： 提高项： 作业2 展示： 未抗锯齿： 抗锯齿： 以下代码一个图截图截不完，就只粘贴关键代码，需要的可以前往文章开头的作业地址查看
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48493c360bfd56afa5a08a1db27cf453/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ccce18621cc23ce9ebc35b20e791c30/" rel="bookmark">
			redis源码阅读-持久化之aof与aof重写详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		aof相关配置 aof-rewrite-incremental-fsync yes # aof 开关，默认是关闭的，改为yes表示开启 appendonly no # aof的文件名，默认 appendfilename "appendonly.aof" # aof刷数据的策略,有no/everysec/aways appendfsync everysec no-appendfsync-on-rewrite no # aof超出配置大小的比例，模式是100%，可以理解为阈值 auto-aof-rewrite-percentage 100 # aof 配置的文件的大小，默认64mb auto-aof-rewrite-min-size 64mb aof-load-truncated yes # rewrite 进行时候，rewrite 文件分两种格式，1. 先 用 rdb 序列化，序列化结果写入aof文件，然后期间积累的差异用追加aof命令格式 ，2 整个文件都是aof的命令追加格式 aof-use-rdb-preamble yes appendfsync 一共有3种策略
alays 主要有数据改动就把数据刷入磁盘，性能相对最差，但最安全everysec 每隔1秒刷一次数据，redis默认的，也是redis推荐的no 不主动刷，什么时候刷数据，取决于操作系统，大多数linux 30秒提交一次 aof写入： 在之前分析redis的流程的时候《redis源码阅读三-终于把主线任务执行搞明白了》里读取客户端信息的时候
在processCommand 函数里，解析出来执行命令，放入了client中
int processCommand(client *c) { //解析出来命令 c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[0]-&gt;ptr); //CMD_CALL_FULL 包含着CMD_CALL_SLOWLOG | CMD_CALL_STATS | CMD_CALL_PROPAGATE //CMD_CALL_PROPAGATE 包含着CMD_CALL_PROPAGATE_AOF|CMD_CALL_PROPAGATE_REPL call(c,CMD_CALL_FULL); } //命令执行 void call(client *c, int flags) { /** * dirty 记录修改次数 * start记录命令开始执行时间us * duration记录命令执行花费时间 */ long long dirty; ustime_t start, duration; int client_old_flags = c-&gt;flags; struct redisCommand *real_cmd = c-&gt;cmd; //从server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ccce18621cc23ce9ebc35b20e791c30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7524c1ab871fb573a565c786e8d0ce69/" rel="bookmark">
			Echarts柱状图配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基本柱状图 // 指定图表的配置项和数据 var option = { // ---- 标题 ----- title: { text: '主标题', textStyle: { color: 'red' }, subtext: '副标题', subtextStyle: { color: 'blue' }, padding: [0, 0, 10, 100] // 位置 }, // ---- legend ---- legend: { type: 'plain', // 图列类型，默认为 'plain' top: '1%', // 图列相对容器的位置 top\bottom\left\right selected: { // '销量': true // 图列选择，图形加载出来会显示选择的图列，默认为true }, textStyle: { // 图列内容样式 color: '#fff', // 字体颜色 backgroundColor: 'black' // 字体背景色 }, tooltip: { // 图列提示框，默认不显示 show: true, color: 'red' }, data: [ // 图列内容 { name: '销量', icon: 'circle', textStyle: { color: 'red', // 单独设置某一个图列的颜色 backgroundColor: '#fff' // 单独设置某一个图列的字体背景色 } } ] }, // --- 提示框 ---- tooltip: { show: true, // 是否显示提示框，默认为true trigger: 'item', // 数据项图形触发 axisPointer: { // 指示样式 type: 'shadow', axis: 'auto' }, padding: 5, textStyle: { // 提示框内容的样式 color: '#fff' } }, // ---- gird区域 --- gird: { show: false, // 是否显示直角坐标系网格 top: 80, // 相对位置 top\bottom\left\right containLabel: false, // gird 区域是否包含坐标轴的刻度标签 tooltip: { show: true, trigger: 'item', // 触发类型 textStyle: { color: '#666' } } }, // ------ X轴 ------ xAxis: { show: true, // 是否显示 position: 'bottom', // x轴的位置 offset: 0, // x轴相对于默认位置的偏移 type: 'category', // 轴类型， 默认为 'category' name: '月份', // 轴名称 nameLocation: 'end', // 轴名称相对位置 nameTextStyle: { // 坐标轴名称样式 color: 'red', padding: [5, 0, 0, -5] }, nameGap: 15, // 坐标轴名称与轴线之间的距离 nameRotate: 0, // 坐标轴名字旋转 axisLine: { // 坐标轴 轴线 show: true, // 是否显示 symbol: ['none', 'arrow'], // 是否显示轴线箭头 symbolSize: [8, 8], // 箭头大小 symbolOffset: [0, 7], // 箭头位置 // ------ 线 --------- lineStyle: { color: 'blue', width: 1, type: 'solid' } }, axisTick: { // 坐标轴 刻度 show: true, // 是否显示 inside: true, // 是否朝内 length: 3, // 长度 lineStyle: { // 默认取轴线的样式 color: 'red', width: 1, type: 'solid' } }, axisLabel: { // 坐标轴标签 show: true, // 是否显示 inside: false, // 是否朝内 rotate: 0, // 文字旋转角度，防止x轴文字不显示 margin: 5, // 刻度标签与轴线之间的距离 color: 'red' , // 默认取轴线的颜色 formatter: function (params) { var newParamsName = '' // 最终拼接成的字符串 var paramsNameNumber = params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7524c1ab871fb573a565c786e8d0ce69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca45c9e3b36a11d3aaeecd1aab83337/" rel="bookmark">
			Kmalloc Vmalloc 与malloc 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总的来说
kmalloc和vmalloc是分配内核的内存，malloc分配的是用户空间的内存。kmalloc 保证分配的内存在物理上是连续的，vmalloc保证的是在虚拟地址空间上的连续，malloc申请的内存不一定连续（用户空间存储以空间链表的方式组织（地址递增），每一个链表块包含一个长度、一个指向下一个链表块的指针以及一个指向自身的存储空间指针。）kmalloc能分配的大小有限，vmalloc与malloc能分配的空间大小相对较大。内存只有在要被DMA访问的时候才需要物理上连续。vmalloc要不kmalloc要慢。 详细的解释
对于提供了MMU（存储管理器，辅助操作系统进行内存管理，提供虚实地址转换等硬件支持）的处理器而言，linux提供了复杂的内存管理系统，是的进程所能访问的内存达到4G.
进程的4G内存空间被人为分为两个部分-- 用户空间和内核空间。 用户空间的地址分布从0到3GB(PAGE_OFFSET，在0x86中它等于0xC0000000),3GB到4GB为内核空间。
内核空间中，从3G到vmalloc_start这段地址是物理内存映射区域（该区域中包含了内核镜像、物理页框表mem_map等等），比如我们使用的VMware虚拟系统内存是160M，那么3G~3G+160M 这片内存就应该映射物理内存，在物理内存映射区之后，就是vmalloc区域。对于160M的系统而言，vmalloc_start位置应该在3G+160M附近（在物理内存映射区域vmalloc_start器件还存在一个9M的gap来防止越界），vmalloc_end的位置接近4G（最后位置系统会保留一片128k大小的区域用于专用页面映射）
kmalloc和get_free_page申请的内存位于物理内存映射区域，而且在物理上也是连续的，它们与真实的物理地址只有一个固定的偏移，因此存在较简单的转换关系，virt_to_phys() 可以实现内核虚拟地址转换为物理地址：
#define _pa(x) ((unsigned long)(x)-PAGE_OFFSET) extern inline unsigned long virt_to_phsy(volatile void *address) { return _pa(address); } 上面的转换过程是将虚拟地址减去3G（PAGE_OFFFSET=0xc0000000）。
与之对应的函数为phys_to_virt(), 将内核的物理地址转换为虚拟地址：
#define _va(x) ((void *)(unsigned long)(x)+PAGE_OFFSET) extern inline void *phys_to_virt(unsigned long address) { return _va(address); } virt_to_phys()和phys_to_virt()都定义在include/asm-i386/io.h中。
而vmalloc申请的内存则位于vmalloc_start~vmalloc_end之间，与物理地址没有简单的转换关系，虽然逻辑上他们也是连续的，但是在物理上不要求连续。
#include &lt;linux/module.h&gt; #include &lt;linux/slab.h&gt; #include &lt;linux/vmalloc.h&gt; MODEULE_LICENSE("GPL"); unsigned char *pagemem; unsigned cahr *kmallocmen; unsigned char *vmallocmem; int __init mem_module_init(void) { //每次内存的申请都要检查是否申请成功，这里只做测试 pagemen = (unsigned char*)get_free_page(0); printk("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cca45c9e3b36a11d3aaeecd1aab83337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af8c2a249b252fd86f26be4b925df162/" rel="bookmark">
			Java序列化框架的比较（JDK、FastJson、Hessian、Hessian2、Protostuff）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念： 序列化：将Java对象转化为字节数组
反序列化：将字节数组转化为Ｊava对象
在RPC应用中，进行跨进程远程调用的时候，需要使用特定的序列化技术，需要对进行网络传输的对象进行序列化和反序列化。
影响序列化选择有两个因素：
序列化之后码流的大小，如果太大，那么将会影响网络传输的性能。序列化和反序列化过程的性能 常用的序列化框架性能比较
序列化框架对比测试： JDKFastJsonHessianHessian2Protostuff 准备 需要序列化的对象，这是一个复杂的对象。
NettyMessage public class NettyMessage implements Serializable { //消息头 private Header header; //消息体 private Object body; } @Data public class Header implements Serializable { //校验头 private int crcCode; //消息头消息体的总长度 private int length; //全局唯一id private long sessionId; //消息类型 private MessageType type; //扩展字段 private Map&lt;String,Object&gt; attachment; } @Data public class RpcRequest implements Serializable { private long requestId; //请求id private String interfaceName; //调用类名 private String methodName; //调用方法名 private String[] parameterTypes; //方法参数类型 private Object[] parameters; //方法参数 } public enum MessageType { APP_RESPONE_TYPE; } 创建一个构造器创建该对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af8c2a249b252fd86f26be4b925df162/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4baf44179b79e33f915100a57c846a44/" rel="bookmark">
			CString与char *互转总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自作者：flydream0
原文链接：https://blog.csdn.net/flydream0/article/details/8543525/
1 前言 今天在网上看论坛,发现大家对CString与Char *互转各说一词,其实我发现提问者所说的情况与回答问题的人完全不是同一情况,这里做一总结.
首先大家得清楚一件事,一般在网上提出问题的人大部分使用的都是VC,那么你就应该知道,在VC下编程,工程属性中有一属性Charecter Set属性,其值可以设置为Use Multi-Byte Charecter Set 和 Use Unicode Charecter Set 这两种选择,具默认情况下工程是采用了Use Unicode Charecter Set选项.如我使用的VS2010的工程属性中如下:
VC在处理CString类型字符时,在这两种不种选择的处理结果也是完全不一样的,而网上那么答复大都是针对假设提问者是使用了Use Mult-Byte Chracter Set的前提下,但大多提这个问题的人都是使用了后者的情况的人.
暂且将Use Mult-Byte Chracter Set称之为宽字节字符模式,而Use Unicode Charecter Set称之为Unicode编码模式.
2 宽字节字符模式 首先讨论一下宽字符字符模式下的CStirng与Char *之间的互转,在这种情况下互换很简单:
2.1 CString --&gt;char * 如下:
CString str1 ="123"; char *p =(LPSTR)(LPCSTR)str1; 但好像官方并不建议这么做,而建议采用下面这种方式:
CString str1 ="123"; char *t1 =str1.GetBuffer(str1.GetLength()); str1.ReleaseBuffer(); //do something with t1 网上也有人说是这样t1 =str1.GetBuffer(0);但其实我在实测时并没发现str1.GetBuffer(str1.GetLenth())与str.GetBuffer(0)返回值有啥区别,MSDN中相应说明如下:
CString::GetBuffer LPTSTR GetBuffer( int nMinBufLength ); throw( CMemoryException ); Return Value An LPTSTR pointer to the object’s (null-terminated) character buffer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4baf44179b79e33f915100a57c846a44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/248e15f2c6396f87d83fc11b9e02ca02/" rel="bookmark">
			全栈7——Cookie 和 Session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cookie 什么是Cookie
1、Cookie 翻译过来是饼干的意思。
2、Cookie 是服务器通知客户端保存键值对的一种技术。
3、客户端有了 Cookie 后，每次请求都发送给服务器。
4、每个 Cookie 的大小不能超过 4kb
如何创建 Cookie
服务器如何获取 Cookie
Cookie 值的修改
浏览器查看 Cookie：
Cookie 生命控制
Cookie 有效路径 Path 的设置
Session 什么是 Session 会话
1、Session 就一个接口（HttpSession）。
2、Session 就是会话。它是用来维护一个客户端和服务器之间关联的一种技术。 3、每个客户端都有自己的一个 Session 会话。
4、Session 会话中，我们经常用来保存用户登录之后的信息。
一些理解
Session代表服务器与浏览器的一次会话过程，这个过程是连续的，也可以时断时续的。在Servlet中，当JSP页面没有显式禁止session的时候，在打开浏览器第一次请求该jsp的时候，服务器会自动为其创建一个session，并赋予其一个sessionID，发送给客户端的浏览器。以后客户端接着请求本应用中其他资源的时候，会自动在请求头上添加：（Cookie:JSESSIONID=客户端第一次拿到的session ID）。这个cookie是服务器自动生成的，他的max-age为-1，变松hi仅当前浏览器有效。关闭浏览器失效，浏览器子窗口共享，各浏览器窗口不共享。这样，服务器端在接到请求时候，就会收到session ID，并根据ID在内存中找到之前创建的session对象，提供给请求使用。
这种在多次HTTP连接间维护用户与同一用户发出的不同请求之间关联的情况称为维护一个会话（session）建立了一次tcp的连接，但是可以发送很多次HTTP请求，session记录了用户信息，于是就可以判断这些请求都来自同一个用户。比如淘宝时候，加入浏览很多种商品，就是很多次HTTP请求。比如访问公司主页等等会话Session代表的是客户端与服务器的一次交互过程，这个过程可以是连续也可以是时断时续的。在Servlet中（jsp），一旦用户与服务端交互，服务器tomcat就会为用户创建一个session，同时前端会有一个jsessionid，每次交互都会携带。如此一来，服务器只要在接到用户请求时候，就可以拿到jsessionid，并根据这个ID在内存中找到对应的会话session，当拿到session会话后，那么我们就可以操作会话了。会话存活期间，我们就能认为用户一直处于正在使用着网站的状态，一旦session超期过时，那么就可以认为用户已经离开网站，停止交互了。用户的身份信息，我们也是通过session来判断的，在session中可以保存不同用户的信息。 浏览器和 Session 之间关联的技术内幕 Session 技术，底层其实是基于 Cookie 技术来实现的
会话种类
https://blog.csdn.net/qq_38446413/article/details/105755620
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/689f530022b0d1f1739400109e51b1b2/" rel="bookmark">
			查找指定的单个字符在整个字符串中的所有索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查找指定的单个字符在整个字符串中的所有索引 利用常规的str.find()和str.index()只能查找指定字符在字符串中出现的第一个索引，但是没有办法查找字符在字符串中出现的所有索引。 str1 = input('string1: ') key_i = input('one key1: ') index_key = [] str1_indexkey = str1.find(key_i) index_key.append(str1_indexkey) str_new = str1[str1_indexkey + 1:len(str1)] while str_new.find(key_i) != -1: str_new_indexkey = str_new.find(key_i) str1_indexkey = str1_indexkey + str_new_indexkey + 1 index_key.append(str1_indexkey) str_new = str1[str1_indexkey + 1:len(str1)] print('{}中指定的单个字符{}索引列表为{}'.format(str1, key_i, index_key)) 使用例子1：
string: 20200806 one key: 0 20200806中指定的单个字符0索引列表为[1, 3, 4, 6] 使用例子2：
string1: 00000 one key1: 0 00000中指定的单个字符0索引列表为[0, 1, 2, 3, 4] 希望对大家有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9948655f5512cc7713f3d31ef51b633d/" rel="bookmark">
			修改k8s集群中nginx-ingress中nginx.conf参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一，修改nginx.conf全局配置
# kubectl edit deploy -n ingress-nginx nginx-ingress-controller spec:
containers:
- args:
- /nginx-ingress-controller
- --default-backend-service=$(POD_NAMESPACE)/default-http-backend
- --configmap=$(POD_NAMESPACE)/nginx-configuration
- --tcp-services-configmap=$(POD_NAMESPACE)/tcp-services
- --udp-services-configmap=$(POD_NAMESPACE)/udp-services
- --publish-service=$(POD_NAMESPACE)/ingress-nginx
- --annotations-prefix=nginx.ingress.kubernetes.io
确认configmap，进行编辑：
# kubectl edit cm -n ingress-nginx nginx-configuration
kind: ConfigMap
apiVersion: v1
data:
client-header-buffer-size: 20m
compute-full-forwarded-for: "true"
forwarded-for-header: X-Forwarded-For
large-client-header-buffers: 4 1024k
proxy-body-size: 50m
use-forwarded-headers: "true"
metadata:
name: nginx-ingress-controller
namespace: default
labels:
app.kubernetes.io/name: ingress-nginx
app.kubernetes.io/part-of: ingress-nginx
第二、针对单个服务的ingress配置
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
annotations:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9948655f5512cc7713f3d31ef51b633d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e7b4e68c24ad879fbc501849e408cb8/" rel="bookmark">
			js中 给json对象添加属性和json数组添加元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js中 给json对象添加新的属性 比如现在有一个json对象为jsonObj，需要给这个对象添加新的属性newParam，同时给newParam赋值为pre。做法如下：
var jsonObj={
'param1':22,
'param2' :33
};
jsonObj. newParam ='pre';
新的属性添加以后，json对象变成：
var jsonObj={
'param1':22,
'param2' :33,
'newParam':'pre'
};
json 数组也是数组 //1、 var jsonstr="[{'name':'a','value':1},{'name':'b','value':2}]"; var jsonarray = eval('('+jsonstr+')'); var arr = { "name" : $('#names').val(), "value" : $('#values').val() } jsonarray.push(arr); //2、 var json={};// 定义一个json对象 json.array1=["2","4"];// 增加一个新属性array1，此属性是数组 json.array1[json.array1.length]='6';// 数组追加一个元素 alert(json.array1) //3、 var dic = new Array(); dic[i] = item; console.log(dic) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c346fd35277b87bbb2926017f408b9fa/" rel="bookmark">
			Flink CDC 系列（1）—— 什么是 Flink CDC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink CDC 系列文章：
《Flink CDC 系列（1）—— 什么是 Flink CDC》
《Flink CDC 系列（2）—— Flink CDC 源码编译》
《Flink CDC 系列（3）—— Flink CDC MySQL Connector 与 Flink SQL 的结合使用案例Demo》
《Flink CDC 系列（4）—— Flink CDC MySQL Connector 常用参数表》
《Flink CDC 系列（5）—— Flink CDC MySQL Connector 启动模式》
《Flink CDC 系列（6）—— Flink CDC MySQL Connector 工作机制之 Incremental Snapshot Reading》
《Flink CDC 系列（7）—— 从 MySQL 到 ElasticSearch》
文章目录 什么是 Flink CDC功能特性与 Flink 版本的对应关系 什么是 Flink CDC Flink CDC 是 CDC（change data capture 变更数据捕获）在 Flink 的一种实现，具体体现为一系列的 Flink CDC Connector，如 Mysql CDC connector，PostgreSQL connector 等。Flink CDC Connector 内嵌了 Debezium 来捕获数据变更。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c346fd35277b87bbb2926017f408b9fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22280c95dd5892ba51bc9bcd9caba5e0/" rel="bookmark">
			Flink CDC 系列（2）—— Flink CDC 源码编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink CDC 系列文章：
《Flink CDC 系列（1）—— 什么是 Flink CDC》
《Flink CDC 系列（2）—— Flink CDC 源码编译》
《Flink CDC 系列（3）—— Flink CDC MySQL Connector 与 Flink SQL 的结合使用案例Demo》
《Flink CDC 系列（4）—— Flink CDC MySQL Connector 常用参数表》
《Flink CDC 系列（5）—— Flink CDC MySQL Connector 启动模式》
《Flink CDC 系列（6）—— Flink CDC MySQL Connector 工作机制之 Incremental Snapshot Reading》
《Flink CDC 系列（7）—— 从 MySQL 到 ElasticSearch》
文章目录 什么时候需要源码编译系统环境下载源码修改 pom.xml编译 什么时候需要源码编译 一般来说，源码编译是不需要的，用户可以直接在 Flink CDC 官网下载官方编译好的二进制包或者在 pom.xml 文件中添加相关依赖即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22280c95dd5892ba51bc9bcd9caba5e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62dea7176e665b26d53aacfd4889ffae/" rel="bookmark">
			Flink CDC 系列（3）—— Flink CDC MySQL Connector 与 Flink SQL 的结合使用案例Demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink CDC 系列文章：
《Flink CDC 系列（1）—— 什么是 Flink CDC》
《Flink CDC 系列（2）—— Flink CDC 源码编译》
《Flink CDC 系列（3）—— Flink CDC MySQL Connector 与 Flink SQL 的结合使用案例Demo》
《Flink CDC 系列（4）—— Flink CDC MySQL Connector 常用参数表》
《Flink CDC 系列（5）—— Flink CDC MySQL Connector 启动模式》
《Flink CDC 系列（6）—— Flink CDC MySQL Connector 工作机制之 Incremental Snapshot Reading》
《Flink CDC 系列（7）—— 从 MySQL 到 ElasticSearch》
文章目录 系统环境MySQL 测试数据准备Flink CDC 源码编译Flink 集群准备演示开始1. 启动 Flink SQL Client2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62dea7176e665b26d53aacfd4889ffae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a58143fb9d0e992e65bc828036606a0d/" rel="bookmark">
			Flink CDC 系列（4）—— Flink CDC MySQL Connector 常用参数表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink CDC 系列文章：
《Flink CDC 系列（1）—— 什么是 Flink CDC》
《Flink CDC 系列（2）—— Flink CDC 源码编译》
《Flink CDC 系列（3）—— Flink CDC MySQL Connector 与 Flink SQL 的结合使用案例Demo》
《Flink CDC 系列（4）—— Flink CDC MySQL Connector 常用参数表》
《Flink CDC 系列（5）—— Flink CDC MySQL Connector 启动模式》
《Flink CDC 系列（6）—— Flink CDC MySQL Connector 工作机制之 Incremental Snapshot Reading》
《Flink CDC 系列（7）—— 从 MySQL 到 ElasticSearch》
Flink CDC MySQL Connector 参数 参数名是否必填默认值类型参数描述connector是无String指定connector，这里填 mysql-cdchostname是无StringMySql server 的主机名或者 IP 地址username是无String连接 MySQL 数据库的用户名password是无String连接 MySQL 数据库的密码database-name是无String需要监控的数据库名,支持正则表达式table-name是无String需要监控的表名,支持正则表达式port否3306IntegerMySQL 服务的端口号server-id否无Integer当开启scan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a58143fb9d0e992e65bc828036606a0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8392300190cef1ad4acc105cb3782610/" rel="bookmark">
			Flink CDC 系列（5）—— Flink CDC MySQL Connector 启动模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink CDC 系列文章：
《Flink CDC 系列（1）—— 什么是 Flink CDC》
《Flink CDC 系列（2）—— Flink CDC 源码编译》
《Flink CDC 系列（3）—— Flink CDC MySQL Connector 与 Flink SQL 的结合使用案例Demo》
《Flink CDC 系列（4）—— Flink CDC MySQL Connector 常用参数表》
《Flink CDC 系列（5）—— Flink CDC MySQL Connector 启动模式》
《Flink CDC 系列（6）—— Flink CDC MySQL Connector 工作机制之 Incremental Snapshot Reading》
《Flink CDC 系列（7）—— 从 MySQL 到 ElasticSearch》
文章目录 简介initiallatest-offset使用场景 简介 Flink CDC MySQL Connector 可通过参数 scan.startup.mode 配置启动模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8392300190cef1ad4acc105cb3782610/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acc416220baaf0587afc60099a6b79fa/" rel="bookmark">
			Flink CDC 系列（6）—— Flink CDC MySQL Connector 工作机制之 Incremental Snapshot Reading
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink CDC 系列文章：
《Flink CDC 系列（1）—— 什么是 Flink CDC》
《Flink CDC 系列（2）—— Flink CDC 源码编译》
《Flink CDC 系列（3）—— Flink CDC MySQL Connector 与 Flink SQL 的结合使用案例Demo》
《Flink CDC 系列（4）—— Flink CDC MySQL Connector 常用参数表》
《Flink CDC 系列（5）—— Flink CDC MySQL Connector 启动模式》
《Flink CDC 系列（6）—— Flink CDC MySQL Connector 工作机制之 Incremental Snapshot Reading》
《Flink CDC 系列（7）—— 从 MySQL 到 ElasticSearch》
文章目录 什么是Incremental Snapshot ReadingIncremental Snapshot Reading 如何工作 什么是Incremental Snapshot Reading Incremental snapshot reading 是读取表块照数据的新机制。和旧的快照机制相比，有以下优点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acc416220baaf0587afc60099a6b79fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad562c00b81bc041c9fa4e966e9f8c31/" rel="bookmark">
			ESP8266的3种配网方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、直接把账号密码写到程序中，每次上电都从程序中定义好的账号密码进行配对连接。
#include &lt;ESP8266WiFi.h&gt; #define AP_SSID "xxx" //这里改成你的wifi名字 #define AP_PSW "xxxxxxxx"//这里改成你的wifi密码 void setup(){ //设置串口波特率，以便打印信息 Serial.begin(115200); //延时2s 为了演示效果 delay(2000); Serial.println("Setup start"); //启动STA模式，并连接到wifi网络 WiFi.begin(AP_SSID, AP_PSW); Serial.println(String("Connecting to ")+AP_SSID); //判断网络状态是否连接上，没连接上就延时500ms，并且打出一个点，模拟正在连接 while (WiFi.status() != WL_CONNECTED){ delay(500); Serial.println("."); } Serial.println(""); Serial.println("Connected, IP address: "); //输出station IP地址，这里的IP地址由DHCP分配 Serial.println(WiFi.localIP()); Serial.println("Setup End"); } void loop() { } 2、一键配网（大家都叫airkiss）
将以下代码烧录到开发版中，会先进行配网，如果没有配网就会进入airkiss配网模式，这时候可以打开乐鑫信息科技公众号提供的一件配网工具，我的airkiss设备将自己手机连接的网络共享给开发板。
#include &lt;ESP8266WiFi.h&gt; bool AutoConfig()//断电重连 { WiFi.begin(); //如果觉得时间太长可改 for (int i = 0; i &lt; 20; i++) { int wstatus = WiFi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad562c00b81bc041c9fa4e966e9f8c31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c1ce60671a0fd7a91844262abf6d25/" rel="bookmark">
			curl 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		curl 是一种命令行工具，作用是发出网络请求，然后获取数据，显示在"标准输出"（stdout）上面。它支持多种协议，下面列举其常用功能。
一、查看网页源码 直接在 curl 命令后加上网址，就可以看到网页源码。以网址 www.sina.com为例（选择该网址，主要因为它的网页代码较短）。
$ curl www.sina.com &lt;html&gt; &lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt; &lt;body bgcolor="white"&gt; &lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt; &lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt; &lt;/body&gt; &lt;/html&gt; 如果要把这个网页保存下来，可以使用 -o 参数：
$ curl -o [文件名] www.sina.com 二、自动跳转 有的网址是自动跳转的。使用 -L 参数，curl 就会跳转到新的网址。
$ curl -L www.sina.com 键入上面的命令，结果自动跳转为 www.sina.com.cn。
三、显示头信息 -i 参数可以显示 http response 的头信息，连同网页代码一起。-I 参数则只显示 http response 的头信息。
$ curl -i www.sina.com HTTP/1.1 301 Moved Permanently Server: nginx Date: Tue, 23 Aug 2016 08:30:16 GMT Content-Type: text/html Location: http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65c1ce60671a0fd7a91844262abf6d25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/929a3e81c74026724000ff040f45f558/" rel="bookmark">
			windows系统安装curl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.curl是什么 curl 是一种命令行工具，作用是发出网络请求，然后获取数据，显示在"标准输出"（stdout）上面。 安装教程👇：
1. 官网下载curl安装包
​ curl官网下载地址：curl下载
​ windows在最下面
2. 安装curl ​ 不需要解压安装包，只需要将bin文件夹中的
curl.exe和curl-ca-bundle.crt文件
提取出来，放在你想要将curl安装的文件夹中就行了。
3. 配置curl的系统环境变量 4.打开cmd，输入curl验证是否成功 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/288/">«</a>
	<span class="pagination__item pagination__item--current">289/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/290/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>