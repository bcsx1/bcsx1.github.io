<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f590167198c8db4e242c58e84a83964/" rel="bookmark">
			关于电脑任务栏软件图标变成白色白纸的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候在软件使用过程中，桌面上的图标是正常的，可是点击后出现在任务栏的图标就变成了白纸，怎么解决呢？，实就是图标缓存信息出了问题，博主亲测解决办法有效，现在把步骤写入下面，希望能帮到需要的人：
1、在搜索界面中输入cmd,也可以win+r然后输入cmd打开命令提示符号
2、输入以下代码，即可解决(记住要一条一条的输入代码）
taskkill /im explorer.exe /f
cd /d %userprofile%\appdata\local
del iconcache.db /a
start explorer.exe
exit
要是成功解决了麻烦点赞评论哈！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4961986a2de4be82fcb6466f1f958edd/" rel="bookmark">
			Android 创建桌面组件Widget——构建应用微件（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 创建桌面组件Widget——构建应用微件（二） Android 创建桌面组件Widget——构建应用微件（二）概览使用 AppWidgetProvider 类接收应用微件广播 Intent 固定应用微件设置预览图片 完整代码 Android 创建桌面组件Widget——构建应用微件（一）
Android 创建桌面组件Widget——构建应用微件（二） 效果图：
创建一个可以改变大小的widget，包含一个Button和一个TextView，点击按钮跳转到指定的Activity。
概览 微件是自定义主屏幕的一个重要方面。您可以将微件想象成“一目了然”的视图，它们让最重要的应用数据和功能一览无余，从用户的主屏幕即可进行访问。用户可以在其主屏幕面板间移动微件，如果系统支持，用户还可以调整微件的大小，按照他们的偏好量身定制微件中的信息量。
使用 AppWidgetProvider 类 AppWidgetProvider类扩展了BroadcastReceiver作为一个辅助类来处理应用微件广播。AppWidgetProvider仅接收与应用微件有关的事件广播，例如当更新、删除、启用和停用应用微件时发出的广播。当发生这些广播事件时，AppWidgetProvider会接收以下方法调用：
onUpdate()
调用此方法可以按AppWidgetProviderInfo中的updatePeriodMillis属性定义的时间间隔来更新应用微件。当用户添加应用微件时也会调用此方法，所以它应执行基本设置，如定义视图的事件处理脚本以及根据需要启动临时的 Service。不过，如果您已声明配置Activity，则当用户添加应用微件时不会调用此方法，但会调用它来执行后续更新。由配置Activity负责在配置完成后执行首次更新。onAppWidgetOptionsChanged()
当首次放置微件时以及每当调整微件的大小时，会调用此方法。您可以使用此回调来根据微件的大小范围显示或隐藏内容。您可以通过调用 getAppWidgetOptions() 来获取大小范围，该方法会返回包含以下各项的 Bundle： OPTION_APPWIDGET_MIN_WIDTH : 包含微件实例的当前宽度的下限（以 dp 为单位）。OPTION_APPWIDGET_MIN_HEIGHT: 包含微件实例的当前高度的下限（以 dp 为单位）OPTION_APPWIDGET_MAX_WIDTH: 包含微件实例的当前宽度的上限（以 dp 为单位）OPTION_APPWIDGET_MAX_HEIGHT: 包含微件实例的当前高度的上限（以 dp 为单位）。此回调是在 API 级别 16 (Android 4.1) 中引入的。如果您实现此回调，请确保您的应用不依赖于它，因为在旧款设备上不会调用它。 onDeleted(Context, int[])
每次从应用微件托管应用中删除应用微件时，都会调用此方法。onEnabled(Context)
首次创建应用微件的实例时，会调用此方法。例如，如果用户添加应用微件的两个实例，只有首次添加时会调用此方法。如果您需要打开一个新的数据库或执行只需要对所有应用微件实例执行一次的其他设置，则此方法非常合适。onDisabled(Context)
从应用微件托管应用中删除了应用微件的最后一个实例时，会调用此方法。您应使用此方法来清理在 onEnabled(Context)中完成的所有工作，如删除临时数据库。``
针对每个广播调用此方法，并且是在上述各个回调方法之前调用。您通常不需要实现此方法，因为默认的 AppWidgetProvider 实现会过滤所有应用微件广播并视情况调用上述方法。 最重要的 AppWidgetProvider 回调是 onUpdate()，因为向托管应用添加每个应用微件时都会调用它（除非您使用配置 Activity）。如果应用微件接受任何用户交互事件，则您需要在此回调中注册事件处理脚本。如果应用微件未创建临时文件或数据库，或者未执行其他需要清理的工作，则 onUpdate() 可能是您需要定义的唯一一个回调方法。例如，如果您希望应用微件具有一个在用户点击时会启动 Activity 的按钮，则可以使用以下 AppWidgetProvider 实现：
public class ExampleAppWidgetProvider extends AppWidgetProvider { public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) { final int N = appWidgetIds.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4961986a2de4be82fcb6466f1f958edd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c72d4dec94bbd51559382817f5da4c7/" rel="bookmark">
			[Ansible专栏]Ansible安装和基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信公众号：运维开发故事，作者：姜总
一、Ansible安装
1.1 yum使用EPEL源安装
1.2 编译安装
1.3 Git 源码安装
1.4 pip安装
二、Ansible相关文件说明
2.1 配置文件
2.2 主配置文件介绍
2.3 Inventory主机清单文件
三、实战演练
3.1 环境介绍
3.2 Ansible相关命令工具
一、Ansible安装 Ansible的安装方法主要有以下三种：
1.1 yum使用EPEL源安装 $ mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup $ mv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup $ wget -O /etc/yum.repos.d/epel.repo https://mirrors.aliyun.com/repo/epel-7.repo $ yum clean all &amp;&amp; yum makecache # 可以使用以下三种方式查看ansible包的信息 $ yum info ansible $ yum list ansible $ yum list | grep ansible ansible.noarch 2.9.27-1.el7 epel ansible-collection-microsoft-sql.noarch 1.1.0-1.el8 AppStream ansible-collection-redhat-rhel_mgmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c72d4dec94bbd51559382817f5da4c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725db186c112b2961e19120cc7ba7c05/" rel="bookmark">
			mysql不同引擎间差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常用MySQL引擎, 分别是MyISAM、InnoDB。其中默认的引擎是InnoDB，只要在需要它不支持的特性时，才考虑使用其他存储引擎。
InnoDB InnoDB 是 MySQL 默认的事务型存储引擎，并且实现了四个标准隔离级别(未提交读、提交读、可重复读、可串行化)。其默认级别时可重复读（REPEATABLE READ）。主索引时聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对主键查询有很高的性能。
InnoDB 支持真正的在线热备份，MySQL 其他的存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合的场景中，停止写入可能也意味着停止读取。
MyISAM mylsam不支持事务，仅仅支持表所。设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。
由于其不支持事务所以在奔溃修复时速度较慢，而且会有数据丢失的可能。
总结 Innodb MyISAM 事务支持不支持并发表锁，行锁表锁外键支持不支持恢复支持回滚，恢复快不支持回滚，恢复慢存储空间需要更多的内存和存储MyISAM可被压缩，存储空间较小 那么这两种引擎适合什么场景？
更新（删除）操作频率也高，数据的完整性要求高，对于并发量有要求选择innodb以读写插入为主的应用程序选择MyISAM 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15596ffe57c1119f2b96568d0ac3f4bd/" rel="bookmark">
			最小生成树的PRIM算法(c&#43;&#43;实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接
在网络搭建中,最小生成树有其广泛的应用.本文是作者学习了PRIM算法实现最小生成树之后的笔记体会.欢迎指正批评.
1.概述 设G =(V,E)是无向连通带权图，即一个网络。E中每条边(v,w)的权为c[v][w]。如果G的子图G’是一棵包含G的所有顶点的树，则称G’为G的生成树。生成树上各边权的总和称为该生成树的耗费。在G的所有生成树中，耗费最小的生成树称为G的最小生成树。
网络的最小生成树在实际中有广泛应用。例如，在设计通信网络时，用图的顶点表示城市，用边(v,w)的权c[v][w]表示建立城市v和城市w之间的通信线路所需的费用，则最小生成树就给出了建立通信网络的最经济的方案。
最小生成树性质： 设G=(V,E)是连通带权图，U是V的真子集。如果(u,v)属于E，且u属于U，v属于V-U，且在所有这样的边中，(u,v)的权c[u][v]最小，那么一定存在G的一棵最小生成树，它以(u,v)为其中一条边。这个性质有时也称为MST性质。
2.PRIM算法 设G=(V,E)是连通带权图，V={1,2,…,n}。
构造G的最小生成树的Prim算法的基本思想是：首先置S={1}，然后，只要S是V的真子集，就作如下的贪心选择：选取满足条件i属于S，j属于V-S，且c[i][j]最小的边，将顶点j添加到S中。这个过程一直进行到S=V时为止。
在这个过程中选取到的所有边恰好构成G的一棵最小生成树。
利用最小生成树性质和数学归纳法容易证明，上述算法中的边集合T始终包含G的某棵最小生成树中的边。因此，在算法结束时，T中的所有边构成G的一棵最小生成树。
例如，对于右图中的带权图，按Prim算法选取边的过程如下页图所示。　按Prim算法选取边的过程如下页图所示。
在上述Prim算法中，还应当考虑如何有效地找出满足条件i在S中,j也在V-S中，且权c[i][j]最小的边(i,j)。实现这个目的的较简单的办法是设置2个数组closest和lowcost。
在Prim算法执行过程中，先找出V-S中使lowcost值最小的顶点j，然后根据数组closest选取边(j,closest[j］)，最后将j添加到S中，并对closest和lowcost作必要的修改。
用这个办法实现的Prim算法所需的计算时间为O(n2).
以下是我参考&lt;计算机算法分析与设计&gt;王晓东第三版的代码设计的程序.
#include &lt;iostream&gt; #define MAXINT 6 using namespace std; //声明一个二维数组,C[i][j]存储的是点i到点j的边的权值,如果不可达,则用1000表示 //借此二维数组来表示一个连通带权图 int c[MAXINT][MAXINT]={{1000,6,1,5,1000,1000},{6,1000,5,1000,3,1000},{1,5,1000,5,6,4},{5,1000,5,1000,1000,2},{1000,3,6,1000,1000,6},{1000,1000,4,2,6,1000}}; void Prim(int n) { int lowcost[MAXINT];//存储S中到达对应的其它各点的最小权值分别是多少 int closest[MAXINT];//closest[]数组保存的是未在S中的点所到达S中包含的最近的点是哪一个,如:closest[i]=1表示i最靠近的S中的点是1 bool s[MAXINT];//bool型变量的S数组表示i是否已经包括在S中 int i,k; s[0]=true;//从第一个结点开始寻找,扩展 for(i=1;i&lt;=n;i++)//简单初始化 { lowcost[i]=c[0][i]; closest[i]=0;//现在所有的点对应的已经在S中的最近的点是1 s[i]=false; } cout&lt;&lt;"0-&gt;"; for(i=0;i&lt;n;i++) { int min=1000;//最小值,设大一点的值,后面用来记录lowcost数组中的最小值 int j=1; for(k=1;k&lt;=n;k++)//寻找lowcost中的最小值 { if((lowcost[k]&lt;min)&amp;&amp;(!s[k])) { min=lowcost[k];j=k; } } cout&lt;&lt;j&lt;&lt;" "&lt;&lt;"-&gt;"; s[j]=true;//添加点j到集合S中 for(k=1;k&lt;=n;k++)//因为新加入了j点,所以要查找新加入的j点到未在S中的点K中的权值是不是可以因此更小 { if((c[j][k]&lt;lowcost[k])&amp;&amp;(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15596ffe57c1119f2b96568d0ac3f4bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e952455403f7c04ab300fbe66a11c0f0/" rel="bookmark">
			c语言指针详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言指针 指针的定义和使用指针大小野指针和空指针万能指针 void*const修饰的指针变量第一种修饰普通变量第二种修饰指针类型第三种修饰指针变量第四种修饰指针类型修饰指针变量 （常量指针） 指针和数组指向数组的指针指针运算指针数组 多级指针指针和函数值传递和地址传递数组作为函数参数字符串去空格 指针作为函数的返回值字符串查找字符串 指针和字符串栈区字符串和数据区字符串的区别字符串数组字符指针作为函数参数主函数参数 &amp;是取地址符号 是升纬度的
*是取值符号 是降维度的
指针的定义和使用 指针就是内存中的一个地址编号，指针变量用于存储地址，指针变量也是一个变量。
#include&lt;stdio.h&gt; int main(void) { int a = 0xaabbccdd; printf("%p\n", &amp;a);//获取a的内存地址 return 0; } 内存中的每一个数据都会分配相应的地址
char 占内存一个字节，分配一个地址
int 占内存四个字节，分配四个地址
windows电脑在做数据存储时采用小端对齐（低位数据放在低位内存地址，高位数据放在高位内存地址）。
大端对齐：低位数据放在高位内存地址，高位数据放在低位内存地址。
计算机的字节顺序模式分为大端数据模式和小端数据模式，它们是根据数据在内存中的存储方式来区分的。小端对齐和大端对齐都是计算机中数据存储的一种方式。
数据类型* 变量名 定义指针类型变量
*变量名 = 值 通过指针间接修改变量的值
#include&lt;stdio.h&gt; int main(void) { int a = 0; printf("%p\n", &amp;a);//获取a的内存地址 //定义指针变量存储变量地址 int* b = &amp;a; printf("%p\n", b); *b = 20;//通过指针间接修改变量的值 printf("%d\n", a); printf("%d\n", *b); return 0; } 结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e952455403f7c04ab300fbe66a11c0f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80e3ef15da488e44c4f0e866aec32c33/" rel="bookmark">
			centos 7 下git使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		step 1 安装： yum -y install git
step 2 拉取代码前准备工作
生成公钥 ssh-keygen
公钥私钥位置
如果使用原有私钥，将这两个复制过来，执行ssh-add id_rsa
如果出现
调用
ssh-agent $SHELL
未完待续
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4e0fb9264592436fdb13e4d1b8702e7/" rel="bookmark">
			西瓜书机器学习复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 1科学技术工程 科学是什么，为什么
技术怎么做
工程多快好省地做
2分类与回归 若欲预测的是离散值，此类学习任务称为分类
若欲预测的是连续值，此类学习任务称为回归
若只涉及两个类别的分类任务，称为二分类任务
若涉及多个类别的分类任务，称为多分类任务
预测任务是希望通过对训练集进行学习，建立一个从输入空间x到输出空间y的映射f:x→y
3监督学习和无监督学习 监督学习:训练样本拥有标记信息，代表回归和分类
无监督学习:训练样本不拥有标记信息，代表聚类
4机器学习的目标 机器学习的目标是使学得的模型能很好地适用于新样本，而不是仅仅在训练样本上工作得很好
5泛化能力 泛化能力：学得模型适用于新样本的能力
6独立同分布 通常假设样本空间中全体样本服从一个未知分布D，我们获得的每个样本都是独立地从这个分布上采样获得的，即独立同分布
7奥卡姆剃刀 若有多个假设与观察一致，则选最简单的那个
8偏好 任何一个有效的机器学习算法必有其偏好
学习算法偏高是否与问题本身匹配，大多数时候直接决定了算法能否取得好的性能
9没有免费的午餐（nfl定理） 前提所有问题出现的机会相同，或所有问题同等重要
10机器学习经典定义 计算机利用经验改善系统自身性能的行为
11机器学习现状 计算机领域最活跃的研究分支之一
与普通人的生活密切相关
影响到人类社会的政治生活
具有自然科学探索色彩
12机器学习发展 13假设空间 假设空间就是基于数据集形成的所有情况的假设集合，对每种情况根据数据集分析得到概率情况，以便后期对未知情况进行判断
问题所有假设组成的空间
第二章 1模型评估 错误率低、精度高、繁华能力强
2泛化误差与经验误差 泛化误差：在测试集上的误差（在未来样本上的误差）
经验误差、训练误差：在训练集上的误差
3过拟合overfitting和欠拟合underfitting 过拟合：模型在训练集本中表现得过于优越，导致在验证数据集以及测试数据集中表现不佳。
欠拟合：模型没有很好地捕捉到数据特征，不能够很好地拟合数据
解决：
过拟合： 增大训练样本数，正则化也可以起到一定的作用。很多学习方法中也提供了防止过拟合的方法，如决策树中的预剪枝和后剪枝，BP算法中的早停和正则化等。
欠拟合：增加正则项，减少正则化参数，增加训练轮数
泛化误差越小越好？经验误差越小越好？no
4模型选择的三个关键问题 如何获得测试结果？评估方法
如何评估性能优劣？性能量度
如何判断实质差别？比较检验
5样本划分 如何获得测试集？
注意：
1保持数据分布一致性（例如分层采样）
2多次重复划分（例如：100次随机划分）
3测试集不能太大、不能太小（例如0.2-0.5）
方法：留出法、交叉验证法、自助法
留出法：将数据集D划分为两个互斥的集合，其中一个饿集合作为训练集S，另一个作为测试集T，在S上训练出模型后，用T来评估其测试误差，作为对泛化误差的估计。需要注意保持数据分布一致性、多次重复划分取平均、测试集不能太大、不能太小
交叉验证法：将数据集D划分为k个大小相似的互斥子集，每个子集都尽可能保持数据分布的一致性，每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集。优点：每一个样本数据都既被用作训练数据，也被用作测试数据，可以有效的避免过学习以及欠学习状态的发生，最后得到的结果也比较具有说服性。缺点：评估结果的稳定性和保真性很大程度上取决于k的取值。
自助法（自助采样，有放回采样，可重复采样）：在数据集较小、难以有效划分训练/测试集时很有用，自助法能从初始数据集中产生多个不同的训练集，这对集成学习等方法有很大的好处。自助法产生的数据集改变了初始数据集的分布，这会引入估计误差。
约有36.8%的不会出现，称为包外估计
4调参与最终模型 算法的参数：一般由人工设定，亦称为超参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4e0fb9264592436fdb13e4d1b8702e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad54df2be7bf2d82bcaec3a1c8ec94a/" rel="bookmark">
			搭建Web环境，初识JSP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
理解C/S和B/S的概念
B/S架构工作原理：
在互联网上如何实现资源访问：
WEB服务器
TomCat服务器
Tomcat使用小结
配置Tomcat
如何启动Tomcat
如何通过Tomcat部署静态页面
在Eclipse中配置Tomcat
如何创建web项目
部署web项目
JSP概述
使用JSP实现输出
在jsp中使用变量
JSP的执行过程
WEB程序调试和排错
小结
​​​​​​​page指令
out对象​编辑
理解C/S和B/S的概念 C/S：通过客户端程序访问服务器。
B/S：通过浏览器访问应用程序。
B/S架构工作原理： 在互联网上如何实现资源访问： WEB服务器 TomCat服务器 Tomcat使用小结 后面我们经常会操作的也就是/bin目录、/conf目录、/webapps目录和/work目录。
配置Tomcat 如何启动Tomcat 进入bin目录，双击startup.bat即可启动。
如果双击后，启动窗口一闪而过，而且Tomcat服务未启动
原因：在启动Tomcat时，需要读取环境变量和配置信息，缺少了这些信息，就不能登记环境变量，导致tomcat闪退。
二、解决办法：
1.在已解压的Tomcat的bin文件夹下找到startup.bat，右击-&gt;编辑。在文件头加入下面两行：
SET JAVA_HOME=D:\Program Files\Java\jdk1.8.0_152 （java jdk目录）
SET TOMCAT_HOME=D:\apache-tomcat-8.5.24-windows-x64\apache-tomcat-8.5.24 解压后的Tomcat文件目录）
注意有的版本提示：CATALINA_HOME，那就在文件头再加上一行：
SET CATALINA_HOME=D:\apache-tomcat-8.5.24-windows-x64\apache-tomcat-8.5.24
2.同样的，在已解压的Tomcat的bin文件夹下找到shutdown.bat，右击-&gt;编辑。在文件头加入下面两行：
SET JAVA_HOME=D:\Program Files\Java\jdk1.8.0_152 （java jdk目录）
SET TOMCAT_HOME=D:\apache-tomcat-8.5.24-windows-x64\apache-tomcat-8.5.24 解压后的Tomcat文件目录）
3.在 startup.bat 和shutdown.bat两个文件的最后一行添加单独的一行pause命令。
可以使startup.bat 暂停，查看是否有错误报告
4.双击startup.bat即可启动Tomcat
5.双击shutdown.bat即可停止Tomcat。或者在已启动的Tomcat窗口中直接ctrl+c也可停止Tomcat
判断是否启动成功
打开浏览器，因为是基于http协议的，在浏览器地址栏中输入http://localhost:8080 （8080是默认端口号，如果你修改了端口号，后面就跟你修改后的端口号，修改端口号的方法参照上面的配置Tomcat。）
如果能打开，表示Tomcat服务启动成功。
启动后不要关闭页面，关闭页面的话，服务也会关闭
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ad54df2be7bf2d82bcaec3a1c8ec94a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d372377abac060235b2032972eda35fd/" rel="bookmark">
			Linux上Tomcat配置HTTPS协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、安装jkd1.8 https://blog.csdn.net/sunpanlong123/article/details/128098296
二、配置tomcat 1.放入tomcat安装包，放入到 /data
2.解压安装包 tar -zxvf apache-tomcat-8.5.59.tar.gz
3.启动tomcat
/data/apache-tomcat-8.5.59/bin/startup.sh
4.开放接口
三、生成证书 1.使用keytool为Tomcat生成证书，tmp1是文件夹，tomcat.keystore是生成的证书
keytool -genkey -v -alias tomcat -keyalg RSA -keystore /tmp1/tomcat.keystore -validity 36500 2.字段解释
输入keystore密码：输入大于6个字符的字符串。您的名字与姓氏是什么，TOMCAT部署主机的域名或者IP，在本地做开发测试时，应填入“localhost”。你的组织单位名称是什么？”、“您的组织名称是什么？”、“您所在城市或区域名称是什么？”、“您所在的州或者省份名称是什么？”、“该单位的两字母国家代码是什么？”可以按照需要填写也可以不填写直接回车，在系统询问“正确吗？”时，对照输入信息，如果符合要求则使用键盘输入字母“y”，否则输入“n”重新填写上面的信息。 四、配置Tomcat服务器 打开tomcat配置文件，如：/tmp1/apache-tomcat-6.0.29/conf/server.xml，
把下面代码加进去
&lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol" maxThreads="150" SSLEnabled="true" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" keystoreFile="/tmp1/tomcat.keystore" keystorePass="123456"/&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" secretRequired="" /&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f7a40e3d502e43a45f41e840f8ce1ed/" rel="bookmark">
			【elementUI样式】模态框中的el-select下拉框不跟随页面滚动问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.在el-select标签中设置:popper-append-to-body="false"2.样式穿透（比较普遍的写法） 模态框中的el-select下拉框不跟随页面滚动问题 在使用elementUI写界面的时候，偶然遇到了如下图所示bug 当页面滚动的时候，el-select的内容跟随页面移动，不是跟随el-select下面的input进行移动，想要实现的效果如下图 百度了一下，有如下解决方案
1.在el-select标签中设置:popper-append-to-body=“false” popper-append-to-body属性的作用：
popper-append-to-body 属性是 Element-ui 官方文档中提供的一个属性，该属性的用途: 就是将 el-select 选项的内容移动 div#app 当中，默认值是 true ;(详情可见elementUI的官网)
&lt;el-select v-model="returnformValue" placeholder="Please select your return reason" :popper-append-to-body="false" style="z-index:1" class="returformSelect"&gt; &lt;el-option v-for="item in returnform" :key="item.value" :label="item.label" :value="item.value"&gt; &lt;/el-option&gt; &lt;/el-select&gt; 2.样式穿透（比较普遍的写法） &lt;el-dialog title="Please select your return reason" :visible.sync="dialogFormVisible"&gt; &lt;el-select v-model="returnformValue" placeholder="Please select your return reason" :popper-append-to-body="false" style="z-index:1" class="returformSelect"&gt; &lt;el-option v-for="item in returnform" :key="item.value" :label="item.label" :value="item.value"&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;div slot="footer" class="dialog-footer"&gt; &lt;el-button @click="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f7a40e3d502e43a45f41e840f8ce1ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64a0e49e8e833f019957d783d4797022/" rel="bookmark">
			02——用form表单简单实现登陆页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图：
&lt;!-- 信息抓取，获取有关文件信息 --&gt;
上传头像：&lt;input type="file"&gt;
效果如下：
代码：
注意：form标签不支持 border（边框属性），若要为表单添加边框，则应将form代码写在table中
&lt;!-- form 标签不支持 border属性,若要为表单添加边框, 则应将 form 代码写在 table 当中 --&gt; &lt;table border="1px solid #000"&gt; &lt;tr&gt; &lt;td&gt; &lt;!-- action="网址",作用是将表单内容提交给服务器 --&gt; &lt;form action=""&gt; &lt;!-- input 中的 name,是告诉服务器提交哪些内容 --&gt; 用户名：&lt;input type="text" name="user"&gt;&lt;br&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type="password" name="pwd"&gt;&lt;br&gt; &lt;!-- 1. 使用label标签,将可使单选框与对应文字打包, 效果:当鼠标点击文字时,也可选中相应的单选框, 好处在于增强用户体验 (需删除 label 标签中的 for="") 2. &lt;label for="man"&gt;&lt;/label&gt; &lt;input type="radio" name="sex" id="man" checked&gt;男 以上两行代码应配合使用,for="man",指向 input 中的 id 则实现效果同: &lt;label&gt; &lt;input type="radio" name="sex" checked&gt;男 &lt;/label&gt; --&gt; 性别： &lt;label&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64a0e49e8e833f019957d783d4797022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cf28adef76c16d39313f320e93c755f/" rel="bookmark">
			Linux下mysql安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、mysql下载 路径：https://www.mysql.com/
怎么找： 1、 2、 3、 4、 5、 6、 二、上传到服务器 安装包上传位置：/opt，为了好区分安装包，在这里新建了一个mysql5.7安装包打开Xftp，进入到opt内，把镜像附近进去，mysql5.7有四个文件，mysql8.0有五个文件 三、安装mysql 检查/tmp临时目录权限
chmod -R 777 /tmp
安装前，检查依赖
rpm -qa|grep libaio
rpm -qa|grep net-tools
执行下面命令，必须按照下面的顺序
rpm -ivh mysql-community-common-5.7.37-1.el7.x86_64.rpm
rpm -ivh mysql-community-libs-5.7.37-1.el7.x86_64.rpm
rpm -ivh mysql-community-client-5.7.37-1.el7.x86_64.rpm
rpm -ivh mysql-community-server-5.7.37-1.el7.x86_64.rpm
查看安装文件
rpm -qa | grep -i mysql
查看安装版本
mysql --version
服务初始化
mysqld --initialize --user=mysql
查看密码
cat /var/log/mysqld.log
查看服务是否启动
systemctl status mysqld.service
如果是inactive (dead)需要启动服务，启动服务是第九步
如果不需要启动，直接第11步
启动服务
systemctl start mysqld.service
再一次查看查看服务是否启动
systemctl status mysqld.service
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cf28adef76c16d39313f320e93c755f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe0f73f75475b956177659afae665bcc/" rel="bookmark">
			Android 图表-折线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鉴于网上有很多图表的一些好的文章，我今天的主要利用git上的一个开源框架CombinedChart来实现下面的效果.
图一和图二是最近在温湿度设备上需要实现的两个图表，需求：利用折线图将最近一天，一周，一个月得数据以图标的形式显示出来，同时若为本周本月需要添加多个折线展示最大和最小数据的一个变化。在这里我们主要用的是git上的一个开源图表框架-CombinedChart。
CombinedChart可以绘制饼图，柱形图，折线图，这次需求重点需要绘制折线图，这里便对CombinedChart如何绘制折线图做一个详细得介绍。
首先我们对combinedChart进行初始化这里我们涉及到的属性有:
//创建的CombinedChart表格 lateinit var ccTempertureForm: CombinedChart lateinit var ccHumidityForm: CombinedChart //不显示描述内容 ccTempertureForm.getDescription().setEnabled(true) //设置描述对象，对描述进行设置属性 var description: Description = Description() //这里可以设置文字，文字颜色，文字类型 description.text = "" //图表默认右下方的描述，参数是String对象 ccTempertureForm.description = description ccTempertureForm.setBackgroundColor(Color.WHITE) //设置图网格背景是否显示，默认是false ccTempertureForm.setDrawGridBackground(false) // ccTempertureForm.setHighlightFullBarEnabled(false) //显示边界,就是最上面的一条线加粗的 ccTempertureForm.setDrawBorders(false) //设置true支持两个指头向X、Y轴的缩放，如果为false，只能支持X或者Y轴的当方向缩放 ccTempertureForm.setPinchZoom(false) //设置是否可以拖拽,true可以左右滑动 ccTempertureForm.setDragEnabled(true) //设置是否可以缩放，false不可以放大缩小 ccTempertureForm.setScaleEnabled(false) //图例说明 val legend: Legend = ccTempertureForm.getLegend() legend.isEnabled = false //不显示图例 底部的什么颜色代表什么的说明 在这里我们初始化完图表数据后，我们需要设置X轴得数据列表，X轴数据属性及数据源
//x轴显示位置 ccHumidityForm.xAxis.position = XAxis.XAxisPosition.BOTTOM //网格显示颜色 ccHumidityForm.xAxis.gridColor = R.color.color_aaf7f7f7 //网格显示虚线 ccHumidityForm.xAxis.enableGridDashedLine(10f, 10f, 20f) //添加x轴显示数据源 ccHumidityForm.xAxis.valueFormatter = IndexAxisValueFormatter(xAxisHum) //getFormattedValue利用回调来设置修改x轴的值及添加其他的属性字符 ccHumidityForm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe0f73f75475b956177659afae665bcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846254aff307a6737dd5c3f43ed4e746/" rel="bookmark">
			企业python面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.列举常见的内置函数 2.简述yield和yield from关键字 3. 常用模块都有哪些？列举8个 4.json序列化时，可以处理的数据类型有哪些？如何保持原字典的顺序？ 5.@classmethod,@staticmethod,@property含义及用法 6.写一个可以给定出错重试次数的装饰器，用来处理HTTP超时等 def get_response(url): r = requests.get("www.baidu.com") return r.content 7.写出5个你最熟悉linux命令，并简要说明使用场景。 8.简述python的垃圾回收机制 引用计数、标记回收、隔代回收
引用计数：当一个对象被引用，则会+1，反之-1，如果为0则消除没对象，但是会导致一个循环引用的问题，所以引出标记回收。
标记回收：成本较高
隔代回收：分三代回收
9.HTTP协议中，Cookie和session的区别是什么？GET和POST分别是做什么用的，你还知道其他的方法吗？ 1.HTTP是无状态请求，cookie和session都是为了记录客户端状态，cookie是保存在客服端的，大小限制为4K。session保存存在服务器，相对cookie更安全，存储信息更多，缺点就是服务器压力大
2.GET请求获取数据，POST提交数据，DELETE删除数据，PUT更新单挑数据，PATCH更新部分数据
10.python中有哪些方法可以实现并行，他们分别适用于什么场景？ 方法：进程、协程、线程，io多路复用（select、poll、epoll）
场景：爬虫（进程+协程）、nginx（IO多路复用）
11.python中的装饰器是什么？@classmethod，@staticmethod，@property，这些装饰器的用途分别是什么？ 装饰器：在不改变原来函数代码基础上，增加额外的功能
@classmethod:类方法
@staticmethod:静态方法
@property：属性，把类的方法，装饰城属性一样调用
12.简要描述数组、链表、队列、堆栈的区别？ 13.写出你知道的排序算法，并使用python实现一种排序算法，对0-100的整数列表进行排序 14.什么是可变与不可变类型？ 15.浅拷贝和深拷贝的实现方式、区别？ 在python中对象的赋值其实就是对象的引用。当创建一个对象，把它赋值给另外一个变量的时候，python并没有拷贝这个对象，只是拷贝这个对象的引用而已。
浅拷贝：拷贝了最外围的对象本身，内部的元素都只是拷贝了一个引用而已，也就是，把对象复制一遍，但是该对象中引用的其他对象我不复制
深拷贝：外围和内部元素都进行了拷贝对象本身，而不是引用。也就是说，把对象复制一遍，并且该对象中引用的其他对象我也复制
16.new()与__init__（）的区别？ 17.编码和解码 编码：encode
解码：encode
编码：在python3中将str转化成bytes类型，python2将unicode转化为str
解码：在python3中将bytes按照utf-8或者gdk编码方式转为成str类型，python2是将str转化为unicode
18.range和xrange的区别？ xrange用户与range完全相同，所不同的就是生成的不是一个数组，而是一个生成器
要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间，在python3中，range()是像xrange()那样实现，xrange()被抛弃
19.TCP/IP分别在模型的那一层？ 20.socket长连接是什么意思? 21.http一次连接的全过程，你来说下从用户发起request-到用户response； 22.线程和进程的联系和区别？ 23.死锁的条件有哪些？ 24.List和tuple的区别有哪些？ 25.Set类型的特点是什么？ 26.GIL是什么？他对python多线程变成有什么影响？ 27.函数参数*args和**kwargs分别是什么意思？ 28.numbers是一个列表，元素都是整型，请写出代码求numbers中的所有值的和。 29.请为下面这个函数写一个装饰器，使用之后，在函数调用前和调用后分别输出Log到stderr（简单的print log即可） def foo(): print("Function foo") 30.函数bar()可能会抛出一个自定义的异常CustomError，请写代码实现如下功能：如果bar()抛出了CustomError,打印"custom error",否则打印"success" 31.浮点数比较,是否正确，如何比较浮点数大小 double a,b a = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/846254aff307a6737dd5c3f43ed4e746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b949938757b7a19ba623c994c9bfae2/" rel="bookmark">
			STM32CubeMX之串口配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32CubeMX之串口配置 串口通信是一种设备间非常常用的串行通信方式，以比特位的形式发送或接收数据，电子工程师经常使用这种方式来调试数据。本章节我们将学习串口发送和接收数据。STM32F103C8开发板通过串口协议和上位机软件对话，实现设备间的数据传输。
1.串口简介 通用同步异步收发器(USART)提供了一种灵活的方法与使用工业标准NRZ异步串行数据格式的外部设备之间进行全双工数据交换。 USART利用分数波特率发生器提供宽范围的波特率选择。它支持同步单向通信和半双工单线通信，也支持LIN(局部互连网)，智能卡协议和IrDA(红外数据组织)SIR ENDEC规范，以及调制解调器(CTS/RTS)操作。它还允许多处理器通信。使用多缓冲器配置的DMA方式，可以实现高速数据通信。
串口是计算机上一种非常通用设备通信的协议。大多数计算机包含两个基于RS232的串口。串口同时也是仪器仪表设备通用的通信协议；很多GPIB兼容的设备也带有RS-232口。同时，串口通信协议也可以用于获取远程采集设备的数据。本次所所使用开发板为mini USB串口，有3个分别为USART1、USART2和USART3。我们将以串口1为例完成开发板与上位机之间通讯。
2.串口特性 全双工：串行发送TX和串行接收RX（发送数据和接收数据不会相互干扰）；异步通信：一帧数据包含起始位，数据位，（校验位）停止位；最高通信速率：4.5Mbit/s 3.串口功能概述 任何USART双向通信至少需要两个脚：接收数据输入(RX)和发送数据输出(TX)。
RX：接收数据串行输。通过过采样技术来区别数据和噪音，从而恢复数据。
TX：发送数据输出。当发送器被禁止时，输出引脚恢复到它的I/O端口配置。当发送器被激活，并且不发送数据时， TX引脚处于高电平。在单线和智能卡模式里，此I/O口被同时用于数据的发送和接收。
总线在发送或接收前应处于空闲状态。一个起始位。一个数据字(8或9位)，最低有效位在前。0.5， 1.5， 2个的停止位，由此表明数据帧的结束。使用分数波特率发生器 —— 12位整数和4位小数的表示方法。一个状态寄存器(USART_SR)。一个数据寄存器(USART_DR)。一个波特率寄存器(USART_BRR)， 12位的整数和4位小数。一个智能卡模式下的保护时间寄存器(USART_GTPR)。 4.串口特性描述 1.串口是全双工通讯，串行发送TX和串行接收RX（发送数据和接收数据不会相互干扰）；
2.异步通信方式，一帧数据包含起始位，数据位，（校验位）停止位；
3.最高通信速率：4.5Mbit/s
4.字长可以通过编程USART_CR1 寄存器中的M位，如下图。在起始位期间， TX脚处于低电平，在停止位期间处于高电平。
5.空闲符号被视为完全由’1’组成的一个完整的数据帧，后面跟着包含了数据的下一帧的开始位(‘1’的位数也包括了停止位的位数)。
6.断开符号，被视为在一个帧周期内全部收到’0’(包括停止位期间，也是’0’)。在断开帧结束时，发送器再插入1 或2个停止位(‘1’)来应答起始位。
7.发送和接收由一共用的波特率发生器驱动，当发送器和接收器的使能位分别置位时，分别为其产生时钟。
5.硬件设计 使用跳线帽将PA9与CH340_RXD相连，PA10与CH340_TXD相连。
6.软件设计 打开STM32CbeMX软件，配置串口串口、开启串口中断
串口1配置:全双工异步通信、波特率为115200、8个数据位、1个停止位、无校验位
优先级分组设置：2位抢占优先级2位副优先级
7.生成代码 基本参数配置示例 波特率、数据位、停止位、校验位
void MX_USART1_UART_Init(void) { huart1.Instance = USART1; huart1.Init.BaudRate = 115200; //波特率 huart1.Init.WordLength = UART_WORDLENGTH_8B;//数据位 huart1.Init.StopBits = UART_STOPBITS_1;//停止位 huart1.Init.Parity = UART_PARITY_NONE;//校验位 huart1.Init.Mode = UART_MODE_TX_RX;//开启发送和接收功能 huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; if (HAL_UART_Init(&amp;huart1) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b949938757b7a19ba623c994c9bfae2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ba2c8b7ccf87e6d715332ea31572b2a/" rel="bookmark">
			logi k380 蓝牙键盘 与macbook 连接断开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		logi k380 蓝牙键盘 与macbook 连接断开，无法重新连接 问题描述系统环境不重启电脑的解决方案 问题描述 logi k380 蓝牙键盘正常连接macbook后，
经常自动断开连接；按键卡住，重复输入某个符号。 出现以上问题后，如果尝试重新连接键盘，发现macbook一直无法与键盘连接，除非重新启动macbook。
系统环境 macOS Ventura 13.0.1
不重启电脑的解决方案 打开macOS系统自带的Activity Monitor （活动监视器）找到bluetoothd 进程选中bluetoothd 并将其强制退出 如图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f85db0d2f9781359ebd19745e61ab06/" rel="bookmark">
			答案解析——第五届“传智杯”全国大学生计算机大赛（练习赛）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五届“传智杯”全国大学生计算机大赛（练习赛） A [传智杯 #5 练习赛] 复读 题目描述 给定若干个字符串，不定数量，每行一个。有些字符串可能出现了多次。如果读入一个字符串后，发现这个字符串以前被读入过，则这个字符串被称为前面相同的字符串的复读，这个字符串被称为复读字符串。相应的，每个首次出现的字符串就是非复读字符串。
举个例子，
abc def abc abc abc 第 1 , 3 , 4 , 5 1,3,4,5 1,3,4,5 行是字符串 abc，那么 3 , 4 , 5 3,4,5 3,4,5 行的字符串会被称为“复读”。
请你把所有的非复读字符串，按照行号从小到大的顺序，依次拼接为一个长串并输出。
输入格式 多个字符串，每行一个，含义见题目描述。
注意：如果这个字符串是 0，说明所有字符串都读完了。这个 0 不认为是一个“非复读字符串”。
输出格式 共一行，表示所有非复读字符串，按照行号从小到大依次连接的结果。
样例 #1 样例输入 #1 cc b a cc 0 样例输出 #1 ccba 提示 【数据范围】
字符串的个数不超过 500 500 500 个，字符串总长度不超过 50000 50000 50000，每个字符串中只包含小写字母、数字、 . 、! 和 &amp;，不包含空格等特殊符号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f85db0d2f9781359ebd19745e61ab06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01841038bd8d172f1a1a37e969c56b66/" rel="bookmark">
			下载vue-element-admin文件，最直接解决报错的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我知道更换版本很麻烦，我之前也尝试过很多除了修改版本之外的方法，结果是改改这个修修那个，花了三天的时间还是屈服了，一劳永逸更换旧的版本，欢迎大家经历过各种报错后再回来看这篇文章，点一下收藏，不然就找不到了。 能克隆成功的前提是涉及到了node.js,VScode,git命令的使用，python环境 下面将比较详细的介绍各个般的的协调匹配。
之前我也是找了很多文章，但是没有成功，当你修改完这些安装环境后，就可以按照官网上的命令挨个的执行了，没有一点问题，亲测有效。
而且一点也没报错，也不用像其他博主那样修改这个修改那个了。
vue-element-admin压缩包的链接地址是：https://download.csdn.net/download/qq_61920297/87192419
1.1
在我的主页上有从官网 介绍 | vue-element-admin上下载好的vue-element-admin文件压缩包
vue-element-admin完整版的（内有node-modules）开箱即用，可以直接 npm run dev， vue-element-admin压缩包的链接地址是：https://download.csdn.net/download/qq_61920297/87192419
第一个就是，不用花钱（先别着急下载，请向下阅读配置环境，不然会运行时报各种稀奇古怪的bug)
配置好环境后直接按照官网上的命令来一点也没报错，千万要注意配置环境！！！！！！
首先声明，博主也是踩了很多坑，最终花费了三天的空余时间git到这个完整版的前端参考文件，适合做课程设计，快速开发中级企业网站，另外的文章上也有详细的安装说明，比较适用于对电脑熟悉的朋友使用，其中也嵌套有其他博主的论文，这里是个压缩包，可在vscode等多种前端开发软件中使用，在我的GitHub账户上也能获取。
1.2
先看一下效果：
2.1.1 处理node.js版本
我这里使用的mvn版本是1.1.10，好像低版本的也会报错，node版本如果大于17.0.0，好像会在执行运行命令 npm run dev时会报错，所以建议使用node.js版本是16.0.0。
发表这篇文章的目的也是为了自己以后能用到，希望也能给大家来带一定的帮助。
这里建议使用使用nvm管理切换node版本,mvn的安装有很多教程，请参考连接：
多个Node.js版本之间切换 - 博客码农 - 博客园
Microsoft Windows [版本 10.0.19043.2251] (c) Microsoft Corporation。保留所有权利。 C:\Users\联想&gt;nvm -V Running version 1.1.10. Usage: nvm arch : Show if node is running in 32 or 64 bit mode. nvm current : Display active version. nvm install &lt;version&gt; [arch] : The version can be a specific version, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01841038bd8d172f1a1a37e969c56b66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2491a56f29f931f2d73f5624c16431cc/" rel="bookmark">
			第五届传智杯初赛B组题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A-莲子的软件工程学 【题解】这是一个简单的编程题，如果b大于0，a为正整数，b小于0，a为负整数。但是要注意，java写的时候要用long类型！！！
代码：
import java.util.Scanner; public class A { public static void main(String[] args) { Scanner sc = new Scanner(System.in); long a = sc.nextLong(); long b = sc.nextLong(); if (b &gt; 0) { System.out.println(Math.abs(a)); } else { System.out.println(-Math.abs(a)); } } } B-莲子的机械动力学 【题解】这个题是进制相加问题，首先输入两个数的长度，由于每个数都是由高位到低位描述数码，我们可以先将长度较短的那个数字进行前补0的操作，这样最后相加的时候两个数的长度相同。然后将两个数的每一位按顺序放入两个list中，进行从低位开始的a+b的操作。由于最低位进制从2开始依次递增，我们可以在相加的时候用两个变量分别表示进制位和是否有进位。再由一个list记录答案即可。
代码：
import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.io.PrintWriter; import java.io.StreamTokenizer; import java.util.ArrayList; import java.util.List; public class Main{ static List&lt;Integer&gt;lista = new ArrayList&lt;&gt;(); static List&lt;Integer&gt;listb = new ArrayList&lt;&gt;(); public static void main(String[] args) throws IOException { StreamTokenizer re = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2491a56f29f931f2d73f5624c16431cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c392f5284fdacff1fccd0f9c792e8529/" rel="bookmark">
			Python CNN卷积神经网络实例讲解，CNN实战，CNN代码实例，超实用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CNN简介
1. 神经网络基础
输入层（Input layer），众多神经元（Neuron）接受大量非线形输入讯息。输入的讯息称为输入向量。
输出层（Output layer），讯息在神经元链接中传输、分析、权衡，形成输出结果。输出的讯息称为输出向量。
隐藏层（Hidden layer），简称“隐层”，是输入层和输出层之间众多神经元和链接组成的各个层面。如果有多个隐藏层，则意味着多个激活函数。
2. 卷积一下哦
卷积神经网络（Convolutional Neural Network，CNN）针对全连接网络的局限做出了修正，加入了卷积层（Convolution层）和池化层（Pooling层）。通常情况下，卷积神经网络由若干个卷积层（Convolutional Layer）、激活层（Activation Layer）、池化层（Pooling Layer）及全连接层（Fully Connected Layer）组成。
下面看怎么卷积的
1.如图，可以看到：
（1）两个神经元，即depth=2，意味着有两个滤波器。
（2）数据窗口每次移动两个步长取3*3的局部数据，即stride=2。
（3）边缘填充，zero-padding=1，主要为了防止遗漏边缘的像素信息。
然后分别以两个滤波器filter为轴滑动数组进行卷积计算，得到两组不同的结果。
2.如果初看上图，可能不一定能立马理解啥意思，但结合上文的内容后，理解这个动图已经不是很困难的事情：
（1）左边是输入（7*7*3中，7*7代表图像的像素/长宽，3代表R、G、B 三个颜色通道）
（2）中间部分是两个不同的滤波器Filter w0、Filter w1
（3）最右边则是两个不同的输出
（4）随着左边数据窗口的平移滑动，滤波器Filter w0 / Filter w1对不同的局部数据进行卷积计算。
局部感知：左边数据在变化，每次滤波器都是针对某一局部的数据窗口进行卷积，这就是所谓的CNN中的局部感知机制。打个比方，滤波器就像一双眼睛，人类视角有限，一眼望去，只能看到这世界的局部。如果一眼就看到全世界，你会累死，而且一下子接受全世界所有信息，你大脑接收不过来。当然，即便是看局部，针对局部里的信息人类双眼也是有偏重、偏好的。比如看美女，对脸、胸、腿是重点关注，所以这3个输入的权重相对较大。
参数共享：数据窗口滑动，导致输入在变化，但中间滤波器Filter w0的权重（即每个神经元连接数据窗口的权重）是固定不变的，这个权重不变即所谓的CNN中的参数（权重）共享机制。
3卷积计算：
图中最左边的三个输入矩阵就是我们的相当于输入d=3时有三个通道图，每个通道图都有一个属于自己通道的卷积核，我们可以看到输出（output）的只有两个特征图意味着我们设置的输出的d=2，有几个输出通道就有几层卷积核（比如图中就有FilterW0和FilterW1），这意味着我们的卷积核数量就是输入d的个数乘以输出d的个数（图中就是2*3=6个），其中每一层通道图的计算与上文中提到的一层计算相同，再把每一个通道输出的输出再加起来就是绿色的输出数字啦！
举例：
绿色输出的第一个特征图的第一个值：
1通道x[ : :0] 1*1+1*0 = 1 （0像素点省略）
2通道x[ : :1] 1*0+1*(-1)+2*0 = -1
3通道x[ : :2] 2*0 = 0 b = 1
输出：1+（-1）+ 0 + 1（这个是b）= 1 绿色输出的第二个特征图的第一个值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c392f5284fdacff1fccd0f9c792e8529/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beb21cd0e5d74e64ae98bd7f50d210ab/" rel="bookmark">
			Python 关于numpy的练习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 输出非零数字位置 查找一维数组中所有非零元素的位置。
输入格式: 在一行输入数据，以空格分隔
输出格式: 输出非零数据的索引（按从小到大顺序）
输入: 1 2 0 0 5 输出: 0 1 4 # 此处引用numpy创建数组及判断非零元素 import numpy as np a = np.array(list(map(int,input().split()))) # nonzero()函数是numpy中用于得到数组array中非零元素的位置（数组索引）的函数。 b = np.nonzero(a) for i in range(len(b[0])): print(b[0][i],end = " ") # nonzero()返回的是元组，故需要写成b[0]，否则将出现以下结果： 2. 创建数组 创建一个二维数组，其中边界值为1，其余值为0。
输入格式: 一个整数，代表二维数组（方阵）维数
输出格式: 一个方阵
输入样例: 4 输出样例: [[1. 1. 1. 1.] [1. 0. 0. 1.] [1. 0. 0. 1.] [1. 1. 1. 1.]] import numpy as np x = int(input()) #np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beb21cd0e5d74e64ae98bd7f50d210ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd02da6f68fb82f98ea30b554c96594/" rel="bookmark">
			matlab实现线性参数的最小二乘法处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的 最小二乘法原理是一种在多学科领域中获得广泛应用的数据处理方法。通过实验要求掌握最小二乘法基本原理、正规方程以及组合测量的最小二乘法处理办法。
二、实验原理 （1）测量结果的最可信赖值应在残余误差平方和为最小的条件下求出，这就是最小二乘法原理。即
（2）正规方程最小二乘法可以将误差方程转化为有确定解的代数方程组（其方程式的数目正好等于未知数的个数），从而可求解出这些未知参数。这个有确定解的代数方程组称为最小二乘法估计的正规方程。
（3）精度估计为了确定最小二乘估计量x1、x2.......xt的精度，首先需要给出直接测量所得测量数据的精度。测量数据的精度也以标准差来表示。因为无法求得的真值，只能依据有限次的测量结果给出的估计值，所谓精度估计，实际上是求出估计值。 （4）组合测量是通过直接测量待测参数的各种组合量，然后对这些测量数据进行处理，从而求得待测参数的估计量，并给出其精度估计。
三、实验内容 如下图所示已知直接测量刻线的各种组合量，要求检定刻线A、B、C、D间距离x1、x2、x3，测量数据的标准差以及估计量精度估计。
L1=2.018mm 、L2=1.986mm、L3=2.020mm、L4=4.020mm、L5=3.984mm、L6=6.030mm
四、实验要求 1、实验程序 根据最小二乘法原理利用matlab编写程序。
clc close all clear L = [2.018;1.986;2.020;4.020;3.984;6.030]; %直接测量的数据L A = [1 0 0;0 1 0;0 0 1;1 1 0;0 1 1;1 1 1]; %正规方程的矩阵形式 X = inv(A'*A)*A'*L; %待测量Ｘ的无偏估计 V1 = L(1)-X(1); V2 = L(2)-X(2); V3 = L(3)-X(3); V4 = L(4)-X(1)-X(2); %根据图示X与L的关系求出残差 V5 = L(5)-X(2)-X(3); V6 = L(6)-X(1)-X(2)-X(3); V = V1*V1+V2*V2+V3*V3+V4*V4+V5*V5+V6*V6; %求出残差之和 B = sqrt(V/(6-3)); %根据公式算出测量数据L的标准差 D = diag(inv(A'*A)); Q = B*sqrt(D); %精度估计 2、运行结果 给出程序运行结果，包括估计量的值，测量数据的标准差以及估计量的精度估计。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bd02da6f68fb82f98ea30b554c96594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1629653eea4e12beb87439f80c0cb86d/" rel="bookmark">
			【C51单片机学习笔记----DS18B20温度传感器&amp;&amp;LCD1602液晶屏&amp;&amp;直流电机调速与呼吸灯&amp;&amp;AD模数转换&amp;&amp;红外外部中断】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、DS18B20温度传感器1.DS18B20温度传感器连接原理图2.DS18B20温度传感器单总线通信时序3.DS18B20温度传感器代码模块 二、LCD1602液晶屏1.LCD1602液晶屏连接原理图2.字符码和指令集3.LCD1602液晶屏模块 三、直流电机调速与呼吸灯1.直流电机连接原理图2. PWM直流电机调速和呼吸灯亮度变化3. 直流电机调速和呼吸灯亮度变化代码模块 四、AD模数转换和DA数模转换1. AD和DA介绍2. 运放电路3. AD和DA的原理图4. AD和DA的代码模块 五、红外遥控和外部中断1. 红外遥控简介和原理图2. 外部中断和NEC编码3. 红外遥控代码模块 一、DS18B20温度传感器 1.DS18B20温度传感器连接原理图 DS18B20是一种单总线数字温度传感器，测试温度范围-55℃-125℃，具有体积小，硬件开销低，抗干扰能力强，精度高的特点。单总线，意味着没有时钟线，只有一根通信线。单总线读写数据是靠控制起始时间和采样时间来完成，所以时序要求很严格，这也是DS18B20驱动编程的难点。
DS18B20温度传感器靠VCC和GND两个引脚完成供电，另一个引脚P3^7则负责单总线数据传输通信。
主要由2部分组成：64位ROM、9字节暂存器，如图所示。
(1) 64 位ROM。它的内容是64 位序列号，它可以被看作是该DS18B20 的地址序列码，其作用是使每个DS18B20 都各不相同，这样就可以实现一根总线上挂接多个DS18B20 的目的。
(2) 9字节暂存器包含：温度传感器、上限触发TH高温报警器、下限触发TL低温报警器、高速暂存器、8位CRC产生器。
2.DS18B20温度传感器单总线通信时序 DS18B20的通信分为初始化，发送一个字节，接受一个字节三个阶段：
初始化阶段先将主机总线拉低一定时间等待存在的从机响应。
发送一个字节阶段先将主机总线拉低然后再将一个字节放到总线上，如果该字节是1主机就会拉高从机就会读出1，如果该字节是0主机将一直拉低从机将读出0。
接受一个字节阶段先将主机总线拉低然后读取总线上的高低电平，高电平则是1，低电平则是0。
按照数据帧原理，初始化时要跳过ROM，然后发送接受数据原理类似移位寄存器，将数据一位一位放到总线上便可以实现温度的发送与读取。
3.DS18B20温度传感器代码模块 # include &lt;REGX52.H&gt; sbit OneWire_IO = P3^7;//定义通信引脚DQ unsigned char OneWire_Init() { unsigned char i,Ack; EA=0; OneWire_IO = 1; OneWire_IO = 0; i = 247;while (--i);//delay 500us OneWire_IO = 1; i = 32;while (--i);//delay 70us Ack=OneWire_IO ; i = 247;while (--i);//delay 500us EA=1; return Ack; } void OneWire_SendBit(unsigned char Bit) { unsigned char i; EA=0; OneWire_IO = 0; i = 4;while (--i);//delay 10us OneWire_IO=Bit; i = 24;while (--i);//delay 50us OneWire_IO = 1; EA=1; } unsigned char OneWire_ReceiveBit() { unsigned char i,Bit; EA=0; OneWire_IO = 0; i = 2;while (--i);//delay 5us OneWire_IO = 1; i = 2;while (--i);//delay 5us Bit=OneWire_IO; i = 24;while (--i);//delay 50us EA=1; return Bit; } void OneWire_SendData(unsigned char Data) { unsigned char i; for (i=0;i&lt;8;i++) { OneWire_SendBit(Data&amp;(0x01&lt;&lt;i)); } } unsigned char OneWire_ReceiveData() { unsigned char i,Data=0x00; for (i=0;i&lt;8;i++) { if (OneWire_ReceiveBit()) { Data|=(0x01&lt;&lt;i); } } return Data; } 这个是单总线通信模块，一共封装为初始化，发送一个字节，接受一个字节，发送数据，接收数据五个模块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1629653eea4e12beb87439f80c0cb86d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a2e8bcc04d7f6611fa6790a065da326/" rel="bookmark">
			深度学习常见损失函数总结&#43;Pytroch实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、引言二、损失函数1.均方差损失（Mean Squared Error Loss）2.平均绝对误差损失（Mean Absolute Error Loss）3.交叉熵（Cross Entropy Loss）（1）信息论中的熵a.熵b.相对熵（KL散度）c.交叉熵 （2） 常见的交叉熵函数a.one-hot编码b.SoftMax函数和Sigmoid函数c.交叉熵损失函数 （3）Pytroch实现交叉熵损失函数a.torch.nn.CrossEntropyLoss() b.torch.nn.NLLLossc.torch.nn.BCELoss和torch.nn.BCEWithLogitsLoss 4.三元组损失 参考文献 一、引言 啊啊啊，最近读到一篇论文用到了三元组损失，看的要把人给逼疯了。故在此先总结一下深度学习常见的损失函数以及其Pytroch实现，以方便我以后读论文和看源码。此外，由于现阶段见识浅薄，后面会遇到其它损失函数会接着更新。（小声bb，之前整理过一次，但太过简单了）
二、损失函数 1.均方差损失（Mean Squared Error Loss） 均方差损失（MSE）也称为L2损失，其数学公式如下：
J M S E = 1 N ∑ i = 1 N ( y i − y i ‘ ) J_{MSE}=\frac{1}{N}\sum_{i=1}^{N}{(y_i-y_i^{`})} JMSE​=N1​i=1∑N​(yi​−yi‘​)
在模型输出与真实值的误差服从高斯分布的假设下，最小化均方差损失函数与极大似然估计本质上是一致的。至于啥模型输出与真实值的误差服从高斯分布，这个还真的难说，极大似然估计是概率论中用来近似计算真实分布中的参数的一种方法。
Pytroch官方文档如下：
官方文档介绍：size_average和reduce已经被弃用，reduction可以选择‘mean’和‘sum’，这两者区别在于一个求完和后还要取均值，一个求完和后啥都不干。
实例如下：
import torch import torch.nn as nn loss_mean = nn.MSELoss() loss_sum = nn.MSELoss(reduction='sum') input = torch.randn(3, 5, requires_grad=True) target = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a2e8bcc04d7f6611fa6790a065da326/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ac6d41ede953e786fbc8766714031ad/" rel="bookmark">
			ORACLE: DDL及约束条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、基础知识
数据库对象
数据类型
字符
数字
日期
大对象
oracle中的表（表的类型）
查询数据字典
二、DDL
create
默认值
使用子查询建表
alter
drop
三、补充
对象重命名
truncate截断表
四、约束
not null
unique
primary key
foreign key
check
一、基础知识 数据库对象 表-table：基本的数据存储集合，列组成表的结构，行组成表的数据视图-view：从一张或多张表取出的逻辑相关的数据集合，存储在数据字典中的一条 select 语句序列-sequence：生成规律的数值，：一种生成唯一数字的结构：有序的发出数字索引-index：可以减少对表中行的访问次数、提高查询性能别名（同义词）-synonym：给对象起别名 对象命名规则
必须以字母开头，必须在1-30个字符内；必须只能包含A-Z，a-z，0-9，_，$，#；不能和用户其他定义的对象重名；小写字母会自动转换为大写字母； 通过将名称括在双引号内，除长度外其他规则可以打破。但后面使用对象时也一定要用双引号指定； 不能为oracle保留字。 查看oracle保留字，在sys用户下： select * from v$reserved_words where reserved='Y'; 数据类型 字符 char(n):
固定长度 字符数据，读取效率快，存储时使用 空格 填满空白内容。 n 默认值 1 ，范围 1~2000 字节 varchar2(n): 可变长度 字符数据，节省存储空间， n 必须指定 ，范围 1~4000 字节 一个汉字占两个字节 数字 number(p,s)：
数值数据，包括零、负数、正数 p为precision精度，即总的有效位数。最大38默认38 s为scale刻度，即小数点后位数s=0:整数，s&gt;0:保留s位小数，s&lt;0:小数点前第|s|位四舍五入，用0取得小数点前|s|位 日期 date：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ac6d41ede953e786fbc8766714031ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdf8d8372cc50164bc78fcc4eb54b8b3/" rel="bookmark">
			报错：Process finished with exit code -1073741819 (0xC0000005)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方案： 经过一遍遍排错，最后还是关机重启解决了问题！重启pycharm不好使！
问题描述： pycharm中写好的程序，前几天还能正常运行的，突然就不能运行了，报错：Process finished with exit code -1073741819 (0xC0000005)我在网上找了相关解答，说是文件路径可能含有中文，但我的程序、读取的文件路径都没有中文。而且Run命令的程序文件名多了(1)、(2)，但是在项目里并没有重名的程序。 排错过程： 1、查看一下配置到底怎么回事 2、可以看到有3个同名的程序，每个程序的路径也不相同。 【可能是我以前把这个程序挪来挪去的，虽然删掉了，但是还有一些缓存记录，导致存在冲突了】
2、把不要的程序给移除掉，然后点击Apply、OK 3、重新Run运行该程序，还是报错！！！ 4、文件夹名字有空格，但是去掉之后还是报错！！！ 5、一气之下，关机重启，再次运行，不报错了！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9dbee3bbdbc8e2232c9a74dc92b320c/" rel="bookmark">
			一本通2058；简单计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;math.h&gt; using namespace std; int main() { double x,y; char op; scanf("%lf %lf %c",&amp;x,&amp;y,&amp;op); switch(op) { case '+': printf("%lg\n",x+y); break; case '-': printf("%lg\n",x-y); break; case '*': printf("%lg\n",x*y); break; case '/': if(fabs(y)&lt;1e-6) printf("Divided by zero!\n"); else printf("%lg\n",x/y); break; default: printf("Invalid operator!\n"); } return 0; } ​​​​​​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b245b30d8d96811b6b0d9e2027f9cd2/" rel="bookmark">
			一本通2053；三个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;stdio.h&gt; int main() { int a,b,c,t; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(a&lt;b) { t=a; a=b; b=t; } if(a&lt;c) { t=a; a=c; c=t; } if(b&lt;c) { t=b; b=c; c=t; } printf("%d %d %d\n",a,b,c); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34fb69763aa91d56c9180b3760477b3e/" rel="bookmark">
			2069；【例2.12 】糖果游戏（信奥一本通）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考代码： #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int a,b,c,d,e; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e; a /= 3; b += a; e += a; b /= 3; a += b; c += b; c /= 3; d += c; b += c; d /= 3; c += d; e += d; e /= 3; a += e; d += e; cout &lt;&lt; setw(5) &lt;&lt;a; cout &lt;&lt; setw(5) &lt;&lt;b; cout &lt;&lt; setw(5) &lt;&lt;c; cout &lt;&lt; setw(5) &lt;&lt;d; cout &lt;&lt; setw(5) &lt;&lt;e; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f22b163ccd341977bbe557fbcbb7c1/" rel="bookmark">
			文本编辑器vi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文本编辑器的作用
Linux中最常用的文本编辑器
基本格式
命令模式的基本操作
退出vim
复制粘贴
删除
光标移动
插入模式操作
末行模式操作
保存文件及退出vi编辑器
打开文件或读入其他文件内容
忽略字符的大小写
自动缩进
复制保留格式
显示隐藏字符
查找并替换
加密
set帮助
配置文件定制vim的工作特性
文本编辑器的作用 创建或修改文本文件
维护Linux系统中的各种配置文件
Linux中最常用的文本编辑器 vi：类UNIX操作系统的默认文本编辑器
vim：vim是vi文本编辑器（一般简称为vi编辑器）的增强版本
基本格式 vim [OPTION]... ...
命令 选项 文件
vim 文件名不存在 是新建
vim 文件名存在 是修改
如果系统最小化安装vim并没有提前安装可以使用
yum install vim -y 最小桌面
常用选项
+# 打开文件后，让光标处于第#行的行首，+默认行尾
！ 打开上一次的文件
+/PATTERN 让光标处于第一个被PATTERN匹配到的行行首用不多
三种模式
命令模式：默认模式，可以实现移动光标，剪切/粘贴文本 插入模式：用于修改文本
末行模式：保存，退出等搜索代替
命令模式用a、i、o等键可以进入插入模式 输入：进入末行模式
在插入模式下没法直接进入末行模式 需要按esc进入命令模式输入：才可以进入末行模式
在末行模式输入：q退出
w保存
wq保存退出
q！强制退出
wq!强制保存退出
命令模式的基本操作 退出vim ZZ 保存退出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56f22b163ccd341977bbe557fbcbb7c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/740d1013214f5d3e9328936d75e3a972/" rel="bookmark">
			QEMU/KVM虚拟机Win11黑屏问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ＡrchLinux系统下，通过qemu/kvm虚拟机环境安装的win11（UEFI+GPT)，８月份以来一直使用正常。最近看到一个错误想纠正（如下图），考虑到可能是权限问题，便将win11的qcow2文件移动到用户文件夹下，当时可以正常启动，但错误依然没有纠正。
平常用得少，后来不知怎的无法启动，黑屏。首先考虑是调整显示协议和显卡，反复强制关机调整无果。后来想到可能UEFI启动方式问题，通过sudo nano /etc/libvirt/qemu.conf修改也没有找到解决办法。启动时无法显示下图的界面。
灵机一动，考虑到可能是win11的文件系统在强制关机中被破坏，也许克隆一下就能解决。果然，克隆以后可以启动。删除原来的，搞定。什么原理，我也想不明白。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c310e48f0b0cd40881b867d8e640fb1/" rel="bookmark">
			【路径规划】局部路径规划算法——人工势场法（含python实现 | c&#43;&#43;实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 参考资料1. 算法简介2. 算法精讲2.1 引力势场2.2 斥力势场2.3 合力势场 3. 引力斥力推导计算4. 算法缺陷与改进4.1 目标不可达的问题4.2 陷入局部最优的问题4.3 解决方案4.3.1 改进障碍物斥力势场函数4.3.2 道路边界斥力势场 5. python实现6. c++实现 参考资料 路径规划与轨迹跟踪系列算法基于改进型人工势场法的车辆避障路径规划研究基于改进人工势场法的车辆避障路径规划研究 1. 算法简介 1986 年 Khatib 首先提出人工势场法，并将其应用在机器人避障领域， 而现代汽车可以看作是一个高速行驶的机器人，所以该方法也可应用于汽车的避障路径规划领域。 人工势场法的基本思想是在障碍物周围构建障碍物斥力势场，在目标点周围构建引力势场，类似于物理学中的电磁场
被控对象在这两种势场组成的复合场中受到斥力作用和引力作用，斥力和引力的合力指引着被控对象的运动，搜索无碰的避障路径。
更直观而言， 势场法是将障碍物比作是平原上具有高势能值的山峰， 而目标点则是具有低势能值的低谷。
2. 算法精讲 2.1 引力势场 引力势场主要与汽车和目标点间的距离有关, 距离越大, 汽车所受的势能值就越大; 距离越小, 汽车所受的势能值则越小, 所以引力势场的函数为:
U a t t ( q ) = 1 2 η ρ 2 ( q , q g ) (1) \tag{1} U_{a t t}(q)=\frac{1}{2} \eta \rho^{2}\left(q, q_{g}\right) Uatt​(q)=21​ηρ2(q,qg​)(1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c310e48f0b0cd40881b867d8e640fb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f914fbc3277efe870308253a43afc1e/" rel="bookmark">
			【路径规划】全局路径规划算法——A*算法（含python实现 | c&#43;&#43;实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 参考资料1. 算法简介2. 算法精讲2.1 预处理2.2 开始搜索2.3 继续搜索2.4 确定实际路径 3. 算法总结3.1 算法步骤3.2 伪代码 4. python实现5. c++实现 参考资料 Introduction to the A* Algorithm路径规划与轨迹跟踪系列算法Robotic Motion Planning Lectures A星算法详解A星寻路算法路径规划之 A* 算法 1. 算法简介 A*（A-Star)算法是一种静态路网中求解最短路径最有效的直接搜索方法，也是解决许多搜索问题的有效算法，广泛应用于室内机器人路径搜索、游戏动画路径搜索等。它是图搜索算法的一种。
A*算法是一种启发式的搜索算法，它是基于深度优先算法(Depth First Search, DFS)和广度优先算法(Breadth First Search, BFS)的一种融合算法，按照一定原则确定如何选取下一个结点。
启发式搜索算法指的是，从起点出发，先寻找起点相邻的栅格，判断它是否是最好的位置，基于这个最好的栅格再往外向其相邻的栅格扩展，找到一个此时最好的位置，通过这样一步一步逼近目标点，减少盲目的搜索，提高了可行性和搜索效率。
深度优先搜索算法的思想是，搜索算法从起点开始进行搜索(初始状态下待搜索区域内所有结点均未被访问)，与周围所有邻点进行比较，选择其中距离终点最近的点进行存储，然后再以该邻点为基础对比其周围未被访问的所有邻点，仍然选择距离终点最近的邻点存储。若访问结点到达终点或访问完所有结点仍未到达终点，则视为搜索失败。成功搜索所存储的结点连接而成的路径即为起点到终点的路径。
广度优先搜索的原理是，从初始点出发依次访问与它相连接的邻点，访问完毕后再从这些邻点出发访问邻点的邻点,但是要保证先被访问的邻点的邻点要比后被访问的邻点的邻点先访问，直至图中所有已被访问的结点的邻点都被访问到。如果此时图中尚有未被访问的结点，则需要选取一个尚未被访问的结点作为个新的初始点,继续搜索访问，直到图中所有的结点都被访问一遍为止。
因此深度优先算法与广度优先搜索算法从过程上存在较大差异。深度优先算法优先选择离目标点最近的结点，而广度优先搜索算法优先选择离初始点最近的点。基于深度优先算法,能以最快的速度找到一条连接初始点到目标点的路径，但不能保证路径的最优性(例如以路径最短为标准)；广度优先搜索算法则必然能找到最短的路径，但由于需要遍历所有的结点，其计算复杂程度更大。基于这两种算法的优缺点，A*算法基于启发函数构建了代价函数，既考虑了新结点距离初始点的代价，又考虑了新结点与目标点距离的代价。
A*算法使用一个路径优劣评价公式为：
f ( n ) = g ( n ) + h ( n ) f(n)=g(n)+h(n) f(n)=g(n)+h(n)
f(n) 是从初始状态经由状态n到目标状态的代价估计，g(n) 是从初始状态到状态n的实际代价，h(n) 是从状态n到目标状态的最佳路径的估计代价。 A*算法需要维护两个状态表，分别称为openList表和closeList表。openList表由待考察的节点组成， closeList表由已经考察过的节点组成。
2. 算法精讲 2.1 预处理 如图，假设我们需要从A点到目标点，这两点之间有一堵墙。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f914fbc3277efe870308253a43afc1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd149acf28c9c8279bba3f4e2226f949/" rel="bookmark">
			Windows使用scp上传文件到linux服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我不是管理员，所以上传有点麻烦，需要在windows电脑上操作scp命令，
命令格式：上传文件夹带上-r，上传文件就不用带-r了，而且只能上传到tmp目录下，然后再使用mv命令移动到你想要的目录下，而且要用sudo mv才可以
scp -r 你本地的文件目录 服务器的用户名@服务器IP:/tmp 例如我本地的： 命令行要用管理员身份运行，然后将dist目录上传到服务器的tmp目录下
执行后，输入密码即可上传成功：
到服务器上，然后查找一下dist：看到已经存在了
然后将dist目录移动到nginx服务器的根目录下：
sudo mv dist /var/www/html 可以看到已经移动成功，那么再将dist下面的内容全部移动到html下面，再删除dist就好了： 将dist里面的内容全部移动到html下面：
先进入html目录：cd /var/www/html
然后移动命令： sudo mv dist/* ./
然后删除dist目录：sudo rm -rf dist
OK，到此结束，打开服务器的外网ip：即可看到index页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dde66c07132b9e7e3957b30c0966ab53/" rel="bookmark">
			退出当前for循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 退出当前for循环用 continue; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/601d30f02fb72788ab13ff6b0c972a72/" rel="bookmark">
			Jenkins工作空间及自定义工作空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jenkins工作空间路径 在没有设置自定义工作空间目录的前提下
首先我们需要在job新建后，构建一次，这个时候Jenkins会自动创建工作空间
每一个job构建过后，都会生成独立的工作空间，这个工作空间就在Jenkins的安装目录的workspace下
== 使用Jenkins自动生成的工作空间，只需要相对路径 ==
比如项目路径
比如测试报告获取路径
自定义Jenkins工作空间 有的时候，我们并不需要每一个job都需要一个独立的工作空间，比如多个job只需要一个工作空间，我们就需要自定义工作空间路径
后续继续使用Jenkins工作空间相对路径的时候，就会自动衔接上自定义的工作空间路径了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c124a02740b81d02fa26a5a6b8c3d86f/" rel="bookmark">
			确保发那科机器人零点标定（零点复归）精度的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		确保发那科机器人零点标定（零点复归）精度的3种方法 随便聊聊先贴结论一、测试项目二、测试方法三、不同零点复归方法精度测试1、测试过程2、测试数据3、测试结论 四、重做用户及工具坐标系测试1、测试过程2、测试数据3、测试结论 五、FANUC机器人快速零点复归原理研究1、相关系统变量2、FANUC机器人编码器原理3、SRVO-075报警消除原理4、快速零点复归原理 六、零点丢失故障应对方法总结七、注意事项 随便聊聊 最近接触了库卡的机器人，在上电的过程中，本想着需要确认一下机器人各轴零点是否对齐，深入查看后才发现库卡机器人并没有各轴零点标牌对齐一说，而是有一套专门的零点标定工具叫做EMD。
理解下来，大致原理就是如果机器人机械零点丢失，客户需要使用EMD标定工具，工具有一支测头，安装到转轴处。在轴转动的过程中，测头会检测到固定安装在机器人各轴上的V形槽的位置，依次来确认各轴零点位置。
发那科的零点标定方法，则是目视各轴对齐刻度后记录零点数据。当然也有导入零点数据就可以恢复零点的情况，这种情况不在此深究；也有专门的夹具用于零点恢复，但我没用过，也没见别人使用过，也不在此深究。
实际使用过程中，在一些对精度要求较高的应用中，零点数据丢失后，常规的全轴零点复归方法，由于目视对齐刻度始终存在误差的原因，实测零点复归后并不能满足精度要求，在零点复归后还需要微调工艺轨迹，导致停产。
案例：2019年，宁波T公司，客户1台用于车门内板双组份密封胶涂胶的M-710iC/50机器人，由于本体电池电量耗尽导致零点丢失。使用全轴零点复归方法重做零点后，发现涂胶轨迹存在偏差，多次尝试后仍存在偏差，需临时调整轨迹后恢复生产。
由此可见，标准的全轴零点复归方法不能适用于所有场合，发那科全轴零点复归的操作方法，在网上能够找到比较标准的版本，在这儿也不再重复描述；编写此文的目的，倒在于分享一下发那科机器人零点复归背后的原理，以及对应不同故障下的零点复归方法。
先贴结论 1、单纯对刻度的全轴零点复归，可能会导致末端TCP高达10mm以上的位置误差。
2、零点复归精度：快速零点复归 &gt; 单轴零点复归 &gt; 全轴零点复归。
3、全轴零点复归后重做用户坐标系和工具坐标系，也能恢复较高的轨迹精度，但前提是有固定安装的用户坐标系支架和工具坐标系指针。
4、零点丢失后重做零点，要保证精度的话，建议方法如下：
故障情况应对方法本体/附加轴电池掉电使用快速零点标定方法进行零点复归。在此之前需要先设置快速零点参考位；或者将Master Count和Master Position输入Reference Count和Reference Position作为参考数据（均为系统变量）。控制柜电池掉电导入Master文件或手动输入Master Count和Master Position。单轴电机、减速机、编码器拆卸更换使用单轴零点标定法，标定后运行轨迹查看偏差情况；然后分别向两侧以某个分度如0.05度进给，进行多次标定，通过实际轨迹或者之前已经做好的标定点位偏差情况，判断零点标定是否OK。 一、测试项目 二、测试方法 ① 在测试平台上使用胶带固定1根TCP针，设置如下所示的用户坐标系UF1，设置机器人手持笔尖的工具坐标系UT1。
② 激活UF1、UT1，移动手持笔尖与固定TCP针对齐，记录下此时的位置为P[1]。
③ 重做零点标定后，再次激活UF1、UT1，移动手持笔尖与固定TCP针对齐（点位角度相同，即WPR值不变），记录下此时的位置为P[2]，记录下偏差位置Δ=P[1] - P[2]，假定重新标定前为出厂精度，偏差值Δ即可表示再次零点标定后的机器人运动偏差，作为零点复归精度的评判指标。
③ 使用同样的方法测量其他项目，得到各种情况下零点标定精度数据。
④ 分析测量数据，得出结论。
三、不同零点复归方法精度测试 1、测试过程 控制柜断电的情况下，将M-20iA机器人本体电池拆下，等待1min后再装回，模拟本体电池掉电导致零点丢失的故障。
使用全轴零点方法进行零点复归操作后，再次运行程序至P[1]点，如下图所示，机器人到达的位置出现明显偏差；再次尝试后还是存在较大偏差。由此可见，单纯靠各轴对刻度的全轴零点标定方法，标定精度较低。
2、测试数据 由于测试时间有限，每种情况仅测试1~2组数据，供参考。
3、测试结论 零点复归精度：快速零点复归 &gt; 单轴零点复归 &gt; 全轴零点复归。发那科机器人零点丢失后，单纯地仅使用对刻度方式进行全轴零点复归，偏差较大为10mm左右，无法满足某些高精度应用的需求。
四、重做用户及工具坐标系测试 1、测试过程 全轴零点复归后，重新使用3点法设置UF2及UT2，UF2及UT2的数值如下：
① 激活UF1与UT2，测试仅重做工具坐标系的偏差；
② 激活UF2与UT1，测试仅重做用户坐标系的偏差；
③ 激活UF2与UT2，测试同时重做用户及工具坐标系的偏差；
2、测试数据 由于测试时间有限，每种情况仅测试1~2组数据，供参考。
3、测试结论 全轴零点复归后，同时重做用户及工具坐标系，能够满足精度要求；仅重做用户坐标系或者仅重做工具坐标系，都无法满足精度要求。
但该方法在实际应用时有一定难度，一方面作为用户坐标系标记的坐标系支架位置可能会发生变动；另一方面某些应用多采用直接输入TCP方法，无法再次示教工具坐标系。
因此实际应用中，还是要靠保证零点复归精度来保证轨迹精度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c124a02740b81d02fa26a5a6b8c3d86f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32514b920672ab374b7a67f4e7222f62/" rel="bookmark">
			解决git cherry-pick 冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景 两个分支
mastermaster_test master_test 分支 cherry-pick到 master分支 时遇到冲突
解决方案 查看commit id 先将本地的代码保存 或 提交打开pycharm终端git log 查看 cherry-pick 冲突的那一笔 commit id
=或者直接在gitlab上复制也可以=
切换到master分支cherry-pick 切换到master分支 git checkout master -在master上cherry-pick
git cherry-pick xxx ( xxx 前面查看到的提交a的commit id) master分支解决冲突 =这个时候会提示冲突=
输入git status可以查看当前冲突的文件， 输入git diff，会在代码中生成冲突提示，之后根据冲突提示开始逐个文件解决冲突
使用pycharm查看冲突的文件手动解决冲突即可（有冲突的文件是红色的并带有波浪线）
冲突解决完成后master分支继续 cherry-pick 将解决冲突后的文件 add
鼠标右键单击解决完冲突的文件，然后添加
继续cherry-pick
git cherry-pick --continue 如果有冲突则继续解决，直到提示成功
最后push到master即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f774694b28379e9bf14ac44d14b199c9/" rel="bookmark">
			VxLAN网络虚拟化技术详解（HCIE）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标：
1、了解VxLAN解决的问题
2、了解VxLAN的专业术语NVO3、NVE、VTEP、VNI
3、通过实验来深入了解VxLAN
4、了解VxLAN的报文封装
VxLAN的由来
VPN种类大划分：
为什么会有VxLAN以及VXLAN解决的问题？
一、Vxlan的基本概念：
1、NVO3&amp;NVE
2、VTEP
3、VNI
Vxlan数据封装与转发
Vxlan实验：
1、实验准备：
2、 网络拓扑：
二·、Vxlan报文格式
Vxlan报头：
未完待续。。。。。。
学习目标： 1、了解VxLAN解决的问题 2、了解VxLAN的专业术语NVO3、NVE、VTEP、VNI 3、通过实验来深入了解VxLAN 4、了解VxLAN的报文封装 VxLAN的由来 VxLAN 全称是 Visual eXtensible Local Area Network（虚拟扩展本地局域网），VxLAN出来有很多年了（二层VPN），最早是由vmware联合cisco开发的隧道技术，用于服务器虚拟化情况下实现二层的隧道技术，现在VxLAN已经标准化了，主流厂家在数据中心首选的大二层技术。
VPN种类大划分： 二层vpn：封装的对象是数据帧，则称为二层VPN，有Vxlan、TRILL、L2TP、PPTP、VPLS。
三层vpn：封装的对象是数据包，则称为三层VPN，有IPsec、GRE、DSVPN、MPLS-VPN。
ipsec-vpn隧道模式，则3层VPN。
ipsec-vpn传输模式，只封装IP之上的内容。
应用层VPN：SSL VPN。
MPLS-VPN：三层。
VPLS：2层。
VxLAN网络虚拟化技术，由IETF定义的NVO3（Network virtualization over layer 3），采用L2-over-L4（MAC-in-UDP）的报文封装模式，本质就是把二层的报文用三层协议进行封装，可以实现二层网络在三层范围内进行扩展，同事满足数据中心大二层虚拟迁移和多租户的需求。
VxLAN是一种无控制平面（建立隧道两端不需要跑控制层面协议维护隧道，都是人为控制的），利用底层IP网络实现二层通信的隧道技术。
底层的IP网络称为Underlay网络，Vxlan则称为Overlayer网络。
为什么会有VxLAN以及VXLAN解决的问题？ 传统网络两台虚拟机同一个网段IP，只能放在同一个网络下，有了Vxlan后，放在不同网络中也能互访，虚拟机热迁移只要地址不变就能互访。本质上来讲Vxlan就是一个隧道技术（二层隧道），业务方面来讲Vxlan就是一个网络虚拟化技术，通过VNI来区分不同的业务并且不同VNI之间做隔离，VLAN的取值1-4094，VNI取值1-16777215完全解决了VLAN不够用问题，公有云就是通过Vxlan实现不同租户之间隔离。
一、Vxlan的基本概念： 1、NVO3&amp;NVE NVO3：基于三层IP overlay网络构建虚拟网络技术系统成为NOV3。
NVE：执行Vxlan封装和解封装的设备都统称为NVE。
2、VTEP VTEP：每一个NVE至少有一个VTEP（类似于OSPF的设备必须得有一个Router ID标识），VTEP既用于标识设备，也用于标识一条Vxlan隧道，由2个VTEP地址唯一确定一条Vxlan隧道，所以VTEP的地址要求全网可达。
3、VNI VNI（Vxlan网络标识符）：类似于Vlan ID，一个VNI代表一个租户，属于不同VNI的虚拟机之间不能直接进行二层通信。
Vxlan数据封装与转发 Vxlan实现PC1和PC2在一个二层内的通信
传统网络两台虚拟机同一个网段IP，只能放在同一个网络下，有了Vxlan后，放在不同网络中也能互访，虚拟机热迁移只要地址不变就能互访。 Vxlan实验： 1、实验准备： 模拟器使用CE系列交换机，支持VxLAN实验。
CE68和CE128都是用这个镜像，但VxLAN只能用CE12800做。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f774694b28379e9bf14ac44d14b199c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/926a0954edd65b850c9f0d31b2544632/" rel="bookmark">
			OSError: Could not find lib c or load any of its variants [].
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac在安装chineseocr_lite-onnx的时候，配置环境遇到了上边的问题，这个错误是shapely这个包在按流程下载的时候是shapely1.7.0，用python -m pip uninstall shapely 卸载后，用python -m pip install shapely 安装了最新版之后，整个程序可以使用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c0c75c8db107b6a10b307c76edf2e9/" rel="bookmark">
			Packet Tracer配置交换机远程登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们先在工作区放置一台电脑和一台交换机并且连接起来：
然后给电脑设置IP地址，我这里设置的IP地址为192.168.31.1，子网掩码软件会自动填写的：
然后我们进入交换机配置界面，打开交换机管理端口并配置IP地址，然后设置登陆密码和特权密码。
这里我们先点击交换机，然后点击命令行并回车进入普通用户模式：
然后输入enable后回车进入特权模式：
再输入config terminal后回车进入全局配置模式：
进入全局模式后，我们先给交换机改个名字，输入hostname xiaoxing（xiaoxing就是我们要改的名字，想改成什么就输入什么）然后回车：
我们交换机的名字已经改好了，然后我们进入交换机的管理端口。因为我们交换机默认的管理端口为vlan 1，所以我们输入interface vlan 1后回车进入管理端口
进入端口后我们就要设置IP地址了，我这里设置的IP地址为192.168.31.10，然后子网掩码是255.255.255.0。所以我们输入ip address 192.168.31.10 255.255.255.0后回车：
这里我们IP地址就设置好了，现在我们来打开端口。输入no shutdown后回车：
端口我们已经设置好了，现在来设置特权模式密码。我们先从接口模式退出，返回全局模式。输入exit后回车：
然后我这里设置的密码为5201314，所以输入enable secret 5201314后回车：
特权模式密码设置好之后，现在来为VTY线路配置参数，我设置为允许同时有6个用户分别在0~5号VTY线路上实施Telnet远程登陆，输入line vty 0 5后回车：
现在我们就进入线程模式了，然后我们在线程模式里面设置登陆密码，我这里设置为1314520，输入password 1314520后回车：
密码设置好了，现在我们让密码生效。输入login后回车：
现在交换机所有的设置就已经设置好了，我们现在可以在电脑实现远程登陆了，点击电脑然后点击桌面进入命令提示符：
输入telnet 192.168.31.10进行远程登陆，这里的IP地址就是之前我设置的交换机管理端口的IP地址。然后会让你输入密码，密码是不会显示出来的（输了回车就好了），我这里第一次是输错了的，所以我这里一共输了两次登陆密码（登陆密码是在线程里面设置的那个密码）。然后我这里进入特权模式，也是输了密码的，因为我刚刚设置了密码，然后最后我进入的全局配置模式，现在在这里配置交换机，和在交换机里配置是一样的效果啦。
这就是我们实现交换机远程登陆的全过程咯，我们有缘再见！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4cbea0b5fd8e8ead3d4c64fa03bd8d3/" rel="bookmark">
			LeetCode | 1851.包含每个查询的最小区间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode | 1851.包含每个查询的最小区间 给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示第 i 个区间开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 righti - lefti + 1 。
再给你一个整数数组 queries 。第 j 个查询的答案是满足 lefti &lt;= queries[j] &lt;= righti 的 长度最小区间 i 的长度。如果不存在这样的区间，那么答案是 -1 。
以数组形式返回对应查询的所有答案。
示例 1：
输入：intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5] 输出：[3,3,1,4] 解释：查询处理如下： - Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。 - Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。 - Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。 - Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。 示例 2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4cbea0b5fd8e8ead3d4c64fa03bd8d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79b32c863e34c95acf0446f844b77111/" rel="bookmark">
			MATLAB 支持向量机（SVM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB 支持向量机（SVM）详细解释（含代码） 基础线性可分最大间隔超平面 SVM分类基本代码和工具二分类线性非线性 多分类详细解释 基础 线性可分 简单来讲就是如何将两个数据用点、直线、平面分开。。。。。
二维空间中，要分开两个线性可分的点集合，我们需要找到一条分类直线即可，
最大间隔超平面 通俗来讲，在这个二维平面中，可以把两类点的分开的直线有很多条，那么这些直线中，哪一条才是最好的呢？也就是如何选择出一条最好的直线呢？
先看橙色的点，如果这些点到分类直线的距离越大，分类直线也就越远离橙色的点，那么再来一个新的点，如果这个点是依照橙色点集合的特性产生的（也就是它不是一个相对于橙色点集合很奇异的点），那么这个点也很可能和橙色的点集合一样，分布在直线的同一侧。分布在同一侧，表明它和橙色集合点属于同一个类别。用同样的思想，图4中，对于灰色的集合点，这条分类直线离它们的距离也要越远越好。所以找最优分类线，就是要找到这条一条直线，使它到两个类别点的距离越大越好。
因此便可得到某根距离离两边都累计最远的直线，即最大分隔超平面。 上述也叫硬间隔最最大化，能够用直线将两者分开。
SVM分类 基本代码和工具 工具：1、MATLAB 2020a；2、fitcsvm
二分类 fitcsvm：fitcsvm训练或交叉验证支持向量机（SVM）模型在低维或中维预测数据集上的一类和二类（binary）分类。fitcsvm支持使用核函数映射预测数据，并支持通过二次规划实现目标函数最小化的顺序最小优化（SMO，sequential minimal optimization）、迭代单数据算法（ISDA，iterative single data algorithm）或L1软边界最小化。
代码:
线性 clc clear all %设置两类不同数据 A = [3,7;6,6;4,6;5,6.5]; B = [1,2;3,5;7,3;3,4;6,2.7;4,3;2,7]; C = [A;B];%两类数据合并 %设置不同类别标签 table = [true true true true false false false false false false false]; D = nominal(table); %%数据集和标签 sd=C; Y=D; %% 原始数据图像 subplot(1,2,1) gscatter(sd(:,1),sd(:,2),Y,'rg','+*'); %% SVM SVMModel=fitcsvm(sd,Y,'KernelFunction','linear'); [lable,score]=predict(SVMModel,sd); %% 画图 subplot(1,2,2) h = nan(3,1); h(1:2) = gscatter(sd(:,1),sd(:,2),Y,'rg','+*'); hold on h(3) =plot(sd(SVMModel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79b32c863e34c95acf0446f844b77111/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5636464b5e257cf4b1604334dc161e3/" rel="bookmark">
			SpringMVC的视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户
SpringMVC视图的种类很多，默认有转发视图和重定向视图
当工程引入jstl的依赖，转发视图会自动转换为JstlView
若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView
1、ThymeleafView 当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转
@RequestMapping("/testHello") public String testHello(){ return "hello"; } 2、转发视图 SpringMVC中默认的转发视图是InternalResourceView
SpringMVC中创建转发视图的情况：
当控制器方法中所设置的视图名称以"forward:"为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"forward:"去掉，剩余部分作为最终路径通过转发的方式实现跳转
例如"forward:/"，"forward:/employee"
@RequestMapping("/testForward") public String testForward(){ return "forward:/testHello"; } 3、重定向视图 SpringMVC中默认的重定向视图是RedirectView
当控制器方法中所设置的视图名称以"redirect:"为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"redirect:"去掉，剩余部分作为最终路径通过重定向的方式实现跳转
例如"redirect:/"，"redirect:/employee"
@RequestMapping("/testRedirect") public String testRedirect(){ return "redirect:/testHello"; } 注：
重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径
4、视图控制器view-controller 当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示
&lt;!-- path：设置处理的请求地址 view-name：设置请求地址所对应的视图名称 --&gt; &lt;mvc:view-controller path="/testView" view-name="success"&gt;&lt;/mvc:view-controller&gt; 注：
当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：
&lt;mvc:annotation-driven /&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fdea3e1abd47306523c601971f69d2a/" rel="bookmark">
			leetcode--三数之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请
你返回所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
示例 1：
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fdea3e1abd47306523c601971f69d2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2edc91e15339ff5b0d0d7d241127dcb0/" rel="bookmark">
			【MySQL】MySQL 链接数以及max_used_connections、max_connections和max_user_connections区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看当前MySQL 链接数 connected SHOW STATUS LIKE 'Threads%' Threads_connected显示的数值就是当前的连接数
查看MySQL系统最大链接数 max_connections show variables like '%max_connections%' 该参数设置过小的最明显特征是出现”Too many connections”错误；
全局每个用户最大连接数 max_user_connections show variables like 'max_user_connections' 默认情况值为 0。代表：不限制用户资源的。
设置全局每个用户最大连接数
set global max_user_connections=1 响应的连接数 max_used_connections show variables like 'max_connections' 最大连接数 show status like 'max_used_connections'响应的连接数。 mysql&gt; show variables like ‘max_connections‘; +-----------------------+-------+ | Variable_name　| Value | +-----------------------+-------+ | max_connections | 256　| +-----------------------+-------+ mysql&gt; show status like ‘max_used_connections‘; +-----------------------+-------+ | Variable_name　| Value | +----------------------------+-------+ | max_used_connections | 256| +----------------------------+-------+ max_used_connections / max_connections * 100%（理想值≈ 85%）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2edc91e15339ff5b0d0d7d241127dcb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3a0ee75014766af87c12879c8fac994/" rel="bookmark">
			MOS驱动自举电容和限流电阻的选取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自举电容选取 最近做逆变时出现了异常，使用2104驱动MOS管
蓝色为滤波后双端带载时出现的波形，一端带载时没有问题
放大波形后发现输出波形在占空比满值时垮掉，产生严重的震荡 可以看到波形顶部斜向下，我们可以推断是驱动自举电容值偏小，当占空比增大时无法为高端MOS提供足够的电荷。
下图为2104的驱动波形，在占空比增大时，电平降低
当电容值偏大后，占空比增大，驱动波形不能达到最低值，MOS管不能完全关断，造成损耗。
电容取值合适后输出带载波形
限流电阻对MOS的影响 一般都习惯在栅极串一个电阻，电阻提高稳定性的同时减缓了MOS的开关过程
蓝色为串10欧姆电阻的栅极波形
黄色为0欧姆电阻
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34db7072120fd8d95b574f283cb9fec8/" rel="bookmark">
			如何用JS实现页面的全屏滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全屏滚动 说白了就是：每张图都占满整个浏览器窗口，当滑动鼠标或者触摸板时，图片切换。
主要使用的方法 addEventListener() 方法用于向指定元素添加监听事件。
Mousewheel 鼠标滚轮。
我们需要用addEventListener() 方法，来监听到 Mousewheel 的滚动 。然后通过点击小圆点再去实现图片的切换效果。
实现效果展示 那么废话不多说直接上代码，这些图片在（极简壁纸）
HTML部分 &lt;div class="container"&gt; &lt;div class="section section1"&gt; &lt;h1&gt;第1屏&lt;/h1&gt; &lt;/div&gt; &lt;div class="section section2"&gt; &lt;h1&gt;第2屏&lt;/h1&gt; &lt;/div&gt; &lt;div class="section section3"&gt; &lt;h1&gt;第3屏&lt;/h1&gt; &lt;/div&gt; &lt;div class="section section4"&gt; &lt;h1&gt;第4屏&lt;/h1&gt; &lt;/div&gt; &lt;div class="section section5"&gt; &lt;h1&gt;第5屏&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;ul class="controls"&gt; &lt;li class="active"&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; CSS部分 &lt;style&gt; * { padding: 0; margin: 0; } html, body { width: 100%; height: 100%; overflow: hidden; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34db7072120fd8d95b574f283cb9fec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb92b06bd641087c96476abfddd9342/" rel="bookmark">
			RobotStudio实现喷漆、打磨等功能（曲面路径生成与仿真）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务介绍 在Robotstudio中导入一个CAD模型，如汽车外壳等复杂曲面模型。使用Robotstudio进行路径规划，实现机械臂的汽车外壳的喷漆功能。
所用环境 实现本功能，使用到了ABB公司发布的ABB Machining PowerPac功能包。该功能包可以实现的功能包括打磨产品（规则的方形体）、涂胶、火焰切割、卫浴打磨、复杂的大型曲面体打磨、磨边等。
下载链接如下：
官网：https://robotapps.blob.core.windows.net/apps/d2d4e3fc-1810-4c05-937d-8154d31fca13machiningpowerpac6.04.zip网盘：https://pan.baidu.com/s/1BbhjmIAKT3c7yryCDRXtsQ?pwd=abbb 提取码: abbb 如果链接失效，该插件下载方式如下图，找到插件后，在右侧点击链接下载。
（由于插件页面无法上下滚动，所以如果屏幕看不到下面的下载链接，还需要调高屏幕分辨率或者把缩放改成100%，下载后再改回来即可）
下载后为压缩包格式，解压后运行其中exe再进行解压，注意这次解压不要选带中文的路径，找到解压后的exe运行即可安装。
该插件为6.04版本，支持Robotstudio6.04及以上版本使用，低于此版本的使用插件时可能会出现兼容性问题，建议使用Robotstudio 6.08，该版本对于大多数插件都有较好的兼容性。使用时双击插件即可加载，加载成功后在Add-Ins栏中即可看到Machining 6.04插件。
实现方法 1. 创建工件坐标与工具 （1）首先创建工件坐标。
（2）然后创建工具。
侧面加工与端面加工，在图中可以直观理解为，使用圆柱的侧面、底面端面加工。
工具的类型如下：
T_Cutter：T型刀Chamfger_Cutter：倒角铣刀Flame_Cutter：火焰切割枪Swallow_Cutter：燕尾槽铣刀Ball_Cutter：球型铣刀None：无形状 对于喷漆作业来说，选择端面加工；使用T型刀，调整接触圈高度为喷头到工件的距离。
（3）新建一个空程序组
2. 提取加工曲面 （1）新建几何
（2）设置曲线类型
类型：
Projection Geometry：投影几何Intersection Geometry：交叉口几何UV Curve：UV曲线Edge Curve：边缘曲线Customized Curve：自定义曲线 对于喷漆来说，我们选择使用Intersection Geometry复杂曲线。
（3）选择加工区域
（4）指定切割平面
4. 新建操作 （1）新建一个操作
（2）设置外轴移动模式为：固定距离模式
（3）点击刀具插补设置，点击可达率，在图表中选择一个100%可达率的角度，然后点击应用。
5. 模拟仿真 本博客文章首先发布于个人博客网站：https://www.mahaofei.com/，欢迎大家访问。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/204/">«</a>
	<span class="pagination__item pagination__item--current">205/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/206/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>