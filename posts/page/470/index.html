<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aabf789d975db06a236a9458d668efc/" rel="bookmark">
			linux同时连接内外网的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为工作的原因，经常会用有线网卡连接服务器进行配置，无线网卡上外网。
查看当前网关信息
pipci@ubuntu:~$ ip route show
default via 192.168.2.1 dev enp2s0 proto static metric 100
default via 192.168.8.1 dev wlp3s0 proto static metric 600
169.254.0.0/16 dev wlp3s0 scope link metric 1000
192.168.2.0/24 dev enp2s0 proto kernel scope link src 192.168.2.120 metric 100
192.168.8.0/24 dev wlp3s0 proto kernel scope link src 192.168.8.5 metric 600
可以看到前两行default开头的就是默认网关。
192.168.2.1是我的有线网关，192.168.8.1是wifi网关。
默认有线网关的优先级更高所以导致无线不能上外网。
解决办法是让系统只有一个默认网关，有两种方法。
方法1：
最简单的方法：Ubuntu 16.04 实现有线 无线同时用
还是在有线连接的IPv4标签下，网关不用动，点击路由选项，选上 仅为此连接的资源使用 后保存，从新连接就可以正常有线 无线同时用了，编辑的时候有线必须先断开连接，要不不能保存
方法2：
1、鼠标点击-&gt;Gnome顶栏-&gt;网络图标-&gt;有线设置 打开网络 #我的桌面环境是Gnome
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aabf789d975db06a236a9458d668efc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad9a5d720bfcb7526d76853e8a54c3b/" rel="bookmark">
			Manjaro(archLinux)系统时间快8小时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 不知道为什么,之前还好好的,但是突然打开电脑的时候时间快了8小时,解决方案如下:
设置时区: sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai/etc/localtime 安装openNTPD: sudo pacman -S openntpd 重启openNTPD: systemctl restart openntpd 设置开机启动: systemctl enable openntpd 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb41a578b7cd7c9ae12a62597588aea9/" rel="bookmark">
			数据仓库维度建模步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在商业智能项目的实施过程中，维度建模技术和企业数据仓库建模是两种不同的方法论，以下是以应用驱动、提供快速原型的商业智能项目的实施和规划过程中使用的维度建模方法时的标准实施过程。具体到项目中则根据项目的规模及所涉及的业务范围而有所补充或裁减。
1. 商业智能项目规划
a) 数据仓库项目的定义及范围
b) 项目准备评估
c) 业务合理性证明
2. 商业智能项目业务需求定义
a) 业务需求收集
b) 业务需求审查
c) 数据审计
3. 数据仓库逻辑设计
3.1. 维度建模
维度建模是一种逻辑设计技术，该技术试图采用某种直观的标准框架结构来表现数据，并且允许高性能存取。
优点：
a) 维度建模是可预测的标准框架。允许数据库系统和最终用户查询工具在数据方面生成强大的假设条件，这些数据主要在表现和性能方面起作用。
b) 星型连接模式的可预测框架能够忍受不可预知的用户行为变化。
c) 具有非常好的可扩展性，以便容纳不可预知的新数据源和新的设计决策。可以很方便在不改变模型粒度情况下，增加新的分析维度和事实，不需要重载数据，也不需要为了适应新的改变而重新编码。较好的扩展性意味着以前的所有应用都可以继续运行，并不会产生不同的结果。
3.2. 定义数据仓库总线结构
a) 业务驱动维度建模
b) 数据仓库总线结构矩阵
c) 一致性维度
d) 一致性事实
一致性维度和一致性事实是数据仓库的“总线”
e) 单元数据集市
购货订单，装船，付款等，来源于单个事务
f) 多元数据集市
客户利润率，其中描述收益的传统源必须与描述成本的传统源组合在一起使用。来源于多个事务，应该从单元数据集市开始创建数据集市。
g) 事务模式数据集市
h) 周期快照数据集市
i) 累计快照数据集市
3.3. 定义高级数据模型逻辑图
3.4. 维度模型的设计过程
a) 选取业务处理
b) 定义粒度
c) 选定维度
d) 确定事实
3.5. 源数据－目标数据映射
即ETL规则定义，设计数据仓库与数据源之间的逻辑映射与转换关系。
a) 维度表映射
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb41a578b7cd7c9ae12a62597588aea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83a2c682ce191365bb73626970ffe8b0/" rel="bookmark">
			使用ArcGIS Pro发布高程服务（dem）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果自己有一些高精度dem数据，可以在ArcGIS Pro中将这些dem数据进行切片缓存，然后发布到portal中，以高程服务的形式进行调用。在Portal中直接使用，或者通过Javascript API进行调用。
整个发布过程主要分为两步，一是创建高程数据的切片，二是发布高程切片。由于一般创建的高程服务是与普通的二维地图服务或者影像底图服务一起使用，所以高程服务的切片方案必须和二维底图、影像底图服务的切片方案相同，因此需要根据自己的数据情况进行判断，选择不同的切片生成方法。
一般的创建高程切片情况如下：
（1）采用与ArcGIS online相同即Web Mecator投影坐标系（WKID:3857）的切片方案，需要用到两个工具Manage tile cache和Export Tile Cache工具；
（2）采用自己的坐标系，比如CGCS2000、西安80、北京54、UTM等坐标系，需要先使用Generate Tile Cache Tiling Scheme工具创建切片方案，然后再使用Manage tile cache和Export Tile Cache工具创建切片。
1.Generate Tile Cache Tiling Scheme工具创建切片方案 如果是Web mecator坐标系，则跳过这步，直接进入第二步。
找到“数据管理工具箱——Tile Cache——Generate Tile Cache Tiling Scheme工具”
设置好输入和输出之后，下面的Tile Format要设置为LERC compression格式，有限误差栅格压缩（LERC）是一种有效的有损压缩方法，适合用于具有较大像素深度的单波段或高程数据，例如浮点，32位，16位或12位数据。要创建高程服务的切片，一定要设置这个选项。
2.使用Manage tile cache工具 找到“数据管理工具箱——Tile Cache——Manage Tile Cache工具”
注意在Input tiling scheme那栏：
（1）如果采用Web Mecator投影坐标系（WKID:3857），则直接选择Elevation Tiling Schema；
（2）如果采用自己的坐标系，则选择import schema，下面会多出一个选项，选中自己上一步创建出来的xml文件即可。
最后点击Run运行工具即可，在指定的文件件会得到已经做好的切片。
3.使用Export Tile Cache工具导出切片包 同一个工具集下面，打开Export Tile Cache工具：
创建出来的结果如下图：
4.将tpk包上传并发布 可以在portal中“内容”页面，直接add item，选择我的计算机中tpk文件，设置好名称和标签之后，会自动上传并发布。
点击add item后，会自动上传tpk文件，并将其发布为高程服务：
发布完成可以打开服务，在scene viewer中进行浏览。我这里是以UTM坐标系为示例，浏览时就打开的是local scene模式，如果是Web mecator坐标系，则在Globe Scene模式进行浏览。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88a90b4a2732dd22a10241e0b4f0bb88/" rel="bookmark">
			【ps】ps命令(process status)、jobs命令(查看后台程序)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 ps命令简介1．命令格式2．命令功能3．命令参数4.常用命令 jobs命令 ps命令 简介 Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。
要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。
ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 top 工具。
kill 命令用于杀死进程。
1．命令格式 ps[参数] 2．命令功能 用来显示当前进程的状态
3．命令参数 a 显示所有进程-a 显示同一终端下的所有程序-A 显示所有进程c 显示进程的真实名称-N 反向选择-e 等于“-A”e 显示环境变量f 显示程序间的关系-H 显示树状结构r 显示当前终端的进程T 显示当前终端的所有程序-u 指定用户的所有进程-au 显示较详细的资讯-aux 显示所有包含其他使用者的行程-C&lt;命令&gt; 列出指定命令的状况–lines&lt;行数&gt; 每页显示的行数–width&lt;字符数&gt; 每页显示的字符数–help 显示帮助信息–version 显示版本显示-f 显示所有信息 4.常用命令 ps -A / ps -e //显示所有进程信息 ps -u root //显示指定用户信息 ps -ef //显示所有进程信息，连同命令行 ps -ef|grep ssh // ps 与grep 常用组合用法，查找特定进程 ps -l // 将目前属于您自己这次登入的 PID 与相关信息列示出来 ps aux | egrep '(cron|syslog)' // 找出与 cron 与 syslog 这两个服务有关的 PID 号码 jobs命令 jobs -l //查看所有后台任务 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a743eb9619e1ec456cea630a1b5d4a/" rel="bookmark">
			【netstat】netstat命令(显示网络相关信息)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1．命令格式2．命令功能3．命令参数4.netstat输出详解5.常用命令组合 1．命令格式 netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][–ip]
2．命令功能 netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。
3．命令参数 -a或–all 显示所有连线中的Socket。-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。-c或–continuous 持续列出网络状态。-C或–cache 显示路由器配置的快取信息。-e或–extend 显示网络其他相关信息。-F或–fib 显示FIB。-g或–groups 显示多重广播功能群组组员名单。-h或–help 在线帮助。-i或–interfaces 显示网络界面信息表单。-l或–listening 显示监控中的服务器的Socket。-M或–masquerade 显示伪装的网络连线。-n或–numeric 直接使用IP地址，而不通过域名服务器。-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。-o或–timers 显示计时器。-p或–programs 显示正在使用Socket的程序识别码和程序名称。-r或–route 显示Routing Table。-s或–statistice 显示网络工作信息统计表。-t或–tcp 显示TCP传输协议的连线状况。-u或–udp 显示UDP传输协议的连线状况。-v或–verbose 显示指令执行过程。-V或–version 显示版本信息。-w或–raw 显示RAW传输协议的连线状况。-x或–unix 此参数的效果和指定”-A unix”参数相同。–ip或–inet 此参数的效果和指定”-A inet”参数相同。 4.netstat输出详解 [root@localhost ~]# netstat （添加-p后还有一列PID/Program name） Active Internet connections (w/o servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 268 192.168.120.204:ssh 10.2.0.68:62420 ESTABLISHED udp 0 0 192.168.120.204:4371 10.58.119.119:domain ESTABLISHED Active UNIX domain sockets (w/o servers) Proto RefCnt Flags Type State I-Node Path unix 2 [ ] DGRAM 1491 @/org/kernel/udev/udevd unix 4 [ ] DGRAM 7337 /dev/log unix 2 [ ] DGRAM 708823 unix 2 [ ] DGRAM 7539 unix 3 [ ] STREAM CONNECTED 7287 unix 3 [ ] STREAM CONNECTED 7286 [root@localhost ~]# 从整体上看，netstat的输出结果可以分为两个部分：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a743eb9619e1ec456cea630a1b5d4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c77242530490e2b994cd84da90f567ba/" rel="bookmark">
			switch case语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.switch后面的括号里面只能是自动类型转换成int,(short、char、int、byte)
2.case后面只能跟自动类型转换成int的常量或者常量表达式
3.case后面的常量必须唯一
4.case和default顺序可以交换，前提是case和default加了break
5.在case后面如果有多条语句，可以不用加花括号
举第1个栗子：输入两个数和运算符，输出结果
package com.c_String; import java.util.Scanner; import java.util.Scanner; public class switchcase3 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println("请输入两个整数"); int num1 = sc.nextInt(); int num2 = sc.nextInt(); System.out.println("请输入运算符"); char a = sc.next().charAt(0); switch(a) { case '+':System.out.println(num1+"+"+num2+"="+(num1+num2));break; case '-':System.out.println(num1+"-"+num2+"="+(num1-num2));break; case '*':System.out.println(num1+"*"+num2+"="+(num1*num2));break; case '/': if(num2==0) { System.out.println("除数不能为0"); break; } System.out.println(num1+"/"+num2+"="+(num1*1.0/num2));break; default:System.out.println("运算符有误"); } } } 举第2个栗子：要求通过程序 输出输入的日期为2019年的第几天。
package com.c_String; import java.util.Scanner; public class swichcaseDemo { public static void main(String[] args){ Scanner scan = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c77242530490e2b994cd84da90f567ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce9a7cb5132968f4c2e47a822a24a848/" rel="bookmark">
			无人驾驶技术——ROS进阶之python实现串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 环境PC与开发板1串口通信示例PC与开发板2串口通信示例测试USB接口编译运行接收到的结果显示： 环境 Ubuntu16.04
ROS Kinetic
ROS环境配置可参考
无人驾驶技术——【ROS】ROS环境配置和Python版talk-linstener实现
Ubuntu下串口通信入门可参考：
ubuntu16.04 下Python串口通信配置与代码实现（PL2303串口）
本文主要是根据实际的需求，在基本的串口通信上进行修改，改成在ROS环境下能调用的版本。
PC与开发板1串口通信示例 #usr/bin/python3 # -*- coding: utf-8 -*- import rospy from std_msgs.msg import String import serial import time def gbk_2_number(strsrc): result = [] for i in range(0,len(strsrc),2): tmp = strsrc[i:i+2] result.append(tmp) #print(tmp, result) tmp1 = '' for i in range(len(result)): if result[i]== '2e': tmp1 += '.' else: tmp1 += str(int(result[i]) - 30) #print('tmp: ',tmp1) return tmp1 pub = rospy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce9a7cb5132968f4c2e47a822a24a848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/382c18ee38ed5867741135d867e1f17f/" rel="bookmark">
			8、TM4单片机的滴答定时器，及利用定时器精确延时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们日常使用单片机的时候，延时一般采用循环的方式，但是这样的方式只能用于粗略的延时，但我们需要精准的时间控制的时候，便需要利用定时器获得精确的延时。
本次采用TM4内的滴答定时器。
文章目录 1、滴答定时器使用（1）初始化代码（2）解释 2、利用定时器进行延时的方法1、精髓：micros()函数2、利用micros()实现延时 测试例程1测试例程2 1、滴答定时器使用 滴答定时器结构比较简单，在TM4内部是一个24位自减的计数器。
（1）初始化代码 SysTickPeriodSet(SysCtlClockGet()/1000); // 1ms SysTickIntRegister(SysTick_IntHandler); SysTickIntEnable(); SysTickEnable(); （2）解释 1、首先进行周期设置，用系统频率除以1000，表示1ms的中断。
计算方法：定时器的工作原理便是在系统时钟驱动下进行计数，假设系统时钟频率是10KHz，代表1秒钟可以计10000个数，即：即计一个数的时间t = 1/10000 s = 0.1 ms，那么如果我要设置一个一毫秒的中断，即需要数10个数，因为10*(1/10000) = 1/1000 s = 1ms。
因此对于SysTickPeriodSet()这个函数来说，我需要一毫秒的中断，便将系统时钟除以1000作为参数传进去即可。
2、然后设置中断函数的地址
即SysTick_IntHandler便是中断处理函数的函数名称，代表该函数的地址。
3、使能中断，打开定时器
SysTickIntEnable(); SysTickEnable(); 4、写中断处理函数
这里是设置了一个全局变量，每进入一次中断便将其加1。
void SysTick_IntHandler(void) { System_Time_ms++; } 5、测试：见文末测试例程1。
2、利用定时器进行延时的方法 1、精髓：micros()函数 首先我们需要知道系统的当前精确时间，这里实现了一个micros()函数，以微秒为单位。
uint32_t micros(void) { register uint32_t ms, tick; do{ ms = System_Time_ms; tick = HWREG(NVIC_ST_CURRENT); }while(ms != System_Time_ms); return (ms+1)*1000 - tick/usTicks; } 在这个函数中，因为滴答定时器的中断是1ms，所以System_Time_ms便是系统运行的ms数，HWREG(NVIC_ST_CURRENT)是针对寄存器的操作，获得当前滴答定时器内部的计数值。usTicks = Clock/1000000，所以tick/usTicks = tick*(1000000/Clock)，即将定时器计数值转换为实际的us数，然后通过(ms+1)*1000 - tick/usTicks的运算，即得到了us级的系统时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/382c18ee38ed5867741135d867e1f17f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b632d6349e1f9552b33cd0e7d34ff328/" rel="bookmark">
			exists 的自由之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解释与比较：
in 语句：
只执行一次,确定给定的值是否与子查询或列表中的值相匹配。in在查询的时候，首先查询子查询的表，然后将内表和外表做一个笛卡尔积(翻译：笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尓积（Cartesian product），又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员。)，然后按照条件进行筛选。所以相对内表比较小的时候，in的速度较快。
例：
select a.* from dual a where a.dummy in (select b.dummy from dual b);
执行流程：
首先会执行from语句找出dual表中的数据，然后执行 in 里面的子查询，再然后将查询到的结果和原有的dual表做一个笛卡尔积，再根据我们的a.dummy IN b.dummy 的条件，将结果进行筛选（既比较dummy 列的值是否相等，将不相等的删除）。最后，得到符合条件的数据。
EXISTS语句：
执行dual.length次,指定一个子查询，检测行的存在。遍历循环外表，然后看外表中的记录有没有和内表的数据一样的。匹配上就将结果放入结果集中。
例：
select a.* from dual a where exists (select * from dual b where a.dummy = b.dummy);
执行流程：
首先，我们先查询的不是子查询的内容，而是查我们的主查询的表(select a.* from dual),然后，根据表的每一条记录，执行以下语句(exists (select * from dual b where a.dummy = b.dummy))，依次去判断where后面的条件是否成立,如果成立则返回true不成立则返回false。如果返回的是true的话，则该行结果保留，如果返回的是false的话，则删除该行，最后将得到的结果返回。
区别及应用场景: in 和 exists的区别: 如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in, 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。其实我们区分in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外IN时不对NULL进行处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b632d6349e1f9552b33cd0e7d34ff328/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca93f9c25a2ffc8dafad58e133d07297/" rel="bookmark">
			Java修炼——异常的概念以及处理方式（捕获异常）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常概念分类
异常（ Exception 也称例外）就是在程序的运行过程中
所发生的不正常的事件，它会中断正在运行的程序
 所需文件找不到
 网络连接不通或中断
 算术运算错 (被零除…)
 数组下标越界
 装载一个不存在的类或者对 null 对象操作
 类型转换异常
 ……
当 Java 程序出现以上的异常时，就会在所处的方法 中产生一个异常对象。这个异常对象包括异常的类型， 异常出现时程序的运行状态以及对该异常的详细描述
异常的分类：
异常处理方式——捕获异常
捕获异常所使用的关键字 try 、catch 、finally
1)try-catch 组合
a)正常情况
b)异常情况，异常出现的类型与捕获的类型匹配
c)异常情况，异常出现的类型与捕获的类型不匹配
2)try-finally 组合
finally 是无论是否产生异常，都执行的代码，但是有 一种情况 finally 不执行，即退出 Java 虚拟机
package com.bjsxt.exception; import java.util.Scanner; public class CatchException { public static void main(String[] args) { int c; try { Scanner intput=new Scanner(System.in); System.out.println("请输入被除数："); int a=intput.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca93f9c25a2ffc8dafad58e133d07297/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ac43a1d962ab4181a36f0de95641bc/" rel="bookmark">
			vector常见用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vector定义二维数组 vector&lt;vector&lt;int&gt; &gt;v(m,vector&lt;int&gt;(n));
vector&lt;vector&lt;int&gt; &gt;v(N); 第一维大小确定，第二维大小不确定。
vector&lt;vector&lt;int&gt; &gt;v;可使用v.resize()改变一维的大小
int in[N],n=20; vector&lt;int&gt;tin(in,in+n); 用数组in[]初始化tin，并且tin.size()==n; 1047 Student List for Course (25 分)
Zhejiang University has 40,000 students and provides 2,500 courses. Now given the registered course list of each student, you are supposed to output the student name lists of all the courses.
Input Specification: Each input file contains one test case. For each case, the first line contains 2 numbers: N (≤40,000), the total number of students, and K (≤2,500), the total number of courses.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49ac43a1d962ab4181a36f0de95641bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f043757af612da0bdf980d6289386e6/" rel="bookmark">
			Boltzmann Machine玻尔兹曼机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考Hinton发表于2007年的一篇论文，链接在此
但玻尔兹曼机实际上是1985年就被Hinton和Terry Sejnowski发明了。
本渣英语自认并不是特别烂，但最近发现看长篇的英文文献总是看的时候很明白，但眼睛拿开就特别容易忘记···所以很多重点我翻译过来，变成中文一下爽多了。并不是完全不看英文哈，毕竟地道和专业的文献写作技术还是需要不断打磨的，而且很多时候只看单一语言不容易懂，偶尔你只看中文会很迷惑，看看原英文就一下明白了，因为翻译毕竟不能传神，有时候只看英文也会很迷惑，需要借助翻译工具搭配中文一起看才明白本意。
本文长篇大论预警，但讲的系统详尽，看不进去的自动撤离。。。
（一）简介 玻尔兹曼机是一种对称连接的网络，其实它就是图论中的完全图，任意单元都相互连接，像神经元一样的单元会对是否开启或关闭做出随机的决策。最开始BM只是用来描述只有二值变量的模型，但现在的很多模型如均值-协方差RBM也含有实值变量。
BM有一个简单的学习算法，是Hinton等人1983年提出的，这个学习算法可以发现训练数据中很有趣的可以表示复杂规律的特征。
但这个算法在有很多层特征检测器的网络中很慢，但在RBM受限玻尔兹曼机中很快，RBM只有一个隐层，也就是只有一层特征检测器，特征检测器就是隐层中像人脑神经元一样的单元们。
多个隐层的学习可以通过组合RBM高效地实现，即用一个RBM的特征激活程度（feature activations）作为下一个RBM的训练数据。这种组合就像是堆叠，很多描述DBN的文献也常用stack一词.
BM常被用于解决两种不同的计算问题。 一是搜索问题（a search problem），这种问题中，连接的权值们是固定的，它们一起表示了一个代价函数。BM的随机动态性就允许它去采样出一个代价函数取值低的二元状态向量。 实际上这在DBN的训练中就是权重固定对隐层单元采样的操作。二是学习问题（a learning problem）,这时候，我们会给BM一组二元状态向量作为输入，二元状态向量就是一个元素要么取0要么取1的向量，BM要努力去学习以很高的概率生成这些向量，这一句话就说明了BM学习的目的，就是以高概率去重现自己接收到的所有输入数据，学习到的参数就是连接的权重和每个隐层单元的偏置。
具体怎么实现以高概率生成训练数据呢？还是要建立一个代价函数cost function去量化问题，努力训练找到使代价函数最小化的权重和偏置。学习问题中，需要多次更新权重，每次更新很小，且每次更新都要解决多个搜索问题，就是在DBN或者RBM的学习训练中需要对隐层和显层单元反复采样的，所以学习问题中也需要执行搜索问题。 （二）BM的随机动力学 stochastic dynamics 不清楚译为随机动力学还是随机动态性比较好，可见我还没明白精髓。
一个单元被激活的概率 当隐层单元i可以更新自己的二元状态时，它要先计算自己的总输入，由自己的偏置加上所有连接到它的神经元的激活程度乘以相应连接的权重得到。最终神经元i更新为1的概率用sigmoid计算，把总输入带进去算出来的概率就是单元i开启（取1）的概率。
2. 一个状态向量出现的概率
如果BM的所有单元以任意顺序先后更新自己的激活状态，那么网络最终将会到达一个玻尔兹曼分布（也叫做均衡点，平衡点equilibrium 或者平稳分布 stationary distribution）。
在玻尔兹曼分布下，一个状态向量v的概率完全由他自己的能量相对于所有可能的状态向量的总能量决定。
可见没有一个能量函数会使得任何状态变量的概率小于或等于0 ，所有变量的概率都是正的。
分母就是配分函数，它用来保证所有可能的v的概率总和是1,实际上就是个归一化常数。
玻尔兹曼分布就是玻尔兹曼机得名的原因。这个分布是物理学上给出粒子在各量子态的分布概率。它的数学建模就是上图公式那样，只要满足这个公式的任何分布都是玻尔兹曼分布的一个实例instance。详情可见
所以说BM是基于能量的模型，参考了统计力学的一个分布和其建模方式，其实概率的建模最初都是统计物理学家在研究的，所以会在机器学习的文献中常常见到能量，配分函数等物理学上的术语，其实很有趣，这体现了学科的交叉性，这么火热的机器学习模型实际上灵感来源于物理上的一种能量分布。实际上在实际应用中这个能量就是我们的代价函数，能量越小的状态向量被采样的概率就越大。
而且！！！由于BM的随机动态性，就可以使我们在寻找低代价的解时跳出比较差的局部最小（ poor local optima）。 举个栗子：有时候 z i z_i zi​即使是负的，即单元 i i i的总输入为负，他的能量当然就不足以激活啦，但按照sigmoid计算的概率虽然很小，但小概率事件也是有可能发生的，所以单元i可能被激活，使得系统的能量上升（激活的神经元越多能量越大），就可以跳出能量局部最小啦。
能量怎么计算
在Hopfield 网络中，一个二元状态向量的能量是这么计算的:
也可以写作矩阵形式：
E ( v ) = − v T W v − b T v E(\boldsymbol v)=-\boldsymbol v^T\boldsymbol W\boldsymbol v-\boldsymbol b^T\boldsymbol v E(v)=−vTWv−bTv s i v s^v_i siv​是状态向量v中单元i的状态，0或1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f043757af612da0bdf980d6289386e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ca5991e670d1305f401d1d9d5134f55/" rel="bookmark">
			k8s部署nginx实例、iptables开放端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 运行nginx实例 kubectl run nginx --image=nginx --replicas=2 --port=80 2 查看pod [root@localhost ~]# kubectl get pods NAME READY STATUS RESTARTS AGE nginx-3449338310-tmlqp 1/1 Running 0 50s nginx-3449338310-tn7xt 1/1 Running 0 50s 3 查看服务详情 [root@localhost ~]# kubectl describe pod nginx-3449338310-tmlqp Name: nginx-3449338310-tmlqp Namespace: default Node: 127.0.0.1/127.0.0.1 Start Time: Mon, 15 Jul 2019 07:54:10 -0400 Labels: pod-template-hash=3449338310 run=nginx Status: Running IP: 172.17.0.3 Controllers: ReplicaSet/nginx-3449338310 Containers: nginx: Container ID: docker://38d6e64e2b9a5d5936c74eca5d117e6b5a0cf8b9d4d0726ea1e1869be543c10c Image: nginx Image ID: docker-pullable://docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ca5991e670d1305f401d1d9d5134f55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/654f4d81ed3a0ccf7b260a16baaff4bc/" rel="bookmark">
			springmvc发送请求时，tomcat所导致的405错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.发送POST请求问题 排除代码问题
Tomcat8以上不支持post请求，降低版本解决 2.发送PUT请求问题 排除代码问题
需在tomcat的conf/web.xml：&lt;servlet&gt; &lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33d61c2953e715da32186d0b2514cec8/" rel="bookmark">
			SpringBoot&#43;Thymeleaf拼接URL，字符和请求参数参数变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 最近搭建网站需要使用Thymeleaf来创建一个 http://localhost:8081/news/list/all?page=1&amp;size=10 这样的url，现在希望“all”、“page”、“size”变化，其他的不变：“all”可能自身变为其他字符串，如"top"，而“page”“size”只改变数值，如"3"和"30"。结果希望变为： http://localhost:8081/news/list/top?page=3&amp;size=30 解决方案： Controller如下，“all”其实就是下面的type变量，通过 model.addAttribute("type", type) 传给前端，“page”“size”作为请求参数@RequestParam： /** * 查询所有新闻 * @return 新闻列表 */ @GetMapping("list/all") public String listAll(Model model, @RequestParam(value = "page", defaultValue = PAGE_DEFAULT) Integer page, @RequestParam(value = "size", defaultValue = SIZE_DEFAULT) Integer size) { String type = "all"; logger.info("List news:" + type); PageHelper.startPage(page, size); List&lt;News&gt; list = mNewsService.selectAll(); PageInfo&lt;News&gt; pageInfo = new PageInfo&lt;&gt;(list); model.addAttribute("type", type); model.addAttribute("newsList", list); int pages = pageInfo.getPages(); model.addAttribute("indexPage", page &lt; 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33d61c2953e715da32186d0b2514cec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28b5ecc014bc7bf31a622c6af62c5e6c/" rel="bookmark">
			LeetCode_面试精选（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刷LeetCode真是一个一眼望不到头的任务，为了秋招，只能先考虑搞定面试精选题。
46.全排列
题目描述：给定一个没有重复数字的序列，返回其所有可能的全排列。
代码：
回溯算法
class Solution(object): def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ res=[] tmp=[] def backtrack(nums,tmp): if not nums: res.append(tmp) return for i in range(len(nums)): backtrack(nums[:i]+nums[i+1:],tmp+[nums[i]]) backtrack(nums,tmp) return res 48. 数组中的第K个最大元素
题目描述：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
代码：
class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ nums_len=len(nums) nums1=sorted(nums) return nums1[nums_len-k] 55.跳跃游戏
题目描述：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。
代码：
从前往后
class Solution(object): def canJump(self, nums): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28b5ecc014bc7bf31a622c6af62c5e6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/524bcd9baeeaeef18831177f637a6049/" rel="bookmark">
			SSM到Spring Boot从零开发校园商铺平台---9、阿里云部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章：
1、环境搭建及测试- - -附免费视频教程
专栏14篇，参看：https://www.jianshu.com/nb/38421432
GitHub地址：https://github.com/tyronczt/imooc-o2o
线上演示地址：http://o2o.tyronblog.com:8088/o2o/front/index
此处没有效果图，可点击线上项目直接查看，按F12查看效果更佳。
阿里云部署主要步骤： 申请阿里云服务器；搭建环境；发布项目；域名解析。 此处参考翔仔的文章----阿里云部署Java网站，由于自己本身申请有服务器＋域名，搭建起来比较快，借这次机会再来回顾一遍web项目的整个发布过程：
申请阿里云服务器 阿里云经常会有活动，特别针对新用户，活动力度相当大，当时服务器配置是：1Mbps 1 vCPU 2 GiB ，3年的价格是：279元，合着7.75一个月，还可以邀请新用户再延长时间。
搭建环境 有了服务器，就需要搭建环境，JDK --&gt; MySQL --&gt; Tomcat 一个一个来，Redis可选安装。
可参考我之前写的文章：
Tomcat部署web服务（线上）
CentOS 7.2下yum安装MySQL5.7
发布项目 修改项目中数据库配置；将图片放到服务器中，路径在PathUtil.java的第25行配置；修改Tomcat的server.xml文件： &lt;!-- 增加图片路径 --&gt; &lt;Context docBase="/home/tyron/image/upload" path="/upload"/&gt; 将本地项目打成war包：
右击项目名–&gt; Export --&gt; WAR file --&gt; 选择Destination --&gt; Finish，将导出的War包放到Tomcat目录下的webapps；
修改端口（可选）
翔仔是将Tomcat的端口改成了80端口，这样就可以省略端口号了，但是由于我服务器中80端口已经给我博客用了，只能端口重新改一个：
&lt;Connector port="8088" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 配置安全组，将8088端口设置授权对象为0.0.0.0/0。运行项目： cd /home/tomcat-8.5.35/bin ./startup.sh 域名解析 域名解析很快，但是申请域名就稍微麻烦点，如果用国内备案的话就再麻烦点，就如同给网站政审，自行体会。
有需要的可参看我之前写的：hexo+github 终于有了自己的博客！文章中的域名和服务器选择章节。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ac241ca5e36fc5d420a060fbe1a30e0/" rel="bookmark">
			We&#39;re sorry but blog doesn&#39;t work properly without JavaScript enabled. （解决方案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在搭建博客的过程中发现代码跑起来的时候服务端返回了这样的一个东西，如下图
我相信这个问题会有人遇到的，那么解决这个问题的方法也很简单。
问题出在vue项目中，在router文件夹的index.js文件中，将mode修改为hash模式即可，如果使用的是history，那么需要后端进行配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd7826f6a11acbacbc0681e3b77d677/" rel="bookmark">
			有关wxGLCanvas的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在将osg窗口嵌入wxWidgets窗口中时涉及到了在wxWidgets中嵌入openGL窗口的问题，为了实现这个目的需要继承wxGLCanvas类，为了能使用wxGLCanvas类，需要做以下工作： 在wxWidgets工程目录下的include/wx/msw/setup.h中将 define wxUSE_GLCANVAS 0改为 1 然后重新编译wx_gl工程文件 再将lib/vc_lib/msw/wx/setup.h中的 define wxUSE_GLCANVAS 0改为 1 这样就没什么问题了 转载于:https://www.cnblogs.com/du_utopia/archive/2009/11/23/1608486.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b90f3c226a5d4d243229b2f31eb5021e/" rel="bookmark">
			C# List集合中获取重复值及集合运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说，直接上实例：
一、获取集合内重复值 public void GetDuplicateValue() { List&lt;string&gt; lisA = new List&lt;string&gt; { "A", "B", "C", "A" }; //方式一 借助字典 Dictionary&lt;string, int&gt; dic = new Dictionary&lt;string, int&gt;(); lisA.ForEach(x =&gt; { if (dic.ContainsKey(x)) dic[x] += 1; else dic[x] = 0; }); List&lt;string&gt; lisDupValues = dic.Where(x =&gt; x.Value &gt; 0).Select(x =&gt; x.Key).ToList(); //结果{"A"} //方式二 List&lt;string&gt; lisDupValues2 = lisA.GroupBy(x =&gt; x).Where(x =&gt; x.Count() &gt; 1).Select(x =&gt; x.Key).ToList(); //结果{"A"} //方式三 等同于方式二 List&lt;string&gt; lisDupValues3 = (from r in lisA group r by r into g where g.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b90f3c226a5d4d243229b2f31eb5021e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48069ae7dba27e0e94eaf1e16fc6fa68/" rel="bookmark">
			Cisco Packet Tracer（配置密码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 特权密文密码（进入特权模式需要的密码） 上面一句是明文，下面一句是密文
明文和密文都要配置（明文是给别人看的，密文是自己用的）
当明文密码和加密密码同时配置的时候，只能够是加密的密码生效。
然后执行两次exit
退回到用户模式，再进入：
password： 我需要输入我刚刚配置的密文密码bbb，在键盘上输入bbb，然后敲下回车，就进入特权模式了
注意：输入的密码是不可见的
明文密码可以在show running-config下看到，而加密的密码在show running-conifg下看到的却只是经过MD5加密后出现的一长串的字母。
SW1&gt;show running-config 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73e9af6f01b947529d5cee47d1cd669c/" rel="bookmark">
			半导体行业都有哪些设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为转载，方便了解半导体设备行业。
众 所周知，半导体作为最重要的产业之一，每年为全球贡献近五千亿美金的产值，可以毫不夸张的说，半导体技术无处不在。俗话说：巧妇难为无米之炊，硅晶圆作为制造半导体器件和芯片的基本材料，在产业中扮演着举足轻重的地位，硅是当今最重要、应用最广泛的半导体材料。
硅是非常常见的物质，如沙子里面就有二氧化硅，但沙子到硅晶体这可是个非常复杂的过程，如沙子要经过提纯、高温整形再到旋转拉伸……单晶硅是晶圆最初始的状态，在实际应用中仍不行，还需要制造成晶圆，而且是要求很高的圆圆晶体。在实际的生产中，我们通常将二氧化硅还原成单晶硅，但是这个过程难度很高，因为实际用到的晶圆纯度很高，要达到99.999%以上，常用的晶圆生产过程包括硅的纯化、纯硅制成硅晶棒、制造成电路的石英半导体材料、照相制版、硅材料研磨和抛光、多晶硅融解然后拉出单晶硅晶棒再到最后切割成一片薄薄的晶圆。
常见的硅晶圆生产流程
硅在自然界中以硅酸盐或二氧化硅的形式广泛存在于岩石、砂砾中，硅晶圆的制造有三大步骤：硅提炼及提纯、单晶硅生长、晶圆成型。
一、 硅提炼及提纯 硅的提纯是第一道工序，需将沙石原料放入一个温度超过两千摄氏度的并有碳源的电弧熔炉中，在高温下发生还原反应得到冶金级硅，然后将粉碎的冶金级硅与气态的氯化氢反应，生成液态的硅烷，然后通过蒸馏和化学还原工艺，得到了高纯度的多晶硅。
二、 单晶硅生长 （用直拉法制造晶圆的流程图） 晶圆企业常用的是直拉法，如上图所示，高纯度的多晶硅放在石英坩埚中，并用外面围绕着的石墨加热器不断加热，温度维持在大约一千多摄氏度，炉中的空气通常是惰性气体，使多晶硅熔化，同时又不会产生不需要的化学反应。 为了形成单晶硅，还需要控制晶体的方向，坩埚带着多晶硅熔化物在旋转，把一颗籽晶浸入其中，并且由拉制棒带着籽晶作反方向旋转，同时慢慢地、垂直地由硅熔化物中向上拉出。 熔化的多晶硅会粘在籽晶的底端，按籽晶晶格排列的方向不断地生长上去。用直拉法生长后，单晶棒将按适当的尺寸进行切割，然后进行研磨，再用化学机械抛光工艺使其至少一面光滑如镜，这时候晶圆片就制造完成了。 晶圆制造厂把这些多晶硅融解，再在融液里种入籽晶，然后将其慢慢拉出，以形成圆柱状的单晶硅晶棒，由于硅晶棒是由一颗晶面取向确定的籽晶在熔融态的硅原料中逐渐生成。 三、 晶圆成型 完成了上述两道工艺， 硅晶棒再经过切段，滚磨，切片，倒角，抛光，激光刻，包装后，即成为集成电路工厂的基本原料——硅晶圆片，这就是“晶圆”。
在现实中，经常会听到人们讲几寸晶圆厂，它是说生产单片晶圆的尺寸。一般情况下，硅晶圆直径越大，代表晶圆厂技术实力越强，如中芯国际以12寸晶圆为主，台积电的8寸晶圆等。为了将电晶体与导线尺寸缩小，可以将几片晶圆制作在同一片晶圆上，制作出更多的硅晶粒，但是硅晶圆生产最关键的参数就是良品率，这是晶圆厂的核心技术参数，它与硅晶圆生产设备的质量密不可分。
制造一颗硅晶圆需要的半导体设备
制作一颗硅晶圆需要的半导体设备大致有十个，它们分别是单晶炉、气相外延炉、氧化炉、磁控溅射台、化学机械抛光机、光刻机、离子注入机、引线键合机、晶圆划片机、晶圆减薄机，其实光刻机只是九牛一毛。
1、 单晶炉
单晶炉是一种在惰性气体（氮气、氦气为主）环境中，用石墨加热器将多晶硅等多晶材料熔化，用直拉法生长无错位单晶硅的设备。在实际生产单晶硅过程中，它扮演着控制硅晶体的温度和质量的关键作用。
由于单晶直径在生长过程中可受到温度、提拉速度与转速、坩埚跟踪速度、保护气体流速等因素影响，其中生产的温度主要决定能否成晶，而速度将直接影响到晶体的内在质量，而这种影响却只能在单晶拉出后通过检测才能获知，单晶炉主要控制的方面包括晶体直径、硅功率控制、泄漏率和氩气质量等。
2、 气相外延炉
气相外延炉主要是为硅的气相外延生长提供特定的工艺环境，实现在单晶上生长与单晶晶相具有对应关系的薄层晶体。外延生长是指在单晶衬底（基片）上生长一层有一定要求的、与衬底晶向相同的单晶层，犹如原来的晶体向外延伸了一段，为了制造高频大功率器件，需要减小集电极串联电阻，又要求材料能耐高压和大电流，因此需要在低阻值衬底上生长一层薄的高阻外延层。
气相外延炉能够为单晶沉底实现功能化做基础准备，气相外延即化学气相沉积的一种特殊工艺，其生长薄层的晶体结构是单晶衬底的延续，而且与衬底的晶向保持对应的关系。
3、 氧化炉
硅与含有氧化物质的气体，例如水汽和氧气在高温下进行化学反应，而在硅片表面产生一层致密的二氧化硅薄膜，这是硅平面技术中一项重要的工艺。氧化炉的主要功能是为硅等半导体材料进行氧化处理，提供要求的氧化氛围，实现半导体预期设计的氧化处理过程，是半导体加工过程的不可缺少的一个环节。
4、 磁控溅射台
磁控溅射是物理气相沉积的一种，一般的溅射法可被用于制备半导体等材料，且具有设备简单、易于控制、镀膜面积大和附着力强等优点。在硅晶圆生产过程中，通过二极溅射中一个平行于靶表面的封闭磁场，和靶表面上形成的正交电磁场，把二次电子束缚在靶表面特定区域，实现高离子密度和高能量的电离，把靶原子或分子高速率溅射沉积在基片上形成薄膜。
5、 化学机械抛光机
一种进行化学机械研磨的机器，在硅晶圆制造中，随着制程技术的升级、导线与栅极尺寸的缩小，光刻技术对晶圆表面的平坦程度的要求越来越高，IBM公司于1985年发展CMOS产品引入，并在1990年成功应用于64MB的DRAM生产中，1995年以后，CMP技术得到了快速发展，大量应用于半导体产业。
化学机械研磨亦称为化学机械抛光，其原理是化学腐蚀作用和机械去除作用相结合的加工技术，是目前机械加工中唯一可以实现表面全局平坦化的技术。在实际制造中，它主要的作用是通过机械研磨和化学液体溶解“腐蚀”的综合作用，对被研磨体（半导体）进行研磨抛光。
6、 光刻机
又名掩模对准曝光机、曝光系统、光刻系统等，常用的光刻机是掩膜对准光刻，一般的光刻工艺要经历硅片表面清洗烘干、涂底、旋涂光刻胶、软烘、对准曝光、后烘、显影、硬烘、刻蚀等工序。在硅片表面匀胶，然后将掩模版上的图形转移光刻胶上的过程将器件或电路结构临时“复制”到硅片上的过程。
7、 离子注入机
它是高压小型加速器中的一种，应用数量最多。它是由离子源得到所需要的离子，经过加速得到几百千电子伏能量的离子束流，用做半导体材料、大规模集成电路和器件的离子注入，还用于金属材料表面改性和制膜等 。
在进行硅生产工艺里面，需要用到离子注入机对半导体表面附近区域进行掺杂，离子注入机是集成电路制造前工序中的关键设备，离子注入是对半导体表面附近区域进行掺杂的技术目的是改变半导体的载流子浓度和导电类型，离子注入与常规热掺杂工艺相比可对注入剂量角度和深度等方面进行精确的控制，克服了常规工艺的限制，降低了成本和功耗。
8、 引线键合机
它的主要作用是把半导体芯片上的Pad与管脚上的Pad，用导电金属线（金丝）链接起来。引线键合是一种使用细金属线，利用热、压力、超声波能量为使金属引线与基板焊盘紧密焊合，实现芯片与基板间的电气互连和芯片间的信息互通。在理想控制条件下，引线和基板间会发生电子共享或原子的相互扩散，从而使两种金属间实现原子量级上的键合。
9、 晶圆划片机
因为在制造硅晶圆的时候，往往是一整大片的晶圆，需要对它进行划片和处理，这时候晶圆划片机的价值就体现出了。之所以晶圆需要变换尺寸，是为了制作更复杂的集成电路。
10、 晶圆减薄机
在硅晶圆制造中，对晶片的尺寸精度、几何精度、表面洁净度以及表面微晶格结构提出很高要求，因此在几百道工艺流程中，不可采用较薄的晶片，只能采用一定厚度的晶片在工艺过程中传递、流片。晶圆减薄，是在制作集成电路中的晶圆体减小尺寸，为了制作更复杂的集成电路。在集成电路封装前，需要对晶片背面多余的基体材料去除一定的厚度，这一工艺需要的装备就是晶片减薄机。
当然了，在实际的生产过程中，硅晶圆制造需要的设备远远不止这些。之所以光刻机的关注度超越了其它半导体设备，这是由于它的技术难度是最高的，目前仅有荷兰和美国等少数国家拥有核心技术。近年来，国内的企业不断取得突破，在光刻机技术上也取得了不错的成绩，前不久，国产首台超分辨光刻机被研制出来，一时间振奋了国人，随着中国自主研发的技术不断取得进步，未来中国自己生产的晶圆也将不断问世。
下面本人附录国际上著名的半导体设备厂商、晶圆厂，在半导体行业是赢者全拿，国际前两名从业站拿下8层以上的市场份额。
从图中可以看出设备厂商前三名是： ASML（阿斯麦。荷兰——大股东是美国）
apply material（应用材料。美国）
tokyo electron（东京电子。日本）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3ba7df578e22a55b23c3a51dcb81501/" rel="bookmark">
			十种经典运放电路分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载十一种经典运放电路分析
本文章为转载文章，只是为以后方便查阅，如有侵权，请联系本人。
1）反向放大器 图一运放的同向端接地=0V，反向端和同向端虚短，所以也是0V，反向输入端输入电阻很高，虚断，几乎没有电流注入和流出，那么R1和R2相当于是串联的，流过一个串联电路中的每一只组件的电流是相同的，即流过R1的电流和流过R2的电流是相同的。
流过R1的电流：I1 = (Vi - V-)/R1 ………a
流过R2的电流：I2 = (V- - Vout)/R2 ……b
V- = V+ = 0 ………………c
I1 = I2 ……………………d
求解上面的初中代数方程得Vout = (-R2/R1)*Vi
这就是传说中的反向放大器的输入输出关系式了。
2）同向放大器 图二中Vi与V-虚短，则 Vi = V- ……a
因为虚断，反向输入端没有电流输入输出，通过R1和R2 的电流相等，设此电流为I，由欧姆定律得： I = Vout/(R1+R2) ……b
Vi等于R2上的分压， 即：Vi = I*R2 ……c
由abc式得Vout=Vi*(R1+R2)/R2 这就是传说中的同向放大器的公式了
3）加法运放器 图三中，由虚短知： V- = V+ = 0 ……a
由虚断及基尔霍夫定律知，通过R2与R1的电流之和等于通过R3的电流，故 (V1 – V-)/R1 + (V2 – V-)/R2 = (V- –Vout)/R3 ……b
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3ba7df578e22a55b23c3a51dcb81501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/827b7aeda2bdea5e21e1a753ed44b0ff/" rel="bookmark">
			opencv实现字符分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		opencv字符分割流程是：1、图像单通道化，2、图像二值化；3、获取图像中的轮廓；4、实现分割。
代码如下：
void SegmentChar(const string strPic) { Mat img = imread(strPic, 0); if (!img.data) { return; } Mat threshImg; threshold(img, threshImg, 100, 255, cv::THRESH_BINARY_INV); std::vector&lt;std::vector&lt;Point&gt;&gt; contours; Mat hierarchy; findContours(threshImg, contours, hierarchy, CV_RETR_LIST, CV_CHAIN_APPROX_NONE); drawContours(threshImg, contours, -1, Scalar(255, 0, 255), 1); std::vector&lt;std::vector&lt;Point&gt;&gt;::const_iterator iter = contours.begin(); while (iter != contours.end()) { Rect rc = boundingRect(*iter); rectangle(img, rc, Scalar(0, 255, 255), 1); iter++; } imshow("char", img); waitKey(0); } 效果如下
数字和字母的分割效率不错，但是中文字符的分割很差，还需要改进，有一篇不错的文档，可以参考一下https://www.cnblogs.com/chenzhefan/p/7629441.html
https://www.cnblogs.com/wj-1314/p/9754072.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f11df76275b40c4b1cd4808ea2234e96/" rel="bookmark">
			Jrebel激活方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考 https://www.yanjiayu.cn/posts/3eecb801.html
https://gitee.com/gsls200808/JrebelLicenseServerforJava
转载于:https://www.cnblogs.com/shengulong/p/11186508.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1e1ffdd7875d49190f1f2bd759006cc/" rel="bookmark">
			vue的八种组件通信方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件之间的通信主要分为：
父子组件之间通信非父子组件之间的通信（兄弟组件、隔代关系组件等） 八种通信方式1. props 、$emit2. c h i l d r e n 、 children 、 children、parent3. ref4. provide 、reject5. Vuex6. $attrs 与listenters7. eventBus8. localStorage 、sessionStorage props 详情： 用来接收来自父组件的数据，props可以是简单的数组或对象。
如果只是父子关系的组件数据交互，那么应该考虑使用props进行单向传递
基于对象的语法： type： 可以是String、Number、Boolean、Array、Object、Date、Function、Symbol任何自定义构造函数、或上述内容组成的数组。
子组件会检查父组件传递过来的数据是否是给定的类型，否则抛出警告。
default：any： 默认情况，如果prop没有被传入，则为该prop指定一个默认值，对象或数组的默认值必须从一个工厂函数返回。
required：Boolean：在非生产环境中，如果prop没有传入，则控制台会抛出警告。
举个栗子：
父组件test.vue
&lt;template&gt; &lt;div class="hello"&gt; &lt;HelloWorld :date="date"&gt;&lt;/HelloWorld&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import HelloWorld from '../components/HelloWorld' export default { data () { return { date:new Date() } }, components:{ HelloWorld } } &lt;/script&gt; 子组件 HelloWorld.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1e1ffdd7875d49190f1f2bd759006cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f095558c9cccc4589e8e50b135ba569/" rel="bookmark">
			数据库面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库面试题 2019年05月04日 21:29:19 李先森 阅读数 260
Section 1：小常识 1.union 和union all的区别？ union 会去重
2. 游标 游标（Cursor）是处理数据的一种方法，可以把游标当作一个指针，它可以指定结果表中的任何位置，对指定位置的数据进行处理。
显示游标：自己打开关闭
隐式游标：自动打开关闭
引用内容
3用户管理 #查看用户拥有的权限 select * from mysql.user; select * from information_schema.USER_PRIVILEGES; #删除用户 drop role admin; #创建用户 create user admin identified by 'first_pd'; #给与权限 grant all privileges on *.* to admin ; #改该用户密码 ALTER USER 'admin'@'%' IDENTIFIED WITH mysql_native_password BY 'Ldd123456'; 1234567891011 Section 1： DW Essential： 1.什么是DW？ 就是一个集成的，面向主题，经过处理,基于OLAP的数据库。DW主要用于数据分析决策。
（
数据仓库是一个面向主题的（Subject Oriented）、集成的（Integrate）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f095558c9cccc4589e8e50b135ba569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62642a2058d7434822bea4c0563eeed3/" rel="bookmark">
			react 父子组件之间相互传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		From: https://blog.csdn.net/luzhaopan/article/details/85003362
1、定义父组件
import React, { PureComponent } from 'react';
export default class Father extends PureComponent {
render(){
return(
&lt;div&gt;
&lt;p&gt;父组件&lt;/p&gt;
&lt;/div&gt;
)
}
}
2、定义子组件
import React, { PureComponent } from 'react';
export default class Children extends PureComponent {
render(){
return(
&lt;div&gt;
&lt;p&gt;子组件&lt;/p&gt;
&lt;/div&gt;
)
}
}
3、父组件向子组件传值
import React, { PureComponent } from 'react';
// 引入子组件
import Children from '@/components/Children';
export default class Father extends PureComponent {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62642a2058d7434822bea4c0563eeed3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e42f8e54b3a7496818b87daee360b0a/" rel="bookmark">
			51单片机（2）硬件结构（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先回顾单片机的定义：
单片机内部硬件结构 按功能可分成9个部件，通过片内单一总线连接起来
主要功能部件：
1. 中央处理单元（CPU，微处理器）包括运算器和控制器两大部分，
运算器是实现算术运算和逻辑运算。
控制器是单片机的指挥控制部件，保证单片机各部分能自动而协调 地工作。
2. 数据存储器（RAM） 数据存储器（RAM）128B 片外64K字节
8051片内共256个RAM单元，前128为RAM区，
后128为SFR 存放临时数据:堆栈数据\ 运算中间结果\采集的数据。
3. 程序存储器（ROM/EPROM）8751内有4KB EPROM 片外最多可扩展到64K字节，用于存放程序和原始数据或表格
4. 定时器/计数器 3个16位的定时器/计数器，以实现定时或计数功能
5. 并行I/O接口 4个8位的I/O口（P0、P1、P2、P3） 实现数据的并行输入输出及总线扩展
6. 串行接口
7. 中断系统 共有6个中断源，即2个外部中断、3个定时器/计数器中断、 1个串行口中断。中断优先级分为高、低两级。
8. 特殊功能寄存器（SFR）控制寄存器和状态寄存器
9.看门狗WDT 当单片机由于干扰而使程序陷入死循环或跑飞状态时， 可引起单片机复位，使程序恢复正常运行。
80C51单片机引脚逻辑图 下面是两种不同的引脚封装方式：
一.电源及时钟引脚
1．电源引脚 ：
Vcc：+5V电源
GND：接地
2．时钟引脚
XTAL1
XTAL2
内部时钟方式：在芯片外部跨接石英晶体（注意是在芯片外面跨接石英晶体）
外部时钟方式：外部振荡信号直接接入XTAL1 或XTAL2
二.控制引脚：
1.RST/VPD: (Reset) 复位信号/备用电源输入端 此引脚加2个机器周期的高电平将使单片机复位 正常工作，此脚电平应 ≤ 0.5V。
2.EA/VPP:(External Access （Enable）) 访问程序存储器控制信号/编程电源输入端 高电平时，单片机访问从内部程序存储器开始； 低电平时，只访问外部程序存储器。
3.PSEN:(Program （Memroy）Store Enable) 片外程序存储器读选通信号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e42f8e54b3a7496818b87daee360b0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b745dededb39524706c7531cb274da6/" rel="bookmark">
			使用nginx搭建静态资源服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用ngnix搭建静态资源服务器 通过在地址栏输入ip+port的方式来完成目录的映射
nginx下载地址 下载地址
我使用的是:nginx1.16.0
下载后解压
搭建流程 这里以我电脑的D盘下面的abc和boot文件为例，abc文件夹是一个静态页面，boot文件夹是一个文件
1、配置conf文件
在解压后的文件夹中打开conf/nginx.conf文件如果nginx的:location /{} 下面没有其他的配置 server { listen 8888;#访问的端口号 server_name localhost;#访问的ip location / { root D:/;#在location /下面配置的话,是将D盘中的所有文件夹作为了静态资源服务器 autoindex on;#打开目录浏览功能 } } 如果nginx的:location /{} 下面有其他配置 server { listen 8888; server_name localhost; location / { root html; index index.html index.htm; proxy_pass http://localhost:8080/123/; } location /abc/ {#路径必须为改文件下面有的文件名 root D:/; autoindex on; } location /boot/ { root D:/; autoindex on; } }	配置成功保存后
在压缩文件下面双击启动nginx.exe
启动后查看logs文件下面是否有nginx.pid文件，如果有说明启动成功，如果没有点击error.log文件查看失败原因
运行结果 在网页中访问localhost:8888/abc和localhost:8888/boot结果如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b745dededb39524706c7531cb274da6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b896714d539433f88e41d559c657f3/" rel="bookmark">
			如何在云服务器安装操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天讲解一下如何在云服务器安装操作系统。
首先进入云服务器管理界面，在工具栏找到安装操作系统并点击。
然后在即可看到选择操作系统类型项，这里推荐安装CentOS系统，不推荐windows。因为CentOS相对WIN更好管理。
之前我写了一篇文章讲解了如何注册开通三丰云免费云服务器和免费虚拟主机，对于没有云服务器的同学可以先去注册一个。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11d1a0107e0af7608e2311af3d953621/" rel="bookmark">
			pytorch教程之nn.Module类详解——state_dict和parameters两个方法的差异性比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：pytorch的模块Module类有很多的方法，前面的文章中已经介绍了四个常用的方法，这四个方法可以用于获取模块中所定义的对象（即每一个层）他们分别是children()、named_children()、modules()、named_modules()方法，本文介绍另外两个重要的方法，这两个方法会获取到模型中训练的参数（权值矩阵、偏置bias），这两个方法是model.state_dict()方法和model.parameters()方法。前面的文章参考：pytorch教程之nn.Module类详解——使用Module类来自定义模型
一、本文的模型案例 为了简单的演示，本文的模型较为简单，代码如下：
import torch import torch.nn.functional as F from torch.optim import SGD class MyNet(torch.nn.Module): def __init__(self): super(MyNet, self).__init__() # 第一句话，调用父类的构造函数 self.conv1 = torch.nn.Conv2d(3, 32, 3, 1, 1) self.relu1=torch.nn.ReLU() self.max_pooling1=torch.nn.MaxPool2d(2,1) self.conv2 = torch.nn.Conv2d(3, 32, 3, 1, 1) self.relu2=torch.nn.ReLU() self.max_pooling2=torch.nn.MaxPool2d(2,1) self.dense1 = torch.nn.Linear(32 * 3 * 3, 128) self.dense2 = torch.nn.Linear(128, 10) def forward(self, x): x = self.conv1(x) x = self.relu1(x) x = self.max_pooling1(x) x = self.conv2(x) x = self.relu2(x) x = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11d1a0107e0af7608e2311af3d953621/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d82d6851a5d9472ccfe811aafbc1e60/" rel="bookmark">
			uni-app的小程序中的关闭小程序方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在uni-app官网中没有该属性，但是在微信小程序官网可以查看该属性，navigator的open-type='exit' target='miniProgram' &lt;navigator open-type="exit" target="miniProgram" v-if="completeBtnSTtus" class="close-btn complete"&gt;完成&lt;/navigator&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39565f85f011a38462cfa8a6962f7875/" rel="bookmark">
			20大5G关键技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		戳蓝字“CSDN云计算”关注我们哦！
来源 | 北京物联网智能技术应用协会
5G网络技术主要分为三类：核心网、回传和前传网络、无线接入网。
核心网
核心网关键技术主要包括：网络功能虚拟化（NFV）、软件定义网络（SDN）、网络切片和多接入边缘计算（MEC）。
1 网络功能虚拟化（NFV）
NFV，就是通过IT虚拟化技术将网络功能软件化，并运行于通用硬件设备之上，以替代传统专用网络硬件设备。NFV将网络功能以虚拟机的形式运行于通用硬件设备或白盒之上，以实现配置灵活性、可扩展性和移动性，并以此希望降低网络CAPEX和OPEX。
NFV要虚拟化的网络设备主要包括：交换机（比如Open vSwitch）、路由器、HLR（归属位置寄存器）、SGSN、GGSN、CGSN、RNC（无线网络控制器）、SGW（服务网关）、PGW（分组数据网络网关）、RGW（接入网关）、BRAS（宽带远程接入服务器）、CGNAT（运营商级网络地址转换器）、DPI（深度包检测）、PE路由器、MME（移动管理实体）等。
NFV独立于SDN，可单独使用或与SDN结合使用。
2 软件定义网络（SDN）
软件定义网络（SDN），是一种将网络基础设施层（也成为数据面）与控制层（也称为控制面）分离的网络设计方案。网络基础设施层与控制层通过标准接口连接，比如OpenFLow（首个用于互连数据和控制面的开放协议）。
SDN将网络控制面解耦至通用硬件设备上，并通过软件化集中控制网络资源。控制层通常由SDN控制器实现，基础设施层通常被认为是交换机，SDN通过南向API（比如OpenFLow）连接SDN控制器和交换机，通过北向API连接SDN控制器和应用程序。
SDN可实现集中管理，提升了设计灵活性，还可引入开源工具，具备降低CAPEX和OPEX以及激发创新的优势。
3 网络切片（Network Slicing）
5G网络将面向不同的应用场景，比如，超高清视频、VR、大规模物联网、车联网等，不同的场景对网络的移动性、安全性、时延、可靠性，甚至是计费方式的要求是不一样的，因此，需要将一张物理网络分成多个虚拟网络，每个虚拟网络面向不同的应用场景需求。虚拟网络间是逻辑独立的，互不影响。
只有实现NFV/SDN之后，才能实现网络切片，不同的切片依靠NFV和SDN通过共享的物理/虚拟资源池来创建。网络切片还包含MEC资源和功能。
4 多接入边缘计算（MEC）
多接入边缘计算（MEC），就是位于网络边缘的、基于云的IT计算和存储环境。它使数据存储和计算能力部署于更靠近用户的边缘，从而降低了网络时延，可更好的提供低时延、高宽带应用。
MEC可通过开放生态系统引入新应用，从而帮助运营商提供更丰富的增值服务，比如数据分析、定位服务、AR和数据缓存等。
前传和回传
5 前传和回传技术
回传（Backhaul）指无线接入网连接到核心网的部分，光纤是回传网络的理想选择，但在光纤难以部署或部署成本过高的环境下，无线回传是替代方案，比如点对点微波、毫米波回传等，此外，无线mesh网络也是5G回传的一个选项，在R16里，5G无线本身将被设计为无线回传技术，即IAB（5G NR集成无线接入和回传）。
前传（Fronthaul）指BBU池连接拉远RRU部分，如C-RAN章节所述。前传链路容量主要取决于无线空口速率和MIMO天线数量，4G前传链路采用CPRI（通用公共无线接口）协议，但由于5G无线速率大幅提升、MIMO天线数量成倍增加，CPRI无法满足5G时代的前传容量和时延需求，为此，标准组织正在积极研究和制定新的前传技术，包括将一些处理能力从BBU下沉到RRU单元，以减小时延和前传容量等。
无线接入网
为了提升容量、频谱效率，降低时延，提升能效，以满足5G关键KPI，5G无线接入网包含的关键技术包括：C-RAN、SDR（软件定义无线电）、CR（认知无线电）、Small Cells、自组织网络、D2D通信、Massive MIMO、毫米波、高级调制和接入技术、带内全双工、载波聚合、低时延和低功耗技术等。
6 云无线接入网（C-RAN）
云无线接入网（C-RAN），将无线接入的网络功能软件化为虚拟化功能，并部署于标准的云环境中。C-RAN概念由集中式RAN发展而来，目标是为了提升设计灵活性和计算可扩展性，提升能效和减少集成成本。在C-RAN构架下，BBU功能是虚拟化的，且集中化、池化部署，RRU与天线分布式部署，RRU通过前传网络连接BBU池， BBU池可共享资源、灵活分配处理来自各个RRU的信号。
C-RAN的优势是，可以提升计算效率和能效，易于实现CoMP（协同多点传输）、多RAT、动态小区配置等更先进的联合优化方案，但C-RAN的挑战是前传网络设计和部署的复杂性。
7 软件定义无线电（SDR）
软件定义无线电（SDR），可实现部分或全部物理层功能在软件中定义。需要注意软件定义无线电和软件控制无线电的区别，后者仅指物理层功能由软件控制。
在SDR中可实现调制、解调、滤波、信道增益和频率选择等一些传统的物理层功能，这些软件计算可在通用芯片、GPU、DSP、FPGA和其他专用处理芯片上完成。
8 认知无线电（CR）
认知无线电（CR），通过了解无线内部和外部环境状态实时做出行为决策。SDR被认为是CR的使能技术，但CR包括和可使能多种技术应用，比如动态频谱接入、自组织网络、认知无线电抗干扰系统、认知网关、认知路由、实时频谱管理、协作MIMO等。
9 Small Cells
Small Cells，就是小基站（小小区），相较于传统宏基站，Small Cells的发射功率更低，覆盖范围更小，通常覆盖10米到几百米的范围，通常Small Cells根据覆盖范围的大小依次分为微蜂窝、Picocell和家庭Femtocell。
Small Cells的使命是不断补充宏站的覆盖盲点和容量，以更低成本的方式提高网络服务质量。考虑5G无线频段越来越高，未来还将部署5G毫米波频段，无线信号频段更高，覆盖范围越小，加之未来多场景下的用户流量需求不断攀升，后5G时代必将部署大量Small Cells，这些Small Cells将与宏站组成超级密集的混合异构（HetNet）网络，这将为网络管理、频率干扰等带来空前的复杂性挑战。
10 自组织网络（SON）
自组织网络（SON），指可自动协调相邻小区、自动配置和自优化的网络，以减少网络干扰，提升网络运行效率。
SON并不是新鲜概念，早在3G时代就提出，但进入5G时代，SON将是一项至关重要的技术。如上所述，5G时代网络致密化给网络干扰和管理提出了空前的复杂性挑战，更需要SON来最小化网络干扰和管理，但即便是SON恐怕也难以应付超级密集的5G网络，因此，还需要上文提到的CR（认知无线电）技术来帮忙。
11 设备到设备通信（D2D）
设备到设备通信（D2D），指数据传输不通过基站，而是允许一个移动终端设备与另一个移动终端设备直接通信。D2D源于4G时代，被称为LTE Proximity Services (ProSe)技术，是一种基于3GPP通信系统的近距离通信技术，主要包括两大功能：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39565f85f011a38462cfa8a6962f7875/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a50a198a2503b5f8ab1abb4a1abde7/" rel="bookmark">
			卓越人生的两大利器——任务分解与保持节奏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总有人说，什么方法论啊，价值观啊，人生观啊，都是一些虚无缥缈的东西，与现实中的自己距离太远，而且都是一些“虚幻”的东西，不如谈谈具体的技术实在，比如说什么Spring Cloud啊、Docker啊、Kubernetes啊、Angular啊、Kafka啊，这些都是实打实的技术，掌握了就是掌握了，没掌握就是没掌握，来不得半点虚假。
没错，上面所列举的技术都是一些硬实力，这些硬实力是确保你职场竞争力的根本所在，特别是对于技术人员来说，掌握的技术越深入、越扎实、再有一些广度，那么你就是一个在职场非常具有竞争力的人，也是公司所需要的人，同时不可替代性也会越强。因此，很多开发人员就容易陷入这样一个误区：只关注于眼前，只关注于技术本身，但对于一些具有指导意义的方法论视而不见或是漠不关心。其实，我想说的是，若想在人生这场马拉松赛事中永葆活力，关注当下纵然不可或缺，但掌握了正确的方法论则会令你越走越远，同时越走越好。
那到底什么是方法论呢？这个词语我们每个人都知道，但它到底有什么作用呢？其实，按照我的理解，方法论就是指导我们行事的一套理论体系，每个人每一天都在使用它，只不过很多人并未感知到它的存在而已。究其原因，每个人的方法论都已经成为这个人根深蒂固的习惯了，在不经意间其实就已经在运用了。只不过，有的方法论是好的，是优秀的，是有价值的；而有些方法论则是不好的，应该被摒弃的。但正所谓，当局者迷，旁观者清。当事人往往对于自己所运用的方法论浑然不知。因此，即便自己所运用的方法论需要改进，他也完全不知晓。下面我举一个例子，相信大家都会感同身受。
当我们接到一个新的功能需求时，不同人的做法是截然不同的。有的人会选择立刻开始编码，写着写着开始发现问题，然后又修改代码；改完之后写了一阵，又发现有问题，然后接着改。上来就编码的做法看似快，但实则却会浪费不少时间，因为他会用所谓编码的忙碌来掩饰自己不愿意，或是不擅长思考的本性。而有的人则不会采取这种做法，他会根据功能需求首先进行设计，仔细思考这个新的功能需求会给既有系统带来哪些改变，对既有系统会产生何种影响，应该采取什么方式来更好地实现这个功能需求，最后一切都想清楚了，并且在纸上画明白了，最后才开始编码。这看似很慢的做法往往会带来更好的结果，而且总体时间会减少很多。这其实就是一种方法论的体现。
又，在学习一项新技术时，有些人采取的做法是在百度上到处搜，搜索完一篇文章后，走马观花地看一下，然后再继续搜，不得不说，这其实是很多人学习方式的真实写照，这么做看起来是挺快，不过结果可想而知。但，总有那么一群人，同样学习一项新技术，他会仔细阅读官方文档，阅读API说明，采取系统化的学习方式，先从宏观上对所要学习的技术有一个总体的把控，然后再由浅入深地学习技术的各个组成部分，正所谓从总体到局部。花费了足够的时间与精力对各个局部都有了较好的理解后，最后再从总体上审视这项技术，如果是一项重要技术，那么他还会花费足够的时间研究技术底层的源码与设计。看，这又是一种学习技术的方式。显然，这又是方法论的不同所导致的学习方式的不同，而且这种不同的差别还是非常大的。孰优孰劣，大家可以自行评判。
回到正题，本文我想谈及的两个要点分别是任务分解与保持节奏，下面逐个解释。
任务分解，顾名思义，就是将一个大任务划分为若干小任务，接下来再对分解之后的小任务继续划分，直到粒度足够细为止，没错，这其实就是Java 7所引入的Fork-Join框架的做法。编程语言中的很多问题解决方式都是来源于现实生活的。我们在现实生活中就会常常面临任务分解的场景。比如说，我们制订了为期一个月的开发任务。显然，我们需要对这一个月的时间进行细粒度的划分，明确每一天，每一周要完成哪些工作，要达成什么样的目标，每一周的里程碑是什么。确保每一天的工作都能完成是确保当周工作能够顺利完成的前提；而每一周工作的顺利完成则是确保整月工作顺利完成的重要前提。只有这样，我们的开发工作才能有条不紊，沿着既定的路线前行，不至于工作了一段时间后发现“跑偏了”。正确地做事与做正确的事哪一个更为重要呢？
有的人可能会说，开发会由于产品的不断修改而导致各种问题。没错，在现实工作中这种情况注定是不可避免的。但你要知道这样一个观点：制订计划的目的是为了更好地应对变化。如果没有良好的计划与任务分解能力，那么每天萦绕在你脑海中的总是这个待完成的任务整体，你丝毫体会不到一天工作下来对于整体任务的推进程度如何。这实际上是非常打消人的积极性的。
我毕业后的第一份工作是在理光软件研究所，接手的第一个项目就是公司自己开发的一个项目管理系统，这个系统涉及到PMBOK项目管理所涵盖的时间管理与范围管理两个领域。因此，这令我对项目管理有着更加深刻的认识。在团队协作中，总是存在依赖关系的。正如Spring Bean之间的Dependency一样，及BeanA依赖于BeanB，那么在初始化BeanA时，Spring会首先实例并初始化BeanB，然后将其注入到BeanA中。日常工作中也是如此，你的工作可能会被其他同事所依赖，如果你延误了，那么就会对其他人造成干扰。几次延误后，你在其他人眼中就是一个不遵守承诺的人，这与技术水准毫无关系。长此以往，你的口碑在团队中就会越来越差，对于个人所造成的影响不言而喻。因此，为了避免这一局面的出现，首先要做到的就是信守承诺，承诺别人的事情就一定要办到；如果因为种种原因无法达成，那么一定要提前与对方沟通，千万不要到截止日期前才告诉别人，说你没完成，这实在是下下的方式。
若想达成这样的结果，任务分解就是不二之选。对自己要做的工作与完成工作的时间进行合理的规划，并且对任务进行细粒度划分。明确自己每一天的工作成果，只有这样才能稳妥地完成各项工作与任务。每次都能很好地完成任务，你的口碑我相信在团队中一定会越来越好，这对于自己自信心的提升也是有诸多裨益的，这才是一个良性循环。
第二个话题：保持节奏。
其实，这是我一直在不断强调的四个字。很多人无论做什么，总期盼着一下子做完。不过实际上，除非是那种比较简单的工作；很多时候，很多任务，我们是根本不可能一下子搞定的。这时就需要我们保持一个良好的节奏，平稳地完成每天的工作，按照既定的目标不断前行。
在当下之时代，很多人并不是不努力，而是太努力了。用力过猛是很多人的真实写照，无论是工作上，抑或生活上。总期望一下子用猛力将事情做完。但结果往往不尽如人意。要知道的是，用力过猛极易导致过早放弃。我举一个我的实际例子。我从毕业到现在已经翻译了24本技术图书。每次接手一本新书的翻译工作时，我都会花费足够多的时间对图书内容进行一个较为细粒度的划分。一般来说，一本技术图书的翻译周期是3-4个月。这其实是一项长期的工作。为了让这长期的工作能够按照计划执行，我都会按照预先设定的节奏每天翻译几页，这样看起来其实每天翻译的工作量并不大，1-2小时而已，但我知道，只要我每天完成了这些工作，就不会造成翻译工作的拖延；同时，为了预防一些意外事件的发生（比如说生病、状态不好就是不想工作、工作比较忙等），我都会预留一些缓冲时间（这是不是又与Java IO中的缓冲区一样呢）。通过这样有节奏感的工作，我会确保翻译工作的不拖延，同时每天又不会感到很疲倦。
另外值得一提的就是目前的课程录制工作。现在，圣思园的课程是每周定期发布，这其实就是我保持节奏感的一种很好的体现。我从来不会一下子发布太多课程，也不会一下子什么也不发。从我们的JDK 8课程发布以来，我们已经持续了几个月的时间，这期间从未出现过因为我个人原因导致课程无法按时发布的情况。这正是保持节奏感的最佳实践，我准备每周的课程都是分为几个部分进行的；首先，当然是准备课程内容，这部分是最花费时间与精力的，我都会提前准备好，越提前越好；接下来，准备好后，我一般会找周末的时间完成录制，然后在预定的发布时间按时发布（也许我后面可以专门写一篇文章谈谈我是如何录制一节课程的）。
此外，我平时很喜欢跑步，下面是到目前为止我的总跑量，这其实也是我保持节奏感的做法。我一般是每周跑步20千米（除非遇到雾霾天气等一些不可控的客观因素），否则一定会完成自己的预定目标，这不仅是锻炼身体的一种好方式，而且也是履行自己对自己的承诺的一种做法。
--------------------- 作者：风中叶的思考 来源：CSDN 原文：https://blog.csdn.net/ricohzhanglong/article/details/80668226 版权声明：本文为博主原创文章，转载请附上博文链接！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e0a0c49b1fbf5c67f290d00a414fcd/" rel="bookmark">
			[填坑]Unable to start debugging.Unable to establish a connection to GDB.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只需要将launch.json,中externalConsole修改为true即可 参考：https://github.com/Microsoft/vscode-cpptools/issues/2889
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847f3414216b49ef8bcd4882301765a7/" rel="bookmark">
			Java8学习笔记（五）—— 方法引用(::双冒号操作符)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java8学习笔记系列： Java8学习笔记（一）—— 函数式编程的四个基本接口
Java8学习笔记（二）—— Lambda表达式
Java8学习笔记（三）—— Optional类的使用
Java8学习笔记（四） —— Stream流式编程
Java8学习笔记（五）—— 方法引用(::双冒号操作符)
一、什么是方法引用？ 简单来说就是一个Lambda表达式，方法引用提供了一种引用而不执行方法的方式，运行时，方法引用会创建一个函数式接口的实例。
如下所示：
@Test public void example1(){ //使用Lambda表达式 Consumer&lt;String&gt; consumer1 = x -&gt; System.out.println(x); consumer1.accept("Lambda表达式"); //使用方法引用 Consumer&lt;String&gt; consumer2 = System.out::println; consumer2.accept("方法引用::"); } 二、方法引用的五种方式 ① 引用对象的实例方法 对象::实例方法名
② 引用类的静态方法 类::静态方法名
③ 引用类的实例方法 类::实例方法名
④ 引用构造方法 类::new
⑤ 数组引用 类型::new
使用示例如下：
/** * 引用类 */ class Human{ private String name; private int age; public Human(){ } public Human(String name, int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847f3414216b49ef8bcd4882301765a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/027f2f1ede57e762ca46540657120741/" rel="bookmark">
			omni协议usdt钱包地址交易查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三方文档地址 https://api.omniexplorer.info/#request-v1-transaction-address
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35df72f86d550d42f072bb9b95819a20/" rel="bookmark">
			@Value注解失效的原因分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、@Value的注意事项
二、错误的方式
三、正确的方式
一、@Value的注意事项 1.不能作用于静态变量（static）；
2.不能作用于常量（final）;
3.不能在非注册的类中使用（类需要被注册在spring上下文中，如用@Service,@RestController,@Component等）；
4.使用这个类时，只能通过依赖注入的方式，用new的方式是不会自动注入这些配置的。
二、错误的方式 /** * 抽象工厂+反射 */ //不能在非注册的类中使用（类需要被注册在spring上下文中，如用@Service,@RestController,@Component等）； public class SimpleAbstractFactory { @Value("${packName}") //不能作用于静态变量（static） private static String packName; @Value("${sqlName}") //不能作用于常量（final）; private final String sqlName; public IUser CreateUser() throws Exception{ String className=packName+"."+sqlName+"IUser"; return (IUser)Class.forName(className).newInstance(); } public IDepartment CreateDepartment() throws Exception{ String className=packName+"."+sqlName+"IDepartment"; return (IDepartment)Class.forName(className).newInstance(); } } @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = {"classpath:spring-config.xml"}) public class MainToken{ @Test public void testToken() { try{ //使用这个类时，只能通过依赖注入的方式，用new的方式是不会自动注入这些配置的。 SimpleAbstractFactory simpleAbstractFactory=new SimpleAbstractFactory(); User user=new User(); Department department=new Department(); IDepartment idp=simpleAbstractFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35df72f86d550d42f072bb9b95819a20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b590d68ff4d2f43ac8ea180575758ad6/" rel="bookmark">
			json.load()方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		json.load()方法 参考[1] https://docs.python.org/2/library/json.html
conversion table如下：
我们使用最多的就是将json对象转换成Python dict.
举个例子，
1.txt
{ "filename": "/mnt/data/src/0a5ca1430d.c", "tokens": [ { "kind": "Keyword", "line": 2, "sem": "FunctionDecl", "text": "int" }, { "kind": "Identifier", "line": 2, "sem": "FunctionDecl", "sym": { "id": "c:@F@main", "kind": "FunctionDecl", "type": "int ()" }, "text": "main" } ] } test.py
# -*- coding: utf-8 -*- # @Author: Chenglin Yu # @Date : 2019/7/13 # @Desc : import json if __name__ == '__main__': with open("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b590d68ff4d2f43ac8ea180575758ad6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ee89637577fa719b2099a087e3f2df6/" rel="bookmark">
			【Navicat】连接Oracle时提示oracle library is not loaded的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考地址：https://blog.csdn.net/gxp1182893781/article/details/79815573
笔者使用的Navicat Premium 12启动界面截屏：
请注意是64位的。笔者win7 64位系统。
连接Oracle时提示“oracle library is not loaded”。
解决方法：
1.前往“http://www.oracle.com/technetwork/database/database-technologies/instant-client/downloads/index.html”
2.选择与自己系统匹配的“Instant Client”。
我的是64位的软件，所以我选择第一个“Instant Client for Microsoft Windows(x64)”，如果你的软件是32位的 ，就选择第二个。
3.按照图示选择“Accept License Agreement”，然后点击“ instantclient-basic-windows.x64-x.x.x.x.zip”。这里的"x.x.x.x"是版本号，这个不重要，理论上任何版本都行的。注意，这时候需要你登录Oracle账号，没有可以直接注册个，不麻烦。
4.如果没有登录，则会跳转到下面的登录界面。没有账户就注册个账户，有就直接输入账号跟密码，点击“登录”按钮就会自动下载那个zip压缩包了。
5.下载好压缩包后解压，并将解压后的目录放在一个没有中文字符的路径之下，这样做是为了防止程序出错。我把它放在了："D:\ORACLE"目录下了。
6.打开Navicat Premium程序，打开“工具 - 选项 - 环境 - OCI环境 - OCI library (oci.dll)”，然后将你刚才下载的文件夹中的oci.dll文件的完整目录填上，点击确定。
7.重启Navicat Premium程序进行测试双击oracle数据库，发现现在可以连接了，完成。
注意：特别注意：
配置完后一定要重新启动Navicat Premium程序，否则配置无法生效！！重要的事情说三遍！！！
配置完后一定要重新启动Navicat Premium程序，否则配置无法生效！！重要的事情说三遍！！！
配置完后一定要重新启动Navicat Premium程序，否则配置无法生效！！重要的事情说三遍！！！
近来有几个朋友说按照我的方法无法解决问题，你可以试一下安装我安装的版本。
必须安装oracle客户端的。注意是客户端，不是服务端。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8578c8bf886be7dfdbe4ed11d85208d0/" rel="bookmark">
			有几个软件包无法下载，要不运行 apt-get update 或者加上 --fix-missing 的选项再试试？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 使用 sudo vim /etc/apt/sources.list 修改镜像源。
2. 然后执行 sudo apt-get update 更新。
镜像源如下，推荐使用国内源，速度更快。镜像源内容转载自 https://blog.csdn.net/skyie53101517/article/details/50450989。
官方源
deb http://archive.ubuntu.com/ubuntu/ trusty main restricted universe multiverse
deb http://archive.ubuntu.com/ubuntu/ trusty-security main restricted universe multiverse
deb http://archive.ubuntu.com/ubuntu/ trusty-updates main restricted universe multiverse
deb http://archive.ubuntu.com/ubuntu/ trusty-proposed main restricted universe multiverse
deb http://archive.ubuntu.com/ubuntu/ trusty-backports main restricted universe multiverse
deb-src http://archive.ubuntu.com/ubuntu/ trusty main restricted universe multiverse
deb-src http://archive.ubuntu.com/ubuntu/ trusty-security main restricted universe multiverse
deb-src http://archive.ubuntu.com/ubuntu/ trusty-updates main restricted universe multiverse
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8578c8bf886be7dfdbe4ed11d85208d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0349a45456d68b929f91301605552d52/" rel="bookmark">
			Nginx 安装配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx("engine x")是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。
在高连接并发的情况下，Nginx是Apache服务器不错的替代品。
nginx-1.17.3.tar.gz pcre2-10.33.tar.gz 推荐博文链接：推荐参考的博文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e725029d39141023b04e7e5acd8139a/" rel="bookmark">
			C#日期格式精确到毫秒 ！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们要对时间进行转换,达到不同的显示效果
默认格式为:2009-6-24 14:33:34
如果要换成成200906,06-2009,2009-6-24或更多的该怎么办呢
我们要用到:DateTime.ToString的方法(String, IFormatProvider)
using System;
using System.Globalization;
String format="D";
DateTime date=DataTime,Now;
Response.Write(date.ToString(format, DateTimeFormatInfo.InvariantInfo));
结果输出
Thursday, June 24, 2009
C# 日期格式转换
参数format格式详细用法
格式字符 关联属性/说明
d ShortDatePattern
D LongDatePattern
f 完整日期和时间（长日期和短时间）
F FullDateTimePattern（长日期和长时间）
g 常规（短日期和短时间）
G 常规（短日期和长时间）
m、M MonthDayPattern
r、R RFC1123Pattern
s 使用当地时间的 SortableDateTimePattern（基于 ISO 8601）
t ShortTimePattern
T LongTimePattern
u UniversalSortableDateTimePattern 用于显示通用时间的格式
U 使用通用时间的完整日期和时间（长日期和长时间）
y、Y YearMonthPattern
C# 日期格式转换
下表列出了可被合并以构造自定义模式的模式。这些模式是区分大小写的；例如，识别“MM”，但不识别“mm”。如果自定义模式包含空白字符或用单引号括起来的字符，则输出字符串页也将包含这些字符。未定义为格式模式的一部分或未定义为格式字符的字符按其原义复制。
格式模式 说明
d 月中的某一天。一位数的日期没有前导零。
dd 月中的某一天。一位数的日期有一个前导零。
ddd 周中某天的缩写名称，在 AbbreviatedDayNames 中定义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e725029d39141023b04e7e5acd8139a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bc02b5888ebf0f73cae03dc97765ac2/" rel="bookmark">
			Hive删除表中数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一：仅删除表中数据，保留表结构
truncate table 表名; （truncate用于删除所有的行，这个行为在hive元存储删除数据是不可逆的）
或 delete from 表名 where 1 = 1 ; （delete用于删除特定条件下的行，使用where 1=1 删除所有行 SQL中where 1 = 1 的使用）
truncate 不能删除外部表！因为外部表里的数据并不是存放在Hive Meta store中
方式二：删除整个表
drop table 表名;
如果要永久性删除，不准备再恢复：
drop table 表名 purge;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707d0baa0f14b652891d1f74a176db55/" rel="bookmark">
			关于&amp;lt;script&amp;gt;元素（js两种引用方法：内部嵌入，外部引入）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、在HTML中引用JavaScirpt脚本的方法有两种：内部嵌入和外部引用。二、在同一个HTML文档中，调用多个JavaScript脚本。三、&lt;script&gt;元素定义的6个属性。 一、在HTML中引用JavaScirpt脚本的方法有两种：内部嵌入和外部引用。 关于&lt;script&gt;标签的位置问题，虽然&lt;script&gt;&lt;/script&gt;可以放在&lt;head&gt;&lt;/head&gt;里面，也可放在&lt;body&gt;&lt;/body&gt;里面，但为了避免浏览器加载延迟，最好是放在&lt;/body&gt;前面。
内部嵌入：直接在HTML文档内使用&lt;script&gt;&lt;/script&gt;标记对引入。 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;内容&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascirpt"&gt; //脚本语句··· &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Tips：虽然现在已被告知可不再写 type=“text/javascript” 属性，因为现在即使不指定这个属性，其默认值仍为 “text/javascirpt” 。但，个人建议还是要习惯性加上，写上可以明确指示浏览器按照何种脚本以及何种版本加载和解析脚本，可以有效避免兼容性或者版本差异造成的错误。
外部引入：通过src属性指定外部JavaScript文件链接。 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;内容&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript" src="javascript.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这里使用 src 属性引入javascript.js的JS文件，建议js文件和html文件放在同一个目录里，这样写 src 地址就不用这么长这么麻烦了。而在js文件里面，无需写&lt;script type="text/javascript"&gt;&lt;/script&gt;了，直接开始js脚本的编写：
document.write("Hello World!"); //等等js Tips1：src 属性还可以包含来自外部域的JavaScript文件。它的 src 属性可以是指向当前HTML页面所在域之外的某个域中的URL。
&lt;script type="text/javascript" src="http://www.xxx.com/xx.js"&gt;&lt;/script&gt; Tips2:除了通过外部URL引入js脚本，还可以通过伪URL引入。伪URL地址的格式一般以 "javascript:"开始，后面紧跟要执行的操作。
&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707d0baa0f14b652891d1f74a176db55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e76f0174b1a55f56ce8ac0cd0b3bf4c4/" rel="bookmark">
			Elasticsearch——RestHighLevelClient
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 java rest client有两个实现类，分别是RestClient和RestHighLevelClient。前者是一个低级客户端，通过Http与elasticsearch集群进行通信，可以做到 负载均衡、故障转移、持久化链接、自动发现集群节点等功能，同时支持所有elasticsearch版本，但是需要自己对请求和相应做编解码（自己写JSON）；后者是一个高级客户端，对增删改差进行了封装，不需要处理编解码，类似之前的TransportClient，但是兼容性较差，对客户端和集群版本要求较高。
因为RestClient没有提供增删改差方法，只能自己写json并选择Http请求的方法进行实现，一般使用较少，只有RestHighLevelClient无法满足的情况下才会使用。这里主要介绍RestHighLevelClient。
RestHighLevelClient RestHighLevelClient restHighLevelClient = new RestHighLevelClient(restClient);
RestHighLevelClient仅仅是对RestClinet的一个封装。支持异步请求。
search api
请求
构造查询主要用到两个类：SearchRequest和SearchSourceBuilder。
SearchRequest searchRequest = new SearchRequest(); //穿件SeachRequest，Without arguments this runs against all indices. SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();// 大多数的搜索参数被添加到 SearchSourceBuilder 。它为每个进入请求体的每个东西都提供 setter 方法。 searchSourceBuilder.query(QueryBuilders.matchAllQuery()); // 添加一个 match_all 查询到 searchSourceBuilder 。 searchRequest.source(searchSourceBuilder); //将searchSourceBuilder添加到searchRequest 这里构造了一个查询请求，内容为一个match_all查询。
SearchRequest为最终的查询请求封装，而查询的大部分细节由SearchSourceBuilder指定。
首先来看一下常用的几个SearchRequest方法
SearchRequest searchRequest = new SearchRequest("posts"); // 限制请求到某个索引上 searchRequest.indices("gets"); //设定索引 searchRequest.types("doc"); // 限制请求的类别 Es-java包中请求体封装类，其属性的setter和getter方法，都没有相应的set和get标记，直接使用属性名作为方法名，然后通过入参和返回值区分哪个是setter哪个是getter。之前版本中用的标准setter和getter在（至少在5.X）客户端中已经不见了。 还有很多其他的配置参数，这里不再罗列。
然后是搜索细节——SearchSourceBuilder
SearchSourceBuilder可以配置大多数的搜索细节，以下为几个实例，详细参考文档：
SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); //使用默认选项创建 SearchSourceBuilder 。 sourceBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e76f0174b1a55f56ce8ac0cd0b3bf4c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124c7df8b6e0aec934ac595c090141ee/" rel="bookmark">
			iview中Modal组件点击确定后验证信息不通过则不关闭弹窗方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Modal对话框过程中，遇到当点击确定按钮后，即使有检验信息不通过，写了return，弹窗依然关闭了，解决方案如下
&lt;Modal v-model="isTemManageShow" title="管理模板" @on-ok="ok" :loading="loading" @on-cancel="cancel"&gt; &lt;div class="mb10"&gt; &lt;!-- your content --&gt; &lt;/div&gt; &lt;/Modal&gt; 要点分析
添加loading状态，loading初始值为true
手动关闭弹窗this.isTemManageShow = false
JS核心代码
messageWarningFn (text) { this.$Message.warning(text) setTimeout(() =&gt; { this.loading = false this.$nextTick(() =&gt; { this.loading = true }) }, 500) }, ok () { if (!this.addTitle) { this.messageWarningFn('请输入名称') return } if (this.addTitle.length &gt; 20) { this.messageWarningFn('标题不超过20个文字') return } if (!this.addContent.trim()) { this.messageWarningFn('请输入内容') return } // 请求参数 if (this.templateId2 !== -1) { // 更新 } else { // 添加 for (let i = 0; i &lt; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/124c7df8b6e0aec934ac595c090141ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02cc9d708c7e1ed932c2bbda6e4bfe5b/" rel="bookmark">
			解决Mybatis-plus和pagehelper依赖冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。
启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作
Mybati-plus本身自带分页功能，但是我个人一直是使用pagehelper进行分页，所以在pom中添加了pagehelper依赖，但是运行项目后发现jar包冲突，面对冲突我们应该怎么解决它呢，看完如下内容便可轻松解决
先看依赖 &lt;!-- mbatis-plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--generator--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- pagehelper--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; 运行项目
*************************** APPLICATION FAILED TO START *************************** Description: An attempt was made to call a method that does not exist. The attempt was made from the following location: com.baomidou.mybatisplus.core.MybatisMapperAnnotationBuilder.getLanguageDriver(MybatisMapperAnnotationBuilder.java:369) The following method did not exist: com.baomidou.mybatisplus.core.MybatisConfiguration.getLanguageDriver(Ljava/lang/Class;)Lorg/apache/ibatis/scripting/LanguageDriver; The method's class, com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02cc9d708c7e1ed932c2bbda6e4bfe5b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/469/">«</a>
	<span class="pagination__item pagination__item--current">470/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/471/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>