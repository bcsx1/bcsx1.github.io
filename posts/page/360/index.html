<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed9eff35bfd0dae63f00518bcc99a22/" rel="bookmark">
			android sparsearray 排序,Android SparseArray 源码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android开发中如果使用key为Integer的HashMap，就会出现黄色警告，提示使用SparseArray，SparseArray具有比HashMap更高的内存使用效率，我们在前面的《Android HashMap源码详解》中提到，HashMap的存储方式是数组加链表，今天要分析的SparseArray是使用纯数组的形式存储。我们先来看其中的一个构造方法public SparseArray(int initialCapacity) {
if (initialCapacity == 0) {
mKeys = ContainerHelpers.EMPTY_INTS;
mValues = ContainerHelpers.EMPTY_OBJECTS;
} else {
initialCapacity = ArrayUtils.idealIntArraySize(initialCapacity);
mKeys = new int[initialCapacity];
mValues = new Object[initialCapacity];
}
mSize = 0;
}
先给一个初始空间的大小，默认的是10，但是这个最终空间大小是由计算得到的最理想的大小，public static int idealIntArraySize(int need) {
return idealByteArraySize(need * 4) / 4;
}
public static int idealByteArraySize(int need) {
for (int i = 4; i if (need &lt;= (1 &lt;
return (1 &lt;
return need;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ed9eff35bfd0dae63f00518bcc99a22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06c24245f574e31d9be58c213ac14b73/" rel="bookmark">
			android进度提示,Android进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同的进度条显示结果:
demo xml代码:
xmlns:app="http://schemas.android.com/apk/res-auto"
xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:orientation="vertical"
android:gravity="center_horizontal"
tools:context=".util.ProgressActivity"
android:padding="15dp"&gt;
android:id="@+id/pb1"
android:layout_width="wrap_content"
android:layout_height="wrap_content"/&gt;
android:id="@+id/pb2"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
style="@android:style/Widget.ProgressBar"
android:layout_marginTop="10dp"/&gt;
android:id="@+id/pb3"
android:layout_width="match_parent"
android:layout_height="wrap_content"
style="@android:style/Widget.ProgressBar.Horizontal"
android:layout_marginTop="10dp"
android:max="100"
android:progress="10"
android:secondaryProgress="30"/&gt;
android:id="@+id/pb4"
android:layout_width="match_parent"
android:layout_height="wrap_content"
style="@android:style/Widget.Material.ProgressBar.Horizontal"
android:layout_marginTop="10dp"
android:max="100"
android:progress="10"
android:secondaryProgress="30"/&gt;
二.模拟进度条加载过程:
运行展示图:
xml代码:
android:id="@+id/btn_start"
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:text="模拟进度"
android:layout_marginTop="10dp"/&gt;
Activity代码:
package com.example.lineralayout.util;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.Toast;
import com.example.lineralayout.R;
public class ProgressActivity extends AppCompatActivity {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06c24245f574e31d9be58c213ac14b73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d96091dae8120209c3f326f20ee0341/" rel="bookmark">
			第83节 多维数组作函数参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.用多维数组名作函数参数
1.写函数,求3×4矩阵中所有元素中的最大值
#include &lt;stdio.h&gt; int max_value(int array[][4]); int main() { int a[3][4] = { {11,32,45,67},{22,44,66,88},{15,72,43,37} }; printf("max value is %d \n", max_value(a)); return 0; } int max_value(int array[][4]) { int max = array[0][0]; for (int i = 0; i &lt; 3; ++i) for (int j = 0; j &lt; 4; ++j) if (array[i][j] &gt; max) max = array[i][j]; return max; } 运行结果: max value is 88 2.几种函数原型分析:
 数组定义: int a[3][4]={…}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d96091dae8120209c3f326f20ee0341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/134dcaf81494afbefc6d3074f128b727/" rel="bookmark">
			我的分享：第九章：月薪三万执行计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何办成一件事？
比如，我要赚钱，一个月月薪三万，我该怎么去做？
第一步：挖掘自己的能力，分析可能性 作为技术人员（Java开发工程师），我的长处就是技术，通过技术变现，那么有哪些渠道呢？
工作，自媒体，写书，接私活，理财等。
工作： 找一份高薪的工作，技术能力要求高，能力不够的时候需要花大量的时间学习，能力上去了，还需要备战面试，写好简历，准备面试。固定收入（可行）
自媒体： 这个属于周期长，长期输出干货，提升影响力，副业提升主业，建立个人品牌效应。被动收入（可行）
写书： 周期中等，文档能力提升不少，副业提升主业，提升影响力，建立个人品牌效应。被动收入（可行）
接私活： 短期，工作强度大，提升项目经验，副业提升主业。下班回来已经很晚了，回来接着弄干私活除了提升项目经验几乎压榨所有的业余时间。额外收入（排除）
理财： 基金，股票，债券等。波动收入（可行）
第二步：制定大计划 工作： 编写一份月薪三万的简历，根据简历写的技术点，系统性学习，理论方面：列出脑图，编写博文；项目方面：将简历中的技术点单独拎出来进行demo实现，并设计多种业务场景。
自媒体： 方向定型，选择技术方向，学习视频剪辑，定期录制输出。
写书： 结合市场需求，找对方向，列举大纲，编写正文。
理财： 可当做爱好了解
第三步：了解市场需求 工作：Java资深开发30k - 参与 NIO ⽤⼾端和企业端相关软件和后台服务的设计和开发；
- 在产品交付周期的各个阶段内持续贡献，包括且不限于需求沟通 / 系统设计 / 撰写⽂档 / 研发功能 /
测试沟通和⽀持 / 线上系统的监控运维等。
岗位要求：
- 本科及以上学历，计算机科学及相关专业优先；
- 熟悉常⽤的数据结构和算法；
- 熟悉分布式系统，熟悉常⻅的⼀致性协议、消息队列、分布式存储和缓存等（如 Zookeeper /
MongoDB / Redis / Cassandra / Kafka 等）；
- 能熟练运⽤线程池 / 异步 / 缓存 / 锁等技术构建⾼效、健壮、⾼可⽤的系统；
- 有 MySQL 相关使⽤和调优经验，熟悉数据库的索引原理、事务的隔离、传播⽅式和加锁⾏为，能够
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/134dcaf81494afbefc6d3074f128b727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95ab8e5cfce23ee711e194c7dcec0fc0/" rel="bookmark">
			BLE 技术（七）--- BLE MESH 是如何设计的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、BLE MESH 如何定义并传递消息？1.1 如何定义MESH 设备的消息？1.2 如何在MESH 中传递消息？1.3 如何在MESH 中寻址目的节点？ 二、BLE MESH 如何保证通信安全？2.1 子网隔离与加密认证2.2 启动配网与密钥分发2.3 重放攻击与模糊化处理2.4 垃圾桶攻击与密钥刷新 三、BLE MESH 如何支持低功耗设备？3.1 LPN与FN 如何建立Friendship？3.2 LPN 与FN 如何传递消息？ 四、BLE MESH 如何支持BLE GATT 设备？4.1 BLE GATT 设备如何收发MESH 消息？4.2 BLE MESH 如何保证与GATT 设备通信的安全？4.3 BLE GATT 设备如何管理订阅列表？ 更多文章： 前言 前篇博文BLE协议栈设计与演进介绍过，当BLE 设备数量比较多时，常用的大规模组网方式有IP 组网和MESH 组网两种。如果熟悉TCP/IP 协议，不难理解 IP 组网就是将BLE 作为数据链路层，在其上添加TCP/IP协议栈接入Internet，如果需要接入云平台实现大规模远程监控，可以借助MQTT 协议的消息发布-订阅模型来实现。
很多场景下，我们并不需要每台设备都接入Internet，而是需要大量的BLE 设备在本地组成一个智能局域网，比如楼宇智能照明网络、传感器网路等。为此，SIG 于2017 年发布了Bluetooth mesh networking 规范，使用MESH 网络拓扑结构可以实现本地大规模自组网，BLE MESH 有哪些特点或优势？又是怎么实现的呢？
MESH 类似于TCP/IP 协议，是一种网状网络标准，下层需要物理层和数据链路层的支撑，BLE MESH 就是基于BLE 的网状网络标准，允许大量BLE 设备之间进行多对多通信。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95ab8e5cfce23ee711e194c7dcec0fc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd6837927e7174a117536aea6b0abec2/" rel="bookmark">
			springcloud&#43;dubbo&#43;nacos搭建(nacos使用mysql存储)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面两篇讲了不用springcloud做粘合，直接springboot+dubbo+nacos+sentinel的搭建
这篇讲用springcloud做粘合是怎么搞的
一、nacos作为注册中心 1.原理 2.调用方business服务代码 场景是business项目调用storage项目
目录
pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;test-spring-cloud-alibaba&lt;/artifactId&gt; &lt;groupId&gt;com.sid&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;business&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 这个是接口包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.sid&lt;/groupId&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 不加这个不行，好像是给nacos上报用的http协议 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd6837927e7174a117536aea6b0abec2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1027211fb92c98e5ab41a60334e92da2/" rel="bookmark">
			Web在线聊天室(完结) --- 注册用户&#43;ip地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注册用户 注册用户接口设计前端异步回调ajax函数编写servlet实现注册业务逻辑操作数据库插入新用户实现效果 项目发布地址 注册用户 接口设计 请求: POST /register { name: xxx, password: xxx, nickName: "蔡徐坤", signature: "我擅长唱跳rap篮球", } 响应: HTTP/1.1 200 OK { ok: 1, reason: xxx } 前端异步回调ajax函数 register(){ $.ajax({ url: 'register', type: 'post', contentType: 'application/json', data: JSON.stringify({ name: app.registerForm.inputUsername, password: app.registerForm.inputPassword, nickName: app.registerForm.inputNickName, signature: app.registerForm.inputSignature, }), success: function(data, status) { if (!data.ok) { alert('注册失败! ' + data.reason); return; }else { alert("恭喜你，注册成功！") } app.registerForm.showDialog = false; app.login.showLoginDialog = true; } }) } 编写servlet实现注册业务逻辑 package org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1027211fb92c98e5ab41a60334e92da2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5542d1941fe2735ce82e19ff6cd80b1b/" rel="bookmark">
			Scapy的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scapy的交互shell是运行在一个终端会话当中。因为需要root权限才能发送数据包，所以我们在这里使用sudo
$ sudo scapy Welcome to Scapy (2https://wizardforcel.gitbooks.io/scapy-docs/content/0https://wizardforcel.gitbooks.io/scapy-docs/content/1-dev) &gt;&gt;&gt; 在Windows当中，请打开命令提示符（cmdhttps://wizardforcel.gitbooks.io/scapy-docs/content/exe），并确保您拥有管理员权限：
C:\&gt;scapy INFO: No IPv6 support in kernel WARNING: No route found for IPv6 destination :: (no default route?) Welcome to Scapy (2https://wizardforcel.gitbooks.io/scapy-docs/content/0https://wizardforcel.gitbooks.io/scapy-docs/content/1-dev) &gt;&gt;&gt; 如果您没有安装所有的可选包，Scapy将会告诉你有些功能不可用：
INFO: Can't import python gnuplot wrapper https://wizardforcel.gitbooks.io/scapy-docs/content/ Won't be able to plothttps://wizardforcel.gitbooks.io/scapy-docs/content/ INFO: Can't import PyXhttps://wizardforcel.gitbooks.io/scapy-docs/content/ Won't be able to use psdump() or pdfdump()https://wizardforcel.gitbooks.io/scapy-docs/content/ 虽然没有安装，但发送和接收数据包的基本功能仍能有效。
本节将会告诉您一些Scapy的功能。让我们按上文所述打开Scapy，亲自尝试些例子吧。
让我们来建立一个数据包试一试
&gt;&gt;&gt; a=IP(ttl=10) &gt;&gt;&gt; a &lt; IP ttl=10 |&gt; &gt;&gt;&gt; ahttps://wizardforcel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5542d1941fe2735ce82e19ff6cd80b1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b31124c4ede0ee0d8b2e3f07f3f9de9e/" rel="bookmark">
			html5文字横向变纵向,使用writing-mode让文字竖向排版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常我们网页上的文字在缺省状况下是从左到右横向排版的，但有些情况下，为了排版效果，或为了更好的利用页面空间，我们需要将文字竖向排版。以前有一种很土的方法，就是让文字的容器只有一个文字的宽度，挤的文字竖向排列。在table表头里通常会有这种效果。
writing-mode是CSS3里新引入的可以让文字竖向排版的属性。它不仅可以让文字竖向，还可以让文字从右往左排。这个CSS3属性还处在实验阶段，使用最新版的谷歌浏览器或火狐浏览器时，最好在属性前面加入浏览器引擎前缀。
下面我们看看writing-mode属性的语法：
/* Keyword values */
writing-mode: horizontal-tb;
writing-mode: vertical-rl;
writing-mode: vertical-lr;
/* Global values */
writing-mode: inherit;
writing-mode: initial;
writing-mode: unset;
writing-mode的几个属性值介绍：
horizontal-tb
文字从左到右排列，换行内容是从上往下扩展。
vertical-rl
文字从上到下排列，换行内容是从右往左扩展。
vertical-lr
文字从上到下排列，换行内容从左往右扩展。
sideways-rl
是正常的文字内容逆时针旋转90度得到的效果。
sideways-lr
是正常的文本内容顺时针旋转90度得到的效果。
下图是设计预期的效果图：
实际执行效果是这样的：
上面sideways-rl和sideways-lr两个属性目前还处于试验阶段，有些浏览器里不一定有效果。对于这种效果的文字排版，我们有很好的替代方法，就是使用CSS3里的变换旋转功能:
.vertical-text {
transform: rotate(90deg);
transform-origin: left top 0;
}
实例效果：
writing-mode废弃的属性值
注意：下面这些属性是已经废除的writing-mode属性值，如果你在新版浏览器里属于这些属性值将没有效果。
lr-tb
tb-rl
lr
rl
tb
一个有趣的事情，实验中发现，writing-mode属性在table上设置时，谷歌浏览器上不起作用，火狐浏览器上正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176fccd8aa368b00796128f0ebd8e83e/" rel="bookmark">
			html界面等待状态,html 等待界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发送中,请稍等... function show(o1,o2,open)
{
var o1 = document.getElementById(o1);
var o2 = document.getElementById(o2);
o1.style.width = document.documentElement.scrollWidth;
o1.style.height = document.documentElement.scrollHeight
if(open){
o1.style.display = "block";
o2.style.display = "block";
}else{
o1.style.display = "none";
}
}
function showLoading(open)
{
var dialog = document.getElementById("loading");
if(open){
dialog.style.display = "block";
}else{
dialog.style.display = "none";
}
return true;
}
function sendOSMessageForAll()
{
show('pop','message_form',true);
showLoading(true);
$.ajax({
url : 'android/createOSMessage.action',
data:{senderId:$("#senderId").attr("value"),content:$("#content").attr("value"),receiver:$("#receiver").attr("value")},
cache : false,
async : true,
type : "POST",
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/176fccd8aa368b00796128f0ebd8e83e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13349fd8278f88f053bf4444588308cb/" rel="bookmark">
			安卓APP_ Fragment（5）—— Fragment &#43; ViewPager2 模拟微信首页 （2）两者联动翻页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘自：安卓APP_ Fragment（5）—— Fragment + ViewPager2 模拟微信首页 （2）两者联动实现翻页
作者：丶PURSUING
发布时间： 2021-04-22 00:11:43
网址：https://blog.csdn.net/weixin_44742824/article/details/115956924
目录 效果与UI框架（1）定义导航栏大致布局（2）初步设置导航栏图标点击响应事件（3）导航栏图标跟随viewPager滑动一同变化（4）点击导航栏图标，切换viewPager更多细节在具体代码中体现 效果与UI框架 模拟微信首页的最终实现效果如下图：
要实现下面导航栏的效果，有很多的实现方案，典型的是navigation。这个控件把整个联动效果都完成了,开发变得非常简单，在下一章节中再介绍这个简便高级的办法
下面硬撸代码，了解更底层地原理。一行行手写效果。总的UI框架为：
（1）定义导航栏大致布局 导航栏框
导航栏中的图标按钮（其中一个）
点击按钮图标的变化实际上是换了一张图片
（2）初步设置导航栏图标点击响应事件 用图标所对应的LinearLayout响应点击事件
布局初始化与设置监听
在main.xml中引用
（3）导航栏图标跟随viewPager滑动一同变化 viewPager既然能够设置滑动，必然有滑动的监听接口
要重置状态，使得按钮变化正常化（不点击与点击对应不同状态）
（4）点击导航栏图标，切换viewPager 完成按钮的点击事件
viewPager设置item，实现页面切换
更多细节在具体代码中体现 代码架构
bottom_layout.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!--导航栏布局，方向为水平，颜色为#0E0E0E(灰色)--&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="55dp" android:background="@color/gray" android:orientation="horizontal"&gt; &lt;!-- 宽度设置为0，权重为1，表示宽度按照LL个数自动分配--&gt; &lt;LinearLayout android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" android:orientation="vertical" android:id="@+id/id_tab_weixin"&gt; &lt;ImageView android:layout_width="32dp" android:layout_height="32dp" android:id="@+id/tab_iv_weixin" android:background="@drawable/tab_weixin"/&gt; &lt;TextView android:layout_width="32dp" android:layout_height="wrap_content" android:id="@+id/text_weixin" android:gravity="center" android:text="微信"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13349fd8278f88f053bf4444588308cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb09e11f9651988d71d9b5085fc38be2/" rel="bookmark">
			js中的事件委托
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念
委托事件，又名事件代理。事件委托就是通过事件冒泡，把子元素上的事件委托给父元素。阻止事件冒泡就没办法实现事件委托了。
事件委托的优点
减少内存占用，减少事件注册。新增元素实现动态绑定事件 应用的场景
事件冒泡，当触发子元素的事件时，通过冒泡将事件传递给父元素，父元上绑定有处理程序，进而触发
使用背景
事件委托通常用在导航列表中
在这里插入代码片 &lt;ul id="my-ul"&gt; &lt;li onclick="alertText(this)"&gt;1&lt;/li&gt; &lt;li onclick="alertText(this)"&gt;2&lt;/li&gt; &lt;li onclick="alertText(this)"&gt;3&lt;/li&gt; &lt;li onclick="alertText(this)"&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; function alertText(ele){ alert(ele.innerText) } &lt;/script&gt; 普通写法为给每个 li 设置一个点击事件，然后弹出它对应的内容，这样写当然也是没问题的，但是如果要增加 li 或者li比较多的情况，比如下面这样：
&lt;ul id="my-ul"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;12&lt;/li&gt; &lt;li&gt;13&lt;/li&gt; &lt;li&gt;14&lt;/li&gt; &lt;li&gt;15&lt;/li&gt; &lt;li&gt;16&lt;/li&gt; &lt;li&gt;17&lt;/li&gt; &lt;li&gt;18&lt;/li&gt; &lt;li&gt;19&lt;/li&gt; &lt;li&gt;20&lt;/li&gt; &lt;/ul&gt; 这样为每个 li 设置点击事件当然也不是不行，但是这样代码的可观性和冗余性就比较差，所以此时就可以用到事件委托。
事件委托
将 li 的点击事件交给它的父级 ul 来执行，因为点击 li 时会进行事件的冒泡，所以父级元素的点击事件也可以执行，那么问题就变成只用给 ul 添加点击事件就行了，像下面这样
script&gt; let myUl = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb09e11f9651988d71d9b5085fc38be2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f601d4f236dcd11f1dc97ed430e64b2/" rel="bookmark">
			textureView.getSurfaceTexture() == null解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		textureView.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() { @Override public void onSurfaceTextureAvailable(@NonNull SurfaceTexture surface, int width, int height) { playVideo();//该方法里有textureView.getSurfaceTexture()的操作 } @Override public void onSurfaceTextureSizeChanged(@NonNull SurfaceTexture surface, int width, int height) { } @Override public boolean onSurfaceTextureDestroyed(@NonNull SurfaceTexture surface) { return false; } @Override public void onSurfaceTextureUpdated(@NonNull SurfaceTexture surface) { } }); 这样就解决了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0a04792b1b8676048910aae53456c9e/" rel="bookmark">
			html中斜体样式怎么写,html &lt;i&gt; 斜体标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html I斜体标签 html i标签
html标签之html字体斜体标签标签教程。 html斜体标签是用于改动文字字体显现名目，i让字体斜着闪现。在结构中大面积使用不是很多，但在小部门为了达到排版都雅或某个须要，无意偶尔对文字字体斜体表示，即可以或许使用html i标签来实现(懂得和html i同样有着让字体倾斜斜体展示html em比较张扬标签)。
一、html 斜体i语法结构
1、html i语法先容
i标签是一对有劈头有结束的标签，以最早，以完结。
html i分析图
html i斜体结构语法综合图
2、html斜体小试
html i斜体小试代码：
我是畸形字体我被斜体
截图
斜体标签小试成效截图
二、html i斜体标签应用
在一段笔墨中，一些笔墨加html斜体标签，测试html斜体名目标签造诣。
1、完整HTML代码-html斜体代码
html i斜体实例 CSS5 我是畸形字体被斜体CSS5斜体！
以上html斜体实例代码大概直接拷贝测试使用。
2、斜体实例成果截图
html斜体使用实例功效截图
三、斜体总结
在CSS中font-style:italic也是设置装备摆设字体斜体样式，这里HTML标签中也是配置字体斜体名堂。一个是CSS技俩设置装备摆设斜体，一个是HTML标签设置装备摆设斜体款式，在现实DIV CSS组织中都不能丢，不管html标签照样CSS花样设置斜体，按照必要决意使用实现斜体款式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/455ca79c5e9d07f121e0b7cd4f839a74/" rel="bookmark">
			MVC&#43;三层架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.MVC MVC,即Model模型、View视图，及Controller 控制器。
View:视图为用户提供使用界面，与用户直接进行交互。Model:模型 承载数据,并对用户提交请求进行处理的模块。
其分为两类, 一类称为数据承载Bean, 一类称为业务处理Bean。所谓数据承载Bean是指实体类,专门用于承载业务数据的,如Student, User等。而业务处理Bean则是指Service 或Dao对象,专门用于处理用户提交请求的。
Controller: 控制器用于将用户请求转发给相应的Model进行处理,并根据Model的计算结果向用户提供相应响应。 MVC架构程序的工作流程是这样的:
(1)用户通过View页面向服务端提出请求，可以是表单请求、超链接请求、AJAX 请求等
(2).服务端Controller控制器接收到请求后对请求进行解析，找到相应的Model对用户请求进行处理。
(3) Model处理后,将处理结果再交给Controller
(4) Controller 在接到处理结果后,根据处理结果找到要作为向客户端发回的响应View页面。页面经渲染(数据填充)后，再发送给客户端。
2.三层架构 三层架构是指:视图层View、服务层Service, 与持久层Dao.它们分别完成不同的功能。
➢View层: 表现层、视图层，对于Web开发,也称为Web层。用于接收用户提交请求的代码在这里编写。
➢Service层:业务层、逻辑层,系统的业务逻辑主要在这里完成。
➢Dao层: 持久层、数据访问层，直接操作数据库的代码在这里编写。DAO,即Data Access Object,数据访问对象。
为了更好的降低各层间的耦合度,在三层架构程序设计中,采用面向抽象编程。即上层对下层的调用，是通过接口实现的。而下层对上层的真正服务提供者，是下层接口的实现类。服务标准(接口)是相同的，服务提供者(实现类)可以更换。这就实现了层间解耦合。
3.mvc+三层架构 所谓“MVC+三层架构”的开发模型，主要是指将MVC的业务处理Model分为了两层Service层与Dao层，分别用于处理业务逻辑与持久化操作。
“MVC+三层架构”的开发模型，是传统的JavaWeb项目的最常用开发模型。
4.三层架构和框架开发的对应关系 三层架构框架View层: 表现层、视图层SpringMvcService层:业务层、逻辑层Dao层: 持久层、数据访问层Mybatis 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c4fb506345116fea80da3343c9c73f0/" rel="bookmark">
			C&#43;&#43;重载运算符3--自增运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C++重载运算符3--自增运算符 # 一、自增运算符重载 自增运算符重载分为两种a++与++a，a++是先输出，然后在自增，++a是先自增，然后在输出。 1.成员函数重载
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; class Person { publiuc: Person() { m_age=10; } Person&amp; operator++()//++a { m_age++; return *this; } Person operator++(int) { Person temp; temp=*this; m_age++; return temp;//因为这边temp是一个局部变量，运行完就被释放，所以这里只能返回值，不能返回引用 } private: int m_age; }; void test() { Person p; p++; ++p; } int main() { test(); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e870bb4863f61ad546ec2b18f7f4f7c/" rel="bookmark">
			8.4  通过指针引用字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言程序设计（谭浩强版） 目录
C语言程序设计（谭浩强版）
8.4 通过指针引用字符串
8.4.1 字符串的引用方式
8.4.2 字符指针作函数参数
8.4.3 使用字符指针变量和字符数组的比较
8.4 通过指针引用字符串 8.4.1 字符串的引用方式 本节将使用字符串的更灵活方便的方法——通过指针引用字符串
引用字符串，可以用以下两种方式：
用字符数组存放一个字符串，通过数组名和下标引用字符，也可也通过数组名和格式声明“%s”输出该字符串。 #include&lt;stdio.h&gt; int main(){ char string[] = "I love China"; printf("%s\n",string); //通过%s格式声明输出string printf("%c\n",string[7]); // 用%c格式输出一个字符数组元素 return 0; } 2.通过字符指针变量输出一个字符串。
#include&lt;stdio.h&gt; int main(){ char * string = "I love China"; printf("%s\n",string); return 0; } 运行结果如下：
程序分析如下：
在程序中没有定义字符数组，只定义了一个char *型的指针（字符类型指针变量）。"I love China"是一个字符串常量，对它初始化。C语言对字符串常量是按字符数组处理的，在内存中开辟了一个存放该字符串常量，但是这个字符串数组没有名字，因此不能用数组名进行引用，只能通过指针变量来引用。（可以理解为没有名字，通过访问地址来引用）对于字符指针变量string的初始化，实际就是将字符串常量的第一个元素地址赋给了指针变量string，使string指向字符串的第一个字符。（字符指针变量指向字符串的第一字符）%s是输出字符串时所用的格式符，在输出项中给出字符指针变量string，则系统会输出string所指向的字符串第一个字符，然后自动使string加1，使之指向下一个字符，再输出该字符。直到遇到字符结束标志'\0'为止。 例题：将字符串a复制为字符串b，然后输出字符串b。
1.用数组来处理：
#include&lt;stdio.h&gt; int main(){ char a[] = "I love China.", b[20]; int i; for (i = 0;a[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e870bb4863f61ad546ec2b18f7f4f7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db06f6b7682428d7a9259e53372838d7/" rel="bookmark">
			画出下列伪代码程序的流程图，计算它的环形复杂度。这个程序的逻辑有什么问题吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		画出下列伪代码程序的流程图，计算它的环形复杂度。这个程序的逻辑有什么问题吗？ C	EXAMPLE LOOP:DO WHILE Z&gt;0 A=B+1 IF A&gt;10 THEN X=A ELSE Y=Z END IF IF Y&lt;5 THEN PRINT X,Y ELSE IF Y=2 THEN GOTO LOOP ELSE C=3 END IF END IF G=H+R END DO IF F&gt;0 THEN PRINT G ELSE PRINT K END IF STOP 程序流程图 流图 环形复杂度 V(G)=判断结点+1=6+1=7
其中判断结点为 1 , 3 , 6，8, 10, 11
逻辑问题 有问题：当Z&gt;0时，容易形成死循环，条件Y&lt;5中包含条件Y=2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc15399f3eae37a03497d67b735fa82b/" rel="bookmark">
			mongo-admin基于Web的Mongodb数据库管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.基本介绍 该项目是基于Web的Mongodb数据库管理工具。
项目地址：https://github.com/ammi3/mongo-admin
演示地址：http://47.98.136.116:8080/
2. 功能点 github第三方权限认证连接Mongodb数据库（可以切换数据的连接单连接）展示Mongodb数据库内的数据库信息（过滤admin和local数据库）展示Mongodb数据库内的集合信息（过滤系统集合system.*)展示集合内的所有文档信息插入文档，更新文档，删除文档，导出文档嵌入式的mongo shell命令行工具CodeMirror（支持$find, $sort等）Gridfs文件存储，支持下载，删除 3. 如何使用 git clone git@github.com:ammi3/mongo-admin.git更改application.yml内的mongodb数据库连接信息前往Github-settings-Developer settings-OAuth-apps创建一个App，将Ip换成127.0.0.1 在RestAuthController.java更换Client Id与Client secrets启动 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38c436aad3513637e48b5064fc0a3d93/" rel="bookmark">
			安装pihole的总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几个月之前就刷了一遍rasbian，安了pihole，结果vodafone的路由器不能改dns，所以用不来pihole。
由于现在的路由器是tenda的，可以改dns，于是今天再次挑战pihole。
这花了4个小时试了各种情况。从一开始的查看pi的config： ifconfig，到试图修改adlist的内容，adlist是readonly，连sudo vim都不行，使用chmod 666 倒是可以成功修改并保存该文件，但是对pihole没有改善。
然后打算用pihole5-list-tool，但是它的安装需要python3.6以上，pi的python只有3.5，于是找到了sam18的一个教程，下载python3.7到本地，tar命令解压压缩包并安装，compile，makefile啥的，最后用ln来把python3 绑定到python3.7上。
然后用pip3下载tool时还是报错。查询无果后突然想通了，原来pip3绑定的是python3.5，通过修改pip相应描述文件可以改绑定，但已经挺晚了，于是直接用pip3.7安装，果然可以。
然而，用tool也无法改变。
最后毅然决定重装pihole
果然可以，但是其实效果一般，账面上是阻挡了18%左右的queries，但是常用app的广告还在。
其实关键是我没有好好研究interface，所以一直在看黑名单，而不知道其实adlist在group management那边。
anyway，总算装好，接下来要收集好的adlist试验一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/702a088bfee833afc1985157a5072290/" rel="bookmark">
			软件工程过程总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件工程过程总结 一、软件过程基本理论与技术**********二、团队与团队文化建设**********三、过程环境与支持管理**********四、过程监控与度量**********五、质量运动与过程改进********** 一、软件过程基本理论与技术********** 我国的软件开发存在的问题？（1）质量意识淡薄，企业从上到下都缺乏正确的产品质量意识，只注重完成软件产品的功能，忽视产品的质量问题。（2）体制不灵活，不健全，导致质量监督不力。由于体制问题造成软件人才不必要的流动，同样是因为体制问题造成实际上企业的软件资产流失。（3）做产品的概念不浓，大多只为短期的经济利益，做短期的项目。（4）形式化的东西太多，为追求评奖或完成项目，报喜不报忧。（5）软件企业的交流少，思想保守。（6）对新技术研究的跟进、投入少。（7）多数项目盲目采用国外技术，没有从自身问题入手，寻找适合产品开发的技术和过程。
软件过程的有哪些分类？软件过程可概括为三类：基本过程类、 支持过程类和组织过程类。 软件基本过程：软件获取、供应、开发、运行和维护的过程，包括需求分析、软件设计、编码等过程。软件支持过程：对软件主要过程提供支持的过程，包括文档编制过程、配置管理过程、质量保证过程、验证和确认过程（测试过程）、评审过程等。软件组织过程：对软件主要过程和支持过程的组织保证过程，包括管理过程、基础设施过程、改进过程和培训过程。
软件开发过程是指在完成某个软件项目的过程中，开发目标软件所经历的步骤，是一系列软件活动的集合。
如何建立软件过程？从现有的成熟的软件生存周期模型中选择、对模型加以改进、 自定义过程、六个主要过程：制定计划、需求分析、设计、程序编码、测试及运行维护
瀑布模型：计划-&gt;需求分析-&gt;设计-&gt;编码-&gt;测试-&gt;运行·维护 优点：过程有计划、分工明确；缺点：理想化，不灵活、产品交付延迟，反应慢
渐增模型：软件项目往往要“干两遍”，这样最终软件才能较好的令用户满意。第一次只是“试验开发”，目的是探索可行性、明确需求，所得到的工件称为“原型”。优点：缓解了瀑布模型不灵活，用户无法预判系统正确性的问题；缺点：易退化成“边做边改”模型、增加了成本。
螺旋模型：每个螺旋周期可分为制定计划、风险分析、开发实施、用户评估4 个步骤。优点：加强了用户与开发人员的交流，兼有瀑布模型与演化模型的优点；缺点：风险分析是螺旋模型的核心活动，要重复评估，以确保进度和成本可控
喷泉模型：优点：支持软件复用，有利于多项开发活动集成；缺点：大量开发人员同时开发，不利于项目管理，同时要确保文档一致性
原型模型：原型模型以迭代式开发为思想，针对需求分析难以完整、准确，或者可实现性难以验证的问题，首先构建一个软件原始模型给用户体验，反馈意见，通过不断更新或者多次重复开发，得到最终软件。优点：易明确需求、易验证方案、用户快速体验与反馈：缺点：需要工具和方法支持，以保障进度和成本
V模型：优点：包含了底层测试（单元测试）和高层测试（系统测试）；清楚的标识了开发和测试的各个阶段；自上而下逐步求精，每个阶段分工明确，便于整体项目的把控。缺点：自上而下的顺序导致测试工作在编码后，不能及时的进行修改；实际工作中，需求经常变化，导致V模型步骤反复执行，返工量很大，灵活度较低。
CMM软件能力成熟度模型分为五个等级 ：初始级，软件生产过程的特征是随机的，有时甚至是杂乱的。很少过程被定义，成功依赖于个人的努力。 可重复级，建立基本的项目管理过程，以跟踪费用、进度和功能。设定必要的过程纪律以重复以往在相同应用的项目的成功。已定义级，管理和工程活动的软件过程已文档化、标准化、集成化到一个标准的组织的软件过程。组织内所有的项目使用的软件过程是集体同意、裁剪过的标准开发和维护软件的版本。已管理级，详细的软件过程和产品质量的特征已被收集。软件过程和产品已被定量管理和控制。优化级，能自觉利用各种经验和来自新技术、新思想的先导试验的定量反馈信息，不断改进和优化组织统一的标准软件过程。
CMM、 PSP、 TSP三者之间的关系、CMM是过程改善的第一步，它提供了评价组织的能力、识别优先改善需求和追踪改善进展的管理方式。企业只有开始CMM改善后，才能接受需要规划的事实，认识到质量的重要性，才能注重对员工经常进行培训，合理分配项目人员，并且建立起有效的项目小组。然而，它实现的成功与否与组织内部有关人员的积极参加和创造性活动密不可分。PSP能够指导软件工程师如何保证自己的工作质量，估计和规划自身的工作，度量和追踪个人的表现，管理自身的软件过程和产品质量。经过PSP学习和实践的正规训练，软件工程师们能够在他们参与的项目工作之中充分运用PSP，从而有助于CMM目标的实现。TSP结合了CMM的管理方法和PSP的工程技能，通过告诉软件工程师如何将个体过程结合进小组软件过程，并将后者与组织进而整个管理系统相联系；通过告诉管理层如何支持和授权项目小组，坚持高质量的工作，并且依据数据进行项目的管理，向组织展示如何应用CMM的原则和PSP的技能去生产高质量的产品。
RUP中的软件生命周期的四个阶段及对应里程碑：初始阶段：生命周期目标里程碑。细化阶段：生命周期结构里程碑。构造阶段：初始功能里程碑。交付阶段：产品发布里程碑。
业务驱动开发的6个原则：提高过程的适应性、平衡有竞争的涉众的优先级、团队协作、体现迭代的力量、提升抽象级别、持续关注质量。
RUP的9个规程：需求、业务建模、配置和变更管理、环境、项目管理、分析与设计、实施、测试、部署。
RUP的6个最佳实践：迭代开发、管理需求、使用基于组件的构架、可视建模、持续的质量验证、控制变更。
RUP的三个中心元素。用于成功开发软件的一组基本原则。这些原则是开发RUP的基础。可重用方法内容及流程构件块的框架。方法插件系列定义了方法框架，从该框架您可以创建自己的方法配置及定制的流程。底层方法及流程定义语言。统一方法体系结构元模型提供了用于描述方法内容及流程的语言。
敏捷宣言的四个核心价值是：个体和互动高于流程和工具、工作的软件高于详尽的文档、客户合作高于合同谈判、响应变化高于遵循计划。① 人是获得成功的最为重要的因素。一个由平均水平的、具有良好沟通能力的程序员组成的团队，将要比那些虽然拥有一批高水平的程序员，但是成员之间却不能进行交流的团队更有可能获得成功。团队的构建要比环境的构建重要的多。许多团队和管理者就犯了先构建环境，然后期望团队自动凝聚在一起的错误。相反，应该首先致力于构建团队，然后再让团队基于需要来配置环境。② 没有文档的软件是一种灾难。代码不是交流系统原理和结构的理想媒介。团队更需要编制易于阅读的文档，来对系统及其设计决策的依据进行面熟。然而，过多的文档比过少的文档更糟。编制众多的文档需要花费大量的时间，并且使这些文档和代码保持同步，要花费更多的时间。如果文档和代码之间失去同步，那么文档就会变成庞大的、复杂的谎言，会造成重大的误导。③ 成功的项目需要定期且频繁的客户反馈。不是依赖于合同或者关于工作的陈述，而是让软件的客户和开发团队密切地工作在一起，并尽量经常地提供反馈。一个指明了需求、进度以及项目成本的合同存在根本上的缺陷。在大多数情况下，合同中规定的条款远在项目完成之前（有时甚至是远在合同签署之前）就变得没有意义。那些为开发团队和客户的协同工作方式提供指导的合同才是最好的合同。④ 随时应对变化的能力常常决定着一个软件项目的成败。当我们构建计划时，应该确保计划是灵活的，并且易于适应商务和技术方面的变化。计划不能考虑得过远。首先，商务环境很可能会变化，这会引起需求的变动。其次，一旦客户看到系统开始运作，他们很可能会改变需求。最后，即使我们知道需求是什么，并且确信他们不会改变，我们仍然不能很好地估算出开发他们需要的时间。所以我们要时刻保持计划的灵活性，这样才不会浪费不必要的人力、物力、财力。
平衡敏捷与规范：如果只有强有力的规范而缺乏敏捷，将导致官僚作风， 进而停滞不前；缺乏规范的敏捷则如同一个新创公司在盈利之前的不负 责任的狂热。敏捷过程与规范过程各有自己的特点和优点，在本质上和在实际项目中，敏捷与规范是可以平衡的.Boehm等详细总结了敏捷与规范两种方法各自的擅长领域，并给出了基于风险分析平衡敏捷与规范的策略，而平衡的策略可以综合两种方法的优点。Boehm给出了影响敏捷与规范方法选择的五个维度（动态性、危险性、规模、人员和文化）。结论：敏捷与规范，软件开发中看似对立的两个属性，实际上相得益彰。计划驱动的开发人员必须敏捷，敏捷开发人员必须规范。成功的关键在于找到两者的平衡点。这个平衡点随项目所处的环境以及所涉及的风险而变化。仅凭一腔热情径直地采用极端方法的开发人员，必须学会如何根据实际情况恰当地平衡敏捷与规范。
极限编程XP是敏捷过程中最负盛名的一个，其名称“极限”二字的含义是指把好的开 发实践运用到极致。XP的四个观点：交流 、简单、回馈、勇气。原则:测试1．所有的代码都必须有单元测试 2．所有的代码在发布之前必须通过所有单元测试 3．当一个BUG发现时，就增加新的测试 4．经常运行验收测试，并公布分数
敏捷项目管理:对整个项目做一个粗略的估计,每一次迭代都有详细的计划.鼓励变化, 客户价值驱动开发.信任和赋予权力;合约使变更变得简单，增加价值.客户和开发人员之间是紧密的连续的合作关系每次迭代都产生可交付的软件专注于交付软件.第一次迭代就可交付能工作的版本，风险发现的早.
为什么采用敏捷? 采用敏捷方法得当的话，可以：更加透明; 随时跟踪项目的状态和进展情况，及早发现问题和风险 .快速交付, 每次迭代都能交付可运行的软件.最高风险和最高优先级的需求，最优先进行开发.改善应对变更能力, 减少大量的重计划.改善项目沟通.更好的客户参与, 避免错误的假设.
软件构建指的是通过编码、验证、单元测试、集成测试和调试的组合，详细地创建可工作的，有意义的软件。软件构建的原则：最小的复杂性、要预测变更、为验证二构建。
软件重构是在不改变代码外在行为的前提下，对代码进行修改以改进程序的内部结构，即软件重构只是将软件的内部结构进行调整，提高其可理解性，降低修改的成本。为什么需要重构？“三次原则”可以作为重构时机的参考，即“ 事不过三，三则重构”。也就是说，第一次编写全新的代码尽管去做；第二次编写类似的代码虽然令人反感，但还是直接去做；第三次再做类似的事情，这时就应该重构。 重构常用方法？1. 重新组织函数 2. 在对象之间迁移特征 3. 重新组织数据 4. 简化条件表达式 5. 简化函数调用 6. 处理概括关系 7. 大型重构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/702a088bfee833afc1985157a5072290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c55787b9c460e538abc91dd6c7e93a0/" rel="bookmark">
			await的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 function getSomething() { return "something"; } async function testAsync() { return Promise.resolve("hello async"); } async function test() { const v1 = await getSomething(); const v2 = await testAsync(); console.log(v1, v2); } test(); [Running] node "/Users/ivyone/44.js" something hello async 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e98a87c539b9363a4229f960bfab2507/" rel="bookmark">
			signature=35acbbc22d8329429967120a125263a4,Root phloem-specific expression of the plasma membrane am...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Abstract
Amino acids are regarded as the nitrogen ‘currency’ of plants. Amino acids can be taken up from the soil directly or synthesized from inorganic nitrogen, and then circulated in the plant via phloem and xylem. AtAAP3, a member of the Amino Acid Permease (AAP) family, is mainly expressed in root tissue, suggesting a potential role in the uptake and distribution of amino acids. To determine the spatial expression pattern of AAP3, promoter–reporter gene fusions were introduced into Arabidopsis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e98a87c539b9363a4229f960bfab2507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e65a3c77ae01109a11fcfae18543c707/" rel="bookmark">
			android更新删除数据库表,从SQLite数据库表中删除所有表行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我想删除我从SQLite数据库表中输入的所有行。 表名是tbltask 。 我试图删除表并从表中删除*，但那些给了我运行时错误。 我想在Button OnClickListner事件中触发此事件。
以下代码是我尝试的：String delete = "DELETE FROM "+DATABASE_TABLE; db.rawQuery(delete, null); db.delete(DATABASE_TABLE, null, null);
logcat的：
11-15 17:45:04.660: DEBUG/AndroidRuntime(300): Shutting down VM 11-15 17:45:04.660: WARN/dalvikvm(300): threadid=1: thread exiting with uncaught exception (group=0x4001d800) 11-15 17:45:04.710: ERROR/AndroidRuntime(300): FATAL EXCEPTION: main 11-15 17:45:04.710: ERROR/AndroidRuntime(300): java.lang.NullPointerException 11-15 17:45:04.710: ERROR/AndroidRuntime(300): at database.com.android.DatabaseAccess.drop(DatabaseAccess.java:258) 11-15 17:45:04.710: ERROR/AndroidRuntime(300): at com.android.ExtraActivity$3$1.onClick(ExtraActivity.java:61) 11-15 17:45:04.710: ERROR/AndroidRuntime(300): at com.android.internal.app.AlertController$ButtonHandler.handleMessage(AlertController.java:158) 11-15 17:45:04.710: ERROR/AndroidRuntime(300): at android.os.Handler.dispatchMessage(Handler.java:99) 11-15 17:45:04.710: ERROR/AndroidRuntime(300): at android.os.Looper.loop(Looper.java:123) 11-15 17:45:04.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e65a3c77ae01109a11fcfae18543c707/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1a55ebc494fb4e3de4c06cbafe4fabb/" rel="bookmark">
			idea无法下载源码Sources not found for:org.springframework
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 ,
2
3,
4 ,命令行执行如下命令
mvn dependency:resolve -Dclassifier=sources 5,在查看源码注释
注意: 如果执行命令 提示
mvn dependency:resolve -Dclassifier=sourcesIDEA提示: ‘mvn’ 不是内部或外部命令，也不是可运行的程序
你的maven没有配置系统变量，或者你直接切换到maven目录下执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff8dce73bd9617a7b1f92a120dca528b/" rel="bookmark">
			在VS中使用Boost库出现Macro redefinition错误的解决方法（warning C4005）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在VS中使用Boost库出现Macro redefinition错误的解决方法（warning C4005）
参考文章：
（1）在VS中使用Boost库出现Macro redefinition错误的解决方法（warning C4005）
（2）https://www.cnblogs.com/madhenry/p/3778203.html
（3）https://www.javazxz.com/thread-4015-1-1.html
备忘一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed6ae136c0b3ff384ee3b2048cc86e5/" rel="bookmark">
			signature=380c781d7acdb4a0b58b81f0ad23d1e8,certbot/certbot-auto at b841f0f307e3f7bda7122761e0efa1139...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/sh
#
# Download and run the latest release version of the Certbot client.
#
# NOTE: THIS SCRIPT IS AUTO-GENERATED AND SELF-UPDATING
#
# IF YOU WANT TO EDIT IT LOCALLY, *ALWAYS* RUN YOUR COPY WITH THE
# "--no-self-upgrade" FLAG
#
# IF YOU WANT TO SEND PULL REQUESTS, THE REAL SOURCE FOR THIS FILE IS
# letsencrypt-auto-source/letsencrypt-auto.template AND
# letsencrypt-auto-source/pieces/bootstrappers/*
set -e # Work even if somebody does "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ed6ae136c0b3ff384ee3b2048cc86e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4f1c011e161743963b7281fb856c27/" rel="bookmark">
			踩坑日记：Unable to process Jar entry [module-info.class]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 运行环境： Java 版本：11.0.10 操作系统：Window 10 maven 版本：3.8.1 tomcat7 插件版本：2.2 问题描述： 使用 manven 启动 tomcat7 插件后报错，错误如下：
严重: Unable to process Jar entry [module-info.class] from Jar [jar:file:/E:/myRepository/javax/xml/bind/jaxb-api/2.3.0/jaxb-api-2.3.0.jar!/] for annotations 原因分析： `jaxb-api` 版本过高导致，找到其所在，将其依赖排除即可。 解决方案： 看网上很多博主的解决方式都是找到 jaxb-api jar包，用解压软件打开【不是解压】，将其里面的 module-info.class 文件夹删除，我自己也试过，确实可以解决该问题，但是总感觉该方式有问题，不可能每下载一次都要删除一次吧。以下是我的解决方案，大家看需要随缘取之！
&lt;!-- 腾讯云短信依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.tencentcloudapi&lt;/groupId&gt; &lt;artifactId&gt;tencentcloud-sdk-java&lt;/artifactId&gt; &lt;version&gt;3.1.270&lt;/version&gt; &lt;exclusions&gt; &lt;!-- 排除关联依赖的引入 --&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69314b0f493351cca182a6314f9f0712/" rel="bookmark">
			android文本拖动,Android笔记之文本随滑块移动的SeekBar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		packagecom.bu_ish.blog;importandroid.content.Context;importandroid.graphics.Canvas;importandroid.graphics.Color;importandroid.graphics.Paint;importandroid.os.Build;importandroid.util.AttributeSet;importandroid.util.Log;importandroid.util.TypedValue;importandroid.view.View;importandroid.widget.LinearLayout;importandroid.widget.SeekBar;importjava.lang.reflect.Field;public class FloatingTextSeekBar extendsLinearLayout {privateSeekBar sb;privateFloatingTextView ftv;private String startText = "100";private int max = 49;private floatfloatingTextX;private static final String TAG = FloatingTextSeekBar.class.getName();publicFloatingTextSeekBar(Context context, AttributeSet attrs) {super(context, attrs);
setOrientation(VERTICAL);
sb= newSeekBar(context);
LayoutParams sbLayoutParams= newLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
sb.setLayoutParams(sbLayoutParams);
sb.setPadding(16, 0, 16, 0);try{
Class cls=sb.getClass().getSuperclass().getSuperclass();
Field field= cls.getDeclaredField("mMaxHeight");
field.setAccessible(true);
field.set(sb, PixelTool.dpToPx(context,5));
}catch (NoSuchFieldException |IllegalAccessException ex) {
Log.e(TAG,null, ex);
}
sb.setMax(max);
sb.setProgressDrawable(getResources().getDrawable(R.drawable.seek_bar_progress_drawable));
sb.setThumb(getResources().getDrawable(R.mipmap.ic_seek_bar_thumb));if (Build.VERSION.SDK_INT &gt;=Build.VERSION_CODES.LOLLIPOP)
sb.setSplitTrack(false);
addView(sb);
ftv= newFloatingTextView(context);
LayoutParams ftvLayoutParams= new LayoutParams(LayoutParams.MATCH_PARENT, PixelTool.dpToPx(context, 12));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69314b0f493351cca182a6314f9f0712/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34c6fc7326f32a5fd1ae01a11b5733e2/" rel="bookmark">
			UE4Android聚光灯投影,Unreal Engine 4 高级灯光实战教学V2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		灯光的设计好坏直接决定了场景的质感，在这套虚幻引擎4高级灯光教学中，主要分为三个大的部分。在第一部分中，我们详细了解了在引擎中的点光源，方向光源，聚光灯光源以及Skylight这四种最基本光源的属性，以及在这四个属性当中每一个重要的节点选项的功能演示，让你能够对UE4的灯光系统有一个基本的了解。
在对灯光有了基本的了解之后，我们的第二部分学习中，系统了解了与灯光效果影响密切相关的Lightmass importance Volume 以及负责后期处理的Post Process Volume中的15组不同功能的设定选项，并且在案例里面实际演示每一组参数所控制的不同内容，让大家对影响质感的灯光的一系列参数有所直观了解。
虚幻引擎4 以其一贯高品质的材质，灯光与画面给人留下深刻的印象。 我们在上次的第一套虚幻引擎4 灯光教学距今已经两年多，虚幻引擎经过了十多个版本的更新，在许多地方都有了更新与调整，加上虚幻引擎官方文档中大量新增内容并没有更新，为初学者带来比较大的麻烦。
为此，我们将虚幻引擎4 灯光教学进行重置，基于 Unreal Engine 4.2X 版本为基础，从灯光的基础属性开始介绍各主要灯光光源的属性，灯光应用，以及与光和影相关的知识点和使用频率最高的灯光组合与 Post Process Volume 功能模块。 更通多多个实战项目带大家交接在实际应用中如何将不同的灯光做搭配，并展示 Vray For Unreal Engine 4 的全新工作流程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21468c436921819311c4146e938365e2/" rel="bookmark">
			linux进阶19——GDB（五）：单步调试命令（next、step和until）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一段c语言程序:
#include &lt;stdio.h&gt; int print(int num){ int ret = num * num; return ret; } int myfunc(int num){ int i = 1; int sum = 0; while(i &lt;= num){ sum += print(i); i++; } return sum; } int main(){ int num =0; scanf("%d", &amp;num); int result = myfunc(num); printf("%d", result); return 0; } 1. next命令 1.1 功能 next 是最常用来进行单步调试的命令，其最大的特点是当遇到包含调用函数的语句时，无论函数内部包含多少行代码，next 指令都会一步执行完。也就是说，对于调用的函数来说，next 命令只会将其视作一行代码。
1.2 语法 (gdb) next count 参数 count 表示单步执行多少行代码，默认为 1 行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21468c436921819311c4146e938365e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad16a22c299fe6f59c571ce378a3aa25/" rel="bookmark">
			python--字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、字典的含义
字典是Python提供的一种常用的数据结构，它用于存放具有映射关系的数据。 字典相当于保存了两组数据，其中一组数据是关键数据，被称为 key；另一组数据可通过 key 来访问，被称为 value。形象地看，字典中 key 和 value 的关联关系如下图所示:
注意：key是十分关键的数据，而且访问value的时候需要通过key进行访问，因此字典的key不允许重复。
二、创建和使用字典
字典由多个键和其对应的值构成的键—值对组成，键和值中间以冒号：隔开，项之间用逗号隔开，整个字典是由大括号{}括起来的。
字典的创建：
1、info = {'name':'班长', 'id':100, 'sex':'f', 'address':'地球亚洲中国北京'}
三、字典的基本用法
1.通过key访问value
2.通过key添加key-value对
3.通过key删除key-value对
4.通过key值修改值
5.通过key判断指定的key-value是否存在
四、字典的方法：
(1)
get()方法是根据key值来获取value,使用get()方法的时候，如果key值不存在则会返回None
(2)
update:可使用一个字典所包含的 key-value对来更新己有的字典。在执行 update()方法时，如果被更新的字典中己包含对应的 key-value对，那么原value 会被覆盖；如果被更新的字典中不包含对应的 key-value对，则该key-value对被添加进去
(3)
clear() 用于清空字典中所有的 key-value 对，对一个字典执行 clear() 方法之后，该字典就会变成一个空字典
(4)
pop() 方法用于获取指定 key 对应的 value，并删除这个 key-value 对
(5)
items()、keys()、values() 分别用于获取字典中的所有 key-value 对、所有 key、所有 value。这三个方法依次返回 dict_items、dict_keys 和 dict_values 对象
注意：字典和列表的区别：
a. 字典的键可以是任意的不可变类型
b. 成员资格查找时查找的时键而不是值
c. 即使键起初不存在也可以为它直接赋值，字典会自动添加新的项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad16a22c299fe6f59c571ce378a3aa25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52b6fd4e6b2444652c56372f985e5850/" rel="bookmark">
			寻找公共子串，给定两个字符串str1和str2,输出两个字符串的最长公共子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 本题提供了两种思路：思路和代码如下两种方法都能通过牛客网（动态规划的想法是真的牛逼） * 一、基本思路：我的算法思路更接近我们正常的思路是： * 现在存在连个字符串str1和str2 * ①我们首先要做的是找到str1和str2哪个串更长，把长的存入str1中短的存入str2中 * （这样做的原因是：遍历短的字符串来找最短重复子串会更加省时间） * ②我们开始遍历短的字符串，从中找到一个最长的子串str1中也存在 * 我们逐个遍历每个字符，先找到str2中的一个字符在str1中存在我们将其赋值给str（代表公共子串），接着我们一个个遍历字符，如果下一个字符 * 将下一个字符和原先我们找到的重复子串部分连接起来，如果仍然是公共子串则将其加入重复子串str中，如果加入后 * 不在是公共子串，我们判断加入的那个字符本身是否可以在str1中找到，如果找到我们判断下一个字符，如果可以找到又分为 * 将str的第一个字符删除加入该字符知否仍然是公共子串，如果是则删除str的第一个加入该字符，如果找不到则接着从下一个字符判断。 * 每次判断我们都将结果与result比较，如果长则将其存入result（保证result中存的是最长的） * *二、 动态规划： *一样的现在有str1和str2两个字符串 *我们的做法是定义一个二维数组，这个数组的用于存储str1中的第i个元素与str2中的第j和元素连续相同的个数 *我们是这样做的：声明一个空间大小为array[str1.length() + 1][str2.length + 1]的数组（多一行的原因是方便动态规划叠加，初始默认为空的都不同） *接着只要字符串str1(i) == str2(j)就将array[i - 1][j - 1]叠加，原因是array[i - 1][j - 1]存储的是它们的上一个元素连续相等的次数这样，我们每次 *赋值完成后都记录最大值，方便我们在遍历完成后找出最大连续相同的个数和位置，然后引用。 * */ public class LCS { public static void main(String[] args) { String str1 = "12"; String str2 = "312"; System.out.println(LCSPLUE(str1,str2));; } public static String LCS (String str1, String str2) { if(str1 == null || str2 == null){ return null; } String result = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52b6fd4e6b2444652c56372f985e5850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e9c8b6fbec43b9ac910484cd751340/" rel="bookmark">
			Android iOS热修复,细说热修复（一），体验如何线上快速修复APP！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是热修复？首先我们先来还原一下场景：
客服MM：用户反馈生产版本出现crash问题了，很严重没法用，怎么办，怎么办？
程序猿GG：测试组确认问题后，我们修复Bug，测试验证完成，打包发布。
客服MM：用户需要多久能下载新包呢？
程序猿GG：至少3天。
客服MM：额，这个.....
这个时候大家都会想，如果能够马上修复线上版本bug该多好啊。想法没毛病，热修复技术就是在这种场景下发展并普及的。
热修复是一种App客户端快速修复bug方法，通过后台下发代码，可以在App不发布新版本的情况下修复bug。在2015年的时候国内开始流行起来，在2017年3月被苹果的一封警告信推上了风口浪尖。
【基本原理】
后台下发代码(Patch包)，App加载patch包，通过patch里的数据分析，查找到有问题的Method方法进行替换。替换是APP运行时直接调用新Method’方法执行，从而避免了bug的影响。
(图一)
【IOS热修复】
15年项目上在选择方案时，基于当时市面上比较流行的2种方案JSPatch和WaxPatch进行了对比。主要从性能、功能、维护成本等方面综合考虑。因为lua语言没有JS语言普及程度高，而且WaxPatch框架现在已经停止维护了，而JSPatch框架还在持续不断的更新，因此IOS热修复方案我们选择JSPatch。
JSPatch的设计原理是利用了OC语言的动态特性，动态修改类的方法达到修复bug的目的。在介绍如何进行类方法替换之前，我们先来熟悉几个名词解释：Class、SEL、IMP，有助于我们理解方法替换。
Class在OC中是一个objc_class的结构体指针，定义如下：
图2
我们知道OC中每个类都有一个isa的指针，指向类对象的类【元类metaclass】。通过isa指针能找到对象所属的类，类结构体里保存着所有的信息，如父类、类名、类成员变量、类方法、协议链表等。类方法都存储在objc_method_list链表中，我们从图2中可以看到链表中存储的objc_method对象，包括SEL(selector)方法选择器，表示为方法的名称；char*存储的是参数类型，包括方法的返回值类型和入参类型；IMP(implement)是一个函数指针，存储方法具体实现代码块的地址，可以像普通C函数调用一样使用IMP。
一、IOS方法替换原理
OC上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法。
二、JSPARCH和OC交互原理
回过头来再来看看JSPatch是如何进行工作的。JSPatch主要语言是JS脚本，利用IOS系统提供的JavaScriptCore.framework库执行JS脚本，可以调用在JSContext中预先定义的方法。
1.DEFINECLASS方法
我们使用热修复就是为了要替换有Bug的方法，所以JS脚本中首先要定义好需要替换方法的类名、方法名，还有具体的方法实现过程。在OC端加载JSPatch的时候，会进行JPEngine的初始化，在初始化函数中有定义_OC_defineClass桥接函数。当js端执行_OC_defineClass方法时，就会触发OC的桥接函数调用。
▪ defineClass方法中能获得类名、方法名(如果有实现协议也能获得)。
▪通过NSClassFromString获得类对象，然后根据类对象和方法名获取到IMP。
▪同时返回{className:class}值给JS端。
2.OVERRIDEMETOD方法
OC从JS端脚本中获取到待替换的方法后，会判断app中是否有实现该方法，如果实现了就会执行overrideMethod函数。
▪overrideMethod把原始方法的IMP设置为_objc_msgForward，如果方法的返回值为特殊的struct类型(如:CGRect/CGRange)则设置为_objc_msgForward_stret，方法的调用会走消息转发流程。
▪添加新方法ORIG+方法名指向原始实现的IMP，保存原始方法。
▪添加JPForwardInvocation指向新的自定义IMP。
▪添加ORIGForwardInvocation指向原始的IMP。
3.JPFORWARDINVOCATION方法
上面提到了我们用JPForwardInvocation替换了原生的消息转发。替换的目的，是利用了IOS消息转发机制来实现一个通用的IMP，任意方法任意参数都可以通过这个IMP中转，拿到方法的所有参数回调JS的实现。在forwardInvocation中会有一个NSInvocation对象，保存了方法调用的所有参数值。
▪JPForwardInvocation读取传入的NSInvocation对象所有参数。
▪根据实际参数类型转换成OC类型。
▪把参数组装成一个数组返回给JS端。
▪如果转发的方法和JS脚本方法不匹配，调用ORIGForwardInvocation走原有的流程。
4._METHODFUNC()函数
JS脚本所有的方法调用都通过__c()函数，根据当前对象类型判断进行不同操作，_methodFunc()就是把相关信息转给OC，OC用Runtime接口调用相应方法的核心。
_OC_callI负责调用实例方法，_OC_callC负责调用类方法。
通过这两个函数调用，完成了JS端替换方法实现中调用OC对象或方法的过程。
5.CALLSELECTOR方法
JS端调用OC方法时，有时会出现JS类型和OC类型不一致的问题，通过此方法进行参数类型、返回值类型的转换和处理。
▪J将JS封装的对象进行拆分，得到OC对象。
▪J根据类名和方法名得到对应的Class对象和SEL。
▪J根据返回值类型，封装OC对象{className:cls,obj:obj}返回JS端
三、JSPATCH案例
本文介绍了热修复的基本原理、IOS热修复的原理与方法，并进行了实战案例演示。我们会继续跟新关于ANDROID热修复的内容，请继续关注！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13b46e4273fe269895463197356306ed/" rel="bookmark">
			springboot&#43;mybatis&#43;mysql&#43;influxdb&#43;thymeleaf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目目录
pom配置文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.6&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.zzedu&lt;/groupId&gt; &lt;artifactId&gt;go-fwd&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;go-fwd&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 阿里巴巴json包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.69&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.influxdb&lt;/groupId&gt; &lt;artifactId&gt;influxdb-java&lt;/artifactId&gt; &lt;version&gt;2.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13b46e4273fe269895463197356306ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/294bf9b7babd28a35412d9a8ade55973/" rel="bookmark">
			oracle update select效率最高的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用merge into方式
merge into t_test a
using(select carid,carstyle,num from t_test_wx_zsx) b
on( a.carstyle=b.carstyle) when matched then
update set a.vehicle_num = b.num;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6a07b1bde499aa0ff54f00278db1afe/" rel="bookmark">
			[密码学基础][每个信息安全博士生应该知道的52件事][Bristol52]38.隐蔽信道和侧信道的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一系列博客文章中最新的一篇，该文章列举了“每个博士生在做密码学时应该知道的52件事”:一系列问题的汇编是为了让博士生们在第一年结束时知道些什么。
隐蔽信道和侧信道是两种不同的信息泄露信道
隐蔽信道使用目的不是通信的机制。例如，写和检查文件是否被锁传递信号’1’或者’0’。在隐蔽通道中，内部处理器及那个不允许外部处理器访问的信息泄露给外部处理器。内部处理器（发送方）可能是之前植入的木马程序。外部的处理器可能是一个非特权进程。[1]
侧信道攻击也被叫做被动非侵入式的攻击，在侧信道攻击中，密码设备直接被攻击。例如，攻击仅仅利用了可直接访问的接口。该设备没有被改变，因此不会留下任何攻击的痕迹。侧信道攻击的主要思想是通过测量密码的执行时间，功耗或者电磁场强度来确定密钥。[2]
在物理侧信道攻击中，非常规的技术被用于推断密钥信息。典型的，设备被攻击者偷取或者获取，攻击者就可以通过物理访问进行侧信道攻击。传统的侧信道攻击包括差分功耗分析和时间分析。用于执行加密的不同数量的功率（时间）可以被用于推断出所有或者部分密钥的位数。功率或者时间信道攻击会比数学分析要花费更少的时间。[1]
在软件侧信道攻击中，受害者进程无意中承担了发送进程的角色，而监听(攻击者)进程承担了接收进程的角色。如果受害进程使用秘密密钥执行加密，则软件侧通道攻击允许监听进程获取导致密钥[1]部分或全部恢复的信息。[1]
[1] Wang, Zhenghong, and Ruby B. Lee. “Covert and side channels due to processor architecture.” Computer Security Applications Conference, 2006. ACSAC’06. 22nd Annual. IEEE, 2006.
[2] Mangard, Stefan, Elisabeth Oswald, and Thomas Popp. Power analysis attacks: Revealing the secrets of smart cards. Vol. 31. Springer Science &amp; Business Media, 2008.
转载链接：https://www.cnblogs.com/zhuowangy2k/p/12242767.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f55bfe6f41e7a0cc73eb9ad323fdf1a/" rel="bookmark">
			真香！前阿里P8看我技术太差，反手甩我一份内部SpringCloud笔记手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「SpringCloud Alibaba 因配置灵活、迭代高速、兼容性强，近几年在受到国内不少开发者的广泛关注。其中，Sentinel 作为服务治理开源组件相当出彩，可以帮助解决很多难题，比如：秒杀限流，消息削峰填谷，集群流量控制，实时熔断等。而作为国内的Spring爱好者，最最苦恼的莫过于操作性强的进阶干货太少了！」
毋庸置疑，强大的 Spring 技术体系，在电商、直播、游戏、金融等各大领域相当出彩。而微服务的走红，又使得阿里首推的一站式解决方案 SpringCloud Alibaba，备受各大厂程序员的追捧！但与高频的面试考察热度、追捧热度相比，市面上相关的操作性强的系统资料却很少见。这就造成不少学习者的困惑：
❝
框架仅仅停留在会使用的层次，但不能灵活配置和运用；
性能遇到瓶颈，不知道如何定位排查；
面试的时候总会被问到：有阅读过框架源码吗？
❞
其实，学习Spring，不要总停留在框架的使用上。理解并掌握底层原理并熟悉源码实现，将这些「内化为自身的抽象思维能力」，「做到灵活运用」，才是你突破瓶颈，脱颖而出的重要方向！
然而，一个人阅读源码是相当费力的。如果有前辈的指引，能少走不少弯路。这里推荐一个跟「市场需求高度契合、注重技术学习方法、口碑极好的SpringCloud Alibaba学习笔记手册（文末有获取方式！）」
先来看看这份SpringCloud Alibaba学习笔记手册的目录 「第一章节：微服务介绍」
❝
随着互联网的发展，网站应用的规模也在不断的扩大，进而导致系统架构也在不断的进行变化。从互联网早起到现在，系统架构大体经历了下面几个过程: 单体应用架构---&gt;垂直应用架构---&gt;分布式架构---&gt;SOA架构---&gt;微服务架构，当然还有悄然兴起的Service Mesh(服务网格化)。接下来我们就来了解一下每种系统架构是什么样子的， 以及各有什么优缺点。
❞
「第二章节：微服务环境搭建」
「第三章 Nacos Discovery--服务治理」
❝
Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。从前面就可以看出，nacos的作用就是一个注册中心，用来管理注册上来的各个微服务。
❞
「第四章 Sentinel--服务容错」
❝
在微服务架构中，我们将业务拆分成一个个的服务，服务与服务之间可以相互调用，但是由于网络原因或者自身的原因，服务并不能保证服务的100%可用，如果单个服务出现问题，调用这个服务就会出现网络延迟，此时若有大量的网络涌入，会形成任务堆积，最终导致服务瘫痪。
❞
「第五章 Gateway--服务网关」
❝
Spring Cloud Gateway是Spring公司基于Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。它的目标是替代Netflflflflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控和限流。
❞
「第六章 Sleuth--链路追踪」
❝
SpringCloud Sleuth主要功能就是在分布式系统中提供追踪解决方案。它大量借用了Google Dapper的设计
❞
「第七章 Rocketmq--消息驱动」
「第八章 SMS--短信服务」
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f55bfe6f41e7a0cc73eb9ad323fdf1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b77dd91d7d64948789a7ab0cdf645357/" rel="bookmark">
			同相比例运算放大器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源 作者使用这个放大器的原因，在反向放大器对小信号进行放大的中信号噪声特别大，因为同相放大器输入阻抗大所以准备测试一下。
仿真 介绍：
供电：单电源3V
输入信号：正弦波100~100Khz 直流偏置1.5V.
调试记录 输出信号不放大：C1由100nF改为10uF 解决；
输入信号测试100Hz ~ 100KHz 正弦信号，测试幅度与相位放大与理论值一致。
结论 此放大电路仿真正常，实际做板验证。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bac6fe8358b95675e0ec635c73e6d44/" rel="bookmark">
			[密码学基础][每个信息安全博士生应该知道的52件事]52.先进的应用概念 系统的大致安全需求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一系列博客文章中最新的一篇，该文章列举了“每个博士生在做密码学时应该知道的52件事”:一系列问题的汇编是为了让博士生们在第一年结束时知道些什么。我们希望学生知道从理论到实践的各个方面。但关键是你需要在密码学中考虑的不仅是对遵守规则的玩家的安全，还有对不遵守规则的玩家的安全。让我们从投票、拍卖和多方计算的角度来研究这个问题。
选择一个先进的应用概念，如电子投票，拍卖或多方计算。这样一个系统的大致安全需求是什么 让我们先讨论一下三个应用程序的含义。 在投票中，我们根绝投票者进行一些投票方案（得票最多者当选、多选、赞成投票或其他投票）进行选择候选人。投票应该保守秘密，仅仅合法的投票者可以进行投票，每个候选人只能投一票，投票必须是有效的(例如对于一个真正的候选人)，最后的结果必须是正确的，选民不能被强迫，安全要求的名单很长。
针对拍卖，我们想要拍卖应该是隐私的，我们不能信任拍卖商，那可能有很多个物品，很多个可能的最终价格，中标的投标/价格的选择将由于某种算法，最终的输出可能需要审核。
针对多方计算（这里我们指的是一个函数在一组参与方的私有输入上的计算），安全是简单的—我们希望仅仅计算得到的函数的结果可以被暴露，任何有关输入的信息不能被泄露。然而，虽然这是一个简单的目标，功能比拍卖和投票更广泛，因为我们需要为任何函数应该能够计算。
这些场景的特点是什么？ 使这些操作有趣的是，我们期望坏家伙成为协议的一部分。和简单的加密方案相比，Alice和Bob发送一个消息，我们期望Alice和Bob都是可信任的，坏家伙只能在协议外围观看。针对投票、拍卖和多方计算，我们不能信任任何人，坏人可能是一个试图投多张票的投票人，一个试图数错票数的计票人，一个试图出价并不是最高的得标人，或者一个试图计算出未中标者的价值的拍卖人等等。
协议中的各方甚至不需要遵守规则，即遵循协议。它们可以发送生成不正确但“看起来像”有效的消息，但随后会为协议生成不正确的结果。我们需要防范这种所谓的“恶意”行为。
可能会有一群坏人一起合作来击败这个系统，我们需要确定在我们的协议中我们能容忍多大的坏人联盟。在MPC中，诚实多数和不诚实多数是有很大区别的。对于诚实多数协议，我们可以确保诚实的一方总是以有效的函数输出结束。对于不诚实的多数协议，我们不能阻止不诚实的一方终止每个人的协议。
我们需要防止谁先谁后的问题。有一个单词叫做“公平”。例如，假设我们有三个投票人;A、B和C。假设投票是加密的，玩家C可以通过复制A的投票来确保被A投票支持的候选人获胜(从而找出被A投票支持的人)。这应该被阻止起来。
敌手可能在协议开始时控制一组参与方，即所谓的静态敌手。或者，随着协议的推进，对手可能会决定要腐败哪个政党，也就是所谓的适应性敌手。
可以看到，在这样的高级协议中可能存在大量的安全问题，而且确实存在大量的安全结果。实际上，每个应用程序域都会产生不同的安全属性。考虑到可能的应用协议的广泛范围，这意味着密码学要解决的一系列问题永远不会结束。
因此，密码学博士生要解决的问题层出不穷。
转载连接：https://www.cnblogs.com/zhuowangy2k/p/12249514.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5fb6a7903bf5d04b8a72d5502f077eb/" rel="bookmark">
			[密码学基础][每个信息安全博士生应该知道的52件事][Bristol52]51.基于ID的加密安全模型，描述IBE方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一系列博客文章中最新的一篇，该文章列举了“每个博士生在做密码学时应该知道的52件事”:一系列问题的汇编是为了让博士生们在第一年结束时知道些什么。
在公钥密码学中，如果Alice想要给Bob发送一条消息，她需要Bob的公钥，一般来说公钥都很长，就像一个随机的字符串。
假设Alice可以不用公钥而是使用Bob的名字或者邮件地址作为他的公钥。实际的来说，这会很方便，Alice不必记住很长的公钥，也不用验证这个类似于随机串的公钥是否真的属于Bob。为了让这变得容易，我们需要基于身份的加密（IBE）。
在IBE中，存在一个实体叫做私钥生成器（PKG）。PKG能够通过Bob的ID和一个主密钥来计算Bob的私钥。一旦Bob已经对PKG认证过自己，那么他就可以向PKG请求他的私钥，一旦他获得了自己的私钥，那么他就可以对任何通过他的ID加密的消息进行解密。
但是这里有一个问题，通过主密钥，PKG可以对任何ID都生成一个私钥，因此PKG可以对任何消息进行解密，这叫做密钥托管，意思就是说你必须信任PKG不会读取你的消息或者你不在乎PKG会读取你的消息。在公司中，高级管理者一般都有权限读取你的邮件，因此IBE方案在这种情况下是很恰当的。
正式的，一个IBE方案包含四个算法：setup，extract，encrypt和decrypt。
转载链接：https://www.cnblogs.com/zhuowangy2k/p/12249077.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad6c5b73a9221c45c94cf66f2ac30b82/" rel="bookmark">
			qps计算公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qps=1000ms/单个请求耗时*服务器核心数
单个请求耗时100ms
服务器核心数4核
qps=1000ms/100*4=40个/每秒
QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。每秒的响应请求数，也即是最大吞吐能力 jmeter里面对应的是吞吐量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71a324c62d4b14122cae6022a33701aa/" rel="bookmark">
			std::result_of编译时获取函数返回类型（C&#43;&#43;11）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 定义： 1.头文件：&lt;type_traits&gt;
2.函数定义：
template&lt; class &gt; class result_of; // F为函数类型 ArgTypes为函数可变参数类型 template&lt; class F, class... ArgTypes &gt; class result_of&lt;F(ArgTypes...)&gt;; 3.实例：
int fun(int x) { return x + 1; } std::result_of&lt;fun(int)&gt;::type d = 10; // d的类型是fun返回类型int 二 应用实例： 1.问题描述：定义一个person数组，person包含姓名，年龄和城市信息，现在需要按照某一条件对该person数组做分组，条件可以是按照年龄或者按照姓名和城市等等。
2.分析：设计range类并提供group_by方法，该方法返回一个multimap，key为分组条件，value为person对象。
3.代码：
（1）range.hpp
#pragma once #include &lt;map&gt; #include &lt;type_traits&gt; #include &lt;algorithm&gt; template &lt;typename R&gt; class range { public: typedef typename R::value_type value_type; // 获取R的类型 range(R &amp;r) : range_(r) { } public: template &lt;typename KeyFn, typename ValueFn&gt; // KeyFn为key对应的映射函数 即输入value_type类型的值 输出key ValueFn同理 std::multimap&lt;typename std::result_of&lt;KeyFn(value_type)&gt;::type, typename std::result_of&lt;ValueFn(value_type)&gt;::type&gt; // multimap的key和value都采用std::result_of获取类型 group_by(const KeyFn &amp;keyf, const ValueFn &amp;valuef) { typedef typename std::result_of&lt;KeyFn(value_type)&gt;::type k_type; typedef typename std::result_of&lt;ValueFn(value_type)&gt;::type v_type; std::multimap&lt;k_type, v_type&gt;mm; std::for_each(std::begin(range_), std::end(range_), [&amp;mm, &amp;keyf, &amp;valuef] (const value_type &amp;item) { // 这里要求rang_是容器类型 k_type key = keyf(item); // 映射出key v_type value = valuef(item); // 映射出value mm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71a324c62d4b14122cae6022a33701aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d62f5e7067ff276a844a8ca2ab535d72/" rel="bookmark">
			使用vs建立C/C&#43;&#43;项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有粉丝私信我，说看到我文章中的截图看起来好像界面和它的不一样？当我建议他们用vs编程的时候，他们说vs建立项目感觉好复杂，不会弄？其实真的是很简单的，所以在这里给大家做个简单的介绍。那就以我的计算机上VS2017为示范。ps:前提是你在安装C++的时候，装上了有关C++的模块，这样才好顺利建立一个项目。
特此声明：此文适合C/C++初学者，或者首次使用vs编译器写C/C++的同学们学习阅读！
好，首先第一步：我们打开VS，首页再工具栏上会有文件，编辑等等一系列的文字提示，我们点击 文件–》项目。如下图所示：
因为我们在之前预装了Vistual C++，所以在这里选择Vistual C++，然后点击空项目，底下的名称可以自己命名，我此处就用默认的Project1来命名了，然后位置可以进行选择，之后点击确定。建议大家专门去分一个存放代码的盘，这样可以保证我们以后找代码比较方便。
然后我们到了现在如图这样一个样子：
接着我们点击源文件，添加新建项，此时需要注意：
假如我们要添加一个C++文件，那自然应该添加后缀为cpp的文件，点击C++文件，然后下面的名称可以自己命名，命名之后点击添加，就完成了cpp源文件的添加：
接着说一下，如何添加C语言类型的文件，其实也很简单，上述操作步骤不变，一直到修改名称时候，把.cpp改成.c然后进行添加即可：
添加成功源文件，那还得添加头文件啊，我们都知道头文件都是.h文件，所以不管是C或者C++都是一样的。和添加源文件步骤类似，在头文件文件夹出右键，然后点击添加新建项：
然后我们点击Visual C++，然后选择头文件，然后下面的名称，我们可以修改，也可以不改名字，进行添加：
所有内容都添加完毕之后，我们就可以写代码来测试看看效果怎么样啦，写一个“Hello KookNut”吧！在这里我就拿.cpp举例了嗷，学习C语言的同学，我相信到这里写个Hello World不存在任何问题吧！
头文件中包含以下内容
#pragma once #include&lt;iostream&gt; using namespace std; 源文件中包含以下内容
#include"Demo.h" int main() { cout &lt;&lt; "Hello KookNut39" &lt;&lt; endl; return 0; } 我们来运行，看一下结果：
至此，我们完成了一个简单的C++项目，输出了我们要的字符串。其实用VS建立一个工程不是难点，然后安装VS环境也可以在本站搜到很多很详细的教程，作为初学者，我们主要是学习C/C++基本语法和知识点，有关这些，可以看看我之前的文章欧，点击这里，打下良好的语法基础之后，我们就可以在以后面对开发大型项目的过程中也能够游刃有余！！！如果文章对您有帮助，还希望赏作者一键三连+评论留言
最后吟诗一句：“千磨万击还坚劲，任尔东西南北风”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e73208e0da7274c52042fa8ba4d6f67/" rel="bookmark">
			Nginx安装及入门笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx环境准备 Nginx版本介绍 Nginx的官方网站为: http://nginx.org
打开源码可以看到如下的页面内容
Nginx的官方下载网站为http://nginx.org/en/download.html，当然你也可以之间在首页选中右边的download进入版本下载网页。在下载页面我们会看到如下内容：
获取Nginx源码 http://nginx.org/download/
打开上述网站，就可以查看到Nginx的所有版本，选中自己需要的版本进行下载。下载我们可以直接在windows上下载然后上传到服务器，也可以直接从服务器上下载，这个时候就需要准备一台服务器。
准备服务器系统 环境准备
VMware WorkStation Centos7 MobaXterm xsheel,SecureCRT 网络 (1)确认centos的内核
准备一个内核为2.6及以上版本的操作系统，因为linux2.6及以上内核才支持epoll,而Nginx需要解决高并发压力问题是需要用到epoll，所以我们需要有这样的版本要求。
我们可以使用uname -a命令来查询linux的内核版本。
(2)确保centos能联网
ping www.baidu.com (3)确认关闭防火墙
这一项的要求仅针对于那些对linux系统的防火墙设置规则不太清楚的，建议大家把防火墙都关闭掉，因为我们此次课程主要的内容是对Nginx的学习，把防火墙关闭掉，可以省掉后续Nginx学习过程中遇到的诸多问题。
关闭的方式有如下两种：
systemctl stop firewalld 关闭运行的防火墙，系统重新启动后，防火墙将重新打开 systemctl disable firewalld 永久关闭防火墙，，系统重新启动后，防火墙依然关闭 systemctl status firewalld	查看防火墙状态 （4）确认停用selinux
selinux(security-enhanced linux),美国安全局对于强制访问控制的实现，在linux2.6内核以后的版本中，selinux已经成功内核中的一部分。可以说selinux是linux史上最杰出的新安全子系统之一。虽然有了selinux，我们的系统会更安全，但是对于我们的学习Nginx的历程中，会多很多设置，所以这块建议大家将selinux进行关闭。
sestatus查看状态
如果查看不是disabled状态，我们可以通过修改配置文件来进行设置,修改SELINUX=disabled，然后重启下系统即可生效。
vim /etc/selinux/config Nginx安装方式介绍 Nginx的安装方式有两种分别是:
通过Nginx源码 通过Nginx源码简单安装 (1) 通过Nginx源码复杂安装 (3) 通过yum安装 (2) 如果通过Nginx源码安装需要提前准备的内容：
GCC编译器 Nginx是使用C语言编写的程序，因此想要运行Nginx就需要安装一个编译工具。GCC就是一个开源的编译器集合，用于处理各种各样的语言，其中就包含了C语言。
使用命令yum install -y gcc来安装
安装成功后，可以通过gcc --version来查看gcc是否安装成功
PCRE Nginx在编译过程中需要使用到PCRE库（perl Compatible Regular Expressoin 兼容正则表达式库)，因为在Nginx的Rewrite模块和http核心模块都会使用到PCRE正则表达式语法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e73208e0da7274c52042fa8ba4d6f67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50d2b85cdfeaeb6f0f9e356b17c0474f/" rel="bookmark">
			RestTemplate-文件上传下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
二、RestTemplate 配置
三、文件上传
四、文件下载
如果发现本文有错误的地方，请大家毫不吝啬，多多指教，欢迎大家评论，谢谢！
一、概述 在我们实际开发项目中，有需求通过HttpCliect调用另外一个服务去上传，此时我们可以 RestTemplate 上传和下载来实现功能，是一个不错的选择。
二、RestTemplate 配置 /** * RestTemplate配置 * 这是一种JavaConfig的容器配置，用于spring容器的bean收集与注册，并通过参数传递的方式实现依赖注入。 * "@Configuration"注解标注的配置类，都是spring容器配置类，springboot通过"@EnableAutoConfiguration" * 注解将所有标注了"@Configuration"注解的配置类，"一股脑儿"全部注入spring容器中。 * * @author Zou.LiPing * */ @Configuration public class RestTemplateConfig { @Bean public RestTemplate restTemplate(@Qualifier("simpleClientHttpRequestFactory") ClientHttpRequestFactory factory){ return new RestTemplate(factory); } @Bean public ClientHttpRequestFactory simpleClientHttpRequestFactory(){ SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); factory.setConnectTimeout(15000); // 获取数据超时时间 毫秒 factory.setReadTimeout(5000); return factory; } } 三、文件上传 调用者
@Slf4j @RestController @AllArgsConstructor @RequestMapping("file") public class FileController { private final RestTemplate restTemplate; /** * restTemplate 上传文件 * 访问地址: http://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50d2b85cdfeaeb6f0f9e356b17c0474f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4d5e6b0fb7dea1283c730c4b0b9586d/" rel="bookmark">
			EMD算法原理分解信号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSVEP信号中含有自发脑电和大量外界干扰信号，属于典型的非线性非平稳信号。传统的滤波方法通常不满足对非线性非平稳分析的条件，1998年黄鄂提出希尔伯特黄变换(HHT)方法，其中包含经验模式分解(EMD)和希尔伯特变换(HT)两部分。EMD可以将原始信号分解成为一系列固有模态函数(IMF) [1]，IMF分量是具有时变频率的震荡函数，能够反映出非平稳信号的局部特征，用它对非线性非平稳的SSVEP信号进行分解比较合适。
网友Aeo[2]提供了下面的算法过程分析。
算法过程分析
筛选（Sifting）
求极值点 通过Find Peaks算法获取信号序列的全部极大值和极小值
拟合包络曲线 通过信号序列的极大值和极小值组，经过三次样条插值法获得两条光滑的波峰/波谷拟合曲线，即信号的上包络线与下包络线
均值包络线 将两条极值曲线平均获得平均包络线
中间信号 原始信号减均值包络线，得到中间信号
判断本征模函数（IMF） IMF需要符合两个条件：1）在整个数据段内，极值点的个数和过零点的个数必须相等或相差最多不能超过一个。2）在任意时刻，由局部极大值点形成的上包络线和由局部极小值点形成的下包络线的平均值为零，即上、下包络线相对于时间轴局部对称。
IMF 1 获得的第一个满足IMF条件的中间信号即为原始信号的第一个本征模函数分量IMF 1（由原数据减去包络平均后的新数据，若还存在负的局部极大值和正的局部极小值，说明这还不是一个本征模函数，需要继续进行“筛选”。）
使用上述方法得到第一个IMF后，用原始信号减IMF1，作为新的原始信号，再通过上述的筛选分析，可以得到IMF2，以此类推，完成EMD分解。
下面利用公式来说明上面的分析过程。
EMD算法步骤
任何复杂的信号均可视为多个不同的固有模态函数叠加之和，任何模态函数可以是线性的或非线性的，并且任意两个模态之间都是相互独立的。在这个假设 基础上，复杂信号x(t) 的EMD分解步骤如下：
步骤1：
寻找信号 全部极值点，通过三次样条曲线将局部极大值点连成上包络线，将局部极小值点连成下包络线。上、下包络线包含所有的数据点。
步骤2：
由上包络和下包络线的平均值 m1(t) ，得出
h1(t)=x(t)-m1(t);
若h1(t) 满足IMF的条件，则可认为h1(t) 是x(t) 的第一个IMF分量。
步骤3：
若 h1(t)不符合IMF条件，则将 h1(t) 作为原始数据，重复步骤1、步骤2，得到上、下包络的均值m1(t) ，通过计算 h1(t)=h1(t)-m1(t);是否适合IMF分量的必备条件，若不满足，重复如上两步 k次，直到满足前提下得到。第1个IMF表示如下:
c1(t)=;
步骤4：
将c1(t) 从信号x(t) 中分离得到：
r1=x(t)-c1(t);
将 r1(t)作为原始信号重复上述三个步骤，循环 n次，得到第二个IMF分量 c2(t)直到第n 个IMF分量 ，则会得出：
步骤5：
当 变成单调函数后，剩余的 成为残余分量。所有IMF分量和残余分量之和为原始信号x(t) ：
;
1.求极大值点和极小值点
from scipy.signal import argrelextrema import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4d5e6b0fb7dea1283c730c4b0b9586d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d127e076cdeecf8d25a3c7d4d2d6af14/" rel="bookmark">
			项目分享：spu和sku 搜索服务分享 21-05-27
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spu和sku 搜索服务 文章目录 spu和sku 搜索服务流程分析表结构分析查询所有SKU后端实现：JavaBean后端实现：搭建环境后端实现：查询 流程分析 搜索服务：从elasticsearch中搜索数据，默认情况下es中没有数据sku查询功能：从数据库查询sku所有相关信息数据同步：将数据库中的数据，同步到es中。（） 数据库查询搜索慢、es查询速度快同步时机：1. 定时器（理论）、2. 测试程序（实施） 表结构分析 商品相关表总览 表间关系 查询所有SKU 接口
GET http://localhost:10010/web-service/sku/esData 后端实现：JavaBean 数据库相关JavaBean Spu类似分类Sku 商品详情SkuComment sku的评论 ES相关JavaBean ESData 准备存放到es中的数据，是以上三种数据的组合数据。 Spu
package com.czxy.changgou4.pojo; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableName; import lombok.Data; import java.util.Date; @TableName("tb_spu") @Data public class Spu { @TableId(type = IdType.AUTO) private Integer id; //spu名字 @TableField(value="spu_name") private String spuName; //spu副名称 @TableField(value="spu_subname") private String spuSubname; //商品logo @TableField(value="logo") private String logo; //分类1Id @TableField(value="cat1_id") private Integer cat1Id; //分类2ID @TableField(value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d127e076cdeecf8d25a3c7d4d2d6af14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/950ed903fb66975cf157f3e636ddf014/" rel="bookmark">
			鸿蒙os升级APP信息会被删除,可以放心了！荣耀机型会升级鸿蒙OS系统！一款机型已得到确认！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此前荣耀还没有正式和华为分开的时候，鸿蒙系统如果搭载在手机上那么必不可少荣耀的机型也会逐步的升级。
但是当荣耀和华为分离之后，不少的人就不太确定鸿蒙OS的升级是否涵盖了荣耀之前的机型，也对此引发了一些担忧，害怕荣耀此前的机型不会升级鸿蒙OS系统。
而到了鸿蒙OS系统被宣布将在4月份逐步升级之后，并且目前暂时余承东公布的是mate X2在升级的名单里，并没有单独的提到荣耀的机型。
而且在之前通过各方透露的消息显示，更新EMUI 11的华为机型可能会比没有更新的要先升级鸿蒙OS系统。于是这份担忧也越来越深。
不过，现在可以放心了。
根据知名博主@长安数码君的近期的爆料显示，华为不会区别对待荣耀和华为的老用户，荣耀此前的机型也会升级鸿蒙OS系统。而目前荣耀机型升级鸿蒙OS的名单出炉。看到这里别急着高兴，这份名单并不长，只有一款机型。根据爆料的信息显示，荣耀9X这一款手机已得到升级系统的确认，并且会在今年年内的时候完成鸿蒙OS系统的升级。
至于其他的机型，小编在文章后面会提及一些相关信息。接着我们继续往下看。
个人认为，这份爆料的真实性还是很高的，因为这位博主平时爆料的很多信息到最后几乎都接近官方宣布的信息。而且由此位博主的透露显示，他是联系了华为和荣耀双方的开发人员才得到了这样的消息确认。从某种程度上来说，荣耀9X已经确定会在荣耀机型升级的名单里。
而通过这样的一个消息，我们也可以得知华为并没有放弃对以前荣耀的机型搭载鸿蒙OS系统的计划，简而言之，以前的荣耀机型也有搭载鸿蒙OS的机会。所以，使用荣耀手机的用户可以放心了，等到后续逐步升级的时候，也能体验一下鸿蒙OS的系统。
不过，目前升级的时间并没有确定。
按照官方的信息显示，鸿蒙OS的系统是逐步升级在手机上，荣耀的机型就算是在升级的名单当中，也不可能赶在华为mate X2的前面。而且个人认为，很有可能荣耀此前的机型在升级的时间上会稍微落后一点华为的其他旗舰机型。
毕竟，有一个很现实的问题，那就是华为好荣耀现在已经分开了，华为主要的重心很大可能是放在华为自己过去的旗舰机型上。但这也不是什么大事，最多时间要等得久一点，总不如以前还需要猜测荣耀的机型到底在不在鸿蒙OS的升级当中。
说完这一点，现在小编再来说说刚刚我们说到的那个问题，相信也是很多荣耀机型用户关心的问题，那就是：除了荣耀9X之外，其他的荣耀机型名单有哪些？
目前暂时没有确认的消息爆出，不过小编根据长安数码局此前在2月份的爆料信息中找到了一点可用的信息。在2月份的时候，该位博主爆料，升级了Magic 4.0的机型将会升级到鸿蒙OS的系统。而没有升级到这个系统的机型，可能会直接跳过这个版本的升级，搭载鸿蒙OS系统。
或许正如华为的王成录所言：市面上90％的机型都会有升级鸿蒙OS系统的机会。
写在最后
至于和华为分开之后，荣耀发布的机型是否会继续搭载鸿蒙OS的系统，这个还真的很难说。因为之前赵明在回应这个问题的时候，说了一句要看鸿蒙的开源程度，还说了一个荣耀会遵守相关的规则制度。所以，之后荣耀发布的机型，会搭载鸿蒙OS系统得打一个问号。换一句简单的话来说就是，荣耀现在跟其他的友商一样，是华为的竞争对手。
最后，有多少荣耀机型的用户呢？等到升级的时候你们会选择升级鸿蒙OS的系统吗？欢迎留言评论、点赞和分享！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7e169b5bd6c93a503fa86d1228da671/" rel="bookmark">
			8.3 通过指针引用数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第八章 善于利用指针
目录
第八章 善于利用指针
8.3 通过指针引用数组
8.3.1 数组元素的指针
8.3.2 在引用数组元素时指针的运算
8.3.3 通过指针引用数组元素
8.3.4 用数组名作函数参数
*8.3.5 通过指针引用多维数组
​​​​​​​
8.3 通过指针引用数组 8.3.1 数组元素的指针 所谓数组元素的指针就是数组元素的地址。一个变量有地址，一个数组包含若干个元素。每个元素都在内存中占用存储单元，它们都有相应的地址。指针变量可以指向变量，当然也可以指向有地址的数组元素（把地址放在一个指针变量中），这就是数组元素的指针就是数组元素的地址。
int a[10] = {0,1,2,3,4,5,6,7,8,9}; //定义a为包含10个整型数据的数组 int * p ; //定义基类型为int，指针变量p； p = &amp;a[0]; //把a[0]元素的地址赋给了指针变量p； 以上是使指针变量p指向数组a的第0个元素。
引用数组我们可以用下标法（a[0],a[1]),也可以用指针法（即通过指向数组元素的指针找到该元素）。使用指针的好处是目标程序质量高，占用内存少，运行速度快。
在C语言中，数组名（不包括形参数组名）代表数组首元素（即序号为0的元素）的地址。如下面语句
p = &amp;a[0]; //p的值是a[0]的地址 p = a; //p的值是a[0]的地址 该两行代码等价，都是p指向数组a[0]的地址。
*注意：程序中的数组名不代表整个数组元素，仅仅只代表首元素的地址。
在定义指针变量时可以将对它初始化，如
int * p = a; //等同于下面代码语句 int *p; p = a ; /*此语句等同于 ————&gt;*/ p = &amp;a[0]； 该代码的含义是将a（a[0]）的首元素地址赋给指针变量p；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7e169b5bd6c93a503fa86d1228da671/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/359/">«</a>
	<span class="pagination__item pagination__item--current">360/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/361/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>