<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfd6b4d780f448c7ca2c20917166d732/" rel="bookmark">
			【图像去噪】均值&#43;中值图像去噪【含GUI Matlab源码 1815期】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⛄一、获取代码方式 获取代码方式1：
完整代码已上传我的资源：【图像去噪】基于matlab GUI均值+中值图像去噪【含Matlab源码 1815期】
(https://download.csdn.net/download/TIQCmatlab/62925370)
点击上面蓝色字体，直接付费下载，即可。
获取代码方式2：
付费专栏Matlab图像处理（初级版）
备注：
点击上面蓝色字体付费专栏Matlab图像处理（初级版），扫描上面二维码，付费29.9元订阅海神之光博客付费专栏Matlab图像处理（初级版），凭支付凭证，私信博主，可免费获得1份本博客上传CSDN资源代码（有效期为订阅日起，三天内有效）；
点击CSDN资源下载链接：1份本博客上传CSDN资源代码
⛄二、图像去噪及滤波简介 1 图像去噪
1.1 图像噪声定义
噪声是干扰图像视觉效果的重要因素，图像去噪是指减少图像中噪声的过程。噪声分类有三种：加性噪声，乘性噪声和量化噪声。我们用f(x,y）表示图像，g(x,y）表示图像信号，n(x,y）表示噪声。
图像去噪是指减少数字图像中噪声的过程。现实中的数字图像在数字化和传输过程中常受到成像设备与外部环境噪声干扰等影响，称为含噪图像或噪声图像。去噪是图像处理研究中的一个重点内容。在图像的获取、传输、发送、接收、复制、输出等过程中，往往都会产生噪声，其中的椒盐噪声是比较常见的一种噪声，它属于加性噪声。
1.2 图像噪声来源
（1）图像获取过程中
图像传感器CCD和CMOS采集图像过程中受传感器材料属性、工作环境、电子元器件和电路结构等影响，会引入各种噪声。
（2）图像信号传输过程中
传输介质和记录设备等的不完善，数字图像在其传输记录过程中往往会受到多种噪声的污染。
1.3 噪声分类
噪声按照不同的分类标准可以有不同的分类形式：
基于产生原因：内部噪声，外部噪声。
基于噪声与信号的关系：
加性噪声：加性噪声和图像信号强度是不相关的，这类带有噪声的图像g可看成为理想无噪声图像f与噪声n之和：
g = f + n；
乘性嗓声：乘性噪声和图像信号是相关的，往往随图像信号的变化而变化，载送每一个象素信息的载体的变化而产生的噪声受信息本身调制。在某些情况下，如信号变化很小，噪声也不大。为了分析处理方便，常常将乘性噪声近似认为是加性噪声，而且总是假定信号和噪声是互相统计独立。
g = f + f*n
按照基于统计后的概率密度函数：
是比较重要的，主要因为引入数学模型这就有助于运用数学手段去除噪声。在不同场景下噪声的施加方式都不同，由于在外界的某种条件下，噪声下图像-原图像（没有噪声时）的概率密度函数（统计结果）服从某种分布函数，那么就把它归类为相应的噪声。下面将具体说明基于统计后的概率密度函数的噪声分类及其消除方式。
1.4 图像去噪算法的分类
（1）空间域滤波
空域滤波是在原图像上直接进行数据运算，对像素的灰度值进行处理。常见的空间域图像去噪算法有邻域平均法、中值滤波、低通滤波等。
（2）变换域滤波
图像变换域去噪方法是对图像进行某种变换，将图像从空间域转换到变换域，再对变换域中的变换系数进行处理，再进行反变换将图像从变换域转换到空间域来达到去除图像嗓声的目的。将图像从空间域转换到变换域的变换方法很多，如傅立叶变换、沃尔什-哈达玛变换、余弦变换、K-L变换以及小波变换等。而傅立叶变换和小波变换则是常见的用于图像去噪的变换方法。
（3）偏微分方程
偏微分方程是近年来兴起的一种图像处理方法，主要针对低层图像处理并取得了很好的效果。偏微分方程具有各向异性的特点，应用在图像去噪中，可以在去除噪声的同时，很好的保持边缘。偏微分方程的应用主要可以分为两类:一种是基本的迭代格式，通过随时间变化的更新，使得图像向所要得到的效果逐渐逼近，这种算法的代表为Perona和Malik的方程，以及对其改进后的后续工作。该方法在确定扩散系数时有很大的选择空间，在前向扩散的同时具有后向扩散的功能，所以，具有平滑图像和将边缘尖锐化的能力。偏微分方程在低噪声密度的图像处理中取得了较好的效果，但是在处理高噪声密度图像时去噪效果不好，而且处理时间明显高出许多。
（4）变分法
另一种利用数学进行图像去噪方法是基于变分法的思想，确定图像的能量函数，通过对能量函数的最小化工作，使得图像达到平滑状态，现在得到广泛应用的全变分TV模型就是这一类。这类方法的关键是找到合适的能量方程，保证演化的稳定性，获得理想的结果。
形态学噪声滤除器将开与闭结合可用来滤除噪声，首先对有噪声图像进行开运算，可选择结构要素矩阵比噪声尺寸大，因而开运算的结果是将背景噪声去除；再对前一步得到的图像进行闭运算，将图像上的噪声去掉。据此可知，此方法适用的图像类型是图像中的对象尺寸都比较大，且没有微小细节，对这类图像除噪效果会较好。
⛄三、部分源代码 function varargout = work(varargin)
% WORK MATLAB code for work.fig
% WORK, by itself, creates a new WORK or raises the existing
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfd6b4d780f448c7ca2c20917166d732/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3658d1bc455fcfc6655861fd7757af27/" rel="bookmark">
			回归预测 | MATLAB实ZOA-LSTM基于斑马优化算法优化长短期记忆神经网络的多输入单输出数据回归预测模型 （多指标，多图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回归预测 | MATLAB实ZOA-LSTM基于斑马优化算法优化长短期记忆神经网络的多输入单输出数据回归预测模型 （多指标，多图） 目录 回归预测 | MATLAB实ZOA-LSTM基于斑马优化算法优化长短期记忆神经网络的多输入单输出数据回归预测模型 （多指标，多图）效果一览基本介绍程序设计参考资料 效果一览 基本介绍 1.回归预测 | MATLAB实ZOA-LSTM基于斑马优化算法优化长短期记忆神经网络的多输入单输出数据回归预测模型 （多指标，多图） （多指标，多图） 。出图包括迭代曲线图、预测效果图等等。
2.matlab 版本要求2020b及以上版本 程序已调试好可以直接运行(数据直接在Excel中替换)优化参数为核参数。
3.直接替换Excel数据即可用，注释清晰，适合新手小白[火]
4.附赠示例数据，直接运行main文件一键出图[灯泡]评价指标包括:R2、MAE、MSE、MAPE、RMSE等，图很多。
程序设计 完整源码和数据获取方式：私信回复MATLAB实ZOA-LSTM基于斑马优化算法优化长短期记忆神经网络的多输入单输出数据回归预测模型 （多指标，多图）。 %% 清空环境变量 warning off % 关闭报警信息 close all % 关闭开启的图窗 clear % 清空变量 clc % 清空命令行 %% 导入数据 res = xlsread('data.xlsx'); %% 划分训练集和测试集 temp = randperm(103); P_train = res(temp(1: 80), 1: 7)'; T_train = res(temp(1: 80), 8)'; M = size(P_train, 2); P_test = res(temp(81: end), 1: 7)'; T_test = res(temp(81: end), 8)'; N = size(P_test, 2); %% 数据归一化 [p_train, ps_input] = mapminmax(P_train, 0, 1); p_test = mapminmax('apply', P_test, ps_input); [t_train, ps_output] = mapminmax(T_train, 0, 1); t_test = mapminmax('apply', T_test, ps_output); %% 数据反归一化 T_sim1 = mapminmax('reverse', t_sim1, ps_output); T_sim2 = mapminmax('reverse', t_sim2, ps_output); %% 均方根误差 error1 = sqrt(sum((T_sim1 - T_train).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3658d1bc455fcfc6655861fd7757af27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fddeb0ea05449f9071e298c1d558813/" rel="bookmark">
			NeurIPS 2023 | 用于多示例偏标记学习的消歧注意力嵌入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		©作者 | 邱思超
单位 | IDEA Lab
来源 | AIforBio
论文标题：
Disambiguated Attention Embedding for Multi-Instance Partial-Label Learning
论文地址：
https://arxiv.org/abs/2305.16912
代码地址：
https://palm.seu.edu.cn/zhangml/files/DEMIPL.rar
今天给大家分享的是东南大学张敏灵教授团队发表在 NeurIPS 2023 的一篇论文“Disambiguated Attention Embedding for Multi-Instance Partial-Label Learning”。这篇文章提出了一种用于多示例偏标签学习的消歧注意力嵌入算法 DEMIPL，它引入了消歧注意力机制与注意力损失将多示例包映射到嵌入空间，进而通过基于动量的消歧策略从候选标签集中识别多示例包的真实标签。
论文介绍
在许多现实世界的任务中，相关对象可以表示为与候选标签集相关联的多示例包，该候选标签集由一个真实标签和几个假阳性标签组成。多示例偏标记学习（MIPL，Multi-Instance Partial-Label learning）是一种处理此类任务的学习范式，并取得了良好的性能。现有的 MIPL 方法遵循示例空间范式，将包的扩充候选标签集分配给每个示例，并从示例级标签聚合包级标签。
然而，该方案具有局限性，因为全局包级别信息被忽略，并且包的预测标签对负面情况的预测敏感。在本文中，作者提出算法 DEMIPL 用于多示例偏标签学习的消歧注意力嵌入。DEMIPL 采用消歧注意力机制将多示例包聚合到单个向量表示中，然后采用基于动量的消歧策略从候选标签集中识别真实标签。
此外，作者提出了一个用于结直肠癌癌症分类的真实 MIPL 数据集。在基准数据集和真实数据集上的实验结果表明，DEMIPL 在性能上优于其他 MIPL 和偏标记学习（PLL，Partial-Label Learning）方法。
方法
▲ 图1. DEMIPL框架图
2.1 DEMIPL框架 设表示示例空间，设表示包含个类标签的标签空间。MIPL 的目标是得到一个分类器。是由个包及其相关的候选标签集组成的训练数据集。
特别地，是第个多示例偏标签样本，其中构成一个带有个示例的包，其中每个示例, 。是隐藏了真实标签的候选标签集，即，在训练过程中真实标签是未知的。
假设中的潜在示例级别标签为，则，且 \ 。在 MIPL 的背景下，如果一个示例的标签与包的真实标签相同，则该示例被视为正示例；否则，它将被视为负示例。此外，负示例的类标签不属于标签空间。
DEMIPL 的框架主要包括三个主要步骤：首先，作者提取多示例包中的示例，并获得示例级别特征。接下来，使用消歧注意力机制将多示例包集成到单个特征向量中。最后，使用分类器来预测多示例包的分类置信度。为了提高分类性能，作者为模型训练引入了两个损失函数：注意力损失和基于动量的消歧损失。在训练过程中，注意力机制和分类器协同工作。
2.2 消歧注意机制 消歧注意机制是 DEMIPL 的关键组成部分，对于多示例包，使用由参数化的神经网络来提取其特征信息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fddeb0ea05449f9071e298c1d558813/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/520b9b52c1929377b2464126c211032c/" rel="bookmark">
			OpenLAM | 深度势能预训练大模型DPA-2发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在迈向通用大原子模型（Large Atomic Model，LAM）的征途上，深度势能核心开发者团队面向社区，发起 OpenLAM 大原子模型计划。OpenLAM 的口号是“征服元素周期表！”，希望通过建立开源开放的围绕微尺度大模型的生态，为微观科学研究提供新的基础设施，并推动材料、能源、生物制药等领域微尺度工业设计的变革。
经过北京科学智能研究院、深势科技、北京应用物理与计算数学研究所等 29 家单位的 42 位合作者的通力协作，深度势能团队近日面向社区发布了深度势能预训练大模型 DPA-2，将成为 OpenLAM 大原子模型计划的重要载体。基于 DPA-2 的微调/蒸馏/应用自动化流程也于同期面向社区全面开放，打通了面向各类实际应用的最后一公里。相关文章[1]以《DPA-2: Towards a universal large atomic model for molecular and material simulation》为题，在arXiv上预发表。
论文链接：
https://arxiv.org/abs/2312.15492
面向丰富的下游任务，微调 DPA-2“大模型”所需的数据量整体相比过去减少了 1-2 个数量级；同时，进一步蒸馏、压缩得到的深度势能“小模型”可以保持过去模型的精度和效率。相比于去年发布的 DPA-1，DPA-2 在模型架构显著更新的同时，最大的特点在于采用了多任务训练的策略，从而可以同时学习计算设置不同、标签类型不同的各类数据集。由此产生的模型在下游任务上显示出极强的 few-shot 乃至 zero-shot 迁移的能力，显著超越过去的方案。目前用于训练 DPA-2 模型的数据集已覆盖了半导体、钙钛矿、合金、表面催化、正极材料、固态电解质、有机分子等多类体系。
图1 DPA-2 提出的多任务预训练、微调、蒸馏全流程示意图
“大原子模型计划(OpenLAM)”为进一步打破数据壁垒，拓宽原子层面各方面的应用，为开源开放的科学计算生态共建打开了新的思路。作为一项开放式的协作计划，建立一个开放且面向应用的模型评估系统也格外重要。面向社区该计划将定期进行模型更新与评估报告发布、定期更新发布领域应用与评估工作流，同时开展比赛、培训交流，与领域开发者协作推动建立供预训练与评估的数据集等。这将是 OpenLAM 计划在 2024 年的重点。
感兴趣的读者，欢迎通过以下 Bohrium Notebook 链接快速上手 DPA-2，也欢迎使用 DP Combo@Bohrium APP 更加深入系统地产生你需要的势函数！
Notebook链接
https://nb.bohrium.dp.tech/detail/18475433825
以下为关于 DPA-2 的详细介绍。
DPA-2 项目背景
机器学习势函数在材料科学、计算物理等领域应用广泛，并取得了较大成果。然而，面对一个新的复杂体系，要获得可用的、较为完备的势函数模型，科学家们基本上仍然需要获取大量计算数据并从头开始训练模型。随着电子结构数据的积累，开始有工作关注“通用”的势能函数模型，比如 DPA-1，Gemnet-OC，Equiformer-V2，M3GNet 等，并有部分工作将其应用到“预训练+微调”的范式上来，从而节省新体系的数据生产成本。
但是这些模型还没有做到通用，主要有以下几方面的问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/520b9b52c1929377b2464126c211032c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/515a67f67200776942a4e1cd30227c23/" rel="bookmark">
			上海内推 | 途深智合招聘AI4Science方向研发工程师/算法实习生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		合适的工作难找？最新的招聘信息也不知道？
AI 求职为大家精选人工智能领域最新鲜的招聘信息，助你先人一步投递，快人一步入职！
途深智合
公司成立于2022年，是一家人工智能蛋白质设计领域的新锐公司，致力于开发轻量、可控的人工智能模型，降低生物科技领域中开发新合成生物产品的难度、周期和成本。公司CEO是上海交通大学自然科学研究院的王宇光副教授，团队核心成员来自于上海交大，清华大学，约翰霍普金斯大学等。公司于2023年拿到种子轮投资，目前已经与国内外知名的生物，医药等企业开展合作。初次之外，公司在多家行业大赛中获奖，包括获得了英伟达2023年度Top10初创企业，创业黑马AI年度TOP30初创企业等。
AI研发工程师
坐标：上海
岗位职责
1. 负责公司人工智能蛋白质设计模型的开发和具体任务的交付；
2. 完成算法模块在平台的上线和测试工作；
3. 跟进领域最新进展，能完成文章的复现和深度理解，并提出创新方案。
岗位要求
1. 计算机、机器学习等相关专业；
2. 对机器学习算法、深度神经网络等有理论上的知识和实际应用能力；
3. 熟悉Linux系统，熟练掌握Python；
4. 熟练使用pytorch等深度学习框架；
5. 熟悉Transformer或图神经网络；
6. 有良好的学习能力和习惯；
7. 在计算机顶会顶刊上发表文章者优先考虑；
8. 有生物信息学相关背景优先；
9. 211或985学历优先。
AI算法实习生
坐标：上海
岗位职责
1. 研究大型蛋白质语言模型的设计和预训练方法；
2. 研究基于深度学习的蛋白质序列和结构表征方法；
3. 实现蛋白质大模型的分布式部署和训练；
4. 研究生成式模型在蛋白质设计中的应用；
5. 挖掘并清洗与团队研究主题相关的蛋白质实验数据；
6. 协助团队设计算法、完成实验和模型落地。
岗位要求
1. 计算机、人工智能、生物信息学等相关专业，硕士或以上；
2. 具备NLP大模型或GNN的相关理论知识，有相关实践项目或者论文发表的优先；
3. 熟悉python编程语言和深度学习框架，包括PyTorch、Hugging Face等；
4. 在CCF推荐的A、B类或同档次国际会议和期刊上发表过论文的优先；
5. 有大模型分布式训练经验，熟悉DeepSpeed, DDP，FSDP等框架的优先；
6. 可以在上海市闵行区（上海交大附近）实习3-6个月。
投递方式 📪 yyp@tsynbio.com
邮件标题和简历标明：姓名-岗位名称-AI求职
实习内推
中国电信总部大数据AI中心｜京东零售推荐算法团队｜创业黑马科技集团｜微信视觉团队｜小红书搜索团队｜VIVO影像算法研究部｜阿里通义实验室对话智能团队｜智源人工智能研究院｜微软亚洲研究院媒体计算组｜华为云｜小米自动驾驶团队｜字节跳动国际化短视频搜索团队｜京东广告研发部｜默沙东高阶分析团队｜浙江清华长三角研究院｜阿里通义实验室对话智能团队｜新加坡科技研究局A*STAR｜联想数字化转型部门｜腾讯优图实验室｜快手Y-tech部门｜中国科学院自动化研究所｜腾讯IEG光子工作室群｜微软亚洲研究院自然语言计算组｜粤港澳大湾区数字经济研究院｜好未来AI增长实验室｜腾讯混元大模型团队｜微软亚洲互联网工程院｜AMD北京AI算法团队｜Apple中国NLP团队｜右脑科技
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/515a67f67200776942a4e1cd30227c23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2c2091fd5869764f555e521b398e75/" rel="bookmark">
			校园跑腿小程序源码系统：取快递&#43;寄快递&#43;食堂超市跑腿 带完整的搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现如今，越来越多的校园生活服务需求涌现出来。为了满足学生们的日常需求，校园跑腿小程序应运而生。这款小程序集成了取快递、寄快递、食堂超市跑腿等功能，为学生们提供了一个方便、快捷的生活服务平台。
以下是部分代码的示例：
系统特色功能一览：
1.取快递：学生们可以通过小程序在线下单，让跑腿人员代取快递并送至指定地点，省去了排队等待的烦恼。
2.寄快递：除了取快递，学生们还可以在小程序上选择寄快递服务。填写寄送信息后，会有跑腿人员上门取件，方便快捷。
3.食堂超市跑腿：小程序还提供了食堂超市代购服务。学生们可以在线下单购买所需物品，由跑腿人员代购并送至宿舍或指定地点。
4.完整的搭建教程：为了让更多的人了解并搭建这款小程序，我们提供了完整的搭建教程。从环境配置到代码实现，每一个步骤都有详细的说明，让没有经验的开发者也能轻松上手。
校园跑腿小程序源码系统为校园生活提供了极大的便利。无论是取快递、寄快递还是食堂超市跑腿，都能满足学生们的日常需求。而完整的搭建教程则让更多的人能够参与到这款小程序的推广和建设中来，共同打造一个更加便捷、高效的校园生活服务平台。
页面展示：
源码下载地址：春哥技术博客或帮企商城获取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4701ec088074f15d60a6daae9c6ba8e2/" rel="bookmark">
			骑砍MOD天芒传奇-任务列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.真假仁宗
进入场景后找到假的仁宗并击杀,只能问一个问题.但你不知道他是否是说真话的那个人！
dlga_rz_question_list:question1|那 个 是 仁 宗 ？ dlga_rz_question_list:question2|你 是 个 说 真 话 的 人 吗 ？ dlga_rz_question_list:question3|你 说 说 旁 边 那 个 守 卫 会 说 那 个 是 仁 宗 ？ 骑砍1战团mod天芒传奇-重出江湖_哔哩哔哩_bilibilihttps://www.bilibili.com/video/BV1AN41157NJ/
二.找回丢失的和谈金
进入场景后找到四个凶手,四个凶手的名字暗藏在线索之中.击杀四个凶手后就可以把门打开取得金子了.
国 初 以 来 画 鞍 马 - 安国泰 神 庙 独 数 江 都 王 - 王海霸 将 军 得 名 三 十 载 - 萧军 人 间 又 见 真 乘 黄 - 黄乐 骑砍1战团mod天芒传奇-找回丢失的和谈金_哔哩哔哩_bilibiliMOD下载地址:https://gitcode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4701ec088074f15d60a6daae9c6ba8e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/243fd803532252d0c6f1e9172ff1d2cc/" rel="bookmark">
			PTA找出不是两个数组共有的元素（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读题： 给定两个整型数组，本题要求找出不是两者共有的元素。
输入格式: 输入分别在两行中给出两个整型数组，每行先给出正整数N（≤20），随后是N个整数，其间以空格分隔。
输出格式: 在一行中按照数字给出的顺序输出不是两数组共有的元素，数字间以空格分隔，但行末不得有多余的空格。题目保证至少存在一个这样的数字。同一数字不重复输出。
输入样例: 10 3 -5 2 8 0 3 5 -15 9 100 11 6 4 8 2 6 -5 9 0 100 8 1 输出样例: 3 5 -15 6 4 1 代码长度限制
16 KB
时间限制
400 ms
内存限制
64 MB
代码如下： #include &lt;stdio.h&gt; int cnt=0; int is_yes(int b[],int x,int m){//判断某一元素x在不在某一数组中 for(int i=0;i&lt;m;i++){ if(x==b[i]) return 0; } return 1; } void look(int a[],int n,int b[],int m,int c[]){ for(int i=0;i&lt;n;i++){ if(is_yes(b,a[i],m)&amp;&amp;is_yes(c,a[i],cnt)){ c[cnt++]=a[i]; } } } int main(){ int n,m,a[20],b[20],c[40]; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/243fd803532252d0c6f1e9172ff1d2cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad8b298238d8909dd9835f02e1c6ddf3/" rel="bookmark">
			Rust在写库时实现缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rust在写库时实现缓存 依赖 在写库时，实现一个缓存请求，需要用到全局变量，所以我们可以添加cratelazy_static
Cargo.toml添加以下依赖
[dependencies] chrono = "0.4.31" lazy_static = "1.4.0" reqwest = { version = "0.11.23", features = ["blocking", "json"] } serde = { version = "1.0.193", features = ["derive"] } serde_json = "1.0.108" 代码实现 use std::{sync::Mutex, collections::HashMap}; use chrono::{DateTime, Utc}; use lazy_static::lazy_static; use serde_json::Value; lazy_static! { static ref REQUESTS_RESPONSE_CACHE: Mutex&lt;HashMap&lt;String, RequestsResponseCache&gt;&gt; = Mutex::new(HashMap::new()); } pub struct RequestsResponseCache { pub response: Value, pub datetime: DateTime&lt;Utc&gt;, } pub fn get_requests_response_cache(url: &amp;str) -&gt; Result&lt;Value, reqwest::Error&gt; { let mut cache = REQUESTS_RESPONSE_CACHE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad8b298238d8909dd9835f02e1c6ddf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3350e9cea1f0eb262caaec91a0750bfd/" rel="bookmark">
			jvm实战之-常用jvm命令的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各命令的使用 JMAP 1、查看内存信息，对象实例数、对象占有大小
jmap -histo 进程号&gt;./log.txt 2、查看堆的配置信息和使用情况
jmap - heap 进程号 3、将堆的快照信息dump下来，使用java自带的jvisualvm.exe打开分析
jmap -dump:format=b,file=dump.hprof 进程号 Jstack 查看线程信息，死锁时用到可以查看线程阻塞信息
jstack -l 进程号 &gt; jstack.log jstat 查看gc日志
jstat -gc 进程号 持续打印gc日志
jstat -gc 进程号 1000 10 其他 1、jvisualvm.exe可以开启远程连接，但生产一般不用。只能在测试服务器上进行压测的时候可以开启。开启需要在服务器上加命令：自行百度
2、记录下outofmemory时的dump文件
-Xmx10M -Xms10M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:/dump.dump dump下来的文件使用java自带的jvisualvm.exe打开分析
实战例子 cpu飙高定位问题 top 查看占用较大的进程号使用 top -p 进程，再按大写的H 查看该进程下对应的线程情况找到占有最大的线程idjstack -l 进程号用jstack打出来的线程nid和top -p 查到的线程进行对比。就能得到对应的代码信息注意jstack 里面的线程信息 nid是16进制的，top里面找到的线程信息需要转换一下
优化full gc 目的：让朝生夕死的对象在年轻代就干掉，不要给他到达老年代
案例
线上系统频繁发生full gc。有卡顿，但是线上的系统压力也不是很大。
1、通过jstat -gc 进程号 查看gc情况
机器和GC情况
机器配置：2核4GJVM内存大小：2G系统运行时间：7天期间发生的Full GC次数和耗时：500多次，200多秒期间发生的Young GC 次数和耗时：1万多次，500多秒大致算下来每天会发生70多次Full GC,平均每小时3次，每次Full GC在400毫秒左右；每天会发生1000多次Young GC, 每分钟会发生一次，每次Young GC 在50毫秒左右上述数据对任何一个线上系统，用jstat -gc 进程号，可以轻松看出来，因为jstat显示出来的Full GC和Young GC的次数都是系统启动以来的总次数。可回看上方jstat -gc命令的介绍 JVM的参数设置如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3350e9cea1f0eb262caaec91a0750bfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27bf97a6c93530f3c5eadccd37045558/" rel="bookmark">
			AI智能语音机器人2023年的发展，展望2024年更上一层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年，AI智能语音机器人的发展取得了令人瞩目的进展，为人们的生活和工作带来了许多变化。以下是对2023年AI智能语音机器人发展变化的一些概述：
自然语言理解和生成能力：AI智能语音机器人在自然语言理解和生成方面取得了显著的进展。它们能够更准确地理解人类语言的含义，并能以更自然的方式进行回应和交流。跨领域应用：AI智能语音机器人的应用领域不断扩展。除了日常生活中的语音助手，如智能音箱和智能手机，它们还进入了医疗、金融、教育、客服等领域，为人们提供更智能、个性化的服务。个性化定制和学习能力：AI智能语音机器人可以通过学习用户的行为和喜好，进行个性化的定制。它们能够记住用户的喜好和习惯，并根据用户的需求和偏好提供更加精准的建议和服务。 预计在2024年，AI智能语音机器人将进一步发展，并展现出以下趋势：
人机交互的进一步迭代：AI智能语音机器人将更加注重人机交互的体验，如更加自然的语音交流和记忆对话能力。人们可以更轻松地与机器人进行对话，并得到更贴近真人的回应。智能生活场景的拓展：AI智能语音机器人将进一步拓展应用于家庭、商务和社交等生活场景。例如，可以通过智能音箱控制家居设备、协助商务会议以及社交娱乐等，使人们的生活更加便捷和智能化。提供更精准的个性化服务：AI智能语音机器人将通过学习用户的行为和偏好，为用户提供更精准和个性化的服务。它们能够通过分析用户的数据，不断优化个性化建议和推荐，帮助用户更好地满足他们的需求。深度融合于行业应用：AI智能语音机器人将进一步深度融合于不同行业的应用，如医疗、金融、教育等。在医疗领域，机器人可以提供在线问诊和健康咨询；在金融领域，机器人可以提供智能投资和财务规划建议；在教育领域，机器人可以提供个性化学习指导等。加强隐私和安全保护：随着AI智能语音机器人应用范围的扩大，隐私和安全问题也将备受关注。2024年将出现更多的隐私保护技术跨平台互通的进一步实现：AI智能语音机器人将更加实现跨平台互通，使得用户可以在不同设备上无缝地使用机器人助手。无论是通过智能手机、智能音箱还是电脑，用户都可以享受到一致的语音交互体验。语音技术与其他领域的融合：AI智能语音机器人将与其他前沿技术进行更深入的融合。例如，与增强现实、虚拟现实和区块链等技术结合，创造出更多新颖的应用场景，如语音AR游戏、语音虚拟会议等。多语言支持的拓展：AI智能语音机器人将加强对多语言的支持和翻译能力。这将使得机器人在国际交流和跨文化合作中发挥更重要的作用，帮助人们消除语言的障碍。倡导可持续发展：AI智能语音机器人的发展将更加注重可持续发展的道路。在设计和制造过程中，将更多考虑环境保护、资源利用和社会责任等因素，推动AI技术的发展与社会责任的平衡。法律和伦理问题的考量：随着AI智能语音机器人的发展，将继续涌现法律和伦理问题。如隐私保护、数据安全、责任分配等方面，需要制定相关法律法规和伦理准则，确保机器人的应用和开发符合社会的价值观和法律规定。 总结起来，2024年AI智能语音机器人的发展趋势将包括更加自然的人机交互、更广泛的应用场景、个性化服务、行业应用的深度融合、隐私和安全保护、跨平台互通、技术融合、多语言支持、可持续发展倡导以及法律和伦理问题的考量。这些趋势将进一步推动AI智能语音机器人的发展，为人们带来更智能、便捷和个性化的服务体验。同时，我们也需要在发展的过程中注重伦理和法律的约束，确保机器人的应用符合社会的价值观和法规要求。有关技术问题欢迎看博主铭一起交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12522a1ebdfc0ade0200e8a66bee9b2e/" rel="bookmark">
			【PHP】函数strpos()：判断一个字符串是否包含另一个字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		strpos 是 PHP 中的一个字符串函数，用于查找一个字符串在另一个字符串中首次出现的位置。如果找到了匹配的字符串，strpos 函数会返回匹配的第一个字符的索引值（从 0 开始），否则返回 false。
函数原型：
int|false strpos ( string $haystack, mixed $needle [, int $offset = 0 ] ) 参数说明：
$haystack：要在其中查找 $needle 的字符串。$needle：要查找的字符串。$offset：可选参数，指定从 $haystack 的哪个位置开始查找，默认为 0。 返回值：
如果找到 $needle，返回它在 $haystack 中首次出现的位置的索引值（从 0 开始）。如果 $needle 不在 $haystack 中，返回 false。 示例：
$str1 = "Hello, world!"; $str2 = "world"; // 查找 $str2 在 $str1 中首次出现的位置 $pos = strpos($str1, $str2); if ($pos !== false) { echo "找到了 $str2，它在 $str1 中的位置是 $pos"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12522a1ebdfc0ade0200e8a66bee9b2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cee7743b537c30ce1193dfc6e2981fb3/" rel="bookmark">
			Sensor Demosaic IP 手册PG286笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《 UG1449 Multimedia User Guide》中包含了大量的多媒体IP简介。
本IP 用于对bayer RGB（每个pixel只有单个R/G/B）做去马赛克处理，恢复成每个pixel点都有完整的RGB值。通过axi接口配置IP内部erg。
1、算法手册中的描述 提到了几种插值算法，并描述了IP中的处理流程。
2、reg 3、位宽及bayerRGB排列 实际使用的raw10格式，RGB每个占用10bit.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74902249eed2c502a0cfb35aa5e2d90c/" rel="bookmark">
			OpenCV-Python(21)：轮廓层次结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标 学习轮廓的层次结构，了解轮廓之间的父子关系 原理 在前面的内容中我们使用函数cv2.findContours() 来查找轮廓的时候，我们会传入一个参数:轮廓提取模式（Contour_Retrieval_Mode）。我们总是把它􄕭置为cv2.RETR_LIST 或者是cv2.RETR_TREE，效果效果还是可以得。但是它们到底代表什么呢？
同时，我们得到的结果包含3 个数组，第一个图像，第二个是轮廓，第三个是层次结构。但是我们从来没有用过层次结构。层次结构是用来干嘛的呢？层次结构与廓提取模式有什么关系呢？这将是我们将要进行学习和讨论的。
什么是层次结构 通常我们使用函数cv2.findContours 在图片中查找一个对像。有时对可能位于不同的位置，还有些情况，一个形状在另外一个形状的内部。这种情况下我们称外部的形状为父，内部的形状为子。按照这种方式分类，一幅图像中的所有轮廓之间就建立父子关系。这样我们就可以确定一个轮廓与其他轮廓是怎样连接的，比如它是不是某个轮廓的子轮廓或者是父轮廓。这种关系就成为组织结构，下图就是一个简单的例子：
在这幅图像中，我给这几个形状编号为0-5。2 和2a 分别代表最外矩形的外轮廓和内轮廓。在这里面轮廓0、1、2 在外部或最外面。我们可以称他们为(组织结构)0 级,简单来说就是他们属于同一级。 接下来轮廓2a。我们把它当成轮廓2 的子轮廓。它就成为(组织结构)第1 级。同样,轮廓3是轮廓2 的子轮廓，成为(组织结构)第3 级。最后轮廓4,5 是轮廓3a 的子轮廓，成为（组织结构）第4 级（最后一级）。按照这种方式给这些形状编号，我们可以说廓4 是轮廓3a 的子轮廓，当然轮廓5 也是。我说这么多就是为了解释层次结构、外轮廓、内轮廓、父轮廓、子轮廓等。
OpenCV 中层次结构 不管层次结构是什么样的，每一个轮库包含自己的信息：谁是父，谁是子等。OpenCV 使用一个含有四个元素的数组表示。[Next，Previous，First_Child，Parent]。
Next 示同一级组织结构中的下一个轮廓。
以上图中的轮廓0 为例，轮廓1 就是他的Next。同样轮廓1 的Next是2，Next=2。那么轮廓2 呢，在同一级没有Next。此时Next=-1。而轮廓4 的Next为5，所以它的Next=5。
Previous 表示同一级结构中的前一个轮廓。
与前面一样，轮廓1 的Previous 为轮廓0，轮廓2 的Previous 为轮廓1。轮廓0 没有Previous，所以Previous=-1。
First_Child 表示它的第一个子轮廓。
没有必要再解释了，轮廓2 的子轮廓为2a。所以它的First_Child 为2a。那么廓3a 呢，它有两个子轮廓。但是我们只要第一个子轮廓，所以是轮廓4(按照从上往下/从左往右的顺序排序)。
Parent 表示它的父轮廓。
与First_Child 刚好相反。轮廓廓4 和5 的父轮廓是轮廓3a。而轮廓3a的父轮廓是3。
轮廓检索模式 我们上面了解了OpenCV 中的轮廓廓组织结构。下面我们还是根据上面的图片再学习一下轮廓检索模式cv2.RETR_LIST,cv2.RETR_TREE,cv2.RETR_CCOMP,cv2.RETR_EXTERNAL到底代表什么意思？
RETR_LIST 从解释的角度来看，这应该是最简单的。它只是提取所有的轮廓，而不去创建任何父子关系。换句话说，就是人人平等，它们属于同一级组织轮廓(如果你不关心轮廓之间的关系，这是一个非常好的选择)。所以在这种情况下，组织结构数组的第三和第四个数都是-1。但是很明显，Next 和Previous 应有对应的值。
下面就是我得到的结果，每一行是对应轮廓的组织结构细节。例如，第一行对应的是轮廓0。下一个轮廓为1，所以Next=1。前面没有其他的轮廓，所以Previous=0。接下来的两个参数是-1，与刚才我们说的一样。
RETR_EXTERNAL 如果你选择这种模式的话，只会返回最外层的轮廓，所有的子轮廓都会被忽略掉。(当你只想得到最外面的轮廓时，你可以用这种模式，在有些情况下很有用)所以在上图中使用这种模式的话，只会返回最外层的轮廓(第0 级),轮廓廓0、1、2。下面是我选择这种模式得到的结果:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74902249eed2c502a0cfb35aa5e2d90c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c290fb2a248ec777f45a2ec9064f670/" rel="bookmark">
			浅谈C&#43;&#43;20 协程那点事儿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是 C++20 的协程入门文章，作者围绕协程的概念到协程的实现思路全方位进行讲解，努力让本文成为全网最好理解的「C++20 协程」原理解析文章。
协程概念 浅谈C++20 协程那点事儿 先介绍一点协程的概念，如果你已经理解和掌握了相关的背景知识就可以跳过这个章节（或者快速浏览下，也许我们有些观念不一致可以讨论）。这里我想稍微聊的深入一点，这涉及到入门后遇到复杂的协程问题时能不能正确的理解并解决问题。
协程（Coroutines），也被称为微线程，纤程。一般指一个可以被暂停和恢复执行的逻辑体。
一个普通的函数有 2 个常规的操作和行为：调用（Call）和返回（Return）。当调用这个函数的时候，会暂停当前的执行，跳转到这个函数的起始位置去执行。当函数执行完成后会返回结果（或者抛出异常）。
这个调用过程通常是“一次性”的，再次调用这个函数又是一次独立的行为。
但是协程不是，协程的操作和行为是：
调用/创建（Create）、暂停/挂起（Suspend）、 恢复执行（Resume）和销毁（Destroy）。
协程可以允许这个被调用的函数执行到某个位置之后暂时保留自己的临时信息并挂起。
在后面的某个时间点可以再回到当时执行的位置和状态继续执行。
所以从某种意义上可以说协程是普通函数的泛化（Generalisation）。
当一个程序开始执行时，操作系统会创建出一个进程，操作系统内核里也会创建出一个调度实体（一个记录这个进程相关信息的数据结构），然后跳转到这个程序的代码入口去执行。
同一时间操作系统往往同时在执行很多个进程。这些进程在真实的多核 CPU 上并行或者轮流执行（当进程数大于 CPU 核数时排队）。操作系统负责对这些调度实体进行监控、统计、切换等一切调度工作。一个进程通常只有一个常规的执行流（主线程），对应到 C/C++ 语言里就是一个串行执行的main()函数，main()函数里会调用其他函数。
其他函数可能继续调用另外的函数，最终main()函数执行完成后进程退出。当一个进程执行代码时，CPU 的寄存器保存着当前函数的执行状态，临时结果等信息。如果要调用新的函数，那么需要把当前部分寄存器的值保存在内存里再去调用新的函数（因为新的函数也会使用这些寄存器进行运算）。
那么哪些寄存器需要保存？传递给新函数的参数放在哪里？调用完的返回值保存在哪里？
调用约定（Calling Conventions）规定了这些细节。本文不详细调用约定的细节，有兴趣的话可以阅读参考文献 [1]。
在 AMD64/x86_64 架构下，函数调用使用栈（Stack）来实现，每个函数使用的栈区域称之为一个栈帧（Stack Frame）。下面展示一段代码和其执行时对应的栈状态：
当代码执行到main()-&gt;func1()-&gt;func2()的时候，内存栈是如图的形式。新的函数调用会使得栈空间向上增长为新函数创建栈帧，创建局部变量以及保存之前函数使用的寄存器。
函数调用返回后，栈帧就会被回收，同时从栈里恢复出之前的寄存器值并跳转到之前执行的代码地址（所以 C/C++代码里不能返回函数局部变量的指针，因为函数返回后再访问被回收的栈帧是很危险的，这些空间随后就被其他函数的临时数据覆盖了）。
随着函数的调用和返回，栈不断的增大和缩小。这个栈默认有多大？在 Linux 系统上执行ulimit -s就能看到默认的值是 8192 KB。如果程序里定义了过大的函数局部变量或者函数调用深度太长（尤其是递归），就有栈溢出的风险。
与栈相对的内存区域是堆，一般在程序运行时使用brk(2)或者mmap(2)进行分配，C/C++程序里使用的malloc(3)/free(3)或者new/delete（只讨论内存分配的语义部分）分配一般是 CRT 的封装（或者jemalloc之类的内存分配库）。
堆内存区域不随着函数调用结束而自动回收，需要程序自行在使用完成后进行显式的释放动作。本质上堆、栈只是内存逻辑上的概念，只是创建时机和使用方式的不同而已，并无本质区别。
如果逻辑上一个程序需要更多的执行流，可以创建线程来并发地执行另一个函数。这里的线程通常是操作系统支持的概念，对应内核的一个调度实体，可以在不同的 CPU 核上和主线程并行的执行。操作系统内核在什么时候进行任务调度呢？
自然是执行流跳转到内核代码的时候，除了系统调用会陷入内核额外触发调度外，还需要硬件时钟中断强行中断当前执行的程序来切换到内核逻辑来兜底（否则一个在用户态死循环的程序岂不是永远不交出执行权了）。这个创建的线程跟主线程一样，拥有一个完全独立的线程栈去进行自身函数调用的状态保存。
铺垫了这么多，那协程究竟是什么？前文提到协程函数的操作和行为有：调用/创建（Create）、暂停/挂起（Suspend）、恢复执行（Resume）和销毁（Destroy）。
创建和销毁比较好理解，创建线程也是有这 2 个步骤。多出来的挂起和恢复操作，是因为这个执行逻辑完全是在用户态模拟出来的，不存在一个内核的调度实体，那么自然需要在用户态去管理这些执行流的挂起和恢复执行。如果你熟悉 Linux 线程发展史的话，你会知道在 Linux 内核支持线程概念前，用户态模拟出的多个可以切换的“线程”其实就是协程的一种实现。
在多线程编程里，一般不在线程里添加主动切换的逻辑，往往都是被动的被内核从执行状态转换为等待状态，比如 IO 操作未完成，尝试获取的资源暂时被强占的时候（最多就是调用某些系统调用告诉内核自己暂时让出 CPU，让内核看看要不要执行别的任务）。但协程不是，协程需要用户逻辑在后续执行条件不满足的时候主动切换让出执行权。
这里姑且将这种协程称之为第一代协程，其仅仅是线程等概念在理论上的推演。而广义的协程（Coroutines）是个很宽泛的概念。尤其是async/await语义带来了新的浪潮之后。这几年新的编程语言里引入的协程模型几乎都是async/await语义的（除了 go 语言 😁）。本文不考古async/await概念在微软的发展历史，有兴趣的话可以参阅相关资料。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c290fb2a248ec777f45a2ec9064f670/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6881add97d162774cd56e856e42a3d05/" rel="bookmark">
			监控设备IP地址是如何设置的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在如今科技日新月异的时代，监控设备的应用越来越广泛。无论是家庭、商业还是公共场所，安装监控设备已成为一种常见的安全防范措施。而要使监控设备正常运行，其中关键的一步就是设置监控设备的IP地址。
首先，我们来了解一下什么是IP地址。IP地址是指互联网协议地址，是一个由数字和点组成的标识符，用于唯一标识网络上的设备。在监控设备中，IP地址的设置是通过网络实现设备间的通信、数据传输和远程访问的重要手段。
那么，监控设备的IP地址一般是多少呢？实际上，监控设备的IP地址并没有固定的范围，而是根据网络的设置和需求而定。一般情况下，监控设备的IP地址可以是私有IP地址，也可以是公有IP地址。
私有IP地址是指在局域网中使用的IP地址，用于内部设备间的通信。常见的私有IP地址段有：192.168.0.0~192.168.255.255、172.16.0.0~172.31.255.255、10.0.0.0~10.255.255.255。当监控设备被部署在一个私有网络中时，可以根据需要从这些范围中选择一个合适的IP地址。
而公有IP地址则是指在公共互联网中使用的IP地址，用于设备与外部网络的通信。公有IP地址是由互联网服务提供商(ISP)分配的，通常需要进行申请和付费。如果你的监控设备需要从外部网络访问或与外部设备进行通信，就需要配置一个唯一的公有IP地址。
此外，为了方便监控设备的管理和访问，还可以设置专用的端口号。端口号是用于识别不同服务或应用程序的标识符，常见的监控设备端口号有：80(HTTP)、443(HTTPS)、554(RTSP)等。通过设置不同的端口号，可以实现不同的功能或服务访问。
综上所述，监控设备的IP地址是根据网络设置和需求而定的，可以是私有IP地址或公有IP地址。为了方便管理和访问，还可以设置专用的端口号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adfa72ba488c72dfac288939b77806a4/" rel="bookmark">
			C&#43;&#43;协程和线程的区别？详细介绍一下C&#43;&#43;协程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++协程和线程的区别 线程是操作系统级别的资源，由操作系统负责调度和切换，每个线程都有自己的堆栈和执行上下文。线程之间的切换需要保存和恢复线程的执行上下文，这个过程有一定的开销。协程是用户态的轻量级线程，协程的调度完全由用户控制，一个线程可以拥有多个协程，协程之间的切换不需要操作系统的干预，因此开销更小。协程也有自己的堆栈和执行上下文，但是协程的堆栈是动态分配的，可以根据需要增长或缩小，协程的执行上下文是保存在协程状态中的，协程状态是分配在堆上的内部对象。线程是同步机制，即线程在执行过程中如果遇到阻塞，比如IO操作，就会让出CPU，等待阻塞结束后再继续执行。这样会导致线程的资源浪费和调度开销的增加。线程之间如果要共享数据，还需要使用锁机制来避免竞争和冲突，这也会增加复杂度和开销。协程是异步机制，即协程在执行过程中可以主动挂起，让出CPU，然后在适当的时候再恢复执行。这样可以避免无意义的等待和切换，提高CPU的利用率。协程之间如果要共享数据，不需要使用锁机制，只需要判断状态就可以了，这也会降低复杂度和开销。 C++协程的基本概念和用法 C++协程是在C++20标准中引入的一个新特性，目的是为了简化异步编程的模式，提高性能和效率。C++协程的实现主要依赖于三个新的关键字：co_await, co_yield, co_return，以及一些新的类型和库函数。C++协程是一种特殊的函数，它的返回类型必须是一个有promise_type成员类型的类型，比如std::future, std::generator, std::task等。这个promise_type类型是一个承诺对象，它负责生成协程函数的返回对象，提交协程的结果或异常，以及控制协程的启动和终止行为。C++协程可以使用co_await关键字来调用一个等待体对象，根据其内部定义决定其操作是挂起还是继续，以及挂起和恢复时的行为。等待体对象必须有await_ready, await_suspend, await_resume三个成员函数，或者重载了operator co_await的类型。一般而言，等待体对象可以表示一个异步操作，比如网络IO，文件读写，定时器等。C++协程可以使用co_yield关键字来挂起协程，并且产生一个值，这个值会保存在承诺对象中，通过yield_value函数。在协程外部可以通过承诺对象得到这个值。这个机制可以用来实现生成器，即按需产生值的函数。C++协程可以使用co_return关键字来终止协程，并且返回一个值，这个值会保存在承诺对象中，通过return_value函数。在协程外部可以通过承诺对象得到这个值。这个机制可以用来实现异步函数，即返回一个未来值的函数。C++协程的唯一标识是协程句柄，它是一个std::coroutine_handle模板类的实例，它可以用来恢复或销毁协程。协程句柄可以通过承诺对象的get_return_object函数或者from_promise静态函数得到。协程句柄还可以访问协程状态，即保存协程的上下文和数据的对象。 以下是一个简单的C++协程的例子，实现了一个生成斐波那契数列的函数：
#include &lt;iostream&gt; #include &lt;coroutine&gt; // 定义一个生成器类型，用于返回协程函数的对象 template&lt;typename T&gt; struct generator { // 定义一个承诺类型，用于控制协程的行为 struct promise_type { // 保存协程产生的值 T value; // 生成协程函数的返回对象 generator get_return_object() { // 从承诺对象中获取协程句柄 return generator{ std::coroutine_handle&lt;promise_type&gt;::from_promise(*this) }; } // 表示协程启动后不立即挂起 std::suspend_never initial_suspend() { return {}; } // 表示协程终止后不再恢复 std::suspend_never final_suspend() noexcept { return {}; } // 处理协程的返回值 void return_void() {} // 处理协程的异常 void unhandled_exception() { std::terminate(); } // 保存协程的产生的值 std::suspend_always yield_value(T val) { value = val; return {}; } }; // 保存协程句柄 std::coroutine_handle&lt;promise_type&gt; handle; // 构造函数，从协程句柄初始化 explicit generator(std::coroutine_handle&lt;promise_type&gt; h) : handle(h) {} // 析构函数，销毁协程 ~generator() { if (handle) { handle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adfa72ba488c72dfac288939b77806a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b901b7793c292499de22d8d3d1b8c1/" rel="bookmark">
			mysql保姆安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：考完研回来，重新配置数据库的相关环境，按照本方法安装请确保你之前的MySQL已完全清除干净。
一.下载install文件 1.进入Mysql官网，点击下载
2.选择MySQL Installer for Windows
3.推荐选择第二个安装包
4.不登陆，开始下载
5.等待下载完成 二.安装前的配置 通过电脑“设置”，检查电脑是否包含中文名，如果包含请重命名
三.安装过程 1.双击刚刚下载的文件，等待开始，出现下面情况
2.挨个点击前三个选项后选择back返回，最后选择custom
3.挨个点击右边的每个组件，选择安装路径
注意这里的位置不要选择你已经存在的文件夹，最好的办法就是把前缀C改成D。4.点击next5.点击Execute进行安装
6.一路next到如下配置界面
7.next到密码配置阶段
如果后续使用navicat等软件连接Mysql请选择推荐选项，如果不使用请选择后面选项。
8.一路next直到下面，选择Execute
9.点击finish完成配置10.next输入密码进行验证
11.验证通过后继续执行，后选择finish
12.后续全部选择next或finish。 四.环境变量配置 1.验证存在mysql 在MySQL的bin文件下打开终端，输入mysql -u root -p后输入密码，弹出如下界面
注意：尽量使用win+R输入cmd，用管理员权限打开，后切换到该目录下，如果直接在原目录下打开终端 ，可能会报错。 2.验证mysql版本 1.输入quit退出mysql2.输入mysql --version 3.配置环境变量 1.收获环境变量2.选择path3.点击新建，粘贴好地址4.一路确定返回 4.验证环境变量配置成功 在任意路径下输入mysql -u root -p后输入密码，即可进入数据库
参考视频：mysql保姆视频
五.navicat连接MySQL 1.打开navicat，点击连接，选择mysql
2.连接名任意写，密码填你刚刚设置的密码，
3.测试连接-&gt;确定，即连接成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/405979eeb3f54e6ac635b04a6c275697/" rel="bookmark">
			YOLO-NAS姿态简介：姿态估计技术的飞跃
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文 | BFT机器人 YOLO-NAS姿态模型是对姿态估计领域的最新贡献。今年早些时候，Deci凭借其开创性的物体检测基础模型YOLO-NAS获得了广泛认可。在YOLO-NAS成功的基础上，该公司现在推出了YOLO-NAS Pose作为其姿态估计的对应产品，这种姿势模型在延迟和准确性之间提供了很好的平衡。
YOLO-NAS姿势
姿态估计在计算机视觉中起着至关重要的作用，涵盖了广泛的重要应用。这些应用包括监测医疗保健中的患者运动、分析运动员在运动中的表现、创建无缝的人机界面以及改进机器人系统。
01 YOLO-NAS姿态模型架构
2.1 基于规划空间的分类及特点
传统的姿态估计模型遵循以下两种方法之一：
检测场景中的所有人物，然后估计其关键点并创建姿势，自上而下的两阶段过程；
检测场景中的所有关键点，然后生成姿势，自下而上的两阶段过程。
YOLO-NAS Pose与传统的Pose Estimation模型相比，其工作方式有所不同。它不是先检测人，然后估计他们的姿势，而是可以在一个步骤中同时检测和估计人及其姿势。
YOLO-NASPose架构–骨干和颈部设计
姿势模型建立在YOLO-NAS目标检测架构之上，目标检测模型和姿态估计模型具有相同的脊柱和颈部设计，但头部不同。YOLO-NAS Pose的头部专为其多任务目标而设计，即检测单个类别的物体（如人或动物）并估计物体的姿势。
YOLO-NAS Pose架构–头部设计
这种令人印象深刻的组合是Deci专有的神经架构搜索（NAS）引擎AutoNAC的结果，它在广阔的架构搜索空间中导航并返回最佳架构设计。以下是搜索的超参数：
姿势和框回归路径的Conv-BN-Relu块数；
两条路径的中间通道数；
在姿势/框回归的共享词干或不同词干之间做出决定。
YOLO-NASPose模型在COCOVal2017数据集上进行评估，该模型的准确性和延迟是最先进的。nano模型速度最快，在T4GPU上达到高达425fps的推理速度，同时大模型可以达到113fps。
COCOVal2017数据集上的YOLO-NAS姿态评估
02 YOLO-NAS与YOLOv8姿势
2.1 基于规划空间的分类及特点
下图是YOLO-NAS Pose和YOLOv8Pose模型的精度延迟权衡。这个空间也被称为效率前沿。所有模型均在COCOVal2017数据集和英特尔至强第四代CPU上进行评估，具有1个批处理大小和16位浮点运算。
YOLO-NAS姿势与YOLOv8姿势高效前沿图
所有YOLO-NAS Pose模型的精度都高于YOLOv8 Pose模型，这可以被认可到AutoNAC的头部设计中，具体的细节是：
较小的YOLO-NAS Pose模型，即nano和small，虽然精度更高，但比YOLOv8Pose模型慢。
较大的YOLO-NAS Pose型号，如中型和大型，在准确性和延迟方面都更好。
03 姿势模型是如何训练的？
2.1 基于规划空间的分类及特点
YOLO-NAS姿态损失功能
为了确保模型有效地学习这两个任务，Deci改进了训练中使用的损失函数。我们不仅考虑了分配框的IoU（交集与并集）分数，还合并了对象关键点相似性（OKS）分数，该分数将预测的关键点与实际的关键点进行比较，此更改鼓励模型对边界框和姿态估计进行准确预测。
此外，还采用了直接OKS回归技术，超越了传统的L1/L2损失方法，这种方法具有以下几个优点：
它在0到1的范围内运行，类似于框IoU，表示姿势的相似程度。
它考虑了注释特定关键点的不同难度，每个关键点都与唯一的sigma分数相关联，该分数反映了注释和数据集细节的准确性，分数决定了模型因做出不准确的预测而受到的惩罚程度。
使用与验证指标一致的损失函数，这反过来又允许对指标进行定位和优化。
YOLO-NAS姿态估计
训练超参数
由于YOLO-NAS Pose采用了与YOLO-NAS模型类似的基础结构，因此在进行最终训练之前，使用YOLO-NAS的预训练权重来初始化模型的骨架和颈部。以下是训练超参数：
训练硬件：使用了8个NVIDIAGeForceRTX3090GPU和PyTorch2.0。
培训计划：培训进行了长达1000个epoch，如果在过去100个epoch中表现没有改善，则提前停止。
优化器：采用具有余弦LR（学习率）衰减的AdamW，在训练结束时将LR降低0.05倍。
权重衰减：应用了0.000001的权重衰减因子，不包括偏差层和BatchNorm层。
EMA（指数移动平均线）衰减：使用50的beta因子进行EMA衰减。
图像分辨率：图像经过处理后，最大边长为640像素，填充分辨率为640×640，填充颜色为（127，127，127）。
若您对该文章内容有任何疑问，请与我们联系，我们将及时回应。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4359dc89eef3c9b3b456c9ee16021ff9/" rel="bookmark">
			OpenAI“一路生花”，致力于超级人工智能研发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创 | 文 BFT机器人 INTELLIGENT ROBOT
OpenAI提供1000万美元的资助用于解决超级智能AI控制问题
OpenAI是人工智能研究领域的领先组织，据媒体称，它正在采取积极措施应对与超级智能AI系统相关的潜在风险。在一项大胆的举措中，该公司宣布将提供1000万美元的资助，以支持技术研究，重点是确保对超越人类智能的人工智能系统进行安全和道德控制。
INTELLIGENT ROBOT
Superalignment fast授予对AI Alignment的追求
OpenAI已经启动了所谓的“Superalignment Fast Grants”计划，以推进如何调整未来超级AI系统的研究。目标是防止这些高度先进的人工智能系统反扑人类或对人类社会造成伤害。这些赠款旨在支持学术界、非营利组织的研究团队以及致力于解决人工智能关键性问题和拥有挑战心理的个人研究人员。
OpenAI在一个研究博客上的一份声明中强调了解决这个问题的紧迫性，并指出：弄清楚如何确保未来的超级AI系统保持一致和安全是世界上最重要的未解决的技术问题之一。但OpenAI内部认为这是一个可以解决的问题，有很多现成的研究经验和成果可以供大家参考，之后研究人员可以再推进新一个阶梯。因此关于未来超级AI系统的这项研究，成功与否在OpenAI看来只是时间长短的问题。
INTELLIGENT ROBOT
人工智能控制的未来正在超越人类的监督
当前的人工智能系统严重依赖人类的监督和干预来有效运行。然而，随着人工智能技术的进步和超级智能人工智能即将成为可能，它同样也引发了人们的担忧，即仅靠人类监督是否足以控制这些系统呢？OpenAI对此所采取的方法旨在寻找创新方法，让人类能够保持对比实际上智能得多的AI系统的有效控制。
INTELLIGENT ROBOT
对于研究人员和研究生的支持
OpenAI不仅向成熟的研究机构提供资助，还赞助了为期一年的150,000美元的 OpenAI Superalignment Fellowship，旨在支持在这一关键领域进行研究的研究生。这表明该公司致力于培养下一代人工智能研究人员，并促进该领域专家之间的合作。
INTELLIGENT ROBOT
人工智能安全的七项实践
虽然今天的人工智能工具带给人类很多惊喜，但它们还没有达到OpenAI所期望的超级智能水平。超级人工智能将大大超越人类的能力，如果控制不当，可能会带来重大的危害。OpenAI的首席执行官山姆·奥特曼暗示将开发的GPT-5，这是一种可能具有超级智能元素的模型。OpenAI预计，超级智能可能在未来十年内成为现实。
INTLLIGENT ROBOT
OpenAI研究资助的影响
OpenAI的Superalignment Fast Grants和Agentic AI Research Grants的“重大计划”影响将在塑造人工智能的未来方面发挥至关重要的作用。随着人工智能技术的不断进步，超级智能人工智能系统的负责任开发和控制变得至关重要。这些研究计划的成功与否可能决定了未来几年社会如何制定应对超级智能的到来办法的决定性因素。
OpenAI致力于应对超级智能AI系统带来的挑战是值得称赞的。通过向研究人员和研究生提供大量赠款和奖学金，该组织正在培养一种协作和积极向上的方法，以实现人工智能的一致性和安全性。随着人工智能技术的发展，这些研究工作的结果可能是确保人工智能安全和负责任的未来的关键。超级智能出现的时间表仍然不确定，但OpenAI致力于寻找解决方案是为这个变革时代做准备的重要一步。
若您对该文章内容有任何疑问，请与我们联系，将及时回应。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48777bd838cc27e0629136b5562d87cf/" rel="bookmark">
			PADS的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、PADS基础1.1 常用快捷键1.2 PADS Logic相关设置1.3 PADS Layout相关设置1.4 PADS Router相关设置 二、库文件制作2.1 逻辑库2.2 封装库2.3 元件库 三、Logic原理图操作四、Layout PCB操作4.1 元件导入4.2 添加板框4.3 PCB布局4.4 规则设置4.5 布线覆铜 五、PCB Router操作5.1 打开Router5.2 Router布线5.3 敷铜与扇孔 六、PCB最后处理6.1 DRC检查6.2 装配图PDF6.3 Gerber文件6.4 IPC网表 一、PADS基础 PADS安装好了之后，主要使用下面三个软件：
Logic：原理图操作软件Layout：PCB布局软件工具，手动的地方比较多，保护相对少一些Router：PCB元器件布局，自动布线软件工具 1.1 常用快捷键 点击鼠标滚轮，向上放大，向下缩小界面。可以用Ctrl+滚轮放大缩小
快捷键功能W布线宽度Q快速测量U切换单位G设计栅格设置T透明显示切换N高亮网络O切换PCB上元素透明显示L + 层切换不同的板层Z*设置和获取当前层GD显示栅格设置SS检索并选中元件参数名SO设置原点PO解除敷铜DO显示过孔内层AA/AD/AO走线角度设置：任意角度、45度、90度HC\HH\HP\HR绘制：圆形、路径、多边形、矩形F2布线layoutF3连线routerF4换层，会自动加焊盘Ctrl+S保存Ctrl+L对齐元器件Ctrl+I任意角度旋转元件Ctrl+F元器件翻面 (镜像)Ctrl+E移动Ctrl + H进行高亮同一网络Ctrl + U取消高亮Ctrl+A全选Ctrl+Q打开元件属性Ctrl+R旋转90度Ctrl+B将整个PCB区域置于屏幕可视范围内Ctrl+Tab切换 Power 形状Ctrl+Enter进入选项设置Ctrl + Alt + C层颜色设置，显示参数设置Ctrl + Alt + F调用Filter工具Ctrl + 鼠标左键结束走线Alt+Enter元器件特性的快捷键Alt+B翻转180度，切换顶、底层视图连线时Shift+左键添加过孔Shift + S移动走线router/修线LayoutTab切换选择/旋转器件 注意：Layout组件内使用无模命令可以不用空格，如G5；Router组件内使用需要添加空格，如G 5
1.2 PADS Logic相关设置 菜单栏空白处右击可以选择工具栏
工具-&gt;选项，进入选项设置
首先常规设置，主要是栅格设置最好是50的倍数，且与显示栅格一致，栅格就是移动元件的最小距离。然后就是一个备份文件，PADS运行可能崩溃，可以找到之前的文件。
然后是设计，主要是页面大小打印参考，还有下面的勾选
设置-&gt;显示颜色，可以根据喜好设置背景和元素颜色
1.3 PADS Layout相关设置 点击工具-&gt;选项，打开选项设置，对全局里的常规和备份进行如下设置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48777bd838cc27e0629136b5562d87cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d2a95da754ed3a836b391ddcfb0f47f/" rel="bookmark">
			Apache简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache是一款非常有名的应用软件。它是世界上使用最广泛的Web服务器应用程序，在商业Web服务器市场中占有超过50％的份额。 Apache是类Unix操作系统中使用最广泛的Web服务器应用程序，但几乎可用于所有平台，如Windows，OS X，OS / 2等.Aracle这个词取自Native的名称 美国部落’阿帕奇’，以其在战争和战略制定方面的技能而闻名。
它是一个基于流程的模块化Web服务器应用程序，它通过每个同时连接创建一个新线程。 它支持许多功能; 其中许多都被编译为单独的模块并扩展其核心功能，并且可以提供从服务器端编程语言支持到身份验证机制的所有功能。 虚拟主机就是这样一种功能，它允许单个Apache Web服务器为许多不同的网站提供服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b0e472a577a101c680cc26b993c965c/" rel="bookmark">
			css动态传参，attr的妙用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天再做一个编辑器的功能的时候，发现有一段非常奇妙的代码，使用attr获取div标签的data-label值。
css的attr?What fuck?这又是什么鬼东西，emmm。
查询后官方是这么回答的：
CSS 表达式 attr() 用来获取选择到的元素的某一 HTML 属性值，并用于其样式。它也可以用于伪元素，属性值采用伪元素所依附的元素。
属性函数 attr() 目前暂时只能应用于CSS元素中的伪元素（before,after）。
好，学废了！
下面就来模仿这个编辑器，做一个改变字体大小的实例吧。
&lt;style&gt; .main { float: left; cursor: pointer; } .selectItemTitle { border: 1px solid #ccc; } .selectOptions { border: 1px solid #ccc; display: none; } .main:hover .selectOptions { display: block; } .testText { float: left; margin-left: 20px; } .selectItemTitle:before { content: 'Normal'; } .selectItemTitle[data-value]:not([data-value='']):before { content: attr(data-value); } .selectItem[data-value]:not([data-value='']):before { content: attr(data-value); } &lt;/style&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b0e472a577a101c680cc26b993c965c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84eb205b649093a02ba13f0ea84ebb1a/" rel="bookmark">
			洛谷P2895 Meteor Shower S（流星雨）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 贝茜听说一场特别的流星雨即将到来：这些流星会撞向地球，并摧毁它们所撞击的任何东西。她为自己的安全感到焦虑，发誓要找到一个安全的地方（一个永远不会被流星摧毁的地方）。
如果将牧场放入一个直角坐标系中，贝茜现在的位置是原点，并且，贝茜不能踏上一块被流星砸过的土地。
根据预报，一共有 M 颗流星 (1≤M≤50,000) 会坠落在农场上，其中第 i 颗流星会在时刻 Ti​（0≤Ti​≤1000）砸在坐标为(Xi​,Yi​)(0≤Xi​≤300，0≤Yi​≤300) 的格子里。流星的力量会将它所在的格子，以及周围 4 个相邻的格子都化为焦土，当然贝茜也无法再在这些格子上行走。
贝茜在时刻 0 开始行动，她只能在第一象限中，平行于坐标轴行动，每 1 个时刻中，她能移动到相邻的（一般是 4 个）格子中的任意一个，当然目标格子要没有被烧焦才行。如果一个格子在时刻 t 被流星撞击或烧焦，那么贝茜只能在 t 之前的时刻在这个格子里出现。 贝茜一开始在 (0,0)。
请你计算一下，贝茜最少需要多少时间才能到达一个安全的格子。如果不可能到达输出 −1。
输入格式 共 M+1 行，第 1 行输入一个整数 M，接下来的 M 行每行输入三个整数分别为 Xi​,Yi​,Ti​。
输出格式 贝茜到达安全地点所需的最短时间，如果不可能，则为 −1。
输入输出样例 输入 #1
4 0 0 2 2 1 2 1 1 2 0 3 5 输出 #1
5 看题目很容易想到用bfs，然而与其他题目不同的是，这里某些点不是一来就不可以走的，而是要根据流星落下的时间来判断，在流星落下之前可以走，落下之后就不能走了。
解题思路
我们可以使用三个二维数组分别储存
1.每一个点流星最早落下的时间（注意：一个点可能有多个流星落下，只需要取最早落下的时间就可以了）
2.这个点是否已经走过（避免多次到达同一个点）
3.这个点是否有流星落下（用来寻找安全点）
对于一个点是否能够到达只需要比较
这题主要有3个容易出错的点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84eb205b649093a02ba13f0ea84ebb1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90bb6cc55627783bdabebdee73de31f/" rel="bookmark">
			CSS 丝带形状效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS 丝带形状效果如图： 通过CSS创建折叠丝带形状 这里代码应该比较清晰易懂，clip-path 的值应该也容易理解。要注意的是，我们使用了 color-mix()
函数，这个属性允许创建主颜色的深色版本。现在如果我们将元素旋转相反的方向，就会得到旋转的 CSS 丝带形状。
完整代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;CSS 丝带形状&lt;/title&gt; &lt;style&gt; @property --a { syntax: "&lt;angle&gt;"; initial-value: 0deg; inherits: true; } h1 { --r: 30px; --a: 15deg; --c: #384cff; line-height: 1.6; padding-inline: .5lh; color: #fff; background: linear-gradient(calc(90deg + var(--a)), #0000 calc(1lh*sin(var(--a)) - 1px), var(--c) calc(1lh*sin(var(--a))) calc(100% - 1lh*sin(var(--a))), #0000 calc(100% - 1lh*sin(var(--a)) + 1px)); position: relative; rotate: calc(-1*var(--a)); transform-style: preserve-3d; transition: --a .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f90bb6cc55627783bdabebdee73de31f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/483594aa1fcae45713320228e8373132/" rel="bookmark">
			GLTF 编辑器实现逼真3D动物毛发效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线工具推荐： 3D数字孪生场景编辑器 - GLTF/GLB材质纹理编辑器 - 3D模型在线转换 - Three.js AI自动纹理开发包 - YOLO 虚幻合成数据生成器 - 三维模型预览图生成器 - 3D模型语义搜索引擎 要实现逼真的3D动物毛发效果，可以采用以下技术和方法：
毛发建模：使用专门的3D建模软件，根据动物的解剖结构和毛发生长方向，创建具有细节的毛发模型。这可通过将细分曲面、细分器或毛发插件应用于基本形状来实现。
毛发分布和动态：为模型指定头部、身体和四肢等区域的毛发分布，并根据毛发生长特性确定其长度和密度。考虑到真实世界中毛发的动态效果，可以使用物理模拟技术（如动力学模拟）来模拟毛发的自然运动，例如在行走或风吹时的摆动。
毛发渲染：为了呈现逼真的毛发光线反射和阴影效果，需要使用合适的渲染引擎和材质属性。常用的渲染技术包括基于物理的渲染（PBR）和毛发着色器。使用这些技术可以模拟出毛发的光泽度、透明度和散射等视觉效果。
着色和纹理：为模型的毛发添加适当的颜色和纹理，以与目标动物的真实毛发相匹配。可以使用贴图、颜色渐变或生成程序化纹理来实现。
光照和阴影：为了增加毛发￥￥真度，需要考虑光源对毛发的影响，并使用合适的灯光设置来产生适当的明暗和阴影效果。这可以帮助毛发更好地融入场景环境中。
粒子系统和优化：对于大量的细小毛发，可以使用粒子系统来快速生成并调整毛发模型。此外，为了提高渲染和计算性能，可以采用优化技术，例如级别细节（LOD）或简化几何体等。
毛发后期处理：在渲染完成后，还可以通过后期处理来进一步提升毛发效果。这包括调整颜色、对比度、亮度等参数，使毛发看起来更加自然和栩栩如生。
本文将讲解如何使用GLTF 编辑器 -NSDT 在线材质编辑工具为动物3D模型设置逼真的毛发效果，在开始之前我们先了解下纹理里纹理贴图的一些基本概念。
GLTF编辑器支持GLTF/GLB在线预览、材质编辑、重置原点、以及模型轻量化（将相同材质Mesh合并）。GLTF editor supports GLTF/GLB online preview, material editing, reset origin, and model lightweight (merging the same material Mesh)
1、材质纹理贴图 1：没有纹理的 3D 模型2：带纹理的相同模型
纹理贴图是应用于（映射）到形状或多边形表面的图像。这可以是位图图像或程序纹理。它们可以以常见的图像文件格式存储，由 3D 模型格式或材料定义引用，并组装成资源包。
它们可能有 1-3 个维度，尽管 2 个维度对于可见表面最常见。为了与现代硬件一起使用，纹理贴图数据可以以旋转或平铺顺序存储，以提高缓存一致性。渲染 API 通常将纹理贴图资源（可能位于设备内存中）作为缓冲区或表面进行管理，并且可能允许“渲染到纹理”以获得其他效果，例如后期处理或环境映射。
它们通常包含 RGB 颜色数据（存储为直接颜色、压缩格式或索引颜色），有时还包含用于 alpha 混合 （RGBA） 的附加通道，尤其是对于广告牌和贴花叠加纹理。可以将 alpha 通道（以硬件解析的格式存储可能很方便）用于其他用途，例如镜面反射。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/483594aa1fcae45713320228e8373132/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e0bb3c869e42ac7b40d1432cd613101/" rel="bookmark">
			写实风格3D模型材质贴图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线工具推荐： 3D数字孪生场景编辑器 - GLTF/GLB材质纹理编辑器 - 3D模型在线转换 - Three.js AI自动纹理开发包 - YOLO 虚幻合成数据生成器 - 三维模型预览图生成器 - 3D模型语义搜索引擎 写实3D模型的制作过程包括建模、材质贴图、灯光设置和渲染等步骤。首先，艺术家使用特定的建模软件创建基本的几何形状，并对其进行细节的雕刻和调整，使之与真实世界中的对象更加相似。其次，通过为模型添加材质贴图，艺术家可以模拟出物体表面的纹理、色彩和反射等效果。然后，设置合适的灯光效果是制作写实3D模型非常重要的一步，它能够营造出逼真的阴影、光照和光线效果。最后，通过渲染引擎将模型渲染成最终的图像或动画，呈现出细腻、逼真的效果。
写实3D模型具有许多应用价值。在电影和游戏产业中，它们可以创造栩栩如生的角色、场景和特效，提升视觉效果和沉浸感。在建筑和工程领域，写实3D模型可以帮助设计师和客户直观地了解建筑物的外观和内部结构，提前发现潜在问题并做出相应修改。此外，写实3D模型还可以应用于虚拟现实技术，提供逼真的虚拟体验，例如虚拟旅游和虚拟培训等领域。
本文将讲解如何使用GLTF 编辑器 -NSDT 在线材质编辑工具为写实3D模型设置纹理贴图，在开始之前我们先了解下纹理里纹理贴图的一些基本概念。
GLTF编辑器支持GLTF/GLB在线预览、材质编辑、重置原点、以及模型轻量化（将相同材质Mesh合并）。GLTF editor supports GLTF/GLB online preview, material editing, reset origin, and model lightweight (merging the same material Mesh)
1、材质纹理贴图 1：没有纹理的 3D 模型2：带纹理的相同模型
纹理贴图是应用于（映射）到形状或多边形表面的图像。这可以是位图图像或程序纹理。它们可以以常见的图像文件格式存储，由 3D 模型格式或材料定义引用，并组装成资源包。
它们可能有 1-3 个维度，尽管 2 个维度对于可见表面最常见。为了与现代硬件一起使用，纹理贴图数据可以以旋转或平铺顺序存储，以提高缓存一致性。渲染 API 通常将纹理贴图资源（可能位于设备内存中）作为缓冲区或表面进行管理，并且可能允许“渲染到纹理”以获得其他效果，例如后期处理或环境映射。
它们通常包含 RGB 颜色数据（存储为直接颜色、压缩格式或索引颜色），有时还包含用于 alpha 混合 （RGBA） 的附加通道，尤其是对于广告牌和贴花叠加纹理。可以将 alpha 通道（以硬件解析的格式存储可能很方便）用于其他用途，例如镜面反射。
2、纹理贴图的作用 纹理贴图在创建视觉上令人惊叹且逼真的 3D 模型中发挥着至关重要的作用。3D 建模中使用了多种类型的纹理贴图，每种类型都有其独特的用途。例如，漫反射贴图用于定义 3D 模型的表面颜色，而镜面贴图则定义表面的光泽度和反射率。法线贴图用于向模型表面添加深度和结构，而位移贴图用于修改表面几何形状本身。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e0bb3c869e42ac7b40d1432cd613101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37f7caff722a36dd4acc88606ba49f06/" rel="bookmark">
			数据库01_增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是数据？什么是数据库？ 数据：描述事物的符号记录称为数据。数据是数据库中存储的基本对象。数据库：存放数据的仓库，数据库中可以保存文本型数据、二进制数据、多媒体数据等数据 2、数据库的发展 第一阶段：使用磁盘文件来存储数据，有网状模型、层次模型，用于分组保存数据。第二阶段：关系型数据库（RDB）+结构化查询语言（SQL），各厂商都在做关系型数据库以及优化SQL查询的效率。第三阶段：关系-对象型数据库即我们平时听到的“大数据”，大数据是超越了关系型数据库的非结构化数据库，通常使用大数据处理技术+全文搜索+分类聚类各种算法来处理。 关系型数据库（结构化的数据）
结构化数据：每一列都有特定的含义，结构非常清晰，二维表结构是关系型数据库的核心。
二、数据库常用操作 数据库定义功能：DBMS提供数据定义语言（DDL）用户可以对数据库中的数据对象进行定义
如创建数据库、删除数据库、修改数据库、创建表、删除表、修改表等数据库操纵功能:DBMS提供数据操纵语言（DML）用户可以实现对数据的基本操作，如插入、删除、修改。数据查询功能：DBMS提供数据查询语言（DQL）用户实现对数据的查询功能数据控制功能：DBMS提供数据控制语言（DCL）进行用户角色和权限的管理 总体上，对数据的操作基本上都支持CRUD，即Create、Retrieve、Update、Delete
三、一些数据库管理系统
Access：桌面的个人数据库，微软开发的，办公用的和office放在一起MS SQLserver：微软的企业版本的数据库，关系型数据库，企业型的DB2/Informixi：IBM的，IBM最早期的是DB2，Informixi是被IBM收购的，关系型数据库最早就是IBM 发明的，但现在最厉害的是ORACLE商业数据库MySQL：免费版本和商业版本，MySQL被ORACLE收购，所以MySQL的免费版本和商业版有比较大的差异，MySQL Community是社区免费版，ORACLE收购了Sun，Sun之前收购了MySQL。
ORACLE收购了Sun有两个至关重要的产品，第一个是Java。第二个是MySQL，都是开源社区里面及其重要的两个应用系统和底层的软件，所以欧盟对ORACLE收购Sun这件事做了严格的审计，确保 ORACLE承诺无论是否开发商业版本，都要有免费版本的授权，否则是不允许收购的。因为用MySQL和Java的人太多了，必须要考虑这种影响。
Sun在被ORACLE后，MySQL的原作者拉了一个分支出来叫MariaDB，内核都一样，功能都一样，95%都是一样的。Java社区版是OpenJdk。MySQL常用的版本是5.6或5.7。
PostgreSQL：免费试用、修改和分发PostgreSQL，不管是私用、商用还是学术研究，很多企业从MySQL转换到PostgreSQL，也是因为宽松的授权ORACLE商业数据库NoSQL：非关系型数据库 三、关系型数据库
什么是关系？
关系型数据库加结构化查询语句
数据库定义语言DDL
1、创建数据库 在大多数的RDBMS中，我们可以使用如下简单的SQL语句，创建整个数据库：
CREATE DATABASE [IF NOT EXISTS] 数据库名 [CHARACTER set 'utf8mb4']; #在SQL语句中 中括号 表示 可选 #[IF NOT EXISTS]参数表示当数据库不存在的时候才执行创建，如果存在的时候就不执行 #[CHARACTER set 'utf8mb4'] create database test character set 'utf8'; create database if not exists test character set 'utf8'; 其中：数据库名在服务器中必须是唯一的，并且符合标识符规则。所谓标识符规则指：
第一一个字符必须是下列字符
a）Unicode标准3.0所定义的字母（Unicode中定义的字母包括拉丁字母a-z和A-Z，以及来自其他语言的字母字符）。
b）下划线（_）、at符号（@）或者数字符号（#）后续字符可以是
a）Unicode标准3.0所定义的字母
b）来自基本拉丁字母或其他国家/地区脚本的十进制数字
c）at符号（@）、美元符号（$）、数字符号或下划线
d）标识符不能是所用RDBMS的保留字，如create、drop、insert、delete、update、alter、select、return、use、grant、revoke等。
e）不允许嵌入空格或其他特殊字符。 2、修改数据库 语法：ALTER DATABASE db_name CHARACTER SET = charset_name
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37f7caff722a36dd4acc88606ba49f06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/544f9758b416e475e94dd14256ca3136/" rel="bookmark">
			【ESP32双核运行Freertos及互斥量】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【ESP32双核运行Freertos及互斥量】 1. ESP32为什么需要多任务2. 什么是互斥量？3. ESP32双核互斥量示例4. 代码分析5. 安装必备组件6. 运行结果7. 总结 1. ESP32为什么需要多任务 ESP32需要多任务处理主要是因为以下几个原因：
edbb4a78-91a1-4704-b54f-4965d500f317
例如添加如下代码块：
var code = “edbb4a78-91a1-4704-b54f-4965d500f317”
并行处理能力：ESP32是一款双核微控制器，拥有两个可以独立运行的处理核心。通过多任务处理，这两个核心可以同时执行不同的任务，提高系统的整体性能和效率。实时响应：在许多嵌入式应用中，系统可能需要对多个输入或事件进行实时响应。例如，一个设备可能需要同时处理用户界面的更新、传感器数据采集、网络通信以及数据处理等任务。通过多任务处理，每个任务可以在其各自的上下文中独立运行，确保各个功能模块能够及时响应。资源利用率：当某些任务在等待外部事件（如I/O操作或网络数据包接收）时，如果只有一个任务在运行，那么处理器的其他部分可能会处于空闲状态。通过多任务处理，其他任务可以在这些等待期间继续执行，提高了处理器资源的利用率。优先级管理：多任务环境允许对任务进行优先级管理。这样，重要的或时间敏感的任务可以得到更高的优先级，确保它们能够在必要时获得处理器资源，而不受低优先级任务的影响。模块化和可扩展性：多任务编程有助于将复杂的系统划分为多个独立的、易于管理的模块。每个模块可以作为一个单独的任务运行，使得代码更易于理解和维护，同时也为系统的扩展和升级提供了便利。事件驱动编程：在事件驱动的系统中，任务通常会在特定事件发生时被触发。通过多任务处理，可以轻松地创建和管理这些事件相关的任务，使得系统能够灵活地应对各种情况。操作系统支持：ESP32支持FreeRTOS等实时操作系统（RTOS），这些系统本身就设计用于多任务环境，并提供了一系列工具和机制来简化多任务编程，如任务调度、同步原语（如互斥量、信号量和事件组）等。
综上所述，ESP32采用多任务处理能够充分利用其双核架构，提高系统性能、响应速度和资源利用率，同时也有利于软件设计的模块化和可扩展性。这对于开发复杂的嵌入式应用，特别是那些涉及多种并发操作和实时响应需求的场景来说至关重要。 在嵌入式系统开发中，多核处理器已成为常态。由于这些处理器具有多个核心，它们能够并行处理多个任务，从而提高系统的整体性能。然而，这也带来了一个挑战：如何确保资源在并行处理过程中的互斥访问，以避免数据冲突和不一致。互斥量（Mutex）是一种常用的同步机制，用于解决这个问题。在这篇文章中，我们将深入探讨ESP32双核处理器的互斥量机制，并通过一个简单的示例来展示如何使用它。我们将使用FreeRTOS库来实现这个示例，该库提供了对互斥量的强大支持。
2. 什么是互斥量？ 互斥量是一种同步工具，用于防止多个任务同时访问共享资源。当一个任务持有互斥量时，其他任务必须等待直到该任务释放互斥量。这样可以确保资源的顺序访问，避免数据冲突和不一致。
3. ESP32双核互斥量示例 我们将通过一个简单的示例来展示ESP32双核处理器上互斥量的使用。这个示例包括两个任务：task1和task2。这两个任务将并行运行，并尝试访问一个共享资源（变量number）。我们将使用互斥量来确保这两个任务不会同时访问这个资源。
#include &lt;FreeRTOSConfig.h&gt; xSemaphoreHandle xMutex; //互斥量 int number = 0; //互斥资源 void task1(void* param) { static int count = 0; int p = *((int*)param); while(count++ &lt; 200) { int core = xPortGetCoreID(); //获取当前核 Serial.printf("Core %d -&gt; ", core); Serial.print("I am task1, Param: "); Serial.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/544f9758b416e475e94dd14256ca3136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa2bd7d8ac1ac19ce34165069584bea/" rel="bookmark">
			Linux报错：audit: backlog limit exceeded
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天，一台虚拟机上操作昨天打开的连接一直没响应，新打开连接连接不上。SSH校验不通过。
通过IT的后台，可以看到满屏的audit: backlog limit exceeded。
问题原因：audit服务记录的审计事件超出默认(或设置)数量 ，达到或超出容量的审计缓冲区队列也可能导致实例锁定或持续无响应状态。
解决办法：强行重启机器并修改audit服务配置。
查看当前默认配置：auditctl -s 修改最大审计缓冲量：auditctl -b 10000
持久化修改
编辑配置文件：vim /etc/audit/rules.d/audit.rules
重启auditd服务
systemctl restart auditd 禁用auditd服务
systemctl disable auditd 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495acff43934fd55af486604a481521e/" rel="bookmark">
			官网万词霸屏推广源码系统：轻松实现百度上万关键词排名在线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互联网的快速发展，网络营销已经成为企业推广的重要手段。在这个竞争激烈的市场中，如何让自己的网站在搜索引擎中获得更好的排名，成为众多企业关注的焦点。而万词霸屏推广源码系统正是在这样的背景下应运而生，为企业提供了一种全新的推广方式。
以下是部分代码示例：
系统特色功能一览：
1.智能选词功能：系统可以根据企业所处行业、产品特点和用户需求，智能筛选出适合的关键词，避免了人工选词的繁琐和遗漏。
2.快速排名功能：通过系统的优化算法，可以快速提升关键词在搜索引擎中的排名，让网站获得更多的曝光和流量。
3.多渠道推广：系统支持多种推广渠道，如搜索引擎、社交媒体、广告联盟等，让企业可以根据自身需求选择合适的推广方式。
4.数据分析功能：系统可以对推广数据进行分析和挖掘，帮助企业了解用户行为和需求，为后续的营销策略提供数据支持。
5.智能客服功能：系统可以自动识别潜在客户，提供智能客服服务，提高用户体验和转化率。
6.定制化服务：根据企业不同的需求和特点，系统可以提供定制化的服务和解决方案，让企业的推广更加精准和有效。
7.安全性高：系统采用了多重安全措施，确保企业的推广数据和信息的安全性。
8.操作简单：系统的界面设计简洁明了，操作方便快捷，让企业可以快速上手并实现高效的推广。
9.高效稳定：系统经过了严格的技术测试和优化，确保运行高效稳定，能够应对高流量的访问和搜索引擎的爬虫抓取。
页面展示：
源码下载地址：春哥技术博客或帮企商城获取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fd3a255a5b7ab951a7f049e46c348c3/" rel="bookmark">
			编程笔记 html5&amp;css&amp;js 013 HTML布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程笔记 html5&amp;css&amp;js 013 HTML布局 一、使用 `&lt;div&gt;` 元素的网页布局二、使用 `&lt;table&gt;` 元素的网页布局三、布局框架小结 网页布局对改善网站的外观非常重要。请慎重设计您的网页布局。 一、使用 &lt;div&gt; 元素的网页布局 div 元素是用于分组 HTML 元素的块级元素。
下面的例子使用五个 div 元素来创建多列布局：
实例
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;网页布局(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="container" style="width:500px"&gt; &lt;div id="header" style="background-color:#FFA500;"&gt; &lt;h1 style="margin-bottom:0;"&gt;网页标题&lt;/h1&gt;&lt;/div&gt; &lt;div id="menu" style="background-color:#FFD700;height:200px;width:100px;float:left;"&gt; &lt;b&gt;菜单&lt;/b&gt;&lt;br&gt; HTML&lt;br&gt; CSS&lt;br&gt; JavaScript&lt;/div&gt; &lt;div id="content" style="background-color:#EEEEEE;height:200px;width:400px;float:left;"&gt; 内容在这里&lt;/div&gt; &lt;div id="footer" style="background-color:#FFA500;clear:both;text-align:center;"&gt; 版权 © 9999999.com&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 二、使用 &lt;table&gt; 元素的网页布局 使用 HTML &lt;table&gt; 标签是创建布局的一种简单的方式。
大多数站点可以使用 &lt;div&gt; 或者 &lt;table&gt; 元素来创建多列。CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fd3a255a5b7ab951a7f049e46c348c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce832e3d205e9a8aaf47e2ae6ee64fc/" rel="bookmark">
			Python中基于字段的不使用元类的ORM实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不使用元类的简单ORM实现 在 Python 中，ORM（Object-Relational Mapping）是一种将对象和数据库之间的映射关系进行转换的技术，使得通过面向对象的方式来操作数据库更加方便。通常，我们使用元类（metaclass）来实现ORM，但是本文将介绍一种不使用元类的简单ORM实现方式。
Field类 首先，我们定义一个Field类，用于表示数据库表中的字段。这个类包含字段的名称和类型等信息，并且支持一些比较操作，以便后续构建查询条件。
class Field: def __init__(self, **kwargs): self.name = kwargs.get('name') self.column_type = kwargs.get('column_type') def __eq__(self, other): return Compare(self, '=', other) # 其他比较操作略... Compare类 为了构建查询条件，我们引入了一个Compare类，用于表示字段之间的比较关系。它可以支持链式操作，构建复杂的查询条件。
class Compare: def __init__(self, left: Field, operation: str, right: Any): self.condition = f'`{left.name}` {operation} "{right}"' def __or__(self, other: "Compare"): self.condition = f'({self.condition}) OR ({other.condition})' return self def __and__(self, other: "Compare"): self.condition = f'({self.condition}) AND ({other.condition})' return self Model类 接下来，我们定义Model类，表示数据库中的表。该类通过Field类的实例来定义表的字段，并提供了插入数据的方法。
class Model: def __init__(self, **kwargs): _meta = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ce832e3d205e9a8aaf47e2ae6ee64fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe78bf4cf190a7eae7c7ce31c36319db/" rel="bookmark">
			使用Pandas DataFrame.resample来处理时间序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas DataFrame.resample方法详解 Pandas库中的DataFrame.resample方法是用于对时间序列数据进行频率转换和重采样的便捷方法。该方法要求对象具有类似日期时间的索引（DatetimeIndex、PeriodIndex或TimedeltaIndex），或者调用者必须将一个类似日期时间的系列/索引的标签传递给关键字参数on/level。
参数说明 rule：DateOffset、Timedelta或字符串，代表目标转换的偏移量。
axis：{0或’index’，1或’columns’}，默认为0。用于上采样或下采样的轴。对于Series，此参数未使用，默认为0。必须是DatetimeIndex、TimedeltaIndex或PeriodIndex。
closed：{‘right’，‘left’}，默认为None。封闭的区间边界。除了’M’、‘A’、‘Q’、‘BM’、‘BA’、‘BQ’和’W’的所有频率偏移，默认为’left’。
label：{‘right’，‘left’}，默认为None。用于标记桶的区间边缘标签。除了’M’、‘A’、‘Q’、‘BM’、‘BA’、‘BQ’和’W’的所有频率偏移，默认为’left’。
convention：{‘start’，‘end’，‘s’，‘e’}，默认为’start’。仅适用于PeriodIndex，控制使用规则的开始或结束。
kind：{‘timestamp’，‘period’}，可选，默认为None。传递’timestamp’将结果索引转换为DateTimeIndex，传递’period’将其转换为PeriodIndex。默认保留输入表示形式。
on：字符串，可选。对于DataFrame，用于重采样的列而不是索引。列必须类似于日期时间。
level：字符串或整数，可选。对于MultiIndex，用于重采样的级别（名称或编号）。级别必须类似于日期时间。
origin：Timestamp或字符串，默认为’start_day’。调整分组的时间戳。原点的时区必须与索引的时区匹配。如果是字符串，必须是以下之一：
‘epoch’：原点是1970-01-01。‘start’：原点是时间序列的第一个值。‘start_day’：原点是时间序列的午夜的第一天。‘end’：原点是时间序列的最后一个值。‘end_day’：原点是最后一天午夜的天花板。 在1.3.0版本中新增。注意：只对Tick频率（即固定频率，如天、小时和分钟，而不是月份或季度）有效。
offset：Timedelta或字符串，默认为None。添加到原点的偏移时间间隔。
group_keys：bool，默认为False。是否在对重采样对象使用.apply()时将组键包含在结果索引中。
返回值 pandas.api.typing.Resampler 重采样器对象。
示例 以下是一些示例以及对应的代码：
示例 1：将时间序列数据进行降采样为3分钟间隔，对每个区间内的数值求和。 index = pd.date_range('1/1/2000', periods=9, freq='T') series = pd.Series(range(9), index=index) 2000-01-01 00:00:00 0 2000-01-01 00:01:00 1 2000-01-01 00:02:00 2 2000-01-01 00:03:00 3 2000-01-01 00:04:00 4 2000-01-01 00:05:00 5 2000-01-01 00:06:00 6 2000-01-01 00:07:00 7 2000-01-01 00:08:00 8 Freq: T, dtype: int64 result = series.resample('3T').sum() print(result) 2000-01-01 00:00:00 3 2000-01-01 00:03:00 12 2000-01-01 00:06:00 21 Freq: 3T, dtype: int64 示例 2：将时间序列数据进行上采样为30秒间隔，利用ffill和bfill方法填充NaN值。 up_sample_ffill = series.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe78bf4cf190a7eae7c7ce31c36319db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b1841fd5b923927fb599a6511666d39/" rel="bookmark">
			CTF-Reverse学习-为缺少指导的同学而生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新日志：
2023-12-22 11:57 发布博客，创建工具列表，创建实验1
2023-12-23 16:46 实验1课后练习添加 “入门逆向-bugku”
Reverse是什么？
CTF中Reverse题型通常会给你一些与程序相关的程序，往往是一些编译后的程序，然后通过反汇编的方式，窥探和猜测程序的逻辑，并分析程序逻辑，获取解题逻辑。利用解题逻辑，按固定条件执行尘效果或者编写逆向逻辑脚本的方式来获取flag。
软件代码逆向主要指对软件的结构，流程，算法，代码等进行逆向拆解和分析。
逆向逆向，逆向的是程序吗，nonono，逆向的是人心，编程人的心。程序是人写的，只要他在开发时走了下神，或者少考虑了一个细节，就会产生漏洞和BUG，绝大多数都会被修复，但完全没有错误的程序是不存在的。
解题步骤
获取题目附件分析文件是程序从开发到编译到运行的哪个阶段的产物通过反汇编，猜测源代码等一系列手段，逆向出源代码或者代码逻辑分析源代码和逻辑，找到解题思路利用解题思路，按顺序执行程序或者编写解题脚本来得到flag 本博客在B站有配套视频，随博客同步跟新，但博客内容的替换和更新会更加频繁。等博主社恐的毛病处理好，视频会重新录制，现在可能有些糟糕。还望大家见谅
Rotten战队-Reverse入门https://www.bilibili.com/video/BV14g4y1Z7HR/?spm_id_from=333.999.0.0&amp;vd_source=b0baa38241452f542afabdf70d10fca7
一、教学用的题库网址 我会以NSSCTF,BUUCTF平台的题目做教学，后面也会加其他平台。
NSSCTF网址
NSSCTF平台
BUUCTF
BUUCTF平台
二、工具列表 IDA pro 7.7 反汇编工具
链接：https://pan.baidu.com/s/11YzTTBgDzlrg8a_k-raqqw?pwd=6666 提取码：6666 解压后
执行，选择yes即可完成破解
温馨提示：安装目录请不要有中文路径。
jadx-gui 1.4.7 安卓反编译工具
exeinfope 查壳工具
FFI 脱壳工具
MUMU模拟器 安卓模拟器
MuMu模拟器官网_安卓12模拟器_网易手游模拟器
好用！
如果报错显卡问题，请先检查独立显卡的驱动更新，如果CPU带有核显，核显也需要更新
AndroidKiller 安卓反编译工具
kali虚拟机 三、刷题加学习 实验1 字符串泄露（1） 学习目标: 学会使用Linux中的file指令查看程序位数学会使用IDA pro 查找字符串学会使用jadx-gui查找安卓程序字符串 1.easyre BUUCTF平台
题目附件拖入kali，使用file指令查看这个文件，可以看到有X86-64标记，为64位程序
使用64位的IDA打开，如果用32位可能会存在无法反编译等其他异常情况。
点击OK，如果发现缺少第一二行的选项，请检查是否安装错误（只是这道题目，别的题目可能真只有最后的选项）
一路YES，让你选文件夹的点取消
接下来使用shift+F12来查找字符串
有些同学电脑键盘上可能存在键位冲突，这样打开即可
按CTRL+F执行搜索，输入flag或者{，或者flag{。
即可搜索到flag,如果想复制，请双击这个字符串，在这个页面复制
flag{this_Is_a_EaSyRe} 退出IDA时，勾选DON'T SAVE the database，删除缓存文件，如果你还要再次打开，可暂时保留
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b1841fd5b923927fb599a6511666d39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2e2138a474fa14df199a63e73a1f61e/" rel="bookmark">
			浅析Python修饰器（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		书接上回 实现对属性编辑操作的拦截 在上回中，我们谈到在Python中利用基于类的描述器（descriptor）和函数修饰器（decorator），可以实现针对对象属性访问的拦截操作。那么我们很容易想到，既然可以拦截对属性的访问操作，那么也就一定能够实现针对属性的编辑操作的拦截。
下面我先直接上具体的代码：
class my_property: def __init__(self, *args, **kwargs): pass def __get__(self, obj, cls): return self.func(obj) def setter(self, fset): self.fset = fset return self def __set__(self, obj, value): if not self.fset: raise AttributeError("can't set attribute") return self.fset(obj, value) def __call__(self, func, *args, **kwargs): self.func = func return self class SysOptions: def __init__(self): self.cache = dict() @my_property() def website_base_url(self): if 'website_base_url' in self.cache: return self.cache['website_base_url'] else: return None @website_base_url.setter def website_base_url(self, value): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2e2138a474fa14df199a63e73a1f61e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43b5a376aa5e5e9bb85e826034c2852d/" rel="bookmark">
			C#/.NET/.NET Core学习、工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐱‍🚀C#/.NET/.NET Core学习、工作、面试指南 让现在的自己不再迷茫✨✨✨。
🌈DotNetGuide DotNetGuide技术社区是一个面向.NET开发者的开源技术社区，旨在为开发者们提供全面的C#/.NET/.NET Core相关学习资料、技术分享和咨询、项目推荐、招聘资讯和解决问题的平台。在这个社区中，开发者们可以分享自己的技术文章、项目经验、遇到的疑难技术问题以及解决方案，并且还有机会结识志同道合的开发者。我们致力于构建一个积极向上、和谐友善的.NET技术交流平台，为广大.NET开发者带来更多的价值和成长机会。
🔍目录导航(善用Ctrl+F) 🏷️优质学习资料收录栈🏹编程效率提升技巧集⚒️程序员常用的工具软件✍C#入门到进阶学习指南🔋C#/.NET/.NET Core充电站🎁C#/.NET/.NET Core面试宝典📰C#/.NET/.NET Core最新资讯🥇C#/.NET/.NET Core开发实战教程✋C#/.NET/.NET Core疑难问题答疑📚C#/.NET/.NET Core推荐学习书籍📺C#/.NET/.NET Core学习视频汇总🏗️C#/.NET/.NET Core优秀项目框架🧱设计模式🛠️数据结构🧮逻辑算法🍇关系型数据库🍉非关系型数据库💡系统设计💻操作系统🛰️计算机网络☁️容器技术🧰DevOps&amp;CI&amp;CD🌍Web前端开发🧲版本控制工具🙇面试须知👩‍💻简历模板🧭宝藏指南✈️社区组织 🏷️优质学习资料收录栈 🐱‍🚀零基础如何自学C#?🥇高质量付费学习课程推荐🚤适合后端程序员的前端框架📚.NET应用程序体系结构文档📚2023年ASP.NET Core开发者学习指南🥏值得推荐的.NET/.NET Core ORM框架汇总🐮C#/.NET/.NET Core推荐博客&amp;博主&amp;公众号⛵C#/.NET/.NET Core推荐学习路线&amp;文档&amp;文章📚C#指南（微软提供的最权威，最全面的C#学习资料）📚.NET文档（微软提供的最权威，最全面的.NET学习资料）💪微软官方.NET免费教程（面向从初学者到高级开发人员）🔎面向开发人员和技术专业人员的Microsoft文档和学习主页 🔝返回目录
🏹编程效率提升技巧集 Visual Studio Visual Studio 2022下载Visual Studio for Mac下载Visual Studio常用快捷键Visual Studio的奇淫技巧18款Visual Studio实用插件Visual Studio 2022进行文件差异比较合理使用Visual Studio 2022内置任务列表（TODO）Visual Studio将JSON格式数据自动转化为对应的类Visual Studio使用Git忽略不想上传到远程仓库的文件Visual Studio使用Web Deploy发布.NET Web应用到指定服务器的IIS中 Visual Studio Code VS Code下载VS Code常用快捷键20款VS Code实用插件VS Code使用Git可视化管理源代码详细教程VS Code调试和发布ASP.NET Core Web应用VS Code安装C#开发工具包并编写ASP.NET Core Web应用VS Code安装CodeGeeX AI编程助手提高.NET开发工作效率 AI辅助编程工具 CodeGeeX AI编程助手AI编程工具CodeWhisperer GitHub GitHub漫游指南C# GitHub趋势榜GitHub Issues 快速入门如何给GitHub上的开源项目提交PR?五分钟教你使用GitHub寻找优质项目我找回了我喜欢的GitHub Old Feed30分钟快速搭建并部署一个免费的个人博客 Git管理工具 GitHub Desktop使用教程最全面的SourceTree使用教程详解TortoiseGit使用教程（图文详细版）VS Code使用Git可视化管理源代码详细教程 🔝返回目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43b5a376aa5e5e9bb85e826034c2852d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a3111b1c0b772c9e99ab71fc2e93192/" rel="bookmark">
			数据之光：乡镇企业的发展利器——数据可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据可视化是一项强大的工具，它不仅在大型企业中发挥关键作用，而且在乡镇企业中也能作出显著贡献。那么，数据可视化究竟能为乡镇企业做出什么样的贡献呢？
首先，数据可视化为乡镇企业提供了更清晰的业务洞察。通过将庞大的数据以图表、图形的方式展现，企业领导和员工能够迅速了解业务的现状、趋势和关键绩效指标。这种直观的洞察力有助于企业更好地理解市场需求，优化产品和服务，提高竞争力。其次，数据可视化提升了决策效率。在乡镇企业中，决策者通常需要快速而准确地做出决策。通过可视化的方式呈现数据，决策者能够更迅速地理解业务状况，从而做出更明智的战略和战术决策。这种高效决策有助于乡镇企业在竞争激烈的市场中更好地应对挑战。
第三，数据可视化提高了业务的透明度。透过直观的图形和图表，企业内部的各个层面能够更容易地了解业务运作情况。这种透明度有助于团队之间更好地协作，快速响应市场变化，共同推动企业的发展。此外，数据可视化也为乡镇企业的市场营销提供了有力支持。通过可视化展示销售数据、客户反馈等信息，企业能够更好地了解目标市场的需求，调整营销策略，提高市场占有率。这对于乡镇企业而言，是促进业务增长的关键一环。
这里惯例推荐一下山海鲸可视化这款数据可视化软件，它的数据可视化相关编辑功能全部可以免费使用，并且没有任何限制，甚至如果你制作的是纯二维项目，那么私有化部署也是完全免费的。那么三维项目呢？尽管三维项目无法像二维项目一样免费部署，但是仍然可以免费编辑制作，只是最终导出后会存在水印。不过与同类产品相比，山海鲸可视化的免费化程度可以说是相当高了。
综合而言，数据可视化不仅仅是大企业的专利，对于乡镇企业而言同样具有重要价值。通过提供清晰的业务洞察、提升决策效率、增加业务透明度、支持市场营销和促进可持续发展，数据可视化为乡镇企业开辟了一条通向成功的道路。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ad58e5cbacfd138d8994a515dc4528/" rel="bookmark">
			vue2.0/vue3.0学习笔记——2022.08.16
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue2（查漏补缺） 一、vue基础 内置指令（查漏补缺） 1、v-text 更新元素的textContent
2、v-html 更新元素的innerHtml
3、v-cloak 防止闪现，与css配合: [v-cloak] {dispaly: none}
4、v-once 在初次动态渲染厚，就视为静态内容了；后面数据的改变不会引起v-once所在结构的更新，可以用于优化性能
5、v-pre 跳过其所在节点的编译过程；可利用它跳过：没有指令语法、没有使用插件语法的节点，加快编译
6、还可自定义指令
生命周期 1、初始化显示
beforeCreate()created()beforeMount()mounted() 2、更新状态: this.xxx = value
beforeUpdate()updated() 3、销毁 vue 实例: vm.$destory()
beforeDestory()destoryed() 二、vue-cli vue脚手架 说明 Vue 脚手架是 Vue 官方提供的标准化开发工具（开发平台）
三、vue-router 说明 vue 的一个插件库，专门用来实现 SPA 应用
SPA 应用的理解 单页 Web 应用（single page web application，SPA）。整个应用只有一个完整的页面。点击页面中的导航链接不会刷新页面，只会做页面的局部更新。数据需要通过 ajax 请求获取。 相关 API this.$router.push(path): 相当于点击路由链接（可以返回到当前路由界面）this.$router.replace(path): 用新路由替换当前路由（不可以返回到当前路由界面）this.$router.back(): 请求(返回)上一个记录路由this.$router.go(-1): 请求(返回)上一个记录路由this.$router.go(1): 请求下一个记录路由 四、vuex 概念 专门在 Vue 中实现集中式状态（数据）管理的一个Vue 插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。
什么时候使用 Vuex 多个组件依赖于同一状态来自不同组件的行为需要变更同一状态 vuex 核心概念和 API 1、state vuex 管理的状态对象；是唯一的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ad58e5cbacfd138d8994a515dc4528/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d55c619e74086a694a33840956d5d4a/" rel="bookmark">
			【开题报告】基于SpringBoot的茶文化宣传网站设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.研究背景和意义 1.1研究背景 茶文化是中国传统文化的重要组成部分，具有悠久的历史和丰富的内涵。茶文化不仅是一种饮食文化，更是一种生活方式和精神追求。然而，在当今快节奏的生活中，茶文化逐渐被人们所忽视。为了加强对茶文化的宣传和推广，有必要设计和实现一个茶文化宣传网站，以便向更多的人传播茶文化的魅力。
1.2研究意义 设计和实现一个基于SpringBoot的茶文化宣传网站具有以下意义：
（1）传播茶文化知识：通过网站上发布茶文化相关的文章、图片和视频等多媒体内容，向用户介绍茶文化的起源、发展、品种、制作工艺、茶具等方面的知识，提高用户对茶文化的认知和理解。
（2）促进茶文化的传承和发展：通过网站上的互动交流功能，用户可以进行评论、点赞、分享等操作，增加用户参与度和黏性，促进茶文化的传承和发展。
（3）推动茶产业的繁荣：茶文化宣传网站可以为茶产业提供一个宣传和推广的平台，吸引更多的人了解茶文化，提高茶产品的知名度和销售量，推动茶产业的繁荣。
（4）丰富人们的生活方式：茶文化不仅仅是一种饮食文化，更是一种生活方式和精神追求。通过网站上提供茶文化相关的艺术、音乐、文学等内容，能够丰富人们的精神生活，提升生活品质。
综上所述，设计和实现一个基于SpringBoot的茶文化宣传网站，有助于加强茶文化的宣传和推广，提高用户对茶文化的认知和理解，推动茶产业的发展，同时也能够丰富人们的生活方式，提升生活品质。
2.研究目的 基于SpringBoot的茶文化宣传网站设计与实现的研究目的主要包括以下几个方面：
（1）茶文化传播：通过设计和实现一个茶文化宣传网站，旨在向更多的人传播茶文化的知识和魅力。通过发布茶文化相关的文章、图片、视频等多媒体内容，让用户了解茶文化的起源、发展、品种、制作工艺、茶具等方面的知识，提高用户对茶文化的认知和理解。
（2）用户参与与互动：茶文化宣传网站应提供互动交流的功能，为用户提供评论、点赞、分享等操作，增加用户的参与度和黏性。通过用户间的互动交流，促进茶文化的传承和发展。
（3）茶产业推广：茶文化宣传网站可以为茶产业提供一个宣传和推广的平台。通过网站上宣传茶产业的特色茶叶、茶具、茶旅等产品和服务，吸引更多的人了解茶文化，提高茶产品的知名度和销售量，推动茶产业的发展。
（4）提升用户体验：茶文化宣传网站的设计与实现需要注重用户体验，通过界面设计、功能设置和内容展示等方面的优化，提升用户的使用体验，让用户更好地享受到茶文化带来的乐趣和价值。
综上所述，基于SpringBoot的茶文化宣传网站设计与实现的研究目的是通过传播茶文化知识、提供用户参与与互动的平台、推广茶产业、提升用户体验等手段，促进茶文化的传承与发展，让更多的人了解、体验和喜爱茶文化。
3.国内外研究现状 目前，在茶文化宣传网站的设计与实现方面，国内外都有一些相关的研究和实践。
3.1国内研究现状 在国内，茶文化宣传网站的设计与实现得到了广泛关注与研究。一些大型茶企或茶协会建立了自己的官方网站，通过发布茶文化相关的文章、图片、视频等内容，向用户传播茶文化知识，并提供互动交流的平台。同时，也有一些学术机构和研究者从茶文化的角度出发，开展了与茶文化宣传网站相关的研究工作，探索如何通过网站设计和内容呈现方式，更好地传播茶文化。
3.2国外研究现状 在国外，茶文化宣传网站的设计与实现也得到了一定的关注。一些以茶为主题的商业网站或社区平台，通过发布茶文化相关的内容，吸引茶爱好者的关注，促进交流和分享。此外，针对茶文化的在线学习平台和论坛也相继涌现，为国外用户提供了学习和交流的机会。同时，还有一些学术界的研究者对茶文化宣传网站的设计与实现进行了一定的研究，旨在提升用户体验和茶文化传播效果。
总体来说，国内外对于基于SpringBoot的茶文化宣传网站的设计与实现都已经有了一定的研究和实践，但仍有很大的发展空间。未来的研究可以从用户体验、内容创新、数据分析等方面入手，进一步提升网站的功能和效果，更好地推广和传承茶文化。
4.研究内容和方法 基于SpringBoot的茶文化宣传网站设计与实现的研究内容主要包括以下几个方面：
（1）网站需求分析：根据茶文化宣传网站的目标和功能，对网站的需求进行分析和梳理，确定网站的基本功能和特色。
（2）系统设计：根据网站需求分析结果，设计网站的系统框架、模块划分、数据库设计等方案，明确项目的技术路线和实现途径。
（3）网站实现：按照系统设计方案，使用SpringBoot框架开发网站的后端逻辑，采用HTML、CSS、JavaScript等前端技术实现网站的界面设计和交互效果，搭建整个网站并进行测试和调试。
（4）性能优化：对网站进行性能优化，提高网站的访问速度和响应能力，让用户在使用网站时获得更好的体验。
（5）用户体验测试：对网站进行用户体验测试，收集用户反馈意见和建议，通过不断改进和优化，提高网站的用户满意度和吸引力。
基于SpringBoot的茶文化宣传网站设计与实现的研究方法主要包括以下几个方面：
（1）文献综述法：了解国内外茶文化宣传网站的设计与实现情况，汲取其他项目的成功经验和教训，为本项目提供借鉴和参考。
（2）问卷调查法：通过网络或实地问卷调查的方式，了解用户对于茶文化宣传网站的需求和期望，为网站的设计和功能开发提供参考和依据。
（3）实证研究法：通过搭建网站原型，进行实证研究，验证设计方案的可行性和有效性，并不断进行改进和优化。
（4）用户体验测试法：邀请一些具有代表性的用户，对网站的界面设计、功能体验、交互效果等方面进行测试和评估，收集用户反馈意见和建议，为网站的改进和优化提供参考。
综上所述，基于SpringBoot的茶文化宣传网站设计与实现的研究内容和方法主要包括需求分析、系统设计、网站实现、性能优化和用户体验测试等方面，通过文献综述、问卷调查、实证研究和用户体验测试等多种方法，提高网站的设计水平和质量，实现茶文化的传承和推广。
5.功能设计 基于SpringBoot的茶文化宣传网站功能设计如下：
（1）首页展示：网站首页应呈现茶文化的核心内容，包括茶文化的介绍、茶叶品种、茶具展示、名人故事等，吸引用户的注意力并提供导航入口。
（2）茶文化文章：提供茶文化相关的文章栏目，包括茶史、茶学、茶道、茶艺等，向用户传递更深入的茶文化知识。
（3）视频与图片展示：通过视频和图片的展示，形象地展示茶文化的魅力，包括茶叶制作过程、茶具展示、名家表演等，增强用户对茶文化的感官体验。
（4）在线茶艺课堂：提供在线茶艺课程，包括泡茶技巧、品茶方法、茶道礼仪等，帮助用户学习和掌握茶艺知识。
（5）茶文化活动：发布茶文化相关的活动信息，包括茶会、茶展、茶文化讲座等，鼓励用户参与和体验真实的茶文化活动。
（6）用户互动功能：提供用户评论、点赞、分享等功能，让用户可以与其他用户互动交流，分享自己的茶文化体验和心得。
（7）茶产品推荐：展示优质的茶叶产品和茶具，包括茶叶品牌、茶具商家等，提供购买和推荐服务。
（8）茶文化资讯：提供茶文化的最新资讯和动态，包括茶文化的研究成果、茶叶市场动向等，让用户了解到茶文化的最新发展。
（9）用户个人中心：为用户提供注册登录功能，并设计个人中心页面，用户可以管理个人信息、收藏喜欢的文章、参与互动等。
（10）网站管理后台：提供网站管理者登录入口，管理网站内容、用户评论、活动发布等功能，确保网站的正常运行和良好的用户体验。
以上是基于SpringBoot的茶文化宣传网站的功能设计，通过这些功能的实现，可以为用户提供丰富的茶文化知识和互动体验，促进茶文化的传播和发展。
6.技术方案 基于SpringBoot的茶文化宣传网站设计与实现的技术方案如下：
（1）前端技术：使用HTML、CSS、JavaScript等前端技术实现网站的页面布局、样式设计和交互效果。
（2）后端技术：使用SpringBoot框架，搭建网站的后端逻辑，包括数据处理、业务逻辑、接口设计等。
（3）数据库技术：采用MySQL数据库，存储网站的数据信息，包括用户信息、文章内容、评论信息、活动信息等。
（4）前后端分离技术：采用前后端分离的技术架构，提高网站的响应速度和用户体验。
综上所述，基于SpringBoot的茶文化宣传网站设计与实现的技术方案主要包括前端技术、后端技术、数据库技术、安全技术、前后端分离技术、等。通过采用这些技术手段，可以提高网站的响应速度和用户体验，为用户提供稳定、便捷、安全的服务。
7.预期成果和创新性 本项目的预期成果是设计和实现一个功能完善、用户友好的茶文化宣传网站。具体包括：
提供丰富的茶文化知识内容，通过文章、图片和视频展示，向用户传递茶文化的魅力。支持用户互动和交流，通过评论、点赞等功能，增加用户参与度和黏性。具备一定的可拓展性，可以根据需求进行功能的扩展和定制。 8.预期影响和意义 本项目的完成将有助于加强茶文化的宣传和推广，提高用户对茶文化的认知和理解。通过设计和实现一个易用且具有良好用户体验的茶文化宣传网站，可以吸引更多的用户参与其中，促进茶文化的传承和发展，推动茶产业的繁荣。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef008d52e6a744f9d0bbb6cc0af539b4/" rel="bookmark">
			Java 编程实现常见的排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java编程中，实现常见的排序算法是一项基础而重要的任务。排序算法是计算机科学中的经典问题之一，涉及将一组元素按照某个顺序进行排列。Java提供了一种非常灵活的编程环境，可以用来实现各种排序算法。
冒泡排序（Bubble Sort） 冒泡排序是一种简单的排序算法，它重复地遍历待排序数组，比较相邻的两个元素，如果它们的顺序不对，则交换它们。这个过程持续进行，直到整个数组都是有序的。
public class BubbleSort { public static void bubbleSort(int[] array) { int n = array.length; for (int i = 0; i &lt; n - 1; i++) { for (int j = 0; j &lt; n - i - 1; j++) { if (array[j] &gt; array[j + 1]) { // 交换array[j]和array[j+1] int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; } } } } public static void main(String[] args) { int[] array = {64, 34, 25, 12, 22, 11, 90}; bubbleSort(array); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef008d52e6a744f9d0bbb6cc0af539b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f51c47aab4af430381f107f70c8f80f/" rel="bookmark">
			SQL面试题挑战12：计算部门的平均工资
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 问题：SQL解答： 问题： 现在要计算每个部门的平均工资（工资和/员工数），但是要去掉部门的最高工资和最低工资（如果一个部门最高或最低工资有并列的，去掉一个最高的和一个最低的）后，计算部门的平均工资。
101 ,"研发部" ,50000 102 ,"研发部" ,50000 103 ,"研发部" ,10000 104 ,"研发部" ,20000 105 ,"研发部" ,30000 106 ,"市场部" ,20000 107 ,"市场部" ,30000 108 ,"产品部" ,20000 109 ,"产品部" ,30000 110 ,"产品部" ,25000 111 ,"市场部"	,14000 112 ,"市场部"	,8000 113	,"产品部"	,20000 SQL解答： 使用开窗函数找出该部门的最高工资和最低工资，并按最高到最低和最低到最高分别给排名，最后排除掉满足工资要求且排名在最前面的员工即可。
with temp as ( select 101 as user_id,"研发部" as dept,50000 as salary union all select 102 as user_id,"研发部" as dept,50000 as salary union all select 103 as user_id,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f51c47aab4af430381f107f70c8f80f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/723973e12925ce9f3f138324d99511ab/" rel="bookmark">
			uniapp-H5项目的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先推荐个插件库-非常好用：https://ext.dcloud.net.cn/
一、uniapp h5 适配pc端
1、问题：屏幕尺寸在400px~960px之间页面排版错乱
2、解决方法：在page.json文件中
"globalStyle": { "navigationStyle": "custom", "navigationBarTextStyle": "white", "navigationBarTitleText": "xxxx项目App", "navigationBarBackgroundColor": "#FFFFFF", // 以下代码是解决H5适配排版错乱问题的代码 "rpxCalcMaxDeviceWidth": 0, // rpx 计算所支持的最大设备宽度，单位 px，默认值为 960 "rpxCalcBaseDeviceWidth": 375, // rpx 计算使用的基准设备宽度，设备实际宽度超出 rpx 计算所支持的最大设备宽度时将按基准宽度计算，单位 px，默认值为 375 "rpxCalcIncludeWidth": 750 // rpx 计算特殊处理的值，始终按实际的设备宽度计算，单位 rpx，默认值为 750 } 二、uniapp h5 在手机上底部导航栏上下抖动
1、问题：原因不详
2、解决方法：在App.vue中加入如下代码
&lt;style lang="scss"&gt; page{ height: 100vh !important; } &lt;/style&gt; 三、uniapp h5 适配 Ios底部小黑条
1、问题：安卓没有小黑条、Ios有小黑条
2、解决方法：在App.vue 样式中加入如下代码
padding-bottom: constant(safe-area-inset-bottom) !important; /*兼容 IOS&lt;11.2*/ padding-bottom: env(safe-area-inset-bottom) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/723973e12925ce9f3f138324d99511ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4379058e51adb78be9c1060460ff9bf4/" rel="bookmark">
			WinForm开发 - C# RadioButton(单选框) 设置默认选中或取消默认选中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WinForm开发中RadioButton组件使用过程中的小技巧。
1、属性界面操作
如果有多个组件，希望不显示默认选中单选框只需要将其Checked属性全部设置为False即可，
如果希望默认多个组件中显示默认选中，将其Checked属性设置为True。
2、代码实现
要想RadioButton的默认选中或取消默认选中，可以通过设置Checked属性为true或false来实现。
以下是一个示例代码：
// 取消RadioButton的默认选择 radioButton1.Checked = false; //or //RadioButton的默认选择 radioButton1.Checked = true; 另外，如果希望一组RadioButton中的所有选项都不设置默认选择，可以将它们的Checked属性都设置为false。这样，这组RadioButton中的所有选项都不会被默认选中。
// 取消一组RadioButton的默认选择 radioButton1.Checked = false; radioButton2.Checked = false; radioButton3.Checked = false; 一组RadioButton中希望显示默认选中：
// 一组RadioButton的默认选择一个 radioButton1.Checked = true; radioButton2.Checked = false; radioButton3.Checked = false; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb19a115b498d784cb21dc2ba464a40b/" rel="bookmark">
			模型剪枝【学习笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 参考文献：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/349b8953231c81a92e69d48f42368ba5/" rel="bookmark">
			Java 调用 Excel 中的各种公式解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中调用Excel中的各种公式通常涉及到操作Excel文件，以及使用Java库来执行和计算公式。为了实现这一目标，我们可以使用Apache POI库来读取和写入Excel文件，同时使用Apache Commons Math库来执行数学运算。
以下是一个详细的步骤，演示如何在Java中调用Excel中的各种公式：
步骤一：添加依赖 首先，在你的Java项目中添加所需的依赖。在这个例子中，我们将使用Apache POI和Apache Commons Math。你可以通过在Maven项目的pom.xml文件中添加以下依赖来引入这两个库：
&lt;dependencies&gt; &lt;!-- Apache POI --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Apache Commons Math --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-math3&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 步骤二：读取Excel文件 使用Apache POI库可以轻松读取Excel文件。以下是读取Excel文件的简单示例：
import org.apache.poi.ss.usermodel.*; import org.apache.poi.xssf.usermodel.XSSFWorkbook; import java.io.FileInputStream; import java.io.IOException; public class ExcelFormulaReader { public static void main(String[] args) { try (FileInputStream fileInputStream = new FileInputStream("path/to/your/excel/file.xlsx")) { Workbook workbook = new XSSFWorkbook(fileInputStream); Sheet sheet = workbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/349b8953231c81a92e69d48f42368ba5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa0b79b1b0b772e0b3ddc0d0b256098d/" rel="bookmark">
			隧道代理HTTP工作原理：一场奇妙的网络魔法表演
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嘿，小伙伴们！今天我们要一起探索一个有趣的话题——隧道代理HTTP的工作原理。这不是普通的表演，而是一场奇妙的网络魔法表演！
首先，让我们想象一下，网络世界就像一个大舞台，而我们每个人都是这个舞台上的演员。我们通过电脑、手机等设备与这个舞台进行互动，而隧道代理HTTP就是这场表演的魔术师，帮助我们完成各种神奇的表演。
那么，隧道代理HTTP是如何完成这些神奇表演的呢？这就需要了解它的工作原理了。
隧道代理HTTP其实就是一道桥梁，它连接了你的设备和你想要访问的网站。当你通过隧道代理HTTP访问网站时，你的请求会先到达代理服务器，然后再由代理服务器转发给目标网站。这样，你的真实IP地址就被隐藏了起来，你的浏览行为也变得更加安全了。
在这个过程中，隧道代理HTTP就像是一个变魔术的人，它把你的请求变成了一个“魔法信封”，然后通过这个“信封”将你的请求传递给代理服务器。这个“信封”有一个神奇的功能，它能够将你的请求转换成一种只有代理服务器才能解读的语言。这样一来，你的请求就被保护了起来，没有人能够知道你到底在做什么。
而当你从网站获取信息时，隧道代理HTTP同样发挥着它的神奇作用。它再次将网站的信息装进“魔法信封”，然后传递给你。你打开信封，就能看到你想看的内容了。整个过程就像是一场神奇的魔术表演，让你在不知不觉中享受到了网络世界的便利和乐趣。
总之，隧道代理HTTP的工作原理就像是一场奇妙的网络魔法表演。它通过将你的请求转换成“魔法信封”，保护了你的隐私和浏览行为的安全。同时，它还像一个魔术师一样，让你能够突破地域限制、访问更多网站、提升网速等。是不是感觉像找到了网络世界的宝藏？
在接下来的文章中，我们将一起探讨如何选择合适的代理服务器、如何配置和使用各种代理工具、以及如何在使用隧道代理HTTP的同时保护我们的网络安全。所以，如果你想在网络世界中畅游无阻、保护自己的隐私安全，那就一定要关注我们的后续文章哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a691012fd204dfd2236e3fd418f176/" rel="bookmark">
			[react]react-router-dom 与 redux 版本升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[react]react-router-dom 与 redux 版本升级 环境脚手架的升级react-router-dom 升级关于路由相关文件的写法--react-router-dom 5.0.1入口渲染文件App.js路由框架src/views/root/index.js路由守卫 src/views/routerguide/index.jsx路由文件src/views/page.js 关于路由相关文件的写法--react-router-dom 6.20.1方式1入口渲染文件App.js路由框架src/views/root/index.js报错信息[RouterGuide] is not a &lt;Route&gt; component. All component children of &lt;Routes&gt; must be a &lt;Route&gt; or &lt;React.Fragment&gt; 路由守卫 src/views/routerguide/index.jsx路由文件src/views/page.js 关于路由相关文件的写法--react-router-dom 6.20.1方式2入口渲染文件App.js路由框架src/views/root/index.js路由文件 src/views/page.js 路由的跳转代码跳转标签跳转 状态管理React 状态管理--Redux4.0.4版本action.js定义改变状态类型connect.js定义组件需要修改的全局变量redux.js 定义改变状态类型store.js 定义所有的全局变量App.js 全局变量的注册：组件使用全局变量 React 状态管理--Redux5.0.0版本store.js 定义所有全局状态store.js 定义所有全局状态--持久化版本组件使用全局变量：报错信息store.js:60 A non-serializable value was detected in an action, in the path: `register`. Value: ƒ register2(key) { _pStore.dispatch({ type: REGISTER,key});} 生命周期问题汇总Module not found: Can't resolve 'web-vitals'Cannot access '__WEBPACK_DEFAULT_EXPORT__' before initializationState updates from the useState() and useReducer() Hooks don't support the second callback argument.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7a691012fd204dfd2236e3fd418f176/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dc6f1624d765521abb652d96ffaf25b/" rel="bookmark">
			深度学习在自然语言处理中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习在自然语言处理中的应用
一、引言
随着人工智能技术的飞速发展，自然语言处理（NLP）作为其重要分支，已经在诸多领域取得了令人瞩目的成果。深度学习作为当前最炙手可热的技术，为NLP带来了革命性的变革。本文将详细探讨深度学习在自然语言处理中的应用，以及其未来的发展趋势。
二、深度学习在自然语言处理中的应用
1.词向量表示
词向量表示是自然语言处理中的基础问题，旨在将词转化为稠密的向量。传统的词向量表示方法，如基于手工特征的方法，难以应对大规模语料和复杂语义。而深度学习方法，特别是Word2Vec和GloVe，能够通过无监督学习，将词转化为低维稠密向量，有效捕捉词的语义信息。
2.文本分类与情感分析
深度学习在文本分类和情感分析中发挥了巨大作用。卷积神经网络（CNN）和循环神经网络（RNN）是常用的模型。CNN能够捕捉文本的局部特征，而RNN能够捕捉文本的时序依赖性。在此基础上，长短期记忆网络（LSTM）和门控循环单元（GRU）进一步提高了RNN的性能。另外，Transformer结构以其强大的表示能力和并行计算能力，在NLP任务中取得了显著成果，例如BERT和GPT系列模型。
3.机器翻译
机器翻译是自然语言处理的另一重要任务。传统的基于规则或统计方法的机器翻译系统在处理复杂语言结构和语义时存在局限性。深度学习方法，特别是Encoder-Decoder架构和Transformer模型，为机器翻译带来了突破。这些模型能够捕捉语言的时序依赖性和语义信息，使得机器翻译结果更加准确流畅。
4.对话系统与问答系统
深度学习在对话系统和问答系统中也发挥了重要作用。基于深度学习的生成模型能够生成更加自然和丰富的对话内容。而问答系统则可以通过预训练语言模型，如BERT，对问题进行理解和回答。这些模型能够有效地从大量文本数据中提取知识，提高了问答系统的准确性和可靠性。
三、深度学习在自然语言处理的挑战与未来展望
尽管深度学习在自然语言处理中取得了显著的成果，但仍面临一些挑战。首先，深度学习模型需要大规模语料数据进行训练，对于小语种或特定领域的数据资源较为匮乏。其次，深度学习模型的解释性较差，难以理解其决策过程。此外，深度学习模型在处理复杂语义和长距离依赖时仍存在困难。
1.未来展望：随着技术的不断发展，我们期待更多的创新方法能够解决上述挑战。一方面，无监督和半监督学习方法将在自然语言处理中发挥越来越重要的作用，减少对大规模标注数据的依赖。另一方面，可解释性和可引导性将成为深度学习模型的重要研究方向，提高模型的透明度和可信度。此外，多模态融合、领域适应性和跨语言处理也将是未来研究的热点方向。
五、深度学习在自然语言处理中的实际应用案例
1.智能客服
智能客服是深度学习在自然语言处理中的重要应用之一。通过深度学习技术，智能客服可以理解用户的自然语言输入，并自动回复相关问题。这不仅可以提高客户服务效率，还可以在夜间和节假日提供不间断的服务。例如，阿里巴巴的智能客服“阿里小蜜”和京东的“言犀”都是基于深度学习的智能客服系统，能够有效地解决用户的问题。
2.智能助手
智能助手是另一种深度学习在自然语言处理中的应用。智能助手可以理解用户的语音或文本输入，并提供各种服务，如设置提醒、查询信息、播放音乐等。例如，苹果的Siri和亚马逊的Alexa都是基于深度学习的智能助手，能够为用户提供便捷的生活服务。
3.机器翻译
机器翻译是深度学习在自然语言处理中的又一重要应用。通过深度学习技术，机器翻译系统可以自动将一种语言的文本转换为另一种语言的文本。这极大地促进了跨语言交流和全球化发展。例如，谷歌翻译和微软的Azure翻译都是基于深度学习的机器翻译系统，能够提供高效、准确的翻译服务。
4.舆情监控
舆情监控是深度学习在自然语言处理中的另一个应用场景。通过分析社交媒体上的文本数据，舆情监控系统可以实时监测公众对某一事件或产品的态度和情绪。这有助于企业及时了解市场动态和消费者需求，为决策提供有力支持。例如，基于深度学习的舆情监控系统可以帮助企业快速发现市场趋势和潜在危机。
七、深度学习在自然语言处理中的优化方法
随着深度学习在自然语言处理中的广泛应用，模型优化和加速变得至关重要。下面将介绍几种常见的深度学习优化方法：
1.模型剪枝（Model Pruning）
模型剪枝是一种有效的深度学习优化方法，通过对模型中的权重进行剪枝，去除冗余或次要的连接，从而减小模型的大小并加速推理速度。剪枝后的模型在保持性能的同时，能够显著降低计算和存储开销。
2.知识蒸馏（Knowledge Distillation）
知识蒸馏是一种将大型预训练模型的知识传递给小型模型的策略。通过训练小型模型以模仿大型模型的输出，知识蒸馏能够有效地压缩模型并提高其性能。这种方法在自然语言处理中尤其有效，例如使用Transformer等大型模型作为教师模型，指导小型模型的训练。
3.量化（Quantization）
量化是一种降低模型精度的优化方法，通过将权重和激活从浮点数转换为较低精度的表示（如8位整数），可以显著减小模型大小并加速计算。同时，量化技术还可以在一定程度上减少模型的精度损失。
4.混合精度训练（Mixed Precision Training）
混合精度训练是一种利用不同精度数据类型的优化方法，将模型的权重和激活用较低精度的数据类型表示，以加速训练和推理过程。这种方法可以显著提高模型的训练速度和效率。
5.自适应优化算法（Adaptive Optimization Algorithms）
自适应优化算法是一种能够根据模型性能动态调整学习率的优化方法。通过在训练过程中自动调整学习率，自适应优化算法可以帮助模型更快地收敛，并避免过拟合或欠拟合的问题。常见的自适应优化算法包括Adam、RMSprop等。
六、总结与展望
深度学习优化方法在自然语言处理中发挥着重要的作用，可以有效提高模型的性能、速度和效率。未来，随着计算资源和数据规模的持续增长，我们期待看到更加先进的优化方法和技术，以应对更大规模和更复杂的自然语言处理任务。同时，我们也需要关注深度学习优化方法的可解释性和公平性，以确保其在实际应用中的可靠性和公正性。通过不断的研究和创新，深度学习优化方法将在自然语言处理领域取得更大的突破和成就。
深度学习在自然语言处理中的应用已经取得了令人瞩目的成果，并在实际场景中得到了广泛应用。随着技术的不断发展和语料数据的持续增长，深度学习在自然语言处理中的潜力将进一步释放。未来，我们期待看到更加先进的深度学习模型和方法应用于自然语言处理领域，以解决更加复杂的问题和满足更多的应用需求。同时，我们也需要关注深度学习在自然语言处理中的挑战和限制，如数据质量和标注、模型解释性和泛化能力等。通过不断的研究和创新，我们相信深度学习将在自然语言处理领域取得更大的突破和成就。
深度学习为自然语言处理带来了革命性的变革，广泛应用于词向量表示、文本分类与情感分析、机器翻译、对话系统与问答系统等领域。尽管面临一些挑战，但随着技术的不断进步，我们相信深度学习将在自然语言处理中发挥越来越重要的作用，推动人工智能技术的进一步发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f2a2cffc1c22ea329f8a26bb303fdcb/" rel="bookmark">
			大数据引爆点：数据可视化的飞速发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在信息时代，数据如潮水般涌入，企业和个人面临的挑战前所未有。而在这个数据的浩瀚海洋中，数据可视化如一道明亮的灯塔，引领着信息时代的航行者。近几年，数据可视化以其直观、生动的特性，迅速成为了信息表达和决策分析的重要工具。那么，是什么推动了数据可视化的快速发展呢？
首先，是技术的不断创新推动了数据可视化的发展。随着计算能力的提升和图形处理技术的成熟，数据可视化得以在更大规模和更高维度的数据上展现其优越性。先进的图形处理单元（GPU）和高性能计算（HPC）的应用为数据可视化提供了更强大的支持，使得处理海量数据和实时分析成为可能。
其次，是大数据时代的来临促进了数据可视化的需求。随着大数据技术的普及，企业、科研机构等各个领域面临了海量数据的管理和分析问题。传统的报告和表格已经无法满足快速、直观地理解大数据的需求，而数据可视化则能够将庞大的数据以图形化的方式清晰展现，使得复杂数据变得容易理解。
第三，是信息传递效果的提升加速了数据可视化的普及。在快节奏的社会中，人们对信息的获取有着更迫切的需求，而传统的文字和表格在传递信息上显得繁琐。数据可视化以其生动直观的特点，使得信息一目了然，更容易引起人们的注意和理解。这不仅提高了信息的传递效果，也促进了数据可视化的广泛应用。
这里惯例推荐一下山海鲸可视化这款数据可视化软件，它的数据可视化相关编辑功能全部可以免费使用，并且没有任何限制，甚至如果你制作的是纯二维项目，那么私有化部署也是完全免费的。那么三维项目呢？尽管三维项目无法像二维项目一样免费部署，但是仍然可以免费编辑制作，只是最终导出后会存在水印。不过与同类产品相比，山海鲸可视化的免费化程度可以说是相当高了。
综合来看，技术的创新、大数据的崛起、信息传递效果的提升以及社交媒体的普及，这些因素共同推动了数据可视化近几年的快速发展。在未来，随着科技的不断进步和数据应用的深入，数据可视化必将继续发挥更为重要的作用，为我们的信息世界带来更多的清晰和启示。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/3/">«</a>
	<span class="pagination__item pagination__item--current">4/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/5/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>