<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e8a5b0404d93a9def7c150e6d310a1b/" rel="bookmark">
			问题笔记：java输入出现报错总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当用到输入问题时出现的错误及解决方法总结
问题一：
解决：添加“import java.util.Scanner;”//没有这个运行不了
问题二：
解决：末尾添加“自定义.close();”//不添加也能运行
//“自定义”为——Scanner (自定义)scan = new Scanner(System.in);
犯错误代码：
import java.util.Scanner; public class account { public static void main(String[] args){ double capital=1000;//本金 Scanner scan = new Scanner(System.in); double expend=scan.nextDouble();//输入收入金额 capital += expend; System.out.println(capital);//总金额 scan.close(); } } //注：1.个人笔记，语言描述可能存在不规范，能看懂就行。2.新手，之后会添加新的理解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19de567b4e808c1b08434d419e9c95c8/" rel="bookmark">
			表单input的输入类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		邮箱 Email 必须有@且前后有值
网址 url 必须http开头
数字 number 必须值是数字
范围 range 取值 value默认值中间
颜色 color RGB选择颜色 HSL或16进制进行选择
时间 time date month week
搜索 search 有一键删除功能
以上功能不同浏览器显示效果不同 有些浏览器不支持 存在兼容性问题
多媒体 需要加上控制台（controls）
audio 音频 video 视频 height 高度 weight 宽度 muted 静音 autoplay 自动播放（静音）
poster 封面（视频播放之前显示的一帧）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37268524f3f2a57125597d466bdbe5c3/" rel="bookmark">
			Android 约束布局:ConstraintLayout chain LinearLayout的一些特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		像普通得LinearLayout 可以通过weight 权重得方式来分割大小。
约束布局也可以
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;TextView android:id="@+id/tvA" android:layout_width="wrap_content" android:layout_height="50dp" android:background="@android:color/holo_red_dark" android:gravity="center" android:minWidth="60dp" android:text="A" android:textColor="@color/white" app:layout_constraintEnd_toStartOf="@id/tvB" app:layout_constraintHorizontal_chainStyle="spread" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;TextView android:id="@+id/tvB" android:layout_width="wrap_content" android:layout_height="50dp" android:background="@android:color/holo_red_dark" android:gravity="center" android:minWidth="80dp" android:text="B" android:textColor="@color/white" app:layout_constraintEnd_toStartOf="@id/tvC" app:layout_constraintStart_toEndOf="@id/tvA" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;TextView android:id="@+id/tvC" android:layout_width="wrap_content" android:layout_height="50dp" android:background="@android:color/holo_red_dark" android:gravity="center" android:minWidth="100dp" android:text="C" android:textColor="@color/white" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toEndOf="@id/tvB" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 但是这里需要注意得是左右约束必须写完整 然后使用
app:layout_constraintHorizontal_chainStyle="spread" 就可以十七分为三等分并间隔相同距离
还有其他得属性
换成：
app:layout_constraintHorizontal_chainStyle="spread_inside" app:layout_constraintHorizontal_chainStyle="packed" 非常的时尚。
我们还可以不用chain 使用权重 width =0 and weight=1这样
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37268524f3f2a57125597d466bdbe5c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae33bbacef89bd74f8126bf8acd6108d/" rel="bookmark">
			输出n以内的质数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可以通过scanf语句对n进行赋值，可以输出n以内的所有质数 。
#include&lt;stdio.h&gt; int main() { int a,b,n; int sum; scanf("%d",&amp;n); printf("%d以内的质数为：",n); for(a=1;a&lt;=n;a++) { sum=0; for(b=1;b&lt;=a;b++) { if(a%b==0) sum++; } if(sum==2) printf("%d ",a); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d35440ff9a9c76c10a16dfc353c02a25/" rel="bookmark">
			Android12,SCHEDULE_EXACT_ALARM权限检查值一直返回true
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于Android12升级，在调用精确闹钟的方法的时候，必须进行SCHEDULE_EXACT_ALARM权限的检查。具体操作请参考：适配Android 12的行为变更-----精确的闹钟权限_袁美丽..的博客-CSDN博客_android 闹钟权限
但是最近在做新机种的时候，在S平台上，虽然clock调用了精确闹钟的方法，但是没做SCHEDULE_EXACT_ALARM权限的检查，没有任何影响（正常来说，如果不处理，在调用精确闹钟的方法时肯定会crash）
经过调查发现：
framework给clock进程加了doze mode白名单
&lt;!-- Whitelist of what components are permitted to run in the background --&gt; &lt;allow-in-power-save package="com.android.deskclock" /&gt; 导致canScheduleExactAlarms的值一直返回的是true
AlarmManagerService$mService#canScheduleExactAlarms @Override public boolean canScheduleExactAlarms(String packageName) { ...... if (!isExactAlarmChangeEnabled(packageName, userId)) { // Check the feature flag is on or off return true; } return isExemptFromExactAlarmPermission(packageUid) // ★ Will check DozeMode white list here || hasScheduleExactAlarmInternal(packageName, packageUid); } AlarmManagerService#isExemptFromExactAlarmPermission boolean isExemptFromExactAlarmPermission(int uid) { return (UserHandle.isSameApp(mSystemUiUid, uid) || UserHandle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d35440ff9a9c76c10a16dfc353c02a25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5b655069a58ce9b0a9bbb8e5cb49469/" rel="bookmark">
			Win10快捷键模式退出的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入了快捷键模式虽然可以很好的使用，但是有时候也会带来一些麻烦，因此这个时候就需要将其进行关闭了，为此我们带来了教程，来看看win10快捷键模式怎么退出吧。
更多重装系统教程可在小白系统官网了解
1、首先按下快捷键“win+i”打开windows设置，点击“设备”。
2、然后点击左侧的“输入”。
3、再点击右侧的“高级键盘设置”。
4、点击选择“输入语言热键”。
5、点击“更改按键顺序”。
6、全部选择“未分配”即可。
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd9b9b598804e0d6ebe73ead3866834/" rel="bookmark">
			贝叶斯滤波算法（实例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本的贝叶斯滤波算法 Algorithm Bayes_filter(bel(x[t-1], u[t], z[t])): for all x[t] do: bel_transition(x[t]) = ∫p(x[t] | u[t], x[t-1]) * bel(x[t-1]) * dx[t-1] # 控制更新 bel(x[t]) = η * p(z[t] | x[t]) * bel_transition(x[t]) # 测量更新，η为归一化常数 return bel(x[t]) 实例：利用摄像机来估计门的状态的机器人
假设：门只有开关两种状态，只有机器人能改变门的状态
一、初始置信度 bel(X[0] = open) = 0.5 bel(X[0] = closed) = 0.5 二、测量概率 机器人传感器检测门状态的概率
p(Z[t] = sense_open | X[t] = is_open) = 0.6 p(Z[t] = sense_closed | X[t] = is_open) = 0.4 p(Z[t] = sense_open | X[t] = is_closed) = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dd9b9b598804e0d6ebe73ead3866834/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/258ec97149f1c787c2ba7a0f3b5ca394/" rel="bookmark">
			leetCode_168. Excel表列名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetCode_168. Excel表列名称 一、题目描述 给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。
例如：
A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ... 示例 1： 输入：columnNumber = 1 输出："A" 示例 2： 输入：columnNumber = 28 输出："AB" 示例 3： 输入：columnNumber = 701 输出："ZY" 二、思路 这是一道从 1开始的的 26 进制转换题。
对于一般性的进制转换题目，只需要不断地对 columnNumbercolumnNumber 进行 % 运算取得最后一位，然后对 columnNumbercolumnNumber 进行 / 运算，将已经取得的位数去掉，直到 columnNumbercolumnNumber 为 00 即可。
一般性的进制转换题目无须进行额外操作，是因为我们是在「每一位数值范围在 [0,x)[0,x)」的前提下进行「逢 xx 进一」。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/258ec97149f1c787c2ba7a0f3b5ca394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c7683863d9d39df6bfc0d5257b27d43/" rel="bookmark">
			vscode多行注释，自定义按键多行注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开vscode，点击左下角齿轮图标，然后点击键盘快捷键方式
2.在搜索框搜索注释，找到第一个切换块注释，默认是Shift+Alt+A，双击切换块注释，或者右键选择更改键绑定
3.在输入框依次输入你想设置的按键，最后按enter确定
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516b09ac8ec883575a7fdab8a6c9a615/" rel="bookmark">
			[Kafka] Kafka如何保证消息不丢失、不重复？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Kafka] Kafka如何保证消息不丢失、不重复 Kafka基本架构Kafka如何保证消息不丢失、不重复Kafka消息的丢失和重复可能会发生在哪里？Kafka如何保证`生产者端`的消息不丢失、不重复？生产者端`丢失数据`的情况分析生产者端`丢失数据`的解决办法生产者端`重复发送数据`的情况分析及解决办法消费者端`丢失数据`的情况分析及解决办法消费者端`重复消费数据`的情况分析及解决办法 Kafka基本架构 生产者Producer ：生产信息；消费者Consumer ：订阅主题、消费信息；代理Broker : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个卡夫卡集群 Kafka Cluster；主题topic：可以理解为一个队列， 生产者和消费者面向的都是一个 topic， Producer 将消息发送到特定的主题，Consumer 通过订阅特定的主题来消费消息；分区partition： 为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列。副本Replica： ：副本，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。leader ：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 leader。follower ：每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据的同步。leader 发生故障时，某个 follower 会成为新的 follower。 Kafka如何保证消息不丢失、不重复 Kafka消息的丢失和重复可能会发生在哪里？ 根据以上的Kafka架构图，我们推测一下，消息丢失可能会发生在哪里？
生产者丢失数据
消费者丢失数据
那么消息重复消费可能会发生在哪里？
同样也是在消费者端和生产者端，即：
生产者重复发送数据
消费者重复消费数据
如何保证消息的有序？
同步发送模式：发出消息后，必须等待阻塞队列收到通知后，才发送下一条消息；同步发送模式可以保证消息不丢失、又能保证消息的有序性。
异步发送模式：生产者一直向缓冲区写消息，然后一起写到队列中；好处是吞吐量大，性能高。
Kafka如何保证生产者端的消息不丢失、不重复？ 生产者端丢失数据的情况分析 生产者端使用同步发送模式，有三种状态保证消息被安全生产，即配置acks参数（默认为1）：
● 1：集群的leader节点收到消息后，就可以发回成功写入的通知
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/516b09ac8ec883575a7fdab8a6c9a615/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b58201c4650a6b506fbdad98da50e384/" rel="bookmark">
			scoped 覆盖样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		scoped 覆盖样式 覆盖原理参考资料 覆盖原理 在组件中使用style设置样式会全局生效，如el-button；当加上scoped会在每个样式的最后生成特殊属性，如data-v-469af010 下面举例说明
&lt;template&gt; &lt;div class="hello"&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;el-button type="primary"&gt;hello&lt;/el-button&gt; &lt;el-select v-model="value"&gt; &lt;el-option :value="1"&gt;1&lt;/el-option&gt; &lt;el-option :value="2"&gt;2&lt;/el-option&gt; &lt;/el-select&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt; h1 { color: red; } .el-select .el-input__inner { background-color: violet; } &lt;/style&gt; &lt;style&gt; .el-button { background-color: pink; } &lt;/style&gt; 结果样式如下图
使用了scoped，h1解析为h1[data-v-469af010]，Hello样式生效，不影响Hi.el-button不使用scoped，样式全局生效，影响到其他组件.el-select .el-input__inner解析为.el-select .el-input__inner[data-v-469af010]；因为图中 input 输入框无data-v-469af010属性，故不生效，假如给该元素手动加上这个属性，样式生效，如下图
在编写组件样式时，正常情况下需要使用scoped达到样式隔离，这就意味着不能直接使用&lt;style&gt;&lt;/style&gt;的方式全局修改，需要使用&lt;style scoped&gt;&lt;/style&gt;的方式。
当需要更改第三方组件内部样式时，可css使用&gt;&gt;&gt;、less使用/deep/的方式，样式解析后外层元素套上data-v-469af010，代码更改为
.el-select &gt;&gt;&gt; .el-input__inner { background-color: violet; } .el-select &gt;&gt;&gt; .el-input__inner解析为.el-select[data-v-469af010] .el-input__inner，达到样式隔离的目的
参考资料 Vue scoped与覆盖第三方组件样式
vue中慎用style的scoped属性
此文章如有不足之处，希望大家在评论区一起交流哦！谢谢大家！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bf229279b77e7a0c38eeb1664cebd94/" rel="bookmark">
			C语言实现汉诺塔【图文讲解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期介绍🍖 主要介绍：汉诺塔是什么，汉诺塔的规律，如何用C语言来实现汉诺塔👀。
目录 什么是汉诺塔如何用C语言实现汉诺塔 什么是汉诺塔 汉诺塔（Tower of Hanoi），又称河内塔。源自印度古老传说的一个游戏，大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。
若每次移动需要1s的时间，那么请问婆罗门需要多久才能把这64片黄金圆盘从一根石柱上移动到另一个石柱上？
若只有1个圆盘时，需要移动1次；若有2个圆盘时，需要移动3次；若有3个圆盘时，需要移动7次……不难看出，汉诺塔步数的数学规律为2的n次方减1（n为柱子上的圆盘个数）。所以若有64个圆盘那将会移动2^64-1次（即：18,446,744,073,709,551,615‬次），若每次移动需要1s时间，则需要将近5849亿年的时间才能够做到。可见大梵天有多恨婆罗门，这绝对是在坑人啊！！！
如何用C语言实现汉诺塔 现有三个柱子A、B、C，其中有n个圆盘在A柱上，最终要实现把这n个圆盘从A柱借助B柱移动到C柱上。实现实现思路：先将n-1个圆盘从A柱移动到B柱上，然后将A柱上最后一个圆盘移动到C柱上，最后再把B柱上的n-1个圆盘移动到C柱上。如下图所示：
当n=1时：
1.将A柱上最后一个圆盘移动到C柱上（A →C）
当n=2时：
1.将1个圆盘从A柱移动到B柱上，重复n=1时的步骤，只不过是将那1个圆盘（从A借助于B移动到C）改为（从A借助于C移动到B）
2.将A柱上最后一个圆盘移动到C柱上（A →C）
3.将B柱上的1个圆盘移动到C柱上。重复n=1时的步骤，只不过是将那个圆盘（从A借助于B移动到C）改为（从B借助于A移动到C）
当n=3时：
1.将2个圆盘从A柱移动到B柱上。重复n=2时的步骤，只不过是将那2个圆盘（从A借助于B移动到C）改为（从A借助于C移动到B） 2.将A柱上最后一个圆盘移动到C柱上（A →C）
3.将B柱上的2个圆盘移动到C柱上。重复n=2时的步骤，只不过是将那2个圆盘（从A借助于B移动到C）改为（从B借助于A移动到C）
当n=4时：
1.将3个圆盘从A柱移动到B柱上。重复n=3时的步骤，只不过是将那3个圆盘（从A借助于B移动到C）改为（从A借助于C移动到B） 2.将A柱上最后一个圆盘移动到C柱上（A →C）
3.将B柱上的3个圆盘移动到C柱上。重复n=3时的步骤，只不过是将那3个圆盘（从A借助于B移动到C）改为（从B借助于A移动到C）
以此类推，当汉诺塔上的圆盘数为n个时该如何移动，只需要按照上面的规律一直往上递归，最终是可以达到目的的。程序如下：
#include&lt;stdio.h&gt; void move(char A, char C, int n) { printf("把第%d个圆盘从%c---&gt;%c\n", n, A, C); } void HanoiTower(char A, char B, char C, int n) { if (n == 1) { move(A, C, n); } else { //将n-1个圆盘从A柱借助于C柱移动到B柱上 HanoiTower(A, C, B, n - 1); //将A柱子最后一个圆盘移动到C柱上 move(A, C, n); //将n-1个圆盘从B柱借助于A柱移动到C柱上 HanoiTower(B, A, C, n - 1); } } int main() { int n = 0; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bf229279b77e7a0c38eeb1664cebd94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0129016d9269c9240787f7d9d890a94b/" rel="bookmark">
			JVM的类加载过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM 的类加载阶段 JVM 的类加载分为五个阶段：
1. 加载：被虚拟机读入内存
2. 验证：验证 Class 字节流的数据是否遵守JVM的规定
3. 准备：正式为类变量（静态变量）分配内存并设置初始值，并非代码中设置的值
4. 解析：将常量池中的符号引用解析为直接引用
5. 初始化：真正执行类中定义的java代码
加载 指 JVM 读取 class 文件，并且根据 Class 文件描述创建 java.lang.Class 对象的过程。
类加载过程主要包含将 Class 文件读取到运行时区域的方法区内，在堆中创建 java.lang.Class 对象，并封装类在方法区的数据结构的过程。
在读取 Class 文件是既可以通过文件的形式读取，也可以通过 jar 包、war 包读取，还可以通过代理自动生成 Class或其他方式读取
验证 主要用于确保 Class 文件符合当前虚拟机的要求，保障虚拟机自身的安全，只有通过验证的 CLass 文件才能被 JVM 加载
准备 主要工作是在方法区中为类变量分配内存空间并设置类中变量的初始值。
初始值指不同数据类型的默认值，这里需要注意 final 类型的变量和非final类型的变量在准备阶段的数据初始化过程不同
例如一个成员变量定义如下：
public static long value = 1000;
在以上代码中，静态变量 value 在准备阶段的初始值是0，将 value 设置为 1000 的动作是在对象初始化时完成的，因为 JVM 在编译阶段会将静态变量的初始化操作定义在构造器中。
public static final int value = 1000;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0129016d9269c9240787f7d9d890a94b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffb4ce39c0077ec5214d3d5bb8a6011c/" rel="bookmark">
			饿了么（elementUI）组件库如何在vue项目中使用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方组件库地址：Element - The world's most popular Vue UI frameworkhttps://element.eleme.cn/#/zh-CN
elementui是做PC项目的首选
创建项目并引入element组件库 用vue-cli脚手架创建vue项目 找一个合适的文件夹，打开cmd窗口，用vue create 创建项目
命令：vue create 自定项目名
vue create element-demo ------------------------------- ? Please pick a preset: &gt; Default ([Vue 2] babel, eslint) Default (Vue 3 Preview) ([Vue 3] babel, eslint) Manually select features 直接 回车 注意：
vue create 命令会自动创建文件夹，这样就不需要我们手动创建了
选择Vue2 版本的默认配置
如果vue create 命令不能正常运行，要先安装脚手架工具， 对应的命令是： npm i -g @vue/cli
然后运行vue项目：命令： npm run serve 输入http://localhost:8080 查看
把ElementUI添加到项目中 参考官网文档，按全局引入的方式，一共分成两步：
安装elementUI 命令：npm i element-ui -S
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffb4ce39c0077ec5214d3d5bb8a6011c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9981a7266ed6a0bd66c917fd01e0119/" rel="bookmark">
			apollo配置druid实时自动更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在apollo官方描述配置变化时自动更新时，提到有两种方法：
EnvironmentChangeEvent 或 RefreshScope
1.这里描述一下用EnvironmentChangeEvent中遇到的坑，
apollo推荐的demo是在监听中用下面代码更新
this.applicationContext.publishEvent(new EnvironmentChangeEvent(changeEvent.changedKeys())); 如果更改数据源配置的话，druid会抛出个异常，因为在druid的bean设置值的时候会判断druid是否初始化
以下为DruidAbstractDataSource.java中setUrl()，如果初始化过了就会抛出一个异常。这就需要我们人工手动关闭Druid中的数据库连接，且设置为未初始化，个人技术不到位，试了几次都有其他异常。
public void setUrl(String jdbcUrl) { if (StringUtils.equals(this.jdbcUrl, jdbcUrl)) { return; } //如果初始化就会抛出异常 if (inited) { throw new UnsupportedOperationException(); } if (jdbcUrl != null) { jdbcUrl = jdbcUrl.trim(); } this.jdbcUrl = jdbcUrl; // if (jdbcUrl.startsWith(ConfigFilter.URL_PREFIX)) { // this.filters.add(new ConfigFilter()); // } } 2.于是我们采用了第二种方式RefreshScope
在Druid配置类中添加注解 @EnableApolloConfig @RefreshScope
@Configuration @EnableApolloConfig public class DruidConfig { @RefreshScope @ConfigurationProperties(prefix="spring.datasource") @Bean public DataSource druid() { return new DruidDataSource(); } } 在apollo监听类中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9981a7266ed6a0bd66c917fd01e0119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecea24feb3b7c807769fc13368dcd6cf/" rel="bookmark">
			C语言——字符串指针篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：
本文章旨在总结备份、方便以后查询，由于是个人总结，如有不对，欢迎指正；另外，内容大部分来自网络、书籍、和各类手册，如若侵权请告知，马上删帖致歉。
QQ 群 号：513683159 【相互学习】
来源：
C语言中文网
文章目录 前提知识字符串（字符数组）注意事项字符串处理函数字符串连接函数 strcat()【 string catenate】字符串复制函数 strcpy()【string copy】字符串比较函数 strcmp()【string compare】 字符串指针（指向字符串的指针） 前提知识 字符串（字符数组） 在C语言中没有专门的字符串数据类型：string，一般通过数组的方法来实现，称为字符数组（存放字符的数组，实际上一系列字符集合（字符串）），如：
char str[]="hello world!"	/这种写法最简洁，也可写为: char str[20]={"hello world!"} 要注意：字符数组 只有在定义时才可一次性赋值，一旦定义完就只能一个个赋值
，如：
char str[4]; str = "abc"; /错误 str[0] = 'a'; str[1] = 'b'; str[2] = 'c';	/正确 注意事项 ①字符串是一系列连续字符。若想在内存中定位一个字符串，不仅要知道开头，还需知道结束。开头就是数组名（或字符串名）但结束呢？
C语言是通过\0表示结尾，故\0又称为：字符串结束标志符（位于ASCII码表中第0个字符或称NULL或称空字符。该字符没有任何效果）
②C语言中，一般在用" "包围字符串下自动末尾添加\0,如：char[]="abc";,逐个赋值不会自动添加\0
③注意字符串长度大于数组时可能会为以后错误埋下伏笔，故正确做法若是长度为3的字符串，数组长度为4.
④在函数内部定义的变量、数组、结构体、共用体都被称为局部数据。很多编译器下局部数据初始值都是随机的，无意义的值而不是“零”值。故若未给字符数组赋初值0，则可能输出会出现输出超过数组长度的值或其他奇葩问题，故可通过：
1）手动在字符串最后添加\0，如：str[i] = 0
2）只初始化部分数组元素，那么剩余的数组元素也会自动初始化为“零”值,如：char str[30] = {0}; //将所有元素都初始化为 0，或者说 '\0'
⑤字符串长度函数：strlen()函数,用法：length strlen(strname);
#include&lt;stdio.h&gt; #include&lt;string.h&gt; /使用strlen需该头文件 int main(){ char string[3] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecea24feb3b7c807769fc13368dcd6cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4185e80f334237429b15a81938cdfb2/" rel="bookmark">
			[深度学习]note for Machine Learning: An Algorithmic Perspective, Second Edition（Ch04-Ch06）【日常更新】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Machine Learning: An Algorithmic Perspective, Second Edition——Part 2 4. 多层感知器4.1 前向4.1.1 偏置 4.2 后向：误差的反向传播4.2.1 多层感知器算法4.2.2 初始化权重4.2.3 不同的输出激活函数4.2.4 顺序和批量训练4.2.5 局部最小4.2.6 利用冲量4.2.7 小批量和随机梯度下降4.2.8 其他改善方法 4.3 实践中的MLP4.3.1 训练数据的量4.3.2 隐藏层的数目4.3.3 什么时候停止学习 4.4 MLP应用示例4.4.1 回归问题 4. 多层感知器 我们感兴趣的大部分分体是非线性可分的——找到一种合适的转换特征的方式使问题线性可分；
神经网络中的学习与权重有关——为了进行更多的运算，就要加入更多的权重——① 加入后向的连接，以便于输出神经与输入联系起来——循环网络（recurrent network），已有研究，但并不经常使用；② 加入更多神经元——在输入节点与输出节点之间加入神经元，使神经网络更复杂；
加入额外的层会使神经网络更有用——解决XOR问题：
检查不同的输入结果可以看出上述网络可以实现XOR函数问题。
如何训练这种多层网络使得权重产生合适的正确目标——计算输出的误差——但不知道哪一个权重是错误的：在第一层还是在第二层；同时也不知道网络中间的神经元的正确激活是什么——隐藏层（hidden layer）：不可能去检查并且直接修正它们的值——多层感知器MLP（Rumelhart、Hinton、MeClelland，1986）；
MLP是最常用的神经网络之一，通常被视为“黑匣子”——人们在不了解其工作原理的情况下使用它，这通常会导致相当差的结果。
4.1 前向 训练MLP由两部分组成：① 前向（forward）：对于给定的输入和当前的权重，计算输出；② 后向（backward）：根据误差对权重进行更新——误差：表示输出和目标之间差别的函数；
前向——再现阶段：沿着网络计算每层神经元是否激活，并用与下一层的输入。
4.1.1 偏置 需要使每一个神经元包含一个偏置输入（-1），并且调整每个神经元的权重作为训练的一部分——在网络中的每个神经元（无论是隐藏层还是输出层）都有一个格外 的输入，且为定值。
4.2 后向：误差的反向传播 误差的反向传播（back-propagation of error）：误差通过网络向后传播，是梯度下降（gradient descent）的一种形式——用数学来表述反向传播的性质。
在感知器中，改变权重以便于当目标认为一个神经元应该激活时这个神经元激活，而目标认为这个神经元不能激活时，它就不激活——为每一个神经元k选择预估误差函数Ek=yk-tk，并试图让其最小——此时网络只有一组权重，所以足以训练网络。
加入额外层（隐藏层）的权重，使得最小化误差难以安排——在尝试调整多层感知器的权重时，需要知道是哪一个权重引起的误差：可能是连接输入层和隐藏层的权重，或者是连接隐藏层和输出层的权重——对于更复杂的网络，在隐藏层中节点之间会有额外的权重，可以用相同的方法解决，但更难讨论，此处只考虑一层隐藏层。
感知器使用的误差函数为： ∑ k = 1 N E k = ∑ k = 1 N y k − t k \sum\limits_{k=1}^{N}{{{E}_{k}}}=\sum\limits_{k=1}^{N}{{{y}_{k}}}-{{t}_{k}} k=1∑N​Ek​=k=1∑N​yk​−tk​，N为输出节点的数量，假设存在两个误差点：一个目标大于输出，一个输出大于目标，而这两个误差的大小相同，则和为0——算法认为没有误差——需要让所有的误差都具有相同的符号——平方和（sum-of square）误差函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4185e80f334237429b15a81938cdfb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17651af2dc488141c57718cfeea2b678/" rel="bookmark">
			leetCode_125. 验证回文串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetCode_125. 验证回文串 一、题目描述 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
示例 1: 输入: "A man, a plan, a canal: Panama" 输出: true 解释："amanaplanacanalpanama" 是回文串 示例 2: 输入: "race a car" 输出: false 解释："raceacar" 不是回文串 二、思路 最简单的方法是对字符串进行一次遍历，并将其中的字母和数字字符进行保留，放在另一个字符串 中。这样我们只需要判断是否是一个普通的回文串即可。
三、具体实现 class Solution { public boolean isPalindrome(String s) { StringBuffer sgood = new StringBuffer(); int length = s.length(); for (int i = 0; i &lt; length; i++) { char ch = s.charAt(i); //isLetterOrDigit（）确定则字符被认为是字母或数字 if (Character.isLetterOrDigit(ch)) { //Character.toLowerCase(ch)将所有字母转化为小写的 sgood.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17651af2dc488141c57718cfeea2b678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a61c98893f7393fc48627b4d7f940b96/" rel="bookmark">
			教你使用Java制作倒计时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 根据自己的业务需求可以指定倒计时的时间。（年、月、日、时、分、秒）,以下代码已经测试，直接拿走使用，不用谢！
代码 import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; public class CountDownController { static String countdown = ""; public static void main(String[] args) { //开启倒计时 time(); System.out.println("Countdown=" + countdown); } /** * 倒计时,设定时间戳 */ private static void time() { Calendar c = Calendar.getInstance(); // 根据自己的需求进行加/减（年、月、日、时、分、秒），例如：当前日期的下一个月的当前日期：(c.get(Calendar.MONTH) + 1) c.set(c.get(Calendar.YEAR), (c.get(Calendar.MONTH)), c.get(Calendar.DAY_OF_MONTH), c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), c.get(Calendar.SECOND)+10);// 注意月份的设置，0-11表示1-12月 // 结束日期 long endTime = c.getTimeInMillis(); System.out.println("结束的时间："+ endTime); // 查看结束日期 SimpleDateFormat sdf = new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a61c98893f7393fc48627b4d7f940b96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c58f47b6a21194f6ba42fd0aefffea5/" rel="bookmark">
			3.7 欧拉函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欧拉函数(Euler’s totient function)，也叫φ函数，入参只能是正整数。定义是从1到N这N个数里，和N互质的数的个数。欧拉函数没有通项公式，只有分段递归公式。下面是1~10的欧拉函数值：
x12345678910φ(x)1122426464 欧拉函数最简单的算法是循环。但是这个计算方法非常费时。高斯证明了以下一个公式：
∑ d ∣ n ϕ ( d ) = n \sum_{d|n}\phi(d)=n d∣n∑​ϕ(d)=n
这里的d|n的意思是遍历n所有的约数。比如10的所有约数是1，2，5，10。这个公式没有恰当的翻译，我姑且翻译为约数欧拉函数和。所以应用上述公式有：
ϕ ( 1 ) + ϕ ( 2 ) + ϕ ( 5 ) + ϕ ( 10 ) = 10 \phi(1)+\phi(2)+\phi(5)+\phi(10)=10 ϕ(1)+ϕ(2)+ϕ(5)+ϕ(10)=10
验证下哈,确实没错：
ϕ ( 1 ) + ϕ ( 2 ) + ϕ ( 5 ) + ϕ ( 10 ) = 1 + 1 + 4 + 4 = 10 \phi(1)+\phi(2)+\phi(5)+\phi(10)=1+1+4+4=10 ϕ(1)+ϕ(2)+ϕ(5)+ϕ(10)=1+1+4+4=10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c58f47b6a21194f6ba42fd0aefffea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e850c7007dce8093ba3099aa41989c4/" rel="bookmark">
			C# Execl创建，读取，写入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、内容二、使用步骤1.使用OleDB读取execl2.创建execl文件3.写入execl数据 一、内容 本文包含了使用C# OleDB读取execl表格内容，Microsoft.Office.Interop.Excel创建execl，写入数据等基础操作实例，非专业，可参考，有问题请指正包含。
二、使用步骤 在IDE中找到项目,添加引用，在.NET下找到Microsoft.Office.Interop.Excel并添加至项目
1.使用OleDB读取execl 读写execl的方法比较多，这里主要使用OleDB，读取出来的数据更方便操作，使用VS2011开发的命令行窗口程序。
首先引入相关头文件
using System.Data.OleDb; using System.Data; using System.Data.SqlClient; using System.IO; using Excel = Microsoft.Office.Interop.Excel; 读取数据代码实例，注释已说明步骤
//检查你要读取的execl文件是否存在（保证程序友好） string filepath = Directory.GetCurrentDirectory(); string newpath = Path.Combine(filepath, "XX.xlsx"); //以XX为例 if (!File.Exists(newpath)) { Console.Write("XX.xlsx文件不存在！"); return; } string pathName="IP.xlsx"; string strCon = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" + pathName + ";Extended Properties='Excel 12.0;HDR=Yes;IMEX=1;'"; //1.使用数据源与excel连接 OleDbConnection connection =new OleDbConnection(strCon); //2.打开连接 connection.Open(); //3.查询命令，与sql查询类似 string sql ="select * from [Sheet1$]"; //3.1 查询适配器，OleDbDataAdapter 返回的是datatable类型的数据 OleDbDataAdapter adapter = new OleDbDataAdapter(sql, connection); // 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e850c7007dce8093ba3099aa41989c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/443252d4ee6e0407b2525f7f09aceb10/" rel="bookmark">
			-Dmaven.test.skip=true 和 -DskipTests 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-DskipTests ，不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下。-Dmaven.test.skip=true ，不执行测试用例，也不编译测试用例类。 执行mvn clean 再执行 mvn clean install -Dmaven.test.skip=true
执行 mvn clean 再执行 mvn clean install -DskipTests
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/492586dd68577679d3cb3b85588e8cab/" rel="bookmark">
			(四)孪生神经网络介绍及pytorch实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎访问个人网络日志🌹🌹知行空间🌹🌹
孪生神经网络介绍及pytorch实现 1.孪生神经网络2.孪生神经网络的损失函数2.1 Triplet Loss2.2 Contrastive Loss3.动手实现一个孪生网络3.1 网络结构3.2 损失函数3.3 数据3.4 训练结果 4.SiameseNetWork的一些应用参考资料 1.孪生神经网络 在深度学习领域，神经网络取得了成功。但普通的神经网络模型的训练需要大量的数据，对于一些数据有限的场景，如人脸验证，签字验证，必须考虑其他方法。
Siamese 古语表示瞿罗，即现在的泰国，如Siamese cat，之所以Siamese表示孪生，是因为19世纪瞿罗出了一对连体双胞胎，在美国玲玲马戏团做演出比较出名，因此提起Siamese即表示孪生的意思。1
孪生神经网络Siamese Network,如其名字孪生Siamese的意思即存在连体，连体即彼此共享一部分。孪生神经网络的结构也包括两个子网络，两个子网络之间共享权重。
&gt; 图片来自于1 如上图，两个网络是同一个并共享权重，当两个子网络不共享权重时，通常定义为伪孪生神经网络。
图片来自于1
从上面的图中可以看出来，孪生神经网络有两个输入，input1和input2，因此孪生神经网络常用来通过比较两个输入特征向量的距离来衡量两个输入的相似度。早在1993年的NIPS上Yann Lecun就发表了使用孪生神经网络做签名验证的论文。现在的人脸识别应用也有基于孪生神经来做的。
孪生神经网络的优点，对于类别不平衡问题更鲁棒，更易于做集成学习(Ensemble Learning),可以从语义相似性上学习来估测两个输入的距离。孪生神经网络的缺点，由于有两个输入，两个子网，其训练相对于常规网络运算量更大，需要的时间更长。输出的结果不是概率，孪生神经网络时成对的输入，其输出是两个类间的距离而不是概率。
2.孪生神经网络的损失函数 由与孪生神经网络是计算的两个输入的相似度，距离，而不是对输入做分类，因此交叉商损失函数不适用于此种场景，孪生神经网络的常用的损失函数有Triplet Loss和Contrastive Loss。
2.1 Triplet Loss Triplet Loss三元组损失函数，其应用见谷歌2015年发表在CVPR上的做人脸验证的论文facenet。该损失函数定义一个三元组作为输入，分别是 ( X a n c h o r , X p o s i t i v e , X n e g a t i v e ) (X_{anchor},X_{positive},X_{negative}) (Xanchor​,Xpositive​,Xnegative​)这三个输入的通过如下方式构成，先从训练数据集中随机选一个样本作为Anchor,再随机选取一个和Anchor属于同一类的样本作为正样本 X p o s i t i v e X_{positive} Xpositive​，和一个不同类的样本作为负样本 X n e g a t i v e X_{negative} Xnegative​，通过这种方式定义一个输入的三元组 ( X a n c h o r , X p o s i t i v e , X n e g a t i v e ) (X_{anchor},X_{positive},X_{negative}) (Xanchor​,Xpositive​,Xnegative​)，将其输入到网络可以得到对应的特征向量 [ f ( X a n c h o r ) , f ( X p o s i t i v e ) , f ( X n e g a t i v e ) ] [f(X_{anchor}),f(X_{positive}),f(X_{negative})] [f(Xanchor​),f(Xpositive​),f(Xnegative​)],Triplet Loss的目的是通过训练，使得同种类别的距离更近，不通类别的距离更大，即拉近anchor与positive推远anchor和negative,如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/492586dd68577679d3cb3b85588e8cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd92f0b01b13258c51d6c3215103e634/" rel="bookmark">
			Excel数据透视表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一节课-什么是数据透视表 如果需要对数据源进行分类汇总（或者是分类计数，或者是分类平均值等），就可以用数据透视表来解决。它的优点是高效，易操作（相对函数） 第二节课-创建数据透视表 选中数据源-插入选项卡-数据透视表-打开了创建数据透视表对话框，选择数据透视表放置的位置-确定数据透视表字段对话框，可以在设计选项卡中显示组，选中数据字段显示或不选中不显示数据透视表字段对话框字段拖到行标签的意思，是对此字段的记录进行去重，结果放在一列中的各行字段拖到列标签的意思，是对此字段的记录进行去重，结果放在一行中的各列字段拖到值区域的意思，是根据行标签或列标签里字段去重的结果，进行汇总筛选区域，也是对字段记录进行去重，但是是起到筛选的作用并不是每一个区域都必须有字段才行一个区域也可以有多个字段，比如行标签有两个字段，那么上面的就是父字段，下面的是子字段 第三节课-数据源规范 数据源区域每一列必须有表头，不能空白数据源中同一类记录必须在一列中，不能分布在多列中数据源中表头不能是合并单元格数据源中字段中的记录不能有合并单元格，同一记录不能用两种形式表示数据源中字段不能有计算行数据源中的数据类型要规范 第四节课-数据透视表的布局1 把各个字段在四个区域中拖动其实就是改变了数据透视表的布局除了拖动字段，还可以在字段列表中右键，选择添加到哪个区域中 已经在四个区域中的字段，点开下拉菜单，可以上下移动（如果有多个字段，可以改变其上下位置），或者是移动到其他区域中，也可以删除字段
在数据透视表上，在相应的字段上右键，也可以选择删除字段，或者是移动字段
筛选区域的设置改变布局：选择选择多项，可以进行多条件的筛选 数据透视表上右键，打开数据透视表选项-布局和格式-然后可以改变筛选字段的是纵向并排还是横向并排
在分析选项卡中，数据透视表组，点开选项，选择显示报表筛选页，可以按筛选字段把数据分布在独立的工作表中
4、2003版本经典布局样式：右键打开数据透视表选项-显示-勾选经典布局样式，可以直接将字段拖到数据透视表上。
第五节课-数据透视表的布局2 重命名数据透视表上的字段名：选中，在编辑栏中重新命名，注意，不能和之前的字段名一致，若要一样，可以加一个空格 批量修改，可以用查找替换，把计数项或汇总项替换成空格
显示or隐藏行标签或列标签，到分析选项卡，显示组，字段标题去掉选中或选中分析选项卡中，可以设置展开或折叠字段，或者在相应字段上右键设置 在分析选项卡显示组，加减号按钮显示or隐藏
报表布局：压缩形式，大纲形式，表格形式 分类汇总：可以显示或不显示，也可以设置显示在组上方或下方
总计：不显示或只显示行或只只显示列
空行：在每一组下方插入一行空行，以做区分作用
第六节课-更改数据源和刷新数据透视表 数据源添加记录，需要在分析选项卡中，点击更改数据源，重新选择数据源区域，然后再点击分析选项卡中的刷新按钮即可更新到最新结果也可以在数据透视表上右键，点击刷新给数据源套用开始选项卡中的表格样式，使它变成列表形式，那么再添加或删除数据源的记录，数据源范围会自动更新，只需要右键刷新下即可在数据透视表选项中，可以在 数据 选项中，勾选打开文件时刷新数据，即可实现每次打开文件，都会自动刷新如果是通过外部数据源创建的数据透视表，还可以在分析选项卡-更改数据源-连接属性中，设置刷新的频率。注意只有是外部数据源的数据透视表才有此功能如果数据源数据非常多，每一次拖动字段都会卡（电脑计算一会），那么可以点击 推迟布局更新，等所有字段都托好了，手机点击更新按钮。最后记得去掉这个勾，因为会影响到排序筛选等当我们删除了数据源中的相同项的数据，刷新数据透视表结果会更新，但是在筛选里仍然会有此项，若要删除，可以在数据源选型中—数据，把保留从数据源删除的项目—每个字段保留的项数改成 无， 再刷新下数据透视表即可。 第七节课-数据透视表的格式设置 可以在设计选项卡-数据透视表样式组，套用样式，同时可以设置行标题列标题，镶边行和镶边列我们可以手动设置数据透视表的字体、字号、边框、颜色填充、列宽、数值格式等在数据透视表选项中，建议不勾选 更新时自动调整列宽，和勾选 更新时保留单元格格式。值区域里的空单元格，可以在数据透视表选项里设置空单元格显示成什么 错误值也可以设置显示成什么
如果行标签或列标签中有（空白），可以使用查找替换方式替换掉在数据透视表中也可以使用条件格式，和普通表格使用方法一样 第八节课-数据透视表的排序和筛选 在相应的字段上右键-排序可以选择升序或降序，默认是升序排序的在行标签里的字段排序是对这一列进行排序，在列标签里的字段进行排序是对这一行排序，如果对值区域里的一个单元格排序，那么默认是对这一列进行排序，如果想对这一行排序，可以右键-排序-其他排序选项-选择方向-从左到右注意，排序时定位一个单元格即可，选中一行或一列是不能排序的如果想按自己的想法排序，可以定位到一个单元格，然后鼠标指针放在边缘，变成四向箭头的时候拖动，可以移动它的位置，也可以右键-移动-上下移动或移动到头或尾另一个方法是先到 文件-选项-高级-自定义序列-先添加顺序，然后再升序排序即可在行标签或列标签下拉选项里可以勾选需要显示的项即可完成筛选也可以在行标签或列标签下拉选项里进行搜索完成筛选，针对项比较多的情况可以使用标签筛选，等于，不等于，开头是等等等。行标签里的值筛选是筛选与行标签对应的总计里的数值，列标签里的值筛选是与列标签对应的总计里的数值若要对值区域里其他列进行筛选，可以把活动单元格定位到数据透视表表头旁边，但不能定位到数据透视表上，然后在数据选项卡里，选择筛选，除了常规的筛选，还可以按颜色来筛选（如果有颜色的话） 第九节课-切片器 切片器也是用来筛选的，但是它不仅可以让数据透视表显示筛选结果，也可以直观显示哪些数据项被筛选了选中数据透视表-分析选项卡或者插入选项卡都可以插入切片器点击切片器中的某一个字段项即可完成筛选了，若要筛选多个字段项，可以先选中多选按钮，就可以多选了，或者没有选中 多选按钮，安住ctrl键也可以多选一个切片器是可以控制多个数据透视表的，操作是，两个或多各数据透视表的数据源必须一致，然后在数据透视表上右键选择报表连接，-勾选要连接的数据透视表确定。这样在一个切片器中筛选，两个或多个连接了的数据透视表都会起作用把鼠标指针放在边缘变成四向箭头的时候拖动，就可以移动切片器了可以在选项选项卡中，设置筛选字段的列数，也可以设置选项按钮的大小选中切片器可以在四角拖动改变切片器的大小在切片器上右键，可以排序，也可以在切片器设置里设置排序，还可以在选项选项卡里套用样式在切片器设置里，去掉删除数据源选项的勾，可以在切片器上不显示已经删除的项切片器设置里的其他设置，可以修改切片器的名称，设置是否显示页眉等 第十节课-项目组合1 分析选项卡-组合组-分组选择:它的作用是把不同类的项组合到一起(右键-组合也是此功能)手动组合方法: 在数据透视表上,把需要组合到一起的项移动到一起,然后选中,右键-组合.即为他们添加了一个父级字段, 即把他们都组合到一起了不使用组合功能, 也能实现把不同类的项组合到一起, 方法是: 在数据源中添加辅助列, 把需要组合到一起的项都在新列中对应相同的名称, 那再用新数据源插入数据透视表,把新列字段拖到行标签, 就是组合的效果了 第十一节课-项目组合2 对于数值型字段，可以使用手动组合，也可以使用自动组合步骤：选中此字段的一个单元格，右键-组合，打开组合对话框，设置规律，即起始于、终止于 和步骤，告诉excel了规律，excel就会按此规律自动分组了因为文本字段的分组无规律可循，所以只能使用手动分组若数值字段的分组要求无规律，也不能使用自动分组对于数值型字段也是可以在数据源中添加辅助列的方式来完成分组的 第十二节课-项目分组3 日期可以按年月日时分秒来分组步骤：在日期字段上右键-组合，选择相应的分组要求（年月日时分秒）只有数据源中的日期是规范日期，创建的数据透视表才能进行自动的分组Excel不能识别的分组要求，可以在数据源中添加辅助列的方法来分组（见视频中例子）总结：文本字段只能用手动分组 数值字段可以使用手动也可以使用自动分组
日期字段可以使用手动也可以使用自动分组
以上分组效果都能在数据源中添加辅助列完成分组（不使用分组功能）
自动分组无法完成的，也能在数据源中添加辅助列完成分组
第十三节课-值的汇总方式和显示方式 对于拖到值区域里的字段，如果是数值，默认是求和汇总，我们也可以修改成过计数，平均数，最大值，最小值，等值的显示方式：见表 序号
选项
功能描述
1
无计算
数据区域字段显示为数据透视表中的原始数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd92f0b01b13258c51d6c3215103e634/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd2ed08b3e4fce1d41e048d4228626e/" rel="bookmark">
			关于宝塔面板数据库管理报EDIT_ERROR‘latin-1‘ codec can‘t encode characters in position 5-7: ordinal not in range(
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 刚刚在使用宝塔面板的数据库管理时遇到了一个问题，当我的root密码修改成中文字符后导致我的整个数据库管理无法正常使用。重新修改root密码会报错，如下图
对数据库进行权限等各种操作无反应，请求接口报错500.如下
解决办法 找到文件connections.py www/server/panel/pyenv/lib/python3.7/site-packages/pymysql/connections.py 将文件中的.encode('latin-1')改成.encode("utf-8") 改之前 self.password = self.password.encode('latin-1') 改之后 self.password = self.password.encode("utf-8") 打开宝塔首页点击修复
检验是否成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34860f9e7d66c960f9c8211fd44c0c3/" rel="bookmark">
			微信小程序之获取用户位置权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序获取用户当前位置有三个方式： 1. wx.getLocation 注意： 先要在app.json里配置permission：
不然就会出现以下提示（本地测试环境）：
配置如下：
"permission": { "scope.userLocation": { "desc": "为了给您提供更好的服务，请授权您的地理位置信息" } }, wxml:
&lt;button class="btn" type="primary" bindtap="handleGetLocation"&gt; getLocation &lt;/button&gt; js:
handleGetLocation: function () { //获取位置 wx.getLocation({ type: 'gcj02', //默认为 wgs84 返回 gps 坐标，gcj02 返回可用于wx.openLocation的坐标 success: (res) =&gt; { console.log(res) }, fail: (err) =&gt; { console.log(err) } }) }, success回调函数返回数据：
2.wx.chooseLocation wxml:
&lt;button class="btn" type="default" bindtap="handleChooseLocation"&gt; chooseLocation &lt;/button&gt; js:
handleChooseLocation: function () { wx.chooseLocation({ success: (res) =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b34860f9e7d66c960f9c8211fd44c0c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7e044c0d5e44f650d9e726b1c9de0a3/" rel="bookmark">
			上手搭建vue项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开始学vue,之前在mac电脑上搭建了vue-element-admin的项目.是英文版,偶然发现还有中文版的.于是着手搭建,步骤非常简单,就是有些时候在windows上编译打包就各种报错,特将包含完整包(包含node_modules)的项目保存下来,随时取用.
选择以这个vue项目来学习 主要是它的很多技术在实战中比较有用.比如它有以下特性
-国际化多语言
- 多种动态换肤
- 动态侧边栏（支持多级路由嵌套）
- 动态面包屑
- 快捷导航(标签页)
- Svg Sprite 图标
- 本地/后端 mock 数据
- Screenfull全屏
- 自适应收缩侧边栏
项目代码编译后如下:
需提前安装好git
node环境部署好的情况下,
执行以下命名即可轻松搭建
git clone https://github.com/PanJiaChen/vue-element-admin.git cd vue-element-admin/ git branch -a git checkout remotes/origin/i18n npm config set registry https://registry.npm.taobao.org npm install npm run dev 搭建后运行
npm run dev
运行项目截图如下
支持切换语言
github上有项目,如果想下载编译好的,可以在这里下载,包含所有的依赖包,免去安装各种报错烦恼
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6449ac9193509d6ac6ecee1adaef2a44/" rel="bookmark">
			C&#43;&#43;判断一个类是否是第一次实例化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可以对构造函数下手。构造函数一开始先判断。为什么会有这种需求呢？我有一个类是用来维护wifi连接的，但是wifi模块只有一个，所以只允许有一个实例化对象控制wifi模块。
所以当这个类被多次实例化时要知道，并且采取措施防止第二个实例对象去控制wifi模块
可以在构造函数中生命一个静态变量作为标志。
ConnectWifi::ConnectWifi(void) { static bool bFirst = true; /*先判断是不是第一次被初始化，改类只允许有一个实例化对象*/ if (bFirst) { bFirst = false; //设置wifi模式为无线终端模式 WiFi.mode(WIFI_STA); xTaskCreate(connectThread, "", 2000, this, 1, nullptr); m_pThis = this; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1636b979f59a2d229949795052799b0/" rel="bookmark">
			C语言-函数调用练习（附答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.编写判断素数的函数，主函数输入10个整数，素数输出，要求每行最多出5个。
2.比较三个数大小。
3.使用函数统计指定数字的个数，读入一个整数，统计并输出该数中“2”的个数，要求定义并调用函数countdigit（number，digit），它的功能是统计整数number。例如：countdigit（12922，2），返回值是3。
4.写两个函数，分别求两个整数的最大公约数和最小公倍数，用主函数调用这两个函数，并输出结果。两个整数由键盘输入。
5.写一个函数，输入一个十六进制数，输出相应的十进制数。
6. 汉诺塔问题
7. 编写递归函数reverse(int n)实现将整数n逆序输出。
8.编写递归函数calc_pow ( double x, int n )实现一个计算x n（n≥1）的函数
9. 编写递归函数int fib(int n)求Fabonacci数列.
10.有一个3*4的矩阵，求所有元素中的最大值
1.编写判断素数的函数，主函数输入10个整数，素数输出，要求每行最多出5个。 #include&lt;stdio.h&gt; int ss(int j) { int flag=1; int i; for(i=2;i&lt;j;i++) if(j%2==0) {flag=0;break;} if(flag==0) return 0; else return 1;}	int main() { int a,n=0,i; for(i=1;i&lt;=10;i++) { scanf("%d",&amp;a); if(ss(a)) {printf("%d ",a); n++;} if(n==5) printf("\n");} return 0;} 2.比较三个数大小。 #include&lt;stdio.h&gt; int max(int x,int y) { if(x&gt;y) return x; else return y; } int main() { int a,b,c; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1636b979f59a2d229949795052799b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d4de7d0c32d42c596ca329189d2f96e/" rel="bookmark">
			Stream按对象某属性去重的方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Collectors.collectingAndThen 这是Stream中的一个收集器，相比普通的Collectors.toList、Collectors.groupingBy等收集器Collectors.collectingAndThen还可以在收集之后进行某种操作多一个形参，用于写function函数（有入参有出参） 举例说明collectingAndThen： List按某属性去重，返回List 2.本质流程 使用Collectors.collectingAndThen的本质是：先把new Set( list ) 获取一个Set，然后new List ( set )返回List
3. 如何用Set去重 用TreeSet和HashSet都能去重，只是去重的逻辑不一样。先看二者的存储逻辑：
Hashset是通过复写hashCode()方法和equals()方法来保证的。而Treeset是通过Compareable接口的compareto方法来保证的。同理可以用Comparator来定制排序 3.1TreeSet去重 ①自然排序Comparable接口 @Data public class DtoReq implements Comparable { private String userName; private String password; @Override public int compareTo(Object o) { DtoReq req = (DtoReq)o; return req.getUserName().compareTo(this.getUserName()); } } 代码逻辑即：对userName字段进行比较，且TreeSet的去重功能不需要关注顺序，谁比谁都一样不过这种方式相当于写死了，耦合度太高 去重代码 ArrayList&lt;DtoReq&gt; collect = arrayList.stream().collect( Collectors.collectingAndThen( Collectors.toCollection( TreeSet::new),ArrayList::new) ); new TreeSet(arrayList)时构造器会自动去比较Comparable接口的compareTo方法，而达到去重的效果
②定制排序Comparator接口 当元素的类型没实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序
应该用匿名对象重写compare方法 或用lambda表达式调用Comparator.comparing方法
@Data
public class DtoReq {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d4de7d0c32d42c596ca329189d2f96e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9758382f4c8052071b5a678dfcade203/" rel="bookmark">
			AcWing刷题1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 最近发现一个算法题目的宝藏平台，上面的题目其实都是比较偏向应用题了，所以可能更适合用来提高自己笔试的能力。在这里还没有入口的uu们可以在这里看一看哦：AcWing刷题网站
今天其实做了上周的周赛的一个题目，才发现自己很多基础的算法模板都没有掌握，所以只能说我算法还是没有真正的入门吧!今天其实也少稍微的学习了一下，关于区间合并的一个模板问题，题目描述如下：
二、题目描述 三、思路 本题的思路需要一些推导，也不是特别难，我们可以看到假设a数组中的 a i = a j a_i = a_j ai​=aj​的话，那么由于 b i + 1 b_{i + 1} bi+1​对于 b i b_i bi​来说只有两种可能，要不然和他相同，要不然比他大一，因此对于 a i = a j a_i = a_j ai​=aj​来说，b数组中下标为 [ i , j ] [i,j] [i,j]必须满足 b i = b j b_{i} = b_j bi​=bj​所以这个区间所有的数字必须相同才能满足条件，那么按照这样的分法，我们是一定可以把一整个区间划分成不同的小段，假设我们划分成了m个小段，对于第一个小段来说，由于题目的限定， b 0 = 0 b_0=0 b0​=0因此第一段只可能是0，那么接下来的每一段都有两种选择，要不然等于前面一段的数，要不然等于前面的数加1，因此最后的结果为 2 m − 1 2^{m - 1} 2m−1。
而在划分区域的时候，我们要进行合并区域的操作，即两个有交集的区间应该取他们两个的并集才能够正确的划分最终的区段。
举个栗子：
假设a[5] = {1,2,1,2,3},我们在合并的时候假设要划分到1的时候区间为[0,2],而划分2的时候是[1,3],我们发现这两个区间需要b数组在两个区间内的值要相同，就必须把两个区间合并成为[0,3]即在这整个区间上的b数组的值必须都相同，最后才是最正确的答案，而合并区间的操作，可以利用两个哈希表来进行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9758382f4c8052071b5a678dfcade203/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e45d974cf86a46dd3a5e8ee819b10a77/" rel="bookmark">
			MYSQL开窗判断连续月份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hive开窗判断连续月份
select custkey,name, months, add_mont, memory, memory1 from ( select a1.custkey,a2.name,a1.orderdate as months,sum(a1.totalprice) as memory, lead(a1.orderdate)over(partition by custkey) as add_mont, lead(sum(a1.totalprice))over(partition by custkey) as memory1 from orders as a1 join customer as a2 on a1.custkey = a2.custkey group by a1.custkey,a2.name,substr(a1.orderdate,1,7) order by a1.custkey ,a1.ORDERDATE ) as fbb where memory1-0&gt;memory-0 and ( year(months)=year(add_mont) and month(add_mont)=month(months)+1 or year(add_mont)=year(months)+1 and month(add_mont)=1 and month(months)=12) UNION all select custkey,name, months, add_mont, memory, memory1 from ( select a1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e45d974cf86a46dd3a5e8ee819b10a77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9348bff34f078dca22148b35d2673ea4/" rel="bookmark">
			微信小程序-旋转的音乐播放暂停功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做项目需要用到音乐播放的功能，播放icon中的音乐图片可360度旋转，点击时icon时,可暂停或播放音乐，切换页面时，暂停音乐播放
实际效果如下：
因多个页面运用到，就封装成自定义组件musicPlay
在根目录下新建一个文件夹，命名为components，在components下新建一个musicPlay的component
wxml
//musicStyle为整个音乐icon在页面的定位，有默认值，也可改变 &lt;view class="music-bg" style="{{ musicStyle }}"&gt; &lt;view class="music-icon"&gt;&lt;image class='music {{ rotate &amp;&amp; musicClass }}' src="{{ icon }}" bindtap='switch' wx:if="{{ music }}"&gt;&lt;/image&gt;&lt;/view&gt; &lt;/view&gt; wxss
.music-bg{ width: 100rpx; height: 100rpx; background: rgba(0, 0, 0, .4); border-radius: 50%; display: flex; flex-direction: column; justify-content: center; align-items: center; } .music { z-index: 99; -webkit-animation-iteration-count: infinite; } .music-icon{ width: 60rpx; height: 60rpx; } .music-icon image{ width: 100%; height: 100%; display: block; } /* 旋转 */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9348bff34f078dca22148b35d2673ea4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f3871482e1a945dbd620f01182af8f/" rel="bookmark">
			vue项目安全依赖包时各种报错解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行以下命令
npm install --registry=https://registry.npm.taobao.org --loglevel=silly
npm cache clean --force
npm install
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc3f8b15bdfb89994d42dfc97ae1371c/" rel="bookmark">
			微前端-乾坤qiankun
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019-2020年前端最火的技术之一：微前端
微前端究竟是什么？
微前端是近三年前端社区比较火的技术方案，试图把拆分大型后端系统的一些益处引入前端。
微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。
微前端的核心在于拆, 拆完后再合!
微前端，即前端微服务。是将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品。
微前端主要解决的问题： 1）毫无相关的业务，独立部署，降低运维成本。 (独立业务拆离)
2）团队人员逐渐增多，产品功能复杂，代码冲突频繁、影响面大，需独立部署。 （独立模块拆离）
3）在业务中，运行比较稳定，运维不频繁的项目部分，需独立部署。 （稳定业务拆离）
4）架构比较老但运行比较稳定的项目部分，近期不计划重构的，需独立部署。（独立架构拆离） 微前端特点： 独立开发、独立部署、独立运行、增量升级（单个服务升级）。
微前端方案正确的架构姿势：应用之间不应该有任何直接或间接的技术栈、依赖、以及实现上的耦合。
Single-spa微前端方案结合了MPA和SPA的优势，可以在单个页面内集成多个应用。
技术栈无关
独立部署每一个单页面应用
新功能使用新框架，旧的单页应用不用重写可以共存
改善初始加载时间，延迟加载代码
qiankun示例
微前端拆离工具：qiankun
主应用配置：
1.安装乾坤
$ yarn add qiankun # 或者 npm i qiankun –S
2.注册微服务
I.自动注册 // 在主应用中注册子应用
II.手动注册
import { loadMicroApp } from 'qiankun';
name跟container需要名称不一致。
3.子应用访问
I.跨域
devServer: {
headers: {// 重点1: 允许跨域访问子应用页面
‘Access-Control-Allow-Origin’: ‘http://localhost:7100’,//设置多域名，逗号隔开
},
子应用配置：
I.main.js配置
II.路由配置
import '../../public-path' // 重点3： 引入public-path文件
router里面添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc3f8b15bdfb89994d42dfc97ae1371c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc7948d71a7e69f700d800cd6725b78b/" rel="bookmark">
			linux-deepin-GPU-CudaFFT从入门到使用三天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPU简介 一般人眼中的GPU
图形处理器（英语：graphics processing unit，缩写：GPU），又称显示核心、视觉处理器、显示芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上做图像和图形相关运算工作的微处理器。 -我曾经也一度的认为GPU只是针对图像处理的，直到现在，某次课提到了一下，我尝试学习了它，才发现它的处理思维逻辑有点像FPGA（Field Programmable Gate Array），只不过GPU可以进行浮点运算。GPU的主频也还是蛮高的。其他具体的介绍度娘都可以为你解答，耐心看就行。
-废话不多说，我也不是很了解GPU，这篇文章也只是一个初步探索，谈不上精通，有一点当年用FPGA并行的舒爽吧。这里主要是从两个例子来介绍，第一个则是，cuda程序并行计算，另一个个是cuda加速的cufft与fftw相比。毕竟我的目的是尽可能的使得SDR可以实时。
硬件参数 做实验，不说硬件配置都是流氓呀 CPU: AMD Ryzen 7 3700X 8-Core Processor @ 5.35781GHz 内存：16GB 操作系统：deepin20.02 社区版 显卡：Getforce RTX2060 自打买了这电脑以来，还没用过显卡，可不能浪费啦 软件参数 这里主要是说一下我安装的显卡驱动什么的, 默认已经装好显卡驱动和cuda啦，我不做神经网络，所以不装cudann。
终端输入
nvidia-smi 结果如下： 显卡驱动教程，我看人家的：
deepin20 显卡驱动安装
这个稍微和别人有点不一样的，自己装的时候意会一下就好啦
deepin 安装ubuntu的cuda
cuda安装，首先取官网下一个cuda，我直接下debian的deb没装好，装的ubuntu 的.run
什么版本看自己显卡吧
注意大写
$ nvcc -V nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2021 NVIDIA Corporation Built on Mon_May__3_19:15:13_PDT_2021 Cuda compilation tools, release 11.3, V11.3.109 Build cuda_11.3.r11.3/compiler.29920130_0 到这里环境就算是搭建好啦
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc7948d71a7e69f700d800cd6725b78b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3a737a17c28de0dfeb969e0e6eca611/" rel="bookmark">
			QTableWidget用法记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 自动平均宽和列的宽度相关使用方法添加子项设置单个item属性右键弹出菜单清空qss美化 自动平均宽和列的宽度 Qt4的方法
ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setResizeMode(QHeaderView::Stretch); //平均分配列宽 ui-&gt;tableWidget-&gt;verticalHeader()-&gt;setResizeMode(QHeaderView::Stretch);//平均分配行宽 Qt5的方法
ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setSectionResizeMode(QHeaderView::Stretch); //平均分配列宽 ui-&gt;tableWidget-&gt;verticalHeader()-&gt;setSectionResizeMode(QHeaderView::Stretch);//平均分配行宽 自动调整行高和列宽详细说明
QTableWidget 有几个函数自动调整表格的行高和列宽，分别如下：
resizeColumnsToContents()：自动调整所有列的宽度，以适应其内容。resizeColumnToContents(int column)：自动调整列号为 co/www 的列的宽度。resizeRowsToContents()：自动调整所有行的高度，以适应其内容。resizeRowToContents(int row)：自动调整行号为 raw 的行的高度。 设置表格内容是否可编辑
ui-&gt;tableInfo-&gt;setEditTriggers(QAbstractItemView::DoubleClicked | QAbstractItemView::SelectedClicked);//双击或获取焦点后单击，进入编辑状态ui-&gt;tableInfo-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers); //不允许编辑 设置行表头、列表头是否显示
ui-&gt;tableInfo-&gt;horizontalHeader()-&gt;setVisible(checked);//是否显示水平表头ui-&gt;tableInfo-&gt;verticalHeader()-&gt;setVisible(checked);//是否显示垂直表头 选择模式
ui-&gt;tableInfo-&gt;setSelectionBehavior(QAbstractltemView::Selectltems); 单元格选择ui-&gt;tableInfo-&gt;setSelectionBehavior(QAbstractltemView::SelectRows); 行选择 相关使用方法 //ui-&gt;tableWidget-&gt;setShowGrid(true); //设置显示格子线 ui-&gt;tableWidget-&gt;setSelectionBehavior(QAbstractItemView::SelectRows); //整行选中的方式 ui-&gt;tableWidget-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers); //禁止编辑 ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setStretchLastSection(true); //行头自适应表格 //点击表时不对表头行光亮（获取焦点） ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setHighlightSections(false); //设置表头字体族和大小 ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setFont(QFont("song", 12)); //设置表头字体加粗 QFont font = ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;font(); font.setBold(true); ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setFont(font); //所有单元格的字体 设置成一样 ui-&gt;tableWidget-&gt;setFont(QFont("song", 12)); ui-&gt;tableWidget-&gt;setRowCount(1); //设置行数 ui-&gt;tableWidget-&gt;setColumnCount(8); //设置列数 ui-&gt;tableWidget-&gt;setWindowTitle("TABLE演示"); //设置标题 //代码设置表头 QStringList header; header&lt;&lt;"序号"&lt;&lt;"名称"&lt;&lt;"设备ID"&lt;&lt;"设备IP"&lt;&lt;"设备端口"&lt;&lt;"型号"&lt;&lt;"厂家"&lt;&lt;"备注"; ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(header); //去掉默认行号 可以用horizontalHeader() -&gt;setVisible(false)隐藏横向表头 QHeaderView *header1 = ui-&gt;tableWidget-&gt;verticalHeader(); header1-&gt;setHidden(true); //设置单元格大小 ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setDefaultSectionSize(50); //设置默认宽度 ui-&gt;tableWidget-&gt;verticalHeader()-&gt;setDefaultSectionSize(30); //设置一行默认高度 ui-&gt;tableWidget-&gt;setColumnWidth(1,110); ui-&gt;tableWidget-&gt;setColumnWidth(2,110); ui-&gt;tableWidget-&gt;setColumnWidth(4,180); ui-&gt;tableWidget-&gt;setColumnWidth(5,110); ui-&gt;tableWidget-&gt;setColumnWidth(6,80); ui-&gt;tableWidget-&gt;setColumnWidth(7,80); ui-&gt;tableWidget-&gt;setSortingEnabled(true); //启动排序 //单元格单独设置字体方法： QTableWidgetItem *item = new QTableWidgetItem; item-&gt;setText(strDev); item-&gt;setFont(QFont("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3a737a17c28de0dfeb969e0e6eca611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d31c91dce3439f376365b787c57e25/" rel="bookmark">
			Linux下ASP.NET初尝试之Jexus使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国产化进程一直在推进，以前Windows系列的开发部署模式，也要有所改动了。
.NET Core也推出来了，奈何不支持WebForm啊，只能是MVC。
于是需要找到一种可以在Linux下运行ASP.NET的方式。
跟度娘聊了会儿，说到了今天的主角Jexus。
目录
Jexus闪亮登场
Jexus安装、启动
Jexus网站配置
1、提示dll不存在，加载文件失败
2、继续访问，提示不存在xx.Global
3、继续，连接数据库错误
4、缺少动态加载dll
设置外部访问
已知、未知的问题
补充
后记
Jexus闪亮登场 Jexus以支持ASP.NET、Core、php在Linux上运行为特色，能够支持ASP.NET的原理，就是在Linux上安装了Mono（跨平台.NET运行环境），进而支持ASP.NET程序的运行。
官网：Jexus Web Server 官网
独立版（专业版）自带Mono环境，省去了自己在Linux上安装Mono的繁杂步骤，安装独立版的Jexus很简单，一个命令就搞定了。这里再插一句，要搞这些操作，首先你需要一个Linux环境，我是用VMWare做的CentOS 7.0的虚机Linux系统。可以从阿里云的镜像服务器直接下载相应的ISO文件，然后就可以做虚机了。
以下是官网首页的说明：
Jexus独立版(专业版)的安装 Jexus“独立版”指的是自带.net运行时（mono），不需要在客户服务器安装mono就能正常运行的Jexus版本，该版本只支持 64位Linux操作系统。
Jexus安装、启动 安装jexus独立版的命令是：
curl https://jexus.org/release/x64/install.sh|sudo sh
注：运行安装命令，需要操作者有root权限。
安装几分钟就搞定了。
默认安装在/usr/Jexus下
命令行：首先cd到Jexus目录下
然后：./jws start
即可启动服务。
也可以设置为自动启动，一开始我是问的度娘，给的方法也可以实现，就是比较麻烦些，见：Jexus开机自动启动配置_星火燎猿的博客-CSDN博客
问了下Linux专业交流群（值得加入的收费群，后面几个问题都是群里大神帮助解决的），有简单方法：
在/etc/rc.local 中，添加一行： /usr/jexus/jws start
意思差不多，都是在系统启动的时候，可以直接Jexus的启动Start
启动后，其实就可以访问了：http://localhost/info
Jexus网站配置 接下来就是配置自己的网站了。
在Jexus安装目录/usr/Jexus下，有个jsw.conf文件定义了Jexus的基本配置信息，可以不用管
再有个文件夹siteconf，这个是关键，所有的网站配置信息都在这里了，默认有个default，可以设置网站程序的端口、路径、主机名的。详细的说明官网都有的。
默认的网站程序文件放在/var/www下，一个网站再新建一个子文件夹（注意这个www是自己手动新建的，默认没有的）
注意：修改了上述siteconf下的网站配置文件后，重启jexus才会生效（restart）
正常，这么配置以后就可以正常访问我们的系统，看到熟悉的界面了。
不过我在搞的时候遇到了几个问题，正好在这里说下。
1、提示dll不存在，加载文件失败 根据错误提示，应该是在web.config中注册了这个提示错误的dll，一开始我是从我的win10电脑拷贝到bin下还是报错，拷贝到mono下的目录也不行，不知这家伙的运行原理；
解决：看了下，应该这个dll其他地方也没调用，直接web.config直接去掉，这个问题是过去了
2、继续访问，提示不存在xx.Global 这个就是程序下的Global.asax页面，存在的啊
这里想不明白，于是消费￥5进了Jexus交流群（官网可以看到群号），错误贴出来后，大佬一针见血发现问题所在：
由于我们的程序之前在IIS下都是部署到网站下的应用程序，所以我在拷贝代码的时候，是把我的代码根目录拷贝到了default下，即：default/mysite下才是我的实际程序文件（bin、页面这些的）
正是由于这个，导致找相关文件的时候出错了，还好也可以按照IIS网站下应用程序方式配置，见下：
默认是没有mySite这一级的，该问题也被灭。
3、继续，连接数据库错误 程序连接的数据库在我的Win10上，ping是通的，但是搞不懂为啥访问不到。
一开始是按照机器名\实例名方式，后来改为IP\实例名都不行，又加上,1433（SQL Server默认端口）还是不行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9d31c91dce3439f376365b787c57e25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08113eb04617d9d029469ab07d866c6f/" rel="bookmark">
			Java中switch的三种用法方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从java14开始， switch语句有了一个很大的调整， 这就让swicth语句有了更多的操作和选择，在代码上，更加的简便灵活.
switch 标准方式switch - &gt; 用法：switch yield 用法： 标准方式 int dayOfWeek = 2; switch (dayOfWeek) { case 1: System.out.println("星期一"); case 2: System.out.println("星期二"); case 3: System.out.println("星期三"); case 4: System.out.println("星期四"); case 5: System.out.println("星期五"); case 6: System.out.println("星期六"); default: System.out.println("星期日"); } 輸出如下：
星期二 星期三 星期四 星期五 星期六 星期日 从输出结果发现case代码块被穿透了，使用break防止case代码执行穿透，代码如下：
int dayOfWeek = 2; switch (dayOfWeek) { case 1: System.out.println("星期一"); break; case 2: System.out.println("星期二"); break; case 3: System.out.println("星期三"); break; case 4: System.out.println("星期四"); break; case 5: System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08113eb04617d9d029469ab07d866c6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c99902bf6bd70b42e079dde6951951cf/" rel="bookmark">
			C语言-函数（一）：函数的定义和调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数是一个完成特定工作的独立程序模块，包括库函数和自定义函数两种。例如，scanf()、printf()等这些都为库函数，是由C语言系统提供定义，编程时直接调用即可；还有一种是自己定义的函数，我们主要介绍的就是这类函数。
1、函数的定义 C语言的函数与数学上的函数概念类似。例如计算圆柱体积的公式为 V = π r 2 h V=\pi r^2h V=πr2h，在数学上可以写成 V = f ( r , h ) V=f(r,h) V=f(r,h)这个二元函数，其中 r , h r,h r,h是自变量， V V V是根据自变量所得到的函数值。在C语言中同样可以定义一个函数double cylinder(double r, double h)，这个函数的功能就是计算圆柱的体积。其函数值的结果依赖于 r , h r,h r,h，在C语言中称为函数参数。而 f ( r , h ) f(r,h) f(r,h)计算得到的函数值，在C语言中一定要为某一种数据类型，称为函数类型。
函数定义的一般形式：
函数类型 函数名(形式参数表)	/*函数首部*/ { 函数实现过程	/*函数体*/ } 例如计算圆柱体积函数的定义：
double cylinder(double r, double h) { double result; result = 3.1415926*r*r*h;	/*计算圆柱体积*/ return result;	/*返回结果*/ } （1）函数首部
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c99902bf6bd70b42e079dde6951951cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5a5721cbea5970328865464e1fa6ee6/" rel="bookmark">
			Flameshot——最好用的ubuntu截图工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux系统里面最好用的截屏工具支持图形化截图支持命令行截图 Flameshot 自带一系列非常好的功能
一、安装：
snap install flameshot 二、快捷键设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5d6fa52ac38b55a9a7da87dfa18af25/" rel="bookmark">
			canvas画布，绘制矩形、圆形、渐变色、图片、文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		画布 canvas元素是H5新增的一个重要元素，专门用来绘制图形。在页面中放置一个canvas元素，就相当于在页面上放置一块画布，可以利用canvas api在其中进行图形的描绘。canvas只是一个容器，不具备绘制能力，需要我们编写js代码实现
矩形
绘制矩形的步骤：
1. 取得canvas对象
2. 取得2d上下文（context）
3. 设定绘图样式，使用图形上下文对象中的fillStyle填充样式 strokeStyle 边框样式
4. 指定线宽，使用图形上下文对象中的lineWidth
5. 绘制矩形，使用图形上下文对象的
代码实现： &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 矩形: 1. 取得canvas对象 2. 取得2d上下文（context） 3. 设定绘图样式，使用图形上下文对象中的fillStyle填充样式 strokeStyle 边框样式 4. 指定线宽，使用图形上下文对象中的lineWidth 5. 绘制矩形，使用图形上下文对象的 --&gt; // canvas 画布宽高用heigh和width属性设置 &lt;canvas height="500" width="500" style="border: 1px solid #333;"&gt;&lt;/canvas&gt; &lt;script&gt; // 1.获取canvas对象 var canvas = document.getElementsByTagName('canvas')[0] // 2.获取canvasd的2d上下文 var context = canvas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5d6fa52ac38b55a9a7da87dfa18af25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d861ecbf0a89c3c4dfe5d602befb752/" rel="bookmark">
			springboot集成redisson启动报错:Unable to connect to Redis server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis未配置密码时springboot集成redisson启动报错Unable to connect to Redis server。
application.yml配置：
spring: redis: host: 127.0.0.1 port: 6379 password: 方式一：
maven依赖：
&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.9.1&lt;/version&gt; &lt;/dependency&gt; 重新实现实现RedissonClient：
@Configuration public class RedissonConfig { @Value("${spring.redis.host}") private String host; @Value("${spring.redis.port}") private Integer port; @Value("${spring.redis.password}") private String password; @Bean public RedissonClient redissonClient() { Config config = new Config(); config.useSingleServer() .setAddress("redis://" + host + ":" + port); if (StringUtils.isNotEmpty(password)) { config.useSingleServer().setPassword(password); } return Redisson.create(config); } } 方式二：
maven依赖：
&lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d861ecbf0a89c3c4dfe5d602befb752/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6a1c30b2bcc0a1816acb8238a3a1b81/" rel="bookmark">
			Eclipse 导入项目 中文注释乱码解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
win10下编写的java程序代码，linux虚拟机中用Eclipse打开，中文注释乱码。
解决方法：
windows系统默认用GBK编码格式，linux系统默认编码格式为UTF-8。在Eclipse当中将项目编码格式改为GBK格式就可以解决问题。
1.项目名字右击---属性
2.资源 --文本文件编码 -- 其他 ： 输入GBK。应用并关闭。
3.乱码问题解决：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dffde6109cf953349e32aed19ce9c6d6/" rel="bookmark">
			微信小程序之绝对路径、相对路径、返回到某个页面 抛弃../../
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
1、绝对路径、相对路径 **
小程序写了好久了 还停留在图片…/…/时代 真是out了。。。抛弃…/…/ 直接写 /images 就OK了！
“./”：代表目前所在的路径
“…/”：代表上一层路径
“/”开头，代码根目录（绝对路径）
绝对路径可以在登录过滤中使用，token过期后跳转到登录页面
**
2、返回到某个页面 **
/** * 关闭到某个页面 */ goback(pageRoute ) { let index getCurrentPages().find((pageItem, routeIndex) =&gt; { if (pageItem.route == pageRoute) index = routeIndex }) console.log("回退的页面为：", pageRoute, index) wx.navigateBack({ delta: getCurrentPages().length - index - 1, }) }, 借鉴文章：
微信小程序——绝对路径、相对路径、返回到某个页面：https://blog.csdn.net/wy313622821/article/details/119103856
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208ce4b38ef9257daaaebb45fe016ba7/" rel="bookmark">
			【Python软件和第三方库国内地址】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python软件和第三方库国内地址 提示：国外地址下载半天，总失败
文章目录 Python软件和第三方库国内地址前言一、安装Python1.[国内华为镜像](https://mirrors.huaweicloud.com/python/)：2.[官方地址](https://www.python.org/ftp/python/)：3.下载文件 二、第三方库国内镜像1.豆瓣2.阿里云3.清华大学4.中国科技大学 前言 提示：这里可以添加本文要记录的大概内容：
很多人在下载包或者安装的时候总下载很慢，然后超时失败，本文简单记录一些常用的地址，方便大家使用
一、安装Python 提示：python不要进行升级，直接安装不同版本的python，通过pytharm等编辑器选择，切换到想要的版本即可
1.国内华为镜像： https://mirrors.huaweicloud.com/python/
2.官方地址： https://www.python.org/ftp/python/
3.下载文件 Windows 64位下载 python-3.10.4-amd64.exe
Linux 安装tar包
二、第三方库国内镜像 由于 Python 服务器在国外，因此使用 pip 安装第三方模块或者库的时候，下载速度特别慢，经常出现如下报错：
$ socket.timeout: The read operation timed out 使用方法为在 pip 命令后加 -i URL 方法，以从豆瓣下载 pandas 库为例：
$ pip install pandas -i https://pypi.douban.com/simple 1.豆瓣 https://pypi.douban.com/simple
2.阿里云 https://mirrors.aliyun.com/pypi/simple
3.清华大学 https://pypi.tuna.tsinghua.edu.cn/simple
4.中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1057a1d0206d88b9fc62435706548fdd/" rel="bookmark">
			HCL_路由器_ISIS配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、实验环境 win7操作系统HCL v2.1.2 二、拓扑结构 三、模拟环境 应用型网络，主要面向企业网用户；路由策略和策略路由应用频繁多变，需要精细化的路由操作；架构层面扁平化，要求IGP作为基础路由为上层BGP协议服务；IS-IS的快速算法（PRC得到加强），简便报文结构（TLV），快速邻居关系建立，大 容量路由传递（基于二层开销低）等一系列特点在骨干网有着天然的优势。
四、介绍 1、ISIS地址结构 Area Address（区域地址） IDP和DSP中的HODSP（High Order DSP）一起，既能够标识路由域，也能够标识路由域中的区域，因此，它们一起被称为区域地址（Area Address），相当于OSPF中的区域编号。同一个路由域中不同区域不允许有相同的区域地址。同一Level-1区域中路由器的区域地址必须相同。
一般情况下，一个路由器只需要配置一个区域地址，且同一区域中所有节点的区域地址都要相同。为了支持区域的平滑合并、分割及转换，在设备的实现中，一个IS-IS进程下最多可配置3个区域地址。
system ID System ID用来在区域内唯一标识主机或路由器。在设备的实现中，它的长度固定为48bit（6字节）。
在实际应用中，一般使用Router ID与System ID进行对应。假设一台路由器使用接口Loopback0的IP地址172.16.0.1作为Router ID，则它在IS-IS使用的System ID可通过如下方法转换得到： 将IP地址172.16.0.1的每个十进制数都扩展为3位，不足3位的在前面补0将扩展后的地址172.16.000.001分为3部分，每部分由4位数字组成重新组合的1720.1600.0001就是System ID SEL
SEL（NSAP Selector，有时也写成N-SEL）的作用类似IP中的“协议标识符”，不同的传输协议对应不同的SEL。在IP上SEL均为00。
NET
网络实体名称NET（Network Entity Title）指的是IS本身的网络层信息，可以看作是一类特殊的NSAP（SEL＝0）。NET的长度与NSAP的相同，最多为20个字节，最少为8个字节。例如有NET为：ab.cdef.1234.5678.9abc.00，则其中区域地址为ab.cdef，System ID为1234.5678.9abc，SEL为00。
通常情况下，一个IS-IS进程下配置一个NET即可，当区域需要重新划分时，例如将多个区域合并，或者将一个区域划分为多个区域，这种情况下配置多个NET可以在重新配置时仍然能够保证路由的正确性。
而完整的ISIS地址是由Area Address（区域地址）+ System ID + SEL 组成。
2、路由器的三种分类 Level-1路由器
Level-1路由器负责区域内的路由，它只与属于同一区域的Level-1和Level-1-2路由器形成邻居关系。
一个Level-1路由器只负责维护本区域内的LSDB（Link State Database，链路状态数据库），对于目的地不在本区域内的路由，Level-1路由器会将该路由的目的地标识为最近的Level-1-2路由器。
Level-2路由器
Level-2路由器负责区域间的路由，可以与Level-2或其它区域的Level-1-2路由器形成邻居关系，维护一个Level-2的LSDB，该LSDB包含区域间的路由信息。
所有Level-2级别的路由器组成路由域的骨干网，负责在不同区域间通信，路由域中Level-2级别的路由器必须是连续的，以保证骨干网的连续性。
只有Level-2级别的路由器才能直接与区域外的路由器交换数据报文或路由信息。
Level-1-2路由器
同时属于Level-1和Level-2的路由器称为Level-1-2路由器，可以与同一区域的Level-1和Level-1-2路由器形成Level-1邻居关系，也可以与其他区域的Level-2和Level-1-2路由器形成Level-2的邻居关系。Level-1路由器必须通过Level-1-2路由器才能连接至其他区域。
Level-1-2路由器维护两个LSDB，Level-1的LSDB用于区域内路由，Level-2的LSDB用于区域间路由。
属于不同区域的Level-1路由器不能形成邻居关系。Level-2路由器之间可以形成邻居关系，与所在区域无关。
3、IS-IS的网络类型 IS-IS只支持两种类型的网络，根据物理链路不同可分为：
广播链路：如Ethernet、Token-Ring等。点到点链路：如PPP、HDLC等。 五、路由器配置 六、登陆测试 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a934b8c891b3f50c2ee907d6d6e82083/" rel="bookmark">
			头歌：实现顺序表中数据的查找功能。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "Seqlist.h" void SL_Initiate(SqList &amp;L) // 顺序表的初始化，即构造一个空的顺序表 { L.elem = (ElemType*)malloc(sizeof(ElemType)*MAXSIZE); L.length=0; } void SL_Free(SqList &amp;L) // 释放顺序表 { free(L.elem); } bool SL_IsEmpty(SqList L) // 判断顺序表是否空 { return L.length==0; } bool SL_IsFull(SqList L) // 判断顺序表是否满 { return L.length==MAXSIZE; } void SL_Create(SqList &amp;L,int n) // 输入n个数据元素，创建一个顺序表L { int i; L.length=n; for(i=0; i&lt;n; i++) scanf("%d", &amp;L.elem[i]);	} void SL_Print(SqList L) // 输出整个顺序表 { if (L.length==0) { printf("The slist is empty.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a934b8c891b3f50c2ee907d6d6e82083/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a62cc8194425bad13bf57f79035ace6/" rel="bookmark">
			给定一棵二叉树，计算该二叉树的深度、总节点个数和叶子节点个数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// // binary_tree.cpp // BinaryTreeApp // // Created by ljpc on 2018/5/3. // Copyright © 2018年 ljpc. All rights reserved. // #include "binary_tree.h" int GetTreeDepth(BiTreeNode* root) // 计算该二叉树的深度 // 参数：二叉树根节点root // 返回：二叉树的深度 { // 请在这里补充代码，完成本关任务 /********** Begin *********/ int a,b; if(root==NULL) { return 0; } else { a=GetTreeDepth(root-&gt;right); b=GetTreeDepth(root-&gt;left); if(a&gt;b) { return a+1; } else { return b+1; } } /********** End **********/ } int GetNodeNumber(BiTreeNode* root) // 计算该二叉树的总节点个数 // 参数：二叉树根节点root // 返回：二叉树的总节点个数 { // 请在这里补充代码，完成本关任务 /********** Begin *********/ if(root!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a62cc8194425bad13bf57f79035ace6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa4a90cfbb271dab613f948a8c931210/" rel="bookmark">
			UE4-灯光烘焙效果质量不佳解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.烘焙之后，如果在场景中发现某个模型在仅光照模式下，光照UV的质量很差（阴影较模糊），但是其他模型并没有这种情况，我们需要对模型进行调整。
先查看正常模型在一般设置中的属性下有光照贴图分辨率属性数值。
打开需要修改的模型网格体，在详情面板将光照贴图分辨率更改为与正常模型数值一致。然后再次进行构建光照。一般都会消除这种错误。
2.场景内存在多个相同的物体，只需要场景内某一个的物体烘焙效果较好，其余物体可以忽略。此时可以单独对场景内物体的光照分辨率进行覆盖设置，然后进行重新构建。
（1）首先选中场景内的模型，在细节面板找到光照属性。
注意：一定要在场景内选择特定模型设定，而不是去模型网格体里面设置。
（2）勾选覆盖的光照贴图分辨率，然后设置大小，一般设置不会超过1024。
覆盖的意思就是说将原网格体里设置的光照贴图分辨率进行覆盖，此处进行单一计算。
例如：网格体模型设置光照贴图分辨率为512，拖拽模型至场景，存在两个。选择场景内的一个物体设置覆盖的光照贴图分辨率为1024。构建光照后。原512分辨率的阴影会有锯齿状，设置覆盖分辨率的物体阴影会平滑很多。
（3）设置单个物体的覆盖的光照贴图分辨率时Lightmass下的参数一般不会做修改。
3.自发光物体烘焙后影响场景设置
（1）开启自发光影响场景设置
选择场景中的自发光物体，Lightmass属性下勾选使用静态光照的自发光，再次构建，即可影响场景。
参数路径：光照/Lightmass/使用静态光照的自发光。
（2）增强自发光影响强度
在Lightmass属性下的自发光提升值加大，构建场景后，自发光影响加强
原值：
自发光提升修改到5：
（3）如果将投射阴影关闭，如果场景内只有一个自发光物体，表现为场景黑暗，无法看到其余物体，只能看到自发光物体自己。
4.如果有一个物体特别大并需要烘焙的灯光的时候，光照贴图分辨率设置的再高，效果都不会很好。
可以将这个物体分为若干个小物体，就是说用小物体叠加起来，并设置成静态组成这个大物体，这样烘焙效率及效果都会很高。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/276/">«</a>
	<span class="pagination__item pagination__item--current">277/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/278/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>