<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a49af223244059da4db706cf8172906/" rel="bookmark">
			Java中用for循环输出九九乘法表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先先用一个for循环来输出第一行
for (int j = 1; j &lt;= 9; j++) { System.out.println(1+"*"+j+"="+(1*j)+"\t"); } 输出结果：
然后在使用for嵌套循环来实现
public static void main(String[] args) { for (int i = 1; i &lt;= 9; i++) { for (int j = 1; j &lt;= i; j++) { System.out.println(j+"*"+i+"="+(i*j)+"\t");//不换行输出且没输出一次中间多一个Tab键 } } } 整个程序大概流程是第一个for循环j初始值为1，小于9判断为真执行循环体语句，进来之后i初始值为1，小于j判断为真执行循环体语句，输出i*j=(i+j)，然后里面的for循环的i自增加1为2，大于j判断为假，跳出循环回到第一个for循环，j自增加1为2，小于9带入第二个for循环继续执行，以此类推，最终输入九九乘法表。
注意：print()与println()的区别，print()是不换行输出，会接着上一个输出结果继续输出；println()是换行输出，输出一个结果之后会自动换行，下一个输出结果就在下一行了。
源码及结果：
public class ForDemo04 { public static void main(String[] args) { for (int i = 1; i &lt;= 9; i++) { for (int j = 1; j &lt;= i; j++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a49af223244059da4db706cf8172906/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b43629cb5d2d53e59a8534d322dc5c31/" rel="bookmark">
			在.NetFramework中使用Microsoft.Extensions.Configuration 读取Json和XML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//需要安装 Microsoft.Extensions.Configuration;
//Microsoft.Extensions.Configuration.json
//Microsoft.Extensions.Configuration.xml
//Microsoft.Extensions.Configuration.Binder;
//注意: json 的key中不能出现冒号":"
//XML的 Atrribute中不能出现关键词 “Name”, 且不能使用根节点(从第一个子节点开始)
using Microsoft.Extensions.Configuration; using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; //需要安装 Microsoft.Extensions.Configuration; //Microsoft.Extensions.Configuration.json //Microsoft.Extensions.Configuration.xml //Microsoft.Extensions.Configuration.Binder; //注意: json 的key中不能出现冒号":" //XML的 Atrribute中不能出现关键词 "Name", 且不能使用根节点(从第一个子节点开始) namespace XMLFrameworkDemon { internal class Program { static void Main(string[] args) { ConfigurationBuilder cfgbuilder = new ConfigurationBuilder(); cfgbuilder.AddXmlFile("cfg.xml"); IConfigurationRoot root = cfgbuilder.Build(); ; string name = root.GetSection("NodeClass:ModbusNode:ModbusGroup:NameXML").Value; //string variable = root.GetSection("NodeClass:ModbusNode:Variable:0:NameXML").Value; //不行 ConfigurationBuilder cfgJsonbuilder = new ConfigurationBuilder(); cfgJsonbuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b43629cb5d2d53e59a8534d322dc5c31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec4404e84429d81b9eff65dd87bf6e2e/" rel="bookmark">
			windows下使用microsoft、intel、gnu不同编译器利用cmake和vscode对c&#43;&#43;和fortran程序进行编译和调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows下使用microsoft、intel、gnu不同编译器利用cmake和vscode对c++和fortran程序进行编译和调试 由于编译器支持特性、编译后程序运行速度、安装使用便捷程度等的不同，我们往往会安装多种不同的编译器。对于c++语言主要的编译器有：microsoft、intel、gnu等，对于fortran语言则更多，包括gnu、intel、pgi等等。不同的编译器在一个系统下，往往需要利用一些手段进行区分，比如环境变量的临时设置等方式，便于区别使用。
本文介绍一下对于同一个程序利用不同的编译器进行编译的不同方法。
1. 编译器准备 本文介绍主要针对c++和fortran，但以c++为例，fortran的方式是类似的。
c++程序可以采用3种编译器：microsoft、intel、gnu。
其中前两种编译器的安装在【前文】 介绍过了，这里不再说明。
GNU编译器在windows最常用的是mingw和cygwin。这里我们使用【mingw-w64】。几年前mingw-w64主要下载的工具是【MingW-W64-builds工具】。但近今年维护似乎不再持续，而转向msys2了。所以下载msys2【下载地址】 即可。msys2用法参考其【官网】 。需要注意的是，下载安装msys2后只有msys2支持环境，编译工具需要另外下载，打开msys2命令行，输入如下命令下载编译工具：
pacman -S --needed base-devel mingw-w64-x86_64-toolchain 编译器下载完成后，需要将工具所在路径加入系统路径，如：
D:\msys64\mingw64\bin 在命令行下使用命令path或者env可以看到该路径已经加入了系统路径中。
注意：如果是在msys2提供的命令行下工作，那么可以修改home下的.bashrc文件，将mingw的地址加入到msys2的系统目录中，比如：
export PATH="/mingw64/bin/:$PATH" 如此每次打开msys2命令行就能找到g++等工具了。观测path可知：
2. 编译工具和编辑器准备 编译工具我们使用命令行和cmake，【前文】介绍过，安装即可 。
编辑器使用【vscode】 。
需要安装C/C++,C/C++ Extension Pack 两个插件，后者已经包含了CMake Tools插件。
3. 程序准备 C/C++测试程序使用一个简单的程序（这个示例是vscode网址上的）
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; using namespace std; int main(int, char**) { vector&lt;string&gt; msg {"Hello", "C++", "World", "from", "VS Code", "and the C++ extension!"}; cout &lt;&lt; "Hello, world!\n"; int i=0; for (const string&amp; word : msg) { cout &lt;&lt; word &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec4404e84429d81b9eff65dd87bf6e2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19ef49ef67ccfa7341812f58c8b37ec4/" rel="bookmark">
			减法器运算电路公式推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本人是菜鸟，有错误欢迎斧正，近期在看仪表放大器，其第二级放大电路就是一个减法器，大学教的我也忘的差不多了，于是开始网上冲浪，可是网上都是根据具体电路分析，或者分析的跳跃度很大，我被搞懵了，我如果不理解公式的推导，我会排斥记下这个公式。所以我为了避免后来者和我我一样。我觉得我需要一步一步，一点一点推出来减法器的公式。
公式推导 上面是我绘制的减法器的图，首先需要满足的是R1_1=R1，R2_2=R2。
思路就是根据叠加原理算出反相与同相的输出方程，再进行相加，最后整理一下即可。下面开始推导。
首先将V2=0；
V+=(V1-V3) * R2 / (R1+R2) + V3 整理后可以得出 V+=(V1R2+V3R1) / (R1+R2)
（V+表示同向端电压，V-表示反向端的电压）
然后Vo就等于V+ 乘以 同相增益方程（也就是放大倍数）公式如下
Vo=(V1R2+V3R1) / (R1+R2) * (R1_1+R2_2) / R1_1
因为R1_1=R1，R2_2=R2 整理后得出
Vo=(V1R2+V3R1) / R1
然后将V1=0,V3=0；
Vo=V2 * (-R2_2) / R1_1
再将两式加在一起得出
Vo = V2 * (-R2_2) / R1_1+(V1R2+V3R1) / R1整理后得出
Vo = R2 / R1 * (V1-V2) + V3
再当R1=R1_1=R2=R2_2时
Vo=V1-V2+V3
应用 AD620是一款仪表放大器，其内部就使用了减法器，如红框所示
其就遵循R1=R1_1=R2=R2_2
所以Vo=V1-V2+V3，REF引脚就是V3，一般接入ADC采集的基准电压，或者加入一定的偏移。
与其相似的芯片还有很多，如INA128，INA828等等。
总结 我分析的可能会存在错误，请不要听信一家之言，请全面分析，有任何问题可以私信联系我。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e478969e8fff4e5bdda096bca0523857/" rel="bookmark">
			维度表，实体表，事实表之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段时间在慢慢学习有关维度建模的一些东西，其中有个问题当时被老大挖了个坑就跳了进去几天都没爬出来，这个坑主要在于我对维度表，实体表，事实表这三种表之间的关系和概念认知比较模糊，当时老大要我去设计一个关于设备的维度和事实表及实体表出来时，结果我就真的去傻乎乎的对设备进行各种维度表和事实表的设计，然后在给老大看的时候各种被怼，最后才认知到设备怎么可能设计的出一个维度表呢，它本身就是一个客观存在的事实，我们是不可能去把一个客观存在的事实做成一个维度去分析的，维度建模中只存在通过各种维度去分析一个事实，而不能通过别的事实角度去分析另一个事实，如果存在这种结构，也应该是指标值（度量值）而不是一个维度。
维度表：维度表可以看成是用户用来分析一个事实的窗口，它里面的数据应该是对事实的各个方面描述，比如时间维度表，它里面的数据就是一些日，周，月，季，年，日期等数据，维度表只能是事实表的一个分析角度。
实体表：实体表就是一个实际对象的表，实体表它放的数据一定是一条条客观存在的事物数据，比如说设备 ，它就是客观存在的，所以可以将其设计一个实体表。
事实表：事实表其实质就是通过各种维度和一些指标值得组合来确定一个事实的，比如通过时间维度，地域组织维度，指标值可以去确定在某时某地的一些指标值怎么样的事实。事实表的每一条数据都是几条维度表的数据和指标值交汇而得到的。
上面这张图就是设备表的一个实体表设计，它作为一个客观存在的事实它是无法建立一个维度表的，其实设备表本身也可以看成是一个事实表，只需要对生厂商，设备类型，时间，地点这几个点进行维度表设计就行了，这样就将一个设备表变成一个事实表了。
可能由于我本身对维度建模的接触时间比较短，在加上表达能力也不怎么行，对这三种关系理解的也不是很透切，导致文中对这三种表的关系及含义的描述可能会有错误或歧义，希望大家帮我指出，维度建模中的一个小白敬上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e013d91f285ab6c4c412e25e94729234/" rel="bookmark">
			重载和重写有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重载和重写是Java中两个重要的概念。重载可以实现本类内的方法多态性，重写可以实现子类或实现类的多态性。
一、重载
在自然语言中，经常会出现“一词多义”的现象。比如：“墨水”，它可以指一种含有色素或染料的液体，墨水被用于书写或绘画；还可以指人的文化、知识，“胸无半点墨”便指人的知识很匮乏。一个词语如果有多重含义，那么就说该词语被重载了，具体代表什么含义需要结合具体的场景。在Java语言中，也存在重载，不过它需要满足以下几点：
1.方法名必须相同；
2.参数列表必须不同（参数的个数不同、参数的类型不同、类型的次序必须不同）
public static void main(String[] args) { print(12); print("1234"); print("hello Java！"); } public static void print(int i){ System.out.println("打印整型值："+i); } public static void print(String s){ System.out.println("打印字符串类型值："+s); } public static void print(String s1,String s2){ System.out.println("打印字符串类型值1"+s1+";字符串类型值2："+s2); } //输出结果 //打印整型值：12 //打印字符串类型值：1234 //打印字符串类型值：hello Java！ 编译器在编译代码时，会对实参进行推演，会根据推演的结果来确定调用那个方法。
注意：重载与返回值类型是否相同无关；两个方法如果仅仅只是因为返回值类型不同，是不能构成重载的。具体错误如下所示：
public static void main(String[] args) { int a = 10; int b = 20; int ret = add(a, b); System.out.println("ret = " + ret); } public static int add(int x, int y) { return x + y; } public static double add(int x, int y) { return x + y; } //编译错误 Test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e013d91f285ab6c4c412e25e94729234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b731c28ed6149bf12e00d25527356cec/" rel="bookmark">
			[论文笔记]Remote Sensing Image Change Detection with Transformers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Remote Sensing Image Change Detection with Transformers
论文简介： 该论文是2021年发表在ISPRS上的利用transformer做变化检测的工作。利用了LEVIR-CD数据集，下图是论文提出的BIT在该数据集上的结果。
网络模型： 关键点： BIT能够学习并且关联全局高层语义的上下文信息并可以反馈附加到原始特征。
3个主要步骤 从CNN backbone中提取高层特征。用BIT来修饰双时图像特征由预测头获得变化图。 算法流程图 3个关键组件 1.a Siamese semantic tokenizer, 2. transformer encoder (TE)，3. a Siamese TD。
a Siamese semantic tokenizer： TE: 这一模块，在已经获得了两个语义token集。
该模块核心思想是MSA，多个独立注意力分支并行计算。MSA 的优点是它可以在不同的位置联合处理来自不同表示子空间的信息。
TD: 经过TE后，得到了两个语义丰富tokens集，这些语义丰富tokens包含紧凑的高级语义信息，很好地揭示了区域变化信息。 在TD结构中我们需要投影回到像素空间以获得像素级特征。论文认为每个像素都可以用紧致语义的tokens组合来表示。
网络细节： 1)CNN主干网络：修改的ResNet18来提取双时图像特征图。ResNet18一共有五个阶段，每个下采样倍率为2。修改最后两个阶段倍率为1，在最后添加卷积层减少输出通道至32。为了减少空间细节的损失，后加双线性插值层获得下采样倍率为4。
2)双时Transformer: token length L = 4 、NTE=1、NTD=8、h=8、d=8。
3)
4)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b95e2cd353aa895e06801435670b1783/" rel="bookmark">
			Tomcat-pass-getshell 弱口令 vulfocus夺旗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞原因：后台登录使用弱口令，部署war包geshell
测试环境：Apache Tomcat/8.0.43
1、启动CVE-2017-12615目标靶场，并访问
默认账目密码：tomcat/tomcat
2、找到上传点进行上传war包
利用冰蝎的shell.jsp去生成war包
jar -cvf war.war "shell.jsp"
上传点进行上传
可以看到是否上传成功
3、无需访问木马文件，直接连冰蝎即可
http://123.58.236.76:24554/war/shell.jsp
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d24c8bbd8efc3ce0a953c2cb8350bb/" rel="bookmark">
			解决tomcat访问404问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，本解决方法仅限于新版本的tomcat
如果之前没问题，现在tomcat访问404，要么防火墙没开，要么安全组没开，要么tomcat没启动，要么资源放的地方不对，再仔细检测一下。
最后，是新版本刚用的解决方法。
tomcat新版本将webapps目录变成空了，将原来的网页资源都放在了webapps.dist目录下。
即将删除webapps目录，将webapps.dist改名webapps就可以了，不需要重启服务器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d7b96d041ddb503308a9d04417b7b70/" rel="bookmark">
			mybatis ＜if＞标签判断不生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原if标签写法 &lt;if test="type == '1'"&gt; &lt;!--内部逻辑--&gt; &lt;/if&gt; 这种情况不生效,原因是mybatis是用OGNL表达式来解析的，在OGNL的表达式中，'0’会被解析成字符(而我传入的type却是string)，java是强类型的，char 和 一个string 会导致不等，所以if标签中的sql不会被解析。
解决方法 &lt;!--第一种解决方案,加上.toString()--&gt; &lt;if test="type == '1'.toString()"&gt; &lt;!--内部逻辑--&gt; &lt;/if&gt; &lt;!--第二种解决方案,将单引号缓冲双引号--&gt; &lt;if test='type == "1"'&gt; &lt;!--内部逻辑--&gt; &lt;/if&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3471f42e55a2a0f94605536f63a5b77/" rel="bookmark">
			vm安装centOS出现VMware Workstation 与 Device/Credential Guard 不兼容的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：VMware Workstation 与 Device/Credential Guard 不兼容。在禁用 Device/Credential Guard 后，可以运行 VMware Workstation
（vm版本不同也可尝试）
方法一：
如果使用的是win10专业版，那么直接：
（1）控制面板——程序——打开或关闭windows功能，选择勾选Hyper-V，确定禁用该服务即可；
（2）重启电脑，再启动VM虚拟机。
但是找了半天没找到Hyper-V这个选项，查了VMware Workstation 与 Device/Credential Guard 不兼容。在禁用 Device/Credential Guard 后，可以运行 VMware这篇博客，里面第二步需要用到的禁用Device Guard：[win+R] 打开输入 gpedit.msc ，依次 本地计算机策略 --&gt; 计算机配置 --&gt; 管理模板&gt;系统 --&gt; Device Guard，将 基于虚拟化的安全设置 设置为 “已禁用”。
但是我gpedit.msc又啥都没出现。里面提到的“策略编辑器”我也没找到，所以继续查，发现这篇博客提到如果是win家庭版，没有上面提到的是正常的，按照方法二就好。
方法二：
1、按下WIN+R打开运行，然后输入services.msc回车；
2、在服务中找到 HV主机服务，双击打开设置为禁用
3、win+x，然后打开powershell（管理员）运行命令bcdedit /set hypervisorlaunchtype off（关闭Hyper-V）
4、重启电脑，大功告成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc9ab517ca41e58d47d668a48d058c15/" rel="bookmark">
			Maven添加SQLserver的依赖及驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.下载依赖
链接：https://pan.baidu.com/s/1Tz4Biv3rakJshRJTWWGwgA
提取码：z2g9
2.使用命令将依赖打包到本地maven仓库
打开cmd，输入命令： mvn install:install-file -Dfile=sqljdbc42.jar -Dpackaging=jar -DgroupId=com.microsoft.sqlserver -DartifactId=sqljdbc4 -Dversion=4.2　命令解释：mvn install:install-file -Dfile="jar包的绝对路径" -Dpackaging="文件打包方式" -DgroupId=groupid名 -DartifactId=artifactId名 -Dversion=jar版本 （artifactId名对应之后maven配置的依赖名）。 3.pom文件添加依赖
&lt;dependency&gt; &lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt; &lt;artifactId&gt;sqljdbc4&lt;/artifactId&gt; &lt;version&gt;4.2&lt;/version&gt; &lt;/dependency&gt; 4.java项目配置文件配置
driver-class-name: com.microsoft.sqlserver.jdbc.SQLServerDriver url: jdbc:sqlserver://localhost:1433;DatabaseName=u8cloudgis username: test password: 1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4b903a0bec3ed48cfdf9471c3b75735/" rel="bookmark">
			BCEWithLogitsLoss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bce = BCEWithLogitsLoss()
pred为网络输出，y为标签值。
第一种情况。pred和y都只有一个值 pred1.shape:[1],pred1.dtype:torch.float32
y1.shape:[1],pred1.dtype:torch.float32
&gt;&gt;&gt; pred1 = torch.Tensor([0.3]) &gt;&gt;&gt; y1 = torch.Tensor([1]) &gt;&gt;&gt; bce(pred1,y1) tensor(0.5544) 根据交叉熵公式：loss = -(1-y)*log(1-pred)-y*log(pred),当y取0的时候只剩下-(1-y)*log(1-pred)，当y取1的时候剩下-y*log(pred)需要注意，首先需要将0.3进行sigmoid处理，1/(1+1/math.pow(e,0.3))就是将0.3进入sigmoid网络。所以pred不是0.3，是1/(1+1/math.pow(e,0.3))=0.5744 &gt;&gt;&gt; import math &gt;&gt;&gt; e = math.e &gt;&gt;&gt; log = math.log &gt;&gt;&gt; -log(1/(1+1/math.pow(e,0.3))) 0.5543552444685272 第二种情况。pred和y不是一个值，是列表 pred1.shape:[10],pred1.dtype:torch.float32
y1.shape:[10],pred1.dtype:torch.float32
&gt;&gt;&gt; y2 = torch.ones([10], dtype=torch.float32) &gt;&gt;&gt; pred2 = torch.full([10], 1.5) &gt;&gt;&gt; criterion(pred2, y2) tensor(0.2014) 因为都是1.5，-log(1/(1+1/math.pow(e,1.5)))=0.2014，加起来再平均一下，还是0.2014 第三种情况。pred和y不是一个值，是矩阵 pred1.shape:[10,64],pred1.dtype:torch.float32
y1.shape:[10,64],pred1.dtype:torch.float32
&gt;&gt;&gt; y3 = torch.ones([4, 3], dtype=torch.float32) &gt;&gt;&gt; pred3 = torch.full([4, 3], 1.5) &gt;&gt;&gt; criterion = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4b903a0bec3ed48cfdf9471c3b75735/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/720f9d5c8f094b027351f115cba95918/" rel="bookmark">
			pytorch 猫狗识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据集分割
import shutil import numpy as np import os # kaggle原始数据集地址 original_dataset_dir = 'D:\\data1\\data' total_num = int(len(os.listdir(original_dataset_dir))/2) # total_num=12500 # os.listdir() 可以查看当前目录下的文件和目录个数 random_idx = np.array(range(total_num)) np.random.shuffle(random_idx) # np.random.shuffle() 对第一维的随机打乱 base_dir = 'D:\\data1\\target_data' # 待处理的数据集地址 if not os.path.exists(base_dir): os.mkdir(base_dir) # 创建目录 # 训练集、测试集的划分 sub_dirs = ['train', 'test'] animals = ['cats', 'dogs'] train_idx = random_idx[:int(total_num * 0.8):] # train_idx=10000 test_idx = random_idx[int(total_num * 0.8)::] # test_idx=2500 numbers = [train_idx, test_idx] for idx, sub_dir in enumerate(sub_dirs): dir = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/720f9d5c8f094b027351f115cba95918/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cda535fee3f6fbf4d091415833c73b8/" rel="bookmark">
			python写网络爬虫微博用户发布的视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微博用户发布在奉天承芸超话的视频：
def run(self):
s = requests.Session()
# 暂时先抓self.TotalPage=200页
for i in range(1,self.TotalPage):
time.sleep(1)
if self.end_flag:
print("self.end_flag TRUE,leave run")
break
if i == 1:
self.url = self.basic_weibo_url
else:
self.url = self.basic_weibo_url + '&amp;since_id=' + str(self.since_id)
weibo_response = s.get(self.url)
weibo_data = weibo_response.json()
if weibo_response.status_code != 200:
print("end process for reponse.status_code=", weibo_response.status_code)
self.end_flag = True
return self.end_flag
if weibo_data['data'].get('cards'):
cards = weibo_data['data']['cards']
if weibo_data['data'].get('cardlistInfo'):
cardlistInfo = weibo_data['data']['cardlistInfo']
self.since_id = cardlistInfo.get('since_id')
if self.since_id is None:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cda535fee3f6fbf4d091415833c73b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa681a4ac9e1280c5965bcfc757281a/" rel="bookmark">
			C# Post提交formdata类型数据-.Net Core
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、C# Post提交 formdata格式数据
form-data字典类型 key-value格式
字典格式
//form - data格式发送Post请求 Dictionary&lt;string, string&gt; dic = new Dictionary&lt;string, string&gt;(); dic.Add("resp_type", "1"); dic.Add("upload_type", "1"); dic.Add("img_url", "http://www.jnqianle.cn/img/index/scan.png"); string reuslt = NetHelper.Post(url, dic); Console.WriteLine(reuslt); object转字典格式
//form-data格式发送Post请求 object param = new { resp_type = 1, upload_type = 1, img_url = "http://www.jnqianle.cn/img/index/scan.png" }; string reuslt = NetHelper.Post(url, param); Console.WriteLine(reuslt); Post底层分装：
.Net Standard HttpClient封装Htt请求常用操作整理 - 天马3798 - 博客园​​​​​​​​​​​​​​g
更多：
C# 正则表达式使用_C# Regex使用整理 C# 正则使用_正则表达式使用整理（一） Kestrel简介_Kestrel Web 服务器简介 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/602d796548ba4988bac2e6ae40ef8c93/" rel="bookmark">
			库文件、静态库(lib)与动态库(dll)的生成与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态库 程序编译一般需经预处理、编译、汇编和链接几个步骤。在应用中，有一些公共代码是需要反复使用，就把这些代码编译为“库”文件；在链接步骤中，连接器将从库文件取得所需的代码，复制到生成的可执行文件中。这种库称为静态库，其特点是可执行文件中包含了库代码的一份完整拷贝；缺点就是被多次使用就会有多份冗余拷贝。
动态库 动态库又称动态链接库英文为DLL，是Dynamic Link Library 的缩写形式，DLL是一个包含可由多个程序同时使用的代码和数据的库，DLL不是可执行文件。动态链接提供了一种方法，使进程可以调用不属于其可执行代码的函数。函数的可执行代码位于一个 DLL 中，该 DLL 包含一个或多个已被编译、链接并与使用它们的进程分开存储的函数。DLL 还有助于共享数据和资源。多个应用程序可同时访问内存中单个DLL 副本的内容。DLL 是一个包含可由多个程序同时使用的代码和数据的库。Windows下动态库为.dll后缀，在linux在为.so后缀。
俩者区别 静态库是编写的时候加载进源代码进行编译的，如各种头文件。动态库是在程序运行的时候映射进程序的内存空间进行动态加载的，如DLL文件。静态库和动态库是两种共享程序代码的方式，它们的区别是：静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。使用动态库的优点是系统只需载入一次动态库，不同的程序可以得到内存中相同的动态库的副本，因此节省了很多内存。
静态链接库生成方法 1、新建一个项目，选择Win32项目
2、选择静态库，预编译头可以加也可以不加，这里我不加
如果没有选静态库，可以在项目/工程属性/配置属性/常规/项目默认值配置类型中修改
3、添加.cpp文件和.h文件
（1）demo.cpp文件
#include&lt;iostream&gt; #include&lt;vector&gt; #include"BinarySearchLib.h" using namespace std; //递归方法 int Binary_Search_Recursion(vector&lt;int&gt; v, int begin, int end, int key) { if (begin &gt; end) return -1; int mid = (begin + end) &gt;&gt; 1; if (v[mid] &gt; key) return Binary_Search_Recursion(v, begin, mid - 1, key); else if (v[mid] &lt; key) return Binary_Search_Recursion(v, mid + 1, end, key); else return mid; } //非递归方法 int Binary_Search(vector&lt;int&gt; v, int begin, int end, int key) { if (begin &gt; end) return -1; int mid = 0; while (begin &lt;= end) { mid = (begin + end) &gt;&gt; 1; if (v[mid] &gt; key) end = mid - 1; else if (v[mid] &lt; key) begin = mid + 1; else return mid; } return -1; } （2）BinarySearchLib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/602d796548ba4988bac2e6ae40ef8c93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03869ad2531c08c084ede8d7746d0e84/" rel="bookmark">
			Qt 实现配置 OpenCV 环境，并实现打开图片与调用摄像头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明 所用QT版本：5.9.1
电脑配置：win10，64位系统
调用的是编译好的：OpenCV-MinGW-Build-4.1.0（点击链接进码云仓库）
在大学期间，由于项目需求需要用到QT+opencv进行编程。在网上看了一下，有很多介绍配置的方法的文章，大致有两种，一种是需要使用CMake对opencv进行编译，这种方法太复杂了，而且我在尝试中也是各种报错，各种尝试无果之后果断放弃了；
另一种是直接引用库函数，配置起来非常简单，我选择的配置方法是第二种。虽然第二种方法只有三四步的过程，网上也有很多教程，但是在我实际配置的过程中，遇到了很多麻烦，本来几分钟搞定的事情，我花了几天才完成，中途一度有过放弃。
这里简单介绍一下配置方法，提点一下特别需要主要的细节。
二、步骤 1、新建一个项目（注意英文路径）
2、在pro文件内加入代码（完整如下）：
#------------------------------------------------- # # Project created by QtCreator 2021-11-04T19:23:51 # #------------------------------------------------- QT += core gui greaterThan(QT_MAJOR_VERSION, 4): QT += widgets TARGET = A_1 TEMPLATE = app # The following define makes your compiler emit warnings if you use # any feature of Qt which as been marked as deprecated (the exact warnings # depend on your compiler). Please consult the documentation of the # deprecated API in order to know how to port your code away from it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03869ad2531c08c084ede8d7746d0e84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1300bf0d9d1ebeeab6e1ff39fa467ee0/" rel="bookmark">
			Gin--使用cookie（跨域共享，第三方cookie写入）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务端 跨最高二级域名 有三个域名A .top，x.A.top，y.A.top
也就是在A.top产生的cookie，可以与，x.A.top和y.A.top共享
要想cookie在跨域在相同父级域名下共享，那么domian属性就应该为：“.A.top”
跨域设置 // 处理跨域请求,支持options访问 func Cors() gin.HandlerFunc { return func(c *gin.Context) { method := c.Request.Method origin := c.Request.Header.Get("Origin") c.Header("Access-Control-Allow-Origin", origin) c.Header("Access-Control-Allow-Headers", "Content-Type") c.Header("Access-Control-Allow-Methods", "POST, GET, OPTIONS,DELETE,PUT") c.Header("Access-Control-Expose-Headers", "Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers,Content-Type") //想要cookie正常使用，就要加上这个头部，设置为true c.Header("Access-Control-Allow-Credentials", "true") // 放行所有OPTIONS方法 if method == "OPTIONS" { c.AbortWithStatus(http.StatusNoContent) } // 处理请求 c.Next() } } 设置cookie import ( "net/http" "net/url" ） var c *gin.centext userCookie := &amp;http.Cookie{Name: 'user', Value: url.QueryEscape(token), Path: "/", Secure: false, Domain: '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1300bf0d9d1ebeeab6e1ff39fa467ee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8abae2b86eefff0108d1f9478e0d5cf/" rel="bookmark">
			git 常用指令记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		--强制回滚到master分支
git reset --hard master
--
场景：当远程分支有问题的时候怎么办？
将远程分支删掉，将本地分支删掉，重新创建分支；
第一步：删除远程分支：[删除的远程qa分支]
git push origin --delete qa ；
第二步： 删除本地的qa分支；[注意要切换到其他分支]
git branch -D qa;
第三步： 重新从master拉取分支；
git checkout -b [分支名称]；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5cc3c1643e055208f75074aed4f69a5/" rel="bookmark">
			Questa 10.7 在 ubuntu20.04下安装成功了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 为了得到下面这一张图，小编是真的花了将近10个小时，把网上各种教程都看了一遍。
参考文章：IC验证工具：Ubuntu下Questasim10.7安装（64bit）全攻略
推荐一篇最新的安装教程：安装Mentor QuestaSim 2021 Linux 在ubuntu 20 LTS
1. 下载及安装： 小编最后整理出来的安装包目录如下：(链接：提取码：ment)
install.linux64应该是pl脚本，安装的时候给运行权限，运行便会出现如下界面！
注意：小编使用了 chmod a+x install.linux64，第一次直接使用./ install.linux64安装，但是它不能安装在/opt的目录下，因此使用 sudo ./ install.linux64可以帮助你安装到任意位置！
这个安装命令可以反复运行，通过这个gui界面，你可以很方便的控制安装的组件！
2. 破解 01.安装的图中有linux_patch文件夹，文件夹下有linux和Patch文件夹,
其中，Patch内容如下图：
linux内容如下图：
2.1 patch文件夹下生成mentor.dat，移动到安装路径中 2.1.1 在windows下生成即可 如别人所说，在patch文件夹下面随便改改下面划线处内容，然后运行run_me.bat就会生成mentor.dat，注意，这里指的是windows下！ 第一处划线：hostname第二处划线：mac_address第三处划线：PATH
将文件修改成下面的效果就可以了
2.1.2 在linux下生成也行 如果上面完成了，并且通过破解成功，这里就不用了看了。小编这里给你解剖下run_me.bat,如下，这里小编已经把文件全部拷贝到linux下了，为了执行mgcrypt.exe,小编尝试除了linux下的生成方式，即：使用命令wine mgcrypt.exe -i license.src -o mentor.dat。 ubuntu@ubuntu Patch % cat run_me.bat [0] @mgcrypt.exe -i license.src -o mentor.dat ubuntu@ubuntu Patch % wine mgcrypt.exe -i license.src -o mentor.dat 如果你操作到了这里，建议使用sudo mv mentor.dat /opt/questasim/完成移动操作。为了方便维护,将生成的mentor.dat保存在安装路径下，不至于当临时文件被清理了。 不管在windows还是linux中生成，达到如下的目的就行： 2.2 linux文件夹拷贝到指定位置，接着一顿乱操作 在linux文件夹中，有三个文件： ubuntu20@ubuntu20 linux % ls [0] libstdc++.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5cc3c1643e055208f75074aed4f69a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff8874153154846b56260136b3394094/" rel="bookmark">
			2020前端一些大厂面经系列———JS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上篇
总结了一下大厂面试中出现的JS题目，都是2019年12月的亲身经历
问题都附有解答，阅读非常方便
JS 0. bind apply call的相同与不同（腾讯）
相同点：都可以改变函数内部的this指向不同点： call和apply会调用函数，并且改变函数内部的this指向call和apply传递的参数不一样，apply必须以数组形式bind不会调用函数，但是会改变函数内部的this指向 主要应用场景： call主要用作继承apply经常跟数组有关，比如借助数学对象实现数组中的最大最小值bind可用于改变定时器内部的this指向 1. 用apply或者call实现bind（字节跳动）
考察的其实是对bind和apply/call的区别，即新建了一个函数
Function.prototype.bind = function( context ){ var self = this; // 保存原函数 return function(){ // 返回一个新的函数 return self.apply( context, arguments );//执行新的函数的时候，会把之前传入的context当作新的函数体的this } }; 2. 节流和防抖分别是什么？手写一波（字节跳动，网易雷火）
防抖是动作绑定事件，动作发生后一定时间后触发事件，在这段时间内，如果该动作又发生，则重新等待一定时间再触发事件。
节流是 动作绑定事件，动作发生后一段时间后触发事件，在这段时间内，如果动作又发生，则无视该动作，直到事件执行完后，才能重新触发。
// 防抖 function debounce (fn, delay) { let timber = null; return function(this, ...args) { if(timber) { clearTimeout(timber); timber = null; } timber = setTimeout(fn.bind(this, ...args), delay); } } // 节流 function throttle (fn, delay) { let prev = Date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff8874153154846b56260136b3394094/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a1d3f08d91432353b0a67aa8d1a5064/" rel="bookmark">
			VLAN划分（华为）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应领导要求要对vlan进行划分，咋个办，学撒。 简易top图
在没有进行配置的情况下所有的交换机接口都在vlan1内，所以在这个都可以ping通
那么现在要做的就是
PC1 ping PC4 OK
PC1 ping PC2 NO
PC2 ping PC3 OK
PC2 ping PC4 NO
首先就是创建并划分vlan 注意事项在交换机上划分VLAN时，需要首先创建VLAN。在交换机上执行vlan &lt;vlan-id&gt;命令，创建VLAN.
如本例所示,
执行vlan 10命令后，就创建了VLAN 10，并进入了VLAN 10视图。VLAN ID的取值范围是1到4094。如需创建多个VLAN,可以在交换机上执行vlan batch { vlan-id1 [ to vlan-id2 ]}命令，以创建多个连续的VLAN。也可以执行vlanbatch { vlan-id1 vlan-id2}命令，创建多个不连续的VLAN,VLAN号之间需要有空格。
进入配置视图
vlan 10 创建vlan 也可以这样
1.display vlan 查看vlan
2.display vlan [ vlan-id]命令，可以查看指定VLAN的详细信息
3.display vlan vlan-id statistics命令，可以查看指定VLAN中的流量统计信息。
4.display vlan summary命令，可以查看系统中所有VLAN的汇总信息。
2，划分链路——access口 交换机连接主机的链路为access链路
进入接口并定义接口链路
interface ethernet port link-type access
port link-type trunk
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a1d3f08d91432353b0a67aa8d1a5064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf5170c5fe9ad5a9528c6613775bb32e/" rel="bookmark">
			R语言进行随机抽样、分层抽样和系统抽样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在进行一项哨点监测项目，需要对监测点乡镇、学校和医疗机构分别进行人口规模排序的系统抽样、学校类别的分层抽样以及随机抽样，对比spss、excel后发现R语言中的sampling包能够得到较好的实现，直接上代码。
原始抽样框如下，分别存放与excel不同的sheet中：
代码部分： library(readxl) library(dplyr) library(sampling) dt&lt;-list() for(i in 1:3){ dt[[i]]&lt;-read_excel("xx抽样框.xlsx",sheet=i) } xz&lt;-dt[[1]]%&gt;%data.frame()%&gt;%arrange(desc(人口数)) xx&lt;-dt[[2]]%&gt;%data.frame() yy&lt;-dt[[3]]%&gt;%data.frame() ###人口规模排序的系统随机抽样（抽取2两个乡镇）### n&lt;-2 N&lt;-nrow(xz) if(N%%2==1){ set.seed(111) s1&lt;-srswor(1,N) xz&lt;-xz[-getdata(xz,s1)$ID_unit,] ##该循环用来判断总规模是否为偶数，如不为抽数，随机抽除1个## }else{ xz&lt;-xz } p&lt;-rep(n/N,N) set.seed(111) ###设置随机种子便于后期核验### sxz&lt;-UPsystematic(p) xz.result&lt;-getdata(xz,sxz) ###学校类型的分层随机抽样（每层各抽取1个）### set.seed(111) sxx&lt;-strata(xx[order(xx$层别),],stratanames = "层别",size=c(1,1),method = "srswor") xx.result&lt;-getdata(xx,sxx) ###医院简单随机抽样### n1&lt;-1 N1&lt;-nrow(yy) set.seed(111) syy&lt;-srswor(n1,N1) yy.result&lt;-getdata(yy,syy) ###结果输出### library(openxlsx) rr&lt;-list() tt&lt;-list("乡镇抽样结果"=xz.result,"学校抽样结果"=xx.result,"医院抽样结果"=yy.result) for(i in 1:length(tt)){ rr[[i]]&lt;-tt[[i]] } names(rr)&lt;-names(tt) write.xlsx(rr,file = "抽样结果.xlsx",rowNames=F) 输出结果：ID_unit即为本次抽样抽中的序号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f825cba07e8367a9de522d9a42858450/" rel="bookmark">
			我C&#43;&#43;的getline输入为什么出现了问题？——两个样例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言的前言 如果你清楚C++输入输出、缓冲区等概念，而且清楚下面这两个例子为什么不对，那你就可以太长不看了。
先读取一个整数n，再读取一行字符串，之后输出。
输入：
2 wupeng 输出：
wupeng 错误示范：
/// 错误示范！ int n; cin &gt;&gt; n; string s; getline(cin, s); // 错误示范！ cout &lt;&lt; s &lt;&lt; endl; /// 错误示范！ 先读取一个整数n，表示后面的行数，再读取n行以,分隔的不含,的string（每行5个），把他们放进一个二维vector中。别整什么,替换成空格，我就是要放到vector中！
输入：
2 a,b,ca,dw,ew wp,wu,peng,uin,y 输出：
a b ca dw ew wp wu peng uin y 错误示范：
/// 错误示范！ int n; cin &gt;&gt; n; vector&lt;vector&lt;string&gt;&gt; v(n, vector&lt;string&gt;(5)); for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; 5; ++j) { getline(cin, v[i][j], ','); /// 错误示范！ } } /// 错误示范！ 前言 一直没把输入输出当回事，毕竟笔试题什么的都是固定好的输入格式。牛客的OJ在线编程常见输入输出练习刷完就再也没管过了，直到有一次想玩点花的，用getline+分隔符读取输入出现了BUG，才正视我根本不懂C++的输入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f825cba07e8367a9de522d9a42858450/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab3903402797cac0bd414799a75bc0c/" rel="bookmark">
			Labview路径问题注意点及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Labview可通过使用当前vi路径（编程-文件I/O-文件常量-当前vi路径）获取当前.vi的具体路径，若要调用的当前.vi同路径下的某文件，只需在当前vi路径后连接拆分路径（编程-文件I/O-拆分路径），则此时的路径为当前.vi路径的上一级路径，再通过创建路径（编程-文件I/O-创建路径）与某文件名（含后缀名）结合，通过路径至字符串转换（编程-字符串-路径\数组\字符串转换-路径至字符串转换）显示某文件路径，即可实现对某文件索引。
但在.vi打包为.exe文件后，可以理解为此时的.vi相当于在.exe下一级路径下，此时获取到的某文件路径则为...\.exe\某文件，这时则会路径错误，获取不到某文件。如果只针对此问题进行解决，只需多加一个拆分路径，既能使.exe调用某文件正确。
随之带来的问题是.vi的路径的错误，为了使路径在.vi和.exe两种情况下都能正确，可以通过条件判断来自动区别，即通过匹配路径中是否有.exe存在，若存在，其返回值大于0，否则返回值为-1，由此来判断是否多加一次拆分路径。
关于路径获取上，除了可以用当前vi路径，还可以用应用程序目录，其中应用程序目录获取的路径是当前.vi或.exe的路径，使用应用程序目录则不会出现打包后路径错误的问题。
写在最后：使用当前vi路径在打包后，非.vi文件默认会被生成在data文件夹下，可以在目标-支持目录-目标路径更改，时期与.exe在同一路径下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e41acf136d53c4d13967cd674b2afcd9/" rel="bookmark">
			git 撤销commit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 撤销未push的commit # 用户已经执行的操作 git add . git commit -m "提示" # 现在想要撤销之前的提交 # 第一种：不删除工作空间提交的代码，撤销commit，并且撤销git add.操作 git reset --mixed HEAD^ # 第二种：删除工作空间提交的代码，撤销commit，并且撤销 git add . 操作 git reset --hard HEAD^ # 第三种： 不删除工作空间提交的代码，撤销commit，但不撤销 git add . git reset --soft HEAD^ 本地有很多多余的文件 # 查看有多少个记录的节点 git reflog # 回到远程分支的最后一个节点 git reset --hard origin/dev # 拉取最新的代码 git pull origin dev 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447c9ab99b7b2e83b1dc2e8a44e9deac/" rel="bookmark">
			svn访问路径提示Unable to connect to a repository at url
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个svn账号很久没有访问svn库下载内容，今天访问svn时提示unable to connect to a repository at Url。截图如下：
经过以下检查：
1、检查svn账号在svn服务器的访问规则配置是否正确。经检查，访问规则配置正确。
2、其他账号是否可正常登录，更新和提交文件。经核实，其他账号可正常登录，并可正常更新和提交文件。
判断如下：
1、svn服务器、访问规则没有问题。
2、是该svn账号出现的个例问题。
但尚不确认是什么问题导致。
首先猜测是账号密码问题。尝试先清空密码，重新输入账号密码登录。步骤如下：
1、在桌面或者文件夹中点击右键，选择TortoiseSVN-设置。如图：
2、尝试清空本地保存的验证数据，然后重新输入账号和密码。路径如下：
3、输入上次报错的地址，弹出输入账号密码框。输入正确账号密码后，可正常登录svn，可正常下载和提交。
问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c90d92ad7b600b4e3520d4902c7f76/" rel="bookmark">
			linux patch命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		patch指令让用户利用补丁文件来修改，更新原始文件，达到升级原始文件功能的目的。
一、生成补丁文件： 我们通过diff命令来生成补丁文件，diff -Naur a.txt b.txt
首先我们来看两个文件：a.txt，b.txt
$ vim -O a.txt b.txt safsdgfdsg |fdsfdgfdgsdg 12345 |12345 |555555555 hello linux |hello python very good | 注意：crtl+w 点击两次 两个窗口切换
通过执行diff -Naur命令查看文件差异：
# diff -Naur a.txt b.txt --- a.txt 2022-04-14 03:35:41.000000000 +0000 +++ b.txt 2022-04-14 03:35:53.000000000 +0000 @@ -1,7 +1,4 @@ - -safsdgfdsg +fdsfdgfdgsdg 12345 - -hello linux -very good - +555555555 +hello python 命令选项说明：
-N 不存在的文件以空文件方式处理
-a 所有文件都以文本方式处理
-u [n] 输出（默认为 3 行）一致的上下文（差异前后相同的行，方便定义差异的位置）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26c90d92ad7b600b4e3520d4902c7f76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2234623eccd1207fda0466bfcf68a727/" rel="bookmark">
			C&#43;&#43; vector insert，erase简单用法——竞赛专用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		insert 在第 i i i 个元素前插入， 0 ≤ i 0 \leq i 0≤i
ve.insert(ve.begin()+i,2); erase 删除第 i i i 个元素， 0 ≤ i 0 \leq i 0≤i
ve.erase(ve.begin()+1); 示例 #include&lt;bits/stdc++.h&gt; #define rep(i,x,y) for(int i=x; i&lt;=y; ++i) #define per(i,x,y) for(int i=x; i&gt;=y; --i) #define pushk push_back #define popk pop_back #define mem(a,b) memset(a,b,sizeof a) #define ll long long #define lp p&lt;&lt;1 #define rp p&lt;&lt;1|1 using namespace std; const int N = 1e6+9; vector&lt;int&gt; ve; int main() { ve.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2234623eccd1207fda0466bfcf68a727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8015a42478a3f0e175dd3166dd6a8bda/" rel="bookmark">
			使用docker安装部署kibana
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 项目场景：使用docker安装部署kibana
前提：已成功部署安装elasticsearch 可参考文章链接: 《使用docker安装部署elaticsearch》.
1.拉取Kibana 例如：首先需要把Kibana从DockerHub上拉取下来：统一版本7.6.2
#拉去Kibana docker pull kibana:7.6.2 2.启动kibana容器： -e ELASTICSEARCH_HOSTS 设置elasticsearch地址
#运行kibana 注意IP一定不要写错 docker run --name kibana -e ELASTICSEARCH_HOSTS=http://自己的elasticsearchIP地址:9200 -p 5601:5601 -d kibana:7.6.2 3.进入kibana容器 接下来使用docker命令进入到kibana容器里面：
#进入容器 docker exec -it 容器ID /bin/sh 进入容器中找到/usr/share/kibana/config/kibana.yml
#使用vi 修改文件内容 vi /usr/share/kibana/config/kibana.yml 4.覆盖配置文件 将如下内容写到kibana.yml中，然后保存退出：:wq
server.name: kibana server.host: "0" #elasticsearch.hosts: [ "http://elasticsearch:9200" ] elasticsearch.hosts: [ "http://自己的elasticsearch的IP:9200" ] xpack.monitoring.ui.container.elasticsearch.enabled: true #设置kibana中文显示 i18n.locale: zh-CN 5.最后访问页面 http://自己的IP地址:5601
问题： 如果长时间都是下图那样服务器没准备好，可以看下日志排查问题
#查看kibana容器日志 docker logs -f 容器ID 推荐文章：《使用docker安装部署kibana》
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8015a42478a3f0e175dd3166dd6a8bda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/591730d8ab96dd819a84be1a7c1d8c6f/" rel="bookmark">
			【深度学习】查看本机显卡配置是否支持安装tensorflow的gpu版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装tensorflow的GPU版本需要安装CUDA和cuDNN，所以要检查本机的GPU是否支持CUDA，计算能力大于3.1才可以。
查看本机显卡配置 右键我的电脑——管理——设备管理器
可以看到显卡配置为：NVIDIA GeForce GTX 1050
显卡型号支持官网：https://developer.nvidia.com/cuda-gpus 传送门
对比官网型号，计算能力6.1，支持安装。
安装CUDA和cuDNN可以参考这篇→https://blog.csdn.net/qq_43627106/article/details/124175225
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04606e5f67411fd1d5b9eafa16c41254/" rel="bookmark">
			Android studio页面布局实现固定顶部和底部导航栏，中间可滑动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 开发 页面布局实现固定顶部和底部导航栏，中间可滑动 大家好 I am HYJones
相信大家在学习Android开发的时候是不是想过也想做出高大尚的页面 那你算是来对地方啦
下面将传授大家的秘籍就是 Android 页面布局实现固定顶部和底部导航栏
大家有没有发现我们平常使用的软件都是固定顶部和底部的菜单栏的 ，而中间的部分是可以上下滑动的。这样软件的界面就会比较使用 而且有b格 。
如果你也想实现这样的效果，看啦这篇文章 你也可以轻松实现，全是基础知识，只用线性布局即可实现 。
先看一下效果,体验一下快感。
页面颜色多是为啦看的更明白
直接上源码
activity_main.xml
&lt;!-- android:orientation="vertical" 设置页面垂直布局（ 从上至下的排列）--&gt; &lt;!-- android:orientation="horizontal" 设置页面水平布局（ 从左至右的排列） --&gt; &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;!--总体布局--&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;!-- 固定顶部--&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="50dp" android:background="#F1E60909" android:orientation="horizontal" tools:ignore="MissingConstraints"&gt; &lt;Button android:layout_weight="1" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/Button&gt; &lt;Button android:background="@color/white" android:layout_weight="1" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/Button&gt; &lt;Button android:layout_weight="1" android:layout_width="match_parent" android:layout_height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04606e5f67411fd1d5b9eafa16c41254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f71b1cefc1b6cedd6f79adaeb0dee3b9/" rel="bookmark">
			PHP字符串首尾留N位,中间替换成*号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //字符串替换(保留第N位跟最后N位,替换中间所有字符)
//封装成函数调用
function strReplace($string,$start,$end) {	//参数一:$string 需要替换的字符串 //参数二:$start 开始的保留几位 //参数三:$end 最后保留几位 $strlen = mb_strlen($string, 'UTF-8');//获取字符串长度 $firstStr = mb_substr($string, 0, $start,'UTF-8');//获取第一位 $lastStr = mb_substr($string, -1, $end, 'UTF-8');//获取最后一位 return $strlen == 2 ? $firstStr . str_repeat('*', mb_strlen($string, 'utf-8') -1) : $firstStr . str_repeat("*", $strlen - 2) . $lastStr; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f4419460dcfec1355154a94f2aad2c/" rel="bookmark">
			服务器名怎么查看？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：服务器名就是计算机名，cmd中输入hostname就可以看到
方法二：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce7b5110a7c2a1448238756613bb36c0/" rel="bookmark">
			cannot be compiled under ‘--isolatedModules‘ because it is considered a global script file. Add an i
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ts定义变量的时候报错：
找到tsconfig.json的配置文件：
isolatedModules字段改为false
原因：
Typescript将没有导入/导出的文件视为旧脚本文件。这样的文件不是模块，它们的任何定义都已合并到全局名称空间中。 isolatedModules禁止此类文件。
将任何导入或导出添加到文件都使其成为一个模块，并且错误消失。
export {}也是一种方便的方法，可以在不导入任何内容的情况下使文件成为模块。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e6f957c650263b304ee52f4fafcbdb0/" rel="bookmark">
			我的创作纪念日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机缘 提示：可以和大家分享最初成为创作者的初心
例如：
实战项目中的经验分享日常学习过程中的记录通过文章进行技术交流… 收获 提示：在创作的过程中都有哪些收获
例如：
获得了多少粉丝的关注获得了多少正向的反馈，如赞、评论、阅读量等认识和哪些志同道合的领域同行… 日常 提示：当前创作和你的工作、学习是什么样的关系
例如：
创作是否已经是你生活的一部分了有限的精力下，如何平衡创作和工作学习… 憧憬 提示：职业规划、创作规划等​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50e0dd2f0cd82d2903af135675206dfd/" rel="bookmark">
			总结 cookie 和 session 的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、为什么要使用会话控制技术？ Web是通过 HTTP协议来实现的，而HTTP协议是无状态协议，所以同一个用户在请求相同的页面两次的时候，HTTP协议不会认为这两次请求都来自于同一个用户，会把它们当做是两次请求的独立（即会将两次请求隔离开），会认为是两个不同的用户请求的。如果用户执行了登录操作，再次请求页面，HTTP协议不会认为该用户之前登录过，因为它无法保持该用户之前的登录状态，所以无法在不同页面之间进行用户的跟踪和状态的保持
。
2、Cookie工作原理 cookie的工作原理：是一种由服务器发送给客户端的片段信息，存储在客户端浏览器的内存或硬盘当中的技术。【可以把它当做是存储在浏览器中的一个文件，这个文件中包含我们客户端的一些片段的信息（如：登录或存储的一些其他信息等），它就是一个文件，这个文件是存储在客户端的！！！】
3、Cookie 的优点和缺点 cookie的优点：因为cookie是将信息存储在客户端，因此不会占用服务器的资源（即不会浪费服务器的资源），效率会高一些。cookie的缺点：也是因为其存储在客户端，由于我们的信息全部保存在客户端计算机中，所以不建议将一些敏感重要的数据保存到cookie当中，而且用户有权限禁止cookie的使用。如果我们在浏览器中，将cookie禁止掉，一旦用户禁止cookie，我们没有办法去保存用户的信息。
4、session的工作原理 将使用者相同的资料存储在服务器中
5、Session 优点和缺点 session的优点：信息非常的安全，都是存储在服务器端的，客户端不可能拿到 session 的数据。session的缺点：会占用服务器的资源（session文件越来越多，可能某一天会占满磁盘），并且它的分布式也是一个问题（如：将来我们可能会有多台 web服务器，但是 session 可能是存储在其中一台，而另外一台是没有办法去使用的。这种情况下，我们可以使用 redis，不管在哪台服务器，都可以去调用 redis 的服务器，就可以达到信息共享)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a48b1124bcb8f3fa9189d6a164a4761/" rel="bookmark">
			【python GUI】tkinter好看的主题|ttkbootstrap的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直觉得tkinter自带的ui控件实在是太丑了！！！ 难道我只能去学习qt了嘛？ 不！我觉得还可以挣扎一下下！ 我曾经做了一个人工智能分类器：
(71条消息) 【tkinter+深度学习】实现人工智能分类器|简单的深度学习|仅供娱乐，学习还须脚踏实地_深度学习与tkinter-深度学习文档类资源-CSDN文库https://download.csdn.net/download/m0_61139217/79995910?spm=1001.2014.3001.5503
长得一副不太聪明的样子。
直到我发现了这个库： pip install ttkbootstrap 给大家一个官网链接： ttkbootstrap - ttkbootstrap
经过我得一番操作：
可以发现，在已有控件的基础上，对控件的样式进行了改变！ 话不多说，我们开整： 导入ttkbootstrap库的Style：
from ttkbootstrap import Style 设置我们想要的一个主题：
if __name__ == '__main__': # 设置主题颜色 style = Style(theme='pulse') base = style.master # base = tkinter.Tk() FirstPage(base) base.mainloop() 主题：
cosmo - flatly - journal - literal - lumen - minty - pulse - sandstone - united - yeti（浅色主题）
cyborg - darkly - solar - superhero（深色主题）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a48b1124bcb8f3fa9189d6a164a4761/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05faafe320253ba4fad8aefd30b0f39f/" rel="bookmark">
			vs code 自定义注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一直使用vs studio+visuall assist，一直觉visuall assit的注释非常好用，就现在在vs code也使用类似的注释方式。
现在开始
1.下载插件，Snippet，注意图标是小黄鸭
2.修改配置
ctrl+shift+p 进入命令模式---&gt;输入snippet，最后结结果如下图所示：
鼠标点选上图中的高亮地方，接着输入cpp，最后结果如下图
点击cpp.json，就可以开始编辑我们的注释模板了。以下是一个示例，我们可以根据自己的习惯编辑注释模板
{ "Print to consoletest": { "prefix": "//-", //快捷键盘，也就是你在编辑器中输入就会有对应的注释出来。 "body": [ "// $1 yourname $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND", //注释内容，输入焦点会停在 $1处 ], "description": "带签名时间戳的注释插入", //说明 } } 下图是最终的效果图：
当snippet不仅仅做注释，还是可以做一些代码段，例如下面的示例：
{ "Print to consolet": { "prefix": "//-", "body": [ "// $1 zhuyb $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND", ], "description": "带签名时间戳的注释插入" }, "my for ": { "prefix": "for", "body": [ "for(int i = 0; i &lt; $1; ++i) \n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05faafe320253ba4fad8aefd30b0f39f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a53ef29d0b67032c75dda2aeb3a3bd9/" rel="bookmark">
			acm竞赛技巧——c/c&#43;&#43; /java 快读快写(整数，字符串)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 整数快读快写 字符串读入读出 java快读快输 注意： 本文参考博客 整数 这里用int做示范，long long，__int128 改下变量类型即可
快读 inline int rd() { char ch=getchar(); int x=0,w=1; //过滤掉其他字符 while(ch&lt;'0'|| ch&gt;'9') { if(ch=='-') w=-1; ch=getchar(); } while(ch&gt;='0' &amp;&amp; ch&lt;='9') { //代替x=x*10+ch-'0'; x=(x&lt;&lt;1) + (x&lt;&lt;3) +(ch^48); ch=getchar(); } return x*w; } 快写 inline void print(int x) { if(x&lt;0) { putchar('-'); x=-x; } if(x&gt;9) print(x/10); putchar(x%10+'0'); } 字符串 读入 inline string rd() { string str=""; char ch=getchar(); //处理空格或回车 while(ch==' ' || ch=='\n' || ch=='\r') { ch=getchar(); } //读入 while(ch!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a53ef29d0b67032c75dda2aeb3a3bd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a99b0d61f41ddf8c8603f37773295204/" rel="bookmark">
			正则表达式统计日志状态码一个实例备忘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我想要提取日志里的 "status": xxx 这个键值对，我想要统计不同的状态码出现的次数。
最开始，我用的正则表达式是：
\"status\"\:.*,
它会把 status： 到最后一个 逗号 的字符串 都匹配出来。
后来学习了一下，改成以下这样就符合要求了：
\"status\"\:-?[0-9]*
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadec50ec40586b1719e6da8a0129498/" rel="bookmark">
			Firefox火狐浏览器主密码暴力破解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前网络上唯一的工具，即Firefox Master Password Cracker，即FireMaster和GUI版本，遗憾的是，其最新更新日期为2017年1月，也就是说，其无法支持最新的Firefox版本，仅支持58版本以前，即使用key3.db加密。
如果我们使用的是上古版本浏览器，当然可以使用这个工具，不过目前来开应该是过时了，且好像现在也没有其他的工具。
在58以后的版本中应该如何解决呢，我们来写一个简单快速的暴力破解程序。
不难发现的是，当要求我们登录时，Firefox产生了如下窗口：
我们不妨考虑在这个窗口中进行暴力破解，这里引入一个自动化键鼠控制的python模块：pyautogui。Pyautogui可以对屏幕内容进行识别判断定位，自动在指定的位置进行键鼠动作。
但是我们分析pyautogui的源码时发现，判断功能在定位时遵守一个先截图再判断的过程，在我们输入密码并点击登录后，输入框消失了大约0.2秒后重新出现，这导致了一个问题，如果想要准确判断，必须要暂停程序0.2秒后继续，同时，模块识别图像会有工作时间，所以判断是否成功会有相当大的延迟。
判断图片：
下面，我将提出另一种思路，使用win32对窗口进行操作：
我们用spy++获取到密码输入框窗口信息：
可以看到，窗口标题为“需要输入密码 - Mozilla Firefox”。
我们引入win32gui，下面是成品代码：
import time import win32gui import pyautogui as auto if __name__ == '__main__': FrameClass = "MozillaDialogClass" FrameTitle = "需要输入密码 - Mozilla Firefox" hwnd = win32gui.FindWindow(FrameClass, FrameTitle) if hwnd: win32gui.SetForegroundWindow(hwnd) f = open('passlist.txt') pw = f.readlines() i = 1 for p in pw: print(i, p) auto.typewrite(p) time.sleep(0.05) hwnd = win32gui.FindWindow(FrameClass, FrameTitle) if hwnd == 0: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cadec50ec40586b1719e6da8a0129498/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe69253fa7060e9def926400d70d025b/" rel="bookmark">
			【计算机视觉学习03】全景图像拼接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、基本原理1.1 图像拼接的几何原理1.2 直线,圆，复杂曲线方程拟合1.3 RANSAC算法1.4 APAP算法1.5 寻找最佳拼接缝（Seam Finding）1.5.1 最大流问题1.5.2 最大流问题的增广链算法1.5.3 最大流最小割定理 二、 图像拼接具体实现2.1 代码2.2 运行结果 一、基本原理 将两幅或多幅具有重叠区域的图像，通过特征匹配将具有相同的特征点（SIFT特征点）的图像拼接在一起，将来自多个不同视角拍摄的图像变换到同一视角下，拼接成一张宽视野图像。
图像拼接基础流程
针对某个场景拍摄多张/序列图像
计算第二张图像与第一张图像之间的变换关系
将第二张图像叠加到第一张图像的坐标系中
变换后的融合/合成
在多图场景中，重复上述过程
1.1 图像拼接的几何原理 全景融合的 3D 几何解释
图像被投影到共同的拼接平面上（同一坐标系）在拼接平面上实现全景融合 在拼接的应用中，其实可以简化理解为 2D图像的变换，叠加过程
1.2 直线,圆，复杂曲线方程拟合 给定若干二维空间中的点，求直线 y = a x + b y=ax+by=ax+b ，使得该直线对空间点的拟合误差最小。
直线确定步骤：
随机选择两个点根据该点构造直线给定阈值，计算 inliers 数量 我们在空间中随机寻找两个点，并以这两点构造出一条直线，然后计算在这条线上的对应 inliers 的数量，当 inliers 值达到我们需要的阈值，我们就得到了一条拟合直线。
用这种方法我们可以拟合出一条直线，那么圆可以拟合吗？复杂的曲线方程可以拟合吗？
对于圆，我们同样可以用该方法，两点确定一条直线，三点可以确定一个圆，我们随机确定三个点，然后确定一个圆的方程，然后计算在圆上的 inliers 值，之后的过程就与直线的一致了。
对于复杂的曲线方程，我们需要先给定一个方程式,这个方程式的参数是我们要求的，求出一个解，使得在 inliers 值尽可能多，或者是求出的曲线与点之间是最逼近。
1.3 RANSAC算法 RANSAC 是“RANdom SAmple Consensus”（随机一致性采样）的缩写。该方法是用来找到正确模型来拟合带有噪声数据的迭代方法。给定一个模型，例如点集之间的单应性矩阵，RANSAC 基本的思想是，数据中包含正确的点和噪声点，合理的模型应该能够在描述正确数据点的同时摒弃噪声点。 即从一组数据集（包含噪声点的数据集）中，能够从中挑选出正确的点，获取能够正确拟合的参数模型。
RANSAC的基本思想和算法流程如下：
随机采样K个点，K是求解模型参数的最少点个数；使用K个点估计模型参数；计算剩余点到估计模型的距离，距离小于阈值则为内点，统计内点的数目；重复步骤1~3，重复次数M且保留数目最多的内点；使用所有的内点重新估计模型。 1.4 APAP算法 在图像拼接融合的过程中，拼接融合后的图像可能会存在“鬼影现象”，即图像叠加后出现重影的现象。如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe69253fa7060e9def926400d70d025b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dab0fe6bdeb7b1438626e28c0b252df/" rel="bookmark">
			xlsx.js 实现前端 table 数据导出并下载为 excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 需求① 加载 xlsx.js② 引入 JS 代码③ 按钮绑定事件结果附源码 需求 在写一个 SSM 项目的时候需要添加 excel 数据导出的功能, 实质上也就是将从数据库中渲染到前端的数据保存为一个 excel 的形式并下载。
① 加载 xlsx.js xlsx.js 是由 SheetJS 出品的js-xlsx是一款非常方便的只需要纯JS即可读取和导出excel的工具库，功能强大，支持格式众多，支持 xls、xlsx、ods等十几种格式。附链接 Github 打包下载取库内的 js 文件即可。
dist &gt; xlsx.core.min.js 导入 js
&lt;script src="../js/xlsx.core.min.js"&gt;&lt;/script&gt; ② 引入 JS 代码 引自
如果需要使用的话, 注意以下两个步骤
为你的 table 定义 id, 并添加在 btn_export 函数中替换 table1,
定义 button 组件, 并添加 onclick 事件绑定函数 btn_export
&lt;script&gt; function btn_export() { var table1 = document.querySelector("#table1"); var sheet = XLSX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dab0fe6bdeb7b1438626e28c0b252df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11d27cfc802e5647179c5e41ab46c48d/" rel="bookmark">
			中阶C语言 结构体（typedef用法、多维结构体、指针、内嵌函数、赋值）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中阶C语言 结构体（typedef用法、多维结构体、指针、内嵌函数、赋值） type A： 多年工作经验告诉我这种方法最为标准实用，墙裂推荐
&lt;span style="color:#000000"&gt;&lt;code class="language-c"&gt;　&lt;span style="color:#c678dd"&gt;typedef&lt;/span&gt; &lt;span style="color:#c678dd"&gt;struct&lt;/span&gt; Student &lt;span style="color:#999999"&gt;{&lt;/span&gt; &lt;span style="color:#c678dd"&gt;int&lt;/span&gt; a&lt;span style="color:#999999"&gt;;&lt;/span&gt; &lt;span style="color:#999999"&gt;}&lt;/span&gt;Stu&lt;span style="color:#999999"&gt;;&lt;/span&gt; &lt;/code&gt;&lt;/span&gt; 使用方法：
&lt;span style="color:#000000"&gt;&lt;code class="language-c"&gt;	Stu exam&lt;span style="color:#999999"&gt;;&lt;/span&gt; &lt;/code&gt;&lt;/span&gt; type B： 省略了struct后面的内容
&lt;span style="color:#000000"&gt;&lt;code class="language-c"&gt;　&lt;span style="color:#c678dd"&gt;typedef&lt;/span&gt; &lt;span style="color:#c678dd"&gt;struct&lt;/span&gt; &lt;span style="color:#999999"&gt;{&lt;/span&gt; &lt;span style="color:#c678dd"&gt;int&lt;/span&gt; a&lt;span style="color:#999999"&gt;;&lt;/span&gt; &lt;span style="color:#999999"&gt;}&lt;/span&gt;Stu&lt;span style="color:#999999"&gt;;&lt;/span&gt; &lt;/code&gt;&lt;/span&gt; 使用方法：
&lt;span style="color:#000000"&gt;&lt;code class="language-c"&gt;	Stu exam&lt;span style="color:#999999"&gt;;&lt;/span&gt; &lt;/code&gt;&lt;/span&gt; type C： 省略了最后分号前的定义
&lt;span style="color:#000000"&gt;&lt;code class="language-c"&gt;　&lt;span style="color:#c678dd"&gt;typedef&lt;/span&gt; &lt;span style="color:#c678dd"&gt;struct&lt;/span&gt; stu &lt;span style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11d27cfc802e5647179c5e41ab46c48d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b59cacfef9c3f4ee0d3241922e38cd96/" rel="bookmark">
			组件化之二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 有志者，事竟成
APT技术 APT是什么？ APT(Annotation Processing Tool)
是一种处理注释的工具，它对源代码文件进行检测找出其中的Annotation，根据注解自动生成代码，如果想要自定义的注解处理器能够正常运行，必须要通过APT工具来进行处理。
也可以这样理解，只有通过声明APT工具后，程序在编译期间自定义注解解释器才能执行。
通俗理解：根据规则，帮我们生成代码、生成类文件
APT中用到的重要元素 ackageElement ：表示一个包程序元素。提供对有关包及其成员的信息的访问
ExecutableElement ：表示某个类或接口的方法、构造方法或初始化程序（静态或实例）
TypeElement：表示一个类或接口程序元素。提供对有关类型及其成员的信息的访问。
VariableElement：表示一个字段、enum常量、方法或构造方法参数、局部变量或异常参数
APT中用到API getEnclosedElements(） 返回该元素直接包含的子元素getEnclosingElement() 返回包含该element的父element，与上一个方法相反getKind () 返回element的类型，判断是哪种elementgetModifierso() 获取修饰关键字,入public static final等关键字getSimpleName()获取名字，不带包名getQualifiedName () 获取全名，如果是类的话，包含完整的包名路径getParameters() 获取方法的参数元素，每个元素是一个VariableElementgetReturnType() 获取方法元素的返回值getConstantValue() 如果属性变量被final修饰，则可以使用该方法获取它的值 高级用法JavaPoet JavaPoet是什么？ JavaPoet是square推出的开源java代码生成框架，提供JavaApi生成.java源文件这个框架功能非常实用，也是我们习惯的Java面向对象OOP语法,可以很方便的使用它根据注解生成对应代码,通过这种自动化生成代码的方式， 可以让我们用更加简洁优雅的方式要替代繁琐冗杂的重复工作
JavaPoet相关 类对象说明MethodSpec代表一个构造函数或方法声明TypeSpec代表一个类，接口，或者枚举声明FieldSpec代表一个成员变量，一个字段声明JavaFile包含一个顶级类的Java文件ParameterSpec用来创建参数AnnotationSpec用来创建注解ClassName用来包装一个类TypeName类型，如在添加返回值类型是使用 TypeName. voID S 字 符 串 ， 如 : S字符串，如: S字符串，如:s, ” hello” T 类 、 接 口 ， 如 : T类、接口，如: T类、接口，如:T， MainActivity 高级用法JavaPoet JavaPoet到底是什么？
​答：oop思想方式：优点（加入oop思想）缺点（不习惯，倒序）
JavaPoet真的比传统方式好吗？
答：并不是这样的，如果复杂的代码生成，反而效率低下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01db3394f1fce3df80f71a19a0473626/" rel="bookmark">
			Java下一代高并发技术——虚拟线程“JEP 425: Virtual Threads (Preview)”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多语言都有类似于“虚拟线程”的技术，比如Go、C#、Erlang、Lua等，他们称之为“协程”。 不管是虚拟线程还是协程，他们都是轻量级线程，其目的都是为了提高并发能力。
本节详细介绍Java平台的“虚拟线程”的技术——“JEP 425: Virtual Threads (Preview)”。
Java平台计划引入虚拟线程，可显著减少编写、维护和观察高吞吐量并发应用程序的工作量。“JEP 425: Virtual Threads (Preview)”目是一个预览性的API。
目标 使以简单的线程每请求风格编写的服务器应用程序能够以近乎最佳的硬件利用率进行扩展。启用使用java.lang.Thread API的现有代码，以最小的更改采用虚拟线程。使用现有的JDK工具，轻松地对虚拟线程进行故障排除、调试和分析。 非目标 目标不是删除线程的传统实现，也不是静默迁移现有应用程序以使用虚拟线程。改变Java的基本并发模型并不是目标。在Java语言或Java库中提供新的数据并行结构并不是目标。Stream API仍然是并行处理大型数据集的首选方式。 动机 近30年来，Java开发人员一直依赖线程作为并发服务器应用程序的构建块。每个方法中的每个语句都在线程内执行，由于Java是多线程的，多个执行线程同时发生。线程是Java的并发单元：一段顺序代码，与其他此类单元同时运行，而且在很大程度上独立于其他此类单元。每个线程都提供一个堆栈来存储局部变量和协调方法调用，以及出错时的上下文：异常被同一线程中的方法抛出和捕获，因此开发人员可以使用线程的堆栈跟踪来查找发生了什么。线程也是工具的核心概念：调试器逐步浏览线程方法中的语句，分析器可视化多个线程的行为，以帮助了解它们的性能。
线程每请求样式 服务器应用程序通常处理相互独立的并发用户请求，因此应用程序通过在请求的整个持续时间内将线程专用于该请求来处理请求是有意义的。这种线程每请求风格易于理解、易于编程、易于调试和分析，因为它使用平台的并发单位来表示应用程序的并发单位。
服务器应用程序的可扩展性遵循利特尔定律（Little’s Law），它与延迟、并发和吞吐量有关：对于给定的请求处理持续时间（即延迟），应用程序同时处理的请求数（即，并发）必须与到达速率（即吞吐量）成比例增长。例如，假设平均延迟为50ms的应用程序通过同时处理10个请求，实现每秒200个请求的吞吐量。为了使该应用程序扩展到每秒2000个请求的吞吐量，它需要同时处理100个请求。如果每个请求在请求的持续时间内都在线程中处理，那么，要使应用程序跟上，线程数量必须随着吞吐量的增长而增长。
不幸的是，可用线程的数量是有限的，因为JDK将线程作为操作系统（OS）线程的包装器实现。操作系统线程成本高昂，因此我们不能拥有太多线程，这使得实现不适合线程每请求风格。如果每个请求在其持续时间内消耗一个线程，从而消耗一个操作系统线程，那么线程数量通常在其他资源（如CPU或网络连接）耗尽之前很久就成为限制因素。JDK当前的线程实现将应用程序的吞吐量限制在远低于硬件所能支持的水平。即使线程池化，也会发生这种情况，因为池化有助于避免启动新线程的高成本，但不会增加线程总数。
使用异步风格提高可扩展性 一些希望充分利用硬件的开发人员放弃了每请求线程风格，转到线程共享风格。请求处理代码不是从头到尾处理一个线程上的请求，而是在等待I/O操作完成时将其线程返回到池，以便线程可以为其他请求提供服务。这种细粒度的线程共享–在这种共享中，代码仅在线程执行计算时保留线程，而不是在等待I/O时保留线程–允许大量并发操作，而不会消耗大量线程。虽然它消除了操作系统线程稀缺性对吞吐量的限制，但它的代价很高：它需要所谓的异步编程风格，使用一组单独的I/O方法，这些方法不等待I/O操作完成，而是，稍后，向回调表示它们的完成。如果没有专用线程，开发人员必须将其请求处理逻辑分解为小阶段，通常编写为lambda表达式，然后使用API将它们组合成顺序管道(请参见CompletableFuture，或所谓的“反应性”（reactive）框架。因此，它们放弃了语言的基本顺序组成运算符，如循环和try/catch块。
在异步风格中，请求的每个阶段都可能在不同的线程上执行，每个线程以交错的方式运行属于不同请求的阶段。这对理解程序行为具有深刻的影响：堆栈跟踪不提供可用的上下文，调试器无法逐步完成请求处理逻辑，分析器无法将操作的成本与其调用者关联起来。在使用Java时，编写lambda表达式是可以管理的Stream API在短管道中处理数据，但当应用程序中的所有请求处理代码都必须以这种方式编写时，就会有问题。这种编程风格与Java平台不一致，因为应用程序的并发单位–异步管道–不再是平台的并发单位。
使用虚拟线程保留线程每请求样式 为了使应用程序能够扩展，同时与平台保持和谐，我们应该通过更有效地实现线程来努力保留每个请求的线程风格，这样它们就可以更丰富。操作系统无法更有效地实现操作系统线程，因为不同的语言和运行时以不同的方式使用线程堆栈。但是，Java运行时可以以一种将Java线程与操作系统线程的一对一对应关系分开的方式实现Java线程。就像操作系统通过将大量虚拟地址空间映射到有限数量的物理RAM来给人丰富内存的错觉一样，Java运行时也可以通过将大量虚拟线程映射到少量操作系统线程来给人丰富线程的错觉。
虚拟线程是java.lang.Thread的一个实例，它不绑定到特定的操作系统线程。相比之下，平台线程是java.lang.Thread的实例，以传统方式实现，作为操作系统线程周围的精简包装器。
线程每请求样式中的应用程序代码可以在虚拟线程中运行整个请求持续时间，但虚拟线程仅在CPU上执行计算时消耗操作系统线程。结果是与异步风格相同的可扩展性，只是它是透明的：当在虚拟线程中运行的代码调用java中的阻塞I/O操作的java.* API时，运行时执行非阻塞操作系统调用，并自动挂起虚拟线程，直到稍后可以恢复。对于Java开发人员来说，虚拟线程只是创建起来很便宜，而且几乎无限丰富的线程。硬件利用率接近最佳，允许高水平的并发性，从而实现高吞吐量，同时应用程序与Java平台及其工具的多线程设计保持和谐。
虚拟线程的含义 虚拟线程既便宜又丰富，因此永远不应该池化：应该为每个应用程序任务创建一个新的虚拟线程。因此，大多数虚拟线程都是短暂的，并且具有浅调用堆栈，执行的时间只需单个HTTP客户端调用或单个JDBC查询。相比之下，平台线程是重量级和昂贵的，因此通常必须池化。它们往往是长寿命的，具有深度的调用堆栈，并在许多任务中共享。
总之，虚拟线程保留了可靠的每请求线程风格，该风格与Java平台的设计和谐，同时优化地利用硬件。使用虚拟线程不需要学习新的概念，尽管它可能需要养成不学习的习惯，以应对当今线程的高成本。虚拟线程不仅将帮助应用程序开发人员，还将帮助框架设计人员提供易于使用的API，这些API与平台的设计兼容，而不影响可扩展性。
描述 今天，每一个例子 java.lang.Thread在JDK中，是一个平台线程。平台线程在底层操作系统线程上运行Java代码，并在代码的整个生命周期内捕获操作系统线程。平台线程数限制为操作系统线程数。
虚拟线程是java.lang.Thread的一个实例，它在基础操作系统线程上运行Java代码，但在代码的整个生命周期内不捕获操作系统线程。这意味着许多虚拟线程可以在同一操作系统线程上运行其Java代码，有效地共享它。虽然平台线程垄断了宝贵的操作系统线程，但虚拟线程却不垄断。虚拟线程的数量可以远大于操作系统线程的数量。
虚拟线程是由JDK而不是操作系统提供的线程的轻量级实现。它们是用户模式线程的一种形式，在其他多线程语言中已经成功（例如，Go中的goroutine和Erlang中的进程）。用户态线程甚至被称为“green threads”在Java的早期版本中，当时操作系统线程还不成熟和广泛。然而，Java的green threads都共享一个操作系统线程（M:1调度），平台线程被实现为操作系统线程的包装器（1:1调度）。虚拟线程采用M:N调度，其中大量（M）虚拟线程被调度在较少数量（N）的操作系统线程上运行。
使用虚拟线程vs平台线程 开发者可以选择使用虚拟线程还是平台线程。这里是一个创建大量虚拟线程的示例程序。程序首先获取一个ExecutorService这将为每个提交的任务创建一个新的虚拟线程。然后，它提交10,000个任务，并等待所有任务完成：
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) { IntStream.range(0, 10_000).forEach(i -&gt; { executor.submit(() -&gt; { Thread.sleep(Duration.ofSeconds(1)); return i; }); }); } // executor.close() is called implicitly, and waits 本例中的任务是简单的代码–睡眠一秒钟–现代硬件可以轻松支持10000个虚拟线程同时运行此类代码。在幕后，JDK在少量的操作系统线程上运行代码，也许只有一个线程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01db3394f1fce3df80f71a19a0473626/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac8932d2cef838e13af0f5dc9b61b986/" rel="bookmark">
			Room数据库实战：搭配RxJava使用与封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 接着上一篇Room的基本使用介绍（不会Room基本使用的先看这一篇），每次使用增删改查功能都需要new Thread，不方便也不好管理，本章主要介绍RxJava如何搭配Room使用。
二、引入RxJava库 def latest_version = "2.2.5" //room implementation "androidx.room:room-runtime:$latest_version" implementation "androidx.room:room-ktx:$latest_version" kapt "androidx.room:room-compiler:$latest_version" // optional - RxJava support for Room implementation "androidx.room:room-rxjava2:$latest_version" 三、项目实战 使用前需要先准备数据实体，数据库，数据访问对象（DAO）。 其中数据实体和数据库的内容与上一篇的内容一样，核心在数据访问对象的修改。
数据实体 @Entity class RunRecord { @PrimaryKey(autoGenerate = true) var id: Long? = null @ColumnInfo(name = "userId") var userId: String? = null @ColumnInfo(name = "pathLine") var pathLine: String? = null @ColumnInfo(name = "totalStep") var totalStep:Int? = 0 } 数据库 @Database(entities = [ RunRecord::class], version = 1) abstract class YzDatabase : RoomDatabase() { abstract fun runDao(): RunDao?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac8932d2cef838e13af0f5dc9b61b986/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31fd504a0388f3dca4726973f68de0ab/" rel="bookmark">
			SLAM相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SLAM相关论文摘要 相关算法关系图
高精度地图定位
由于一些停车场是在室内，所以对于车辆的定位问题，如果没有高精度地图的支撑是很难解决的，有了髙精度地图数据，车辆通过自身车辆的摄像头等视觉设备，提取停车场的一些关键特征，然后通过这些特征与髙精度地图进行比对，进而可以得到车辆的自身位置，这就是高精度地图提供的定位功能。
高精度地图相关
高精度地图的构建由五个过程组成：数据采集，数据处理，对象检测，手动验证和地图发布。数据采集是一个巨大的工程，Apollo 拥有近 300 辆专业车辆用于数据采集，这些数据采集车不仅仅用于数据采集，对于地图的维护更新也非常重要，它可以随时的更新地图数据。专业车辆具有角度的传感器，比如 GPS、惯性测量单元 (IMU)、激光雷达摄像机，Apollo定义了一个硬件框架，将这些传感器集成到单个自主系统中，通过将这些数据的融合，最终生成高精度地图。数据处理是指对手机的数据进行整理、分类以及清洗的过程，以获得没有任何语义信息或注释的初始地图模板。对于对象检测，Apollo 团队使用人工智能来检测静态对象并对其进行分类，包括车道线、交通标志甚至电线杆。手动验证可以确保自动地图创建过程正确并及时发现问题。经过了上述过程的处理，地图可以进行发布，除了发布高精度地图，Apollo还发布了采用自上而下视图的相对定位地图以及三维点云地图。 基于 GNSS/IMU/激光雷达的高精度地图生成算法研究 （吉大硕士论文2021）
1. 定位与地图构建（Simultaneous Localization and Mapping，SLAM）
是一种高精度点云地图生成算法。根据使用的传感器不同，SLAM 也分为视觉 SLAM 和激光 SLAM。视觉设备极易受到外界光线因素的干扰，相比之下激光雷达的点云数据更加稳定，同时激光雷达采集到的点云信息可以更好地反应周围环的结构信息。
2.激光 SLAM 主要可以分为前端里程计、后端优化、建图等步骤。
前端里程计的作用是利用点云配准来获取相邻两帧激光雷达之间的刚性变换。IMU 预积分的结果可以为前端里程计提供初始的位姿变换矩阵。前端里程计只考虑了相邻两帧之间的位姿变换关系，所以会存在累计误差。后端优化通过加入回环检测、GNSS 绝对值等约束来降低累计误差带来的影响。建图是将各个相邻的点云以点云拼接的方式生成点云地图。
PNP ICP 主流slam框架
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/280/">«</a>
	<span class="pagination__item pagination__item--current">281/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/282/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>