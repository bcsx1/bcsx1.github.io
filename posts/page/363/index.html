<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94c8d236b7f3b687213104e3093fa9c7/" rel="bookmark">
			cocosCreator---物理引擎（未完待续... 最新更新时间21/4/28）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		顺着自己能够理解的思想、实际使用的角度来解释，分享
在写这篇文章之前，使用过很多次物理引擎，但是想使用的时候还是的重新看官方文档，这次先顺着自己思路来，看能想到那，在看文档，观察自己有什么不足
先总观一下 上面为官方实例关于碰撞检测部分
上面为文档
现在的我还不能看出他们之间的关系，但容我慢慢掰开啦揉碎啦，整明白
碰撞系统 操作步骤：（白话版）
1.找到你要设置碰撞的节点，挂载上碰撞组件（Collider 组件: Polygon（多边形），Circle（圆形），Box（矩形）），设计碰撞体形状区域
2.然后在这个节点挂在上控制脚本，主要就是控制碰撞是否开启，和碰撞的状态，主要在3个回调函数（1）onCollisionEnter（other，self） 当碰撞产生的时候调用 other 产生碰撞的另一个碰撞组件 self 产生碰撞的自身的碰撞组件
（2）onCollisionStay（other，self） 当碰撞产生后，碰撞结束前的情况下，每次计算碰撞结果后调用
（3）onCollisionExit（other，self） 当碰撞结束后调用
3.注意 注意 注意 别忘了设置碰撞分组管理，在Group属性中，选择自己到底属于哪一类。
如果现在节点是单独一类，点击编辑，先在上面添加好分组（看好添加分组后的请注意，想好啦在添加分组）；然后想让那个分组与那个分组擦除火花，就在他们交集点勾上（有点像月老，哈哈哈）
你能用的上 一、
记住这个辅助类 cc.Intersection，用于测试形状与形状是否相交，
至于这个形状有：1.点 2.线段 3.圆形 4.矩形 5.多边形
你就想想是不是能能做老多游戏啦
二、
在上面碰撞的3个状态中，3个反馈函数，都会有other与self入参，在你要获取碰撞体形状时，都可以在这里找到。看栗子：
onCollisionEnter: function (other, self) { console.log('on collision enter'); // 碰撞系统会计算出碰撞组件在世界坐标系下的相关的值，并放到 world 这个属性里面 var world = self.world; // 碰撞组件的 aabb 碰撞框 var aabb = world.aabb; // 节点碰撞前上一帧 aabb 碰撞框的位置 var preAabb = world.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94c8d236b7f3b687213104e3093fa9c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc1ca20b9a1892fe9fa97baca074b5d/" rel="bookmark">
			51单片机c语言基本结构,51单片机的内部组成及应用原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述
1、单片机内部资源
STC89C52：8KFLASH、512字节RAM、32个IO口、3个定时器、1个UART、8个中断源
(1)Flash(硬盘)——程序存储空间 —— 擦写10万次，断电数据不丢失，读写速度慢
(2)RAM(内存)——数据存储空间 —— 断电数据丢失，读写速度快，无限次使用
(3)SFR —— 特殊功能寄存器
2、单片机最小系统
最小系统：最少组件组成单片机可以工作的系统。
三要素：
(1)、 电源电路：5V
(2)、 晶振电路：11.0592MHZ、两个30PF
(3)、 复位电路：
P0：开漏输出，必须加上拉电阻
准双向口：
强推挽输出：电流驱动能力强
高阻态
上下拉电阻：上拉电路就是将不确定的信号通过一个电阻拉到高电平，同时限流作用。下拉电阻就是下拉到低电平。
上下拉电阻选取：从降低功耗方面考虑应该足够大，因为电阻越大，电流越小；驱动能力来看，小电阻
3、硬件基础知识
(1)、电磁干扰(EMI)——静电放电(ESD)、快速瞬间脉冲群(EFT)、浪涌(Surge)
(2)、去耦电容的使用
低频滤波电容，平常应用最多的事钽电容，电解电容，陶瓷电容，起到去除电源低频纹波，稳定电源的作用。
高频滤波电容，电容附近，通常用104电容来进行去除高频干扰。
(3)、三极管(PNP，NPN) b，c，e --- 电压驱动
控制应用
驱动应用
4、LED发光二极管——电流驱动
通常红色贴片LED， 靠电流驱动，电压1.8V~2.2V，电流1~20mA，在1~5mA亮度有所变化，5mA以上亮度基本不变。
VCC 电压是 5V，发光二极管自
身压降大概是 2V，那么在右边 R34 这个电阻上承受的电压就是 3V。
R = U/I —— 1~20mA —— R：150~3K
5、C语言基础
(1)、基本运算符
+ - * / % ++ -- = == ！= += -= 《《 》》 &amp;&amp; “| ！ &amp; | ~ ^
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dc1ca20b9a1892fe9fa97baca074b5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f745aab738a78593718ce3c250e0315b/" rel="bookmark">
			对软件测试人员的要求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		朱少民老师：
​ 不少计算机软件业界人士认为，对软件测试人员要求比较低、容易招聘，只要他们会操作计算机、有一定的软件经验就可以了。他们认为，软件测试人员要一步一步操作所要测的软件，就能发现程序中的问题；或者依据软件产品规格设计说明书，通过和软件的实际表现进行对比就能够发现两者不一致的地方，发现缺陷，这些都不需要什么技术。
​ 这种想法是错误的。测试工作的确是一项技术工作，不局限与功能测试，在进行集成测试和系统测试时，测试人员必须明白被测软件系统的实现原理、方法以及设计的各种第三方平台、技术等内容。专职测试人员可能要进行数据库测试，这时需要数据库设计、开发和性能调优等能力；专职测试人员有时需要开发测试工具，或针对某测试工具开发测试脚本，这时需要良好的编程能力，而且拥有编程或开发经验的测试人员会对软件开发过程有更深的理解，对于开发人员、项目经理的沟通、测试工作改进等会有很大帮助。在进行性能测试、安全性测试、可靠性测试和兼容性测试等工作时，这就要求测试人员掌握系统架构设计、系统特性标识、系统环境设置等方面的知识。测试的方法也不能局限于黑盒测试方法，还要结合白盒测试方法，这就要求测试人员具有一定的编程经验和系统架构知识。对软件测试人员的要求，不仅在技术上有较高的要求，而且在沟通能力、理解能力、分析问题能力等方面的要求会更高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bccb1794f5c207644bcdee6414b0a14/" rel="bookmark">
			c语言兼容ipv4 ipv6的结构体,C&#43;&#43; IPv4与IPv6的兼容编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		structaddrinfo hints, *res, *ressave;
bzero(&amp;hints,sizeof(hints));
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;
hints.ai_protocol = IPPROTO_IP;
官网：
https://developer.apple.com/library/mac/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html#//apple_ref/doc/uid/TP40010220-CH213-SW1
Check Source Code for IPv6 DNS64/NAT64 Incompatibilities
Check for and eliminate IPv4-specific APIs, such as:
inet_addr()
inet_aton()
inet_lnaof()
inet_makeaddr()
inet_netof()
inet_network()
inet_ntoa()
inet_ntoa_r()
bindresvport()
getipv4sourcefilter()
setipv4sourcefilter()
If your code handles IPv4 types, make sure the IPv6 equivalents are handled too.
IPv4
IPv6
AF_INET
AF_INET6
PF_INET
PF_INET6
struct in_addr
struct in_addr6
struct sockaddr_in
struct sockaddr_in6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bccb1794f5c207644bcdee6414b0a14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94cfd738575440df422cd0214dea90cd/" rel="bookmark">
			[大数据]Kafka(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.Kafka API 4.1 Producer API 4.1.1 消息发送流程 Kafka的Producer发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了两个线程——main线程和Sender线程，以及一个线程共享变量——RecordAccumulator。main线程将消息发送给RecordAccumulator，Sender线程不断从RecordAccumulator中拉取消息发送到Kafka broker。
相关参数：
batch.size：只有数据积累到batch.size之后，sender才会发送数据。
linger.ms：如果数据迟迟未达到batch.size，sender等待linger.time之后就会发送数据。
4.1.2 异步发送API 1）导入依赖
&lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;/dependency&gt; 2）代码
Producer.java
需要用到的类：
KafkaProducer：需要创建一个生产者对象，用来发送数据
ProducerConfig：获取所需的一系列配置参数
ProducerRecord：每条数据都要封装成一个ProducerRecord对象
回调函数会在producer收到ack时调用，为异步调用，该方法有两个参数，分别是RecordMetadata和Exception，如果Exception为null，说明消息发送成功，如果Exception不为null，说明消息发送失败。
import org.apache.kafka.clients.producer.Callback; import org.apache.kafka.clients.producer.KafkaProducer; import org.apache.kafka.clients.producer.ProducerRecord; import org.apache.kafka.clients.producer.RecordMetadata; import java.util.Properties; public class Producer { public static void main(String[] args) { //1.实例化kafka集群 Properties properties = new Properties(); properties.setProperty("key.serializer", "org.apache.kafka.common.serialization.StringSerializer"); properties.setProperty("value.serializer", "org.apache.kafka.common.serialization.StringSerializer"); properties.setProperty("acks", "all"); properties.setProperty("bootstrap.servers", "hadoop102:9092"); KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;String, String&gt;(properties); //2.用集群对象发送数据 for (int i = 0; i &lt; 10; i++) { producer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94cfd738575440df422cd0214dea90cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/874e58f79466f454587323b859f81e1f/" rel="bookmark">
			解决一个机器学习问题时，你的流程是怎样的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单地说，大多数机器学习算法可以分成训练(training)和测试(testing)两个步
骤，这两个步骤可以重叠进行。训练，一般需要训练数据，就是告诉机器前人的
经验，比如什么是猫、什么是狗、看到什么该停车。训练学习的结果，可以认为
是机器写的程序或者存储的数据，叫模型(model)。总体上来说，训练包括有监督
(supervised learning)和无监督(unsupervised learning)两类。有监督好比有老师告
诉你正确答案；无监督仅靠观察自学，机器自己在数据里找模式和特征。深度学
习（deep learning）是机器学习的一种方法，它基于神经元网络，适用于音频、视
频、语言理解等多个方面。
解决机器学习问题的一般流程如下：
1.数据收集
业界有一句非常著名的话：“数据决定了机器学习的上界，而模型和算法只是逼近这个上界。”由此可见，数据对于整个机器学习项目至关重要。通常，我们拿到一个具体的领域问题后，可以使用网上一些具有代表性的、大众经常会用到的公开数据集。相较于自己整理的数据集，显然大众的数据集更具有代表性，数据处理的结果也更容易得到大家的认可。此外，大众的数据集在数据过拟合、数据偏差、数值缺失等问题上也会处理的更好。但如果在网上找不到现成的数据，那我们只好收集原始数据，再去一步步进行加工、整理，这将是一个漫长的过程，需要我们足够细心。
2.数据预处理与特征工程
即使我们能够拿到大众认可度比较高的代表性数据集，该数据集也会或多或少存在数据缺失、分布不均衡、存在异常数据、混有无关紧要的数据等诸多数据不规范的问题。这就需要我们对收集到的数据进行进一步的处理、包括数据的清洗、数据的转换、数据标准化、缺失值的处理、特征的提取、数据的降维等方面。我们把对数据的这一系列的工程化活动，叫做“特征工程”。我们通常使用sklearn库来处理数据、提取特征，sklearn是机器学习中最常见的一个第三方模块，里边封装了大量特征处理的方法，详细方法请参阅sklearn官方手册： http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing。
3.模型的选择与训练
可供选择的机器学习模型有很多，每个模型都有自己的适用场景，那么如何选择合适的模型呢？首先我们要对处理好的数据进行分析，判断训练数据有没有类标，若是有类标则应该考虑监督学习的模型，否则可以划分为非监督学习问题。其次分析问题的类型是属于分类问题还是回归问题，当我们确定好问题的类型之后再去选择具体的模型。在模型的实际选择时，通常会考虑尝试不同的模型对数据进行训练，然后比较输出的结果，选择最佳的那个。此外，我们还会考虑到数据集的大小。若是数据集样本较少，训练的时间较短，通常考虑朴素贝叶斯等一些轻量级的算法，否则的话就要考虑SVM等一些重量级算法。
4.模型的评估与优化
一些常见的模型评估的指标和方法。例如：我们可以选择查准率、查全率、AUC指标表现更好的模型；还可以通过交叉验证法用验证集来评估模型性能的好坏；当然，也可以针对一种模型采用多种不同的方法，每种方法给予不同的权重值，来对该模型进行综合“评分”。
在模型评估的过程中，我们可以判断模型的“过拟合”和“欠拟合”。若是存在数据过度拟合的现象，说明我们可能在训练过程中把噪声也当作了数据的一般特征，可以通过增大训练集的比例或是正则化的方法来解决过拟合的问题；若是存在数据拟合不到位的情况，说明我们数据训练的不到位，未能提取出数据的一般特征，要通过增加多项式维度、减少正则化参数等方法来解决欠拟合问题。最后，为了使模型的训练效果更优，我们还要对所选的模型进行调参，这就需要我们对模型的实现原理有更深的理解。
此外，在实际项目中，我们还会对机器学习的模型进行模型的融合，根据模型的重要程度对每个模型设置不同的权重等，以调高模型的准确率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e345f8b628a47473308a7f3651991831/" rel="bookmark">
			python append 坑 bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 append 之后发现值被覆盖
概述 list 和字典 append 导致问题
详细 发现a是会变的，如果append字典之后并且字典的VALUE值发生变化，那么a也会跟着变
模拟 class baidu1spider(): a=[] b ={} b['b']='23' for i in range(0,1): print(a) print('-分割-') a.append(b) print(a) print('修改b') # b=[] b['b']=10 print('重新打印a') print(a) print(b) print('结束') 打印结果
[] -分割- [{'b': '23'}] 修改b 重新打印a [{'b': 10}] {'b': 10} 结束 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10e442d5f381cfd52200a2789a7788c/" rel="bookmark">
			BSC链节点搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BSC官网文档: https://docs.binance.org/smart-chain/developer/fullnode.html
1.确保您已安装Go 1.13+并已添加GOPATH到PATH环境变量中 这里具体可以参考Heco的文章
2.下载源代码 git clone https://github.com/binance-chain/bsc
cd bsc
make geth
cd /bsc/build/bin
3.下载配置文件 注意：不同的配置文件接入的网络不同 下载genesis.json并config.toml通过：
主网： wget https://github.com/binance-chain/bsc/releases/download/v1.1.0-beta/mainnet.zip
unzip mainnet.zip
测试网： wget https://github.com/binance-chain/bsc/releases/download/v1.1.0-beta/testnet.zip
unzip testnet.zip
./*geth --datadir node init genesis.json
会看到以下输出
INFO [05-19|14:53:17.468] Allocated cache and file handles database=/Users/huangsuyu/Downloads/bsc/node/geth/chaindata cache=16.00MiB handles=16 INFO [05-19|14:53:17.498] Writing custom genesis block INFO [05-19|14:53:17.501] Persisted trie from memory database nodes=21 size=56.84KiB time=357.915µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=-574.00B INFO [05-19|14:53:17.502] Successfully wrote genesis state database=chaindata hash=7d79cc…fb0d1e INFO [05-19|14:53:17.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a10e442d5f381cfd52200a2789a7788c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4331730ac6827412853271020d454051/" rel="bookmark">
			Scapy的下载和安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 Python 2https://wizardforcel.gitbooks.io/scapy-docs/content/5。下载并安装 Scapy。（对于非Linux平台）：安装libpcap和libdnet及其 Python 包装器。（可选）：安装用于特殊功能的其他软件。使用 root 权限运行 Scapy。 每个步骤可以以不同的方式完成，具体取决于你的平台和要使用的 Scapy 版本。
目前，Scapy 有两个不同版本：
Scapy v1https://wizardforcel.gitbooks.io/scapy-docs/content/x。它只包含一个文件，并适用于 Python 2https://wizardforcel.gitbooks.io/scapy-docs/content/4，因此它可能更易于安装。 此外，你的操作系统可能已经含有一个为之特别准备的包或端口。 最后一个版本是 v1https://wizardforcel.gitbooks.io/scapy-docs/content/2https://wizardforcel.gitbooks.io/scapy-docs/content/2。Scapy v2https://wizardforcel.gitbooks.io/scapy-docs/content/x。当前的开发版本增加了多个功能（例如 IPv6）。 它包括以distutils标准方式打包的几个文件。 Scapy v2 需要 Python 2https://wizardforcel.gitbooks.io/scapy-docs/content/5。 注意：在 Scapy v2 中使用from scapyhttps://wizardforcel.gitbooks.io/scapy-docs/content/all import *来代替from scapy import *。
以下步骤描述如何安装（或更新）Scapy 本身。 根据你的平台，可能需要安装一些额外的库才能使其真正工作。 所以，请大家在平台特定之指南中查看如何安装这些必需的东西。
注意：以下步骤适用于类 Unix 操作系统（Linux，BSD，Mac OS X）。 对于 Windows，请参阅下面的特殊章节。
确保在继续之前安装了 Python。
将最新版本下载到临时目录，并以distutils标准方式来安装。
$ cd /tmp$ wget scapyhttps://wizardforcel.gitbooks.io/scapy-docs/content/net$ unzip scapy-latesthttps://wizardforcel.gitbooks.io/scapy-docs/content/zip$ cd scapy-2https://wizardforcel.gitbooks.io/scapy-docs/content/*$ sudo python setuphttps://wizardforcel.gitbooks.io/scapy-docs/content/py install 或者，你也可以执行 Zip 文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4331730ac6827412853271020d454051/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/492c71d4c33da39bc182425d7f555580/" rel="bookmark">
			python项目Flask框架配置端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接使用代码指定，无效，还是默认的端口5000
from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello World!' if __name__ == '__main__': app.run() 需要指定options -p 8080
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08d648709c97a212819cdf9166d33250/" rel="bookmark">
			sleep函数的头文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、windows下的Sleep函数，首字母大写
#include &lt;windows.h&gt; 参数usigned long类型，为毫秒数
Sleep(1)；
2、linux下的sleep函数，首字母小写
#include &lt;unistd.h&gt; 其参数为秒数
sleep(1)；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5004c42e68d262014b484332419a7d80/" rel="bookmark">
			在js文件中引入（调用）另一个js文件的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一，在调用文件的顶部加入下例代码 function addScript(url){ document.write("&lt;script language=javascript src="+url+"&gt;&lt;/script&gt;"); } 注：有时你引用的文件还可能需要引用其他的js,我们需要将需要的那个js文件也以同样的方法引用进来。
方法二，在js中写如下代码： function addScript(url){ var script = document.createElement('script'); script.setAttribute('type','text/javascript'); script.setAttribute('src',url); document.getElementsByTagName('head')[0].appendChild(script); } 利用document.createElement(”script”)生成了一个script的标签，设置其 type属性为text/javascript。
方法三，利用es6中export和import实现模块化 一个js文件代表一个js模块 。ES6引入外部模块分两种情况：
1.导入外部的变量或函数等；
import {firstName, lastName} from './test'; 2.导入外部的模块，并立即执行
import './test' //执行test.js，但不导入任何变量 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91086c9976eb337cb58ae0cdfa36f909/" rel="bookmark">
			c语言函数怎么返回,C语言函数的返回值应该怎么返回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用实例来说明，我们定义一个简单函数
int add( int a int b){
int sum;
sum= a+b;
return sum; // 这里就是返回值
}
有几点需要注意：
1. 返回值类型必须和函数声明时的类型兼容，这里不是一致是因为允许自动类型转换，比如函数声明为int，但返回的值是return 的值实为char也是允许的，因为char 兼容于int， 类型兼容还是会引发编译警告， 但类型不兼容会引发编译错误。 最好提前进行显式强制类型转换来去除编译警告。
2. 如果函数声明了类型，则表明必须有对应返回值，必须有return语句进行返回
3. 返回值需要接收来使用，不接收的返回值没有用，需要理解正确调用有返回值的函数，返回值肯定存在的，但不一定用到，比如
add(5 7); // 是一次对add函数的正确调用，产生了返回值12，但因为这里没有接收返回值，所以这个调用其实是无意义的，对这种返回值代表函数执行价值的函数，必须采用正确的方法接收函数返回值来进行后续处理，如这里
int mysum;
mysum = add( 5 7);
但另外后面可能接触到一些函数虽然有返回值，但实际当处理信息的传递采用了另外的手段，返回值只表示执行状态，如果能确保都能被正确执行，则返回值可以不接收。比如常用的printf函数声明中其实有一个int 返回值代表函数执行状态，我们一般没有接收使用的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ae8524e24b2cf5c18551a8a4c8a381e/" rel="bookmark">
			版本控制工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.版本控制工具简介 1.1什么是版本控制工具 版本控制工具提供完备的版本管理功能，用于存储、追踪目录(文件夹)和文件的修改历史，是软件开发者的必备工具，是软件公司的基础设施。
版本控制最主要的功能就是追踪文件的变更。它将什么时候、什么人更改了文件的什么内容等信息忠实地了已录下来。每一次文件的改变，文件的版本号都将增加。除了记录版本变更外，版本控制的另一个重要功能是并行开发。软件开发往往是多人协同作业，版本控制可以有效地解决版本的同步以及不同开发者之间的开发通信问题，提高协同开发的效率。并行开发中最常见的不同版本软件的错误(Bug)修正问题也可以通过版本控制中分支与合并的方法有效地解决。
1.2版本控制工具的作用 (1)协同态发
团队协作共同完成同一个项目。
(2)版本管理
以不断提升项目版本的方式逐步完成项目。
(3)数据备份
开发中以版本控制的形式保存每一个历史版本。
(4)权限控制
对团队开发人员进行不同的权限分配。
(5)分支管理
允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。
1.3市面上常见的版本控制工具及分类 a.集中式版本控制工具：cvs、svn、vss
不同的客户端直接跟服务器端交互工作，可以进行提交操作、克隆操作等。不同客户端之间是相互独立的。
b.分布式版本控制工具：Git、Mercurial、 Bazaar、 Darcs......
每个用户都有自己在本地的仓库,用来管理版本控制,每个客户端也同时是一个服务器。同时也可以用一个专门的服务器（也可叫远程服务器，在上图没有画出来）的仓库用来管理，当每多个客户端需要交互的时候，就需要用到远程服务器。
2. Git简介 2.1 Git概述 Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 起初是Linus Torvalds 为了帮助管理Linux 内核开发而开发的一个开放源码的版本控制软件。
2.2 Git的优点 (1)适合分布式开发，强调个体。
(2)公共服务器压力和数据量都不会太大。
(3)速度快、灵活。
(4)相对容易的解决冲突。
(5)大部分操作在本地完成，不需要联网。
2.3 Git的下载 官网：https://git-scm.com/
2.4Git版本控制方式 关于基本操作
将工作目录的代码先提交到暂存区，然后再由暂存区提交到本地仓库。
3. GitHub 应用方式 3.1 GitHub概述 GitHub是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名GitHub。
2018年6月4日，微软宣布，通过75亿美元的股票交易收购代码托管平台GitHub。2018年10月26日，微软以75亿美元收购GitHub交易已完成。同年10月29日微软
开发者服务副总裁奈特弗里德曼(Nat Friedman)将成为GitHub的新一任 CEO。
3.2 GitHub官网: 官网：https://github.com/
官网首页就是注册页面。
3.3GitHub的开发流程 4.总结 如今，GitHub+Git的开发模式已经被全世界所认可，已然成为了全世界应用最广泛的分布式版本控制管理工具。
扩展：其他开发模式：Gitee+Git、GitLab+Git
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04f8f736c9afcd35dbe22369a40d80a1/" rel="bookmark">
			layui表格实现图片上传功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端的代码Layui官网上也有,大家可以参考一下(主要是后端比较难实现,话不多说 小二上代码)
div &lt;div class="layui-form-item" style="padding-right: 50px;"&gt; &lt;div class="layui-form-item"&gt; &lt;label class="layui-form-label"&gt;作者头像&lt;/label&gt; &lt;div class="layui-input-block"&gt; &lt;button type="button" class="layui-btn" id="upload1"&gt;上传图片&lt;/button&gt; &lt;input type="hidden" id="img_url" name="img" value=""/&gt; &lt;div class="layui-upload-list"&gt; &lt;img class="layui-upload-img" width="200px" height="120px" id="demo1"/&gt; &lt;p id="demoText"&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; js里的 &lt;script src="../../js/jquery-3.4.1.min.js"&gt;&lt;/script&gt;//换成自己的js路径 &lt;script src="../../layui/layui.js"&gt;&lt;/script&gt;//换成自己的Layui路径 &lt;script&gt; // 文件上传 layui.use('upload', function(){ var $ = layui.jquery ,upload = layui.upload; //普通图片上传 var uploadInst = upload.render({ elem: '#upload1' ,url: '/EmployeeController/uploadFile' //改成您自己的上传接口 ,before: function(obj){ //预读本地文件示例，不支持ie8 obj.preview(function(index, file, result){ $('#demo1').attr('src', result); //图片链接（base64） }); } ,done: function(res){ //如果上传失败 if(res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04f8f736c9afcd35dbe22369a40d80a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f45ad0b9ebc42c773e1b2059d89eeba3/" rel="bookmark">
			amlogic t972红外遥控功能器及飞鼠模式（附上RK和全志飞鼠模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		驱动：
common/drivers/amlogic/input/remote
remote_core.c：遥控器核心层，向input子系统注册、上报键值。
remote_cdev.c：/dev/amremote设备节点及相关的ioctl操作
remote_decoder_xmp.c：XMP红外协议解码器
remote_meson.c：红外遥控器配置相关。
remote_raw.c：使用软件方式来获取红外扫描值。
remote_regmap.c：寄存器操作相关的代码
sysfs.c：为应用程序提供sys文件节点及操作。
驱动代码的入口在remote_meson.c：
遥控器初始化 直接看remote_probe()
static int remote_probe(struct platform_device *pdev) { struct remote_dev *dev; int ret; struct remote_chip *chip; //结构体remote_chip包含整个红外相关的信息 chip = kzalloc(sizeof(struct remote_chip), GFP_KERNEL); //结构体remote_dev代表一个红外设备 dev = remote_allocate_device(); chip-&gt;r_dev = dev; chip-&gt;dev = &amp;pdev-&gt;dev; chip-&gt;r_dev-&gt;dev = &amp;pdev-&gt;dev; chip-&gt;r_dev-&gt;platform_data = (void *)chip; chip-&gt;r_dev-&gt;getkeycode = getkeycode; chip-&gt;r_dev-&gt;ir_report_rel = ir_report_rel; chip-&gt;r_dev-&gt;set_custom_code = set_custom_code; chip-&gt;r_dev-&gt;is_valid_custom = is_valid_custom; chip-&gt;r_dev-&gt;is_next_repeat = is_next_repeat; chip-&gt;r_dev-&gt;max_learned_pulse = MAX_LEARNED_PULSE; chip-&gt;set_register_config = ir_register_default_config; platform_set_drvdata(pdev, chip); //初始化input_dev，设置为input0，可用getevent | grep event0来获取按键事件 ir_input_device_init(dev-&gt;input_device, &amp;pdev-&gt;dev, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f45ad0b9ebc42c773e1b2059d89eeba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31133e51bfd925f773f7afb842f7d043/" rel="bookmark">
			c语言求解一元二次方程的两相等实根,c语言改错题 有关求一元二次方程ax2&#43;bx&#43;c=0的两个实根...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言改错题 有关求一元二次方程ax2+bx+c=0的两个实根0
麻烦帮忙看看下面三个程序的区别~~谢谢啦
下列是用于求一元二次方程ax2+bx+c=0的两个实根的三个c程序，分别采用不同的方法或使用不同的精度。其中a=1.0，b=-(1012+1)，c=1012。
分别输入并运行这三个程序，并检验结构是否正确，分析原因。
(1)利用求根公式
程序如下：
#include #include void main( )
{float a,b,c,p,d,x1,x2;
a=1.0;
b=-(1.0e+12+1.0);
c=1.0e+12;
p=sqrt(b*b-4.0*a*c);
d=2.0*a;
x1=(-b+p)/d;
x2=(-b-p)/d;
printf(“x1=%e
x2=%e
”,x1,x2);
}
(2)利用求根公式计算一个实根，然后根据韦达定理计算另一个实根
程序如下：
#include #include void main( )
{float a,b,c,p,d,x1,x2;
a=1.0;
b=-(1.0e+12+1.0);
c=1.0e+12;
p=sqrt(b*b-4.0*a*c);
d=fabs(b)/b;
x1=(-b-d*p)/(2.0*a);
x2=c/(a*x1);
printf(“x1=%e
x2=%e
”,x1,x2);
}
(3)与(1)一样，利用求根公式，但程序中的变量均使用双精度类型。
#include #include void main( )
{double a,b,c,p,d,x1,x2;
a=1.0;b=-(1.0e+12+1.0);c=1.0e+12;
p=sqrt(b*b-4.0*a*c);
d=2.0*a;
x1=(-b+p)/d;
x2=(-b-p)/d;
printf(“x1=%e
x2=%e
”,x1,x2);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d55824528ff4bf27d94fc4e2b8c68a/" rel="bookmark">
			Vivado2018【编辑器设置黑色背景】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文链接：https://blog.csdn.net/m0_37652453/article/details/90212973
在使用vivado时编代码时，默认的白色背景主题很不利于长时间观看，可以通过settings更改代码主题风格，因为没有专用的主题包可以使用，只能参考代码界流行的主题风格逐一进行设置，例如参考notepad++中的主题，我是参考CCS中的主题进行设置。
先贴一张设置完后的效果图 【1】tool–&gt;settings–&gt;Fonts and clolrs 将字体改为微软雅黑等宽字体，大小20，将背景修改为黑色，前景修改为白色，其他按图片进行修改，颜色都是下拉菜单中的参考色。
【2】VHDL选项卡进行以下设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb3c26c51599bea38ca91f8eddccd312/" rel="bookmark">
			多线程交替打印ABC的多种实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://blog.csdn.net/xiaokang123456kao/article/details/77331878
一、题目描述 建立三个线程A、B、C，A线程打印10次字母A，B线程打印10次字母B,C线程打印10次字母C，但是要求三个线程同时运行，并且实现交替打印，即按照ABCABCABC的顺序打印。
二、Synchronized同步法 1、基本思路 使用同步块和wait、notify的方法控制三个线程的执行次序。具体方法如下：从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能进行打印操作。一个对象锁是prev，就是前一个线程所对应的对象锁，其主要作用是保证当前线程一定是在前一个线程操作完成后（即前一个线程释放了其对应的对象锁）才开始执行。还有一个锁就是自身对象锁。主要的思想就是，为了控制执行的顺序，必须要先持有prev锁（也就前一个线程要释放其自身对象锁），然后当前线程再申请自己对象锁，两者兼备时打印。之后首先调用self.notify()唤醒下一个等待线程（注意notify不会立即释放对象锁，只有等到同步块代码执行完毕后才会释放），再调用prev.wait()立即释放prev对象锁，当前线程进入休眠，等待其他线程的notify操作再次唤醒。
2、代码 经博友：璐璐的宝宝的指点，原程序虽然也能完成任务，但是存在一个很大的缺陷。为了对比一下，这里保留原实现，并给出新的改进实现。
原实现：
public class ABC_Synch { public static class ThreadPrinter implements Runnable { private String name; private Object prev; private Object self; private ThreadPrinter(String name, Object prev, Object self) { this.name = name; this.prev = prev; this.self = self; } @Override public void run() { int count = 10; while (count &gt; 0) {// 多线程并发，不能用if，必须使用whil循环 synchronized (prev) { // 先获取 prev 锁 synchronized (self) {// 再获取 self 锁 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb3c26c51599bea38ca91f8eddccd312/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42aa05edbd6f15d1d572a196e0410308/" rel="bookmark">
			cmd窗口输入python，提示the environment has not been activated
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cmd窗口输入python，提示the environment has not been activated 原因是Python环境没有激活，在cmd窗口输入activate进行激活就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a68c540c7d76ca6f7a2e689fd16ddf8e/" rel="bookmark">
			tomcat java nio是如何关联同一客户socket的多次请求消息的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用命令行telnet和Mac上的一个tcp通信软件socket debugger，对tomcat8.5的nio模式做了源代码调试，解开了之前自己关于nio模式的一个疑惑：nio模式下tcp通信是非阻塞的，即客户端有信息发往tomcat，对该信息处理完毕后，tomcat便回收工作线程；待tomcat接收到客户端新的消息时，会再次分配工作线程处理客户端消息——那么同一个客户端先后发送的消息是怎么关联到一起的？
比如客户端发送了一个http post请求如下
POST /greet HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Content-Length: 31
Content-Type: application/x-www-form-urlencoded
Accept: */*
Accept-Encoding: gzip, deflate, br
country=china&amp;province=zhejiang
request body分了两次发送，第一次发送country=chin，第二次发送a&amp;province=zhejiang，tomcat如何将这两次请求关联起来？
看了源码发现，tomcat维护了一个全局的 ConcurrentHashMap，key为socket，value则是该socket对应的已解析的http内容和http解析阶段。当前信息处理完，便将当前处理的socket作为key，已解析的结果作为value保存到该全局ConcurrentHashMap中 // Associate the processor with the connection connections.put(socket, processor); ，待到下次收到消息，便先去全局Map中查找是否有保存的信息
Processor processor = connections.get(socket); 如果有，则根据之前保存的解析阶段继续解析。
对应的类是org.apache.coyote.AbstractProtocol.ConnectionHandler，全局Map是
private final Map&lt;S,Processor&gt; connections = new ConcurrentHashMap&lt;&gt;(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98ae6f6391591a86ed7d86fee292402b/" rel="bookmark">
			java并发编程之上下文切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上下文切换 CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。
并发执行不一定比串行执行快，因为线程有创建和上下文切换的开销。
减少上下文切换的方法有：
无锁并发编程：多线程竞争锁时，会引起上下文切换，可以用一 些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据
CAS算法(compare-and-swap)：Java的Atomic包使用CAS算法来更新数据，而不需要加锁
public class AtomicCounter { private final AtomicInteger counter = new AtomicInteger(0); public int getValue() { return counter.get(); } public void increment() { while(true) { int existingValue = getValue(); int newValue = existingValue + 1; if(counter.compareAndSet(existingValue, newValue)) { return; } } } } 复制代码 使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态
协程(Quasar)：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换
死锁 锁是个非常有用的工具，运用场景非常多，因为它使用起来非常简单，而且易于理解。但同时它也会带来一些困扰，那就是可能会引起死锁，一旦产生死锁，就会造成系统功能不可用。
避免死锁的几种常见方法：
避免一个线程同时获取多个锁避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况 资源限制 资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。 例如服务器的带宽只有2Mb/s，某个资源的下载速度是1Mb/s每秒，系统启动10个线程下载资源，下载速度不会变成10Mb/s，所以在进行并发编程时，要考虑这些资源的限制。
常见资源限制有：
带宽的上传/下载速度硬盘读写速度CPU的处理速度数据库的连接数socket连接数等 在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源仍然在串行执行，这时候程序不仅不会加快执行反而会更慢，因为增加了上下文切换和资源调度的时间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb079b3c1fe07c26fbc70b4421d68eb2/" rel="bookmark">
			java内存收集器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		垃圾收集器 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应 用特点和要求组合出各个年代所使用的收集器。
下图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。
Serial收集器 Serial收集器是一个单线程的收集器，但它的单线程的意义并不仅仅说明它只会使用一个CPU或一个收集线程去完成垃圾收集工作， 更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。
Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。
ParNew收集器 ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也 要暂停所有其他的工作线程。ParNew 垃圾收集器是很多 java 虚拟机运行在 Server 模式下新生代的默认垃圾收集器。
ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。
Parallel Scavenge收集器 Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量(Thoughput)， 高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。
垃圾收集停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
Serial Old收集器 Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整 理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。
Parallel Old收集器 Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。
在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge 和年老代 Parallel Old 收集器的搭配策略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb079b3c1fe07c26fbc70b4421d68eb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83750727ef279ed94d8b4ee8c06d1a58/" rel="bookmark">
			Kubernetes入门与实践--Kubernetes是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		它是一个全新的基于容器技术的分布式架构领先方案。这个方案虽然还很新，但它是谷歌十几年以来大规模应用容器技术的经验积累和升华的重要成果。确切地说，Kubernetes是谷歌严格保密十几年的秘密武器——Borg的一个开源版本。Borg是谷歌的一个久负盛名的内部使用的大规模集群管理系统，它基于容器技术，目的是实现资源管理的自动化，以及跨多个数据中心的资源利用率的最大化。十几年以来，谷歌一直通过Borg系统管理着数量庞大的应用程序集群。由于谷歌员工都签署了保密协议，即便离职也不能泄露Borg的内部设计，所以外界一直无法了解关于它的更多信息。直到2015年4月，传闻许久的Borg论文伴随Kubernetes的高调宣传被谷歌首次公开，大家才得以了解它的更多内幕。正是由于站在Borg这个前辈的肩膀上，汲取了Borg过去十年间的经验与教训，所以Kubernetes一经开源就一鸣惊人，并迅速称霸容器领域。 其次，如果我们的系统设计遵循了Kubernetes的设计思想，那么传统系统架构中那些和业务没有多大关系的底层代码或功能模块，都可以立刻从我们的视线中消失，我们不必再费心于负载均衡器的选型和部署实施问题，不必再考虑引入或自己开发一个复杂的服务治理框架，不必再头疼于服务监控和故障处理模块的开发。总之，使用Kubernetes提供的解决方案，我们不仅节省了不少于30%的开发成本，还可以将精力更加集中于业务本身，而且由于Kubernetes提供了强大的自动化机制，所以系统后期的运维难度和运维成本大幅度降低。 然后，Kubernetes是一个开放的开发平台。与J2EE不同，它不局限于任何一种语言，没有限定任何编程接口，所以不论是用Java、Go、C++还是用Python编写的服务，都可以被映射为Kubernetes的Service（服务），并通过标准的TCP通信协议进行交互。此外，Kubernetes平台对现有的编程语言、编程框架、中间件没有任何侵入性，因此现有的系统也很容易改造升级并迁移到Kubernetes平台上。 最后，Kubernetes是一个完备的分布式系统支撑平台。Kubernetes具有完备的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建的智能负载均衡器、强大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制，以及多粒度的资源配额管理能力。同时，Kubernetes提供了完善的管理工具，这些工具涵盖了包括开发、部署测试、运维监控在内的各个环节。因此，Kubernetes是一个全新的基于容器技术的分布式架构解决方案，并且是一个一站式的完备的分布式系统开发和支撑平台。 在Kubernetes中，Service是分布式集群架构的核心，一个Service对象拥有如下关键特征。◎ 拥有唯一指定的名称（比如mysql-server）。◎ 拥有一个虚拟IP（Cluster IP、Service IP或VIP）和端口号。◎ 能够提供某种远程服务能力。◎ 被映射到提供这种服务能力的一组容器应用上。 Service的服务进程目前都基于Socket通信方式对外提供服务，比如Redis、Memcache、MySQL、Web Server，或者是实现了某个具体业务的特定TCPServer进程。虽然一个Service通常由多个相关的服务进程提供服务，每个服务进程都有一个独立的Endpoint（IP+Port）访问点，但Kubernetes能够让我们通过Service（虚拟Cluster IP +Service Port）连接到指定的Service。有了Kubernetes内建的透明负载均衡和故障恢复机制，不管后端有多少服务进程，也不管某个服务进程是否由于发生故障而被重新部署到其他机器，都不会影响对服务的正常调用。更重要的是，这个Service本身一旦创建就不再变化，这意味着我们再也不用为Kubernetes集群中服务的IP地址变来变去的问题而头疼了。 容器提供了强大的隔离功能，所以有必要把为Service提供服务的这组进程放入容器中进行隔离。为此，Kubernetes设计了Pod对象，将每个服务进程都包装到相应的Pod中，使其成为在Pod中运行的一个容器（Container）。为了建立Service和Pod间的关联关系，Kubernetes首先给每个Pod都贴上一个标签（Label），给运行MySQL的Pod贴上name=mysql标签，给运行PHP的Pod贴上name=php标签，然后给相应的Service定义标签选择器（Label Selector），比如MySQL Service的标签选择器的选择条件为name=mysql，意为该Service要作用于所有包含name=mysql Label的Pod。这样一来，就巧妙解决了Service与Pod的关联问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f5b9f49bef8c597f2b9ec404ca28454/" rel="bookmark">
			c语言差分求导,有限差分法求导体槽的静电场.doc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有限差分法中的迭代法求解接地金属槽内电位分布
一、实验原理
有限差分法是基于差分原理的一种数值计算法。其基本思想想是将场域离散成很多许多小的网格，应用差分原理，将求解连续函数的柏松方程问题转换为求解网格节点上的差分方程组问题。
1．1 二维柏松方程的差分格式
图1 有限差分法的网格划分
导体槽中静电场的边值问题的拉普拉斯方程为：
为简单起见，将场域分成足够小的正方形网格，网格线之间的距离为h，。节点0、1、2、3、4上的电位分别用、、、和表示。点1、点3在x0处可微，沿x方向在x0处的泰勒级数展开式为
点2、点4在y0处可微，沿y方向在y0处的泰勒级数展开式为
忽略高次项
稍作变化得到拉普拉斯方程的五点差分格式：
可通过迭代法求解以上差分方程。
1.2 高斯—赛德尔迭代法
进行迭代时可写为
,为行数，,为列数，为迭代次数，为前次迭代的结果，为当次迭代的结果，由于迭代从第一行、第一列开始，()、()点的迭代较()点进行得早，顾可使用当次迭代的结果。直到所有的点电位满足(为所设定精度)时迭代停止。
以上迭代收敛较慢，迭代次数多，因此还可以使用超松弛迭代法。
1.3 超松弛迭代法
式中(1&lt;&lt;2)为加速收敛的因子，影响着迭代的收敛，
最佳收敛因子的经验公式
其中为每边的节点数减去1。
二、程序框图：
三、实验内容：
3.1内容及要求：
用高斯—赛德尔迭代法求解接地金属槽内点位分布，精度，行数M、列数N自己定义。
3.2 实验思路：
由超松弛迭代法，将网格分成M*N列，边界点正好都是网格的节点，对所有的节点进行编号，并记录节点的坐标位置，并用一个二维数组进行表示u1[M][N],此数组表示的是迭代后的值。考虑到迭代前后的数值不一样，再用一个二维数组表示迭代之前的数值u2[M][N]。
运用C++或MATLAB的知识在计算机上将边界值和内节点进行赋值，即将节点离散化。然后开始迭代。迭代开始之前将另一个数组b赋值，用数组a给其赋值，表示迭代之前的值，好用于后面精度的比较。开始进行迭代时，根据超松弛公式将迭代方程编写输入。每次迭代结束后将数组a和数组b对应的值进行比较，即是精度的计算。如果误差大于所规定的误差0.00001，将a的值赋给b，然后继续进行迭代。直到当迭代前后数值误差小于所规定的误差时停止迭代。并比较迭代因子的大小对收敛次数的影响，选取最烧收敛次数的迭代因子作为实验最后的输出结果。
最后输出最适合迭代因子、迭代的次数和迭代后各点的电位值。
3.3 编写程序
用C语言或MATLAB语言编写差分法程序，打印出迭代次数和每一点的电位值。
展开阅读全文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d206379dbfb1fe880f0c24851ced4b06/" rel="bookmark">
			c语言函数定义的语法格式,C语言函数
-C语言函数定义的语法格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言程序是由多个零件组合而成的，而函数就是最主要的组合零件。C语言程序的主体部分就是一个 main( ) 函数，它在 C语言程序中是必不可少的，每一个 C 程序都首先从 main( ) 函数开始执行。
C语言函数是什么
在前面的学习中，我们知道在 main( ) 函数中可以通过 printf( ) 函数实现屏幕输出显示的功能，通过 scanf( ) 函数实现读取键盘输入信息的功能。另外，我们还可以使用 abs(x)、sqrt(x) 等函数实现各种数学运算功能。
这些都是由 C语言提供的库函数，我们在编程过程中直接拿来使用就可以了，不过在使用之前需要在程序开头部分，用#include引入包含这些库函数的头文件。
此外，我们可以根据需要自己创建各种函数，称为自定义函数。
而 C语言程序基本上就是用这些函数像搭积木一样搭建起来的(见图 1)。
图 1：像搭积木一样创建 C语言程序
总结：函数可以理解为能够执行特定功能的“魔法盒”，将多个处理步骤集中在一起并且可能重复使用时可以使用函数。
C语言函数定义
函数的定义由多个部分构成(见图 2)。其一般格式如下：
返回类型 函数名 (形参声明) //函数头
{
函数体; //一条或多条 C 语句
}
下面的代码定义了一个函数 Max2，其功能是接收两个整数，返回较大的值：
int Max2 ( int a, int b )
{
if(a&gt;b)
return a;
else
return b;
}
函数头部分包含函数的返回类型、函数名以及一个或多个形式参数(简称形参)。它指出了该函数的使用方法(函数调用的形式)。
一般函数都会返回一个值(return 后面跟随的值)，这个返回值的数据类型，就是函数的返回类型。也有一些函数没有返回值，只是执行一些具体的操作(比如打印输出等)，这些没有返回值的函数在定义时其返回类型为 void 型(见图 2)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d206379dbfb1fe880f0c24851ced4b06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24c465ccab76a01cfcd0331c92cabaa4/" rel="bookmark">
			UOS&#43;anacond&#43;opencv环境搭建过程小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去年的某个时候，在学习贾志刚老师OpenCv教程的过程中，我开始对Linux系统中运行Python+OpenCv来了兴趣，正好又在熟悉统信UOS中，于是乎就设想着用UOS系统运行一下Python+OpenCv吧。那就说干就干，走起！
然而，过程是非常艰难的，我不是计算机科班出生，所有的知识都是通过网络学来的，经验和结果都是不断试错出得来的，所以，您要是大佬的话，下面所有的内容您就别看了，怕您笑话啦。这两天终于把这个系统搭建成功了，于是赶紧记录下来，给自己做个备忘，也供有同样想法的朋友做个参考吧。见笑啦！
我用的系统是统信UOS个人桌面版V20，有空闲的电脑，就没有用虚拟机（用虚拟机也是同样的情况）。系统安装好、激活，系统更新（其实更不更新都行，只是安装好了之后，更新的时间要比下载opencv等部件的时间要少得多，所以就更新了），打开开发者模式。如果没有打开开发者模式的话，连anacond都正常安装不了的。当然了，我还尝试着用过银河麒麟、深度社区版、ubuntu18,其实遇到的问题都差不多，最后还是踏踏实实在UOS 上摸索试错吧。好在经过数月的跌跌撞撞，最终还是搭建成了，可以正常运行了。好开心，哈哈...
一、下载文件
https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ 清华大学开源软件镜像站
通过上面这个网站下载anacond安装文件： Anaconda3-2018.12-Linux-x86_64.sh 。在搭建的过程中，我还下载过Anaconda3-2020.10-Linux-x86_64.sh 和 Anaconda3-2021.04-Linux-x86_64.sh ，这两个最终都没有成功，原因是Python的版本是3.8,好像没有能正常匹配python版的opencv。而Anaconda3-2018.12-Linux-x86_64.sh 的Python版本是3.7，有适配的Python版的opencv，请您不要再走我的弯路 。在这个过程中我学习的网址是（https://blog.csdn.net/cckavin/article/details/86663352 Anaconda: Linux下安装Anaconda ）。
二、安装anacond
下载完成后，在 Downloads（下载）文件夹下（下载后的Anaconda3-2018.12-Linux-x86_64.sh文件在的文件夹），空白处右键选择“在终端中打开”，然后输入：
bash Anaconda3-2018.12-Linux-x86_64.sh 然后一路回车，一路“yes”。最后输入以下两行命令：
source ~/.bashrc
conda --version
屏幕上显示：
(base) EmptyBowl@EB-PC:~$ conda --version
conda 4.5.10 （好像是这个版本号，sorry，很不严谨，不过只要出现版本号就表示anacond安装成功啦！哈哈）
这个时候，在系统的文件管理的主目录里面，会有一个 anaconda3 文件夹，占空间6G以上，这个就是安装好的anacond所在文件夹。
三、安装anacond自认的opencv插件
在上一步的终端窗口中，接着输入命令：
anaconda-navigator
这里要注意，有时候打开终端后输入这个命令，anacond界面未响应，并有一些提示（抱歉，我英语很菜的，不认识），主要是命令行最前面没有（base），如 EmptyBowl@EB-PC:~$ 。这个时候就需要连输入以下两行命令：
source ~/anaconda3/bin/activate root
anaconda-navigator
这时候，命令行一定是带(base) 的，如 (base) EmptyBowl@EB-PC:~$ 。并且，andcond 也开始启动啦。在刚才这个过程中我学习的网址是（https://blog.csdn.net/miner_zhu/article/details/81702992 Linux中 anaconda 启动其终端命令行）。
1.在启动后的anacond界面的最左边点击 Environments ， installed 下拉框中选择 all ，最右侧框中输入 opencv ，下方界面出现liboopencv、opencv、py-opencv三个待选项（版本好像都是3.4.2）（一定会出现的，如果空白，说明网速不行，要多试几次），都选上，右下角有绿色的 Apply ，点击。等待一段时间后，屏幕中间的小窗口右下角出现绿色 Apply 后，点击。这一步需要等待了，要看网速了，不一定什么时候网速快，傍晚、凌晨、半夜、上班时间.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24c465ccab76a01cfcd0331c92cabaa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82232182a27fa7593d56e99b15b2190f/" rel="bookmark">
			伺服电机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交流伺服电机和步进电机的原理区别 步进电机原理： 步进电机是一种将电脉冲转换成角位移的执行机构，当步进驱动器接收到一个脉冲信号，它就驱动步进电机按设定的方向转动一个固定的角度（步距角），它的旋转是以固定的角度一步一步运行的，可以通过控制脉冲个数来控制角位移量，从而达到准确定位的目的；同时可以通过控制脉冲频率来控制电机转动的速度，从而达到调速的目的；
伺服电机原理： 伺服电机内部的转子是永磁铁，驱动器控制的UVW三相电形成了电磁场，转子在此磁场的作用下转动，同时电机自带的编码器反馈信号给驱动器，驱动器根据反馈值与目标值进行比较，调整转子转动的角度，伺服电机的精度决定于编码器的精度；
交流伺服电机和步进电机的区别 1.控制的方式不同 步进电机是通过控制脉冲的个数来控制转动角度的，一个脉冲对应一个步距角； 伺服电机是通过控制脉冲时间的长短来控制转动角度的；
2.低频特性不同 步进电机在低速时容易出现低频震动的现象，震动频率与负载情况和驱动器的性能有关； 交流伺服电机运行非常平稳，即使在低速时也不会出现震动现象，交流伺服系统具有共振抑制功能，可涵盖机械的刚性不足，并且系统内部具有频率解析机能，可检测出机械的共振点，便于系统调整
3.矩频特性不同 步进电机的输出力矩随转速的升高而下降，且在较高转速时急剧下降，所以其最高工作转速一般在300到600转每分钟； 交流伺服电机为恒力矩输出，即在其额定转速，一般2000到3000转每分钟以内，都能输出额定转矩，在额定转速以上为恒功率输出
4.过载能力不同 步进电机一般不具有过载能力，交流伺服电机具有较强的过载能力； 以松下交流伺服系统为例，它具有速度过载和转矩过载能力，其最大的转矩为额定转矩的3倍，可用于克服惯性过载在启动瞬间的惯性力矩； 步进电机因为没有这种过载能力，在选型时为了克服这种惯性力矩，往往需要选取较大转矩的电机，而机器在正常工作期间又不需要那么大的转矩，便出现了力矩浪费的现象；
5.速度响应性能不同 步进电机从静止加速到工作转速需要200到400毫秒 交流伺服系统的加速性能较好，以松下MSMA400W交流伺服电机为例，从静止加速到其额定转速3000转每分钟，仅仅需要几毫秒，可以用于要求快速启动的控制场合
6.力矩不同 步进电机的锁定力矩较大，而伺服则是在受外力影响下位置丢失以后再找回位置，这个过程容易造成误差；
7.调试复杂性不同 伺服驱动器涉及的参数多，使用手册长，且不同品牌的驱动器区别比较大；而步进电机只需要调整驱动器上的电流设定和细分设定，不会因为品牌不同而不同
8.成本不同 伺服系统相应能力快，高速性能好的有点突出，通过分析其控制方法得知其主要是采用矢量控制技术和闭环控制来获得高性能的，因此它的成本也就相对步进电机非常高； 然而通过细分驱动，添加闭环控制等技术手段步进电机同样可以达到很高的控制精度，两者的发展并不对；
9.反馈形式不同 伺服电机具有编码器，所以可以很容易组成闭环控制系统 步进电机只是执行机构，没有位置反馈，上位机发出命令后，步进电机有没有执行，上位机并不知道；
交流伺服电机的结构 伺服电机内部的转子是永磁铁，驱动器控制的UVW三相电形成了电磁场，转子在此磁场的作用下转动，同时电机自带的编码器反馈信号给驱动器，驱动器根据反馈值与目标值进行比较，调整转子转动的角度
伺服电机相较于步进电机主要应用于高精度位置控制，如工业机器人手臂，加工中心等； 我们在选型的时候需要结合成本，控制精度，速度要求，响应时间等问题来选择合适的方式； 如果成本不是问题，那么我们可以直接使用伺服电机，因为伺服电机相较于步进电机有绝对的优势；
以上摘自我的课程EPLAN自动化电路入门教程的PPT，我也从这个视频教程中剥离出了另一个视频教程电气元件的基本原理，主要讲解电气元件的原理，不涉及EPLAN的知识
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96a1f01dccc4c0ea31abfedeb029adc/" rel="bookmark">
			变频调速系统c语言编程,基于8098单片机的SPWM变频调速系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字控制的交流调速系统所选用的微处理器、功率器件及产生PWM波的方法是影响交流调速系统性能好坏的直接因素。在介绍了正弦脉宽调制(SPWM)技术的基础上，设计了一种以8098单片机作为控制器，以智能功率模块IPM为开关器件的变频调速系统。通过软件编程，产生正弦脉冲宽度调制波形来控制绝缘栅双极晶体管的导通和关断，从而达到控制异步电动机转速的目的。实验结果表明，该系统可调频率调电压，稳定度高，调速范围宽，具有较强的实用价值
Abstract:
AC variable speed with digital control systems used microprocessors， power devices and generate PWM wave is the direct factors of affecting the performance AC speed regulation system. On the basis of introducing the sinusoidal pulse width modulation (SPWM) technology，this paper designed variable speed system which used 8098 as a controller， intelligent power module IPM as switching device. Through software programming， resulting in sinusoidal pulse width modulation waveform to control the insulated gate bipolar transistor turn on and off， so as to achieve the purpose of speed control of induction motors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a96a1f01dccc4c0ea31abfedeb029adc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65fb40a3c3b1be7dab78c8ace462689/" rel="bookmark">
			c语言打地鼠项目报告,打地鼠实训报告.docx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打地鼠实训报告
实训题“打地鼠”游戏程序设计实训内容打地鼠的界面设计(含截图、代码)package com.iotek.mouse;import java.awt.Color;import java.awt.Font;import java.awt.Point;import java.awt.Toolkit;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import javax.swing.ImageIcon;import javax.swing.JFrame;import javax.swing.JLabel; public class PlayMouse extends JFrame implements Runnable{private int num = 0;private JLabel back;private JLabel [] mouses;private ImageIcon imgMouse;private JLabel jtf;public PlayMouse(){this.setResizable(false);//不能修改大小。this.getContentPane().setLayout(null);this.setTitle("打地鼠游戏");this.setBounds(400,200,1000, 600);back= new JLabel();ImageIcon icon = new ImageIcon(this.getClass().getResource("1.jpg"));back.setIcon(icon);back.setBounds(0, -10,1000,600);this.setCursor(Toolkit.getDefaultToolkit().createCustomCursor(Toolkit.getDefaultToolkit().getImage("src/com/iotek/mouse/4.png"),new Point(),"self"));imgMouse = new ImageIcon(this.getClass().getResource("3.jpg"));mouses = new JLabel[6];for(int i=0;i&lt;6;i++){mouses[i] = new JLabel();mouses[i].setSize(imgMouse.getIconWidth(), imgMouse.getIconHeight());//mouses[i].setIcon(imgMouse);mouses[i].addMouseListener(new MouseListener() {@Overridepublic void mouseReleased(MouseEvent e) {// TODO 自动生成的方法存根}@Overridepublic void mousePressed(MouseEvent e) {// TODO 自动生成的方法存根}@Overridepublic void mouseExited(MouseEvent e) {// TODO 自动生成的方法存根}@Overridepublic void mouseEntered(MouseEvent e) {// TODO 自动生成的方法存根}@Overridepublic void mouseClicked(MouseEvent e) {//加分功能Object object = e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a65fb40a3c3b1be7dab78c8ace462689/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dbfd4db46357e98777a26be3384de2b/" rel="bookmark">
			深入了解requestFullscreen()方法实现全屏显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、全屏模式：requestFullscreen()方法用于发出异步请求实现元素全屏显示 const openFullscreen = () =&gt; { /* 获取(&lt;html&gt;)元素以全屏显示页面 */ const full = document.getElementById('content') if (full.RequestFullScreen) { full.RequestFullScreen() //兼容Firefox } else if (full.mozRequestFullScreen) { full.mozRequestFullScreen() //兼容Chrome, Safari and Opera等 } else if (full.webkitRequestFullScreen) { full.webkitRequestFullScreen() //兼容IE/Edge } else if (full.msRequestFullscreen) { full.msRequestFullscreen() } } 2、取消全屏模式：exitFullscreen()方法退出全屏模式 const exitFullscreen = () =&gt; { function exitFullscreen() { if(document.exitFullScreen) { document.exitFullScreen(); //兼容Firefox } else if(document.mozCancelFullScreen) { document.mozCancelFullScreen(); //兼容Chrome, Safari and Opera等 } else if(document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dbfd4db46357e98777a26be3384de2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f0a461737327382a63c00ab848682db/" rel="bookmark">
			c语言计算十进制转八进制,C语言 十进制数转换八进制 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：直接使用控制字符串 %o 八进制%x
方法二：
求余来算，比如求十进制数 x(x&gt;100) 的8进制，先通过 x%8 可以得到个位(末位)上的数，当十进制数等于8时，必然会进位，求余的结果正好是不能进位的部分，x=x/8(这就像位移，x的8进制数向右移了一位)，这样已经求出来的 个位 位移后没有了，原来的十位变成了个位，继续把得到的x按上面的方式求末位，就能求出来十位，按照这种方式得到的 8进制数 是反的(先得到个位，再十位。。。)，这样很适合放到栈中，取得时候又会反过来，伪代码可以这样写：
while(x){
printf("%d",x%n);//会打印出x转换为 N进制数 从低位到高位上的每一位数
x/=n;
}
十进制转换N进制：
#include
#include
#include
typedef int INT;
typedef struct dd
{
INT data;
struct dd *next;
}LNode,*LStack;
LStack pushstack(LStack top,int x)
{
LStack p;
p=(LStack)malloc(sizeof(LNode));
if((x)!=-1) {p-&gt;data=(x); p-&gt;next=top; top=p;}
return top;
}
LStack outstack(LStack top,int *x)
{
LStack p=top;
*x=p-&gt;data;
top=p-&gt;next;
free(p);
return top;
}
main()
{
int x,n;
LStack top=NULL;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f0a461737327382a63c00ab848682db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44732b0f07c54f4b03d4a2ab401f6700/" rel="bookmark">
			Vue-element-admin上手之登录篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端新手学了下vue，用vue-element-admin熟悉了一下vue的用法，发现很多地方都十分的绕，特此写这篇文章记录一下登录功能的工作流程。
1.@views/login
在vue项目中，基本代码都在src目录下，这不用多说。而页面代码都写在src/views下，每一个子视图相当于是个页面，通用的组件则是在src/components下，并不是我最开始以为所有的页面都分成组件然后都写在components下，实际上这种也合理一点，只有通用的才在src/components下。
login子视图中主要看index.vue文件。
主要注意handleLogin(): this.$refs.loginForm.validate 验证表单中属性格式是否正确，valid为回调函数的返回值
this.$store.dispatch('user/login', this.loginForm)调用store/modules/user.js的login ，而actions中又调用了api/user.js的login方法，而此方法访问的url是mock/user.js中的模拟服务器接口，获取的返回值自然是mock返回的
2.权限路由
在此项目router/index.js中 constantRoutes为通用路由，即不需要权限也能访问的路由，asyncRoutes为设置的权限路由，注意asyncRoutes不能为空，为空的话会卡在登录界面进不去
在与main.js同目录的permission.js中声明了路由的前置守卫beforeEach，前置守卫判断是否有token，若已经登录过了则有token，相当于登录过后获取了token会执行这一步，如果还没有获取到用户的权限角色这一步会调用store/modules/user.js的getInfo获取roles，然后调用store/modules/permission.js 的 generateRoutes ，根据用户roles进行权限路由筛选，再添加到路由中，进入主页面。
通过整个登录流程来理解还是能理解，就是太多文件目录有点绕，建议找不到对应处的时候在项目中搜索关键字
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4566f854fc502a70ffa59934d16b2179/" rel="bookmark">
			抽奖算法 中奖算法 权重随机算法实现 中奖概率实现方式  无需配置中奖概率 自我实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		封装好的工具类 /** * 随机工具 * * @author cc * @date 2021/5/18 */ public class RandomUtil { private static final int MAX_WEIGHT = 1; /** * 权重随机算法 * 比如传入weightArray={1D,2D,3D,4D} 那么100W次结果返回下标0,1,2,3的概率应为10%,20%,30%,40% * 比如传入weightArray={1D,2D} 那么100W次结果返回下标0,1的概率应为33.33%,66.67% * @param weightArray 权重源数组，不能为空 * @return 权重数组下标 */ public static int weightWinning(double[] weightArray) { if (weightArray.length == 0) { return -1; } // hutool double randomDouble = cn.hutool.core.util.RandomUtil.randomDouble(MAX_WEIGHT); // or java random // double randomDouble = new Random().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4566f854fc502a70ffa59934d16b2179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b26f1ea120b85b24cbafed45f7d3ddc/" rel="bookmark">
			python 以html的形式显示测试结果图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# coding:utf-8 import webbrowser import sys import os # 准备相关变量 txt_file = "./results" txt_file_list = os.listdir(txt_file) data = [i for i in txt_file_list] res_list = [] for j, i in enumerate(data): new_name = os.path.join("./results", i) if j % 3 == 0: res_list.append("&lt;img src=" + new_name + "&gt;&lt;br&gt;") else: res_list.append("&lt;img src=" + new_name + "&gt;") img_str = "" for i in res_list: img_str += i # 命名生成的html GEN_HTML = "test_result.html" # 打开文件，准备写入 f = open(GEN_HTML, 'w') message = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b26f1ea120b85b24cbafed45f7d3ddc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b064cc1c022b39f53c99cf71c9c57c/" rel="bookmark">
			Linux权限drwxrwxrwx相关详细说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux权限drwxrwxrwx所代表的意义 [root@app-LT-147 localPartExp]# ll
drwxrwxrwx 2 root root 4096 11月816:38 excel
drwxr-xr-- 2 777 root 4096 11月816:47 zip
共显示了七列信息，从左至右依次为：权限、文件数、归属用户、归属群组、文件大小、创建日期、文件名称
d ：第一位表示文件类型
d 文件夹
- 普通文件
l 链接
b 块设备文件
p 管道文件
c 字符设备文件
s 套接口文件
rwx ：第2-4位表示这个文件的属主拥有的权限。r是读、w是写、x是执行
r-x ：第5-7位表示和这个文件属主所在同一个组的用户所具有的权限
r-x ：第8-10位表示其他用户所具有的权限
常用的linux文件权限：
444 r–r--r–
600 drw-------
644 drw-r–r--
666 drw-rw-rw-
700 drwx------
744 drwxr–r--
755 drwxr-xr-x
777 drwxrwxrwx
1、从左至右，1-3位数字代表文件所有者的权限，4-6位数字代表同组用户的权限，7-9数字代表其他用户的权限。
一共有10位数，其中：最前面那个 - 代表的是类型
中间那三个 rw- 代表的是所有者（user）
然后那三个 rw- 代表的是组群（group）
最后那三个 r-- 代表的是其他人（other）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78b064cc1c022b39f53c99cf71c9c57c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06b7b8d2a3bd0e88763b0bd0e5c073ff/" rel="bookmark">
			matlab存储的矩阵，python用f5py读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab存储的矩阵可以用scipy函数读取，但是对于matlab存储大数据，可以使用matlab -v7.3进行压缩，不过scipy不支持，但可以用f5py读取，但是在压缩过程中，数据维度会发生变化，如CxHxW会变为WxHxC,需要将维度变化回来。
matlab 存储命令
save(‘path’,‘name’,‘v7.3’);
python读取
import f5py
import numpy as np
f = h5py.File(data_path,‘r’)
data = f[‘name’]
data = np.transpose(data,[2,1,0])
这样维度就转换过来了。
正常用scipy存储的矩阵是3个多G，但是用matlab存储的矩阵只有400多M，节省了很多存储空间哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/739645ef8478062482c165d8e0baf7a9/" rel="bookmark">
			c语言int注释,C语言/C&#43;&#43;中*和&amp;的用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：C语言/C++中*和&amp;的用法详解
C++中&amp;和*的用法一直是非常让人头疼的难点，网上讲这些知识点多数都是分开讲其用法的，没有详细的总结，导致我在这方面的知识结构格外混乱，在网上找到了一篇英文文章简单总结了这两个符号的一些用法，不过都是一些比较基础的知识。
C/C++中*和&amp;的用法
C++语言是C语言的超集。几乎所有可以运行的C程序都是可以运行的C++程序。因此，写一个不包含C++特性的C++程序是可能的，尽管cout和引用的使用(见下文)更好的构成了一个C++程序。C++和C在代码格式上偶尔会有不同，比如，在C语言中，我们这样把p声明为一个int类型的指针 int p，而在C++中我们使用int p(编译器并不在意你使用的是哪种格式)。
在C/C++中，*和&amp;有很多用法，具体的使用要根据代码内容来确定。
C中*的用法
(a) 乘法运算：x=y*z;
(b) 乘法赋值运算：x*=y;相当于x=x*y
(c) 注释：/这里是你的注释/
(d) 指针的声明：int p 或 int p; 读法：p是指向一个整数类型的指针。
(e) 复合指针：int p; 或 int p; 读法 p是一个指向一个指向整数类型的指针的指针。(同样道理， int***p等等)
(f) 解引用：x=*p 把指针p指向的值赋值给x
&amp;在C语言中的用法
(a) 逻辑与：if((a&gt;1)&amp;&amp;(b&lt;0))
(b) 位运算与：x=a&amp;b;
(c) 逻辑与赋值：x&amp;=y;与 x=x&amp;y含义相同
(d) 求地址运算符：p=&amp;x;读法：把x的地址赋给p(指针)
C++中&amp;的补充用法
C++中有一种C不存在的变量类型引用变量(简单说来为引用)，尽管在C语言中用指针也可以实现类似的功能。
引用，指针，地址是联系密切的概念。地址是在电脑内存中的地址(一般是一些变量的值在内存中的储存位置)，指针是存地址的变量，所以指针可以“指向”内存地址。概念上讲，引用变量本质上是指针的另一个名字(但是并不能被编译器实例化)
在函数内像其他变量一样定义一个引用是可能的，举例
void main(void)
{
int i;
int&amp; r = i;
…
}
但是这是没有意义的，因为引用的使用和对引用的变量的使用是一样的。
引用在函数的参数中被使用。
void main(void)
{
int i=3;
f(i);
cout &lt;&lt; i;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/739645ef8478062482c165d8e0baf7a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d49356f5c0034c708978ccae9b2877c6/" rel="bookmark">
			将以下c语言改用ARM编程实现,ARM汇编程序---C语言调用ARM汇编实现字符串的拷贝...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的实现将一个字符串复制到另外一个字符数组中。拷贝功能在ARM中实现。C语言调用汇编实现。
C语言代码：主要注意要将汇编中的函数导入进来。其余很简单！我这样赋值方便以后调试的时侯方便。
#include extern void strcopy(char *d, const char *s);
int main()
{
const char *srcstr="abcdefghi";
char dststr[]="ighfedcba";
strcopy(dststr,srcstr);
return 0;
}
ARM汇编代码：在此汇编代码中，主要是注意将拷贝函数导出，将C语言main函数导入，注意在调试的时候你会发现，R0,R1寄存器存储的是两个传入参数的存储地址，所以后期通过LDR和STR即可实现，主要是要不断的调试你就会熟悉这个参数是怎么传入的，还有就是注意通过寻址观察目标字符数组的变化，是否复制成功。
STACK_TOP EQU 0x40002000
PRESERVE8
AREA SCopy, CODE, READONLY
EXPORT START
EXPORT strcopy
import main
ENTRY
START
LDR R13,=STACK_TOP
B main
strcopy
LDRB r2, [r1],#1
STRB r2, [r0],#1
CMP r2, #0
BNE strcopy
MOV pc,lr
END
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8774d115a696dd5beca2a0821dc8c5/" rel="bookmark">
			第十八讲 jQuery操作DOM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列课程目录 第十八讲 jQuery操作DOM
目录 系列课程目录前言一、jQuery操作DOM1.jQuery添加节点2.jQuery删除节点3.jQuery获取节点 二、课堂作业1.按照要求完成任务2.解析代码 前言 jQuery操作DOM
提示：以下是本篇文章正文内容，下面案例可供参考
一、jQuery操作DOM 1.jQuery添加节点 使用jQuery工厂函数 ( ) 可 以 创 建 H T M L 元 素 ∗ ∗ ()可以创建HTML元素 ** ()可以创建HTML元素∗∗(HTML标签)**
添加节点
append()
可以直接传入HTML代码
可以添加多个元素
原代码：
所列方法的返回值均为原jQuery对象
如 ( " u l " ) . a p p e n d ( " &lt; l i &gt; n e w &lt; / l i &gt; " ) 的 返 回 值 为 ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8774d115a696dd5beca2a0821dc8c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b5e14e23d63630a22e25694ec464e8/" rel="bookmark">
			c语言程序10进制转8进制数,数制转换，将10进制转换为8进制 C语言 栈的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数制转换，将10进制转换为8进制 C语言 栈的应用
#include #include #include typedef int ElemType;
typedef int Status;
#define STACK_SIZE 10
#define STACK_INCREMENT 10
#define OK 1
#define ERROR -1
typedef struct{
ElemType *base;
ElemType *top;
int stacksize;
}Stack;
Status InitStack(Stack &amp;S)
{
S.base=(ElemType*)malloc(STACK_SIZE*sizeof(ElemType));
if (!S.base)
return ERROR;
S.top=S.base;
S.stacksize=STACK_SIZE;
return OK;
}
Status Pop(Stack &amp;S,ElemType &amp;e)
{
if (S.base==S.top)//判断是否非空
return ERROR;
S.top--;//栈顶元素降低
e=*S.top;//输出
return OK;
}
Status Push(Stack &amp;S,ElemType e)
{
if ((S.top-S.base)&gt;=S.stacksize)//栈满追加数据元素
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33b5e14e23d63630a22e25694ec464e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4be5a77b2ecc13a66d839ab8322b1f80/" rel="bookmark">
			Java中布尔类型操作符[  ` &amp;= `  ,    ` |= ` ,    与 ` ^= ` ]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 结论 今天刷Flink代码的时候, 发现操作符 |= , 这个是什么鬼, 做了这么多年Java瞬间觉得好丢人…
总结:
跟正常的 &amp;&amp; , || 操作差不多,输出的结果都是boolean类型.
a值操作符b值结果true&amp;=truetruetrue&amp;=falsefalsefalse&amp;=truefalsefalse&amp;=falsefalsetrue|=truetruetrue|=falsetruefalse|=truetruefalse|=falsefalsetrue^=truefalsetrue^=falsetruefalse^=truetruefalse^=falsefalse 二. 验证代码 public class MainMethod { public static void main(String[] args) { System.out.println(" ======================"); boolean flag = true; flag &amp;= true; System.out.println("true\t&amp;=\ttrue\t==&gt;\t" + flag); flag = true; flag &amp;= false; System.out.println("true\t&amp;=\tfalse\t==&gt;\t" + flag); flag = false; flag &amp;= true; System.out.println("false\t&amp;=\ttrue\t==&gt;\t" + flag); flag = false; flag &amp;= false; System.out.println("false\t&amp;=\tfalse\t==&gt;\t" + flag+"\n"); System.out.println(" ======================"); flag = true; flag |= true; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4be5a77b2ecc13a66d839ab8322b1f80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/296063840ab8de0417b2ca110a8f754c/" rel="bookmark">
			MySQL数据库多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL数据库多表查询 前言 在之前的文章MySQL数据库之SQL入门中，我们讲到了四类SQL中的DQL(数据库查询语言，用于查询表中数据)，但是我仅仅用DQL去查询一张表中数据，而在实际的应用中，经常是对多张数据库表进行查找。本文介绍MySQL数据库的多表查询，介绍内连接查询、外连接查询以及子查询三种多表查询方式及其区别。
零、创建用于查询的示例数据库表 创建一张部门表 CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); 为dept表添加数据 INSERT INTO dept (NAME) VALUES ('开发部'),('市场部'),('财务部'); 创建一张员工表 CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键) ); 为emp表添加数据 NSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('孙悟空','男',7200,'2013-02-24',1); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('猪八戒','男',3600,'2010-12-02',2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('唐僧','男',9000,'2008-08-08',2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('白骨精','女',5000,'2015-10-07',3); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('蜘蛛精','女',4500,'2011-03-14',1); 部门表dept和员工表emp之间的关系
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/296063840ab8de0417b2ca110a8f754c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/475cb16f78979a5c9107d8cf435459e6/" rel="bookmark">
			递归自我总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 递归 概念 什么是递归？ 在一个函数的内部执行 **自身** 特点 - 占内存 - 低版本浏览器中会造成内存泄漏 - 掌握编程思路，可以利用递归的思想，解决问题 - 代码非常简洁 递归解决问题的思路 - 递：向内执行 - 归：向外结束 注意：递归最重要的是终止条件
相关例题： 例题一：创建一个递归函数实现相关功能 完成阶乘的计算规则方式实现阶乘的相关效果。 提示：如要用递归进行相关的编程那么一定要进行要点的寻找要点有如下两点 一个为递归的相关公式 一个为递归的终点 找到两者之后进行相关的计算 注意：递归的相关公式不要用小括号进行包裹否则会出现报错：Maximum call stack size exceeded; function fn(n){ if(n === 1){ return 1; }else{ return (n-1)*n; } } fn(5);//函数内部传进的参数 例题二：已知一段数字 1、1、2、3、5、8、13、21...... 求：第N位的数字是多少 function fn(){ if(n === 1){ return 1; }else if(n === 2){ return 1; }else{ return (n - 1) + (n - 2); } } fn(9);//求第9个数的值是多少 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4467c031dc3d2c6176e5bdd253fff4c2/" rel="bookmark">
			c语言程序 输入一个四位数,用c语言编程:输入一个四位数,求出它的个位、十位、百位、千位...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		满意答案
QQ89748770
推荐于 2018.02.26
采纳率：45% 等级：13
已帮助：7318人
C代码:---------------------
int a;
scanf("%d",&amp;a);
printf("个位:%d,十位:%d,百位:%d,千位:%d",a%10,a%100/10,a%1000/100,a/1000)
--------------------------------
VC++中代码如下:
#include "stdafx.h"
#include int main(int argc, char* argv[])
{
int a;
scanf("%d",&amp;a);
printf("个位:%d,十位:%d,百位:%d,千位:%d",a%10,a%100/10,a%1000/100,a/1000);
system("pause");
return 0;
}
C语言有以下几种取整方法：
1、直接赋值给整数变量。如：
int i = 2.5; 或 i = (int) 2.5;
这种方法采用的是舍去小数部分，可以用于你的问题。
2、C/C++中的整数除法运算符"/"本身就有取整功能(int / int)，而下面介绍的取整函数返回值是double。整数除法对正数的取整是舍去小数部分，但是整数除法对负数的取整结果和使用的C编译器有关。
3、使用floor函数。floor(x)返回的是x的整数部分。如：
floor(2.5) = 2
floor(-2.5) = -3
4、使用ceil函数。ceil(x)返回的是不大于x的最小整数。如：
ceil(2.5) = 2
ceil(-2.5) = -2
floor和ceil对于正数没有区别，但是对于负数结果不同。floor()是向负无穷大舍入，floor(-2.5) = -3；ceil()是向正无穷大舍入，ceil(-2.5) = -2。
37分享举报
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3c6f5960fc62b83d9068e29b67078b0/" rel="bookmark">
			函数参数类型匹配 C&#43;&#43; 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数参数类型匹配 C++ 实现 这段代码实现了给定一个函数，函数的参数是否和给定的参数列表匹配 以下注释详解实现
template &lt;typename Func, typename ... Args&gt; struct is_argument_match { private: // 第一种匹配 // // 匹配一下面的test函数匹配失败的所有情况 template &lt;typename T&gt; static std::false_type test(...); // 第二种匹配 // // 构造T类型加给定参数组成的函数 (std::declval&lt;T&gt;()(std::declval&lt;Args&gt;()...))， // 使用decltype获取其类型值，若定义这种函数类型 //（例如：已定义std::string foo(std::string a, std::string b)，模板匹配成功，否则匹配 // 上面的test函数 template &lt;typename T, typename X = decltype(std::declval&lt;T&gt;()(std::declval&lt;Args&gt;()...))&gt; static std::true_type test(int); // 定义test&lt;Func&gt;(0)进行第二种匹配，若成功 test函数原型是 ：std::true_type test(int) // result_type = decltype(test&lt;Func&gt;(0) = std::true_type // // 第二种匹配失败，则第一种匹配成功 test函数原型是 ：std::false_type test(...) // result_type = decltype(test&lt;Func&gt;(0) = std::false_type using result_type = decltype(test&lt;Func&gt;(0)); public: static constexpr bool value = result_type::value; }; // is_argument_match 的封装 template &lt;typename Func, typename .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3c6f5960fc62b83d9068e29b67078b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9afc734c7ceffc30570d55f37f9b6645/" rel="bookmark">
			ANTLR使用监听器遍历语法分析树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ANTLR生成语法分析树之后我们可以对其节点进行遍历，在过程中完成相应的逻辑操作。ANTLR提供了两种遍历分析树的方法–监听器和访问器，默认会生成监听器的接口和代码。利用监听器实现一个语法分析器将Java中的short数组转化为字符串，例如
short[] dataArr={1, 2, 3}; String dataStr="\u0001\u0002\u0003";	//将short值看作Unicode字符 语法描述文件 如下所示，新建一个语法文件ArrayInit.g4
/** 语法文件以grammar开头，本语法名为ArrayInit，且语法名和文件名必须一致 */ grammar ArrayInit; /** 定义一条名为init的规则，匹配花括号中以逗号分隔的value */ init : '{' value (',' value)* '}' ; /** 定义一个 value 可以是嵌套的结构，也可以是一个简单的整数INT */ value : init | INT	//使用‘|’来分割多个备选分支 ; // 语法规则以小写字母开头, 词法规则以大写字母开头 INT : [0-9]+ ; // 定义词法符号INT，由一个或多个数字组成 WS : [ \t\r\n]+ -&gt; skip ; // 定义空白词法符号并跳过 生成与测试 运行ANTLR工具，生成相关的语法分析器和词法分析器
&gt; antlr4 ArrayInit.g4
其中
ArrayInitParser.java是语法分析器类，每条语法规则都在该类中对应一个方法ArrayInitLexer.java是词法分析器类，用于识别输入中的词法ArrayInit.tokens，每个词法符号类型对应一个数字，将映射关系保存到该文件ArraylnitListener.java,：ArraylnitListener接口中定义了语法树遍历时监听器的回调方法ArraylnitBaseListener.java是该接口的默认实现类，其中的每个方法都为空，我们可以覆盖需要的回调方法，在其中完成逻辑操作。 如下所示为tokens文件中定义的符号类型，可以看到‘{’、‘，’、‘}’分别对应1、2、3，整形INT和空白WS对应4、5
T__0=1
T__1=2
T__2=3
INT=4
WS=5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9afc734c7ceffc30570d55f37f9b6645/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/404e51583796b7889b51fd06b4b6bd63/" rel="bookmark">
			GitHub入门笔记--概述（纯干货，建议一键三连）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言第一章 概述一、Git1、什么是Git2、为什么使用Git（一）对个人（二）对团队 二、GitHub1、什么是GitHub2、为什么使用GitHub 三、关键概念 总结 前言 经过最近一段时间的忙碌，博主又开始重新开始更新博客啦，这次是来记录博主自己看《GitHub入门》一书后所整理的知识，希望能对渴望在github（全球最大的同性社交平台）获得快乐的各位读者有所帮助。
第一章 概述 这一章，我们将介绍什么是Git和GitHub以及他们之间的区别，并同时介绍一些其他常用术语，只有了解了这些基础知识，才能更容易理解和参与讨论你的项目。
一、Git 1、什么是Git Git是一个版本控制系统，版本控制系统是设计用于跟踪文件随时间变化状态的一款软件。更具体地说，Git是一个分布式的版本控制系统。这就意味着，在Git参与项目的每个程序员不仅能拥有文件的当前状态，还能拥有完整的历史记录。
2、为什么使用Git （一）对个人 (1)撤销更改功能
如果编译过程出错，你可以回到之前一个时间点，撤销错误的修改
(2)一个包含所有更改的完整历史记录
如果你想去了解之前的项目状态，你 可以检查项目的先前版本以详细查看当时文件的状态
(3)对改动原因进行文档记录
我们一般很难记住修改代码的原因，使用过Git提交信息功能，就可以很容易地对你之前所做的改动的原因进行文档记录，以备参考
(4)修改一切的信心
既然我们可以如此容易地恢复之前的项目状态，那么我们就可以放心地对项目进行你想要的修改，不用顾忌写错后无法改会之前正确的代码，毕竟大不了一切重头再来还是很浪费时间的。
(5)历史记录的多种分支流
你可以通过创建历史记录的不同分支，来尝试对内容作出不同的更改，最终采取最有方法。
（二）对团队 (1)解决冲突的能力
一个团队使用Git开发项目，许多人可以在同一时间对相同的文件进行更改。通常。Git可以自动合并这些更改。如果不能自动合并，Git将想开发人员展示有何冲突并将使你更容易解决这些冲突
(2)历史记录的独立分支流
在一个项目中，不同人可以在不同的分支工作，这使他们能独立工作在不同的功能上，然后在各自完成后合并这些功能
二、GitHub 1、什么是GitHub GitHub是一个网站(世界上最大的同性社交平台yyds！)，该网站可以为你保存你的Git数据库副本。使用GitHub使你与他人合作开发一个项目变得更加容易，而这归功于GitHub提供的下述机制：一个用以共享库的集中位置，一个基于web的界面以及分叉、拉请求、提出问题、维基等功能，这些功能能使你和你的团队能更有效地对所做的修改进行说明、讨论、评估。
2、为什么使用GitHub GitHub在提供存储Git库的地方的功能的基础上，还提供了许多额外的好处，包括执行以下操作的能力：
(一)文档需求
使用提出问题，可以记录项目的缺陷或指定新的功能，然后这些功能由你的团队进行开发
(二)独立分支流记录的协作
(三)评估工作进展
(四)看到团队的进展
通过pulse或提交历史命令，你可以看到团队的工作进展
三、关键概念 为了更加有效使用Git和GitHub工作，我们需要去理解以下关键概念。
提交
无论你何时将一个或多个文件修改保存到Git的历史记录，你都会创建一个新的提交。提交信息
每次做出提交时，你需要提供一个消息，描述为什么要进行这种改动。这在以后试图理解为什么实现特定的修改时，提交的这一消息是非常有用的。分支
存放在一侧的独立的系列提交，用户可以使用它来进行一个实验或者创建一个新的功能。主分支
无论什么时候闯进一个新的Git项目，都会创建一个默认的分支，称为主分支。这个分支一旦准备发布，你的工作啧应完全停止功能分支
不论何时构建一个新的功能，都将创建一个分支，称为功能分支。发布分支合并
合并是将一个分支完成的全部工作归并到另一个分支。通常是将一个功能分支合并到主分支标签
引用一个特定历史的提交。佐常用语记录发布版本，据此你可以知道发布的是哪个版本的代码以及何时生成的查看
找到一个不同版本的项目历史记录，以及时查看该时间点的文件。通常你会找一个分支以查看在其上完成的所有工作。但其实你可以查看任何类型的提交。拉请求
最初，拉请求是用来请求别人复查已经完成的分支工作，并将它合并到主分支。现在，拉请求常用于一个流程的早期阶段，用以讨论可能的功能。提出问题
可以用来讨论功能。跟踪缺陷，或者两者兼备维基
维基最初由Ward Cunningham开发，是一个轻量级的web界面创建方式，创建的web页面之间用简单的链接相联系。GitHub项目经常使用wiki进行文档记录克隆（贼重要）
通常你要从GitHub下载一个项目的副本，这样你就可以在本地工作。将项目库复制到你的电脑的过程称为克隆分叉 如此多的术语刚开始会令你感到无所适从，但是当你开始实际接触一些项目时，他们将展示更多的意义。
总结 在下一章各位读者将看到GitHub项目的各种元素，以及如何使用它们来开展一个项目的流程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbf658d2e439fc13c9885c5b4e54a57e/" rel="bookmark">
			【SLAM】——GCNv2-SLAM修改成CPU版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GCNv2, SLAM
GPU版本的编译可参考:编译GCNv2_SLAM
将GCNextractor.cc的218行改为： torch::DeviceType device_type; device_type = torch::kCPU; torch::Device device(device_type); const char *net_fn = getenv("GCN_PATH"); net_fn = (net_fn == nullptr) ? "gcn2.pt" : net_fn; module = torch::jit::load(net_fn, device); 使用全局搜索，将torch::kCUDA替换为torch::kCPU
将GCN2/gcn2_320x240.pt文件中的gcn/code/gcn.py中的cuda:0替换为cpu
跑起来的效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8814e98582c64a6c1105229ff0c4b39c/" rel="bookmark">
			装载问题(0-1背包问题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题 2.解析 3.设计 4.分析 源码 https://github.com/TeAmo-Lan/Tracy-Y0617/blob/main/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%9010%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98.cpp
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/362/">«</a>
	<span class="pagination__item pagination__item--current">363/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/364/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>