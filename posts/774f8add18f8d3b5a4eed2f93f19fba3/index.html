<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java——商城后台（2.0） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java——商城后台（2.0）" />
<meta property="og:description" content="书写规范：缩进 命名 注释 封装 1.、类别--查询列表--数据访问层 关于查询类别的列表，需要执行的SQL语句大致是：
select * from pms_category order by sort, id desc 为了封装查询列表时各类别数据，（只保证有用的数据 ，保证数据传输时节省流量，万一旧VO更改 会更加麻烦）应该在csmall-pojo的vo包中创建CategoryListItemVO类，
在类中添加最有必要性的属性：
@Data public class CategoryListItemVO implements Serializable { private Long id; private String name; private Long parentId; private Integer depth; private String icon; private Integer enable; private Integer display; } 在CategoryMapper.java接口中添加抽象方法：
/** * 查询类别的列表 * * @return 类别的列表，如果数据表中无数据，则返回长度为0的列表 */ List&lt;CategoryListItemVO&gt; list(); 在CategoryMapper.xml中配置SQL语句：
&lt;!-- List&lt;CategoryListItemVO&gt; list(); --&gt; &lt;select id=&#34;list&#34; resultMap=&#34;ListResultMap&#34;&gt; select &lt;include refid=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/774f8add18f8d3b5a4eed2f93f19fba3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-29T10:38:41+08:00" />
<meta property="article:modified_time" content="2022-04-29T10:38:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java——商城后台（2.0）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>书写规范：缩进 命名 注释 封装 </h2> 
<p> </p> 
<h2></h2> 
<h2></h2> 
<h2>1.、类别--查询列表--数据访问层</h2> 
<p>关于查询类别的列表，需要执行的SQL语句大致是：</p> 
<pre><code>select * from pms_category order by sort, id desc</code></pre> 
<p>为了封装查询列表时各类别数据，（只保证有用的数据 ，保证数据传输时节省流量，万一旧VO更改 会更加麻烦）应该在<code>csmall-pojo</code>的<code>vo</code>包中创建<code>CategoryListItemVO</code>类，</p> 
<p>在类中添加最有必要性的属性：</p> 
<pre><code>@Data
public class CategoryListItemVO implements Serializable {

    private Long id;
    private String name;
    private Long parentId;
    private Integer depth;
    private String icon;
    private Integer enable;
    private Integer display;

}</code></pre> 
<p>在<code>CategoryMapper.java</code>接口中添加抽象方法：</p> 
<pre><code>/**
 * 查询类别的列表
 *
 * @return 类别的列表，如果数据表中无数据，则返回长度为0的列表
 */
List&lt;CategoryListItemVO&gt; list();</code></pre> 
<p>在<code>CategoryMapper.xml</code>中配置SQL语句：</p> 
<pre><code class="language-XML">&lt;!-- List&lt;CategoryListItemVO&gt; list(); --&gt;
&lt;select id="list" resultMap="ListResultMap"&gt;
    select
        &lt;include refid="ListQueryFields" /&gt;
    from
        pms_category
    order by
        sort, id desc
&lt;/select&gt;

&lt;sql id="ListQueryFields"&gt;
    &lt;if test="true"&gt;
        id,
        name,
        parent_id,
        depth,
        icon,
        enable,
        is_display
    &lt;/if&gt;
&lt;/sql&gt;

&lt;resultMap id="ListResultMap" type="cn.tedu.csmall.pojo.vo.CategoryListItemVO"&gt;
    &lt;id column="id" property="id" /&gt;
    &lt;result column="name" property="name" /&gt;
    &lt;result column="parent_id" property="parentId" /&gt;
    &lt;result column="depth" property="depth" /&gt;
    &lt;result column="icon" property="icon" /&gt;
    &lt;result column="enable" property="enable" /&gt;
    &lt;result column="is_display" property="display" /&gt;
&lt;/resultMap&gt;</code></pre> 
<p>完成后，在<code>CategoryMapperTests</code>中测试：</p> 
<pre><code>@Test
@Sql(scripts = {"classpath:truncate.sql", "classpath:insert_data.sql"})
@Sql(scripts = {"classpath:truncate.sql"}, executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
void testList() {
    List&lt;?&gt; list = mapper.list();
    log.debug("查询到的数据的数量：{}", list.size());
    for (Object item : list) {
        log.debug("{}", item);
    }
}</code></pre> 
<h2>2、 类别--查询列表--业务逻辑层</h2> 
<p>  <span style="color:#be191c;"><strong> 没有条件查询   不需要处理异常。。。。</strong></span></p> 
<p>在<code>ICategoryService</code>中添加抽象方法：</p> 
<pre><code>/**
 * 查询类别的列表
 *
 * @return 类别的列表，如果数据表中无数据，则返回长度为0的列表
 */
List&lt;CategoryListItemVO&gt; list();</code></pre> 
<p>在<code>CategoryServiceImpl</code>中实现以上抽象方法：</p> 
<blockquote> 
 <pre>@Override public List&lt;CategoryListItemVO&gt; list() { return categoryMapper.list(); }
</pre> 
</blockquote> 
<p>在<code>CategoryServiceTests</code>中测试：</p> 
<pre><code>@Test
@Sql(scripts = {"classpath:truncate.sql", "classpath:insert_data.sql"})
@Sql(scripts = {"classpath:truncate.sql"}, executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
void testList() {
    List&lt;?&gt; list = service.list();
    log.debug("查询到的数据的数量：{}", list.size());
    for (Object item : list) {
        log.debug("{}", item);
    }
}</code></pre> 
<hr> 
<h2>3. 类别--查询列表--控制器层</h2> 
<p>在<code>CategoryController</code>中添加：</p> 
<pre>@ApiOperationSupport(order = 40)
@ApiOperation("查询类别列表")
@GetMapping("")
public JsonResult&lt;List&lt;CategoryListItemVO&gt;&gt; list() {
    return JsonResult.ok(categoryService.list());
}</pre> 
<p> 题外话：加实体类的在线文档注解    显示在线文档的返回结果。</p> 
<pre><code>
import java.io.Serializable;

@Data
public class CategoryListItemVO implements Serializable {

    @ApiModelProperty(value = "类别id",position = 1)
    private Long id;

    @ApiModelProperty(value = "类别名称",example = "家电",required = true,position = 2)
    private String name;

    @ApiModelProperty(value = "父级类别名称id  如果是一级类 为 0",example = "0",required = true,position = 3)
    private Long parentId;

    @ApiModelProperty(value = "几级分类",position = 4)
    private Integer depth;

    @ApiModelProperty(value = "图标的URL",position = 5)
    private String icon;

    @ApiModelProperty(value = "是否启用",position = 6)
    private Integer enable;

    @ApiModelProperty(value = "是否需要展示",position = 7)
    private Integer display;
}
</code></pre> 
<p></p> 
<p></p> 
<p>多加的模块在 4.21下午里面</p> 
<hr> 
<h2>4. 类别--根据id查询数据--数据访问层</h2> 
<p>此前在“增加类别”时已经完成根据id查询的功能。<br>  </p> 
<h2>5. 类别--根据id查询数据--业务逻辑层</h2> 
<p>在<code>ICategoryService</code>中添加抽象方法：  再业务逻辑实现类  重写方法</p> 
<pre><code>/**
 * 根据类别id获取类别详情
 *
 * @param id 类别id
 * @return 匹配的类别详情，如果没有匹配的数据，则返回null
 */
CategoryStandardVO getById(Long id);
在CategoryServiceImpl中实现：

public CategoryStandardVO getById(Long id) {
    CategoryStandardVO queryResult = categoryMapper.getById(id);
    if (queryResult == null) {
        throw new ServiceException(NOT_FOUND, "查询类别详情失败，尝试访问的数据不存在！");
    }
    return queryResult;
}</code></pre> 
<h2>6. 类别--根据id查询数据--控制器层</h2> 
<p>在<code>CategoryController</code>中添加：</p> 
<pre><code>@ApiOperationSupport(order = 40)
@ApiOperation("根据id查询类别详情")
//下面的的注解  api在线文档中对参数进行说明
@ApiImplicitParam(name = "id", value = "类别id", required = true, paramType = "path", dataType = "long")
@GetMapping("/{id:[0-9]+}")  //id表示跟参数的id相同   //@PathVariable表示冲url中获取数字
public JsonResult&lt;CategoryStandardVO&gt; getById(@PathVariable Long id) {
    return JsonResult.ok(categoryService.getById(id));
}</code></pre> 
<p>提示：原查询列表的方法的排序序号已从<code>40</code>改为更大的值（45）。</p> 
<p>另外，应该在以上查询返回的结果类型中各属性上添加<code>@ApiModelProperty</code>注解，以完善API文档：</p> 
<pre><code>@Data
public class CategoryStandardVO implements Serializable {

    @ApiModelProperty(value = "数据id", position = 1)
    private Long id;

    @ApiModelProperty(value = "类别名称", position = 2)
    private String name;

    @ApiModelProperty(value = "父级类别id，如果是一级分类，则此属性值为0", position = 3)
    private Long parentId;

    @ApiModelProperty(value = "深度，最顶级类别的深度为1，次级为2，以此类推", position = 4)
    private Integer depth;

    @ApiModelProperty(value = "类别关键词", position = 5)
    private String keywords;

    @ApiModelProperty(value = "自定义排序序号", position = 6)
    private Integer sort;

    @ApiModelProperty(value = "图标的URL", position = 7)
    private String icon;

    @ApiModelProperty(value = "是否启用，1=启用，0=禁用", position = 8)
    private Integer enable;

    @ApiModelProperty(value = "是否为父级（是否包含子级），1=是父级，0=不是父级", position = 9)
    private Integer parent;

    @ApiModelProperty(value = "是否显示在导航栏，1=显示，0=不显示", position = 10)
    private Integer display;

}</code></pre> 
<hr> 
<h2>7. 关于缓存</h2> 
<p>缓存数据是将数据存储在更加易于访问的位置，以前提高查询数据的效率！</p> 
<p>通常，数据都是存储在数据库中的，并且，数据库服务器与应用程序服务器不是同一台服务器，当需要获取某个数据时，如果能将数据在应用程序服务器中另外保存一份，并从此处获取数据，就会比从数据库服务器获取数据更加高效，另外，数据库中的数据是存储在硬盘上的，如果将“另外保存”的数据存储在比硬盘访问效率更高的存储介质中，例如保存到内存中，也可以非常明显的提高读取数据的效率。</p> 
<p>所以，常见的缓存手段是将数据库中的数据存储到应用程序服务器中（可能是存储在硬盘上，也可能是存储在内存中），或者，使用专门的缓存服务器（通常都是基于内存存储的）。</p> 
<p>但是，一旦使用了缓存，也就是同一份数据在不同的位置存储了2份甚至多份，就会存在数据不一致的风险，则需要评估此风险！有些数据对于“准确性”要求并不严格，比如某篇文章的点赞数量，火车票在车次列表中显示的余票数量，但是，也有时需要数据是非常精准的，例如在创建订单尝试购买某趟火车的车票时，要求查询到的余票数量必须是精准的！</p> 
<p>一般来说，如果要求某个数据必须是精准的，是不会使用缓存的，而是直接从数据库查询数据，或者，在这些场景中，及时同步缓存中的数量，使之始终与数据库中的数据保持一致！</p> 
<p>通常，使用缓存来存储的数据具有以下特点：</p> 
<ul><li>访问频率偏高，甚至非常高</li><li>数据改变的频率相对较低，或对数据的准确性要求并不严格</li></ul> 
<hr> 
<h2>8. 使用Redis缓存数据</h2> 
<p>Redis是一个主流的基于内存的NO-SQL数据存储服务。</p> 
<p>相关下载：</p> 
<ul><li> <p>Redis 3.2.100 Windows x64 msi 下载链接：<a href="https://gitee.com/link?target=https%3A%2F%2Frobinliu.3322.org%3A8888%2Fdownload%2FRedis-x64-3.2.100.msi" rel="nofollow" title="https://robinliu.3322.org:8888/download/Redis-x64-3.2.100.msi">https://robinliu.3322.org:8888/download/Redis-x64-3.2.100.msi</a></p> </li><li> <p>Redis 3.2.100 Windows x64 msi 百度网盘：<a href="https://gitee.com/link?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1lHPFAyazgGS-6U6str6xtg" rel="nofollow" title="https://pan.baidu.com/s/1lHPFAyazgGS-6U6str6xtg">https://pan.baidu.com/s/1lHPFAyazgGS-6U6str6xtg</a> 密码:cib8</p> </li><li> <p>Redis 3.2.13 Mac/Linux</p> 
  <ul><li>下载：<a href="https://gitee.com/link?target=http%3A%2F%2Fdoc.canglaoshi.org%2Fredis%2Fredis-3.2.13.tar.gz" rel="nofollow" title="http://doc.canglaoshi.org/redis/redis-3.2.13.tar.gz">http://doc.canglaoshi.org/redis/redis-3.2.13.tar.gz</a></li><li>下载链接：<a href="https://gitee.com/link?target=https%3A%2F%2Frobinliu.3322.org%3A8888%2Fdownload%2Fredis-3.2.13.tar.gz" rel="nofollow" title="https://robinliu.3322.org:8888/download/redis-3.2.13.tar.gz">https://robinliu.3322.org:8888/download/redis-3.2.13.tar.gz</a></li><li>官网下载：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fredis%2Fredis%2Farchive%2F3.2.13.tar.gz" title="https://github.com/redis/redis/archive/3.2.13.tar.gz">https://github.com/redis/redis/archive/3.2.13.tar.gz</a>)</li></ul></li><li> <p>Another Redis Desktop Manager 1.5.2 Win 官网下载： <a href="https://gitee.com/qishibo/AnotherRedisDesktopManager/attach_files/958501/download/Another-Redis-Desktop-Manager.1.5.2.exe" rel="nofollow" title="https://gitee.com/qishibo/AnotherRedisDesktopManager/attach_files/958501/download/Another-Redis-Desktop-Manager.1.5.2.exe">https://gitee.com/qishibo/AnotherRedisDesktopManager/attach_files/958501/download/Another-Redis-Desktop-Manager.1.5.2.exe</a></p> </li><li> <p>Another Redis Desktop Manager 1.5.1 M1 ARM64 官网下载：<a href="https://gitee.com/qishibo/AnotherRedisDesktopManager/attach_files/934337/download/Another-Redis-Desktop-Manager-M1-arm64-1.5.1.dmg" rel="nofollow" title="https://gitee.com/qishibo/AnotherRedisDesktopManager/attach_files/934337/download/Another-Redis-Desktop-Manager-M1-arm64-1.5.1.dmg">https://gitee.com/qishibo/AnotherRedisDesktopManager/attach_files/934337/download/Another-Redis-Desktop-Manager-M1-arm64-1.5.1.dmg</a></p> </li><li> <p>Another Redis Desktop Manager 1.5.2 macOS 官网下载：<a href="https://gitee.com/qishibo/AnotherRedisDesktopManager/attach_files/958502/download/Another-Redis-Desktop-Manager.1.5.2.dmg" rel="nofollow" title="https://gitee.com/qishibo/AnotherRedisDesktopManager/attach_files/958502/download/Another-Redis-Desktop-Manager.1.5.2.dmg">https://gitee.com/qishibo/AnotherRedisDesktopManager/attach_files/958502/download/Another-Redis-Desktop-Manager.1.5.2.dmg</a></p> </li></ul> 
<p>关于Redis编程，在Java中，有许多成熟的开发框架，例如Redisson、Jedis、lettuce等……Spring提供了<code>spring-data</code>的框架，用于统一了API，甚至，在Spring Boot中，还提供了<code>spring-boot-starter-data-redis</code>依赖项，集成了<code>spring-data</code>对Redis中的数据访问的各依赖项及自动配置，使得在Spring Boot中实现Redis编程更加简单！</p> 
<p>当通过Spring系列框架实现Redis编程时，需要使用到<code>RedisTemplate</code>对象，在Spring Boot工程中，应该将创建此类型的对象，并交给Spring进行管理，后续，当需要执行Redis数据访问时，调用此对象的方法即可！</p> 
<p>则在<code>csmall-product.webapi</code>的<code>config</code>包下创建<code>RedisConfiguration</code>类：</p> 
<p>配置将<code>RedisTemplate</code>对象放到spring容器里面</p> 
<pre><code>@Configuration
public class RedisConfiguration {
    /*
    基于键值对  都可以使用泛型   .......
    值需要是可系列化的  就是实现了序列化接口的类对象都可以传
    因为需要再程序和内存硬盘里面传输。
     */
        //这个对象就是一个redis服务，或者说一个小程序。
    @Bean
    public RedisTemplate&lt;String , Serializable&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory){
        RedisTemplate&lt;String , Serializable&gt; redisTemplate=new RedisTemplate&lt;&gt;();
        //设置将值和键设置   方便缓存进行解析
        redisTemplate.setKeySerializer(RedisSerializer.string());
        redisTemplate.setValueSerializer(RedisSerializer.json());
        //设置链接工程   再参数上声明  springboot会帮助创建。
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //暂时不用的
        redisTemplate.setHashKeySerializer(RedisSerializer.string());
        redisTemplate.setHashValueSerializer(RedisSerializer.json());

        return  redisTemplate;
    }
}
</code></pre> 
<p>接下来，可以在测试包建redis包下创建<code>RedisTemplateTests</code>类，进行简单的测试：</p> 
<pre><code>

@SpringBootTest
public class RedisTemplateTests {

    @Autowired
    RedisTemplate&lt;String, Serializable&gt; redisTemplate;

    @Test
    public void testSetValue() {
        // 对于普通的字符串值，调用opsForValue()
        // 再调用set()方法实现存入数据
        // 此方法的特点与Map中的put()类似，既是新增数据的方法，也是修改数据的方法
        String key = "category";
        Serializable value = "Phone";
        //得到一个值的操作器
        ValueOperations&lt;String, Serializable&gt; opsForValue = redisTemplate.opsForValue();
        opsForValue.set(key, value);
    }

}</code></pre> 
<p>存入值后，可以通过同样的“值操作器”取出值，例如：</p> 
<pre><code>@Test
public void testGetValue() {
    // 因为值是字符串值，需要先调用opsForValue()
    // 再调用get()方法根据key获取值
    String key = "category";
    Serializable value = redisTemplate.opsForValue().get(key);
    System.out.println(value);
}</code></pre> 
<p>由于值的操作配置序列化器是JSON的序列化器，所以，通过以上方式，还可以将整个对象直接写入到Redis中并读取出来，因为序列化器会将对象转换为JSON格式的字符串，只不过，为了保证反序列化成功，还会在JSON数据中添加数据的类型。</p> 
<p></p> 
<p><img alt="" height="34" src="https://images2.imgbox.com/8b/3f/PMx7XL4v_o.png" width="322">清除所有</p> 
<p>当我们设置值的时候 进行了json   转换  而redis并没有 如果通过redis控制台设置值 不能通过ideajava代码获取。</p> 
<p></p> 
<p>会将数据持久化，不是一直保存再内存里面。</p> 
<hr> 
<p></p> 
<p>另外，由于默认情况下并不支持Java 8中的日期时间（<code>LocalDateTime</code>、<code>LocalDate</code>、<code>LocalTime</code>），为了保证能够对这些数据类型执行正确的序列化和反序列化，需要在对应的属性上添加注解，例如：</p> 
<p>需要先加web依赖到pojo里面</p> 
<pre><code>&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
                &lt;/exclusion&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
                &lt;/exclusion&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
                &lt;/exclusion&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;</code></pre> 
<p> 序列化和反序列化：也就可以通过配置类装配起来实现每个属性的序列化与反系列化   复制粘贴。</p> 
<pre><code>// 使用以下注解时，需要添加Jackson相关依赖
@JsonSerialize(using = LocalDateTimeSerializer.class)  序列化为了存时间
@JsonDeserialize(using = LocalDateTimeDeserializer.class) 反序列化 为了读出来
private LocalDateTime gmtCreate;

两个属性都得加   记得</code></pre> 
<p><span style="color:#be191c;"><strong>接下来，即可通过<code>RedisTemplate</code>的<code>opsForValue()</code>再调用<code>set()</code> / <code>get()</code>方法写入 / 读取整个对象，</strong></span>例如：</p> 
<pre><code>设置
@Test
public void testSetObjectValue() {
    String key = "category999";
    Category category = new Category();
    category.setId(999L);
    category.setName("礼品");
    category.setEnable(1);
    category.setGmtCreate(LocalDateTime.now());
    redisTemplate.opsForValue().set(key, category);
}
获取
@Test
public void testGetObjectValue() {
    String key = "category999";
    Serializable serializable = redisTemplate.opsForValue().get(key);
    System.out.println("获取到的值：" + serializable);
    System.out.println("获取到的值的类型：" + serializable.getClass().getName());
}</code></pre> 
<p>redis获得是带类名的json对象</p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/18/9f/kejRfgeN_o.png" width="566"></p> 
<p></p> 
<hr> 
<hr> 
<p></p> 
<p>由于Redis中的数据存在与数据库中的数据不一致的风险，则可能某些数据是无效的，需要清楚，并且，如果反复向Redis中存入大量不同Key的数据，也可能导致Redis服务器内存不足，则需要清除数据。在向Redis中存入数据时，可以指定数据的TTL（Time To Live：有效生存时间），当此生存时间结束后，对应的数据将被自动清理：</p> 
<pre><code class="language-java">@Test
public void testSetValueDuration() {
    String key = "brand";
    Serializable value = "华为";
    ValueOperations&lt;String, Serializable&gt; opsForValue = redisTemplate.opsForValue();
    
    //key  value  时间数  时间单位
    opsForValue.set(key, value, 15, TimeUnit.SECONDS);
}</code></pre> 
<p>也可以自行通过指令清理（删除）某些数据，例如：</p> 
<pre><code class="language-java">@Test
public void testDelete() {
    String key = "category";
    redisTemplate.delete(key);
}</code></pre> 
<p>另外，还有关于列表的数据操作，例如添加元素到Redis中的列表中：</p> 
<pre><code>@Test
public void testSetListValue() {
    // 向Redis中存入列表数据
    // 需要调用RedisTemplate对象得到opsForList()返回对象后再操作
    //保证了是列表
    List&lt;String&gt; categories = new ArrayList&lt;&gt;();
    categories.add("家电");
    categories.add("食品");
    categories.add("衣物");
    String key = "categories";
    // redisTemplate.opsForList().set(key, 0, categories.get(0));
    //这个操作之前需要有列表key 不然报错
    for (int i = 0; i &lt; categories.size(); i++) {
    //right  和  left系列方法  区别  将新加元素放在右边和左边。
    //rightPop  弹出元素   （）    
    redisTemplate.opsForList().rightPush(key, categories.get(i));
    }
}</code></pre> 
<p>获取列表的长度：</p> 
<pre><code>@Test
public void testGetListSize() {
    String key = "categories";
    Long size = redisTemplate.opsForList().size(key);
    System.out.println("size = " + size);
}</code></pre> 
<p>获取列表中的元素：</p> 
<pre><code>@Test
public void testGetListValue() {
    // 在RedisTemplate获取的opsForList()返回的结果对象中
    // 当获取列表值时，默认是分页获取的，所以，每次获取都需要指定获取哪个区间段的值
    // 在指定区间时，start取值为0表示从头开始，end取值为-1表现末尾（直至最后一个元素）
    // 在获取列表值时，会获取包含start至包含end的元素
    // start / end均表示元素在列表中的索引，是从0开始顺序编号的
//  含头含尾  
    String key = "categories";
    long start = 2;
    long end = 4;
    List&lt;Serializable&gt; list = redisTemplate.opsForList().range(key, start, end);
    for (Serializable serializable : list) {
        System.out.println(serializable);
    }
}</code></pre> 
<p></p> 
<h2>9. 在项目中缓存类别列表</h2> 
<p>由于类别列表是常用数据（例如每次打开首页都需要，且其它的页面也可能需要），并且这些数据在项目正式上线后一般不会频繁调整，是非常适合缓存的！</p> 
<p>这种缓存数据应该是在服务刚刚启动时就需要读取数据库，并将数据写入到Redis的，在后续的访问中，都将优先从Redis中获取数据！</p> 
<p>所以，目前需要解决的问题有：</p> 
<ul><li>从数据库中读取类别列表（已完成）</li><li>将从数据库中读取到的列表写入到Redis中</li><li>使得启动服务时就执行写入Redis的操作</li></ul> 
<p>先在<code>csmall-product-webapi</code>模块的根包下创建<code>cache</code>子包，并在其下创建<code>repo</code>子包，在其中先创建<code>ICategoryCacheRepository</code>接口，在接口中定义必要的抽象方法：</p> 
<pre><code>public interface ICategoryCacheRepository {

    /**
     * 清除相关缓存
     */
    void clear();

    /**
     * 将列表数据添加到缓存
     *
     * @param categories 列表数据
     */
    void appendList(List&lt;CategoryListItemVO&gt; categories);

}</code></pre> 
<p>然后，在<code>repo</code>下创建<code>impl</code>子包，并在其中创建<code>CategoryCacheRepositoryImpl</code>实现：</p> 
<pre><code>@Repository
public class CategoryCacheRepositoryImpl implements ICategoryCacheRepository {

    @Autowired
    private RedisTemplate&lt;String, Serializable&gt; redisTemplate;

    /**
     * 类别列表在Redis中的Key
     */
    public static final String KEY_LIST = "categories";

    @Override
    public void clear() {
        redisTemplate.delete(KEY_LIST);
    }

    @Override
    public void appendList(List&lt;CategoryListItemVO&gt; categories) {
        for (CategoryListItemVO category : categories) {
            redisTemplate.opsForList().rightPush(KEY_LIST, category);
        }
    }

}</code></pre> 
<p>接下来，应该在“类别”数据的业务逻辑层进行后续的处理，则在<code>CategoryServiceImpl</code>中添加：</p> 
<pre><code>@Autowired
private ICategoryCacheRepository categoryCacheRepository;

/**
 * 加载类别数据的缓存
 */
private void loadCache() {
    // 1. 从数据库中读取类别列表
    List&lt;CategoryListItemVO&gt; list = categoryMapper.list();
    // 2. 清除缓存的类别数据
    categoryCacheRepository.clear();
    // 3. 将类别数据写入到缓存
    categoryCacheRepository.appendList(list);
}</code></pre> 
<p>提示：以上方法是私有的，因为后续可能需要复用。</p> 
<p>为了使得以上功能是可以被外部调用的，需要在<code>ICategoryService</code>接口中定义对外的方法：</p> 
<blockquote> 
 <pre><code>/**
 * 初始化缓存
 */
void initCache();</code></pre> 
 <p></p> 
</blockquote> 
<p>并在<code>CategoryServiceImpl</code>中，直接调用上面的私有方法来实现：</p> 
<pre><code>@Override
public void initCache() {
    loadCache();
}</code></pre> 
<p>最后，需要在服务启动时就执行以上初始化缓存的操作，此操作一般称之为“缓存预热”，则在<code>csmall-product-webapi</code>的<code>cache</code>包下创建<code>preload</code>子包，并在其下创建<code>CachePreLoad</code>类：</p> 
<pre><code>@Slf4j
@Component
public class CachePreLoad implements ApplicationRunner {

    @Autowired
    private ICategoryService categoryService;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        log.debug("缓存预热，准备向缓存中写入【类别】数据……");
        categoryService.initCache();
    }

}</code></pre> 
<p>提示：当需要启动服务时就会执行某个代码片段，可以自定义组件类，实现<code>ApplicationRunner</code>接口，将需要执行的代码片段添加在重写的<code>run()</code>方法中即可。</p> 
<hr> 
<p>接下来，还需要保证在后续获取数据列表时，能够从缓存中读取数据，则先在<code>ICategoryCacheRepository</code>中添加读取列表的功能：</p> 
<pre><code>/**
 * 从缓存中读取列表数据
 *
 * @return 列表数据
 */
List&lt;CategoryListItemVO&gt; list();</code></pre> 
<p>然后，在<code>CategoryCacheRepositoryImpl</code>中实现：</p> 
<pre><code>@Override
public List&lt;CategoryListItemVO&gt; list() {
    long start = 0;
    long end = -1;
    List&lt;Serializable&gt; list = redisTemplate.opsForList().range(KEY_LIST, start, end);
    List&lt;CategoryListItemVO&gt; categories = new ArrayList&lt;&gt;();
    for (Serializable serializable : list) {
        categories.add((CategoryListItemVO) serializable);
    }
    return categories;
}</code></pre> 
<p>完成后，当需要读取类别列表时，在<code>CategoryServiceImpl</code>中将调整为从缓存中读取：</p> 
<pre><code>@Override
public List&lt;CategoryListItemVO&gt; list() {
    // return categoryMapper.list();
    return categoryCacheRepository.list();
}</code></pre> 
<p>重启项目，则客户端提交请求后都将从缓存中获取类别列表！</p> 
<hr> 
<p><span style="color:#be191c;"><strong>为了避免数据库中的数据发生变化，</strong></span>但是缓存中的并没有更新，</p> 
<p><span style="color:#1c7331;"><strong>对于数据较少时  当用户觉得数据不准时 可执行重建缓存功能</strong></span></p> 
<p>所以，添加“重建缓存”的功能，先在<code>ICategoryService</code>中添加：</p> 
<pre><code>/**
 * 重建缓存
 */
void rebuildCache();</code></pre> 
<p>并在<code>CategoryServiceImpl</code>中实现：</p> 
<pre><code>@Override
public void rebuildCache() {
    // TODO 添加限制频繁重建缓存的策略   不能频繁操作   下面实现
    loadCache();
}</code></pre> 
<p>并在控制器中添加处理此请求：</p> 
<pre><code>@ApiOperationSupport(order = 50)
@ApiOperation("重建缓存")
@PostMapping("/cache/rebuild")
public JsonResult&lt;Void&gt; rebuildCache() {
    categoryService.rebuildCache();
    return JsonResult.ok();
}</code></pre> 
<p>重启项目，当需要手动更新缓存数据时，就可以向服务器端发送“重建缓存”的请求，则缓存的数据将更新。</p> 
<p></p> 
<hr> 
<hr> 
<p>但是，绝对不允许频繁的进行“重建缓存”的操作，必须添加一定的限制条件，通常会使用间隔时间进行约束，则需要解决几个问题：</p> 
<ul><li>必须在每次“重建缓存”时记录时间，作为后续的“重建缓存”时用于判断的“上次重建缓存的时间”，此时间值应该记录在Redis中（其实也可以声明全局的静态成员存储此时间），则需要在<code>ICategoryCacheRepository</code>中声明2个新的抽象方法，分别用于写入时间值和读取时间值</li><li>在<code>CategoryServiceImpl</code>业务实现类的<code>private void loadCache()</code>方法中，当已经写入缓存数据后，调用“写入时间值”的方法，以记录此次建立/重建缓存的时间</li><li>在“重建缓存”的方法中，读取记录的时间值，用于与当前时间值进行对比，如果时间差小于一定时间，则抛出异常</li></ul> 
<p><strong>ICategoryCacheRepository</strong></p> 
<pre><code>/**
 * 写入“最近重建缓存”的时间
 */
void setRecentRebuildTime(Long time);

/**
 * 读取“最近重建缓存”的时间
 * @return “最近重建缓存”的时间
 */
Long getRecentRebuildTime();</code></pre> 
<p><strong>CategoryCacheRepositoryImpl</strong></p> 
<pre><code>/**
 * 类别的“最近重建缓存时间”Redis中的Key
冒号的意义  会在可视化界面做出分级   -号不会分级显示在一行
 */
public static final String KEY_RECENT_REBUILD_TIME = "categories:recent-rebuild-time";

@Override
public void setRecentRebuildTime(Long time) {
    redisTemplate.opsForValue().set(KEY_RECENT_REBUILD_TIME, time);
}

@Override
public Long getRecentRebuildTime() {
    Serializable serializable = redisTemplate.opsForValue().get(KEY_RECENT_REBUILD_TIME);
    if (serializable != null) {
        if (serializable instanceof Long) {
            return (Long) serializable;
        }
    }
    return null;
}</code></pre> 
<p><strong>CategoryServiceImpl</strong></p> 
<pre><code>/**
 * 重建缓存的间隔时间，以分钟为单位
 */
public static final Integer REBUILD_INTERVAL_TIME_IN_MINUTE = 1;

@Override
public void rebuildCache() {
    // 读取“最近重建缓存”的时间
    Long recentRebuildTime = categoryCacheRepository.getRecentRebuildTime();
    if (recentRebuildTime == null) {
        recentRebuildTime = 0L;
    }
    // 与当前时间对比，判断时间差是否大于xx分钟
    long currentTimeMillis = System.currentTimeMillis();
    if (currentTimeMillis - recentRebuildTime &gt; REBUILD_INTERVAL_TIME_IN_MINUTE * 60 * 1000) {
        // 是：两次重建缓存的间隔时间较长，允许重建缓存
        loadCache();
    } else {
        // 否：两次重建缓存的间隔时间太短，则抛出异常
        throw new ServiceException(NOT_ACCEPTABLE, "重建缓存失败，重建缓存必须间隔至少" + REBUILD_INTERVAL_TIME_IN_MINUTE + "分钟！");
    }
}

/**
 * 加载类别数据的缓存
 */
private void loadCache() {
    // 1. 从数据库中读取类别列表
    List&lt;CategoryListItemVO&gt; list = categoryMapper.list();
    // 2. 清除缓存的类别数据
    categoryCacheRepository.clear();
    // 3. 将类别数据写入到缓存
    categoryCacheRepository.appendList(list);
    // 4. 写入“最近重建缓存”的时间
    categoryCacheRepository.setRecentRebuildTime(System.currentTimeMillis());
}</code></pre> 
<h2>10. 关于缓存每个“类别”数据</h2> 
<p>当缓存了“类别”列表list后，很难直接通过缓存中的“列表”实现“根据id获取某个类别的详情”，</p> 
<p>为了便于实现各种情景下的数据访问，还应该再次缓存每个“类别”数据。</p> 
<p>为了便于后续的操作，在缓存每个“类别”数据时，使用的Key必须是有规律的，并且，还应该将每个“类别”的id作为Key的一部分，才能实现“根据id获取某个类别的详情”。</p> 
<p>暂定Key的规则是<code>categories:id</code>，例如<code>categories:15</code>。id为数据的id</p> 
<p>要实现此目标，需要：</p> 
<ul><li>从数据库中可以获取所有“类别”详情（未实现，此前实现的读取<code>CategoryListItemVO</code>，此时需要一次性读出所有<code>CategoryStandardVO</code>）</li><li>将某个id对应的“类别”详情数据写入到缓存中</li><li>根据id从缓存中读取“类别”详情</li><li>获取所有在缓存中的“类别”数据的Key(s)</li><li>在“类别”的业务实现类中，将原本从数据库中读取数据改为从缓存中读取数据</li><li>在重建缓存时，需要先清除各个“类别”详情数据，并添加各“类别”详情数据到缓存中</li></ul> 
<p>关于一次性读出所有<code>CategoryStandardVO</code>，先在<code>CategoryMapper.java</code>接口添加：</p> 
<pre><code>List&lt;CategoryStandardVO&gt; listDetails();</code></pre> 
<p>然后，在<code>CategoryMapper.xml</code>中配置SQL：</p> 
<pre><code>&lt;!-- List&lt;CategoryStandardVO&gt; listDetails(); --&gt;
&lt;select id="listDetails" resultMap="StandardResultMap"&gt;
    select
        &lt;include refid="StandardQueryFields" /&gt;
    from
        pms_category
    order by
        sort, id desc
&lt;/select&gt;</code></pre> 
<p>调整Key的常量：</p> 
<pre><code>/**
     * 在Redis缓存的所有”类别“数据的Key共有的前缀
     */
    public static final String KEY_PREFIX = "csmall:category:";
    /**
     * ”类别“列表在Redis中的Key，即：csmall:category:list
     */
    public static final String KEY_LIST = KEY_PREFIX + "list";
    /**
     * 各”类别“在Redis中的Key的前缀，例如：csmall:category:item:15
     */
    public static final String KEY_PREFIX_ITEM = KEY_PREFIX + "item:";
    /**
     * 类别的“最近重建缓存时间”Redis中的Key，即：csmall:category:recent-rebuild-time
     */
    public static final String KEY_RECENT_REBUILD_TIME = KEY_PREFIX + "recent-rebuild-time";</code></pre> 
<p>然后，在<code>ICategoryCacheRepository</code>中添加抽象方法：</p> 
<p><code>ICategoryCacheRepository及其实现类是为了缓存工作的  为了数据库读到数据放到缓存中</code></p> 
<pre><code>/**
 * 将某个“类别”详情数据写入到缓存中
 *
 * @param category “类别”详情数据
 */
void setCategory(CategoryStandardVO category);

/**
 * 根据id从缓存中读取“类别”详情
 *
 * @param id 尝试读取的”类别“的id
 * @return 匹配的“类别”详情，如果没有匹配的数据，则返回null
 */
CategoryStandardVO getCategoryById(Long id);

/**
 * 获取缓存中所有”类别“数据的Key
 * @return
 */
Set&lt;String&gt; getKeys();
</code></pre> 
<p></p> 
<p>并在CategoryCacheRepository中实现：</p> 
<p></p> 
<pre><code>并在CategoryCacheRepository中实现：

@Override
public void setCategory(CategoryStandardVO category) {
    String key = KEY_PREFIX_ITEM + category.getId();
    log.debug("处理【类别】缓存：向缓存中写入Key为【{}】的数据：{}", key, category);
    redisTemplate.opsForValue().set(key, category);
}

@Override
public CategoryStandardVO getCategoryById(Long id) {
    CategoryStandardVO category = null;
    String key = KEY_PREFIX_ITEM + id;
    Serializable serializable = redisTemplate.opsForValue().get(key);
    if (serializable != null) {
        if (serializable instanceof CategoryStandardVO) {
            category = (CategoryStandardVO) serializable;
        }
    }
    log.debug("处理【类别】缓存：从缓存中读取详情数据：id={}，结果={}", key, category);
    return category;
}

@Override
public Set&lt;String&gt; getKeys() {
    Set&lt;String&gt; keys = redisTemplate.keys(KEY_PREFIX + "*");
    log.debug("处理【类别】缓存：从缓存中读取所有Key：{}", keys);
    return keys;
}

// ===== 以下是调整原实现代码 =====
@Override
public void clear() {
    Set&lt;String&gt; keys = getKeys();
    for (String key : keys) {
        log.debug("处理【类别】缓存：清除数据，Key={}", key);
        redisTemplate.delete(key);
    }
}</code></pre> 
<p>接下来，在<code>CategoryServiceImpl</code>中修改原有方法的实现细节：</p> 
<blockquote> 
 <pre><code>/**
 * 加载类别数据的缓存
 */
private void loadCache() {
    // 1. 从数据库中读取类别列表
    // 忽略原有代码，增加以下代码
    List&lt;CategoryStandardVO&gt; listDetails = categoryMapper.listDetails();
    // 2. 清除缓存的类别数据
    // 不变
    // 3. 将类别数据写入到缓存
    // 忽略原有代码，增加以下代码
    for (CategoryStandardVO category : listDetails) {
        categoryCacheRepository.setCategory(category);
    }
    // 4. 写入“最近重建缓存”的时间
    // 不变
}

@Override
public CategoryStandardVO getById(Long id) {
    // 改为通过缓存获取数据
    // CategoryStandardVO queryResult = categoryMapper.getById(id);
    CategoryStandardVO queryResult = categoryCacheRepository.getCategoryById(id);
    // 剩余代码不变
}</code></pre> 
 <p></p> 
</blockquote> 
<p>完成后，重启项目，在缓存预热也会写入每个“类别”的缓存，并且，通过ID查询时，也是从缓存中获取的数据。</p> 
<h2>12. 关于缓存穿透</h2> 
<p>当客户端请求某个数据时，还可以使用另一种策略：优先从缓存中获取数据，如果命中缓存，则返回缓存中的数据，如果未命中，则尝试从数据库中查询，如果仍无此数据，则返回<code>null</code>或抛出异常，如果数据库中存在此数据，则将数据写入到缓存，并返回。</p> 
<p>以商品数据为例，这种数据其实是可以入在缓存中的，因为热门商品被访问的频率相对较高，除了库存、销量等数据以外，其它数据基本上短期内不会发生变化，则使用缓存是相对合理的！但是，这种商品数据什么时候写入到缓存？如果是刚刚创建时（将数据写入到数据库时）就同步也写入缓存，但是某商品并不是热销商品，长期存在于缓存中会形成浪费！对于这种数据，通常会采取第1次访问时再写入到缓存的机制。</p> 
<p>所以，可以将<code>CategoryServiceImpl</code>中的策略调整为（暂时使用“类别”数据演示此做法）：</p> 
<pre><code>@Override
public CategoryStandardVO getById(Long id) {
    // 暂定策略：优先从缓存中获取数据
    // 如果命中缓存，则返回缓存中的数据
    // 如果未命中，则尝试从数据库中查询，如果仍无此数据，则返回null或抛出异常
    // 如果数据库中存在此数据，则将数据写入到缓存，并返回
    // CategoryStandardVO queryResult = categoryMapper.getById(id);
    CategoryStandardVO queryResult = categoryCacheRepository.getCategoryById(id);
    if (queryResult == null) {
        CategoryStandardVO categoryInDB = categoryMapper.getById(id);
        if (categoryInDB == null) {
            throw new ServiceException(NOT_FOUND, "查询类别详情失败，尝试访问的数据不存在！");
        } else {
            //设置添加缓存  和设置这个缓存的存在时间
            categoryCacheRepository.setCategory(categoryInDB, 1);
            return categoryInDB;
        }
    } else {
        return queryResult;
    }
}</code></pre> 
<p>上诉添加时间的代码需要在缓存接口中重载 设置类别的代码  加上时间   （） 在再实现类里面实现</p> 
<pre><code>/**
     * 设置详情存在  并设置保持在缓存的时间
     * @param category
     * @param durationInMinute
     */
    void setCategory(CategoryStandardVO category,Integer durationInMinute);</code></pre> 
<pre><code>@Override
    public void setCategory(CategoryStandardVO category, Integer durationInMinute) {
        String key=KEY_PREFIX_ITEM+category.getId();
        log.debug("设置类别详情的id：向缓存中写入Key为【{}】的数据：{}",key,category);
        redisTemplate.opsForValue().set(key,category,durationInMinute, TimeUnit.MINUTES);
    }</code></pre> 
<p><span style="color:#be191c;"><strong>经过以上调整后，将会优先从缓存中获取数据，但是，如果使用一个不存在数据的id值尝试获取数据，就会反复查询数据库，则可能对数据库产生一定的冲击！这种现象称之为：缓存穿透。</strong></span></p> 
<p>关于缓存穿透，最直接的解决方法是：如果未命中缓存，将从数据库中查询数据，即使数据库中也没有匹配的数据，仍会向缓存中写入此id对应的空数据或可以标识为“无”意义的数据，后续，当尝试从缓存中获取数据时，应该先判断获取到的结果是不是空或“无”，再决定后续的处理过程，另外，写入的空或“无”数据应该是在一定时间范围内有限的，过了这段时间将失效！</p> 
<p>使用这种策略解决缓存穿透时，需要：</p> 
<ul><li>添加向缓存中写入<code>null</code>数据的方法</li><li>在业务中，需要增加判断<code>hasKey()</code>的结果</li></ul> 
<p>则在<code>ICategoryCacheRepository</code>中添加：</p> 
<pre><code>/**
 * 写入某个id对应的”类别“的空值，通常用于解决缓存穿透的问题
 *
 * @param id 尝试从缓存中获取的数据的id
 */
void setEmptyValue(Long id);

/**
 * 判断某个id对应的Key是否存在
 *
 * @param id 类别id
 * @return 此id对应的Key是否存在
 */
boolean hasKey(Long id);</code></pre> 
<p>在<code>CategoryCacheRepositoryImpl</code>中实现：</p> 
<pre>@Override
public void setEmptyValue(Long id) {
    String key = KEY_PREFIX_ITEM + id;
    log.debug("处理【类别】缓存：向缓存中写入Key为【{}】的【null】数据：{}", key);
    redisTemplate.opsForValue().set(key, null, 1, TimeUnit.MINUTES);
}

@Override
public boolean hasKey(Long id) {
    String key = KEY_PREFIX_ITEM + id;
    Boolean result = redisTemplate.hasKey(key);
    log.debug("处理【类别】缓存：判断是否存在Key={}的缓存数据，结果为：{}", key, result);
    return result;
}</pre> 
<p>在<code>CategoryServiceImpl</code>中调整<code>getById()</code>的业务逻辑：</p> 
<pre>// 根据id判断缓存中是否存在此Key
// 是：存在，则从缓存中获取数据，并判断是否为null
// -- 是：缓存中数据为null，抛出异常
// -- 否：缓存中存在有效数据，则返回
// 否：不存在，表示缓存中无此数据，则查数据库，判断是否存在此数据
// -- 是：存在，则将此数据写入缓存，并返回
// -- 否：不存在，则向缓存中写入空值，并抛出异常</pre> 
<p>或者：</p> 
<pre>// 根据id从缓存中获取数据，并判断是否不为null
// -- 是：缓存中存在有效数据，则返回

// 判断此Key是否存在
// -- 是：Key存在，却是null，抛出异常

// 查数据库，判断是否存在此数据
// -- 是：存在，则将此数据写入缓存，并返回
// -- 否：不存在，则向缓存中写入空值，并抛出异常</pre> 
<p>最终实现为：</p> 
<pre>@Override
public CategoryStandardVO getById(Long id) {
    // 根据id从缓存中获取数据，并判断是否不为null
    CategoryStandardVO category = categoryCacheRepository.getCategoryById(id);
    if (category != null) {
        // 是：缓存中存在有效数据，则返回
        return category;
    }

    // 判断此Key是否存在
    boolean hasKey = categoryCacheRepository.hasKey(id);
    // 是：Key存在，却是null，抛出异常
    if (hasKey) {
        throw new ServiceException(NOT_FOUND, "获取类别详情失败，尝试访问的数据不存在！");
    }

    // 查数据库，判断是否存在此数据
    CategoryStandardVO categoryInDB = categoryMapper.getById(id);
    if (categoryInDB != null) {
        // 是：存在，则将此数据写入缓存，并返回
        categoryCacheRepository.setCategory(categoryInDB);
        return categoryInDB;
    } else {
        // 否：不存在，则向缓存中写入空值，并抛出异常
        categoryCacheRepository.setEmptyValue(id);
        throw new ServiceException(NOT_FOUND, "获取类别详情失败，尝试访问的数据不存在！");
    }
}</pre> 
<p></p> 
<p></p> 
<hr> 
<hr> 
<h2><br><br><br><br><br><br><br><br><span style="color:#be191c;">问题：：：：———————————————————————————</span></h2> 
<blockquote> 
 <p><img alt="" height="333" src="https://images2.imgbox.com/71/f0/4pgGWFVo_o.png" width="1081"></p> 
 <p> 出现字符码混乱   将yml的代码 复制到记事本 再粘贴回来</p> 
</blockquote> 
<p></p> 
<p></p> 
<hr> 
<hr> 
<h2><span style="color:#be191c;"><strong>数据表设计的字段详解..</strong></span></h2> 
<p>SPU ；</p> 
<p>SKU：</p> 
<p>spu：固定不变的</p> 
<p><img alt="" height="239" src="https://images2.imgbox.com/3b/07/8kxax6hI_o.png" width="244"><img alt="" height="173" src="https://images2.imgbox.com/69/97/857j43Wu_o.png" width="403"></p> 
<p> 一个字段寻存多个属性json格式   但是不规范  所以再加一个属性详情表</p> 
<p>——————————————</p> 
<p>sort：排序   解决各种数据和汉字多音字排序问题。。。。</p> 
<p> ——————————————</p> 
<p><img alt="" height="52" src="https://images2.imgbox.com/32/1f/DzsaneHl_o.png" width="623"></p> 
<p>显示的时候号显示一个大概的值。 </p> 
<p><img alt="" height="64" src="https://images2.imgbox.com/57/6c/n63lxb1X_o.png" width="837"></p> 
<p>分库分表时  自定生产id  会出现id重复的问题，需要使用id生成器 ，将id变唯一。 </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5adf8dd223627599223ea74c63094b6c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">leetCode_242. 有效的字母异位词</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/127c3499ba5abe4ddaeacfc48f0f532f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信小程序 uni.uploadFile/wx.uploadFile一次性上传多个文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>