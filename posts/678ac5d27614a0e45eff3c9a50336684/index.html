<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【网络入门】详解常用的基础网络知识（面试笔试常考内容） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【网络入门】详解常用的基础网络知识（面试笔试常考内容）" />
<meta property="og:description" content="目录 1、概述
2、OSI七层模型和TCP/IP四层模型
3、数据进入TCP/IP协议栈时的封装过程
4、端口的概念
5、TCP建立连接时的三次握手
5.1、TCP头的构成
5.2、三次握手的流程说明
5.3、为什么必须使用三次握手，不能用两次握手去建立连接 5.4、SYN包攻击简介
6、TCP与UDP的区别及使用场景
6.1、TCP与UDP的区别
6.2、TCP与UDP的使用场景
6.3、使用TCP和UDP的常用协议
7、TCP的心跳检测机制与丢包重传机制
7.1、TCP心跳检测机制
7.2、TCP丢包重传机制
8、常用的网络命令
8.1、ping命令
8.2、telnet命令
8.3、ipconfig命令
8.4、netstat命令
8.5、route相关命令
8.6、arp命令
8.7、tracert命令
9、在Linux和Windows两个平台中抓包
9.1、在Windows系统中抓包
9.2、在Linux系统中抓包
10、最后
无论是软件开发人员，还是测试人员，亦或是运维人员，都需要掌握一些常用的基础网络知识，以用于日常网络问题的排查。这些基本的网络知识与概念，不仅日常工作会用到，跳槽时的笔试面试也会用到。本文结合多年来的工作实践，来详细讲述一下作为IT从业人员要掌握的一些基本网络知识。
VC&#43;&#43;常用功能开发汇总（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/124272585C&#43;&#43;软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931C&#43;&#43;软件分析工具案例集锦（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/article/details/131405795C/C&#43;&#43;基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.html
1、概述 当前的应用系统主要分两大类，一类是C/S（Client/Server）客户端/服务器架构的，一类是B/S（Browser/Server）浏览器/服务器架构的。无论是C/S架构，还是B/S架构，客户端都需要和远端的服务器进行网络通信，进行数据交互。不需要进行网络通信的纯单机版的程序已经很少了。
PC上安装的QQ程序，就是典型的C/S架构中的客户端程序，需要和远端的服务器通信，发送和接收数据。通过在浏览器中输入淘宝的网址打开淘宝的主页，就是典型的B/S架构，浏览器通过网址向web服务器请求HTML网页在浏览器中展现出来，也是通过网络和远端的web服务器进行通信。
不仅仅客户端和浏览器需要和远端平台侧的服务器进行网络通信，平台侧部署了多台服务器，比如web服务器、业务服务器、集群服务器、负载均衡服务器，这些服务器之间也要进行网络通信。一旦通过网络进行通信，就会不可避免地出现各种网络问题或网络故障。客户端与远端的服务器之间可能有多台服务器和网路设备，比如DNS服务器、路由器、交换机、集线器等，一旦客户端与服务器之间出现网络问题和数据交互问题，就可能是多个原因引起的，需要逐步地进行排查。
我们这里讲的网络问题主要有两大类，一类是客户端与服务器无法建立连接的问题，一类是建立连接后有网络延时或严重丢包问题。至于建立通信连接后，客户端与服务器之间收发的数据内容不正确等问题，可能和网络有关，也可能是业务上存在的问题导致的。对于客户端无法和服务器建立连接，可能有多种原因，可能是客户端与服务器之间的网络是不通的，也有可能是客户端使用了错误的地址或端口，也有可能服务器侧没有开启监听端口导致的，也有可能是中间的网络设备故障了或者中间网络设备启动了部分安全规则将数据包拦截了。对于网络延时和丢包问题，可能是业务上的问题，也有可能是网络不稳定，也有可能是中间的网络设备拦截数据导致的。
对于网络不稳定的场景，比如一般在家里或公司，我们尽量使用网线连接路由器，即使用有线网络，不使用无线网络。无线网络会因为距离、信号强弱等原因，会出现网络信号弱或网络不稳定，所以走无线网络可能会导致延时或丢包，与服务器频繁断链等问题。
对于网络设备拦截数据包的场景，比如网络环境中的网络设备设置了安全规则，拦截了部分或全部数据包，再比如有些路由器会拦截SIP协议下的TCP包和UDP包。
要排查网络通信过程中遇到的一系列网络问题，需要掌握一些基础的网络知识，了解一些常用的网络命令，必要时要使用wireshark进行抓包分析。接下来我们就来具体地讲解一下这些网络知识以及常用的网络命令。
在这里，给大家重点推荐一下我的两个热门畅销专栏：
专栏1：（该专栏订阅量接近350个，很有实战参考价值，广受好评！）
C&#43;&#43;软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931
本专栏根据近几年C&#43;&#43;软件异常排查的项目实践，系统地总结了引发C&#43;&#43;软件异常的常见原因以及排查C&#43;&#43;软件异常的常用思路与方法，详细讲述了C&#43;&#43;软件的调试方法与手段，以图文并茂的方式给出具体的实战问题分析实例，带领大家逐步掌握C&#43;&#43;软件调试与异常排查的相关技术，适合基础进阶和想做技术提升的相关C&#43;&#43;开发人员！
专栏中的文章都是通过项目实战总结出来的，有很强的实战参考价值！专栏文章还在持续更新中，预计文章篇数能更新到200篇以上！
专栏2： C/C&#43;&#43;基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.html
以多年的开发实战为基础，总结并讲解一些的C/C&#43;&#43;基础与进阶内容，以图文并茂的方式对相关知识点进行详细地展开与阐述！专栏涉及了C/C&#43;&#43;领域的多个方面的内容，同时给出C/C&#43;&#43;及网络方面的常见笔试面试题，并详细讲述Visual Studio常用调试手段与技巧！
2、OSI七层模型和TCP/IP四层模型 OSI七层模型和TCP/IP四层模型的构成，以及它们的对应关系如下所示：
OSI七层模型的全称为开放式系统互联通信参考模型（Open System Interconnection Reference Model），它是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。OSI参考模型分为7层，分别为应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。
TCP/IP的全称为传输控制协议/网际协议（Transmission Control Protocol/Internet Protocol），它是一组用于实现网络互连的通信协议，是构建Internet互联网的基础，Internet网络体系结构是以TCP/IP为核心的。基于TCP/IP的参考模型将协议分成四个层次，分别为应用层、传输层、网络层和物理链路层。也可以将物理链路层拆为两层，一个是数据链路层，一个是物理层，这样TCPIP模型就变成了五层一般我们使用的四层模型。
我们平时使用的都是TCP/IP四层模型。从wireshark中抓到的数据包中能看到每一层的数据信息，如下所示：
3、数据进入TCP/IP协议栈时的封装过程 最上面的应用层的数据，进入TCP/IP协议栈时的封装过程如下：(以TCP数据为例，与TCP/IP四层模型相对应)
经过传输层时，会加上TCP头部；经过网络层时，会加上IP头；经过数据链路层时，会加上以太网头。对于数据接收端，会按照相反的方向，将各层的头部剥离掉，最终到上层的数据就是发送端应用层的数据。
从数据发送到接收端的整个流程，可以用下图来说明（以QQ1给QQ2发一个“你好”的聊天内容为例）：
4、端口的概念 此处讲的端口是TCP或UDP通信中数字端口号，属于传输层的概念，是软件中的端口。端口号用16位整型数据来表示，端口的范围为0-65535。要进行TCP或UDP通信时，除了要有IP，必须要有端口。
操作系统会有很多默认端口，是留给指定的协议使用的，比如21是ftp协议的默认端口，80是http协议的默认端口，443是https协议的默认端口。作为接收客户端连接请求的服务器，可以设定自己的服务端口。
对于TCP，需要先绑定目标端口（调用bind），再开启对目标端口的监听（调用listen），准备接收客户端的请求，如下所示：
对于UDP，是无连接的，只需要绑定端口，不需要开启对端口的监听，如下所示：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/678ac5d27614a0e45eff3c9a50336684/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-17T21:32:48+08:00" />
<meta property="article:modified_time" content="2023-11-17T21:32:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【网络入门】详解常用的基础网络知识（面试笔试常考内容）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong> </p> 
<p id="1%E3%80%81%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%A6%82%E8%BF%B0" rel="nofollow">1、概述</a></p> 
<p id="2%E3%80%81OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8CTCPIP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B-toc" style="margin-left:40px;"><a href="#2%E3%80%81OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8CTCPIP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B" rel="nofollow">2、OSI七层模型和TCP/IP四层模型</a></p> 
<p id="3%E3%80%81%E6%95%B0%E6%8D%AE%E8%BF%9B%E5%85%A5TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%97%B6%E7%9A%84%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E8%BF%9B%E5%85%A5TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%97%B6%E7%9A%84%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B" rel="nofollow">3、数据进入TCP/IP协议栈时的封装过程</a></p> 
<p id="4%E3%80%81%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">4、端口的概念</a></p> 
<p id="5%E3%80%81TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%97%B6%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-toc" style="margin-left:40px;"><a href="#5%E3%80%81TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%97%B6%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B" rel="nofollow">5、TCP建立连接时的三次握手</a></p> 
<p id="5.1%E3%80%81TCP%E5%A4%B4%E7%9A%84%E6%9E%84%E6%88%90-toc" style="margin-left:80px;"><a href="#5.1%E3%80%81TCP%E5%A4%B4%E7%9A%84%E6%9E%84%E6%88%90" rel="nofollow">5.1、TCP头的构成</a></p> 
<p id="5.2%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#5.2%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E" rel="nofollow">5.2、三次握手的流程说明</a></p> 
<p id="5.3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%8D%E8%83%BD%E7%94%A8%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9B%E8%A1%8C%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%C2%A0-toc" style="margin-left:80px;"><a href="#5.3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%8D%E8%83%BD%E7%94%A8%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9B%E8%A1%8C%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%C2%A0" rel="nofollow">5.3、为什么必须使用三次握手，不能用两次握手去建立连接 </a></p> 
<p id="5.4%E3%80%81SYN%E5%8C%85%E6%94%BB%E5%87%BB%E7%AE%80%E4%BB%8B-toc" style="margin-left:80px;"><a href="#5.4%E3%80%81SYN%E5%8C%85%E6%94%BB%E5%87%BB%E7%AE%80%E4%BB%8B" rel="nofollow">5.4、SYN包攻击简介</a></p> 
<p id="6%E3%80%81TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#6%E3%80%81TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">6、TCP与UDP的区别及使用场景</a></p> 
<p id="6.1%E3%80%81TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#6.1%E3%80%81TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">6.1、TCP与UDP的区别</a></p> 
<p id="6.2%E3%80%81TCP%E4%B8%8EUDP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px;"><a href="#6.2%E3%80%81TCP%E4%B8%8EUDP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">6.2、TCP与UDP的使用场景</a></p> 
<p id="6.3%E3%80%81%E4%BD%BF%E7%94%A8TCP%E5%92%8CUDP%E7%9A%84%E5%B8%B8%E7%94%A8%E5%8D%8F%E8%AE%AE-toc" style="margin-left:80px;"><a href="#6.3%E3%80%81%E4%BD%BF%E7%94%A8TCP%E5%92%8CUDP%E7%9A%84%E5%B8%B8%E7%94%A8%E5%8D%8F%E8%AE%AE" rel="nofollow">6.3、使用TCP和UDP的常用协议</a></p> 
<p id="7%E3%80%81TCP%E7%9A%84%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%B8%A2%E5%8C%85%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#7%E3%80%81TCP%E7%9A%84%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%B8%A2%E5%8C%85%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6" rel="nofollow">7、TCP的心跳检测机制与丢包重传机制</a></p> 
<p id="7.1%E3%80%81TCP%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;"><a href="#7.1%E3%80%81TCP%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6" rel="nofollow">7.1、TCP心跳检测机制</a></p> 
<p id="7.2%E3%80%81TCP%E4%B8%A2%E5%8C%85%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;"><a href="#7.2%E3%80%81TCP%E4%B8%A2%E5%8C%85%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6" rel="nofollow">7.2、TCP丢包重传机制</a></p> 
<p id="8%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4-toc" style="margin-left:40px;"><a href="#8%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4" rel="nofollow">8、常用的网络命令</a></p> 
<p id="8.1%E3%80%81ping%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#8.1%E3%80%81ping%E5%91%BD%E4%BB%A4" rel="nofollow">8.1、ping命令</a></p> 
<p id="8.2%E3%80%81telnet%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#8.2%E3%80%81telnet%E5%91%BD%E4%BB%A4" rel="nofollow">8.2、telnet命令</a></p> 
<p id="8.3%E3%80%81ipconfig%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#8.3%E3%80%81ipconfig%E5%91%BD%E4%BB%A4" rel="nofollow">8.3、ipconfig命令</a></p> 
<p id="8.4%E3%80%81netstat%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#8.4%E3%80%81netstat%E5%91%BD%E4%BB%A4" rel="nofollow">8.4、netstat命令</a></p> 
<p id="8.5%E3%80%81route%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#8.5%E3%80%81route%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4" rel="nofollow">8.5、route相关命令</a></p> 
<p id="8.6%E3%80%81arp%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#8.6%E3%80%81arp%E5%91%BD%E4%BB%A4" rel="nofollow">8.6、arp命令</a></p> 
<p id="8.7%E3%80%81traccert%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#8.7%E3%80%81traccert%E5%91%BD%E4%BB%A4" rel="nofollow">8.7、tracert命令</a></p> 
<p id="9%E3%80%81Linux%E5%92%8CWindows%E4%B8%A4%E4%B8%AA%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%8A%93%E5%8C%85-toc" style="margin-left:40px;"><a href="#9%E3%80%81Linux%E5%92%8CWindows%E4%B8%A4%E4%B8%AA%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%8A%93%E5%8C%85" rel="nofollow">9、在Linux和Windows两个平台中抓包</a></p> 
<p id="9.1%E3%80%81Windows%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%8A%93%E5%8C%85-toc" style="margin-left:80px;"><a href="#9.1%E3%80%81Windows%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%8A%93%E5%8C%85" rel="nofollow">9.1、在Windows系统中抓包</a></p> 
<p id="9.2%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E6%8A%93%E5%8C%85-toc" style="margin-left:80px;"><a href="#9.2%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E6%8A%93%E5%8C%85" rel="nofollow">9.2、在Linux系统中抓包</a></p> 
<p id="10%E3%80%81%E6%9C%80%E5%90%8E-toc" style="margin-left:40px;"><a href="#10%E3%80%81%E6%9C%80%E5%90%8E" rel="nofollow">10、最后</a></p> 
<hr id="hr-toc"> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/0d/bd/oa4D0ElY_o.png" width="593"></p> 
<p>       无论是软件开发人员，还是测试人员，亦或是运维人员，都需要掌握一些常用的基础网络知识，以用于日常网络问题的排查。这些基本的网络知识与概念，不仅日常工作会用到，跳槽时的笔试面试也会用到。本文结合多年来的工作实践，来详细讲述一下作为IT从业人员要掌握的一些基本网络知识。</p> 
<p><a class="link-info has-card" href="https://blog.csdn.net/chenlycly/article/details/124272585" title="VC++常用功能开发汇总（专栏文章列表，欢迎订阅，持续更新...）"><span class="link-card-box"><span class="link-title">VC++常用功能开发汇总（专栏文章列表，欢迎订阅，持续更新...）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/f2/63/3yBl21xQ_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/chenlycly/article/details/124272585</span></span></a><a class="link-info has-card" href="https://blog.csdn.net/chenlycly/article/details/125529931" title="C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）"><span class="link-card-box"><span class="link-title">C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/68/6b/7T3atzfp_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/chenlycly/article/details/125529931</span></span></a><a class="link-info has-card" href="https://blog.csdn.net/chenlycly/article/details/131405795" title="C++软件分析工具案例集锦（专栏文章，持续更新中...）"><span class="link-card-box"><span class="link-title">C++软件分析工具案例集锦（专栏文章，持续更新中...）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/e5/5f/PXZanHCB_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/chenlycly/article/details/131405795</span></span></a><a class="link-info has-card" href="https://blog.csdn.net/chenlycly/category_11931267.html" title="C/C++基础与进阶（专栏文章，持续更新中...）"><span class="link-card-box"><span class="link-title">C/C++基础与进阶（专栏文章，持续更新中...）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/07/ea/yB1zM3E7_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/chenlycly/category_11931267.html</span></span></a></p> 
<h3>1、概述</h3> 
<p>       当前的应用系统主要分两大类，一类是<span style="color:#be191c;">C/S（Client/Server）</span><span style="color:#494949;">客户端/服务器架构</span>的，一类是<span style="color:#be191c;">B/S（Browser/Server）</span><span style="color:#494949;">浏览器/服务器架构</span>的。无论是C/S架构，还是B/S架构，客户端都需要和远端的服务器进行网络通信，进行数据交互。不需要进行网络通信的纯单机版的程序已经很少了。</p> 
<blockquote> 
 <p>PC上安装的QQ程序，就是典型的C/S架构中的客户端程序，需要和远端的服务器通信，发送和接收数据。通过在浏览器中输入淘宝的网址打开淘宝的主页，就是典型的B/S架构，浏览器通过网址向web服务器请求HTML网页在浏览器中展现出来，也是通过网络和远端的web服务器进行通信。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="270" src="https://images2.imgbox.com/d6/62/e3w8xdIu_o.png" width="510"></p> 
<p>       不仅仅客户端和浏览器需要和远端平台侧的服务器进行网络通信，平台侧部署了多台服务器，比如web服务器、业务服务器、集群服务器、负载均衡服务器，这些服务器之间也要进行网络通信。<strong><span style="color:#494949;">一旦通过网络进行通信，就会不可避免地出现各种网络问题或网络故障。</span></strong>客户端与远端的服务器之间可能有多台服务器和网路设备，比如<span style="color:#494949;">DNS服务器、路由器、交换机、集线器</span>等，一旦客户端与服务器之间出现网络问题和数据交互问题，就可能是多个原因引起的，需要逐步地进行排查。</p> 
<p>       我们这里讲的网络问题主要有两大类，<span style="color:#494949;"><strong>一类是客户端与服务器无法建立连接的问题，一类是建立连接后有网络延时或严重丢包问题。</strong></span>至于建立通信连接后，客户端与服务器之间收发的数据内容不正确等问题，<span style="color:#494949;">可能和网络有关，也可能是业务上存在的问题导致的。对于客户端无法和服务器建立连接，可能有多种原因，</span><strong><span style="color:#be191c;">可能是客户端与服务器之间的网络是不通的</span><span style="color:#494949;">，</span><span style="color:#be191c;">也有可能是客户端使用了错误的地址或端口</span><span style="color:#494949;">，</span><span style="color:#be191c;">也有可能服务器侧没有开启监听端口导致的</span><span style="color:#494949;">，</span><span style="color:#be191c;">也有可能是中间的网络设备故障了或者中间网络设备启动了部分安全规则将数据包拦截了</span></strong><span style="color:#494949;">。</span>对于网络延时和丢包问题，可能是业务上的问题，也有可能是网络不稳定，也有可能是中间的网络设备拦截数据导致的。</p> 
<p class="img-center"><img alt="" height="339" src="https://images2.imgbox.com/ac/4a/IQVc7fPb_o.png" width="668"></p> 
<p>     <span style="color:#494949;">  <strong>对于网络不稳定的场景</strong></span>，比如一般在家里或公司，我们尽量使用网线连接路由器，即使用有线网络，不使用无线网络。无线网络会因为距离、信号强弱等原因，会出现网络信号弱或网络不稳定，所以走无线网络可能会导致延时或丢包，与服务器频繁断链等问题。</p> 
<p>       <span style="color:#494949;"><strong>对于网络设备拦截数据包的场景</strong></span>，比如网络环境中的网络设备设置了安全规则，拦截了部分或全部数据包，再比如有些路由器会拦截SIP协议下的TCP包和UDP包。</p> 
<p>       要排查网络通信过程中遇到的一系列网络问题，需要掌握一些基础的网络知识，了解一些常用的网络命令，必要时要使用<span style="color:#be191c;">wireshark</span>进行抓包分析。接下来我们就来具体地讲解一下这些网络知识以及常用的网络命令。</p> 
<hr> 
<p>        在这里，给大家<strong><span style="color:#be191c;">重点推荐一下我的两个热门畅销专栏</span>：</strong></p> 
<p><strong><span style="color:#be191c;">专栏1：</span></strong><span style="color:#be191c;">（该专栏订阅量接近350个，很有实战参考价值，广受好评！）</span></p> 
<p><strong><strong><a class="link-info has-card" href="https://blog.csdn.net/chenlycly/article/details/125529931" title="C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）"><span class="link-card-box"><span class="link-title">C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/3c/43/EdOHIBD4_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/chenlycly/article/details/125529931</span></span></a></strong></strong></p> 
<blockquote> 
 <p><span style="color:#0d0016;">本专栏根据近几年C++软件异常排查的项目实践，系统地总结了引发C++软件异常的常见原因以及排查C++软件异常的常用思路与方法，详细讲述了C++软件的调试方法与手段，<strong>以图文并茂的方式给出具体的实战问题分析实例</strong>，带领大家逐步掌握C++软件调试与异常排查的相关技术，适合基础进阶和想做技术提升的相关C++开发人员！</span></p> 
 <p><span style="color:#0d0016;"><strong>专栏中的文章都是通过项目实战总结出来的，有很强的实战参考价值！</strong>专栏文章还在持续更新中，预计文章篇数能更新到200篇以上！</span></p> 
</blockquote> 
<p><strong><span style="color:#be191c;">专栏2</span>： </strong></p> 
<p><a class="link-info has-card" href="https://blog.csdn.net/chenlycly/category_11931267.html" title="C/C++基础与进阶（专栏文章，持续更新中...）"><span class="link-card-box"><span class="link-title">C/C++基础与进阶（专栏文章，持续更新中...）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/cc/a0/ZLMf1Pq8_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/chenlycly/category_11931267.html</span></span></a></p> 
<blockquote> 
 <p><span style="color:#0d0016;">以多年的开发实战为基础，总结并讲解一些的C/C++基础与进阶内容，以图文并茂的方式对相关知识点进行详细地展开与阐述！专栏涉及了C/C++领域的多个方面的内容，同时给出C/C++及网络方面的常见笔试面试题，并详细讲述Visual Studio常用调试手段与技巧！</span></p> 
</blockquote> 
<hr> 
<h3>2、OSI七层模型和TCP/IP四层模型</h3> 
<p>        <span style="color:#be191c;">OSI七层模型</span>和<span style="color:#be191c;">TCP/IP四层模型</span>的构成，以及它们的对应关系如下所示：</p> 
<p class="img-center"><img alt="" height="260" src="https://images2.imgbox.com/58/75/cyVRyoOq_o.png" width="683"></p> 
<p>       OSI七层模型的全称为<span style="color:#494949;">开放式系统互联通信参考模型（Open System Interconnection Reference Model），</span>它是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。<strong><span style="color:#494949;">OSI参考模型分为7层，分别为应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。</span></strong></p> 
<p>       TCP/IP的全称为<span style="color:#494949;">传输控制协议/网际协议（Transmission Control Protocol/Internet Protocol），它是一组用于实现网络互连的通信协议，是构建Internet互联网的基础，Internet网络体系结构是以TCP/IP为核心的。<strong>基于TCP/IP的参考模型将协议分成四个层次，分别为应用层、传输层、网络层和物理链路层。</strong>也可</span>以将物理链路层拆为两层，一个是数据链路层，一个是物理层，这样TCPIP模型就变成了五层一般我们使用的四层模型。</p> 
<p>       我们平时使用的都是TCP/IP四层模型。从wireshark中抓到的数据包中能看到每一层的数据信息，如下所示：</p> 
<p class="img-center"><img alt="" height="422" src="https://images2.imgbox.com/ab/64/aTaJgbJw_o.png" width="683"></p> 
<h3 id="3%E3%80%81%E6%95%B0%E6%8D%AE%E8%BF%9B%E5%85%A5TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%97%B6%E7%9A%84%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B">3、数据进入TCP/IP协议栈时的封装过程</h3> 
<p>       最上面的应用层的数据，进入TCP/IP协议栈时的封装过程如下：(以TCP数据为例，与TCP/IP四层模型相对应)</p> 
<p class="img-center"><img alt="" height="423" src="https://images2.imgbox.com/3f/2e/V18GVEZa_o.png" width="536"></p> 
<p>经过传输层时，会加上<span style="color:#be191c;">TCP头部</span>；经过网络层时，会加上<span style="color:#be191c;">IP头</span>；经过数据链路层时，会加上<span style="color:#be191c;">以太网头</span>。对于数据接收端，会按照相反的方向，将各层的头部剥离掉，最终到上层的数据就是发送端应用层的数据。</p> 
<p>       从数据发送到接收端的整个流程，可以用下图来说明（以QQ1给QQ2发一个“你好”的聊天内容为例）：</p> 
<p class="img-center"><img alt="" height="449" src="https://images2.imgbox.com/f4/70/iqVkMNCK_o.png" width="681"></p> 
<h3 id="4%E3%80%81%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5">4、端口的概念</h3> 
<p style="text-align:center;"><img alt="" height="273" src="https://images2.imgbox.com/91/39/n1mB7cpA_o.png" width="455">       </p> 
<p>       此处讲的端口是TCP或UDP通信中<span style="color:#494949;"><strong>数字端口号</strong></span>，属于传输层的概念，是软件中的端口。端口号用16位整型数据来表示，端口的范围为0-65535。要进行TCP或UDP通信时，除了要有IP，必须要有端口。</p> 
<p>       操作系统会有很多默认端口，是留给指定的协议使用的，比如<strong>21是ftp协议的默认端口</strong>，<strong>80是http协议的默认端口</strong>，<strong>443是https协议的默认端口</strong>。作为接收客户端连接请求的服务器，可以设定自己的服务端口。</p> 
<p>       对于TCP，需要<span style="color:#494949;"><strong>先绑定目标端口（调用bind）</strong></span>，再<strong><span style="color:#494949;">开启对目标端口的监听（调用listen）</span></strong>，准备接收客户端的请求，如下所示：</p> 
<p class="img-center"><img alt="" height="367" src="https://images2.imgbox.com/34/51/U5ZK1739_o.png" width="380"></p> 
<p>       对于UDP，是无连接的，只需要<span style="color:#be191c;">绑定端口</span>，不需要开启对端口的监听，如下所示：</p> 
<p class="img-center"><img alt="" height="325" src="https://images2.imgbox.com/e5/c2/aSeLdT7F_o.png" width="364"></p> 
<p>如果端口已经被绑定了，即端口被占用了，再绑定这个端口会失败，除非设置了端口复用。</p> 
<p>       <span style="color:#494949;"><strong>对于TCP</strong></span>，通信前需要先建立连接，连接发起方向指定的IP和端口发起连接请求；被连接方，必须开启对该端口的监听（程序中调用listen接口开启对目标端口的监听），才能接收别人发来的请求。如果目标端口没有开启监听，是连接不上的。<strong><span style="color:#494949;">对于UDP</span></strong>，是无连接的，直接收发数据也是需要端口的。</p> 
<blockquote> 
 <p><span style="color:#be191c;">有时即使程序开启了端口，可能也连接不上，可能是路由器或者防火墙禁用了该端口，导致发给该端口的数据（包括连接请求）都被拦截了，此时需要在网络环境中放行该端口，即不再拦截与该端口相关的数据。</span>比如在一些安全级别比较高的客户系统中，默认情况下很多端口都是被禁用的，我们需要给客户提供一下软件系统中使用的端口列表（包括客户端和服务器用到的所有端口），需要客户在其网络环境中放行这些端口。只有放行了这些端口，我们的软件系统才能正常的运行。</p> 
</blockquote> 
<p>      <strong><span style="color:#494949;"> 如何判断远端服务器的端口有没有开启监听</span></strong>，有个简单的方法，只要使用Telnet命令去测试即可，比如<span style="color:#be191c;">telnet 192.168.102.176 7800</span>。如果远端的7800端口没有开启监听，就是显示连接失败。如果cmd窗口中提示找不到Telnet，需要到<span style="color:#494949;"><strong>控制面板-&gt;程序与功能-&gt;启用和关闭Windows功能</strong></span>中开启Telnet客户端，如下图所示：</p> 
<p class="img-center"><img alt="" height="467" src="https://images2.imgbox.com/f6/d8/Gsultk0U_o.png" width="685"></p> 
<h3 id="5%E3%80%81TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%97%B6%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">5、TCP建立连接时的三次握手</h3> 
<p>       TCP建立连接时的三次握手是个重要的基础概念，同样也是面试时常问的一个知识点。</p> 
<h4 id="5.1%E3%80%81TCP%E5%A4%B4%E7%9A%84%E6%9E%84%E6%88%90">5.1、TCP头的构成</h4> 
<p>       TCP建立连接的过程就是三次握手的过程，三次握手成功完成，TCP连接就建立了。在看三次握手的完整过程之前，我们先来看一下TCP报文中的TCP头都由哪些部分构成。<span style="color:#be191c;">TCP头的构成</span>如下所示：</p> 
<p class="img-center"><img alt="" height="386" src="https://images2.imgbox.com/51/32/XFTOxt4R_o.png" width="596"></p> 
<p>上图中有几个字段需要重点说明一下：</p> 
<p>1）<span style="color:#494949;"><strong>源端口和目标端口</strong></span>：源端口是该包数据发送者的端口，目标端口是这包数据要发送到的目的端口。</p> 
<p>2）<strong><span style="color:#494949;">（包）序号</span></strong>：当前数据包的包序号Seq序号，占4字节（32bit），用来标识从TCP源端向目的端已经发送了多少字节的数据，发起方发送数据时对此进行标记。包序号的最大值是65535，如果达到最大值，则会从0开始重新计数。</p> 
<p>3）<span style="color:#494949;"><strong>确认号</strong></span>：Ack序号，占4字节（32bit），只有ACK标志位为1时，该确认序号字段才有效。<strong>在TCP中，接收端收到发送端发来的 数据后会给客户端回一个ACK确认包，确认收到数据了，这就是<span style="color:#be191c;">TCP的ACK机制</span></strong>。</p> 
<blockquote> 
 <p>当客户端给服务器发送一包数据时，假设发送该包数据时设置的序号为seq1，本包要发送的数据长度为len1，服务器收到这包数据后，会回给客户端一个ACK包，表示我服务器收到你客户端发来的这包数据了，此ACK包的ACK号等于收到的这包数据的序号seq1，加上收到这包数据的长度len1，该ACK包的ACK号表示我服务器一共收到了你客户端发来的多少字节数据了。注意，这个含义只是一种理解方式，因为包序号达到65535后会再从0开始计数。此外，此处说到的数据长度都是不包含TCP头的数据长度。</p> 
</blockquote> 
<p>4）<span style="color:#494949;"><strong>标志位</strong></span>：<br> 共6个，即URG、ACK、PSH、RST、SYN、FIN等，用来标记该包的类型如下：</p> 
<blockquote> 
 <ul><li>① <strong>URG紧急</strong>：当 URG = 1 时，表明此报文段中有紧急数据，是高优先级的数据，应尽快发送，不用在缓存中排队。</li><li>② <strong>ACK确认</strong>：仅当 ACK = 1 时确认号字段才有效，当 ACK = 0 时确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。</li><li>③ <strong>PSH推送</strong>：接收方收到 PSH = 1 的报文段时，就直接发送给应用进程，而不用等到整个缓冲区都填满了后再向上传送。</li><li>④ <strong>RST复位</strong>：当 RST = 1 时，表明 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。</li><li>⑤ <strong>SYN同步</strong>：SYN = 1 表示这是一个连接请求或连接接受报文。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 且 ACK = 1。</li><li>⑥ <strong>FIN终止</strong>：用来释放一个连接。当 FIN = 1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</li></ul> 
</blockquote> 
<p>       在我们使用wireshark抓包并分析数据包时，可以使用这些标记位作为过滤条件过滤出对应类型的包，比如使用<span style="color:#be191c;">tcp.syn==1</span>过滤出发起三次握手的SYN包，使用<span style="color:#be191c;">tcp.rst==1</span>过滤出RST包。</p> 
<h4 id="5.2%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E">5.2、三次握手的流程说明</h4> 
<p>       TCP三次握手，是指建立一个TCP连接时，客户端和服务器一共发送3个包完成连接的建立。三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号并交换 TCP 窗口大小等信息。在socket编程中，客户端执行connect接口去连接目标IP和端口，触发三次握手。</p> 
<p>       从wireshark的抓包来看，可以看出完整的三次握手的全过程：</p> 
<p class="img-center"><img alt="" height="423" src="https://images2.imgbox.com/10/f8/shSg1fHO_o.png" width="684"></p> 
<p>三次握手的示意图如下：</p> 
<p class="img-center"><img alt="" height="305" src="https://images2.imgbox.com/01/9f/qwgNCbsC_o.png" width="617"></p> 
<p><strong>         第一次握手：</strong></p> 
<p class="img-center"><img alt="" height="206" src="https://images2.imgbox.com/e6/a3/6FiTU3Yj_o.png" width="484"></p> 
<p>客户端发送一个TCP的SYN标志位置1的包，指明客户打算连接的服务器的端口，并将包的序号设置1。</p> 
<p><strong>       第二次握手:</strong></p> 
<p class="img-center"><img alt="" height="207" src="https://images2.imgbox.com/65/71/4IvKyQs7_o.png" width="481"></p> 
<p>服务器收到客户端发来的SYN包，给客户端回ACK确认包，包中的SYN标志位和ACK标志位设置为1，并将ACK确认号设置为1。</p> 
<p><strong>       第三次握手：</strong></p> 
<p class="img-center"><img alt="" height="215" src="https://images2.imgbox.com/73/4c/qa08Un1V_o.png" width="486"></p> 
<p>客户端收到服务器的ACK包，客户端给服务器发送一个ACK确认包，包中的SYN标志位设置为0，ACK标志位设置为1，并把包中的SEQ号设置为1，把ACK号设置为1。</p> 
<blockquote> 
 <p>服务器收到客户端发来的ACK包后，TCP连接建立了，连接就编程了established已建立状态。</p> 
</blockquote> 
<p>       如果三次握手流程没有完成，则连接建立失败，遇到三次握手失败的情况，用wireshark抓包立马便能知道原因。比如有次我们的客户端登录后连不上某个业务服务器，我们第一反应就是先去ping一下该业务服务器地址，结果是能ping通，则说明网络是通的。于是直接使用wireshark抓包，发现当我们给业务服务器发三次握手的SYN包后，<strong><span style="color:#0d0016;">服务器直接回了一个</span><span style="color:#be191c;">RST</span><span style="color:#494949;">包</span></strong>：</p> 
<p class="img-center"><img alt="" height="100" src="https://images2.imgbox.com/17/3d/Mjz5FcRX_o.png" width="697"></p> 
<p>强行将三次握手终止了，可能是业务服务器的端口有问题。经平台侧核实，业务服务器出问题了，无故退出了，这样服务器的端口也就没有处于监听状态，所以就连接不上了。<span style="color:#494949;"><strong>一般三次握手时直接回RST包，都是由端口问题引起的。</strong></span></p> 
<h4 id="5.3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%8D%E8%83%BD%E7%94%A8%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9B%E8%A1%8C%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%C2%A0"><span style="color:#494949;">5.3、为什么必须使用三次握手，不能用两次握手去建立连接 </span></h4> 
<p>       三次握手的好处：</p> 
<blockquote> 
 <ul><li><span style="color:#494949;">① 三次握手目的是确认双方的接收与发送能力是否正常，同步连接双方的初始化序列号 ISN，为后面的可靠性传输做准备。而两次握手只有服务端对客户端的起始序列号做了确认，但客户端却没有对服务端的初始序列号做确认，不能保证传输的可靠性。</span></li><li><span style="color:#494949;">② 三次握手可以防止已失效的连接请求报文段突然又传送到了服务端，导致服务器错误地建立连接，浪费服务端的连接资源。</span></li></ul> 
</blockquote> 
<p><span style="color:#494949;">       如果客户端发出的第一个连接请求报文并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达服务器侧。本来这是一个早已失效的报文，但服务器收到此失效的连接请求报文后：</span></p> 
<blockquote> 
 <ul><li><span style="color:#494949;">① 假设不采用“三次握手”，那么只要Server发出确认，新的连接就建立了。但由于现在Client并没有发出建立连接的请求，因此不会理睬Server的确认，也不会向Server发送数据。而Server却以为新的连接已经建立，并一直等待Client发来数据，这样，Server的很多资源就白白浪费掉了</span></li><li><span style="color:#494949;">② 而采用“三次握手”协议，只要Server收不到来自Client的确认，就知道Client并没有要求建立请求，就不会建立连接了。</span></li></ul> 
</blockquote> 
<h4 id="5.4%E3%80%81SYN%E5%8C%85%E6%94%BB%E5%87%BB%E7%AE%80%E4%BB%8B"><span style="color:#494949;">5.4、SYN包攻击简介</span></h4> 
<p>       <strong>SYN 包攻击是指利用 TCP 需要三次握手的特性，攻击者伪造 SYN 报文向服务器发起连接，服务器在收到报文后用 ACK 应答，但之后攻击者不再对该响应进行应答，造成一个半连接。</strong>假设攻击者发送大量这样的报文，那么被攻击主机就会造成大量的半连接，服务器支持的总的连接数是有限的，最终会导致服务器连接资源耗尽，导致正常的 SYN 请求因为队列满而被丢弃，使得正常用户无法访问。</p> 
<p>       这个问题我们以前遇到过，在一个项目中客户的网络环境比较复杂，其安全系统竟然向我们的业务服务器发SYN包攻击，导致我们的业务服务器无法提供正常的连接服务。</p> 
<p>       服务器侧有一个半连接队列和一个全连接队列。半连接队列是指，服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为半连接队列。对于全连接队列，完成三次握手后建立起的连接就会放在全连接队列中。</p> 
<h3 id="6%E3%80%81TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">6、TCP与UDP的区别及使用场景</h3> 
<p>       这也是面试时经常问到的点，需要搞清楚他们的区别。此处根据日常工作实践，详细地阐述一下这个话题。</p> 
<p class="img-center"><img alt="" height="90" src="https://images2.imgbox.com/60/4b/c6ahnoqH_o.png" width="326"></p> 
<h4 id="6.1%E3%80%81TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB">6.1、TCP与UDP的区别</h4> 
<p><strong>（1）TCP是可靠传输，UDP是不可靠传输 </strong>      </p> 
<p><strong>       TCP是面向连接的，需要建立连接后才能收发数据，TCP在收发数据时有<span style="color:#be191c;">ACK机制</span>，即数据接收方收到数据后会给数据发送方回一个<span style="color:#be191c;">ACK确认包</span>，表示已经收到对方的数据，如果数据发送方没收到ACK包就会触发丢包重传机制，所以<span style="color:#be191c;">TCP是可靠的</span>。</strong>从网络通信的socket套接字编程上看，必须先connect去连ip和端口先建立连接，才能使用send和recv收发数据！对于接收连接的服务端，需要先使用bind函数给socket套接字绑定端口，紧接着调用listen开启端口的监听，然后调用accept接收客户端的连接。</p> 
<p>      <strong> UDP不需要建立连接，可以直接收发数据，没有收发数据的ACK机制，所以<span style="color:#be191c;">UDP通信是不可靠的</span>。</strong>从网络通信的socket套接字编程上看，客户端直接给sendto函数设置ip和端口，不需要建立连接，直接将数据投递过去，不管数据受到与否。对于服务端，只需要使用bind绑定端口，然后调用recvfrom接收数据即可！</p> 
<p><strong>（2）TCP传输的数据是有序的，UDP数据可能是乱序的</strong></p> 
<p>     <strong>  </strong>网络层的ip协议不能保证数据的有序收发，所以数据接收端ip协议层收到的网络数据都可能是乱序的，无论是TCP数据还是UDP数据。<strong>之所以TCP能得到有序的数据，是因为数据到达传输层时TCP协议会将乱序的包按前后顺序重组，即排好顺序后再投递给应用层，所以到应用层经过TCP传输的数据都是有序的。</strong>而UDP协议没有对数据包进行排序，所以经UDP传输的数据到达应用层后还是乱序的，需要应用层自己去排序！</p> 
<p><strong>（3）其他方面的区别</strong></p> 
<p>       此外，TCP和UDP还有一些其他方面的区别：</p> 
<blockquote> 
 <ul><li>TCP首部长度是20个字节，而UDP的首部长度是8个字节，所以TCP数据传输的网络传输开销大一些，UDP数据传输的开销小一些。</li><li>TCP有拥塞控制和流量控制，而UDP没有拥塞控制和流量控制。</li><li>TCP提供全双工通信，但不提供广播或多播服务；UDP则提供广播和多播，所以要广播或多播，都使用UDP。</li></ul> 
</blockquote> 
<h4 id="6.2%E3%80%81TCP%E4%B8%8EUDP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">6.2、TCP与UDP的使用场景</h4> 
<p>      <strong> TCP收发数据时有ACK机制，是<span style="color:#be191c;">可靠的</span>，对要求数据准确无误地发送给对方的场景需要选择TCP，比如<span style="color:#494949;">软件中的控制信令</span></strong>，控制信令要保证准确无误地被投递到目的地。但也正因为接收到数据后每次都要ACK，所以实时性要差一些。</p> 
<p>       <strong>UDP没有数据的ACK，直接发送数据，<span style="color:#be191c;">实时性好</span>，对实时性要求较高且对可靠性要求不太高的场景一般都要选择UDP。</strong>比如通信中的<span style="color:#494949;"><strong>音视频数据</strong></span>，数据量比较大，数据接收端要实时地看到视频听到声音，所以需要保证<strong><span style="color:#494949;">实时性</span></strong>，要有较低的延时，即使有少量的丢包也是没多大问题的，所以音视频数据都是通过UDP来传输的，比如QQ和微信的音视频、视频会议中音视频、直播中的音视频。</p> 
<p>       上面讲述了TCP与UDP区别的关键点，很多同学可以留意一下，下次面试再被问到时一定要说到<span style="color:#494949;"><strong>关键点</strong></span>上！</p> 
<h4 id="6.3%E3%80%81%E4%BD%BF%E7%94%A8TCP%E5%92%8CUDP%E7%9A%84%E5%B8%B8%E7%94%A8%E5%8D%8F%E8%AE%AE">6.3、使用TCP和UDP的常用协议</h4> 
<p>       TCP 是可靠的，能将数据准确无误的传递给对方，一般处理文件传输的HTTP、HTTPS、FTP协议、用于发送和接收邮件的POP3、SMTP等邮件传输协议，使用的都是TCP。对实时性要求高且对可靠性要求低的协议则使用UDP。</p> 
<blockquote> 
 <p>（1）TCP对应的协议：</p> 
 <ul><li>FTP：文件传输协议，默认使用21端口。</li><li>Telnet：远程终端接入，默认使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</li><li>SMTP：邮件传送协议，用于发送邮件，默认使用25端口。</li><li>POP3：邮件传送协议，P用于接收邮件，默认使用110端口。</li><li>HTTP：万维网超文本传输协议，是从Web服务器传输超文本到本地浏览器的传送协议，默认使用80端口。</li></ul> 
 <p>（2）UDP对应的协议：</p> 
 <ul><li>DNS：域名解析服务，将域名地址转换为IP地址，默认使用53号端口。</li><li>SNMP：网络管理协议，用来管理网络设备，默认使用161号端口。</li><li>TFTP：简单文件传输协议，提供不复杂、开销不大的文件传输服务，默认使用 69 端口。</li><li>NFS：远程文件服务器。</li><li>RIP：路由信息协议。</li><li>DHCP：动态主机配置协议。</li><li>IGMP：网际组管理协议。</li></ul> 
</blockquote> 
<h3 id="7%E3%80%81TCP%E7%9A%84%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%B8%A2%E5%8C%85%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">7、TCP的心跳检测机制与丢包重传机制</h3> 
<p>   <span style="color:#494949;"><strong>    TCP心跳检测</strong></span>和<span style="color:#494949;"><strong>丢包重传机制</strong></span>是TCP的两个重要特性，其中丢包重传机制也是保证可靠传输的一种机制。这两种机制都要搞清楚，下面我们就来大概的讲述一下。</p> 
<h4 id="7.1%E3%80%81TCP%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6">7.1、TCP心跳检测机制</h4> 
<p>       TCP心跳检测是通过定时在链路上发<span style="color:#494949;"><strong>心跳包</strong>去</span>保持链路的活性（keepalive），这样链路中的网络设备就不会因为链路上有段时间没有数据在跑，将链路强行断开了。</p> 
<p class="img-center"><img alt="" height="289" src="https://images2.imgbox.com/fb/70/jccUIw8y_o.png" width="513"></p> 
<p>       以上是<strong><span style="color:#494949;">TCP/IP协议栈的心跳机制</span></strong>，有时我们应用层会添加一个<strong><span style="color:#494949;">应用层的心跳检测</span></strong>，比如客户端可以给服务器发心跳包，根据服务器的回应情况来判断服务器是否还活着，客户端和服务器之间的网络是否出现问题，如果心跳检测异常，客户端会主动断开与服务器的连接。</p> 
<p>       大家经常使用的<span style="color:#494949;"><strong>libwebsockets</strong></span>开源库支持设置心跳检测参数，默认情况下是不启用心跳检测的。<span style="color:#494949;"><strong>libwebsockets内部的心跳检测，实际上使用的是TCP/IP协议栈的心跳检测</strong></span>，将心跳检测参数设置给对应的socket，libwebsockets内部相关的接口如下所示：（调用<span style="color:#be191c;">WSAIoctl</span>接口给socket套接字设置心跳参数）</p> 
<pre><code class="language-cpp">LWS_VISIBLE int
lws_plat_set_socket_options(struct lws_vhost *vhost, lws_sockfd_type fd)
{
	int optval = 1;
	int optlen = sizeof(optval);
	u_long optl = 1;
	DWORD dwBytesRet;
	struct tcp_keepalive alive;
	int protonbr;
#ifndef _WIN32_WCE
	struct protoent *tcp_proto;
#endif
 
	if (vhost-&gt;ka_time) {
		/* enable keepalive on this socket */
		// 先调用setsockopt打开发送心跳包（设置）选项
		optval = 1;
		if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE,
					     (const char *)&amp;optval, optlen) &lt; 0)
			return 1;
 
		alive.onoff = TRUE;
		alive.keepalivetime = vhost-&gt;ka_time*1000;
		alive.keepaliveinterval = vhost-&gt;ka_interval*1000;
 
		if (WSAIoctl(fd, SIO_KEEPALIVE_VALS, &amp;alive, sizeof(alive),
					      NULL, 0, &amp;dwBytesRet, NULL, NULL))
			return 1;
	}
 
	/* Disable Nagle */
	optval = 1;
#ifndef _WIN32_WCE
	tcp_proto = getprotobyname("TCP");
	if (!tcp_proto) {
		lwsl_err("getprotobyname() failed with error %d\n", LWS_ERRNO);
		return 1;
	}
	protonbr = tcp_proto-&gt;p_proto;
#else
	protonbr = 6;
#endif
 
	setsockopt(fd, protonbr, TCP_NODELAY, (const char *)&amp;optval, optlen);
 
	/* We are nonblocking... */
	ioctlsocket(fd, FIONBIO, &amp;optl);
 
	return 0;
}</code></pre> 
<h4 id="7.2%E3%80%81TCP%E4%B8%A2%E5%8C%85%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">7.2、TCP丢包重传机制</h4> 
<p>       对于TCP连接，数据发送方将数据发出去后，会启动一个定时器，等待接收端回ACK确认包，如果在指定的时间内没有收到ACK确认包，就会触发TCP的丢包重传机制。如果发送重传包后还是没收到ACK，下一次的重传时间间隔会加倍，<strong><span style="color:#494949;">当重传次数达到系统上限（</span><span style="color:#be191c;">Windows默认的上限是5次，Linux默认的上限是15次</span><span style="color:#494949;">）后，协议栈就认为网络出故障了，协议栈会直接将对应的连接关闭了。          </span></strong></p> 
<p>       所以当网络出现故障时有数据交互，协议栈会在数十秒内检测到网路出现异常，就会直接将连接直接关闭掉。丢包重传机制的详细描述如下所示：</p> 
<p class="img-center"><img alt="" height="613" src="https://images2.imgbox.com/f5/9a/mP5qAwwP_o.png" width="586"></p> 
<p></p> 
<p class="img-center"><img alt="" height="161" src="https://images2.imgbox.com/6c/26/Fgf3eDHi_o.png" width="591"></p> 
<h3 id="8%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4">8、常用的网络命令</h3> 
<p>       这里主要介绍一下Windows系统下一些常用的网络相关命令。Linux系统也有对应的命令，后面会写一篇关于Linux命令文章，此处就不再就Linux系统的命令进行详细展开了。这些命令均是在命令行窗口中执行的，可使用“<span style="color:#be191c;">命令名 /?</span>”去查看命令支持参数和使用上的说明，还会有使用范例。</p> 
<h4 id="8.1%E3%80%81ping%E5%91%BD%E4%BB%A4">8.1、ping命令</h4> 
<p>       当无法连接到远端的地址及端口时，我们最先想到的是，先ping一个远端的地址，看看网络是不是通的，如下：</p> 
<p class="img-center"><img alt="" height="441" src="https://images2.imgbox.com/db/1d/5bRaORC7_o.png" width="681"></p> 
<p>       如果<strong>软件系统在交互的过程中数据出现延时或抖动</strong>，可以在ping指令后面加上一个<span style="color:#be191c;">-t</span>的参数，比如<span style="color:#be191c;">ping 192.168.0.1 -t</span>，查看连续的ping包，看网络是否存在明显的延迟或抖动，如下：</p> 
<p class="img-center"><img alt="" height="442" src="https://images2.imgbox.com/50/8e/7gMkZxc8_o.png" width="681"></p> 
<p>如果要停止持续的ping，按下<span style="color:#be191c;">Ctrl+C</span>组合键就可以终止当前命令的执行。</p> 
<h4 id="8.2%E3%80%81telnet%E5%91%BD%E4%BB%A4">8.2、telnet命令</h4> 
<p>       telnet命令其实对应的是telnet客户端程序（telnet.exe），该程序使用的是telnet协议。telnet协议是TCP/IP协议族中的一员，是远程登陆服务的标准协议和主要方式，它为用户提供了从本地计算机远程登录远程主机的能力。</p> 
<p>       <span style="color:#494949;"><strong>使用该命令可以检查服务器上的端口有没有开启监听</strong></span>，比如telnet 192.168.100.196 7800，如果7800端口没有开启监听，则会提示连接失败。</p> 
<p>       如果远端开启了telnet服务器，可以使用telnet命令远程登录到该telnet服务器上。如果cmd窗口中提示找不到Telnet，需要到<span style="color:#494949;"><strong>控制面板-&gt;程序与功能-&gt;启用和关闭Windows功能中</strong></span>开启Telnet客户端，如下所示：</p> 
<p class="img-center"><img alt="" height="463" src="https://images2.imgbox.com/77/a8/jkfoC8jL_o.png" width="679"></p> 
<h4 id="8.3%E3%80%81ipconfig%E5%91%BD%E4%BB%A4">8.3、ipconfig命令</h4> 
<p>       ipconfig命令主要用来查看网卡的配置信息，比如IP地址，子网掩码和默认网关等，一般使用<span style="color:#be191c;">ipconfig /all</span>，如下所示：</p> 
<p class="img-center"><img alt="" height="450" src="https://images2.imgbox.com/ef/70/XLI6ubXq_o.png" width="678"></p> 
<p>还有比较常用的是<span style="color:#be191c;">ipconfig /flushdns</span>命令，用来清除系统中的DNS缓存：</p> 
<p class="img-center"><img alt="" height="435" src="https://images2.imgbox.com/65/3a/FH2QaM4v_o.png" width="681"></p> 
<p>这样在发起新的域名解析请求时，会向域名服务器上去实时地查询最新的IP。比如某时某个域名对应的IP变更了，但Windows系统DNS缓存中有<span style="color:#be191c;">域名-IP对</span>的记录，导致程序使用的还是老的IP，出现访问失败的问题。所以出现域名访问失败的时候，可以尝试使用<span style="color:#be191c;">ipconfig /flushdns</span>命令刷新系统DNS缓存。</p> 
<p>       <strong>经常有朋友询问使用DNS系统查询IP的完整流程，这里我们普及一下这一过程。</strong>DNS服务器大致分为三种类型：根DNS服务器、顶级域DNS服务器和权威DNS服务器，其中顶级域DNS服务器主要负责诸如com、org、net、edu、gov 等顶级域名。</p> 
<p class="img-center"><img alt="" height="195" src="https://images2.imgbox.com/f1/4e/PQg7kOXr_o.png" width="510"></p> 
<p>      根DNS服务器存储了所有顶级域DNS服务器的 IP 地址，可以通过根服务器找到顶级域服务器，比如百度的域名www.baidu.com，根服务器会返回所有维护 com 这个顶级域服务器的 IP 地址。然后你任选其中一个顶级域服务器发送请求，该顶级域服务器拿到域名后能够给出负责当前域的权威服务器地址。以 百度的域名为例，顶级域服务器将返回所有负责百度这个域的权威服务器地址。接着任选其中一个权威服务器地址查询“www.baidu.com”的具体 IP 地址，最终权威服务器会返回给你具体的 IP 地址。此外，本地 DNS 服务器是具有缓存功能的，通常两天内的记录都会被缓存。</p> 
<p>       所以，通过DNS系统查询域名对应的 IP 的具体步骤可以总结为：</p> 
<blockquote> 
 <ul><li>① 操作系统先查<strong>本地 hosts文件 </strong>中是否有记录，如果有，则直接返回相对应映射的IP地址。</li><li>② 如果本地hosts文件中没有配置，则主机向自己的<strong>本地DNS服务器</strong>发送查询报文，如果本地DNS服务器缓存中有，将直接返回结果。</li><li>③ 如果本地服务器缓存中没有，则从内置在内部的<strong>根DNS服务器</strong>列表（全球13台，固定的IP地址）中选一个发送查询报文。</li><li>④ 根服务器解析域名中的后缀名，告诉本地服务器负责该后缀名的所有<strong>顶级服务器</strong>列表。</li><li>⑤ 本地服务器选择其中一个<strong>顶级域服务器</strong>发送查询请求，顶级域服务器拿到域名后继续解析，返回对应域的所有<strong>权威服务器</strong>列表。</li><li>⑥ 本地服务器再向返回的<strong>权威服务器</strong>发送查询报文，最终会从某一个权威服务器上得到具体的 IP 地址。</li><li>⑦ 主机返回结果IP。</li></ul> 
</blockquote> 
<h4 id="8.4%E3%80%81netstat%E5%91%BD%E4%BB%A4">8.4、netstat命令</h4> 
<p>        netstat命令用来查看本机的网络连接与端口占用情况，如下：</p> 
<p class="img-center"><img alt="" height="450" src="https://images2.imgbox.com/0d/f7/9jofl6Mw_o.png" width="680"></p> 
<p>netstat命令支持多个参数，具体使用<span style="color:#be191c;">netstat /?</span>去查看详细说明：</p> 
<p class="img-center"><img alt="" height="451" src="https://images2.imgbox.com/f4/c7/FpQZV6P7_o.png" width="681"></p> 
<p>这里就不再赘述了。</p> 
<h4 id="8.5%E3%80%81route%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">8.5、route相关命令</h4> 
<p>       route相关命令主要用来查看路由表、添加/删除路由等。首先来看看<span style="color:#be191c;">route print</span>命令，该命令是将Windows系统中的路由表打印出来，如下图所示：</p> 
<p class="img-center"><img alt="" height="453" src="https://images2.imgbox.com/21/d4/Doul57c5_o.png" width="684"></p> 
<p><span style="color:#be191c;">route add</span>命令可以往路由表中添加一条路由，<span style="color:#be191c;">route delete</span>命令可以删除一条路由。命令具体怎么使用可以使用route /?命令查看一下参数的说明以及范例：</p> 
<p class="img-center"><img alt="" height="450" src="https://images2.imgbox.com/6b/cf/LeQCazUn_o.png" width="681"></p> 
<p>       一般在处理Windows系统中的<strong><span style="color:#be191c;">多网卡问题</span></strong>时，会用到这些路由相关的命令。比如以前我们遇到的一个场景，Windows系统中有两张网卡，一张是<span style="color:#be191c;">连接局域网的内网网卡</span>，一张是<span style="color:#be191c;">连接外网的外网网卡</span>：</p> 
<p class="img-center"><img alt="" height="179" src="https://images2.imgbox.com/c7/22/hCoSJrRx_o.png" width="581"></p> 
<p><strong>Windows系统中只能设置一个默认网关</strong>，外网网卡的IP和默认网关是从路由器自动获取的，肯定是有默认网关的，所以内网的网卡不能设置默认网关。如果要通过内网的网卡访问局域网中的地址，则需要使用route add命令添加策略路由来控制ip的访问走向，即通过策略路由让访问内网地址的都走内网的网关。给内网的网卡添加策略路由的命令为：</p> 
<blockquote> 
 <p><strong>route add</strong> 172.16.0.0 mask 255.255.0.0  172.16.30.186（172.16.30.186为内网中的网关）</p> 
</blockquote> 
<p>该命令的含义是，所以访问172.16开头的地址时，都通过内网的网关172.16.30.186走出去。<br> 服务器上一般都会配置多个网卡，有时也会通过添加策略路由去处理服务器之间无法访问的问题，这样的场景我们都遇到过。</p> 
<h4 id="8.6%E3%80%81arp%E5%91%BD%E4%BB%A4">8.6、arp命令</h4> 
<p>       该arp命令主要用来显示和修改地址解析协议(ARP)使用的“IP 到物理”地址转换表：</p> 
<p class="img-center"><img alt="" height="434" src="https://images2.imgbox.com/4f/2d/NlnSJXwh_o.png" width="680"></p> 
<p>系统中会保存IP和MAC地址的映射表。其中<span style="color:#be191c;">ARP协议（Address Resolution Protocol）</span>，是根据IP地址获取物理地址的一个TCP/IP协议。<strong>主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后<span style="color:#494949;">将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源</span>。</strong></p> 
<p>       可以使用<span style="color:#be191c;">arp -a</span>的命令查看系统缓存的映射表，使用<span style="color:#be191c;">arp -s</span>保存一个IP和MAC地址的映射对，使用<span style="color:#be191c;">arp -d</span>删除符合条件的映射对，条件中支持使用通配符，比如：arp -d 192.168.*.*。</p> 
<p>       这里我们详细介绍一下ARP协议，它是根据 IP 地址获取 MAC 地址的一种协议，核心原理就是广播发送ARP请求，单播发送ARP响应。关于ARP相关流程的说明如下：</p> 
<blockquote> 
 <ul><li>① 每个主机都在自己的ARP缓冲区中建立一个ARP列表，以表示 IP 地址和 MAC 地址之间的对应关系。</li><li>② 当源主机要发送数据时，先检查ARP列表中是否有该 IP 地址对应的 MAC 地址，如果有，则直接发送数据；如果没有，就向本网段的所有主机发送ARP数据包，用于查询目的主机的MAC地址，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP。</li><li>③ 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</li><li>④ 源主机收到 ARP 响应包后，将目的主机的 IP 和 MAC 地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li></ul> 
</blockquote> 
<h4 id="8.7%E3%80%81traccert%E5%91%BD%E4%BB%A4">8.7、tracert命令</h4> 
<p>       该命令可以追踪访问目标地址所经历的网络节点，如下所示：</p> 
<p class="img-center"><img alt="" height="452" src="https://images2.imgbox.com/95/ca/83gBo78p_o.png" width="683"></p> 
<p>通过该命令，可以看出数据包是从那个网卡发出去的（看默认网关），也可以看出从哪个运营商线路（联通线路、移动线路、电信线路）访问到目标地址的！</p> 
<h3 id="9%E3%80%81Linux%E5%92%8CWindows%E4%B8%A4%E4%B8%AA%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%8A%93%E5%8C%85">9、在Linux和Windows两个平台中抓包</h3> 
<p>       出现网络问题后，最直接最有效的办法就是抓包，对抓到的网络包进行分析，有时不仅要在客户端抓包，还要在服务器抓包，要综合分析。 服务器一般是运行在Linux系统之上的，所以此处也简单的介绍一下如何在服务器上使用tcpdump命令抓包。</p> 
<h4 id="9.1%E3%80%81Windows%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%8A%93%E5%8C%85">9.1、在Windows系统中抓包</h4> 
<p>       Windows上抓包很简单，只要在系统中安装<span style="color:#be191c;">wireshark</span>即可。启动wireshark后，选择要抓包的那个网卡：</p> 
<p class="img-center"><img alt="" height="418" src="https://images2.imgbox.com/ae/a6/60jYOj7l_o.png" width="681"></p> 
<p>开启抓包即可。抓完包之后，可以将抓包数据保存到文件中。接下来就是分析抓包文件，抓包文件中是抓取了整个网卡的数据包，而我们要分析的是我们软件中的数据包，所以要用过滤条件将要查看的包过滤出来。</p> 
<p>        数据包的过滤条件很讲究，可以使用ip或端口进行过滤，也可以通过协议去过滤，比如如下的一些过滤条件：</p> 
<blockquote> 
 <ul><li>① 用<strong>ip地址</strong>过滤，比如ip.addr==192.168.2.1、ip.src==192.168.2.1、ip.dst==192.168.2.1；</li><li>② 用<strong>端口</strong>来过滤，比如tcp.port==7800、tcp.srcport==7800、tcp.dstport==7800、udp.port==7800;</li><li>③ 使用<strong>协议</strong>过滤，比如tcp、udp、http、websocket、xmpp、rtp等协议名称进行过滤，比如下图：</li></ul> 
</blockquote> 
<p class="img-center"><img alt="" height="420" src="https://images2.imgbox.com/dd/8d/51MP5WVi_o.png" width="683"></p> 
<blockquote> 
 <ul><li>④ 上面我们还说过，可以使用<strong>tcp.syn==1</strong>来过滤三次握手的SYN包；</li><li>⑤  使用<strong>数据包的字符串</strong>来过滤，比如http <strong>contains </strong>"destport"、xmpp <strong>contains </strong>“123”。</li></ul> 
</blockquote> 
<p>具体使用什么过滤条件，要具体问题具体分析吧。</p> 
<h4 id="9.2%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E6%8A%93%E5%8C%85">9.2、在Linux系统中抓包</h4> 
<p class="img-center"><img alt="" height="129" src="https://images2.imgbox.com/65/0d/k78YI8gw_o.png" width="371"></p> 
<p>       服务器中一般使用的是Linux操作系统，比如最常用的是<span style="color:#be191c;">CentOS</span>系统。当然CentOS开发商Red Hat(红帽)公司已经宣布不再对CentOS进行维护更新了，对于大多数国产IT厂商是个很不好的消息。好在华为、阿里和腾讯快速地推出了<span style="color:#be191c;">CentOS的替代服务器操作系统</span>，华为发布了<span style="color:#be191c;">欧拉系统</span>、阿里发布了<span style="color:#be191c;">龙蜥系统</span>、腾讯发布了<span style="color:#be191c;">TencentOS系统</span>，这些服务器操作系统都是在开源的Linux系统演化而来的，也都开源了，大家都可以使用。鉴于华为在鸿蒙手机操作系统上的卓越表现，很多厂商都选择了使用华为的欧拉系统，有的厂商则选择继续使用国外的Linux系统，比如<span style="color:#be191c;">Ubuntu</span>、<span style="color:#be191c;">Debian</span>等。</p> 
<p>       好像扯的有点远了，还是回到本文的主题上来。在Linux上抓包之前，我们需要使用<span style="color:#be191c;">SSH</span>工具远程登录到Linux系统中，登录到Linux系统的命令行上，然后在Linux命令行中使用<span style="color:#be191c;">tcpdump</span>命令启动抓包，比如使用如下的命令：</p> 
<blockquote> 
 <p><strong>tcpdump</strong> <strong>–i</strong> eth1 <strong>–s</strong> 0 <strong>–w</strong> dsvserver.pcap </p> 
</blockquote> 
<p>该命令中使用<span style="color:#be191c;">-i</span>指定在哪个网卡上抓包，eth1是网卡名称，如果要抓所有网卡上的包，则使用-i any；<span style="color:#be191c;">-s</span>指定生成的抓包文件的大小，以字节为单位，0表示不限制；<span style="color:#be191c;">-w</span>指定抓包文件的名称。</p> 
<p>       开启该命令后，服务器上一直在抓包，可以按下<span style="color:#be191c;">Ctrl+C</span>停止抓包命令的执行。然后使用<span style="color:#be191c;">sz</span>命令：</p> 
<blockquote> 
 <p><strong>sz</strong> dsvserver.pcap</p> 
</blockquote> 
<p>将刚才生成的抓包下载到当前的Windows系统中，最后在Windows系统中使用WireShark打开抓包文件分析即可。</p> 
<p class="img-center"><img alt="" height="485" src="https://images2.imgbox.com/56/d5/5TJlaV0Y_o.png" width="523"></p> 
<p>       sz命令（Send ZMODEM）通过ZMODEM协议，可将文件从远程的服务器下载到本地来。比如我们要取日志文件，也可以使用sz命令下载到本地来。关于下载的保存路径，可以在SSH工具的远程连接会话好配置选项中设置，如上图所示。</p> 
<h3 id="10%E3%80%81%E6%9C%80%E5%90%8E">10、最后</h3> 
<p>        上面讲述了一些基础网络知识，作为IT从业人员是要掌握的，不仅工作中会用到，笔试面试也会涉及到的。如果要学习一些进阶网络知识，学习一些实际项目中遇到的网络问题排查，可以查看我之前写的另一篇文章：</p> 
<p><a class="link-info has-card" href="https://blog.csdn.net/chenlycly/article/details/124643918" title="【网络进阶】网络问题排查实例集锦（实战经验分享）"><span class="link-card-box"><span class="link-title">【网络进阶】网络问题排查实例集锦（实战经验分享）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/6b/5b/yYKLjR8r_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/chenlycly/article/details/124643918</span></span></a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8b3f2777b833af86c56ba013182b1c27/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">完美解决 git报错fatal: unable to access ‘https://github.com/.../.git‘:Recv failure Connection was reset</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f8413a33324537fbeb4e3651b630541c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">modbusRTU通信简单实现（使用NModbus4通信库）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>