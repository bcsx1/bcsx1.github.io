<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux spi字符类驱动注册流程spi_register_driver和简单实例 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux spi字符类驱动注册流程spi_register_driver和简单实例" />
<meta property="og:description" content="一、用spi_register_driver函数注册spi驱动。spi的驱动在\kernel\drivers\spi\spi.c
二、这里初始化driver结构的总线类型，然后是调用driver_register注册一个driver，到这里可以回到总线驱动模型的知识，driver_register是所有总线注册一个driver进总线中的统一接口，在学习总线模型的时候知道，在调用driver_register注册一个driver会去遍历总线下的device，并调用总线提供的总线提供的match函数进行匹配，对应的spi总线，它的match函数为：
三、spi_match_device会进行三项比较，任意一项匹配成功则返回1，匹配成功后调用driver的probe函数，就是__spi_register_driver里面的spi_drv_probe函数。 四、spi_drv_probe函数里面会调用spi_driver里面的probe函数。
五，dts里面添加下面的内容就可以完成spi驱动注册了。
/* Firefly SPI demo */ &amp;spi1 { spi_demo: spi-demo@00{ status = &#34;disabled&#34;; compatible = &#34;firefly,rk3399-spi&#34;; reg = &lt;0x00&gt;; spi-max-frequency = &lt;48000000&gt;; /* rk3399 driver support SPI_CPOL | SPI_CPHA | SPI_CS_HIGH */ //spi-cpha; /* SPI mode: CPHA=1 */ //spi-cpol; /* SPI mode: CPOL=1 */ //spi-cs-high; }; }; status:如果要启用 SPI，则设为 okay，如不启用，设为 disable。 spi-demo@00:由于本例子使用 CS0，故此处设为 00，如果使用 CS1，则设为 01。 compatible:这里的属性必须与驱动中的结构体：of_device_id 中的成员 compatible 保持一致。 reg:此处与 spi-demo@00 保持一致，本例设为：0x00。 spi-max-frequency：此处设置 spi 使用的最高频率。Firefly-RK3399 最高支持 48000000。 spi-cpha，spi-cpol：SPI 的工作模式在此设置，本例所用的模块 SPI 工作模式为 SPI_MODE_0 或者 SPI_MODE_3，这里我们选用 SPI_MODE_0，如果使用 SPI_MODE_3，spi_demo 中打开 spi-cpha 和 spi-cpol 即可。 六、spi设备简单示例，读写W25Q128FV。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3166f683b8e3adf530f3b3416e0f937d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-08T16:09:56+08:00" />
<meta property="article:modified_time" content="2022-04-08T16:09:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux spi字符类驱动注册流程spi_register_driver和简单实例</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>一、用spi_register_driver函数注册spi驱动。spi的驱动在\kernel\drivers\spi\spi.c</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/62/54/F3WCZchK_o.png"></p> 
<p></p> 
<p><strong>二、这里初始化driver结构的总线类型，然后是调用driver_register注册一个driver，到这里可以回到总线驱动模型的知识，driver_register是所有总线注册一个driver进总线中的统一接口，在学习总线模型的时候知道，在调用driver_register注册一个driver会去遍历总线下的device，并调用总线提供的总线提供的match函数进行匹配，对应的spi总线，它的match函数为：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c8/f6/Icq9fBfv_o.png"></p> 
<p><strong>三、spi_match_device会进行三项比较，任意一项匹配成功则返回1，匹配成功后调用driver的probe函数，就是__spi_register_driver里面的spi_drv_probe函数。</strong> </p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/ed/a2/4a05bQEv_o.png"></strong></p> 
<p><strong>四、spi_drv_probe函数里面会调用spi_driver里面的probe函数。</strong></p> 
<p><img alt="" src="https://images2.imgbox.com/9b/e2/YCSI0hPm_o.png"></p> 
<p><strong>五，dts里面添加下面的内容就可以完成spi驱动注册了。</strong></p> 
<pre><code>/* Firefly SPI demo */
&amp;spi1 {
       spi_demo: spi-demo@00{
               status = "disabled";
               compatible = "firefly,rk3399-spi";
               reg = &lt;0x00&gt;;
               spi-max-frequency = &lt;48000000&gt;;
               /* rk3399 driver support SPI_CPOL | SPI_CPHA | SPI_CS_HIGH */
               //spi-cpha;             /* SPI mode: CPHA=1 */
               //spi-cpol;     /* SPI mode: CPOL=1 */
               //spi-cs-high;
       };
};
 
 
status:如果要启用 SPI，则设为 okay，如不启用，设为 disable。
 
spi-demo@00:由于本例子使用 CS0，故此处设为 00，如果使用 CS1，则设为 01。
 
compatible:这里的属性必须与驱动中的结构体：of_device_id 中的成员 compatible 保持一致。
 
reg:此处与 spi-demo@00 保持一致，本例设为：0x00。
 
spi-max-frequency：此处设置 spi 使用的最高频率。Firefly-RK3399 最高支持 48000000。
 
spi-cpha，spi-cpol：SPI 的工作模式在此设置，本例所用的模块 SPI 工作模式为 SPI_MODE_0 或者 SPI_MODE_3，这里我们选用 SPI_MODE_0，如果使用 SPI_MODE_3，spi_demo 中打开 spi-cpha 和 spi-cpol 即可。</code></pre> 
<p> </p> 
<p><strong>六、spi设备简单示例，读写W25Q128FV。</strong></p> 
<p>       1、读写 SPI 数据<br>               firefly_spi_probe 中使用了两种接口操作读取 W25Q128FV 的 ID:</p> 
<p>             firefly_spi_read_w25x_id_0 接口直接使用了 spi_transfer 和 spi_message 来传送数据。</p> 
<p>             firefly_spi_read_w25x_id_1 接口则使用 SPI 接口 spi_write_then_read 来读写数据。</p> 
<p>       2、驱动代码</p> 
<pre><code>/*
 * Driver for pwm demo on Firefly board.
 *
 * Copyright (C) 2016, Zhongshan T-chip Intelligent Technology Co.,ltd.
 * Copyright 2006  Sam Chan
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#define DEBUG
#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/err.h&gt;
#include &lt;linux/io.h&gt;
#include &lt;linux/of.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/platform_device.h&gt;
#include &lt;linux/spi/spi.h&gt;
#include &lt;linux/spi/spidev.h&gt;
 
#define FIREFLY_SPI_READ_ID_CMD 0x9F
 
#define FIREFLY_SPI_PRINT_ID(rbuf) \
        do { \
                if (status == 0) \
                        dev_dbg(&amp;spi-&gt;dev, "%s: ID = %02x %02x %02x %02x %02x\n", __FUNCTION__, \
                                rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4]); \
                else \
                        dev_err(&amp;spi-&gt;dev, "%s: read ID error\n", __FUNCTION__); \
        }while(0)
 
static int firefly_spi_read_w25x_id_0(struct spi_device *spi)
{       
        int     status;
        char tbuf[]={FIREFLY_SPI_READ_ID_CMD};
        char rbuf[5];
 
        struct spi_transfer     t = {
                .tx_buf         = tbuf,
                .len            = sizeof(tbuf),
        };
 
        struct spi_transfer     r = {
                .rx_buf         = rbuf,
                .len            = sizeof(rbuf),
        };
        struct spi_message      m;
 
        spi_message_init(&amp;m);
        spi_message_add_tail(&amp;t, &amp;m);
        spi_message_add_tail(&amp;r, &amp;m);
        status = spi_sync(spi, &amp;m);
 
        printk("%s ID = %02x %02x %02x %02x %02x\n", __FUNCTION__, rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4]);
        return status;
}
 
 
static int firefly_spi_read_w25x_id_1(struct spi_device *spi)
{
        int     status;
        char tbuf[] = {FIREFLY_SPI_READ_ID_CMD};
        char rbuf[5];
 
        status = spi_write_then_read(spi, tbuf, sizeof(tbuf), rbuf, sizeof(rbuf));
        printk("%s ID = %02x %02x %02x %02x %02x\n", __FUNCTION__, rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4]);
        return status;
}
 
static int firefly_spi_probe(struct spi_device *spi)
{
    int ret = 0;
    struct device_node __maybe_unused *np = spi-&gt;dev.of_node;
 
    dev_dbg(&amp;spi-&gt;dev, "Firefly SPI demo program\n");
    printk("firefly spi demo\r\n");
        if(!spi)        
                return -ENOMEM;
 
        dev_dbg(&amp;spi-&gt;dev, "firefly_spi_probe: setup mode %d, %s%s%s%s%u bits/w, %u Hz max\n",
                        (int) (spi-&gt;mode &amp; (SPI_CPOL | SPI_CPHA)),
                        (spi-&gt;mode &amp; SPI_CS_HIGH) ? "cs_high, " : "",
                        (spi-&gt;mode &amp; SPI_LSB_FIRST) ? "lsb, " : "",
                        (spi-&gt;mode &amp; SPI_3WIRE) ? "3wire, " : "",
                        (spi-&gt;mode &amp; SPI_LOOP) ? "loopback, " : "",
                        spi-&gt;bits_per_word, spi-&gt;max_speed_hz);
 
        firefly_spi_read_w25x_id_0(spi);
        firefly_spi_read_w25x_id_1(spi);
        
    return ret;
}
 
static int firefly_spi_remove(struct spi_device *spi)
{
    return 0;
}
 
 
static struct of_device_id firefly_match_table[] = {
        { .compatible = "firefly,rk3399-spi",},
        {},
};
 
static struct spi_driver firefly_spi_driver = {
        .driver = {
                .name = "firefly-spi",
                .of_match_table = of_match_ptr(firefly_match_table),
        },
        .probe = firefly_spi_probe,
        .remove = firefly_spi_remove,
};
 
static int firefly_spi_init(void)
{
        int retval;
        retval = spi_register_driver(&amp;firefly_spi_driver);
        printk(KERN_ALERT "register firefly_spi_init spi return v = :%d\n",retval);
        return retval;
}
 
module_init(firefly_spi_init);
 
static void firefly_spi_exit(void)
{
        spi_unregister_driver(&amp;firefly_spi_driver);
}
module_exit(firefly_spi_exit);
 
MODULE_AUTHOR("zhansb &lt;service@t-firefly.com&gt;");
MODULE_DESCRIPTION("Firefly SPI demo driver");
MODULE_ALIAS("platform:firefly-spi");
MODULE_LICENSE("GPL");</code></pre> 
<p><strong>七、Linux 提供了一个功能有限的 SPI 用户接口，如果不需要用到 IRQ 或者其他内核驱动接口，可以考虑使用接口 spidev 编写用户层程序控制 SPI 设备。代码在kernel\drivers\spi\spidev.c。</strong></p> 
<pre><code>/*
 * Simple synchronous userspace interface to SPI devices
 *
 * Copyright (C) 2006 SWAPP
 *	Andrea Paterniani &lt;a.paterniani@swapp-eng.it&gt;
 * Copyright (C) 2007 David Brownell (simplification, cleanup)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
 
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/ioctl.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/err.h&gt;
#include &lt;linux/list.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/compat.h&gt;
#include &lt;linux/of.h&gt;
#include &lt;linux/of_device.h&gt;
 
#include &lt;linux/spi/spi.h&gt;
#include &lt;linux/spi/spidev.h&gt;
 
#include &lt;linux/uaccess.h&gt;
 
 
/*
 * This supports access to SPI devices using normal userspace I/O calls.
 * Note that while traditional UNIX/POSIX I/O semantics are half duplex,
 * and often mask message boundaries, full SPI support requires full duplex
 * transfers.  There are several kinds of internal message boundaries to
 * handle chipselect management and other protocol options.
 *
 * SPI has a character major number assigned.  We allocate minor numbers
 * dynamically using a bitmask.  You must use hotplug tools, such as udev
 * (or mdev with busybox) to create and destroy the /dev/spidevB.C device
 * nodes, since there is no fixed association of minor numbers with any
 * particular SPI bus or device.
 */
#define SPIDEV_MAJOR			153	/* assigned */
#define N_SPI_MINORS			32	/* ... up to 256 */
 
static DECLARE_BITMAP(minors, N_SPI_MINORS);
 
 
/* Bit masks for spi_device.mode management.  Note that incorrect
 * settings for some settings can cause *lots* of trouble for other
 * devices on a shared bus:
 *
 *  - CS_HIGH ... this device will be active when it shouldn't be
 *  - 3WIRE ... when active, it won't behave as it should
 *  - NO_CS ... there will be no explicit message boundaries; this
 *	is completely incompatible with the shared bus model
 *  - READY ... transfers may proceed when they shouldn't.
 *
 * REVISIT should changing those flags be privileged?
 */
#define SPI_MODE_MASK		(SPI_CPHA | SPI_CPOL | SPI_CS_HIGH \
				| SPI_LSB_FIRST | SPI_3WIRE | SPI_LOOP \
				| SPI_NO_CS | SPI_READY | SPI_TX_DUAL \
				| SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD)
 
struct spidev_data {
	dev_t			devt;
	spinlock_t		spi_lock;
	struct spi_device	*spi;
	struct list_head	device_entry;
 
	/* TX/RX buffers are NULL unless this device is open (users &gt; 0) */
	struct mutex		buf_lock;
	unsigned		users;
	u8			*tx_buffer;
	u8			*rx_buffer;
	u32			speed_hz;
};
 
static LIST_HEAD(device_list);
static DEFINE_MUTEX(device_list_lock);
 
static unsigned bufsiz = 4096;
module_param(bufsiz, uint, S_IRUGO);
MODULE_PARM_DESC(bufsiz, "data bytes in biggest supported SPI message");
 
/*-------------------------------------------------------------------------*/
 
static ssize_t
spidev_sync(struct spidev_data *spidev, struct spi_message *message)
{
	DECLARE_COMPLETION_ONSTACK(done);
	int status;
	struct spi_device *spi;
 
	spin_lock_irq(&amp;spidev-&gt;spi_lock);
	spi = spidev-&gt;spi;
	spin_unlock_irq(&amp;spidev-&gt;spi_lock);
 
	if (spi == NULL)
		status = -ESHUTDOWN;
	else
		status = spi_sync(spi, message);
 
	if (status == 0)
		status = message-&gt;actual_length;
 
	return status;
}
 
static inline ssize_t
spidev_sync_write(struct spidev_data *spidev, size_t len)
{
	struct spi_transfer	t = {
			.tx_buf		= spidev-&gt;tx_buffer,
			.len		= len,
			.speed_hz	= spidev-&gt;speed_hz,
		};
	struct spi_message	m;
 
	spi_message_init(&amp;m);
	spi_message_add_tail(&amp;t, &amp;m);
	return spidev_sync(spidev, &amp;m);
}
 
static inline ssize_t
spidev_sync_read(struct spidev_data *spidev, size_t len)
{
	struct spi_transfer	t = {
			.rx_buf		= spidev-&gt;rx_buffer,
			.len		= len,
			.speed_hz	= spidev-&gt;speed_hz,
		};
	struct spi_message	m;
 
	spi_message_init(&amp;m);
	spi_message_add_tail(&amp;t, &amp;m);
	return spidev_sync(spidev, &amp;m);
}
 
/*-------------------------------------------------------------------------*/
 
/* Read-only message with current device setup */
static ssize_t
spidev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
	struct spidev_data	*spidev;
	ssize_t			status = 0;
 
	/* chipselect only toggles at start or end of operation */
	if (count &gt; bufsiz)
		return -EMSGSIZE;
 
	spidev = filp-&gt;private_data;
 
	mutex_lock(&amp;spidev-&gt;buf_lock);
	status = spidev_sync_read(spidev, count);
	if (status &gt; 0) {
		unsigned long	missing;
 
		missing = copy_to_user(buf, spidev-&gt;rx_buffer, status);
		if (missing == status)
			status = -EFAULT;
		else
			status = status - missing;
	}
	mutex_unlock(&amp;spidev-&gt;buf_lock);
 
	return status;
}
 
/* Write-only message with current device setup */
static ssize_t
spidev_write(struct file *filp, const char __user *buf,
		size_t count, loff_t *f_pos)
{
	struct spidev_data	*spidev;
	ssize_t			status = 0;
	unsigned long		missing;
 
	/* chipselect only toggles at start or end of operation */
	if (count &gt; bufsiz)
		return -EMSGSIZE;
 
	spidev = filp-&gt;private_data;
 
	mutex_lock(&amp;spidev-&gt;buf_lock);
	missing = copy_from_user(spidev-&gt;tx_buffer, buf, count);
	if (missing == 0)
		status = spidev_sync_write(spidev, count);
	else
		status = -EFAULT;
	mutex_unlock(&amp;spidev-&gt;buf_lock);
 
	return status;
}
 
static int spidev_message(struct spidev_data *spidev,
		struct spi_ioc_transfer *u_xfers, unsigned n_xfers)
{
	struct spi_message	msg;
	struct spi_transfer	*k_xfers;
	struct spi_transfer	*k_tmp;
	struct spi_ioc_transfer *u_tmp;
	unsigned		n, total, tx_total, rx_total;
	u8			*tx_buf, *rx_buf;
	int			status = -EFAULT;
 
	spi_message_init(&amp;msg);
	k_xfers = kcalloc(n_xfers, sizeof(*k_tmp), GFP_KERNEL);
	if (k_xfers == NULL)
		return -ENOMEM;
 
	/* Construct spi_message, copying any tx data to bounce buffer.
	 * We walk the array of user-provided transfers, using each one
	 * to initialize a kernel version of the same transfer.
	 */
	tx_buf = spidev-&gt;tx_buffer;
	rx_buf = spidev-&gt;rx_buffer;
	total = 0;
	tx_total = 0;
	rx_total = 0;
	for (n = n_xfers, k_tmp = k_xfers, u_tmp = u_xfers;
			n;
			n--, k_tmp++, u_tmp++) {
		k_tmp-&gt;len = u_tmp-&gt;len;
 
		total += k_tmp-&gt;len;
		/* Since the function returns the total length of transfers
		 * on success, restrict the total to positive int values to
		 * avoid the return value looking like an error.  Also check
		 * each transfer length to avoid arithmetic overflow.
		 */
		if (total &gt; INT_MAX || k_tmp-&gt;len &gt; INT_MAX) {
			status = -EMSGSIZE;
			goto done;
		}
 
		if (u_tmp-&gt;rx_buf) {
			/* this transfer needs space in RX bounce buffer */
			rx_total += k_tmp-&gt;len;
			if (rx_total &gt; bufsiz) {
				status = -EMSGSIZE;
				goto done;
			}
			k_tmp-&gt;rx_buf = rx_buf;
			if (!access_ok(VERIFY_WRITE, (u8 __user *)
						(uintptr_t) u_tmp-&gt;rx_buf,
						u_tmp-&gt;len))
				goto done;
			rx_buf += k_tmp-&gt;len;
		}
		if (u_tmp-&gt;tx_buf) {
			/* this transfer needs space in TX bounce buffer */
			tx_total += k_tmp-&gt;len;
			if (tx_total &gt; bufsiz) {
				status = -EMSGSIZE;
				goto done;
			}
			k_tmp-&gt;tx_buf = tx_buf;
			if (copy_from_user(tx_buf, (const u8 __user *)
						(uintptr_t) u_tmp-&gt;tx_buf,
					u_tmp-&gt;len))
				goto done;
			tx_buf += k_tmp-&gt;len;
		}
 
		k_tmp-&gt;cs_change = !!u_tmp-&gt;cs_change;
		k_tmp-&gt;tx_nbits = u_tmp-&gt;tx_nbits;
		k_tmp-&gt;rx_nbits = u_tmp-&gt;rx_nbits;
		k_tmp-&gt;bits_per_word = u_tmp-&gt;bits_per_word;
		k_tmp-&gt;delay_usecs = u_tmp-&gt;delay_usecs;
		k_tmp-&gt;speed_hz = u_tmp-&gt;speed_hz;
		if (!k_tmp-&gt;speed_hz)
			k_tmp-&gt;speed_hz = spidev-&gt;speed_hz;
#ifdef VERBOSE
		dev_dbg(&amp;spidev-&gt;spi-&gt;dev,
			"  xfer len %zd %s%s%s%dbits %u usec %uHz\n",
			u_tmp-&gt;len,
			u_tmp-&gt;rx_buf ? "rx " : "",
			u_tmp-&gt;tx_buf ? "tx " : "",
			u_tmp-&gt;cs_change ? "cs " : "",
			u_tmp-&gt;bits_per_word ? : spidev-&gt;spi-&gt;bits_per_word,
			u_tmp-&gt;delay_usecs,
			u_tmp-&gt;speed_hz ? : spidev-&gt;spi-&gt;max_speed_hz);
#endif
		spi_message_add_tail(k_tmp, &amp;msg);
	}
 
	status = spidev_sync(spidev, &amp;msg);
	if (status &lt; 0)
		goto done;
 
	/* copy any rx data out of bounce buffer */
	rx_buf = spidev-&gt;rx_buffer;
	for (n = n_xfers, u_tmp = u_xfers; n; n--, u_tmp++) {
		if (u_tmp-&gt;rx_buf) {
			if (__copy_to_user((u8 __user *)
					(uintptr_t) u_tmp-&gt;rx_buf, rx_buf,
					u_tmp-&gt;len)) {
				status = -EFAULT;
				goto done;
			}
			rx_buf += u_tmp-&gt;len;
		}
	}
	status = total;
 
done:
	kfree(k_xfers);
	return status;
}
 
static struct spi_ioc_transfer *
spidev_get_ioc_message(unsigned int cmd, struct spi_ioc_transfer __user *u_ioc,
		unsigned *n_ioc)
{
	struct spi_ioc_transfer	*ioc;
	u32	tmp;
 
	/* Check type, command number and direction */
	if (_IOC_TYPE(cmd) != SPI_IOC_MAGIC
			|| _IOC_NR(cmd) != _IOC_NR(SPI_IOC_MESSAGE(0))
			|| _IOC_DIR(cmd) != _IOC_WRITE)
		return ERR_PTR(-ENOTTY);
 
	tmp = _IOC_SIZE(cmd);
	if ((tmp % sizeof(struct spi_ioc_transfer)) != 0)
		return ERR_PTR(-EINVAL);
	*n_ioc = tmp / sizeof(struct spi_ioc_transfer);
	if (*n_ioc == 0)
		return NULL;
 
	/* copy into scratch area */
	ioc = kmalloc(tmp, GFP_KERNEL);
	if (!ioc)
		return ERR_PTR(-ENOMEM);
	if (__copy_from_user(ioc, u_ioc, tmp)) {
		kfree(ioc);
		return ERR_PTR(-EFAULT);
	}
	return ioc;
}
 
static long
spidev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	int			err = 0;
	int			retval = 0;
	struct spidev_data	*spidev;
	struct spi_device	*spi;
	u32			tmp;
	unsigned		n_ioc;
	struct spi_ioc_transfer	*ioc;
 
	/* Check type and command number */
	if (_IOC_TYPE(cmd) != SPI_IOC_MAGIC)
		return -ENOTTY;
 
	/* Check access direction once here; don't repeat below.
	 * IOC_DIR is from the user perspective, while access_ok is
	 * from the kernel perspective; so they look reversed.
	 */
	if (_IOC_DIR(cmd) &amp; _IOC_READ)
		err = !access_ok(VERIFY_WRITE,
				(void __user *)arg, _IOC_SIZE(cmd));
	if (err == 0 &amp;&amp; _IOC_DIR(cmd) &amp; _IOC_WRITE)
		err = !access_ok(VERIFY_READ,
				(void __user *)arg, _IOC_SIZE(cmd));
	if (err)
		return -EFAULT;
 
	/* guard against device removal before, or while,
	 * we issue this ioctl.
	 */
	spidev = filp-&gt;private_data;
	spin_lock_irq(&amp;spidev-&gt;spi_lock);
	spi = spi_dev_get(spidev-&gt;spi);
	spin_unlock_irq(&amp;spidev-&gt;spi_lock);
 
	if (spi == NULL)
		return -ESHUTDOWN;
 
	/* use the buffer lock here for triple duty:
	 *  - prevent I/O (from us) so calling spi_setup() is safe;
	 *  - prevent concurrent SPI_IOC_WR_* from morphing
	 *    data fields while SPI_IOC_RD_* reads them;
	 *  - SPI_IOC_MESSAGE needs the buffer locked "normally".
	 */
	mutex_lock(&amp;spidev-&gt;buf_lock);
 
	switch (cmd) {
	/* read requests */
	case SPI_IOC_RD_MODE:
		retval = __put_user(spi-&gt;mode &amp; SPI_MODE_MASK,
					(__u8 __user *)arg);
		break;
	case SPI_IOC_RD_MODE32:
		retval = __put_user(spi-&gt;mode &amp; SPI_MODE_MASK,
					(__u32 __user *)arg);
		break;
	case SPI_IOC_RD_LSB_FIRST:
		retval = __put_user((spi-&gt;mode &amp; SPI_LSB_FIRST) ?  1 : 0,
					(__u8 __user *)arg);
		break;
	case SPI_IOC_RD_BITS_PER_WORD:
		retval = __put_user(spi-&gt;bits_per_word, (__u8 __user *)arg);
		break;
	case SPI_IOC_RD_MAX_SPEED_HZ:
		retval = __put_user(spidev-&gt;speed_hz, (__u32 __user *)arg);
		break;
 
	/* write requests */
	case SPI_IOC_WR_MODE:
	case SPI_IOC_WR_MODE32:
		if (cmd == SPI_IOC_WR_MODE)
			retval = __get_user(tmp, (u8 __user *)arg);
		else
			retval = __get_user(tmp, (u32 __user *)arg);
		if (retval == 0) {
			u32	save = spi-&gt;mode;
 
			if (tmp &amp; ~SPI_MODE_MASK) {
				retval = -EINVAL;
				break;
			}
 
			tmp |= spi-&gt;mode &amp; ~SPI_MODE_MASK;
			spi-&gt;mode = (u16)tmp;
			retval = spi_setup(spi);
			if (retval &lt; 0)
				spi-&gt;mode = save;
			else
				dev_dbg(&amp;spi-&gt;dev, "spi mode %x\n", tmp);
		}
		break;
	case SPI_IOC_WR_LSB_FIRST:
		retval = __get_user(tmp, (__u8 __user *)arg);
		if (retval == 0) {
			u32	save = spi-&gt;mode;
 
			if (tmp)
				spi-&gt;mode |= SPI_LSB_FIRST;
			else
				spi-&gt;mode &amp;= ~SPI_LSB_FIRST;
			retval = spi_setup(spi);
			if (retval &lt; 0)
				spi-&gt;mode = save;
			else
				dev_dbg(&amp;spi-&gt;dev, "%csb first\n",
						tmp ? 'l' : 'm');
		}
		break;
	case SPI_IOC_WR_BITS_PER_WORD:
		retval = __get_user(tmp, (__u8 __user *)arg);
		if (retval == 0) {
			u8	save = spi-&gt;bits_per_word;
 
			spi-&gt;bits_per_word = tmp;
			retval = spi_setup(spi);
			if (retval &lt; 0)
				spi-&gt;bits_per_word = save;
			else
				dev_dbg(&amp;spi-&gt;dev, "%d bits per word\n", tmp);
		}
		break;
	case SPI_IOC_WR_MAX_SPEED_HZ:
		retval = __get_user(tmp, (__u32 __user *)arg);
		if (retval == 0) {
			u32	save = spi-&gt;max_speed_hz;
 
			spi-&gt;max_speed_hz = tmp;
			retval = spi_setup(spi);
			if (retval &gt;= 0)
				spidev-&gt;speed_hz = tmp;
			else
				dev_dbg(&amp;spi-&gt;dev, "%d Hz (max)\n", tmp);
			spi-&gt;max_speed_hz = save;
		}
		break;
 
	default:
		/* segmented and/or full-duplex I/O request */
		/* Check message and copy into scratch area */
		ioc = spidev_get_ioc_message(cmd,
				(struct spi_ioc_transfer __user *)arg, &amp;n_ioc);
		if (IS_ERR(ioc)) {
			retval = PTR_ERR(ioc);
			break;
		}
		if (!ioc)
			break;	/* n_ioc is also 0 */
 
		/* translate to spi_message, execute */
		retval = spidev_message(spidev, ioc, n_ioc);
		kfree(ioc);
		break;
	}
 
	mutex_unlock(&amp;spidev-&gt;buf_lock);
	spi_dev_put(spi);
	return retval;
}
 
#ifdef CONFIG_COMPAT
static long
spidev_compat_ioc_message(struct file *filp, unsigned int cmd,
		unsigned long arg)
{
	struct spi_ioc_transfer __user	*u_ioc;
	int				retval = 0;
	struct spidev_data		*spidev;
	struct spi_device		*spi;
	unsigned			n_ioc, n;
	struct spi_ioc_transfer		*ioc;
 
	u_ioc = (struct spi_ioc_transfer __user *) compat_ptr(arg);
	if (!access_ok(VERIFY_READ, u_ioc, _IOC_SIZE(cmd)))
		return -EFAULT;
 
	/* guard against device removal before, or while,
	 * we issue this ioctl.
	 */
	spidev = filp-&gt;private_data;
	spin_lock_irq(&amp;spidev-&gt;spi_lock);
	spi = spi_dev_get(spidev-&gt;spi);
	spin_unlock_irq(&amp;spidev-&gt;spi_lock);
 
	if (spi == NULL)
		return -ESHUTDOWN;
 
	/* SPI_IOC_MESSAGE needs the buffer locked "normally" */
	mutex_lock(&amp;spidev-&gt;buf_lock);
 
	/* Check message and copy into scratch area */
	ioc = spidev_get_ioc_message(cmd, u_ioc, &amp;n_ioc);
	if (IS_ERR(ioc)) {
		retval = PTR_ERR(ioc);
		goto done;
	}
	if (!ioc)
		goto done;	/* n_ioc is also 0 */
 
	/* Convert buffer pointers */
	for (n = 0; n &lt; n_ioc; n++) {
		ioc[n].rx_buf = (uintptr_t) compat_ptr(ioc[n].rx_buf);
		ioc[n].tx_buf = (uintptr_t) compat_ptr(ioc[n].tx_buf);
	}
 
	/* translate to spi_message, execute */
	retval = spidev_message(spidev, ioc, n_ioc);
	kfree(ioc);
 
done:
	mutex_unlock(&amp;spidev-&gt;buf_lock);
	spi_dev_put(spi);
	return retval;
}
 
static long
spidev_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	if (_IOC_TYPE(cmd) == SPI_IOC_MAGIC
			&amp;&amp; _IOC_NR(cmd) == _IOC_NR(SPI_IOC_MESSAGE(0))
			&amp;&amp; _IOC_DIR(cmd) == _IOC_WRITE)
		return spidev_compat_ioc_message(filp, cmd, arg);
 
	return spidev_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));
}
#else
#define spidev_compat_ioctl NULL
#endif /* CONFIG_COMPAT */
 
static int spidev_open(struct inode *inode, struct file *filp)
{
	struct spidev_data	*spidev;
	int			status = -ENXIO;
 
	mutex_lock(&amp;device_list_lock);
 
	list_for_each_entry(spidev, &amp;device_list, device_entry) {
		if (spidev-&gt;devt == inode-&gt;i_rdev) {
			status = 0;
			break;
		}
	}
 
	if (status) {
		pr_debug("spidev: nothing for minor %d\n", iminor(inode));
		goto err_find_dev;
	}
 
	if (!spidev-&gt;tx_buffer) {
		spidev-&gt;tx_buffer = kmalloc(bufsiz, GFP_KERNEL);
		if (!spidev-&gt;tx_buffer) {
			dev_dbg(&amp;spidev-&gt;spi-&gt;dev, "open/ENOMEM\n");
			status = -ENOMEM;
			goto err_find_dev;
		}
	}
 
	if (!spidev-&gt;rx_buffer) {
		spidev-&gt;rx_buffer = kmalloc(bufsiz, GFP_KERNEL);
		if (!spidev-&gt;rx_buffer) {
			dev_dbg(&amp;spidev-&gt;spi-&gt;dev, "open/ENOMEM\n");
			status = -ENOMEM;
			goto err_alloc_rx_buf;
		}
	}
 
	spidev-&gt;users++;
	filp-&gt;private_data = spidev;
	nonseekable_open(inode, filp);
 
	mutex_unlock(&amp;device_list_lock);
	return 0;
 
err_alloc_rx_buf:
	kfree(spidev-&gt;tx_buffer);
	spidev-&gt;tx_buffer = NULL;
err_find_dev:
	mutex_unlock(&amp;device_list_lock);
	return status;
}
 
static int spidev_release(struct inode *inode, struct file *filp)
{
	struct spidev_data	*spidev;
 
	mutex_lock(&amp;device_list_lock);
	spidev = filp-&gt;private_data;
	filp-&gt;private_data = NULL;
 
	/* last close? */
	spidev-&gt;users--;
	if (!spidev-&gt;users) {
		int		dofree;
 
		kfree(spidev-&gt;tx_buffer);
		spidev-&gt;tx_buffer = NULL;
 
		kfree(spidev-&gt;rx_buffer);
		spidev-&gt;rx_buffer = NULL;
 
		spin_lock_irq(&amp;spidev-&gt;spi_lock);
		if (spidev-&gt;spi)
			spidev-&gt;speed_hz = spidev-&gt;spi-&gt;max_speed_hz;
 
		/* ... after we unbound from the underlying device? */
		dofree = (spidev-&gt;spi == NULL);
		spin_unlock_irq(&amp;spidev-&gt;spi_lock);
 
		if (dofree)
			kfree(spidev);
	}
	mutex_unlock(&amp;device_list_lock);
 
	return 0;
}
 
static const struct file_operations spidev_fops = {
	.owner =	THIS_MODULE,
	/* REVISIT switch to aio primitives, so that userspace
	 * gets more complete API coverage.  It'll simplify things
	 * too, except for the locking.
	 */
	.write =	spidev_write,
	.read =		spidev_read,
	.unlocked_ioctl = spidev_ioctl,
	.compat_ioctl = spidev_compat_ioctl,
	.open =		spidev_open,
	.release =	spidev_release,
	.llseek =	no_llseek,
};
 
/*-------------------------------------------------------------------------*/
 
/* The main reason to have this class is to make mdev/udev create the
 * /dev/spidevB.C character device nodes exposing our userspace API.
 * It also simplifies memory management.
 */
 
static struct class *spidev_class;
 
#ifdef CONFIG_OF
static const struct of_device_id spidev_dt_ids[] = {
	{ .compatible = "rohm,dh2228fv" },
	{ .compatible = "lineartechnology,ltc2488" },
	{ .compatible = "rockchip,spidev" },
	{},
};
MODULE_DEVICE_TABLE(of, spidev_dt_ids);
#endif
 
/*-------------------------------------------------------------------------*/
 
static int spidev_probe(struct spi_device *spi)
{
	struct spidev_data	*spidev;
	int			status;
	unsigned long		minor;
 
	/*
	 * spidev should never be referenced in DT without a specific
	 * compatible string, it is a Linux implementation thing
	 * rather than a description of the hardware.
	 */
	if (spi-&gt;dev.of_node &amp;&amp; !of_match_device(spidev_dt_ids, &amp;spi-&gt;dev)) {
		dev_err(&amp;spi-&gt;dev, "buggy DT: spidev listed directly in DT\n");
		WARN_ON(spi-&gt;dev.of_node &amp;&amp;
			!of_match_device(spidev_dt_ids, &amp;spi-&gt;dev));
	}
 
	/* Allocate driver data */
	spidev = kzalloc(sizeof(*spidev), GFP_KERNEL);
	if (!spidev)
		return -ENOMEM;
 
	/* Initialize the driver data */
	spidev-&gt;spi = spi;
	spin_lock_init(&amp;spidev-&gt;spi_lock);
	mutex_init(&amp;spidev-&gt;buf_lock);
 
	INIT_LIST_HEAD(&amp;spidev-&gt;device_entry);
 
	/* If we can allocate a minor number, hook up this device.
	 * Reusing minors is fine so long as udev or mdev is working.
	 */
	mutex_lock(&amp;device_list_lock);
	minor = find_first_zero_bit(minors, N_SPI_MINORS);
	if (minor &lt; N_SPI_MINORS) {
		struct device *dev;
 
		spidev-&gt;devt = MKDEV(SPIDEV_MAJOR, minor);
		dev = device_create(spidev_class, &amp;spi-&gt;dev, spidev-&gt;devt,
				    spidev, "spidev%d.%d",
				    spi-&gt;master-&gt;bus_num, spi-&gt;chip_select);
		status = PTR_ERR_OR_ZERO(dev);
	} else {
		dev_dbg(&amp;spi-&gt;dev, "no minor number available!\n");
		status = -ENODEV;
	}
	if (status == 0) {
		set_bit(minor, minors);
		list_add(&amp;spidev-&gt;device_entry, &amp;device_list);
	}
	mutex_unlock(&amp;device_list_lock);
 
	spidev-&gt;speed_hz = spi-&gt;max_speed_hz;
 
	if (status == 0)
		spi_set_drvdata(spi, spidev);
	else
		kfree(spidev);
 
	return status;
}
 
static int spidev_remove(struct spi_device *spi)
{
	struct spidev_data	*spidev = spi_get_drvdata(spi);
 
	/* make sure ops on existing fds can abort cleanly */
	spin_lock_irq(&amp;spidev-&gt;spi_lock);
	spidev-&gt;spi = NULL;
	spin_unlock_irq(&amp;spidev-&gt;spi_lock);
 
	/* prevent new opens */
	mutex_lock(&amp;device_list_lock);
	list_del(&amp;spidev-&gt;device_entry);
	device_destroy(spidev_class, spidev-&gt;devt);
	clear_bit(MINOR(spidev-&gt;devt), minors);
	if (spidev-&gt;users == 0)
		kfree(spidev);
	mutex_unlock(&amp;device_list_lock);
 
	return 0;
}
 
static struct spi_driver spidev_spi_driver = {
	.driver = {
		.name =		"spidev",
		.of_match_table = of_match_ptr(spidev_dt_ids),
	},
	.probe =	spidev_probe,
	.remove =	spidev_remove,
 
	/* NOTE:  suspend/resume methods are not necessary here.
	 * We don't do anything except pass the requests to/from
	 * the underlying controller.  The refrigerator handles
	 * most issues; the controller driver handles the rest.
	 */
};
 
/*-------------------------------------------------------------------------*/
 
static int __init spidev_init(void)
{
	int status;
 
	/* Claim our 256 reserved device numbers.  Then register a class
	 * that will key udev/mdev to add/remove /dev nodes.  Last, register
	 * the driver which manages those device numbers.
	 */
	BUILD_BUG_ON(N_SPI_MINORS &gt; 256);
	status = register_chrdev(SPIDEV_MAJOR, "spi", &amp;spidev_fops);
	if (status &lt; 0)
		return status;
 
	spidev_class = class_create(THIS_MODULE, "spidev");
	if (IS_ERR(spidev_class)) {
		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);
		return PTR_ERR(spidev_class);
	}
 
	status = spi_register_driver(&amp;spidev_spi_driver);
	if (status &lt; 0) {
		class_destroy(spidev_class);
		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);
	}
	return status;
}
module_init(spidev_init);
 
static void __exit spidev_exit(void)
{
	spi_unregister_driver(&amp;spidev_spi_driver);
	class_destroy(spidev_class);
	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);
}
module_exit(spidev_exit);
 
MODULE_AUTHOR("Andrea Paterniani, &lt;a.paterniani@swapp-eng.it&gt;");
MODULE_DESCRIPTION("User mode SPI device interface");
MODULE_LICENSE("GPL");
MODULE_ALIAS("spi:spidev");</code></pre> 
<p></p> 
<p>————————————————<br> 版权声明：本文为CSDN博主「海月汐辰」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/qq_37858386/article/details/119756871</p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/711a4ce4fc1b8c367bc6e86cebfdd16c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">阻塞IO与非阻塞IO的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e221478114f388157a4e2d70f0921c98/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Halcon图像拼接-算法速度优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>