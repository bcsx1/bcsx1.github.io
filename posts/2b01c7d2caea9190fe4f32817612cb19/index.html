<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;11标准库(第二版)笔记整理 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;11标准库(第二版)笔记整理" />
<meta property="og:description" content="1.C&#43;&#43;编译环境的组成：
C语言兼容库：头文件带.h，是C&#43;&#43;编译器提供商为推广自己的产品，而提供的C兼容库（不是C&#43;&#43;标准库提供的），内置的C库。C&#43;&#43;标准库：如string cstdio(注意不带.h)是C&#43;&#43;标准库提供的。使用时要用using namespace std编译器扩展库：这是针对不同的编译器而独有扩展，例如g&#43;&#43;和vc&#43;&#43;,他们在这一板块就不同。C&#43;&#43;标准库语法模块：C&#43;&#43;标准语法的支持C&#43;&#43;扩展语法模块：同样是针对不同的编译器而独有的扩展语法 2.C&#43;&#43;标准库
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-U2lveYxw-1646271445999)(F:\C&#43;&#43;\C&#43;&#43;库\image-20220301092740399.png)]
(1)流输入/输出
iostream：支持标准流cin、cout、cerr和clog的输入和输出，还支持多字节字符标准流wcin、wcout、wcerr和wclog。
iomanip：提供操纵程序，允许改变流的状态，从而改变输出的格式。
ios：定义iostream的基类。
istream：为管理输出流缓存区的输入定义模板类。
ostream：为管理输出流缓存区的输出定义模板类。
sstream：支持字符串的流输入输出。
fstream：支持文件的流输入输出。
iosfwd：为输入输出对象提供向前的声明。
streambuf：支持流输入和输出的缓存。
cstdio：为标准流提供C样式的输入和输出。
cwchar：支持多字节字符的C样式输入输出。
(2)数值操作
complex：支持复杂数值的定义和操作。
valarray：支持数值矢量的操作。
numeric：在数值序列上定义一组一般数学操作，例如accumulate和inner_product。
cmath：这是C数学库，其中还附加了重载函数，以支持C&#43;&#43;约定。
cstdlib：提供的函数可以提取整数的绝对值，对整数进行取余数操作
(3)诊断功能
stdexcept：定义标准异常。
cassert：定义断言宏，用于运行时检查。
cerrno：支持C样式的错误信息
(4)语言支持功能
cstddef：定义宏NULL和offsetof以及其它标准类型size_t和ptrdiff_t。与对应的标准C头文件的区别是，NULL是C&#43;&#43;空指针常量的补充定义(C&#43;&#43;11中已有关键字nullptr），宏offsetof接受结构或者联合类型参数，只要没有成员指针类型的非静态成员即可。
limits：提供与基本数据类型相关的定义。例如，对于每个数值数据类型，它定义了可以表示出来的最大值和最小值以及二进制数字的位数。
climits：提供与基本整数数据类型相关的C样式定义，C&#43;&#43;样式定义在中。
：提供与基本浮点型数据类型相关的C样式定义，C&#43;&#43;样式定义在limits中。
cstdlib：提供支持程序启动和终止的宏和函数，还声明了许多其他杂项函数，例如搜索和排序函数，从字符串转换为数值等函数。cstdlib与对应的标准C头文件stdlib.h不同，定义了abort(void)。abort()函数还有额外的功能，它不为静态或自动对象调用析构函数，也不调用传给atexit()函数的函数。它还定义了exit()函数的额外功能，可以释放静态对象，以注册的逆序调用用atexit()注册的函数。清除并关闭所有打开的C流，把控制权返回给主机环境。
new：支持动态内存分配。
typeinfo：支持变量在运行期间的类型标识。
exception：支持异常处理，是处理程序中可能发生的错误的一种方式。
cstdarg：支持接受数量可变的参数的函数。即在调用函数时，可以给函数传送数量不等的数据项。定义了宏va_arg、va_end、va_start以及va_list类型。
csetjmp：为C样式的非本地跳跃提供函数，在C&#43;&#43;中不常用。
csignal：为中断处理提供C样式支持。
(5)字符串处理
string：为字符串类型提供支持和定义，包括单字节字符串(由char组成)的string和多字节字符串(由wchar_t组成)。
cctype：单字节字符类别。
cwctype：多字节字符类别。
cstring：为处理非空字节序列和内存块提供函数。不同于对应的标准C库头文件，C样式字符串的一般C库函数被返回值为const和非const的函数对替代。
cwchar：为处理、执行I/O和转换多字节字符序列提供函数，不同于对应的标准C库头文件，几个多字节C样式字符串操作的一般C库函数被返回值为const和非const的函数对替代。
cstdlib：为把单字节字符串转换为数值、在多字节字符和多字节字符串之间转换提供函数。
(6)容器类模板
vector：定义vector序列模板，是一个大小可以重新设置的数组类型，比普通数组更安全、更灵活。
list：定义list序列模板，是一个序列的链表，常常在任意位置插入和删除元素。
deque：定义deque序列模板，支持在开始和结尾的高效插入和删除操作。
queue：为队列(先进先出)数据结构定义序列适配器queue和priority_queue。
stack：为堆栈(后进先出)数据结构定义序列适配器stack。
map: map是一个关联容器类型，允许根据键值是唯一的，且按照升序存储。multimap类似于map，但键不是唯一的。
set：set是一个关联容器类型，用于以升序方式存储唯一值。multiset类似于set，但是值不必是唯一的。
bitset：为固定长度的位序列定义bitset模板，它可以看作固定长度的紧凑型bool数组。
array：（TR1）固定大小数组，支持复制。
forward_list：（c&#43;&#43;11）单向列表，支持快速随机访问。
unordered_set：（TR1)无序容器set，其元素随机存放。multiset类似于set，但是值不必是唯一的。
unordered_map：（TR1)无序容器map，其键值随机存放。multimap类似于map，但键不是唯一的
(7)迭代器
iterator:给迭代器提供定义和支持
(8)算法
algorithm：提供一组基于算法的函数，包括置换、排序、合并和搜索。
cstdlib：声明C标准库函数bsearch()和qsort()，进行搜索和排序。
ciso646：允许在代码中使用and代替&amp;&amp;
3.C&#43;&#43;标准库" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2b01c7d2caea9190fe4f32817612cb19/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-03T09:43:06+08:00" />
<meta property="article:modified_time" content="2022-03-03T09:43:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;11标准库(第二版)笔记整理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>1.C++编译环境的组成：</p> 
<p><img src="https://images2.imgbox.com/cb/18/MknJTAto_o.png" alt="img"></p> 
<ul><li>C语言兼容库：头文件带.h，是C++编译器<strong>提供商</strong>为推广自己的产品，而提供的<strong>C兼容库</strong>（<strong>不是C++标准库</strong>提供的），<strong>内置的C库</strong>。</li><li>C++标准库：如string cstdio(注意不带.h)是C++标准库提供的。使用时要用using namespace std</li><li>编译器扩展库：这是针对不同的编译器而独有扩展，例如g++和vc++,他们在这一板块就不同。</li><li>C++标准库语法模块：C++标准语法的支持</li><li>C++扩展语法模块：同样是针对不同的编译器而独有的扩展语法</li></ul> 
<p>2.C++标准库</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-U2lveYxw-1646271445999)(F:\C++\C++库\image-20220301092740399.png)]</p> 
<p>(1)流输入/输出</p> 
<p>iostream：支持标准流cin、cout、cerr和clog的输入和输出，还支持多字节字符标准流wcin、wcout、wcerr和wclog。<br> iomanip：提供操纵程序，允许改变流的状态，从而改变输出的格式。<br> ios：定义iostream的基类。<br> istream：为管理输出流缓存区的输入定义模板类。<br> ostream：为管理输出流缓存区的输出定义模板类。<br> sstream：支持字符串的流输入输出。<br> fstream：支持文件的流输入输出。<br> iosfwd：为输入输出对象提供向前的声明。<br> streambuf：支持流输入和输出的缓存。<br> cstdio：为标准流提供C样式的输入和输出。<br> cwchar：支持多字节字符的C样式输入输出。<br> (2)数值操作</p> 
<p>complex：支持复杂数值的定义和操作。<br> valarray：支持数值矢量的操作。<br> numeric：在数值序列上定义一组一般数学操作，例如accumulate和inner_product。<br> cmath：这是C数学库，其中还附加了重载函数，以支持C++约定。<br> cstdlib：提供的函数可以提取整数的绝对值，对整数进行取余数操作<br> (3)诊断功能</p> 
<p>stdexcept：定义标准异常。<br> cassert：定义断言宏，用于运行时检查。<br> cerrno：支持C样式的错误信息</p> 
<p>(4)语言支持功能</p> 
<p>cstddef：定义宏NULL和offsetof以及其它标准类型size_t和ptrdiff_t。与对应的标准C头文件的区别是，NULL是C++空指针常量的补充定义(C++11中已有关键字nullptr），宏offsetof接受结构或者联合类型参数，只要没有成员指针类型的非静态成员即可。<br> limits：提供与基本数据类型相关的定义。例如，对于每个数值数据类型，它定义了可以表示出来的最大值和最小值以及二进制数字的位数。<br> climits：提供与基本整数数据类型相关的C样式定义，C++样式定义在中。<br> ：提供与基本浮点型数据类型相关的C样式定义，C++样式定义在limits中。<br> cstdlib：提供支持程序启动和终止的宏和函数，还声明了许多其他杂项函数，例如搜索和排序函数，从字符串转换为数值等函数。cstdlib与对应的标准C头文件stdlib.h不同，定义了abort(void)。abort()函数还有额外的功能，它不为静态或自动对象调用析构函数，也不调用传给atexit()函数的函数。它还定义了exit()函数的额外功能，可以释放静态对象，以注册的逆序调用用atexit()注册的函数。清除并关闭所有打开的C流，把控制权返回给主机环境。<br> new：支持动态内存分配。<br> typeinfo：支持变量在运行期间的类型标识。<br> exception：支持异常处理，是处理程序中可能发生的错误的一种方式。<br> cstdarg：支持接受数量可变的参数的函数。即在调用函数时，可以给函数传送数量不等的数据项。定义了宏va_arg、va_end、va_start以及va_list类型。<br> csetjmp：为C样式的非本地跳跃提供函数，在C++中不常用。<br> csignal：为中断处理提供C样式支持。<br> (5)字符串处理</p> 
<p>string：为字符串类型提供支持和定义，包括单字节字符串(由char组成)的string和多字节字符串(由wchar_t组成)。<br> cctype：单字节字符类别。<br> cwctype：多字节字符类别。<br> cstring：为处理非空字节序列和内存块提供函数。不同于对应的标准C库头文件，C样式字符串的一般C库函数被返回值为const和非const的函数对替代。<br> cwchar：为处理、执行I/O和转换多字节字符序列提供函数，不同于对应的标准C库头文件，几个多字节C样式字符串操作的一般C库函数被返回值为const和非const的函数对替代。<br> cstdlib：为把单字节字符串转换为数值、在多字节字符和多字节字符串之间转换提供函数。</p> 
<p>(6)容器类模板</p> 
<p>vector：定义vector序列模板，是一个大小可以重新设置的数组类型，比普通数组更安全、更灵活。<br> list：定义list序列模板，是一个序列的链表，常常在任意位置插入和删除元素。<br> deque：定义deque序列模板，支持在开始和结尾的高效插入和删除操作。<br> queue：为队列(先进先出)数据结构定义序列适配器queue和priority_queue。<br> stack：为堆栈(后进先出)数据结构定义序列适配器stack。</p> 
<p>map: map是一个关联容器类型，允许根据键值是唯一的，且按照升序存储。multimap类似于map，但键不是唯一的。</p> 
<p>set：set是一个关联容器类型，用于以升序方式存储唯一值。multiset类似于set，但是值不必是唯一的。<br> bitset：为固定长度的位序列定义bitset模板，它可以看作固定长度的紧凑型bool数组。<br> array：（TR1）固定大小数组，支持复制。<br> forward_list：（c++11）单向列表，支持快速随机访问。<br> unordered_set：（TR1)无序容器set，其元素随机存放。multiset类似于set，但是值不必是唯一的。<br> unordered_map：（TR1)无序容器map，其键值随机存放。multimap类似于map，但键不是唯一的</p> 
<p>(7)迭代器</p> 
<p>iterator:给迭代器提供定义和支持</p> 
<p>(8)算法</p> 
<p>algorithm：提供一组基于算法的函数，包括置换、排序、合并和搜索。<br> cstdlib：声明C标准库函数bsearch()和qsort()，进行搜索和排序。<br> ciso646：允许在代码中使用and代替&amp;&amp;</p> 
<p>3.C++标准库</p> 
<p>C++标准库可以分为两部分：</p> 
<ul><li>标准函数库：这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自C语言</li><li>面向对象类库：这个库是类及其相关函数的集合</li></ul> 
<p>C++标准库包含了所有的C标准库，为了支持类型安全，做了一定的添加和修改。</p> 
<p><strong>标准函数库：</strong></p> 
<p>标准函数库分为以下几类：输入/输出IO 、字符串和字符处理、数学、时间 日期和本地化、动态分配、其他、宽字符函数</p> 
<p><strong>面向对象类库：</strong></p> 
<p>标准的C++面向对象类库定义了大量支持一些常见操作的类，比如输入/输出I/O、字符串处理、数值处理。面向对象类库包括以下内容：</p> 
<p>标准的C++ I/O类、String类、数值类、STL容器类、STL算法、STL函数对象、STL迭代器、STL分配器、本地化库、异常处理类、杂项支持库</p> 
<h3><a id="3__111"></a>第3章 语言新特性</h3> 
<p><strong>3.1 C++11语言新特性</strong></p> 
<p><strong>1.微小但重要的语法提升</strong></p> 
<p>Template表达式内的空格</p> 
<p>“在两个template表达式的闭符之间放一个空格”的要求已经过时了：</p> 
<pre><code class="prism language-c++">vector&lt;list&lt;int&gt; &gt;;			//OK in each C++ version
vector&lt;list&lt;int&gt;&gt;;			//OK since C++11
</code></pre> 
<p>nullptr和std::nullptr_t</p> 
<p>C++11允许你使用nullptr取代0或NULL，用来表示一个pointer指向所谓的no value（此不同于拥有一个不确定值）。这个新特性特别能够帮助你在“null pointer被解释为一个整数值”时避免误解。</p> 
<pre><code class="prism language-C++">void f(int);
void f(void*);
f(0);        //calls f(int)
f(NULL);    //calls f(int) if NULL is 0,ambiguous otherwise
f(nullptr);//calls f(void*)
</code></pre> 
<p>nullptr是个新关键字。<strong>它被自动转换为各种pointer类型，但不会被转换为任何整数类型。</strong></p> 
<p><strong>2.以auto完成类型自动推导</strong></p> 
<p>C++11允许你声明一个变量或对象(object)不需要指明其类型，只需说它是auto</p> 
<pre><code class="prism language-c++">auto i = 42;		//i has type int
double f();
auto d = f();		//d has type double
</code></pre> 
<p>以auto声明的变量，其类型会根据其初值被自动推导出来，因此一定需要一个初始化操作：</p> 
<pre><code class="prism language-c++">auto i ;			//ERROR:can't deduce the type of i
</code></pre> 
<p>可为它加上额外的限定符：</p> 
<pre><code class="prism language-c++">static auto var = 0.19;
</code></pre> 
<p>如果类型很长或表达式很复杂，auto特别有用：</p> 
<pre><code class="prism language-c++">vector&lt;string&gt; v;
auto pos = v.begin();		//pos ha type vector&lt;string&gt;::iterator
auto lam = [](int x) -&gt; bool {	//lam has the type of a lambda
    ...,					//taking an int and returning a bool
};
</code></pre> 
<p><strong>3.一致性初始化(Uniform Initializaion)与初值列(Initializer List)</strong></p> 
<p><strong>4.Range-Based for循环</strong></p> 
<p>C++11引入一个崭新的for循环形式，可以逐一迭代某个给定的区间、数组、集合内的每一个元素。</p> 
<p>一般性语法：</p> 
<pre><code class="prism language-C++">for(decl : coll){
    statement
}
for(int i: {1,3,5,7,9,11.13}){
    cout&lt;&lt;i&lt;&lt;endl;
}
</code></pre> 
<p>如果要将vector vec的每个元素elem乘以3：</p> 
<pre><code class="prism language-C++">vector&lt;double&gt; vec;
for( auto &amp;elem : vec){
    elem *= 3;
    cout&lt;&lt;elem&lt;&lt;endl;
}
</code></pre> 
<p><strong>5.Move语义和Rvalue Reference</strong></p> 
<p>C++11的一个重要的特性就是，支持move semantic(搬迁语义)。这项特性更进一步进入了C++主要涉及目标内，用以避免非必要拷贝(copy)和临时对象(temporary)。</p> 
<p>新特性的出现是为了解决现有的问题或不足之处，move的出现为了解决某些场景下深拷贝的效率问题。</p> 
<p><strong>6.关键字noexcept</strong></p> 
<p>C++11提供了关键字noexcept，用来指明某个函数无法—或不打算—抛出异常</p> 
<pre><code class="prism language-C++">void foo() noexcept;		//声明了foo()不打算抛出异常。
</code></pre> 
<p>若有异常未在foo()内被处理—亦即如果foo()抛出异常—程序会被终止，然后std::terminate()被调用并默认调用std::abort()</p> 
<p>你甚至可以指明在某种条件下函数不抛出异常。</p> 
<pre><code class="prism language-C++">void swap(Type&amp; x,Type&amp; y) noexcept(noexcept(x.swap(y)))
{
    x.swap(y);
}
</code></pre> 
<p>在noexcept()中你可以指定一个Boolean条件，若符号就抛出异常</p> 
<p><strong>7.关键字constexpr</strong></p> 
<p><strong>constexpr常量表达式，常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。</strong></p> 
<p>自C++11起，constexpr可用来让表达式核定于编译器</p> 
<pre><code class="prism language-C++">constexpr int square(int x)
{
	return x*x;
}
</code></pre> 
<p>constexpr表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。声明为constexpr的变量一定是一个const变量，而且必须用常量表达式初始化</p> 
<p><strong>8.崭新的Template特性</strong></p> 
<p>Variadic Template:自C++11起，template可拥有那种“得以接受个数不定之template实参”的参数。此能力称为variadic template.</p> 
<pre><code class="prism language-c++">void print()
{

}
template&lt;typename T,typename... Types&gt;
void print(const T&amp; firstArg,const Types&amp;... args)
{
    cout&lt;&lt;firstArg&lt;&lt;endl;   //print first argument
    print(args...);         //call print() for remaining arguments

}

void test01()
{
    print(7.5,"hello",bitset&lt;16&gt;(32),42);
}

</code></pre> 
<p><strong>9.Alias Template(带别名的模板，或者叫Template Typedef)</strong></p> 
<p>自C++11起，支持template(partial) type definiation</p> 
<pre><code class="prism language-C++">template &lt;typename T&gt;

using Vec = vector&lt;T,MyAlloc&lt;T&gt;&gt;;	//standard vector using own allocator
Vec&lt;int&gt; coll;
// 等价于
vector&lt;int,MyAlloc&lt;int&gt;&gt; coll;
</code></pre> 
<p><strong>10.Lambda</strong></p> 
<pre><code class="prism language-C++">int x = 0;
int y = 42;
auto qqq = [x,&amp;y]{
    cout&lt;&lt;"x: "&lt;&lt;x&lt;&lt;endl;
    cout&lt;&lt;"y: "&lt;&lt;y&lt;&lt;endl;
    ++y;    //OK
};
x = y = 77;
qqq();
qqq();
cout&lt;&lt;"final y: "&lt;&lt;y&lt;&lt;endl;
</code></pre> 
<pre><code class="prism language-c++">int id = 0;
auto f = [id]() mutable{
    cout&lt;&lt;"id:"&lt;&lt;id&lt;&lt;endl;
   	++id;       //OK
};
id = 42;
f();
f();
f();
cout&lt;&lt;id&lt;&lt;endl;

//可以把上述lambda的行为视同下面这个function object
class {
private:
    int id;      //copy of outside id
public:
     void operator()(){
         cout&lt;&lt;"id:"&lt;&lt;id&lt;&lt;endl;
         ++id;   //OK
     }
};
</code></pre> 
<p><strong>11.关键字decltype</strong></p> 
<p>decltype类型说明符，它的作用是选择返回操作数的数据类型,它的出现主要是解决复杂的类型声明。decltype并不会实际计算表达式的值，编译器分析表达式并得到它的类型。</p> 
<pre><code class="prism language-C++">//sum的类型是函数f返回的类型
decltype(f()) sum = x;
</code></pre> 
<p><strong>3.2 虽旧犹新的语言特性</strong></p> 
<p>Default Template Parameter(模板参数默认值)</p> 
<p>Class template可以拥有默认实参。例如下面的声明式允许我们在声明class MyClass对象时指定1或2个template实参。</p> 
<pre><code class="prism language-C++">template&lt;typename T,typename container = vector&lt;T&gt;&gt;
class MyClass;
</code></pre> 
<p>如果你只传入一个实参，第二实参会采用默认值：</p> 
<pre><code class="prism language-C++">MyClass&lt;int&gt; x1;//equivalent to:MyClass&lt;int,vector&lt;int&gt;&gt;
</code></pre> 
<h3><a id="4__352"></a>第4章 一般概念</h3> 
<h4><a id="41_Namespace_std_354"></a>4.1 命名空间Namespace std</h4> 
<p>当你采用不同的模板或程序库时，经常会出现名称冲突现象，这是因为不同的模板和程序库可能对不同的对象使用相同的标识符(identifier)。Namespace正是用来解决这个问题的。所谓Namespace是指标识符的某种可见范围。</p> 
<h4><a id="44_Callable_Object_358"></a>4.4 Callable Object(可被调用的对象)</h4> 
<p>Callable Object“可被某种方式调用其某些函数”的对象。它可以是：</p> 
<ul><li>一个函数，接受额外传入的args作为实参(argument)</li><li>一个指向成员函数的指针(a pointer to a member function)，当你通过对象调用它，该对象被传递称为第一个实参(必须是个reference或pointer)，其他实参则一一对应成员函数的实参。</li><li>一个函数对象(function object,该对象拥有operator())，附带的args被传递作为实参。</li><li>一个lambda，严格地说它是一种函数对象</li></ul> 
<pre><code class="prism language-c++">void func(int x,int y);
auto l = [](int x,int y){

};
class C{
    public:
        void operator()(int x,int y) const;
        void memfunc(int x,int y) const;
};

void test01()
{
    C c;
    shared_ptr&lt;C&gt; sp(new C);
    //bind() use callable objects to bind arguments
    bind(func,77,33)();
    bind(l,77,33)();
    bind(C(),77,33)();
    bind(&amp;C::memfunc,c,77,33)();
    bind(&amp;C::memfunc,sp,77,33)();
}

</code></pre> 
<h3><a id="5__394"></a>第5章 通用工具</h3> 
<p>本章讲解C++标准库的通用工具，这些工具包括：</p> 
<ul><li>class pair&lt;&gt;和class tuple&lt;&gt;</li><li>Smart pointer class（shared_ptr()和unique_ptr）</li><li>数值极值(Numeric limit)</li><li>Type trait和type utility</li><li>辅助函数(如min()、max()和swap())</li><li>class ratio&lt;&gt;</li><li>Clock和timer</li></ul> 
<h4><a id="51_PairTuple_406"></a>5.1 Pair和Tuple</h4> 
<p><strong>5.1.1 Pair</strong></p> 
<p>class pair可将两个value视为一个单元。C++标准库内多处用到了这个class。尤其容器map、multimap、unordered_map和unordered_multimap就是使用pair来管理其以ke/value pair形式存在的元素。任何函数如果需返回两个value,也需要用到pair</p> 
<p>Struct pair定义于 提供了first_type和second_type类型定义式，用来表示第一value和第二value的类型。</p> 
<p>元素访问：</p> 
<pre><code class="prism language-c++">//generic output operator for pairs(limited solution)
template&lt;typename T1,typename T2&gt;
ostream&amp; operator &lt;&lt; (ostream&amp; strm,const pair&lt;T1,T2&gt;&amp; p)
{
    return strm&lt;&lt;"["&lt;&lt;p.first&lt;&lt;","&lt;&lt;p.second&lt;&lt;"]";
}

typedef pair&lt;int,float&gt; IntFloatPair;
IntFloatPair p(42,3.14);
//访问元素
cout&lt;&lt;get&lt;0&gt;(p)&lt;&lt;endl;
cout&lt;&lt;get&lt;1&gt;(p)&lt;&lt;endl;
cout&lt;&lt;p.first&lt;&lt;endl;
cout&lt;&lt;p.second&lt;&lt;endl;
</code></pre> 
<p>便捷函数make_pair():返回一个pair对</p> 
<p>Template函数make_pair(）使你无需写出类型就能生成一个pair对象</p> 
<p>不必这样写：pair&lt;int,char&gt;(42,’@’)</p> 
<p>可写成这样：make_pair(42,’@’)</p> 
<p><strong>5.1.2 Tuple</strong>(不定数的值组)</p> 
<p>Tuple是TR1引入的东西，<strong>它扩展了pair的概念，拥有任意数量的元素。</strong></p> 
<p>C++11中variadic template被引入进来，使template得以接受任何数量的template实参。出现在中的class tuple声明式现在被简化如下：</p> 
<pre><code class="prism language-c++">namespace std{
    template&lt;typename... Types&gt;
    class type;
}
</code></pre> 
<p>Tuple的操作：</p> 
<ul><li>使用便捷函数make_tuple(),创建一个tuple</li><li>通过get&lt;&gt;() function template,可以访问tuple的元素</li></ul> 
<pre><code class="prism language-C++">//create a four-element tuple
    tuple&lt;string,int,int,complex&lt;double&gt;&gt; t;
    //create and initialize a tuple explicitly
    tuple&lt;int,float,string&gt; t1(41,6.3,"nico");

    cout&lt;&lt;get&lt;0&gt;(t1)&lt;&lt;" ";
    cout&lt;&lt;get&lt;1&gt;(t1)&lt;&lt;" ";
    cout&lt;&lt;get&lt;2&gt;(t1)&lt;&lt;" ";
    cout&lt;&lt;endl;

    //create tuple with make_tuple()
    auto t2 = make_tuple(66,44,"nico");

    //assign second value in t2 to t1
    get&lt;1&gt;(t1) = get&lt;1&gt;(t2);

    //comparison and assignment
    if(t1&lt;t2){      //compares value for value
        t1 = t2;    //OK,assigns value for value
    }

    cout&lt;&lt;get&lt;0&gt;(t1)&lt;&lt;" ";
    cout&lt;&lt;get&lt;1&gt;(t1)&lt;&lt;" ";
    cout&lt;&lt;get&lt;2&gt;(t1)&lt;&lt;" ";
    cout&lt;&lt;endl;
</code></pre> 
<h4><a id="52_Smart_Pointer_487"></a>5.2 Smart Pointer(智能指针)</h4> 
<ul><li><strong>shared_ptr</strong> 实现共享式拥有(shared ownership)。多个smart pointer可以指向相同对象，该对象和其相关资源会在“最后一个reference被销毁”时被释放。</li><li>unique_ptr 实现独占式拥有(exclusive ownership)或严格拥有(strict ownership),保证同一时间内只有一个smart pointer可以指向该对象。你可以以交拥有权。它对于避免资源泄露(resource leak)—例如，“以new创建对象后因为发生异常而忘记调用delete”----特别有用</li></ul> 
<p><strong>5.2.1 class shared_ptr</strong></p> 
<p>对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。<strong>可以通过make_shared函数或者通过构造函数传入普通指针</strong>，可以通过get函数获得普通指针。</p> 
<p>使用shared_ptr：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;

using namespace std;

int main()
{
    //two shared pointers representing two persons by theirf name
    shared_ptr&lt;string&gt; pNico(new string("nico"));
    shared_ptr&lt;string&gt; PJutta(new string("jutta"));
    
    //capitalize person names
    (*pNico)[0] = 'N';
    PJutta-&gt;replace(0,1,"J");

    //put them multiple times in a container
    vector&lt;shared_ptr&lt;string&gt;&gt; whoMadeCoffee;
    whoMadeCoffee.push_back(PJutta);
    whoMadeCoffee.push_back(PJutta);
    whoMadeCoffee.push_back(pNico);
    whoMadeCoffee.push_back(PJutta);
    whoMadeCoffee.push_back(pNico);

    //print all elements
    for(auto ptr : whoMadeCoffee){
        cout&lt;&lt;*ptr&lt;&lt;" ";
    }
    cout&lt;&lt;endl;

    //overwrite a name again
    *pNico = "Nicolai";

    //print all elements
    for(auto ptr : whoMadeCoffee){
        cout&lt;&lt;*ptr&lt;&lt;" ";
    }
    cout&lt;&lt;endl;

    //print some internal data
    cout&lt;&lt;"use_count:"&lt;&lt;whoMadeCoffee[0].use_count()&lt;&lt;endl;

    return 0;

}
</code></pre> 
<p>在某些情况下，有些行为无法运作或不被期望。如循环指向，如果两对象使用shared_ptr互相指向对方，而一旦不存在其他reference指向它们时，想要释放它们和其对应资源。这种情况下shared_ptr不会释放数据，因为每个对象的use_count()扔是1.</p> 
<p>标准库提供了weak_ptr，允许你“共享但不拥有”某对象。这个类会建立起一个shared pointer。一旦最末一个拥有该对象的shared pointer失去了拥有权，任何weak pointer都会自动成空。因此，在default和copy构造函数之外，weak_ptr只提供“接受一个shared_ptr”的构造函数。</p> 
<p><strong>5.2.2 unique_ptr</strong></p> 
<p>unique_ptr可确保一个对象和其相应的资源同一时间只被一个pointer拥有。一旦拥有者被销毁或变成empty,或开始拥有另一个对象，先拥有的那个对象就会被销毁，其任何相应资源也会被释放。</p> 
<h4><a id="53_Type_TraitType_Utility_559"></a>5.3 Type Trait和Type Utility</h4> 
<p>所谓type trait，提供一种用来处理type属性的办法。它是个template,<strong>可在编译器根据一个或多个template实参(通常也是type)产出一个type或value。</strong></p> 
<h4><a id="54__565"></a>5.4 辅助函数</h4> 
<p>#include </p> 
<p>minmax()返回一个pair&lt;&gt;,其中的first是最小值，second是最大值。</p> 
<p>那些接受两个值的版本，返回的是个reference</p> 
<p>swap函数：其泛化实现定义于</p> 
<pre><code class="prism language-c++">namespace std{
    template &lt;typename T&gt;
    inline void swap(T&amp; a,T&amp; b){
        T tmp(move(a));
        a = move(b);
        b = move(a);
    }
}
</code></pre> 
<p>在其内部，数值被moved或被move assigned。</p> 
<p>swap()的最大优势在于，通过模板特化或函数重载，我们可以为更复杂的类型提供特殊实现版本；这些特殊实现有可能交换内部成员，而非对对象赋值，这无疑大大节省了空间。标准库的所有容器和string都运用了这个技术。</p> 
<p>注：C++11标准库(第二版)这本书长达1000多页，后面章节由于时间原因，没有做笔记整理。</p> 
<p>用来处理type属性的办法。它是个template,<strong>可在编译器根据一个或多个template实参(通常也是type)产出一个type或value。</strong></p> 
<h4><a id="54__598"></a>5.4 辅助函数</h4> 
<p>#include </p> 
<p>minmax()返回一个pair&lt;&gt;,其中的first是最小值，second是最大值。</p> 
<p>那些接受两个值的版本，返回的是个reference</p> 
<p>swap函数：其泛化实现定义于</p> 
<pre><code class="prism language-c++">namespace std{
    template &lt;typename T&gt;
    inline void swap(T&amp; a,T&amp; b){
        T tmp(move(a));
        a = move(b);
        b = move(a);
    }
}
</code></pre> 
<p>在其内部，数值被moved或被move assigned。</p> 
<p>swap()的最大优势在于，通过模板特化或函数重载，我们可以为更复杂的类型提供特殊实现版本；这些特殊实现有可能交换内部成员，而非对对象赋值，这无疑大大节省了空间。标准库的所有容器和string都运用了这个技术。</p> 
<p>注：C++11标准库(第二版)这本书长达1000多页，后面章节由于时间原因，没有做笔记整理。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5faa9a72f9658d523602e29b44abbf70/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言实现二叉排序树</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/066eb7dadb782832ea0adfb14498f4d8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">YOLO系列算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>