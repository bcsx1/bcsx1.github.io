<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java集合，超详细整理，适合新手入门 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java集合，超详细整理，适合新手入门" />
<meta property="og:description" content="目录 1. 单列集合Collection1.0 Collection接口实现类的特点1.1 Collection常用方法1.2 继承了Iterable接口1.3 Collection接口遍历元素的方法1.3.1 Iterator迭代器1.3.2 增强for循环 1.4 List接口1.4.1 List常用方法1.4.2 List接口遍历元素的方法1.4.3 ArrayList类1.4.3.1 ArrayList底层源码，1.5倍扩容，Object[]数组 1.4.4 Vector类1.4.4.1 Vector底层源码，2倍扩容1.4.4.2 ArrayList 和Vector比较 1.4.5 LinkedList类1.4.5.1 简单实现双向链表1.4.5.2 LinkedList底层源码，没有扩容，双向链表1.4.5.3 ArrayList和LinkedList比较 1.5 Set接口，不提供索引1.5.1 HashSet1.5.1.1 简单实现数组&#43;链表1.5.1.2 HashSet底层机制，数组&#43;链表&#43;红黑树1.5.1.3 HashSet扩容&#43;红黑树机制 1.5.2 LinkedHashSet1.5.2.1 数组&#43;双向链表 1.5.3 TreeSet 2. 双列集合(Map)：2.1 Map接口实现类的特点2.2 Map常用方法，不支持索引2.3 Map接口三组遍历方法2.3.1 keySet&#43;增强for循环2.3.2 keySet&#43;迭代器2.3.3 values()&#43;增强for循环2.3.4 values()&#43;迭代器2.3.5 EntrySet&#43;增强for循环2.3.6 EntrySet&#43;迭代器 2.4 HashMap扩容机制2.5 Hashtable扩容机制(数组&#43;链表)2.5.1 Hashtable与HashMap比较2.5.2 Properties实现类(继承Hashtable) 2.6 treeMap 3. 小结3.1 Collections集合工具类3.1.1 Collections.reverse()，反转集合3.1.2 Collections.shuffle()，打乱集合顺序3.1.3 Collections.sort(list); 默认按照字符串大小升序排列3.1.4 swap(list, int, int)；将指定集合中的i处元素和j处元素互换3.1.5 Collections.max(collection); 根据元素的自然顺序，返回指定集合中的最大值3.1.6 Collection.frequency(collection，Object); 返回指定集合中指定元素出现的次数3.1.7 Collections.copy(List dest, List src); 把src集合中的数据拷贝到dest中去3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8745e3351680b69070348839b6168ad5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-17T13:28:24+08:00" />
<meta property="article:modified_time" content="2023-10-17T13:28:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java集合，超详细整理，适合新手入门</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1_Collection_5" rel="nofollow">1. 单列集合Collection</a></li><li><ul><li><a href="#10_Collection_11" rel="nofollow">1.0 Collection接口实现类的特点</a></li><li><a href="#11_Collection_16" rel="nofollow">1.1 Collection常用方法</a></li><li><a href="#12_Iterable_39" rel="nofollow">1.2 继承了Iterable接口</a></li><li><a href="#13_Collection_43" rel="nofollow">1.3 Collection接口遍历元素的方法</a></li><li><ul><li><a href="#131_Iterator_44" rel="nofollow">1.3.1 Iterator迭代器</a></li><li><a href="#132_for_51" rel="nofollow">1.3.2 增强for循环</a></li></ul> 
   </li><li><a href="#14_List_59" rel="nofollow">1.4 List接口</a></li><li><ul><li><a href="#141_List_66" rel="nofollow">1.4.1 List常用方法</a></li><li><a href="#142_List_86" rel="nofollow">1.4.2 List接口遍历元素的方法</a></li><li><a href="#143_ArrayList_93" rel="nofollow">1.4.3 ArrayList类</a></li><li><ul><li><a href="#1431_ArrayList15Object_99" rel="nofollow">1.4.3.1 ArrayList底层源码，1.5倍扩容，Object[]数组</a></li></ul> 
    </li><li><a href="#144_Vector_175" rel="nofollow">1.4.4 Vector类</a></li><li><ul><li><a href="#1441_Vector2_180" rel="nofollow">1.4.4.1 Vector底层源码，2倍扩容</a></li><li><a href="#1442_ArrayList_Vector_203" rel="nofollow">1.4.4.2 ArrayList 和Vector比较</a></li></ul> 
    </li><li><a href="#145_LinkedList_211" rel="nofollow">1.4.5 LinkedList类</a></li><li><ul><li><a href="#1451__218" rel="nofollow">1.4.5.1 简单实现双向链表</a></li><li><a href="#1452_LinkedList_229" rel="nofollow">1.4.5.2 LinkedList底层源码，没有扩容，双向链表</a></li><li><a href="#1453_ArrayListLinkedList_265" rel="nofollow">1.4.5.3 ArrayList和LinkedList比较</a></li></ul> 
   </li></ul> 
   </li><li><a href="#15_Set_270" rel="nofollow">1.5 Set接口，不提供索引</a></li><li><ul><li><a href="#151_HashSet_280" rel="nofollow">1.5.1 HashSet</a></li><li><ul><li><a href="#1511__281" rel="nofollow">1.5.1.1 简单实现数组+链表</a></li><li><a href="#1512_HashSet_285" rel="nofollow">1.5.1.2 HashSet底层机制，数组+链表+红黑树</a></li><li><a href="#1513_HashSet_415" rel="nofollow">1.5.1.3 HashSet扩容+红黑树机制</a></li></ul> 
    </li><li><a href="#152_LinkedHashSet_454" rel="nofollow">1.5.2 LinkedHashSet</a></li><li><ul><li><a href="#1521__462" rel="nofollow">1.5.2.1 数组+双向链表</a></li></ul> 
    </li><li><a href="#153_TreeSet_484" rel="nofollow">1.5.3 TreeSet</a></li></ul> 
  </li></ul> 
  </li><li><a href="#2_Map_513" rel="nofollow">2. 双列集合(Map)：</a></li><li><ul><li><a href="#21_Map_519" rel="nofollow">2.1 Map接口实现类的特点</a></li><li><a href="#22_Map_583" rel="nofollow">2.2 Map常用方法，不支持索引</a></li><li><a href="#23_Map_592" rel="nofollow">2.3 Map接口三组遍历方法</a></li><li><ul><li><a href="#231_keySetfor_594" rel="nofollow">2.3.1 keySet+增强for循环</a></li><li><a href="#232_keySet_596" rel="nofollow">2.3.2 keySet+迭代器</a></li><li><a href="#233_valuesfor_598" rel="nofollow">2.3.3 values()+增强for循环</a></li><li><a href="#234_values_601" rel="nofollow">2.3.4 values()+迭代器</a></li><li><a href="#235_EntrySetfor_603" rel="nofollow">2.3.5 EntrySet+增强for循环</a></li><li><a href="#236_EntrySet_605" rel="nofollow">2.3.6 EntrySet+迭代器</a></li></ul> 
   </li><li><a href="#24_HashMap_607" rel="nofollow">2.4 HashMap扩容机制</a></li><li><a href="#25_Hashtable_674" rel="nofollow">2.5 Hashtable扩容机制(数组+链表)</a></li><li><ul><li><a href="#251_HashtableHashMap_694" rel="nofollow">2.5.1 Hashtable与HashMap比较</a></li><li><a href="#252_PropertiesHashtable_704" rel="nofollow">2.5.2 Properties实现类(继承Hashtable)</a></li></ul> 
   </li><li><a href="#26_treeMap_716" rel="nofollow">2.6 treeMap</a></li></ul> 
  </li><li><a href="#3__722" rel="nofollow">3. 小结</a></li><li><ul><li><a href="#31_Collections_746" rel="nofollow">3.1 Collections集合工具类</a></li><li><ul><li><a href="#311_Collectionsreverse_747" rel="nofollow">3.1.1 Collections.reverse()，反转集合</a></li><li><a href="#312_Collectionsshuffle_749" rel="nofollow">3.1.2 Collections.shuffle()，打乱集合顺序</a></li><li><a href="#313_Collectionssortlist__751" rel="nofollow">3.1.3 Collections.sort(list); 默认按照字符串大小升序排列</a></li><li><a href="#314_swaplist_int_intij_756" rel="nofollow">3.1.4 swap(list, int, int)；将指定集合中的i处元素和j处元素互换</a></li><li><a href="#315_Collectionsmaxcollection__758" rel="nofollow">3.1.5 Collections.max(collection); 根据元素的自然顺序，返回指定集合中的最大值</a></li><li><a href="#316_CollectionfrequencycollectionObject__764" rel="nofollow">3.1.6 Collection.frequency(collection，Object); 返回指定集合中指定元素出现的次数</a></li><li><a href="#317_CollectionscopyList_dest_List_src_srcdest_766" rel="nofollow">3.1.7 Collections.copy(List dest, List src); 把src集合中的数据拷贝到dest中去</a></li><li><a href="#318_CollectionsreplaceAllList_list_oldVal_newValnewValoldVal_768" rel="nofollow">3.1.8 Collections.replaceAll(List list, oldVal, newVal)；用newVal替换集合中的oldVal</a></li></ul> 
   </li><li><a href="#32__770" rel="nofollow">3.2 史上巨坑题</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/df/ad/LlPb0SYi_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="1_Collection_5"></a>1. 单列集合Collection</h2> 
<ul><li>指的是在集合里面放的是单个的对象</li><li>Collection 接口有两个重要的子接口 List、Set</li><li>Collection提供了size()方法，List提供了get()方法<br> <img src="https://images2.imgbox.com/a5/92/7jI9ufGt_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/38/38/EJPq15ST_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="10_Collection_11"></a>1.0 Collection接口实现类的特点</h3> 
<blockquote> 
 <ol><li>Collection接口的实现子类可以存放多个元素，每个元素可以是Object；</li><li>Collection的实现类，有些可以存放重复的元素，有些不可以；</li><li>Collection的实现类，有些是有序的（比如List），有些是无序的（比如Set）；</li><li>Collection接口没有直接的实现子类，通过它的子接口Set和List来实现的；</li></ol> 
</blockquote> 
<h3><a id="11_Collection_16"></a>1.1 Collection常用方法</h3> 
<blockquote> 
 <ol><li>add添加单个元素,只要是Object的子类，都可以往里放,输入整数存在一个自动装箱的过程<br> <img src="https://images2.imgbox.com/fc/ee/MWCEFC0o_o.png" alt="在这里插入图片描述"></li><li>remove()删除指定的元素<br> remove构成重载: remove(Object 0) 返回布尔值; remove(int index) 返回被删除的对象<br> <img src="https://images2.imgbox.com/81/97/SjqfSIp9_o.png" alt="在这里插入图片描述"></li><li>contains()查找某个元素是否存在<br> <img src="https://images2.imgbox.com/5d/f0/THLeXmT0_o.png" alt="在这里插入图片描述"></li><li>size()获取元素个数,从1开始计数<br> <img src="https://images2.imgbox.com/7f/30/OKUu2RAk_o.png" alt="在这里插入图片描述"></li><li>addAll()可以添加多个元素<br> 可以在某个下标存入一个实现了Collection接口的ArrayList<br> <img src="https://images2.imgbox.com/ba/56/OxuMNY3Z_o.png" alt="在这里插入图片描述"></li><li>removeAll()删除多个元素<br> 参数为一个实现了Collection接口的ArrayList<br> <img src="https://images2.imgbox.com/5f/a0/8FCubOxJ_o.png" alt="在这里插入图片描述"></li><li>clear()清空<br> <img src="https://images2.imgbox.com/bf/f4/mU3D7Dkm_o.png" alt="在这里插入图片描述"></li><li>isEmpty()判断是否为空<br> <img src="https://images2.imgbox.com/ff/0f/2mowtSNt_o.png" alt="在这里插入图片描述"></li><li>containsAll()查找多个元素是否都存在<br> 参数为一个实现了Collection接口的ArrayList<br> <img src="https://images2.imgbox.com/d4/6c/e6VGvCaK_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h3><a id="12_Iterable_39"></a>1.2 继承了Iterable接口</h3> 
<blockquote> 
 <ol><li>由于Collection实现了Iterable接口，所以所有实现了Collection接口的集合类都有一个iterator()方法，返回一个实现了Iterator接口的对象，即迭代器；<img src="https://images2.imgbox.com/95/ba/6LVoMiDT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d9/66/8XTfYENz_o.png" alt="在这里插入图片描述"></li><li>iterator.next()取不到值的时候，NoSuchElementException；</li></ol> 
</blockquote> 
<h3><a id="13_Collection_43"></a>1.3 Collection接口遍历元素的方法</h3> 
<h4><a id="131_Iterator_44"></a>1.3.1 Iterator迭代器</h4> 
<blockquote> 
 <p>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素；所有实现了Collection接口的实现类都有这个方法；(shortcuts: itit)</p> 
 <ol><li>遍历collection集合，得到collection对象对应的迭代器；iterator.next()，返回下一个元素，类型Object；<br> obj编译类型是Object，运行类型是实际存的对象；<br> <img src="https://images2.imgbox.com/2a/dd/0DcRqv96_o.png" alt="在这里插入图片描述"></li><li>如果要再次遍历，需要重置迭代器； 当迭代器到达最后一个元素时，重置迭代器<br> <img src="https://images2.imgbox.com/4d/ea/bkCOee8U_o.png" alt="&gt;"></li></ol> 
</blockquote> 
<h4><a id="132_for_51"></a>1.3.2 增强for循环</h4> 
<blockquote> 
 <ol><li>增强for循环底层仍然是用的迭代器；所以可以认为增强for循环就是简化版的迭代器遍历；(shortcuts: I、iter)<br> <img src="https://images2.imgbox.com/e8/4f/vPQZjsR2_o.png" alt="在这里插入图片描述"><br> 返回一个Iterator对象；<br> <img src="https://images2.imgbox.com/00/0c/avdyCw9V_o.png" alt="在这里插入图片描述"><br> 调用iterator.hasNext()方法,判断是不是集合中的最后一个对象；<img src="https://images2.imgbox.com/36/2c/wVjN5oJ1_o.png" alt="在这里插入图片描述"><br> 如果不是，调用iterator.next()取得下一个对象；<br> <img src="https://images2.imgbox.com/b6/d2/VYoUaexL_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h3><a id="14_List_59"></a>1.4 List接口</h3> 
<p>List支持索引；</p> 
<ol><li>List接口中的元素是有序的(添加顺序和取出顺序一致)，并且元素可以重复；<br> <img src="https://images2.imgbox.com/49/51/pIdhCaVb_o.png" alt="在这里插入图片描述"></li><li>List集合中的每个元素都有其对应的顺序索引，List支持索引，索引从0开始；<br> <img src="https://images2.imgbox.com/ec/56/SHYltTWJ_o.png" alt="在这里插入图片描述"></li></ol> 
<h4><a id="141_List_66"></a>1.4.1 List常用方法</h4> 
<blockquote> 
 <ol><li>void add(int index, Object ele); 在index位置插入ele对象；如果没有index，则默认在最后插入；<br> <img src="https://images2.imgbox.com/16/ef/B1spG4Yr_o.png" alt="在这里插入图片描述"></li><li>addAll(int index, Collection c);从index处将集合c中所有的元素添加进来；<br> boolean addAll(int index, Collection c);<br> boolean addAll(Collection c);<br> <img src="https://images2.imgbox.com/db/0c/MobE3SEe_o.png" alt="在这里插入图片描述"></li><li>int indexOf(Object o); 返回o对象在集合中首次出现的索引；<br> <img src="https://images2.imgbox.com/27/88/WumhNhNL_o.png" alt="在这里插入图片描述"></li><li>int lastIndexOf(Object o);返回o对象在集合中最后一次出现的索引；<br> <img src="https://images2.imgbox.com/79/30/T83EKTbZ_o.png" alt="在这里插入图片描述"></li><li>Object remove(int index); 移除给定索引处的元素，并返回该元素<br> boolean remove(Object o);<br> <img src="https://images2.imgbox.com/de/ad/37Y86Ldk_o.png" alt="在这里插入图片描述"></li><li>Object set(int index, Object ele); 设置index处的元素为ele，相当于替换<br> index不可以越界：IndexOutOfBoundsException<br> <img src="https://images2.imgbox.com/e1/e8/1hHrG9LN_o.png" alt="在这里插入图片描述"></li><li>List subList(int fromIndex, int toIndex); 截取fromIndex到toIndex的元素，返回一个集合<br> 前闭后开，fromIndex &lt;= 返回的元素 &lt; toIndex; [fromIndex, toIndex);<br> <img src="https://images2.imgbox.com/3a/4c/E2YaEPLw_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h4><a id="142_List_86"></a>1.4.2 List接口遍历元素的方法</h4> 
<blockquote> 
 <ol><li>Iterator迭代器<br> <img src="https://images2.imgbox.com/4c/1d/w9x6WdLz_o.png" alt="在这里插入图片描述"></li><li>增强for循环<br> <img src="https://images2.imgbox.com/43/9d/cwZNWGVV_o.png" alt="在这里插入图片描述"></li><li>普通for循环<br> <img src="https://images2.imgbox.com/88/88/fhHPX9K0_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h4><a id="143_ArrayList_93"></a>1.4.3 ArrayList类</h4> 
<p><img src="https://images2.imgbox.com/f6/d9/crOjoCP3_o.png" alt="在这里插入图片描述"></p> 
<ol><li>ArrayList 线程不安全,Vector 线程安全；</li><li>ArrayList中维护了一个Object类型的数组elementData；transient Object[] elementData;（transient修饰的属性表示这个属性不会被序列化）；</li><li>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData的容量为0；第一次添加时，elementData扩容为10，第二次添加时，elementData则扩容为原来的1.5倍；</li><li>如果使用的是指定大小的构造器，则初始elementData为指定大小，如果需要扩容，则直接扩容为原来的1.5倍；</li></ol> 
<h5><a id="1431_ArrayList15Object_99"></a>1.4.3.1 ArrayList底层源码，1.5倍扩容，Object[]数组</h5> 
<p>transient 瞬间；短暂的<br> final DEFAULTCAPACITY_EMPTY_ELEMENTDATA = 0；<br> final DEFAULT_CAPACITY = 10;</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">calculateCapacity</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> minCapacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">//calculateCapacity()返回的是10或者elementData数组的容量</span>
        <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        modCount<span class="token operator">++</span><span class="token punctuation">;</span>

        <span class="token comment">// overflow-conscious code</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// overflow-conscious code</span>
        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">//向右移动一位，除以2，1.5倍</span>
        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// minCapacity is usually close to size, so this is a win:</span>
        elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>
                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <ol><li>使用无参构造器创建ArrayList源码<br> <img src="https://images2.imgbox.com/b6/d5/rvPhPoEx_o.png" alt="在这里插入图片描述"><br> 1.1 创建了一个空的elementData数组<br> <img src="https://images2.imgbox.com/ff/36/Gzl6mAhB_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6c/3a/kQug1Oqz_o.png" alt="在这里插入图片描述"><br> 1.2 先确定是否要扩容；然后然后再执行赋值操作<br> <img src="https://images2.imgbox.com/ff/e1/CgHjeAIe_o.png" alt="在这里插入图片描述"><br> 1.3 ensureCapacityInternal(): 该方法确定minCapacity(最小容量)<br> (1) 第一次扩容为10<br> <img src="https://images2.imgbox.com/70/02/UdAvloeA_o.png" alt="在这里插入图片描述"><br> 1.4 (1) modCount++；modCount用来记录当前这个集合被修改的次数，防止被多线程操作；<br> (2) 如果elementData容量不够，就调用grow()去扩容<br> <img src="https://images2.imgbox.com/57/6f/GPNdpbvq_o.png" alt="在这里插入图片描述"><br> 1.5 使用扩容机制来确定要扩容到多大；<br> (1) 第一次扩容后newCapacity=10；<br> 原因：elenmentData数组的长度为0，赋给oldCapacity；oldCapacity向右移一位，即: oldCapacity + oldCapacity / 2，赋给newCapacity，则newCapacity的值还为0；此时minCapacity为10，newCapacity &lt; minCapacity，所以将minCapacity赋给newCapacity。<br> (2) 第二次扩容及其以后，按照1.5倍扩容；<br> (3) 扩容使用的是Arrays.copyOf(); 保证原来数据安全的情况下，再增加空间；<br> <img src="https://images2.imgbox.com/cd/d1/hV8eXm5K_o.png" alt="在这里插入图片描述"><br> 1.6. Idea再Debug情况下，显示的数据默认是已简化的，如果希望看到完成的数据，需要做设置<br> <img src="https://images2.imgbox.com/a7/0f/fNEE9jqN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5e/b3/XVspWteG_o.png" alt="在这里插入图片描述"></li><li>使用有参构造器创建和使用ArrayList<br> <img src="https://images2.imgbox.com/5d/b9/2UdEe3aG_o.png" alt="在这里插入图片描述"><br> 2.1 创建了一个指定大小的elementData数组(Object[capacity])<br> 如果是有参的构造器，那么扩容机制是：第一次按照elementData的1.5倍扩容，整个执行流程还是和前面一样；<br> <img src="https://images2.imgbox.com/4d/08/u6VRU04a_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h4><a id="144_Vector_175"></a>1.4.4 Vector类</h4> 
<ol><li>Vector类底层也是一个对象数组；protected Object[] elementData;</li></ol> 
<p><img src="https://images2.imgbox.com/7f/0a/3IVWSGlh_o.png" alt="在这里插入图片描述"><br> 2. Vector是线程同步的，即线程安全，Vector常用方法都带有synchronized；</p> 
<h5><a id="1441_Vector2_180"></a>1.4.4.1 Vector底层源码，2倍扩容</h5> 
<blockquote> 
 <ol><li>使用无参构造器创建Vector<br> <img src="https://images2.imgbox.com/c6/f2/cMrbf9bh_o.png" alt="在这里插入图片描述"><br> 1.1 new Vector()底层：调用无参构造器，初始容量为10，initialCapacity=10；<br> <img src="https://images2.imgbox.com/c2/ed/N06pw7JT_o.png" alt="在这里插入图片描述"><br> Vector(int)，调用一个参数的构造器<br> <img src="https://images2.imgbox.com/bc/09/rDKrVTqT_o.png" alt="在这里插入图片描述"><br> Vector(int,int)，调用两个参数的构造器<img src="https://images2.imgbox.com/2e/3b/9m4Lkfl6_o.png" alt="在这里插入图片描述">1.2 执行add()操作；<img src="https://images2.imgbox.com/f8/13/zLfkSAZU_o.png" alt="在这里插入图片描述"><br> 1.3 确定是否需要扩容【minCapacity - elementData.length &gt; 0】<br> <img src="https://images2.imgbox.com/d2/bf/4bKatIuH_o.png" alt="在这里插入图片描述"><br> 1.4 如果需要的elementData大小不够用，就扩容2倍；<br> newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity);<br> <img src="https://images2.imgbox.com/03/f5/nCN3TTyy_o.png" alt="在这里插入图片描述"></li><li>使用有参构造器创建Vector，初始容量为指定大小；<br> <img src="https://images2.imgbox.com/6e/7b/iBM1Tcw2_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a5/7c/edR3CyRe_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/92/02/lUziAfoc_o.png" alt="在这里插入图片描述"></li><li>使用两个参数的构造器：Vector(int,int)，可以自定义扩容步长；<br> <img src="https://images2.imgbox.com/0a/42/mF5B7eV4_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/82/ce/vSS8WmtQ_o.png" alt="在这里插入图片描述"><br> capacityIncrement &gt; 0 ? capacityIncrement : oldCapacity<br> <img src="https://images2.imgbox.com/24/c8/czevQhge_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h5><a id="1442_ArrayList_Vector_203"></a>1.4.4.2 ArrayList 和Vector比较</h5> 
<table><thead><tr><th>〇</th><th>底层结构</th><th>版本</th><th>线程安全(同步)效率</th><th>扩容倍数</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组Object[]</td><td>jdk1.2</td><td>不安全，效率高</td><td>(无参)10➡15➡22➡33➡49</td></tr><tr><td>Vector</td><td>可变数组Object[]</td><td>jdk1.0</td><td>安全，效率低</td><td>(无参)10➡20➡40➡80➡160</td></tr></tbody></table> 
<ol><li>Vector如果是无参构造器，则默认初始容量为10，之后扩容按照2倍扩容；<br> 如果是有参构造器则第一次指定大小，之后扩容按照2倍扩容；</li><li>ArrayList第一次扩容为10，第二次扩容及其以后，按照1.5倍扩容；</li></ol> 
<h4><a id="145_LinkedList_211"></a>1.4.5 LinkedList类</h4> 
<p><img src="https://images2.imgbox.com/25/da/OPna9l2G_o.png" alt="在这里插入图片描述"></p> 
<ol><li>LinkedList中维护了两个属性first和last，分别指向首结点和尾结点；</li><li>每个节点中(Node对象)，又维护了prev、next、item三个属性；其中通过prev指向前一个，通过next指向后一个，最终实现双向链表；</li><li>所有LinkedList的元素的添加和删除，不是通过数组完成的，所以效率极高；</li><li>LinkedList也是线程不安全的；</li></ol> 
<h5><a id="1451__218"></a>1.4.5.1 简单实现双向链表</h5> 
<p><img src="https://images2.imgbox.com/0f/b7/AQfSVkSZ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/af/b9/RoBgJZde_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7d/06/O5BYPulP_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>从头到尾循环链表</strong><br> <img src="https://images2.imgbox.com/16/2c/ZnjDuZQb_o.png" alt="在这里插入图片描述"></li><li><strong>从尾到头循环链表</strong><br> <img src="https://images2.imgbox.com/d5/0a/Pgu3Qkil_o.png" alt="在这里插入图片描述"></li><li><strong>添加节点</strong><br> <img src="https://images2.imgbox.com/77/84/hdnCT6sr_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3f/f6/kOn15FqZ_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="1452_LinkedList_229"></a>1.4.5.2 LinkedList底层源码，没有扩容，双向链表</h5> 
<blockquote> 
 <ol><li>调用无参构造器后LinkedList的属性first=null，last=null<br> <img src="https://images2.imgbox.com/6e/60/pAxfgo2d_o.png" alt="在这里插入图片描述"><br> size大小为0，只是做了一个初始化<br> <img src="https://images2.imgbox.com/f4/4f/F1G7EVwP_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8a/5c/vsMPSF8s_o.png" alt="在这里插入图片描述"><br> 1.2 执行add方法；<br> <img src="https://images2.imgbox.com/68/3a/Q7WXdvq0_o.png" alt="在这里插入图片描述"><br> 1.2.1 添加第一个节点，加入到双向链表的最后；<br> <img src="https://images2.imgbox.com/ef/db/hY2mNsZq_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d2/d7/Jc6KK3dn_o.png" alt="在这里插入图片描述"><br> 1.2.2 LinkedList的first属性和last属性都指向了同一个节点，这个节点两头为空，item值为1；<br> <img src="https://images2.imgbox.com/d4/40/bLDsVYN6_o.png" alt="在这里插入图片描述"><br> 1.2.3 内存布局图：<br> <img src="https://images2.imgbox.com/b6/c6/5uWnM0fR_o.png" alt="在这里插入图片描述"><br> 1.2.4 向链表添加第二个节点<br> <img src="https://images2.imgbox.com/b3/8b/ZCBQ4aU5_o.png" alt="在这里插入图片描述"></li><li>remove()，默认删除第一个节点；（新版本遗弃了此方法）<br> <img src="https://images2.imgbox.com/f9/9e/2aRHrMzY_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/71/15/nYl7Vsjo_o.png" alt="public E remove() {
return removeFirst();
}"><br> <img src="https://images2.imgbox.com/6e/11/9ly5zELU_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1b/29/T5p7dWTz_o.png" alt="在这里插入图片描述"><br> 2.1 首先让f指向first，即f指向了第一个节点；<br> <img src="https://images2.imgbox.com/42/b9/LjHqVvnC_o.png" alt="在这里插入图片描述"><br> 2.2 将f.next即第二个节点赋给了next<br> <img src="https://images2.imgbox.com/d0/86/ftdJYtQZ_o.png" alt="在这里插入图片描述"><br> 2.3 将第一个节点的item和next置空<br> <img src="https://images2.imgbox.com/70/a1/nrxKTsa5_o.png" alt="在这里插入图片描述"><br> 2.4 first指向next，即first也指向了第二个节点<br> <img src="https://images2.imgbox.com/f4/e2/ski977KT_o.png" alt="在这里插入图片描述"><br> 2.5 将next.pre置空，此时第一个节点成为垃圾；<br> <img src="https://images2.imgbox.com/fb/30/tzRCPmtp_o.png" alt="在这里插入图片描述"></li><li>linkedList.set(1,999); 修改某个节点对象；索引从0开始；</li><li>linkedList.get(1); 取得第二个节点对象；</li></ol> 
</blockquote> 
<h5><a id="1453_ArrayListLinkedList_265"></a>1.4.5.3 ArrayList和LinkedList比较</h5> 
<table><thead><tr><th>〇</th><th>底层结构</th><th>增删的效率</th><th>改查的效率</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>较低，涉及数组扩容</td><td>较高</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>较高，通过链表追加</td><td>较低</td></tr></tbody></table> 
<h3><a id="15_Set_270"></a>1.5 Set接口，不提供索引</h3> 
<blockquote> 
 <ol><li>Set接口是无序的（添加顺序和取出顺序不一致），原因： 添加元素时，会根据元素的哈希值进行排序；排序后，位置就固定了；</li><li>不允许重复元素，最后只能包含一个null；<br> <img src="https://images2.imgbox.com/69/00/sOSfFdRg_o.png" alt="在这里插入图片描述"></li><li>Set接口的实现类没有索引；</li><li>Set接口的遍历方式</li></ol> 
 <ul><li>迭代器</li><li>增强for循环<br> <img src="https://images2.imgbox.com/52/b4/e2UVGIvB_o.png" alt="在这里插入图片描述"></li></ul> 
 <ol start="4"><li>HashSet底层机制: HashMap，即：数组+链表+红黑树</li></ol> 
</blockquote> 
<h4><a id="151_HashSet_280"></a>1.5.1 HashSet</h4> 
<h5><a id="1511__281"></a>1.5.1.1 简单实现数组+链表</h5> 
<blockquote> 
 <ol><li>数组+链表<br> <img src="https://images2.imgbox.com/b7/92/lljyHiS3_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a8/ff/019EYQFO_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h5><a id="1512_HashSet_285"></a>1.5.1.2 HashSet底层机制，数组+链表+红黑树</h5> 
<p>LinkedList、HashSet和HashMap都是在添加元素时初始化大小的，只有Vector是通过无参构造器初始化容量的；<br> final Object PRESENT = new Object();<br> final DEFAULT_LOAD_FACTOR=0.75;<br> final DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//16</p> 
<blockquote> 
 <p>tips:</p> 
 <ol><li>HashSet的底层是HashMap；</li><li>HashSet添加元素时，先得到hash值，根据hash值 &amp;（n-1）得到索引值；</li><li>找到存储数据的数组[表]table，看这个索引位置是否已经有元素；<br> (1)如果没有，直接添加；<br> (2)如果有，调用equals方法[程序员自己定义]比较，如果相同，放弃添加; 如果不相同，添加到最后；</li><li>在jdk8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认值是8）[即到第九个元素时],并且table数组的大小 &gt;= MIN_TREEIFY_CAPACITY（默认是64），就会转化成红黑树；<br> 实操：</li><li>调用HashSet无参构造器<br> <img src="https://images2.imgbox.com/ea/85/QzQ25E4c_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/be/cb/uTCSnzky_o.png" alt="在这里插入图片描述"><br> 调用HashMap的构造器，将加载因子赋予0.75<br> <img src="https://images2.imgbox.com/d7/37/iCAyD9Hc_o.png" alt="在这里插入图片描述"></li><li>执行第一个add(“java”)方法，（e就是加的元素）<br> <img src="https://images2.imgbox.com/de/4a/TOQfqESo_o.png" alt="在这里插入图片描述"><br> private static final Object PRESENT = new Object(); 起到占位作用；<br> <img src="https://images2.imgbox.com/55/79/U6vaN98P_o.png" alt="在这里插入图片描述"><br> 2.1 进入到put方法; key=e=“java”，value=PRESENT<br> <img src="https://images2.imgbox.com/62/e9/lDxQ1jCJ_o.png" alt="在这里插入图片描述"><br> 2.2 进入到hash(key)方法<br> 如果key=null，返回一个0；<br> 如果key不等于null，将key的hashCode无符号右移十六位（防止冲突），返回key的哈希值；<br> <img src="https://images2.imgbox.com/5c/a5/DauQeDfn_o.png" alt="在这里插入图片描述"><br> 2.3 进入到putVal()方法<br> <img src="https://images2.imgbox.com/87/c8/BNwKzYsO_o.png" alt="在这里插入图片描述"><br> 2.4 如果table的大小为0，进入到resize()方法，给table赋DEFAULT_INITIAL_CAPACITY（16）<br> <img src="https://images2.imgbox.com/e5/4d/l1bBmAa0_o.png" alt="在这里插入图片描述">tips:<br> (n - 1) &amp; hash 决定key的索引（即应该在table的哪个位置存放）<br> table是HashMap里的属性，是存放节点的数组<br> <img src="https://images2.imgbox.com/5b/1c/LPHRAed7_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b2/6f/ffh3IIwW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ac/9a/rqJsHBjH_o.png" alt="在这里插入图片描述"><br> 这是HashMap留给子类(比如linkedHashMap)实现的一个方法<br> <img src="https://images2.imgbox.com/9e/f0/uswGdZSE_o.png" alt="在这里插入图片描述"></li><li>执行第二个add(“php”)方法<br> <img src="https://images2.imgbox.com/0c/67/nvXs9Z3f_o.png" alt="在这里插入图片描述"></li><li>执行第三个add(“java”)方法<br> <img src="https://images2.imgbox.com/19/fd/xGEYnJ4U_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/95/b3/Lg3TjVhv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e0/d6/V2QnW1VP_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d8/b3/vkUJ1EB6_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
                       <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span><span class="token comment">//定义了辅助变量</span>
            <span class="token comment">//table 就是 HashMap的一个属性，类型是 Node[]，存放节点的数组</span>
            <span class="token comment">//if语句表示如果当前这个table是空或者大小为0</span>
            <span class="token comment">//  就第一次扩容到16</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            <span class="token comment">//(1)根据key得到的哈希值去计算 该key应该存放到table表的哪个索引</span>
            <span class="token comment">//   并且把这个索引位置的对象赋给辅助变量p</span>
            <span class="token comment">//(2)接下来就要判断这个索引位置的对象(即p)是否为空</span>
            <span class="token comment">//如果p为null(表示这个索引位置还没有存放数据),将创建一个Node(key="java",value=PRESENT)</span>
            <span class="token comment">//放在该位置tab[i] = newNode(hash, key, value, null);</span>
            <span class="token comment">//   Node(hash,key,value,null)</span>
            <span class="token comment">//          这个value只起到占位作用[value=PRESENT]</span>
            <span class="token comment">//          这个哈希值用于比较下一次存放的key和这个key是否相等</span>
            <span class="token comment">//          null就是next</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//一个开发技巧tip：在需要局部变量(辅助变量)的时候，再创建</span>
                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
                <span class="token comment">//老韩的理解：</span>
                <span class="token comment">//如果当前索引位置对应的链表的第一个元素和准备添加进来的key哈希值相同</span>
                <span class="token comment">//并且满足下列条件之一：</span>
                <span class="token comment">//  条件一：如果准备加入的key和(即p指向的Node节点处的key)这个索引处的key是同一个对象</span>
                <span class="token comment">//  条件二：或着p指向的Node节点的key经equals方法和准备加入的key比较后相同(不是同一个对象，但是内容相同)</span>
                <span class="token comment">//则不能在此处添加</span>
                <span class="token comment">//自己的理解：</span>
                <span class="token comment">//就是判断这个索引处的对象是否为空，如果不为空，且两个key哈希值相同，</span>
                <span class="token comment">//且经equals()比较内容也相同[程序员自己定义标准]，则不能在此处添加</span>
                <span class="token comment">//总结：第一个if语句判断和表的第一个节点是否相同，不同则要考虑表的情况进行添加操作</span>
                <span class="token comment">//     如果表是红黑树，则执行putTreeVal()方法添加</span>
                <span class="token comment">//     如果不是红黑树，则判断key和每一个节点是否都相同，如果没有相同的则添加在末尾</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                    <span class="token comment">//[自己的理解]这个if里的语句就是如果两个即传进来的key和p指向的位置的第一个节点完全一样，则不能在此处添加</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    e <span class="token operator">=</span> p<span class="token punctuation">;</span>
                <span class="token comment">//这里判断p是否是一颗红黑树</span>
                <span class="token comment">//  如果是一颗红黑树，就调用putTreeVal方法来进行比较添加</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                    e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">//如果table对应的索引位置已经是一个链表，就使用for循环依次比较</span>
                    <span class="token comment">//  (1)依次和该链表的每一个节点比较后都不相同，则添加在链表末尾;</span>
                    <span class="token comment">//     注意在把元素添加到链表末尾后，立即判断 该链表是否已经达到8个节点</span>
                    <span class="token comment">//     如果达到8个节点，就调用treeifyBin() 对当前这个链表进行树化(转成红黑树)</span>
                    <span class="token comment">//     注意，在转成红黑树时，还进行一个判断：</span>
                    <span class="token comment">//     if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY(64))</span>
                    <span class="token comment">//          resize();</span>
                    <span class="token comment">//     如果上面条件成立，对table表扩容。</span>
                    <span class="token comment">//     只有上面条件不成立时，才转成红黑树；</span>
                    <span class="token comment">//  (2)依次和该链表的每一个节点比较，如果有相同的情况，直接break</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//e可以当作一个指针，比较完之后通过p.next指向下一个节点</span>
                            p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加到链表末尾</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>
                                <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//从这里退出循环e为空</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//从这里退出循环e不为空</span>
                        p <span class="token operator">=</span> e<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// existing mapping for key</span>
                    <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                        e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                    <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
            <span class="token comment">//size 每加入一个Node(h,k,v,next)节点, size++</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
                <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="1513_HashSet_415"></a>1.5.1.3 HashSet扩容+红黑树机制</h5> 
<blockquote> 
 <ol><li>//容量: 0-&gt;16-&gt;32-&gt;64-&gt;128<br> //临界值:0-&gt;12-&gt;24-&gt;48-&gt;96<br> HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值(threshold)是12;<img src="https://images2.imgbox.com/e6/09/xm4Gnvig_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e7/3b/mULglnqw_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/90/df/tGYkKlQb_o.png" alt="在这里插入图片描述"></li><li>如果table数组元素增加到了临界值12，就会扩容到16 * 2=32，新的临界值就是32*0.75=24，依此类推；</li><li>在jdk8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认值是8）[即到第九个元素时],并且table数组的大小 &gt;= MIN_TREEIFY_CAPACITY（默认是64），就会转化成红黑树；否则仍然采用数组扩容机制</li><li>每加入一个Node(h,k,v,next)节点, size就会++<br> <img src="https://images2.imgbox.com/8f/a2/gbA1vuJt_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSetIncrement</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">HashSet</span> hashSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            hashSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hashSet<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>练习题</p> 
 <ol><li>重写equals方法，两个都勾选，说明只有两个字段都相同equals才返回true；<br> <img src="https://images2.imgbox.com/0b/16/Z6lCBSeZ_o.png" alt="在这里插入图片描述"></li><li>重写hashCode方法，两个都勾选，说明只有两个字段都相同hashCode才返回true；<br> <img src="https://images2.imgbox.com/ea/63/ozyCQ0Sk_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ca/29/L2Pp3Wqo_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h4><a id="152_LinkedHashSet_454"></a>1.5.2 LinkedHashSet</h4> 
<p><img src="https://images2.imgbox.com/2b/4a/hThZPulb_o.png" alt="在这里插入图片描述"></p> 
<ol><li>LinkedHashSet是HashSet的子类;</li><li>LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表;</li><li>LinkedHashSet使用双向链表维护元素的次序，所以元素看起来是以插入顺序保存的；（取出顺序和插入顺序一致）</li><li>LinkedHashSet根据元素的hashCode值来决定元素的存储位置;</li><li>LinkedHashSet不允许重复元素；<br> (LinkedHashSet有head和tail)；</li></ol> 
<h5><a id="1521__462"></a>1.5.2.1 数组+双向链表</h5> 
<blockquote> 
 <ol><li>每一个节点都有before和after属性，这样可以形成双向链表；</li><li>在添加一个元素时，先求hash值，再求索引，确定该元素在table中的位置，然后将添加的元素加入到双向链表，如果已经存在(原则和HashSet一致)，则放弃添加；这样在遍历LinkedHashSet是也能确保插入顺序和遍历顺序一致；<br> tail.after = newElement;<br> newElement.before = tail;<br> tail = newElement;</li><li>第一次添加时将数组扩容到16；</li><li>数组类型是HashMap$Node[]；存放的节点类型是LinkedHashMap$Entry;Entry是一个静态内部类，实现了双向链表，Node只是单向链表；<br> <img src="https://images2.imgbox.com/cb/aa/zmqMWK1r_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/db/8e/xxQeCylQ_o.png" alt="在这里插入图片描述"><br> 只确定了loadfactor和threshold<br> <img src="https://images2.imgbox.com/67/ca/xzprcZIj_o.png" alt="image-20221113094555363"><br> <img src="https://images2.imgbox.com/ef/a7/8EKMy80L_o.png" alt="image-20221113094609317"><br> <img src="https://images2.imgbox.com/ab/34/DjyDN4zs_o.png" alt="image-20221113094636910"><br> <img src="https://images2.imgbox.com/1b/0e/ogTcUQ0E_o.png" alt="image-20221113094708974"><br> LinkedHashSet底层维护的是LinkedHashMap（是HashMap的子类）<br> <img src="https://images2.imgbox.com/c7/22/Q6a4VU57_o.png" alt="image-20221113095548867"><br> LinkedHashMap底层维护的是HashMap：数据+双向链表<br> <img src="https://images2.imgbox.com/ef/fb/iE2wUr3d_o.png" alt="image-20221113095628887"><br> 数组类型是HashMap$Node, 数组存放的节点类型是LinkedHashMap$Entry ➡(多态数组)<br> <img src="https://images2.imgbox.com/38/4d/PFIYmXWM_o.png" alt="image-20221113095915913"><br> 原因：LinkedHashMap.Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt;</li></ol> 
</blockquote> 
<h4><a id="153_TreeSet_484"></a>1.5.3 TreeSet</h4> 
<p><img src="https://images2.imgbox.com/52/b3/uK87C3Dh_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>当使用无参构造器创建TreeSet并添加元素的时候，插入顺序和取出顺序不一致（这是因为TreeSet会默认按照传入的key从小到大排序）<br> 原因：创建TreeSet对象时如果传入了一个Comparator对象，就用实现的compare方法比较；如果没有传入Comparator对象，则以添加对象的实现的Comparable接口的compareTo方法比较；<br> <img src="https://images2.imgbox.com/84/71/LBwfRTyU_o.png" alt="在这里插入图片描述"><br> 当传入第一个元素时，若这个元素没有实现Comparable接口，则会报错<br> <img src="https://images2.imgbox.com/66/f7/urU6Iln8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cc/93/Z1oO1r5a_o.png" alt="在这里插入图片描述"><br> 以后传入的对象如果没有实现Comparable接口，也会报类转换异常ClassCastException<br> <img src="https://images2.imgbox.com/1a/6a/aAyLSKQy_o.png" alt="在这里插入图片描述"><br> 解决方案：让对象实现Comparable接口，重写compareTo方法；<br> 去重机制：<br> 创建TreeSet对象时如果传入了一个Comparator对象，就用实现的compare方法去除重复元素，如果方法返回0，就认为不应该添加；如果没有传入Comparator对象，则以添加对象的实现的Comparable接口的compareTo方法去除重复元素；</p> 
</blockquote> 
<blockquote> 
 <ol><li>使用无参构造器创建TreeSet并添加元素<br> <img src="https://images2.imgbox.com/5a/2b/hZy4Kmfl_o.png" alt="在这里插入图片描述"></li><li>使用TreeSet 提供的一个有参构造器，传入一个比较器(匿名内部类)，指定一个排序规则<br> <img src="https://images2.imgbox.com/19/4b/sakDRdKo_o.png" alt="在这里插入图片描述"><br> treeSet底层是treeMap；<br> <img src="https://images2.imgbox.com/d6/26/oW4UzfIe_o.png" alt="在这里插入图片描述"><br> treeSet构造器，把传入的实现了 Comparator接口的匿名内部类传给了TreeMap的属性comparator；<img src="https://images2.imgbox.com/f6/3c/tt7gs0NH_o.png" alt="在这里插入图片描述"><br> 当调用treeSet.add()方法时，在底层会执行到:<br> <img src="https://images2.imgbox.com/34/98/hilJrGeN_o.png" alt="在这里插入图片描述"><br> 能不能加得进去，要看compare()比较的内容，如果内容相等，即cmp返回0，这个key就不会加入<br> <img src="https://images2.imgbox.com/b2/18/YSwn5RFC_o.png" alt="在这里插入图片描述"><br> 在这里会动态绑定到：匿名内部类的compare()方法<br> <img src="https://images2.imgbox.com/7d/2c/VHhu2Zfi_o.png" alt="在这里插入图片描述"><br> 这里是长度相等就相同，所以长度相等的加不进去；<br> <img src="https://images2.imgbox.com/75/cd/4j8nzoKL_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h2><a id="2_Map_513"></a>2. 双列集合(Map)：</h2> 
<ul><li>指的是在集合里面放的是键值对</li><li>Map 接口的实现子类是双列集合，存放的是 k-v</li><li>Map接口没有继承迭代器，不能使用迭代器遍历，也不能使用增强for循环遍历<br> <img src="https://images2.imgbox.com/c8/3b/5FwpXzW3_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a8/60/YDdzY7ND_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="21_Map_519"></a>2.1 Map接口实现类的特点</h3> 
<blockquote> 
 <ol><li>Map用于保存具有映射关系的数据Key-Value；</li><li>Map中的key、value可以是任意引用类型，封装进HashMap的Node内部类中；<br> <img src="https://images2.imgbox.com/04/67/UH0cou22_o.png" alt="在这里插入图片描述"></li><li>Map中的数据key不允许重复,原因：根据hash值和equals判断</li><li>当有相同的key时，就相当于替换value值</li><li>Map中的value值可以重复；</li><li>Map【Hashtable、Properties除外】中的key、value都可以为null，但key只能有一个null，value可以有多个；</li><li>习惯是key放字符串，但是key可以放任意类型</li><li>通过get()方法传入一个key，返回key对应的value，value只有一个；</li><li>k-v 最后都是 HashMap$Node node = newNode(hash,key,value,null);</li><li>k-v 为了方便程序员的遍历，还会创建 EntrySet 集合，该集合存放的元素的类型是 Entry, 而一个Entry对象就有k,v -&gt; EntrySet&lt;Entry&lt;K,V&gt;&gt;<br> <img src="https://images2.imgbox.com/56/bb/bC32gXW1_o.png" alt="在这里插入图片描述"></li><li>在EntrySet中，定义的类型是 Map.Entry,但是实际上存放的还是HashMap$Node,这是因为HashMap$Node 实现了 Map.Entry接口<br> <img src="https://images2.imgbox.com/a9/cb/sUntYZb6_o.png" alt="在这里插入图片描述"></li><li>把HashMap$Node 对象 存放到entrySet集合，方便我们的遍历，因为Map.Entry提供了重要的方法<br> <img src="https://images2.imgbox.com/d0/db/TxlSlmRM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/09/a7/sGMZmVHy_o.png" alt="在这里插入图片描述"></li><li>HashMap没有做同步互斥，没有syntronized，因此是线程不安全的；</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token string">"all"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapSource</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Map</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"No1"</span><span class="token punctuation">,</span><span class="token string">"scott"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"No2"</span><span class="token punctuation">,</span><span class="token string">"zzw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"zzw"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//1.k-v 最后都是 HashMap$Node node = newNode(hash,key,value,null)</span>
        <span class="token comment">//2.k-v 为了方便程序员的遍历，还会创建 EntrySet 数组，该集合存放的元素的类型是 Entry，但元素的运行类型是Node</span>
        <span class="token comment">//  而一个Entry对象就有k,v EntrySet&lt;Entry&lt;K,V&gt;&gt;</span>
        <span class="token comment">//  即：transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span>
        <span class="token comment">//3.在EntrySet中，定义的类型是 Map.Entry,但是实际上存放的还是HashMap$Node</span>
        <span class="token comment">//  这是因为HashMap$Node 实现了 Map.Entry接口</span>
        <span class="token comment">//4.把HashMap$Node 对象 存放到entrySet，方便我们的遍历，因为Map.Entry提供了重要的方法</span>
        <span class="token comment">//  K getKey();</span>
        <span class="token comment">//  V getValue();</span>
        <span class="token class-name">Set</span> set <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//HashMap$EntrySet 是HashMap的一个内部类</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> obj <span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>obj <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//HashMap$Node</span>
            <span class="token comment">//为了从HashMap$Node中取出k-v</span>
            <span class="token comment">//1.先向下转型</span>
            <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> entry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Set</span> set1 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set1<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//HashMap$KeySet</span>
        <span class="token class-name">Collection</span> values <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//HashMap$Values</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{<!-- --></span>

<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="22_Map_583"></a>2.2 Map常用方法，不支持索引</h3> 
<blockquote> 
 <ol><li>put(key,value) 添加键值对</li><li>remove(k,v) remove(k)</li><li>get(k)</li><li>size() 获取k-v个数</li><li>isEmpty() 是否为空</li><li>clear() 清空键值对</li><li>containsKey():查找键是否存在<br> <img src="https://images2.imgbox.com/15/87/PwSqTtcl_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h3><a id="23_Map_592"></a>2.3 Map接口三组遍历方法</h3> 
<p><img src="https://images2.imgbox.com/9c/ae/HRfGqxGv_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="231_keySetfor_594"></a>2.3.1 keySet+增强for循环</h4> 
<p><img src="https://images2.imgbox.com/e6/7b/Efzdty8x_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="232_keySet_596"></a>2.3.2 keySet+迭代器</h4> 
<p><img src="https://images2.imgbox.com/57/54/WoV4VkIG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="233_valuesfor_598"></a>2.3.3 values()+增强for循环</h4> 
<p><img src="https://images2.imgbox.com/21/89/t7L8CAOT_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="234_values_601"></a>2.3.4 values()+迭代器</h4> 
<p><img src="https://images2.imgbox.com/69/f7/SUWIZMaQ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="235_EntrySetfor_603"></a>2.3.5 EntrySet+增强for循环</h4> 
<p><img src="https://images2.imgbox.com/02/0e/073ep0ej_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="236_EntrySet_605"></a>2.3.6 EntrySet+迭代器</h4> 
<p><img src="https://images2.imgbox.com/ce/94/SJWz6auj_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="24_HashMap_607"></a>2.4 HashMap扩容机制</h3> 
<blockquote> 
 <ol><li>HashMap底层维护了Node类型的数组table，默认为null；</li><li>当创建HashMap对象时，将加载因子(loadfactor)初始化为0.75；<br> <img src="https://images2.imgbox.com/e8/b0/bsYEGGQW_o.png" alt="在这里插入图片描述"></li><li>当添加k，v时，通过key的哈希值得到在table的索引，然后判断该索引处是否有元素。如果没有元素，则直接添加；<br> <img src="https://images2.imgbox.com/38/62/y9vbuOpQ_o.png" alt="在这里插入图片描述"><br> 如果有元素，则判断该索引处的key是否和准备加入的key相等；<br> <img src="https://images2.imgbox.com/88/2a/VIMzj4RM_o.png" alt="在这里插入图片描述"><br> 如果key相同，则执行完if语句直接跳到，替换value【e.value = value;】<br> <img src="https://images2.imgbox.com/54/94/205YTj4u_o.png" alt="在这里插入图片描述"><br> 如果key不相同，需要判断是树结构，还是链表结构，然后做出相应处理；<br> 树结构<br> <img src="https://images2.imgbox.com/9e/c5/aQ0a6Evl_o.png" alt="在这里插入图片描述"><br> 链表结构中，如果每个元素的key都不相同，则会一直循环到链表的最后<br> <img src="https://images2.imgbox.com/a3/cf/Ika1IDOD_o.png" alt="在这里插入图片描述"><br> 添加时，发现容量不对，则需要扩容；<br> <img src="https://images2.imgbox.com/b0/fa/GGkZsdvm_o.png" alt="在这里插入图片描述"></li><li>第一次添加，需要将table扩容为16，临界值threshold为12,；<br> <img src="https://images2.imgbox.com/f2/13/MH0kULY6_o.png" alt="在这里插入图片描述"><br> 以后再次扩容，则需要将table扩容为2倍；临界值也变为原来的2倍，即24，以此类推；<br> <img src="https://images2.imgbox.com/12/71/evAqQyWG_o.png" alt="在这里插入图片描述"></li><li>在java8中，如果在binCount到达TREEIFY_THRESHOLD-1，即一条链表的元素超过TREEIFY_THRESHOLD（默认为8），<br> <img src="https://images2.imgbox.com/05/36/EqQtkN6Q_o.png" alt="在这里插入图片描述"><br> 个数： 2 3 4 5 6 7 8 9<br> binCount: 0 1 2 3 4 5 6 7<br> 并且table表的大小超过MIN_TREEIFY_CAPACITY（默认为64），就会进行树化，变为红黑树；<br> <img src="https://images2.imgbox.com/5d/bf/iERDcwYX_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<ol><li>如果底层的table 数组为null，或者 length=0，则扩容到16，调用resize()方法;</li><li>取出hash值对应的table的索引位置的Node，如果为null，就直接把加入的k-v创建成一个Node，加入即可；<br> tab[i] = newNode(hash, key, value, null);</li><li>如果key相同，则替换value【e.value = value;】 走到e != null，说明那个位置有元素并且元素相同，所以在这里不在添加；这段代码专门替换value值；<br> <img src="https://images2.imgbox.com/d5/86/E6fgbo1l_o.png" alt="在这里插入图片描述"></li><li>剪枝：红黑树删除节点到一定数量之后转为链表；</li></ol> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMapSource01</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Map</span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">12</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"zze"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Set</span> entrySet <span class="token operator">=</span> hashMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Object</span> entry <span class="token operator">:</span> entrySet<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//所有的Dog对象的hashCode都一样</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token string">"Dog{"</span> <span class="token operator">+</span>
                <span class="token string">"age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>
                <span class="token char">'}'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="25_Hashtable_674"></a>2.5 Hashtable扩容机制(数组+链表)</h3> 
<blockquote> 
 <ol><li>Hashtable存放的元素是键值对，使用方法基本上和HashMap一致；<br> <img src="https://images2.imgbox.com/25/45/3dj2cOsp_o.png" alt="在这里插入图片描述"></li><li>Hashtable的键和值都不能为null，否则会抛出NullPointerException；<br> <img src="https://images2.imgbox.com/45/89/UX0hT1Vz_o.png" alt="在这里插入图片描述"></li><li>Hashtable是线程安全的，HashMap是线程不安全的；</li><li>Hashtable底层有一个 Hashtable$Entry的数组。第一次初始化大小为11，临界值是8；<br> threshold = 11 * 0.75；<br> <img src="https://images2.imgbox.com/76/29/A3Fyh1uv_o.png" alt="在这里插入图片描述"><br> Hashtable 底层维护的是一个Hashtable$Entry<br> <img src="https://images2.imgbox.com/98/57/zLQn3Kxx_o.png" alt="在这里插入图片描述"></li><li>第二次扩容<br> table大小：11-》23<br> 临界值：8 -》17<br> <img src="https://images2.imgbox.com/3a/7e/WYqTs5gc_o.png" alt="在这里插入图片描述"></li><li>扩容会执行addEntry(hash,key,value,index);<img src="https://images2.imgbox.com/b5/ac/MFkADXNX_o.png" alt="在这里插入图片描述"><br> 当数量大于等于临界值时，扩容<br> <img src="https://images2.imgbox.com/cc/2f/JXYurSYp_o.png" alt="在这里插入图片描述"><br> 大小变为原来的2倍+1；newCapacity = (oldCapacity &lt;&lt; 1) + 1;<br> <img src="https://images2.imgbox.com/53/5b/xDypFYng_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h4><a id="251_HashtableHashMap_694"></a>2.5.1 Hashtable与HashMap比较</h4> 
<table><thead><tr><th>〇</th><th>版本</th><th>线程安全(同步)</th><th>效率</th><th>允许键为null，值为null</th></tr></thead><tbody><tr><td>HashMap</td><td>jdk1.2</td><td>不安全</td><td>效率高</td><td>可以</td></tr><tr><td>Hashtable</td><td>jdk1.0</td><td>安全</td><td>效率低</td><td>不可以</td></tr></tbody></table> 
<table><thead><tr><th>Hashtable</th><th>扩容机制</th></tr></thead><tbody><tr><td>容量</td><td>11➡23➡47➡95</td></tr><tr><td>临界值</td><td>8➡17➡35➡71</td></tr></tbody></table> 
<h4><a id="252_PropertiesHashtable_704"></a>2.5.2 Properties实现类(继承Hashtable)</h4> 
<ol><li>Properties类继承Hashtable类并实现了Map接口，也是使用键值对的形式来存储数据；使用特点和Hashtable相似；</li><li>Properties还可以用于 从某个后缀名为properties的文件中，加载数据到Properties对象，并进行读取和修改；</li><li>Properties不允许键值为null；键或值为空会抛异常NullPointerException</li><li>xxx.properties文件常常作为配置文件【IO流】；</li></ol> 
<blockquote> 
 <ol><li>put()；添加键值对，及修改value值<br> <img src="https://images2.imgbox.com/82/e5/soZfYPsy_o.png" alt="在这里插入图片描述"></li><li>get(key)方法，获取value</li><li>remove()； 删除键值对<br> remove(Object key)<br> boolean remove(Object key, Object value)<br> <img src="https://images2.imgbox.com/fe/97/alLW0Bi6_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h3><a id="26_treeMap_716"></a>2.6 treeMap</h3> 
<blockquote> 
 <p>当使用无参构造器创建TreeSet并添加元素的时候，插入顺序和取出顺序不一致（这是因为TreeSet会默认从小到大升序排序）<br> 第一次添加时，把key、value封装到Entry对象，放入root<br> <img src="https://images2.imgbox.com/8c/ae/MRcMF5HD_o.png" alt="在这里插入图片描述"><br> 第二次添加时，遍历所有的key<br> <img src="https://images2.imgbox.com/68/96/JYxoQp3Y_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h2><a id="3__722"></a>3. 小结</h2> 
<table><thead><tr><th>集合类</th><th>扩容机制</th><th>红黑树机制</th></tr></thead><tbody><tr><td>ArrayList</td><td>第一次添加时，elementData扩容为10，第二次扩容时，elementData则扩容为原来的1.5倍；</td><td>-----</td></tr><tr><td>Vector</td><td>第一次初始化elementData为10，如果需要的elementData大小不够用，就扩容2倍；(可自定义容量增量)</td><td>-----</td></tr><tr><td>LinkedList</td><td>✖</td><td>-----</td></tr><tr><td>HashSet(HashMap)</td><td>第一次添加时，table数组扩容到16，临界值为12；第二次扩容时，table数组扩容为原来的2倍<br>容量: 0-&gt;16-&gt;32-&gt;64-&gt;128，临界值:0-&gt;12-&gt;24-&gt;48-&gt;96</td><td>-----</td></tr><tr><td>Hashtable</td><td>第一次添加时，table数组扩容到11，临界值为8；第二次扩容时，table数组扩容为原来的（2倍+1）,临界值变为原来的(2倍+1)<br>容量: 11-&gt;23-&gt;47-&gt;95，临界值:8-&gt;17-&gt;35-&gt;71</td><td>-----</td></tr></tbody></table> 
<p>在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择，如下：</p> 
<ol><li>先判断存储的类型：（一组对象即单列；一组键值对即双列）</li><li>一组对象[单列]：Collection接口 
  <ul><li>允许重复：List 
    <ul><li>增删多：LinkedList 【底层维护了一个双向链表】</li><li>改查多：ArrayList 【底层维护了Object类型的可变数组】</li></ul> </li><li>不允许重复：Set 
    <ul><li>无序：HashSet 【底层是HashMap，维护了一个哈希表，即数组+链表+红红黑树】</li><li>排序：TreeSet</li><li>插入和取出顺序一致：LinkedHashSet，【底层维护的是数组+双向链表】</li></ul> </li></ul> </li><li>一组键值对[双列]：Map<br> 3.1 键无序：HashMap【底层：哈希表 jdk7：数组+链表，jdk8：数组+链表+红黑树】<br> 3.2 键排序：TreeMap<br> 3.3 键插入和取出顺序一致：LinkedHashMap<br> 读取文件：Properties</li></ol> 
<h3><a id="31_Collections_746"></a>3.1 Collections集合工具类</h3> 
<h4><a id="311_Collectionsreverse_747"></a>3.1.1 Collections.reverse()，反转集合</h4> 
<p><img src="https://images2.imgbox.com/86/34/y6mkC8zO_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="312_Collectionsshuffle_749"></a>3.1.2 Collections.shuffle()，打乱集合顺序</h4> 
<p><img src="https://images2.imgbox.com/bb/d7/ivzmsDHL_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="313_Collectionssortlist__751"></a>3.1.3 Collections.sort(list); 默认按照字符串大小升序排列</h4> 
<p><a href="https://blog.csdn.net/qq_18817831/article/details/127496828#Comparator">Comparator接口匿名内部类的用法👉传送门</a></p> 
<blockquote> 
 <p>Collections.sort(list, Comparator comparator); 自定义排序规则<br> 1)我们希望按照字符串的长度大小排序<br> <img src="https://images2.imgbox.com/55/70/Vr1ts1Nk_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="314_swaplist_int_intij_756"></a>3.1.4 swap(list, int, int)；将指定集合中的i处元素和j处元素互换</h4> 
<p><img src="https://images2.imgbox.com/36/ae/5HJ1SSXm_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="315_Collectionsmaxcollection__758"></a>3.1.5 Collections.max(collection); 根据元素的自然顺序，返回指定集合中的最大值</h4> 
<p><img src="https://images2.imgbox.com/fe/17/O88qNNDw_o.png" alt="在这里插入图片描述"><br> Collections.max(collection, Comparator comparator); 自定义排序，返回指定集合中的最大值<br> <img src="https://images2.imgbox.com/5c/bf/zu683iVa_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ol start="6"><li>Collections.min(collection); 根据元素的自然顺序，返回指定集合中的最小值<br> Collections.min(collection, Comparator comparator); 自定义排序，返回指定集合中的最小值</li></ol> 
</blockquote> 
<h4><a id="316_CollectionfrequencycollectionObject__764"></a>3.1.6 Collection.frequency(collection，Object); 返回指定集合中指定元素出现的次数</h4> 
<p><img src="https://images2.imgbox.com/b9/57/mJMvxvoM_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="317_CollectionscopyList_dest_List_src_srcdest_766"></a>3.1.7 Collections.copy(List dest, List src); 把src集合中的数据拷贝到dest中去</h4> 
<p><img src="https://images2.imgbox.com/f5/a9/tucIesJ1_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="318_CollectionsreplaceAllList_list_oldVal_newValnewValoldVal_768"></a>3.1.8 Collections.replaceAll(List list, oldVal, newVal)；用newVal替换集合中的oldVal</h4> 
<p><img src="https://images2.imgbox.com/f9/eb/dG5wqtXl_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="32__770"></a>3.2 史上巨坑题</h3> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Homework06</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">HashSet</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Person</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span> <span class="token string">"AA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Person</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">1002</span><span class="token punctuation">,</span> <span class="token string">"BB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//HashMap$Node tab[i] = newNode(hash, 1001, "AA", null);</span>
        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//HashMap$Node tab[i] = newNode(hash, 1002, "BB", null);</span>
        p1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"CC"</span><span class="token punctuation">;</span>
        set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此时p1的哈希值改变了</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//p1,p2</span>
        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span> <span class="token string">"CC"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span> <span class="token string">"AA"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token string">"Person{"</span> <span class="token operator">+</span>
                <span class="token string">"id="</span> <span class="token operator">+</span> id <span class="token operator">+</span>
                <span class="token string">", name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>
                <span class="token char">'}'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> o<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>
        <span class="token keyword">return</span> id <span class="token operator">==</span> person<span class="token punctuation">.</span>id <span class="token operator">&amp;&amp;</span>
                <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dc2e5e59480926b09da951e9492bb8c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQL如何将正数转为负数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/07710780402b79e383287e6560d5c47f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux篇---更改hostname</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>