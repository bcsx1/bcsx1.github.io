<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>仙侠网游学习笔记 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="仙侠网游学习笔记" />
<meta property="og:description" content="part 1 复习 OD复习（了解了OD后转x32dbg更好用） e：模块列表，可以看到调用的所有DLL
t：线程线列：可以看到运行的所有线程
k：堆栈列表：可以看到调用的所有call
b：断点列表：可以看到设置的所有断点
c：CPU窗口/代码窗口
入口：main/启动窗口创建完毕/子程序创建完毕
OD打开主程序入口如下：
00B755E2 &gt;/$ 55 push ebp
按上面的e按钮后找到ELEMENTCLIENT.EXE条目如下：
Executable modules, 条目 32
基址=00400000
大小=00950000 (9764864.)
入口=00B755E2 ELEMENTC.
名称=ELEMENTC
路径=D:\kdxy\setup\口袋西游\element\ELEMENTCLIENT.EXE
我们打开ce附加进程后在00400000到00D50000范围内搜索，全是绿色地址
如果附加进程后运行不了
按上面的t按钮右击重启所有线程即可
按上面的c按钮可以回到主界面
ctrl&#43;g再输入地址可以直接跳到目的地址
输入send可以直接定位到发包函数
如果send定位不到，则输入WS2_32.send再回车
找到没人的地方打断点，保持没有发包
吃药，发包中断，然后ctrl&#43;F9就能跳到send函数最后一条指令
回车就能回到call send的下一条指令0x00666850
00666830 . 53 push ebx 00666831 . 56 push esi 00666832 . 8BF1 mov esi,ecx 00666834 . 57 push edi 00666835 . 6A 00 push 0x0 ; /Flags = 0 00666837 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/d972e6d6d411a53a870c59a60b34e723/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-28T20:33:28+08:00" />
<meta property="article:modified_time" content="2021-06-28T20:33:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">仙侠网游学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="part_1__0"></a>part 1 复习</h2> 
<h3><a id="ODODx32dbg_2"></a>OD复习（了解了OD后转x32dbg更好用）</h3> 
<blockquote> 
 <p>e：模块列表，可以看到调用的所有DLL<br> t：线程线列：可以看到运行的所有线程<br> k：堆栈列表：可以看到调用的所有call<br> b：断点列表：可以看到设置的所有断点<br> c：CPU窗口/代码窗口</p> 
</blockquote> 
<blockquote> 
 <p>入口：main/启动窗口创建完毕/子程序创建完毕<br> OD打开主程序入口如下：<br> 00B755E2 &gt;/$ 55 push ebp</p> 
</blockquote> 
<blockquote> 
 <p>按上面的e按钮后找到ELEMENTCLIENT.EXE条目如下：<br> Executable modules, 条目 32<br> 基址=00400000<br> 大小=00950000 (9764864.)<br> 入口=00B755E2 ELEMENTC.<br> 名称=ELEMENTC<br> 路径=D:\kdxy\setup\口袋西游\element\ELEMENTCLIENT.EXE<br> 我们打开ce附加进程后在00400000到00D50000范围内搜索，全是绿色地址</p> 
</blockquote> 
<blockquote> 
 <p>如果附加进程后运行不了<br> 按上面的t按钮右击重启所有线程即可</p> 
</blockquote> 
<blockquote> 
 <p>按上面的c按钮可以回到主界面<br> ctrl+g再输入地址可以直接跳到目的地址<br> 输入send可以直接定位到发包函数<br> 如果send定位不到，则输入WS2_32.send再回车</p> 
</blockquote> 
<blockquote> 
 <p>找到没人的地方打断点，保持没有发包<br> 吃药，发包中断，然后ctrl+F9就能跳到send函数最后一条指令<br> 回车就能回到call send的下一条指令0x00666850</p> 
</blockquote> 
<pre><code>00666830   .  53            push ebx
00666831   .  56            push esi
00666832   .  8BF1          mov esi,ecx
00666834   .  57            push edi
00666835   .  6A 00         push 0x0                                 ; /Flags = 0
00666837   .  8B46 10       mov eax,dword ptr ds:[esi+0x10]          ; |
0066683A   .  8B48 04       mov ecx,dword ptr ds:[eax+0x4]           ; |
0066683D   .  8B50 08       mov edx,dword ptr ds:[eax+0x8]           ; |
00666840   .  8B46 04       mov eax,dword ptr ds:[esi+0x4]           ; |
00666843   .  8BD9          mov ebx,ecx                              ; |
00666845   .  2BD3          sub edx,ebx                              ; |
00666847   .  52            push edx                                 ; |DataSize = 856FDDC (139918812.)
00666848   .  51            push ecx                                 ; |Data = 0A29A465
00666849   .  50            push eax                                 ; |Socket = 0x3
0066684A   .  FF15 B868BE00 call dword ptr ds:[&lt;&amp;WS2_32.#send_19&gt;]   ; \send
00666850   .  8BD8          mov ebx,eax
</code></pre> 
<blockquote> 
 <p>再次ctrl+f9跳到函数末，回车跳到上一层call的下一条指令，按错了可以用-键返回上一条指向的指令（无论是ctrl+f9按错还是enter按错都可以跳回刚指向的指令）<br> 如此循环找到多重call，我们给第一，第二，第三……每重call都打断点，按上面的b按钮可以看所有断点<br> 走路进入的断点撤销，吃药进入的断点就是要找的！只要是只有吃药才进入的断点都可以进行远程注入线程调用！观察前几行的push，用代码注入进行调试！</p> 
</blockquote> 
<blockquote> 
 <p>喊话call找法：同吃药call，就是把吃药换成喊话<br> 快速寻找call：在send函数处断下，喊话，按上面的k按钮，可以分析出所有的call调用</p> 
</blockquote> 
<blockquote> 
 <p>在send函数头处中断，右下角双击栈地址，可以变成<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          − 
         
        
          − 
         
        
          &gt; 
         
        
          ， 
         
        
       
         --&gt;， 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord">−</span><span class="mord">−</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0em; vertical-align: 0em;"></span><span class="mord cjk_fallback">，</span></span></span></span></span>+4，$+8这类的地址<br> 观察到传进来的参数有四个：socket,data,datasize,flags，我们如果能分析出每一个参数的地址，就可以实现每一种call了！<br> 在send函数头处的中断改成条件中断，如[ESP+0x0C]==0x0B，逐个值试！<br> 走路断，不动断，点击断，攻击断，吃药断，都有不同的datasize，记下对应断的值即可</p> 
</blockquote> 
<blockquote> 
 <p>eax一般是call的返回值，小部分可能是用ecx<br> ecx一般用来存对象基地址（像新剑侠情缘中的独孤剑）<br> ebx与edx就是读写比较快，没什么特别</p> 
</blockquote> 
<blockquote> 
 <p>附加进程后结束调试：右击代码区-strongOD-detach<br> OD基本功：懂得f7与f8与f9来运行，ctrl+f9与enter与-来跳转，代码段int3与条件来中断，数据段内存（易被检测勿用）与硬件（断在访问内存数据的指令下一行）来中断，上面的按钮看不同窗口界面<br> 汇编基本功：mov(传值)与lea(传址)，push x(sub esp,4 + mov [esp],x)与pop x(mov x,[esp] + add esp,4)，call x(push eip + jmp x)与retn(pop eip)与retn x(pop eip + add esp,x)</p> 
</blockquote> 
<blockquote> 
 <p>右击代码区，查找，用户定义的注释（即可看到所有代码注释）<br> 右击代码区，查找，所有常量（即可看到所有用到绿址的代码）</p> 
</blockquote> 
<blockquote> 
 <p>在OD看到[ebp+2C]这种，要先判断ebp是本层函数栈底还是偏移！ebp与右下角的堆栈区拉到最靠栈顶的那个有显示返回的地址的那一行（call的push eip）的上一行（函数头push的ebp）相等就是顶底<br> 右下角的堆栈区如果是新跳入的call，栈顶指令右边会是“call返回xxx”然后连同下面几行有个大括号括住传入的参数，之后本函数如果有push，则“call返回xxx”的这个不是栈顶<br> 往上找代码时看到retn，要注意区分retn的下一行代码是不是函数入口，点击分析代码，看上面是否会有jmp箭头指向它，有的话就是同一个函数（一般中间没有int3是同一函数）<br> 往上找代码时看到retn，要注意区分retn的下一行代码是不是函数入口，ctrl+f9-回车-上一行指向call-回车进行函数入口，与刚才retn的下一行比较是否相同（一般上面是int3的是函数头）</p> 
</blockquote> 
<blockquote> 
 <p>在OD看到[esp+10]这种，要意识到要看代码往前找第四个push，（esp是栈顶，右下角堆栈区往下找四个地址（4B为单位）可以看到值）</p> 
</blockquote> 
<blockquote> 
 <p>在OD看到mov edx,[eax+2C]且上一行是call，要小心eax很大可能是call的返回值</p> 
</blockquote> 
<blockquote> 
 <p>远程调用call时，call前的mov寄存器要看函数体内有没有调用到该寄存器的值，有的话也可能是一个参数<br> 远程调用call时，call后对esp的操作要看函数体末有没有自动平栈如retn 10，或者用OD在CALL前后用F8步过看push前与call后的esp是否相等也可以知道是否自动平栈</p> 
</blockquote> 
<pre><code class="prism language-asm">假设现在的场景如下（所有指令与值都假设为1B）
设10处指令执行时ebp与esp的值都是08
11    push eax
12    push ecx
13    push edx
14    call 0xF4
15    inc a
      ....
F4    push ebp
F5    mov ebp,esp
      ....
FE    pop ebp
FF    retn 3

我们知道call x(push eip + jmp x)
所以在执行F4处的指令前栈顶会有一个大括号括着四行
依次是eip的值即15，edx的值，ecx的值，eax的值
当前栈：(ebp=08,esp=04)
04  15(返回到15)
05  edx
06  ecx
07  eax
08  ...

F4处压入ebp保护起来，此时栈顶的值是08，然后是15
当前栈：(ebp=08,esp=03)
03  08
04  15(返回到15)
05  edx
06  ecx
07  eax
08  ...

我们知道esp永远是指向栈顶的，即此时esp的值是03
F5处把esp赋给ebp，则ebp的值也是03，指向本段函数的栈底
此时就回到了esp与ebp相等的情况（开始时的两个值都是08）
当前栈：(ebp=03,esp=03)
03  08
04  15(返回到15)
05  edx
06  ecx
07  eax
08  ...

假设本段函数没有再调用子函数，没有对栈进行操作，一直到FE处
FE处pop ebp还原ebp的值为08，即上层函数的栈底，esp由于退栈地址增加变成04
当前栈：(ebp=08,esp=04)
04  15(返回到15)
05  edx
06  ecx
07  eax
08  ...

我们知道retn x相当于pop eip + add esp,x
首先eip=15，esp由于退栈地址增加变成05
当前栈：(ebp=08,esp=05)
05  edx
06  ecx
07  eax
08  ...
（补充说明:如果只是retn没有x，则第地址为15处的指令就该是add esp,3）

然后esp再add增加把三个输入的参数退掉
当前栈：(ebp=08,esp=08)
08  ...

</code></pre> 
<pre><code class="prism language-asm">假如上面的程序调整为：
F4    push ebp
F5    mov ebp,esp
F6    sub esp,04
      ....
FD    add esp,04
FE    pop ebp
FF    retn 3

解释:
F6的作用就是给局部变量开辟空间
FD的作用就是给局部变量释放空间

我们要区分出变量与参数，假如在执行到F8处时：
当前栈：(ebp=03,esp=02)
02  DD
03  08
04  15(返回到15)
05  edx
06  ecx
07  eax
08  ...
我们凭借OD右下角栈区中(返回到15)来进行分界
在04处(返回到15)下面的是传入参数，[ebp+08]，[ebp+0C]，...
在04处(返回到15)上面的是局部变量，[ebp-04]，[ebp-08]，...
注意如果是用esp来定位栈区地址的话esp只有加没有减的，要小心计算
</code></pre> 
<hr> 
<h2><a id="part_2__189"></a>part 2 打坐</h2> 
<hr> 
<p>1运行游戏后，打开x32_dbg，ctrl+g，ws32_32.send，找到发包函数<br> <img src="https://images2.imgbox.com/f2/2e/hYwRPKFF_o.png" alt="在这里插入图片描述"></p> 
<p>2ctrl+f9找到发包函数结束位置<br> <img src="https://images2.imgbox.com/e6/05/UVCRjEpW_o.png" alt="在这里插入图片描述"></p> 
<p>3enter找到调用发包函数的指令（可以看到下面有&amp;send）<br> <img src="https://images2.imgbox.com/bd/d3/GZCthL8n_o.png" alt="在这里插入图片描述"></p> 
<p>4ctrl+9找到send+1层函数的结束位置，然后enter,ctrl+f9,enter，到达send+3层函数的调用位置<br> <img src="https://images2.imgbox.com/37/2e/ySBPEJtJ_o.png" alt="在这里插入图片描述"></p> 
<p>5send+3层函数的调用位置<br> <img src="https://images2.imgbox.com/2d/ae/EJoGbQtU_o.png" alt="在这里插入图片描述"></p> 
<p>6同理，ctrl+f9，到达send+3层函数的结束位置<br> <img src="https://images2.imgbox.com/04/97/jCaE0hMw_o.png" alt="在这里插入图片描述"></p> 
<p>7同理，enter，到达send+4层函数的调用位置<br> <img src="https://images2.imgbox.com/14/8b/G0kL4PTd_o.png" alt="在这里插入图片描述"></p> 
<p>8现在给send+1,send+2,send+3,send+4层调用处加了f2断点，不断按x32_dbg窗口工具箱第四个按钮（运行），在没有中断时，在游戏中按7键，激活打坐事件，发现是从send+4层call开始断，然后send+3层，send+2层，send+1层，而其他事件中断（即非打坐事件产生的中断）不会执行到send+4层的调用指令，可见send_4层调用就是我们要找的call<br> （凭经验可知，一般到第四五六层就是要找的call）<br> <img src="https://images2.imgbox.com/5b/26/kpJOyHWA_o.png" alt="在这里插入图片描述"></p> 
<p>9基本思想：寻找send+4层调用的所有参数的基地址及所有偏移，例如寻找esi的来源<img src="https://images2.imgbox.com/be/2c/xSGb5bnt_o.png" alt="在这里插入图片描述"></p> 
<p>10经分析，esi是eax赋值的<br> <img src="https://images2.imgbox.com/41/7a/ELXhqZA5_o.png" alt="在这里插入图片描述"></p> 
<p>11在mov esi,eax后esi就没有变过<br> <img src="https://images2.imgbox.com/9c/e6/qxFIxyAE_o.png" alt="在这里插入图片描述"></p> 
<p>12寻找eax的来源，确定是从call elementclient.96E8D0中得到<br> <img src="https://images2.imgbox.com/1b/ae/BfZBmahb_o.png" alt="在这里插入图片描述"></p> 
<p>13然后我发现这样很难找，所以我尝试ctrl+f9到send+4结束处<br> <img src="https://images2.imgbox.com/8f/fe/BZsqZxHM_o.png" alt="在这里插入图片描述"></p> 
<p>14再enter找到send+5层调用<br> <img src="https://images2.imgbox.com/d8/d9/INrhXouq_o.png" alt="在这里插入图片描述"></p> 
<p>15发现是无参调用！马上用注入工具测试下，成功！</p> 
<p>16call 0x006C5650这个是不是万能的呢，我们重启多次游戏测试，仍然可行！</p> 
<p>17同样方法寻找结束打坐的call</p> 
<p><img src="https://images2.imgbox.com/af/d3/DjHDKuCl_o.png" alt="在这里插入图片描述">18惊奇地发现原来打坐开始与结束的函数入口是如此的近</p> 
<p><img src="https://images2.imgbox.com/19/a5/APkEcbv1_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>综上所述，下面两个call就是打坐开始与打坐结束<br> call 0x006C5650<br> call 0x006C5690</p> 
</blockquote> 
<hr> 
<h2><a id="part_3__260"></a>part 3 血量地址</h2> 
<p>人物现血量：[[[[[[[00D11A50+1C]+68]+4]+8]+1C]+8]+28]+288<br> 人物基地址：[[[[[[[00D11A50+1C]+68]+4]+8]+1C]+8]+28]<br> 要想找到其他属性就在人物基地址基础上找偏移即可<br> 【心得：见到ebp不用慌，可能只是普通寄存器用法】<br> 【万一是mov ebp,esp，那么其实就是在上下文找push】<br> 【[ebp-4]是mov ebp,esp后的第一个push】<br> 【[ebp]是mov ebp,esp前的第一个push】<br> 举个例子：<br> push 1<br> push 2<br> mov ebp,esp<br> push 3<br> mov eax [ebp-4]<br> mov ebx [ebp]<br> mov ecx [ebp+4]</p> 
<p>此时eax=3,ebx=2,ecx=1</p> 
<p>补充找地址偏移笔记：<br> ecx=edi<br> ebp=ecx<br> ecx=[ebp+1C]，ebp=00D11A50<br> ebp=ecx<br> ecx=ebp<br> edi=ecx，ecx=0598F5A8<br> ecx=[edi+68]<br> ebx=ecx<br> eax=[ebx+4]<br> ebp=[eax+8]<br> ecx=[ebp+eax*4+1C]，eax=0<br> ecx=23A85808<br> eax=[ecx+8]<br> eax=[eax+28]<br> eax=人物基地址<br> 血量=[人物基地址+288]</p> 
<hr> 
<h2><a id="part_4__300"></a>part 4 自动打怪</h2> 
<hr> 
<h2><a id="part_5__304"></a>part 5 总结一下代码</h2> 
<h2><a id="_305"></a>一、远程修改内存及创建线程注入代码（入门）</h2> 
<pre><code>//以植物大战僵尸为例
DWORD CplantsprojectDlg::FindGageProcessIdByWndTitle(CString strTitle) {
	HWND hWnd = ::FindWindow(NULL, strTitle.GetBuffer());
	if (!hWnd) {
		MessageBox(_T("未打开程序"), NULL, 0);
		return 0;
	}
	DWORD dwPid = 0;
	GetWindowThreadProcessId(hWnd, &amp;dwPid);
	return dwPid;
}
void CplantsprojectDlg::OnBnClickedButton1() {
	/*
		阳光基地址：0x6A9EC0（或者说是：程序基地址00400000+0级偏移地址002A9EC0）
		阳光第1级偏移地址：[0x6A9EC0]+0x768
		阳光第2级偏移地址：[[0x6A9EC0]+0x768]+0x5560
	*/
	UpdateData(TRUE);
	DWORD dwPid = FindGageProcessIdByWndTitle(_T("植物大战僵尸中文版"));
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
	if (!hProcess) {
		MessageBox(_T("打开失败"), NULL, 0);
		return;
	}
	DWORD dwTemp = 0;	//基地址
	if (!ReadProcessMemory(hProcess, (LPVOID)0x6A9EC0, (LPVOID)&amp;dwTemp, sizeof(DWORD), &amp;dwPid)) {
		MessageBox(_T("读取失败"), NULL, 0);
		CloseHandle(hProcess);
		return;
	}
	dwTemp += 0x768;	//加偏移地址
	if (!ReadProcessMemory(hProcess, (LPVOID)dwTemp, (LPVOID)&amp;dwTemp, sizeof(DWORD), &amp;dwPid)) {
		MessageBox(_T("读取失败"), NULL, 0);
		CloseHandle(hProcess);
		return;
	}
	dwTemp += 0x5560;	//加偏移地址
	DWORD dwShine = 9999;	//是传入的值，表示修改后的阳光数
	DWORD dwLength = 0;		//是传出的值，表示修改了的字节数
	if (!::WriteProcessMemory(hProcess, (LPVOID)dwTemp, &amp;dwShine, sizeof(DWORD),&amp;dwLength)){
		MessageBox(_T("写入失败"), NULL, 0);
		CloseHandle(hProcess);
		return;
	}
	CloseHandle(hProcess);
}
__declspec(naked) void putPlant() {//__declspec(naked)告诉编译器不要改我写的汇编代码，注意最后要手动ret
	//源码位置00410A91，下面的2是植物类型，3是X坐标，5是Y坐标
	__asm{
		pushad
		push	-1
		push	2
		mov		eax, 3
		push	5
		mov		ebx,ds:[0x006A9EC0]
		mov		ebx,ds:[ebx + 0x768]
		push	ebx
		mov		edx, 0x40D120
		call	edx
		popad
		ret
	}
}
void CplantsprojectDlg::OnBnClickedButton5() {
	//一、窗口名获PID
	DWORD dwPid = FindGageProcessIdByWndTitle(_T("植物大战僵尸中文版"));
	//二、PID获进程话柄
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
	if (!hProcess) {
		MessageBox(_T("打开程序失败"), NULL, 0);
		return;
	}
	//三、分配内存（进程话柄/上一步获取，内存地址/随意，大小/4K，提交/立马使用，权限/读写执行）
	LPVOID ThreadFunAdd=VirtualAllocEx(hProcess,NULL,4096,MEM_COMMIT,PAGE_EXECUTE_READWRITE);
	if (!ThreadFunAdd) {
		MessageBox(_T("分配内存失败"), NULL, 0);
		CloseHandle(hProcess);
		return;
	}
	//四、写入代码
	DWORD tmpWrite = 0;
	DWORD tmpSize = 4096;
	BOOL wpm = WriteProcessMemory(hProcess, ThreadFunAdd, putPlant, tmpSize, &amp;tmpWrite);
	if (!wpm) {
		MessageBox(_T("写入代码失败"), NULL, 0);
		CloseHandle(hProcess);
		return;
	}
	//五、远程调用
	HANDLE hThread=CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)ThreadFunAdd, NULL, NULL, NULL);
	if (!hThread) {
		MessageBox(_T("远程调用失败"), NULL, 0);
		CloseHandle(hProcess);
		return;
	}
	//六、等待远程线程执行完成
	DWORD dwWait=WaitForSingleObject(hThread, INFINITE);
	//七、释放目标进程空间
	VirtualFreeEx(hProcess, hThread, 0, MEM_RELEASE);
	//八、关闭目标进程句柄
	CloseHandle(hProcess);
}
</code></pre> 
<h2><a id="DLLMFC_411"></a>二、创建新线程注入DLL-MFC，修改内存（单机）</h2> 
<pre><code>//以新剑侠情缘为例（直接修改属性就能无敌）
void AssistMainDlg::OnBnClickedButton1GetMoney(){
	int* money = (int*)0x00845628;//这个就是金钱地址
	*money = *money + 2;
}
</code></pre> 
<h2><a id="DLLMFCcall_420"></a>三、创建新线程注入DLL-MFC，调用call（网游）</h2> 
<pre><code>// AssistMainDlg.cpp: 实现文件
#include "pch.h"
#include "wmgj_dll.h"
#include "AssistMainDlg.h"
#include "afxdialogex.h"
#include &lt;thread&gt;
#include &lt;mutex&gt; 
// AssistMainDlg 对话框
IMPLEMENT_DYNAMIC(AssistMainDlg, CDialog)
AssistMainDlg::AssistMainDlg(CWnd* pParent /*=nullptr*/)
	: CDialog(IDD_MAIN_DIALOG, pParent), nowHP(0)
{
}
AssistMainDlg::~AssistMainDlg(){
}
void AssistMainDlg::DoDataExchange(CDataExchange* pDX){
	CDialog::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_EDIT1, nowHP);
}
BEGIN_MESSAGE_MAP(AssistMainDlg, CDialog)
	ON_WM_TIMER()
	ON_BN_CLICKED(IDC_BUTTON1_GET_MONEY, &amp;AssistMainDlg::OnBnClickedButton1GetMoney)
	ON_BN_CLICKED(IDC_BUTTON2, &amp;AssistMainDlg::OnBnClickedButton2)
	ON_BN_CLICKED(IDC_BUTTON3, &amp;AssistMainDlg::OnBnClickedButton3)
	ON_BN_CLICKED(IDC_BUTTON4, &amp;AssistMainDlg::OnBnClickedButton4)
	ON_BN_CLICKED(IDC_BUTTON5, &amp;AssistMainDlg::OnBnClickedButton5)
	ON_BN_CLICKED(IDC_BUTTON6, &amp;AssistMainDlg::OnBnClickedButton6)
	ON_BN_CLICKED(IDC_BUTTON8, &amp;AssistMainDlg::OnBnClickedButton8)
	ON_BN_CLICKED(IDC_BUTTON9, &amp;AssistMainDlg::OnBnClickedButton9)
	ON_BN_CLICKED(IDC_BUTTON7, &amp;AssistMainDlg::OnBnClickedButton7)
	ON_BN_CLICKED(IDC_BUTTON10, &amp;AssistMainDlg::OnBnClickedButton10)
	ON_BN_CLICKED(IDC_BUTTON11, &amp;AssistMainDlg::OnBnClickedButton11)
END_MESSAGE_MAP()

// 用户实现方法：AssistMainDlg 消息处理程序
BOOL AssistMainDlg::OnInitDialog(){
	CDialog::OnInitDialog();
	MessageBox(L"窗口加载完成", L"窗口加载完成", 0);
	return TRUE; 
}
void AssistMainDlg::OnBnClickedButton1GetMoney(){
	static int titleFlag = -1;
	titleFlag *= -1;
	if(titleFlag&gt;0)	SetWindowTextA(FindWindowA(NULL,"口袋西游"),"CJ2GJL");
	else SetWindowTextA(FindWindowA(NULL, "CJ2GJL"), "口袋西游");
	
}
__declspec(naked) void beginDaZuo() {
	__asm {
		pushad
		mov edx, 0x006C5650
		call edx
		popad
		ret
	}
}
void AssistMainDlg::OnBnClickedButton2(){
	beginDaZuo();
}
__declspec(naked) void endDaZuo() {
	__asm {
		pushad
		mov edx, 0x006C5690
		call edx
		popad
		ret
	}
}
void AssistMainDlg::OnBnClickedButton3(){
	endDaZuo();
}
void AssistMainDlg::OnBnClickedButton4(){
	int a = *((int*)(0x00D11A50+0x1C));
	int b = *((int*)(a + 0x68));
	int c = *((int*)(b + 0x4));
	int d = *((int*)(c + 0x8));
	int e = *((int*)(d + 0x1C));
	int f = *((int*)(e + 0x8));
	int g = *((int*)(f + 0x28));
	int h = *((int*)(g + 0x288));
	nowHP = h;
	UpdateData(FALSE);
}
void AssistMainDlg::OnBnClickedButton5(){
	SetCursorPos(100, 100); 
	mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
	keybd_event(VK_TAB, 0, 0, 0);
	Sleep(1000);
	keybd_event(VK_TAB, 0, 2, 0);
	Sleep(1000);
	keybd_event('1', 0, 0, 0);
	Sleep(1000);
	keybd_event('1', 0, 2, 0);
	Sleep(1000);
}

int TimerOnOrOff = 0;
int hp1 = -1;
int hp2 = -1;
int hp() {
	int a = *((int*)(0x00D11A50 + 0x1C));
	int b = *((int*)(a + 0x68));
	int c = *((int*)(b + 0x4));
	int d = *((int*)(c + 0x8));
	int e = *((int*)(d + 0x1C));
	int f = *((int*)(e + 0x8));
	int g = *((int*)(f + 0x28));
	int h = *((int*)(g + 0x288));
	return h;
}
void AssistMainDlg::OnTimer(UINT_PTR nIDEvent) {
	switch (nIDEvent) {
		case 1: {
			hp2 = hp();
			if (hp2 == hp1) {//血量不动就是满血可以打怪
				endDaZuo();
				SetCursorPos(100, 100);//找到窗口内再移动
				mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
				keybd_event(VK_TAB, 0, 0, 0);
				Sleep(1000);
				keybd_event(VK_TAB, 0, 2, 0);
				Sleep(1000);
				keybd_event('1', 0, 0, 0);
				Sleep(1000);
				keybd_event('1', 0, 2, 0);
				Sleep(1000);
			}
			else if (hp2 &gt; hp1) {//血量上升就是已脱离战斗回血中可以打坐
				beginDaZuo();
			}//血量下降就是正在打怪
			hp1 = hp();
			break;
		}
		default: {
			break;
		}
	}
	AssistMainDlg::OnTimer(nIDEvent);//nIDEvent号计时器重新计时
}
void AssistMainDlg::OnBnClickedButton6(){
	hp1 = hp();
	if (!TimerOnOrOff)SetTimer(1, 10000, NULL);
	else KillTimer(1);
	TimerOnOrOff = (TimerOnOrOff + 1) % 2;
}

void AssistMainDlg::OnBnClickedButton8(){
	MessageBox(L"启动功能后请点击一下屏幕", L"提示", 0);
	HWND hWnd = ::FindWindow(NULL, _T("口袋西游"));
	if (NULL == hWnd) {
		::MessageBox(NULL, _T("口袋西游未打开"), _T("错误"), MB_OK);
		return;
	}
	unsigned short xypos[2] = { 100,100 };
	::PostMessage(hWnd, WM_LBUTTONDOWN, MK_LBUTTON, *(int*)xypos);
	::PostMessage(hWnd, WM_LBUTTONUP, 0, *(int*)xypos);
	keybd_event(VK_TAB, 0, 0, 0);
	Sleep(1000);
	keybd_event(VK_TAB, 0, 2, 0);
	Sleep(1000);
	keybd_event('1', 0, 0, 0);
	Sleep(1000);
	keybd_event('1', 0, 2, 0);
	Sleep(1000);
}
/*
关于模拟键盘说明一下：
VOID keybd_event(
	BYTE bVk,				//虚拟键码，右击看定义可以查看所有键的宏定义
	BYTE bScan,				// 硬件扫描码。一般不用
	DWORD dwFlags,			// 函数选项标识，0按下，2释放
	ULONG_PTR dwExtraInfo	//一般不用
);
*/
/*
关于模拟鼠标说明一下：（其实扫雷有用过）
	VOID mouse_event(
		DWORD dwFlags,			// 鼠标的单击和移动选项（鼠标左键按下与释放）
		DWORD dx,				// 横坐标（先SetCursorPos就不用了）
		DWORD dy,				// 纵坐标（先SetCursorPos就不用了）
		DWORD dwData,			// 齿轮的滚动（用不到）
		ULONG_PTR dwExtraInfo   // 应用程序定义信息（用不到）
	);
*/
/*特别注意：本代码文件中第19行要手动写入ON_WM_TIMER()
* 第十八行起的代码如下：
BEGIN_MESSAGE_MAP(AssistMainDlg, CDialog)
	ON_WM_TIMER()
	ON_BN_CLICKED(IDC_BUTTON1_GET_MONEY, &amp;AssistMainDlg::OnBnClickedButton1GetMoney)
	ON_BN_CLICKED(IDC_BUTTON2, &amp;AssistMainDlg::OnBnClickedButton2)
	ON_BN_CLICKED(IDC_BUTTON3, &amp;AssistMainDlg::OnBnClickedButton3)
	ON_BN_CLICKED(IDC_BUTTON4, &amp;AssistMainDlg::OnBnClickedButton4)
	ON_BN_CLICKED(IDC_BUTTON5, &amp;AssistMainDlg::OnBnClickedButton5)
	ON_BN_CLICKED(IDC_BUTTON6, &amp;AssistMainDlg::OnBnClickedButton6)
	ON_BN_CLICKED(IDC_BUTTON8, &amp;AssistMainDlg::OnBnClickedButton8)
END_MESSAGE_MAP()
*/


int flag = false;
CWinThread* pThread = NULL;
UINT _cdecl ThreadProc(LPVOID lpParameter) {
	flag = true;
	while (flag) {
		beginDaZuo();
		int getHP_1, getHP_2;
		do{
			getHP_1 = hp();
			Sleep(3);
			getHP_2 = hp();
		} while (getHP_1!= getHP_2);
		endDaZuo();
		HWND hWnd = ::FindWindow(NULL, _T("口袋西游"));
		if (NULL == hWnd) {
			::MessageBox(NULL, _T("口袋西游未打开"), _T("错误"), MB_OK);
			return 0;
		}
		unsigned short xypos[2] = { 100,100 };
		::PostMessage(hWnd, WM_LBUTTONDOWN, MK_LBUTTON, *(int*)xypos);
		::PostMessage(hWnd, WM_LBUTTONUP, 0, *(int*)xypos);
		keybd_event(VK_TAB, 0, 0, 0);
		Sleep(1000);
		keybd_event(VK_TAB, 0, 2, 0);
		Sleep(1000);
		keybd_event('1', 0, 0, 0);
		Sleep(1000);
		keybd_event('1', 0, 2, 0);
		Sleep(5000);
	}
	return 0;
}
void AssistMainDlg::OnBnClickedButton9(){
	MessageBox(L"启动功能后请点击一下屏幕", L"提示", 0);
	pThread = AfxBeginThread(ThreadProc, (LPVOID)456);
}
void AssistMainDlg::OnBnClickedButton7(){
	flag = false;
}

CWinThread* tempThread = NULL;
bool theFinalTestFlag = false;
UINT _cdecl TempFunc(LPVOID lpParameter) {
	theFinalTestFlag = true;
	while (theFinalTestFlag) {
		if (theFinalTestFlag == false)return 0;
		int a = (int)lpParameter;
		CString str;
		str.Format(_T("%d"), a);
		AfxMessageBox(str);
		Sleep(1000);
	}
	return 0;
}
void AssistMainDlg::OnBnClickedButton10(){
	tempThread = AfxBeginThread(TempFunc, (LPVOID)456);
}
void AssistMainDlg::OnBnClickedButton11(){
	theFinalTestFlag = false;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/61/b9/zhy62OSb_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_685"></a>心得</h3> 
<p>学习开发游戏辅助小项目<br> 掌握了C++的MFC定时器<br> 还有多线程和ASM等写法<br> 当然x64_dgb和CE最重要</p> 
<p>游戏逆向开发学了挺久了<br> 这次以kdxy游戏辅助结束<br> 总算是从单机向网游进发</p> 
<p>其实在最后自动攻击那里<br> 我是没有找到怪物数组的<br> 所以用的是模拟键鼠点击<br> 将来如果能用得上再回顾</p> 
<h2><a id="_700"></a>逆向补充</h2> 
<h3><a id="HOOK_701"></a>HOOK</h3> 
<p>把原来的call入口jmp到另一个地方执行指定功能，跑完指定代码再jmp回</p> 
<h3><a id="CRC_703"></a>CRC</h3> 
<p>原理其实挺简单，看下面的代码可以理解（虽然我测试了不能执行）</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
int crc = NULL;
int have_crc_table = NULL;
unsigned int crc32_table[256];
void Crc_Make_Table() {
    have_crc_table = 1;
    for (int i = 0; i &lt; 256; i++) {
        crc = i;
        for (int j = 0; j &lt; 8; j++) {
            if (crc &amp; 1) {
                crc = (crc &gt;&gt; 1) ^ 0xED888320;
            }
            else {
                crc &gt;&gt;= 1;
            }
        }
        crc32_table[i] = crc;
    }
}
unsigned int Calc_Crc32(unsigned int crc, char* Data, int len) {
    crc = 0xFFFFFFFF;
    if (!have_crc_table)Crc_Make_Table();
    for (int i = 0; i &lt; len; i++) {
        crc = crc32_table[(crc ^ Data[i]) &amp; 0xFF] ^ (crc &gt;&gt; 8);
    }
    return ~crc;
}
int main() {
    unsigned int uMainMoudleSumA = Calc_Crc32(0,(char*)0x400000,0x95000);
    int x;
    while (1) {
        unsigned int TmpCrcSum = Calc_Crc32(0, (char*)0x400000, 0x95000);
        if (TmpCrcSum != uMainMoudleSumA) {
            cout &lt;&lt; "you modify the code" &lt;&lt; endl;
        }
        cin &gt;&gt; x;
        if (x == 3)break;
    }
    return 0;
}
//破解方法：找到crc函数，把他改为nop即可
//例如：植物大战僵尸改阳光被识别到开挂，就用CE查看是谁访问了这个地址
//然后，看哪个访问指定1秒访问一次，因为一般来说也没有必要使劲地检查
//最后，一般crc不会是在004xxxxx的代码段处，而是作为一个dll模块导入
//找到目标crc检测代码就好办，直接把call改为nop
//或者说找到找到判断语句，不相等时的jnp改成jmp
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3dab9597196a0969ae73d59fda365c88/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">面试知识点归纳——MySQL</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d5eccf9736f4e60d9a70032e89d6ab5e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NVIDIA Jetson AGX Xavier学习笔记3——环境配置(pytorch、torchvision、cv2)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>