<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python 内置函数大全 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python 内置函数大全" />
<meta property="og:description" content="文章目录 A1.abs(x)2.all(iterable)3.any(iterable)4.ascii(object) B5.bin(x)6.bool([object])7.bytearray([source, [encoding, [errors]]])8.bytes([source, [encoding, [errors]]]) C9.callable(object)10.chr(x)12.compile(source，filename， mode[， flags， [dont_inherit，optimize = -1]])13.complex([real [，imag]) D14.delattr(object，name)15.dict()16.dir(object)17.divmod(a，b) E18.enumerate(iterable，start = 0)19.eval(expression, globals=None, locals=None)20.exec(object[, globals[, locals]]) F21.filter(function，iterable)22.float([x])23.format(value[, format_spec]))24.frozenset([iterable]) G25.getattr(object， name[，default])26.globals()---- H27.hasattr(object，name)28.hash(object)29.help([object])30.hex(x) I31.id(object)32.input([prompt])33.int(x, base = 10)34.isinstance(object，classinfo)35.issubclass(class, classinfo)36.iter(object[, sentinel])----37.len(s)38.list([iterable])39.locals() M40.map(function，iterable，...)41.max(iterable, *[, key, default])42.memoryview(object)43.min(iterable, *[, key, default]) N44.next(iterator[，default]) O45.object()46.oct(x)47.open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)48.ord( c ) P49.pow(x，y[，z])50.print(*objects, sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False)51.property(fget=None， fset=None， fdel=None， doc=None) R52.range(start，stop[，step])53.repr(object)54.reversed(seq)55.round(number[， ndigits]) S56.set([iterable])57.setattr(object， name， value）58.slice(start， stop[， step])59.sorted(iterable，key=None，reverse=False)60.staticmethod(function) ---61.str(object=b&#39;&#39;, encoding=&#39;utf-8&#39;, errors=&#39;strict&#39;)62." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/be60c97c147fe35cef7fab155d9a7b3d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-21T18:07:01+08:00" />
<meta property="article:modified_time" content="2019-09-21T18:07:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python 内置函数大全</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#A_2" rel="nofollow">A</a></li><li><ul><li><a href="#1absx_4" rel="nofollow">1.abs(x)</a></li><li><a href="#2alliterable_32" rel="nofollow">2.all(iterable)</a></li><li><a href="#3anyiterable_62" rel="nofollow">3.any(iterable)</a></li><li><a href="#4asciiobject_80" rel="nofollow">4.ascii(object)</a></li></ul> 
   </li><li><a href="#B_93" rel="nofollow">B</a></li><li><ul><li><a href="#5binx_94" rel="nofollow">5.bin(x)</a></li><li><a href="#6boolobject_106" rel="nofollow">6.bool([object])</a></li><li><a href="#7bytearraysource_encoding_errors_127" rel="nofollow">7.bytearray([source, [encoding, [errors]]])</a></li><li><a href="#8bytessource_encoding_errors_163" rel="nofollow">8.bytes([source, [encoding, [errors]]])</a></li></ul> 
   </li><li><a href="#C_182" rel="nofollow">C</a></li><li><ul><li><a href="#9callableobject_183" rel="nofollow">9.callable(object)</a></li><li><a href="#10chrx_216" rel="nofollow">10.chr(x)</a></li><li><a href="#12compilesourcefilename_mode_flags_dont_inheritoptimize__1_288" rel="nofollow">12.compile(source，filename， mode[， flags， [dont_inherit，optimize = -1]])</a></li><li><a href="#13complexreal_imag_322" rel="nofollow">13.complex([real [，imag])</a></li></ul> 
   </li><li><a href="#D_354" rel="nofollow">D</a></li><li><ul><li><a href="#14delattrobjectname_355" rel="nofollow">14.delattr(object，name)</a></li><li><a href="#15dict_387" rel="nofollow">15.dict()</a></li><li><a href="#16dirobject_408" rel="nofollow">16.dir(object)</a></li><li><a href="#17divmodab_419" rel="nofollow">17.divmod(a，b)</a></li></ul> 
   </li><li><a href="#E_441" rel="nofollow">E</a></li><li><ul><li><a href="#18enumerateiterablestart__0_443" rel="nofollow">18.enumerate(iterable，start = 0)</a></li><li><a href="#19evalexpression_globalsNone_localsNone_465" rel="nofollow">19.eval(expression, globals=None, locals=None)</a></li><li><a href="#20execobject_globals_locals_514" rel="nofollow">20.exec(object[, globals[, locals]])</a></li></ul> 
   </li><li><a href="#F_546" rel="nofollow">F</a></li><li><ul><li><a href="#21filterfunctioniterable_547" rel="nofollow">21.filter(function，iterable)</a></li><li><a href="#22floatx_570" rel="nofollow">22.float([x])</a></li><li><a href="#23formatvalue_format_spec_595" rel="nofollow">23.format(value[, format_spec]))</a></li><li><a href="#24frozensetiterable_639" rel="nofollow">24.frozenset([iterable])</a></li></ul> 
   </li><li><a href="#G_654" rel="nofollow">G</a></li><li><ul><li><a href="#25getattrobject_namedefault_655" rel="nofollow">25.getattr(object， name[，default])</a></li><li><a href="#26globals_702" rel="nofollow">26.globals()----</a></li></ul> 
   </li><li><a href="#H_718" rel="nofollow">H</a></li><li><ul><li><a href="#27hasattrobjectname_720" rel="nofollow">27.hasattr(object，name)</a></li><li><a href="#28hashobject_744" rel="nofollow">28.hash(object)</a></li><li><a href="#29helpobject_762" rel="nofollow">29.help([object])</a></li><li><a href="#30hexx_788" rel="nofollow">30.hex(x)</a></li></ul> 
   </li><li><a href="#I_808" rel="nofollow">I</a></li><li><ul><li><a href="#31idobject_810" rel="nofollow">31.id(object)</a></li><li><a href="#32inputprompt_825" rel="nofollow">32.input([prompt])</a></li><li><a href="#33intx_base__10_842" rel="nofollow">33.int(x, base = 10)</a></li><li><a href="#34isinstanceobjectclassinfo_859" rel="nofollow">34.isinstance(object，classinfo)</a></li><li><a href="#35issubclassclass_classinfo_912" rel="nofollow">35.issubclass(class, classinfo)</a></li><li><a href="#36iterobject_sentinel_934" rel="nofollow">36.iter(object[, sentinel])----</a></li><li><a href="#37lens_953" rel="nofollow">37.len(s)</a></li><li><a href="#38listiterable_969" rel="nofollow">38.list([iterable])</a></li><li><a href="#39locals_983" rel="nofollow">39.locals()</a></li></ul> 
   </li><li><a href="#M_1007" rel="nofollow">M</a></li><li><ul><li><a href="#40mapfunctioniterable_1009" rel="nofollow">40.map(function，iterable，...)</a></li><li><a href="#41maxiterable__key_default_1049" rel="nofollow">41.max(iterable, *[, key, default])</a></li><li><a href="#42memoryviewobject_1071" rel="nofollow">42.memoryview(object)</a></li><li><a href="#43miniterable__key_default_1102" rel="nofollow">43.min(iterable, *[, key, default])</a></li></ul> 
   </li><li><a href="#N_1123" rel="nofollow">N</a></li><li><ul><li><a href="#44nextiteratordefault_1125" rel="nofollow">44.next(iterator[，default])</a></li></ul> 
   </li><li><a href="#O_1157" rel="nofollow">O</a></li><li><ul><li><a href="#45object_1159" rel="nofollow">45.object()</a></li><li><a href="#46octx_1189" rel="nofollow">46.oct(x)</a></li><li><a href="#47openfile_moder_buffering1_encodingNone_errorsNone_newlineNone_closefdTrue_openerNone_1205" rel="nofollow">47.open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</a></li><li><a href="#48ord_c__1292" rel="nofollow">48.ord( c )</a></li></ul> 
   </li><li><a href="#P_1303" rel="nofollow">P</a></li><li><ul><li><a href="#49powxyz_1305" rel="nofollow">49.pow(x，y[，z])</a></li><li><a href="#50printobjects_sep__endn_filesysstdout_flushFalse_1335" rel="nofollow">50.print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)</a></li><li><a href="#51propertyfgetNone_fsetNone_fdelNone_docNone_1365" rel="nofollow">51.property(fget=None， fset=None， fdel=None， doc=None)</a></li></ul> 
   </li><li><a href="#R_1421" rel="nofollow">R</a></li><li><ul><li><a href="#52rangestartstopstep_1423" rel="nofollow">52.range(start，stop[，step])</a></li><li><a href="#53reprobject_1484" rel="nofollow">53.repr(object)</a></li><li><a href="#54reversedseq_1501" rel="nofollow">54.reversed(seq)</a></li><li><a href="#55roundnumber_ndigits_1516" rel="nofollow">55.round(number[， ndigits])</a></li></ul> 
   </li><li><a href="#S_1537" rel="nofollow">S</a></li><li><ul><li><a href="#56setiterable_1539" rel="nofollow">56.set([iterable])</a></li><li><a href="#57setattrobject_name_value_1556" rel="nofollow">57.setattr(object， name， value）</a></li><li><a href="#58slicestart_stop_step_1572" rel="nofollow">58.slice(start， stop[， step])</a></li><li><a href="#59sortediterablekeyNonereverseFalse_1590" rel="nofollow">59.sorted(iterable，key=None，reverse=False)</a></li><li><a href="#60staticmethodfunction__1604" rel="nofollow">60.staticmethod(function) ---</a></li><li><a href="#61strobjectb_encodingutf8_errorsstrict_1632" rel="nofollow">61.str(object=b'', encoding='utf-8', errors='strict')</a></li><li><a href="#62sumiterablestart_1647" rel="nofollow">62.sum(iterable[，start])</a></li><li><a href="#63supertype_objectortype_1659" rel="nofollow">63.super([type[， object-or-type]])</a></li></ul> 
   </li><li><a href="#T_1733" rel="nofollow">T</a></li><li><ul><li><a href="#64tupleiterable_1734" rel="nofollow">64.tuple([iterable])</a></li><li><a href="#65type_1753" rel="nofollow">65.type()</a></li><li><a href="#66varsobject_1773" rel="nofollow">66.vars([object])</a></li><li><a href="#67zipiterable_1799" rel="nofollow">67.zip(*iterable)</a></li><li><a href="#68___import___name_globalsNone_localsNonefromlist_level0_1831" rel="nofollow">68._ \_import_ _(name， globals=None， locals=None，fromlist=()， level=0)</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<br> 本文粗略的介绍了python 3 的内置函数，如有错误和不足，还望指正。 
<p></p> 
<h3><a id="A_2"></a>A</h3> 
<h4><a id="1absx_4"></a>1.abs(x)</h4> 
<p><strong>参数</strong>–x：数值表达式，可以是整形，浮点型，复数。<br> <strong>返回值</strong>：返回数值（x）的绝对值，如果（x）是复数则返回复数的大小。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; abs(-1)
1
&gt;&gt;&gt; abs(-1.0100)
1.01
&gt;&gt;&gt; abs(2.000)
2.0
&gt;&gt;&gt; abs(1+1j)
1.4142135623730951
</code></pre> 
<p>当参数为浮点形时会保留实际长度，多余的0会被省略。<br> 此外math模块中的fabs()函数也有类似的功能，但是fabs()的参数不能是复数。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.fabs(1+1j)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can't convert complex to float
&gt;&gt;&gt;
</code></pre> 
<h4><a id="2alliterable_32"></a>2.all(iterable)</h4> 
<p><strong>参数</strong>：iterable：：可迭代对象。<br> <strong>返回值</strong>：如果iterable的所有元素不为0、’’、False或者iterable为空，all(iterable)返回True，否则返回False。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; t = ['k', 'o', '']
&gt;&gt;&gt; all(t)
False
&gt;&gt;&gt; s = [1, 0, 1]
&gt;&gt;&gt; all(s)
False
&gt;&gt;&gt; l = ["False", 2, "1"]   #这里False是字符串
&gt;&gt;&gt; all(l)
True
&gt;&gt;&gt; l = [False, 1, 3]
&gt;&gt;&gt; all(l)
False
</code></pre> 
<p>注意：<strong>空集合，空列表，空元组会返回True</strong>。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; all([])
True
&gt;&gt;&gt; all({})
True
&gt;&gt;&gt; all(())
True
</code></pre> 
<h4><a id="3anyiterable_62"></a>3.any(iterable)</h4> 
<p><strong>参数</strong>–iterable：可迭代对象。<br> <strong>返回值</strong>：any() 函数用于判断给定的可迭代参数 iterable 是否全部为 False，则返回 False，如果有一个为 True，则返回 True。元素除了是 0、空、FALSE 外都算 TRUE。<br> 大部分情况与all()函数结果相反。</p> 
<pre><code>&gt;&gt;&gt; any({})
False
&gt;&gt;&gt; any([])
False
&gt;&gt;&gt; any(())
False
&gt;&gt;&gt; t = {1, 0, 2}
&gt;&gt;&gt; any(t)
True
&gt;&gt;&gt; q = ["False", 1, 2]    #与all()结果相同
&gt;&gt;&gt; any(q)
True
</code></pre> 
<h4><a id="4asciiobject_80"></a>4.ascii(object)</h4> 
<p><strong>参数</strong>–object：对象<br> <strong>返回值</strong>：返回一个表示对象的字符串, 但是对于字符串中的非 ASCII 字符则返回通过 repr() 函数使用 \x, \u 或 \U 编码的字符。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; ascii(2)
'2'
&gt;&gt;&gt; ascii(1.00)   #当末尾有多个0时， 只会保存一个
'1.0'
&gt;&gt;&gt; ascii("中国")
"'\\u4e2d\\u56fd'"
</code></pre> 
<h3><a id="B_93"></a>B</h3> 
<h4><a id="5binx_94"></a>5.bin(x)</h4> 
<p><strong>参数</strong>–x：int或者long int<br> 返回值：x的二进制表达<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; bin(10)
'0b1010'
&gt;&gt;&gt; bin(256)
'0b100000000'
&gt;&gt;&gt; bin(-10)
'-0b1010'
</code></pre> 
<h4><a id="6boolobject_106"></a>6.bool([object])</h4> 
<p><strong>参数</strong>–object：要转化的对象<br> <strong>返回值</strong>：True 或者 False。当参数为 0，’’，或者为其他数据类型却为空时返回False，当参数为空时返回False。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; t = {}
&gt;&gt;&gt; bool(t)
False
&gt;&gt;&gt; t = []
&gt;&gt;&gt; bool(t)
False
&gt;&gt;&gt; bool(0)
False
&gt;&gt;&gt; bool(-1)
True
&gt;&gt;&gt; bool("")
False
&gt;&gt;&gt; bool()
False
</code></pre> 
<h4><a id="7bytearraysource_encoding_errors_127"></a>7.bytearray([source, [encoding, [errors]]])</h4> 
<p><strong>参数</strong>–source：要转化的对象<br> encoding：字符串的编码格式<br> errors：默认值为"strict"（？？？）<br> <strong>返回值</strong>：根据参数的不同，有不同的返回值。返回值为字符数组，数组元素可变。<br> a.当source为空时，返回长度为0的字符数组<br> b.当source为字符串时，必须要给encode参数赋值。返回经过encode<br> 编码的字符数组。<br> c.当source为int时，返回长度为source的空数组。<br> d.当source为缓冲区的对象时，会用只读的方式将对象按字节读取到字符数组后返回。<br> e.当source为可迭代对象时，则此对象的元素必须属于集合[0，256)，以便初始化到字符数组。<br> <a href="https://blog.csdn.net/u012950066/article/details/78617773">应用技巧</a><br> 示例：</p> 
<pre><code>&gt;&gt;&gt; bytearray()   #参数为空
bytearray(b'')

&gt;&gt;&gt; bytearray(10)           #整数
bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')

&gt;&gt;&gt; bytearray("中文",'utf-8')   #字符串
bytearray(b'\xe4\xb8\xad\xe6\x96\x87')

&gt;&gt;&gt; bytearray([1,0,1,1,1,0,1])    #可迭代对象
bytearray(b'\x01\x00\x01\x01\x01\x00\x01')

&gt;&gt;&gt; bytearray([1.2, 2])            #可迭代对象的元素必须是整数
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'float' object cannot be interpreted as an integer

&gt;&gt;&gt; bytearray([1,256,2])          #可迭代对象的元素必须是range(0,256)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: byte must be in range(0, 256)
</code></pre> 
<h4><a id="8bytessource_encoding_errors_163"></a>8.bytes([source, [encoding, [errors]]])</h4> 
<p><strong>参数</strong>–source：要转化的对象<br> encode：字符串的编码格式<br> errors：默认值为"strict"<br> <strong>返回值</strong>：根据参数的不同，有不同的返回值。返回值为字符数组，数组元素不可变，是betyarray的不可变版本。返回值与bytearray()类似。<br> a.当source为空时，返回长度为0的字符数组<br> b.当source为字符串时，必须要给encode参数赋值。返回经过encode<br> 编码的字符数组。<br> c.当source为int时，返回长度为source的空数组。<br> d.当source为缓冲区的对象时，会用只读的方式将对象按字节读取到字符数组后返回。<br> e.当source为可迭代对象时，则此对象的元素必须属于集合[0，256)，以便初始化到字符数组。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; bytes(10)
b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
&gt;&gt;&gt; bytes("中文",'utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'
</code></pre> 
<h3><a id="C_182"></a>C</h3> 
<h4><a id="9callableobject_183"></a>9.callable(object)</h4> 
<p><strong>参数</strong>–object：对象<br> <strong>返回值</strong>：可调用返回True，不可调用返回False。callable() 函数用于检查一个对象是否是可调用的。如果返回 True，object 仍然可能调用失败；但如果返回 False，调用对象 object 绝对不会成功。<br> 对于函数、方法、lambda 函式、 类以及实现了 _ <strong>call</strong> _ 方法的<strong>类实例</strong>, 它都返回 True。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; callable(10)    #常数
False
&gt;&gt;&gt; def add():     #方法
...     print("11")
...
&gt;&gt;&gt; callable(add)
True
&gt;&gt;&gt; class A():    #类， 没有实现__call__()方法
...     def __init__(self):
...             x = 10
...
&gt;&gt;&gt; callable(A)
True
&gt;&gt;&gt; a = A()     #类实例
&gt;&gt;&gt; callable(a)
False
&gt;&gt;&gt; class B():       #类，实现__call__()方法
...     def __call__(self):
...             return 0
&gt;&gt;&gt; callable(B)
True
&gt;&gt;&gt; b = B()
&gt;&gt;&gt; callable(b)
True
&gt;&gt;&gt;
</code></pre> 
<h4><a id="10chrx_216"></a>10.chr(x)</h4> 
<p><strong>参数</strong>–x：10进制或者16进制的整数，x&gt;=0。<br> <strong>返回值</strong>：返回对应的ascii码字符。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; chr(0)
'\x00'
&gt;&gt;&gt; chr(1)
'\x01'
&gt;&gt;&gt; chr(52)
'4'
&gt;&gt;&gt; chr(97)
'a'
&gt;&gt;&gt; chr(10000)
'✐'
&gt;&gt;&gt; chr(-1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: chr() arg not in range(0x110000)
</code></pre> 
<p>11.classmethod()<br> 描述：装饰器的一种与@联用。返回一个经过装饰器装饰的函数。classmethod 修饰符对应的函数不需要实例化，不需要 self 参数，但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。<br> <strong>参数</strong>：无<br> <strong>返回值</strong>：返回函数的类方法。<br> 参考<a href="https://blog.csdn.net/qq_18525247/article/details/95079501">112479的博客</a><br> 示例：</p> 
<pre><code>class A():
    q = 10
    def __init__(self, s):
        print(s)

    @classmethod
    def testmethod(cls):
        print(cls.q)        #经@classmethod修饰，可直接使用类的属性
        return cls(123)

t = A.testmethod()  #经@classmethod修饰可不初始化直接调用
</code></pre> 
<p>执行结果：</p> 
<pre><code>10
123
</code></pre> 
<p>这里的执行顺序是A -&gt;testmethod -&gt; _ <strong>init</strong> _<br> 另外 cls是个位置参数，可更换为其他名称，如 this。<br> 示例：</p> 
<pre><code>class A():
    q = 10
    def __init__(self, s):
        print(s)

    @classmethod
    def testmethod(this):
        print(this.q)
        return this(123)

t = A.testmethod()
</code></pre> 
<p>执行结果：</p> 
<pre><code>10
123
</code></pre> 
<h4><a id="12compilesourcefilename_mode_flags_dont_inheritoptimize__1_288"></a>12.compile(source，filename， mode[， flags， [dont_inherit，optimize = -1]])</h4> 
<p><strong>描述</strong>：将字符串编译成字节代码。<br> <strong>参数</strong>–source：字符串或AST对象。<br> filename：需要的是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 ‘&lt;string&gt;’）<br> mode：mode 实参指定了编译代码必须用的模式。如果 source 是语句序列，可以是 ‘exec’；如果是单一表达式，可以是 ‘eval’；如果是单个交互式语句，可以是 ‘single’。（在最后一种情况下，如果表达式执行结果不是 None 将会被打印出来。）<br> flags和dont_inherit是用来控制编译源码时的标志<br> optimize：optimize 实参指定编译器的优化级别；默认值 -1 选择与解释器的 -O 选项相同的优化级别。显式级别为 0 （没有优化；<strong>debug</strong> 为真）、1 （断言被删除， <strong>debug</strong> 为假）或 2 （文档字符串也被删除）。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; str = "for i in range(10): print(i)"
&gt;&gt;&gt; c = compile(str, "", "exec")
&gt;&gt;&gt; c
&lt;code object &lt;module&gt; at 0x0000029C7FA48030, file "", line 1&gt;
&gt;&gt;&gt; exec(c)
0
1
2
3
4
5
6
7
8
9
&gt;&gt;&gt; str = "3 + 5 * 4"
&gt;&gt;&gt; d = compile(str, "", "eval")
&gt;&gt;&gt; eval(d)
23
&gt;&gt;&gt; exec(d)   #不是指定的mode，不能得出结果。
</code></pre> 
<p>如果是单一表达式，只能是eval；使用exec不会报错但得不到结果。<br> 在 ‘single’ 或 ‘eval’ 模式编译多行代码字符串时，输入必须以至少一个换行符结尾。 这使 code 模块更容易检测语句的完整性。</p> 
<h4><a id="13complexreal_imag_322"></a>13.complex([real [，imag])</h4> 
<p><strong>描述</strong>：将字符串或数字转换为复数。<br> <strong>参数</strong>–real：实数部分，可以是int，也可以是string<br> image：虚数部分<br> 如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有第二个形参。第二个形参不能是字符串。每个实参都可以是任意的数值类型（包括复数）。如果省略了 imag，则默认值为零，构造函数会像 int 和 float 一样进行数值转换。如果两个实参都省略，则返回 0j。<br> <strong>返回值</strong>：返回一个 大小为 real + imag * j 的复数</p> 
<p><strong>注意：从字符串转换时，字符串在 + 或 - 的周围必须不能有空格。例如 complex(‘1+2j’) 是合法的，但 complex(‘1 + 2j’) 会触发 ValueError 异常。</strong><br> 示例：</p> 
<pre><code>&gt;&gt;&gt; complex(1)
(1+0j)
&gt;&gt;&gt; complex(1, -1)
(1-1j)

&gt;&gt;&gt; complex("1", -1)     #当第一个参数为字符串，不能有第二个参数
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: complex() can't take second arg if first is a string

&gt;&gt;&gt; complex(1+1j, -1)   #参数可以是复数
(1+0j)
&gt;&gt;&gt; complex("1+1j")
(1+1j)

&gt;&gt;&gt; complex("1 + 1j")   #注意 ‘+’ / ‘-’ 周围不能有空格
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: complex() arg is a malformed string
</code></pre> 
<h3><a id="D_354"></a>D</h3> 
<h4><a id="14delattrobjectname_355"></a>14.delattr(object，name)</h4> 
<p><strong>描述</strong>：删除一个对象的某个属性。实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。例如 delattr(x, ‘foobar’) 等价于 del x.foobar 。</p> 
<p><strong>参数</strong>–object：对象<br> name：该对象的某个属性名称，是个字符串s。<br> <strong>返回值</strong>：无<br> 示例：</p> 
<pre><code>class test():
    a = 1
    b = 2

t = test()
print(t.a)
print(t.b)
delattr(test, "b")
print(t.a)
print(t.b)
</code></pre> 
<p>执行结果：</p> 
<pre><code>1
2
1
Traceback (most recent call last):
  File "c:/Users/hasee/Desktop/111-1.py", line 74, in &lt;module&gt;
    print(t.b)
AttributeError: 'test' object has no attribute 'b'

</code></pre> 
<h4><a id="15dict_387"></a>15.dict()</h4> 
<p><strong>描述</strong>：创建一个新的字典。共有三种形式dict(**kwarg)，dict(mapping，**kwarg)，dict(iterable，**kwarg)<br> <strong>参数</strong>–**kwarg：关键字<br> mapping：元素的容器<br> iterable：可迭代的对象<br> 示例：</p> 
<pre><code>#五种字典初始化方法
&gt;&gt;&gt; dict1 = {}
&gt;&gt;&gt; dict1['firstname'] = 'ma'
&gt;&gt;&gt; dict1['lastname'] = 'yun'
&gt;&gt;&gt;
&gt;&gt;&gt; dict1 = {'firstname':'ma', 'lastname':'yun'}
&gt;&gt;&gt;
&gt;&gt;&gt; dict1 = dict([('firstname','ma'), ('lastname', 'yun')])
&gt;&gt;&gt;
&gt;&gt;&gt; dict1 = dict(firstname = 'ma', lastname = 'yun')
&gt;&gt;&gt;
&gt;&gt;&gt; dict1 = dict(zip(['firstname', 'lastname'], ['ma', 'yun']))
</code></pre> 
<h4><a id="16dirobject_408"></a>16.dir(object)</h4> 
<p><strong>描述</strong>：如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。<br> <strong>参数</strong>–object：对象，类型，变量<br> 示例：</p> 
<pre><code>&gt;&gt;&gt;dir()   #  获得当前模块的属性列表
['__builtins__', '__doc__', '__name__', '__package__', 'arr', 'myslice']
&gt;&gt;&gt; dir([ ])    # 查看列表的方法
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
</code></pre> 
<h4><a id="17divmodab_419"></a>17.divmod(a，b)</h4> 
<p><strong>描述</strong>：divmod() 函数接收两个数字类型（非复数）参数，返回一个包含商和余数的元组(a // b, a % b)。<br> <strong>参数</strong>–a：数字，非复数<br> b：数字，非复数<br> <strong>返回值</strong>：对于整数（a//b，a%b），对于浮点数，结果是 (q, a % b) ，q 通常是 math.floor(a / b) 但可能会比 1 小。在任何情况下， q * b + a % b 和 a 基本相等；如果 a % b 非零，它的符号和 b 一样，并且 0 &lt;= abs(a % b) &lt; abs(b) 。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; divmod(3,2)
(1, 1)
&gt;&gt;&gt; divmod(-3,2)
(-2, 1)
&gt;&gt;&gt; divmod(3,-2)       #当余数不为0时，余数的符号与 b 相同
(-2, -1)
&gt;&gt;&gt; divmod(3.2,2)
(1.0, 1.2000000000000002)
&gt;&gt;&gt; divmod(3.3,3)                  
(1.0, 0.2999999999999998)    #当是浮点数时，结果是近似
&gt;&gt;&gt; divmod(3.3,4)
(0.0, 3.3)
</code></pre> 
<h3><a id="E_441"></a>E</h3> 
<h4><a id="18enumerateiterablestart__0_443"></a>18.enumerate(iterable，start = 0)</h4> 
<p><strong>描述</strong>：接收一个元组，返回一个枚举对象。<br> <strong>参数</strong>–iterable：一个序列、迭代器或其他支持迭代对象。<br> start：序号的起始，默认为0。<br> <strong>返回值</strong>：返回一个枚举对象。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; for i in enumerate(a):
...     print(i)
...
(0, 'a')
(1, 'b')
(2, 'c')
#对于字典，会枚举输出关键字
&gt;&gt;&gt; d = dict(firstname = "zhong",lastname = "guo")
&gt;&gt;&gt; for i in enumerate(d):
...     print(i)
...
(0, 'firstname')
(1, 'lastname')
</code></pre> 
<h4><a id="19evalexpression_globalsNone_localsNone_465"></a>19.eval(expression, globals=None, locals=None)</h4> 
<p><strong>描述</strong>：接收一个字符串表达式，返回其计算结果。<br> <strong>参数</strong>–expression：字符串表达式<br> globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。<br> locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。<br> <strong>返回值</strong>：表达式的计算结果。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; eval("3 + 4 &gt; 10")
False
&gt;&gt;&gt; x = 2
&gt;&gt;&gt; eval("3*x")
6
&gt;&gt;&gt; d = dict(x = 7, y = 8, z = 9)
&gt;&gt;&gt; eval("y + z", "", d)      #globals 不能为 ""
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: globals must be a real dict; try eval(expr, {}, mapping)
&gt;&gt;&gt; c = {}
&gt;&gt;&gt; eval("y+z", c, d)
17
&gt;&gt;&gt; eval("y+z", d)  
17
</code></pre> 
<p><strong>小技巧：</strong><br> A.eval()可以去掉字符串的引号，返回字符串本身<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; a = "123"
&gt;&gt;&gt; eval(a)
123
</code></pre> 
<p>B.可以用来直接读取用户输入的多个数据</p> 
<pre><code>&gt;&gt;&gt; a, b = input()   #直接input()不能同时输入多个数据
10,5
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: too many values to unpack (expected 2)

&gt;&gt;&gt; a, b = eval(input())   
10,5
&gt;&gt;&gt; print(a,b)
10 5
</code></pre> 
<h4><a id="20execobject_globals_locals_514"></a>20.exec(object[, globals[, locals]])</h4> 
<p><strong>描述</strong>：exec 执行储存在字符串或文件中的 Python 语句，相比于 eval，exec可以执行更复杂的 Python 代码。<br> <strong>参数</strong>–object：必选参数，表示需要被指定的Python代码。它必须是字符串或code对象。如果object是一个字符串，该字符串会先被解析为一组Python语句，然后在执行（除非发生语法错误）。如果object是一个code对象，那么它只是被简单的执行。<br> globals：可选参数，表示全局命名空间（存放全局变量），如果被提供，则必须是一个字典对象。<br> locals：可选参数，表示当前局部命名空间（存放局部变量），如果被提供，可以是任何映射对象。如果该参数被忽略，那么它将会取与globals相同的值。<br> <strong>返回值</strong>：None<br> 示例：</p> 
<pre><code>x = 10
y = 10
expr = """
z = 30
sum = x + y + z
print(sum)
"""
def func():
    y = 20
    exec(expr)  # 默认使用最近的参数  计算过程为 30 + 20 +10
    exec(expr, {'x': 1, 'y': 2})   #计算过程为  30 + 1 + 2
    exec(expr, {'x': 1, 'y': 2}, {'y': 3, 'z': 4})  # 外部参数不能替代原本字符串里面的值，且当globals与locals有相同参数时优先使用locals的
    
func()
</code></pre> 
<p>执行结果：</p> 
<pre><code>60
33
34
</code></pre> 
<h3><a id="F_546"></a>F</h3> 
<h4><a id="21filterfunctioniterable_547"></a>21.filter(function，iterable)</h4> 
<p><strong>描述</strong>：根据function对iterable进行筛选，符合条件的留下，不符合的剔除，构建新的迭代器。<br> <strong>参数</strong>–function：判断函数。<br> iterable：可迭代对象。<br> <strong>返回值</strong>：新的可迭代对象。<br> 示例：</p> 
<pre><code>#选出1~100中平方根是整数的数
import math
def is_sqr(x):
    return math.sqrt(x) % 1 == 0
 
tmplist = filter(is_sqr, range(1, 101))
newlist = list(tmplist)
print(newlist)
</code></pre> 
<p>执行结果：</p> 
<pre><code>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre> 
<h4><a id="22floatx_570"></a>22.float([x])</h4> 
<p><strong>描述</strong>：将字符串或整数转化为浮点型。<br> <strong>参数</strong>–x：字符串或者整数。如果实参是字符串，则它必须是包含十进制数字的字符串，字符串前面可以有符号，之前也可以有空格。可选的符号有 ‘+’ 和 ‘-’ ； ‘+’ 对创建的值没有影响。实参也可以是 NaN（非数字）、正负无穷大的字符串。确切地说，除去首尾的空格后，输入必须遵循以下语法：</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>sign</td><td>“+” | “-”</td></tr><tr><td>infinity</td><td>“Infinity” | “inf”</td></tr><tr><td>nan</td><td>“nan”</td></tr><tr><td>numeric_value</td><td>floatnumber | infinity | nan</td></tr><tr><td>numeric_string</td><td>[sign] numeric_value</td></tr></tbody></table> 
<p><strong>返回值</strong>：返回浮点数。实参为空时返回 0.0<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; float("inf")
inf
&gt;&gt;&gt; float("nan")
nan
&gt;&gt;&gt; float("-3.14e10")
-31400000000.0
&gt;&gt;&gt; float()
0.0
</code></pre> 
<h4><a id="23formatvalue_format_spec_595"></a>23.format(value[, format_spec]))</h4> 
<p><strong>描述</strong>：用于格式化输出，取代%。将 value 转换为 format_spec 控制的“格式化”表示。<br> <strong>参数</strong>–value：要输出的值<br> format_spec：控制value输出的格式。<br> <strong>返回值</strong>：无<br> 示例：</p> 
<pre><code>&gt;&gt;&gt;"{} {}".format("hello", "world")    # 不设置指定位置，按默认顺序
'hello world'
 
&gt;&gt;&gt; "{0} {1}".format("hello", "world")  # 设置指定位置
'hello world'
 
&gt;&gt;&gt; "{1} {0} {1}".format("hello", "world")  # 设置指定位置
'world hello world'

&gt;&gt;&gt; format(255, '#x'), format(255, 'x'), format(255, 'X')  #设置format_spec 为16进制输出
('0xff', 'ff', 'FF')

&gt;&gt;&gt; f'{255:#x}', f'{255:x}', f'{255:X}'   #简化书写
('0xff', 'ff', 'FF')
</code></pre> 
<p>也可以设置参数名字：</p> 
<pre><code>&gt;&gt;&gt; print("name = {name}, age = {age}".format(name = "china", age = 70))  #直接设置参数值
name = china, age = 70

&gt;&gt;&gt; s = ["china", 70]                               #用单个列表保存实参值
&gt;&gt;&gt; print("name = {0}, age = {1}".format(*s))
name = china, age = 70

&gt;&gt;&gt; t1 = ["china"]								   #用多个列表保存实参值
&gt;&gt;&gt; t2 = [70]
&gt;&gt;&gt; print("name = {0[0]}, age = {1[0]}".format(t1,t2))
name = china, age = 70

&gt;&gt;&gt; t = dict(name = "china", age = 70)              #用字典保存实参值
&gt;&gt;&gt; print("name = {name}, age = {age}".format(**t))
name = china, age = 70
</code></pre> 
<p>更多详细使用技巧参考<a href="https://www.runoob.com/python/att-string-format.html" rel="nofollow">菜鸟教程</a></p> 
<h4><a id="24frozensetiterable_639"></a>24.frozenset([iterable])</h4> 
<p><strong>描述</strong>：返回一个冻结的集合，不能再对此集合进行增删操作。<br> <strong>参数</strong>–iterable： 可迭代的对象，比如列表、字典、元组等等。<br> <strong>返回值</strong>：返回一个forzenset对象，该对象的元素来自于iterable。没有实参则返回一个空集合。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt;a = frozenset(range(10))     # 生成一个新的不可变集合
&gt;&gt;&gt; a
frozenset([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; b = frozenset('runoob') 
&gt;&gt;&gt; b
frozenset(['b', 'r', 'u', 'o', 'n'])   # 创建不可变集合
</code></pre> 
<h3><a id="G_654"></a>G</h3> 
<h4><a id="25getattrobject_namedefault_655"></a>25.getattr(object， name[，default])</h4> 
<p><strong>描述</strong>：获得对象(object)名字为name的属性。<br> <strong>参数</strong>–object：对象<br> name：字符串，想要获取的属性的名字。<br> default：当要获取的属性不存在时的默认返回值。如果不提供，当属性不存在时将触发 AttributeError。可以是字符串，可以是数字类型，也可以是函数。可以认为是异常处理手段。<br> <strong>返回值</strong>：返回对应属性的值。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; class A():
...     x = 10
...     y = 15
...
&gt;&gt;&gt;
&gt;&gt;&gt; getattr(A,"x")
10
&gt;&gt;&gt;
&gt;&gt;&gt; getattr(A, "z", -1)
-1
&gt;&gt;&gt;
&gt;&gt;&gt; getattr(A, "z", "无此属性")   #default 可以是字符串
'无此属性'
&gt;&gt;&gt;
&gt;&gt;&gt; def test():       #default 可以是函数
...     print("111")
...
&gt;&gt;&gt; getattr(A, "z", test())
111
</code></pre> 
<p>此外也可以获取方法。<br> 示例：</p> 
<pre><code>class A():
    def set(self, a, b):
        print(a + b)
    x = 10

a = A()
c = getattr(a, "set")   #获取到对象的方法 并且可以直接使用
c(1, 2)
</code></pre> 
<p>执行结果：</p> 
<pre><code>3
</code></pre> 
<h4><a id="26globals_702"></a>26.globals()----</h4> 
<p><strong>描述</strong>：函数会以字典类型返回当前位置的全部全局变量。<br> <strong>参数</strong>：无<br> <strong>返回值</strong>：返回全局变量的字典。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; class A():
...     x = 10
...
&gt;&gt;&gt;
&gt;&gt;&gt; print(globals())
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__':
{}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'A': &lt;class '__main__.A'&gt;}
</code></pre> 
<h3><a id="H_718"></a>H</h3> 
<h4><a id="27hasattrobjectname_720"></a>27.hasattr(object，name)</h4> 
<p><strong>描述</strong>：用于判断对象是否包含对应的属性。<br> <strong>参数</strong>–object：对象。<br> name：属性名称，字符串。<br> <strong>返回值</strong>：如果对象有该属性返回 True，否则返回 False。<br> 示例：</p> 
<pre><code>class A():
    def set(self, a, b):
        print(a + b)
    x = 10

print(hasattr(A, "set"))
print(hasattr(A, "x"))

</code></pre> 
<p>执行结果：</p> 
<pre><code>True
True
</code></pre> 
<h4><a id="28hashobject_744"></a>28.hash(object)</h4> 
<p><strong>描述</strong>：返回该对象的哈希值（如果它有的话）。<br> <strong>参数</strong>–object：对象。一般是整型，浮点型，字符串。不能直接是list，set，dictionary。<br> <strong>返回值</strong>：对象的hash值。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; hash("qwer")
3620707056588834181

&gt;&gt;&gt; hash("qwrerthlfbkncndfjoidddviofj")
-3805363231758489070

&gt;&gt;&gt; hash("qwrerthlfbkncndfjoidddviofj")
-3805363231758489070
</code></pre> 
<p><strong>可以看出同一个值的hash值相同，可以利用这一点来校验字符串是否被第三方篡改。</strong></p> 
<h4><a id="29helpobject_762"></a>29.help([object])</h4> 
<p><strong>描述</strong>：用于查看函数或模块用途的详细说明。<br> <strong>参数</strong>–object：对象。<br> <strong>返回值</strong>：返回对象帮助信息。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; help(math)   #查询模块信息
Help on built-in module math:

NAME
    math

DESCRIPTION
    This module is always available.  It provides access to the
    mathematical functions defined by the C standard.
......

&gt;&gt;&gt; help(math.sin)  #查询函数信息
Help on built-in function sin in module math:

sin(x, /)
    Return the sine of x (measured in radians).
</code></pre> 
<h4><a id="30hexx_788"></a>30.hex(x)</h4> 
<p><strong>描述</strong>：将整数转换为以“0x”为前缀的小写十六进制字符串。<br> <strong>参数</strong>–x：整数。<br> <strong>返回值</strong>：小写的十六进制字符串。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; hex(16)
'0x10'

&gt;&gt;&gt; "%x" %10    #用 %x 转换进制
'a'

&gt;&gt;&gt; format(10,  "#x")    #用format转换进制
'0xa'

&gt;&gt;&gt; f'{255:#x}', f'{255:x}', f'{255:X}'  
('0xff', 'ff', 'FF')
</code></pre> 
<h3><a id="I_808"></a>I</h3> 
<h4><a id="31idobject_810"></a>31.id(object)</h4> 
<p><strong>描述</strong>：返回对象在内存中的地址。<br> <strong>参数</strong>–object：对象。<br> <strong>返回值</strong>：对象在内存中的地址。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; a = "china"
&gt;&gt;&gt; id(a)
1739113113224
&gt;&gt;&gt; b = 10
&gt;&gt;&gt; id(b)
140733210059696
</code></pre> 
<h4><a id="32inputprompt_825"></a>32.input([prompt])</h4> 
<p><strong>描述</strong>：Python3.x 中 input() 函数接受一个标准输入数据，返回为 string 类型。在 Python3.x 中 raw_input() 和 input() 进行了整合，去除了 raw_input( )，仅保留了input( )函数，其接收任意任性输入，将所有输入默认为字符串处理，并返回字符串类型。<br> <strong>参数</strong>–prompt：提示信息<br> <strong>返回值</strong>：以字符串形式返回输入的内容。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; num = input()
10
&gt;&gt;&gt; num
'10'
&gt;&gt;&gt; temp = input("请输入数字temp：")
请输入数字temp：10
&gt;&gt;&gt; temp
'10'
</code></pre> 
<h4><a id="33intx_base__10_842"></a>33.int(x, base = 10)</h4> 
<p><strong>描述</strong>：用于将一个字符串或数字转换为整型。<br> <strong>参数-</strong>-x：字符串或数字。如果 x 不是数字，或者有 base 参数，<strong>x 必须是字符串、bytes、表示进制为 base 的 整数字面值 的 bytearray 实例</strong>。该文字前可以有 + 或 - （中间不能有空格），前后可以有空格。<br> <strong>返回值</strong>：返回10进制整型数据。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; int()
0
&gt;&gt;&gt; int("123", 10) 
123
&gt;&gt;&gt; int("123", 16)    #当有base = 8时，表示123为八进制数
291
&gt;&gt;&gt; int("123", 8)  
83
</code></pre> 
<h4><a id="34isinstanceobjectclassinfo_859"></a>34.isinstance(object，classinfo)</h4> 
<p><strong>描述</strong>：isinstance() 函数来判断一个对象是否是一个已知的类型的实例，类似 type()。<br> <strong>参数</strong>–object：实例对象。<br> classinfo：可以是直接或间接类名、基本类型或者由它们组成的元组。<br> <strong>返回值</strong>：如果 object 实参是 classinfo 实参的实例，或者是（直接、间接或 虚拟）子类的实例，则返回 true。如果 object 不是给定类型的对象，函数始终返回 false。如果 classinfo 是对象类型（或多个递归元组）的元组，如果 object 是其中的任何一个的实例则返回 true。 如果 classinfo 既不是类型，也不是类型元组或类型的递归元组，那么会触发 TypeError 异常。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt;a = 2
&gt;&gt;&gt; isinstance (a,int)
True
&gt;&gt;&gt; isinstance (a,str)
False
&gt;&gt;&gt; isinstance (a,(str,int,list))    # 是元组中的一个返回 True
True
</code></pre> 
<p>isinstance()与type()的区别：</p> 
<pre><code>class A:
    pass
 
class B(A):
    pass
 
print(isinstance(A(), A) )   # returns True
print(type(A()) == A)        # returns True
print(isinstance(B(), A))  # returns True
print(type(B()) == A )       # returns False
</code></pre> 
<p>执行结果：</p> 
<pre><code>True
True
True
False
</code></pre> 
<p><strong>从上可以看出type()不能识别出子类。</strong><br> 此外注意在classinfo中字符串是 <strong>str</strong> 不是string，字典是 <strong>dict</strong>。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; a = 123
&gt;&gt;&gt; isinstance(a, str)
False

&gt;&gt;&gt; isinstance(a, string)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'string' is not defined
</code></pre> 
<h4><a id="35issubclassclass_classinfo_912"></a>35.issubclass(class, classinfo)</h4> 
<p><strong>描述</strong>：用于判断参数 class 是否是类型参数 classinfo 的子类。方法与isinstance()类似。<br> <strong>参数</strong>–class ：子类。<br> classinfo ：父类。<br> <strong>返回值</strong>：如果 class 是 classinfo 的子类（直接、间接或 虚拟 的），则返回 true。classinfo 可以是类对象的元组，此时 classinfo 中的每个元素都会被检查。其他情况，会触发 TypeError 异常。<br> 示例：</p> 
<pre><code>class A:
    pass
 
class B(A):
    pass

print(issubclass(B, A))
</code></pre> 
<p>执行结果：</p> 
<pre><code>True
</code></pre> 
<h4><a id="36iterobject_sentinel_934"></a>36.iter(object[, sentinel])----</h4> 
<p><strong>描述</strong>：iter() 函数用来生成迭代器。<br> <strong>参数</strong>–object： 支持迭代的集合对象。<br> sentinel：如果传递了第二个参数，则参数 object 必须是一个可调用的对象（如，函数），此时，iter 创建了一个迭代器对象，每次调用这个迭代器对象的__next__()方法时，都会调用 object。可以认为是一个终止符。<br> <strong>返回值</strong>：迭代器对象。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt;lst = [1, 2, 3]
&gt;&gt;&gt; for i in iter(lst):
...     print(i)
... 
1
2
3
</code></pre> 
<p>详细使用可参考<a href="https://www.cnblogs.com/xiao-apple36/p/9519114.html" rel="nofollow">一只小小寄居蟹的博客</a></p> 
<h4><a id="37lens_953"></a>37.len(s)</h4> 
<p><strong>描述</strong>：返回对象中元素的个数。<br> <strong>参数</strong>–s：可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）。<br> <strong>返回值</strong>：对象s中元素的个数。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; str = "abcdefg"
&gt;&gt;&gt; len(str)
7

&gt;&gt;&gt; e = {1, 2, 3, 4, 5}
&gt;&gt;&gt; len(e)
5
</code></pre> 
<h4><a id="38listiterable_969"></a>38.list([iterable])</h4> 
<p>描述：用于将元组或字符串转换为列表。<br> 参数–iterable：要转换为列表的元组或字符串。<br> 返回值：返回一个列表。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; tuple = {1, "a", 32, "cd" }
&gt;&gt;&gt; temp = list(tuple)    #将元组转换成了列表，可以再次对其进行修改
&gt;&gt;&gt; temp.append(4)
&gt;&gt;&gt; temp
[32, 1, 'cd', 'a', 4]
</code></pre> 
<h4><a id="39locals_983"></a>39.locals()</h4> 
<p>描述：更新并返回表示当前本地符号表的字典。<br> 参数：无<br> 返回值：更新并返回表示当前本地符号表的字典。<br> 示例：</p> 
<pre><code>class A():
    x = 10
    def test(self, a, b):
        y = 20
        print(locals())      #locals的范围小，当在方法中使用时指方法的全局变量

print(globals())        #globals范围大，一般指模块内的全局变量
a = A()
a.test(1, 2)
</code></pre> 
<p>执行结果：</p> 
<pre><code>{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x0000025803BBEEF0&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': 'c:/Users/hasee/Desktop/111-1.py', '__cached__': None, 'A': &lt;class '__main__.A'&gt;}
{'self': &lt;__main__.A object at 0x0000025805821438&gt;, 'a': 1, 'b': 2, 'y': 20}
</code></pre> 
<h3><a id="M_1007"></a>M</h3> 
<h4><a id="40mapfunctioniterable_1009"></a>40.map(function，iterable，…)</h4> 
<p><strong>描述</strong>：根据提供的函数对指定序列做映射。<br> <strong>参数</strong>–function：函数。<br> iterable：序列<br> <strong>返回值</strong>：返回一个经过function映射的迭代器。 如果传入了额外的 iterable 参数，function 的映射操作会从每一个iterable对应位置取一个值进行计算。 当有多个可迭代对象时，最短的可迭代对象耗尽则整个迭代就将结束。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt;def square(x) :            # 计算平方数
...     return x ** 2
... 
&gt;&gt;&gt; for i in map(square, [1,2,3,4,5]):# 计算列表各个元素的平方
...     print(i)

#使用匿名函数
&gt;&gt;&gt; for i in map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10, 12]):
...     print(i)
...
3
7
11
15
19
 
</code></pre> 
<p>与filter()的区别：filter 是通过生成 True 和 False 组成的迭代器将可迭代对象中不符合条件的元素过滤掉；而 map 返回的则是 True 和 False 组成的迭代器。</p> 
<pre><code>&gt;&gt;&gt; res1 = map(lambda n: n &gt; 5, range(10))
&gt;&gt;&gt; lt1 = list(res1)
&gt;&gt;&gt; print(lt1)
[False, False, False, False, False, False, True, True, True, True]

&gt;&gt;&gt; res2 = filter(lambda n: n &gt; 5, range(10))
&gt;&gt;&gt; lt = list(res2)
&gt;&gt;&gt; print(lt) 
[6, 7, 8, 9]
</code></pre> 
<h4><a id="41maxiterable__key_default_1049"></a>41.max(iterable, *[, key, default])</h4> 
<p><strong>描述</strong>：获取序列中值最大的元素。还有一种写法为 <strong>max(arg1, arg2, *args[, key])</strong><br> <strong>参数</strong>–当只有一个位置参数时，必须是非空的iterable。<br> iterable：列表，元组，字典等。<br> key：指定排序函数用的参数<br> default：当可迭代对象为空时返回的值。<br> <strong>返回值</strong>：如果只提供了一个位置参数，返回可迭代对象中最小的元素；如果提供了两个及以上的位置参数，则返回最小的位置参数。如果有多个最小元素，则此函数将返回第一个找到的。<br> 示例：</p> 
<pre><code>t1 = (2, "wang")
t2 = (3, "zhao")
t3 = (4, "li")

print(max(t3, t2, t1, key = lambda x: x[0]))  # key 一般用关键字 + 匿名函数来表示
</code></pre> 
<p>执行结果：</p> 
<pre><code>(4, 'li')
</code></pre> 
<h4><a id="42memoryviewobject_1071"></a>42.memoryview(object)</h4> 
<p><strong>描述</strong>：memoryview() 函数返回给定参数的内存查看对象(Momory view)。<br> 所谓内存查看对象，是指对支持缓冲区协议的数据进行包装，在<strong>不需要复制对象</strong>基础上允许Python代码访问。<br> <strong>参数</strong>–object：必须支持缓冲区协议的对象，支持缓冲区协议的内置对象包括 bytes 和 bytearray。<br> <strong>返回值</strong>：返回元组列表。<br> 示例：</p> 
<pre><code>&gt;&gt; a = b"aaaaa"
&gt;&gt;&gt; ma = memoryview(a)
&gt;&gt;&gt; ma.readonly   #只读memoryview
True
&gt;&gt;&gt; mb = ma[:2]   #不会产生新的字符串
&gt;&gt;&gt; mb = "bb"
&gt;&gt;&gt; ma.tobytes()
b'aaaaa'

&gt;&gt;&gt; a = bytearray('aaaa', "utf8")
&gt;&gt;&gt; ma = memoryview(a)
&gt;&gt;&gt; mb = ma[:2]
&gt;&gt;&gt; mb.readonly      #可写memoryview
False
&gt;&gt;&gt; mb[:2] = b"bb"   #修改mb相当于修改ma，同时注意赋值方法
&gt;&gt;&gt; mb.tobytes()
b'bb'
&gt;&gt;&gt; ma.tobytes()
b'bbaa'
</code></pre> 
<p>详细使用技巧可参考<a href="https://segmentfault.com/q/1010000007137721" rel="nofollow">这里</a></p> 
<h4><a id="43miniterable__key_default_1102"></a>43.min(iterable, *[, key, default])</h4> 
<p><strong>描述</strong>：获取序列中值最小的元素。还有一种写法为 <strong>min(arg1, arg2, *args[, key])</strong><br> <strong>参数</strong>–当只有一个位置参数时，必须是非空的iterable。<br> iterable：列表，元组，字典等。<br> key：指定排序函数用的参数<br> default：当可迭代对象为空时返回的值。<br> <strong>返回值</strong>：如果只提供了一个位置参数，返回可迭代对象中最小的元素；如果提供了两个及以上的位置参数，则返回最小的位置参数。如果有多个最小元素，则此函数将返回第一个找到的。<br> 示例：</p> 
<pre><code>t1 = (2, "wang")
t2 = (3, "zhao")
t3 = (4, "li")

print(min(t3, t2, t1, key = lambda x: x[0]))  # key 一般用关键字 + 匿名函数来表示
</code></pre> 
<p>执行结果：</p> 
<pre><code>(2, "wang")
</code></pre> 
<h3><a id="N_1123"></a>N</h3> 
<h4><a id="44nextiteratordefault_1125"></a>44.next(iterator[，default])</h4> 
<p><strong>描述</strong>：返回迭代器的下一个项目。<br> <strong>参数</strong>–iterable：迭代器。<br> default：用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 StopIteration 异常。<br> <strong>返回值</strong>：迭代器中的一个元素。当下一个元素不存在，且default不为空将返回default 的值，否则抛出StopIteration异常。<br> <strong>注意</strong>：list，dict，set 都不是迭代器，不能直接使用next()，需要使用 iter() 方法将其转化为iterator<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; lst = [1, 3, 4, 6]
&gt;&gt;&gt; next(lst)    #不能直接使用
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'list' object is not an iterator

&gt;&gt;&gt; next(iter(lst))    #用名称只能获取到第一个元素
1

&gt;&gt;&gt; lst = iter(lst)  #结合循环使用时，要先转化成 iterator
&gt;&gt;&gt; while 1:
...     x = next(lst, "a")    #设置default
...     print(x)
...     if x == "a":
...             break
...
1
3
4
6
a
</code></pre> 
<h3><a id="O_1157"></a>O</h3> 
<h4><a id="45object_1159"></a>45.object()</h4> 
<p><strong>描述</strong>：返回一个没有特征的对象。<br> <strong>参数</strong>：无。<br> <strong>返回值</strong>：返回一个object类的实例。object 是所有类的基类。它具有所有 Python 类实例的通用方法。<br> <strong>注意</strong>：由于 object 没有 _ _dict_ _ ，因此无法将任何属性赋给 object 的实例。</p> 
<p>示例：</p> 
<pre><code>&gt;&gt;&gt; o = object()
&gt;&gt;&gt; dir(o)      #object 有所有类的公共方法
['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__',
'__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']

&gt;&gt;&gt; class A:
...     x = 10
...

&gt;&gt;&gt; issubclass(A, object)  #object 是所有类的基类
True

&gt;&gt;&gt; a = A()  
&gt;&gt;&gt; a.name = "wang"   #普通类可以设置属性

&gt;&gt;&gt; o.name = "wang"    #object 不可以设置属性
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'dict' object has no attribute 'name'
</code></pre> 
<h4><a id="46octx_1189"></a>46.oct(x)</h4> 
<p><strong>描述</strong>：将一个整数变成前缀为 "0o"的进制字符串。<br> <strong>参数</strong>–x：整数<br> <strong>返回值</strong>：八进制的字符串。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; oct(8)
'0o10'

&gt;&gt;&gt; oct(8.0)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'float' object cannot be interpreted as an integer
</code></pre> 
<h4><a id="47openfile_moder_buffering1_encodingNone_errorsNone_newlineNone_closefdTrue_openerNone_1205"></a>47.open(file, mode=‘r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</h4> 
<p><strong>描述</strong>：Python open() 函数用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。<br> <strong>参数</strong>–file：必需，文件路径（相对或者绝对路径）。<br> mode： 可选，文件打开模式。<br> buffering：设置缓冲。<br> encoding： 一般使用utf8。<br> errors： 是一个可选的字符串参数，用于指定如何处理编码和解码错误 - 这不能在二进制模式下使用。<br> newline：设置换行符。它可以是 None，’’，’\n’，’\r’ 和 ‘\r\n’。<br> closefd： 传入的file参数类型。<br> opener：<br> <strong>返回值</strong>：返回对应的file object，如果文件不存在，则触发OSError。<br> <strong>注意</strong>：使用 open() 函数一定要保证关闭文件对象，即调用 close() 函数。使用with open() 可以自动关闭文件对象。<br> open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; with open(r"C:\Users\hasee\Desktop\test.txt", "r") as f:
...     f.read()
...
'Hello World！'
</code></pre> 
<p>附表1 mode的类型</p> 
<table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>t</td><td>文本模式 (默认)。</td></tr><tr><td>x</td><td>写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr><td>b</td><td>二进制模式。</td></tr><tr><td>+</td><td>打开一个文件进行更新(可读可写)。</td></tr><tr><td>U</td><td>通用换行模式（不推荐）。</td></tr><tr><td>r</td><td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td>rb</td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td>r+</td><td>打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td>w</td><td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb</td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>w+</td><td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb+</td><td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>a</td><td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>ab</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>a+</td><td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td>ab+</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table> 
<p><strong>注意</strong>：1.Python区分二进制和文本I/O。以二进制模式打开的文件（包括 mode 参数中的 ‘b’ ）返回的内容为 bytes 对象，不进行任何解码。在文本模式下（默认情况下，或者在 mode 参数中包含 ‘t’）时，文件内容返回为 str ，首先使用指定的 encoding （如果给定）或者使用平台默认的的字节编码解码。</p> 
<p>2.a 与 a+ 的区别<br> a ：追加写，但是不能读。<br> a+：追加写，可读。但是文件指针在末尾，直接读取内容为空。</p> 
<p>示例：</p> 
<pre><code>&gt;&gt;&gt; with open(r"C:\Users\hasee\Desktop\test.txt", "a") as f:
...     f.read()    #  a 不能直接读取
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
io.UnsupportedOperation: not readable

&gt;&gt;&gt; with open(r"C:\Users\hasee\Desktop\test.txt", "a+") as f:
...     f.read()    # a+ 直接读取内容为空 
...
''
</code></pre> 
<p>附表二 设置buffering 的含义</p> 
<table><thead><tr><th>数值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>关闭缓冲，仅允许在二进制模式下</td></tr><tr><td>1</td><td>选择行缓冲，仅允许在文本模式下</td></tr><tr><td>&gt;1</td><td>以指示固定大小的块缓冲区的大小（以字节为单位）</td></tr></tbody></table> 
<p>附表三 errors 的类型</p> 
<table><thead><tr><th>模式</th><th>含义</th></tr></thead><tbody><tr><td>None</td><td>如果存在编码错误，会引发 ValueError 异常</td></tr><tr><td>strict</td><td>如果存在编码错误，会引发 ValueError 异常</td></tr><tr><td>ignore</td><td>忽略错误。请注意，忽略编码错误可能会导致数据丢失。</td></tr><tr><td>replace</td><td>会将替换标记（例如 ‘?’ ）插入有错误数据的地方。</td></tr><tr><td>surrogateescape</td><td>将表示任何不正确的字节作为Unicode专用区中的代码点，范围从U+DC80到U+DCFF。当在写入数据时使用 surrogateescape 错误处理程序时，这些私有代码点将被转回到相同的字节中。这对于处理未知编码的文件很有用。</td></tr><tr><td>xmlcharrefreplace</td><td>只有在写入文件时才支持 ‘xmlcharrefreplace’。编码不支持的字符将替换为相应的XML字符引用 &amp;#nnn;。</td></tr><tr><td>backslashreplace</td><td>用Python的反向转义序列替换格式错误的数据。</td></tr><tr><td>namereplace</td><td>(也只在编写时支持）用 \N{…} 转义序列替换不支持的字符。</td></tr></tbody></table> 
<p>注：转义序列即转义字符的集合，包括 \n，\r，\t，\u 等等。</p> 
<h4><a id="48ord_c__1292"></a>48.ord( c )</h4> 
<p><strong>描述</strong>：对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。<br> <strong>参数</strong>–c：单个的 Unicode 字符。<br> <strong>返回值</strong>：对应的 Unicode 码点的整数。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; ord("#")
35
</code></pre> 
<h3><a id="P_1303"></a>P</h3> 
<h4><a id="49powxyz_1305"></a>49.pow(x，y[，z])</h4> 
<p><strong>描述</strong>：返回 x 的 y 次幂；如果 z 存在，则对 z 取余。<br> <strong>参数</strong>–x：数值表达式<br> y：数值表达式<br> z：数值表达式<br> <strong>返回值</strong>：返回 x 的 y 次幂；如果 z 存在，则对 z 取余。<br> <strong>注意</strong>： math 模块中也包含 pow()方法，区别如下：</p> 
<table><thead><tr><th>区别</th><th>描述</th></tr></thead><tbody><tr><td>参数个数</td><td>math.pow() 只能有两个参数，内置的pow()可以有三个参数。</td></tr><tr><td>返回值类型</td><td>math.pow()默认返回float，内置的pow()默认返回int</td></tr></tbody></table> 
<p>示例：</p> 
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.pow(10, 2, 3)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: pow() takes exactly 2 arguments (3 given)

&gt;&gt;&gt; math.pow(10, 2)  
100.0

&gt;&gt;&gt; pow(10, 2, 3)
1

&gt;&gt;&gt; pow(3*2, 2*2)
1296
</code></pre> 
<h4><a id="50printobjects_sep__endn_filesysstdout_flushFalse_1335"></a>50.print(*objects, sep=’ ‘, end=’\n’, file=sys.stdout, flush=False)</h4> 
<p>描述：print() 方法用于打印输出，最常见的一个函数。print 在 Python3.x 是一个函数，但在 Python2.x 版本不是一个函数，只是一个关键字。<br> 参数–*objects：可以接收多个参数，中键用 ‘,’ 分隔开。<br> sep：间隔符，当接收多个输出值时，两两之间用 sep 间隔开，默认为空格。<br> end：结尾后缀。输出以什么结尾，默认为’\n’，可替换成其他合理值。<br> file：要写入的文件对象。如果参数不存在或为 None，则将使用 sys.stdout.<br> flush：当为真是，会强制刷新流。<br> 返回值：无。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; a = 123
&gt;&gt;&gt; b = "hello"
&gt;&gt;&gt; c = "world"
&gt;&gt;&gt; print(a, b, c, sep = "##", end = "&amp;&amp;")    #这里没有换行符
123##hello##world&amp;&amp;&gt;&gt;&gt;

&gt;&gt;&gt; print(a, b, c, sep = "##", end = "&amp;&amp;\n")
123##hello##world&amp;&amp;

&gt;&gt;&gt; with open(r"C:\Users\hasee\Desktop\test.txt", "a+") as f:
...     print(a, b, c, sep = "##", file = f)
...
&gt;&gt;&gt; with open(r"C:\Users\hasee\Desktop\test.txt", "r") as f:
...     f.read()
...
'Hello World！123##hello##world\n'
&gt;&gt;&gt;
</code></pre> 
<h4><a id="51propertyfgetNone_fsetNone_fdelNone_docNone_1365"></a>51.property(fget=None， fset=None， fdel=None， doc=None)</h4> 
<p><strong>描述</strong>：可以对属性进行封装，不直接调用属性。<br> <strong>参数</strong>–fget：获取属性值的函数<br> fset：设置属性值的函数<br> fdel：删除属性值的函数<br> doc：属性的描述信息<br> <strong>返回值</strong>：返回封装好的属性。<br> 示例：</p> 
<pre><code>class A:
    def __init__(self, value):
        self._x = value
    
    def getx(self):
        print("get self._x")
        return self._x
    
    def setx(self, value):
        print("set self._x")
        self._x = value
    
    def delx(self):
        print("del self._x")
        del self._x

    x = property(getx, setx, delx, "this is private _x")   #对私有属性进行封装

a = A(10)
print(a.x)
a.x = 20
print(a.x)
del a.x
print(a.x)
</code></pre> 
<p>执行结果：</p> 
<pre><code>get self._x
10
set self._x
get self._x
20
del self._x
get self._x
Traceback (most recent call last):
  File "c:/Users/hasee/Desktop/111-1.py", line 163, in &lt;module&gt;
    print(a.x)
  File "c:/Users/hasee/Desktop/111-1.py", line 146, in getx
    return self._x
AttributeError: 'A' object has no attribute '_x'
</code></pre> 
<p>a.x 将触发 getx，a.x = value 将触发 setx ， del a.x 触发 delx。<br> 如果给定 doc 参数，其将成为这个属性值的 docstring，否则 property 函数就会复制 fget 函数的 docstring（如果有的话）。<br> <strong>注意</strong>：python 中还有 @property 装饰器，可以将方法变为属性使用。具体使用可参照<a href="http://funhacks.net/explore-python/Class/property.html" rel="nofollow">Funhacks的博客</a></p> 
<h3><a id="R_1421"></a>R</h3> 
<h4><a id="52rangestartstopstep_1423"></a>52.range(start，stop[，step])</h4> 
<p>描述：Python3 range() 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。<br> Python3 list() 函数是对象迭代器，可以把range()返回的可迭代对象转为一个列表，返回的变量类型为列表。<br> Python2 range() 函数返回的是列表。<br> 参数–start：计数起始值，默认为 0 。<br> stop：计数结束值，将不会输出，即range的取值范围为[start，stop)。<br> step：步长。默认为1。<br> 返回值：返回一个序列对象range<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; x = range(5)
&gt;&gt;&gt; type(x)
&lt;class 'range'&gt;
&gt;&gt;&gt; for i in x:
...     print(i)
...
0
1
2
3
4

&gt;&gt;&gt; for i in range(0, 10, 2):
...     print(i)
...
0
2
4
6
8
</code></pre> 
<p><strong>注意</strong>：当有step不为空时，start 必须不为空，否则会出现错我的结果。<br> range的计算公式为 i = start + step 。所以范围为负数时要将 数值小的作为 start。同时可以将步长设为 -1 倒序遍历，此时应将start 设为大的值。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; for i in range(0, 10, -1):
...     print(i)
...
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; for i in range(5, 0, -1):
...     print(i)
...
5
4
3
2
1
&gt;&gt;&gt; for i in range(-4, -1):
...     print(i)
...
-4
-3
-2
</code></pre> 
<h4><a id="53reprobject_1484"></a>53.repr(object)</h4> 
<p><strong>描述</strong>：将对象转化成可输出的字符串，如果给与参数时可执行的语句，则先执行，再返回结果的字符串。<br> <strong>参数</strong>–object：对象。<br> <strong>返回值</strong>：一个字符串对象。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; x = [1, 2, 3, 4]
&gt;&gt;&gt; repr(x)
'[1, 2, 3, 4]'

&gt;&gt;&gt; a = 3
&gt;&gt;&gt; b = 4
&gt;&gt;&gt; repr((a + b))
'7'
</code></pre> 
<h4><a id="54reversedseq_1501"></a>54.reversed(seq)</h4> 
<p><strong>描述</strong>：将序列顺序颠倒，返回一个迭代器。<br> <strong>参数</strong>–seq：要反转的序列。<br> <strong>返回值</strong>：返回一个迭代器。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; x
[1, 2, 3, 4]
&gt;&gt;&gt; x = reversed(x)
&gt;&gt;&gt; print(x)
&lt;list_reverseiterator object at 0x0000018E528D1CC0&gt;
&gt;&gt;&gt; list(x)
[4, 3, 2, 1]
</code></pre> 
<h4><a id="55roundnumber_ndigits_1516"></a>55.round(number[， ndigits])</h4> 
<p><strong>描述</strong>：对数字进行四舍五入计算。返回 number 舍入到小数点后 ndigits 位精度的值。<br> <strong>参数</strong>–Number：数字表达式。<br> ndigits：精度，即保持小数后几位。任何整数值都可作为有效的 ndigits (正数、零或负数)。<br> <strong>返回值</strong>： 如果 ndigits 被省略或为 None 则返回值将为整数。 否则返回值与 number 的类型相同。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; round(3.14159265359, 2)
3.14
&gt;&gt;&gt; round(3.14159265359, -1)
0.0
&gt;&gt;&gt; round(3.14159265359, 0)
3.0
&gt;&gt;&gt; round(314.1592653579, -1)  #当为负数的时候，表示对整数部分进行四舍五入计算。
310.0
&gt;&gt;&gt; round(2.675, 2)       #这里并不是错误
2.67
</code></pre> 
<p><strong>注意</strong>：对浮点数进行round()计算时，结果可能不是预期的结果。例如，round(2.675, 2) 将给出 2.67 而不是期望的 2.68。 这不算是程序错误：这一结果是由于大多数十进制小数实际上都不能以浮点数精确地表示。详细可以参阅官方文档<a href="https://docs.python.org/zh-cn/3/tutorial/floatingpoint.html#tut-fp-issues" rel="nofollow">浮点计算</a></p> 
<h3><a id="S_1537"></a>S</h3> 
<h4><a id="56setiterable_1539"></a>56.set([iterable])</h4> 
<p><strong>描述</strong>：返回一个新的 set 对象，可以选择带有从 iterable 获取的元素。<br> <strong>参数</strong>–iterable：可迭代对象对象。<br> <strong>返回值</strong>：一个新的set对象。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt;x = set('runoob')
&gt;&gt;&gt; y = set('google')
&gt;&gt;&gt; x, y
(set(['b', 'r', 'u', 'o', 'n']), set(['e', 'o', 'g', 'l']))   # 重复的被删除
&gt;&gt;&gt; x &amp; y         # 交集
set(['o'])
&gt;&gt;&gt; x | y         # 并集
set(['b', 'e', 'g', 'l', 'o', 'n', 'r', 'u'])
&gt;&gt;&gt; x - y         # 差集
set(['r', 'b', 'u', 'n'])
</code></pre> 
<h4><a id="57setattrobject_name_value_1556"></a>57.setattr(object， name， value）</h4> 
<p><strong>描述</strong>：对应函数 getattr()，用于设置属性值，该属性不一定是存在的。<br> <strong>参数</strong>–object：对象。<br> name：字符串。<br> value：任意值。<br> <strong>返回值</strong>：无。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; class A:
...     x = 10
...
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; setattr(a, "x", 20)
&gt;&gt;&gt; print(a.x)
20
</code></pre> 
<h4><a id="58slicestart_stop_step_1572"></a>58.slice(start， stop[， step])</h4> 
<p><strong>描述</strong>：返回一个表示由 range(start, stop, step) 所指定索引集的 slice 对象。也可以表示为slice(stop)。<br> <strong>参数</strong>–start：起始位置。<br> stop：结束位置。<br> step：步长。<br> <strong>返回值</strong>：一个切片对象。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt;myslice = slice(5)    # 设置截取5个元素的切片
&gt;&gt;&gt; myslice
slice(None, 5, None)
&gt;&gt;&gt; arr = range(10)
&gt;&gt;&gt; arr
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; arr[myslice]         # 截取 5 个元素
[0, 1, 2, 3, 4]
</code></pre> 
<h4><a id="59sortediterablekeyNonereverseFalse_1590"></a>59.sorted(iterable，key=None，reverse=False)</h4> 
<p><strong>描述</strong>：对所有可迭代的对象进行排序操作。具有两个可选参数，它们都必须指定为关键字参数。<br> <strong>参数</strong>–iterable：可迭代对象。<br> Key：主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。<strong>key一般用匿名函数来表示。</strong><br> reverse：排序规则，reverse = True 降序 ， reverse = False 升序（默认）。<br> 示例：</p> 
<pre><code> a = [{"name":"aaa", "score":30}, {"name":"bcd", "score":28}, {"name":"bbc", "score":"28"}, {"name":"ddd", "score":35}]
 
 &gt;&gt;&gt; sorted(a, key = lambda x:(x["score"], x["name"]), reverse = True)    #先对分数排序，分数相同按名字排序
 
[{'name': 'ddd', 'score': 35}, {'name': 'aaa', 'score': 30}, {'name': 'bcd', 'score': 28}, {'name': 'bbc', 'score': 28}]
</code></pre> 
<h4><a id="60staticmethodfunction__1604"></a>60.staticmethod(function) —</h4> 
<p><strong>描述</strong>：将方法转换成静态方法，该方法不强制要求传递参数。与 @staticmethod 相同。<br> <strong>参数</strong>–function：方法名。<br> 返回值：无。<br> 示例：</p> 
<pre><code>class A:
    def setx(self, Value):
        self.x = Value
        print(self.x)
    
    @staticmethod    #装饰器
    def setx_s(value):
        x = value
        print(x)

    set_x = staticmethod(setx)   #这里将setx() 转变成静态的方法。使得可以直接调用它，但是同时self也作为参数，需要赋值。-----

A.setx_s(10)
A.set_x(A, 20)
</code></pre> 
<p>执行结果：</p> 
<pre><code>10
20
</code></pre> 
<h4><a id="61strobjectb_encodingutf8_errorsstrict_1632"></a>61.str(object=b’’, encoding=‘utf-8’, errors=‘strict’)</h4> 
<p><strong>描述</strong>：将对象转换成字符串形式。也可以表示为str(object)。<br> <strong>参数</strong>–object：对象。<br> encoding：编码格式<br> errors：报错级别。详细在open()函数出有介绍。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; now =datetime.now()
&gt;&gt;&gt; repr(now)
'datetime.datetime(2019, 9, 20, 15, 41, 45, 660991)'
&gt;&gt;&gt; str(now)
'2019-09-20 15:41:45.660991'
</code></pre> 
<p>与repr()的区别是，str()倾向于可读性，面向用户。repr()倾向于精准的表达，所以输出不是常用类型时会带上数据类型，面向开发人员。参考<a href="https://zhuanlan.zhihu.com/p/42730827" rel="nofollow">学python桃子</a></p> 
<h4><a id="62sumiterablestart_1647"></a>62.sum(iterable[，start])</h4> 
<p><strong>描述</strong>：求一个序列的和。<br> <strong>参数</strong>–itreable：序列，可以是列表，集合，元组。<br> start：指定相加的参数，如果没有设置这个值，默认为0。<br> <strong>返回值</strong>：返回序列求和的结果，序列元素全为整数时返回整数，否则返回浮点数。</p> 
<pre><code>&gt;&gt;&gt; l = [1.1, 2.4, 3, 4]
&gt;&gt;&gt; sum(l)
10.5
&gt;&gt;&gt; sum(l, 3)  #将3 作为求和运算的第一个值。
13.5
</code></pre> 
<h4><a id="63supertype_objectortype_1659"></a>63.super([type[， object-or-type]])</h4> 
<p><strong>描述</strong>：调用父类的方法。<br> <strong>参数</strong>–type：类。<br> object-or-type：类或对象。如果省略第二个参数，则返回的超类对象是未绑定的。 如果第二个参数为obj，则 isinstance(obj, type) 必须为真值，<strong>即第二个参数为第一个参数的实例</strong>。 如果第二个参数为一个类型，则 issubclass(type2, type) 必须为真值，<strong>即第二个参数是第一个参数的子类</strong>（这适用于类方法）。<br> 示例：</p> 
<pre><code>class A:
    def __init__(self):
        print("this is class A")
        self.x = 1
    
    def add(self):
        print("this self is class {0}, this method is A.add()".format(self))
        self.x += 1
        print(self.x, "this is a.add()")
        return self.x

class B(A):
    def __init__(self):
        print("this is class B")
        self.x = 2

    def add(self):
        print("this is class {0}, this is B.add()".format(self))
        super().add()
        self.x += 2
        print(self.x, "this is b.add()")
        return self.x

class C(A):
    def __init__(self):
        print("this is class C")
        self.x = 3
    
    def add(self):
        print("this self is class {0}, this is c.add()".format(self))
        super().add()
        self.x += 3
        print(self.x, "this c.add()")
        return self.x

class D(B, C):
    def __init__(self):
        print("this is class D")
        self.x = 4

    def add(self):
        print("this self is class {0}, this is D.add()".format(self))
        super().add()
        self.x += 4
        print(self.x, "this d.add()")
        return self.x

d = D()
temp = d.add()
print(temp)
</code></pre> 
<p>执行 结果：</p> 
<pre><code>this is class D
this self is class &lt;__main__.D object at 0x0000012C056D1668&gt;, this is D.add()
this is class &lt;__main__.D object at 0x0000012C056D1668&gt;, this is B.add()
this self is class &lt;__main__.D object at 0x0000012C056D1668&gt;, this is c.add()
this self is class &lt;__main__.D object at 0x0000012C056D1668&gt;, this method is A.add()
5 this is a.add()
8 this c.add()
10 this is b.add()
14 this d.add()
14
</code></pre> 
<p>可以看到多继承的执行顺序是D-&gt;B-&gt;C-&gt;A。更详细的描述可以参考<a href="https://mozillazg.com/2016/12/python-super-is-not-as-simple-as-you-thought.html" rel="nofollow">Huang Huang的博客</a></p> 
<h3><a id="T_1733"></a>T</h3> 
<h4><a id="64tupleiterable_1734"></a>64.tuple([iterable])</h4> 
<p><strong>描述</strong>：将序列转化成元组。<br> <strong>参数</strong>–iterable：序列，可以是列表，字典，集合。<br> <strong>返回值</strong>：返回一个新的tuple对象。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; tuple(a)
(1, 2, 3)

&gt;&gt;&gt; b = "abcd"
&gt;&gt;&gt; tuple(b)
('a', 'b', 'c', 'd')

&gt;&gt;&gt; c = dict(a = 1, b = 2, c = 3)  #字典转化成元组时，只保留键。
&gt;&gt;&gt; tuple(c)
('a', 'b', 'c')
</code></pre> 
<h4><a id="65type_1753"></a>65.type()</h4> 
<p><strong>描述</strong>：有两种形式，type(object)，type(name，bases，dict)。如果你只有第一个参数则返回对象的类型，三个参数返回新的类型对象。<br> <strong>参数</strong>–object：对象。<br> name：类名。<br> bases：bases 元组列出基类并且会成为 <strong>bases</strong> 属性。基类的元组。<br> dict：而 dict 字典为包含类主体定义的命名空间并且会被复制到一个标准字典成为 <strong>dict</strong> 属性。<br> <strong>返回值</strong>：如果你只有第一个参数则返回对象的类型，三个参数返回新的类型对象。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; a = 123
&gt;&gt;&gt; type(a)    #一个参数时
&lt;class 'int'&gt;

&gt;&gt;&gt; x = type('x', (object,), dict(a = 1))   #三个参数时，等价于创建一个类名为 x 的类，包含一个属性 a = 1
&gt;&gt;&gt; type(x)
&lt;class 'type'&gt;
&gt;&gt;&gt; print(x.a)
1
</code></pre> 
<h4><a id="66varsobject_1773"></a>66.vars([object])</h4> 
<p><strong>描述</strong>：返回模块、类、实例或任何其它具有 <strong>dict</strong> 属性的对象的 <strong>dict</strong> 属性。<br> <strong>参数</strong>–object：对象。<br> <strong>返回值</strong>：返回对象object的属性和属性值的字典对象，如果没有参数，就打印当前调用位置的属性和属性值 类似 locals()。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; x = type('x', (object,), dict(a = 1)) 
&gt;&gt;&gt; vars(x)
mappingproxy({'a': 1, '__module__': '__main__', '__dict__': &lt;attribute '__dict__' of 'x' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'x' objects&gt;, '__doc__': None})
&gt;&gt;&gt; x.__dict__
mappingproxy({'a': 1, '__module__': '__main__', '__dict__': &lt;attribute '__dict__' of 'x' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'x' objects&gt;, '__doc__': None})
&gt;&gt;&gt; dir(x)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'a']
</code></pre> 
<p>可以看出 vars() 的值与 _ _dict_ _的值一致。<br> 与dir()最显著的区别之一就是vars()会带上属性值。<br> <strong>注意</strong>：在赋值语句 x = 1 执行后，名称 x 可以引用数值 1，这类似字典的键值对，可以用 vars() 返回这个 “字典” 。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt; x = 1
&gt;&gt;&gt; d = vars()
&gt;&gt;&gt; d["x"]
1
</code></pre> 
<h4><a id="67zipiterable_1799"></a>67.zip(*iterable)</h4> 
<p><strong>描述</strong>：zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。<br> 我们可以使用 list() 转换来输出列表。<br> 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。<br> <strong>参数</strong>–iterable：一个或多个迭代器。<br> <strong>返回值</strong>：返回一个元组的迭代器，其中的第 i 个元组包含来自每个参数序列或可迭代对象的第 i 个元素。<br> 示例：</p> 
<pre><code>&gt;&gt;&gt;a = [1,2,3]
&gt;&gt;&gt; b = [4,5,6]
&gt;&gt;&gt; c = [4,5,6,7,8]
&gt;&gt;&gt; zipped = zip(a,b)     # 返回一个对象
&gt;&gt;&gt; zipped
&lt;zip object at 0x103abc288&gt;
&gt;&gt;&gt; list(zipped)  # list() 转换为列表
[(1, 4), (2, 5), (3, 6)]
&gt;&gt;&gt; list(zip(a,c))              # 元素个数与最短的列表一致
[(1, 4), (2, 5), (3, 6)]
 
&gt;&gt;&gt; a1, a2 = zip(*zip(a,b))          # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式
&gt;&gt;&gt; list(a1)
[1, 2, 3]
&gt;&gt;&gt; list(a2)
[4, 5, 6]

&gt;&gt;&gt; a = dict(name1 = "aaa", name2 = "bbb", name3 = "ccc")  #当参数为字典是只会保留关键字
&gt;&gt;&gt; b = dict(age1 = 10, age2 = 20, age3 = 30)
&gt;&gt;&gt; c = zip(a, b)
&gt;&gt;&gt; list(c) 
[('name1', 'age1'), ('name2', 'age2'), ('name3', 'age3')]
</code></pre> 
<h4><a id="68___import___name_globalsNone_localsNonefromlist_level0_1831"></a>68._ _import_ _(name， globals=None， locals=None，fromlist=()， level=0)</h4> 
<p>描述：动态加载模块。<br> 参数–name：必选，包，模块名称<br> globals：包含全局变量的字典，默认采用 globals()，一般很少使用。<br> locals：包含局部变量的字典，默认采用 locals()，一般很少使用。<br> fromlist：想要导入的下级模块的名字。<br> level：指定是使用绝对还是相对导入。0 表示仅绝对导入， level 为正数值表示相对于模块调用 _ <em>import</em> _() 的目录，将要搜索的父目录层数。</p> 
<p>使用技巧参考<a href="https://docs.lvrui.io/2017/10/13/Python%E4%B8%AD-import-%E7%9A%84fromlist%E5%8F%82%E6%95%B0%E7%94%A8%E6%B3%95/" rel="nofollow">传送门</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51212742f52cc9f833bce5723a2c0458/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mybatisPlus使用LocalDateTime转化异常</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a702f7e5be12fcf9c0c0d7583e21510/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IOT-OS之RT-Thread（六）--- 线程间同步与线程间通信</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>