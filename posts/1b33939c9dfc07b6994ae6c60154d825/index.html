<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>王道2023数据结构笔记 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="王道2023数据结构笔记" />
<meta property="og:description" content="本文是在学习2023年王道最新课程时所做的学习笔记，仅供参考，需要书籍或者视频的可以私信，剩下三门课的笔记私信博主获得
文章目录 数据结构笔记第一章 绪论1.1 基本概念1.2 数据结构三要素1.3 算法的概念1.4 算法效率的度量 第二章 线性表2.1 线性表的定义和基本操作2.2 线性表的顺序表示2.3 线性表的链式表示 第三章 栈、队列和数组3.1 栈3.2 队列3.3 栈和队列的应用3.3.1 栈在括号匹配中的应用3.3.2 栈在表达式求值中的应用3.3.3 栈在递归中的应用3.3.4 队列的应用 3.4 数组和特殊矩阵3.4.1 数组3.4.2 特殊矩阵的压缩存储 第四章 串4.1 定义和实现4.1.1 定义4.1.2 串的存储结构4.1.3 基本操作 4.2 串的模式匹配4.2.1 简单的模式匹配算法4.2.2 KMP算法 第五章 树与二叉树5.1 树的基本概念5.1.1 树的定义5.1.2 基本术语5.1.3 树的性质 5.2 二叉树的概念5.2.1 二叉树的定义及主要特征5.2.2 二叉树的性质5.2.3 二叉树的存储结构 5.3 二叉树的遍历和线索二叉树5.3.1 二叉树的遍历5.3.2 ==线索二叉树== (没理解) 5.4 树、森林5.4.1 树的存储结构5.4.2 树、森林和二叉树的转换5.4.3 树和森林的遍历 5.5 树与二叉树的应用5.5.1 哈夫曼树和哈夫曼编码5.5.2 并查集 第六章 图6.1 图的基本概念6.2 图的存储及基本操作6.2.1 邻接矩阵法6.2.2 邻接表法6.2.3 邻接多重表6.2.4 十字链表6.2.5 图的基本操作 6." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/1b33939c9dfc07b6994ae6c60154d825/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-30T16:59:11+08:00" />
<meta property="article:modified_time" content="2022-07-30T16:59:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">王道2023数据结构笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>本文是在学习2023年王道最新课程时所做的学习笔记，仅供参考，需要书籍或者视频的可以私信，剩下三门课的笔记私信博主获得</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ab/2c/DyqBeMH9_o.png" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_5" rel="nofollow">数据结构笔记</a></li><li><ul><li><a href="#___7" rel="nofollow">第一章 绪论</a></li><li><ul><li><a href="#11__13" rel="nofollow">1.1 基本概念</a></li><li><a href="#12__33" rel="nofollow">1.2 数据结构三要素</a></li><li><a href="#13__93" rel="nofollow">1.3 算法的概念</a></li><li><a href="#14__120" rel="nofollow">1.4 算法效率的度量</a></li></ul> 
   </li><li><a href="#__144" rel="nofollow">第二章 线性表</a></li><li><ul><li><a href="#21__146" rel="nofollow">2.1 线性表的定义和基本操作</a></li><li><a href="#22__178" rel="nofollow">2.2 线性表的顺序表示</a></li><li><a href="#23__215" rel="nofollow">2.3 线性表的链式表示</a></li></ul> 
   </li><li><a href="#__325" rel="nofollow">第三章 栈、队列和数组</a></li><li><ul><li><a href="#31__327" rel="nofollow">3.1 栈</a></li><li><a href="#32__381" rel="nofollow">3.2 队列</a></li><li><a href="#33__443" rel="nofollow">3.3 栈和队列的应用</a></li><li><ul><li><a href="#331__445" rel="nofollow">3.3.1 栈在括号匹配中的应用</a></li><li><a href="#332__459" rel="nofollow">3.3.2 栈在表达式求值中的应用</a></li><li><a href="#333__537" rel="nofollow">3.3.3 栈在递归中的应用</a></li><li><a href="#334__553" rel="nofollow">3.3.4 队列的应用</a></li></ul> 
    </li><li><a href="#34__567" rel="nofollow">3.4 数组和特殊矩阵</a></li><li><ul><li><a href="#341__569" rel="nofollow">3.4.1 数组</a></li><li><a href="#342__589" rel="nofollow">3.4.2 特殊矩阵的压缩存储</a></li></ul> 
   </li></ul> 
   </li><li><a href="#__626" rel="nofollow">第四章 串</a></li><li><ul><li><a href="#41__628" rel="nofollow">4.1 定义和实现</a></li><li><ul><li><a href="#411__630" rel="nofollow">4.1.1 定义</a></li><li><a href="#412__674" rel="nofollow">4.1.2 串的存储结构</a></li><li><a href="#413__680" rel="nofollow">4.1.3 基本操作</a></li></ul> 
    </li><li><a href="#42__696" rel="nofollow">4.2 串的模式匹配</a></li><li><ul><li><a href="#421__698" rel="nofollow">4.2.1 简单的模式匹配算法</a></li><li><a href="#422_KMP_716" rel="nofollow">4.2.2 KMP算法</a></li></ul> 
   </li></ul> 
   </li><li><a href="#__726" rel="nofollow">第五章 树与二叉树</a></li><li><ul><li><a href="#51__728" rel="nofollow">5.1 树的基本概念</a></li><li><ul><li><a href="#511__730" rel="nofollow">5.1.1 树的定义</a></li><li><a href="#512__752" rel="nofollow">5.1.2 基本术语</a></li><li><a href="#513__773" rel="nofollow">5.1.3 树的性质</a></li></ul> 
    </li><li><a href="#52__796" rel="nofollow">5.2 二叉树的概念</a></li><li><ul><li><a href="#521__798" rel="nofollow">5.2.1 二叉树的定义及主要特征</a></li><li><a href="#522__844" rel="nofollow">5.2.2 二叉树的性质</a></li><li><a href="#523__866" rel="nofollow">5.2.3 二叉树的存储结构</a></li></ul> 
    </li><li><a href="#53__897" rel="nofollow">5.3 二叉树的遍历和线索二叉树</a></li><li><ul><li><a href="#531__899" rel="nofollow">5.3.1 二叉树的遍历</a></li><li><a href="#532___951" rel="nofollow">5.3.2 ==线索二叉树== (没理解)</a></li></ul> 
    </li><li><a href="#54__973" rel="nofollow">5.4 树、森林</a></li><li><ul><li><a href="#541__975" rel="nofollow">5.4.1 树的存储结构</a></li><li><a href="#542__1000" rel="nofollow">5.4.2 树、森林和二叉树的转换</a></li><li><a href="#543__1023" rel="nofollow">5.4.3 树和森林的遍历</a></li></ul> 
    </li><li><a href="#55__1061" rel="nofollow">5.5 树与二叉树的应用</a></li><li><ul><li><a href="#551__1063" rel="nofollow">5.5.1 哈夫曼树和哈夫曼编码</a></li><li><a href="#552__1108" rel="nofollow">5.5.2 并查集</a></li></ul> 
   </li></ul> 
   </li><li><a href="#__1116" rel="nofollow">第六章 图</a></li><li><ul><li><a href="#61__1118" rel="nofollow">6.1 图的基本概念</a></li><li><a href="#62__1207" rel="nofollow">6.2 图的存储及基本操作</a></li><li><ul><li><a href="#621__1209" rel="nofollow">6.2.1 邻接矩阵法</a></li><li><a href="#622__1231" rel="nofollow">6.2.2 邻接表法</a></li><li><a href="#623__1237" rel="nofollow">6.2.3 邻接多重表</a></li><li><a href="#624__1241" rel="nofollow">6.2.4 十字链表</a></li><li><a href="#625__1249" rel="nofollow">6.2.5 图的基本操作</a></li></ul> 
    </li><li><a href="#63__1271" rel="nofollow">6.3 图的遍历</a></li><li><ul><li><a href="#631_BFS_1273" rel="nofollow">6.3.1 广度优先遍历BFS</a></li><li><a href="#632_DFS_1306" rel="nofollow">6.3.2 深度优先遍历DFS</a></li><li><a href="#633__1333" rel="nofollow">6.3.3 图的遍历与图的连通性</a></li></ul> 
    </li><li><a href="#64__1343" rel="nofollow">6.4 图的应用</a></li><li><ul><li><a href="#641__1345" rel="nofollow">6.4.1 最小生成树</a></li><li><a href="#642__1382" rel="nofollow">6.4.2 最短路径</a></li><li><a href="#643_DAG_1419" rel="nofollow">6.4.3 有向无环图DAG</a></li><li><a href="#644__1433" rel="nofollow">6.4.4 拓扑排序</a></li><li><a href="#645__1465" rel="nofollow">6.4.5 关键路径</a></li></ul> 
   </li></ul> 
   </li><li><a href="#__1539" rel="nofollow">第七章 查找</a></li><li><ul><li><a href="#71__1541" rel="nofollow">7.1 查找的基本概念</a></li><li><a href="#72__1569" rel="nofollow">7.2 顺序查找和折半查找</a></li><li><ul><li><a href="#721__1571" rel="nofollow">7.2.1 顺序查找</a></li><li><a href="#722__1581" rel="nofollow">7.2.2 折半查找（二分查找）</a></li><li><a href="#723__1603" rel="nofollow">7.2.3 分块查找</a></li></ul> 
    </li><li><a href="#73__1623" rel="nofollow">7.3 树型查找</a></li><li><ul><li><a href="#731_BST_1625" rel="nofollow">7.3.1 二叉排序树BST</a></li><li><a href="#732_AVL_1658" rel="nofollow">7.3.2 平衡二叉树AVL</a></li><li><a href="#733__1690" rel="nofollow">7.3.3 红黑树</a></li></ul> 
    </li><li><a href="#74_BB_1732" rel="nofollow">7.4 B树和B+树</a></li><li><ul><li><a href="#741_B_1734" rel="nofollow">7.4.1 B树</a></li><li><a href="#742_B_1798" rel="nofollow">7.4.2 B+树</a></li></ul> 
    </li><li><a href="#75__1818" rel="nofollow">7.5 散列表</a></li><li><ul><li><a href="#751__1820" rel="nofollow">7.5.1 散列表的基本概念</a></li><li><a href="#752__1834" rel="nofollow">7.5.2 散列函数的构造方法</a></li><li><a href="#753__1856" rel="nofollow">7.5.3 处理冲突的方法</a></li><li><a href="#754__1888" rel="nofollow">7.5.4 散列查找及性能分析</a></li></ul> 
   </li></ul> 
   </li><li><a href="#__1907" rel="nofollow">第八章 排序</a></li><li><ul><li><a href="#81__1909" rel="nofollow">8.1 排序的基本概念</a></li><li><a href="#82__1919" rel="nofollow">8.2 插入排序</a></li><li><ul><li><a href="#821__1921" rel="nofollow">8.2.1 直接插入排序</a></li><li><a href="#822__1937" rel="nofollow">8.2.2 折半插入排序</a></li><li><a href="#823__1953" rel="nofollow">8.2.3 希尔排序</a></li></ul> 
    </li><li><a href="#83__1969" rel="nofollow">8.3 交换排序</a></li><li><ul><li><a href="#831__1971" rel="nofollow">8.3.1 冒泡排序</a></li><li><a href="#832__1988" rel="nofollow">8.3.2 快速排序</a></li></ul> 
    </li><li><a href="#84__2023" rel="nofollow">8.4 选择排序</a></li><li><ul><li><a href="#841__2025" rel="nofollow">8.4.1 简单选择排序</a></li><li><a href="#842__2043" rel="nofollow">8.4.2 堆排序</a></li><li><a href="#843__2069" rel="nofollow">8.4.3 堆的插入和删除</a></li></ul> 
    </li><li><a href="#85__2077" rel="nofollow">8.5 归并排序和基数排序</a></li><li><ul><li><a href="#851__2079" rel="nofollow">8.5.1 归并排序</a></li><li><a href="#852__2093" rel="nofollow">8.5.2 基数排序</a></li></ul> 
    </li><li><a href="#86__2115" rel="nofollow">8.6 内部排序算法比较与应用</a></li><li><a href="#87__2119" rel="nofollow">8.7 外部排序</a></li><li><ul><li><a href="#871__2121" rel="nofollow">8.7.1 外部排序的基本概念</a></li><li><a href="#872__2137" rel="nofollow">8.7.2 败者树</a></li><li><a href="#873__2155" rel="nofollow">8.7.3 置换选择排序</a></li><li><a href="#874__2173" rel="nofollow">8.7.4 最佳归并树</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_5"></a>数据结构笔记</h2> 
<h3><a id="___7"></a>第一章 绪论</h3> 
<p><img src="https://images2.imgbox.com/cb/67/EXjxOVRW_o.png" alt="image-20220705091600548"></p> 
<h4><a id="11__13"></a>1.1 基本概念</h4> 
<p><strong>数据</strong>是<mark>信息的载体</mark>，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别 和处理的符号的集合。</p> 
<p><strong>数据元素</strong>是数据的基本单位</p> 
<p>一个数据元素可由若干数据项组成，<strong>数据项</strong>是构成数据元素的不可分割的最小单位</p> 
<p><strong>数据结构</strong>是相互之间存在一种或多种特定关系的数据元素的集合。</p> 
<p><strong>数据对象</strong>是具有相同性质的数据元素的集合，是数据的一个子集。</p> 
<blockquote> 
 <p><strong>数据类型</strong> ：一个值的集合和定义在集合上的一组操作的总称</p> 
</blockquote> 
<ol><li>原子类型 ：值不可再分</li><li>结构类型：值可以再分</li><li><strong>抽象数据类型</strong> ： 抽象数据组织及与之相关的操作</li></ol> 
<h4><a id="12__33"></a>1.2 数据结构三要素</h4> 
<p><img src="https://images2.imgbox.com/5d/25/bASDdZeB_o.png" alt="image-20220705105722142"></p> 
<blockquote> 
 <p>逻辑结构 ：数据元素之间的逻辑关系,与存储无关,独立于计算机（一个算法的设计）</p> 
</blockquote> 
<ol><li> <p><strong>线性结构</strong>：一对一</p> <p>除了第一个元素，所有元素都有<mark>唯一前驱</mark>； 除了最后一个元素，所有元素都有<mark>唯一后继</mark></p> </li><li> <p><strong>树形结构</strong>： 一对多</p> </li><li> <p><strong>网状/图状</strong>：多对多</p> </li><li> <p>集合： 同属一个集合</p> </li></ol> 
<blockquote> 
 <p>存储结构：数据结构在计算机中的表示，又称映像/物理结构 （一个算法的实现）</p> 
</blockquote> 
<ol><li> <p><strong>顺序存储</strong>：把<mark>逻辑上相邻</mark>的元素存储在<mark>物理位置 上也相邻</mark>的存储单元中，元素之间的关系由存储 单元的邻接关系来体现</p> <p>优点： <mark>随机存取</mark>,元素占用最少存储空间</p> <p>缺点： 只能使用相邻的一整块存储单元,产生较多的外部碎片</p> </li><li> <p><strong>链式存储</strong>：逻辑上相邻的元素在物理位置上可以 不相邻，借助指示元素存储地址的指针来表示元 素之间的逻辑关系</p> <p>优点: 不会出现碎片现象</p> <p>缺点: 存储指针占用额外的存储空间; <mark>只能顺序存取</mark></p> </li><li> <p><strong>索引存储</strong>：建立附加 的索引表。索引表中的每项称为索引项，索引项 的一般形式是（关键字，地址）</p> <p>优点: 检索速度快</p> <p>缺点: 占用较多存储空间; 增加和删除数据要修改索引表,花费较多时间</p> </li><li> <p><strong>散列存储</strong>：根据元素的关键字直接计算出该元素 的存储地址，又称哈希（Hash）存储</p> <p>优点: 检索,增加和删除结点都很快</p> <p>缺点: 若散列函数不好,出现元素存储单元冲突,会增加时间和空间的开销</p> </li></ol> 
<blockquote> 
 <p>数据的运算</p> 
</blockquote> 
<p>​ 运算的定义是针对逻辑结构的， 指出运算的功能</p> 
<p>​ 运算的实现是针对存储结构的，指出运算的具体操作步骤。</p> 
<p><mark><strong>易错点</strong></mark></p> 
<ol><li> <p>属于逻辑结构 有序表</p> </li><li> <p>循环队列是用顺序表表示的队列,是数据结构,不是抽象数据结构</p> </li><li> <p>不同结点的存储空间可以不连续,但结点内的存储空间必须连续</p> </li><li> <p>两种不同的数据结构,逻辑结构和物理结构可以完全相同,但数据的运算不同</p> </li></ol> 
<h4><a id="13__93"></a>1.3 算法的概念</h4> 
<p><strong>算法</strong> ：对特定问题求解步骤的描述，是指令的有限序列，其中每条指令表示一个或多个操作</p> 
<blockquote> 
 <p>算法的特性</p> 
</blockquote> 
<ol><li> <p><strong>有穷性</strong>：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成</p> <p><mark>算法是有穷的，程序是无穷的。</mark></p> </li><li> <p><strong>确定性</strong>：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出</p> </li><li> <p><strong>可行性</strong> ：算法中描述的操作都可以通过已经实现的基本运算执行<mark>有限次</mark>来实现</p> </li><li> <p>输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合</p> </li><li> <p>输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量</p> </li></ol> 
<blockquote> 
 <p>好的算法</p> 
</blockquote> 
<pre><code>1. 正确性
2. 可读性
3. 健壮性：输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果
4. 高效率与低存储量需求 （时间复杂度低、空间复杂度低）
</code></pre> 
<h4><a id="14__120"></a>1.4 算法效率的度量</h4> 
<blockquote> 
 <p>算法的时间复杂度</p> 
</blockquote> 
<p>定义：<mark>事前预估</mark>算法<mark>时间开销T(n)<mark>与</mark>问题规模n</mark>的关系</p> 
<p>衡量算法随着问题规模增大,算法执行<mark>时间</mark>增长的快慢</p> 
<p>同一个算法,实现的语言的级别越高级,执行效率越低</p> 
<pre><code>O(1) &lt; O(log2n) &lt; O(n) &lt; O(nlog2n) &lt; O(n2 ) &lt; O(n3 ) &lt; O(2n) &lt; O(n!) &lt; O(nn)  常对幂指阶
</code></pre> 
<p><img src="https://images2.imgbox.com/0a/61/2UPQdoMx_o.png" alt="image-20220705153607195"></p> 
<blockquote> 
 <p>算法的空间复杂度</p> 
</blockquote> 
<p>衡量算法随着问题规模增大,算法所需<mark>空间</mark>增长的快慢</p> 
<p><img src="https://images2.imgbox.com/63/4a/4tWXusM7_o.png" alt="image-20220705151358994"></p> 
<h3><a id="__144"></a>第二章 线性表</h3> 
<h4><a id="21__146"></a>2.1 线性表的定义和基本操作</h4> 
<p><img src="https://images2.imgbox.com/54/7f/vnm3OwUY_o.png" alt="image-20220706142233411"></p> 
<blockquote> 
 <p>线性表的定义</p> 
</blockquote> 
<p>​ 线性表是具有<mark>相同数据类型</mark>的n（n≥0）个数据元素的<mark>有限序列</mark>，其中n为表长，当n = 0时线 性表是一个空表。若用L命名线性表，则其一般表示为 L = (a1, a2, … , ai , ai+1, … , an)</p> 
<p>​ ai是线性表中的“第i个”元素线性表中的<mark>位序</mark></p> 
<p>​ a1是<mark>表头元素</mark>；an是<mark>表尾元素</mark></p> 
<p>​ 除第一个元素外，每个元素有且仅有一个<mark>直接前驱</mark>；除最后一个元素外，每个元素有且仅 有一个<mark>直接后继</mark></p> 
<blockquote> 
 <p>线性表的基本操作</p> 
</blockquote> 
<p>InitList(&amp;L)：<strong>初始化</strong>表。构造一个空的线性表L，分配内存空间。</p> 
<p>DestroyList(&amp;L)：<strong>销毁</strong>操作。销毁线性表，并释放线性表L所占用的内存空间。</p> 
<p>ListInsert(&amp;L,i,e)：<strong>插入</strong>操作。在表L中的第i个位置上插入指定元素e。</p> 
<p>ListDelete(&amp;L,i,&amp;e)：<strong>删除</strong>操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p> 
<p>LocateElem(L,e)：<strong>按值查找</strong>操作。在表L中查找具有给定关键字值的元素。</p> 
<p>GetElem(L,i)：<strong>按位查找</strong>操作。获取表L中第i个位置的元素的值。</p> 
<p>&amp; 表示C++中的引用,若传入指针型变量且在函数体内要进行改变,要用到指针变量的引用(C中用指针的指针也可以)</p> 
<h4><a id="22__178"></a>2.2 线性表的顺序表示</h4> 
<p><img src="https://images2.imgbox.com/4d/5f/pPA1ob3f_o.png" alt="image-20220706144535349"></p> 
<blockquote> 
 <p>顺序表的定义</p> 
</blockquote> 
<p><strong>顺序表</strong>——用<mark>顺序存储</mark>的方式实现线性表</p> 
<p><strong>顺序存储</strong>：把<mark>逻辑上相邻</mark>的元素存储在<mark>物理位置上也相邻</mark>的存储单元中，元素之间的关 系由存储单元的邻接关系来体现</p> 
<p><strong>顺序表的实现</strong> ：<mark>静态分配、动态分配</mark></p> 
<p>动态分布语句：</p> 
<pre><code class="prism language-java"> <span class="token class-name">L</span><span class="token punctuation">.</span>data<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">ElemType</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token class-name">ElemType</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token class-name">InitSize</span><span class="token punctuation">)</span>
<span class="token comment">//malloc函数申请一片连续的存储空间</span>
<span class="token comment">//free函数释放原来的内存空间</span>
</code></pre> 
<p>动态分配不是链式存储,同样属于顺序存储结构,物理结构没有变化:随机存取方式,只是分配的空间大小可以在运行时决定</p> 
<p><strong>特点</strong>: <mark>随机访问,存储密度高,插入和删除需要移动大量元素</mark></p> 
<blockquote> 
 <p>顺序表的操作</p> 
</blockquote> 
<pre><code>1. **插入操作**  平均时间复杂度O(n)
2. **删除操作**  平均时间复杂度O(n)
</code></pre> 
<p><img src="https://images2.imgbox.com/be/c8/q1SB7YWf_o.png" alt="image-20220706145751764"></p> 
<ol start="3"><li><strong>查找操作</strong>：按值查找、按位查找</li></ol> 
<p><img src="https://images2.imgbox.com/21/16/FOAjHAmC_o.png" alt="image-20220706150012081"></p> 
<h4><a id="23__215"></a>2.3 线性表的链式表示</h4> 
<blockquote> 
 <p>单链表</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/bc/85/ScULR9na_o.png" alt="image-20220706150925539"></p> 
<p>头指针和头结点的区别：（1）不管带不带头结点,头指针始终指向链表的第一个结点</p> 
<p>​ （2）头结点是带头结点的链表中的第一个结点,通常不存储信息</p> 
<p>引入头结点的优点：无论链表是否为空,头指针都指向头结点的非空指针,空表和非空表处理一致</p> 
<p><img src="https://images2.imgbox.com/17/bc/BTAVshSW_o.png" alt="image-20220706151705172"></p> 
<blockquote> 
 <p>单链表的操作</p> 
</blockquote> 
<p><strong>建立单链表</strong></p> 
<p>核心：<mark>初始化</mark>操作、<mark>指定结点的后插</mark>操作</p> 
<p>​ （1）头插法，链表的逆置</p> 
<p>​ （2）尾插法，注意设置一个指向表尾结点的指针</p> 
<p><strong>插入结点操作</strong></p> 
<p>​ （1）按位序插入（带头结点）</p> 
<p>​ （2）按为序插入（不带头结点）</p> 
<p>​ （3）指定结点的前插操作: 先找到前一个结点,时间复杂度为O(n)</p> 
<p>​ （4） 将前插操作转化为后插操作,然后交换两个结点的数据,时间复杂度为O(1)</p> 
<p><strong>删除结点操作</strong></p> 
<p>​ （1）按位序删除（带头结点）</p> 
<p>​ （2）指定结点的删除：先找到前驱节点,再删除结点,O(n)</p> 
<p><img src="https://images2.imgbox.com/c8/1a/U4vUZebv_o.png" alt="image-20220706152853595"></p> 
<p><strong>查找结点操作</strong></p> 
<p>​ （1）按位查找</p> 
<p>​ （2）按值查找</p> 
<p><img src="https://images2.imgbox.com/06/14/Z6VujYIg_o.png" alt="image-20220706153424393"></p> 
<blockquote> 
 <p>双链表</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/fd/50/fj5oksGE_o.png" alt="image-20220706155442751"></p> 
<p><img src="https://images2.imgbox.com/5f/cc/NGqhog26_o.png" alt="image-20220706155507113"></p> 
<p><img src="https://images2.imgbox.com/4f/8f/2KNNXQKt_o.png" alt="image-20220706155522021"></p> 
<p><img src="https://images2.imgbox.com/35/82/a5vKdwjD_o.png" alt="image-20220706155534366"></p> 
<p><img src="https://images2.imgbox.com/a4/97/LPsUmXHB_o.png" alt="image-20220706155613952"></p> 
<blockquote> 
 <p>循环链表</p> 
</blockquote> 
<p>​ （1）循环单链表：表尾结点的next指针指向头结点</p> 
<p>​ 对单链表在表头和表尾操作时: 不设头指针仅设尾指针,效率更高</p> 
<p>​ 可以从任意一个结点开始遍历整个链表</p> 
<p>​ （2）循环双链表：表头结点的prior指向表尾结点，表尾结点的next指向头结点</p> 
<p><img src="https://images2.imgbox.com/2e/e6/BX6jU23x_o.png" alt="image-20220706160502165"></p> 
<blockquote> 
 <p>静态链表</p> 
</blockquote> 
<p>用<mark>数组</mark>描述链式存储结构,也有数据域和指针域.指针是结点的相对地址(数组下标),又称游标</p> 
<p>插入和删除只需要修改指针,不需要移动元素</p> 
<p><img src="https://images2.imgbox.com/a2/04/tIkNcJc5_o.png" alt="image-20220706160623434"></p> 
<blockquote> 
 <p>顺序表和链表的比较</p> 
</blockquote> 
<ol><li> <p>逻辑结构 都属于线性表，都是线性结构</p> </li><li> <p>存储结构 顺序表：顺序存储 链表：链式存储</p> </li><li> <p>基本操作–初始化</p> <p><img src="https://images2.imgbox.com/d0/86/cerKJExG_o.png" alt="image-20220706161309741"></p> </li><li> <p>基本操作–增删</p> <p><img src="https://images2.imgbox.com/17/a3/pDBacT4T_o.png" alt="image-20220706161352823"></p> </li><li> <p>基本操作–查</p> <p><img src="https://images2.imgbox.com/0f/80/OHRFY0b9_o.png" alt="image-20220706161414864"></p> </li><li> <p>如何选择</p> <p>（1）基于存储的考虑 ：难以估计长度和存储规模时用链表,但链表的存储密度较低</p> <p>（2）基于运算的考虑：经常做按序号访问数据元素用顺序表</p> <p>（3）基于环境的考虑：较稳定选顺序表,动态性较强选链表</p> </li></ol> 
<h3><a id="__325"></a>第三章 栈、队列和数组</h3> 
<h4><a id="31__327"></a>3.1 栈</h4> 
<blockquote> 
 <p>定义</p> 
</blockquote> 
<p><mark>只允许在一端进行插入或删除</mark>操作的<mark>线性表</mark></p> 
<p>特点：<mark>先进后出，后进先出</mark></p> 
<p>栈顶、栈底、空栈</p> 
<blockquote> 
 <p>基本操作</p> 
</blockquote> 
<p>InitStack(&amp;S)：初始化栈。构造一个空栈 S，分配内存空间。</p> 
<p>DestroyStack(&amp;S)：销毁栈。销毁并释放栈 S 所占用的内存空间。</p> 
<p>Push(&amp;S,x)：<strong>进栈</strong>，若栈S未满，则将x加入使之成为新<mark>栈顶</mark>。</p> 
<p>Pop(&amp;S,&amp;x)：<strong>出栈</strong>，若栈S非空，则弹出<mark>栈顶</mark>元素，并用x返回。</p> 
<p>GetTop(S, &amp;x)：<strong>读栈顶元素</strong>。若栈 S 非空，则用 x 返回栈顶元素</p> 
<p><img src="https://images2.imgbox.com/33/01/sMFz6J1c_o.png" alt="image-20220707200808882"></p> 
<blockquote> 
 <p>栈的顺序存储结构</p> 
</blockquote> 
<p><strong>实现</strong></p> 
<ol><li> <p>栈顶指针:S.top 栈顶元素:S.data[S.top]</p> </li><li> <p>进栈: 指针先加1,再送值到栈顶元素</p> </li><li> <p>出栈: 先取栈顶元素值,再将栈顶指针减1</p> </li></ol> 
<blockquote> 
 <p>共享栈</p> 
</blockquote> 
<ol><li> <p>定义: 将两个栈的栈底设置在共享空间的两端,两个栈顶向中间延伸</p> </li><li> <p>判空: top0=-1 top1=MaxSize</p> </li><li> <p>判满: top1-top0=1</p> </li><li> <p>进栈: top0先加1再赋值,top1先减1再赋值,出栈相反</p> </li></ol> 
<p><img src="https://images2.imgbox.com/b6/cb/uJaPjxIG_o.png" alt="image-20220707202230929"></p> 
<blockquote> 
 <p>栈的链式存储结构</p> 
</blockquote> 
<p><strong>优点</strong>: 便于多个栈共享储存空间,提高其效率,不会栈满上溢</p> 
<p><strong>特点</strong>：所有操作在表头进行,通常没有头结点,将头指针作为栈顶指针,便于结点插入/删除</p> 
<p><img src="https://images2.imgbox.com/c9/9a/xSrLAela_o.png" alt="image-20220707202548099"></p> 
<h4><a id="32__381"></a>3.2 队列</h4> 
<blockquote> 
 <p>定义</p> 
</blockquote> 
<p>队列（Queue）是只允许==在一端进行插入（入队），在另一端删除（出队）==的线性表</p> 
<p>队头、队尾、空队列</p> 
<p>特点：<mark>先进先出</mark></p> 
<blockquote> 
 <p>队列的基本操作</p> 
</blockquote> 
<p>InitQueue(&amp;Q)：初始化队列，构造一个空队列Q。</p> 
<p>DestroyQueue(&amp;Q)：销毁队列。销毁并释放队列Q所占用的内存空间。</p> 
<p>EnQueue(&amp;Q,x)：入队，若队列Q未满，将x加入，使之成为新的<mark>队尾</mark>。</p> 
<p>DeQueue(&amp;Q,&amp;x)：出队，若队列Q非空，删除<mark>队头</mark>元素，并用x返回。</p> 
<p>GetHead(Q,&amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给x</p> 
<p><img src="https://images2.imgbox.com/97/6a/mXx30WMY_o.png" alt="image-20220707203842193"></p> 
<blockquote> 
 <p>队列的顺序存储结构</p> 
</blockquote> 
<p><strong>实现</strong></p> 
<ol><li> <p>两个指针: front指示队头元素,rear指向队尾元素下一个位置</p> </li><li> <p>初始状态(队空): Q.front== Q.rear==0</p> </li><li> <p>进队: 先送值到队尾元素,再将队尾指针加1</p> </li><li> <p>出队: 先取队头元素值,再将队头指针加1</p> </li><li> <p>存在假溢出</p> </li></ol> 
<p><img src="https://images2.imgbox.com/fc/ec/RWiIHtpg_o.png" alt="image-20220707205353627"></p> 
<blockquote> 
 <p>队列的链式存储结构</p> 
</blockquote> 
<p>适合数据元素变动较大的情形,不存在队满溢出,多个队列不存在存储分配不合</p> 
<p><img src="https://images2.imgbox.com/21/85/mljtun80_o.png" alt="image-20220707211256177"></p> 
<blockquote> 
 <p>双端队列</p> 
</blockquote> 
<p>只允许从<mark>两端插入、两端删除</mark>的线性表</p> 
<p><strong>输入受限</strong>的双端队列：只允许从一端插入、两端删除的线性表</p> 
<p><strong>输出受限</strong>的双端队列：只允许从两端插入、一端删除的线性表</p> 
<p><img src="https://images2.imgbox.com/bd/a6/ooydbst0_o.png" alt="image-20220707211955552"></p> 
<h4><a id="33__443"></a>3.3 栈和队列的应用</h4> 
<h5><a id="331__445"></a>3.3.1 栈在括号匹配中的应用</h5> 
<p>最后出现的左括号最先被匹配</p> 
<ol><li> <p>设置一个空栈,顺序读入括号</p> </li><li> <p>若为 ) ,与栈顶 ( 配对出栈或者不合法</p> </li><li> <p>若为 ( ,作为新的更急迫的期待压入栈中</p> </li><li> <p>算法结束,栈为空,否则括号序列不匹</p> </li></ol> 
<p><img src="https://images2.imgbox.com/6a/e1/OsuYw7Mt_o.png" alt="image-20220708090722195"></p> 
<h5><a id="332__459"></a>3.3.2 栈在表达式求值中的应用</h5> 
<p><img src="https://images2.imgbox.com/ee/80/SgVkTnbX_o.png" alt="image-20220708091506370"></p> 
<blockquote> 
 <p>中缀转后缀</p> 
</blockquote> 
<p>中缀转后缀的手算方法</p> 
<p>① 确定中缀表达式中各个运算符的运算顺序</p> 
<p>② 选择下一个运算符，按照==「左操作数 右操作数 运算符」==的方式组合成一个新的操作数</p> 
<p>③ 如果还有运算符没被处理，就继续 ②</p> 
<p><strong>“左优先”原则</strong>：只要左边的运算符能先计算，就优先算左边的 可<strong>保证运算顺序唯一</strong></p> 
<p><strong>后缀表达式的手算方法</strong>： 从左往右扫描，每遇到一个运算符，就让<mark>运算符前面最近的两个操作数</mark>执行对应运算， <mark>合体为一个操作数</mark></p> 
<blockquote> 
 <p>中缀转后缀的机算方法</p> 
</blockquote> 
<p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。</p> 
<p>从左到右处理各个元素，直到末尾。可能遇到三种情况：</p> 
<p>① 遇到操作数。直接加入后缀表达式。</p> 
<p>② 遇到界限符。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到 弹出“(”为止。注意：“(”不加入后缀表达式。</p> 
<p>③ 遇到运算符。依次弹出栈中<mark>优先级</mark>高于或等于当前运算符的所有运算符，并加入后缀表达式， 若碰到“(” 或栈空则停止。之后再把当前运算符入栈</p> 
<blockquote> 
 <p>后缀表达式计算（算法实现）</p> 
</blockquote> 
<p>用栈实现后缀表达式的计算：</p> 
<p>①<mark>从左往右</mark>扫描下一个元素，直到处理完所有元素</p> 
<p>②若扫描到<mark>操作数</mark>则压<mark>入栈</mark>，并回到①；否则执行③</p> 
<p>③若扫描到<mark>运算符</mark>，则<mark>弹出两个栈顶元素</mark>（<mark>先出栈的为右操作数</mark>），执行相应运算，运算结果压回栈顶，回到①</p> 
<blockquote> 
 <p>中缀表达式计算（栈实现） 中缀转后缀+后缀表达式求值</p> 
</blockquote> 
<ol><li>初始化两个栈，<mark>操作数栈</mark>和<mark>运算符栈</mark></li><li>若扫描到操作数，压入操作数栈</li><li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出 运算符，每当<mark>弹出一个运算符</mark>时，就需要再<mark>弹出两个操作数栈的栈顶元素并执行相应运算， 运算结果再压回操作数栈</mark>）</li></ol> 
<blockquote> 
 <p>中缀转前缀</p> 
</blockquote> 
<p>中缀转前缀的手算方法：</p> 
<p>① 确定中缀表达式中各个运算符的运算顺序</p> 
<p>② 选择下一个运算符，按照==「运算符 左操作数 右操作数」==的方式组合成一个新的操作数</p> 
<p>③ 如果还有运算符没被处理，就继续 ②</p> 
<p><strong>“右优先”原则</strong>：只要右边的运算符能先计算，就优先算右边的</p> 
<blockquote> 
 <p>前缀表达式计算（算法实现）</p> 
</blockquote> 
<p>用栈实现前缀表达式的计算：</p> 
<p>①<mark>从右往左</mark>扫描下一个元素，直到处理完所有元素</p> 
<p>②若扫描到操作数则压入栈，并回到①；否则执行③</p> 
<p>③若扫描到运算符，则弹出两个栈顶元素（<mark>先弹出的为左操作数</mark>），执行相应运算，运算结果压回栈顶，回到①</p> 
<p><img src="https://images2.imgbox.com/57/69/DjGtP8Au_o.png" alt="image-20220708094501022"></p> 
<h5><a id="333__537"></a>3.3.3 栈在递归中的应用</h5> 
<p>函数调用的特点：最后被调用的函数最先执行结束（LIFO）</p> 
<p>函数调用时，需要用一个栈存储： ① 调用返回地址 ② 实参 ③ 局部变量</p> 
<p><strong>递归</strong> ：可以把原始问题转换为<mark>属性相同</mark>，但<mark>规模较小</mark>的问题</p> 
<p><strong>两个条件</strong> 1.递归表达式(递归体) 2.边界条件(递归出口)</p> 
<p>递归调用时，函数调用栈可称为“递归工作栈” 每进入一层递归，就将递归调用所需信息压入栈顶 每退出一层递归，就从栈顶弹出相应信</p> 
<p><strong>缺点</strong>：效率低，太多层递归可能会导 致栈溢出；可能包含很多重复计算</p> 
<h5><a id="334__553"></a>3.3.4 队列的应用</h5> 
<blockquote> 
 <p>在层次遍历中的应用</p> 
</blockquote> 
<ol><li>树的遍历</li><li>图的广度优先遍历</li></ol> 
<blockquote> 
 <p>在计算机系统中的应用</p> 
</blockquote> 
<ol><li> <p>FCFS 先来先服务</p> </li><li> <p>解决主机与外部设备之间速度不匹配的问题</p> </li><li> <p>解决由多用户引起的资源竞争问题</p> </li></ol> 
<h4><a id="34__567"></a>3.4 数组和特殊矩阵</h4> 
<h5><a id="341__569"></a>3.4.1 数组</h5> 
<p><strong>数组</strong> ：由n（n&gt;=1）个<mark>相同类型</mark>的数据元素构成的<mark>有限序列</mark>，每个数据元素称为一个数组元素</p> 
<p>数组是线性表的推广</p> 
<blockquote> 
 <p>数组地址计算</p> 
</blockquote> 
<ol><li>一维数组</li></ol> 
<p><img src="https://images2.imgbox.com/3b/15/Q3z6rJ6b_o.png" alt="image-20220708103928626"></p> 
<ol start="2"><li>二维数组–行优先</li></ol> 
<p><img src="https://images2.imgbox.com/f9/27/HiPoUbql_o.png" alt="image-20220708103947011"></p> 
<ol start="3"><li>二维数组–列优先</li></ol> 
<p><img src="https://images2.imgbox.com/a0/06/Df7I7VHw_o.png" alt="image-20220708104003488"></p> 
<h5><a id="342__589"></a>3.4.2 特殊矩阵的压缩存储</h5> 
<p><strong>压缩存储</strong>: 多个值相同的元素只分配一个空间,0不分配空间</p> 
<blockquote> 
 <p>对称矩阵的压缩存储</p> 
</blockquote> 
<p>若 n 阶方阵中任意一个元素 ai,j都有 <mark>ai,j = aj,i</mark> 则该矩阵为<strong>对称矩阵</strong></p> 
<p><img src="https://images2.imgbox.com/9a/b8/OuCIZWCS_o.png" alt="image-20220708104355825"></p> 
<blockquote> 
 <p>三角矩阵的压缩存储</p> 
</blockquote> 
<p><strong>下三角矩阵</strong>：除了主对角线和下三角区，其余的 元素都相同</p> 
<p><strong>上三角矩阵</strong>：除了主对角线和上三角区，其余的 元素都相同</p> 
<p><img src="https://images2.imgbox.com/e8/86/otV5sbCf_o.png" alt="image-20220708104804623"></p> 
<p><img src="https://images2.imgbox.com/72/a6/CDgSKvyl_o.png" alt="image-20220708104824527"></p> 
<blockquote> 
 <p>三对角矩阵的压缩存储</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/3e/50/0wGDDsdZ_o.png" alt="image-20220708104935718"></p> 
<blockquote> 
 <p>稀疏矩阵的压缩存储</p> 
</blockquote> 
<p><strong>压缩存储策略：</strong></p> 
<ol><li>顺序存储——三元组 &lt;行，列，值&gt;</li><li>链式存储——十字链表法</li></ol> 
<p><img src="https://images2.imgbox.com/ce/8d/xTuvr7Ub_o.png" alt="image-20220708105538088"></p> 
<p><img src="https://images2.imgbox.com/88/10/QKqgFpSM_o.png" alt="image-20220708105521154"></p> 
<h3><a id="__626"></a>第四章 串</h3> 
<h4><a id="41__628"></a>4.1 定义和实现</h4> 
<h5><a id="411__630"></a>4.1.1 定义</h5> 
<p><strong>串</strong>，即<mark>字符串</mark>（String）是由零个或多个<mark>字符</mark>组成的有限序列。</p> 
<p>T=‘iPhone 11 Pro Max?’</p> 
<p>子串：串中任意个<mark>连续的</mark>字符组成的子序列。 Eg：’iPhone’，’Pro M’ 是串T 的子串</p> 
<p>主串：包含子串的串。 Eg：T 是子串’iPhone’的主串</p> 
<p>字符在主串中的位置：字符在串中的序号。 Eg：’1’在T中的位置是8(第一次出现)</p> 
<p>子串在主串中的位置：子串的第一个字符在主串中的位置 。 Eg：’11 Pro’在 T 中的位置为</p> 
<p>串的数据对象限定为<mark>字符集</mark>（如中文字符、英文字符、数字字符、标点字符等）</p> 
<p>串的基本操作，如增删改查等通常<mark>以子串为操作对象</mark></p> 
<blockquote> 
 <p>串的基本操作</p> 
</blockquote> 
<p>StrAssign(&amp;T,chars)：赋值操作。把串T赋值为chars。</p> 
<p>StrCopy(&amp;T,S)：复制操作。由串S复制得到串T。</p> 
<p>StrEmpty(S)：判空操作。若S为空串，则返回TRUE，否则返回FALSE。</p> 
<p>StrLength(S)：求串长。返回串S的元素个数。 ClearString(&amp;S)：清空操作。将S清为空串。</p> 
<p>DestroyString(&amp;S)：销毁串。将串S销毁（回收存储空间）。</p> 
<p>Concat(&amp;T,S1,S2)：串联接。用T返回由S1和S2联接而成的新串</p> 
<p>SubString(&amp;Sub,S,pos,len)：求子串。用Sub返回串S的第pos个字符起长度为len的子串。</p> 
<p><mark>Index(S,T)：定位操作</mark>。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的 位置；否则函数值为0。</p> 
<p><mark>StrCompare(S,T)：比较操作</mark>。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S</p> 
<p><img src="https://images2.imgbox.com/e9/28/OiSdWcBY_o.png" alt="image-20220708111427614"></p> 
<h5><a id="412__674"></a>4.1.2 串的存储结构</h5> 
<blockquote> 
 <p>顺序存储</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/aa/56/6gF2pD5H_o.png" alt="image-20220708112033923"></p> 
<h5><a id="413__680"></a>4.1.3 基本操作</h5> 
<ol><li>求子串</li></ol> 
<p><img src="https://images2.imgbox.com/9b/7e/Ox2KMKQ5_o.png" alt="image-20220708112342876"></p> 
<ol start="2"><li>比较</li></ol> 
<p><img src="https://images2.imgbox.com/8e/10/JxnBrUNL_o.png" alt="image-20220708112403796"></p> 
<ol start="3"><li>定位</li></ol> 
<p><img src="https://images2.imgbox.com/d2/00/R3Qc0AKI_o.png" alt="image-20220708112421645"></p> 
<p><img src="https://images2.imgbox.com/e1/08/eNgtlACh_o.png" alt="image-20220708112809109"></p> 
<h4><a id="42__696"></a>4.2 串的模式匹配</h4> 
<h5><a id="421__698"></a>4.2.1 简单的模式匹配算法</h5> 
<p><strong>串的模式匹配</strong>：在<mark>主串</mark>中找到与<mark>模式串</mark>相同的<mark>子串</mark>，并返回其所在位置</p> 
<p>n为主串长度 m为模式串长度</p> 
<p><strong>朴素模式匹配算法</strong> ：将主串中<mark>所有长度为m的子串</mark>依次与模式串对比，直到找到一个完全匹配的或所有的子串都不匹配为止</p> 
<p>当前子串匹配失败：主串指针i指向下一个子串的第一个位置，模式串指针j回到模式串的第一个位置</p> 
<p>当前子串匹配成功：返回当前子串第一个字符的位置</p> 
<p>直到匹配成功/匹配失败最多需要 (n-m+1)*m 次比较</p> 
<p><mark>最坏时间复杂度：O(nm)</mark></p> 
<p><img src="https://images2.imgbox.com/aa/35/EBAkwT1g_o.png" alt="image-20220708135954588"></p> 
<h5><a id="422_KMP_716"></a>4.2.2 KMP算法</h5> 
<p><img src="https://images2.imgbox.com/f6/f3/BM3wW4ax_o.png" alt="image-20220708141849092"></p> 
<p><mark>最坏时间复杂度：O(m+n)</mark></p> 
<p><img src="https://images2.imgbox.com/a5/c2/A6m7PDIq_o.png" alt="image-20220708143731549"></p> 
<h3><a id="__726"></a>第五章 树与二叉树</h3> 
<h4><a id="51__728"></a>5.1 树的基本概念</h4> 
<h5><a id="511__730"></a>5.1.1 树的定义</h5> 
<p><strong>树</strong>是n（n≥0）个<mark>结点</mark>的有限集合，n = 0时，称为<mark>空树</mark>，这是一种特殊情况。</p> 
<p>在任意一棵非 空树中应满足：</p> 
<p>1）<mark>有且仅有一个</mark>特定的称为<mark>根的结点</mark>。</p> 
<p>2）当n &gt; 1时，其余结点可分为m（m &gt; 0）个<mark>互不相交</mark>的<mark>有限集合</mark>T1, T2,…, Tm，其中每个集 合本身又是一棵树，并且称为根结点的<mark>子树</mark>。</p> 
<p><strong>非空树的特性</strong>：</p> 
<ol><li><mark>有且仅有一个根节点</mark></li><li>没有后继的结点称为“<mark>叶子结点</mark>”（或终端结点）</li><li>有后继的结点称为“<mark>分支结点</mark>”（或非终端结点）</li><li>除了根节点外，任何一个结点都<mark>有且仅有一个前驱</mark></li><li>每个结点可以有<mark>0个或多个后继</mark>。</li></ol> 
<p>树是一种<strong>递归定义</strong>的数据结构</p> 
<h5><a id="512__752"></a>5.1.2 基本术语</h5> 
<ol><li><mark>结点的度</mark> 一个结点的子结点个数</li><li><mark>树的度</mark> 树中结点的最大度数</li><li><strong>结点的深度</strong> 从根结点开始自顶向下逐层累加</li><li><strong>结点的高度</strong> 从叶结点开始自底向上逐层累加</li><li><strong>树的高度(深度)</strong> 树中结点的最大层数</li><li>两结点之间的<strong>路径</strong> 两结点之间经过的结点序列</li><li><strong>路径长度</strong> 路径上经过的边的个数</li><li>注意 树中的分支是有向的(双亲指向孩子),路径从上向下,两个孩子之间不存在路径</li></ol> 
<p><strong>有序树</strong>——逻辑上看，树中结点的各子树从左至右是有次序的，不能互换</p> 
<p><strong>无序树</strong>——逻辑上看，树中结点的各子树从左至右是无次序的，可以互换</p> 
<p>**森林：**森林是m（m≥0）棵<mark>互不相交</mark>的<mark>树</mark>的集合</p> 
<p><img src="https://images2.imgbox.com/0f/2d/wnlLBr1y_o.png" alt="image-20220709084427285"></p> 
<h5><a id="513__773"></a>5.1.3 树的性质</h5> 
<ol><li><mark>结点数=总度数+1</mark></li><li><strong>度为m的树、m叉树 的区别</strong></li></ol> 
<p><img src="https://images2.imgbox.com/df/6c/EuZ509ZH_o.png" alt="image-20220709084722559"></p> 
<ol start="3"><li> <p>度为m的树第 i 层至多有 <strong>m<sup>i-1</sup></strong> 个结点（i≥1）</p> <p>m叉树第 i 层至多有 <strong>m<sup>i-1</sup></strong> 个结点（i≥1）</p> </li><li> <p>高度为h的m叉树至少有 <strong>h</strong> 个结点</p> <p>高度为h、度为m的树至少有 <strong>h+m-1</strong> 个结点</p> </li><li> <p>高度为h的m叉树至多有 <strong>(m<sup>h</sup> -1)/m-1</strong> 个结点</p> </li><li> <p>具有n个结点的m叉树的最小高度为 <strong>[logm(n(m - 1) + 1)]</strong></p> <p><img src="https://images2.imgbox.com/11/0b/u1gT8uhm_o.png" alt="image-20220709085557148"></p> </li></ol> 
<h4><a id="52__796"></a>5.2 二叉树的概念</h4> 
<h5><a id="521__798"></a>5.2.1 二叉树的定义及主要特征</h5> 
<p><strong>二叉树</strong>是n（n≥0）个结点的有限集合：</p> 
<p>① 或者为空二叉树，即n = 0。</p> 
<p>② 或者由一个根结点和两个互不相交的被称为根的<mark>左子树和右子树</mark>组成。左子树和右子树 又分别是一棵二叉树。</p> 
<p><strong>特点</strong>：①<mark>每个结点至多只有两棵子树</mark> ②<mark>左右子树不能颠倒</mark>（二叉树是有序树）</p> 
<blockquote> 
 <p>二叉树与度为2的有序树的区别</p> 
</blockquote> 
<ol><li> <p>度为2的树至少有3个结点,二叉树可为空</p> </li><li> <p>度为2的有序树的孩子的左右次序相对于另一个孩子无须区分左右</p> <p>二叉树是有序树</p> </li></ol> 
<p><img src="https://images2.imgbox.com/1f/7a/urHvUIMm_o.png" alt="image-20220709091029068"></p> 
<blockquote> 
 <p>特殊的二叉树</p> 
</blockquote> 
<ol><li> <p><mark>满二叉树</mark>：一棵高度为h，且含有2<sup>h</sup> - 1个结点的二叉树</p> <p><strong>树中的每层都含有最多的结点</strong>，只有最后一层有叶子结点 且不存在度为 1 的结点</p> </li><li> <p><mark>满二叉树</mark>：当且仅当其每个结点都与高度为h的 满二叉树中编号为1～n的结点一一对应时，称为 完全二叉树</p> <p><strong>叶子结点只在最大的两层上</strong> ，<strong>若有度为1的结点,只有一个,该结点只能是左孩子</strong></p> </li></ol> 
<p><img src="https://images2.imgbox.com/87/39/rDqkIlYf_o.png" alt="image-20220709091529726"></p> 
<ol start="3"><li> <p><mark>二叉排序树</mark></p> <p>（1）左子树上所有结点的关键字小于根结点</p> <p>（2）右子树上所有结点的关键字大于根结点</p> <p>（3）左右子树又各是一颗二叉排序树</p> <p><img src="https://images2.imgbox.com/61/8b/JF3vY7Pu_o.png" alt="image-20220709091841885"></p> </li><li> <p><mark>平衡二叉树</mark>：树上任一结点的左子树和右子树的深度之差不超过1（搜索效率高）</p> </li></ol> 
<p><img src="https://images2.imgbox.com/77/4e/8z5064EC_o.png" alt="image-20220709092221614"></p> 
<h5><a id="522__844"></a>5.2.2 二叉树的性质</h5> 
<ol><li> <p>设非空<mark>二叉树</mark>中度为0、1和2的结点个数分别为n0、n1和n2，则 <mark>n0 = n2 + 1</mark> （<mark>叶子结点比二分支结点多一个</mark>）</p> </li><li> <p>二叉树第 i 层至多有 2<sup>i-1</sup> 个结点（i≥1）</p> <p>m叉树第 i 层至多有 m<sup>i-1</sup> 个结点（i≥1）</p> </li><li> <p>高度为h的m叉树至多有 <strong>(m<sup>h</sup> -1)/m-1</strong> 个结点</p> <p>高度为h的2叉树至多有2<sup>h</sup>-1个结点</p> </li></ol> 
<blockquote> 
 <p>完全二叉树的常见考点</p> 
</blockquote> 
<ol><li> <p>具有n个（n &gt; 0）结点的完全二叉树的高度h为<mark>log2(n + 1)或log2n + 1</mark></p> </li><li> <p>对于完全二叉树，可以由的结点数 n 推出度为0、1和2的结点个数为n0、n1和n2</p> <p>若完全二叉树有2k个（偶数）个结点，则 必有 n1=1， n0 = k， n2 = k-1</p> <p>若完全二叉树有2k-1个（奇数）个结点，则 必有 n1=0， n0 = k， n2 = k-1</p> </li></ol> 
<h5><a id="523__866"></a>5.2.3 二叉树的存储结构</h5> 
<blockquote> 
 <p>顺序存储</p> 
</blockquote> 
<p>几个重要常考的基本操作：</p> 
<ol><li>i 的左孩子 ——2i</li><li>i 的右孩子 ——2i+1</li><li>i 的父节点—— i/2</li><li>i 所在的层次 —— log2(n + 1)或log2n+ 1</li></ol> 
<p>若<mark>完全二叉树</mark>中共有n个结点，则</p> 
<ol><li>判断 i 是否有左孩子？ ——2i ≤ n</li><li>判断 i 是否有右孩子？ ——2i+1 ≤ n</li><li>判断 i 是否是叶子/分支结点？——i &gt; n/2</li></ol> 
<p>二叉树的顺序存储中，一定要<mark>把二叉 树的结点编号与完全二叉树对应起来</mark></p> 
<p>最坏情况：高度为 h 且只有 h 个结点的单 支树（所有结点只有右孩子），也至少需 要 2h-1 个存储单元</p> 
<p>结论：二叉树的顺序存储结构，<mark>只适合存 储完全二叉树</mark></p> 
<blockquote> 
 <p>链式存储</p> 
</blockquote> 
<ol><li> <p>二叉链表3个域: data,lchild,rchild</p> </li><li> <p>n个结点的二叉链表有n+1个空链域(根结点不用指针)形成线索链表</p> </li></ol> 
<p><img src="https://images2.imgbox.com/f5/85/hS9r91L4_o.png" alt="image-20220709101508575"></p> 
<h4><a id="53__897"></a>5.3 二叉树的遍历和线索二叉树</h4> 
<h5><a id="531__899"></a>5.3.1 二叉树的遍历</h5> 
<p><strong>遍历</strong>：按照某种次序把所有结点都访问一遍</p> 
<p><mark>先序遍历：根左右（NLR）</mark></p> 
<p><img src="https://images2.imgbox.com/4f/a9/KZErhR9C_o.png" alt="image-20220709103512834"></p> 
<p><mark>中序遍历：左根右（LNR）</mark></p> 
<p><img src="https://images2.imgbox.com/ab/55/tfq3T75w_o.png" alt="image-20220709103528779"></p> 
<p><mark>后序遍历：左右根（LRN）</mark></p> 
<p><img src="https://images2.imgbox.com/be/09/F6LaexwX_o.png" alt="image-20220709103541387"></p> 
<blockquote> 
 <p>层序遍历</p> 
</blockquote> 
<p><strong>算法思想：</strong></p> 
<p>①初始化一个辅助队列</p> 
<p>②根结点入队</p> 
<p>③若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾（如果有的话）</p> 
<p>④重复③直至队列为空</p> 
<blockquote> 
 <p>由遍历序列构造二叉树</p> 
</blockquote> 
<p>若只给出一棵二叉树的 前/中/后/层 序遍历序列中的一种，不能<mark>唯一</mark>确定一棵二叉树</p> 
<ol><li><strong>先序和中序</strong></li></ol> 
<p>（1）先序中: 第一个为根结点</p> 
<p>（2）中序中: 根结点分割成两个子序列,前左子树,后右子树</p> 
<p>（3）先序中: 找到两个子序列,各自的第一个结点又是根结点</p> 
<p><img src="https://images2.imgbox.com/55/23/fd3F9ki2_o.png" alt="image-20220709111900495"></p> 
<ol start="2"><li> <p><strong>后序和中序</strong> 后序最后一个结点相当于先序第一个结点</p> <p><img src="https://images2.imgbox.com/32/95/sFG1PLDz_o.png" alt="image-20220709112218194"></p> </li><li> <p><strong>层序和后序</strong>不可以</p> <p><img src="https://images2.imgbox.com/12/d5/vTCKO0WL_o.png" alt="image-20220709112314560"></p> </li></ol> 
<p><img src="https://images2.imgbox.com/57/df/YXkE4Xxz_o.png" alt="image-20220709112535353"></p> 
<h5><a id="532___951"></a>5.3.2 <mark>线索二叉树</mark> (没理解)</h5> 
<p><strong>目的</strong>: 加快查找结点前驱和后继的速度</p> 
<p><strong>线索</strong>: 指向前驱和后继的指针</p> 
<p><strong>线索化</strong>: 对二叉树以某种次序遍历使其成为线索二叉树的过程</p> 
<p>无左子树,令<mark>lchild指向前驱</mark>结点;无右子树,令<mark>rchild指向后继</mark>结点 前驱,后继由具体的遍历方式决定</p> 
<p><img src="https://images2.imgbox.com/21/86/lgayp7jx_o.png" alt="image-20220709113849622"></p> 
<p><img src="https://images2.imgbox.com/0e/5c/HMqHzs00_o.png" alt="image-20220709114211727"></p> 
<p><img src="https://images2.imgbox.com/78/be/KqJqa0uM_o.png" alt="image-20220709114733467"></p> 
<blockquote> 
 <p>二叉树线索化</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/5e/0d/sJYV9P2Y_o.png" alt="image-20220709162648385"></p> 
<h4><a id="54__973"></a>5.4 树、森林</h4> 
<h5><a id="541__975"></a>5.4.1 树的存储结构</h5> 
<blockquote> 
 <p>双亲表示法（顺序存储）</p> 
</blockquote> 
<ol><li>定义: 连续空间存储,每个结点增设一个伪指针,<mark>指示双亲在数组中位置</mark>,根结点下标为0,其伪指针为-1</li><li>特点: 可以很快得到双亲,但求孩子要遍历整个结构</li></ol> 
<p><img src="https://images2.imgbox.com/54/89/izKWvR8w_o.png" alt="image-20220709163129152"></p> 
<blockquote> 
 <p>孩子表示法（顺序+链式存储）</p> 
</blockquote> 
<ol><li> <p>定义：顺序存储各个节点，每个结点中<mark>保存孩子 链表头指针</mark></p> </li><li> <p>特点: 求孩子很方便,求双亲不方便</p> </li></ol> 
<p><img src="https://images2.imgbox.com/9a/c1/nbMgF8G3_o.png" alt="image-20220709164111137"></p> 
<blockquote> 
 <p>孩子兄弟表示法（链式存储）</p> 
</blockquote> 
<ol><li>定义: <mark>左指针指向第一个孩子</mark>,<mark>右指针指向第一个兄弟</mark>,二叉链表作为存储结构</li><li>优点: 方便实现树转化为二叉树,易于查找孩子</li><li>缺点: 查找双亲麻烦,若增设parent指向双亲,会方便</li></ol> 
<p><img src="https://images2.imgbox.com/c4/44/nMZFNikQ_o.png" alt="image-20220709164442780"></p> 
<h5><a id="542__1000"></a>5.4.2 树、森林和二叉树的转换</h5> 
<blockquote> 
 <p>树转换为二叉树</p> 
</blockquote> 
<p><mark>左指针指向第一个孩子</mark>,<mark>右指针指向第一个兄弟</mark>,根没有兄弟,二叉树没有右子树</p> 
<p><img src="https://images2.imgbox.com/a9/5d/xtUr2DwO_o.png" alt="image-20220709165231103"></p> 
<blockquote> 
 <p>森林转化为二叉树</p> 
</blockquote> 
<p>森林中的树依次转化为二叉树，<mark>每棵二叉树的根依次作为上一颗二叉树的右子树</mark></p> 
<p><img src="https://images2.imgbox.com/44/7a/uvRt0Oo4_o.png" alt="image-20220709165252421"></p> 
<blockquote> 
 <p>二叉树转化为森林</p> 
</blockquote> 
<ol><li>二叉树的根及左子树作为第一棵树的二叉树形态,再转换为树(右孩子变为兄弟)</li><li>根的右子树及其左孩子作为第二棵树,右孩子作为第三棵树,反复下去</li></ol> 
<p><img src="https://images2.imgbox.com/9e/07/FSfubq9M_o.png" alt="image-20220709165545835"></p> 
<p><img src="https://images2.imgbox.com/a3/76/eSjf4uak_o.png" alt="image-20220709165612646"></p> 
<h5><a id="543__1023"></a>5.4.3 树和森林的遍历</h5> 
<blockquote> 
 <p>树的先根遍历（深度优先遍历）</p> 
</blockquote> 
<p>先访问根,再从左到右遍历每棵子树,与相应二叉树的先序序列相同</p> 
<blockquote> 
 <p>树的后根遍历（深度优先遍历）</p> 
</blockquote> 
<p>从左到右遍历每棵子树,再访问根，与这棵树相应二叉树的 中序序列相同</p> 
<blockquote> 
 <p>树的层次遍历（广度优先遍历）</p> 
</blockquote> 
<p>①若树非空，则根节点入队</p> 
<p>②若队列非空，队头元素出队并访问，同 时将该元素的孩子依次入队</p> 
<p>③重复②直到队列为空</p> 
<blockquote> 
 <p>森林的先序遍历==依次对各个子树进行先序遍历</p> 
</blockquote> 
<p>若森林为非空，则按如下规则进行遍历：</p> 
<p>​ (1)访问森林中第一棵树的根结点。</p> 
<p>​ (2)先序遍历第一棵树中根结点的子树森林。</p> 
<p>​ (3)先序遍历除去第一棵树之后剩余的树构成的森林。</p> 
<blockquote> 
 <p>森林的中序遍历==依次对各个子树进行后序遍历</p> 
</blockquote> 
<p>若森林为非空，则按如下规则进行遍历：</p> 
<p>​ （1） 中序遍历森林中第一棵树的根结点的子树森林。</p> 
<p>​ （2） 访问第一棵树的根结点。</p> 
<p>​ （3）中序遍历除去第一棵树之后剩余的树构成的森林</p> 
<h4><a id="55__1061"></a>5.5 树与二叉树的应用</h4> 
<h5><a id="551__1063"></a>5.5.1 哈夫曼树和哈夫曼编码</h5> 
<p>结点的<mark>权</mark>：有某种现实含义的数值（如：表示结点的重要性等）</p> 
<p><mark>结点的带权路径长度</mark>：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积</p> 
<p><mark>树的带权路径长度</mark>：树中所有<mark>叶结点</mark>的带权路径长度之和</p> 
<p><strong>定义：</strong> 在含有n个带权叶结点的二叉树中，其中<mark>带权路径长度（WPL）最小</mark>的二叉树称为<mark>哈夫曼树</mark>，也称<mark>最优二叉树</mark></p> 
<blockquote> 
 <p>哈夫曼树的构造</p> 
</blockquote> 
<p>给定n个权值分别为w1, w2,…, wn的结点，构造哈夫曼树的算法描述如下：</p> 
<p>​ （1）将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。</p> 
<p>​ （2）构造一个新结点，从F中选取两棵<mark>根结点权值最小的树</mark>作为新结点的左、右子树，并且将<mark>新 结点的权值置为左、右子树上根结点的权值之和</mark>。</p> 
<p>​ （3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。</p> 
<p>​ （4）重复步骤2）和3），直至F中只剩下一棵树为止。</p> 
<blockquote> 
 <p>特点</p> 
</blockquote> 
<pre><code>1. 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大 
2. 哈夫曼树的==结点总数为2n − 1== 
3. 哈夫曼树中不存在度为1的结点。 
4. 哈夫曼树并==不唯一==，但==WPL必然相同且为最优==
</code></pre> 
<blockquote> 
 <p>哈夫曼编码</p> 
</blockquote> 
<p>**固定长度编码:**每个字符用相等长度的二进制位表示</p> 
<p><strong>可变长度编码</strong>：允 许对不同字符用不等 长的二进制位表示</p> 
<p><strong>前缀编码</strong> :没有一个编码是另一个编码的前缀</p> 
<p><mark>构造哈夫曼编码：</mark></p> 
<p>​ （1）字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点 的权值，根据之前介绍的方法<mark>构造哈夫曼树</mark></p> 
<p>​ （2）从根结点到叶子结点的路径上标记序列,0转向左孩子,1转向右孩子</p> 
<p><img src="https://images2.imgbox.com/3c/92/FVNLaokL_o.png" alt="image-20220709174523041"></p> 
<h5><a id="552__1108"></a>5.5.2 并查集</h5> 
<p><img src="https://images2.imgbox.com/77/10/IAM22PyJ_o.png" alt="image-20220709180344958"></p> 
<p><img src="https://images2.imgbox.com/08/ce/oZ7WvYSn_o.png" alt="image-20220709180434521"></p> 
<p><img src="https://images2.imgbox.com/cb/41/CqbGlUdw_o.png" alt="image-20220709180509148"></p> 
<h3><a id="__1116"></a>第六章 图</h3> 
<h4><a id="61__1118"></a>6.1 图的基本概念</h4> 
<blockquote> 
 <p>图的定义</p> 
</blockquote> 
<p><mark>图G</mark>由<mark>顶点集V</mark>和<mark>边集E</mark>组成，记为<mark>G = (V, E)</mark>，其中V(G)表示图G中顶点的<mark>有限非空集</mark>；E(G) 表示图G中顶点之间的关系（边）集合。若V = {v1, v2, … , vn}，则用==|V|表示图G中顶点的个 数==，也称<mark>图G的阶</mark>，E = {(u, v) | uÎV, vÎV}，用==|E|表示图G中边的条数==。</p> 
<p><strong>注意</strong>：线性表可以是空表，树可以是空树，但图不可以是空，即<strong>V一定是非空集</strong> ，E可以是空集</p> 
<p><strong>有向图：</strong> 若<mark>E是有向边</mark>（也称<mark>弧</mark>）的有限集合时，则图G为<mark>有向图</mark>。 弧是顶点的有序对，记为==&lt;v,w&gt;<mark>，其中v、w是顶点，v称为 <mark>弧尾</mark>，w称为</mark>弧头==，称为从顶点v到顶点w的弧，也称 v邻接到w，或w邻接自v。 &lt;v,w&gt; ≠&lt;w,v&gt;</p> 
<p><strong>无向图：</strong> 若E是<mark>无向边</mark>（简称<mark>边</mark>）的有限集合时，则图G为无向图。边 是顶点的无序对，<mark>记为(v, w)或(w, v)</mark>，因为==(v, w) = (w, v)<mark>，其 中v、w是</mark>顶点==。可以说顶点w和顶点v互为邻接点。边(v, w) 依附于顶点w和v，或者说边(v, w)和顶点v、w相关联。</p> 
<p>**简单图：**① 不存在重复边； ② 不存在顶点到自身的边</p> 
<p><strong>多重图</strong>：图G中某两个结点之间的边数多于 一条，又允许顶点通过同一条边和自己关联， 则G为多重图</p> 
<blockquote> 
 <p>顶点的度、入度、出度</p> 
</blockquote> 
<p><strong>无向图：</strong><mark>顶点v的度</mark>是指依附于该顶点的边的条数，记为<mark>TD(v)</mark>。</p> 
<p>​ 无向图的全部顶点的度的和等于边数的2倍</p> 
<p><strong>有向图：</strong> <mark>入度</mark>是以顶点v为终点的有向边的数目，记为<mark>ID(v)</mark>；</p> 
<p>​ <mark>出度</mark>是以顶点v为起点的有向边的数目，记为<mark>OD(v)</mark>。</p> 
<pre><code>			==顶点v的度==等于其入度和出度之和，即TD(v) = ID(v) + OD(v)。
</code></pre> 
<blockquote> 
 <p>顶点-顶点的关系描述</p> 
</blockquote> 
<ol><li><strong>路径</strong>——顶点vp到顶点vq之间的一条路径是指顶点序列 ，</li><li><strong>回路</strong>——第一个顶点和最后一个顶点相同的路径称为回路或环</li><li><strong>简单路径</strong>——在路径序列中，顶点不重复出现的路径称为简单路径。</li><li><strong>简单回路</strong>——除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</li><li><strong>路径长度</strong>——路径上边的数目</li><li><strong>点到点的距离</strong>——从顶点u出发到顶点v的<strong>最短路径</strong>若存在，则此路径的长度称为从u到v的距离。 若从u到v根本不存在路径，则记该距离为无穷（∞）</li><li><strong>无向图</strong>中，若从顶点v到顶点w有路径存在，则称v和w是<strong>连通</strong>的</li><li><strong>有向图</strong>中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是<strong>强连通</strong>的</li><li>若图G中任意两个顶点都是连通的，则称图G为 <strong>连通图</strong>，否则称为非连通图</li><li>若图中任何一对顶点都是强连通的，则称此图为 <strong>强连通图</strong></li></ol> 
<p><img src="https://images2.imgbox.com/f1/0d/D3QAh5Ay_o.png" alt="image-20220715093902232"></p> 
<ol start="11"><li> <p><strong>子图：</strong> 设有两个图G = (V, E)和G’ = (V’,E’)，若<mark>V’是V的子集</mark>，且<mark>E’是 E的子集</mark>，则称G¢是G的子图。</p> </li><li> <p><strong>生成子图</strong>：满足==V(G’) = V(G)==的子图G’</p> </li><li> <p><strong>连通分量：</strong> <mark>无向图</mark>中的<mark>极大连通子图</mark>称为连通分量。</p> <p><strong>极大连通子图</strong>：子图必须连通，且包含 尽可能多的顶点和边</p> </li><li> <p><strong>强连通分量:</strong><mark>有向图</mark><mark>中的极大强连通子图称为有向图的强连通分量</mark></p> </li><li> <p><mark>连通图(无向)<mark>的<strong>生成树</strong>是</mark>包含图中全部顶点</mark>的一个<mark>极小连通子图</mark></p> <p>若图中顶点数为n，则它的生成树含有 n-1 条边。</p> </li><li> <p>在<mark>非连通图</mark>中，<mark>连通分量的生成树</mark>构成了非连通图的<strong>生成森林</strong>。</p> </li></ol> 
<blockquote> 
 <p>边的权、带权图/网</p> 
</blockquote> 
<p><strong>边的权</strong>——在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的<mark>权值</mark>。</p> 
<p><strong>带权图/网</strong>——<mark>边上带有权值</mark>的图称为带权图，也称网。</p> 
<p><strong>带权路径长度</strong>——当图是带权图时，一<mark>条路径上所有边的权值之和</mark>，称为该路径的带权路径长度</p> 
<blockquote> 
 <p>特殊形态的图</p> 
</blockquote> 
<p><strong>无向完全图</strong>——无向图中<mark>任意两个顶点 之间都存在边</mark></p> 
<p><strong>有向完全图</strong>——有向图中<mark>任意两个顶点 之间都存在方向相反的两条弧</mark></p> 
<p>边数很少的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong></p> 
<p><img src="https://images2.imgbox.com/9b/52/wmqqzJda_o.png" alt="image-20220715095802210"></p> 
<p><img src="https://images2.imgbox.com/b8/14/nZZRYZIi_o.png" alt="image-20220715095847581"></p> 
<p><strong>树</strong>——<mark>不存在回路</mark>，且连通的无向图</p> 
<p>​ n个顶点的树，必有n-1条边</p> 
<p><strong>有向树</strong>——一个顶点的入度为0、其余顶点的 入度均为1的有向图，称为有向树</p> 
<p><img src="https://images2.imgbox.com/1e/1f/gXyBpSmC_o.png" alt="image-20220715100009796"></p> 
<p><img src="https://images2.imgbox.com/89/60/5e05HDik_o.png" alt="image-20220715100802244"></p> 
<h4><a id="62__1207"></a>6.2 图的存储及基本操作</h4> 
<h5><a id="621__1209"></a>6.2.1 邻接矩阵法</h5> 
<p><img src="https://images2.imgbox.com/f5/a8/RRf5mo80_o.png" alt="image-20220715101044162"></p> 
<p>第i个结点的<mark>度 = 第i行（或第i列）的非零元素个数</mark></p> 
<p>第i个结点的<mark>出度</mark> = 第<mark>i行</mark>的非零元素个数</p> 
<p>第i个结点的<mark>入度</mark> = 第<mark>i列</mark>的非零元素个数</p> 
<p>第i个结点的度 = 第i行、第i列的非零元素个数之和</p> 
<p>邻接矩阵法<mark>求顶点的度/出度/入度</mark>的<mark>时间复杂度为 O(|V|)</mark></p> 
<p><mark>空间复杂度：O(|V|<sup>2</sup> )</mark> ——只和顶点数相关，和实际的边数无关</p> 
<blockquote> 
 <p>邻接矩阵法的性质</p> 
</blockquote> 
<p>设图G的邻接矩阵为A（矩阵元素为0/1），则A<sup>n</sup> 的元素<mark>A<sup>n</sup> [i] [j]<mark>等于由</mark>顶点i到顶点j</mark>的<mark>长度为n</mark>的<mark>路径的数目</mark></p> 
<p><img src="https://images2.imgbox.com/bf/c2/cg6wbXg3_o.png" alt="image-20220715101636629"></p> 
<h5><a id="622__1231"></a>6.2.2 邻接表法</h5> 
<p><img src="https://images2.imgbox.com/a2/cf/52Raf9pq_o.png" alt="image-20220715101745011"></p> 
<p><img src="https://images2.imgbox.com/cf/24/6IoF3Zq5_o.png" alt="image-20220715101828254"></p> 
<h5><a id="623__1237"></a>6.2.3 邻接多重表</h5> 
<p><img src="https://images2.imgbox.com/7d/09/fxOwrepA_o.png" alt="image-20220715102109763"></p> 
<h5><a id="624__1241"></a>6.2.4 十字链表</h5> 
<p><img src="https://images2.imgbox.com/aa/18/phji4Vmq_o.png" alt="image-20220715102002952"></p> 
<p><img src="https://images2.imgbox.com/53/98/mkbpwPWZ_o.png" alt="image-20220715102018289"></p> 
<p><img src="https://images2.imgbox.com/de/99/FO7QeCCi_o.png" alt="image-20220715102130523"></p> 
<h5><a id="625__1249"></a>6.2.5 图的基本操作</h5> 
<p>• Adjacent(G,x,y)：判断图G是否存在边或(x, y)。</p> 
<p>• Neighbors(G,x)：列出图G中与结点x邻接的边。</p> 
<p>• InsertVertex(G,x)：在图G中插入顶点x。</p> 
<p>• DeleteVertex(G,x)：从图G中删除顶点x。</p> 
<p>• AddEdge(G,x,y)：若无向边(x, y)或有向边不存在，则向图G中添加该边。</p> 
<p>• RemoveEdge(G,x,y)：若无向边(x, y)或有向边存在，则从图G中删除该边。</p> 
<p>• <mark>FirstNeighbor(G,x)</mark>：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点 或图中不存在x，则返回-1。</p> 
<p>• <mark>NextNeighbor(G,x,y)</mark>：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一 个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。</p> 
<p>• Get_edge_value(G,x,y)：获取图G中边(x, y)或对应的权值。</p> 
<p>• Set_edge_value(G,x,y,v)：设置图G中边(x, y)或对应的权值为v。</p> 
<h4><a id="63__1271"></a>6.3 图的遍历</h4> 
<h5><a id="631_BFS_1273"></a>6.3.1 广度优先遍历BFS</h5> 
<p>**步骤：**1. 找到与⼀个顶点相邻的所有顶点</p> 
<ol start="2"><li>标记哪些顶点被访问过</li><li>需要⼀个辅助队列</li></ol> 
<p><img src="https://images2.imgbox.com/e4/28/ncXchsSo_o.png" alt="image-20220715103208306"></p> 
<p>同⼀个图的<mark>邻接矩阵表示⽅式唯⼀</mark>，因此<mark>⼴度优先遍历序列唯⼀</mark></p> 
<p>同⼀个图<mark>邻接表</mark>表示⽅式不唯⼀，因此⼴度优先遍历序列<mark>不唯⼀</mark></p> 
<p><strong>存在的问题</strong>：如果是⾮连通图，则⽆法遍历完所有结点</p> 
<p><img src="https://images2.imgbox.com/ee/6b/dIWQWlFY_o.png" alt="image-20220715103403877"></p> 
<p><strong>性能分析</strong> ：空间复杂度: O(|V|)</p> 
<p>​ 时间复杂度：邻接表:O(|V|+|E|) 邻接矩阵:O(|V|²)</p> 
<p>​</p> 
<p><strong>广度优先生成树</strong></p> 
<p><strong>定义</strong>: 广度遍历过程中,得到的一颗遍历树</p> 
<p><strong>特点</strong>: <mark>邻接矩阵中唯一,邻接表中不唯一</mark></p> 
<p>对⾮连通图的⼴度优先遍历，可得到⼴度优先⽣成森林</p> 
<p><img src="https://images2.imgbox.com/7a/f3/ZedDGNwI_o.png" alt="image-20220715103717354"></p> 
<h5><a id="632_DFS_1306"></a>6.3.2 深度优先遍历DFS</h5> 
<p><strong>步骤：</strong></p> 
<ol><li>首先访问起始顶点v</li><li>访问v的未访问过的任一邻接顶点w</li><li>再访问w的未访问过的任一邻接顶点w2</li><li>重复下去,直到不能继续向下访问,依次退回到最近被访问的顶点</li></ol> 
<p><img src="https://images2.imgbox.com/44/d8/8NEC7Jnw_o.png" alt="image-20220715103938104"></p> 
<p>存在的问题：如果是⾮连通图，则⽆法遍历完所有结点</p> 
<p><img src="https://images2.imgbox.com/ad/87/5oSUWIHB_o.png" alt="image-20220715104034939"></p> 
<p><strong>性能分析：</strong></p> 
<p><strong>空间复杂度</strong>：来⾃函数调⽤栈，最坏情况，递归深度为<mark>O(|V|)</mark></p> 
<p>时间复杂度=访问各结点所需时间+探索各条边所需时间</p> 
<p><mark>邻接表:O(|V|+|E|)，邻接矩阵:O(|V|²)</mark></p> 
<p>同⼀个图的<mark>邻接矩阵表示⽅式唯⼀</mark>，因此<mark>深度优先遍历序列唯⼀</mark>，深度优先⽣成树也唯⼀</p> 
<p>同⼀个图<mark>邻接表表示⽅式不唯⼀</mark>，因此<mark>深度优先遍历序列不唯⼀</mark>，深度优先⽣成树也不唯⼀</p> 
<h5><a id="633__1333"></a>6.3.3 图的遍历与图的连通性</h5> 
<p>对<mark>⽆向图</mark>进⾏BFS/DFS遍历 调⽤BFS/DFS函数的<mark>次数=连通分量数</mark></p> 
<p>对于<mark>连通图</mark>，只需调⽤1次 BFS/DFS</p> 
<p>对于<mark>强连通图</mark>，从任⼀结点出发都只需调⽤1次 BFS/DFS</p> 
<p><img src="https://images2.imgbox.com/db/19/NmKeBk9C_o.png" alt="image-20220715104946409"></p> 
<h4><a id="64__1343"></a>6.4 图的应用</h4> 
<h5><a id="641__1345"></a>6.4.1 最小生成树</h5> 
<p>对于⼀个<mark>带权连通⽆向图G = (V, E)</mark>，⽣成树不同，每棵树的权（即树中所有边上的权值 之和）也可能不同。设R为G的所有⽣成树的集合，若T为R中边的<mark>权值之和最⼩的⽣成 树</mark>，则T称为G的<mark>最⼩⽣成树</mark>（Minimum-Spanning-Tree, <mark>MST</mark>）。</p> 
<p>• 最⼩⽣成树可能有多个，但边的<mark>权值之和总是唯⼀且最⼩的</mark></p> 
<p>• <mark>最⼩⽣成树的边数 = 顶点数 - 1</mark>。砍掉⼀条则不连通，增加⼀条边则会出现回路</p> 
<p>• 如果⼀个连通图本身就是⼀棵树，则其最⼩⽣成树就是它本身</p> 
<p>• <mark>只有连通图才有⽣成树</mark>，⾮连通图只有⽣成森林</p> 
<blockquote> 
 <p>Prim 算法（普⾥姆）</p> 
</blockquote> 
<p>从某⼀个顶点开始构建⽣成树； 每次将代价最⼩的新顶点纳⼊⽣成 树，直到所有顶点都纳⼊为⽌。</p> 
<p><strong>步骤：</strong></p> 
<ol><li>初始化: 先任选一个顶点作为初始顶点</li><li>循环(直到包含所有顶点): 再选择这个顶点的邻边中权值最小的边且不会构成回路</li><li>再选择这两个顶点的邻边中权值最小的边且不会构成回路</li></ol> 
<p><strong>特点：</strong> 时间复杂度: O(|V|²),不依赖于|E|,适合边稠密的图</p> 
<blockquote> 
 <p>Kruskal 算法（克鲁斯卡尔）</p> 
</blockquote> 
<p>每次选择⼀条权值最⼩的边，使这 条边的两头连通（原本已经连通的 就不选） 直到所有结点都连通</p> 
<p><strong>步骤：</strong></p> 
<ol><li>初始化: 先包含所有的顶点,没有边</li><li>循环(直到成为一棵树): 按权值递增的顺序选择边且不构成回路,直到包含n-1条边</li></ol> 
<p><strong>特点：</strong> 采用堆存放边集合,时间复杂度O(|E|log|E|),适合边稀疏而顶点较多的图</p> 
<h5><a id="642__1382"></a>6.4.2 最短路径</h5> 
<blockquote> 
 <p>BFS求⽆权图的单源最短路径</p> 
</blockquote> 
<p>⽆权图可以视为⼀种特殊的带权图，只是<mark>每条边的权值都为1</mark></p> 
<p>BFS算法求单源最短路径只适⽤于⽆ 权图，或所有边的权值都相同的图</p> 
<p><img src="https://images2.imgbox.com/be/ae/GJf0yfe2_o.png" alt="image-20220715114825231"></p> 
<blockquote> 
 <p>Dijkstra算法求单源最短路径</p> 
</blockquote> 
<ol><li>初始化: 集合S为{0},dist[]为初始顶点0到各个顶点的距离,没有为无穷 path[]中初始顶点0为-1(一直不变),0到其他点有距离为0,没有为无穷</li><li>在dist[]中选剩下值最小的点j,若dist[j]+arcs[j] [k] &lt;dist[k],则更新dist[k] 在集合S中加入此点,若更新了dist[k],则令path[k]=j</li><li>再在集合S中剩下的点中重复操作,直到S包含所有点</li></ol> 
<p>单源时间复杂度为O(|V|²),所有结点对为O(|V|³)</p> 
<blockquote> 
 <p>Floyd算法法求各顶点间最短路径</p> 
</blockquote> 
<ol><li>递推产生一个n阶方阵序列,从A﹣¹开始到Aⁿ﹣¹</li><li>初始时: 若任意两个顶点存在边,权值作为最短路径,不存在为无穷</li><li>以后逐步在原路径中加入顶点k(k从0到n-1)作为中间顶点,若路径减少,则替换原路径</li><li>A(k)[i][j]: 从顶点i到顶点j,中间结点的序号不大于k的最短路径的长度</li></ol> 
<p><strong>特点：</strong></p> 
<ol><li>时间复杂度: O(|V|³)</li><li>允许带负权值的边,不允许包含负权值的边组成回路</li><li>适用于带权无向图,视为有往返二重边的有向图</li></ol> 
<p><img src="https://images2.imgbox.com/98/40/UJFESeZI_o.png" alt="image-20220715115538153"></p> 
<h5><a id="643_DAG_1419"></a>6.4.3 有向无环图DAG</h5> 
<p><mark>有向⽆环图</mark>：若⼀个有向图中<mark>不存在环</mark>，则称为有向⽆环图，简称DAG图</p> 
<p>结题步骤：</p> 
<p>Step 1：把各个操作数不重复地排成⼀排</p> 
<p>Step 2：标出各个运算符的⽣效顺序（先 后顺序有点出⼊⽆所谓）</p> 
<p>Step 3：按顺序加⼊运算符，注意“分层”</p> 
<p>Step 4：从底向上逐层检查同层的运算符 是否可以合体</p> 
<h5><a id="644__1433"></a>6.4.4 拓扑排序</h5> 
<p><mark>AOV⽹</mark>(Activity On Vertex NetWork，⽤顶点表示活动的⽹)： ⽤<mark>DAG图（有向⽆环图）表示⼀个⼯程</mark>。<mark>顶点表示活动</mark>，有向边表示活动Vi必须先于活动Vj进⾏</p> 
<p><mark>拓扑排序</mark>：在图论中，由⼀个有向⽆环图 的顶点组成的序列，当且仅当满⾜下列条 件时，称为该图的⼀个拓扑排序： ① <mark>每个顶点出现且只出现⼀次</mark>。 ② 若顶点A在序列中排在顶点B的前⾯，则 在图中不存在从顶点B到顶点A的路径。</p> 
<p>或定义为：拓扑排序是对有向⽆环图的顶 点的⼀种排序，它使得若存在⼀条从顶点A 到顶点B的路径，则在排序中顶点B出现在 顶点A的后⾯。<mark>每个AOV⽹都有⼀个或多个 拓扑排序序列</mark>。</p> 
<p><strong>拓扑排序的实现：</strong></p> 
<p>① 从AOV⽹中选择⼀个没有前驱==（⼊度为0）==的顶点并输出。</p> 
<p>② 从⽹中删除该顶点和所有以它为起点的有向边。</p> 
<p>③ 重复①和②直到当前的<mark>AOV⽹为空或当前⽹中不存在⽆前驱的顶点为⽌</mark>。</p> 
<p><img src="https://images2.imgbox.com/99/45/CRTAZ1CV_o.png" alt="image-20220715120559949"></p> 
<p>对⼀个AOV⽹，如果采⽤下列步骤进⾏排序，则称之为<mark>逆拓扑排序：</mark></p> 
<p>① 从AOV⽹中选择⼀个没有后继（<mark>出度为0</mark>）的顶点并输出。</p> 
<p>② 从⽹中<mark>删除该顶点和所有以它为终点的有向边</mark>。</p> 
<p>③ 重复①和②<mark>直到当前的AOV⽹为空</mark>。</p> 
<p><img src="https://images2.imgbox.com/97/d6/wa3JIlUR_o.png" alt="image-20220715120622281"></p> 
<p><img src="https://images2.imgbox.com/ec/8c/fBvjZpbi_o.png" alt="image-20220715120658198"></p> 
<h5><a id="645__1465"></a>6.4.5 关键路径</h5> 
<p><mark>AOE⽹ (Activity On Edge NetWork)</mark>：在带权有向图中，以<mark>顶点表示事件</mark>，以<mark>有向边表示活动</mark>，以<mark>边上的权值表示完成该活动的开销（如 完成活动所需的时间）</mark>，称之为⽤边表示活动的⽹络，简称AOE</p> 
<p>AOE⽹具有以下两个性质：</p> 
<p>① 只有在某顶点所代表的事件发⽣后，从该顶点出发的各有向边所代表的活动才能开始；</p> 
<p>② 只有在进⼊某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发⽣。 另外，有些活动是可以并⾏进⾏的</p> 
<p>在AOE⽹中<mark>仅有⼀个⼊度为0的顶点</mark>，称为开始顶点（源点），它表示整个⼯程的<mark>开始</mark>； 也<mark>仅有⼀个出度为0的顶点</mark>，称为结束顶点（汇点），它表示整个⼯程的<mark>结束</mark>。</p> 
<p>从源点到汇点的有向路径可能有多条，所有路径中，具有<mark>最⼤路径⻓度的路径</mark>称为 <mark>关键路径</mark>，⽽把关键路径上的活动称为<mark>关键活动</mark></p> 
<blockquote> 
 <p>求关键路径步骤</p> 
</blockquote> 
<p>① 求所有事件的最早发⽣时间 ve( ) --决定了所有从vk开始的活动能够开⼯的最早时间</p> 
<p>② 求所有事件的最迟发⽣时间 vl( ) --它是指在不推迟整个⼯程完成的前提下，该事件最迟必须发⽣的时间</p> 
<p>③ 求所有活动的最早发⽣时间 e( ) – 指该活动弧的起点所表⽰的事件的最早发⽣时间</p> 
<p>④ 求所有活动的最迟发⽣时间 l( ) --它是指该活动弧的终点所表示事件的最迟发⽣时间与该活动所需时间之差</p> 
<p>⑤ 求所有活动的时间余量 d( ) –<mark>时间余量d(i)=l(i)-e(i)</mark></p> 
<p>d(i)=0的活动就是关键活动, 由 关键活动可得关键路径</p> 
<ol><li> <p>求所有事件的最早发⽣时间 ve( )</p> <p>从源点开始往后加上权值,取不同路径的最大值</p> </li></ol> 
<p><img src="https://images2.imgbox.com/d1/49/P8XabtHq_o.png" alt="image-20220715121655450"></p> 
<ol start="2"><li> <p>求所有事件的最迟发⽣时间 vl( )</p> <p>Vl(汇点)=Ve(汇点),从汇点往前依次减去权值,取不同路径最小值</p> </li></ol> 
<p><img src="https://images2.imgbox.com/02/73/quyI0HTM_o.png" alt="image-20220715121744348"></p> 
<ol start="3"><li> <p>求所有活动的最早发⽣时间 e( )</p> <p>若边表⽰活动ai，则有e(i) = ve(k)</p> </li></ol> 
<p><img src="https://images2.imgbox.com/2f/38/GLsqtlim_o.png" alt="image-20220715121827467"></p> 
<ol start="4"><li> <p>求所有活动的最迟发⽣时间 l( )</p> <p>若边表⽰活动ai，则有l(i) = vl(j) - Weight(vk, vj)</p> </li></ol> 
<p>​ <img src="https://images2.imgbox.com/22/3f/6D7pQ3lD_o.png" alt="image-20220715121910681"></p> 
<ol start="5"><li> <p>求所有活动的时间余量 d( )</p> <p>d(i) = l(i) - e(i)</p> </li></ol> 
<p><img src="https://images2.imgbox.com/5e/57/8KF7B8bt_o.png" alt="image-20220715121931532"></p> 
<p>若关键活动耗时增加，则整个⼯程的⼯期将增⻓ 缩</p> 
<p>短关键活动的时间，可以缩短整个⼯程的⼯期</p> 
<p>当缩短到⼀定程度时，关键活动可能会变成⾮关键活动</p> 
<p><img src="https://images2.imgbox.com/08/d9/DiY7aN7c_o.png" alt="image-20220715122059352"></p> 
<p><img src="https://images2.imgbox.com/bb/7a/DKnTS0IS_o.png" alt="image-20220715122117914"></p> 
<h3><a id="__1539"></a>第七章 查找</h3> 
<h4><a id="71__1541"></a>7.1 查找的基本概念</h4> 
<p>查找 —— 在数据集合中寻找满⾜某种条件的数据元素的过程称为查找</p> 
<p>查找表（查找结构）—— ⽤于查找的数据集合称为查找表，它由同⼀类型的数据元素（或记录）组成</p> 
<p>关键字 —— 数据元素中<mark>唯⼀</mark>标识该元素的某个数据项的值，使⽤基于关键字的查找，查找结果应该是 唯⼀的</p> 
<blockquote> 
 <p>对查找表的常⻅操作</p> 
</blockquote> 
<p>①查找符合条件的数据元素 ②插⼊、删除某个数据元素</p> 
<p>只需进⾏操作① —— <mark>静态查找表</mark> 仅关注查找速度</p> 
<p>也要进⾏操作② —— <mark>动态查找表</mark> 除了查找速度，也要关注 插/删操作是否⽅便实现</p> 
<p>适合静态查找表: 顺序查找,折半查找,散列查找</p> 
<p>适合动态查找表: 二叉排序树,散列查找,二叉平衡树和B树都是二叉排序树的改进</p> 
<blockquote> 
 <p>查找算法的评价指标</p> 
</blockquote> 
<p>查找⻓度——在查找运算中，需要对⽐关键字的次数称为查找⻓度</p> 
<p><mark>平均查找⻓度（ASL</mark>, Average Search Length）—— 所有查找过程中进⾏关键字的⽐较次数的平均值</p> 
<p><img src="https://images2.imgbox.com/eb/9c/4WL7l2Tv_o.png" alt="image-20220715151829992"></p> 
<h4><a id="72__1569"></a>7.2 顺序查找和折半查找</h4> 
<h5><a id="721__1571"></a>7.2.1 顺序查找</h5> 
<p>顺序查找，⼜叫“线性查找”，通常⽤于线性表</p> 
<p>ASL成功=(n+1)/2 ASL失败=n+1</p> 
<p><img src="https://images2.imgbox.com/48/a3/qqEiDn7C_o.png" alt="image-20220715152155300"></p> 
<p><img src="https://images2.imgbox.com/68/43/vFOY5vZ9_o.png" alt="image-20220715152851249"></p> 
<h5><a id="722__1581"></a>7.2.2 折半查找（二分查找）</h5> 
<p>折半查找，⼜称“⼆分查找”，仅适⽤于<mark>有序的顺序表</mark>。</p> 
<p><img src="https://images2.imgbox.com/e3/37/NvUGvNaS_o.png" alt="image-20220715153335311"></p> 
<blockquote> 
 <p>折半查找判定树的构造</p> 
</blockquote> 
<p>如果当前low和high之间有<mark>奇数个</mark>元素，则 mid 分隔后，<mark>左右两部分元素个数相等</mark></p> 
<p>如果当前low和high之间有<mark>偶数个</mark>元素，则 mid 分隔后，<mark>左半部分⽐右半部分少⼀个元素</mark></p> 
<p>折半查找的判定树中，若 mid = ⌊(low + high)/2]，则对于任何⼀个结点，必有： <mark>右⼦树结点数-左⼦树结点数=0或1</mark></p> 
<p><mark>折半查找的判定树⼀定是平衡⼆叉树</mark></p> 
<p>折半查找的判定树中，只有最下⾯⼀层是不满的 因此，元素个数为n时树⾼h = ⌈log2(n + 1)⌉</p> 
<p>折半查找的时间复杂度 = O(log2n)</p> 
<p><img src="https://images2.imgbox.com/dc/c2/KxDypz3b_o.png" alt="image-20220715153840003"></p> 
<h5><a id="723__1603"></a>7.2.3 分块查找</h5> 
<p>分块查找，⼜称索引顺序查找，算法过程如下： ①在索引表中确定待查记录所属的分块（可顺序、可折半） ②在块内顺序查找</p> 
<p><strong>特点</strong>：块内⽆序、块间有序</p> 
<p><strong>算法思想：</strong></p> 
<ol><li>分为若干子块,块内可以无序,块之间有序</li><li>第一块中最大关键字&lt;第二块中所有记录,以此类推</li><li>建立一个索引表,含有各块最大关键字和各块第一个元素的地址,按关键字有序排列</li></ol> 
<p>若索引表中不包含⽬标关键字，则折半查找索引表最终停在 low&gt;high，要在low所指分块中查找</p> 
<p>low超出索引表范 围，查找失败</p> 
<p>设索引查找和块内查找的平均查找⻓度分别为LI、LS，则分块查找的<mark>平均查找⻓度为 ASL=LI + LS</mark></p> 
<p><img src="https://images2.imgbox.com/63/1c/rn1S4A1a_o.png" alt="image-20220715162002709"></p> 
<h4><a id="73__1623"></a>7.3 树型查找</h4> 
<h5><a id="731_BST_1625"></a>7.3.1 二叉排序树BST</h5> 
<p>二叉排序树，又称二叉查找树（BST，Binary Search Tree）</p> 
<p>二叉排序树可用于元 素的有序组织、搜索</p> 
<p>具有如下性质：左子树上所有结点的关键字均小于根结点的关键字； 右子树上所有结点的关键字均大于根结点的关键字。 左子树和右子树又各是一棵二叉排序树。</p> 
<p><mark>左子树结点值 &lt; 根结点值 &lt; 右子树结点值</mark></p> 
<p><mark>进行中序遍历，可以得到一个递增的有序序列</mark></p> 
<p><img src="https://images2.imgbox.com/42/67/TG6ST6Zs_o.png" alt="image-20220715163258828"></p> 
<p><img src="https://images2.imgbox.com/61/64/YRQ6MhHo_o.png" alt="image-20220715163219519"></p> 
<p><img src="https://images2.imgbox.com/72/04/uVNTJNs4_o.png" alt="image-20220715163240244"></p> 
<p><strong>二叉排序树的删除</strong>：① 若被删除结点z是<mark>叶结点</mark>，则<mark>直接删除</mark>，不会破坏二叉排序树的性质。</p> 
<p>② 若结点z<mark>只有一棵左子树或右子树</mark>，则让<mark>z的子树成为z父结点</mark>的子树，替代z的位置</p> 
<p>③ 若结点<mark>z有左、右两棵子树</mark>，则<mark>令z的直接后继（或直接前驱）替代z</mark>，然后从二叉排序树中删去这 个直接后继（或直接前驱），这样就转换成了第一或第二种情况</p> 
<p><strong>查找效率分析：</strong></p> 
<ol><li>平均查找长度ASL=(每层个数*对应层数)/总个数</li><li>最坏情况: 类似有序单链表O(n)</li><li>最好情况: 平衡二叉树O(㏒₂n)</li><li>查找过程: 与二分查找类似,但二分查找的判定树唯一</li></ol> 
<p><img src="https://images2.imgbox.com/8c/4c/jDsGkpCp_o.png" alt="image-20220715163555212"></p> 
<h5><a id="732_AVL_1658"></a>7.3.2 平衡二叉树AVL</h5> 
<p>平衡二叉树（Balanced Binary Tree），简称<mark>平衡树（AVL树</mark>）——树上任一<mark>结点的左子树和右子树的 高度之差不超过1</mark></p> 
<p><mark>结点的平衡因子</mark>=左子树高-右子树高</p> 
<p>平衡二叉树的插入：从插入点往回 找到第一个不 平衡结点，调 整以该结点为 根的子树，每次调整的对象都是==“最小不平衡子树”==</p> 
<p><img src="https://images2.imgbox.com/c4/e8/7FB4oIRS_o.png" alt="image-20220715164001193"></p> 
<ol><li> <p><mark>LL平衡旋转（右单旋转）</mark>。由于在结点A的左孩子（L）的左子树（L）上插入了新结点，A的平衡因子 由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。将A的<mark>左孩子B向右上旋转</mark>代替A成 为根结点，<mark>将A结点向右下旋转</mark>成为B的右子树的根结点，而B的原右子树则作为A结点的左子树</p> <p><img src="https://images2.imgbox.com/8e/9b/OYQWNSAs_o.png" alt="image-20220715164203534"></p> </li><li> <p><mark>RR平衡旋转（左单旋转）</mark>。由于在结点A的右孩子（R）的右子树（R）上插入了新结点，A的平衡因 子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。将A的<mark>右孩子B向左上旋转</mark>代替 A成为根结点，将<mark>A结点向左下旋转</mark>成为B的左子树的根结点，而B的原左子树则作为A结点的右子树</p> <p><img src="https://images2.imgbox.com/fd/cb/BhrKxsFa_o.png" alt="image-20220715164216718"></p> </li><li> <p><mark>LR平衡旋转（先左后右双旋转）</mark>。由于在A的左孩子（L）的右子树（R）上插入新结点，A的平衡因 子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将A结点 的左孩子B的右子树的根结点<mark>C向左上旋转提升到B结点的位置</mark>，然后再把该<mark>C结点向右上旋转提升到A结 点的位置</mark></p> <p><img src="https://images2.imgbox.com/75/b2/lsOSsjc7_o.png" alt="image-20220715164318165"></p> </li><li> <p><mark>RL平衡旋转（先右后左双旋转）</mark>。由于在A的右孩子（R）的左子树（L）上插入新结点，A的平衡 因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将A 结点的右孩子B的左子树的根结点<mark>C向右上旋转提升到B结点的位置</mark>，然后再把该<mark>C结点向左上旋转提升 到A结点的位置</mark></p> <p><img src="https://images2.imgbox.com/4c/bb/vASn31Qu_o.png" alt="image-20220715164409219"></p> </li></ol> 
<p><img src="https://images2.imgbox.com/f1/31/TyZ6xODD_o.png" alt="image-20220715164438896"></p> 
<p>含有n个结点的平衡二叉树的最大深度为O(log2n) ，<mark>平衡二叉树的平均查找长度为O(log2n)</mark></p> 
<p><img src="https://images2.imgbox.com/04/e7/oBvAj7ly_o.png" alt="image-20220715164605522"></p> 
<h5><a id="733__1690"></a>7.3.3 红黑树</h5> 
<p><mark>平衡二叉树 AVL</mark>：插入/删除 很容易破坏“平衡”特性，需要频繁调整树的形态。如：插入操作导致不 平衡，则需要先计算平衡因子，找到最小不平衡子树（时间开销大），再进行 LL/RR/LR/RL 调整</p> 
<p><mark>红黑树 RBT</mark>：插入/删除 很多时候不会破坏“红黑”特性，无需频繁调整树的形态。即便需要调整，一 般都可以<mark>在常数级时间内完成</mark></p> 
<p>平衡二叉树：适用于以查为主、很少插入/删除的场景</p> 
<p>红黑树：适用于频繁插入、删除的场景，实用性更强</p> 
<p><mark>红黑树是二叉排序树</mark> 左子树结点值 ≤ 根结点值 ≤ 右子树结点值</p> 
<blockquote> 
 <p>定义</p> 
</blockquote> 
<p>①每个结点或是红色，或是黑色的</p> 
<p>②<mark>根节点是黑色的</mark></p> 
<p>③<mark>叶结点</mark>（外部结点、NULL结点、失败结点）均是<mark>黑色的</mark></p> 
<p>④<mark>不存在两个相邻的红结点</mark>（即红结点的父节点和孩子结点均是黑色）</p> 
<p>⑤对每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数 目相同(每个结点的左右子树中黑结点的层数是相等)</p> 
<p><img src="https://images2.imgbox.com/12/bd/TilwLTTD_o.png" alt="image-20220715165327067"></p> 
<p><mark>结点的黑高 bh</mark> —— 从某结点出发（不含该结点）到达任一空叶结点的路径上<mark>黑结点总数</mark></p> 
<p><strong>性质：</strong> 从根节点到叶结点的最长路径不大于最短路径的2倍，有n个内部节点的红黑树高度 h ≤ 2log2(n+1)</p> 
<p>红黑树查找操作<mark>时间复杂度 = O(log2n)</mark></p> 
<blockquote> 
 <p>红黑树的插入</p> 
</blockquote> 
<p><strong>插入过程</strong></p> 
<p><img src="https://images2.imgbox.com/b0/44/oFYtLeKj_o.png" alt="image-20220715170131484"></p> 
<p><img src="https://images2.imgbox.com/15/e0/yLVkH9rl_o.png" alt="image-20220715170321909"></p> 
<p><img src="https://images2.imgbox.com/64/7f/b9djvTIj_o.png" alt="image-20220715170341102"></p> 
<h4><a id="74_BB_1732"></a>7.4 B树和B+树</h4> 
<h5><a id="741_B_1734"></a>7.4.1 B树</h5> 
<p><mark>B树，<mark>⼜称</mark>多路平衡查找树</mark>，B树中所有结点的孩⼦个数的最⼤值称为B树的阶，通常⽤m表示。⼀棵<mark>m阶B树</mark> 或为空树，或为满⾜如下特性的m叉树：</p> 
<p>1）树中每个结点⾄多有m棵⼦树，即<mark>⾄多含有m-1个关键字</mark>。</p> 
<p>2）若根结点不是终端结点，则<mark>⾄少有两棵⼦树</mark>。</p> 
<p>3）除根结点外的所有⾮<mark>叶结点⾄少有m/2 棵⼦树，即⾄少含有 m/2-1个关键字。</mark></p> 
<p>4）所有的叶结点都出现在同⼀层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失 败结点，实际上这些结点不存在，指向这些结点的指针为空）</p> 
<p><img src="https://images2.imgbox.com/6a/a2/CwD0CO8d_o.png" alt="image-20220715170810390"></p> 
<p>5）所有非叶结点结构：关键字递增排列，左子树所有数&lt;对应关键字,右子树所有数&gt;对应关键字</p> 
<p><strong>m阶B树的核⼼特性：</strong></p> 
<p>1） 根节点的⼦树数∈[2, m]，关键字数∈[1, m-1]。 其他结点的⼦树数∈[ , m]；关键字数∈[ -1, m-1]</p> 
<p>2）对任⼀结点，其<mark>所有⼦树⾼度都相同</mark></p> 
<p>3）关键字的值：⼦树0&lt;关键字1&lt;⼦树1&lt;关键字2&lt;⼦树2&lt;…. (类⽐⼆叉查找树 <mark>左&lt;中&lt;右)</mark></p> 
<p><strong>B树的高度</strong> 算B树的⾼度不包括叶⼦结点（失败结点）</p> 
<p><img src="https://images2.imgbox.com/c7/9f/O7M70d8l_o.png" alt="image-20220715171307335"></p> 
<blockquote> 
 <p>B树的插入</p> 
</blockquote> 
<ol><li> <p>一定插入在最低层的某个非叶结点内</p> </li><li> <p>在插⼊key后，若导致原结点关键字数超过上限，则从中间位置（ m/2）<mark>将其中的关键字分为两部分</mark>，<mark>左部分包 含的关键字放在原结点中</mark>，<mark>右部分包含的关键字放到新结点</mark>中，中间位置（ m/2）的结点<mark>插⼊原结点的⽗结点</mark></p> </li><li> <p>若此时导致其<mark>⽗结点的关键字个数也超过了上限</mark>，则<mark>继续</mark>进⾏这种<mark>分裂</mark>操作，直⾄这个过程传到根结点为⽌，进 ⽽导致B树⾼度增1</p> <p><img src="https://images2.imgbox.com/f1/0e/LMoB51U7_o.png" alt="image-20220715173102829"></p> </li></ol> 
<blockquote> 
 <p>B树的删除</p> 
</blockquote> 
<p><mark>结点关键字个数 ⌈m/2⌉ − 1 ≤n≤m-1</mark></p> 
<ol><li> <p>若被删除关键字在<mark>终端节点</mark>，则<mark>直接删除</mark>该关键字（要注意节点关键字个数是否低于下限 ⌈m/2⌉ − 1）</p> </li><li> <p>若被删除关键字在<mark>⾮终端节点</mark>，则⽤<mark>直接前驱或直接后继</mark>来替代被删除的关键字</p> <p>直接前驱：当前关键字左侧指针所指⼦树中“<mark>最右下</mark>”的元素</p> <p>直接后继：当前关键字右侧指针所指⼦树中“<mark>最左下</mark>”的元素</p> </li><li> <p><mark>兄弟够借</mark>。若被删除关键字所在结点删除前的关键字个数低于下限，且与此结点右（或左）兄弟结 点的关键字个数还很宽裕，则需要调整该结点、右（或左）兄弟结点及其双亲结点（<mark>⽗⼦换位法</mark></p> <p><mark>父子换位法:</mark> 兄弟结点中的一个关键字进入父结点,父结点中的一个关键字进入被删结点,然后删 除关键字</p> <p>本质：要永远<mark>保证 ⼦树0&lt;关键字1&lt;⼦树1&lt;关键字2&lt;⼦树2</mark></p> </li><li> <p><mark>兄弟不够借</mark>。若被删除关键字所在结点删除前的关键字个数低于下限，且此时与该结点相邻的左、右兄弟结 点的关键字个数均=⌈m/2⌉ − 1，则将关键字删除后<mark>与左（或右）兄弟结点及双亲结点中的关键字进⾏合并</mark></p> <p>在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少⾄0（根结点关键 字个数为1时，有2棵⼦树），则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点，且关 键字个数减少到 ，则⼜要与它⾃⼰的兄弟结点进⾏调整或合并操作，并重复上述步骤，直⾄符合B 树的要求为⽌</p> </li></ol> 
<p><img src="https://images2.imgbox.com/91/0d/WSiCJIO9_o.png" alt="image-20220715173639719"></p> 
<h5><a id="742_B_1798"></a>7.4.2 B+树</h5> 
<blockquote> 
 <p>⼀棵m阶的B+树需满⾜下列条件：</p> 
</blockquote> 
<p>1）每个分⽀结点<mark>最多有m棵⼦树</mark>（孩⼦结点）。</p> 
<p>2）⾮叶根结点⾄少有两棵⼦树，其他每个分⽀结点⾄少有 棵⼦树。</p> 
<p>3）结点的<mark>⼦树个数与关键字个数相等</mark>。(与B树的最大区别)</p> 
<p>4）所有<mark>叶结点包含全部关键字</mark>及指向相应记录的指针，叶结点中将关键字按⼤⼩顺序排列，并且相邻叶结点<mark>按⼤⼩顺序相互链接起来</mark>。</p> 
<p>5）所有<mark>分⽀结点</mark>中仅包含它的各个⼦结点中<mark>关键字的最⼤值</mark>及指向其⼦结点的指针。</p> 
<p><strong>B+树的查找</strong>：从最小关键字<strong>顺序查找</strong>/从根结点<strong>多路查找</strong></p> 
<p>B+树中，⽆论查找成功与否，最终⼀定都要⾛到最下⾯⼀层结点</p> 
<p><img src="https://images2.imgbox.com/d1/1b/VJkOcFaC_o.png" alt="image-20220715174148075"></p> 
<h4><a id="75__1818"></a>7.5 散列表</h4> 
<h5><a id="751__1820"></a>7.5.1 散列表的基本概念</h5> 
<p>散列表（Hash Table），⼜称哈希表。是⼀种数据结构，</p> 
<p><strong>特点：</strong><mark>数据元素的关键字与其 存储地址直接相关</mark></p> 
<p>若不同的关键字通过散列函数映射到同⼀个值，则称它们为“<mark>同义词</mark>”</p> 
<p>通过散列函数确定的位置已经存放了其他元素，则称这种情况为“<mark>冲突</mark>”</p> 
<p>处理冲突的⽅法——<mark>拉链法</mark>（⼜称链接法、链地址法）：把所有“同义词”存储在⼀个链表中</p> 
<h5><a id="752__1834"></a>7.5.2 散列函数的构造方法</h5> 
<ol><li> <p><strong>除留余数法</strong> —— H(key) = key % p</p> <p>P的选取: 不大于m(散列表长)但最接近或等于m的质数</p> </li><li> <p><strong>直接定址法</strong> —— H(key) = key 或 H(key) = a*key + b</p> <p>其中，a和b是常数。这种⽅法计算最简单，且不会产⽣冲突。它适合<mark>关键字的分布基本连续</mark>的情 况，若关键字分布不连续，空位较多，则会造成存储空间的浪费</p> </li><li> <p><strong>数字分析法</strong> —— 选取数码分布较为均匀的若⼲位作为散列地址</p> <p>设关键字是r进制数（如⼗进制数），⽽<mark>r个数码在各位上出现的频率不⼀定相同，可能在某些位 上分布均匀⼀些</mark>，每种数码出现的机会均等；⽽在某些位上分布不均匀，只有某⼏种数码经常出 现，此时可选取数码分布较为均匀的若⼲位作为散列地址。这种⽅法适合于已知的关键字集合， 若更换了关键字，则需要重新构造新的散列函数</p> </li><li> <p><strong>平⽅取中法</strong>——取关键字的平⽅值的中间⼏位作为散列地址</p> <p>具体取多少位要视实际情况⽽定。这种⽅法<mark>得到的散列地址与关键字的每位都有关系</mark>，因此使得 <mark>散列地址分布⽐较均匀</mark>，适⽤于关键字的每位取值都不够均匀或均⼩于散列地址所需的位数</p> </li><li> <p><strong>折叠法</strong>——关键字分割成位数相同的几部分,取叠加和作为散列地</p> <p>适用于位数很多且每位上数字分布大致均匀</p> </li></ol> 
<h5><a id="753__1856"></a>7.5.3 处理冲突的方法</h5> 
<ol><li> <p>⽤<mark>拉链法</mark>（⼜称链接法、链地址法）处理“冲突”：<mark>把所有“同义词”存储在⼀个链表中</mark></p> </li><li> <p><mark>开放定址法</mark>，是指可存放新表项的<mark>空闲地址既向它的同义词表项开放，⼜向它的⾮同义词表项开 放</mark>。</p> <p>其数学递推公式为：<mark>Hi = (H(key) + di) % m</mark></p> <p>i = 0, 1, 2,…, k（k≤m - 1），m表示散列表表⻓；di为增量序列；i 可理解为“第i次发⽣冲突“</p> <p>①<mark>线性探测法</mark>—— di = 0, 1, 2, 3, …, m-1；即发⽣冲突时，每次往后探测相邻的下⼀个单元是否为空</p> <p>线性探测法很容易造成同义词、<mark>⾮同义词的“聚集（堆积）</mark>”现象，严重影响查找效率</p> <p>产⽣原因——冲突后再探测⼀定是放在某个连续的位置</p> <p>②<mark>平⽅探测法</mark>。当di = 02, 12, -12, 22, -22, …, k2, -k2时，称为平⽅探测法，⼜称⼆次探测法其中k≤m/2</p> <p>优点: 可以避免出现堆积问题，缺点: 只能探测一半单元</p> <p>③<mark>伪随机序列法</mark>。di 是⼀个伪随机序列，如 di= 0, 5, 24, 11, …</p> <p><img src="https://images2.imgbox.com/ce/ea/qI1WMscJ_o.png" alt="image-20220715180400737"></p> </li></ol> 
<p><strong>注意：</strong></p> 
<ol><li>不能随便物理删除已有元素,会截断其他相同散列地址元素的查找地址</li><li>可做删除标记,逻辑删除</li><li>副作用: 多次删除后,表面上散列表很满,其实还有很多位置未用,需定期维护</li></ol> 
<p><img src="https://images2.imgbox.com/27/df/NNrQ1nF4_o.png" alt="image-20220715180424065"></p> 
<h5><a id="754__1888"></a>7.5.4 散列查找及性能分析</h5> 
<p><strong>查找效率：</strong></p> 
<ol><li>取决于: 散列函数,处理冲突的方法,装填因子</li><li>装填因子(α): 定义一个表的装满程度 α=表中记录数n/散列表长度m</li><li>平均查找长度依赖于α,不直接依赖于n或m</li></ol> 
<p><strong>易错点：</strong></p> 
<ol><li>K个同义词采用线性探测填入散列表,需要探测K(K+1)/2次</li><li>冲突产生的概率与装填因子的大小成正比 越满越容易冲突</li><li>不能用随机数函数构造散列函数,无法进行正常的查找</li></ol> 
<p><strong>注意点:</strong></p> 
<ol><li>ASL成功 查找次数=冲突次数+1</li><li>根据散列函数确定一共需要的查找的位置,对每个位置查找直到为空时结束,不为空时用相应的冲突 处理方法再进行查找,为空时也需要比较一次</li></ol> 
<h3><a id="__1907"></a>第八章 排序</h3> 
<h4><a id="81__1909"></a>8.1 排序的基本概念</h4> 
<p><strong>排序（Sort）</strong>，就是重新排列表中的元素，使表中的元素满⾜按关键字有序的过程。</p> 
<p><strong>算法的稳定性</strong>。若待排序表中有两个元素Ri和Rj，其对应的关键字相同即keyi = keyj，且在排序 前Ri在Rj的前⾯，若使⽤某⼀排序算法排序后，Ri仍然在Rj的前⾯，则称这个排序算法是稳定 的，否则称排序算法是不稳定的。</p> 
<p><img src="https://images2.imgbox.com/52/a5/uGt3vRGx_o.png" alt="image-20220715183636933"></p> 
<h4><a id="82__1919"></a>8.2 插入排序</h4> 
<h5><a id="821__1921"></a>8.2.1 直接插入排序</h5> 
<p>算法思想：每次将⼀个待排序的记录按其关键字⼤⼩插⼊到前⾯已排好序的⼦序列中， 直到全部记录插⼊完成</p> 
<p><img src="https://images2.imgbox.com/30/09/FCUvY16c_o.png" alt="image-20220715184038315"></p> 
<p><img src="https://images2.imgbox.com/a2/be/edJqcv9A_o.png" alt="image-20220715184052624"></p> 
<p>空间复杂度：O(1)</p> 
<p>最好时间复杂度—— O(n)</p> 
<p>最坏时间复杂度——O(n2)</p> 
<p><mark>平均时间复杂度：O(n2)</mark></p> 
<h5><a id="822__1937"></a>8.2.2 折半插入排序</h5> 
<p>先⽤折半查找找到应该插⼊的位置，再移动元素</p> 
<p><img src="https://images2.imgbox.com/b6/07/w8WW5hgQ_o.png" alt="image-20220715184531264"></p> 
<p>当 low&gt;high 时折半查找停⽌，应将 [low, i-1] 内的元素全部右移，并将 A[0] 复制到 low 所指位置</p> 
<p>当 A[mid]==A[0] 时，为了保证算法的“稳定性”，应继续在 mid 所指位置右边寻找插⼊位置</p> 
<p><img src="https://images2.imgbox.com/a4/05/ucK0Y9qT_o.png" alt="image-20220715184716210"></p> 
<p>仅减少了比较元素的次数,移动的次数并未改变</p> 
<p><img src="https://images2.imgbox.com/d9/b7/iRfGCyHg_o.png" alt="image-20220715184758654"></p> 
<h5><a id="823__1953"></a>8.2.3 希尔排序</h5> 
<p>**希尔排序：**先将待排序表分割成若⼲形如 L[i, i + d, i + 2d,…, i + kd] 的“特殊”⼦表，对各个⼦表 分别进⾏直接插⼊排序。<mark>缩⼩增量d</mark>，重复上述过程，<mark>直到d=1为⽌</mark>。</p> 
<p><img src="https://images2.imgbox.com/2c/34/svVZaweW_o.png" alt="image-20220715185957592"></p> 
<p>空间复杂度：O(1)</p> 
<p>时间复杂度：和增量序列 d1, d2, d3… 的选择有关，⽬前⽆法⽤数学⼿段证明确切的时间复杂度</p> 
<p>稳定性：不稳定</p> 
<p>适⽤性：仅适⽤于顺序表，不适⽤于链表</p> 
<p><img src="https://images2.imgbox.com/3f/9d/N0CvStdQ_o.png" alt="image-20220715190306672"></p> 
<h4><a id="83__1969"></a>8.3 交换排序</h4> 
<h5><a id="831__1971"></a>8.3.1 冒泡排序</h5> 
<p>**冒泡排序：**从后往前（或从前往后）两两⽐较相邻元素的值，若为逆序（即A[i-1]&gt;A[i]），则交换它们，直到序 列⽐较完。</p> 
<p><strong>实现步骤：</strong></p> 
<ol><li>从最后一个元素开始,两两相邻进行比较,若为逆序,则交换它们</li><li>一趟冒泡,结果将最小的元素交换到第一个位置</li><li>下一趟冒泡,前一趟确定的最小元素不再参与,待排序列减少一个元素</li><li>每趟冒泡的结果是序列中最小元素放到最终位置,最多n-1此完成</li></ol> 
<p><img src="https://images2.imgbox.com/c8/b2/lug1cfDX_o.png" alt="image-20220715190628100"></p> 
<p><img src="https://images2.imgbox.com/ec/72/C1LQA6M3_o.png" alt="image-20220715190646459"></p> 
<p><img src="https://images2.imgbox.com/85/0f/4rusbHRR_o.png" alt="image-20220715190810014"></p> 
<h5><a id="832__1988"></a>8.3.2 快速排序</h5> 
<p>更⼩的元素都交换到左边 更⼤的元素都交换到右边</p> 
<p><strong>实现步骤：</strong></p> 
<ol><li>每次取当前表中第一个元素作为基准pivot(枢轴值)对表进行划分</li><li><mark>i指向第一个元素(基准),j指向最后一个元素</mark></li><li>先从j开始,从后往前找到<mark>第一个</mark>比基准小的元素,j指向此元素位置,用此元素替换掉i所指元素</li><li>再从i开始,从前往后找到<mark>第一个</mark>比基准大的元素,i指向此元素位置,用此元素替换掉j所指元素</li><li>再次从j开始,循环往复,直到i与j接触停止,将基准值放到接触位置,将序列划分为两块,前面小于基准值,后面大于基准值</li><li>分别取两个子序列的第一个元素作为基准值,重复操作</li></ol> 
<p><img src="https://images2.imgbox.com/c5/2a/ohcPIzGl_o.png" alt="image-20220715191155128"></p> 
<p><img src="https://images2.imgbox.com/42/7c/6QUmxZrf_o.png" alt="image-20220715191526060"></p> 
<p><mark>时间复杂度=O(n*递归层数)</mark></p> 
<p>​ 最好时间复杂度=O(nlog2n)</p> 
<p>​ 最坏时间复杂度=O(n2)</p> 
<p><mark>空间复杂度=O(递归层数)</mark></p> 
<p>​ 最好空间复杂度=O(log2n)</p> 
<p>​ 最坏空间复杂度=O(n)</p> 
<p>快速排序是所有内部排序算法中 平均性能最优的排序算法</p> 
<p>稳定性：<mark>不稳定</mark></p> 
<p><img src="https://images2.imgbox.com/80/3a/nhvlMpF7_o.png" alt="image-20220715191742835"></p> 
<h4><a id="84__2023"></a>8.4 选择排序</h4> 
<h5><a id="841__2025"></a>8.4.1 简单选择排序</h5> 
<p><strong>选择排序</strong>：每⼀趟在待排序元素中选取关键字最⼩（或最⼤）的元素加⼊有序⼦序列</p> 
<p><strong>简单选择排序：</strong> 每⼀趟在待排序元素中选取关键字最⼩的元素加⼊有序⼦序列</p> 
<p><img src="https://images2.imgbox.com/63/cf/bBNIiz2B_o.png" alt="image-20220715192006119"></p> 
<p><strong>空间复杂度</strong>：O(1)</p> 
<p><strong>时间复杂度</strong>=O(n2)</p> 
<p><strong>稳定性</strong>：不稳定</p> 
<p><strong>适⽤性</strong>：既可以⽤于顺序表，也可⽤于链表</p> 
<p><img src="https://images2.imgbox.com/5d/9e/AQgE3psd_o.png" alt="image-20220715192116271"></p> 
<h5><a id="842__2043"></a>8.4.2 堆排序</h5> 
<p>若n个关键字序列L[1…n] 满⾜下⾯某⼀条性质，则称为<mark>堆（Heap）</mark>：</p> 
<p>① 若满⾜：L(i)≥L(2i)且L(i)≥L(2i+1) （1 ≤ i ≤n/2）—— ⼤根堆（⼤顶堆）</p> 
<p>② 若满⾜：L(i)≤L(2i)且L(i)≤L(2i+1) （1 ≤ i ≤n/2）—— ⼩根堆（⼩顶堆）</p> 
<p><img src="https://images2.imgbox.com/fc/08/L4yoP9kq_o.png" alt="image-20220715192224603"></p> 
<p><img src="https://images2.imgbox.com/4e/14/Uqz2kS21_o.png" alt="image-20220715192421696"></p> 
<p><img src="https://images2.imgbox.com/d3/1c/g01anUJo_o.png" alt="image-20220715192434969"></p> 
<p><mark>堆排序</mark>：每⼀趟<mark>将堆顶元素加⼊有序⼦序列</mark> （与待排序序列中的最后⼀个元素交换）并<mark>将待排序元素序列再次调整为⼤根堆</mark> （⼩元素不断“下坠”）</p> 
<p><img src="https://images2.imgbox.com/3e/da/Rx9gKZ6q_o.png" alt="image-20220715192704393"></p> 
<p><mark>堆排序的时间复杂度 = O(n) + O(nlog2n) = O(nlog2n)</mark></p> 
<p><mark>堆排序的空间复杂度 = O(1)</mark></p> 
<p><strong>稳定性：</strong> 不稳定</p> 
<p><img src="https://images2.imgbox.com/56/6f/lGkRlHg0_o.png" alt="image-20220715192916757"></p> 
<h5><a id="843__2069"></a>8.4.3 堆的插入和删除</h5> 
<p><img src="https://images2.imgbox.com/22/d0/X1Jgicrg_o.png" alt="image-20220715193225585"></p> 
<p><img src="https://images2.imgbox.com/92/11/AbvKnYgT_o.png" alt="image-20220715193207604"></p> 
<p><img src="https://images2.imgbox.com/42/3d/42q0o0zW_o.png" alt="image-20220715193040522"></p> 
<h4><a id="85__2077"></a>8.5 归并排序和基数排序</h4> 
<h5><a id="851__2079"></a>8.5.1 归并排序</h5> 
<p><strong>归并</strong>：把两个或多个已经有序的序列合并成⼀个</p> 
<p><img src="https://images2.imgbox.com/96/7c/G9xLS4zo_o.png" alt="image-20220715193505832"></p> 
<p><img src="https://images2.imgbox.com/be/3d/bWqudtMK_o.png" alt="image-20220715193522946"></p> 
<p><img src="https://images2.imgbox.com/91/15/sJgeaUu1_o.png" alt="image-20220715193721243"></p> 
<p><img src="https://images2.imgbox.com/2d/fd/hcXszeT3_o.png" alt="image-20220715193751084"></p> 
<p><img src="https://images2.imgbox.com/30/c3/pcput55j_o.png" alt="image-20220715193803211"></p> 
<h5><a id="852__2093"></a>8.5.2 基数排序</h5> 
<p><img src="https://images2.imgbox.com/87/f3/HQEJYeUt_o.png" alt="image-20220715193939706"></p> 
<p><img src="https://images2.imgbox.com/33/7e/AK8IGdAJ_o.png" alt="image-20220715194029594"></p> 
<p><mark>空间复杂度 = O®</mark></p> 
<p><mark>时间复杂度=O(d(n+r)）</mark></p> 
<p><strong>稳定性：稳定</strong></p> 
<p><strong>基数排序擅⻓解决的问题：</strong></p> 
<p>①数据元素的关键字可以⽅便地拆分为 d 组，且 d 较⼩</p> 
<p>②每组关键字的取值范围不⼤，即 r 较⼩</p> 
<p>③数据元素个数 n 较⼤</p> 
<p><img src="https://images2.imgbox.com/16/2d/24jHTEH0_o.png" alt="image-20220715194208466"></p> 
<h4><a id="86__2115"></a>8.6 内部排序算法比较与应用</h4> 
<p><img src="https://images2.imgbox.com/5e/5e/hOldAfKh_o.png" alt="image-20220715194729455"></p> 
<h4><a id="87__2119"></a>8.7 外部排序</h4> 
<h5><a id="871__2121"></a>8.7.1 外部排序的基本概念</h5> 
<p><strong>外部排序</strong>：数据元素太多，⽆法⼀次全部读⼊内存进⾏排序</p> 
<p>**“归并排序”**要求各个⼦序列有序，每次读⼊ 两个块的内容，进⾏内部排序后写回磁盘</p> 
<p>外部排序时间开销=读写外存的时间+内部排序所需时间+内部归并所需时间</p> 
<p><img src="https://images2.imgbox.com/7e/4b/yz6om4fK_o.png" alt="image-20220715195547381"></p> 
<p><img src="https://images2.imgbox.com/e8/02/0Aac3uTq_o.png" alt="image-20220715195627034"></p> 
<p><img src="https://images2.imgbox.com/ff/de/iglL0LS3_o.png" alt="image-20220715195648475"></p> 
<h5><a id="872__2137"></a>8.7.2 败者树</h5> 
<p><strong><mark>k路平衡归并</mark></strong>：①最多只能有k个段归并为⼀个； ②每⼀趟归并中，若有 m 个归并段参与归并，则经过这⼀趟处理得到⌈m/k⌉个新的归并段</p> 
<p><mark>败者树</mark>——可视为⼀棵<mark>完全⼆叉树</mark>（多 了⼀个头头）。k个叶结点分别是当前 参加⽐较的元素，⾮叶⼦结点⽤来记忆 左右⼦树中的“失败者”，⽽让胜者往上 继续进⾏⽐较，⼀直到根结点</p> 
<ol><li><strong>叶结点</strong> 当前参加比较的记录</li><li><strong>内部结点</strong> 记忆左右子树中失败者的序号,让胜者继续向上比较,直到根结点</li><li><strong>根结点</strong> 当前的最小数/最大数的序号,不是数值本身(胜者)</li></ol> 
<p><img src="https://images2.imgbox.com/14/3c/nLJonN29_o.png" alt="image-20220715200030501"></p> 
<p>利用败者树得到最小值序号后,取出最小值数,在其位置加入下一个关键字,继续比较,构造败者树</p> 
<p>使用败者树后,比较次数与m无关,可以增大m来减少归并树的高度</p> 
<p>m并不是越大越好 m增大,输入缓冲区增加,其容量减少,内外存交换数据的次数增大</p> 
<h5><a id="873__2155"></a>8.7.3 置换选择排序</h5> 
<p>设初始待排⽂件为FI，初始归并段输出⽂件为FO，内存⼯作区为WA，FO和WA的初始状态为 空，WA可容纳w个记录。<mark>置换-选择算法的步骤如下：</mark></p> 
<p>1）从FI输⼊w个记录到⼯作区WA。</p> 
<p>2）从WA中选出其中关键字取最⼩值的记录，记为MINIMAX记录。</p> 
<p>3）将MINIMAX记录输出到FO中去。</p> 
<p>4）若FI不空，则从FI输⼊下⼀个记录到WA中。</p> 
<p>5）从WA中所有关键字⽐MINIMAX记录的关键字⼤的记录中选出最⼩关键字记录，作为新的 MINIMAX记录。</p> 
<p>6）重复3）～5），直⾄在WA中选不出新的MINIMAX记录为⽌，由此得到⼀个初始归并段，输 出⼀个归并段的结束标志到FO中去。</p> 
<p>7）重复2）～6），直⾄WA为空。由此得到全部初始归并段。</p> 
<h5><a id="874__2173"></a>8.7.4 最佳归并树</h5> 
<p>思想：让记录少的归并段最先归并,记录多的最晚归并</p> 
<p>重要结论：<mark>归并过程中的磁盘I/O次数 = 归并树的WPL * 2</mark></p> 
<p>要让磁盘I/O次数最少， 就要使归并树WPL最⼩ ——<mark>哈夫曼树！</mark></p> 
<p>注意：对于k叉归并，若<mark>初始归并段的数量⽆法构成严格的 k 叉归并树</mark>， 则需要<mark>补充⼏个⻓度为 0 的“虚段”</mark>，再进⾏ k 叉哈夫曼树的构造。</p> 
<p><mark>m叉哈夫曼树：</mark></p> 
<ol><li>叶结点 参加归并的一个初始归并段</li><li>叶结点的权值 初始归并段中的记录数</li><li>叶结点到根结点的路径长度 归并趟数</li><li>非叶结点 归并生成的新归并段</li><li>归并树的带权路径长度 总读记录数</li></ol> 
<p><img src="https://images2.imgbox.com/41/91/PbQfZGxE_o.png" alt="image-20220715200609097"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3f5d32ae3748ea2c127a2c53f650d083/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2022深圳杯C题自动驾驶电动物料车换电站选址及调度方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e7fe12888b71cd9a4271cb1f2992c06/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C# protobuf ByteString和string之间的转换方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>