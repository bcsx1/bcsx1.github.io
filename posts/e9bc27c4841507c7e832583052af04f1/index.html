<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python循环语句-详解Python中的循环语句的用法 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python循环语句-详解Python中的循环语句的用法" />
<meta property="og:description" content="一、简介
Python的条件和循环语句，决定了程序的控制流程，体现结构的多样性。须重要理解，if、while、for以及与它们相搭配的 else、 elif、break、continue和pass语句。
二、详解
1、if语句
Python中的if子句由三部分组成：关键字本身、用于判断结果真假的条件表达式以及当表达式为真或者非零时执行的代码块。if 语句的语法如下：
if expression:
expr_true_suite
if 语句的expr_true_suite代码块只有在条件表达式的结果的布尔值为真时才执行，否则将继续执行紧跟在该代码块后面的语句。
（1）多重条件表达式
单个if语句可以通过使用布尔操作符and、or和not，实现多重判断条件或是否定判断条件。
（2）单一语句的代码块
如果一个复合语句（例如if子句、while或for循环）的代码块仅仅包含一行代码，那么它可以和前面的语句写在同一行上。如if make_hard_copy: send_data_to_printer()，这样的单行语句是合法的， 尽管它可能方便，但这样会使得代码更难阅读， 所以推荐将这行代码移到下一行并合理地缩进。另外一个原因就是如果你需要添加新的代码, 你还是得把它移到下一行。
2、else语句 Python提供了与if语句搭配使用的else语句，如果if语句的条件表达式的结果布尔值为假，那么程序将执行 else 语句后的代码。其语法如下：
if expression:
expr_true_suite
else:
expr_false_suite
在C语言中，不会在条件语句范围外发现else语句， 但Python不同，可以在while和for循环中使用else语句，在循环中使用时，else子句只在循环完成后执行，也就是说break语句也会跳过else块。
例：显示出10到20中的数字的最大约数
在CODE上查看代码片派生到我的代码片
#!/usr/bin/env python
def showMaxFactor(num):
count = num / 2
while count &gt; 1:
if (num % count == 0):
print &#39;largest factor of %d is %d&#39; % (num, count)
break
count = count - 1" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/e9bc27c4841507c7e832583052af04f1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-01T12:07:08+08:00" />
<meta property="article:modified_time" content="2020-11-01T12:07:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python循环语句-详解Python中的循环语句的用法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、简介</p> 
<p>Python的条件和循环语句，决定了程序的控制流程，体现结构的多样性。须重要理解，if、while、for以及与它们相搭配的 else、 elif、break、continue和pass语句。</p> 
<p>二、详解</p> 
<p>1、if语句</p> 
<p>Python中的if子句由三部分组成：关键字本身、用于判断结果真假的条件表达式以及当表达式为真或者非零时执行的代码块。if 语句的语法如下：</p> 
<p>if expression:</p> 
<p>expr_true_suite</p> 
<p>if 语句的expr_true_suite代码块只有在条件表达式的结果的布尔值为真时才执行，否则将继续执行紧跟在该代码块后面的语句。</p> 
<p>（1）多重条件表达式</p> 
<p>单个if语句可以通过使用布尔操作符and、or和not，实现多重判断条件或是否定判断条件。</p> 
<p>（2）单一语句的代码块</p> 
<p>如果一个复合语句（例如if子句、while或for循环）的代码块仅仅包含一行代码，那么它可以和前面的语句写在同一行上。如if make_hard_copy: send_data_to_printer()，这样的单行语句是合法的， 尽管它可能方便，但这样会使得代码更难阅读， 所以推荐将这行代码移到下一行并合理地缩进。另外一个原因就是如果你需要添加新的代码, 你还是得把它移到下一行。</p> 
<p>2、else语句 Python提供了与if语句搭配使用的else语句，如果if语句的条件表达式的结果布尔值为假，那么程序将执行 else 语句后的代码。其语法如下：</p> 
<p>if expression:</p> 
<p>expr_true_suite</p> 
<p>else:</p> 
<p>expr_false_suite</p> 
<p>在C语言中，不会在条件语句范围外发现else语句， 但Python不同，可以在while和for循环中使用else语句，在循环中使用时，else子句只在循环完成后执行，也就是说break语句也会跳过else块。</p> 
<p>例：显示出10到20中的数字的最大约数</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>#!/usr/bin/env python</p> 
<p>def showMaxFactor(num):</p> 
<p>count = num / 2</p> 
<p>while count &gt; 1:</p> 
<p>if (num % count == 0):</p> 
<p>print 'largest factor of %d is %d' % (num, count)</p> 
<p>break</p> 
<p>count = count - 1</p> 
<p>else:</p> 
<p>print eachNum, 'is prime'</p> 
<p>for eachNum in range(10, 21):</p> 
<p>showMaxFactor(eachNum)</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>largest factor of 10 is 5</p> 
<p>11 is prime</p> 
<p>largest factor of 12 is 6</p> 
<p>13 is prime</p> 
<p>largest factor of 14 is 7</p> 
<p>largest factor of 15 is 5</p> 
<p>largest factor of 16 is 8</p> 
<p>17 is prime</p> 
<p>largest factor of 18 is 9</p> 
<p>19 is prime</p> 
<p>largest factor of 20 is 10</p> 
<p>3、elif (即else-if )语句 elif是Python的else-if 语句，它检查多个表达式是否为真，并在为真时执行特定代码块中的代码。和else一样，elif 声明是可选的，然而不同的是if 语句后最多只能有一个else语句，但可以有任意数量的 elif 语句。</p> 
<p>if expression1:</p> 
<p>expr1_true_suite</p> 
<p>elif expression2:</p> 
<p>expr2_true_suite</p> 
<p>...</p> 
<p>elif expressionN:</p> 
<p>exprN_true_suite</p> 
<p>else:</p> 
<p>none_of_the_above_suite</p> 
<p>在将来的某天，Python可能会支持 switch /case语句，但是完全可以用其他的Python结构来模拟它。在Python中，大量的if-elif 语句并不难阅读。</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>if user.cmd == 'create':</p> 
<p>action = "create item"</p> 
<p>elif user.cmd == 'delete':</p> 
<p>action = 'delete item'</p> 
<p>elif user.cmd == 'update':</p> 
<p>action = 'update item'</p> 
<p>else:</p> 
<p>action = 'invalid choice... try again!'</p> 
<p>上面的语句还可以用序列和成员关系操作符来简化它：</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>if user.cmd in ('create', 'delete', 'update'):</p> 
<p>action = '%s item' % user.cmd</p> 
<p>else:</p> 
<p>action = 'invalid choice... try again!'</p> 
<p>还可以用Python字典给出更加优雅的解决方案，使用映射对象（比如字典）的一个最大好处就是它的搜索操作比类似语句或是 for 循环这样的序列查询要快很多。</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>msgs = {'create': 'create item',</p> 
<p>'delete': 'delete item',</p> 
<p>'update': 'update item'</p> 
<p>}</p> 
<p>default = 'invalid choice... try again!'</p> 
<p>action = msgs.get(user.cmd, default)</p> 
<p>4、条件表达式(即"三元操作符") 三元运算符语法为：X if C else Y，只需要一行完成条件判断和赋值操作：</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>&gt;&gt;&gt; x, y = 4, 3</p> 
<p>&gt;&gt;&gt; smaller = x if x &lt; y else y</p> 
<p>&gt;&gt;&gt; smaller</p> 
<p>3</p> 
<p>5、while语句 while是一个条件循环语句，与if声明相比，如果 if 后的条件为真，就会执行一次相应的代码块。而while中的代码块会一直循环执行，直到循环条件不再为真。</p> 
<p>（1）一般语法</p> 
<p>while循环的语法如下：</p> 
<p>while expression:</p> 
<p>suite_to_repeat</p> 
<p>while循环的suite_to_repeat子句会一直循环执行，直到expression值为布尔假。</p> 
<p>（2）计数循环</p> 
<p>count = 0</p> 
<p>while (count &lt; 9):</p> 
<p>print 'the index is:', count</p> 
<p>count += 1</p> 
<p>代码块里包含了print和自增语句，它们被重复执行，直到count不再小于9。索引count在每次迭代时被打印出来然后自增 1。</p> 
<p>（3）无限循环</p> 
<p>while True:</p> 
<p>handle, indata = wait_for_client_connect()</p> 
<p>outdata = process_request(indata)</p> 
<p>ack_result_to_client(handle, outdata)</p> 
<p>“无限”循环永远不会结束，但它不一定是坏事，许多通讯服务器的客户端/服务器系统就是通过它来工作的。</p> 
<p>6、for语句 Python提供了的另一个循环机制就是for语句，它是Python中最强大的循环结构。它可以遍历序列成员，可以用在列表解析和生成器表达式中，它会自动地调用迭代器的next()方法，捕获StopIteration异常并结束循环（所有这一切都是在内部发生的）。 Python的for更像是shell或是脚本语言中的foreach循环。</p> 
<p>（1）一般语法</p> 
<p>for循环会访问一个可迭代对象（例如序列或是迭代器）中的所有元素,，并在所有条目都处理过后结束循环。它的语法如下：</p> 
<p>for iter_var in iterable:</p> 
<p>suite_to_repeat</p> 
<p>每次循环， iter_var迭代变量被设置为可迭代对象（序列、迭代器或者是其他支持迭代的对象）的当前元素，提供给suite_to_repeat 语句块使用。</p> 
<p>（2）用于序列类型</p> 
<p>for循环可以迭代不同的序列对象，像字符串、 列表、以及元组。</p> 
<p>迭代序列有三种基本方法：</p> 
<p>通过序列项迭代</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>&gt;&gt;&gt; nameList = ['Walter', "Nicole", 'Steven', 'Henry']</p> 
<p>&gt;&gt;&gt; for eachName in nameList:</p> 
<p>... print eachName, "Lim"</p> 
<p>...</p> 
<p>Walter Lim</p> 
<p>Nicole Lim</p> 
<p>Steven Lim</p> 
<p>Henry Lim</p> 
<p>迭代一个列表.。每次迭代，eacgName变量都被设置为列表中特定某个元素。</p> 
<p>通过序列索引迭代</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>&gt;&gt;&gt; nameList = ['Cathy', "Terry", 'Joe', 'Heather','Lucy']</p> 
<p>&gt;&gt;&gt; for nameIndex in range(len(nameList)):</p> 
<p>... print "Liu,", nameList[nameIndex]</p> 
<p>...</p> 
<p>Liu, Cathy</p> 
<p>Liu, Terry</p> 
<p>Liu, Joe</p> 
<p>Liu, Heather</p> 
<p>Liu, Lucy</p> 
<p>没有迭代元素, 而是通过列表的索引迭代。但通过直接迭代序列要比索引迭代快。</p> 
<p>使用项和索引迭代</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>&gt;&gt;&gt; nameList = ['Donn', 'Shirley', 'Ben', 'Janice','David', 'Yen', 'Wendy']</p> 
<p>&gt;&gt;&gt; for i, eachLee in enumerate(nameList):</p> 
<p>... print "%d %s Lee" % (i+1, eachLee)</p> 
<p>...</p> 
<p>1 Donn Lee</p> 
<p>2 Shirley Lee</p> 
<p>3 Ben Lee</p> 
<p>4 Janice Lee</p> 
<p>5 David Lee</p> 
<p>6 Yen Lee</p> 
<p>7 Wendy Lee</p> 
<p>（3）用于迭代器类型</p> 
<p>用for循环访问迭代器和访问序列的方法差不多，迭代器并不代表循环条目的集合，迭代器对象有一个next()方法， 调用后返回下一个条目。 所有条目迭代完后， 迭代器引发一个StopIteration异常告诉程序循环结束，for语句在内部调用next()并捕获异常。</p> 
<p>使用迭代器做 for 循环的代码与使用序列条目几乎完全相同。事实上在大多情况下，无法分辨出迭代的是一个序列还是迭代器，因此遍历一个迭代器时，实际上可能指的是要遍历一个序列、迭代器或是一个支持迭代的对象（它有 next()方法）。</p> 
<p>（4）range()内建函数</p> 
<p>内建函数range()可以把类似foreach的for循环变成你更加熟悉的语句。</p> 
<p>Python提供了两种不同的方法来调用range() ，完整语法要求提供两个或三个整数参数：range(start, end, step =1)，range()会返回一个包含所有k的列表，其中start &lt;= k &lt; end，从start到end ，k每次递增 ste，step不可以为零，否则将发生错误。</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>&gt;&gt;&gt; range(3, 7)</p> 
<p>[3, 4, 5, 6]</p> 
<p>&gt;&gt;&gt; for eachVal in range(2, 19, 3):</p> 
<p>... print "value is:", eachVal</p> 
<p>...</p> 
<p>value is: 2</p> 
<p>value is: 5</p> 
<p>value is: 8</p> 
<p>value is: 11</p> 
<p>value is: 14</p> 
<p>value is: 17</p> 
<p>range() 还有两种简略的语法格式：range(end)和range(start, end)。 start 默认为0， step默认为1。</p> 
<p>（5）xrange()内建函数</p> 
<p>xrange()类似range()，不过当有一个很大的范围列表时，xrange() 可能更为适合， 因为它不会在内存里创建列表的完整拷贝。 它只被用在 for 循环中，在 for 循环外使用它没有意义。它的性能远高出 range()，因为它不生成整个列表。在Python的将来版本中，range()可能会像xrange()一样，返回一个可迭代对象（不是列表也不是一个迭代器）。</p> 
<p>（6）与序列相关的内建函数</p> 
<p>序列相关函数：sorted()、 reversed()、enumerate()和zip()，称为“序列相关”是因为其中两个函数（sorted() 和 zip()）返回一个序列（列表），而另外两个函数（reversed() 和 enumerate()）返回迭代器（类似序列）。</p> 
<p>7、break和continue语句 Python中的break语句可以结束当前循环然后跳转到下条语句，类似C中的break。常用在当某个外部条件被触发（一般通过 if 语句检查），需要立即从循环中退出时.。break 语句可以用在 while 和 for 循环中。</p> 
<p>Python里的continue语句和其他高级语言中的传统continue并没有什么不同，它可以被用在while和for循环里。 while循环是条件</p> 
<p>性的，而 for 循环是迭代的，所以continue在开始下一次循环前要满足一些先决条件，否则循环会正常结束。</p> 
<p>程序中当遇到 continue 语句时, 程序会终止当前循环，并忽略剩余的语句，然后回到循环的顶端。在开始下一次迭代前，如果是条件循环，我们将验证条件表达式。如果是迭代循环，将验证是否还有元素可以迭代。只有在验证成功的情况下，才会开始下一次迭代。</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>#!/usr/bin/env python</p> 
<p>valid = False</p> 
<p>count = 3</p> 
<p>passwdList=('abc',)</p> 
<p>while count &gt; 0 and valid == False:</p> 
<p>input = raw_input("enter password:").strip()</p> 
<p># check for valid passwd</p> 
<p>for eachPasswd in passwdList:</p> 
<p>if input == eachPasswd:</p> 
<p>valid = True</p> 
<p>break</p> 
<p>if not valid: # (or valid == 0)</p> 
<p>print "invalid input"</p> 
<p>count -= 1</p> 
<p>continue</p> 
<p>else:</p> 
<p>break</p> 
<p>结合使用了while、for、if、break以及continue，来验证用户输入。用户有三次机会来输入正确的密码，阻止用户猜测密码。</p> 
<p>8、pass语句 Python中没有对应的空大括号或是分号( ; )来表示如C语言中的“不做任何事”，如果需要子语句块的地方不写任何语句， 解释器会提示语法错误。因此，Python 提供了pass语句，它不做任何事情，即NOP（No OPeration），pass同样也可作为开发中的小技巧，标记以后将要完成的代码。</p> 
<p>def foo_func():</p> 
<p>pass</p> 
<p>这样的代码结构在开发和调试时很有用，因为编写代码的时候可能要先把结构定下来，但又不希望它干扰其他已经完成的代码， 在不需要它做任何事情地方放一个pass，将是一个很好的主意。另外它在异常处理中也被经常用到，比如你跟踪到了一个非致命的错误而不想采取任何措施。</p> 
<p>9、迭代器和iter()函数</p> 
<p>（1）什么是迭代器</p> 
<p>迭代器为类序列对象提供了一个类序列的接口，可以利用它们的索引从0开始一直"迭代" 到序列的最后一个条目，用"计数"的方法迭代序列是很简单的。 Python的迭代无缝地支持序列对象，而且它还允许程序员迭代非序列类型， 包括用户定义的对象。</p> 
<p>迭代器用起来很灵巧，可以迭代不是序列但表现出序列行为的对象，例如字典的 key 、一个文件的行等等。当使用循环迭代一个对象条目时，不必去关注它是迭代器还是序列。</p> 
<p>（2）为什么要迭代器</p> 
<p>迭代器的定义：提供了可扩展的迭代器接口、对列表迭代带来了性能上的增强、在字典迭代中性能提升、创建真正的迭代接口，而不是原来的随机对象访问、与所有已经存在的用户定义的类以及扩展的模拟序列和映射的对象向后兼容、迭代非序列集合（例如映射和文件）时， 可以创建更简洁可读的代码。</p> 
<p>（3）如何迭代</p> 
<p>迭代器有一个next()方法的对象，而不是通过索引来计数。当一个循环机制（例如 for 语句）需要下一个项时，调用迭代器的next()方法就可以获得它。条目全部取出后，会引发一个StopIteration异常，这并不表示错误发生，只是告诉外部调用者迭代完成。</p> 
<p>不过，迭代器也有一些限制。 例如不能向后移动，不能回到开始，也不能复制一个迭代器。如果要再次(或者是同时)迭代同个对象，你只能去创建另一个迭代器对象。不过，还有其他的工具来帮助你使用迭代器。</p> 
<p>reversed()内建函数将返回一个反序访问的迭代器。enumerate()内建函数同样也返回迭代器。另外两个新的内建函数：any()和 all()，如果迭代器中某个/所有条目的值都为布尔真时，则它们返回值为真。</p> 
<p>（4）使用迭代器</p> 
<p>序列</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>&gt;&gt;&gt; myTuple = (123, 'xyz', 45.67)</p> 
<p>&gt;&gt;&gt; i = iter(myTuple)</p> 
<p>&gt;&gt;&gt; i.next()</p> 
<p>123</p> 
<p>&gt;&gt;&gt; i.next()</p> 
<p>'xyz'</p> 
<p>&gt;&gt;&gt; i.next()</p> 
<p>45.670000000000002</p> 
<p>&gt;&gt;&gt; i.next()</p> 
<p>Traceback (most recent call last):</p> 
<p>File "", line 1, in </p> 
<p>StopIteration</p> 
<p>在for循环中for i in seq:do_something_to(i)，它会自动调用迭代器的next()方法，并且监视StopIteration异常。</p> 
<p>字典</p> 
<p>字典和文件是另外两个可迭代的Python数据类型。字典的迭代器会遍历它的键(keys)，语句for eachKey in myDict.keys()可以缩写为for eachKey in myDict。</p> 
<p>Python还引进了三个新的内建字典方法来定义迭代： myDict.iterkeys() （通过 keys 迭代）， myDict.itervalues() （通过 values 迭代）以及myDicit.iteritems() （通过key/value 对来迭代 ）。 注意 ： in操作符也可以用于检查字典的key是否存在，布尔表达式myDict.has_key(anyKey)可以被简写为anyKey in myDict。</p> 
<p>文件</p> 
<p>文件对象生成的迭代器会自动调用readline()方法。这样，循环就可以访问文本文件的所有行。可以使用更简单的for eachLine in myFile替 换for eachLine in myFile.readlines()。</p> 
<p>（5）可变对象和迭代器</p> 
<p>在迭代可变对象的时候修改它们并不是个好主意，这在迭代器出现之前就是一个问题。一个序列的迭代器只是记录当前到达第几个元素，所以若在迭代时改变了元素，更新会立即反映到你所迭代的条目上。在迭代字典的key时，绝对不能改变这个字典。 使用字典的keys()方法是可以的，因为keys() 返回一个独立于字典的列表， 而迭代器是与实际对象绑定在一起的，它将不会继续执行下去。</p> 
<p>（6）如何创建迭代器</p> 
<p>对一个对象调用iter()就可以得到它的迭代器，它的语法如下：iter(obj)或iter(func, sentinel )。如果传递一个参数给iter()，它会检查你传递的是不是一个序列，如果是则会根据索引从0一直迭代到序列结束。另一个创建迭代器的方法是使用类，一个实现__iter__()和next()方法的类可以作为迭代器使用。如果是传递两个参数给iter()， 它会重复地调用func，直到迭代器的下个值等于sentinel。</p> 
<p>10、列表解析 列表解析( List comprehensions或缩略为list comps ) 来自函数式编程语言Haskell。它是一个非常有用、简单、而且灵活的工具， 可以用来动态地创建列表。</p> 
<p>Python支持的函数式编程特性，例如lambda 、map() 以及filter()等，通过列表解析它们可以被简化为一个列表解析式子。map()对所有的列表成员应用一个操作，filter()基于一个条件表达式过滤列表成员，lambda()允许快速地创建只有一行的函数对象。</p> 
<p>列表解析的语法：[expr for iter_var in iterable]， 它迭代iterable对象的所有条目。其中的expr应用于序列的每个成员，最后的结果值是该表达式产生的列表，迭代变量并不需要是表达式的一部分。</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>&gt;&gt;&gt; [x ** 2 for x in range(6)]</p> 
<p>[0, 1, 4, 9, 16, 25]</p> 
<p>列表解析的表达式可以取代内建的map()函数以及lambda ，而且效率更高。结合 if语句，列表解析还提供了一个扩展版本的语法：[expr for iter_var in iterable if cond_expr]，它在迭代时会过滤/捕获满足条件表达式cond_expr的序列成员。</p> 
<p>挑选出序列中的奇数：</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>&gt;&gt;&gt; seq = [11, 10, 9, 9, 10, 10, 9, 8, 23, 9, 7, 18, 12, 11, 12]</p> 
<p>&gt;&gt;&gt; filter(lambda x: x % 2, seq)</p> 
<p>[11, 9, 9, 9, 23, 9, 7, 11]</p> 
<p>&gt;&gt;&gt; [x for x in seq if x % 2]</p> 
<p>[11, 9, 9, 9, 23, 9, 7, 11]</p> 
<p>即使不用filter()和lambda，可以使用列表解析来完成操作，获得想要的数字。</p> 
<p>矩阵样例：迭代一个有三行五列的矩阵，[(x+1,y+1) for x in range(3) for y in range(5)]。</p> 
<p>磁盘文件样例：若有一个数据文件text.txt，需要计算出所有非空白字符的数目，可以把每行分割( split )为单词,，然后计算单词个数：&gt;&gt;&gt; f = open('hhga.txt', 'r');len([word for line in f for word in line.split()])。快速地计算文件大小：&gt;&gt;&gt;import os;os.stat('text.txt').st_size。把每个单词的长度加起来：&gt;&gt;&gt;f.seek(0);sum([len(word) for line in f for word in line.split()])。</p> 
<p>11、生成器表达式</p> 
<p>生成器表达式是列表解析的一个扩展，只用一行代码就可以创建包含特定内容的列表。另一个重要特性是生成器，生成器是特定的函数，允许返回一个值，然后"暂停"代码的执行，稍后恢复。</p> 
<p>列表解析的一个不足就是必要生成所有的数据，用以创建整个列表。这可能对有大量数据的迭代器有负面效应， 生成器表达式通过结合列表解析和生成器解决了这个问题。</p> 
<p>生成器表达式与列表解析非常相似，而且它们的基本语法基本相同。不过它并不真正创建数字列表而是返回一个生成器，这个生成器在每次计算出一个条目后，把这个条目“产生”(yield)出来。生成器表达式使用了"延迟计算"(lazy evaluation)，所以它在使用内存上更有效。生成器并不会让列表解析废弃，它只是一个内存使用更友好的结构，基于此,有很多使用生成器地方。</p> 
<p>列表解析语法：</p> 
<p>[expr for iter_var in iterable if cond_expr]</p> 
<p>生成器表达式语法：</p> 
<p>(expr for iter_var in iterable if cond_expr)</p> 
<p>磁盘文件样例：上述计算文本文件中非空白字符总和，如果这个文件的大小变得很大， 那么这行代码的内存性能会很低，因为要创建一个很长的列表用于存放单词的长度。为了避免创建庞大的列表，使用生成器表达式来完成求和操作，优化后的代码：&gt;&gt;&gt; sum(len(word) for line in data for word in line.split())，是把方括号删除，少了两字节， 而且更节省内存。</p> 
<p>交叉配对例子：成器表达式就好像是懒惰的列表解析（这反而成了它主要的优势），它还可以用来处理其他列表或生成器，如：x_product_pairs = ((i, j) for i in rows for j in cols())。</p> 
<p>重构样例，寻找文件最长的行的例子：</p> 
<p>以前的方法：</p> 
<p>在CODE上查看代码片派生到我的代码片</p> 
<p>#!/usr/bin/env python</p> 
<p>def fun():</p> 
<p>f = open('/etc/motd', 'r')</p> 
<p>longest = 0</p> 
<p>allLines = [x.strip() for x in f.readlines()] #or allLineLens = [len(x.strip()) for x in f]</p> 
<p>f.close()</p> 
<p>for line in allLines:</p> 
<p>linelen = len(line)</p> 
<p>if linelen &gt; longest: #or longest = max(allLineLens)</p> 
<p>longest = linelen</p> 
<p>return longest</p> 
<p>新的方法：</p> 
<p>使用生成器表达式替换列表解析和max()函数，并去掉文件打开模式（默认为读取）：return max(len(x.strip()) for x in open('/etc/motd'))。</p> 
<p>三、总结（1）itertools模块被加入，更加支持了迭代器的应用，列表解析和生成表达式的内容可结合实例分析。</p> 
<p>（2）若有不足，请留言，在此先感谢！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e4616d2f5db450c97ab5427d835d9fd5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FPGA 频率计实验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4df195c5c58ee2c1fd303030f3167155/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python文件可以用什么软件打开-py文件用什么可以打开.</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>