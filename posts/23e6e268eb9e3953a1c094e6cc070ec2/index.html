<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32配合CubeMX硬件SPI驱动0.96寸OLED - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32配合CubeMX硬件SPI驱动0.96寸OLED" />
<meta property="og:description" content="目录
一、简单介绍
1.1 OLED
1.2 SPI协议
接口
优点
缺点
数据传输
二、实战
2.1 工程配置
2.2 测试工程
2.3 波形分析
三、驱动OLED
3.1 初始化代码
3.2 清屏函数
3.3 设置坐标函数
3.4 显示字符函数
3.5 显示字符串函数
3.6 显示图片函数
附录 驱动代码文件
oled.c
oled.h
f6x8.h
一、简单介绍 1.1 OLED 有机发光二极管（英语：Organic Light-Emitting Diode，缩写：OLED）又称有机电激发光显示（英语：Organic Electroluminescence Display，缩写：OELD）、有机发光半导体，OLED技术最早于1950年代和1960年代由法国人和美国人研制，其后由美国柯达及英国剑桥大学加以演进，日本SONY及韩国三星和LG等公司于21世纪开始量产，现在的市场都趋近于OLED但是在寿命上比LCD短。[来源请求]
OLED（有机发光二极管）与TFT-LCD（薄膜晶体管液晶显示器）为不同类型的产品，OLED具有自发光性、广视角、高对比、低耗电、高反应速率、全彩化及制程简单等优点，但相对的在大面板价格、技术选择性 、寿命、分辨率、色彩还原方面便无法与TFT-LCD匹敌，有机发光二极管显示器可分单色、多彩及全彩等种类，而其中以全彩制作技术最为困难。
OLED显示器依驱动方式的不同又可分为被动式（Passive Matrix，PMOLED）与主动式（Active Matrix，AMOLED）。
笔者使用的oled如上图，七针脚SPI协议，主控为SSD1306。
规格为0.96寸，分辨率为128*64
1.2 SPI协议 串行外设接口（Serial Peripheral Interface Bus，SPI），是一种用于芯片通信的同步串行通信接口规范，主要应用于单片机系统中。类似I²C。 这种接口首先由摩托罗拉公司于20世纪80年代中期开发，后发展成了行业规范。它的典型应用有闪存[1][2]、EEPROM、SD卡与液晶显示器。
SPI设备之间使用全双工模式通信，是一个主机和一个或多个从机的主从模式。主机负责初始化帧，这个数据传输帧可以用于读与写两种操作，片选线路可以从多个从机选择一个来响应主机的请求。
有时SPI接口被称作四线式接口，这是为了与其他不同线制的数据传输接口加以区分。SPI准确来讲应为“同步串行接口”，但是它又与同步串行接口协议（SSI）是完全不同的两种协议。虽然SSI也是一个四线式同步通信协议，但是它使用差分信号，而且仅提供一个单工通信信道。于此相对地，SPI是一个单主机多从机的通信接口。
SPI是一种事实标准，也就是说这种规范没有对应的技术标准。因此各个厂家生产的SPI器件配置不一样，不一定有互操作性。
接口 SPI总线规定了4个保留逻辑信号接口：
SCLK（Serial Clock）：串列时脉，由主机发出MOSI（Master Output, Slave Input）：主机输出从机输入信号（数据由主机发出）MISO（Master Input, Slave Output）：主机输入从机输出信号（数据由从机发出）SS（Slave Select）：片选信号，由主机发出，一般是低电位有效 尽管上面的引脚名称是最常用的，但在过去，有时会使用其他引脚命名方式，因此旧的集成电路产品的SPI端口引脚名称可能有所不同。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/23e6e268eb9e3953a1c094e6cc070ec2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-23T17:17:28+08:00" />
<meta property="article:modified_time" content="2023-11-23T17:17:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32配合CubeMX硬件SPI驱动0.96寸OLED</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="%E4%B8%80%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D" rel="nofollow">一、简单介绍</a></p> 
<p id="1.1%20OLED-toc" style="margin-left:80px;"><a href="#1.1%20OLED" rel="nofollow">1.1 OLED</a></p> 
<p id="1.2%20SPI%E5%8D%8F%E8%AE%AE-toc" style="margin-left:80px;"><a href="#1.2%20SPI%E5%8D%8F%E8%AE%AE" rel="nofollow">1.2 SPI协议</a></p> 
<p id="%E6%8E%A5%E5%8F%A3-toc" style="margin-left:120px;"><a href="#%E6%8E%A5%E5%8F%A3" rel="nofollow">接口</a></p> 
<p id="%E4%BC%98%E7%82%B9-toc" style="margin-left:120px;"><a href="#%E4%BC%98%E7%82%B9" rel="nofollow">优点</a></p> 
<p id="%E7%BC%BA%E7%82%B9-toc" style="margin-left:120px;"><a href="#%E7%BC%BA%E7%82%B9" rel="nofollow">缺点</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-toc" style="margin-left:120px;"><a href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93" rel="nofollow">数据传输</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%AE%9E%E6%88%98-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E6%88%98" rel="nofollow">二、实战</a></p> 
<p id="2.1%20%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#2.1%20%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE" rel="nofollow">2.1 工程配置</a></p> 
<p id="2.2%20%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B-toc" style="margin-left:80px;"><a href="#2.2%20%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B" rel="nofollow">2.2 测试工程</a></p> 
<p id="2.3%20%E6%B3%A2%E5%BD%A2%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2.3%20%E6%B3%A2%E5%BD%A2%E5%88%86%E6%9E%90" rel="nofollow">2.3 波形分析</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%A9%B1%E5%8A%A8OLED-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E9%A9%B1%E5%8A%A8OLED" rel="nofollow">三、驱动OLED</a></p> 
<p id="%C2%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A3%E7%A0%81%20%E7%BC%96%E5%86%99%E5%A6%82%E4%B8%8B-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A3%E7%A0%81%20%E7%BC%96%E5%86%99%E5%A6%82%E4%B8%8B" rel="nofollow">3.1 初始化代码</a></p> 
<p id="%E4%B8%8B%E9%9D%A2%E7%BC%96%E5%86%99%E6%B8%85%E5%B1%8F%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E4%B8%8B%E9%9D%A2%E7%BC%96%E5%86%99%E6%B8%85%E5%B1%8F%E5%87%BD%E6%95%B0" rel="nofollow">3.2 清屏函数</a></p> 
<p id="%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E6%98%AF%E8%AE%BE%E7%BD%AE%E5%9D%90%E6%A0%87%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E6%98%AF%E8%AE%BE%E7%BD%AE%E5%9D%90%E6%A0%87%E5%87%BD%E6%95%B0" rel="nofollow">3.3 设置坐标函数</a></p> 
<p id="%C2%A0%E6%8C%89%E7%85%A7%E8%BF%99%E4%B8%AA%E6%80%9D%E8%B7%AF%E7%BC%96%E5%86%99%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%8C%89%E7%85%A7%E8%BF%99%E4%B8%AA%E6%80%9D%E8%B7%AF%E7%BC%96%E5%86%99%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0" rel="nofollow">3.4 显示字符函数</a></p> 
<p id="3.5%20%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.5%20%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0" rel="nofollow">3.5 显示字符串函数</a></p> 
<p id="%E7%BC%96%E5%86%99%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E7%BC%96%E5%86%99%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E5%87%BD%E6%95%B0" rel="nofollow">3.6 显示图片函数</a></p> 
<p id="%E9%99%84%E5%BD%95%20%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%E9%99%84%E5%BD%95%20%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6" rel="nofollow">附录 驱动代码文件</a></p> 
<p id="oled.c-toc" style="margin-left:80px;"><a href="#oled.c" rel="nofollow">oled.c</a></p> 
<p id="oled.h-toc" style="margin-left:80px;"><a href="#oled.h" rel="nofollow">oled.h</a></p> 
<p id="%C2%A0f6x8.h-toc" style="margin-left:80px;"><a href="#%C2%A0f6x8.h" rel="nofollow">f6x8.h</a></p> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D">一、简单介绍</h3> 
<h4 id="1.1%20OLED">1.1 OLED</h4> 
<p><strong>有机发光二极管</strong>（英语：Organic Light-Emitting Diode，缩写：<strong>OLED</strong>）又称<strong>有机电激发光显示</strong>（英语：Organic Electroluminescence Display，缩写：<strong>OELD</strong>）、<strong>有机发光半导体</strong>，OLED技术最早于1950年代和1960年代由法国人和美国人研制，其后由美国<a href="https://zh.wikipedia.org/wiki/%E4%BC%8A%E5%A3%AB%E6%9B%BC%E6%9F%AF%E8%BE%BE%E5%85%AC%E5%8F%B8" rel="nofollow" title="柯达">柯达</a>及英国<a href="https://zh.wikipedia.org/wiki/%E5%8A%8D%E6%A9%8B%E5%A4%A7%E5%AD%B8" rel="nofollow" title="剑桥大学">剑桥大学</a>加以演进，日本<a href="https://zh.wikipedia.org/wiki/SONY" rel="nofollow" title="SONY">SONY</a>及韩国<a href="https://zh.wikipedia.org/wiki/%E4%B8%89%E6%98%9F%E9%9B%86%E5%9C%98" rel="nofollow" title="三星">三星</a>和<a href="https://zh.wikipedia.org/wiki/LG%E9%9B%86%E5%9C%98" rel="nofollow" title="LG">LG</a>等公司于<a href="https://zh.wikipedia.org/wiki/21%E4%B8%96%E7%BA%AA" rel="nofollow" title="21世纪">21世纪</a>开始量产，现在的市场都趋近于OLED但是在寿命上比<a href="https://zh.wikipedia.org/wiki/LCD" rel="nofollow" title="LCD">LCD</a>短。<a href="https://zh.wikipedia.org/wiki/Wikipedia:%E5%88%97%E6%98%8E%E6%9D%A5%E6%BA%90" rel="nofollow" title="[来源请求]">[来源请求]</a></p> 
<p>OLED（有机发光二极管）与<a href="https://zh.wikipedia.org/wiki/TFT-LCD" rel="nofollow" title="TFT-LCD">TFT-LCD</a>（薄膜晶体管液晶显示器）为不同类型的产品，OLED具有自发光性、广<a href="https://zh.wikipedia.org/wiki/%E8%A6%96%E8%A7%92" rel="nofollow" title="视角">视角</a>、高对比、低耗电、高反应速率、全彩化及制程简单等优点，但相对的在大面板价格、技术选择性 、寿命、<a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E5%BA%A6" rel="nofollow" title="分辨率">分辨率</a>、<a href="https://zh.wikipedia.org/wiki/%E8%89%B2%E5%BD%A9" rel="nofollow" title="色彩">色彩</a>还原方面便无法与<a href="https://zh.wikipedia.org/wiki/TFT-LCD" rel="nofollow" title="TFT-LCD">TFT-LCD</a>匹敌，有机发光二极管显示器可分单色、多彩及全彩等种类，而其中以全彩制作技术最为困难。</p> 
<p>OLED显示器依驱动方式的不同又可分为被动式（Passive Matrix，<a href="https://zh.wikipedia.org/w/index.php?title=PMOLED&amp;action=edit&amp;redlink=1" rel="nofollow" title="PMOLED">PMOLED</a>）与主动式（Active Matrix，<a href="https://zh.wikipedia.org/wiki/AMOLED" rel="nofollow" title="AMOLED">AMOLED</a>）。</p> 
<p class="img-center"><img alt="" height="236" src="https://images2.imgbox.com/78/d2/JVzClVuu_o.png" width="315"></p> 
<p></p> 
<p>笔者使用的oled如上图，七针脚SPI协议，主控为<span style="color:#fe2c24;">SSD1306</span>。</p> 
<p>规格为0.96寸，分辨率为128*64</p> 
<h4 id="1.2%20SPI%E5%8D%8F%E8%AE%AE">1.2 SPI协议</h4> 
<p><strong>串行外设接口</strong>（Serial Peripheral Interface Bus，SPI），是一种用于芯片通信的<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5%E9%9B%BB%E8%B7%AF" rel="nofollow" title="同步">同步</a><a href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1" rel="nofollow" title="串行通信">串行通信</a>接口规范，主要应用于<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E7%BB%9F" rel="nofollow" title="单片机系统">单片机系统</a>中。类似<a href="https://zh.wikipedia.org/wiki/I%C2%B2C" rel="nofollow" title="I²C">I²C</a>。 这种接口首先由<a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E6%89%98%E7%BD%97%E6%8B%89%E5%85%AC%E5%8F%B8" rel="nofollow" title="摩托罗拉公司">摩托罗拉公司</a>于20世纪80年代中期开发，后发展成了行业规范。它的典型应用有<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%96%83%E8%A8%98%E6%86%B6%E9%AB%94" rel="nofollow" title="闪存">闪存</a><a href="https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97%E5%91%A8%E9%82%8A%E4%BB%8B%E9%9D%A2#cite_note-1" rel="nofollow" title="[1]">[1]</a><a href="https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97%E5%91%A8%E9%82%8A%E4%BB%8B%E9%9D%A2#cite_note-2" rel="nofollow" title="[2]">[2]</a>、<a href="https://zh.wikipedia.org/wiki/EEPROM" rel="nofollow" title="EEPROM">EEPROM</a>、<a href="https://zh.wikipedia.org/wiki/SD%E5%8D%A1" rel="nofollow" title="SD卡">SD卡</a>与<a href="https://zh.wikipedia.org/wiki/%E6%B6%B2%E6%99%B6%E6%98%BE%E7%A4%BA%E5%99%A8" rel="nofollow" title="液晶显示器">液晶显示器</a>。</p> 
<p>SPI设备之间使用<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E9%9B%99%E5%B7%A5" rel="nofollow" title="全双工">全双工</a>模式通信，是一个主机和一个或多个从机的<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F" rel="nofollow" title="主从模式">主从模式</a>。主机负责初始化<a href="https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%B8%A7&amp;action=edit&amp;redlink=1" rel="nofollow" title="帧">帧</a>，这个数据传输帧可以用于读与写两种操作，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%89%87%E9%80%89&amp;action=edit&amp;redlink=1" rel="nofollow" title="片选">片选</a>线路可以从多个从机选择一个来响应主机的请求。</p> 
<p>有时SPI接口被称作四线式接口，这是为了与其他不同线制的数据传输接口加以区分。SPI准确来讲应为“同步串行接口”，但是它又与<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5%E4%B8%B2%E8%A1%8C%E6%8E%A5%E5%8F%A3" rel="nofollow" title="同步串行接口">同步串行接口</a>协议（SSI）是完全不同的两种协议。虽然SSI也是一个四线式同步通信协议，但是它使用差分信号，而且仅提供一个单工通信信道。于此相对地，SPI是一个单主机多从机的通信接口。</p> 
<p>SPI是一种事实标准，也就是说这种规范没有对应的技术标准。因此各个厂家生产的SPI器件配置不一样，不一定有<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7" rel="nofollow" title="互操作性">互操作性</a>。</p> 
<p><img alt="" height="800" src="https://images2.imgbox.com/59/10/XtKd55td_o.png" width="1200"></p> 
<p><img alt="" height="532" src="https://images2.imgbox.com/ec/f3/JoybyUwW_o.png" width="671"></p> 
<h5 id="%E6%8E%A5%E5%8F%A3">接口</h5> 
<p>SPI总线规定了4个保留逻辑信号接口：</p> 
<ul><li>SCLK（Serial Clock）：串列时脉，由主机发出</li><li>MOSI（Master Output, Slave Input）：主机输出从机输入信号（数据由主机发出）</li><li>MISO（Master Input, Slave Output）：主机输入从机输出信号（数据由从机发出）</li><li>SS（Slave Select）：片选信号，由主机发出，一般是低电位有效</li></ul> 
<p>尽管上面的引脚名称是最常用的，但在过去，有时会使用其他引脚命名方式，因此旧的集成电路产品的SPI端口引脚名称可能有所不同。</p> 
<h5 id="%E4%BC%98%E7%82%B9">优点</h5> 
<ul><li>SPI协议默认是全双工通信。</li><li>与<a href="https://zh.wikipedia.org/wiki/%E6%BC%8F%E6%9E%81%E5%BC%80%E8%B7%AF" rel="nofollow" title="漏极开路">漏极开路</a>输出相反，SPI的<a href="https://zh.wikipedia.org/wiki/%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA" rel="nofollow" title="推挽输出">推挽输出</a>可提供良好的信号完整性和高速度</li><li>比<a href="https://zh.wikipedia.org/wiki/I%C2%B2C" rel="nofollow" title="I²C">I²C</a>或<a href="https://zh.wikipedia.org/wiki/SMBus" rel="nofollow" title="SMBus">SMBus</a>更高的传输带宽 。 不限于任何最大时钟频率，可实现高速运行</li><li>完整的传输位协议灵活性 
  <ul><li>不限于8位字</li><li>任意选择消息大小，内容和目的地</li></ul></li><li>简单的线路连接 
  <ul><li>由于电路较少（包括上拉电阻），因此通常比I²C或SMBus的功耗要低，</li><li>没有仲裁或相关的失败模式</li><li>从站与主机使用同一主频来源，不需要各自配置精密振荡器</li><li>从站不需要唯一的地址 - 不像<a href="https://zh.wikipedia.org/wiki/I%C2%B2C" rel="nofollow" title="I²C">I²C</a>或<a href="https://zh.wikipedia.org/wiki/GPIB" rel="nofollow" title="GPIB">GPIB</a>或<a href="https://zh.wikipedia.org/wiki/SCSI" rel="nofollow" title="SCSI">SCSI</a></li><li>不需要收发器</li></ul></li><li>IC封装只使用四个引脚，而电路板布局或连接器则少于并行接口</li><li>每个器件至多有一个独特的总线信号（芯片选择）;其他信号均可以共享</li><li>信号是单向的，允许简单的<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E6%B0%A3%E9%9A%94%E9%9B%A2" rel="nofollow" title="电气隔离">电气隔离</a></li><li>软件撰写简易</li></ul> 
<h5 id="%E7%BC%BA%E7%82%B9">缺点</h5> 
<ul><li>即使是三线式SPI，也需要比<a href="https://zh.wikipedia.org/wiki/I%C2%B2C" rel="nofollow" title="I²C">I²C</a>更多的IC线路</li><li>没有带内寻址; 共享总线上需要带外片选信号</li><li>从机不支持<a href="https://zh.wikipedia.org/w/index.php?title=%E6%B5%81%E6%8E%A7%E5%88%B6&amp;action=edit&amp;redlink=1" rel="nofollow" title="流控制">流控制</a> （但主机可以延迟下一个时钟边沿以降低传输速率）</li><li>不支持动态添加节点（<a href="https://zh.wikipedia.org/wiki/%E7%83%AD%E6%8F%92%E6%8B%94" rel="nofollow" title="热插拔">热插拔</a>）。 
  <ul><li>没有从机检测机制，主机无法检测是否与从机断开。</li></ul></li><li>通常只支持一个主设备（取决于设备的硬件实现）</li><li>没有错误检测机制，不像<a href="https://zh.wikipedia.org/wiki/I%C2%B2C" rel="nofollow" title="I²C">I²C</a>在每个字节后有回复信号</li><li>无法进行数据检验，不定义额外的协议时（如CRC）无法保证数据正确性。</li><li>与<a href="https://zh.wikipedia.org/wiki/RS-232" rel="nofollow" title="RS-232">RS-232</a> ， <a href="https://zh.wikipedia.org/wiki/RS-485" rel="nofollow" title="RS-485">RS-485</a>或CAN总线相比，它只能处理短距离内的数据传输。（距离可以通过使用收发器如RS-422进行扩展）</li><li>有许多现有的变体，使得很难找到支持这些变体的主机适配器等开发工具。 
  <ul><li>一些变体，如<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%8C%E8%B7%AFSPI&amp;action=edit&amp;redlink=1" rel="nofollow" title="双路SPI">双路SPI</a> ， <a href="https://zh.wikipedia.org/w/index.php?title=%E5%9B%9B%E8%B7%AFSPI&amp;action=edit&amp;redlink=1" rel="nofollow" title="四路SPI">四路SPI</a>和<a href="https://zh.wikipedia.org/w/index.php?title=%E4%B8%89%E7%BA%BFSPI&amp;action=edit&amp;redlink=1" rel="nofollow" title="三线SPI">三线SPI</a>是半双工的。</li></ul></li><li>必须通过<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%A6%E5%A4%96%E4%BF%A1%E5%8F%B7&amp;action=edit&amp;redlink=1" rel="nofollow" title="带外信号">带外信号</a>来实现中断，或者通过使用类似于USB 1.1和2.0的定期轮询来模拟中断</li></ul> 
<h5 id="%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93">数据传输</h5> 
<p>为了开始通信，总线上的主设备需要使用从设备支持的频率来配置时钟，这个频率最高为几兆赫兹左右。然后主设备将某个从设备的SS线置为低电平，来选中这个从设备。如果等待时间是必要的话（例如进行模数转换），主设备必须在这段时间结束后，才可以发出时钟周期讯号。</p> 
<p>在每个SPI时钟周期内，都会发生全双工数据传输。主设备在MOSI线上发送一个位，从设备读取它，同时从机在MISO线上发送一位数据，主机读取它。即使只有单向数据传输的目的，主从机之间的通信工作方式仍然是双工的。</p> 
<p><img alt="" height="1024" src="https://images2.imgbox.com/e3/59/mwPi60hf_o.png" width="1200">​</p> 
<p>两个连接成虚拟<a href="https://zh.wikipedia.org/wiki/%E7%92%B0%E5%BD%A2%E7%B7%A9%E8%A1%9D%E5%8D%80" rel="nofollow" title="环形缓冲器">环形缓冲器</a>的移位寄存器</p> 
<p>传输通常会使用给定字长的两个<a href="https://zh.wikipedia.org/wiki/%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8" rel="nofollow" title="移位寄存器">移位寄存器</a>，一个在主设备中，一个在从设备中，这两个寄存器连接成一个虚拟的<a href="https://zh.wikipedia.org/wiki/%E7%92%B0%E5%BD%A2%E7%B7%A9%E8%A1%9D%E5%8D%80" rel="nofollow" title="环形缓冲器">环形缓冲器</a>。数据通常先从最高位移出。在时钟讯号边沿，主机和从机均移出一位，然后在传输线上输出给对方。在下一个时钟沿，每个接收器都从传输线接受对方发出的数据位，并且从移位寄存器的最低位推入。每完成这样一个移出——推入的周期后，主机和从机就交换寄存器中的一位数据。当所有数据位都经过了这样的移出——推入过程后，主机和从机就完成了寄存器上的数据交换。如果需要交换的数据比寄存器的位数还要长的话，则需要重新加载移位寄存器并重复该过程。传输可能会持续任意数量的时钟周期。完成后，主设备会停止发送时钟讯号，并通常会取消选择从设备。</p> 
<p>传输寄存器通常包含8位。但是其他字长也很常见，例如触摸屏控制器或音频编解码器通常采用16位字长（如<a href="https://zh.wikipedia.org/wiki/%E5%BE%B7%E5%B7%9E%E4%BB%AA%E5%99%A8" rel="nofollow" title="德州仪器">德州仪器</a>的TSC2101），许多数模转换或者模数转换的设备则会采用12位字长。</p> 
<p>所有在总线上的没有被片选线激活的从设备必须忽略输入时钟和MOSI讯号，并且不得从MISO发送数据。</p> 
<h3 id="%E4%BA%8C%E3%80%81%E5%AE%9E%E6%88%98">二、实战</h3> 
<h4 id="2.1%20%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE"><a name="t4"></a>2.1 工程配置</h4> 
<p>打开cubeMX进行配置</p> 
<p><img alt="" height="832" src="https://images2.imgbox.com/73/a7/nDzxKvTh_o.png" width="1200">​</p> 
<p><img alt="" height="782" src="https://images2.imgbox.com/68/03/iLVOqdaQ_o.png" width="1200">​</p> 
<p>开启SPI1，我这里GPIO是根据板子上的接口来设定的，大家灵活配置即可。波特率我设置了3M的速率，实际上更高到12M也是没问题的，不过那样的话逻辑分析仪采集信号就会有损失，为了方便演示，笔者就16分频了。</p> 
<h4 id="2.2%20%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B">2.2 测试工程</h4> 
<p>打开生成的工程，添加测试代码</p> 
<p></p> 
<div> 
 <p><img alt="" height="273" src="https://images2.imgbox.com/bc/93/Qej6Q4NN_o.png" width="559">​</p> 
</div> 
<p>函数具体说明如下</p> 
<p><img alt="" height="243" src="https://images2.imgbox.com/0d/e2/i0KkDLnF_o.png" width="1091">​</p> 
<h4 id="2.3%20%E6%B3%A2%E5%BD%A2%E5%88%86%E6%9E%90">2.3 波形分析</h4> 
<p>使用逻辑分析仪查看波形如下</p> 
<p><img alt="" height="1199" src="https://images2.imgbox.com/9b/d2/veg55qNk_o.png" width="1200">​</p> 
<p>但是这仅仅有发送数据，没有设置CS，SC，RES引脚的电平</p> 
<h3 id="%E4%B8%89%E3%80%81%E9%A9%B1%E5%8A%A8OLED">三、驱动OLED</h3> 
<p>知道HAL库对SPI的发送过程后，阅读ssd1306的datasheet，进行驱动的编写</p> 
<p>使用器件需要对器件进行初始化，阅读手册进行配置即可</p> 
<p>其间用到一条重要的函数即</p> 
<p>void SSD1306_WriteByte(uint8_t dat,uint8_t cmd)；</p> 
<p>功能是通过SPI总线对ssd1306进行数据发送</p> 
<p>OLED通信过程如下</p> 
<p><img alt="" height="606" src="https://images2.imgbox.com/a8/33/Q8TTzBNu_o.png" width="1199">​</p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/e1/34/LHSOIvz3_o.png" width="1060">​</p> 
<p>当片选信号CS电平为低时器件被主机选中，由DC引脚控制发生的是命令还是数据</p> 
<p><span style="color:#fe2c24;"><strong>如果是数据则高电平，如果是指令则低电平.</strong></span></p> 
<pre><code class="language-cpp">void SSD1306_WriteByte(uint8_t dat,uint8_t cmd)
{
	uint8_t buffer[1];
	buffer[0]=dat;
	if(cmd==OLED_CMD)
	{
		HAL_GPIO_WritePin(DC_GPIO_Port,DC_Pin,GPIO_PIN_RESET);
		HAL_SPI_Transmit(&amp;hspi1,buffer,1,0xffff);
	}
	else if(cmd==OLED_DATA)
	{
		HAL_GPIO_WritePin(DC_GPIO_Port,DC_Pin,GPIO_PIN_SET);
		HAL_SPI_Transmit(&amp;hspi1,buffer,1,0xffff);
	}
}</code></pre> 
<p><strong>HAL_SPI_Transmit()函数一次发一个字节过去，参数cmd告知是数据还是指令，选择DC引脚的电平</strong></p> 
<p><img alt="" height="879" src="https://images2.imgbox.com/48/15/hfr161ul_o.png" width="1200"></p> 
<p>主要指令内容集中在这几章，整个datasheet约60页，开头为目录和介绍，末尾是封装信息。</p> 
<p>指令表中有<strong>基本指令，滚动指令，地址设置指令，硬件配置指令，时序及驱动指令</strong></p> 
<p>用到的为除滚动指令外的四个</p> 
<p><img alt="" height="473" src="https://images2.imgbox.com/76/db/1jJh34AL_o.png" width="892"></p> 
<p><img alt="" height="648" src="https://images2.imgbox.com/c3/10/55BFFjtb_o.png" width="901"></p> 
<p><img alt="" height="305" src="https://images2.imgbox.com/6b/83/0khzgq5Y_o.png" width="883"></p> 
<p><img alt="" height="668" src="https://images2.imgbox.com/a7/90/bpYcEDFm_o.png" width="912"></p> 
<p><strong>光看指令表会有些陌生，可以结合下面的描述来看</strong></p> 
<p class="img-center"><img alt="" height="487" src="https://images2.imgbox.com/d6/97/Xe1GRYcA_o.png" width="393"></p> 
<p></p> 
<p><img alt="" height="775" src="https://images2.imgbox.com/ce/85/YLUhRcjx_o.png" width="875"></p> 
<h4 id="%C2%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A3%E7%A0%81%20%E7%BC%96%E5%86%99%E5%A6%82%E4%B8%8B"><span style="color:#fe2c24;"><strong>3.1 初始化代码</strong></span></h4> 
<pre><code class="language-cpp">void OLED_Init()
{
	HAL_GPIO_WritePin(RES_GPIO_Port,RES_Pin,GPIO_PIN_RESET);
	HAL_Delay(100);
	HAL_GPIO_WritePin(RES_GPIO_Port,RES_Pin,GPIO_PIN_SET);
	SSD1306_WriteByte(0xAE,OLED_CMD); //display off
	
	SSD1306_WriteByte(0x20,OLED_CMD); //Set Memory Addressing Mode   
	SSD1306_WriteByte(0x10,OLED_CMD); //00,Horizontal Addressing Mode;01,Vertical Addressing Mode;10,Page Addressing Mode (RESET);11,Invalid
	
	SSD1306_WriteByte(0xB0,OLED_CMD); //Set Page Start Address for Page Addressing Mode,0-7
	
	SSD1306_WriteByte(0x00,OLED_CMD); //---set low column address
	SSD1306_WriteByte(0x10,OLED_CMD); //---set high column address
	
	SSD1306_WriteByte(0xC8,OLED_CMD); //Set COM Output Scan Direction

	SSD1306_WriteByte(0x40,OLED_CMD); //--set start line address
	
	SSD1306_WriteByte(0x81,OLED_CMD); //--set contrast control register
	SSD1306_WriteByte(0xff,OLED_CMD); //¶Ô±È¶ÈÉèÖÃ
	
	SSD1306_WriteByte(0xA1,OLED_CMD); //--set segment re-map 0 to 127
	SSD1306_WriteByte(0xC8,OLED_CMD); //--set segment re-map 0 to 127
	
	SSD1306_WriteByte(0xA6,OLED_CMD); //--set normal display
	
	SSD1306_WriteByte(0xA8,OLED_CMD); //--set multiplex ratio(1 to 64)
	SSD1306_WriteByte(0x3F,OLED_CMD); //
	
	SSD1306_WriteByte(0xA4,OLED_CMD); //0xa4,Output follows RAM content;0xa5,Output ignores RAM content
	
	SSD1306_WriteByte(0xD3,OLED_CMD); //-set display offset
	SSD1306_WriteByte(0x00,OLED_CMD); //-not offset
	
	SSD1306_WriteByte(0xD5,OLED_CMD); //--set display clock divide ratio/oscillator frequency
	SSD1306_WriteByte(0xF0,OLED_CMD); //--set divide ratio
	
	SSD1306_WriteByte(0xD9,OLED_CMD); //--set pre-charge period
	SSD1306_WriteByte(0x22,OLED_CMD); //
	
	SSD1306_WriteByte(0xDA,OLED_CMD); //--set com pins hardware configuration
	SSD1306_WriteByte(0x12,OLED_CMD);
	
	SSD1306_WriteByte(0xDB,OLED_CMD); //--set vcomh
	SSD1306_WriteByte(0x20,OLED_CMD); //0x20,0.77xVcc
	
	SSD1306_WriteByte(0x8D,OLED_CMD); //--set DC-DC enable
	SSD1306_WriteByte(0x14,OLED_CMD); //
	SSD1306_WriteByte(0xAF,OLED_CMD); //--turn on SSD1306 panel
}</code></pre> 
<p><strong> OLED_CMD使用宏定义，其值为0x00</strong></p> 
<p><img alt="" height="902" src="https://images2.imgbox.com/bb/48/MX4FLJPp_o.png" width="698"></p> 
<p>根据描述，第一步先设置地址模式为页地址模式，<strong><span style="color:#ff9900;">注意这个指令是双字节的，意思是发送0x20后要继续发送一个指令联合起来进行设置。根据手册，第二个指令为 0x10</span></strong></p> 
<p>然后设置列地址起始位置，由于屏幕横向有128个像素点，就有128列，手册将地址设置分成高四位地址设置和低四位地址设置，用两个指令来完成，分别是0x00~0x0F控制低四位，0x10~0x1F控制高四位，手册中的例子为低地址指令0x03，高地址为0x10，则最终列起始地址为0x03即SEG3</p> 
<p><span style="color:#fe2c24;">重要的指令为页起始地址设置指令，就是上面的0x10~0x1f和0x00~0x0f，实际上前者不能为0x1f，因为只有128列，显然f*16=240&gt;128</span></p> 
<h4 id="%E4%B8%8B%E9%9D%A2%E7%BC%96%E5%86%99%E6%B8%85%E5%B1%8F%E5%87%BD%E6%95%B0"><span style="color:#fe2c24;"><strong>3.2 清屏函数</strong></span></h4> 
<pre><code class="language-cpp">void OLED_Clear()
{
     uint8_t i,n;		    
	for(i=0;i&lt;8;i++)  
	{  
		SSD1306_WriteByte (0xb0+i,OLED_CMD);    //ÉèÖÃÒ³µØÖ·£¨0~7£©
		SSD1306_WriteByte (0x00,OLED_CMD);      //ÉèÖÃÏÔÊ¾Î»ÖÃ¡ªÁÐµÍµØÖ·
		SSD1306_WriteByte (0x10,OLED_CMD);      //ÉèÖÃÏÔÊ¾Î»ÖÃ¡ªÁÐ¸ßµØÖ·   
		for(n=0;n&lt;128;n++)
			SSD1306_WriteByte(0,OLED_DATA); //write 0x00;
	} //¸üÐÂÏÔÊ¾
}</code></pre> 
<p><span style="color:#7b7f82;"><em>外层循环8次，对应8个page，每个page由纵向8个像素，横向128列构成。设置页地址起始列为最左边即SEG0，将这128列都填充数据0x00，显示出来就是一片黑色</em></span></p> 
<h4 id="%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E6%98%AF%E8%AE%BE%E7%BD%AE%E5%9D%90%E6%A0%87%E5%87%BD%E6%95%B0"><span style="color:#fe2c24;"><strong>3.3 设置坐标函数</strong></span></h4> 
<pre><code class="language-cpp">void OLED_Set_Pos(unsigned char x, unsigned char y) 
{ 	
	SSD1306_WriteByte(0xb0+y,OLED_CMD);						//page y
	SSD1306_WriteByte(((x&amp;0xf0)&gt;&gt;4)|0x10,OLED_CMD);			//high 4 address
	SSD1306_WriteByte((x&amp;0x0f),OLED_CMD); 					//low 4 address
} </code></pre> 
<p><span style="color:#7b7f82;"><em>形参y设置page，范围为0到7，对应的指令为0xb0~0xb7。形参x设置起始页列地址，范围为0~127对应SEG0~SEG127。需要对x进行分块，分成高半字节和低半字节</em></span></p> 
<p>编写主函数代码如下</p> 
<p class="img-center"><img alt="" height="244" src="https://images2.imgbox.com/19/fa/Xe9HN5pX_o.png" width="500"></p> 
<p> OLED在左上角显示字符A，高度为8像素，宽为6像素，图中6行发送数据的函数将字符A的6列一一发送过去，且OLED的列指针会自动加一，因此不必反复设置列指针位置 </p> 
<p class="img-center"><img alt="" height="390" src="https://images2.imgbox.com/ca/38/pg5qGI9E_o.png" width="305"></p> 
<p> 当然，写成下面这样也是可以的</p> 
<p class="img-center"><img alt="" height="319" src="https://images2.imgbox.com/a7/14/2MvAokRX_o.png" width="438"></p> 
<p>这里会有一个疑问，就是这些数据是怎么得到的，总不会一个个去画吧。实际这是对A进行字体大小为8*6的取模得到的。网上有许多取模软件，一般会将ASCII码全部取出，并存放在一个数组中，需要用到时只需要发送对应行的数据</p> 
<p><img alt="" height="551" src="https://images2.imgbox.com/5f/60/ZQ43It1R_o.png" width="624"></p> 
<h4><span style="color:#fe2c24;">3.4显示字符函数</span></h4> 
<pre><code class="language-cpp">void OLED_ShowChar(uint8_t x,uint8_t y,uint8_t chr,uint8_t Char_Size)
{      	
	unsigned char c=0,i=0;	
		c=chr-' ';//得到偏移后的值			
		if(x&gt;Max_Column-1){x=0;y=y+2;}
		if(Char_Size ==16)
			{
				OLED_Set_Pos(x,y);	
				for(i=0;i&lt;8;i++)
				SSD1306_WriteByte(F8X16[c*16+i],OLED_DATA);
				OLED_Set_Pos(x,y+1);
				for(i=0;i&lt;8;i++)
				SSD1306_WriteByte(F8X16[c*16+i+8],OLED_DATA);
			}
		else 
			{	
				OLED_Set_Pos(x,y);
				for(i=0;i&lt;6;i++)
				SSD1306_WriteByte(F6x8[c][i],OLED_DATA);
			}
}</code></pre> 
<p><span style="color:#7b7f82;"><em>这个字符显示函数只有高8和高16两种大小的字符显示功能，其中显示高度为16像素的字符时，涉及到两页，需要将y+1。先将上半部分的8列写入再将下半部分8列写入。但是想写高为12，14，20等等的字体需要用另一种方法</em></span></p> 
<h4 id="3.5%20%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span style="color:#fe2c24;"><strong>3.5 显示字符串函数</strong></span></h4> 
<pre><code class="language-cpp">void OLED_ShowString(uint8_t x,uint8_t y,uint8_t *chr,uint8_t Char_Size)
{
	unsigned char j=0;
	while (chr[j]!='\0')
	{		OLED_ShowChar(x,y,chr[j],Char_Size);
			x+=8;
		if(x&gt;120){x=0;y+=2;}
			j++;
	}
}</code></pre> 
<p class="img-center"><img alt="" height="525" src="https://images2.imgbox.com/e2/37/FjI9wGTh_o.png" width="536"></p> 
<p>效果如下</p> 
<p class="img-center"><img alt="" height="410" src="https://images2.imgbox.com/b9/8b/qzjuKlmj_o.png" width="308"></p> 
<p><span style="color:#ff9900;"><strong>如果想显示数字的话，使用</strong></span><span style="color:#fe2c24;"><strong>sprintf</strong></span><span style="color:#ff9900;"><strong>函数进行转换为字符串，然后显示对应的字符串即可。</strong></span></p> 
<h4 id="%E7%BC%96%E5%86%99%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E5%87%BD%E6%95%B0"><span style="color:#fe2c24;"><strong>3.6 显示图片函数</strong></span></h4> 
<p>这里以经典的PCtoLCD2002为例</p> 
<p>取模设置如下</p> 
<p class="img-center"><img alt="" height="298" src="https://images2.imgbox.com/e1/ee/BEbhTCyY_o.png" width="477"></p> 
<p> 参考手册页地址模式</p> 
<p><img alt="" height="279" src="https://images2.imgbox.com/6e/f6/7BYXIE4w_o.png" width="872"></p> 
<p>选择低位在前，且为列行式，使用一维数组储存，右边格式前缀后缀稍作修改。</p> 
<p><strong>由于图片包含取模信息和图片的长度宽度，使用结构体进行定义 </strong></p> 
<pre><code class="language-cpp">typedef struct
{
	uint8_t xSize;
	uint8_t ySize;
	const unsigned char *p;
}BMP;</code></pre> 
<p>将这个声明放到oled.h中，因为oled.c有显示图片函数需要用到</p> 
<p>以这个苹果图片为例</p> 
<p><img alt="" height="346" src="https://images2.imgbox.com/de/cb/UheRDidn_o.png" width="327"><img alt="" height="352" src="https://images2.imgbox.com/fd/b5/4d7vSeMc_o.png" width="345"></p> 
<p> 将取好的图片模和字模放到一个.h文件中</p> 
<pre><code class="language-cpp">const unsigned char bmp_data[]=
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xC0,0xE0,0xE0,0xF0,0xF0,0xF8,0xF8,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFE,
0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x1F,0x1F,0x07,0x01,0x00,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,0xF8,0xF8,0xFC,0xFE,0xFE,0xFE,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xFE,0xFE,0xFC,0xFE,0xFC,0xFD,0xFD,
0xFD,0xFE,0xFE,0xFE,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFE,0xFC,0xFE,0xF8,0xF8,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xC0,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xBF,0x0F,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x04,0x1F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFC,0xF8,0xF8,0xE0,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0x3F,0x7F,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0x7F,0x1F,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x0F,0x0F,
0x1F,0x3F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x3F,0x3F,0x1F,0x1F,0x1F,0x1F,0x0F,
0x0F,0x1F,0x1F,0x1F,0x1F,0x3F,0x3F,0x3F,0x7F,0x7F,0x7F,0x7F,0x3F,0x3F,0x1F,0x1F,
0x0F,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"C:\Users\Tom\Desktop\1.bmp",0*/
};

BMP bmp=
{
	64,	//¿íÏñËØ
	64,	//¸ßÏñËØ
	bmp_data
};
</code></pre> 
<p>并将bmp用extern修饰</p> 
<pre><code class="language-cpp">extern BMP bmp;</code></pre> 
<p>显示函数如下</p> 
<pre><code class="language-cpp">void OLED_ShowPic(uint8_t x,uint8_t y,BMP bmp)
{
	uint8_t xsize=bmp.xSize;
	uint8_t ysize=bmp.ySize;
	OLED_Set_Pos(x,y);
	//如果像素高度不是8的倍数，则整除后加1补上
	if(ysize%8!=0)
		ysize=ysize+8;
	uint8_t i,j;
	for(i=0;i&lt;ysize/8;i++)
	{
		OLED_Set_Pos(x,y+i);
		for(j=0;j&lt;xsize;j++)
		SSD1306_WriteByte(*(bmp.p+i*xsize+j),OLED_DATA);
	}
}</code></pre> 
<p>主函数编写</p> 
<p class="img-center"><img alt="" height="561" src="https://images2.imgbox.com/f5/da/0EnaxxI3_o.png" width="458"></p> 
<pre><code class="language-cpp">OLED_Init();
OLED_Clear();
OLED_ShowPic(32,0,bmp);</code></pre> 
<p> 显示效果如下</p> 
<p class="img-center"><img alt="" height="696" src="https://images2.imgbox.com/28/bb/6D8okUIK_o.png" width="508"></p> 
<h3 id="%E9%99%84%E5%BD%95%20%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6">附录 驱动代码文件</h3> 
<h4 id="oled.c">oled.c</h4> 
<pre><code class="language-cpp">#include "oled.h"
#include "f6x8.h"

static  uint16_t AStrbuffer[STRING_LENTH];		//×Ö¿â×ª16½øÖÆÊý´æ·ÅÊý×é
static  uint16_t Strbuffer[STRING_LENTH];		//´ýÏÔÊ¾×Ö·û´®×ª16½øÖÆÊý´æ·ÅÊý×é
static uint16_t Alen=0;		//×Ö¿â×Ö·û´®³¤¶È£¬ÖµÎª×Ö¿â°üº¬ºº×ÖÊý*2
static uint16_t len=0;		//ÒªÏÔÊ¾µÄ×Ö·û´®µÄ³¤¶È£¬ÖµÎª×Ö¿â°üº¬ºº×ÖÊý*2
static HZ* hz;				//×Ö¿âÖ¸Õë

static uint8_t xsize;		//ºº×ÖµÄ¿í¶È
static uint8_t ysize;		//ºº×ÖµÄ¸ß¶È

void SSD1306_WriteByte(uint8_t dat,uint8_t cmd)
{
	uint8_t buffer[1];
	buffer[0]=dat;
	if(cmd==OLED_CMD)
	{
		HAL_GPIO_WritePin(DC_GPIO_Port,DC_Pin,GPIO_PIN_RESET);
		HAL_SPI_Transmit(&amp;hspi1,buffer,1,0xffff);
		//HAL_GPIO_WritePin(DC_GPIO_Port,DC_Pin,GPIO_PIN_SET);
	}
	else if(cmd==OLED_DATA)
	{
		HAL_GPIO_WritePin(DC_GPIO_Port,DC_Pin,GPIO_PIN_SET);
		HAL_SPI_Transmit(&amp;hspi1,buffer,1,0xffff);
		//HAL_GPIO_WritePin(DC_GPIO_Port,DC_Pin,GPIO_PIN_SET);
	}
}

void OLED_Clear()
{
     uint8_t i,n;		    
	for(i=0;i&lt;8;i++)  
	{  
		SSD1306_WriteByte (0xb0+i,OLED_CMD);    //ÉèÖÃÒ³µØÖ·£¨0~7£©
		SSD1306_WriteByte (0x00,OLED_CMD);      //ÉèÖÃÏÔÊ¾Î»ÖÃ¡ªÁÐµÍµØÖ·
		SSD1306_WriteByte (0x10,OLED_CMD);      //ÉèÖÃÏÔÊ¾Î»ÖÃ¡ªÁÐ¸ßµØÖ·   
		for(n=0;n&lt;128;n++)
			SSD1306_WriteByte(0,OLED_DATA); //write 0x00;
	} //¸üÐÂÏÔÊ¾
}
void OLED_Init()
{
	HAL_GPIO_WritePin(RES_GPIO_Port,RES_Pin,GPIO_PIN_RESET);
	HAL_Delay(100);
	HAL_GPIO_WritePin(RES_GPIO_Port,RES_Pin,GPIO_PIN_SET);
	SSD1306_WriteByte(0xAE,OLED_CMD); //display off
	
	SSD1306_WriteByte(0x20,OLED_CMD); //Set Memory Addressing Mode   
	SSD1306_WriteByte(0x10,OLED_CMD); //00,Horizontal Addressing Mode;01,Vertical Addressing Mode;10,Page Addressing Mode (RESET);11,Invalid
	
	SSD1306_WriteByte(0xB0,OLED_CMD); //Set Page Start Address for Page Addressing Mode,0-7
	
	SSD1306_WriteByte(0x00,OLED_CMD); //---set low column address
	SSD1306_WriteByte(0x10,OLED_CMD); //---set high column address
	
	SSD1306_WriteByte(0xC8,OLED_CMD); //Set COM Output Scan Direction

	SSD1306_WriteByte(0x40,OLED_CMD); //--set start line address
	
	SSD1306_WriteByte(0x81,OLED_CMD); //--set contrast control register
	SSD1306_WriteByte(0xff,OLED_CMD); //¶Ô±È¶ÈÉèÖÃ
	
	SSD1306_WriteByte(0xA1,OLED_CMD); //--set segment re-map 0 to 127
	SSD1306_WriteByte(0xC8,OLED_CMD); //--set segment re-map 0 to 127
	
	SSD1306_WriteByte(0xA6,OLED_CMD); //--set normal display
	
	SSD1306_WriteByte(0xA8,OLED_CMD); //--set multiplex ratio(1 to 64)
	SSD1306_WriteByte(0x3F,OLED_CMD); //
	
	SSD1306_WriteByte(0xA4,OLED_CMD); //0xa4,Output follows RAM content;0xa5,Output ignores RAM content
	
	SSD1306_WriteByte(0xD3,OLED_CMD); //-set display offset
	SSD1306_WriteByte(0x00,OLED_CMD); //-not offset
	
	SSD1306_WriteByte(0xD5,OLED_CMD); //--set display clock divide ratio/oscillator frequency
	SSD1306_WriteByte(0xF0,OLED_CMD); //--set divide ratio
	
	SSD1306_WriteByte(0xD9,OLED_CMD); //--set pre-charge period
	SSD1306_WriteByte(0x22,OLED_CMD); //
	
	SSD1306_WriteByte(0xDA,OLED_CMD); //--set com pins hardware configuration
	SSD1306_WriteByte(0x12,OLED_CMD);
	
	SSD1306_WriteByte(0xDB,OLED_CMD); //--set vcomh
	SSD1306_WriteByte(0x20,OLED_CMD); //0x20,0.77xVcc
	
	SSD1306_WriteByte(0x8D,OLED_CMD); //--set DC-DC enable
	SSD1306_WriteByte(0x14,OLED_CMD); //
	SSD1306_WriteByte(0xAF,OLED_CMD); //--turn on SSD1306 panel
}



void OLED_Set_Pos(unsigned char x, unsigned char y) 
{ 	
	SSD1306_WriteByte(0xb0+y,OLED_CMD);						//page y
	SSD1306_WriteByte(((x&amp;0xf0)&gt;&gt;4)|0x10,OLED_CMD);			//high 4 address
	SSD1306_WriteByte((x&amp;0x0f),OLED_CMD); 					//low 4 address
} 


void OLED_ShowChar(uint8_t x,uint8_t y,uint8_t chr,uint8_t Char_Size)
{      	
	unsigned char c=0,i=0;	
		c=chr-' ';//µÃµ½Æ«ÒÆºóµÄÖµ			
		if(x&gt;Max_Column-1){x=0;y=y+2;}
		if(Char_Size ==16)
			{
				OLED_Set_Pos(x,y);	
				for(i=0;i&lt;8;i++)
				SSD1306_WriteByte(F8X16[c*16+i],OLED_DATA);
				OLED_Set_Pos(x,y+1);
				for(i=0;i&lt;8;i++)
				SSD1306_WriteByte(F8X16[c*16+i+8],OLED_DATA);
			}
		else 
			{	
				OLED_Set_Pos(x,y);
				for(i=0;i&lt;6;i++)
				SSD1306_WriteByte(F6x8[c][i],OLED_DATA);
			}
}
void OLED_ShowString(uint8_t x,uint8_t y,uint8_t *chr,uint8_t Char_Size)
{
	unsigned char j=0;
	while (chr[j]!='\0')
	{		OLED_ShowChar(x,y,chr[j],Char_Size);
			x+=8;
		if(x&gt;120){x=0;y+=2;}
			j++;
	}
}
void OLED_ShowPic(uint8_t x,uint8_t y,BMP bmp)
{
	uint8_t xsizeb=bmp.xSize;
	uint8_t ysizeb=bmp.ySize;
	OLED_Set_Pos(x,y);
	//Èç¹ûÏñËØ¸ß¶È²»ÊÇ8µÄ±¶Êý£¬ÔòÕû³ýºó²¹ÉÏ
	if(ysizeb%8!=0)
		ysizeb=ysizeb/8*8+8;
	uint8_t i,j;
	for(i=0;i&lt;ysizeb/8;i++)
	{
		OLED_Set_Pos(x,y+i);
		for(j=0;j&lt;xsizeb;j++)
		SSD1306_WriteByte(*(bmp.p+i*xsizeb+j),OLED_DATA);
	}
}

/**
½«×Ö¿â×Ö·û´®×ªÎª16½øÖÆÊý²¢´æÈëÈ«¾ÖÊý×é
*/
void AStrtoHex(char* c)
{
	uint16_t i;
	
	for(i=0;i&lt;STRING_LENTH;i=i+1)		//Çå¿ÕÊý×éÄÚÈÝ
	{
		AStrbuffer[i]=0;
	}
	
	Alen=0;
	char*p=c;
	while(*(p++)!='\0')
		Alen++;

	
	uint16_t tmp=0;
	p=c;
	for(i=0;i&lt;Alen;i=i+2)
	{
		tmp=((uint16_t)(*(p+i)))&lt;&lt;8;
		tmp=tmp|(uint16_t)*(p+i+1);
		AStrbuffer[i/2]=tmp;
	}
}
/**
½«´ýÏÔÊ¾×Ö·û´®×ªÎª16½øÖÆÊý²¢´æÈëÈ«¾ÖÊý×é
*/
void StrtoHex(char* c)
{
	uint16_t i;
	for(i=0;i&lt;STRING_LENTH;i=i+1)		//Çå¿ÕÊý×éÄÚÈÝ
	{
		Strbuffer[i]=0;
	}
	char*p=c;
	len=0;
	while(*(p++)!='\0')
		len++;

	
	uint16_t tmp=0;
	p=c;
	for(i=0;i&lt;len;i=i+2)
	{
		tmp=((uint16_t)(*(p+i)))&lt;&lt;8;
		tmp=tmp|(uint16_t)*(p+i+1);
		Strbuffer[i/2]=tmp;
	}
}
/**
ÉèÖÃ×ÖÌå
*/
void OLED_SetFont(HZ *hz1)
{
	hz=hz1;
	xsize=hz-&gt;xSize;
	ysize=hz-&gt;ySize;
	if(ysize%8!=0)		//Èç¹ûÏñËØ¸ß¶È²»ÊÇ8µÄ±¶Êý£¬ÔòÕû³ýºó²¹ÉÏ
		ysize=ysize/8*8+8;
}
/**
ÏÔÊ¾×Ö·û´®
*/
void OLED_ShowHZ(uint8_t x,uint8_t y, char* str)
{
	uint16_t i,j,k,index=0;

	
	AStrtoHex(hz-&gt;Astr);		//--&gt;AStrbuffer[]  AlenÖµÎª×Ö¿â°üº¬ºº×ÖÊý*2
	StrtoHex(str);			//--&gt;Strbuffer[]   lenÖµÎªÏÔÊ¾º¯ÊýÖÐ×Ö·û´®°üº¬ºº×ÖÊý*2
	uint16_t a=0;
	//ÒªÏÔÊ¾µÄÖÐÎÄ×Ö·û´®ÓÐ¼¸¸öºº×Ö¾ÍÑ­»·¼¸´Î
	for(a=0;a&lt;len/2;a++)
	{
		for(i=0;i&lt;Alen/2;i++)
		{
			if(Strbuffer[a]==AStrbuffer[i])
			{
				index=i;		//·Ö±ðÕÒ³öÃ¿¸öºº×ÖÔÚ×Ö·û´®ÄÚµÄÎ»ÖÃ
				break;
			}

		}
			for(j=0;j&lt;ysize/8;j++)
			{
				OLED_Set_Pos(x+a*xsize,y+j);		//ÏÔÊ¾ÍêÒ»¸öºº×Öºó×ø±êÒÆ¶¯
				for(k=0;k&lt;xsize;k++)
				SSD1306_WriteByte(*(hz-&gt;p +  k +j*xsize+ index*xsize*ysize/8),OLED_DATA);//ÏÔÊ¾indexÖ¸ÏòµÄÄÇ¸öºº×Ö
			}
	}
}




</code></pre> 
<h4 id="oled.h">oled.h</h4> 
<pre><code class="language-cpp">#ifndef OLED_H
#define OLED_H
#include "main.h"                  // Device header
#include "spi.h"


#define OLED_CMD  0X00 //Ð´ÃüÁî
#define OLED_DATA 0X40 //Ð´Êý¾Ý

#define SSD1306_I2C_ADDR         0x78
#define SSD1306_WIDTH            128
#define SSD1306_HEIGHT           6

#define SIZE 16
#define XLevelL		0x02
#define XLevelH		0x10
#define Max_Column	128
#define Max_Row		64
#define	Brightness	0xFF 
#define X_WIDTH 	128
#define Y_WIDTH 	64

#define STRING_LENTH 50
typedef struct
{
	uint8_t xSize;
	uint8_t ySize;
	const unsigned char *p;
}BMP;
typedef struct
{
	uint8_t xSize;			//×ÖÌå¿í¶È
	uint8_t ySize;			//×ÖÌå¸ß¶È
	const char *Astr;		//×Ö¿âËù°üº¬×ÖÄ£°´Ë³ÐòµÄ×Ö·û´®
	const unsigned char *p;	//×ÖÄ£Êý×éÖ¸Õë
}HZ;

void SSD1306_WriteByte(uint8_t dat,uint8_t cmd);
void OLED_Set_Pos(unsigned char x, unsigned char y) ;
void OLED_Init();
void OLED_Clear();
void OLED_ShowChar(uint8_t x,uint8_t y,uint8_t chr,uint8_t Char_Size);
void OLED_ShowString(uint8_t x,uint8_t y,uint8_t *chr,uint8_t Char_Size);
void OLED_ShowPic(uint8_t x,uint8_t y,BMP bmp);
void OLED_ShowHZ(uint8_t x,uint8_t y,char* str);
void OLED_SetFont(HZ *hz1);

#endif</code></pre> 
<h4 id="%C2%A0f6x8.h">f6x8.h</h4> 
<pre><code class="language-cpp">#ifndef __OLEDFONT_H__
#define __OLEDFONT_H__   
#include "oled.h"

//³£ÓÃASCII±í
//Æ«ÒÆÁ¿32
//ASCII×Ö·û¼¯
//Æ«ÒÆÁ¿32
//´óÐ¡:12*6
/************************************6*8µÄµãÕó************************************/
const unsigned char  F6x8[][6] =		
{
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,// sp
0x00, 0x00, 0x00, 0x2f, 0x00, 0x00,// !
0x00, 0x00, 0x07, 0x00, 0x07, 0x00,// "
0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14,// #
0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12,// $
0x00, 0x62, 0x64, 0x08, 0x13, 0x23,// %
0x00, 0x36, 0x49, 0x55, 0x22, 0x50,// &amp;
0x00, 0x00, 0x05, 0x03, 0x00, 0x00,// '
0x00, 0x00, 0x1c, 0x22, 0x41, 0x00,// (
0x00, 0x00, 0x41, 0x22, 0x1c, 0x00,// )
0x00, 0x14, 0x08, 0x3E, 0x08, 0x14,// *
0x00, 0x08, 0x08, 0x3E, 0x08, 0x08,// +
0x00, 0x00, 0x00, 0xA0, 0x60, 0x00,// ,
0x00, 0x08, 0x08, 0x08, 0x08, 0x08,// -
0x00, 0x00, 0x60, 0x60, 0x00, 0x00,// .
0x00, 0x20, 0x10, 0x08, 0x04, 0x02,// /
0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E,// 0
0x00, 0x00, 0x42, 0x7F, 0x40, 0x00,// 1
0x00, 0x42, 0x61, 0x51, 0x49, 0x46,// 2
0x00, 0x21, 0x41, 0x45, 0x4B, 0x31,// 3
0x00, 0x18, 0x14, 0x12, 0x7F, 0x10,// 4
0x00, 0x27, 0x45, 0x45, 0x45, 0x39,// 5
0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30,// 6
0x00, 0x01, 0x71, 0x09, 0x05, 0x03,// 7
0x00, 0x36, 0x49, 0x49, 0x49, 0x36,// 8
0x00, 0x06, 0x49, 0x49, 0x29, 0x1E,// 9
0x00, 0x00, 0x36, 0x36, 0x00, 0x00,// :
0x00, 0x00, 0x56, 0x36, 0x00, 0x00,// ;
0x00, 0x08, 0x14, 0x22, 0x41, 0x00,// &lt;
0x00, 0x14, 0x14, 0x14, 0x14, 0x14,// =
0x00, 0x00, 0x41, 0x22, 0x14, 0x08,// &gt;
0x00, 0x02, 0x01, 0x51, 0x09, 0x06,// ?
0x00, 0x32, 0x49, 0x59, 0x51, 0x3E,// @
0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C,// A
0x00, 0x7F, 0x49, 0x49, 0x49, 0x36,// B
0x00, 0x3E, 0x41, 0x41, 0x41, 0x22,// C
0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C,// D
0x00, 0x7F, 0x49, 0x49, 0x49, 0x41,// E
0x00, 0x7F, 0x09, 0x09, 0x09, 0x01,// F
0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A,// G
0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F,// H
0x00, 0x00, 0x41, 0x7F, 0x41, 0x00,// I
0x00, 0x20, 0x40, 0x41, 0x3F, 0x01,// J
0x00, 0x7F, 0x08, 0x14, 0x22, 0x41,// K
0x00, 0x7F, 0x40, 0x40, 0x40, 0x40,// L
0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F,// M
0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F,// N
0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E,// O
0x00, 0x7F, 0x09, 0x09, 0x09, 0x06,// P
0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E,// Q
0x00, 0x7F, 0x09, 0x19, 0x29, 0x46,// R
0x00, 0x46, 0x49, 0x49, 0x49, 0x31,// S
0x00, 0x01, 0x01, 0x7F, 0x01, 0x01,// T
0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F,// U
0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F,// V
0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F,// W
0x00, 0x63, 0x14, 0x08, 0x14, 0x63,// X
0x00, 0x07, 0x08, 0x70, 0x08, 0x07,// Y
0x00, 0x61, 0x51, 0x49, 0x45, 0x43,// Z
0x00, 0x00, 0x7F, 0x41, 0x41, 0x00,// [
0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55,// 55
0x00, 0x00, 0x41, 0x41, 0x7F, 0x00,// ]
0x00, 0x04, 0x02, 0x01, 0x02, 0x04,// ^
0x00, 0x40, 0x40, 0x40, 0x40, 0x40,// _
0x00, 0x00, 0x01, 0x02, 0x04, 0x00,// '
0x00, 0x20, 0x54, 0x54, 0x54, 0x78,// a
0x00, 0x7F, 0x48, 0x44, 0x44, 0x38,// b
0x00, 0x38, 0x44, 0x44, 0x44, 0x20,// c
0x00, 0x38, 0x44, 0x44, 0x48, 0x7F,// d
0x00, 0x38, 0x54, 0x54, 0x54, 0x18,// e
0x00, 0x08, 0x7E, 0x09, 0x01, 0x02,// f
0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C,// g
0x00, 0x7F, 0x08, 0x04, 0x04, 0x78,// h
0x00, 0x00, 0x44, 0x7D, 0x40, 0x00,// i
0x00, 0x40, 0x80, 0x84, 0x7D, 0x00,// j
0x00, 0x7F, 0x10, 0x28, 0x44, 0x00,// k
0x00, 0x00, 0x41, 0x7F, 0x40, 0x00,// l
0x00, 0x7C, 0x04, 0x18, 0x04, 0x78,// m
0x00, 0x7C, 0x08, 0x04, 0x04, 0x78,// n
0x00, 0x38, 0x44, 0x44, 0x44, 0x38,// o
0x00, 0xFC, 0x24, 0x24, 0x24, 0x18,// p
0x00, 0x18, 0x24, 0x24, 0x18, 0xFC,// q
0x00, 0x7C, 0x08, 0x04, 0x04, 0x08,// r
0x00, 0x48, 0x54, 0x54, 0x54, 0x20,// s
0x00, 0x04, 0x3F, 0x44, 0x40, 0x20,// t
0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C,// u
0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C,// v
0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C,// w
0x00, 0x44, 0x28, 0x10, 0x28, 0x44,// x
0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C,// y
0x00, 0x44, 0x64, 0x54, 0x4C, 0x44,// z
0x14, 0x14, 0x14, 0x14, 0x14, 0x14,// horiz lines
};
/****************************************8*16µÄµãÕó************************************/
const unsigned char  F8X16[]=	  
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// 0
  0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,//! 1
  0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//" 2
  0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,//# 3
  0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,//$ 4
  0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,//% 5
  0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,//&amp; 6
  0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//' 7
  0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,//( 8
  0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,//) 9
  0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,//* 10
  0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,//+ 11
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,//, 12
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,//- 13
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,//. 14
  0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,/// 15
  0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,//0 16
  0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//1 17
  0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,//2 18
  0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,//3 19
  0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,//4 20
  0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,//5 21
  0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,//6 22
  0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,//7 23
  0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,//8 24
  0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,//9 25
  0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,//: 26
  0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,//; 27
  0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,//&lt; 28
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,//= 29
  0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,//&gt; 30
  0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,//? 31
  0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,//@ 32
  0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,//A 33
  0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,//B 34
  0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,//C 35
  0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,//D 36
  0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,//E 37
  0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,//F 38
  0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,//G 39
  0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,//H 40
  0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//I 41
  0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,//J 42
  0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,//K 43
  0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,//L 44
  0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,//M 45
  0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,//N 46
  0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,//O 47
  0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,//P 48
  0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,//Q 49
  0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,//R 50
  0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,//S 51
  0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//T 52
  0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//U 53
  0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,//V 54
  0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,//W 55
  0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,//X 56
  0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//Y 57
  0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,//Z 58
  0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,//[ 59
  0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,//\ 60
  0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,//] 61
  0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//^ 62
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,//_ 63
  0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//` 64
  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,//a 65
  0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,//b 66
  0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,//c 67
  0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,//d 68
  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,//e 69
  0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//f 70
  0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,//g 71
  0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//h 72
  0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//i 73
  0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,//j 74
  0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,//k 75
  0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//l 76
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,//m 77
  0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//n 78
  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//o 79
  0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,//p 80
  0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,//q 81
  0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,//r 82
  0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,//s 83
  0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,//t 84
  0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,//u 85
  0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,//v 86
  0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,//w 87
  0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,//x 88
  0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,//y 89
  0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,//z 90
  0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,//{ 91
  0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,//| 92
  0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,//} 93
  0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//~ 94
};





#endif


</code></pre> 
<p>使用时主函数只需要包含oled.h即可</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/630bb985f7302b0adbf2b9761c7b75b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android12 ROM定制导读</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d351891f94abf2d739dfff3be60917c8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot多数据源集成</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>