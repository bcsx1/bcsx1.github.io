<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C3P0数据库连接池的解析 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C3P0数据库连接池的解析" />
<meta property="og:description" content="文章目录 一、 Basic Pool Configuration (基础配置项)二、Managing Pool Size and Connection Age （管理连接池大小和连接寿命）三、Configuring Connection Testing（配置连接测试）四、Configuring Statement Pooling五、Configuring Recovery From Database Outages（从数据库中断恢复配置项）六、Configuring Unresolved Transaction Handling[![Go To Top](https://img-blog.csdnimg.cn/img_convert/559514564b425b8a2d8d410f07ccb293.png)](https://www.mchange.com/projects/c3p0/#contents)七、Configuring to Debug and Workaround Broken Client Applications[[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-q6948Dkg-1655893008212)(https://www.mchange.com/projects/c3p0/arrow_sm.png)]](https://www.mchange.com/projects/c3p0/#contents)八、Configuring To Avoid Memory Leaks On Hot Redeploy Of Clients[![Go To Top](https://img-blog.csdnimg.cn/img_convert/559514564b425b8a2d8d410f07ccb293.png)](https://www.mchange.com/projects/c3p0/#contents)九、Other DataSource Configuration[![Go To Top](https://img-blog.csdnimg.cn/img_convert/559514564b425b8a2d8d410f07ccb293.png)](https://www.mchange.com/projects/c3p0/#contents)十、Configuring Logging 十一、附录A Appendix A: Configuration Properties[[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vvz8DFQk-1655893008216)(https://www.mchange.com/projects/c3p0/arrow_sm.png)]](https://www.mchange.com/projects/c3p0/#contents)JavaBeans-style Properties[[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9TAOXV1H-1655893008217)(https://www.mchange.com/projects/c3p0/arrow_sm.png)]](https://www.mchange.com/projects/c3p0/#contents) 十二、网络闪断c3p0线程堵塞解决方法 一、 Basic Pool Configuration (基础配置项) c3p0 Connection pools are very easy to configure via the following basic parameters:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/9022bf22efb56d2dec0b9ff66d750823/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-23T10:15:42+08:00" />
<meta property="article:modified_time" content="2022-06-23T10:15:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C3P0数据库连接池的解析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#_Basic_Pool_Configuration__1" rel="nofollow">一、 Basic Pool Configuration (基础配置项)</a></li><li><a href="#Managing_Pool_Size_and_Connection_Age__25" rel="nofollow">二、Managing Pool Size and Connection Age （管理连接池大小和连接寿命）</a></li><li><a href="#Configuring_Connection_Testing_39" rel="nofollow">三、Configuring Connection Testing（配置连接测试）</a></li><li><a href="#Configuring_Statement_Pooling_105" rel="nofollow">四、Configuring Statement Pooling</a></li><li><a href="#Configuring_Recovery_From_Database_Outages_125" rel="nofollow">五、Configuring Recovery From Database Outages（从数据库中断恢复配置项）</a></li><li><a href="#Configuring_Unresolved_Transaction_HandlingGo_To_Tophttpsimgblogcsdnimgcnimg_convert559514564b425b8a2d8d410f07ccb293pnghttpswwwmchangecomprojectsc3p0contents_139" rel="nofollow">六、Configuring Unresolved Transaction Handling[![Go To Top](https://img-blog.csdnimg.cn/img_convert/559514564b425b8a2d8d410f07ccb293.png)](https://www.mchange.com/projects/c3p0/#contents)</a></li><li><a href="#Configuring_to_Debug_and_Workaround_Broken_Client_Applicationsimgq6948Dkg1655893008212httpswwwmchangecomprojectsc3p0arrow_smpnghttpswwwmchangecomprojectsc3p0contents_150" rel="nofollow">七、Configuring to Debug and Workaround Broken Client Applications[[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-q6948Dkg-1655893008212)(https://www.mchange.com/projects/c3p0/arrow_sm.png)]](https://www.mchange.com/projects/c3p0/#contents)</a></li><li><a href="#Configuring_To_Avoid_Memory_Leaks_On_Hot_Redeploy_Of_ClientsGo_To_Tophttpsimgblogcsdnimgcnimg_convert559514564b425b8a2d8d410f07ccb293pnghttpswwwmchangecomprojectsc3p0contents_173" rel="nofollow">八、Configuring To Avoid Memory Leaks On Hot Redeploy Of Clients[![Go To Top](https://img-blog.csdnimg.cn/img_convert/559514564b425b8a2d8d410f07ccb293.png)](https://www.mchange.com/projects/c3p0/#contents)</a></li><li><a href="#Other_DataSource_ConfigurationGo_To_Tophttpsimgblogcsdnimgcnimg_convert559514564b425b8a2d8d410f07ccb293pnghttpswwwmchangecomprojectsc3p0contents_186" rel="nofollow">九、Other DataSource Configuration[![Go To Top](https://img-blog.csdnimg.cn/img_convert/559514564b425b8a2d8d410f07ccb293.png)](https://www.mchange.com/projects/c3p0/#contents)</a></li><li><a href="#Configuring_Logging_202" rel="nofollow">十、Configuring Logging</a></li></ul> 
   </li><li><a href="#A_Appendix_A_Configuration_Propertiesimgvvz8DFQk1655893008216httpswwwmchangecomprojectsc3p0arrow_smpnghttpswwwmchangecomprojectsc3p0contents_260" rel="nofollow">十一、附录A Appendix A: Configuration Properties[[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vvz8DFQk-1655893008216)(https://www.mchange.com/projects/c3p0/arrow_sm.png)]](https://www.mchange.com/projects/c3p0/#contents)</a></li><li><ul><li><a href="#JavaBeansstyle_Propertiesimg9TAOXV1H1655893008217httpswwwmchangecomprojectsc3p0arrow_smpnghttpswwwmchangecomprojectsc3p0contents_264" rel="nofollow">JavaBeans-style Properties[[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9TAOXV1H-1655893008217)(https://www.mchange.com/projects/c3p0/arrow_sm.png)]](https://www.mchange.com/projects/c3p0/#contents)</a></li></ul> 
   </li><li><a href="#c3p0_534" rel="nofollow">十二、网络闪断c3p0线程堵塞解决方法</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="_Basic_Pool_Configuration__1"></a>一、 Basic Pool Configuration (基础配置项)</h4> 
<p>c3p0 Connection pools are very easy to configure via the following basic parameters:</p> 
<ul><li><a href="https://www.mchange.com/projects/c3p0/#acquireIncrement" rel="nofollow">acquireIncrement</a></li><li><a href="https://www.mchange.com/projects/c3p0/#initialPoolSize" rel="nofollow">initialPoolSize</a></li><li><a href="https://www.mchange.com/projects/c3p0/#maxPoolSize" rel="nofollow">maxPoolSize</a></li><li><a href="https://www.mchange.com/projects/c3p0/#maxIdleTime" rel="nofollow">maxIdleTime</a></li><li><a href="https://www.mchange.com/projects/c3p0/#minPoolSize" rel="nofollow">minPoolSize</a></li></ul> 
<p><code>initialPoolSize</code>, <code>minPoolSize</code>, <code>maxPoolSize</code> define the number of Connections that will be pooled. Please ensure that <code>minPoolSize &lt;= maxPoolSize</code>. Unreasonable values of <code>initialPoolSize</code> will be ignored, and <code>minPoolSize</code> will be used instead.<font color="red">（一旦<code>initialPoolSize</code> 设置的不合理，<code>minPoolSize</code>会去替代它）</font></p> 
<p>Within the range between <code>minPoolSize</code> and <code>maxPoolSize</code>, the number of Connections in a pool varies according to usage patterns. The number of Connections increases whenever a Connection is requested by a user, no Connections are available, and the pool has not yet reached <code>maxPoolSize</code> in the number of Connections managed.<font color="red">（使用连接的数量会增加，知道达到<code>maxPoolSize</code>）</font></p> 
<p>Since Connection acquisition is very slow, it is almost always useful to increase the number of Connections eagerly, in batches, rather than forcing each client to wait for a new Connection to provoke a single acquisition when the load is increasing. <code>acquireIncrement</code> determines how many Connections a c3p0 pool will attempt to acquire when the pool has run out of Connections. (Regardless of <code>acquireIncrement</code>, the pool will never allow <code>maxPoolSize</code> to be exceeded.)</p> 
<p><font color="red">（批量创建连接的数量<code>acquireIncrement</code>）</font></p> 
<p>The number of Connections in a pool decreases whenever a pool tests a Connection and finds it to be broken (see <a href="https://www.mchange.com/projects/c3p0/#configuring_connection_testing" rel="nofollow">Configuring Connection Testing</a> below), or when a Connection is expired by the pool after sitting idle for a period of time, or for being too old (See <a href="https://www.mchange.com/projects/c3p0/#managing_pool_size" rel="nofollow">Managing Pool Size and Connection Age</a>.)</p> 
<p><font color="red">（池中连接数减少原因，1. 池连接测试发现连接已经broken，这个可以通过连接测试配置项进行配置。 2. 池中连接已经expired，在空闲周期检查的时候发现，3. 连接已经too old，个人认为，这个连接创建的时间太长了）</font></p> 
<h4><a id="Managing_Pool_Size_and_Connection_Age__25"></a>二、Managing Pool Size and Connection Age （管理连接池大小和连接寿命）</h4> 
<p>Different applications have different needs with regard to trade-offs between performance, footprint, and reliability. <font color="red">（不同的应用程序在权衡性能、占用空间和可靠性方面有不同的需求）</font>C3P0 offers a wide variety of options for controlling how quickly pools that have grown large under load revert to <code>minPoolSize</code>, and whether “old” Connections in the pool should be proactively replaced to maintain their reliablity.<font color="red">（C3P0提供了各种各样的选项来控制在负载下增长较大的池恢复到minPoolSize的速度，以及是否应该主动替换池中的“旧”连接以保持其可靠性。）</font></p> 
<ul><li><a href="https://www.mchange.com/projects/c3p0/#maxConnectionAge" rel="nofollow">maxConnectionAge</a></li><li><a href="https://www.mchange.com/projects/c3p0/#maxIdleTime" rel="nofollow">maxIdleTime</a></li><li><a href="https://www.mchange.com/projects/c3p0/#maxIdleTimeExcessConnections" rel="nofollow">maxIdleTimeExcessConnections</a></li></ul> 
<p>By default, pools will never expire Connections. If you wish Connections to be expired over time in order to maintain “freshness”, set <code>maxIdleTime</code> and/or <code>maxConnectionAge</code>. <code>maxIdleTime</code> defines how many seconds a Connection should be permitted to go unused before being culled from the pool. <code>maxConnectionAge</code> forces the pool to cull any Connections that were acquired from the database more than the set number of seconds in the past.<font color="red">默认情况下，池永远不会使连接过期。如果你希望连接随时间过期以保持“新鲜度”，设置maxIdleTime或者maxConnectionAge。maxIdleTime定义了一个连接在未被使用的情况下可以维持的秒数。maxConnectionAge强制池剔除超过设置时间的所有连接。</font></p> 
<p><code>maxIdleTimeExcessConnections</code> is about minimizing the number of Connections held by c3p0 pools when the pool is not under load. By default, c3p0 pools grow under load, but only shrink if Connections fail a Connection test or are expired away via the parameters described above. Some users want their pools to quickly release unnecessary Connections after a spike in usage that forces a large pool size. You can achieve this by setting <code>maxIdleTimeExcessConnections</code> to a value much shorter than <code>maxIdleTime</code>, forcing Connections beyond your set minimum size to be released if they sit idle for more than a short period of time.<font color="red"><code>maxIdleTimeExcessConnections</code>是关于最小化c3p0池在无负载剔除连接的时间。默认情况下，c3p0池的连接在有并发负载的情况下才会增长，但只有在连接测试失败或通过上述参数过期时才会减少连接。一些用户希望他们的池在使用高峰后迅速释放不必要的连接。你可以通过设置<code>maxIdleTimeExcessConnections</code>为比<code>maxIdleTime</code>短得多的值来实现这一点，如果空闲时间超过设置的最小大小，则强制释放超出设置的最小值的连接</font></p> 
<p>Some general advice about all of these timeout parameters: Slow down! The point of Connection pooling is to bear the cost of acquiring a Connection only once, and then to reuse the Connection many, many times. Most databases support Connections that remain open for hours at a time. There’s no need to churn through all your Connections every few seconds or minutes. Setting <code>maxConnectionAge</code> or <code>maxIdleTime</code> to 1800 (30 minutes) is quite aggressive. For most databases, several hours may be more appropriate. You can ensure the reliability of your Connections by testing them, rather than by tossing them. (see <a href="https://www.mchange.com/projects/c3p0/#configuring_connection_testing" rel="nofollow">Configuring Connection Testing</a>.) The only one of these parameters that should generally be set to a few minutes or less is <code>maxIdleTimeExcessConnections</code>.<font color="red">关于所有这些超时参数的一些一般性建议:仔细想想，连接池的意义在于只承担一次获取连接的成本，然后重用连接很多很多次。大多数数据库支持数据库连接被打开几个小时。所以就没有必要每隔几秒或几分钟就翻遍所有的连接。将<code>maxConnectionAge</code>或<code>maxIdleTime</code>设置为1800(30分钟)是相当激进的。对于大多数数据库，几个小时可能更合适。您可以通过测试来确保连接的可靠性，而不是通过丢弃连接，强调通过测试来判定连接是否应该释放掉</font></p> 
<h4><a id="Configuring_Connection_Testing_39"></a>三、Configuring Connection Testing（配置连接测试）</h4> 
<p>c3p0 can be configured to test the Connections that it pools in a variety of ways, to minimize the likelihood that your application will see broken or “stale” Connections.<font color="red">C3P0有很多种配置方式来剔除坏链接和无效连接</font>。 Pooled Connections can go bad for a variety of reasons – some JDBC drivers intentionally “time-out” long-lasting database Connections; back-end databases or networks sometimes go down “stranding” pooled Connections; and Connections can simply become corrupted over time and use due to resource leaks, driver bugs, or other causes. <font color="red">连接池可能会因为各种原因而变坏，比如说，1.一些JDBC驱动程序故意让长期存在的数据库连接“超时”;2. 后端数据库或网络有时会“搁浅”池连接;3. 或者随着时间的推移，由于资源泄漏、驱动程序bug或其他原因，连接可能会被损坏。</font></p> 
<p>c3p0 provides users a great deal of flexibility in testing Connections, via the following configuration parameters:</p> 
<ul><li><a href="https://www.mchange.com/projects/c3p0/#automaticTestTable" rel="nofollow">automaticTestTable</a></li><li><a href="https://www.mchange.com/projects/c3p0/#connectionTesterClassName" rel="nofollow">connectionTesterClassName</a></li><li><a href="https://www.mchange.com/projects/c3p0/#idleConnectionTestPeriod" rel="nofollow">idleConnectionTestPeriod</a></li><li><a href="https://www.mchange.com/projects/c3p0/#preferredTestQuery" rel="nofollow">preferredTestQuery</a></li><li><a href="https://www.mchange.com/projects/c3p0/#testConnectionOnCheckin" rel="nofollow">testConnectionOnCheckin</a></li><li><a href="https://www.mchange.com/projects/c3p0/#testConnectionOnCheckout" rel="nofollow">testConnectionOnCheckout</a></li></ul> 
<p><code>idleConnectionTestPeriod</code>, <code>testConnectionOnCheckout</code>, and <code>testConnectionOnCheckin</code> control when Connections will be tested.<font color="red">这三个参数是控制什么时候连接被测试的，空闲周期测试，取出时测试，归还时测试</font>。 <code>automaticTestTable</code>, <code>connectionTesterClassName</code>, and <code>preferredTestQuery</code> control how they will be tested. <font color="red">这三个参数是控制怎么测试的</font>。</p> 
<p>When configuring Connection testing, first try to minimize the cost of each test. If you are using a JDBC driver that you are certain supports the new(ish) jdbc4 API — and if you are using c3p0-0.9.5 or higher! — let your driver handle this for you. jdbc4 Connections include a method called <code>isValid()</code> that should be implemented as a fast, reliable Connection test. By default, c3p0 will use that method if it is present.<font color="red">为了控制测试成本，可以确认一下你的数据库驱动是否是JDBC4的API，而且您使用C3P0的版本高于或等于c3p0-0.9.5！可以使用驱动来直接进行测试，使用连接API <code>isValid()</code>，其实C3P0也是默认使用这个接口来检查连接的有效性</font>。</p> 
<p>However, if your driver does not support this new-ish API, c3p0’s default behavior is to test Connections by calling the <code>getTables()</code> method on a Connection’s associated <code>DatabaseMetaData</code> object. This has the advantage of being very robust and working with any database, regardless of the database schema. However, a call to <code>DatabaseMetaData.getTables()</code> is often much slower than a simple database query, and using this test may significantly impair your pool’s performance.<font color="red">但是，如果你的驱动程序不支持这个新的API, c3p0的默认行为是通过调用一个连接的相关<code>DatabaseMetaData</code>对象的<code>getTables()</code>方法来测试连接。这样做的优点是非常健壮，可以使用任何数据库，而不用考虑数据库模式。但是，对<code>DatabaseMetaData.getTables()</code>的调用通常比简单的数据库查询要慢得多，并且使用此测试可能会显著降低池的性能</font>。</p> 
<p>The simplest way to speed up Connection testing under a JDBC 3 driver (or a pre-0.9.5 version of c3p0) is to define a test query with the <code>preferredTestQuery</code> parameter. Be careful, however. Setting <code>preferredTestQuery</code> will lead to errors as Connection tests fail if the query target table does not exist in your database <em>prior to initialization of your DataSource</em>. Depending on your database and JDBC driver, a table-independent query like <code>SELECT 1</code> may (or may not) be sufficient to verify the Connection. If a table-independent query is not sufficient, instead of <code>preferredTestQuery</code>, you can set the parameter <code>automaticTestTable</code>. Using the name you provide, c3p0 will create an empty table, and make a simple query against it to test the database. <font color="red">在JDBC 3驱动程序(或c3p0的0.9.5以前版本)下加快Connection测试的最简单方法是使用<code>preferredTestQuery</code> 参数定义一个测试查询。然而,要注意。设置preferredTestQuery将会导致错误，因为如果在DataSource初始化之前，数据库中不存在查询目标表，则连接测试将失败。根据数据库和JDBC驱动程序的不同，像<code>SELECT 1</code>这样与表无关的查询可能(也可能不)足以验证Connection。如果表无关的查询还不够，可以设置参数 <code>automaticTestTable</code>，而不是<code>preferredTestQuery</code>。使用您提供的名称，c3p0将创建一个空表，并对其进行简单查询以测试数据库</font>。</p> 
<p>The most reliable time to test Connections is on check-out. But this is also the most costly choice from a client-performance perspective. Most applications should work quite reliably using a combination of <code>idleConnectionTestPeriod</code> and <code>testConnectionOnCheckin</code>. Both the idle test and the check-in test are performed asynchronously, which can lead to better performance, both perceived and actual.<font color="red">测试Connections最可靠的时间是在checkout时。但从客户端性能的角度来看，这也是成本最高的选择。大多数应用程序应该使用<code>idleConnectionTestPeriod</code>和<code>testConnectionOnCheckin</code>的组合非常可靠地工作。空闲测试和签入测试都是异步执行的，这可以带来更好的性能，无论是感知上的还是实际上的</font></p> 
<p>For some applications, high performance is more important than the risk of an occasional database exception. In its default configuration, c3p0 does no Connection testing at all. Setting a fairly long <code>idleConnectionTestPeriod</code>, and not testing on checkout and check-in at all is an excellent, high-performance approach.<font color="red">对于某些应用程序，高性能比偶尔发生数据库异常的风险更重要。在默认配置中，c3p0根本不进行连接测试。设置一个相当长时间的<code>idleConnectionTestPeriod</code>，并且完全不测试签出和签入是一种优秀的高性能方法。</font></p> 
<p>It is possible to customize how c3p0’s <code>DefaultConnectionTester</code> tests when no <code>preferredTestQuery</code> or <code>automaticTestTable</code> are available. Please see <a href="https://www.mchange.com/projects/c3p0/#configuring_dctivt" rel="nofollow">Configuring DefaultConnectionTester.isValidTimeout</a> and <a href="https://www.mchange.com/projects/c3p0/#configuring_dctqtr" rel="nofollow">Configuring DefaultConnectionTester.QuerylessTestRunner</a>. <font color="red">当没有preferredTestQuery或automaticTestTable可用时，可以定制c3p0的DefaultConnectionTester测试方式</font></p> 
<p>Advanced users may define any kind of Connection testing they wish, by implementing a <a href="https://www.mchange.com/projects/c3p0/apidocs/com/mchange/v2/c3p0/ConnectionTester.html" rel="nofollow">ConnectionTester</a> and supplying the fully qualified name of the class as <code>connectionTesterClassName</code>. If you’d like your custom ConnectionTesters to honor and support the <code>preferredTestQuery</code> and <code>automaticTestTable</code> parameters, implement <a href="https://www.mchange.com/projects/c3p0/apidocs/com/mchange/v2/c3p0/UnifiedConnectionTester.html" rel="nofollow">UnifiedConnectionTester</a>, most conveniently by extending <a href="https://www.mchange.com/projects/c3p0/apidocs/com/mchange/v2/c3p0/AbstractConnectionTester.html" rel="nofollow">AbstractConnectionTester</a>. See the <a href="https://www.mchange.com/projects/c3p0/apidocs/index.html" rel="nofollow">api docs</a> for more information.</p> 
<p><font color="red">高级用户可以通过实现 <a href="https://www.mchange.com/projects/c3p0/apidocs/com/mchange/v2/c3p0/ConnectionTester.html" rel="nofollow">ConnectionTester</a> 接口并提供类的完全限定名称<code>connectionTesterClassName</code>来定义他们想要的任何类型的连接测试。如果您希望您的自定义connectiontester尊重并支持preferredTestQuery和automaticTestTable参数，那么通过扩展AbstractConnectionTester最方便地实现UnifiedConnectionTester。</font></p> 
<p>If you know you want to use the jdbc4 <code>Connection.isValid()</code> method, but you want to set a timeout, consider writing a trivial extension of <a href="https://www.mchange.com/projects/c3p0/apidocs/com/mchange/v2/c3p0/util/IsValidOnlyConnectionTester.html" rel="nofollow">IsValidConnectionTester</a>. <font color="red">如果您知道您想使用jdbc4 <code>Connection.isValid()</code>方法，但是您想设置超时，那么可以考虑编写一个简单的 <a href="https://www.mchange.com/projects/c3p0/apidocs/com/mchange/v2/c3p0/util/IsValidOnlyConnectionTester.html" rel="nofollow">IsValidConnectionTester</a>扩展。</font></p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>mchange<span class="token punctuation">.</span>v2<span class="token punctuation">.</span>c3p0<span class="token punctuation">.</span>example</span><span class="token punctuation">;</span> 
<span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>mchange<span class="token punctuation">.</span>v2<span class="token punctuation">.</span>c3p0<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">IsValidOnlyConnectionTester</span><span class="token punctuation">;</span> 
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">IsValidOnlyConnectionTester30</span> <span class="token keyword">extends</span> <span class="token class-name">IsValidOnlyConnectionTester</span> <span class="token punctuation">{<!-- --></span>    
<span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">getIsValidTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
  <span class="token punctuation">{<!-- --></span> 
    <span class="token keyword">return</span> <span class="token number">30</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>     
</code></pre> 
<p>Simple advice on Connection testing</p> 
<ol><li> <p>If you know your driver supports the JDBC 4 <code>Connection.isValid(...)</code> method and you are using c3p0-0.9.5 or above, don’t set a <code>preferredTestQuery</code>. If your driver does not support this method (or if you are not sure), try <code>**SELECT 1**</code> for your <code>preferredTestQuery</code>, if you are running MySQL or Postgres. For other databases, look for <a href="http://stackoverflow.com/questions/3668506/efficient-sql-test-query-or-validation-query-that-will-work-across-all-or-most" rel="nofollow">suggestions here</a>. Leave <code>automatedTestTable</code> undefined.<font color="red">如果您的驱动支持JDBC 4 <code>Connection.isValid(...)</code>，而且您是使用c3p0-0.9.5或者以上的版本，就不用设置 <code>preferredTestQuery</code>参数了。但是如果您不确认，或者您的驱动不支持，您可以设置参数<code>preferredTestQuery</code>，或者收您是使用 MySQL or Postgres。如果是使用其他的数据库类型，查阅一下<a href="http://stackoverflow.com/questions/3668506/efficient-sql-test-query-or-validation-query-that-will-work-across-all-or-most" rel="nofollow">suggestions here</a>。且参数<code>automatedTestTable</code> 未定义.</font></p> </li><li> <p>Begin by setting <code>testConnectionOnCheckout</code> to <code>true</code> and get your application to run correctly and stably. If you are happy with your application’s performance, <em>you can stop here!</em> This is the simplest, most reliable form of Connection-testing, but it does have a client-visible performance cost.<font color="red"> 设置参数<code>testConnectionOnCheckout</code>的值为<code>true</code> 而且让您的应用程序正确而稳定地运行，如果满意当前您应用的性能表现，那就这样设置，这是最简单的，最有效的连接测试，但是他会导致应用程序的访问性能下降，毕竟每次获取连接都要执行一次测试</font></p> </li><li> <p>If you’d like to improve performance by eliminating Connection testing from clients’ code path:</p> <p>a. Set <code>testConnectionOnCheckout</code> to <code>false</code></p> <p>b. Set <code>testConnectionOnCheckin</code> to <code>true</code></p> <p>c. Set <code>idleConnectionTestPeriod</code> to <code>30</code>, fire up you application and observe. This is a pretty robust setting, all Connections will tested on check-in and every 30 seconds thereafter while in the pool. Your application should experience broken or stale Connections only very rarely, and the pool should recover from a database shutdown and restart quickly. But there is some overhead associated with all that Connection testing.<font color="red">需要启动应用并进行观察，这是一个非常健壮的设置，所有连接将在签入时测试，此后在池中每30秒测试一次。您的应用程序很少会遇到连接中断或失效的情况，数据库池应该在数据库关闭后恢复并快速重启。但是所有的连接测试都有一些开销。</font></p> <p>d. If database restarts will be rare so quick recovery is not an issue, consider reducing the frequency of tests by <code>idleConnectionTestPeriod</code> to, say, <code>300</code>, and see whether clients are troubled by stale or broken Connections. If not, stick with <code>300</code>, or try an even bigger number. Consider setting <code>testConnectionOnCheckin</code> back to false to avoid unnecessary tests on checkin. Alternatively, if your application does encounter bad Connections, consider reducing <code>idleConnectionTestPeriod</code> and set <code>testConnectionOnCheckin</code> back to <code>true</code>. There are no correct or incorrect values for these parameters: you are trading off overhead for reliability in deciding how frequently to test. The exact numbers are not so critical. It’s usually easy to find configurations that perform well. It’s rarely worth spending time in pursuit of “optimal” values here.<font color="red">如果您的数据库很少重启，那么快速恢复就不是一个关键问题，那么考虑将idleConnectionTestPeriod的测试频率降低到(比方说)300，并查看客户机是否受到陈旧或中断的连接的困扰。如果没有，那就坚持300，或者尝试一个更大的数字。考虑将testConnectionOnCheckin设置为false，以避免对签入进行不必要的测试。或者，如果你的应用程序遇到坏的连接，考虑减少idleConnectionTestPeriod并将testConnectionOnCheckin设置为true。这些参数没有绝对正确或绝对不正确的值，因此在决定测试频率时，您要权衡开销和可靠性。具体数字并不那么关键。通常很容易找到性能良好的配置。在这里，花时间去追求“最佳”值是不值得的。</font></p> </li></ol> 
<p>So, when should you stick with simple and reliable (Step 2 above), and when is it worth going for better performance (Step 3)? In general, it depends on how much work clients typically do with Connections once they check them out. If clients usually make complex queries and/or perform multiple operations, adding the extra cost of one fast test per checkout will not much affect performance. But if your application typically checks out a Connection and performs one simple query with it, throwing in an additional test can really slow things down.<font color="red">那么，什么时候应该坚持简单可靠(上面的第2步)，什么时候值得追求更好的性能(第3步)?一般来说，这取决于客户端在签出Connections后通常使用Connections做多少工作。如果客户端通常执行复杂的查询和/或多个操作，那么增加每次签出一次快速测试的额外成本不会对性能造成太大影响。但是，如果您的应用程序通常检出一个Connection并使用它执行一个简单的查询，那么添加额外的测试确实会降低速度。</font></p> 
<p>That’s nice in theory, but often people don’t really have a good sense of how much work clients perform on average. The best thing to do is usually to try Step 3, see if it helps (however you measure performance), see if it hurts (is your application troubled by broken Connections? does it recover from database restarts well enough?), and then decide. You can always go back to simple, slow, and robust. Just set testConnectionOnCheckout to true, testConnectionOnCheckin to false, and set idleConnectionTestPeriod to 0. <font color="red">这在理论上是不错的，但通常人们并不真正清楚客户平均完成多少工作。最好的做法通常是尝试步骤3，看看它是否有帮助(无论您如何衡量性能)，看看它是否有害(您的应用程序是否受到连接中断的困扰?从数据库重新启动恢复是否足够好?)，然后决定。你总是可以回到简单、缓慢和强健的状态。只需将testConnectionOnCheckout设置为true, testConnectionOnCheckin设置为false，并将idleConnectionTestPeriod设置为0。</font></p> 
<p><em>But do, always, be sure that your tests themselves are performant, either because your JDBC driver supports</em> <code>Connection.isValid(...)</code> <em>or because you have set an efficient</em> <code>preferredTestQuery</code> <em>!!!</em><font color="red">但是，一定要确保您的测试本身是有效果的，或者您的JDBC驱动程序支持Connection.isValid(…)，或者因为您设置了一个有效的preferredTestQuery !!。</font></p> 
<h4><a id="Configuring_Statement_Pooling_105"></a>四、Configuring Statement Pooling</h4> 
<p>c3p0 implements transparent PreparedStatement pooling as defined by the JDBC spec. Under some circumstances, statement pooling can dramatically improve application performance. Under other circumstances, the overhead of statement pooling can slightly harm performance. Whether and how much statement pooling will help depends on how much parsing, planning, and optimizing of queries your databases does when the statements are prepared. Databases (and JDBC drivers) vary widely in this respect. It’s a good idea to benchmark your application with and without statement pooling to see if and how much it helps.<font color="red">c3p0实现了JDBC规范定义的透明PreparedStatement池。在某些情况下，语句池可以显著提高应用程序的性能。在其他情况下，语句池的开销可能会略微损害性能。语句池是否有帮助以及有多大帮助，取决于准备语句时数据库对查询的解析、规划和优化程度。数据库(和JDBC驱动程序)在这方面差别很大。对使用和不使用语句池的应用程序进行基准测试是一个好主意，看看它是否有帮助以及有多大帮助。</font></p> 
<p>You configure statement pooling in c3p0 via the following configuration parameters:</p> 
<ul><li><a href="https://www.mchange.com/projects/c3p0/#maxStatements" rel="nofollow">maxStatements</a></li><li><a href="https://www.mchange.com/projects/c3p0/#maxStatementsPerConnection" rel="nofollow">maxStatementsPerConnection</a></li><li><a href="https://www.mchange.com/projects/c3p0/#statementCacheNumDeferredCloseThreads" rel="nofollow">statementCacheNumDeferredCloseThreads</a></li></ul> 
<p><code>maxStatements</code> is JDBC’s standard parameter for controlling statement pooling. <code>maxStatements</code> defines the total number <code>PreparedStatements</code> a DataSource will cache. The pool will destroy the least-recently-used PreparedStatement when it hits this limit. This sounds simple, but it’s actually a strange approach, because cached statements conceptually belong to individual Connections; they are not global resources. To figure out a size for <code>maxStatements</code> that does not “churn” cached statements, you need to consider the number of <em>frequently used</em> PreparedStatements in your application, and multiply that by the number of Connections you expect in the pool (<code>maxPoolSize</code> in a busy application).<font color="red"><code>maxStatements </code>是JDBC控制语句池的标准参数。<code>maxStatements</code>定义了数据源将缓存的<code>PreparedStatements</code>的总数。当达到这个限制时，池将销毁最近最少使用的PreparedStatement。这听起来很简单，但实际上是一种奇怪的方法，因为缓存语句在概念上属于各个连接;它们不是全局资源。要计算出不“占用”缓存语句的<code>maxStatements</code>的大小，你需要考虑应用程序中<em>频繁使用</em> preparedstatement的数量，并将其乘以池中预期的连接数(繁忙应用程序中的<code>maxPoolSize</code>)。</font></p> 
<p><code>maxStatementsPerConnection</code> is a non-standard configuration parameter that makes a bit more sense conceptually. It defines how many statements each pooled Connection is allowed to own. You can set this to a bit more than the number of <code>PreparedStatements</code> your application <em>frequently</em> uses, to avoid churning.<font color="red"><code>maxStatementsPerConnection</code>是一个非标准配置参数，它在概念上更有意义。它定义了每个连接池允许拥有多少条语句。您可以将其设置为比应用程序经常使用的<code>preparedstatement</code>数量多一点，以避免重复使用。</font></p> 
<p>If either of these parameters are greater than zero, statement pooling will be enabled. If both parameters are greater than zero, both limits will be enforced. If only one is greater than zero, statement pooling will be enabled, but only one limit will be enforced.</p> 
<p><font color="red">如果这些参数中的任何一个大于零，则将启用语句池。如果两个参数都大于零，则两个限制都将执行。如果只有一个大于0，则将启用语句池，但只执行一个限制。</font></p> 
<p>If <code>statementCacheNumDeferredCloseThreads</code> is greater than zero, the Statement pool will defer physically close()ing cached Statements until its parent Connection is not in use by any client or internally (in e.g. a test) by the pool itself. For some JDBC drivers (especially Oracle), attempts to close a Statement freeze if the parent Connection is in use. This parameter defaults to 0. Set it to a positive value if you observe “APPARENT DEADLOCKS” realted to Connection close tasks. Almost always, that value should be one: if you need more than one Thread dedicated solely to Statement destruction, you probably should set <code>maxStatements</code> and/or <code>maxStatementsPerConnection</code> to higher values so you don’t churn through cached Statements so quickly.<font color="red">如果statementCacheNumDeferredCloseThreads大于0，语句池将物理上延迟关闭()缓存语句，直到父连接没有被任何客户端使用，或者池本身内部(例如测试)没有使用。对于某些JDBC驱动程序(尤其是Oracle)，如果父连接正在使用，则尝试关闭Statement冻结。该参数默认为0。如果观察到与连接关闭任务相关的 “APPARENT DEADLOCKS”，则将其设置为正值。基本上，这个值应该是1:如果您需要多个线程专门用于语句销毁，您可能应该将maxStatements和/或maxStatementsPerConnection设置为更高的值，这样您就不会这么快地使用缓存的语句。</font></p> 
<h4><a id="Configuring_Recovery_From_Database_Outages_125"></a>五、Configuring Recovery From Database Outages（从数据库中断恢复配置项）</h4> 
<p>c3p0 DataSources are designed (and configured by default) to recover from temporary database outages, such as those which occur during a database restart or brief loss of network connectivity. You can affect how c3p0 handles errors in acquiring Connections via the following configurable properties:<font color="red">c3p0数据源被设计(并在默认情况下配置)用于从临时数据库中断中恢复，例如在数据库重启或网络连接短暂中断期间发生的中断。你可以通过以下可配置属性来影响c3p0如何处理获取连接时的错误:</font></p> 
<ul><li><a href="https://www.mchange.com/projects/c3p0/#acquireRetryAttempts" rel="nofollow">acquireRetryAttempts</a></li><li><a href="https://www.mchange.com/projects/c3p0/#acquireRetryDelay" rel="nofollow">acquireRetryDelay</a></li><li><a href="https://www.mchange.com/projects/c3p0/#breakAfterAcquireFailure" rel="nofollow">breakAfterAcquireFailure</a></li></ul> 
<p>When a c3p0 DataSource attempts and fails to acquire a Connection, it will retry up to <code>acquireRetryAttempts</code> times, with a delay of <code>acquireRetryDelay</code> between each attempt. If all attempts fail, any clients waiting for Connections from the DataSource will see an Exception, indicating that a Connection could not be acquired. Note that clients do not see any Exception until a full round of attempts fail, which may be some time after the initial Connection attempt. If <code>acquireRetryAttempts</code> is set to 0, c3p0 will attempt to acquire new Connections indefinitely, and calls to <code>getConnection()</code> may block indefinitely waiting for a successful acquisition.<font color="red">当c3p0数据源尝试获取连接失败时，它将重试到<code>acquireRetryAttempts</code>次，每次尝试之间的延迟为<code>acquireRetryDelay</code>。如果所有尝试都失败，任何等待来自数据源的连接的客户端将看到一个Exception，表明无法获得连接。请注意，客户端在整个尝试失败之前不会看到任何异常，这可能是在初始连接尝试之后的一段时间。如果<code>acquireRetryAttempts</code>设置为0,c3p0将尝试无限地获取新的连接，并且调用’<code>getConnection() </code>可能会无限地阻塞，直至成功的获取连接。</font></p> 
<p>Once a full round of acquisition attempts fails, there are two possible policies. By default, the c3p0 DataSource will remain active, and will try again to acquire Connections in response to future requests for Connections. If you set <code>breakAfterAcquireFailure</code> to <code>true</code>, the DataSource will consider itself broken after a failed round of Connection attempts, and future client requests will fail immediately.<font color="red">一旦一轮尝试失败，有两种可能的策略。默认情况下，c3p0数据源将保持活动状态，并将再次尝试获取连接，以响应未来的连接请求。但是如果您将<code>breakAfterAcquireFailure</code>设置为’<code>true </code>，那么数据源将在连接尝试失败一轮后认为自己已经中断，并且以后的客户端请求也将立即失败。</font></p> 
<p>Note that if a database restart occurs, a pool may contain previously acquired but now stale Connections. By default, these stale Connections will only be detected and purged lazily, when an application attempts to use them, and sees an Exception. Setting <code>maxIdleTime</code> or <code>maxConnectionAge</code> can help speed up the replacement of broken Connections. (See <a href="https://www.mchange.com/projects/c3p0/#managing_pool_size" rel="nofollow">Managing ConnectionAge</a>.) If you wish to avoid application Exceptions entirely, you must adopt a connection testing strategy that is likely to detect stale Connections prior to their delivery to clients. (See “<a href="https://www.mchange.com/projects/c3p0/#configuring_connection_testing" rel="nofollow">Configuring Connection Testing</a>”.) Even with active Connection testing (<code>testConnectionOnCheckout</code> set to <code>true</code>, or <code>testConnectionOnCheckin</code> and a short <code>idleConnectionTestPeriod</code>), your application may see occasional Exceptions on database restart, for example if the restart occurs after a Connection to the database has already been checked out.<font color="red">注意，如果数据库重新启动，池中可能包含以前获取但现在失效的连接。默认情况下，只有当应用程序试图使用这些陈旧的连接并看到一个Exception时，才会惰性地检测和清除这些连接。设置<code>maxIdleTime </code>或<code>maxConnectionAge </code>可以帮助加速替换坏掉的连接。(见[管理ConnectionAge] (https://www.mchange.com/projects/c3p0/ managing_pool_size))。如果希望完全避免应用程序异常，则必须采用连接测试策略，该策略可能会在交付给客户端之前检测失效的连接。(请参阅“<a href="https://www.mchange.com/projects/c3p0/#configuring_connection_testing" rel="nofollow">配置连接测试</a>”。)即使活动连接测试(<code>testConnectionOnCheckout</code>设置为“真正的”,或<code>testConnectionOnCheckin</code>和一个简短的<code>idleConnectionTestPeriod</code>),对数据库重新启动您的应用程序可能会看到偶尔例外,例如,如果重启后出现数据库连接已被检出。</font></p> 
<h4><a id="Configuring_Unresolved_Transaction_HandlingGo_To_Tophttpsimgblogcsdnimgcnimg_convert559514564b425b8a2d8d410f07ccb293pnghttpswwwmchangecomprojectsc3p0contents_139"></a>六、Configuring Unresolved Transaction Handling<a href="https://www.mchange.com/projects/c3p0/#contents" rel="nofollow"><img src="https://images2.imgbox.com/d5/c4/qBxCLWUM_o.png" alt="Go To Top"></a></h4> 
<p>Connections checked into a pool cannot have any unresolved transactional work associated with them. If users have set <code>autoCommit</code> to <code>false</code> on a Connection, and c3p0 cannot guarantee that there is no pending transactional work, c3p0 must either <code>rollback()</code> or <code>commit()</code> on check-in (when a user calls <code>close()</code>). The JDBC spec is (unforgivably) silent on the question of whether unresolved work should be committed or rolled back on Connection close. By default, c3p0 rolls back unresolved transactional work when a user calls <code>close()</code>.</p> 
<p>You can adjust this behavior via the following configuration properties:</p> 
<ul><li><a href="https://www.mchange.com/projects/c3p0/#autoCommitOnClose" rel="nofollow">autoCommitOnClose</a></li><li><a href="https://www.mchange.com/projects/c3p0/#forceIgnoreUnresolvedTransactions" rel="nofollow">forceIgnoreUnresolvedTransactions</a></li></ul> 
<p>If you wish c3p0 to allow unresolved transactional work to commit on checkin, set <code>autoCommitOnClose</code> to true. If you wish c3p0 to leave transaction management to you, and neither commit nor rollback (nor modify the state of Connection <code>autoCommit</code>), you may set <code>forceIgnoreUnresolvedTransactions</code> to true. Setting <code>forceIgnoreUnresolvedTransactions</code> is strongly discouraged, because if clients are not careful to commit or rollback themselves prior to close(), or do not set Connection <code>autoCommit</code> consistently, bizarre unreproduceable behavior and database lockups can occur.</p> 
<h4><a id="Configuring_to_Debug_and_Workaround_Broken_Client_Applicationsimgq6948Dkg1655893008212httpswwwmchangecomprojectsc3p0arrow_smpnghttpswwwmchangecomprojectsc3p0contents_150"></a>七、Configuring to Debug and Workaround Broken Client Applications<a href="https://www.mchange.com/projects/c3p0/#contents" rel="nofollow">[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-q6948Dkg-1655893008212)(https://www.mchange.com/projects/c3p0/arrow_sm.png)]</a></h4> 
<p>Sometimes client applications are sloppy about close()ing all Connections they check out. Eventually, the pool grows to <code>maxPoolSize</code>, and then runs out of Connections, because of these bad clients.</p> 
<p><font color="red">有时候，应用程序在使用close()的动作去归还检出的连接过于草率会很容易导致连接池连接增长到最大设置，并导致连接溢出。</font></p> 
<p>The right way to address this problem is to fix the client application. <code>c3p0</code> can help you debug, by letting you know where Connections are checked out that occasionally don’t get checked in. In rare and unfortunate situations, development of the client application is closed, and even though it is buggy, you cannot fix it. c3p0 can help you work around the broken application, preventing it from exhausting the pool.</p> 
<p><font color="red">解决这个问题的正确方法是修复客户机应用程序。c3p0可以帮助您调试，通过让您知道在哪里连接被检查出来，且不被检入。在罕见和不幸的情况下，客户端应用程序的开发是关闭的，即使它有缺陷，您也无法修复它。C3p0可以帮助您处理损坏的应用程序，防止它耗尽连接池连接。</font></p> 
<p>The following parameters can help you debug or workaround broken client applications.</p> 
<ul><li><a href="https://www.mchange.com/projects/c3p0/#debugUnreturnedConnectionStackTraces" rel="nofollow">debugUnreturnedConnectionStackTraces</a></li><li><a href="https://www.mchange.com/projects/c3p0/#unreturnedConnectionTimeout" rel="nofollow">unreturnedConnectionTimeout</a></li></ul> 
<p><code>unreturnedConnectionTimeout</code> defines a limit (in seconds) to how long a Connection may remain checked out. If set to a nozero value, unreturned, checked-out Connections that exceed this limit will be summarily destroyed, and then replaced in the pool. Obviously, you must take care to set this parameter to a value large enough that all intended operations on checked out Connections have time to complete. You can use this parameter to merely workaround unreliable client apps that fail to close() Connections.</p> 
<p><font color="red">有时候，应用程序在使用close()的动作去归还检出的连接过于草率会很容易导致连接池连接增长到最大设置，并导致连接溢出。如果设置为非零值，超过此限制的未返回的签出连接将被立即销毁，然后在池中替换。显然，您必须小心地将该参数设置为足够大的值，使签出的连接上的所有预期操作都有时间完成。您可以使用此参数来解决不可靠的客户端应用程序无法关闭()连接的问题。</font></p> 
<p>Much better than working-around is fixing. If, <em>in addition to setting</em> <code>unreturnedConnectionTimeout</code>, you set <code>debugUnreturnedConnectionStackTraces</code> to <code>true</code>, then a stack trace will be captured each time a Connection is checked-out. Whenever an unreturned Connection times out, that stack trace will be printed, revealing where a Connection was checked out that was not checked in promptly. <code>debugUnreturnedConnectionStackTraces</code> is intended to be used only for debugging, as capturing a stack trace can slow down Connection check-out.</p> 
<p><font color="red">有时候，应用程序在使用close()的动作去归还检出的连接过于草率会很容易导致连接池连接增长到最大设置，并导致连接溢出。如果除了设置’ unreturnedConnectionTimeout ‘之外，还将’ debugUnreturnedConnectionStackTraces ‘设为’ true ‘，那么每次签出一个Connection时，都会捕获一个堆栈跟踪。每当未返回的Connection超时时，将打印该堆栈跟踪，显示未及时签入的Connection签出的位置。’ debugUnreturnedConnectionStackTraces '只用于调试，因为捕获堆栈跟踪会减慢连接检出的速度。</font></p> 
<h4><a id="Configuring_To_Avoid_Memory_Leaks_On_Hot_Redeploy_Of_ClientsGo_To_Tophttpsimgblogcsdnimgcnimg_convert559514564b425b8a2d8d410f07ccb293pnghttpswwwmchangecomprojectsc3p0contents_173"></a>八、Configuring To Avoid Memory Leaks On Hot Redeploy Of Clients<a href="https://www.mchange.com/projects/c3p0/#contents" rel="nofollow"><img src="https://images2.imgbox.com/dd/cf/PsG4Ahen_o.png" alt="Go To Top"></a></h4> 
<p>c3p0 spawns a variety of Threads (<a href="https://www.mchange.com/projects/c3p0/#numHelperThreads" rel="nofollow">helper threads</a>, <code>java.util.Timer</code> threads), and does so lazily in response to the first client request experienced by a PooledDataSource. By default, the Threads spawned by c3p0 inherit a <code>java.security.AccessControlContext</code> and a <code>contextClassLoader</code> property from this first-calling Thread. If that Thread came from a client that may need to be hot-undeployed, references to these objects may prevent the undeployed application, often partitioned into a <code>ClassLoader</code>, from being garbage collected. (See for example <a href="https://wiki.apache.org/tomcat/MemoryLeakProtection" rel="nofollow">this description of Tomcat memory leaks on redeployment</a>.)</p> 
<p>c3p0 provides two configuration parameters that can help with this:</p> 
<ul><li><a href="https://www.mchange.com/projects/c3p0/#contextClassLoaderSource" rel="nofollow">contextClassLoaderSource</a></li><li><a href="https://www.mchange.com/projects/c3p0/#privilegeSpawnedThreads" rel="nofollow">privilegeSpawnedThreads</a></li></ul> 
<p><code>contextClassLoaderSource</code> should be set to one of <code>caller</code>, <code>library</code>, or <code>none</code>. The default (which yields the default behavior described above) is <code>caller</code>. Set this to <code>library</code> to use c3p0’s ClassLoader, so that no reference is maintained to a client that may need to be redeployed.</p> 
<p><code>privilegeSpawnedThreads</code> is a boolean, <code>false</code> by default. Set this to <code>true</code> so that c3p0’s Threads use the the c3p0 library’s <code>AccessControlContext</code>, rather than an <code>AccessControlContext</code> that may be associated with the client application and prevent its garbage collection.</p> 
<h4><a id="Other_DataSource_ConfigurationGo_To_Tophttpsimgblogcsdnimgcnimg_convert559514564b425b8a2d8d410f07ccb293pnghttpswwwmchangecomprojectsc3p0contents_186"></a>九、Other DataSource Configuration<a href="https://www.mchange.com/projects/c3p0/#contents" rel="nofollow"><img src="https://images2.imgbox.com/25/d1/3KeR3bAp_o.png" alt="Go To Top"></a></h4> 
<p>See <a href="https://www.mchange.com/projects/c3p0/#configuration_properties" rel="nofollow">Appendix A</a> for information about the following configuration properties:</p> 
<ul><li><a href="https://www.mchange.com/projects/c3p0/#checkoutTimeout" rel="nofollow">checkoutTimeout</a></li><li><a href="https://www.mchange.com/projects/c3p0/#factoryClassLocation" rel="nofollow">factoryClassLocation</a></li><li><a href="https://www.mchange.com/projects/c3p0/#forceSynchronousCheckins" rel="nofollow">forceSynchronousCheckins</a></li><li><a href="https://www.mchange.com/projects/c3p0/#maxAdministrativeTaskTime" rel="nofollow">maxAdministrativeTaskTime</a></li><li><a href="https://www.mchange.com/projects/c3p0/#numHelperThreads" rel="nofollow">numHelperThreads</a></li></ul> 
<p><code>numHelperThreads</code> and <code>maxAdministrativeTaskTime</code> help to configure the behavior of DataSource thread pools. By default, each DataSource has only three associated helper threads. If performance seems to drag under heavy load, or if you observe via JMX or direct inspection of a <code>PooledDataSource</code>, that the number of “pending tasks” is usually greater than zero, try increasing <code>numHelperThreads</code>. <code>maxAdministrativeTaskTime</code> may be useful for users experiencing tasks that hang indefinitely and “APPARENT DEADLOCK” messages. (See Appendix A for more.)<font color="red"><code>numHelperThreads </code>和<code>maxAdministrativeTaskTime </code>帮助配置数据源线程池的行为。默认情况下，每个DataSource只有三个关联的辅助线程。如果性能似乎在重负载下下降，或者如果你通过JMX或直接检查<code>PooledDataSource</code>观察到“挂起的任务”的数量通常大于零，尝试增加<code>numHelperThreads</code>。<code>maxAdministrativeTaskTime </code>可能对用户遇到无限挂起的任务和“明显的死锁”消息有用。(详见附录A)</font></p> 
<p>Ordinarily check-ins are performed asynchronously so that clients do not experience the overhead of on-check-in Connection tests and/or operations specified in <code>ConnectionCustomizer.onCheckIn(...)</code>. However, asynchronous checkins add to Thread pool congestion. Under loads so large that it is impractical to expand <code>numHelperThreads</code> to reduce congestion, <code>forceSynchronousCheckins</code> will cause client Threads to perform the checkin operations, adding to the load of the Thread pool and precluding any delays in termination of checkin due to Thread pool congestion. As long as you neither perform Connection tests on check-in (see <a href="https://www.mchange.com/projects/c3p0/#testConnectionOnCheckin" rel="nofollow">testConnectionOnCheckin</a>) nor perform database operations or other slow work in <code>ConnectionCustomizer.onCheckIn(...)</code>, this setting is likely to improve performance. However, if Connections <em>are</em> tested on check-in, or custom work is performed, setting <code>forceSynchronousCheckins</code> will cause clients to experience delays associated with that work when they call <code>Connection.close()</code>.<font color="red">通常，check-ins是异步执行的，这样客户端就不会遇到<code>ConnectionCustomizer.onCheckIn(…)</code>中指定的签入连接测试和/或操作的开销。然而，异步签入会增加线程池拥塞。在如此大的负载之下，扩展’ numHelperThreads ‘来减少拥塞是不切实际的，’ forceSynchronousCheckins ‘将导致客户端线程执行签入操作，增加线程池的负载，并减少不了任何由于线程池拥塞而终止签入的延迟。只要您既不在签入时执行连接测试(请参阅<a href="https://www.mchange.com/projects/c3p0/#testConnectionOnCheckin" rel="nofollow">testConnectionOnCheckin</a>)，也不在<code>ConnectionCustomizer.onCheckIn(…)</code>中执行数据库操作或其他慢速工作，此设置可能会提高性能。然而，如果在签入时测试了连接，或者执行了自定义工作，设置’ <code>forceSynchronousCheckins </code>将导致客户端在调用<code>Connection.close()</code>时经历与该工作相关的延迟。</font></p> 
<p><code>checkoutTimeout</code> limits how long a client will wait for a Connection, if all Connections are checked out and one cannot be supplied immediately.</p> 
<h4><a id="Configuring_Logging_202"></a>十、Configuring Logging</h4> 
<p>c3p0 uses a custom logging library similar to jakarta commons-logging. Log messages can be directed to the to the popular <a href="http://www.slf4j.org/" rel="nofollow">slf4j</a> (with its <a href="http://logback.qos.ch/" rel="nofollow">logback backend</a>), to the venerable log4j library, the more recent log4j2 library, to the standard logging facility introduced with jdk1.4, or to <code>System.err</code>. Nearly all configuration should be done at the level of your preferred logging library. There are a very few configuration options specific to c3p0’s logging, and usually the defaults will be fine. Logging-related parameters may be placed in your <code>c3p0.properties</code> file, in <a href="https://www.mchange.com/projects/c3p0/#c3p0_conf" rel="nofollow">HOCON configuration files</a>, in a file called <code>mchange-log.properties</code> at the top-level of your classpath, or they may be defined as System properties. (The logging properties defined below may not be defined in <code>c3p0-config.xml</code>!) See the <a href="https://www.mchange.com/projects/c3p0/#log_properties_box" rel="nofollow">box</a> below.</p> 
<p><font color="red">C3P0使用了一个自定义日志库，类似于Jakarta common-logging。日志消息可以被定向到流行的<a href="http://www.slf4j.org/" rel="nofollow">slf4j</a>(及其<a href="http://logback.qos.ch/" rel="nofollow">logback后端</a>)，到令人尊敬的log4j库，或者最近的log4j2库，或者到jdk1.4引入的标准日志记录工具，或者’ System.err’。几乎所有的配置都应该在首选的日志库级别上完成。c3p0日志记录特有的配置选项非常少，通常默认设置就可以了。与日志相关的参数可以放在您的’ c3p0.properties`文件中。如果是在<a href="https://www.mchange.com/projects/c3p0/#c3p0_conf" rel="nofollow">HOCON配置文件</a>中，那么就是在一个名为“mchange-log.properties”的文件中。或者它们可以被定义为系统属性。(下面定义的日志属性可能没有在’ c3p0-config.xml '中定义!)请参阅下面的<a href="https://www.mchange.com/projects/c3p0/#log_properties_box" rel="nofollow">框</a>。</font></p> 
<p>c3p0’s logging behavior is affected by certain build-time options. If build-option <code>c3p0.debug</code> is set to <code>false</code>, all messages at a logging level below INFO will be suppressed. Build-option <code>c3p0.trace</code> controls how fine-grained c3p0’s below INFO level reporting will be. For the moment, distributed c3p0 binaries are compiled with <code>debug</code> set to <code>true</code> and <code>trace</code> set to its maximum level of <code>10</code>. But binaries may eventually be distributed with <code>debug</code> set to <code>false</code>. (For the moment, the performance impact of the logging level-checks seems very small, and it’s most flexible to compile in all the messages, and let your logging library control which are emitted.) When c3p0 starts up, it emits the build-time values of debug and trace, along with the version and build time.</p> 
<p><font color="red">C3p0的日志记录行为受某些构建时选项的影响。如果构建选项<code>c3p0.debug</code>被设置为<code>false</code>，所有日志级别低于INFO的消息将被抑制。构建选项的<code>c3p0.trace</code>控制INFO级别以下c3p0报告的细粒度。目前，分布式c3p0二进制文件在编译时将“debug”设置为“true”，并将“trace”设置为最大等级“10”。但是二进制文件可能最终会在发布时将“debug”设置为“false”。(目前，日志级别检查的性能影响似乎非常小，在所有消息中编译是最灵活的，并让您的日志库进行具体控制)。当c3p0启动时，它会输出调试和跟踪在构建时设定的值，或者以及版本发布时构建的值。</font></p> 
<ol><li>com.mchange.v2.log.MLog</li></ol> 
<p>Determines which library c3p0 will output log messages to. By default, if slf4j is available, it will use that library, otherwise log4j if available, otherwise log4j2 if available, otherwise jdk1.4 logging apis, and if all are unavailable, it will fallback to logging via <code>System.err</code>. If you want to directly control which library is used, you may set this property to one of:</p> 
<ul><li><code>com.mchange.v2.log.slf4j.Slf4jMLog</code></li><li><code>com.mchange.v2.log.log4j.Log4jMLog</code></li><li><code>com.mchange.v2.log.log4j2.Log4j2MLog</code></li><li><code>com.mchange.v2.log.jdk14logging.Jdk14MLog</code></li><li><code>com.mchange.v2.log.FallbackMLog</code></li></ul> 
<p>Alternatively, the following abbreviations are supported:<font color="red">另外支持一下缩写</font>&gt;</p> 
<ul><li><code>slf4j</code></li><li><code>log4j</code></li><li><code>log4j2</code></li><li><code>jul, jdk14, java.util.logging</code></li><li><code>fallback</code></li></ul> 
<p>You may also set this property to a comma separated list of any mix the above alternatives, to define an order of preference among logging libraries.</p> 
<p><font color="red">您还可以将此属性设置为一个逗号分隔的列表，将上述选项混合在一起，以定义日志库之间的首选顺序。</font></p> 
<ol><li><strong>com.mchange.v2.log.MLog.useRedirectableLoggers</strong></li></ol> 
<p>Using API in <a href="https://www.mchange.com/projects/mchange-commons-java/apidocs/com/mchange/v2/log/MLog.html" rel="nofollow"><code>com.mchange.v2.log.MLog</code></a>, it is possible to change at runtime what library c3p0 output logs to, or to switch midstream to the standard-error based fallback logger. However, for this to be useful, loggers already constructed against the original configuration need to be sensitive to the change. Setting this value to <code>true</code> will cause c3p0 to use slightly less performant loggers that can be redirected between libraries at runtime. This setting is <code>false</code> by default.</p> 
<p><font color="red">使用<a href="https://www.mchange.com/projects/mchange-commons-java/apidocs/com/mchange/v2/log/MLog.html" rel="nofollow">’ com.mchange.v2.log.MLog '</a>中的API，可以在运行时修改库c3p0输出日志的位置，或在切换到一个基于标准fallback的日志记录器。然而，为了使这一点生效，已经根据原始配置构造的日志记录器要对修改敏感。将该值设置为“true”将导致c3p0使用性能稍差的记录器，这些记录器可以在运行时在库之间重定向。该设置默认为“false”。</font></p> 
<ol start="2"><li><strong>com.mchange.v2.log.jdk14logging.suppressStackWalk</strong></li></ol> 
<p>Under JDK standard logging, the logging library may inspect stack traces to determine the class and method from which a log message was generated. That can be helpful, but it is also slow. Setting this configuration parameter to true will suppress this stack walk, and reduce the overhead of logging. <strong>This property now defaults to <code>true</code>, and logger names are logged in place of class names.</strong> To return to the original slower but more informative approach, explicitly set the property to false.</p> 
<p><font color="red">在JDK标准日志记录下，日志库可以检查堆栈跟踪以确定生成日志消息的类和方法。这可能是有帮助的，但也是缓慢的。将此配置参数设置为true将抑制此堆栈遍历，并减少日志记录的开销。**此属性现在默认为’ true '，日志记录器的名称将被记录在类名的位置。**要返回原来的较慢但信息量更大的方法，显式地将属性设置为false。</font></p> 
<ol start="3"><li><strong>com.mchange.v2.log.NameTransformer</strong></li></ol> 
<p>By default, c3p0 uses very fine-grained logging, in general with one logger for each c3p0 class. For a variety of reasons, some users may prefer fewer, more global loggers. You may opt for one-logger-per-package by setting <code>com.mchange.v2.log.NameTransformer</code> to the value <code>com.mchange.v2.log.PackageNames</code>. Advanced users can also define other strategies for organizing the number and names of loggers by setting this variable to the fully-qualified class name of a custom implementation of the <code>com.mchange.v2.log.NameTransformer</code> interface.</p> 
<p><font color="red">默认情况下，c3p0使用非常细粒度的日志记录，通常为每个c3p0类使用一个日志记录器。由于各种原因，一些用户可能更喜欢更少、更多的全局记录器。您可以通过设置<code>com.mchange.v2.log.NameTransformer</code>为<code>com.mchange.v2.log.PackageNames</code>. 。高级用户还可以设置其他自定义策略为继承了接口<code>com.mchange.v2.log.NameTransformer</code>的全限定实现类类名。</font></p> 
<ol start="4"><li>com.mchange.v2.log.FallbackMLog.DEFAULT_CUTOFF_LEVEL</li></ol> 
<p>If, whether by choice or by necessity, you are using c3p0’s <code>System.err</code> fallback logger, you can use this parameter to control how detailed c3p0’s logging should be. Any of the following values (taken from the jdk1.4 logging library) are acceptable:<code>OFF``SEVERE``WARNING``INFO``CONFIG``FINE``FINER``FINEST``ALL</code>This property defaults to <code>INFO</code>.</p> 
<p><font color="red">如果，无论是出于选择还是必要，您正在使用c3p0的<code>System.err</code>fallback logger，您可以使用此参数来控制c3p0日志记录的详细程度。以下任何值(取自jdk1.4日志库)都是可以接受的:’ OFF ’ ’ SEVERE ’ ’ WARNING ’ ’ INFO ’ ’ CONFIG ’ ’ FINE ’ ’ FINER ’ ’ FINEST ’ ’ ALL ‘该属性默认为’ INFO '。</font>&gt;</p> 
<h3><a id="A_Appendix_A_Configuration_Propertiesimgvvz8DFQk1655893008216httpswwwmchangecomprojectsc3p0arrow_smpnghttpswwwmchangecomprojectsc3p0contents_260"></a>十一、附录A Appendix A: Configuration Properties<a href="https://www.mchange.com/projects/c3p0/#contents" rel="nofollow">[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vvz8DFQk-1655893008216)(https://www.mchange.com/projects/c3p0/arrow_sm.png)]</a></h3> 
<p>c3p0 configuration properties can be divided into <a href="https://www.mchange.com/projects/c3p0/#javabeans-style-properties" rel="nofollow">JavaBeans-style Properties</a> and <a href="https://www.mchange.com/projects/c3p0/#other-properties" rel="nofollow">Other Properties</a>.</p> 
<h4><a id="JavaBeansstyle_Propertiesimg9TAOXV1H1655893008217httpswwwmchangecomprojectsc3p0arrow_smpnghttpswwwmchangecomprojectsc3p0contents_264"></a>JavaBeans-style Properties<a href="https://www.mchange.com/projects/c3p0/#contents" rel="nofollow">[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9TAOXV1H-1655893008217)(https://www.mchange.com/projects/c3p0/arrow_sm.png)]</a></h4> 
<p>The following properties can be set directly in code as JavaBeans properties, via a <a href="https://www.mchange.com/projects/c3p0/#system_properties" rel="nofollow">System properties</a> or a <a href="https://www.mchange.com/projects/c3p0/#c3p0_properties" rel="nofollow"><code>c3p0.properties</code></a> file (with <code>c3p0.</code> prepended to the property name), in <a href="https://www.mchange.com/projects/c3p0/#c3p0_conf" rel="nofollow">HOCON (typesafe-config) files</a>, or in a <a href="https://www.mchange.com/projects/c3p0/#c3p0-config.xml" rel="nofollow"><code>c3p0-config.xml</code></a> file. See the section on <a href="https://www.mchange.com/projects/c3p0/#configuration" rel="nofollow">Configuration</a> above. Click on the property name for a full description.</p> 
<table><thead><tr><th><a href="https://www.mchange.com/projects/c3p0/#acquireIncrement" rel="nofollow">acquireIncrement</a> <a href="https://www.mchange.com/projects/c3p0/#acquireRetryAttempts" rel="nofollow">acquireRetryAttempts</a> <a href="https://www.mchange.com/projects/c3p0/#acquireRetryDelay" rel="nofollow">acquireRetryDelay</a> <a href="https://www.mchange.com/projects/c3p0/#autoCommitOnClose" rel="nofollow">autoCommitOnClose</a> <a href="https://www.mchange.com/projects/c3p0/#automaticTestTable" rel="nofollow">automaticTestTable</a> <a href="https://www.mchange.com/projects/c3p0/#breakAfterAcquireFailure" rel="nofollow">breakAfterAcquireFailure</a> <a href="https://www.mchange.com/projects/c3p0/#checkoutTimeout" rel="nofollow">checkoutTimeout</a> <a href="https://www.mchange.com/projects/c3p0/#connectionCustomizerClassName" rel="nofollow">connectionCustomizerClassName</a> <a href="https://www.mchange.com/projects/c3p0/#connectionTesterClassName" rel="nofollow">connectionTesterClassName</a> <a href="https://www.mchange.com/projects/c3p0/#contextClassLoaderSource" rel="nofollow">contextClassLoaderSource</a> <a href="https://www.mchange.com/projects/c3p0/#dataSourceName" rel="nofollow">dataSourceName</a> <a href="https://www.mchange.com/projects/c3p0/#debugUnreturnedConnectionStackTraces" rel="nofollow">debugUnreturnedConnectionStackTraces</a> <a href="https://www.mchange.com/projects/c3p0/#driverClass" rel="nofollow">driverClass</a> <a href="https://www.mchange.com/projects/c3p0/#extensions" rel="nofollow">extensions</a></th><th><a href="https://www.mchange.com/projects/c3p0/#factoryClassLocation" rel="nofollow">factoryClassLocation</a> <a href="https://www.mchange.com/projects/c3p0/#forceIgnoreUnresolvedTransactions" rel="nofollow">forceIgnoreUnresolvedTransactions</a> <a href="https://www.mchange.com/projects/c3p0/#forceSynchronousCheckins" rel="nofollow">forceSynchronousCheckins</a> <a href="https://www.mchange.com/projects/c3p0/#forceUseNamedDriverClass" rel="nofollow">forceUseNamedDriverClass</a> <a href="https://www.mchange.com/projects/c3p0/#idleConnectionTestPeriod" rel="nofollow">idleConnectionTestPeriod</a> <a href="https://www.mchange.com/projects/c3p0/#initialPoolSize" rel="nofollow">initialPoolSize</a> <a href="https://www.mchange.com/projects/c3p0/#jdbcUrl" rel="nofollow">jdbcUrl</a> <a href="https://www.mchange.com/projects/c3p0/#maxAdministrativeTaskTime" rel="nofollow">maxAdministrativeTaskTime</a> <a href="https://www.mchange.com/projects/c3p0/#maxConnectionAge" rel="nofollow">maxConnectionAge</a> <a href="https://www.mchange.com/projects/c3p0/#maxIdleTime" rel="nofollow">maxIdleTime</a> <a href="https://www.mchange.com/projects/c3p0/#maxIdleTimeExcessConnections" rel="nofollow">maxIdleTimeExcessConnections</a> <a href="https://www.mchange.com/projects/c3p0/#maxPoolSize" rel="nofollow">maxPoolSize</a> <a href="https://www.mchange.com/projects/c3p0/#maxStatements" rel="nofollow">maxStatements</a> <a href="https://www.mchange.com/projects/c3p0/#maxStatementsPerConnection" rel="nofollow">maxStatementsPerConnection</a></th><th><a href="https://www.mchange.com/projects/c3p0/#minPoolSize" rel="nofollow">minPoolSize</a> <a href="https://www.mchange.com/projects/c3p0/#numHelperThreads" rel="nofollow">numHelperThreads</a> <a href="https://www.mchange.com/projects/c3p0/#overrideDefaultUser" rel="nofollow">overrideDefaultUser</a> <a href="https://www.mchange.com/projects/c3p0/#overrideDefaultPassword" rel="nofollow">overrideDefaultPassword</a> <a href="https://www.mchange.com/projects/c3p0/#password" rel="nofollow">password</a> <a href="https://www.mchange.com/projects/c3p0/#preferredTestQuery" rel="nofollow">preferredTestQuery</a> <a href="https://www.mchange.com/projects/c3p0/#privilegeSpawnedThreads" rel="nofollow">privilegeSpawnedThreads</a> <a href="https://www.mchange.com/projects/c3p0/#propertyCycle" rel="nofollow">propertyCycle</a> <a href="https://www.mchange.com/projects/c3p0/#statementCacheNumDeferredCloseThreads" rel="nofollow">statementCacheNumDeferredCloseThreads</a> <a href="https://www.mchange.com/projects/c3p0/#testConnectionOnCheckin" rel="nofollow">testConnectionOnCheckin</a> <a href="https://www.mchange.com/projects/c3p0/#testConnectionOnCheckout" rel="nofollow">testConnectionOnCheckout</a> <a href="https://www.mchange.com/projects/c3p0/#unreturnedConnectionTimeout" rel="nofollow">unreturnedConnectionTimeout</a> <a href="https://www.mchange.com/projects/c3p0/#user" rel="nofollow">user</a> <a href="https://www.mchange.com/projects/c3p0/#usesTraditionalReflectiveProxies" rel="nofollow">usesTraditionalReflectiveProxies</a></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table> 
<ul><li> <p>acquireIncrement</p> <p><strong>Default: 3</strong></p> <p>Determines how many connections at a time c3p0 will try to acquire when the pool is exhausted. [See <a href="https://www.mchange.com/projects/c3p0/#basic_pool_configuration" rel="nofollow">“Basic Pool Configuration”</a>]</p> </li><li> <p>acquireRetryAttempts</p> <p><strong>Default: 30</strong></p> <p>Defines how many times c3p0 will try to acquire a new Connection from the database before giving up. If this value is less than or equal to zero, c3p0 will keep trying to fetch a Connection indefinitely. <font color="red">如果这个值小于或等于0,c3p0将继续尝试无限获取一个Connection。</font>[See <a href="https://www.mchange.com/projects/c3p0/#configuring_recovery" rel="nofollow">“Configuring Recovery From Database Outages”</a>]</p> </li><li> <p>acquireRetryDelay</p> <p><strong>Default: 1000 Milliseconds,</strong></p> <p>time c3p0 will wait between acquire attempts. [See <a href="https://www.mchange.com/projects/c3p0/#configuring_recovery" rel="nofollow">“Configuring Recovery From Database Outages”</a>]</p> </li><li> <p>autoCommitOnClose</p> <p><strong>Default: false</strong></p> <p>The JDBC spec is unforgivably silent on what should happen to unresolved, pending transactions on Connection close. C3P0’s default policy is to rollback any uncommitted, pending work. (I think this is absolutely, undeniably the right policy, but there is no consensus among JDBC driver vendors.) Setting <code>autoCommitOnClose</code> to true causes uncommitted pending work to be committed, rather than rolled back on Connection close. [<em>Note: Since the spec is absurdly unclear on this question, application authors who wish to avoid bugs and inconsistent behavior should ensure that all transactions are explicitly either committed or rolled-back before close is called.</em>] [See <a href="https://www.mchange.com/projects/c3p0/#configuring_unresolved" rel="nofollow">“Configuring Unresolved Transaction Handling”</a>]</p> </li><li> <p>automaticTestTable</p> <p><strong>Default: null</strong></p> <p>If provided, c3p0 will create an empty table of the specified name, and use queries against that table to test the Connection. If <code>automaticTestTable</code> is provided, c3p0 will generate its own test query, therefore any <code>preferredTestQuery</code> set will be ignored. You should not work with the named table after c3p0 creates it; it should be strictly for c3p0’s use in testing your Connection. (If you define your own ConnectionTester, it must implement the <a href="https://www.mchange.com/projects/c3p0/apidocs/com/mchange/v2/c3p0/QueryConnectionTester.html" rel="nofollow">QueryConnectionTester</a> interface for this parameter to be useful.) [See <a href="https://www.mchange.com/projects/c3p0/#configuring_connection_testing" rel="nofollow">“Configuring Connection Testing”</a>]</p> </li><li> <p>breakAfterAcquireFailure</p> <p><strong>Default: false</strong></p> <p>If true, a pooled DataSource will declare itself broken and be permanently closed if a Connection cannot be obtained from the database after making <code>acquireRetryAttempts</code> to acquire one. If false, failure to obtain a Connection will cause all Threads waiting for the pool to acquire a Connection to throw an Exception, but the DataSource will remain valid, and will attempt to acquire again following a call to <code>getConnection()</code>. [See <a href="https://www.mchange.com/projects/c3p0/#configuring_recovery" rel="nofollow">“Configuring Recovery From Database Outages”</a>]</p> <p><font color="red">如果为真，在使用“acquireRetryAttempts” 获取连接后，无法从数据库中获取连接，则池化数据源将声明自己已损坏，并永久关闭。如果为false，获取连接失败将导致所有等待池获取连接的线程抛出异常，但数据源将保持有效，并将在调用’ getConnection() '后尝试再次获取。</font></p> </li><li> <p>checkoutTimeout</p> <p><strong>Default: 0</strong></p> <p>The number of milliseconds a client calling getConnection() will wait for a Connection to be checked-in or acquired when the pool is exhausted. Zero means wait indefinitely. Setting any positive value will cause the getConnection() call to time-out and break with an <code>SQLException</code> after the specified number of milliseconds.</p> <p><font color="red">当连接池耗尽时，调用getConnection()的客户端等待连接被签入或获取的毫秒数。零意味着无限期等待。设置任何正值都会导致getConnection()调用超时，并在指定的毫秒数之后以’ SQLException '中断。</font></p> </li><li> <p>connectionCustomizerClassName</p> <p><strong>Default: null</strong></p> <p>The fully qualified class-name of an implememtation of the <a href="https://www.mchange.com/projects/c3p0/apidocs/com/mchange/v2/c3p0/ConnectionCustomizer.html" rel="nofollow"><code>ConnectionCustomizer</code></a> interface, which users can implement to set up Connections when they are acquired from the database, or on check-out, and potentially to clean things up on check-in and Connection destruction. If standard Connection properties (holdability, readOnly, or transactionIsolation) are set in the ConnectionCustomizer’s onAcquire() method, these will override the Connection default values.</p> </li><li> <p>connectionTesterClassName</p> <p><strong>Default: com.mchange.v2.c3p0.impl.DefaultConnectionTester</strong></p> <p>The fully qualified class-name of an implememtation of the <a href="https://www.mchange.com/projects/c3p0/apidocs/com/mchange/v2/c3p0/ConnectionTester.html" rel="nofollow"><code>ConnectionTester</code></a> interface, or <a href="https://www.mchange.com/projects/c3p0/apidocs/com/mchange/v2/c3p0/QueryConnectionTester.html" rel="nofollow"><code>QueryConnectionTester</code></a> if you would like instances to have access to a user-configured <code>preferredTestQuery</code>. This can be used to customize how c3p0 DataSources test Connections, but with the introduction of <code>automaticTestTable</code> and <code>preferredTestQuery</code> configuration parameters, “rolling your own” should be overkill for most users. [See <a href="https://www.mchange.com/projects/c3p0/#configuring_connection_testing" rel="nofollow">“Configuring Connection Testing”]</a></p> </li><li> <p>contextClassLoaderSource</p> <p><strong>Default: caller</strong></p> <p>Must be one of <code>caller</code>, <code>library</code>, or <code>none</code>. Determines how the <code>contextClassLoader</code> (see <code>java.lang.Thread</code>) of c3p0-spawned Threads is determined. If <code>caller</code>, c3p0-spawned Threads (<a href="https://www.mchange.com/projects/c3p0/#numHelperThreads" rel="nofollow">helper threads</a>, <code>java.util.Timer</code> threads) inherit their <code>contextClassLoader</code> from the client Thread that provokes initialization of the pool. If <code>library</code>, the <code>contextClassLoader</code> will be the class that loaded c3p0 classes. If <code>none</code>, no <code>contextClassLoader</code> will be set (the property will be <code>null</code>), which in practice means the system ClassLoader will be used. The default setting of <code>caller</code> is sometimes a problem when client applications will be hot redeployed by an app-server. When c3p0’s Threads hold a reference to a <code>contextClassLoader</code> from the first client that hits them, it may be impossible to garbage collect a <code>ClassLoader</code> associated with that client when it is undeployed in a running VM. Setting this to <code>library</code> can resolve these issues. [See “<a href="https://www.mchange.com/projects/c3p0/#configuring_to_avoid_memory_leaks_on_redeploy" rel="nofollow">Configuring To Avoid Memory Leaks On Hot Redeploy Of Client</a>”]Does Not Support Per-User Overrides.</p> </li><li> <p>dataSourceName</p> <p><strong>Default: if configured with a <a href="https://www.mchange.com/projects/c3p0/#named_configurations" rel="nofollow">named config</a>, the config name, otherwise the pool’s “identity token”</strong></p> <p>Every c3p0 pooled data source is given a <code>dataSourceName</code>, which serves two purposes. It helps users find DataSources via <a href="https://www.mchange.com/projects/c3p0/#using_c3p0_registry_box" rel="nofollow">C3P0Registry</a>, and it is included in the name of JMX mBeans in order to help track and distinguish between multiple c3p0 DataSources even across application or JVM restarts. <code>dataSourceName</code> defaults to the pool’s configuration name, if a <a href="https://www.mchange.com/projects/c3p0/#named_configurations" rel="nofollow">named config</a> was used, or else to an “identity token” (an opaque, guaranteed unique String associated with every c3p0 DataSource). You may update this property to any name you find convenient. <code>dataSourceName</code> is <em>not</em> guaranteed to be unique — for example, multiple DataSource created from the same named configuration will share the same <code>dataSourceName</code>. But if you are going to make use of <code>dataSourceName</code>, you will probably want to ensure that all pooled DataSources within your JVM do have unique names.</p> </li><li> <p>debugUnreturnedConnectionStackTraces</p> <p><strong>Default: false</strong></p> <p>If true, and if ```unreturnedConnectionTimeout<code>is set to a positive value, then the pool will capture the stack trace (via an Exception) of all Connection checkouts, and the stack traces will be printed when unreturned checked-out Connections timeout. This is intended to debug applications with Connection leaks, that is applications that occasionally fail to return Connections, leading to pool growth, and eventually exhaustion (when the pool hits</code>maxPoolSize` with all Connections checked-out and lost). This parameter should only be set while debugging, as capturing the stack trace will slow down every Connection check-out. [See <a href="https://www.mchange.com/projects/c3p0/#configuring_to_debug_and_workaround_broken_clients" rel="nofollow">“Configuring to Debug and Workaround Broken Client Applications”</a>]</p> </li><li> <p>driverClass</p> <p>Default: null</p> <p>The fully-qualified class name of the JDBC driverClass that is expected to provide Connections. c3p0 will preload any class specified here to ensure that appropriate URLs may be resolved to an instance of the driver by <code>java.sql.DriverManager</code>. If you wish to skip <code>DriverManager</code> resolution entirely and ensure that an instance of the specified class is used to provide Connections, use ```driverClass<code>in combination with</code>forceUseNamedDriverClass<code>. [See also </code>jdbcUrl`.]Does Not Support Per-User Overrides.</p> </li><li> <p>extensions</p> <p>Default: an empty <code>java.util.Map</code></p> <p>A <code>java.util.Map</code> (raw type) containing the values of any <a href="https://www.mchange.com/projects/c3p0/#user_extensions_to_configurations" rel="nofollow">user-defined configuration extensions</a> defined for this DataSource.Does Not Support Per-User Overrides.</p> </li><li> <p>factoryClassLocation</p> <p><strong>Default: null</strong></p> <p>DataSources that will be bound by JNDI and use that API’s Referenceable interface to store themselves may specify a URL from which the class capable of dereferencing a them may be loaded. If (as is usually the case) the c3p0 libraries will be locally available to the JNDI service, leave this set as null.</p> </li><li> <p>forceIgnoreUnresolvedTransactions</p> <p><strong>Default: false</strong></p> <p>*<strong>Strongly disrecommended. Setting this to <code>true</code> may lead to subtle and bizarre bugs.*</strong> This is a terrible setting, leave it alone unless absolutely necessary. It is here to workaround broken databases / JDBC drivers that do not properly support transactions, but that allow Connections’ <code>autoCommit</code> flags to go to false regardless. If you are using a database that supports transactions “partially” (this is oxymoronic, as the whole point of transactions is to perform operations reliably and completely, but nonetheless such databases are out there), if you feel comfortable ignoring the fact that Connections with <code>autoCommit == false</code> may be in the middle of transactions and may hold locks and other resources, you may turn off c3p0’s wise default behavior, which is to protect itself, as well as the usability and consistency of the database, by either rolling back (default) or committing (see <code>c3p0.autoCommitOnClose</code> <em>above</em>) unresolved transactions. <strong>This should only be set to true when you are sure you are using a database that allows Connections’ autoCommit flag to go to false, but offers no other meaningful support of transactions. Otherwise setting this to true is just a bad idea.</strong> [See <a href="https://www.mchange.com/projects/c3p0/#configuring_unresolved" rel="nofollow">“Configuring Unresolved Transaction Handling”</a>]</p> </li><li> <p>forceSynchronousCheckins</p> <p><strong>Default: false</strong></p> <p>Setting this to <code>true</code> forces Connections to be checked-in synchronously, which under some circumstances may improve performance. Ordinarily Connections are checked-in asynchronously so that clients avoid any overhead of testing or custom check-in logic. However, asynchronous check-in contributes to thread pool congestion, and very busy pools might find clients delayed waiting for check-ins to complete. Expanding <code>numHelperThreads</code> can help manage Thread pool congestion, but memory footprint and switching costs put limits on practical thread pool size. To reduce thread pool load, you can set <code>forceSynchronousCheckins</code> to <code>true</code>. Synchronous check-ins are likely to improve overall performance when <code>testConnectionOnCheckin</code> is set to false and no slow work is performed in a <code>ConnectionCustomizer</code>’s <code>onCheckIn(...)</code> method. If Connections are tested or other slow work is performed on check-in, then this setting will cause clients to experience the overhead of that work on <code>Connection.close()</code>, which you must trade-off against any improvements in pool performance. [See <a href="https://www.mchange.com/projects/c3p0/#other_ds_configuration" rel="nofollow">“Other DataSource Configuration”</a>]</p> <p><font color="red">将此设置为<code>true</code>将强制同步签入Connections，这在某些情况下可能会提高性能。通常情况下，连接是异步签入的，这样客户机就可以避免任何测试或自定义签入逻辑的开销。但是，异步签入会导致线程池拥塞，非常繁忙的池可能会发现客户端延迟等待签入完成。扩展<code>numHelperThreads</code>可以帮助管理线程池拥塞，但是内存占用和切换成本限制了实际的线程池大小。为了减少线程池负载，你可以设置<code>forceSynchronousCheckins </code>为<code>true</code>。当<code>testConnectionOnCheckin</code>设置为false，并且在<code>ConnectionCustomizer</code>的<code>onCheckIn(…)</code>方法中不执行缓慢的工作时，同步签入可能会提高整体性能。如果在签入时测试连接或执行其他慢速工作，则此设置将导致客户端在<code>Connection.close()</code>上体验该工作的开销，您必须权衡池性能的任何改进。</font></p> </li><li> <p>forceUseNamedDriverClass</p> <p><strong>Default: false</strong></p> <p>Setting the parameter <a href="https://www.mchange.com/projects/c3p0/#driverClass" rel="nofollow">driverClass</a> causes that class to preload and register with <code>java.sql.DriverManager</code>. However, it does not on its own ensure that the driver used will be an instance of <a href="https://www.mchange.com/projects/c3p0/#driverClass" rel="nofollow">driverClass</a>, as <code>DriverManager</code> may (in unusual cases) know of other driver classes which can handle the specified <a href="https://www.mchange.com/projects/c3p0/#jdbcUrl" rel="nofollow">jdbcUrl</a>. Setting this parameter to true causes c3p0 to ignore <code>DriverManager</code> and simply instantiate <a href="https://www.mchange.com/projects/c3p0/#driverClass" rel="nofollow">driverClass</a> directly.Does Not Support Per-User Overrides.</p> </li><li> <p>idleConnectionTestPeriod</p> <p><strong>Default: 0</strong></p> <p>If this is a number greater than 0, c3p0 will test all idle, pooled but unchecked-out connections, every this number of seconds. [See <a href="https://www.mchange.com/projects/c3p0/#configuring_connection_testing" rel="nofollow">“Configuring Connection Testing”</a>]</p> </li><li> <p>initialPoolSize</p> <p><strong>Default: 3</strong></p> <p>Number of Connections a pool will try to acquire upon startup. Should be between <code>minPoolSize</code> and <code>maxPoolSize</code>. [See <a href="https://www.mchange.com/projects/c3p0/#basic_pool_configuration" rel="nofollow">“Basic Pool Configuration”</a>]</p> </li><li> <p>jdbcUrl</p> <p><strong>Default: null</strong></p> <p>The JDBC URL of the database from which Connections can and should be acquired. Should resolve via <code>java.sql.DriverManager</code> to an appropriate JDBC Driver (which you can ensure will be loaded and available by setting ```driverClass<code>), or if you wish to specify which driver to use directly (and avoid </code>DriverManager` resolution), you may specify <a href="https://www.mchange.com/projects/c3p0/#driverClass" rel="nofollow">driverClass</a> in combination with <a href="https://www.mchange.com/projects/c3p0/#forceUseNamedDriverClass" rel="nofollow">forceUseNamedDriverClass</a>. Unless you are supplying your own unpooled DataSource, a <a href="https://www.mchange.com/projects/c3p0/#jdbcUrl" rel="nofollow">must always be provided and appropriate for the JDBC driver, however it is resolved.</a><a href="https://www.mchange.com/projects/c3p0/#jdbcUrl" rel="nofollow">Does Not Support Per-User Overrides.</a></p> </li><li> <p>maxAdministrativeTaskTime</p> <p><strong>Default: 0</strong></p> <p>Seconds before c3p0’s thread pool will try to interrupt an apparently hung task. Rarely useful. Many of c3p0’s functions are not performed by client threads, but asynchronously by an internal thread pool. c3p0’s asynchrony enhances client performance directly, and minimizes the length of time that critical locks are held by ensuring that slow jdbc operations are performed in non-lock-holding threads. If, however, some of these tasks “hang”, that is they neither succeed nor fail with an Exception for a prolonged period of time, c3p0’s thread pool can become exhausted and administrative tasks backed up. If the tasks are simply slow, the best way to resolve the problem is to increase the number of threads, via <a href="https://www.mchange.com/projects/c3p0/#numHelperThreads" rel="nofollow">numHelperThreads</a>. But if tasks sometimes hang indefinitely, you can use this parameter to force a call to the task thread’s <code>interrupt()</code> method if a task exceeds a set time limit. [c3p0 will eventually recover from hung tasks anyway by signalling an “APPARENT DEADLOCK” (you’ll see it as a warning in the logs), replacing the thread pool task threads, and interrupt()ing the original threads. But letting the pool go into APPARENT DEADLOCK and then recover means that for some periods, c3p0’s performance will be impaired. So if you’re seeing these messages, increasing <a href="https://www.mchange.com/projects/c3p0/#numHelperThreads" rel="nofollow">numHelperThreads</a> and setting <code>maxAdministrativeTaskTime</code> might help. <code>maxAdministrativeTaskTime</code> should be large enough that any resonable attempt to acquire a Connection from the database, to test a Connection, or to destroy a Connection, would be expected to succeed or fail within the time set. Zero (the default) means tasks are never interrupted, which is the best and safest policy under most circumstances. If tasks are just slow, allocate more threads. If tasks are hanging forever, try to figure out why, and maybe setting <code>maxAdministrativeTaskTime</code> can help in the meantime.Does Not Support Per-User Overrides.</p> <p><font color="red">在c3p0的线程池试图中断一个明显挂起的任务前几秒。很少有用。c3p0的许多函数不是由客户端线程执行的，而是由内部线程池异步执行的。C3p0的异步直接提高了客户端性能，通过确保在非锁持有线程中执行慢速JDBC操作，最小化了关键锁持有的时间长度。但是，如果其中一些任务“挂起”，即它们在很长一段时间内既不成功也不失败，并伴有异常，那么c3p0的线程池可能会耗尽，从而备份管理任务。如果任务很慢，解决这个问题的最好方法是通过<a href="https://www.mchange.com/projects/c3p0/#numHelperThreads" rel="nofollow">numHelperThreads</a>增加线程的数量。但是如果任务有时无限期地挂起，你可以使用这个参数来强制调用任务线程的’ interrupt() ‘方法，如果任务超过了设定的时间限制。[c3p0最终将通过发出“明显的死锁”信号(在日志中会看到这是一个警告)来从挂起的任务中恢复，替换线程池任务线程，并中断()原始线程。但是让池进入表观死锁，然后恢复意味着在一段时间内，c3p0的性能将受到损害。因此，如果你看到这些消息，增加<a href="https://www.mchange.com/projects/c3p0/#numHelperThreads" rel="nofollow">numHelperThreads</a>和设置’ maxAdministrativeTaskTime ‘可能会有所帮助。’ maxAdministrativeTaskTime '应该足够大，以至于任何合理的尝试从数据库获取连接，测试连接，或销毁连接，都将在设定的时间内预期成功或失败。0(默认值)意味着任务不会被中断，这在大多数情况下是最好和最安全的策略。如果任务很慢，那么分配更多线程。如果任务一直挂着，试着找出原因，在此期间设置“maxAdministrativeTaskTime”可能会有所帮助。不支持每用户重写。</font></p> </li><li> <p>maxConnectionAge</p> <p><strong>Default: 0</strong></p> <p>Seconds, effectively a time to live. A Connection older than <code>maxConnectionAge</code> will be destroyed and purged from the pool. This differs from <code>maxIdleTime</code> in that it refers to absolute age. Even a Connection which has not been much idle will be purged from the pool if it exceeds <code>maxConnectionAge</code>. Zero means no maximum absolute age is enforced.</p> <p><font color="red">秒，有效地活了一段时间。大于“maxConnectionAge”的连接将被销毁并从池中清除。这与’ maxIdleTime ‘不同，因为它指的是绝对年龄。即使是一个没有太多空闲的连接，如果它超过了’ maxConnectionAge '，也会从池中清除。零意味着没有强制规定最大年龄。</font></p> </li><li> <p>maxIdleTime</p> <p>Default: 0</p> <p>Seconds a Connection can remain pooled but unused before being discarded. Zero means idle connections never expire. [See <a href="https://www.mchange.com/projects/c3p0/#basic_pool_configuration" rel="nofollow">“Basic Pool Configuration”</a>]</p> </li><li> <p>maxIdleTimeExcessConnections</p> <p>Default: 0</p> <p>Number of seconds that Connections in excess of <code>minPoolSize</code> should be permitted to remain idle in the pool before being culled. Intended for applications that wish to aggressively minimize the number of open Connections, shrinking the pool back towards minPoolSize if, following a spike, the load level diminishes and Connections acquired are no longer needed. If <code>maxIdleTime</code> is set, <code>maxIdleTimeExcessConnections</code> should be smaller if the parameter is to have any effect. Zero means no enforcement, excess Connections are not idled out.</p> <p><font color="red">在被剔除之前，超过“minPoolSize”的连接应该被允许在池中保持空闲的秒数。适用于希望积极地最小化打开连接数量的应用程序，如果在峰值之后，负载水平降低，并且不再需要获得的连接，则将池缩小到minPoolSize。如果设置了’ maxIdleTime ‘，那么’ maxIdleTimeExcessConnections '应该更小，如果该参数要起作用的话。零意味着没有强制，多余的连接不会闲置。</font></p> </li><li> <p>maxPoolSize</p> <p><strong>Default: 15</strong></p> <p>Maximum number of Connections a pool will maintain at any given time. [See <a href="https://www.mchange.com/projects/c3p0/#basic_pool_configuration" rel="nofollow">“Basic Pool Configuration”</a>]</p> </li><li> <p>maxStatements</p> <p><strong>Default: 0</strong></p> <p>The size of c3p0’s global PreparedStatement cache. If both <code>maxStatements</code> and <code>maxStatementsPerConnection</code> are zero, statement caching will not be enabled. If <code>maxStatements</code> is zero but <code>maxStatementsPerConnection</code> is a non-zero value, statement caching will be enabled, but no global limit will be enforced, only the per-connection maximum. <code>maxStatements</code> controls the total number of Statements cached, for all Connections. If set, it should be a fairly large number, as each pooled Connection requires its own, distinct flock of cached statements. As a guide, consider how many distinct PreparedStatements are used <em>frequently</em> in your application, and multiply that number by <code>maxPoolSize</code> to arrive at an appropriate value. Though <code>maxStatements</code> is the JDBC standard parameter for controlling statement caching, users may find c3p0’s alternative <code>maxStatementsPerConnection</code> more intuitive to use. [See <a href="https://www.mchange.com/projects/c3p0/#configuring_statement_pooling" rel="nofollow">“Configuring Statement Pooling”</a>]</p> </li><li> <p>maxStatementsPerConnection</p> <p><strong>Default: 0</strong></p> <p>The number of PreparedStatements c3p0 will cache for a single pooled Connection. If both <code>maxStatements</code> and <code>maxStatementsPerConnection</code> are zero, statement caching will not be enabled. If <code>maxStatementsPerConnection</code> is zero but <code>maxStatements</code> is a non-zero value, statement caching will be enabled, and a global limit enforced, but otherwise no limit will be set on the number of cached statements for a single Connection. If set, maxStatementsPerConnection should be set to about the number distinct PreparedStatements that are used <em>frequently</em> in your application, plus two or three extra so infrequently statements don’t force the more common cached statements to be culled. Though <code>maxStatements</code> is the JDBC standard parameter for controlling statement caching, users may find <code>maxStatementsPerConnection</code> more intuitive to use. [See <a href="https://www.mchange.com/projects/c3p0/#configuring_statement_pooling" rel="nofollow">“Configuring Statement Pooling”</a>]</p> <p><font color="red">preparedstatement c3p0的数量将为单个池连接缓存。如果’ maxStatements ‘和’ maxStatementsPerConnection '都为零，语句缓存将不会被启用。如果“maxStatementsPerConnection”为零，但“maxStatements”为非零值，则将启用语句缓存，并强制执行全局限制，否则不会对单个连接的缓存语句数量设置限制。如果设置了maxStatementsPerConnection，应该将其设置为在应用程序中<em>频繁使用</em>的不同preparedstatement的数量，再加上两到三个额外的，这样不频繁的语句就不会强制选择更常见的缓存语句。虽然“maxStatements”是用于控制语句缓存的JDBC标准参数，但用户可能会发现“maxStatementsPerConnection”使用起来更直观。</font></p> </li><li> <p>minPoolSize</p> <p><strong>Default: 3</strong></p> <p>Minimum number of Connections a pool will maintain at any given time. [See <a href="https://www.mchange.com/projects/c3p0/#basic_pool_configuration" rel="nofollow">“Basic Pool Configuration”</a>]</p> </li><li> <p>numHelperThreads</p> <p><strong>Default: 3</strong></p> <p>c3p0 is very asynchronous. Slow JDBC operations are generally performed by helper threads that don’t hold contended locks. Spreading these operations over multiple threads can significantly improve performance by allowing multiple operations to be performed simultaneously.</p> </li><li> <p>overrideDefaultUser</p> <p><strong>Default: null</strong></p> <p>Forces the username that should by PooledDataSources when a user calls the default getConnection() method. This is primarily useful when applications are pooling Connections from a non-c3p0 unpooled DataSource. Applications that use <code>ComboPooledDataSource</code>, or that wrap any c3p0-implemented unpooled DataSource can use the simple <a href="https://www.mchange.com/projects/c3p0/#user" rel="nofollow">user</a> property.Does Not Support Per-User Overrides.</p> </li><li> <p>overrideDefaultPassword</p> <p><strong>Default: null</strong></p> <p>Forces the password that should by PooledDataSources when a user calls the default getConnection() method. This is primarily useful when applications are pooling Connections from a non-c3p0 unpooled DataSource. Applications that use <code>ComboPooledDataSource</code>, or that wrap any c3p0-implemented unpooled DataSource can use the simple <a href="https://www.mchange.com/projects/c3p0/#password" rel="nofollow">password</a> property.Does Not Support Per-User Overrides.</p> </li><li> <p>password</p> <p><strong>Default: null</strong></p> <p>For applications using <code>ComboPooledDataSource</code> or any c3p0-implemented unpooled DataSources — <code>DriverManagerDataSource</code> or the DataSource returned by <code>DataSources.unpooledDataSource( ... )</code> — defines the password that will be used for the DataSource’s default <code>getConnection()</code> method. (See also <a href="https://www.mchange.com/projects/c3p0/#user" rel="nofollow">user</a>.)Does Not Support Per-User Overrides.</p> </li><li> <p>preferredTestQuery</p> <p><strong>Default: null</strong></p> <p>Defines the query that will be executed for all connection tests, if the default ConnectionTester (or some other implementation of <a href="https://www.mchange.com/projects/c3p0/apidocs/com/mchange/v2/c3p0/QueryConnectionTester.html" rel="nofollow">QueryConnectionTester</a>, or better yet <a href="https://www.mchange.com/projects/c3p0/apidocs/com/mchange/v2/c3p0/FullQueryConnectionTester.html" rel="nofollow">FullQueryConnectionTester</a>) is being used. Defining a <code>preferredTestQuery</code> that will execute quickly in your database may dramatically speed up Connection tests. (If no <code>preferredTestQuery</code> is set, the default ConnectionTester executes a <code>getTables()</code> call on the Connection’s DatabaseMetaData. Depending on your database, this may execute more slowly than a “normal” database query.) <strong>NOTE: The table against which your <code>preferredTestQuery</code> will be run must exist in the database schema *prior* to your initialization of your DataSource. If your application defines its own schema, try <code>automaticTestTable</code> instead.</strong> [See <a href="https://www.mchange.com/projects/c3p0/#configuring_connection_testing" rel="nofollow">“Configuring Connection Testing”</a>]</p> </li><li> <p>privilegeSpawnedThreads</p> <p><strong>Default: false</strong></p> <p>If <code>true</code>, c3p0-spawned Threads will have the <code>java.security.AccessControlContext</code> associated with c3p0 library classes. By default, c3p0-spawned Threads (<a href="https://www.mchange.com/projects/c3p0/#numHelperThreads" rel="nofollow">helper threads</a>, <code>java.util.Timer</code> threads) inherit their <code>AccessControlContext</code> from the client Thread that provokes initialization of the pool. This can sometimes be a problem, especially in application servers that support hot redeployment of client apps. If c3p0’s Threads hold a reference to an <code>AccessControlContext</code> from the first client that hits them, it may be impossible to garbage collect a <code>ClassLoader</code> associated with that client when it is undeployed in a running VM. Also, it is possible client Threads might lack sufficient permission to perform operations that c3p0 requires. Setting this to <code>true</code> can resolve these issues. [See “<a href="https://www.mchange.com/projects/c3p0/#configuring_to_avoid_memory_leaks_on_redeploy" rel="nofollow">Configuring To Avoid Memory Leaks On Hot Redeploy Of Client</a>”]Does Not Support Per-User Overrides.</p> </li><li> <p>propertyCycle</p> <p><strong>Default: 0</strong></p> <p>Maximum time in seconds before user configuration constraints are enforced. Determines how frequently <code>maxConnectionAge</code>, <code>maxIdleTime</code>, <code>maxIdleTimeExcessConnections</code>, <code>unreturnedConnectionTimeout</code> are enforced. c3p0 periodically checks the age of Connections to see whether they’ve timed out. This parameter determines the period. Zero means automatic: A suitable period will be determined by c3p0. [You can call <code>getEffectivePropertyCycle...()</code> methods on a c3p0 <a href="https://www.mchange.com/projects/c3p0/apidocs/com/mchange/v2/c3p0/PooledDataSource.html" rel="nofollow">PooledDataSource</a> to find the period automatically chosen.]</p> <p><font color="red">用户配置约束生效的最大时间(秒)。确定强制执行’ maxConnectionAge '， ’ maxIdleTime '， ’ maxIdleTimeExcessConnections '， ’ unreturnedConnectionTimeout '的频率。c3p0定期检查连接的年龄，看它们是否超时。该参数决定周期。0表示自动:一个合适的周期将由c3p0确定。</font></p> </li><li> <p>statementCacheNumDeferredCloseThreads</p> <p><strong>Default: 0</strong></p> <p>If set to a value greater than 0, the statement cache will track when Connections are in use, and only destroy Statements when their parent Connections are not otherwise in use. Although closing of a Statement while the parent Connection is in use is formally within spec, some databases and/or JDBC drivers, most notably Oracle, do not handle the case well and freeze, leading to deadlocks. Setting this parameter to a positive value should eliminate the issue. This parameter should only be set if you observe that attempts by c3p0 to close() cached statements freeze (usually you’ll see <code>APPARENT DEADLOCKS</code> in your logs). If set, this parameter should almost always be set to <code>1</code>. Basically, if you need more than one Thread dedicated solely to destroying cached Statements, you should set <code>maxStatements</code> and/or <code>maxStatementsPerConnection</code> so that you don’t churn through Statements so quickly. [See <a href="https://www.mchange.com/projects/c3p0/#configuring_statement_pooling" rel="nofollow">“Configuring Statement Pooling”</a>]Does Not Support Per-User Overrides.</p> </li><li> <p>testConnectionOnCheckin</p> <p><strong>Default: false</strong></p> <p>If true, an operation will be performed asynchronously at every connection checkin to verify that the connection is valid. Use in combination with <code>idleConnectionTestPeriod</code> for quite reliable, always asynchronous Connection testing. Also, setting an <code>automaticTestTable</code> or <code>preferredTestQuery</code> will usually speed up all connection tests. [See <a href="https://www.mchange.com/projects/c3p0/#configuring_connection_testing" rel="nofollow">“Configuring Connection Testing”</a>]</p> </li><li> <p>testConnectionOnCheckout</p> <p><strong>Default: false</strong></p> <p>If true, an operation will be performed at every connection checkout to verify that the connection is valid. *<strong>Be sure to set an efficient*</strong> <code>preferredTestQuery</code> *<strong>or*</strong> <code>automaticTestTable</code> *<strong>if you set this to*</strong> <code>true</code>. *<strong>Performing the (expensive) default Connection test on every client checkout will harm client performance.*</strong> Testing Connections in checkout is the simplest and most reliable form of Connection testing, but for better performance, consider verifying connections periodically using <code>idleConnectionTestPeriod</code>. [See <a href="https://www.mchange.com/projects/c3p0/#configuring_connection_testing" rel="nofollow">“Configuring Connection Testing”</a>]</p> </li><li> <p>unreturnedConnectionTimeout</p> <p><strong>Default: 0</strong></p> <p>Seconds. If set, if an application checks out but then fails to check-in [i.e. close()] a Connection within the specified period of time, the pool will unceremoniously destroy() the Connection. This permits applications with occasional Connection leaks to survive, rather than eventually exhausting the Connection pool. And that’s a shame. Zero means no timeout, applications are expected to close() their own Connections. Obviously, if a non-zero value is set, it should be to a value longer than any Connection should reasonably be checked-out. Otherwise, the pool will occasionally kill Connections in active use, which is bad. *<strong>This is basically a bad idea, but it’s a commonly requested feature. Fix your $%!@% applications so they don’t leak Connections! Use this temporarily in combination with <code>debugUnreturnedConnectionStackTraces</code> to figure out where Connections are being checked-out that don’t make it back into the pool!*</strong> [See <a href="https://www.mchange.com/projects/c3p0/#configuring_to_debug_and_workaround_broken_clients" rel="nofollow">“Configuring to Debug and Workaround Broken Client Applications”</a>]</p> </li><li> <p>user</p> <p><strong>Default: null</strong></p> <p>For applications using <code>ComboPooledDataSource</code> or any c3p0-implemented unpooled DataSources — <code>DriverManagerDataSource</code> or the DataSource returned by <code>DataSources.unpooledDataSource()</code> — defines the username that will be used for the DataSource’s default <code>getConnection()</code> method. (See also <a href="https://www.mchange.com/projects/c3p0/#password" rel="nofollow">password</a>.)Does Not Support Per-User Overrides.</p> </li></ul> 
<h3><a id="c3p0_534"></a>十二、网络闪断c3p0线程堵塞解决方法</h3> 
<p>场景：c3p0数据库连接耗尽，新的工作线程获取连接时进入堵塞状态，此时网络关闭。获取连接成功的工作线程由于断网没有接收到数据库的回应会一直堵塞等待数据返回。获取连接而堵塞的工作线程也会一直堵塞下去。</p> 
<p>解决方法：通过设置驱动底层socket的soTimeout可以使socket通过抛出timeout异常，解除线程堵塞状态，提前返回。</p> 
<p>通过测试，估算出交易中sql最大运行时间，推荐设置为</p> 
<p>Sql最大运行时间&lt; c3p0 MaxIdleTime &lt; soTimeout</p> 
<p>soTimeout在不同数据库中设置</p> 
<table><thead><tr><th>数据库</th><th>设置方法</th></tr></thead><tbody><tr><td>mysql</td><td>url设置socketTimeout，单位毫秒比如设置为30秒在url后添加参数&amp;socketTimeout=30000</td></tr><tr><td>oracle</td><td>虚拟机设置参数，单位毫秒比如设置为30秒在启动程序时设置-Doracle.jdbc.ReadTimeout=30000</td></tr><tr><td>db2</td><td>单位秒设置loginTimeout，QueryTimeout，blockingReadConnectionTimeout（待验证）</td></tr></tbody></table>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a23dd85867522ca3229074627fc8101e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker安装eclipse-mosquitto MQTT并记录日志</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27a67b4b5aea1d1e7a62a5296027341f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">将数据导入到MATLAB</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>