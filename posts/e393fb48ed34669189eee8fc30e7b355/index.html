<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 多进程开发 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; 多进程开发" />
<meta property="og:description" content="文章目录 一、程序二、进程三、 操作系统单道和多道程序时间片并行和并发进程控制块（PCB） 四、进程状态 和 Linux下的命令进程的状态Linux进程命令查看进程杀死进程进程号和相关函数 五、子进程的创建和执行进程的创建 fork()多进程调试 GDBexec函数族 六、 进程控制进程的退出孤儿进程僵尸进程进程回收wait()waitpid() 进程通信匿名管道管道的读写特点创建匿名管道设置管道非阻塞 有名管道有名管道的使用 内存映射信号发送信号相关的函数：定时器函数信号捕捉函数信号集sigaction信号捕捉函数 共享内存消息队列守护进程进程组和会话进程组、会话操作函数守护进程 总结 一、程序 程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：
二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息（是指描述文件本身的信息，例如文件大小，和文件内存储的数据）。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）。机器语言指令：对程序算法进行编码。程序入口地址：标识程序开始执行时的起始指令位置。数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。 二、进程 进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是资源分配的基本单位。可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。 三、 操作系统 操作系统调度进程有两种方式：抢占式调度和非抢占时调度，其中非抢占式调度只有进程阻塞时，CPU才会处理其他资源。抢占式调度系统会根据某种原则终止当前运行的进程去执行另一个以及就绪的进程。抢占式调度的源泽包括：时间片原则、优先级原则、短作业优先原则。
单道和多道程序 单道程序，即在计算机内存中只允许一个的程序运行。多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。 时间片 时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。 并行和并发 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。并发是我们需要研究的。
进程控制块（PCB） 为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。在 /usr/src/linux-headers-xxx/include/linux/sched." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/e393fb48ed34669189eee8fc30e7b355/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-24T16:33:38+08:00" />
<meta property="article:modified_time" content="2022-07-24T16:33:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 多进程开发</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_6" rel="nofollow">一、程序</a></li><li><a href="#_20" rel="nofollow">二、进程</a></li><li><a href="#__23" rel="nofollow">三、 操作系统</a></li><li><ul><li><a href="#_25" rel="nofollow">单道和多道程序</a></li><li><a href="#_31" rel="nofollow">时间片</a></li><li><a href="#_35" rel="nofollow">并行和并发</a></li><li><a href="#PCB_39" rel="nofollow">进程控制块（PCB）</a></li></ul> 
  </li><li><a href="#__Linux_54" rel="nofollow">四、进程状态 和 Linux下的命令</a></li><li><ul><li><a href="#_55" rel="nofollow">进程的状态</a></li><li><a href="#Linux_65" rel="nofollow">Linux进程命令</a></li><li><a href="#_66" rel="nofollow">查看进程</a></li><li><a href="#_111" rel="nofollow">杀死进程</a></li><li><a href="#_120" rel="nofollow">进程号和相关函数</a></li></ul> 
  </li><li><a href="#_129" rel="nofollow">五、子进程的创建和执行</a></li><li><ul><li><a href="#_fork_130" rel="nofollow">进程的创建 fork()</a></li><li><a href="#_GDB_170" rel="nofollow">多进程调试 GDB</a></li><li><a href="#exec_180" rel="nofollow">exec函数族</a></li></ul> 
  </li><li><a href="#__234" rel="nofollow">六、 进程控制</a></li><li><ul><li><a href="#_235" rel="nofollow">进程的退出</a></li><li><a href="#_256" rel="nofollow">孤儿进程</a></li><li><a href="#_290" rel="nofollow">僵尸进程</a></li><li><a href="#_299" rel="nofollow">进程回收</a></li><li><ul><li><a href="#wait_305" rel="nofollow">wait()</a></li><li><a href="#waitpid_328" rel="nofollow">waitpid()</a></li></ul> 
   </li><li><a href="#_352" rel="nofollow">进程通信</a></li><li><a href="#_363" rel="nofollow">匿名管道</a></li><li><ul><li><a href="#_376" rel="nofollow">管道的读写特点</a></li><li><a href="#_386" rel="nofollow">创建匿名管道</a></li><li><a href="#_404" rel="nofollow">设置管道非阻塞</a></li></ul> 
   </li><li><a href="#_412" rel="nofollow">有名管道</a></li><li><ul><li><a href="#_421" rel="nofollow">有名管道的使用</a></li></ul> 
   </li><li><a href="#_548" rel="nofollow">内存映射</a></li><li><a href="#_643" rel="nofollow">信号</a></li><li><ul><li><a href="#_705" rel="nofollow">发送信号相关的函数：</a></li><li><a href="#_734" rel="nofollow">定时器函数</a></li><li><a href="#_783" rel="nofollow">信号捕捉函数</a></li><li><a href="#_807" rel="nofollow">信号集</a></li><li><a href="#sigaction_895" rel="nofollow">sigaction信号捕捉函数</a></li></ul> 
   </li><li><a href="#_1010" rel="nofollow">共享内存</a></li><li><a href="#_1130" rel="nofollow">消息队列</a></li><li><a href="#_1135" rel="nofollow">守护进程</a></li><li><ul><li><a href="#_1136" rel="nofollow">进程组和会话</a></li><li><a href="#_1147" rel="nofollow">进程组、会话操作函数</a></li><li><a href="#_1155" rel="nofollow">守护进程</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_1259" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_6"></a>一、程序</h2> 
<p>程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：</p> 
<ul><li>二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息（是指描述文件本身的信息，例如文件大小，和文件内存储的数据）。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）。</li><li>机器语言指令：对程序算法进行编码。</li><li>程序入口地址：标识程序开始执行时的起始指令位置。</li><li>数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。</li><li>符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。</li><li>共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。</li><li>其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。</li></ul> 
<h2><a id="_20"></a>二、进程</h2> 
<ul><li>进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是资源分配的基本单位。</li><li>可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与<code>进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息</code>。</li></ul> 
<h2><a id="__23"></a>三、 操作系统</h2> 
<p>操作系统调度进程有两种方式：抢占式调度和非抢占时调度，其中非抢占式调度只有进程阻塞时，CPU才会处理其他资源。抢占式调度系统会根据某种原则终止当前运行的进程去执行另一个以及就绪的进程。抢占式调度的源泽包括：<code>时间片原则、优先级原则、短作业优先原则。</code></p> 
<h3><a id="_25"></a>单道和多道程序</h3> 
<ul><li>单道程序，即在计算机内存中只允许一个的程序运行。</li><li>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。</li><li>对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。</li><li>在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</li></ul> 
<h3><a id="_31"></a>时间片</h3> 
<ul><li>时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。</li><li>时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。</li></ul> 
<h3><a id="_35"></a>并行和并发</h3> 
<ul><li>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。</li><li>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。<code>并发是我们需要研究的。</code><br> <img src="https://images2.imgbox.com/34/2f/95UKNegH_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="PCB_39"></a>进程控制块（PCB）</h3> 
<ul><li>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。</li><li>在 /usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，主要有： 
  <ol><li>进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数</li><li>进程的状态：有就绪、运行、挂起、停止等状态</li><li>进程切换时需要保存和恢复的一些CPU寄存器</li><li>描述虚拟地址空间的信息</li><li>描述控制终端的信息</li><li>当前工作目录（Current Working Directory）</li><li>umask 掩码</li><li>文件描述符表，包含很多指向 file 结构体的指针</li><li>和信号相关的信息</li><li>用户 id 和组 id</li><li>会话（Session）和进程组</li><li>进程可以使用的资源上限（Resource Limit）<code>（Linux使用 Ulimit -a可以查看资源上限）</code></li></ol> </li></ul> 
<h2><a id="__Linux_54"></a>四、进程状态 和 Linux下的命令</h2> 
<h3><a id="_55"></a>进程的状态</h3> 
<p>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型中，进程分为新建态、就绪态，运行态，阻塞态，终止态。<br> <img src="https://images2.imgbox.com/4c/31/23CscCfn_o.png" alt="在这里插入图片描述"></p> 
<ul><li>运行态：进程占有处理器正在运行</li><li>就绪态：进程具备运行条件，当进程已分配了到除CPU以外的所有必要资源，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</li><li>阻塞态：又称为等待(wait)态或睡眠(sleep)态，指进程不具备运行条件，正在等待某个事件的完成。不拥有CPU资源，例如调用sleep()、用户交互和文件读取会发生阻塞。</li></ul> 
<p>有些系统增加了五态模型：</p> 
<ul><li>新建态：进程刚被创建时的状态，尚未进入就绪队列</li><li>终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后<code>（用户区的数据会自动释放，但内核区的数据还没释放）</code>。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。</li></ul> 
<h3><a id="Linux_65"></a>Linux进程命令</h3> 
<h3><a id="_66"></a>查看进程</h3> 
<p>ps aux / ajx</p> 
<blockquote> 
 <p>a：显示终端上的所有进程，包括其他用户的进程 <br> u：显示进程的详细信息<br> x：显示没有控制终端的进程<br> j：列出与作业控制相关的信息</p> 
</blockquote> 
<p>执行 ps aux后，会显示以下的信息，具体含义看名字就能看出来接下来会详细讲一下STAT参数(进程运行时的状态)：</p> 
<pre><code class="prism language-cpp">USER      PID        <span class="token operator">%</span>CPU  <span class="token operator">%</span>MEM    VSZ   RSS    TTY   STAT   START      TIME        COMMAND
所属用户  进程id      占用资源                   终端   状态   开始时间    持续时间    执行的命令（产生的该进程）
</code></pre> 
<pre><code class="prism language-cpp">STAT参数的含义：
	D 不可中断 Uninterruptible（usually IO）
	R 正在运行，或在队列中的进程
	<span class="token function">S</span><span class="token punctuation">(</span>大写<span class="token punctuation">)</span> 处于休眠状态
	T 停止或被追踪
	Z 僵尸进程
	W 进入内存交换（从内核<span class="token number">2.6</span>开始无效）
	X 死掉的进程
	<span class="token operator">&lt;</span> 高优先级
	N 低优先级
	s 包含子进程
	<span class="token operator">+</span> 位于前台的进程组
</code></pre> 
<p>执行 ps ajx后，会显示以下的信息（<code>TPGID为-1表示是守护进程</code>）</p> 
<pre><code class="prism language-cpp"> PPID      PID      PGID       SID      TTY    TPGID          STAT   UID   TIME  COMMAND
父进程id   进程id   进程组id    会话id   终端   前台进程组id     
</code></pre> 
<p>执行top 命令会动态显示进程信息。可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在 top 命令执行后，可以按以下按键对显示的结果进行排序：</p> 
<pre><code class="prism language-cpp"> PID USER  PR  NI    VIRT    RES    SHR S  <span class="token operator">%</span>CPU <span class="token operator">%</span>MEM     TIME<span class="token operator">+</span> COMMAND
</code></pre> 
<blockquote> 
 <p>M 根据内存使用量排序<br> P 根据 CPU 占有率排序<br> T 根据进程运行时间长短排序<br> U 根据用户名来筛选进程<br> K 输入指定的 PID 杀死进程</p> 
</blockquote> 
<h3><a id="_111"></a>杀死进程</h3> 
<p>kill [-signal] pid</p> 
<ul><li>kill –l 列出所有信号</li><li>kill –SIGKILL 进程ID</li><li>kill -9 进程ID (强制杀死进程，9就是SIGKILL信号)</li><li>killall name 根据进程名杀死进程</li></ul> 
<p><mark>小知识：./a.out &amp; 可以让进程在后台运行，不加 &amp; 默认在前台运行，输入 fg 切换到前台。/a.out &gt;&gt; 文件名 可以重定向程序输出的文件，默认是标准输出（当前终端）</mark> <a href="https://blog.csdn.net/guotianqing/article/details/104835177">参考这篇博客</a></p> 
<h3><a id="_120"></a>进程号和相关函数</h3> 
<ul><li>每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767（2^10-1）。进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。</li><li>任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。</li><li>进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号。</li><li>进程号和进程组相关函数：<br> pid_t getpid(void);<br> pid_t getppid(void);<br> pid_t getpgid(pid_t pid); (如果参数为<code>NULL</code>，获得当前进程的进程组号)</li></ul> 
<h2><a id="_129"></a>五、子进程的创建和执行</h2> 
<h3><a id="_fork_130"></a>进程的创建 fork()</h3> 
<p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。创建进程的函数为：<br> pid_t fork(void)，该函数是一个Linux的系统调用函数，其头文件包括：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
</code></pre> 
<p>返回值：</p> 
<ul><li>成功：子进程中返回 0，父进程中返回子进程 ID</li><li>失败：返回 -1</li></ul> 
<p>失败的两个主要原因：</p> 
<ol><li>当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN</li><li>系统内存不足，这时 errno 的值被设置为 ENOMEM</li></ol> 
<p>fork()出的子进程不会执行父进程已经执行过的代码，而是会从 <code>fork()</code> 代码处继续向后执行。</p> 
<p>Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</p> 
<p>fork之后父子进程共享文件，fork产生的子进程产生与父进程相同的文件描述符，指向相同的文件表，引用计数增加，共享文件偏移指针（父子进程都可以操作文件，父子进程共享文件偏移的指针，具体表现就是，父进程修改了文件，子进程会在父进程修改之后的地方对文件进行操作）。</p> 
<p>父子进程之间的关系：</p> 
<pre><code>   区别：
        1.fork()函数的返回值不同
            父进程中: &gt;0 返回的子进程的ID
            子进程中: =0
        2.pcb中的一些数据
            当前的进程的 pid 不一样
            当前的进程的父进程的 ppid 不一样
            信号集
    共同点：
        某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作
            - 用户区的数据
            - 文件描述符表
    
    父子进程对变量是不是共享的？
        - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。
        - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。
</code></pre> 
<h3><a id="_GDB_170"></a>多进程调试 GDB</h3> 
<p>使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，<code>默认跟踪父进程</code>。</p> 
<ul><li> <p>设置调试父进程或者子进程：<code>set follow-fork-mode [parent（默认）| child]</code></p> </li><li> <p>设置调试模式：<code>set detach-on-fork [on | off]</code><br> 默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。</p> </li><li> <p>查看调试的进程：info inferiors<br> 切换当前调试的进程：inferior id<br> 使进程脱离 GDB 调试：detach inferiors id</p> </li></ul> 
<h3><a id="exec_180"></a>exec函数族</h3> 
<p>函数族类似C++的函数重载，函数族是一族函数，可以执行相似的功能。exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</p> 
<p>exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容<code>取代（着重讲是替换！替换！替换！可以理解为用户区内容之间被换了，内核区照旧）</code>，调用成功从可执行文件的 main 函数处执行，只留下进程 ID 等一些表面上的信息仍保持原样。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。<a href="https://blog.csdn.net/yychuyu/article/details/80173039">这篇文章讲的非常好，我就不说了，我只写一下参数的意义，其他差不多，也可以去牛客网的C++课程听听老师的课。</a></p> 
<pre><code class="prism language-cpp"><span class="token comment">//C++的库函数</span>
<span class="token comment">//头文件  #include &lt;unistd.h&gt;</span>
<span class="token keyword">int</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/* (char *) NULL */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">-</span> 参数：
            <span class="token operator">-</span> path<span class="token operator">:</span>需要指定的执行的文件的路径或者名称
                a<span class="token punctuation">.</span>out <span class="token operator">/</span>home<span class="token operator">/</span>nowcoder<span class="token operator">/</span>a<span class="token punctuation">.</span>out 推荐使用绝对路径
                <span class="token punctuation">.</span><span class="token operator">/</span>a<span class="token punctuation">.</span>out hello world

            <span class="token operator">-</span> arg<span class="token operator">:</span>是执行可执行文件所需要的参数列表
                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称
                从第二个参数开始往后，就是程序执行所需要的的参数列表。
                参数最后需要以<span class="token constant">NULL</span>结束（哨兵）

        <span class="token operator">-</span> 返回值：
            只有当调用失败，才会有返回值，返回<span class="token operator">-</span><span class="token number">1</span>，并且设置errno
            如果调用成功，没有返回值。
            
<span class="token keyword">int</span> <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* (char *) NULL */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 	<span class="token operator">-</span> 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。
        <span class="token operator">-</span> 参数：
            <span class="token operator">-</span> file<span class="token operator">:</span>需要执行的可执行文件的文件名
                a<span class="token punctuation">.</span>out
                ps

            <span class="token operator">-</span> arg<span class="token operator">:</span>是执行可执行文件所需要的参数列表
                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称
                从第二个参数开始往后，就是程序执行所需要的的参数列表。
                参数最后需要以<span class="token constant">NULL</span>结束（哨兵）

        <span class="token operator">-</span> 返回值：
            只有当调用失败，才会有返回值，返回<span class="token operator">-</span><span class="token number">1</span>，并且设置errno
            如果调用成功，没有返回值。
            
<span class="token keyword">int</span> <span class="token function">execle</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/*, (char *) NULL, char * const envp[] */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execvpe</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//Linux的系统调用</span>
<span class="token keyword">int</span> <span class="token function">execve</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>exec函数族都以exec作前缀，那么后缀的意义是下面的解释，方便记忆：</p> 
<p>l(list) 参数地址列表，以空指针结尾<br> v(vector) 存有各参数地址的指针数组的地址<br> p(path) 按 PATH 环境变量指定的目录搜索可执行文件<br> e(environment) 存有环境变量字符串地址的指针数组的地址</p> 
<h2><a id="__234"></a>六、 进程控制</h2> 
<h3><a id="_235"></a>进程的退出</h3> 
<p>一共有两个函数，exit 和 _exit<code>（该函数是系统调用）</code>，子进程退出时，子进程只能回收用户区的资源，内核区的资源需要父进程回收。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span><span class="token comment">//标准C库的函数</span></span>
<span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span><span class="token comment">//Linux系统调用的函数</span></span>
<span class="token keyword">void</span> <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>

status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。
</code></pre> 
<p>exit() 函数的执行流程：<br> <mark>进程运行-&gt; exit() -&gt; 刷新I/O缓冲，关闭文件描述符 -&gt; 调用_exit() -&gt; 进程终止</mark><br> _exit() 函数的执行流程<br> <mark>进程运行 -&gt; 调用_exit() -&gt; 进程终止</mark></p> 
<ul><li><code>exit是系统调用级别的</code>，它表示了一个进程的结束，它将删除进程使用的内存空间，同时把错误信息返回父进程。</li><li><code>return</code>是语言级别的，表示返回到上一层的调用，即调用堆栈的返回，如果位于main函数中，两个都可以使用，但其实main函数会隐式调用exit().</li><li>父进程可以通过 <code>参数 status</code> 获取子进程退出时的信息。</li></ul> 
<h3><a id="_256"></a>孤儿进程</h3> 
<p>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init <code>（pid为 1 的进程，最最最老的系统进程，Linux系统的第一个进程，其他进程都是他创建的）</code>，而 init 进程会循环地 <code>wait()</code> 它的子进程（该孤儿进程）。这样，当一个孤儿进程结束生命周期的时候，init 进程就会出面处理它的一切善后工作。所以孤儿进程不会有什么危害。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 创建子进程</span>
    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 判断是父进程还是子进程</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i am parent process, pid : %d, ppid : %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 当前是子进程</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i am child process, pid : %d, ppid : %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       
    <span class="token punctuation">}</span>

    <span class="token comment">// for循环</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i : %d , pid : %d\n"</span><span class="token punctuation">,</span> i <span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>执行课程的代码，会出现下图的情况，原因是当前终端进程（tty）是 ./orphan 进程的父进程，父进程默认在前台执行并输出信息，父进程结束时，当前终端进程回收父进程的资源，并处于阻塞态，但是父进程创建了子进程，该子进程共享父进程的文件描述符信息，包括指向的终端（STDOUT_FILENO，标准输出），所以子进程会把信息输出到当前终端。<br> <img src="https://images2.imgbox.com/91/12/OtAxfceI_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_290"></a>僵尸进程</h3> 
<ul><li>每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。</li><li>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</li><li><code>僵尸进程不能被 kill -9 杀死</code>，这样就会导致一个问题，<code>如果父进程不调用 wait() 或 waitpid() 的话</code>，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</li></ul> 
<p>避免僵尸进程的方法：</p> 
<ul><li>杀死父进程，通过 kill 命令，开发时不可能这么做</li><li>调用 wait() 或者 waitpid()</li></ul> 
<h3><a id="_299"></a>进程回收</h3> 
<ul><li>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。</li><li>父进程可以通过调用 wait 或 waitpid 得到它的退出状态同时彻底清除掉这个进程。</li><li>wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数默认会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。</li><li>注意：一次 wait 或 waitpid 调用只能清理一个子进程，清理多个子进程应使用循环。</li></ul> 
<h4><a id="wait_305"></a>wait()</h4> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
pid_t <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>wstatus<span class="token punctuation">)</span><span class="token punctuation">;</span>
    功能：等待任意一个子进程结束，如果任意一个子进程结束了，该函数会回收子进程的资源。
    参数：<span class="token keyword">int</span> <span class="token operator">*</span>wstatus
        进程退出时的状态信息，传入的是一个<span class="token keyword">int</span>类型的地址，传出参数，函数执行的信息会写入到wstatus中。
    返回值：
        <span class="token operator">-</span> 成功：返回被回收的子进程的id
        <span class="token operator">-</span> 失败：<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">(</span>所有的子进程都结束，调用函数失败<span class="token punctuation">)</span>，两种情况
</code></pre> 
<p>调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.</p> 
<p>进程退出信息（wstatus）相关宏函数</p> 
<ul><li>WIFEXITED(status) 非0，进程正常退出</li><li>WEXITSTATUS(status) 如果上宏为真，获取进程退出的状态（exit的参数）</li><li>WIFSIGNALED(status) 非0，进程异常终止</li><li>WTERMSIG(status) 如果上宏为真，获取使进程终止的信号编号</li><li>WIFSTOPPED(status) 非0，进程处于暂停状态</li><li>WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号</li><li>WIFCONTINUED(status) 非0，进程暂停后已经继续运行</li></ul> 
<h4><a id="waitpid_328"></a>waitpid()</h4> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
pid_t <span class="token function">waitpid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>wstatus<span class="token punctuation">,</span> <span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
    功能：回收指定进程号的子进程，可以设置是否阻塞。
    参数：
        <span class="token operator">-</span> pid<span class="token operator">:</span>
            pid <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">:</span> 某个子进程的pid
            pid <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">:</span> 回收当前进程组的所有子进程    
            pid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> 回收所有的子进程，相当于 <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  （最常用）
            pid <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> 某个进程组的组id 等于 pid的绝对值，则回收其中的所有子进程
        <span class="token operator">-</span> options：设置阻塞或者非阻塞
            <span class="token number">0</span> <span class="token operator">:</span> 阻塞
            WNOHANG <span class="token operator">:</span> 非阻塞
        <span class="token operator">-</span> 返回值：
            <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">:</span> 返回子进程的id（当某个子进程被干掉的时候）
            <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">:</span> options<span class="token operator">=</span>WNOHANG<span class="token punctuation">,</span> 表示还有子进程存在（在运行）
            <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> ：错误，或者没有子进程了
</code></pre> 
<p><img src="https://images2.imgbox.com/9c/5f/AoTEmUV7_o.png" alt="在这里插入图片描述"><br> 当创建一个父进程的时候，会默认生成一个进程组，进程组名就是父进程的pid，进程组可以包含多个进程，父进程创建的子进程默认属于父进程的组，也可以指定子进程到别的进程组，如上图所示，pid&gt;0 和 pid = -1 的情况就不做介绍，当pid=0时，会释放父进程所在组的子进程（B、C），指定到其他组的子进程（D、E）不会释放，当 pid &lt; -1时，如果子进程D、E所在的进程组号为2，父进程 A 调用 waitpid(-2) ，因为 |-2|=2，那么进程组2中的 A 的所有子进程都会被释放，B、C进程不会释放。</p> 
<h3><a id="_352"></a>进程通信</h3> 
<ul><li>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</li><li>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )。</li><li>进程间通信的目的：<br> 数据传输：一个进程需要将它的数据发送给另一个进程。<br> 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。<br> 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。<br> 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。<mark>（陷入代表内中断，是CPU内部发生的中断，可是能由于程序自身产生的代码写错了；外中断是CPU对I/O设备发来的中断信号的响应。）</mark></li></ul> 
<p>进程间的通信报考以下几种方式：<br> <img src="https://images2.imgbox.com/80/8f/zf4TYrH4_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_363"></a>匿名管道</h3> 
<p>管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。管道的两端是两个文件描述符（fd[0]、fd[1]），fd[0] 是管道的写出端，fd[1] 是管道的写入端。</p> 
<blockquote> 
 <p>例如 统计一个目录中文件的数目命令：ls | wc –l，为了执行该命令，shell 创建了两个进程来分别执行 ls 和 wc。其中ls 和 wc中间的 <code>|</code> 代表管道符<br> <img src="https://images2.imgbox.com/16/71/bg75OAVB_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<ul><li>管道其实是一个在<code>内核内存</code>中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。</li><li>管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作。</li><li>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。</li><li>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。</li><li>在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。</li><li>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。</li><li>匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</li></ul> 
<h4><a id="_376"></a>管道的读写特点</h4> 
<p>使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作）</p> 
<ol><li> <p>所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。</p> </li><li> <p>如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</p> </li><li> <p>如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</p> </li><li> <p>如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，直到管道中有空位置才能再次写入数据并返回。</p> </li></ol> 
<h4><a id="_386"></a>创建匿名管道</h4> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    功能：创建一个匿名管道，用来进程间通信。
    参数：<span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> 这个数组是一个传出参数。
        pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> 对应的是管道的读端
        pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> 对应的是管道的写端
    返回值：
        成功 <span class="token number">0</span>
        失败 <span class="token operator">-</span><span class="token number">1</span>

管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞

注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）
</code></pre> 
<h4><a id="_404"></a>设置管道非阻塞</h4> 
<p>通过 fcntl 设置管道非阻塞。</p> 
<pre><code class="prism language-cpp">设置管道非阻塞
<span class="token keyword">int</span> flags <span class="token operator">=</span> <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取原来的flag</span>
flags <span class="token operator">|=</span> O_NONBLOCK<span class="token punctuation">;</span>            <span class="token comment">// 修改flag的值</span>
<span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 设置新的flag</span>
</code></pre> 
<h3><a id="_412"></a>有名管道</h3> 
<ul><li>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。</li><li>有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。</li><li>一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I/O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出。</li></ul> 
<p>有名管道和匿名管道的区别：</p> 
<ol><li>FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。</li><li>当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。</li><li>FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。</li></ol> 
<h4><a id="_421"></a>有名管道的使用</h4> 
<ul><li>通过命令创建有名管道</li></ul> 
<pre><code class="prism language-cpp"> mkfifo 名字
</code></pre> 
<ul><li>通过函数创建有名管道</li></ul> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>一旦使用 mkfifo 创建了一个 FIFO，就可以使用 open 打开它，常见的文件I/O 函数都可用于 fifo。如：close、read、write、unlink （删除文件）等。</li><li>FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek() 等文件定位操作。</li></ul> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    参数：
        <span class="token operator">-</span> pathname<span class="token operator">:</span> 管道名称的路径
        <span class="token operator">-</span> mode<span class="token operator">:</span> 文件的权限 和 open 的 mode 是一样的，是一个八进制的数（mode <span class="token operator">&amp;</span> <span class="token operator">~</span>umask 是最终权限）
    返回值：成功返回<span class="token number">0</span>，失败返回<span class="token operator">-</span><span class="token number">1</span>，并设置错误号
</code></pre> 
<p>两个代码一个执行有名管道的写操作，一个执行有名管道的读操作。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token comment">// 向管道中写数据</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 1.判断文件是否存在</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">access</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> F_OK<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"管道不存在，创建管道\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 2.创建管道文件</span>
        ret <span class="token operator">=</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token number">0664</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mkfifo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>       

    <span class="token punctuation">}</span>

    <span class="token comment">// 3.以只写的方式打开管道</span>
    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> O_WRONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 写数据</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"hello, %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write data : %s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>

<span class="token comment">// 从管道中读取数据</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 1.打开管道文件</span>
    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 读数据</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"写端断开连接了...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"recv buf : %s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code>有名管道的注意事项：
    1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道
    2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道

读管道：
    管道中有数据，read返回实际读到的字节数
    管道中无数据：
        管道写端被全部关闭，read返回0，（相当于读到文件末尾）
        写端没有全部被关闭，read阻塞等待

写管道：
    管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）
    管道读端没有全部关闭：
        管道已经满了，write会阻塞
        管道没有满，write将数据写入，并返回实际写入的字节数。
</code></pre> 
<h3><a id="_548"></a>内存映射</h3> 
<p>内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。内存映射除了进行进程通信外，还可以进行文件复制等功能。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> size_t length<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> off_t offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">-</span> 功能：将一个文件或者设备的数据映射到内存中
   <span class="token operator">-</span> 参数：
       <span class="token operator">-</span> <span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token operator">:</span> 设为<span class="token constant">NULL</span>即可<span class="token punctuation">,</span> 由内核指定并返回
       <span class="token operator">-</span> length <span class="token operator">:</span> 要映射的数据的长度，这个值不能为<span class="token number">0</span>。建议使用文件的长度。
               获取文件的长度：stat lseek
              	长度为Linux系统的页的整数倍，如果不够一页，会设为一页的长度，一般一页大小为<span class="token number">4</span>KB
       <span class="token operator">-</span> prot <span class="token operator">:</span> 对申请的内存映射区的操作权限
           <span class="token operator">-</span>PROT_EXEC ：可执行的权限
           <span class="token operator">-</span>PROT_READ ：读权限
           <span class="token operator">-</span>PROT_WRITE ：写权限
           <span class="token operator">-</span>PROT_NONE ：没有权限
           要操作映射内存，必须要有读的权限。
           PROT_READ、PROT_READ<span class="token operator">|</span>PROT_WRITE
       <span class="token operator">-</span> flags <span class="token operator">:</span>
           <span class="token operator">-</span> MAP_SHARED <span class="token operator">:</span> 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项
           <span class="token operator">-</span> MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）
       <span class="token operator">-</span> fd<span class="token operator">:</span> 需要映射的那个文件的文件描述符
           <span class="token operator">-</span> 通过open得到，open的是一个磁盘文件
           <span class="token operator">-</span> 注意：文件的大小不能为<span class="token number">0</span>，open指定的权限不能和prot参数有冲突。
               prot<span class="token operator">:</span> PROT_READ                open<span class="token operator">:</span>只读<span class="token operator">/</span>读写 
               prot<span class="token operator">:</span> PROT_READ <span class="token operator">|</span> PROT_WRITE   open<span class="token operator">:</span>读写
       <span class="token operator">-</span> offset：偏移量，一般不用。必须指定的是<span class="token number">4</span>k的整数倍，<span class="token number">0</span>表示不偏移。
   <span class="token operator">-</span> 返回值：返回创建的内存的首地址
       失败返回MAP_FAILED，<span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span>

<span class="token keyword">int</span> <span class="token function">munmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> size_t length<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">-</span> 功能：释放内存映射
   <span class="token operator">-</span> 参数：
       <span class="token operator">-</span> addr <span class="token operator">:</span> 要释放的内存的首地址
       <span class="token operator">-</span> length <span class="token operator">:</span> 要释放的内存的大小，要和mmap函数中的length参数的值一样。
</code></pre> 
<p><code>void * ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</code>可以实现匿名映射，即不需要磁盘文件，也不需要文件描述符，这种映射只能实现<code>有关系的进程的通信</code>。主要区别在于后三个参数，具体含义一看懂。内存映射区的两种通信方式：</p> 
<ol><li>有关系的进程（父子进程）</li></ol> 
<blockquote> 
 <ul><li>准备一个大小不是0的磁盘文件</li><li>还没有子进程的时候</li><li>通过唯一的父进程，先创建内存映射区</li><li>有了内存映射区以后，创建子进程</li><li>父子进程共享创建的内存映射区</li></ul> 
</blockquote> 
<ol start="2"><li>没有关系的进程间通信</li></ol> 
<blockquote> 
 <ul><li>准备一个大小不是0的磁盘文件</li><li>进程1 通过磁盘文件创建内存映射区 
   <ul><li>得到一个操作这块内存的指针</li></ul> </li><li>进程2 通过磁盘文件创建内存映射区 
   <ul><li>得到一个操作这块内存的指针</li></ul> </li><li>使用内存映射区通信</li></ul> 
</blockquote> 
<pre><code>注意：内存映射区通信，是非阻塞。.
</code></pre> 
<p>内存映射的注意事项：</p> 
<pre><code class="prism language-cpp"><span class="token number">1.</span>如果对mmap的返回值<span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>做<span class="token operator">++</span>操作<span class="token punctuation">(</span>ptr<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">,</span> munmap是否能够成功<span class="token operator">?</span>
	<span class="token keyword">void</span> <span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ptr<span class="token operator">++</span><span class="token punctuation">;</span>  可以对其进行<span class="token operator">++</span>操作
	<span class="token function">munmap</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 错误,要从内存映射的首地址开始释放</span>

<span class="token number">2.</span>如果open时O_RDONLY<span class="token punctuation">,</span> mmap时prot参数指定PROT_READ <span class="token operator">|</span> PROT_WRITE会怎样<span class="token operator">?</span>
	错误，返回MAP_FAILED
	<span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span>函数中的权限建议和prot参数的权限保持一致。

<span class="token number">3.</span>如果文件偏移量为<span class="token number">1000</span>会怎样<span class="token operator">?</span>
	偏移量必须是<span class="token number">4</span>KB的整数倍，返回MAP_FAILED，Linux系统一页的内存默认是<span class="token number">4</span>KB，不同系统可能不一样

<span class="token number">4.</span>mmap什么情况下会调用失败<span class="token operator">?</span>
    <span class="token operator">-</span> 第二个参数：length <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token operator">-</span> 第三个参数：prot
        <span class="token operator">-</span> 只指定了写权限
        <span class="token operator">-</span> prot PROT_READ <span class="token operator">|</span> PROT_WRITE
          第<span class="token number">5</span>个参数fd 通过open函数时指定的 O_RDONLY <span class="token operator">/</span> O_WRONLY

<span class="token number">5.</span>可以open的时候O_CREAT一个新文件来创建映射区吗<span class="token operator">?</span>
    <span class="token operator">-</span> 可以的，但是创建的文件的大小如果为<span class="token number">0</span>的话，肯定不行
    <span class="token operator">-</span> 可以对新的文件进行扩展
        <span class="token operator">-</span> <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token operator">-</span> <span class="token function">truncate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token number">6.</span>mmap后关闭文件描述符，对mmap映射有没有影响？
    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"XXX"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token punctuation">,</span><span class="token punctuation">,</span><span class="token punctuation">,</span><span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    映射区还存在，创建映射区的fd被关闭，没有任何影响，mmap对fd进行了 copy。

<span class="token number">7.</span>对ptr越界操作会怎样？
	<span class="token keyword">void</span> <span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span><span class="token punctuation">,</span><span class="token punctuation">,</span><span class="token punctuation">,</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	内存映射的大小，是一页的大小的整数倍（一页默认为<span class="token number">4</span>K）
	越界操作操作的是非法的内存 <span class="token operator">-&gt;</span> 段错误
</code></pre> 
<h3><a id="_643"></a>信号</h3> 
<p>信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下：</p> 
<ol><li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C 通常会给进程发送一个中断信号。</li><li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。</li><li>系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，或者进程执行的 CPU 时间超限，或者该进程的某个子进程退出。</li><li>运行 kill 命令或调用 kill 函数。</li></ol> 
<p>使用信号的两个主要目的是：</p> 
<ol><li>让进程知道已经发生了一个特定的事情。</li><li>强迫进程执行它自己代码中的信号处理程序。</li></ol> 
<p>信号的特点：</p> 
<ol><li>简单</li><li>不能携带大量信息</li><li>满足某个特定条件才发送</li><li>优先级比较高</li></ol> 
<p>查看系统定义的信号列表：kill -l，前 31 个信号为常规信号，其余为实时信号，查看信号的详细信息：man 7 signal。信号的几种状态：<code>产生、未决、递达</code>。SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。信号的 5 中默认处理动作：</p> 
<blockquote> 
 <p>1、Term 终止进程<br> 2、 Ign 当前进程忽略掉这个信号<br> 3、 core 终止进程，并生成一个Core文件，使用core文件需要首先打开core文件的权限（通过命令ulimit -c 文件大小），然后在编译的时候使用<code>-g</code>命令，在gdb调试的时候，使用<code>core-file core文件名</code>即可查看core文件内容。<br> 4、 Stop 暂停当前进程<br> 5、 cont 继续执行当前被暂停的进程</p> 
</blockquote> 
<table><thead><tr><th>编号</th><th>信号名称</th><th>对应事件</th><th>默认动作</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>用户退出shell时，由该shell启动的所有进程将收到这个信号</td><td>终止进程</td></tr><tr><td>2</td><td><code>SIGINT</code></td><td>当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号</td><td>终止进程</td></tr><tr><td>3</td><td><code>SIGQUIT</code></td><td>用户按下&lt;Ctrl+\&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出此信号</td><td>终止进程</td></tr><tr><td>4</td><td>SIGILL</td><td>CPU检测到某进程执行了非法指令</td><td>终止进程并产生core文件</td></tr><tr><td>5</td><td>SIGTRAP</td><td>该信号由断点指令或其他 trap指令产生</td><td>终止进程并产生core文件</td></tr><tr><td>6</td><td>SIGABRT</td><td>调用abort函数时产生该信号</td><td>终止进程并产生core文件</td></tr><tr><td>7</td><td>SIGBUS</td><td>非法访问内存地址，包括内存对齐出错</td><td>终止进程并产生core文件</td></tr><tr><td>8</td><td>SIGFPE</td><td>在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误</td><td>终止进程并产生core文件</td></tr><tr><td>9</td><td><code>SIGKILL</code></td><td>无条件终止进程。该信号不能被忽略，处理和阻塞</td><td>终止进程，可以杀死任何进程</td></tr><tr><td>10</td><td>SIGUSE1</td><td>用户定义的信号。即程序员可以在程序中定义并使用该信号</td><td>终止进程</td></tr><tr><td>11</td><td><code>SIGSEGV</code></td><td>指示进程进行了无效内存访问(段错误)</td><td>终止进程并产生core文件</td></tr><tr><td>12</td><td>SIGUSR2</td><td>另外一个用户自定义信号，程序员可以在程序中定义并使用该信号</td><td>终止进程</td></tr><tr><td>13</td><td><code>SIGPIPE</code></td><td>Broken pipe向一个没有读端的管道写数据</td><td>终止进程</td></tr><tr><td>14</td><td><code>SIGALARM</code></td><td>定时器超时，超时的时间 由系统调用alarm设置</td><td>终止进程</td></tr><tr><td>15</td><td>SIGTERM</td><td>程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号</td><td>终止进程</td></tr><tr><td>16</td><td>SIGSTKFLT</td><td>Linux早期版本出现的信号，现仍保留向后兼容</td><td>终止进程</td></tr><tr><td>17</td><td><code>SIGCHLD</code></td><td>子进程结束时，父进程会收到这个信号</td><td>忽略这个信号</td></tr><tr><td>18</td><td><code>SIGCONT</code></td><td>如果进程已停止，则使其继续运行</td><td>继续/忽略</td></tr><tr><td>19</td><td><code>SIGSTOP</code></td><td>停止进程的执行。信号不能被忽略，处理和阻塞</td><td>终止进程</td></tr><tr><td>20</td><td>SIGTSTP</td><td>停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号</td><td>暂停进程</td></tr><tr><td>21</td><td>SIGTTIN</td><td>后台进程读终端控制台</td><td>暂停进程</td></tr><tr><td>22</td><td>SIGTTOU</td><td>该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生</td><td>暂停进程</td></tr><tr><td>23</td><td>SIGURG</td><td>套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达</td><td>忽略该信号</td></tr><tr><td>24</td><td>SIGXCPU</td><td>进程执行时间超过了分配给该进程的CPU时间，系统产生该信号并发送给该进程</td><td>终止进程</td></tr><tr><td>25</td><td>SIGXFSZ</td><td>超过文件的最大长度设置</td><td>终止进程</td></tr><tr><td>26</td><td>SIGVTALRM</td><td>虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间</td><td>终止进程</td></tr><tr><td>27</td><td>SGIPROF</td><td>类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间</td><td>终止进程</td></tr><tr><td>28</td><td>SIGWINCH</td><td>窗口变化大小时发出</td><td>忽略该信号</td></tr><tr><td>29</td><td>SIGIO</td><td>此信号向进程指示发出了一个异步IO事件</td><td>忽略该信号</td></tr><tr><td>30</td><td>SIGPWR</td><td>关机</td><td>终止进程</td></tr><tr><td>31</td><td>SIGSYS</td><td>无效的系统调用</td><td>终止进程并产生core文件</td></tr><tr><td>34~64</td><td>SIGRTMIN ～SIGRTMAX</td><td>LINUX的实时信号，它们没有固定的含义（可以由用户自定义）</td><td>终止进程</td></tr></tbody></table> 
<h4><a id="_705"></a>发送信号相关的函数：</h4> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">kill</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">-</span> 功能：给任何的进程或者进程组pid<span class="token punctuation">,</span> 发送任何的信号 sig
        <span class="token operator">-</span> 参数：
            <span class="token operator">-</span> pid ：
                <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">:</span> 将信号发送给指定的进程
                <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">:</span> 将信号发送给当前的进程组
                <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> 将信号发送给每一个有权限接收这个信号的进程
                <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> 发送给某个进程组，这个进程组号<span class="token operator">=</span>pid取反 （<span class="token operator">-</span><span class="token number">12345</span>）
            <span class="token operator">-</span> sig <span class="token operator">:</span> 需要发送的信号的编号或者是宏值，<span class="token number">0</span>表示不发送任何信号
       <span class="token operator">-</span> 返回值：
	       <span class="token operator">-</span> 成功 <span class="token number">0</span>
	       <span class="token operator">-</span> 失败 非<span class="token number">0</span>

<span class="token keyword">int</span> <span class="token function">raise</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">-</span> 功能：给当前进程发送信号
   <span class="token operator">-</span> 参数：
       <span class="token operator">-</span> sig <span class="token operator">:</span> 要发送的信号
   <span class="token operator">-</span> 返回值：
       <span class="token operator">-</span> 成功 <span class="token number">0</span>
       <span class="token operator">-</span> 失败 非<span class="token number">0</span>
       
<span class="token keyword">void</span> <span class="token function">abort</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">-</span> 功能： 发送SIGABRT信号给当前的进程，杀死当前进程
    <span class="token function">kill</span><span class="token punctuation">(</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SIGABRT<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_734"></a>定时器函数</h4> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">-</span> 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为<span class="token number">0</span>的时候<span class="token punctuation">,</span>
    		函数会给当前的进程发送一个信号：SIGALARM
    		该函数是非阻塞的
    <span class="token operator">-</span> 参数：
        seconds<span class="token operator">:</span> 倒计时的时长，单位：秒。如果参数为<span class="token number">0</span>，定时器无效（不进行倒计时，不发信号）。
                取消一个定时器，通过<span class="token function">alarm</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>。
    <span class="token operator">-</span> 返回值：
        <span class="token operator">-</span> 之前没有定时器，返回<span class="token number">0</span>
        <span class="token operator">-</span> 之前有定时器，返回之前的定时器剩余的时间

	<span class="token operator">-</span> SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。
	    <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">-&gt;</span> 返回<span class="token number">0</span>
	    过了<span class="token number">1</span>秒
	    <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">-&gt;</span> 上一个定时器失效，并返回<span class="token number">9</span>

 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/time.h&gt;</span></span>
 <span class="token keyword">int</span> <span class="token function">setitimer</span><span class="token punctuation">(</span><span class="token keyword">int</span> which<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">itimerval</span> <span class="token operator">*</span>new_value<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">itimerval</span> <span class="token operator">*</span>old_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token operator">-</span> 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时
     		该函数是非阻塞的
     <span class="token operator">-</span> 参数：
         <span class="token operator">-</span> which <span class="token operator">:</span> 定时器以什么时间计时
         	   <span class="token comment">//进程时间 = 用户时间 + 内核时间 + I/O时间 </span>
	           ITIMER_REAL<span class="token operator">:</span> 真实时间，时间到达，发送 SIGALRM   常用
	           ITIMER_VIRTUAL<span class="token operator">:</span> 用户时间，时间到达，发送 SIGVTALRM
	           ITIMER_PROF<span class="token operator">:</span> 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF

         <span class="token operator">-</span> new_value<span class="token operator">:</span> 设置定时器的属性
         
             <span class="token keyword">struct</span> <span class="token class-name">itimerval</span> <span class="token punctuation">{<!-- --></span>      <span class="token comment">// 定时器的结构体</span>
             <span class="token keyword">struct</span> <span class="token class-name">timeval</span> it_interval<span class="token punctuation">;</span>  <span class="token comment">// 每个阶段的时间，（两个定时器之间的）间隔时间</span>
             <span class="token keyword">struct</span> <span class="token class-name">timeval</span> it_value<span class="token punctuation">;</span>     <span class="token comment">// 延迟多长时间执行定时器（定时间倒计时时间）</span>
             <span class="token punctuation">}</span><span class="token punctuation">;</span>

             <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token punctuation">{<!-- --></span>        <span class="token comment">// 时间的结构体</span>
                 time_t      tv_sec<span class="token punctuation">;</span>     <span class="token comment">//  秒数     </span>
                 suseconds_t tv_usec<span class="token punctuation">;</span>    <span class="token comment">//  微秒    </span>
             <span class="token punctuation">}</span><span class="token punctuation">;</span>
        
         <span class="token operator">-</span> old_value ：记录上一次的定时的时间参数，一般不使用，指定<span class="token constant">NULL</span>
     
     <span class="token operator">-</span> 返回值：
         成功 <span class="token number">0</span>
         失败 <span class="token operator">-</span><span class="token number">1</span> 并设置错误号
</code></pre> 
<h4><a id="_783"></a>信号捕捉函数</h4> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sighandler_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sighandler_t <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> sighandler_t handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">-</span> 功能：设置某个信号的捕捉行为
    <span class="token operator">-</span> 参数：
        <span class="token operator">-</span> signum<span class="token operator">:</span> 要捕捉的信号
        <span class="token operator">-</span> handler<span class="token operator">:</span> 捕捉到信号要如何处理
            <span class="token operator">-</span> SIG_IGN ： 忽略信号
            <span class="token operator">-</span> SIG_DFL ： 使用信号默认的行为
            <span class="token operator">-</span> 回调函数 <span class="token operator">:</span>  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。
            回调函数：
                <span class="token operator">-</span> 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义
                <span class="token operator">-</span> 不是程序员调用，而是当信号产生，由内核调用
                <span class="token operator">-</span> 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。

    <span class="token operator">-</span> 返回值：
        成功，返回上一次注册的信号处理函数的地址。第一次调用返回<span class="token constant">NULL</span>
        失败，返回SIG_ERR，设置错误号
        
SIGKILL SIGSTOP不能被捕捉，不能被忽略。
</code></pre> 
<h4><a id="_807"></a>信号集</h4> 
<ul><li>许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。</li><li>在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为“未决信号集” 。这两个信号集都是内核使用位图机制（二进制位）来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改（<code>产生的信号默认放到未决信号集中，我们只能获取未决信号集，而不能设置；操作的信号集其实只有阻塞信号集</code>）。</li><li>信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。</li><li>信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。</li><li>信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。</li></ul> 
<p>信号的处理流程</p> 
<pre><code class="prism language-cpp"><span class="token number">1.</span>用户通过键盘  Ctrl <span class="token operator">+</span> C<span class="token punctuation">,</span> 产生<span class="token number">2</span>号信号<span class="token function">SIGINT</span> <span class="token punctuation">(</span>信号被创建<span class="token punctuation">)</span>

<span class="token number">2.</span>信号产生但是没有被处理 （未决）
    <span class="token operator">-</span> 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）
    <span class="token operator">-</span> SIGINT信号状态被存储在第二个标志位上
        <span class="token operator">-</span> 这个标志位的值为<span class="token number">0</span>， 说明信号不是未决状态
        <span class="token operator">-</span> 这个标志位的值为<span class="token number">1</span>， 说明信号处于未决状态
    
<span class="token number">3.</span>这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较
    <span class="token operator">-</span> 阻塞信号集默认不阻塞任何的信号
    <span class="token operator">-</span> 如果想要阻塞某些信号需要用户调用系统的API
    	这个标志位的值为<span class="token number">0</span>， 说明信号不阻塞
        这个标志位的值为<span class="token number">1</span>， 说明信号阻塞

<span class="token number">4.</span>在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了
    <span class="token operator">-</span> 如果没有阻塞，这个信号就被处理
    <span class="token operator">-</span> 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理
</code></pre> 
<p>以下信号集相关的函数都是对自定义的信号集进行操作。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">sigemptyset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">-</span> 功能：清空信号集中的数据<span class="token punctuation">,</span>将信号集中的所有的标志位 置为<span class="token number">0</span>
    <span class="token operator">-</span> 参数：set<span class="token punctuation">,</span>传出参数，需要操作的信号集
    <span class="token operator">-</span> 返回值：成功返回<span class="token number">0</span>， 失败返回<span class="token operator">-</span><span class="token number">1</span>

<span class="token keyword">int</span> <span class="token function">sigfillset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">-</span> 功能：将信号集中的所有的标志位置为<span class="token number">1</span>
    <span class="token operator">-</span> 参数：set<span class="token punctuation">,</span>传出参数，需要操作的信号集
    <span class="token operator">-</span> 返回值：成功返回<span class="token number">0</span>， 失败返回<span class="token operator">-</span><span class="token number">1</span>

<span class="token keyword">int</span> <span class="token function">sigaddset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">-</span> 功能：设置信号集中的某一个信号对应的标志位为<span class="token number">1</span>，表示阻塞这个信号
    <span class="token operator">-</span> 参数：
        <span class="token operator">-</span> set：传出参数，需要操作的信号集
        <span class="token operator">-</span> signum：需要设置阻塞的那个信号
    <span class="token operator">-</span> 返回值：成功返回<span class="token number">0</span>， 失败返回<span class="token operator">-</span><span class="token number">1</span>

<span class="token keyword">int</span> <span class="token function">sigdelset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">-</span> 功能：设置信号集中的某一个信号对应的标志位为<span class="token number">0</span>，表示不阻塞这个信号
    <span class="token operator">-</span> 参数：
        <span class="token operator">-</span> set：传出参数，需要操作的信号集
        <span class="token operator">-</span> signum：需要设置不阻塞的那个信号
    <span class="token operator">-</span> 返回值：成功返回<span class="token number">0</span>， 失败返回<span class="token operator">-</span><span class="token number">1</span>

<span class="token keyword">int</span> <span class="token function">sigismember</span><span class="token punctuation">(</span><span class="token keyword">const</span> sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">-</span> 功能：判断某个信号是否阻塞
    <span class="token operator">-</span> 参数：
        <span class="token operator">-</span> set：需要操作的信号集
        <span class="token operator">-</span> signum：需要判断的那个信号
    <span class="token operator">-</span> 返回值：
        <span class="token number">1</span> ： signum被阻塞
        <span class="token number">0</span> ： signum不阻塞
        <span class="token operator">-</span><span class="token number">1</span> ： 失败
</code></pre> 
<p>系统调用操作PCB中的两个信号集：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">sigprocmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> how<span class="token punctuation">,</span> <span class="token keyword">const</span> sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> sigset_t <span class="token operator">*</span>oldset<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">-</span> 功能：将自定义信号集中的数据设置到内核中的阻塞信号集（设置阻塞，解除阻塞，替换）
   <span class="token operator">-</span> 参数：
       <span class="token operator">-</span> how <span class="token operator">:</span> 如何对内核阻塞信号集进行处理
           SIG_BLOCK<span class="token operator">:</span> 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变
               假设内核中默认的阻塞信号集是mask， mask <span class="token operator">|</span> set
           SIG_UNBLOCK<span class="token operator">:</span> 根据用户设置的数据，对内核中的数据进行解除阻塞
               mask <span class="token operator">&amp;=</span> <span class="token operator">~</span>set
           SIG_SETMASK<span class="token operator">:</span>覆盖内核中原来的值
       
       <span class="token operator">-</span> set ：已经初始化好的用户自定义的信号集
       <span class="token operator">-</span> oldset <span class="token operator">:</span> 保存设置之前的内核中的阻塞信号集的状态，可以是 <span class="token constant">NULL</span>
   <span class="token operator">-</span> 返回值：
       成功：<span class="token number">0</span>
       失败：<span class="token operator">-</span><span class="token number">1</span>
           设置错误号：EFAULT（指向错误地址）、EINVAL（how是非法的）

<span class="token keyword">int</span> <span class="token function">sigpending</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">-</span> 功能：获取内核中的未决信号集
   <span class="token operator">-</span> 参数：set<span class="token punctuation">,</span>传出参数，保存的是内核中的未决信号集中的信息。
</code></pre> 
<h4><a id="sigaction_895"></a>sigaction信号捕捉函数</h4> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>act<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>oldact<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">-</span> 功能：检查或者改变信号的处理。信号捕捉
    <span class="token operator">-</span> 参数：
        <span class="token operator">-</span> signum <span class="token operator">:</span> 需要捕捉的信号的编号或者宏值（信号的名称）
        <span class="token operator">-</span> act ：捕捉到信号之后的处理动作
        <span class="token operator">-</span> oldact <span class="token operator">:</span> 上一次对信号捕捉相关的设置，一般不使用，传递<span class="token constant">NULL</span>
    <span class="token operator">-</span> 返回值：
        成功 <span class="token number">0</span>
        失败 <span class="token operator">-</span><span class="token number">1</span>

	 <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token punctuation">{<!-- --></span>
	    <span class="token comment">// 函数指针，指向的函数就是信号捕捉到之后的处理函数</span>
	    <span class="token keyword">void</span>     <span class="token punctuation">(</span><span class="token operator">*</span>sa_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token comment">// 不常用</span>
	    <span class="token keyword">void</span>     <span class="token punctuation">(</span><span class="token operator">*</span>sa_sigaction<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> siginfo_t <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。</span>
	    sigset_t   sa_mask<span class="token punctuation">;</span>
	    <span class="token comment">// 使用哪一个信号处理对捕捉到的信号进行处理</span>
	    <span class="token comment">// 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span>
	    <span class="token keyword">int</span>        sa_flags<span class="token punctuation">;</span>
	    <span class="token comment">// 被废弃掉了</span>
	    <span class="token keyword">void</span>     <span class="token punctuation">(</span><span class="token operator">*</span>sa_restorer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f8/f7/STwKFGAe_o.png" alt="在这里插入图片描述"><br> 信号捕捉的特性：</p> 
<ol><li>信号捕捉的处理过程中，使用临时阻塞信号集，处理完毕使用内核中的阻塞信号集，信号处理过程中，再产生一个信号，新产生的信号只能等上个信号处理完毕再被处理。</li><li>前31个信号不支持排队，如果又产生多个某信号，只会被处理一次</li></ol> 
<p>SIGCHLD信号产生的条件。</p> 
<blockquote> 
 <p>1、子进程终止时<br> 2、子进程接收到 SIGSTOP 信号停止时 <br> 3、子进程处在停止态，接受到SIGCONT后唤醒时</p> 
</blockquote> 
<p>以上三种条件都会给父进程发送 SIGCHLD 信号，父进程默认会忽略该信号，通过该信号可以回收子进程资源，解决僵尸进程代码，仅作参考。</p> 
<pre><code class="prism language-cpp"><span class="token comment">/* 
    使用SIGCHLD信号解决僵尸进程的问题。
*/</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">myFun</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"捕捉到的信号 ：%d\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 回收子进程PCB的资源</span>
    <span class="token comment">// while(1) {<!-- --></span>
    <span class="token comment">//     wait(NULL); </span>
    <span class="token comment">// }</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
       <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
           <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child die , pid = %d\n"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
           <span class="token comment">// 说明还有子进程或者</span>
           <span class="token keyword">break</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
           <span class="token comment">// 没有子进程</span>
           <span class="token keyword">break</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 提前设置好阻塞信号集，阻塞SIGCHLD，因为有可能子进程很快结束，父进程还没有注册完信号捕捉</span>
    sigset_t set<span class="token punctuation">;</span>
    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>set<span class="token punctuation">,</span> SIGCHLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>set<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 创建一些子进程</span>
    pid_t pid<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 父进程</span>

        <span class="token comment">// 捕捉子进程死亡时发送的SIGCHLD信号</span>
        <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> act<span class="token punctuation">;</span>
        act<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        act<span class="token punctuation">.</span>sa_handler <span class="token operator">=</span> myFun<span class="token punctuation">;</span>
        <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>act<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sigaction</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> <span class="token operator">&amp;</span>act<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 注册完信号捕捉以后，解除阻塞</span>
        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_UNBLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>set<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent process pid : %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 子进程</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child process pid : %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_1010"></a>共享内存</h3> 
<ul><li>共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会成为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</li><li>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。</li></ul> 
<p>共享内存的使用步骤：</p> 
<ul><li>调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。</li><li>使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。</li><li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。</li><li>调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。</li><li>调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。</li></ul> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">-</span> 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识，新创建的内存段中的数据都会被初始化为<span class="token number">0</span>
    <span class="token operator">-</span> 参数：
        <span class="token operator">-</span> key <span class="token operator">:</span> key_t类型是一个整形，通过这个找到或者创建一个共享内存。
                一般使用<span class="token number">16</span>进制表示，非<span class="token number">0</span>值<span class="token punctuation">(</span><span class="token number">0</span>代表标记删除，但是还没删除<span class="token punctuation">)</span>
        <span class="token operator">-</span> size<span class="token operator">:</span> 共享内存的大小
        <span class="token operator">-</span> shmflg<span class="token operator">:</span> 属性
            <span class="token operator">-</span> 访问权限
            <span class="token operator">-</span> 附加属性：创建<span class="token operator">/</span>判断共享内存是不是存在
                <span class="token operator">-</span> 创建：IPC_CREAT
                <span class="token operator">-</span> 判断共享内存是否存在： IPC_EXCL <span class="token punctuation">,</span> 需要和IPC_CREAT一起使用
                    IPC_CREAT <span class="token operator">|</span> IPC_EXCL <span class="token operator">|</span> <span class="token number">0664</span>
        <span class="token operator">-</span> 返回值：
            失败：<span class="token operator">-</span><span class="token number">1</span> 并设置错误号
            成功：<span class="token operator">&gt;</span><span class="token number">0</span> 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。


<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>shmaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">-</span> 功能：和当前的进程进行关联
    <span class="token operator">-</span> 参数：
        <span class="token operator">-</span> shmid <span class="token operator">:</span> 共享内存的标识（ID）<span class="token punctuation">,</span>由shmget返回值获取
        <span class="token operator">-</span> shmaddr<span class="token operator">:</span> 申请的共享内存的起始地址，指定<span class="token constant">NULL</span>，内核指定
        <span class="token operator">-</span> shmflg <span class="token operator">:</span> 对共享内存的操作
            <span class="token operator">-</span> 读 ： SHM_RDONLY<span class="token punctuation">,</span> 必须要有读权限
            <span class="token operator">-</span> 读写： <span class="token number">0</span>
    <span class="token operator">-</span> 返回值：
        成功：返回共享内存的首（起始）地址。  失败<span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span>


<span class="token keyword">int</span> <span class="token function">shmdt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>shmaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">-</span> 功能：解除当前进程和共享内存的关联
    <span class="token operator">-</span> 参数：
        shmaddr：共享内存的首地址
    <span class="token operator">-</span> 返回值：成功 <span class="token number">0</span>， 失败 <span class="token operator">-</span><span class="token number">1</span>

<span class="token keyword">int</span> <span class="token function">shmctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">-</span> 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，
    		创建共享内存的进程被销毁了对共享内存是没有任何影响。
    <span class="token operator">-</span> 参数：
        <span class="token operator">-</span> shmid<span class="token operator">:</span> 共享内存的ID
        <span class="token operator">-</span> cmd <span class="token operator">:</span> 要做的操作
            <span class="token operator">-</span> IPC_STAT <span class="token operator">:</span> 获取共享内存的当前的状态
            <span class="token operator">-</span> IPC_SET <span class="token operator">:</span> 设置共享内存的状态
            <span class="token operator">-</span> IPC_RMID<span class="token operator">:</span> 标记共享内存被销毁
        <span class="token operator">-</span> buf：需要设置或者获取的共享内存的属性信息
            <span class="token operator">-</span> IPC_STAT <span class="token operator">:</span> buf存储数据
            <span class="token operator">-</span> IPC_SET <span class="token operator">:</span> buf中需要初始化数据，设置到内核中
            <span class="token operator">-</span> IPC_RMID <span class="token operator">:</span> 没有用，<span class="token constant">NULL</span>

key_t <span class="token function">ftok</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> proj_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">-</span> 功能：根据指定的路径名，和<span class="token keyword">int</span>值，生成一个共享内存的key（shmget的一个参数）
    <span class="token operator">-</span> 参数：
        <span class="token operator">-</span> pathname<span class="token operator">:</span>指定一个存在的路径
        <span class="token operator">-</span> proj_id<span class="token operator">:</span> <span class="token keyword">int</span>类型的值，但是这系统调用只会使用其中的<span class="token number">1</span>个字节
                   范围 ： <span class="token number">0</span><span class="token operator">-</span><span class="token number">255</span>  一般指定一个字符 <span class="token char">'a'</span>
</code></pre> 
<pre><code class="prism language-cpp">问题<span class="token number">1</span>：操作系统如何知道一块共享内存被多少个进程关联？
    <span class="token operator">-</span> 共享内存维护了一个结构体<span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> 这个结构体中有一个成员 shm_nattch
    <span class="token operator">-</span> shm_nattach 记录了关联的进程个数

问题<span class="token number">2</span>：可不可以对共享内存进行多次删除 shmctl
    <span class="token operator">-</span> 可以的
    <span class="token operator">-</span> 因为shmctl 标记删除共享内存，不是直接删除
    <span class="token operator">-</span> 什么时候真正删除呢<span class="token operator">?</span>
        当和共享内存关联的进程数为<span class="token number">0</span>的时候，就真正被删除
    <span class="token operator">-</span> 当共享内存的key为<span class="token number">0</span>的时候，表示共享内存被标记删除了
        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。

    共享内存和内存映射的区别
    <span class="token number">1.</span>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）
    <span class="token number">2.</span>共享内存效果更高
    <span class="token number">3.</span>内存
        所有的进程操作的是同一块共享内存。
        内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。
    <span class="token number">4.</span>数据安全
        <span class="token operator">-</span> 进程突然退出
            共享内存还存在
            内存映射区消失
        <span class="token operator">-</span> 运行进程的电脑死机，宕机了
            数据存在在共享内存中，没有了
            内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。

    <span class="token number">5.</span>生命周期
        <span class="token operator">-</span> 内存映射区：进程退出，内存映射区销毁
        <span class="token operator">-</span> 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为<span class="token number">0</span>），或者关机
            如果一个进程退出，会自动和共享内存进行取消关联。
            当共享内存的关联进程为<span class="token number">0</span>时（最后一个关联的进程也退出了，即使该进程没有调用shmctl函数），
            共享内存也会被销毁
</code></pre> 
<p>共享内存操作命令<br> ipcs 用法</p> 
<ul><li>ipcs -a // 打印当前系统中所有的进程间通信方式的信息</li><li>ipcs -m // 打印出使用共享内存进行进程间通信的信息</li><li>ipcs -q // 打印出使用消息队列进行进程间通信的信息</li><li>ipcs -s // 打印出使用信号进行进程间通信的信息</li></ul> 
<p>ipcrm 用法</p> 
<ul><li>ipcrm -M shmkey // 移除用shmkey创建的共享内存段</li><li>ipcrm -m shmid // 移除用shmid标识的共享内存段</li><li>ipcrm -Q msgkey // 移除用msqkey创建的消息队列</li><li>ipcrm -q msqid // 移除用msqid标识的消息队列</li><li>ipcrm -S semkey // 移除用semkey创建的信号</li><li>ipcrm -s semid // 移除用semid标识的信号</li></ul> 
<h3><a id="_1130"></a>消息队列</h3> 
<p>消息队列就是在<code>内存</code>中创建一个区域，该形式为<code>链表形式</code>，支持进程的双向通信。消息队列用一个key进行标识，和共享内存类似，发送的数据类型需要自己定义，而且定义了自己的消息发送和接收函数，在System V 中这两个函数是 msgsnd/msgrcv。具体的API，我不写了，参考下面这两篇博客。<br> <a href="https://blog.csdn.net/xiupong/article/details/119294239">进程间的通讯：消息队列</a><br> <a href="https://blog.csdn.net/JACKSONMHLK/article/details/125018474">进程间通信方式</a></p> 
<h3><a id="_1135"></a>守护进程</h3> 
<h4><a id="_1136"></a>进程组和会话</h4> 
<ul><li>在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成为 shell 进程的控制终端（Controlling Terminal），进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其它进程的控制终端也是这个终端。</li><li>默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</li><li>在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 Ctrl + C 会产生 SIGINT 信号，Ctrl + \ 会产生 SIGQUIT 信号。</li><li>进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，会话是一组相关进程组的集合。进程组和会话是为支持 shell 作业控制而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。</li><li>进行组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程会继承其父进程所属的进程组 ID</li><li>进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。</li><li>会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会话 ID。新进程会继承其父进程的会话 ID。</li><li>一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。</li><li>在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</li><li>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</li></ul> 
<h4><a id="_1147"></a>进程组、会话操作函数</h4> 
<pre><code class="prism language-cpp">pid_t <span class="token function">getpgrp</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pid_t <span class="token function">getpgid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">setpgid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> pid_t pgid<span class="token punctuation">)</span><span class="token punctuation">;</span>
pid_t <span class="token function">getsid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
pid_t <span class="token function">setsid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_1155"></a>守护进程</h4> 
<ul><li>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。</li><li>守护进程具备下列特征：<br> 1、 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。<br> 2、 它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。</li><li>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。</li></ul> 
<p>守护进程创建步骤</p> 
<ol><li>执行一个 fork()，之后父进程退出，子进程继续执行。</li><li>子进程调用 setsid() 开启一个新会话。</li><li>清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。</li><li>修改进程的当前工作目录，通常会改为根目录（/）。</li><li>关闭守护进程从其父进程继承而来的所有打开着的文件描述符。</li><li>在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null 并使用dup2() 使所有这些描述符指向这个设备。</li><li>核心业务逻辑。</li></ol> 
<p>守护进程的demo</p> 
<pre><code class="prism language-cpp"><span class="token comment">/*
    写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。
*/</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/time.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 捕捉到信号之后，获取系统时间，写入磁盘文件</span>
    time_t tm <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tm</span> <span class="token operator">*</span> loc <span class="token operator">=</span> <span class="token function">localtime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// char buf[1024];</span>

    <span class="token comment">// sprintf(buf, "%d-%d-%d %d:%d:%d\n",loc-&gt;tm_year,loc-&gt;tm_mon</span>
    <span class="token comment">// ,loc-&gt;tm_mday, loc-&gt;tm_hour, loc-&gt;tm_min, loc-&gt;tm_sec);</span>

    <span class="token comment">// printf("%s\n", buf);</span>

    <span class="token keyword">char</span> <span class="token operator">*</span> str <span class="token operator">=</span> <span class="token function">asctime</span><span class="token punctuation">(</span>loc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"time.txt"</span><span class="token punctuation">,</span> O_RDWR <span class="token operator">|</span> O_CREAT <span class="token operator">|</span> O_APPEND<span class="token punctuation">,</span> <span class="token number">0664</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd <span class="token punctuation">,</span>str<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 1.创建子进程，退出父进程</span>
    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 2.将子进程重新创建一个会话</span>
    <span class="token function">setsid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 3.设置掩码</span>
    <span class="token function">umask</span><span class="token punctuation">(</span><span class="token number">022</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 4.更改工作目录</span>
    <span class="token function">chdir</span><span class="token punctuation">(</span><span class="token string">"/home/nowcoder/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 5. 关闭、重定向文件描述符</span>
    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/null"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dup2</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> STDIN_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dup2</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> STDOUT_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dup2</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> STDERR_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 6.业务逻辑</span>

    <span class="token comment">// 捕捉定时信号</span>
    <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> act<span class="token punctuation">;</span>
    act<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    act<span class="token punctuation">.</span>sa_handler <span class="token operator">=</span> work<span class="token punctuation">;</span>
    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>act<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sigaction</span><span class="token punctuation">(</span>SIGALRM<span class="token punctuation">,</span> <span class="token operator">&amp;</span>act<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">itimerval</span> val<span class="token punctuation">;</span>
    val<span class="token punctuation">.</span>it_value<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    val<span class="token punctuation">.</span>it_value<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    val<span class="token punctuation">.</span>it_interval<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    val<span class="token punctuation">.</span>it_interval<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 创建定时器</span>
    <span class="token function">setitimer</span><span class="token punctuation">(</span>ITIMER_REAL<span class="token punctuation">,</span> <span class="token operator">&amp;</span>val<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 不让进程结束</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h2><a id="_1259"></a>总结</h2> 
<p>牛客C++课程总结和复盘。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fb2b008694a779c0faa5368bd96f7603/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言-指针练习（附答案）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fe71bd723155490ab9ba95095539b391/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言 函数中返回数组</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>