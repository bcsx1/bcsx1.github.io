<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之排序算法--C#实现 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构之排序算法--C#实现" />
<meta property="og:description" content="原文出处：http://www.cnblogs.com/hfutwyy/archive/2012/04/25/2470173.html
本文中介绍的排序方法主要有以下几种：冒泡排序、选择排序、插入排序、希尔排序、归并排序、堆排序、快速排序。
排序算法之一：冒泡排序（Bubble Sort）
冒泡排序算法是可用的最慢的排序算法之一，但是是最容易理解和实现的一种排序算法。这种排序的得名是由于数值&#34;像气泡“一样升至队列的顶端或者底端而得名，
通过多次遍历整个列，并且比较相邻的数据，如果左边的数值大于右边的数值就进行交换（升序）。
实现代码如下：
//Bubble Sort Code public static void BubbleSort(int[] arr) { for(int i=0;i&lt;arr.Length;i&#43;&#43;) { for(int j = 0;j&lt;arr.Length-i-1;j&#43;&#43;) { if(arr[j]&gt;arr[j&#43;1]) { int temp = arr[j]; arr[j]=arr[j&#43;1]; arr[j&#43;1]=temp; } } } } 排序算法之二：选择排序（Selection Sort)
以数组为例（当然其他的集合类型也是一样），这种排序是从数组的起始处开始，把第一个元素与数组中其他元素进行比较。然后将最小的元素放在第0个位置，接着再从第一个位置开始再次进行排序操作。直到数组的最后一个元素为止。
//Selection Sort Code public static void SelectSort(int[] arr) { int min; for (int i = 0; i &lt; arr.Length-1; i&#43;&#43;) { min = i; for (int j = i &#43; 1; j &lt; arr." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/44e38f1297ba35be7505e0b72e4f56b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-05-08T15:53:03+08:00" />
<meta property="article:modified_time" content="2012-05-08T15:53:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之排序算法--C#实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong><span style="font-size:16px">原文出处：<a href="http://www.cnblogs.com/hfutwyy/archive/2012/04/25/2470173.html" rel="nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/hfutwyy/archive/2012/04/25/2470173.html</a></span></strong></p> 
<p><span style="font-weight:bold"><span style="font-size:18px">本文中介绍的排序方法主要有以下几种：冒泡排序、选择<span style="font-size:18px"><strong>排序</strong></span>、插入<span style="font-size:18px"><strong>排序</strong></span>、希尔<span style="font-size:18px"><strong>排序、归并<span style="font-size:18px"><strong>排序</strong></span>、堆<span style="font-size:18px"><strong>排序、</strong></span>快速<span style="font-size:18px"><strong>排序。</strong></span></strong></span></span></span></p> 
<p><strong><span style="font-size:24px">排序算法之一：冒泡排序（Bubble Sort）</span></strong></p> 
<p></p> 
<p><span style="font-size:16px">冒泡排序算法是可用的最慢的排序算法之一，但是是最容易理解和实现的一种排序算法。这种排序的得名是由于数值"像气泡“一样升至队列的顶端或者底端而得名，</span></p> 
<p><span style="font-size:16px">通过多次遍历整个列，并且比较相邻的数据，如果左边的数值大于右边的数值就进行交换（升序）。</span></p> 
<p><span style="font-size:16px">实现代码如下：</span></p> 
<pre><code class="language-csharp">//Bubble Sort Code 
 public static void BubbleSort(int[] arr)
         {
             for(int i=0;i&lt;arr.Length;i++)
             {
                 for(int j = 0;j&lt;arr.Length-i-1;j++)
                 {
                     if(arr[j]&gt;arr[j+1])
                     {
                         int temp = arr[j];
                         arr[j]=arr[j+1];
                         arr[j+1]=temp;
                     }
                 }
             }
         }</code></pre> 
<br> 
<p><strong><span style="font-size:24px">排序算法之二：选择排序（Selection Sort)</span></strong></p> 
<p><span style="font-size:18px">以数组为例（当然其他的集合类型也是一样），这种排序是从数组的起始处开始，把第一个元素与数组中其他元素进行比较。然后将最小的元素放在第0个位置，接着再从第一个位置开始再次进行排序操作。直到数组的最后一个元素为止。</span></p> 
<pre><code class="language-csharp">//Selection Sort Code 
 public static void SelectSort(int[] arr)
         {
             int min;
             for (int i = 0; i &lt; arr.Length-1; i++)
             {
                 min = i;
                 for (int j = i + 1; j &lt; arr.Length; j++)
                 {
                     if (arr[min] &gt; arr[j]) // 若写成if (arr[i] &gt; arr[j])是错误的！注意！！
                     {
                         min = j;   //保存最小数的下标
                     }
                 }
                 if (min != i)
                 {
                     int temp = arr[min];
                     arr[min] = arr[i];
                     arr[i] = temp;
                 }
             }
         }</code></pre> 
<p></p> 
<p><strong><span style="font-size:24px">排序算法之三：插入排序（Insertion Sort）</span></strong></p> 
<p><span style="font-size:18px">其基本操作为将一个记录插入到一个已经排序好的序列中，从而得到一个新的、记录数增1的新序列。</span></p> 
<p><span style="font-size:18px">如下图所示插入排序的过程：（图片源自网络）</span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/66/f0/dj9eE1FY_o.jpg" alt=""><br> </span></p> 
<pre><code class="language-csharp">//Insertion Sort Code 

 public static void InsertionSort(int[] arr)
        {
            int inner, temp;
            for (int i = 1; i &lt; arr.Length; i++)
            {
                temp = arr[i];
                inner = i;
                while (inner &gt; 0 &amp;&amp; arr[inner - 1] &gt; temp)
                {
                    arr[inner] = arr[inner - 1];
                    inner -= 1;
                }
                arr[inner - 1] = temp;
            }
        }</code></pre> 
<p><strong><span style="font-size:24px">总结：</span></strong></p> 
<p><span style="font-size:18px">选择排序是如上三种排序算法中效率最高的一种，其次是冒泡和插入。</span></p> 
<p><span style="font-size:18px">如上三种排序算法对小型数据集合适用，若是大型数据集合，由于其性能瓶颈，最好选用其他高级排序算法。</span></p> 
<p></p> 
<p><strong><span style="font-size:24px"><span style="font-size:24px"><strong>排序算法之四：</strong></span>希尔排序（Shell‘s Sort）又称“缩小增量排序”（Diminshing Increment Sort）是一种对插入排序的改进算法。</span></strong></p> 
<p><span style="font-size:18px">基本思想为：</span></p> 
<p><span style="font-size:18px">设待排序记录序列有n个记录，首先取一个整数gap&lt;n作为间隔，将全部记录分为gap个子序列，所有间隔为gap的记录放在同一子序列中，在每一子序列中分别执行直接插入排序。</span></p> 
<p><span style="font-size:18px">重复上述的子序列划分和排序工作，直到gap==1将所有记录放在同一个序列中排序为止。</span></p> 
<p><span style="font-size:18px">C#实现代码如下：</span></p> 
<p></p> 
<pre><code class="language-csharp">//Shell's Sort Code 
 public static void ShellSort(int[] arr)
         {
             int inner, temp;
             int h = 3;
             while (h &gt; 0)
             {
                 for (int outer = h; outer &lt;= arr.Length - 1; outer ++) 
 
                 {
                     temp = arr[outer];
                     inner = outer;
                     while ((inner &gt; h - 1) &amp;&amp; arr[inner - h] &gt;= temp)
                     {
                         arr[inner] = arr[inner - h];
                         inner -= h;
                     }
                     arr[inner] = temp;
                 }
                 Console.WriteLine();
                 Console.WriteLine("h="+h.ToString());
                 DisplayArray(arr);
                 h = (h - 1) % 3;
             }
         }</code></pre> 
<p></p> 
<p><strong><span style="font-size:24px"><strong><strong>排序算法之五：</strong></strong>归并排序算法（Merge Sort)</span></strong></p> 
<p><span style="font-size:18px">归并排序法是将两个（或多个）有序集合合并成一个新的有序集合。即把待排序集合分为若干个子集合，对每个集合进行排序，然后再把这些有序的子集合合并为整体集合。是分治法（Divide and COnquer)的典型应用。</span></p> 
<p><span style="font-size:18px">若将两个集合合并成一个集合称为2-路归并。</span></p> 
<p><span style="font-size:18px">百度百科关于归并排序算法的介绍，非常的详细，请参阅：<a href="http://baike.baidu.com/view/19000.htm" rel="nofollow">http://baike.baidu.com/view/19000.htm</a></span></p> 
<p><span style="font-size:18px"> 本处以2-路归并算法为例给出C#源代码，供大家学习。</span></p> 
<p></p> 
<pre><code class="language-csharp">//Merge Sort Code 
  public static void MergeSort(int[] arr)
         {
             int arrLength1, arrLength2;
             arrLength1 = arr.Length / 2;
             if (arr.Length % 2 == 0)
             {
                 arrLength2 = arrLength1;
             }
             else
             {
                 arrLength2 = arrLength1 + 1;
             }
             int[] arr1 = new int[arrLength1];
             int[] arr2 = new int[arrLength2];
             Array.Copy(arr, 0, arr1, 0, arrLength1);
             Array.Copy(arr, arrLength1, arr2, 0, arrLength2);
             Console.WriteLine("\narr1 Before Sort:");
             DisplayArray(arr1);
             Console.WriteLine("\narr2 Before Sort:");
             DisplayArray(arr2);
             //应用冒泡排序法为其排序
             BubbleSort(arr1);
             BubbleSort(arr2);
             Console.WriteLine("\narr1 After Sort:");
             DisplayArray(arr1);
             Console.WriteLine("\narr2 After Sort:");
             DisplayArray(arr2);
             //合并操作arr作为目标数组
             int arrIndex = 0;
             int arr1Index =0,arr2Index = 0;
             while(arr1Index&lt;arrLength1 &amp;&amp; arr2Index &lt; arrLength2)
             {
                 //选择较小项存入arr
                 if (arr1[arr1Index] &lt; arr2[arr2Index])
                 {
                     arr[arrIndex] = arr1[arr1Index];
                     arr1Index++;
                 }
                 else
                 {
                     arr[arrIndex] = arr2[arr2Index];
                     arr2Index++;
                 }
                 arrIndex++;
             }
             //对arr1或者arr2中的没有存入arr中的元素进行追加
             if (arr1Index != arrLength1 )
             {
                 while (arr1Index &lt; arrLength1)
                 {
                     arr[arrIndex] = arr1[arr1Index];
                     arrIndex++;
                     arr1Index++;
                 }
             }
             else if (arr2Index != arrLength2 )
             {
                 while (arr2Index &lt; arrLength2)
                 {
                     arr[arrIndex] = arr2[arr2Index];
                     arrIndex++;
                     arr2Index++;
                 }
             }
             DisplayArray(arr);
         }</code></pre> 
<p></p> 
<p style="font-size:18px">归并排序算法的时间复杂度为O(nlogn),空间复杂度为O(n).</p> 
<p><strong><span style="font-size:24px"><strong>排序算法之</strong></span><span style="font-size:24px"><strong>六：</strong>堆排序（Heap Sort）</span></strong></p> 
<p><span style="font-size:18px">首先介绍堆的概念，如果有一个关键字集合｛k0,k1,k2,...,kn-1｝,把其所有元素按完全二叉树的顺序存储在一个一维数组中，当且仅当ki&lt;=K2i并且ki&lt;=k(2i+1)称为最小堆。相反称为最大堆。</span></p> 
<p><span style="font-size:18px">堆性质1：大顶堆的堆顶关键字肯定是所有关键字中最大的，小顶堆的堆顶关键字是所有关键字中最小的。</span></p> 
<p><span style="font-size:18px">堆排序的思想：</span></p> 
<p><span style="font-size:18px">堆排序的思想：利用如上堆的性质1为基础，使每次从无序中选择最大记录（或最小记录）变得简单。</span></p> 
<p><span style="font-size:18px">构建初始堆和调整堆是堆排序的两个最重要的过程。并且初始堆也是对堆中所有元素的调整过程。所以算法的核心也正是堆的调整。</span></p> 
<p><span style="font-size:18px">如下摘自海子的园子(<a href="http://www.cnblogs.com/dolphin0520/archive/2011/10/06/2199741.html" rel="nofollow">http://www.cnblogs.com/dolphin0520/archive/2011/10/06/2199741.html</a>)</span></p> 
<p><span style="font-size:18px">下面举例说明：</span></p> 
<p><span style="font-size:18px">     给定一个整形数组a[]={16,7,3,20,17,8}，对其进行堆排序。</span></p> 
<p><span style="font-size:18px">    首先根据该数组元素构建一个完全二叉树，得到</span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/dd/41/R81p754T_o.jpg" alt=""><br> </span></p> 
<span style="font-size:18px">然后需要构造初始堆，则从最后一个非叶节点开始调整，调整过程如下：</span> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/3e/07/g3i5wbXh_o.jpg" alt=""><img src="https://images2.imgbox.com/26/d2/1UhPCDz5_o.jpg" alt=""><img src="https://images2.imgbox.com/89/3f/bmt2UFD3_o.jpg" alt=""><br> </span></p> 
<p><span style="font-size:18px">20和16交换后导致16不满足堆的性质，因此需重新调整</span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/86/31/shtd41H5_o.jpg" alt="">这样就得到了初始堆。<br> </span></p> 
<p></p> 
<div style="font-size:18px">
  即每次调整都是从父节点、左孩子节点、右孩子节点三者中选择最大者跟父节点进行交换(交换之后可能造成被交换的孩子节点不满足堆的性质，因此每次交换之后要重新对被交换的孩子节点进行调整)。有了初始堆之后就可以进行排序了。 
</div> 
<div style="font-size:18px"> 
 <img src="https://images2.imgbox.com/95/7c/mdsWLcbO_o.jpg" alt="">此时3位于堆顶不满堆的性质，则需调整继续调整 
 <img src="https://images2.imgbox.com/cb/14/jspwHIvB_o.jpg" alt=""> 
 <br> 
</div> 
<span style="font-size:18px"><img src="https://images2.imgbox.com/1c/20/HzYtMjlx_o.jpg" alt=""><img src="https://images2.imgbox.com/01/ba/R3iZfqZn_o.jpg" alt=""><img src="https://images2.imgbox.com/70/74/nx7Pn5Gw_o.jpg" alt=""><img src="https://images2.imgbox.com/a2/83/bVs2WIYa_o.jpg" alt=""><img src="https://images2.imgbox.com/95/02/fvkq85Fc_o.jpg" alt=""><img src="https://images2.imgbox.com/a0/f0/R64YFKgC_o.jpg" alt=""><img src="https://images2.imgbox.com/d0/0e/fGaAUahI_o.jpg" alt=""><img src="https://images2.imgbox.com/16/f1/oG6iiNYS_o.jpg" alt=""><img src="https://images2.imgbox.com/ae/a0/AsqZJk6P_o.jpg" alt=""></span> 
<div style="font-size:18px">
  这样整个区间便已经有序了。 
</div> 
<div style="font-size:18px">
  C#实现代码如下： 
</div> 
<pre><code class="language-csharp">//Heap Sort Code 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace HeapSort
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] arr = {53,17,78,09,45,65,87,23};
            //调整初始数据为最小堆（或者最大堆）
            Heap.MinHeapAdjust(arr,0, arr.Length);
            //交换首尾数字输出排序结果
            for (int i = arr.Length-1; i &gt;= 0; i--)
            { 
                //交换首尾
                int temp = arr[i];
                arr[i] = arr[0];
                arr[0] = temp;
                //调整除尾部之后的特定的堆
                Heap.MinHeapAdjust(arr, 0, i);
            }
            Heap.DisplayHeap(arr);
            Console.ReadLine();
        }
    }
    public static class Heap
    {
        /// &lt;summary&gt;
        /// 将传入的数组调节为最小堆
        /// &lt;/summary&gt;
        /// &lt;param name="arr"&gt;待调解数组&lt;/param&gt;
        /// &lt;param name="maxIndex"&gt;待调节的最大索引，最大索引之后的数据将不会调节&lt;/param&gt;
        public static void MinHeapAdjust(int[] arr,int startIndex, int maxIndex)
        {
            //Console.WriteLine("Before Adjust");
            //DisplayHeap(arr);
            //首先需要获得倒数第一个分枝节点
            int currentBranchIndex = maxIndex / 2-1;
            //调整分枝节点及其子节点
            for (; currentBranchIndex &gt;= startIndex; currentBranchIndex--)
            {
                AdjustSubHeap(arr, currentBranchIndex, maxIndex);
            }
            //Console.WriteLine("After Adjust");
            //DisplayHeap(arr);
        }
        /// &lt;summary&gt;
        /// FliterDown算法，调整以startIndex为要的子树为最小堆
        /// &lt;/summary&gt;
        /// &lt;param name="arr"&gt;&lt;/param&gt;
        /// &lt;param name="currentIndex"&gt;&lt;/param&gt;
        /// &lt;param name="maxIndex"&gt;&lt;/param&gt;
        public static void AdjustSubHeap(int[] arr, int currentIndex, int maxIndex)
        {
            var temp = arr[currentIndex];
            if(2 * currentIndex + 1&lt;maxIndex)
            if (temp &gt; arr[2 * currentIndex + 1])
            {
                arr[currentIndex] = arr[2 * currentIndex + 1];
                arr[2 * currentIndex + 1] = temp;
                temp = arr[currentIndex];   //若本子树顶部的键值已经改变，则将此键值存入临时区
                AdjustSubHeap(arr, 2 * currentIndex + 1, maxIndex);
            }
            if (2 * currentIndex + 2 &lt; maxIndex)   //如果有最后一个节点有两个子节点
            {
                if (temp &gt; arr[2 * currentIndex + 2])
                {
                    arr[currentIndex] = arr[2 * currentIndex + 2];
                    arr[2 * currentIndex + 2] = temp;
                }
                AdjustSubHeap(arr, 2 * currentIndex + 2, maxIndex);
            }
        }
        /// &lt;summary&gt;
        /// 显示Heap
        /// &lt;/summary&gt;
        /// &lt;param name="arr"&gt;&lt;/param&gt;
        public static void DisplayHeap(int[] arr)
        {
            foreach(int val in arr)
            {
                Console.WriteLine(val + " ");
            }
        }
    }

}</code></pre> 
<p></p> 
<p><strong><span style="font-size:18px"><strong><span style="font-size:24px"><strong>排序算法之七</strong></span><span style="font-size:24px"><strong>：</strong></span></strong></span><span style="font-size:24px">快速排序（quick sort)</span></strong></p> 
<p style="font-size:18px">快速排序也是分治法的一个实例，其主要思想为，选取一个值，将大于其的值放在其后，小于其的值放在其前。并对其前和其后的数据段进行迭代，直至分到数据段为一个数字。</p> 
<p style="font-size:18px">【它的基本思想是：通过一趟排序将要排序的<a href="http://www.cnblogs.com/view/4466818.htm" rel="nofollow noopener noreferrer" target="_blank">数据分割</a>成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以<a href="http://www.cnblogs.com/view/96473.htm" rel="nofollow noopener noreferrer" target="_blank">递归</a>进行，以此达到整个数据变成有序序列。】（如上括号里面的为引用自别处，人家写的比俺写的好多了。）</p> 
<p style="font-size:18px">其具体做法如下：</p> 
<p style="font-size:18px">设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用第一个数据）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。</p> 
<div class="spctrl" style="font-size:18px">
  　　一趟快速排序的算法是： 
</div> 
<div class="spctrl" style="font-size:18px">
   　　1）设置两个变量I、J，排序开始的时候：I=0，J=N-1； 
</div> 
<div class="spctrl" style="font-size:18px">
   　　2）以第一个数组元素作为关键数据，赋值给 
 <strong>key</strong>，即 
 <strong>key</strong>=A[0]； 
</div> 
<div class="spctrl" style="font-size:18px">
   　　3）从J开始向前搜索，即由后开始向前搜索（J=J-1即J--），找到第一个小于 
 <strong>key</strong>的值A[j]，A[j]与A[i]交换； 
</div> 
<div class="spctrl" style="font-size:18px">
   　　4）从I开始向后搜索，即由前开始向后搜索（I=I+1即I++），找到第一个大于 
 <strong>key</strong>的A[i]，A[i]与A[j]交换； 
</div> 
<div class="spctrl" style="font-size:18px">
   　　5）重复第3、4、5步，直到 I=J； (3,4步是在程序中没找到时候j=j-1，i=i+1，直至找到为止。找到并交换的时候i， j指针位置不变。另外当i=j这过程一定正好是i+或j-完成的最后另循环结束。） 
</div> 
<pre><code class="language-csharp">//Quick Sort Code 
 using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
 
 namespace QuickSort
 {
     class Program
     {
         static void Main(string[] args)
         {
             int[] arr = { 97,76,13,27,20,10,9,90,49,65};
             QuickSort.sort(arr, 0, arr.Length-1);
             QuickSort.DisplayArr(arr, 0, arr.Length);
             Console.ReadLine();
         }
     }
     public static class  QuickSort
     {
         public static void sort(int[] arr,int lowIndex,int upperIndex)
         {
             if (lowIndex &gt;= upperIndex) return;
             int key,i,j,temp;
             i = lowIndex;
             key = arr[lowIndex];
             j = upperIndex;
             bool leftToRight = false;
             while (i&lt; j)
             {
                 //从右向左检索，查找右边第一个小于key的元素
                 if(!leftToRight)
                 if (arr[j] &lt; key)
                 {
                     temp = arr[i];
                     arr[i] = arr[j];
                     arr[j] = temp;
                     leftToRight = true;
                     i = lowIndex;
                 }
                 else
                 {
                     j--;
                 }
                 //从左向右检索，查找左边第一个大于key的元素
                 if (leftToRight)
                 if (arr[i] &gt; key)
                 {
                     temp = arr[i];
                     arr[i] = arr[j];
                     arr[j] = temp;
                     j = upperIndex;
                     leftToRight = false;
                 }
                 else
                 {
                     i++;
                 }
             }
             if (lowIndex &lt; upperIndex)
             {
                 sort(arr, lowIndex, i-1);
                 sort(arr, i + 1, upperIndex);
             }
         }
         //输出数组
         public static void DisplayArr(int[] arr, int lowindex, int upperindex)
         {
             Console.WriteLine();
             for (int i = lowindex; i &lt; upperindex; i++)
             {
                 Console.Write(arr[i] + " ");
             }
         }
     }
 }</code></pre> 
<strong><span style="font-size:24px">排序方法的选择</span></strong> 
<br> 
<span style="font-size:18px">　　因为不同的排序方法适应不同的应用环境和要求，所以选择合适的排序方法很重要</span> 
<br> 
<span style="font-size:18px"><strong>       (1)若n较小，可采用直接插入或直接选择排序。</strong></span> 
<br> 
<span style="font-size:18px">　　当记录规模较小时，直接插入排序较好，它会比选择更少的比较次数；</span> 
<br> 
<span style="font-size:18px">　　但当记录规模较大时，因为直接选择移动的记录数少于直接插人，所以宜用选直接选择排序。</span> 
<br> 
<span style="font-size:18px">　　这两种都是稳定排序算法。</span> 
<br> 
<span style="font-size:18px"><strong>　　(2)若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜(这里的随机是指基准取值的随机，原因见上的快速排序分析)；这里快速排序算法将不稳定。</strong></span> 
<br> 
<span style="font-size:18px">　<strong>　(3)若n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。</strong></span> 
<br> 
<span style="font-size:18px">　　快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</span> 
<br> 
<span style="font-size:18px">　　堆排序虽不会出现快速排序可能出现的最坏情况。但它需要建堆的过程。这两种排序都是不稳定的。</span> 
<br> 
<span style="font-size:18px">　　归并排序是稳定的排序算法，但它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。</span> 
<br> 
<span style="font-size:18px">　　<strong>(4)特殊的箱排序、基数排序</strong></span> 
<br> 
<span style="font-size:18px">　　它们都是一种稳定的排序算法，但有一定的局限*：</span> 
<br> 
<span style="font-size:18px">　　1&gt;关键字可分解。</span> 
<br> 
<span style="font-size:18px">　　2&gt;记录的关键字位数较少，如果密集更好</span> 
<br> 
<span style="font-size:18px">　　3&gt;如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。</span> 
<br>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/896d582fe770cc94a511e694a1fcf67c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">批处理基础：if判断输入参数是否空</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bda5feaf65a94e7780a04284505296f1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ORA-01931: cannot grant UNLIMITED TABLESPACE to a role on 10g</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>