<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 面试题基础 -总结 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 面试题基础 -总结" />
<meta property="og:description" content="Java 面试题基础(一) 如想了解更多更全面的Java必备内容可以阅读：所有JAVA必备知识点面试题文章目录：
JAVA必备知识点面试题 1、面向对象的特征有哪些方面？
答：面向对象的特征主要有以下几个方面：
抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽 象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的 细节是什么。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类 被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让 变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要 手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中 关于桥梁模式的部分）。
第 212 页 共 485 页 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问 只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自 治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写 一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西， 只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别， 明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是 封装得足够好的，因为几个按键就搞定了所有的事情）。 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。 简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分 为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的 服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B 系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须 刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电， 甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道 供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载 （overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override） 实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的 东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已 有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样 的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 2、访问修饰符public,private,protected,以及不写（默认）时的区别？
修饰符当前类同 包子 类其他包public√√√√protected√√√×default√√××private√××× 类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公 开（public），对于不是同一个包中的其他类相当于私有（private）。受保护 （protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私 有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的 修饰符可以是以上四种。
3、String 是最基本的数据类型吗？
答：不是。Java 中的基本数据类型只有 8 个：byte、short、 char、int、long、float、double、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。
4、float f=3.4;是否正确？
答:不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于 下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换 float f =(float)3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2490f4b249394d55ef8309bfa93f1dcf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-10T20:43:32+08:00" />
<meta property="article:modified_time" content="2020-07-10T20:43:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 面试题基础 -总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="Java__0"></a>Java 面试题基础(一)</h4> 
<hr> 
<p>如想了解更多更全面的Java必备内容可以阅读：<strong>所有JAVA必备知识点面试题文章目录：</strong></p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> <a href="https://blog.csdn.net/shishishilove/article/details/107451998">JAVA必备知识点面试题</a></li></ul> 
<hr> 
<p><strong>1、面向对象的特征有哪些方面？</strong><br> 答：面向对象的特征主要有以下几个方面：</p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽 象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的 细节是什么。</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类 被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让 变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要 手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中 关于桥梁模式的部分）。<br> 第 212 页 共 485 页</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问 只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自 治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写 一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西， 只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别， 明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是 封装得足够好的，因为几个按键就搞定了所有的事情）。</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。 简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分 为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的 服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B 系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须 刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电， 甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道 供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载 （overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override） 实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的 东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已 有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样 的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li></ul> 
<p><strong>2、访问修饰符public,private,protected,以及不写（默认）时的区别？</strong></p> 
<table><thead><tr><th>修饰符</th><th>当前类</th><th>同 包</th><th>子 类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table> 
<p>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公 开（public），对于不是同一个包中的其他类相当于私有（private）。受保护 （protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私 有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的 修饰符可以是以上四种。</p> 
<p><strong>3、String 是最基本的数据类型吗？</strong><br> 答：不是。Java 中的基本数据类型只有 8 个：byte、short、 char、int、long、float、double、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p> 
<p><strong>4、float f=3.4;是否正确？</strong><br> 答:不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于 下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换 float f =(float)3.4; 或者写成 float f =3.4F;。</p> 
<p><strong>5、short s1=1;s1=s1+1;有错吗? short s1=1;s1+=1;有错吗？</strong><br> 答：对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。而 short s1 = 1; s1 += 1;可以正确 编译，因为 s1+= 1;相当于 s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</p> 
<p><strong>6、Java有没有goto？</strong><br> 答：goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。 （根据 James Gosling （Java 之父）编写的《The Java Programming Language》一书的附录中给出 了一个 Java 关键字列表，其中有 goto 和 const，但是这两个是目前无法使用的 关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意 义，因为熟悉 C 语言的程序员都知道，在系统类库中使用过的有特殊意义的单词 或单词的组合都被视为保留字）</p> 
<p><strong>7、int和Integer有什么区别？</strong><br> 答：Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本 数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer， 从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型：<br> 原始类型: boolean，char，byte，short，int，long，float，double<br> 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float、Double</p> 
<p><strong>8、&amp;和&amp;&amp;的区别？</strong><br> 答：&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与 跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的 表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我 们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是 null 而且不 是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者 的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行 字符串的 equals 比较，否则会产生 NullPointerException 异常。注意：逻辑或 运算符（|）和短路或运算符（||）的差别也是如此。</p> 
<p><strong>9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</strong><br> 答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的 现场保存都使用 JVM 中的栈空间；而通过 new 关键字和构造器创建的对象则放在 堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收 集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、 Survivor（又可分为 From Survivor 和 To Survivor）、Tenured；方法区和堆都 是各个线程共享的内存区域，用于存储已经被 JVM 加载的类信息、常量、静态变 量、JIT 编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的 100、” hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来 最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过 JVM 的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常量 池空间不足则会引发 OutOfMemoryError。<br> String str = new String(“hello”);<br> 上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而” hello”这个字面量是放在方法区的。<br> 补充 1：较新版本的 Java（从 Java 6 的某个更新开始）中，由于 JIT 编译器的发 展和”逃逸分析”技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一 定分配在堆上这件事情已经变得不那么绝对了。<br> 补充 2：运行时常量池相当于 Class 文件常量池具有动态性，Java 语言并不要求 常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 intern()方法就是这样的。</p> 
<p><strong>10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</strong><br> 答：Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五 入的原理是在参数上加 0.5 然后进行下取整。</p> 
<p><strong>11、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</strong><br> 答：在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java 5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始， expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是 不可以的。</p> 
<p><strong>12、用最有效率的方法计算2乘以8？</strong><br> 答：2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。补充：我们为编写的类重写 hashCode 方法时，可能会看到如下所示的代码，其 实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为 什么这个数是个素数，为什么通常选择 31 这个数？前两个问题的答案你可以自己 百度一下，选择 31 是因为可以用移位和减法运算来代替乘法，从而得到更好的性 能。说到这里你可能已经想到了：31 * num 等价于(num &lt;&lt; 5) - num，左移 5 位相当于乘以 2 的 5 次方再减去自身就相当于乘以 31，现在的 VM 都能自动完成 这个优化。</p> 
<p><strong>13、数组有没有length()方法？String有没有length()方法？</strong><br> 答：数组没有 length()方法，有 length 的属性。String 有 length()方法。JavaScript 中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</p> 
<p><strong>在Java中，如何跳出当前的多重嵌套循环？</strong><br> 答：在最外层循环前加一个标记如 A，然后用 break A;可以跳出多重循环。（Java 中 支持带标签的 break 和 continue 语句，作用有点类似于 C 和 C++中的 goto 语 句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue， 因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法 其实不知道更好）</p> 
<p><strong>15、构造器（constructor）是否可被重写（override）？</strong><br> 答：构造器不能被继承，因此不能被重写，但可以被重载。</p> 
<p><strong>16、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</strong><br> 答：不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hash code） 应当相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1)如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；(2) 如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求 去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现 在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统， 如果哈希码频繁的冲突将会造成存取性能急剧下降）。</p> 
<p><strong>17、是否可以继承String类？</strong><br> 答：String 类是 final 类，不可以被继承。<br> 补充：继承 String 本身就是一个错误的行为，对 String 类型最好的重用方式是关 联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。</p> 
<p><strong>18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</strong><br> 答：是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个 参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调 用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和 C#中可以 通过传引用或传输出参数来改变传入的参数的值。</p> 
<p><strong>19、String和StringBuilder、StringBuffer的区别？</strong><br> 答：Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它 们可以储存和操作字符串。其中 String 是只读字符串，也就意味着 String 引用的 字符串内容是不能被改变的。而 StringBuffer/StringBuilder 类表示的字符串对象 可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方 法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。<br> <strong>面试题 1</strong>- 什么情况下用+运算符进行字符串连接比调用 StringBuffer/StringBuilder 对象的 append 方法连接字符串性能更好？<br> <strong>面试题 2</strong> - 请说出下面程序的输出。</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">StringEqualTest</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		String s1 <span class="token operator">=</span> <span class="token string">"Programming"</span><span class="token punctuation">;</span>
		String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Programming"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		String s3 <span class="token operator">=</span> <span class="token string">"Program"</span><span class="token punctuation">;</span>
		String s4 <span class="token operator">=</span> <span class="token string">"ming"</span><span class="token punctuation">;</span>
		String s5 <span class="token operator">=</span> <span class="token string">"Program"</span> <span class="token operator">+</span> <span class="token string">"ming"</span><span class="token punctuation">;</span>
		String s6 <span class="token operator">=</span> s3 <span class="token operator">+</span> s4<span class="token punctuation">;</span>
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s6<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2 <span class="token operator">==</span> s2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
结果：
<span class="token boolean">false</span>
<span class="token boolean">true</span>
<span class="token boolean">false</span>
<span class="token boolean">true</span>
<span class="token boolean">false</span>
</code></pre> 
<p>补充：解答上面的面试题需要清除两点：</p> 
<ol><li>String 对象的 intern 方法会得到字符 串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与 String 对象 的 equals 结果是 true），如果常量池中没有对应的字符串，则该字符串将被添加 到常量池中，然后返回常量池中字符串的引用；</li><li>字符串的+操作其本质是创建 了 StringBuilder 对象进行 append 操作，然后将拼接后的 StringBuilder 对象用 toString 方法处理成 String 对象，这一点可以用 javap -c StringEqualTest.class 命令获得 class 文件对应的 JVM 字节码指令就可以看出来。</li></ol> 
<p><strong>20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</strong><br> 答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性， 而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同 的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返 回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里 氏代换原则）。重载对返回类型没有特殊的要求。<br> <strong>面试题：</strong> 华为的面试题中曾经问过这样一个问题 - “为什么不能根据返回类型来 区分重载”，快说出你的答案吧！</p> 
<p><strong>21、描述一下JVM加载class文件的原理机制？</strong><br> 答：JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的 类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件 中的类。 由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一 个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、 连接（验证、准备和解析）和初始化。类的加载是指把类的.class 文件中的数据读 入到内存中，通常是创建一个字节数组读入.class 文件，然后产生与所加载类对应 的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。当类 被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设 置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对 类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么 就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加 载器（Extension）、系统加载器（System）和用户自定义类加载器 （java.lang.ClassLoader 的子类）。从 Java 2（JDK 1.2）开始，类加载过程采 取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制 中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载 器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类 加载器的说明：</p> 
<ul><li>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</li><li>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父 加载器是Bootstrap；</li><li>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的 类加载器。它从环境变量classpath或者系统属性java.class.path 所指定的目 录中记载类，是用户自定义加载器的默认父加载器。</li></ul> 
<p><strong>22、char 型变量中能不能存贮一个中文汉字，为什么？</strong><br> 答：char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode（不选择 任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一 个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。补充：使用 Unicode 意味着字符在 JVM 内部和外部有不同的表现形式，在 JVM 内部都是 Unicode，当这个字符被从 JVM 内部转移到外部时（例如存入文件系统 中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字符流和字节 流之间进行转换的转换流，如 InputStreamReader 和 OutputStreamReader， 这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于 C 程 序员来说，要完成这样的编码转换恐怕要依赖于 union（联合体/共用体）共享内 存的特征来实现了。</p> 
<p><strong>23、抽象类（abstract class）和接口（interface）有什么异同？</strong><br> 答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是 private、默认、protected、 public 的，而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接 口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而 抽象类未必要有抽象方法。</p> 
<p><strong>24、静态嵌套类(StaticNestedClass)和内部类（InnerClass）的不同？</strong><br> 答：Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。</p> 
<p><strong>25、Java 中会存在内存泄漏吗，请简单描述。</strong><br> 答：理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被 广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无 用但可达的对象，这些对象不能被 GC 回收，因此也会导致内存泄露的发生。例如 Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收 这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close） 或清空（flush）一级缓存就可能导致内存泄露。</p> 
<p><strong>26、抽象的（abstract）方法是否可是静态的（static）,是否可是本地方法（native），是否可被synchronized修饰？</strong><br> 答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛 盾的。本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现 的，也是矛盾的。synchronized 和方法的实现细节有关，抽象方法不涉及实现细 节，因此也是相互矛盾的。</p> 
<p><strong>27、阐述静态变量和实例变量的区别。</strong><br> 答：静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的 任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷 贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。 静态变量可以实现让多个对象共享内存。<br> 补充：在 Java 开发中，上下文类和工具类中通常会有大量的静态成员。</p> 
<p><strong>28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</strong><br> 答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在 调用静态方法时可能对象并没有被初始化。</p> 
<p><strong>29、如何实现对象克隆？</strong><br> 答：有两种方式： 1). 实现 Cloneable 接口并重写 Object 类中的 clone()方法； 2). 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真 正的深度克隆。</p> 
<p><strong>30、GC是什么？为什么要有GC？</strong><br> 答：GC 是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动 监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放 已分配内存的显示操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会 自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或 Runtime.getRuntime().gc() ，但 JVM 可以屏蔽掉显示的垃圾回收调用。<br> 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通 常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死 亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回 收器对某个对象或所有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java 最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过 境迁，如今 Java 的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常 觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在 于 Android 系统中垃圾回收的不可预知性。<br> 补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量 垃圾回收等方式。标准的 Java 进程既有栈又有堆。栈保存了原始型局部变量，堆 保存了要创建的对象。Java 平台对堆内存回收和再利用的基本算法被称为标记和 清除，但是 Java 对其进行了改进，采用“分代式垃圾收集”。这种方法会跟 Java 对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象 移动到不同区域：</p> 
<ul><li>伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说， 这里是它们唯一存在过的区域。</li><li>幸存者区（Survivor）：从伊甸园幸存下来的对象会被挪到这里。</li><li>终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集 （Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身 颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩， 以便为大对象腾出足够的空间。</li></ul> 
<p>与垃圾回收相关的 JVM 参数：</p> 
<ul><li>-Xms / -Xmx — 堆的初始大小 / 堆的最大大小</li><li>-Xmn — 堆中年轻代的大小</li><li>-XX:-DisableExplicitGC — 让System.gc()不产生任何作用</li><li>-XX:+PrintGCDetails — 打印GC 的细节</li><li>-XX:+PrintGCDateStamps — 打印GC操作的时间戳</li><li>-XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小</li><li>-XX:NewRatio — 可以设置老生代和新生代的比例</li><li>-XX:PrintTenuringDistribution — 设置每次新生代GC 后输出幸存者 乐园中对象年龄的分布</li><li>-XX:InitialTenuringThreshold/-XX:MaxTenuringThreshold：设置老 年代阀值的初始值和最大值</li><li>-XX:TargetSurvivorRatio：设置幸存区的目标使用率</li></ul> 
<p><strong>31、Strings=newString(“xyz”);创建了几个字符串对象？</strong><br> 答：两个对象，一个是静态区的”xyz”，一个是用 new 创建在堆上的对象。</p> 
<p><strong>32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？</strong><br> 答：接口可以继承接口，而且支持多重继承；抽象类可以实现(implements)接口；抽象类可继承具体类也可以继承抽象类。</p> 
<p><strong>33、一个”.java”源文件中是否可以包含多个类（不是内部类） ？有什么限制？</strong><br> 答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和 公开类的类名完全保持一致。</p> 
<p><strong>34、AnonymousInnerClass(匿名内部类)是否可以继承其它类？是否可以实现接口？</strong><br> 答：可以继承其他类或实现其他接口，在 Swing 编程和 Android 开发中常用此方式来 实现事件监听和回调。</p> 
<p><strong>35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</strong><br> 答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p> 
<p><strong>36、Java 中的final关键字有哪些用法？</strong><br> 答：(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。</p> 
<p><strong>37、指出下面程序的运行结果?</strong><br> 答：创建对象时构造器的调用顺序是：先初始化静态成员，然后 调用父类构造器，再初始化非静态成员，最后调用自身构造器。</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token punctuation">{<!-- --></span> 
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token punctuation">{<!-- --></span> 
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
		A ab <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
		ab <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
运行结果：
<span class="token number">1</span>a2b2b
</code></pre> 
<p><strong>38、数据类型之间的转换：如何将字符串转换为基本数据类型？如何将基本数据类型转换为字符串？</strong><br> 答：</p> 
<ul><li>调用基本数据类型对应的包装类中的方法parseXXX(String)或 valueOf(String)即可返回相应基本类型；</li><li>一种方法是将基本数据类型与空字符串（”“）连接（+）即可获得其所 对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符 串</li></ul> 
<p><strong>39、如何实现字符串的反转及替换？</strong><br> 答：方法很多，可以自己写实现也可以使用 String 或 StringBuffer/StringBuilder 中 的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">reverse</span><span class="token punctuation">(</span>String originStr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
	<span class="token keyword">if</span><span class="token punctuation">(</span>originStr <span class="token operator">==</span> null <span class="token operator">||</span> originStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> 
		<span class="token keyword">return</span> originStr<span class="token punctuation">;</span> 
	<span class="token keyword">return</span> <span class="token function">reverse</span><span class="token punctuation">(</span>originStr<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> originStr<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> 
<p><strong>40、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</strong><br> 答：代码如下所示：<br> String s1 = “你好”;<br> String s2 = new String(s1.getBytes(“GB2312”), “ISO-8859-1”);</p> 
<p><strong>41、比较一下Java和JavaSciprt。</strong><br> 答：JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun Microsystems 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而 JavaScript 是 Netscape 公司的产品，为了扩展 Netscape 浏览器的功能而开发的一种可以嵌入 Web 页面中运行的基于对象和事件驱动的解释性语言。 JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。 下面对两种语言间的异同作如下比较：</p> 
<ul><li>基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发 简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对 象供设计人员使用。</li><li>解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是 一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏 览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）</li><li>强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编 译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作 声明，JavaScript的解释器在运行时检查推断其数据类型。</li><li>代码格式不一样。</li></ul> 
<p>补充：上面列出的四点是网上流传的所谓的标准答案。其实 Java 和 JavaScript 最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势 是函数式语言和动态语言。在 Java 中类（class）是一等公民，而 JavaScript 中 函数（function）是一等公民，因此 JavaScript 支持函数式编程，可以使用 Lambda 函数和闭包（closure），当然 Java 8 也开始支持函数式编程，提供了对 Lambda 表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的 语言回答会更加靠谱，不要背网上所谓的标准答案。</p> 
<p><strong>42、什么时候用断言（assert）？</strong><br> 答：断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一 般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true；如果表达式的值为 false，那么系统会报告一个AssertionError。断言的使用如下面的代 码所示：assert(a &gt; 0); // throws an AssertionError if a &lt;= 0<br> 断言可以有两种形式：<br> assert Expression1;<br> assert Expression1 : Expression2 ; Expression1<br> 应该总是产生一个布尔值。 Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信 息的字符串消息。<br> 要在运行时启用断言，可以在启动 JVM 时使用-enableassertions 或者-ea 标记。 要在运行时选择禁用断言，可以在启动 JVM 时使用-da 或者-disableassertions 标记。要在系统类中启用或禁用断言，可使用-esa 或-dsa 标记。还可以在包的基 础上启用或者禁用断言。</p> 
<p><strong>43、Error和Exception有什么区别？</strong><br> 答：Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情 况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况； Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题； 也就是说，它表示如果程序运行正常，从不会发生的情况。</p> 
<p><strong>44、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?</strong><br> 答：会执行，在方法返回调用者return前执行。<br> 注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try 中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完 毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改 后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中 直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse 中可以在如图所示的地方进行 设置，强烈建议将此项设置为编译错误。<br> <img src="https://images2.imgbox.com/a6/89/p83zYu33_o.png" alt="在这里插入图片描述"></p> 
<p><strong>45、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</strong><br> 答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了 良好的接口。在 Java 中，每个异常都是一个对象，它是Throwable 类或其子类 的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理 是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。一般情况 下是用 try 来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过 它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try 用 来指定一块预防所有异常的程序；catch 子句紧跟在 try 块后面，用来指定你想要 捕获的异常的类型；throw 语句用来明确地抛出一个异常；throws 用来声明一个 方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally 为确保一段 代码不管发生什么异常状况都要被执行；try 语句可以嵌套，每当遇到一个 try 语 句，异常的结构就会被放入异常栈中，直到所有的 try 语句都完成。如果下一级的 try 语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这 种异常的 try 语句或者最终将异常抛给 JVM。</p> 
<p><strong>46、运行时异常与受检异常有何异同？</strong><br> 答：异常表示程序运行过程中可能出现的非正常状态，<strong>运行时异常</strong>表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。<strong>受检异常</strong>跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java 编译器要求方法必须声明抛出可能发生的受检异常， 但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在 Effective Java 中对异常的使用给出了以下指 导原则：</p> 
<ul><li>不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调 用者为了正常的控制流而使用异常）</li><li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常</li><li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发 生）</li><li>优先使用标准的异常</li><li>每个方法抛出的异常都要有文档</li><li>保持异常的原子性</li><li>不要在catch中忽略掉捕获到的异常</li></ul> 
<p><strong>47、列出一些你常见的运行时异常？</strong><br> 答：</p> 
<ul><li>ArithmeticException（算术异常）</li><li>ClassCastException （类转换异常）</li><li>IllegalArgumentException （非法参数异常）</li><li>IndexOutOfBoundsException （下标越界异常）</li><li>NullPointerException （空指针异常）</li><li>SecurityException （安全异常）</li></ul> 
<p><strong>48、阐述final、finally、finalize的区别。</strong><br> 答：</p> 
<ul><li>final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。</li><li>finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。</li><li>finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行 其他清理工作。</li></ul> 
<p><strong>49、类ExampleA继承Exception，类ExampleB继承ExampleA。请问执行此段代码的输出是什么？</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExampleB</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span> <span class="token keyword">catch</span>（ExampleA e）<span class="token punctuation">{<!-- --></span> 
	System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ExampleA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> <span class="token keyword">catch</span>（Exception e）<span class="token punctuation">{<!-- --></span> 
	System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]， 抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的 异常）<br> <strong>面试题</strong> - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Annoyance</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> 
<span class="token keyword">class</span> <span class="token class-name">Sneeze</span> <span class="token keyword">extends</span> <span class="token class-name">Annoyance</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{<!-- --></span> 
		<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span> 
			<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span> 
				<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Sneeze</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
			<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span> Annoyance a <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
				System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Caught Annoyance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
				<span class="token keyword">throw</span> a<span class="token punctuation">;</span> 
			<span class="token punctuation">}</span> 
		<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span> Sneeze s <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
			System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Caught Sneeze"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
			<span class="token keyword">return</span> <span class="token punctuation">;</span> 
		<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span> 
			System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
		<span class="token punctuation">}</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
运行结果：
Caught Annoyance
Caught Sneeze
Hello World<span class="token operator">!</span>
</code></pre> 
<p><strong>50、List、Set、Map是否继承自Collection接口？</strong><br> 答：List、Set 是，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显的区别， 而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。</p> 
<p><strong>51、阐述ArrayList、Vector、LinkedList的存储性能和特性。</strong><br> 答：ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的 数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉 及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 中的方法由 于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使用双向链表实现存 储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector 属于遗留容器（Java 早期的版本中 提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties 都是遗留容器），已经不推荐使用，但是由于 ArrayList 和 LinkedList都是非 线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</p> 
<p><strong>52、Collection和Collections的区别？</strong><br> 答：Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、 排序、线程安全化等等。</p> 
<p><strong>53、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</strong><br> 答：TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比 较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。<br> TreeMap要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进行排序。<br> Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入 的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；第二 种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于 一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对 回调模式的应用（Java 中对函数式编程的支持）。</p> 
<p><strong>54、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</strong><br> 答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复。wait()是 Object 类的方法，调用对象的 wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用 对象的 notify()方法（或 notifyAll()方法）时才能唤醒等待池中的线程进入等锁池 （lock pool），如果线程重新获得对象的锁就可以进入就绪状态。<br> 补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线 程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数 据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线 程是进程的一个实体，是 CPU 调度和分派的基本单位，是比进程更小的能独立运 行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程 在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编 程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友 好的，因为它可能占用了更多的 CPU 资源。当然，也不是线程越多，程序的性能 就越好，因为线程之间的调度和切换也会浪费 CPU 时间。</p> 
<p><strong>55、线程的sleep()方法和yield()方法有什么区别？</strong><br> 答：<br> ① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br> ② 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转 入就绪（ready）状态；<br> ③ sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异 常；<br> ④ sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。</p> 
<p><strong>59、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</strong><br> 答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p> 
<p><strong>60、请说出与线程同步以及线程调度相关的方法。</strong><br> 答：</p> 
<ul><li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用 此方法要处理InterruptedException异常；  notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并 不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且 与优先级无关；  notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给 所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li></ul> 
<p>补充：Java 5 通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活 性以及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方 法，同时还提供了 newCondition()方法来产生用于线程之间通信的 Condition 对 象；此外，Java 5 还提供了信号量机制（semaphore），信号量可以用来限制对 某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信 号量的许可（调用 Semaphore 对象的 acquire()方法）；在完成对资源的访问后， 线程必须向信号量归还许可（调用 Semaphore 对象的 release()方法）。</p> 
<p><strong>61、编写多线程程序有几种实现方式？</strong></p> 
<ul><li>继承Thread类</li><li>实现Runnable接口</li><li>匿名内部类</li><li>实现Callable接口通过FutureTask包装器来创建Thread线程</li><li>通过线程池创建线程，使用线程池接口ExecutorService结合Callable、Future实现有返回结果的多线程。</li></ul> 
<p>前面三种【无返回值】原因：通过重写run方法，run方法的返回值是void，所以没有办法返回结果。在run方法处理异常时，不能抛出异常，只能用try{ }catch(){}中捕获异常。<br> 后面两种【有返回值】原因：通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中。</p> 
<p><strong>63、举例说明同步和异步。</strong><br> 答：如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线 程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好 的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并 且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异 步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。</p> 
<p>64、启动一个线程是调用run()还是start()方法？<br> 答：启动一个线程是调用 start()方法，使线程所代表的虚拟处理机处于可运行状态， 这意味着它可以由 JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。</p> 
<p><strong>65、什么是线程池（thread pool）？</strong><br> 答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内 存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象， 以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽 可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就 是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的 线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完 毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口 是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理 不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生 成一些常用的线程池，如下所示：</p> 
<ul><li>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只 有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线 程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li><li>newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li><li>newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的 线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程 池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM） 能够创建的最大线程大小。</li><li>newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li></ul> 
<p><strong>66、线程的基本状态以及状态之间的关系？</strong><br> 答：<br> <img src="https://images2.imgbox.com/6f/f2/2VLBJQN5_o.png" alt="在这里插入图片描述"><br> 说明：其中 Running 表示运行状态，Runnable 表示就绪状态（万事俱备，只欠 CPU），Blocked 表示阻塞状态，阻塞状态又有多种情况，可能是因为调用 wait() 方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用 了 sleep()方法或 join()方法等待休眠或其他线程结束，或是因为发生了 I/O 中断。</p> 
<p><strong>67、简述synchronized 和java.util.concurrent.locks.Lock的异同？</strong><br> 答：Lock 是 Java 5 并发包以后引入的新的 API，和关键字 synchronized 相比主要相同点： Lock 能完成 synchronized 所实现的所有功能；主要不同点：Lock 有比 synchronized 更精确的线程语义和更好的性能，而且不强制性的要求一定要获得 锁。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且最好 在 finally 块中释放（这是释放外部资源的最好的地方）。</p> 
<p><strong>68、Java中如何实现序列化，有什么意义？</strong><br> 答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流 化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。 序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会 存在数据乱序的问题）。 要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口， 标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通 过 writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要 反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中 读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。</p> 
<p><strong>69、Java中有几种类型的流？</strong><br> 答：字节流和字符流。字节流继承于 InputStream、OutputStream，字符流继承于 Reader、Writer。在 java.io 包中还有许多其他的流，主要是为了提高性能和使 用方便。关于 Java 的 I/O 需要注意的有两点：一是两种对称性（输入和输出的对 称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。</p> 
<p><strong>70、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？</strong><br> 答：XML 文档定义分为 DTD 和 Schema 两种形式，二者都是对 XML 语法的约束，其本质区别在于 Schema 本身也是一个 XML 文件，可以被 XML 解析器解析，而且 可以为 XML 承载的数据定义类型，约束能力较之 DTD 更强大。对 XML 的解析主 要有 DOM（文档对象模型，Document Object Model）、SAX（Simple API for XML）和 StAX（Java 6 中引入的新的解析 XML 的方式，Streaming API for XML），其中 DOM 处理大型文件时其性能下降的非常厉害，这个问题是由 DOM 树结构占用的内存较多造成的，而且 DOM 解析方式必须在解析文件之前把整个文档装入内存，适合对 XML 的随机访问（典型的用空间换取时间的策略）；SAX 是事件驱动型的 XML 解析方式，它顺序读取 XML 文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件， 用户通过事件回调代码来处理 XML 文件，适合对 XML 的顺序访问；顾名思义， StAX 把重点放在流上，实际上 StAX 与其他解析方式的本质区别就在于应用程序能够把 XML 作为一个事件流来处理。将 XML 作为一组事件来处理的想法并不新颖（SAX 就是这样做的），但不同之处在于 StAX 允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。</p> 
<p><strong>71、阐述JDBC操作数据库的步骤。</strong><br> 答：下面的代码以连接本机的 Oracle 数据库为例，演示 JDBC 操作数据库的步骤。</p> 
<ul><li>加载驱动</li></ul> 
<pre><code class="prism language-java">Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"oracle.jdbc.driver.OracleDriver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>创建连接。</li></ul> 
<pre><code class="prism language-java">Connection con <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:oracle:thin:@localhost:1521:orcl"</span><span class="token punctuation">,</span> <span class="token string">"scott"</span><span class="token punctuation">,</span> <span class="token string">"tiger"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>创建语句。</li></ul> 
<pre><code class="prism language-java">PreparedStatement ps <span class="token operator">=</span> con<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span><span class="token string">"select * from emp where sal between ? and ?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>执行语句。</p> 
<pre><code class="prism language-java">ResultSet rs <span class="token operator">=</span> ps<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>处理结果。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
	System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"empno"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" - "</span> <span class="token operator">+</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"ename"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>关闭资源</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span> 
	<span class="token keyword">if</span><span class="token punctuation">(</span>con <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
		<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span> 
			con<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
		<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
			e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
		<span class="token punctuation">}</span> 
	<span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>72、Statement和PreparedStatement有什么区别？哪个性能更好？</strong><br> 答：与 Statement 相比，①PreparedStatement 接口代表预编译的语句，它主要的优 势在于可以减少 SQL 的编译错误并增加 SQL 的安全性（减少 SQL 注射攻击的可 能性）；②PreparedStatement 中的 SQL 语句是可以带参数的，避免了用字符串 连接拼接 SQL 语句的麻烦和不安全；③当批量处理 SQL 或频繁执行相同的查询时， PreparedStatement 有明显的性能上的优势，由于数据库可以将编译优化后的 SQL 语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成 执行计划）。<br> 补充：为了提供对存储过程的调用，JDBC API 中还提供了CallableStatement 接 口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的 SQL 语 句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数 （如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全 性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦， 因为每种数据库的存储过程在书写上存在不少的差别。</p> 
<p><strong>73、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？</strong><br> 答：要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize() 方法指定每次抓取的记录数（典型的空间换时间策略）；<br> 要提升更新数据的性能可以使用 PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处 理中执行。</p> 
<p><strong>74、在进行数据库编程时，连接池有什么作用？</strong><br> 答：由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每 次建立连接都需要进行 TCP 的三次握手，释放连接需要进行 TCP 四次握手，造成 的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连 接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭 连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间 的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在 Java 开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于 Java 的 开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid 等。</p> 
<p><strong>75、什么是DAO模式？</strong><br> 答：DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了 抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访 问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在 一个公共 API 中。用程序设计语言来说，就是建立一个接口，接口中定义了此应 用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该 类对应一个特定的数据存储。DAO 模式实际上包含了两个模式，一是 Data Accessor（数据访问器），二是 Data Object（数据对象），前者要解决如何访 问数据的问题，而后者要解决的是如何用对象封装数据。</p> 
<p><strong>76、事务的ACID是指什么？</strong><br> 答：</p> 
<ul><li>原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作 的失败都会导致整个事务的失败；</li><li>一致性(Consistent)：事务结束后系统状态是一致的；</li><li>隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态；</li><li>持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难 性的失败。通过日志和同步备份可以在故障发生后重建数据。<br> 补充：关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。 首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一 数据时，可能会存在 5 类问题，包括 3 类数据读取问题（脏读、不可重复读和幻 读）和 2 类数据更新问题（第 1 类丢失更新和第 2 类丢失更新）。<br> 脏读（Dirty Read）：A 事务读取 B 事务尚未提交的数据并在此基础上操作，而 B 事务执行回滚，那么 A 读取到的数据就是脏数据。<br> 不可重复读（Unrepeatable Read）：事务 A 重新读取前面读取过的数据，发现 该数据已经被另一个已提交的事务 B 修改过了。<br> 幻读（Phantom Read）：事务 A 重新执行一个查询，返回一系列符合查询条件 的行，发现其中插入了被事务 B 提交的行。</li></ul> 
<p><strong>77、JDBC 中如何进行事务处理？</strong><br> 答：Connection 提供了事务处理的方法，通过调用 setAutoCommit(false)可以设置 手动提交事务；当事务完成后用 commit()显式提交事务；如果在事务处理过程中 发生异常则通过 rollback()进行事务回滚。除此之外，从 JDBC 3.0 中还引入了 Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保 存点。</p> 
<p><strong>78、JDBC能否处理Blob和Clob？</strong><br> 答：Blob 是指二进制大对象（Binary Large Object），而 Clob 是指大字符对象 （Character Large Objec），因此其中 Blob 是为存储大的二进制数据而设计的， 而 Clob 是为存储大的文本数据而设计的。JDBC 的 PreparedStatement 和 ResultSet 都提供了相应的方法来支持 Blob 和 Clob 操作。</p> 
<p><strong>79、简述正则表达式及其用途。</strong><br> 答：在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。 正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本 规则的代码。<br> 说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用 计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符 串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支 持。</p> 
<p><strong>80、Java中是如何支持正则表达式操作的？</strong><br> 答：Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、 replaceAll()、replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则 表达式对象，它提供了丰富的 API 进行各种正则表达式操作。</p> 
<p><strong>81、获得一个类的类对象有哪些方式？</strong><br> 答：</p> 
<ul><li>方法1：类型.class，例如：String.class</li><li>方法2：对象.getClass()，例如：”hello”.getClass()</li><li>方法3：Class.forName()，例如：Class.forName(“java.lang.String”)</li></ul> 
<p><strong>82、如何通过反射创建对象？</strong><br> 答：<br> ① 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()<br> ② 方法2：通过类对象的getConstructor()或getDeclaredConstructor() 方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象， 例如：String.class.getConstructor(String.class).newInstance(“Hello”);</p> 
<p><strong>83、如何通过反射调用对象的方法？</strong><br> 答：请看下面的代码：</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span>
	<span class="token keyword">class</span> <span class="token class-name">MethodInvokeTest</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{<!-- --></span> 
			String str <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> 
			Method m <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"toUpperCase"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
			System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出HELLO		    		</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>84、简述一下面向对象的”六原则一法则”。</strong></p> 
<ul><li>单一职责原则：一个类只做它该做的事情。 （单一职责原则想表达的就是” 高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝 典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一 个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事， 而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。</li><li>开闭原则：软件实体应当对扩展开放，对修改关闭。。要做到开闭有两个要点：①抽象是关 键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系 统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系 统将变得复杂而换乱。</li><li>依赖倒转原则：面向接口编程。</li><li>里氏替换原则：任何时候都可以用子类型替换掉父类型。（但简单的说就是能用父 类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如 果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对 代码进行重构。例如让猫继承狗是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是： 子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更 多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</li><li>接口隔离原则：接口要小而专，绝不能大而全 。</li><li>合成聚合复用原则：优先使用聚合或合成关系复用代码。</li><li>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有 尽可能少的了解。</li></ul> 
<p><strong>85、简述一下你了解的设计模式。</strong><br> 答：所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经 过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他 人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计 和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解 其设计思路。<br> 23 种设计模式：包括：Abstract Factory（抽象工厂模式）， Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始 模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器 模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模 式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式）， Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式）， State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。</p> 
<p><strong>86、用Java写一个单例类。</strong><br> 答：</p> 
<ul><li>饿汉式单例</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span> 
	<span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> 
	<span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
		<span class="token keyword">return</span> instance<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>懒汉式单例</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span> 
	<span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> null<span class="token punctuation">;</span> 
	<span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> 
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		 <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		 	instance ＝ <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		 <span class="token punctuation">}</span>
	  	<span class="token keyword">return</span> instance<span class="token punctuation">;</span>
	   <span class="token punctuation">}</span> 
   <span class="token punctuation">}</span>
</code></pre> 
<p>注意：实现一个单例有两点注意事项，①将构造器私有，不允许外界通过构造器 创建对象；②通过公开的静态方法向外界返回类的唯一实例。这里有一个问题可 以思考：Spring 的 IoC 容器可以为普通的类创建单例，它是怎么做到的呢？</p> 
<p><strong>87、什么是UML？UML中有哪些常用的图？</strong><br> 答：UML 是统一建模语言（Unified Modeling Language）的缩写，它发表于 1997 年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型 化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。<br> 常用图包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、 活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来 捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、 类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描 述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能 接收的消息也就是说对象能够向外界提供的服务）。</p> 
<p>====================================================================</p> 
<p>······<br> 帮助他人，快乐自己，最后，感谢您的阅读！<br> 所以如有纰漏或者建议，还请读者朋友们在评论区不吝指出！</p> 
<p><a href="http://myxiangwei.sxl.cn/" rel="nofollow">个人网站</a>…知识是一种宝贵的资源和财富，益发掘，更益分享…</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0010883cf03f5b67c80e94ee2975ff11/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python】 第3章-3 输出字母在字符串中位置索引 (20分)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d45b556fc3640d7c8d6f58a075441e21/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">P5704 【深基2.例6】字母转换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>