<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>arm64 smmu 驱动笔记 （4.19） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="arm64 smmu 驱动笔记 （4.19）" />
<meta property="og:description" content="设备StreamID：sid struct iommu_fwspec { const struct iommu_ops	*ops; struct fwnode_handle	*iommu_fwnode; void	*iommu_priv; unsigned int	num_ids; u32	ids[1]; //ids保存的某device使用的streamID }; 通过iommu_fwspec_add_id函数设置：
struct iommu_fwspec { const struct iommu_ops	*ops; struct fwnode_handle	*iommu_fwnode; void	*iommu_priv; unsigned int	num_ids; //和该设备关联的总共ids/streamID u32	ids[1];//sid内容数组 }; int iommu_fwspec_add_ids(struct device *dev, u32 *ids, int num_ids) { struct iommu_fwspec *fwspec = dev-&gt;iommu_fwspec; size_t size; int i; if (!fwspec) return -EINVAL; size = offsetof(struct iommu_fwspec, ids[fwspec-&gt;num_ids &#43; num_ids]); if (size &gt; sizeof(*fwspec)) { fwspec = krealloc(dev-&gt;iommu_fwspec, size, GFP_KERNEL); if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/cc61181d15bf3b6382c427d5d116c539/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-17T10:55:12+08:00" />
<meta property="article:modified_time" content="2023-10-17T10:55:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">arm64 smmu 驱动笔记 （4.19）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>设备StreamID：sid</h4> 
<pre><code>struct iommu_fwspec {
	const struct iommu_ops	*ops;
	struct fwnode_handle	*iommu_fwnode;
	void			*iommu_priv;
	unsigned int		num_ids;
	u32			ids[1];  //ids保存的某device使用的streamID
};</code></pre> 
<p>通过iommu_fwspec_add_id函数设置：</p> 
<pre><code>struct iommu_fwspec {
	const struct iommu_ops	*ops;
	struct fwnode_handle	*iommu_fwnode;
	void			*iommu_priv;
	unsigned int		num_ids;  //和该设备关联的总共ids/streamID
	u32			ids[1];//sid内容数组
};


int iommu_fwspec_add_ids(struct device *dev, u32 *ids, int num_ids)
{
        struct iommu_fwspec *fwspec = dev-&gt;iommu_fwspec;
        size_t size;
        int i;

        if (!fwspec)
                return -EINVAL;

        size = offsetof(struct iommu_fwspec, ids[fwspec-&gt;num_ids + num_ids]);
        if (size &gt; sizeof(*fwspec)) {
                fwspec = krealloc(dev-&gt;iommu_fwspec, size, GFP_KERNEL);
                if (!fwspec)
                        return -ENOMEM;

                dev-&gt;iommu_fwspec = fwspec;
        }

        for (i = 0; i &lt; num_ids; i++)
                fwspec-&gt;ids[fwspec-&gt;num_ids + i] = ids[i];

        fwspec-&gt;num_ids += num_ids;
        return 0;
}
</code></pre> 
<p>设置流程dump_stack信息: </p> 
<blockquote> 
 <p><br> [   79.499624] ===iommu_fwspec_add_ids for dev 0000:0a:00.0 num_ids 1<br> [   79.505862] CPU: 29 PID: 1 Comm: swapper/0 Not tainted 4.19.0l+ #20<br> [   79.512098] Hardware name: PHYTIUM LTD Phytium S2500/64/Phytium S2500/64, BIOS V2.2 Feb  9 2021<br> [   79.520754] Call trace:<br> [   79.523192]  dump_backtrace+0x0/0x1c0<br> [   79.526838]  show_stack+0x24/0x30<br> [   79.530138]  dump_stack+0x9c/0xbc<br> [   79.533439]  iommu_fwspec_add_ids+0x44/0xd0<br> [   79.537602]  iort_iommu_xlate+0x144/0x170<br> [   79.541592]  iort_pci_iommu_init+0x58/0x80<br> [   79.545670]  pci_for_each_dma_alias+0x44/0x188<br> [   79.550093]  iort_iommu_configure+0xac/0x1c8<br> [   79.554343]  acpi_dma_configure+0x68/0xbc<br> [   79.558333]  pci_dma_configure+0xa8/0xc8<br> [   79.562236]  dma_configure+0x4c/0x64<br> [   79.565795]  really_probe+0x98/0x3b8<br> [   79.569354]  driver_probe_device+0x6c/0x138<br> [   79.573516]  __driver_attach+0x118/0x150<br> [   79.577419]  bus_for_each_dev+0x84/0xd8<br> [   79.581237]  driver_attach+0x30/0x40<br> [   79.584795]  bus_add_driver+0x20c/0x250<br> [   79.588613]  driver_register+0x64/0x110<br> [   79.592430]  __pci_register_driver+0x58/0x68<br> [   79.596681]  xhci_pci_init+0x58/0x64<br> [   79.600240]  do_one_initcall+0x68/0x1e4<br> [   79.604059]  kernel_init_freeable+0x2d0/0x388<br> [   79.608396]  kernel_init+0x18/0x108<br> [   79.611867]  ret_from_fork+0x10/0x1c<br>  </p> 
</blockquote> 
<h4>iort_iommu_configure函数：</h4> 
<pre><code>//drivers/acpi/arm64/iort.c
const struct iommu_ops *iort_iommu_configure(struct device *dev)
{
	struct acpi_iort_node *node, *parent;
	const struct iommu_ops *ops;
	u32 streamid = 0;
	int err = -ENODEV;

	/*
	 * If we already translated the fwspec there
	 * is nothing left to do, return the iommu_ops.
	 */
	ops = iort_fwspec_iommu_ops(dev-&gt;iommu_fwspec);
	if (ops)
		return ops;

	if (dev_is_pci(dev)) { //PCI设备的sid 使用的是BDF号。
		struct pci_bus *bus = to_pci_dev(dev)-&gt;bus;
		struct iort_pci_alias_info info = { .dev = dev };

		node = iort_scan_node(ACPI_IORT_NODE_PCI_ROOT_COMPLEX,
				      iort_match_node_callback, &amp;bus-&gt;dev);
		if (!node)
			return NULL;

		info.node = node;
//计算sid
		err = pci_for_each_dma_alias(to_pci_dev(dev),
					     iort_pci_iommu_init, &amp;info); 
	} else {
		int i = 0;

		node = iort_scan_node(ACPI_IORT_NODE_NAMED_COMPONENT,
				      iort_match_node_callback, dev);
		if (!node)
			return NULL;

		do {
			parent = iort_node_map_platform_id(node, &amp;streamid,
							   IORT_IOMMU_TYPE,
							   i++);

			if (parent)
				err = iort_iommu_xlate(dev, parent, streamid);
		} while (parent &amp;&amp; !err);
	}

	/*
	 * If we have reason to believe the IOMMU driver missed the initial
	 * add_device callback for dev, replay it to get things in order.
	 */
	if (!err) {
		ops = iort_fwspec_iommu_ops(dev-&gt;iommu_fwspec);
		err = iort_add_device_replay(ops, dev);
	}

	/* Ignore all other errors apart from EPROBE_DEFER */
	if (err == -EPROBE_DEFER) {
		ops = ERR_PTR(err);
	} else if (err) {
		dev_dbg(dev, "Adding to IOMMU failed: %d\n", err);
		ops = NULL;
	}

	return ops;
}



 */
int pci_for_each_dma_alias(struct pci_dev *pdev,
			   int (*fn)(struct pci_dev *pdev,
				     u16 alias, void *data), void *data)
{
    .....
	struct pci_bus *bus;
	int ret;

	ret = fn(pdev, PCI_DEVID(pdev-&gt;bus-&gt;number, pdev-&gt;devfn), data);
    .....
}


static int iort_pci_iommu_init(struct pci_dev *pdev, u16 alias, void *data)
{
	struct iort_pci_alias_info *info = data;
	struct acpi_iort_node *parent;
	u32 streamid;

	parent = iort_node_map_id(info-&gt;node, alias, &amp;streamid,
				  IORT_IOMMU_TYPE);
	return iort_iommu_xlate(info-&gt;dev, parent, streamid);
}

最终：
static int arm_smmu_iort_xlate(struct device *dev, u32 streamid,
			       struct fwnode_handle *fwnode,
			       const struct iommu_ops *ops)
{
	int ret = iommu_fwspec_init(dev, fwnode, ops);

	if (!ret)
		ret = iommu_fwspec_add_ids(dev, &amp;streamid, 1);  //添加streamid

	return ret;
}</code></pre> 
<h4>arm_smmu_add_device</h4> 
<p>在drivers/iommu/arm-smmu.c的 arm_smmu_add_device函数中：</p> 
<pre><code>#ifdef CONFIG_ARCH_PHYTIUM
#define FWID_READ(id) (((u16)(id) &gt;&gt; 3) | (((id) &gt;&gt; SMR_MASK_SHIFT | 0x7000) &lt;&lt; SMR_MASK_SHIFT))
#endif
//默认streamID会使用pci的bdf，但ft2000+ 硬件实现上不同，该值会通过FWID_READ函数进行调整。iommu_fwspec_add_ids加入到fwspec中。因此一个设备会有两个sid。

static int arm_smmu_add_device(struct device *dev)
{
        struct arm_smmu_device *smmu;
        struct arm_smmu_master_cfg *cfg;
        struct iommu_fwspec *fwspec = dev-&gt;iommu_fwspec;
        int i, ret;

#ifdef CONFIG_ARCH_PHYTIUM
        /* FT2000PLUS workaround patch */
        if ((read_cpuid_id() &amp; MIDR_CPU_MODEL_MASK) == MIDR_PHYTIUM_FT2000PLUS) {
                printk("===arm_smmu_add_device ft2000+ \n");
                int num = fwspec-&gt;num_ids;
                for (i = 0; i &lt; num; i++) {
                        u32 fwid = FWID_READ(fwspec-&gt;ids[i]);
                        printk("===arm_smmu_add_device ft2000+ ids %llx to fwid %llx \n",fwspec-&gt;ids[i],fwid);
                        iommu_fwspec_add_ids(dev, &amp;fwid, 1);
                }
        }
#endif

..............
打印一下设备的sid
       for (i = 0; i &lt; fwspec-&gt;num_ids; i++) {
                u16 sid = fwspec-&gt;ids[i];
                u16 mask = fwspec-&gt;ids[i] &gt;&gt; SMR_MASK_SHIFT;
                printk("===arm_smmu_add_device for dev %s num_ids %d of %d sid %llx  \n",dev_name(dev),fwspec-&gt;num_ids,i,sid);
                if (sid &amp; ~smmu-&gt;streamid_mask) {
                        dev_err(dev, "stream ID 0x%x out of range for SMMU (0x%x)\n",
                                sid, smmu-&gt;streamid_mask);
                        goto out_free;
                }
                if (mask &amp; ~smmu-&gt;smr_mask_mask) {
                        dev_err(dev, "SMR mask 0x%x out of range for SMMU (0x%x)\n",
                                mask, smmu-&gt;smr_mask_mask);
                        goto out_free;
                }
        }
...................

        ret = arm_smmu_master_alloc_smes(dev); //分配stream mapping entry 表项

}</code></pre> 
<p>ft2000+日志：0000:04:00.x  都有一个-x80的sid。</p> 
<blockquote> 
 <p><span style="color:#0d0016;">[   11.775255] ===arm_smmu_add_device for dev 0000:41:00.0 num_ids 2 of 0 sid 4100  <br> [   11.782698] ===arm_smmu_add_device for dev 0000:41:00.0 num_ids 2 of 1 sid 820  <br> [   12.576919] ===arm_smmu_add_device for dev 0000:03:00.0 num_ids 2 of 0 sid 300  <br> [   12.576922] ===arm_smmu_add_device for dev 0000:03:00.0 num_ids 2 of 1 sid 60  <br> [   15.638439] ===arm_smmu_add_device for dev </span><span style="color:#fe2c24;">0000:04:00.0</span><span style="color:#0d0016;"> num_ids 2 of 0 sid 400</span><span style="color:#fe2c24;">  <br><strong>[   15.645802] ===arm_smmu_add_device for dev 0000:04:00.0 num_ids 2 of 1 sid 80  </strong></span><br><span style="color:#0d0016;">[   16.494888] ===arm_smmu_add_device for dev 0000:51:00.0 num_ids 2 of 0 sid 5100  <br> [   16.502947] ===arm_smmu_add_device for dev 0000:51:00.0 num_ids 2 of 1 sid a20  <br> [   17.105745] ===arm_smmu_add_device for dev </span><span style="color:#fe2c24;">0000:04:00.1 num_ids 2 of 0 sid 401</span><span style="color:#0d0016;">  </span><br><span style="color:#fe2c24;"><strong>[   17.119853] ===arm_smmu_add_device for dev 0000:04:00.1 num_ids 2 of 1 sid 80  </strong></span><br><span style="color:#0d0016;">[   18.338789] ===arm_smmu_add_device for dev </span><span style="color:#fe2c24;">0000:04:00.2 num_ids 2 of 0 sid 402</span><span style="color:#0d0016;">  </span><br><span style="color:#fe2c24;"><strong>[   18.346151] ===arm_smmu_add_device for dev 0000:04:00.2 num_ids 2 of 1 sid 80  </strong></span><br><span style="color:#0d0016;">[   19.099235] ===arm_smmu_add_device for dev </span><span style="color:#fe2c24;">0000:04:00.3 num_ids 2 of 0 sid 403  <br><strong>[   19.099237] ===arm_smmu_add_device for dev 0000:04:00.3 num_ids 2 of 1 sid 80 </strong></span></p> 
</blockquote> 
<p> 上述中发现一个dev可能有多个sid，如iommu_fwspec_add_ids函数关联了多个sid的话，最终往iommu_fwspec 中填充sid数组值。</p> 
<p> 在arm_smmu_add_device函数中建立一个设备下的sid和其它数据的关系：</p> 
<pre><code>static int arm_smmu_add_device(struct device *dev)
{

#ifdef CONFIG_ARCH_PHYTIUM
#define FWID_READ(id) (((u16)(id) &gt;&gt; 3) | (((id) &gt;&gt; SMR_MASK_SHIFT | 0x7000) &lt;&lt; SMR_MASK_SHIFT))
        /* FT2000PLUS workaround patch */
        if ((read_cpuid_id() &amp; MIDR_CPU_MODEL_MASK) == MIDR_PHYTIUM_FT2000PLUS) {
                int num = fwspec-&gt;num_ids;
                for (i = 0; i &lt; num; i++) {
                        u32 fwid = FWID_READ(fwspec-&gt;ids[i]);
                        iommu_fwspec_add_ids(dev, &amp;fwid, 1); //这里对2000+进行特殊处理，再一次添加了处理后的sid值，应该是2000+处理器的smmu识别sid的方式不一样，
                }
        }
#endif


        ret = -EINVAL;
        for (i = 0; i &lt; fwspec-&gt;num_ids; i++) {
                u16 sid = fwspec-&gt;ids[i];
                u16 mask = fwspec-&gt;ids[i] &gt;&gt; SMR_MASK_SHIFT;

                if (sid &amp; ~smmu-&gt;streamid_mask) {
                        dev_err(dev, "stream ID 0x%x out of range for SMMU (0x%x)\n",
                                sid, smmu-&gt;streamid_mask);
                        goto out_free;
                }
                if (mask &amp; ~smmu-&gt;smr_mask_mask) {
                        dev_err(dev, "SMR mask 0x%x out of range for SMMU (0x%x)\n",
                                mask, smmu-&gt;smr_mask_mask);
                        goto out_free;
                }
        }

        ret = -ENOMEM;
//cfg的smendx数组大小刚好和fwspec的num_ids一致，后面要保存数据。
        cfg = kzalloc(offsetof(struct arm_smmu_master_cfg, smendx[i]),
                      GFP_KERNEL);
        if (!cfg)
                goto out_free;

        cfg-&gt;smmu = smmu;
        fwspec-&gt;iommu_priv = cfg;
        while (i--)
                cfg-&gt;smendx[i] = INVALID_SMENDX;

        ret = arm_smmu_master_alloc_smes(dev);

}</code></pre> 
<p></p> 
<h4>arm_smmu_attach_dev函数：</h4> 
<p>arm_smmu_init_domain_context初始化domain，是arm_smmu_add_device一路调用到arm_smmu_attach_dev：</p> 
<pre><code>static int arm_smmu_init_domain_context(struct iommu_domain *domain,
					struct arm_smmu_device *smmu)
{
    ............

	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);
	struct arm_smmu_cfg *cfg = &amp;smmu_domain-&gt;cfg;

    ret = __arm_smmu_alloc_bitmap(smmu-&gt;context_map, start,
				      smmu-&gt;num_context_banks);

    cfg-&gt;cbndx = ret;  //将上述获取的全局唯一context bank 编号 保存在cfg-&gt;cbndx
    

	arm_smmu_init_context_bank(smmu_domain, &amp;pgtbl_cfg); //设置好cb等参数。其中包括lape获取的页表等内容。
	arm_smmu_write_context_bank(smmu, cfg-&gt;cbndx); //编号作为参数
    ............

}


static void arm_smmu_write_context_bank(struct arm_smmu_device *smmu, int idx)
{
............
cb_base = ARM_SMMU_CB(smmu, idx); //根据编号获取cb_base地址

下面是一些写寄存器的操作
	/* TTBRs */
	if (cfg-&gt;fmt == ARM_SMMU_CTX_FMT_AARCH32_S) {
		writel_relaxed(cfg-&gt;asid, cb_base + ARM_SMMU_CB_CONTEXTIDR);
		writel_relaxed(cb-&gt;ttbr[0], cb_base + ARM_SMMU_CB_TTBR0);
		writel_relaxed(cb-&gt;ttbr[1], cb_base + ARM_SMMU_CB_TTBR1);
	} else {
		writeq_relaxed(cb-&gt;ttbr[0], cb_base + ARM_SMMU_CB_TTBR0); //将ttbr[0]写入，其中保存的是页表的pgd基地址。
		if (stage1)
			writeq_relaxed(cb-&gt;ttbr[1], cb_base + ARM_SMMU_CB_TTBR1);
	}

............

}</code></pre> 
<blockquote> 
 <p>[   78.770289] ===arm_smmu_init_domain_context for dev arm-smmu.0.auto domain ffff8139415a1b50 smmu ffff834941ef0018  smmu_doamin-&gt;stage 0 fmt 2 cfg-&gt;cbndx 0<br> [   78.784048] CPU: 28 PID: 1 Comm: swapper/0 Not tainted 4.19.0l+ #40<br> [   78.790284] Hardware name: PHYTIUM LTD Phytium S2500/64/Phytium S2500/64, BIOS V2.2 Feb  9 2021<br> [   78.798938] Call trace:<br> [   78.801373]  dump_backtrace+0x0/0x1c0<br> [   78.805017]  show_stack+0x24/0x30<br> [   78.808316]  dump_stack+0x9c/0xbc<br> [   78.811615]  <span style="color:#fe2c24;">arm_smmu_attach_dev</span>+0x44c/0x788<br> [   78.815864]  __iommu_attach_device+0x54/0xf8 <br> [   78.820113]  iommu_group_add_device+0x17c/0x478<br> [   78.824621]  iommu_group_get_for_dev+0x74/0x178<br> [   78.829129]  <span style="color:#fe2c24;">arm_smmu_add_device</span>+0x218/0x6b8<br> [   78.833379]  iort_iommu_configure+0x144/0x1c8<br> [   78.837715]  acpi_dma_configure+0x68/0xbc<br> [   78.841705]  pci_dma_configure+0xa8/0xc8<br> [   78.845608]  dma_configure+0x4c/0x64<br> [   78.849166]  really_probe+0x98/0x3b8<br> [   78.852725]  driver_probe_device+0x6c/0x138<br> [   78.856887]  __driver_attach+0x118/0x150<br> [   78.860790]  bus_for_each_dev+0x84/0xd8<br> [   78.864608]  driver_attach+0x30/0x40<br> [   78.868166]  bus_add_driver+0x20c/0x250<br> [   78.871984]  driver_register+0x64/0x110<br> [   78.875802]  __pci_register_driver+0x58/0x68<br> [   78.880051]  ahci_pci_driver_init+0x28/0x30<br> [   78.884213]  do_one_initcall+0x68/0x1e4<br> [   78.888031]  kernel_init_freeable+0x2d0/0x388<br> [   78.892367]  kernel_init+0x18/0x108<br> [   78.895839]  ret_from_fork+0x10/0x1c<br>  </p> 
</blockquote> 
<h4>设备创建group和doamin流程 </h4> 
<pre><code>device：加组流程
really_probe
	dma_configure
		pci_dma_configure
			acpi_dma_configure
				iort_iommu_configure
					arm_smmu_add_device
						arm_smmu_master_alloc_smes
							iommu_group_get_for_dev
								arm_smmu_device_group //创建iommu_group
								group-&gt;default_domain = dom; //创建domain
								group-&gt;domain = dom;
								iommu_group_add_device //将deive加入到group链表，将iommu_grouop 赋值dev-&gt;iommu_group指针
									__iommu_attach_device
										arm_smmu_attach_dev
							for_each_cfg_sme：smmu-&gt;s2crs[idx].group = group; //循环将该device下的第idxg个s2crs数组分配group
	


arm_smmu_device_group
	pci_device_group
		alloc_group
	generic_device_group
</code></pre> 
<p></p> 
<h4>关联smmu下的<strong><strong><strong>SMMU_SMRn寄存器。其中写入streamID。</strong></strong></strong> </h4> 
<p>相关寄存器参考：<a href="https://blog.csdn.net/gaojy19881225/article/details/82585842" title="(66条消息) Smmu硬件寄存器—V2_一墨一飞花的博客-CSDN博客_smmu context bank">(66条消息) Smmu硬件寄存器—V2_一墨一飞花的博客-CSDN博客_smmu context bank</a></p> 
<p>SMMU_SMRn<br> streamID匹配寄存器。</p> 
<p>        EXMASK, bits[31:16] 屏蔽无关位，如果EXMASK[i]==1，则EXID[i]被忽略；</p> 
<p>                相反，EXMASK[i]==0，则EXID[i]有效，用于匹配</p> 
<p>        EXID, bits[15:0] 用于匹配的streamID</p> 
<pre><code>static int arm_smmu_master_alloc_smes(struct device *dev)
{
	struct iommu_fwspec *fwspec = dev-&gt;iommu_fwspec;
	struct arm_smmu_master_cfg *cfg = fwspec-&gt;iommu_priv;
	struct arm_smmu_device *smmu = cfg-&gt;smmu;
	struct arm_smmu_smr *smrs = smmu-&gt;smrs;
	struct iommu_group *group;
	int i, idx, ret;

	mutex_lock(&amp;smmu-&gt;stream_map_mutex);
	/* Figure out a viable stream map entry allocation */
	for_each_cfg_sme(fwspec, i, idx) {
		u16 sid = fwspec-&gt;ids[i];
		u16 mask = fwspec-&gt;ids[i] &gt;&gt; SMR_MASK_SHIFT;

		if (idx != INVALID_SMENDX) {
			ret = -EEXIST;
			goto out_err;
		}

		ret = arm_smmu_find_sme(smmu, sid, mask); //分配一个smmu下唯一的idx给当前设备的arm_smmu_master_cfg ,如果sid一致，则返回同样的idx。这个在ft2000+上就是这种情况，bus_dev_fn忽略fn则会导致很多设备相同。
		if (ret &lt; 0)
			goto out_err;

		idx = ret;
		if (smrs &amp;&amp; smmu-&gt;s2crs[idx].count == 0) {
			smrs[idx].id = sid; //将streamid保存在全局smrs数组下，后续写入寄存器中，一个设备有多个sid的情况下也会分配多个全局唯一的idx。
			smrs[idx].mask = mask;
			smrs[idx].valid = true;
		}
		smmu-&gt;s2crs[idx].count++;
		cfg-&gt;smendx[i] = (s16)idx;  //设置当前设备arm_smmu_master_cfg 数组smendx为smmu全局分配的idx值。
	}

	group = iommu_group_get_for_dev(dev);
	if (!group)
		group = ERR_PTR(-ENOMEM);
	if (IS_ERR(group)) {
		ret = PTR_ERR(group);
		goto out_err;
	}
	iommu_group_put(group);

	/* It worked! Now, poke the actual hardware */
	for_each_cfg_sme(fwspec, i, idx) {
		arm_smmu_write_sme(smmu, idx);  //将smrs下的sid写入寄存器中。根据idx来定位寄存器地址。
		smmu-&gt;s2crs[idx].group = group;
	}

	mutex_unlock(&amp;smmu-&gt;stream_map_mutex);
	return 0;

out_err:
	while (i--) {
		arm_smmu_free_sme(smmu, cfg-&gt;smendx[i]);
		cfg-&gt;smendx[i] = INVALID_SMENDX;
	}
	mutex_unlock(&amp;smmu-&gt;stream_map_mutex);
	return ret;
}</code></pre> 
<p> 关联smmu下的s2cr寄存器。</p> 
<pre><code>static int arm_smmu_domain_add_master(struct arm_smmu_domain *smmu_domain,
				      struct iommu_fwspec *fwspec)
{
	struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;
	struct arm_smmu_s2cr *s2cr = smmu-&gt;s2crs;
	u8 cbndx = smmu_domain-&gt;cfg.cbndx;   //init_context_bank 中分配的，从bitmap中查找的唯一编号，参考arm_smmu_init_domain_context中分配cfg-&gt;cbndx的过程。
	enum arm_smmu_s2cr_type type;
	int i, idx;

	if (smmu_domain-&gt;stage == ARM_SMMU_DOMAIN_BYPASS)
		type = S2CR_TYPE_BYPASS;
	else
		type = S2CR_TYPE_TRANS;

	for_each_cfg_sme(fwspec, i, idx) {
		if (type == s2cr[idx].type &amp;&amp; cbndx == s2cr[idx].cbndx)
			continue;

		s2cr[idx].type = type;
		s2cr[idx].privcfg = S2CR_PRIVCFG_DEFAULT;
		s2cr[idx].cbndx = cbndx;
		arm_smmu_write_s2cr(smmu, idx); //根据设备在全局的idx号，定位到s2cr寄存器地址。
	}
	return 0;
}</code></pre> 
<p>相关写寄存器的函数：通过idx关联。 </p> 
<pre><code>//写入streamID。可以推断idx值
static void arm_smmu_write_smr(struct arm_smmu_device *smmu, int idx)
{
	struct arm_smmu_smr *smr = smmu-&gt;smrs + idx;
	u32 reg = smr-&gt;id &lt;&lt; SMR_ID_SHIFT | smr-&gt;mask &lt;&lt; SMR_MASK_SHIFT;

	if (!(smmu-&gt;features &amp; ARM_SMMU_FEAT_EXIDS) &amp;&amp; smr-&gt;valid)
		reg |= SMR_VALID;
	writel_relaxed(reg, ARM_SMMU_GR0(smmu) + ARM_SMMU_GR0_SMR(idx));
}

//根据idx 找到s2cr寄存器，可以找到cbndx值，该值可以定位到io-pgtable页表的pgd地址。
static void arm_smmu_write_s2cr(struct arm_smmu_device *smmu, int idx)
{
	struct arm_smmu_s2cr *s2cr = smmu-&gt;s2crs + idx;
	u32 reg = (s2cr-&gt;type &amp; S2CR_TYPE_MASK) &lt;&lt; S2CR_TYPE_SHIFT |  //16-17bit为TYPE位
		  (s2cr-&gt;cbndx &amp; S2CR_CBNDX_MASK) &lt;&lt; S2CR_CBNDX_SHIFT |   //0-7bit为CBNDX位。
		  (s2cr-&gt;privcfg &amp; S2CR_PRIVCFG_MASK) &lt;&lt; S2CR_PRIVCFG_SHIFT;

	if (smmu-&gt;features &amp; ARM_SMMU_FEAT_EXIDS &amp;&amp; smmu-&gt;smrs &amp;&amp;
	    smmu-&gt;smrs[idx].valid)
		reg |= S2CR_EXIDVALID;
	writel_relaxed(reg, ARM_SMMU_GR0(smmu) + ARM_SMMU_GR0_S2CR(idx));
}

static void arm_smmu_write_sme(struct arm_smmu_device *smmu, int idx)
{
	arm_smmu_write_s2cr(smmu, idx);
	if (smmu-&gt;smrs)
		arm_smmu_write_smr(smmu, idx);
}</code></pre> 
<h4>arm_smmu_device_group：</h4> 
<pre><code>static struct iommu_group *arm_smmu_device_group(struct device *dev)
{
        struct iommu_fwspec *fwspec = dev-&gt;iommu_fwspec;
        struct arm_smmu_device *smmu = fwspec_smmu(fwspec);
        struct iommu_group *group = NULL;
        int i, idx;

        for_each_cfg_sme(fwspec, i, idx) {
                if (group &amp;&amp; smmu-&gt;s2crs[idx].group &amp;&amp;
                    group != smmu-&gt;s2crs[idx].group)
                        return ERR_PTR(-EINVAL);
                printk("===arm_smmu_deivce_group for %s idx %d group %llx \n",dev_name(dev),idx,group);
                group = smmu-&gt;s2crs[idx].group; //对于ft2000+，由于idx存在一致，因此会分在一个组。
        }
        printk("==arm_smmu_device_group=== is_pci %d group = %llx name %s \n",dev_is_pci(dev),group,dev_name(dev));
        if (group)
                return iommu_group_ref_get(group);
        printk("group is empty \n");
        if (dev_is_pci(dev))
                group = pci_device_group(dev);
        else
                group = generic_device_group(dev);

        return group;
}
</code></pre> 
<p></p> 
<pre><code>arm_smmu_attach_dev-&gt;
arm_smmu_domain_add_master
{
....
    struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
    struct arm_smmu_master_cfg *cfg = dev_iommu_priv_get(dev);
    arm_smmu_domain_add_master(smmu_domain, cfg, fwspec);
.....
}

/*
配置设备下不同idx组寄存器，其中cbndx使用的是domain唯一的值。
不同设备如果使用同一个domain。则根据唯一的cbndx值(arm_smmu_init_domain_context中分配)
因此设备的dma发送sid找到smr的idx组。对应s2cr中查找cbndx。进而找到ttbr ？
*/
static int arm_smmu_domain_add_master(struct arm_smmu_domain *smmu_domain, //设备归属的domain
                                      struct arm_smmu_master_cfg *cfg,   //dev下的
                                      struct iommu_fwspec *fwspec)   //dev下的
{
        struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;
        struct arm_smmu_s2cr *s2cr = smmu-&gt;s2crs;
        u8 cbndx = smmu_domain-&gt;cfg.cbndx; //一个domain唯一的cbndx。
        enum arm_smmu_s2cr_type type;
        int i, idx;

        if (smmu_domain-&gt;stage == ARM_SMMU_DOMAIN_BYPASS)
                type = S2CR_TYPE_BYPASS;
        else
                type = S2CR_TYPE_TRANS;
        for_each_cfg_sme(cfg, fwspec, i, idx) {
                if (type == s2cr[idx].type &amp;&amp; cbndx == s2cr[idx].cbndx)
                        continue;

                s2cr[idx].type = type;
                s2cr[idx].privcfg = S2CR_PRIVCFG_DEFAULT;
                s2cr[idx].cbndx = cbndx;
                arm_smmu_write_s2cr(smmu, idx); //写入第idx组s2cr寄存器
        }
        return 0;
}
</code></pre> 
<p></p> 
<p><img alt="" height="830" src="https://images2.imgbox.com/52/8c/Wn7VWCIo_o.png" width="946"></p> 
<p></p> 
<p><img alt="" height="707" src="https://images2.imgbox.com/50/1c/yP0ezpmZ_o.png" width="1200"></p> 
<p></p> 
<p>StreamID写入smmu寄存器：</p> 
<blockquote> 
 <p> arm_smmu_attach_dev(struct iommu_domain *domain, struct device *dev)<br>     arm_smmu_init_domain_context(domain, smmu);<br>         arm_smmu_init_context_bank(smmu_domain, &amp;pgtbl_cfg);<br>         arm_smmu_write_context_bank(smmu, cfg-&gt;cbndx);</p> 
</blockquote> 
<p></p> 
<p><strong>地址映射使用io_pgtable_ops</strong></p> 
<pre><code>//drivers/iommu/io-pgtable.h
struct io_pgtable_ops {
	int (*map)(struct io_pgtable_ops *ops, unsigned long iova,
		   phys_addr_t paddr, size_t size, int prot);
	size_t (*unmap)(struct io_pgtable_ops *ops, unsigned long iova,
			size_t size);
	phys_addr_t (*iova_to_phys)(struct io_pgtable_ops *ops,
				    unsigned long iova);
};


</code></pre> 
<p> iommu_ops的map函数arm_smmu_map</p> 
<pre><code>static int arm_smmu_map(struct iommu_domain *domain, unsigned long iova,
                        phys_addr_t paddr, size_t size, int prot)
{
        struct io_pgtable_ops *ops = to_smmu_domain(domain)-&gt;pgtbl_ops;

        if (!ops)
                return -ENODEV;

        return ops-&gt;map(ops, iova, paddr, size, prot);
}

</code></pre> 
<p>arm_smmu_init_domain_context中对domain进行初始化的时候分配io_pgtable_ops:<br>  </p> 
<pre><code>static int arm_smmu_init_domain_context(struct iommu_domain *domain,
                                        struct arm_smmu_device *smmu)
{
    ................
    pgtbl_ops = alloc_io_pgtable_ops(fmt, &amp;pgtbl_cfg, smmu_domain);
    ................

}


//drivers/iommu/io-pgtable.c

static const struct io_pgtable_init_fns *
io_pgtable_init_table[IO_PGTABLE_NUM_FMTS] = {
#ifdef CONFIG_IOMMU_IO_PGTABLE_LPAE
        [ARM_32_LPAE_S1] = &amp;io_pgtable_arm_32_lpae_s1_init_fns,
        [ARM_32_LPAE_S2] = &amp;io_pgtable_arm_32_lpae_s2_init_fns,
        [ARM_64_LPAE_S1] = &amp;io_pgtable_arm_64_lpae_s1_init_fns,
        [ARM_64_LPAE_S2] = &amp;io_pgtable_arm_64_lpae_s2_init_fns,
#endif
#ifdef CONFIG_IOMMU_IO_PGTABLE_ARMV7S
        [ARM_V7S] = &amp;io_pgtable_arm_v7s_init_fns,
#endif
};

struct io_pgtable_ops *alloc_io_pgtable_ops(enum io_pgtable_fmt fmt,
                                            struct io_pgtable_cfg *cfg,
                                            void *cookie)
{
        struct io_pgtable *iop;
        const struct io_pgtable_init_fns *fns;

        if (fmt &gt;= IO_PGTABLE_NUM_FMTS)
                return NULL;

        fns = io_pgtable_init_table[fmt];
        if (!fns)
                return NULL;

        iop = fns-&gt;alloc(cfg, cookie);
        if (!iop)
                return NULL;

        iop-&gt;fmt        = fmt;
        iop-&gt;cookie     = cookie;
        iop-&gt;cfg        = *cfg;

        return &amp;iop-&gt;ops;
}
</code></pre> 
<p>io_pgtable_arm_64_lpae_s1_init_fns: driver/iommu/io-pgtable-arm.c</p> 
<pre><code>struct io_pgtable_init_fns io_pgtable_arm_64_lpae_s1_init_fns = {
        .alloc  = arm_64_lpae_alloc_pgtable_s1,
        .free   = arm_lpae_free_pgtable,
};




static struct io_pgtable *
arm_64_lpae_alloc_pgtable_s1(struct io_pgtable_cfg *cfg, void *cookie)
{
..................

    struct arm_lpae_io_pgtable *data;
    data = arm_lpae_alloc_pgtable(cfg); //分配
    data-&gt;pgd = __arm_lpae_alloc_pages(data-&gt;pgd_size, GFP_KERNEL, cfg);
...................
}



static struct arm_lpae_io_pgtable *
arm_lpae_alloc_pgtable(struct io_pgtable_cfg *cfg)
{
        unsigned long va_bits, pgd_bits;
        struct arm_lpae_io_pgtable *data;
。。。。。。。。。。。

        data = kmalloc(sizeof(*data), GFP_KERNEL);
        if (!data)
                return NULL;

        data-&gt;pg_shift = __ffs(cfg-&gt;pgsize_bitmap);
        data-&gt;bits_per_level = data-&gt;pg_shift - ilog2(sizeof(arm_lpae_iopte));

        va_bits = cfg-&gt;ias - data-&gt;pg_shift;
        data-&gt;levels = DIV_ROUND_UP(va_bits, data-&gt;bits_per_level);

        /* Calculate the actual size of our pgd (without concatenation) */
        pgd_bits = va_bits - (data-&gt;bits_per_level * (data-&gt;levels - 1));
        data-&gt;pgd_size = 1UL &lt;&lt; (pgd_bits + ilog2(sizeof(arm_lpae_iopte)));

        data-&gt;iop.ops = (struct io_pgtable_ops) {
                .map            = arm_lpae_map, //map函数
                .unmap          = arm_lpae_unmap,

                .iova_to_phys   = arm_lpae_iova_to_phys,
        };

        return data;
}
</code></pre> 
<h4>案例：</h4> 
<p>ft2000+/5.10内核 </p> 
<p>分组树：</p> 
<pre><code>[root@localhost ~]# tree /sys/kernel/iommu_groups/
/sys/kernel/iommu_groups/
├── 0
│   ├── devices
│   │   └── 0000:41:00.0 -&gt; ../../../../devices/pci0000:40/0000:40:00.0/0000:41:00.0
│   ├── reserved_regions
│   └── type
├── 1
│   ├── devices
│   │   └── 0000:03:00.0 -&gt; ../../../../devices/pci0000:00/0000:00:00.0/0000:01:00.0/0000:02:01.0/0000:03:00.0
│   ├── reserved_regions
│   └── type
├── 10
│   ├── devices
│   │   └── 0000:40:00.0 -&gt; ../../../../devices/pci0000:40/0000:40:00.0
│   ├── reserved_regions
│   └── type
├── 11
│   ├── devices
│   │   └── 0000:50:00.0 -&gt; ../../../../devices/pci0000:50/0000:50:00.0
│   ├── reserved_regions
│   └── type
├── 12
│   ├── devices
│   │   └── 0000:70:00.0 -&gt; ../../../../devices/pci0000:70/0000:70:00.0
│   ├── reserved_regions
│   └── type
├── 13
│   ├── devices
│   │   ├── 0000:04:00.1 -&gt; ../../../../devices/pci0000:00/0000:00:00.0/0000:01:00.0/0000:02:02.0/0000:04:00.1
│   │   ├── 0000:04:00.2 -&gt; ../../../../devices/pci0000:00/0000:00:00.0/0000:01:00.0/0000:02:02.0/0000:04:00.2
│   │   └── 0000:04:00.3 -&gt; ../../../../devices/pci0000:00/0000:00:00.0/0000:01:00.0/0000:02:02.0/0000:04:00.3
│   ├── reserved_regions
│   └── type
├── 14
│   ├── devices
│   │   └── 0000:21:00.0 -&gt; ../../../../devices/pci0000:20/0000:20:00.0/0000:21:00.0
│   ├── reserved_regions
│   └── type
├── 2
│   ├── devices
│   │   └── 0000:00:00.0 -&gt; ../../../../devices/pci0000:00/0000:00:00.0
│   ├── reserved_regions
│   └── type
├── 3
│   ├── devices
│   │   └── 0000:01:00.0 -&gt; ../../../../devices/pci0000:00/0000:00:00.0/0000:01:00.0
│   ├── reserved_regions
│   └── type
├── 4
│   ├── devices
│   │   └── 0000:02:01.0 -&gt; ../../../../devices/pci0000:00/0000:00:00.0/0000:01:00.0/0000:02:01.0
│   ├── reserved_regions
│   └── type
├── 5
│   ├── devices
│   │   └── 0000:02:02.0 -&gt; ../../../../devices/pci0000:00/0000:00:00.0/0000:01:00.0/0000:02:02.0
│   ├── reserved_regions
│   └── type
├── 6
│   ├── devices
│   │   └── 0000:02:04.0 -&gt; ../../../../devices/pci0000:00/0000:00:00.0/0000:01:00.0/0000:02:04.0
│   ├── reserved_regions
│   └── type
├── 7
│   ├── devices
│   │   └── 0000:02:05.0 -&gt; ../../../../devices/pci0000:00/0000:00:00.0/0000:01:00.0/0000:02:05.0
│   ├── reserved_regions
│   └── type
├── 8
│   ├── devices
│   │   └── 0000:02:06.0 -&gt; ../../../../devices/pci0000:00/0000:00:00.0/0000:01:00.0/0000:02:06.0
│   ├── reserved_regions
│   └── type
└── 9
    ├── devices
    │   ├── 0000:04:00.0 -&gt; ../../../../devices/pci0000:00/0000:00:00.0/0000:01:00.0/0000:02:02.0/0000:04:00.0
    │   └── 0000:20:00.0 -&gt; ../../../../devices/pci0000:20/0000:20:00.0
    ├── reserved_regions
    └── type

48 directories, 30 files
</code></pre> 
<p> 设备下最终sid：看下上述9组。包含04:00.0和20：00.0。 看下面的日志：恰好这两个共同的0x400的sid；</p> 
<pre><code>[   10.503563] ===arm_smmu_add_device dev 0000:41:00.0 num_ids 4 of 0 sid 4100 
[   10.510581] ===arm_smmu_add_device dev 0000:41:00.0 num_ids 4 of 1 sid 4101 
[   10.517598] ===arm_smmu_add_device dev 0000:41:00.0 num_ids 4 of 2 sid 820 
[   10.524522] ===arm_smmu_add_device dev 0000:41:00.0 num_ids 4 of 3 sid 820 
[   10.677266] ===arm_smmu_add_device dev 0000:03:00.0 num_ids 2 of 0 sid 300 
[   10.684191] ===arm_smmu_add_device dev 0000:03:00.0 num_ids 2 of 1 sid 60 
[   11.108133] ===arm_smmu_add_device dev 0000:00:00.0 num_ids 2 of 0 sid 0 
[   11.121369] ===arm_smmu_add_device dev 0000:00:00.0 num_ids 2 of 1 sid 0 
[   11.155433] ===arm_smmu_add_device dev 0000:01:00.0 num_ids 2 of 0 sid 100 
[   11.162367] ===arm_smmu_add_device dev 0000:01:00.0 num_ids 2 of 1 sid 20 
[   11.215796] ===arm_smmu_add_device dev 0000:02:01.0 num_ids 2 of 0 sid 208 
[   11.215799] ===arm_smmu_add_device dev 0000:02:01.0 num_ids 2 of 1 sid 41 
[   11.268019] ===arm_smmu_add_device dev 0000:02:02.0 num_ids 2 of 0 sid 210 
[   11.283765] ===arm_smmu_add_device dev 0000:02:02.0 num_ids 2 of 1 sid 42 
[   11.387949] ===arm_smmu_add_device dev 0000:02:04.0 num_ids 2 of 0 sid 220 
[   11.387950] ===arm_smmu_add_device dev 0000:02:04.0 num_ids 2 of 1 sid 44 
[   11.442892] ===arm_smmu_add_device dev 0000:02:05.0 num_ids 2 of 0 sid 228 
[   11.449820] ===arm_smmu_add_device dev 0000:02:05.0 num_ids 2 of 1 sid 45 
[   11.484502] ===arm_smmu_add_device dev 0000:02:06.0 num_ids 2 of 0 sid 230 
[   11.491435] ===arm_smmu_add_device dev 0000:02:06.0 num_ids 2 of 1 sid 46 
[   11.526207] ===arm_smmu_add_device dev 0000:20:00.0 num_ids 2 of 0 sid 2000 
[   11.533218] ===arm_smmu_add_device dev 0000:20:00.0 num_ids 2 of 1 sid 400   //0x400 
[   11.568096] ===arm_smmu_add_device dev 0000:40:00.0 num_ids 2 of 0 sid 4000 
[   11.575107] ===arm_smmu_add_device dev 0000:40:00.0 num_ids 2 of 1 sid 800 
[   11.610065] ===arm_smmu_add_device dev 0000:50:00.0 num_ids 2 of 0 sid 5000 
[   11.617080] ===arm_smmu_add_device dev 0000:50:00.0 num_ids 2 of 1 sid a00 
[   11.652088] ===arm_smmu_add_device dev 0000:70:00.0 num_ids 2 of 0 sid 7000 
[   11.665674] ===arm_smmu_add_device dev 0000:70:00.0 num_ids 2 of 1 sid e00 
[   13.530809] ===arm_smmu_add_device dev 0000:04:00.0 num_ids 2 of 0 sid 400  //x0400
[   13.537743] ===arm_smmu_add_device dev 0000:04:00.0 num_ids 2 of 1 sid 80 
[   13.848325] ===arm_smmu_add_device dev 0000:04:00.1 num_ids 2 of 0 sid 401 
[   13.855250] ===arm_smmu_add_device dev 0000:04:00.1 num_ids 2 of 1 sid 80 
[   14.171899] ===arm_smmu_add_device dev 0000:04:00.2 num_ids 2 of 0 sid 402 
[   14.178831] ===arm_smmu_add_device dev 0000:04:00.2 num_ids 2 of 1 sid 80 
[   14.489847] ===arm_smmu_add_device dev 0000:04:00.3 num_ids 2 of 0 sid 403 
[   14.496779] ===arm_smmu_add_device dev 0000:04:00.3 num_ids 2 of 1 sid 80 
[   21.292421] ===arm_smmu_add_device dev 0000:21:00.0 num_ids 2 of 0 sid 2100 
[   21.299443] ===arm_smmu_add_device dev 0000:21:00.0 num_ids 2 of 1 sid 420 
</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df8eda30a75b38a719d44ca86c69f9df/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Docker部署ActiveMQ,并且挂载存储和日志</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0da2511d8cb811d48aef0cc22295e09b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[cmake]使用依赖项指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>