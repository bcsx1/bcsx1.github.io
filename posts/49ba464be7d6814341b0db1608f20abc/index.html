<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2021超全大数据面试宝典，吐血总结十万字，大数据面试收藏这一篇就够了 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2021超全大数据面试宝典，吐血总结十万字，大数据面试收藏这一篇就够了" />
<meta property="og:description" content="本文最新版已发布至公众号【五分钟学大数据】
获取此套面试题最新pdf版，请搜索公众号【五分钟学大数据】，对话框发送 面试宝典
扫码获取最新PDF版：
版本
时间
描述
V1.0
2020-02-18
创建
V1.2
2020-06-17
新增 spark 、flink相关面试题
V1.3
2021-03-18
新增 java、JVM、mysql、JUC等
持续更新中… 本文档更新只发于公众号：五分钟学大数据
本套面试题堪称史上最全，既有面试技巧，面试流程，还有技术总结，面试真题，包含算法，Java，Mysql，大数据框架，大数据项目等（持续更新中… 最新版请扫描下方二维码关注公众号：五分钟学大数据，回复【面试宝典】获取）。
第一版是按照大数据技术进行划分(另一版，可在公众号【五分钟学大数据】后台发送 面试 获取)，第二版是综合版 (此版)。
扫码关注公众号，获取最新PDF版：（对话框发送 面试宝典）
目 录
第1章 找工作流程. 1
1.1 学习技能. 1
1.2 编写简历. 1
1.3 投简历. 1
1.4 约面试时间. 1
1.5 面试. 1
1.6 等回复. 1
1.7 拿offer 2
1.8 入职. 2
1.9 准备必备资料，签合同. 2
第2章 面试说明. 2
2.1 笔试. 2
2.2 面试. 3" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/49ba464be7d6814341b0db1608f20abc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-09T17:30:30+08:00" />
<meta property="article:modified_time" content="2021-07-09T17:30:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2021超全大数据面试宝典，吐血总结十万字，大数据面试收藏这一篇就够了</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p style="margin-left:0;"><strong><span style="color:#fe2c24;">本文最新版已发布至公众号【五分钟学大数据】</span></strong></p> 
 <p><strong>获取此套面试题最新pdf版</strong>，请搜索公众号【五分钟学大数据】，对话框发送 <strong>面试宝典</strong></p> 
 <p><strong>扫码获取<span style="color:#fe2c24;">最新PDF版</span>：</strong></p> 
 <p><img alt="" height="301" src="https://images2.imgbox.com/b2/de/SUbvKPWO_o.png" width="301"></p> 
</div> 
<div> 
 <table align="left" border="1" style="margin-left:6.75pt;"><thead><tr><td style="background-color:#f0f0f0;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><strong>版本</strong></p> </td><td style="background-color:#f0f0f0;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><strong><span style="color:#000000;">时间</span></strong></p> </td><td style="background-color:#f0f0f0;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><strong><span style="color:#000000;">描述</span></strong></p> </td></tr></thead><tbody><tr><td style="background-color:#ffffff;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">V1.0</span></p> </td><td style="background-color:#ffffff;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">2020-02-18</span></p> </td><td style="background-color:#ffffff;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">创建</span></p> </td></tr><tr><td style="background-color:#f8f8f8;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">V1.2</span></p> </td><td style="background-color:#f8f8f8;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">2020-06-17</span></p> </td><td style="background-color:#f8f8f8;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">新增 spark 、flink相关面试题</span></p> </td></tr><tr><td style="background-color:#ffffff;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">V1.3</span></p> </td><td style="background-color:#ffffff;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">2021-03-18</span></p> </td><td style="background-color:#ffffff;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">新增 java、JVM、mysql、JUC等</span></p> </td></tr></tbody></table> 
 <div> 
  <h4 style="margin-left:21.55pt;text-align:justify;"></h4> 
  <h4 style="margin-left:21.55pt;text-align:justify;"></h4> 
  <h4 style="margin-left:21.55pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#000000;"><strong><span style="background-color:#ef7060;"><span style="color:#ffffff;">持续更新中…</span></span></strong><strong> </strong></span></span></span></h4> 
 </div> 
 <p style="margin-left:96pt;"><strong><span style="color:#e96900;">本文档更新只发于公众号：</span></strong><em><strong><span style="color:#c51162;">五分钟学大数据</span></strong></em></p> 
 <div> 
  <div style="margin-left:0;text-align:center;"> 
   <hr> 
  </div> 
 </div> 
 <p style="margin-left:0cm;"><strong><span style="color:#e96900;">本套面试题堪称史上最全</span></strong>，既有面试技巧，面试流程，还有技术总结，面试真题，包含算法，Java，Mysql，大数据框架，大数据项目等（<strong>持续更新中</strong><strong>… </strong><strong>最新版请扫描下方二维码关注公众号：<span style="color:#ff0000;">五分钟学大数据</span>，回复【<span style="color:#00b050;">面试宝典</span>】获取</strong>）。</p> 
 <p style="margin-left:0cm;"><strong><span style="color:#e96900;">第一版是按照大数据技术进行划分</span></strong>(另一版，可在公众号【五分钟学大数据】后台发送 <strong><span style="color:#e96900;">面试</span></strong> 获取)，<strong><span style="color:#e96900;">第二版是综合版</span></strong> (此版)。</p> 
 <table><tbody><tr><td> 
     <div> 
      <p style="margin-left:0;text-align:center;"><span style="color:#fe2c24;"><strong>扫码关注公众号，获取最新PDF版：（对话框发送 面试宝典）</strong></span></p> 
     </div> </td></tr></tbody></table> 
 <p style="text-align:center;"><img alt="" height="154" src="https://images2.imgbox.com/ac/40/A7xlIKjt_o.png" width="157"></p> 
</div> 
<p></p> 
<div> 
 <p style="margin-left:0;text-align:center;"><strong>目   录</strong></p> 
 <p style="margin-left:0;text-align:justify;"><strong><a href="#_Toc66809561" rel="nofollow">第1章        找工作流程. 1</a></strong></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809562" rel="nofollow">1.1         学习技能. 1</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809563" rel="nofollow">1.2         编写简历. 1</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809564" rel="nofollow">1.3         投简历. 1</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809565" rel="nofollow">1.4         约面试时间. 1</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809566" rel="nofollow">1.5         面试. 1</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809567" rel="nofollow">1.6         等回复. 1</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809568" rel="nofollow">1.7         拿offer 2</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809569" rel="nofollow">1.8         入职. 2</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809570" rel="nofollow">1.9         准备必备资料，签合同. 2</a></p> 
 <p style="margin-left:0;text-align:justify;"><strong><a href="#_Toc66809571" rel="nofollow">第2章        面试说明. 2</a></strong></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809572" rel="nofollow">2.1         笔试. 2</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809573" rel="nofollow">2.2         面试. 3</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809574" rel="nofollow"><strong>2.2.1</strong><strong> </strong><strong>人事面试</strong>. 3</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809575" rel="nofollow"><strong>2.2.2</strong><strong> ·</strong><strong>手写代码</strong>. 3</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809576" rel="nofollow"><strong>2.2.3</strong><strong> </strong><strong>技术经理面试</strong>. 3</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809577" rel="nofollow"><strong>2.2.4</strong><strong> CTO/</strong><strong>技术架构师等面试</strong>（如果过了技术经理面试）. 4</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809578" rel="nofollow">2.3         机试. 4</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809579" rel="nofollow">2.4         面试考察方式. 4</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809580" rel="nofollow"><strong>2.4.1</strong><strong> </strong><strong>知识广度</strong>. 4</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809581" rel="nofollow"><strong>2.4.2</strong><strong> </strong><strong>知识深度</strong>. 6</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809582" rel="nofollow">2.5         面试过程最关键的是什么？. 7</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809583" rel="nofollow">2.6         面试要点. 7</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809584" rel="nofollow">2.7         面试技巧. 7</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809585" rel="nofollow"><strong>2.7.1</strong><strong> </strong><strong>六个常见问题</strong>. 7</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809586" rel="nofollow"><strong>2.7.2</strong><strong> </strong><strong>两个注意事项</strong>. 8</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809587" rel="nofollow"><strong>2.7.3</strong> 自我介绍（控制在4分半以内，不超过5分钟）. 8</a></p> 
 <p style="margin-left:0;text-align:justify;"><strong><a href="#_Toc66809588" rel="nofollow">第3章        手写代码. 9</a></strong></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809589" rel="nofollow">3.1         冒泡排序. 9</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809590" rel="nofollow">3.2         二分查找. 10</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809591" rel="nofollow">3.3         快排. 12</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809592" rel="nofollow">3.4         归并. 13</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809593" rel="nofollow">3.5         二叉树之Scala实现. 15</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809594" rel="nofollow"><strong>3.5.1</strong><strong> </strong><strong>二叉树概念</strong>. 15</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809595" rel="nofollow"><strong>3.5.2</strong><strong> </strong><strong>二叉树的特点</strong>. 15</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809596" rel="nofollow"><strong>3.5.3</strong><strong> </strong><strong>二叉树的Scala</strong><strong>代码实现</strong>. 15</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809597" rel="nofollow">3.6         手写Spark-WordCount 21</a></p> 
 <p style="margin-left:0;text-align:justify;"><strong><a href="#_Toc66809598" rel="nofollow">第4章        项目架构. 21</a></strong></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809599" rel="nofollow">4.1         数仓概念. 21</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809600" rel="nofollow">4.2         系统数据流程设计. 22</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809601" rel="nofollow">4.3         框架版本选型. 22</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809602" rel="nofollow">4.4         服务器选型. 22</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809603" rel="nofollow">4.5         集群规模. 23</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809604" rel="nofollow">4.6         人员配置参考. 23</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809605" rel="nofollow"><strong>4.6.1</strong><strong> </strong><strong>整体架构</strong>. 23</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809606" rel="nofollow"><strong>4.6.2</strong><strong> </strong><strong>你们部门的职级等级，晋升规则</strong>. 23</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809607" rel="nofollow"><strong>4.6.3</strong><strong> </strong><strong>人员配置参考</strong>. 23</a></p> 
 <p style="margin-left:0;text-align:justify;"><strong><a href="#_Toc66809608" rel="nofollow">第5章        项目涉及技术. 24</a></strong></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809609" rel="nofollow">5.1         Linux&amp;Shell相关总结. 24</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809610" rel="nofollow"><strong>5.1.1</strong><strong> Linux</strong><strong>常用命令</strong>. 24</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809611" rel="nofollow"><strong>5.1.2</strong><strong> Shell</strong><strong>常用工具</strong>. 24</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809612" rel="nofollow">5.2         Hadoop相关总结. 24</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809613" rel="nofollow"><strong>5.2.1</strong><strong> Hadoop</strong><strong>常用端口号</strong>. 24</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809614" rel="nofollow"><strong>5.2.2</strong><strong> Hadoop</strong><strong>配置文件以及简单的Hadoop</strong><strong>集群搭建</strong>. 25</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809615" rel="nofollow"><strong>5.2.3</strong><strong> HDFS</strong><strong>读流程和写流程</strong>. 25</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809616" rel="nofollow"><strong>5.2.4</strong><strong> MapReduce</strong><strong>的Shuffle</strong><strong>过程及Hadoop</strong><strong>优化（包括：压缩、小文件、集群优化）</strong>. 26</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809617" rel="nofollow"><strong>5.2.5</strong><strong> Yarn</strong><strong>的Job</strong><strong>提交流程</strong>. 28</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809618" rel="nofollow"><strong>5.2.6</strong><strong> Yarn</strong><strong>的默认调度器、调度器分类、以及他们之间的区别</strong>. 29</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809619" rel="nofollow"><strong>5.2.7</strong><strong> </strong><strong>项目经验之LZO</strong><strong>压缩</strong>. 30</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809620" rel="nofollow"><strong>5.2.8</strong><strong> Hadoop</strong><strong>参数调优</strong>. 31</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809621" rel="nofollow"><strong>5.2.9</strong><strong> </strong><strong>项目经验之基准测试</strong>. 32</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809622" rel="nofollow"><strong>5.2.10</strong><strong> Hadoop</strong><strong>宕机</strong>. 33</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809623" rel="nofollow">5.3         Zookeeper相关总结. 33</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809624" rel="nofollow"><strong>5.3.1</strong><strong> </strong><strong>选举机制</strong>. 33</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809625" rel="nofollow"><strong>5.3.2</strong><strong> </strong><strong>常用命令</strong>. 34</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809626" rel="nofollow">5.4         Flume相关总结. 34</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809627" rel="nofollow"><strong>5.4.1</strong><strong> Flume</strong><strong>组成，Put</strong><strong>事务，Take</strong><strong>事务</strong>. 34</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809628" rel="nofollow"><strong>5.4.2</strong><strong> Flume</strong><strong>拦截器</strong>. 34</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809629" rel="nofollow"><strong>5.4.3</strong><strong> Flume Channel</strong><strong>选择器</strong>. 35</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809630" rel="nofollow"><strong>5.4.4</strong><strong> Flume</strong><strong>监控器</strong>. 35</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809631" rel="nofollow"><strong>5.4.5</strong><strong> Flume</strong><strong>采集数据会丢失吗?</strong><strong>（防止数据丢失的机制）</strong>. 36</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809632" rel="nofollow"><strong>5.4.6</strong><strong> Flume</strong><strong>内存</strong>. 36</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809633" rel="nofollow"><strong>5.4.7</strong><strong> FileChannel</strong><strong>优化</strong>. 36</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809634" rel="nofollow"><strong>5.4.8</strong><strong> HDFS Sink</strong><strong>小文件处理</strong>. 37</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809635" rel="nofollow">5.5         Kafka相关总结. 38</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809636" rel="nofollow"><strong>5.5.1</strong><strong> Kafka</strong><strong>架构</strong>. 38</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809637" rel="nofollow"><strong>5.5.2</strong><strong> Kafka</strong><strong>压测</strong>. 38</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809638" rel="nofollow"><strong>5.5.3</strong><strong> Kafka</strong><strong>的机器数量</strong>. 38</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809639" rel="nofollow"><strong>5.5.4</strong><strong> Kafka</strong><strong>的日志保存时间</strong>. 38</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809640" rel="nofollow"><strong>5.5.5</strong><strong> Kafka</strong><strong>的硬盘大小</strong>. 38</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809641" rel="nofollow"><strong>5.5.6</strong><strong> Kafka</strong><strong>监控</strong>. 38</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809642" rel="nofollow"><strong>5.5.7</strong><strong> Kakfa</strong><strong>分区数</strong>. 39</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809643" rel="nofollow"><strong>5.5.8</strong><strong> </strong><strong>副本数设定</strong>. 39</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809644" rel="nofollow"><strong>5.5.9</strong><strong> </strong><strong>多少个Topic</strong> 39</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809645" rel="nofollow"><strong>5.5.10</strong><strong> Kafka</strong><strong>丢不丢数据</strong>. 39</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809646" rel="nofollow"><strong>5.5.11</strong><strong> Kafka</strong><strong>的ISR</strong><strong>副本同步队列</strong>. 39</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809647" rel="nofollow"><strong>5.5.12</strong><strong> Kafka</strong><strong>中数据量计算</strong>. 39</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809648" rel="nofollow"><strong>5.5.13</strong><strong> Kafka</strong><strong>挂掉</strong>. 40</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809649" rel="nofollow"><strong>5.5.14</strong><strong> Kafka</strong><strong>消息数据积压，Kafka</strong><strong>消费能力不足怎么处理？</strong>. 40</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809650" rel="nofollow"><strong>5.5.15</strong><strong> Kafka</strong><strong>的再平衡机制</strong>. 40</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809651" rel="nofollow">5.6         Hive相关总结. 47</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809652" rel="nofollow"><strong>5.6.1</strong><strong> Hive</strong><strong>的架构</strong>. 47</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809653" rel="nofollow"><strong>5.6.2</strong><strong> Hive</strong><strong>和数据库比较</strong>. 48</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809654" rel="nofollow"><strong>5.6.3</strong><strong> </strong><strong>内部表和外部表</strong>. 48</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809655" rel="nofollow"><strong>5.6.4</strong><strong> 4</strong><strong>个By</strong><strong>区别</strong>. 48</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809656" rel="nofollow"><strong>5.6.5</strong><strong> </strong><strong>窗口函数</strong>. 48</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809657" rel="nofollow"><strong>5.6.6</strong> 自定义UDF、UDTF 49</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809658" rel="nofollow"><strong>5.6.7</strong> Hive优化. 49</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809659" rel="nofollow">5.7         HBase相关总结. 51</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809660" rel="nofollow"><strong>5.7.1</strong><strong> HBase</strong><strong>存储结构</strong>. 51</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809661" rel="nofollow"><strong>5.7.2</strong><strong> </strong><strong>读流程</strong>. 51</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809662" rel="nofollow"><strong>5.7.3</strong><strong> </strong><strong>写流程</strong>. 52</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809663" rel="nofollow"><strong>5.7.4</strong><strong> </strong><strong>数据flush</strong><strong>过程</strong>. 52</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809664" rel="nofollow"><strong>5.7.5</strong><strong> </strong><strong>数据合并过程</strong>. 52</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809665" rel="nofollow"><strong>5.7.6</strong><strong> hbase-default.xml</strong><strong>中相关参数</strong>. 53</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809666" rel="nofollow"><strong>5.7.7</strong><strong> rowkey</strong><strong>设计原则</strong>. 54</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809667" rel="nofollow"><strong>5.7.8</strong><strong> RowKey</strong><strong>如何设计</strong>. 54</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809668" rel="nofollow">5.8         Sqoop参数. 54</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809669" rel="nofollow"><strong>5.8.1</strong><strong> Sqoop</strong><strong>导入导出Null</strong><strong>存储一致性问题</strong>. 54</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809670" rel="nofollow"><strong>5.8.2</strong><strong> Sqoop</strong><strong>数据导出一致性问题</strong>. 54</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809671" rel="nofollow"><strong>5.8.3</strong><strong> Sqoop</strong><strong>底层运行的任务是什么</strong>. 55</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809672" rel="nofollow"><strong>5.8.4</strong><strong> Sqoop</strong><strong>数据导出的时候一次执行多长时间</strong>. 55</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809673" rel="nofollow">5.9         Scala相关总结. 55</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809674" rel="nofollow"><strong>5.9.1</strong><strong> </strong><strong>元组</strong>. 55</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809675" rel="nofollow"><strong>5.9.2</strong><strong> </strong><strong>隐式转换</strong>. 55</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809676" rel="nofollow"><strong>5.9.3</strong><strong> </strong><strong>函数式编程理解</strong>. 56</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809677" rel="nofollow"><strong>5.9.4</strong><strong> </strong><strong>样例类</strong>. 56</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809678" rel="nofollow"><strong>5.9.5</strong><strong> </strong><strong>柯里化</strong>. 56</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809679" rel="nofollow"><strong>5.9.6</strong><strong> </strong><strong>闭包</strong>. 57</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809680" rel="nofollow"><strong>5.9.7</strong><strong> Some</strong><strong>、None</strong><strong>、Option</strong><strong>的正确使用</strong>. 57</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809681" rel="nofollow">5.10       Spark相关总结. 57</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809682" rel="nofollow"><strong>5.10.1</strong><strong> Spark</strong><strong>有几种部署方式？请分别简要论述</strong>. 57</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809683" rel="nofollow"><strong>5.10.2</strong><strong> Spark</strong><strong>任务使用什么进行提交，javaEE</strong><strong>界面还是脚本</strong>. 58</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809684" rel="nofollow"><strong>5.10.3</strong><strong> Spark</strong><strong>提交作业参数（重点）</strong>. 58</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809685" rel="nofollow"><strong>5.10.4</strong><strong> </strong><strong>简述Spark</strong><strong>的架构与作业提交流程（画图讲解，注明各个部分的作用）（重点）</strong>. 59</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809686" rel="nofollow"><strong>5.10.5</strong><strong> </strong><strong>如何理解Spark</strong><strong>中的血统概念（RDD</strong><strong>）（笔试重点）</strong>. 59</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809687" rel="nofollow"><strong>5.10.6</strong><strong> </strong><strong>简述Spark</strong><strong>的宽窄依赖，以及Spark</strong><strong>如何划分stage</strong><strong>，每个stage</strong><strong>又根据什么决定task</strong><strong>个数? </strong><strong>（笔试重点）</strong>. 59</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809688" rel="nofollow"><strong>5.10.7</strong><strong> </strong><strong>请列举Spark</strong><strong>的transformation</strong><strong>算子（不少于8</strong><strong>个），并简述功能（重点）</strong>. 59</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809689" rel="nofollow"><strong>5.10.8</strong><strong> </strong><strong>请列举Spark</strong><strong>的action</strong><strong>算子（不少于6</strong><strong>个），并简述功能（重点）</strong>. 60</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809690" rel="nofollow"><strong>5.10.9</strong><strong> </strong><strong>请列举会引起Shuffle</strong><strong>过程的Spark</strong><strong>算子，并简述功能。</strong>. 61</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809691" rel="nofollow"><strong>5.10.10</strong><strong> </strong><strong>简述Spark</strong><strong>的两种核心Shuffle</strong><strong>（HashShuffle</strong><strong>与SortShuffle</strong><strong>）的工作流程（包括未优化的HashShuffle</strong><strong>、优化的HashShuffle</strong><strong>、普通的SortShuffle</strong><strong>与bypass</strong><strong>的SortShuffle</strong><strong>）（重点）</strong>. 61</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809692" rel="nofollow"><strong>5.10.11</strong><strong> Spark</strong><strong>常用算子reduceByKey</strong><strong>与groupByKey</strong><strong>的区别，哪一种更具优势？（重点）</strong>. 62</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809693" rel="nofollow"><strong>5.10.12</strong><strong> Repartition</strong><strong>和Coalesce</strong><strong>关系与区别</strong>. 63</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809694" rel="nofollow"><strong>5.10.13</strong><strong> </strong><strong>分别简述Spark</strong><strong>中的缓存机制（cache</strong><strong>和persist</strong><strong>）与checkpoint</strong><strong>机制，并指出两者的区别与联系</strong>. 63</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809695" rel="nofollow"><strong>5.10.14</strong><strong> </strong><strong>简述Spark</strong><strong>中共享变量（广播变量和累加器）的基本原理与用途。（重点）</strong>. 63</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809696" rel="nofollow"><strong>5.10.15</strong><strong> </strong><strong>当Spark</strong><strong>涉及到数据库的操作时，如何减少Spark</strong><strong>运行中的数据库连接数？</strong>. 64</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809697" rel="nofollow"><strong>5.10.16</strong><strong> </strong><strong>简述SparkSQL</strong><strong>中RDD</strong><strong>、DataFrame</strong><strong>、DataSet</strong><strong>三者的区别与联系? </strong><strong>（笔试重点）</strong>. 64</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809698" rel="nofollow"><strong>5.10.17</strong><strong> SparkSQL</strong><strong>中join</strong><strong>操作与left join</strong><strong>操作的区别？</strong>. 65</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809699" rel="nofollow"><strong>5.10.18</strong><strong> SparkStreaming</strong><strong>有哪几种方式消费Kafka</strong><strong>中的数据，它们之间的区别是什么？</strong><strong> </strong><strong>（重点）</strong>. 65</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809700" rel="nofollow"><strong>5.10.19</strong><strong> </strong><strong>简述SparkStreaming</strong><strong>窗口函数的原理（重点）</strong>. 66</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809701" rel="nofollow"><strong>5.10.20</strong><strong> </strong><strong>请手写出wordcount</strong><strong>的Spark</strong><strong>代码实现（Scala</strong><strong>）（手写代码重点）</strong>. 67</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809702" rel="nofollow"><strong>5.10.21</strong><strong> </strong><strong>如何使用Spark</strong><strong>实现topN</strong><strong>的获取（描述思路或使用伪代码）（重点）</strong>. 67</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809703" rel="nofollow"><strong>5.10.22</strong><strong> </strong><strong>京东：调优之前与调优之后性能的详细对比（例如调整map</strong><strong>个数，map</strong><strong>个数之前多少、之后多少，有什么提升）</strong>. 67</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809704" rel="nofollow">5.11       Flink相关总结. 68</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809705" rel="nofollow"><strong>5.11.1</strong><strong> </strong><strong>简单介绍一下Flink</strong> 68</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809706" rel="nofollow"><strong>5.11.2</strong><strong> Flink</strong><strong>相比Spark Streaming</strong><strong>有什么区别？</strong>. 68</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809707" rel="nofollow"><strong>5.11.3</strong><strong> Flink</strong><strong>中的分区策略有哪几种？</strong>. 70</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809708" rel="nofollow"><strong>5.11.4</strong><strong> Flink</strong><strong>的并行度有了解吗？Flink</strong><strong>中设置并行度需要注意什么？</strong>. 76</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809709" rel="nofollow"><strong>5.11.5</strong><strong> Flink</strong><strong>支持哪几种重启策略？分别如何配置？</strong>. 76</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809710" rel="nofollow"><strong>5.11.6</strong><strong> Flink</strong><strong>的分布式缓存有什么作用？如何使用？</strong>. 76</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809711" rel="nofollow"><strong>5.11.7</strong><strong> Flink</strong><strong>中的广播变量，使用广播变量需要注意什么事项？</strong>. 77</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809712" rel="nofollow"><strong>5.11.8</strong><strong> Flink</strong><strong>中对窗口的支持包括哪几种？说说他们的使用场景</strong>. 77</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809713" rel="nofollow"><strong>5.11.9</strong><strong> Flink </strong><strong>中的 State Backends</strong><strong>是什么？有什么作用？分成哪几类？说说他们各自的优缺点？</strong>. 78</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809714" rel="nofollow"><strong>5.11.10</strong> Flink中的时间种类有哪些？各自介绍一下？. 79</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809715" rel="nofollow"><strong>5.11.11</strong><strong> WaterMark</strong><strong>是什么？是用来解决什么问题？如何生成水印？水印的原理是什么？</strong>. 79</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809716" rel="nofollow"><strong>5.11.12</strong><strong> Flink</strong><strong>的table</strong><strong>和SQL</strong><strong>熟悉吗？Table API</strong><strong>和SQL</strong><strong>中TableEnvironment</strong><strong>这个类有什么作用</strong>. 79</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809717" rel="nofollow"><strong>5.11.13</strong><strong> Flink</strong><strong>如何实现SQL</strong><strong>解析的呢？</strong>. 80</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809718" rel="nofollow"><strong>5.11.14</strong><strong> Flink</strong><strong>是如何做到批处理与流处理统一的？</strong>. 80</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809719" rel="nofollow"><strong>5.11.15</strong><strong> Flink</strong><strong>中的数据传输模式是怎么样的？</strong>. 81</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809720" rel="nofollow"><strong>5.11.16</strong><strong> Flink</strong><strong>的容错机制</strong>. 82</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809721" rel="nofollow"><strong>5.11.17</strong><strong> Flink</strong><strong>在使用Window</strong><strong>时出现数据倾斜，你有什么解决办法？</strong>. 82</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809722" rel="nofollow"><strong>5.11.18</strong><strong> Flink</strong><strong>任务，delay</strong><strong>极高，请问你有什么调优策略？</strong>. 82</a></p> 
 <p style="margin-left:0;text-align:justify;"><strong><a href="#_Toc66809723" rel="nofollow">第6章        业务交互数据分析. 83</a></strong></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809724" rel="nofollow">6.1         电商常识. 83</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809725" rel="nofollow">6.2         电商业务流程. 83</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809726" rel="nofollow">6.3         业务表关键字段. 83</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809727" rel="nofollow"><strong>6.3.1</strong><strong> </strong><strong>订单表（order_info</strong><strong>）</strong>. 83</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809728" rel="nofollow"><strong>6.3.2</strong><strong> </strong><strong>订单详情表（order_detail</strong><strong>）</strong>. 84</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809729" rel="nofollow"><strong>6.3.3</strong><strong> </strong><strong>商品表</strong>. 84</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809730" rel="nofollow"><strong>6.3.4</strong><strong> </strong><strong>用户表</strong>. 84</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809731" rel="nofollow"><strong>6.3.5</strong><strong> </strong><strong>商品一级分类表</strong>. 84</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809732" rel="nofollow"><strong>6.3.6</strong><strong> </strong><strong>商品二级分类表</strong>. 85</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809733" rel="nofollow"><strong>6.3.7</strong><strong> </strong><strong>商品三级分类表</strong>. 85</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809734" rel="nofollow"><strong>6.3.8</strong><strong> </strong><strong>支付流水表</strong>. 85</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809735" rel="nofollow">6.4         MySql中表的分类. 85</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809736" rel="nofollow">6.5         同步策略. 86</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809737" rel="nofollow">6.6         关系型数据库范式理论. 86</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809738" rel="nofollow">6.7         数据模型. 87</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809739" rel="nofollow">6.8         业务数据数仓搭建. 87</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809740" rel="nofollow"><strong>6.8.1</strong><strong> ods</strong><strong>层</strong>. 88</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809741" rel="nofollow"><strong>6.8.2</strong><strong> dwd</strong><strong>层</strong>. 88</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809742" rel="nofollow"><strong>6.8.3</strong><strong> dws</strong><strong>层</strong>. 88</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809743" rel="nofollow">6.9         需求一：GMV成交总额. 89</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809744" rel="nofollow">6.10       需求二：转化率. 89</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809745" rel="nofollow"><strong>6.10.1</strong><strong> </strong><strong>新增用户占日活跃用户比率表</strong>. 89</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809746" rel="nofollow"><strong>6.10.2</strong><strong> </strong><strong>用户行为转化率表</strong>. 89</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809747" rel="nofollow">6.11       需求三：品牌复购率. 89</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809748" rel="nofollow"><strong>6.11.1</strong><strong> </strong><strong>用户购买商品明细表（宽表）</strong>. 89</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809749" rel="nofollow"><strong>6.11.2</strong><strong> </strong><strong>品牌复购率表</strong>. 89</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809750" rel="nofollow">6.12       项目中有多少张宽表. 90</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809751" rel="nofollow">6.13       拉链表. 90</a></p> 
 <p style="margin-left:0;text-align:justify;"><strong><a href="#_Toc66809752" rel="nofollow">第7章        项目中遇到过哪些问题. 91</a></strong></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809753" rel="nofollow">7.1         Hadoop宕机. 91</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809754" rel="nofollow">7.2         Ganglia监控. 92</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809755" rel="nofollow">7.3         Flume小文件. 92</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809756" rel="nofollow">7.4         Kafka挂掉. 92</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809757" rel="nofollow">7.5         Kafka消息数据积压，Kafka消费能力不足怎么处理？. 92</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809758" rel="nofollow">7.6         Kafka数据重复. 92</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809759" rel="nofollow">7.7         Mysql高可用. 92</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809760" rel="nofollow">7.8         自定义UDF和UDTF解析和调试复杂字段. 93</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809761" rel="nofollow">7.9         Sqoop数据导出Parquet 93</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809762" rel="nofollow">7.10       Sqoop数据导出控制. 93</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809763" rel="nofollow">7.11       Sqoop数据导出一致性问题. 93</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809764" rel="nofollow">7.12       SparkStreaming优雅关闭. 94</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809765" rel="nofollow">7.13       Spark OOM、数据倾斜解决. 94</a></p> 
 <p style="margin-left:0;text-align:justify;"><strong><a href="#_Toc66809766" rel="nofollow">第8章        项目经验. 94</a></strong></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809767" rel="nofollow">8.1         框架经验. 94</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809768" rel="nofollow"><strong>8.1.1</strong><strong> Hadoop</strong> 94</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809769" rel="nofollow"><strong>8.1.2</strong><strong> Flume</strong> 95</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809770" rel="nofollow"><strong>8.1.3</strong><strong> Kafka</strong> 95</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809771" rel="nofollow"><strong>8.1.4</strong><strong> Tez</strong><strong>引擎优点（略过）？</strong>. 96</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809772" rel="nofollow"><strong>8.1.5</strong><strong> Sqoop</strong><strong>参数</strong>. 96</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809773" rel="nofollow"><strong>8.1.6</strong><strong> Azkaban</strong><strong>每天执行多少个任务</strong>. 96</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809774" rel="nofollow">8.2         业务经验. 97</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809775" rel="nofollow"><strong>8.2.1</strong><strong> ODS</strong><strong>层采用什么压缩方式和存储格式？</strong>. 97</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809776" rel="nofollow"><strong>8.2.2</strong><strong> DWD</strong><strong>层做了哪些事？</strong>. 97</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809777" rel="nofollow"><strong>8.2.3</strong><strong> DWS</strong><strong>层做了哪些事？</strong>. 97</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809778" rel="nofollow"><strong>8.2.4</strong><strong> </strong><strong>分析过哪些指标（一分钟至少说出30</strong><strong>个指标）</strong>. 99</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809779" rel="nofollow"><strong>8.2.5</strong><strong> </strong><strong>分析过最难的两个指标，现场手写</strong>. 102</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809780" rel="nofollow"><strong>8.2.6</strong><strong> </strong><strong>数据仓库每天跑多少张表，大概什么时候运行，运行多久？</strong>. 103</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809781" rel="nofollow"><strong>8.2.7</strong><strong> </strong><strong>数仓中使用的哪种文件存储格式</strong>. 103</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809782" rel="nofollow"><strong>8.2.8</strong><strong> </strong><strong>数仓中用到过哪些Shell</strong><strong>脚本及具体功能</strong>. 104</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809783" rel="nofollow"><strong>8.2.9</strong><strong> </strong><strong>项目中用过的报表工具</strong>. 104</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809784" rel="nofollow"><strong>8.2.10</strong><strong> </strong><strong>测试相关</strong>. 104</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809785" rel="nofollow"><strong>8.2.11</strong><strong> </strong><strong>项目实际工作流程</strong>. 104</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809786" rel="nofollow"><strong>8.2.12</strong><strong> </strong><strong>项目中实现一个需求大概多长时间</strong>. 104</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809787" rel="nofollow"><strong>8.2.13</strong><strong> </strong><strong>项目在3</strong><strong>年内迭代次数，每一个项目具体是如何迭代的。</strong>. 105</a></p> 
 <p style="margin-left:41.95pt;text-align:justify;"><a href="#_Toc66809788" rel="nofollow"><strong>8.2.14</strong><strong> </strong><strong>项目开发中每天做什么事</strong>. 105</a></p> 
 <p style="margin-left:0;text-align:justify;"><strong><a href="#_Toc66809789" rel="nofollow">第9章        JavaSE（答案精简）. 105</a></strong></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809790" rel="nofollow">9.1         hashMap底层源码，数据结构. 105</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809791" rel="nofollow">9.2         Java自带有哪几种线程池？. 108</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809792" rel="nofollow">9.3         HashMap和HashTable区别. 109</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809793" rel="nofollow">9.4         TreeSet和HashSet区别. 110</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809794" rel="nofollow">9.5         String buffer和String build区别. 110</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809795" rel="nofollow">9.6         Final、Finally、Finalize 110</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809796" rel="nofollow">9.7         ==和Equals区别. 111</a></p> 
 <p style="margin-left:0;text-align:justify;"><strong><a href="#_Toc66809797" rel="nofollow">第10章     Redis（答案精简）. 111</a></strong></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809798" rel="nofollow">10.1       缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级. 111</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809799" rel="nofollow">10.2       哨兵模式. 118</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809800" rel="nofollow">10.3       数据类型. 119</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809801" rel="nofollow">10.4       持久化. 119</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809802" rel="nofollow">10.5       悲观锁. 120</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809803" rel="nofollow">10.6       乐观锁. 120</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809804" rel="nofollow">10.7       redis是单线程的，为什么那么快. 120</a></p> 
 <p style="margin-left:0;text-align:justify;"><strong><a href="#_Toc66809805" rel="nofollow">第11章     MySql 121</a></strong></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809806" rel="nofollow">11.1       MyISAM与InnoDB的区别. 121</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809807" rel="nofollow">11.2       索引. 121</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809808" rel="nofollow">11.3       b-tree和b+tree的区别. 122</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809809" rel="nofollow">11.4       MySQL的事务. 122</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809810" rel="nofollow">11.5       常见面试sql 123</a></p> 
 <p style="margin-left:0;text-align:justify;"><strong><a href="#_Toc66809811" rel="nofollow">第12章     JVM 128</a></strong></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809812" rel="nofollow">12.1       JVM内存分哪几个区，每个区的作用是什么? 128</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809813" rel="nofollow">12.2       Java类加载过程? 129</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809814" rel="nofollow">12.3       java中垃圾收集的方法有哪些? 130</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809815" rel="nofollow">12.4       如何判断一个对象是否存活?(或者GC对象的判定方法) 131</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809816" rel="nofollow">12.5       什么是类加载器，类加载器有哪些? 131</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809817" rel="nofollow">12.6       简述Java内存分配与回收策略以及Minor GC和Major GC（full GC）  132</a></p> 
 <p style="margin-left:0;text-align:justify;"><strong><a href="#_Toc66809818" rel="nofollow">第13章     JUC 132</a></strong></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809819" rel="nofollow">13.1       Synchronized与Lock的区别. 132</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809820" rel="nofollow">13.2       Runnable和Callable的区别. 133</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809821" rel="nofollow">13.3       什么是分布式锁. 133</a></p> 
 <p style="margin-left:21pt;text-align:justify;"><a href="#_Toc66809822" rel="nofollow">13.4       什么是分布式事务. 133</a></p> 
 <p style="margin-left:0;text-align:justify;"></p> 
</div> 
<p></p> 
<ol><li style="text-align:justify;"><strong><a name="_Toc66809561"> 找工作流程</a></strong></li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809562"> 学习技能</a></strong></span></span></li></ol> 
<p style="margin-left:0;">1.1.1</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809563"> 编写简历</a></strong></span></span></li></ol> 
<p style="margin-left:0;">简历编写可在公众号【<strong><span style="color:#ff0000;">五分钟学大数据</span></strong>】后台发送：<strong><span style="color:#ff0000;">简历</span></strong>，获取大数据简历的模板，包含各个行业及各个项目，非常全。可直接扫码：</p> 
<p style="margin-left:0;"><img alt="" height="151" src="https://images2.imgbox.com/27/f6/ob4nxDRH_o.png" width="151"></p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809564"> 投简历</a></strong></span></span></li></ol> 
<p style="margin-left:0;">如能内推，尽量走内推路线，可免简历筛选，如果找不到内推路径，可在牛客网上搜内推码，上面有很多公司的员工发内推码。</p> 
<p style="margin-left:0;">招聘软件推荐 Boss直聘，这个软件还是很靠谱的，其他的智联招聘，拉勾，前程无忧，猎聘也不错。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809565"> 约面试时间</a></strong></span></span></li></ol> 
<ol><li style="text-align:justify;">一般需要多轮面试</li><li style="text-align:justify;">不想去的公司先去面试，积累面试经验，想去的公司约到最后</li><li style="text-align:justify;">合理安排面试时间，给自己尽可能的留一些复习的时间</li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809566"> 面试</a></strong></span></span></li></ol> 
<ol><li style="text-align:justify;">人事面试，了解基本情况--笔试/填表</li><li style="text-align:justify;">一面：技术经理面试（面试官一般是入职之后你的直接上级，此面很重要）</li><li style="text-align:justify;">二面：技术老大面试</li><li style="text-align:justify;">三面：架构师/大Boss面试</li><li style="text-align:justify;">.....</li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809567"> 等回复</a></strong></span></span></li></ol> 
<ol><li style="text-align:justify;">不要立马入职</li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809568"> 拿offer</a></strong></span></span></li><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809569"> 入职</a></strong></span></span></li><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809570"> 准备必备资料，签合同</a></strong></span></span></li></ol> 
<ol><li style="text-align:justify;"><strong><a name="_Toc66809571"> 面试说明</a></strong></li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809572"> 笔试</a></strong></span></span></li></ol> 
<ol><li style="text-align:justify;">试题量：一般两页纸，多的有3页纸</li><li style="text-align:justify;">考题类型：选择和简答，简答居多</li></ol> 
<p style="margin-left:0;text-align:justify;"><strong>选择题</strong>：基础知识类型的选择题（编程语言，数据库，操作系统，大数据要点知识，网络，计算机组成原理等）</p> 
<p style="margin-left:0;text-align:justify;">    <strong>简答题</strong>：</p> 
<ol><li> 
  <ol><li style="text-align:justify;">知识点的详细解释类，比如，MapReduce的Shuffle详细过程</li><li style="text-align:justify;">对比之类，Hive内部表和外部表的区别，MapReduce和Spark的异同？</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">    <strong>编程题</strong>：算法题（考察逻辑思维，考察解答问题的方式方法等）</p> 
<p style="margin-left:0;text-align:justify;">    数据库类型的SQL编写题目（MySQL或者Hive）这是必出题，也是分必拿题。否则就全盘覆没了。</p> 
<p style="margin-left:0;text-align:justify;"><strong>SQL</strong><strong>题</strong>：必有（Hive和MySQL）</p> 
<p style="margin-left:0;text-align:justify;">    <strong>场景题</strong>：</p> 
<p style="margin-left:0;text-align:justify;">    给你假定一种场景，让你给出解决方案，面试问的最多的也是这种</p> 
<p style="margin-left:0;text-align:justify;">    遇到了问题（集群节点宕机，任务运行出错，数据丢失等），该如何解决？</p> 
<p style="margin-left:0;text-align:justify;">    <strong>简单脚本题</strong>：</p> 
<p style="margin-left:0;text-align:justify;">    写出一个简单的数据处理脚本，或者运维脚本（会的就自己写，不会的就百度搜，或者求救于小伙伴）</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809573"> 面试</a></strong></span></span> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809574"><strong>人事面试</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">聊基本情况，聊工作经历，聊人生价值观，聊对工作的态度，聊方方面面，就是不聊技术</p> 
<p style="margin-left:0;text-align:justify;">请事先准备好针对你个人基本情况的面试题</p> 
<p style="margin-left:0;text-align:justify;">1、比如你原来在上海，为何10月份来北京找工作？</p> 
<p style="margin-left:0;text-align:justify;">2、比如工作经历中，有4个月是不上班的，怎么解释？</p> 
<p style="margin-left:0;text-align:justify;">.....</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809575"><strong>·手写代码</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">也就是做题 </p> 
<p style="margin-left:0;text-align:justify;">当然技术面试过程中，也有可能会出现手写代码的问题</p> 
<p style="margin-left:0;text-align:justify;">经典手写代码：</p> 
<ul><li style="text-align:justify;">快速排序和归并排序，冒泡排序（优先级由高到低）</li><li style="text-align:justify;">一个设计模式的实现：比如单例，比如代理，比如装饰器</li><li style="text-align:justify;">多线程相关，比如两个线程交替执行</li><li style="text-align:justify;">java,mapreduce,scala,spark的wordcount</li><li style="text-align:justify;">画出你的项目的架构图 或者 数据处理流程架构图 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809576"><strong>技术经理面试</strong></a></span></span></li></ol></li></ol></li></ul> 
<p style="margin-left:0;text-align:justify;">基本只聊技术。</p> 
<p style="margin-left:0;text-align:justify;">基本套路：</p> 
<ul><li style="text-align:justify;">先自我介绍</li><li style="text-align:justify;">然后介绍项目</li><li style="text-align:justify;">从项目入手</li><li style="text-align:justify;">先聊业务</li><li style="text-align:justify;">再切入到技术点</li><li style="text-align:justify;">问如何实现、项目结构、数据处理流程</li><li style="text-align:justify;">问遇到过什么难题，怎么解决的，怎么发现的和怎么避免</li><li style="text-align:justify;">问相类似的场景，如何做技术选型</li><li style="text-align:justify;">问相类似的突发情况，应该怎么决策快速解决问题</li></ul> 
<p style="margin-left:0;text-align:justify;">    考察广度的同时，也会考察深度</p> 
<p style="margin-left:0;text-align:justify;">通俗的说，也就是会在不同的方向，不同的领域问各种问题，然后针对你能回答的问题，就深入探讨，以此得知你对这门技术的掌握程度</p> 
<p style="margin-left:0;text-align:justify;">    所以：</p> 
<p style="margin-left:0;text-align:justify;">    考察广度，就是看你的技术领域分布</p> 
<p style="margin-left:0;text-align:justify;">    考察深度，就是看你你对这个技术掌握程度如何</p> 
<p style="margin-left:0;text-align:justify;">    总体来说：</p> 
<ul><li style="text-align:justify;">聊业务</li><li style="text-align:justify;">聊技术</li><li style="text-align:justify;">聊问题</li><li style="text-align:justify;">聊解决方案</li><li style="text-align:justify;">.... 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809577"><strong>CTO/</strong></a><strong>技术架构师等面试</strong>（如果过了技术经理面试）</span></span></li></ol></li></ol></li></ul> 
<p style="margin-left:0;text-align:justify;">    到了这种级别的面试，一般考察技术的就少了。</p> 
<p style="margin-left:0;text-align:justify;">    更多的是考察发展，眼光更长远的，考察你的职业生涯规划，考察你的价值观，考察你是否符合公司的长期发展战略</p> 
<p style="margin-left:0;text-align:justify;">    能了解公司更多信息，就切合公司实际去描述</p> 
<p style="margin-left:0;text-align:justify;">    如果不了解公司的，那就尽量按照通用套路说</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809578"> 机试</a></strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">少数场景会有的。但是不要慌。按照自己的本事来。</p> 
<p style="margin-left:0;text-align:justify;">有些是现场的，这种很少。有些是给出需求之后让你回来之后自己做。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809579"> 面试考察方式</a></strong></span></span> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809580"><strong>知识广度</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"><strong>编程语言方向</strong></p> 
<p style="margin-left:0;text-align:justify;">    java是重点（重中之重），其次：scala、python</p> 
<p style="margin-left:0;text-align:justify;">    java中的重点考察方向：</p> 
<p style="margin-left:0;text-align:justify;">        集合（优缺点，底层实现，更好的替代方案，如何根据场景选择和使用）</p> 
<p style="margin-left:0;text-align:justify;">        并发（锁，JMM，各种关键字（volite），技术点，线程池，......）</p> 
<p style="margin-left:0;text-align:justify;">        面向对象</p> 
<p style="margin-left:0;text-align:justify;">    <strong>数据库方向</strong></p> 
<p style="margin-left:0;text-align:justify;">    mysql是重点，其次是hbase，redis</p> 
<p style="margin-left:0;text-align:justify;">    sql语句的编写和优化就不说了，没有不考查的 </p> 
<p style="margin-left:0;text-align:justify;">    Hadoop体系/Spark体系</p> 
<p style="margin-left:0;text-align:justify;">    架构原理</p> 
<p style="margin-left:0;text-align:justify;">    工作机制</p> 
<p style="margin-left:0;text-align:justify;">    典型的常见流程</p> 
<p style="margin-left:0;text-align:justify;">    某个功能的详细分析</p> 
<p style="margin-left:0;text-align:justify;">    问题和运维难点</p> 
<p style="margin-left:0;text-align:justify;">    集群规模/集群规划</p> 
<p style="margin-left:0;text-align:justify;">    任务多少</p> 
<p style="margin-left:0;text-align:justify;">    任务运行总时长</p> 
<p style="margin-left:0;text-align:justify;">    每天数据量</p> 
<p style="margin-left:0;text-align:justify;">    总数据量</p> 
<p style="margin-left:0;text-align:justify;">    多少条记录</p> 
<p style="margin-left:0;text-align:justify;">    每条记录多大</p> 
<p style="margin-left:0;text-align:justify;">    每条记录多少个字段</p> 
<p style="margin-left:0;text-align:justify;">    hive的总表数等等</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">    其他知识：</p> 
<p style="margin-left:0;text-align:justify;">        ElasticSearch</p> 
<p style="margin-left:0;text-align:justify;">        Flink</p> 
<p style="margin-left:0;text-align:justify;">        机器学习</p> 
<p style="margin-left:0;text-align:justify;">        架构</p> 
<p style="margin-left:0;text-align:justify;">        优化</p> 
<p style="margin-left:0;text-align:justify;">        源码</p> 
<p style="margin-left:0;text-align:justify;">        数据结构</p> 
<p style="margin-left:0;text-align:justify;">        算法</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809581"><strong>知识深度</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">追根究底的问各种你答的上来的东西的底层实现细节，直到你答不上来为止，或者到他满意为止  </p> 
<p style="margin-left:0;text-align:justify;">关于HashMap的问题：</p> 
<ul><li style="text-align:justify;">什么是HashMap，能否自己实现一个？</li><li style="text-align:justify;">什么时候使用HashMap，有没有替代品？有没有什么好的hasmap使用经验？</li><li style="text-align:justify;">HashMap和HashTable的区别？优缺点？如何选择在那种场景使用？有没有更好的map实现类？</li><li style="text-align:justify;">你知道HashMap的内部数据结构么？/   put和get操作的原理么？</li><li style="text-align:justify;">HashMap的初始长度和扩容策略是怎样的？（什么时候触发扩容，扩大到多少，扩容的时候要考虑什么问题？）</li><li style="text-align:justify;">HashMap初始化传入的容量参数的值就是HashMap实际分配的空间么？</li><li style="text-align:justify;">HashMap解决hash冲突的策略是什么？</li><li style="text-align:justify;">HashMap能同步/线程安全么？怎么做？</li><li style="text-align:justify;">了解HashMap的条件竞争么？</li><li style="text-align:justify;">JDK7和JDK8的hashmap一样么？</li><li style="text-align:justify;">HashMap的key的hash计算规则是怎样的？</li><li style="text-align:justify;">HashMap的key有什么要求？为什么最好是String或者Integer这种类型呢？为什么不要是自定义对象呢？</li><li style="text-align:justify;">了解Hash攻击么？</li><li style="text-align:justify;">了解ConcurrentHashMap么？了解他的工作原理么？和HashMap相比较，优势在哪里？</li></ul> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809582"> 面试过程最关键的是什么？</a></strong></span></span></li></ol> 
<ol><li style="text-align:justify;">不是你说了什么，而是你怎么说</li><li style="text-align:justify;">大大方方的聊，放松</li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809583"> 面试要点</a></strong></span></span></li></ol> 
<ol><li style="text-align:justify;">乐观开朗，不让要人觉得跟你很难交流，要善于交流，善于倾听</li></ol> 
<p style="margin-left:0;text-align:justify;">    别人说的合理的给予赞同和钦佩</p> 
<p style="margin-left:0;text-align:justify;">    别人说的你不赞同的你不要反对，你可以用另外一种方式表现出你的看法和意见，这是讨论和交流，不是针锋相对</p> 
<ol><li style="text-align:justify;">积极向上，所有人都希望融入团队的新人都能给团队增添活力，带给团队乐趣，大家轻松工作，愉快生活</li><li style="text-align:justify;">上进好学，不是说别人一说到不会的，你就说我会去学的，而是要表现出我曾经就是这么学过来的</li><li style="text-align:justify;">有礼貌有情商有智商，不要看起来傻傻的没见过世面一样的，不妄自菲薄，但是也要谦卑，要表现出我有货，但是知道自己不够，自己正在努力</li><li style="text-align:justify;">面试要注意引导。尽量把面试官往你擅长的领域去引导。</li><li style="text-align:justify;">关于回答问题，记住，如果不懂这个问题，可以让面试官再叙述一遍的。如果是真回答不上来，就真诚的回答说不知道，不了解，不太清楚。如果你发现你回答的某些问题的答案，面试官在质疑你，你也不要质疑自己。就一口咬死就是这样的。当然不能是离谱的答案还要坚持。</li><li style="text-align:justify;">总之一切随机应变</li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10405"></a><a name="_Toc10725140"></a><a name="_Toc66809584"> 面试技巧</a></strong></span></span> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725141"></a><a name="_Toc20742"></a><a name="_Toc66809585"><strong>六个常见问题</strong></a></span></span></li></ol></li></ol></li></ol> 
<ol><li style="text-align:justify;">你的优点是什么？</li></ol> 
<p style="margin-left:0;text-align:justify;">    大胆的说出自己各个方面的优势和特长</p> 
<p style="margin-left:0;text-align:justify;">不要写消遣类的爱好，比如爬上，唱歌看电影</p> 
<ol><li style="text-align:justify;">你的缺点是什么？</li></ol> 
<p style="margin-left:0;text-align:justify;">    不要谈自己真实问题；用“缺点”衬托自己的优点</p> 
<ol><li style="text-align:justify;">你的离职原因是什么？</li></ol> 
<ul><li style="text-align:justify;">不说前东家坏话，哪怕被伤过</li><li style="text-align:justify;">合情合理合法</li><li style="text-align:justify;">不要说超过1个以上的原因</li></ul> 
<ol><li style="text-align:justify;">您对薪资的期望是多少？</li></ol> 
<ul><li style="text-align:justify;">非终面不深谈薪资</li><li style="text-align:justify;">只说区间，不说具体数字</li><li style="text-align:justify;">底线是不低于当前薪资</li><li style="text-align:justify;">非要具体数字，区间取中间值，或者当前薪资的+20%</li></ul> 
<ol><li style="text-align:justify;">您还有什么想问的问题？</li></ol> 
<ul><li style="text-align:justify;">这是体现个人眼界和层次的问题</li><li style="text-align:justify;">问题本身不在于面试官想得到什么样的答案，而在于你跟别的应聘者的对比</li><li style="text-align:justify;">标准答案：</li></ul> 
<p style="margin-left:0;text-align:justify;">公司希望我入职后的3-6个月内，给公司解决什么样的问题</p> 
<p style="margin-left:0;text-align:justify;">公司（或者对这个部门）未来的战略规划是什么样子的？</p> 
<ol><li style="text-align:justify;">您最快多长时间能入职？</li></ol> 
<p style="margin-left:0;text-align:justify;">    一周左右，如果公司需要，可以适当提前</p> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725142"></a><a name="_Toc19547"></a><a name="_Toc66809586"><strong>两个注意事项</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<ol><li style="text-align:justify;">职业化的语言</li><li style="text-align:justify;">职业化的形象</li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725143"></a><a name="_Toc25124"></a><a name="_Toc66809587">自我介绍（控制在4分半以内，不超过5分钟）</a></span></span></li></ol></li></ol></li><li style="text-align:justify;">个人基本信息</li><li style="text-align:justify;">工作履历</li></ol> 
<p style="margin-left:0;text-align:justify;">    时间、公司名称、任职岗位、主要工作内容、工作业绩、离职原因</p> 
<ol><li style="text-align:justify;">深度沟通（也叫压力面试）</li></ol> 
<p style="margin-left:0;text-align:justify;">    刨根问底下沉式追问（注意是下沉式，而不是发散式的）</p> 
<p style="margin-left:0;text-align:justify;">    基本技巧：往自己熟悉的方向说</p> 
<ol><li style="text-align:justify;"><strong><a name="_Toc66809588"> 手写代码</a></strong> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809589"> 冒泡排序</a></strong></span></span></li></ol></li></ol> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <pre style="margin-left:0;"><code class="language-html hljs">/**

 * 冒泡排序 时间复杂度 O(n^2) 空间复杂度O(1)

 */

  public class BubbleSort {

    public static void bubbleSort(int[] data) {

        System.out.println("开始排序");

        int arrayLength = data.length;

        for (int i = 0; i &lt; arrayLength - 1; i++) {

            boolean flag = false;

            for (int j = 0; j &lt; arrayLength - 1 - i; j++) {

                if(data[j] &gt; data[j + 1]){

                    int temp = data[j + 1];

                    data[j + 1] = data[j];

                    data[j] = temp;

                    flag = true;

                }

            }

            System.out.println(java.util.Arrays.toString(data));

            if (!flag)

                break;

        }

    }

    public static void main(String[] args) {

        int[] data = { 9, -16, 21, 23, -30, -49, 21, 30, 30 };

        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));

        bubbleSort(data);

        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));

    }

}</code></pre> </td></tr></tbody></table> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809590"> 二分查找</a></strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<p style="margin-left:36pt;text-align:justify;">实现代码：</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <pre style="margin-left:0;"><code class="language-html hljs">/**

 * 二分查找 时间复杂度O(log2n);空间复杂度O(1)

 */

  def binarySearch(arr:Array[Int],left:Int,right:Int,findVal:Int): Int={

  if(left&gt;right){//递归退出条件，找不到，返回-1

    -1

  }

  val midIndex = (left+right)/2

  

  if (findVal &lt; arr(midIndex)){//向左递归查找

    binarySearch(arr,left,midIndex,findVal)

  }else if(findVal &gt; arr(midIndex)){//向右递归查找

    binarySearch(arr,midIndex,right,findVal)

  }else{//查找到，返回下标

    midIndex

  }

}</code></pre> </td></tr></tbody></table> 
<p style="margin-left:36pt;text-align:justify;"><span style="color:#000000;">拓展需求：当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到。</span></p> 
<p style="margin-left:36pt;text-align:justify;">代码实现如下：</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <pre style="margin-left:0;"><code class="language-html hljs">/*

{1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000.

//分析

1. 返回的结果是一个可变数组 ArrayBuffer

2. 在找到结果时，向左边扫描，向右边扫描 [条件]

3. 找到结果后，就加入到ArrayBuffer

 */

  def binarySearch2(arr: Array[Int], l: Int, r: Int,

                  findVal: Int): ArrayBuffer[Int] = {

  

  //找不到条件?

  if (l &gt; r) {

    return ArrayBuffer()

  }

  

  val midIndex = (l + r) / 2

  val midVal = arr(midIndex)

  if (midVal &gt; findVal) {

    //向左进行递归查找

    binarySearch2(arr, l, midIndex - 1, findVal)

  } else if (midVal &lt; findVal) { //向右进行递归查找

    binarySearch2(arr, midIndex + 1, r, findVal)

  } else {

    println("midIndex=" + midIndex)

    //定义一个可变数组

    val resArr = ArrayBuffer[Int]()

    //向左边扫描

    var temp = midIndex - 1

    breakable {

      while (true) {

        if (temp &lt; 0 || arr(temp) != findVal) {

          break()

        }

        if (arr(temp) == findVal) {

          resArr.append(temp)

        }

        temp -= 1

      }

    }

    //将中间这个索引加入

    resArr.append(midIndex)

    //向右边扫描

    temp = midIndex + 1

    breakable {

      while (true) {

        if (temp &gt; arr.length - 1 || arr(temp) != findVal) {

          break()

        }

        if (arr(temp) == findVal) {

          resArr.append(temp)

        }

        temp += 1

      }

    }

    return resArr

  }</code></pre> </td></tr></tbody></table> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809591"> 快排</a></strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<p style="margin-left:36pt;text-align:justify;">代码实现：</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <pre style="margin-left:0;"><code class="language-html hljs">/**

 * 快排 

 * 时间复杂度:平均时间复杂度为O(nlogn)

 * 空间复杂度:O(logn)，因为递归栈空间的使用问题

 */

  public class QuickSort {

    public static void main(String[] args) {

        int [] a = {1,6,8,7,3,5,16,4,8,36,13,44};

        QKSourt(a,0,a.length-1);

        for (int i:a) {

            System.out.print(i + " ");

        }

    }

    private static void QKSourt(int[] a, int start, int end) {

        if (a.length &lt; 0){

            return ;

        }

        if (start &gt;= end){

            return ;

        }

        int left = start;

        int right = end;

        int temp = a[left];

        while (left &lt; right){

            while (left &lt; right &amp;&amp; a[right] &gt; temp){

                right -- ;

            }

            a[left] = a[right];

            while (left &lt; right &amp;&amp; a[left] &lt; temp){

                left ++ ;

            }

            a[right] = a[left];

        }

        a[left] = temp;

        System.out.println(Arrays.toString(a));

        QKSourt(a, start, left -1);

        QKSourt(a,left+1,end);

    }

}</code></pre> </td></tr></tbody></table> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725146"></a><a name="_Toc5360"></a><a name="_Toc66809592"> 归并</a></strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;">核心思想：不断的将大的数组分成两个小数组，直到不能拆分为止，即形成了单个值。此时使用合并的排序思想对已经有序的数组进行合并，合并为一个大的数据，不断重复此过程，直到最终所有数据合并到一个数组为止。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:36pt;text-align:justify;">代码实现：</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <pre style="margin-left:0;"><code class="language-html hljs">/**

 * 快排 

 * 时间复杂度:O(nlogn)

 * 空间复杂度:O(n)

 */

  def merge(left: List[Int], right: List[Int]): List[Int] = (left, right) match {

  case (Nil, _) =&gt; right

  case (_, Nil) =&gt; left

  case (x :: xTail, y :: yTail) =&gt;

    if (x &lt;= y) x :: merge(xTail, right)

    else y :: merge(left, yTail)

}</code></pre> </td></tr></tbody></table> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809593"> 二叉树之Scala实现</a></strong></span></span> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725151"></a><a name="_Toc7955"></a><a name="_Toc66809594"><strong>二叉树概念</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725152"></a><a name="_Toc12189"></a><a name="_Toc66809595"><strong>二叉树的特点</strong></a></span></span></li></ol></li></ol></li><li style="text-align:justify;">树执行查找、删除、插入的时间复杂度都是O(logN)</li><li style="text-align:justify;">遍历二叉树的方法包括前序、中序、后序</li><li style="text-align:justify;">非平衡树指的是根的左右两边的子节点的数量不一致</li><li style="text-align:justify;">在非空二叉树中，第i层的结点总数不超过 , i&gt;=1；</li><li style="text-align:justify;">深度为h的二叉树最多有个结点(h&gt;=1)，最少有h个结点；</li><li style="text-align:justify;">对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1； 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809596"><strong>二叉树的Scala代码实现</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">定义节点以及前序、中序、后序遍历</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <pre style="margin-left:0;"><code class="language-html hljs">class TreeNode(treeNo:Int){

  val no = treeNo

  var left:TreeNode = null

  var right:TreeNode = null

  

  //后序遍历

  def postOrder():Unit={

    //向左递归输出左子树

    if(this.left != null){

      this.left.postOrder

    }

    //向右递归输出右子树

    if (this.right != null) {

      this.right.postOrder

    }

  

    //输出当前节点值

    printf("节点信息 no=%d \n",no)

  }

  

  //中序遍历

  def infixOrder():Unit={

    //向左递归输出左子树

    if(this.left != null){

      this.left.infixOrder()

    }

  

    //输出当前节点值

    printf("节点信息 no=%d \n",no)

  

    //向右递归输出右子树

    if (this.right != null) {

      this.right.infixOrder()

    }

  }

  

  //前序遍历

  def preOrder():Unit={

    //输出当前节点值

    printf("节点信息 no=%d \n",no)

  

    //向左递归输出左子树

    if(this.left != null){

      this.left.postOrder()

    }

  

    //向右递归输出右子树

    if (this.right != null) {

      this.right.preOrder()

    }

  }

  

  //后序遍历查找

  def postOrderSearch(no:Int): TreeNode = {

    //向左递归输出左子树

    var resNode:TreeNode = null

    if (this.left != null) {

      resNode = this.left.postOrderSearch(no)

    }

    if (resNode != null) {

      return resNode

    }

    if (this.right != null) {

      resNode = this.right.postOrderSearch(no)

    }

    if (resNode != null) {

      return resNode

    }

    println("ttt~~")

    if (this.no == no) {

      return this

    }

    resNode

  }

  

  //中序遍历查找

  def infixOrderSearch(no:Int): TreeNode = {

  

    var resNode : TreeNode = null

    //先向左递归查找

    if (this.left != null) {

      resNode = this.left.infixOrderSearch(no)

    }

    if (resNode != null) {

      return resNode

    }

    println("yyy~~")

    if (no == this.no) {

      return this

    }

    //向右递归查找

    if (this.right != null) {

      resNode = this.right.infixOrderSearch(no)

    }

    return resNode

  

  }

  

  //前序查找

  def preOrderSearch(no:Int): TreeNode = {

    if (no == this.no) {

      return this

    }

    //向左递归查找

    var resNode : TreeNode = null

    if (this.left != null) {

      resNode = this.left.preOrderSearch(no)

    }

    if (resNode != null){

      return  resNode

    }

    //向右边递归查找

    if (this.right != null) {

      resNode = this.right.preOrderSearch(no)

    }

  

    return resNode

  }

  

  //删除节点

  //删除节点规则

  //1如果删除的节点是叶子节点，则删除该节点

  //2如果删除的节点是非叶子节点，则删除该子树

  

  def delNode(no:Int): Unit = {

    //首先比较当前节点的左子节点是否为要删除的节点

    if (this.left != null &amp;&amp; this.left.no == no) {

      this.left = null

      return

    }

    //比较当前节点的右子节点是否为要删除的节点

    if (this.right != null &amp;&amp; this.right.no == no) {

      this.right = null

      return

    }

    //向左递归删除

    if (this.left != null) {

      this.left.delNode(no)

    }

    //向右递归删除

    if (this.right != null) {

      this.right.delNode(no)

    }

  }

}</code></pre> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">定义二叉树，前序、中序、后序遍历，前序、中序、后序查找，删除节点</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <pre style="margin-left:0;"><code class="language-html hljs">class BinaryTree {

  var root: TreeNode = null

  

  //后序遍历

  def postOrder(): Unit = {

    if (root != null) {

      root.postOrder()

    } else {

      println("当前二叉树为空，不能遍历")

    }

  }

  

  //中序遍历

  def infixOrder(): Unit = {

    if (root != null) {

      root.infixOrder()

    } else {

      println("当前二叉树为空，不能遍历")

    }

  }

  

  //前序遍历

  def preOrder(): Unit = {

    if (root != null) {

      root.preOrder()

    } else {

      println("当前二叉树为空，不能遍历")

    }

  }

  

  //后序遍历查找

  def postOrderSearch(no: Int): TreeNode = {

    if (root != null) {

      root.postOrderSearch(no)

    } else {

      null

    }

  }

  

  //中序遍历查找

  def infixOrderSeacher(no: Int): TreeNode = {

    if (root != null) {

      return root.infixOrderSearch(no)

    } else {

      return null

    }

  }

  

  //前序查找

  def preOrderSearch(no: Int): TreeNode = {

  

    if (root != null) {

      return root.preOrderSearch(no)

    } else {

      //println("当前二叉树为空，不能查找")

      return null

    }

  }

  

  //删除节点

  def delNode(no: Int): Unit = {

    if (root != null) {

      //先处理一下root是不是要删除的

      if (root.no == no) {

        root = null

      } else {

        root.delNode(no)

      }

    }

  

  }

}</code></pre> </td></tr></tbody></table> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809597"> 手写Spark-WordCount</a></strong></span></span></li></ol></li></ol> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <pre style="margin-left:0;"><code class="language-html hljs">val conf: SparkConf =

  new SparkConf().setMaster("local[*]").setAppName("WordCount")

  

  val sc = new SparkContext(conf)

  

  sc.textFile("/input")

  .flatMap(_.split(" "))

  .map((_, 1))

  .reduceByKey(_ + _)

  .saveAsTextFile("/output")

  

  sc.stop()</code></pre> </td></tr></tbody></table> 
<p style="margin-left:0;"></p> 
<ol><li style="text-align:justify;"><strong><a name="_Toc66809598"> 项目架构</a></strong> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc3963"></a><a name="_Toc10725155"></a><a name="_Toc66809599"> 数仓概念</a></strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"><strong><span style="color:#000000;">数据仓库的输入数据源和输出系统分别是什么？</span></strong></p> 
<p style="margin-left:0;text-align:justify;">输入系统：埋点产生的用户行为数据、JavaEE后台产生的业务数据。</p> 
<p style="margin-left:0;text-align:justify;">输出系统：报表系统、用户画像系统、推荐系统</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725156"></a><a name="_Toc28132"></a><a name="_Toc66809600"> 系统数据流程设计</a></strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc23191"></a><a name="_Toc10725157"></a><a name="_Toc66809601"> 框架版本选型</a></strong></span></span></li></ol></li><li style="text-align:justify;">Apache：运维麻烦，组件间兼容性需要自己调研。（一般大厂使用，技术实力雄厚，有专业的运维人员）</li><li style="text-align:justify;">CDH：国内使用最多的版本，但 CM不开源，但其实对中、小公司使用来说没有影响（建议使用）</li><li style="text-align:justify;">HDP：开源，可以进行二次开发，但是没有CDH稳定，国内使用较少 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc32227"></a><a name="_Toc10725158"></a><a name="_Toc66809602"> 服务器选型</a></strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">服务器使用物理机还是云主机？</p> 
<ol><li style="text-align:justify;">机器成本考虑： 
  <ol><li style="text-align:justify;">物理机：以128G内存，20核物理CPU，40线程，8THDD和2TSSD硬盘，单台报价4W出头，需考虑托管服务器费用。一般物理机寿命5年左右</li><li style="text-align:justify;">云主机，以阿里云为例，差不多相同配置，每年5W</li></ol></li><li style="text-align:justify;">运维成本考虑： 
  <ol><li style="text-align:justify;">物理机：需要有专业的运维人员</li><li style="text-align:justify;">云主机：很多运维工作都由阿里云已经完成，运维相对较轻松</li></ol></li></ol> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725159"></a><a name="_Toc5187"></a><a name="_Toc66809603"> 集群规模</a></strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc23305"></a><a name="_Toc10725160"></a><a name="_Toc66809604"> 人员配置参考</a></strong></span></span> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc2290"></a><a name="_Toc10725161"></a><a name="_Toc66809605"><strong>整体架构</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">属于研发部，技术总监下面有各个项目组，我们属于数据组，其他还有后端项目组，基础平台等。总监上面就是副总等级别了。其他的还有产品运营部等。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725162"></a><a name="_Toc22713"></a><a name="_Toc66809606"><strong>你们部门的职级等级，晋升规则</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">职级就分初级，中级，高级。晋升规则不一定，看公司效益和职位空缺。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725163"></a><a name="_Toc31825"></a><a name="_Toc66809607"><strong>人员配置参考</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">小型公司（3人左右）：组长1人，剩余组员无明确分工，并且可能兼顾javaEE和前端。</p> 
<p style="margin-left:0;text-align:justify;">中小型公司（3~6人左右）：组长1人，离线2人左右，实时1人左右（离线一般多于实时），JavaEE 1人（有或者没有人单独负责JavaEE，有时是有组员大数据和JavaEE一起做，或者大数据和前端一起做）。</p> 
<p style="margin-left:0;text-align:justify;">中型公司（5~10人左右）：组长1人，离线3~5人左右（离线处理、数仓），实时2人左右，JavaEE 1人左右（负责对接JavaEE业务），前端1人左右（有或者没有人单独负责前端）。</p> 
<p style="margin-left:0;text-align:justify;">中大型公司（5~20人左右）：组长1人，离线5~10人（离线处理、数仓），实时5人左右，JavaEE2人左右（负责对接JavaEE业务），前端1人（有或者没有人单独负责前端）。（发展比较良好的中大型公司可能大数据部门已经细化拆分，分成多个大数据组，分别负责不同业务）</p> 
<p style="margin-left:0;text-align:justify;">上面只是参考配置，因为公司之间差异很大，例如ofo大数据部门只有5个人左右，因此根据所选公司规模确定一个合理范围，在面试前必须将这个人员配置考虑清楚，回答时要非常确定。</p> 
<ol><li style="text-align:justify;"><strong><a name="_Toc14961"></a><a name="_Toc10725164"></a><a name="_Toc66809608"> 项目涉及技术</a></strong> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc8261"></a><a name="_Toc10725165"></a><a name="_Toc66809609"> Linux&amp;Shell</a>相关总结</strong></span></span> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725166"></a><a name="_Toc32099"></a><a name="_Toc66809610"><strong>Linux</strong></a><strong>常用命令</strong></span></span></li></ol></li></ol></li></ol> 
<table border="1" cellspacing="0" style="width:416pt;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:35.95pt;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">序号</span></p> </td><td style="border-color:#000000;vertical-align:top;width:6cm;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">命令</span></p> </td><td style="border-color:#000000;vertical-align:top;width:209.95pt;"> <p style="margin-left:0;"><span style="color:#000000;">命令解释</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:35.95pt;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">1</span></p> </td><td style="vertical-align:top;width:6cm;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">top</span></p> </td><td style="vertical-align:top;width:209.95pt;"> <p style="margin-left:0;"><span style="color:#000000;">查看内存</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:35.95pt;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">2</span></p> </td><td style="vertical-align:top;width:6cm;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">df -h</span></p> </td><td style="vertical-align:top;width:209.95pt;"> <p style="margin-left:0;"><span style="color:#000000;">查看磁盘存储情况</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:35.95pt;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">3</span></p> </td><td style="vertical-align:top;width:6cm;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">iotop</span></p> </td><td style="vertical-align:top;width:209.95pt;"> <p style="margin-left:0;"><span style="color:#000000;">查看磁盘IO读写(yum install iotop安装）</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:35.95pt;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">4</span></p> </td><td style="vertical-align:top;width:6cm;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">iotop -o</span></p> </td><td style="vertical-align:top;width:209.95pt;"> <p style="margin-left:0;"><span style="color:#000000;">直接查看比较高的磁盘读写程序</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:35.95pt;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">5</span></p> </td><td style="vertical-align:top;width:6cm;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">netstat -tunlp | grep </span><span style="color:#000000;">端口号</span></p> </td><td style="vertical-align:top;width:209.95pt;"> <p style="margin-left:0;"><span style="color:#000000;">查看端口占用情况</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:35.95pt;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">6</span></p> </td><td style="vertical-align:top;width:6cm;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">uptime</span></p> </td><td style="vertical-align:top;width:209.95pt;"> <p style="margin-left:0;"><span style="color:#000000;">查看报告系统运行时长及平均负载</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:35.95pt;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">7</span></p> </td><td style="vertical-align:top;width:6cm;"> <p style="margin-left:0;text-align:center;"><span style="color:#000000;">ps  aux</span></p> </td><td style="vertical-align:top;width:209.95pt;"> <p style="margin-left:0;"><span style="color:#000000;">查看进程</span></p> </td></tr></tbody></table> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725167"></a><a name="_Toc11434"></a><a name="_Toc66809611"><strong>Shell</strong></a><strong>常用工具</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">awk、sed、cut、sort</p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725168"></a><a name="_Toc13214"></a><a name="_Toc66809612"> Hadoop</a>相关总结</strong></span></span> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc26199"></a><a name="_Toc10725169"></a><a name="_Toc66809613"><strong>Hadoop</strong></a><strong>常用端口号</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"><span style="color:#ff0000;">Hadoop 2.x </span><span style="color:#ff0000;">版本：</span></p> 
<ul><li style="text-align:justify;">dfs.namenode.http-address:50070</li><li style="text-align:justify;">dfs.datanode.http-address:50075</li><li style="text-align:justify;">SecondaryNameNode辅助名称节点端口号：50090</li><li style="text-align:justify;">dfs.datanode.address:50010</li><li style="text-align:justify;">fs.defaultFS:8020 或者9000</li><li style="text-align:justify;">yarn.resourcemanager.webapp.address:8088</li><li style="text-align:justify;">历史服务器web访问端口：19888</li></ul> 
<p style="margin-left:0;text-align:justify;"><span style="color:#ff0000;">Hadoop 3.x</span><span style="color:#ff0000;">版本：(仅列出相对于2.x版本有更改的端口，箭头前为2.x，箭头后为3.x)</span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">NameNode </span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">的端口</span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">: </span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">50070 --&gt; 9870 </span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">8020 --&gt; 9820,</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">50470 --&gt; 9871</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">Secondary NameNode</span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">的端口</span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">: </span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">50091 --&gt; 9869</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">50090 --&gt; 9868</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#000000;">DataNode </span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#000000;">的端口</span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#000000;">:</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4a4a4a;"> 50020 --&gt; 9867</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4a4a4a;"> 50010 --&gt; 9866</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4a4a4a;"> 50475 --&gt; 9865</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">50075 --&gt; 9864</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">Hadoop KMS </span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">的端口</span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">: </span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4a4a4a;">16000 --&gt; 9600</span></span></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725170"></a><a name="_Toc66809614"><strong>Hadoop</strong></a><strong>配置文件以及简单的Hadoop集群搭建</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">配置文件：</li></ol> 
<p style="margin-left:0;text-align:justify;">core-site.xml、hdfs-site.xml、mapred-site.xml、yarn-site.xml</p> 
<p style="margin-left:0;text-align:justify;">hadoop-env.sh、yarn-env.sh、mapred-env.sh、slaves</p> 
<ol><li style="text-align:justify;">简单的集群搭建过程：</li></ol> 
<p style="margin-left:0;text-align:justify;">JDK安装</p> 
<p style="margin-left:0;text-align:justify;">配置SSH免密登录</p> 
<p style="margin-left:0;text-align:justify;">配置hadoop核心文件: </p> 
<p style="margin-left:0;text-align:justify;">格式化namenode</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc5873"></a><a name="_Toc10725171"></a><a name="_Toc66809615"><strong>HDFS</strong></a><strong>读流程和写流程</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"><strong><span style="color:#ff0000;">HDFS</span></strong><strong><span style="color:#ff0000;">读数据：</span></strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#ff0000;">HDFS</span></strong><strong><span style="color:#ff0000;">写数据：</span></strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725172"></a><a name="_Toc21815"></a><a name="_Toc66809616"><strong>MapReduce</strong></a><strong>的Shuffle过程及Hadoop优化（包括：压缩、小文件、集群优化）</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"><strong>MapReduce</strong><strong>的详细工作流程：</strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>一、Shuffle机制</strong></p> 
<ol><li style="text-align:justify;">Map方法之后Reduce方法之前这段处理过程叫Shuffle</li><li style="text-align:justify;">Map方法之后，数据首先进入到分区方法，把数据标记好分区，然后把数据发送到环形缓冲区；环形缓冲区默认大小100m，环形缓冲区达到80%时，进行溢写；溢写前对数据进行排序，排序按照对key的索引进行字典顺序排序，<strong><span style="color:#ff0000;">排序的手段快排</span></strong>；溢写产生大量溢写文件，需要对溢写文件进行<strong><span style="color:#ff0000;">归并排序</span></strong>；对溢写的文件也可以进行Combiner操作，前提是汇总操作，求平均值不行。最后将文件按照分区存储到磁盘，等待Reduce端拉取。</li><li style="text-align:justify;">每个Reduce拉取Map端对应分区的数据。拉取数据后先存储到内存中，内存不够了，再存储到磁盘。拉取完所有数据后，采用<strong><span style="color:#ff0000;">归并排序</span></strong>将内存和磁盘中的数据都进行排序。在进入Reduce方法前，可以对数据进行分组操作。</li></ol> 
<p style="margin-left:0;text-align:justify;"><strong>二、Hadoop优化</strong></p> 
<ol><li style="text-align:justify;">HDFS小文件影响 
  <ol><li style="text-align:justify;">影响NameNode的寿命，因为文件元数据存储在NameNode的内存中</li><li style="text-align:justify;">影响计算引擎的任务数量，比如每个小的文件都会生成一个Map任务</li></ol></li><li style="text-align:justify;">数据输入小文件处理： 
  <ol><li style="text-align:justify;">合并小文件：对小文件进行归档（Har）、自定义Inputformat将小文件存储成SequenceFile文件。</li><li style="text-align:justify;">采用ConbinFileInputFormat来作为输入，解决输入端大量小文件场景。</li><li style="text-align:justify;">对于大量小文件Job，可以开启JVM重用。</li></ol></li><li style="text-align:justify;">Map阶段 
  <ol><li style="text-align:justify;">增大环形缓冲区大小。由100m扩大到200m</li><li style="text-align:justify;">增大环形缓冲区溢写的比例。由80%扩大到90%</li><li style="text-align:justify;">减少对溢写文件的merge次数。</li><li style="text-align:justify;">不影响实际业务的前提下，采用Combiner提前合并，减少 I/O。</li></ol></li><li style="text-align:justify;">Reduce阶段 
  <ol><li style="text-align:justify;">合理设置Map和Reduce数：两个都不能设置太少，也不能设置太多。太少，会导致Task等待，延长处理时间；太多，会导致 Map、Reduce任务间竞争资源，造成处理超时等错误。</li><li style="text-align:justify;">设置Map、Reduce共存：调整slowstart.completedmaps参数，使Map运行到一定程度后，Reduce也开始运行，减少Reduce的等待时间。</li><li style="text-align:justify;">规避使用Reduce，因为Reduce在用于连接数据集的时候将会产生大量的网络消耗。</li><li style="text-align:justify;">增加每个Reduce去Map中拿数据的并行数</li><li style="text-align:justify;">集群性能可以的前提下，增大Reduce端存储数据内存的大小。</li></ol></li><li style="text-align:justify;">IO传输 
  <ol><li style="text-align:justify;">采用数据压缩的方式，减少网络IO的的时间。安装<strong><span style="color:#ff0000;">Snappy</span></strong>和LZOP压缩编码器。</li><li style="text-align:justify;">使用SequenceFile二进制文件</li></ol></li><li style="text-align:justify;">整体 
  <ol><li style="text-align:justify;">MapTask默认内存大小为1G，可以增加MapTask内存大小为4-5g</li><li style="text-align:justify;">ReduceTask默认内存大小为1G，可以增加ReduceTask内存大小为4-5g</li><li style="text-align:justify;">可以增加MapTask的cpu核数，增加ReduceTask的CPU核数</li><li style="text-align:justify;">增加每个Container的CPU核数和内存大小</li><li style="text-align:justify;">调整每个Map Task和Reduce Task最大重试次数</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"><strong>三、压缩</strong></p> 
<table border="1" cellspacing="0" style="width:412.7pt;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:50.15pt;"> <p style="margin-left:0;"><span style="color:#000000;">压缩格式</span></p> </td><td style="border-color:#000000;vertical-align:top;width:77.95pt;"> <p style="margin-left:0;"><span style="color:#000000;">Hadoop</span><span style="color:#000000;">自带？</span></p> </td><td style="border-color:#000000;vertical-align:top;width:2cm;"> <p style="margin-left:0;"><span style="color:#000000;">算法</span></p> </td><td style="border-color:#000000;vertical-align:top;width:2cm;"> <p style="margin-left:0;"><span style="color:#000000;">文件扩展名</span></p> </td><td style="border-color:#000000;vertical-align:top;width:49.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">支持切分</span></p> </td><td style="border-color:#000000;vertical-align:top;width:121.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">换成压缩格式后，原来的程序是否需要修改</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:50.15pt;"> <p style="margin-left:0;"><span style="color:#000000;">DEFLATE</span></p> </td><td style="vertical-align:top;width:77.95pt;"> <p style="margin-left:0;"><span style="color:#000000;">是，直接使用</span></p> </td><td style="vertical-align:top;width:2cm;"> <p style="margin-left:0;"><span style="color:#000000;">DEFLATE</span></p> </td><td style="vertical-align:top;width:2cm;"> <p style="margin-left:0;"><span style="color:#000000;">.deflate</span></p> </td><td style="vertical-align:top;width:49.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">否</span></p> </td><td style="vertical-align:top;width:121.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">和文本处理一样，不需要修改</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:50.15pt;"> <p style="margin-left:0;"><span style="color:#000000;">Gzip</span></p> </td><td style="vertical-align:top;width:77.95pt;"> <p style="margin-left:0;"><span style="color:#000000;">是，直接使用</span></p> </td><td style="vertical-align:top;width:2cm;"> <p style="margin-left:0;"><span style="color:#000000;">DEFLATE</span></p> </td><td style="vertical-align:top;width:2cm;"> <p style="margin-left:0;"><span style="color:#000000;">.gz</span></p> </td><td style="vertical-align:top;width:49.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">否</span></p> </td><td style="vertical-align:top;width:121.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">和文本处理一样，不需要修改</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:50.15pt;"> <p style="margin-left:0;"><span style="color:#000000;">bzip2</span></p> </td><td style="vertical-align:top;width:77.95pt;"> <p style="margin-left:0;"><span style="color:#000000;">是，直接使用</span></p> </td><td style="vertical-align:top;width:2cm;"> <p style="margin-left:0;"><span style="color:#000000;">bzip2</span></p> </td><td style="vertical-align:top;width:2cm;"> <p style="margin-left:0;"><span style="color:#000000;">.bz2</span></p> </td><td style="vertical-align:top;width:49.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">是</span></p> </td><td style="vertical-align:top;width:121.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">和文本处理一样，不需要修改</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:50.15pt;"> <p style="margin-left:0;"><span style="color:#000000;">LZO</span></p> </td><td style="vertical-align:top;width:77.95pt;"> <p style="margin-left:0;"><span style="color:#000000;">否，需要安装</span></p> </td><td style="vertical-align:top;width:2cm;"> <p style="margin-left:0;"><span style="color:#000000;">LZO</span></p> </td><td style="vertical-align:top;width:2cm;"> <p style="margin-left:0;"><span style="color:#000000;">.lzo</span></p> </td><td style="vertical-align:top;width:49.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">是</span></p> </td><td style="vertical-align:top;width:121.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">需要建索引，还需要指定输入格式</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:50.15pt;"> <p style="margin-left:0;"><span style="color:#000000;">Snappy</span></p> </td><td style="vertical-align:top;width:77.95pt;"> <p style="margin-left:0;"><span style="color:#000000;">否，需要安装</span></p> </td><td style="vertical-align:top;width:2cm;"> <p style="margin-left:0;"><span style="color:#000000;">Snappy</span></p> </td><td style="vertical-align:top;width:2cm;"> <p style="margin-left:0;"><span style="color:#000000;">.snappy</span></p> </td><td style="vertical-align:top;width:49.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">否</span></p> </td><td style="vertical-align:top;width:121.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">和文本处理一样，不需要修改</span></p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;"><span style="color:#ffffff;">提示：如果面试过程问起，我们一般回答压缩方式为</span><strong><span style="color:#ff0000;">Snappy</span></strong>，特点速度快，缺点无法切分（可以回答在链式MR中，Reduce端输出使用bzip2压缩，以便后续的map任务对数据进行split）</p> 
<p style="margin-left:0;text-align:justify;"><strong>四、切片机制</strong></p> 
<ol><li style="text-align:justify;">简单地按照文件的内容长度进行切片</li><li style="text-align:justify;">切片大小，默认等于Block大小</li><li style="text-align:justify;">切片时不考虑数据集整体，而是逐个针对每一个文件单独切片</li></ol> 
<p style="margin-left:0;text-align:justify;">提示：切片大小公式：max(0,min(Long_max,blockSize))</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc17545"></a><a name="_Toc10725173"></a><a name="_Toc66809617"><strong>Yarn</strong></a><strong>的Job提交流程</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc5457"></a><a name="_Toc10725174"></a><a name="_Toc66809618"><strong>Yarn</strong></a><strong>的默认调度器、调度器分类、以及他们之间的区别</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">Hadoop调度器重要分为三类：</li></ol> 
<p style="margin-left:0;text-align:justify;">FIFO（先进先出调度器）、Capacity Scheduler（容量调度器）和Fair Sceduler（公平调度器）。</p> 
<p style="margin-left:0;text-align:justify;">Hadoop2.7.2默认的资源调度器是 容量调度器</p> 
<ol><li style="text-align:justify;">区别：</li></ol> 
<p style="margin-left:0;text-align:justify;">FIFO调度器：先进先出，同一时间队列中只有一个任务在执行。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;">容量调度器：多队列；每个队列内部先进先出，同一时间队列中只有一个任务在执行。队列的并行度为队列的个数。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;">公平调度器：多队列；每个队列内部按照缺额大小分配资源启动任务，同一时间队列中有多个任务执行。队列的并行度大于等于队列的个数。</p> 
<ol><li style="text-align:justify;"><a name="_Hlk525278622">一定要强调生产环境中不是使用的FifoScheduler，面试的时侯会发现候选人大概了解这几种调度器的区别，但是问在生产环境用哪种，却说使用的FifoScheduler（<strong><span style="color:#ff0000;">企业生产环境一定不会用这个调度的</span></strong>）</a></li></ol> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc12076"></a><a name="_Toc10725175"></a><a name="_Toc66809619"><strong>项目经验之LZO压缩</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">启用lzo的压缩方式对于小规模集群是很有用处，压缩比率大概能降到原始日志大小的1/3。同时解压缩的速度也比较快。</p> 
<p style="margin-left:0;text-align:justify;">Hadoop默认不支持LZO压缩，如果需要支持LZO压缩，需要添加jar包，并在hadoop的cores-site.xml文件中添加相关压缩配置。</p> 
<ol><li style="text-align:justify;">环境准备</li></ol> 
<p style="margin-left:0;text-align:justify;">maven（下载安装，配置环境变量，修改sitting.xml加阿里云镜像）<br>     gcc-c++<br>     zlib-devel<br>     autoconf<br>     automake<br>     libtool<br>     通过yum安装即可</p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">yum -y install gcc-c++ lzo-devel zlib-devel autoconf automake libtool</span></span></p> 
<ol><li style="text-align:justify;">下载、安装并编译LZO</li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">wget http://www.oberhumer.com/opensource/lzo/download/lzo-2.10.tar.gz</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">tar -zxvf lzo-2.10.tar.gz</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">cd lzo-2.10</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">./configure -prefix=/usr/local/hadoop/lzo/</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">make</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">make install</span></span></p> 
<ol><li style="text-align:justify;">编译hadoop-lzo源码 
  <ol><li style="text-align:justify;">下载hadoop-lzo的源码</li></ol></li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">下载地址：https://github.com/twitter/hadoop-lzo/archive/master.zip</span></span></p> 
<ol><li> 
  <ol><li style="text-align:justify;">解压之后，修改pom.xml</li></ol></li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">&lt;hadoop.current.version&gt;2.7.2&lt;/hadoop.current.version&gt;</span></span></p> 
<ol><li> 
  <ol><li style="text-align:justify;">声明两个临时环境变量</li></ol></li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;"> export C_INCLUDE_PATH=/usr/local/hadoop/lzo/include</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;"> export LIBRARY_PATH=/usr/local/hadoop/lzo/lib </span></span></p> 
<ol><li> 
  <ol><li style="text-align:justify;">进入hadoop-lzo-master，执行maven编译命令</li></ol></li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">mvn package -Dmaven.test.skip=true</span></span></p> 
<ol><li> 
  <ol><li style="text-align:justify;">进入target，将hadoop-lzo-0.4.21-SNAPSHOT.jar放到hadoop的classpath下</li></ol></li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">如${HADOOP_HOME}/share/hadoop/common</span></span></p> 
<ol><li> 
  <ol><li style="text-align:justify;">修改core-site.xml增加配置支持LZO压缩</li></ol></li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">&lt;configuration&gt;</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">        &lt;property&gt;</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">            &lt;name&gt;io.compression.codecs&lt;/name&gt;</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">            &lt;value&gt;</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">            org.apache.hadoop.io.compress.GzipCodec,</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">            org.apache.hadoop.io.compress.DefaultCodec,</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">            org.apache.hadoop.io.compress.BZip2Codec,</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">            org.apache.hadoop.io.compress.SnappyCodec,</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">            com.hadoop.compression.lzo.LzoCodec,</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">            com.hadoop.compression.lzo.LzopCodec</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">            &lt;/value&gt;</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">        &lt;/property&gt;</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">        &lt;property&gt;</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">            &lt;name&gt;io.compression.codec.lzo.class&lt;/name&gt;</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">            &lt;value&gt;com.hadoop.compression.lzo.LzoCodec&lt;/value&gt;</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">        &lt;/property&gt;</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">&lt;/configuration&gt;</span></span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#ff0000;">注意：</span></strong></p> 
<p style="margin-left:0;text-align:justify;">LZO本身是不支持分片的，但是我们给LZO压缩的文件加上索引，就支持分片了</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc17333"></a><a name="_Toc10725176"></a><a name="_Toc66809620"><strong>Hadoop</strong></a><strong>参数调优</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">在hdfs-site.xml文件中配置多目录，最好提前配置好，否则更改目录需要重新启动集群</li><li style="text-align:justify;">NameNode有一个工作线程池，用来处理不同DataNode的并发心跳以及客户端并发的元数据操作。</li></ol> 
<p style="margin-left:0;text-align:justify;">dfs.namenode.handler.count=20 * log2(Cluster Size)，比如集群规模为10台时，此参数设置为60</p> 
<ol><li style="text-align:justify;">编辑日志存储路径dfs.namenode.edits.dir设置与镜像文件存储路径dfs.namenode.name.dir尽量分开，达到最低写入延迟</li><li style="text-align:justify;">服务器节点上YARN可使用的物理内存总量，默认是8192（MB），注意，如果你的节点内存资源不够8GB，则需要调减小这个值，而YARN不会智能的探测节点的物理内存总量。yarn.nodemanager.resource.memory-mb</li><li style="text-align:justify;">单个任务可申请的最多物理内存量，默认是8192（MB）。yarn.scheduler.maximum-allocation-mb 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725177"></a><a name="_Toc3002"></a><a name="_Toc66809621"><strong>项目经验之基准测试</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Hadoop 带有一些基准测试程序，可以最少的准备成本轻松运行。基准测试被打包在测试程序JAR文件中，通过无参调用JAR文件可以得到其列表</p> 
<ol><li style="text-align:justify;">查看信息：</li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">[root@node1 hadoop-2.6.0-cdh5.14.0]# bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-client-jobclient-2.6.0-cdh5.14.0-tests.jar</span></span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;">写入速度测试</li></ol> 
<p style="margin-left:0;text-align:justify;">测试写入10个10M文件</p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">[root@node1 hadoop-2.6.0-cdh5.14.0]# bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-client-jobclient-2.6.0-cdh5.14.0-tests.jar TestDFSIO -write -nrFiles 10 -fileSize 10MB</span></span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;">测试读文件速度</li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">[root@node1 hadoop-2.6.0-cdh5.14.0]# bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-client-jobclient-2.6.0-cdh5.14.0-tests.jar TestDFSIO -read -nrFiles 10 -fileSize 10MB</span></span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;">命令查看</li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">[root@node1 hadoop-2.6.0-cdh5.14.0]# cat TestDFSIO_results.log</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">----- TestDFSIO ----- : write</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">           Date &amp; time: Fri Nov 08 10:43:20 CST 2019</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">       Number of files: 10</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">Total MBytes processed: 100.0</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">     Throughput mb/sec: 4.551039912620034</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">Average IO rate mb/sec: 5.2242536544799805</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;"> IO rate std deviation: 2.1074511594328245</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">    Test exec time sec: 52.394</span></span></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">----- TestDFSIO ----- : read</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">           Date &amp; time: Fri Nov 08 10:45:28 CST 2019</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">       Number of files: 10</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">Total MBytes processed: 100.0</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">     Throughput mb/sec: 73.85524372230428</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">Average IO rate mb/sec: 135.5804901123047</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;"> IO rate std deviation: 111.20953898062095</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">    Test exec time sec: 28.231</span></span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc24312"></a><a name="_Toc10725178"></a><a name="_Toc66809622"><strong>Hadoop</strong></a><strong>宕机</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">如果MR造成系统宕机。此时要控制Yarn同时运行的任务数，和每个任务申请的最大内存。调整参数：yarn.scheduler.maximum-allocation-mb（单个任务可申请的最多物理内存量，默认是8192MB）</li><li style="text-align:justify;">如果写入文件过量造成NameNode宕机。那么调高Kafka的存储大小，控制从Kafka到HDFS的写入速度。高峰期的时候用Kafka进行缓存，高峰期过去数据同步会自动跟上。 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725179"></a><a name="_Toc28363"></a><a name="_Toc66809623"> Zookeeper</a>相关总结</strong></span></span> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725180"></a><a name="_Toc16480"></a><a name="_Toc66809624"><strong>选举机制</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">半数机制</p> 
<p style="margin-left:0;text-align:justify;">三个核心选举原则：</p> 
<ol><li style="text-align:justify;">Zookeeper集群中只有超过半数以上的服务器启动，集群才能正常工作；</li><li style="text-align:justify;">在集群正常工作之前，myid小的服务器给myid大的服务器投票，直到集群正常工作，选出Leader；</li><li style="text-align:justify;">选出Leader之后，之前的服务器状态由Looking改变为Following，以后的服务器都是Follower</li></ol> 
<p style="margin-left:0;text-align:justify;"><strong>比如：</strong></p> 
<p style="margin-left:0;text-align:justify;">集群半数以上存活，集群可用</p> 
<p style="margin-left:0;text-align:justify;">假设有五台服务器组成的zookeeper集群，它们的id从1-5，同时它们都是最新启动的</p> 
<ol><li style="text-align:justify;">1启动，选自己</li><li style="text-align:justify;">2启动，选自己（比1大，12选2）</li><li style="text-align:justify;">3启动，选自己（123都选3，超过半数）当选leader</li><li style="text-align:justify;">4启动，已有leader3</li><li style="text-align:justify;">5启动，已有leader3 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc12137"></a><a name="_Toc10725181"></a><a name="_Toc66809625"><strong>常用命令</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">ls</span><span style="color:#000000;">、get、create</span></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc16931"></a><a name="_Toc10725182"></a><a name="_Toc66809626"> Flume</a>相关总结</strong></span></span> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725183"></a><a name="_Toc2278"></a><a name="_Toc66809627"><strong>Flume</strong></a><strong>组成，Put事务，Take事务</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">flume组成，Put事务，Take事务</li></ol> 
<p style="margin-left:0;text-align:justify;">Taildir Source：断点续传、多目录。Flume1.6以前需要自己自定义Source记录每次读取文件位置，实现断点续传。</p> 
<p style="margin-left:0;text-align:justify;">File Channel：数据存储在磁盘，宕机数据可以保存。但是传输速率慢。适合对数据传输可靠性要求高的场景，比如，金融行业。</p> 
<p style="margin-left:0;text-align:justify;">Memory Channel：数据存储在内存中，宕机数据丢失。传输速率快。适合对数据传输可靠性要求不高的场景，比如，普通的日志数据。</p> 
<p style="margin-left:0;text-align:justify;">Kafka Channel：减少了Flume的Sink阶段，提高了传输效率。          </p> 
<p style="margin-left:0;text-align:justify;">Source到Channel是Put事务</p> 
<p style="margin-left:0;text-align:justify;">Channel到Sink是Take事务</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc7290"></a><a name="_Toc10725184"></a><a name="_Toc66809628"><strong>Flume</strong></a><strong>拦截器</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">拦截器注意事项</li></ol> 
<p style="margin-left:0;text-align:justify;">项目中自定义了：ETL拦截器和区分类型拦截器。</p> 
<p style="margin-left:0;text-align:justify;">采用两个拦截器的优缺点：优点，模块化开发和可移植性；缺点，性能会低一些</p> 
<ol><li style="text-align:justify;">自定义拦截器步骤 
  <ol><li style="text-align:justify;">实现 Interceptor</li><li style="text-align:justify;">重写四个方法</li></ol></li></ol> 
<ol><li> 
  <ol><li style="text-align:justify;">initialize 初始化</li><li style="text-align:justify;">public Event intercept(Event event) 处理单个Event</li><li style="text-align:justify;">public List&lt;Event&gt; intercept(List&lt;Event&gt; events) 处理多个Event，在这个方法中调用Event intercept(Event event)</li><li style="text-align:justify;">close 方法</li></ol></li></ol> 
<ol><li> 
  <ol><li style="text-align:justify;">静态内部类，实现Interceptor.Builder 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc15385"></a><a name="_Toc10725185"></a><a name="_Toc66809629"><strong>Flume Channel</strong></a><strong>选择器</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc22613"></a><a name="_Toc10725186"></a><a name="_Toc66809630"><strong>Flume</strong></a><strong>监控器</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"><strong>Ganglia</strong><strong>监控</strong></p> 
<p style="margin-left:0;text-align:justify;">加州伯克利大学千禧计划的其中一个开源项目.是一个集群汇总监控用的的软件，和Cacti不同，cacti是详细监控集群中每台服务器的运行状态，而Ganglia是将集群中的服务器数据进行汇总然后监控。有时通过cacti或者zabbix（监控软件）看不出来的集群总体负载问题，却能够在Ganglia中体现。被监控的主机(即client)安装ganglia-gmond并启动该进程。服务器端需要安装gmetad和web程序。大致大构图如下：</p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#000000;">   </span></span> <span style="color:#000000;">参考链接：</span><span style="color:#000000;"><a href="https://www.cnblogs.com/yinzhengjie/p/9798739.html" rel="nofollow"><span style="color:#000000;">https://www.cnblogs.com/yinzhengjie/p/9798739.html</span></a></span></span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc13254"></a><a name="_Toc66809631"></a><a name="_Toc10725187"><strong>Flume</strong></a><strong>采集数据会丢失吗?</strong><strong>（防止数据丢失的机制）</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">不会，Channel存储可以存储在File中，数据传输自身有事务。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc27834"></a><a name="_Toc10725188"></a><a name="_Toc66809632"><strong>Flume</strong></a><strong>内存</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">开发中在flume-env.sh中设置JVM heap为4G或更高，部署在单独的服务器上（4核8线程16G内存）</p> 
<p style="margin-left:0;text-align:justify;">-Xmx（设定程序运行期间最大可占用的内存大小）与-Xms（设定程序启动时占用内存大小）最好设置一致，减少内存抖动带来的性能影响，如果设置不一致容易导致频繁fullgc。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725189"></a><a name="_Toc3322"></a><a name="_Toc66809633"><strong>FileChannel</strong></a><strong>优化</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">通过配置dataDirs指向多个路径，每个路径对应不同的硬盘，增大Flume吞吐量。</p> 
<p style="margin-left:0;text-align:justify;">官方说明如下：</p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">Comma separated list of directories for storing log files. Using multiple directories on separate disks can improve file channel peformance</span></span></p> 
<p style="margin-left:0;text-align:justify;">checkpointDir和backupCheckpointDir也尽量配置在不同硬盘对应的目录中，保证checkpoint坏掉后，可以快速使用backupCheckpointDir恢复数据</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725190"></a><a name="_Toc1044"></a><a name="_Toc66809634"><strong>HDFS Sink</strong></a><strong>小文件处理</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">HDFS存入大量小文件，有什么影响？</li></ol> 
<p style="margin-left:0;text-align:justify;"><strong>元数据层面</strong>：每个小文件都有一份元数据，其中包括文件路径，文件名，所有者，所属组，权限，创建时间等，这些信息都保存在Namenode内存中。所以小文件过多，会占用Namenode服务器大量内存，影响Namenode性能和使用寿命</p> 
<p style="margin-left:0;text-align:justify;"><strong>计算层面</strong>：默认情况下MR会对每个小文件启用一个Map任务计算，非常影响计算性能。同时也影响磁盘寻址时间。</p> 
<ol><li style="text-align:justify;">HDFS小文件处理</li></ol> 
<p style="margin-left:0;text-align:justify;">官方默认的这三个参数配置写入HDFS后会产生小文件，hdfs.rollInterval、hdfs.rollSize、hdfs.rollCount</p> 
<p style="margin-left:0;text-align:justify;">基于以上hdfs.rollInterval=3600，hdfs.rollSize=134217728，hdfs.rollCount =0，hdfs.roundValue=10，hdfs.roundUnit= second几个参数综合作用，效果如下：</p> 
<p style="margin-left:0;text-align:justify;">（1）tmp文件在达到128M时会滚动生成正式文件</p> 
<p style="margin-left:0;text-align:justify;">（2）tmp文件创建超10分时会滚动生成正式文件</p> 
<p style="margin-left:0;"><span style="color:#000000;">举例：在2018-01-01 05:23的时侯sink接收到数据，那会产生如下tmp文件：</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">/itcast/20180101/itcast.201801010520.tmp</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">即使文件内容没有达到128M，也会在05:33时滚动生成正式文件</span></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725191"></a><a name="_Toc11175"></a><a name="_Toc66809635"> Kafka</a>相关总结</strong></span></span> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc4348"></a><a name="_Toc10725192"></a><a name="_Toc66809636"><strong>Kafka</strong></a><strong>架构</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc1221"></a><a name="_Toc10725193"></a><a name="_Toc66809637"><strong>Kafka</strong></a><strong>压测</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Kafka官方自带压力测试脚本（kafka-consumer-perf-test.sh、kafka-producer-perf-test.sh）。Kafka压测时，可以查看到哪个地方出现了瓶颈（CPU，内存，网络IO）。一般都是网络IO达到瓶颈。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc22079"></a><a name="_Toc10725194"></a><a name="_Toc66809638"><strong>Kafka</strong></a><strong>的机器数量</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Kafka机器数量=2*（峰值生产速度*副本数/100）+1</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc21180"></a><a name="_Toc10725195"></a><a name="_Toc66809639"><strong>Kafka</strong></a><strong>的日志保存时间</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">7天</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725196"></a><a name="_Toc25654"></a><a name="_Toc66809640"><strong>Kafka</strong></a><strong>的硬盘大小</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">每天的数据量*7天</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc19944"></a><a name="_Toc10725197"></a><a name="_Toc66809641"><strong>Kafka</strong></a><strong>监控</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">公司自己开发的监控器；</p> 
<p style="margin-left:0;text-align:justify;">开源的监控器：KafkaManager、KafkaMonitor</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc23970"></a><a name="_Toc10725198"></a><a name="_Toc66809642"><strong>Kakfa</strong></a><strong>分区数</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">分区数并不是越多越好，一般分区数不要超过集群机器数量。分区数越多占用内存越大（ISR等），一个节点集中的分区也就越多，当它宕机的时候，对系统的影响也就越大。</p> 
<p style="margin-left:0;text-align:justify;">分区数一般设置为：3-10个</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc4724"></a><a name="_Toc10725199"></a><a name="_Toc66809643"><strong>副本数设定</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">一般我们设置成2个或3个，很多企业设置为2个。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10414"></a><a name="_Toc10725200"></a><a name="_Toc66809644"><strong>多少个Topic</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">通常情况：多少个日志类型就多少个Topic。也有对日志类型进行合并的。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725201"></a><a name="_Toc26083"></a><a name="_Toc66809645"><strong>Kafka</strong></a><strong>丢不丢数据</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Ack=0，相当于异步发送，消息发送完毕即offset增加，继续生产。</p> 
<p style="margin-left:0;text-align:justify;">Ack=1，leader收到leader replica 对一个消息的接受ack才增加offset，然后继续生产。</p> 
<p style="margin-left:0;text-align:justify;">Ack=-1，leader收到所有replica 对一个消息的接受ack才增加offset，然后继续生产。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725202"></a><a name="_Toc5320"></a><a name="_Toc66809646"><strong>Kafka</strong></a><strong>的ISR副本同步队列</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">ISR（In-Sync Replicas），副本同步队列。ISR中包括Leader和Follower。如果Leader进程挂掉，会在ISR队列中选择一个服务作为新的Leader。有replica.lag.max.messages（延迟条数）和replica.lag.time.max.ms（延迟时间）两个参数决定一台服务是否可以加入ISR副本队列，在0.10版本移除了replica.lag.max.messages参数，防止服务频繁的进去队列。</p> 
<p style="margin-left:0;text-align:justify;">任意一个维度超过阈值都会把Follower剔除出ISR，存入OSR（Outof-Sync Replicas）列表，新加入的Follower也会先存放在OSR中。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc1130"></a><a name="_Toc10725204"></a><a name="_Toc66809647"><strong>Kafka</strong></a><strong>中数据量计算</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">每天总数据量100g，每天产生1亿条日志， 10000万/24/60/60=1150条/每秒钟</p> 
<p style="margin-left:0;text-align:justify;">平均每秒钟：1150条</p> 
<p style="margin-left:0;text-align:justify;">低谷每秒钟：400条</p> 
<p style="margin-left:0;text-align:justify;">高峰每秒钟：1150条*（2-20倍）=2300条-&gt;23000条</p> 
<p style="margin-left:0;text-align:justify;">每条日志大小：0.5k-2k</p> 
<p style="margin-left:0;text-align:justify;">每秒多少数据量：2.3M-20MB</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc30706"></a><a name="_Toc10725205"></a><a name="_Toc66809648"><strong>Kafka</strong></a><strong>挂掉</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">Flume记录</li><li style="text-align:justify;">日志有记录</li><li style="text-align:justify;">短期没事 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc25104"></a><a name="_Toc10725206"></a><a name="_Toc66809649"><strong>Kafka</strong></a><strong>消息数据积压，Kafka消费能力不足怎么处理？</strong><strong> </strong></span></span></li></ol></li></ol></li></ol> 
<ol><li style="text-align:justify;">如果是Kafka消费能力不足，则可以考虑增加Topic的分区数，并且同时提升消费组的消费者数量，消费者数=分区数。（两者缺一不可）</li><li style="text-align:justify;">如果是下游的数据处理不及时：提高每批次拉取的数量。批次拉取数据过少（拉取数据/处理时间&lt;生产速度），使处理的数据小于生产的数据，也会造成数据积压。 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809650"><strong>Kafka</strong></a><strong>的再平衡机制</strong></span></span> 
      <ol><li style="text-align:justify;"><strong>什么是再平衡</strong></li></ol></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">所谓的再平衡，指的是在kafka consumer所订阅的topic发生变化时发生的一种分区重分配机制。一般有三种情况会触发再平衡：</p> 
<ol><li style="text-align:justify;">consumer group中的新增或删除某个consumer，导致其所消费的分区需要分配到组内其他的consumer上；</li><li style="text-align:justify;">consumer订阅的topic发生变化，比如订阅的topic采用的是正则表达式的形式，如test-*此时如果有一个新建了一个topic test-user，那么这个topic的所有分区也是会自动分配给当前的consumer的，此时就会发生再平衡；</li><li style="text-align:justify;">consumer所订阅的topic发生了新增分区的行为，那么新增的分区就会分配给当前的consumer，此时就会触发再平衡。</li></ol> 
<p style="margin-left:0;text-align:justify;">Kafka提供的再平衡策略主要有三种：Round Robin，Range和Sticky，默认使用Range。这三种分配策略的主要区别在于：</p> 
<ol><li style="text-align:justify;">Round Robin：会采用轮询的方式将当前所有的分区依次分配给所有的consumer；</li><li style="text-align:justify;">Range：首先会计算每个consumer可以消费的分区个数，然后按照顺序将指定个数范围的分区分配给各个consumer；</li><li style="text-align:justify;">Sticky：这种分区策略是最新版本中新增的一种策略，其主要实现了两个目的： 
  <ol><li style="text-align:justify;">将现有的分区尽可能均衡的分配给各个consumer，存在此目的的原因在于Round Robin和Range分配策略实际上都会导致某几个consumer承载过多的分区，从而导致消费压力不均衡；</li><li style="text-align:justify;">如果发生再平衡，那么在重新分配前的基础上会尽力保证当前未宕机的consumer所消费的分区不会被分配给其他的consumer上；</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">本文主要会通过几个示例来对上面讲解的三种分区重分配策略的基本实现原理进行讲解。</p> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li> 
      <ol><li style="text-align:justify;"><strong>Round Robin</strong></li></ol></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">关于Round Robin重分配策略，其主要采用的是一种轮询的方式分配所有的分区，该策略主要实现的步骤如下。这里我们首先假设有三个topic：t0、t1和t2，这三个topic拥有的分区数分别为1、2和3，那么总共有六个分区，这六个分区分别为：t0-0、t1-0、t1-1、t2-0、t2-1和t2-2。这里假设我们有三个consumer：C0、C1和C2，它们订阅情况为：C0订阅t0，C1订阅t0和t1，C2订阅t0、t1和t2。那么这些分区的分配步骤如下：</p> 
<ol><li style="text-align:justify;">首先将所有的partition和consumer按照字典序进行排序，所谓的字典序，就是按照其名称的字符串顺序，那么上面的六个分区和三个consumer排序之后分别为：</li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;">然后依次以按顺序轮询的方式将这六个分区分配给三个consumer，如果当前consumer没有订阅当前分区所在的topic，则轮询的判断下一个consumer：</li></ol> 
<ol><li style="text-align:justify;">尝试将t0-0分配给C0，由于C0订阅了t0，因而可以分配成功；</li><li style="text-align:justify;">尝试将t1-0分配给C1，由于C1订阅了t1，因而可以分配成功；</li><li style="text-align:justify;">尝试将t1-1分配给C2，由于C2订阅了t1，因而可以分配成功；</li><li style="text-align:justify;">尝试将t2-0分配给C0，由于C0没有订阅t2，因而会轮询下一个consumer；</li><li style="text-align:justify;">尝试将t2-0分配给C1，由于C1没有订阅t2，因而会轮询下一个consumer；</li><li style="text-align:justify;">尝试将t2-0分配给C2，由于C2订阅了t2，因而可以分配成功；</li><li style="text-align:justify;">同理由于t2-1和t2-2所在的topic都没有被C0和C1所订阅，因而都不会分配成功，最终都会分配给C2。</li></ol> 
<p style="margin-left:0;text-align:justify;">按照上述的步骤将所有的分区都分配完毕之后，最终分区的订阅情况如下：</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">从上面的步骤分析可以看出，轮询的策略就是简单的将所有的partition和consumer按照字典序进行排序之后，然后依次将partition分配给各个consumer，如果当前的consumer没有订阅当前的partition，那么就会轮询下一个consumer，直至最终将所有的分区都分配完毕。但是从上面的分配结果可以看出，轮询的方式会导致每个consumer所承载的分区数量不一致，从而导致各个consumer压力不均一。</p> 
<ol><li> 
  <ol><li> 
    <ol><li> 
      <ol><li style="text-align:justify;"><strong>Range（默认策略）</strong></li></ol></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">所谓的Range重分配策略，就是首先会计算各个consumer将会承载的分区数量，然后将指定数量的分区分配给该consumer。这里我们假设有两个consumer：C0和C1，两个topic：t0和t1，这两个topic分别都有三个分区，那么总共的分区有六个：t0-0、t0-1、t0-2、t1-0、t1-1和t1-2。那么Range分配策略将会按照如下步骤进行分区的分配：</p> 
<ol><li style="text-align:justify;">需要注意的是，Range策略是按照topic依次进行分配的，比如我们以t0进行讲解，其首先会获取t0的所有分区：t0-0、t0-1和t0-2，以及所有订阅了该topic的consumer：C0和C1，并且会将这些分区和consumer按照字典序进行排序；</li><li style="text-align:justify;">然后按照平均分配的方式计算每个consumer会得到多少个分区，如果没有除尽，则会将多出来的分区依次计算到前面几个consumer。比如这里是三个分区和两个consumer，那么每个consumer至少会得到1个分区，而3除以2后还余1，那么就会将多余的部分依次算到前面几个consumer，也就是这里的1会分配给第一个consumer，总结来说，那么C0将会从第0个分区开始，分配2个分区，而C1将会从第2个分区开始，分配1个分区；</li><li style="text-align:justify;">同理，按照上面的步骤依次进行后面的topic的分配。</li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">最终上面六个分区的分配情况如下：</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">可以看到，如果按照Range分区方式进行分配，其本质上是依次遍历每个topic，然后将这些topic的分区按照其所订阅的consumer数量进行平均的范围分配。这种方式从计算原理上就会导致排序在前面的consumer分配到更多的分区，从而导致各个consumer的压力不均衡。</p> 
<ol><li> 
  <ol><li> 
    <ol><li> 
      <ol><li style="text-align:justify;"><strong>Sticky</strong></li></ol></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Sticky策略是新版本中新增的策略，顾名思义，这种策略会保证再分配时已经分配过的分区尽量保证其能够继续由当前正在消费的consumer继续消费，当然，前提是每个consumer所分配的分区数量都大致相同，这样能够保证每个consumer消费压力比较均衡。关于这种分配方式的分配策略，我们分两种情况进行讲解，即初始状态的分配和某个consumer宕机时的分配情况。</p> 
<ol><li> 
  <ol><li> 
    <ol><li> 
      <ol><li> 
        <ol><li style="text-align:justify;"><strong>初始分配</strong></li></ol></li></ol></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">初始状态分配的特点是，所有的分区都还未分配到任意一个consumer上。这里我们假设有三个consumer：C0、C1和C2，三个topic：t0、t1和t2，这三个topic分别有1、2和3个分区，那么总共的分区为：t0-0、t1-0、t1-1、t2-0、t2-1和t2-2。关于订阅情况，这里C0订阅了t0，C1订阅了t0和1，C2则订阅了t0、t1和t2。这里的分区分配规则如下：</p> 
<ol><li style="text-align:justify;">首先将所有的分区进行排序，排序方式为：首先按照当前分区所分配的consumer数量从低到高进行排序，如果consumer数量相同，则按照分区的字典序进行排序。这里六个分区由于所在的topic的订阅情况各不相同，因而其排序结果如下：</li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;">然后将所有的consumer进行排序，其排序方式为：首先按照当前consumer已经分配的分区数量有小到大排序，如果两个consumer分配的分区数量相同，则会按照其名称的字典序进行排序。由于初始时，这三个consumer都没有分配任何分区，因而其排序结果即为其按照字典序进行排序的结果：</li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;">然后将各个分区依次遍历分配给各个consumer，首先需要注意的是，这里的遍历并不是C0分配完了再分配给C1，而是每次分配分区的时候都整个的对所有的consumer从头开始遍历分配，如果当前consumer没有订阅当前分区，则会遍历下一个consumer。然后需要注意的是，在整个分配的过程中，各个consumer所分配的分区数是动态变化的，而这种变化是会体现在各个consumer的排序上的，比如初始时C0是排在第一个的，此时如果分配了一个分区给C0，那么C0就会排到最后，因为其拥有的分区数是最多的。上面的六个分区整体的分配流程如下： 
  <ol><li style="text-align:justify;">首先将t2-0尝试分配给C0，由于C0没有订阅t2，因而分配不成功，继续轮询下一个consumer；</li><li style="text-align:justify;">然后将t2-0尝试分配给C1，由于C1没有订阅t2，因而分配不成功，继续轮询下一个consumer；</li><li style="text-align:justify;">接着将t2-0尝试分配给C2，由于C2订阅了t2，因而分配成功，此时由于C2分配的分区数发生变化，各个consumer变更后的排序结果为：</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li style="text-align:justify;">接下来的t2-1和t2-2，由于也只有C2订阅了t2，因而其最终还是会分配给C2，最终在t2-0、t2-1和t2-2分配完之后，各个consumer的排序以及其分区分配情况如下：</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li style="text-align:justify;">接着继续分配t1-0，首先尝试将其分配给C0，由于C0没有订阅t1，因而分配不成功，继续轮询下一个consumer；</li><li style="text-align:justify;">然后尝试将t1-0分配给C1，由于C1订阅了t1，因而分配成功，此时各个consumer以及其分配的分区情况如下：</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li style="text-align:justify;">同理，接下来会分配t1-1，虽然C1和C2都订阅了t1，但是由于C1排在C2前面，因而该分区会分配给C1，即：</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li style="text-align:justify;">最后，尝试将t0-0分配给C0，由于C0订阅了t0，因而分配成功，最终的分配结果为：</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">上面的分配过程中，需要始终注意的是，虽然示例中的consumer顺序始终没有变化，但这是由于各个分区分配之后正好每个consumer所分配的分区数量的排序结果与初始状态一致。这里读者也可以比较一下这种分配方式与前面讲解的Round Robin进行对比，可以很明显的发现，Sticky重分配策略分配得更加均匀一些。</p> 
<ol><li> 
  <ol><li> 
    <ol><li> 
      <ol><li> 
        <ol><li style="text-align:justify;"><strong>模拟consumer宕机</strong></li></ol></li></ol></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">由于前一个示例中最终的分区分配方式模拟宕机的情形比较简单，因而我们使用另一种订阅策略。这里我们的示例的consumer有三个：C0、C1和C2，topic有四个：t0、t1、t2和t3，每个topic都有两个分区，那么总的分区有：t0-0、t0-1、t1-0、t1-1、t2-0、t2-1、t3-0和t3-1。这里的订阅情况为三个consumer订阅所有的主题，那么如果按照Sticky的分区分配策略，初始状态时，分配情况如下，读者可以按照前一示例讲解的方式进行推算：</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">这里我们假设在消费的过程中，C1发生了宕机，此时就会发生再平衡，而根据Sticky策略，其再分配步骤如下：</p> 
<ol><li style="text-align:justify;">首先会将宕机之后未分配的分区进行排序，排序方式为：首先按照分区所拥有的consumer数量从低到高进行排序，如果consumer数量相同，则按照分区的字典序进行排序。这里需要注意的是，由于只有C1宕机，因而未分配的分区为：t0-1、t2-0和t3-1，排序之后的结果为：</li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;">然后将所有的consumer进行排序，排序方式为：首先将consumer按照其所拥有的consumer数量从小到大排序，如果数量相同，则按照consumer名称的字典序进行排序，排序结果如下：</li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;">接着依次遍历各个分区，将其分配给各个consumer，需要注意的是，在分配的过程中，consumer所分配的分区数量是在变化的，而这种变化是会反应在consumer的排序上的： 
  <ol><li style="text-align:justify;">首先尝试将t0-1分配给C2，由于C2订阅了t0，因而可以分配成功，此时consumer排序和分区分配情况如下，需要注意的是，虽然分配之后，C2和C0的分区数量相同，但是由于按照字典序，C0在C2前面，因而排序情况还是会发生变化：</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li style="text-align:justify;">然后尝试将t2-0分配给C0，由于C0订阅了t2，因而分配可以成功，此时consumer排序和分区分配情况如下：</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li style="text-align:justify;">最后尝试分配t3-1给C2，由于C2订阅了t3，因而分配可以成功，此时consumer排序与分区分配情况如下：</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">在上面的分区分配过程中，我们可以看到，由于分区的不断分配，各个consumer所拥有的分区数量也在不断变化，因而其排序情况也在变化，但是最终可以看到，各个分区是均匀的分配到各个consumer的，并且还保证了当前consumer已经消费的分区是不会分配到其他的consumer上的。</p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725207"></a><a name="_Toc5637"></a><a name="_Toc66809651"> Hive</a>相关总结</strong></span></span> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc8680"></a><a name="_Toc10725208"></a><a name="_Toc66809652"><strong>Hive</strong></a><strong>的架构</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">  </span></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725209"></a><a name="_Toc19180"></a><a name="_Toc66809653"><strong>Hive</strong></a><strong>和数据库比较</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Hive 和数据库除了拥有类似的查询语言，再无类似之处。</p> 
<ol><li style="text-align:justify;">数据存储位置</li></ol> 
<p style="margin-left:0;text-align:justify;">Hive存储在HDFS。数据库将数据保存在块设备或者本地文件系统中。</p> 
<ol><li style="text-align:justify;">数据更新</li></ol> 
<p style="margin-left:0;text-align:justify;">Hive中不建议对数据的改写。而数据库中的数据通常是需要经常进行修改的，</p> 
<ol><li style="text-align:justify;">执行延迟</li></ol> 
<p style="margin-left:0;text-align:justify;">Hive执行延迟较高。数据库的执行延迟较低。当然，这个是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive的并行计算显然能体现出优势。</p> 
<ol><li style="text-align:justify;">数据规模</li></ol> 
<p style="margin-left:0;text-align:justify;">Hive支持很大规模的数据计算；数据库可以支持的数据规模较小。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc24067"></a><a name="_Toc10725210"></a><a name="_Toc66809654"><strong>内部表和外部表</strong></a></span></span></li></ol></li></ol></li><li style="text-align:justify;">内部表：当我们删除一个内部表时，Hive也会删除这个表中数据。内部表不适合和其他工具共享数据。</li><li style="text-align:justify;">外部表：删除该表并不会删除掉原始数据，删除的是表的元数据 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725211"></a><a name="_Toc24007"></a><a name="_Toc66809655"><strong>4</strong></a><strong>个By区别</strong></span></span></li></ol></li></ol></li></ol> 
<ol><li style="text-align:justify;">Sort By：分区内有序；</li><li style="text-align:justify;">Order By：全局排序，只有一个Reducer；</li><li style="text-align:justify;">Distrbute By：类似MR中Partition，进行分区，结合sort by使用。</li><li style="text-align:justify;">Cluster By：当Distribute by和Sorts by字段相同时，可以使用Cluster by方式。Cluster by除了具有Distribute by的功能外还兼具Sort by的功能。但是排序只能是升序排序，不能指定排序规则为ASC或者DESC。 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725212"></a><a name="_Toc18027"></a><a name="_Toc66809656"><strong>窗口函数</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">RANK() 排序相同时会重复，总数不会变</p> 
<p style="margin-left:0;text-align:justify;">DENSE_RANK() 排序相同时会重复，总数会减少</p> 
<p style="margin-left:0;text-align:justify;">ROW_NUMBER() 会根据顺序计算</p> 
<ol><li style="text-align:justify;">OVER()：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变而变化</li><li style="text-align:justify;">CURRENT ROW：当前行</li><li style="text-align:justify;">n PRECEDING：往前n行数据</li><li style="text-align:justify;">n FOLLOWING：往后n行数据</li><li style="text-align:justify;">UNBOUNDED：起点，UNBOUNDED PRECEDING 表示从前面的起点， UNBOUNDED FOLLOWING表示到后面的终点</li><li style="text-align:justify;">LAG(col,n)：往前第n行数据</li><li style="text-align:justify;">LEAD(col,n)：往后第n行数据</li><li style="text-align:justify;">NTILE(n)：把有序分区中的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，NTILE返回此行所属的组的编号。注意：n必须为int类型。 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725213"></a><a name="_Toc21477"></a><a name="_Toc66809657">自定义UDF、UDTF</a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">在项目中是否自定义过UDF、UDTF函数，以及用他们处理了什么问题，及自定义步骤？</p> 
<ol><li style="text-align:justify;">自定义过。</li><li style="text-align:justify;">用UDF函数解析公共字段；用UDTF函数解析事件字段。</li></ol> 
<p style="margin-left:0;text-align:justify;">自定义UDF：继承UDF，重写evaluate方法</p> 
<p style="margin-left:0;text-align:justify;">自定义UDTF：继承自GenericUDTF，重写3个方法：initialize(自定义输出的列名和类型)，process（将结果返回forward(result)），close</p> 
<p style="margin-left:0;text-align:justify;">为什么要自定义UDF/UDTF，因为自定义函数，可以自己埋点Log打印日志，出错或者数据异常，方便调试.</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc4421"></a><a name="_Toc10725214"></a><a name="_Toc66809658">Hive</a>优化</span></span></li></ol></li></ol></li><li style="text-align:justify;">MapJoin</li></ol> 
<p style="margin-left:0;text-align:justify;">如果不指定MapJoin或者不符合MapJoin的条件，那么Hive解析器会将Join操作转换成Common Join，即：在Reduce阶段完成join。容易发生数据倾斜。可以用MapJoin把小表全部加载到内存在map端进行join，避免reducer处理。</p> 
<ol><li style="text-align:justify;">行列过滤</li></ol> 
<p style="margin-left:0;text-align:justify;">列处理：在SELECT中，只拿需要的列，如果有，尽量使用分区过滤，少用SELECT *。</p> 
<p style="margin-left:0;text-align:justify;">行处理：在分区剪裁中，当使用外关联时，如果将副表的过滤条件写在Where后面，那么就会先全表关联，之后再过滤。</p> 
<ol><li style="text-align:justify;">采用分桶技术</li><li style="text-align:justify;">采用分区技术</li><li style="text-align:justify;"><a name="_Toc374199304">合理设置Map数</a> 
  <ol><li style="text-align:justify;">通常情况下，作业会通过input的目录产生一个或者多个map任务。</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">主要的决定因素有：input的文件总个数，input的文件大小，集群设置的文件块大小。</p> 
<ol><li> 
  <ol><li style="text-align:justify;">是不是map数越多越好？</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">答案是否定的。如果一个任务有很多小文件（远远小于块大小128m），则每个小文件也会被当做一个块，用一个map任务来完成，而一个map任务启动和初始化的时间远远大于逻辑处理的时间，就会造成很大的资源浪费。而且，同时可执行的map数是受限的。</p> 
<ol><li> 
  <ol><li style="text-align:justify;">是不是保证每个map处理接近128m的文件块，就高枕无忧了？</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">答案也是不一定。比如有一个127m的文件，正常会用一个map去完成，但这个文件只有一个或者两个小字段，却有几千万的记录，如果map处理的逻辑比较复杂，用一个map任务去做，肯定也比较耗时。</p> 
<p style="margin-left:0;text-align:justify;">针对上面的问题2和3，我们需要采取两种方式来解决：即减少map数和增加map数；</p> 
<ol><li style="text-align:justify;">小文件进行合并</li></ol> 
<p style="margin-left:0;text-align:justify;">在Map执行前合并小文件，减少Map数：CombineHiveInputFormat具有对小文件进行合并的功能（系统默认的格式）。HiveInputFormat没有对小文件合并功能。</p> 
<ol><li style="text-align:justify;">合理设置Reduce数</li></ol> 
<p style="margin-left:0;text-align:justify;">Reduce个数并不是越多越好</p> 
<ol><li> 
  <ol><li style="text-align:justify;">过多的启动和初始化Reduce也会消耗时间和资源；</li><li style="text-align:justify;">另外，有多少个Reduce，就会有多少个输出文件，如果生成了很多个小文件，那么如果这些小文件作为下一个任务的输入，则也会出现小文件过多的问题；</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">在设置Reduce个数的时候也需要考虑这两个原则：处理大数据量利用合适的Reduce数；使单个Reduce任务处理数据量大小要合适；</p> 
<ol><li style="text-align:justify;">常用参数</li></ol> 
<p style="margin-left:0;text-align:justify;">// 输出合并小文件</p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">SET hive.merge.mapfiles = true; -- </span><span style="color:#000000;">默认true，在map-only任务结束时合并小文件</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">SET hive.merge.mapredfiles = true; -- </span><span style="color:#000000;">默认false，在map-reduce任务结束时合并小文件</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">SET hive.merge.size.per.task = 268435456; -- </span><span style="color:#000000;">默认256M</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">SET hive.merge.smallfiles.avgsize = 16777216; -- </span><span style="color:#000000;">当输出文件的平均大小小于该值时，启动一个独立的map-reduce任务进行文件merge</span></span></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc1127"></a><a name="_Toc10725215"></a><a name="_Toc66809659"> HBase</a>相关总结</strong></span></span> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc21293"></a><a name="_Toc10725216"></a><a name="_Toc66809660"><strong>HBase</strong></a><strong>存储结构</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc421124243"></a><a name="_Toc66809661"><strong>读流程</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;">Client先访问zookeeper，从meta表读取region的位置，然后读取meta表中的数据。meta中又存储了用户表的region信息；</li><li style="text-align:justify;">根据namespace、表名和rowkey在meta表中找到对应的region信息；</li><li style="text-align:justify;">找到这个region对应的regionserver；</li><li style="text-align:justify;">查找对应的region；</li><li style="text-align:justify;">先从MemStore找数据，如果没有，再到BlockCache里面读；</li><li style="text-align:justify;">BlockCache还没有，再到StoreFile上读(为了读取的效率)；</li><li style="text-align:justify;">如果是从StoreFile里面读取的数据，不是直接返回给客户端，而是先写入BlockCache，再返回给客户端。 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc421124241"></a><a name="_Toc66809662"><strong>写流程</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:center;">图2  HBase写数据流程</p> 
<ol><li style="text-align:justify;">Client向HregionServer发送写请求；</li><li style="text-align:justify;">HRegionServer将数据写到HLog（write ahead log）。为了数据的持久化和恢复；</li><li style="text-align:justify;">HRegionServer将数据写到内存（MemStore）；</li><li style="text-align:justify;">反馈Client写成功。 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc421124242"></a><a name="_Toc66809663"><strong>数据flush过程</strong></a></span></span></li></ol></li></ol></li></ol> 
<ol><li style="text-align:justify;">当MemStore数据达到阈值（默认是128M，老版本是64M），将数据刷到硬盘，将内存中的数据删除，同时删除HLog中的历史数据；</li><li style="text-align:justify;">并将数据存储到HDFS中；</li><li style="text-align:justify;">在HLog中做标记点。 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809664"><strong>数据合并过程</strong></a></span></span></li></ol></li></ol></li></ol> 
<ol><li style="text-align:justify;">当数据块达到3块，Hmaster触发合并操作，Region将数据块加载到本地，进行合并；</li><li style="text-align:justify;">当合并的数据超过256M，进行拆分，将拆分后的Region分配给不同的HregionServer管理；</li><li style="text-align:justify;">当HregionServer宕机后，将HregionServer上的hlog拆分，然后分配给不同的HregionServer加载，修改.META.；</li><li style="text-align:justify;">注意：HLog会同步到HDFS。<a name="_Toc421124244"></a> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809665"><strong>hbase-default.xml</strong></a><strong>中相关参数</strong></span></span></li></ol></li></ol></li></ol> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;"><span style="color:#000000;">Flush:</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;!--</span><span style="color:#000000;">当memstore的大小超过这个值的时候，会flush到磁盘。128M--&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;property&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">            &lt;name&gt;hbase.hregion.memstore.flush.size&lt;/name&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">            &lt;value&gt;134217728&lt;/value&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;/property&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;!--</span><span style="color:#000000;">单个regionserver的全部memstore的最大值。超过这个值总容量(Max Heap=983.4 M)*0.4，</span></p> <p style="margin-left:0;">      <span style="color:#000000;">一个新的put插入操作会被挂起，强制执行flush操作。 --&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;property&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">            &lt;name&gt;hbase.regionserver.global.memstore.upperLimit&lt;/name&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">            &lt;value&gt;0.4&lt;/value&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;/property&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;!--</span><span style="color:#000000;">当强制执行flush操作的时候，当低于这个值的时候，flush会停止。默认是堆大小的 35% . --&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;property&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">            &lt;name&gt;hbase.regionserver.global.memstore.lowerLimit&lt;/name&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">            &lt;value&gt;0.35&lt;/value&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;/property&gt;</span></p> <p style="margin-left:0;"></p> <p style="margin-left:0;"><span style="color:#000000;">Compact:</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;!--</span><span style="color:#000000;">当一个HStore含有多于这个值的HStoreFiles(每一个memstore flush产生一个HStoreFile)的时候，会执行一个合并操作，把这HStoreFiles写成一个--&gt;   </span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;property&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">            &lt;name&gt;hbase.hstore.compactionThreshold&lt;/name&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">            &lt;value&gt;3&lt;/value&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;/property&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;!--</span><span style="color:#000000;">一个Region中的所有HStoreFile的major compactions的时间间隔。默认是1天。--&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;property&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">            &lt;name&gt;hbase.hregion.majorcompaction&lt;/name&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">            &lt;value&gt;86400000&lt;/value&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;/property&gt;</span></p> <p style="margin-left:0;"></p> <p style="margin-left:0;"><span style="color:#000000;">Split:</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;!--</span><span style="color:#000000;">最大HStoreFile大小。若某个列族的HStoreFile增长达到这个值，这个Hegion会被切割成两个。 默认: 10G.--&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;property&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">            &lt;name&gt;hbase.hregion.max.filesize&lt;/name&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">            &lt;value&gt;10737418240&lt;/value&gt;</span></p> <p style="margin-left:0;"><span style="color:#000000;">      &lt;/property&gt;</span></p> </td></tr></tbody></table> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725217"></a><a name="_Toc12426"></a><a name="_Toc66809666"><strong>rowkey</strong></a><strong>设计原则</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">rowkey长度原则（Rowkey的长度被很多开发者建议说设计在10~100个字节，不过建议是越短越好，不要超过16个字节）</li><li style="text-align:justify;">rowkey散列原则</li><li style="text-align:justify;">rowkey唯一原则 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc13523"></a><a name="_Toc10725218"></a><a name="_Toc66809667"><strong>RowKey</strong></a><strong>如何设计</strong></span></span></li></ol></li></ol></li></ol> 
<ol><li style="text-align:justify;">生成随机数、hash、散列值</li><li style="text-align:justify;">字符串反转</li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725220"></a><a name="_Toc6842"></a><a name="_Toc66809668"> Sqoop</a>参数</strong></span></span></li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">/opt/module/sqoop/bin/sqoop import \</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">--connect \</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">--username \</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">--password \</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">--target-dir \</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">--delete-target-dir \</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">--num-mappers \</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">--fields-terminated-by   \</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">--query   "$2" ' and $CONDITIONS;'</span></span></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725221"></a><a name="_Toc21356"></a><a name="_Toc66809669"><strong>Sqoop</strong></a><strong>导入导出Null存储一致性问题</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Hive中的Null在底层是以“\N”来存储，而MySQL中的Null在底层就是Null，为了保证数据两端的一致性。在导出数据时采用--input-null-string和--input-null-non-string两个参数。导入数据时采用--null-string和--null-non-string。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc21974"></a><a name="_Toc10725222"></a><a name="_Toc66809670"><strong>Sqoop</strong></a><strong>数据导出一致性问题</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">1）场景1：如Sqoop在导出到Mysql时，使用4个Map任务，过程中有2个任务失败，那此时MySQL中存储了另外两个Map任务导入的数据，此时老板正好看到了这个报表数据。而开发工程师发现任务失败后，会调试问题并最终将全部数据正确的导入MySQL，那后面老板再次看报表数据，发现本次看到的数据与之前的不一致，这在生产环境是不允许的。</p> 
<p style="margin-left:0;text-align:justify;">官网：http://sqoop.apache.org/docs/1.4.6/SqoopUserGuide.html</p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">Since Sqoop breaks down export process into multiple transactions, it is possible that a failed export job may result in partial data being committed to the database. This can further lead to subsequent jobs failing due to insert collisions in some cases, or lead to duplicated data in others. You can overcome this problem by specifying a staging table via the --staging-table option which acts as an auxiliary table that is used to stage exported data. The staged data is finally moved to the destination table in a single transaction.</span></span></p> 
<p style="margin-left:0;text-align:justify;">–staging-table方式</p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">sqoop export --connect jdbc:mysql://192.168.137.10:3306/user_behavior --username root --password 123456 --table app_cource_study_report --columns watch_video_cnt,complete_video_cnt,dt --fields-terminated-by "\t" --export-dir "/user/hive/warehouse/tmp.db/app_cource_study_analysis_${day}" --staging-table app_cource_study_report_tmp --clear-staging-table --input-null-string '\N'</span></span></p> 
<p style="margin-left:0;text-align:justify;">2）场景2：设置map数量为1个（不推荐，面试官想要的答案不只这个）</p> 
<p style="margin-left:0;text-align:justify;">多个Map任务时，采用–staging-table方式，仍然可以解决数据一致性问题。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725223"></a><a name="_Toc17353"></a><a name="_Toc66809671"><strong>Sqoop</strong></a><strong>底层运行的任务是什么</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">只有Map阶段，没有Reduce阶段的任务。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc27207"></a><a name="_Toc10725224"></a><a name="_Toc66809672"><strong>Sqoop</strong></a><strong>数据导出的时候一次执行多长时间</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Sqoop任务5分钟-2个小时的都有。取决于数据量。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809673"></a><a name="_Toc30202"></a><a name="_Toc10725225"> Scala</a>相关总结</strong></span></span> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725226"></a><a name="_Toc9420"></a><a name="_Toc66809674"><strong>元组</strong></a></span></span></li></ol></li></ol></li></ol> 
<ol><li style="text-align:justify;">元组的创建</li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">val tuple1 = (1, 2, 3, "heiheihei")</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">println(tuple1)</span></span></p> 
<ol><li style="text-align:justify;">元组数据的访问，注意元组元素的访问有下划线，并且访问下标从1开始，而不是0</li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">val value1 = tuple1._4</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">println(value1)</span></span></p> 
<ol><li style="text-align:justify;">元组的遍历</li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">方式1：</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">for (elem &lt;- tuple1.productIterator  ) {<!-- --></span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">   print(elem)</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">}</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">println()</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">方式2：</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">tuple1.productIterator.foreach(i =&gt; println(i))</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">tuple1.produIterator.foreach(print(_))</span></span></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc29771"></a><a name="_Toc10725227"></a><a name="_Toc66809675"><strong>隐式转换</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">隐式转换函数是以implicit关键字声明的带有单个参数的函数。这种函数将会自动应用，将值从一种类型转换为另一种类型。</p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">implicit def a(d: Double) = d.toInt</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">//</span><span style="color:#000000;">不加上边这句你试试</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">val i1: Int = 3.5</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">println(i1)</span></span></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc15579"></a><a name="_Toc10725228"></a><a name="_Toc66809676"><strong>函数式编程理解</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">1）Scala中函数的地位：一等公民 <br> 2） Scala中的匿名函数(函数字面量) <br> 3）Scala中的高阶函数 <br> 4）Scala中的闭包 <br> 5）Scala中的部分应用函数 <br> 6）Scala中的柯里化函数</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725229"></a><a name="_Toc7474"></a><a name="_Toc66809677"><strong>样例类</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">case class Person(name:String,age:Int)</p> 
<p style="margin-left:0;text-align:justify;">一般使用在 ds=df.as[Person]</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725230"></a><a name="_Toc28812"></a><a name="_Toc66809678"><strong>柯里化</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">函数编程中，接受多个参数的函数都可以转化为接受单个参数的函数，这个转化过程就叫柯里化，柯里化就是证明了函数只需要一个参数而已。其实我们刚的学习过程中，已经涉及到了柯里化操作，所以这也印证了，柯里化就是以函数为主体这种思想发展的必然产生的结果。</p> 
<p style="margin-left:0;">1）柯里化的示例</p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">def mul(x: Int, y: Int) = x * y</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">println(mul(10, 10))</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">def mulCurry(x: Int) = (y: Int) =&gt; x * y</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">println(mulCurry(10)(9))</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">def mulCurry2(x: Int)(y:Int) = x * y</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">println(mulCurry2(10)(8))</span></span></p> 
<p style="margin-left:0;">2）柯里化的应用</p> 
<p style="margin-left:0;text-align:justify;">比较两个字符串在忽略大小写的情况下是否相等，注意，这里是两个任务：</p> 
<ul><li style="text-align:justify;">全部转大写（或小写）</li><li style="text-align:justify;">比较是否相等</li></ul> 
<p style="margin-left:0;">针对这两个操作，我们用一个函数去处理的思想，其实无意间也变成了两个函数处理的思想。示例如下：</p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">val a = Array("Hello", "World")</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">val b = Array("hello", "world")</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">println(a.corresponds(b)(_.equalsIgnoreCase(_)))</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">其中corresponds函数的源码如下：</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">def corresponds[B](that: GenSeq[B])(p: (A,B) =&gt; Boolean): Boolean = {<!-- --></span></span></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">val i = this.iterator</span></span></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">val j = that.iterator</span></span></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">while (i.hasNext &amp;&amp; j.hasNex  t)</span></span></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">  if (!p(i.next(), j.next()    ))</span></span></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">    return fals</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">!i.hasNext &amp;&amp; !j.hasNext</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">}</span></span></p> 
<p style="margin-left:0;">尖叫提示：不要设立柯里化存在义这样的命题，柯里化，是面向函数思想的必然产生结果。 </p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc29202"></a><a name="_Toc10725231"></a><a name="_Toc66809679"><strong>闭包</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;">一个函数把外部的那些不属于自己的对象也包含(闭合)进来。</p> 
<p style="margin-left:0;">案例1：</p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">def minusxy(x: Int) = (y: Int) =&gt; x - y</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">这就是一个闭包：</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">1) </span><span style="color:#000000;">匿名函数(y: Int) =&gt; x -y嵌套在minusxy函数中。</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">2) </span><span style="color:#000000;">匿名函数(y: Int) =&gt; x -y使用了该匿名函数之外的变量x</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">3) </span><span style="color:#000000;">函数minusxy返回了引用了局部变量的匿名函数</span></span></p> 
<p style="margin-left:0;">案例2</p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">def minusxy(x: Int) = (y: Int) =&gt; x - y</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">val f1 = minusxy(10)</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">val f2 = minusxy(10)</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">println(f1(3) + f2(3))</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">此处f1,f2这两个函数就叫闭包。</span></span></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725232"></a><a name="_Toc12464"></a><a name="_Toc66809680"><strong>Some</strong></a><strong>、None、Option的正确使用</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">val map = Map("Tom"-&gt; 23)</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">map("Jack") // </span><span style="color:#000000;">抛出异常 java.util.NoSuchElementException: key not found: Jack</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">map.get("Jack") // None</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">map("Tom") // 23</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">map.get("Tom") // Some(23)</span></span></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">使用模式匹配取出最后结果</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">val optionAge = map.get("Tom")</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">val age = optionAge match {<!-- --></span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;"> case Some(x) =&gt; optionAge.get</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;"> case None =&gt; 0</span></span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">}</span></span></p> 
<p style="margin-left:36pt;text-align:justify;"></p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725233"></a><a name="_Toc18801">  </a><a name="_Toc66809681">Spark</a>相关总结</strong></span></span> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc26318"></a><a name="_Toc10725234"></a><a name="_Toc66809682"><strong>Spark</strong></a><strong>有几种部署方式？请分别简要论述</strong></span></span></li></ol></li></ol></li></ol> 
<ol><li style="text-align:justify;">Local:运行在一台机器上，通常是练手或者测试环境。</li><li style="text-align:justify;">Standalone:构建一个基于Master+Slaves的资源调度集群，Spark任务提交给Master运行。是Spark自身的一个调度系统。</li><li style="text-align:justify;">Yarn: Spark客户端直接连接Yarn，不需要额外构建Spark集群。有yarn-client和yarn-cluster两种模式，主要区别在于：Driver程序的运行节点。</li><li style="text-align:justify;">Mesos：国内大环境比较少用。 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725235"></a><a name="_Toc26504"></a><a name="_Toc66809683"><strong>Spark</strong></a><strong>任务使用什么进行提交，javaEE界面还是脚本</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;">Shell 脚本。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc27612"></a><a name="_Toc10725236"></a><a name="_Toc66809684"><strong>Spark</strong></a><strong>提交作业参数（重点）</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;">参考答案：</p> 
<p style="margin-left:0;">https://blog.csdn.net/gamer_gyt/article/details/79135118</p> 
<ol><li style="text-align:justify;">在提交任务时的几个重要参数</li></ol> 
<p style="margin-left:0;">executor-cores —— 每个executor使用的内核数，默认为1，官方建议2-5个，我们企业是4个</p> 
<p style="margin-left:0;">num-executors —— 启动executors的数量，默认为2</p> 
<p style="margin-left:0;">executor-memory —— executor内存大小，默认1G</p> 
<p style="margin-left:0;">driver-cores —— driver使用内核数，默认为1</p> 
<p style="margin-left:0;">driver-memory —— driver内存大小，默认512M</p> 
<ol><li style="text-align:justify;">给一个提交任务的样式</li></ol> 
<p style="margin-left:0;">spark-submit \</p> 
<p style="margin-left:0;">  --master local[5]  \</p> 
<p style="margin-left:0;">  --driver-cores 2   \</p> 
<p style="margin-left:0;">  --driver-memory 8g \</p> 
<p style="margin-left:0;">  --executor-cores 4 \</p> 
<p style="margin-left:0;">  --num-executors 10 \</p> 
<p style="margin-left:0;">  --executor-memory 8g \</p> 
<p style="margin-left:0;">  --class PackageName.ClassName XXXX.jar \</p> 
<p style="margin-left:0;">  --name "Spark Job Name" \</p> 
<p style="margin-left:0;">  InputPath      \</p> 
<p style="margin-left:0;">  OutputPath</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc22666"></a><a name="_Toc10725237"></a><a name="_Toc66809685"><strong>简述Spark的架构与作业提交流程（画图讲解，注明各个部分的作用）（</strong></a><strong><span style="color:#ff0000;">重点</span></strong><strong>）</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725238"></a><a name="_Toc15853"></a><a name="_Toc66809686"><strong>如何理解Spark中的血统概念（RDD）（</strong></a><strong><span style="color:#ff0000;">笔试重点</span></strong><strong>）</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;">RDD在Lineage依赖方面分为两种Narrow Dependencies与Wide Dependencies用来解决数据容错时的高效性以及划分任务时候起到重要作用。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc554"></a><a name="_Toc10725239"></a><a name="_Toc66809687"><strong>简述Spark的宽窄依赖，以及Spark如何划分stage，每个stage又根据什么决定task个数? （</strong></a><strong><span style="color:#ff0000;">笔试重点</span></strong><strong>）</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;">Stage：根据RDD之间的依赖关系的不同将Job划分成不同的Stage，遇到一个宽依赖则划分一个Stage。</p> 
<p style="margin-left:0;">Task：Stage是一个TaskSet，将Stage根据分区数划分成一个个的Task。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc13360"></a><a name="_Toc10725240"></a><a name="_Toc66809688"><strong>请列举Spark的transformation算子（不少于8个），并简述功能（重点）</strong></a></span></span></li></ol></li></ol></li><li style="text-align:justify;">map（func）：返回一个新的RDD，该RDD由每一个输入元素经过func函数转换后组成.</li><li style="text-align:justify;">mapPartitions(func)：类似于map，但独立地在RDD的每一个分片上运行，因此在类型为T的RD上运行时，func的函数类型必须是Iterator[T] =&gt; Iterator[U]。假设有N个元素，有M个分区，那么map的函数的将被调用N次,而mapPartitions被调用M次,一个函数一次处理所有分区。</li><li style="text-align:justify;">reduceByKey（func，[numTask]）：在一个(K,V)的RDD上调用，返回一个(K,V)的RDD，使用定的reduce函数，将相同key的值聚合到一起，reduce任务的个数可以通过第二个可选的参数来设置。</li><li style="text-align:justify;">aggregateByKey (zeroValue:U,[partitioner: Partitioner]) (seqOp: (U, V) =&gt; U,combOp: (U, U) =&gt; U: 在kv对的RDD中，，按key将value进行分组合并，合并时，将每个value和初始值作为seq函数的参数，进行计算，返回的结果作为一个新的kv对，然后再将结果按照key进行合并，最后将每个分组的value传递给combine函数进行计算（先将前两个value进行计算，将返回结果和下一个value传给combine函数，以此类推），将key与计算结果作为一个新的kv对输出。</li><li style="text-align:justify;">combineByKey(createCombiner: V=&gt;C, mergeValue: (C, V) =&gt;C, mergeCombiners: (C, C) =&gt;C):</li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">对相同K，把V合并成一个集合。</span></p> 
<ol><li> 
  <ol><li style="text-align:justify;">createCombiner: combineByKey() 会遍历分区中的所有元素，因此每个元素的键要么还没有遇到过，要么就和之前的某个元素的键相同。如果这是一个新的元素,combineByKey()会使用一个叫作createCombiner()的函数来创建那个键对应的累加器的初始值</li><li style="text-align:justify;">mergeValue: 如果这是一个在处理当前分区之前已经遇到的键，它会使用mergeValue()方法将该键的累加器对应的当前值与这个新的值进行合并</li><li style="text-align:justify;">mergeCombiners: 由于每个分区都是独立处理的， 因此对于同一个键可以有多个累加器。如果有两个或者更多的分区都有对应同一个键的累加器， 就需要使用用户提供的 mergeCombiners() 方法将各个分区的结果进行合并。</li></ol></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">…</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">根据自身情况选择比较熟悉的算子加以介绍。</span></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc19990"></a><a name="_Toc10725241"></a><a name="_Toc66809689"><strong>请列举Spark的action算子（不少于6个），并简述功能（重点）</strong></a></span></span></li></ol></li></ol></li><li style="text-align:justify;">reduce：</li><li style="text-align:justify;">collect:</li><li style="text-align:justify;">first：</li><li style="text-align:justify;">take：</li><li style="text-align:justify;">aggregate：</li><li style="text-align:justify;">countByKey：</li><li style="text-align:justify;">foreach：</li><li style="text-align:justify;">saveAsTextFile： 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725242"></a><a name="_Toc11244"></a><a name="_Toc66809690"><strong>请列举会引起Shuffle过程的Spark算子，并简述功能。</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;">reduceBykey：</p> 
<p style="margin-left:0;">groupByKey：</p> 
<p style="margin-left:0;">…ByKey:</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725243"></a><a name="_Toc7556"></a><a name="_Toc66809691"><strong>简述Spark的两种核心Shuffle（HashShuffle与SortShuffle）的工作流程（包括未优化的HashShuffle、优化的HashShuffle、普通的SortShuffle与bypass的SortShuffle）（</strong></a><strong><span style="color:#ff0000;">重点</span></strong><strong>）</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"><strong><span style="color:#ff0000;">未经优化的HashShuffle：</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong><span style="color:#ff0000;">优化后的Shuffle：</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong><span style="color:#ff0000;">普通的SortShuffle：</span></strong></p> 
<p style="margin-left:0;">      当 shuffle read task 的 数 量 小 于 等 于 spark.shuffle.sort。</p> 
<p style="margin-left:0;">bypassMergeThreshold 参数的值时（默认为 200），就会启用 bypass 机制。</p> 
<p style="margin-left:0;"><span style="color:#000000;">  </span></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc15969"></a><a name="_Toc10725244"></a><a name="_Toc66809692"><strong>Spark</strong></a><strong>常用算子reduceByKey与groupByKey的区别，哪一种更具优势？（重点）</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;">reduceByKey：按照key进行聚合，在shuffle之前有combine（预聚合）操作，返回结果是RDD[k,v]。</p> 
<p style="margin-left:0;">groupByKey：按照key进行分组，直接进行shuffle。</p> 
<p style="margin-left:0;">开发指导：reduceByKey比groupByKey，建议使用。但是需要注意是否会影响业务逻辑。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc30220"></a><a name="_Toc10725245"></a><a name="_Toc66809693"><strong>Repartition</strong></a><strong>和Coalesce关系与区别</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">关系：</li></ol> 
<p style="margin-left:0;">两者都是用来改变RDD的partition数量的，repartition底层调用的就是coalesce方法：coalesce(numPartitions, shuffle = true)</p> 
<ol><li style="text-align:justify;">区别：</li></ol> 
<p style="margin-left:0;">repartition一定会发生shuffle，coalesce根据传入的参数来判断是否发生shuffle</p> 
<p style="margin-left:0;">一般情况下增大rdd的partition数量使用repartition，减少partition数量时使用coalesce</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725246"></a><a name="_Toc20152"></a><a name="_Toc66809694"><strong>分别简述Spark中的缓存机制（cache和persist）与checkpoint机制，并指出两者的区别与联系</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;">都是做RDD持久化的</p> 
<p style="margin-left:0;">cache:内存，不会截断血缘关系，使用计算过程中的数据缓存。</p> 
<p style="margin-left:0;">checkpoint：磁盘，截断血缘关系，在ck之前必须没有任何任务提交才会生效，ck过程会额外提交一次任务。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725247"></a><a name="_Toc6749"></a><a name="_Toc66809695"><strong>简述Spark中共享变量（广播变量和累加器）的基本原理与用途。（</strong></a><strong><span style="color:#ff0000;">重点</span></strong><strong>）</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;">累加器（accumulator）是Spark中提供的一种分布式的变量机制，其原理类似于mapreduce，即分布式的改变，然后聚合这些改变。累加器的一个常见用途是在调试时对作业执行过程中的事件进行计数。而广播变量用来高效分发较大的对象。</p> 
<p style="margin-left:0;">共享变量出现的原因：</p> 
<p style="margin-left:0;">通常在向 Spark 传递函数时，比如使用 map() 函数或者用 filter() 传条件时，可以使用驱动器程序中定义的变量，但是集群中运行的每个任务都会得到这些变量的一份新的副本，更新这些副本的值也不会影响驱动器中的对应变量。</p> 
<p style="margin-left:0;">Spark的两个共享变量，累加器与广播变量，分别为结果聚合与广播这两种常见的通信模式突破了这一限制。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725248"></a><a name="_Toc30821"></a><a name="_Toc66809696"><strong>当Spark涉及到数据库的操作时，如何减少Spark运行中的数据库连接数？</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;">使用foreachPartition代替foreach，在foreachPartition内获取数据库的连接。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc5522"></a><a name="_Toc10725249"></a><a name="_Toc66809697"><strong>简述SparkSQL中RDD、DataFrame、DataSet三者的区别与联系? （</strong></a><strong><span style="color:#ff0000;">笔试重点</span></strong><strong>）</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">RDD</li></ol> 
<p style="margin-left:0;">优点:</p> 
<p style="margin-left:0;">编译时类型安全 </p> 
<p style="margin-left:0;">编译时就能检查出类型错误</p> 
<p style="margin-left:0;">面向对象的编程风格 </p> 
<p style="margin-left:0;">直接通过类名点的方式来操作数据</p> 
<p style="margin-left:0;">缺点:</p> 
<p style="margin-left:0;">序列化和反序列化的性能开销 </p> 
<p style="margin-left:0;">无论是集群间的通信, 还是IO操作都需要对对象的结构和数据进行序列化和反序列化。</p> 
<p style="margin-left:0;">GC的性能开销，频繁的创建和销毁对象, 势必会增加GC</p> 
<ol><li style="text-align:justify;">DataFrame</li></ol> 
<p style="margin-left:0;">DataFrame引入了schema和off-heap</p> 
<p style="margin-left:0;">schema : RDD每一行的数据, 结构都是一样的，这个结构就存储在schema中。 Spark通过schema就能够读懂数据, 因此在通信和IO时就只需要序列化和反序列化数据, 而结构的部分就可以省略了。</p> 
<ol><li style="text-align:justify;">DataSet</li></ol> 
<p style="margin-left:0;">DataSet结合了RDD和DataFrame的优点，并带来的一个新的概念Encoder。</p> 
<p style="margin-left:0;">当序列化数据时，Encoder产生字节码与off-heap进行交互，能够达到按需访问数据的效果，而不用反序列化整个对象。Spark还没有提供自定义Encoder的API，但是未来会加入。</p> 
<p style="margin-left:0;">三者之间的转换：</p> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725250"></a><a name="_Toc27052"></a><a name="_Toc66809698"><strong>SparkSQL</strong></a><strong>中join操作与left join操作的区别？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;">join和sql中的inner join操作很相似，返回结果是前面一个集合和后面一个集合中匹配成功的，过滤掉关联不上的。</p> 
<p style="margin-left:0;">leftJoin类似于SQL中的左外关联left outer join，返回结果以第一个RDD为主，关联不上的记录为空。</p> 
<p style="margin-left:0;">部分场景下可以使用left semi join替代left join：</p> 
<p style="margin-left:0;">因为 left semi join 是 in(keySet) 的关系，遇到右表重复记录，左表会跳过,性能更高，而 left join 则会一直遍历。但是left semi join 中最后 select 的结果中只许出现左表中的列名，因为右表只有 join key 参与关联计算了</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809699"></a><a name="_Toc10725251"></a><a name="_Toc13871"><strong>SparkStreaming</strong></a><strong>有哪几种方式消费Kafka中的数据，它们之间的区别是什么？</strong><strong> （</strong><strong><span style="color:#ff0000;">重点</span></strong><strong>）</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"><strong>一、基于Receiver的方式</strong></p> 
<p style="margin-left:0;">这种方式使用Receiver来获取数据。Receiver是使用Kafka的高层次Consumer API来实现的。receiver从Kafka中获取的数据都是存储在Spark Executor的内存中的（如果突然数据暴增，大量batch堆积，很容易出现内存溢出的问题），然后Spark Streaming启动的job会去处理那些数据。</p> 
<p style="margin-left:0;text-align:justify;">然而，在默认的配置下，这种方式可能会因为底层的失败而丢失数据。如果要启用高可靠机制，让数据零丢失，就必须启用Spark Streaming的预写日志机制（Write Ahead Log，WAL）。该机制会同步地将接收到的Kafka数据写入分布式文件系统（比如HDFS）上的预写日志中。所以，即使底层节点出现了失败，也可以使用预写日志中的数据进行恢复。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong><span style="color:#000000;">二、基于Direct的方式</span></strong></p> 
<p style="margin-left:0;text-align:justify;">这种新的不基于Receiver的直接方式，是在Spark 1.3中引入的，从而能够确保更加健壮的机制。替代掉使用Receiver来接收数据后，这种方式会周期性地查询Kafka，来获得每个topic+partition的最新的offset，从而定义每个batch的offset的范围。当处理数据的job启动时，就会使用Kafka的简单consumer api来获取Kafka指定offset范围的数据。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong><span style="color:#000000;">优点如下： </span></strong></p> 
<p style="margin-left:0;"><strong>简化并行读取</strong>：如果要读取多个partition，不需要创建多个输入DStream然后对它们进行union操作。Spark会创建跟Kafka partition一样多的RDD partition，并且会并行从Kafka中读取数据。所以在Kafka partition和RDD partition之间，有一个一对一的映射关系。</p> 
<p style="margin-left:0;"><strong><span style="color:#000000;">高性能：</span></strong><span style="color:#000000;">如果要保证零数据丢失，在基于receiver的方式中，需要开启WAL机制。这种方式其实效率低下，因为数据实际上被复制了两份，Kafka自己本身就有高可靠的机制，会对数据复制一份，而这里又会复制一份到WAL中。而基于direct的方式，不依赖Receiver，不需要开启WAL机制，只要Kafka中作了数据的复制，那么就可以通过Kafka的副本进行恢复。 </span></p> 
<p style="margin-left:0;"><strong><span style="color:#000000;">一次且仅一次的事务机制</span></strong><span style="color:#000000;">。</span></p> 
<p style="margin-left:0;"><strong><span style="color:#000000;">三、对比：</span></strong></p> 
<p style="margin-left:0;text-align:justify;">基于receiver的方式，是使用Kafka的高阶API来在ZooKeeper中保存消费过的offset的。这是消费Kafka数据的传统方式。这种方式配合着WAL机制可以保证数据零丢失的高可靠性，但是却无法保证数据被处理一次且仅一次，可能会处理两次。因为Spark和ZooKeeper之间可能是不同步的。</p> 
<p style="margin-left:0;text-align:justify;">基于direct的方式，使用kafka的简单api，Spark Streaming自己就负责追踪消费的offset，并保存在checkpoint中。Spark自己一定是同步的，因此可以保证数据是消费一次且仅消费一次。</p> 
<p style="margin-left:0;text-align:justify;">在实际生产环境中大都用Direct方式</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725252"></a><a name="_Toc21280"></a><a name="_Toc66809700"><strong>简述SparkStreaming窗口函数的原理（</strong></a><strong><span style="color:#ff0000;">重点</span></strong><strong>）</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"> 窗口函数就是在原来定义的SparkStreaming计算批次大小的基础上再次进行封装，每次计算多个批次的数据，同时还需要传递一个滑动步长的参数，用来设置当次计算任务完成之后下一次从什么地方开始计算。</p> 
<p style="margin-left:0;text-align:justify;">图中time1就是SparkStreaming计算批次大小，虚线框以及实线大框就是窗口的大小，必须为批次的整数倍。虚线框到大实线框的距离（相隔多少批次），就是滑动步长。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc7698"></a><a name="_Toc10725253"></a><a name="_Toc66809701"><strong>请手写出wordcount的Spark代码实现（Scala）（手写代码重点）</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <pre style="margin-left:0;"><code class="language-html hljs">val conf: SparkConf = new SparkConf().setMaster("local[*]").setAppName("WordCount")

  val sc = new SparkContext(conf)

  sc.textFile("/input")

  .flatMap(_.split(" "))

  .map((_,1))

  .reduceByKey(_+_)

  .saveAsTextFile("/output")

 sc.stop()</code></pre> </td></tr></tbody></table> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725254"></a><a name="_Toc7258"></a><a name="_Toc66809702"><strong>如何使用Spark实现topN的获取（描述思路或使用伪代码）（重点）</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">方法1：</p> 
<p style="margin-left:0;"><span style="color:#000000;">（1）按照key对数据进行聚合（groupByKey）</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">（2）将value转换为数组，利用scala的sortBy或者sortWith进行排序（mapValues）数据量太大，会OOM。</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">方法2：</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">（1）取出所有的key</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">（2）对key进行迭代，每次取出一个key利用spark的排序算子进行排序</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">方法3：</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">（1）自定义分区器，按照key进行分区，使不同的key进到不同的分区</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">（2）对每个分区运用spark的排序算子进行排序</span></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc30426"></a><a name="_Toc10725255"></a><a name="_Toc66809703"><strong>京东：调优之前与调优之后性能的详细对比（例如调整map个数，map个数之前多少、之后多少，有什么提升）</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">这里举个例子。比如我们有几百个文件，会有几百个map出现，读取之后进行join操作，会非常的慢。这个时候我们可以进行coalesce操作，比如240个map，我们合成60个map，也就是窄依赖。这样再shuffle，过程产生的文件数会大大减少。提高join的时间性能。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809704"> Flink</a>相关总结</strong></span></span> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809705"><strong>简单介绍一下Flink</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;">Flink核心是一个流式的数据流执行引擎，其针对数据流的分布式计算提供了数据分布、数据通信以及容错机制等功能。基于流执行引擎，Flink提供了诸多更高抽象层的API以便用户编写分布式任务：DataSet API， 对静态数据进行批处理操作，将静态数据抽象成分布式的数据集，用户可以方便地使用Flink提供的各种操作符对分布式数据集进行处理，支持Java、Scala和Python。DataStream API，对数据流进行流处理操作，将流式的数据抽象成分布式的数据流，用户可以方便地对分布式数据流进行各种操作，支持Java和Scala。Table API，对结构化数据进行查询操作，将结构化数据抽象成关系表，并通过类SQL的DSL对关系表进行各种查询操作，支持Java和Scala。此外，Flink还针对特定的应用领域提供了领域库，例如：Flink ML，Flink的机器学习库，提供了机器学习Pipelines API并实现了多种机器学习算法。Gelly，Flink的图计算库，提供了图计算的相关API及多种图计算算法实现。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809706"><strong>Flink</strong></a><strong>相比Spark Streaming有什么区别？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"><strong>架构模型上</strong>：Spark Streaming 的task运行依赖driver 和 executor和worker，当然driver和excutor还依赖于集群管理器Standalone或者yarn等。而Flink运行时主要是JobManager、TaskManage和TaskSlot。另外一个最核心的区别是：Spark Streaming 是微批处理，运行的时候需要指定批处理的时间，每次运行 job 时处理一个批次的数据；Flink 是基于事件驱动的，事件可以理解为消息。事件驱动的应用程序是一种状态应用程序，它会从一个或者多个流中注入事件，通过触发计算更新状态，或外部动作对注入的事件作出反应。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>任务调度上</strong>：Spark Streaming的调度分为构建 DGA 图，划分 stage，生成 taskset，调度 task等步骤，而Flink首先会生成 StreamGraph，接着生成 JobGraph，然后将 jobGraph 提交给 Jobmanager 由它完成 jobGraph 到 ExecutionGraph 的转变，最后由 jobManager 调度执行。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>时间机制上</strong>：flink 支持三种时间机制事件时间，注入时间，处理时间，同时支持 watermark 机制处理滞后数据。Spark Streaming 只支持处理时间，Structured streaming则支持了事件时间和watermark机制。</p> 
<p style="margin-left:0;text-align:justify;"><strong>容错机制上</strong>：二者保证exactly-once的方式不同。spark streaming 通过保存offset和事务的方式；Flink 则使用两阶段提交协议来解决这个问题。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809707"><strong>Flink</strong></a><strong>中的分区策略有哪几种？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;">Flink中默认提供了八大分区策略(也叫分区器)。八大分区策略继承关系图</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">ChannelSelector: 接口，决定将记录写入哪个Channel。有3个方法:</p> 
<ol><li style="text-align:justify;">void setup(int numberOfChannels): 初始化输出Channel的数量。</li><li style="text-align:justify;">int selectChannel(T record): 根据当前记录以及Channel总数，决定应将记录写入下游哪个Channel。八大分区策略的区别主要在这个方法的实现上。</li><li style="text-align:justify;">boolean isBroadcast(): 是否是广播模式。决定了是否将记录写入下游所有Channel。</li><li style="text-align:justify;">StreamPartitioner:抽象类，也是所有流分区器的基类。</li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>注意:</strong></p> 
<p style="margin-left:0;">这里以及下边提到的Channel可简单理解为下游Operator的某个实例。Flink 中改变并行度，默认RebalancePartitioner分区策略。分区策略，可在Flink WebUI上直观看出，如REBALANCE,即使用了RebalancePartitioner分区策略;SHUFFLE,即使用了ShufflePartitioner分区策略。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;">GlobalPartitioner: DataStream =&gt; DataStream</li></ol> 
<p style="margin-left:0;">GlobalPartitioner,GLOBAL分区。将记录输出到下游Operator的第一个实例。</p> 
<p style="margin-left:0;"><strong>selectChannel</strong><strong>实现</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">public int selectChannel(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record) {<!-- --></p> <p style="margin-left:0;">//对每条记录，只选择下游operator的第一个Channel</p> <p style="margin-left:0;">return 0;</p> <p style="margin-left:0;">}</p> </td></tr></tbody></table> 
<p style="margin-left:0;"><strong><span style="color:#000000;">API</span></strong><strong>使用</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">dataStream</p> <p style="margin-left:0;">    .setParallelism(2)</p> <p style="margin-left:0;">    // 采用GLOBAL分区策略重分区</p> <p style="margin-left:0;">    .global()</p> <p style="margin-left:0;">    .print()</p> <p style="margin-left:0;">    .setParallelism(1);</p> </td></tr></tbody></table> 
<ol><li style="text-align:justify;">ShufflePartitioner: DataStream =&gt; DataStream</li></ol> 
<p style="margin-left:0;">ShufflePartitioner，SHUFFLE分区。将记录随机输出到下游Operator的每个实例。</p> 
<p style="margin-left:0;"><strong>selectChannel</strong><strong>实现</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">private Random random = new Random();</p> <p style="margin-left:0;">@Override</p> <p style="margin-left:0;">public int selectChannel(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record) {<!-- --></p> <p style="margin-left:0;">    //对每条记录，随机选择下游operator的某个Channel</p> <p style="margin-left:0;">     return random.nextInt(numberOfChannels);</p> <p style="margin-left:0;">}</p> </td></tr></tbody></table> 
<p style="margin-left:0;"><strong><span style="color:#000000;">API</span></strong><strong>使用</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">dataStream</p> <p style="margin-left:0;">    .setParallelism(2)</p> <p style="margin-left:0;">    // 采用SHUFFLE分区策略重分区</p> <p style="margin-left:0;">    .shuffle()</p> <p style="margin-left:0;">    .print()</p> <p style="margin-left:0;">    .setParallelism(4);</p> </td></tr></tbody></table> 
<p style="margin-left:0;"></p> 
<ol><li style="text-align:justify;">RebalancePartitioner: DataStream =&gt; DataStream</li></ol> 
<p style="margin-left:0;">RebalancePartitioner,REBALANCE分区。将记录以循环的方式输出到下游Operator的每个实例。</p> 
<p style="margin-left:0;"><strong>selectChannel</strong><strong>实现</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">public int selectChannel(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record) {<!-- --></p> <p style="margin-left:0;">    //第一条记录，输出到下游的第一个Channel;第二条记录，输出到下游的第二个Channel...如此循环</p> <p style="margin-left:0;">     nextChannelToSendTo = (nextChannelToSendTo + 1) % numberOfChannels;</p> <p style="margin-left:0;">     return nextChannelToSendTo;</p> <p style="margin-left:0;">}</p> </td></tr></tbody></table> 
<p style="margin-left:0;"><strong><span style="color:#000000;">API</span></strong><strong>使用</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">dataStream</p> <p style="margin-left:0;">        .setParallelism(2)</p> <p style="margin-left:0;">        // 采用REBALANCE分区策略重分区</p> <p style="margin-left:0;">        .rebalance()</p> <p style="margin-left:0;">        .print()</p> <p style="margin-left:0;">        .setParallelism(4);</p> </td></tr></tbody></table> 
<p style="margin-left:0;"></p> 
<ol><li style="text-align:justify;">RescalePartitioner: DataStream =&gt; DataStream</li></ol> 
<p style="margin-left:0;">RescalePartitioner,RESCALE分区。基于上下游Operator的并行度，将记录以循环的方式输出到下游Operator的每个实例。举例: 上游并行度是2，下游是4，则上游一个并行度以循环的方式将记录输出到下游的两个并行度上;上游另一个并行度以循环的方式将记录输出到下游另两个并行度上。若上游并行度是4，下游并行度是2，则上游两个并行度将记录输出到下游一个并行度上；上游另两个并行度将记录输出到下游另一个并行度上。</p> 
<p style="margin-left:0;"><strong>selectChannel</strong><strong>实现</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">private int nextChannelToSendTo = -1;</p> <p style="margin-left:0;">@Override</p> <p style="margin-left:0;">public int selectChannel(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record) {<!-- --></p> <p style="margin-left:0;">     if (++nextChannelToSendTo &gt;= numberOfChannels) {<!-- --></p> <p style="margin-left:0;">          nextChannelToSendTo = 0;</p> <p style="margin-left:0;">     }</p> <p style="margin-left:0;">     return nextChannelToSendTo;</p> <p style="margin-left:0;">}</p> </td></tr></tbody></table> 
<p style="margin-left:0;"><strong><span style="color:#000000;">API</span></strong><strong>使用</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">dataStream</p> <p style="margin-left:0;">    .setParallelism(2)</p> <p style="margin-left:0;">    // 采用RESCALE分区策略重分区</p> <p style="margin-left:0;">    .rescale()</p> <p style="margin-left:0;">    .print()</p> <p style="margin-left:0;">    .setParallelism(4);</p> </td></tr></tbody></table> 
<ol><li style="text-align:justify;">BroadcastPartitioner: DataStream =&gt; DataStream</li></ol> 
<p style="margin-left:0;">BroadcastPartitioner,BROADCAST分区。广播分区将上游数据集输出到下游Operator的每个实例中。适合于大数据集Join小数据集的场景。</p> 
<p style="margin-left:0;"><strong>selectChannel</strong><strong>实现</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">@Override</p> <p style="margin-left:0;">public int selectChannel(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record) {<!-- --></p> <p style="margin-left:0;">    //广播分区不支持选择Channel,因为会输出到下游每个Channel中</p> <p style="margin-left:0;">     throw new UnsupportedOperationException("Broadcast partitioner does not support select channels.");</p> <p style="margin-left:0;">}</p> <p style="margin-left:0;">@Override</p> <p style="margin-left:0;">public boolean isBroadcast() {<!-- --></p> <p style="margin-left:0;">    //启用广播模式，此时Channel选择器会选择下游所有Channel</p> <p style="margin-left:0;">     return true;</p> <p style="margin-left:0;">}</p> </td></tr></tbody></table> 
<p style="margin-left:0;"><strong><span style="color:#000000;">API</span></strong><strong>使用</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">dataStream</p> <p style="margin-left:0;">    .setParallelism(2)</p> <p style="margin-left:0;">    // 采用BROADCAST分区策略重分区</p> <p style="margin-left:0;">    .broadcast()</p> <p style="margin-left:0;">    .print()</p> <p style="margin-left:0;">    .setParallelism(4);</p> </td></tr></tbody></table> 
<ol><li style="text-align:justify;"><span style="color:#000000;">ForwardPartitioner</span></li></ol> 
<p style="margin-left:0;">ForwardPartitioner,FORWARD分区。将记录输出到下游本地的operator实例。ForwardPartitioner分区器要求上下游算子并行度一样。上下游Operator同属一个SubTasks。</p> 
<p style="margin-left:0;"><strong>selectChannel</strong><strong>实现</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">@Override</p> <p style="margin-left:0;">public int selectChannel(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record) {<!-- --></p> <p style="margin-left:0;">     return 0;</p> <p style="margin-left:0;">}</p> </td></tr></tbody></table> 
<p style="margin-left:0;"><strong><span style="color:#000000;">API</span></strong><strong>使用</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">dataStream</p> <p style="margin-left:0;">    .setParallelism(2)</p> <p style="margin-left:0;">    // 采用FORWARD分区策略重分区</p> <p style="margin-left:0;">    .forward()</p> <p style="margin-left:0;">    .print()</p> <p style="margin-left:0;">    .setParallelism(2);</p> </td></tr></tbody></table> 
<ol><li style="text-align:justify;"><span style="color:#000000;">KeyGroupStreamPartitioner(HASH</span>方式):</li></ol> 
<p style="margin-left:0;">KeyGroupStreamPartitioner,HASH分区。将记录按Key的Hash值输出到下游Operator实例。</p> 
<p style="margin-left:0;"><strong>selectChannel</strong><strong>实现</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">@Override</p> <p style="margin-left:0;">public int selectChannel(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record) {<!-- --></p> <p style="margin-left:0;">     K key;</p> <p style="margin-left:0;">     try {<!-- --></p> <p style="margin-left:0;">          key = keySelector.getKey(record.getInstance().getValue());</p> <p style="margin-left:0;">     } catch (Exception e) {<!-- --></p> <p style="margin-left:0;">          throw new RuntimeException("Could not extract key from " + record.getInstance().getValue(), e);</p> <p style="margin-left:0;">     }</p> <p style="margin-left:0;">     return KeyGroupRangeAssignment.assignKeyToParallelOperator(key, maxParallelism, numberOfChannels);</p> <p style="margin-left:0;">}</p> <p style="margin-left:0;">// KeyGroupRangeAssignment中的方法</p> <p style="margin-left:0;">public static int assignKeyToParallelOperator(Object key, int maxParallelism, int parallelism) {<!-- --></p> <p style="margin-left:0;">     return computeOperatorIndexForKeyGroup(maxParallelism, parallelism, assignToKeyGroup(key, maxParallelism));</p> <p style="margin-left:0;">}</p> <p style="margin-left:0;">// KeyGroupRangeAssignment中的方法</p> <p style="margin-left:0;">public static int assignToKeyGroup(Object key, int maxParallelism) {<!-- --></p> <p style="margin-left:0;">     return computeKeyGroupForKeyHash(key.hashCode(), maxParallelism);</p> <p style="margin-left:0;">}</p> <p style="margin-left:0;">// KeyGroupRangeAssignment中的方法</p> <p style="margin-left:0;">public static int computeKeyGroupForKeyHash(int keyHash, int maxParallelism) {<!-- --></p> <p style="margin-left:0;">     return MathUtils.murmurHash(keyHash) % maxParallelism;</p> <p style="margin-left:0;">}</p> </td></tr></tbody></table> 
<p style="margin-left:0;"><strong><span style="color:#000000;">API</span></strong><strong>使用</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">dataStream</p> <p style="margin-left:0;">    .setParallelism(2)</p> <p style="margin-left:0;">    // 采用HASH分区策略重分区</p> <p style="margin-left:0;">    .keyBy((KeySelector&lt;Tuple3&lt;String, Integer, String&gt;, String&gt;) value -&gt; value.f0)</p> <p style="margin-left:0;">    .print()</p> <p style="margin-left:0;">    .setParallelism(4);</p> </td></tr></tbody></table> 
<ol><li style="text-align:justify;">CustomPartitionerWrapper</li></ol> 
<p style="margin-left:0;">CustomPartitionerWrapper,CUSTOM分区。通过Partitioner实例的partition方法(自定义的)将记录输出到下游。</p> 
<p style="margin-left:0;"><strong>selectChannel</strong><strong>实现</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">Partitioner&lt;K&gt; partitioner;</p> <p style="margin-left:0;">KeySelector&lt;T, K&gt; keySelector;</p> <p style="margin-left:0;">public CustomPartitionerWrapper(Partitioner&lt;K&gt; partitioner, KeySelector&lt;T, K&gt; keySelector) {<!-- --></p> <p style="margin-left:0;">     this.partitioner = partitioner;</p> <p style="margin-left:0;">     this.keySelector = keySelector;</p> <p style="margin-left:0;">}</p> <p style="margin-left:0;">@Override</p> <p style="margin-left:0;">public int selectChannel(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record) {<!-- --></p> <p style="margin-left:0;">     K key;</p> <p style="margin-left:0;">     try {<!-- --></p> <p style="margin-left:0;">          key = keySelector.getKey(record.getInstance().getValue());</p> <p style="margin-left:0;">     } catch (Exception e) {<!-- --></p> <p style="margin-left:0;">          throw new RuntimeException("Could not extract key from " + record.getInstance(), e);</p> <p style="margin-left:0;">     }</p> <p style="margin-left:0;">     return partitioner.partition(key, numberOfChannels);</p> <p style="margin-left:0;">}</p> </td></tr></tbody></table> 
<p style="margin-left:0;"><strong><span style="color:#000000;">自定义分区器将指定的</span></strong><strong>Key</strong><strong>分到指定的分区</strong></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">// 自定义分区器，将不同的Key(用户ID)分到指定的分区</p> <p style="margin-left:0;">// key: 根据key的值来分区</p> <p style="margin-left:0;">// numPartitions: 下游算子并行度</p> <p style="margin-left:0;">static class CustomPartitioner implements Partitioner&lt;String&gt; {<!-- --></p> <p style="margin-left:0;">      @Override</p> <p style="margin-left:0;">      public int partition(String key, int numPartitions) {<!-- --></p> <p style="margin-left:0;">          switch (key){<!-- --></p> <p style="margin-left:0;">              case "user_1":</p> <p style="margin-left:0;">                  return 0;</p> <p style="margin-left:0;">              case "user_2":</p> <p style="margin-left:0;">                  return 1;</p> <p style="margin-left:0;">              case "user_3":</p> <p style="margin-left:0;">                  return 2;</p> <p style="margin-left:0;">              default:</p> <p style="margin-left:0;">                  return 3;</p> <p style="margin-left:0;">          }</p> <p style="margin-left:0;">      }</p> <p style="margin-left:0;">  }</p> </td></tr></tbody></table> 
<p style="margin-left:0;"><a name="_Toc10725297"></a><a name="_Toc17885"><strong><span style="color:#000000;">使用自定义分区器</span></strong></a></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:450.15pt;"> <p style="margin-left:0;">dataStream</p> <p style="margin-left:0;">    .setParallelism(2)</p> <p style="margin-left:0;">    // 采用CUSTOM分区策略重分区</p> <p style="margin-left:0;">    .partitionCustom(new CustomPartitioner(),0)</p> <p style="margin-left:0;">    .print()</p> <p style="margin-left:0;">    .setParallelism(4);</p> </td></tr></tbody></table> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809708"><strong>Flink</strong></a><strong>的并行度有了解吗？Flink中设置并行度需要注意什么？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Flink程序由多个任务（Source、Transformation、Sink）组成。任务被分成多个并行实例来执行，每个并行实例处理任务的输入数据的子集。任务的并行实例的数量称之为并行度。Flink中人物的并行度可以从多个不同层面设置：操作算子层面(Operator Level)、执行环境层面(Execution Environment Level)、客户端层面(Client Level)、系统层面(System Level)。Flink可以设置好几个level的parallelism，其中包括Operator Level、Execution Environment Level、Client Level、System Level在flink-conf.yaml中通过parallelism.default配置项给所有execution environments指定系统级的默认parallelism；在ExecutionEnvironment里头可以通过setParallelism来给operators、data sources、data sinks设置默认的parallelism；如果operators、data sources、data sinks自己有设置parallelism则会覆盖ExecutionEnvironment设置的parallelism。 </p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809709"><strong>Flink</strong></a><strong>支持哪几种重启策略？分别如何配置？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">重启策略种类：固定延迟重启策略（Fixed Delay Restart Strategy）故障率重启策略（Failure Rate Restart Strategy）无重启策略（No Restart Strategy）Fallback重启策略（Fallback Restart Strategy）</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809710"><strong>Flink</strong></a><strong>的分布式缓存有什么作用？如何使用？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Flink提供了一个分布式缓存，类似于hadoop，可以使用户在并行函数中很方便的读取本地文件，并把它放在taskmanager节点中，防止task重复拉取。</p> 
<p style="margin-left:0;text-align:justify;">此缓存的工作机制如下：程序注册一个文件或者目录(本地或者远程文件系统，例如hdfs或者s3)，通过ExecutionEnvironment注册缓存文件并为它起一个名称。</p> 
<p style="margin-left:0;text-align:justify;">当程序执行，Flink自动将文件或者目录复制到所有taskmanager节点的本地文件系统，仅会执行一次。用户可以通过这个指定的名称查找文件或者目录，然后从taskmanager节点的本地文件系统访问它。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809711"><strong>Flink</strong></a><strong>中的广播变量，使用广播变量需要注意什么事项？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">在Flink中，同一个算子可能存在若干个不同的并行实例，计算过程可能不在同一个Slot中进行，不同算子之间更是如此，因此不同算子的计算数据之间不能像Java数组之间一样互相访问，而广播变量Broadcast便是解决这种情况的。我们可以把广播变量理解为是一个公共的共享变量，我们可以把一个dataset 数据集广播出去，然后不同的task在节点上都能够获取到，这个数据在每个节点上只会存在一份。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809712"><strong>Flink</strong></a><strong>中对窗口的支持包括哪几种？说说他们的使用场景</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<ol><li style="text-align:justify;">Tumbling Time Window</li></ol> 
<p style="margin-left:0;text-align:justify;">假如我们需要统计每一分钟中用户购买的商品的总数，需要将用户的行为事件按每一分钟进行切分，这种切分被成为翻滚时间窗口（Tumbling Time Window）。翻滚窗口能将数据流切分成不重叠的窗口，每一个事件只能属于一个窗口。</p> 
<ol><li style="text-align:justify;">Sliding Time Window</li></ol> 
<p style="margin-left:0;text-align:justify;">我们可以每30秒计算一次最近一分钟用户购买的商品总数。这种窗口我们称为滑动时间窗口（Sliding Time Window）。在滑窗中，一个元素可以对应多个窗口。</p> 
<ol><li style="text-align:justify;">Tumbling Count Window</li></ol> 
<p style="margin-left:0;text-align:justify;">当我们想要每100个用户购买行为事件统计购买总数，那么每当窗口中填满100个元素了，就会对窗口进行计算，这种窗口我们称之为翻滚计数窗口（Tumbling Count Window），上图所示窗口大小为3个。</p> 
<ol><li style="text-align:justify;">Session Window</li></ol> 
<p style="margin-left:0;text-align:justify;">在这种用户交互事件流中，我们首先想到的是将事件聚合到会话窗口中（一段用户持续活跃的周期），由非活跃的间隙分隔开。如上图所示，就是需要计算每个用户在活跃期间总共购买的商品数量，如果用户30秒没有活动则视为会话断开（假设raw data stream是单个用户的购买行为流）。一般而言，window 是在无限的流上定义了一个有限的元素集合。这个集合可以是基于时间的，元素个数的，时间和个数结合的，会话间隙的，或者是自定义的。Flink 的 DataStream API 提供了简洁的算子来满足常用的窗口操作，同时提供了通用的窗口机制来允许用户自己定义窗口分配逻辑。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809713"><strong>Flink </strong></a><strong>中的 State Backends是什么？有什么作用？分成哪几类？说说他们各自的优缺点？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Flink流计算中可能有各种方式来保存状态：</p> 
<ol><li style="text-align:justify;">窗口操作</li><li style="text-align:justify;">使用了KV操作的函数</li><li style="text-align:justify;">继承了CheckpointedFunction的函数</li></ol> 
<p style="margin-left:0;text-align:justify;">当开始做checkpointing的时候，状态会被持久化到checkpoints里来规避数据丢失和状态恢复。选择的状态存储策略不同，会导致状态持久化如何和checkpoints交互。</p> 
<p style="margin-left:0;text-align:justify;">Flink内部提供了这些状态后端:</p> 
<ol><li style="text-align:justify;">MemoryStateBackend</li><li style="text-align:justify;">FsStateBackend</li><li style="text-align:justify;">RocksDBStateBackend</li></ol> 
<p style="margin-left:0;text-align:justify;">如果没有其他配置，系统将使用MemoryStateBackend。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809714">Flink</a>中的时间种类有哪些？各自介绍一下？</span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Flink中的时间与现实世界中的时间是不一致的，在flink中被划分为事件时间，摄入时间，处理时间三种。如果以EventTime为基准来定义时间窗口将形成EventTimeWindow,要求消息本身就应该携带EventTime如果以IngesingtTime为基准来定义时间窗口将形成IngestingTimeWindow,以source的systemTime为准。如果以ProcessingTime基准来定义时间窗口将形成ProcessingTimeWindow，以operator的systemTime为准。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809715"><strong>WaterMark</strong></a><strong>是什么？是用来解决什么问题？如何生成水印？水印的原理是什么？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Watermark是Apache Flink为了处理EventTime 窗口计算提出的一种机制,本质上也是一种时间戳。watermark是用于处理乱序事件的，处理乱序事件通常用watermark机制结合window来实现。详细参考：<a href="https://www.jianshu.com/p/1c2542f11da0" rel="nofollow">https://www.jianshu.com/p/1c2542f11da0</a></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809716"><strong>Flink</strong></a><strong>的table和SQL熟悉吗？Table API和SQL中TableEnvironment这个类有什么作用</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">TableEnvironment是Table API和SQL集成的核心概念。它负责：</p> 
<ol><li style="text-align:justify;">在内部catalog中注册表</li><li style="text-align:justify;">注册外部catalog</li><li style="text-align:justify;">执行SQL查询</li><li style="text-align:justify;">注册用户定义（标量，表或聚合）函数</li><li style="text-align:justify;">将DataStream或DataSet转换为表</li><li style="text-align:justify;">持有对ExecutionEnvironment或StreamExecutionEnvironment的引用  
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809717"><strong>Flink</strong></a><strong>如何实现SQL解析的呢？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;">StreamSQL API的执行原理如下：</p> 
<ol><li style="text-align:justify;">用户使用对外提供Stream SQL的语法开发业务应用；</li><li style="text-align:justify;">用calcite对StreamSQL进行语法检验，语法检验通过后，转换成calcite的逻辑树节点；最终形成calcite的逻辑计划；</li><li style="text-align:justify;">采用Flink自定义的优化规则和calcite火山模型、启发式模型共同对逻辑树进行优化，生成最优的Flink物理计划；</li><li style="text-align:justify;">对物理计划采用janino codegen生成代码，生成用低阶API DataStream 描述的流应用，提交到Flink平台执行详细参考：<a href="https://cloud.tencent.com/developer/article/1471612" rel="nofollow">https://cloud.tencent.com/developer/article/1471612</a></li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809718"><strong>Flink</strong></a><strong>是如何做到批处理与流处理统一的？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Flink设计者认为：有限流处理是无限流处理的一种特殊情况，它只不过在某个时间点停止而已。Flink通过一个底层引擎同时支持流处理和批处理。详细参考：<a href="https://cloud.tencent.com/developer/article/1501348" rel="nofollow">https://cloud.tencent.com/developer/article/1501348</a></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809719"><strong>Flink</strong></a><strong>中的数据传输模式是怎么样的？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;">大概的原理，上游的task产生数据后，会写在本地的缓存中，然后通知JM自己的数据已经好了，JM通知下游的Task去拉取数据，下游的Task然后去上游的Task拉取数据，形成链条。</p> 
<p style="margin-left:0;text-align:justify;">但是在何时通知JM？这里有一个设置，比如pipeline还是blocking，pipeline意味着上游哪怕产生一个数据，也会去通知，blocking则需要缓存的插槽存满了才会去通知，默认是pipeline。</p> 
<p style="margin-left:0;text-align:justify;">虽然生产数据的是Task，但是一个TaskManager中的所有Task共享一个NetworkEnvironment，下游的Task利用ResultPartitionManager主动去上游Task拉数据，底层利用的是Netty和TCP实现网络链路的传输。</p> 
<p style="margin-left:0;text-align:justify;">那么，一直都在说Flink的背压是一种自然的方式，为什么是自然的了？</p> 
<p style="margin-left:0;text-align:justify;">从上面的图中下面的链路中可以看到，当下游的process逻辑比较慢，无法及时处理数据时，他自己的local buffer中的消息就不能及时被消费，进而导致netty无法把数据放入local buffer，进而netty也不会去socket上读取新到达的数据，进而在tcp机制中，tcp也不会从上游的socket去读取新的数据，上游的netty也是一样的逻辑，它无法发送数据，也就不能从上游的localbuffer中消费数据，所以上游的localbuffer可能就是满的，上游的operator或者process在处理数据之后进行collect.out的时候申请不能本地缓存，导致上游的process被阻塞。这样，在这个链路上，就实现了背压。</p> 
<p style="margin-left:0;text-align:justify;">如果还有相应的上游，则会一直反压上去，一直影响到source，导致source也放慢从外部消息源读取消息的速度。一旦瓶颈解除，网络链路畅通，则背压也会自然而然的解除。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809720"><strong>Flink</strong></a><strong>的容错机制</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Flink基于分布式快照与可部分重发的数据源实现了容错。用户可自定义对整个Job进行快照的时间间隔，当任务失败时，Flink会将整个Job恢复到最近一次快照，并从数据源重发快照之后的数据。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">详细参考：<a href="https://www.jianshu.com/p/1fca8fb61f86" rel="nofollow">https://www.jianshu.com/p/1fca8fb61f86</a></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809721"><strong>Flink</strong></a><strong>在使用Window时出现数据倾斜，你有什么解决办法？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">注意：这里window产生的数据倾斜指的是不同的窗口内积攒的数据量不同，主要是由源头数据的产生速度导致的差异。核心思路：1.重新设计key 2.在窗口计算前做预聚合可以参考这个：<a href="https://blog.csdn.net/it_lee_j_h/article/details/88641894">https://blog.csdn.net/it_lee_j_h/article/details/88641894</a></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc66809722"><strong>Flink</strong></a><strong>任务，delay极高，请问你有什么调优策略？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">首先要确定问题产生的原因，找到最耗时的点，确定性能瓶颈点。比如任务频繁反压，找到反压点。主要通过：资源调优、作业参数调优。资源调优即是对作业中的Operator的并发数（parallelism）、CPU（core）、堆内存（heap_memory）等参数进行调优。作业参数调优包括：并行度的设置，State的设置，checkpoint的设置。</p> 
<ol><li style="text-align:justify;"><strong><a name="_Toc66809723"> 业务交互数据分析</a></strong></li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725298"></a><a name="_Toc21993"></a><a name="_Toc66809724"> 电商常识</a></strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">SKU（<span style="background-color:#ffffff;"><span style="color:#333333;">库存量单位</span></span>）：一台银色、128G内存的、支持联通网络的iPhoneX</p> 
<p style="margin-left:0;text-align:justify;">SPU（<span style="background-color:#ffffff;"><span style="color:#333333;">标准产品单位</span></span>）：iPhoneX</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc8481"></a><a name="_Toc10725299"></a><a name="_Toc66809725"> 电商业务流程</a></strong></span></span></li></ol> 
<p style="margin-left:0;"></p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725300"></a><a name="_Toc3670"></a><a name="_Toc66809726"> 业务表关键字段</a></strong></span></span> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc22350"></a><a name="_Toc10725301"></a><a name="_Toc66809727"><strong>订单表（order_info）</strong></a></span></span></li></ol></li></ol></li></ol> 
<table cellspacing="0" style="width:571px;"><tbody><tr><td colspan="2" style="vertical-align:top;width:121.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">标签</span></p> </td><td style="vertical-align:top;width:306.85pt;"> <p style="margin-left:0;"><span style="color:#000000;">含义</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">id</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">订单编号</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">total_amount</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">订单金额</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">order_status</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">订单状态</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">user_id</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">用户id</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">payment_way</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">支付方式</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">out_trade_no</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">支付流水号</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">create_time</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">创建时间</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">operate_time</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">操作时间</span></p> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc4880"></a><a name="_Toc10725302"></a><a name="_Toc66809728"><strong>订单详情表（order_detail）</strong></a></span></span></li></ol></li></ol></li></ol> 
<table cellspacing="0" style="width:571px;"><tbody><tr><td colspan="2" style="vertical-align:top;width:121.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">标签</span></p> </td><td style="vertical-align:top;width:306.85pt;"> <p style="margin-left:0;"><span style="color:#000000;">含义</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">id</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">订单编号</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">order_id</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">订单号</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">user_id</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">用户id</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">sku_id</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">商品id</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">sku_name</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">商品名称</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">order_price</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">商品价格</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">sku_num</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">商品数量</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">create_time</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">创建时间</span></p> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725303"></a><a name="_Toc636"></a><a name="_Toc66809729"><strong>商品表</strong></a></span></span></li></ol></li></ol></li></ol> 
<table cellspacing="0" style="width:571px;"><tbody><tr><td colspan="2" style="vertical-align:top;width:121.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">标签</span></p> </td><td style="vertical-align:top;width:306.85pt;"> <p style="margin-left:0;"><span style="color:#000000;">含义</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">id</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">skuId</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">spu_id</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">spuid</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">price</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">价格</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">sku_name</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">商品名称</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">sku_desc</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">商品描述</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">weight</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">重量</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">tm_id</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">品牌id</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">category3_id</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">品类id</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">create_time</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">创建时间</span></p> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725304"></a><a name="_Toc22546"></a><a name="_Toc66809730"><strong>用户表</strong></a></span></span></li></ol></li></ol></li></ol> 
<table cellspacing="0" style="width:571px;"><tbody><tr><td colspan="2" style="vertical-align:top;width:121.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">标签</span></p> </td><td style="vertical-align:top;width:306.85pt;"> <p style="margin-left:0;"><span style="color:#000000;">含义</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">id</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">用户id</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">name</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">姓名</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">birthday</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">生日</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">gender</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">性别</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">email</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">邮箱</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">user_level</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">用户等级</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">create_time</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">创建时间</span></p> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725305"></a><a name="_Toc2035"></a><a name="_Toc66809731"><strong>商品一级分类表</strong></a></span></span></li></ol></li></ol></li></ol> 
<table cellspacing="0" style="width:571px;"><tbody><tr><td colspan="2" style="vertical-align:top;width:121.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">标签</span></p> </td><td style="vertical-align:top;width:306.85pt;"> <p style="margin-left:0;"><span style="color:#000000;">含义</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">id</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">id</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">name</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">名称</span></p> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725306"></a><a name="_Toc20947"></a><a name="_Toc66809732"><strong>商品二级分类表</strong></a></span></span></li></ol></li></ol></li></ol> 
<table cellspacing="0" style="width:571px;"><tbody><tr><td colspan="2" style="vertical-align:top;width:121.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">标签</span></p> </td><td style="vertical-align:top;width:306.85pt;"> <p style="margin-left:0;"><span style="color:#000000;">含义</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">id</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">id</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">name</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">名称</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">category1_id</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">一级品类id</span></p> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725307"></a><a name="_Toc25945"></a><a name="_Toc66809733"><strong>商品三级分类表</strong></a></span></span></li></ol></li></ol></li></ol> 
<table cellspacing="0" style="width:571px;"><tbody><tr><td colspan="2" style="vertical-align:top;width:121.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">标签</span></p> </td><td style="vertical-align:top;width:306.85pt;"> <p style="margin-left:0;"><span style="color:#000000;">含义</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">id</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">id</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">name</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">名称</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">Category2_id</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">二级品类id</span></p> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc7752"></a><a name="_Toc10725308"></a><a name="_Toc66809734"><strong>支付流水表</strong></a></span></span></li></ol></li></ol></li></ol> 
<table cellspacing="0" style="width:571px;"><tbody><tr><td colspan="2" style="vertical-align:top;width:121.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">标签</span></p> </td><td style="vertical-align:top;width:306.85pt;"> <p style="margin-left:0;"><span style="color:#000000;">含义</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">id</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">编号</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">out_trade_no</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">对外业务编号</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">order_id</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">订单编号</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">user_id</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">用户编号</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">alipay_trade_no</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">支付宝交易流水编号</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">total_amount</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">支付金额</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">subject</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">交易内容</span></p> </td></tr><tr><td style="vertical-align:top;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">payment_type</span></p> </td><td colspan="2" style="vertical-align:top;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">支付类型</span></p> </td></tr><tr><td style="background-color:#e6eed5;width:116.75pt;"> <p style="margin-left:0;"><span style="color:#000000;">payment_time</span></p> </td><td colspan="2" style="background-color:#e6eed5;width:11cm;"> <p style="margin-left:0;"><span style="color:#000000;">支付时间</span></p> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;">订单表跟订单详情表有什么区别？</p> 
<p style="margin-left:0;text-align:justify;">    订单表的订单状态会变化，订单详情表不会，因为没有订单状态。</p> 
<p style="margin-left:0;text-align:justify;">    订单表记录user_id，订单id订单编号，订单的总金额order_status，支付方式，订单状态等。</p> 
<p style="margin-left:0;text-align:justify;">    订单详情表记录user_id，商品sku_id ,具体的商品信息（商品名称sku_name，价格order_price，数量sku_num）</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725309"></a><a name="_Toc1063"></a><a name="_Toc66809735"> MySql</a>中表的分类</strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">实体表，维度表，事务型事实表，周期性事实表</p> 
<p style="margin-left:0;text-align:justify;">其实最终可以把事务型事实表，周期性事实表统称实体表，实体表，维度表统称维度表</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;">订单表（order_info）（周期型事实表）</p> 
<p style="margin-left:0;text-align:justify;">订单详情表（order_detail）(事务型事实表)</p> 
<p style="margin-left:0;text-align:justify;">商品表(实体表)</p> 
<p style="margin-left:0;text-align:justify;">用户表(实体表)</p> 
<p style="margin-left:0;text-align:justify;">商品一级分类表(维度表)</p> 
<p style="margin-left:0;text-align:justify;">商品二级分类表(维度表)</p> 
<p style="margin-left:0;text-align:justify;">商品三级分类表(维度表)</p> 
<p style="margin-left:0;text-align:justify;">支付流水表(事务型实体表)</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc7923"></a><a name="_Toc10725310"></a><a name="_Toc66809736"> 同步策略</a></strong></span></span></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">  </span></p> 
<p style="margin-left:0;text-align:justify;">实体表，维度表统称维度表，每日全量或者每月（更长时间）全量</p> 
<p style="margin-left:0;text-align:justify;">事务型事实表：每日增量</p> 
<p style="margin-left:0;text-align:justify;">周期性事实表：拉链表</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc11780"></a><a name="_Toc10725311"></a><a name="_Toc66809737"> 关系型数据库范式理论</a></strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">1NF：属性不可再分割（例如不能存在5台电脑的属性，坏处：表都没法用）</p> 
<p style="margin-left:0;text-align:justify;">2NF：不能存在部分函数依赖（例如主键（学号+课名）--&gt;成绩，姓名，但学号--》姓名，所以姓名部分依赖于主键（学号+课名），所以要去除，坏处：数据冗余）</p> 
<p style="margin-left:0;text-align:justify;">3NF：不能存在传递函数依赖（学号--》宿舍种类--》价钱，坏处：数据冗余和增删异常）</p> 
<p style="margin-left:0;text-align:justify;">Mysql关系模型：关系模型主要应用与OLTP系统中，为了保证数据的一致性以及避免冗余，所以大部分业务系统的表都是遵循第三范式的。</p> 
<p style="margin-left:0;text-align:justify;">Hive 维度模型：维度模型主要应用于OLAP系统中，因为关系模型虽然冗余少，但是在大规模数据，跨表分析统计查询过程中，会造成多表关联，这会大大降低执行效率。所以HIVE把相关各种表整理成两种：事实表和维度表两种。所有维度表围绕着事实表进行解释。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc21605"></a><a name="_Toc10725312"></a><a name="_Toc66809738"> 数据模型</a></strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">雪花模型、星型模型和星座模型</p> 
<p style="margin-left:0;text-align:justify;">（在维度建模的基础上又分为三种模型：星型模型、雪花模型、星座模型。）</p> 
<p style="margin-left:0;text-align:justify;">星型模型（一级维度表），雪花（多级维度），星座模型（星型模型+多个事实表）</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc20661"></a><a name="_Toc10725313"></a><a name="_Toc66809739"> 业务数据数仓搭建</a></strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">sqoop</p> 
<p style="margin-left:0;text-align:justify;">导数据的原理是mapreduce,</p> 
<p style="margin-left:0;text-align:justify;">import  把数据从关系型数据库 导到 数据仓库，自定义InputFormat，</p> 
<p style="margin-left:0;text-align:justify;">export  把数据从数据仓库 导到 关系型数据库，自定义OutputFormat，</p> 
<p style="margin-left:0;text-align:justify;">用sqoop从mysql中将八张表的数据导入数仓的ods原始数据层</p> 
<p style="margin-left:0;text-align:justify;">全量无条件，增量按照创建时间，增量+变化按照创建时间或操作时间。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;">origin_data</p> 
<p style="margin-left:0;text-align:justify;">sku_info商品表（每日导全量）</p> 
<p style="margin-left:0;text-align:justify;">user_info用户表（每日导全量）</p> 
<p style="margin-left:0;text-align:justify;">base_category1商品一级分类表（每日导全量）</p> 
<p style="margin-left:0;text-align:justify;">base_category2商品二级分类表（每日导全量）</p> 
<p style="margin-left:0;text-align:justify;">base_category3商品三级分类表（每日导全量）</p> 
<p style="margin-left:0;text-align:justify;">order_detail订单详情表（每日导增量）</p> 
<p style="margin-left:0;text-align:justify;">payment_info支付流水表（每日导增量）</p> 
<p style="margin-left:0;text-align:justify;">order_info订单表（每日导增量+变化）</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725314"></a><a name="_Toc3808"></a><a name="_Toc66809740"><strong>ods</strong></a><strong>层</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">（八张表，表名，字段跟mysql完全相同）</p> 
<p style="margin-left:0;text-align:justify;">从origin_data把数据导入到ods层，表名在原表名前加ods_</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725315"></a><a name="_Toc30396"></a><a name="_Toc66809741"><strong>dwd</strong></a><strong>层</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">对ODS层数据进行判空过滤。对商品分类表进行维度退化(降维)。其他数据跟ods层一模一样</p> 
<p style="margin-left:0;text-align:justify;">订单表 dwd_order_info</p> 
<p style="margin-left:0;text-align:justify;">订单详情表 dwd_order_detail</p> 
<p style="margin-left:0;text-align:justify;">用户表 dwd_user_info</p> 
<p style="margin-left:0;text-align:justify;">支付流水表 dwd_payment_info</p> 
<p style="margin-left:0;text-align:justify;">商品表 dwd_sku_info</p> 
<p style="margin-left:0;text-align:justify;">其他表字段不变，唯独商品表，通过关联3张分类表，增加了</p> 
<p style="margin-left:0;text-align:justify;">    category2_id` string COMMENT '2id', </p> 
<p style="margin-left:0;text-align:justify;">    `category1_id` string COMMENT '3id', </p> 
<p style="margin-left:0;text-align:justify;">    `category3_name` string COMMENT '3', </p> 
<p style="margin-left:0;text-align:justify;">    `category2_name` string COMMENT '2', </p> 
<p style="margin-left:0;text-align:justify;">    `category1_name` string COMMENT '1', </p> 
<p style="margin-left:0;text-align:justify;">小结：</p> 
<ol><li style="text-align:justify;">维度退化要付出什么代价？或者说会造成什么样的需求处理不了？</li></ol> 
<p style="margin-left:0;text-align:justify;">如果被退化的维度，还有其他业务表使用，退化后处理起来就麻烦些。</p> 
<p style="margin-left:0;text-align:justify;">还有如果要删除数据，对应的维度可能也会被永久删除。</p> 
<ol><li style="text-align:justify;">想想在实际业务中还有那些维度表可以退化</li></ol> 
<p style="margin-left:0;text-align:justify;">城市的三级分类（省、市、县）等</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725316"></a><a name="_Toc25854"></a><a name="_Toc66809742"><strong>dws</strong></a><strong>层</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">从订单表 dwd_order_info 中获取 下单次数 和 下单总金额</p> 
<p style="margin-left:0;text-align:justify;">从支付流水表 dwd_payment_info 中获取 支付次数 和 支付总金额</p> 
<p style="margin-left:0;text-align:justify;">从事件日志评论表 dwd_comment_log 中获取评论次数</p> 
<p style="margin-left:0;text-align:justify;">最终按照user_id聚合，获得明细，跟之前的mid_id聚合不同</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc16874"></a><a name="_Toc10725317"></a><a name="_Toc66809743"> 需求一：GMV成交总额</a></strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">从用户行为宽表中dws_user_action，根据统计日期分组，聚合，直接sum就可以了。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10367"></a><a name="_Toc10725318"></a><a name="_Toc66809744"> 需求二：转化率</a></strong></span></span> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725319"></a><a name="_Toc24420"></a><a name="_Toc66809745"><strong>新增用户占日活跃用户比率表</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;">从日活跃数表 ads_uv_count 和 日新增设备数表 ads_new_mid_count 中取即可。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc4791"></a><a name="_Toc10725320"></a><a name="_Toc66809746"><strong>用户行为转化率表</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;">从用户行为宽表dws_user_action中取，下单人数（只要下单次数&gt;0）,支付人数（只要支付次数&gt;0）</p> 
<p style="margin-left:0;text-align:justify;">从日活跃数表 ads_uv_count 中取活跃人数，然后对应的相除就可以了。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725321"></a><a name="_Toc26862"></a><a name="_Toc66809747"> 需求三：品牌复购率</a></strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">需求：以月为单位统计，购买2次以上商品的用户</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc27947"></a><a name="_Toc10725322"></a><a name="_Toc66809748"><strong>用户购买商品明细表（宽表）</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725323"></a><a name="_Toc1403"></a><a name="_Toc66809749"><strong>品牌复购率表</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="color:#000000;">从用户购买商品明细宽表dws_sale_detail_daycount中，根据品牌id--sku_tm_id聚合，计算每个品牌购买的总次数，购买人数a=购买次数&gt;=1,两次及以上购买人数b=购买次数&gt;=2，三次及以上购买人数c=购买次数&gt;=3,</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">单次复购率=b/a，多次复购率=c/a</span></p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc24675"></a><a name="_Toc10725324"></a><a name="_Toc66809750"> 项目中有多少张宽表</a></strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">宽表要3-5张，用户行为宽表，用户购买商品明细行为宽表，商品宽表，购物车宽表，物流宽表、登录注册、售后等。</p> 
<ol><li style="text-align:justify;">为什么要建宽表</li></ol> 
<p style="margin-left:0;text-align:justify;">需求目标，把每个用户单日的行为聚合起来组成一张多列宽表，以便之后关联用户维度信息后进行，不同角度的统计分析。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc27476"></a><a name="_Toc10725325"></a><a name="_Toc66809751"> 拉链表</a></strong></span></span></li></ol> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;">订单表拉链表 dwd_order_info_his</p> 
<p style="margin-left:0;text-align:justify;">    `id` string COMMENT '订单编号',</p> 
<p style="margin-left:0;text-align:justify;">    `total_amount` decimal(10,2) COMMENT '订单金额',</p> 
<p style="margin-left:0;text-align:justify;">    `order_status` string COMMENT '订单状态',</p> 
<p style="margin-left:0;text-align:justify;">    `user_id` string COMMENT '用户id' ,</p> 
<p style="margin-left:0;text-align:justify;">    `payment_way` string COMMENT '支付方式', </p> 
<p style="margin-left:0;text-align:justify;">    `out_trade_no` string COMMENT '支付流水号', </p> 
<p style="margin-left:0;text-align:justify;">    `create_time` string COMMENT '创建时间', </p> 
<p style="margin-left:0;text-align:justify;">    `operate_time` string COMMENT '操作时间' ,</p> 
<p style="margin-left:0;text-align:justify;">    `start_date`  string COMMENT '有效开始日期',</p> 
<p style="margin-left:0;text-align:justify;">    `end_date`  string COMMENT '有效结束日期'</p> 
<p style="margin-left:0;text-align:justify;">1）创建订单表拉链表，字段跟拉链表一样，只增加了有效开始日期和有效结束日期</p> 
<p style="margin-left:0;text-align:justify;">初始日期，从订单变化表ods_order_info导入数据，且让有效开始时间=当前日期，有效结束日期=9999-99-99</p> 
<p style="margin-left:0;text-align:justify;">（从mysql导入数仓的时候就只导了新增的和变化的数据ods_order_info，dwd_order_info跟ods_order_info基本一样，只多了一个id的判空处理）</p> 
<p style="margin-left:0;text-align:justify;">2）建一张拉链临时表dwd_order_info_his_tmp，字段跟拉链表完全一致</p> 
<p style="margin-left:0;text-align:justify;">3）新的拉链表中应该有这几部分数据，</p> 
<p style="margin-left:0;text-align:justify;">（1）增加订单变化表dwd_order_info的全部数据</p> 
<p style="margin-left:0;text-align:justify;">（2）更新旧的拉链表左关联订单变化表dwd_order_info，关联字段：订单id, where 过滤出end_date只等于9999-99-99的数据，如果旧的拉链表中的end_date不等于9999-99-99，说明已经是终态了，不需要再更新</p> 
<p style="margin-left:0;text-align:justify;">如果dwd_order_info.id is null , 没关联上，说明数据状态没变，让end_date还等于旧的end_date</p> 
<p style="margin-left:0;text-align:justify;">如果dwd_order_info.id is not null , 关联上了，说明数据状态变了，让end_date等于当前日期-1</p> 
<p style="margin-left:0;text-align:justify;">把查询结果插入到拉链临时表中</p> 
<p style="margin-left:0;text-align:justify;">4）把拉链临时表覆盖到旧的拉链表中</p> 
<ol><li style="text-align:justify;"><strong><a name="_Toc10725327"></a><a name="_Toc14414"></a><a name="_Toc66809752"> 项目中遇到过哪些问题</a></strong> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc17516"></a><a name="_Toc10725328"></a><a name="_Toc66809753"> Hadoop</a>宕机</strong></span></span></li></ol></li></ol> 
<ol><li style="text-align:justify;">如果MR造成系统宕机。此时要控制Yarn同时运行的任务数，和每个任务申请的最大内存。调整参数：yarn.scheduler.maximum-allocation-mb（单个任务可申请的最多物理内存量，默认是8192MB）</li><li style="text-align:justify;">如果写入文件过量造成NameNode宕机。那么调高Kafka的存储大小，控制从Kafka到HDFS的写入速度。高峰期的时候用Kafka进行缓存，高峰期过去数据同步会自动跟上。 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725329"></a><a name="_Toc30959"></a><a name="_Toc66809754"> Ganglia</a>监控</strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">Ganglia</span><span style="color:#000000;">监控Flume发现尝试提交的次数大于最终成功的次数</span></p> 
<ol><li style="text-align:justify;">增加Flume内存</li><li style="text-align:justify;">增加Flume台数 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725330"></a><a name="_Toc15937"></a><a name="_Toc66809755"> Flume</a>小文件</strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">Flume</span><span style="color:#000000;">上传文件到HDFS时参数大量小文件?</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">调整hdfs.rollInterval、hdfs.rollSize、hdfs.rollCount这三个参数的值。</span></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc15724"></a><a name="_Toc10725331"></a><a name="_Toc66809756"> Kafka</a>挂掉</strong></span></span></li></ol></li><li style="text-align:justify;">Flume记录</li><li style="text-align:justify;">日志有记录</li><li style="text-align:justify;">短期没事 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc11125"></a><a name="_Toc10725332"></a><a name="_Toc66809757"> Kafka</a>消息数据积压，Kafka消费能力不足怎么处理？ </strong></span></span></li></ol></li></ol> 
<ol><li style="text-align:justify;">如果是Kafka消费能力不足，则可以考虑增加Topic的分区数，并且同时提升消费组的消费者数量，消费者数=分区数。（两者缺一不可）</li><li style="text-align:justify;">如果是下游的数据处理不及时：提高每批次拉取的数量。批次拉取数据过少（拉取数据/处理时间&lt;生产速度），使处理的数据小于生产的数据，也会造成数据积压。 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc21479"></a><a name="_Toc10725333"></a><a name="_Toc66809758"> Kafka</a>数据重复</strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">在下一级消费者中去重。（redis、SparkStreaming）</span></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725334"></a><a name="_Toc9050"></a><a name="_Toc66809759"> Mysql</a>高可用</strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">Hive</span><span style="color:#000000;">的metadata存储在MySql中（配置MySql的高可用（主从复制和读写分离和故障转移））</span></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725335"></a><a name="_Toc14683"></a><a name="_Toc66809760"> 自定义UDF和UDTF解析和调试复杂字段</a></strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">自定义UDF（extends UDF 实现evaluate方法） 解析公共字段</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">自定义UDTF(extends Genertic UDTF-&gt;实现三个方法init(指定返回值的名称和类型)、process(处理字段一进多出)、close方法) -&gt; 更加灵活以及方便定义bug</span></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725336"></a><a name="_Toc3647"></a><a name="_Toc66809761"> Sqoop</a>数据导出Parquet</strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">Ads</span><span style="color:#000000;">层数据用Sqoop往MySql中导入数据的时候，如果用了orc（Parquet）不能导入，需转化成text格式</span></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725337"></a><a name="_Toc7949"></a><a name="_Toc66809762"> Sqoop</a>数据导出控制</strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">Sqoop</span><span style="color:#000000;">中导入导出Null存储一致性问题：    </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">Hive</span><span style="color:#000000;">中的Null在底层是以“\N”来存储，而MySQL中的Null在底层就是Null，为了保证数据两端的一致性。在导出数据时采用--input-null-string和--input-null-non-string两个参数。导入数据时采用--null-string和--null-non-string。</span></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725338"></a><a name="_Toc420"></a><a name="_Toc66809763"> Sqoop</a>数据导出一致性问题</strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">当Sqoop导出数据到MySql时，使用4个map怎么保证数据的一致性</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">因为在导出数据的过程中map任务可能会失败，可以使用—staging-table  –clear-staging</span></p> 
<p style="margin-left:0;"><span style="background-color:#e0e0e0;"><span style="color:#000000;">sqoop export --connect jdbc:mysql://192.168.137.10:3306/user_behavior --username root --password 123456 --table app_cource_study_report --columns watch_video_cnt,complete_video_cnt,dt --fields-terminated-by "\t" --export-dir "/user/hive/warehouse/tmp.db/app_cource_study_analysis_${day}" --staging-table app_cource_study_report_tmp --clear-staging-table --input-null-string '\N'</span></span></p> 
<p style="margin-left:0;"><span style="color:#000000;">任务执行成功首先在tmp临时表中，然后将tmp表中的数据复制到目标表中（这个时候可以使用事务，保证事务的一致性）</span></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725339"></a><a name="_Toc4233"></a><a name="_Toc66809764"> SparkStreaming</a>优雅关闭</strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">如何优雅的关闭SparkStreaming任务（将写好的代码打包，Spark-Submit）</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">Kill -9 xxx ?</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">开启另外一个线程每5秒监听HDFS上一个文件是否存在。如果检测到存在，调用ssc.stop()方法关闭SparkStreaming任务（当你要关闭任务时，可以创建你自定义监控的文件目录）</span></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc7881"></a><a name="_Toc10725340"></a><a name="_Toc66809765"> Spark OOM</a>、数据倾斜解决</strong></span></span></li></ol></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">    </span></p> 
<ol><li style="text-align:justify;"><strong><a name="_Toc26220"></a><a name="_Toc10725341"></a><a name="_Toc66809766"> 项目经验</a></strong></li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725342"></a><a name="_Toc3788"></a><a name="_Toc66809767"> 框架经验</a></strong></span></span> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725343"></a><a name="_Toc21637"></a><a name="_Toc66809768"><strong>Hadoop</strong></a></span></span></li></ol></li></ol></li></ol> 
<ol><li style="text-align:justify;">Hadoop集群基准测试（HDFS的读写性能、MapReduce的计算能力测试）</li><li style="text-align:justify;">一台服务器一般都有很多个硬盘插槽（插了几个插槽）</li></ol> 
<p style="margin-left:0;text-align:justify;">如果不配置datanode.data.dir多目录，每次插入一块新的硬盘都需要重启服务器</p> 
<p style="margin-left:0;text-align:justify;">配置了即插即用</p> 
<ol><li style="text-align:justify;">Hdfs参数调优</li></ol> 
<p style="margin-left:0;text-align:justify;">Namenode有一个工作线程池，用来处理与datanode的心跳（报告自身的健康状况和文件恢复请求）和元数据请求    dfs.namenode.handler.count=20 * log2(Cluster Size)</p> 
<p style="margin-left:0;">4）编辑日志存储路径dfs.namenode.edits.dir设置与镜像文件存储路径    dfs.namenode.name.dir尽量分开，达到最低写入延迟（提高写入的吞吐量）</p> 
<p style="margin-left:0;">5）YARN参数调优yarn-site.xml</p> 
<p style="margin-left:0;text-align:justify;">（1）服务器节点上YARN可使用的物理内存总量，默认是8192（MB）</p> 
<p style="margin-left:0;text-align:justify;">（2）单个任务可申请的最多物理内存量，默认是8192（MB）。</p> 
<p style="margin-left:0;">6）HDFS和硬盘空闲控制在70%以下。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc20668"></a><a name="_Toc10725344"></a><a name="_Toc66809769"><strong>Flume</strong></a></span></span></li></ol></li></ol></li><li style="text-align:justify;">Flume内存配置为4G（flume-env.sh修改）</li><li style="text-align:justify;">FileChannel优化</li></ol> 
<p style="margin-left:0;text-align:justify;">通过配置dataDirs指向多个路径，每个路径对应不同的硬盘，增大Flume吞吐量。</p> 
<p style="margin-left:0;text-align:justify;">checkpointDir和backupCheckpointDir也尽量配置在不同硬盘对应的目录中，保证checkpoint坏掉后，可以快速使用backupCheckpointDir恢复数据</p> 
<ol><li style="text-align:justify;">Sink：HDFS Sink小文件处理</li></ol> 
<p style="margin-left:0;text-align:justify;">这三个参数配置写入HDFS后会产生小文件，hdfs.rollInterval、hdfs.rollSize、hdfs.rollCount</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc5664"></a><a name="_Toc10725345"></a><a name="_Toc66809770"><strong>Kafka</strong></a></span></span></li></ol></li></ol></li><li style="text-align:justify;">Kafka的吞吐量测试（测试生产速度和消费速度）</li><li style="text-align:justify;">Kafka内存为6G（不能超过6G）</li><li style="text-align:justify;">Kafka数量确定：2 * 峰值生产速度（m/s）* 副本数 / 100  + 1 = ?</li><li style="text-align:justify;">Kafka中的数据量计算</li></ol> 
<p style="margin-left:0;text-align:justify;">每天数据总量100g(1亿条)   10000万/24/60/60 = 1150条/s</p> 
<p style="margin-left:0;text-align:justify;">平均每秒钟：1150条</p> 
<p style="margin-left:0;text-align:justify;">低谷每秒：400条</p> 
<p style="margin-left:0;text-align:justify;">高峰每秒钟：1150 * 10 = 11000 条</p> 
<p style="margin-left:0;text-align:justify;">每条日志大小： 1K左右</p> 
<p style="margin-left:0;text-align:justify;">每秒多少数据量：20MB</p> 
<ol><li style="text-align:justify;">Kafka消息数据积压，Kafka消费能力不足怎么处理？ 
  <ol><li style="text-align:justify;">如果是Kafka消费能力不足，则可以考虑增加Topic的分区数，并且同时提升消费组的消费者数量，消费者数=分区数。（两者缺一不可）</li><li style="text-align:justify;">如果是下游的数据处理不及时：提高每批次拉取的数量。批次拉取数据过少（拉取数据/处理时间&lt;生产速度），使处理的数据小于生产的数据，也会造成数据积压。 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725347"></a><a name="_Toc4463"></a><a name="_Toc66809771"><strong>Tez</strong></a><strong>引擎优点（略过）？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Tez可以将多个有依赖的作业转换为一个作业，这样只需写一次HDFS，且中间节点较少，从而大大提升作业的计算性能。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc16645"></a><a name="_Toc10725348"></a><a name="_Toc66809772"><strong>Sqoop</strong></a><strong>参数</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">Sqoop导入导出Null存储一致性问题</li><li style="text-align:justify;">Sqoop数据导出一致性问题</li></ol> 
<p style="margin-left:0;text-align:justify;">–staging-table方式 --clear-staging</p> 
<ol><li style="text-align:justify;">Sqoop数据导出的时候一次执行多长时间</li></ol> 
<p style="margin-left:0;text-align:justify;">Sqoop任务5分钟-2个小时的都有。取决于数据量。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725349"></a><a name="_Toc1328"></a><a name="_Toc66809773"><strong>Azkaban</strong></a><strong>每天执行多少个任务</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">每天集群运行多少job?</li><li style="text-align:justify;">每个任务的资源是如何分配的？</li><li style="text-align:justify;">多个指标（200）*6=1200（1000-2000个job）</li><li style="text-align:justify;">每天集群运行多少个task? 1000*（5-8）=5000多个</li><li style="text-align:justify;">任务挂了怎么办？运行成功或者失败都会发邮件</li></ol> 
<p style="margin-left:0;text-align:justify;">Zip a.job b.job c.job   job.zip  把压缩的zip包放到azkaban的web界面上提交（指定sechduler）</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc4014"></a><a name="_Toc10725350"></a><a name="_Toc66809774"> 业务经验</a></strong></span></span> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc16580"></a><a name="_Toc10725351"></a><a name="_Toc66809775"><strong>ODS</strong></a><strong>层采用什么压缩方式和存储格式？</strong></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">压缩采用<span style="color:#ff0000;">Snappy</span>，存储采用<span style="color:#ff0000;">orc</span>，压缩比是100g数据压缩完10g左右。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725352"></a><a name="_Toc27654"></a><a name="_Toc66809776"><strong>DWD</strong></a><strong>层做了哪些事？</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">数据清洗 
  <ol><li style="text-align:justify;">空值去除</li><li style="text-align:justify;">过滤核心字段无意义的数据，比如订单表中订单id为null，支付表中支付id为空</li><li style="text-align:justify;">对手机号、身份证号等敏感数据脱敏</li><li style="text-align:justify;">对业务数据传过来的表进行维度退化和降维。</li><li style="text-align:justify;">将用户行为宽表和业务表进行数据一致性处理</li></ol></li></ol> 
<p style="margin-left:36pt;text-align:justify;">select case when a is null then b else a end as JZR,</p> 
<p style="margin-left:36pt;text-align:justify;">    ...</p> 
<p style="margin-left:36pt;text-align:justify;">from A</p> 
<ol><li style="text-align:justify;">清洗的手段</li></ol> 
<p style="margin-left:36pt;text-align:justify;">Sql、mr、rdd、kettle、Python（项目中采用sql进行清除）</p> 
<ol><li style="text-align:justify;">清洗掉多少数据算合理</li></ol> 
<p style="margin-left:36pt;text-align:justify;">1万条数据清洗掉1条。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc24096"></a><a name="_Toc10725353"></a><a name="_Toc66809777"><strong>DWS</strong></a><strong>层做了哪些事？</strong></span></span></li></ol></li></ol></li><li style="text-align:justify;">DWS层有3-5张宽表（处理100-200个指标   70%以上的需求）</li></ol> 
<p style="margin-left:36pt;text-align:justify;">具体宽表名称：用户行为宽表，用户购买商品明细行为宽表，商品宽表，购物车宽表，物流宽表、登录注册、售后等。</p> 
<ol><li style="text-align:justify;">哪个宽表最宽？大概有多少个字段？</li></ol> 
<p style="margin-left:36pt;text-align:justify;">最宽的是用户行为宽表。大概有60-100个字段</p> 
<ol><li style="text-align:justify;">具体用户行为宽表字段名称</li></ol> 
<p style="margin-left:36pt;text-align:justify;">评论、打赏、收藏、关注--商品、关注--人、点赞、分享、好价爆料、文章发布、活跃、签到、补签卡、幸运屋、礼品、金币、电商点击、gmv</p> 
<p style="margin-left:0;"><span style="color:#000000;">CREATE TABLE `app_usr_interact`(</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `stat_dt` date COMMENT '</span><span style="color:#000000;">互动日期', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `user_id` string COMMENT '</span><span style="color:#000000;">用户id', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `nickname` string COMMENT '</span><span style="color:#000000;">用户昵称', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `register_date` string COMMENT '</span><span style="color:#000000;">注册日期', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `register_from` string COMMENT '</span><span style="color:#000000;">注册来源', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `remark` string COMMENT '</span><span style="color:#000000;">细分渠道', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `province` string COMMENT '</span><span style="color:#000000;">注册省份', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `pl_cnt` bigint COMMENT '</span><span style="color:#000000;">评论次数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `ds_cnt` bigint COMMENT '</span><span style="color:#000000;">打赏次数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `sc_add` bigint COMMENT '</span><span style="color:#000000;">添加收藏', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `sc_cancel` bigint COMMENT '</span><span style="color:#000000;">取消收藏', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `gzg_add` bigint COMMENT '</span><span style="color:#000000;">关注商品', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `gzg_cancel` bigint COMMENT '</span><span style="color:#000000;">取消关注商品', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `gzp_add` bigint COMMENT '</span><span style="color:#000000;">关注人', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `gzp_cancel` bigint COMMENT '</span><span style="color:#000000;">取消关注人', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `buzhi_cnt` bigint COMMENT '</span><span style="color:#000000;">点不值次数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `zhi_cnt` bigint COMMENT '</span><span style="color:#000000;">点值次数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `zan_cnt` bigint COMMENT '</span><span style="color:#000000;">点赞次数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `share_cnts` bigint COMMENT '</span><span style="color:#000000;">分享次数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `bl_cnt` bigint COMMENT '</span><span style="color:#000000;">爆料数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `fb_cnt` bigint COMMENT '</span><span style="color:#000000;">好价发布数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `online_cnt` bigint COMMENT '</span><span style="color:#000000;">活跃次数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `checkin_cnt` bigint COMMENT '</span><span style="color:#000000;">签到次数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `fix_checkin` bigint COMMENT '</span><span style="color:#000000;">补签次数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `house_point` bigint COMMENT '</span><span style="color:#000000;">幸运屋金币抽奖次数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `house_gold` bigint COMMENT '</span><span style="color:#000000;">幸运屋积分抽奖次数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `pack_cnt` bigint COMMENT '</span><span style="color:#000000;">礼品兑换次数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `gold_add` bigint COMMENT '</span><span style="color:#000000;">获取金币', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `gold_cancel` bigint COMMENT '</span><span style="color:#000000;">支出金币', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `surplus_gold` bigint COMMENT '</span><span style="color:#000000;">剩余金币', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `event` bigint COMMENT '</span><span style="color:#000000;">电商点击次数', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `gmv_amount` bigint COMMENT 'gmv', </span></p> 
<p style="margin-left:0;"><span style="color:#000000;">  `gmv_sales` bigint COMMENT '</span><span style="color:#000000;">订单数')</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">PARTITIONED BY (  `dt` string)</span></p> 
<ol><li style="text-align:justify;">商品详情  -----  购物车  ----- 订单  ------ 付款的转换比率</li></ol> 
<p style="margin-left:36pt;text-align:justify;"><span style="color:#000000;">       5%          30%        70% </span></p> 
<ol><li style="text-align:justify;">每天的GMV是多少，哪个商品卖的最好？每天下单量多少？ 
  <ol><li style="text-align:justify;">100万的日活每天大概有10万人购买，平均每人消费100元，一天的GMV在1000万</li><li style="text-align:justify;">面膜，每天销售5000个</li><li style="text-align:justify;">每天下单量在10万左右 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc24032"></a><a name="_Toc10725354"></a><a name="_Toc66809778"><strong>分析过哪些指标（一分钟至少说出30个指标）</strong></a></span></span></li></ol></li></ol></li></ol> 
<ol><li style="text-align:justify;">离线指标</li></ol> 
<p style="margin-left:0;text-align:justify;">网站流量指标  独立访问数UV  页面访客数PV</p> 
<p style="margin-left:0;text-align:justify;">流量质量指标类  跳出率  平均页面访问时长 人均页面访问数</p> 
<ol><li style="text-align:justify;">购物车类指标 </li></ol> 
<p style="margin-left:0;text-align:justify;">加入购物车次数  加入购物车买家次数  加入购物车商品数  购物车支付转化率</p> 
<ol><li style="text-align:justify;">下单类指标 </li></ol> 
<p style="margin-left:0;text-align:justify;">下单笔数  下单金额  下单买家数  浏览下单转化率</p> 
<ol><li style="text-align:justify;">支付类指标 </li></ol> 
<p style="margin-left:0;text-align:justify;">支付金额  支付买家数 支付商品数  浏览-支付买家转化率</p> 
<p style="margin-left:0;text-align:justify;">下单-支付金额转化率  下单-支付买家数转换率</p> 
<ol><li style="text-align:justify;">交易类指标 </li></ol> 
<p style="margin-left:0;text-align:justify;">交易成功订单数  交易成功金额  交易成功买家数  交易成功商品数</p> 
<p style="margin-left:0;text-align:justify;">交易失败订单数  交易失败订单金额  交易失败买家数 </p> 
<p style="margin-left:0;text-align:justify;">交易失败商品数  退款总订单量  退款金额  退款率</p> 
<ol><li style="text-align:justify;">市场营销活动指标  </li></ol> 
<p style="margin-left:0;text-align:justify;">新增访问人数   新增注册人数  广告投资回报率  UV订单转化率</p> 
<ol><li style="text-align:justify;">风控类指标 </li></ol> 
<p style="margin-left:0;text-align:justify;">买家评价数  买家上传图片数  买家评价率  买家好评率  买家差评率</p> 
<p style="margin-left:0;text-align:justify;">物流平均配送时间</p> 
<ol><li style="text-align:justify;">投诉类指标 </li></ol> 
<p style="margin-left:0;text-align:justify;">发起投诉数  投诉率 撤销投诉(申诉数)</p> 
<ol><li style="text-align:justify;">商品类指标 </li></ol> 
<p style="margin-left:0;text-align:justify;">产品总数  SKU数  SPU数 </p> 
<p style="margin-left:0;text-align:justify;">上架商品SKU数  上架商品SPU数  上架商品数 </p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;">日活跃用户，</p> 
<p style="margin-left:0;text-align:justify;">月活跃用户，</p> 
<p style="margin-left:0;text-align:justify;">各区域Top10商品统计，</p> 
<p style="margin-left:0;text-align:justify;">季度商品品类点击率top10，</p> 
<p style="margin-left:0;text-align:justify;">用户留存，</p> 
<p style="margin-left:0;text-align:justify;">月APP的用户增长人数，</p> 
<p style="margin-left:0;text-align:justify;">广告区域点击数top3，</p> 
<p style="margin-left:0;text-align:justify;">活跃用户每天在线时长，</p> 
<p style="margin-left:0;text-align:justify;">投诉人数占比，</p> 
<p style="margin-left:0;text-align:justify;">沉默用户占比，</p> 
<p style="margin-left:0;text-align:justify;">用户的新鲜度，</p> 
<p style="margin-left:0;text-align:justify;">商品上架的sku数，</p> 
<p style="margin-left:0;text-align:justify;">同种品类的交易额排名，</p> 
<p style="margin-left:0;text-align:justify;">统计买家的评价率，</p> 
<p style="margin-left:0;text-align:justify;">用户浏览时长，</p> 
<p style="margin-left:0;text-align:justify;">统计下单的数量，</p> 
<p style="margin-left:0;text-align:justify;">统计支付的数量，</p> 
<p style="margin-left:0;text-align:justify;">统计退货的数量，</p> 
<p style="margin-left:0;text-align:justify;">用户的（日活、月活、周活），</p> 
<p style="margin-left:0;text-align:justify;">统计流失人数</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">日活，周活，月活，沉默用户占比，增长人数，活跃用户占比，在线时长统计，歌曲访问数，歌曲访问时长，各地区Top10歌曲统计 ,投诉人数占比，投诉回应时长，留存率，月留存率，转化率，GMV，复购vip率，vip人数，歌榜，挽回率，粉丝榜，打赏次数，打赏金额，发布歌曲榜单，歌曲热度榜单，歌手榜单，用户年龄组，vip年龄组占比，收藏数榜单，评论数</p> 
<ol><li style="text-align:justify;">用户活跃数统计（日活，月活，周活）</li><li style="text-align:justify;">某段时间的新增用户/活跃用户数</li><li style="text-align:justify;">页面单跳转化率统计</li><li style="text-align:justify;">活跃人数占比（占总用户比例）</li><li style="text-align:justify;">在线时长统计（活跃用户每天在线时长）</li><li style="text-align:justify;">统计本月的人均在线时长</li><li style="text-align:justify;">订单产生效率（下单的次数与访问次数比）</li><li style="text-align:justify;">页面访问时长（单个页面访问时长）   </li><li style="text-align:justify;">统计本季度付款订单</li><li style="text-align:justify;">统计某广告的区城点击数top3</li><li style="text-align:justify;">统计本月用户的流失人数</li><li style="text-align:justify;">统计本月流失人数占用户人数的比例</li><li style="text-align:justify;">统计本月APP的用户增长人数</li><li style="text-align:justify;">统计本月的沉默用户</li><li style="text-align:justify;">统计某时段的登录人数</li><li style="text-align:justify;">统计本日用户登录的次数平均值</li><li style="text-align:justify;">统计用户在某类型商品中的浏览深度（页面转跳率）</li><li style="text-align:justify;">统计用户从下单开始到交易成功的平均时长</li><li style="text-align:justify;">Top10热门商品的统计</li><li style="text-align:justify;">统计下单的数量</li><li style="text-align:justify;">统计支付的数量</li><li style="text-align:justify;">统计退货的数量</li><li style="text-align:justify;">统计动销率（有销量的商品/在线销售的宝贝）</li><li style="text-align:justify;">统计支付转化率</li><li style="text-align:justify;">统计用户的消费频率</li><li style="text-align:justify;">统计商品上架的SKU数</li><li style="text-align:justify;">统计同种品类的交易额排名</li><li style="text-align:justify;">统计按下单退款排序的top10的商品</li><li style="text-align:justify;">统计本APP的投诉人数占用户人数的比例</li><li style="text-align:justify;">用户收藏商品 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725355"></a><a name="_Toc1893"></a><a name="_Toc66809779"><strong>分析过最难的两个指标，现场手写</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;"><strong><span style="color:#ff0000;">最近连续</span><span style="color:#ff0000;">3</span></strong><strong><span style="color:#ff0000;">周活跃用户数：</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong><span style="color:#ff0000;">最近7天连续3天活跃用户数：</span></strong></p> 
<p style="margin-left:0;"></p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725356"></a><a name="_Toc20405"></a><a name="_Toc66809780"><strong>数据仓库每天跑多少张表，大概什么时候运行，运行多久？</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">基本一个项目建一个库，表格个数为初始的原始数据表格加上统计结果表格的总数。（一般70-100张表格）</p> 
<p style="margin-left:0;text-align:justify;">每天0：30开始运行。</p> 
<p style="margin-left:0;text-align:justify;">所有离线数据报表控制在8小时之内</p> 
<p style="margin-left:0;text-align:justify;">大数据实时处理部分控制在5分钟之内。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10907"></a><a name="_Toc10725357"></a><a name="_Toc66809781"><strong>数仓中使用的哪种文件存储格式</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">常用的包括：textFile，rcFile，ORC，Parquet，一般企业里使用ORC或者Parquet，因为是列式存储，且压缩比非常高，所以相比于textFile，查询速度快，占用硬盘空间少</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725358"></a><a name="_Toc14103"></a><a name="_Toc66809782"><strong>数仓中用到过哪些Shell脚本及具体功能</strong></a></span></span></li></ol></li></ol></li><li style="text-align:justify;">集群启动停止脚本（Hadoop、Flume、Kafka、Zookeeper）</li><li style="text-align:justify;">Sqoop和数仓之间的导入导出脚本</li><li style="text-align:justify;">数仓层级之间的数据导入脚本。 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725359"></a><a name="_Toc20492"></a><a name="_Toc66809783"><strong>项目中用过的报表工具</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Echarts、kibana、supesrset</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc18462"></a><a name="_Toc10725360"></a><a name="_Toc66809784"><strong>测试相关</strong></a></span></span></li></ol></li></ol></li><li style="text-align:justify;">公司有多少台测试服务器？</li></ol> 
<p style="margin-left:0;text-align:justify;">测试服务器一般三台</p> 
<ol><li style="text-align:justify;">测试数据哪来的？</li></ol> 
<p style="margin-left:0;text-align:justify;">一部分自己写Java程序自己造，一部分从生产环境上取一部分。</p> 
<ol><li style="text-align:justify;">如何保证写的sql正确性</li></ol> 
<p style="margin-left:0;text-align:justify;">需要造一些特定的测试数据，测试。</p> 
<p style="margin-left:0;text-align:justify;">离线数据和实时数据分析的结果比较。</p> 
<ol><li style="text-align:justify;">测试环境什么样？</li></ol> 
<p style="margin-left:0;text-align:justify;">测试环境的配置是生产的一半</p> 
<ol><li style="text-align:justify;">测试之后如何上线？</li></ol> 
<p style="margin-left:0;text-align:justify;">上线的时候，将脚本打包，提交git。先发邮件抄送经理和总监，运维。通过之后跟运维一起上线。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725361"></a><a name="_Toc23680"></a><a name="_Toc66809785"><strong>项目实际工作流程</strong></a></span></span></li></ol></li></ol></li><li style="text-align:justify;">先与产品讨论，看报表的各个数据从哪些埋点中取</li><li style="text-align:justify;">将业务逻辑过程设计好，与产品确定后开始开发</li><li style="text-align:justify;">开发出报表SQL脚本，并且跑几天的历史数据，观察结果</li><li style="text-align:justify;">将报表放入调度任务中，第二天给产品看结果。</li><li style="text-align:justify;">周期性将表结果导出或是导入后台数据库，生成可视化报表 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725362"></a><a name="_Toc6466"></a><a name="_Toc66809786"><strong>项目中实现一个需求大概多长时间</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">刚入职第一个需求大概需要7天左右。</p> 
<p style="margin-left:0;text-align:justify;">对业务熟悉后，平均一天一个需求。</p> 
<p style="margin-left:0;text-align:justify;">影响时间的因素：开会讨论需求、表的权限申请、测试等</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc10725363"></a><a name="_Toc26167"></a><a name="_Toc66809787"><strong>项目在3年内迭代次数，每一个项目具体是如何迭代的。</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">差不多一个月会迭代一次。就产品或我们提出优化需求，然后评估时间。每周我们都会开会做下周计划和本周总结。</p> 
<p style="margin-left:0;text-align:justify;">有时候也会去预研一些新技术。</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;"><a name="_Toc25307"></a><a name="_Toc10725364"></a><a name="_Toc66809788"><strong>项目开发中每天做什么事</strong></a></span></span></li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">新需求比如埋点或是报表来了之后，需要设计做的方案，设计完成之后跟产品讨论，再开发。</p> 
<p style="margin-left:0;text-align:justify;">数仓的任何步骤出现问题，需要查看问题，比如日活，月活下降等。</p> 
<ol><li style="text-align:justify;"><strong><a name="_Toc15060"></a><a name="_Toc66809789"></a><a name="_Toc10725365"> JavaSE</a>（答案精简）</strong></li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725366"></a><a name="_Toc8169"></a><a name="_Toc66809790"> hashMap</a>底层源码，数据结构</strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">hashMap的底层结构在jdk1.7中由数组+链表实现，在jdk1.8中由数组+链表+红黑树实现，以数组+链表的结构为例。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong><span style="color:#000000;">JDK1.8</span></strong><strong><span style="color:#000000;">之前Put方法：</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong><span style="color:#000000;">JDK1.8</span></strong><strong><span style="color:#000000;">之后Put方法：</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725367"></a><a name="_Toc26015"></a><a name="_Toc66809791"> Java</a>自带有哪几种线程池？</strong></span></span></li></ol> 
<ol><li style="text-align:justify;">newCachedThreadPool</li></ol> 
<p style="margin-left:0;text-align:justify;">创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是：</p> 
<p style="margin-left:0;text-align:justify;">工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</p> 
<p style="margin-left:0;text-align:justify;">如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p> 
<p style="margin-left:0;text-align:justify;">在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</p> 
<ol><li style="text-align:justify;">newFixedThreadPool</li></ol> 
<p style="margin-left:0;text-align:justify;">创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p> 
<ol><li style="text-align:justify;">newSingleThreadExecutor</li></ol> 
<p style="margin-left:0;text-align:justify;">创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p> 
<ol><li style="text-align:justify;">newScheduleThreadPool</li></ol> 
<p style="margin-left:0;text-align:justify;">创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。延迟3秒执行。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc16846"></a><a name="_Toc10725368"></a><a name="_Toc66809792"> HashMap</a>和HashTable区别</strong></span></span></li></ol> 
<ol><li><span style="color:#000000;">线程安全性不同</span></li></ol> 
<p style="margin-left:0;text-align:justify;">HashMap是线程不安全的，HashTable是线程安全的，其中的方法是Synchronize的，在多线程并发的情况下，可以直接使用HashTabl，但是使用HashMap时必须自己增加同步处理。</p> 
<ol><li><span style="color:#000000;">是否提供contains方法</span></li></ol> 
<p style="margin-left:0;text-align:justify;">HashMap只有containsValue和containsKey方法；HashTable有contains、containsKey和containsValue三个方法，其中contains和containsValue方法功能相同。</p> 
<ol><li><span style="color:#000000;">key</span><span style="color:#000000;">和value是否允许null值</span></li></ol> 
<p style="margin-left:0;text-align:justify;">Hashtable中，key和value都不允许出现null值。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。</p> 
<ol><li><span style="color:#000000;">数组初始化和扩容机制</span></li></ol> 
<p style="margin-left:0;text-align:justify;"> HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。</p> 
<p style="margin-left:0;text-align:justify;"> Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725369"></a><a name="_Toc16575"></a><a name="_Toc66809793"> TreeSet</a>和HashSet区别</strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">HashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。</p> 
<p style="margin-left:0;text-align:justify;">TreeSet是采用树结构实现(红黑树算法)。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log (n))的方法。它还提供了一些方法来处理排序的set，如first(), last(), headSet(), tailSet()等等。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc30494"></a><a name="_Toc10725370"></a><a name="_Toc66809794"> String buffer</a>和String build区别</strong></span></span></li></ol> 
<ol><li style="text-align:justify;">StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，</li><li style="text-align:justify;">只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 </li><li style="text-align:justify;">在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低</li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725371"></a><a name="_Toc12639"></a><a name="_Toc66809795"> Final</a>、Finally、Finalize</strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;"><strong>final</strong>：修饰符（关键字）有三种用法：修饰类、变量和方法。修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。修饰方法时，也同样只能使用，不能在子类中被重写。</p> 
<p style="margin-left:0;text-align:justify;"><strong>finally</strong>：通常放在try…catch的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。</p> 
<p style="margin-left:0;text-align:justify;"><strong>finalize</strong>：Object类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725372"></a><a name="_Toc17845"></a><a name="_Toc66809796"> ==</a>和Equals区别</strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">== : 如果比较的是基本数据类型，那么比较的是变量的值</p> 
<p style="margin-left:0;text-align:justify;">如果比较的是引用数据类型，那么比较的是地址值（两个对象是否指向同一块内存）</p> 
<p style="margin-left:0;text-align:justify;">equals:如果没重写equals方法比较的是两个对象的地址值。</p> 
<p style="margin-left:0;text-align:justify;">如果重写了equals方法后我们往往比较的是对象中的属性的内容</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;">equals方法是从Object类中继承的，默认的实现就是使用==</p> 
<p style="margin-left:0;"><span style="color:#000000;">  </span></p> 
<ol><li style="text-align:justify;"><strong><a name="_Toc28119"></a><a name="_Toc66809797"></a><a name="_Toc10725373"> Redis</a>（答案精简）</strong></li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809798"> 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级</a></strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;"><strong>缓存雪崩</strong></p> 
<p style="margin-left:0;text-align:justify;">缓存雪崩我们可以简单的理解为：<strong>由于原有缓存失效，新缓存未到期间</strong>(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p> 
<p style="margin-left:0;text-align:justify;">缓存正常从Redis中获取，示意图如下：</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;">缓存失效瞬间示意图如下：</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">缓存失效时的雪崩效应对底层系统的冲击非常可怕！大多数系统设计者考虑用<span style="color:#ff0000;">加锁</span>或者<span style="color:#ff0000;">队列</span>的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p> 
<p style="margin-left:0;text-align:justify;">以下简单介绍两种实现方式的伪代码：</p> 
<p style="margin-left:0;text-align:justify;">（1）碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队，伪代码如下：</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！</p> 
<p style="margin-left:0;text-align:justify;"><strong>注意</strong>：加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！</p> 
<p style="margin-left:0;text-align:justify;">（2）还有一个解决办法解决方案是：给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存，实例伪代码如下：</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">解释说明：</p> 
<p style="margin-left:0;text-align:justify;">1、缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存；</p> 
<p style="margin-left:0;text-align:justify;">2、缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。</p> 
<p style="margin-left:0;text-align:justify;">关于缓存崩溃的解决方法，这里提出了三种方案：使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间，还有一各被称为“二级缓存”的解决方法，有兴趣的读者可以自行研究。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>缓存穿透</strong></p> 
<p style="margin-left:0;text-align:justify;">缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p> 
<p style="margin-left:0;text-align:justify;">有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用<span style="color:#ff0000;">布隆过滤器</span>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p> 
<p style="margin-left:0;text-align:justify;">另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴！</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;text-align:justify;">把空结果，也给缓存起来，这样下次同样的请求就可以直接返回空了，即可以避免当查询的值为空时引起的缓存穿透。同时也可以单独设置个缓存区域存储空值，对要查询的key进行预先校验，然后再放行给后面的正常缓存处理逻辑。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>缓存预热</strong></p> 
<p style="margin-left:0;text-align:justify;">缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p> 
<p style="margin-left:0;text-align:justify;">解决思路：</p> 
<ol><li style="text-align:justify;">直接写个缓存刷新页面，上线时手工操作下；</li><li style="text-align:justify;">数据量不大，可以在项目启动的时候自动进行加载；</li><li style="text-align:justify;">定时刷新缓存；</li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>缓存更新</strong></p> 
<p style="margin-left:0;text-align:justify;">除了缓存服务器自带的缓存失效策略之外（Redis默认的有6种策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p> 
<ol><li style="text-align:justify;">定时去清理过期的缓存；</li><li style="text-align:justify;">当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li></ol> 
<p style="margin-left:0;text-align:justify;">两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>缓存降级</strong></p> 
<p style="margin-left:0;text-align:justify;">当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p> 
<p style="margin-left:0;text-align:justify;">降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p> 
<p style="margin-left:0;text-align:justify;">在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p> 
<ol><li style="text-align:justify;">一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li><li style="text-align:justify;">警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li><li style="text-align:justify;">错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li><li style="text-align:justify;">严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725375"></a><a name="_Toc18174"></a><a name="_Toc66809799"> 哨兵模式</a></strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。</p> 
<p style="margin-left:0;text-align:justify;">哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">这里的哨兵有两个作用</p> 
<ol><li style="text-align:justify;">通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li style="text-align:justify;">当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</li></ol> 
<p style="margin-left:0;text-align:justify;">然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p> 
<p style="margin-left:0;text-align:justify;">用文字描述一下故障切换（failover）的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc27554"></a><a name="_Toc10725376"></a><a name="_Toc66809800"> 数据类型</a></strong></span></span></li></ol> 
<table align="left" border="1" cellspacing="0" style="margin-left:6.75pt;width:412.7pt;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:93.1pt;"> <p style="margin-left:0;"><span style="color:#000000;">string</span></p> </td><td style="border-color:#000000;vertical-align:top;width:319.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">字符串</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:93.1pt;"> <p style="margin-left:0;"><span style="color:#000000;">list</span></p> </td><td style="vertical-align:top;width:319.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">可以重复的集合</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:93.1pt;"> <p style="margin-left:0;"><span style="color:#000000;">set</span></p> </td><td style="vertical-align:top;width:319.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">不可以重复的集合</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:93.1pt;"> <p style="margin-left:0;"><span style="color:#000000;">hash</span></p> </td><td style="vertical-align:top;width:319.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">类似于Map&lt;String,String&gt;</span></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:93.1pt;"> <p style="margin-left:0;"><span style="color:#000000;">zset(sorted set</span><span style="color:#000000;">）</span></p> </td><td style="vertical-align:top;width:319.6pt;"> <p style="margin-left:0;"><span style="color:#000000;">带分数的set</span></p> </td></tr></tbody></table> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725377"></a><a name="_Toc21921"></a><a name="_Toc66809801"> 持久化</a></strong></span></span></li></ol> 
<ol><li style="text-align:justify;">RDB持久化： 
  <ol><li style="text-align:justify;">在指定的时间间隔内持久化</li><li style="text-align:justify;">服务shutdown会自动持久化</li><li style="text-align:justify;">输入bgsave也会持久化</li></ol></li><li style="text-align:justify;">AOF :  以日志形式记录每个更新操作</li></ol> 
<p style="margin-left:0;">Redis重新启动时读取这个文件，重新执行新建、修改数据的命令恢复数据。</p> 
<p style="margin-left:0;"><strong><span style="color:#000000;">保存策略：</span></strong></p> 
<p style="margin-left:0;">推荐（并且也是默认）的措施为每秒持久化一次，这种策略可以兼顾速度和安全性。</p> 
<p style="margin-left:0;"><strong><span style="color:#000000;">缺点：</span></strong></p> 
<ol><li> 
  <ol><li style="text-align:justify;">比起RDB占用更多的磁盘空间</li><li style="text-align:justify;">恢复备份速度要慢</li><li style="text-align:justify;">每次读写都同步的话，有一定的性能压力</li><li style="text-align:justify;">存在个别Bug，造成恢复不能</li></ol></li></ol> 
<p style="margin-left:0;"><strong><span style="color:#000000;">选择策略：</span></strong></p> 
<p style="margin-left:0;">官方推荐：</p> 
<p style="margin-left:0;">如果对数据不敏感，可以选单独用RDB；不建议单独用AOF，因为可能出现Bug;如果只是做纯内存缓存，可以都不用</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc19667"></a><a name="_Toc10725378"></a><a name="_Toc66809802"> 悲观锁</a></strong></span></span></li></ol> 
<p style="margin-left:0;">所谓悲观锁：具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p> 
<p style="margin-left:0;">简单来说：执行操作前假设当前的操作肯定（或有很大几率）会被打断（悲观）。基于这个假设，我们在做操作前就会把相关资源锁定，不允许自己执行期间有其他操作干扰。</p> 
<p style="margin-left:0;">悲观锁的并发性能差，但是能保证不会发生脏数据的可能性小一点。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc20700"></a><a name="_Toc10725379"></a><a name="_Toc66809803"> 乐观锁</a></strong></span></span></li></ol> 
<p style="margin-left:0;">执行操作前假设当前操作不会被打断（乐观）。基于这个假设，我们在做操作前不会锁定资源，万一发生了其他操作的干扰，那么本次操作将被放弃。Redis使用的就是乐观锁。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725380"></a><a name="_Toc11349"></a><a name="_Toc26338"></a><a name="_Toc66809804"> redis</a>是单线程的，为什么那么快</strong></span></span></li></ol> 
<ol><li style="text-align:justify;">完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。</li><li style="text-align:justify;">数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的</li><li style="text-align:justify;">采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li><li style="text-align:justify;">使用多路I/O复用模型，非阻塞IO</li><li style="text-align:justify;">使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li></ol> 
<ol><li style="text-align:justify;"><strong><a name="_Toc66809805"> MySql</a></strong></li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc13786"></a><a name="_Toc66809806"> MyISAM</a>与InnoDB的区别</strong></span></span></li></ol> 
<table border="1" cellspacing="0" style="margin-left:-.25pt;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:52.15pt;"> <p style="margin-left:0;"><strong>对比项</strong></p> </td><td style="border-color:#000000;vertical-align:top;width:142.6pt;"> <p style="margin-left:0;"><strong>MyISAM</strong></p> </td><td style="border-color:#000000;vertical-align:top;width:248.45pt;"> <p style="margin-left:0;"><strong>InnoDB</strong></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:52.15pt;"> <p style="margin-left:0;"><strong>外键</strong></p> </td><td style="vertical-align:top;width:142.6pt;"> <p style="margin-left:0;"><strong>不支持</strong></p> </td><td style="vertical-align:top;width:248.45pt;"> <p style="margin-left:0;"><strong>支持</strong></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:52.15pt;"> <p style="margin-left:0;"><strong>事务</strong></p> </td><td style="vertical-align:top;width:142.6pt;"> <p style="margin-left:0;"><strong>不支持</strong></p> </td><td style="vertical-align:top;width:248.45pt;"> <p style="margin-left:0;"><strong>支持</strong></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:52.15pt;"> <p style="margin-left:0;"><strong>行表锁</strong></p> </td><td style="vertical-align:top;width:142.6pt;"> <p style="margin-left:0;"><strong>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</strong></p> </td><td style="vertical-align:top;width:248.45pt;"> <p style="margin-left:0;"><strong>行锁,操作时只锁某一行，不对其它行有影响，</strong></p> <p style="margin-left:0;"><strong>适合高并发的操作</strong></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:52.15pt;"> <p style="margin-left:0;"><strong>缓存</strong></p> </td><td style="vertical-align:top;width:142.6pt;"> <p style="margin-left:0;"><strong>只缓存索引，不缓存真实数据</strong></p> </td><td style="vertical-align:top;width:248.45pt;"> <p style="margin-left:0;"><strong>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</strong></p> </td></tr></tbody></table> 
<p style="margin-left:0;"></p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725382"></a><a name="_Toc3432"></a><a name="_Toc66809807"> 索引</a></strong></span></span></li></ol> 
<p style="margin-left:0;"><strong><span style="color:#000000;">数据结构：B+Tree</span></strong></p> 
<p style="margin-left:0;">一般来说能够达到range就可以算是优化了</p> 
<p style="margin-left:0;"><strong><span style="color:#000000;">口诀（两个法则加6种索引失效的情况）</span></strong></p> 
<p style="margin-left:0;">全值匹配我最爱，最左前缀要遵守；</p> 
<p style="margin-left:0;">带头大哥不能死，中间兄弟不能断；</p> 
<p style="margin-left:0;">索引列上少计算，范围之后全失效；</p> 
<p style="margin-left:0;">LIKE百分写最右，覆盖索引不写*；</p> 
<p style="margin-left:0;">不等空值还有OR，索引影响要注意；</p> 
<p style="margin-left:0;">VAR引号不可丢，SQL优化有诀窍。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc4762"></a><a name="_Toc66809808"> b-tree</a>和b+tree的区别</strong></span></span></li></ol> 
<ol><li style="text-align:justify;">B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。</li><li style="text-align:justify;">在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。</li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc26654"></a><a name="_Toc66809809"> MySQL</a>的事务</strong></span></span></li></ol> 
<p style="margin-left:0;"><strong><span style="color:#000000;">一、事务的基本要素（ACID）</span></strong></p> 
<ol><li style="text-align:justify;">原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位</li><li style="text-align:justify;">一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</li><li style="text-align:justify;">隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</li><li style="text-align:justify;">持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</li></ol> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong><span style="color:#000000;">二、事务的并发问题</span></strong></p> 
<ol><li style="text-align:justify;">脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li style="text-align:justify;">不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致</li><li style="text-align:justify;">幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li></ol> 
<p style="margin-left:0;">小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong><span style="color:#000000;">三、MySQL事务隔离级别</span></strong></p> 
<p style="margin-left:0;"><span style="color:#000000;">事务隔离级别                       脏读        不可重复读      幻读</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">读未提交（read-uncommitted）       是          是              是</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">不可重复读（read-committed）       否          是              是</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">可重复读（repeatable-read）        否          否              是</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">串行化（serializable）             否          否              否</span></p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc11551"></a><a name="_Toc10725383"></a><a name="_Toc66809810"> 常见面试sql</a></strong></span></span></li></ol> 
<ol><li style="text-align:justify;">用一条SQL语句查询出每门课都大于80分的学生姓名</li></ol> 
<p style="margin-left:0;">name   kecheng   fenshu<br>     张三    语文    81<br>     张三    数学    75<br>     李四    语文    76<br>     李四    数学     90<br>     王五    语文    81<br>     王五    数学    100<br>     王五    英语    90<br>     A: select distinct name from table where name not in (select distinct name from table where fenshu&lt;=80)<br>     B：select name from table group by name having min(fenshu)&gt;80</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;">学生表</li></ol> 
<p style="margin-left:0;text-align:justify;">自动编号   学号  姓名 课程编号 课程名称 分数<br>     1     2005001 张三   0001   数学   69<br>     2     2005002 李四   0001   数学   89<br>     3     2005001 张三   0001   数学   69<br>     删除除了自动编号不同, 其他都相同的学生冗余信息<br><br>     A: delete tablename where 自动编号 not in(select min(自动编号) from tablename group by学号, 姓名, 课程编号, 课程名称, 分数)</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;">一个叫team的表，里面只有一个字段name,一共有4条纪录，分别是a,b,c,d,对应四个球队，现在四个球队进行比赛，用一条sql语句显示所有可能的比赛组合</li></ol> 
<p style="margin-left:0;text-align:justify;">select a.name, b.name<br>     from team a, team b <br>     where a.name &lt; b.name</p> 
<ol><li style="text-align:justify;">面试题：怎么把这样一个</li></ol> 
<p style="margin-left:0;text-align:justify;">year   month amount<br>     1991   1     1.1<br>     1991   2     1.2<br>     1991   3     1.3<br>     1991   4     1.4<br>     1992   1     2.1<br>     1992   2     2.2<br>     1992   3     2.3<br>     1992   4     2.4<br>     查成这样一个结果<br>     year m1  m2  m3   m4<br>     1991 1.1 1.2 1.3 1.4<br>     1992 2.1 2.2 2.3 2.4 <br><br>     答案<br>     select year, <br>     (select amount from aaa m where month=1 and m.year=aaa.year) as m1,<br>     (select amount from aaa m where month=2 and m.year=aaa.year) as m2,<br>     (select amount from aaa m where month=3 and m.year=aaa.year) as m3,<br>     (select amount from  aaa m where month=4 and m.year=aaa.year) as m4<br>     from aaa group by year</p> 
<ol><li style="text-align:justify;">说明：复制表(只复制结构,源表名：a新表名：b)</li></ol> 
<p style="margin-left:0;text-align:justify;">SQL: select * into b from a where 1&lt;&gt;1 (where1=1，拷贝表结构和数据内容)<br>     ORACLE:create table b</p> 
<p style="margin-left:0;text-align:justify;">As</p> 
<p style="margin-left:0;text-align:justify;">Select * from a where 1=2</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">[&lt;&gt;（不等于）(SQL Server Compact)</p> 
<p style="margin-left:0;text-align:justify;">比较两个表达式。 当使用此运算符比较非空表达式时，如果左操作数不等于右操作数，则结果为 TRUE。 否则，结果为 FALSE。]</p> 
<ol><li style="text-align:justify;">原表:<br> courseid coursename score<br> -------------------------------------<br> 1 java 70<br> 2 oracle 90<br> 3 xml 40<br> 4 jsp 30<br> 5 servlet 80<br><span style="color:#000000;">-------------------------------------</span><br> 为了便于阅读,查询此表后的结果显式如下(及格分数为60):<br> courseid coursename score mark<br><span style="color:#000000;">---------------------------------------------------<br> 1 java 70 pass<br> 2 oracle 90 pass<br> 3 xml 40 fail<br> 4 jsp 30 fail<br> 5 servlet 80 pass<br> ---------------------------------------------------</span><br><span style="color:#000000;">写出此查询语句<br> select courseid, coursename ,score ,if(score&gt;=60, "pass","fail")  as mark from course</span></li><li style="text-align:justify;"><span style="color:#000000;">表名：购物信息</span></li></ol> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">购物人      商品名称     数量</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">A            </span><span style="color:#000000;">甲          2</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">B            </span><span style="color:#000000;">乙          4</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">C            </span><span style="color:#000000;">丙          1</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">A            </span><span style="color:#000000;">丁          2</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">B            </span><span style="color:#000000;">丙          5</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">……</span></p> 
<p style="margin-left:0;"><span style="background-color:#ffffff;"> </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">给出所有购入商品为两种或两种以上的购物人记录</span></p> 
<p style="margin-left:0;"><span style="background-color:#ffffff;"> </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">答：select * from 购物信息 where 购物人 in (select 购物人 from 购物信息 group by 购物人 having count(*) &gt;= 2);</span></p> 
<ol><li style="text-align:justify;"><span style="color:#000000;">info </span><span style="color:#000000;">表</span></li></ol> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">date          result</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">2005-05-09    win</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">2005-05-09    lose </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">2005-05-09    lose </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">2005-05-09    lose </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">2005-05-10    win </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">2005-05-10    lose </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">2005-05-10    lose </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">如果要生成下列结果, 该如何写sql语句? </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">win           lose</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">2005-05-09  2   2 </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">2005-05-10  1   2 </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">答案： </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">(1) select date, sum(case when result = "win" then 1 else 0 end) as "win", sum(case when result = "lose" then 1 else 0 end) as "lose" from info group by date; </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">(2) select a.date, a.result as win, b.result as lose </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">　　from </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">　　(select date, count(result) as result from info where result = "win" group by date) as a </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">　　join </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">　　(select date, count(result) as result from info where result = "lose" group by date) as b </span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">　　on a.date = b.date;</span></p> 
<p style="margin-left:0;"></p> 
<ol><li style="text-align:justify;"><strong><a name="_Toc31536"></a><a name="_Toc10725384"></a><a name="_Toc66809811"> JVM</a></strong></li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725385"></a><a name="_Toc5170"></a><a name="_Toc66809812"> JVM</a>内存分哪几个区，每个区的作用是什么?</strong></span></span></li></ol> 
<p style="margin-left:0;"><span style="color:#000000;">  </span></p> 
<p style="margin-left:0;text-align:justify;">java虚拟机主要分为以下几个区:</p> 
<ol><li style="text-align:justify;">方法区： 
  <ol><li style="text-align:justify;">有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载</li><li style="text-align:justify;">方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。</li><li style="text-align:justify;">该区域是被线程共享的。</li><li style="text-align:justify;">方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</li></ol></li><li style="text-align:justify;">虚拟机栈: 
  <ol><li style="text-align:justify;"> 虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</li><li style="text-align:justify;">虚拟机栈是线程私有的，它的生命周期与线程相同。</li><li style="text-align:justify;">局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定</li><li style="text-align:justify;">操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</li><li style="text-align:justify;">每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</li></ol></li><li style="text-align:justify;">本地方法栈：</li></ol> 
<p style="margin-left:0;text-align:justify;">本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务。</p> 
<ol><li style="text-align:justify;">堆：</li></ol> 
<p style="margin-left:0;text-align:justify;">java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。</p> 
<ol><li style="text-align:justify;">程序计数器：</li></ol> 
<p style="margin-left:0;text-align:justify;">内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。</p> 
<p style="margin-left:0;"></p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725386"></a><a name="_Toc28733"></a><a name="_Toc66809813"> Java</a>类加载过程?</strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">Java类加载需要经历一下几个过程：</p> 
<ol><li style="text-align:justify;">加载</li></ol> 
<p style="margin-left:0;text-align:justify;">加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：</p> 
<ol><li> 
  <ol><li style="text-align:justify;">通过一个类的全限定名获取该类的二进制流。</li><li style="text-align:justify;">将该二进制流中的静态存储结构转化为方法去运行时数据结构。 </li><li style="text-align:justify;">在内存中生成该类的Class对象，作为该类的数据访问入口。</li></ol></li><li style="text-align:justify;">验证</li></ol> 
<p style="margin-left:0;text-align:justify;">验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:</p> 
<ol><li> 
  <ol><li style="text-align:justify;">文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.</li><li style="text-align:justify;">元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</li><li style="text-align:justify;">字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。</li><li style="text-align:justify;">符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。</li><li style="text-align:justify;">准备</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p> 
<ol><li style="text-align:justify;">解析</li></ol> 
<p style="margin-left:0;text-align:justify;">该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。</p> 
<ol><li style="text-align:justify;">初始化</li></ol> 
<p style="margin-left:0;text-align:justify;">初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</p> 
<p style="margin-left:0;"></p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc5334"></a><a name="_Toc10725387"></a><a name="_Toc66809814"> java</a>中垃圾收集的方法有哪些?</strong></span></span></li></ol> 
<ol><li style="text-align:justify;"><strong>引用计数法</strong>   应用于：微软的COM/ActionScrip3/Python等 
  <ol><li style="text-align:justify;">如果对象没有被引用，就会被回收，缺点：需要维护一个引用计算器</li></ol></li><li style="text-align:justify;"><strong>复制算法</strong>  年轻代中使用的是Minor GC，这种GC算法采用的是复制算法(Copying) 
  <ol><li style="text-align:justify;">效率高，缺点：需要内存容量大，比较耗内存</li><li style="text-align:justify;">使用在占空间比较小、刷新次数多的新生区</li></ol></li><li style="text-align:justify;"><strong>标记清除</strong>  老年代一般是由标记清除或者是标记清除与标记整理的混合实现 
  <ol><li style="text-align:justify;">效率比较低，会差生碎片。</li></ol></li><li style="text-align:justify;"><strong>标记压缩</strong>  老年代一般是由标记清除或者是标记清除与标记整理的混合实现 
  <ol><li style="text-align:justify;"><span style="color:#000000;">效率低速度慢，需要移动对象，但不会产生碎片。</span></li></ol></li><li style="text-align:justify;"><strong>标记清除压缩 </strong>标记清除-标记压缩的集合，多次GC后才Compact 
  <ol><li style="text-align:justify;"><span style="color:#000000;">使用于占空间大刷新次数少的养老区，是3 4的集合体</span></li></ol></li></ol> 
<p style="margin-left:0;"></p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725388"></a><a name="_Toc13076"></a><a name="_Toc66809815"> 如何判断一个对象是否存活?(或者GC对象的判定方法)</a></strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">判断一个对象是否存活有两种方法:</p> 
<ol><li style="text-align:justify;">引用计数法</li><li style="text-align:justify;">可达性算法(引用链法)</li><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725389"></a><a name="_Toc20911"></a><a name="_Toc66809816"> 什么是类加载器，类加载器有哪些?</a></strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p> 
<p style="margin-left:0;text-align:justify;">主要有一下四种类加载器:</p> 
<ol><li style="text-align:justify;">启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li><li style="text-align:justify;">扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li style="text-align:justify;">系统类加载器（system class loader）也叫应用类加载器：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li><li style="text-align:justify;">用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc10725390"></a><a name="_Toc29066"></a><a name="_Toc66809817"> 简述Java内存分配与回收策略以及Minor GC和Major GC（full GC）</a></strong></span></span></li></ol> 
<p style="margin-left:0;"><strong>内存分配：</strong></p> 
<ol><li style="text-align:justify;">栈区：栈分为java虚拟机栈和本地方法栈</li><li style="text-align:justify;">堆区：堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，主要放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。</li><li style="text-align:justify;">方法区：被所有线程共享区域，用于存放已被虚拟机加载的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（permanment generation）</li><li style="text-align:justify;">程序计数器：当前线程所执行的行号指示器。通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。线程私有的。</li></ol> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>回收策略以及Minor GC和Major GC：</strong></p> 
<ol><li style="text-align:justify;">对象优先在堆的Eden区分配。</li><li style="text-align:justify;">大对象直接进入老年代。</li><li style="text-align:justify;">长期存活的对象将直接进入老年代。</li></ol> 
<p style="margin-left:0;text-align:justify;">当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。</p> 
<ol><li style="text-align:justify;"><strong><a name="_Toc10210"></a><a name="_Toc66809818"> JUC</a></strong></li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809819"> Synchronized</a>与Lock的区别</strong></span></span></li></ol> 
<ol><li style="text-align:justify;">Synchronized能实现的功能Lock都可以实现，而且Lock比Synchronized更好用，更灵活。</li><li style="text-align:justify;">Synchronized可以自动上锁和解锁；Lock需要手动上锁和解锁</li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809820"> Runnable</a>和Callable的区别</strong></span></span></li></ol> 
<ol><li style="text-align:justify;">Runnable接口中的方法没有返回值；Callable接口中的方法有返回值</li><li style="text-align:justify;">Runnable接口中的方法没有抛出异常；Callable接口中的方法抛出了异常</li><li style="text-align:justify;">Runnable接口中的落地方法是call方法；Callable接口中的落地方法是run方法</li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809821"> 什么是分布式锁</a></strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。分布式锁可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存，如 Redis，通过set (key,value,nx,px,timeout)方法添加分布式锁。</p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#555555;"><strong><a name="_Toc66809822"> 什么是分布式事务</a></strong></span></span></li></ol> 
<p style="margin-left:0;text-align:justify;">分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#00b050;">-----------------------------------------------------------------------------------</span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:center;">如果你是大数据从业者，建议关注下公众号【<strong><span style="color:#ff0000;">五分钟学大数据</span></strong>】，本号专注于大数据技术研究，绝对能让你在大数据技术方面有所收获！</p> 
<p style="margin-left:0;text-align:center;"><strong>可直接扫码关注</strong></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="194" src="https://images2.imgbox.com/fd/d8/Xdrc9vz7_o.png" width="194"></p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54133ff11bbb74aeb5e5666deb0d723d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu16.04使用华为4G路由器（随行wifi）USB直连</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7352da95f6a013d8eba4269c5e1f4d81/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">面试速记之Java SE</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>