<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>工具系列：TensorFlow决策森林_(3)使用dtreeviz可视化 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="工具系列：TensorFlow决策森林_(3)使用dtreeviz可视化" />
<meta property="og:description" content="文章目录 介绍设置安装 TF-DF 和 dtreeviz导入库 可视化分类树加载、清洗和准备数据分割训练/测试集并训练模型训练一个随机森林分类器显示决策树检查叶节点统计信息决策树如何对实例进行分类特征空间划分 可视化回归树加载、清洗和准备数据分割训练/测试集并训练模型训练一个随机森林回归器显示决策树检查叶子节点统计信息决策树如何预测实例的值特征空间划分 介绍 之前的教程演示了如何使用TensorFlow的决策森林（随机森林、梯度提升树和CART）分类器和回归器来准备数据、训练和评估。 （我们将TensorFlow决策森林缩写为TF-DF。）您还学会了如何使用内置的plot_model_in_colab()函数可视化树，并显示特征重要性度量。
本教程的目标是通过可视化更深入地解释分类器和回归器决策树。我们将查看详细的树结构图示，以及决策树如何划分特征空间以做出决策的描绘。树结构图帮助我们理解模型的行为，特征空间图帮助我们通过展示特征和目标变量之间的关系来理解数据。
我们将使用的可视化库称为dtreeviz，为了保持一致性，我们将重复使用初学者教程中的企鹅和鲍鱼数据
在本教程中，您将学习如何：
显示TF-DF森林中决策树的结构更改dtreeviz树结构图的大小和样式绘制叶子信息，例如每个叶子中的实例数、每个叶子中目标值的分布以及关于叶子的各种统计信息跟踪树对特定实例的解释，并显示从根到叶子的路径，以进行预测打印树如何解释实例的英文解释查看一维和二维特征空间，以了解模型如何将它们划分为相似实例的区域 设置 安装 TF-DF 和 dtreeviz # 安装tensorflow_decision_forests库 !pip install -q -U tensorflow_decision_forests # 安装 dtreeviz 库 !pip install -q -U dtreeviz 导入库 import tensorflow_decision_forests as tfdf import tensorflow as tf import os import numpy as np import pandas as pd import tensorflow as tf import math import dtreeviz from matplotlib import pyplot as plt from IPython import display # 避免“Arial字体未找到”的警告 import logging logging." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/60f35f7a454ab364078a550ee3b9dd0c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-25T00:30:31+08:00" />
<meta property="article:modified_time" content="2023-12-25T00:30:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">工具系列：TensorFlow决策森林_(3)使用dtreeviz可视化</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_2" rel="nofollow">介绍</a></li><li><a href="#_19" rel="nofollow">设置</a></li><li><ul><li><a href="#_TFDF__dtreeviz_21" rel="nofollow">安装 TF-DF 和 dtreeviz</a></li><li><a href="#_35" rel="nofollow">导入库</a></li></ul> 
   </li><li><a href="#_118" rel="nofollow">可视化分类树</a></li><li><ul><li><a href="#_122" rel="nofollow">加载、清洗和准备数据</a></li><li><a href="#_330" rel="nofollow">分割训练/测试集并训练模型</a></li><li><a href="#_346" rel="nofollow">训练一个随机森林分类器</a></li><li><a href="#_407" rel="nofollow">显示决策树</a></li><li><a href="#_549" rel="nofollow">检查叶节点统计信息</a></li><li><a href="#_664" rel="nofollow">决策树如何对实例进行分类</a></li><li><a href="#_721" rel="nofollow">特征空间划分</a></li></ul> 
   </li><li><a href="#_807" rel="nofollow">可视化回归树</a></li><li><ul><li><a href="#_811" rel="nofollow">加载、清洗和准备数据</a></li><li><a href="#_926" rel="nofollow">分割训练/测试集并训练模型</a></li><li><a href="#_947" rel="nofollow">训练一个随机森林回归器</a></li><li><a href="#_1001" rel="nofollow">显示决策树</a></li><li><a href="#_1120" rel="nofollow">检查叶子节点统计信息</a></li><li><a href="#_1242" rel="nofollow">决策树如何预测实例的值</a></li><li><a href="#_1316" rel="nofollow">特征空间划分</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_2"></a>介绍</h3> 
<p>之前的教程演示了如何使用TensorFlow的决策森林（随机森林、梯度提升树和CART）分类器和回归器来准备数据、训练和评估。 （我们将TensorFlow决策森林缩写为TF-DF。）您还学会了如何使用内置的<code>plot_model_in_colab()</code>函数可视化树，并显示特征重要性度量。</p> 
<p>本教程的目标是通过可视化更深入地解释分类器和回归器决策树。我们将查看详细的树结构图示，以及决策树如何划分特征空间以做出决策的描绘。树结构图帮助我们理解模型的行为，特征空间图帮助我们通过展示特征和目标变量之间的关系来理解数据。</p> 
<p>我们将使用的可视化库称为<a href="https://github.com/parrt/dtreeviz">dtreeviz</a>，为了保持一致性，我们将重复使用初学者教程中的企鹅和鲍鱼数据</p> 
<p>在本教程中，您将学习如何：</p> 
<ul><li>显示TF-DF森林中决策树的结构</li><li>更改dtreeviz树结构图的大小和样式</li><li>绘制叶子信息，例如每个叶子中的实例数、每个叶子中目标值的分布以及关于叶子的各种统计信息</li><li>跟踪树对特定实例的解释，并显示从根到叶子的路径，以进行预测</li><li>打印树如何解释实例的英文解释</li><li>查看一维和二维特征空间，以了解模型如何将它们划分为相似实例的区域</li></ul> 
<h3><a id="_19"></a>设置</h3> 
<h4><a id="_TFDF__dtreeviz_21"></a>安装 TF-DF 和 dtreeviz</h4> 
<pre><code class="prism language-python"><span class="token comment"># 安装tensorflow_decision_forests库</span>
!pip install <span class="token operator">-</span>q <span class="token operator">-</span>U tensorflow_decision_forests
</code></pre> 
<pre><code class="prism language-python"><span class="token comment"># 安装 dtreeviz 库</span>
!pip install <span class="token operator">-</span>q <span class="token operator">-</span>U dtreeviz
</code></pre> 
<h4><a id="_35"></a>导入库</h4> 
<pre><code class="prism language-python">
<span class="token keyword">import</span> tensorflow_decision_forests <span class="token keyword">as</span> tfdf

<span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf

<span class="token keyword">import</span> os
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd
<span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf
<span class="token keyword">import</span> math

<span class="token keyword">import</span> dtreeviz

<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> plt
<span class="token keyword">from</span> IPython <span class="token keyword">import</span> display

<span class="token comment"># 避免“Arial字体未找到”的警告</span>
<span class="token keyword">import</span> logging
logging<span class="token punctuation">.</span>getLogger<span class="token punctuation">(</span><span class="token string">'matplotlib.font_manager'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setLevel<span class="token punctuation">(</span>level<span class="token operator">=</span>logging<span class="token punctuation">.</span>CRITICAL<span class="token punctuation">)</span>

display<span class="token punctuation">.</span>set_matplotlib_formats<span class="token punctuation">(</span><span class="token string">'retina'</span><span class="token punctuation">)</span> <span class="token comment"># 生成高分辨率的图形</span>

np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span>  <span class="token comment"># 为了可重现的图形/数据解释的目的</span>

</code></pre> 
<pre><code>2023-03-07 12:10:56.998585: W tensorflow/compiler/xla/stream_executor/platform/default/dso_loader.cc:64] Could not load dynamic library 'libnvinfer.so.7'; dlerror: libnvinfer.so.7: cannot open shared object file: No such file or directory
2023-03-07 12:10:56.998704: W tensorflow/compiler/xla/stream_executor/platform/default/dso_loader.cc:64] Could not load dynamic library 'libnvinfer_plugin.so.7'; dlerror: libnvinfer_plugin.so.7: cannot open shared object file: No such file or directory
2023-03-07 12:10:56.998714: W tensorflow/compiler/tf2tensorrt/utils/py_utils.cc:38] TF-TRT Warning: Cannot dlopen some TensorRT libraries. If you would like to use Nvidia GPU with TensorRT, please make sure the missing libraries mentioned above are installed properly.
/tmpfs/tmp/ipykernel_9236/31193553.py:20: DeprecationWarning: `set_matplotlib_formats` is deprecated since IPython 7.23, directly use `matplotlib_inline.backend_inline.set_matplotlib_formats()`
</code></pre> 
<pre><code class="prism language-python"><span class="token comment"># 打印库的版本信息</span>
tfdf<span class="token punctuation">.</span>__version__<span class="token punctuation">,</span> dtreeviz<span class="token punctuation">.</span>__version__  <span class="token comment"># 希望 dtreeviz 的版本大于等于 2.2.0</span>
</code></pre> 
<pre><code>('1.2.0', '2.2.0')
</code></pre> 
<p>为了方便起见，我们需要定义一个函数来将数据集分为训练集和测试集：</p> 
<pre><code class="prism language-python"><span class="token comment"># 定义一个函数split_dataset，用于将一个panda dataframe分成两部分，通常用于训练集和测试集的划分。</span>
<span class="token comment"># 使用相同的随机种子确保我们得到相同的划分，以便本教程中的描述与生成的图像相对应。</span>

<span class="token keyword">def</span> <span class="token function">split_dataset</span><span class="token punctuation">(</span>dataset<span class="token punctuation">,</span> test_ratio<span class="token operator">=</span><span class="token number">0.30</span><span class="token punctuation">,</span> seed<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    将一个panda dataframe分成两部分，通常用于训练集和测试集的划分。
    使用相同的随机种子确保我们得到相同的划分，以便本教程中的描述与生成的图像相对应。
    
    参数：
    dataset：要划分的数据集，panda dataframe类型
    test_ratio：测试集所占比例，默认为0.30
    seed：随机种子，默认为1234
    
    返回值：
    划分后的训练集和测试集，均为panda dataframe类型
    """</span>
    
    <span class="token comment"># 设置随机种子</span>
    np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span>seed<span class="token punctuation">)</span>
    
    <span class="token comment"># 生成一个与dataset长度相同的随机数数组，元素值在0到1之间</span>
    <span class="token comment"># 若随机数小于test_ratio，则对应位置为True，否则为False</span>
    test_indices <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>dataset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> test_ratio
    
    <span class="token comment"># 返回划分后的训练集和测试集</span>
    <span class="token comment"># 通过~test_indices可以得到test_indices的逻辑反，即对应位置为False的元素</span>
    <span class="token comment"># 通过test_indices可以得到test_indices的逻辑值，即对应位置为True的元素</span>
    <span class="token keyword">return</span> dataset<span class="token punctuation">[</span><span class="token operator">~</span>test_indices<span class="token punctuation">]</span><span class="token punctuation">,</span> dataset<span class="token punctuation">[</span>test_indices<span class="token punctuation">]</span>
</code></pre> 
<h3><a id="_118"></a>可视化分类树</h3> 
<p><img align="right" src="https://images2.imgbox.com/96/80/EIeXDidF_o.png" width="150">使用企鹅数据，让我们构建一个分类器来预测其他7列中的<code>species</code>（<code>Adelie</code>，<code>Gentoo</code>或<code>Chinstrap</code>）。然后，我们可以使用dtreeviz来显示树并询问模型以了解它如何做出决策以及了解我们的数据。</p> 
<h4><a id="_122"></a>加载、清洗和准备数据</h4> 
<p>和初学者教程一样，让我们开始下载企鹅数据并将其转换为pandas数据框。</p> 
<pre><code class="prism language-python"><span class="token comment"># 下载企鹅数据集</span>
!wget <span class="token operator">-</span>q https<span class="token punctuation">:</span><span class="token operator">//</span>storage<span class="token punctuation">.</span>googleapis<span class="token punctuation">.</span>com<span class="token operator">/</span>download<span class="token punctuation">.</span>tensorflow<span class="token punctuation">.</span>org<span class="token operator">/</span>data<span class="token operator">/</span>palmer_penguins<span class="token operator">/</span>penguins<span class="token punctuation">.</span>csv <span class="token operator">-</span>O <span class="token operator">/</span>tmp<span class="token operator">/</span>penguins<span class="token punctuation">.</span>csv

<span class="token comment"># 将数据集加载到 Pandas Dataframe 中</span>
df_penguins <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">"/tmp/penguins.csv"</span><span class="token punctuation">)</span>

<span class="token comment"># 显示前三行数据</span>
df_penguins<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre> 
<div> 
</div> 
<table border="1" class="dataframe"><thead><tr><th></th><th>species</th><th>island</th><th>bill_length_mm</th><th>bill_depth_mm</th><th>flipper_length_mm</th><th>body_mass_g</th><th>sex</th><th>year</th></tr></thead><tbody><tr><th>0</th><td>Adelie</td><td>Torgersen</td><td>39.1</td><td>18.7</td><td>181.0</td><td>3750.0</td><td>male</td><td>2007</td></tr><tr><th>1</th><td>Adelie</td><td>Torgersen</td><td>39.5</td><td>17.4</td><td>186.0</td><td>3800.0</td><td>female</td><td>2007</td></tr><tr><th>2</th><td>Adelie</td><td>Torgersen</td><td>40.3</td><td>18.0</td><td>195.0</td><td>3250.0</td><td>female</td><td>2007</td></tr></tbody></table> 
<p>快速检查显示数据集中存在缺失值：</p> 
<pre><code class="prism language-python">df_penguins<span class="token punctuation">.</span>columns<span class="token punctuation">[</span>df_penguins<span class="token punctuation">.</span>isna<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code>['bill_length_mm', 'bill_depth_mm', 'flipper_length_mm', 'body_mass_g', 'sex']
</code></pre> 
<p>相比于填充缺失值，让我们只是删除不完整的行，以便在本教程中专注于可视化。</p> 
<pre><code class="prism language-python"><span class="token comment"># 删除包含缺失值的行</span>
df_penguins <span class="token operator">=</span> df_penguins<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 例如，有19行缺少性别等信息...</span>
</code></pre> 
<p>TF-DF要求分类标签为整数，范围在[0，num_labels)之间，因此让我们将标签列<code>species</code>从字符串转换为整数。</p> 
<p><strong>注意：</strong> TF-DF支持分类字符串输入特征。您不需要对任何特征值进行编码。</p> 
<pre><code class="prism language-python"><span class="token comment"># 定义变量penguin_label，表示分类目标标签的名称</span>
penguin_label <span class="token operator">=</span> <span class="token string">"species"</span>

<span class="token comment"># 获取数据集中penguin_label列的所有唯一值，并将其转换为列表</span>
classes <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>df_penguins<span class="token punctuation">[</span>penguin_label<span class="token punctuation">]</span><span class="token punctuation">.</span>unique<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 将数据集中的penguin_label列的值映射为它们在classes列表中的索引值</span>
df_penguins<span class="token punctuation">[</span>penguin_label<span class="token punctuation">]</span> <span class="token operator">=</span> df_penguins<span class="token punctuation">[</span>penguin_label<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>classes<span class="token punctuation">.</span>index<span class="token punctuation">)</span>

<span class="token comment"># 打印输出分类目标标签的名称和对应的类别列表</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Target '</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>penguin_label<span class="token punctuation">}</span></span><span class="token string">'' classes: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>classes<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

<span class="token comment"># 显示数据集的前3行</span>
df_penguins<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code>Target 'species'' classes: ['Adelie', 'Gentoo', 'Chinstrap']
</code></pre> 
<div> 
</div> 
<table border="1" class="dataframe"><thead><tr><th></th><th>species</th><th>island</th><th>bill_length_mm</th><th>bill_depth_mm</th><th>flipper_length_mm</th><th>body_mass_g</th><th>sex</th><th>year</th></tr></thead><tbody><tr><th>0</th><td>0</td><td>Torgersen</td><td>39.1</td><td>18.7</td><td>181.0</td><td>3750.0</td><td>male</td><td>2007</td></tr><tr><th>1</th><td>0</td><td>Torgersen</td><td>39.5</td><td>17.4</td><td>186.0</td><td>3800.0</td><td>female</td><td>2007</td></tr><tr><th>2</th><td>0</td><td>Torgersen</td><td>40.3</td><td>18.0</td><td>195.0</td><td>3250.0</td><td>female</td><td>2007</td></tr></tbody></table> 
<p>现在，让我们使用上面定义的便捷函数将训练和测试数据按70-30的比例划分，并将这些数据框转换为tensorflow数据集。</p> 
<h4><a id="_330"></a>分割训练/测试集并训练模型</h4> 
<pre><code class="prism language-python"><span class="token comment"># 将数据集分割为训练集和测试集</span>
train_ds_pd<span class="token punctuation">,</span> test_ds_pd <span class="token operator">=</span> split_dataset<span class="token punctuation">(</span>df_penguins<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token builtin">len</span><span class="token punctuation">(</span>train_ds_pd<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string"> 个训练样本，</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token builtin">len</span><span class="token punctuation">(</span>test_ds_pd<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string"> 个测试样本。"</span></span><span class="token punctuation">)</span>

<span class="token comment"># 将数据集转换为 TensorFlow 数据集</span>
train_ds <span class="token operator">=</span> tfdf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>pd_dataframe_to_tf_dataset<span class="token punctuation">(</span>train_ds_pd<span class="token punctuation">,</span> label<span class="token operator">=</span>penguin_label<span class="token punctuation">)</span>
test_ds <span class="token operator">=</span> tfdf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>pd_dataframe_to_tf_dataset<span class="token punctuation">(</span>test_ds_pd<span class="token punctuation">,</span> label<span class="token operator">=</span>penguin_label<span class="token punctuation">)</span>
</code></pre> 
<pre><code>243 examples in training, 90 examples for testing.
</code></pre> 
<h4><a id="_346"></a>训练一个随机森林分类器</h4> 
<pre><code class="prism language-python"><span class="token comment"># 导入所需的库和模块</span>

<span class="token comment"># 创建一个随机森林模型对象，设置参数verbose为0表示不输出训练过程中的详细信息，random_seed为1234表示设置随机种子为1234</span>
cmodel <span class="token operator">=</span> tfdf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>RandomForestModel<span class="token punctuation">(</span>verbose<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> random_seed<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">)</span>

<span class="token comment"># 使用训练数据集train_ds对模型进行训练</span>
cmodel<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>train_ds<span class="token punctuation">)</span>
</code></pre> 
<pre><code>WARNING:tensorflow:From /tmpfs/src/tf_docs_env/lib/python3.9/site-packages/tensorflow/python/autograph/pyct/static_analysis/liveness.py:83: Analyzer.lamba_check (from tensorflow.python.autograph.pyct.static_analysis.liveness) is deprecated and will be removed after 2023-09-23.
Instructions for updating:
Lambda fuctions will be no more assumed to be used in the statement where they are used, or at least in the same block. https://github.com/tensorflow/tensorflow/issues/56089


[INFO 2023-03-07T12:11:06.100795433+00:00 kernel.cc:1214] Loading model from path /tmpfs/tmp/tmpeau3pdt_/model/ with prefix 72ee2781602146e9
[INFO 2023-03-07T12:11:06.113257784+00:00 decision_forest.cc:661] Model loaded with 300 root(s), 4310 node(s), and 7 input feature(s).
[INFO 2023-03-07T12:11:06.113286363+00:00 abstract_model.cc:1311] Engine "RandomForestGeneric" built
[INFO 2023-03-07T12:11:06.113305638+00:00 kernel.cc:1046] Use fast generic engine


WARNING:tensorflow:AutoGraph could not transform &lt;function simple_ml_inference_op_with_handle at 0x7f67957524c0&gt; and will run it as-is.
Please report this to the TensorFlow team. When filing the bug, set the verbosity to 10 (on Linux, `export AUTOGRAPH_VERBOSITY=10`) and attach the full output.
Cause: could not get source code
To silence this warning, decorate the function with @tf.autograph.experimental.do_not_convert
WARNING: AutoGraph could not transform &lt;function simple_ml_inference_op_with_handle at 0x7f67957524c0&gt; and will run it as-is.
Please report this to the TensorFlow team. When filing the bug, set the verbosity to 10 (on Linux, `export AUTOGRAPH_VERBOSITY=10`) and attach the full output.
Cause: could not get source code
To silence this warning, decorate the function with @tf.autograph.experimental.do_not_convert





&lt;keras.callbacks.History at 0x7f68310ddd90&gt;
</code></pre> 
<p>只是为了验证一切是否正常工作，让我们检查模型的准确率，应该约为99%：</p> 
<pre><code class="prism language-python"><span class="token comment"># 对模型进行编译，使用"accuracy"作为评估指标</span>
cmodel<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span>metrics<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"accuracy"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 对测试数据集进行评估，返回字典形式的评估结果，verbose=0表示不输出评估过程</span>
cmodel<span class="token punctuation">.</span>evaluate<span class="token punctuation">(</span>test_ds<span class="token punctuation">,</span> return_dict<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code>{'loss': 0.0, 'accuracy': 0.9888888597488403}
</code></pre> 
<p>是的，模型在测试集上的准确率很高。</p> 
<h4><a id="_407"></a>显示决策树</h4> 
<p>现在我们有了一个模型，让我们选择随机森林中的一棵树，并查看其结构。dtreeviz库要求我们将TF-DF模型与相关的训练数据捆绑在一起，然后可以重复询问模型。</p> 
<pre><code class="prism language-python"><span class="token comment"># 获取penguin数据集的特征名</span>
penguin_features <span class="token operator">=</span> <span class="token punctuation">[</span>f<span class="token punctuation">.</span>name <span class="token keyword">for</span> f <span class="token keyword">in</span> cmodel<span class="token punctuation">.</span>make_inspector<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>features<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token comment"># 创建一个dtreeviz的可视化模型</span>
<span class="token comment"># 参数说明：</span>
<span class="token comment"># - cmodel: 训练好的决策树模型</span>
<span class="token comment"># - tree_index: 指定要可视化的决策树的索引</span>
<span class="token comment"># - X_train: 训练集的特征数据</span>
<span class="token comment"># - y_train: 训练集的标签数据</span>
<span class="token comment"># - feature_names: 特征的名称列表</span>
<span class="token comment"># - target_name: 目标变量的名称</span>
<span class="token comment"># - class_names: 类别的名称列表</span>
viz_cmodel <span class="token operator">=</span> dtreeviz<span class="token punctuation">.</span>model<span class="token punctuation">(</span>cmodel<span class="token punctuation">,</span>
                           tree_index<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>
                           X_train<span class="token operator">=</span>train_ds_pd<span class="token punctuation">[</span>penguin_features<span class="token punctuation">]</span><span class="token punctuation">,</span>
                           y_train<span class="token operator">=</span>train_ds_pd<span class="token punctuation">[</span>penguin_label<span class="token punctuation">]</span><span class="token punctuation">,</span>
                           feature_names<span class="token operator">=</span>penguin_features<span class="token punctuation">,</span>
                           target_name<span class="token operator">=</span>penguin_label<span class="token punctuation">,</span>
                           class_names<span class="token operator">=</span>classes<span class="token punctuation">)</span>
</code></pre> 
<p>最常见的dtreeviz API函数是<code>view()</code>，它显示树的结构以及与每个决策节点相关联的实例的特征分布。</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用viz_cmodel的view方法，并设置缩放比例为1.2，用于显示模型的可视化结果。</span>
viz_cmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>scale<span class="token operator">=</span><span class="token number">1.2</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b0/a3/w4orC1Zx_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/c4/af/BBOnCWp6_o.png" alt="在这里插入图片描述"></p> 
<p>决策树的根节点表示分类开始时通过测试<code>flipper_length_mm</code>特征，使用分割值206。如果测试实例的<code>flipper_length_mm</code>特征值小于206，则决策树向左子节点下降。如果它大于或等于206，则分类通过向右子节点下降进行。</p> 
<p>为了了解模型为什么选择在<code>flipper_length_mm</code>=206处分割训练数据，让我们放大根节点。</p> 
<pre><code class="prism language-python"><span class="token comment"># 设置深度范围和缩放比例，并显示模型</span>
viz_cmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>depth_range_to_display<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">1.5</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/21/fa/RiVX3BRa_o.png" alt="在这里插入图片描述"></p> 
<p>清晰地看到，206右侧的几乎所有实例都是蓝色（<code>Gentoo</code>企鹅）。因此，通过一次特征比较，模型可以将训练数据分成一个相当纯净的<code>Gentoo</code>组和一个混合组。（模型将通过根节点以下的未来分割进一步净化子组。）</p> 
<p>决策树还具有分类决策节点，可以测试类别子集而不是简单的数值分割。例如，让我们来看看树的第二层：</p> 
 
<pre><code class="prism language-python"><span class="token comment"># 调用viz_cmodel的view函数，并设置参数</span>
<span class="token comment"># depth_range_to_display参数用于指定显示的深度范围，这里设置为[1,1]，表示只显示深度为1的部分</span>
<span class="token comment"># scale参数用于指定显示的缩放比例，这里设置为1.5，表示放大1.5倍显示</span>
viz_cmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>depth_range_to_display<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">1.5</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/97/3e/7jYFBfiB_o.png" alt="在这里插入图片描述"></p> 
<p>节点（左侧）测试特征<code>island</code>，如果测试实例具有<code>island==Dream</code>，则分类继续向下移动到其右子节点。对于另外两个类别<code>Torgersen</code>和<code>Biscoe</code>，分类继续向下移动到其左子节点。（在这个图中，右侧的<code>bill_length_mm</code>节点与对分类决策节点的讨论无关。）</p> 
<p>这种分割行为突出了决策树将特征空间划分为目标值纯度增加的区域的目标。我们将在下面更详细地查看特征空间。</p> 
<p>决策树可能会变得非常庞大，将它们完整地绘制出来并不总是有用的。但是，我们可以查看树的简化版本、树的部分、各个叶子节点（进行预测的地方）中的训练实例数量等等… 这是一个例子，我们关闭了精美的决策节点分布图，并将整个图像缩小到75%的比例：</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用viz_cmodel的view函数，以可视化模型</span>
<span class="token comment"># 参数fancy设置为False，表示不使用复杂的样式</span>
<span class="token comment"># 参数scale设置为0.75，表示缩放比例为0.75</span>
viz_cmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>fancy<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">.75</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b9/9c/A1VDTzvv_o.png" alt="在这里插入图片描述"></p> 
<p>我们还可以使用从左到右的方向，这样有时会得到一个较小的图。</p> 
<pre><code class="prism language-python"><span class="token comment"># 设置可视化模型的方向为从左到右，缩放比例为0.75</span>
viz_cmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>orientation<span class="token operator">=</span><span class="token string">'LR'</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">.75</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/57/cf/7z8vqQu2_o.png" alt="在这里插入图片描述"></p> 
<p>如果你不是饼图的粉丝，你也可以使用条形图。</p> 
<pre><code class="prism language-python"><span class="token comment"># 使用viz_cmodel对象的view方法展示数据可视化结果</span>
<span class="token comment"># leaftype参数指定使用条形图展示数据</span>
<span class="token comment"># scale参数指定缩放比例为0.75，即将图形缩小为原来的75%大小</span>
viz_cmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>leaftype<span class="token operator">=</span><span class="token string">'barh'</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">.75</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/74/99/4Lq0hb4k_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_549"></a>检查叶节点统计信息</h4> 
<p>决策树在叶节点上做出决策，因此如果整个图表太大而无法一次性查看所有内容，有时候将焦点放在叶节点上是很有用的。以下是如何检查每个叶节点中分组的训练数据实例数量：</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用viz_cmodel的leaf_sizes方法，并设置figsize参数为(5,1.5)</span>
viz_cmodel<span class="token punctuation">.</span>leaf_sizes<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/c5/3d/7RupQxpQ_o.png" alt=""></p> 
<p>也许更有趣的图表是显示各个叶子中每种训练实例的比例。训练的目标是使叶子节点具有单一颜色，因为它代表可以高度自信地预测该类别的“纯净”节点。</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用ctree_leaf_distributions函数，并设置图像大小为(5,1.5)</span>
viz_cmodel<span class="token punctuation">.</span>ctree_leaf_distributions<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/af/c8/QzmjhFiC_o.png" alt=""></p> 
<p>我们还可以放大特定的叶节点，查看各个实例特征的一些统计信息。例如，叶节点5包含31个实例，其中有24个实例具有唯一的<code>bill_length_mm</code>值：</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用viz_cmodel的node_stats方法，传入参数node_id=5，用于获取节点5的统计信息。</span>
viz_cmodel<span class="token punctuation">.</span>node_stats<span class="token punctuation">(</span>node_id<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>
</code></pre> 
<div> 
</div> 
<table border="1" class="dataframe"><thead><tr><th></th><th>bill_depth_mm</th><th>bill_length_mm</th><th>body_mass_g</th><th>flipper_length_mm</th><th>island</th><th>sex</th><th>year</th></tr></thead><tbody><tr><th>count</th><td>31.0</td><td>31.0</td><td>31.0</td><td>31.0</td><td>31</td><td>31</td><td>31</td></tr><tr><th>unique</th><td>24.0</td><td>28.0</td><td>26.0</td><td>17.0</td><td>1</td><td>2</td><td>3</td></tr><tr><th>top</th><td>18.5</td><td>39.5</td><td>3300.0</td><td>185.0</td><td>Dream</td><td>female</td><td>2009</td></tr><tr><th>freq</th><td>4.0</td><td>2.0</td><td>2.0</td><td>4.0</td><td>31</td><td>19</td><td>11</td></tr></tbody></table> 
<h4><a id="_664"></a>决策树如何对实例进行分类</h4> 
<p>现在我们已经了解了决策树的结构和内容，让我们来弄清楚分类器如何对特定实例进行决策。通过将实例（特征向量）作为参数<code>x</code>传入<code>view()</code>函数，该函数将突出显示分类器为该实例进行预测所追求的从根到叶子的路径。</p> 
<pre><code class="prism language-python">
<span class="token comment"># 选择第20个样本</span>
x <span class="token operator">=</span> train_ds_pd<span class="token punctuation">[</span>penguin_features<span class="token punctuation">]</span><span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span>

<span class="token comment"># 调用viz_cmodel库中的view函数，可视化样本x</span>
viz_cmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>x<span class="token operator">=</span>x<span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">.75</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/5f/d8/RDbTGnPT_o.png" alt="在这里插入图片描述"></p> 
<p>说明：<br> 该插图突出显示了被测试的树路径和实例特征（<code>island</code>、<code>bill_length_mm</code>和<code>flipper_length_mm</code>）。</p> 
<p>对于非常大的树，您还可以通过使用<code>show_just_path</code>参数仅查看树的路径，而不是整个树。</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用viz_cmodel的view方法来可视化模型</span>
<span class="token comment"># 参数x表示输入数据</span>
<span class="token comment"># 参数show_just_path表示只显示路径</span>
<span class="token comment"># 参数scale表示缩放比例为0.75</span>
viz_cmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>x<span class="token operator">=</span>x<span class="token punctuation">,</span> show_just_path<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">.75</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f8/ac/HrEjdh15_o.png" alt="在这里插入图片描述"></p> 
<p>为了获得一个实例分类的英文解释，使用<code>explain_prediction_path()</code>函数来获取最小可能的表示。</p> 
<pre><code class="prism language-python"><span class="token comment"># 打印可视化模型的解释预测路径</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>viz_cmodel<span class="token punctuation">.</span>explain_prediction_path<span class="token punctuation">(</span>x<span class="token operator">=</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code>bill_length_mm &lt; 40.6
flipper_length_mm &lt; 206.0
island in {'Dream'}  
</code></pre> 
<p>模型测试 <code>x</code> 的 <code>bill_length_mm</code>、<code>flipper_length_mm</code> 和 <code>island</code> 特征，以达到叶子节点，该节点预测为 <code>Adelie</code>。</p> 
<h4><a id="_721"></a>特征空间划分</h4> 
<p>到目前为止，我们已经了解了树的结构以及树如何解释实例以做出决策，但是决策节点到底在做什么呢？决策树将特征空间划分为一组共享相似目标值的观测值。每个叶子节点表示从根节点到该叶子节点执行的特征分裂序列所导致的分区。对于分类问题，目标是使分区共享相同或大部分相同的目标类值。</p> 
<p>如果我们回顾一下树的结构，我们会发现变量<code>flipper_length_mm</code>在树中被三个节点测试。相应的决策节点分裂值为189、206和210.5，这意味着决策树将<code>flipper_length_mm</code>分成了四个区域，我们可以使用<code>ctree_feature_space()</code>来说明：</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用ctree_feature_space函数，并传入参数</span>
<span class="token comment"># features参数指定要显示的特征，这里只显示'flipper_length_mm'</span>
<span class="token comment"># show参数指定要显示的内容，这里显示'splits'和'legend'</span>
<span class="token comment"># figsize参数指定图像的大小，这里设置为(5,1.5)</span>
viz_cmodel<span class="token punctuation">.</span>ctree_feature_space<span class="token punctuation">(</span>features<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'flipper_length_mm'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> show<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">'splits'</span><span class="token punctuation">,</span><span class="token string">'legend'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/4a/77/3UWOCYc7_o.png" alt=""></p> 
<p>（在这种单特征情况下，垂直轴没有意义。为了增加可见性，垂直轴只是将表示不同目标类的点分隔成不同的高度，并添加了一些噪音。）</p> 
<p>第一个分割点在206处（在根部进行测试）将训练数据分割成了一个重叠区域，其中包含了Adelie/Gentoo Penguins，以及一个相当区域的Chinstrap Penguins。随后在210.5处的分割进一步隔离了一个纯Chinstrap区域（大于210.5的鳍长）。决策树还在189处进行了分割，但是得到的区域仍然不纯。树依靠通过其他变量进行分割来分离“混乱”的Adelie/Gentoo Penguins。因为我们只传入了一个特征名称，所以其他特征的分割没有显示出来。</p> 
<p>让我们看看另一个具有更多分割的特征，<code>bill_length_mm</code>。决策树中有四个节点测试了该特征，因此我们得到了一个将特征空间分割成五个区域的结果。请注意，模型可以通过测试<code>bill_length_mm</code>小于40来分割出一个纯净的<code>Adelie</code>区域。</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用ctree_feature_space函数，并传入参数features=['bill_length_mm']，表示只显示bill_length_mm特征</span>
<span class="token comment"># 参数show={'splits','legend'}表示显示决策树的分割线和图例</span>
<span class="token comment"># 参数figsize=(5,1.5)表示设置图像的大小为5x1.5</span>
viz_cmodel<span class="token punctuation">.</span>ctree_feature_space<span class="token punctuation">(</span>features<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'bill_length_mm'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> show<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">'splits'</span><span class="token punctuation">,</span><span class="token string">'legend'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/38/ca/xEQ6aas6_o.png" alt=""></p> 
<p>我们还可以同时检查树如何将特征空间划分为两个特征，例如<code>flipper_length_mm</code>和<code>bill_length_mm</code>：</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用ctree_feature_space函数，并传入参数</span>
<span class="token comment"># features参数指定要显示的特征，这里是'flipper_length_mm'和'bill_length_mm'</span>
<span class="token comment"># show参数指定要显示的内容，这里是'splits'和'legend'</span>
<span class="token comment"># figsize参数指定图像的大小，这里是(5,5)</span>
viz_cmodel<span class="token punctuation">.</span>ctree_feature_space<span class="token punctuation">(</span>features<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'flipper_length_mm'</span><span class="token punctuation">,</span><span class="token string">'bill_length_mm'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                               show<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">'splits'</span><span class="token punctuation">,</span><span class="token string">'legend'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/43/b8/lkQkowt1_o.png" alt=""></p> 
<p>区域的颜色表示测试实例的分类颜色，其特征落在该区域内。</p> 
<p>通过同时考虑两个变量，决策树可以创建更加纯净（矩形）的区域，从而实现更准确的预测。例如，左上方的区域完全包含了“Chinstrap”企鹅。</p> 
<p>根据我们选择的变量，区域的纯度会有所不同。这是另一个基于<code>bill_depth_mm</code>和<code>bill_length_mm</code>特征的二维特征空间划分，其中阴影表示不确定性。</p> 
<pre><code class="prism language-python"><span class="token comment"># 使用ctree_feature_space函数绘制特征空间图</span>
<span class="token comment"># 参数features指定要绘制的特征，这里选择了'body_mass_g'和'bill_length_mm'</span>
<span class="token comment"># 参数show指定要显示的内容，这里选择了'splits'和'legend'</span>
<span class="token comment"># 参数figsize指定图像的大小，这里设置为(5,5)</span>
viz_cmodel<span class="token punctuation">.</span>ctree_feature_space<span class="token punctuation">(</span>features<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'body_mass_g'</span><span class="token punctuation">,</span><span class="token string">'bill_length_mm'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> show<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">'splits'</span><span class="token punctuation">,</span><span class="token string">'legend'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/c7/ae/ErnUDeV4_o.png" alt=""></p> 
<p>只有<code>Adelie</code>地区相对纯净。树依赖于其他变量来获得更好的分区，就像我们刚刚在<code>flipper_length_mm</code> vs <code>bill_length_mm</code>空间中看到的那样。</p> 
<p>目前，dtreeviz库无法可视化超过两个特征维度的分类。</p> 
<p>到目前为止，您已经很好地掌握了如何可视化决策树的结构，树如何分割特征空间以及树如何对测试实例进行分类。现在让我们转向回归，看看dtreeviz如何可视化回归树。</p> 
<h3><a id="_807"></a>可视化回归树</h3> 
<p><img align="right" src="https://images2.imgbox.com/65/db/iaf2XPOC_o.png" width="120">让我们使用初学者教程中使用的<a href="https://storage.googleapis.com/download.tensorflow.org/data/abalone_raw.csv" rel="nofollow">鲍鱼数据集</a>来探索回归树的结构。与上面的分类相同，我们首先加载和准备训练数据。给定8个变量，我们想预测鲍鱼壳中的环数。</p> 
<h4><a id="_811"></a>加载、清洗和准备数据</h4> 
<p>使用以下代码片段，我们可以看到除了 <code>Type</code>（性别）变量之外，所有特征都是数值型的。</p> 
<pre><code class="prism language-python"><span class="token comment"># 下载数据集</span>
!wget <span class="token operator">-</span>q https<span class="token punctuation">:</span><span class="token operator">//</span>storage<span class="token punctuation">.</span>googleapis<span class="token punctuation">.</span>com<span class="token operator">/</span>download<span class="token punctuation">.</span>tensorflow<span class="token punctuation">.</span>org<span class="token operator">/</span>data<span class="token operator">/</span>abalone_raw<span class="token punctuation">.</span>csv <span class="token operator">-</span>O <span class="token operator">/</span>tmp<span class="token operator">/</span>abalone<span class="token punctuation">.</span>csv

<span class="token comment"># 读取CSV文件并将数据存储在DataFrame中</span>
df_abalone <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">"/tmp/abalone.csv"</span><span class="token punctuation">)</span>

<span class="token comment"># 显示DataFrame的前3行数据</span>
df_abalone<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre> 
<div> 
</div> 
<table border="1" class="dataframe"><thead><tr><th></th><th>Type</th><th>LongestShell</th><th>Diameter</th><th>Height</th><th>WholeWeight</th><th>ShuckedWeight</th><th>VisceraWeight</th><th>ShellWeight</th><th>Rings</th></tr></thead><tbody><tr><th>0</th><td>M</td><td>0.455</td><td>0.365</td><td>0.095</td><td>0.5140</td><td>0.2245</td><td>0.1010</td><td>0.15</td><td>15</td></tr><tr><th>1</th><td>M</td><td>0.350</td><td>0.265</td><td>0.090</td><td>0.2255</td><td>0.0995</td><td>0.0485</td><td>0.07</td><td>7</td></tr><tr><th>2</th><td>F</td><td>0.530</td><td>0.420</td><td>0.135</td><td>0.6770</td><td>0.2565</td><td>0.1415</td><td>0.21</td><td>9</td></tr></tbody></table> 
<p>幸运的是，没有缺失的数据需要处理：</p> 
<pre><code class="prism language-python"><span class="token comment"># 使用isna()方法检查数据集中是否存在缺失值，any()方法判断是否存在缺失值</span>
df_abalone<span class="token punctuation">.</span>isna<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code>Type             False
LongestShell     False
Diameter         False
Height           False
WholeWeight      False
ShuckedWeight    False
VisceraWeight    False
ShellWeight      False
Rings            False
dtype: bool
</code></pre> 
<h4><a id="_926"></a>分割训练/测试集并训练模型</h4> 
<pre><code class="prism language-python"><span class="token comment"># 定义分类目标标签名称为 "Rings"</span>
abalone_label <span class="token operator">=</span> <span class="token string">"Rings"</span>

<span class="token comment"># 将数据集按照 70/30 的比例分为训练集和测试集</span>
df_train_abalone<span class="token punctuation">,</span> df_test_abalone <span class="token operator">=</span> split_dataset<span class="token punctuation">(</span>df_abalone<span class="token punctuation">)</span>

<span class="token comment"># 输出训练集和测试集的样本数量</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token builtin">len</span><span class="token punctuation">(</span>df_train_abalone<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string"> examples in training, </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token builtin">len</span><span class="token punctuation">(</span>df_test_abalone<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string"> examples for testing."</span></span><span class="token punctuation">)</span>

<span class="token comment"># 将数据集转换为 TensorFlow 数据集</span>
train_ds <span class="token operator">=</span> tfdf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>pd_dataframe_to_tf_dataset<span class="token punctuation">(</span>df_train_abalone<span class="token punctuation">,</span> label<span class="token operator">=</span>abalone_label<span class="token punctuation">,</span> task<span class="token operator">=</span>tfdf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Task<span class="token punctuation">.</span>REGRESSION<span class="token punctuation">)</span>
test_ds <span class="token operator">=</span> tfdf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>pd_dataframe_to_tf_dataset<span class="token punctuation">(</span>df_test_abalone<span class="token punctuation">,</span> label<span class="token operator">=</span>abalone_label<span class="token punctuation">,</span> task<span class="token operator">=</span>tfdf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Task<span class="token punctuation">.</span>REGRESSION<span class="token punctuation">)</span>
</code></pre> 
<pre><code>2935 examples in training, 1242 examples for testing.
</code></pre> 
<h4><a id="_947"></a>训练一个随机森林回归器</h4> 
<p>现在我们有了训练集和测试集，让我们来训练一个随机森林回归器。由于数据的特性，我们需要人为地限制树的高度以便进行可视化。（限制树的深度也是一种正则化的形式，用于防止过拟合。）深度为5足够准确，同时又足够小以进行可视化。</p> 
<pre><code class="prism language-python"><span class="token comment"># 创建一个随机森林模型</span>
rmodel <span class="token operator">=</span> tfdf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>RandomForestModel<span class="token punctuation">(</span>task<span class="token operator">=</span>tfdf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Task<span class="token punctuation">.</span>REGRESSION<span class="token punctuation">,</span>  <span class="token comment"># 设置任务为回归</span>
                                      max_depth<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>      <span class="token comment"># 设置树的最大深度为5，避免树过大</span>
                                      random_seed<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">,</span> <span class="token comment"># 设置随机种子，确保每次创建相同的树</span>
                                      verbose<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>       <span class="token comment"># 设置不显示训练过程中的详细信息</span>

<span class="token comment"># 使用训练数据集进行模型训练</span>
rmodel<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>x<span class="token operator">=</span>train_ds<span class="token punctuation">)</span>
</code></pre> 
<pre><code>[INFO 2023-03-07T12:11:19.959239957+00:00 kernel.cc:1214] Loading model from path /tmpfs/tmp/tmpdts8fzxf/model/ with prefix a5115ef6d4b2486a
[INFO 2023-03-07T12:11:19.98628563+00:00 decision_forest.cc:661] Model loaded with 300 root(s), 9264 node(s), and 8 input feature(s).
[INFO 2023-03-07T12:11:19.986325053+00:00 abstract_model.cc:1311] Engine "RandomForestOptPred" built
[INFO 2023-03-07T12:11:19.986350895+00:00 kernel.cc:1046] Use fast generic engine





&lt;keras.callbacks.History at 0x7f68310dd430&gt;
</code></pre> 
<p>让我们使用MAE和MSE来检查模型的准确性。<code>Rings</code>的范围是1-27，所以测试集上的MAE为1.66并不是很好，但对于我们的演示目的来说还可以。</p> 
<pre><code class="prism language-python"><span class="token comment"># 编译模型，指定评估指标为平均绝对误差（MAE）和均方误差（MSE）</span>
rmodel<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span>metrics<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"mae"</span><span class="token punctuation">,</span><span class="token string">"mse"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 在测试数据集上评估模型，并返回评估结果</span>
evaluation <span class="token operator">=</span> rmodel<span class="token punctuation">.</span>evaluate<span class="token punctuation">(</span>test_ds<span class="token punctuation">,</span> return_dict<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment"># 打印均方误差（MSE）</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"MSE: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>evaluation<span class="token punctuation">[</span><span class="token string">'mse'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

<span class="token comment"># 打印平均绝对误差（MAE）</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"MAE: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>evaluation<span class="token punctuation">[</span><span class="token string">'mae'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

<span class="token comment"># 打印均方根误差（RMSE），通过对均方误差取平方根得到</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"RMSE: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>evaluation<span class="token punctuation">[</span><span class="token string">'mse'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
</code></pre> 
<pre><code>MSE: 5.4397759437561035
MAE: 1.6559592485427856
RMSE: 2.3323327257825164
</code></pre> 
<h4><a id="_1001"></a>显示决策树</h4> 
<p>要使用dtreeviz，我们需要将模型和训练数据捆绑在一起。我们还必须选择要显示的随机森林中的特定树；让我们选择树3，就像我们对分类问题所做的那样。</p> 
<pre><code class="prism language-python"><span class="token comment"># 创建一个列表abalone_features，其中包含了rmodel模型的所有特征的名称</span>
abalone_features <span class="token operator">=</span> <span class="token punctuation">[</span>f<span class="token punctuation">.</span>name <span class="token keyword">for</span> f <span class="token keyword">in</span> rmodel<span class="token punctuation">.</span>make_inspector<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>features<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token comment"># 使用dtreeviz库中的model函数创建一个决策树可视化模型viz_rmodel</span>
<span class="token comment"># 设置tree_index参数为3，表示选择第三棵决策树进行可视化</span>
<span class="token comment"># 使用X_train参数传入训练集的特征数据df_train_abalone[abalone_features]</span>
<span class="token comment"># 使用y_train参数传入训练集的目标数据df_train_abalone[abalone_label]</span>
<span class="token comment"># 使用feature_names参数传入特征的名称列表abalone_features</span>
<span class="token comment"># 使用target_name参数传入目标变量的名称'Rings'</span>
viz_rmodel <span class="token operator">=</span> dtreeviz<span class="token punctuation">.</span>model<span class="token punctuation">(</span>rmodel<span class="token punctuation">,</span> tree_index<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>
                           X_train<span class="token operator">=</span>df_train_abalone<span class="token punctuation">[</span>abalone_features<span class="token punctuation">]</span><span class="token punctuation">,</span>
                           y_train<span class="token operator">=</span>df_train_abalone<span class="token punctuation">[</span>abalone_label<span class="token punctuation">]</span><span class="token punctuation">,</span>
                           feature_names<span class="token operator">=</span>abalone_features<span class="token punctuation">,</span>
                           target_name<span class="token operator">=</span><span class="token string">'Rings'</span><span class="token punctuation">)</span>
</code></pre> 
<p>功能<code>view()</code>显示了树的结构，但现在决策节点是散点图而不是堆叠条形图。每个决策节点显示了指定变量与目标（<code>Rings</code>）的边际图。</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用viz_rmodel的view方法，并设置缩放比例为1.2，用于可视化rmodel模型。</span>
viz_rmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>scale<span class="token operator">=</span><span class="token number">1.2</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/01/ed/KcWK1APp_o.png" alt="在这里插入图片描述"></p> 
<p>与分类一样，回归从树的根部向特定叶子前进，最终为特定的测试实例进行预测。通往叶子的路径上的节点测试数值或分类变量，将回归器引导到具有非常相似目标值的特定特征空间区域（希望如此）。</p> 
<p>叶子是条带图，显示叶子中所有实例的目标变量“Rings”的值。水平参数没有意义，只是一点噪音，用于分隔点，以便我们可以看到密度分布在哪里。考虑左下角的叶子，n=10，Rings=3.30。这表示该叶子中10个实例的平均“Rings”值为3.30，这也是决策树对达到该叶子的任何测试实例的预测结果。</p> 
<p>让我们放大树的根部，看看回归器如何根据变量“ShellWeight”进行分割：</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用viz_rmodel库中的view函数，并传入参数depth_range_to_display=[0,0]和scale=2</span>
viz_rmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>depth_range_to_display<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/8d/ab/IXriFyE2_o.png" alt="在这里插入图片描述"></p> 
<p>对于一个具有<code>ShellWeight&lt;0.164</code>的测试实例，回归器会沿着根节点的左子节点进行处理；否则，它会沿着右子节点进行处理。水平虚线表示与<code>ShellWeight</code>大于或小于0.164的实例相关联的平均<code>Rings</code>值。</p> 
<p>另一方面，对于分类变量，决策节点测试类别的子集，因为类别是无序的。在树的第四层中，有两个测试分类变量<code>Type</code>的决策节点：</p> 
 
<pre><code class="prism language-python"><span class="token comment"># 调用viz_rmodel的view方法来显示可视化结果</span>
<span class="token comment"># depth_range_to_display参数指定了要显示的深度范围，这里设置为[3,3]，表示只显示深度为3的部分</span>
<span class="token comment"># scale参数指定了显示的缩放比例，这里设置为1.5，表示放大1.5倍显示结果</span>
viz_rmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>depth_range_to_display<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">1.5</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/3a/23/Kl9WBQqx_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f5/f4/erj1pgC5_o.png" alt="在这里插入图片描述"></p> 
<p>分类器节点使用颜色来指示子集。例如，第四层左侧的决策节点指示分类器在测试实例的<code>Type=I</code>或<code>Type=F</code>时向左下降；否则，分类器向右下降。黄色和蓝色表示与左右分支相关联的两个分类值子集。水平虚线表示具有相关分类值的实例的平均<code>Rings</code>目标值。</p> 
<p>要显示大型树，可以使用orientation参数获得从左到右的树的版本，尽管它相当高，因此使用scale来缩小它是一个好主意。使用计算机上的屏幕缩放功能，可以放大感兴趣的区域。</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用view函数，设置参数orientation为'LR'，表示水平方向从左到右排列；设置参数scale为0.5，表示缩放比例为0.5</span>
viz_rmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>orientation<span class="token operator">=</span><span class="token string">'LR'</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">.5</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/6c/57/dFetQegv_o.png" alt="在这里插入图片描述"></p> 
<p>我们可以使用非花哨的图表来节省空间。它仍然显示决策节点的分裂变量和分裂点；只是不太漂亮。</p> 
<pre><code class="prism language-python"><span class="token comment"># 使用viz_rmodel库中的view函数来可视化模型</span>
<span class="token comment"># 参数fancy设置为False，表示不使用复杂的样式</span>
<span class="token comment"># 参数scale设置为0.75，表示缩放比例为0.75</span>
viz_rmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>fancy<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">.75</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/32/41/BWiqY4zf_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_1120"></a>检查叶子节点统计信息</h4> 
<p>当图形变得非常大时，有时候更好地关注叶子节点。函数<code>leaf_sizes()</code>指示每个叶子节点中找到的实例数量：</p> 
<pre><code class="prism language-python">
<span class="token comment"># 调用leaf_sizes函数，并设置figsize参数为(5,1.5)，用于指定绘图的大小</span>
viz_rmodel<span class="token punctuation">.</span>leaf_sizes<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/06/62/qNAH6J78_o.png" alt=""></p> 
<p>我们还可以查看叶子节点中实例的分布（<code>Rings</code>值）。垂直轴上每个叶子节点有一行，水平轴显示每个叶子节点中实例的<code>Rings</code>值的分布。右侧的列显示每个叶子节点的平均目标值。</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用viz_rmodel库中的rtree_leaf_distributions函数，并设置图像大小为(5,5)</span>
viz_rmodel<span class="token punctuation">.</span>rtree_leaf_distributions<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f4/ff/QYVRmo1M_o.png" alt=""></p> 
<p>或者，我们可以获取特定节点中实例特征的信息。例如，以下是如何获取叶节点29中特征的信息，该叶节点具有最多的实例：</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用viz_rmodel模块中的node_stats函数</span>
<span class="token comment"># 传入参数node_id=29，表示要获取节点ID为29的统计信息</span>
viz_rmodel<span class="token punctuation">.</span>node_stats<span class="token punctuation">(</span>node_id<span class="token operator">=</span><span class="token number">29</span><span class="token punctuation">)</span>
</code></pre> 
<div> 
</div> 
<table border="1" class="dataframe"><thead><tr><th></th><th>Diameter</th><th>Height</th><th>LongestShell</th><th>ShellWeight</th><th>ShuckedWeight</th><th>Type</th><th>VisceraWeight</th><th>WholeWeight</th></tr></thead><tbody><tr><th>count</th><td>672.0</td><td>672.000</td><td>672.00</td><td>672.000</td><td>672.0000</td><td>672</td><td>672.000</td><td>672.000</td></tr><tr><th>unique</th><td>42.0</td><td>18.000</td><td>48.00</td><td>262.000</td><td>483.0000</td><td>3</td><td>363.000</td><td>556.000</td></tr><tr><th>top</th><td>0.5</td><td>0.175</td><td>0.65</td><td>0.335</td><td>0.5985</td><td>F</td><td>0.318</td><td>1.262</td></tr><tr><th>freq</th><td>66.0</td><td>115.000</td><td>44.00</td><td>22.000</td><td>5.0000</td><td>328</td><td>11.000</td><td>4.000</td></tr></tbody></table> 
<h4><a id="_1242"></a>决策树如何预测实例的值</h4> 
<p>为了对特定实例进行预测，决策树根据测试实例中的特征值从根节点向下延伸到特定叶节点。单个树的预测值只是该叶节点中驻留的实例（来自训练集）的<code>Rings</code>值的平均值。如果我们通过参数<code>x</code>提供一个测试实例，dtreeviz库可以说明这个过程。</p> 
<pre><code class="prism language-python"><span class="token comment"># 从df_abalone数据集中获取第1234行的数据</span>
x <span class="token operator">=</span> df_abalone<span class="token punctuation">[</span>abalone_features<span class="token punctuation">]</span><span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">1234</span><span class="token punctuation">]</span>

<span class="token comment"># 调用viz_rmodel库中的view函数，可视化数据</span>
viz_rmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>x<span class="token operator">=</span>x<span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">.75</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a3/df/SWl1um8h_o.png" alt="在这里插入图片描述"></p> 
<p>如果该可视化太大，我们可以将图表缩小到实际遍历的从根到叶子的路径。</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用viz_rmodel的view方法来可视化模型</span>
<span class="token comment"># 参数x表示输入数据</span>
<span class="token comment"># 参数show_just_path表示只显示路径</span>
<span class="token comment"># 参数scale表示缩放比例为1.0</span>
viz_rmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>x<span class="token operator">=</span>x<span class="token punctuation">,</span> show_just_path<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a5/8a/Vxl32vKg_o.png" alt="在这里插入图片描述"></p> 
<p>我们可以使用水平方向来使其变得更小：</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用viz_rmodel的view函数来可视化模型</span>
<span class="token comment"># 参数x表示模型</span>
<span class="token comment"># 参数show_just_path表示只显示路径</span>
<span class="token comment"># 参数scale表示缩放比例</span>
<span class="token comment"># 参数orientation表示图的方向为从左到右</span>
viz_rmodel<span class="token punctuation">.</span>view<span class="token punctuation">(</span>x<span class="token operator">=</span>x<span class="token punctuation">,</span> show_just_path<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">.75</span><span class="token punctuation">,</span> orientation<span class="token operator">=</span><span class="token string">"LR"</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/0a/a7/woufS71n_o.png" alt="在这里插入图片描述"></p> 
<p>有时候，获取一个英文描述来了解模型如何测试我们的特征值以做出决策会更容易：</p> 
<pre><code class="prism language-python"><span class="token comment"># 打印可视化模型的预测解释路径</span>
<span class="token comment"># 参数 x 为输入数据</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>viz_rmodel<span class="token punctuation">.</span>explain_prediction_path<span class="token punctuation">(</span>x<span class="token operator">=</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code>0.25 &lt;= Diameter 
ShellWeight &lt; 0.11
Type not in {'M', 'F'}  
</code></pre> 
<h4><a id="_1316"></a>特征空间划分</h4> 
<p>使用<code>rtree_feature_space()</code>函数，我们可以看到决策树通过一系列的分割来划分特征空间。例如，下面是决策树如何划分特征<code>ShellWeight</code>的示例：</p> 
<pre><code class="prism language-python"><span class="token comment"># 使用rtree_feature_space函数来生成特征空间的可视化图表</span>
<span class="token comment"># features参数指定要显示的特征，这里只显示'ShellWeight'</span>
<span class="token comment"># show参数指定要显示的内容，这里只显示'splits'</span>
viz_rmodel<span class="token punctuation">.</span>rtree_feature_space<span class="token punctuation">(</span>features<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'ShellWeight'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> show<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">'splits'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/57/a4/pbFTx0RE_o.png" alt=""></p> 
<p>水平的橙色条表示每个区域内的平均“Rings”值。这是另一个使用特征“Diameter”的示例（树中只有一个分割点）：</p> 
<pre><code class="prism language-python"><span class="token comment"># 调用rtree_feature_space函数，传入参数features=['Diameter']和show={'splits'}</span>
<span class="token comment"># features参数指定了要在可视化中展示的特征，这里只展示了直径（Diameter）这一项</span>
<span class="token comment"># show参数指定了要展示的内容，这里指定了展示决策树的分裂情况（splits）</span>
viz_rmodel<span class="token punctuation">.</span>rtree_feature_space<span class="token punctuation">(</span>features<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Diameter'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> show<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">'splits'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/52/df/UzegEHlG_o.png" alt=""></p> 
<p>我们还可以查看二维特征空间，在这个空间中，“Rings”值的颜色从绿色（低）到蓝色（高）变化：</p> 
<pre><code class="prism language-python">
<span class="token comment"># 创建一个可视化模型对象</span>
viz_model <span class="token operator">=</span> viz_rmodel<span class="token punctuation">.</span>rtree_feature_space<span class="token punctuation">(</span>features<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'ShellWeight'</span><span class="token punctuation">,</span><span class="token string">'LongestShell'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> show<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">'splits'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/c0/b5/9UR27CQn_o.png" alt=""></p> 
<p>那个热力图可能会让人感到困惑，因为它实际上是一个三维空间的二维投影：两个特征 x 目标值。相反，dtreeviz可以向您展示这个三维图（从各种角度和高度）。</p> 
<pre><code class="prism language-python"><span class="token comment"># 创建一个3D特征空间图</span>
<span class="token comment"># 参数features指定要在图中显示的特征，这里选择了'ShellWeight'和'LongestShell'</span>
<span class="token comment"># 参数show指定要在图中显示的内容，这里选择了'splits'，表示显示决策树的分割线</span>
<span class="token comment"># 参数elev、azim和dist分别指定了视角的高度、方位和距离</span>
<span class="token comment"># 参数figsize指定了图的大小</span>
viz_rmodel<span class="token punctuation">.</span>rtree_feature_space3D<span class="token punctuation">(</span>features<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'ShellWeight'</span><span class="token punctuation">,</span><span class="token string">'LongestShell'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                              show<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">'splits'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> elev<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> azim<span class="token operator">=</span><span class="token number">140</span><span class="token punctuation">,</span> dist<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/76/ff/ZvukROfK_o.png" alt=""></p> 
<p>如果模型只测试了 <code>ShellWeight</code> 和 <code>LongestShell</code> 两个特征，那么就不会有重叠的垂直“板块”。每个特征空间的二维区域都会做出独特的预测。在这棵树中，还有其他特征可以区分模糊的垂直预测区域。</p> 
<p>在这个阶段，你已经学会了如何使用<a href="https://github.com/parrt/dtreeviz">dtreeviz</a>来展示决策树的结构，绘制叶子节点信息，跟踪模型如何解释特定实例以及模型如何划分未来空间。你已经准备好使用自己的数据集可视化和解释树了！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/71d1cffd2cf70e894805719d8914b5d6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">this.baseMapper.getRoleNameByUserId 会调用什么</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bacc7dfb50ad9cc7a8a36bd37a708704/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">工具系列：TensorFlow决策森林_(7)检查和调试决策森林模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>