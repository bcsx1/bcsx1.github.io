<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>stm32的时钟、中断的配置（针对寄存器），内存架构，总线地址 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="stm32的时钟、中断的配置（针对寄存器），内存架构，总线地址" />
<meta property="og:description" content="一、学习参考资料 （1）正点原子的寄存器源码。
（2）STM32F103最小系统板开发指南-寄存器版本_V1.1（正点）
（3）STM32F103最小系统板开发指南-库函数版本_V1.1（正点）
（4）Cortex-M3权威指南(中文)
（5）STM32中文参考手册_V10
（6）stm32cubemx可视化时钟树配置
（7）其他博主文章
本文主要以stm32f1系列单片机为研究对象，从寄存器层面对时钟树的配置、中断优先级的配置进行阐述。
二、stm32官方bsp库寄存器封装的基本方式 一般按照连续的寄存器地址使用结构体指针的形式封装，将寄存器按照连续的顺序定义变量在结构体中，然后直接将利用结构体指针指向结构体第一个定义的首地址的位置。
typedef struct { __I uint32_t CPUID; /*!&lt; Offset: 0x00 CPU ID Base Register */ __IO uint32_t ICSR; /*!&lt; Offset: 0x04 Interrupt Control State Register */ __IO uint32_t VTOR; /*!&lt; Offset: 0x08 Vector Table Offset Register */ __IO uint32_t AIRCR; /*!&lt; Offset: 0x0C Application Interrupt / Reset Control Register */ __IO uint32_t SCR; /*!&lt; Offset: 0x10 System Control Register */ __IO uint32_t CCR; /*!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/7ac859cbddeb262dcab726c00209504f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-24T10:20:42+08:00" />
<meta property="article:modified_time" content="2023-11-24T10:20:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">stm32的时钟、中断的配置（针对寄存器），内存架构，总线地址</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、学习参考资料</h2> 
<p>        （1）正点原子的寄存器源码。</p> 
<p>        （2）STM32F103最小系统板开发指南-寄存器版本_V1.1（正点）</p> 
<p>        （3）STM32F103最小系统板开发指南-库函数版本_V1.1（正点）</p> 
<p>        （4）Cortex-M3权威指南(中文)</p> 
<p>        （5）STM32中文参考手册_V10</p> 
<p>        （6）stm32cubemx可视化时钟树配置</p> 
<p>        （7）其他博主文章</p> 
<p>       本文主要以stm32f1系列单片机为研究对象，从寄存器层面对时钟树的配置、中断优先级的配置进行阐述。</p> 
<h2>二、stm32官方bsp库寄存器封装的基本方式</h2> 
<p>        一般按照连续的寄存器地址使用结构体指针的形式封装，将寄存器按照连续的顺序定义变量在结构体中，然后直接将利用结构体指针指向结构体第一个定义的首地址的位置。</p> 
<pre><code class="language-cpp">typedef struct
{
  __I  uint32_t CPUID;                        /*!&lt; Offset: 0x00  CPU ID Base Register                                  */
  __IO uint32_t ICSR;                         /*!&lt; Offset: 0x04  Interrupt Control State Register                      */
  __IO uint32_t VTOR;                         /*!&lt; Offset: 0x08  Vector Table Offset Register                          */
  __IO uint32_t AIRCR;                        /*!&lt; Offset: 0x0C  Application Interrupt / Reset Control Register        */
  __IO uint32_t SCR;                          /*!&lt; Offset: 0x10  System Control Register                               */
  __IO uint32_t CCR;                          /*!&lt; Offset: 0x14  Configuration Control Register                        */
  __IO uint8_t  SHP[12];                      /*!&lt; Offset: 0x18  System Handlers Priority Registers (4-7, 8-11, 12-15) */
  __IO uint32_t SHCSR;                        /*!&lt; Offset: 0x24  System Handler Control and State Register             */
  __IO uint32_t CFSR;                         /*!&lt; Offset: 0x28  Configurable Fault Status Register                    */
  __IO uint32_t HFSR;                         /*!&lt; Offset: 0x2C  Hard Fault Status Register                            */
  __IO uint32_t DFSR;                         /*!&lt; Offset: 0x30  Debug Fault Status Register                           */
  __IO uint32_t MMFAR;                        /*!&lt; Offset: 0x34  Mem Manage Address Register                           */
  __IO uint32_t BFAR;                         /*!&lt; Offset: 0x38  Bus Fault Address Register                            */
  __IO uint32_t AFSR;                         /*!&lt; Offset: 0x3C  Auxiliary Fault Status Register                       */
  __I  uint32_t PFR[2];                 /*!&lt; Offset: 0x40  Processor Feature Register   */      // 如果占用两个字节，就直接定义为数组的形式
  __I  uint32_t DFR;                          /*!&lt; Offset: 0x48  Debug Feature Register                                */
  __I  uint32_t ADR;                          /*!&lt; Offset: 0x4C  Auxiliary Feature Register                            */
  __I  uint32_t MMFR[4];                      /*!&lt; Offset: 0x50  Memory Model Feature Register                         */
  __I  uint32_t ISAR[5];                      /*!&lt; Offset: 0x60  ISA Feature Register                                  */
} SCB_Type;    </code></pre> 
<pre><code class="language-cpp">#define SCB   ((SCB_Type *)   SCB_BASE)    /*!&lt; SCB configuration struct          */</code></pre> 
<p>        上面定义之后，对寄存器的操作就变成了“SCB-&gt;VTOR &amp;= data(寄存器对应位置零),SCB-&gt;VTOR |= data(寄存器对应位置一)”。上面有些寄存器并不是32位的，占用位数比较多的可以采用定义数据的方式。</p> 
<p>--------------------------------------------------------------------------------------------------------------------------------</p> 
<p>        除了上面大范围的定义寄存器的形式，对于操作某些单个寄存器的时候，可以采用寄存器地址强制转化的方式。转化为指针“ <span style="color:#fe2c24;">unsigned volatile int * </span>”。</p> 
<pre><code class="language-cpp">#define RCC_BASE_MY       (uint32_t)0x40021000   //基地址
#define RCC_CR_MY         (uint32_t)0x00000000   //偏移地址
#define RCC_CFGR_MY       (uint32_t)0x00000004
#define RCC_CIR_MY         (uint32_t)0x00000008
#define RCC_APB2RSTR_MY   (uint32_t)0x0000000c

#define MY_RCC_CR          *((unsigned volatile int*)(RCC_BASE_MY+RCC_CR_MY))
#define MY_RCC_CFGR        *((unsigned volatile int*)(RCC_BASE_MY+RCC_CFGR_MY)) 
#define MY_RCC_CIR         *((unsigned volatile int*)(RCC_BASE_MY+RCC_CIR_MY)) 
#define MY_RCC_APB2RSTR    *((unsigned volatile int*)(RCC_BASE_MY+RCC_APB2RSTR_MY)) 
#define MY_FLASH_ACR	   *((unsigned volatile int*)0x40022000)   //要查m4内核手册</code></pre> 
<p>        此时对寄存器置位和复位的操作为：“ <span style="color:#fe2c24;">MY_RCC_CR |= (uint32_t)(1&lt;&lt;24) </span>”和“ <span style="color:#fe2c24;">MY_RCC_CFGR &amp;= ~(uint32_t)(3&lt;&lt;11)</span> ”。使用上面的方式就可以单独对某个寄存器进行操作。</p> 
<p>------------------------------------------------------------------------------------------------------------------------------</p> 
<p>        stm32底层代码的知识点补充：</p> 
<p>底层配置代码经常使用“assert_param()”函数判断用户的选择是否正确，如果不正确就会调用相应的错误处理函数进行处理。</p> 
<pre><code class="language-cpp">  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
//利用上面定义的assert_param(expr)，判断expr是否正确（也就是用户的选择参数是否正确，来确定是否调用assert_failed函数，assert_failed函数需要从写。）
/* Exported functions ------------------------------------------------------- */
  void assert_failed(uint8_t* file, uint32_t line);
#else
  #define assert_param(expr) ((void)0)
#endif /* USE_FULL_ASSERT */

#endif /* __STM32F10x_CONF_H */</code></pre> 
<p>        </p> 
<pre><code class="language-cpp">#define     __I      volatile const      /*!&lt; defines 'read only' permissions      */

#define     __O     volatile            /*!&lt; defines 'write only' permissions     */

#define     __IO     volatile              /*!&lt; defines 'read / write' permissions   */</code></pre> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>__I </strong></strong>：输入口<strong>(read only)</strong>。既然是输入，那么寄存器的值就随时会外部修改，那就不能进行优化，          每次都要重新从寄存器中读取。也不能写，即只读，不然就不是输入而是输出了。<br><strong><strong>__O </strong></strong>：输出口<strong>(write only)</strong>，也不能进行优化，不然你连续两次输出相同值，编译器认为没改变，           就忽略了后面那一次输出，假如外部在两次输出中间修改了值，那就影响输出<br><strong><strong>__IO</strong></strong>：输入输出口<strong>(read/write)</strong>，同上</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;">为什么加下划线？</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;">        原因是：避免命名冲突,一般宏定义都是大写，但因为这里的字母比较少，所以再添加下划线来区分。这样一般都可以避免命名冲突问题，因为很少人这样命名，这样命名的人肯定知道这些是有什么用的。经常写大工程时，都会发现老是命名冲突，要不是全局变量冲突，要不就是宏定义冲突，所以我们要尽量避免这些问题，不然出问题了都不知道问题在哪里。</span></p> 
<h2>三、stm32f103zet6的时钟树讲解</h2> 
<p>        对单片机的时钟树进行配置的时候，可以结合stm32cubemx的图形化配置进行理解。</p> 
<p><img alt="" height="799" src="https://images2.imgbox.com/df/e1/bHlXGS74_o.png" width="1110"></p> 
<p>        如上图所示，总线时钟需要配置的位置为“1、2、3、4、5、6”。对时钟配置的寄存器主要有下图的几个，下面将针对需要配置位置的寄存器进行讲解。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">        对应外设时钟的</span><span style="color:#ff0000;">“复位”（RCC_APB1RSTR、RCC_APB2RSTR）</span><span style="color:#000000;">和</span><span style="color:#ff0000;">“使能和失能”(RCC_APB1ENR、RCC_APB2ENR)</span><span style="color:#000000;">分别对应两个寄存器。</span></p> 
<p><img alt="" height="332" src="https://images2.imgbox.com/81/ac/WdxnX4sx_o.png" width="369"></p> 
<p> 1、<span style="color:#000000;"><strong>PLLXTPRE</strong></span><span style="color:#000000;">：</span><span style="color:#000000;">HSE</span><span style="color:#000000;">分频器作为</span><span style="color:#000000;">PLL</span><span style="color:#000000;">输入</span><span style="color:#000000;"> (HSE divider for PLL entry) （属于<strong>RCC_CFGR</strong>）</span></p> 
<p><img alt="" height="123" src="https://images2.imgbox.com/49/4b/R3tDp2g8_o.png" width="848"></p> 
<p>2、<span style="color:#000000;"><strong>PLLMUL</strong></span><span style="color:#000000;">：</span><span style="color:#000000;">PLL</span><span style="color:#000000;">倍频系数 (PLL multiplication factor)（属于<strong>RCC_CFGR</strong>）</span></p> 
<p><img alt="" height="318" src="https://images2.imgbox.com/88/7d/CFwQo883_o.png" width="844"></p> 
<p>3、<span style="color:#000000;"><strong>SW[1:0]</strong></span><span style="color:#000000;">：系统时钟切换 (System clock switch) （属于<strong>RCC_CFGR</strong>）</span></p> 
<p><img alt="" height="380" src="https://images2.imgbox.com/64/dd/TDtU6EXk_o.png" width="858"></p> 
<p>4、<span style="color:#000000;"><strong>HPRE[3:0]</strong></span><span style="color:#000000;">：</span><span style="color:#000000;"> AHB</span><span style="color:#000000;">预分频 (AHB Prescaler)（属于<strong>RCC_CFGR</strong>）</span></p> 
<p><img alt="" height="242" src="https://images2.imgbox.com/71/66/AS4T6ZnO_o.png" width="854"></p> 
<p>5、<span style="color:#000000;"><strong>PPRE1[2:0]</strong></span><span style="color:#000000;">：低速</span><span style="color:#000000;">APB</span><span style="color:#000000;">预分频(APB1) (APB low-speed prescaler (APB1))（属于<strong>RCC_CFGR</strong>）</span></p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/87/74/yBEKaf80_o.png" width="856"></p> 
<p>6、<span style="color:#000000;"><strong>PPRE2[2:0]</strong></span><span style="color:#000000;">：高速</span><span style="color:#000000;">APB</span><span style="color:#000000;">预分频(APB2) (APB high-speed prescaler (APB2))属于<strong>RCC_CFGR</strong>）</span></p> 
<p><img alt="" height="194" src="https://images2.imgbox.com/61/b4/NlWu4ylp_o.png" width="851"></p> 
<p>        配置的时钟和总线的开启寄存器是RCC_CR寄存器 。</p> 
<p><span style="background-color:#ffd900;">注意：时钟配置的时候要从后向前配置，在相应时钟和总线开启之后，从“6”的位置向前进行配置。</span></p> 
<h2>四、系统时钟寄存器</h2> 
<pre><code class="language-cpp">typedef struct
{
  __IO uint32_t CR;
  __IO uint32_t CFGR;
  __IO uint32_t CIR;
  __IO uint32_t APB2RSTR;
  __IO uint32_t APB1RSTR;
  __IO uint32_t AHBENR;
  __IO uint32_t APB2ENR;
  __IO uint32_t APB1ENR;
  __IO uint32_t BDCR;
  __IO uint32_t CSR;

#ifdef STM32F10X_CL  
  __IO uint32_t AHBRSTR;
  __IO uint32_t CFGR2;
#endif /* STM32F10X_CL */ 

#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)   
  uint32_t RESERVED0;
  __IO uint32_t CFGR2;
#endif /* STM32F10X_LD_VL || STM32F10X_MD_VL || STM32F10X_HD_VL */ 
} RCC_TypeDef;</code></pre> 
<pre><code class="language-cpp">#define RCC                 ((RCC_TypeDef *) RCC_BASE)</code></pre> 
<p>         对系统时钟树的配置使用上述的底层地址定义即可。</p> 
<p>下面是正点时钟树的配置代码，其中中断优先级的配置后面会讲：</p> 
<pre><code class="language-cpp">//不能在这里执行所有外设复位!否则至少引起串口不工作.		    
//把所有时钟寄存器复位		  
void MYRCC_DeInit(void)
{	
 	RCC-&gt;APB1RSTR = 0x00000000;//复位结束			 
	RCC-&gt;APB2RSTR = 0x00000000; 
	  
  	RCC-&gt;AHBENR = 0x00000014;  //睡眠模式闪存和SRAM时钟使能.其他关闭.	  
  	RCC-&gt;APB2ENR = 0x00000000; //外设时钟关闭.			   
  	RCC-&gt;APB1ENR = 0x00000000;   
	RCC-&gt;CR |= 0x00000001;     //使能内部高速时钟HSION	 															 
	RCC-&gt;CFGR &amp;= 0xF8FF0000;   //复位SW[1:0],HPRE[3:0],PPRE1[2:0],PPRE2[2:0],ADCPRE[1:0],MCO[2:0]					 
	RCC-&gt;CR &amp;= 0xFEF6FFFF;     //复位HSEON,CSSON,PLLON
	RCC-&gt;CR &amp;= 0xFFFBFFFF;     //复位HSEBYP	   	  
	RCC-&gt;CFGR &amp;= 0xFF80FFFF;   //复位PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE 
	RCC-&gt;CIR = 0x00000000;     //关闭所有中断		 
	//配置向量表				  
#ifdef  VECT_TAB_RAM
    /* 向量表的配置和中断优先级的配置后面都会讲 */
	MY_NVIC_SetVectorTable(0x20000000, 0x0);
#else   
	MY_NVIC_SetVectorTable(0x08000000,0x0);
#endif
}</code></pre> 
<pre><code class="language-cpp">//系统时钟初始化函数
//pll:选择的倍频数，从2开始，最大值为16		 
void Stm32_Clock_Init(u8 PLL)
{
	unsigned char temp=0;   
	MYRCC_DeInit();		     //复位并配置向量表
 	RCC-&gt;CR|=0x00010000;   //外部高速时钟使能HSEON
	while(!(RCC-&gt;CR&gt;&gt;17)); //等待外部时钟就绪
	RCC-&gt;CFGR=0X00000400;  //APB1=DIV2;APB2=DIV1;AHB=DIV1;
	PLL-=2;				         //抵消2个单位（因为是从2开始的，设置0就是2）
	RCC-&gt;CFGR|=PLL&lt;&lt;18;    //设置PLL值 2~16
	RCC-&gt;CFGR|=1&lt;&lt;16;	     //PLLSRC ON 
	FLASH-&gt;ACR|=0x32;	     //FLASH 2个延时周期
	RCC-&gt;CR|=0x01000000;   //PLLON
	while(!(RCC-&gt;CR&gt;&gt;25)); //等待PLL锁定
	RCC-&gt;CFGR|=0x00000002; //PLL作为系统时钟	 
	while(temp!=0x02)      //等待PLL作为系统时钟设置成功
	{   
		temp=RCC-&gt;CFGR&gt;&gt;2;
		temp&amp;=0x03;
	}    
}		    
</code></pre> 
<h2>五、中断向量表地址的配置</h2> 
<p>        这里需要有stm32内存的框架知识，后面有对这部分知识的详细的讲解，不懂得可以先看后面，这里为了衔接前面的代码，先介绍中断向量表地址的配置。</p> 
<p>        stm32的内存中，对于程序员最重要的是“<span style="color:#fe2c24;">SRAM（0x2000 0000~0x2000 FFFF）</span>”和“<span style="color:#fe2c24;">Flash(0x0800 0000~0x0808 0000)</span>”两个位置的内存。</p> 
<p><img alt="" height="840" src="https://images2.imgbox.com/54/99/wjQPGQrW_o.png" width="734"></p> 
<p>        向量表的首地址可以设置在SRAM区或者Flash区域。下面是stm32F4的向量表设置的形式，STM32F4 在复位后，先从 0X08000004 地址取出复位中断向量的地址，并<br> 跳转到复位中断服务程序，如图标号①所示；在复位中断服务程序执行完之后，会跳转到我们<br> 的 main 函数，如图标号②所示；而我们的 main 函数一般都是一个死循环，在 main 函数执行过<br> 程中，如果收到中断请求（发生重中断），此时 STM32F4 强制将 PC 指针指回中断向量表处，<br> 如图标号③所示；然后，根据中断源进入相应的中断服务程序，如图标号④所示；在执行完中<br> 断服务程序以后，程序再次返回 main 函数执行，如图标号⑤所示。</p> 
<p><img alt="" height="604" src="https://images2.imgbox.com/67/4a/uuVN7Z5c_o.png" width="814"></p> 
<p>        中断项链表的配置的寄存器在“Cortex-M3权威指南(中文)”文档中可以找到(113页)。</p> 
<p><img alt="" height="344" src="https://images2.imgbox.com/e6/be/8Ou1BRvy_o.png" width="920"></p> 
<p>下面是底层硬件地址结构体封装和正点项链表地址设置代码。</p> 
<pre><code class="language-cpp">/** @addtogroup CMSIS_CM3_SCB CMSIS CM3 SCB
  memory mapped structure for System Control Block (SCB)
  @{
 */
typedef struct
{
  __I  uint32_t CPUID;                        /*!&lt; Offset: 0x00  CPU ID Base Register                                  */
  __IO uint32_t ICSR;                         /*!&lt; Offset: 0x04  Interrupt Control State Register                      */
  __IO uint32_t VTOR;                         /*!&lt; Offset: 0x08  Vector Table Offset Register                          */
  __IO uint32_t AIRCR;                        /*!&lt; Offset: 0x0C  Application Interrupt / Reset Control Register        */
  __IO uint32_t SCR;                          /*!&lt; Offset: 0x10  System Control Register                               */
  __IO uint32_t CCR;                          /*!&lt; Offset: 0x14  Configuration Control Register                        */
  __IO uint8_t  SHP[12];                      /*!&lt; Offset: 0x18  System Handlers Priority Registers (4-7, 8-11, 12-15) */
  __IO uint32_t SHCSR;                        /*!&lt; Offset: 0x24  System Handler Control and State Register             */
  __IO uint32_t CFSR;                         /*!&lt; Offset: 0x28  Configurable Fault Status Register                    */
  __IO uint32_t HFSR;                         /*!&lt; Offset: 0x2C  Hard Fault Status Register                            */
  __IO uint32_t DFSR;                         /*!&lt; Offset: 0x30  Debug Fault Status Register                           */
  __IO uint32_t MMFAR;                        /*!&lt; Offset: 0x34  Mem Manage Address Register                           */
  __IO uint32_t BFAR;                         /*!&lt; Offset: 0x38  Bus Fault Address Register                            */
  __IO uint32_t AFSR;                         /*!&lt; Offset: 0x3C  Auxiliary Fault Status Register                       */
  __I  uint32_t PFR[2];                       /*!&lt; Offset: 0x40  Processor Feature Register                            */
  __I  uint32_t DFR;                          /*!&lt; Offset: 0x48  Debug Feature Register                                */
  __I  uint32_t ADR;                          /*!&lt; Offset: 0x4C  Auxiliary Feature Register                            */
  __I  uint32_t MMFR[4];                      /*!&lt; Offset: 0x50  Memory Model Feature Register                         */
  __I  uint32_t ISAR[5];                      /*!&lt; Offset: 0x60  ISA Feature Register                                  */
} SCB_Type;     </code></pre> 
<pre><code class="language-cpp">#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!&lt; SCB configuration struct          */</code></pre> 
<pre><code class="language-cpp">//设置向量表偏移地址
//NVIC_VectTab:基址
//Offset:偏移量			 
void MY_NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)	 
{ 	   	 
	SCB-&gt;VTOR = NVIC_VectTab|(Offset &amp; (u32)0x1FFFFF80);//设置NVIC的向量表偏移寄存器
	//用于标识向量表是在CODE区还是在RAM区
}</code></pre> 
<h2> 六、中断的优先级分组、优先级设置、外部中断的配置</h2> 
<h3> 6.1、stm32中断相关基础知识</h3> 
<p>        中断使用的时候不允许中断嵌套。</p> 
<p>        对于stm32f10xxx系列单片机而言，有<span style="color:#000000;">68</span><span style="color:#000000;">个可屏蔽中断通道</span><span style="color:#000000;">(</span><span style="color:#000000;">不包含</span><span style="color:#000000;">16</span><span style="color:#000000;">个</span><span style="color:#000000;">Cortex™-M3的中断线，16</span><span style="color:#000000;">个可编程的优先等级</span><span style="color:#000000;">(</span><span style="color:#fe2c24;">使用了4位中断优先级</span><span style="color:#000000;">)</span><span style="color:#000000;">；</span></p> 
<p><img alt="" height="487" src="https://images2.imgbox.com/95/8c/c5IpOQ86_o.png" width="837"></p> 
<div> 
 <span style="color:#000000;">        STM32 将中断分为 </span> 
 <span style="color:#000000;">5 </span> 
 <span style="color:#000000;">个组，组 </span> 
 <span style="color:#000000;">0~4</span> 
 <span style="color:#000000;">。该分组的设置是由 </span> 
 <span style="color:#fe2c24;">SCB-&gt;AIRCR 寄存器的 bit10~8 </span> 
 <span style="color:#000000;">来定义的。具体的分配关系如表 </span> 
 <span style="color:#000000;">4.5.1 </span> 
 <span style="color:#000000;">所示：</span> 
</div> 
<p><img alt="" height="209" src="https://images2.imgbox.com/78/a9/RX3ZK8MG_o.png" width="891"></p> 
<p><img alt="" height="486" src="https://images2.imgbox.com/6f/34/Km8qLj7i_o.png" width="874"></p> 
<p>        中断的使能的相关寄存器信息在“Cortex-M3权威指南(中文)”资料里面看，里面有中断使能相关的寄存器，中断只能的寄存器挂载在“SysTick_BASE”系统时钟总线上。</p> 
<div></div> 
<div> 
 <span style="color:#000000;">SETENAs: xE000_E100 – 0xE000_E11C ; CLRENAs:0xE000E180 - 0xE000_E19C</span> 
</div> 
<p><img alt="" height="524" src="https://images2.imgbox.com/61/b8/I1INklLW_o.png" width="859"></p> 
<div> 
 <span style="color:#000000;">SETPENDs:0xE000_E200 – 0xE000_E21C ; CLRPENDs:0xE000E280 - 0xE000_E29C</span> 
</div> 
<div></div> 
<p><img alt="" height="535" src="https://images2.imgbox.com/83/5d/GhiYYato_o.png" width="874"></p> 
<p>  ------------------------------------------------------------------------------------------------------------------------------</p> 
<p> <strong>       中断和事件的区别：</strong></p> 
<p>        事件机制提供了一个完全有硬件自动完成的触发到产生结果的通道，不要软件的参与，降低了CPU的负荷，节省了中断资源，提高了响应速度(硬件总快于软件)，是利用硬件来提升CPU芯片处理事件能力的一个有效方法。中断信号需要经过cpu的处理，然后调用中断处理函数进行处理。<br>         </p> 
<p></p> 
<p>这里先只讲解外部GPIO的中断，外设的中断后面再讲。</p> 
<div> 
 <strong><span style="color:#000000;">STM32F103 </span><span style="color:#000000;">的 </span><span style="color:#000000;">19 个外部中断为：</span></strong> 
</div> 
<div> 
 <span style="color:#000000;">        线 0~15</span> 
 <span style="color:#000000;">：对应外部 </span> 
 <span style="color:#000000;">IO </span> 
 <span style="color:#000000;">口的输入中断。 </span> 
</div> 
<div> 
 <span style="color:#000000;">        线 16</span> 
 <span style="color:#000000;">：连接到 </span> 
 <span style="color:#000000;">PVD </span> 
 <span style="color:#000000;">输出。 </span> 
</div> 
<div> 
 <span style="color:#000000;">        线 17</span> 
 <span style="color:#000000;">：连接到 </span> 
 <span style="color:#000000;">RTC </span> 
 <span style="color:#000000;">闹钟事件。 </span> 
</div> 
<div> 
 <span style="color:#000000;">        线 18</span> 
 <span style="color:#000000;">：连接到 </span> 
 <span style="color:#000000;">USB </span> 
 <span style="color:#000000;">唤醒事件。 </span> 
</div> 
<p>stm32的外部中断是按pin号进行分级管理的，共有16个管理器。</p> 
<p><img alt="" height="691" src="https://images2.imgbox.com/fc/2c/0aK4xeIB_o.png" width="881"></p> 
<p></p> 
<p>        stm32的系统时钟和中断相关的操作的寄存器需要参考“<span style="color:#fe2c24;">Cortex-M3权威指南(中文)</span>”和“<span style="color:#fe2c24;">STM32中文参考手册_V10</span>”关于中断向量这些的定义是Cortex-M3相关，stm32官方直接使用的，基本外设这些寄存器是stm32官方根据需求自己定义的，所以对时钟和中断的配置需要参考两个的文档。</p> 
<h3>6.2、中断项链表偏移地址的配置以及分组设置（不是必须的，自己代码可以步配置，使用默认的）</h3> 
<p>        使用到的寄存器如下所示，来自“<span style="color:#fe2c24;">Cortex-M3权威指南(中文)</span>”。</p> 
<p><img alt="" height="175" src="https://images2.imgbox.com/7b/60/4s2c5zdp_o.png" width="879"></p> 
<p><img alt="" height="427" src="https://images2.imgbox.com/b3/3a/IZWiV8CJ_o.png" width="898"></p> 
<p>        下面是正点地中断向量表地址配置代码：</p> 
<pre><code class="language-cpp">//设置向量表偏移地址
//NVIC_VectTab:基址
//Offset:偏移量			 
void MY_NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)	 
{ 	   	 
	SCB-&gt;VTOR = NVIC_VectTab|(Offset &amp; (u32)0x1FFFFF80);//设置NVIC的向量表偏移寄存器
	//用于标识向量表是在CODE区还是在RAM区
}</code></pre> 
<p>        根据6.1中地前两个图可以知道如何设置寄存器地分组，下面是正点的中断优先级分组的代码：</p> 
<pre><code class="language-cpp">//设置NVIC分组
//NVIC_Group:NVIC分组 0~4 总共5组 		   
void MY_NVIC_PriorityGroupConfig(u8 NVIC_Group)	 
{ 
	u32 temp,temp1;	  
	temp1=(~NVIC_Group)&amp;0x07;//取后三位，分组数与位的设置正好是取反的关系
	temp1&lt;&lt;=8;        //移位到寄存器AIRCR中断优先级分组配置位置
	temp=SCB-&gt;AIRCR;  //读取先前的设置
	temp&amp;=0X0000F8FF; //清空先前分组
	temp|=0X05FA0000; //写入钥匙，根据手册，改变寄存器必须写入钥匙
	temp|=temp1;	   
	SCB-&gt;AIRCR=temp;  //设置分组	    	  				   
}</code></pre> 
<h2>七、stm32内存架构</h2> 
<p>        stm32的内存架构是非常重要的，有助于理解stm32的寄存器的配置，程序员经常关心和使用的内存区域主要有SRAM和Flash两个区域。</p> 
<h3>7.1、内存的基础知识点        </h3> 
<p>       <span style="color:#fe2c24;"> RAM：</span>随机存取存储器（英语：Random Access Memory，缩写：RAM），也叫主存，是与CPU直接交换数据的内部存储器。</p> 
<p>        <span style="color:#fe2c24;">ROM:</span>（只读内存(Read-Only Memory)简称）英文简称ROM。ROM所存数据，一般是装入整机前事先写好的，整机工作过程中只能读出，而不像随机存储器那样能快速地、方便地加以改写。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        内存有ROM（掉电不丢失，例如Flash）和RAM（掉电丢失，例如SRAM），下面是关于两种内存的介绍：</p> 
<p><img alt="" height="667" src="https://images2.imgbox.com/81/1e/U3gHgqPm_o.png" width="760"></p> 
<h4>7.1.1、Flash</h4> 
<p>        通过上图我们可以知道，FLASH属于 非易失性存储器：</p> 
<p style="margin-left:.0001pt;text-align:justify;">        FLASH又称为闪存，不仅具备电子可擦除可编程(EEPROM)的性能，还不会断电丢失数据同时可以快速读取数据，U盘和MP3里用的就是这种存储器。在以前的嵌入式芯片中，存储设备一直使用ROM(EPROM)，随着技术的进步，现在嵌入式中基本都是FLASH，用作存储Bootloader以及操作系统或者程序代码或者直接当硬盘使用(U盘)。</p> 
<p>        <span style="color:#fe2c24;">Flash 主要有两种NOR Flash和NADN Flash</span>：</p> 
<p style="margin-left:.0001pt;text-align:justify;">        NOR Flash的读取和我们常见的SDRAM的读取是一样，用户可以直接运行装载在NOR FLASH里面的代码，这样可以减少SRAM的容量从而节约了成本，<span style="color:#fe2c24;"><strong>可以随机读写</strong></span>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        NAND Flash<span style="color:#fe2c24;">没有采取内存的随机读取技术</span>，它的读取是以一次读取一块的形式来进行的，通常是一次读取512个字节，采用这种技术的Flash比较廉价。用户不能直接运行NAND Flash上的代码，因此好多使用NAND Flash的开发板除了使用NAND Flah以外，还作上了一块小的NOR Flash来运行启动代码。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;"><span style="color:#ff0000;">        STM32单片机内部的FLASH为 NOR FLASH。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;"><span style="color:#ff0000;">        Flash 相对容量大，掉电数据不丢失，主要用来存储 代码，以及一些掉电不丢失的用户数据。</span></span></p> 
<h4>7.1.2、RAM</h4> 
<p>        RAM 属于易失性存储器：</p> 
<p>        RAM随机存储器（Random Access Memory）表示既可以从中读取数据，也可以写入数据。当机器电源关闭时，存于其中的数据就会丢失。比如电脑的内存条。</p> 
<p>        RAM有两大类，一种称为静态RAM(Static RAM/SRAM)，SRAM速度非常快，是目前读写最快的存储设备了，但是它也非常昂贵，所以只在要求很苛刻的地方使用，譬如CPU的一级缓冲，二级缓冲。另一种称为动态RAM(Dynamic RAM/DRAM)，DRAM保留数据的时间很短，速度也比SRAM慢，不过它还是比任何的ROM都要快，但从价格上来说DRAM相比SRAM要便宜很多，计算机内存就是DRAM的。</p> 
<p>        为什么需要RAM，因为相对FlASH而言，RAM的速度快很多，所有数据在FLASH里面读取太慢了，为了加快速度，就把一些需要和CPU交换的数据读到RAM里来执行（注意这里不是全部数据，只是一部分需要的数据，这个在后面介绍STM32的内存管理中会提到）。</p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;"><span style="color:#ff0000;">        STM32单片机内部的 RAM 为 SRAM。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;"><span style="color:#ff0000;">        RAM相对容量小，速度快，掉电数据丢失，其作用是用来存取各种动态的输入输出数据、中间计算结果以及与外部存储器交换的数据和暂存数据。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;"><span style="color:#ff0000;">        总结：stm32的RAM内存为SRAM，ROM为Flash。</span></span></p> 
<p></p> 
<p></p> 
<p>        stm32的内存管理分为两部分，一部分是关于内核的，stm32参照Cortex-M内核进行内存映射地址的设置。另一部分是stm32根据不同单片机进行的内存地址的映射，两种地址设置的方式都是非常重要的，下面将对其进行张开叙述。</p> 
<h3>7.2、Cortex-M3的存储器映射</h3> 
<p>        Cortex-M3的存储器映射是stm32单片机存储区映射的基本框架和标准。stm32单片机可以在此标准下进行关于自己的存储器映射的扩展。</p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/29/09/9gxXCqeI_o.png" width="700"></p> 
<p style="margin-left:.0001pt;text-align:justify;">        存储器映射 是用 地址来表示 对象，<span style="color:#fe2c24;">因为Cortex-M3是32位的单片机，因此其PC指针可以指向2^32=4G的地址空间，也就是图中的 0x00000000到0xFFFFFFFF的区间</span>，也就是将程序存储器、数据存储器、寄存器和输入输出端口被组织在同一个4GB的线性地址空间内，数据字节以小端格式存放在存储器中。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        注意：上面介绍的内存的地址分布架构，只要单片机采用上面的架构，就需要遵守上面的地址规定，区域的首地址是不能改变的，<span style="color:#fe2c24;">不同的单片机使用的内存的大小是不一样的，首地址不能改变，</span>后面不适用的映射地址可以保留。</p> 
<p>         前三个区域对于程序员来说是比较重要的。</p> 
<h3>7.3、stm32的存储器映射</h3> 
<p>        STM32存储器映射表（选用的是STM32F103VE的，不同的型号Flash 和 SRAM 的地址空间不同，起始地址都是一样的），stm32地栈和堆的位置所需要的内存都在“  64K大小的SRAM”的位置：</p> 
<p><img alt="" height="833" src="https://images2.imgbox.com/a1/10/9TwtnYyW_o.png" width="734"></p> 
<p style="margin-left:.0001pt;text-align:justify;">        那么我们所需要分析的STM32 内存，就是图中 0X0800 0000开始的 Flash 部分 和 0x2000 0000 开始的SRAM部分，这里还要介绍一个和Flash模块相关的部分，从0X0800 0000开始的 Flash 部分，可以对其进行划分为：主存储块、信息块、闪存存储器接口寄存器。</p> 
<p>        STM32的Flash，严格说，应该是Flash模块。该Flash模块包括：<span style="color:#ff0000;">Flash主存储区（Main memory）</span>、<span style="color:#ff0000;">Flash信息区（Informationblock）</span>，以及<span style="color:#ff0000;">Flash存储接口寄存器区（Flash memory interface）</span>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">        主存储器，</span>该部分用来存放代码和数据常数（如加const类型的数据）。对于大容量产品，其被划分为256页，每页2K，小容量和中容量产品则每页只有1K字节。主存储起的起始地址为0X08000000，B0、B1都接GND的时候，就从0X08000000开始运行代码。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">        信息块，</span>该部分分为2个部分，其中启动程序代码，是用来存储ST自带的启动程序，用于下载，当B0接3.3V，B1接GND时，运行的就这部分代码，用户选择字节，则一般用于配置保护等功能。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">        闪存储器块，</span>该部分用于控制闪存储器读取等，是整个闪存储器的控制机构。</p> 
<p style="margin-left:.0001pt;text-align:justify;">对于主存储器和信息块的写入有内嵌的闪存编程管理；编程与擦除的高压由内部产生。</p> 
<p style="margin-left:.0001pt;text-align:justify;">在执行闪存写操作时，任何对闪存的读操作都会锁定总线，在写完成后才能正确进行，在进行读取或擦除操作时，不能进行代码或者数据的读取操作。</p> 
<h3>7.4、stm32的代码中内存管理</h3> 
<p>        STM32 的内存管理起始就是对0X0800 0000 开始的 Flash 部分 和  0x2000 0000 开始的 SRAM 部分使用管理。根据程序中的数据存储可以划分为6个存储数据段和3种存储属性区。</p> 
<p><img alt="" height="351" src="https://images2.imgbox.com/63/4e/GIiZlFvo_o.png" width="863"></p> 
<p>        上面几个6个存储数据段和3种存储属性区，将从代码的层次进行分析。</p> 
<p><img alt="" height="471" src="https://images2.imgbox.com/71/47/yPGu04EK_o.png" width="1180"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#ff0000;"><strong>（1）Code：</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">        程序代码部分。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>.text 段</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">        放在ROM里面，就是Flash，需要占用flash空间</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#ff0000;"><strong>（2）RO-data</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">        (Read Only)只读数据</p> 
<p style="margin-left:.0001pt;text-align:justify;">        程序定义的常量,只读数据，字符串常量（const修饰的）</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>.constdata 段</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">        放在flash里面，需要占用flash空间</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#ff0000;"><strong>（3）RW-data</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">        (Read Write)可读可写数据</p> 
<p style="margin-left:.0001pt;text-align:justify;">        已经初始化的全局变量和静态变量（就是static修饰的变量）；</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>.data 段</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">        需要在 RAM里面运行，但是起初需要保存在 Flash里面，程序运行后复制到 RAM里面运行，需要占用Flash空间。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#ff0000;"><strong>（4）ZI-data</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">        (Zero Initialize)未初始化的全局变量和静态变量，以及初始化为0的变量；</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>.BSS段</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">        ZI的数据全部是0，没必要开始就包含，只要程序运行之前将ZI数据所在的区域（RAM里面）一律清 0，不占用Flash，运行时候占用RAM。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>       <span style="color:#fe2c24;"> heap</span></strong></strong><span style="color:#fe2c24;"> 和 <strong><strong>stack</strong></strong> 其实也属于 ZI</span>，只不过他不是程序编译就能确定大小的，必须在运行中才会有大小，而是是变化的，<span style="background-color:#ffffff;"><span style="color:#0033ff;">因为RAM掉电丢失，所以 RW-data 数据也得下载到ROM（flash） 中，在运行的时候复制到 RAM中运行</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">，如下图所示（图中的地址也是错的，应该是从0x0800 0000 开始）：</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">        由上我们得知：</p> 
<p style="margin-left:.0001pt;text-align:justify;">       <strong> 程序</strong>占用 <strong><strong>Flash = Code + RO data + RW data</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">        <strong>程序运行</strong>时候占用 <strong><strong>RAM = RW data + ZI data。</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>        Code + RO data + RW data</strong></strong> 的大小也是生成的<strong><strong> bin </strong></strong>文件的大小</p> 
<p><img alt="" height="465" src="https://images2.imgbox.com/39/72/aXJ9s3FB_o.png" width="626"></p> 
<p><img alt="" height="513" src="https://images2.imgbox.com/ab/af/TE7MaLei_o.png" width="850"></p> 
<p style="margin-left:.0001pt;text-align:justify;">        在 <strong><strong>startup_stm32fxxx.s</strong></strong> 中我们可以看到关于 <strong><strong>Stack_Size</strong></strong> 和 <strong><strong>Heap_Size</strong></strong>的定义，图中的定义就是规定本程序中 栈 的大小为 <strong><strong>1K</strong></strong>， 堆的大小为 <strong><strong>0.5K</strong></strong>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        经过keil编译过后的文件会生成“test.map”的文件，这个文件中有编译之后的栈和堆的位置，但是这些都是不固定的，所以用户自己使用这段内存的时候，需要看堆的地址，也可以直接使用malloc进行堆上数据的申请，但是这种方式容易形成碎片内存的现象（例如刚开始申请了2，之后有申请了3，释放前面申请的2之后，在申请3的时候，前面的连续内存2就不能使用了，这样连续进行小容量的malloc申请，就会形成很对如前面没用的2的碎片内存。最后造成系统内存减少。）</p> 
<h3>7.5、stm32启动方式</h3> 
<p><img alt="" height="140" src="https://images2.imgbox.com/c3/4c/ma5TYCrI_o.png" width="845"></p> 
<p style="margin-left:.0001pt;text-align:justify;">        <strong>第一种</strong>启动方式是最常用的用户FLASH启动，正常工作就在这种模式下，STM32的FLASH可以擦出10万次，所以不用担心芯片哪天会被擦爆！</p> 
<p style="margin-left:.0001pt;text-align:justify;">        <strong>第二种</strong>启动方式是系统存储器启动方式，即我们常说的串口下载方式（ISP），不建议使用这种，速度比较慢。STM32 中自带的BootLoader就是在这种启动方式中，如果出现程序硬件错误的话可以切换BOOT0/1到该模式下重新烧写Flash即可恢复正常。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        <strong>第三种</strong>启动方式是STM32内嵌的SRAM启动。该模式用于调试。 用jlink在线仿真，则是下载到SRAM中。</p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;">以上三种启动方式我们都很熟悉，但是他的究竟是如何实现的呢？</p> 
<p style="margin-left:.0001pt;text-align:justify;">我们先来看看《Cortex-M3权威指南》关于CM3复位后的动作：</p> 
<p><img alt="" height="320" src="https://images2.imgbox.com/be/1d/OAmG3QYE_o.png" width="876"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">当选择相应的启动方式时，对应的存储器空间被映射到启动空间(0x00000000)。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">        从闪存存储器启动：主闪存存储器被映射到启动空间(0x0000 0000) ,也就是0x08000000被映射到0x00000000。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        从内嵌SRAM启动 ：SRAM起始地址 0x2000 0000 被映射到0x00000000。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        从系统存储器启动：系统存储器被映射到启动空间(0x0000 0000)，也就是0x1FFF F000被映射到0x00000000。</p> 
<p style="margin-left:.0001pt;text-align:justify;">(为什么是0x1FFF F000 可以查阅上文中的 2.2小节 STM32 的存储器映射分析，STM32互联型产品这个地址不一样，此地址由ST官方写入了一段BootLoader代码，可以通过官方BootLoader升级MCU固件，无法修改）。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>参考链接：</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><a href="https://blog.csdn.net/weixin_42328389/article/details/120622384" title="STM32的内存管理相关（内存架构，内存管理，map文件分析）_stm32f103 malloc_矜辰所致的博客-CSDN博客">STM32的内存管理相关（内存架构，内存管理，map文件分析）_stm32f103 malloc_矜辰所致的博客-CSDN博客</a></p> 
<p style="margin-left:.0001pt;text-align:justify;"><a href="https://blog.csdn.net/zhuguanlin121/article/details/119799860?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link" title="深入理解STM32内存管理_行稳方能走远的博客-CSDN博客">深入理解STM32内存管理_行稳方能走远的博客-CSDN博客</a></p> 
<h2>八、stm32时钟树基础总线地址</h2> 
<p>        stm32对基本外设的管理都是通过总线进行管理的，外设的配置寄存器的操作形式为“基础地址+偏移地址”，其中的基础地址就是总线的地址。</p> 
<p><img alt="" height="696" src="https://images2.imgbox.com/f7/f6/91d2N5Gz_o.png" width="909"></p> 
<p><img alt="" height="719" src="https://images2.imgbox.com/c3/18/h8juRkM9_o.png" width="995"></p> 
<p> <img alt="" height="753" src="https://images2.imgbox.com/19/d0/U4CuLJqg_o.png" width="669"></p> 
<p>        stm32f1系列的基础地址的映射分为两部分，有部分是片上外设（eripheral_memory_map）如上图中“A”的位置。另一个映射区域为Cortex-M3的内核寄存器（/* Memory mapping of Cortex-M3 Hardware */）如图中的“B”的位置。在stm32f1的代码文件中，两种寄存器的定义分别在“stm32f10x.h”和“core_cm3.h”的代码文件里面。</p> 
<p>        下面是“stm32f10x.h”代码中对片上外设（eripheral_memory_map）基础总线地址的定义。</p> 
<pre><code class="language-cpp">/** @addtogroup Peripheral_memory_map
  * @{
  */


#define FLASH_BASE            ((uint32_t)0x08000000) /*!&lt; FLASH base address in the alias region */
#define SRAM_BASE             ((uint32_t)0x20000000) /*!&lt; SRAM base address in the alias region */
#define PERIPH_BASE           ((uint32_t)0x40000000) /*!&lt; Peripheral base address in the alias region */

#define SRAM_BB_BASE          ((uint32_t)0x22000000) /*!&lt; SRAM base address in the bit-band region */
#define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!&lt; Peripheral base address in the bit-band region */

#define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!&lt; FSMC registers base address */

/*!&lt; Peripheral memory map */
#define APB1PERIPH_BASE       PERIPH_BASE
#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)

#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
#define TIM12_BASE            (APB1PERIPH_BASE + 0x1800)
.................等</code></pre> 
<p>        下面是“core_cm3.h”代码文件中对Cortex-M3的内核寄存器（/* Memory mapping of Cortex-M3 Hardware */）的定义的情况。</p> 
<pre><code class="language-cpp">/* Memory mapping of Cortex-M3 Hardware */
#define SCS_BASE            (0xE000E000)                              /*!&lt; System Control Space Base Address */
#define ITM_BASE            (0xE0000000)                              /*!&lt; ITM Base Address                  */
#define CoreDebug_BASE      (0xE000EDF0)                              /*!&lt; Core Debug Base Address           */
#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!&lt; SysTick Base Address              */
#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!&lt; NVIC Base Address                 */
#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!&lt; System Control Block Base Address */

#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!&lt; Interrupt Type Register           */
#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!&lt; SCB configuration struct          */
#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!&lt; SysTick configuration struct      */
#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!&lt; NVIC configuration struct         */
#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!&lt; ITM configuration struct          */
#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!&lt; Core Debug configuration struct   */
</code></pre> 
<p>上面比较重要的就是<span style="color:#fe2c24;">AHB</span>、<span style="color:#fe2c24;">APB1</span>、<span style="color:#fe2c24;">APB2</span>、<span style="color:#fe2c24;">SysTick_BASE</span>几个总线的地址的地址是比较重要的。</p> 
<table><thead><tr><th>总线名称</th><th>总线基地址</th></tr></thead><tbody><tr><td>APB1</td><td>0x4000 0000</td></tr><tr><td>APB2</td><td>0x4001 0000</td></tr><tr><td>AHB</td><td>0x4002 0000</td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8c6546aef371dc0cc6188a9bad3bc6da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">通俗理解词向量模型，预训练模型，Transfomer，Bert和GPT的发展脉络和如何实践</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d1aec94ebf1aa6cf163c2f5268223d92/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Kotlin基础——Lambda和函数式编程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>