<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用Opencv的车牌识别 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用Opencv的车牌识别" />
<meta property="og:description" content="使用openCV识别车牌 流程框架 图像的预处理 车牌定位的第一步为图像预处理。为了方便计算，系统通常将获取的图片灰度化。将彩色图像转化成为灰度图像的过程就称为图像的灰度化处理。彩色图像中R、G、B三个分量的值决定了具体的像素点。一个像素点可以有上千万种颜色。而灰度图像是一种彩色图像，但是它的特点在于R、G、B三个分量具体的值是一致的。灰度图中每个像素点的变化区间是0到255，由于方便计算，所以在实际工程处理中会先将各种格式的图像转变成灰度图像。在保留图像轮廓和特征的基础上，灰度图仍然能够反映整幅图像轮廓和纹理。在Opencv里面有实现图像灰度化的接口。调用OpenCV中的cvSmooth函数进行中值滤波处理，以去除细小毛刺。 图像二值化 局部自适应二值化是针对灰度图像中的每一个像素逐点进行阈值计算，它的阈值是由像素周围点局部灰度特性和像素灰度值来确定的。局部阈值法是逐个计算图像的每个像素灰度级，保存了图像的细节信息，非均匀光照条件等情况虽然影响整个图像的灰度分布缺不影响局部的图像性质，但也存在缺点和问题，相比全局阈值法来说，它的计算时间较长，但适用于多变的环境。
设图像在像素点(x,y)处的灰度值为f(x,y)，考虑以像素点(x,y)为中心的(2w&#43;1)*(2w&#43;1)窗口（w为窗口宽度），则局部自适应二值化算法可以描述如下：
a.计算图像中各点(x,y)的阈值w(x,y)
W(x,y)=0.5*(max f(x&#43;m,y&#43;n)&#43;min f(x&#43;m,y&#43;n))
b.如果f(x,y)&gt;w(x,y)，则二值化结果为1，代表字符区域的目标点；否则二值化结果为0，代表背景区域的目标点。
灰度化和二值化的区别 灰度化：现在大部分的彩色图像都是采用RGB颜色模式，处理图像的时候，要分别对RGB三种分量进行处理，实际上RGB并不能反映图像的形态特征，只是从光学的原理上进行颜色的调配。 在RGB模型中，如果R=G=B时，则彩色表示一种灰度颜色，其中R=G=B的值叫灰度值，因此，灰度图像每个像素只需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255。一般常用的是加权平均法来获取每个像素点的灰度值。
图像的预处理，加载图像、并灰度化、高斯滤波
void CMyDialog::OnLoadimage() { // TODO: Add your control notification handler code here src = NULL ; CString filePath; CFileDialog dlg(TRUE, _T(&#34;*.bmp&#34;),&#34;&#34;,OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY,&#34;image files (*.bmp; *.jpg) |*.bmp;*.jpg|All Files (*.*)|*.*||&#34;,NULL); char title[]= {&#34;Open Image&#34;}; dlg.m_ofn.lpstrTitle= title; if (dlg.DoModal() == IDOK) { filePath= dlg.GetPathName(); src=cvLoadImage(filePath); DrawPicToHDC(src,IDC_IMAGESRC); } pImgCanny=cvCreateImage(cvSize(src-&gt;width,src-&gt;height),IPL_DEPTH_8U,1); cvCvtColor(src,pImgCanny,CV_RGB2GRAY); cvSmooth(pImgCanny,pImgCanny,CV_GAUSSIAN,3,0,0); //平滑高斯滤波 滤波后的图片保存在 pImgCanny } 二值化：就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的只有黑和白的视觉效果。 一幅图像包括目标物体、背景还有噪声，要想从多值的数字图像中直接提取出目标物体，常用的方法就是设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。 二值化图像" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/719ab4540a9de24dfaef993d8e879296/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-11T17:13:35+08:00" />
<meta property="article:modified_time" content="2018-08-11T17:13:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用Opencv的车牌识别</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="使用opencv识别车牌">使用openCV识别车牌</h2> 
<h3 id="流程框架">流程框架</h3> 
<p><img src="https://images2.imgbox.com/ca/79/s9Ewq5p1_o.png" alt="这里写图片描述" title=""></p> 
<h4 id="图像的预处理">图像的预处理</h4> 
<p>车牌定位的第一步为图像预处理。为了方便计算，系统通常将获取的图片灰度化。将彩色图像转化成为灰度图像的过程就称为图像的灰度化处理。彩色图像中R、G、B三个分量的值决定了具体的像素点。一个像素点可以有上千万种颜色。而灰度图像是一种彩色图像，但是它的特点在于R、G、B三个分量具体的值是一致的。灰度图中每个像素点的变化区间是0到255，由于方便计算，所以在实际工程处理中会先将各种格式的图像转变成灰度图像。在保留图像轮廓和特征的基础上，灰度图仍然能够反映整幅图像轮廓和纹理。在Opencv里面有实现图像灰度化的接口。调用OpenCV中的cvSmooth函数进行中值滤波处理，以去除细小毛刺。 <br> <img src="https://images2.imgbox.com/5c/b1/TTPPtDIf_o.png" alt="这里写图片描述" title=""></p> 
<h5 id="图像二值化">图像二值化</h5> 
<p>局部自适应二值化是针对灰度图像中的每一个像素逐点进行阈值计算，它的阈值是由像素周围点局部灰度特性和像素灰度值来确定的。局部阈值法是逐个计算图像的每个像素灰度级，保存了图像的细节信息，非均匀光照条件等情况虽然影响整个图像的灰度分布缺不影响局部的图像性质，但也存在缺点和问题，相比全局阈值法来说，它的计算时间较长，但适用于多变的环境。</p> 
<p>设图像在像素点(x,y)处的灰度值为f(x,y)，考虑以像素点(x,y)为中心的(2w+1)*(2w+1)窗口（w为窗口宽度），则局部自适应二值化算法可以描述如下：</p> 
<p>a.计算图像中各点(x,y)的阈值w(x,y)</p> 
<p>W(x,y)=0.5*(max f(x+m,y+n)+min f(x+m,y+n))</p> 
<p>b.如果f(x,y)&gt;w(x,y)，则二值化结果为1，代表字符区域的目标点；否则二值化结果为0，代表背景区域的目标点。</p> 
<h5 id="灰度化和二值化的区别">灰度化和二值化的区别</h5> 
<p><strong>灰度化</strong>：现在大部分的彩色图像都是采用RGB颜色模式，处理图像的时候，要分别对RGB三种分量进行处理，实际上RGB并不能反映图像的形态特征，只是从光学的原理上进行颜色的调配。 </p> 
<p>在RGB模型中，如果R=G=B时，则彩色表示一种灰度颜色，其中R=G=B的值叫灰度值，因此，灰度图像每个像素只需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255。一般常用的是加权平均法来获取每个像素点的灰度值。</p> 
<p>图像的预处理，加载图像、并灰度化、高斯滤波</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">void</span> CMyDialog::OnLoadimage() 
{
    <span class="hljs-comment">// TODO: Add your control notification handler code here</span>
    src = <span class="hljs-literal">NULL</span> ;
    CString filePath;
    CFileDialog dlg(<span class="hljs-literal">TRUE</span>, _T(<span class="hljs-string">"*.bmp"</span>),<span class="hljs-string">""</span>,OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY,<span class="hljs-string">"image files (*.bmp; *.jpg) |*.bmp;*.jpg|All Files (*.*)|*.*||"</span>,<span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">char</span> title[]= {<!-- --><span class="hljs-string">"Open Image"</span>};
    dlg<span class="hljs-variable">.m_ofn</span><span class="hljs-variable">.lpstrTitle</span>= title;
    <span class="hljs-keyword">if</span> (dlg<span class="hljs-variable">.DoModal</span>() == IDOK) {
        filePath= dlg<span class="hljs-variable">.GetPathName</span>();
        src=cvLoadImage(filePath);
        DrawPicToHDC(src,IDC_IMAGESRC);
    }   
    pImgCanny=cvCreateImage(cvSize(src-&gt;width,src-&gt;height),IPL_DEPTH_8U,<span class="hljs-number">1</span>);

    cvCvtColor(src,pImgCanny,CV_RGB2GRAY);
    cvSmooth(pImgCanny,pImgCanny,CV_GAUSSIAN,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);   <span class="hljs-comment">//平滑高斯滤波  滤波后的图片保存在 pImgCanny            </span>
}</code></pre> 
<p><strong>二值化</strong>：就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的只有黑和白的视觉效果。 <br> 一幅图像包括目标物体、背景还有噪声，要想从多值的数字图像中直接提取出目标物体，常用的方法就是设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。 <br> 二值化图像</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-keyword">void</span> CMyDialog::Threshold(IplImage *Image, IplImage *Image_O)
{
    <span class="hljs-keyword">int</span> thresMax=<span class="hljs-number">0</span>,thresMin=<span class="hljs-number">255</span>,i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>;
    <span class="hljs-comment">//循环得到图片的最大灰度值和最小灰度值</span>
    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;Image-&gt;height;j++)
        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;Image-&gt;width;i++)
        {
            if(CV_IMAGE_ELEM(Image,<span class="hljs-keyword">uchar</span>,j,i)&gt;thresMax) 
                thresMax=CV_IMAGE_ELEM(Image,<span class="hljs-keyword">uchar</span>,j,i);
            <span class="hljs-keyword">else</span> if(CV_IMAGE_ELEM(Image,<span class="hljs-keyword">uchar</span>,j,i)&lt;thresMin)   
                thresMin=CV_IMAGE_ELEM(Image,<span class="hljs-keyword">uchar</span>,j,i);
        }

    <span class="hljs-comment">//小阈值用来控制边缘连接  大阈值用来控制强边缘的初始化分割</span>
    cvCanny(Image,Image_O,AdaptiveThreshold((thresMax+thresMin)*<span class="hljs-number">0.5</span>,Image),thresMax*<span class="hljs-number">0.7</span>,<span class="hljs-number">3</span>);

}</code></pre> 
<p>我们来看一下图片二值化和灰度化后的区别 <br> 灰度化的图片 <br> <img src="https://images2.imgbox.com/8b/31/er8mv5Zg_o.png" alt="这里写图片描述" title=""> <br> 二值化的图片 <br> <img src="https://images2.imgbox.com/10/c4/IX9wF9Vq_o.png" alt="这里写图片描述" title=""></p> 
<h4 id="利用carry算子实现车牌的边缘检测">利用carry算子实现车牌的边缘检测</h4> 
<p>Canny边缘检测是从不同视觉对象中提取有用的结构信息并大大减少要处理的数据量的一种技术，目前已广泛应用于各种计算机视觉系统。Canny发现，在不同视觉系统上对边缘检测的要求较为类似，因此，可以实现一种具有广泛应用意义的边缘检测技术。边缘检测的一般标准包括：</p> 
<ul><li>尽可能准确的捕获图像中尽可能多的边缘。</li><li>检测到的边缘应精确定位在真实边缘的中心。</li><li>图像中给定的边缘应只被标记一次，并且在可能的情况下，图像的噪声不应产生假的边缘。</li></ul> 
<p><strong>Canny边缘检测算法可以分为以下5个步骤</strong>：</p> 
<p>(1)使用高斯滤波器，以平滑图像，滤除噪声。</p> 
<ul><li>为了尽可能减少噪声对边缘检测结果的影响，所以必须滤除噪声以防止由噪声引起的错误检测。为了平滑图像，使用高斯滤波器与图像进行卷积，该步骤将平滑图像，以减少边缘检测器上明显的噪声影响。大小为(2k+1)x(2k+1)的高斯滤波器核的生成方程式由下式给出： <br> <img src="https://images2.imgbox.com/f4/d9/7JNezAXe_o.png" alt="这里写图片描述" title="">大小为下面是一个sigma = 1.4，尺寸为3x3的高斯卷积核的例子（需要注意归一化）： <br> <img src="https://images2.imgbox.com/ad/2a/UstAO3T1_o.png" alt="这里写图片描述" title=""> <br> 若图像中一个3x3的窗口为A，要滤波的像素点为e，则经过高斯滤波之后，像素点e的亮度值为： <br> <img src="https://images2.imgbox.com/b3/76/UljZobOr_o.png" alt="这里写图片描述" title="">其中*为卷积符号，sum表示矩阵中所有元素相加求和。重要的是需要理解，高斯卷积核大小的选择将影响Canny检测器的性能。尺寸越大，检测器对噪声的敏感度越低，但是边缘检测的定位误差也将略有增加。一般5x5是一个比较不错的trade off。</li></ul> 
<p>(2)计算图像中每个像素点的梯度强度和方向。</p> 
<ul><li>图像中的边缘可以指向各个方向，因此Canny算法使用四个算子来检测图像中的水平、垂直和对角边缘。边缘检测的算子（如Roberts，Prewitt，Sobel等）返回水平Gx和垂直Gy方向的一阶导数值，由此便可以确定像素点的梯度G和方向theta 。 <br> <img src="https://images2.imgbox.com/80/91/jRIFNmQl_o.png" alt="这里写图片描述" title=""> <br> 其中G为梯度强度， theta表示梯度方向，arctan为反正切函数。下面以Sobel算子为例讲述如何计算梯度强度和方向。 <br> x和y方向的Sobel算子分别为： <br> <img src="https://images2.imgbox.com/f4/79/MBPg1Gai_o.png" alt="这里写图片描述" title=""> <br> 其中Sx表示x方向的Sobel算子，用于检测y方向的边缘； Sy表示y方向的Sobel算子，用于检测x方向的边缘（边缘方向和梯度方向垂直）。在直角坐标系中，Sobel算子的方向如下图所示。 <br> <img src="https://images2.imgbox.com/cd/ad/M4piGRCe_o.png" alt="这里写图片描述" title=""> <br> 若图像中一个3x3的窗口为A，要计算梯度的像素点为e，则和Sobel算子进行卷积之后，像素点e在x和y方向的梯度值分别为： <br> <img src="https://images2.imgbox.com/2a/3f/qJOLik2T_o.png" alt="这里写图片描述" title=""> <br> 其中*为卷积符号，sum表示矩阵中所有元素相加求和。根据公式（3-2）便可以计算出像素点e的梯度和方向。</li></ul> 
<p>(3) 应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。</p> 
<ul><li><p>非极大值抑制是一种边缘稀疏技术，非极大值抑制的作用在于“瘦”边。对图像进行梯度计算后，仅仅基于梯度值提取的边缘仍然很模糊。对于标准3，对边缘有且应当只有一个准确的响应。而非极大值抑制则可以帮助将局部最大值之外的所有梯度值抑制为0</p> <p>对梯度图像中每个像素进行非极大值抑制的算法是：</p> <p>(1)将当前像素的梯度强度与沿正负梯度方向上的两个像素进行比较。 <br> (2)如果当前像素的梯度强度与另外两个像素相比最大，则该像素点保留为边缘点，否则该像素点将被抑制。 <br> 通常为了更加精确的计算，在跨越梯度方向的两个相邻像素之间使用线性插值来得到要比较的像素梯度，现举例如下： <br> <img src="https://images2.imgbox.com/5a/50/iRv4MaJ9_o.png" alt="这里写图片描述" title=""> <br> 如图所示，将梯度分为8个方向，分别为E、NE、N、NW、W、SW、S、SE，其中0代表00~45o,1代表450~90o，2代表-900~-45o，3代表-450~0o。像素点P的梯度方向为theta，则像素点P1和P2的梯度线性插值为： <br> <img src="https://images2.imgbox.com/6b/4c/nMkuQyjP_o.png" alt="这里写图片描述" title=""> <br> 因此非极大值抑制的伪代码描写如下： <br> <img src="https://images2.imgbox.com/e6/ae/bGF1tzF6_o.png" alt="这里写图片描述" title=""> <br> 需要注意的是，如何标志方向并不重要，重要的是梯度方向的计算要和梯度算子的选取保持一致。</p></li></ul> 
<p>(4) 应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。 <br> - 在施加非极大值抑制之后，剩余的像素可以更准确地表示图像中的实际边缘。然而，仍然存在由于噪声和颜色变化引起的一些边缘像素。为了解决这些杂散响应，必须用弱梯度值过滤边缘像素，并保留具有高梯度值的边缘像素，可以通过选择高低阈值来实现。如果边缘像素的梯度值高于高阈值，则将其标记为强边缘像素；如果边缘像素的梯度值小于高阈值并且大于低阈值，则将其标记为弱边缘像素；如果边缘像素的梯度值小于低阈值，则会被抑制。阈值的选择取决于给定输入图像的内容。 <br> 双阈值检测的伪代码描写如下： <br> <img src="https://images2.imgbox.com/e5/62/T8HbLrK6_o.png" alt="这里写图片描述" title=""></p> 
<p>(5)通过抑制孤立的弱边缘最终完成边缘检测。</p> 
<ul><li>到目前为止，被划分为强边缘的像素点已经被确定为边缘，因为它们是从图像中的真实边缘中提取出来的。然而，对于弱边缘像素，将会有一些争论，因为这些像素可以从真实边缘提取也可以是因噪声或颜色变化引起的。为了获得准确的结果，应该抑制由后者引起的弱边缘。通常，由真实边缘引起的弱边缘像素将连接到强边缘像素，而噪声响应未连接。为了跟踪边缘连接，通过查看弱边缘像素及其8个邻域像素，只要其中一个为强边缘像素，则该弱边缘点就可以保留为真实的边缘。抑制孤立边缘点的伪代码描述如下： <br> <img src="https://images2.imgbox.com/1d/4d/llf1K4v1_o.png" alt="这里写图片描述" title=""></li></ul> 
<h5 id="车牌位置的定位">车牌位置的定位</h5> 
<p>车牌细定位的目的是为下一步字符的分割做，就是要进一步去掉车牌冗余的部分。在一幅经过适当二值化处理 含有车牌的图像中，车牌区域具有以下三个基本特征：</p> 
<ul><li>列在一个不大的区域内密集包含有多个字符； </li><li>车牌字符与车牌底色形成强烈对比；</li><li>车牌区域大小相对固定，区域长度和宽度成固定比例。</li></ul> 
<p>根据以上特征，车牌区域所在行相邻像素之间0 到1和1到0 的的变化会很频繁，变化总数会大于一个临界值，这可以作为寻找车牌区域的一个依据。 因此根据跳变次数与设定的阈值比较，就可以确定出车牌的水平区域。</p> 
<p>由于车牌一般悬挂在车辆下部，所以采用从上到下，从左到右的方式对图像进行扫描。车牌的字符部分由7个字符数与两个竖直边框组成，则车牌区域内任一行的跳变次数至少为(7+2)*2=18次。从图像的底部开始向顶部进行扫描，则第一组连续数行且每行的跳变次数都大于跳变阈值，同时满足连续行数大于某个阈值。</p> 
<p>在车牌的水平区域中，最高行与最低行的差值即为车牌在图像中的高度。我国车牌区域为矩形，宽高比约为3.14，取3.14*H作为车牌的宽度。在水平区域内选择任意一行，用L长的窗口由左至右移动，统计窗口中相邻像素0,1的跳变次数并存入数组中。若窗口移动到车牌的垂直区域时，窗口内的跳变次数应该最大。因此在数组中找到最大值，其对应的区域即为车牌的垂直区域。</p> 
<p>车牌定位代码</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">int</span> CMyDialog::PlateAreaSearch(IplImage *pImg_Image)
{
    <span class="hljs-comment">// 检测是否有值</span>
    <span class="hljs-keyword">if</span> (pImg_Image==<span class="hljs-literal">NULL</span>)   
    { 
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   
    }

    IplImage* imgTest =<span class="hljs-number">0</span>; 
    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>,m=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">bool</span> flag=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> plate_n=<span class="hljs-number">0</span>;  <span class="hljs-comment">//上边界</span>
    <span class="hljs-keyword">int</span> plate_s=<span class="hljs-number">0</span>;  <span class="hljs-comment">//下边界</span>
    <span class="hljs-keyword">int</span> plate_e=<span class="hljs-number">0</span>;  <span class="hljs-comment">//右边界</span>
    <span class="hljs-keyword">int</span> plate_w=<span class="hljs-number">0</span>;  <span class="hljs-comment">//左边界</span>

    <span class="hljs-keyword">int</span> *num_h=new <span class="hljs-keyword">int</span>[MAX(pImg_Image-&gt;width,pImg_Image-&gt;height)];     
    <span class="hljs-keyword">if</span> ( num_h==<span class="hljs-literal">NULL</span> )  
    {
        MessageBox(<span class="hljs-string">"memory exhausted!"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   
    } 

    <span class="hljs-comment">//初始化分配的空间</span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;pImg_Image-&gt;width;i++)
    {
        num_h[i]=<span class="hljs-number">0</span>;
    }  

    imgTest = cvCreateImage(cvSize(pImg_Image-&gt;width,pImg_Image-&gt;height),IPL_DEPTH_8U,<span class="hljs-number">1</span>);
    cvCopy(pImg_Image, imgTest); 

    <span class="hljs-comment">//--水平轮廓细化</span>
    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;imgTest-&gt;height; j++)
    {
        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;imgTest-&gt;width-<span class="hljs-number">1</span>;i++)
       {
            CV_IMAGE_ELEM(imgTest,uchar,j,i)=CV_IMAGE_ELEM(imgTest,uchar,j,i+<span class="hljs-number">1</span>)-CV_IMAGE_ELEM(imgTest,uchar,j,i);
            <span class="hljs-comment">//记录每一行的像素值</span>
            num_h[j]+=CV_IMAGE_ELEM(imgTest,uchar,j,i)/<span class="hljs-number">250</span>;      
       }        
    } 

    <span class="hljs-keyword">int</span> temp_1 = <span class="hljs-number">0</span>;  <span class="hljs-comment">//统计20行中最大的每行数据量</span>
    <span class="hljs-keyword">int</span> temp_max = <span class="hljs-number">0</span>;  <span class="hljs-comment">//20行最大的数据量 </span>
    <span class="hljs-keyword">int</span> temp_i = <span class="hljs-number">0</span>;  <span class="hljs-comment">//最大数据量的行</span>

    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;imgTest-&gt;height-<span class="hljs-number">20</span>; j++)  
    {
      temp_1=<span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)  
        temp_1 +=  num_h[i+j];
      <span class="hljs-keyword">if</span>(temp_1&gt;=temp_max)
      {
          temp_max=temp_1;
          temp_i = j;
      }
    }

    <span class="hljs-comment">//找出上行边界行</span>
    k=temp_i;
    <span class="hljs-keyword">while</span> ( ((num_h[k +<span class="hljs-number">1</span>]&gt;POINT_X )||(num_h[k +<span class="hljs-number">2</span>]&gt;POINT_X )||(num_h[k]&gt;POINT_X )) &amp;&amp; k ) k--;
    plate_n=k+<span class="hljs-number">1</span>; 

    <span class="hljs-comment">//找出下边界行</span>
    k=temp_i+<span class="hljs-number">10</span>;
    <span class="hljs-keyword">while</span> (((num_h[k -<span class="hljs-number">1</span>]&gt;POINT_X )||(num_h[k-<span class="hljs-number">2</span>]&gt;POINT_X )||(num_h[k]&gt;POINT_X ))&amp;&amp;(k&lt;imgTest-&gt;height)) k++; 
    plate_s=k;

    <span class="hljs-comment">//没找到水平分割线，设置为默认值</span>
    <span class="hljs-keyword">if</span> ( !(plate_n &amp;&amp; plate_s
        &amp;&amp; (plate_n&lt;plate_s) &amp;&amp; ((plate_s-plate_n)*HIGH_WITH_CAR&lt;imgTest-&gt;width*(<span class="hljs-number">1</span>-WITH_X))))
    {
        MessageBox(<span class="hljs-string">"水平分割失败!"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-comment">//找到水平线 </span>
    <span class="hljs-keyword">else</span> 
    {
        <span class="hljs-keyword">int</span>  max_count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span>  plate_length = (imgTest-&gt;width-(plate_s-plate_n)*HIGH_WITH_CAR);
        plate_w=imgTest-&gt;width*WITH_X-<span class="hljs-number">1</span>;<span class="hljs-comment">//车牌宽度 默认</span>

        <span class="hljs-comment">//--垂直方向 轮廓细化</span>
        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;imgTest-&gt;width;i++)
            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;imgTest-&gt;height-<span class="hljs-number">1</span>;j++) 
           {
                CV_IMAGE_ELEM(imgTest,uchar,j,i)=CV_IMAGE_ELEM(imgTest,uchar,j+<span class="hljs-number">1</span>,i)-CV_IMAGE_ELEM(imgTest,uchar,j,i);
           }

        <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;plate_length;k++)
        { 
            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;(<span class="hljs-keyword">int</span>)((plate_s-plate_n)*HIGH_WITH_CAR); i++)
                <span class="hljs-keyword">for</span> (j=plate_n;j&lt;plate_s;j++)<span class="hljs-comment">//两水平线之间 </span>
                {
                    num_h[k] =num_h[k]+ CV_IMAGE_ELEM(imgTest,uchar,j,(i+k))/<span class="hljs-number">250</span>;
                }
            <span class="hljs-keyword">if</span> (num_h[k]&gt;max_count)
            {
                max_count = num_h[k];
                plate_w = k;
            }

        }


        CvRect ROI_rect;                 <span class="hljs-comment">//获得图片感兴趣区域</span>
        ROI_rect<span class="hljs-variable">.x</span>=plate_w;
        ROI_rect<span class="hljs-variable">.y</span>=plate_n;
        ROI_rect<span class="hljs-variable">.width</span>=(plate_s-plate_n)*HIGH_WITH_CAR;
        ROI_rect<span class="hljs-variable">.height</span>=plate_s-plate_n;

        <span class="hljs-keyword">if</span> ((ROI_rect<span class="hljs-variable">.width</span>+ROI_rect<span class="hljs-variable">.x</span>)&gt; pImg_Image-&gt;width)
        {
            ROI_rect<span class="hljs-variable">.width</span>=pImg_Image-&gt;width-ROI_rect<span class="hljs-variable">.x</span>;   
            MessageBox(<span class="hljs-string">"垂直方向分割失败!"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">else</span>
        {
            IplImage *pImg8uROI=<span class="hljs-literal">NULL</span>;         <span class="hljs-comment">//感兴趣的图片  </span>
            pImg8uROI=cvCreateImage(cvSize(ROI_rect<span class="hljs-variable">.width</span>,ROI_rect<span class="hljs-variable">.height</span>), src-&gt;depth,src-&gt;nChannels);

            IplImage *pImg8u11=<span class="hljs-literal">NULL</span>;        <span class="hljs-comment">//车牌区域灰度图</span>
            pImg8u11=cvCreateImage(cvSize(<span class="hljs-number">40</span>*HIGH_WITH_CAR,<span class="hljs-number">40</span>),pImg8uROI-&gt;depth,pImg8uROI-&gt;nChannels);

            cvSetImageROI(src,ROI_rect);
            cvCopy(src,pImg8uROI,<span class="hljs-literal">NULL</span>);
            cvResetImageROI(src);

            pImgResize=cvCreateImage(cvSize(<span class="hljs-number">40</span>*HIGH_WITH_CAR,<span class="hljs-number">40</span>),IPL_DEPTH_8U,<span class="hljs-number">1</span>);   
            cvResize(pImg8uROI,pImg8u11,CV_INTER_LINEAR); <span class="hljs-comment">//线性插值</span>

            cvCvtColor(pImg8u11,pImgResize,CV_RGB2GRAY);
            Threshold(pImgResize,pImgResize);

            cvReleaseImage(&amp;pImg8uROI);
            cvReleaseImage(&amp;pImg8u11);
            cvReleaseImage(&amp;imgTest);
        } 
    } 

    <span class="hljs-comment">// 释放内存</span>
    delete []num_h;  
    num_h=<span class="hljs-literal">NULL</span>;  
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
<h5 id="车牌字符的识别">车牌字符的识别</h5> 
<p>车牌字符识别是字符识别的重要组成部分。车牌字符识别的最终目的就是将图像中的车牌字符转化成文本字符，车牌字符的识别属于印刷体识别范畴。</p> 
<p>字符识别的基本思想是匹配判别。抽取待识别字符特征按照字符识别的原理和预先存储在计算机中的标准字符模式表达形式的集合逐一进行匹配，找出最接近输入字符模式的表达形式，该表达形式对应的字就是识别结果。字符识别的原理如下： <br> <img src="https://images2.imgbox.com/e7/24/aDxVg9n7_o.png" alt="这里写图片描述" title=""> <br> 根据我国的车牌牌照标准，车牌第一位字符一般为汉字，车牌第二位英文大写字母，第三位至第七位为英文大写字母或数字。考虑到神经网络对小类别字符集有较高的识别率，因此在车牌字符识别系统中，分别设计三个神经网络：汉字网络、字母网络、字母数字网络 实现对字符的分类识别。 <br> <img src="https://images2.imgbox.com/fa/1a/EMO7RyqK_o.png" alt="这里写图片描述" title=""> <br> 以字母0为例，提取字符特征的步骤为：将分割好的图片再分割成8*4的特征向量，形成一个32维的向量。最终字符特征提取的结果如下： <br> <img src="https://images2.imgbox.com/56/49/xwKf1aX5_o.png" alt="这里写图片描述" title=""> <br> 最终效果： <br> <img src="https://images2.imgbox.com/d9/78/jpRomZcs_o.png" alt="这里写图片描述" title=""> <br> 字符切割代码</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">int</span> CMyDialog::SegmentPlate()
{
    <span class="hljs-comment">// 没有切割成功，直接弹出</span>
    <span class="hljs-keyword">if</span> (pImgResize==<span class="hljs-literal">NULL</span>)  
    { 
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; 
    } 

    <span class="hljs-keyword">int</span> *num_h=new <span class="hljs-keyword">int</span>[MAX(pImgResize-&gt;width,pImgResize-&gt;height)];
    <span class="hljs-keyword">if</span> ( num_h==<span class="hljs-literal">NULL</span> ) 
    {   
        MessageBox(<span class="hljs-string">"字符分割memory exhausted"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   
    }

    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;<span class="hljs-comment">//循环变量 12</span>
    <span class="hljs-keyword">int</span>  letter[<span class="hljs-number">14</span>]={<!-- --><span class="hljs-number">0</span>,<span class="hljs-number">20</span>,<span class="hljs-number">23</span>,<span class="hljs-number">43</span>,<span class="hljs-number">55</span>,<span class="hljs-number">75</span>,<span class="hljs-number">78</span>,<span class="hljs-number">98</span>,<span class="hljs-number">101</span>,<span class="hljs-number">121</span>,<span class="hljs-number">124</span>,<span class="hljs-number">127</span>,<span class="hljs-number">147</span>,<span class="hljs-number">167</span>}; <span class="hljs-comment">// 默认分割</span>
    <span class="hljs-keyword">bool</span> flag1=<span class="hljs-number">0</span>;  

    <span class="hljs-comment">// 垂直投影</span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>*HIGH_WITH_CAR;i++)
    {   
         num_h[i]=<span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化指针</span>
         <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">17</span>;j++)  <span class="hljs-comment">// 0-16</span>
         {
             num_h[i]+=CV_IMAGE_ELEM(pImgResize,uchar,j,i)/<span class="hljs-number">45</span>;
         }  
         <span class="hljs-keyword">for</span>(j=<span class="hljs-number">24</span>;j&lt;<span class="hljs-number">40</span>;j++)  <span class="hljs-comment">// 24-39</span>
         {
             num_h[i]+=CV_IMAGE_ELEM(pImgResize,uchar,j,i)/<span class="hljs-number">45</span>;
         }
    }
    <span class="hljs-comment">// 初定位，定位点 第二个字符末端，</span>
    <span class="hljs-keyword">int</span> max_count=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>; 
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">30</span>;i&lt;<span class="hljs-number">40</span>*HIGH_WITH_CAR;i++)
    {
        <span class="hljs-keyword">if</span>(num_h[i]&lt;POINT_Y)
        {
            max_count++;
            <span class="hljs-keyword">if</span>(max_count==<span class="hljs-number">11</span>)
            {
                letter[<span class="hljs-number">3</span>]=i-<span class="hljs-number">11</span>;<span class="hljs-comment">//第二字符的结束位置</span>
                <span class="hljs-keyword">while</span>( (num_h[i]&lt;POINT_Y)||(num_h[i-<span class="hljs-number">1</span>]&lt;POINT_Y) ) i++;
                letter[<span class="hljs-number">4</span>]=i-<span class="hljs-number">1</span>;<span class="hljs-comment">//第三个字符的开始位置</span>
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">else</span>
        {
            max_count=<span class="hljs-number">0</span>;
        }
    }

    <span class="hljs-comment">// 精定位</span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>*HIGH_WITH_CAR;i++)
    {
        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">17</span>;j&lt;=<span class="hljs-number">24</span>;j++)
        {
            num_h[i]+=CV_IMAGE_ELEM(pImgResize,uchar,j,i)/<span class="hljs-number">45</span>;
        }
    }

    <span class="hljs-keyword">for</span>(j=letter[<span class="hljs-number">3</span>];j&gt;<span class="hljs-number">0</span>;j--)<span class="hljs-comment">//找第一个和第二个字符起始位置</span>
    {
        <span class="hljs-keyword">if</span>((num_h[j]&lt;POINT_Y)&amp;&amp;(num_h[j-<span class="hljs-number">1</span>]&lt;POINT_Y))
        {
            letter[<span class="hljs-number">2</span>]=j;                       <span class="hljs-comment">//第二个字符的开始位置</span>
            letter[<span class="hljs-number">1</span>]=(j&gt;=<span class="hljs-number">23</span>)?j-<span class="hljs-number">3</span>:letter[<span class="hljs-number">1</span>];   <span class="hljs-comment">//第一个字符的结束位置</span>
            letter[<span class="hljs-number">0</span>]=(j&gt;=<span class="hljs-number">23</span>)?j-<span class="hljs-number">23</span>:letter[<span class="hljs-number">0</span>];  <span class="hljs-comment">//第一个字符的起始位置</span>
            <span class="hljs-keyword">break</span>;
        }
    }

    j=<span class="hljs-number">2</span>;  flag=<span class="hljs-number">0</span>;flag1=<span class="hljs-number">0</span>;<span class="hljs-comment">//两个标记</span>
    <span class="hljs-keyword">for</span>(i=letter[<span class="hljs-number">4</span>];i&lt;<span class="hljs-number">40</span>*HIGH_WITH_CAR;i++)  <span class="hljs-comment">//从第三个字符的开始位置算起</span>
    {
        <span class="hljs-keyword">if</span>((num_h[i]&gt;POINT_Y)&amp;&amp;(num_h[i-<span class="hljs-number">1</span>]&gt;POINT_Y) &amp;&amp; !flag )
        {
            flag=<span class="hljs-number">1</span>;
            flag1=<span class="hljs-number">0</span>;
            letter[<span class="hljs-number">2</span>*j]=i-<span class="hljs-number">1</span>; <span class="hljs-comment">//这里 只记录字符的开始位置</span>
            <span class="hljs-keyword">if</span>(j==<span class="hljs-number">6</span>)  <span class="hljs-comment">//判断 最后一个字符的结束位置 是否越界 超出界限,如果没有,则letter[13]=letter[12]+20</span>
            {
                letter[<span class="hljs-number">2</span>*j+<span class="hljs-number">1</span>]=((letter[<span class="hljs-number">2</span>*j]+<span class="hljs-number">20</span>)&gt;<span class="hljs-number">40</span>*HIGH_WITH_CAR-<span class="hljs-number">1</span>)?<span class="hljs-number">40</span>*HIGH_WITH_CAR-<span class="hljs-number">1</span>:letter[<span class="hljs-number">2</span>*j]+<span class="hljs-number">20</span>;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((num_h[i]&lt;POINT_Y)&amp;&amp;(num_h[i-<span class="hljs-number">1</span>]&lt;POINT_Y) &amp;&amp; !flag1 &amp;&amp; flag)<span class="hljs-comment">//如果是 空白区域  </span>
        {
            flag=<span class="hljs-number">0</span>;
            flag1=<span class="hljs-number">1</span>;
            letter[<span class="hljs-number">2</span>*j+<span class="hljs-number">1</span>]=i-<span class="hljs-number">1</span>;
            j++;
        }  
    }   
    <span class="hljs-comment">// 删除角点  </span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>*HIGH_WITH_CAR-<span class="hljs-number">1</span>;i++)
    {
        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">39</span>;j++)
        {
            <span class="hljs-keyword">if</span>(CV_IMAGE_ELEM(pImgResize,uchar,j,i)&amp;&amp;CV_IMAGE_ELEM(pImgResize,uchar,j,i+<span class="hljs-number">1</span>)&amp;&amp;CV_IMAGE_ELEM(pImgResize,uchar,j+<span class="hljs-number">1</span>,i)) <span class="hljs-comment">//  01</span>
                CV_IMAGE_ELEM(pImgResize,uchar,j,i)=<span class="hljs-number">0</span>;                                                                                                                                                                                                                             <span class="hljs-comment">//   1</span>

            <span class="hljs-keyword">if</span>(CV_IMAGE_ELEM(pImgResize,uchar,j,i)&amp;&amp;  CV_IMAGE_ELEM(pImgResize,uchar,j,i-<span class="hljs-number">1</span>) &amp;&amp;CV_IMAGE_ELEM(pImgResize,uchar,j+<span class="hljs-number">1</span>,i))     <span class="hljs-comment">//  10</span>
                CV_IMAGE_ELEM(pImgResize,uchar,j,i)=<span class="hljs-number">0</span>;                                                                                                                                                                                                                               <span class="hljs-comment">//    1                    </span>

            <span class="hljs-keyword">if</span>(CV_IMAGE_ELEM(pImgResize,uchar,j,i)&amp;&amp;CV_IMAGE_ELEM(pImgResize,uchar,j,i-<span class="hljs-number">1</span>) &amp;&amp;CV_IMAGE_ELEM(pImgResize,uchar,j-<span class="hljs-number">1</span>,i))         <span class="hljs-comment">//   1      </span>
                CV_IMAGE_ELEM(pImgResize,uchar,j,i)=<span class="hljs-number">0</span>;                                                                                    <span class="hljs-comment">// 10</span>

            <span class="hljs-keyword">if</span>(CV_IMAGE_ELEM(pImgResize,uchar,j,i)&amp;&amp;CV_IMAGE_ELEM(pImgResize,uchar,j,i+<span class="hljs-number">1</span>) &amp;&amp;CV_IMAGE_ELEM(pImgResize,uchar,j-<span class="hljs-number">1</span>,i))           <span class="hljs-comment">// 1      </span>
                CV_IMAGE_ELEM(pImgResize,uchar,j,i)=<span class="hljs-number">0</span>;                                                                                 <span class="hljs-comment">// 01</span>
        }
    }   


    <span class="hljs-comment">// 分割出字符图片</span>
    pImgCharOne=cvCreateImage(cvSize(<span class="hljs-number">20</span>,<span class="hljs-number">40</span>),IPL_DEPTH_8U,<span class="hljs-number">1</span>);
    pImgCharTwo=cvCreateImage(cvSize(<span class="hljs-number">20</span>,<span class="hljs-number">40</span>),IPL_DEPTH_8U,<span class="hljs-number">1</span>);
    pImgCharThree=cvCreateImage(cvSize(<span class="hljs-number">20</span>,<span class="hljs-number">40</span>),IPL_DEPTH_8U,<span class="hljs-number">1</span>);
    pImgCharFour=cvCreateImage(cvSize(<span class="hljs-number">20</span>,<span class="hljs-number">40</span>),IPL_DEPTH_8U,<span class="hljs-number">1</span>);
    pImgCharFive=cvCreateImage(cvSize(<span class="hljs-number">20</span>,<span class="hljs-number">40</span>),IPL_DEPTH_8U,<span class="hljs-number">1</span>);
    pImgCharSix=cvCreateImage(cvSize(<span class="hljs-number">20</span>,<span class="hljs-number">40</span>),IPL_DEPTH_8U,<span class="hljs-number">1</span>);
    pImgCharSeven=cvCreateImage(cvSize(<span class="hljs-number">20</span>,<span class="hljs-number">40</span>),IPL_DEPTH_8U,<span class="hljs-number">1</span>);

            CvRect ROI_rect1;
            ROI_rect1<span class="hljs-variable">.x</span>=<span class="hljs-number">0.5</span>*(letter[<span class="hljs-number">1</span>]+letter[<span class="hljs-number">0</span>])-<span class="hljs-number">10</span>;
            ROI_rect1<span class="hljs-variable">.y</span>=<span class="hljs-number">0</span>;
            ROI_rect1<span class="hljs-variable">.width</span>=<span class="hljs-number">20</span>;
            ROI_rect1<span class="hljs-variable">.height</span>=<span class="hljs-number">40</span>;
            cvSetImageROI(pImgResize,ROI_rect1);
            cvCopy(pImgResize,pImgCharOne,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//获取第1个字符</span>
            cvResetImageROI(pImgResize);

            ROI_rect1<span class="hljs-variable">.x</span>=<span class="hljs-number">0.5</span>*(letter[<span class="hljs-number">3</span>]+letter[<span class="hljs-number">2</span>])-<span class="hljs-number">10</span>;
            ROI_rect1<span class="hljs-variable">.y</span>=<span class="hljs-number">0</span>;
            ROI_rect1<span class="hljs-variable">.width</span>=<span class="hljs-number">20</span>;
            ROI_rect1<span class="hljs-variable">.height</span>=<span class="hljs-number">40</span>;
            cvSetImageROI(pImgResize,ROI_rect1);
            cvCopy(pImgResize,pImgCharTwo,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//获取第2个字符</span>
            cvResetImageROI(pImgResize);

            ROI_rect1<span class="hljs-variable">.x</span>=<span class="hljs-number">0.5</span>*(letter[<span class="hljs-number">5</span>]+letter[<span class="hljs-number">4</span>])-<span class="hljs-number">10</span>;
            ROI_rect1<span class="hljs-variable">.y</span>=<span class="hljs-number">0</span>;
            ROI_rect1<span class="hljs-variable">.width</span>=<span class="hljs-number">20</span>;
            ROI_rect1<span class="hljs-variable">.height</span>=<span class="hljs-number">40</span>;
            cvSetImageROI(pImgResize,ROI_rect1);
            cvCopy(pImgResize,pImgCharThree,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//获取第3个字符</span>
            cvResetImageROI(pImgResize);

            ROI_rect1<span class="hljs-variable">.x</span>=<span class="hljs-number">0.5</span>*(letter[<span class="hljs-number">7</span>]+letter[<span class="hljs-number">6</span>])-<span class="hljs-number">10</span>;
            ROI_rect1<span class="hljs-variable">.y</span>=<span class="hljs-number">0</span>;
            ROI_rect1<span class="hljs-variable">.width</span>=<span class="hljs-number">20</span>;
            ROI_rect1<span class="hljs-variable">.height</span>=<span class="hljs-number">40</span>;
            cvSetImageROI(pImgResize,ROI_rect1);
            cvCopy(pImgResize,pImgCharFour,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//获取第4个字符</span>
            cvResetImageROI(pImgResize);

            ROI_rect1<span class="hljs-variable">.x</span>=<span class="hljs-number">0.5</span>*(letter[<span class="hljs-number">9</span>]+letter[<span class="hljs-number">8</span>])-<span class="hljs-number">10</span>;
            ROI_rect1<span class="hljs-variable">.y</span>=<span class="hljs-number">0</span>;
            ROI_rect1<span class="hljs-variable">.width</span>=<span class="hljs-number">20</span>;
            ROI_rect1<span class="hljs-variable">.height</span>=<span class="hljs-number">40</span>;
            cvSetImageROI(pImgResize,ROI_rect1);
            cvCopy(pImgResize,pImgCharFive,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//获取第5个字符</span>
            cvResetImageROI(pImgResize);

            ROI_rect1<span class="hljs-variable">.x</span>=<span class="hljs-number">0.5</span>*(letter[<span class="hljs-number">11</span>]+letter[<span class="hljs-number">10</span>])-<span class="hljs-number">10</span>;
            ROI_rect1<span class="hljs-variable">.y</span>=<span class="hljs-number">0</span>;
            ROI_rect1<span class="hljs-variable">.width</span>=<span class="hljs-number">20</span>;
            ROI_rect1<span class="hljs-variable">.height</span>=<span class="hljs-number">40</span>;
            cvSetImageROI(pImgResize,ROI_rect1);
            cvCopy(pImgResize,pImgCharSix,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//获取第6个字符</span>
            cvResetImageROI(pImgResize);

            ROI_rect1<span class="hljs-variable">.x</span>=<span class="hljs-number">0.5</span>*(letter[<span class="hljs-number">13</span>]+letter[<span class="hljs-number">12</span>])-<span class="hljs-number">10</span>;
            ROI_rect1<span class="hljs-variable">.y</span>=<span class="hljs-number">0</span>;
            ROI_rect1<span class="hljs-variable">.width</span>=<span class="hljs-number">20</span>;
            ROI_rect1<span class="hljs-variable">.height</span>=<span class="hljs-number">40</span>;
            cvSetImageROI(pImgResize,ROI_rect1);
            cvCopy(pImgResize,pImgCharSeven,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//获取第7个字符</span>
            cvResetImageROI(pImgResize);



            <span class="hljs-comment">// 释放内存</span>
            delete []num_h;  
            num_h=<span class="hljs-literal">NULL</span>;

}</code></pre> 
<p>字符识别代码</p> 
<pre class="prettyprint"><code class=" hljs mel"><span class="hljs-keyword">int</span> CMyDialog::CodeRecognize(IplImage <span class="hljs-variable">*imgTest</span>, <span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> char_num)
{
    <span class="hljs-keyword">if</span> (imgTest==NULL)
    { 
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span>  char_start=<span class="hljs-number">0</span>,char_end=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> num_t[CHARACTER ]={<!-- --><span class="hljs-number">0</span>};


     <span class="hljs-keyword">switch</span>(num)<span class="hljs-comment">//这里这样分 可以提高效率，并且提高了识别率</span>
     {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:  char_start =<span class="hljs-number">0</span>;         <span class="hljs-comment">// 数字</span>
                         char_end  = <span class="hljs-number">9</span>;
                          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:  char_start =<span class="hljs-number">10</span>;        <span class="hljs-comment">// 英文</span>
                         char_end  = <span class="hljs-number">35</span>;
                          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:  char_start =<span class="hljs-number">0</span>;       <span class="hljs-comment">// 英文和数字</span>
                         char_end  = <span class="hljs-number">35</span>;
                          <span class="hljs-keyword">break</span>;  
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:  char_start =<span class="hljs-number">36</span>;       <span class="hljs-comment">// 中文</span>
                         char_end  = TEMPLETENUM-<span class="hljs-number">1</span>;
                          <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>;                 
     }

    <span class="hljs-comment">// 提取前8个特征</span>
    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>; k&lt;<span class="hljs-number">8</span>; k++)
    { 
        <span class="hljs-keyword">for</span>(j=<span class="hljs-keyword">int</span>(k/<span class="hljs-number">2</span>)<span class="hljs-variable">*10</span>; j&lt;<span class="hljs-keyword">int</span>(k/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)<span class="hljs-variable">*10</span>; j++)
        {
            <span class="hljs-keyword">for</span>(i=(k<span class="hljs-variable">%2</span>)<span class="hljs-variable">*10</span>;i&lt;(k<span class="hljs-variable">%2</span>+<span class="hljs-number">1</span>)<span class="hljs-variable">*10</span>;i++)
            {       
               num_t[k]+=CV_IMAGE_ELEM(imgTest,uchar,j,i)/<span class="hljs-number">255</span> ;
            }       
        }

        <span class="hljs-comment">// 第9个特征 前8个特征的和作为第9个特征值</span>
        num_t[<span class="hljs-number">8</span>]+= num_t[k];  
    }

    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)   
        num_t[<span class="hljs-number">9</span>]+=CV_IMAGE_ELEM(imgTest,uchar,<span class="hljs-number">10</span>,i)/<span class="hljs-number">255</span> ;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)
        num_t[<span class="hljs-number">10</span>]+=CV_IMAGE_ELEM(imgTest,uchar,<span class="hljs-number">20</span>,i)/<span class="hljs-number">255</span> ;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)
        num_t[<span class="hljs-number">11</span>]+=CV_IMAGE_ELEM(imgTest,uchar,<span class="hljs-number">30</span>,i)/<span class="hljs-number">255</span> ;

    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">40</span>;j++)
        num_t[<span class="hljs-number">12</span>]+=CV_IMAGE_ELEM(imgTest,uchar,j,<span class="hljs-number">7</span>)/<span class="hljs-number">255</span>;
    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">40</span>;j++)
        num_t[<span class="hljs-number">13</span>]+=CV_IMAGE_ELEM(imgTest,uchar,j,<span class="hljs-number">10</span>)/<span class="hljs-number">255</span> ;
    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">40</span>;j++)
        num_t[<span class="hljs-number">14</span>]+=CV_IMAGE_ELEM(imgTest,uchar,j,<span class="hljs-number">13</span>)/<span class="hljs-number">255</span> ;

    <span class="hljs-keyword">int</span> num_tt[CHARACTER]={<!-- --><span class="hljs-number">0</span>};
    <span class="hljs-keyword">int</span> matchnum=<span class="hljs-number">0</span>;  <span class="hljs-comment">//可以说是 匹配度或 相似度</span>
    <span class="hljs-keyword">int</span> matchnum_max=<span class="hljs-number">0</span>;  
    <span class="hljs-keyword">int</span> matchcode = <span class="hljs-number">0</span>;         <span class="hljs-comment">// 匹配号</span>

    j=<span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span>(k=char_start;k&lt;=char_end;k++)
    {
        matchnum=<span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++) <span class="hljs-comment">//区域的匹配</span>
        {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">abs</span>(num_t[i]-Num_Templete[k][i])&lt;=<span class="hljs-number">2</span>)<span class="hljs-comment">//与模板里的相应值进行匹配</span>
                matchnum++;
        }

       <span class="hljs-keyword">if</span>(Num_Templete[k][i]-<span class="hljs-keyword">abs</span>(num_t[i])&lt;=<span class="hljs-number">8</span>)<span class="hljs-comment">//对第9个特征进行匹配 </span>
             matchnum+=<span class="hljs-number">2</span>;   
       <span class="hljs-keyword">for</span>(i=<span class="hljs-number">9</span>;i&lt;CHARACTER;i++)  <span class="hljs-comment">// 横竖的匹配  </span>
        {
           <span class="hljs-keyword">if</span> (Num_Templete[k][i]&gt;=<span class="hljs-number">5</span>)  <span class="hljs-comment">//特征值 大于5 </span>
           {
                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">abs</span>(num_t[i]-Num_Templete[k][i])&lt;=<span class="hljs-number">1</span>)
                matchnum+=<span class="hljs-number">2</span>;
           }
           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( num_t[i]==Num_Templete[k][i])
           { 
                matchnum+=<span class="hljs-number">2</span>;
           }
        }
        <span class="hljs-keyword">if</span>(matchnum&gt;matchnum_max)
        {
              matchnum_max=matchnum;  <span class="hljs-comment">//保留最大的 匹配 </span>
              matchcode= k;  <span class="hljs-comment">//记录 识别的字符的 索引 </span>
        }   
    }
    <span class="hljs-comment">//识别输出  存放输出结果</span>
    G_PlateChar[char_num]=PlateCode[matchcode]; <span class="hljs-comment">//保存下该字符</span>
}</code></pre> 
<p>参考： <br> <a href="https://blog.csdn.net/xundh/article/details/75453695">https://blog.csdn.net/xundh/article/details/75453695</a> <br> <a href="https://blog.csdn.net/qq_25343557/article/details/78703065">https://blog.csdn.net/qq_25343557/article/details/78703065</a> <br> <a href="https://www.cnblogs.com/techyan1990/p/7291771.html" rel="nofollow">https://www.cnblogs.com/techyan1990/p/7291771.html</a> <br> <a href="https://www.cnblogs.com/techyan1990/p/7291771.html" rel="nofollow">https://www.cnblogs.com/techyan1990/p/7291771.html</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a7c9ed82a53b678dde965e9ff56161d7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">debug caffe python layer</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/65e16c1bf470f608f266889e2aa05674/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">1.2 Fundamentals—offline（Arcgis runtime for java）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>