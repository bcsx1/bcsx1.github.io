<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>内核中断笔记(MSIx和GSI)。 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="内核中断笔记(MSIx和GSI)。" />
<meta property="og:description" content="struct device { struct irq_domain	*msi_domain; // 设备关联的是在----&gt;irq-gic-v3-its-pci-msi.c中创建， } struct irq_domain { void *host_data; struct irq_domain_ops *ops; } irq_domain的创建最终通过： __irq_domain_add函数： struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size, irq_hw_number_t hwirq_max, int direct_max, const struct irq_domain_ops *ops, //提供ops void *host_data) //额外的host_data。有不同的意义。 层次结构：具体是irq_domain_alloc_irq_data函数建立：
系统创建的irq_domain：总共4个。通过parent成员组成 层次结构。根为ffff8020c0030400。
[ 0.000000] ===__irq_domain_add domain ffff8020c0030400 name irqchip@(____ptrval____) === irq-gic-v3.c
[ 0.000000] ===__irq_domain_add domain ffff8020c0030500 name irqchip@(____ptrval____) === irq-gic-v3-its.c
[ 0.002937] ===__irq_domain_add domain ffff8020c0032100 name irqchip@(____ptrval____) === irq-gic-v3-its-pci-msi" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/4ad408ad9dffff8e71d6e6c5acfb0186/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-11T16:26:38+08:00" />
<meta property="article:modified_time" content="2023-10-11T16:26:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">内核中断笔记(MSIx和GSI)。</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre><code>struct device 
{
	struct irq_domain	*msi_domain; // 设备关联的是在----&gt;irq-gic-v3-its-pci-msi.c中创建，
}

struct irq_domain
{
	void *host_data;
	struct irq_domain_ops *ops;
}


irq_domain的创建最终通过：
 __irq_domain_add函数：
struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,
				    irq_hw_number_t hwirq_max, int direct_max,
				    const struct irq_domain_ops *ops,  //提供ops
				    void *host_data)   //额外的host_data。有不同的意义。</code></pre> 
<p>层次结构：具体是irq_domain_alloc_irq_data函数建立：</p> 
<p></p> 
<p><img alt="" height="1041" src="https://images2.imgbox.com/ea/5f/20vkDIe0_o.png" width="1200"></p> 
<p></p> 
<p>系统创建的irq_domain：总共4个。通过parent成员组成 层次结构。根为ffff8020c0030400。</p> 
<blockquote> 
 <p>[    0.000000] ===__irq_domain_add domain ffff8020c0030400 name irqchip@(____ptrval____) ===    irq-gic-v3.c<br> [    0.000000] ===__irq_domain_add domain ffff8020c0030500 name irqchip@(____ptrval____) ===    irq-gic-v3-its.c<br> [    0.002937] ===__irq_domain_add domain ffff8020c0032100 name irqchip@(____ptrval____) ===    irq-gic-v3-its-pci-msi</p> 
</blockquote> 
<p>具体创建过程：</p> 
<p>第一个：boot核init_IRQ 函数最终调用到irq_gic_v3.c中</p> 
<blockquote> 
 <p>host_data: 是struct gic_chip_data gic_data</p> 
 <p>irq_domain_ops:gic_irq_domain_ops</p> 
 <p>参考：irq_gic_v3.c ：gic_init_bases函数</p> 
</blockquote> 
<pre><code>[    0.000000] ===__irq_domain_add domain ffff8020c0030400 name irqchip@(____ptrr
val____) ===
[    0.000000] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.19.0 #100
[    0.000000] Call trace:
[    0.000000]  dump_backtrace+0x0/0x180
[    0.000000]  show_stack+0x24/0x30
[    0.000000]  dump_stack+0x90/0xb4
[    0.000000]  __irq_domain_add+0x1e4/0x398
[    0.000000]  gic_init_bases+0xd4/0x2dc
[    0.000000]  gic_acpi_init+0x158/0x270
[    0.000000]  acpi_match_madt+0x4c/0x84
[    0.000000]  acpi_table_parse_entries_array+0x140/0x218
[    0.000000]  acpi_table_parse_entries+0x70/0x98
[    0.000000]  acpi_table_parse_madt+0x40/0x50
[    0.000000]  __acpi_probe_device_table+0x88/0xe0
[    0.000000]  irqchip_init+0x38/0x40
[    0.000000]  init_IRQ+0xfc/0x130
[    0.000000]  start_kernel+0x330/0x4b8

  

irq_domain_update_bus_token(gic_data.domain, DOMAIN_BUS_WIRED);</code></pre> 
<p></p> 
<p>第二个 irq_gic_v3调用了irq_gic_v3_its中的函数创建，作为parent传递。</p> 
<blockquote> 
 <p>host_data是msi_domain_info（ops:its_msi_domain_ops）</p> 
 <p>irq_domain_ops是its_domain_ops .</p> 
 <p>参考：its_probe_one-&gt;its_init_domain函数</p> 
</blockquote> 
<pre><code>[    0.000000] ===__irq_domain_add domain ffff8020c0030500 name irqchip@(____ptrr
val____) ===
[    0.000000] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.19.0 #100
[    0.000000] Call trace:
[    0.000000]  dump_backtrace+0x0/0x180
[    0.000000]  show_stack+0x24/0x30
[    0.000000]  dump_stack+0x90/0xb4
[    0.000000]  __irq_domain_add+0x1e4/0x398
[    0.000000]  its_probe_one+0x8cc/0x9bc
[    0.000000]  gic_acpi_parse_madt_its+0x104/0x144
[    0.000000]  acpi_table_parse_entries_array+0x140/0x218
[    0.000000]  acpi_table_parse_entries+0x70/0x98
[    0.000000]  acpi_table_parse_madt+0x40/0x50
[    0.000000]  its_init+0x1bc/0x490
[    0.000000]  gic_init_bases+0x1d4/0x2dc
[    0.000000]  gic_acpi_init+0x158/0x270
[    0.000000]  acpi_match_madt+0x4c/0x84
[    0.000000]  acpi_table_parse_entries_array+0x140/0x218
[    0.000000]  acpi_table_parse_entries+0x70/0x98
[    0.000000]  acpi_table_parse_madt+0x40/0x50
[    0.000000]  __acpi_probe_device_table+0x88/0xe0
[    0.000000]  irqchip_init+0x38/0x40



irq_domain_update_bus_token(inner_domain, DOMAIN_BUS_NEXUS);</code></pre> 
<p></p> 
<p>第三个 最后的do_one_initcall 调用its_pci_msi_init中函数创建，在msi_create_irq_domain函数下创建。</p> 
<blockquote> 
 <p>host_data:  msi_domain_info （ ops:its_pci_msi_ops）</p> 
 <p>irq_domain_ops是 kernel/irq/msi.c提供的msi_domain_ops。</p> 
 <p>        irq_domain_ops在kernel/irq/msi.c和drivers/pci/msi.c也有，在不同的每个地方都提供了部分回调。</p> 
 <p>参考：its_pci_msi_init_one-&gt;pci_msi_create_irq_domain-&gt;msi_create_irq_domain .....</p> 
</blockquote> 
<pre><code>[    0.002937] ===__irq_domain_add domain ffff8020c0032100 name irqchip@(____ptrr
val____) ===
[    0.002939] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.19.0 #100
[    0.002941] Call trace:
[    0.002944]  dump_backtrace+0x0/0x180
[    0.002946]  show_stack+0x24/0x30
[    0.002948]  dump_stack+0x90/0xb4
[    0.002950]  __irq_domain_add+0x1e4/0x398
[    0.002953]  irq_domain_create_hierarchy+0x88/0x90
[    0.002955]  msi_create_irq_domain+0x50/0x160
[    0.002959]  pci_msi_create_irq_domain+0x80/0x160
[    0.002961]  its_pci_msi_init_one+0x94/0xd8
[    0.002963]  its_pci_msi_parse_madt+0x60/0x90
[    0.002965]  acpi_table_parse_entries_array+0x140/0x218
[    0.002967]  acpi_table_parse_entries+0x70/0x98
[    0.002969]  acpi_table_parse_madt+0x40/0x50
[    0.002971]  its_pci_msi_init+0xb8/0xcc
[    0.002973]  do_one_initcall+0x54/0x1d8
[    0.002976]  kernel_init_freeable+0x160/0x328
[    0.002978]  kernel_init+0x18/0x110
[    0.002980]  ret_from_fork+0x10/0x18



irq_domain_update_bus_token(domain, DOMAIN_BUS_PCI_MSI);</code></pre> 
<pre><code class="language-cpp">int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
                            unsigned int nr_irqs, int node, void *arg,
                            bool realloc, const struct cpumask *affinity)
{
        int i, ret, virq;

        if (domain == NULL) {
                domain = irq_default_domain;
                if (WARN(!domain, "domain is NULL; cannot allocate IRQ\n"))
                        return -EINVAL;
        }

        if (!domain-&gt;ops-&gt;alloc) {
                pr_debug("domain-&gt;ops-&gt;alloc() is NULL\n");
                return -ENOSYS;
        }

        if (realloc &amp;&amp; irq_base &gt;= 0) {
                virq = irq_base;
        } else {
                virq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node,
                                              affinity); //创建irq_desc
                if (virq &lt; 0) {
                        pr_debug("cannot allocate IRQ(base %d, count %d)\n",
                                 irq_base, nr_irqs);
                        return virq;
                }
        }

        if (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {  //irq_data 也会创建层次，更加parent。
                pr_debug("cannot allocate memory for IRQ%d\n", virq);
                ret = -ENOMEM;
                goto out_free_desc;
        }

        mutex_lock(&amp;irq_domain_mutex);
        ret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg); //层次调用，下面日志内容，通过irq_domain_set_hwirq_and_chip 打印。
        if (ret &lt; 0) {
                mutex_unlock(&amp;irq_domain_mutex);
                goto out_free_irq_data;
        }
        for (i = 0; i &lt; nr_irqs; i++)
                irq_domain_insert_irq(virq + i);
        mutex_unlock(&amp;irq_domain_mutex);

        return virq;

out_free_irq_data:
        irq_domain_free_irq_data(virq, nr_irqs);
out_free_desc:
        irq_free_descs(virq, nr_irqs);
        return ret;
}
</code></pre> 
<blockquote> 
 <p>irq_domain_set_hwirq_and_chip 函数kernel/irq/irqdomain.c</p> 
 <p>从父到子创建。</p> 
 <p>pci设备的MSI中断hwirq和virq的创建：</p> 
 <p></p> 
</blockquote> 
<p>drivers/pci/msi.c函数 pci_msi_setup_msi_irqs中通过dev_get_msi_domain获取的是irq-gic-v3-its-pci-msi.c下创建的domain。然后根据其中的parent，调用irq_domain_alloc_irqs_parent从父节点的domain创建hwirq和virq的映射。</p> 
<blockquote> 
 <p>这个是gic-irq-v3.c中的：<br> [   13.130169] ===irq_domain_set_hwirq_and_chip domain ffff8020c0030400 irq_dataa<br>  ffff8020d6c8f600  virq 32 hwirq 8197 ===<br> [   13.140852] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.19.0 #100<br> [   13.146929] Hardware name: Phytium FT2004/FT2004, BIOS V1006 Apr  7 2020<br> [   13.153613] Call trace:<br> [   13.156047]  dump_backtrace+0x0/0x180<br> [   13.159695]  show_stack+0x24/0x30<br> [   13.162996]  dump_stack+0x90/0xb4<br> [   13.166297]  irq_domain_set_hwirq_and_chip+0x78/0xd8<br> [   13.171246]  irq_domain_set_info+0x58/0x90<br> [   13.175327]  gic_irq_domain_alloc+0xdc/0x268<br> [   13.179582]  irq_domain_alloc_irqs_parent+0x48/0x60<br> [   13.184445]  its_irq_gic_domain_alloc+0xd4/0xf8<br> [   13.188960]  its_irq_domain_alloc+0xd0/0x168<br> [   13.193215]  irq_domain_alloc_irqs_parent+0x48/0x60<br> [   13.198078]  <strong>msi_domain_alloc</strong>+0x7c/0x160<br> [   13.201985]  __irq_domain_alloc_irqs+0x150/0x338<br> [   13.206587]  msi_domain_alloc_irqs+0xa8/0x308<br> [   13.210930]  pci_msi_setup_msi_irqs+0x64/0x78<br> [   13.215271]  __pci_enable_msix+0x320/0x540<br> [   13.219353]  pci_alloc_irq_vectors_affinity+0x120/0x160</p> 
</blockquote> 
<p>下面是gic-irq-v3-its.c中的alloc函数</p> 
<blockquote> 
 <p>[   13.447145] ===irq_domain_set_hwirq_and_chip domain ffff8020c0030500 irq_dataa<br>  ffff8020d6c8cb00  virq 32 hwirq 8197 ===<br> [   13.457825] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.19.0 #100<br> [   13.463902] Hardware name: Phytium FT2004/FT2004, BIOS V1006 Apr  7 2020<br> [   13.470586] Call trace:<br> [   13.473019]  dump_backtrace+0x0/0x180<br> [   13.476667]  show_stack+0x24/0x30<br> [   13.479967]  dump_stack+0x90/0xb4<br> [   13.483267]  irq_domain_set_hwirq_and_chip+0x78/0xd8<br> [   13.488216]  its_irq_domain_alloc+0x58/0x168<br> [   13.492471]  irq_domain_alloc_irqs_parent+0x48/0x60<br> [   13.497334]  <strong>msi_domain_alloc</strong>+0x7c/0x160<br> [   13.501242]  __irq_domain_alloc_irqs+0x150/0x338<br> [   13.505844]  msi_domain_alloc_irqs+0xa8/0x308<br> [   13.510186]  pci_msi_setup_msi_irqs+0x64/0x78<br> [   13.514527]  __pci_enable_msix+0x320/0x540<br> [   13.518609]  pci_alloc_irq_vectors_affinity+0x120/0x160</p> 
</blockquote> 
<p>最终这个是irq-gic-v3-its-pci-msi.c中的接口调用：</p> 
<p>这个3145732 hwirq在函数drivers/pci/msi.c：pci_msi_domain_calc_hwirq中计算。__irq_domain_alloc_irqs下通过ops-&gt;set_desc。调到pci_msi_domain_set_desc。到pci_msi_domain_calc_hwirq</p> 
<blockquote> 
 <p>[   13.595814] ===irq_domain_set_hwirq_and_chip domain ffff8020c0032100 irq_dataa<br>  ffff8020c1b70c28  virq 32 hwirq 3145732 ===<br> [   13.606754] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.19.0 #100<br> [   13.612830] Hardware name: Phytium FT2004/FT2004, BIOS V1006 Apr  7 2020<br> [   13.619514] Call trace:<br> [   13.621947]  dump_backtrace+0x0/0x180<br> [   13.625595]  show_stack+0x24/0x30<br> [   13.628896]  dump_stack+0x90/0xb4<br> [   13.632196]  irq_domain_set_hwirq_and_chip+0x78/0xd8<br> [   13.637145]  msi_domain_ops_init+0x3c/0x80<br> [   13.641227]  <strong>msi_domain_alloc</strong>+0xb8/0x160<br> [   13.645135]  __irq_domain_alloc_irqs+0x150/0x338<br> [   13.649737]  msi_domain_alloc_irqs+0xa8/0x308<br> [   13.654079]  pci_msi_setup_msi_irqs+0x64/0x78<br> [   13.658421]  __pci_enable_msix+0x320/0x540<br> [   13.662502]  pci_alloc_irq_vectors_affinity+0x120/0x160</p> 
</blockquote> 
<h3>pci驱动初始化irq中断：pci_alloc_irq_vectors_affinity 跟踪：</h3> 
<pre><code>pci_alloc_irq_vectors_affinity (drivers/pci/msi.c)
	__pci_enable_msi_range
		msi_capability_init              暂分析msi部分
			pci_msi_setup_msi_irqs 			(drivers/pci/msi.c)
				msi_domain_alloc_irqs 		(kernel/irq/msi.c)
					ops-&gt;domain_alloc_irqs  (kernel/irq/msi.c) //msi_domain_ops-&gt;__msi_domain_alloc_irqs


函数：	
__msi_domain_alloc_irqs (kernel/irq/msi.c)
	msi_domain_prepare_irqs    (一个pci/x 设备分配一个its_devie ：调用its_create_device 分配its_device)
 for_each_msi_entry循环：
	ops-&gt;set_desc   (kernel/irq/msi.c) （pci_msi_domain_calc_hwirq）计算出的全局唯一ID ，作为最上面的irq_data的hwirq                
	__irq_domain_alloc_irqs  //kernel/irq/irqdomain.c
			irq_domain_alloc_descs (kernel/irq/irqdomain.c) ---分配多个irq_desc
			irq_domain_alloc_irq_data (kernel/irq/irqdomain.c) ---建立irq_doamin。irq_data的层次结构
			irq_domain_alloc_irqs_hierarchy (kernel/irq/irqdomain.c)
	irq_set_msi_desc_off 		//设置msi_entry-&gt;irq 。该msi_desc 的irq_base
	irq_domain_insert_irq
	irq_domain_activate_irq   //激活msi/x中断 ,往相关的寄存器写入gic的地址。
		
	
函数：	
irq_domain_alloc_irqs_hierarchy
	domain-&gt;ops-&gt;alloc(domain, irq_base, nr_irqs, arg)  //kernel/irq/msi.c ：irq_domain_ops-&gt;alloc（msi_domain_alloc）
		msi_domain_alloc
			irq_domain_alloc_irqs_parent
				irq_domain_alloc_irqs_hierarchy(domain-&gt;parent,irq_base,nr_irqsa,arg) ......层级调用 irq-gic-v3-its
					domain-&gt;ops-&gt;alloc                 //drivers/irqchip/irq-gic-v3-its.c 提供 its_irq_domain_alloc
						its_irq_domain_alloc			//drivers/irqchip/irq-gic-v3-its.c
							its_irq_gic_domain_alloc
								irq_domain_alloc_irqs_parent  //kernel/irq/irqdomain.c
									irq_domain_alloc_irqs_hierarchy(domain-&gt;parent, irq_base, nr_irqs, arg);  ----------------层级调用到irq-gic-v3
										domain-&gt;ops-&gt;alloc     //drivers/irqchip/irq-gic-v3.c  提供gic_irq_domain_alloc
											gic_irq_domain_alloc  //drivers/irqchip/irq-gic-v3.c
												gic_irq_domain_map
													irq_domain_set_info          //kernel/irq/irqdomain.c
														irq_domain_set_hwirq_and_chip  设置最底层的hwirq和irq,irq_chip
														
							irq_domain_set_hwirq_and_chip       //设置irq_data 的hwirq和irq ,irq_chip //drivers/irqchip/irq-gic-v3-its.c
			msi_domain_ops-&gt;msi_init                      kernel/irq/msi.c 提供msi_domain_ops_init
				irq_domain_set_hwirq_and_chip		设置最上层的hwirq和irq ,irq_chip
				
				
				
dmesg日志：
不同irq_domain_ops-&gt;alloc：先后关系
[   11.265652] ===gic_irq_domain_alloc domain ffff8022c0038f00 virq 47 hwirq 8205 nr_irq 1     //首先是最底层的irq-gic-v3.c
[   11.273733] ===its_irq_domain_alloc domain ffff8022c0039000 virq 47 hwirq 8205 nr_irqs 1    //其次是中级的irq-gic-v3-its.c
[   11.281899] ===msi_domain_alloc doamin ffff8022c003ad00 virq 47  hwirq 7864320 nr_irqs 1		//最后是irq-gic-v3-its-pci-msi.c 使用 kernel/irq/msi.c 的alloc

可以看出：
    每个层级的irq_data的virq是一致的，是同一个虚拟中断号。而hwirq 除了最上层的是pci_msi_domain_calc_hwirq 计算出的全局唯一ID，其它是irq-gic-v3-its.c 中根据gic驱动得出
	
</code></pre> 
<p></p> 
<h3>设置irq_data 中    的hwirq和irq ,irq_chip<br> irq_domain_set_hwirq_and_chip:</h3> 
<pre><code>其中irq_chip代表的中断芯片的配置，分别定义了三个
drivers/irqchip/irq-gic-v3.c：  gic_chip /"GICv3"
drivers/irqchip/irq-gic-v3-its.c: its_irq_chip /"ITS"
drivers/irqchip/irq-gic-v3-its-pci-msi.c: its_msi_irq_chip /"ITS-MSI"</code></pre> 
<h3>激活msi/msix中断：</h3> 
<pre><code>irq_domain_activate_irq
    __irq_domain_activate_irq
        domain-&gt;ops-&gt;activate //kernel/irq/msi.c 中irq_domain_ops-&gt;activate (msi_domain_activate)
            msi_domain_activate
                irq_chip_write_msi_msg




static int msi_domain_activate(struct irq_domain *domain,
                               struct irq_data *irq_data, bool early)
{
        struct msi_msg msg[2] = { [1] = { }, };

        BUG_ON(irq_chip_compose_msi_msg(irq_data, msg));
        msi_check_level(irq_data-&gt;domain, msg);
        irq_chip_write_msi_msg(irq_data, msg);
        return 0;
}


static inline void irq_chip_write_msi_msg(struct irq_data *data,
					  struct msi_msg *msg)
{
	data-&gt;chip-&gt;irq_write_msi_msg(data, msg);
}


__pci_write_msi_msg 函数是具体的写操作、</code></pre> 
<h3>激活msi/msix中断： </h3> 
<pre><code>
irq_domain_activate_irq
    __irq_domain_activate_irq
        domain-&gt;ops-&gt;activate //kernel/irq/msi.c 中irq_domain_ops-&gt;activate (msi_domain_activate)
            msi_domain_activate  //kernel/irq/msi.c
                irq_chip_compose_msi_msg
                irq_chip_write_msi_msg  //写msi/x 相关寄存器。写入gic地址。
                    irq_data-&gt;chip-&gt;irq_write_msi_msg(data, msg);  //此时irq_domain是its_pci_msi创建的，irq_data的 chip数据是 irq-gic-v3-its-pci-msi.c  --- irq_chip "ITS-MSI"



激活需要写入msi/x消息：
static void its_irq_compose_msi_msg(struct irq_data *d, struct msi_msg *msg)
{
        struct its_device *its_dev = irq_data_get_irq_chip_data(d);
        struct its_node *its;
        u64 addr;

        its = its_dev-&gt;its;
        addr = its-&gt;get_msi_base(its_dev); //调用its_irq_get_msi_base函数

        msg-&gt;address_lo         = lower_32_bits(addr); //gic——its的地址
        msg-&gt;address_hi         = upper_32_bits(addr);
        msg-&gt;data               = its_get_event_id(d);  //data
        printk("===its_irq_compose_msi_msg its_device %llx  address %llx_%llx data %u\n",msg-&gt;address_hi,msg-&gt;address_lo,msg-&gt;data);
        iommu_dma_map_msi_msg(d-&gt;irq, msg);
}  

//data的值实际上就是hwirq和当前设备的起始中断号的差。 如果一个设备只有一个，那么这个差值就是0。
static inline u32 its_get_event_id(struct irq_data *d)
{
	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
	return d-&gt;hwirq - its_dev-&gt;event_map.lpi_base;
}

//获取gic——ITS的地址
static u64 its_irq_get_msi_base(struct its_device *its_dev)
{
        struct its_node *its = its_dev-&gt;its;

        return its-&gt;phys_base + GITS_TRANSLATER;
}
</code></pre> 
<p></p> 
<h3>its_irq_compose_msi_msg：合成msi_msg。</h3> 
<p>PS:关于补丁中修改的its驱动“msi中断控制器XXXXXXXXXX”的理解：msi_base 没有转换成iova，直接使用。正常使会通过smmu进行转换的。。。<br> its_irq_compose_msi_msg 中注释了iommu_dma_compose_msi_msg这句话调用。<br> 原函数的意思是需要准备msi_msg。其中有msi_base的地址（its_base+GIC_TRANSLATOR） </p> 
<pre><code>
static void its_irq_compose_msi_msg(struct irq_data *d, struct msi_msg *msg)
{
        struct its_device *its_dev = irq_data_get_irq_chip_data(d);
        struct its_node *its;
        u64 addr;

        its = its_dev-&gt;its;
        addr = its-&gt;get_msi_base(its_dev); 

        msg-&gt;address_lo         = lower_32_bits(addr);
        msg-&gt;address_hi         = upper_32_bits(addr);
        msg-&gt;data               = its_get_event_id(d);

        iommu_dma_compose_msi_msg(irq_data_get_msi_desc(d), msg); //将msi_base的地址通过 iova地址。
}

void iommu_dma_compose_msi_msg(struct msi_desc *desc,
                               struct msi_msg *msg)
{
        struct device *dev = msi_desc_to_dev(desc);
        const struct iommu_domain *domain = iommu_get_domain_for_dev(dev);
        const struct iommu_dma_msi_page *msi_page;

        msi_page = msi_desc_get_iommu_cookie(desc); 

        if (!domain || !domain-&gt;iova_cookie || WARN_ON(!msi_page))
                return;
 
        msg-&gt;address_hi = upper_32_bits(msi_page-&gt;iova); // 地址是msi_page的iova 这个是什么是否分配的 ？？ 是在its的alloc回调its_irq_domain_alloc-&gt;iommu_dma_prepare_msi
        msg-&gt;address_lo &amp;= cookie_msi_granule(domain-&gt;iova_cookie) - 1;
        msg-&gt;address_lo += lower_32_bits(msi_page-&gt;iova);
}

iommu_dma_prepare_msi函数将	分配iommu_dma_msi_page结构体，记录msi_addr和iova。
int iommu_dma_prepare_msi(struct msi_desc *desc, phys_addr_t msi_addr)
{
        struct device *dev = msi_desc_to_dev(desc);
        struct iommu_domain *domain = iommu_get_domain_for_dev(dev);
        struct iommu_dma_msi_page *msi_page;
        static DEFINE_MUTEX(msi_prepare_lock); /* see below */

        if (!domain || !domain-&gt;iova_cookie) {
                desc-&gt;iommu_cookie = NULL;
                return 0;
        }

        /*
         * In fact the whole prepare operation should already be serialised by
         * irq_domain_mutex further up the callchain, but that's pretty subtle
         * on its own, so consider this locking as failsafe documentation...
         */
        mutex_lock(&amp;msi_prepare_lock);
        msi_page = iommu_dma_get_msi_page(dev, msi_addr, domain);
        mutex_unlock(&amp;msi_prepare_lock);

        msi_desc_set_iommu_cookie(desc, msi_page); //将msi_page设置到irq_desc-&gt;iommu_cookie

        if (!msi_page)
                return -ENOMEM;
        return 0;
}
			</code></pre> 
<h3><br>                 <br>                 <br>                 <br>                 </h3> 
<h3>分配的8192开始的号，，怎么开始？its_alloc_device_irq 确定msi的硬件中断号<br> its_device-&gt;event_map.lpi_base-&gt;lpi_base号怎么来的 ？</h3> 
<pre><code>分配的8192开始的号，，怎么开始？its_alloc_device_irq 确定msi的硬件中断号
its_device-&gt;event_map.lpi_base-&gt;lpi_base号怎么来的 ？

gic_its初始化
its_init
	its_alloc_lpi_tables
		its_lpi_init
			free_lpi_range(8192, lpis);
				mk_lpi_range  //创建lpi_range
				list_add(&amp;new-&gt;entry, &amp;lpi_range_list);
				

设备初始化irq	
its_create_device	
	its_lpi_alloc
		alloc_lpi_range //为每个its_device 分配dev-&gt;event_map.lpi_base。每次在前面已经分配的后面。</code></pre> 
<h3>初始化msi中断号：一个its硬件</h3> 
<pre><code>static int __init its_alloc_lpi_tables(void)
{
        phys_addr_t paddr;

        lpi_id_bits = min_t(u32, GICD_TYPER_ID_BITS(gic_rdists-&gt;gicd_typer),
                                ITS_MAX_LPI_NRBITS);
        gic_rdists-&gt;prop_page = its_allocate_prop_table(GFP_NOWAIT);
        if (!gic_rdists-&gt;prop_page) {
                pr_err("Failed to allocate PROPBASE\n");
                return -ENOMEM;
        }

        paddr = page_to_phys(gic_rdists-&gt;prop_page);
        pr_info("===GIC: using LPI property table @%pa lpi_id_bits %u \n", &amp;paddr,lpi_id_bits); //这里实测16 。 16个bit位？？？？
        return its_lpi_init(lpi_id_bits);
}


static int __init its_lpi_init(u32 id_bits)
{
        u32 lpis = (1UL &lt;&lt; id_bits) - 8192; //左移16位为65536 。意思是总共65536 - 8192个中断？
        u32 numlpis;
        int err;

        numlpis = 1UL &lt;&lt; GICD_TYPER_NUM_LPIS(gic_rdists-&gt;gicd_typer);

        if (numlpis &gt; 2 &amp;&amp; !WARN_ON(numlpis &gt; lpis)) {
                lpis = numlpis;
                pr_info("ITS: Using hypervisor restricted LPI range [%u]\n",
                        lpis);
        }

        /*
         * Initializing the allocator is just the same as freeing the
         * full range of LPIs.
         */
        err = free_lpi_range(8192, lpis);  //这里会初始化新的lpi_range 。并加入到lpi_range_list，从8192开始计算。总共65536 - 8192 个
        pr_info("===ITS: Allocator initialized for %u LPIs\n", lpis);
        return err;
}


static int free_lpi_range(u32 base, u32 nr_lpis)
{
        struct lpi_range *new;
        int err = 0;

        mutex_lock(&amp;lpi_range_lock);

        new = mk_lpi_range(base, nr_lpis);
        if (!new) {
                err = -ENOMEM;
                goto out;
        }

        list_add(&amp;new-&gt;entry, &amp;lpi_range_list);
        list_sort(NULL, &amp;lpi_range_list, lpi_range_cmp);
        merge_lpi_ranges();
out:
        mutex_unlock(&amp;lpi_range_lock);
        return err;
}

</code></pre> 
<p>分配中断号：</p> 
<pre><code>static int alloc_lpi_range(u32 nr_lpis, u32 *base)
{
        struct lpi_range *range, *tmp;
        int err = -ENOSPC;

        mutex_lock(&amp;lpi_range_lock);

        list_for_each_entry_safe(range, tmp, &amp;lpi_range_list, entry) {
                if (range-&gt;span &gt;= nr_lpis) {
                        *base = range-&gt;base_id;
                        range-&gt;base_id += nr_lpis;
                        range-&gt;span -= nr_lpis;

                        if (range-&gt;span == 0) {
                                list_del(&amp;range-&gt;entry);
                                kfree(range);
                        }

                        err = 0;
                        break;
                }
        }

        mutex_unlock(&amp;lpi_range_lock);

        pr_info("==ITS: alloc %u:%u\n", *base, nr_lpis);
        dump_stack();
        return err;
}

dmesg日志：
[    6.293629] ==ITS: alloc 8192:1
[    6.615759] ==ITS: alloc 8193:1
[    6.905502] ==ITS: alloc 8194:1
[    7.280835] ==ITS: alloc 8195:1
[    7.582356] ==ITS: alloc 8196:1
[    7.902356] ==ITS: alloc 8197:1
[    8.198276] ==ITS: alloc 8198:1
[    8.489553] ==ITS: alloc 8199:1
[    8.787372] ==ITS: alloc 8200:1
[   11.019360] ==ITS: alloc 8201:4
[   12.709670] ==ITS: alloc 8205:1
[   16.354248] ==ITS: alloc 8206:1
</code></pre> 
<p></p> 
<h3>pci设备注册irq相关的handle：</h3> 
<pre><code>前面初始化的时会返回多个连续virq。

static bool pci_endpoint_test_request_irq(struct pci_endpoint_test *test)
{
        int i;
        int err;
        struct pci_dev *pdev = test-&gt;pdev;
        struct device *dev = &amp;pdev-&gt;dev;

        for (i = 0; i &lt; test-&gt;num_irqs; i++) {
                err = devm_request_irq(dev, pci_irq_vector(pdev, i),  //第i个virq
                                       pci_endpoint_test_irqhandler,
                                       IRQF_SHARED, DRV_MODULE_NAME, test);
                if (err)
                        goto fail;
        }

        return true;

}

获取第nr个virq

int pci_irq_vector(struct pci_dev *dev, unsigned int nr)
{
	if (dev-&gt;msix_enabled) { //msix 有多个，一个irq对应一个msi_desc。
		struct msi_desc *entry;
		int i = 0;

		for_each_pci_msi_entry(entry, dev) {
			if (i == nr)
				return entry-&gt;irq; 
			i++;
		}
		WARN_ON_ONCE(1);
		return -EINVAL;
	}

	if (dev-&gt;msi_enabled) { //msi只有一个msi_desc 。里面记录了irq_base和nvec_used
		struct msi_desc *entry = first_pci_msi_entry(dev);

		if (WARN_ON_ONCE(nr &gt;= entry-&gt;nvec_used))
			return -EINVAL;
	} else {
		if (WARN_ON_ONCE(nr &gt; 0))
			return -EINVAL;
	}

	return dev-&gt;irq + nr; //从base 开始增加 nr 个。
}</code></pre> 
<p>pci_irq_vector 返回第n个irq号。用来申请irq_request。</p> 
<p>1：根据irq找到irq_data<br>     根据irq找到irq_desc-&gt;irq_data</p> 
<p>两种方式：<br> irq_get_irq_data:             获取virq关联的第一层irq_data。<br> irq_domain_get_irq_data：根据irq和domain 找到irq_data。   首先获取virq关联的第一层irq_data ，然后遍历irq_data的parent，比较doamin是否相对。</p> 
<p></p> 
<h3>中断触发后调用gic_handle_irq函数：drivers/irqchip/irq-gic-v3.c</h3> 
<pre><code>static asmlinkage void __exception_irq_entry gic_handle_irq(struct pt_regs *regs)
{
        u32 irqnr;

        do {
                irqnr = gic_read_iar();

                if (likely(irqnr &gt; 15 &amp;&amp; irqnr &lt; 1020) || irqnr &gt;= 8192) {
                        int err;

                        if (static_branch_likely(&amp;supports_deactivate_key))
                                gic_write_eoir(irqnr);
                        else
                                isb();

                        err = handle_domain_irq(gic_data.domain, irqnr, regs);  //使用的是gic_data.domain。也就是irq_gic_v3.c创建的doamin。 其会根据hwirq找到virq。并执行handle
                        if (err) {
                                WARN_ONCE(true, "Unexpected interrupt received!\n");
                                if (static_branch_likely(&amp;supports_deactivate_key)) {
                                        if (irqnr &lt; 8192)
                                                gic_write_dir(irqnr);
                                } else {
                                        gic_write_eoir(irqnr);
                                }
                        }
                        continue;
                }

。。。。

}</code></pre> 
<p></p> 
<p></p> 
<p>/GSIGSI ：<strong>Global System Interrupt</strong>，是ACPI spec规定的全局中断表。. 它为多IOAPIC情况下确定了系统唯一的一个中断号。. 例如IOAPIC1有24个IRQ，IOAPIC2也有24个IRQ，则IOAPIC2 的GSI是从24开始，GSI = 24 + IRQ（IOAPIC2）。. SCI ：System Control Interrupt，系统控制中断，是ACPI定义的，专用于ACPI电源管理的一个IRQ。. 它在Intel平台上常常与南桥的电源管理模块一起，当外部EC等发生Event后会引发SCI。. Windows的SCI ISR程序就是著名的acpi.sys。.</p> 
<h3>非PCI的 中断hwirq和virq</h3> 
<blockquote> 
 <p>[    0.000000] ===irq_domain_set_hwirq_and_chip domain ffff8020c0030400 irq_dataa<br>  ffff8020c0042828  virq 3 hwirq 27 ===<br> [    0.000000] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.19.0 #100<br> [    0.000000] Call trace:<br> [    0.000000]  dump_backtrace+0x0/0x180<br> [    0.000000]  show_stack+0x24/0x30<br> [    0.000000]  dump_stack+0x90/0xb4<br> [    0.000000]  irq_domain_set_hwirq_and_chip+0x78/0xd8<br> [    0.000000]  irq_domain_set_info+0x58/0x90<br> [    0.000000]  gic_irq_domain_alloc+0x170/0x268<br> [    0.000000]  __irq_domain_alloc_irqs+0x150/0x338<br> [    0.000000]  irq_create_fwspec_mapping+0x118/0x318<br> [    0.000000]  acpi_register_gsi+0x6c/0xa8<br> [    0.000000]  map_gt_gsi+0x30/0x3c<br> [    0.000000]  acpi_gtdt_map_ppi+0x4c/0x78<br> [    0.000000]  arch_timer_acpi_init+0xa4/0x280<br> [    0.000000]  acpi_table_parse+0xa4/0xdc<br>  </p> 
</blockquote> 
<p>=================================================================</p> 
<blockquote> 
 <p>[    0.000000] ===irq_domain_set_hwirq_and_chip domain ffff8020c0030400 irq_data ffff8020c0042428  virq 1 hwirq 25 ===<br> [    0.000000] ===irq_domain_set_hwirq_and_chip domain ffff8020c0030400 irq_data ffff8020c0042628  virq 2 hwirq 30 ===<br> [    0.000000] ===irq_domain_set_hwirq_and_chip domain ffff8020c0030400 irq_data ffff8020c0042828  virq 3 hwirq 27 ===<br> .........</p> 
</blockquote> 
<h3>irq_create_fwspec_mapping :</h3> 
<pre><code>​

unsigned int irq_create_fwspec_mapping(struct irq_fwspec *fwspec)
{
	struct irq_domain *domain;
	struct irq_data *irq_data;
	irq_hw_number_t hwirq;
	unsigned int type = IRQ_TYPE_NONE;
	int virq;

	if (fwspec-&gt;fwnode) {
		domain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_WIRED); //irq-gic-v3.c irq_domain
		if (!domain)
			domain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_ANY);
	} else {
		domain = irq_default_domain;
	}

	if (!domain) {
		pr_warn("no irq domain found for %s !\n",
			of_node_full_name(to_of_node(fwspec-&gt;fwnode)));
		return 0;
	}

	if (irq_domain_translate(domain, fwspec, &amp;hwirq, &amp;type))
		return 0;


	if (irq_domain_is_hierarchy(domain)) {
		virq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, fwspec); //__irq_domain_alloc_irqs-&gt;分配virq。调用irq_domain_alloc_irqs_hierarchy:调用gic_irq_v3下的irq_domain-&gt;ops-&gt;alloc .....
		if (virq &lt;= 0)
			return 0;
	} else {
		/* Create mapping */
		virq = irq_create_mapping(domain, hwirq);
		if (!virq)
			return virq;
	}

}



static int irq_domain_translate(struct irq_domain *d,
				struct irq_fwspec *fwspec,
				irq_hw_number_t *hwirq, unsigned int *type)
{
#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY
	if (d-&gt;ops-&gt;translate)
		return d-&gt;ops-&gt;translate(d, fwspec, hwirq, type); //gic_irq_domain_translate
#endif
	if (d-&gt;ops-&gt;xlate)
		return d-&gt;ops-&gt;xlate(d, to_of_node(fwspec-&gt;fwnode),
				     fwspec-&gt;param, fwspec-&gt;param_count,
				     hwirq, type);

	/* If domain has no translation, then we assume interrupt line */
	*hwirq = fwspec-&gt;param[0];
	return 0;
}



static int gic_irq_domain_translate(struct irq_domain *d,
                                    struct irq_fwspec *fwspec,
                                    unsigned long *hwirq,
                                    unsigned int *type)
{
。。。
        if (is_fwnode_irqchip(fwspec-&gt;fwnode)) {
                if(fwspec-&gt;param_count != 2)
                        return -EINVAL;

                *hwirq = fwspec-&gt;param[0];  //fwspec中记录了hwirq
                *type = fwspec-&gt;param[1];

                WARN_ON(*type == IRQ_TYPE_NONE);
                return 0;
        }

。。。。


}

​</code></pre> 
<p>irq_create_fwspec_mapping后续调用： </p> 
<pre><code>irq_create_fwspec_mapping
	irq_domain_alloc_irqs
		__irq_domain_alloc_irqs  //后续流程参考msi

比如acpi创建platform过程中

[    5.094866]  irq_create_fwspec_mapping+0x60/0x310
[    5.099555]  acpi_register_gsi+0x64/0xa4
[    5.103464]  acpi_dev_resource_interrupt+0x170/0x1c0
[    5.108414]  acpi_dev_process_resource+0xe0/0x160
[    5.113104]  acpi_walk_resource_buffer+0x68/0xc8
[    5.117706]  acpi_walk_resources+0xb0/0xf8
[    5.121788]  acpi_dev_get_resources+0xcc/0x130
[    5.126217]  acpi_create_platform_device+0xac/0x2b0
[    5.131080]  acpi_bus_attach+0x274/0x284
[    5.134989]  acpi_bus_attach+0x80/0x284
[    5.138810]  acpi_bus_attach+0x80/0x284
[    5.142632]  acpi_bus_scan+0x50/0xb0
[    5.146193]  acpi_scan_init+0x120/0x284
[    5.150015]  acpi_init+0x2c8/0x33c
[    5.153402]  do_one_initcall+0x50/0x2f0
[    5.157224]  kernel_init_freeable+0x340/0x3cc
[    5.161567]  kernel_init+0x20/0x140
[    5.165042]  ret_from_fork+0x10/0x18</code></pre> 
<p></p> 
<h3>platform_get_irq 函数：</h3> 
<pre><code>drivers/base/platform.c

int platform_get_irq(struct platform_device *dev, unsigned int num)
{
#ifdef CONFIG_SPARC
	/* sparc does not have irqs represented as IORESOURCE_IRQ resources */
	if (!dev || num &gt;= dev-&gt;archdata.num_irqs)
		return -ENXIO;
	return dev-&gt;archdata.irqs[num];
#else
	struct resource *r;
	if (IS_ENABLED(CONFIG_OF_IRQ) &amp;&amp; dev-&gt;dev.of_node) {
		int ret;

		ret = of_irq_get(dev-&gt;dev.of_node, num);
		if (ret &gt; 0 || ret == -EPROBE_DEFER)
			return ret;
	}

	r = platform_get_resource(dev, IORESOURCE_IRQ, num); //中断是一种资源IORESOURCE_IRQ，参考acpi创建platform_device的文章
	if (has_acpi_companion(&amp;dev-&gt;dev)) {
		if (r &amp;&amp; r-&gt;flags &amp; IORESOURCE_DISABLED) {
			int ret;

			ret = acpi_irq_get(ACPI_HANDLE(&amp;dev-&gt;dev), num, r);
			if (ret)
				return ret;
		}
	}

	/*
	 * The resources may pass trigger flags to the irqs that need
	 * to be set up. It so happens that the trigger flags for
	 * IORESOURCE_BITS correspond 1-to-1 to the IRQF_TRIGGER*
	 * settings.
	 */
	if (r &amp;&amp; r-&gt;flags &amp; IORESOURCE_BITS) {
		struct irq_data *irqd;

		irqd = irq_get_irq_data(r-&gt;start);
		if (!irqd)
			return -ENXIO;
		irqd_set_trigger_type(irqd, r-&gt;flags &amp; IORESOURCE_BITS);
	}

	return r ? r-&gt;start : -ENXIO;
#endif
}

</code></pre> 
<h2>pci设备如关联设置msi_domain (irq_domain):</h2> 
<p>apic表的git：其中translation ID用来表示id。</p> 
<p><img alt="" height="114" src="https://images2.imgbox.com/25/9d/Y5F85bWy_o.png" width="554"></p> 
<pre><code>

static void pci_set_msi_domain(struct pci_dev *dev)
{
	struct irq_domain *d;

	/*
	 * If the platform or firmware interfaces cannot supply a
	 * device-specific MSI domain, then inherit the default domain
	 * from the host bridge itself.
	 */
	d = pci_dev_msi_domain(dev);
	if (!d)
		d = dev_get_msi_domain(&amp;dev-&gt;bus-&gt;dev);

	dev_set_msi_domain(&amp;dev-&gt;dev, d);  //设置msi_domain为找到的irq_domain
}

static struct irq_domain *pci_dev_msi_domain(struct pci_dev *dev)
{
	struct irq_domain *d;

	/*
	 * If a domain has been set through the pcibios_add_device()
	 * callback, then this is the one (platform code knows best).
	 */
	d = dev_get_msi_domain(&amp;dev-&gt;dev);
	if (d)
		return d;

	/*
	 * Let's see if we have a firmware interface able to provide
	 * the domain.
	 */
	d = pci_msi_get_device_domain(dev);
	if (d)
		return d;

	return NULL;
}
	

struct irq_domain *pci_msi_get_device_domain(struct pci_dev *pdev)
{
	struct irq_domain *dom;
	u32 rid = pci_dev_id(pdev);

	pci_for_each_dma_alias(pdev, get_msi_id_cb, &amp;rid);
	dom = of_msi_map_get_device_domain(&amp;pdev-&gt;dev, rid, DOMAIN_BUS_PCI_MSI);
	if (!dom)
		dom = iort_get_device_domain(&amp;pdev-&gt;dev, rid,
					     DOMAIN_BUS_PCI_MSI);
	return dom;
}


struct irq_domain *iort_get_device_domain(struct device *dev, u32 id,
					  enum irq_domain_bus_token bus_token)
{
	struct fwnode_handle *handle;
	int its_id;

	if (iort_dev_find_its_id(dev, id, 0, &amp;its_id))  //参考这个获取its_id，其实就是translation id
		return NULL;

	handle = iort_find_domain_token(its_id);
	if (!handle)
		return NULL;

	return irq_find_matching_fwnode(handle, bus_token);
}</code></pre> 
<p>translation id 如何用？</p> 
<p>上面用的了IORT的acpi表：</p> 
<pre><code>[2D0h 0720   1]                         Type : 00
[2D1h 0721   2]                       Length : 0018
[2D3h 0723   1]                     Revision : 00
[2D4h 0724   4]                     Reserved : 00000000
[2D8h 0728   4]                Mapping Count : 00000000
[2DCh 0732   4]               Mapping Offset : 00000000

[2E0h 0736   4]                     ItsCount : 00000001
[2E4h 0740   4]                  Identifiers : 0000001C  //这个和translation id匹配

[2E8h 0744   1]                         Type : 00
[2E9h 0745   2]                       Length : 0018
[2EBh 0747   1]                     Revision : 00
[2ECh 0748   4]                     Reserved : 00000000
[2F0h 0752   4]                Mapping Count : 00000000
[2F4h 0756   4]               Mapping Offset : 00000000

[2F8h 0760   4]                     ItsCount : 00000001
[2FCh 0764   4]                  Identifiers : 0000001D
</code></pre> 
<p>iort_dev_find_its_id 日志 </p> 
<pre><code>[root@localhost ~]# dmesg |grep ===
[    2.191551] ===iort_dev_find_its_id dev 0000:01:00.0 id 256     2.194216] ===iort_dev_find_its_id dev 0000:01:00.1 id 257 idx 0 its-&gt;its_counts 1 its-&gt;identifiers[0] 2 
[    2.194546] ===iort_dev_find_its_id dev 0000:02:00.0 id 512 idx 0 its-&gt;its_counts 1 its-&gt;identifiers[0] 3 
[    2.194667] ===iort_dev_find_its_id dev 0000:02:00.1 id 513 idx 0 its-&gt;its_counts 1 its-&gt;identifiers[0] 3 
[    2.194786] ===iort_dev_find_its_id dev 0000:02:00.2 id 514 idx 0 its-&gt;its_counts 1 its-&gt;identifiers[0] 3 
[    2.209618] ===iort_dev_find_its_id dev 0000:04:00.0 id 1024 idx 0 its-&gt;its_counts 1 its-&gt;identifiers[0] 3 
[    2.224086] ===iort_dev_find_its_id dev 0001:01:00.0 id 256 idx 0 its-&gt;its_counts 1 its-&gt;identifiers[0] 6 
[    2.246036] ===iort_dev_find_its_id dev 0004:03:00.0 id 768 idx 0 its-&gt;its_counts 1 its-&gt;identifiers[0] 19 
[    2.261645] ===iort_dev_find_its_id dev 0004:04:00.0 id 1024 idx 0 its-&gt;its_counts 1 its-&gt;identifiers[0] 19 
[    2.276042] ===iort_dev_find_its_id dev 0005:01:00.0 id 256 idx 0 its-&gt;its_counts 1 its-&gt;identifiers[0] 22 
[    2.279045] ===iort_dev_find_its_id dev 0006:04:00.0 id 1024 idx 0 its-&gt;its_counts 1 its-&gt;identifiers[0] 27 </code></pre> 
<pre><code class="hljs">下面两个第0个die的设备。找到node都是ffff000075cfd5b0。根据output_refrence为78找到，表中78位置的type为0的its，its-&gt;identifiers[0] 19
[    1.712186] ===iort_dev_find_its_id start dev 0000:03:00.0 node ffff000075cfd5b0 type 2 
[    1.712189] ===iort_node_map_id 0 node ffff000075cfd5b0 type 2 mapping_offset 24 mapping_count 2 
[    1.712193] ===iort_node_map_id 1 iort_table ffff000075cfd098 rc 0 out_ref 0 map-&gt;output_reference 78 node ffff000075cfd110 
[    1.712197] ===iort_node_map_id 0 node ffff000075cfd110 type 0 mapping_offset 0 mapping_count 0 
[    1.712200] ===iort_dev_find_its_id end dev 0000:03:00.0 node ffff000075cfd110 type 0 
[    1.712204] ===iort_dev_find_its_id final dev 0000:03:00.0 id 768 idx 0 its-&gt;its_counts 1 its-&gt;identifiers[0] 3 

[    1.721490] ===iort_dev_find_its_id start dev 0000:04:00.0 node ffff000075cfd5b0 type 2 
[    1.721493] ===iort_node_map_id 0 node ffff000075cfd5b0 type 2 mapping_offset 24 mapping_count 2 
[    1.721497] ===iort_node_map_id 1 iort_table ffff000075cfd098 rc 0 out_ref 0 map-&gt;output_reference 78 node ffff000075cfd110 
[    1.721501] ===iort_node_map_id 0 node ffff000075cfd110 type 0 mapping_offset 0 mapping_count 0 
[    1.721504] ===iort_dev_find_its_id end dev 0000:04:00.0 node ffff000075cfd110 type 0 
[    1.721507] ===iort_dev_find_its_id final dev 0000:04:00.0 id 1024 idx 0 its-&gt;its_counts 1 its-&gt;identifiers[0] 3 



第4个die。找到node。根据output_refrence为1f8找到表中1f8位置的type为0的its，，its-&gt;identifiers[0] 19
[    1.756757] ===iort_dev_find_its_id start dev 0004:03:00.0 node ffff000075cfd6a4 type 2 
[    1.756760] ===iort_node_map_id 0 node ffff000075cfd6a4 type 2 mapping_offset 24 mapping_count 2 
[    1.756764] ===iort_node_map_id 1 iort_table ffff000075cfd098 rc 0 out_ref 0 map-&gt;output_reference 1f8 node ffff000075cfd290 
[    1.756768] ===iort_node_map_id 0 node ffff000075cfd290 type 0 mapping_offset 0 mapping_count 0 
[    1.756771] ===iort_dev_find_its_id end dev 0004:03:00.0 node ffff000075cfd290 type 0 
[    1.756775] ===iort_dev_find_its_id final dev 0004:03:00.0 id 768 idx 0 its-&gt;its_counts 1 its-&gt;identifiers[0] 19</code></pre> 
<p>die 4的acpi表内容： </p> 
<pre><code class="hljs">[1F8h 0504   1]                         Type : 00         //偏移1F8
[1F9h 0505   2]                       Length : 0018
[1FBh 0507   1]                     Revision : 00
[1FCh 0508   4]                     Reserved : 00000000
[200h 0512   4]                Mapping Count : 00000000
[204h 0516   4]               Mapping Offset : 00000000

[208h 0520   4]                     ItsCount : 00000001
[20Ch 0524   4]                  Identifiers : 00000013    //0x13


。。。。。。

[61Ch 1564   8]            Memory Properties : [IORT Memory Access Properties]
[61Ch 1564   4]              Cache Coherency : 00000001
[620h 1568   1]        Hints (decoded below) : 00
                                   Transient : 0
                              Write Allocate : 0
                               Read Allocate : 0
                                    Override : 0
[621h 1569   2]                     Reserved : 0000
[623h 1571   1] Memory Flags (decoded below) : 03
                                   Coherency : 1
                            Device Attribute : 1
[624h 1572   4]                ATS Attribute : 00000000
[628h 1576   4]           PCI Segment Number : 00000004   //die4 
[62Ch 1580   1]            Memory Size Limit : 30
[62Dh 1581   3]                     Reserved : 000000

[630h 1584   4]                   Input base : 00000100
[634h 1588   4]                     ID Count : 000001FF
[638h 1592   4]                  Output Base : 00000100
[63Ch 1596   4]             Output Reference : 00000998
[640h 1600   4]        Flags (decoded below) : 00000000
                              Single Mapping : 0

[644h 1604   4]                   Input base : 00000300
[648h 1608   4]                     ID Count : 000003FF
[64Ch 1612   4]                  Output Base : 00000300
[650h 1616   4]             Output Reference : 000001F8    //偏移位置1F8
[654h 1620   4]        Flags (decoded below) : 00000000
                              Single Mapping : 0
</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bbbd3a0366c80535bcee4b55d6e8f52f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【思考总结】数列收敛和级数收敛的联系与区别【概念辨析】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/40d7bec0d7bf809c86c2293569e85131/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UnityHub无法打开项目问题，打开项目闪退回到hub界面</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>