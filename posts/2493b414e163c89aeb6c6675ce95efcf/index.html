<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python&#43;Opencv实现多种形状的检测 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python&#43;Opencv实现多种形状的检测" />
<meta property="og:description" content="目录 一、Hough变换是什么？二、Hough变换原理简介三、Hough变换实现步骤四、Hough变换直线检测代码实现及效果展示五、Hough变换圆形检测代码实现及效果展示六、基于Hough的椭圆检测代码实现及效果展示七、轮廓检测不同形状代码实现及效果展示八、获取图像中的黑色形状块九、移除图中的圆和椭圆十、思维扩展参考资料注意事项 一、Hough变换是什么？ Hough变换是由 P.V.C.Hough提出的一种算法，这种算法可以快速、准确的检测出图片中的直线、圆和椭圆等多种形状。在计算机视觉领域中得到了广泛的使用。
二、Hough变换原理简介 Hough变换是一种特征提取算法，它已经被广泛的应用在机器视觉、图像分析和影像处理等多个方面。Hough变换的主要用途包括寻找图像中直线、圆或椭圆等在图像中的具体位置，其主要的原理是将图像转换到Hough变换空间中，将直角坐标系中的点转换到极坐标系中，通过数学关系的推导，我们可以得到直角坐标系中的直线对应到极坐标系中就是多条曲线的交点，即图像空间中的直线检测问题转化到Hough空间就成了检测曲线的汇集点点的问题。
Hough变换的基本思想是基于点和线的对偶关系，图像空间XY中，所有通过点（x，y）的点所表示的方程为： y = p x &#43; q \mathrm{y}=p x&#43;q y=px&#43;q；其中P表示的是直线的斜率，q表示直线的截距，也可以表示为 q = − p x &#43; y q=-p x&#43;y q=−px&#43;y；如下图所示，图像空间中过 ( x i , y j ) \left(x_{i}, y_{j}\right) (xi​,yj​)点的直线方程可以表示成 y i = p x i &#43; q y_{i}=p x_{i}&#43;q yi​=pxi​&#43;q；也可以在参数空间中表示为 q = − p x i &#43; y i q=-p x_{i}&#43;y_{i} q=−pxi​&#43;yi​。
通过上图我们可以得出图像空间中共线的点和参数空间中的相交的线具有一一对应的关系；参数空间中相交于同一点的所有直线和图像空间中贡献的点相互对应，这就是所谓的点和线之间的对偶关系。Hough变换就是按照这种关系来将图像空间中的检测问题转变成参数空间中寻找交叉点，然后在参数空间中执行简单的累计统计来完成直线的检测任务。当直线接近于竖直方向时，此时我们用极坐标方程来表示该直线。具体的方程可以表示为 λ = x cos ⁡ θ &#43; y sin ⁡ θ \lambda=x \cos \theta&#43;y \sin \theta λ=xcosθ&#43;ysinθ；根据上式，我们可以得出对于极坐标系中的任意一组点 ( λ , θ ) (\lambda, \theta) (λ,θ)都对应这一条直线，即这里将点和线的对偶关系转变成了点和正弦曲线的对偶关系。如下图所示，图a表示的是图像空间中的5个坐标点，它们和图b中的5条曲线相互对应， θ ∈ [ − 90 , &#43; 90 ] , λ ∈ [ − 2 N 2 , &#43; 2 N 2 ] \theta \in[-90,&#43;90], \quad \lambda \in\left[-\frac{\sqrt{2} N}{2},&#43;\frac{\sqrt{2} N}{2}\right] θ∈[−90,&#43;90],λ∈[−22 ​N​,&#43;22 ​N​]，其中N表示图像的宽度。即图像空间中的的点和参数空间中的曲线相互对应，图b中的曲线1、3、5这3条曲线都经过K点，对应到图像空间中表示1、3、5处于同一条直线上面；图a中的2、3、4这3个点处于同一条直线上，对应于参数空间中表示它们所对应的曲线2、3、4都通过同一点L。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2493b414e163c89aeb6c6675ce95efcf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-15T21:12:42+08:00" />
<meta property="article:modified_time" content="2023-03-15T21:12:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python&#43;Opencv实现多种形状的检测</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#Hough_2" rel="nofollow">一、Hough变换是什么？</a></li><li><a href="#Hough_5" rel="nofollow">二、Hough变换原理简介</a></li><li><a href="#Hough_12" rel="nofollow">三、Hough变换实现步骤</a></li><li><a href="#Hough_19" rel="nofollow">四、Hough变换直线检测代码实现及效果展示</a></li><li><a href="#Hough_67" rel="nofollow">五、Hough变换圆形检测代码实现及效果展示</a></li><li><a href="#Hough_109" rel="nofollow">六、基于Hough的椭圆检测代码实现及效果展示</a></li><li><a href="#_151" rel="nofollow">七、轮廓检测不同形状代码实现及效果展示</a></li><li><a href="#_196" rel="nofollow">八、获取图像中的黑色形状块</a></li><li><a href="#_237" rel="nofollow">九、移除图中的圆和椭圆</a></li><li><a href="#_280" rel="nofollow">十、思维扩展</a></li><li><a href="#_283" rel="nofollow">参考资料</a></li><li><a href="#_286" rel="nofollow">注意事项</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="Hough_2"></a>一、Hough变换是什么？</h3> 
<p>  Hough变换是由 P.V.C.Hough提出的一种算法，这种算法可以快速、准确的检测出图片中的直线、圆和椭圆等多种形状。在计算机视觉领域中得到了广泛的使用。</p> 
<h3><a id="Hough_5"></a>二、Hough变换原理简介</h3> 
<p>  Hough变换是一种特征提取算法，它已经被广泛的应用在机器视觉、图像分析和影像处理等多个方面。Hough变换的主要用途包括寻找图像中直线、圆或椭圆等在图像中的具体位置，其主要的原理是将图像转换到Hough变换空间中，将直角坐标系中的点转换到极坐标系中，通过数学关系的推导，我们可以得到直角坐标系中的直线对应到极坐标系中就是多条曲线的交点，即图像空间中的直线检测问题转化到Hough空间就成了检测曲线的汇集点点的问题。<br>   Hough变换的基本思想是基于点和线的对偶关系，图像空间XY中，所有通过点（x，y）的点所表示的方程为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
         = 
        
       
         p 
        
       
         x 
        
       
         + 
        
       
         q 
        
       
      
        \mathrm{y}=p x+q 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathrm" style="margin-right: 0.0139em;">y</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span></span></span></span></span>；其中P表示的是直线的斜率，q表示直线的截距，也可以表示为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         q 
        
       
         = 
        
       
         − 
        
       
         p 
        
       
         x 
        
       
         + 
        
       
         y 
        
       
      
        q=-p x+y 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.1944em;"></span><span class="mord">−</span><span class="mord mathnormal">p</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span>；如下图所示，图像空间中过<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
        
        
          x 
         
        
          i 
         
        
       
         , 
        
        
        
          y 
         
        
          j 
         
        
       
         ) 
        
       
      
        \left(x_{i}, y_{j}\right) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>点的直线方程可以表示成<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          y 
         
        
          i 
         
        
       
         = 
        
       
         p 
        
        
        
          x 
         
        
          i 
         
        
       
         + 
        
       
         q 
        
       
      
        y_{i}=p x_{i}+q 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span></span></span></span></span>；也可以在参数空间中表示为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         q 
        
       
         = 
        
       
         − 
        
       
         p 
        
        
        
          x 
         
        
          i 
         
        
       
         + 
        
        
        
          y 
         
        
          i 
         
        
       
      
        q=-p x_{i}+y_{i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.1944em;"></span><span class="mord">−</span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。<br> <img src="https://images2.imgbox.com/78/e8/GoThfFTN_o.png" alt="在这里插入图片描述"><br>   通过上图我们可以得出图像空间中共线的点和参数空间中的相交的线具有一一对应的关系；参数空间中相交于同一点的所有直线和图像空间中贡献的点相互对应，这就是所谓的点和线之间的对偶关系。Hough变换就是按照这种关系来将图像空间中的检测问题转变成参数空间中寻找交叉点，然后在参数空间中执行简单的累计统计来完成直线的检测任务。当直线接近于竖直方向时，此时我们用极坐标方程来表示该直线。具体的方程可以表示为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         λ 
        
       
         = 
        
       
         x 
        
       
         cos 
        
       
         ⁡ 
        
       
         θ 
        
       
         + 
        
       
         y 
        
       
         sin 
        
       
         ⁡ 
        
       
         θ 
        
       
      
        \lambda=x \cos \theta+y \sin \theta 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span></span></span></span></span>；根据上式，我们可以得出对于极坐标系中的任意一组点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         λ 
        
       
         , 
        
       
         θ 
        
       
         ) 
        
       
      
        (\lambda, \theta) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span><span class="mclose">)</span></span></span></span></span>都对应这一条直线，即这里将点和线的对偶关系转变成了点和正弦曲线的对偶关系。如下图所示，图a表示的是图像空间中的5个坐标点，它们和图b中的5条曲线相互对应，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         θ 
        
       
         ∈ 
        
       
         [ 
        
       
         − 
        
       
         90 
        
       
         , 
        
       
         + 
        
       
         90 
        
       
         ] 
        
       
         , 
        
        
       
         λ 
        
       
         ∈ 
        
        
        
          [ 
         
        
          − 
         
         
          
           
           
             2 
            
           
          
            N 
           
          
         
           2 
          
         
        
          , 
         
        
          + 
         
         
          
           
           
             2 
            
           
          
            N 
           
          
         
           2 
          
         
        
          ] 
         
        
       
      
        \theta \in[-90,+90], \quad \lambda \in\left[-\frac{\sqrt{2} N}{2},+\frac{\sqrt{2} N}{2}\right] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7335em; vertical-align: -0.0391em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">90</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">+</span><span class="mord">90</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 1em;"></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.8em; vertical-align: -0.65em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size2">[</span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.038em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.399em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.9128em;"><span class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mtight" style="padding-left: 0.833em;"><span class="mord mtight">2</span></span></span><span class="" style="top: -2.8728em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail mtight" style="min-width: 0.853em; height: 1.08em;"> 
                    <svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"> 
                     <path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path> 
                    </svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.1272em;"><span class=""></span></span></span></span></span><span class="mord mathnormal mtight" style="margin-right: 0.109em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">+</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.038em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.399em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.9128em;"><span class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mtight" style="padding-left: 0.833em;"><span class="mord mtight">2</span></span></span><span class="" style="top: -2.8728em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail mtight" style="min-width: 0.853em; height: 1.08em;"> 
                    <svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"> 
                     <path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path> 
                    </svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.1272em;"><span class=""></span></span></span></span></span><span class="mord mathnormal mtight" style="margin-right: 0.109em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size2">]</span></span></span></span></span></span></span>，其中N表示图像的宽度。即图像空间中的的点和参数空间中的曲线相互对应，图b中的曲线1、3、5这3条曲线都经过K点，对应到图像空间中表示1、3、5处于同一条直线上面；图a中的2、3、4这3个点处于同一条直线上，对应于参数空间中表示它们所对应的曲线2、3、4都通过同一点L。<br> <img src="https://images2.imgbox.com/5f/1a/nO1pHw23_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Hough_12"></a>三、Hough变换实现步骤</h3> 
<ul><li>步骤1-首先建立一个二维数组，其对应的参数空间为，这个数组其实就相当于一个累加器；</li><li>步骤2-然后使用顺序搜索的方式在图像中的所有目标像素中进行快速的搜索，针对图像中的每一个像素而言，在参数空间中根据式<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          λ 
         
        
          = 
         
        
          x 
         
        
          cos 
         
        
          ⁡ 
         
        
          θ 
         
        
          + 
         
        
          y 
         
        
          sin 
         
        
          ⁡ 
         
        
          θ 
         
        
       
         \lambda=x \cos \theta+y \sin \theta 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span></span></span></span></span>计算出一个对应的位置，在累加器对应的位置上执行一次加1操作；</li><li>步骤3-然后求出累加器中的最大值，也就是参数空间中的最大值，其对应的位置为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ( 
         
         
         
           λ 
          
         
           ′ 
          
         
        
          , 
         
         
         
           θ 
          
         
           ′ 
          
         
        
          ) 
         
        
       
         \left(\lambda^{\prime}, \theta^{\prime}\right) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0019em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7519em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7519em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>；</li><li>步骤4-最后将获得的参数空间位置<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ( 
         
         
         
           λ 
          
         
           ′ 
          
         
        
          , 
         
         
         
           θ 
          
         
           ′ 
          
         
        
          ) 
         
        
       
         \left(\lambda^{\prime}, \theta^{\prime}\right) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0019em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7519em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7519em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>输入到式<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          λ 
         
        
          = 
         
        
          x 
         
        
          cos 
         
        
          ⁡ 
         
        
          θ 
         
        
          + 
         
        
          y 
         
        
          sin 
         
        
          ⁡ 
         
        
          θ 
         
        
       
         \lambda=x \cos \theta+y \sin \theta 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span></span></span></span></span>中，从而找到该空间所对应的图像空间中的直线参数，即我们需要检测的结果。</li></ul> 
<h3><a id="Hough_19"></a>四、Hough变换直线检测代码实现及效果展示</h3> 
<pre><code># coding=utf-8

# 导入python库
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 读取图片
img = cv2.imread('test3.jpg') 
# 彩色图片灰度化
gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
# 执行边缘检测
edges = cv2.Canny(gray,100,200)
# 显示原始结果

cv2.imwrite('edges.png',edges)
cv2.imshow('edge', edges)
# plt.subplot(121)
# plt.imshow(edges)

# 执行Hough直线检测
lines = cv2.HoughLines(edges,1,np.pi/180,160)
lines1 = lines[:,0,:]
for rho,theta in lines1:
    a = np.cos(theta)
    b = np.sin(theta)
    x0 = a*rho
    y0 = b*rho
    x1 = int(x0 + 1000*(-b))
    y1 = int(y0 + 1000*(a))
    x2 = int(x0 - 1000*(-b))
    y2 = int(y0 - 1000*(a)) 
    cv2.line(img,(x1,y1),(x2,y2),(255,0,0),1)

cv2.imwrite('line.png',img)
cv2.imshow('line', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
# plt.subplot(122)
# plt.imshow(img)

</code></pre> 
<p><img src="https://images2.imgbox.com/70/b8/pq31fjlT_o.png" alt="在这里插入图片描述"><br>   上图展示了Hough变换直线检测的结果。第1列表示的是原始的输入图片；第2列表示的是边缘检测的结果；第3列表示Hough直线检测结果。我们可以发现Hough变换准确的检测到图片中的所有直线。<strong>需要主要的是用户需要根据自己的需要对边缘检测的参数进行调节。</strong></p> 
<h3><a id="Hough_67"></a>五、Hough变换圆形检测代码实现及效果展示</h3> 
<pre><code># coding=utf-8
# 导入python包
import numpy as np
import argparse
import cv2

# 构建并解析参数
ap = argparse.ArgumentParser()
ap.add_argument("-i", "--image", required = True, help = "Path to the image")
args = vars(ap.parse_args())

# 读取彩色图片
image = cv2.imread(args["image"])
output = image.copy()
# 将其转换为灰度图片
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# 应用hough变换进行圆检测
circles = cv2.HoughCircles(gray, cv2.HOUGH_GRADIENT, 1.2, 100)

# 确保至少发现一个圆
if circles is not None:
	# 进行取整操作
	circles = np.round(circles[0, :]).astype("int")

	# 循环遍历所有的坐标和半径
	for (x, y, r) in circles:
		# 绘制结果
		cv2.circle(output, (x, y), r, (0, 255, 0), 4)
		cv2.rectangle(output, (x - 5, y - 5), (x + 5, y + 5), (0, 128, 255), -1)

	# 显示结果
	cv2.imshow("output", np.hstack([image, output]))
	cv2.waitKey(0)

</code></pre> 
<p><img src="https://images2.imgbox.com/67/ed/hyW2BfCZ_o.png" alt="在这里插入图片描述"><br>   上图展示了Hough变换圆形检测的结果。每一行表示一个测试图片，第1列表示的是原始的输入图片，第2列表示的是Hough检测的结果。通过上图我们可以获得一些信息，即Hough变换不仅能够处理简单的情况，也能很好的处理复杂的情况。<strong>需要注意的是用户需要根据自己的输入图片去调节cv2.HoughCircles函数中的一些关键参数。</strong></p> 
<h3><a id="Hough_109"></a>六、基于Hough的椭圆检测代码实现及效果展示</h3> 
<pre><code># coding=utf-8

import matplotlib.pyplot as plt
from skimage import data,draw,color,transform,feature

#加载图片，转换成灰度图并检测边缘
image_rgb = data.coffee()[0:220, 160:420] #裁剪原图像，不然速度非常慢
image_gray = color.rgb2gray(image_rgb)
edges = feature.canny(image_gray, sigma=2.0, low_threshold=0.55, high_threshold=0.8)

#执行椭圆变换
result =transform.hough_ellipse(edges, accuracy=20, threshold=250,min_size=100, max_size=120)
result.sort(order='accumulator') #根据累加器排序

#估计椭圆参数
best = list(result[-1])  #排完序后取最后一个
yc, xc, a, b = [int(round(x)) for x in best[1:5]]
orientation = best[5]

#在原图上画出椭圆
cy, cx =draw.ellipse_perimeter(yc, xc, a, b, orientation)
image_rgb[cy, cx] = (0, 0, 255) #在原图中用蓝色表示检测出的椭圆

# #分别用白色表示canny边缘，用红色表示检测出的椭圆，进行对比
# edges = color.gray2rgb(edges)
# edges[cy, cx] = (250, 0, 0) 

fig2, (ax1, ax2) = plt.subplots(ncols=2, nrows=1, figsize=(8, 4))

ax1.set_title('Original picture')
ax1.imshow(image_rgb)

ax2.set_title('Detect result')
ax2.imshow(edges)

plt.show()
</code></pre> 
<p><img src="https://images2.imgbox.com/97/27/8NYVV5nZ_o.png" alt="在这里插入图片描述"><br>   上图展示了Hough变换椭圆检测的结果。第1列表示的是原始的输入图片，图中的蓝线表示检测的结果；第2列表示检测的结果，并将其绘制在一张存在的图片中。图中可以看出Hough变换可以很好的检测出图片中的椭圆。</p> 
<h3><a id="_151"></a>七、轮廓检测不同形状代码实现及效果展示</h3> 
<pre><code># coding=utf-8
# 导入python包
import cv2

# 读取彩色图片
img = cv2.imread('rect1.png')
# 转换为灰度图片
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# 进行二值化处理
ret,binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)

# 寻找轮廓
_,contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

# 绘制不同的轮廓
draw_img0 = cv2.drawContours(img.copy(),contours,0,(0,255,255),3)
draw_img1 = cv2.drawContours(img.copy(),contours,1,(255,0,255),3)
draw_img2 = cv2.drawContours(img.copy(),contours,2,(255,255,0),3)
draw_img3 = cv2.drawContours(img.copy(), contours, -1, (0, 0, 255), 3)

# 打印结果
print ("contours:类型：",type(contours))
print ("第0 个contours:",type(contours[0]))
print ("contours 数量：",len(contours))

print ("contours[0]点的个数：",len(contours[0]))
print ("contours[1]点的个数：",len(contours[1]))

# 显示并保存结果
cv2.imshow("img", img)
cv2.imshow("draw_img0", draw_img0)
cv2.imshow("draw_img1", draw_img1)
cv2.imshow("draw_img2", draw_img2)
cv2.imwrite("rect_result.png", draw_img3)
cv2.imshow("draw_img3", draw_img3)

cv2.waitKey(0)
cv2.destroyAllWindows()
</code></pre> 
<p><img src="https://images2.imgbox.com/6e/92/WDbSig6a_o.png" alt="在这里插入图片描述"><br>   上图展示了利用轮廓检测不同形状的结果。每一行展示了一个测试图片，第1列展示的是输入图片，第2类展示的是输出结果。通过上图我们可以看到轮廓检测算法可以准确的检测到图中的所有轮廓并准确的将他们绘制出来。这在现实场景中具有很广泛的应用价值。</p> 
<h3><a id="_196"></a>八、获取图像中的黑色形状块</h3> 
<pre><code># coding=utf-8
# 导入python包
import numpy as np
import argparse
import imutils
import cv2

# 构建并解析参数
ap = argparse.ArgumentParser()
ap.add_argument("-i", "--image", help = "path to the image file")
args = vars(ap.parse_args())

# 读取图片
image = cv2.imread(args["image"])

# 寻找到图片中的黑色形状块
lower = np.array([0, 0, 0])
upper = np.array([15, 15, 15])
shapeMask = cv2.inRange(image, lower, upper)

# 在mask中寻找轮廓
cnts = cv2.findContours(shapeMask.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
cnts = imutils.grab_contours(cnts)
print("I found {} black shapes".format(len(cnts)))
cv2.imwrite("Mask.png", shapeMask)
cv2.imshow("Mask", shapeMask)

# 循环遍历所有的轮廓
for c in cnts:
	# draw the contour and show it
	cv2.drawContours(image, [c], -1, (0, 255, 0), 2)
cv2.imwrite("shape1.png", image)
cv2.imshow("Image", image)
cv2.waitKey(0)
</code></pre> 
<p><img src="https://images2.imgbox.com/b3/c4/TII8NGT3_o.png" alt="在这里插入图片描述"><br>   上图展示了使用python+opencv自动检测到图像中的黑色形状块，第1列表示的是原始的输入图片，和代码中的image对应；第2列表示的是获取到的掩模，对应于代码中的shapeMask；第3列表示的是检测的结果，对应于代码中的image。通过上图我们可以发现该算法能够准确的检测出这些不同的形状块。</p> 
<h3><a id="_237"></a>九、移除图中的圆和椭圆</h3> 
<pre><code># coding=utf-8
# 导入python包
import numpy as np
import imutils
import cv2

def is_contour_bad(c):
	# 近似轮廓
	peri = cv2.arcLength(c, True)
	approx = cv2.approxPolyDP(c, 0.02 * peri, True)

	# 判断当前的轮廓是不是矩形
	return not len(approx) == 4

# 首先读取图片；然后进行颜色转换；最后进行边缘检测
image = cv2.imread("remove.png")
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
edged = cv2.Canny(gray, 50, 100)
cv2.imshow("Original", image)

# 寻找图中的轮廓并设置mask
cnts = cv2.findContours(edged.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
cnts = imutils.grab_contours(cnts)
mask = np.ones(image.shape[:2], dtype="uint8") * 255

# 循环遍历所有的轮廓
for c in cnts:
	# 检测该轮廓的类型，在新的mask中绘制结果
	if is_contour_bad(c):
		cv2.drawContours(mask, [c], -1, 0, -1)

# 移除不满足条件的轮廓并显示结果
image = cv2.bitwise_and(image, image, mask=mask)
cv2.imwrite("Mask.png", mask)
cv2.imshow("Mask", mask)
cv2.imwrite("result.png", image)
cv2.imshow("After", image)
cv2.waitKey(0)
</code></pre> 
<p><img src="https://images2.imgbox.com/bb/3e/oCLQqSbi_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_280"></a>十、思维扩展</h3> 
<p>  在现实场景中，我们经常会遇到检测图片中具有不同形状的目标的任务。本文主要关注的是直线、圆、椭圆、三角形等，对于那些不规则的形状而言，其实Opencv中已经内嵌了其它的函数，聪明的你一定可以找到这个函数完成一些更加复杂的形状检测任务。</p> 
<h3><a id="_283"></a>参考资料</h3> 
<p>[1] <a href="https://www.pyimagesearch.com/2014/07/21/detecting-circles-images-using-opencv-hough-circles/" rel="nofollow">参考链接</a></p> 
<h3><a id="_286"></a>注意事项</h3> 
<p>[1] 如果您对AI、自动驾驶、AR、ChatGPT等技术感兴趣，欢迎关注我的微信公众号“<strong>AI产品汇</strong>”，有问题可以在公众号中私聊我！<br> [2] 该博客是本人原创博客，如果您对该博客感兴趣，想要转载该博客，请与我联系（qq邮箱：1575262785@qq.com）,我会在第一时间回复大家，谢谢大家的关注.<br> [3] 由于个人能力有限，该博客可能存在很多的问题，希望大家能够提出改进意见。<br> [4] 如果您在阅读本博客时遇到不理解的地方，希望您可以联系我，我会及时的回复您，和您交流想法和意见，谢谢。<br> [5] 本文测试的图片可以通过关注微信公众号<strong>AI产品汇</strong>之后找我索取！<br> [6] <strong>本人业余时间承接各种本科毕设设计和各种小项目，包括图像处理（数据挖掘、机器学习、深度学习等）、matlab仿真、python算法及仿真等，有需要的请加QQ：1575262785详聊！！！</strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2664bdf7f92a40f28fae9b45ef032d30/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">stm32毕业设计 远程家庭智能监控系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5882eff25eadffb9e0be06854f252a1a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深度优先搜索（DFS）和广度优先搜索（BFS）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>