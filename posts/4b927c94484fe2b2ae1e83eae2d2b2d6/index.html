<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>6 FFmpeg从入门到精通-FFmpeg滤镜使用 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="6 FFmpeg从入门到精通-FFmpeg滤镜使用" />
<meta property="og:description" content="1 FFmpeg从入门到精通-FFmpeg简介
2 FFmpeg从入门到精通-FFmpeg工具使用基础
3 FFmpeg从入门到精通-FFmpeg转封装
4 FFmpeg从入门到精通-FFmpeg转码
5 FFmpeg从入门到精通-FFmpeg流媒体
6 FFmpeg从入门到精通-FFmpeg滤镜使用
7 FFmpeg从入门到精通-FFmpeg中Linux设备操作
8 FFmpeg从入门到精通-FFmpeg接口libavformat的使用
9 FFmpeg从入门到精通-FFmpeg接口libavcodec的使用
10 FFmpeg从入门到精通-FFmpeg接口libavfilter的使用
文章目录 6.FFmpeg滤镜使用 6.1 FFmpeg滤镜Filter描述格式 6.1.1 FFmpeg滤镜Filter的参数排列方式 6.1.2 FFmpeg滤镜Filter时间内置变量 6.2 FFmpeg为视频加水印 6.2.1 文字水印 6.2.2 图片水印 6.3 FFmpeg生成画中画 6.4 FFmpeg视频多宫格处理 6.5 FFmpeg音频流滤镜操作 6.5.1 双声道合并单声道 6.5.2 双声道提取 6.5.3 双声道转双音频流 6.5.4 单声道转双声道 6.5.5 两个音频源合并双声道 6.5.6 多个音频合并为多声道 6.6 FFmpeg音频音量探测 6.6.1 音频音量获得 6.6.2 绘制音频波形 6.7 FFmpeg为视频加字幕 6.7.1 ASS字幕流写入视频流 6.7.2 ASS字幕流写入封装容器 6.8 FFmpeg视频抠图合并 6.9 FFmpeg3D视频处理 6.9.1 stereo3d处理3D视频 6." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/4b927c94484fe2b2ae1e83eae2d2b2d6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-29T14:49:25+08:00" />
<meta property="article:modified_time" content="2023-03-29T14:49:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">6 FFmpeg从入门到精通-FFmpeg滤镜使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="https://blog.csdn.net/migu123/article/details/129300701">1 FFmpeg从入门到精通-FFmpeg简介</a><br> <a href="https://blog.csdn.net/migu123/article/details/129300983">2 FFmpeg从入门到精通-FFmpeg工具使用基础</a><br> <a href="https://blog.csdn.net/migu123/article/details/129301229">3 FFmpeg从入门到精通-FFmpeg转封装</a><br> <a href="https://blog.csdn.net/migu123/article/details/129313337">4 FFmpeg从入门到精通-FFmpeg转码</a><br> <a href="https://blog.csdn.net/migu123/article/details/129313756">5 FFmpeg从入门到精通-FFmpeg流媒体</a><br> <a href="https://blog.csdn.net/migu123/article/details/129314333">6 FFmpeg从入门到精通-FFmpeg滤镜使用</a><br> <a href="https://blog.csdn.net/migu123/article/details/129314910">7 FFmpeg从入门到精通-FFmpeg中Linux设备操作</a><br> <a href="https://blog.csdn.net/migu123/article/details/129317309">8 FFmpeg从入门到精通-FFmpeg接口libavformat的使用</a><br> <a href="https://blog.csdn.net/migu123/article/details/129324534">9 FFmpeg从入门到精通-FFmpeg接口libavcodec的使用</a><br> <a href="https://blog.csdn.net/migu123/article/details/129324632">10 FFmpeg从入门到精通-FFmpeg接口libavfilter的使用</a></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#font_face_size46FFmpegfont_12" rel="nofollow"><font face="黑体" size="4">6.FFmpeg滤镜使用</font></a></li><li><ul><li><a href="#nbspnbspfont_face_size361_FFmpegFilterfont_13" rel="nofollow">  <font face="黑体" size="3">6.1 FFmpeg滤镜Filter描述格式</font></a></li><li><ul><li><a href="#font_face_size3nbspnbsp611_FFmpegFilterfont_15" rel="nofollow"><font face="黑体" size="3">  6.1.1 FFmpeg滤镜Filter的参数排列方式</font></a></li><li><a href="#font_face_size3nbspnbsp612_FFmpegFilterfont_25" rel="nofollow"><font face="黑体" size="3">  6.1.2 FFmpeg滤镜Filter时间内置变量</font></a></li></ul> 
   </li><li><a href="#nbspnbspfont_face_size362_FFmpegfont_28" rel="nofollow">  <font face="黑体" size="3">6.2 FFmpeg为视频加水印</font></a></li><li><ul><li><a href="#font_face_size3nbspnbsp621_font_30" rel="nofollow"><font face="黑体" size="3">  6.2.1 文字水印</font></a></li><li><a href="#font_face_size3nbspnbsp622_font_70" rel="nofollow"><font face="黑体" size="3">  6.2.2 图片水印</font></a></li></ul> 
   </li><li><a href="#nbspnbspfont_face_size363_FFmpegfont_85" rel="nofollow">  <font face="黑体" size="3">6.3 FFmpeg生成画中画</font></a></li><li><a href="#nbspnbspfont_face_size364_FFmpegfont_105" rel="nofollow">  <font face="黑体" size="3">6.4 FFmpeg视频多宫格处理</font></a></li><li><a href="#nbspnbspfont_face_size365_FFmpegfont_116" rel="nofollow">  <font face="黑体" size="3">6.5 FFmpeg音频流滤镜操作</font></a></li><li><ul><li><a href="#font_face_size3nbspnbsp651_font_118" rel="nofollow"><font face="黑体" size="3">  6.5.1 双声道合并单声道</font></a></li><li><a href="#font_face_size3nbspnbsp652_font_141" rel="nofollow"><font face="黑体" size="3">  6.5.2 双声道提取</font></a></li><li><a href="#font_face_size3nbspnbsp653_font_177" rel="nofollow"><font face="黑体" size="3">  6.5.3 双声道转双音频流</font></a></li><li><a href="#font_face_size3nbspnbsp654_font_196" rel="nofollow"><font face="黑体" size="3">  6.5.4 单声道转双声道</font></a></li><li><a href="#font_face_size3nbspnbsp655_font_225" rel="nofollow"><font face="黑体" size="3">  6.5.5 两个音频源合并双声道</font></a></li><li><a href="#font_face_size3nbspnbsp656_font_254" rel="nofollow"><font face="黑体" size="3">  6.5.6 多个音频合并为多声道</font></a></li></ul> 
   </li><li><a href="#nbspnbspfont_face_size366_FFmpegfont_271" rel="nofollow">  <font face="黑体" size="3">6.6 FFmpeg音频音量探测</font></a></li><li><ul><li><a href="#font_face_size3nbspnbsp661_font_273" rel="nofollow"><font face="黑体" size="3">  6.6.1 音频音量获得</font></a></li><li><a href="#font_face_size3nbspnbsp662_font_304" rel="nofollow"><font face="黑体" size="3">  6.6.2 绘制音频波形</font></a></li></ul> 
   </li><li><a href="#nbspnbspfont_face_size367_FFmpegfont_318" rel="nofollow">  <font face="黑体" size="3">6.7 FFmpeg为视频加字幕</font></a></li><li><ul><li><a href="#font_face_size3nbspnbsp671_ASSfont_320" rel="nofollow"><font face="黑体" size="3">  6.7.1 ASS字幕流写入视频流</font></a></li><li><a href="#font_face_size3nbspnbsp672_ASSfont_349" rel="nofollow"><font face="黑体" size="3">  6.7.2 ASS字幕流写入封装容器</font></a></li></ul> 
   </li><li><a href="#nbspnbspfont_face_size368_FFmpegfont_358" rel="nofollow">  <font face="黑体" size="3">6.8 FFmpeg视频抠图合并</font></a></li><li><a href="#nbspnbspfont_face_size369_FFmpeg3Dfont_377" rel="nofollow">  <font face="黑体" size="3">6.9 FFmpeg3D视频处理</font></a></li><li><ul><li><a href="#font_face_size3nbspnbsp691_stereo3d3Dfont_379" rel="nofollow"><font face="黑体" size="3">  6.9.1 stereo3d处理3D视频</font></a></li><li><a href="#font_face_size3nbspnbsp692_3Dfont_381" rel="nofollow"><font face="黑体" size="3">  6.9.2 3D图像转换举例</font></a></li></ul> 
   </li><li><a href="#nbspnbspfont_face_size3610_FFmpegfont_390" rel="nofollow">  <font face="黑体" size="3">6.10 FFmpeg定时视频截图</font></a></li><li><ul><li><a href="#font_face_size3nbspnbsp6101_vframefont_392" rel="nofollow"><font face="黑体" size="3">  6.10.1 vframe参数截取一张图片</font></a></li><li><a href="#font_face_size3nbspnbsp6102_fpsfont_410" rel="nofollow"><font face="黑体" size="3">  6.10.2 fps滤镜定时获得图片</font></a></li></ul> 
   </li><li><a href="#nbspnbspfont_face_size3611_FFmpegfont_429" rel="nofollow">  <font face="黑体" size="3">6.11 FFmpeg生成测试元数据</font></a></li><li><ul><li><a href="#font_face_size3nbspnbsp6111_FFmpegfont_431" rel="nofollow"><font face="黑体" size="3">  6.11.1 FFmpeg生成音频测试流</font></a></li><li><a href="#font_face_size3nbspnbsp6112_FFmpegfont_443" rel="nofollow"><font face="黑体" size="3">  6.11.2 FFmpeg生成视频测试流</font></a></li></ul> 
   </li><li><a href="#nbspnbspfont_face_size3612_FFmpegfont_465" rel="nofollow">  <font face="黑体" size="3">6.12 FFmpeg对音视频倍速处理</font></a></li><li><ul><li><a href="#font_face_size3nbspnbsp6121_atempofont_467" rel="nofollow"><font face="黑体" size="3">  6.12.1 atempo音频倍速处理</font></a></li><li><a href="#font_face_size3nbspnbsp6122_setptsfont_514" rel="nofollow"><font face="黑体" size="3">  6.12.2 setpts视频倍速处理</font></a></li></ul> 
   </li><li><a href="#nbspnbspfont_face_size3613_font_559" rel="nofollow">  <font face="黑体" size="3">6.13 小结</font></a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="font_face_size46FFmpegfont_12"></a><font face="黑体" size="4">6.FFmpeg滤镜使用</font></h2> 
<h3><a id="nbspnbspfont_face_size361_FFmpegFilterfont_13"></a>  <font face="黑体" size="3">6.1 FFmpeg滤镜Filter描述格式</font></h3> 
<p><font face="Courier New">    在使用FFmpeg的滤镜处理音视频特效之前，首先需要了解一下Filter的基本格式。</font></p> 
<h4><a id="font_face_size3nbspnbsp611_FFmpegFilterfont_15"></a><font face="黑体" size="3">  6.1.1 FFmpeg滤镜Filter的参数排列方式</font></h4> 
<p><font face="Courier New">    为了便于理解Filter使用的方法，下面先用最简单的方式来描述Filter使用时的参数排列方式：</font></p> 
<pre><code class="prism language-bash">输入流或标记名<span class="token punctuation">]</span>滤镜参数<span class="token punctuation">[</span>临时标记名<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span>输入流或标记名<span class="token punctuation">]</span>滤镜参数<span class="token punctuation">[</span>临时标记名<span class="token punctuation">]</span>…
</code></pre> 
<p><font face="Courier New">    文字描述的排列方式很明确，接下来列举一个简单的例子：输入两个文件，一个视频input.mp4，一个图片logo.png，将logo进行缩放，然后放在视频的左上角：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -i logo.png -filter_complex <span class="token string">"[1:v]scale=176:144[logo];[0:v][logo]overlay=x=0:y=0"</span> output.mp4
</code></pre> 
<p><font face="Courier New">    从上述命令可以看出，将<code>logo.png的图像流缩放为176×144</code>的分辨率，然后<code>定义一个临时标记名logo</code>，最后将缩放后的图像<code>[logo]</code>铺在输入的视频input.mp4的视频流<code>[0:v]</code>的左上角。</font></p> 
<h4><a id="font_face_size3nbspnbsp612_FFmpegFilterfont_25"></a><font face="黑体" size="3">  6.1.2 FFmpeg滤镜Filter时间内置变量</font></h4> 
<p><font face="Courier New">    在使用Filter时，经常会用到根据时间轴进行操作的需求，下面先来了解一下这些相关的变量，见表。</font><br> <img src="https://images2.imgbox.com/85/e5/lEUvd2Nh_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="nbspnbspfont_face_size362_FFmpegfont_28"></a>  <font face="黑体" size="3">6.2 FFmpeg为视频加水印</font></h3> 
<p><font face="Courier New">    FFmpeg可以<code>为视频添加水印，水印可以是文字，也可以是图片</code>，主要用来标记视频所属标记等。下面就来看一下FFmpeg加水印的多种方式。</font></p> 
<h4><a id="font_face_size3nbspnbsp621_font_30"></a><font face="黑体" size="3">  6.2.1 文字水印</font></h4> 
<p><font face="Courier New">    在视频中增加文字水印需要准备的条件比较多，需要有文字字库处理的相关文件，在编译<code>FFmpeg时需要支持FreeType、FontConfig、iconv</code>，系统中需要有相关的字库，在FFmpeg中增加纯字母水印可以使用<code>drawtext滤镜进行支持</code>，下面就来看一下drawtext的滤镜参数，具体见表。</font><br> <img src="https://images2.imgbox.com/fe/2e/vWmh9M0x_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    <code>drawtext滤镜使用举例</code><br>     使用drawtext可以根据前面介绍过的参数进行加水印设置，例如将文字的水印加在视频的左上角，命令行如下：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -vf <span class="token string">"drawtext=fontsize=100:fontfile=FreeSerif.ttf:text='hello world':x=20:y=20"</span> output.mp4
</code></pre> 
<p><font face="Courier New">    执行完这条命令行之后，即可在output.mp4视频的左上角增加“hello world”文字水印，为了使文字展示得更清楚一些，将文字大小设置为100像素，如图所示。</font><br> <img src="https://images2.imgbox.com/aa/19/9f2Vg2Ux_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    如图所示，视频的左上角加入了“hello world”文字水印。<br>     图的文字水印为纯黑色，会展现得比较突兀，为了使水印更加柔和，可以通过drawtext滤镜的fontcolor参数调节颜色，例如将字体的颜色设置为绿色：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -vf <span class="token string">"drawtext=fontsize=100:fontfile=FreeSerif.ttf:text='hello world':fontcolor=green"</span> output.mp4
</code></pre> 
<p><font face="Courier New">    执行完命令行之后，文字水印即为绿色，如图所示。</font><br> <img src="https://images2.imgbox.com/82/97/lEZvb3oo_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    如果想调整文字水印显示的位置，<code>调整x与y参数的数值即可</code>。文字水印还可以增加一个框，然后给框加上背景颜色：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -vf <span class="token string">"drawtext=fontsize=100:fontfile=FreeSerif.ttf:text='hello world':fontcolor=green:box=1:boxcolor=yellow"</span> output.mp4
</code></pre> 
<p><font face="Courier New">    <code>执行完命令行之后，视频左上角显示文字水印，水印背景色为黄色，效果如图所示</code>。</font><br> <img src="https://images2.imgbox.com/9d/58/6McO6q47_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    至此，文字水印的基础功能已经添加完成。<br>     有些时候文字水印希望以本地时间作为水印内容，可以在drawtext滤镜中配合一些特殊用法来完成，例如：</font></p> 
<pre><code class="prism language-bash">ffmpeg -re -i input.mp4 -vf <span class="token string">"drawtext=fontsize=60:fontfile=FreeSerif.ttf:text='%{localtime\:%Y\-%m\-%d %H-%M-%S}':fontcolor=green:box=1:boxcolor=yellow"</span> output.mp4
</code></pre> 
<p><font face="Courier New">    <code>在text中显示本地当前时间，格式为年月日时分秒的方式</code>，具体情况如图所示。</font><br> <img src="https://images2.imgbox.com/b2/16/zmlyr0dm_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    在个别场景中，需要<code>定时显示水印，定时不显示水印</code>，这种方式同样可以配合drawtext滤镜进行处理，使用drawtext与enable配合即可，例如每3秒钟显示一次文字水印：</font></p> 
<pre><code class="prism language-bash">ffmpeg -re -i input.mp4 -vf <span class="token string">"drawtext=fontsize=60:fontfile=FreeSerif.ttf:text='test':fontcolor=green:box=1:boxcolor=yellow:enable=lt(mod(t\,3)\,1)"</span> output.mp4
</code></pre> 
<p><font face="Courier New">    执行完命令行之后，即可达到每三秒钟闪一下文字水印的效果，由于其是一个动态展示的视频，所以在这里就不抓图展示了。<br>     当然，<code>大多数时候文字水印会有中文字符，此时系统需要包含中文字库与中文编码支持</code>，这样才能够将中文水印加入到视频中并正常显示。</font></p> 
<pre><code class="prism language-bash">ffmpeg -re -i input.mp4 -vf <span class="token string">"drawtext=fontsize=50:fontfile=/Library/Fonts/Songti.ttc:text='文字水印测试':fontcolor=green:box=1:boxcolor=yellow"</span> output.mp4
</code></pre> 
<p><font face="Courier New">    执行完命令行之后即可将中文水印加入到视频当中，并且中文字符的字体为行文楷体。</font></p> 
<h4><a id="font_face_size3nbspnbsp622_font_70"></a><font face="黑体" size="3">  6.2.2 图片水印</font></h4> 
<p><font face="Courier New">    FFmpeg除了可以向视频添加文字水印之外，还可以向<code>视频添加图片水印、视频跑马灯等</code>，本节将重点介绍如何为视频添加图片水印；为视频添加图片水印可以使用movie滤镜，下面就来熟悉一下movie滤镜的参数，如表所示。</font><br> <img src="https://images2.imgbox.com/c8/a6/EqFzMlA7_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    下面举例说明，在FFmpeg中加入图片水印有两种方式，一种是<code>通过movie指定水印文件路径</code>，另外一种方式是<code>通过filter读取输入文件的流并指定为水印</code>，这里重点介绍如何读取movie图片文件作为水印，举例如下：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -vf <span class="token string">"movie=logo.png[wm]; [in][wm]overlay=30:10[out]"</span> output.mp4
</code></pre> 
<p><font face="Courier New">    执行完命令行之后logo.png水印将会打入到input.mp4视频中，显示在x坐标30、y坐标10的位置，如图所示。<br> <img src="https://images2.imgbox.com/83/22/N10OTdP7_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    从图中可以看到，将透明水印加入到视频中的效果更好一些。<code>当只有纯色背景的logo图片时，可以考虑使用movie与colorkey滤镜配合做成半透明效果</code>，例如：</font></font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -vf <span class="token string">"movie=logo.png,colorkey=black:1.0:1.0 [wm]; [in] [wm]overlay=30:10 [out]"</span> output.mp4
</code></pre> 
<p><font face="Courier New">    执行完命令行之后，将会根据colorkey设置的颜色值、相似度、混合度与原片混合为半透明水印。</font></p> 
<h3><a id="nbspnbspfont_face_size363_FFmpegfont_85"></a>  <font face="黑体" size="3">6.3 FFmpeg生成画中画</font></h3> 
<p><font face="Courier New">    在使用FFmpeg处理流媒体文件时，有时需要使用画中画的效果。在FFmpeg中，可以<code>通过overlay将多个视频流、多个多媒体采集设备、多个视频文件合并到一个界面中，生成画中画的效果</code>。在前面的滤镜使用中，以至于以后的滤镜使用中，与视频操作相关的处理，大多数都会与overlay滤镜配合使用，尤其是用在图层处理与合并场景中，下面就来了解一下overlay的参数，具体见表。</font><br> <img src="https://images2.imgbox.com/29/8f/qB5gZXpK_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    从参数列表中可以看到，主要参数并不多，但实际上在overlay滤镜使用中，还有很多组合的参数可以使用，可以使用一些内部变量，例如overlay图层的宽、高、坐标等；下面再列举几个画中画的例子：</font></p> 
<pre><code class="prism language-bash">ffmpeg -re -i input.mp4 -vf <span class="token string">"movie=sub.mp4,scale=480x320[test]; [in][test] overlay [out]"</span> -vcodec libx264 output.flv
</code></pre> 
<p><font face="Courier New">    执行完命令行之后会<code>将sub.mp4视频文件缩放成宽480、高320的视频，然后显示在视频input.mp4的x坐标为0、y坐标为0的位置</code>，下面看一下命令行执行后生成的output.flv的效果，如图所示。</font><br> <img src="https://images2.imgbox.com/80/c6/3f4l5gKn_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    图即为显示画中画的最基本方式，<code>如果希望子视频显示在指定位置，例如显示在画面的右下角，则需要用到overlay中x坐标与y坐标的内部变量</code>：</font></p> 
<pre><code class="prism language-bash">ffmpeg -re -i input.mp4 -vf <span class="token string">"movie=sub.mp4,scale=480x320[test]; [in][test] overlay=x=main_w-480:y=main_h-320 [out]"</span> -vcodec libx264 output.flv
</code></pre> 
<p><font face="Courier New">    根据命令行可以分析出，<code>除了显示在overlay画面中，子视频将会定位在主画面的最右边减去子视频的宽度，最下边减去子视频的高度的位置</code>，生成的视频播放效果如图所示。</font><br> <img src="https://images2.imgbox.com/23/8d/HPQGDNJH_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    以上两种视频画中画的处理均为静态位置处理，<code>使用overlay还可以配合正则表达式进行跑马灯式画中画处理，动态改变子画面的x坐标与y坐标即可</code>：</font></p> 
<pre><code class="prism language-bash">ffmpeg -re -i input.mp4 -vf <span class="token string">"movie=sub.mp4,scale=480x320[test]; [in][test] overlay=x='if(gte(t,2), -w+(t-2)*20, NAN)':y=0 [out]"</span> -vcodec libx264 output.flv
</code></pre> 
<p><font face="Courier New">    命令行执行之后，<code>子视频将会从主视频的左侧开始渐入视频从左向右游动</code>，视频画中画的基本处理至此已介绍完毕，重点为overlay滤镜的使用。</font></p> 
<h3><a id="nbspnbspfont_face_size364_FFmpegfont_105"></a>  <font face="黑体" size="3">6.4 FFmpeg视频多宫格处理</font></h3> 
<p><font face="Courier New">    视频除了画中画显示，还有一种场景为以<code>多宫格的方式呈现出来</code>，除了可以输入视频文件，还可以输入视频流、采集设备等。从前文中可以看出进行视频图像处理时，overlay滤镜为关键画布，可以通过FFmpeg建立一个画布，也可以使用默认的画布。如果想以多宫格的方式展现，则可以自己建立一个足够大的画布，下面就来看一下多宫格展示的例子：</font></p> 
<pre><code class="prism language-bash">ffmpeg -re -i input1.mp4 -re -i input2.mp4 -re -i input3.mp4 -re -i input4.mp4 -filter_complex <span class="token string">"nullsrc=size=640x480 [base]; [0:v] setpts=PTS-STARTPTS, scale=320x240 [upperleft]; [1:v] setpts=PTS-STARTPTS, scale=320x240 [upperright]; [2:v] setpts=PTS-STARTPTS, scale=320x240 [lowerleft]; [3:v] setpts=PTS-STARTPTS, scale=320x240 [lowerright]; [base][upperleft] overlay=shortest=1 [tmp1]; [tmp1][upperright] overlay=shortest=1:x=320 [tmp2]; [tmp2][lowerleft] overlay=shortest=1:y=240 [tmp3]; [tmp3][lowerright] overlay=shortest=1:x=320:y=240"</span> -c:v libx264 output.flv
</code></pre> 
<p><font face="Courier New">    执行完命令行之后，即可<code>通过nullsrc创建一个overlay画布</code>，<code>画布的大小为宽640像素、高480像素</code>，使用<code>[0:v][1:v][2:v][3:v]将输入的4个视频流去除</code>，<code>分别进行缩放处理，处理为宽320、高240的视频</code>，然后<code>基于nullsrc生成的画布进行视频平铺</code>，平铺的整体情况如图所示。</font><br> <img src="https://images2.imgbox.com/17/0c/Pn095C6J_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    根据命令中定义的<mark>upperleft、upperright、lowerleft、lowerright</mark>进行不同位置的平铺，平铺的整体步骤如图所示。</font><br> <img src="https://images2.imgbox.com/42/13/rm8PKKqH_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    执行完命令行之后的最终展现形式如图所示。</font><br> <img src="https://images2.imgbox.com/7b/30/MxztQ9hG_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="nbspnbspfont_face_size365_FFmpegfont_116"></a>  <font face="黑体" size="3">6.5 FFmpeg音频流滤镜操作</font></h3> 
<p><font face="Courier New">    FFmpeg除了可以操作视频之外，还可以对音频进行操作，例如<code>拆分声道</code>、<code>合并多声道为单声道</code>、<code>调整声道布局</code>、<code>调整音频采样率</code>等，<code>而进行音频的拆分与合并，在FFmpeg中可以使用滤镜进行操作</code>，可以通过<mark>amix、amerge、pan、channelsplit、volume、volumedetect</mark>等滤镜进行常用的音频操作，下面就来了解一下相关的操作。</font></p> 
<h4><a id="font_face_size3nbspnbsp651_font_118"></a><font face="黑体" size="3">  6.5.1 双声道合并单声道</font></h4> 
<p><font face="Courier New">    在进行音频转换时常常会遇到音频声道发生改变的情况，例如将双声道合并为单声道，通过<code>ffmpeg –layouts</code>参数可以查看音频的声道布局支持情况，例如将双声道合并为单声道操作，则是将<code>stereo转变为mono模式</code>，如图所示。</font><br> <img src="https://images2.imgbox.com/ac/23/dAMVQRvm_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">ffmpeg -i input.aac -ac <span class="token number">1</span> output.aac
</code></pre> 
<p><font face="Courier New">    执行完命令行之后，<code>input.aac的音频原为双声道，现被转为单声道</code>，下面来看一下执行后的对比信息：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, aac, from 'input.aac':</span>
  Duration: 00:00:34.25, bitrate: <span class="token number">5</span> kb/s
  Stream <span class="token comment">#0:0: Audio: aac (LC), 48000 Hz, stereo, fltp, 5 kb/s</span>
Stream mapping:
  Stream <span class="token comment">#0:0 -&gt; #0:0 (aac (native) -&gt; aac (native))</span>
Press <span class="token punctuation">[</span>q<span class="token punctuation">]</span> to stop, <span class="token punctuation">[</span>?<span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token builtin class-name">help</span>
Output <span class="token comment">#0, adts, to 'output.aac':</span>
  Metadata:
    encoder         <span class="token builtin class-name">:</span> Lavf59.34.102
  Stream <span class="token comment">#0:0: Audio: aac (LC), 48000 Hz, mono, fltp, 69 kb/s</span>
    Metadata:
      encoder         <span class="token builtin class-name">:</span> Lavc59.54.100 aac
<span class="token assign-left variable">size</span><span class="token operator">=</span>      18kB <span class="token assign-left variable">time</span><span class="token operator">=</span>00:00:35.00 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span>   <span class="token number">4</span>.2kbits/s <span class="token assign-left variable">speed</span><span class="token operator">=</span> 477x
</code></pre> 
<p><font face="Courier New">    从图中可以看到，<code>input.aac的音频是stereo布局方式</code>，即FL与FR两个声道，通过ac将双声道转为单声道mono布局，输出为output.aac。原本双声道的音频，左耳右耳都可以听到声音，调整后依然可以左右耳都听到声音，只是布局发生了改变，为中央布局；接下来可以将双声道拆分成左耳与右耳两个音频，每个耳朵只能听到一个声道的声音。</font></p> 
<h4><a id="font_face_size3nbspnbsp652_font_141"></a><font face="黑体" size="3">  6.5.2 双声道提取</font></h4> 
<p><font face="Courier New">    使用FFmpeg可以提取多声道的音频并输出至新音频文件或者多个音频流，以便于后续的编辑等，下面看一下提取多声道音频的方式，如图所示。</font><br> <img src="https://images2.imgbox.com/2b/4d/cBSENcaZ_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    从提取方式中可以看到，将音频为stereo的布局提取为两个mono流，左声道一个流，右声道一个流，命令格式如下。可以使用FFmpeg的map_channel参数实现：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.aac -map_channel <span class="token number">0.0</span>.0 left.aac -map_channel <span class="token number">0.0</span>.1 right.aac
</code></pre> 
<p><font face="Courier New">    这里也可以使用pan滤镜实现：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.aac -filter_complex <span class="token string">"[0:0]pan=1c|c0=c0[left];[0:0]pan=1c|c0=c1[right]"</span> -map <span class="token string">"[left]"</span> left.aac -map <span class="token string">"[right]"</span> right.aac
</code></pre> 
<p><font face="Courier New">    命令行执行后，会将布局格式为stereo的input.aac转换为两个mono布局的left.aac与right.aac：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, aac, from 'input.aac':</span>
  Duration: 00:00:34.25, bitrate: <span class="token number">5</span> kb/s
  Stream <span class="token comment">#0:0: Audio: aac (LC), 48000 Hz, stereo, fltp, 5 kb/s</span>
Stream mapping:
  Stream <span class="token comment">#0:0 (aac) -&gt; pan:default</span>
  Stream <span class="token comment">#0:0 (aac) -&gt; pan:default</span>
  pan:default -<span class="token operator">&gt;</span> Stream <span class="token comment">#0:0 (aac)</span>
  pan:default -<span class="token operator">&gt;</span> Stream <span class="token comment">#1:0 (aac)</span>
Output <span class="token comment">#0, adts, to 'left.aac':</span>
  Metadata:
    encoder         <span class="token builtin class-name">:</span> Lavf59.34.102
  Stream <span class="token comment">#0:0: Audio: aac (LC), 48000 Hz, mono, fltp, 69 kb/s</span>
    Metadata:
      encoder         <span class="token builtin class-name">:</span> Lavc59.54.100 aac
Output <span class="token comment">#1, adts, to 'right.aac':</span>
  Metadata:
    encoder         <span class="token builtin class-name">:</span> Lavf59.34.102
  Stream <span class="token comment">#1:0: Audio: aac (LC), 48000 Hz, mono, fltp, 69 kb/s</span>
    Metadata:
      encoder         <span class="token builtin class-name">:</span> Lavc59.54.100 aac
<span class="token assign-left variable">size</span><span class="token operator">=</span>      18kB <span class="token assign-left variable">time</span><span class="token operator">=</span>00:00:35.00 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span>   <span class="token number">4</span>.2kbits/s <span class="token assign-left variable">speed</span><span class="token operator">=</span> 276x
</code></pre> 
<p><font face="Courier New">    从上述输出中可以看到，<code>input.aac为stereo，而left.aac与right.aac为mono</code>。</font></p> 
<h4><a id="font_face_size3nbspnbsp653_font_177"></a><font face="黑体" size="3">  6.5.3 双声道转双音频流</font></h4> 
<p><font face="Courier New">    <code>FFmpeg不但可以将双声道音频提取出来生成两个音频文件，还可以将双声道音频提取出来转为一个音频文件两个音频流，每个音频流为一个声道</code>，转换方式如图所示。</font><br> <img src="https://images2.imgbox.com/68/46/Pegc9bp1_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">ffmpeg -i input.aac -filter_complex <span class="token assign-left variable">channelsplit</span><span class="token operator">=</span>channel_layout<span class="token operator">=</span>stereo output.mka
</code></pre> 
<p><font face="Courier New">    命令行通过channelsplit滤镜将stereo布局方式的音频切分开，分成两个音频流，下面来看一下切分前后的音频效果：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, aac, from 'input.aac':</span>
  Duration: 00:00:34.25, bitrate: <span class="token number">5</span> kb/s
  Stream <span class="token comment">#0:0: Audio: aac (LC), 48000 Hz, stereo, fltp, 5 kb/s</span>
Output <span class="token comment">#0, matroska, to 'output.mka':</span>
  Stream <span class="token comment">#0:0: Audio: vorbis (oV[0][0] / 0x566F), 48000 Hz, 1 channels (FL), fltp (default)</span>
    Metadata:
      encoder         <span class="token builtin class-name">:</span> Lavc59.54.100 libvorbis
  Stream <span class="token comment">#0:1: Audio: vorbis (oV[0][0] / 0x566F), 48000 Hz, 1 channels (FR), fltp</span>
    Metadata:
      encoder         <span class="token builtin class-name">:</span> Lavc59.54.100 libvorbis
</code></pre> 
<h4><a id="font_face_size3nbspnbsp654_font_196"></a><font face="黑体" size="3">  6.5.4 单声道转双声道</font></h4> 
<p><font face="Courier New">    使用FFmpeg可以将单声道转换为双声道，即当只有中央声道或者只有mono布局时，才可以通过FFmpeg转换为stereo布局，转换方式如图所示。</font><br> <img src="https://images2.imgbox.com/82/44/XOD0ocnB_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    根据前面章节提到的stereo布局转出来的mono布局的音频文件</font>left.aac进行生成，命令行如下：</p> 
<pre><code class="prism language-bash">ffmpeg -i left.aac -ac <span class="token number">2</span> output.m4a
</code></pre> 
<p><font face="Courier New">    执行完命令行之后，将会从left.aac中，将布局为mono的音频转换为stereo布局的音频文件output.m4a，下面查看一下输入与输出文件：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, aac, from 'left.aac':</span>
  Duration: 00:00:34.13, bitrate: <span class="token number">4</span> kb/s
  Stream <span class="token comment">#0:0: Audio: aac (LC), 48000 Hz, mono, fltp, 4 kb/s</span>
Stream mapping:
  Stream <span class="token comment">#0:0 -&gt; #0:0 (aac (native) -&gt; aac (native))</span>
Press <span class="token punctuation">[</span>q<span class="token punctuation">]</span> to stop, <span class="token punctuation">[</span>?<span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token builtin class-name">help</span>
Output <span class="token comment">#0, ipod, to 'output.m4a':</span>
  Metadata:
    encoder         <span class="token builtin class-name">:</span> Lavf59.34.102
  Stream <span class="token comment">#0:0: Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 128 kb/s</span>
    Metadata:
      encoder         <span class="token builtin class-name">:</span> Lavc59.54.100 aac
<span class="token assign-left variable">size</span><span class="token operator">=</span>      17kB <span class="token assign-left variable">time</span><span class="token operator">=</span>00:00:35.02 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span>   <span class="token number">4</span>.0kbits/s <span class="token assign-left variable">speed</span><span class="token operator">=</span> 280x
</code></pre> 
<p><font face="Courier New">    从以上的输出信息中可以看到，输入的left.aac中音频为mono布局，而输出的文件output.m4a中的音频布局则为stereo。<code>除了使用ac参数，还可以使用amerge滤镜进行处理</code>，命令行如下：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i left.aac -filter_complex <span class="token string">"[0:a][0:a]amerge=inputs=2[aout]"</span> -map <span class="token string">"[aout]"</span> output.m4a
</code></pre> 
<p><font face="Courier New">    命令行执行后的效果与使用ac的效果相同。<br>     当然，<code>这样执行之后的双声道并不是真正的双声道，而是由单声道处理成的多声道，效果不会比原有的多声道效果好</code>。</font></p> 
<h4><a id="font_face_size3nbspnbsp655_font_225"></a><font face="黑体" size="3">  6.5.5 两个音频源合并双声道</font></h4> 
<p><font face="Courier New">    前面讲过将单mono处理为双声道，如果将输入的单mono转换为stereo双声道为伪双声道，则可以考虑将两个音频源合并为双声道，相对来说这样操作更容易理解一些，下面就来看一下如何将两个音频源输入为双声道，如图所示。</font><br> <img src="https://images2.imgbox.com/81/49/4j1dT2Ki_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    输入两个布局为mono的音频源，合并为一个布局为stereo双声道的音频流，输出到output文件，下面用命令行执行来举例说明：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i left.aac -i right.aac -filter_complex <span class="token string">"[0:a][1:a]amerge=inputs=2[aout]"</span> -map <span class="token string">"[aout]"</span> output.mka
</code></pre> 
<p><font face="Courier New">    命令行执行之后，会将left.aac与right.aac两个音频为mono布局的AAC合并为一个布局为stereo的音频流，输出至output.mka文件，下面就来看一下输入文件与输出文件信息：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, aac, from 'left.aac':</span>
  Duration: 00:00:34.13, bitrate: <span class="token number">4</span> kb/s
  Stream <span class="token comment">#0:0: Audio: aac (LC), 48000 Hz, mono, fltp, 4 kb/s</span>
<span class="token punctuation">[</span>aac @ 000002afbe53a640<span class="token punctuation">]</span> Estimating duration from bitrate, this may be inaccurate
Input <span class="token comment">#1, aac, from 'right.aac':</span>
  Duration: 00:00:34.13, bitrate: <span class="token number">4</span> kb/s
  Stream <span class="token comment">#1:0: Audio: aac (LC), 48000 Hz, mono, fltp, 4 kb/s</span>
Stream mapping:
  Stream <span class="token comment">#0:0 (aac) -&gt; amerge</span>
  Stream <span class="token comment">#1:0 (aac) -&gt; amerge</span>
  amerge:default -<span class="token operator">&gt;</span> Stream <span class="token comment">#0:0 (libvorbis)</span>
Press <span class="token punctuation">[</span>q<span class="token punctuation">]</span> to stop, <span class="token punctuation">[</span>?<span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token builtin class-name">help</span>
Output <span class="token comment">#0, matroska, to 'output.mka':</span>
  Metadata:
    encoder         <span class="token builtin class-name">:</span> Lavf59.34.102
  Stream <span class="token comment">#0:0: Audio: vorbis (oV[0][0] / 0x566F), 48000 Hz, stereo, fltp</span>
    Metadata:
      encoder         <span class="token builtin class-name">:</span> Lavc59.54.100 libvorbis
</code></pre> 
<p><font face="Courier New">    从以上三个Input信息可以看，<code>输入的两路mono转换为stereo了</code>，输出音频为AC3，这个可以<code>通过acodec aac指定为输出AAC编码的音频</code>。</font></p> 
<h4><a id="font_face_size3nbspnbsp656_font_254"></a><font face="黑体" size="3">  6.5.6 多个音频合并为多声道</font></h4> 
<p><font face="Courier New">    除了双声道音频，FFmpeg还可以支持多声道，通过ffmpeg-layouts即可看到声道布局有很多种，常见的多声道还有一种是5.1方式的多声道，其原理如图6-20所示。</font><br> <img src="https://images2.imgbox.com/86/40/xtByRiHq_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    图表示将6个mono布局的音频流合并为一个多声道（5.1声道）的音频流。如果希望实现这样的效果，则可以使用如下命令行：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i front_left.wav -i front_right.wav -i front_center.wav -i lfe.wav -i back_left.wav -i back_right.wav -filter_complex <span class="token string">"[0:a][1:a][2:a][3:a][4:a][5:a]amerge=inputs=6[aout]"</span> -map <span class="token string">"[aout]"</span> output.wav
</code></pre> 
<p><font face="Courier New">    命令行执行之后，将会生成一个5.1布局的音频，下面就来看一下执行后的效果：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, wav, from 'output.wav':</span>
    Metadata:
        encoder         <span class="token builtin class-name">:</span> Lavf57.71.100
    Duration: 00:00:50.03, bitrate: <span class="token number">4608</span> kb/s
        Stream <span class="token comment">#0:0: Audio: pcm_s16le ([1][0][0][0] / 0x0001), 48000 Hz, 5.1, s16, 4608 kb/s</span>
</code></pre> 
<p><font face="Courier New">    如Input信息所示，<code>多音频输入合并后生成为5.1布局的音频</code>，码率为4608kbit/s。<br>     使用FFmpeg除了可以生成以上这些布局方式之外，还可以生成很多种，可以通过<code>ffmpeg -layouts</code>方式获得布局方式信息。</font></p> 
<h3><a id="nbspnbspfont_face_size366_FFmpegfont_271"></a>  <font face="黑体" size="3">6.6 FFmpeg音频音量探测</font></h3> 
<p><font face="Courier New">    在拿到音频文件播放音频时，有时会需要根据音频的音量绘制出音频的波形，<code>而有时候会希望根据音频的音量来过滤音频文件</code>，将重点介绍音频音量与音频波形相关的滤镜操作。</font></p> 
<h4><a id="font_face_size3nbspnbsp661_font_273"></a><font face="黑体" size="3">  6.6.1 音频音量获得</font></h4> 
<p><font face="Courier New">    使用FFmpeg可以获得音频的音量分贝，以及与音频相关的一些信息，可以使用滤镜<code>volumedetect</code>获得，下面举例说明：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i output.wav -filter_complex volumedetect -c:v copy -f null /dev/null
</code></pre> 
<p><font face="Courier New">    命令行执行之后，输出信息如下：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, wav, from 'output.wav':</span>
  Duration: 00:00:46.18, bitrate: <span class="token number">1411</span> kb/s
  Stream <span class="token comment">#0:0: Audio: pcm_s16le ([1][0][0][0] / 0x0001), 44100 Hz, stereo, s16, 1411 kb/s</span>
<span class="token punctuation">[</span>Parsed_volumedetect_0 @ 0x41cf6c0<span class="token punctuation">]</span> n_samples: <span class="token number">0</span>
Stream mapping:
  Stream <span class="token comment">#0:0 (pcm_s16le) -&gt; volumedetect:default</span>
  volumedetect:default -<span class="token operator">&gt;</span> Stream <span class="token comment">#0:0 (pcm_s16le)</span>
Press <span class="token punctuation">[</span>q<span class="token punctuation">]</span> to stop, <span class="token punctuation">[</span>?<span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token builtin class-name">help</span>
Output <span class="token comment">#0, null, to '/dev/null':</span>
  Metadata:
    encoder         <span class="token builtin class-name">:</span> Lavf59.27.100
  Stream <span class="token comment">#0:0: Audio: pcm_s16le, 44100 Hz, stereo, s16, 1411 kb/s</span>
    Metadata:
      encoder         <span class="token builtin class-name">:</span> Lavc59.37.100 pcm_s16le
<span class="token assign-left variable">size</span><span class="token operator">=</span>N/A <span class="token assign-left variable">time</span><span class="token operator">=</span>00:00:46.18 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span>N/A <span class="token assign-left variable">speed</span><span class="token operator">=</span><span class="token number">2</span>.53e+03x    
video:0kB audio:7956kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: unknown
<span class="token punctuation">[</span>Parsed_volumedetect_0 @ 0x4210d40<span class="token punctuation">]</span> n_samples: <span class="token number">4073400</span>
<span class="token punctuation">[</span>Parsed_volumedetect_0 @ 0x4210d40<span class="token punctuation">]</span> mean_volume: -16.2 dB
<span class="token punctuation">[</span>Parsed_volumedetect_0 @ 0x4210d40<span class="token punctuation">]</span> max_volume: -2.8 dB
<span class="token punctuation">[</span>Parsed_volumedetect_0 @ 0x4210d40<span class="token punctuation">]</span> histogram_2db: <span class="token number">206</span>
<span class="token punctuation">[</span>Parsed_volumedetect_0 @ 0x4210d40<span class="token punctuation">]</span> histogram_3db: <span class="token number">3454</span>
<span class="token punctuation">[</span>Parsed_volumedetect_0 @ 0x4210d40<span class="token punctuation">]</span> histogram_4db: <span class="token number">5650</span>
</code></pre> 
<p><font face="Courier New">    从输出信息中可以看到，mean_volume为获得的音频的平均大小，即-16.2dB。</font></p> 
<h4><a id="font_face_size3nbspnbsp662_font_304"></a><font face="黑体" size="3">  6.6.2 绘制音频波形</font></h4> 
<p><font face="Courier New">    一些应用场景需要用到音频的波形图，随着声音分贝的增大，波形波动越强烈，使用FFmpeg可以通过showwavespic滤镜来绘制音频的波形图，下面将列举几个例子，首先看一下如何使用FFmpeg绘制简单的波形图：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i output.wav -filter_complex <span class="token string">"showwavespic=s=640x120"</span> -frames:v <span class="token number">1</span> output.png
</code></pre> 
<p><font face="Courier New">    命令行执行之后将会生成一个宽高为640×120大小的output.png图片，图片内容为音频波形，如图所示。</font><br> <img src="https://images2.imgbox.com/26/41/WZgrhqLN_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    图中所绘的为音频波形的全部信息。前边章节中看到的output.wav为5.1布局方式的多声道音频，如果希望看到每个声道的音频的波形图，则可以使用showwavepic与split_channel滤镜配合绘制出不同声道的波形图。</font></p> 
<pre><code class="prism language-bash">ffmpeg -i output.wav -filter_complex <span class="token string">"showwavespic=s=640x240:split_channels=1"</span> -frames:v <span class="token number">1</span> output.png
</code></pre> 
<p><font face="Courier New">    由于现实的波形有些多，所以生成图片的宽高会发生一些改变，可以将高度设置得大一些，这条命令执行完之后会将音频的每一个声道进行拆分，然后绘制出图像，如图所示。</font><br> <img src="https://images2.imgbox.com/66/ad/Q0ZwQa9k_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    <code>六条波形图分别表示5.1布局每一个声道的波形图</code>。</font></p> 
<h3><a id="nbspnbspfont_face_size367_FFmpegfont_318"></a>  <font face="黑体" size="3">6.7 FFmpeg为视频加字幕</font></h3> 
<p><font face="Courier New">    为视频添加字幕的方式有很多种，大概可以分为<code>将字幕编码进视频流中</code>以及<code>在封装容器中加入字幕流</code>。将字幕编码进入视频流中的方式与为<code>视频增加水印的方式基本相似</code>，而在封装容器中加入字幕流的方式则<code>需要封装容器支持加入字幕流</code>，下面就来看一下如何使用FFmpeg为视频文件增添字幕。</font></p> 
<h4><a id="font_face_size3nbspnbsp671_ASSfont_320"></a><font face="黑体" size="3">  6.7.1 ASS字幕流写入视频流</font></h4> 
<p><font face="Courier New">    使用FFmpeg可以将字幕流写入视频流，通过ASS滤镜即可，首先需要将视频流进行解码，然后将ASS字幕写入视频流，编码压缩之后再进行容器封装即可完成，字幕文件的内容格式大致如下：</font></p> 
<pre><code class="prism language-bash">Script Info<span class="token punctuation">]</span>
<span class="token punctuation">[</span>V4+ Styles<span class="token punctuation">]</span>
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding Style: *Default,微软雅黑,21,<span class="token operator">&amp;</span>H00FFFFFF,<span class="token operator">&amp;</span>H0000FFFF, <span class="token operator">&amp;</span>H2D804000,<span class="token operator">&amp;</span>H32000000,-1,0,0,0,100,100,0,0,0,2,1,2,5,5,5,134
Style: logo,微软雅黑,21,<span class="token operator">&amp;</span>H00FFFFFF,<span class="token operator">&amp;</span>HF0000000,<span class="token operator">&amp;</span>H00000000,<span class="token operator">&amp;</span>H00000000,0,0,0,0,100,100,0,0,1,2,1,2,5,5,5 ,134
<span class="token punctuation">[</span>Events<span class="token punctuation">]</span>
Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text
Dialogue: <span class="token number">0,0</span>:00:00.91,0:00:02.56,*Default,NTP,0000,0000,0000,,前情提要<span class="token punctuation">\</span>N<span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>1c<span class="token operator">&amp;</span>HFFFFFF<span class="token operator">&amp;</span><span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>3a<span class="token operator">&amp;</span>H82<span class="token operator">&amp;</span><span class="token punctuation">\</span>4c<span class="token operator">&amp;</span>H030303<span class="token operator">&amp;</span><span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>fnArial Black<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>fs20<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>b1<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>fe0<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>shad1<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>3c<span class="token operator">&amp;</span>H030303<span class="token operator">&amp;</span><span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>4c<span class="token operator">&amp;</span>H030303<span class="token operator">&amp;</span><span class="token punctuation">}</span>Previously on “the Vampire Diaries”<span class="token punctuation">..</span>.
Dialogue: <span class="token number">0,0</span>:00:02.59,0:00:05.47,*Default,NTP,0000,0000,0000,,Elena很享受你们兄弟俩对她的爱慕吧<span class="token punctuation">\</span>N<span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>1c<span class="token operator">&amp;</span>HFFFFFF<span class="token operator">&amp;</span><span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>3a<span class="token operator">&amp;</span>H82<span class="token operator">&amp;</span><span class="token punctuation">\</span>4c<span class="token operator">&amp;</span>H030303<span class="token operator">&amp;</span><span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>fnArial Black<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>fs20<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>b1<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>fe0<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>shad1<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>3c<span class="token operator">&amp;</span>H030303<span class="token operator">&amp;</span><span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>4c<span class="token operator">&amp;</span>H030303<span class="token operator">&amp;</span><span class="token punctuation">}</span>Does Elena enjoy having both of you worship at her altar?
Dialogue: <span class="token number">0,0</span>:00:05.50,0:00:06.66,*Default,NTP,0000,0000,0000,,我听说过你<span class="token punctuation">\</span>N<span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>1c<span class="token operator">&amp;</span>HFFFFFF<span class="token operator">&amp;</span><span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>3a<span class="token operator">&amp;</span>H82<span class="token operator">&amp;</span><span class="token punctuation">\</span>4c<span class="token operator">&amp;</span>H030303<span class="token operator">&amp;</span><span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>fnArial Black<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>fs20<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>b1<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>fe0<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>shad1<span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>3c<span class="token operator">&amp;</span>H030303<span class="token operator">&amp;</span><span class="token punctuation">}</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">\</span>4c<span class="token operator">&amp;</span>H030303<span class="token operator">&amp;</span><span class="token punctuation">}</span>I've heard about you<span class="token punctuation">..</span>.
</code></pre> 
<p><font face="Courier New">    打开的文件中的内容为字幕文件的片段，内容格式为<code>ASS字幕格式</code>。下面将字幕写入视频流中：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -vf <span class="token assign-left variable">ass</span><span class="token operator">=</span>t1.ass -f mp4 output.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行之后即可根据<code>input.mp4的信息增加ASS字幕</code>，将字幕写入视频流中生成output.mp4，下面可以看一下输入与输出文件的情况：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, mov,mp4,m4a,3gp,3g2,mj2, from 'input.mp4':</span>
  Stream <span class="token comment">#0:0[0x1](und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709, progressive), 1920x1080 [SAR 1:1 DAR 16:9], 2497 kb/s, 30 fps, 30 tbr, 15360 tbn (default)</span>
  Stream <span class="token comment">#0:1[0x2](und): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 159 kb/s (default)</span>
Output <span class="token comment">#0, mp4, to 'output.mp4':</span>
  Stream <span class="token comment">#0:0(und): Video: h264 (avc1 / 0x31637661), yuv420p(tv, bt709, progressive), 1920x1080 [SAR 1:1 DAR 16:9], q=2-31, 30 fps, 15360 tbn (default)</span>
  Stream <span class="token comment">#0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 128 kb/s (default)</span>
</code></pre> 
<p><font face="Courier New">    从Input信息中可以看到，<code>输入与输出的封装容器格式基本相同，均为一个视频流和一个音频流，并未包含字幕流，因为字幕已经通过ASS容器将文字写入视频流中</code>。播放效果如图所示。</font><br> <img src="https://images2.imgbox.com/50/36/HK0KQG9J_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    从图所示的播放效果可以看到，字幕流已经写入视频文件中，并且在播放时可以看到字幕。</font></p> 
<h4><a id="font_face_size3nbspnbsp672_ASSfont_349"></a><font face="黑体" size="3">  6.7.2 ASS字幕流写入封装容器</font></h4> 
<p><font face="Courier New">    下面看一下如何利用·FFmpeg将ASS字幕流写入MKV封装容器中·，并以字幕流的形式存在：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -i t1.ass -acodec copy -vcodec copy -scodec copy output.mkv
</code></pre> 
<p><font face="Courier New">    命令行执行之后，会将input.mp4中的音频流、视频流、t1.ass中的字幕流在不改变编码的情况下封装入output.mkv文件中，而output.mkv文件将会包含三个流，<code>分别为视频流、音频流以及字幕流</code>；而在input.mp4中或者输入的视频文件中原本同样带有字幕流，并希望使用t1.ass字幕流时，可以通过map功能将对应的字幕流指定封装入output.mkv，例如：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -i t1.ass -map <span class="token number">0</span>:0 -map <span class="token number">0</span>:1 -map <span class="token number">1</span>:0 -acodec copy -vcodec copy -scodec copy output.mkv
</code></pre> 
<h3><a id="nbspnbspfont_face_size368_FFmpegfont_358"></a>  <font face="黑体" size="3">6.8 FFmpeg视频抠图合并</font></h3> 
<p><font face="Courier New">    <code>FFmpeg还可以进行视频抠图与背景视频合并的操作——chromakey操作</code>，下面就来介绍chromakey操作。</font></p> 
<table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>color</td><td>颜色</td><td>设置chromakey颜色值 默认为黑色</td></tr><tr><td>similarity</td><td>浮点</td><td>设置chromakey相似值</td></tr><tr><td>blend</td><td>浮点</td><td>设置chromakey融合值</td></tr><tr><td>yuv</td><td>布尔</td><td>yuv替代rgb 默认为false</td></tr></tbody></table> 
<p><font face="Courier New">    参数介绍完毕，接下来再举一个例子实战体验一下。如果当前有两个视频：一个为input.mp4，另一个为绿色背景的视频input_green.mp4。<br>     背景颜色可以根据ffmpeg-colors查询颜色支持，这个背景颜色为绿色，那么可以设置透明色部分为绿色，下面使用chromakey滤镜将绿色背景中的人物抠出来，然后贴到以input.mp4为背景的视频中：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -i input_green.mp4 -filter_complex <span class="token string">"[1:v]chromakey=Green:0.1:0.2[ckout];[0:v][ckout]overlay[out]"</span> -map <span class="token string">"[out]"</span> output.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行之后，<code>会设置chrom-akey的背景色为绿色，设置标签为ckout</code>，然后将ckout铺在以input.mp4的视频为背景的画布上，最后输出output.mp4，输出效果如图所示。</font><br> <img src="https://images2.imgbox.com/e5/e6/HNmvdKBG_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    从图中可以看到，人物已经被铺在了视频中，两个图层已经合并。chromakey效果已经达到。。</font><br>     <strong>注意：</strong><br>     FFmpeg中除了有chromakey滤镜之外，还有一个colorkey参数，<code>chromakey滤镜主要处理YUV数据，所以一般来说做绿幕处理更有优势</code>；<code>而colorkey处理纯色均可以，因为colorkey处理主要以RGB数据为主</code>。</p> 
<h3><a id="nbspnbspfont_face_size369_FFmpeg3Dfont_377"></a>  <font face="黑体" size="3">6.9 FFmpeg3D视频处理</font></h3> 
<p><font face="Courier New">    使用FFmpeg可以进行相关的处理，介绍一下如何<code>通过stereo3d滤镜方式实现3D效果</code>。</font></p> 
<h4><a id="font_face_size3nbspnbsp691_stereo3d3Dfont_379"></a><font face="黑体" size="3">  6.9.1 stereo3d处理3D视频</font></h4> 
<p><font face="Courier New">    查询FFmpeg滤镜stereo3d参数。接下来举个例子验证一下，首先获得一个左右眼的视频，然后将其转变为红蓝眼镜观看的视频。</font></p> 
<h4><a id="font_face_size3nbspnbsp692_3Dfont_381"></a><font face="黑体" size="3">  6.9.2 3D图像转换举例</font></h4> 
<p><font face="Courier New">    3D视频除了用VR眼镜观看之外，还有一种场景是在电影院裸眼用黄蓝眼镜观看，这时候看这样的视频同样是左右效果而不是3D效果，<code>可以通过stereo3d滤镜转换之后使用黄蓝眼镜观看</code>：</font></p> 
<pre><code class="prism language-bash">ffplay -vf <span class="token string">"stereo3d=sbsl:aybd"</span> input.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行后，会将原片的左右排列效果合并为黄蓝合并排列效果，视频播放起来将会更有立体感；如果使用红蓝眼镜观看视频，可以使用红蓝输出参数：</font></p> 
<pre><code class="prism language-bash">ffplay -vf <span class="token string">"stereo3d=sbsl:arbg"</span> input.mp4
</code></pre> 
<h3><a id="nbspnbspfont_face_size3610_FFmpegfont_390"></a>  <font face="黑体" size="3">6.10 FFmpeg定时视频截图</font></h3> 
<p><font face="Courier New">    使用FFmpeg截图有很多种，<code>常见的为使用vframe参数与fps滤镜</code>，下面重点介绍vframe参数与fps滤镜两种方法的使用例子。</font></p> 
<h4><a id="font_face_size3nbspnbsp6101_vframefont_392"></a><font face="黑体" size="3">  6.10.1 vframe参数截取一张图片</font></h4> 
<p><font face="Courier New">    在获取指定时间位置的视频图像缩略图时，可使用vframe获得，通过FFmpeg参数ss与vframe即可获得，下面来看一下例子：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.flv -ss 00:00:7.435 -vframes <span class="token number">1</span> out.png
</code></pre> 
<p><font face="Courier New">    命令行执行之后，FFmpeg会定位到input.flv的第7秒位置，获得对应的视频帧，然后将图像解码出来编码成RGB24的图像并封装成PNG图像，过程如下：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, flv, from 'input.flv':</span>
  Stream <span class="token comment">#0:0: Video: h264 (High), yuv420p(progressive), 1280x720, 2500 kb/s, 30 fps, 30 tbr, 1k tbn</span>
  Stream <span class="token comment">#0:1: Audio: aac (LC), 44100 Hz, stereo, fltp, 160 kb/s</span>
Stream mapping:
  Stream <span class="token comment">#0:0 -&gt; #0:0 (h264 (native) -&gt; png (native))</span>
Output <span class="token comment">#0, image2, to 'out.png':</span>
  Stream <span class="token comment">#0:0: Video: png, rgb24(pc, gbr/unknown/unknown, progressive), 1280x720, q=2-31, 200 kb/s, 30 fps, 30 tbn</span>
<span class="token punctuation">[</span>image2 @ 000001505cd0d240<span class="token punctuation">]</span> The specified filename <span class="token string">'out.png'</span> does not contain an image sequence pattern or a pattern is invalid.
<span class="token punctuation">[</span>image2 @ 000001505cd0d240<span class="token punctuation">]</span> Use a pattern such as %03d <span class="token keyword">for</span> an image sequence or use the -update option <span class="token punctuation">(</span>with -frames:v <span class="token number">1</span> <span class="token keyword">if</span> needed<span class="token punctuation">)</span> to <span class="token function">write</span> a single image.
<span class="token assign-left variable">frame</span><span class="token operator">=</span>    <span class="token number">1</span> <span class="token assign-left variable">fps</span><span class="token operator">=</span><span class="token number">0.0</span> <span class="token assign-left variable">q</span><span class="token operator">=</span>-0.0 <span class="token assign-left variable">Lsize</span><span class="token operator">=</span>N/A <span class="token assign-left variable">time</span><span class="token operator">=</span>00:00:00.00 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span>N/A <span class="token assign-left variable">dup</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">drop</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">speed</span><span class="token operator">=</span>   0x
</code></pre> 
<h4><a id="font_face_size3nbspnbsp6102_fpsfont_410"></a><font face="黑体" size="3">  6.10.2 fps滤镜定时获得图片</font></h4> 
<p><font face="Courier New">    下面来看一下FFmpeg的fps滤镜是如何在间隔时间获得图片的：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.flv -vf <span class="token assign-left variable">fps</span><span class="token operator">=</span><span class="token number">1</span> out%d.png
</code></pre> 
<p><font face="Courier New">    命令行执行之后，<code>将会每隔1秒钟生成一张PNG图片</code>。</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.flv -vf <span class="token assign-left variable">fps</span><span class="token operator">=</span><span class="token number">1</span>/60 img%03d.jpg
</code></pre> 
<p><font face="Courier New">    命令行执行之后，<code>将会每隔1分钟生成一张JPEG图片</code>。</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.flv -vf <span class="token assign-left variable">fps</span><span class="token operator">=</span><span class="token number">1</span>/600 thumb%04d.bmp
</code></pre> 
<p><font face="Courier New">    命令行执行之后，<code>将会每隔10分钟生成一张BMP图片</code>。<br>     以上三种方式均为按照时间截取图片，那么如果希望按照关键帧截取图片，可以使用select来截取：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.flv -vf <span class="token string">"select='eq(pict_type,PICT_TYPE_I)'"</span> -vsync vfr thumb%04d.png
</code></pre> 
<p><font face="Courier New">    命令行执行之后，<code>FFmpeg将会判断图像类型是否为I帧，如果是I帧则会生成一张PNG图像</code>。</font></p> 
<h3><a id="nbspnbspfont_face_size3611_FFmpegfont_429"></a>  <font face="黑体" size="3">6.11 FFmpeg生成测试元数据</font></h3> 
<p><font face="Courier New">    FFmpeg不但可以处理音视频文件，还可以生成音视频文件，可以通过lavfi设备虚拟音视频源数据，下面就来简单介绍几个常用的案例。</font></p> 
<h4><a id="font_face_size3nbspnbsp6111_FFmpegfont_431"></a><font face="黑体" size="3">  6.11.1 FFmpeg生成音频测试流</font></h4> 
<p><font face="Courier New">    在FFmpeg中，可以通过lavfi虚拟音频源的abuffer、aevalsrc、anullsrc、flite、anoisesrc、sine滤镜生成音频流，下面就来举例说明：</font></p> 
<pre><code class="prism language-bash">ffmpeg -re -f lavfi -i <span class="token assign-left variable">abuffer</span><span class="token operator">=</span>sample_rate<span class="token operator">=</span><span class="token number">44100</span>:sample_fmt<span class="token operator">=</span>s16p:channel_layout<span class="token operator">=</span>stereo -acodec aac -y output.aac
</code></pre> 
<p><font face="Courier New">    命令行执行之后，<code>FFmpeg会根据lavfi设备输入的abuffer中定义的采样率、格式，以及声道布局，通过AAC编码</code>，然后生成AAC音频文件；下面再列举一个例子：</font></p> 
<pre><code class="prism language-bash">ffmpeg -re -f lavfi <span class="token string">"aevalsrc=sin(420*2*PI*t)|cos(430*2*PI*t):c=FC|BC"</span> -acodec aac output.aac
</code></pre> 
<p><font face="Courier New">    命令行执行之后，<code>音频为使用aevalsrc生成的双通道音频，输出为output.aac</code>，下面就来使用前边提到过的波形查看方式查看一下音频波形，效果如图所示。</font><br> <img src="https://images2.imgbox.com/33/34/aUun3vpU_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    以上举例为<code>abuffer与aevalsrc两种输入举例</code>，还可以以类似的方式<code>使用anullsrc、flite、anoisesrc、sine来虚拟输入的音频设备生成音频流</code>。以便使用FFmpeg测试音频流处理。</font></p> 
<h4><a id="font_face_size3nbspnbsp6112_FFmpegfont_443"></a><font face="黑体" size="3">  6.11.2 FFmpeg生成视频测试流</font></h4> 
<p><font face="Courier New">    在使用FFmpeg测试流媒体时，如果没有输入文件，则可以通过FFmpeg虚拟设备虚拟出来一个输入视频流，<code>可以通过FFmpeg模拟多种视频源：allrgb、allyuv、color、haldclutsrc、nullsrc、rgbtestsrc、smptebars、smptehdbars、testsrc、testsrc2、yuvtestsrc</code>；下面就对常见的视频源进行举例测试。</font></p> 
<pre><code class="prism language-bash">ffmpeg -re -f lavfi -i <span class="token assign-left variable">testsrc</span><span class="token operator">=</span>duration<span class="token operator">=</span><span class="token number">5.3</span>:size<span class="token operator">=</span>qcif:rate<span class="token operator">=</span><span class="token number">25</span> -vcodec libx264 -r:v <span class="token number">25</span> output.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行之后，FFmpeg会根据<code>testsrc生成长度为5.3秒、图像大小为QCIF分辨率、帧率为25fps的视频图像数据，并编码成为H.264，然后输出output.mp4</code>视频文件，下面就来看一下生成的MP4文件，如图所示。<br> <img src="https://images2.imgbox.com/fd/21/A8h0APsg_o.png" alt="在这里插入图片描述"></font></p> 
<pre><code class="prism language-bash">ffmpeg -re -f lavfi -i <span class="token assign-left variable">testsrc2</span><span class="token operator">=</span>duration<span class="token operator">=</span><span class="token number">5.3</span>:size<span class="token operator">=</span>qcif:rate<span class="token operator">=</span><span class="token number">25</span> -vcodec libx264 -r:v <span class="token number">25</span> output.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行之后，会<code>根据testsrc2生成一个视频图像内容，其他参数与testsrc相同</code>。下面就来看一下命令行执行之后生成的output.mp4文件内容，如图所示。</font><br> <img src="https://images2.imgbox.com/f0/c1/lBS2Cc3H_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">ffmpeg -re -f lavfi -i <span class="token assign-left variable">color</span><span class="token operator">=</span>c<span class="token operator">=</span>red@0.2:s<span class="token operator">=</span>qcif:r<span class="token operator">=</span><span class="token number">25</span> -vcodec libx264 -r:v <span class="token number">25</span> output.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行之后，<code>会使用color作为视频源，图像内容为纯红色，编码为H.264</code>，编码出来后生成的output.mp4视频内容如图所示。</font><br> <img src="https://images2.imgbox.com/3f/07/EvUw0Hpa_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">ffmpeg -re -f lavfi -i <span class="token string">"nullsrc=s=256x256, geq=random(1)*255:128:128"</span> -vcodec libx264 -r:v <span class="token number">25</span> output.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行之后，会使用<code>nullsrc作为视频源，宽高为256×256，数据为随机雪花样</code>。下面看一下命令行执行之后的效果图，如图所示。</font><br> <img src="https://images2.imgbox.com/5e/a7/sDtCYmnB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="nbspnbspfont_face_size3612_FFmpegfont_465"></a>  <font face="黑体" size="3">6.12 FFmpeg对音视频倍速处理</font></h3> 
<p><font face="Courier New">    在音视频处理中，常见的处理还包括音视频的倍速处理，如2倍速播放、4倍速播放，常见的处理方式包含跳帧播放与不跳帧播放，两种处理方式FFmpeg均可支持，跳帧处理方式的用户体验稍差一些，<code>下面就来了解两个滤镜：atempo与setpts</code>。</font></p> 
<h4><a id="font_face_size3nbspnbsp6121_atempofont_467"></a><font face="黑体" size="3">  6.12.1 atempo音频倍速处理</font></h4> 
<p><font face="Courier New">    在FFmpeg的音频处理滤镜中，atempo是用来处理倍速的滤镜，能够控制音频播放速度的快与慢，这个滤镜只有一个参数：tempo，将这个参数的值设置为浮点型，取值范围从0.5到2，0.5则是原来速度的一半，调整为2则是原来速度的2倍速。下面列举两个测试例子。<br>     <code>（1）半速处理</code></font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.wav -filter_complex <span class="token string">"atempo=tempo=0.5"</span> -acodec aac output.aac
</code></pre> 
<p><font face="Courier New">    命令行执行之后，FFmpeg将会输出如下执行信息：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, aac, from 'input_audio.aac':</span>
    Duration: 00:00:50.82, bitrate: <span class="token number">127</span> kb/s
        Stream <span class="token comment">#0:0: Audio: aac (LC), 48000 Hz, stereo, fltp, 127 kb/s</span>
Stream mapping:
    Stream <span class="token comment">#0:0 (aac) -&gt; atempo</span>
    atempo -<span class="token operator">&gt;</span> Stream <span class="token comment">#0:0 (aac)</span>
Press <span class="token punctuation">[</span>q<span class="token punctuation">]</span> to stop, <span class="token punctuation">[</span>?<span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token builtin class-name">help</span>
Output <span class="token comment">#0, adts, to 'output.aac':</span>
    Metadata:
        encoder         <span class="token builtin class-name">:</span> Lavf57.71.100
         Stream <span class="token comment">#0:0: Audio: aac (LC), 48000 Hz, stereo, fltp, 128 kb/s</span>
        Metadata:
            encoder         <span class="token builtin class-name">:</span> Lavc57.89.100 aac
<span class="token assign-left variable">size</span><span class="token operator">=</span>    1600kB <span class="token assign-left variable">time</span><span class="token operator">=</span>00:01:39.94 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span> <span class="token number">131</span>.1kbits/s <span class="token assign-left variable">speed</span><span class="token operator">=</span><span class="token number">31.8</span>
</code></pre> 
<p><font face="Courier New">    <code>从命令行执行后的内容中可以看到，该命令行执行总时长消耗为输入的duration的2倍</code>，处理过后的output.aac可以通过播放器播放，效果是源音频速度的一半。<br>     <code>（2）2倍速处理</code></font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.wav -filter_complex <span class="token string">"atempo=tempo=2.0"</span> -acodec aac output.aac
</code></pre> 
<p><font face="Courier New">    命令行执行之后，FFmpeg将会输出如下执行信息：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, aac, from 'input_audio.aac':</span>
Input <span class="token comment">#0, aac, from 'input_audio.aac':</span>
    Duration: 00:00:50.82, bitrate: <span class="token number">127</span> kb/s
        Stream <span class="token comment">#0:0: Audio: aac (LC), 48000 Hz, stereo, fltp, 127 kb/s</span>
Stream mapping:
    Stream <span class="token comment">#0:0 (aac) -&gt; atempo</span>
    atempo -<span class="token operator">&gt;</span> Stream <span class="token comment">#0:0 (aac)</span>
Press <span class="token punctuation">[</span>q<span class="token punctuation">]</span> to stop, <span class="token punctuation">[</span>?<span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token builtin class-name">help</span>
Output <span class="token comment">#0, adts, to 'output.aac':</span>
    Metadata:
        encoder         <span class="token builtin class-name">:</span> Lavf57.71.100
        Stream <span class="token comment">#0:0: Audio: aac (LC), 48000 Hz, stereo, fltp, 128 kb/s</span>
        Metadata:
            encoder         <span class="token builtin class-name">:</span> Lavc57.89.100 aac
<span class="token assign-left variable">size</span><span class="token operator">=</span>     400kB <span class="token assign-left variable">time</span><span class="token operator">=</span>00:00:24.98 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span> <span class="token number">131</span>.2kbits/s <span class="token assign-left variable">speed</span><span class="token operator">=</span><span class="token number">30</span>.4x
</code></pre> 
<p><font face="Courier New">    从以上输出的内容中可以看到，<code>该命令执行总时长消耗为输入的duration的二分之一</code>，处理过后的output.aac可以通过播放器播放，效果会比源音频快一倍。</font></p> 
<h4><a id="font_face_size3nbspnbsp6122_setptsfont_514"></a><font face="黑体" size="3">  6.12.2 setpts视频倍速处理</font></h4> 
<p><font face="Courier New">    在FFmpeg的视频处理滤镜中，通过setpts能够控制视频速度的快与慢，这个滤镜只有一个参数：expr，这个参数可用来描述视频的每一帧的时间戳，下面就来看一下setpts的可用的常见值，具体见表。</font></p> 
<table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>FRAME_RATE</td><td>根据帧率设置帧率值 只用于固定帧率</td></tr><tr><td>PTS</td><td>输入的pts时间戳</td></tr><tr><td>RICTIME</td><td>使用RTC的时间作为时间戳</td></tr><tr><td>TB</td><td>输入的时间戳的实践基</td></tr></tbody></table> 
<p><font face="Courier New">    下面对如何使用PTS值来控制播放速度的应用列举两个例子。<br>     <code>（1）半速处理</code></font></p> 
<pre><code class="prism language-bash">ffmpeg -re -i input.mp4 -filter_complex <span class="token string">"setpts=PTS*2"</span> output.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行之后FFmpeg将会输出如下信息：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, mov,mp4,m4a,3gp,3g2,mj2, from 'input_video.mp4':</span>
    Metadata:
        major_brand     <span class="token builtin class-name">:</span> isom
        minor_version   <span class="token builtin class-name">:</span> <span class="token number">512</span>
        compatible_brands: isomiso2avc1mp41
        encoder         <span class="token builtin class-name">:</span> Lavf57.66.102
    Duration: 00:00:50.00, start: <span class="token number">0.080000</span>, bitrate: <span class="token number">2486</span> kb/s
        Stream <span class="token comment">#0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 1280x714 [SAR 1:1 DAR 640:357], 2484 kb/s, 25 fps, 25 tbr, 25k tbn, 50 tbc (default)</span>
</code></pre> 
<p><font face="Courier New">    如上述输出内容所示，输出的视频output.mp4的时长刚好是input.mp4的duration的2倍，因为是半速的视频，所以处理时间长度是原视频的2倍，而使用播放器播放output.mp4时将会看到其速度比原视频慢一半的运动效果。<br>     <code>（2）2倍速处理</code></font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -filter_complex <span class="token string">"setpts=PTS/2"</span> output.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行之后FFmpeg将会输出如下信息：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, mov,mp4,m4a,3gp,3g2,mj2, from 'input_video.mp4':</span>
    Metadata:
        major_brand     <span class="token builtin class-name">:</span> isom
 major_brand     <span class="token builtin class-name">:</span> isom
        minor_version   <span class="token builtin class-name">:</span> <span class="token number">512</span>
        compatible_brands: isomiso2avc1mp41
        encoder         <span class="token builtin class-name">:</span> Lavf57.66.102
    Duration: 00:00:50.00, start: <span class="token number">0.080000</span>, bitrate: <span class="token number">2486</span> kb/s
        Stream <span class="token comment">#0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 1280x714 [SAR 1:1 DAR 640:357], 2484 kb/s, 25 fps, 25 tbr, 25k tbn, 50 tbc (default)</span>
        Metadata:
            handler_name    <span class="token builtin class-name">:</span> VideoHandler
</code></pre> 
<p><font face="Courier New">    如以上输出内容所示，<em>输出的视频output.mp4的时长刚好是input.mp4的duration的一半，因为是2倍速的视频，所以处理时间长度是原视频的一半</em>，使用播放器播放output.mp4时将会看到速度比原视频快一倍的运动效果。</font></p> 
<h3><a id="nbspnbspfont_face_size3613_font_559"></a>  <font face="黑体" size="3">6.13 小结</font></h3> 
<p><font face="Courier New">    FFmpeg功能强大的主要原因是其包含了<code>滤镜处理avfilter</code>，<code>FFmpeg的avfilter能够实现的音频、视频、字幕渲染效果数不胜数</code>。</font></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/66c1dffd31d3903fbceda04dfa5839c3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">fastadmin隐藏table操作栏拖动排序按钮</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f1d4028d22508245f38271ec67e5f946/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">docker部署Elasticsearch7.17集群和kibana</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>