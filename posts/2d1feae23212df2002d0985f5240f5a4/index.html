<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python 3实现k-邻近算法以及 iris 数据集分类应用 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python 3实现k-邻近算法以及 iris 数据集分类应用" />
<meta property="og:description" content="前言 这个周基本在琢磨这个算法以及自己利用Python3 实现自主编程实现该算法。持续时间比较长，主要是Pyhton可能还不是很熟练，走了很多路，基本是一边写一边学。不过，总算是基本搞出来了。不多说，进入正题。
1. K-邻近算法 1.1 基本原理 k近邻法(k-nearest neighbor, k-NN)是1967年由Cover T和Hart P提出的一种基本分类与回归方法。它的工作原理是：存
在一个样本数据集合，也称作为训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一个数据与所属分
类的对应关系。输入没有标签的新数据后，将新的数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本
最相似数据(最近邻)的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，
通常k是不大于20的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。
1.2 一个例子 先来看一个图： 在这个图里面，我们可以看到有第三种颜色标记的标签，蓝色正方形，红色三角形以及一个未知类型的绿色原点。那么如何判断这
个绿色点是属于蓝色家族的还是红色家族的呢？
邻近的思想就是计算这个绿色的点分别到它附近的点的距离，距离近就判定属于这个类型，那么K-邻近就是让待分类的这个点与所
有的已经分类点的距离，然后选取K个点，统计待分类的这个绿色点属于哪个类别的数量比较多，就最终判定这个点属于哪一个。
再回到图，首先是K=3，可以看到实线里面有两个红点，一个蓝点，那么判定这个绿家伙属于红色的三角形类型。接着，选取了近
距离绿色点最近的5个点，这时，会发现，蓝色系占得更多，所以，判定这个绿家伙是属于蓝色正方形的类型。
从这个例子可以看出来，K-邻近的几个基本关键点有：
点之间的距离计算
欧式距离： d12=∑i=1n(x1i−x2i)−−−−−−−−−−−√ 曼哈顿距离：
两个向量 a(x11,xx12,⋯,x1n) 与 b(x21,xx22,⋯,x2n) 的曼哈顿距离为： d12=∑k=1n|x1k−x2k| 其他 参考http://www.cnblogs.com/xbinworld/archive/2012/09/24/2700572.html
里面有着更加详细的关于距离的介绍。
距离排序 在这个计算的过程中，需要将最终的计算进行一个排序的。为下一步操作做好准备。
K的选择 很明显，对于这算法，K的选取决定了整个算法分类预测的准确性，可以说是其核心参数。从上面的例子也可以看出来，K=3和K=5得到的决然不同的结果的。
1.3 算法步骤 （1）初始化距离 （2）计算待分类样本和每个训练集的距离 （3）排序 （4）选取K个最邻近的数据 （5）计算K个训练样本的每类标签出现的概率 （6）将待分类样本归为出现概率最大的标签，分类结束。
2. Python实现K-邻近算法 2.1 K-邻近函数 def mykNN(testData, trainData, label, K): # testData 待分类的数据集 # trainData 已经分类好的数据集 # label trainData数据集里面的分类标签 # K是knn算法中的K # testData=[101,20] # testData=np." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2d1feae23212df2002d0985f5240f5a4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-08-31T10:41:32+08:00" />
<meta property="article:modified_time" content="2017-08-31T10:41:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python 3实现k-邻近算法以及 iris 数据集分类应用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="前言">前言</h2> 
<p>这个周基本在琢磨这个算法以及自己利用Python3 实现自主编程实现该算法。持续时间比较长，主要是Pyhton可能还不是很熟练，走了很多路，基本是一边写一边学。不过，总算是基本搞出来了。不多说，进入正题。</p> 
<h2 id="1-k-邻近算法">1. K-邻近算法</h2> 
<h3 id="11-基本原理">1.1 基本原理</h3> 
<p>k近邻法(k-nearest neighbor, k-NN)是1967年由Cover T和Hart P提出的一种基本分类与回归方法。它的工作原理是：存</p> 
<p>在一个样本数据集合，也称作为训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一个数据与所属分</p> 
<p>类的对应关系。输入没有标签的新数据后，将新的数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本</p> 
<p>最相似数据(最近邻)的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，</p> 
<p>通常k是不大于20的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。</p> 
<h3 id="12-一个例子">1.2 一个例子</h3> 
<p>先来看一个图： <br> <img src="https://images2.imgbox.com/f9/d4/eygOGwfT_o.png" alt="这里写图片描述" title=""></p> 
<p>在这个图里面，我们可以看到有第三种颜色标记的标签，蓝色正方形，红色三角形以及一个未知类型的绿色原点。那么如何判断这</p> 
<p>个绿色点是属于蓝色家族的还是红色家族的呢？</p> 
<p>邻近的思想就是计算这个绿色的点分别到它附近的点的距离，距离近就判定属于这个类型，那么K-邻近就是让待分类的这个点与所</p> 
<p>有的已经分类点的距离，然后选取K个点，统计待分类的这个绿色点属于哪个类别的数量比较多，就最终判定这个点属于哪一个。</p> 
<p>再回到图，首先是K=3，可以看到实线里面有两个红点，一个蓝点，那么判定这个绿家伙属于红色的三角形类型。接着，选取了近</p> 
<p>距离绿色点最近的5个点，这时，会发现，蓝色系占得更多，所以，判定这个绿家伙是属于蓝色正方形的类型。</p> 
<p>从这个例子可以看出来，K-邻近的几个基本关键点有：</p> 
<ol><li><p>点之间的距离计算</p> 
  <ol><li>欧式距离： <br> <span class="MathJax_Preview"></span> 
    <div class="MathJax_Display" style="text-align: center;"> 
     <span class="MathJax" id="MathJax-Element-1-Frame"> 
       
       <span class="math" id="MathJax-Span-1" style="width: 12.216em; display: inline-block;"><span style="display: inline-block; position: relative; width: 9.763em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(0.909em 1000em 4.216em -0.424em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2"><span class="msubsup" id="MathJax-Span-3"><span style="display: inline-block; position: relative; width: 1.336em; height: 0px;"><span style="position: absolute; clip: rect(1.709em 1000em 2.723em -0.424em); top: -2.557em; left: 0.003em;"><span class="mi" id="MathJax-Span-4" style="font-family: MathJax_Math-italic;">d<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; height: 2.563em;"></span></span><span style="position: absolute; top: -2.344em; left: 0.536em;"><span class="texatom" id="MathJax-Span-5"><span class="mrow" id="MathJax-Span-6"><span class="mn" id="MathJax-Span-7" style="font-size: 70.7%; font-family: MathJax_Main;">12</span></span></span><span style="display: inline-block; width: 0px; height: 2.509em;"></span></span></span></span><span class="mo" id="MathJax-Span-8" style="font-family: MathJax_Main; padding-left: 0.269em;">=</span><span class="msqrt" id="MathJax-Span-9" style="padding-left: 0.269em;"><span style="display: inline-block; position: relative; width: 7.096em; height: 0px;"><span style="position: absolute; clip: rect(1.016em 1000em 4.056em -0.424em); top: -2.717em; left: 1.016em;"><span class="mrow" id="MathJax-Span-10"><span class="munderover" id="MathJax-Span-11"><span style="display: inline-block; position: relative; width: 1.496em; height: 0px;"><span style="position: absolute; clip: rect(2.669em 1000em 4.376em -0.424em); top: -3.784em; left: 0.003em;"><span class="mo" id="MathJax-Span-12" style="font-family: MathJax_Size2; vertical-align: 0.003em;">∑</span><span style="display: inline-block; width: 0px; height: 3.789em;"></span></span><span style="position: absolute; clip: rect(1.869em 1000em 2.776em -0.477em); top: -1.437em; left: 0.163em;"><span class="texatom" id="MathJax-Span-13"><span class="mrow" id="MathJax-Span-14"><span class="mi" id="MathJax-Span-15" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span><span class="mo" id="MathJax-Span-16" style="font-size: 70.7%; font-family: MathJax_Main;">=</span><span class="mn" id="MathJax-Span-17" style="font-size: 70.7%; font-family: MathJax_Main;">1</span></span></span><span style="display: inline-block; width: 0px; height: 2.509em;"></span></span><span style="position: absolute; clip: rect(1.869em 1000em 2.616em -0.477em); top: -3.624em; left: 0.536em;"><span class="mi" id="MathJax-Span-18" style="font-size: 70.7%; font-family: MathJax_Math-italic;">n</span><span style="display: inline-block; width: 0px; height: 2.456em;"></span></span></span></span><span class="mo" id="MathJax-Span-19" style="font-family: MathJax_Main;">(</span><span class="msubsup" id="MathJax-Span-20"><span style="display: inline-block; position: relative; width: 1.283em; height: 0px;"><span style="position: absolute; clip: rect(1.976em 1000em 2.723em -0.424em); top: -2.557em; left: 0.003em;"><span class="mi" id="MathJax-Span-21" style="font-family: MathJax_Math-italic;">x</span><span style="display: inline-block; width: 0px; height: 2.563em;"></span></span><span style="position: absolute; top: -2.344em; left: 0.589em;"><span class="texatom" id="MathJax-Span-22"><span class="mrow" id="MathJax-Span-23"><span class="mn" id="MathJax-Span-24" style="font-size: 70.7%; font-family: MathJax_Main;">1</span><span class="mi" id="MathJax-Span-25" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span></span></span><span style="display: inline-block; width: 0px; height: 2.509em;"></span></span></span></span><span class="mo" id="MathJax-Span-26" style="font-family: MathJax_Main; padding-left: 0.216em;">−</span><span class="msubsup" id="MathJax-Span-27" style="padding-left: 0.216em;"><span style="display: inline-block; position: relative; width: 1.283em; height: 0px;"><span style="position: absolute; clip: rect(1.976em 1000em 2.723em -0.424em); top: -2.557em; left: 0.003em;"><span class="mi" id="MathJax-Span-28" style="font-family: MathJax_Math-italic;">x</span><span style="display: inline-block; width: 0px; height: 2.563em;"></span></span><span style="position: absolute; top: -2.344em; left: 0.589em;"><span class="texatom" id="MathJax-Span-29"><span class="mrow" id="MathJax-Span-30"><span class="mn" id="MathJax-Span-31" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span class="mi" id="MathJax-Span-32" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span></span></span><span style="display: inline-block; width: 0px; height: 2.509em;"></span></span></span></span><span class="mo" id="MathJax-Span-33" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span><span style="position: absolute; clip: rect(3.576em 1000em 4.056em -0.477em); top: -5.331em; left: 1.016em;"><span style="display: inline-block; position: relative; width: 6.083em; height: 0px;"><span style="position: absolute; font-family: MathJax_Main; top: -3.997em; left: -0.104em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; font-family: MathJax_Main; top: -3.997em; left: 5.389em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.997em; left: 0.429em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.997em; left: 1.016em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.997em; left: 1.549em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.997em; left: 2.083em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.997em; left: 2.669em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.997em; left: 3.203em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.997em; left: 3.736em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.997em; left: 4.323em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.997em; left: 4.856em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; clip: rect(2.083em 1000em 5.389em -0.371em); top: -3.891em; left: 0.003em;"><span style="font-family: MathJax_Size4;">√</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 3.87em; vertical-align: -1.73em;"></span></span> 
      </span> 
    </div><script type="math/tex; mode=display" id="MathJax-Element-1">d_{12}=\sqrt{ \sum_{i=1}^n(x_{1i}-x_{2i})}</script></li><li><p>曼哈顿距离：</p> <p>两个向量<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-2-Frame"> 
       
       <span class="math" id="MathJax-Span-34" style="width: 10.936em; display: inline-block;"><span style="display: inline-block; position: relative; width: 8.749em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.816em 1000em 3.149em -0.424em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-35"><span class="mi" id="MathJax-Span-36" style="font-family: MathJax_Math-italic;">a</span><span class="mo" id="MathJax-Span-37" style="font-family: MathJax_Main;">(</span><span class="msubsup" id="MathJax-Span-38"><span style="display: inline-block; position: relative; width: 1.389em; height: 0px;"><span style="position: absolute; clip: rect(1.976em 1000em 2.723em -0.424em); top: -2.557em; left: 0.003em;"><span class="mi" id="MathJax-Span-39" style="font-family: MathJax_Math-italic;">x</span><span style="display: inline-block; width: 0px; height: 2.563em;"></span></span><span style="position: absolute; top: -2.344em; left: 0.589em;"><span class="texatom" id="MathJax-Span-40"><span class="mrow" id="MathJax-Span-41"><span class="mn" id="MathJax-Span-42" style="font-size: 70.7%; font-family: MathJax_Main;">11</span></span></span><span style="display: inline-block; width: 0px; height: 2.509em;"></span></span></span></span><span class="mo" id="MathJax-Span-43" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-44" style="font-family: MathJax_Math-italic; padding-left: 0.163em;">x</span><span class="msubsup" id="MathJax-Span-45"><span style="display: inline-block; position: relative; width: 1.389em; height: 0px;"><span style="position: absolute; clip: rect(1.976em 1000em 2.723em -0.424em); top: -2.557em; left: 0.003em;"><span class="mi" id="MathJax-Span-46" style="font-family: MathJax_Math-italic;">x</span><span style="display: inline-block; width: 0px; height: 2.563em;"></span></span><span style="position: absolute; top: -2.344em; left: 0.589em;"><span class="texatom" id="MathJax-Span-47"><span class="mrow" id="MathJax-Span-48"><span class="mn" id="MathJax-Span-49" style="font-size: 70.7%; font-family: MathJax_Main;">12</span></span></span><span style="display: inline-block; width: 0px; height: 2.509em;"></span></span></span></span><span class="mo" id="MathJax-Span-50" style="font-family: MathJax_Main;">,</span><span class="mo" id="MathJax-Span-51" style="font-family: MathJax_Main; padding-left: 0.163em;">⋯</span><span class="mo" id="MathJax-Span-52" style="font-family: MathJax_Main; padding-left: 0.163em;">,</span><span class="msubsup" id="MathJax-Span-53" style="padding-left: 0.163em;"><span style="display: inline-block; position: relative; width: 1.443em; height: 0px;"><span style="position: absolute; clip: rect(1.976em 1000em 2.723em -0.424em); top: -2.557em; left: 0.003em;"><span class="mi" id="MathJax-Span-54" style="font-family: MathJax_Math-italic;">x</span><span style="display: inline-block; width: 0px; height: 2.563em;"></span></span><span style="position: absolute; top: -2.344em; left: 0.589em;"><span class="texatom" id="MathJax-Span-55"><span class="mrow" id="MathJax-Span-56"><span class="mn" id="MathJax-Span-57" style="font-size: 70.7%; font-family: MathJax_Main;">1</span><span class="mi" id="MathJax-Span-58" style="font-size: 70.7%; font-family: MathJax_Math-italic;">n</span></span></span><span style="display: inline-block; width: 0px; height: 2.509em;"></span></span></span></span><span class="mo" id="MathJax-Span-59" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.403em; vertical-align: -0.397em;"></span></span> 
      </span><script type="math/tex" id="MathJax-Element-2">a(x_{11},xx_{12},\cdots,x_{1n})</script>与<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-3-Frame"> 
       
       <span class="math" id="MathJax-Span-60" style="width: 10.829em; display: inline-block;"><span style="display: inline-block; position: relative; width: 8.643em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.816em 1000em 3.149em -0.424em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-61"><span class="mi" id="MathJax-Span-62" style="font-family: MathJax_Math-italic;">b</span><span class="mo" id="MathJax-Span-63" style="font-family: MathJax_Main;">(</span><span class="msubsup" id="MathJax-Span-64"><span style="display: inline-block; position: relative; width: 1.389em; height: 0px;"><span style="position: absolute; clip: rect(1.976em 1000em 2.723em -0.424em); top: -2.557em; left: 0.003em;"><span class="mi" id="MathJax-Span-65" style="font-family: MathJax_Math-italic;">x</span><span style="display: inline-block; width: 0px; height: 2.563em;"></span></span><span style="position: absolute; top: -2.344em; left: 0.589em;"><span class="texatom" id="MathJax-Span-66"><span class="mrow" id="MathJax-Span-67"><span class="mn" id="MathJax-Span-68" style="font-size: 70.7%; font-family: MathJax_Main;">21</span></span></span><span style="display: inline-block; width: 0px; height: 2.509em;"></span></span></span></span><span class="mo" id="MathJax-Span-69" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-70" style="font-family: MathJax_Math-italic; padding-left: 0.163em;">x</span><span class="msubsup" id="MathJax-Span-71"><span style="display: inline-block; position: relative; width: 1.389em; height: 0px;"><span style="position: absolute; clip: rect(1.976em 1000em 2.723em -0.424em); top: -2.557em; left: 0.003em;"><span class="mi" id="MathJax-Span-72" style="font-family: MathJax_Math-italic;">x</span><span style="display: inline-block; width: 0px; height: 2.563em;"></span></span><span style="position: absolute; top: -2.344em; left: 0.589em;"><span class="texatom" id="MathJax-Span-73"><span class="mrow" id="MathJax-Span-74"><span class="mn" id="MathJax-Span-75" style="font-size: 70.7%; font-family: MathJax_Main;">22</span></span></span><span style="display: inline-block; width: 0px; height: 2.509em;"></span></span></span></span><span class="mo" id="MathJax-Span-76" style="font-family: MathJax_Main;">,</span><span class="mo" id="MathJax-Span-77" style="font-family: MathJax_Main; padding-left: 0.163em;">⋯</span><span class="mo" id="MathJax-Span-78" style="font-family: MathJax_Main; padding-left: 0.163em;">,</span><span class="msubsup" id="MathJax-Span-79" style="padding-left: 0.163em;"><span style="display: inline-block; position: relative; width: 1.443em; height: 0px;"><span style="position: absolute; clip: rect(1.976em 1000em 2.723em -0.424em); top: -2.557em; left: 0.003em;"><span class="mi" id="MathJax-Span-80" style="font-family: MathJax_Math-italic;">x</span><span style="display: inline-block; width: 0px; height: 2.563em;"></span></span><span style="position: absolute; top: -2.344em; left: 0.589em;"><span class="texatom" id="MathJax-Span-81"><span class="mrow" id="MathJax-Span-82"><span class="mn" id="MathJax-Span-83" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span class="mi" id="MathJax-Span-84" style="font-size: 70.7%; font-family: MathJax_Math-italic;">n</span></span></span><span style="display: inline-block; width: 0px; height: 2.509em;"></span></span></span></span><span class="mo" id="MathJax-Span-85" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.403em; vertical-align: -0.397em;"></span></span> 
      </span><script type="math/tex" id="MathJax-Element-3">b(x_{21},xx_{22},\cdots,x_{2n})</script>的曼哈顿距离为： <br> <span class="MathJax_Preview"></span></p> 
    <div class="MathJax_Display" style="text-align: center;"> 
     <span class="MathJax" id="MathJax-Element-4-Frame"> 
       
       <span class="math" id="MathJax-Span-86" style="width: 11.096em; display: inline-block;"><span style="display: inline-block; position: relative; width: 8.856em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.016em 1000em 4.109em -0.424em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-87"><span class="msubsup" id="MathJax-Span-88"><span style="display: inline-block; position: relative; width: 1.336em; height: 0px;"><span style="position: absolute; clip: rect(1.709em 1000em 2.723em -0.424em); top: -2.557em; left: 0.003em;"><span class="mi" id="MathJax-Span-89" style="font-family: MathJax_Math-italic;">d<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; height: 2.563em;"></span></span><span style="position: absolute; top: -2.344em; left: 0.536em;"><span class="texatom" id="MathJax-Span-90"><span class="mrow" id="MathJax-Span-91"><span class="mn" id="MathJax-Span-92" style="font-size: 70.7%; font-family: MathJax_Main;">12</span></span></span><span style="display: inline-block; width: 0px; height: 2.509em;"></span></span></span></span><span class="mo" id="MathJax-Span-93" style="font-family: MathJax_Main; padding-left: 0.269em;">=</span><span class="munderover" id="MathJax-Span-94" style="padding-left: 0.269em;"><span style="display: inline-block; position: relative; width: 1.496em; height: 0px;"><span style="position: absolute; clip: rect(2.669em 1000em 4.376em -0.424em); top: -3.784em; left: 0.003em;"><span class="mo" id="MathJax-Span-95" style="font-family: MathJax_Size2; vertical-align: 0.003em;">∑</span><span style="display: inline-block; width: 0px; height: 3.789em;"></span></span><span style="position: absolute; clip: rect(1.869em 1000em 2.776em -0.424em); top: -1.384em; left: 0.109em;"><span class="texatom" id="MathJax-Span-96"><span class="mrow" id="MathJax-Span-97"><span class="mi" id="MathJax-Span-98" style="font-size: 70.7%; font-family: MathJax_Math-italic;">k</span><span class="mo" id="MathJax-Span-99" style="font-size: 70.7%; font-family: MathJax_Main;">=</span><span class="mn" id="MathJax-Span-100" style="font-size: 70.7%; font-family: MathJax_Main;">1</span></span></span><span style="display: inline-block; width: 0px; height: 2.509em;"></span></span><span style="position: absolute; clip: rect(1.869em 1000em 2.616em -0.477em); top: -3.624em; left: 0.536em;"><span class="mi" id="MathJax-Span-101" style="font-size: 70.7%; font-family: MathJax_Math-italic;">n</span><span style="display: inline-block; width: 0px; height: 2.456em;"></span></span></span></span><span class="texatom" id="MathJax-Span-102" style="padding-left: 0.163em;"><span class="mrow" id="MathJax-Span-103"><span class="mo" id="MathJax-Span-104" style="font-family: MathJax_Main;">|</span></span></span><span class="msubsup" id="MathJax-Span-105"><span style="display: inline-block; position: relative; width: 1.389em; height: 0px;"><span style="position: absolute; clip: rect(1.976em 1000em 2.723em -0.424em); top: -2.557em; left: 0.003em;"><span class="mi" id="MathJax-Span-106" style="font-family: MathJax_Math-italic;">x</span><span style="display: inline-block; width: 0px; height: 2.563em;"></span></span><span style="position: absolute; top: -2.344em; left: 0.589em;"><span class="texatom" id="MathJax-Span-107"><span class="mrow" id="MathJax-Span-108"><span class="mn" id="MathJax-Span-109" style="font-size: 70.7%; font-family: MathJax_Main;">1</span><span class="mi" id="MathJax-Span-110" style="font-size: 70.7%; font-family: MathJax_Math-italic;">k</span></span></span><span style="display: inline-block; width: 0px; height: 2.509em;"></span></span></span></span><span class="mo" id="MathJax-Span-111" style="font-family: MathJax_Main; padding-left: 0.216em;">−</span><span class="msubsup" id="MathJax-Span-112" style="padding-left: 0.216em;"><span style="display: inline-block; position: relative; width: 1.389em; height: 0px;"><span style="position: absolute; clip: rect(1.976em 1000em 2.723em -0.424em); top: -2.557em; left: 0.003em;"><span class="mi" id="MathJax-Span-113" style="font-family: MathJax_Math-italic;">x</span><span style="display: inline-block; width: 0px; height: 2.563em;"></span></span><span style="position: absolute; top: -2.344em; left: 0.589em;"><span class="texatom" id="MathJax-Span-114"><span class="mrow" id="MathJax-Span-115"><span class="mn" id="MathJax-Span-116" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span class="mi" id="MathJax-Span-117" style="font-size: 70.7%; font-family: MathJax_Math-italic;">k</span></span></span><span style="display: inline-block; width: 0px; height: 2.509em;"></span></span></span></span><span class="texatom" id="MathJax-Span-118"><span class="mrow" id="MathJax-Span-119"><span class="mo" id="MathJax-Span-120" style="font-family: MathJax_Main;">|</span></span></span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 3.603em; vertical-align: -1.597em;"></span></span> 
      </span> 
    </div><script type="math/tex; mode=display" id="MathJax-Element-4">d_{12}=\sum_{k=1}^n|x_{1k}-x_{2k}|</script><p></p></li><li><p>其他 <br> 参考<a href="http://www.cnblogs.com/xbinworld/archive/2012/09/24/2700572.html" rel="nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/xbinworld/archive/2012/09/24/2700572.html</a></p></li></ol> <p>里面有着更加详细的关于距离的介绍。</p></li><li><p>距离排序 <br> 在这个计算的过程中，需要将最终的计算进行一个排序的。为下一步操作做好准备。</p></li><li><p>K的选择 <br> 很明显，对于这算法，K的选取决定了整个算法分类预测的准确性，可以说是其核心参数。从上面的例子也可以看出来，K=3和K=5得到的决然不同的结果的。</p></li></ol> 
<h3 id="13-算法步骤">1.3 算法步骤</h3> 
<p>（1）初始化距离 <br> （2）计算待分类样本和每个训练集的距离 <br> （3）排序 <br> （4）选取K个最邻近的数据 <br> （5）计算K个训练样本的每类标签出现的概率 <br> （6）将待分类样本归为出现概率最大的标签，分类结束。</p> 
<h2 id="2-python实现k-邻近算法">2. Python实现K-邻近算法</h2> 
<h3 id="21-k-邻近函数"><strong>2.1 K-邻近函数</strong></h3> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mykNN</span><span class="hljs-params">(testData, trainData, label, K)</span>:</span>

    <span class="hljs-comment"># testData 待分类的数据集</span>
    <span class="hljs-comment"># trainData 已经分类好的数据集</span>
    <span class="hljs-comment"># label trainData数据集里面的分类标签</span>
    <span class="hljs-comment"># K是knn算法中的K</span>
    <span class="hljs-comment"># testData=[101,20]</span>
    <span class="hljs-comment"># testData=np.array(testData)</span>
    <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
    arraySize = trainData.shape
    trainingSampleNumber = arraySize[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 样本大小</span>
    trainFeatureNumber = arraySize[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 样本特征个数</span>

    <span class="hljs-comment"># 将待测试样本拓展为和训练集一样大小矩阵</span>
    testDataTemp = np.tile(testData, (trainingSampleNumber, <span class="hljs-number">1</span>))
    distanceMatrixTemp = (testDataTemp - trainData)**<span class="hljs-number">2</span>
    distanceMatrix = np.sum(distanceMatrixTemp, axis=<span class="hljs-number">1</span>)
    distanceMatrix = np.sqrt(distanceMatrix)
    <span class="hljs-comment"># print('测试集与训练集之间的欧式距离值为：\n')</span>
    <span class="hljs-comment"># print(distanceMatrix)</span>
    <span class="hljs-comment"># print()</span>
    <span class="hljs-comment"># np.argsort()得到矩阵排序后的对应的索引值</span>
    sortedDistanceIndex = np.argsort(distanceMatrix)
    <span class="hljs-comment"># print(sortedDistanceIndex)</span>
    <span class="hljs-comment"># 定义一个统计类别的字典</span>
    labelClassCount = {}
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(K):
        labelTemp = label[sortedDistanceIndex[i]]  <span class="hljs-comment"># 获取排名前K的距离对应的类别值</span>
        <span class="hljs-comment"># print(labelTemp)</span>
        labelClassCount[labelTemp] = labelClassCount.get(
            labelTemp, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>  <span class="hljs-comment"># 统计前K中每个类别出现的次数</span>

        <span class="hljs-comment"># print(labelClassCount)</span>

    sortedLabelClassCount = sorted(labelClassCount.items(), key=<span class="hljs-keyword">lambda</span> item: item[
                                   <span class="hljs-number">1</span>], reverse=<span class="hljs-keyword">True</span>)  <span class="hljs-comment"># 对字典进行降序排序</span>
    <span class="hljs-comment"># lambda item:item[1] 匿名函数，将利用dict.items()获取的字典的key-value作为该匿名函数的变量输入。# reverse=True 降序排列</span>
    <span class="hljs-comment"># print(sortedLabelClassCount)</span>
    <span class="hljs-keyword">return</span> sortedLabelClassCount[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]  <span class="hljs-comment"># 返回最终的分类标签值</span></code></pre> 
<h3 id="22-牛刀小试-电影分类">2.2 牛刀小试-电影分类</h3> 
<p>举个简单的例子，我们可以使用k-近邻算法分类一个电影是爱情片还是动作片。</p> 
<table><thead><tr><th>电影名称</th><th align="left">打斗镜头</th><th>接吻镜头</th><th>电影类型</th></tr></thead><tbody><tr><td>电影1</td><td align="left">1</td><td>101</td><td>Romance</td></tr><tr><td>电影2</td><td align="left">5</td><td>89</td><td>Romance</td></tr><tr><td>电影3</td><td align="left">108</td><td>5</td><td>action</td></tr><tr><td>电影4</td><td align="left">115</td><td>8</td><td>action</td></tr></tbody></table> 
<p>以上是已知的训练样本，我们需预测的是（101, 20）这个样本，我们大致可以知道，打斗镜头多则应该是动作片</p> 
<p><strong>数据集函数</strong></p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">creatDataSet</span><span class="hljs-params">()</span>:</span>
<span class="hljs-comment">#定义数据集函数</span>
    group = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">101</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">89</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">108</span>, <span class="hljs-number">5</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">115</span>, <span class="hljs-number">8</span>, <span class="hljs-number">120</span>]])
    label = [<span class="hljs-string">'romance Movie'</span>, <span class="hljs-string">'romance Movie'</span>, <span class="hljs-string">'action Movie'</span>, <span class="hljs-string">'action Movie'</span>]
    <span class="hljs-comment"># label=['r','r','a','a']</span>
    <span class="hljs-keyword">return</span> group, label
    <span class="hljs-comment"># print(group)</span>
    <span class="hljs-comment"># print(label)'''</span>
</code></pre> 
<p><strong>主函数</strong></p> 
<pre class="prettyprint"><code class=" hljs php"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:
<span class="hljs-comment">#主函数</span>
    finalIdentifyingResult=[]
    group,label=creatDataSet()
    <span class="hljs-keyword">print</span>()
    <span class="hljs-keyword">print</span>(<span class="hljs-string">'Identifying ......'</span>)
    <span class="hljs-keyword">print</span>()
    <span class="hljs-keyword">print</span>(<span class="hljs-string">'The identified result is :\n'</span>)


    testData=[<span class="hljs-number">101</span>,<span class="hljs-number">20</span>]
    testData=np.<span class="hljs-keyword">array</span>(testData)
    finalIdentifyingLabel=mykNN(testData,group,label,<span class="hljs-number">3</span>)
    <span class="hljs-keyword">print</span>(<span class="hljs-string">'the test data is identified as: '</span>,finalIdentifyingLabel,<span class="hljs-string">'\n'</span>)</code></pre> 
<p><img src="https://images2.imgbox.com/e8/56/VQGOAe0I_o.png" alt="这里写图片描述" title=""></p> 
<p>可以看出来，分类结果和我们预测的是一致的，动作电影。</p> 
<p><strong>完整代码</strong></p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-comment">#!/usr/bin/env python</span>
<span class="hljs-comment"># -*- coding: utf-8 -*-</span>
<span class="hljs-comment"># @Date    : 2017-08-28 16:04:25</span>
<span class="hljs-comment"># @Author  : AiYong (aiyong_stu@163.com)</span>
<span class="hljs-comment"># @Link    : http://blog.csdn.net/sjtuai</span>
<span class="hljs-comment"># @Version : $Id$</span>

<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">creatDataSet</span><span class="hljs-params">()</span>:</span>

    group = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">101</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">89</span>], [<span class="hljs-number">108</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">115</span>, <span class="hljs-number">8</span>]])
    label = [<span class="hljs-string">'romance Movie'</span>, <span class="hljs-string">'romance Movie'</span>, <span class="hljs-string">'action Movie'</span>, <span class="hljs-string">'action Movie'</span>]
    <span class="hljs-keyword">return</span> group, label
    print(group)
    print(label)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mykNN</span><span class="hljs-params">(testData, trainData, label, K)</span>:</span>

    arraySize = trainData.shape
    trainingSampleNumber = arraySize[<span class="hljs-number">0</span>]
    testDataTemp = np.tile(testData, (trainingSampleNumber, <span class="hljs-number">1</span>))
    distanceMatrixTemp = (testDataTemp - trainData)**<span class="hljs-number">2</span>
    distanceMatrix = np.sum(distanceMatrixTemp, axis=<span class="hljs-number">1</span>)
    distanceMatrix = np.sqrt(distanceMatrix)
    sortedDistanceIndex = np.argsort(distanceMatrix)
    labelClassCount = {}
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(K):
        labelTemp = label[sortedDistanceIndex[i]]  
        labelClassCount[labelTemp] = labelClassCount.get(
            labelTemp, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span> 
        sortedLabelClassCount = sorted(labelClassCount.items(), key=<span class="hljs-keyword">lambda</span> item: item[
            <span class="hljs-number">1</span>], reverse=<span class="hljs-keyword">True</span>) 
        <span class="hljs-keyword">return</span> sortedLabelClassCount[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] 

<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:

    finalIdentifyingResult=[]
    group,label=creatDataSet()
    print()
    print(<span class="hljs-string">'Identifying ......'</span>)
    print()
    print(<span class="hljs-string">'The identified result is :\n'</span>)
    testData=[<span class="hljs-number">101</span>,<span class="hljs-number">20</span>]
    testData=np.array(testData)
    finalIdentifyingLabel=mykNN(testData,group,label,<span class="hljs-number">3</span>)
    print(<span class="hljs-string">'the test data is identified as: '</span>,finalIdentifyingLabel,<span class="hljs-string">'\n'</span>)
</code></pre> 
<h3 id="23-考验阶段-鸢尾花数据集应用-分类预测">2.3 考验阶段-鸢尾花数据集应用-分类预测</h3> 
<p><strong>鸢尾花数据集</strong></p> 
<p>U can get description of ‘iris.csv’ at ‘<a href="http://aima.cs.berkeley.edu/data/iris.txt" rel="nofollow noopener noreferrer" target="_blank">http://aima.cs.berkeley.edu/data/iris.txt</a>‘#### <br> Definiation of COLs: <br> #1. sepal length in cm (花萼长) # <br> #2. sepal width in cm（花萼宽）# <br> #3. petal length in cm (花瓣长) <br> #4. petal width in cm（花瓣宽） # <br> #5. class: # <br> #– Iris Setosa # <br> #– Iris Versicolour # <br> #– Iris Virginica # <br> #Missing Attribute Values: None</p> 
<p><strong>数据集整理函数</strong></p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">creatDataSet</span><span class="hljs-params">(fileName, test_size_ratio)</span>:</span>
        <span class="hljs-comment"># fileName is the data file whose type is string</span>
        <span class="hljs-comment"># test_size whose type is float is the ratio of test data in the whole</span>
            <span class="hljs-comment"># data set</span>
    irisData = np.loadtxt(fileName, dtype=float,
                          delimiter=<span class="hljs-string">','</span>, usecols=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))
    dataSize = irisData.shape
    irisLabel = np.loadtxt(fileName, dtype=str, delimiter=<span class="hljs-string">','</span>, usecols=<span class="hljs-number">4</span>)

    irisLabel = irisLabel.reshape(dataSize[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)
    <span class="hljs-comment">#这里使用的一个函数是机器学习库中的一个可以用来随机选取训练集和测试集的一个函数</span>
    iristrainData, iristestData, iristrainDataLabel, iristestDataLabel = cross_validation.train_test_split(
        irisData, irisLabel, test_size=test_size_ratio, random_state=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> iristrainData, iristestData, iristrainDataLabel, iristestDataLabel</code></pre> 
<p><strong>矩阵转化为列表函数</strong></p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ndarray2List</span><span class="hljs-params">(label)</span>:</span>
    <span class="hljs-comment">#这个函数的目的是为了后的数据服务的。</span>
    label = label.tolist()
    finalLabel = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(label.__len__()):
        finalLabel.append(<span class="hljs-string">'\n'</span>.join(list(label[i])))
    <span class="hljs-keyword">return</span> finalLabel</code></pre> 
<p><strong>自定义混淆矩阵计算函数</strong></p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">computingConfusionMatrix</span><span class="hljs-params">(trueResultA, modelPredictResultB)</span>:</span>

        <span class="hljs-comment"># trueResultA 正确的分类结果，numpy矩阵类型</span>
        <span class="hljs-comment"># modelPredictResultB 模型预测结果，numpy矩阵类型</span>
        <span class="hljs-comment"># labelType 分类标签值，list列表类型</span>
        <span class="hljs-comment">#返回，confusionMatrix，混淆矩阵，numpy矩阵类型</span>
        <span class="hljs-comment">#返回，labelType，分类标签，list列表类型</span>
        <span class="hljs-comment">#返回，Accuracy，分类争取率，float浮点数据</span>
    <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
    labelType = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> trueResultA:
        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> labelType:
            labelType.append(i)
    print(labelType)
    labelTypeNumber = labelType.__len__()
    confusionMatrix = np.zeros(
        [labelTypeNumber, labelTypeNumber], dtype=<span class="hljs-string">'int64'</span>)
    finalCount = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(labelTypeNumber):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(trueResultA.__len__()):
            <span class="hljs-keyword">if</span> modelPredictResultB[j] == labelType[i] <span class="hljs-keyword">and</span> trueResultA[j] == labelType[i]:
                confusionMatrix[i][i] += <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(labelTypeNumber):
                    <span class="hljs-keyword">if</span> k == i:
                        <span class="hljs-keyword">break</span>
                    <span class="hljs-keyword">if</span> modelPredictResultB[j] == labelType[k]:
                        confusionMatrix[i][k] += <span class="hljs-number">1</span>
                        <span class="hljs-keyword">break</span>
    count = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(labelTypeNumber - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(labelTypeNumber - <span class="hljs-number">1</span> - count):
            confusionMatrix[i][j] = confusionMatrix[
                i][j] - confusionMatrix[i - <span class="hljs-number">1</span>][j]
        count += <span class="hljs-number">1</span>
    totalTrueResult = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(labelTypeNumber):
        totalTrueResult += confusionMatrix[k][k]
    Accuracy = float(totalTrueResult / modelPredictResultB.__len__()) * <span class="hljs-number">100</span>
    <span class="hljs-keyword">return</span> confusionMatrix, labelType, Accuracy</code></pre> 
<p><strong>定义图里面的横纵坐标轴标签值的旋转</strong></p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">labelsRotation</span><span class="hljs-params">(labels, rotatingAngle)</span>:</span>
    <span class="hljs-comment">#labels 获取的x，y轴的标签值</span>
    <span class="hljs-comment">#rotatingAngle 想要旋转的角度</span>
    <span class="hljs-comment"># 定义x，y轴标签旋转函数</span>
    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> labels:
        t.set_rotation(rotatingAngle)
</code></pre> 
<p><strong>定义混淆矩阵可视化函数</strong></p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plotConfusionMatrix</span><span class="hljs-params">(confusionMatrix,labelType)</span>:</span>
    <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-comment"># 设置图片的大小以及图片分辨率</span>
    fig = plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>), dpi=<span class="hljs-number">120</span>)
    plt.clf()
<span class="hljs-comment"># 绘制图，colormap是coolwarm</span>
    plt.imshow(confusionMatrix, cmap=plt.cm.coolwarm, interpolation=<span class="hljs-string">'nearest'</span>)
    plt.colorbar()
<span class="hljs-comment"># 设置x，y的横纵轴的标签</span>
    plt.xlabel(<span class="hljs-string">'Predicted Result'</span>, fontsize=<span class="hljs-number">11</span>)
    plt.ylabel(<span class="hljs-string">'True Result'</span>, fontsize=<span class="hljs-number">11</span>)
    cmSize = confusionMatrix.shape
    width = cmSize[<span class="hljs-number">0</span>]
    height = cmSize[<span class="hljs-number">1</span>]
    plt.xticks(fontsize=<span class="hljs-number">11</span>)
    plt.yticks(fontsize=<span class="hljs-number">11</span>)
<span class="hljs-comment"># 设置横纵坐标的刻度标签，显示为分类标签值</span>
    x_locs, x_labels = plt.xticks(range(width), labelType[:width])
    y_locs, y_labels = plt.yticks(range(height), labelType[:height])
<span class="hljs-comment"># 设置x，y轴的标签是否旋转</span>
    labelsRotation(x_labels, <span class="hljs-number">0</span>)
    labelsRotation(y_labels, <span class="hljs-number">0</span>)

<span class="hljs-comment"># 在图里面添加数据标签</span>
    confusionMatrix = confusionMatrix.T
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(width):  <span class="hljs-comment"># 数据标签</span>
        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(height):
            plt.annotate(confusionMatrix[x][y], xy=(
                x, y), horizontalalignment=<span class="hljs-string">'center'</span>, verticalalignment=<span class="hljs-string">'center'</span>)
    plt.grid(<span class="hljs-keyword">True</span>, which=<span class="hljs-string">'minor'</span>, linestyle=<span class="hljs-string">'-'</span>)
<span class="hljs-comment"># plt.rc('font',family='Times New Roman',size=15)</span>
    font = {<!-- --><span class="hljs-string">'family'</span>: <span class="hljs-string">'monospace'</span>, <span class="hljs-string">'weight'</span>: <span class="hljs-string">'bold'</span>, <span class="hljs-string">'size'</span>: <span class="hljs-number">15</span>}
    plt.rc(<span class="hljs-string">'font'</span>, **font)
    plt.show()</code></pre> 
<p><strong>主函数</strong></p> 
<pre class="prettyprint"><code class=" hljs mel"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    finalIdentifyingResult = []
    iriskNNResult = []
    iristrainData, iristestData, iristrainDataLabel, iristestDataLabel = creatDataSet(
        <span class="hljs-string">'iris.txt'</span>, <span class="hljs-number">0.8</span>)
    testGroup = iristestData
    trainGroup = iristrainData
    trainLabel = iristrainDataLabel

    testSize = testGroup.shape
    testSampleNumber = testSize[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">print</span>()
    <span class="hljs-keyword">print</span>(<span class="hljs-string">'Identifying ......'</span>)
    <span class="hljs-keyword">print</span>()
    <span class="hljs-keyword">print</span>(<span class="hljs-string">'The identified result is :\n'</span>)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(testSampleNumber):
        testData = testGroup[i]
        finalIdentifyingLabel = mykNN(testData, trainGroup, trainLabel, <span class="hljs-number">10</span>)
        finalIdentifyingResult.append(finalIdentifyingLabel)
    iriskNNResult = np.array(
        finalIdentifyingResult).reshape(testSampleNumber, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">print</span>(finalIdentifyingResult)
    trueResultA = ndarray2List(iristestDataLabel)
    modelPredictResultB = finalIdentifyingResult
    confusionMatrix, labelType, Accuracy = computingConfusionMatrix(
        trueResultA, modelPredictResultB)
    <span class="hljs-keyword">print</span>(<span class="hljs-string">'The accuracy is :{a:5.3f}%'</span>.<span class="hljs-keyword">format</span>(a=Accuracy))
    plotConfusionMatrix(confusionMatrix, labelType)
</code></pre> 
<p><strong>结果</strong></p> 
<p><img src="https://images2.imgbox.com/0f/6b/UuW2A7fT_o.png" alt="这里写图片描述" title=""><img src="https://images2.imgbox.com/58/60/v4I2htfO_o.png" alt="这里写图片描述" title=""> <br> <img src="https://images2.imgbox.com/e3/ab/xaJ5rgdm_o.png" alt="这里写图片描述" title=""></p> 
<p><strong>混淆矩阵</strong> <br> <img src="https://images2.imgbox.com/75/4e/45amhUIa_o.png" alt="这里写图片描述" title=""></p> 
<p>从上面的结果可以看到这个准确率在90%以上，说明还是不错的！</p> 
<p><strong>完整的程序结构</strong></p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-comment">#!/usr/bin/env python</span>
<span class="hljs-comment"># -*- coding: utf-8 -*-</span>
<span class="hljs-comment"># @Date    : 2017-08-08 16:04:25</span>
<span class="hljs-comment"># @Author  : AiYong (aiyong_stu@163.com)</span>
<span class="hljs-comment"># @Link    : http://blog.csdn.net/sjtuai</span>
<span class="hljs-comment"># @Version : $Id$</span>

<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> cross_validation
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mykNN</span><span class="hljs-params">(testData, trainData, label, K)</span>:</span>

    <span class="hljs-comment"># testData 待分类的数据集</span>
    <span class="hljs-comment"># trainData 已经分类好的数据集</span>
    <span class="hljs-comment"># label trainData数据集里面的分类标签</span>
    <span class="hljs-comment"># K是knn算法中的K</span>
    <span class="hljs-comment"># testData=[101,20]</span>
    <span class="hljs-comment"># testData=np.array(testData)</span>
    <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
    arraySize = trainData.shape
    trainingSampleNumber = arraySize[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 样本大小</span>
    trainFeatureNumber = arraySize[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 样本特征个数</span>

    <span class="hljs-comment"># 将待测试样本拓展为和训练集一样大小矩阵</span>
    testDataTemp = np.tile(testData, (trainingSampleNumber, <span class="hljs-number">1</span>))
    distanceMatrixTemp = (testDataTemp - trainData)**<span class="hljs-number">2</span>
    distanceMatrix = np.sum(distanceMatrixTemp, axis=<span class="hljs-number">1</span>)
    distanceMatrix = np.sqrt(distanceMatrix)
    <span class="hljs-comment"># print('测试集与训练集之间的欧式距离值为：\n')</span>
    <span class="hljs-comment"># print(distanceMatrix)</span>
    <span class="hljs-comment"># print()</span>
    <span class="hljs-comment"># np.argsort()得到矩阵排序后的对应的索引值</span>
    sortedDistanceIndex = np.argsort(distanceMatrix)
    <span class="hljs-comment"># print(sortedDistanceIndex)</span>
    <span class="hljs-comment"># 定义一个统计类别的字典</span>
    labelClassCount = {}
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(K):
        labelTemp = label[sortedDistanceIndex[i]]  <span class="hljs-comment"># 获取排名前K的距离对应的类别值</span>
        <span class="hljs-comment"># print(labelTemp)</span>
        labelClassCount[labelTemp] = labelClassCount.get(
            labelTemp, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>  <span class="hljs-comment"># 统计前K中每个类别出现的次数</span>

        <span class="hljs-comment"># print(labelClassCount)</span>

    sortedLabelClassCount = sorted(labelClassCount.items(), key=<span class="hljs-keyword">lambda</span> item: item[
                                   <span class="hljs-number">1</span>], reverse=<span class="hljs-keyword">True</span>)  <span class="hljs-comment"># 对字典进行降序排序</span>
    <span class="hljs-comment"># lambda item:item[1] 匿名函数，将利用dict.items()获取的字典的key-value作为该匿名函数的变量输入。# reverse=True 降序排列</span>
    <span class="hljs-comment"># print(sortedLabelClassCount)</span>
    <span class="hljs-keyword">return</span> sortedLabelClassCount[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]  <span class="hljs-comment"># 返回最终的分类标签值</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">creatDataSet</span><span class="hljs-params">(fileName, test_size_ratio)</span>:</span>
        <span class="hljs-comment"># fileName is the data file whose type is string</span>
        <span class="hljs-comment"># test_size whose type is float is the ratio of test data in the whole</span>
            <span class="hljs-comment"># data set</span>
    irisData = np.loadtxt(fileName, dtype=float,
                          delimiter=<span class="hljs-string">','</span>, usecols=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))
    dataSize = irisData.shape
    irisLabel = np.loadtxt(fileName, dtype=str, delimiter=<span class="hljs-string">','</span>, usecols=<span class="hljs-number">4</span>)

    irisLabel = irisLabel.reshape(dataSize[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)
    <span class="hljs-comment">#这里使用的一个函数是机器学习库中的一个可以用来随机选取训练集和测试集的一个函数</span>
    iristrainData, iristestData, iristrainDataLabel, iristestDataLabel = cross_validation.train_test_split(
        irisData, irisLabel, test_size=test_size_ratio, random_state=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> iristrainData, iristestData, iristrainDataLabel, iristestDataLabel


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ndarray2List</span><span class="hljs-params">(label)</span>:</span>
    <span class="hljs-comment">#这个函数的目的是为了后的数据服务的。</span>
    label = label.tolist()
    finalLabel = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(label.__len__()):
        finalLabel.append(<span class="hljs-string">'\n'</span>.join(list(label[i])))
    <span class="hljs-keyword">return</span> finalLabel


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">computingConfusionMatrix</span><span class="hljs-params">(trueResultA, modelPredictResultB)</span>:</span>

        <span class="hljs-comment"># trueResultA 正确的分类结果，numpy矩阵类型</span>
        <span class="hljs-comment"># modelPredictResultB 模型预测结果，numpy矩阵类型</span>
        <span class="hljs-comment"># labelType 分类标签值，list列表类型</span>
        <span class="hljs-comment">#返回，confusionMatrix，混淆矩阵，numpy矩阵类型</span>
        <span class="hljs-comment">#返回，labelType，分类标签，list列表类型</span>
        <span class="hljs-comment">#返回，Accuracy，分类争取率，float浮点数据</span>
    <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
    labelType = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> trueResultA:
        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> labelType:
            labelType.append(i)
    print(labelType)
    labelTypeNumber = labelType.__len__()
    confusionMatrix = np.zeros(
        [labelTypeNumber, labelTypeNumber], dtype=<span class="hljs-string">'int64'</span>)
    finalCount = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(labelTypeNumber):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(trueResultA.__len__()):
            <span class="hljs-keyword">if</span> modelPredictResultB[j] == labelType[i] <span class="hljs-keyword">and</span> trueResultA[j] == labelType[i]:
                confusionMatrix[i][i] += <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(labelTypeNumber):
                    <span class="hljs-keyword">if</span> k == i:
                        <span class="hljs-keyword">break</span>
                    <span class="hljs-keyword">if</span> modelPredictResultB[j] == labelType[k]:
                        confusionMatrix[i][k] += <span class="hljs-number">1</span>
                        <span class="hljs-keyword">break</span>
    count = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(labelTypeNumber - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(labelTypeNumber - <span class="hljs-number">1</span> - count):
            confusionMatrix[i][j] = confusionMatrix[
                i][j] - confusionMatrix[i - <span class="hljs-number">1</span>][j]
        count += <span class="hljs-number">1</span>
    totalTrueResult = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(labelTypeNumber):
        totalTrueResult += confusionMatrix[k][k]
    Accuracy = float(totalTrueResult / modelPredictResultB.__len__()) * <span class="hljs-number">100</span>
    <span class="hljs-keyword">return</span> confusionMatrix, labelType, Accuracy
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">labelsRotation</span><span class="hljs-params">(labels, rotatingAngle)</span>:</span>
        <span class="hljs-comment">#labels 获取的x，y轴的标签值</span>
        <span class="hljs-comment">#rotatingAngle 想要旋转的角度</span>
        <span class="hljs-comment"># 定义x，y轴标签旋转函数</span>
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> labels:
            t.set_rotation(rotatingAngle)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plotConfusionMatrix</span><span class="hljs-params">(confusionMatrix,labelType)</span>:</span>
    <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
    fig = plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>), dpi=<span class="hljs-number">120</span>)
    plt.clf()
    plt.imshow(confusionMatrix, cmap=plt.cm.coolwarm, interpolation=<span class="hljs-string">'nearest'</span>)
    plt.colorbar()
    plt.xlabel(<span class="hljs-string">'Predicted Result'</span>, fontsize=<span class="hljs-number">11</span>)
    plt.ylabel(<span class="hljs-string">'True Result'</span>, fontsize=<span class="hljs-number">11</span>)
    cmSize = confusionMatrix.shape
    width = cmSize[<span class="hljs-number">0</span>]
    height = cmSize[<span class="hljs-number">1</span>]
    plt.xticks(fontsize=<span class="hljs-number">11</span>)
    plt.yticks(fontsize=<span class="hljs-number">11</span>)
    x_locs, x_labels = plt.xticks(range(width), labelType[:width])
    y_locs, y_labels = plt.yticks(range(height), labelType[:height])
    labelsRotation(x_labels, <span class="hljs-number">0</span>)
    labelsRotation(y_labels, <span class="hljs-number">0</span>)
    confusionMatrix = confusionMatrix.T
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(width):  <span class="hljs-comment"># 数据标签</span>
        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(height):
            plt.annotate(confusionMatrix[x][y], xy=(
                x, y), horizontalalignment=<span class="hljs-string">'center'</span>, verticalalignment=<span class="hljs-string">'center'</span>)
    plt.grid(<span class="hljs-keyword">True</span>, which=<span class="hljs-string">'minor'</span>, linestyle=<span class="hljs-string">'-'</span>)
    font = {<!-- --><span class="hljs-string">'family'</span>: <span class="hljs-string">'monospace'</span>, <span class="hljs-string">'weight'</span>: <span class="hljs-string">'bold'</span>, <span class="hljs-string">'size'</span>: <span class="hljs-number">15</span>}
    plt.rc(<span class="hljs-string">'font'</span>, **font)
    plt.show()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    finalIdentifyingResult = []
    iriskNNResult = []
    iristrainData, iristestData, iristrainDataLabel, iristestDataLabel = creatDataSet(
        <span class="hljs-string">'iris.txt'</span>, <span class="hljs-number">0.8</span>)
    testGroup = iristestData
    trainGroup = iristrainData
    trainLabel = iristrainDataLabel

    testSize = testGroup.shape
    testSampleNumber = testSize[<span class="hljs-number">0</span>]
    print()
    print(<span class="hljs-string">'Identifying ......'</span>)
    print()
    print(<span class="hljs-string">'The identified result is :\n'</span>)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(testSampleNumber):
        testData = testGroup[i]
        finalIdentifyingLabel = mykNN(testData, trainGroup, trainLabel, <span class="hljs-number">10</span>)
        finalIdentifyingResult.append(finalIdentifyingLabel)
    iriskNNResult = np.array(
        finalIdentifyingResult).reshape(testSampleNumber, <span class="hljs-number">1</span>)
    print(finalIdentifyingResult)
    trueResultA = ndarray2List(iristestDataLabel)
    modelPredictResultB = finalIdentifyingResult
    confusionMatrix, labelType, Accuracy = computingConfusionMatrix(
        trueResultA, modelPredictResultB)
    print(<span class="hljs-string">'The accuracy is :{a:5.3f}%'</span>.format(a=Accuracy))
    plotConfusionMatrix(confusionMatrix, labelType)
</code></pre> 
<h2 id="3-总结">3. 总结</h2> 
<p>这里有非常好的关于K-邻近分类的理论以及一些比较好的图理：</p> 
<p><a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm</a></p> 
<h3 id="31-优缺点">3.1 优缺点</h3> 
<p><strong>优点</strong></p> 
<p>简单，易于理解，易于实现，无需估计参数，无需训练 <br> 适合对稀有事件进行分类（例如当流失率很低时，比如低于0.5%，构造流失预测模型） <br> 特别适合于多分类问题(multi-modal,对象具有多个类别标签)，例如根据基因特征来判断其功能分类，kNN比SVM的表现要好</p> 
<p><strong>缺点</strong></p> 
<p>懒惰算法，对测试样本分类时的计算量大，内存开销大，评分慢 <br> 可解释性较差，无法给出决策树那样的规则。</p> 
<h3 id="32-一些问题集锦">3.2 一些问题集锦</h3> 
<p><strong>1、k值设定为多大？</strong> <br> k太小，分类结果易受噪声点影响；k太大，近邻中又可能包含太多的其它类别的点。（对距离加权，可以降低k值设定的影响） <br> k值通常是采用交叉检验来确定（以k=1为基准） <br> 经验规则：k一般低于训练样本数的平方根</p> 
<p><strong>2、类别如何判定最合适？</strong> <br> 投票法没有考虑近邻的距离的远近，距离更近的近邻也许更应该决定最终的分类，所以加权投票法更恰当一些。</p> 
<p><strong>3、如何选择合适的距离衡量？</strong></p> 
<p>高维度对距离衡量的影响：众所周知当变量数越多，欧式距离的区分能力就越差。 <br> 变量值域对距离的影响：值域越大的变量常常会在距离计算中占据主导作用，因此应先对变量进行标准化。</p> 
<p><strong>4、训练样本是否要一视同仁？</strong></p> 
<p>在训练集中，有些样本可能是更值得依赖的。 <br> 可以给不同的样本施加不同的权重，加强依赖样本的权重，降低不可信赖样本的影响。</p> 
<p><strong>5、性能问题？</strong></p> 
<p>kNN是一种懒惰算法，平时不好好学习，考试（对测试样本分类）时才临阵磨枪（临时去找k个近邻）。 <br> 懒惰的后果：构造模型很简单，但在对测试样本分类地的系统开销大，因为要扫描全部训练样本并计算距离。</p> 
<h2 id="参考链接">参考链接：</h2> 
<p><a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm</a></p> 
<p><a href="http://blog.csdn.net/jmydream/article/details/8644004" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/jmydream/article/details/8644004</a></p> 
<p><a href="http://wuguangbin1230.blog.163.com/blog/static/61529835201522905624494/" rel="nofollow noopener noreferrer" target="_blank">http://wuguangbin1230.blog.163.com/blog/static/61529835201522905624494/</a></p> 
<p><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html" rel="nofollow noopener noreferrer" target="_blank">https://docs.scipy.org/doc/numpy-dev/user/quickstart.html</a></p> 
<p><a href="http://matplotlib.org/api/pyplot_summary.html" rel="nofollow noopener noreferrer" target="_blank">http://matplotlib.org/api/pyplot_summary.html</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1f908343974734dfd5f8039cdbb517cd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">机器学习实战之KMeans算法pandas实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c4ef99e08a5437dbbbf3ecf2d8db764e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">datastage-报错收集</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>