<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 控件 RecyclerView  看这篇就够了 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android 控件 RecyclerView  看这篇就够了" />
<meta property="og:description" content="【Android 控件 RecyclerView】 概述 RecyclerView是什么 从Android 5.0开始，谷歌公司推出了一个用于大量数据展示的新控件RecylerView，可以用来代替传统的ListView，更加强大和灵活。RecyclerView的官方定义如下：
A flexible view for providing a limited window into a large data set.
从定义可以看出，flexible（可扩展性）是RecyclerView的特点。
RecyclerView是support-v7包中的新组件，是一个强大的滑动组件，与经典的ListView相比，同样拥有item回收复用的功能，这一点从它的名字Recyclerview即回收view也可以看出。
RecyclerView的优点 RecyclerView并不会完全替代ListView（这点从ListView没有被标记为@Deprecated可以看出），两者的使用场景不一样。但是RecyclerView的出现会让很多开源项目被废弃，例如横向滚动的ListView, 横向滚动的GridView, 瀑布流控件，因为RecyclerView能够实现所有这些功能。
比如：有一个需求是屏幕竖着的时候的显示形式是ListView，屏幕横着的时候的显示形式是2列的GridView，此时如果用RecyclerView，则通过设置LayoutManager一行代码实现替换。
RecylerView相对于ListView的优点罗列如下：
RecyclerView封装了viewholder的回收复用，也就是说RecyclerView标准化了ViewHolder，编写Adapter面向的是ViewHolder而不再是View了，复用的逻辑被封装了，写起来更加简单。
直接省去了listview中convertView.setTag(holder)和convertView.getTag()这些繁琐的步骤。提供了一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecyclerView专门抽取出了相应的类，来控制Item的显示，使其的扩展性非常强。设置布局管理器以控制Item的布局方式，横向、竖向以及瀑布流方式
例如：你想控制横向或者纵向滑动列表效果可以通过LinearLayoutManager这个类来进行控制(与GridView效果对应的是GridLayoutManager,与瀑布流对应的还StaggeredGridLayoutManager等)。也就是说RecyclerView不再拘泥于ListView的线性展示方式，它也可以实现GridView的效果等多种效果。可设置Item的间隔样式（可绘制）
通过继承RecyclerView的ItemDecoration这个类，然后针对自己的业务需求去书写代码。可以控制Item增删的动画，可以通过ItemAnimator这个类进行控制，当然针对增删的动画，RecyclerView有其自己默认的实现。 但是关于Item的点击和长按事件，需要用户自己去实现。
基本使用 recyclerView = (RecyclerView) findViewById(R.id.recyclerView); LinearLayoutManager layoutManager = new LinearLayoutManager(this ); //设置布局管理器 recyclerView.setLayoutManager(layoutManager); //设置为垂直布局，这也是默认的 layoutManager.setOrientation(OrientationHelper. VERTICAL); //设置Adapter recyclerView.setAdapter(recycleAdapter); //设置分隔线 recyclerView.addItemDecoration( new DividerGridItemDecoration(this )); //设置增加或删除条目的动画 recyclerView.setItemAnimator( new DefaultItemAnimator()); 在使用RecyclerView时候，必须指定一个适配器Adapter和一个布局管理器LayoutManager。适配器继承RecyclerView.Adapter类，具体实现类似ListView的适配器，取决于数据信息以及展示的UI。布局管理器用于确定RecyclerView中Item的展示方式以及决定何时复用已经不可见的Item，避免重复创建以及执行高成本的findViewById()方法。
可以看见RecyclerView相比ListView会多出许多操作，这也是RecyclerView灵活的地方，它将许多动能暴露出来，用户可以选择性的自定义属性以满足需求。
基本使用 引用 在build.gradle文件中引入该类。
compile &#39;com.android.support:recyclerview-v7:23.4.0&#39; 布局 Activity布局文件activity_rv.xml" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2bacc7e9b9d20302322ef8b03af9dceb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-19T19:49:52+08:00" />
<meta property="article:modified_time" content="2020-10-19T19:49:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 控件 RecyclerView  看这篇就够了</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>【Android 控件 RecyclerView】</h2> 
<h3>概述</h3> 
<h4>RecyclerView是什么</h4> 
<p>从Android 5.0开始，谷歌公司推出了一个用于大量数据展示的新控件RecylerView，可以用来代替传统的ListView，更加强大和灵活。RecyclerView的官方定义如下：</p> 
<blockquote> 
 <p>A flexible view for providing a limited window into a large data set.</p> 
</blockquote> 
<p>从定义可以看出，flexible（可扩展性）是RecyclerView的特点。</p> 
<p>RecyclerView是<strong>support-v7包</strong>中的<strong>新组件</strong>，是一个强大的滑动组件，与经典的ListView相比，同样拥有item回收复用的功能，这一点从它的名字Recyclerview即回收view也可以看出。</p> 
<h4>RecyclerView的优点</h4> 
<p>RecyclerView并不会完全替代ListView（这点从ListView没有被标记为@Deprecated可以看出），两者的使用场景不一样。但是RecyclerView的出现会让很多开源项目被废弃，例如横向滚动的ListView, 横向滚动的GridView, 瀑布流控件，因为RecyclerView能够实现所有这些功能。</p> 
<p>比如：有一个需求是<strong>屏幕竖着</strong>的时候的显示形式是<strong>ListView</strong>，屏幕<strong>横着</strong>的时候的显示形式是2列的<strong>GridView</strong>，此时如果用<strong>RecyclerView</strong>，则通过设置LayoutManager<strong>一行代码实现替换</strong>。</p> 
<p>RecylerView相对于ListView的优点罗列如下：</p> 
<ul><li>RecyclerView<strong>封装了viewholder</strong>的回收复用，也就是说RecyclerView<strong>标准化了ViewHolder</strong>，<strong>编写Adapter面向</strong>的是<strong>ViewHolder</strong>而不再是View了，复用的逻辑被封装了，写起来更加简单。<br> 直接省去了listview中convertView.setTag(holder)和convertView.getTag()这些繁琐的步骤。</li><li>提供了一种<strong>插拔式的体验</strong>，<strong>高度的解耦</strong>，异常的灵活，针对一个Item的显示RecyclerView专门抽取出了<strong>相应的类</strong>，来<strong>控制Item的显示</strong>，使其的扩展性非常强。</li><li>设置<strong>布局管理器</strong>以控制<strong>Item</strong>的<strong>布局方式</strong>，<strong>横向</strong>、<strong>竖向</strong>以及<strong>瀑布流</strong>方式<br> 例如：你想控制横向或者纵向滑动列表效果可以通过<strong>LinearLayoutManager</strong>这个类来进行控制(与GridView效果对应的是<strong>GridLayoutManager</strong>,与<strong>瀑布流</strong>对应的还<strong>StaggeredGridLayoutManager</strong>等)。也就是说RecyclerView不再拘泥于ListView的线性展示方式，它也可以实现GridView的效果等多种效果。</li><li>可设置<strong>Item的间隔样式</strong>（可绘制）<br> 通过<strong>继承RecyclerView的ItemDecoration</strong>这个类，然后针对自己的业务需求去书写代码。</li><li>可以控制<strong>Item增删的动画</strong>，可以通过<strong>ItemAnimator</strong>这个类进行控制，当然针对增删的动画，RecyclerView有其自己默认的实现。</li></ul> 
<p>但是关于Item的点击和长按事件，需要用户自己去实现。</p> 
<h4>基本使用</h4> 
<p> </p> 
<pre><code>recyclerView = (RecyclerView) findViewById(R.id.recyclerView);  
LinearLayoutManager layoutManager = new LinearLayoutManager(this );  
//设置布局管理器  
recyclerView.setLayoutManager(layoutManager);  
//设置为垂直布局，这也是默认的  
layoutManager.setOrientation(OrientationHelper. VERTICAL);  
//设置Adapter  
recyclerView.setAdapter(recycleAdapter);  
 //设置分隔线  
recyclerView.addItemDecoration( new DividerGridItemDecoration(this ));  
//设置增加或删除条目的动画  
recyclerView.setItemAnimator( new DefaultItemAnimator());  
</code></pre> 
<p>在使用RecyclerView时候，必须指定一个适配器Adapter和一个布局管理器LayoutManager。适配器继承<strong><code>RecyclerView.Adapter</code></strong>类，具体实现类似ListView的适配器，取决于数据信息以及展示的UI。布局管理器用于确定RecyclerView中Item的展示方式以及决定何时复用已经不可见的Item，避免重复创建以及执行高成本的<code>findViewById()</code>方法。</p> 
<p>可以看见RecyclerView相比ListView会多出许多操作，这也是RecyclerView灵活的地方，它将许多动能暴露出来，用户可以选择性的自定义属性以满足需求。</p> 
<h3>基本使用</h3> 
<h4>引用</h4> 
<p>在build.gradle文件中<strong>引入该类</strong>。</p> 
<p> </p> 
<pre><code>    compile 'com.android.support:recyclerview-v7:23.4.0'
</code></pre> 
<h4>布局</h4> 
<p>Activity布局文件activity_rv.xml<br> ...</p> 
<p>Item的布局文件item_1.xml<br> ...</p> 
<h4>创建适配器</h4> 
<p>标准实现步骤如下：<br> ① <strong>创建Adapter</strong>：创建一个<strong>继承<code>RecyclerView.Adapter&lt;VH&gt;</code></strong>的Adapter类（VH是ViewHolder的类名）<br> ② <strong>创建ViewHolder</strong>：在Adapter中创建一个<strong>继承<code>RecyclerView.ViewHolder</code></strong>的静态内部类，记为VH。ViewHolder的实现和ListView的ViewHolder实现几乎一样。<br> ③ 在<strong>Adapter中实现3个方法</strong>：</p> 
<ul><li><strong>onCreateViewHolder()</strong><br> 这个方法主要<strong>生成</strong>为<strong>每个Item inflater出一个View</strong>，但是该方法<strong>返回</strong>的是一个<strong>ViewHolder</strong>。该方法把View直接封装在ViewHolder中，然后我们面向的是ViewHolder这个实例，当然这个ViewHolder需要我们自己去编写。</li></ul> 
<p>需要<strong>注意</strong>的是在<code>onCreateViewHolder()</code>中，映射<strong>Layout必须为</strong></p> 
<p> </p> 
<pre><code>View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, parent, false);
</code></pre> 
<p>而不能是：</p> 
<p> </p> 
<pre><code>View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, null);
</code></pre> 
<ul><li><strong>onBindViewHolder()</strong><br> 这个方法主要用于<strong>适配渲染数据到View</strong>中。方法<strong>提供</strong>给你了一<strong>viewHolder</strong>而不是原来的convertView。</li><li><strong>getItemCount()</strong><br> 这个方法就<strong>类似</strong>于BaseAdapter的<strong>getCount</strong>方法了，即总共有多少个条目。</li></ul> 
<p>可以看出，RecyclerView将ListView中<code>getView()</code>的功能拆分成了<code>onCreateViewHolder()</code>和<code>onBindViewHolder()</code>。</p> 
<p>基本的Adapter实现如下：</p> 
<p> </p> 
<pre><code>// ① 创建Adapter
public class NormalAdapter extends RecyclerView.Adapter&lt;NormalAdapter.VH&gt;{
    //② 创建ViewHolder
    public static class VH extends RecyclerView.ViewHolder{
        public final TextView title;
        public VH(View v) {
            super(v);
            title = (TextView) v.findViewById(R.id.title);
        }
    }
    
    private List&lt;String&gt; mDatas;
    public NormalAdapter(List&lt;String&gt; data) {
        this.mDatas = data;
    }

    //③ 在Adapter中实现3个方法
    @Override
    public void onBindViewHolder(VH holder, int position) {
        holder.title.setText(mDatas.get(position));
        holder.itemView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //item 点击事件
            }
        });
    }

    @Override
    public int getItemCount() {
        return mDatas.size();
    }

    @Override
    public VH onCreateViewHolder(ViewGroup parent, int viewType) {
        //LayoutInflater.from指定写法
        View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, parent, false);
        return new VH(v);
    }
}
</code></pre> 
<h4>设置RecyclerView</h4> 
<p>创建完Adapter，接着对RecyclerView进行设置，一般来说，需要为RecyclerView进行<strong>四大设置</strong>，也就是后文说的四大组成：</p> 
<ul><li>Layout Manager(必选)</li><li>Adapter(必选)</li><li>Item Decoration(可选，默认为空)</li><li>Item Animator(可选，默认为DefaultItemAnimator)</li></ul> 
<p>如果要实现ListView的效果，只需要设置Adapter和Layout Manager，如下：</p> 
<p> </p> 
<pre><code>List&lt;String&gt; data = initData();
RecyclerView rv = (RecyclerView) findViewById(R.id.rv);
rv.setLayoutManager(new LinearLayoutManager(this));
rv.setAdapter(new NormalAdapter(data));
</code></pre> 
<h3>四大组成</h3> 
<p>RecyclerView的四大组成是：</p> 
<ul><li>Layout Manager：Item的布局。</li><li>Adapter：为Item提供数据。</li><li>Item Decoration：Item之间的Divider。</li><li>Item Animator：添加、删除Item动画。</li></ul> 
<h4>Layout Manager布局管理器</h4> 
<p>在最开始就提到，RecyclerView 能够支持各种各样的布局效果，这是 ListView 所不具有的功能，那么这个功能如何实现的呢？其核心关键在于 <a href="https://link.jianshu.com?t=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fsupport%2Fv7%2Fwidget%2FRecyclerView.LayoutManager.html" rel="nofollow">RecyclerView.LayoutManager</a> 类中。从前面的基础使用可以看到，RecyclerView 在使用过程中要比 ListView 多一个 setLayoutManager 步骤，这个 LayoutManager 就是用于控制我们 RecyclerView 最终的展示效果的。</p> 
<p>LayoutManager负责RecyclerView的布局，其中包含了Item View的获取与回收。</p> 
<p>RecyclerView提供了<strong>三种布局管理器</strong>：</p> 
<ul><li><strong>LinerLayoutManager</strong> 以<strong>垂直</strong>或者<strong>水平列表</strong>方式展示Item</li><li><strong>GridLayoutManager</strong> 以<strong>网格</strong>方式展示Item</li><li><strong>StaggeredGridLayoutManager</strong> 以<strong>瀑布流</strong>方式展示Item</li></ul> 
<p>如果你想用 RecyclerView 来实现自己<strong>自定义效果</strong>，则应该去<strong>继承实现自己的 LayoutManager</strong>，并重写相应的方法，而不应该想着去改写 RecyclerView。</p> 
<p>LayoutManager 常见 API</p> 
<p>关于 LayoutManager 的使用有下面一些常见的 API（有些在 LayoutManager 实现的子类中）</p> 
<p> </p> 
<pre><code>    canScrollHorizontally();//能否横向滚动
    canScrollVertically();//能否纵向滚动
    scrollToPosition(int position);//滚动到指定位置

    setOrientation(int orientation);//设置滚动的方向
    getOrientation();//获取滚动方向

    findViewByPosition(int position);//获取指定位置的Item View
    findFirstCompletelyVisibleItemPosition();//获取第一个完全可见的Item位置
    findFirstVisibleItemPosition();//获取第一个可见Item的位置
    findLastCompletelyVisibleItemPosition();//获取最后一个完全可见的Item位置
    findLastVisibleItemPosition();//获取最后一个可见Item的位置
</code></pre> 
<p>上面仅仅是列出一些常用的 API 而已，更多的 API 可以查看官方文档，通常你想用 RecyclerView 实现某种效果，例如指定滚动到某个 Item 位置，但是你在 RecyclerView 中又找不到可以调用的 API 时，就可以跑到 LayoutManager 的文档去看看，基本都在那里。<br> 另外还有一点关于瀑布流布局效果 StaggeredGridLayoutManager 想说的，看到网上有些文章写的示例代码，在设置了 StaggeredGridLayoutManager 后仍要去 Adapter 中动态设置 View 的高度，才能实现瀑布流，这种做法是完全错误的，之所以 StaggeredGridLayoutManager 的瀑布流效果出不来，基本是 item 布局的 xml 问题以及数据问题导致。如果要在 Adapter 中设置 View 的高度，则完全违背了 LayoutManager 的设计理念了。</p> 
<p>LinearLayoutManager源码分析</p> 
<p>这里我们简单分析LinearLayoutManager的实现。</p> 
<p>对于LinearLayoutManager来说，比较重要的几个方法有：</p> 
<ul><li><code>onLayoutChildren()</code>: 对RecyclerView进行布局的入口方法。</li><li><code>fill()</code>: 负责填充RecyclerView。</li><li><code>scrollVerticallyBy()</code>:根据手指的移动滑动一定距离，并调用<code>fill()</code>填充。</li><li><code>canScrollVertically()</code>或<code>canScrollHorizontally()</code>: 判断是否支持纵向滑动或横向滑动。</li></ul> 
<p><code>onLayoutChildren()</code>的核心实现如下：</p> 
<p> </p> 
<pre><code>public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
    detachAndScrapAttachedViews(recycler); //将原来所有的Item View全部放到Recycler的Scrap Heap或Recycle Pool
    fill(recycler, mLayoutState, state, false); //填充现在所有的Item View
}
</code></pre> 
<p>RecyclerView的回收机制有个重要的概念，即将回收站分为Scrap Heap和Recycle Pool，其中Scrap Heap的元素可以被直接复用，而不需要调用<code>onBindViewHolder()</code>。<code>detachAndScrapAttachedViews()</code>会根据情况，将原来的Item View放入Scrap Heap或Recycle Pool，从而在复用时提升效率。</p> 
<p><code>fill()</code>是对剩余空间不断地调用<code>layoutChunk()</code>，直到填充完为止。<code>layoutChunk()</code>的核心实现如下：</p> 
<p> </p> 
<pre><code>public void layoutChunk() {
    View view = layoutState.next(recycler); //调用了getViewForPosition()
    addView(view);  //加入View
    measureChildWithMargins(view, 0, 0); //计算View的大小
    layoutDecoratedWithMargins(view, left, top, right, bottom); //布局View
}
</code></pre> 
<p>其中<code>next()</code>调用了<code>getViewForPosition(currentPosition)</code>，该方法是从RecyclerView的回收机制实现类Recycler中获取合适的View，在后文的回收机制中会介绍该方法的具体实现。</p> 
<p>如果要自定义LayoutManager，可以参考：</p> 
<ul><li><a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fhehonghui%2Fandroid-tech-frontier%2Fblob%2Fmaster%2Fissue-9%2F%25E5%2588%259B%25E5%25BB%25BA-RecyclerView-LayoutManager-Part-1.md" rel="nofollow">创建一个 RecyclerView LayoutManager – Part 1</a></li><li><a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fhehonghui%2Fandroid-tech-frontier%2Fblob%2Fmaster%2Fissue-13%2F%25E5%2588%259B%25E5%25BB%25BA-RecyclerView-LayoutManager-Part-2.md" rel="nofollow">创建一个 RecyclerView LayoutManager – Part 2</a></li><li><a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fhehonghui%2Fandroid-tech-frontier%2Fblob%2Fmaster%2Fissue-13%2F%25E5%2588%259B%25E5%25BB%25BA-RecyclerView-LayoutManager-Part-3.md" rel="nofollow">创建一个 RecyclerView LayoutManager – Part 3</a></li></ul> 
<h4>Adapter适配器</h4> 
<p>Adapter的使用方式前面已经介绍了，功能就是为RecyclerView提供数据，这里主要介绍万能适配器的实现。其实万能适配器的概念在ListView就已经存在了，即<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2FJoanZapata%2Fbase-adapter-helper" rel="nofollow">base-adapter-helper</a>。</p> 
<p>这里我们只针对RecyclerView，聊聊万能适配器出现的原因。为了创建一个RecyclerView的Adapter，每次我们都需要去做重复劳动，包括重写<code>onCreateViewHolder()</code>,<code>getItemCount()</code>、创建ViewHolder，并且实现过程大同小异，因此万能适配器出现了。</p> 
<p>万能适配器</p> 
<p>这里讲解下万能适配器的实现思路。</p> 
<p>我们通过<code>public abstract class QuickAdapter&lt;T&gt; extends RecyclerView.Adapter&lt;QuickAdapter.VH&gt;</code>定义万能适配器QuickAdapter类，T是列表数据中每个元素的类型，QuickAdapter.VH是QuickAdapter的ViewHolder实现类，称为万能ViewHolder。</p> 
<p>首先介绍QuickAdapter.VH的实现：</p> 
<p> </p> 
<pre><code>static class VH extends RecyclerView.ViewHolder{
    private SparseArray&lt;View&gt; mViews;
    private View mConvertView;

    private VH(View v){
        super(v);
        mConvertView = v;
        mViews = new SparseArray&lt;&gt;();
    }

    public static VH get(ViewGroup parent, int layoutId){
        View convertView = LayoutInflater.from(parent.getContext()).inflate(layoutId, parent, false);
        return new VH(convertView);
    }

    public &lt;T extends View&gt; T getView(int id){
        View v = mViews.get(id);
        if(v == null){
            v = mConvertView.findViewById(id);
            mViews.put(id, v);
        }
        return (T)v;
    }

    public void setText(int id, String value){
        TextView view = getView(id);
        view.setText(value);
    }
}
</code></pre> 
<p>其中的关键点在于通过<code>SparseArray&lt;View&gt;</code>存储item view的控件，<code>getView(int id)</code>的功能就是通过id获得对应的View（首先在mViews中查询是否存在，如果没有，那么<code>findViewById()</code>并放入mViews中，避免下次再执行<code>findViewById()</code>）。</p> 
<p><strong>QuickAdapter的实现</strong>如下：</p> 
<p> </p> 
<pre><code>public abstract class QuickAdapter&lt;T&gt; extends RecyclerView.Adapter&lt;QuickAdapter.VH&gt;{
    private List&lt;T&gt; mDatas;
    public QuickAdapter(List&lt;T&gt; datas){
        this.mDatas = datas;
    }

    public abstract int getLayoutId(int viewType);

    @Override
    public VH onCreateViewHolder(ViewGroup parent, int viewType) {
        return VH.get(parent,getLayoutId(viewType));
    }

    @Override
    public void onBindViewHolder(VH holder, int position) {
        convert(holder, mDatas.get(position), position);
    }

    @Override
    public int getItemCount() {
        return mDatas.size();
    }

    public abstract void convert(VH holder, T data, int position);
    
    static class VH extends RecyclerView.ViewHolder{
        private SparseArray&lt;View&gt; mViews;
        private View mConvertView;
    
        private VH(View v){
            super(v);
            mConvertView = v;
            mViews = new SparseArray&lt;&gt;();
        }
    
        public static VH get(ViewGroup parent, int layoutId){
            View convertView = LayoutInflater.from(parent.getContext()).inflate(layoutId, parent, false);
            return new VH(convertView);
        }
    
        public &lt;T extends View&gt; T getView(int id){
            View v = mViews.get(id);
            if(v == null){
                v = mConvertView.findViewById(id);
                mViews.put(id, v);
            }
            return (T)v;
        }
    
        public void setText(int id, String value){
            TextView view = getView(id);
            view.setText(value);
        }
    }
}
</code></pre> 
<p>其中：</p> 
<ul><li><code>getLayoutId(int viewType)</code>是根据viewType返回布局ID。</li><li><code>convert()</code>做具体的bind操作。</li></ul> 
<p>就这样，万能适配器实现完成了。</p> 
<p>通过万能适配器能通过以下方式快捷地创建一个Adapter：</p> 
<p> </p> 
<pre><code>mAdapter = new QuickAdapter&lt;String&gt;(data) {
    @Override
    public int getLayoutId(int viewType) {
        return R.layout.item;
    }

    @Override
    public void convert(VH holder, String data, int position) {
        holder.setText(R.id.text, data);
        //holder.itemView.setOnClickListener(); 此处还可以添加点击事件
    }
};
</code></pre> 
<p>是不是很方便。当然复杂情况也可以轻松解决。</p> 
<p> </p> 
<pre><code>mAdapter = new QuickAdapter&lt;Model&gt;(data) {
    @Override
    public int getLayoutId(int viewType) {
        switch(viewType){
            case TYPE_1:
                return R.layout.item_1;
            case TYPE_2:
                return R.layout.item_2;
        }
    }

    @Override
    public int getItemViewType(int position) {
        if(position % 2 == 0){
            return TYPE_1;
        } else{
            return TYPE_2;
        }
    }

    @Override
    public void convert(VH holder, Model data, int position) {
        int type = getItemViewType(position);
        switch(type){
            case TYPE_1:
                holder.setText(R.id.text, data.text);
                break;
            case TYPE_2:
                holder.setImage(R.id.image, data.image);
                break;
        }
    }
};
</code></pre> 
<h4>Item Decoration间隔样式</h4> 
<p>RecyclerView通过<strong><code>addItemDecoration()</code></strong>方法添加item之间的分割线。Android并没有提供实现好的Divider，因此<strong>任何分割线样式都需要自己实现</strong>。</p> 
<p>自定义间隔样式需要继承<strong><code>RecyclerView.ItemDecoration</code></strong>类，该类是个<strong>抽象类</strong>，官方目前并没有提供默认的实现类，主要有三个方法。</p> 
<ul><li><strong>onDraw</strong>(Canvas c, RecyclerView parent, State state)，在<strong>Item绘制之前</strong>被调用，该方法主要用于绘制间隔样式。</li><li><strong>onDrawOver</strong>(Canvas c, RecyclerView parent, State state)，在<strong>Item绘制之前</strong>被调用，该方法主要用于绘制间隔样式。</li><li><strong>getItemOffsets</strong>(Rect outRect, View view, RecyclerView parent, State state)，设置<strong>item的偏移量</strong>，<strong>偏移的部分用于填充间隔样式</strong>，即设置分割线的宽、高；在RecyclerView的<code>onMesure()</code>中会调用该方法。</li></ul> 
<p><code>onDraw()</code>和<code>onDrawOver()</code>这两个方法都是用于绘制间隔样式，我们只需要复写其中一个方法即可。</p> 
<p>Google在sample中给了一个参考的实现类：<a href="https://link.jianshu.com?t=https%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Fdevelopment%2F%252B%2Fmaster%2Fsamples%2FSupport7Demos%2Fsrc%2Fcom%2Fexample%2Fandroid%2Fsupportv7%2Fwidget%2Fdecorator%2FDividerItemDecoration.java" rel="nofollow">DividerItemDecoration</a>，这里我们通过分析这个例子来看如何自定义Item Decoration。</p> 
<p>自定义的间隔样式的实现步骤</p> 
<ul><li>① 通过读取系统主题中的 Android.R.attr.<strong>listDivider</strong>作为Item间的<strong>分割线</strong>，并且支持横向和纵向。<br> 该分割线是系统默认的，你可以在theme.xml中找到该属性（android:listDivider）的使用情况。<br> 如果要设置，则需要在value/styles.xml中设置：</li></ul> 
<p> </p> 
<pre><code>&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;item name="android:listDivider"&gt;@drawable/item_divider&lt;/item&gt;
&lt;/style&gt;
</code></pre> 
<ul><li>② 获取到<strong>listDivider</strong>以后，该属性的值是个<strong>Drawable</strong>，在<strong>getItemOffsets</strong>中，<strong>outRect</strong>去设置了绘制的范围。</li><li>③ <strong>onDraw</strong>中实现了真正的绘制。</li></ul> 
<p>① 获取listDivider</p> 
<p>首先看构造函数，构造函数中获得系统属性<code>android:listDivider</code>，该属性是一个Drawable对象。</p> 
<p> </p> 
<pre><code>private static final int[] ATTRS = new int[]{android.R.attr.listDivider};
private Drawable mDivider;
public DividerItemDecoration(Context context, int orientation) {
    final TypedArray a = context.obtainStyledAttributes(ATTRS);
    mDivider = a.getDrawable(0);
    a.recycle();
    setOrientation(orientation);
}
</code></pre> 
<p>② getItemOffsets</p> 
<p>接着来看<code>getItemOffsets()</code>的实现：</p> 
<p> </p> 
<pre><code>public void getItemOffsets(Rect outRect, int position, RecyclerView parent) {
    if (mOrientation == VERTICAL_LIST) {
        outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());
    } else {
        outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);
    }
}
</code></pre> 
<p>这里只看<code>mOrientation == VERTICAL_LIST</code>的情况，outRect是当前item四周的间距，类似margin属性，现在设置了该item下间距为<code>mDivider.getIntrinsicHeight()</code>。</p> 
<p>那么<code>getItemOffsets()</code>是怎么被调用的呢？</p> 
<p>RecyclerView继承了ViewGroup，并重写了<code>measureChild()</code>，该方法在<code>onMeasure()</code>中被调用，用来计算每个child的大小，计算每个child大小的时候就需要加上<code>getItemOffsets()</code>设置的外间距：</p> 
<p> </p> 
<pre><code>public void measureChild(View child, int widthUsed, int heightUsed){
    final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);//调用getItemOffsets()获得Rect对象
    widthUsed += insets.left + insets.right;
    heightUsed += insets.top + insets.bottom;
    //...
}
</code></pre> 
<p>③ onDraw</p> 
<p>这里我们只考虑<code>mOrientation == VERTICAL_LIST</code>的情况，DividerItemDecoration的<code>onDraw()</code>实际上调用了<code>drawVertical()</code>：</p> 
<p> </p> 
<pre><code>public void drawVertical(Canvas c, RecyclerView parent) {
    final int left = parent.getPaddingLeft();
    final int right = parent.getWidth() - parent.getPaddingRight();
    final int childCount = parent.getChildCount();
    // 画每个item的分割线
    for (int i = 0; i &lt; childCount; i++) {
        final View child = parent.getChildAt(i);
        final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child
                .getLayoutParams();
        final int top = child.getBottom() + params.bottomMargin + Math.round(ViewCompat.getTranslationY(child));
        final int bottom = top + mDivider.getIntrinsicHeight();
        mDivider.setBounds(left, top, right, bottom);/*规定好左上角和右下角*/
        mDivider.draw(c);
    }
}
</code></pre> 
<p>那么<code>onDraw()</code>是怎么被调用的呢？还有ItemDecoration还有一个方法<code>onDrawOver()</code>，该方法也可以被重写，那么<code>onDraw()</code>和<code>onDrawOver()</code>之间有什么关系呢？</p> 
<p>我们来看下面的代码：</p> 
<p> </p> 
<pre><code>class RecyclerView extends ViewGroup{
    public void draw(Canvas c) {
        super.draw(c); //调用View的draw()，该方法会先调用onDraw()，再调用dispatchDraw()绘制children

        final int count = mItemDecorations.size();
        for (int i = 0; i &lt; count; i++) {
            mItemDecorations.get(i).onDrawOver(c, this, mState);
        }
        ...
    }
    public void onDraw(Canvas c) {
        super.onDraw(c);
        final int count = mItemDecorations.size();
        for (int i = 0; i &lt; count; i++) {
            mItemDecorations.get(i).onDraw(c, this, mState);
        }
    }
}
</code></pre> 
<p>根据<a href="https://link.jianshu.com?t=http%3A%2F%2Fa.codekk.com%2Fdetail%2FAndroid%2FlightSky%2F%25E5%2585%25AC%25E5%2585%25B1%25E6%258A%2580%25E6%259C%25AF%25E7%2582%25B9%25E4%25B9%258B%2520View%2520%25E7%25BB%2598%25E5%2588%25B6%25E6%25B5%2581%25E7%25A8%258B" rel="nofollow">View的绘制流程</a>，首先调用RecyclerView重写的<code>draw()</code>方法，随后<code>super.draw()</code>即调用View的<code>draw()</code>，该方法会先调用<code>onDraw()</code>（这个方法在RecyclerView重写了），再调用<code>dispatchDraw()</code>绘制children。因此：ItemDecoration的<code>onDraw()</code>在绘制Item之前调用，ItemDecoration的<code>onDrawOver()</code>在绘制Item之后调用。</p> 
<p>当然，如果只需要实现Item之间相隔一定距离，那么只需要为Item的布局设置margin即可，没必要自己实现ItemDecoration这么麻烦。</p> 
<h4>Item Animator动画</h4> 
<p>RecyclerView能够通过<strong><code>mRecyclerView.setItemAnimator(ItemAnimator animator)</code>设置添加、删除、移动、改变的动画效果</strong>。</p> 
<p>RecyclerView提供了<strong>默认</strong>的ItemAnimator实现类：<strong>DefaultItemAnimator</strong>。如果没有特殊的需求，默认使用这个动画即可。</p> 
<p> </p> 
<pre><code>// 设置Item添加和移除的动画
mRecyclerView.setItemAnimator(new DefaultItemAnimator());
</code></pre> 
<p>下面就添加一下删除和添加Item的动作。在<strong>Adapter里面添加方法</strong>。</p> 
<p> </p> 
<pre><code>public void addNewItem() {
    if(mData == null) {
        mData = new ArrayList&lt;&gt;();
    }
    mData.add(0, "new Item");
  更新数据集不是用adapter.notifyDataSetChanged()而是notifyItemInserted(position)与notifyItemRemoved(position) 否则没有动画效果。 
    notifyItemInserted(0);
}

public void deleteItem() {
    if(mData == null || mData.isEmpty()) {
        return;
    }
    mData.remove(0);
    notifyItemRemoved(0);
}
</code></pre> 
<p>添加事件的处理。</p> 
<p> </p> 
<pre><code>public void onClick(View v) {
    int id = v.getId();
    if(id == R.id.rv_add_item_btn) {
        mAdapter.addNewItem();
        // 由于Adapter内部是直接在首个Item位置做增加操作，增加完毕后列表移动到首个Item位置
        mLayoutManager.scrollToPosition(0);
    } else if(id == R.id.rv_del_item_btn){
        mAdapter.deleteItem();
        // 由于Adapter内部是直接在首个Item位置做删除操作，删除完毕后列表移动到首个Item位置
        mLayoutManager.scrollToPosition(0);
    }
}

</code></pre> 
<p>准备工作完毕后，来看一下运行的效果。</p> 
<p><img alt="" src="https://images2.imgbox.com/9d/2f/votD3o7A_o.png"></p> 
<p> </p> 
<p> </p> 
<p>DefaultItemAnimator源码分析</p> 
<p>这里我们通过分析DefaultItemAnimator的源码来介绍如何自定义Item Animator。</p> 
<p>DefaultItemAnimator继承自SimpleItemAnimator，SimpleItemAnimator继承自ItemAnimator。</p> 
<p>首先我们介绍<strong>ItemAnimator类</strong>的几个重要<strong>方法</strong>：</p> 
<ul><li><strong>animateAppearance</strong>(): 当ViewHolder出现在屏幕上时被调用（可能是<strong>add或move</strong>）。</li><li><strong>animateDisappearance</strong>(): 当ViewHolder消失在屏幕上时被调用（可能是<strong>remove或move</strong>）。</li><li><strong>animatePersistence</strong>(): 在没调用<code>notifyItemChanged()</code>和<code>notifyDataSetChanged()</code>的情况下布局发生改变时被调用。</li><li><strong>animateChange</strong>(): 在显式调用<code>notifyItemChanged()</code>或<code>notifyDataSetChanged()</code>时被调用。</li><li><strong>runPendingAnimations</strong>(): RecyclerView动画的执行方式并不是立即执行，而是每帧执行一次，比如两帧之间添加了多个Item，则会将这些将要执行的动画Pending住，保存在成员变量中，等到下一帧一起执行。该方法执行的前提是前面<code>animateXxx()</code>返回true。</li><li><strong>isRunning</strong>(): 是否有动画要执行或正在执行。</li><li><strong>dispatchAnimationsFinished</strong>(): 当全部动画执行完毕时被调用。</li></ul> 
<p>上面的方法比较难懂，不过没关系，因为Android提供了<strong>SimpleItemAnimator</strong>类（继承自ItemAnimator），该类提供了一系列更易懂的API，在自定义Item Animator时只需要继承SimpleItemAnimator即可：</p> 
<ul><li><strong>animateAdd</strong>(ViewHolder holder): 当Item添加时被调用。</li><li><strong>animateMove</strong>(ViewHolder holder, int fromX, int fromY, int toX, int toY): 当Item移动时被调用。</li><li><strong>animateRemove</strong>(ViewHolder holder): 当Item删除时被调用。</li><li><strong>animateChange</strong>(ViewHolder oldHolder, ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop): 当显式调用<code>notifyItemChanged()</code>或<code>notifyDataSetChanged()</code>时被调用。</li></ul> 
<p>对于以上四个方法，<strong>注意</strong>两点：</p> 
<ul><li>当Xxx动画开始执行前（在<code>runPendingAnimations()</code>中）需要调用<code>dispatchXxxStarting(holder)</code>，执行完后需要调用<code>dispatchXxxFinished(holder)</code>。</li><li>这些方法的内部实际上并不是书写执行动画的代码，而是将需要执行动画的Item全部存入成员变量中，并且返回值为true，然后在<code>runPendingAnimations()</code>中一并执行。</li></ul> 
<p><strong>DefaultItemAnimator</strong>类是RecyclerView提供的默认动画类。我们通过阅读该类源码学习如何自定义Item Animator。我们先看DefaultItemAnimator的<strong>成员变量</strong>：</p> 
<p> </p> 
<pre><code>private ArrayList&lt;ViewHolder&gt; mPendingAdditions = new ArrayList&lt;&gt;();//存放下一帧要执行的一系列add动画
ArrayList&lt;ArrayList&lt;ViewHolder&gt;&gt; mAdditionsList = new ArrayList&lt;&gt;();//存放正在执行的一批add动画
ArrayList&lt;ViewHolder&gt; mAddAnimations = new ArrayList&lt;&gt;(); //存放当前正在执行的add动画

private ArrayList&lt;ViewHolder&gt; mPendingRemovals = new ArrayList&lt;&gt;();
ArrayList&lt;ViewHolder&gt; mRemoveAnimations = new ArrayList&lt;&gt;();

private ArrayList&lt;MoveInfo&gt; mPendingMoves = new ArrayList&lt;&gt;();
ArrayList&lt;ArrayList&lt;MoveInfo&gt;&gt; mMovesList = new ArrayList&lt;&gt;();
ArrayList&lt;ViewHolder&gt; mMoveAnimations = new ArrayList&lt;&gt;();

private ArrayList&lt;ChangeInfo&gt; mPendingChanges = new ArrayList&lt;&gt;();
ArrayList&lt;ArrayList&lt;ChangeInfo&gt;&gt; mChangesList = new ArrayList&lt;&gt;();
ArrayList&lt;ViewHolder&gt; mChangeAnimations = new ArrayList&lt;&gt;();
</code></pre> 
<p>DefaultItemAnimator实现了SimpleItemAnimator的<code>animateAdd()</code>方法，该方法只是将该item添加到mPendingAdditions中，等到<code>runPendingAnimations()</code>中执行。</p> 
<p> </p> 
<pre><code>public boolean animateAdd(final ViewHolder holder) {
    resetAnimation(holder);  //重置清空所有动画
    ViewCompat.setAlpha(holder.itemView, 0); //将要做动画的View先变成透明
    mPendingAdditions.add(holder);
    return true;
}
</code></pre> 
<p>接着看<code>runPendingAnimations()</code>的实现，该方法是执行remove,move,change,add动画，执行顺序为：remove动画最先执行，随后move和change并行执行，最后是add动画。为了简化，我们将remove,move,change动画执行过程省略，只看执行add动画的过程，如下：</p> 
<p> </p> 
<pre><code>public void runPendingAnimations() {
    //1、判断是否有动画要执行，即各个动画的成员变量里是否有值。
    //2、执行remove动画
    //3、执行move动画
    //4、执行change动画，与move动画并行执行
    //5、执行add动画
    if (additionsPending) {
        final ArrayList&lt;ViewHolder&gt; additions = new ArrayList&lt;&gt;();
        additions.addAll(mPendingAdditions);
        mAdditionsList.add(additions);
        mPendingAdditions.clear();
        Runnable adder = new Runnable() {
            @Override
            public void run() {
                for (ViewHolder holder : additions) {
                    animateAddImpl(holder);  //***** 执行动画的方法 *****
                }
                additions.clear();
                mAdditionsList.remove(additions);
            }
        };
        if (removalsPending || movesPending || changesPending) {
            long removeDuration = removalsPending ? getRemoveDuration() : 0;
            long moveDuration = movesPending ? getMoveDuration() : 0;
            long changeDuration = changesPending ? getChangeDuration() : 0;
            long totalDelay = removeDuration + Math.max(moveDuration, changeDuration);
            View view = additions.get(0).itemView;
            ViewCompat.postOnAnimationDelayed(view, adder, totalDelay); //等remove，move，change动画全部做完后，开始执行add动画
        }
    }
}
</code></pre> 
<p>为了防止在执行add动画时外面有新的add动画添加到mPendingAdditions中，从而导致执行add动画错乱，这里将mPendingAdditions的内容移动到局部变量additions中，然后遍历additions执行动画。</p> 
<p>在<code>runPendingAnimations()</code>中，<code>animateAddImpl()</code>是执行add动画的具体方法，其实就是将itemView的透明度从0变到1（在<code>animateAdd()</code>中已经将view的透明度变为0），实现如下：</p> 
<p> </p> 
<pre><code>void animateAddImpl(final ViewHolder holder) {
    final View view = holder.itemView;
    final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);
    mAddAnimations.add(holder);
    animation.alpha(1).setDuration(getAddDuration()).
            setListener(new VpaListenerAdapter() {
                @Override
                public void onAnimationStart(View view) {
                    dispatchAddStarting(holder);  //在开始add动画前调用
                }
                @Override
                public void onAnimationCancel(View view) {
                    ViewCompat.setAlpha(view, 1);
                }

                @Override
                public void onAnimationEnd(View view) {
                    animation.setListener(null);
                    dispatchAddFinished(holder); //在结束add动画后调用
                    mAddAnimations.remove(holder);
                    if (!isRunning()) {
                        dispatchAnimationsFinished(); //结束所有动画后调用
                    }
                }
            }).start();
}
</code></pre> 
<p>开源动画recyclerview-animators</p> 
<p>从DefaultItemAnimator类的实现来看，发现自定义Item Animator好麻烦，需要继承SimpleItemAnimator类，然后实现一堆方法。<br> 别急，<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fwasabeef%2Frecyclerview-animators" rel="nofollow">recyclerview-animators</a>解救你，原因如下：</p> 
<ul><li>首先，<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fwasabeef%2Frecyclerview-animators" rel="nofollow">recyclerview-animators</a>提供了一系列的Animator，比如FadeInAnimator,ScaleInAnimator。</li><li>其次，如果该库中没有你满意的动画，该库提供了BaseItemAnimator类，该类继承自SimpleItemAnimator，进一步封装了自定义Item Animator的代码，使得自定义Item Animator更方便，你只需要关注动画本身。如果要实现DefaultItemAnimator的代码，只需要以下实现：</li></ul> 
<p> </p> 
<pre><code>public class DefaultItemAnimator extends BaseItemAnimator {

  public DefaultItemAnimator() {
  }

  public DefaultItemAnimator(Interpolator interpolator) {
    mInterpolator = interpolator;
  }

  @Override protected void animateRemoveImpl(final RecyclerView.ViewHolder holder) {
    ViewCompat.animate(holder.itemView)
        .alpha(0)
        .setDuration(getRemoveDuration())
        .setListener(new DefaultRemoveVpaListener(holder))
        .setStartDelay(getRemoveDelay(holder))
        .start();
  }

  @Override protected void preAnimateAddImpl(RecyclerView.ViewHolder holder) {
    ViewCompat.setAlpha(holder.itemView, 0); //透明度先变为0
  }

  @Override protected void animateAddImpl(final RecyclerView.ViewHolder holder) {
    ViewCompat.animate(holder.itemView)
        .alpha(1)
        .setDuration(getAddDuration())
        .setListener(new DefaultAddVpaListener(holder))
        .setStartDelay(getAddDelay(holder))
        .start();
  }
}
</code></pre> 
<p>是不是比继承SimpleItemAnimator方便多了。</p> 
<p>局部刷新闪屏问题解决</p> 
<p>对于RecyclerView的Item Animator，有一个常见的坑就是“闪屏问题”。<br> 这个问题的描述是：当Item视图中有图片和文字，当更新文字并调用<code>notifyItemChanged()</code>时，文字改变的同时图片会闪一下。这个问题的原因是当调用<code>notifyItemChanged()</code>时，会调用DefaultItemAnimator的<code>animateChangeImpl()</code>执行change动画，该动画会使得Item的透明度从0变为1，从而造成闪屏。</p> 
<p>解决办法很简单，在<code>rv.setAdapter()</code>之前调用<code>((SimpleItemAnimator)rv.getItemAnimator()).setSupportsChangeAnimations(false)</code><strong>禁用change动画</strong>。</p> 
<h3>点击事件</h3> 
<p>RecyclerView并没有像ListView一样暴露出Item点击事件或者长按事件处理的api，也就是说使用RecyclerView时候，需要我们自己来实现Item的点击和长按等事件的处理。<br> 实现方法有很多：</p> 
<ul><li>可以<strong>监听RecyclerView的Touch事件</strong>然后判断手势做相应的处理，</li><li>也可以通过<strong>在绑定ViewHolder的时候设置监听</strong>，然后通过Apater回调出去</li></ul> 
<p>我们选择第二种方法，更加直观和简单。<br> 看一下Adapter的完整代码。</p> 
<p> </p> 
<pre><code>public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt;{
    // 展示数据
    private ArrayList&lt;String&gt; mData;
    // 事件回调监听
    private MyAdapter.OnItemClickListener onItemClickListener;
    public MyAdapter(ArrayList&lt;String&gt; data) {
        this.mData = data;
    }
    public void updateData(ArrayList&lt;String&gt; data) {
        this.mData = data;
        notifyDataSetChanged();
    }
    // 添加新的Item
    public void addNewItem() {
        if(mData == null) {
            mData = new ArrayList&lt;&gt;();
        }
        mData.add(0, "new Item");
        notifyItemInserted(0);
    }
    // 删除Item
    public void deleteItem() {
        if(mData == null || mData.isEmpty()) {
            return;
        }
        mData.remove(0);
        notifyItemRemoved(0);
    }

    // ① 定义点击回调接口
    public interface OnItemClickListener {
        void onItemClick(View view, int position);
        void onItemLongClick(View view, int position);
    }
    
    // ② 定义一个设置点击监听器的方法
    public void setOnItemClickListener(MyAdapter.OnItemClickListener listener) {
        this.onItemClickListener = listener;
    }

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        // 实例化展示的view
        View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.view_rv_item, parent, false);
        // 实例化viewholder
        ViewHolder viewHolder = new ViewHolder(v);
        return viewHolder;
    }

    @Override
    public void onBindViewHolder(final ViewHolder holder, int position) {
        // 绑定数据
        holder.mTv.setText(mData.get(position));
        //③ 对RecyclerView的每一个itemView设置点击事件
        holder.itemView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(final View v) {
                if(onItemClickListener != null) {
                    int pos = holder.getLayoutPosition();
                    onItemClickListener.onItemClick(holder.itemView, pos);
                }
            }
        });

        holder.itemView.setOnLongClickListener(new View.OnLongClickListener() {
            @Override
            public boolean onLongClick(View v) {
                if(onItemClickListener != null) {
                    int pos = holder.getLayoutPosition();
                    onItemClickListener.onItemLongClick(holder.itemView, pos);
                }
                //表示此事件已经消费，不会触发单击事件
                return true;
            }
        });
    }

    @Override
    public int getItemCount() {
        return mData == null ? 0 : mData.size();
    }

    public static class ViewHolder extends RecyclerView.ViewHolder {
        TextView mTv;
        public ViewHolder(View itemView) {
            super(itemView);
            mTv = (TextView) itemView.findViewById(R.id.item_tv);
        }
    }
}
</code></pre> 
<p>设置Adapter的事件监听。</p> 
<p> </p> 
<pre><code>mAdapter.setOnItemClickListener(new MyAdapter.OnItemClickListener() {
    @Override
    public void onItemClick(View view, int position) {
        Toast.makeText(MDRvActivity.this,"click " + position + " item", Toast.LENGTH_SHORT).show();
    }

    @Override
    public void onItemLongClick(View view, int position) {
        Toast.makeText(MDRvActivity.this,"long click " + position + " item", Toast.LENGTH_SHORT).show();
    }
});
</code></pre> 
<p>最后的实现效果。</p> 
<p><img alt="" src="https://images2.imgbox.com/f7/a6/Ee7BFcx7_o.png"></p> 
<p> </p> 
<p> </p> 
<h3>网格样式</h3> 
<p>RecyclerView展示的样式由布局管理器LayoutManager来控制。<br> 网格样式的管理器是<strong><code>GridLayoutManager</code></strong>，看一下它最常用的两个构造函数以及参数含义。</p> 
<ul><li>GridLayoutManager(Context context, int spanCount) 
  <ul><li>spanCount，每列或者每行的item个数，设置为1，就是列表样式</li><li>该构造函数默认是竖直方向的网格样式</li></ul></li><li>GridLayoutManager(Context context, int spanCount, int orientation,boolean reverseLayout) 
  <ul><li>spanCount，每列或者每行的item个数，设置为1，就是列表样式</li><li>网格样式的方向，水平（OrientationHelper.HORIZONTAL）或者竖直（OrientationHelper.VERTICAL）</li><li>reverseLayout，是否逆向，true：布局逆向展示，false：布局正向显示</li></ul></li></ul> 
<p> </p> 
<pre><code>// 竖直方向的网格样式，每行四个Item
mLayoutManager = new GridLayoutManager(this, 4, OrientationHelper.VERTICAL, false);
mRecyclerView.setLayoutManager(mLayoutManager);
</code></pre> 
<p>运行效果</p> 
<p> </p> 
<p><img alt="" src="https://images2.imgbox.com/fa/fa/KWt3RK0f_o.png"></p> 
<p>网格样式已经显示出来了，和之前遇见的问题一样，没有间隔线，非常丑，间隔线必须加，而且要使用自定义，不使用系统自带的。</p> 
<p>新建文件md_divider.xml，是一个灰色的矩形。</p> 
<p> </p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"
       android:shape="rectangle" &gt;
    &lt;solid android:color="@android:color/darker_gray"/&gt;
    &lt;size android:height="4dp" android:width="4dp"/&gt;
&lt;/shape&gt;
</code></pre> 
<p>在styles.xml中的自定义的应用主题里替换掉listdivider属性。</p> 
<p> </p> 
<pre><code>&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name="android:listDivider"&gt;@drawable/md_divider&lt;/item&gt;
&lt;/style&gt;
</code></pre> 
<p>然后继承<strong><code>RecyclerView.ItemDecoration</code></strong>类，在构造函数里获取自定义的间隔线，复写绘制间隔线的方法。</p> 
<p> </p> 
<pre><code>public class MDGridRvDividerDecoration extends RecyclerView.ItemDecoration {
    private static final int[] ATTRS = new int[]{android.R.attr.listDivider};
    // 用于绘制间隔样式
    private Drawable mDivider;
    
    public MDGridRvDividerDecoration(Context context) {
        // 获取默认主题的属性
        final TypedArray a = context.obtainStyledAttributes(ATTRS);
        mDivider = a.getDrawable(0);
        a.recycle();
    }

    @Override
    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
        // 绘制间隔，每一个item，绘制右边和下方间隔样式
        int childCount = parent.getChildCount();
        int spanCount = ((GridLayoutManager)parent.getLayoutManager()).getSpanCount();
        int orientation = ((GridLayoutManager)parent.getLayoutManager()).getOrientation();
        boolean isDrawHorizontalDivider = true;
        boolean isDrawVerticalDivider = true;
        int extra = childCount % spanCount;
        extra = extra == 0 ? spanCount : extra;
        for(int i = 0; i &lt; childCount; i++) {
            isDrawVerticalDivider = true;
            isDrawHorizontalDivider = true;
            // 如果是竖直方向，最右边一列不绘制竖直方向的间隔
            if(orientation == OrientationHelper.VERTICAL &amp;&amp; (i + 1) % spanCount == 0) {
                isDrawVerticalDivider = false;
            }

            // 如果是竖直方向，最后一行不绘制水平方向间隔
            if(orientation == OrientationHelper.VERTICAL &amp;&amp; i &gt;= childCount - extra) {
                isDrawHorizontalDivider = false;
            }

            // 如果是水平方向，最下面一行不绘制水平方向的间隔
            if(orientation == OrientationHelper.HORIZONTAL &amp;&amp; (i + 1) % spanCount == 0) {
                isDrawHorizontalDivider = false;
            }

            // 如果是水平方向，最后一列不绘制竖直方向间隔
            if(orientation == OrientationHelper.HORIZONTAL &amp;&amp; i &gt;= childCount - extra) {
                isDrawVerticalDivider = false;
            }

            if(isDrawHorizontalDivider) {
                drawHorizontalDivider(c, parent, i);
            }

            if(isDrawVerticalDivider) {
                drawVerticalDivider(c, parent, i);
            }
        }
    }

    @Override
    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
        int spanCount = ((GridLayoutManager) parent.getLayoutManager()).getSpanCount();
        int orientation = ((GridLayoutManager)parent.getLayoutManager()).getOrientation();
        int position = parent.getChildLayoutPosition(view);
        if(orientation == OrientationHelper.VERTICAL &amp;&amp; (position + 1) % spanCount == 0) {
            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());
            return;
        }

        if(orientation == OrientationHelper.HORIZONTAL &amp;&amp; (position + 1) % spanCount == 0) {
            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);
            return;
        }

        outRect.set(0, 0, mDivider.getIntrinsicWidth(), mDivider.getIntrinsicHeight());
    }

    /* 绘制竖直间隔线
     * @param canvas
     * @param parent   父布局，RecyclerView
     * @param position item在父布局中所在的位置     */
    private void drawVerticalDivider(Canvas canvas, RecyclerView parent, int position) {
        final View child = parent.getChildAt(position);
        final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child
                .getLayoutParams();
        final int top = child.getTop() - params.topMargin;
        final int bottom = child.getBottom() + params.bottomMargin + mDivider.getIntrinsicHeight();
        final int left = child.getRight() + params.rightMargin;
        final int right = left + mDivider.getIntrinsicWidth();
        mDivider.setBounds(left, top, right, bottom);
        mDivider.draw(canvas);
    }

    /* 绘制水平间隔线
     * @param canvas
     * @param parent   父布局，RecyclerView
     * @param position item在父布局中所在的位置     */
    private void drawHorizontalDivider(Canvas canvas, RecyclerView parent, int position) {
        final View child = parent.getChildAt(position);
        final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child
                .getLayoutParams();
        final int top = child.getBottom() + params.bottomMargin;
        final int bottom = top + mDivider.getIntrinsicHeight();
        final int left = child.getLeft() - params.leftMargin;
        final int right = child.getRight() + params.rightMargin + mDivider.getIntrinsicWidth();
        mDivider.setBounds(left, top, right, bottom);
        mDivider.draw(canvas);
    }
}
</code></pre> 
<p>设置RecyclerView的间隔线。</p> 
<p> </p> 
<pre><code>mRecyclerView.addItemDecoration(new MDGridRvDividerDecoration(this));
</code></pre> 
<p>运行效果如下图。</p> 
<p><img alt="" src="https://images2.imgbox.com/1f/c2/NVDbedrv_o.png"></p> 
<p>关于网格样式的RecyclerView使用大体和列表样式相同，主要在于间隔线的实现上有些不同，来看一下如果真正的使用自定义的间隔线需要做些什么。</p> 
<ul><li>实现间隔线样式，可以是xml文件也可以是图片</li><li>覆盖应用主题的listdivider属性，使用自定义的间隔线样式</li><li>继承<code>RecyclerView.ItemDecoration</code>类，并实现其中的绘制间隔线方法</li><li>设置RecyclerView间隔线样式</li></ul> 
<h3>瀑布流样式</h3> 
<p>RecyclerView的瀑布流布局管理器是<strong><code>StaggeredGridLayoutManager</code></strong>，它最常用的构造函数就一个，StaggeredGridLayoutManager(int spanCount, int orientation)，spanCount代表每行或每列的Item个数，orientation代表列表的方向，竖直或者水平。</p> 
<p>看在代码中的使用。</p> 
<p> </p> 
<pre><code>// 初始化布局管理器
mLayoutManager = new StaggeredGridLayoutManager(2, OrientationHelper.VERTICAL);
// 设置布局管理器
mRecyclerView.setLayoutManager(mLayoutManager);
// 设置adapter
mRecyclerView.setAdapter(mAdapter);
// 设置间隔样式
mRecyclerView.addItemDecoration(new MDStaggeredRvDividerDecotation(this));
</code></pre> 
<p>要实现瀑布流效果（仅讨论竖直方向的瀑布流样式），每一个Item的高度要有所差别，如果所有的item的高度相同，就和网格样式是一样的展示效果。示例中就实现两中不同高度的Item，一个高度为80dp,一个高度为100dp。</p> 
<p>view_rv_staggered_item.xml布局：</p> 
<p> </p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:tools="http://schemas.android.com/tools"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="80dp"&gt;
    &lt;TextView
        android:id="@+id/item_tv"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="center"
        tools:text="item"/&gt;
&lt;/LinearLayout&gt;
</code></pre> 
<p>view_rv_staggered_item_two.xml布局：</p> 
<p> </p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:tools="http://schemas.android.com/tools"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="100dp"&gt;
    &lt;TextView
        android:id="@+id/item_tv"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="center"
        tools:text="item"/&gt;
&lt;/LinearLayout&gt;
</code></pre> 
<p>Item不同的布局是在Adapter里面绑定的，看一下Adapter的实现。</p> 
<p> </p> 
<pre><code>public class MDStaggeredRvAdapter extends RecyclerView.Adapter&lt;MDStaggeredRvAdapter.ViewHolder&gt; {
    // 展示数据
    private ArrayList&lt;String&gt; mData;
    public MDStaggeredRvAdapter(ArrayList&lt;String&gt; data) {
        this.mData = data;
    }
    public void updateData(ArrayList&lt;String&gt; data) {
        this.mData = data;
        notifyDataSetChanged();
    }

    @Override
    public int getItemViewType(int position) {
        // 瀑布流样式外部设置spanCount为2，在这列设置两个不同的item type，以区分不同的布局
        return position % 2;
    }

    @Override
    public MDStaggeredRvAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        // 实例化展示的view
        View v;
        if(viewType == 1) {
            v = LayoutInflater.from(parent.getContext()).inflate(R.layout.view_rv_staggered_item, parent, false);
        } else {
            v = LayoutInflater.from(parent.getContext()).inflate(R.layout.view_rv_staggered_item_two, parent, false);
        }
        // 实例化viewholder
        ViewHolder viewHolder = new ViewHolder(v);
        return viewHolder;
    }

    @Override
    public void onBindViewHolder(MDStaggeredRvAdapter.ViewHolder holder, int position) {
        // 绑定数据
        holder.mTv.setText(mData.get(position));
    }

    @Override
    public int getItemCount() {
        return mData == null ? 0 : mData.size();
    }

    public static class ViewHolder extends RecyclerView.ViewHolder {

        TextView mTv;

        public ViewHolder(View itemView) {
            super(itemView);
            mTv = (TextView) itemView.findViewById(R.id.item_tv);
        }
    }
}
</code></pre> 
<p>接下来是设置瀑布流样式的间隔线样式的，上面代码中使用的是<code>MDStaggeredRvDividerDecotation</code>类，其实是直接拷贝的网格样式的间隔线绘制类。看一下运行效果。</p> 
<p><img alt="" src="https://images2.imgbox.com/9f/34/9WwUQPQw_o.png"></p> 
<h4>瀑布流间隔样式</h4> 
<p>很奇怪，间隔线并没有按照我们想象中的方式绘制，仔细看瀑布流中Item的分布，发现瀑布流样式的Item分布和网格样式的Item分布有些不同。对比一下两者Item的分布，如下图。</p> 
<p><img alt="" src="https://images2.imgbox.com/a6/d6/ilbOftLG_o.png"></p> 
<p>网格样式的Item分布规律很明显，竖直方向的网格，Item是从左向右从上到下依次按顺序排列分布。</p> 
<p>瀑布流样式的Item分布也是从上到下，从左到右的顺序排列，但是有一个高度的优先级，如果某一列中有一个高度最低的位置为空，最优先在此处添加Item。看第三张图的<code>3 item</code>，因为该位置最低，优先在此处添加Item。</p> 
<p>分析出了瀑布流样式的Item的分布规律，就会发现，按照以往列表样式或者网格样式去设置间隔线是有问题的，因为不知道Item具体的位置，上下左右间隔线是否需要绘制不确定，参考第二张图，其实第三张图的间隔线也有问题，向上滑动就会展示出来。</p> 
<p>目前能考虑到的瀑布流添加间隔线的思路：</p> 
<ul><li>Item布局中设置四周间隔padding/margin</li><li>代码中动态修改ItemView的间隔padding/margin</li></ul> 
<p>设置间隔有两个方法：</p> 
<ul><li>上下左右都设置间隔</li><li>相邻两边设置间隔（左上/左下/右上/右下）</li></ul> 
<p>第一种设置间隔的方法会导致相邻的Item间距是间隔的两倍，第二种设置间隔的方法会导致Item某一个方向上的与父布局边缘无间隔，但是另一个方向与父布局边缘有间隔，例如左上相邻两边设置了间隔，最左边一列的Item左边与父布局边缘有间隔，但是最右边一列Item右边与父布局无间隔，第一行和最后一行的Item也会出现这种情况。</p> 
<p>要解决上面的问题，父布局RecyclerView也需要根据相应的情况设置padding让整个布局的间隔都一致。下面的例子是选择在Item布局中设置间隔，因为可以自己在布局文件中控制颜色比较方便，选择右下两边设置间隔。</p> 
<p>首先修改两个Item的布局文件。<br> view_rv_staggered_item.xml修改背景色和外层间距背景色。</p> 
<p> </p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:tools="http://schemas.android.com/tools"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="@dimen/md_common_view_height"
              android:background="@color/md_divider"
              android:paddingBottom="5dp"
              android:paddingRight="5dp"&gt;
    &lt;TextView
        android:id="@+id/item_tv"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="center"
        android:background="@color/md_white"
        tools:text="item"/&gt;
&lt;/LinearLayout&gt;
</code></pre> 
<p>同样修改view_rv_staggered_item_two.xml。</p> 
<p> </p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:tools="http://schemas.android.com/tools"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="100dp"
              android:paddingBottom="5dp"
              android:paddingRight="5dp"
              android:background="@color/md_divider"&gt;
    &lt;TextView
        android:id="@+id/item_tv"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="center"
        android:background="@color/md_white"
        tools:text="item"/&gt;
&lt;/LinearLayout&gt;

</code></pre> 
<p>最后修改RecyclerView的一些属性。</p> 
<p> </p> 
<pre><code>&lt;android.support.v7.widget.RecyclerView
        android:id="@+id/my_recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="@color/md_divider"
        android:paddingLeft="5dp"
        android:paddingTop="5dp"
        android:fadeScrollbars="true"/&gt;

</code></pre> 
<p>运行一下，看看最后的效果。</p> 
<p><img alt="" src="https://images2.imgbox.com/a4/74/r90XbYEd_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/c9/63/h1zgUn1F_o.png"></p> 
<p>差不多完美的解决了间隔线的问题，有细心的同学可能发现，在RecyclerView滑动的时候上面一直有一条灰色的间隔线，这个可以通过取消xml布局文件中RecyclerView的paddingTop属性去掉顶部灰色的间隔线。</p> 
<h3>拓展RecyclerView</h3> 
<h4>添加HeaderView和FooterView</h4> 
<p>RecyclerView默认没有提供类似<code>addHeaderView()</code>和<code>addFooterView()</code>的API，因此这里介绍如何优雅地实现这两个接口。</p> 
<p>如果你已经实现了一个Adapter，现在想为这个Adapter添加<code>addHeaderView()</code>和<code>addFooterView()</code>接口，则需要在Adapter中添加几个Item Type，然后修改<code>getItemViewType()</code>,<code>onCreateViewHolder()</code>,<code>onBindViewHolder()</code>,<code>getItemCount()</code>等方法，并添加switch语句进行判断。那么如何在不破坏原有Adapter实现的情况下完成呢？</p> 
<p>这里引入<strong>装饰器（Decorator）设计模式</strong>，该设计模式通过组合的方式，在不破话原有类代码的情况下，对原有类的功能进行扩展。</p> 
<p>具体实现思路其实很简单，创建一个继承<code>RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;</code>的类，并重写常见的方法，然后通过引入ITEM TYPE的方式实现：</p> 
<p> </p> 
<pre><code>public class NormalAdapterWrapper extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;{

    enum ITEM_TYPE{
        HEADER,
        FOOTER,
        NORMAL
    }

    private NormalAdapter mAdapter;
    private View mHeaderView;
    private View mFooterView;

    public NormalAdapterWrapper(NormalAdapter adapter){
        mAdapter = adapter;
    }

    @Override
    public int getItemViewType(int position) {
        if(position == 0){
            return ITEM_TYPE.HEADER.ordinal();
        } else if(position == mAdapter.getItemCount() + 1){
            return ITEM_TYPE.FOOTER.ordinal();
        } else{
            return ITEM_TYPE.NORMAL.ordinal();
        }
    }

    @Override
    public int getItemCount() {
        return mAdapter.getItemCount() + 2;
    }

    @Override
    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
        if(position == 0){
            return;
        } else if(position == mAdapter.getItemCount() + 1){
            return;
        } else{
            mAdapter.onBindViewHolder(((NormalAdapter.VH)holder), position - 1);
        }
    }

    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        if(viewType == ITEM_TYPE.HEADER.ordinal()){
            return new RecyclerView.ViewHolder(mHeaderView) {};
        } else if(viewType == ITEM_TYPE.FOOTER.ordinal()){
            return new RecyclerView.ViewHolder(mFooterView) {};
        } else{
            return mAdapter.onCreateViewHolder(parent,viewType);
        }
    }

    public void addHeaderView(View view){
        this.mHeaderView = view;
    }
    public void addFooterView(View view){
        this.mFooterView = view;
    }
}
</code></pre> 
<p>这恰恰满足了我们的需求。我们只需要通过以下方式为原有的Adapter（这里命名为NormalAdapter）添加<code>addHeaderView()</code>和<code>addFooterView()</code>接口：</p> 
<p> </p> 
<pre><code>NormalAdapter adapter = new NormalAdapter(data);
NormalAdapterWrapper newAdapter = new NormalAdapterWrapper(adapter);
View headerView = LayoutInflater.from(this).inflate(R.layout.item_header, mRecyclerView, false);
View footerView = LayoutInflater.from(this).inflate(R.layout.item_footer, mRecyclerView, false);
newAdapter.addFooterView(footerView);
newAdapter.addHeaderView(headerView);
mRecyclerView.setAdapter(newAdapter);
</code></pre> 
<p>是不是看起来特别优雅。</p> 
<h4>添加setEmptyView</h4> 
<p>ListView提供了<code>setEmptyView()</code>设置Adapter数据为空时的View视图。RecyclerView虽然没提供直接的API，但是也可以很简单地实现。</p> 
<ul><li>创建一个继承RecyclerView的类，记为EmptyRecyclerView。</li><li>通过<code>getRootView().addView(emptyView)</code>将空数据时显示的View添加到当前View的层次结构中。</li><li>通过AdapterDataObserver监听RecyclerView的数据变化，如果adapter为空，那么隐藏RecyclerView，显示EmptyView。</li></ul> 
<p>具体实现如下：</p> 
<p> </p> 
<pre><code>public class EmptyRecyclerView extends RecyclerView{
    private View mEmptyView;
    private AdapterDataObserver mObserver = new AdapterDataObserver() {
        @Override
        public void onChanged() {
            Adapter adapter = getAdapter();
            if(adapter.getItemCount() == 0){
                mEmptyView.setVisibility(VISIBLE);
                EmptyRecyclerView.this.setVisibility(GONE);
            } else{
                mEmptyView.setVisibility(GONE);
                EmptyRecyclerView.this.setVisibility(VISIBLE);
            }
        }

        public void onItemRangeChanged(int positionStart, int itemCount) {onChanged();}
        public void onItemRangeMoved(int fromPosition, int toPosition, int itemCount) {onChanged();}
        public void onItemRangeRemoved(int positionStart, int itemCount) {onChanged();}
        public void onItemRangeInserted(int positionStart, int itemCount) {onChanged();}
        public void onItemRangeChanged(int positionStart, int itemCount, Object payload) {onChanged();}
    };

    public EmptyRecyclerView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
    }

    public void setEmptyView(View view){
        this.mEmptyView = view;
        ((ViewGroup)this.getRootView()).addView(mEmptyView); //加入主界面布局
    }

    public void setAdapter(RecyclerView.Adapter adapter){
        super.setAdapter(adapter);
        adapter.registerAdapterDataObserver(mObserver);
        mObserver.onChanged();
    }
}   
</code></pre> 
<p>布局</p> 
<p> </p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"&gt;

    &lt;FrameLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"&gt;

        &lt;me.xiazdong.recyclerviewdemo.demo5.EmptyRecyclerView
            android:id="@+id/rv"
            android:layout_width="match_parent"
            android:layout_height="match_parent" /&gt;

        &lt;TextView
            android:id="@+id/text_empty"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:gravity="center"
            android:text="空数据啊"
            android:visibility="gone" /&gt;
    &lt;/FrameLayout&gt;

    &lt;View
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:background="#333333" /&gt;
&lt;/LinearLayout&gt;
</code></pre> 
<p>Activity中使用</p> 
<p> </p> 
<pre><code>    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_5);
        mRv = (EmptyRecyclerView) findViewById(R.id.rv);
        mRv.setLayoutManager(new LinearLayoutManager(this));
        mData = new ArrayList&lt;&gt;();
        mAdapter = new NormalAdapter(mData);
        //View view = LayoutInflater.from(this).inflate(R.layout.empty, null);
        View view = findViewById(R.id.text_empty);
        mRv.setEmptyView(view);
        mRv.setAdapter(mAdapter);
    }
</code></pre> 
<h4>拖拽、侧滑删除</h4> 
<p>Android提供了ItemTouchHelper类，使得RecyclerView能够轻易地实现滑动和拖拽，此处我们要实现上下拖拽和侧滑删除。</p> 
<p>① 创建ItemTouchHelper.Callback类</p> 
<p>首先<strong>创建</strong>一个<strong>继承自<code>ItemTouchHelper.Callback</code>的类</strong>，并重写以下方法：</p> 
<ul><li><strong><code>getMovementFlags()</code></strong>: 设置<strong>支持</strong>的拖拽和滑动的<strong>方向</strong>，此处我们支持的拖拽方向为上下，滑动方向为从左到右和从右到左，内部通过<code>makeMovementFlags()</code>设置。</li><li><strong><code>onMove()</code></strong>: 拖拽时回调。</li><li><strong><code>onSwiped()</code></strong>: 滑动时回调。</li><li><strong><code>onSelectedChanged()</code></strong>: 状态变化时回调，一共有三个状态，分别是ACTION_STATE_<strong>IDLE</strong>(空闲状态)，ACTION_STATE_<strong>SWIPE</strong>(滑动状态)，ACTION_STATE_<strong>DRAG</strong>(拖拽状态)。此方法中可以做一些状态变化时的处理，比如拖拽的时候修改背景色。</li><li><strong><code>clearView()**</code>: 用户</strong>交互结束**时回调。此方法可以做一些状态的清空，比如拖拽结束后还原背景色。</li><li><strong><code>isLongPressDragEnabled()</code></strong>: 是否支持长按拖拽，默认为true。如果不想支持长按拖拽，则重写并返回false。</li></ul> 
<p>具体实现如下：</p> 
<p> </p> 
<pre><code>public class SimpleItemTouchCallback extends ItemTouchHelper.Callback {

    private NormalAdapter mAdapter;
    private List&lt;ObjectModel&gt; mData;
    public SimpleItemTouchCallback(NormalAdapter adapter, List&lt;ObjectModel&gt; data){
        mAdapter = adapter;
        mData = data;
    }

    //设置支持的拖拽、滑动的方向
    @Override
    public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {
        int dragFlag = ItemTouchHelper.UP | ItemTouchHelper.DOWN; //s上下拖拽
        int swipeFlag = ItemTouchHelper.START | ItemTouchHelper.END; //左-&gt;右和右-&gt;左滑动
        return makeMovementFlags(dragFlag,swipeFlag);
    }

    @Override
    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) {
        int from = viewHolder.getAdapterPosition();
        int to = target.getAdapterPosition();
        Collections.swap(mData, from, to);
        mAdapter.notifyItemMoved(from, to);
        return true;
    }

    @Override
    public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {
        int pos = viewHolder.getAdapterPosition();
        mData.remove(pos);
        mAdapter.notifyItemRemoved(pos);
    }

    //状态改变时回调
    @Override
    public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) {
        super.onSelectedChanged(viewHolder, actionState);
        if(actionState != ItemTouchHelper.ACTION_STATE_IDLE){
            NormalAdapter.VH holder = (NormalAdapter.VH)viewHolder;
            holder.itemView.setBackgroundColor(0xffbcbcbc); //设置拖拽和侧滑时的背景色
        }
    }

    //拖拽或滑动完成之后调用，用来清除一些状态
    @Override
    public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {
        super.clearView(recyclerView, viewHolder);
        NormalAdapter.VH holder = (NormalAdapter.VH)viewHolder;
        holder.itemView.setBackgroundColor(0xffeeeeee); //背景色还原
    }
}
</code></pre> 
<p>② 设置ItemTouchHelper给RecyclerView</p> 
<p>然后通过以下代码为RecyclerView设置该滑动、拖拽功能：</p> 
<p> </p> 
<pre><code>ItemTouchHelper helper = new ItemTouchHelper(new SimpleItemTouchCallback(adapter, data));
helper.attachToRecyclerView(recyclerview);
</code></pre> 
<p>触摸拖拽</p> 
<p>前面拖拽的触发方式只有长按，如果想支持触摸Item中的某个View实现拖拽，则核心方法为<code>helper.startDrag(holder)</code>。首先定义接口：</p> 
<p> </p> 
<pre><code>interface OnStartDragListener{
    void startDrag(RecyclerView.ViewHolder holder);
}
</code></pre> 
<p>然后让Activity实现该接口：</p> 
<p> </p> 
<pre><code>public MainActivity extends Activity implements OnStartDragListener{
    ...
    public void startDrag(RecyclerView.ViewHolder holder) {
        mHelper.startDrag(holder);
    }
}
</code></pre> 
<p>如果要对ViewHolder的text对象支持触摸拖拽，则在Adapter中的<code>onBindViewHolder()</code>中添加：</p> 
<p> </p> 
<pre><code>holder.text.setOnTouchListener(new View.OnTouchListener() {
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        if(event.getAction() == MotionEvent.ACTION_DOWN){
            mListener.startDrag(holder);
        }
        return false;
    }
});
</code></pre> 
<p>其中mListener是在创建Adapter时将实现OnStartDragListener接口的Activity对象作为参数传进来。</p> 
<p><strong>完整代码</strong>如下：</p> 
<p> </p> 
<pre><code>public class NormalAdapter extends RecyclerView.Adapter&lt;NormalAdapter.VH&gt;{

    private List&lt;ObjectModel&gt; mDatas;
    private OnStartDragListener mListener;
    public NormalAdapter(List&lt;ObjectModel&gt; data, OnStartDragListener listener) {
        this.mDatas = data;
        mListener = listener;
    }

    @Override
    public void onBindViewHolder(final VH holder, int position) {
        ObjectModel model = mDatas.get(position);
        holder.title.setText(model.title);
        holder.number.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                if(event.getAction() == MotionEvent.ACTION_DOWN){
                    mListener.startDrag(holder);
                }
                return false;
            }
        });
    }

    @Override
    public int getItemCount() {
        return mDatas.size();
    }

    @Override
    public VH onCreateViewHolder(ViewGroup parent, int viewType) {
        View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_3, parent, false);
        return new VH(v);
    }

    public static class VH extends RecyclerView.ViewHolder{
        public final TextView title;
        public final ImageView number;
        public VH(View v) {
            super(v);
            title = (TextView) v.findViewById(R.id.title);
            number = (ImageView) v.findViewById(R.id.icon);
        }
    }
}
</code></pre> 
<p> </p> 
<pre><code>public class Activity3 extends AppCompatActivity implements OnStartDragListener{
    private RecyclerView mRv;
    private NormalAdapter mAdapter;
    private ItemTouchHelper mHelper;
    private List&lt;ObjectModel&gt; mData;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_3);
        mRv = (RecyclerView) findViewById(R.id.rv);
        mRv.setLayoutManager(new LinearLayoutManager(this));
        mAdapter = new NormalAdapter(mData = initData(), this);
        mRv.setAdapter(mAdapter);
        mHelper = new ItemTouchHelper(new SimpleItemTouchCallback(mAdapter, mData));
        mHelper.attachToRecyclerView(mRv);

    }

    public ArrayList&lt;ObjectModel&gt; initData(){
        ArrayList&lt;ObjectModel&gt; models = new ArrayList&lt;&gt;();
        String[] titles = getResources().getStringArray(R.array.title_array);
        for(int i=0;i&lt;titles.length;i++){
            ObjectModel model = new ObjectModel();
            model.number = i + 1;
            model.title = titles[i];
            models.add(model);
        }
        return models;
    }

    @Override
    public void startDrag(RecyclerView.ViewHolder holder) {
        mHelper.startDrag(holder);
    }
}

interface OnStartDragListener{
    void startDrag(RecyclerView.ViewHolder holder);
}
</code></pre> 
<h4>嵌套滑动机制</h4> 
<p>Android 5.0推出了嵌套滑动机制，在之前，一旦子View处理了触摸事件，父View就没有机会再处理这次的触摸事件，而嵌套滑动机制解决了这个问题，能够实现如下效果：</p> 
<p><img alt="" src="https://images2.imgbox.com/b0/c9/uM1KwEmZ_o.png"></p> 
<p>为了支持嵌套滑动，<strong>子View</strong>必须<strong>实现NestedScrollingChild</strong>接口，<strong>父View</strong>必<strong>须实现NestedScrollingParent</strong>接口。<br> 而RecyclerView实现了NestedScrollingChild接口，而CoordinatorLayout实现了NestedScrollingParent接口，上图是实现CoordinatorLayout嵌套RecyclerView的效果。</p> 
<p>为了实现上图的效果，需要用到的组件有：</p> 
<ul><li>CoordinatorLayout: 布局根元素。</li><li>AppBarLayout: 包裹的内容作为应用的Bar。</li><li>CollapsingToolbarLayout: 实现可折叠的ToolBar。</li><li>ToolBar: 代替ActionBar。</li></ul> 
<p>实现中需要注意的点有：</p> 
<ul><li>我们为ToolBar的<code>app:layout_collapseMode</code>设置为pin，表示折叠之后固定在顶端，而为ImageView的<code>app:layout_collapseMode</code>设置为parallax，表示视差模式，即渐变的效果。</li><li>为了让RecyclerView支持嵌套滑动，还需要为它设置<code>app:layout_behavior="@string/appbar_scrolling_view_behavior"</code>。</li><li>为CollapsingToolbarLayout设置<code>app:layout_scrollFlags="scroll|exitUntilCollapsed"</code>，其中scroll表示滚动出屏幕，exitUntilCollapsed表示退出后折叠。</li></ul> 
<p>具体实现参见Demo6。<br> 布局：</p> 
<p> </p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;android.support.design.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;

    &lt;android.support.design.widget.AppBarLayout
        android:id="@+id/appbar"
        android:layout_width="match_parent"
        android:layout_height="256dp"
        android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
        android:fitsSystemWindows="true"&gt;

        &lt;android.support.design.widget.CollapsingToolbarLayout
            android:id="@+id/collapsing_toolbar"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            app:layout_scrollFlags="scroll|exitUntilCollapsed"
            android:fitsSystemWindows="true"
            app:contentScrim="?attr/colorPrimary"
            app:expandedTitleMarginStart="48dp"
            app:expandedTitleMarginEnd="64dp"&gt;
        &lt;ImageView
            android:id="@+id/backdrop"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:scaleType="centerCrop"
            android:fitsSystemWindows="true"
            android:src="@drawable/s8"
            app:layout_collapseMode="parallax"
            /&gt;
            &lt;android.support.v7.widget.Toolbar
                android:id="@+id/toolbar"
                android:layout_width="match_parent"
                android:layout_height="?attr/actionBarSize"
                app:popupTheme="@style/ThemeOverlay.AppCompat.Light"
                app:layout_collapseMode="pin"
                /&gt;
        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;
    &lt;/android.support.design.widget.AppBarLayout&gt;
    &lt;android.support.v7.widget.RecyclerView
        android:id="@+id/rv"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior"
        /&gt;
&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre> 
<p>适配器：</p> 
<p> </p> 
<pre><code>public abstract class QuickAdapter&lt;T&gt; extends RecyclerView.Adapter&lt;QuickAdapter.VH&gt;{

    private List&lt;T&gt; mDatas;

    public QuickAdapter(List&lt;T&gt; datas){
        this.mDatas = datas;
    }

    public abstract int getLayoutId(int viewType);

    @Override
    public VH onCreateViewHolder(ViewGroup parent, int viewType) {
        return VH.get(parent,getLayoutId(viewType));
    }

    @Override
    public void onBindViewHolder(VH holder, int position) {
        convert(holder, mDatas.get(position), position);
    }

    @Override
    public int getItemCount() {
        return mDatas.size();
    }

    public abstract void convert(VH holder, T data, int position);

    static class VH extends RecyclerView.ViewHolder{
        private SparseArray&lt;View&gt; mViews;
        private View mConvertView;

        private VH(View v){
            super(v);
            mConvertView = v;
            mViews = new SparseArray&lt;&gt;();
        }

        public static VH get(ViewGroup parent, int layoutId){
            View convertView = LayoutInflater.from(parent.getContext()).inflate(layoutId, parent, false);
            return new VH(convertView);
        }

        public &lt;T extends View&gt; T getView(int id){
            View v = mViews.get(id);
            if(v == null){
                v = mConvertView.findViewById(id);
                mViews.put(id, v);
            }
            return (T)v;
        }

        public void setText(int id, String value){
            TextView view = getView(id);
            view.setText(value);
        }
    }
}
</code></pre> 
<p>Activity：</p> 
<p> </p> 
<pre><code>public class Activity6 extends AppCompatActivity {
    private RecyclerView mRv;
    private QuickAdapter&lt;Integer&gt; mAdapter;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_6);

        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);

        mRv = (RecyclerView) findViewById(R.id.rv);
        mRv.setLayoutManager(new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL));
        mAdapter = new QuickAdapter&lt;Integer&gt;(initData()) {
            @Override
            public int getLayoutId(int viewType) {
                return R.layout.item_6;
            }

            @Override
            public void convert(VH holder, Integer data, int position) {
                ImageView imageView = holder.getView(R.id.image);
                Picasso.with(Activity6.this).load(data).into(imageView);
                //holder.itemView.setOnClickListener();  此处添加点击事件
            }

            @Override
            public int getItemViewType(int position) {
                return super.getItemViewType(position);
            }
        };
        mAdapter.setHasStableIds(true);
        ((SimpleItemAnimator)mRv.getItemAnimator()).setSupportsChangeAnimations(false);
        mRv.setAdapter(mAdapter);

    }

    public List&lt;Integer&gt; initData(){
        Integer[] images = {R.drawable.s1, R.drawable.s2, R.drawable.s3, R.drawable.s4, R.drawable.s5,
                        R.drawable.s6, R.drawable.s7, R.drawable.s8, R.drawable.s9, R.drawable.s10
                };
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        for(int i=0;i&lt;2;i++){
            for(Integer image:images){
                list.add(image);
            }
        }
        return list;
    }
}
</code></pre> 
<h3>总结</h3> 
<ul><li>水平列表展示，设置LayoutManager的方向性</li><li>竖直列表展示，设置LayoutManager的方向性</li><li>自定义间隔，RecyclerView.addItemDecoration()</li><li>Item添加和删除动画,RecyclerView.setItemAnimator()</li><li><strong>网格</strong>样式的布局管理器<strong>GridLayoutManager</strong>的spanCount设置为1，就是列表样式</li><li>瀑布流样式如果Item的布局文件是等高，竖直方向，就是竖直方向的网格样式；如果Item是等宽，水平方向，那就是水平方向的网络样式</li><li>如果<strong>瀑布流</strong>样式的布局管理器<strong>StaggeredGridLayoutManager</strong>的spanCount设置为1，竖直方向，是竖直方向的列表；水平方向，就是水平方向的列表</li></ul> 
<h2>RecyclerView vs ListView</h2> 
<p><strong>ListView</strong>相比RecyclerView，有一些<strong>优点</strong>：</p> 
<ul><li><strong><code>addHeaderView()</code></strong>, <strong><code>addFooterView()</code></strong>添加头视图和尾视图。</li><li>通过<strong>”android:divider”</strong>设置自定义分割线。</li><li><strong><code>setOnItemClickListener()</code></strong>和<strong><code>setOnItemLongClickListener()</code></strong>设置点击事件和长按事件。</li></ul> 
<p>这些功能在RecyclerView中都没有直接的接口，要自己实现（虽然实现起来很简单），因此如果只是实现简单的显示功能，ListView无疑更简单。</p> 
<p><strong>RecyclerView</strong>相比ListView，有一些明显的<strong>优点</strong>：</p> 
<ul><li>默认<strong>已</strong>经<strong>实现</strong>了<strong>View</strong>的<strong>复用</strong>，不需要类似<code>if(convertView == null)</code>的实现，而且回收机制更加完善。</li><li>默认<strong>支持局部刷新</strong>。</li><li>容易实现<strong>添加item、删除item</strong>的<strong>动画</strong>效果。</li><li>容易实现<strong>拖拽、侧滑删除</strong>等功能。</li></ul> 
<p>RecyclerView是一个插件式的实现，对各个功能进行解耦，从而扩展性比较好。</p> 
<h4>局部刷新</h4> 
<h4>ListView实现局部刷新</h4> 
<p>我们都知道ListView通过<code>adapter.notifyDataSetChanged()</code>实现ListView的更新，这种更新方法的缺点是<strong>全局更新</strong>，即对每个Item View都进行重绘。但事实上很多时候，我们只是更新了其中一个Item的数据，其他Item其实可以不需要重绘。</p> 
<p>这里给出ListView实现局部更新的方法：</p> 
<p> </p> 
<pre><code>public void updateItemView(ListView listview, int position, Data data){
    int firstPos = listview.getFirstVisiblePosition();
    int lastPos = listview.getLastVisiblePosition();
    if(position &gt;= firstPos &amp;&amp; position &lt;= lastPos){  //可见才更新，不可见则在getView()时更新
        //listview.getChildAt(i)获得的是当前可见的第i个item的view
        View view = listview.getChildAt(position - firstPos);
        VH vh = (VH)view.getTag();
        vh.text.setText(data.text);
    }
}
</code></pre> 
<p>可以看出，我们通过ListView的<code>getChildAt()</code>来获得需要更新的View，然后通过<code>getTag()</code>获得ViewHolder，从而实现更新。</p> 
<h4>RecyclerView实现局部刷新</h4> 
<p>RecyclerView提供了<code>notifyItemInserted()</code>,<code>notifyItemRemoved()</code>,<code>notifyItemChanged()</code>等API更新单个或某个范围的Item视图。</p> 
<h3>缓存机制</h3> 
<p>ListView与RecyclerView缓存机制原理大致相似，如下图所示：</p> 
<p><img alt="" src="https://images2.imgbox.com/12/3b/bjD9P7T9_o.png"></p> 
<p>image</p> 
<p>过程中，离屏的ItemView即被回收至缓存，入屏的ItemView则会优先从缓存中获取，只是ListView与RecyclerView的实现细节有差异.（这只是缓存使用的其中一个场景，还有如刷新等）</p> 
<h4>缓存机制对比</h4> 
<p>1. 层级不同：</p> 
<p>RecyclerView比ListView多两级缓存，支持多个离ItemView缓存，支持开发者自定义缓存处理逻辑，支持所有RecyclerView共用同一个RecyclerViewPool(缓存池)。</p> 
<p>具体来说：<br> ListView(两级缓存)：</p> 
<p><img alt="" src="https://images2.imgbox.com/ef/d4/F0yd7p5j_o.png"></p> 
<p>image</p> 
<p>RecyclerView(四级缓存)：</p> 
<p><img alt="" src="https://images2.imgbox.com/3b/b2/Ml8N0mNA_o.png"></p> 
<p>image</p> 
<p>ListView和RecyclerView缓存机制基本一致：</p> 
<p>1). mActiveViews和mAttachedScrap功能相似，意义在于快速重用屏幕上可见的列表项ItemView，而不需要重新createView和bindView；</p> 
<p>2). mScrapView和mCachedViews + mReyclerViewPool功能相似，意义在于缓存离开屏幕的ItemView，目的是让即将进入屏幕的ItemView重用.</p> 
<p>3). RecyclerView的优势在于</p> 
<ul><li>mCacheViews的使用，可以做到屏幕外的列表项ItemView进入屏幕内时也无须bindView快速重用；</li><li>mRecyclerPool可以供多个RecyclerView共同使用，在特定场景下，如viewpaper+多个列表页下有优势。</li></ul> 
<p>客观来说，RecyclerView在特定场景下对ListView的缓存机制做了补强和完善。</p> 
<p>2. 缓存不同：</p> 
<p>1). RecyclerView缓存RecyclerView.ViewHolder，抽象可理解为：<br> View + ViewHolder(避免每次createView时调用findViewById) + flag(标识状态)；<br> 2). ListView缓存View。</p> 
<p>缓存不同，二者在缓存的使用上也略有差别，具体来说：<br> ListView获取缓存的流程：</p> 
<p><img alt="" src="https://images2.imgbox.com/85/85/JOGMmpsJ_o.png"></p> 
<p>image</p> 
<p>RecyclerView获取缓存的流程：</p> 
<p><img alt="" src="https://images2.imgbox.com/a8/13/33zX9Fcx_o.png"></p> 
<p>image</p> 
<p>1). RecyclerView中mCacheViews(屏幕外)获取缓存时，是通过匹配pos获取目标位置的缓存，这样做的好处是，当数据源数据不变的情况下，无须重新bindView：</p> 
<p><img alt="" src="https://images2.imgbox.com/db/5d/bEj2l87U_o.png"></p> 
<p> </p> 
<p>而同样是离屏缓存，ListView从mScrapViews根据pos获取相应的缓存，但是并没有直接使用，而是重新getView（即必定会重新bindView），相关代码如下：</p> 
<p> </p> 
<pre><code>//AbsListView源码：line2345
//通过匹配pos从mScrapView中获取缓存
final View scrapView = mRecycler.getScrapView(position);
//无论是否成功都直接调用getView,导致必定会调用createView
final View child = mAdapter.getView(position, scrapView, this);
if (scrapView != null) {
    if (child != scrapView) {
        mRecycler.addScrapView(scrapView, position);
    } else {
        ...
    }
}
</code></pre> 
<p>2). ListView中通过pos获取的是view，即pos–&gt;view；<br> RecyclerView中通过pos获取的是viewholder，即pos –&gt; (view，viewHolder，flag)；<br> 从流程图中可以看出，标志flag的作用是判断view是否需要重新bindView，这也是RecyclerView实现局部刷新的一个核心.</p> 
<h4>局部刷新</h4> 
<p>由上文可知，RecyclerView的缓存机制确实更加完善，但还不算质的变化，RecyclerView更大的亮点在于提供了局部刷新的接口，通过局部刷新，就能避免调用许多无用的bindView.</p> 
<p><img alt="" src="https://images2.imgbox.com/fe/8e/0WEW0IWh_o.png"></p> 
<p><br> (RecyclerView和ListView添加，移除Item效果对比)</p> 
<p> </p> 
<p>结合RecyclerView的缓存机制，看看局部刷新是如何实现的：<br> 以RecyclerView中notifyItemRemoved(1)为例，最终会调用requestLayout()，使整个RecyclerView重新绘制，过程为：<br> onMeasure()–&gt;onLayout()–&gt;onDraw()</p> 
<p>其中，onLayout()为重点，分为三步：</p> 
<ol><li>dispathLayoutStep1()：记录RecyclerView刷新前列表项ItemView的各种信息，如Top,Left,Bottom,Right，用于动画的相关计算；</li><li>dispathLayoutStep2()：真正测量布局大小，位置，核心函数为layoutChildren()；</li><li>dispathLayoutStep3()：计算布局前后各个ItemView的状态，如Remove，Add，Move，Update等，如有必要执行相应的动画.</li></ol> 
<p>其中，layoutChildren()流程图：</p> 
<p><img alt="" src="https://images2.imgbox.com/0b/83/BnYcPa0F_o.png"></p> 
<p>image</p> 
<p><img alt="" src="https://images2.imgbox.com/27/67/DWHFTjTe_o.png"></p> 
<p>image</p> 
<p>当调用notifyItemRemoved时，会对屏幕内ItemView做预处理，修改ItemView相应的pos以及flag(流程图中红色部分)：</p> 
<p><img alt="" src="https://images2.imgbox.com/66/c6/uYKMfsw8_o.png"></p> 
<p>image</p> 
<p>当调用fill()中RecyclerView.getViewForPosition(pos)时，RecyclerView通过对pos和flag的预处理，使得bindview只调用一次.</p> 
<p>需要指出，ListView和RecyclerView最大的区别在于数据源改变时的缓存的处理逻辑，ListView是”一锅端”，将所有的mActiveViews都移入了二级缓存mScrapViews，而RecyclerView则是更加灵活地对每个View修改标志位，区分是否重新bindView。</p> 
<h4>回收机制源码分析</h4> 
<p>ListView回收机制</p> 
<p>ListView为了保证Item View的复用，实现了一套回收机制，该回收机制的实现类是RecycleBin，他实现了两级缓存：</p> 
<ul><li><code>View[] mActiveViews</code>: 缓存屏幕上的View，在该缓存里的View不需要调用<code>getView()</code>。</li><li><code>ArrayList&lt;View&gt;[] mScrapViews;</code>: 每个Item Type对应一个列表作为回收站，缓存由于滚动而消失的View，此处的View如果被复用，会以参数的形式传给<code>getView()</code>。</li></ul> 
<p>接下来我们通过源码分析ListView是如何与RecycleBin交互的。其实ListView和RecyclerView的layout过程大同小异，ListView的布局函数是<code>layoutChildren()</code>，实现如下：</p> 
<p> </p> 
<pre><code>void layoutChildren(){
    //1. 如果数据被改变了，则将所有Item View回收至scrapView  
  //（而RecyclerView会根据情况放入Scrap Heap或RecyclePool）；否则回收至mActiveViews
    if (dataChanged) {
        for (int i = 0; i &lt; childCount; i++) {
            recycleBin.addScrapView(getChildAt(i), firstPosition+i);
        }
    } else {
        recycleBin.fillActiveViews(childCount, firstPosition);
    }
    //2. 填充
    switch(){
        case LAYOUT_XXX:
            fillXxx();
            break;
        case LAYOUT_XXX:
            fillXxx();
            break;
    }
    //3. 回收多余的activeView
    mRecycler.scrapActiveViews();
}
</code></pre> 
<p>其中<code>fillXxx()</code>实现了对Item View进行填充，该方法内部调用了<code>makeAndAddView()</code>，实现如下：</p> 
<p> </p> 
<pre><code>View makeAndAddView(){
    if (!mDataChanged) {
        child = mRecycler.getActiveView(position);
        if (child != null) {
            return child;
        }
    }
    child = obtainView(position, mIsScrap);
    return child;
}
</code></pre> 
<p>其中，<code>getActiveView()</code>是从mActiveViews中获取合适的View，如果获取到了，则直接返回，而不调用<code>obtainView()</code>，这也印证了如果从mActiveViews获取到了可复用的View，则不需要调用<code>getView()</code>。</p> 
<p><code>obtainView()</code>是从mScrapViews中获取合适的View，然后以参数形式传给了<code>getView()</code>，实现如下：</p> 
<p> </p> 
<pre><code>View obtainView(int position){
    final View scrapView = mRecycler.getScrapView(position);  //从RecycleBin中获取复用的View
    final View child = mAdapter.getView(position, scrapView, this);
}
</code></pre> 
<p>接下去我们介绍<code>getScrapView(position)</code>的实现，该方法通过position得到Item Type，然后根据Item Type从mScrapViews获取可复用的View，如果获取不到，则返回null，具体实现如下：</p> 
<p> </p> 
<pre><code>class RecycleBin{
    private View[] mActiveViews;    //存储屏幕上的View
    private ArrayList&lt;View&gt;[] mScrapViews;  //每个item type对应一个ArrayList
    private int mViewTypeCount;            //item type的个数
    private ArrayList&lt;View&gt; mCurrentScrap;  //mScrapViews[0]

    View getScrapView(int position) {
        final int whichScrap = mAdapter.getItemViewType(position);
        if (whichScrap &lt; 0) {
            return null;
        }
        if (mViewTypeCount == 1) {
            return retrieveFromScrap(mCurrentScrap, position);
        } else if (whichScrap &lt; mScrapViews.length) {
            return retrieveFromScrap(mScrapViews[whichScrap], position);
        }
        return null;
    }
    private View retrieveFromScrap(ArrayList&lt;View&gt; scrapViews, int position){
        int size = scrapViews.size();
        if(size &gt; 0){
            return scrapView.remove(scrapViews.size() - 1);  //从回收列表中取出最后一个元素复用
        } else{
            return null;
        }
    }
}
</code></pre> 
<p>RecyclerView回收机制</p> 
<p>RecyclerView和ListView的回收机制非常相似，但是<strong>ListView是以View作为单位进行回收</strong>，<strong>RecyclerView是以ViewHolder作为单位进行回收</strong>。<br> Recycler是RecyclerView回收机制的实现类，他实现了四级缓存：</p> 
<ul><li>mAttachedScrap: 缓存在屏幕上的ViewHolder。</li><li>mCachedViews: 缓存屏幕外的ViewHolder，默认为2个。ListView对于屏幕外的缓存都会调用<code>getView()</code>。</li><li>mViewCacheExtensions: 需要用户定制，默认不实现。</li><li>mRecyclerPool: 缓存池，多个RecyclerView共用。</li></ul> 
<p>在上文Layout Manager中已经介绍了RecyclerView的layout过程，但是一笔带过了<code>getViewForPosition()</code>，因此此处介绍该方法的实现。</p> 
<p> </p> 
<pre><code>View getViewForPosition(int position, boolean dryRun){
    if(holder == null){
        //从mAttachedScrap,mCachedViews获取ViewHolder
        holder = getScrapViewForPosition(position,INVALID,dryRun); //此处获得的View不需要bind
    }
    final int type = mAdapter.getItemViewType(offsetPosition);
    if (mAdapter.hasStableIds()) { //默认为false
        holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);
    }
    if(holder == null &amp;&amp; mViewCacheExtension != null){
        final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type); //从
        if(view != null){
            holder = getChildViewHolder(view);
        }
    }
    if(holder == null){
        holder = getRecycledViewPool().getRecycledView(type);
    }
    if(holder == null){  //没有缓存，则创建
        holder = mAdapter.createViewHolder(RecyclerView.this, type); //调用onCreateViewHolder()
    }
    if(!holder.isBound() || holder.needsUpdate() || holder.isInvalid()){
        mAdapter.bindViewHolder(holder, offsetPosition);
    }
    return holder.itemView;
}
</code></pre> 
<p>从上述实现可以看出，依次从mAttachedScrap, mCachedViews, mViewCacheExtension, mRecyclerPool寻找可复用的ViewHolder，如果是从mAttachedScrap或mCachedViews中获取的ViewHolder，则不会调用<code>onBindViewHolder()</code>，mAttachedScrap和mCachedViews也就是我们所说的Scrap Heap；而如果从mViewCacheExtension或mRecyclerPool中获取的ViewHolder，则会调用<code>onBindViewHolder()</code>。</p> 
<p>RecyclerView局部刷新的实现原理也是基于RecyclerView的回收机制，即能直接复用的ViewHolder就不调用<code>onBindViewHolder()</code>。</p> 
<h3>结论</h3> 
<ol><li> <p>在一些场景下，如界面初始化，滑动等，ListView和RecyclerView都能很好地工作，两者并没有很大的差异：</p> </li><li> <p>数据源频繁更新的场景，如弹幕：<a href="https://www.jianshu.com/p/2232a63442d6" rel="nofollow">http://www.jianshu.com/p/2232a63442d6</a>等RecyclerView的优势会非常明显；</p> </li></ol> 
<p>进一步来讲，结论是：<br><strong>列表页展示界面，需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展；其它情况(如微信卡包列表页)两者都OK，但ListView在使用上会更加方便，快捷。</strong></p> 
<h3>扩展阅读</h3> 
<ul><li><a href="https://link.jianshu.com?t=http%3A%2F%2Fv.youku.com%2Fv_show%2Fid_XMTU4MTQ1ODg2NA%3D%3D.html%3Ff%3D27314446" rel="nofollow">Google I/O 2016: RecyclerView Ins and Outs</a></li><li><a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2FCymChad%2FCymChad.github.io" rel="nofollow">RecyclerView优秀文章集</a></li></ul> 
<p><strong>引用：</strong><br> ★★★★<a href="https://link.jianshu.com?t=http%3A%2F%2Fblog.csdn.net%2Ftencent_bugly%2Farticle%2Fdetails%2F54287626%23t7" rel="nofollow">RecyclerView 必知必会</a><br> ★★★★<a href="https://link.jianshu.com?t=http%3A%2F%2Fblog.csdn.net%2Ftencent_bugly%2Farticle%2Fdetails%2F52981210" rel="nofollow">Android ListView 与 RecyclerView 对比浅析–缓存机制</a><br> ★★★<a href="https://www.jianshu.com/p/4fc6164e4709" rel="nofollow">RecyclerView使用完全指南，是时候体验新控件了（一）</a><br> ★★★<a href="https://www.jianshu.com/p/7c3c549a0ec4" rel="nofollow">RecyclerView使用完全指南，是时候体验新控件了（二）</a><br><a href="https://link.jianshu.com?t=http%3A%2F%2Fblog.csdn.net%2Fu012124438%2Farticle%2Fdetails%2F53495951" rel="nofollow">一篇博客理解Recyclerview的使用</a><br><a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.cnblogs.com%2Fanni-qianqian%2Fp%2F6587329.html" rel="nofollow">RecyclerView使用全解析</a></p> 
<p><strong>Demo地址：</strong></p> 
<ul><li><a href="https://link.jianshu.com?t=https://github.com/Kyogirante/MaterialDesignDemo">RecyclerView基本用法</a></li><li><a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fxiazdong%2FRecyclerViewDemo" rel="nofollow">RecyclerViewDemo</a></li></ul> 
<ul><li>Demo1: RecyclerView添加HeaderView和FooterView，ItemDecoration范例。</li><li>Demo2: ListView实现局部刷新。</li><li>Demo3: RecyclerView实现拖拽、侧滑删除。</li><li>Demo4: RecyclerView闪屏问题。</li><li>Demo5: RecyclerView实现<code>setEmptyView()</code>。</li><li>Demo6: RecyclerView实现万能适配器，瀑布流布局，嵌套滑动机制。</li></ul> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b6619b72bbe18274a97467ce3fe25ab4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">这 6 个 SpringBoot 项目够经典！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b0e28aa1d51fe696329fe33dd140066/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Latex中设置enumerate有序列表使用方括号标号以及设置item间距</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>