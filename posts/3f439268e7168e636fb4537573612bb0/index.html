<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>(3/100) cmake指令详解 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="(3/100) cmake指令详解" />
<meta property="og:description" content="参考博客：
1. cmake核心知识点整理
2. cmake - 编译
3. CMake教程
4. Cmake使用教程（看这一篇就够了）(这篇详细的介绍了cmake的安装、创建和使用过程)
5. CMake 入门实战
6. CMake&amp;CMakeList.txt
0、cmake基础知识 0.1 什么是cmake，与make区别 在各种开源项目中，经常会发现项目中除了代码源文件，还包含了 CMakeList.txt、 Makefile 文件，在项目的编译时候需要用到的命令有 cmake 、 make。我们本次想搞清楚他们之前的关系以及CMakeList的语法规则。
正常情况下，我们编写程序的大体流程为： 1）用编辑器（vim、emacs等）编写源代码文件（.h、.cpp等）； 2）用编译器编译代码生成目标文件（.o等）； 3）用链接器连接目标文件生成可执行文件（.exe等）。 一个程序在编写时，可能需要编写很多的代码文件，以及依赖很多第三方的库。在这种情况下，手动依次编译每个文件会变的非常麻烦，效率低下。
make 是一个自动化的批量编译工具，可以实现用一个命令构建整个工程的目的。但是其执行需要依赖一个规则文件，这个文件就是 Makefile。 Makefile 文件里详细描述了构建的细节（文件的依赖关系，编译的先后顺序等）。
对于一个大工程来说，编写 Makefile 文件也是一项非常复杂的事情。
cmake(Cross-platform Make)是一个可以自动生成 Makefile 文件的工具，当然它不只能生成 Makefile ，还能跨平台生成主流IDE(VS, xcode…)构建工程所需的 project 文件。 cmake 的执行同样需要依赖规则文件，这个文件就是 CMakeLists.txt 。
所以，为了能够把一堆c，cc，cpp，h，hpp代码变成可运行的库或者程序，核心还是Makefile，CMakefiles.txt纯粹是为了降低不懂Unix体系的人去编译C/C&#43;&#43;代码做的一个自动系统和环境检测和设置工具，同时帮你生成Makefile。
0.2 语法特性介绍 基本语法格式：指令(参数 1 参数 2…) 参数使用括弧括起 参数之间使用空格或分号分开 指令是大小写无关的，参数和变量是大小写相关的 set(HELLO hello.cpp) add_executable(hello main.cpp hello.cpp) ADD_EXECUTABLE(hello main.cpp ${HELLO}) 变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名 1、指定编译器并同时设置编译选项 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3f439268e7168e636fb4537573612bb0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-18T16:00:14+08:00" />
<meta property="article:modified_time" content="2023-04-18T16:00:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">(3/100) cmake指令详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>参考博客：</strong><br> <a href="https://blog.csdn.net/chengyongkang/article/details/122438467">1. cmake核心知识点整理</a><br> <a href="https://www.shuzhiduo.com/A/xl56q7gmJr/" rel="nofollow">2. cmake - 编译</a><br> <a href="https://blog.csdn.net/CSDN_crossover/article/details/126757595#t31">3. CMake教程</a><br> <a href="https://blog.csdn.net/weixin_43717839/article/details/128032486?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-128032486-blog-124142651.235%5Ev29%5Epc_relevant_default_base3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">4. Cmake使用教程（看这一篇就够了）</a>(这篇详细的介绍了cmake的安装、创建和使用过程)<br> <a href="https://www.hahack.com/codes/cmake/" rel="nofollow">5. CMake 入门实战</a><br> <a href="https://blog.csdn.net/guo_zhen_qian/article/details/126411810">6. CMake&amp;CMakeList.txt</a></p> 
<h2><a id="0cmake_7"></a>0、cmake基础知识</h2> 
<h3><a id="01_cmakemake_8"></a>0.1 什么是cmake，与make区别</h3> 
<p>在各种开源项目中，经常会发现项目中除了代码源文件，还包含了 CMakeList.txt、 Makefile 文件，在项目的编译时候需要用到的命令有 cmake 、 make。我们本次想搞清楚他们之前的关系以及CMakeList的语法规则。</p> 
<pre><code class="prism language-typescript">正常情况下，我们编写程序的大体流程为：
<span class="token number">1</span>）用编辑器（vim、emacs等）编写源代码文件（<span class="token punctuation">.</span>h、<span class="token punctuation">.</span>cpp等）；
<span class="token number">2</span>）用编译器编译代码生成目标文件（<span class="token punctuation">.</span>o等）；
<span class="token number">3</span>）用链接器连接目标文件生成可执行文件（<span class="token punctuation">.</span>exe等）。
</code></pre> 
<p>一个程序在编写时，可能需要编写很多的代码文件，以及依赖很多第三方的库。在这种情况下，手动依次编译每个文件会变的非常麻烦，效率低下。</p> 
<p><code>make</code> 是一个自动化的批量编译工具，可以实现用一个命令构建整个工程的目的。但是其执行需要依赖一个规则文件，这个文件就是 <code>Makefile</code>。 <code>Makefile</code> 文件里详细描述了构建的细节（文件的依赖关系，编译的先后顺序等）。</p> 
<p><em><strong>对于一个大工程来说，编写 Makefile 文件也是一项非常复杂的事情。</strong></em></p> 
<p><code>cmake</code>(Cross-platform Make)是一个可以自动生成 <code>Makefile</code> 文件的工具，当然它不只能生成 <code>Makefile</code> ，还能跨平台生成主流IDE(VS, xcode…)构建工程所需的 project 文件。 <code>cmake</code> 的执行同样需要依赖规则文件，这个文件就是 <code>CMakeLists.txt</code> 。</p> 
<p>所以，为了能够把一堆c，cc，cpp，h，hpp代码变成可运行的库或者程序，核心还是Makefile，CMakefiles.txt纯粹是为了降低不懂Unix体系的人去编译C/C++代码做的一个自动系统和环境检测和设置工具，同时帮你生成Makefile。</p> 
<p><img src="https://images2.imgbox.com/f2/7f/jiVQaiZ1_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="02__30"></a>0.2 语法特性介绍</h3> 
<pre><code class="prism language-typescript"><span class="token function">基本语法格式：指令</span><span class="token punctuation">(</span>参数 <span class="token number">1</span> 参数 <span class="token number">2</span>…<span class="token punctuation">)</span>
    参数使用括弧括起
    参数之间使用空格或分号分开

指令是大小写无关的，参数和变量是大小写相关的

<span class="token function">set</span><span class="token punctuation">(</span><span class="token constant">HELLO</span> hello<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span>
<span class="token function">add_executable</span><span class="token punctuation">(</span>hello main<span class="token punctuation">.</span>cpp hello<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span>
<span class="token constant">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello main<span class="token punctuation">.</span>cpp $<span class="token punctuation">{<!-- --></span><span class="token constant">HELLO</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

变量使用$<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>方式取值，但是在 <span class="token constant">IF</span> 控制语句中是直接使用变量名
</code></pre> 
<h2><a id="1_48"></a>1、指定编译器并同时设置编译选项</h2> 
<h3><a id="11__cmake_minimum_required__CMake_50"></a>1.1 <code> cmake_minimum_required</code> - 指定CMake的最小版本要求</h3> 
<pre><code class="prism language-typescript"><span class="token comment">//cmake_minimum_required(VERSION versionNumber ) </span>
<span class="token comment">//CMake最小版本要求为2.8.3 </span>
<span class="token function">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token constant">VERSION</span> <span class="token number">2.8</span><span class="token number">.3</span><span class="token punctuation">)</span> 
</code></pre> 
<h3><a id="12_project___58"></a>1.2 <code>project</code> - 定义工程名称，并可指定工程支持的语言</h3> 
<pre><code class="prism language-typescript"><span class="token comment">//project(projectname [CXX] [C] [Java])</span>
<span class="token comment">//指定工程名为HELLOWORLD</span>
<span class="token function">project</span><span class="token punctuation">(</span><span class="token constant">HELLOWORLD</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="13_set___66"></a>1.3 <code>set</code> - 显式的定义变量</h3> 
<pre><code class="prism language-typescript"><span class="token comment">//set(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span>
<span class="token comment">//定义SRC变量，其值为main.cpp hello.cpp</span>
<span class="token function">set</span><span class="token punctuation">(</span><span class="token constant">SRC</span> sayhello<span class="token punctuation">.</span>cpp hello<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-typescript"><span class="token comment">//设置输出文件位置</span>
<span class="token comment">//设置运行时目标文件（exe、dll）的输出位置，原来的输出文件demo.exe是在build\Debug下，指定其生成路径改为build\exe\Debug下</span>
<span class="token function">set</span><span class="token punctuation">(</span><span class="token constant">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> $<span class="token punctuation">{<!-- --></span><span class="token constant">CMAKE_BINARY_DIR</span><span class="token punctuation">}</span><span class="token operator">/</span>exe<span class="token punctuation">)</span>
<span class="token function">message</span><span class="token punctuation">(</span>$<span class="token punctuation">{<!-- --></span><span class="token constant">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//设置存档目标文件（lib、a）的输出位置</span>
<span class="token function">set</span><span class="token punctuation">(</span><span class="token constant">CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span> $<span class="token punctuation">{<!-- --></span><span class="token constant">CMAKE_BINARY_DIR</span><span class="token punctuation">}</span><span class="token operator">/</span>lib<span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-bash">set<span class="token punctuation">(</span>CMAKE_CXX_COMPILER      <span class="token string">"clang++"</span> <span class="token punctuation">)</span>         <span class="token comment"># 显示指定使用的C++编译器</span>
set<span class="token punctuation">(</span>CMAKE_CXX_FLAGS   <span class="token string">"-std=c++11"</span><span class="token punctuation">)</span>             <span class="token comment"># c++11</span>
set<span class="token punctuation">(</span>CMAKE_CXX_FLAGS   <span class="token string">"-g"</span><span class="token punctuation">)</span>                     <span class="token comment"># 调试信息</span>
set<span class="token punctuation">(</span>CMAKE_CXX_FLAGS   <span class="token string">"-Wall"</span><span class="token punctuation">)</span>                  <span class="token comment"># 开启所有警告</span>
set<span class="token punctuation">(</span>CMAKE_CXX_FLAGS_DEBUG   <span class="token string">"-O0"</span> <span class="token punctuation">)</span>             <span class="token comment"># 调试包不优化</span>
set<span class="token punctuation">(</span>CMAKE_CXX_FLAGS_RELEASE <span class="token string">"-O2 -DNDEBUG "</span> <span class="token punctuation">)</span>   <span class="token comment"># release包优化</span>
</code></pre> 
<p><code>CMAKE_CXX_FLAGS</code>设置的编译选项只会对<code>g++有效，其他编译器不生效。 </code>当然我们也可以通过<code>add_compile_options()</code>设置，但是通过<code>add_compile_options</code>会对<code>所有编译器</code>生效，如：</p> 
<pre><code class="prism language-typescript"><span class="token function">add_compile_options</span><span class="token punctuation">(</span><span class="token operator">-</span>std<span class="token operator">=</span>c<span class="token operator">++</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token comment">//在编译C代码时就会产生警告信息</span>
</code></pre> 
<h2><a id="2_96"></a>2、常用指令</h2> 
<h3><a id="21_add_compile_options___97"></a>2.1 <code>add_compile_options</code> - 添加编译参数</h3> 
<pre><code class="prism language-typescript"><span class="token function">语法：add_compile_options</span><span class="token punctuation">(</span>
<span class="token comment">//添加编译参数 -Wall -std=c++11</span>
<span class="token function">add_compile_options</span><span class="token punctuation">(</span><span class="token operator">-</span>Wall <span class="token operator">-</span>std<span class="token operator">=</span>c<span class="token operator">++</span><span class="token number">11</span> <span class="token operator">-</span><span class="token constant">O2</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="22_add_executable___103"></a>2.2 <code>add_executable</code> - 生成可执行文件</h3> 
<pre><code class="prism language-typescript"><span class="token function">语法：add_executable</span><span class="token punctuation">(</span>exename source1 source2 … sourceN<span class="token punctuation">)</span>
<span class="token comment">//编译main.cpp生成可执行文件main</span>
<span class="token function">add_executable</span><span class="token punctuation">(</span>main main<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="23_option_1bool_109"></a>2.3 <code>option</code> 定义一个开关，相当于1个bool值</h3> 
<pre><code class="prism language-typescript"># <span class="token function">语法：option</span><span class="token punctuation">(</span>变量值 <span class="token string">"帮助信息"</span> <span class="token punctuation">[</span>变量值<span class="token punctuation">]</span><span class="token punctuation">)</span>
# 作用：定义一个开关，相当于<span class="token number">1</span>个bool值
# 说明：变量值为 <span class="token constant">ON</span> 或 <span class="token constant">OFF</span> ，默认为 <span class="token constant">OFF</span>
<span class="token comment">//如果开关被打开，输出当前日期；否则不输出</span>
<span class="token function">option</span><span class="token punctuation">(</span><span class="token constant">DATE_ENABLE</span> <span class="token string">"version date"</span> <span class="token constant">ON</span><span class="token punctuation">)</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">DATE_ENABLE</span><span class="token punctuation">)</span>
    <span class="token function">set</span><span class="token punctuation">(</span>data <span class="token string">"2022.09.09"</span><span class="token punctuation">)</span>
<span class="token function">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="24_configure_file__121"></a>2.4 <code>configure_file</code> 将输入文件进行替换并生成输出文件</h3> 
<pre><code class="prism language-typescript"># <span class="token function">语法：configure_file</span><span class="token punctuation">(</span>输入文件 输出文件<span class="token punctuation">)</span>
# 作用：将输入文件进行替换并生成输出文件
# 说明：输入文件中形如 @<span class="token constant">VAR</span>@ 或 $<span class="token punctuation">{<!-- --></span><span class="token constant">VAR</span><span class="token punctuation">}</span> 的字符串会被替换为这些变量的当前值，如果未定义则被替换为空字符串。
<span class="token comment">//添加config file，输入文件是config.h.in输出文件是config.h</span>
<span class="token function">configure_file</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>h<span class="token punctuation">.</span>in config<span class="token punctuation">.</span>h<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="25_add_subdirectory__129"></a>2.5 <code>add_subdirectory</code> 添加源文件目录</h3> 
<pre><code class="prism language-typescript"># <span class="token function">语法：add_subdirectory</span><span class="token punctuation">(</span>source_dir <span class="token punctuation">[</span>binary_dir<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token constant">EXCLUDE_FROM_ALL</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
# 说明：source_dir指定源文件目录的位置，binary_dir 指定编译结果存放的位置，该参数可以不写。
# 作用：向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置
<span class="token comment">//添加src子目录，src中需有一个CMakeLists.txt</span>
<span class="token function">add_subdirectory</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="26_aux_source_directory___137"></a>2.6 <code>aux_source_directory</code> - 发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表</h3> 
<pre><code class="prism language-typescript"> <span class="token function">语法：aux_source_directory</span><span class="token punctuation">(</span>dir <span class="token constant">VARIABLE</span><span class="token punctuation">)</span>
<span class="token comment">//定义SRC变量，其值为当前目录下所有的源代码文件</span>
<span class="token function">aux_source_directory</span><span class="token punctuation">(</span><span class="token punctuation">.</span> <span class="token constant">SRC</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="27_include_directories__144"></a>2.7 <code>include_directories</code> 指定所有目标的头文件路径</h3> 
<pre><code class="prism language-typescript"># <span class="token function">语法：include_directories</span><span class="token punctuation">(</span>dir1 <span class="token punctuation">[</span>dir2 <span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
# 作用：指定所有目标的头文件添加路径。如果不写会导致无法找到头文件，编译无法过去。
# 说明：目录会被添加到当前文件的 <span class="token constant">INCLUDE_DIRECTORIES</span> 属性中
<span class="token comment">//将/usr/include/myincludefolder 和 ./include 添加到头文件搜索路径</span>
<span class="token function">include_directories</span><span class="token punctuation">(</span><span class="token operator">/</span>usr<span class="token operator">/</span>include<span class="token operator">/</span>myincludefolder <span class="token punctuation">.</span><span class="token operator">/</span>include<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="28_target_include_directories__153"></a>2.8 <code>target_include_directories</code> 指定一个目标的头文件路径</h3> 
<pre><code class="prism language-typescript"># <span class="token function">语法：target_include_directories</span><span class="token punctuation">(</span>target 名
					   <span class="token operator">&lt;</span><span class="token constant">INTERFACE</span> <span class="token operator">|</span> <span class="token constant">PUBLIC</span> <span class="token operator">|</span> <span class="token constant">PRIVATE</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span>items1<span class="token operator">...</span><span class="token punctuation">]</span>
					   <span class="token operator">&lt;</span><span class="token constant">INTERFACE</span> <span class="token operator">|</span> <span class="token constant">PUBLIC</span> <span class="token operator">|</span> <span class="token constant">PRIVATE</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span>items2<span class="token operator">...</span><span class="token punctuation">]</span> <span class="token operator">...</span><span class="token punctuation">)</span>
# <span class="token function">作用：指定一个目标的头文件路径。推荐使用target_include_directories，因为有些目标不需要添加路径，使用include_directories</span><span class="token punctuation">(</span>dir1 <span class="token punctuation">[</span>dir2 <span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">)</span>会增加编译时间。
# 说明：目标文件有 <span class="token constant">INCLUDE_DIRECTORIES</span> 和 <span class="token constant">INTERFACE_INCLUDE_DIRECTORIES</span> 两个属性：
	# ①<span class="token constant">INCLUDE_DIRECTORIES</span>：对内头文件目录
	# ②<span class="token constant">INTERFACE_INCLUDE_DIRECTORIES</span>，对外头文件目录
<span class="token comment">//指定目标的头文件路径</span>
<span class="token function">target_include_directories</span><span class="token punctuation">(</span>HelloWorld <span class="token constant">PUBLIC</span> <span class="token string">"${PROJECT_BINARY_DIR}"</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="29_link_directories___gL_165"></a>2.9 <code>link_directories</code> - 向工程添加多个特定的库文件搜索路径 —&gt;相当于指定g++编译器的-L参</h3> 
<pre><code class="prism language-typescript"># 语法：<span class="token operator">**</span><span class="token function">link_directories</span><span class="token punctuation">(</span>dir1 dir2 …<span class="token punctuation">)</span> <span class="token operator">**</span>
<span class="token comment">//将/usr/lib/mylibfolder 和 ./lib 添加到库文件搜索路径</span>
<span class="token function">link_directories</span><span class="token punctuation">(</span><span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>mylibfolder <span class="token punctuation">.</span><span class="token operator">/</span>lib<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="210_message_173"></a>2.10 <code>message()</code>输出某个信息：</h3> 
<pre><code class="prism language-typescript"><span class="token comment">//其中输出类型可选择：STATUS(输出前缀为-的信息)，SEND_ERROR(产生错误)，FATAL_ERROR(终止cmake过程)</span>
<span class="token function">message</span><span class="token punctuation">(</span><span class="token constant">STATUS</span> <span class="token string">"messages"</span><span class="token punctuation">)</span>  
</code></pre> 
<h3><a id="211_file_178"></a>2.11 <code>file()</code>对文件和文件夹的操作：比如搜索文件、打开文件、写入文件</h3> 
<pre><code class="prism language-typescript"># <span class="token function">语法：file</span><span class="token punctuation">(</span><span class="token constant">GLOB</span> <span class="token operator">&lt;</span>variable<span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token constant">LIST_DIRECTORIES</span> <span class="token boolean">true</span><span class="token punctuation">[</span><span class="token boolean">false</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token constant">RELATIVE</span> <span class="token operator">&lt;</span>path<span class="token operator">&gt;</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token constant">CONFIGURE_DEPENDS</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>globbing<span class="token operator">-</span>expression<span class="token operator">&gt;</span> <span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
# 作用：主要用于匹配规则在指定的目录内匹配到所需要的文
# 说明：<span class="token constant">LIST_DIRECTORIES</span> <span class="token boolean">true</span><span class="token punctuation">[</span><span class="token boolean">false</span><span class="token punctuation">]</span><span class="token operator">:</span> 如果为<span class="token boolean">false</span>，目录将会被省略，默认情况下返回是带目录
		<span class="token constant">RELATIVE</span> <span class="token operator">&lt;</span>path<span class="token operator">&gt;</span><span class="token operator">:</span> 相对路径<span class="token operator">&lt;</span>path<span class="token operator">&gt;</span> 返回的结果将不是绝对路径，而是将绝对路径中的<span class="token operator">&lt;</span>path<span class="token operator">&gt;</span>部分去掉，返回相对路径
		<span class="token constant">CONFIGURE_DEPENDS</span><span class="token operator">:</span>如果该标记位设置，在主构建系统检查目标添加逻辑，必便在构建时重新运行标记的<span class="token constant">GLOB</span>命令
		<span class="token operator">&lt;</span>globbing<span class="token operator">-</span>expression<span class="token operator">&gt;</span>：匹配表达式<span class="token punctuation">,</span>表达式类似与正则匹配
<span class="token comment">//寻找当前路径下的cpp文件，且返回的结果中为/public/home的相对路径</span>
<span class="token function">file</span><span class="token punctuation">(</span><span class="token constant">GLOB</span> <span class="token constant">TEST_RESULT</span> <span class="token constant">LIST_DIRECT</span> <span class="token boolean">true</span> <span class="token constant">RELATIVE</span> <span class="token operator">/</span><span class="token keyword">public</span><span class="token operator">/</span>home <span class="token operator">*</span><span class="token punctuation">.</span>cpp<span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-typescript"><span class="token comment">//如果要创建文件夹路径：</span>
<span class="token function">file</span><span class="token punctuation">(</span><span class="token constant">MAKE_DIRECTORY</span> $<span class="token punctuation">{<!-- --></span>xxx<span class="token punctuation">}</span><span class="token punctuation">)</span>   #创建某个路径文件夹
</code></pre> 
<h2><a id="3_200"></a>3、编译库文件</h2> 
<h3><a id="31_cmakeadd_library_201"></a>3.1 cmake可以通过<code>add_library</code>利用源文件<code>生成</code>动态和静态库文件，指令如下：</h3> 
<pre><code class="prism language-typescript"><span class="token function">add_library</span><span class="token punctuation">(</span>xxx1 <span class="token constant">SHARED</span> xxx<span class="token punctuation">.</span>cpp xxxx<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span> ##命令根据xxx<span class="token punctuation">.</span>cpp和xxxx<span class="token punctuation">.</span>cpp生成动态库文件libxxx1<span class="token punctuation">.</span>so
<span class="token function">add_library</span><span class="token punctuation">(</span>xxx2 <span class="token constant">STATIC</span> xxx<span class="token punctuation">.</span>cpp xxxx<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span> ##命令根据xxx<span class="token punctuation">.</span>cpp和xxxx<span class="token punctuation">.</span>cpp生成静态库文件libxxx1<span class="token punctuation">.</span>a
<span class="token function">add_library</span><span class="token punctuation">(</span>xxx3 <span class="token constant">MODULE</span> xxx<span class="token punctuation">.</span>cpp xxxx<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span> ##命令根据xxx<span class="token punctuation">.</span>cpp和xxxx<span class="token punctuation">.</span>cpp生成中间文件libxxx3，该文件不会被加载到其他地方使用
</code></pre> 
<p><em><strong>注意：库名称不需要写前缀lib，系统会自动在给出的库名称前面加lib.</strong></em></p> 
<p>库文件生成后，我们需要对其属性进行设置，如重置<strong>库文件的名称</strong>，设置<strong>库文件的版本号</strong>等，这些需要通过<code>set_target_properties</code>命令实现：</p> 
<pre><code class="prism language-typescript"><span class="token comment">// 创建动态库</span>
<span class="token function">add_library</span><span class="token punctuation">(</span>algorithms <span class="token constant">SHARED</span> $<span class="token punctuation">{<!-- --></span>src_path<span class="token punctuation">}</span><span class="token punctuation">)</span>  
<span class="token comment">// 创建动态链接库：库名称libalgorithms, SHARED表示为.so动态链接库，src_path是.cpp文件所在路径</span>
</code></pre> 
<pre><code class="prism language-typescript"><span class="token comment">// 创建静态库</span>
<span class="token function">set_target_properties</span><span class="token punctuation">(</span>hello <span class="token constant">PROPERTIES</span> <span class="token constant">CLEAN_DIRECT_OUTPUT</span> <span class="token number">1</span><span class="token punctuation">)</span>         
<span class="token comment">// 设置不清除同名动态库hello.so</span>
<span class="token function">set_target_properties</span><span class="token punctuation">(</span>hello_static <span class="token constant">PROPERTIES</span> <span class="token constant">CLEAN_DIRECT_OUTPUT</span> <span class="token number">1</span><span class="token punctuation">)</span>  
<span class="token comment">// 设置不清除同名静态库hello.a</span>
<span class="token function">set_target_properties</span><span class="token punctuation">(</span>hello_static <span class="token constant">PROPERTIES</span> <span class="token constant">OUTPUT_NAME</span> <span class="token string">"hello"</span><span class="token punctuation">)</span>    
<span class="token comment">// 设置静态库的输出名称为hello，从而即使跟动态库重名也能实现</span>
</code></pre> 
<pre><code class="prism language-typescript"><span class="token comment">//设置动态库的版本号</span>
<span class="token function">set_target_properties</span><span class="token punctuation">(</span>hello <span class="token constant">PROPERTIES</span> <span class="token constant">VERSION</span> <span class="token number">1.2</span> <span class="token constant">SOVERSION</span> <span class="token number">1</span><span class="token punctuation">)</span> 
<span class="token comment">//VERSION指代动态库版本，SOVERSION指代API版本</span>
</code></pre> 
<pre><code class="prism language-typescript"><span class="token comment">//注意：add_library除了可以生产库文件之外，还可以生成目标文件，但不打包成lib命令如下</span>
<span class="token function">add_library</span><span class="token punctuation">(</span>objlib <span class="token constant">OBJECT</span> <span class="token operator">&lt;</span>src<span class="token operator">&gt;</span><span class="token operator">...</span><span class="token punctuation">)</span>
<span class="token comment">//这种库只编译源文件生成目标文件，但是不把这些目标文件打包进一个lib。</span>
<span class="token comment">//当其他的库或者目标文件要使用这些目标文件的时候，会以这样的形式来添加，objlib是这个库的名字</span>
<span class="token function">add_library</span><span class="token punctuation">(</span><span class="token operator">...</span> $<span class="token operator">&lt;</span><span class="token constant">TARGET_OBJECTS</span><span class="token operator">:</span>objlib<span class="token operator">&gt;</span> <span class="token operator">...</span><span class="token punctuation">)</span>
<span class="token function">add_executable</span><span class="token punctuation">(</span><span class="token operator">...</span> $<span class="token operator">&lt;</span><span class="token constant">TARGET_OBJECTS</span><span class="token operator">:</span>objlib<span class="token operator">&gt;</span> <span class="token operator">...</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="32__239"></a>3.2 使用<code>已知路径</code>的<code>外部现成</code>的库文件</h3> 
<p>实测发现默认的.so路径只有一个/usr/lib，也就是库文件如果不在这个路径下则需要手动链接。<br> 有两个语句都可以实现链接库文件：<br> <code>link_libraries(path)</code> 是在生成可执行文件之前就指定库文件路径(必须放在add_executable()的前边)。<br> <code>target_link_libraries(main path)</code> 是在生成target可执行文件之后链接(必须放在add_executable()的后边)<br> <strong>两者的区别就是在定义链接文件时 是在可执行文件生成之前还是之后，都可以实现功能。应尽可能首选<code>target_link_libraries</code>命令</strong></p> 
<pre><code class="prism language-typescript"># <span class="token function">语法：link_libraries</span><span class="token punctuation">(</span><span class="token punctuation">[</span>item1 <span class="token punctuation">[</span>item2 <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
                   <span class="token punctuation">[</span><span class="token punctuation">[</span>debug<span class="token operator">|</span>optimized<span class="token operator">|</span>general<span class="token punctuation">]</span> <span class="token operator">&lt;</span>item<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token operator">...</span><span class="token punctuation">)</span>
# 作用：用于将库链接到稍后添加的所有targets
# 说明：指定在通过诸如add_executable或add_library等命令链接稍后在当前目录或更低目录中创建的任何targets时要使用的库或标志。
<span class="token function">add_library</span><span class="token punctuation">(</span>add <span class="token constant">SHARED</span> $<span class="token punctuation">{<!-- --></span><span class="token constant">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span><span class="token operator">/</span>source<span class="token operator">/</span>add<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span> #将会在build目录下生成libadd<span class="token punctuation">.</span>so
<span class="token function">add_library</span><span class="token punctuation">(</span>subtraction <span class="token constant">SHARED</span> $<span class="token punctuation">{<!-- --></span><span class="token constant">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span><span class="token operator">/</span>source<span class="token operator">/</span>subtraction<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span> #将会在build目录下生成libsubtraction<span class="token punctuation">.</span>so
<span class="token function">link_libraries</span><span class="token punctuation">(</span>add subtraction<span class="token punctuation">)</span> 
<span class="token function">add_executable</span><span class="token punctuation">(</span>sample_add $<span class="token punctuation">{<!-- --></span><span class="token constant">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span><span class="token operator">/</span>samples<span class="token operator">/</span>sample_add<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-typescript"><span class="token function">add_library</span><span class="token punctuation">(</span>libxxx4 <span class="token operator">&lt;</span><span class="token constant">SHARED</span><span class="token operator">|</span><span class="token constant">STATIC</span><span class="token operator">|</span><span class="token constant">MODULE</span><span class="token operator">|</span><span class="token constant">UNKNOWN</span><span class="token operator">&gt;</span> <span class="token constant">IMPORTED</span><span class="token punctuation">)</span>
<span class="token comment">//IMPORTED 表明此库在工程之外，是target_link_libraries的方便形式。</span>
<span class="token comment">//外部库的详细信息通过set_target_properties设置</span>
<span class="token comment">//其中最重要的就是 IMPORTED_LOCATION 属性，它指定外部库的位置。</span>
<span class="token function">add_library</span><span class="token punctuation">(</span>libxxx4 <span class="token constant">STATIC</span> <span class="token constant">IMPORTED</span><span class="token punctuation">)</span>
<span class="token function">set_target_properties</span><span class="token punctuation">(</span>libxxx4 <span class="token constant">PROPERTIES</span> <span class="token constant">IMPORTED_LOCATION</span> <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>libboost_system<span class="token punctuation">.</span>a<span class="token punctuation">)</span> 
<span class="token comment">//libxxx4其实就是libboost_system.a</span>
<span class="token function">target_link_libraries</span><span class="token punctuation">(</span>wang libxxx4<span class="token punctuation">)</span>
<span class="token comment">//其实上述3条命令等价于</span>
<span class="token function">target_link_libraries</span><span class="token punctuation">(</span>wang <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>libboost_system<span class="token punctuation">.</span>a<span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p><strong>如果已知头文件库文件路径</strong>，可直接用<code>target_include_directories()</code>和<code>target_link_libraries()</code>进行添加。<br> <strong>如果不知道头文件库文件路径</strong>，可以有另外2个方法： 一种采用<code>find_package()</code>相当于变量赋值然后用<code>target_include_directories()</code>和<code>target_link_libraries()</code>设置即可；<br> 另一种采用<code>find_library()</code>和<code>find_path()</code>。</p> 
</blockquote> 
<h3><a id="33_find_package_275"></a>3.3 寻找外部依赖库find_package()</h3> 
<p>在一个大型项目中，免不了需要导入很多外部依赖库，比如一个项目需要使用到opencv库，我们需要知道头文件的位置，库文件的位置以及库文件的名称，此时我们就需要find_package命令<br> <code>find_package</code>: 是一种查找头文件和库文件的方法，是针对第三方库的常用方法(比如CUDA/opencv)。</p> 
<p><em>如果要使用find_package()查找第三方库的头文件和链接库文件路径：注意：采用<code>find_package()</code>命令cmake的模块<code>**查找顺序**</code>是：先在变量<code>${CMAKE_MODULE_PATH}</code>查找，然后在<code>/usr/shared/cmake/Modules/</code>里边查找。</em></p> 
<pre><code class="prism language-typescript"><span class="token function">find_package</span><span class="token punctuation">(</span><span class="token constant">CUDA</span> <span class="token constant">REQUIRED</span><span class="token punctuation">)</span>           # 查找某个第三方库的cmake <span class="token keyword">module</span>，比如<span class="token constant">CUDA</span>代表的就是FindCUDA<span class="token punctuation">.</span>cmake这个<span class="token keyword">module</span>
<span class="token function">find_package</span><span class="token punctuation">(</span>OpenCV <span class="token constant">REQUIRED</span><span class="token punctuation">)</span>         # 多个库分别查找， 然后统一加到include_directories和link_libraries即可 
<span class="token function">target_include_directories</span><span class="token punctuation">(</span>tensorrt <span class="token constant">PUBLIC</span> $<span class="token punctuation">{<!-- --></span><span class="token constant">CUDA_INCLUDE_DIRS</span><span class="token punctuation">}</span> $<span class="token punctuation">{<!-- --></span><span class="token constant">TENSORRT_INCLUDE_DIR</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">target_link_libraries</span><span class="token punctuation">(</span>tensorrt $<span class="token punctuation">{<!-- --></span><span class="token constant">CUDA_LIBRARIES</span><span class="token punctuation">}</span> $<span class="token punctuation">{<!-- --></span><span class="token constant">TENSORRT_LIBRARY</span><span class="token punctuation">}</span> $<span class="token punctuation">{<!-- --></span><span class="token constant">CUDA_CUBLAS_LIBRARIES</span><span class="token punctuation">}</span> $<span class="token punctuation">{<!-- --></span>CUDA_cudart_static_LIBRARY<span class="token punctuation">}</span> $<span class="token punctuation">{<!-- --></span>OpenCV_LIBS<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>如果要查看cmake所自带支持的所有module和内容，就在如下路径中：</p> 
<pre><code class="prism language-typescript"><span class="token operator">/</span>usr<span class="token operator">/</span>shared<span class="token operator">/</span>cmake<span class="token operator">/</span>Modules<span class="token operator">/</span>    # 这个路径下所有FindXXXX<span class="token punctuation">.</span>cmake都是cmake <span class="token keyword">module</span><span class="token function">文件</span><span class="token punctuation">(</span>大部分是以Find开头，也有不是这么开头的<span class="token punctuation">)</span>
</code></pre> 
<p>如果要为自己写的库定义一个cmake module，则本质上就是先自己查找好头文件、库文件路径，然后欧放到某几个变量中。并且cmake统一规定这几个变量的写法：<code>name_FOUND, name_INCLUDE_DIR, name_LIBRARY</code>，从而只要知道某些库的module关键字(一般大写)，然后运行find_package(关键字)，然后就能得到两个变量：关键字_INCLUDE_DIR, 关键字_LIBRARY，从而就可以用include_directories(), link_libraries()进行设置了。</p> 
<pre><code class="prism language-typescript">#　如下是一个名为FindTEST<span class="token punctuation">.</span>cmake的<span class="token keyword">module</span>的写法<span class="token operator">:</span> 关键字是<span class="token constant">TEST</span>
# <span class="token function">先找到自己安装的头文件</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>h<span class="token punctuation">)</span><span class="token operator">:</span> 为了避免安装时prefix路径设置不同，
# 这里同时在两个默认存放头文件的路径寻找，一个是所有用户路径，一个是登录用户路径。
<span class="token comment">//表示寻找test.h文件，找到则把路径赋值给变量TEST_INCLUDE_DIR</span>
<span class="token function">find_path</span><span class="token punctuation">(</span><span class="token constant">TEST_INCLUDE_DIR</span> test<span class="token punctuation">.</span>h <span class="token operator">/</span>usr<span class="token operator">/</span>include<span class="token operator">/</span>mytest      
        <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>include<span class="token operator">/</span>mytest<span class="token punctuation">)</span>
                      
# <span class="token function">再找到自己安装的动态库</span><span class="token punctuation">(</span>libmytest<span class="token punctuation">.</span>so<span class="token punctuation">)</span><span class="token operator">:</span> 为了避免安装时prefix路径设置不同，这里也同时在两个路径搜索
<span class="token comment">//NAMES是关键字,表示寻找名称为mytest(实际名称libmytest.so)的头文件，PATH也是关键字，表示在接下来2个路径中寻找</span>
<span class="token function">find_library</span><span class="token punctuation">(</span><span class="token constant">TEST_LIBRARY</span> <span class="token constant">NAMES</span> mytest <span class="token constant">PATH</span> <span class="token operator">/</span>usr<span class="token operator">/</span>lib       
        usr<span class="token operator">/</span>local<span class="token operator">/</span>lib<span class="token punctuation">)</span>                         
 
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">TEST_INCLUDE_DIR</span> <span class="token constant">AND</span> <span class="token constant">TEST_LIBRARY</span><span class="token punctuation">)</span>      # 如果找到则设置标志
    <span class="token function">set</span><span class="token punctuation">(</span><span class="token constant">TEST_FOUND</span> <span class="token constant">TRUE</span><span class="token punctuation">)</span>
<span class="token function">endif</span><span class="token punctuation">(</span><span class="token constant">TEST_INCLUDE_DIR</span> <span class="token constant">AND</span> <span class="token constant">TEST_LIBRARY</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="34_find_libraryfind_path_314"></a>3.4 <code>find_library()</code>和<code>find_path()</code>查找库文件和头文件</h3> 
<pre><code class="prism language-typescript"># <span class="token function">语法：find_library</span><span class="token punctuation">(</span><span class="token keyword">var</span> name <span class="token constant">HINTS</span> path <span class="token constant">PATH_SUFFIXES</span> suff1 suff2<span class="token punctuation">)</span>
# <span class="token function">作用：搜索名称为name的库文件</span><span class="token punctuation">(</span>实际名称是libname<span class="token punctuation">.</span>so<span class="token punctuation">)</span>，找到后存入<span class="token keyword">var</span>中，并可以带多个关键参数
# 说明：其中<span class="token constant">HINTS</span>关键参数代表搜索路径，<span class="token constant">PATH_SUFFIXES</span>代表路径后缀
<span class="token function">find_library</span><span class="token punctuation">(</span>_NVINFER_LIB nvinfer <span class="token constant">HINTS</span> $<span class="token punctuation">{<!-- --></span><span class="token constant">TRT_LIB</span><span class="token punctuation">}</span> <span class="token constant">PATH_SUFFIXES</span> lib lib64<span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-typescript">举例如下：
<span class="token function">find_path</span><span class="token punctuation">(</span>dbms_path
              <span class="token constant">NAMES</span> db_xxx<span class="token punctuation">.</span>h
              <span class="token constant">PATHS</span> <span class="token operator">/</span>home<span class="token operator">/</span>dongfang<span class="token operator">/</span>cmake_example<span class="token operator">/</span>find_path
              <span class="token constant">DOC</span> <span class="token string">"this is a test for find_path"</span><span class="token punctuation">)</span>
查找路径<span class="token constant">PATH</span><span class="token punctuation">(</span><span class="token operator">/</span>home<span class="token operator">/</span>dongfang<span class="token operator">/</span>cmake_example<span class="token operator">/</span>find_path<span class="token punctuation">)</span>下是否有db_xxx<span class="token punctuation">.</span>h文件，如果有则将<span class="token string">"/home/dongfang/cmake_example/find_path"</span>存储在变量dbms_path中
举例如下：
<span class="token function">find_library</span><span class="token punctuation">(</span>dbms_library
                 <span class="token constant">NAMES</span> libDBMS<span class="token punctuation">.</span>so
                 <span class="token constant">PATHS</span> <span class="token operator">/</span>home<span class="token operator">/</span>dongfang<span class="token operator">/</span>cmake_example<span class="token operator">/</span>find_path
                 <span class="token constant">DOC</span> <span class="token string">"this is a test for find_path"</span><span class="token punctuation">)</span>
查找路径<span class="token constant">PATH</span><span class="token punctuation">(</span><span class="token operator">/</span>home<span class="token operator">/</span>dongfang<span class="token operator">/</span>cmake_example<span class="token operator">/</span>find_path<span class="token punctuation">)</span>下是否有libDBMS<span class="token punctuation">.</span>so文件，如果有则将<span class="token string">"/home/dongfang/cmake_example/find_path"</span>存储在变量dbms_library中

在经过查找头文件和库文件路径之后，我们需要对下游负责，明确告知下游头文件路径和库文件路径是否准确找到，可使用如下命令：
<span class="token function">include</span><span class="token punctuation">(</span>FindPackageHandleStandardArgs<span class="token punctuation">)</span>
<span class="token function">find_package_handle_standard_args</span><span class="token punctuation">(</span><span class="token constant">DBMS</span> dbms_path dbms_library<span class="token punctuation">)</span> <span class="token comment">//如果dbms_path或者dbms_library无值，直接对下游报错</span>
</code></pre> 
<h2><a id="4_340"></a>4、安装</h2> 
<p>不管是库文件还是目标文件，编出来之后，都需要将其放到一定的位置，方便其他目标文件使用，此时就需要<code>install命令</code>。</p> 
<p><code>install</code> 可以生成的目标文件包括3种：<code>RUNTIME</code>是可执行文件, <code>LIBRARY</code>是动态库, <code>ARCHIVE</code>是静态库<br> 可以指定安装路径，采用关键字<code>DESTINATION</code>接路径，注意如果是<code>/</code>开头的路径就是绝对路径，如果不是斜杠开头则默认基于<code>CMAKE_INSTALL_PREFIX</code>，也就是<code>{CMAKE_INSTALL_PREFIX}/相对路径</code></p> 
<pre><code>**注意在clion中如果要安装，还需要手动进入项目cmake-build-debug文件夹，执行sudo make install执行，否则clion不会自动帮你安装。
</code></pre> 
<pre><code class="prism language-typescript"><span class="token comment">// 安装bin/lib库文件或者头文件:</span>
<span class="token function">install</span><span class="token punctuation">(</span><span class="token constant">TARGETS</span> MyLib
        <span class="token constant">EXPORT</span> MyLibTargets 
        <span class="token constant">LIBRARY</span> <span class="token constant">DESTINATION</span> lib  # 动态库安装路径
        <span class="token constant">ARCHIVE</span> <span class="token constant">DESTINATION</span> libstatic  # 静态库安装路径
        <span class="token constant">RUNTIME</span> <span class="token constant">DESTINATION</span> bin  # 可执行文件安装路径
        <span class="token constant">PUBLIC_HEADER</span> <span class="token constant">DESTINATION</span> include  # 头文件安装路径
        <span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-typescript"><span class="token comment">//安装头文件:</span>
<span class="token function">install</span><span class="token punctuation">(</span><span class="token constant">FILES</span> hello<span class="token punctuation">.</span>h <span class="token constant">DESTINATION</span> include<span class="token operator">/</span>hello<span class="token punctuation">)</span>  <span class="token comment">//安装头文件</span>
</code></pre> 
<pre><code class="prism language-typescript"><span class="token comment">// 安装sh头文件：</span>
<span class="token function">install</span><span class="token punctuation">(</span><span class="token constant">PROGRAMS</span> runhello<span class="token punctuation">.</span>sh <span class="token constant">DESTINATION</span> bin<span class="token punctuation">)</span><span class="token comment">// 安装sh文件</span>
</code></pre> 
<p><strong><code>install(TARGETS)</code> 仅适用于使用 <code>add_executable()</code>或 <code>add_library()</code>创建的目标。对于使用自定义目标生成的文件，使用 <code>install(FILES)</code></strong></p> 
<pre><code class="prism language-typescript"><span class="token function">add_custom_target</span><span class="token punctuation">(</span>
    main <span class="token constant">ALL</span>
    <span class="token constant">DEPENDS</span> $<span class="token punctuation">{<!-- --></span><span class="token constant">CMAKE_CURRENT_BINARY_DIR</span><span class="token punctuation">}</span><span class="token operator">/</span>program
<span class="token punctuation">)</span>
<span class="token function">add_custom_command</span><span class="token punctuation">(</span>
    <span class="token constant">OUTPUT</span> $<span class="token punctuation">{<!-- --></span><span class="token constant">CMAKE_CURRENT_BINARY_DIR</span><span class="token punctuation">}</span><span class="token operator">/</span>program
    <span class="token constant">COMMAND</span> $<span class="token punctuation">{<!-- --></span><span class="token constant">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span><span class="token operator">/</span>go<span class="token punctuation">.</span>sh $<span class="token punctuation">{<!-- --></span><span class="token constant">PROJECT_NAME</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span>
<span class="token function">install</span><span class="token punctuation">(</span><span class="token constant">FILES</span> $<span class="token punctuation">{<!-- --></span><span class="token constant">CMAKE_CURRENT_BINARY_DIR</span><span class="token punctuation">}</span><span class="token operator">/</span>program <span class="token constant">DESTINATION</span> <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>lib<span class="token operator">/</span><span class="token punctuation">)</span>
</code></pre> 
<h2><a id="5_383"></a>5、编译流程</h2> 
<h3><a id="51__384"></a>5.1 构建流程</h3> 
<p>在 linux 平台下使用 CMake 构建C/C++工程的流程如下:</p> 
<pre><code class="prism language-typescript">手动编写 CmakeLists<span class="token punctuation">.</span>txt。
执行命令 cmake <span class="token constant">PATH</span>生成 <span class="token function">Makefile</span> <span class="token punctuation">(</span> <span class="token constant">PATH</span> 是顶层CMakeLists<span class="token punctuation">.</span>txt 所在的目录 <span class="token punctuation">)</span>。
执行命令make 进行编译。
</code></pre> 
<pre><code class="prism language-typescript"><span class="token comment">// important tips</span>
<span class="token punctuation">.</span>       <span class="token comment">// 表示当前目录</span>
<span class="token punctuation">.</span><span class="token operator">/</span>      <span class="token comment">// 表示当前目录</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token comment">// 表示上级目录</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>     <span class="token comment">// 表示上级目录</span>
</code></pre> 
<h3><a id="52__401"></a>5.2 两种构建方式</h3> 
<p><strong>内部构建(in-source build)：不推荐使用</strong></p> 
<p>内部构建会在同级目录下产生一大堆中间文件，这些中间文件并不是我们最终所需要的，和工程源文件放在一起会显得杂乱无章。</p> 
<pre><code class="prism language-typescript">## 内部构建
<span class="token comment">//在当前目录下，编译本目录的CMakeLists.txt，生成Makefile和其他文件</span>
cmake <span class="token punctuation">.</span>
<span class="token comment">//执行make命令，生成target</span>
make
</code></pre> 
<p><strong>外部构建(out-of-source build)：推荐使用</strong><br> 将编译输出文件与源文件放到不同目录中</p> 
<pre><code class="prism language-typescript">## 外部构建
<span class="token comment">//1. 在当前目录下，创建build文件夹</span>
mkdir build 
<span class="token comment">//2. 进入到build文件夹</span>
cd build
<span class="token comment">//3. 编译上级目录的CMakeLists.txt，生成Makefile和其他文件</span>
cmake <span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">//4. 执行make命令，生成target</span>
make
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f1e3076613b4326e33e0303dfffc8046/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Servlet配置与使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/24560afced492b10b002724f0ae32139/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">拉格朗日乘子法从0到1</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>