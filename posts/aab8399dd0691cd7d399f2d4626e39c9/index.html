<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>gRPC 安全性设计 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="gRPC 安全性设计" />
<meta property="og:description" content="RPC 调用安全策略
1.1 严峻的安全形势
1.2 敏感数据加密传输
1.2.1 基于 SSL/TLS 的通道加密
1.2.2 针对敏感数据的单独加密
1.3 认证和鉴权
1.3.1 身份认证
1.3.2 权限管控
1.4 数据完整性和一致性gRPC 安全机制
2.1 SSL/TLS 认证
2.1.1 SSL/TLS 工作原理
2.1.2 HTTP/2 的 ALPN
2.1.3 gRPC 的 TLS 策略
2.1.4 基于 TLS 的 gRPC 代码示例
2.1.5 gRPC TLS 源码分析
2.2 Google OAuth 2.0
2.2.1 工作原理
2.2.2 代码示例
2.3 自定义安全认证策略 1. RPC 调用安全策略 1.1 严峻的安全形势 近年来，个人信息泄漏和各种信息安全事件层出不穷，个人信息安全以及隐私数据保护面临严峻的挑战。
很多国家已经通过立法的方式保护个人信息和数据安全，例如我国 2016 年 11 月 7 日出台、2017 年 6 月 1 日正式实施的《网络安全法》，以及 2016 年 4 月 14 日欧盟通过的《一般数据保护法案》（GDP R），该法案将于 2018 年 5 月 25 日正式生效。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/aab8399dd0691cd7d399f2d4626e39c9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-04T16:46:00+08:00" />
<meta property="article:modified_time" content="2020-03-04T16:46:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">gRPC 安全性设计</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ol><li>RPC 调用安全策略<br> 1.1 严峻的安全形势<br> 1.2 敏感数据加密传输<br> 1.2.1 基于 SSL/TLS 的通道加密<br> 1.2.2 针对敏感数据的单独加密<br> 1.3 认证和鉴权<br> 1.3.1 身份认证<br> 1.3.2 权限管控<br> 1.4 数据完整性和一致性</li><li>gRPC 安全机制<br> 2.1 SSL/TLS 认证<br> 2.1.1 SSL/TLS 工作原理<br> 2.1.2 HTTP/2 的 ALPN<br> 2.1.3 gRPC 的 TLS 策略<br> 2.1.4 基于 TLS 的 gRPC 代码示例<br> 2.1.5 gRPC TLS 源码分析<br> 2.2 Google OAuth 2.0<br> 2.2.1 工作原理<br> 2.2.2 代码示例<br> 2.3 自定义安全认证策略</li></ol> 
<h2><a id="1_RPC__21"></a>1. RPC 调用安全策略</h2> 
<h3><a id="11__22"></a>1.1 严峻的安全形势</h3> 
<p>近年来，个人信息泄漏和各种信息安全事件层出不穷，个人信息安全以及隐私数据保护面临严峻的挑战。</p> 
<p>很多国家已经通过立法的方式保护个人信息和数据安全，例如我国 2016 年 11 月 7 日出台、2017 年 6 月 1 日正式实施的《网络安全法》，以及 2016 年 4 月 14 日欧盟通过的《一般数据保护法案》（GDP R），该法案将于 2018 年 5 月 25 日正式生效。</p> 
<p>GDPR 的通过意味着欧盟对个人信息保护及其监管达到了前所未有的高度，堪称史上最严格的数据保护法案。</p> 
<p>作为企业内部各系统、模块之间调用的通信框架，即便是内网通信，RPC 调用也需要考虑安全性，RPC 调用安全主要涉及如下三点：</p> 
<ul><li>个人 / 企业敏感数据加密：例如针对个人的账号、密码、手机号等敏感信息进行加密传输，打印接口日志时需要做数据模糊化处理等，不能明文打印；</li><li>对调用方的身份认证：调用来源是否合法，是否有访问某个资源的权限，防止越权访问；</li><li>数据防篡改和完整性：通过对请求参数、消息头和消息体做签名，防止请求消息在传输过程中被非法篡改。</li></ul> 
<h3><a id="12__35"></a>1.2 敏感数据加密传输</h3> 
<h4><a id="121__SSLTLS__36"></a>1.2.1 基于 SSL/TLS 的通道加密</h4> 
<p>当存在跨网络边界的 RPC 调用时，往往需要通过 TLS/SSL 对传输通道进行加密，以防止请求和响应消息中的敏感数据泄漏。跨网络边界调用场景主要有三种：</p> 
<ul><li>后端微服务直接开放给端侧，例如手机 App、TV、多屏等，没有统一的 API Gateway/SLB 做安全接入和认证；</li><li>后端微服务直接开放给 DMZ 部署的管理或者运维类 Portal；</li><li>后端微服务直接开放给第三方合作伙伴 / 渠道。</li></ul> 
<p>除了跨网络之外，对于一些安全等级要求比较高的业务场景，即便是内网通信，只要跨主机 /VM/ 容器通信，都强制要求对传输通道进行加密。在该场景下，即便只存在内网各模块的 RPC 调用，仍然需要做 SSL/TLS。</p> 
<p>使用 SSL/TLS 的典型场景如下所示：<br> <img src="https://images2.imgbox.com/41/06/QW2586aI_o.png" alt="在这里插入图片描述"><br> 目前使用最广的 SSL/TLS 工具 / 类库就是 OpenSSL，它是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及 SSL 协议。</p> 
<p>多数 SSL 加密网站是用名为 OpenSSL 的开源软件包，由于这也是互联网应用最广泛的安全传输方法，被网银、在线支付、电商网站、门户网站、电子邮件等重要网站广泛使用。</p> 
<h4><a id="122__51"></a>1.2.2 针对敏感数据的单独加密</h4> 
<p>有些 RPC 调用并不涉及敏感数据的传输，或者敏感字段占比较低，为了最大程度的提升吞吐量，降低调用时延，通常会采用 HTTP/TCP + 敏感字段单独加密的方式，既保障了敏感信息的传输安全，同时也降低了采用 SSL/TLS 加密通道带来的性能损耗，对于 JDK 原生的 SSL 类库，这种性能提升尤其明显。</p> 
<p>它的工作原理如下所示：<br> <img src="https://images2.imgbox.com/2a/a3/oi7a6e1g_o.png" alt="在这里插入图片描述"><br> 通常使用 Handler 拦截机制，对请求和响应消息进行统一拦截，根据注解或者加解密标识对敏感字段进行加解密，这样可以避免侵入业务。</p> 
<p>采用该方案的缺点主要有两个：</p> 
<ul><li>对敏感信息的识别可能存在偏差，容易遗漏或者过度保护，需要解读数据和隐私保护方面的法律法规，而且不同国家对敏感数据的定义也不同，这会为识别带来很多困难；</li><li>接口升级时容易遗漏，例如开发新增字段，忘记识别是否为敏感数据。</li></ul> 
<h3><a id="13__63"></a>1.3 认证和鉴权</h3> 
<p>RPC 的认证和鉴权机制主要包含两点：</p> 
<ul><li>认证：对调用方身份进行识别，防止非法调用；</li><li>鉴权：对调用方的权限进行校验，防止越权调用。</li></ul> 
<p>事实上，并非所有的 RPC 调用都必须要做认证和鉴权，例如通过 API Gateway 网关接入的流量，已经在网关侧做了鉴权和身份认证，对来自网关的流量 RPC 服务端就不需要重复鉴权。</p> 
<p>另外，一些对安全性要求不太高的场景，可以只做认证而不做细粒度的鉴权。</p> 
<h4><a id="131__73"></a>1.3.1 身份认证</h4> 
<p>内部 RPC 调用的身份认证场景，主要有如下两大类：</p> 
<ul><li>防止对方知道服务提供者的地址之后，绕过注册中心 / 服务路由策略直接访问 RPC 服务提供端；</li><li>RPC 服务只想供内部模块调用，不想开放给其它业务系统使用（双方网络是互通的）。</li></ul> 
<p>身份认证的方式较多，例如 HTTP Basic Authentication、OAuth2 等，比较简单使用的是令牌认证（Token）机制，它的工作原理如下所示：<br> <img src="https://images2.imgbox.com/34/c5/HExCowTE_o.png" alt="在这里插入图片描述"><br> 工作原理如下：</p> 
<ul><li>RPC 客户端和服务端通过 HTTPS 与注册中心连接，做双向认证，以保证客户端和服务端与注册中心之间的安全；</li><li>服务端生成 Token 并注册到注册中心，由注册中心下发给订阅者。通过订阅 / 发布机制，向 RPC 客户端做 Token 授权；</li><li>服务端开启身份认证，对 RPC 调用进行 Token 校验，认证通过之后才允许调用后端服务接口。</li></ul> 
<h4><a id="132__87"></a>1.3.2 权限管控</h4> 
<p>身份认证可以防止非法调用，如果需要对调用方进行更细粒度的权限管控，则需要做对 RPC 调用做鉴权。例如管理员可以查看、修改和删除某个后台资源，而普通用户只能查看资源，不能对资源做管理操作。</p> 
<p>在 RPC 调用领域比较流行的是基于 OAuth2.0 的权限认证机制，它的工作原理如下：<br> <img src="https://images2.imgbox.com/fe/d9/LyyQXzIT_o.png" alt="在这里插入图片描述"><br> OAuth2.0 的认证流程如下：</p> 
<ul><li>客户端向资源拥有者申请授权（例如携带用户名 + 密码等证明身份信息的凭证）；</li><li>资源拥有者对客户端身份进行校验，通过之后同意授权；</li><li>客户端使用步骤 2 的授权凭证，向认证服务器申请资源访问令牌（access token）；</li><li>认证服务器对授权凭证进行合法性校验，通过之后，颁发 access token；</li><li>客户端携带 access token（通常在 HTTP Header 中）访问后端资源，例如发起 RPC 调用；</li><li>服务端对 access token 合法性进行校验（是否合法、是否过期等），同时对 token 进行解析，获取客户端的身份信息以及对应的资源访问权限列表，实现对资源访问权限的细粒度管控；</li><li>access token 校验通过，返回资源信息给客户端。</li></ul> 
<p>步骤 2 的用户授权，有四种方式：</p> 
<ul><li>授权码模式（authorization code）</li><li>简化模式（implicit）</li><li>密码模式（resource owner password credentials）</li><li>客户端模式（client credentials）</li></ul> 
<p>需要指出的是，OAuth 2.0 是一个规范，不同厂商即便遵循该规范，实现也可能会存在细微的差异。大部分厂商在采用 OAuth 2.0 的基础之上，往往会衍生出自己特有的 OAuth 2.0 实现。</p> 
<p>对于 access token，为了提升性能，RPC 服务端往往会缓存，不需要每次调用都与 AS 服务器做交互。同时，access token 是有过期时间的，根据业务的差异，过期时间也会不同。客户端在 token 过期之前，需要刷新 Token，或者申请一个新的 Token。</p> 
<p>考虑到 access token 的安全，通常选择 SSL/TLS 加密传输，或者对 access token 单独做加密，防止 access token 泄漏。</p> 
<h3><a id="14__115"></a>1.4 数据完整性和一致性</h3> 
<p>RPC 调用，除了数据的机密性和有效性之外，还有数据的完整性和一致性需要保证，即如何保证接收方收到的数据与发送方发出的数据是完全相同的。</p> 
<p>利用消息摘要可以保障数据的完整性和一致性，它的特点如下：</p> 
<ul><li>单向 Hash 算法，从明文到密文的不可逆过程，即只能加密而不能解密；</li><li>无论消息大小，经过消息摘要算法加密之后得到的密文长度都是固定的；</li><li>输入相同，则输出一定相同。</li></ul> 
<p>目前常用的消息摘要算法是 SHA-1、MD5 和 MAC，MD5 可产生一个 128 位的散列值。 SHA-1 则是以 MD5 为原型设计的安全散列算法，可产生一个 160 位的散列值，安全性更高一些。MAC 除了能够保证消息的完整性，还能够保证来源的真实性。</p> 
<p>由于 MD5 已被发现有许多漏洞，在实际应用中更多使用 SHA 和 MAC，而且往往会把数字签名和消息摘要混合起来使用。</p> 
<h2><a id="2_gRPC__128"></a>2. gRPC 安全机制</h2> 
<p>谷歌提供了可扩展的安全认证机制，以满足不同业务场景需求，它提供的授权机制主要有四类：</p> 
<ul><li>通道凭证：默认提供了基于 HTTP/2 的 TLS，对客户端和服务端交换的所有数据进行加密传输；</li><li>调用凭证：被附加在每次 RPC 调用上，通过 Credentials 将认证信息附加到消息头中，由服务端做授权认证；</li><li>组合凭证：将一个频道凭证和一个调用凭证关联起来创建一个新的频道凭证，在这个频道上的每次调用会发送组合的调用凭证来作为授权数据，最典型的场景就是使用 HTTP S 来传输 Access Token；</li><li>Google 的 OAuth 2.0：gRPC 内置的谷歌的 OAuth 2.0 认证机制，通过 gRPC 访问 Google API 时，使用 Service Accounts 密钥作为凭证获取授权令牌。</li></ul> 
<h3><a id="21_SSLTLS__136"></a>2.1 SSL/TLS 认证</h3> 
<p>gRPC 基于 HTTP/2 协议，默认会开启 SSL/TLS，考虑到兼容性和适用范围，gRPC 提供了三种协商机制：</p> 
<p>PlaintextNegotiator：非 SSL/TLS 加密传输的 HTTP/2 通道，不支持客户端通过 HTTP/1.1 的 Upgrade 升级到 HTTP/2, 代码示例如下（PlaintextNegotiator 类）：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">static</span> final <span class="token keyword">class</span> <span class="token class-name">PlaintextNegotiator</span> implements ProtocolNegotiator <span class="token punctuation">{<!-- --></span>
 @Override
 <span class="token keyword">public</span> Handler <span class="token function">newHandler</span><span class="token punctuation">(</span>GrpcHttp2ConnectionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">BufferUntilChannelActiveHandler</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>PlaintextUpgradeNegotiator：非 SSL/TLS 加密传输的 HTTP/2 通道，支持客户端通过 HTTP/1.1 的 Upgrade 升级到 HTTP/2，代码示例如下（PlaintextUpgradeNegotiator 类）：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">static</span> final <span class="token keyword">class</span> <span class="token class-name">PlaintextUpgradeNegotiator</span> implements ProtocolNegotiator <span class="token punctuation">{<!-- --></span>
 @Override
 <span class="token keyword">public</span> Handler <span class="token function">newHandler</span><span class="token punctuation">(</span>GrpcHttp2ConnectionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Http2ClientUpgradeCodec upgradeCodec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Http2ClientUpgradeCodec</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
   HttpClientCodec httpClientCodec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">HttpClientCodec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   final HttpClientUpgradeHandler upgrader <span class="token operator">=</span>
       <span class="token keyword">new</span> <span class="token function">HttpClientUpgradeHandler</span><span class="token punctuation">(</span>httpClientCodec<span class="token punctuation">,</span> upgradeCodec<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">BufferingHttp2UpgradeHandler</span><span class="token punctuation">(</span>upgrader<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>TlsNegotiator：基于 SSL/TLS 加密传输的 HTTP/2 通道，代码示例如下（TlsNegotiator 类）：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">static</span> final <span class="token keyword">class</span> <span class="token class-name">TlsNegotiator</span> implements ProtocolNegotiator <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">private</span> final SslContext sslContext<span class="token punctuation">;</span>
   <span class="token keyword">private</span> final String host<span class="token punctuation">;</span>
   <span class="token keyword">private</span> final <span class="token keyword">int</span> port<span class="token punctuation">;</span>
   <span class="token function">TlsNegotiator</span><span class="token punctuation">(</span>SslContext sslContext<span class="token punctuation">,</span> String host<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>sslContext <span class="token operator">=</span> <span class="token function">checkNotNull</span><span class="token punctuation">(</span>sslContext<span class="token punctuation">,</span> <span class="token string">"sslContext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>host <span class="token operator">=</span> <span class="token function">checkNotNull</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> <span class="token string">"host"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>port <span class="token operator">=</span> port<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> 
<p>下面对 gRPC 的 SSL/TLS 工作原理进行详解。</p> 
<h4><a id="211_SSLTLS__176"></a>2.1.1 SSL/TLS 工作原理</h4> 
<p>SSL/TLS 分为单向认证和双向认证，在实际业务中，单向认证使用较多，即客户端认证服务端，服务端不认证客户端。</p> 
<p>SSL 单向认证的过程原理如下：</p> 
<ul><li>SL 客户端向服务端传送客户端 SSL 协议的版本号、支持的加密算法种类、产生的随机数，以及其它可选信息；</li><li>服务端返回握手应答，向客户端传送确认 SSL 协议的版本号、加密算法的种类、随机数以及其它相关信息；</li><li>服务端向客户端发送自己的公钥；</li><li>客户端对服务端的证书进行认证，服务端的合法性校验包括：证书是否过期、发行服务器证书的 CA 是否可靠、发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”、服务器证书上的域名是否和服务器的实际域名相匹配等；</li><li>客户端随机产生一个用于后面通讯的“对称密码”，然后用服务端的公钥对其加密，将加密后的“预主密码”传给服务端；</li><li>服务端将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主密码；</li><li>客户端向服务端发出信息，指明后面的数据通讯将使用主密码为对称密钥，同时通知服务器客户端的握手过程结束；</li><li>服务端向客户端发出信息，指明后面的数据通讯将使用主密码为对称密钥，同时通知客户端服务器端的握手过程结束；</li><li>SSL 的握手部分结束，SSL 安全通道建立，客户端和服务端开始使用相同的对称密钥对数据进行加密，然后-通过 Socket 进行传输。</li></ul> 
<p>SSL 单向认证的流程图如下所示：<br> <img src="https://images2.imgbox.com/d4/bd/fC1cnZAG_o.png" alt="在这里插入图片描述"><br> SSL 双向认证相比单向认证，多了一步服务端发送认证请求消息给客户端，客户端发送自签名证书给服务端进行安全认证的过程。</p> 
<p>客户端接收到服务端要求客户端认证的请求消息之后，发送自己的证书信息给服务端，信息如下：<br> <img src="https://images2.imgbox.com/5c/9c/Hxr4yy45_o.png" alt="在这里插入图片描述"><br> 服务端对客户端的自签名证书进行认证，信息如下：<br> <img src="https://images2.imgbox.com/0f/24/MJiO2aRj_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="212_HTTP2__ALPN_201"></a>2.1.2 HTTP/2 的 ALPN</h4> 
<p>对于一些新的 web 协议，例如 HTTP/2，客户端和浏览器需要知道服务端是否支持 HTTP/2, 对于 HTTP/2 Over HTTP 可以使用 HTTP/1.1 的 Upgrade 机制进行协商，对于 HTTP/2 Over TLS，则需要使用到 NPN 或 ALPN 扩展来完成协商。</p> 
<p>ALPN 作为 HTTP/2 Over TLS 的协商机制，已经被定义到 RFC7301 中，从 2016 年开始它已经取代 NPN 成为 HTTP/2Over TLS 的标准协商机制。目前所有支持 HTTP/2 的浏览器都已经支持 ALPN。</p> 
<p>Jetty 为 OpenJDK 7 和 OpenJDK 8 提供了扩展的 ALPN 实现（JDK 默认不支持），ALPN 类库与 Jetty 容器本身并不强绑定，无论是否使用 Jetty 作为 Web 容器，都可以集成 Jetty 提供的 ALPN 类库，以实现基于 TLS 的 HTTP/2 协议。</p> 
<p>如果要开启 ALPN，需要增加如下 JVM 启动参数：</p> 
<pre><code class="prism language-bash">java -Xbootclasspath/p:<span class="token operator">&lt;</span>path_to_alpn_boot_jar<span class="token operator">&gt;</span> <span class="token punctuation">..</span>.
</code></pre> 
<p>客户端代码示例如下：</p> 
<pre><code class="prism language-cpp">SSLContext sslContext <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
final SSLSocket sslSocket <span class="token operator">=</span> <span class="token punctuation">(</span>SSLSocket<span class="token punctuation">)</span>context<span class="token punctuation">.</span><span class="token function">getSocketFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createSocket</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span><span class="token function">getLocalPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ALPN<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>sslSocket<span class="token punctuation">,</span> <span class="token keyword">new</span> ALPN<span class="token punctuation">.</span><span class="token function">ClientProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> boolean <span class="token function">supports</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> <span class="token function">protocols</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"h2"</span><span class="token punctuation">,</span> <span class="token string">"http/1.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unsupported</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        ALPN<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>sslSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selected</span><span class="token punctuation">(</span>String protocol<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        ALPN<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>sslSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>服务端代码如下：</p> 
<pre><code class="prism language-cpp">final SSLSocket sslSocket <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
ALPN<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>sslSocket<span class="token punctuation">,</span> <span class="token keyword">new</span> ALPN<span class="token punctuation">.</span><span class="token function">ServerProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unsupported</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        ALPN<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>sslSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> String <span class="token function">select</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> protocols<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">{<!-- --></span>
        ALPN<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>sslSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> protocols<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上代码示例来源：链接</p> 
<p>需要指出的是，Jetty ALPN 类库版本与 JDK 版本是配套使用的，配套关系如下所示：<br> <img src="https://images2.imgbox.com/1f/fb/zv6SJLz6_o.png" alt="在这里插入图片描述"><br> 可以通过如下网站查询双方的配套关系：链接</p> 
<p>如果大家需要了解更多的 Jetty ALPN 相关信息，可以下载 jetty 的 ALPN 源码和文档学习。</p> 
<h4><a id="213_gRPC__TLS__260"></a>2.1.3 gRPC 的 TLS 策略</h4> 
<p>gRPC 的 TLS 实现有两种策略：</p> 
<ul><li>基于 OpenSSL 的 TLS</li><li>基于 Jetty ALPN/NPN 的 TLS</li></ul> 
<p>对于非安卓的后端 Java 应用，gRPC 强烈推荐使用 OpenSSL，原因如下：</p> 
<ul><li>性能更高：基于 OpenSSL 的 gRPC 调用比使用 JDK GCM 的性能高 10 倍以上；</li><li>密码算法更丰富：OpenSSL 支持的密码算法比 JDK SSL 提供的更丰富，特别是 HTTP/2 协议使用的加密算法；</li><li>OpenSSL 支持 ALPN 回退到 NPN；</li><li>不需要根据 JDK 的版本升级配套升级 ALPN 类库（Jetty 的 ALPN 版本与 JDK 特定版本配套使用）。</li></ul> 
<p>gRPC 的 HTTP/2 和 TLS 基于 Netty 框架实现，如果使用 OpenSSL，则需要依赖 Netty 的 netty-tcnative。</p> 
<p>Netty 的 OpenSSL 有两种实现机制：Dynamic linked 和 Statically Linked。在开发和测试环境中，建议使用 Statically Linked 的方式（netty-tcnative-boringssl-static），它提供了对 ALPN 的支持以及 HTTP/2 需要的密码算法，不需要额外再集成 Jetty 的 ALPN 类库。从 1.1.33.Fork16 版本开始支持所有的操作系统，可以实现跨平台运行。</p> 
<p>对于生产环境，则建议使用 Dynamic linked 的方式，原因如下：</p> 
<ul><li>很多场景下需要升级 OpenSSL 的版本或者打安全补丁，如果使用动态链接方式（例如 apt-ge），则应用软件不需要级联升级；</li><li>对于一些紧急的 OpenSSL 安全补丁，如果采用 Statically Linked 的方式，需要等待 Netty 社区提供新的静态编译补丁版本，可能会存在一定的滞后性。</li></ul> 
<p>netty-tcnative-boringssl-static 的 Maven 配置如下：</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>project<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>dependencies<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>io.netty<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>netty-tcnative-boringssl-static<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span>2.0.6.Final<span class="token operator">&lt;</span>/version<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>/dependencies<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/project<span class="token operator">&gt;</span>
</code></pre> 
<p>使用 Dynamically Linked (netty-tcnative) 的相关约束如下：</p> 
<pre><code class="prism language-bash">OpenSSL version <span class="token operator">&gt;=</span> 1.0.2 <span class="token keyword">for</span> ALPN
</code></pre> 
<p>或者</p> 
<pre><code class="prism language-bash">version <span class="token operator">&gt;=</span> 1.0.1 <span class="token keyword">for</span> NPN
</code></pre> 
<p>类路径中包含</p> 
<pre><code class="prism language-bash">netty-tcnative version <span class="token operator">&gt;=</span> 1.1.33.Fork7
</code></pre> 
<p>尽管 gRPC 强烈不建议使用基于 JDK 的 TLS，但是它还是提供了对 Jetty ALPN/NPN 的支持。</p> 
<p>通过 Xbootclasspath 参数开启 ALPN，示例如下：</p> 
<blockquote> 
 <p>java -Xbootclasspath/p:/path/to/jetty/alpn/extension.jar</p> 
</blockquote> 
<p>由于 ALPN 类库与 JDK 版本号有强对应关系，如果匹配错误，则会导致 SSL 握手失败，因此可以通过 Jetty-ALPN-Agent 来自动为 JDK 版本选择合适的 ALPN 版本，启动参数如下所示：</p> 
<blockquote> 
 <p>java -javaagent:/path/to/jetty-alpn-agent.jar</p> 
</blockquote> 
<h4><a id="214__TLS__gRPC__316"></a>2.1.4 基于 TLS 的 gRPC 代码示例</h4> 
<p>以基于 JDK（Jetty-ALPN）的 TLS 为例，给出 gRPC SSL 安全认证的代码示例。</p> 
<p>TLS 服务端创建：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">18443</span><span class="token punctuation">;</span>
    SelfSignedCertificate ssc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">SelfSignedCertificate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    server <span class="token operator">=</span> ServerBuilder<span class="token punctuation">.</span><span class="token function">forPort</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">useTransportSecurity</span><span class="token punctuation">(</span>ssc<span class="token punctuation">.</span><span class="token function">certificate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            ssc<span class="token punctuation">.</span><span class="token function">privateKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">addService</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">GreeterImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中 SelfSignedCertificate 是 Netty 提供的用于测试的临时自签名证书类，在实际项目中，需要加载生成环境的 CA 和密钥。</p> 
<p>在启动参数中增加 SSL 握手日志打印以及 Jetty 的 ALPN Agent 类库，示例如下：<br> <img src="https://images2.imgbox.com/68/7c/WxaXTwVw_o.png" alt="在这里插入图片描述"><br> 启动服务端，显示 SSL 证书已经成功加载：<br> <img src="https://images2.imgbox.com/a9/a8/I5V4aSF8_o.png" alt="在这里插入图片描述"><br> TLS 客户端代码创建：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">this</span><span class="token punctuation">(</span>NettyChannelBuilder<span class="token punctuation">.</span><span class="token function">forAddress</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sslContext</span><span class="token punctuation">(</span>
            GrpcSslContexts<span class="token punctuation">.</span><span class="token function">forClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
            <span class="token function">ciphers</span><span class="token punctuation">(</span>Http2SecurityUtil<span class="token punctuation">.</span>CIPHERS<span class="token punctuation">,</span>
                    SupportedCipherSuiteFilter<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">)</span><span class="token punctuation">.</span>
            <span class="token function">trustManager</span><span class="token punctuation">(</span>InsecureTrustManagerFactory<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>NettyChannel 创建时，使用 gRPC 的 GrpcSslContexts 指定客户端模式，设置 HTTP/2 的密钥，同时加载 CA 证书工厂，完成 TLS 客户端的初始化。</p> 
<p>与服务端类似，需要通过 -javaagent 指定 ALPN Agent 类库路径，同时开启 SSL 握手调试日志打印，启动客户端，运行结果如下所示：<br> <img src="https://images2.imgbox.com/c6/49/yicFuIdp_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="215_gRPC_TLS__349"></a>2.1.5 gRPC TLS 源码分析</h4> 
<p>gRPC 在 Netty SSL 类库基础上做了二次封装，以简化业务的使用，以服务端代码为例进行说明，服务端开启 TLS，代码如下（NettyServerBuilder 类）：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">public</span> NettyServerBuilder <span class="token function">useTransportSecurity</span><span class="token punctuation">(</span>File certChain<span class="token punctuation">,</span> File privateKey<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
      sslContext <span class="token operator">=</span> GrpcSslContexts<span class="token punctuation">.</span><span class="token function">forServer</span><span class="token punctuation">(</span>certChain<span class="token punctuation">,</span> privateKey<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>实际调用 GrpcSslContexts 创建了 Netty SslContext，下面一起分析下 GrpcSslContexts 的实现，它调用了 Netty SslContextBuilder，加载 X.509 certificate chain file 和 PKCS#8 private key file（PEM 格式），代码如下（SslContextBuilder 类）：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">public</span> <span class="token keyword">static</span> SslContextBuilder <span class="token function">forServer</span><span class="token punctuation">(</span>File keyCertChainFile<span class="token punctuation">,</span> File keyFile<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">SslContextBuilder</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">keyManager</span><span class="token punctuation">(</span>keyCertChainFile<span class="token punctuation">,</span> keyFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>Netty 的 SslContext 加载 keyCertChainFile 和 private key file（SslContextBuilder 类）：</p> 
<pre><code class="prism language-cpp">X509Certificate<span class="token punctuation">[</span><span class="token punctuation">]</span> keyCertChain<span class="token punctuation">;</span>
        PrivateKey key<span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            keyCertChain <span class="token operator">=</span> SslContext<span class="token punctuation">.</span><span class="token function">toX509Certificates</span><span class="token punctuation">(</span>keyCertChainFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token function">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"File does not contain valid certificates: "</span> <span class="token operator">+</span> keyCertChainFile<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            key <span class="token operator">=</span> SslContext<span class="token punctuation">.</span><span class="token function">toPrivateKey</span><span class="token punctuation">(</span>keyFile<span class="token punctuation">,</span> keyPassword<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>加载完成之后，通过 SslContextBuilder 创建 SslContext，完成 SSL 上下文的创建。</p> 
<p>服务端开启 SSL 之后，gRPC 会根据初始化完成的 SslContext 创建 SSLEngine，然后实例化 Netty 的 SslHandler，将其加入到 ChannelPipeline 中，代码示例如下（ServerTlsHandler 类）：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handlerAdded</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">)</span> throws Exception <span class="token punctuation">{<!-- --></span>
      super<span class="token punctuation">.</span><span class="token function">handlerAdded</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>
      SSLEngine sslEngine <span class="token operator">=</span> sslContext<span class="token punctuation">.</span><span class="token function">newEngine</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      ctx<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">SslHandler</span><span class="token punctuation">(</span>sslEngine<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>下面一起分析下 Netty SSL 服务端的源码，SSL 服务端接收客户端握手请求消息的入口方法是 decode 方法，首先获取接收缓冲区的读写索引，并对读取的偏移量指针进行备份（SslHandler 类）：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">decode</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> ByteBuf in<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span> out<span class="token punctuation">)</span> throws SSLException <span class="token punctuation">{<!-- --></span>
        final <span class="token keyword">int</span> startOffset <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        final <span class="token keyword">int</span> endOffset <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">writerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> offset <span class="token operator">=</span> startOffset<span class="token punctuation">;</span>
        <span class="token keyword">int</span> totalLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p>对半包标识进行判断，如果上一个消息是半包消息，则判断当前可读的字节数是否小于整包消息的长度，如果小于整包长度，则说明本次读取操作仍然没有把 SSL 整包消息读取完整，需要返回 I/O 线程继续读取，代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>packetLength <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>endOffset <span class="token operator">-</span> startOffset <span class="token operator">&lt;</span> packetLength<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p>如果消息读取完整，则修改偏移量：同时置位半包长度标识：</p> 
<pre><code class="prism language-cpp"><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                offset <span class="token operator">+</span><span class="token operator">=</span> packetLength<span class="token punctuation">;</span>
                totalLength <span class="token operator">=</span> packetLength<span class="token punctuation">;</span>
                packetLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
</code></pre> 
<p>下面在 for 循环中读取 SSL 消息，一个 ByteBuf 可能包含多条完整的 SSL 消息。首先判断可读的字节数是否小于协议消息头长度，如果是则退出循环继续由 I/O 线程接收后续的报文：</p> 
<p>if (readableBytes &lt; SslUtils.SSL_RECORD_HEADER_LENGTH) {<!-- --><br> break;<br> }<br> 获取 SSL 消息包的报文长度，具体算法不再介绍，可以参考 SSL 的规范文档进行解读，代码如下（SslUtils 类）：</p> 
<pre><code class="prism language-cpp"> <span class="token keyword">if</span> <span class="token punctuation">(</span>tls<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// SSLv3 or TLS - Check ProtocolVersion</span>
            <span class="token keyword">int</span> majorVersion <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">getUnsignedByte</span><span class="token punctuation">(</span>offset <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>majorVersion <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// SSLv3 or TLS</span>
                packetLength <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">getUnsignedShort</span><span class="token punctuation">(</span>offset <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> SSL_RECORD_HEADER_LENGTH<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p>对长度进行判断，如果 SSL 报文长度大于可读的字节数，说明是个半包消息，将半包标识长度置位，返回 I/O 线程继续读取后续的数据报，代码如下（SslHandler 类）：</p> 
<pre><code class="prism language-cpp"> <span class="token keyword">if</span> <span class="token punctuation">(</span>packetLength <span class="token operator">&gt;</span> readableBytes<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// wait until the whole packet can be read</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>packetLength <span class="token operator">=</span> packetLength<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
</code></pre> 
<p>对消息进行解码，将 SSL 加密的消息解码为加密前的原始数据，unwrap 方法如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">private</span> boolean <span class="token function">unwrap</span><span class="token punctuation">(</span>
            ChannelHandlerContext ctx<span class="token punctuation">,</span> ByteBuf packet<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> throws SSLException <span class="token punctuation">{<!-- --></span>

        boolean decoded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        boolean wrapLater <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        boolean notifyClosure <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        ByteBuf decodeOut <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>ctx<span class="token punctuation">.</span><span class="token function">isRemoved</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                final SSLEngineResult result <span class="token operator">=</span> engineType<span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> packet<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> length<span class="token punctuation">,</span> decodeOut<span class="token punctuation">)</span><span class="token punctuation">;</span>
                final Status status <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p>调用 SSLEngine 的 unwrap 方法对 SSL 原始消息进行解码，对解码结果进行判断，如果越界，说明 out 缓冲区不够，需要进行动态扩展。如果是首次越界，为了尽量节约内存，使用 SSL 最大缓冲区长度和 SSL 原始缓冲区可读的字节数中较小的。如果再次发生缓冲区越界，说明扩张后的缓冲区仍然不够用，直接使用 SSL 缓冲区的最大长度，保证下次解码成功。</p> 
<p>解码成功之后，对 SSL 引擎的操作结果进行判断：如果需要继续接收数据，则继续执行解码操作；如果需要发送握手消息，则调用 wrapNonAppData 发送握手消息；如果需要异步执行 SSL 代理任务，则调用立即执行线程池执行代理任务；如果是握手成功，则设置 SSL 操作结果，发送 SSL 握手成功事件；如果是应用层的业务数据，则继续执行解码操作，其它操作结果，抛出操作类型异常（SslHandler 类）：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">switch</span> <span class="token punctuation">(</span>handshakeStatus<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">case</span> NEED_UNWRAP<span class="token operator">:</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token keyword">case</span> NEED_WRAP<span class="token operator">:</span>
                        <span class="token function">wrapNonAppData</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token keyword">case</span> NEED_TASK<span class="token operator">:</span>
                        <span class="token function">runDelegatedTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token keyword">case</span> FINISHED<span class="token operator">:</span>
                        <span class="token function">setHandshakeSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        wrapLater <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p>需要指出的是，SSL 客户端和服务端接收对方 SSL 握手消息的代码是相同的，那为什么 SSL 服务端和客户端发送的握手消息不同呢？这些是 SSL 引擎负责区分和处理的，我们在创建 SSL 引擎的时候设置了客户端模式，SSL 引擎就是根据这个来进行区分的。</p> 
<p>SSL 的消息读取实际就是 ByteToMessageDecoder 将接收到的 SSL 加密后的报文解码为原始报文，然后将整包消息投递给后续的消息解码器，对消息做二次解码。基于 SSL 的消息解码模型如下：<br> <img src="https://images2.imgbox.com/b5/dc/Qg1j3TRz_o.png" alt="在这里插入图片描述"><br> SSL 消息读取的入口都是 decode，因为是非握手消息，它的处理非常简单，就是循环调用引擎的 unwrap 方法，将 SSL 报文解码为原始的报文，代码如下（SslHandler 类）：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">switch</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">case</span> BUFFER_OVERFLOW<span class="token operator">:</span>
                    <span class="token keyword">int</span> readableBytes <span class="token operator">=</span> decodeOut<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">int</span> bufferSize <span class="token operator">=</span> engine<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getApplicationBufferSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> readableBytes<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>readableBytes <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        decoded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                        ctx<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>decodeOut<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p>握手成功之后的所有消息都是应用数据，因此它的操作结果为 NOT_HANDSHAKING，遇到此标识之后继续读取消息，直到没有可读的字节，退出循环。</p> 
<p>如果读取到了可用的字节，则将读取到的缓冲区加到输出结果列表中，有后续的 Handler 进行处理，例如对 HTTPS 的请求报文做反序列化。</p> 
<p>SSL 消息发送时，由 SslHandler 对消息进行编码，编码后的消息实际就是 SSL 加密后的消息。从待加密的消息队列中弹出消息，调用 SSL 引擎的 wrap 方法进行编码，代码如下（SslHandler 类）：</p> 
<pre><code class="prism language-cpp"> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>ctx<span class="token punctuation">.</span><span class="token function">isRemoved</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                Object msg <span class="token operator">=</span> pendingUnencryptedWrites<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                ByteBuf buf <span class="token operator">=</span> <span class="token punctuation">(</span>ByteBuf<span class="token punctuation">)</span> msg<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>out <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    out <span class="token operator">=</span> <span class="token function">allocateOutNetBuf</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> buf<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                SSLEngineResult result <span class="token operator">=</span> <span class="token function">wrap</span><span class="token punctuation">(</span>alloc<span class="token punctuation">,</span> engine<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>wrap 方法很简单，就是调用 SSL 引擎的编码方法，然后对写索引进行修改，如果缓冲区越界，则动态扩展缓冲区：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                ByteBuffer out0 <span class="token operator">=</span> out<span class="token punctuation">.</span><span class="token function">nioBuffer</span><span class="token punctuation">(</span>out<span class="token punctuation">.</span><span class="token function">writerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> out<span class="token punctuation">.</span><span class="token function">writableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                SSLEngineResult result <span class="token operator">=</span> engine<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>in0<span class="token punctuation">,</span> out0<span class="token punctuation">)</span><span class="token punctuation">;</span>
                in<span class="token punctuation">.</span><span class="token function">skipBytes</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">bytesConsumed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                out<span class="token punctuation">.</span><span class="token function">writerIndex</span><span class="token punctuation">(</span>out<span class="token punctuation">.</span><span class="token function">writerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> result<span class="token punctuation">.</span><span class="token function">bytesProduced</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p>对 SSL 操作结果进行判断，因为已经握手成功，因此返回的结果是 NOT_HANDSHAKING，执行 finishWrap 方法，调用 ChannelHandlerContext 的 write 方法，将消息写入发送缓冲区中，如果待发送的消息为空，则构造空的 ByteBuf 写入（SslHandler 类）：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">finishWrap</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> ByteBuf out<span class="token punctuation">,</span> ChannelPromise promise<span class="token punctuation">,</span> boolean inUnwrap<span class="token punctuation">,</span>
            boolean needUnwrap<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>out <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            out <span class="token operator">=</span> Unpooled<span class="token punctuation">.</span>EMPTY_BUFFER<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>out<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            out<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            out <span class="token operator">=</span> Unpooled<span class="token punctuation">.</span>EMPTY_BUFFER<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>promise <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            ctx<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            ctx<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
<p>编码后，调用 ChannelHandlerContext 的 flush 方法消息发送给对方，完成消息的加密发送。</p> 
<h3><a id="22_Google_OAuth_20_523"></a>2.2 Google OAuth 2.0</h3> 
<h4><a id="221__524"></a>2.2.1 工作原理</h4> 
<p>gRPC 默认提供了多种 OAuth 2.0 认证机制，假如 gRPC 应用运行在 GCE 里，可以通过服务账号的密钥生成 Token 用于 RPC 调用的鉴权，密钥可以从环境变量 GOOGLE_APPLICATION_CREDENTIALS 对应的文件里加载。如果使用 GCE，可以在虚拟机设置的时候为其配置一个默认的服务账号，运行是可以与认证系统交互并为 Channel 生成 RPC 调用时的 access Token。</p> 
<h4><a id="222__527"></a>2.2.2 代码示例</h4> 
<p>以 OAuth2 认证为例，客户端代码如下所示，创建 OAuth2Credentials，并实现 Token 刷新接口：<br> <img src="https://images2.imgbox.com/ae/5d/coI5s77I_o.png" alt="在这里插入图片描述"><br> 创建 Stub 时，指定 CallCredentials，代码示例如下（基于 gRPC1.3 版本，不同版本接口可能发生变化）：</p> 
<pre><code class="prism language-cpp">GoogleAuthLibraryCallCredentials callCredentials <span class="token operator">=</span>
            <span class="token keyword">new</span> <span class="token function">GoogleAuthLibraryCallCredentials</span><span class="token punctuation">(</span>credentials<span class="token punctuation">)</span><span class="token punctuation">;</span>
blockingStub <span class="token operator">=</span> GreeterGrpc<span class="token punctuation">.</span><span class="token function">newBlockingStub</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">withCallCredentials</span><span class="token punctuation">(</span>callCredentials<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>下面的代码示例，用于在 GCE 环境中使用 Google 的 OAuth2：</p> 
<pre><code class="prism language-cpp">ManagedChannel channel <span class="token operator">=</span> ManagedChannelBuilder<span class="token punctuation">.</span><span class="token function">forTarget</span><span class="token punctuation">(</span><span class="token string">"pubsub.googleapis.com"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
GoogleCredentials creds <span class="token operator">=</span> GoogleCredentials<span class="token punctuation">.</span><span class="token function">getApplicationDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
creds <span class="token operator">=</span> creds<span class="token punctuation">.</span><span class="token function">createScoped</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"https://www.googleapis.com/auth/pubsub"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
CallCredentials callCreds <span class="token operator">=</span> MoreCallCredentials<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>creds<span class="token punctuation">)</span><span class="token punctuation">;</span>
PublisherGrpc<span class="token punctuation">.</span>PublisherBlockingStub publisherStub <span class="token operator">=</span>
    PublisherGrpc<span class="token punctuation">.</span><span class="token function">newBlockingStub</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withCallCredentials</span><span class="token punctuation">(</span>callCreds<span class="token punctuation">)</span><span class="token punctuation">;</span>
publisherStub<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>someMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="23__551"></a>2.3 自定义安全认证策略</h3> 
<p>参考 Google 内置的 Credentials 实现类，实现自定义的 Credentials，可以扩展 gRPC 的鉴权策略，Credentials 的实现类如下所示：<br> <img src="https://images2.imgbox.com/35/c2/OXliIIdk_o.png" alt="在这里插入图片描述"><br> 以 OAuth2Credentials 为例，实现 getRequestMetadata(URI uri) 方法，获取 access token，将其放入 Metadata 中，通过 CallCredentials 将其添加到请求 Header 中发送到服务端，代码示例如下（GoogleAuthLibraryCallCredentials 类）：</p> 
<pre><code class="prism language-cpp">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">&gt;&gt;</span> metadata <span class="token operator">=</span> creds<span class="token punctuation">.</span><span class="token function">getRequestMetadata</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Metadata headers<span class="token punctuation">;</span>
            synchronized <span class="token punctuation">(</span>GoogleAuthLibraryCallCredentials<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>lastMetadata <span class="token operator">==</span> null <span class="token operator">||</span> lastMetadata <span class="token operator">!=</span> metadata<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                lastMetadata <span class="token operator">=</span> metadata<span class="token punctuation">;</span>
                lastHeaders <span class="token operator">=</span> <span class="token function">toHeaders</span><span class="token punctuation">(</span>metadata<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span>
              headers <span class="token operator">=</span> lastHeaders<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            applier<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>headers<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>对于扩展方需要自定义 Credentials，实现 getRequestMetadata(URI uri) 方法，由 gRPC 的 CallCredentials 将鉴权信息加入到 HTTP Header 中发送到服务端。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c3b8f703a969511378b0c3b8cf463e08/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js删除某个节点之后的所有节点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4973907ef2c8e42068b151cc643842c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何查看本机路由表并进行分析？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>