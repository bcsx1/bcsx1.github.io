<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM 运行流程、类加载、垃圾回收 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM 运行流程、类加载、垃圾回收" />
<meta property="og:description" content="一、JVM 简介 1、JVM JVM 是 Java Virtual Machine 的简称，意为 Java 虚拟机。
虚拟机是指通过软件模拟的具有完整硬件功能的、运行在一个完全隔离的环境中的完整计算机系统。
常见的虚拟机：JVM、VMwave、Virtual Box。
JVM 和其他两个虚拟机的区别：
VMwave 与 VirtualBox 是通过软件模拟物理 CPU 的指令集，物理系统中会有很多的寄存器；JVM 则是通过软件模拟 Java 字节码的指令集，JVM 中只是主要保留了 PC 寄存器，其他的寄存器都进行了裁剪。 JVM 是一台被定制过的现实当中不存在的计算机
每个 jvm 就是一个 java 进程。如果有两个 java 进程，就是两个 jvm 了!!!
为什么要在程序和操作系统中间添加一个 JVM：Java 是一门抽象程度特别高的语言，提供了自动内存管理等一系列的特性。这些特性直接在操作系统上实现是不太可能的，所以就需要 JVM 进行一番转换。
从图中可以看到，有了 JVM 这个抽象层之后，Java 就可以实现跨平台了。JVM 只需要保证能够正确执行 .class 文件，就可以运行在诸如 Linux、Windows、MacOS等平台上了。
Java如何实现跨平台：windows系统，实现了一个windows 版本的JVM，Linux系统,实现了Linux版本的JVM，Mac系统实现了Mac 版本的JVM
随便某个系统，也实现了对应版本的 JVM，跨平台是靠无数个不同版本的 JVM 支持的!! 这些不同的JVM内部封装了，不同系统的API，对上都是执行同样规则的字节码
C, C&#43;&#43;,Go, Rust 都是把代码编译成 native code，也就是 cpu 能识别的机器指令，不需要虚拟机。——针对不同系统 / cpu 生成的机器指令是不一样 (编译出来的可执行程序不一样)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/40c834ecb367d9c0dd94a7d986ded52a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-16T21:42:32+08:00" />
<meta property="article:modified_time" content="2023-07-16T21:42:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM 运行流程、类加载、垃圾回收</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="JVM__0"></a>一、JVM 简介</h2> 
<h3><a id="1JVM_2"></a>1、JVM</h3> 
<p>JVM 是 Java Virtual Machine 的简称，意为 Java 虚拟机。</p> 
<p><strong>虚拟机是指通过软件模拟的具有完整硬件功能的、运行在一个完全隔离的环境中的完整计算机系统。</strong></p> 
<p>常见的虚拟机：JVM、VMwave、Virtual Box。</p> 
<p>JVM 和其他两个虚拟机的区别：</p> 
<ol><li>VMwave 与 VirtualBox 是通过软件模拟物理 CPU 的指令集，物理系统中会有很多的寄存器；</li><li>JVM 则是通过软件模拟 Java 字节码的指令集，JVM 中只是主要保留了 PC 寄存器，其他的寄存器都进行了裁剪。</li></ol> 
<p>JVM 是一台被定制过的现实当中不存在的计算机</p> 
<p><mark>每个 jvm 就是一个 java 进程。如果有两个 java 进程，就是两个 jvm 了!!!</mark></p> 
<p>为什么要在程序和操作系统中间添加一个 JVM：Java 是一门抽象程度特别高的语言，提供了自动内存管理等一系列的特性。这些特性直接在操作系统上实现是不太可能的，所以就需要 JVM 进行一番转换。</p> 
<p>从图中可以看到，有了 JVM 这个抽象层之后，Java 就可以实现<strong>跨平台</strong>了。<strong>JVM 只需要保证能够正确执行 .class 文件</strong>，就可以运行在诸如 Linux、Windows、MacOS等平台上了。</p> 
<blockquote> 
 <p>Java如何实现跨平台：windows系统，实现了一个windows 版本的JVM，Linux系统,实现了Linux版本的JVM，Mac系统实现了Mac 版本的JVM</p> 
 <p>随便某个系统，也实现了对应版本的 JVM，<strong>跨平台是靠无数个不同版本的 JVM 支持的!!</strong> 这些不同的JVM内部封装了，不同系统的API，对上都是执行同样规则的字节码</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ee/a9/qMlW3gmb_o.png" alt="在这里插入图片描述"></p> 
<p>C, C++,Go, Rust 都是把代码编译成 native code，也就是 <strong>cpu 能识别的机器指令，不需要虚拟机</strong>。——<strong>针对不同系统 / cpu 生成的机器指令是不一样</strong> (编译出来的可执行程序不一样)</p> 
<p>Java, Python, PHP, <strong>为了跨平台，都是统一翻译成指定的字节码，然后由对应的虚拟机转换成机器指令</strong>。——<strong>字节码都是一样的</strong>，tomcat windows 上的直接拷贝到 Linux 就能运行，一个 windows 上编译的 c++ 程序，拷贝到 Linux 就不行了(也有特殊手段如 wine)</p> 
<hr> 
<h3><a id="2JVM__45"></a>2、JVM 发展史</h3> 
<h4><a id="21Sun_Classic_VM_47"></a>2.1、Sun Classic VM</h4> 
<p>早在 1996 年 Java1.0 版本的时候，Sun 公司发不了一款名为 Sun Classic vm 的 java 虚拟机，它同时也是世界上第一款商业 java 虚拟机，jdk1.4 时完全被淘汰。</p> 
<p>这款虚拟机内部只提供解释器。</p> 
<p>如果使用 JIT 编译器，就需要进行外挂。但是一旦使用了 JIT 编译器，JIT 就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</p> 
<p>现在 Hotspot 内置了此虚拟机；</p> 
<h4><a id="22Exact_VM_59"></a>2.2、Exact VM</h4> 
<p>为了解决上一个虚拟机问题，jdk1.2 时，sun 提供了此虚拟机。</p> 
<p>Exact 具备现代高性能虚拟机的雏形，包含了一下功能：</p> 
<ol><li> <p>热点探测（将热点代码编译为字节码加速程序执行）；</p> </li><li> <p>编译器与解析器混合工作模式。</p> </li></ol> 
<p>只在 Solaris 平台短暂使用，其他平台上还是 classic vm 。英雄气短，终被 Hotspot 虚拟机替换。</p> 
<h4><a id="23HotSpot_VM_73"></a>2.3、HotSpot VM</h4> 
<p>HotSpot 历史</p> 
<ol><li> <p>最初由一家名为“Longview Technologies”的小公司设计；</p> </li><li> <p>1997年，此公司被Sun收购；2009年，Sun公司被甲骨文收购。</p> </li><li> <p>JDK1.3时，HotSpot VM成为默认虚拟机</p> </li></ol> 
<p>目前 HotSpot 占用绝对的市场地位，称霸武林。</p> 
<p>不管是现在仍在广泛使用 JDK6，还是使用比较多的 JDK8 中，默认的虚拟机都是 HotSpot；<br> <mark>最主流使用的 JVM，Oracle 官方 jdk 和开源的 openjdk 都是使用这个 JVM</mark>。从服务器、桌面到移动端、嵌入式都有应用。</p> 
<p>名称中的 HotSpot 指的就是它的热点代码探测技术。它能通过计数器找到最具编译价值的代码，触发即 时编译 (JIT) 或栈上替换；通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取 得平衡</p> 
<h4><a id="24JRockit_92"></a>2.4、JRockit</h4> 
<p><strong>JRockit 是专注于服务器端应用，目前在HotSpot的基础上，移植JRockit的优秀特性。</strong></p> 
<p>它可以不太关注程序的启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后 执行；</p> 
<p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</p> 
<p>使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达 50%）；</p> 
<p>优势：全面的Java运行时解决方案组合。</p> 
<p>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财 务、军事指挥、电信网络的需要；</p> 
<p>MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具； 2008，BEA被Oracle收购。</p> 
<p>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移 植JRockit的优秀特性。</p> 
<h4><a id="25J9_JVM_112"></a>2.5、J9 JVM</h4> 
<p>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9。</p> 
<p>市场定位于 HotSpot 接近，服务器端、桌面应用、嵌入式等多用途 JVM，广泛用于 IBM 的各种 Java 产品。</p> 
<p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机(在IBM自己的产品上稳定)；</p> 
<p>2017年左右，IBM发布了开源 J9 VM，命名 OpenJ9，交给Eclipse基金会管理，也称为Eclipse OpenJ9。</p> 
<h4><a id="26Taobao_JVM_124"></a>2.6、Taobao JVM（国产研发）</h4> 
<p>由 AliJVM 团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，<br> 需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p> 
<p>基于OpenJDK 开发了自己的定制版本AlibabaJDK,简称AJDK。是整个阿里JAVA体系的基石；</p> 
<p>基于OpenJDK HotSpot JVM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机，它<br> 具有以下特点（了解即可）：</p> 
<ol><li> <p>创新的GCIH(GC invisible heap)技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收评率和提升GC的回收效率的目的。</p> </li><li> <p>GCIH中的对象还能够在多个Java虚拟机进程中实现共享。</p> </li><li> <p>使用crc32指令实现JVM intrinsic降低JNI的调用开销；</p> </li><li> <p>PMU hardware的Java profiling tool和诊断协助功能；</p> </li><li> <p>针对大数据场景的ZenGC。</p> </li></ol> 
<p>taobao JVM应用在阿里产品上性能高，硬件严重依赖intel的cpu,损失了兼容性，但提高了性能，目前已经在淘宝、天猫上线，把Oracle官方JVM版本全部替换了</p> 
<hr> 
<h3><a id="3_JVM_Java_150"></a>3、 JVM 和《Java虚拟机规范》</h3> 
<p>以上的各种 JVM 版本，比如 HotSpot 和 J9 JVM，都可以看做是不同厂商实现 JVM 产品的具体实现，而它们（JVM）产品的实现必须要符合《Java虚拟机规范》，《Java虚拟机规范》是 Oracle 发布 Java 领域最重要和最权威的著作，它完整且详细的描述了 JVM 的各个组成部分</p> 
<p>PS： 本文以下部分，默认都是使用 HotSpot，也就是 Oracle Java 默认的虚拟机为前提来进行介绍的</p> 
<hr> 
<h2><a id="JVM__160"></a>二、JVM 运行流程</h2> 
<p>JVM 是 Java 运行的基础，也是实现一次编译到处执行的关键，那么 JVM 是如何执行的呢 ？</p> 
<h3><a id="1JVM__166"></a>1、JVM 执行流程</h3> 
<p>程序在执行之前先要把 java 代码转换成字节码（class文件），JVM 首先需要把字节码通过一定的方式 <strong>类加载器（ClassLoader）</strong> 把文件加载到内存中 <strong>运行时数据区（Runtime Data Area）</strong> ，而字节码文件是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器 <strong>执行引擎（Execution Engine）</strong> 将字节码翻译成底层系统指令再交由 CPU 去执行，而这个过程中需要调用其他语言的接口 <strong>本地库接口（Native Interface）</strong> 来实现整个程序的功能，这就是这4个主要组成部分的职责与功能。</p> 
<p><img src="https://images2.imgbox.com/0d/cf/HhfG0Yin_o.png" alt="在这里插入图片描述"></p> 
<p>总结来看， JVM 主要通过分为以下 4 个部分，来执行 Java 程序的，它们分别是：</p> 
<ol><li> <p>类加载器（ClassLoader）</p> </li><li> <p>运行时数据区（Runtime Data Area）</p> </li><li> <p>执行引擎（Execution Engine）</p> </li><li> <p>本地库接口（Native Interface）</p> </li></ol> 
<hr> 
<h3><a id="2JVM__188"></a>2、JVM 运行时数据区</h3> 
<h4><a id="21_190"></a>2.1、内存区域划分</h4> 
<blockquote> 
 <p>毛坯房装修时，需要把房子划分成多个房间，每个房间都有不同的作用，如客厅、卧室，厨房等。</p> 
 <p>内存区域划分也是一样，JVM 也就是启动的时候，会申请到一整个很大的内存区域<br> <strong>JVM 是一个应用程序，要从操作系统这里申请内存</strong> (相当于租了个写字楼)<br> JVM 就要根据需要，<strong>把整个空间，分成几个部分</strong>，每个部分各自有不同的功能作用</p> 
</blockquote> 
<p>JVM 运行时数据区域也叫内存布局，但需要注意的是它和 Java 内存模型（(Java Memory Model，简称 JMM）完全不同，属于完全不同的两个概念，它由以下 5 大部分组成：</p> 
<p><img src="https://images2.imgbox.com/eb/56/uGVuD82y_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="__208"></a>① 本地方法栈</h4> 
<p>本地方法栈和虚拟机栈类似，只不过 <strong>Java 虚拟机栈</strong>是给 <strong>JVM</strong> 使用的，而<strong>本地方法栈</strong>是给<strong>本地方法</strong>使用的</p> 
<p>native 就表示是 JVM 内部的 C++ 代码，就是给调用 native 方法 (JVM 内部的方法) 准备的栈空间</p> 
<hr> 
<h4><a id="_Java__218"></a>② Java 虚拟机栈（线程私有）</h4> 
<blockquote> 
 <p>此处所说的栈，和数据结构的栈，不是一个东西 !!</p> 
 <p>数据结构的栈，是一个通用的，更广泛的概念。此处所谈到的栈，是 JVM 中的一个特定空间。</p> 
</blockquote> 
<blockquote> 
 <p><strong>对于JVM虚拟机栈，这里存储的是方法之间的调用关系</strong></p> 
 <ul><li>整个栈空间内部，可以认为是包含很多个元素 (每个元素表示一个方法)<br> 把这里的每个元素，称为是一个 “栈帧”<br> 这一个栈帧里，会包含这个方法的入口地址，方法的参数是啥，返回地址是啥，局部变量…</li></ul> 
 <p><strong>对于本地方法栈，存储的是 native 方法之间的调用关系</strong></p> 
</blockquote> 
<p><strong>Java 虚拟机栈的作用：</strong> Java 虚拟机栈的生命周期和线程相同，Java 虚拟机栈描述的是 Java 方法执行的</p> 
<p><strong>内存模型：</strong> 每个<strong>方法</strong>在执行的同时都会创建一个<strong>栈帧</strong>（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。我们常说的堆内存、栈内存中，栈内存指的就是虚拟机栈。</p> 
<blockquote> 
 <p><strong>栈帧 包含了以下 4 部分：</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/6f/c7/eQSSLQ0v_o.png" alt="在这里插入图片描述"></p> 
<ol><li> <p><strong>局部变量表：</strong> 存放了编译器可知的各种基本数据类型(8大基本数据类型)、对象引用。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在执行期间不会改变局部变量表大小。简单来说就是存放方法参数和局部变量。</p> </li><li> <p><strong>操作栈：</strong> 每个方法会生成一个先进后出的操作栈。</p> </li><li> <p><strong>动态链接：</strong> 指向运行时常量池的方法引用。</p> </li><li> <p><strong>方法返回地址：</strong> PC 寄存器的地址。</p> </li></ol> 
<hr> 
<h6><a id="_258"></a>什么是线程私有？</h6> 
<p>由于 JVM 的多线程是通过<strong>线程轮流切换并分配处理器执行时间</strong>的方式来实现，因此在<strong>任何一个确定的时刻，一个处理器 (多核处理器则指的是一个内核) 都只会执行一条线程中的指令</strong>。因此为了切换线程后能恢复到正确的执行位置，<strong>每条线程都需要独立的程序计数器</strong>，各条线程之间计数器<strong>互不影响，独立存储</strong>。我们就把类似这类区域称之为 “线程私有” 的内存。</p> 
<p><img src="https://images2.imgbox.com/99/a3/lFPNZLcY_o.png" alt="在这里插入图片描述"></p> 
<p><strong>这里的这个栈，其实不是只有一个，有很多个!! 每个线程有一个，</strong><br> jconsole 查看 java 进程内部的情况，就可以看到所有的线程<br> 点击线程就能看到该线程的调用栈的情况（查看了该线程的栈里的信息）</p> 
<p><img src="https://images2.imgbox.com/e1/ba/JDfeblLQ_o.png" alt="在这里插入图片描述"></p> 
<p>栈是线程私有的 [非常常见]，但是严格的说并不准确<br> 私有，意思是我的你用不了。<br> 实际上，一个线程栈上的内容，可以被另一个线程使用到的</p> 
<hr> 
<h4><a id="__280"></a>③ 程序计数器（线程私有）</h4> 
<blockquote> 
 <p><strong>程序计数器的作用：</strong> 用来记录当前线程执行的行号的。</p> 
</blockquote> 
<p>**程序计数器是一块比较小的内存空间，和 Java 虚拟机栈一样是每个线程都有一份的，**可以看做是当前线程所执行的字节码的行号指示器。</p> 
<p>如果当前线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；<br> 如果正在执行的是一个Native方法，这个计数器值为空。</p> 
<p><mark>程序计数器内存区域是唯一一个在 JVM 规范中没有规定任何 OOM 情况的区域！</mark></p> 
<hr> 
<h4><a id="__295"></a>④ 堆（线程共享）</h4> 
<blockquote> 
 <p><strong>堆的作用：</strong> 程序中创建的所有<strong>对象</strong>都在保存在堆中，<strong>类的成员变量</strong>也就是在堆上</p> 
</blockquote> 
<p>堆 是整个JVM空间最大的区域，<strong>堆是一个进程只有一份的!!</strong><br> 栈 是每个线程有一份，一个进程有 N 个!!<br> <mark>堆——多个线程用的都是同一个堆。栈——每个线程用自己的栈</mark></p> 
<p>我们常见的 JVM 参数设置 -Xms10m 最小启动内存是针对堆的，-Xmx10m 最大运行内存也是针对堆的。<br> <strong>ms 是 memory start 简称，mx 是 memory max 的简称</strong></p> 
<p>堆里面分为两个区域：新生代和老生代，新生代放新建的对象，当经过一定 GC 次数之后还存活的对象会放入老生代。新生代还有 3 个区域：一个 Endn + 两个 Survivor（S0/S1）</p> 
<p><img src="https://images2.imgbox.com/c7/3d/hYB3QROn_o.png" alt="在这里插入图片描述"></p> 
<p>垃圾回收的时候会将 Endn 中存活的对象放到一个未使用的 Survivor 中，并把当前的 Endn 和正在使用<br> 的 Survivor 清除掉</p> 
<hr> 
<h4><a id="__319"></a>⑤ 方法区/元数据区（线程共享）</h4> 
<p><img src="https://images2.imgbox.com/56/7c/d5NfTbI9_o.png" alt="在这里插入图片描述"></p> 
<p>元 Mate ，保存<strong>类对象，常量池，静态对象</strong></p> 
<p><strong>一个进程有一块，多个线程共用</strong></p> 
<blockquote> 
 <p><strong>方法区的作用：</strong> 用来存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据的。</p> 
</blockquote> 
<p>改名：在《Java虚拟机规范中》把此区域称之为 “方法区”，而在 HotSpot 虚拟机的实现中，在 JDK 7 时此区域叫做永久代（PermGen），从 java 8 开始叫做元空间（Metaspace）。</p> 
<p>PS：永久代（PermGen）和元空间（Metaspace）是 HotSpot 中对《Java虚拟机规范》中方法区的实现，它们三者之间的关系就好比，对于一辆汽车来说它定义了一个部分叫做 “动能提供装置”，但对于不同的汽车有不同的实现技术，比如对于燃油车来说，它的“动能提供装置”的实现技术就是汽油发动机（简称发动机），而对于电动汽车来说，它的“动能提供装置”的实现就是电动发动机（简称电机），发动机和电机就相当于永久代和元空间一样，它是对于 “制动器” 也就是方法区定义的实现。</p> 
<blockquote> 
 <p><strong>JDK 1.8 元空间的变化：</strong></p> 
 <ol><li>对于 HotSpot 来说，JDK 8 元空间的内存属于本地内存，这样元空间的大小就不在受 JVM 最大内存的参数影响了，而是与本地内存的大小有关。</li><li>JDK 8 中将字符串常量池移动到了堆中。</li></ol> 
</blockquote> 
<blockquote> 
 <p><strong>运行时常量池：</strong></p> 
 <ul><li> <p>运行时常量池是方法区的一部分，存放字面量与符号引用。</p> 
   <ul><li> <p><strong>字面量：</strong> 字符串(JDK 8 移动到堆中) 、final 常量、基本数据类型的值。</p> </li><li> <p><strong>符号引用：</strong> 类和结构的完全限定名、字段的名称和描述符、方法的名称和描述符。</p> </li></ul> </li></ul> 
</blockquote> 
<hr> 
<h3><a id="3_352"></a>3、总结</h3> 
<p><img src="https://images2.imgbox.com/44/12/rL72TG91_o.png" alt="在这里插入图片描述"></p> 
<p>最主要的考点，给一段代码，问某个变量是在哪个区域上?? 原则：</p> 
<ol><li>局部变量在栈</li><li>普通成员变量在堆</li><li>静态成员变量在方法区 / 元数据区</li></ol> 
<hr> 
<h3><a id="4_368"></a>4、内存布局中的异常问题</h3> 
<h4><a id="_Java__370"></a>① Java 堆溢出</h4> 
<p>Java 堆用于存储对象实例，只要不断的创建对象，并且保证 GC Roots 到对象之间有可达路径来避免来 GC 清除这些对象，那么在对象数量达到最大堆容量后就会产生内存溢出异常。<br> <strong>可以设置 JVM 参数 -Xms: 设置堆的最小值、-Xmx: 设置堆最大值。</strong></p> 
<p>Java 堆内存的 OOM 异常是实际应用中最常见的内存溢出情况。当出现 Java 堆内存溢出时，异常堆信息 “java.lang.OutOfMemoryError” 会进一步提示 “Java heap space”。当出现 “Java heap space” 则很明确的告知我们，OOM发生在堆上。</p> 
<p>此时要对 Dump 出来的文件进行分析，以 MAT 为例。分析问题的产生到底是出现了内存泄漏 (Memory Leak) 还是内存溢出 (Memory Overflow)</p> 
<p><strong>内存泄漏：</strong> 泄漏对象无法被 GC<br> <strong>内存溢出：</strong> 内存对象确实还应该存活。此时要根据 JVM 堆参数与物理内存相比较检查是否还应该把 JVM堆内存调大；或者检查对象的生命周期是否过长。</p> 
<hr> 
<h4><a id="__386"></a>② 虚拟机栈和本地方法栈溢出</h4> 
<p>由于我们HotSpot虚拟机将虚拟机栈与本地方法栈合二为一，因此对于HotSpot来说，栈容量只需要由-Xss参数来设置。</p> 
<p>关于虚拟机栈会产生的两种异常:</p> 
<ul><li> <p>如果线程请求的栈深度大于虚拟机所允许的最大深度，会抛出StackOverFlow异常</p> </li><li> <p>如果虚拟机在拓展栈时无法申请到足够的内存空间，则会抛出OOM异常</p> </li></ul> 
<p>范例:观察StackOverFlow异常(单线程环境下) 、</p> 
<pre><code class="prism language-java"><span class="token comment">/**
* JVM参数为:-Xss128k
* @author 38134
*
*/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> stackLength <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		stackLength<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
			test<span class="token punctuation">.</span><span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Stack Length: "</span><span class="token operator">+</span>test<span class="token punctuation">.</span>stackLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">throw</span> e<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>出现StackOverflowError异常时有错误堆栈可以阅读，比较好找到问题所在。如果使用虚拟机默认参数，栈深度在多多数情况下达到1000-2000完全没问题，对于正常的方法调用（包括递归），完全够用。<br> 如果是因为多线程导致的内存溢出问题，在不能减少线程数的情况下，只能减少最大堆和减少栈容量的方式来换取更多线程。<br> 范例：观察多线程下的内存溢出异常</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * JVM参数为:-Xss2M
 * @author 38134
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dontStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stackLeakByThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token function">dontStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        test<span class="token punctuation">.</span><span class="token function">stackLeakByThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码运行需谨慎。先记得保存手头所有工作</p> 
<hr> 
<h2><a id="JVM__462"></a>三、JVM 类加载</h2> 
<h3><a id="1_464"></a>1、类加载过程</h3> 
<p>从上面的图片我们可以看出整个 JVM 执行的流程中，和程序员关系最密切的就是类加载的过程了，所以接下来我们来看下类加载的执行流程。<br> 对于一个类来说，它的生命周期是这样的：</p> 
<p><img src="https://images2.imgbox.com/fa/2f/wPFsvZAr_o.png" alt="在这里插入图片描述"></p> 
<p>其中前 5 步是固定的顺序并且也是类加载的过程，其中中间的 3 步我们都属于连接，所以对于类加载来<br> 说总共分为以下几个步骤：</p> 
<ol><li> <p>加载</p> </li><li> <p>连接</p> 
  <ol><li>验证</li><li>准备</li><li>解析</li></ol> </li><li> <p>初始化</p> </li></ol> 
<hr> 
<h4><a id="__487"></a>① 加载</h4> 
<p><mark>加载：把 .class文件找到 (找的过程)，打开文件，读文件，把文件内容读到内存中</mark></p> 
<p>“加载”（Loading）阶段是整个 “类加载”（Class Loading）过程中的一个阶段，它和类加载 Class Loading 是不同的，一个是加载 Loading，另一个是类加载 Class Loading，所以不要把二者搞混了。</p> 
<p>在加载 Loading 阶段，Java虚拟机需要完成以下三件事情：</p> 
<ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ul> 
<hr> 
<h4><a id="__503"></a>② 验证</h4> 
<p>验证是连接阶段的第一步，<mark>检查 .class 文件格式是否正确</mark>，这一阶段的目的是确保 class 文件的字节流中包含的信息符合官方提供的《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p> 
<p><strong>最终加载完成是要得到类对象</strong></p> 
<p><a href="https://docs.oracle.com/javase/specs/index.html" rel="nofollow">Java Language and Virtual Machine Specifications</a></p> 
<p><img src="https://images2.imgbox.com/13/5a/jwom3nYg_o.png" alt="在这里插入图片描述"></p> 
<p>java 代码中写的类的所有信息都会包含在这里，只不过是使用二进制的方式重新组织了</p> 
<p><img src="https://images2.imgbox.com/e5/91/eDfmgoRA_o.png" alt="在这里插入图片描述"></p> 
<p>验证选项：<br> 文件格式验证，字节码验证，符号引用验证…</p> 
<hr> 
<h4><a id="__526"></a>③ 准备</h4> 
<p>准备阶段是正式<mark>给类对象中定义的变量（即静态变量，被 static 修饰的变量）分配内存</mark> (先在元数据区占个位置)，<mark>并设置类变量初始值的阶段，内存初始化为全0 (会使静态成员被设置成 0 值)。</mark></p> 
<p>比如此时有这样一行代码：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
</code></pre> 
<p>它是初始化 value 的 int 值为 0，而非 123。</p> 
<hr> 
<h4><a id="__542"></a>④ 解析</h4> 
<p>解析阶段是 Java 虚拟机<mark>初始化字符串常量， 将常量池内的 符号引用 替换为 直接引用 的过程</mark></p> 
<p><strong>如何理解 符号引用 替换为 直接引用：</strong></p> 
<ul><li>字符串常量，得有一块内存空间，存这个字符的实际内容，还得有一个引用，来保存这个内存空间的起始地址</li><li><strong>在类加载之前，字符串常量 此时是处在 .class 文件中的</strong>。此时这个 “引用” 记录的<strong>并非是字符串常量的真正的地址</strong>，而是它在文件中的 “偏移量” 这个东西 (或者是个占位符) <font color="red">——符号引用</font></li><li><strong>类加载之后，才真正把这个字符串常量给放到内存中</strong>，此时才有 "内存地址”，这个引用才能被真正赋值成指定<strong>内存地址</strong> <font color="red">——直接引用</font></li></ul> 
<blockquote> 
 <p>例：组织去电影院看电影，我知道前面是 A，后面是 B，只知道自己的相对位置，不知道具体的位置 =&gt; 符号引用</p> 
 <p>等到了电影院，组织坐下了以后，才知道自己的真实为孩子 =&gt; 符号引用</p> 
</blockquote> 
<hr> 
<h4><a id="__562"></a>⑤ 初始化</h4> 
<p><mark>调用构造方法，进行成员初始化，执行代码块，执行静态代码块，加载父类…</mark></p> 
<p><strong>真正针对类对象里的内容进行初始化</strong>，Java 虚拟机真正开始执行类中编写的 Java 程序代码，将主导权移交给应用程序。初始化阶段就是执行类构造器方法的过程</p> 
<hr> 
<h3><a id="2_572"></a>2、类加载的时机</h3> 
<p>一个类，啥时候会被加载呢？<br> 不是 java 程序一运行，就把所有的类都加载了，而是真正用到才加载 (懒汉模式)</p> 
<ol><li> <p>构造类的<strong>实例</strong></p> </li><li> <p>调用这个类的<strong>静态方法</strong> / 使用静态属性，因为需要先有类对象</p> </li><li> <p>加载<strong>子类</strong>，就要先加载其父类</p> </li></ol> 
<p><strong>用到了，才加载。一旦加载过之后，后续的话再使用就不必重复加载了</strong></p> 
<hr> 
<h3><a id="3_588"></a>3、、双亲委派模型</h3> 
<p><mark>类加载器（Class Loader）：负责将 JVM 中的字节码转化为能够被 JVM 执行的类</mark>，在 JVM 运行时，会根据需要动态创建类，启动类加载器会首先加载程序中的核心类库，然后通过双亲委派模型逐层向下加载依赖类。类加载器可以分为三种：启动类加载器、扩展类加载器和应用程序类加载器。</p> 
<p><img src="https://images2.imgbox.com/bd/ec/Fun5p5dj_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="31_596"></a>3.1、类加载器类型</h4> 
<blockquote> 
 <p>站在 Java 虚拟机的角度来看，只存在两种不同的类加载器：一种是<strong>启动类加载器</strong>（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现，是<strong>虚拟机自身的一部分</strong>；另外一种就是<strong>其他所有的类加载器</strong>，这些类加载器都由 Java 语言实现，<strong>独立存在于虚拟机外部</strong>，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。</p> 
 <p>站在 Java 开发人员的角度来看，类加载器就应当划分得更细致一 些。自 JDK 1.2 以来，Java 一直保持着<strong>三层类加载器</strong>、双亲委派的类加载架构器。</p> 
</blockquote> 
<p><strong>JVM 默认提供的三个类加载器：</strong></p> 
<ul><li><em>BootstrapClassLoader</em> 启动类加载器：负责加载<strong>标准库中的类</strong> (java 规范，要求提供哪些类，无论是哪种 JVM 的实现，都会提供这些一样的类，加载 JDK 中 lib 目录中 Java 的核心类库，即 $JAVA_HOME/lib 目录。<br> ↑</li><li><em>ExtensionClassLoader</em> 扩展类加载器：负责加载 <strong>JVM 扩展库中的类</strong> (规范之外，由实现 JVM 的厂商 / 组织，提供的额外的功能)，加载 lib/ext 目录下的类。<br> ↑</li><li><em>ApplicationClassLoader</em> 应用程序类加载器：负责加载<strong>用户提供的第三方库 / 用户项目代码 中的类</strong></li></ul> 
<p>上述三个类，存在 “父子关系”<br> (不是父类子类，相当于每个 class loader 有一个 parent 属性指向自己的父 <strong>类加载器</strong>)</p> 
<p>再另一方面，类加载器，其实是可以用户自定义的，上述三个类加载器是 jvm 自带的<br> 用户自定义的类加载器，也可以加入到上述流程中，就可以和现有的加载配合使用了<br> <em>User Defined ClassLoader</em> 自定义类加载器：根据自己的需求定制类加载器。</p> 
<p><img src="https://images2.imgbox.com/67/39/PrUecevH_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="3_2_629"></a>3. 2、双亲委派模型</h4> 
<blockquote> 
 <p>"双亲” 委派模型，其实是翻译的很尴尬 (机翻)<br> 叫做 “单亲委派模型” 更合适，或者叫做 “父亲委派模型”<br> parent 双亲之一</p> 
</blockquote> 
<p><mark>加载：把 .class文件找到 (找的过程)，打开文件，读文件，把文件内容读到内存中</mark></p> 
<p><strong>双亲委派模型描述的就是找 .class 文件的基本过程</strong><br> 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是<strong>把这个请求委派给父类加载器去完</strong>成，每一个层次的类加载器都是如此，因此所有的加载请求最 终都应该传送到<strong>最顶层的启动类加载器</strong>中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p> 
<blockquote> 
 <p><strong>上述类加载器如何配合工作：</strong></p> 
 <ul><li> <p>首先加载一个类的时候，是先从 ApplicationClassLoader 开始</p> </li><li> <p>但是 ApplicationClassLoader 会把加载任务，交给父亲，让父亲去进行</p> </li><li> <p>于是 ExtensionClassLoader 要去加载了… 但是也不是真加载，而是再委托给自己的父亲</p> </li><li> <p>BootstrapClassLoader 要去加载了，也是想委托给自己的父亲，结果发现自己的父亲是 null。<br> <strong>没有父亲 / 父亲加载完了，没找着类，才由自己进行加载</strong><br> 此时 BootstrapClassLoader 就会<strong>搜索自己负责的标准库目录的相关的类</strong>，如果找到，就加载，如果没找到，就继续由子类加载器进行加载</p> </li><li> <p>ExtensionClassLoader <strong>真正搜索扩展库相关的目录</strong>，如果找到就加载，如果没找到，就由子类加载器进行加载</p> </li><li> <p>ApplicationClassLoader <strong>真正搜索用户项目相关的目录</strong>，如果找到就加载，没找到，由子类加载器进行加载 (由于当前没有子 了，就只能抛出 <em>ClassNotFoundException</em>) 这样的异常)</p> </li></ul> 
</blockquote> 
<hr> 
<h4><a id="3_2_658"></a>3. 2、双亲委派模型的优点</h4> 
<p><strong>为什么要有上述顺序？</strong><br> 上述这套顺序其实是出自于 jvm 实现代码的逻辑，这段代码大概是类似于 “递归" 的方式写的</p> 
<p>其实从最上面这里直接开始，也不是不行<br> 但是 JVM 代码当前是按照这种类似于递归的方式来实现的，就导致了从下到上，又从上到下过程</p> 
<p>这个顺序，最主要的目的，就是<strong>为了保证 Bootstrap 能够先加载，Application 能够后加载</strong>，这就可以避免说因为用户创建了一些奇怪的类，引起不必要的 bug</p> 
<p><strong>优点：</strong></p> 
<ol><li> <p><strong>避免重复加载类：</strong> 比如 A 类和 B 类都有一个父类 C 类，那么当 A 启动时就会将 C 类加载起来，那么在 B 类进行加载时就不需要在重复加载 C 类了。</p> </li><li> <p><strong>安全性：</strong> 使用双亲委派模型也可以保证了 Java 的核心 API 不被篡改，如果没有使用双亲委派模型，而是每个类加载器加载自己的话，就会出现一些问题，</p> <p>假设用户在自己的代码中，写了个 java.lang.String 这个类，<br> 按照上述加载流程，此时 JVM 加载的还是标准库的类，不会加载到用户自己写的这个类<br> 这样就能保证，即使出现上述问题，也不会让 JVM 已有代码混乱，最多是用户自己写的类不生效罢了</p> </li></ol> 
<hr> 
<h4><a id="4_684"></a>4、破坏双亲委派模型</h4> 
<p><strong>自己写的类加载器，可以去遵守，也可以不遵。是否遵守，主要是看需求</strong><br> <strong>如 Tomcat，去加载 webapp，这里就是单独的类加载器，不遵守双亲委派模型，而是从指定目录加载</strong></p> 
<p>双亲委派模型虽然有其优点，但在某些情况下也存在一定的问题，比如 Java 中 SPI（Service ProviderInterface，服务提供接口）机制中的 JDBC 实现。</p> 
<p>小知识：SPI 全称 Service Provider Interface，是 Java 提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件。 SPI 的作用就是为这些被扩展的 API 寻找服务实现。</p> 
<p>JDBC 的 Driver 接口定义在 JDK 中，其实现由各个数据库的服务商来提供，比如 MySQL 驱动包。我们<br> 先来看下 JDBC 的核心使用代码：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JdbcTest</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            connection <span class="token operator">=</span>
                    <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://127.0.0.1:3306/test"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span>
                            <span class="token string">"awakeyo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>connection<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Connection</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>然后我们进入 DriverManager 的源码类就会发现它是存在系统的 rt.jar 中的，如下图所示：</p> 
<p><img src="https://images2.imgbox.com/31/84/SRF4WSSS_o.png" alt="在这里插入图片描述"></p> 
<p>由双亲委派模型的加载流程可知 rt.jar 是有顶级父类 Bootstrap ClassLoader 加载的，如下图所示：</p> 
<p><img src="https://images2.imgbox.com/7c/66/Lq6oBUue_o.png" alt="在这里插入图片描述"></p> 
<p>而当我们进入它的 getConnection 源码是却发现，它在调用具体的类实现时，使用的是子类加载器（线<br> 程上下文加载器 Thread.currentThread().getContextClassLoader ）来加载具体的数据库数据库包<br> （如 mysql 的 jar 包），源码如下：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@CallerSensitive</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Connection</span> <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> 
                                       <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Properties</span> info<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> info<span class="token punctuation">,</span> <span class="token class-name">Reflection</span><span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Connection</span> <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Properties</span> info<span class="token punctuation">,</span> 
                                        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> caller<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">ClassLoader</span> callerCL <span class="token operator">=</span> caller <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> caller<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// synchronize loading of the correct classloader.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>callerCL <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//获取线程上下为类加载器</span>
            callerCL <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>url <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SQLException</span><span class="token punctuation">(</span><span class="token string">"The url cannot be null"</span><span class="token punctuation">,</span> <span class="token string">"08001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"DriverManager.getConnection(\""</span> <span class="token operator">+</span> url <span class="token operator">+</span> <span class="token string">"\")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">SQLException</span> reason <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">DriverInfo</span> aDriver <span class="token operator">:</span> registeredDrivers<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// isDriverAllowed 对于 mysql 连接 jar 进行加载</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isDriverAllowed</span><span class="token punctuation">(</span>aDriver<span class="token punctuation">.</span>driver<span class="token punctuation">,</span> callerCL<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" trying "</span> <span class="token operator">+</span> aDriver<span class="token punctuation">.</span>driver<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Connection</span> con <span class="token operator">=</span> aDriver<span class="token punctuation">.</span>driver<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>con <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// Success!</span>
                    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getConnection returning "</span> <span class="token operator">+</span> aDriver<span class="token punctuation">.</span>driver<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> <span class="token punctuation">(</span>con<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>reason <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    reason <span class="token operator">=</span> ex<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" skipping: "</span> <span class="token operator">+</span> aDriver<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>reason <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getConnection failed: "</span> <span class="token operator">+</span> reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> reason<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getConnection: no suitable driver found for "</span><span class="token operator">+</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SQLException</span><span class="token punctuation">(</span><span class="token string">"No suitable driver found for "</span><span class="token operator">+</span> url<span class="token punctuation">,</span> <span class="token string">"08001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样一来就破坏了双亲委派模型，因为 DriverManager 位于 rt.jar 包，由 BootStrap 类加载器加载，而其 Driver 接口的实现类是位于服务商提供的 Jar 包中，是由子类加载器（线程上下文加载器Thread.currentThread().getContextClassLoader ）来加载的，这样就破坏了双亲委派模型了（双亲委派模型讲的是所有类都应该交给父类来加载，但 JDBC 显然并不能这样实现）。它的交互流程图如下所示：</p> 
<p><img src="https://images2.imgbox.com/be/c3/KOFEallf_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="_786"></a>四、垃圾回收</h2> 
<h3><a id="1GC_Garbage_Collection_788"></a>1、GC (Garbage Collection)</h3> 
<p>垃圾，指的就是<strong>不再使用的内存</strong><br> <strong>垃圾回收，就是把不用的内存帮我们自动释放了</strong></p> 
<p>C 语言中有 malloc，C++ 有 new，这些都是动态内存申请 (在堆上申请一块内存空间)<br> 上述内存空间需要<strong>手动方式进行释放</strong> free, delete</p> 
<p>C / C++ 的情况<br> <strong>如果不手动释放，这块内存的空间就会持续存在，一直存在到进程结束</strong> (堆上的内存生命周期比较长，不像栈，栈的空间会随着方法执行结束，栈帧销毁而自动释放。<strong>堆，则默认不能自动释放</strong>)</p> 
<p>可能导致一个严重的问题：<strong>内存泄露</strong><br> 如果内存一直占着不用，又不释放，就会导致剩余空间越来越少… 进一步导致后续的内存申请操作失败 !!<br> 尤其是服务器，特别害怕这个，因为是 7 * 24 h 运行的。如果是客户端程序，如打开 QQ，使用完就关了，进程退出，所有内存全部释放</p> 
<p>GC 是解决内存泄漏其中最最主流的一种方式<br> Java Go Python PHP JS 大部分的主流语言都是使用 GC 来解决上述问题的</p> 
<blockquote> 
 <p>C++ 为什么没有 GC？因为 GC 有好处，也有坏处</p> 
 <ul><li>GC好处：非常省心，让程序猿写代码简单点，不容易出错<br> GC坏处：需要消耗额外的系统资源，也有额外的性能开销<br> 这就不符合 C++ 的初心的，追究性能到极致</li><li>另外 GC 这里还有一个比较关键的问题，STW 问题，stop the world<br> 如果有时候，内存中的垃圾已经很多了，此时触发一次 GC 操作，开销可能非常大，大到可能就把系统资源吃了很多<br> 另一方面 GC 回收垃圾的时候可能会涉及到一些锁操作，导致业务代码无法正常执行这样的卡顿，极端情况下，可能是出现几十毫秒甚至上百毫秒</li></ul> 
 <p>新版 Java (Java 13 开始) 引入 zgc 这个垃圾回收器，已经是设计的非常精致，可以使 STW 能控制在 1ms 以下了</p> 
</blockquote> 
<hr> 
<p>JVM 有很多区域：堆，栈，程序计数器，元数据区…</p> 
<p>栈上的空间是一块一块的栈帧，随方法的调用申请，方法结束，自动销毁。程序计数器，每个线程都有一份的，线程结束时，内存就自然跟着线程回收了。元数据区放的是类对象，一般只考虑类的加载，不会涉及到类的卸载。</p> 
<p>因此 GC 主要针对 <strong>堆</strong> 进行释放</p> 
<p><mark>GC 是以 “对象" 为基本单位，进行回收的 (而不是字节)</mark></p> 
<p><img src="https://images2.imgbox.com/17/c0/tFIDa9Mf_o.png" alt="在这里插入图片描述"></p> 
<p>GC 回收的是，整个对象都不再使用的情况<br> 而一部分使用，一部分不使用的对象，暂且先不回收 (一个对象，里面有很多属性，可能其中 10 个属性后面要用，10 个属性后面再也不用了)<br> 要回收，就是回收整个对象，而不会 “回收半个对象”</p> 
<p><strong>GC 实际工作过程：</strong></p> 
<ol><li> <p><strong>找到垃圾/判定垃圾</strong>。Java 堆 中存放着几乎所有的对象实例，垃圾回收器在对堆进行垃圾回收前，首先要判断这些对象哪些还存活，哪些已经"死去"。</p> 
  <ul><li>找到垃圾 / 判定垃圾<br> 关键思路，<strong>抓住这个对象，看这个对象到底有没有 "引用” 指向它</strong><br> Java 中使用对象，只有这一条路，通过 引用 来使用!! 如果一个对象有引用指向它，就可能被使用到<br> 如果一个对象，没有引用指向了，就不会再被使用了</li></ul> </li><li> <p><strong>再进行对象的释放</strong></p> </li></ol> 
<hr> 
<h3><a id="2_855"></a>2、死亡对象的判断算法</h3> 
<blockquote> 
 <p><strong>内存 VS 对象</strong></p> 
 <p>在 Java 中，所有的对象都是要存在内存中的（也可以说内存中存储的是一个个对象），因此我们将内存回收，也可以叫做死亡对象的回收。</p> 
</blockquote> 
<p><strong>如何知道 对象 是否有 引用 指向</strong>，两种典型实现：</p> 
<ol><li><strong>引用计数算法</strong> [<strong>不是 java 的做法</strong>. python / php]</li><li><strong>可达性分析</strong> [ java 的做法]</li></ol> 
<p>注意面试审题！<br> 问题是：谈谈垃圾回收中的如何判定对象是垃圾，此时可以两个都说<br> 问题是：谈谈 java 的垃圾回收中如何判定对象是垃圾，这个时候你再说引用计数就不合适了!</p> 
<hr> 
<h4><a id="21_874"></a>2.1、引用计数算法</h4> 
<p>引用计数描述的算法为：<br> <mark>给<strong>每个对象</strong>分配一个引用计数器 (整数)，每当创建一个引用指向该对象，计数器就 +1；当引用被销毁时，计数器就 -1；任何时刻计数器为0的对象就是不能再被使用的，即对象已"死"。</mark></p> 
<pre><code class="prism language-java"><span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Test</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Test 对象的引用计数 1</span>
	<span class="token class-name">Test</span> t2 <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment">// t2 也指向 t 了,引用计数为 2</span>
	<span class="token class-name">Test</span> t3 <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment">// 引用计数为 3</span>
<span class="token punctuation">}</span> <span class="token comment">// 大括号结束，上述三个引用超出作用域，失效，此时引用计数就是 0 了，此时 new Test() 对象就是垃圾了</span>
</code></pre> 
<p>引用计数法<strong>实现简单，判定效率也比较高</strong>，在大部分情况下都是一个不错的算法。比如Python语言就采用引用计数法进行内存管理。</p> 
<p>但是，在主流的 JVM 中没有选用引用计数法来管理内存，原因：</p> 
<ol><li><strong>内存空间浪费的多 (利用率低 )</strong> 
  <ul><li>每个对象都要分配一个计数器，如果按 4 个字节算的<br> 代码中的对象非常少，无所谓，如果对象特别多了，占用的额外空间就会很多，尤其是每个对象都比较小的情况<br> 一个对象体积 1k，此时，多 4 个自己，无所谓<br> 一个对象体积是 4 字节，此时多 4 个字节，相当于体积扩大一倍</li></ul> </li><li><strong>无法解决对象的循环引用问题</strong> (最主要的原因)</li></ol> 
<p>范例：</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Test</span> t <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">Test</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 号对象, 引用计数是 1</span>
<span class="token class-name">Test</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 号对象, 引用计数也是 1</span>

a<span class="token punctuation">.</span>t <span class="token operator">=</span> b <span class="token comment">// a.t也指向2号对象,2号对象引用计数是2了</span>
b<span class="token punctuation">.</span>t <span class="token operator">=</span> a <span class="token comment">// b.t也指向1号对象了,1号对象引用计数也是2了.</span>
</code></pre> 
<p>接下来，如果 a 和 b 引用销毁，此时 1号对象和 2号对象引用计数都 -1，但是结果都还是 1，不是 0，但是虽然不是 0，不能释放内存，但是实际上这俩对象已经没有办法被访问到了!!!</p> 
<p>Python / PHP 使用引用计数，需要搭配其他的机制，来避免循环引用</p> 
<hr> 
<h4><a id="22_922"></a>2.2、可达性分析算法</h4> 
<p>Java 中的对象，都是通过引用来指向并访问的<br> 经常是一个引用指向一个对象，这个对象里的成员，又指向别的对象</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Node</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        b<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        c<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
        d<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
        e<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
        f<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
        g<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
        a<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
        a<span class="token punctuation">.</span>left <span class="token operator">=</span> b<span class="token punctuation">;</span>
        a<span class="token punctuation">.</span>right <span class="token operator">=</span> c<span class="token punctuation">;</span>
        b<span class="token punctuation">.</span>left <span class="token operator">=</span> d<span class="token punctuation">;</span>
        b<span class="token punctuation">.</span>right <span class="token operator">=</span> e<span class="token punctuation">;</span>
        e<span class="token punctuation">.</span>left <span class="token operator">=</span> g<span class="token punctuation">;</span>
        c<span class="token punctuation">.</span>right <span class="token operator">=</span> f<span class="token punctuation">;</span>
        <span class="token keyword">return</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Node</span> root <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 此时这个 root 就相当于树根节点了</span>
        <span class="token comment">// 当前代码中只有一个引用 root，但是它管理了 N 个对象</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/5f/96/xhAnSDmC_o.png" alt="在这里插入图片描述"></p> 
 <p>虽然此处只有 root 引用，但是上述 7 个对象都是可达的!!!<br> root =&gt; a</p> 
 <p>root.left =&gt; b</p> 
 <p>root.left.left =&gt; d</p> 
 <p>root.left.right =&gt; e</p> 
 <p>root.left.right.left =&gt;g</p> 
 <p>此处可达性分析就是从 roo t出发，尽可能进行遍历，所有能够被访问到的对象就都是可达的!!</p> 
 <pre><code class="prism language-java">root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> 
 <p>会导致 f 不可达，f 就是垃圾了</p> 
 <pre><code class="prism language-java">root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> 
 <p>会导致c不可达~<br> 如果c不可达, f一定不可达</p> 
</blockquote> 
<p>整个 Java 中所有的对象，就通过类似于上述的关系，通过这种 <strong>链式 / 树形</strong>结构，整体给串起来</p> 
<p><mark>可达性分析，就是把所有这些对象被组织的结构视为是树，<strong>从数根节点除法，也就是通过一系列称为"GC Roots"的对象作为起始点，遍历树，走过的路径称之为"引用链"，所有能被访问到的对象，标记成 “可达”，当一个对象到GC Roots没有任何的引用链相连时 (不能被访问到的，就是不可达)</strong></mark> (同样采用此法的还有C#、Lisp-最早的一门采用动态内存分配的语言)</p> 
<p>JVM 自己捏着一个所有对象的名单 (每次 new 的一个对象，JVM 都会记录下来，JVM 会知道一共有哪些对象，每个对象的地址)，通过上述遍历，把可达的标记出来了，剩下的不可达的就可以作为垃圾进行回收了</p> 
<p>可达性分析需要进行类似于 “树遍历”，这个操作相比于引用计数来说肯定要更慢一些的</p> 
<p>但是速度慢没关系，上述可达性分析遍历操作，并不需要一直执行，只需要每隔一段时间，分析一遍就可以了</p> 
<p><img src="https://images2.imgbox.com/8d/cc/MI41cGhb_o.png" alt="在这里插入图片描述"></p> 
<p>对象Object5-Object7之间虽然彼此还有关联，但是它们到GC Roots是不可达的，因此他们会被判定为可回收对象。</p> 
<p><strong>在 Java 语言中，可作为 GC Roots 的对象包含下面几种：</strong></p> 
<ol><li><strong>栈上的局部变量</strong></li><li><strong>常量池中的对象</strong></li><li><strong>静态成员变量</strong></li></ol> 
<p>一个代码中有很多这样的起点，把每个起点都往下遍历一遍，就完成了一次扫描过程</p> 
<p><img src="https://images2.imgbox.com/8d/15/q05bniIN_o.png" alt="在这里插入图片描述"></p> 
<p>从上面我们可以看出“引用”的功能，除了最早我们使用它（引用）来查找对象，现在我们还可以使用“引用”来判断死亡对象了。所以在 JDK1.2 时，Java 对引用的概念做了扩充，将引用分为强引用(StrongReference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)四种，这四种引用的强度依次递减。</p> 
<blockquote> 
 <ol><li> <p>强引用：强引用指的是在程序代码之中普遍存在的，类似于"Object obj = new Object()"这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象实例。</p> </li><li> <p>软引用：软引用是用来描述一些还有用但是不是必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出之前，会把这些对象列入回收范围之中进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在 JDK1.2 之后，提供SoftReference 类来实现软引用。</p> </li><li> <p>弱引用：弱引用也是用来描述非必需对象的。但是它的强度要弱于软引用。被弱引用关联的对象只能生存到下一次垃圾回收发生之前。当垃圾回收器开始进行工作时，无论当前内容是否够用，都会回收掉只被弱引用关联的对象。在JDK1.2之后提供 WeakReference类来实现弱引用。</p> </li><li> <p>虚引用：虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。</p> </li></ol> 
</blockquote> 
<hr> 
<h3><a id="3_1038"></a>3、垃圾回收算法</h3> 
<p>学会将死亡对象标记出来后，就可以进行垃圾回收操作了，在正式介绍垃圾收集器之前，先看下垃圾回收机器使用的几种算法（这些算法是垃圾收集器的指导思想）</p> 
<h4><a id="31_1044"></a>3.1、标记-清除算法</h4> 
<p>“标记-清除” 算法是最基础的收集算法。算法分为 “标记” 和 “清除” 两个阶段：首先<strong>标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</strong> 。后续的收集算法都是基于这种思路并对其不足加以改进而已。</p> 
<p><img src="https://images2.imgbox.com/95/98/FWoYkHvz_o.png" alt="在这里插入图片描述"></p> 
<p>"标记-清除"算法的不足主要有两个：</p> 
<ol><li> <p>效率问题：标记和清除这两个过程的效率都不高</p> </li><li> <p>空间问题：<strong>内存碎片问题，被释放的空闲空间，是零散的，不是连续的</strong>，空间碎片太多可能会导致以后在程序运行中需要分配较大对象时，无法找到足够连续内存而不得不提前触发另一次垃圾收集。</p> </li></ol> 
<p>申请内存要求的是连续空间，总的空闲空间可能很大，但是每一个具体的空间都很小，可能导致申请大一点内存的时候就失败了!!! 例如，总的空闲空间是 10K，分成 1K 一个，一共 10 个，此时如果申请 2K 内存，就会申请失败了!!</p> 
<hr> 
<h4><a id="32_1063"></a>3.2、复制算法</h4> 
<blockquote> 
 <p>“复制” 算法是为了解决 “标记-清理” 的效率问题。</p> 
</blockquote> 
<p><strong>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，用一半，丢一半</strong>。<mark>复制算法，就是把 “不是垃圾” 的对象复制到另外一半，然后把整个空间删除掉。每次触发复制算法，都是向另外─侧进行复制，将内存的数据拷贝过去</mark></p> 
<p>这样做的好处是每次都是对整个半区进行内存回收，内存分配时也就不需要考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配即可。此算法实现简单，运行高效。</p> 
<p><strong>缺点：</strong></p> 
<ol><li> <p><strong>空间利用率低</strong></p> </li><li> <p><strong>如果要是垃圾少，有效对象多复制成本就比较大了</strong></p> </li></ol> 
<p><img src="https://images2.imgbox.com/12/a0/fmh2HIr8_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="33__1083"></a>3.3 标记-整理算法</h4> 
<blockquote> 
 <p>复制收集算法在对象存活率较高时会进行比较多的复制操作，效率会变低。因此在老年代一般不能使用复制算法。</p> 
</blockquote> 
<p>针对老年代的特点，提出了一种称之为"标记-整理算法"。标记过程仍与"标记-清除"过程一致，但后续步骤不是直接对可回收对象进行清理，而是<mark>顺序表删除中间元素，会有元素搬运的操作，让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。</mark></p> 
<p><strong>解决了复制算法的第一个缺点 空间利用率低 的问题</strong><br> <strong>但是很明显，这种做法的缺点，效率也不高，如果要搬运的空间比较大，此时开销也很大</strong></p> 
<p><img src="https://images2.imgbox.com/d8/a0/DD4etcg8_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="34_1098"></a>3.4、分代算法</h4> 
<p>基于上述这些基本策略，搞了一个复合策略 “分代回收”</p> 
<p><mark>通过区域划分，实现不同区域和不同的垃圾回收策略，从而实现更好的垃圾回收。对于不同的场景，使用不同的算法</mark>，这就时分代算法的设计思想。</p> 
<p><strong>基于一个经验规律：如果一个东西，存在的时间比较长了，那么大概率还会继续的长时间持续存在下去</strong></p> 
<p>上述规律，对于 Java 的对象也是有效的 (是有一系列的实验和论证过程…)。java 的对象要么就是生命周期特别短，要么就是特别长，根据生命周期的长短，分别使用不同的算法</p> 
<p><strong>给对象引入一个概念，年龄，单位不是年，而是熬过 GC 的轮次</strong> (经过一次可达性分析的遍历，分析这个对象不是垃圾)<br> 年龄越大，这个对象存在的时间就越久</p> 
<p><mark>当前 JVM 垃圾收集都采用的是 “分代收集(Generational Collection)” 算法，这个算法并没有新思想，只是<strong>根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆 分为新生代和老年代。</strong></mark></p> 
<blockquote> 
 <p><strong>哪些对象会进入新生代？哪些对象会进入老年代？</strong></p> 
 <ul><li>新生代：一般创建的对象都会进入新生代；</li><li>老年代：大对象和经历了 N 次（一般情况默认是 15 次）垃圾回收依然存活下来的对象会从新生代移动到老年代。</li></ul> 
</blockquote> 
<p>根据上述经验规律，大部分的 java 中的对象都是 “朝生夕死"，生命周期非常短，所以幸存区很小，伊甸区很大，一般够放。</p> 
<p>所以并不需要按照1 : 1的比例来划分内存空间，而是将内存(新生代内存)分为**一块较大的Eden(伊甸园)<strong>空间和</strong>两块较小的Survivor(幸存者)**空间，<strong>每次使用Eden和其中一块Survivor</strong>（两个Survivor区域一个称为From区，另一个称为To区域）。</p> 
<p><img src="https://images2.imgbox.com/8c/45/SASsBZau_o.png" alt="在这里插入图片描述"></p> 
<p><strong>——过程：</strong></p> 
<ul><li> <p><strong>刚 new 出来的，年龄是 0 的对象，放到伊甸区。熬过一轮 GC，对象就要被放到幸存区了</strong></p> </li><li> <p><mark><strong>在新生代中，每次垃圾回收都有大批对象死去，只有少量存活，因此我们采用复制算法；</strong></mark> 将存活的对象移到幸存区，将整个伊甸区释放</p> </li><li> <p><strong>幸存区之后，也要周期性的接受 GC 的考验</strong>，如果变成垃圾，就要被释放。如果不是垃圾，拷贝到另外一个幸存区 (这俩幸存区同一时刻只用一个)，<strong>在两个幸存区之间来回拷贝 (复制算法)</strong>，由于幸存区体积不大，此处的空间浪费也能接受。</p> <p>如果这个对象已经再两个幸存区中来回拷贝很多次了，这个时候就要进入老年代了</p> </li><li> <p><mark><strong>老年代中对象生命周期普遍更长，也要周期性 GC 扫描，但是频率更低了，采用 “标记-清理” 或者 “标记-整理” 算法。</strong></mark></p> </li></ul> 
<p>当 Survivor 空间不够用时，需要依赖其他内存(老年代)进行分配担保。</p> 
<p>HotSpot 默认 Eden 与 Survivor 的大小比例是8 : 1，也就是说 Eden:Survivor From : Survivor To = 8:1:1。所以每次新生代可用内存空间为整个新生代容量的90%,而剩下的10%用来存放回收后存活的对象。</p> 
<p>HotSpot实现的复制算法流程如下:</p> 
<ol><li> <p>当Eden区满的时候,会触发第一次Minor gc,把还活着的对象拷贝到Survivor From区；当Eden区再次触发Minor gc的时候,会扫描Eden区和From区域,对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域,并将Eden和From区域清空。</p> </li><li> <p>当后续Eden又发生Minor gc的时候,会对Eden和To区域进行垃圾回收,存活的对象复制到From区域,并将Eden和To区域清空。</p> </li><li> <p>部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代</p> </li></ol> 
<p><img src="https://images2.imgbox.com/de/b5/Sz8yxSg6_o.png" alt="在这里插入图片描述"></p> 
<p>面试题 : 请问了解Minor GC和Full GC么，这两种GC有什么不一样吗</p> 
<ol><li> <p>Minor GC又称为新生代GC : 指的是发生在新生代的垃圾收集。因为Java对象大多都具备朝生夕灭的特性，因此Minor GC(采用复制算法)非常频繁，一般回收速度也比较快。</p> </li><li> <p>Full GC 又称为 老年代GC或者Major GC : 指发生在老年代的垃圾收集。出现了Major GC，经常会伴随至少一次的Minor GC(并非绝对，在Parallel Scavenge收集器中就有直接进行Full GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。</p> </li></ol> 
<p><img src="https://images2.imgbox.com/5d/cf/rUiuEP0Y_o.png" alt="在这里插入图片描述"></p> 
<hr>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58590fb855fd6fcb41fd531fe8383ca4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows下修改Git Bash 默认路径</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/29d7ab977f317fffce954f41bf62f17f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【【51单片机的蜂鸣器实现小星星】】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>