<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java个人汇总 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java个人汇总" />
<meta property="og:description" content="1.数据类型 ①：基本数据类型：byte、short、int、long、float、double、char、boolean
②：引用数据类型: 数组、类、接口。
级别从低到高为：byte,char,short(这三个平级)——&gt;int——&gt;float——&gt;long——&gt;double
自动类型转换：从低级别到高级别，系统自动转的；
强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量；
2.内存区 java分了5片内存。
1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。
栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；
只要数据运算完成所在的区域结束，该数据就会被释放。
堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。
1：每一个实体都有内存首地址值。
2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。
3：垃圾回收机制。
3.框架集合 特点：
1：对象封装数据，对象多了也需要存储。集合用于存储对象。
2：对象的个数确定可以使用数组，但是不确定怎么办？可以用集合。因为集合是可变长度的。
集合和数组的区别：
1：数组是固定长度的；集合可变长度的。
2：数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。
3：数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。
数据结构：
就是容器中存储数据的方式。
对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。
集合容器在不断向上抽取过程中。出现了集合体系。
在使用一个体系时，原则：参阅顶层内容。建立底层对象。
——&lt; java.util &gt;—— Collection接口：
Collection：
|——List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。
|——Set：无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。
1，添加：
add(object)：添加一个元素
addAll(Collection) ：添加一个集合中的所有元素。
2，删除：
clear()：将集合中的元素全删除，清空集合。
remove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。
removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。
3，判断：
boolean contains(obj) ：集合中是否包含指定元素 。
boolean containsAll(Collection) ：集合中是否包含指定的多个元素。
boolean isEmpty()：集合中是否有元素。
4，获取：
int size()：集合中有几个元素。
5，取交集：
boolean retainAll(Collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainAll修改了当前集合，返回true。
6，获取集合中所有元素：
Iterator iterator()：迭代器" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/d53e89256ce9e0f590dd60cadd5ac251/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-11T14:22:07+08:00" />
<meta property="article:modified_time" content="2022-03-11T14:22:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java个人汇总</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1_0"></a><strong>1.数据类型</strong></h3> 
<p>①：基本数据类型：byte、short、int、long、float、double、char、boolean</p> 
<p>②：引用数据类型: 数组、类、接口。</p> 
<p>级别从低到高为：byte,char,short(这三个平级)——&gt;int——&gt;float——&gt;long——&gt;double</p> 
<p>自动类型转换：从低级别到高级别，系统自动转的；</p> 
<p>强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量；</p> 
<h3><a id="2_12"></a>2.内存区</h3> 
<p>java分了5片内存。</p> 
<p>1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。</p> 
<p>栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；</p> 
<p>只要数据运算完成所在的区域结束，该数据就会被释放。</p> 
<p>堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。</p> 
<p>1：每一个实体都有内存首地址值。</p> 
<p>2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。</p> 
<p>3：垃圾回收机制。</p> 
<h3><a id="3_30"></a>3.框架集合</h3> 
<p><strong>特点：</strong></p> 
<p>1：对象封装数据，对象多了也需要存储。集合用于存储对象。</p> 
<p>2：对象的个数确定可以使用数组，但是不确定怎么办？可以用集合。因为集合是可变长度的。</p> 
<p><strong>集合和数组的区别：</strong></p> 
<p>1：数组是固定长度的；集合可变长度的。</p> 
<p>2：数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</p> 
<p>3：数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</p> 
<p><strong>数据结构：</strong></p> 
<p>就是容器中存储数据的方式。</p> 
<p>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。</p> 
<p>集合容器在不断向上抽取过程中。出现了集合体系。</p> 
<p>在使用一个体系时，原则：参阅顶层内容。建立底层对象。<br> 　　<img src="https://images2.imgbox.com/a0/74/hXcE01Ba_o.png" alt="在这里插入图片描述"><br> <strong>——&lt; java.util &gt;—— Collection接口：<br> 　　Collection：</strong></p> 
<p><strong>|——List</strong>：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</p> 
<p><strong>|——Set</strong>：无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。</p> 
<p>1，添加：</p> 
<p>add(object)：添加一个元素</p> 
<p>addAll(Collection) ：添加一个集合中的所有元素。</p> 
<p>2，删除：</p> 
<p>clear()：将集合中的元素全删除，清空集合。</p> 
<p>remove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。</p> 
<p>removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。</p> 
<p>3，判断：</p> 
<p>boolean contains(obj) ：集合中是否包含指定元素 。</p> 
<p>boolean containsAll(Collection) ：集合中是否包含指定的多个元素。</p> 
<p>boolean isEmpty()：集合中是否有元素。</p> 
<p>4，获取：</p> 
<p>int size()：集合中有几个元素。</p> 
<p>5，取交集：</p> 
<p>boolean retainAll(Collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainAll修改了当前集合，返回true。</p> 
<p>6，获取集合中所有元素：</p> 
<p>Iterator iterator()：迭代器</p> 
<p>7，将集合变成数组：</p> 
<p>toArray();<br> 　　　　<br> <strong>——&lt; java.util &gt;—— List接口：</strong></p> 
<p>List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。</p> 
<p>List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</p> 
<p><strong>|——ArrayList</strong>：底层的数据结构是数组,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。</p> 
<p><strong>|——LinkedList</strong>：底层的数据结构是链表，线程不同步，增删元素的速度非常快。</p> 
<p><strong>|——Vector</strong>：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。</p> 
<p>1，添加：</p> 
<p>add(index,element) ：在指定的索引位插入元素。</p> 
<p>addAll(index,collection) ：在指定的索引位插入一堆元素。</p> 
<p>2，删除：</p> 
<p>remove(index) ：删除指定索引位的元素。 返回被删的元素。</p> 
<p>3，获取：</p> 
<p>Object get(index) ：通过索引获取指定元素。</p> 
<p>int indexOf(obj) ：获取指定元素第一次出现的索引位，如果该元素不存在返回—1；</p> 
<p>所以，通过—1，可以判断一个元素是否存在。</p> 
<p>int lastIndexOf(Object o) ：反向索引指定元素的位置。</p> 
<p>List subList(start,end) ：获取子列表。</p> 
<p>4，修改：</p> 
<p>Object set(index,element) ：对指定索引位进行元素的修改。</p> 
<p>5，获取所有元素：</p> 
<p>ListIterator listIterator()：list集合特有的迭代器。</p> 
<p>List集合支持对元素的增、删、改、查。</p> 
<p>List集合因为角标有了自己的获取元素的方式： 遍历。</p> 
<p>for(int x=0; x&lt;list.size(); x++){<!-- --></p> 
<p>sop(“get:”+list.get(x));</p> 
<p>}</p> 
<p>在进行list列表元素迭代的时候，如果想要在迭代过程中，想要对元素进行操作的时候，比如满足条件添加新元素。会发生.ConcurrentModificationException并发修改异常。</p> 
<p>导致的原因是：</p> 
<p>集合引用和迭代器引用在同时操作元素，通过集合获取到对应的迭代器后，在迭代中，进行集合引用的元素添加，迭代器并不知道，所以会出现异常情况。</p> 
<p>如何解决呢？</p> 
<p>既然是在迭代中对元素进行操作,找迭代器的方法最为合适.可是Iterator中只有hasNext,next,remove方法.通过查阅的它的子接口,ListIterator,发现该列表迭代器接口具备了对元素的增、删、改、查的动作。</p> 
<p>ListIterator是List集合特有的迭代器。</p> 
<p>ListIterator it = list.listIterator;//取代Iterator it = list.iterator;</p> 
<p><strong>——&lt; java.util &gt;—— Set接口：</strong></p> 
<p>Set接口中的方法和Collection中方法一致的。Set接口取出方式只有一种，迭代器。</p> 
<p><strong>|——HashSet</strong>：底层数据结构是哈希表，线程是不同步的。无序，高效；</p> 
<p>HashSet集合保证元素唯一性：通过元素的hashCode方法，和equals方法完成的。</p> 
<p>当元素的hashCode值相同时，才继续判断元素的equals是否为true。</p> 
<p>如果为true，那么视为相同元素，不存。如果为false，那么存储。</p> 
<p>如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。</p> 
<p><strong>|——LinkedHashSet</strong>：有序，hashset的子类。</p> 
<p><strong>|——TreeSet</strong>：对Set集合中的元素的进行指定顺序的排序。不同步。TreeSet底层的数据结构就是二叉树。</p> 
<p><strong>哈希表的原理：</strong></p> 
<p>1，对对象元素中的关键字(对象中的特有数据)，进行哈希算法的运算，并得出一个具体的算法值，这个值 称为哈希值。</p> 
<p>2，哈希值就是这个元素的位置。</p> 
<p>3，如果哈希值出现冲突，再次判断这个关键字对应的对象是否相同。如果对象相同，就不存储，因为元素重复。如果对象不同，就存储，在原来对象的哈希值基础 +1顺延。</p> 
<p>4，存储哈希值的结构，我们称为哈希表。</p> 
<p>5，既然哈希表是根据哈希值存储的，为了提高效率，最好保证对象的关键字是唯一的。</p> 
<p>这样可以尽量少的判断关键字对应的对象是否相同，提高了哈希表的操作效率。</p> 
<p>对于ArrayList集合，判断元素是否存在，或者删元素底层依据都是equals方法。</p> 
<p>对于HashSet集合，判断元素是否存在，或者删除元素，底层依据的是hashCode方法和equals方法。</p> 
<p><strong>TreeSet:</strong></p> 
<p>用于对Set集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。</p> 
<p>如果元素不具备比较性，在运行时会发生ClassCastException异常。</p> 
<p>所以需要元素实现Comparable接口，强制让元素具备比较性，复写compareTo方法。</p> 
<p>依据compareTo方法的返回值，确定元素在TreeSet数据结构中的位置。</p> 
<p>TreeSet方法保证元素唯一性的方式：就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。</p> 
<p>注意：在进行比较时，如果判断元素不唯一，比如，同姓名，同年龄，才视为同一个人。</p> 
<p>在判断时，需要分主要条件和次要条件，当主要条件相同时，再判断次要条件，按照次要条件排序。</p> 
<p><strong>TreeSet集合排序有两种方式，Comparable和Comparator区别：</strong></p> 
<p>1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。</p> 
<p>2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。</p> 
<p>第二种方式较为灵活。</p> 
<p><strong>Map集合：</strong></p> 
<p><strong>|——Hashtable</strong>：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。</p> 
<p><strong>|——HashMap</strong>：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable.</p> 
<p><strong>|——TreeMap</strong>：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。</p> 
<p>Map集合存储和Collection有着很大不同：</p> 
<p>Collection一次存一个元素；Map一次存一对元素。</p> 
<p>Collection是单列集合；Map是双列集合。</p> 
<p>Map中的存储的一对元素：一个是键，一个是值，键与值之间有对应(映射)关系。</p> 
<p>特点：要保证map集合中键的唯一性。</p> 
<p>1，添加。</p> 
<p>put(key,value)：当存储的键相同时，新的值会替换老的值，并将老值返回。如果键没有重复，返回null。</p> 
<p>void putAll(Map);</p> 
<p>2，删除。</p> 
<p>void clear()：清空</p> 
<p>value remove(key) ：删除指定键。</p> 
<p>3，判断。</p> 
<p>boolean isEmpty()：</p> 
<p>boolean containsKey(key)：是否包含key</p> 
<p>boolean containsValue(value) ：是否包含value</p> 
<p>4，取出。</p> 
<p>int size()：返回长度</p> 
<p>value get(key) ：通过指定键获取对应的值。如果返回null，可以判断该键不存在。当然有特殊情况，就是在hashmap集合中，是可以存储null键null值的。</p> 
<p>Collection values()：获取map集合中的所有的值。</p> 
<p>5，想要获取map中的所有元素：</p> 
<p>原理：map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。</p> 
<p>★ 把map集合转成set的方法：</p> 
<p>Set keySet();</p> 
<p>Set entrySet();//取的是键和值的映射关系。</p> 
<p>Entry就是Map接口中的内部接口；</p> 
<p>为什么要定义在map内部呢？entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。</p> 
<h3><a id="4_JUC_321"></a>4. JUC是什么？</h3> 
<p>JUC是java.util.concurrent包的简称，在Java5.0添加，目的就是为了更好的支持高并发任务。让开发者进行多线程编程时减少竞争条件和死锁的问题！<br> 我们在面试过程中也会经常问到这类问题！<br> 1.2 进程与线程的区别：</p> 
<p>进程 : 一个运行中的程序的集合; 一个进程往往可以包含多个线程,至少包含一个线程</p> 
<p>java默认有几个线程? 两个 main线程 gc线程</p> 
<p>线程 : 线程（thread）是操作系统能够进行运算调度的最小单位。</p> 
<p>1.3 并发与并行的区别：</p> 
<p>并发(多线程操作同一个资源,交替执行)<br> CPU一核, 模拟出来多条线程,天下武功,唯快不破,快速交替<br> 并行(多个人一起行走, 同时进行)<br> CPU多核,多个线程同时进行 ; 使用线程池操作</p> 
<p>1.4线程的状态</p> 
<pre><code>    // 新生
    NEW,

    // 运行
    RUNNABLE,

    // 阻塞
    BLOCKED,

    // 等待
    WAITING,

    //超时等待
    TIMED_WAITING,

    //终止
    TERMINATED;
</code></pre> 
<p><strong>1.5 wait/sleep的区别：</strong><br> 1来自不同的类</p> 
<p>​ wait来自object类, sleep来自线程类</p> 
<p>2、关于锁的释放</p> 
<p>​ wait会释放锁, sleep不会释放锁</p> 
<p>3、使用的范围不同</p> 
<p>​ wait必须在同步代码块中</p> 
<p>​ sleep可以在任何地方睡</p> 
<p>4、是否需要捕获异常</p> 
<p>​ wait不需要捕获异常</p> 
<p>​ sleep需要捕获异常</p> 
<p><strong>juc的结构</strong><br> <img src="https://images2.imgbox.com/a7/00/EOFgGay7_o.png" alt="在这里插入图片描述"></p> 
<p>1，tools（工具类）：又叫信号量三组工具类，包含有</p> 
<p>1）CountDownLatch（闭锁） 是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待</p> 
<p>2）CyclicBarrier（栅栏） 之所以叫barrier，是因为是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 ，并且在释放等待线程后可以重用。</p> 
<p>3）Semaphore（信号量） 是一个计数信号量，它的本质是一个“共享锁“。信号量维护了一个信号量许可集。线程可以通过调用 acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。</p> 
<p>2，executor(执行者)：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有：</p> 
<p>1）ScheduledExecutorService 解决那些需要任务重复执行的问题</p> 
<p>2）ScheduledThreadPoolExecutor 周期性任务调度的类实现</p> 
<p>3，atomic(原子性包)：是JDK提供的一组原子操作类，</p> 
<p>包含有AtomicBoolean、AtomicInteger、AtomicIntegerArray等原子变量类，他们的实现原理大多是持有它们各自的对应的类型变量value，而且被volatile关键字修饰了。这样来保证每次一个线程要使用它都会拿到最新的值。</p> 
<p>4，locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁包含的实现类有：</p> 
<p>1）ReentrantLock 它是独占锁，是指只能被独自占领，即同一个时间点只能被一个线程锁获取到的锁。</p> 
<p>2）ReentrantReadWriteLock 它包括子类ReadLock和WriteLock。ReadLock是共享锁，而WriteLock是独占锁。</p> 
<p>3）LockSupport 它具备阻塞线程和解除阻塞线程的功能，并且不会引发死锁。</p> 
<p>5，collections(集合类)：主要是提供线程安全的集合， 比如：</p> 
<p>1）ArrayList对应的高并发类是CopyOnWriteArrayList，</p> 
<p>2）HashSet对应的高并发类是 CopyOnWriteArraySet，</p> 
<p>3）HashMap对应的高并发类是ConcurrentHashMap等等</p> 
<p>原文链接：https://blog.csdn.net/weixin_43888181/article/details/116546374</p> 
<h3><a id="5ThreadPoolExecutor_421"></a>5.线程池之ThreadPoolExecutor使用</h3> 
<p>ThreadPoolExecutor提供了四个构造方法：<br> <img src="https://images2.imgbox.com/ab/70/eO7ZpkgR_o.png" alt="在这里插入图片描述"><br> 我们以最后一个构造方法（参数最多的那个），对其参数进行解释：</p> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token comment">// 1 核心线程池大小</span>
                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>  <span class="token comment">// 2 最大线程池大小</span>
                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>  <span class="token comment">// 3 线程最大空闲时间</span>
                              TimeUnit unit<span class="token punctuation">,</span>  <span class="token comment">// 4 时间单位</span>
                              BlockingQueue<span class="token generics function"><span class="token punctuation">&lt;</span>Runnable<span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span> <span class="token comment">// 5 线程等待队列</span>
                              ThreadFactory threadFactory<span class="token punctuation">,</span>  <span class="token comment">// 6 	线程创建工厂</span>
                              RejectedExecutionHandler handler <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//7 拒绝策略</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
            maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>
            maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>
            keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>详情可查看 <a href="https://www.jianshu.com/p/f030aa5d7a28" rel="nofollow">线程池之ThreadPoolExecutor使用</a></p> 
<p>简单写一个线程池：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@EnableAsync</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AsyncTaskConfig</span> <span class="token punctuation">{<!-- --></span>

  <span class="token comment">/*  @Autowired
    private TaskThreadPoolConfig config;*/</span>

    <span class="token comment">// ThredPoolTaskExcutor的处理流程</span>
    <span class="token comment">// 当池子大小小于corePoolSize，就新建线程，并处理请求</span>
    <span class="token comment">// 当池子大小等于corePoolSize，把请求放入workQueue中，池子里的空闲线程就去workQueue中取任务并处理</span>
    <span class="token comment">// 当workQueue放不下任务时，就新建线程入池，并处理请求，如果池子大小撑到了maximumPoolSize，就用RejectedExecutionHandler来做拒绝处理</span>
    <span class="token comment">// 当池子的线程数大于corePoolSize时，多余的线程会等待keepAliveTime长时间，如果无请求可处理就自行销毁</span>
    <span class="token comment">// 当threadNamePrefix设置为true，则核心线程也会超时关闭</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> Executor <span class="token function">myTaskAsyncPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        ThreadPoolTaskExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executor<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executor<span class="token punctuation">.</span><span class="token function">setQueueCapacity</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executor<span class="token punctuation">.</span><span class="token function">setKeepAliveSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executor<span class="token punctuation">.</span><span class="token function">setAllowCoreThreadTimeOut</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executor<span class="token punctuation">.</span><span class="token function">setThreadNamePrefix</span><span class="token punctuation">(</span><span class="token string">"MyExecutor-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// rejection-policy：当pool已经达到max size的时候，如何处理新任务</span>
        <span class="token comment">// CALLER_RUNS：不在新线程中执行任务，而是由调用者所在的线程来执行</span>
        executor<span class="token punctuation">.</span><span class="token function">setRejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executor<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> executor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>使用方法直接在方法前面添加@Async(“myTaskAsyncPool”)注解</p> 
<h3><a id="6synchronizedLock_488"></a>6.关于synchronized同步锁关键字与Lock锁</h3> 
<p><strong>6.1synchronized背景</strong><br> 在 Java 语言中，使用 Synchronized 是能够实现线程同步的，即加锁。并且实现的是悲观锁，在操作同步资源的时候直接先加锁。</p> 
<p>传统synchronized<br> synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：<br> 　　1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；<br> 　　2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；<br> 　　3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；<br> 　　4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</p> 
<p>加锁可以使一段代码在同一时间只有一个线程可以访问，在增加安全性的同时，牺牲掉的是程序的执行性能，所以为了在一定程度上减少获得锁和释放锁带来的性能消耗，在 jdk6 之后便引入了“偏向锁”和“轻量级锁”，所以总共有4种锁状态，级别由低到高依次为：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>。这几个状态会随着竞争情况逐渐升级。</p> 
<p>注意：锁可以升级但不能降级。</p> 
<p><strong>详情可看</strong><a href="https://www.jianshu.com/p/d61f294ac1a6" rel="nofollow">synchronized四种锁状态的升级</a></p> 
<p><strong>6.2 Lock 接口</strong><br> <img src="https://images2.imgbox.com/42/94/J6kt0QAf_o.png" alt="在这里插入图片描述"></p> 
<p>实现类<br> <img src="https://images2.imgbox.com/5f/ac/yogu2uQT_o.png" alt="在这里插入图片描述"></p> 
<p>reentrantLock构造器</p> 
<pre><code>public ReentrantLock() {
    sync = new NonfairSync(); //无参默认非公平锁
}
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();//传参为true为公平锁
}
</code></pre> 
<p><strong>公平锁: 十分公平: 可以先来后到,一定要排队<br> 非公平锁: 十分不公平,可以插队(默认)</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SaleTicketDemo</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Ticket ticket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Ticket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">40</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> ticket<span class="token punctuation">.</span><span class="token function">sale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">40</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> ticket<span class="token punctuation">.</span><span class="token function">sale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">40</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> ticket<span class="token punctuation">.</span><span class="token function">sale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">class</span> <span class="token class-name">Ticket</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> ticketNum <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sale</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>ticketNum <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"购得第"</span> <span class="token operator">+</span> ticketNum<span class="token operator">--</span> <span class="token operator">+</span> <span class="token string">"张票, 剩余"</span> <span class="token operator">+</span> ticketNum <span class="token operator">+</span> <span class="token string">"张票"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//增加错误的发生几率</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p><strong>synchronized和lock锁的区别</strong></p> 
<p>synchronized内置的java关键字,Lock是一个java类<br> synchronized无法判断获取锁的状态, Lock可以判断是否获取到了锁<br> synchronized会自动释放锁,Lock必须要手动释放锁!如果不是释放锁,会产生死锁<br> synchronized 线程1(获得锁,阻塞),线程2(等待); Lock锁就不一定会等待下去<br> synchronized 可重入锁,不可以中断的,非公平的; Lock锁,可重入的,可以判断锁,非公平(可自己设置);<br> synchronized 适合锁少量的代码同步问题,Lock 适合锁大量的同步代码</p> 
<h3><a id="7Javavolatile_571"></a>7.Java并发编程：volatile关键字解析</h3> 
<p>volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。</p> 
<p>volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的。<br> 　　<br> 　在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p> 
<p><strong>1.原子性</strong></p> 
<p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p> 
<p>一个很经典的例子就是银行账户转账问题：</p> 
<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p> 
<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p> 
<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p> 
<p>同样地反映到并发编程中会出现什么结果呢？</p> 
<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p> 
<p>1<br> i = 9;<br> 　　假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p> 
<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p> 
<p><strong>2.可见性</strong></p> 
<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p> 
<p><strong>3.有序性</strong></p> 
<p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p> 
<p>Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p> 
<p>对于可见性，Java提供了volatile关键字来保证可见性。</p> 
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p> 
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p> 
<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p> 
<p><strong>对于volatile关键字，当一个变量被volatile修饰时，i=0；能保持他的原子性，而对于i++这种的话，就不具备其原子性。 一个变量被volatile修饰了，可以保证每次读取这个变量值的时候得到的值是最新的，但是一旦需要对变量进行自增这样的非原子操作，就不会保证这个变量的原子性了。</strong></p> 
<p>举个栗子</p> 
<p>一个变量i被volatile修饰，两个线程想对这个变量修改，都对其进行自增操作也就是i++，i++的过程可以分为三步，首先获取i的值，其次对i的值进行加1，最后将得到的新值写会到缓存中。<br> 线程A首先得到了i的初始值100，但是还没来得及修改，就阻塞了，这时线程B开始了，它也得到了i的值，由于i的值未被修改，即使是被volatile修饰，主存的变量还没变化，那么线程B得到的值也是100，之后对其进行加1操作，得到101后，将新值写入到缓存中，再刷入主存中。根据可见性的原则，这个主存的值可以被其他线程可见。<br> 问题来了，线程A已经读取到了i的值为100，也就是说读取的这个原子操作已经结束了，所以这个可见性来的有点晚，线程A阻塞结束后，继续将100这个值加1，得到101，再将值写到缓存，最后刷入主存，所以即便是volatile具有可见性，也不能保证对它修饰的变量具有原子性。</p> 
<p><strong>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值，这就保证了可见性。</strong></p> 
<p><strong>volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</strong></p> 
<p>volatile关键字禁止指令重排序有两层意思：</p> 
<p>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p> 
<p>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p> 
<p><strong>所以，volatile关键字能保持可见性及有序性，不一定能保持原子性</strong></p> 
<h3><a id="8javaCAS_638"></a>8.关于java中CAS原子性详解</h3> 
<p>因为volatile只能保证可见性，无法保证原子性，而自增操作并不是一个原子操作，在并发的情况下，putstatic指令可能把较小的race值同步回主内存之中，导致我们每次都无法获得想要的结果。那么，应该怎么解决这个问题了？</p> 
<p>决方法：</p> 
<p>首先我们想到的是用synchronized来修饰increase方法。<br> <img src="https://images2.imgbox.com/f7/8f/EvjMEkfS_o.png" alt="在这里插入图片描述"><br> 使用synchronized修饰后，increase方法变成了一个原子操作，因此是肯定能得到正确的结果。但是，我们知道，每次自增都进行加锁，性能可能会稍微差了点，有更好的方案吗？</p> 
<p>答案当然是有的，这个时候我们可以使用Java并发包原子操作类（Atomic开头），例如以下代码。<br> <img src="https://images2.imgbox.com/3d/d9/2IRnFLAD_o.png" alt="在这里插入图片描述"><br> 我们将例子中的代码稍做修改：race改成使用AtomicInteger定义，“race++”改成使用“race.getAndIncrement()”，AtomicInteger.getAndIncrement()是原子操作，因此我们可以确保每次都可以获得正确的结果，并且在性能上有不错的提升（针对本例子，在JDK1.8.0_151下运行）。</p> 
<p>通过方法调用，我们可以发现，getAndIncrement方法调用getAndAddInt方法，最后调用的是compareAndSwapInt方法，这就是CAS。<br> <img src="https://images2.imgbox.com/be/f6/wCFPzZV8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d0/06/Y7fg5dNX_o.png" alt="在这里插入图片描述"><br> getAndAddInt方法解析：拿到内存位置的最新值v，使用CAS尝试修将内存位置的值修改为目标值v+delta，如果修改失败，则获取该内存位置的新值v，然后继续尝试，直至修改成功。</p> 
<p><strong>CAS是什么？</strong><br> CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</p> 
<p>CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。</p> 
<p><strong>CAS的缺点：</strong><br> CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p> 
<p>循环时间长开销很大。<br> 只能保证一个变量的原子操作。<br> ABA问题。</p> 
<p><strong>循环时间长开销很大：</strong><br> CAS 通常是配合无限循环一起使用的，我们可以看到 getAndAddInt 方法执行时，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。</p> 
<p><strong>只能保证一个变量的原子操作：</strong><br> 当对一个变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个变量操作时，CAS 目前无法直接保证操作的原子性。但是我们可以通过以下两种办法来解决：1）使用互斥锁来保证原子性；2）将多个变量封装成对象，通过 AtomicReference 来保证原子性。</p> 
<p><strong>什么是ABA问题？ABA问题怎么解决？</strong><br> CAS 的使用流程通常如下：1）首先从地址 V 读取值 A；2）根据 A 计算目标值 B；3）通过 CAS 以原子的方式将地址 V 中的值从 A 修改为 B。</p> 
<p>但是在第1步中读取的值是A，并且在第3步修改成功了，我们就能说它的值在第1步和第3步之间没有被其他线程改变过了吗？</p> 
<p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p> 
<p>CAS详解原文链接：https://blog.csdn.net/v123411739/article/details/79561458</p> 
<h3><a id="9SpringIOCAOP_688"></a>9.理解Spring两大特性：IOC和AOP</h3> 
<p>众所周知，Spring拥有两大特性：IoC和AOP。IoC，英文全称Inversion of Control，意为控制反转。AOP，英文全称Aspect-Oriented Programming，意为面向切面编程。</p> 
<p>Spring核心容器的主要组件是Bean工厂（BeanFactory），Bean工厂使用控制反转（IoC）模式来降低程序代码之间的耦合度，并提供了面向切面编程（AOP）的实现。</p> 
<p>简单来说，Spring是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的容器框架。</p> 
<p>下面，我们简要说明下这两大特性。</p> 
<p><strong>1. Spring常用注解</strong><br> 在具体介绍IOC和AOP之前，我们先简要说明下Spring常用注解</p> 
<p>1、@Controller：用于标注控制器层组件</p> 
<p>2、@Service：用于标注业务层组件</p> 
<p>3、@Component : 用于标注这是一个受 Spring 管理的组件，组件引用名称是类名，第一个字母小写。可以使用@Component(“beanID”) 指定组件的名称</p> 
<p>4、@Repository：用于标注数据访问组件，即DAO组件</p> 
<p>5、@Bean：方法级别的注解，主要用在@Configuration和@Component注解的类里，@Bean注解的方法会产生一个Bean对象，该对象由Spring管理并放到IoC容器中。引用名称是方法名，也可以用@Bean(name = “beanID”)指定组件名</p> 
<p>6、@Scope(“prototype”)：将组件的范围设置为原型的（即多例）。保证每一个请求有一个单独的action来处理，避免action的线程问题。</p> 
<p>由于Spring默认是单例的，只会创建一个action对象，每次访问都是同一个对象，容易产生并发问题，数据不安全。</p> 
<p>7、@Autowired：默认按类型进行自动装配。在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。</p> 
<p>8、@Resource：默认按名称进行自动装配，当找不到与名称匹配的Bean时会按类型装配。</p> 
<p>简单点说，就是，能够明确该类是一个控制器类组件的，就用@Controller；能够明确是一个服务类组件的，就用@Service；能够明确该类是一个数据访问组件的，就用@Repository；不知道他是啥或者不好区分他是啥，但是就是想让他动态装配的就用@Component。</p> 
<p>@Controller、@Service、@Component、@Repository都是类级别的注解，如果一个方法也想动态装配，就用@Bean。</p> 
<p>当我们想按类型进行自动装配时，就用@Autowired；当我们想按名称（beanID）进行自动装配时，就用@Resource；当我们需要根据比如配置信息等来动态装配不同的组件时，可以用getBean(“beanID”)。</p> 
<p>到这里，如果对这些注解，或是自动装配不太理解，可以继续往下，看完 控制反转(IoC) 内容后再回来理解这里的内容。</p> 
<p><strong>2. 控制反转(IoC)</strong><br> 控制反转，简单点说，就是创建对象的控制权，被反转到了Spring框架上。</p> 
<p>通常，我们实例化一个对象时，都是使用类的构造方法来new一个对象，这个过程是由我们自己来控制的，而控制反转就把new对象的工交给了Spring容器。</p> 
<p>IoC的主要实现方式有两种：依赖查找、依赖注入。</p> 
<p>依赖注入是一种更可取的方式。</p> 
<ol><li>IOC（Inverse of Control）：控制反转，也可以称为依赖倒置。<br> 所谓依赖，从程序的角度看，就是比如A要调用B的方法，那么A就依赖于B，反正A要用到B，则A依赖于B。所谓倒置，你必须理解如果不倒置，会怎么着，因为A必须要有B，才可以调用B，如果不倒置，意思就是A主动获取B的实例：B b = new B()，这就是最简单的获取B实例的方法（当然还有各种设计模式可以帮助你去获得B的实例，比如工厂、Locator等等），然后你就可以调用b对象了。所以，不倒置，意味着A要主动获取B，才能使用B；到了这里，就应该明白了倒置的意思了。倒置就是A要调用B的话，A并不需要主动获取B，而是由其它人自动将B送上门来。<br> 形象的举例就是：<br> 通常情况下，假如你有一天在家里口渴了，要喝水，那么你可以到你小区的小卖部去，告诉他们，你需要一瓶水，然后小卖部给你一瓶水！这本来没有太大问题，关键是如果小卖部很远，那么你必须知道：从你家如何到小卖部；小卖部里是否有你需要的水；你还要考虑是否开着车去；等等等等，也许有太多的问题要考虑了。也就是说，为了一瓶水，你还可能需要依赖于车等等这些交通工具或别的工具，问题是不是变得复杂了？那么如何解决这个问题呢？<br> 解决这个问题的方法很简单：小卖部提供送货上门服务，凡是小卖部的会员，你只要告知小卖部你需要什么，小卖部将主动把货物给你送上门来！这样一来，你只需要做两件事情，你就可以活得更加轻松自在：<br> 第一：向小卖部注册为会员。<br> 第二：告诉小卖部你需要什么。<br> 这和Spring的做法很类似！Spring就是小卖部，你就是A对象，水就是B对象<br> 第一：在Spring中声明一个类：A<br> 第二：告诉Spring，A需要B</li></ol> 
<p><strong>那么依赖查找和依赖注入有什么区别呢？</strong></p> 
<p>依赖查找，主要是容器为组件提供一个回调接口和上下文环境。这样一来，组件就必须自己使用容器提供的API来查找资源和协作对象，控制反转仅体现在那些回调方法上，容器调用这些回调方法，从而应用代码获取到资源。</p> 
<p>依赖注入，组件不做定位查询，只提供标准的Java方法让容器去决定依赖关系。容器全权负责组件的装配，把符合依赖关系的对象通过Java Bean属性或构造方法传递给需要的对象。</p> 
<p><strong>2.1 IoC容器</strong><br> IoC容器：具有依赖注入功能的容器，可以创建对象的容器。IoC容器负责实例化、定位、配置应用程序中的对象并建立这些对象之间的依赖。</p> 
<p><strong>2.2 依赖注入</strong><br> DI，英文全称，Dependency Injection，意为依赖注入。</p> 
<p>依赖注入：由IoC容器动态地将某个对象所需要的外部资源（包括对象、资源、常量数据）注入到组件(Controller, Service等）之中。简单点说，就是IoC容器会把当前对象所需要的外部资源动态的注入给我们。</p> 
<p>Spring依赖注入的方式主要有四个，基于注解注入方式、set注入方式、构造器注入方式、静态工厂注入方式。推荐使用基于注解注入方式，配置较少，比较方便。</p> 
<p>@Autowired与@Resource都可以用来装配Bean，都可以写在字段、setter方法上。他们的区别是：</p> 
<p>@Autowired默认按类型进行自动装配（该注解属于Spring），默认情况下要求依赖对象必须存在，如果要允许为null，需设置required属性为false，例：@Autowired(required=false)。如果要使用名称进行装配，可以与@Qualifier注解一起使用。</p> 
<pre><code class="prism language-java">    <span class="token annotation punctuation">@Autowired</span>
    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"adminService"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> AdminService adminService<span class="token punctuation">;</span>
</code></pre> 
<p>@Resource默认按照名称进行装配（该注解属于J2EE），名称可以通过name属性来指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行装配；如果注解写在setter方法上，默认取属性名进行装配。当找不到与名称相匹配的Bean时，会按照类型进行装配。但是，name属性一旦指定，就只会按照名称进行装配。</p> 
<pre><code class="prism language-java">  	<span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"adminService"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> AdminService adminService<span class="token punctuation">;</span>
</code></pre> 
<p><strong>3. 面向切面编程(AOP)</strong></p> 
<p>面向切面编程（AOP）就是纵向的编程。比如业务A和业务B现在需要一个相同的操作，传统方法我们可能需要在A、B中都加入相关操作代码，而应用AOP就可以只写一遍代码，A、B共用这段代码。并且，当A、B需要增加新的操作时，可以在不改动原代码的情况下，灵活添加新的业务逻辑实现。</p> 
<p>在实际开发中，比如商品查询、促销查询等业务，都需要记录日志、异常处理等操作，AOP把所有共用代码都剥离出来，单独放置到某个类中进行集中管理，在具体运行时，由容器进行动态织入这些公共代码。</p> 
<p>AOP主要一般应用于签名验签、参数校验、日志记录、事务控制、权限控制、性能统计、异常处理等。</p> 
<p>面向切面编程的目标就是分离关注点。什么是关注点呢？就是你要做的事，就是关注点。假如你是个公子哥，没啥人生目标，天天就是衣来伸手，饭来张口，整天只知道玩一件事！那么，每天你一睁眼，就光想着吃完饭就去玩（你必须要做的事），但是在玩之前，你还需要穿衣服、穿鞋子、叠好被子、做饭等等等等事情，这些事情就是你的关注点，但是你只想吃饭然后玩，那么怎么办呢？这些事情通通交给别人去干。在你走到饭桌之前，有一个专门的仆人A帮你穿衣服，仆人B帮你穿鞋子，仆人C帮你叠好被子，仆人C帮你做饭，然后你就开始吃饭、去玩（这就是你一天的正事），你干完你的正事之后，回来，然后一系列仆人又开始帮你干这个干那个，然后一天就结束了！</p> 
<p>AOP的好处就是你只需要干你的正事，其它事情别人帮你干。也许有一天，你想裸奔，不想穿衣服，那么你把仆人A解雇就是了！也许有一天，出门之前你还想带点钱，那么你再雇一个仆人D专门帮你干取钱的活！这就是AOP。每个人各司其职，灵活组合，达到一种可配置的、可插拔的程序结构。<br> 从Spring的角度看，AOP最大的用途就在于提供了事务管理的能力。事务管理就是一个关注点，你的正事就是去访问数据库，而你不想管事务（太烦），所以，Spring在你访问数据库之前，自动帮你开启事务，当你访问数据库结束之后，自动帮你提交/回滚事务！</p> 
<p><strong>3.1 AOP涉及名词</strong><br> <strong>切面（Aspect）</strong>：共有功能的实现。如日志切面、权限切面、验签切面等。在实际开发中通常是一个存放共有功能实现的标准Java类。当Java类使用了@Aspect注解修饰时，就能被AOP容器识别为切面。</p> 
<p><strong>通知（Advice）</strong>：切面的具体实现。就是要给目标对象织入的事情。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际开发中通常是切面类中的一个方法，具体属于哪类通知，通过方法上的注解区分。</p> 
<p><strong>连接点（JoinPoint）</strong>：程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出等。Spring只支持方法级的连接点。一个类的所有方法前、后、抛出异常时等都是连接点。</p> 
<p><strong>切入点（Pointcut）</strong>：用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。</p> 
<p>比如，在上面所说的连接点的基础上，来定义切入点。我们有一个类，类里有10个方法，那就产生了几十个连接点。但是我们并不想在所有方法上都织入通知，我们只想让其中的几个方法，在调用之前检验下入参是否合法，那么就用切点来定义这几个方法，让切点来筛选连接点，选中我们想要的方法。切入点就是来定义哪些类里面的哪些方法会得到通知。</p> 
<p><strong>目标对象（Target）</strong>：那些即将切入切面的对象，也就是那些被通知的对象。这些对象专注业务本身的逻辑，所有的共有功能等待AOP容器的切入。</p> 
<p><strong>代理对象（Proxy）</strong>：将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象本身业务逻辑加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。目标对象被织入共有功能后产生的对象。</p> 
<p><strong>织入（Weaving）</strong>：将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译时、类加载时、运行时。Spring是在运行时完成织入，运行时织入通过Java语言的反射机制与动态代理机制来动态实现。</p> 
<p><strong>有关于spring事务的知识可以看这篇：<a href="https://www.cnblogs.com/mseddl/p/11577846.html" rel="nofollow">Spring事务</a></strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a5ceed4072fa02467457cee5b3771405/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C语言】30行代码写出无限重启程序，室友太吵怎么办？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d5fbc8619eec42e20a35ae885e229e04/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言/C&#43;&#43;游戏项目完整教程：《打砖块》</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>