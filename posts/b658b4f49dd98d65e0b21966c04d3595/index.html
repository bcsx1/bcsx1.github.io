<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Word Search 和 Word Search Ⅱ - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Word Search 和 Word Search Ⅱ" />
<meta property="og:description" content="Word Search 和 Word Search Ⅱ Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where &#34;adjacent&#34; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = [ [&#34;ABCE&#34;], [&#34;SFCS&#34;], [&#34;ADEE&#34;] ] word = &#34;ABCCED&#34;, -&gt; returns true, word = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/b658b4f49dd98d65e0b21966c04d3595/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-08-28T21:22:42+08:00" />
<meta property="article:modified_time" content="2015-08-28T21:22:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Word Search 和 Word Search Ⅱ</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote style="border-left-width:0.5em; border-left-style:solid; border-left-color:rgb(64,170,83); padding:0px 2em; margin-left:0px; max-width:476px; color:rgb(68,68,68); font-family:Georgia,Palatino,'Palatino Linotype',Times,'Times New Roman',serif; font-size:20px; line-height:30px"> 
 <h3 style="color:rgb(17,17,17); font-weight:400; margin:20px 0px 6px; padding:0px; font-size:22px"> Word Search 和 Word Search Ⅱ</h3> 
</blockquote> 
<p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px; color:rgb(68,68,68); font-family:Georgia,Palatino,'Palatino Linotype',Times,'Times New Roman',serif"> </p> 
<p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px; color:rgb(68,68,68); font-family:Georgia,Palatino,'Palatino Linotype',Times,'Times New Roman',serif"> </p> 
<blockquote style="border-left-width:0.5em; border-left-style:solid; border-left-color:rgb(64,170,83); padding:0px 2em; margin-left:0px; max-width:476px; color:rgb(68,68,68); font-family:Georgia,Palatino,'Palatino Linotype',Times,'Times New Roman',serif; font-size:20px; line-height:30px"> 
 <h4 style="color:rgb(17,17,17); font-weight:400; margin-bottom:16px; padding:0px; font-size:21px"> Word Search</h4> 
</blockquote> 
<pre style="padding:0px 4px; max-width:800px; white-space:pre-wrap; font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; font-size:13px; border:1px solid rgb(221,221,221); color:rgb(68,68,68); background-color:rgb(247,247,247)"><code style="font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; border:0px">Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

For example,
Given board =

[
  ["ABCE"],
  ["SFCS"],
  ["ADEE"]
]
word = "ABCCED", -&gt; returns true,
word = "SEE", -&gt; returns true,
word = "ABCB", -&gt; returns false.
</code></pre> 
<p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px; color:rgb(68,68,68); font-family:Georgia,Palatino,'Palatino Linotype',Times,'Times New Roman',serif"> </p> 
<div style="color:rgb(68,68,68); font-family:Georgia,Palatino,'Palatino Linotype',Times,'Times New Roman',serif; font-size:20px; line-height:30px">
  题目意思：在矩阵中查找给定单词，如在 
 <p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px"> </p> 
 <pre style="padding:0px 4px; max-width:800px; white-space:pre-wrap; font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; font-size:13px; border:1px solid rgb(221,221,221); background-color:rgb(247,247,247)"><code style="font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; border:0px">["ABCE"],
  ["SFCS"],
  ["ADEE"]
</code></pre> 
 <p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px"> 中，查找ABCCED，此时可以找到，返回true</p> 
 <p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px"> </p> 
 <div>
   思路：利用回溯，定义一个二维数组dp[][],dp[i][j]表示单词在i,j点经过。从[0,0]开始，如果匹配，则往上下左右四个方向继续进行剩下的查找，直到找到完整的单词 
  <p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px"> </p> 
  <pre style="padding:0px 4px; max-width:800px; white-space:pre-wrap; font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; font-size:13px; border:1px solid rgb(221,221,221); background-color:rgb(247,247,247)"><code class="java" style="font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; border:0px">
<span class="class" style="color:rgb(68,85,136); font-weight:bold"><span class="keyword" style="color:rgb(0,0,255)">class</span> <span class="title">Solution</span> {<!-- --></span>
<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">public</span>:
    bool exist(vector&lt;vector&lt;<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">char</span>&gt; &gt; &amp;board, string word) {

        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">if</span>(word.length()==<span class="number" style="color:rgb(0,0,255)">0</span>)
        {
            <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">return</span> <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">false</span>;
        }
       <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">const</span> <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> m = board.size();
        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">const</span> <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> n = board[<span class="number" style="color:rgb(0,0,255)">0</span>].size();
        vector&lt;vector&lt;bool&gt; &gt; vivisted(m, vector&lt;bool&gt;(n, <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">false</span>));
        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> index=<span class="number" style="color:rgb(0,0,255)">0</span>;
        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">for</span>(<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> i=<span class="number" style="color:rgb(0,0,255)">0</span>;i&lt;board.size();i++)
        {
            <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">for</span>(<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> j=<span class="number" style="color:rgb(0,0,255)">0</span>;j&lt;board[<span class="number" style="color:rgb(0,0,255)">0</span>].size();j++)
            {
                <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">if</span>(board[i][j]==word[<span class="number" style="color:rgb(0,0,255)">0</span>])

                {
                    vivisted[i][j]=<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">true</span>;
                    <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">if</span>(index==word.size()-<span class="number" style="color:rgb(0,0,255)">1</span>||dfsserach(board,word,index+<span class="number" style="color:rgb(0,0,255)">1</span>,i,j,vivisted))
                    {
                        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">return</span> <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">true</span>;
                    }
                    vivisted[i][j]=<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">false</span>;
                }
            }
        }
        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">return</span> <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">false</span>;

    }

    bool dfsserach(vector&lt;vector&lt;<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">char</span>&gt;&gt; &amp;board,string word,<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> index,<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> i,<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> j, vector&lt;vector&lt;bool&gt;&gt; &amp;vivisted)
    {
        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">if</span>(index==word.size()){
            <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">return</span> <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">true</span>;
        }

        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span>  direction[<span class="number" style="color:rgb(0,0,255)">4</span>][<span class="number" style="color:rgb(0,0,255)">2</span>]={-<span class="number" style="color:rgb(0,0,255)">1</span>,<span class="number" style="color:rgb(0,0,255)">0</span>,<span class="number" style="color:rgb(0,0,255)">0</span>,<span class="number" style="color:rgb(0,0,255)">1</span>,<span class="number" style="color:rgb(0,0,255)">1</span>,<span class="number" style="color:rgb(0,0,255)">0</span>,<span class="number" style="color:rgb(0,0,255)">0</span>,-<span class="number" style="color:rgb(0,0,255)">1</span>};

        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> k;
        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">for</span>(k=<span class="number" style="color:rgb(0,0,255)">0</span>;k&lt;<span class="number" style="color:rgb(0,0,255)">4</span>;k++)
        {
            <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> ii=i+direction[k][<span class="number" style="color:rgb(0,0,255)">0</span>];
            <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> jj=j+direction[k][<span class="number" style="color:rgb(0,0,255)">1</span>];

            <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">if</span>(ii&gt;=<span class="number" style="color:rgb(0,0,255)">0</span>&amp;&amp;ii&lt;board.size()&amp;&amp;jj&gt;=<span class="number" style="color:rgb(0,0,255)">0</span>&amp;&amp;jj&lt;board[<span class="number" style="color:rgb(0,0,255)">0</span>].size()&amp;&amp;board[ii][jj]==word[index]&amp;&amp;vivisted[ii][jj]==<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">false</span>)
            {
                vivisted[ii][jj]=<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">true</span>;
                <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">if</span>(index==word.size()-<span class="number" style="color:rgb(0,0,255)">1</span>||dfsserach(board,word,index+<span class="number" style="color:rgb(0,0,255)">1</span>,ii,jj,vivisted))
                {
                    <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">return</span> <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">true</span>;
                }
                vivisted[ii][jj]=<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">false</span>;
            }
        }

        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">return</span> <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">false</span>;
    }

};
</code></pre> 
  <hr> 
  <blockquote style="border-left-width:0.5em; border-left-style:solid; border-left-color:rgb(64,170,83); padding:0px 2em; margin-left:0px; max-width:476px"> 
   <h4 style="color:rgb(17,17,17); font-weight:400; margin-bottom:16px; padding:0px; font-size:21px"> Word SearchⅡ</h4> 
  </blockquote> 
  <pre style="padding:0px 4px; max-width:800px; white-space:pre-wrap; font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; font-size:13px; border:1px solid rgb(221,221,221); background-color:rgb(247,247,247)"><code style="font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; border:0px">Given a 2D board and a list of words from the dictionary, find all words in the board.

Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

For example,
Given words = ["oath","pea","eat","rain"] and board =

[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
Return ["eat","oath"].
</code></pre> 
  <p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px"> </p> 
  <div>
    题目意思是要在给定的矩阵中查找出现在单词字典中单词，如上面的eat和oath在 矩阵中可以找到 
   <p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px"> </p> 
   <p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px"> </p> 
   <div>
     思路：构建字典树，把字典中的单词，创建成字典树,Insert方法重要 
    <p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px"> </p> 
    <pre style="padding:0px 4px; max-width:800px; white-space:pre-wrap; font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; font-size:13px; border:1px solid rgb(221,221,221); background-color:rgb(247,247,247)"><code class="java" style="font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; border:0px">
 struct TrieNode
    {
        TrieNode *child[<span class="number" style="color:rgb(0,0,255)">26</span>];
        string node;
        TrieNode():node(<span class="string" style="color:rgb(221,17,68)">""</span>)
        {
            <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">for</span>(auto &amp;a:child)
                a=NULL;
        }
    };
    struct Trie
    {
        TrieNode *root;
        Trie():root(<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">new</span> TrieNode()){}
        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">void</span> insert(string s)
        {
            TrieNode *p=root;
            <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">for</span>(auto &amp;str:s)
            {
                <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> i=str-<span class="string" style="color:rgb(221,17,68)">'a'</span>;
                <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">if</span>(!p-&gt;child[i])
                {
                    p-&gt;child[i]=<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">new</span> TrieNode();

                }
                p=p-&gt;child[i];
            }
            p-&gt;node =s;
        }

    };

</code></pre> 
    <p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px"> </p> 
    <div>
      构建好字典树之后，根据字母矩阵，然后往字典树中进行查找，时间复杂度N 
     <sup>2</sup> *O(字典查找) 
     <p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px"> </p> 
     <p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px"> 代码如下</p> 
     <pre style="padding:0px 4px; max-width:800px; white-space:pre-wrap; font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; font-size:13px; border:1px solid rgb(221,221,221); background-color:rgb(247,247,247)"><code class="java" style="font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; border:0px">
 <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">for</span>(<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> i=<span class="number" style="color:rgb(0,0,255)">0</span>;i&lt;board.size();i++)
        {
            <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">for</span>(<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> j=<span class="number" style="color:rgb(0,0,255)">0</span>;j&lt;board[<span class="number" style="color:rgb(0,0,255)">0</span>].size();j++)
            {
                <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">if</span>(T.root-&gt;child[board[i][j]-<span class="string" style="color:rgb(221,17,68)">'a'</span>])
                {
                    dp[i][j]=<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">true</span>;<span class="comment" style="color:rgb(0,128,0)">//表示当前</span> 节点 已经走过
                    WordSearch(board,T.root-&gt;child[board[i][j]-'a'],i,j,dp,result);
                    dp[i][j]=false;//去掉走过的痕迹
                }
            }
        }

</code></pre> 
     <p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px"> </p> 
     <div>
       总代码如下： 
      <p style="margin-bottom:16px; padding-top:0px; padding-bottom:0px; font-size:14px; line-height:20px; max-width:540px; margin-top:3px"> </p> 
      <pre style="padding:0px 4px; max-width:800px; white-space:pre-wrap; font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; font-size:13px; border:1px solid rgb(221,221,221); background-color:rgb(247,247,247)"><code class="java" style="font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; border:0px">
<span class="class" style="color:rgb(68,85,136); font-weight:bold"><span class="keyword" style="color:rgb(0,0,255)">class</span> <span class="title">Solution</span> {<!-- --></span>
<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">public</span>:

    struct TrieNode
    {
        TrieNode *child[<span class="number" style="color:rgb(0,0,255)">26</span>];
        string node;
        TrieNode():node(<span class="string" style="color:rgb(221,17,68)">""</span>)
        {
            <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">for</span>(auto &amp;a:child)
                a=NULL;
        }
    };
    struct Trie
    {
        TrieNode *root;
        Trie():root(<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">new</span> TrieNode()){}
        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">void</span> insert(string s)
        {
            TrieNode *p=root;
            <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">for</span>(auto &amp;str:s)
            {
                <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> i=str-<span class="string" style="color:rgb(221,17,68)">'a'</span>;
                <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">if</span>(!p-&gt;child[i])
                {
                    p-&gt;child[i]=<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">new</span> TrieNode();

                }
                p=p-&gt;child[i];
            }
            p-&gt;node =s;
        }

    };
    vector&lt;string&gt; findWords(vector&lt;vector&lt;<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) {

        vector&lt;string&gt; result;
        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">if</span>(board.empty()||board[<span class="number" style="color:rgb(0,0,255)">0</span>].empty()||words.empty())
            <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">return</span> result;

        vector&lt;vector&lt;bool&gt;&gt; dp(board.size(),vector&lt;bool&gt;(board[<span class="number" style="color:rgb(0,0,255)">0</span>].size(),<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">false</span>));
        Trie T;
        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">for</span>(auto &amp;s:words)
            T.insert(s);

        <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">for</span>(<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> i=<span class="number" style="color:rgb(0,0,255)">0</span>;i&lt;board.size();i++)
        {
            <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">for</span>(<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">int</span> j=<span class="number" style="color:rgb(0,0,255)">0</span>;j&lt;board[<span class="number" style="color:rgb(0,0,255)">0</span>].size();j++)
            {
                <span class="keyword" style="color:rgb(0,0,255); font-weight:bold">if</span>(T.root-&gt;child[board[i][j]-<span class="string" style="color:rgb(221,17,68)">'a'</span>])
                {
                    dp[i][j]=<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">true</span>;<span class="comment" style="color:rgb(0,128,0)">//表示当前</span> 节点 已经走过
                    WordSearch(board,T.root-&gt;child[board[i][j]-'a'],i,j,dp,result);
                    dp[i][j]=false;//去掉走过的痕迹
                }
            }
        }

        return result;
    }

    void WordSearch(vector&lt;vector&lt;char&gt;&gt;&amp; board,TrieNode *p,int i,int j,vector&lt;vector&lt;bool&gt;&gt; &amp;dp,vector&lt;string&gt; &amp;result)
    {
        if(!p-&gt;node.empty())//如果当前字典树位于Node处，表示有单词,找到一次，将该单词处的标记清除，继续往下找
        {
            result.push_back(p-&gt;node);
            p-&gt;node.clear();
        }
        int  direction[<span class="number" style="color:rgb(0,0,255)">4</span>][<span class="number" style="color:rgb(0,0,255)">2</span>]={-<span class="number" style="color:rgb(0,0,255)">1</span>,<span class="number" style="color:rgb(0,0,255)">0</span>,0,1,1,0,0,-<span class="number" style="color:rgb(0,0,255)">1</span>};//定义四个方向

       for(int k=0;k&lt;4;k++)
       {
           int new_i=i+direction[k][<span class="number" style="color:rgb(0,0,255)">0</span>];  //新的i
           int new_j=j+direction[k][<span class="number" style="color:rgb(0,0,255)">1</span>]; //新的j

           //跟上面同样的思想，把新的节点看成当前节点继续往前查找
           if(new_i&gt;=0&amp;&amp;new_i&lt;board.size()&amp;&amp;new_j&gt;=<span class="number" style="color:rgb(0,0,255)">0</span>&amp;&amp;new_j&lt;board[<span class="number" style="color:rgb(0,0,255)">0</span>].size()&amp;&amp;dp[new_i][new_j]==<span class="keyword" style="color:rgb(0,0,255); font-weight:bold">false</span>&amp;&amp;p-&gt;child[board[new_i][new_j]-<span class="string" style="color:rgb(221,17,68)">'a'])
           {
               dp[new_i][new_j]=true;
               WordSearch(board,p-&gt;child[board[new_i][new_j]-'a'],new_i,new_j,dp,result);
               dp[new_i][new_j]=false;
           }
       }
    }
};
</span></code></pre> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
 <div> 
  <code class="java" style="font-family:Consolas,Monaco,'Andale Mono',monospace; line-height:1.5; border:0px"><span class="string" style="color:rgb(221,17,68)"><br> </span></code> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2533d6f72fdaa333b686e2c4ba9ad360/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">通俗易懂学C语言-01-什么是C语言以及用处</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/13b70c5d61cd56e61d00cd1c08f33748/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据库-关系代数（类型、完整性约束、基本运算、扩展运算）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>