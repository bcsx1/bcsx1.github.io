<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【面试题】2023年前端最新面试题，JS最新面试题-JS篇 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【面试题】2023年前端最新面试题，JS最新面试题-JS篇" />
<meta property="og:description" content="原文见：语雀（https://www.yuque.com/deepstates/interview/bkbydt）
● js基础
● 现代模式
● 数据类型：
○ 数据类型
■ 基础数据类型
■ 引用数据类型
● 普通对象
● Array 数组
● Funciton（函数/类）
● Error对象
● 数字和日期对象
● 文本处理（正则表达式)
● 结构化数据（json)
● 控制抽象化
● 元编程/反射
○ 数据类型的判断
相关知识点：https://www.yuque.com/webfront/js
js基础
对js的理解？
js是一种基于对象和事件驱动，并具有安全性的脚本语言。
说几条写JavaScript的基本规范？
不要在同一行声明多个变量。请使用 ===/!==来比较true/false或者数值使用对象字面量替代new Array这种形式不要使用全局函数。Switch语句必须带有default分支函数不应该有时候有返回值，有时候没有返回值。For循环必须使用大括号If语句必须使用大括号for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。 js延迟加载的方式有哪些？
defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack。用得最多）、按需异步载入js
js对渲染影响？（数字马力）
现代模式，‘use strict’
javascript 代码中的&#34;use strict&#34;;是什么意思 ? 使用它区别是什么？
一、use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,
二、区别
● 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用； 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;
● 提高编译器效率，增加运行速度； 为未来新版本的Javascript标准化做铺垫。
数据类型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/0a674cda4c0e5f438897ccac66cdbf30/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-17T12:58:31+08:00" />
<meta property="article:modified_time" content="2023-01-17T12:58:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【面试题】2023年前端最新面试题，JS最新面试题-JS篇</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>原文见：<a href="https://www.yuque.com/deepstates/interview/bkbydt" rel="nofollow">语雀</a>（<a href="https://www.yuque.com/deepstates/interview/bkbydt" rel="nofollow">https://www.yuque.com/deepstates/interview/bkbydt</a>）</p> 
</blockquote> 
<p>● js基础<br> ● 现代模式<br> ● 数据类型：<br> ○ 数据类型<br> ■ 基础数据类型<br> ■ 引用数据类型<br> ● 普通对象<br> ● Array 数组<br> ● Funciton（函数/类）<br> ● Error对象<br> ● 数字和日期对象<br> ● 文本处理（正则表达式)<br> ● 结构化数据（json)<br> ● 控制抽象化<br> ● 元编程/反射<br> ○ 数据类型的判断</p> 
<p>相关知识点：<a href="https://www.yuque.com/webfront/js" rel="nofollow">https://www.yuque.com/webfront/js</a><br> js基础<br> 对js的理解？<br> js是一种基于对象和事件驱动，并具有安全性的脚本语言。</p> 
<p>说几条写JavaScript的基本规范？</p> 
<ol><li>不要在同一行声明多个变量。</li><li>请使用 ===/!==来比较true/false或者数值</li><li>使用对象字面量替代new Array这种形式</li><li>不要使用全局函数。</li><li>Switch语句必须带有default分支</li><li>函数不应该有时候有返回值，有时候没有返回值。</li><li>For循环必须使用大括号</li><li>If语句必须使用大括号</li><li>for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</li></ol> 
<p>js延迟加载的方式有哪些？<br> defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack。用得最多）、按需异步载入js</p> 
<p>js对渲染影响？（数字马力）</p> 
<p>现代模式，‘use strict’<br> javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？<br> 一、use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,<br> 二、区别<br> ● 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用； 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;<br> ● 提高编译器效率，增加运行速度； 为未来新版本的Javascript标准化做铺垫。</p> 
<p>数据类型<br> js变量按照存储方式区分为哪些类型？并描述其特点？你能画一下他们的内存图吗?/基本类型与引用类型区别？（百度）（每日互动）<br> 一、两种类型的区别是：存储位置不同<br> ● 原始数据类型：直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br> ● 引用数据类型：存储在堆(heap)中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体<br> 二、特点<br> ● 值类型存储在栈中，存储的是值 ，赋值之后原变量的值不改变 。<br> ● 引用类型存储在堆中，存储的是地址 ，赋值之后是把原变量的引用地址赋值给新变量 ，新变量改变，原来的会跟着改变。<br> 三、内存图</p> 
<p>基础数据类型<br> number<br> 如何判断 0.1 + 0.2 与 0.3 相等？<br> 参考<br> 非是 ECMAScript 独有<br> 一、浮点数为什么会有精度损失<br> ● 浮点数的二进制表示：十进制转换成二进制，出现第一次精度丢失。<br> ● 浮点数的存储：数字是以 双精度浮点数 保存的，其中53位用来存储尾数。因此0.1 、0.2在保存下来的时候发生了精度丢失<br> ● 浮点数的运算：尾数运算后舍入处理，导致了第三次精度丢失<br> 二、解决方案<br> 1、设置误差范围值，通常称为“机器密度”。对于JavaScript来说，这个值是2的-52次幂，即Math.pow(2, -52)<br> if(!Number.EPSILON){<!-- --><br> Number.EPSILON = Math.pow(2, -52);<br> }</p> 
<p>function numbersCloseEnoughToEqual(n1, n2){<!-- --><br> return Math.abs(n1 - n2) &lt; Number.EPSILON;<br> }</p> 
<p>numbersCloseEnoughToEqual(0.1+0.2, 0.3); //true<br> 2、将两边的参数值变成整数后进行比较：将值扩大为1 + 2 和 3 是否相等。</p> 
<p>string<br> 字符串方法/ String对象方法?</p> 
<p>null、undefined<br> null和undefined的区别？</p> 
<ol><li>null是一个表示”无”的对象，是只有一个值的特殊类型，转为数值时为0；<br> undefined是一个表示”无”的原始值，表示一个空对象引用，转为数值时为NaN。</li><li>null 和 undefined 的值相等，但类型不等</li></ol> 
<p>undefined的典型用法？</p> 
<ol><li>数据<br> a. 变量被声明了，但没有赋值时，就等于undefined。<br> b. 对象没有赋值的属性，该属性的值为undefined。</li><li>函数<br> a. 调用函数时，应该提供的参数没有提供，该参数等于undefined。<br> b. 函数没有返回值时，默认返回undefined。</li></ol> 
<p>null的典型用法？</p> 
<ol><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li></ol> 
<p>引用数据类型<br> 对象<br> js中有哪些内置对象？ / js中有哪些数据封装类对象？<br> Object 是 JavaScript 中所有对象的父对象<br> ● 数据封装类对象：Object、Array、Boolean、Number 和 String<br> ● 其他对象：Function、Arguments、Math、Date、RegExp、Error</p> 
<p>Object.is() 与原来的比较操作符" ===“、” =="的区别？<br> ● 两等号判等，会在比较时进行类型转换；<br> ● 三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）；<br> ● Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0<br> ○ 保证 -0 和 +0 不再相同，<br> ○ Object.is(NaN, NaN) 会返回 true<br> ○ Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</p> 
<p>处理对象<br> javascript创建对象的几种方式？<br> 一、对象初始化器<br> var o1 = {name: ‘01’};<br> 二、使用构造器<br> ● 构造函数<br> var M = function(){this.name=‘o2’};<br> var o2 = new M();<br> o2.<strong>proto</strong>=== M.prototype<br> // o2的构造函数是M<br> // o2这个普通函数，是M这个构造函数的实例<br> ● 工厂方式（内置对象）<br> var o11 = new Object({name: ‘011’});<br> ● 原型方式<br> ● 混合方式<br> 三、Object.create()<br> var P = {name:‘o3’};<br> var o3 = Object.create§;<br> 四、使用class关键字</p> 
<p>es6创建对象与es5创建对象的区别？（bilibili)<br> ● ES5实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）。<br> ● ES6实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this。</p> 
<p>深拷贝和浅拷贝，分别举例？</p> 
<ol><li>深拷贝：将对象的各个属性进行递归复制。<br> a. for…in<br> b. JSON.stringify、JSON.parse<br> c. lodash.cloneDeep()</li><li>浅拷贝：将对象的各个属性进行依次复制<br> a. for…in<br> b. Object.assign()<br> c. 拷贝访问器属性本身：Object.defineProperties, Object.getOwnPropertyDescriptos<br> d. 拷贝对象及原型链上的所有属性：Object.create</li></ol> 
<p>对象深拷贝、浅拷贝区别？（百度）<br> ● 深拷贝递归拷贝目标对象的所有属性<br> ● 浅拷贝只会将对象的各个属性进行依次复制，并不会进行递归复制。</p> 
<p>怎么做深拷贝？（百度）（网易）（今日互动）（汇信科技）</p> 
<p>数组</p> 
<p>数组方法/ Array对象方法？/ 数组主要API (大华）</p> 
<p>array数组有哪些方法会改变数组本身？（恒生）<br> ● 添加/删除<br> ○ push()、pop()、shift()、unshift()<br> ○ splice()<br> ● 转换<br> ○ sort()、reverse()</p> 
<p>函数/类<br> 内置函数<br> js中有哪些内置函数？<br> 内置函数：<br> ● eval()方法会对一串字符串形式的JavaScript代码字符求值。<br> ● isFinite()函数判断传入的值是否是有限的数值。如果需要的话，其参数首先被转换为一个数值。<br> ● isNaN()<br> ● parseFloat() 函数解析字符串参数，并返回一个浮点数。<br> ● parseInt()<br> ● encodeURI()<br> ● decodeURI()<br> ● encodeURIComponent()<br> ● decodeURIComponent()<br> ● escape()：20201217：已废弃<br> ● unescape()：20201217：已废弃</p> 
<p>类<br> ECMAScript6 怎么写class，为什么会出现class这种东西?<br> 新的 class 写法让对象原型的写法更加清晰、更像面向对象编程的语法</p> 
<p>类的声明？<br> 1、es5：构造函数，声明一个类<br> function Animal() {<!-- --><br> this.name = ‘name’;<br> }</p> 
<p>2、es6中的class声明<br> class Animal2 {<!-- --><br> constructor() {<!-- --><br> this.name = name;<br> }<br> }</p> 
<p>生成实例？/ 声明一个类，怎么生成类的实例？<br> /<em>实例化</em>/<br> console.log(new Animal(), new Animal2()); // 通过New就可以实例化一个类,如果没有参数，Animal后面的()可以不要</p> 
<p>箭头函数<br> 箭头函数为什么不能new?<br> 对于 new 操作实质上是定义一个具有构造函数内置对象的实例，生成对象实例的过程也是通过构造函数给实例绑定this的过程。而箭头函数实质是一个匿名内部类，不含有 prototype、没有自己的 this 指向、不可以使用 arguments。所以不能使用 new</p> 
<p>函数绑定<br> call、apply的共同点与区别?<br> 1、改变了函数运行上下文<br> 2、call()和apply()主要是能扩充函数赖以运行作用域。<br> 两者的作用方式相同，它们的区别在于<br> ● 接收参数的方式不同<br> ○ 对于call()而言，第一个参数this与apply()相同，其他的参数必须直接传给函数，要一个一个的列出来<br> ○ 对于apply()来说，apply()可以接收一个数组或arguments对象。<br> ○ 所以如何选择二者，在于哪种给函数传参数的方式最简单。</p> 
<p>说说bind、call、apply 区别？?<br> ● call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。<br> ○ 除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。<br> let a = {<!-- --><br> value: 1<br> }<br> function getValue(name, age) {<!-- --><br> console.log(name)<br> console.log(age)<br> console.log(this.value)<br> }<br> getValue.call(a, ‘yck’, ‘24’)<br> getValue.apply(a, [‘yck’, ‘24’])<br> ● bind和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind实现柯里化。</p> 
<p>文本处理<br> RegExp正则表达式</p> 
<p>结构化数据<br> JSON<br> JSON的了解<br> JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。<br> 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小. 如：{“age”:“12”, “name”:“back”}<br> 1、JSON字符串转换为JSON对象:<br> var obj = eval(‘(’+ str +‘)’);<br> var obj = str.parseJSON();<br> var obj = JSON.parse(str);<br> 2、JSON对象转换为JSON字符串：<br> var last = obj.toJSONString();<br> var last = JSON.stringify(obj);</p> 
<p>JSON —— 作用、用途、设计结构。</p> 
<p>stringify序列化对象时，对象的属性为function、null、undefined时结果是什么？<br> 参考<br> 一、作为属性名<br> ● function：忽略<br> ● null、undefined: 转为字符串<br> 二、作为属性值<br> ● function、undefined: 忽略<br> ● null：值仍为null<br> JSON.stringify({<!-- --><br> a() {<!-- --><br> console.log(1)<br> },<br> null: ‘h’,<br> undefined:‘test’,<br> ‘good’: ‘very good’<br> })</p> 
<p>// ‘{“null”:“h”,“undefined”:“test”,“good”:“very good”}’<br> JSON.stringify({<!-- --><br> a() {<!-- --><br> console.log(1)<br> },<br> ‘h’: null,<br> ‘test’: undefined,<br> ‘good’: ‘very good’<br> })</p> 
<p>// ‘{“h”:null,“good”:“very good”}’</p> 
<p>控制抽象化<br> Promises<br> 什么是promise？<br> Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。</p> 
<p>promise常用api<br> Promise 的常用 API 如下：<br> ● Promise.resolve(value)<br> 类方法，该方法返回一个以 value 值解析后的 Promise 对象<br> 1、如果这个值是个 thenable（即带有 then 方法），返回的 Promise 对象会“跟随”这个 thenable 的对象，采用它的最终状态（指 resolved/rejected/pending/settled）<br> 2、如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。<br> 3、其他情况以该值为成功状态返回一个 Promise 对象。<br> 上面是 resolve 方法的解释，传入不同类型的 value 值，返回结果也有区别。这个 API 比较重要，建议大家通过练习一些小例子，并且配合上面的解释来熟悉它。如下几个小例子：<br> //如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。<br> function fn(resolve){<!-- --><br> setTimeout(function(){<!-- --><br> resolve(123);<br> },3000);<br> }<br> let p0 = new Promise(fn);<br> let p1 = Promise.resolve(p0);<br> // 返回为true，返回的 Promise 即是 入参的 Promise 对象。<br> console.log(p0 === p1);<br> 传入 thenable 对象，返回 Promise 对象跟随 thenable 对象的最终状态。<br> ES6 Promises 里提到了 Thenable 这个概念，简单来说它就是一个非常类似 Promise 的东西。最简单的例子就是 jQuery.ajax，它的返回值就是 thenable 对象。但是要谨记，并不是只要实现了 then 方法就一定能作为 Promise 对象来使用。<br> //如果传入的 value 本身就是 thenable 对象，返回的 promise 对象会跟随 thenable 对象的状态。<br> let promise = Promise.resolve($.ajax(‘/test/test.json’));// =&gt; promise对象<br> promise.then(function(value){<!-- --><br> console.log(value);<br> });<br> 返回一个状态已变成 resolved 的 Promise 对象。<br> let p1 = Promise.resolve(123);<br> //打印p1 可以看到p1是一个状态置为resolved的Promise对象<br> console.log(p1)</p> 
<p>● Promise.reject<br> 类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。<br> ● Promise.prototype.then<br> 实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。<br> ● Promise.prototype.catch<br> 实例方法，捕获异常，函数形式：fn(err){}, err 是 catch 注册 之前的回调抛出的异常信息。<br> ● Promise.race<br> 类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败。 。<br> ● Promise.all<br> 类方法，多个 Promise 任务同时执行。<br> 如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。 如果有一个 Promise 任务 rejected，则只返回 rejected 任务的结果。</p> 
<p>为什么Promise的状态一旦变化就无法改变？<br> Promise有3个状态：pending、fulfilled、reject。<br> pending是未完成，fulfilled、reject是已完成，分别表示成功和失败。<br> 一个状态从未完成变成完成之后不可能再回到未完成，状态从未完成变成成功之后也不可能再变成失败，同理，未完成变成失败后也不可能再变成成功。</p> 
<p>介绍promise，异常捕获？（网易）<br> ● .catch处理promise中的各种error：在reject()调用中的，或者在处理程序（handler）中抛出的（thrown）error。<br> ● unhandledrejection事件处理程序（用于浏览器，以及其他环境的模拟），以跟踪未处理的error并告知用户（可能还有我们的服务器）有关信息，以使我们的应用程序永远不会“死掉”</p> 
<p>Promsie 与事件循环<br> Promise在初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完之后，继续往下执行同步代码，在这之前，then 中回调不会执行。同步代码块执行完毕后，才会在事件循环中检测是否有可用的 promise 回调，如果有，那么执行，如果没有，继续下一个事件循环。</p> 
<p>什么是async await？<br> async/await：是一个用同步思维解决异步问题的方案<br> ● 会自动将常规函数转换成Promise，返回值也是一个Promise对象<br> ● 只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数<br> ● 异步函数内部可以使用await<br> ● await放置在Promise调用之前，await强制后面的代码等待，直到Promise对象resolve，得到resolve的值作为await表达式的运算结果<br> ● await只能在async函数内部调用，用在普通函数里就会报错</p> 
<p>promise、async有什么区别？（网易）（每日互动）<br> ● promise是es2015，async是es2017<br> ● 兼容性：Promise即使不支持es6，你依然可以用promise的库或polyfil，而async就很难做到，要实现的成本会高很多<br> ● 错误处理：Promise链式操作，自己catch异常。async则要在函数内catch<br> ● api：Promise有很多并行神器，比如Promise.all、Promise.race等，async无法实现<br> ● Promise是显式的异步，而async/await让你的代码看起来是同步的，你依然需要注意异步</p> 
<p>async函数与Generator函数的不同点？<br> ● Generator出现在ES2015中，async出现在ES2017中。async是generator的语法糖<br> ● 执行方式不同：async自带执行器，Generator函数需要使用执行器（next()等方法）<br> ● 语义更好：async表示异步，await表示等待异步结果；Generator函数的（*）和yield语义就没那么直接了<br> ● await后既可以是Promise对象，也可以是原始类型的值；Generator中yield后面只能跟Thunk函数或Promise对象<br> ● 返回值不同：async函数的返回的是Promise对象，Generator 函数返回生成器对象</p> 
<p>async、await原理<br> async / await实现原理？（每日互动）<br> ● aysnc函数的实现原理：就是将Generator函数和自动执行器，包装在一个函数里。async函数返回一个promise对象<br> ● async函数return原理：async函数本质还是Generator函数，是通过不断执行遍历器对象的next方法来执行函数。当遍历器对象遍历完毕，就将最后遍历（return)的值resolve出来传递给成功回调<br> ● async函数自动执行原理：await有2个作用：<br> ○ 和yield一样，可以将函数的执行进行切割和分步<br> ○ 可以将await后面的值转化为promise实例，然后指定它的回调。所以通过将async函数的下一步执行指定为这个promise实例的回调，就可以实现async自动执行。<br> ● await返回值原理<br> ○ Generator函数遍历器的next方法的参数，会作为上一个yield的返回值。而await会指定其后promise的成功回调</p> 
<p>async await 如何做到阻塞暂停的？</p> 
<p>生成器函数里局部变量是否共用的？如果是共用的，又问原理，前一段函数不是执行完了，为什么局部变量保存下来了</p> 
<p>数据类型的判断<br> js使用typeof能得到的哪些类型？<br> number, string, boolean, undefined, symbol, （注意没有null）<br> object, function</p> 
<p>如何准确判断一个变量arr是数组类型？<br> ● Array.isArray(arr)， // true<br> ● arr instanceof Array, // true<br> ● Object.prototye.toString.call(arr)，// [object Array]</p> 
<p>如何判断一个对象是否属于某一类？/ 判断数据类型的方法有哪些？<br> typeof、instanceof、constructor、Array.isArray()、Object.prototype.toString.call()</p> 
<p>instanceof 可以判断基本类型吗？<br> 不可以</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/238c6bc9fa504e2bc00d4267f425c745/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">dhu 码蹄集 oj赛（第三十二周）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b3f0e45f555012e8008837c44a11fbf1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【面试题】2023年前端最新面试题-http篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>