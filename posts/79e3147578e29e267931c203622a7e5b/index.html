<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker圣经：大白话说Docker底层原理，6W字实现Docker自由 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker圣经：大白话说Docker底层原理，6W字实现Docker自由" />
<meta property="og:description" content="说在前面： 现在拿到offer超级难，甚至连面试电话，一个都搞不到。
尼恩的技术社群（50&#43;）中，很多小伙伴凭借 “左手云原生&#43;右手大数据”的绝活，拿到了offer，并且是非常优质的offer，据说年终奖都足足18个月。
而云原生的核心组件是 Docker &#43; K8S，但是 Docker 又很难。在这里，尼恩从架构师视角出发，Docker &#43; K8S 核心原理做一个宏观的介绍。
由于内容确实太多， 所以写两个pdf 电子书，并且后续会持续升级：
(1) 《 Docker 学习圣经 》PDF
(2) 《 K8S 学习圣经 》PDF
带大家穿透Docker &#43; K8S ，实现Docker &#43; K8S 自由，让大家不迷路。
本书 《 Docker 学习圣经 》PDF的 V1版本，后面会持续迭代和升级。供后面的小伙伴参考，提升大家的 3高 架构、设计、开发水平。
注：本文以 PDF 持续更新，最新尼恩 架构笔记、面试题 的PDF文件，请从这里获取：码云
《 Docker 学习圣经 》PDF 封面 本文目录 文章目录 说在前面：《 Docker 学习圣经 》PDF 封面本文目录Docker基础Docker 巨大的价值Docker 的本质:Docker的广泛应用场景：Docker的在DevOps（开发、运维）场景的应用Docker 的历史 Docker 的入门知识Docker EngineDocker Platform到底什么是docker：什么是容器？docker基本组成Docker 与虚拟机有何区别docker和kvm都是虚拟化技术，它们的主要差别：与传统VM特性对比：docker 与操作系统比较 Docker 的安装环境准备docker安装的三种方式方式一 ：离线安装docker方式二 ：在线安装docker方式三 ：用现成的 （大大的省事） Docker Container概述什么是Container 容器容器与镜像的关系 Docker本地容器相关的操作Container相关命令创建容器查看活跃容器 docker ps查看全部容器停止容器删除容器查看容器的进程信息如何查找容器名称?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/79e3147578e29e267931c203622a7e5b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-25T21:26:18+08:00" />
<meta property="article:modified_time" content="2023-05-25T21:26:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker圣经：大白话说Docker底层原理，6W字实现Docker自由</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_1"></a>说在前面：</h3> 
<p>现在<strong>拿到offer超级难</strong>，甚至连面试电话，一个都搞不到。</p> 
<p>尼恩的<strong>技术社群</strong>（50+）中，很多小伙伴凭借 “左手云原生+右手大数据”的绝活，拿到了offer，并且是非常优质的offer，据说年终奖都足足18个月。</p> 
<p>而云原生的核心组件是 Docker + K8S，但是 Docker 又很难。在这里，尼恩从架构师视角出发，Docker + K8S 核心原理做一个宏观的介绍。</p> 
<blockquote> 
 <p>由于内容确实太多， 所以写两个pdf 电子书，并且后续会持续升级：</p> 
 <p>(1) 《 Docker 学习圣经 》PDF</p> 
 <p>(2) 《 K8S 学习圣经 》PDF</p> 
</blockquote> 
<p>带大家穿透Docker + K8S ，实现Docker + K8S 自由，让大家不迷路。</p> 
<p>本书 《 Docker 学习圣经 》PDF的 V1版本，后面会持续迭代和升级。供后面的小伙伴参考，提升大家的 3高 架构、设计、开发水平。</p> 
<blockquote> 
 <p>注：本文以 PDF 持续更新，最新尼恩 架构笔记、面试题 的PDF文件，请从这里获取：<a href="https://gitee.com/crazymaker/SimpleCrayIM/blob/master/%E7%96%AF%E7%8B%82%E5%88%9B%E5%AE%A2%E5%9C%88%E6%80%BB%E7%9B%AE%E5%BD%95.md" rel="nofollow">码云</a></p> 
</blockquote> 
<h3><a id="_Docker____PDF__27"></a>《 Docker 学习圣经 》PDF 封面</h3> 
<img src="https://images2.imgbox.com/07/c6/aklBQ5zO_o.png" width="500"> 
<h3><a id="_32"></a>本文目录</h3> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">说在前面：</a></li><li><a href="#_Docker____PDF__27" rel="nofollow">《 Docker 学习圣经 》PDF 封面</a></li><li><a href="#_32" rel="nofollow">本文目录</a></li><li><a href="#Docker_35" rel="nofollow">Docker基础</a></li><li><a href="#Docker__43" rel="nofollow">Docker 巨大的价值</a></li><li><ul><li><a href="#Docker__53" rel="nofollow">Docker 的本质:</a></li><li><a href="#Docker_81" rel="nofollow">Docker的广泛应用场景：</a></li><li><a href="#DockerDevOps_96" rel="nofollow">Docker的在DevOps（开发、运维）场景的应用</a></li><li><a href="#Docker__165" rel="nofollow">Docker 的历史</a></li></ul> 
   </li><li><a href="#Docker__217" rel="nofollow">Docker 的入门知识</a></li><li><ul><li><a href="#Docker_Engine_221" rel="nofollow">Docker Engine</a></li><li><a href="#Docker_Platform_260" rel="nofollow">Docker Platform</a></li><li><a href="#docker_275" rel="nofollow">到底什么是docker：</a></li><li><a href="#_288" rel="nofollow">什么是容器？</a></li><li><a href="#docker_314" rel="nofollow">docker基本组成</a></li><li><a href="#Docker__346" rel="nofollow">Docker 与虚拟机有何区别</a></li><li><a href="#dockerkvm_356" rel="nofollow">docker和kvm都是虚拟化技术，它们的主要差别：</a></li><li><a href="#VM_381" rel="nofollow">与传统VM特性对比：</a></li><li><a href="#docker__403" rel="nofollow">docker 与操作系统比较</a></li></ul> 
   </li><li><a href="#Docker__431" rel="nofollow">Docker 的安装</a></li><li><ul><li><a href="#_444" rel="nofollow">环境准备</a></li><li><a href="#docker_484" rel="nofollow">docker安装的三种方式</a></li><li><a href="#_docker_502" rel="nofollow">方式一 ：离线安装docker</a></li><li><a href="#_docker_667" rel="nofollow">方式二 ：在线安装docker</a></li><li><a href="#___750" rel="nofollow">方式三 ：用现成的 （大大的省事）</a></li></ul> 
   </li><li><a href="#Docker_Container_774" rel="nofollow">Docker Container概述</a></li><li><ul><li><a href="#Container__776" rel="nofollow">什么是Container 容器</a></li><li><a href="#_789" rel="nofollow">容器与镜像的关系</a></li></ul> 
   </li><li><a href="#Docker_798" rel="nofollow">Docker本地容器相关的操作</a></li><li><ul><li><a href="#Container_804" rel="nofollow">Container相关命令</a></li><li><a href="#_819" rel="nofollow">创建容器</a></li><li><a href="#_docker_ps_851" rel="nofollow">查看活跃容器 docker ps</a></li><li><a href="#_859" rel="nofollow">查看全部容器</a></li><li><a href="#_871" rel="nofollow">停止容器</a></li><li><a href="#_877" rel="nofollow">删除容器</a></li><li><a href="#_883" rel="nofollow">查看容器的进程信息</a></li><li><a href="#_914" rel="nofollow">如何查找容器名称?</a></li></ul> 
   </li><li><a href="#docker_930" rel="nofollow">docker最为常用的几个命令</a></li><li><ul><li><a href="#docker_932" rel="nofollow">docker的守护进程查看</a></li><li><a href="#docker__938" rel="nofollow">docker 镜像查看</a></li><li><a href="#docker__944" rel="nofollow">docker 容器查看</a></li><li><a href="#Docker_Registry_950" rel="nofollow">Docker Registry配置和查看</a></li></ul> 
   </li><li><a href="#Docker4_972" rel="nofollow">Docker容器进入的4种方式</a></li><li><ul><li><a href="#1docker_attachDocker_985" rel="nofollow">方式1：使用docker attach进入Docker容器</a></li><li><a href="#2SSHDocker_1015" rel="nofollow">方式2：使用SSH进入Docker容器</a></li><li><a href="#3nsenterDocker_1025" rel="nofollow">方式3：使用nsenter进入Docker容器</a></li><li><ul><li><a href="#1nsenter_1029" rel="nofollow">1、什么是nsenter？</a></li><li><a href="#2nsenter_1073" rel="nofollow">2、nsenter安装</a></li><li><a href="#3nsenter__1090" rel="nofollow">3、nsenter的 使用</a></li><li><a href="#docker_1163" rel="nofollow">docker隔离应用应用涉及到的六大名称空间</a></li><li><ul><li><a href="#1pid_ID_1165" rel="nofollow">1、pid 命名空间(进程ID)</a></li><li><a href="#2net__1173" rel="nofollow">2、net 命名空间(网络)</a></li><li><a href="#3ipc__1181" rel="nofollow">3、ipc 命名空间(进程间通信)</a></li><li><a href="#4mnt__1187" rel="nofollow">4、mnt 命名空间(挂载文件系统)</a></li><li><a href="#5UTS__1195" rel="nofollow">5、UTS 命名空间(主机名/域名)</a></li><li><a href="#6user__1199" rel="nofollow">6、user 命名空间(用户)</a></li></ul> 
    </li></ul> 
    </li><li><a href="#nsenterdocker_1203" rel="nofollow">nsenter查看docker的连接</a></li><li><a href="#4docker_execDocker_1219" rel="nofollow">方式4：使用docker exec进入Docker容器</a></li><li><a href="#_1242" rel="nofollow">在容器内部和宿主机中查看容器中的进程信息</a></li><li><ul><li><a href="#_1270" rel="nofollow">查看其父进程信息</a></li><li><a href="#_1294" rel="nofollow">查看子进程信息</a></li><li><a href="#_1304" rel="nofollow">总计三个命令</a></li></ul> 
   </li></ul> 
   </li><li><a href="#Docker_1315" rel="nofollow">Docker本地镜像载入与载出</a></li><li><ul><li><a href="#_1317" rel="nofollow">两种办法</a></li><li><a href="#_1322" rel="nofollow">拉取镜像</a></li><li><a href="#_1336" rel="nofollow">保存镜像</a></li><li><a href="#_1353" rel="nofollow">载入镜像</a></li><li><a href="#tag_1394" rel="nofollow">打个tag</a></li><li><a href="#_1420" rel="nofollow">保存镜像</a></li><li><a href="#_1425" rel="nofollow">载入镜像</a></li></ul> 
   </li><li><a href="#Harbor_1431" rel="nofollow">Harbor私有镜像仓库</a></li><li><ul><li><a href="#Harbor_1444" rel="nofollow">Harbor安装</a></li><li><ul><li><a href="#1_Harbor_1473" rel="nofollow">1、下载 Harbor的压缩包</a></li><li><a href="#2_1483" rel="nofollow">2、上传压缩包到虚拟机，并解压</a></li><li><a href="#3harbor_1497" rel="nofollow">3、创建harbor访问域名证书</a></li><li><a href="#4harbor_1533" rel="nofollow">4、配置harbor</a></li><li><a href="#5prepare__1565" rel="nofollow">5、./prepare 准备</a></li><li><a href="#6installsh_1583" rel="nofollow">6、./install.sh</a></li><li><ul><li><a href="#_1598" rel="nofollow">访问</a></li></ul> 
     </li><li><a href="#7_Harbor_1613" rel="nofollow">7、停止或者重启 Harbor</a></li></ul> 
    </li><li><a href="#dockerdockerharbor_1630" rel="nofollow">修改docker配置文件，使docker支持harbor</a></li><li><a href="#Harbor_1678" rel="nofollow">Harbor使用</a></li><li><ul><li><a href="#SAN_1718" rel="nofollow">什么是含有SAN的证书</a></li></ul> 
    </li><li><a href="#SSL_1759" rel="nofollow">SSL证书格式</a></li><li><ul><li><a href="#1_KEY_1763" rel="nofollow">1. KEY</a></li><li><a href="#2_CRT_1767" rel="nofollow">2. CRT</a></li><li><a href="#3_PEM_1771" rel="nofollow">3. PEM</a></li><li><a href="#4_CSR_1775" rel="nofollow">4. CSR</a></li><li><a href="#5_DER_1785" rel="nofollow">5. DER</a></li><li><a href="#6_PFX_1789" rel="nofollow">6. PFX</a></li><li><a href="#7_JKS_1793" rel="nofollow">7. JKS</a></li><li><a href="#8_KDB_1797" rel="nofollow">8. KDB</a></li><li><a href="#9_OCSP_1801" rel="nofollow">9. OCSP</a></li><li><a href="#10_CER_1805" rel="nofollow">10. CER</a></li><li><a href="#11_CRL_1809" rel="nofollow">11. CRL</a></li><li><a href="#12_SCEP_1813" rel="nofollow">12. SCEP</a></li><li><a href="#13_PKCS7_1817" rel="nofollow">13. PKCS7</a></li><li><a href="#14_PKCS12_1821" rel="nofollow">14. PKCS12</a></li></ul> 
    </li><li><a href="#SAN_1829" rel="nofollow">生成含有SAN的证书</a></li><li><ul><li><a href="#1CA_1834" rel="nofollow">1、生成CA证书私钥</a></li><li><a href="#2CA_1851" rel="nofollow">2、生成CA证书</a></li><li><a href="#3_1864" rel="nofollow">3、生成服务器证书</a></li><li><ul><li><a href="#CSR_1883" rel="nofollow">生成证书签名请求（CSR）</a></li></ul> 
     </li><li><a href="#4v3extHarborcdh1crt_1931" rel="nofollow">4、使用该v3.ext文件为Harbor主机生成证书cdh1.crt</a></li><li><a href="#5cdh1crtcdh1certDocker_1967" rel="nofollow">5、转换cdh1.crt为cdh1.cert，供Docker使用</a></li><li><a href="#6prepareHTTPS_2011" rel="nofollow">6、运行prepare脚本以启用HTTPS</a></li><li><a href="#7installshharbor_2031" rel="nofollow">7、运行install.sh脚本来启动harbor</a></li><li><a href="#_docker__2043" rel="nofollow">证书复制到 docker 并且启动后登录</a></li></ul> 
    </li><li><a href="#hostname_push_2059" rel="nofollow">hostname push失败</a></li><li><ul><li><a href="#_2085" rel="nofollow">以下为解决方法：</a></li></ul> 
    </li><li><a href="#Harber_2143" rel="nofollow">推送镜像到Harber</a></li><li><a href="#Docker__2149" rel="nofollow">Docker 推送命令</a></li><li><a href="#_2177" rel="nofollow">需要生成证书</a></li><li><a href="#_2244" rel="nofollow">推送成功</a></li></ul> 
   </li><li><a href="#Docker_Image_2270" rel="nofollow">Docker Image概述</a></li><li><ul><li><a href="#Image_2272" rel="nofollow">什么是Image</a></li><li><a href="#Image_2279" rel="nofollow">Image的获取</a></li><li><a href="#Base_Image_2292" rel="nofollow">如何做一个自己的Base Image</a></li></ul> 
   </li><li><a href="#Docker_2314" rel="nofollow">构建自己的Docker镜像</a></li><li><ul><li><a href="#Dockerfile_2328" rel="nofollow">Dockerfile语法</a></li><li><a href="#_2451" rel="nofollow">镜像发布</a></li></ul> 
   </li><li><a href="#Docker_2458" rel="nofollow">Docker进程与宿主机进程的对应关系</a></li><li><ul><li><ul><li><a href="#LinuxID_2460" rel="nofollow">Linux通过进程ID查看文件路径</a></li><li><a href="#PID_namespace_2551" rel="nofollow">容器的PID namespace（命名空间）</a></li><li><ul><li><a href="#ID_2561" rel="nofollow">找出容器ID</a></li></ul> 
     </li><li><a href="#_2575" rel="nofollow">查看容器信息</a></li><li><a href="#_2802" rel="nofollow">进入相应目录</a></li><li><a href="#_2867" rel="nofollow">查看容器目录里的进程号</a></li><li><a href="#_2887" rel="nofollow">启动一个进程</a></li><li><a href="#_2913" rel="nofollow">查看容器目录里的进程号</a></li></ul> 
    </li><li><a href="#docker_daemon_docker_2953" rel="nofollow">docker daemon (docker守护进程)</a></li><li><a href="#Docker_3002" rel="nofollow">Docker文件目录和容器内部操作</a></li></ul> 
   </li><li><a href="#Docker_Daemon__3113" rel="nofollow">Docker Daemon 底层原理</a></li><li><ul><li><a href="#Docker_3121" rel="nofollow">演进：Docker守护进程启动</a></li><li><a href="#OCIOpen_Container_Initiative_3171" rel="nofollow">OCI（Open Container Initiative）</a></li><li><ul><li><a href="#image_spec_3187" rel="nofollow">image spec</a></li><li><a href="#runtime_spec_3199" rel="nofollow">runtime spec</a></li></ul> 
    </li><li><a href="#Docker_CLI_3206" rel="nofollow">Docker CLI客户端工具</a></li><li><a href="#Docker_Daemon_dockerd_3214" rel="nofollow">Docker Daemon守护进程 （dockerd）</a></li><li><a href="#Containerd_3224" rel="nofollow">Containerd</a></li><li><a href="#dockershim__3250" rel="nofollow">docker-shim 容器进程</a></li><li><a href="#runc_OCI_reference_implementation_3279" rel="nofollow">runc (OCI reference implementation)</a></li><li><a href="#Dockercontainerd_containerdshimrunc_3307" rel="nofollow">Docker、containerd, containerd-shim和runc之间的关系</a></li><li><a href="#runccontainer_3318" rel="nofollow">通过runc来启动一个container的过程</a></li><li><ul><li><a href="#_3322" rel="nofollow">查看进程信息</a></li><li><a href="#_3334" rel="nofollow">查看父进程信息</a></li><li><a href="#_3344" rel="nofollow">查看进程树</a></li></ul> 
    </li><li><a href="#CRI__3380" rel="nofollow">CRI 运行时接口</a></li></ul> 
   </li><li><a href="#Docker_3426" rel="nofollow">Docker的技术底座：</a></li><li><ul><li><a href="#_3439" rel="nofollow">底层技术支持</a></li></ul> 
   </li><li><a href="#UnionFS___3476" rel="nofollow">UnionFS 联合文件系统</a></li><li><ul><li><a href="#_3478" rel="nofollow">什么是镜像</a></li><li><a href="#UnionFS_AUFS_3488" rel="nofollow">UnionFS 与AUFS</a></li><li><a href="#_Docker__3586" rel="nofollow">什么是 Docker 镜像分层机制？</a></li><li><a href="#Docker_Image__3610" rel="nofollow">Docker Image 如何而来呢？</a></li></ul> 
   </li><li><a href="#Namespaces_3688" rel="nofollow">Namespaces</a></li><li><ul><li><a href="#_3765" rel="nofollow">进程隔离</a></li><li><a href="#_3868" rel="nofollow">网络隔离</a></li><li><a href="#Libnetwork_3949" rel="nofollow">Libnetwork</a></li><li><a href="#Chroot_3991" rel="nofollow">Chroot</a></li></ul> 
   </li><li><a href="#CGroups_3995" rel="nofollow">CGroups物理资源限制分组</a></li><li><a href="#dockersLXCAUFS_4056" rel="nofollow">总之：dockers=LXC+AUFS</a></li><li><a href="#docker_4105" rel="nofollow">深入解读docker网络</a></li><li><ul><li><a href="#docker_4119" rel="nofollow">docker网络理论部分</a></li><li><a href="#Docker_4136" rel="nofollow">Docker网络模式</a></li><li><ul><li><a href="#bridge_4149" rel="nofollow">bridge模式</a></li><li><a href="#host_4169" rel="nofollow">host模式</a></li><li><a href="#Container_4190" rel="nofollow">Container网络模式</a></li><li><a href="#none_4205" rel="nofollow">none模式</a></li><li><a href="#overlay__4211" rel="nofollow">overlay 网络模式</a></li><li><a href="#macvlan__4220" rel="nofollow">macvlan 网络模式</a></li></ul> 
    </li><li><a href="#_4240" rel="nofollow">网络实操</a></li><li><ul><li><a href="#bridge_4260" rel="nofollow">bridge网络</a></li><li><a href="#docker0_4278" rel="nofollow">docker0详解</a></li><li><a href="#_4330" rel="nofollow">多容器之间通讯</a></li><li><a href="#link_4356" rel="nofollow">link容器</a></li><li><ul><li><a href="#bridge_4388" rel="nofollow">新建bridge网络</a></li><li><a href="#lagoubridge_4407" rel="nofollow">把一个运行中容器连接到lagou-bridge网络</a></li></ul> 
     </li><li><a href="#none_4420" rel="nofollow">none网络</a></li><li><a href="#host_4443" rel="nofollow">host网络</a></li></ul> 
    </li><li><a href="#_4466" rel="nofollow">网络命令汇总</a></li><li><ul><li><a href="#_4479" rel="nofollow">查看网络</a></li><li><a href="#_4500" rel="nofollow">创建网络</a></li><li><a href="#_4524" rel="nofollow">网络删除</a></li><li><a href="#_4536" rel="nofollow">查看网络详细信息</a></li><li><a href="#_4549" rel="nofollow">使用网络</a></li><li><a href="#_4563" rel="nofollow">网络连接与断开</a></li></ul> 
   </li></ul> 
   </li><li><a href="#DockerCompose__4578" rel="nofollow">Docker-Compose 简介</a></li><li><ul><li><a href="#DockerCompose_Docker_4584" rel="nofollow">Docker-Compose 用来实现Docker容器快速编排</a></li><li><ul><li><a href="#Dockercompose_4588" rel="nofollow">Docker-compose模板文件简介</a></li><li><a href="#eg_4598" rel="nofollow">eg：</a></li><li><a href="#DockerCompose__4683" rel="nofollow">Docker-Compose 的编排处出来的部署架构</a></li></ul> 
   </li></ul> 
   </li><li><a href="#dockercompose__4687" rel="nofollow">docker-compose 快速编排</a></li><li><ul><li><a href="#DockerCompose__4741" rel="nofollow">Docker-Compose 的编排结构</a></li><li><a href="#YAML_4773" rel="nofollow">YAML模板文件语法</a></li><li><a href="#dockercomposeyml__4781" rel="nofollow">docker-compose.yml 语法说明</a></li><li><ul><li><a href="#1image_4783" rel="nofollow">1、image</a></li><li><a href="#2build_4799" rel="nofollow">2、build</a></li><li><a href="#3command_4803" rel="nofollow">3、command</a></li><li><a href="#4links_4807" rel="nofollow">4、links</a></li><li><a href="#5external_links_4820" rel="nofollow">5、external_links</a></li><li><a href="#6ports_4830" rel="nofollow">6、ports</a></li><li><a href="#7expose_4847" rel="nofollow">7、expose</a></li><li><a href="#8volumes_4857" rel="nofollow">8、volumes</a></li><li><a href="#9volunes_from_4869" rel="nofollow">9、volunes_from</a></li><li><a href="#10environment_4879" rel="nofollow">10、environment</a></li><li><a href="#11env_file_4891" rel="nofollow">11、env_file</a></li><li><a href="#12extends_4910" rel="nofollow">12、extends</a></li><li><a href="#13net_4943" rel="nofollow">13、net</a></li><li><a href="#14pid_4960" rel="nofollow">14、pid</a></li><li><a href="#15dns_4968" rel="nofollow">15、dns</a></li><li><a href="#16cap_addcap_drop_4978" rel="nofollow">16、cap_add，cap_drop</a></li><li><a href="#17dns_search_4990" rel="nofollow">17、dns_search</a></li><li><a href="#18healthcheck_5018" rel="nofollow">18、healthcheck</a></li><li><a href="#19depends_on_5037" rel="nofollow">19、depends_on</a></li><li><a href="#20deploy_5048" rel="nofollow">20、deploy</a></li></ul> 
    </li><li><a href="#dockercomposeyml_5076" rel="nofollow">docker-compose.yml实例</a></li><li><a href="#YAML____5163" rel="nofollow">YAML 文件格式 及 编写注意事项</a></li></ul> 
   </li><li><a href="#1W_5177" rel="nofollow">.....省略1W字</a></li><li><a href="#_5191" rel="nofollow">说在后面</a></li><li><a href="#_5203" rel="nofollow">参考资料</a></li><li><a href="#_PDF_5221" rel="nofollow">技术自由的实现路径 PDF：</a></li><li><ul><li><ul><li><a href="#__5223" rel="nofollow">实现你的 架构自由：</a></li><li><a href="#___5241" rel="nofollow">实现你的 响应式 自由：</a></li><li><a href="#_spring_cloud__5249" rel="nofollow">实现你的 spring cloud 自由：</a></li><li><a href="#_linux__5260" rel="nofollow">实现你的 linux 自由：</a></li><li><a href="#___5266" rel="nofollow">实现你的 网络 自由：</a></li><li><a href="#___5274" rel="nofollow">实现你的 分布式锁 自由：</a></li><li><a href="#___5282" rel="nofollow">实现你的 王者组件 自由：</a></li><li><a href="#___5294" rel="nofollow">实现你的 面试题 自由：</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="Docker_35"></a>Docker基础</h3> 
<p>作为大神或者准架构师/架构师，一定要了解一下docker的底层原理。</p> 
<p>首先还是简单, 说明一下Docker 巨大的价值</p> 
<h3><a id="Docker__43"></a>Docker 巨大的价值</h3> 
<p><img src="https://images2.imgbox.com/c8/f6/j5PFlt5O_o.png" alt=""></p> 
<p>Docker 是一个开源的应用容器引擎，基于 Go 语言开发。</p> 
<p>Docker 遵从 Apache2.0 协议开源。</p> 
<p><img src="https://images2.imgbox.com/98/b0/3t5JO1HJ_o.png" alt=""></p> 
<h4><a id="Docker__53"></a>Docker 的本质:</h4> 
<p>先来说说Docker 的本质</p> 
<blockquote> 
 <p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，实现轻量级虚拟化。</p> 
</blockquote> 
<p>docker为什么有这么巨大的价值呢？</p> 
<p>因为，在容器技术出来之前，大家都是使用虚拟机技术，比如在 window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑，实现硬件资源的细粒度分割和使用隔离。</p> 
<p>但是 ，虚拟机技术太笨重啦！模式太重。</p> 
<p>Docker容器技术，也是一种虚拟化技术，也是实现硬件资源的细粒度分割和使用隔离。但是，Docker是一种轻量级的虚拟机技术。</p> 
<p>Docker容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p> 
<p><img src="https://images2.imgbox.com/be/95/DkkY0DLH_o.png" alt=""></p> 
<p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），</p> 
<p>对于开发人员来说，用 CE（Community Edition） 社区版就可以了</p> 
<h4><a id="Docker_81"></a>Docker的广泛应用场景：</h4> 
<ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul> 
<p>一般来说，测试环境、生产环境，基本都已经全面docker化了。</p> 
<p>可见，docker技术，是那么那么的重要。</p> 
<h4><a id="DockerDevOps_96"></a>Docker的在DevOps（开发、运维）场景的应用</h4> 
<p>一般来说，怎么的微服务应用，有多套环境：</p> 
<pre><code>（1）开发
（2）测试
（3）预生产
（4）生产
</code></pre> 
<p>四套环境，导致环境配置是十分的麻烦，每一个环境都要部署各种组件(如Redis、ES、zk) ，非常的费时费力。</p> 
<p>更要命的是，在生产环境上， 吞吐量一上来，需要动态扩容。</p> 
<p>使用docker，咱们可以将DevOps（开发、运维）的工作，高速完成：</p> 
<p><strong>（1）快速完成 发布工作</strong></p> 
<p>开发环境一般是 Windows/mac，最后发布到Linux。</p> 
<p>没有docker之前，使用jar包发布，配上大量的shell脚本，然后各种配置，及其复杂。</p> 
<p>有了docker之后，做好镜像，开发打包部署上线，一套流程做完！</p> 
<p><strong>（2）快速完成 交付工作</strong></p> 
<p>传统的交付工作，要给用户提供各种安装的帮助文档，安装程序，基础环境安装，依赖的中间件安装，等等等等。</p> 
<p>有了docker之后，能更快速的交付和部署。 给他一套镜像，通过Docker命令，一键运行，啥都是好的。</p> 
<p><em>那你看，docker 是不是，真香。</em></p> 
<p><strong>（3）更便捷的升级和扩缩容</strong></p> 
<p>使用了 Docker之后，我们项目打包为一个镜像，部署应用就和搭积木一样</p> 
<p>扩展服务器A，启动一个容器就ok。</p> 
<p>扩展服务器B，启动一个容器就ok。</p> 
<p>如果要动态扩展，使用K8S这类分布式容器管理基础设施，配上一个HPA 控制器组件，就能自动的完成动态扩容，动态缩容。</p> 
<p><em>那你看，docker 是不是，真香。</em></p> 
<p><strong>（4）服务器的性能可以被压榨到极致</strong></p> 
<p>Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例。</p> 
<p>服务器的性能可以被压榨到极致</p> 
<p><em>那你看，docker 是不是，真香。</em></p> 
<p>接下来，随着40岁老架构师一起，来穿透docker的原理和实操吧。</p> 
<p><em>只有先穿透docker，才能穿透K8S，最终穿透云原生+大数据，实现你的技术自由。</em></p> 
<h4><a id="Docker__165"></a>Docker 的历史</h4> 
<p>2010年，几个的年轻人在美国的旧金山成立了一家公司 dotcloud。dotcloud 是一个Paas平台的创业公司，从事LXC（Linux Container容器）有关的容器技术。</p> 
<p>Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。他们将自己的技术（容器化技术）命名就是 Docker。</p> 
<p>Docker刚刚延生的时候，没有引起行业的注意！</p> 
<p>虽然获得了创业孵化器(Y Combinator)的支持、也获得过一些融资，但随着IT巨头们(微软、谷歌、亚马逊等厂商)也进入PaaS凭他，dotCloud举步维艰，眼看就活不下去！</p> 
<p>2013年，dotCloud的创始人，28岁的Solomon Hykes做了一个艰难的决定，将dotCloud的核心引擎开源，这项核心引擎技术能够将Linux容器中的应用程序、代码打包，轻松的在服务器之间进行迁移。</p> 
<p>2013发布了 Docker-compose 组件提供容器的编排工具。</p> 
<p>2014年 Docker 发布1.0版本，2015年Docker 提供 Docker-machine，支持 windows 平台。</p> 
<p>docker火了。</p> 
<p>这个基于LXC技术的核心管理引擎开源后，让全世界的技术人员感到惊艳。</p> 
<p>大家感叹这一切太方便了！！于是，越来越多的人发现docker的优点，使用他！</p> 
<p>虽然，Docker 项目在开源社区大受追捧，同时也被业界诟病的是： Docker 公司对于 Docker 发展具有绝对的话语权，比如 Docker 公司推行了 libcontainer 难以被社区接受。</p> 
<p>为了防止 Docker 这项开源技术被Docker 公司控制，几个核心贡献代码的厂商诸如 Redhat，谷歌的倡导下，成立了 OCI 开源社区，制定了 OCI 开放容器标准，<em>Open Container Initiative</em>（OCI，开放容器标准）。</p> 
<p>OCI 开源社区旨在于将 Docker 的发展权利回归社区，当然反过来讲，Docker 公司也希望更多的厂商安心贡献代码到Docker 项目，促进 Docker 项目的发展。</p> 
<blockquote> 
 <p>Docker 将自己容器格式和运行时 runC 捐给了 OCI，OCI 在此基础上制定了 2 个标准：</p> 
 <p>运行时标准 Runtime Specification (runtime-spec)</p> 
 <p>镜像标准 Image Specification (image-spec) :</p> 
</blockquote> 
<p>于是通过OCI建立了 runc 项目，替代 libcontainer，这为开发者提供了除 Docker 之外的容器化实现的选择。</p> 
<p>OCI 社区提供了 runc 的维护，而 runc 是基于 OCI 规范的运行容器的工具。</p> 
<p>换句话说，你可以通过 runc，提供自己的容器实现，而不需要依赖 Docker。</p> 
<p>当然，Docker 的发行版底层也是用的 runc。在 Docker 宿主机上执行 runc，你会发现它的大多数命令和 Docker 命令类似，感兴趣的读者可以自己实践如何用 runc 启动容器。</p> 
<p>至2017年，Docker 项目转移到 Moby 项目，基于 Moby 项目，Docker 提供了两种发行版，Docker CE 和 Docker EE， Docker CE 就是目前大家普遍使用的版本，Docker EE 成为付费版本，提供了容器的编排，Service 等概念。</p> 
<p>Docker 公司承诺 Docker 的发行版会基于 Moby 项目。这样一来，通过 Moby 项目，你也可以自己打造一个定制化的容器引擎，而不会被 Docker 公司绑定。</p> 
<h3><a id="Docker__217"></a>Docker 的入门知识</h3> 
<p>从大家常用的Docker Engine开始说起。</p> 
<h4><a id="Docker_Engine_221"></a>Docker Engine</h4> 
<p>当人们说“Docker”时，他们通常是指 Docker Engine，它是一个客户端 - 服务器应用程序，</p> 
<p>Docker 引擎由如下主要的组件构成：Docker 客户端（Docker Client）、Docker 守护进程（Docker daemon）、containerd 以及 runc。</p> 
<p><img src="https://images2.imgbox.com/71/68/Y9q2s1Lb_o.png" alt=""></p> 
<blockquote> 
 <p>Docker Engine 从 CLI 中接受docker 命令，完成容器的管理：</p> 
 <p>例如使用 docker run 、docker ps 来列出正在运行的容器、</p> 
 <p>例如使用docker images 来列出镜像，</p> 
 <p>等等。</p> 
</blockquote> 
<p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上，</p> 
<p>Client通过Socket连接从客户端访问Docker守护进程。Docker守护进程从客户端接受命令，并按照命令，管理运行在主机上的容器。</p> 
<ul><li>后台进行(dockerd)</li><li>REST API Server</li><li>CLI接口（docker）</li></ul> 
<p><img src="https://images2.imgbox.com/ab/96/O6im4pK5_o.png" alt=""></p> 
<h4><a id="Docker_Platform_260"></a>Docker Platform</h4> 
<ul><li>Docker提供了一个开发，打包，运行app的平台</li><li>把app和底层infrastructure隔离开来</li></ul> 
<p>其三层模型如图：</p> 
<p><img src="https://images2.imgbox.com/82/55/2aba5VZi_o.png" alt=""></p> 
<h4><a id="docker_275"></a>到底什么是docker：</h4> 
<p>到底什么是docker：</p> 
<ul><li>docker是一个软件，可以运行在window、linux、mac等各种操作系统上。</li><li>docker 是一个开源的应用容器引擎，基于Go 语言开发并遵从 Apache2.0 协议开源，项目代码托管在github上进行维护</li><li>docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。</li><li>容器是完全使用沙箱机制，相互之间不会有任何接口,更重要的是容器性能开销极低。</li></ul> 
<h4><a id="_288"></a>什么是容器？</h4> 
<p>什么是容器？</p> 
<ul><li>对软件和其依赖的标准化打包</li><li>应用之间相互隔离</li><li>共享同一个OS Kernel</li><li>可以运行在很多主流操作系统上</li></ul> 
<p>注：容器和虚拟机的区别在于容器是APP层面的隔离，而虚拟化是物理资源层面的隔离</p> 
<p>容器解决了什么问题？</p> 
<ul><li>解决了开发和运维之间的矛盾</li><li>在开发和运维之间搭建了一个桥梁，是实现devops最佳解决方案</li></ul> 
<p>一个docker 容器，是一个运行时环境，可以简单理解为进程运行的集装箱。</p> 
<p><img src="https://images2.imgbox.com/6c/d9/QeCXPJv6_o.png" alt=""></p> 
<h4><a id="docker_314"></a>docker基本组成</h4> 
<p>docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p> 
<p>docker仓库(Registry)：用来保存各种打包好的软件镜像；仓库分为公有仓库和私有仓库。(很类似 maven)</p> 
<p>docker镜像(Images)：软件打包好的镜像；放在docker仓库中；</p> 
<p>docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用</p> 
<p>Docker 包括三个基本概念:</p> 
<ul><li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li></ul> 
<p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</p> 
<p>Docker 容器通过 Docker 镜像来创建。</p> 
<table><thead><tr><th align="left">概念</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Docker 镜像(Images)</td><td align="left">Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td></tr><tr><td align="left">Docker 容器(Container)</td><td align="left">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td></tr><tr><td align="left">Docker 客户端(Client)</td><td align="left">Docker 客户端通过命令行或者其他工具使用 Docker SDK (https://docs.docker.com/develop/sdk/) 与 Docker 的守护进程通信。</td></tr><tr><td align="left">Docker 主机(Host)</td><td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td align="left">Docker Registry</td><td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/" rel="nofollow">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;</strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td></tr></tbody></table> 
<h4><a id="Docker__346"></a>Docker 与虚拟机有何区别</h4> 
<blockquote> 
 <p>Docker 的误解：Docker 是轻量级的虚拟机。</p> 
</blockquote> 
<p>很多人将docker理解为， Docker 实现了类似于虚拟化的技术，能够让应用跑在一些轻量级的容器里。这么理解其实是错误的。</p> 
<h4><a id="dockerkvm_356"></a>docker和kvm都是虚拟化技术，它们的主要差别：</h4> 
<p>1、Docker有着比虚拟机更少的抽象层</p> 
<p>2、docker利用的是宿主机的内核，VM需要的是Guest OS</p> 
<p><img src="https://images2.imgbox.com/1b/ba/npX1WNsZ_o.png" alt=""></p> 
<p>二者的不同：</p> 
<ul><li>VM(VMware)在宿主机器、宿主机器操作系统的基础上创建虚拟层、虚拟化的操作系统、虚拟化的仓库，然后再安装应用；</li><li>Container(Docker容器)，在宿主机器、宿主机器操作系统上创建Docker引擎，在引擎的基础上再安装应用。</li></ul> 
<p>所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统，避免引导。docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级！</p> 
<p>虚拟机是加载Guest OS ，这是分钟级别的</p> 
<h4><a id="VM_381"></a>与传统VM特性对比：</h4> 
<p>作为一种轻量级的虚拟化方式，Docker在运行应用上跟传统的虚拟机方式相比具有显著优势：</p> 
<ul><li>Docker 容器很快，启动和停止可以在秒级实现，这相比传统的虚拟机方式要快得多。</li><li>Docker 容器对系统资源需求很少，一台主机上可以同时运行数千个Docker容器。</li><li>Docker 通过类似Git的操作来方便用户获取、分发和更新应用镜像，指令简明，学习成本较低。</li><li>Docker 通过Dockerfile配置文件来支持灵活的自动化创建和部署机制，提高工作效率。</li><li>Docker 容器除了运行其中的应用之外，基本不消耗额外的系统资源，保证应用性能的同时，尽量减小系统开销。</li><li>Docker 利用Linux系统上的多种防护机制实现了严格可靠的隔离。从1.3版本开始，Docker引入了安全选项和镜像签名机制，极大地提高了使用Docker的安全性。</li></ul> 
<table><thead><tr><th align="left">特性</th><th align="left">容器</th><th align="left">虚拟机</th></tr></thead><tbody><tr><td align="left">启动速度</td><td align="left">秒级</td><td align="left">分钟级</td></tr><tr><td align="left">硬盘使用</td><td align="left">一般为MB</td><td align="left">一般为GB</td></tr><tr><td align="left">性能</td><td align="left">接近原生</td><td align="left">弱于原生</td></tr><tr><td align="left">系统支持量</td><td align="left">单机支持上千个容器</td><td align="left">一般几十个</td></tr></tbody></table> 
<h4><a id="docker__403"></a>docker 与操作系统比较</h4> 
<p>docker是一种轻量级的虚拟化方式。与传统操作系统技术的特性比较如下表：</p> 
<table><thead><tr><th>特 性</th><th>容 器</th><th>虚 拟 机</th></tr></thead><tbody><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>性能</td><td>接近原生</td><td>较弱</td></tr><tr><td>内存代价</td><td>很小</td><td>较多</td></tr><tr><td>硬盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>运行密度</td><td>单机支持上千个容器</td><td>一般几十个</td></tr><tr><td>隔离性</td><td>安全隔离</td><td>完全隔离</td></tr><tr><td>迁移性</td><td>优秀</td><td>一般</td></tr></tbody></table> 
<p>传统的虚拟机方式提供的是相对封闭的隔离。</p> 
<p>Docker利用Linux系统上的多种防护技术实现了严格的隔离可靠性，并且可以整合众多安全工具。</p> 
<p>从 1.3.0版本开始，docker重点改善了容器的安全控制和镜像的安全机制， 极大提高了使用docker的安全性。</p> 
<h3><a id="Docker__431"></a>Docker 的安装</h3> 
<p>安装<strong>docker</strong>前置条件</p> 
<p>当我们安装 Docker 的时候，会涉及两个主要组件：</p> 
<ul><li>Docker CLI：客户端</li><li>Docker daemon：有时也被称为“服务端”或者“引擎”</li></ul> 
<h4><a id="_444"></a>环境准备</h4> 
<p>硬件总体要求，可以参考尼恩的本地硬件情况：</p> 
<p><strong>1、硬件要求。</strong></p> 
<p>本文硬件总体要求如下表：</p> 
<table><thead><tr><th>序号</th><th>硬件</th><th>要求</th></tr></thead><tbody><tr><td>1</td><td>CPU</td><td>至少2核</td></tr><tr><td>2</td><td>内存</td><td>至少8G</td></tr><tr><td>3</td><td>硬盘</td><td>至少100G磁盘空间</td></tr></tbody></table> 
<p><strong>2、本地虚拟机环境</strong></p> 
<table><thead><tr><th>软件</th><th>版本</th></tr></thead><tbody><tr><td>Win</td><td>win10以上</td></tr><tr><td>virtual box</td><td>6以上</td></tr><tr><td>vagrant</td><td>2以上</td></tr></tbody></table> 
<p><em>docker+K8S学习环境非常复杂，尼恩搞这个 前前后后起码折腾了一周，</em></p> 
<p><em>其中，很多头疼的工作，包括linux内核升级、磁盘扩容等等， 苦不堪言。</em></p> 
<p>现在把这个环境，以虚拟机box镜像的方式，导出来直接给大家，</p> 
<p>大家一键导入后，直接享受docker 的实操，享受K8S的实操，可以说，爽到不要不要的。</p> 
<p><em>以上软件和 尼恩个人的虚拟机box镜像，可以找尼恩获取。</em></p> 
<h4><a id="docker_484"></a>docker安装的三种方式</h4> 
<blockquote> 
 <p>安装docker的三种方式</p> 
 <p>（1）离线安装</p> 
 <p>（2）在线安装</p> 
 <p>（3）用现成的</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/da/df/UHPG5HY1_o.png" alt=""></p> 
<h4><a id="_docker_502"></a>方式一 ：离线安装docker</h4> 
<p><strong>这里以 19.03.9 版本进行介绍， 其他版本是一样的。</strong></p> 
<p>这种安装方式，可以用于没有 互联网的 场景。</p> 
<p>比如，很多公司，并不能直接上外网。</p> 
<p><strong>一、基础环境</strong></p> 
<p>1、操作系统：CentOS 7.3</p> 
<p>2、Docker版本：<a href="https://download.docker.com/linux/static/stable/x86_64/" rel="nofollow">19.03.9 官方下载地址</a></p> 
<p>3、官方参考文档：<a href="https://blog.csdn.net/lcgskycby/article/details/108476333#install-static-binaries">https://docs.docker.com/install/linux/docker-ce/binaries/#install-static-binaries</a></p> 
<p><strong>二、Docker安装</strong></p> 
<p>1、下载</p> 
<p><code>wget https://download.docker.com/linux/static/stable/x86_64/docker-19.03.9.tgz</code></p> 
<p>注意：如果事先下载好了可以忽略这一步</p> 
<p>2、解压</p> 
<p>把压缩文件存在指定目录下(如root)，并进行解压</p> 
<p><code>tar -zxvf docker-19.03.9.tgz</code></p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> root
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># tar -zxvf docker-19.03.6.tgz</span>
docker/
docker/containerd
docker/docker
docker/ctr
docker/dockerd
docker/runc
docker/docker-proxy
docker/docker-init
docker/containerd-shim
</code></pre> 
<p>3、将解压出来的docker文件内容移动到 /usr/bin/ 目录下</p> 
<p><code>cp docker/* /usr/bin/</code></p> 
<p>4、将docker注册为service</p> 
<p><code>cat /etc/systemd/system/docker.service</code></p> 
<p><code>vi /etc/systemd/system/docker.service</code></p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>
<span class="token assign-left variable">Description</span><span class="token operator">=</span>Docker Application Container Engine
<span class="token assign-left variable">Documentation</span><span class="token operator">=</span>https://docs.docker.com
<span class="token assign-left variable">After</span><span class="token operator">=</span>network-online.target firewalld.service
<span class="token assign-left variable">Wants</span><span class="token operator">=</span>network-online.target

<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>
<span class="token assign-left variable">Type</span><span class="token operator">=</span>notify
<span class="token comment"># the default is not to use systemd for cgroups because the delegate issues still</span>
<span class="token comment"># exists and systemd currently does not support the cgroup feature set required</span>
<span class="token comment"># for containers run by docker</span>
<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/bin/dockerd
<span class="token assign-left variable">ExecReload</span><span class="token operator">=</span>/bin/kill -s HUP <span class="token variable">$MAINPID</span>

<span class="token comment"># Having non-zero Limit*s causes performance problems due to accounting overhead</span>

<span class="token comment"># in the kernel. We recommend using cgroups to do container-local accounting.</span>

<span class="token assign-left variable">LimitNOFILE</span><span class="token operator">=</span>infinity
<span class="token assign-left variable">LimitNPROC</span><span class="token operator">=</span>infinity
<span class="token assign-left variable">LimitCORE</span><span class="token operator">=</span>infinity

<span class="token comment"># Uncomment TasksMax if your systemd version supports it.</span>
<span class="token comment"># Only systemd 226 and above support this version.</span>
<span class="token comment">#TasksMax=infinity</span>
<span class="token assign-left variable">TimeoutStartSec</span><span class="token operator">=</span><span class="token number">0</span>

<span class="token comment"># set delegate yes so that systemd does not reset the cgroups of docker containers</span>

<span class="token assign-left variable">Delegate</span><span class="token operator">=</span>yes

<span class="token comment"># kill only the docker process, not all processes in the cgroup</span>

<span class="token assign-left variable">KillMode</span><span class="token operator">=</span>process

<span class="token comment"># restart the docker process if it exits prematurely</span>

<span class="token assign-left variable">Restart</span><span class="token operator">=</span>on-failure
<span class="token assign-left variable">StartLimitBurst</span><span class="token operator">=</span><span class="token number">3</span>
<span class="token assign-left variable">StartLimitInterval</span><span class="token operator">=</span>60s

<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>
<span class="token assign-left variable">WantedBy</span><span class="token operator">=</span>multi-user.target
</code></pre> 
<p>5、启动</p> 
<pre><code class="prism language-bash"><span class="token function">chmod</span> +x /etc/systemd/system/docker.service  <span class="token comment">#添加文件权限并启动docker</span>

systemctl daemon-reload               <span class="token comment">#重载unit配置文件</span>

systemctl start docker     <span class="token comment">#启动Docker</span>

systemctl <span class="token builtin class-name">enable</span> docker.service       <span class="token comment">#设置开机自启</span>
</code></pre> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># vi /etc/systemd/system/docker.service</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># chmod +x /etc/systemd/system/docker.service</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># systemctl daemon-reload</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># systemctl start docker</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># systemctl enable docker.service</span>
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /etc/systemd/system/docker.service.
</code></pre> 
<p>6、验证</p> 
<pre><code class="prism language-bash">systemctl status docker <span class="token comment">#查看Docker状态</span>

docker -v <span class="token comment">#查看Docker版本</span>

docker info
</code></pre> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># systemctl status docker</span>
 docker.service - Docker Application Container Engine
   Loaded: loaded <span class="token punctuation">(</span>/etc/systemd/system/docker.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: disabled<span class="token punctuation">)</span>
   Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since Sat <span class="token number">2021</span>-10-09 <span class="token number">15</span>:25:44 CST<span class="token punctuation">;</span> 29s ago
     Docs: https://docs.docker.com
 Main PID: <span class="token number">1916</span> <span class="token punctuation">(</span>dockerd<span class="token punctuation">)</span>
   CGroup: /system.slice/docker.service
           ├─1916 /usr/bin/dockerd
           └─1927 containerd --config /var/run/docker/containerd/containerd.toml --log-level info

Oct 09 <span class="token number">15</span>:25:43 localhost.localdomain dockerd<span class="token punctuation">[</span><span class="token number">1916</span><span class="token punctuation">]</span>: <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token string">"2021-10-09T15:25:43.671407996+08:00"</span> <span class="token assign-left variable">level</span><span class="token operator">=</span>info <span class="token assign-left variable">msg</span><span class="token operator">=</span><span class="token string">"scheme <span class="token entity" title='\"'>\"</span>unix<span class="token entity" title='\"'>\"</span> not r...e=grpc
Oct 09 15:25:43 localhost.localdomain dockerd[1916]: time="</span><span class="token number">2021</span>-10-09T15:25:43.671440368+08:00<span class="token string">" level=info msg="</span>ccResolverWrapper: se<span class="token punctuation">..</span>.e<span class="token operator">=</span>grpc
Oct 09 <span class="token number">15</span>:25:43 localhost.localdomain dockerd<span class="token punctuation">[</span><span class="token number">1916</span><span class="token punctuation">]</span>: <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token string">"2021-10-09T15:25:43.671462935+08:00"</span> <span class="token assign-left variable">level</span><span class="token operator">=</span>info <span class="token assign-left variable">msg</span><span class="token operator">=</span><span class="token string">"ClientConn switching ...e=grpc
Oct 09 15:25:43 localhost.localdomain dockerd[1916]: time="</span><span class="token number">2021</span>-10-09T15:25:43.750687781+08:00<span class="token string">" level=info msg="</span>Loading containers: start.<span class="token string">"
Oct 09 15:25:44 localhost.localdomain dockerd[1916]: time="</span><span class="token number">2021</span>-10-09T15:25:44.072960862+08:00<span class="token string">" level=info msg="</span>Default bridge <span class="token punctuation">(</span>docke<span class="token punctuation">..</span>.dress<span class="token string">"
Oct 09 15:25:44 localhost.localdomain dockerd[1916]: time="</span><span class="token number">2021</span>-10-09T15:25:44.153444071+08:00<span class="token string">" level=info msg="</span>Loading containers: done.<span class="token string">"
Oct 09 15:25:44 localhost.localdomain dockerd[1916]: time="</span><span class="token number">2021</span>-10-09T15:25:44.175249299+08:00<span class="token string">" level=info msg="</span>Docker daemon<span class="token string">" commit...9.03.6
Oct 09 15:25:44 localhost.localdomain dockerd[1916]: time="</span><span class="token number">2021</span>-10-09T15:25:44.175337834+08:00<span class="token string">" level=info msg="</span>Daemon has completed <span class="token punctuation">..</span>.ation<span class="token string">"
Oct 09 15:25:44 localhost.localdomain systemd[1]: Started Docker Application Container Engine.
Oct 09 15:25:44 localhost.localdomain dockerd[1916]: time="</span><span class="token number">2021</span>-10-09T15:25:44.195084106+08:00<span class="token string">" level=info msg="</span>API listen on /var/ru<span class="token punctuation">..</span><span class="token punctuation">..</span>sock"
Hint: Some lines were ellipsized, use -l to show <span class="token keyword">in</span> full.
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker -v</span>
Docker version <span class="token number">19.03</span>.6, build 369ce74a3c
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker info</span>
</code></pre> 
<h4><a id="_docker_667"></a>方式二 ：在线安装docker</h4> 
<p>如果可以连接公网，建议在线安装。</p> 
<p>这里注意 linux和 docker的版本。</p> 
<p>尼恩安装 docker 最新版本的时候，发现依赖了 Centos 8 以上的版本。</p> 
<p>在线安装docker步骤</p> 
<ol><li>更新yum</li></ol> 
<pre><code class="prism language-bash">yum update
</code></pre> 
<ol start="2"><li>安装工具包</li></ol> 
<pre><code class="prism language-bash">yum -y <span class="token function">install</span> yum-utils
</code></pre> 
<ol start="3"><li>设置yum源</li></ol> 
<pre><code class="prism language-bash">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre> 
<p>以腾讯源为例</p> 
<pre><code>https://mirrors.cloud.tencent.com/docker-ce/linux/centos/docker-ce.repo
</code></pre> 
<ol start="4"><li>安装Docker-Ce(社区版)</li></ol> 
<pre><code class="prism language-bash">yum <span class="token function">install</span> docker-ce
</code></pre> 
<ol start="5"><li>查看docker版本（用来确认是否安装成功）</li></ol> 
<pre><code class="prism language-bash"><span class="token comment"># 输入 docker-v 后如果出现下面的内容则代表安装成功</span>
<span class="token punctuation">[</span>root@VM-24-9-centos ~<span class="token punctuation">]</span><span class="token comment"># docker -v</span>
Docker version <span class="token number">20.10</span>.23, build <span class="token number">7155243</span>
</code></pre> 
<ol start="6"><li>Docker镜像加速（国内使用）</li></ol> 
<pre><code class="prism language-bash"><span class="token comment"># 需要确定/etc下面是否有docker这个文件夹，若没有则需要使用下面的命令进行创建</span>
<span class="token function">mkdir</span> -p /etc/docker

<span class="token comment"># 创建配置文件daemon.json</span>
<span class="token function">vi</span> /etc/docker/daemon.json

<span class="token comment"># 写入以下内容</span>
<span class="token punctuation">{<!-- --></span>
<span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
<span class="token string">"https://mirror.ccs.tencentyun.com"</span> <span class="token comment"># 可以替换为其他厂商的地址</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment"># 重载一下配置</span>
systemctl daemon-reload
</code></pre> 
<ol start="7"><li>启动Docker服务</li></ol> 
<pre><code class="prism language-bash">systemctl start docker
</code></pre> 
<ol start="8"><li>验证docker是否可以使用</li></ol> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-24-9-centos ~<span class="token punctuation">]</span><span class="token comment"># docker ps</span>
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</code></pre> 
<h4><a id="___750"></a>方式三 ：用现成的 （大大的省事）</h4> 
<p>docker+K8S 是一整套技术体系。</p> 
<p>但是，docker+K8S学习环境非常复杂，尼恩搞这个 前前后后起码折腾了一周。</p> 
<p>其中，很多头疼的工作，包括linux内核升级、磁盘扩容等等， 苦不堪言。</p> 
<p>现在把这个环境，以虚拟机box镜像的方式，导出来直接给大家，</p> 
<p>大家一键导入后，直接<strong>享受docker 的实操</strong>，<strong>享受K8S的实操</strong>，</p> 
<p>可以说，爽到不要不要的。</p> 
<p><img src="https://images2.imgbox.com/6f/a7/oF6gfsSi_o.png" alt=""></p> 
<p><em>以上环境和 尼恩个人的虚拟机box镜像，可以找尼恩获取。</em></p> 
<h3><a id="Docker_Container_774"></a>Docker Container概述</h3> 
<h4><a id="Container__776"></a>什么是Container 容器</h4> 
<ul><li>通过Image创建(copy)</li><li>在Image layer之上建立一个container layer（可读写）</li><li>类比面向对象：类和实例</li><li>Image负责app的存储和分发，Container负责运行app</li></ul> 
<p><img src="https://images2.imgbox.com/96/10/EOLiEssk_o.png" alt=""></p> 
<h4><a id="_789"></a>容器与镜像的关系</h4> 
<ul><li>镜像：镜像是只读文件，提供运行程序完整的软硬件资源。</li><li>容器：容器是镜像的实例，由docker负责创建，容器之间彼此隔离。</li></ul> 
<p><img src="https://images2.imgbox.com/8c/02/XxPWyKtl_o.png" alt=""></p> 
<h3><a id="Docker_798"></a>Docker本地容器相关的操作</h3> 
<p><img src="https://images2.imgbox.com/60/ce/835FXVro_o.png" alt=""></p> 
<h4><a id="Container_804"></a>Container相关命令</h4> 
<ul><li>创建容器 docker run centos</li><li>创建容器 docker run -it centos</li><li>查看活跃容器 docker ps</li><li>查询容器状态 docker container ls -a</li><li>移除容器 docker container rm + [container ID]</li><li>移除镜像 docker image rm + [image ID]</li><li>显示所有containerID docker container ls -aq</li><li>移除所有的container docker rm $（docker container ls -aq）</li></ul> 
<h4><a id="_819"></a>创建容器</h4> 
<p>创建名为"centos6"的容器，并在容器内部和宿主机中查看容器中的进程信息</p> 
<pre><code class="prism language-bash">docker run -itd -p <span class="token number">6080</span>:80 -p <span class="token number">6022</span>:22 docker.io/lemonbar/centos6-ssh:latest
</code></pre> 
<p>结果如下</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-4-17-centos ~<span class="token punctuation">]</span><span class="token comment">#    docker run -itd -p 80:80 -p 6022:22 docker.io/lemonbar/centos6-ssh:latest</span>
Unable to <span class="token function">find</span> image <span class="token string">'lemonbar/centos6-ssh:latest'</span> locally
latest: Pulling from lemonbar/centos6-ssh
a3ed95caeb02: Pull complete
f79eb1f22352: Pull complete
67c1aaa530c8: Pull complete
80447774eee7: Pull complete
6d67b3a80e5a: Pull complete
f1819e4b2f8f: Pull complete
09712b5b9acc: Pull complete
8bc987c5494f: Pull complete
c42b021d0ff2: Pull complete
Digest: sha256:093c2165b3c6fe05d5658343456f9b59bb7ecc690a7d3a112641c86083227dd1
Status: Downloaded newer image <span class="token keyword">for</span> lemonbar/centos6-ssh:latest
a4f1c9b8abcda78c8764cc285183dfa56cd1aa4ce6d111d4d9e77f3a57f3d5fc
</code></pre> 
<h4><a id="_docker_ps_851"></a>查看活跃容器 docker ps</h4> 
<p><code>docker ps</code></p> 
<p><img src="https://images2.imgbox.com/52/2b/6EheNzBG_o.png" alt=""></p> 
<h4><a id="_859"></a>查看全部容器</h4> 
<p>查询容器状态</p> 
<p><code>docker ps -a</code></p> 
<p><code>docker container ls -a</code></p> 
<p>两个命令，效果差不多</p> 
<h4><a id="_871"></a>停止容器</h4> 
<p><code>docker stop id</code></p> 
<h4><a id="_877"></a>删除容器</h4> 
<p><code>docker rm id</code></p> 
<h4><a id="_883"></a>查看容器的进程信息</h4> 
<p><code>docker top</code>：查看容器中运行的进程信息，支持 ps 命令参数。</p> 
<p>语法</p> 
<pre><code class="prism language-bash">docker <span class="token function">top</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> CONTAINER <span class="token punctuation">[</span>ps OPTIONS<span class="token punctuation">]</span>
</code></pre> 
<p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，</p> 
<p>可以使用docker top来实现查看container中正在运行的进程。</p> 
<pre><code class="prism language-bash">docker <span class="token function">top</span> 容器名称
</code></pre> 
<p>尼恩的虚拟机中，存在容器zookeeper/ mysql，如果想查看zookeeper/ mysql 容器内的运行进程信息，</p> 
<p>可以使用下述命令：</p> 
<pre><code class="prism language-bash">docker <span class="token function">top</span> zookeeper
docker <span class="token function">top</span> mysql
</code></pre> 
<p><img src="https://images2.imgbox.com/9a/78/U7LlD5Bd_o.png" alt=""></p> 
<h4><a id="_914"></a>如何查找容器名称?</h4> 
<p>很多的命令，用到容器名称</p> 
<p>如何查找容器名称，可以使用下面的命令</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker ps --format "{<!-- -->{.Names}}"</span>
</code></pre> 
<p>结果如下：</p> 
<p><img src="https://images2.imgbox.com/9a/4a/5TQcw4PK_o.png" alt=""></p> 
<h3><a id="docker_930"></a>docker最为常用的几个命令</h3> 
<h4><a id="docker_932"></a>docker的守护进程查看</h4> 
<p><code>systemctl status docker</code></p> 
<h4><a id="docker__938"></a>docker 镜像查看</h4> 
<p><code>docker image ls</code></p> 
<h4><a id="docker__944"></a>docker 容器查看</h4> 
<p><code>docker ps</code></p> 
<h4><a id="Docker_Registry_950"></a>Docker Registry配置和查看</h4> 
<p><code>cat /etc/docker/daemon.json</code></p> 
<pre><code class="prism language-json">配置私有仓库

cat<span class="token operator">&gt;</span><span class="token operator">/</span>etc<span class="token operator">/</span>docker<span class="token operator">/</span>daemon<span class="token punctuation">.</span>json<span class="token operator">&lt;&lt;</span><span class="token constant">EOF</span>

<span class="token punctuation">{<!-- --></span>
  <span class="token string">"registry-mirrors"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"http://10.24.2.30:5000"</span><span class="token punctuation">,</span><span class="token string">"https://tnxkcso1.mirrors.aliyuncs.com"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>

  <span class="token string">"insecure-registries"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"10.24.2.30:5000"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token constant">EOF</span>
</code></pre> 
<h3><a id="Docker4_972"></a>Docker容器进入的4种方式</h3> 
<p>在使用Docker创建了容器之后，大家比较关心的就是如何进入该容器了，</p> 
<p>其实进入Docker容器有好几多种方式，这里我们就讲一下常用的几种进入Docker容器的方法。</p> 
<p>进入Docker容器比较常见的几种做法如下：</p> 
<ul><li>使用docker attach</li><li>使用SSH</li><li>使用nsenter</li><li>使用exec</li></ul> 
<h4><a id="1docker_attachDocker_985"></a>方式1：使用docker attach进入Docker容器</h4> 
<p>Docker提供了attach命令来进入Docker容器。</p> 
<p>接下来我们创建一个守护态的Docker容器，然后使用docker attach命令进入该容器。</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> docker run -itd ubuntu:14.04 /bin/bash  
</code></pre> 
<p>然后我们使用docker ps查看到该容器信息，接下来就使用docker attach进入该容器</p> 
<p><img src="https://images2.imgbox.com/75/0e/ZsqeNw0i_o.png" alt=""></p> 
<pre><code class="prism language-bash"> docker attach c1437f4bd302  
</code></pre> 
<p><img src="https://images2.imgbox.com/c2/1a/Q4M4IqSK_o.png" alt=""></p> 
<p>可以看到我们已经进入到该容器中了。</p> 
<p>但在，使用该命令有一个问题:</p> 
<blockquote> 
 <p>当多个窗口同时使用该命令进入该容器时，所有的窗口都会同步显示。</p> 
</blockquote> 
<p>如果有一个窗口阻塞了，那么其他窗口也无法再进行操作。</p> 
<p>因为这个原因，所以docker attach命令不太适合于生产环境，平时自己开发应用时可以使用该命令。</p> 
<h4><a id="2SSHDocker_1015"></a>方式2：使用SSH进入Docker容器</h4> 
<p>在生产环境中排除了使用docker attach命令进入容器之后，相信大家第一个想到的就是ssh。</p> 
<p>在镜像（或容器）中安装SSH Server，这样就能保证多人进入。</p> 
<p>容器且相互之间不受干扰了，相信大家在当前的生产环境中（没有使用Docker的情况）也是这样做的。</p> 
<p>但是使用了Docker容器之后不建议使用ssh进入到Docker容器内。</p> 
<h4><a id="3nsenterDocker_1025"></a>方式3：使用nsenter进入Docker容器</h4> 
<p>在上面两种方式都不适合的情况下，还有一种比较方便的方法，即使用nsenter进入Docker容器。</p> 
<h5><a id="1nsenter_1029"></a>1、什么是nsenter？</h5> 
<blockquote> 
 <p><strong>nsenter</strong>命令是一个可以在<strong>指定进程的命令空间下运行指定程序的命令</strong>。它位于<strong>util-linux</strong>包中。</p> 
 <p>util-linux 是一个开放源码的软件包，是一个对任何 Linux 系统的基本工具套件。含有一些标准 Unix 工具，如 login。<br> util-linux 软件包包含许多工具。其中比较重要的是加载、卸载、格式化、分区和管理硬盘驱动器，打开 tty 端口和得到内核消息。</p> 
</blockquote> 
<p>nsenter用途 ？</p> 
<blockquote> 
 <p><strong>一个最典型的用途就是进入容器的网络命令空间</strong>。相当多的容器为了轻量级，是不包含较为基础的命令的，比如说ip address，ping，telnet，ss，tcpdump等等命令，这就给调试容器网络带来相当大的困扰：只能通过docker inspect ContainerID命令获取到容器IP，以及无法测试和其他网络的连通性。这时就可以使用<strong>nsenter命令仅进入该容器的网络命名空间</strong>，<strong>使用宿主机的命令</strong>调试容器网络。</p> 
</blockquote> 
<p>在了解了什么是nsenter之后，系统默认将我们需要的nsenter安装到主机中， <code>nsenter --help</code> 查看帮助</p> 
<p><img src="https://images2.imgbox.com/3c/00/U3S8L3GO_o.png" alt=""></p> 
<p><code>nsenter --help</code> 查看帮助</p> 
<pre><code class="prism language-bash">$ nsenter --help

nsenter <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>program <span class="token punctuation">[</span>arguments<span class="token punctuation">]</span><span class="token punctuation">]</span>

options:
-t, --target pid：指定被进入命名空间的目标进程的pid
-m, --mount<span class="token punctuation">[</span><span class="token operator">=</span>file<span class="token punctuation">]</span>：进入mount命令空间。如果指定了file，则进入file的命令空间
-u, --uts<span class="token punctuation">[</span><span class="token operator">=</span>file<span class="token punctuation">]</span>：进入uts命令空间。如果指定了file，则进入file的命令空间
-i, --ipc<span class="token punctuation">[</span><span class="token operator">=</span>file<span class="token punctuation">]</span>：进入ipc命令空间。如果指定了file，则进入file的命令空间
-n, --net<span class="token punctuation">[</span><span class="token operator">=</span>file<span class="token punctuation">]</span>：进入net命令空间。如果指定了file，则进入file的命令空间
-p, --pid<span class="token punctuation">[</span><span class="token operator">=</span>file<span class="token punctuation">]</span>：进入pid命令空间。如果指定了file，则进入file的命令空间
-U, --user<span class="token punctuation">[</span><span class="token operator">=</span>file<span class="token punctuation">]</span>：进入user命令空间。如果指定了file，则进入file的命令空间
-G, --setgid gid：设置运行程序的gid
-S, --setuid uid：设置运行程序的uid
-r, --root<span class="token punctuation">[</span><span class="token operator">=</span>directory<span class="token punctuation">]</span>：设置根目录
-w, --wd<span class="token punctuation">[</span><span class="token operator">=</span>directory<span class="token punctuation">]</span>：设置工作目录

如果没有给出program，则默认执行<span class="token environment constant">$SHELL</span>。
</code></pre> 
<h5><a id="2nsenter_1073"></a>2、nsenter安装</h5> 
<p>如果没有安装的话，按下面步骤安装即可（注意是主机而非容器或镜像）</p> 
<p>具体的安装命令如下：</p> 
<pre><code class="prism language-bash"><span class="token function">wget</span> https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz
<span class="token function">tar</span> -xzvf util-linux-2.24.tar.gz
<span class="token builtin class-name">cd</span> util-linux-2.24/
./configure --without-ncurses
<span class="token function">make</span> nsenter
<span class="token function">sudo</span> <span class="token function">cp</span> nsenter /usr/local/bin
</code></pre> 
<h5><a id="3nsenter__1090"></a>3、nsenter的 使用</h5> 
<p>nsenter可以访问另一个进程的名称空间。</p> 
<p>所以为了连接到某个容器我们还需要获取该容器的第一个进程的PID。</p> 
<p>怎么办呢 ？ 可以使用<code>docker inspect</code>命令来拿到该 进程的 PID。</p> 
<p><code>docker inspect</code> 命令使用如下：</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> docker inspect --help
</code></pre> 
<p>inspect命令可以分层级显示一个镜像或容器的信息。</p> 
<p>比如我们当前有一个正在运行的容器</p> 
<p><img src="https://images2.imgbox.com/39/61/yiH3vEP3_o.png" alt=""></p> 
<p>可以使用<code>docker inspect</code>来查看该容器的详细信息。</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> docker inspect c1437f4bd302
</code></pre> 
<p><img src="https://images2.imgbox.com/fd/34/oDqngujv_o.png" alt=""></p> 
<p>由其该信息非常多，此处只截取了其中一部分进行展示。如果要显示该容器第一个进行的PID可以使用如下方式</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> docker inspect -f <span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span>.State.Pid<span class="token punctuation">}</span><span class="token punctuation">}</span>    c1437f4bd302
</code></pre> 
<p><img src="https://images2.imgbox.com/ce/f0/7l2kaOEt_o.png" alt=""></p> 
<p>在拿到该进程PID之后我们就可以使用nsenter命令访问该容器了。</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> nsenter --target <span class="token number">22299</span> --mount --uts --ipc --net --pid
</code></pre> 
<p>其中的 22299 即刚才拿到的进程的PID</p> 
<p>输入该命令便进入到容器中</p> 
<pre><code class="prism language-bash">$ nsenter --target 上面查到的进程id --mount --uts --ipc --net --pid
</code></pre> 
<p>解释nsenter指令中进程id之后的参数的含义：</p> 
<blockquote> 
 <p>–mount参数是进去到mount namespace中 (文件系统)<br> –uts参数是进入到uts namespace中 (主机名与域名)<br> –ipc参数是进入到System V IPC namaspace中 (信号量、消息队列和共享内容)<br> –net参数是进入到network namespace中 (网络设备、网络栈、端口)<br> –pid参数是进入到pid namespace中 (进程编号)<br> –user参数是进入到user namespace中 (用户和用户组)</p> 
</blockquote> 
<p>看看下面的例子，进入到容器的 network namespace中 ，看看IP地址，是不是变了。</p> 
<p><img src="https://images2.imgbox.com/92/2d/7aFKwTzY_o.png" alt=""></p> 
<h5><a id="docker_1163"></a>docker隔离应用应用涉及到的六大名称空间</h5> 
<h6><a id="1pid_ID_1165"></a>1、pid 命名空间(进程ID)</h6> 
<p>不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。</p> 
<p>所有的 LXC （Linux 容器）进程在 Docker 中的父进程为 Docker 进程，每个 LXC 进程具有不同的命名空间。</p> 
<p>同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。</p> 
<h6><a id="2net__1173"></a>2、net 命名空间(网络)</h6> 
<p>有了 pid 命名空间，每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。</p> 
<p>网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备，IP 地址，路由表，/proc/net 目录。这样每个容器的网络就能隔离开来。</p> 
<p>Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。</p> 
<h6><a id="3ipc__1181"></a>3、ipc 命名空间(进程间通信)</h6> 
<p>容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication - IPC)， 包括信号量、消息队列和共享内存等。</p> 
<p>然而同 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。</p> 
<h6><a id="4mnt__1187"></a>4、mnt 命名空间(挂载文件系统)</h6> 
<p>类似 chroot，将一个进程放到一个特定的目录执行。</p> 
<p>mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。</p> 
<p>同 chroot 不同，每个命名空间中的容器在 /proc/mounts 的信息只包含所在命名空间的 mount point。</p> 
<h6><a id="5UTS__1195"></a>5、UTS 命名空间(主机名/域名)</h6> 
<p>UTS(“UNIX Time-sharing System”) 命名空间允许每个容器拥有独立的 hostname 和 domain name， 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。</p> 
<h6><a id="6user__1199"></a>6、user 命名空间(用户)</h6> 
<p>每个容器可以有不同的用户和组 id， 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。</p> 
<h4><a id="nsenterdocker_1203"></a>nsenter查看docker的连接</h4> 
<p>由于使用DOCKER的时候，ESTABLISHED连接不会出现在netstat中，在运行中的docker容器中列出打开的套接字的方法</p> 
<p>查看连接：</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> docker inspect -f <span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span>.State.Pid<span class="token punctuation">}</span><span class="token punctuation">}</span>    e9eaef999da9

$ <span class="token function">sudo</span> nsenter -t  <span class="token number">3473</span>  -n <span class="token function">netstat</span> <span class="token operator">|</span> <span class="token function">grep</span> ESTABLISHED    
</code></pre> 
<p><img src="https://images2.imgbox.com/cf/65/DEXd4408_o.png" alt=""></p> 
<h4><a id="4docker_execDocker_1219"></a>方式4：使用docker exec进入Docker容器</h4> 
<p>除了上面几种做法之外，docker在1.3.X版本之后还提供了一个新的命令exec用于进入容器，这种方式相对更简单一些，下面我们来看一下该命令的使用：</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> docker <span class="token builtin class-name">exec</span> --help
</code></pre> 
<p><img src="https://images2.imgbox.com/bd/e2/7FVc74Tp_o.png" alt=""></p> 
<p>接下来我们使用该命令进入一个已经在运行的容器</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> docker <span class="token function">ps</span>  
<span class="token function">sudo</span> docker <span class="token builtin class-name">exec</span> -it 容器id  /bin/bash  
</code></pre> 
<p><img src="https://images2.imgbox.com/90/7d/qwE2qkoT_o.png" alt=""></p> 
<h4><a id="_1242"></a>在容器内部和宿主机中查看容器中的进程信息</h4> 
<p>进入一个名称为 rmqbroker-ha-b 的容器，查看进程信息</p> 
<pre><code class="prism language-bash">docker <span class="token builtin class-name">exec</span> -it rmqbroker-ha-b  /bin/bash   <span class="token function">ps</span> -ef
</code></pre> 
<p>结果如下：</p> 
<p><img src="https://images2.imgbox.com/f6/06/gp3V23Mv_o.png" alt=""></p> 
<p>我们可以使用<code>docker exec</code>命令进入容器PID名空间，并执行应用。</p> 
<p>通过<code>ps -ef</code>命令，可以看到每个 rmqbroker-ha-b 容器都包含一个PID为1的进程，<br> 容器的启动进程是 “sh mqbroker -c /opt/rocketmq…”，具有特殊意义。</p> 
<p>利用<code>docker top</code>命令，可以让我们从宿主机操作系统中看到容器的进程信息。</p> 
<p><img src="https://images2.imgbox.com/3c/58/TsfnuoDY_o.png" alt=""></p> 
<p>“sh mqbroker -c /opt/rocketmq…” 这个命令的进程，在 容器里边是1 ，在容器外部 3473</p> 
<h5><a id="_1270"></a>查看其父进程信息</h5> 
<p><code>ps -ef | grep 3401</code></p> 
<p><img src="https://images2.imgbox.com/a6/c8/Hjqnlmw9_o.png" alt=""></p> 
<pre><code class="prism language-bash">root        <span class="token number">3401</span>       <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">12</span>:06 ?        00:00:00 /usr/bin/containerd-shim-runc-v2 -namespace moby -id e9eaef999da9183b9be0b3239881bc6b9c2070f13057c322dfed3d072820e962 -address /run/containerd/containerd.sock
<span class="token number">3000</span>        <span class="token number">3473</span>    <span class="token number">3401</span>  <span class="token number">0</span> <span class="token number">12</span>:06 ?        00:00:00 <span class="token function">sh</span> mqbroker -c /opt/rocketmq-4.6.0/conf/broker.conf <span class="token assign-left variable">autoCreateTopicEnable</span><span class="token operator">=</span>true <span class="token operator">&amp;</span>
root       <span class="token number">26491</span>   <span class="token number">24084</span>  <span class="token number">0</span> <span class="token number">16</span>:16 pts/1    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto <span class="token number">3401</span>
</code></pre> 
<p>我们使用docker run 启用一个容器时，docker 会给每个容器都启动一个containerd-shim-runc-v2 父进程，这个进程又启动了一个ttrpc server(类似grpc/httpserver), containerd 通过 ttrpc和containerd-shim-runc-v2 通信来管理容器</p> 
<p>从父亲进程可以看到：容器的本质是进程。</p> 
<p>containerd-shim-runc-v2 后面的参数：namespace用来做命名空间隔离，cgroup用来做资源限制。</p> 
<p>containerd-shim-runc-v2 进程很特殊，它们跑在一些特定的namespace和cgroup下。</p> 
<p>站在这些进程的角度看，它们会以为自己跑在一个独立的机器上，看不到其他进程，也看不到其他文件。</p> 
<p>这是其实是操作系统为它虚拟出来的一个独立的、隔离的环境，是假的。</p> 
<h5><a id="_1294"></a>查看子进程信息</h5> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-4-17-centos ~<span class="token punctuation">]</span><span class="token comment">#  ps aux | grep 27880</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/79/8b/CaIXpHP8_o.png" alt=""></p> 
<h5><a id="_1304"></a>总计三个命令</h5> 
<pre><code class="prism language-bash">docker <span class="token function">top</span>  rmqbroker-ha-b  <span class="token comment">#查看容器进程</span>

<span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">3401</span> <span class="token comment">#查看父进程</span>
<span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">3473</span>  <span class="token comment">#查看子进程(容器)</span>
</code></pre> 
<h3><a id="Docker_1315"></a>Docker本地镜像载入与载出</h3> 
<h4><a id="_1317"></a>两种办法</h4> 
<ul><li>保存镜像（保存镜像载入后获得跟原镜像id相同的镜像）</li><li>保存容器（保存容器载入后获得跟原镜像id不同的镜像）</li></ul> 
<h4><a id="_1322"></a>拉取镜像</h4> 
<p>通过命令可以从镜像仓库中拉取镜像，默认从<a href="https://hub.docker.com/" rel="nofollow">Docker Hub</a> 获取。</p> 
<p>命令格式：</p> 
<pre><code class="prism language-bash">docker image pull <span class="token operator">&lt;</span>repository<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>tag<span class="token operator">&gt;</span>

docker image pull   rancher/rke-tools:v0.1.52

<span class="token punctuation">[</span>rancher/rke-tools:v0.1.52
</code></pre> 
<h4><a id="_1336"></a>保存镜像</h4> 
<ul><li>docker save 镜像id -o /home/mysql.tar</li><li>docker save 镜像id &gt; /home/mysql.tar</li></ul> 
<pre><code class="prism language-bash">docker save  docker.io/rancher/rancher-agent   -o /home/rancher-agent .tar

docker save  f29ece87a195  -o /home/rancher-agent.tar

docker save  docker.io/rancher/rke-tools   -o /home/rke-tools-v0.1.52.tar
</code></pre> 
<h4><a id="_1353"></a>载入镜像</h4> 
<ul><li><code>docker load -i mysql.tar</code></li></ul> 
<pre><code class="prism language-bash">docker load -i /usr/local/rancher-v2.3.5.tar

docker load -i /usr/local/rancher-agent.tar

docker  inspect  f29ece87a1954772accb8a2332ee8c3fe460697e3f102ffbdc76eb9bc4f4f1d0

docker load -i /usr/local/rke-tools-v0.1.52.tar
</code></pre> 
<pre><code class="prism language-bash">docker load -i mysql.tar

<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker load -i /usr/local/rancher-v2.3.5.tar</span>
43c67172d1d1: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>  <span class="token number">65</span>.57MB/65.57MB
21ec61b65b20: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>  <span class="token number">991</span>.2kB/991.2kB
1d0dfb259f6a: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>  <span class="token number">15</span>.87kB/15.87kB
f55aa0bd26b8: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>  <span class="token number">3</span>.072kB/3.072kB
e0af200d6950: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>  <span class="token number">126</span>.1MB/126.1MB
088ed892f9ad: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>  <span class="token number">6</span>.656kB/6.656kB
6aa3142b4130: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>   <span class="token number">34</span>.5MB/34.5MB
f4e84c05ab29: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>  <span class="token number">70</span>.41MB/70.41MB
11a6e4332b53: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>  <span class="token number">224</span>.8MB/224.8MB
46d1ac556da7: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>  <span class="token number">3</span>.072kB/3.072kB
0f8b224a5802: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>  <span class="token number">57</span>.87MB/57.87MB
519eba7d586a: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>  <span class="token number">99</span>.58MB/99.58MB
3f8bb7c0c150: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>  <span class="token number">4</span>.608kB/4.608kB
c22c9a5a8211: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>  <span class="token number">3</span>.072kB/3.072kB
Loaded image: rancher/rancher:v2.3.5
</code></pre> 
<h4><a id="tag_1394"></a>打个tag</h4> 
<pre><code class="prism language-bash">docker tag  f29ece87a1954772accb8a2332ee8c3fe460697e3f102ffbdc76eb9bc4f4f1d0 rancher/rancher-agent:v2.3.5

docker tag  f29ece87a195   <span class="token number">172.18</span>.8.104/rancher/rancher-agent:v2.3.5

docker tag 6e421b8753a2  <span class="token number">172.18</span>.8.104/rancher/rke-tools:v0.1.52 

83fe4871cf67
</code></pre> 
<pre><code class="prism language-bash">docker rmi image_name

docker rmi  -f  <span class="token number">172.18</span>.8.104/rancher/coredns-coredns:1.6.5 

docker rmi   -f   <span class="token number">172.18</span>.8.104/rancher/coredns-coredns:v3.4.3-rancher1

docker rmi hub.doge.net/ubuntu:latest
</code></pre> 
<h4><a id="_1420"></a>保存镜像</h4> 
<ul><li>docker export 镜像id -o /home/mysql-export.tar</li><li>docker save 镜像tag -o /home/mysql-export.tar</li></ul> 
<h4><a id="_1425"></a>载入镜像</h4> 
<ul><li>docker import mysql-export.tar</li></ul> 
<h3><a id="Harbor_1431"></a>Harbor私有镜像仓库</h3> 
<p>Harbor （港口，港湾）是一个用于存储和分发Docker镜像的企业级Registry服务器。</p> 
<p>除了Harbor这个私有镜像仓库之外，还有Docker官方提供的Registry。</p> 
<p>相对Registry，Harbor具有很多优势：</p> 
<ol><li>提供分层传输机制，优化网络传输 Docker镜像是是分层的，而如果每次传输都使用全量文件(所以用FTP的方式并不适合)，显然不经济。必须提供识别分层传输的机制，以层的UUID为标识，确定传输的对象。</li><li>提供WEB界面，优化用户体验 只用镜像的名字来进行上传下载显然很不方便，需要有一个用户界面可以支持登陆、搜索功能，包括区分公有、私有镜像。</li><li>支持水平扩展集群 当有用户对镜像的上传下载操作集中在某服务器，需要对相应的访问压力作分解。</li><li>良好的安全机制 企业中的开发团队有很多不同的职位，对于不同的职位人员，分配不同的权限，具有更好的安全性。</li></ol> 
<h4><a id="Harbor_1444"></a>Harbor安装</h4> 
<p>harbor是用过docker-compose 编排的。</p> 
<p>所以 安装的过程中，会检查docker、docker-compose 进程，确保提前启动。</p> 
<p>这些，在咱们的虚拟机里边，docker、docker-compose 进程已经预装好了的。</p> 
<p>查看docker是否安装成功；</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@centos1 ~<span class="token punctuation">]</span><span class="token comment"># docker -v</span>
Docker version <span class="token number">20.10</span>.23, build <span class="token number">7155243</span>
</code></pre> 
<p>查看docker-compose是否安装成功；</p> 
<pre><code class="prism language-bash">docker-compose -version

<span class="token punctuation">[</span>root@centos1 ~<span class="token punctuation">]</span><span class="token comment"># docker-compose -version</span>
docker-compose version <span class="token number">1.25</span>.1, build a82fef07
<span class="token punctuation">[</span>root@centos1 ~<span class="token punctuation">]</span><span class="token comment">#</span>
</code></pre> 
<p>接下来，开始安装harbor</p> 
<h5><a id="1_Harbor_1473"></a>1、下载 Harbor的压缩包</h5> 
<pre><code>https://github.com/goharbor/harbor/releases
</code></pre> 
<p>咱们用这个包： harbor-offline-installer-v2.3.2.tgz</p> 
<p>咱们的学习网盘当中，尼恩已经上传了哈</p> 
<h5><a id="2_1483"></a>2、上传压缩包到虚拟机，并解压</h5> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@centos1 ~<span class="token punctuation">]</span><span class="token comment"># cd /usr/local/</span>
<span class="token punctuation">[</span>root@centos1 local<span class="token punctuation">]</span><span class="token comment"># mkdir harber</span>
<span class="token punctuation">[</span>root@centos1 local<span class="token punctuation">]</span><span class="token comment"># cd harber/</span>

<span class="token function">tar</span> -zxvf harbor-offline-installer-v2.3.2.tgz
</code></pre> 
<p><img src="https://images2.imgbox.com/b2/34/FZLZCDON_o.png" alt=""></p> 
<h5><a id="3harbor_1497"></a>3、创建harbor访问域名证书</h5> 
<p>OpenSSL是一个强大的安全套接字层密码库，Apache使用它加密HTTPS，OpenSSH使用它加密SSH，但是，你不应该只将其作为一个库来使用，它还是一个多用途的、跨平台的密码工具。</p> 
<p>参考：</p> 
<p><a href="https://goharbor.io/docs/2.6.0/install-config/configure-https/" rel="nofollow">Harbor docs | Configure HTTPS Access to Harbor (goharbor.io)</a></p> 
<pre><code class="prism language-bash"><span class="token function">mkdir</span> -p /usr/local/harbor/ssl <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> /usr/local/harbor/ssl
openssl genrsa -out tls.key <span class="token number">4096</span>
      
 openssl req -x509 -new -nodes -sha512 -days <span class="token number">3650</span> <span class="token punctuation">\</span>
 -subj <span class="token string">"/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=cdh1"</span> <span class="token punctuation">\</span>
 -key tls.key <span class="token punctuation">\</span>
 -out tls.cert
</code></pre> 
<ul><li>第一步创建ssl文件夹用来存储证书，</li><li>第二步生成key (私钥)，</li><li>最后一步使用生成的key自签证书。自签证书包含公钥</li></ul> 
<p>days后面是你自签证书的有效时间可以自行修改。</p> 
<p>'CN='后面就写你自己的IP地址或者你自己的域名。</p> 
<p>生成完成之后显示如下</p> 
<p><img src="https://images2.imgbox.com/ec/62/sazT9b6a_o.png" alt=""></p> 
<h5><a id="4harbor_1533"></a>4、配置harbor</h5> 
<p>修改Harbor的配置（harbor.yml）；<br> 修改主机地址：hostname: 192.168.56.121；<br> 修改端口（默认端口80）：port: 85；</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> /usr/local/harbor/harbor    <span class="token comment">#进入到harbor目录</span>
<span class="token function">cp</span>   harbor.yml.tmpl    harbor.yml
<span class="token function">vim</span> harbor.yml   <span class="token comment">#编辑harbor的配置文件</span>

<span class="token comment">#修改以下内容</span>
<span class="token function">hostname</span> <span class="token operator">=</span> <span class="token number">192.168</span>.56.121  <span class="token comment">#修改harbor的启动ip，这里需要依据系统ip设置</span>
port: <span class="token number">85</span> <span class="token comment">#harbor的端口,有两个端口,http协议(80)和https协议(443)</span>
harbor_admin_password <span class="token operator">=</span> <span class="token number">123456</span>   <span class="token comment">#修改harbor的admin用户的密码</span>
data_volume: /harbor/data <span class="token comment">#修改harbor存储位置</span>
</code></pre> 
<p>故harbor.yml中certificate填写为如上tls.cert的文件目录地址：<code>/usr/local/harbor/ssl/tls.cert</code></p> 
<p>故harbor.yml中private_key填写为如上tls.key的文件目录地址：<code>/usr/local/harbor/ssl/tls.key</code></p> 
<p><img src="https://images2.imgbox.com/61/55/2dWcLSjj_o.png" alt=""></p> 
<h5><a id="5prepare__1565"></a>5、./prepare 准备</h5> 
<p>启动之前需要使用<code>./prepare</code>命令进行一些预置工作，下载相关依赖；</p> 
<p>此时需要开启docker服务，不然会报错；</p> 
<p>这个过程可能有点长，需要耐心等待；</p> 
<pre><code class="prism language-bash">/prepare
</code></pre> 
<p><img src="https://images2.imgbox.com/9e/97/RUTNDIgi_o.png" alt=""></p> 
<h5><a id="6installsh_1583"></a>6、./install.sh</h5> 
<p>准备工作完成后，使用<code>./install.sh</code>进行Harbor的安装;<br> 这个过程会持续一段时间，耐心等待；</p> 
<pre><code class="prism language-bash">./install.sh
</code></pre> 
<p><img src="https://images2.imgbox.com/e3/81/mlHmYGZQ_o.png" alt="Harbor安装"></p> 
<h6><a id="_1598"></a>访问</h6> 
<p>http://cdh1:85/</p> 
<p>登录<br> 默认登录名：admin；<br> 默认登录密码：Harbor12345； 被尼恩改成了 12345<br> 具体可以查看harbor.yml；</p> 
<p><img src="https://images2.imgbox.com/40/41/GyD07fmq_o.png" alt=""></p> 
<h5><a id="7_Harbor_1613"></a>7、停止或者重启 Harbor</h5> 
<p><code>cd /usr/local/harber/harbor/</code></p> 
<pre><code class="prism language-bash">docker-compose up -d 启动
docker-compose start 启动
docker-compose stop 停止
docker-compose restart 重新启动
</code></pre> 
<p><img src="https://images2.imgbox.com/33/23/IFXhEswV_o.png" alt=""></p> 
<h4><a id="dockerdockerharbor_1630"></a>修改docker配置文件，使docker支持harbor</h4> 
<p>编辑客户机/etc/docker/daemon.json文件</p> 
<p><code>{"insecure-registries":["192.168.56.121:85"]}</code></p> 
<p>重启客户机docker服务</p> 
<p><code>systemctl restart docker #或者(service docker restart) </code></p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@centos1 harbor<span class="token punctuation">]</span><span class="token comment"># cat  /etc/docker/daemon.json</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token string">"https://bjtzu1jb.mirror.aliyuncs.com"</span>,
    <span class="token string">"http://f1361db2.m.daocloud.io"</span>,
    <span class="token string">"https://hub-mirror.c.163.com"</span>,
    <span class="token string">"https://docker.mirrors.ustc.edu.cn"</span>,
    <span class="token string">"https://reg-mirror.qiniu.com"</span>,
    <span class="token string">"https://dockerhub.azk8s.cn"</span>,
    <span class="token string">"https://registry.docker-cn.com"</span>
  <span class="token punctuation">]</span>,
  <span class="token string">"insecure-registries"</span>:<span class="token punctuation">[</span><span class="token string">"192.168.56.121:85"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@centos1 ssh<span class="token punctuation">]</span><span class="token comment"># cat /etc/docker/daemon.json</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token string">"https://bjtzu1jb.mirror.aliyuncs.com"</span>,
    <span class="token string">"http://f1361db2.m.daocloud.io"</span>,
    <span class="token string">"https://hub-mirror.c.163.com"</span>,
    <span class="token string">"https://docker.mirrors.ustc.edu.cn"</span>,
    <span class="token string">"https://reg-mirror.qiniu.com"</span>,
    <span class="token string">"https://dockerhub.azk8s.cn"</span>,
    <span class="token string">"https://registry.docker-cn.com"</span>,
   <span class="token string">"https://cdh1"</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="Harbor_1678"></a>Harbor使用</h4> 
<p>可以 尝试上传镜像到 Harbor。</p> 
<p>如果是另一台机器，需要添加本地hosts</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'192.168.56.121 cdh'</span> <span class="token operator">&gt;&gt;</span> /etc/hosts
</code></pre> 
<p>因为我们的证书是自签的是不受到其他机器信任的，所以我们要在 harber的客户端机器上放上我们的证书，才能拉取镜像。</p> 
<p>使用下面的代码，在要使用 harber的客户端机器 上保存证书，其中 cdh1 部分使用你自己的域名或者是IP地址。</p> 
<pre><code class="prism language-bash"><span class="token function">mkdir</span> -p /etc/docker/certs.d/cdh1
<span class="token function">scp</span> <span class="token number">192.168</span>.56.122:/usr/local/harbor/ssl/tls.cert /etc/docker/certs.d/cdh1/
</code></pre> 
<p>本地docker 登录的话</p> 
<pre><code class="prism language-bash"><span class="token function">mkdir</span> -p /etc/docker/certs.d/cdh1
<span class="token function">cp</span> /usr/local/harbor/ssl/tls.cert /etc/docker/certs.d/cdh1/ca.crt

<span class="token function">mkdir</span> -p /etc/docker/certs.d/192.168.56.121
</code></pre> 
<p>然后使用如下语句登录harbor，如果没有使用80端口一定要用IP地址加上你的端口号，冒号之后填端口号，查看自己harbor.yml里http或https里的端口详情。</p> 
<pre><code class="prism language-bash">docker login cdh1
</code></pre> 
<p>报错 证书问题， 证书不含SAN</p> 
<h5><a id="SAN_1718"></a>什么是含有SAN的证书</h5> 
<p>docker 的新版本使用**golang 1.15+**版本上，老的x509 证书不行了</p> 
<p>SAN(Subject Alternative Name) 是 SSL 标准 x509 中定义的一个扩展。使用了 SAN 字段的 SSL 证书，可以扩展此证书支持的域名，使得一个证书可以支持多个不同域名的解析。</p> 
<p>subjectAltName 在 RFC 5280 4.2.1.6.中提供了详细的说明，subjectAltName 是 X.509 version 3 的一个扩展项，该扩展项用于标记和界定证书持有者的身份。</p> 
<p>在 X.509 格式的证书中，一般使用 <code>Issuer</code> 项标记证书的颁发者信息，该项必须是一个非空的 Distinguished Name 名称。除此之外还可以使用扩展项 <code>issuerAltName</code> 来标记颁发者的其他名称，这是一个非关键的扩展项。</p> 
<p>对于证书持有者，一般使用 <code>Subject</code> 项标记，并使用 <code>subjectAltName</code> 扩展项提供更详细的持有者身份信息。 <code>subjectAltName</code> 全称为 Subject Alternative Name，缩写为 SAN。它可以包括一个或者多个的电子邮件地址，域名，IP地址和 URI 等，详细定义如下：</p> 
<pre><code class="prism language-bash">SubjectAltName ::<span class="token operator">=</span> GeneralNames
   GeneralNames ::<span class="token operator">=</span> SEQUENCE SIZE <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">..</span>MAX<span class="token punctuation">)</span> OF GeneralName

   GeneralName ::<span class="token operator">=</span> CHOICE <span class="token punctuation">{<!-- --></span>
        otherName                       <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>     OtherName,
        rfc822Name                      <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>     IA5String,
        dNSName                         <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>     IA5String,
        x400Address                     <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>     ORAddress,
        directoryName                   <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span>     Name,
        ediPartyName                    <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span>     EDIPartyName,
        uniformResourceIdentifier       <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span>     IA5String,
        iPAddress                       <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span>     OCTET STRING,
        registeredID                    <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span>     OBJECT IDENTIFIER 
    <span class="token punctuation">}</span>
</code></pre> 
<p>当颁发的证书不存在 <code>Subject</code> 项的时候，证书必须包含扩展项 <code>subjectAltName</code>，并且标记为关键（critical）的。当颁发的证书存在 <code>Subject</code> 项的时候，必须将扩展项 <code>subjectAltName</code> 标记为非关键（no-critical）的。注意：用于颁发证书的 CA 证书是必须包含 <code>Subject</code> 项的。</p> 
<p>根据 <a href="https://www.ietf.org/rfc/rfc6125.txt" rel="nofollow">RFC 6125</a> 中的规定，当一个网站使用证书标记自己的身份时，如果证书中包含 subjectAltName，在识别证书持有者时会忽略 Subject 子项，而是通过 subjectAltName 来识别证书持有者。</p> 
<p>在早期颁发的证书中一般通过 Subject 的 CommonName 来识别持有者的身份，不包含 subjectAltName 扩展项。</p> 
<p>这会导致最新版本的浏览器Chrome、Firefox 等在通过 HTTPS 访问 web 网站时，触发 NET::ERR_CERT_COMMON_NAME_INVALID 错误。</p> 
<h4><a id="SSL_1759"></a>SSL证书格式</h4> 
<p>证书主要的文件类型和协议有：PEM、DER、PFX、JKS、KDB、CER、KEY、CSR、CRT、CRL 、OCSP、SCEP等。</p> 
<h5><a id="1_KEY_1763"></a>1. KEY</h5> 
<p>一般指PEM格式的私钥文件。</p> 
<h5><a id="2_CRT_1767"></a>2. CRT</h5> 
<p>证书文件。可以是PEM格式。</p> 
<h5><a id="3_PEM_1771"></a>3. PEM</h5> 
<p>PEM格式的证书文件（*.pem）由Base64编码的二进制内容和开头行（-----BEGIN CERTIFICATE-----）、结束行（-----END CERTIFICATE-----）组成，支持使用notepad++等文本编辑器打开。对于CER、CRT格式的证书，您可通过直接修改证书文件扩展名的方式将其转换成PEM格式。例如，将server.crt证书文件直接重命名为server.pem。</p> 
<h5><a id="4_CSR_1775"></a>4. CSR</h5> 
<p>证书请求文件(Certificate Signing Request)。生成 X509 数字证书前,一般先由用户提交证书申请文件,然后由 CA 来签发证书。大致过程如下(X509 证书申请的格式标准为 pkcs10 和 rfc2314):</p> 
<ol><li>用户生成自己的公私钥对;</li><li>构造自己的证书申请文件,符合 PKCS10 标准。该文件主要包括了用户信息、公钥以及一些可选的属性信息,并用自己的私钥给该内容签名;</li><li>用户将证书申请文件提交给 CA;</li><li>CA 验证签名,提取用户信息,并加上其他信息(比如颁发者等信息),用 CA 的私钥签发数字证书;</li><li>说明:数字证书(如x.509)是将用户(或其他实体)身份与公钥绑定的信息载体。一个合法的数字证书不仅要符合 X509 格式规范,还必须有 CA 的签名。用户不仅有自己的数字证书,还必须有对应的私钥。X509v3 数字证书主要包含的内容有:证书版本、证书序列号、签名算法、颁发者信息、有效时间、持有者信息、公钥信息、颁发者 ID、持有者 ID 和扩展项。</li></ol> 
<h5><a id="5_DER_1785"></a>5. DER</h5> 
<p>辨别编码规则 (DER) 可包含所有私钥、公钥和证书。它是大多数浏览器的缺省格式，并按 ASN1 DER 格式存储。它是无报头的 － PEM 是用文本报头包围的 DER。</p> 
<h5><a id="6_PFX_1789"></a>6. PFX</h5> 
<p>公钥加密标准 12 (PKCS12) 可包含所有私钥、公钥和证书。其以二进制格式存储，也称为 PFX 文件。通常可以将Apache/OpenSSL使用的“KEY文件 + CRT文件”格式合并转换为标准的PFX文件，你可以将PFX文件格式导入到微软IIS 5/6、微软ISA、微软Exchange Server等软件。转换时需要输入PFX文件的加密密码。</p> 
<h5><a id="7_JKS_1793"></a>7. JKS</h5> 
<p>通常可以将Apache/OpenSSL使用的“KEY文件 + CRT文件”格式”转换为标准的Java Key Store(JKS)文件。JKS文件格式被广泛的应用在基于JAVA的WEB服务器、应用服务器、中间件。你可以将JKS文件导入到TOMCAT、 WEBLOGIC 等软件。</p> 
<h5><a id="8_KDB_1797"></a>8. KDB</h5> 
<p>通常可以将Apache/OpenSSL使用的“KEY文件 + CRT文件”格式转换为标准的IBM KDB文件。KDB文件格式被广泛的应用在IBM的WEB服务器、应用服务器、中间件。你可以将KDB文件导入到IBM HTTP Server、IBM Websphere 等软件。</p> 
<h5><a id="9_OCSP_1801"></a>9. OCSP</h5> 
<p>在线证书状态协议(OCSP,Online Certificate Status Protocol,rfc2560)用于实时表明证书状态。OCSP 客户端通过查询 OCSP 服务来确定一个证书的状态,可以提供给使用者一个或多个数字证书的有效性资料，它建立一个可实时响应的机制，让用户可以实时确认每一张证书的有效性，解决由CRL引发的安全问题。。OCSP 可以通过 HTTP协议来实现。rfc2560 定义了 OCSP 客户端和服务端的消息格式。</p> 
<h5><a id="10_CER_1805"></a>10. CER</h5> 
<p>一般指使用DER格式的证书。</p> 
<h5><a id="11_CRL_1809"></a>11. CRL</h5> 
<p>证书吊销列表 (Certification Revocation List) 是一种包含撤销的证书列表的签名数据结构。CRL 是证书撤销状态的公布形式,CRL 就像信用卡的黑名单,用于公布某些数字证书不再有效。CRL 是一种离线的证书状态信息。它以一定的周期进行更新。CRL 可以分为完全 CRL和增量 CRL。在完全 CRL 中包含了所有的被撤销证书信息,增量 CRL 由一系列的 CRL 来表明被撤销的证书信息,它每次发布的 CRL 是对前面发布 CRL 的增量扩充。基本的 CRL 信息有:被撤销证书序列号、撤销时间、撤销原因、签名者以及 CRL 签名等信息。基于 CRL 的验证是一种不严格的证书认证。CRL 能证明在 CRL 中被撤销的证书是无效的。但是,它不能给出不在 CRL 中的证书的状态。如果执行严格的认证,需要采用在线方式进行认证,即 OCSP 认证。一般是由CA签名的一组电子文档，包括了被废除证书的唯一标识（证书序列号），CRL用来列出已经过期或废除的数字证书。它每隔一段时间就会更新，因此必须定期下载该清单，才会取得最新信息。</p> 
<h5><a id="12_SCEP_1813"></a>12. SCEP</h5> 
<p>简单证书注册协议。基于文件的证书登记方式需要从您的本地计算机将文本文件复制和粘贴到证书发布中心，和从证书发布中心复制和粘贴到您的本地计算机。 SCEP可以自动处理这个过程但是CRLs仍然需要手工的在本地计算机和CA发布中心之间进行复制和粘贴。</p> 
<h5><a id="13_PKCS7_1817"></a>13. PKCS7</h5> 
<p>加密消息语法(pkcs7),是各种消息存放的格式标准。这些消息包括:数据、签名数据、数字信封、签名数字信封、摘要数据和加密数据。</p> 
<h5><a id="14_PKCS12_1821"></a>14. PKCS12</h5> 
<p>– pkcs12 (个人数字证书标准)用于存放用户证书、crl、用户私钥以及证书链。pkcs12 中的私钥是加密存放的。</p> 
<h4><a id="SAN_1829"></a>生成含有SAN的证书</h4> 
<ul><li>使用OPENssl命令行来生成KEY+CSR2个文件，</li><li>使用KEYTOOL来生成JKS和CSR文件</li></ul> 
<h5><a id="1CA_1834"></a>1、生成CA证书私钥</h5> 
<p>openssl genrsa -out ca.key 4096</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@docker-compose-harbor CA<span class="token punctuation">]</span><span class="token comment"># openssl genrsa -out ca.key 4096</span>
Generating RSA private key, <span class="token number">4096</span> bit long modulus
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.++
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>++
e is <span class="token number">65537</span> <span class="token punctuation">(</span>0x10001<span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@docker-compose-harbor CA<span class="token punctuation">]</span><span class="token comment">#</span>
<span class="token punctuation">[</span>root@docker-compose-harbor CA<span class="token punctuation">]</span><span class="token comment">#</span>
<span class="token punctuation">[</span>root@docker-compose-harbor CA<span class="token punctuation">]</span><span class="token comment"># ls</span>
ca.key
<span class="token punctuation">[</span>root@docker-compose-harbor CA<span class="token punctuation">]</span><span class="token comment">#</span>
</code></pre> 
<h5><a id="2CA_1851"></a>2、生成CA证书</h5> 
<pre><code class="prism language-bash">openssl req -x509 -new -nodes -sha512 -days <span class="token number">3650</span> <span class="token punctuation">\</span>
-subj <span class="token string">"/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=cdh1"</span> <span class="token punctuation">\</span>
-key ca.key <span class="token punctuation">\</span>
-out ca.crt
</code></pre> 
<p>自签名的证书，不被浏览器信任，适合内部或者测试使用。</p> 
<h5><a id="3_1864"></a>3、生成服务器证书</h5> 
<p>生成私钥</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@docker-compose-harbor CA<span class="token punctuation">]</span><span class="token comment"># openssl genrsa -out cdh1.key 4096</span>
Generating RSA private key, <span class="token number">4096</span> bit long modulus
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.++
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.++
e is <span class="token number">65537</span> <span class="token punctuation">(</span>0x10001<span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@docker-compose-harbor CA<span class="token punctuation">]</span><span class="token comment">#</span>
<span class="token punctuation">[</span>root@docker-compose-harbor CA<span class="token punctuation">]</span><span class="token comment"># ll -h</span>
total 12K
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">3</span>.2K Jul <span class="token number">20</span> 04:52 cdh1.key
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">2</span>.0K Jul <span class="token number">20</span> 04:51 ca.crt
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">3</span>.2K Jul <span class="token number">20</span> 04:48 ca.key
<span class="token punctuation">[</span>root@docker-compose-harbor CA<span class="token punctuation">]</span><span class="token comment">#</span>
</code></pre> 
<h6><a id="CSR_1883"></a>生成证书签名请求（CSR）</h6> 
<p>制作过程中，系统会产生2个密钥，一个是私钥，存放在服务器上,一个是CSR文件公钥，需要ca签名。</p> 
<pre><code class="prism language-bash">openssl req -sha512 -new <span class="token punctuation">\</span>
-subj <span class="token string">"/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=cdh1"</span> <span class="token punctuation">\</span>
-key cdh1.key <span class="token punctuation">\</span>
-out cdh1.csr
</code></pre> 
<p>需要依次输入国家，地区，城市，组织，组织单位，Common Name和Email。</p> 
<p>其中Common Name，可以写自己的名字或者域名，如果要支持https，Common Name应该与域名保持一致，否则会引起浏览器警告。</p> 
<p>可以将证书发送给证书颁发机构（CA），CA验证过请求者的身份之后，会出具签名证书，需要花钱。</p> 
<p>另外，如果只是内部或者测试需求，也可以使用OpenSSL实现自签名。</p> 
<p>执行过程</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@docker-compose-harbor CA<span class="token punctuation">]</span><span class="token comment"># openssl req -sha512 -new \</span>
<span class="token operator">&gt;</span> -subj <span class="token string">"/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=cdh1"</span> <span class="token punctuation">\</span>
<span class="token operator">&gt;</span> -key cdh1.key <span class="token punctuation">\</span>
<span class="token operator">&gt;</span> -out cdh1.csr

<span class="token punctuation">[</span>root@docker-compose-harbor CA<span class="token punctuation">]</span><span class="token comment"># ll -h</span>
total 20K
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">1</span>.7K Jul <span class="token number">20</span> 04:59 cdh1.csr
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">3</span>.2K Jul <span class="token number">20</span> 04:52 cdh1.key
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">2</span>.0K Jul <span class="token number">20</span> 04:51 ca.crt
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">3</span>.2K Jul <span class="token number">20</span> 04:48 ca.key
<span class="token punctuation">[</span>root@docker-compose-harbor CA<span class="token punctuation">]</span><span class="token comment">#</span>
生成一个x509 v3扩展文件
<span class="token function">cat</span> <span class="token operator">&gt;</span> v3.ext <span class="token operator">&lt;&lt;-</span><span class="token string">EOF
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = IP:cdh1
EOF</span>
</code></pre> 
<h5><a id="4v3extHarborcdh1crt_1931"></a>4、使用该v3.ext文件为Harbor主机生成证书cdh1.crt</h5> 
<pre><code class="prism language-bash">openssl x509 -req -sha512 -days <span class="token number">3650</span> <span class="token punctuation">\</span>
-extfile v3.ext <span class="token punctuation">\</span>
-CA ca.crt -CAkey ca.key -CAcreateserial <span class="token punctuation">\</span>
-in cdh1.csr <span class="token punctuation">\</span>
-out cdh1.crt
</code></pre> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@docker-compose-harbor CA<span class="token punctuation">]</span><span class="token comment"># openssl x509 -req -sha512 -days 3650 \</span>
<span class="token operator">&gt;</span> -extfile v3.ext <span class="token punctuation">\</span>
<span class="token operator">&gt;</span> -CA ca.crt -CAkey ca.key -CAcreateserial <span class="token punctuation">\</span>
<span class="token operator">&gt;</span> -in cdh1.csr <span class="token punctuation">\</span>
<span class="token operator">&gt;</span> -out cdh1.crt
Signature ok
<span class="token assign-left variable">subject</span><span class="token operator">=</span>/C<span class="token operator">=</span>CN/ST<span class="token operator">=</span>Beijing/L<span class="token operator">=</span>Beijing/O<span class="token operator">=</span>example/OU<span class="token operator">=</span>Personal/CN<span class="token operator">=</span>cdh1
Getting CA Private Key
<span class="token punctuation">[</span>root@docker-compose-harbor CA<span class="token punctuation">]</span><span class="token comment">#</span>
</code></pre> 
<p>当服务端向 CA 机构申请证书的时候，CA 签发证书的过程：</p> 
<ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li></ul> 
<h5><a id="5cdh1crtcdh1certDocker_1967"></a>5、转换cdh1.crt为cdh1.cert，供Docker使用</h5> 
<p>转换证书格式</p> 
<p>Docker守护程序将.crt文件解释为CA证书，并将.cert文件解释为客户端证书</p> 
<pre><code class="prism language-bash">openssl x509 -inform PEM -in cdh1.crt -out cdh1.cert
</code></pre> 
<p>修改harbor.yml文件key路径</p> 
<p>修改对应的证书地址：</p> 
<ul><li><code>cdh1.cert</code> 的地址</li><li><code>cdh1.key</code> 的地址</li></ul> 
<p>故harbor.yml中certificate填写为如上cdh1.cert的文件目录地址：<code>/usr/local/harbor/ssl/cdh1.cert</code></p> 
<p>故harbor.yml中private_key填写为如上cdh1.key的文件目录地址：<code>/usr/local/harbor/ssl/cdh1.key</code></p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@docker-compose-harbor harbor<span class="token punctuation">]</span><span class="token comment"># egrep -v "^$|^#" harbor.yml |head -10</span>
hostname: cdh1
http:
<span class="token comment"># port for http, default is 80. If https enabled, this port will redirect to https port</span>
port: <span class="token number">80</span>
https:
<span class="token comment"># https port for harbor, default is 443</span>
port: <span class="token number">443</span>
<span class="token comment"># The path of cert and key files for nginx</span>
certificate: /opt/CA/harbor/cert/cdh1.crt
private_key: /opt/CA/harbor/cert/cdh1.key
<span class="token punctuation">[</span>root@docker-compose-harbor harbor<span class="token punctuation">]</span><span class="token comment">#</span>
</code></pre> 
<h5><a id="6prepareHTTPS_2011"></a>6、运行prepare脚本以启用HTTPS</h5> 
<p><code>./prepare</code></p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@docker-compose-harbor harbor<span class="token punctuation">]</span><span class="token comment"># ./prepare</span>
prepare base <span class="token function">dir</span> is <span class="token builtin class-name">set</span> to /opt/harbor/harbor
Generated configuration file: /config/portal/nginx.conf
Generated configuration file: /config/log/logrotate.conf
Generated configuration file: /config/log/rsyslog_docker.conf
Generated configuration file: /config/nginx/nginx.conf
Generated configuration file: /config/core/env
Generated configuration file: /config/core/app.conf

Clean up the input <span class="token function">dir</span>
<span class="token punctuation">[</span>root@docker-compose-harbor harbor<span class="token punctuation">]</span><span class="token comment">#</span>
</code></pre> 
<h5><a id="7installshharbor_2031"></a>7、运行install.sh脚本来启动harbor</h5> 
<p><code>./install.sh</code></p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@docker-compose-harbor harbor<span class="token punctuation">]</span><span class="token comment"># ./install.sh </span>
<span class="token punctuation">[</span>Step <span class="token number">0</span><span class="token punctuation">]</span>: checking <span class="token keyword">if</span> docker is installed <span class="token punctuation">..</span>.
Note: docker version: <span class="token number">20.10</span>.17
<span class="token punctuation">[</span>Step <span class="token number">1</span><span class="token punctuation">]</span>: checking docker-compose is installed <span class="token punctuation">..</span>.
Not
</code></pre> 
<h5><a id="_docker__2043"></a>证书复制到 docker 并且启动后登录</h5> 
<pre><code class="prism language-bash"><span class="token function">cp</span> /usr/local/harbor/ssl/cdh1.cert /etc/docker/certs.d/cdh1/ca.crt

systemctl daemon-reload <span class="token operator">&amp;&amp;</span> systemctl restart docker
</code></pre> 
<p><img src="https://images2.imgbox.com/9a/71/p1yi2mPE_o.png" alt=""></p> 
<h4><a id="hostname_push_2059"></a>hostname push失败</h4> 
<p>问题：</p> 
<p>push本地镜像到 harbor私服时，push 到 docker.io仓库去了</p> 
<p>原因：</p> 
<p>在配置insecure-registry时，docker 必须配置服务器的 FQDN或者IP地址.不能是服务器的hostname（比如harbor）</p> 
<p>尼恩配置的 是cdh1，推不上去。</p> 
<p>FQDN是什么意思？<br> FQDN（fully qualified domain name）完全限定域名，是互联网上特定计算机或主机的完整域名。</p> 
<p>FQDN 由两部分组成：主机名和域名。</p> 
<p>例如，假设邮件服务器的 FQDN 可能是 mail.chenweiliang.com 。<br> 主机名为mail，主机位于域名chenweiliang.com。<br> DNS（Domain Name System），负责将 FQDN 转换为 IP地址，是 Internet 上大多数应用程序的寻址方式。<br> FQDN：（Fully Qualified Domain Name）完全限定域名：同时包含主机名和域名的名称。 （通过符号“.”）</p> 
<h5><a id="_2085"></a>以下为解决方法：</h5> 
<p>配置harbor服务器的 <code>/etc/hosts</code>，将本地ip地址对应为一条FQDN记录，</p> 
<p>比如 <code>192.168.56.121 harbor.daemon.io</code></p> 
<p>停止harbor后，修改harbor配置 harbor.yml 文件，将 hostname 配置项改为 <code>harbor.daemon.io</code> (一个FQDN)，然后重新配置 harbor.</p> 
<p><code>docker-compose down -v</code></p> 
<p>生成配置文件</p> 
<p><code>./prepare</code></p> 
<p>启动habror</p> 
<p><code>docker-comp up -d</code></p> 
<p>（可以在另外一台能访问harbor服务器的机器上配置 hosts 记录为 FQDN，然后web访问 harbor检查是否能正常登陆.）</p> 
<p>重新配置 docker daemon 中的配置 registry-mirrors 和 insecure-registries 然后重启 docker.</p> 
<p>比如：</p> 
<p>编辑客户机<code>/etc/docker/daemon.json</code>文件</p> 
<p><code>{"insecure-registries":["http://harbor.daemon.io:85"]}</code></p> 
<p>重启客户机docker服务</p> 
<p><code>systemctl restart docker #或者(service docker restart) </code></p> 
<p>之后就能正常pull，并且push本地镜像到 harbor私服中.</p> 
<p>附上完整的：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token string">"https://bjtzu1jb.mirror.aliyuncs.com"</span>,
    <span class="token string">"http://f1361db2.m.daocloud.io"</span>,
    <span class="token string">"https://hub-mirror.c.163.com"</span>,
    <span class="token string">"https://docker.mirrors.ustc.edu.cn"</span>,
    <span class="token string">"https://reg-mirror.qiniu.com"</span>,
    <span class="token string">"https://dockerhub.azk8s.cn"</span>,
    <span class="token string">"https://registry.docker-cn.com"</span>,
    <span class="token string">"https://harbor.daemon.io"</span>
  <span class="token punctuation">]</span>,
  <span class="token string">"insecure-registries"</span>:<span class="token punctuation">[</span><span class="token string">"http://harbor.daemon.io:85"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="Harber_2143"></a>推送镜像到Harber</h4> 
<p><img src="https://images2.imgbox.com/b1/32/zKBOWbv3_o.png" alt=""></p> 
<h4><a id="Docker__2149"></a>Docker 推送命令</h4> 
<p>在项目中标记镜像：</p> 
<p><code>docker tag SOURCE_IMAGE[:TAG] harbor.daemon.io/demo/REPOSITORY[:TAG]</code></p> 
<pre><code class="prism language-bash">docker tag  nginx:latest  harbor.daemon.io/demo/nginx:latest
</code></pre> 
<p>推送镜像到当前项目：</p> 
<p><code>docker push harbor.daemon.io/demo/REPOSITORY[:TAG]</code></p> 
<pre><code class="prism language-bash">docker push harbor.daemon.io/demo/nginx:latest
</code></pre> 
<p>错误提升：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@centos1 harbor<span class="token punctuation">]</span><span class="token comment"># docker push harbor.daemon.io/demo/nginx:latest</span>
The push refers to repository <span class="token punctuation">[</span>harbor.daemon.io/demo/nginx<span class="token punctuation">]</span>
Get <span class="token string">"https://harbor.daemon.io/v2/"</span><span class="token builtin class-name">:</span> x509: certificate is valid <span class="token keyword">for</span> cdh1, not harbor.daemon.io
</code></pre> 
<h4><a id="_2177"></a>需要生成证书</h4> 
<pre><code class="prism language-bash">openssl req -x509 -new -nodes -sha512 -days <span class="token number">3650</span> <span class="token punctuation">\</span>
-subj <span class="token string">"/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=harbor.daemon.io"</span> <span class="token punctuation">\</span>
-key ca.key <span class="token punctuation">\</span>
-out ca.crt

openssl genrsa -out harbor.daemon.io.key <span class="token number">4096</span>

openssl req -sha512 -new <span class="token punctuation">\</span>
-subj <span class="token string">"/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=harbor.daemon.io"</span> <span class="token punctuation">\</span>
-key harbor.daemon.io.key <span class="token punctuation">\</span>
-out harbor.daemon.io.csr


生成一个x509 v3扩展文件
<span class="token function">cat</span> <span class="token operator">&gt;</span> harbor.daemon.io.v3.ext <span class="token operator">&lt;&lt;-</span><span class="token string">EOF
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = DNS:harbor.daemon.io
EOF</span>

openssl x509 -req -sha512 -days <span class="token number">3650</span> <span class="token punctuation">\</span>
-extfile harbor.daemon.io.v3.ext <span class="token punctuation">\</span>
-CA ca.crt -CAkey ca.key -CAcreateserial <span class="token punctuation">\</span>
-in harbor.daemon.io.csr <span class="token punctuation">\</span>
-out harbor.daemon.io.crt

openssl x509 -inform PEM -in harbor.daemon.io.crt -out harbor.daemon.io.cert
</code></pre> 
<p>harbor.yml中certificate填写为如上cdh1.cert的文件目录地址：</p> 
<p><code>/usr/local/harbor/ssl/harbor.daemon.io.cert</code></p> 
<p>harbor.yml中private_key填写为如上cdh1.key的文件目录地址：</p> 
<p><code>/usr/local/harbor/ssl/harbor.daemon.io.key</code></p> 
<pre><code class="prism language-bash"><span class="token function">mkdir</span> /etc/docker/certs.d/harbor.daemon.io

<span class="token function">cp</span> /usr/local/harbor/ssl/harbor.daemon.io.cert /etc/docker/certs.d/harbor.daemon.io/ca.crt

<span class="token function">cp</span> /usr/local/harbor/ssl/harbor.daemon.io.cert /etc/docker/certs.d/harbor.daemon.io/harbor.daemon.io.cert 

<span class="token function">cp</span> /usr/local/harbor/ssl/harbor.daemon.io.cert /etc/docker/certs.d/harbor.daemon.io/ca.crt


docker-compose down

prepare

systemctl restart docker 

docker-compose up -d

docker login  harbor.daemon.io
</code></pre> 
<h4><a id="_2244"></a>推送成功</h4> 
<p>推送镜像到当前项目：</p> 
<p><code>docker push harbor.daemon.io/demo/REPOSITORY[:TAG]</code></p> 
<pre><code class="prism language-bash">docker push harbor.daemon.io/demo/nginx:latest
</code></pre> 
<p><img src="https://images2.imgbox.com/9b/ec/xIkXL3CG_o.png" alt=""></p> 
<p>界面展示</p> 
<p>http://cdh1:85/</p> 
<p><img src="https://images2.imgbox.com/72/e4/51I7AGjc_o.png" alt=""></p> 
<h3><a id="Docker_Image_2270"></a>Docker Image概述</h3> 
<h4><a id="Image_2272"></a>什么是Image</h4> 
<ul><li>文件和meta data的集合(root filesystem)</li><li>分层的，并且每一层都可以添加改变删除文件，成为一个新的image</li><li>不同的image可以共享相同的layer</li><li>Image本身是read-only的</li></ul> 
<h4><a id="Image_2279"></a>Image的获取</h4> 
<ul><li>方式1：Build from Dockerfile</li><li>方式2：Pull from Registry</li></ul> 
<p>例如：输入命令 <code>sudo docker pull ubuntu:14.04</code>，则会从Registry中拉出Image，Registry类似于github的作用，默认都是从docker hub上面拉取，上面会有官方和第三方的版本</p> 
<p><img src="https://images2.imgbox.com/a6/c3/gwDktund_o.png" alt=""></p> 
<p>输入命令 sudo docker image ls则可以显示所拉去的Image</p> 
<p><img src="https://images2.imgbox.com/28/9c/c13SKLlU_o.png" alt=""></p> 
<h4><a id="Base_Image_2292"></a>如何做一个自己的Base Image</h4> 
<p>1.首先创建一个可以执行的程序，下面用一个C语言的hello程序做例子</p> 
<p><img src="https://images2.imgbox.com/39/dc/Bava7QYS_o.png" alt=""></p> 
<p>2.通过dockerfile把这个可执行文件打成一个Image<br> 我们在hellow文件当前目录下创建一个Dockerfile文件，如下：</p> 
<p><img src="https://images2.imgbox.com/95/72/k3HF5jVA_o.png" alt=""></p> 
<p>3.执行命令：<code>docker build -t yunduan/hello-world</code> . (<code>-t</code>表示指示表情，<code>"."</code>表示在当前路径下寻找dockerfile)，执行以后，出现如下界面表示执行成功。</p> 
<p><img src="https://images2.imgbox.com/19/d1/73R64xXV_o.png" alt=""></p> 
<p>4.查看image，则可以看到成功build了一个image，执行命令<code>docker history +[IMAGE ID]</code>则可以查看镜像的层级<br> 执行命令<code>docker run + [镜像标签名]</code>则可以生成一个container运行程序。</p> 
<p><img src="https://images2.imgbox.com/db/63/sQDtlBUj_o.png" alt=""></p> 
<h3><a id="Docker_2314"></a>构建自己的Docker镜像</h3> 
<ul><li>命令一：docker container commit（Create a new image from a container’s changes）</li></ul> 
<p>这个命令表示当你在容器中做出了改变之后，可以重新构建Image</p> 
<p><img src="https://images2.imgbox.com/ae/c5/LOjGREIN_o.png" alt=""></p> 
<p>通过这个例子可以看出，其就在centos镜像上重新构建了一层</p> 
<ul><li>命令二：docker image build(Build an image from a Dockerfile)</li></ul> 
<h4><a id="Dockerfile_2328"></a>Dockerfile语法</h4> 
<ul><li>FROM</li></ul> 
<p>原则：尽量使用官方的image作为base image！</p> 
<pre><code class="prism language-bash">FROM scratch <span class="token comment">#制作base image</span>
FROM centos  <span class="token comment">#使用base image</span>
FROM ubuntu：14.04
</code></pre> 
<ul><li>LABEL</li></ul> 
<p>原则：Metadata不可少！相当于代码的注释</p> 
<pre><code class="prism language-bash">LABEL <span class="token assign-left variable">maintainer</span><span class="token operator">=</span><span class="token string">"yunduan@gmail.com"</span>
LABEL <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token string">"1.0"</span>
LABEL <span class="token assign-left variable">description</span><span class="token operator">=</span><span class="token string">"This is description"</span>
</code></pre> 
<ul><li>RUN</li></ul> 
<p>作用：执行命令并创建新的Image Layer</p> 
<p>原则：为了美观，复杂的RUN请用反斜线换行！避免无用分层，合并多条命令成一行！</p> 
<pre><code class="prism language-bash">RUN yum update <span class="token operator">&amp;&amp;</span> yum <span class="token function">install</span> -y <span class="token function">vim</span> <span class="token punctuation">\</span>
     python-dev   <span class="token comment">#反斜线换行</span>
RUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y perl <span class="token punctuation">\</span>
    pwgen --no-install-recommends <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -rf <span class="token punctuation">\</span>
    /var/lib/apt/lists/*    <span class="token comment">#注意清理cache</span>
RUN /bin/bash -c <span class="token string">'source <span class="token environment constant">$HOME</span>/.bashrc;echo
<span class="token environment constant">$HOME</span>'</span>
</code></pre> 
<ul><li>WORKDIR</li></ul> 
<p>作用：设定当前目录，类似于cd</p> 
<p>原则：用WORKDIR，不要用RUN cd！尽量使用绝对目录</p> 
<pre><code class="prism language-bash">WORKDIR /root
WORKDIR /test  <span class="token comment">#如果没有会自动创建test目录</span>
WORKDIR demo
RUN <span class="token builtin class-name">pwd</span>        <span class="token comment">#输出结果应该是 /test/demo</span>
</code></pre> 
<ul><li>ADD and COPY</li></ul> 
<p>作用：把本地文件添加到Docker image里面</p> 
<p>原则：大部分情况，COPY优先于ADD！ADD除了COPY还有额外功能（解压）！添加远程文件/目录请使用curl或者wget！</p> 
<pre><code class="prism language-bash">ADD hello /
ADD test.tar.gz /   <span class="token comment">#添加到根目录并解压</span>
WORKDIR /root
ADD hello test/     <span class="token comment"># /root/test/hello</span>
WORKDIR /root
COPY hello test/
</code></pre> 
<ul><li>ENV</li></ul> 
<p>作用：设置一个环境变量，引用常量</p> 
<p>原则：尽量使用ENV增加可维护性！</p> 
<pre><code class="prism language-bash">ENV MYSQL_VERSION <span class="token number">5.6</span>    <span class="token comment"># 设置常量</span>
RUN <span class="token function">apt-get</span> <span class="token function">install</span> -y mysql-server<span class="token operator">=</span> <span class="token string">"<span class="token variable">${MYSQL_VERSION}</span>"</span> <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -rf /var/lib/apt/lists/*   <span class="token comment"># 引用常量</span>
</code></pre> 
<ul><li>VOLUME and EXPOSE (存储和网络)</li><li>CMD and ENTRYPOINT</li></ul> 
<p>CMD:设置容器启动后默认执行的命令和参数</p> 
<p>注释：1.容器启动时默认执行的命令 2.如果docker run指定了其他命令，CMD命令被忽略 3.如果定义了多个CMD，只有最后一个会执行</p> 
<p>ENTRYPOINT：设置容器启动时运行的命令</p> 
<p>注释：1.让容器以应用程序或者服务的形式运行 2.不会被忽略，一定会执行 3.最佳实践：写一个shell脚本作为entrypoint</p> 
<p>1.Shell格式</p> 
<pre><code class="prism language-bash">RUN <span class="token function">apt-get</span> <span class="token function">install</span> -y <span class="token function">vim</span>
CMD <span class="token builtin class-name">echo</span> <span class="token string">"hello docker"</span>
ENTRYPOINT <span class="token builtin class-name">echo</span> <span class="token string">"hello docker"</span>
</code></pre> 
<p>2.Exec格式</p> 
<pre><code class="prism language-bash">RUN <span class="token punctuation">[</span><span class="token string">"apt-get"</span>,<span class="token string">"install"</span>,<span class="token string">"-y"</span>,<span class="token string">"vim"</span><span class="token punctuation">]</span>
CMD <span class="token punctuation">[</span><span class="token string">" /bin/echo"</span> , <span class="token string">"hello docker"</span> <span class="token punctuation">]</span>
ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"/bin/echo"</span> , <span class="token string">"hello docker"</span><span class="token punctuation">]</span>
</code></pre> 
<p>3.Shell和Exec格式</p> 
<ul><li>Dockerfile1 A</li></ul> 
<pre><code class="prism language-bash">FROM centos
ENV name Docker
ENTRYPOINT <span class="token builtin class-name">echo</span> <span class="token string">"hello <span class="token variable">$name</span>"</span>
</code></pre> 
<ul><li>Dockerfile2</li></ul> 
<pre><code class="prism language-bash">FROM centos
ENV name Dokcer
ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"/bin/bash"</span>, <span class="token string">"-c"</span>,<span class="token string">"echo hello <span class="token variable">$name</span>"</span> <span class="token punctuation">]</span>
</code></pre> 
<h4><a id="_2451"></a>镜像发布</h4> 
<ul><li>docker login</li><li>docker push</li></ul> 
<h3><a id="Docker_2458"></a>Docker进程与宿主机进程的对应关系</h3> 
<h5><a id="LinuxID_2460"></a>Linux通过进程ID查看文件路径</h5> 
<p>子进程的文件路径</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-4-17-centos ~<span class="token punctuation">]</span><span class="token comment">#  ls -l /proc/27880</span>
total <span class="token number">0</span>
dr-xr-xr-x <span class="token number">2</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 attr
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 autogroup
-r-------- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 auxv
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:14 cgroup
--w------- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 clear_refs
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:15 cmdline
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 <span class="token function">comm</span>
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 coredump_filter
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 cpuset
lrwxrwxrwx <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 cwd -<span class="token operator">&gt;</span> /
-r-------- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 environ
lrwxrwxrwx <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:14 exe -<span class="token operator">&gt;</span> /usr/sbin/sshd
dr-x------ <span class="token number">2</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:14 fd
dr-x------ <span class="token number">2</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 fdinfo
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 gid_map
-r-------- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 io
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 limits
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 loginuid
dr-x------ <span class="token number">2</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 map_files
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 maps
-rw------- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 mem
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:14 mountinfo
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 mounts
-r-------- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 mountstats
dr-xr-xr-x <span class="token number">5</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 net
dr-x--x--x <span class="token number">2</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:14 ns
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 numa_maps
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 oom_adj
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 oom_score
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 oom_score_adj
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 pagemap
-r-------- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 patch_state
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 personality
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 projid_map
lrwxrwxrwx <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 root -<span class="token operator">&gt;</span> /
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 sched
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 schedstat
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 sessionid
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 setgroups
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 smaps
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 stack
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:14 <span class="token function">stat</span>
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 statm
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:14 status
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 syscall
dr-xr-xr-x <span class="token number">3</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 task
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 timers
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:14 uid_map
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:41 wchan

</code></pre> 
<p>以下是/proc目录中进程27880的信息说明：</p> 
<pre><code class="prism language-bash">proc/27880 pid为N的进程信息

/proc/27880/cmdline 进程启动命令

/proc/27880/cwd 链接到进程当前工作目录

/proc/27880/environ 进程环境变量列表

/proc/27880/exe 链接到进程的执行命令文件

/proc/27880/fd 包含进程相关的所有的文件描述符

/proc/27880/maps 与进程相关的内存映射信息

/proc/27880/mem 指代进程持有的内存，不可读

/proc/27880/root 链接到进程的根目录

/proc/27880/stat 进程的状态

/proc/27880/statm 进程使用的内存的状态

/proc/27880/status 进程状态信息，比stat/statm更具可读性
</code></pre> 
<h5><a id="PID_namespace_2551"></a>容器的PID namespace（命名空间）</h5> 
<p>在Docker中，进程管理的基础就是Linux内核中的PID名空间技术。</p> 
<p>在不同PID名空间中，进程ID是独立的；即在两个不同名空间下的进程可以有相同的PID。</p> 
<p>在Docker中，每个Container进程缺省都具有不同的PID名空间。通过名空间技术，Docker实现容器间的进程隔离。</p> 
<p>docker中运行的容器进程，本质上还是运行在宿主机上的，所以也会拥有相对应的PID</p> 
<h6><a id="ID_2561"></a>找出容器ID</h6> 
<pre><code class="prism language-bash">docker <span class="token function">ps</span>
</code></pre> 
<p>输出</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-4-17-centos ~<span class="token punctuation">]</span><span class="token comment"># docker ps</span>
CONTAINER ID        IMAGE                                     COMMAND                  CREATED             STATUS                          PORTS                                              NAMES
460d68823930        lemonbar/centos6-ssh:latest               <span class="token string">"/bin/sh -c '/usr/sb…"</span>   <span class="token number">32</span> minutes ago      Up <span class="token number">32</span> minutes                   <span class="token number">0.0</span>.0.0:6021-<span class="token operator">&gt;</span><span class="token number">22</span>/tcp, <span class="token number">0.0</span>.0.0:6081-<span class="token operator">&gt;</span><span class="token number">80</span>/tcp         centos6-2
</code></pre> 
<h5><a id="_2575"></a>查看容器信息</h5> 
<pre><code class="prism language-bash">docker inspect <span class="token function">id</span>
</code></pre> 
<p>输出</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-4-17-centos ~<span class="token punctuation">]</span><span class="token comment"># docker inspect  460d68823930</span>
<span class="token punctuation">[</span>root@VM-4-17-centos ~<span class="token punctuation">]</span><span class="token comment">#  docker inspect  460d68823930</span>
<span class="token punctuation">[</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token string">"Id"</span><span class="token builtin class-name">:</span> <span class="token string">"460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd"</span>,
        <span class="token string">"Created"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-11-03T08:24:36.934129599Z"</span>,
        <span class="token string">"Path"</span><span class="token builtin class-name">:</span> <span class="token string">"/bin/sh"</span>,
        <span class="token string">"Args"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
            <span class="token string">"-c"</span>,
            <span class="token string">"/usr/sbin/sshd -D"</span>
        <span class="token punctuation">]</span>,
        <span class="token string">"State"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token string">"Status"</span><span class="token builtin class-name">:</span> <span class="token string">"running"</span>,
            <span class="token string">"Running"</span><span class="token builtin class-name">:</span> true,
            <span class="token string">"Paused"</span><span class="token builtin class-name">:</span> false,
            <span class="token string">"Restarting"</span><span class="token builtin class-name">:</span> false,
            <span class="token string">"OOMKilled"</span><span class="token builtin class-name">:</span> false,
            <span class="token string">"Dead"</span><span class="token builtin class-name">:</span> false,
            <span class="token string">"Pid"</span><span class="token builtin class-name">:</span> <span class="token number">4962</span>,
            <span class="token string">"ExitCode"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"Error"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"StartedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-11-03T08:24:37.223255812Z"</span>,
            <span class="token string">"FinishedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"0001-01-01T00:00:00Z"</span>
        <span class="token punctuation">}</span>,
        <span class="token string">"Image"</span><span class="token builtin class-name">:</span> <span class="token string">"sha256:efd998bd6817af509d348b488e3ce4259f9f05632644a7bf574b785bbc8950b8"</span>,
        <span class="token string">"ResolvConfPath"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/containers/460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd/resolv.conf"</span>,
        <span class="token string">"HostnamePath"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/containers/460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd/hostname"</span>,
        <span class="token string">"HostsPath"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/containers/460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd/hosts"</span>,
        <span class="token string">"LogPath"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/containers/460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd/460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd-json.log"</span>,
        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"/centos6-2"</span>,
        <span class="token string">"RestartCount"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"overlay2"</span>,
        <span class="token string">"Platform"</span><span class="token builtin class-name">:</span> <span class="token string">"linux"</span>,
        <span class="token string">"MountLabel"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
        <span class="token string">"ProcessLabel"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
        <span class="token string">"AppArmorProfile"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
        <span class="token string">"ExecIDs"</span><span class="token builtin class-name">:</span> null,
        <span class="token string">"HostConfig"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token string">"Binds"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"ContainerIDFile"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"LogConfig"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span>
                <span class="token string">"Type"</span><span class="token builtin class-name">:</span> <span class="token string">"json-file"</span>,
                <span class="token string">"Config"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
            <span class="token punctuation">}</span>,
            <span class="token string">"NetworkMode"</span><span class="token builtin class-name">:</span> <span class="token string">"default"</span>,
            <span class="token string">"PortBindings"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span>
                <span class="token string">"22/tcp"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
                    <span class="token punctuation">{<!-- --></span>
                        <span class="token string">"HostIp"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
                        <span class="token string">"HostPort"</span><span class="token builtin class-name">:</span> <span class="token string">"6021"</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">]</span>,
                <span class="token string">"80/tcp"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
                    <span class="token punctuation">{<!-- --></span>
                        <span class="token string">"HostIp"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
                        <span class="token string">"HostPort"</span><span class="token builtin class-name">:</span> <span class="token string">"6081"</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">]</span>
            <span class="token punctuation">}</span>,
            <span class="token string">"RestartPolicy"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span>
                <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"no"</span>,
                <span class="token string">"MaximumRetryCount"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>
            <span class="token punctuation">}</span>,
            <span class="token string">"AutoRemove"</span><span class="token builtin class-name">:</span> false,
            <span class="token string">"VolumeDriver"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"VolumesFrom"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"CapAdd"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"CapDrop"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"Dns"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,
            <span class="token string">"DnsOptions"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,
            <span class="token string">"DnsSearch"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,
            <span class="token string">"ExtraHosts"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"GroupAdd"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"IpcMode"</span><span class="token builtin class-name">:</span> <span class="token string">"shareable"</span>,
            <span class="token string">"Cgroup"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"Links"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"OomScoreAdj"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"PidMode"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"Privileged"</span><span class="token builtin class-name">:</span> false,
            <span class="token string">"PublishAllPorts"</span><span class="token builtin class-name">:</span> false,
            <span class="token string">"ReadonlyRootfs"</span><span class="token builtin class-name">:</span> false,
            <span class="token string">"SecurityOpt"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"UTSMode"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"UsernsMode"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"ShmSize"</span><span class="token builtin class-name">:</span> <span class="token number">67108864</span>,
            <span class="token string">"Runtime"</span><span class="token builtin class-name">:</span> <span class="token string">"runc"</span>,
            <span class="token string">"ConsoleSize"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
                <span class="token number">0</span>,
                <span class="token number">0</span>
            <span class="token punctuation">]</span>,
            <span class="token string">"Isolation"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"CpuShares"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"Memory"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"NanoCpus"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"CgroupParent"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"BlkioWeight"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"BlkioWeightDevice"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,
            <span class="token string">"BlkioDeviceReadBps"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"BlkioDeviceWriteBps"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"BlkioDeviceReadIOps"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"BlkioDeviceWriteIOps"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"CpuPeriod"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"CpuQuota"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"CpuRealtimePeriod"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"CpuRealtimeRuntime"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"CpusetCpus"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"CpusetMems"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"Devices"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,
            <span class="token string">"DeviceCgroupRules"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"DiskQuota"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"KernelMemory"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"MemoryReservation"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"MemorySwap"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"MemorySwappiness"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"OomKillDisable"</span><span class="token builtin class-name">:</span> false,
            <span class="token string">"PidsLimit"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"Ulimits"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"CpuCount"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"CpuPercent"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"IOMaximumIOps"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"IOMaximumBandwidth"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>
        <span class="token punctuation">}</span>,
        <span class="token string">"GraphDriver"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token string">"Data"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span>
                <span class="token string">"LowerDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/6835c1b48237aafe27e2efabeda92a3a6623f254f88d54b5e6acce454e560dd6-init/diff:/var/lib/docker/overlay2/7139bf0b716c6e0b6a0c709b7043466f9bbfd7024f8ae584061c00b0bd97348c/diff:/var/lib/docker/overlay2/66a3e278259cdcf50741ce30a115baa3bd6247a60c487e4118e85f2f39328f11/diff:/var/lib/docker/overlay2/20e22c4c28ebadb615eb4c7c290253d3eb91cb49722ee2931b0ee628352a5857/diff:/var/lib/docker/overlay2/a3fa9dbebc83a853083205b8f7921c632cd67f64531f4a25cab419a43172e3ae/diff:/var/lib/docker/overlay2/3af7958c9a4e54d24598058a9fa1e85eb35e3d40f766fa498a674b52724ae73e/diff:/var/lib/docker/overlay2/becb65af4396137ed41fe6d516e834e6e6e9120f4edfac8e2ca8dd67cce23268/diff:/var/lib/docker/overlay2/fef055305158cc96906514c447f0eaea05945138896b0b35ac4146b6a2a3e273/diff:/var/lib/docker/overlay2/79158cdf3ba832493ab0d02d560c784208fe51c74236a5a86f7fb4fb50ab6e44/diff:/var/lib/docker/overlay2/86258a18e1110582b819719593687f11f0404d00a41667b3432c3b974fb1ce42/diff:/var/lib/docker/overlay2/8826b2e0068653fb2c5e8a3dbf839470e2b8eef8cf752b5fe901bea1b210849f/diff:/var/lib/docker/overlay2/145301e2738a8a7581c2bbd5beb9bf7a49b247e46642b8084efbc026a1826116/diff:/var/lib/docker/overlay2/f621f37535e0db1fe44902e22dba7ef0844b9a8b562a9daa39a842a49e9cc9bb/diff:/var/lib/docker/overlay2/7b493e4a97907aaa18b97ad2e9120b5bf87c0e9908ee390a35ea6ff546d8cec6/diff"</span>,
                <span class="token string">"MergedDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/6835c1b48237aafe27e2efabeda92a3a6623f254f88d54b5e6acce454e560dd6/merged"</span>,
                <span class="token string">"UpperDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/6835c1b48237aafe27e2efabeda92a3a6623f254f88d54b5e6acce454e560dd6/diff"</span>,
                <span class="token string">"WorkDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/6835c1b48237aafe27e2efabeda92a3a6623f254f88d54b5e6acce454e560dd6/work"</span>
            <span class="token punctuation">}</span>,
            <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"overlay2"</span>
        <span class="token punctuation">}</span>,
        <span class="token string">"Mounts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,
        <span class="token string">"Config"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token string">"Hostname"</span><span class="token builtin class-name">:</span> <span class="token string">"460d68823930"</span>,
            <span class="token string">"Domainname"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"User"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"AttachStdin"</span><span class="token builtin class-name">:</span> false,
            <span class="token string">"AttachStdout"</span><span class="token builtin class-name">:</span> false,
            <span class="token string">"AttachStderr"</span><span class="token builtin class-name">:</span> false,
            <span class="token string">"ExposedPorts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span>
                <span class="token string">"22/tcp"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>,
                <span class="token string">"80/tcp"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
            <span class="token punctuation">}</span>,
            <span class="token string">"Tty"</span><span class="token builtin class-name">:</span> true,
            <span class="token string">"OpenStdin"</span><span class="token builtin class-name">:</span> true,
            <span class="token string">"StdinOnce"</span><span class="token builtin class-name">:</span> false,
            <span class="token string">"Env"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
                <span class="token string">"HOME=/"</span>,
                <span class="token string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>
            <span class="token punctuation">]</span>,
            <span class="token string">"Cmd"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
                <span class="token string">"/bin/sh"</span>,
                <span class="token string">"-c"</span>,
                <span class="token string">"/usr/sbin/sshd -D"</span>
            <span class="token punctuation">]</span>,
            <span class="token string">"Image"</span><span class="token builtin class-name">:</span> <span class="token string">"docker.io/lemonbar/centos6-ssh:latest"</span>,
            <span class="token string">"Volumes"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"WorkingDir"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"Entrypoint"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"OnBuild"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span>,
        <span class="token string">"NetworkSettings"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token string">"Bridge"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"SandboxID"</span><span class="token builtin class-name">:</span> <span class="token string">"ea66261fb6d8089d5b2d585a2dc32b2003365df7118f5f5e898a152fb5b35773"</span>,
            <span class="token string">"HairpinMode"</span><span class="token builtin class-name">:</span> false,
            <span class="token string">"LinkLocalIPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"LinkLocalIPv6PrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"Ports"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span>
                <span class="token string">"22/tcp"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
                    <span class="token punctuation">{<!-- --></span>
                        <span class="token string">"HostIp"</span><span class="token builtin class-name">:</span> <span class="token string">"0.0.0.0"</span>,
                        <span class="token string">"HostPort"</span><span class="token builtin class-name">:</span> <span class="token string">"6021"</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">]</span>,
                <span class="token string">"80/tcp"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
                    <span class="token punctuation">{<!-- --></span>
                        <span class="token string">"HostIp"</span><span class="token builtin class-name">:</span> <span class="token string">"0.0.0.0"</span>,
                        <span class="token string">"HostPort"</span><span class="token builtin class-name">:</span> <span class="token string">"6081"</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">]</span>
            <span class="token punctuation">}</span>,
            <span class="token string">"SandboxKey"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/run/docker/netns/ea66261fb6d8"</span>,
            <span class="token string">"SecondaryIPAddresses"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"SecondaryIPv6Addresses"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span> <span class="token string">"09ad719a4e9115ee56c5fb0f5b0d39c50bf5acaf0a1afacedc13969c82a2969f"</span>,
            <span class="token string">"Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.1"</span>,
            <span class="token string">"GlobalIPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"GlobalIPv6PrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"IPAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.6"</span>,
            <span class="token string">"IPPrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">16</span>,
            <span class="token string">"IPv6Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"02:42:ac:11:00:06"</span>,
            <span class="token string">"Networks"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span>
                <span class="token string">"bridge"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token string">"IPAMConfig"</span><span class="token builtin class-name">:</span> null,
                    <span class="token string">"Links"</span><span class="token builtin class-name">:</span> null,
                    <span class="token string">"Aliases"</span><span class="token builtin class-name">:</span> null,
                    <span class="token string">"NetworkID"</span><span class="token builtin class-name">:</span> <span class="token string">"2586283d16a08210c955d705f05e0f6999b59523a84b0c163e33f535af809ddd"</span>,
                    <span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span> <span class="token string">"09ad719a4e9115ee56c5fb0f5b0d39c50bf5acaf0a1afacedc13969c82a2969f"</span>,
                    <span class="token string">"Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.1"</span>,
                    <span class="token string">"IPAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.6"</span>,
                    <span class="token string">"IPPrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">16</span>,
                    <span class="token string">"IPv6Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
                    <span class="token string">"GlobalIPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
                    <span class="token string">"GlobalIPv6PrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
                    <span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"02:42:ac:11:00:06"</span>,
                    <span class="token string">"DriverOpts"</span><span class="token builtin class-name">:</span> null
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span>

</code></pre> 
<h5><a id="_2802"></a>进入相应目录</h5> 
<pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> /sys/fs/cgroup/memory/docker/460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd/
</code></pre> 
<p>输出</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> /sys/fs/cgroup/memory/docker/460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd/
<span class="token punctuation">[</span>root@VM-4-17-centos 460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd<span class="token punctuation">]</span><span class="token comment"># ll</span>
total <span class="token number">0</span>
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 cgroup.clone_children
--w--w--w- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 cgroup.event_control
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 cgroup.procs
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.failcnt
--w------- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.force_empty
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.kmem.failcnt
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.kmem.limit_in_bytes
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.kmem.max_usage_in_bytes
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.kmem.slabinfo
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.kmem.tcp.failcnt
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.kmem.tcp.limit_in_bytes
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.kmem.tcp.max_usage_in_bytes
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.kmem.tcp.usage_in_bytes
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.kmem.usage_in_bytes
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.limit_in_bytes
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.max_usage_in_bytes
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.memsw.failcnt
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.memsw.limit_in_bytes
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.memsw.max_usage_in_bytes
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.memsw.usage_in_bytes
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.move_charge_at_immigrate
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.numa_stat
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.oom_control
---------- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.pressure_level
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.soft_limit_in_bytes
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.stat
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.swappiness
-r--r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.usage_in_bytes
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 memory.use_hierarchy
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 notify_on_release
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Nov  <span class="token number">3</span> <span class="token number">16</span>:24 tasks

</code></pre> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-4-17-centos 460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd<span class="token punctuation">]</span><span class="token comment"># cat cgroup.procs</span>
<span class="token number">4962</span>
<span class="token number">11539</span>
<span class="token punctuation">[</span>root@VM-4-17-centos 460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd<span class="token punctuation">]</span><span class="token comment"># cat pids.max</span>
max
<span class="token punctuation">[</span>root@VM-4-17-centos 460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd<span class="token punctuation">]</span><span class="token comment"># cat tasks</span>
<span class="token number">4962</span>
<span class="token number">11539</span>
<span class="token punctuation">[</span>root@VM-4-17-centos 460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd<span class="token punctuation">]</span><span class="token comment"># cat cgroup.clone_children</span>
<span class="token number">0</span>
<span class="token punctuation">[</span>root@VM-4-17-centos 460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd<span class="token punctuation">]</span><span class="token comment"># pwd</span>
/sys/fs/cgroup/pids/docker/460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd
</code></pre> 
<h5><a id="_2867"></a>查看容器目录里的进程号</h5> 
<p>进程号就存在一个文件里面</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-4-17-centos 460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd<span class="token punctuation">]</span><span class="token comment"># </span>
<span class="token function">cat</span> cgroup.procs
<span class="token number">4962</span>
</code></pre> 
<p>与前面利用<code>docker top</code>命令，可以让我们从宿主机操作系统中看到容器的进程信息。</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-4-17-centos ~<span class="token punctuation">]</span><span class="token comment"># docker top centos6-2</span>
<span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME                CMD
root                <span class="token number">4962</span>                <span class="token number">4948</span>                <span class="token number">0</span>                   <span class="token number">16</span>:24               pts/0               00:00:00            /usr/sbin/sshd -D
</code></pre> 
<h5><a id="_2887"></a>启动一个进程</h5> 
<p>我们下面会在 centos6-2容器中，利用<code>docker exec</code>命令启动一个"sleep"进程</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-4-17-centos <span class="token punctuation">]</span><span class="token comment"># docker exec -d  centos6-2  sleep 2000</span>
<span class="token punctuation">[</span>root@VM-4-17-centos <span class="token punctuation">]</span><span class="token comment"># docker exec  centos6-2  ps -ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 08:24 pts/0    00:00:00 /usr/sbin/sshd -D
root         <span class="token number">6</span>     <span class="token number">0</span>  <span class="token number">0</span> 09:06 ?        00:00:00 <span class="token function">sleep</span> <span class="token number">2000</span>
root        <span class="token number">10</span>     <span class="token number">0</span>  <span class="token number">0</span> 09:06 ?        00:00:00 <span class="token function">ps</span> -ef
</code></pre> 
<p>查看宿主机的进程号</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-4-17-centos <span class="token punctuation">]</span><span class="token comment">#  docker top centos6-2</span>
<span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME                CMD
root                <span class="token number">4962</span>                <span class="token number">4948</span>                <span class="token number">0</span>                   <span class="token number">16</span>:24               pts/0               00:00:00            /usr/sbin/sshd -D
root                <span class="token number">11539</span>               <span class="token number">4948</span>                <span class="token number">0</span>                   <span class="token number">17</span>:06               ?                   00:00:00            <span class="token function">sleep</span> <span class="token number">2000</span>
</code></pre> 
<p>我们可以清楚的看到exec命令创建的sleep进程属 centos6-2 容器的名空间，但是它的父进程是Docker 容器的启动进程。</p> 
<h5><a id="_2913"></a>查看容器目录里的进程号</h5> 
<p>进程号就存在一个文件里面</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-4-17-centos 460d688239304172f39bb9586bfc5959e0c3db64e7c3a0937f1003f94408ebbd<span class="token punctuation">]</span><span class="token comment"># cat cgroup.procs</span>
<span class="token number">4962</span>
<span class="token number">11539</span>
</code></pre> 
<pre><code class="prism language-bash"> docker <span class="token builtin class-name">exec</span> -d  centos6-2 pstree -p
 
 docker <span class="token builtin class-name">exec</span> -d  centos6-2 <span class="token function">ps</span> -auxf
 
  docker <span class="token builtin class-name">exec</span> -d  centos6-2 ll /proc
</code></pre> 
<p>输出</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-4-17-centos docker<span class="token punctuation">]</span><span class="token comment">#  docker exec  centos6-2  ps -ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 08:24 pts/0    00:00:00 /usr/sbin/sshd -D
root         <span class="token number">6</span>     <span class="token number">0</span>  <span class="token number">0</span> 09:06 ?        00:00:00 <span class="token function">sleep</span> <span class="token number">2000</span>
root        <span class="token number">40</span>     <span class="token number">0</span>  <span class="token number">0</span> 09:26 ?        00:00:00 <span class="token function">ps</span> -ef
<span class="token punctuation">[</span>root@VM-4-17-centos docker<span class="token punctuation">]</span><span class="token comment">#  docker exec  centos6-2  ps -auxf</span>
<span class="token environment constant">USER</span>       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root        <span class="token number">44</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>  <span class="token number">13360</span>  <span class="token number">1012</span> ?        Rs   09:26   <span class="token number">0</span>:00 <span class="token function">ps</span> -auxf
root         <span class="token number">6</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">4120</span>   <span class="token number">316</span> ?        Ss   09:06   <span class="token number">0</span>:00 <span class="token function">sleep</span> <span class="token number">2000</span>
root         <span class="token number">1</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>  <span class="token number">66664</span>  <span class="token number">3068</span> pts/0    Ss+  08:24   <span class="token number">0</span>:00 /usr/sbin/sshd -D
Warning: bad syntax, perhaps a bogus <span class="token string">'-'</span>? See /usr/share/doc/procps-3.2.8/FAQ
<span class="token punctuation">[</span>root@VM-4-17-centos docker<span class="token punctuation">]</span><span class="token comment">#  docker exec  centos6-2  pstree -p</span>
sshd<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="docker_daemon_docker_2953"></a>docker daemon (docker守护进程)</h4> 
<pre><code class="prism language-bash">pidof dockerd   <span class="token comment">#查看docker守护进程pid</span>
<span class="token function">lsof</span> -p <span class="token number">3197</span> <span class="token operator">|</span> <span class="token function">wc</span> -l <span class="token comment">#docker守护进程打开的文件数</span>
</code></pre> 
<p>在两个容器中的"centos "是两个独立的进程，但是他们拥有相同的父进程 Docker Daemon。</p> 
<p>所以Docker可以父子进程的方式在Docker Daemon和Redis容器之间进行交互。</p> 
<p>另一个值得注意的方面是，<code>docker exec</code>命令可以进入指定的容器内部执行命令。由它启动的进程属于容器的namespace和相应的cgroup。</p> 
<p>但是这些进程的父进程是Docker Daemon而非容器的PID1进程。</p> 
<p>我们下面会在Redis容器中，利用<code>docker exec</code>命令启动一个"sleep"进程</p> 
<pre><code class="prism language-bash">docker@default:~$ docker <span class="token builtin class-name">exec</span> -d redis <span class="token function">sleep</span> <span class="token number">2000</span>
docker@default:~$ docker <span class="token builtin class-name">exec</span> redis <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
redis        <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 02:26 ?        00:00:00 redis-server *:6379
root        <span class="token number">11</span>     <span class="token number">0</span>  <span class="token number">0</span> 02:26 ?        00:00:00 <span class="token function">sleep</span> <span class="token number">2000</span>
root        <span class="token number">21</span>     <span class="token number">0</span>  <span class="token number">0</span> 02:29 ?        00:00:00 <span class="token function">ps</span> -ef
docker@default:~$ docker <span class="token function">top</span> redis
<span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME                CMD
<span class="token number">999</span>                 <span class="token number">9955</span>                <span class="token number">1264</span>                <span class="token number">0</span>                   02:12               ?                   00:00:00            redis-server *:6379
root                <span class="token number">9984</span>                <span class="token number">1264</span>                <span class="token number">0</span>                   02:13               ?                   00:00:00            <span class="token function">sleep</span> <span class="token number">2000</span>
</code></pre> 
<p>我们可以清楚的看到exec命令创建的sleep进程属Redis容器的名空间，但是它的父进程是Docker Daemon。</p> 
<p>如果我们在宿主机操作系统中手动杀掉容器的启动进程（在上文示例中是redis-server），容器会自动结束，而容器名空间中所有进程也会退出。</p> 
<pre><code class="prism language-bash">docker@default:~$ <span class="token assign-left variable">PID</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>docker inspect --format<span class="token operator">=</span><span class="token string">"{<!-- -->{.State.Pid}}"</span> redis<span class="token variable">)</span></span>
docker@default:~$ <span class="token function">sudo</span> <span class="token function">kill</span> <span class="token variable">$PID</span>
docker@default:~$ docker <span class="token function">ps</span> -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES
356eca186321        redis               <span class="token string">"/entrypoint.sh redis"</span>   <span class="token number">23</span> minutes ago      Up <span class="token number">4</span> minutes               <span class="token number">6379</span>/tcp            redis2
f6bc57cc1b46        redis               <span class="token string">"/entrypoint.sh redis"</span>   <span class="token number">23</span> minutes ago      Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">4</span> seconds ago                       redis
</code></pre> 
<p>通过以上示例：</p> 
<ul><li>每个容器有独立的PID名空间，</li><li>容器的生命周期和其PID1进程一致</li><li>利用<code>docker exec</code>可以进入到容器的名空间中启动进程</li></ul> 
<h4><a id="Docker_3002"></a>Docker文件目录和容器内部操作</h4> 
<p>Docker默认的文件目录位于Linux server的/var/lib/docker 下面。目录结构如下</p> 
<p><img src="https://images2.imgbox.com/a6/dc/9Hdg3m3t_o.png" alt=""></p> 
<pre><code>|-----containers：用于存储容器信息
|-----image：用来存储镜像中间件及本身信息，大小，依赖信息
|-----network
|-----swarm
|-----tmp：docker临时目录
|-----trust：docker信任目录
|-----volumes：docker卷目录
</code></pre> 
<p>还可以通过docker指令确认文件位置：</p> 
<pre><code class="prism language-bash">docker info
</code></pre> 
<p><img src="https://images2.imgbox.com/1a/04/jH0fxPwR_o.png" alt=""></p> 
<p>查看某个容器的文件目录：</p> 
<pre><code class="prism language-bash">docker <span class="token builtin class-name">exec</span> 容器name <span class="token function">ls</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b8/73/UMgQtebL_o.png" alt=""></p> 
<pre><code class="prism language-bash"> docker <span class="token builtin class-name">exec</span> centos6-2   <span class="token function">ls</span> /proc
</code></pre> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-4-17-centos containers<span class="token punctuation">]</span><span class="token comment">#  docker exec centos6-2  ls /proc</span>
<span class="token number">1</span>
<span class="token number">103</span>
acpi
buddyinfo
bus
cgroups
cmdline
consoles
cpuinfo
crypto
devices
diskstats
dma
driver
execdomains
fb
filesystems
fs
interrupts
iomem
ioports
irq
kallsyms
kcore
key-users
keys
kmsg
kpagecount
kpageflags
loadavg
locks
mdstat
meminfo
misc
modules
mounts
mtrr
net
pagetypeinfo
partitions
sched_debug
schedstat
scsi
self
slabinfo
softirqs
<span class="token function">stat</span>
swaps
sys
sysrq-trigger
sysvipc
timer_list
timer_stats
<span class="token function">tty</span>
<span class="token function">uptime</span>
version
vmallocinfo
<span class="token function">vmstat</span>
zoneinfo
</code></pre> 
<h3><a id="Docker_Daemon__3113"></a>Docker Daemon 底层原理</h3> 
<p>作为Docker容器管理的守护进程，Docker Daemon从最初集成在<code>docker</code>命令中（1.11版本前），</p> 
<p>到后来的独立成单独二进制程序（1.11版本开始），其功能正在逐渐拆分细化，被分配到各个单独的模块中去。</p> 
<h4><a id="Docker_3121"></a>演进：Docker守护进程启动</h4> 
<p>从Docker服务的启动脚本，也能看见守护进程的逐渐剥离：</p> 
<p>在Docker 1.8之前，Docker守护进程启动的命令为：</p> 
<pre><code class="prism language-bashell">docker -d
</code></pre> 
<p>这个阶段，守护进程看上去只是Docker client的一个选项。</p> 
<p>Docker 1.8开始，启动命令变成了：</p> 
<pre><code class="prism language-bashell">docker daemon
</code></pre> 
<p>这个阶段，守护进程看上去是<code>docker</code>命令的一个模块。</p> 
<p>Docker 1.11开始，守护进程启动命令变成了：</p> 
<pre><code class="prism language-bashell">dockerd
</code></pre> 
<p>其服务的配置文件为：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>Service<span class="token punctuation">]</span>
<span class="token assign-left variable">Type</span><span class="token operator">=</span>notify
<span class="token comment"># the default is not to use systemd for cgroups because the delegate issues still</span>
<span class="token comment"># exists and systemd currently does not support the cgroup feature set required</span>
<span class="token comment"># for containers run by docker</span>
<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/bin/dockerd
<span class="token assign-left variable">ExecReload</span><span class="token operator">=</span>/bin/kill -s HUP <span class="token variable">$MAINPID</span>
</code></pre> 
<p>此时已经和Docker client分离，独立成一个二进制程序了。</p> 
<p>当然，守护进程模块不停的在重构，其基本功能和定位没有变化。和一般的CS架构系统一样，守护进程负责和Docker client交互，并管理Docker镜像、容器。</p> 
<h4><a id="OCIOpen_Container_Initiative_3171"></a>OCI（Open Container Initiative）</h4> 
<p>Open Container Initiative，也就是常说的OCI，是由多家公司共同成立的项目，并由linux基金会进行管理，致力于container runtime的标准的制定和runc的开发等工作。</p> 
<p>官方的介绍是</p> 
<blockquote> 
 <p>An open governance structure for the express purpose of creating open industry standards around container formats and runtime. – Open Containers Official Site</p> 
</blockquote> 
<p>所谓container runtime，主要负责的是容器的生命周期的管理。oci的runtime spec标准中对于容器的状态描述，以及对于容器的创建、删除、查看等操作进行了定义。</p> 
<p>目前主要有两个标准文档：容器运行时标准 （runtime spec）和 容器镜像标准（image spec）。</p> 
<p>这两个协议通过 OCI runtime filesytem bundle 的标准格式连接在一起，OCI 镜像可以通过工具转换成 bundle，然后 OCI 容器引擎能够识别这个 bundle 来运行容器。</p> 
<p><img src="https://images2.imgbox.com/e9/8b/ZtFKQryx_o.png" alt=""></p> 
<h5><a id="image_spec_3187"></a>image spec</h5> 
<p>OCI 容器镜像主要包括几块内容：</p> 
<p>文件系统：以 layer 保存的文件系统，每个 layer 保存了和上层之间变化的部分，layer 应该保存哪些文件，怎么表示增加、修改和删除的文件等</p> 
<p>config 文件：保存了文件系统的层级信息（每个层级的 hash 值，以及历史信息），以及容器运行时需要的一些信息（比如环境变量、工作目录、命令参数、mount 列表），指定了镜像在某个特定平台和系统的配置。比较接近我们使用 <code>docker inspect &lt;image_id&gt;</code> 看到的内容</p> 
<p>manifest 文件：镜像的 config 文件索引，有哪些 layer，额外的 annotation 信息，manifest 文件中保存了很多和当前平台有关的信息</p> 
<p>index 文件：可选的文件，指向不同平台的 manifest 文件，这个文件能保证一个镜像可以跨平台使用，每个平台拥有不同的 manifest 文件，使用 index 作为索引</p> 
<h5><a id="runtime_spec_3199"></a>runtime spec</h5> 
<p>OCI 对容器 runtime 的标准主要是指定容器的运行状态，和 runtime 需要提供的命令。下图可以是容器状态转换图：<br> <img src="https://images2.imgbox.com/4a/20/tiPiYqCI_o.png" alt=""></p> 
<h4><a id="Docker_CLI_3206"></a>Docker CLI客户端工具</h4> 
<pre><code class="prism language-bash">/usr/bin/docker
</code></pre> 
<p>Docker 的客户端工具，通过CLI与 dockerd API 交流。 CLI 的例子比如docker build … docker run …</p> 
<h4><a id="Docker_Daemon_dockerd_3214"></a>Docker Daemon守护进程 （dockerd）</h4> 
<pre><code class="prism language-bash">/usr/bin/dockerd
</code></pre> 
<p>当然，守护进程模块不停的在重构，其基本功能和定位没有变化。</p> 
<p>和一般的CS架构系统一样，守护进程负责和Docker client交互，并管理Docker镜像、容器。</p> 
<h4><a id="Containerd_3224"></a>Containerd</h4> 
<pre><code class="prism language-bash">/usr/bin/docker-containerd
</code></pre> 
<p>containerd是容器技术标准化之后的产物，为了能够兼容OCI标准，将容器运行时及其管理功能从Docker Daemon剥离。</p> 
<p>理论上，即使不运行dockerd，也能够直接通过containerd来管理容器。</p> 
<p>当然，containerd本身也只是一个守护进程，容器的实际运行时由后面介绍的runC控制。</p> 
<p>最近，Docker刚刚宣布开源containerd。从其项目介绍页面可以看出，containerd主要职责是<strong>镜像管理</strong>（镜像、元信息等）、<strong>容器执行</strong>（调用最终运行时组件执行）。</p> 
<p>containerd向上为Docker Daemon提供了gRPC接口，使得Docker Daemon屏蔽下面的结构变化，确保原有接口向下兼容。向下通过containerd-shim结合runC，使得引擎可以独立升级，避免之前Docker Daemon升级会导致所有容器不可用的问题。</p> 
<p><img src="https://images2.imgbox.com/4c/98/RyG6RwYJ_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/d7/80/kdf68qYD_o.png" alt=""></p> 
<p>containerd fully leverages the **OCI runtime specification1, image format specifications and OCI reference implementation (runc).</p> 
<p>containerd includes a daemon exposing gRPC API over a local UNIX socket. The API is a low-level one designed for higher layers to wrap and extend. Containerd uses RunC to run containers according to the OCI specification.</p> 
<h4><a id="dockershim__3250"></a>docker-shim 容器进程</h4> 
<p>docker-shim是一个真实运行的容器的真实垫片载体，每启动一个容器都会起一个新的docker-shim的一个进程，</p> 
<p>他直接通过指定的三个参数：容器id，boundle目录（containerd的对应某个容器生成的目录，一般位于：/var/run/docker/libcontainerd/containerID），</p> 
<p>运行是二进制（默认为runc）来调用runc的api创建一个容器（比如创建容器：最后拼装的命令如下：runc create 。。。。。）</p> 
<pre><code class="prism language-bash">/usr/bin/docker-containerd-shim
</code></pre> 
<p>每启动一个容器都会起一个新的docker-shim的一个进程. 他直接通过指定的三个参数来创建一个容器：</p> 
<ol><li>容器id</li><li>boundle目录（containerd的对应某个容器生成的目录，一般位于：/var/run/docker/libcontainerd/containerID）</li><li>运行是二进制（默认为runc）来调用runc的api（比如创建容器时，最后拼装的命令如下：runc create 。。。）</li></ol> 
<p>他的作用是：</p> 
<ol><li>它允许容器运行时(即 runC)在启动容器之后退出，简单说就是不必为每个容器一直运行一个容器运行时(runC)</li><li>即使在 containerd 和 dockerd 都挂掉的情况下，容器的标准 IO 和其它的文件描述符也都是可用的</li><li>向 containerd 报告容器的退出状态</li></ol> 
<p>前两点尤其重要，有了它们就可以在不中断容器运行的情况下升级或重启 dockerd(这对于生产环境来说意义重大)。</p> 
<h4><a id="runc_OCI_reference_implementation_3279"></a>runc (OCI reference implementation)</h4> 
<p>OCI定义了容器运行时标准，runC是Docker按照开放容器格式标准（OCF, Open Container Format）制定的一种具体实现。</p> 
<p>runC是从Docker的libcontainer中迁移而来的，实现了容器启停、资源隔离等功能。</p> 
<p>Docker默认提供了docker-runc实现，事实上，通过containerd的封装，可以在Docker Daemon启动的时候指定runc的实现。</p> 
<pre><code class="prism language-bash">/usr/bin/docker-runc 
</code></pre> 
<p>OCI定义了容器运行时标准OCI Runtime Spec support (aka runC)，</p> 
<p>runC是Docker按照开放容器格式标准（OCF, Open Container Format）制定的一种具体实现。</p> 
<p>runC是从Docker的<strong>libcontainer</strong>中迁移而来的，实现了容器启停、资源隔离等功能。</p> 
<p>Docker默认提供了docker-runc实现，事实上，通过containerd的封装，可以在Docker Daemon启动的时候指定runc的实现。</p> 
<p>我们可以通过启动Docker Daemon时增加–add-runtime参数来选择其他的runC现。例如：</p> 
<pre><code class="prism language-bash">docker daemon --add-runtime <span class="token string">"custom=/usr/local/bin/my-runc-replacement"</span>
</code></pre> 
<h4><a id="Dockercontainerd_containerdshimrunc_3307"></a>Docker、containerd, containerd-shim和runc之间的关系</h4> 
<p><img src="https://images2.imgbox.com/a3/aa/ECde7Zb9_o.png" alt=""><br> 他们之间的关系如下图：</p> 
<p><img src="https://images2.imgbox.com/3b/2a/8VSlmRDN_o.png" alt=""></p> 
<p>我们可以通过启动一个Docker容器，来观察进程之间的关联。</p> 
<h4><a id="runccontainer_3318"></a>通过runc来启动一个container的过程</h4> 
<h5><a id="_3322"></a>查看进程信息</h5> 
<p>利用<code>docker top</code>命令，可以让我们从宿主机操作系统中看到容器的进程信息。</p> 
<p><img src="https://images2.imgbox.com/14/e8/i4FBKfua_o.png" alt=""></p> 
<p><em>尼恩提示：这里比较复杂，具体的视频介绍，请参见稍后的 穿透云原生视频进行介绍。</em></p> 
<h5><a id="_3334"></a>查看父进程信息</h5> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@VM-4-17-centos containerd<span class="token punctuation">]</span><span class="token comment"># ps -ef | grep 3401</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/96/e7/cA70r7K4_o.png" alt=""></p> 
<p><em>尼恩提示：这里比较复杂，具体的视频介绍，请参见稍后的 穿透云原生视频进行介绍。</em></p> 
<h5><a id="_3344"></a>查看进程树</h5> 
<pre><code class="prism language-bash">pstree -l -a -A <span class="token number">3401</span> -p
</code></pre> 
<p><img src="https://images2.imgbox.com/ef/86/HYcf07Td_o.png" alt=""></p> 
<p>虽然<code>pstree</code>命令截断了命令，但我们还是能够看出，当Docker daemon启动之后，dockerd和docker-containerd进程一直存在。</p> 
<p>当启动容器之后，docker-containerd进程（也是这里介绍的containerd组件）会创建docker-containerd-shim进程，其中的参数<code>e9eaef999da9183b9be0b3239881bc6b9c2070f13057c322dfed3d072820e962</code>就是要启动容器的id。</p> 
<p>最后docker-containerd-shim子进程，已经是实际在容器中运行的进程。</p> 
<p>docker-containerd-shim另一个参数，是一个和容器相关的目录</p> 
<pre><code class="prism language-bash">/var/run/docker/containerd/e9eaef999da9183b9be0b3239881bc6b9c2070f13057c322dfed3d072820e962
</code></pre> 
<p>其中包括了容器配置和标准输入、标准输出、标准错误三个管道文件。</p> 
<p>使用下面的</p> 
<pre><code class="prism language-bash">ll /var/run/docker/containerd/e9eaef999da9183b9be0b3239881bc6b9c2070f13057c322dfed3d072820e962
</code></pre> 
<p><img src="https://images2.imgbox.com/93/f2/7dNGlFTQ_o.png" alt=""></p> 
<p><em>尼恩提示：这里比较复杂，具体的视频介绍，请参见稍后的 穿透云原生视频进行介绍。</em></p> 
<h4><a id="CRI__3380"></a>CRI 运行时接口</h4> 
<p>kubernetes在初期版本里，就对多个容器引擎做了兼容，因此可以使用docker、rkt对容器进行管理。</p> 
<p>以docker为例，kubelet中会启动一个docker manager，通过直接调用docker的api进行容器的创建等操作。</p> 
<p>在k8s 1.5版本之后，kubernetes推出了自己的运行时接口api–CRI(container runtime interface)。</p> 
<p>cri接口的推出，隔离了各个容器引擎之间的差异，而通过统一的接口与各个容器引擎之间进行互动。</p> 
<p>与oci不同，cri与kubernetes的概念更加贴合，并紧密绑定。</p> 
<p>cri不仅定义了容器的生命周期的管理，还引入了k8s中pod的概念，并定义了管理pod的生命周期。</p> 
<p>在kubernetes中，pod是由一组进行了资源限制的，在隔离环境中的容器组成。</p> 
<p>而这个隔离环境，称之为PodSandbox。</p> 
<p>在cri开始之初，主要是支持docker和rkt两种。</p> 
<p>其中kubelet是通过cri接口，调用docker-shim，并进一步调用docker api实现的。</p> 
<p>如上文所述，docker独立出来了containerd。</p> 
<p><img src="https://images2.imgbox.com/31/0a/5JGsSkQS_o.png" alt=""></p> 
<p>kubernetes也顺应潮流，孵化了cri-containerd项目，用以将containerd接入到cri的标准中。</p> 
<p><img src="https://images2.imgbox.com/c5/95/MZNuTctI_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/1a/b4/fifyOiHw_o.png" alt=""></p> 
<p>为了进一步与oci进行兼容，kubernetes还孵化了cri-o，成为了架设在cri和oci之间的一座桥梁。</p> 
<p>通过这种方式，可以方便更多符合oci标准的容器运行时，接入kubernetes进行集成使用。</p> 
<p>可以预见到，通过cri-o，kubernetes在使用的兼容性和广泛性上将会得到进一步加强。</p> 
<p><img src="https://images2.imgbox.com/81/71/7z98MaGb_o.png" alt=""></p> 
<h3><a id="Docker_3426"></a>Docker的技术底座：</h3> 
<p>Linux 命名空间、控制组和 UnionFS 三大技术支撑了目前 Docker 的实现，也是 Docker 能够出现的最重要原因。</p> 
<p><img src="https://images2.imgbox.com/85/a3/rfj3KUeU_o.png" alt=""></p> 
<h4><a id="_3439"></a>底层技术支持</h4> 
<p>其主要利用Linux的底层技术</p> 
<ul><li>Namespaces：做隔离pid，net，ipc，mnt，uts</li><li>Control groups：做资源限制</li><li>Union file systems：Container和image的分层</li></ul> 
<p><img src="https://images2.imgbox.com/e1/36/nxQVqyS8_o.png" alt=""></p> 
<ul><li>namespace，命名空间</li></ul> 
<p>命名空间，容器隔离的基础，保证A容器看不到B容器.<br> 6个命名空间：User，Mnt，Network，UTS，IPC，Pid</p> 
<ul><li>cgroups，Cgroups 是 Control Group 的缩写，控制组</li></ul> 
<p>cgroups 容器资源统计和隔离</p> 
<p>主要用到的cgroups子系统：cpu，blkio，device，freezer，memory</p> 
<p>实际上 Docker 是使用了很多 Linux 的隔离功能，让容器看起来像一个轻量级虚拟机在独立运行，容器的本质是被限制了的 Namespaces，cgroup，具有逻辑上独立文件系统，网络的一个进程。</p> 
<ul><li>unionfs 联合文件系统</li></ul> 
<p>典型：aufs/overlayfs，分层镜像实现的基础</p> 
<h3><a id="UnionFS___3476"></a>UnionFS 联合文件系统</h3> 
<h4><a id="_3478"></a>什么是镜像</h4> 
<p>那么问题来了，没有操作系统，怎么运行程序？</p> 
<p>可以在Docker中创建一个centos的镜像文件，这样就能将centos系统集成到Docker中，运行的应用就都是centos的应用。</p> 
<p>Image 是 Docker 部署的基本单位，一个 Image 包含了我们的程序文件，以及这个程序依赖的资源的环境。Docker Image 对外是以一个文件的形式展示的（更准确的说是一个 mount 点）。</p> 
<h4><a id="UnionFS_AUFS_3488"></a>UnionFS 与AUFS</h4> 
<p>UnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文件系统服务。</p> 
<p>AUFS 即 Advanced UnionFS 其实就是 UnionFS 的升级版，它能够提供更优秀的性能和效率。</p> 
<p>AUFS 作为先进联合文件系统，它能够将不同文件夹中的层联合（Union）到了同一个文件夹中，这些文件夹在 AUFS 中称作分支，整个『联合』的过程被称为联合挂载（Union Mount）。</p> 
<p>概念理解起来比较枯燥，最好是有一个真实的例子来帮助我们理解：</p> 
<p>首先，我们建立 company 和 home 两个目录，并且分别为他们创造两个文件</p> 
<pre><code class="prism language-bash">$ tree <span class="token builtin class-name">.</span>
<span class="token builtin class-name">.</span>
<span class="token operator">|</span>-- company
<span class="token operator">|</span>   <span class="token operator">|</span>-- code
<span class="token operator">|</span>   <span class="token variable"><span class="token variable">`</span>-- meeting
<span class="token variable">`</span></span>-- home
    <span class="token operator">|</span>-- eat
    `-- <span class="token function">sleep</span>
</code></pre> 
<p>然后我们将通过 mount 命令把 company 和 home 两个目录「联合」起来，建立一个 AUFS 的文件系统，并挂载到当前目录下的 mnt 目录下：</p> 
<pre><code class="prism language-bash">$ <span class="token function">mkdir</span> mnt
$ ll
total <span class="token number">20</span>
drwxr-xr-x <span class="token number">5</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span>:10 ./
drwxr-xr-x <span class="token number">5</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span>:06 <span class="token punctuation">..</span>/
drwxr-xr-x <span class="token number">4</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span>:06 company/
drwxr-xr-x <span class="token number">4</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span>:05 home/
drwxr-xr-x <span class="token number">2</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span>:10 mnt/

<span class="token comment"># mount -t aufs -o dirs=./home:./company none ./mnt</span>
<span class="token comment"># ll</span>
total <span class="token number">20</span>
drwxr-xr-x <span class="token number">5</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span>:10 ./
drwxr-xr-x <span class="token number">5</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span>:06 <span class="token punctuation">..</span>/
drwxr-xr-x <span class="token number">4</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span>:06 company/
drwxr-xr-x <span class="token number">6</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span>:10 home/
drwxr-xr-x <span class="token number">8</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span>:10 mnt/
root@rds-k8s-18-svr0:~/xuran/aufs<span class="token comment"># tree ./mnt/</span>
./mnt/
<span class="token operator">|</span>-- code
<span class="token operator">|</span>-- eat
<span class="token operator">|</span>-- meeting
`-- <span class="token function">sleep</span>

<span class="token number">4</span> directories, <span class="token number">0</span> files
</code></pre> 
<p>通过 ./mnt 目录结构的输出结果，可以看到原来两个目录下的内容都被合并到了一个 mnt 的目录下。</p> 
<p>默认情况下，如果我们不对「联合」的目录指定权限，内核将根据从左至右的顺序将第一个目录指定为可读可写的，其余的都为只读。那么，当我们向只读的目录做一些写入操作的话，会发生什么呢？</p> 
<pre><code class="prism language-bash">$ <span class="token builtin class-name">echo</span> apple <span class="token operator">&gt;</span> ./mnt/code
$ <span class="token function">cat</span> company/code
$ <span class="token function">cat</span> home/code
apple
</code></pre> 
<p>通过对上面代码段的观察，我们可以看出，当写入操作发生在 company/code 文件时， 对应的修改并没有反映到原始的目录中。</p> 
<p>而是在 home 目录下又创建了一个名为 code 的文件，并将 apple 写入了进去。</p> 
<p>看起来很奇怪的现象，其实这正是 Union File System 的厉害之处：</p> 
<blockquote> 
 <p>Union File System 联合了多个不同的目录，并且把他们挂载到一个统一的目录上。</p> 
</blockquote> 
<p>在这些「联合」的子目录中， 有一部分是可读可写的，但是有一部分只是可读的。</p> 
<blockquote> 
 <p>当你对可读的目录内容做出修改的时候，其结果只会保存到可写的目录下，不会影响只读的目录。</p> 
</blockquote> 
<p>比如，我们可以把我们的服务的源代码目录和一个存放代码修改记录的目录「联合」起来构成一个 AUFS。前者设置只读权限，后者设置读写权限。</p> 
<p>那么，一切对源代码目录下文件的修改都只会影响那个存放修改的目录，不会污染原始的代码。</p> 
<p>在 AUFS 中还有一个特殊的概念需要提及一下：</p> 
<p>branch – 就是各个要被union起来的目录。</p> 
<p>Stack 结构 - AUFS 它会根据branch 被 Union 的顺序形成一个 Stack 的结构，从下至上，最上面的目录是可读写的，其余都是可读的。如果按照我们刚刚执行 aufs 挂载的命令来说，最左侧的目录就对应 Stack 最顶层的 branch。</p> 
<p>所以：下面的命令中，最为左侧的为 home，而不是 company</p> 
<pre><code class="prism language-bash"><span class="token function">mount</span> -t aufs -o <span class="token assign-left variable">dirs</span><span class="token operator">=</span>./home:./company none ./mnt
</code></pre> 
<h4><a id="_Docker__3586"></a>什么是 Docker 镜像分层机制？</h4> 
<p>首先，让我们来看下 Docker Image 中的 Layer 的概念：</p> 
<p><img src="https://images2.imgbox.com/50/24/frcfGJKf_o.png" alt=""></p> 
<p>Docker Image 是有一个层级结构的，最底层的 Layer 为 BaseImage（一般为一个操作系统的 ISO 镜像），然后顺序执行每一条指令，生成的 Layer 按照入栈的顺序逐渐累加，最终形成一个 Image。</p> 
<p>直观的角度来说，是这个图所示：</p> 
<p><img src="https://images2.imgbox.com/61/60/drNOruYb_o.png" alt=""></p> 
<p>每一次都是一个被联合的目录，从目录的角度来说，大致如下图所示：</p> 
<p><img src="https://images2.imgbox.com/21/8e/uI4fHG1K_o.png" alt=""></p> 
<h4><a id="Docker_Image__3610"></a>Docker Image 如何而来呢？</h4> 
<p>简单来说，一个 Image 是通过一个 DockerFile 定义的，然后使用 docker build 命令构建它。</p> 
<p>DockerFile 中的每一条命令的执行结果都会成为 Image 中的一个 Layer。</p> 
<p>这里，我们通过 Build 一个镜像，来观察 Image 的分层机制：</p> 
<p>Dockerfile:</p> 
<pre><code class="prism language-bash"><span class="token comment"># Use an official Python runtime as a parent image</span>
FROM python:2.7-slim

<span class="token comment"># Set the working directory to /app</span>
WORKDIR /app

<span class="token comment"># Copy the current directory contents into the container at /app</span>
COPY <span class="token builtin class-name">.</span> /app

<span class="token comment"># Install any needed packages specified in requirements.txt</span>
RUN pip <span class="token function">install</span> --trusted-host pypi.python.org -r requirements.txt

<span class="token comment"># Make port 80 available to the world outside this container</span>
EXPOSE <span class="token number">80</span>

<span class="token comment"># Define environment variable</span>
ENV NAME World

<span class="token comment"># Run app.py when the container launches</span>
CMD <span class="token punctuation">[</span><span class="token string">"python"</span>, <span class="token string">"app.py"</span><span class="token punctuation">]</span>
</code></pre> 
<p>构建结果：</p> 
<pre><code class="prism language-bash">root@rds-k8s-18-svr0:~/xuran/exampleimage<span class="token comment"># docker build -t hello ./</span>
Sending build context to Docker daemon  <span class="token number">5.12</span> kB
Step <span class="token number">1</span>/7 <span class="token builtin class-name">:</span> FROM python:2.7-slim
 ---<span class="token operator">&gt;</span> 804b0a01ea83
Step <span class="token number">2</span>/7 <span class="token builtin class-name">:</span> WORKDIR /app
 ---<span class="token operator">&gt;</span> Using cache
 ---<span class="token operator">&gt;</span> 6d93c5b91703
Step <span class="token number">3</span>/7 <span class="token builtin class-name">:</span> COPY <span class="token builtin class-name">.</span> /app
 ---<span class="token operator">&gt;</span> Using cache
 ---<span class="token operator">&gt;</span> feddc82d321b
Step <span class="token number">4</span>/7 <span class="token builtin class-name">:</span> RUN pip <span class="token function">install</span> --trusted-host pypi.python.org -r requirements.txt
 ---<span class="token operator">&gt;</span> Using cache
 ---<span class="token operator">&gt;</span> 94695df5e14d
Step <span class="token number">5</span>/7 <span class="token builtin class-name">:</span> EXPOSE <span class="token number">81</span>
 ---<span class="token operator">&gt;</span> Using cache
 ---<span class="token operator">&gt;</span> 43c392d51dff
Step <span class="token number">6</span>/7 <span class="token builtin class-name">:</span> ENV NAME World
 ---<span class="token operator">&gt;</span> Using cache
 ---<span class="token operator">&gt;</span> 78c9a60237c8
Step <span class="token number">7</span>/7 <span class="token builtin class-name">:</span> CMD python app.py
 ---<span class="token operator">&gt;</span> Using cache
 ---<span class="token operator">&gt;</span> a5ccd4e1b15d
Successfully built a5ccd4e1b15d
</code></pre> 
<p>通过构建结果可以看出，构建的过程就是执行 Dockerfile 文件中我们写入的命令。构建一共进行了7个步骤，每个步骤进行完都会生成一个随机的 ID，来标识这一 layer 中的内容。 最后一行的 a5ccd4e1b15d 为镜像的 ID。由于我贴上来的构建过程已经是构建了第二次的结果了，所以可以看出，对于没有任何修改的内容，Docker 会复用之前的结果。</p> 
<p>如果 DockerFile 中的内容没有变动，那么相应的镜像在 build 的时候会复用之前的 layer，以便提升构建效率。并且，即使文件内容有修改，那也只会重新 build 修改的 layer，其他未修改的也仍然会复用。</p> 
<p>通过了解了 Docker Image 的分层机制，我们多多少少能够感觉到，Layer 和 Image 的关系与 AUFS 中的联合目录和挂载点的关系比较相似。</p> 
<p>而 Docker 也正是通过 AUFS 来管理 Images 的。</p> 
<h3><a id="Namespaces_3688"></a>Namespaces</h3> 
<p>在Linux系统中，Namespace是在内核级别以一种抽象的形式来封装系统资源，通过将系统资源放在不同的Namespace中，来实现资源隔离的目的。不同的Namespace程序，可以享有一份独立的系统资源。</p> 
<p>命名空间（namespaces）是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。</p> 
<p>Linux 的命名空间机制提供了以下七种不同的命名空间，包括 :</p> 
<ul><li>CLONE_NEWCGROUP</li><li>CLONE_NEWIPC</li><li>CLONE_NEWNET</li><li>CLONE_NEWNS</li><li>CLONE_NEWPID</li><li>CLONE_NEWUSER</li><li>CLONE_NEWUTS</li></ul> 
<p>通过这七个选项, 我们能在创建新的进程时, 设置新进程应该在哪些资源上与宿主机器进行隔离。具体如下：</p> 
<table><thead><tr><th align="center"><strong>Namespace</strong></th><th align="center"><strong>Flag</strong></th><th align="center"><strong>Page</strong></th><th align="center"><strong>Isolates</strong></th></tr></thead><tbody><tr><td align="center">Cgroup</td><td align="center"><strong>CLONE_NEWCGROUP</strong></td><td align="center"><strong>cgroup_namespaces</strong></td><td align="center">Cgroup root directory</td></tr><tr><td align="center">IPC</td><td align="center"><strong>CLONE_NEWIPC</strong></td><td align="center"><strong>ipc_namespaces</strong></td><td align="center">System V IPC,POSIX message queues 隔离进程间通信</td></tr><tr><td align="center">Network</td><td align="center"><strong>CLONE_NEWNET</strong></td><td align="center"><strong>network_namespaces</strong></td><td align="center">Network devices,stacks, ports, etc. 隔离网络资源</td></tr><tr><td align="center">Mount</td><td align="center"><strong>CLONE_NEWNS</strong></td><td align="center"><strong>mount_namespaces</strong></td><td align="center">Mount points 隔离文件系统挂载点</td></tr><tr><td align="center">PID</td><td align="center"><strong>CLONE_NEWPID</strong></td><td align="center"><strong>pid_namespaces</strong></td><td align="center">Process IDs 隔离进程的ID</td></tr><tr><td align="center">Time</td><td align="center"><strong>CLONE_NEWTIME</strong></td><td align="center"><strong>time_namespaces</strong></td><td align="center">Boot and monotonic clocks</td></tr><tr><td align="center">User</td><td align="center"><strong>CLONE_NEWUSER</strong></td><td align="center"><strong>user_namespaces</strong></td><td align="center">User and group IDs 隔离用户和用户组的ID</td></tr><tr><td align="center">UTS</td><td align="center"><strong>CLONE_NEWUTS</strong></td><td align="center"><strong>uts_namespaces</strong></td><td align="center">Hostname and NIS domain name 隔离主机名和域名信息</td></tr></tbody></table> 
<p>这里提出一个问题，在宿主机上启动两个容器，在这两个容器内都各有一个 PID=1的进程，众所周知，Linux 里 PID 是唯一的，既然 Docker 不是跑在宿主机上的两个虚拟机，那么它是如何实现在宿主机上运行两个相同 PID 的进程呢？</p> 
<p>这里就用到了 Linux Namespaces，它其实是 Linux 创建新进程时的一个可选参数，在 Linux 系统中创建进程的系统调用是 clone()方法。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>，<span class="token keyword">void</span> <span class="token operator">*</span>child stack<span class="token punctuation">,</span>
          <span class="token keyword">int</span> flags， <span class="token keyword">void</span> <span class="token operator">*</span>arg， <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>
         <span class="token comment">/* pid_ t *ptid, void *newtls, pid_ t *ctid */</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/c0/32/wcq5DfzK_o.png" alt=""></p> 
<p>通过调用这个方法，这个进程会获得一个独立的进程空间，它的 pid 是1，并且看不到宿主机上的其他进程，这也就是在容器内执行 PS 命令的结果。</p> 
<p>不仅仅是 PID，当你启动启动容器之后，Docker 会为这个容器创建一系列其他 namespaces。</p> 
<p>这些 namespaces 提供了不同层面的隔离。容器的运行受到各个层面 namespace 的限制。</p> 
<p>Docker Engine 使用了以下 Linux 的隔离技术:</p> 
<p>The pid namespace: 管理 PID 命名空间 (PID: Process ID).</p> 
<p>The net namespace: 管理网络命名空间(NET: Networking).</p> 
<p>The ipc namespace: 管理进程间通信命名空间(IPC: InterProcess Communication).</p> 
<p>The mnt namespace: 管理文件系统挂载点命名空间 (MNT: Mount).</p> 
<p>The uts namespace: Unix 时间系统隔离. (UTS: Unix Timesharing System).</p> 
<p>通过这些技术，运行时的容器得以看到一个和宿主机上其他容器隔离的环境。</p> 
<h4><a id="_3765"></a>进程隔离</h4> 
<p>进程是 Linux 以及现在操作系统中非常重要的概念，它表示一个正在执行的程序，也是在现代分时系统中的一个任务单元。</p> 
<p>在每一个 *nix 的操作系统上，我们都能够通过 ps 命令打印出当前操作系统中正在执行的进程，比如在 Ubuntu 上，使用该命令就能得到以下的结果：</p> 
<pre><code class="prism language-bash"><span class="token operator">|</span>$ <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>		PID		<span class="token environment constant">PPID</span>	C 	STIME 	TTY          TIME CMD
root     <span class="token number">1</span>       <span class="token number">0</span>  	<span class="token number">0</span>   Apr08 	 ?      00:00:09 /sbin/init
root     <span class="token number">2</span>       <span class="token number">0</span>  	<span class="token number">0</span>   Apr08 	 ?      00:00:00 <span class="token punctuation">[</span>kthreadd<span class="token punctuation">]</span>
root     <span class="token number">3</span>       <span class="token number">2</span>  	<span class="token number">0</span>   Apr08	 ?      00:00:05 <span class="token punctuation">[</span>ksoftirqd/0<span class="token punctuation">]</span>
root     <span class="token number">5</span>       <span class="token number">2</span>  	<span class="token number">0</span>   Apr08 	 ?      00:00:00 <span class="token punctuation">[</span>kworker/0:0H<span class="token punctuation">]</span>
root     <span class="token number">7</span>       <span class="token number">2</span>  	<span class="token number">0</span>   Apr08 	 ?     	00:07:10 <span class="token punctuation">[</span>rcu_sched<span class="token punctuation">]</span>
root    <span class="token number">39</span>       <span class="token number">2</span>  	<span class="token number">0</span>   Apr08 	 ?      00:00:00 <span class="token punctuation">[</span>migration/0<span class="token punctuation">]</span>
root    <span class="token number">40</span>       <span class="token number">2</span>  	<span class="token number">0</span>   Apr08 	 ?      00:01:54 <span class="token punctuation">[</span>watchdog/0<span class="token punctuation">]</span>
</code></pre> 
<p>当前机器上有很多的进程正在执行，在上述进程中有两个非常特殊，一个是 pid 为 1 的 /sbin/init 进程，另一个是 pid 为 2 的 kthreadd 进程，这两个进程都是被 Linux 中的上帝进程 idle 创建出来的，其中前者负责执行内核的一部分初始化工作和系统配置，也会创建一些类似 getty 的注册进程，而后者负责管理和调度其他的内核进程。</p> 
<p><img src="https://images2.imgbox.com/a7/f0/pfg6BjxH_o.png" alt=""></p> 
<p>如果我们在当前的 Linux 操作系统下运行一个新的 Docker 容器，并通过 exec 进入其内部的 bash 并打印其中的全部进程，我们会得到以下的结果：</p> 
<pre><code class="prism language-bash"><span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root     <span class="token number">29407</span>     <span class="token number">1</span>  <span class="token number">0</span> Nov16 ?        00:08:38 /usr/bin/dockerd --raw-logs
root      <span class="token number">1554</span> <span class="token number">29407</span>  <span class="token number">0</span> Nov19 ?        00:03:28 docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval<span class="token operator">=</span><span class="token number">0</span> --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runc
root      <span class="token number">5006</span>  <span class="token number">1554</span>  <span class="token number">0</span> 08:38 ?        00:00:00 docker-containerd-shim b809a2eb3630e64c581561b08ac46154878ff1c61c6519848b4a29d412215e79 /var/run/docker/libcontainerd/b809a2eb3630e64c581561b08ac46154878ff1c61c6519848b4a29d412215e79 docker-runc
</code></pre> 
<p>在新的容器内部执行 ps 命令打印出了非常干净的进程列表，只有包含当前 ps -ef 在内的三个进程，在宿主机器上的几十个进程都已经消失不见了。</p> 
<p>当前的 Docker 容器成功将容器内的进程与宿主机器中的进程隔离，如果我们在宿主机器上打印当前的全部进程时，会得到下面三条与 Docker 相关的结果：</p> 
<p>在当前的宿主机器上，可能就存在由上述的不同进程构成的进程树：</p> 
<p><img src="https://images2.imgbox.com/d8/6c/18DmJ8ib_o.png" alt=""></p> 
<p>这就是在使用 clone(2) 创建新进程时传入 CLONE_NEWPID 实现的，也就是使用 Linux 的命名空间实现进程的隔离，Docker 容器内部的任意进程都对宿主机器的进程一无所知。</p> 
<pre><code class="prism language-bash">containerRouter.postContainersStart
└── daemon.ContainerStart
└── daemon.createSpec
    └── setNamespaces
        └── setNamespace
</code></pre> 
<p>Docker 的容器就是使用上述技术实现与宿主机器的进程隔离，当我们每次运行 docker run 或者 docker start 时，都会在下面的方法中创建一个用于设置进程间隔离的 Spec：</p> 
<pre><code class="prism language-c"><span class="token function">func</span> <span class="token punctuation">(</span>daemon <span class="token operator">*</span>Daemon<span class="token punctuation">)</span> <span class="token function">createSpec</span><span class="token punctuation">(</span>c <span class="token operator">*</span>container<span class="token punctuation">.</span>Container<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>specs<span class="token punctuation">.</span>Spec<span class="token punctuation">,</span> error<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    s <span class="token operator">:</span><span class="token operator">=</span> oci<span class="token punctuation">.</span><span class="token function">DefaultSpec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment">// ...</span>
        <span class="token keyword">if</span> err <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">setNamespaces</span><span class="token punctuation">(</span>daemon<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> nil<span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"linux spec namespaces: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> nil
<span class="token punctuation">}</span> 
</code></pre> 
<p>在 setNamespaces 方法中不仅会设置进程相关的命名空间，还会设置与用户、网络、IPC 以及 UTS 相关的命名空间：</p> 
<pre><code class="prism language-c">func <span class="token function">setNamespaces</span><span class="token punctuation">(</span>daemon <span class="token operator">*</span>Daemon<span class="token punctuation">,</span> s <span class="token operator">*</span>specs<span class="token punctuation">.</span>Spec<span class="token punctuation">,</span> c <span class="token operator">*</span>container<span class="token punctuation">.</span>Container<span class="token punctuation">)</span> error <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// user</span>
    <span class="token comment">// network</span>
    <span class="token comment">// ipc</span>
    <span class="token comment">// uts</span>

    <span class="token comment">// pid</span>
    <span class="token keyword">if</span> c<span class="token punctuation">.</span>HostConfig<span class="token punctuation">.</span>PidMode<span class="token punctuation">.</span><span class="token function">IsContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        ns <span class="token operator">:</span><span class="token operator">=</span> specs<span class="token punctuation">.</span>LinuxNamespace<span class="token punctuation">{<!-- --></span>Type<span class="token operator">:</span> <span class="token string">"pid"</span><span class="token punctuation">}</span>
        pc<span class="token punctuation">,</span> err <span class="token operator">:</span><span class="token operator">=</span> daemon<span class="token punctuation">.</span><span class="token function">getPidContainer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
            <span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> err
            <span class="token punctuation">}</span>
        ns<span class="token punctuation">.</span>Path <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"/proc/%d/ns/pid"</span><span class="token punctuation">,</span> pc<span class="token punctuation">.</span>State<span class="token punctuation">.</span><span class="token function">GetPID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">setNamespace</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ns<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> c<span class="token punctuation">.</span>HostConfig<span class="token punctuation">.</span>PidMode<span class="token punctuation">.</span><span class="token function">IsHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        oci<span class="token punctuation">.</span><span class="token function">RemoveNamespace</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> specs<span class="token punctuation">.</span><span class="token function">LinuxNamespaceType</span><span class="token punctuation">(</span><span class="token string">"pid"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        ns <span class="token operator">:</span><span class="token operator">=</span> specs<span class="token punctuation">.</span>LinuxNamespace<span class="token punctuation">{<!-- --></span>Type<span class="token operator">:</span> <span class="token string">"pid"</span><span class="token punctuation">}</span>
        <span class="token function">setNamespace</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ns<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> nil
<span class="token punctuation">}</span> 
</code></pre> 
<p>所有命名空间相关的设置 Spec 最后都会作为 Create 函数的入参在创建新的容器时进行设置：</p> 
<pre><code class="prism language-c">daemon<span class="token punctuation">.</span>containerd<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> container<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> spec<span class="token punctuation">,</span> createOptions<span class="token punctuation">)</span>
</code></pre> 
<p>所有与命名空间的相关的设置都是在上述的两个函数中完成的，Docker 通过命名空间成功完成了与宿主机进程和网络的隔。</p> 
<h4><a id="_3868"></a>网络隔离</h4> 
<p>如果 Docker 的容器通过 Linux 的命名空间完成了与宿主机进程的网络隔离，但是却有没有办法通过宿主机的网络与整个互联网相连，就会产生很多限制。</p> 
<p>所以 Docker 虽然可以通过命名空间创建一个隔离的网络环境，但是 Docker 中的服务仍然需要与外界相连才能发挥作用。<br> 每一个使用 docker run 启动的容器其实都具有单独的网络命名空间，Docker 为我们提供了四种不同的网络模式，Host、Container、None 和 Bridge 模式。</p> 
<p><img src="https://images2.imgbox.com/9b/52/FxHYwyt1_o.png" alt=""></p> 
<p>在这一部分，我们将介绍 Docker 默认的网络设置模式：网桥模式。</p> 
<p>在这种模式下，除了分配隔离的网络命名空间之外，Docker 还会为所有的容器设置 IP 地址。</p> 
<p>当 Docker 服务器在主机上启动之后会创建新的虚拟网桥 docker0，随后在该主机上启动的全部服务在默认情况下都与该网桥相连。</p> 
<p><img src="https://images2.imgbox.com/32/4e/NtIAQ3DI_o.png" alt=""></p> 
<p>在默认情况下，每一个容器在创建时都会创建一对虚拟网卡，两个虚拟网卡组成了数据的通道，其中一个会放在创建的容器中，会加入到名为 docker0 网桥中。</p> 
<p>我们可以使用如下的命令来查看当前网桥的接口：</p> 
<pre><code class="prism language-bash">$ brctl show
bridge name bridge <span class="token function">id</span>       STP enabled interfaces
docker0     <span class="token number">8000</span>.0242a6654980   no      veth3e84d4f
 veth9953b75
</code></pre> 
<p>docker0会为每一个容器分配一个新的 IP 地址并将 docker0 的 IP 地址设置为默认的网关。</p> 
<p>网桥 docker0 通过 iptables 中的配置与宿主机器上的网卡相连，所有符合条件的请求都会通过 iptables 转发到 docker0 并由网桥分发给对应的机器。</p> 
<pre><code class="prism language-bash">$ iptables -t nat -L
Chain PREROUTING <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
DOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL

Chain DOCKER <span class="token punctuation">(</span><span class="token number">2</span> references<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
RETURN     all  --  anywhere             anywhere
</code></pre> 
<p>我们在当前的机器上使用 docker run -d -p 6379:6379 redis 命令启动了一个新的 Redis 容器，在这之后我们再查看当前 iptables 的 NAT 配置就会看到在 DOCKER 的链中出现了一条新的规则：</p> 
<pre><code class="prism language-bash">DNAT       tcp  --  anywhere             anywhere             tcp dpt:6379 to:192.168.0.4:6379
</code></pre> 
<p>上述规则会将从任意源发送到当前机器 6379 端口的 TCP 包转发到 192.168.0.4:6379 所在的地址上。</p> 
<p>这个地址其实也是 Docker 为 Redis 服务分配的 IP 地址，如果我们在当前机器上直接 ping 这个 IP 地址就会发现它是可以访问到的：</p> 
<pre><code class="prism language-bash">$ <span class="token function">ping</span> <span class="token number">192.168</span>.0.4
PING <span class="token number">192.168</span>.0.4 <span class="token punctuation">(</span><span class="token number">192.168</span>.0.4<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.
<span class="token number">64</span> bytes from <span class="token number">192.168</span>.0.4: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.069</span> ms
<span class="token number">64</span> bytes from <span class="token number">192.168</span>.0.4: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.043</span> ms
^C
--- <span class="token number">192.168</span>.0.4 <span class="token function">ping</span> statistics ---
<span class="token number">2</span> packets transmitted, <span class="token number">2</span> received, <span class="token number">0</span>% packet loss, <span class="token function">time</span> 999ms
rtt min/avg/max/mdev <span class="token operator">=</span> <span class="token number">0.043</span>/0.056/0.069/0.013 ms
</code></pre> 
<p>从上述的一系列现象，我们就可以推测出 Docker 是如何将容器的内部的端口暴露出来并对数据包进行转发的了；当有 Docker 的容器需要将服务暴露给宿主机器，就会为容器分配一个 IP 地址，同时向 iptables 中追加一条新的规则。</p> 
<p><img src="https://images2.imgbox.com/ac/38/on9ZGTuK_o.png" alt=""></p> 
<p>当我们使用 redis-cli 在宿主机器的命令行中访问 127.0.0.1:6379 的地址时，经过 iptables 的 NAT PREROUTING 将 ip 地址定向到了 192.168.0.4，重定向过的数据包就可以通过 iptables 中的 FILTER 配置，最终在 NAT POSTROUTING 阶段将 ip 地址伪装成 127.0.0.1，到这里虽然从外面看起来我们请求的是 127.0.0.1:6379，但是实际上请求的已经是 Docker 容器暴露出的端口了。</p> 
<pre><code class="prism language-bash">$ redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">6379</span> <span class="token function">ping</span>
PONG
</code></pre> 
<p>Docker 通过 Linux 的命名空间实现了网络的隔离，又通过 iptables 进行数据包转发，让 Docker 容器能够优雅地为宿主机器或者其他容器提供服务。</p> 
<h4><a id="Libnetwork_3949"></a>Libnetwork</h4> 
<p>整个网络部分的功能都是通过 Docker 拆分出来的 libnetwork 实现的，它提供了一个连接不同容器的实现，同时也能够为应用给出一个能够提供一致的编程接口和网络层抽象的容器网络模型。</p> 
<p>The goal of libnetwork is to deliver a robust Container Network Model that provides a consistent programming interface and the required network abstractions for applications.</p> 
<p>libnetwork 中最重要的概念，容器网络模型由以下的几个主要组件组成，分别是 Sandbox、Endpoint 和 Network：</p> 
<p><img src="https://images2.imgbox.com/93/7a/4q4zDJGw_o.png" alt=""></p> 
<p>在容器网络模型中，每一个容器内部都包含一个 Sandbox，其中存储着当前容器的网络栈配置，包括容器的接口、路由表和 DNS 设置，Linux 使用网络命名空间实现这个 Sandbox，每一个 Sandbox 中都可能会有一个或多个 Endpoint，在 Linux 上就是一个虚拟的网卡 veth，Sandbox 通过 Endpoint 加入到对应的网络中，这里的网络可能就是我们在上面提到的 Linux 网桥或者 VLAN。</p> 
<p><strong>挂载点</strong></p> 
<p>虽然我们已经通过 Linux 的命名空间解决了进程和网络隔离的问题，在 Docker 进程中我们已经没有办法访问宿主机器上的其他进程并且限制了网络的访问，但是 Docker 容器中的进程仍然能够访问或者修改宿主机器上的其他目录，这是我们不希望看到的。</p> 
<p>在新的进程中创建隔离的挂载点命名空间需要在 clone 函数中传入 CLONE_NEWNS，这样子进程就能得到父进程挂载点的拷贝，如果不传入这个参数子进程对文件系统的读写都会同步回父进程以及整个主机的文件系统。</p> 
<p>如果一个容器需要启动，那么它一定需要提供一个根文件系统（rootfs），容器需要使用这个文件系统来创建一个新的进程，所有二进制的执行都必须在这个根文件系统中。</p> 
<p><img src="https://images2.imgbox.com/e1/71/F3Cgd2M0_o.png" alt=""></p> 
<p>想要正常启动一个容器就需要在 rootfs 中挂载以上的几个特定的目录，除了上述的几个目录需要挂载之外我们还需要建立一些符号链接保证系统 IO 不会出现问题。</p> 
<p>为了保证当前的容器进程没有办法访问宿主机器上其他目录，我们在这里还需要通过 libcotainer 提供的 pivor_root 或者 chroot 函数改变进程能够访问个文件目录的根节点。</p> 
<pre><code class="prism language-bash">// pivor_root
put_old <span class="token operator">=</span> mkdir<span class="token punctuation">(</span><span class="token punctuation">..</span>.<span class="token punctuation">)</span><span class="token punctuation">;</span>
pivot_root<span class="token punctuation">(</span>rootfs, put_old<span class="token punctuation">)</span><span class="token punctuation">;</span>
chdir<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
unmount<span class="token punctuation">(</span>put_old, MS_DETACH<span class="token punctuation">)</span><span class="token punctuation">;</span>
rmdir<span class="token punctuation">(</span>put_old<span class="token punctuation">)</span><span class="token punctuation">;</span>

// <span class="token function">chroot</span>
mount<span class="token punctuation">(</span>rootfs, <span class="token string">"/"</span>, NULL, MS_MOVE, NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>
chroot<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
chdir<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>到这里我们就将容器需要的目录挂载到了容器中，同时也禁止当前的容器进程访问宿主机器上的其他目录，保证了不同文件系统的隔离。</p> 
<h4><a id="Chroot_3991"></a>Chroot</h4> 
<p>在这里不得不简单介绍一下 chroot（change root），在 Linux 系统中，系统默认的目录就都是以 / 也就是根目录开头的，chroot 的使用能够改变当前的系统根目录结构，通过改变当前系统的根目录，我们能够限制用户的权利，在新的根目录下并不能够访问旧系统根目录的结构个文件，也就建立了一个与原系统完全隔离的目录结构。</p> 
<h3><a id="CGroups_3995"></a>CGroups物理资源限制分组</h3> 
<p>我们通过 Linux 的命名空间为新创建的进程隔离了文件系统、网络并与宿主机器之间的进程相互隔离，但是命名空间并不能够为我们提供物理资源上的隔离，比如 CPU 或者内存，如果在同一台机器上运行了多个对彼此以及宿主机器一无所知的『容器』，这些容器却共同占用了宿主机器的物理资源。</p> 
<p><img src="https://images2.imgbox.com/84/c3/ZC2bbTMr_o.png" alt=""></p> 
<p>如果其中的某一个容器正在执行 CPU 密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了解决进程虚拟资源隔离之后的主要问题，而 Control Groups（简称 CGroups）就是能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。</p> 
<p>每一个 CGroup 都是一组被相同的标准和参数限制的进程，不同的 CGroup 之间是有层级关系的，也就是说它们之间可以从父类继承一些用于限制资源使用的标准和参数。</p> 
<p>Linux 的 CGroup 能够为一组进程分配资源，也就是我们在上面提到的 CPU、内存、网络带宽等资源，通过对资源的分配。</p> 
<p>Linux 使用文件系统来实现 CGroup，我们可以直接使用下面的命令查看当前的 CGroup 中有哪些子系统：</p> 
<pre><code class="prism language-bash">$ lssubsys -m
cpuset /sys/fs/cgroup/cpuset
cpu /sys/fs/cgroup/cpu
cpuacct /sys/fs/cgroup/cpuacct
memory /sys/fs/cgroup/memory
devices /sys/fs/cgroup/devices
freezer /sys/fs/cgroup/freezer
blkio /sys/fs/cgroup/blkio
perf_event /sys/fs/cgroup/perf_event
hugetlb /sys/fs/cgroup/hugetlb
</code></pre> 
<p>大多数 Linux 的发行版都有着非常相似的子系统，而之所以将上面的 cpuset、cpu 等东西称作子系统，是因为它们能够为对应的控制组分配资源并限制资源的使用。</p> 
<p>如果我们想要创建一个新的 cgroup 只需要在想要分配或者限制资源的子系统下面创建一个新的文件夹，然后这个文件夹下就会自动出现很多的内容，如果你在 Linux 上安装了 Docker，你就会发现所有子系统的目录下都有一个名为 Docker 的文件夹：</p> 
<pre><code class="prism language-bash">$ <span class="token function">ls</span> cpu
cgroup.clone_children  
<span class="token punctuation">..</span>.
cpu.stat  
docker  
notify_on_release 
release_agent 
tasks

$ <span class="token function">ls</span> cpu/docker/
9c3057f1291b53fd54a3d12023d2644efe6a7db6ddf330436ae73ac92d401cf1 
cgroup.clone_children  
<span class="token punctuation">..</span>.
cpu.stat  
notify_on_release 
release_agent 
tasks
</code></pre> 
<p>9c3057xxx 其实就是我们运行的一个 Docker 容器，启动这个容器时，Docker 会为这个容器创建一个与容器标识符相同的 CGroup，在当前的主机上 CGroup 就会有以下的层级关系：</p> 
<p><img src="https://images2.imgbox.com/c2/d5/YDT7gxtn_o.png" alt=""></p> 
<p>每一个 CGroup 下面都有一个 tasks 文件，其中存储着属于当前控制组的所有进程的 pid，作为负责 cpu 的子系统，cpu.cfs_quota_us 文件中的内容能够对 CPU 的使用作出限制，如果当前文件的内容为 50000，那么当前控制组中的全部进程的 CPU 占用率不能超过 50%。</p> 
<p>如果系统管理员想要控制 Docker 某个容器的资源使用率就可以在 docker 这个父控制组下面找到对应的子控制组并且改变它们对应文件的内容，当然我们也可以直接在程序运行时就使用参数，让 Docker 进程去改变相应文件中的内容。</p> 
<p>当我们使用 Docker 关闭掉正在运行的容器时，Docker 的子控制组对应的文件夹也会被 Docker 进程移除，Docker 在使用 CGroup 时其实也只是做了一些创建文件夹改变文件内容的文件操作，不过 CGroup 的使用也确实解决了我们限制子容器资源占用的问题，系统管理员能够为多个容器合理的分配资源并且不会出现多个容器互相抢占资源的问题。</p> 
<h3><a id="dockersLXCAUFS_4056"></a>总之：dockers=LXC+AUFS</h3> 
<p>docker为LXC+AUFS组合：</p> 
<ul><li>LXC负责资源管理</li><li>AUFS负责镜像管理；</li></ul> 
<p>而LXC包括cgroup，namespace，chroot等组件，并通过cgroup资源管理，</p> 
<p>那么，从资源管理的角度来看，Docker，LXC, Cgroup三者的关系是怎样的呢？</p> 
<p>cgroup是在底层落实资源管理，LXC在cgroup上面封装了一层，随后，docker有在LXC封装了一层；</p> 
<p><img src="https://images2.imgbox.com/d5/69/8w3cCF0s_o.png" alt=""></p> 
<p><strong>Cgroup其实就是linux提供的一种限制记录，隔离进程组所使用的物理资源管理机制；</strong></p> 
<p><strong>也就是说，Cgroup是LXC为实现虚拟化所使用资源管理手段，我们可以这样说，底层没有cgroup支持，也就没有lxc，更别说docker的存在了，这是我们需要掌握和理解的，三者之间的关系概念</strong></p> 
<p>我们在把重心转移到LXC这个相当于中间件上，上述我们提到LXC是建立在cgroup基础上的，</p> 
<p>我们可以粗略的认为<strong>LXC=Cgroup+namespace+Chroot+veth+用户控制脚本；</strong></p> 
<p><strong>LXC利用内核的新特性（cgroup）来提供用户空间的对象，用来保证资源的隔离和对应用系统资源的限制；</strong></p> 
<p>Docker容器的文件系统最早是建立在Aufs基础上的，Aufs是一种Union FS，</p> 
<p>简单来说就<strong>是支持将不同的目录挂载到同一个虚拟文件系统之下，并实现一种 layer的概念,</strong></p> 
<p>由于Aufs未能加入到linux内核中，考虑到兼容性的问题，便加入了Devicemapper的支持，Docker目前默认是建立在Devicemapper基础上，</p> 
<p><strong>devicemapper用户控件相关部分主要负责配置具体的策略和控制逻辑，</strong></p> 
<p>比如逻辑设备和哪些物理设备建立映射，怎么建立这些映射关系等，而具体过滤和重定向IO请求的工作有内核中相关代码完成，</p> 
<p>因此整个device mapper机制由两部分组成–内核空间的device mapper驱动，</p> 
<p>用户控件的device mapper库以及它提供的dmsetup工具；</p> 
<h3><a id="docker_4105"></a>深入解读docker网络</h3> 
<p>当你开始大规模使用docker时，你会发现需要了解很多关于网络的知识。docker作为目前最火的轻量级容器技术，有很多令人称道的功能，如docker的镜像管理。然而，docker同样有着很多不完善的地方，网络方面就是Docker比较薄弱的部分。因此，作为一名运维工程师有必要深入了解docker的网络知识，以满足更高的网络需求。作为一名微服开发工程师，简单了解docker网络环节即可。本章节首先介绍了Docker自身的3种local网络工作方式，然后介绍一些docker自定义网络模式。</p> 
<p>docker安装后会自动创建3种网络:</p> 
<ul><li>bridge</li><li>host</li><li>none</li></ul> 
<pre><code class="prism language-bash">docker network <span class="token function">ls</span>
</code></pre> 
<h4><a id="docker_4119"></a>docker网络理论部分</h4> 
<p>docker使用Linux桥接网卡，在宿主机虚拟一个docker容器网桥(docker0)，docker启动一个容器时会根据docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时docker网桥是每个容器的默认网关。</p> 
<p>因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p> 
<p>docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。</p> 
<p>如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。</p> 
<pre><code class="prism language-bash"><span class="token comment"># 使用命令查看docker网络部分</span>
docker info
</code></pre> 
<h4><a id="Docker_4136"></a>Docker网络模式</h4> 
<table><thead><tr><th>Docker<strong>网络模式</strong></th><th>配置</th><th>说明</th></tr></thead><tbody><tr><td>host模式</td><td>–net=host</td><td>容器和宿主机共享Network namespace。容器将不会虚拟出自己的网卡，配置自己的IP 等，而是使用宿主机的IP和端口。</td></tr><tr><td>container模式</td><td>–net=container:NAME_or_ID</td><td>容器和另外一个容器共享Network namespace。kubernetes中的pod就是多个容器共享一个Network namespace。创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。</td></tr><tr><td>none模式</td><td>–net=none</td><td>容器有独立的Network namespace，并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。该模式关闭了容器的网络功能。</td></tr><tr><td>bridge模式</td><td>–net=bridge</td><td>（默认为该模式）。此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。</td></tr><tr><td>Macvlan network</td><td>无</td><td>容器具备Mac地址，使其显示为网络上的物理设备</td></tr><tr><td>Overlay</td><td>无</td><td>(覆盖网络）： 利用VXLAN实现的bridge模式</td></tr></tbody></table> 
<h5><a id="bridge_4149"></a>bridge模式</h5> 
<p>默认的网络模式。bridge模式下容器没有一个公有ip,只有宿主机可以直接访问,外部主机是不可见的,但容器通过宿主机的NAT规则后可以访问外网。</p> 
<p>Bridge 桥接模式的实现步骤主要如下：</p> 
<ul><li>Docker Daemon 利用 veth pair 技术，在宿主机上创建两个虚拟网络接口设备，假设为veth0 和 veth1。而veth pair 技术的特性可以保证无论哪一个 veth 接收到网络报文，都会将报文传输给另一方。</li><li>Docker Daemon 将 veth0 附加到 Docker Daemon 创建的 docker0网桥上。保证宿主机的网络报文可以发往 veth0；</li><li>Docker Daemon 将 veth1 添加到 Docker Container 所属的 namespace 下，并被改名为eth0。如此一来，保证宿主机的网络报文若发往 veth0，则立即会被 eth0 接收，实现宿主机到Docker Container网络的联通性；同时，也保证 Docker Container 单独使用 eth0，实现容器网络环境的隔离性。</li></ul> 
<p>Bridge桥接模式的缺陷：</p> 
<ol><li>最明显的是，该模式下 Docker Container 不具有一个公有 IP，即和宿主机的 eth0 不处于同一个网段。导致的结果是宿主机以外的世界不能直接和容器进行通信。</li><li>虽然 NAT 模式经过中间处理实现了这一点，但是 NAT 模式仍然存在问题与不便，如：容器均需要在宿主机上竞争端口，容器内部服务的访问者需要使用服务发现获知服务的外部端口等。</li><li>另外 NAT 模式由于是在三层网络上的实现手段，故肯定会影响网络的传输效率。</li></ol> 
<p>注意：</p> 
<p>veth设备是成双成对出现的，一端是容器内部命名为eth0，一端是加入到网桥并命名的veth（通常命名为veth），它们组成了一个数据传输通道，一端进一端出，veth设备连接了两个网络设备并实现了数据通信</p> 
<h5><a id="host_4169"></a>host模式</h5> 
<p>相当于Vmware中的NAT模式，与宿主机在同一个网络中，但没有独立IP地址。</p> 
<p>如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p> 
<p>使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。</p> 
<p>host 网络模式需要在容器创建时指定–network=host</p> 
<p>host 模式是 bridge 桥接模式很好的补充。采用 host 模式的 Docker Container，可以直接使用宿主机的 IP地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换。</p> 
<p>host模式可以让容器共享宿主机网络栈,这样的好处是外部主机与容器直接通信,但是容器的网络缺少隔离性。</p> 
<p>Host 网络模式的缺陷：</p> 
<p>最明显的是 Docker Container 网络环境隔离性的弱化。即容器不再拥有隔离、独立的网络环境。<br> 另外，使用 host 模式的 Docker Container 虽然可以让容器内部的服务和传统情况无差别、无改造的使用，但是由于网络隔离性的弱化，该容器会与宿主机共享竞争网络栈的使用；</p> 
<p>另外，容器内部将不再拥有所有的端口资源，原因是部分端口资源已经被宿主机本身的服务占用，还有部分端口已经用以 bridge 网络模式容器的端口映射。</p> 
<h5><a id="Container_4190"></a>Container网络模式</h5> 
<p>一种特殊host 网络模式</p> 
<p>Container 网络模式是 Docker 中一种较为特别的网络的模式。在容器创建时使用–<br> network=container:vm1指定。(vm1指定的是运行的容器名)</p> 
<p>处于这个模式下的 Docker 容器会共享一个网络环境,这样两个容器之间可以使用localhost高效快速通信。</p> 
<p>缺陷：它并没有改善容器与宿主机以外世界通信的情况（和桥接模式一样，不能连接宿主机以外的其他设备）。</p> 
<p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。</p> 
<p>同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p> 
<h5><a id="none_4205"></a>none模式</h5> 
<p>使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p> 
<p>这种网络模式下容器只有lo回环网络，没有其他网卡。none模式可以在容器创建时通过<code>--network=none</code>来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</p> 
<h5><a id="overlay__4211"></a>overlay 网络模式</h5> 
<p>Overlay 网络，也称为覆盖网络。主要用于docker集群部署。</p> 
<p>Overlay 网络的实现方式和方案有多种。Docker自身集成了一种，基于VXLAN隧道技术实现。<br> Overlay 网络主要用于实现跨主机容器之间的通信。</p> 
<p>应用场景：需要管理成百上千个跨主机的容器集群的网络时</p> 
<h5><a id="macvlan__4220"></a>macvlan 网络模式</h5> 
<p>macvlan网络模式，最主要的特征就是他们的通信会直接基于mac地址进行转发。</p> 
<p>这时宿主机其实充当一个二层交换机。Docker会维护着一个MAC地址表，当宿主机网络收到一个数据包后，直接根据mac地址找到对应的容器，再把数据交给对应的容器。</p> 
<p>容器之间可以直接通过IP互通，通过宿主机上内建的虚拟网络设备（创建macvlan网络时自动创建），但与主机无法直接利用IP互通。</p> 
<p>应用场景：由于每个外来的数据包的目的mac地址就是容器的mac地址，这时每个容器对于外面网络来说就相当于一个真实的物理网络设备。因此当需要让容器来的网络看起来是一个真实的物理机时，使用macvlan模式</p> 
<p>Macvlan是一个新的尝试，是真正的网络虚拟化技术的转折点。Linux实现非常轻量级，因为与传统的Linux Bridge隔离相比，它们只是简单地与一个Linux以太网接口或子接口相关联，以实现网络之间的分离和与物理网络的连接。</p> 
<p>Macvlan提供了许多独特的功能，并有充足的空间进一步创新与各种模式。这些方法的两个高级优点是绕过Linux网桥的正面性能以及移动部件少的简单性。删除传统上驻留在Docker主机NIC和容器接口之间的网桥留下了一个非常简单的设置，包括容器接口，直接连接到Docker主机接口。由于在这些情况下没有端口映射，因此可以轻松访问外部服务。</p> 
<p>Macvlan Bridge模式每个容器都有唯一的MAC地址，用于跟踪Docker主机的MAC到端口映射。</p> 
<p>Macvlan驱动程序网络连接到父Docker主机接口。示例是物理接口，例如eth0，用于802.1q VLAN标记的子接口eth0.10（.10代表VLAN 10）或甚至绑定的主机适配器，将两个以太网接口捆绑为单个逻辑接口。 指定的网关由网络基础设施提供的主机外部。 每个Macvlan Bridge模式的Docker网络彼此隔离，一次只能有一个网络连接到父节点。</p> 
<p>每个主机适配器有一个理论限制，每个主机适配器可以连接一个Docker网络。 同一子网内的任何容器都可以与没有网关的同一网络中的任何其他容器进行通信macvlan bridge。 相同的docker network命令适用于vlan驱动程序。 在Macvlan模式下，在两个网络/子网之间没有外部进程路由的情况下，单独网络上的容器无法互相访问。这也适用于同一码头网络内的多个子网。</p> 
<h4><a id="_4240"></a>网络实操</h4> 
<p>拉取镜像</p> 
<pre><code class="prism language-bash">docker pull nginx:1.19.3-alpine
</code></pre> 
<p>备份镜像</p> 
<pre><code class="prism language-bash">docker save nginx:1.19.3-alpine -o nginx.1.19.3.alpine.tar
</code></pre> 
<p>导入镜像</p> 
<pre><code class="prism language-bash">docker load -i nginx.1.19.3.alpine.tar
</code></pre> 
<h5><a id="bridge_4260"></a>bridge网络</h5> 
<p>本章节学习docker的bridge网络，bridge网络表现形式就是docker0这个网络接口。</p> 
<p>容器默认都是通过docker0这个接口进行通信。</p> 
<p>也可以通过docker0去和本机的以太网接口连接，这样容器内部才能访问互联网。</p> 
<pre><code class="prism language-bash"><span class="token comment"># 查看docker0网络，在默认环境中，一个名为docker0的linux bridge自动被创建好了，其上有一个 </span>
docker0 内部接口，IP地址为172.17.0.1/16
<span class="token function">ip</span> a
<span class="token comment"># 查看docker 网络</span>
docker network <span class="token function">ls</span>
<span class="token comment"># 查看bridge网络详情。主要关注Containers节点信息。</span>
docker network inspect bridge
</code></pre> 
<h5><a id="docker0_4278"></a>docker0详解</h5> 
<p>运行镜像</p> 
<pre><code class="prism language-bash">docker run -itd --name nginx1 nginx:1.19.3-alpine
<span class="token comment"># 查看bridge网络详情。主要关注Containers节点信息。发现nginx1容器默认使用bridge网络</span>
docker network inspect bridge
</code></pre> 
<p>容器创建时IP地址的分配</p> 
<pre><code class="prism language-bash"><span class="token comment"># 查看docker100主机网络。发现多出一块网卡veth62aef5e@if8</span>
<span class="token function">ip</span> a
</code></pre> 
<p>Docker 创建一个容器的时候，会执行如下操作：</p> 
<ul><li>创建一对虚拟接口/网卡，也就是veth pair，分别放到本地主机和新容器中；</li><li>本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 vetha596da4；</li><li>容器一端放到新容器中，并修改名字作为 eth0，这个网卡/接口只在容器的名字空间可见；</li><li>从网桥可用地址段中（也就是与该bridge对应的network）获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 vetha596da4。</li></ul> 
<p>完成这些之后，容器就可以使用 eth0 虚拟网卡来连接其他容器和其他网络。</p> 
<p>如果不指定–network，创建的容器默认都会挂到 docker0 上，使用本地主机上 docker0 接口的 IP 作为所有容器的默认网关。</p> 
<pre><code class="prism language-bash">第一种方式：
docker <span class="token builtin class-name">exec</span> -it nginx1 <span class="token function">sh</span>
<span class="token function">ip</span> a
第二种方式：
docker <span class="token builtin class-name">exec</span> -it nginx1 <span class="token function">ip</span> a
</code></pre> 
<p>安装brctl</p> 
<pre><code class="prism language-bash">yum <span class="token function">install</span> -y bridge-utils
</code></pre> 
<p>运行命令</p> 
<pre><code class="prism language-bash">brctl show
</code></pre> 
<p><img src="https://images2.imgbox.com/5b/12/RNomS5wK_o.png" alt=""></p> 
<h5><a id="_4330"></a>多容器之间通讯</h5> 
<pre><code class="prism language-bash">docker run -itd --name nginx1 nginx:1.19.3-alpine
docker run -itd --name nginx2 nginx:1.19.3-alpine
docker network inspect bridge
docker <span class="token builtin class-name">exec</span> -it nginx1 <span class="token function">sh</span>
<span class="token function">ping</span> <span class="token number">172.17</span>.0.2
docker <span class="token builtin class-name">exec</span> -it nginx2 <span class="token function">sh</span>
<span class="token function">ping</span> <span class="token number">172.17</span>.0.2
<span class="token function">ping</span> www.baidu.com
<span class="token function">ping</span> nginx1
</code></pre> 
<p>容器IP地址会发生变化</p> 
<pre><code class="prism language-bash">docker stop nginx1 nginx2
先启动nginx2，在启动nginx1
docker start nginx2
docker start nginx1
docker network inspect bridge
</code></pre> 
<h5><a id="link_4356"></a>link容器</h5> 
<p>学习docker run命令的link参数</p> 
<ul><li><code>--link=[]</code>: 添加链接到另一个容器；</li></ul> 
<p>使用link的场景：</p> 
<p>在企业开发环境中，我们有一个mysql的服务的容器mysql_1，还有一个web应用程序web_1，肯定web_1这台容器肯定要连接mysql_1这个数据库。</p> 
<p>前面网络命名空间的知识告诉我们，两个容器需要能通信，需要知道对方的具体的IP地址。</p> 
<p>生产环境还比较好，IP地址很少变化，但是在我们内部测试环境，容器部署的IP地址是可能不断变化的，所以，开发人员不能在代码中写死数据库的IP地址。</p> 
<p>这个时候，我们就可以利用容器之间link来解决这个问题。不推荐大家使用该参数</p> 
<p>下面，我们来介绍如何通过容器名称来进行ping，而不是通过IP地址。</p> 
<pre><code class="prism language-bash">docker <span class="token function">rm</span> -f nginx2
docker run -itd --name nginx2 --link nginx1 nginx:1.19.3-alpine docker <span class="token builtin class-name">exec</span> -it nginx2 <span class="token function">sh</span>
<span class="token function">ping</span> <span class="token number">172.17</span>.0.2
<span class="token function">ping</span> www.baidu.com
<span class="token function">ping</span> nginx1
</code></pre> 
<ul><li>上面link命令，是在nginx2容器启动时link到nginx1容器，因此，在nginx2容器里面可以ping通<br> nginx1容器名，link的作用相当于添加了DNS解析。这里提醒下，在nginx1容器里去ping nginx2<br> 容器是不通的，因为link关系是单向的，不可逆。</li><li>实际工作中，docker官网已经不推荐我们使用link参数。</li><li>docker用其他方式替换掉link参数</li></ul> 
<h6><a id="bridge_4388"></a>新建bridge网络</h6> 
<pre><code class="prism language-bash">docker network create -d bridge lagou-bridge
</code></pre> 
<p>上面命令参数-d 是指DRIVER的类型，后面的lagou-bridge是network的自定义名称，这个和docker0是类似的。下面开始介绍，如何把容器连接到lagou-bridge这个网络。</p> 
<p>启动一个nginx的容器nginx3，并通过参数network connect来连接lagou-bridge网络。在启动容器<br> nginx3之前，我们查看目前还没有容器连接到了lagou-bridge这个网络上。</p> 
<pre><code class="prism language-bash">brctl show
docker network <span class="token function">ls</span>
docker network inspect lagou-bridge
docker run -itd --name nginx3 --network lagou-bridge nginx:1.19.3-alpine brctl show
docker network inspect lagou-bridge
</code></pre> 
<h6><a id="lagoubridge_4407"></a>把一个运行中容器连接到lagou-bridge网络</h6> 
<pre><code class="prism language-bash">docker network connect lagou-bridge nginx2
docker network inspect lagou-bridge
docker <span class="token builtin class-name">exec</span> -it nginx2 <span class="token function">sh</span>
<span class="token function">ping</span> nginx3
docker <span class="token builtin class-name">exec</span> -it nginx3 <span class="token function">sh</span>
<span class="token function">ping</span> nginx2
</code></pre> 
<h5><a id="none_4420"></a>none网络</h5> 
<p>环境准备，先stop和rm掉全部之前开启的容器。并且把前面创建的lagou-bridge网络也删除。当然，更简单的办法是使用快照方式。将docker-100主机恢复到docker初始化安装时。</p> 
<pre><code class="prism language-bash">docker <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -aq<span class="token variable">)</span></span>
docker network <span class="token function">rm</span> lagou-bridge
docker network <span class="token function">ls</span>
</code></pre> 
<p>启动一个ngnix的容器nginx1，并且连接到none网络。然后执行docker network inspect none，看看容器信息</p> 
<pre><code class="prism language-bash">docker run -itd --name nginx1 --network none nginx:1.19.3-alpine docker network inspect none
</code></pre> 
<p>注意，容器使用none模式，是没有物理地址和IP地址。我们可以进入到nginx1容器里，执行ip a命令看看。只有一个lo接口，没有其他网络接口，没有IP。也就是说，使用none模式，这个容器是不能被其他容器访问。这种使用场景很少，只有项目安全性很高的功能才能使用到。例如：密码加密算法容器。</p> 
<pre><code class="prism language-bash">docker <span class="token builtin class-name">exec</span> -it nginx1 <span class="token function">sh</span>
<span class="token function">ip</span> a
</code></pre> 
<h5><a id="host_4443"></a>host网络</h5> 
<p>前面学习none网络模式特点就是，容器没有IP地址，不能和其他容器通信。下面来看看host网络是什么特点。我们使用前面命令，启动一个nginx的nginx2容器，连接到host网络。然后<code>docker network inspect host</code>，看看容器信息。</p> 
<pre><code class="prism language-bash">docker run -itd --name nginx2 --network <span class="token function">host</span> nginx:1.19.3-alpine 
docker network inspect <span class="token function">host</span>
</code></pre> 
<p>这里来看，也不显示IP地址。那么是不是和none一样，肯定不是，不然也不会设计none和host网络进行区分。下面我们进入nginx2容器，执行ip a看看效果。我们在容器里执行ip a，发现打印内容和在linux本机外执行ip a是一样的。</p> 
<pre><code class="prism language-bash">docker <span class="token builtin class-name">exec</span> -it nginx2 <span class="token function">sh</span>
<span class="token function">ip</span> a
</code></pre> 
<p>这说明什么呢？</p> 
<p>容器使用了host模式，说明容器和外层linux主机共享一套网络接口。VMware公司的虚拟机管理软件，其中网络设置，也有host这个模式，作用也是一样，虚拟机里面使用网络和你自己外层机器是一模一样的。这种容器和本机使用共享一套网络接口，缺点还是很明显的，例如我们知道web服务器一般端口是80，共享了一套网络接口，那么你这台机器上只能启动一个nginx端口为80的服务器<br> 了。否则，出现端口被占用的情况。</p> 
<p>本篇很简单，就是简单了解下docker中none和host网络模式。学习重点还是如何使用bridge网络。</p> 
<h4><a id="_4466"></a>网络命令汇总</h4> 
<pre><code class="prism language-bash">docker network --help
网络常用命令汇总
connect Connect a container to a network
create Create a network
disconnect Disconnect a container from a network
inspect Display detailed information on one or <span class="token function">more</span> networks <span class="token function">ls</span> List networks
prune Remove all unused networks
<span class="token function">rm</span> Remove one or <span class="token function">more</span> networks
</code></pre> 
<h5><a id="_4479"></a>查看网络</h5> 
<pre><code class="prism language-bash">查看网络 – docker network <span class="token function">ls</span>
<span class="token comment"># 作用：</span>
查看已经建立的网络对象
<span class="token comment"># 命令格式：</span>
docker network <span class="token function">ls</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span>
<span class="token comment"># 命令参数(OPTIONS)：</span>
-f, --filter filter 过滤条件<span class="token punctuation">(</span>如 <span class="token string">'driver=bridge’)
 --format string 格式化打印结果
--no-trunc 不缩略显示
-q, --quiet 只显示网络对象的ID
# 注意：
默认情况下，docker安装完成后，会自动创建bridge、host、none三种网络驱动 
# 命令演示
docker network ls
docker network ls --no-trunc
docker network ls -f '</span><span class="token assign-left variable">driver</span><span class="token operator">=</span>host' 
</code></pre> 
<h5><a id="_4500"></a>创建网络</h5> 
<pre><code class="prism language-bash">创建网络 – docker network create
<span class="token comment"># 作用：</span>
创建新的网络对象
<span class="token comment"># 命令格式：</span>
docker network create <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> NETWORK
<span class="token comment"># 命令参数(OPTIONS)：</span>
-d, --driver string 指定网络的驱动<span class="token punctuation">(</span>默认 <span class="token string">"bridge"</span><span class="token punctuation">)</span>
--subnet strings 指定子网网段<span class="token punctuation">(</span>如192.168.0.0/16、172.88.0.0/24<span class="token punctuation">)</span>
--ip-range strings 执行容器的IP范围，格式同subnet参数
--gateway strings 子网的IPv4 or IPv6网关，如<span class="token punctuation">(</span><span class="token number">192.168</span>.0.1<span class="token punctuation">)</span>
<span class="token comment"># 注意：</span>
host和none模式网络只能存在一个
docker自带的overlay 网络创建依赖于docker swarm<span class="token punctuation">(</span>集群负载均衡<span class="token punctuation">)</span>服务
<span class="token number">192.168</span>.0.0/16 等于 <span class="token number">192.168</span>.0.0~192.168.255.255192.168.8.0/24
<span class="token number">172.88</span>.0.0/24 等于 <span class="token number">172.88</span>.0.0~172.88.0.255
<span class="token comment"># 命令演示</span>
docker network <span class="token function">ls</span>
docker network create -d bridge my-bridge
docker network <span class="token function">ls</span>
</code></pre> 
<h5><a id="_4524"></a>网络删除</h5> 
<pre><code class="prism language-bash">网络删除 – docker network <span class="token function">rm</span>
<span class="token comment"># 作用：</span>
删除一个或多个网络
<span class="token comment"># 命令格式：</span>
docker network <span class="token function">rm</span> NETWORK <span class="token punctuation">[</span>NETWORK<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 命令参数(OPTIONS)：</span>
无
</code></pre> 
<h5><a id="_4536"></a>查看网络详细信息</h5> 
<pre><code class="prism language-bash">查看网络详细信息 docker network inspect
<span class="token comment"># 作用：</span>
查看一个或多个网络的详细信息
<span class="token comment"># 命令格式：</span>
docker network inspect <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> NETWORK <span class="token punctuation">[</span>NETWORK<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
或者 docker inspect <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> NETWORK <span class="token punctuation">[</span>NETWORK<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 命令参数(OPTIONS)：</span>
-f, --format string 根据format输出结果
</code></pre> 
<h5><a id="_4549"></a>使用网络</h5> 
<pre><code class="prism language-bash">使用网络 – docker run –-network
<span class="token comment"># 作用：</span>
为启动的容器指定网络模式
<span class="token comment"># 命令格式：</span>
docker run/create --network NETWORK
<span class="token comment"># 命令参数(OPTIONS)：</span>
无
<span class="token comment"># 注意：</span>
默认情况下，docker创建或启动容器时，会默认使用名为bridge的网络
</code></pre> 
<h5><a id="_4563"></a>网络连接与断开</h5> 
<pre><code class="prism language-bash">网络连接与断开 – docker network connect/disconnect
<span class="token comment"># 作用：</span>
将指定容器与指定网络进行连接或者断开连接
<span class="token comment"># 命令格式：</span>
docker network connect <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> NETWORK CONTAINER
docker network disconnect <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> NETWORK CONTAINER
<span class="token comment"># 命令参数(OPTIONS)：</span>
-f, --force 强制断开连接<span class="token punctuation">(</span>用于disconnect<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="DockerCompose__4578"></a>Docker-Compose 简介</h3> 
<p>Docker-Compose 项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。</p> 
<p>Docker-Compose 项目由 Python 编写，调用 Docker 服务提供的API来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用Compose 来进行编排管理。</p> 
<h4><a id="DockerCompose_Docker_4584"></a>Docker-Compose 用来实现Docker容器快速编排</h4> 
<p>通过 Docker-Compose ，不需要使用shell脚本来启动容器，而使用 YAML 文件来配置应用程序需要的所有服务，然后使用一个命令，根据 YAML 的文件配置创建并启动所有服务。</p> 
<h5><a id="Dockercompose_4588"></a>Docker-compose模板文件简介</h5> 
<p>Compose允许用户通过一个docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p> 
<p>Compose模板文件是一个定义服务、网络和卷的YAML文件。</p> 
<p>Compose模板文件默认路径是当前目录下的docker-compose.yml，可以使用.yml或.yaml作为文件扩展名。</p> 
<p>Docker-Compose标准模板文件应该包含version、services、networks 三大部分，最关键的是services和networks两个部分。</p> 
<h5><a id="eg_4598"></a>eg：</h5> 
<pre><code class="prism language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.5'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">nacos1</span><span class="token punctuation">:</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nacos/nacos<span class="token punctuation">-</span>server<span class="token punctuation">:</span>$<span class="token punctuation">{<!-- --></span>NACOS_VERSION<span class="token punctuation">}</span>
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> nacos1
    <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> <span class="token string">"8001:8001"</span>
     <span class="token punctuation">-</span> <span class="token string">"8011:9555"</span>
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">resources</span><span class="token punctuation">:</span>
        <span class="token key atrule">limits</span><span class="token punctuation">:</span>
          <span class="token key atrule">cpus</span><span class="token punctuation">:</span> <span class="token string">'0.50'</span>
          <span class="token key atrule">memory</span><span class="token punctuation">:</span> 1024M 
    <span class="token key atrule">env_file</span><span class="token punctuation">:</span> 
     <span class="token punctuation">-</span> ./nacos.env 
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
        <span class="token key atrule">NACOS_SERVER_IP</span><span class="token punctuation">:</span> $<span class="token punctuation">{<!-- --></span>NACOS_SERVER_IP_1<span class="token punctuation">}</span>
        <span class="token key atrule">NACOS_APPLICATION_PORT</span><span class="token punctuation">:</span> <span class="token number">8001</span>
        <span class="token key atrule">NACOS_SERVERS</span><span class="token punctuation">:</span> $<span class="token punctuation">{<!-- --></span>NACOS_SERVERS<span class="token punctuation">}</span>     
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> ./logs_01/<span class="token punctuation">:</span>/home/nacos/logs/
     <span class="token punctuation">-</span> ./data_01/<span class="token punctuation">:</span>/home/nacos/data/
     <span class="token punctuation">-</span> ./config/<span class="token punctuation">:</span>/home/nacos/config/
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ha<span class="token punctuation">-</span>network<span class="token punctuation">-</span>overlay
  <span class="token key atrule">nacos2</span><span class="token punctuation">:</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nacos/nacos<span class="token punctuation">-</span>server<span class="token punctuation">:</span>$<span class="token punctuation">{<!-- --></span>NACOS_VERSION<span class="token punctuation">}</span>
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> nacos2
    <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> <span class="token string">"8002:8002"</span>
     <span class="token punctuation">-</span> <span class="token string">"8012:9555"</span>
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">resources</span><span class="token punctuation">:</span>
        <span class="token key atrule">limits</span><span class="token punctuation">:</span>
          <span class="token key atrule">cpus</span><span class="token punctuation">:</span> <span class="token string">'0.50'</span>
          <span class="token key atrule">memory</span><span class="token punctuation">:</span> 1024M    
    <span class="token key atrule">env_file</span><span class="token punctuation">:</span> 
     <span class="token punctuation">-</span> ./nacos.env     
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
        <span class="token key atrule">NACOS_SERVER_IP</span><span class="token punctuation">:</span> $<span class="token punctuation">{<!-- --></span>NACOS_SERVER_IP_2<span class="token punctuation">}</span>
        <span class="token key atrule">NACOS_APPLICATION_PORT</span><span class="token punctuation">:</span> <span class="token number">8002</span>
        <span class="token key atrule">NACOS_SERVERS</span><span class="token punctuation">:</span> $<span class="token punctuation">{<!-- --></span>NACOS_SERVERS<span class="token punctuation">}</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> ./logs_02/<span class="token punctuation">:</span>/home/nacos/logs/
     <span class="token punctuation">-</span> ./data_02/<span class="token punctuation">:</span>/home/nacos/data/
     <span class="token punctuation">-</span> ./config/<span class="token punctuation">:</span>/home/nacos/config/
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ha<span class="token punctuation">-</span>network<span class="token punctuation">-</span>overlay
  <span class="token key atrule">nacos3</span><span class="token punctuation">:</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nacos/nacos<span class="token punctuation">-</span>server<span class="token punctuation">:</span>$<span class="token punctuation">{<!-- --></span>NACOS_VERSION<span class="token punctuation">}</span>
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> nacos3
    <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> <span class="token string">"8003:8003"</span>
     <span class="token punctuation">-</span> <span class="token string">"8013:9555"</span>
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">resources</span><span class="token punctuation">:</span>
        <span class="token key atrule">limits</span><span class="token punctuation">:</span>
          <span class="token key atrule">cpus</span><span class="token punctuation">:</span> <span class="token string">'0.50'</span>
          <span class="token key atrule">memory</span><span class="token punctuation">:</span> 1024M    
    <span class="token key atrule">env_file</span><span class="token punctuation">:</span> 
     <span class="token punctuation">-</span> ./nacos.env 
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
        <span class="token key atrule">NACOS_SERVER_IP</span><span class="token punctuation">:</span> $<span class="token punctuation">{<!-- --></span>NACOS_SERVER_IP_3<span class="token punctuation">}</span>
        <span class="token key atrule">NACOS_APPLICATION_PORT</span><span class="token punctuation">:</span> <span class="token number">8003</span>
        <span class="token key atrule">NACOS_SERVERS</span><span class="token punctuation">:</span> $<span class="token punctuation">{<!-- --></span>NACOS_SERVERS<span class="token punctuation">}</span>         
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> ./logs_03/<span class="token punctuation">:</span>/home/nacos/logs/
     <span class="token punctuation">-</span> ./data_03/<span class="token punctuation">:</span>/home/nacos/data/
     <span class="token punctuation">-</span> ./config/<span class="token punctuation">:</span>/home/nacos/config/
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ha<span class="token punctuation">-</span>network<span class="token punctuation">-</span>overlay
<span class="token key atrule">networks</span><span class="token punctuation">:</span>
   <span class="token key atrule">ha-network-overlay</span><span class="token punctuation">:</span>
     <span class="token key atrule">external</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
</code></pre> 
<h5><a id="DockerCompose__4683"></a>Docker-Compose 的编排处出来的部署架构</h5> 
<p><img src="https://images2.imgbox.com/de/71/fLMdD4dN_o.png" alt=""></p> 
<h3><a id="dockercompose__4687"></a>docker-compose 快速编排</h3> 
<p>Docker-Compose 项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。</p> 
<p>Docker-Compose 项目由 Python 编写，调用 Docker 服务提供的API来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用Compose 来进行编排管理。</p> 
<p>首先检查 版本</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment">#  /usr/local/bin/docker-compose -version</span>
docker-compose version <span class="token number">1.25</span>.1, build a82fef07
</code></pre> 
<p>如果安装好了，就ok了，如果没有安装，则安装docker</p> 
<p>从github上下载docker-compose二进制文件安装</p> 
<p>下载最新版的docker-compose文件</p> 
<pre><code class="prism language-bash"><span class="token function">curl</span> -L https://github.com/docker/compose/releases/download/1.25.1/docker-compose-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -s<span class="token variable">`</span></span>-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -m<span class="token variable">`</span></span> -o /usr/local/bin/docker-compose
</code></pre> 
<blockquote> 
 <p>注明：离线安装包已经提供。上传后，复制到/usr/local/bin/即可</p> 
</blockquote> 
<pre><code class="prism language-bash"><span class="token function">cp</span> /root/docker-compose  /usr/local/bin/
</code></pre> 
<p>添加可执行权限</p> 
<pre><code class="prism language-bash"><span class="token function">chmod</span> +x /usr/local/bin/docker-compose
</code></pre> 
<p>测试安装结果</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker-compose --version </span>
docker-compose version <span class="token number">1.25</span>.1, build a82fef07

<span class="token function">cp</span> /root/docker-compose  /usr/local/bin/
<span class="token function">chmod</span> +x /usr/local/bin/docker-compose
docker-compose --version
</code></pre> 
<h4><a id="DockerCompose__4741"></a>Docker-Compose 的编排结构</h4> 
<p>Docker-Compose 将所管理的容器分为三层</p> 
<ul><li><strong>工程</strong>（project）：一个工程包含多个服务</li><li><strong>服务</strong>（service）：一个服务当中可包括多个容器实例</li><li><strong>容器</strong>（container）</li></ul> 
<p>Docker-Compose 运行目录下的所有文件（<strong>docker-compose.yml</strong>、<strong>extends文件</strong> 或 <strong>环境变量文件</strong>等）组成一个工程，若无特殊指定 <strong>工程名即为当前目录名</strong>。</p> 
<p>Docker Compose 的核心就是其配置文件，采用 YAML 格式，默认为 <code>docker-compose.yml</code> 。</p> 
<p><img src="https://images2.imgbox.com/ae/81/5Y8afR0X_o.png" alt=""></p> 
<p><strong>一个工程当中可包含多个服务</strong>，<strong>每个服务中定义了容器运行的镜像、参数、依赖</strong>。</p> 
<p><strong>一个服务当中可包括多个容器实例</strong>，**但是：Docker-Compose 并没有解决负载均衡的问题，**因此需要借助其它工具实现服务发现及负载均衡，比如 Consul 技术。</p> 
<p><strong>Docker-Compose 的工程配置文件默认为 docker-compose.yml</strong>，可通过环境变量 <strong><code>COMPOSB_FILE</code> 或 <code>-f</code></strong> 参数自定义配置文件，<strong>其定义了多个有依赖关系的服务及每个服务运行的容器。</strong></p> 
<p><strong>Compose 允许用户通过一个单独的 docker-compose.yml 模板文件（YAML格式）来定义一组相关联的应用容器为一个项目 (project)。</strong></p> 
<h4><a id="YAML_4773"></a>YAML模板文件语法</h4> 
<p>默认的模板文件是docker-compose.yml,其中定义的每个服务都必须通过image指令指定镜像，也可以通过build指令（需要Dockerfile）来自动构建。</p> 
<p>其他大部分都跟docker run 中类似。 如果使用build指令，在Dockerfile中设置的选项（例如：CMD,EXPOSE,VOLUME,ENV等）将自动被获取，无需在docker-compose.yml中再次被设置。</p> 
<h4><a id="dockercomposeyml__4781"></a>docker-compose.yml 语法说明</h4> 
<h5><a id="1image_4783"></a>1、image</h5> 
<p>指定为镜像名称或镜像ID。</p> 
<p>如果镜像不存在，Compose将尝试从互联网拉取这个镜像，例如： <code>image: ubuntu image: orchardup/postgresql image: a4bc65fd</code></p> 
<p>指定服务的镜像名，若本地不存在，则 Compose 会去仓库拉取这个镜像:</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
</code></pre> 
<h5><a id="2build_4799"></a>2、build</h5> 
<p>指定Dockerfile所在文件夹的路径。Compose将会利用他自动构建这个镜像，然后使用这个镜像。 <code>build: ./dir</code></p> 
<h5><a id="3command_4803"></a>3、command</h5> 
<p>覆盖容器启动后默认执行的命令。 <code>command: bundle exec thin -p 3000</code></p> 
<h5><a id="4links_4807"></a>4、links</h5> 
<p>链接到其他服务容器，使用服务名称(同时作为别名)或服务别名（SERVICE:ALIAS）都可以</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">links</span><span class="token punctuation">:</span>
 <span class="token punctuation">-</span> db
 <span class="token punctuation">-</span> db<span class="token punctuation">:</span>database
 <span class="token punctuation">-</span> redis
</code></pre> 
<p>注意：使用别名会自动在服务器中的/etc/hosts 里创建，如：172.17.2.186 db，相应的环境变量也会被创建。</p> 
<h5><a id="5external_links_4820"></a>5、external_links</h5> 
<p>链接到docker-compose.yml外部的容器，甚至并非是Compose管理的容器。参数格式和links类似。 external_links:</p> 
<pre><code class="prism language-yaml"><span class="token punctuation">-</span> redis_1
 <span class="token punctuation">-</span> project_db_1<span class="token punctuation">:</span>mysql
 <span class="token punctuation">-</span> project_db_2<span class="token punctuation">:</span>sqlserver
</code></pre> 
<h5><a id="6ports_4830"></a>6、ports</h5> 
<p>暴露端口信息。格式</p> 
<blockquote> 
 <p>宿主机器端口：容器端口（HOST:CONTAINER）</p> 
</blockquote> 
<p>或者仅仅指定容器的端口（宿主机器将会随机分配端口）都可以。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">ports</span><span class="token punctuation">:</span>
 <span class="token punctuation">-</span> <span class="token string">"3306"</span>
 <span class="token punctuation">-</span> <span class="token string">"8080:80"</span>
 <span class="token punctuation">-</span> <span class="token string">"127.0.0.1:8090:8001"</span>
</code></pre> 
<p>注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 你可能会得到错误得结果，因为 YAML 将会解析 xx:yy 这种数字格式为 60 进制。所以建议采用字符串格式。</p> 
<h5><a id="7expose_4847"></a>7、expose</h5> 
<p>暴露端口，与posts不同的是expose只可以暴露端口而不能映射到主机，只供外部服务连接使用；仅可以指定内部端口为参数。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">expose</span><span class="token punctuation">:</span>
 <span class="token punctuation">-</span> <span class="token string">"3000"</span>
 <span class="token punctuation">-</span> <span class="token string">"8000"</span>
</code></pre> 
<h5><a id="8volumes_4857"></a>8、volumes</h5> 
<p>设置卷挂载的路径。</p> 
<p>可以设置宿主机路径:容器路径（host:container）或加上访问模式（host:container:ro）ro就是readonly的意思，只读模式。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">volumes</span><span class="token punctuation">:</span>
 <span class="token punctuation">-</span> /var/lib/mysql<span class="token punctuation">:</span>/var/lib/mysql
 <span class="token punctuation">-</span> /configs/mysql<span class="token punctuation">:</span>/etc/configs/<span class="token punctuation">:</span>ro
</code></pre> 
<h5><a id="9volunes_from_4869"></a>9、volunes_from</h5> 
<p>挂载另一个服务或容器的所有数据卷。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">volumes_from</span><span class="token punctuation">:</span>
 <span class="token punctuation">-</span> service_name
 <span class="token punctuation">-</span> container_name
</code></pre> 
<h5><a id="10environment_4879"></a>10、environment</h5> 
<p>设置环境变量。可以属于数组或字典两种格式。</p> 
<p>如果只给定变量的名称则会自动加载它在Compose主机上的值，可以用来防止<strong>泄露不必要的数据</strong>。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">environment</span><span class="token punctuation">:</span>
 <span class="token punctuation">-</span> RACK_ENV=development
 <span class="token punctuation">-</span> SESSION_SECRET
</code></pre> 
<h5><a id="11env_file_4891"></a>11、env_file</h5> 
<p>从文件中获取环境变量，可以为单独的文件路径或列表。 如果通过<code>docker-compose -f FILE</code>指定了模板文件，则env_file中路径会基于模板文件路径。 如果有变量名称与environment指令冲突，则以后者为准。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">env_file</span><span class="token punctuation">:</span> .env
<span class="token key atrule">env_file</span><span class="token punctuation">:</span>
 <span class="token punctuation">-</span> ./common.env
 <span class="token punctuation">-</span> ./apps/web.env
 <span class="token punctuation">-</span> /opt/secrets.env
</code></pre> 
<p>环境变量文件中每一行都必须有注释，支持#开头的注释行。</p> 
<pre><code class="prism language-yaml"><span class="token comment"># common.env: Set Rails/Rack environment</span>
RACK_ENV=development
</code></pre> 
<h5><a id="12extends_4910"></a>12、extends</h5> 
<p>基于已有的服务进行服务扩展。例如我们已经有了一个webapp服务，模板文件为common.yml.</p> 
<pre><code class="prism language-yaml"><span class="token comment"># common.yml</span>
<span class="token key atrule">webapp</span><span class="token punctuation">:</span>
<span class="token key atrule">build</span><span class="token punctuation">:</span> ./webapp
<span class="token key atrule">environment</span><span class="token punctuation">:</span>
 <span class="token punctuation">-</span> DEBUG=false
 <span class="token punctuation">-</span> SEND_EMAILS=false
</code></pre> 
<p>编写一个新的 development.yml 文件，使用 common.yml 中的 webapp 服务进行扩展。 development.yml</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">web</span><span class="token punctuation">:</span>
<span class="token key atrule">extends</span><span class="token punctuation">:</span>
<span class="token key atrule">file</span><span class="token punctuation">:</span> common.yml
<span class="token key atrule">service</span><span class="token punctuation">:</span> 
  <span class="token key atrule">webapp</span><span class="token punctuation">:</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"8080:80"</span>
    <span class="token key atrule">links</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> db
    <span class="token key atrule">envelopment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> DEBUG=true
   <span class="token key atrule">db</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span><span class="token number">5.7</span>
</code></pre> 
<p>后者会自动继承common.yml中的webapp服务及相关的环境变量。</p> 
<h5><a id="13net_4943"></a>13、net</h5> 
<p>设置网络模式。使用和docker client 的 --net 参数一样的值。</p> 
<pre><code class="prism language-yaml"><span class="token comment"># 容器默认连接的网络，是所有Docker安装时都默认安装的docker0网络.</span>
<span class="token key atrule">net</span><span class="token punctuation">:</span> <span class="token string">"bridge"</span>
<span class="token comment"># 容器定制的网络栈.</span>
<span class="token key atrule">net</span><span class="token punctuation">:</span> <span class="token string">"none"</span>
<span class="token comment"># 使用另一个容器的网络配置</span>
<span class="token key atrule">net</span><span class="token punctuation">:</span> <span class="token string">"container:[name or id]"</span>
<span class="token comment"># 在宿主网络栈上添加一个容器，容器中的网络配置会与宿主的一样</span>
<span class="token key atrule">net</span><span class="token punctuation">:</span> <span class="token string">"host"</span>
</code></pre> 
<p>Docker会为每个节点自动创建三个网络： 网络名称 作用 bridge 容器默认连接的网络，是所有Docker安装时都默认安装的docker0网络 none 容器定制的网络栈 host 在宿主网络栈上添加一个容器，容器中的网络配置会与宿主的一样 附录： 操作名称 命令 创建网络 docker network create -d bridge mynet 查看网络列表 docker network ls</p> 
<h5><a id="14pid_4960"></a>14、pid</h5> 
<p>和宿主机系统共享进程命名空间，打开该选项的容器可以相互通过进程id来访问和操作。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">pid</span><span class="token punctuation">:</span> <span class="token string">"host"</span>
</code></pre> 
<h5><a id="15dns_4968"></a>15、dns</h5> 
<pre><code class="prism language-yaml">配置DNS服务器。可以是一个值，也可以是一个列表。
<span class="token key atrule">dns</span><span class="token punctuation">:</span> 8.8.8.8
<span class="token key atrule">dns</span><span class="token punctuation">:</span>
 <span class="token punctuation">-</span> 8.8.8.8
 <span class="token punctuation">-</span> 9.9.9.9
</code></pre> 
<h5><a id="16cap_addcap_drop_4978"></a>16、cap_add，cap_drop</h5> 
<p>添加或放弃容器的Linux能力（Capability）。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">cap_add</span><span class="token punctuation">:</span>
 <span class="token punctuation">-</span> ALL
<span class="token key atrule">cap_drop</span><span class="token punctuation">:</span>
 <span class="token punctuation">-</span> NET_ADMIN
 <span class="token punctuation">-</span> SYS_ADMIN
</code></pre> 
<h5><a id="17dns_search_4990"></a>17、dns_search</h5> 
<p>配置DNS搜索域。可以是一个值也可以是一个列表。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">dns_search</span><span class="token punctuation">:</span> example.com
<span class="token key atrule">dns_search</span><span class="token punctuation">:</span>
 <span class="token punctuation">-</span> domain1.example.com
 \ <span class="token punctuation">-</span> domain2.example.com
working_dir<span class="token punctuation">,</span> entrypoint<span class="token punctuation">,</span> user<span class="token punctuation">,</span> hostname<span class="token punctuation">,</span> domainname<span class="token punctuation">,</span> mem_limit<span class="token punctuation">,</span> privileged<span class="token punctuation">,</span> restart<span class="token punctuation">,</span> stdin_open<span class="token punctuation">,</span> tty<span class="token punctuation">,</span> cpu_shares
</code></pre> 
<p>这些都是和 docker run 支持的选项类似。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">cpu_shares</span><span class="token punctuation">:</span> <span class="token number">73</span>
<span class="token key atrule">working_dir</span><span class="token punctuation">:</span> /code
<span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> /code/entrypoint.sh
<span class="token key atrule">user</span><span class="token punctuation">:</span> postgresql
<span class="token key atrule">hostname</span><span class="token punctuation">:</span> foo
<span class="token key atrule">domainname</span><span class="token punctuation">:</span> foo.com
<span class="token key atrule">mem_limit</span><span class="token punctuation">:</span> <span class="token number">1000000000</span>
<span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">restart</span><span class="token punctuation">:</span> always
<span class="token key atrule">stdin_open</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">tty</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
</code></pre> 
<h5><a id="18healthcheck_5018"></a>18、healthcheck</h5> 
<p>健康检查，这个非常有必要，等服务准备好以后再上线，避免更新过程中出现短暂的无法访问。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">healthcheck</span><span class="token punctuation">:</span>
  <span class="token key atrule">test</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"CMD"</span><span class="token punctuation">,</span> <span class="token string">"curl"</span><span class="token punctuation">,</span> <span class="token string">"-f"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/alive"</span><span class="token punctuation">]</span>
  <span class="token key atrule">interval</span><span class="token punctuation">:</span> 5s
  <span class="token key atrule">timeout</span><span class="token punctuation">:</span> 3s
</code></pre> 
<p>其实大多数情况下健康检查的规则都会写在 Dockerfile 中:</p> 
<pre><code class="prism language-bash">FROM nginx
RUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y <span class="token function">curl</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -rf /var/lib/apt/lists/*
HEALTHCHECK --interval<span class="token operator">=</span>5s --timeout<span class="token operator">=</span>3s CMD <span class="token function">curl</span> -f http://localhost/alive <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
</code></pre> 
<h5><a id="19depends_on_5037"></a>19、depends_on</h5> 
<p>依赖的服务，优先启动，例：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> redis
</code></pre> 
<h5><a id="20deploy_5048"></a>20、deploy</h5> 
<p>部署相关的配置都在这个节点下，例：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>
  <span class="token key atrule">mode</span><span class="token punctuation">:</span> replicated
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>
  <span class="token key atrule">restart_policy</span><span class="token punctuation">:</span>
    <span class="token key atrule">condition</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure
    <span class="token key atrule">max_attempts</span><span class="token punctuation">:</span> <span class="token number">3</span>
  <span class="token key atrule">update_config</span><span class="token punctuation">:</span>
    <span class="token key atrule">delay</span><span class="token punctuation">:</span> 5s
    <span class="token key atrule">order</span><span class="token punctuation">:</span> start<span class="token punctuation">-</span>first <span class="token comment"># 默认为 stop-first，推荐设置先启动新服务再终止旧的</span>
  <span class="token key atrule">resources</span><span class="token punctuation">:</span>
    <span class="token key atrule">limits</span><span class="token punctuation">:</span>
      <span class="token key atrule">cpus</span><span class="token punctuation">:</span> <span class="token string">"0.50"</span>
      <span class="token key atrule">memory</span><span class="token punctuation">:</span> 1g
<span class="token key atrule">deploy</span><span class="token punctuation">:</span>
  <span class="token key atrule">mode</span><span class="token punctuation">:</span> global <span class="token comment"># 不推荐全局模式（仅个人意见）。</span>
  <span class="token key atrule">placement</span><span class="token punctuation">:</span>
    <span class="token key atrule">constraints</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>node.role == manager<span class="token punctuation">]</span>
</code></pre> 
<p>若非特殊服务，以上各节点的配置能够满足大部分部署场景了。</p> 
<h4><a id="dockercomposeyml_5076"></a>docker-compose.yml实例</h4> 
<pre><code class="prism language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.5'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">nacos1</span><span class="token punctuation">:</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nacos/nacos<span class="token punctuation">-</span>server<span class="token punctuation">:</span>$<span class="token punctuation">{<!-- --></span>NACOS_VERSION<span class="token punctuation">}</span>
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> nacos1
    <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> <span class="token string">"8001:8001"</span>
     <span class="token punctuation">-</span> <span class="token string">"8011:9555"</span>
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">resources</span><span class="token punctuation">:</span>
        <span class="token key atrule">limits</span><span class="token punctuation">:</span>
          <span class="token key atrule">cpus</span><span class="token punctuation">:</span> <span class="token string">'0.50'</span>
          <span class="token key atrule">memory</span><span class="token punctuation">:</span> 1024M 
    <span class="token key atrule">env_file</span><span class="token punctuation">:</span> 
     <span class="token punctuation">-</span> ./nacos.env 
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
        <span class="token key atrule">NACOS_SERVER_IP</span><span class="token punctuation">:</span> $<span class="token punctuation">{<!-- --></span>NACOS_SERVER_IP_1<span class="token punctuation">}</span>
        <span class="token key atrule">NACOS_APPLICATION_PORT</span><span class="token punctuation">:</span> <span class="token number">8001</span>
        <span class="token key atrule">NACOS_SERVERS</span><span class="token punctuation">:</span> $<span class="token punctuation">{<!-- --></span>NACOS_SERVERS<span class="token punctuation">}</span>     
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> ./logs_01/<span class="token punctuation">:</span>/home/nacos/logs/
     <span class="token punctuation">-</span> ./data_01/<span class="token punctuation">:</span>/home/nacos/data/
     <span class="token punctuation">-</span> ./config/<span class="token punctuation">:</span>/home/nacos/config/
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ha<span class="token punctuation">-</span>network<span class="token punctuation">-</span>overlay
  <span class="token key atrule">nacos2</span><span class="token punctuation">:</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nacos/nacos<span class="token punctuation">-</span>server<span class="token punctuation">:</span>$<span class="token punctuation">{<!-- --></span>NACOS_VERSION<span class="token punctuation">}</span>
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> nacos2
    <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> <span class="token string">"8002:8002"</span>
     <span class="token punctuation">-</span> <span class="token string">"8012:9555"</span>
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">resources</span><span class="token punctuation">:</span>
        <span class="token key atrule">limits</span><span class="token punctuation">:</span>
          <span class="token key atrule">cpus</span><span class="token punctuation">:</span> <span class="token string">'0.50'</span>
          <span class="token key atrule">memory</span><span class="token punctuation">:</span> 1024M    
    <span class="token key atrule">env_file</span><span class="token punctuation">:</span> 
     <span class="token punctuation">-</span> ./nacos.env     
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
        <span class="token key atrule">NACOS_SERVER_IP</span><span class="token punctuation">:</span> $<span class="token punctuation">{<!-- --></span>NACOS_SERVER_IP_2<span class="token punctuation">}</span>
        <span class="token key atrule">NACOS_APPLICATION_PORT</span><span class="token punctuation">:</span> <span class="token number">8002</span>
        <span class="token key atrule">NACOS_SERVERS</span><span class="token punctuation">:</span> $<span class="token punctuation">{<!-- --></span>NACOS_SERVERS<span class="token punctuation">}</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> ./logs_02/<span class="token punctuation">:</span>/home/nacos/logs/
     <span class="token punctuation">-</span> ./data_02/<span class="token punctuation">:</span>/home/nacos/data/
     <span class="token punctuation">-</span> ./config/<span class="token punctuation">:</span>/home/nacos/config/
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ha<span class="token punctuation">-</span>network<span class="token punctuation">-</span>overlay
  <span class="token key atrule">nacos3</span><span class="token punctuation">:</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nacos/nacos<span class="token punctuation">-</span>server<span class="token punctuation">:</span>$<span class="token punctuation">{<!-- --></span>NACOS_VERSION<span class="token punctuation">}</span>
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> nacos3
    <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> <span class="token string">"8003:8003"</span>
     <span class="token punctuation">-</span> <span class="token string">"8013:9555"</span>
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">resources</span><span class="token punctuation">:</span>
        <span class="token key atrule">limits</span><span class="token punctuation">:</span>
          <span class="token key atrule">cpus</span><span class="token punctuation">:</span> <span class="token string">'0.50'</span>
          <span class="token key atrule">memory</span><span class="token punctuation">:</span> 1024M    
    <span class="token key atrule">env_file</span><span class="token punctuation">:</span> 
     <span class="token punctuation">-</span> ./nacos.env 
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
        <span class="token key atrule">NACOS_SERVER_IP</span><span class="token punctuation">:</span> $<span class="token punctuation">{<!-- --></span>NACOS_SERVER_IP_3<span class="token punctuation">}</span>
        <span class="token key atrule">NACOS_APPLICATION_PORT</span><span class="token punctuation">:</span> <span class="token number">8003</span>
        <span class="token key atrule">NACOS_SERVERS</span><span class="token punctuation">:</span> $<span class="token punctuation">{<!-- --></span>NACOS_SERVERS<span class="token punctuation">}</span>         
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> ./logs_03/<span class="token punctuation">:</span>/home/nacos/logs/
     <span class="token punctuation">-</span> ./data_03/<span class="token punctuation">:</span>/home/nacos/data/
     <span class="token punctuation">-</span> ./config/<span class="token punctuation">:</span>/home/nacos/config/
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ha<span class="token punctuation">-</span>network<span class="token punctuation">-</span>overlay
<span class="token key atrule">networks</span><span class="token punctuation">:</span>
   <span class="token key atrule">ha-network-overlay</span><span class="token punctuation">:</span>
     <span class="token key atrule">external</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
</code></pre> 
<h4><a id="YAML____5163"></a>YAML 文件格式 及 编写注意事项</h4> 
<p>使用compose对Docker容器进行编排管理时，需要编写docker-compose.yml文件，初次编写时，容易遇到一些比较低级的问题，导致执行docker-compose up时先解析yml文件的错误。</p> 
<p>比较常见的是yml对缩进的严格要求。</p> 
<p>yml文件还行后的缩进，不允许使用tab键字符，只能使用空格，而空格的数量也有要求，经过实际测试，发现每一行增加一个空格用于缩进是正常的。</p> 
<p>aml 是一种标记语言，它可以很直观的展示数据序列化格式，可读性高。类似于XML数据描述语言，语法比 XMAL简单的很多。</p> 
<p>YAML数据结构通过缩进来表示，连续的项目通过减号来表示，键值对用冒号分隔，数组用中括号<code>[]</code>括起来, hash用花括号<code>{}</code>括起来。</p> 
<h3><a id="1W_5177"></a>…省略1W字</h3> 
<p><strong>尼恩说明：由于公众号最多可以发布5W字</strong></p> 
<p><strong>还有1W字放不下…</strong></p> 
<p><strong>更多内容，请参见《 Docker 学习圣经 》PDF</strong></p> 
<img src="https://images2.imgbox.com/32/bd/YbextCrm_o.png" width="600"> 
<h3><a id="_5191"></a>说在后面</h3> 
<p>通过此PDF，尼恩希望能帮助大家，早日实现 Docker 技术和底层原理的技术自由。</p> 
<p>此文PDF 没有完，后面还有N多内容需要补充。可以关注 尼恩的《<strong>技术自由圈</strong>》公众号。</p> 
<p>本书 《 Docker 学习圣经 》PDF的 V1版本，后面会持续迭代和升级。供后面的小伙伴参考，提升大家的 3高 架构、设计、开发水平。</p> 
<blockquote> 
 <p>注：本文以 PDF 持续更新，最新尼恩 架构笔记、面试题 的PDF文件，请从这里获取：<a href="https://gitee.com/crazymaker/SimpleCrayIM/blob/master/%E7%96%AF%E7%8B%82%E5%88%9B%E5%AE%A2%E5%9C%88%E6%80%BB%E7%9B%AE%E5%BD%95.md" rel="nofollow">码云</a></p> 
</blockquote> 
<h3><a id="_5203"></a>参考资料</h3> 
<p>https://docs.docker.com/storage/storagedriver/aufs-driver/#how-the-aufs-storage-driver-works</p> 
<p>https://github.com/opencontainers/runc</p> 
<p>http://www.sel.zju.edu.cn/?p=840</p> 
<p>https://draveness.me/docker/</p> 
<p>https://blog.csdn.net/wangqingjiewa/article/details/85000393</p> 
<p>https://zhuanlan.zhihu.com/p/47683490</p> 
<h3><a id="_PDF_5221"></a>技术自由的实现路径 PDF：</h3> 
<h5><a id="__5223"></a>实现你的 架构自由：</h5> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/129204455">吃透8图1模板，人人可以做架构</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/129410795">10Wqps评论中台，如何架构？B站是这么做的！！！</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/128848309">阿里二面：千万级、亿级数据，如何性能优化？ 教科书级 答案来了</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/128725701">峰值21WQps、亿级DAU，小游戏《羊了个羊》是怎么架构的？</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/129145200">100亿级订单怎么调度，来一个大厂的极品方案</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/128697096">2个大厂 100亿级 超大流量 红包 架构方案</a>》</p> 
<p><em>… 更多架构文章，正在添加中</em></p> 
<h5><a id="___5241"></a>实现你的 响应式 自由：</h5> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/129022714">响应式圣经：10W字，实现Spring响应式编程自由</a>》</p> 
<p>这是老版本 《<a href="https://blog.csdn.net/crazymakercircle/article/details/124120506">Flux、Mono、Reactor 实战（史上最全）</a>》</p> 
<h5><a id="_spring_cloud__5249"></a>实现你的 spring cloud 自由：</h5> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/129559428">Spring cloud Alibaba 学习圣经</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/123420859">分库分表 Sharding-JDBC 底层原理、核心实战（史上最全）</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/125135726">一文搞定：SpringBoot、SLF4j、Log4j、Logback、Netty之间混乱关系（史上最全）</a>》</p> 
<h5><a id="_linux__5260"></a>实现你的 linux 自由：</h5> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/128932396">Linux命令大全：2W多字，一次实现Linux自由</a>》</p> 
<h5><a id="___5266"></a>实现你的 网络 自由：</h5> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/114527369">TCP协议详解 (史上最全)</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/129334254">网络三张表：ARP表, MAC表, 路由表，实现你的网络自由！！</a>》</p> 
<h5><a id="___5274"></a>实现你的 分布式锁 自由：</h5> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/116425814">Redis分布式锁（图解 - 秒懂 - 史上最全）</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/85956246">Zookeeper 分布式锁 - 图解 - 秒懂</a>》</p> 
<h5><a id="___5282"></a>实现你的 王者组件 自由：</h5> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/128264803">队列之王： Disruptor 原理、架构、源码 一文穿透</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/128123114">缓存之王：Caffeine 源码、架构、原理（史上最全，10W字 超级长文）</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/113751575">缓存之王：Caffeine 的使用（史上最全）</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/126579528">Java Agent 探针、字节码增强 ByteBuddy（史上最全）</a>》</p> 
<h5><a id="___5294"></a>实现你的 面试题 自由：</h5> 
<p><a href="https://blog.csdn.net/crazymakercircle/article/details/124790425">4000页《尼恩Java面试宝典 》 40个专题</a></p> 
<p>以上尼恩 架构笔记、面试题 的PDF文件更新，▼请到下面【技术自由圈】公号取 ▼</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/983f6a3ea1342035adbb85aab5a51604/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">K8S学习圣经：大白话说K8S底层原理，14W字实现K8S自由</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d774a7f9e7682fd5d834b6e1259246c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jsonschema fge json-schema-validator 高级能力 自定义类校验</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>