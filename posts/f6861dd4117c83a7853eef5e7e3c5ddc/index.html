<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构复习题（包含答案） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构复习题（包含答案）" />
<meta property="og:description" content="第一章 概论 一、选择题 1、研究数据结构就是研究（ D ）。
A. 数据的逻辑结构 B. 数据的存储结构 C. 数据的逻辑结构和存储结构 D. 数据的逻辑结构、存储结构及其基本操作
2、算法分析的两个主要方面是（ A ）。
A. 空间复杂度和时间复杂度 B. 正确性和简单性
C. 可读性和文档性 D. 数据复杂性和程序复杂性
3、具有线性结构的数据结构是（ D ）。
A. 图 B. 树 C. 广义表 D. 栈
4、计算机中的算法指的是解决某一个问题的有限运算序列，它必须具备输入、输出、（ B ）等5个特性。
A. 可执行性、可移植性和可扩充性 B. 可执行性、有穷性和确定性
C. 确定性、有穷性和稳定性 D. 易读性、稳定性和确定性
5、下面程序段的时间复杂度是（ C ）。
for(i=0;i&lt;m;i&#43;&#43;)
for(j=0;j&lt;n;j&#43;&#43;)
a[i][j]=i*j;
A. O(m2) B. O(n2) C. O(m*n) D. O(m&#43;n)
6、算法是（ D ）。
A. 计算机程序 B. 解决问题的计算方法
C. 排序算法 D." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f6861dd4117c83a7853eef5e7e3c5ddc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-20T13:49:07+08:00" />
<meta property="article:modified_time" content="2023-04-20T13:49:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构复习题（包含答案）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:center;"><a name="_Toc282629585"></a></p> 
<h2 style="margin-left:.0001pt;text-align:center;"></h2> 
<h2 id="%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A6%82%E8%AE%BA" style="margin-left:.0001pt;text-align:center;">第一章 概论</h2> 
<h3 id="%E4%B8%80%E3%80%81%E9%80%89%E6%8B%A9%E9%A2%98" style="margin-left:.0001pt;text-align:justify;">一、选择题</h3> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>1、研究数据结构就是研究（ D  ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 数据的逻辑结构                      B. 数据的存储结构   </p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 数据的逻辑结构和存储结构    D. 数据的逻辑结构、存储结构及其基本操作</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2、算法分析的两个主要方面是（  A ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 空间复杂度和时间复杂度         B. 正确性和简单性</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 可读性和文档性                      D. 数据复杂性和程序复杂性</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>3、具有线性结构的数据结构是（  D ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 图             B. 树         C. 广义表           D. 栈</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>4、计算机中的算法指的是解决某一个问题的有限运算序列，它必须具备输入、输出、（ B  ）等5个特性。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 可执行性、可移植性和可扩充性         B. 可执行性、有穷性和确定性</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 确定性、有穷性和稳定性                   D. 易读性、稳定性和确定性</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>5、下面程序段的时间复杂度是（  C ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">for(i=0;i&lt;m;i++)</p> 
<p style="margin-left:.0001pt;text-align:justify;">for(j=0;j&lt;n;j++)</p> 
<p style="margin-left:.0001pt;text-align:justify;">a[i][j]=i*j;</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. O(m2)         B. O(n2)         C. O(m*n)         D. O(m+n)</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>6、算法是（ D  ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 计算机程序     B. 解决问题的计算方法</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 排序算法        D. 解决问题的有限运算序列</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>7、某算法的语句执行频度为（3n+nlog2n+n2+8）,其时间复杂度表示（ C  ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. O(n)     B. O(nlog2n)       C. O(n2)       D. O(log2n)</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>8、下面程序段的时间复杂度为（  C ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">i=1;</p> 
<p style="margin-left:.0001pt;text-align:justify;">while(i&lt;=n)</p> 
<p style="margin-left:.0001pt;text-align:justify;">i=i*3;</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. O(n)         B. O(3n)         C. O(log3n)        D. O(n3)</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>9、数据结构是一门研究非数值计算的程序设计问题中计算机的数据元素以及它们之间的（  B ）和运算等的学科。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 结构         B. 关系         C. 运算         D. 算法</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>10、抽象数据类型的三个组成部分分别为（   A）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 数据对象、数据关系和基本操作         B. 数据元素、逻辑结构和存储结构</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 数据项、数据元素和数据类型            D. 数据元素、数据结构和数据类型</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>11、通常从正确性、易读性、健壮性、高效性等4个方面评价算法的质量，以下解释错误的是（ D  ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 正确性算法应能正确地实现预定的功能</p> 
<p style="margin-left:.0001pt;text-align:justify;">B. 易读性算法应易于阅读和理解，以便调试、修改和扩充</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 健壮性当环境发生变化时，算法能适当地做出反应或进行处理，不会产生不需要的运行结果</p> 
<p style="margin-left:.0001pt;text-align:justify;">D. 高效性即达到所需要的时间性能</p> 
<h3 id="%E4%BA%8C%E3%80%81%E5%A1%AB%E7%A9%BA%E9%A2%98" style="margin-left:.0001pt;text-align:justify;">二、填空题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、程序段“i=1;while(i&lt;=n)  i=i*2;”的时间复杂度为<u>      O(n)    </u>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2、数据结构的四种基本类型中，<u>     </u><u><u>树形结构</u></u><u>     </u>的元素是一对多关系。</p> 
<h3 id="%E4%B8%89%E3%80%81%E7%BB%BC%E5%90%88%E9%A2%98" style="margin-left:.0001pt;text-align:left;">三、综合题</h3> 
<p style="margin-left:.0001pt;text-align:left;">1、将数量级O(1),O(N),O(N2),O(N3),O(NLOG2N),O(LOG2N),O(2N)按增长率由小到大排序。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;">答案：  O(1)  O(log2N)  O(N)  O(Nlog2N)  O(N2)  O(N3)  O(2N)  </span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 id="%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8" style="margin-left:.0001pt;text-align:center;">第二章 线性表</h2> 
<h3 style="margin-left:.0001pt;text-align:justify;">一、选择题</h3> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>1、若长度为n的线性表采用顺序存储结构，在其第i个位置插入一个新元素算法的时间复杂度（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. O(log2n)         B.O(1)          <span style="color:#ff0000;">C. O(n)</span>        D.O(n2)</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2、若一个线性表中最常用的操作是取第i个元素和找第i个元素的前趋元素，则采用（   ）存储方式最节省时间。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">   <span style="color:#ff0000;"> A. 顺序表</span>        B. 单链表      C.  双链表       D. 单循环链表</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>3、具有线性结构的数据结构是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 图     B. 树     C. 广义表     <span style="color:#ff0000;">D.</span> <span style="color:#ff0000;">栈</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>4、在一个长度为n的顺序表中，在第i个元素之前插入一个新元素时，需向后移动（   ）个元素。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. n-i     <span style="color:#ff0000;">B.</span><span style="color:#ff0000;"> n-i+1</span>    C. n-i-1     D. i</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>5、<span style="color:#0000ff;">非空</span>的循环单链表head的尾结点p满足（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. </span><span style="color:#ff0000;">p-&gt;next==head</span>        B. p-&gt;next==NULL    </p> 
<p style="margin-left:.0001pt;text-align:justify;">C.  p==NULL                D. p==head</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>6、链表不具有的特点是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. 可随机访问任一元素        </span>     B. 插入删除不需要移动元素</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 不必事先估计存储空间         D. 所需空间与线性表长度成正比</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>7、在双向循环链表中，在p指针所指的结点后插入一个指针q所指向的新结点，修改指针的操作是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. p-&gt;next=q;q-&gt;prior=p;p-&gt;next-&gt;prior=q;q-&gt;next=q;</p> 
<p style="margin-left:.0001pt;text-align:justify;">B. p-&gt;next=q;p-&gt;next-&gt;prior=q;q-&gt;prior=p;q-&gt;next=p-&gt;next;</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">C. </span><span style="color:#ff0000;">q-&gt;prior=p;q-&gt;next=p-&gt;next;p-&gt;next-&gt;prior=q;p-&gt;next=q;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">D. q-&gt;next=p-&gt;next;q-&gt;prior=p;p-&gt;next=q;p-&gt;next=q;</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>8、线性表采用链式存储时，结点的存储地址（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 必须是连续的         B. 必须是不连续的</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">C. </span><span style="color:#ff0000;">连续与否均可</span>         D. 和头结点的存储地址相连续</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>9、在一个长度为n的顺序表中删除第i个元素，需要向前移动（   ）个元素。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. </span><span style="color:#ff0000;">n-i</span>        B. n-i+1         C. n-i-1       D. i+1</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>10、线性表是n个（   ）的有限序列。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 表元素         B. 字符         <span style="color:#ff0000;">C. 数据元素        </span> D. 数据项</p> 
<p style="margin-left:.0001pt;text-align:justify;">11、从表中任一结点出发，都能扫描整个表的是（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 单链表      B. 顺序表         <span style="color:#ff0000;">C. 循环链表</span>     D. 静态链表</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>12、在具有n个结点的单链表上查找值为x的元素时，其时间复杂度为（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. </span><span style="color:#ff0000;">O(n)</span>      B. O(1)       C. O(n2)       D. O(n-1)</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>13、线性表L=(a1,a2,……,an)，下列说法正确的是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 每个元素都有一个直接前驱和一个直接后继    </p> 
<p style="margin-left:.0001pt;text-align:justify;">B. 线性表中至少要有一个元素</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 表中诸元素的排列顺序必须是由小到大或由大到小</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">D.</span> <span style="color:#ff0000;">除第一个和最后一个元素外，其余每个元素都由一个且仅有一个直接前驱和直接后继</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>14、一个顺序表的第一个元素的存储地址是90，每个元素的长度为2，则第6个元素的存储地址是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 98         <span style="color:#ff0000;">B. 100        </span> C. 102         D. 106</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>15、在线性表的下列存储结构中，读取元素花费的时间最少的是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"> A. 单链表       B. 双链表     C. 循环链表       <span style="color:#ff0000;">D. </span><span style="color:#ff0000;">顺序表</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>16、在一个单链表中，若删除p所指向结点的后续结点，则执行（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. </span><span style="color:#ff0000;">p-&gt;next=p-&gt;next-&gt;next;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">B. p=p-&gt;next;p-&gt;next=p-&gt;next-&gt;next;</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. p =p-&gt;next;</p> 
<p style="margin-left:.0001pt;text-align:justify;">D. p=p-&gt;next-&gt;next;</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>17、将长度为n的单链表连接在长度为m的单链表之后的算法的时间复杂度为（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. O(1)         B. O(n)         <span style="color:#ff0000;">C. O(m)        </span> D. O(m+n)</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>18、线性表的顺序存储结构是一种（   ）存储结构。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. 随机存取</span>         B. 顺序存取         C. 索引存取         D. 散列存取</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>19、顺序表中，插入一个元素所需移动的元素平均数是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">    A. (n-1)/2       B. n     C. n+1       <span style="color:#ff0000;">D. </span><span style="color:#ff0000;">(n+1)/2</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>10、循环链表的主要优点是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 不再需要头指针        </p> 
<p style="margin-left:.0001pt;text-align:justify;">B. 已知某结点位置后能容易找到其直接前驱 </p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 在进行插入、删除运算时能保证链表不断开 </p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">D. </span><span style="color:#ff0000;">在表中任一结点出发都能扫描整个链表</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>11、<span style="color:#0000ff;">不带</span>头结点的单链表head为空的判定条件是（ A  ）</strong>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. </span><span style="color:#ff0000;">head==NULL</span>                      <span style="color:#0000ff;">B. head-&gt;next==NULL</span>    </p> 
<p style="margin-left:.0001pt;text-align:justify;">C. head-&gt;next==head            D. head!=NULL</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0000ff;">（B是带头结点的）</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>12、在下列对顺序表进行的操作中，算法时间复杂度为O(1)的是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="86" src="https://images2.imgbox.com/8e/b1/FjHv6Qjt_o.png" width="682"></p> 
<p style="margin-left:.0001pt;text-align:left;">答案是A.</p> 
<p style="margin-left:.0001pt;text-align:left;">假设顺序表L,长度为n，求第i个节点L[i],直接前驱L[i-1],因此为O（1）</p> 
<p style="margin-left:.0001pt;text-align:left;">答案B需要移动n-i+1个节点，因此为O(n)</p> 
<p style="margin-left:.0001pt;text-align:left;">答案C也需要移动n-i个节点</p> 
<p style="margin-left:.0001pt;text-align:left;">答案D根据排序方法不同最慢O(n^2)，最快O(nlogn)</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>13、已知指针p和q分别指向某单链表中第一个结点和最后一个结点。假设指针s指向另一个单链表中某个结点，则在s所指结点之后插入上述链表应执行的语句为（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. <span style="color:#ff0000;">q-&gt;next=s-&gt;next；s-&gt;next=p；</span>     </p> 
<p style="margin-left:.0001pt;text-align:justify;">B. s-&gt;next=p；q-&gt;next=s-&gt;next；      </p> 
<p style="margin-left:.0001pt;text-align:justify;">C. p-&gt;next=s-&gt;next；s-&gt;next=q；    </p> 
<p style="margin-left:.0001pt;text-align:justify;">D. <span style="color:#000000;">s-&gt;next=q；p-&gt;next=s-&gt;next；</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>14、在以下的叙述中，正确的是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 线性表的顺序存储结构优于链表存储结构</p> 
<p style="margin-left:.0001pt;text-align:justify;">B. 线性表的顺序存储结构适用于频繁插入/删除数据元素的情况</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. <span style="color:#ff0000;">线性表的链表存储结构适用于频繁插入/删除数据元素的情况</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">D. 线性表的链表存储结构优于顺序存储结构</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>15、在表长为n的顺序表中，当在任何位置删除一个元素的概率相同时，删除一个元素所需移动的平均个数为（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. (n-1)/2       <span style="color:#ff0000;">B. n/2</span>       C. (n+1)/2         D. n</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>16、在一个单链表中，已知q所指结点是p所指结点的前驱结点，若在q和p之间插入一个结点s，则执行（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">A. s-&gt;next=p-&gt;next; p-&gt;next=s;              </span></p> 
<p style="margin-left:.0001pt;text-align:justify;">B. p-&gt;next=s-&gt;next;s-&gt;next=p;  </p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">C. q-&gt;next=s;s-&gt;next=p;</span>            </p> 
<p style="margin-left:.0001pt;text-align:justify;">D. p-&gt;next=s;s-&gt;next=q;</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>17、在单链表中，指针p指向元素为x的结点，实现删除x的后继的语句是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. p=p-&gt;next;     <span style="color:#ff0000;">B. </span><span style="color:#ff0000;">p-&gt;next=p-&gt;next-&gt;next;</span>   </p> 
<p style="margin-left:.0001pt;text-align:justify;">C. p-&gt;next=p; D. p=p-&gt;next-&gt;next;</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>18、在头指针为head且表长大于1的单循环链表中，指针p指向表中某个结点，若p-&gt;next-&gt;next==head，则（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. p指向头结点 B. p指向尾结点 C. p的直接后继是头结点</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">D.</span> <span style="color:#ff0000;">p的直接后继是尾结点</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;">二、填空题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、设单链表的结点结构为（data,next）。已知指针p指向单链表中的结点，q指向新结点，欲将q插入到p结点之后，则需要执行的语句：<u>      </u><u>         </u><u>   </u>；<u>                 </u>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：</span><span style="color:#ff0000;">q-&gt;next=p-&gt;next  </span> <span style="color:#ff0000;">p-&gt;next=q</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">2、线性表的逻辑结构是<u>          </u>，其所含元素的个数称为线性表的<u>        </u>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：</span><span style="color:#ff0000;">线性结构  长度</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">3、写出带头结点的双向循环链表L为空表的条件<u>      </u><u>         </u><u>   </u>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：L-&gt;prior==L-&gt;next==L</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">4、带头结点的单链表head为空的条件是<u>           </u>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：head-&gt;next==NULL</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">5、在一个单链表中删除p所指结点的后继结点时，应执行以下操作：</p> 
<p style="margin-left:.0001pt;text-align:justify;">q = p-&gt;next;</p> 
<p style="margin-left:.0001pt;text-align:justify;">p-&gt;next= <u><u>_ </u></u><span style="color:#fe2c24;">q-&gt;next</span><u><u>  ___</u></u>;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 id="%E4%B8%89%E3%80%81%E5%88%A4%E6%96%AD%E9%A2%98" style="margin-left:.0001pt;text-align:justify;">三、判断题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、单链表不是一种随机存储结构。 <span style="color:#ff0000;">✔️ </span></p> 
<p style="margin-left:.0001pt;text-align:justify;">2、在具有头结点的单链表中，头指针指向链表的第一个数据结点。<span style="color:#ff0000;">❌</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">3、用循环单链表表示的链队列中，可以不设队头指针，仅在队尾设置队尾指针。<span style="color:#ff0000;">✔️ </span></p> 
<p style="margin-left:.0001pt;text-align:justify;">4、顺序存储方式只能用于存储线性结构。<span style="color:#ff0000;">❌</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">5、在线性表的顺序存储结构中，逻辑上相邻的两个元素但是在物理位置上不一定是相邻的。<span style="color:#ff0000;">❌</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">6、链式存储的线性表可以随机存取。<span style="color:#ff0000;">❌</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">四、程序分析填空题</p> 
<p style="margin-left:.0001pt;text-align:justify;">1、函数GetElem实现返回单链表的第i个元素，请在空格处将算法补充完整。</p> 
<p style="margin-left:.0001pt;text-align:justify;">int GetElem(LinkList L,int i,Elemtype *e){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">        LinkList p；int j；</p> 
<p style="margin-left:.0001pt;text-align:justify;">        p=L-&gt;next;j=1;</p> 
<p style="margin-left:.0001pt;text-align:justify;">        while(p&amp;&amp;j&lt;i){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">               <u>     (1)     </u>;++j;</p> 
<p style="margin-left:.0001pt;text-align:justify;">        }</p> 
<p style="margin-left:.0001pt;text-align:justify;">        if(!p||j&gt;i)  return ERROR;</p> 
<p style="margin-left:.0001pt;text-align:justify;">        *e=<u><u>       (2)     </u></u>;</p> 
<p style="margin-left:.0001pt;text-align:justify;">        return OK;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：(1)</span><span style="color:#ff0000;">p=p-&gt;next     (2)p-&gt;data</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">2、函数实现单链表的插入算法，请在空格处将算法补充完整。</p> 
<p style="margin-left:.0001pt;text-align:justify;">int ListInsert(LinkList L,int i,ElemType e){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    LNode *p,*s;int j;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    p=L;j=0;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    while((p!=NULL)&amp;&amp;(j&lt;i-1)){  p=p-&gt;next;j++ }</p> 
<p style="margin-left:.0001pt;text-align:justify;">   if(p==NULL||j&gt;i-1) return ERROR;</p> 
<p style="margin-left:.0001pt;text-align:justify;">   s=(LNode *)malloc(sizeof(LNode));  </p> 
<p style="margin-left:.0001pt;text-align:justify;">   s-&gt;data=e;</p> 
<p style="margin-left:.0001pt;text-align:justify;">   <u><u>      (1)           </u></u>;                </p> 
<p style="margin-left:.0001pt;text-align:justify;">   <u><u>      (2)          </u></u>;</p> 
<p style="margin-left:.0001pt;text-align:justify;">   return OK;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}/*ListInsert*/</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：(1)</span><span style="color:#ff0000;">s-&gt;next=p-&gt;next    (2)p-&gt;next=s</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">3、函数ListDelete_sq实现顺序表删除算法，请在空格处将算法补充完整。</p> 
<p style="margin-left:.0001pt;text-align:justify;">int ListDelete_sq(Sqlist *L,int i){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    int k;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    if(i&lt;1||i&gt;L-&gt;length) return ERROR;</p> 
<p style="margin-left:.0001pt;text-align:justify;">for(k=i-1;k&lt;L-&gt;length-1;k++)</p> 
<p style="margin-left:.0001pt;text-align:justify;">L-&gt;elem[k]=<u><u>    （1）      </u></u>;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <u><u>       （2）       </u></u>;                       </p> 
<p style="margin-left:.0001pt;text-align:justify;">    return OK;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#fe2c24;">答案：（1）L-&gt;elem[k+1]     （2） --L-&gt;Length  </span></p> 
<p style="margin-left:.0001pt;text-align:justify;">4、函数实现单链表的删除算法，请在空格处将算法补充完整。</p> 
<p style="margin-left:.0001pt;text-align:justify;">int ListDelete(LinkList L,int i,ElemType *s){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    LNode *p,*q;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    int j;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    p=L;j=0;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    while((<u><u>      （1）     </u></u>)&amp;&amp;(j&lt;i-1)){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">        p=p-&gt;next;j++;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    }</p> 
<p style="margin-left:.0001pt;text-align:justify;">    if(p-&gt;next==NULL||j&gt;i-1) return ERROR;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    q=p-&gt;next;                  </p> 
<p style="margin-left:.0001pt;text-align:justify;">    <u><u>       （2）          </u></u>;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    *s=q-&gt;data;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    free(q);</p> 
<p style="margin-left:.0001pt;text-align:justify;">    return OK;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}/*listDelete*/</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：(1)p-&gt;next!=NULL    (2)p-&gt;next=q-&gt;next</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">5、写出算法的功能。</p> 
<p style="margin-left:.0001pt;text-align:justify;">int L(head){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">node * head;</p> 
<p style="margin-left:.0001pt;text-align:justify;">int n=0;</p> 
<p style="margin-left:.0001pt;text-align:justify;">node *p;</p> 
<p style="margin-left:.0001pt;text-align:justify;">p=head;</p> 
<p style="margin-left:.0001pt;text-align:justify;">while(p!=NULL)</p> 
<p style="margin-left:.0001pt;text-align:justify;">{ p=p-&gt;next;</p> 
<p style="margin-left:.0001pt;text-align:justify;">   n++;</p> 
<p style="margin-left:.0001pt;text-align:justify;"> }</p> 
<p style="margin-left:.0001pt;text-align:justify;">return(n);</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：</span><span style="color:#ff0000;">求单链表head的长度</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 id="%E4%BA%94%E3%80%81%E7%BB%BC%E5%90%88%E9%A2%98" style="margin-left:.0001pt;text-align:justify;">五、综合题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、有两个循环链表，链头指针分别为L1和L2，要求写出算法将L2链表链到L1链表之后，且连接后仍保持循环链表形式。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：</span><span style="color:#ff0000;">void merge(Lnode *L1, Lnode *L2)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">    {Lnode *p,*q ;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">     while(p-&gt;next!=L1)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">p=p-&gt;next;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">while(q-&gt;next!=L2)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">q=q-&gt;next;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">q-&gt;next=L1; p-&gt;next =L2;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">    }</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">2、设一个带头结点的单向链表的头指针为head，设计算法，将链表的记录，按照data域的值递增排序。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：</span><span style="color:#ff0000;">void assending(Lnode *head)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">    {Lnode *p,*q , *r, *s;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">     p=head-&gt;next; q=p-&gt;next; p-&gt;next=NULL;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">     while(q)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">{r=q; q=q-&gt;next;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">if(r-&gt;data&lt;=p-&gt;data) </span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">{r-&gt;next=p; head-&gt;next=r; p=r; }</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">else</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">{while(!p &amp;&amp; r-&gt;data&gt;p-&gt;data)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">{s=p; p=p-&gt;next; }</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">r-&gt;next=p; s-&gt;next=r;}</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">p=head-&gt;next; }</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">    }</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">3、编写算法,将一个头指针为head不带头结点的单链表改造为一个单向循环链表，并分析算法的时间复杂度。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">void linklist_c(Lnode *head)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">    {Lnode *p; p=head;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">     if(!p) return ERROR;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">while(p-&gt;next!=NULL)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">p=p-&gt;next;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">p-&gt;next=head;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">    }</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">设单链表的长度（数据结点数）为N，则该算法的时间主要花费在查找链表最后一个结点上（算法中的while循环），所以该算法的时间复杂度为O（N）。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">4、假设线性表采用顺序存储结构，表中元素值为整型。阅读算法f2，设顺序表L=(3,7,3,2,1,1,8,7,3),写出执行算法f2后的线性表L的数据元素，并描述该算法的功能。</p> 
<p style="margin-left:.0001pt;text-align:justify;">  void f2(SeqList *L){  </p> 
<p style="margin-left:.0001pt;text-align:justify;">int i,j,k;</p> 
<p style="margin-left:.0001pt;text-align:justify;">k=0;</p> 
<p style="margin-left:.0001pt;text-align:justify;">for(i=0;i&lt;L-&gt;length;i++){  </p> 
<p style="margin-left:.0001pt;text-align:justify;">for(j=0;j&lt;k &amp;&amp; L-&gt;data[i]!=L-&gt;data[j];j++);</p> 
<p style="margin-left:.0001pt;text-align:justify;">    if(j==k){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">if(k!=i)L-&gt;data[k]=L-&gt;data[i];</p> 
<p style="margin-left:.0001pt;text-align:justify;">    k++;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    }</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">L-&gt;length=k;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"> <span style="color:#ff0000;">(3,7,2,1,8)  删除顺序表中重复的元素</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 id="%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97" style="margin-left:.0001pt;text-align:center;">第三章 栈和队列</h2> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;">一、选择题</h3> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>1、一个栈的输入序列为：a，b，c，d，e，则栈的不可能输出的序列是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. a,b,c,d,e              B. d,e,c,b,a     </p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">C. d,c,e,a,b   </span>         D. e,d,c,b,a</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2、判断一个循环队列Q（最多n个元素）为满的条件是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. Q-&gt;rear==Q-&gt;front    B. Q-&gt;rear==Q-&gt;front+1  </p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">C. </span><span style="color:#ff0000;">Q-&gt;front==(Q-&gt;rear+1)%n</span>   D. Q-&gt;front==(Q-&gt;rear-1)%n</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>3、设计一个判别表达式中括号是否配对的算法，采用（   ）数据结构最佳。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 顺序表     B. 链表       C. 队列       <span style="color:#ff0000;">D. </span><span style="color:#ff0000;">栈</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>4、带头结点的单链表head为空的判定条件是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. head==NULL <span style="color:#ff0000;">B. </span><span style="color:#ff0000;">head-&gt;next==NULL</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">C. head-&gt;next!=NULL   D. head!=NULL</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>5、一个栈的输入序列为：1,2,3,4，则栈的不可能输出的序列是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 1243          B. 2134     C. 1432       <span style="color:#ff0000;"> D. </span><span style="color:#ff0000;">4312</span> E. 3214</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>6、若用一个大小为6的数组来实现循环队列，且当rear和front的值分别为0，3。当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 1和5    <span style="color:#ff0000;">B. </span><span style="color:#ff0000;">2和4</span> C. 4和2   D. 5和1</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>7、队列的插入操作是在（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. </span><span style="color:#ff0000;">队尾</span>    B. 队头 C. 队列任意位置 D. 队头元素后</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>8、循环队列的队头和队尾指针分别为front和rear，则判断循环队列为空的条件是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. </span><span style="color:#ff0000;">front==rear</span>      B. front==0     </p> 
<p style="margin-left:.0001pt;text-align:justify;">C. rear==0      D. front=rear+1</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>9、一个顺序栈S，其栈顶指针为top，则将元素e入栈的操作是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. </span><span style="color:#ff0000;">*S-&gt;top=e;S-&gt;top++;</span>      B. S-&gt;top++;*S-&gt;top=e; </p> 
<p style="margin-left:.0001pt;text-align:justify;">C. *S-&gt;top=e     D. S-&gt;top=e;</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>10、将递归算法转换成对应的非递归算法时，通常需要使用（   ）来保存中间结果。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 队列     <span style="color:#ff0000;">B.</span> <span style="color:#ff0000;">栈</span> C. 链表     D. 树</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>11、栈的插入和删除操作在（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">    A. 栈底        <span style="color:#ff0000;">B. </span><span style="color:#ff0000;">栈顶</span>     C.  任意位置       D. 指定位置</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>12、五节车厢以编号1，2，3，4，5顺序进入铁路调度站（栈），可以得到（   ）的编组。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 3，4，5，1，2 B. 2，4，1，3，5</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">C.</span><span style="color:#ff0000;"> 3，5，4，2，1</span> D. 1，3，5，2，4</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>13、判定一个顺序栈S（栈空间大小为n）为空的条件是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. </span><span style="color:#ff0000;">S-&gt;top==0</span>    B. S-&gt;top!=0</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. S-&gt;top==n D. S-&gt;top!=n</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>14、在一个链队列中，front和rear分别为头指针和尾指针，则插入一个结点s的操作为（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. front=front-&gt;next   B. s-&gt;next=rear;rear=s</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">C. </span><span style="color:#ff0000;">rear-&gt;next=s;rear=s;</span> D. s-&gt;next=front;front=s;</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>15、一个队列的入队序列是1，2，3，4，则队列的出队序列是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A.</span><span style="color:#ff0000;"> 1，2，3，4</span> <span style="color:#000000;">B. </span><span style="color:#000000;">4，3，2，1</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 1，4，3，2 D. 3，4，1，2</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>16、依次在初始为空的队列中插入元素a,b,c,d以后，紧接着做了两次删除操作，此时的队头元素是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. a     B. b       <span style="color:#ff0000;">C. </span><span style="color:#ff0000;">c</span>       D. d</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>17、正常情况下，删除非空的顺序存储结构的堆栈的栈顶元素，栈顶指针top的变化是（   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. top不变     B. top=0    C. top=top+1    <span style="color:#ff0000;">D. top=top-1</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>18、判断一个循环队列Q（空间大小为M）为空的条件是（ A  ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. Q-&gt;front==Q-&gt;rear        B. Q-&gt;rear-Q-&gt;front-1==M    </p> 
<p style="margin-left:.0001pt;text-align:justify;">C. Q-&gt;front+1=Q-&gt;rear       D. Q-&gt;rear+1=Q-&gt;front</p> 
<p style="margin-left:.0001pt;text-align:left;">19、设计一个判别表达式中左右括号是否配对出现的算法，采用（ C  ）数据结构最佳。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 线性表的顺序存储结构 B. 队列 C. 栈    D. 线性表的链式存储结构</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>20、当用大小为N的数组存储顺序循环队列时，该队列的最大长度为（C   ）</strong>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. N B. N+1 C. N-1 D. N-2</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>21、队列的删除操作是在（ A  ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 队首 B. 队尾 C. 队前 D. 队后</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>22、若让元素1，2，3依次进栈，则出栈次序不可能是（ C  ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 3，2，1 B. 2，1，3 C. 3，1，2   D. 1，3，2</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>23、循环队列用数组A[0，m-1]存放其元素值，已知其头尾指针分别是front和rear，则当前队列中的元素个数是（ A  ）</strong>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. (rear-front+m)%m B. rear-front+1</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. rear-front-1 D. rear-front</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>24、栈和队列都是（C   ）</strong>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 链式存储的线性结构      B. 链式存储的非线性结构      </p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 限制存取点的线性结构     D. <span style="color:#000000;">限制存取点的非线性结构</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>25、<span style="color:#000000;">在一个链队列中，假定front和rear分别为队头指针和队尾指针，删除一个结点的操作是</span>（ A  ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. <span style="color:#000000;">front=front-&gt;next</span>    B. <span style="color:#000000;">rear= rear-&gt;next</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">C. <span style="color:#000000;">rear-&gt;next=front</span> D. <span style="color:#000000;">front-&gt;next=rear</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>26、队和栈的主要区别是（ D  ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 逻辑结构不同         B. 存储结构不同</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 所包含的运算个数不同     D. 限定插入和删除的位置不同</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;">二、填空题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、设栈S和队列Q的初始状态为空，元素e1,e2,e3,e4,e5,e6依次通过栈S，一个元素出栈后即进入队列Q，若6个元素出队的序列是e2,e4,e3,e6,e5,e1，则栈的容量至少应该是<u>            </u>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案</span><span style="color:#ff0000;">：3</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">2、一个循环队列Q的存储空间大小为M,其队头和队尾指针分别为front和rear，则循环队列中元素的个数为：<u>           </u>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：</span><span style="color:#ff0000;">(rear-front+M)%M</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">3、在具有n个元素的循环队列中，队满时具有<u>          </u>个元素。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：n-1</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">4、设循环队列的容量为70，现经过一系列的入队和出队操作后，front为20，rear为11，则队列中元素的个数为<u>           </u>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：61</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">5、已知循环队列的存储空间大小为20，且当前队列的头指针和尾指针的值分别为8和3，且该队列的当前的长度为__<span style="color:#ff0000;">__</span><span style="color:#ff0000;">15</span>___。</p> 
<h3 style="margin-left:.0001pt;text-align:justify;">三、判断题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、栈和队列都是受限的线性结构。✔️ </p> 
<p style="margin-left:.0001pt;text-align:justify;">2、在单链表中，要访问某个结点，只要知道该结点的地址即可；因此，单链表是一种随机存取结构。❌</p> 
<p style="margin-left:.0001pt;text-align:justify;">3、以链表作为栈的存储结构，出栈操作必须判别栈空的情况。✔️</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 id="%E5%9B%9B%E3%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%A1%AB%E7%A9%BA%E9%A2%98" style="margin-left:.0001pt;text-align:justify;">四、程序分析填空题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、已知栈的基本操作函数：</p> 
<p style="margin-left:.0001pt;text-align:justify;">int InitStack(SqStack *S); //构造空栈</p> 
<p style="margin-left:.0001pt;text-align:justify;">int StackEmpty(SqStack *S);//判断栈空</p> 
<p style="margin-left:.0001pt;text-align:justify;">int Push(SqStack *S,ElemType e);//入栈</p> 
<p style="margin-left:.0001pt;text-align:justify;">int Pop(SqStack *S,ElemType *e);//出栈</p> 
<p style="margin-left:.0001pt;text-align:justify;">函数conversion实现十进制数转换为八进制数，请将函数补充完整。</p> 
<p style="margin-left:.0001pt;text-align:justify;">void conversion(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">InitStack(S);</p> 
<p style="margin-left:.0001pt;text-align:justify;">scanf(“%d”,&amp;N);</p> 
<p style="margin-left:.0001pt;text-align:justify;">while(N){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;"><u><u>      （1）           </u></u>;</p> 
<p style="margin-left:.0001pt;text-align:justify;">N=N/8;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">while(<u><u>      （2）       </u></u>){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">Pop(S,&amp;e);</p> 
<p style="margin-left:.0001pt;text-align:justify;">printf(“%d”,e);</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">}//conversion</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：（1）</span><span style="color:#ff0000;">Push(S,N%8)    </span> <span style="color:#ff0000;">（2）!StackEmpty(S)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">2、写出算法的功能。</p> 
<p style="margin-left:.0001pt;text-align:justify;">int  function(SqQueue *Q,ElemType *e){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">if(Q-&gt;front==Q-&gt;rear)</p> 
<p style="margin-left:.0001pt;text-align:justify;">return ERROR;</p> 
<p style="margin-left:.0001pt;text-align:justify;">*e=Q-&gt;base[Q-&gt;front];</p> 
<p style="margin-left:.0001pt;text-align:justify;">Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;</p> 
<p style="margin-left:.0001pt;text-align:justify;">return OK;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">若循环队列非空，队头元素出队列且返回其值，否则返回空元素。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">3、阅读算法f2,并回答下列问题：</p> 
<p style="margin-left:.0001pt;text-align:justify;">（1）设队列Q=（1，3，5，2，4，6）。写出执行算法f2后的队列Q;</p> 
<p style="margin-left:.0001pt;text-align:justify;">（2）简述算法f2的功能。</p> 
<p style="margin-left:.0001pt;text-align:justify;">void  f2(Queue *Q){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">   DataType   e;</p> 
<p style="margin-left:.0001pt;text-align:justify;">   if (!QueueEmpty(Q)){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">     e=DeQueue(Q);</p> 
<p style="margin-left:.0001pt;text-align:justify;">     f2(Q);</p> 
<p style="margin-left:.0001pt;text-align:justify;">     EnQueue(Q,e);</p> 
<p style="margin-left:.0001pt;text-align:justify;">   }</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：（1）</span><span style="color:#ff0000;">6,4,2,5,3,1</span> <span style="color:#ff0000;">（2）将队列倒置</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;">五、综合题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾结点，但不设头指针，请写出相应的入队列算法（用函数实现）。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:center;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：</span><span style="color:#ff0000;">void EnQueue(Lnode *rear, ElemType e)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">  {  Lnode *new;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">     <span style="color:#ff0000;">N</span><span style="color:#ff0000;">ew=(Lnode *)malloc(sizeof(Lnode));</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">I</span><span style="color:#ff0000;">f(!new) return ERROR;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">new-&gt;data=e; new-&gt;next=rear-&gt;next; </span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">rear-&gt;next=new; rear =new;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">  }</span></p> 
<p style="margin-left:.0001pt;text-align:left;">2、对于一个栈，给出输入项A,B,C,D，如果输入项序列为A,B,C,D，试给出全部可能的输出序列。 <span style="color:#008000;">4,1,4,1,2,1,1</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：</span><span style="color:#ff0000;">出栈的可能序列：</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">  <span style="color:#008000;">AB</span><span style="color:#ff0000;">CD  </span><span style="color:#008000;">AB</span><span style="color:#ff0000;">DC  </span><span style="color:#000080;">AC</span><span style="color:#ff0000;">DB  </span><span style="color:#000080;">AC</span><span style="color:#ff0000;">BD  </span><span style="color:#800080;">AD</span><span style="color:#ff0000;">CB  </span><span style="color:#ff00ff;">BA</span><span style="color:#ff0000;">CD  </span><span style="color:#ff00ff;">BA</span><span style="color:#ff0000;">DC  </span><span style="color:#ffff00;">BC</span><span style="color:#ff0000;">AD  </span><span style="color:#ffff00;">BC</span><span style="color:#ff0000;">DA </span><span style="color:#0099ff;">BD</span><span style="color:#ff0000;">CA</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">  <span style="color:#663300;">CB</span><span style="color:#ff0000;">DA  </span><span style="color:#663300;">CB</span><span style="color:#ff0000;">AD  </span><span style="color:#663399;">CD</span><span style="color:#ff0000;">BA  </span><span style="color:#333333;">DC</span><span style="color:#ff0000;">BA</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 id="%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%C2%A0%E4%B8%B2" style="margin-left:.0001pt;text-align:center;">第四章  串</h2> 
<h3 style="margin-left:.0001pt;text-align:justify;">一、选择题</h3> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>1、设有两个串S1和S2，求串S2在S1中首次出现位置的运算称作（ C  ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 连接    B. 求子串 C. 模式匹配 D. 判断子串</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2、串与普通的线性表相比较，它的特殊性体现在（  C ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 顺序的存储结构 B. 链式存储结构</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 数据元素是一个字符    D. 数据元素任意</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>3、空串和空格串（  B ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">    A. 相同              B. 不相同    C. 可能相同          D. 无法确定</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>4、与线性表相比，串的插入和删除操作的特点是（ B  ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 通常以串整体作为操作对象 B. 需要更多的辅助空间</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 算法的时间复杂度较高 D. 涉及移动的元素更多</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>5、设SUBSTR(S,i,k)是求S中从第i个字符开始的连续k个字符组成的子串的操作，则对于S=‘Beijing&amp;Nanjing’，SUBSTR(S,4,5)=（ B  ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. ‘ijing’   B. ‘jing&amp;’</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. ‘ingNa’       D. ‘ing&amp;N’</p> 
<p style="margin-left:.0001pt;text-align:justify;">二、填空题</p> 
<p style="margin-left:.0001pt;text-align:justify;">1、求子串在主串中首次出现的位置的运算称为<u>      </u><u><u>模式匹配</u></u><u>      </u>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2、设s=‘I︺AM︺A︺TEACHER’,其长度是__14__。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3、两个串相等的充分必要条件是两个串的长度相等且<u>       </u><u><u>对应位置字符相同</u></u><u>        </u> 。</p> 
<p style="margin-left:.0001pt;text-align:justify;">四、程序填空题</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>1、函数实现串的模式匹配算法，请在空格处将算法补充完整。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">int index_bf(sstring *s,sstring *t,int start){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    int i=start-1,j=0;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    while(i&lt;s-&gt;len&amp;&amp;j&lt;t-&gt;len)</p> 
<p style="margin-left:.0001pt;text-align:justify;">        if(s-&gt;data[i]==t-&gt;data[j]){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">            i++;j++;</p> 
<p style="margin-left:.0001pt;text-align:justify;">        }else{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">            i=<u>     </u><u><u>i-j+1</u></u><u>     </u>;j=0;</p> 
<p style="margin-left:.0001pt;text-align:justify;">        }</p> 
<p style="margin-left:.0001pt;text-align:justify;">    if(j&gt;=t-&gt;len)</p> 
<p style="margin-left:.0001pt;text-align:justify;">        return <u>    </u><u><u>i-t-&gt;len+1</u></u><u>      </u>;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    else</p> 
<p style="margin-left:.0001pt;text-align:justify;">        return -1;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}}</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2、写出下面算法的功能。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">int function(SqString *s1,SqString *s2){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">int i;</p> 
<p style="margin-left:.0001pt;text-align:justify;">for(i=0;i&lt;s1-&gt;length&amp;&amp;i&lt;s1-&gt;length;i++)</p> 
<p style="margin-left:.0001pt;text-align:justify;">if(s-&gt;data[i]!=s2-&gt;data[i])</p> 
<p style="margin-left:.0001pt;text-align:justify;">return s1-&gt;data[i]-s2-&gt;data[i];</p> 
<p style="margin-left:.0001pt;text-align:justify;">return s1-&gt;length-s2-&gt;length;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">答案：.串比较算法</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>3、写出算法的功能。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">int fun(sqstring *s,sqstring *t,int start){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    int i=start-1,j=0;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    while(i&lt;s-&gt;len&amp;&amp;j&lt;t-&gt;len)</p> 
<p style="margin-left:.0001pt;text-align:justify;">        if(s-&gt;data[i]==t-&gt;data[j]){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">            i++;j++;</p> 
<p style="margin-left:.0001pt;text-align:justify;">        }else{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">            i=i-j+1;j=0;</p> 
<p style="margin-left:.0001pt;text-align:justify;">        }</p> 
<p style="margin-left:.0001pt;text-align:justify;">    if(j&gt;=t-&gt;len)</p> 
<p style="margin-left:.0001pt;text-align:justify;">        return i-t-&gt;len+1;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    else</p> 
<p style="margin-left:.0001pt;text-align:justify;">        return -1;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">答案：串的模式匹配算法</p> 
<p style="margin-left:.0001pt;text-align:center;"></p> 
<p style="margin-left:.0001pt;text-align:center;"></p> 
<h2 id="%E6%95%B0%E7%BB%84" style="margin-left:.0001pt;text-align:center;">数组</h2> 
<h3 style="margin-left:.0001pt;text-align:justify;">一、选择题</h3> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>1、数组A[0..5,0..6]的每个元素占5个字节，将其按列优先次序存储在起始地址为1000的内存单元中，则元素A[5][5]的地址是（A   ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 1175    B. 1180 C. 1205  D. 1210</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2、常对数组进行两种基本操作是（ C  ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 建立和删除   B. 索引和修改 C. 查找和修改     D. 查找与索引</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>3、对一些特殊矩阵采用压缩存储的目的主要是为了（ D  ）。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 表达变得简单          B. 对矩阵元素的存取变得简单</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 去掉矩阵中的多余元素     D. 减少不必要的存储空间的开销</p> 
<h3 id="%E4%BA%8C%E3%80%81%E5%88%A4%E6%96%AD%E9%A2%98" style="margin-left:.0001pt;text-align:justify;">二、判断题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">（√ ）1、稀疏矩阵压缩存储后，必会失去随机存取功能。</p> 
<h3 id="%E4%B8%89%E3%80%81%E5%A1%AB%E7%A9%BA%E9%A2%98" style="margin-left:.0001pt;text-align:justify;">三、填空题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、已知二维数组A[m][n]采用行序为主方式存储，每个元素占k个存储单元，并且第一个元素的存储地址是LOC(A[0][0])，则A[i][j]的地址是___<u><u> Loc(A[0][0])+(i*N+j)*k</u></u> ____。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2、二维数组，可以按照<u><u>   列序为主和行序为主                      </u></u>两种不同的存储方式。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3、稀疏矩阵的压缩存储方式有：<u> </u><u><u>三元组</u></u><u>         </u>和<u> </u><u><u>十字链表</u></u><u>         </u>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 id="%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%A0%91" style="margin-left:.0001pt;text-align:center;">第六章 树</h2> 
<h3 style="margin-left:.0001pt;text-align:justify;">一、选择题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、二叉树的深度为k，则二叉树最多有（ C  ）个结点。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 2k      B. 2k-1     C. 2k-1     D. 2k-1</p> 
<p style="margin-left:.0001pt;text-align:justify;">2、用顺序存储的方法，将完全二叉树中所有结点按层逐个从左到右的顺序存放在一维数组R[1..N]中，若结点R[i]有右孩子，则其右孩子是（ B  ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. R[2i-1]   B. R[2i+1] C. R[2i]     D. R[2/i]</p> 
<p style="margin-left:.0001pt;text-align:justify;">3、设a,b为一棵二叉树上的两个结点，在中序遍历时，a在b前面的条件是（  B ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. a在b的右方    B. a在b的左方</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. a是b的祖先 D. a是b的子孙</p> 
<p style="margin-left:.0001pt;text-align:justify;">4、设一棵二叉树的中序遍历序列：badce，后序遍历序列：bdeca，则二叉树先序遍历序列为（ D  ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. adbce      B. decab     C. debac     D. abcde</p> 
<p style="margin-left:.0001pt;text-align:justify;">5、在一棵具有5层的满二叉树中结点总数为（ A  ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">    A. 31        B. 32     C.  33       D. 16</p> 
<p style="margin-left:.0001pt;text-align:justify;">6、由二叉树的前序和后序遍历序列（  B ）惟一确定这棵二叉树。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 能    B. 不能</p> 
<p style="margin-left:.0001pt;text-align:justify;">7、某二叉树的中序序列为ABCDEFG，后序序列为BDCAFGE，则其左子树中结点数目为（  C ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 3 B. 2 C. 4 D. 5</p> 
<p style="margin-left:.0001pt;text-align:justify;">8、若以{4,5,6,7,8}作为权值构造哈夫曼树，则该树的带权路径长度为（ C  ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 67 B. 68 C. 69 D. 70</p> 
<p style="margin-left:.0001pt;text-align:justify;">9、将一棵有100个结点的完全二叉树从根这一层开始，每一层上从左到右依次对结点进行编号，根结点的编号为1，则编号为49的结点的左孩子编号为（  A ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 98 B. 99 C. 50 D. 48</p> 
<p style="margin-left:.0001pt;text-align:justify;">10、对某二叉树进行先序遍历的结果为ABDEFC，中序遍历的结果为DBFEAC，则后序遍历的结果是（  B ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. DBFEAC B. DFEBCA C. BDFECA D. BDEFAC</p> 
<p style="margin-left:.0001pt;text-align:justify;">11、树最适合用来表示（ C  ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 有序数据元素     B. 无序数据元素    C. 元素之间具有分支层次关系的数据    D. 元素之间无联系的数据</p> 
<p style="margin-left:.0001pt;text-align:justify;">12、在线索二叉树中，t所指结点没有左子树的充要条件是（B   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. t-&gt;left==NULL B. t-&gt;ltag==1</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. t-&gt;ltag==1&amp;&amp;t-&gt;left==NULL D. 以上都不对</p> 
<p style="margin-left:.0001pt;text-align:justify;">13、假定在一棵二叉树中，度为2的结点数为15，度为1的结点数为30，则叶子结点数为（ B  ）个。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 15 B. 16 C. 17 D. 47</p> 
<p style="margin-left:.0001pt;text-align:justify;">14、在下列情况中，可称为二叉树的是（ B  ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 每个结点至多有两棵子树的树 B. 哈夫曼树</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 每个结点至多有两棵子树的有序树 D. 每个结点只有一棵子树</p> 
<p style="margin-left:.0001pt;text-align:justify;">15、用顺序存储的方法，将完全二叉树中所有结点按层逐个从左到右的顺序存放在一维数组R[1..n]中，若结点R[i]有左孩子，则其左孩子是（C   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. R[2i-1]     B. R[2i+1] C. R[2i]     D. R[2/i]</p> 
<p style="margin-left:.0001pt;text-align:justify;">16、下面说法中正确的是（ D  ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 度为2的树是二叉树      B. 度为2的有序树是二叉树   </p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 子树有严格左右之分的树是二叉树 D. 子树有严格左右之分，且度不超过2的树是二叉树</p> 
<p style="margin-left:.0001pt;text-align:justify;">17、按照二叉树的定义，具有3个结点的二叉树有（ C  ）种。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 3 B. 4 C. 5 D. 6</p> 
<p style="margin-left:.0001pt;text-align:left;">18、由权值为3，6，7，2，5的叶子结点生成一棵哈夫曼树，它的带权路径长度为（  A ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 51 B. 23 C. 53    D. 74</p> 
<h3 style="margin-left:.0001pt;text-align:justify;">二、判断题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">（ √）1、存在这样的二叉树，对它采用任何次序的遍历，结果相同。</p> 
<p style="margin-left:.0001pt;text-align:justify;">（× ）4、在哈夫曼编码中，当两个字符出现的频率相同时，其编码也相同，对于这种情况应做特殊处理。</p> 
<p style="margin-left:.0001pt;text-align:justify;">（√ ）5、一个含有n个结点的完全二叉树，它的高度是ëlog2nû＋1。</p> 
<p style="margin-left:.0001pt;text-align:justify;">（√ ）6、完全二叉树的某结点若无左孩子，则它必是叶结点。</p> 
<h3 style="margin-left:.0001pt;text-align:justify;">三、填空题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、具有n个结点的完全二叉树的深度是<u>     </u><u><u>ë</u></u><u><u>log</u></u><u><u>2</u></u><u><u>n</u></u><u><u>û</u></u><u><u>+1</u></u><u>      </u>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2、哈夫曼树是其树的带权路径长度<u>     </u><u><u>最小</u></u><u>       </u> 的二叉树。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3、在一棵二叉树中，度为0的结点的个数是n0，度为2的结点的个数为n2，则有n0=<u>           </u><u><u>N</u></u><u><u>2+1</u></u><u>           </u> 。</p> 
<p style="margin-left:.0001pt;text-align:justify;">4、树内各结点度的<u>      </u><u><u>最大值</u></u><u>      </u>称为树的度。</p> 
<h3 id="%E5%9B%9B%E3%80%81%E4%BB%A3%E7%A0%81%E5%A1%AB%E7%A9%BA%E9%A2%98" style="margin-left:.0001pt;text-align:justify;">四、代码填空题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、函数InOrderTraverse(Bitree bt)实现二叉树的中序遍历，请在空格处将算法补充完整。</p> 
<p style="margin-left:.0001pt;text-align:justify;">void InOrderTraverse(BiTree bt){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">if(<u>         </u>){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">InOrderTraverse(bt-&gt;lchild);</p> 
<p style="margin-left:.0001pt;text-align:justify;">printf(“%c”,bt-&gt;data);</p> 
<p style="margin-left:.0001pt;text-align:justify;"><u>                                </u>;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">2、函数depth实现返回二叉树的高度，请在空格处将算法补充完整。</p> 
<p style="margin-left:.0001pt;text-align:justify;">int depth(Bitree *t){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">if(t==NULL)</p> 
<p style="margin-left:.0001pt;text-align:justify;">return 0;</p> 
<p style="margin-left:.0001pt;text-align:justify;">else{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">hl=depth(t-&gt;lchild);</p> 
<p style="margin-left:.0001pt;text-align:justify;">hr=<u>       </u><u><u>depth(t-&gt;rchild)</u></u><u>            </u>;</p> 
<p style="margin-left:.0001pt;text-align:justify;">if(<u>     </u><u><u>hl&gt;hr</u></u><u>     </u>)</p> 
<p style="margin-left:.0001pt;text-align:justify;">return hl+1;</p> 
<p style="margin-left:.0001pt;text-align:justify;">else</p> 
<p style="margin-left:.0001pt;text-align:justify;">return hr+1;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">3、写出下面算法的功能。</p> 
<p style="margin-left:.0001pt;text-align:justify;">int LeafNodeCount(BiTree T)</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">if(T==NULL)</p> 
<p style="margin-left:.0001pt;text-align:justify;">return 0; //如果是空树，则叶子结点个数为0</p> 
<p style="margin-left:.0001pt;text-align:justify;">else if(T-&gt;lchild==NULL&amp;&amp;T-&gt;rchild==NULL)</p> 
<p style="margin-left:.0001pt;text-align:justify;">return 1;</p> 
<p style="margin-left:.0001pt;text-align:justify;">else</p> 
<p style="margin-left:.0001pt;text-align:justify;">return LeafNodeCount(T-&gt;lchild)+LeafNodeCount(T-&gt;rchild);</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">答案：统计二叉树的叶结点个数</p> 
<h3 style="margin-left:.0001pt;text-align:left;">五、综合题</h3> 
<p style="margin-left:.0001pt;text-align:left;">1、假设一棵二叉树的先序序列为EBADCFHGIKJ，中序序列为ABCDEFGHIJK，请画出该二叉树。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2、假设用于通讯的电文仅由8个字母A、B、C、D、E、F、G、H组成，字母在电文中出现的频率分别为：0.07，0.19，0.02，0.06，0.32，0.03，0.21，0.10。请为这8个字母设计哈夫曼编码。</p> 
<p style="margin-left:.0001pt;text-align:center;">答案：<img alt="" src="https://images2.imgbox.com/bb/98/awrq6v3M_o.png"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:left;">3、已知二叉树的先序遍历序列为ABCDEFGH，中序遍历序列为CBEDFAGH，画出二叉树。</p> 
<p style="margin-left:.0001pt;text-align:justify;">答案：二叉树形态                       </p> 
<p style="margin-left:.0001pt;text-align:center;">       <img alt="" src="https://images2.imgbox.com/e6/f0/INCKrzs3_o.png"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;">4、试用权集合{12,4,5,6,1,2}构造哈夫曼树，并计算哈夫曼树的带权路径长度。</p> 
<p style="margin-left:.0001pt;">答案：                     <img alt="" src="https://images2.imgbox.com/2d/73/4V6WaxGR_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">WPL=12*1+(4+5+6)*3+(1+2)*4=12+45+12=69</p> 
<p style="margin-left:.0001pt;text-align:justify;">5、已知权值集合为{5,7,2,3,6,9}，要求给出哈夫曼树，并计算带权路径长度WPL。</p> 
<p style="margin-left:.0001pt;text-align:center;">答案：(1)树形态：              <img alt="" src="https://images2.imgbox.com/d5/b6/4eCcW4oe_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">(2)带权路径长度：WPL=(6+7+9)*2+5*3+(2+3)*4=44+15+20=79</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">6、已知一棵二叉树的先序序列：ABDGJEHCFIKL；中序序列：DJGBEHACKILF。画出二叉树的形态。</p> 
<p style="margin-left:.0001pt;text-align:center;">答案：<img alt="" src="https://images2.imgbox.com/2f/da/jUW4ekn6_o.png"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;">7、一份电文中有6种字符：A,B,C,D,E,F，它们的出现频率依次为16，5，9，3，30，1，完成问题：</p> 
<p style="margin-left:.0001pt;text-align:justify;">（1）设计一棵哈夫曼树；（画出其树结构）</p> 
<p style="margin-left:.0001pt;text-align:justify;">（2）计算其带权路径长度WPL；</p> 
<p style="margin-left:.0001pt;">答案：(1)树形态：<img alt="" src="https://images2.imgbox.com/30/18/7QUb3ozq_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">   (2)带权路径长度：WPL=30*1+16*2+9*3+5*4+(1+3)*5=30+32+27+20+20=129</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">8、已知某森林的二叉树如下所示，试画出它所表示的森林。</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/82/23/CdhGO2YA_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">答案：</p> 
<p style="margin-left:.0001pt;text-align:center;">   <img alt="" src="https://images2.imgbox.com/c0/c3/AUnU3dJE_o.png"></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:left;">9、如下所示的二叉树，请写出先序、中序、后序遍历的序列。</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/b5/0d/I5Yq6TV9_o.png"></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"> 答案：先序：FDBACEGIHJ</p> 
<p style="margin-left:.0001pt;text-align:justify;">   中序：ABCDEFGHIJ</p> 
<p style="margin-left:.0001pt;text-align:justify;">   后序：ACBEDHJIGF</p> 
<h3 id="%E5%85%AD%E3%80%81%E7%BC%96%E7%A8%8B%E9%A2%98" style="margin-left:.0001pt;text-align:justify;">六、编程题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、编写求一棵二叉树中结点总数的算法。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 id="%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%9B%BE" style="margin-left:.0001pt;text-align:center;">第七章 图</h2> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;">一、选择题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、对于具有n个顶点的图，若采用邻接矩阵表示，则该矩阵的大小为（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. n      <span style="color:#ff0000;">B. </span><span style="color:#ff0000;">n</span><span style="color:#ff0000;">2</span>     C. n-1     D. (n-1)2</p> 
<p style="margin-left:.0001pt;text-align:justify;">2、如果从无向图的任一顶点出发进行一次深度优先搜索即可访问所有顶点，则该图一定是（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 完全图 <span style="color:#ff0000;">B. </span><span style="color:#ff0000;">连通图</span> C. 有回路    D. 一棵树</p> 
<p style="margin-left:.0001pt;text-align:justify;">3、带权有向图G用邻接矩阵A存储，则顶点i的入度等于A中（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 第i行非无穷的元素之和 <span style="color:#ff0000;">B. </span><span style="color:#ff0000;">第i列非无穷的元素个数之和</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 第i行非无穷且非0的元素个数 D. 第i行与第i列非无穷且非0的元素之和</p> 
<p style="margin-left:.0001pt;text-align:justify;">4、采用邻接表存储的图，其深度优先遍历类似于二叉树的（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 中序遍历   <span style="color:#ff0000;">B. </span><span style="color:#ff0000;">先序遍历</span> C. 后序遍历     D. 按层次遍历</p> 
<p style="margin-left:.0001pt;text-align:justify;">5、无向图的邻接矩阵是一个（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. </span><span style="color:#ff0000;">对称矩阵</span>      B. 零矩阵   C. 上三角矩阵     D. 对角矩阵</p> 
<p style="margin-left:.0001pt;text-align:justify;">6、邻接表是图的一种（  ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 顺序存储结构     <span style="color:#ff0000;">B.</span> <span style="color:#ff0000;">链式存储结构</span>    C. 索引存储结构  D. 散列存储结构</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">7、在无向图中定义顶点vi与vj之间的路径为从vi到vj的一个（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#ff0000;">A. </span><span style="color:#ff0000;">顶点序列</span>         B. 边序列    C. 权值总和        D. 边的条数</p> 
<p style="margin-left:.0001pt;text-align:justify;">8、在有向图的逆邻接表中，每个顶点邻接表链接着该顶点所有（   ）邻接点。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. </span><span style="color:#ff0000;">入边</span> B. 出边 C. 入边和出边    D. 不是出边也不是入边</p> 
<p style="margin-left:.0001pt;text-align:justify;">9、设G1=(V1,E1)和G2=(V2,E2)为两个图，如果V1ÍV2,E1ÍE2则称（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. </span><span style="color:#ff0000;">G1是G2的子图</span>   B. G2是G1的子图     C. G1是G2的连通分量 D. G2是G1的连通分量</p> 
<p style="margin-left:.0001pt;text-align:justify;">10、已知一个有向图的邻接矩阵表示，要删除所有从第i个结点发出的边，应（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 将邻接矩阵的第i行删除      <span style="color:#ff0000;">B. </span><span style="color:#ff0000;">将邻接矩阵的第i行元素全部置为0</span>      C. 将邻接矩阵的第i列删除     D. 将邻接矩阵的第i列元素全部置为0</p> 
<p style="margin-left:.0001pt;text-align:justify;">11、在一个有向图中，所有顶点的入度之和等于所有顶点的出度之和的（   ）倍。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 1/2   <span style="color:#ff0000;">B. </span><span style="color:#ff0000;">1</span> C. 2     D. 4</p> 
<p style="margin-left:.0001pt;text-align:justify;">12、下列关于图遍历的说法不正确的是（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 连通图的深度优先搜索是一个递归过程     </p> 
<p style="margin-left:.0001pt;text-align:justify;">B. 图的广度优先搜索中邻接点的寻找具有“先进先出”的特征     </p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">C. </span><span style="color:#ff0000;">非连通图不能用深度优先搜索法</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">D. 图的遍历要求每一顶点仅被访问一次</p> 
<p style="margin-left:.0001pt;text-align:justify;">13、带权有向图G用邻接矩阵A存储，则顶点i的入度为A中：（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 第i行非¥的元素之和    B. 第i列非¥的元素之和</p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 第i行非¥且非0的元素个数   <span style="color:#ff0000;">D. </span><span style="color:#ff0000;">第</span><span style="color:#ff0000;">i</span><span style="color:#ff0000;">列非</span><span style="color:#ff0000;">¥</span><span style="color:#ff0000;">且非</span><span style="color:#ff0000;">0</span><span style="color:#ff0000;">的元素个数</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">14、采用邻接表存储的图的广度优先遍历算法类似于二叉树的（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 先序遍历   B. 中序遍历 C. 后序遍历 <span style="color:#ff0000;">D. </span><span style="color:#ff0000;">按层次遍历</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">15、一个具有n个顶点的有向图最多有（   ）条边。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. n×(n-1)/2      <span style="color:#ff0000;">B. n×(n-1)</span>    C. n×(n+1)/2 D. n2</p> 
<p style="margin-left:.0001pt;text-align:justify;">16、已知一个有向图的邻接表存储结构如图所示，根据深度优先遍历算法，从顶点v1出发，所得到的顶点序列是（   ）。</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/35/34/lsuIAWpi_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. v1,v2,v3,v5,v4   B. v1,v2,v3,v4,v5</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">C. </span><span style="color:#ff0000;">v1,v3,v4,v5,v2</span>     D. v1,v4,v3,v5,v2</p> 
<p style="margin-left:.0001pt;text-align:justify;">17、以下说法正确的是（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 连通分量是无向图中的极小连通子图</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">B. </span><span style="color:#ff0000;">强连通分量是有向图中的极大强连通子图</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 在一个有向图的拓扑序列中若顶点a在顶点b之前，则图中必有一条弧&lt;a,b&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">D. 对有向图G，如果以任一顶点出发进行一次深度优先或广度优先搜索能访问到每个顶点，则该图一定是完全图</p> 
<p style="margin-left:.0001pt;text-align:justify;">18、假设有向图含n个顶点及e条弧，则表示该图的邻接表中包含的弧结点个数为（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. n    <span style="color:#ff0000;">B. </span><span style="color:#ff0000;">e</span> C. 2e   D. n*e</p> 
<p style="margin-left:.0001pt;text-align:justify;">19、设图的邻接矩阵为，则该图为（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">A. </span><span style="color:#ff0000;">有向图</span>   B. 无向图 C. 强连通图     D. 完全图</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">20</span>、任何一个无向连通图的最小生成树（   ）种。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 只有一棵 <span style="color:#ff0000;">B.</span> <span style="color:#ff0000;">有一棵或多棵</span> C. 一定有多棵 D. 可能不存在</p> 
<p style="margin-left:.0001pt;text-align:left;">21、已知一有向图的邻接表存储结构如图所示，根据有向图的广度优先遍历算法，从顶点v1出发，所得到的顶点序列是（   ）。</p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="197" src="https://images2.imgbox.com/1b/56/OBn1QCCz_o.png" width="352"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">A. v1,v2,v3,v4,v5 <span style="color:#ff0000;">B. </span><span style="color:#ff0000;">v1,v3,v2,v4,v5</span> C. v1,v2,v3,v5,v4    D. v1,v4,v3,v5,v2</p> 
<p style="margin-left:.0001pt;text-align:justify;">22、对于一个有向图，若一个顶点的入度为k1,、出度为k2，则对应邻接表中该顶点单链表中的结点数为（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. k1 <span style="color:#ff0000;">B.</span><span style="color:#ff0000;"> k2</span> C. k1+k2 D. k1-k2</p> 
<p style="margin-left:.0001pt;text-align:justify;">22、一个具有8个顶点的有向图中，所有顶点的入度之和与所有顶点的出度之和的差等于（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 16     B. 4 <span style="color:#ff0000;">C. </span><span style="color:#ff0000;">0</span>     D. 2</p> 
<p style="margin-left:.0001pt;text-align:left;">23、无向图中一个顶点的度是指图中（   ）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">A. 通过该顶点的简单路径数 <span style="color:#ff0000;">B. </span><span style="color:#ff0000;">与该顶点相邻接的顶点数</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">C. 与该顶点连通的顶点数    D. 通过该顶点的回路数</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;">二、填空题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、n个顶点的连通图至少有<u>           </u> 边。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：</span><span style="color:#ff0000;">n-1条</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">2、一个连通图的生成树是一个<u>      </u><u>         </u><u>   </u>，它包含图中所有顶点，但只有足以构成一棵树的n-1条边。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：</span><span style="color:#ff0000;">极小连通子图</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">3、一个图的<u>           </u>表示法是惟一的。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：</span><span style="color:#ff0000;">邻接矩阵</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">4、遍历图的基本方法有深度优先搜索和广度优先搜索，其中<u>        </u>是一个递归过程。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案</span><span style="color:#ff0000;">：</span><span style="color:#ff0000;">深度优先搜索</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">5、在无向图G的邻接矩阵A中，若A[i][j]等于1，则A[j][i]等于<u>      </u><u>         </u><u>   </u>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案</span><span style="color:#ff0000;">：1</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">6、已知一个图的邻接矩阵表示，计算第i个结点的入度的方法是<u> </u><u><span style="color:#ff0000;"><u>求第i列的和</u></span></u><u> </u>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">7、n个顶点的无向图最多有<u>                     </u>边。</p> 
<p style="margin-left:.0001pt;text-align:justify;">8、已知一个图的邻接矩阵表示，删除所有从第i个结点出发的边的方法是<u> </u><u><span style="color:#ff0000;"><u>将第I行和第I列的值全部更新为零）</u></span></u><u><u>。  </u></u>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">9、若以邻接矩阵表示有向图，则邻接矩阵上第i行中非零元素的个数即为顶点vi的<u>       </u>。</p> 
<h3 style="margin-left:.0001pt;text-align:justify;">三、判断题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、图的连通分量是无向图的极小连通子图。 <span style="color:#ff0000;">O</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">2、一个图的广度优先搜索树是惟一的。<span style="color:#ff0000;">O</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">3、图的深度优先搜索序列和广度优先搜索序列不是惟一的。<span style="color:#ff0000;">P</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">4、邻接表只能用于存储有向图，而邻接矩阵则可存储有向图和无向图。<span style="color:#ff0000;">O</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">5、存储图的邻接矩阵中，邻接矩阵的大小不但与图的顶点个数有关，而且与图的边数也有关。<span style="color:#ff0000;">O</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">6、邻接表只能用于存储有向图，而邻接矩阵则可存储有向图和无向图。<span style="color:#ff0000;">O</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">7、图的生成树是惟一的。<span style="color:#ff0000;">O</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 id="%E5%9B%9B%E3%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E9%A2%98" style="margin-left:.0001pt;text-align:justify;">四、程序分析题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、写出下面算法的功能。</p> 
<p style="margin-left:.0001pt;text-align:justify;">typedef struct{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">     int vexnum,arcnum;</p> 
<p style="margin-left:.0001pt;text-align:justify;">     char vexs[N];</p> 
<p style="margin-left:.0001pt;text-align:justify;">     int arcs[N][N];</p> 
<p style="margin-left:.0001pt;text-align:justify;">}graph;</p> 
<p style="margin-left:.0001pt;text-align:justify;">void funtion(int i,graph *g){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">     int j;</p> 
<p style="margin-left:.0001pt;text-align:justify;">     printf("node:%c\n",g-&gt;vexs[i]);</p> 
<p style="margin-left:.0001pt;text-align:justify;">     visited[i]=TRUE;</p> 
<p style="margin-left:.0001pt;text-align:justify;">     for(j=0;j&lt;g-&gt;vexnum;j++)         if((g-&gt;arcs[i][j]==1)&amp;&amp;(!visited[j]))</p> 
<p style="margin-left:.0001pt;text-align:justify;">            function(j,g);</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：实现图的深度优先遍历算法</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;">五、综合题</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、已知图G的邻接矩阵如下所示：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/d9/d5/6xOaaSGb_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;">求从顶点1出发的广度优先搜索序列；</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：</span><span style="color:#ff0000;">(1)广度优先遍历序列：1; 2, 3, 4; 5; 6</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:left;">2、设一个无向图的邻接矩阵如下图所示：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/ed/b9/NAl3BIdX_o.png"></p> 
<p style="margin-left:.0001pt;text-align:left;">（1）画出该图；</p> 
<p style="margin-left:.0001pt;text-align:left;">（2）画出从顶点0出发的深度优先生成树；</p> 
<p style="margin-left:.0001pt;text-align:center;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">答案：                   (1)图形态                                                   (2)深度优先搜索树</span></p> 
<p style="margin-left:.0001pt;text-align:center;"><span style="color:#ff0000;"><img alt="" src="https://images2.imgbox.com/bc/36/VyVZrClz_o.png"></span></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d8e33ebf1bcbbf907703fc0964bfb55d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java - 数据结构，哈希表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3d709435a44c203e55bee4e9ac52a15e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java - 数据结构，栈</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>