<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>组件-ulog - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="组件-ulog" />
<meta property="og:description" content="目录
1、ulog 简介
1.1、特性
1.2、架构
1.3、配置选项
1.3.1、配置项
1.3.2、宏
1.4、日志级别
1.4.1、不使用ULOG_USING_SYSLOG
1.4.2、使用ULOG_USING_SYSLOG
1.4.3、静态级别与动态级别
1.4.4、全局级别与模块级别
1.4.5、设定日志的输出级别
1.5、日志标签
2、日志输出
2.1、宏 LOG_X(...)
2.2、ulog_x(LOG_TAG, __VA_ARGS__)
2.3、LOG_RAW()和ulog_raw()
2.4、LOG_HEX()和ulog_hex()
2.5、接口函数
2.5.1、ulog_raw()函数
2.5.2、ulog_hexdump()函数
2.5.3、ulog_output()函数
2.6、内部函数
2.6.1、output_lock()函数
2.6.2、output_unlock()函数
2.6.3、get_log_buf()函数
2.6.4、do_output()函数
2.6.5、ulog_output_to_all_backend()函数
2.6.6、ulog_voutput()函数
2.6.7、ulog_flush()函数
3、设置日志格式
3.1、函数
3.1.1、ulog_head_formater()函数
3.1.2、ulog_tail_formater()函数
3.1.3、ulog_hex_formater()函数
3.1.4、ulog_formater()函数
4、动态过滤器
4.1、接口函数
4.1.1、ulog_tag_lvl_list_get()函数
4.1.2、ulog_global_filter_lvl_set()函数
4.1.3、ulog_global_filter_lvl_get()函数
4.1.4、ulog_global_filter_tag_set()函数
4.1.5、ulog_global_filter_tag_get()函数
4.1.6、ulog_global_filter_kw_set()函数
4.1.7、ulog_global_filter_kw_get()函数
4.1.8、ulog_tag_lvl_filter_set()函数
4.1.9、ulog_tag_lvl_filter_get()函数
5、异步输出
5.1、异步模式的优缺点
5.1.1、优点
5.1.2、缺点
5.2、结构体
5.2.1、rt_ulog结构体
5.2.2、ulog_frame结构体
5.3、函数
5.3.1、ulog_async_output_enabled()函数
5.3.2、ulog_async_output()函数
5.3.3、ulog_async_waiting_log()函数
5.3.4、async_output_thread_entry()函数
5.3.5、ulog_async_init()函数
6、中断输出
7、后端
7.1、ulog_backend结构体
7.2、接口
7.2.1、ulog_backend_register()函数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/d17ba583458a1af086197cd43c49d5d3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-03T14:05:35+08:00" />
<meta property="article:modified_time" content="2022-11-03T14:05:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">组件-ulog</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81ulog%20%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#1%E3%80%81ulog%20%E7%AE%80%E4%BB%8B" rel="nofollow">1、ulog 简介</a></p> 
<p id="1.1%E3%80%81%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#1.1%E3%80%81%E7%89%B9%E6%80%A7" rel="nofollow">1.1、特性</a></p> 
<p id="1.2%E3%80%81%E6%9E%B6%E6%9E%84-toc" style="margin-left:40px;"><a href="#1.2%E3%80%81%E6%9E%B6%E6%9E%84" rel="nofollow">1.2、架构</a></p> 
<p id="1.3%E3%80%81%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9-toc" style="margin-left:40px;"><a href="#1.3%E3%80%81%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9" rel="nofollow">1.3、配置选项</a></p> 
<p id="1.3.1%E3%80%81%E9%85%8D%E7%BD%AE%E9%A1%B9-toc" style="margin-left:80px;"><a href="#1.3.1%E3%80%81%E9%85%8D%E7%BD%AE%E9%A1%B9" rel="nofollow">1.3.1、配置项</a></p> 
<p id="%C2%A01.3.2%E3%80%81%E5%AE%8F-toc" style="margin-left:80px;"><a href="#%C2%A01.3.2%E3%80%81%E5%AE%8F" rel="nofollow"> 1.3.2、宏</a></p> 
<p id="1.4%E3%80%81%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB-toc" style="margin-left:40px;"><a href="#1.4%E3%80%81%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB" rel="nofollow">1.4、日志级别</a></p> 
<p id="1.4.1%E3%80%81%E4%B8%8D%E4%BD%BF%E7%94%A8ULOG_USING_SYSLOG-toc" style="margin-left:80px;"><a href="#1.4.1%E3%80%81%E4%B8%8D%E4%BD%BF%E7%94%A8ULOG_USING_SYSLOG" rel="nofollow">1.4.1、不使用ULOG_USING_SYSLOG</a></p> 
<p id="1.4.2%E3%80%81%E4%BD%BF%E7%94%A8ULOG_USING_SYSLOG-toc" style="margin-left:80px;"><a href="#1.4.2%E3%80%81%E4%BD%BF%E7%94%A8ULOG_USING_SYSLOG" rel="nofollow">1.4.2、使用ULOG_USING_SYSLOG</a></p> 
<p id="1.4.3%E3%80%81%E9%9D%99%E6%80%81%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BA%A7%E5%88%AB-toc" style="margin-left:80px;"><a href="#1.4.3%E3%80%81%E9%9D%99%E6%80%81%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BA%A7%E5%88%AB" rel="nofollow">1.4.3、静态级别与动态级别</a></p> 
<p id="1.4.4%E3%80%81%E5%85%A8%E5%B1%80%E7%BA%A7%E5%88%AB%E4%B8%8E%E6%A8%A1%E5%9D%97%E7%BA%A7%E5%88%AB-toc" style="margin-left:80px;"><a href="#1.4.4%E3%80%81%E5%85%A8%E5%B1%80%E7%BA%A7%E5%88%AB%E4%B8%8E%E6%A8%A1%E5%9D%97%E7%BA%A7%E5%88%AB" rel="nofollow">1.4.4、全局级别与模块级别</a></p> 
<p id="1.4.5%E3%80%81%E8%AE%BE%E5%AE%9A%E6%97%A5%E5%BF%97%E7%9A%84%E8%BE%93%E5%87%BA%E7%BA%A7%E5%88%AB-toc" style="margin-left:80px;"><a href="#1.4.5%E3%80%81%E8%AE%BE%E5%AE%9A%E6%97%A5%E5%BF%97%E7%9A%84%E8%BE%93%E5%87%BA%E7%BA%A7%E5%88%AB" rel="nofollow">1.4.5、设定日志的输出级别</a></p> 
<p id="1.5%E3%80%81%E6%97%A5%E5%BF%97%E6%A0%87%E7%AD%BE-toc" style="margin-left:40px;"><a href="#1.5%E3%80%81%E6%97%A5%E5%BF%97%E6%A0%87%E7%AD%BE" rel="nofollow">1.5、日志标签</a></p> 
<p id="2%E3%80%81%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA" rel="nofollow">2、日志输出</a></p> 
<p id="2.1%E3%80%81%E5%AE%8F%C2%A0LOG_X(...)-toc" style="margin-left:40px;"><a href="#2.1%E3%80%81%E5%AE%8F%C2%A0LOG_X%28...%29" rel="nofollow">2.1、宏 LOG_X(...)</a></p> 
<p id="2.2%E3%80%81ulog_x(LOG_TAG%2C%C2%A0__VA_ARGS__)-toc" style="margin-left:40px;"><a href="#2.2%E3%80%81ulog_x%28LOG_TAG%2C%C2%A0__VA_ARGS__%29" rel="nofollow">2.2、ulog_x(LOG_TAG, __VA_ARGS__)</a></p> 
<p id="2.3%E3%80%81LOG_RAW()%E5%92%8Culog_raw()-toc" style="margin-left:40px;"><a href="#2.3%E3%80%81LOG_RAW%28%29%E5%92%8Culog_raw%28%29" rel="nofollow">2.3、LOG_RAW()和ulog_raw()</a></p> 
<p id="2.4%E3%80%81LOG_HEX()%E5%92%8Culog_hex()-toc" style="margin-left:40px;"><a href="#2.4%E3%80%81LOG_HEX%28%29%E5%92%8Culog_hex%28%29" rel="nofollow">2.4、LOG_HEX()和ulog_hex()</a></p> 
<p id="2.5%E3%80%81%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#2.5%E3%80%81%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0" rel="nofollow">2.5、接口函数</a></p> 
<p id="2.5.1%E3%80%81ulog_raw()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.5.1%E3%80%81ulog_raw%28%29%E5%87%BD%E6%95%B0" rel="nofollow">2.5.1、ulog_raw()函数</a></p> 
<p id="2.5.2%E3%80%81ulog_hexdump()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.5.2%E3%80%81ulog_hexdump%28%29%E5%87%BD%E6%95%B0" rel="nofollow">2.5.2、ulog_hexdump()函数</a></p> 
<p id="2.5.3%E3%80%81ulog_output()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.5.3%E3%80%81ulog_output%28%29%E5%87%BD%E6%95%B0" rel="nofollow">2.5.3、ulog_output()函数</a></p> 
<p id="2.6%E3%80%81%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#2.6%E3%80%81%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0" rel="nofollow">2.6、内部函数</a></p> 
<p id="2.6.1%E3%80%81output_lock()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.6.1%E3%80%81output_lock%28%29%E5%87%BD%E6%95%B0" rel="nofollow">2.6.1、output_lock()函数</a></p> 
<p id="2.6.2%E3%80%81output_unlock()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.6.2%E3%80%81output_unlock%28%29%E5%87%BD%E6%95%B0" rel="nofollow">2.6.2、output_unlock()函数</a></p> 
<p id="2.6.3%E3%80%81get_log_buf()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.6.3%E3%80%81get_log_buf%28%29%E5%87%BD%E6%95%B0" rel="nofollow">2.6.3、get_log_buf()函数</a></p> 
<p id="2.6.4%E3%80%81do_output()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.6.4%E3%80%81do_output%28%29%E5%87%BD%E6%95%B0" rel="nofollow">2.6.4、do_output()函数</a></p> 
<p id="2.6.5%E3%80%81ulog_output_to_all_backend()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.6.5%E3%80%81ulog_output_to_all_backend%28%29%E5%87%BD%E6%95%B0" rel="nofollow">2.6.5、ulog_output_to_all_backend()函数</a></p> 
<p id="2.6.6%E3%80%81ulog_voutput()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.6.6%E3%80%81ulog_voutput%28%29%E5%87%BD%E6%95%B0" rel="nofollow">2.6.6、ulog_voutput()函数</a></p> 
<p id="2.6.7%E3%80%81ulog_flush()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.6.7%E3%80%81ulog_flush%28%29%E5%87%BD%E6%95%B0" rel="nofollow">2.6.7、ulog_flush()函数</a></p> 
<p id="3%E3%80%81%E8%AE%BE%E7%BD%AE%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E8%AE%BE%E7%BD%AE%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F" rel="nofollow">3、设置日志格式</a></p> 
<p id="3.1%E3%80%81%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#3.1%E3%80%81%E5%87%BD%E6%95%B0" rel="nofollow">3.1、函数</a></p> 
<p id="3.1.1%E3%80%81ulog_head_formater()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.1.1%E3%80%81ulog_head_formater%28%29%E5%87%BD%E6%95%B0" rel="nofollow">3.1.1、ulog_head_formater()函数</a></p> 
<p id="3.1.2%E3%80%81ulog_tail_formater()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.1.2%E3%80%81ulog_tail_formater%28%29%E5%87%BD%E6%95%B0" rel="nofollow">3.1.2、ulog_tail_formater()函数</a></p> 
<p id="3.1.3%E3%80%81ulog_hex_formater()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.1.3%E3%80%81ulog_hex_formater%28%29%E5%87%BD%E6%95%B0" rel="nofollow">3.1.3、ulog_hex_formater()函数</a></p> 
<p id="3.1.4%E3%80%81ulog_formater()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.1.4%E3%80%81ulog_formater%28%29%E5%87%BD%E6%95%B0" rel="nofollow">3.1.4、ulog_formater()函数</a></p> 
<p id="4%E3%80%81%E5%8A%A8%E6%80%81%E8%BF%87%E6%BB%A4%E5%99%A8-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E5%8A%A8%E6%80%81%E8%BF%87%E6%BB%A4%E5%99%A8" rel="nofollow">4、动态过滤器</a></p> 
<p id="4.1%E3%80%81%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.1%E3%80%81%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0" rel="nofollow">4.1、接口函数</a></p> 
<p id="4.1.1%E3%80%81ulog_tag_lvl_list_get()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.1.1%E3%80%81ulog_tag_lvl_list_get%28%29%E5%87%BD%E6%95%B0" rel="nofollow">4.1.1、ulog_tag_lvl_list_get()函数</a></p> 
<p id="4.1.2%E3%80%81ulog_global_filter_lvl_set()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.1.2%E3%80%81ulog_global_filter_lvl_set%28%29%E5%87%BD%E6%95%B0" rel="nofollow">4.1.2、ulog_global_filter_lvl_set()函数</a></p> 
<p id="4.1.3%E3%80%81ulog_global_filter_lvl_get()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.1.3%E3%80%81ulog_global_filter_lvl_get%28%29%E5%87%BD%E6%95%B0" rel="nofollow">4.1.3、ulog_global_filter_lvl_get()函数</a></p> 
<p id="4.1.4%E3%80%81ulog_global_filter_tag_set()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.1.4%E3%80%81ulog_global_filter_tag_set%28%29%E5%87%BD%E6%95%B0" rel="nofollow">4.1.4、ulog_global_filter_tag_set()函数</a></p> 
<p id="4.1.5%E3%80%81ulog_global_filter_tag_get()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.1.5%E3%80%81ulog_global_filter_tag_get%28%29%E5%87%BD%E6%95%B0" rel="nofollow">4.1.5、ulog_global_filter_tag_get()函数</a></p> 
<p id="4.1.6%E3%80%81ulog_global_filter_kw_set()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.1.6%E3%80%81ulog_global_filter_kw_set%28%29%E5%87%BD%E6%95%B0" rel="nofollow">4.1.6、ulog_global_filter_kw_set()函数</a></p> 
<p id="4.1.7%E3%80%81ulog_global_filter_kw_get()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.1.7%E3%80%81ulog_global_filter_kw_get%28%29%E5%87%BD%E6%95%B0" rel="nofollow">4.1.7、ulog_global_filter_kw_get()函数</a></p> 
<p id="4.1.8%E3%80%81ulog_tag_lvl_filter_set()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.1.8%E3%80%81ulog_tag_lvl_filter_set%28%29%E5%87%BD%E6%95%B0" rel="nofollow">4.1.8、ulog_tag_lvl_filter_set()函数</a></p> 
<p id="%C2%A04.1.9%E3%80%81ulog_tag_lvl_filter_get()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A04.1.9%E3%80%81ulog_tag_lvl_filter_get%28%29%E5%87%BD%E6%95%B0" rel="nofollow"> 4.1.9、ulog_tag_lvl_filter_get()函数</a></p> 
<p id="5%E3%80%81%E5%BC%82%E6%AD%A5%E8%BE%93%E5%87%BA-toc" style="margin-left:0px;"><a href="#5%E3%80%81%E5%BC%82%E6%AD%A5%E8%BE%93%E5%87%BA" rel="nofollow">5、异步输出</a></p> 
<p id="5.1%E3%80%81%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:40px;"><a href="#5.1%E3%80%81%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">5.1、异步模式的优缺点</a></p> 
<p id="5.1.1%E3%80%81%E4%BC%98%E7%82%B9-toc" style="margin-left:80px;"><a href="#5.1.1%E3%80%81%E4%BC%98%E7%82%B9" rel="nofollow">5.1.1、优点</a></p> 
<p id="5.1.2%E3%80%81%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px;"><a href="#5.1.2%E3%80%81%E7%BC%BA%E7%82%B9" rel="nofollow">5.1.2、缺点</a></p> 
<p id="5.2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:40px;"><a href="#5.2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">5.2、结构体</a></p> 
<p id="5.2.1%E3%80%81rt_ulog%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:80px;"><a href="#5.2.1%E3%80%81rt_ulog%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">5.2.1、rt_ulog结构体</a></p> 
<p id="5.2.2%E3%80%81ulog_frame%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:80px;"><a href="#5.2.2%E3%80%81ulog_frame%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">5.2.2、ulog_frame结构体</a></p> 
<p id="5.3%E3%80%81%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#5.3%E3%80%81%E5%87%BD%E6%95%B0" rel="nofollow">5.3、函数</a></p> 
<p id="5.3.1%E3%80%81ulog_async_output_enabled()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#5.3.1%E3%80%81ulog_async_output_enabled%28%29%E5%87%BD%E6%95%B0" rel="nofollow">5.3.1、ulog_async_output_enabled()函数</a></p> 
<p id="5.3.2%E3%80%81ulog_async_output()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#5.3.2%E3%80%81ulog_async_output%28%29%E5%87%BD%E6%95%B0" rel="nofollow">5.3.2、ulog_async_output()函数</a></p> 
<p id="5.3.3%E3%80%81ulog_async_waiting_log()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#5.3.3%E3%80%81ulog_async_waiting_log%28%29%E5%87%BD%E6%95%B0" rel="nofollow">5.3.3、ulog_async_waiting_log()函数</a></p> 
<p id="5.3.4%E3%80%81async_output_thread_entry()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#5.3.4%E3%80%81async_output_thread_entry%28%29%E5%87%BD%E6%95%B0" rel="nofollow">5.3.4、async_output_thread_entry()函数</a></p> 
<p id="5.3.5%E3%80%81ulog_async_init()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#5.3.5%E3%80%81ulog_async_init%28%29%E5%87%BD%E6%95%B0" rel="nofollow">5.3.5、ulog_async_init()函数</a></p> 
<p id="6%E3%80%81%E4%B8%AD%E6%96%AD%E8%BE%93%E5%87%BA-toc" style="margin-left:0px;"><a href="#6%E3%80%81%E4%B8%AD%E6%96%AD%E8%BE%93%E5%87%BA" rel="nofollow">6、中断输出</a></p> 
<p id="7%E3%80%81%E5%90%8E%E7%AB%AF-toc" style="margin-left:0px;"><a href="#7%E3%80%81%E5%90%8E%E7%AB%AF" rel="nofollow">7、后端</a></p> 
<p id="7.1%E3%80%81ulog_backend%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:40px;"><a href="#7.1%E3%80%81ulog_backend%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">7.1、ulog_backend结构体</a></p> 
<p id="7.2%E3%80%81%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#7.2%E3%80%81%E6%8E%A5%E5%8F%A3" rel="nofollow">7.2、接口</a></p> 
<p id="7.2.1%E3%80%81ulog_backend_register()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#7.2.1%E3%80%81ulog_backend_register%28%29%E5%87%BD%E6%95%B0" rel="nofollow">7.2.1、ulog_backend_register()函数</a></p> 
<p id="7.2.2%E3%80%81ulog_backend_unregister()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#7.2.2%E3%80%81ulog_backend_unregister%28%29%E5%87%BD%E6%95%B0" rel="nofollow">7.2.2、ulog_backend_unregister()函数</a></p> 
<p id="7.2.3%E3%80%81ulog_backend_set_filter()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#7.2.3%E3%80%81ulog_backend_set_filter%28%29%E5%87%BD%E6%95%B0" rel="nofollow">7.2.3、ulog_backend_set_filter()函数</a></p> 
<p id="7.2.4%E3%80%81ulog_backend_find()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#7.2.4%E3%80%81ulog_backend_find%28%29%E5%87%BD%E6%95%B0" rel="nofollow">7.2.4、ulog_backend_find()函数</a></p> 
<p id="7.2.5%E3%80%81ulog_be_lvl_filter_set()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#7.2.5%E3%80%81ulog_be_lvl_filter_set%28%29%E5%87%BD%E6%95%B0" rel="nofollow">7.2.5、ulog_be_lvl_filter_set()函数</a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%E3%80%81ulog%20%E7%AE%80%E4%BB%8B">1、ulog 简介</h2> 
<p><span style="color:#ff9900;"><strong>ulog是一个小巧、实用的日志组件(日志系统)，为软件调试、维护过程中的问题追溯、性能分析、系统监控、故障预警等功能，提供参考依据。</strong></span></p> 
<h3 id="1.1%E3%80%81%E7%89%B9%E6%80%A7"><strong>1.1、特性</strong></h3> 
<p><span style="color:#0d0016;"><strong>ulog 是一个非常简洁、易用的 C/C++ 日志组件，第一个字母 u 代表 μ，即微型的意思。它能做到最低</strong></span><span style="color:#fe2c24;"><strong>ROM&lt;1K, RAM&lt;0.2K</strong></span><span style="color:#0d0016;"><strong>的资源占用。ulog 不仅有小巧体积，同样也有非常全面的功能，其设计理念参考的是另外一款 C/C++ 开源日志库：EasyLogger（简称 elog），并在功能和性能等方面做了非常多的改进。主要特性如下：</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>1）日志输出的后端多样化，可支持例如：串口、网络，文件、闪存等后端形式。 </strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）日志输出被设计为线程安全的方式，并支持异步输出模式。 </strong></span></p> 
<p><span style="color:#4da8ee;"><strong>3）日志系统高可靠，在中断 ISR 、Hardfault等复杂环境下依旧可用。 </strong></span></p> 
<p><span style="color:#4da8ee;"><strong>4）日志支持运行期 / 编译期设置输出级别。 </strong></span></p> 
<p><span style="color:#4da8ee;"><strong>5）日志内容支持按关键词及标签方式进行全局过滤。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>6）API 和日志格式可兼容 linux syslog。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>7）支持以 hex 格式 dump 调试数据到日志中。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>8）兼容 rtdbg （RTT 早期的日志头文件）及 EasyLogger 的日志输出 API。</strong></span></p> 
<h3 id="1.2%E3%80%81%E6%9E%B6%E6%9E%84">1.2、架构</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4b/5d/mP41yQtg_o.png"></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td style="width:59px;"><span style="color:#0d0016;"><strong>分层</strong></span></td><td style="width:589px;"><span style="color:#0d0016;"><strong>说明</strong></span></td></tr><tr><td style="width:59px;"><span style="color:#4da8ee;"><strong>前端</strong></span></td><td style="width:589px;"><span style="color:#4da8ee;"><strong>该层作为离应用最近的一层，给用户提供了 syslog 及 LOG_X 两类 API 接口，方便用户在不同的场景中使用。</strong></span></td></tr><tr><td style="width:59px;"><span style="color:#4da8ee;"><strong>核心</strong></span></td><td style="width:589px;"><span style="color:#4da8ee;"><strong>中间核心层的主要工作是将上层传递过来的日志，按照不同的配置要求进行格式化与过滤然后生成日志帧，最终通过不同的输出模块，输出到最底层的后端设备上。</strong></span></td></tr><tr><td style="width:59px;"><span style="color:#4da8ee;"><strong>后端</strong></span></td><td style="width:589px;"><span style="color:#4da8ee;"><strong>接收到核心层发来的日志帧后，将日志输出到已经注册的日志后端设备上，例如：文件、控制台、日志服务器等等</strong></span></td></tr></tbody></table> 
<h3 id="1.3%E3%80%81%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9">1.3、配置选项</h3> 
<h4 id="1.3.1%E3%80%81%E9%85%8D%E7%BD%AE%E9%A1%B9">1.3.1、配置项</h4> 
<p><img alt="" height="525" src="https://images2.imgbox.com/ee/b0/DkQM9VVK_o.png" width="1123"></p> 
<p><img alt="" height="406" src="https://images2.imgbox.com/5d/88/VxLJeGmA_o.png" width="1095"></p> 
<h4 id="%C2%A01.3.2%E3%80%81%E5%AE%8F"> 1.3.2、宏</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td><strong>RT_USING_ULOG</strong></td><td><strong>使能ulog组件</strong></td></tr><tr><td><strong>ULOG_USING_SYSLOG</strong></td><td><strong>使能syslog</strong></td></tr><tr><td><strong>ULOG_FILTER_TAG_MAX_LEN</strong></td><td><strong>日志tag最大长度</strong></td></tr><tr><td><strong>ULOG_FILTER_KW_MAX_LEN</strong></td><td><strong>日志关键词最大长度</strong></td></tr><tr><td><strong>ULOG_USING_FILTER</strong></td><td><strong>使能过滤器</strong></td></tr><tr><td><strong>ULOG_OUTPUT_LVL</strong></td><td> <p><strong>静态日志输出级别</strong></p> <p><strong><span style="color:#fe2c24;">注：选择完成后，比设定级别低的日志将不会被编译到 ROM 中</span></strong></p> </td></tr><tr><td><span style="color:#0d0016;"><strong>LOG_LVL</strong></span></td><td> <p><strong>模块静态日志输出级别</strong></p> <p><span style="color:#fe2c24;"><strong>注：需在文件.c文件的<code>#include &lt;ulog.h&gt;</code> 的上方定义</strong></span></p> </td></tr><tr><td><strong>LOG_TAG</strong></td><td> <p><strong>模块标签</strong></p> <p><span style="color:#fe2c24;"><strong>注：需在文件.c文件的<code>#include &lt;ulog.h&gt;</code> 的上方定义</strong></span></p> </td></tr><tr><td><strong>ULOG_USING_ISR_LOG</strong></td><td> <p><strong>使能中断 ISR 日志，即在 ISR 中也可以使用日志输出 API</strong></p> </td></tr><tr><td><strong>ULOG_ASSERT_ENABLE</strong></td><td> <p><strong>使能断言检查。</strong></p> <p><strong><span style="color:#fe2c24;">注：关闭使能后，断言的日志将不会被编译到 ROM 中</span></strong></p> </td></tr><tr><td><strong>ULOG_LINE_BUF_SIZE</strong></td><td> <p><strong>日志的最大长度。</strong></p> <p><strong><span style="color:#fe2c24;">注：由于 ulog 的日志 API 按行作为单位，所以这个长度也代表一行日志的最大长度</span> </strong></p> </td></tr><tr><td colspan="2" style="text-align:center;"><strong><span style="color:#ff9900;">异步日志</span></strong></td></tr><tr><td><strong>ULOG_USING_ASYNC_OUTPUT</strong></td><td> <p><strong>使能异步日志输出模式。</strong></p> <p><span style="color:#fe2c24;"><strong>注：开启这个模式后，日志不会立刻输出到后端，而是先缓存起来，然后交给日志输出线程（例如：idle 线程）去输出</strong></span></p> </td></tr><tr><td><strong>ULOG_ASYNC_OUTPUT_BUF_SIZE</strong></td><td><strong>异步日志的最大长度。</strong></td></tr><tr><td><strong><span style="background-color:#fe2c24;">ULOG_ASYNC_OUTPUT_STORE_LINES</span></strong></td><td> <p><strong>异步日志可储存的消息条数。</strong></p> <p><span style="color:#fe2c24;"><strong>注：默认为ULOG_ASYNC_OUTPUT_BUF_SIZE * 3 / 2 / 80</strong></span></p> </td></tr><tr><td><strong>ULOG_ASYNC_OUTPUT_BY_THREAD</strong></td><td> <p><strong>异步日志通过异步线程</strong><strong>输出。</strong></p> <p><span style="color:#fe2c24;"><strong>注：也可以不使用异步线程，如通过idle线程进行输出。</strong></span></p> </td></tr><tr><td><strong>ULOG_ASYNC_OUTPUT_THREAD_STACK</strong></td><td><strong>异步输出线程栈大小</strong></td></tr><tr><td><strong>ULOG_ASYNC_OUTPUT_THREAD_PRIORITY</strong></td><td><strong>异步输出线程优先级</strong></td></tr><tr><td colspan="2" style="text-align:center;"><strong><span style="color:#ff9900;">后端</span></strong></td></tr><tr><td><strong>ULOG_BACKEND_USING_CONSOLE</strong></td><td> <p><strong>使能控制台作为后端。</strong></p> <p><span style="color:#fe2c24;"><strong>注：使能后，在非线程上下文环境中，日志可以输出到控制台串口上。</strong></span></p> </td></tr><tr><td><strong>ULOG_BACKEND_USING_FILE</strong></td><td><strong>使能文件作为后端。</strong></td></tr><tr><td colspan="2" style="text-align:center;"><strong><span style="color:#ff9900;">日志格式</span></strong></td></tr><tr><td><strong>ULOG_USING_COLOR                         </strong></td><td><strong>使能颜色格式</strong></td></tr><tr><td><strong>ULOG_OUTPUT_TIME</strong></td><td> <p><strong>使能时间格式</strong></p> <p><span style="color:#fe2c24;"><strong>注：默认为系统tick，定义宏ULOG_TIME_USING_TIMESTAMP后则为时间戳</strong></span></p> </td></tr><tr><td><strong>ULOG_TIME_USING_TIMESTAMP</strong></td><td><strong>使能时间戳</strong></td></tr><tr><td><strong>ULOG_OUTPUT_LEVEL</strong></td><td><strong>使能输出级别格式</strong></td></tr><tr><td><strong>ULOG_OUTPUT_THREAD_NAME</strong></td><td><strong>使能输出线程名称格式</strong></td></tr></tbody></table> 
<h3 id="1.4%E3%80%81%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB">1.4、日志级别</h3> 
<h4 id="1.4.1%E3%80%81%E4%B8%8D%E4%BD%BF%E7%94%A8ULOG_USING_SYSLOG">1.4.1、不使用ULOG_USING_SYSLOG</h4> 
<table><thead><tr><th><strong>级别</strong></th><th style="width:54px;"><strong>名称</strong></th><th style="width:481px;"><strong>描述</strong></th></tr></thead><tbody><tr><td><span style="color:#4da8ee;"><strong>LOG_LVL_ASSERT</strong></span></td><td style="width:54px;"><span style="color:#4da8ee;"><strong>断言</strong></span></td><td style="width:481px;"><span style="color:#4da8ee;"><strong>发生无法处理、致命性的的错误，以至于系统无法继续运行的断言日志</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>LOG_LVL_ERROR</strong></span></td><td style="width:54px;"><span style="color:#4da8ee;"><strong>错误</strong></span></td><td style="width:481px;"><span style="color:#4da8ee;"><strong>发生严重的、不可修复的错误时输出的日志属于错误级别日志</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>LOG_LVL_WARNING</strong></span></td><td style="width:54px;"><span style="color:#4da8ee;"><strong>警告</strong></span></td><td style="width:481px;"><span style="color:#4da8ee;"><strong>出现一些不太重要的、具有可修复性的错误时，会输出这些警告日志</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>LOG_LVL_INFO</strong></span></td><td style="width:54px;"><span style="color:#4da8ee;"><strong>信息</strong></span></td><td style="width:481px;"><span style="color:#4da8ee;"><strong>给本模块上层使用人员查看的重要提示信息日志，例如：初始化成功，当前工作状态等。该级别日志一般在量产时依旧保留</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>LOG_LVL_DBG</strong></span></td><td style="width:54px;"><span style="color:#4da8ee;"><strong>调试</strong></span></td><td style="width:481px;"><span style="color:#4da8ee;"><strong>给本模块开发人员查看的调试日志，该级别日志一般在量产时关闭</strong></span></td></tr></tbody></table> 
<h4 id="1.4.2%E3%80%81%E4%BD%BF%E7%94%A8ULOG_USING_SYSLOG">1.4.2、使用ULOG_USING_SYSLOG</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:270px;"><tbody><tr><td style="width:133px;"><span style="color:#0d0016;"><strong>级别</strong></span></td><td style="width:135px;"><span style="color:#0d0016;"><strong>名称</strong></span></td></tr><tr><td style="width:133px;"><span style="color:#4da8ee;"><strong>EMERG</strong></span></td><td style="width:135px;"><span style="color:#4da8ee;"><strong>紧急</strong></span></td></tr><tr><td style="width:133px;"><span style="color:#4da8ee;"><strong>ALERT</strong></span></td><td style="width:135px;"><span style="color:#4da8ee;"><strong>警报</strong></span></td></tr><tr><td style="width:133px;"><span style="color:#4da8ee;"><strong>CRIT</strong></span></td><td style="width:135px;"><span style="color:#4da8ee;"><strong>重要</strong></span></td></tr><tr><td style="width:133px;"><span style="color:#4da8ee;"><strong>ERR</strong></span></td><td style="width:135px;"><span style="color:#4da8ee;"><strong>错误</strong></span></td></tr><tr><td style="width:133px;"><span style="color:#4da8ee;"><strong>WARNING</strong></span></td><td style="width:135px;"><span style="color:#4da8ee;"><strong>警告</strong></span></td></tr><tr><td style="width:133px;"><span style="color:#4da8ee;"><strong>NOTICE</strong></span></td><td style="width:135px;"><span style="color:#4da8ee;"><strong>通知</strong></span></td></tr><tr><td style="width:133px;"><span style="color:#4da8ee;"><strong>INFO</strong></span></td><td style="width:135px;"><span style="color:#4da8ee;"><strong>信息</strong></span></td></tr><tr><td style="width:133px;"><span style="color:#4da8ee;"><strong>DEBUG</strong></span></td><td style="width:135px;"><span style="color:#4da8ee;"><strong>调试</strong></span></td></tr></tbody></table> 
<h4 id="1.4.3%E3%80%81%E9%9D%99%E6%80%81%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BA%A7%E5%88%AB">1.4.3、静态级别与动态级别</h4> 
<p><span style="color:#ff9900;"><strong>按照日志是否可以在运行阶段修改进行分类。</strong></span><span style="color:#0d0016;"><strong>可在运行阶段修改的称之为动态级别，只能在编译阶段修改的称之为静态级别。</strong></span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td style="width:95px;"><span style="color:#4da8ee;"><strong>静态级别</strong></span></td><td style="width:553px;"><span style="color:#4da8ee;"><strong>比静态级别低的日志将不会被编译到 ROM 中，最终也不会输出、显示出来。</strong></span></td></tr><tr><td style="width:95px;"><span style="color:#4da8ee;"><strong>动态级别</strong></span></td><td style="width:553px;"><span style="color:#4da8ee;"><strong>动态级别可以管控的是高于或等于静态级别的日志。在 ulog 运行时，比动态级别低的日志会被过滤掉。</strong></span></td></tr></tbody></table> 
<h4 id="1.4.4%E3%80%81%E5%85%A8%E5%B1%80%E7%BA%A7%E5%88%AB%E4%B8%8E%E6%A8%A1%E5%9D%97%E7%BA%A7%E5%88%AB">1.4.4、全局级别与模块级别</h4> 
<p><span style="color:#ff9900;"><strong>按照作用域进行的分类。</strong></span><span style="color:#0d0016;"><strong>在 ulog 中每个文件（模块）也可以设定独立的日志级别。全局级别作用域大于模块级别(模块级别只能管控那些高于或等于全局级别的模块日志)。</strong></span></p> 
<h4 id="1.4.5%E3%80%81%E8%AE%BE%E5%AE%9A%E6%97%A5%E5%BF%97%E7%9A%84%E8%BE%93%E5%87%BA%E7%BA%A7%E5%88%AB">1.4.5、设定日志的输出级别</h4> 
<p><span style="color:#4da8ee;"><strong>1）全局静态日志级别：ULOG_OUTPUT_LVL宏。 </strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）全局动态日志级别：使用 void ulog_global_filter_lvl_set(rt_uint32_t level) 函数来设定。 </strong></span></p> 
<p><span style="color:#4da8ee;"><strong>3）模块静态日志级别：在模块（文件）内定义 LOG_LVL 宏，与日志标签宏 LOG_TAG 定义方式类似。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>4）模块动态日志级别：使用 int ulog_tag_lvl_filter_set(const char *tag, rt_uint32_t level) 函数来设定。</strong></span></p> 
<p><strong><span style="color:#fe2c24;">注：作用范围关系为，全局静态&gt;全局动态&gt;模块静态&gt;模块动态。</span></strong></p> 
<h3 id="1.5%E3%80%81%E6%97%A5%E5%BF%97%E6%A0%87%E7%AD%BE">1.5、日志标签</h3> 
<p><span style="color:#ff9900;"><strong>使用tag标签可以给每条日志进行分类。</strong></span><span style="color:#0d0016;"><strong>标签的定义是按照</strong></span><span style="color:#4da8ee;"><strong>模块化</strong></span><span style="color:#0d0016;"><strong>的方式，例如：Wi-Fi 组件包括设备驱动（wifi_driver）、设备管理（wifi_mgnt）等模块，则 Wi-Fi 组件内部模块可以使用 <code>wifi.driver</code>、<code>wifi.mgnt</code> 等作为标签，进行日志的分类输出。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>注：日志标签的作用域是当前源码文件，项目源代码通常也会按照模块进行文件分类。所以在定义标签时，可以指定模块名、子模块名作为标签名称，这样不仅在日志输出显示时清晰直观，也能方便后续按标签方式动态调整级别或过滤。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>每条日志的标签属性也可以被输出并显示出来，同时 ulog 还可以设置每个标签对应日志的输出级别。</strong></span><span style="color:#956fe7;"><strong>当前不重要模块的日志可以选择性关闭，不仅降低 ROM 资源，还能帮助开发者过滤无关日志。</strong></span></p> 
<pre><code class="language-cpp">#define LOG_TAG     "example"     // 该模块对应的标签。不定义时，默认：NO_TAG
#define LOG_LVL     LOG_LVL_DBG   // 该模块对应的日志输出级别。不定义时，默认：调试级别
#include &lt;ulog.h&gt;                 // 必须在 LOG_TAG 与 LOG_LVL 下面</code></pre> 
<p><span style="color:#fe2c24;"><strong>注：定义日志标签必须位于 <code>#include &lt;ulog.h&gt;</code> 的上方，否则会使用默认的 <code>NO_TAG</code>（不推荐在头文件中定义这些宏）。</strong></span></p> 
<h2 id="2%E3%80%81%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA">2、日志输出</h2> 
<p><span style="color:#ff9900;"><strong>ulog主要有两种日志输出宏 API，源代码中定义如下所示：</strong></span></p> 
<pre><code class="language-cpp">#define LOG_E(...)                           ulog_e(LOG_TAG, __VA_ARGS__)
#define LOG_W(...)                           ulog_w(LOG_TAG, __VA_ARGS__)
#define LOG_I(...)                           ulog_i(LOG_TAG, __VA_ARGS__)
#define LOG_D(...)                           ulog_d(LOG_TAG, __VA_ARGS__)
#define LOG_RAW(...)                         ulog_raw(__VA_ARGS__)
#define LOG_HEX(name, width, buf, size)      ulog_hex(name, width, buf, size)</code></pre> 
<p></p> 
<h3 id="2.1%E3%80%81%E5%AE%8F%C2%A0LOG_X(...)">2.1、宏 LOG_X(...)</h3> 
<p><span style="color:#ff9900;"><strong>宏 LOG_X(...)的X对应的是不同级别的第一个字母大写。参数 ... 为日志内容，格式与 printf 一致。</strong></span><span style="color:#4da8ee;"><strong>这种方式是首选，一方面因为其 API 格式简单，入参只有一个即日志信息。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>注：这个</strong></span><strong><span style="color:#fe2c24;">API适用于在一个文件中使用相同tag 输出</span></strong><span style="color:#fe2c24;"><strong>。</strong></span></p> 
<h3 id="2.2%E3%80%81ulog_x(LOG_TAG%2C%C2%A0__VA_ARGS__)"><strong>2.2、</strong>ulog_x(LOG_TAG, __VA_ARGS__)</h3> 
<p><strong><span style="color:#ff9900;">ulog_x(LOG_TAG, __VA_ARGS__)宏的x 对应的是不同级别的简写。参数 LOG_TAG 为日志标签，参数 ... 为日志内容，格式与 printf 一致。</span></strong></p> 
<p><strong><span style="color:#fe2c24;">注：这个 API 适用于在一个文件中使用不同 tag 输出日志的情况。</span></strong></p> 
<h3 id="2.3%E3%80%81LOG_RAW()%E5%92%8Culog_raw()"><strong>2.3、</strong>LOG_RAW()和ulog_raw()</h3> 
<p><span style="color:#ff9900;"><strong>LOG_X 及 ulog_x 这类 API 输出都是带格式日志；有些时候需要输出不带任何格式的日志时，可以使用 LOG_RAW 或 ulog_raw() 。</strong></span></p> 
<h3 id="2.4%E3%80%81LOG_HEX()%E5%92%8Culog_hex()"><strong>2.4、LOG_HEX()和ulog_hex</strong>()</h3> 
<p><span style="color:#ff9900;"><strong>以 16 进制 hex 格式 dump 数据到日志中可使用可以使用 LOG_HEX() 或 ulog_hex() 。</strong></span></p> 
<h3 id="2.5%E3%80%81%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0">2.5、接口函数</h3> 
<h4 id="2.5.1%E3%80%81ulog_raw()%E5%87%BD%E6%95%B0">2.5.1、ulog_raw()函数</h4> 
<p><span style="color:#ff9900;"><strong>该接口调用get_log_buf()</strong></span><span style="color:#ff9900;"><strong>获取日志缓冲区并调用do_output()函数输出日志(级别LOG_LVL_DBG，标签为"")。</strong></span></p> 
<pre><code class="language-cpp">void ulog_raw(const char *format, ...)</code></pre> 
<h4 id="2.5.2%E3%80%81ulog_hexdump()%E5%87%BD%E6%95%B0">2.5.2、ulog_hexdump()函数</h4> 
<p><span style="color:#ff9900;"><strong>将十六进制格式数据转储到日志中。</strong></span></p> 
<p></p> 
<pre><code class="language-cpp">void ulog_hexdump(const char *tag, rt_size_t width, const rt_uint8_t *buf, rt_size_t size, ...)</code></pre> 
<h4 id="2.5.3%E3%80%81ulog_output()%E5%87%BD%E6%95%B0">2.5.3、ulog_output()函数</h4> 
<pre><code class="language-cpp">void ulog_output(rt_uint32_t level, const char *tag, rt_bool_t newline, const char *format, ...)</code></pre> 
<h3 id="2.6%E3%80%81%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0">2.6、内部函数</h3> 
<h4 id="2.6.1%E3%80%81output_lock()%E5%87%BD%E6%95%B0">2.6.1、output_lock()函数</h4> 
<p><span style="color:#4da8ee;"><strong>1）如果调度程序已启动并且位于线程上下文中，获取互斥量ulog.output_locker</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）否则，若定义ULOG_USING_ISR_LOG则直接调用rt_hw_interrupt_disable()关中断</strong></span></p> 
<pre><code class="language-cpp">static void output_lock(void)</code></pre> 
<h4 id="2.6.2%E3%80%81output_unlock()%E5%87%BD%E6%95%B0">2.6.2、output_unlock()函数</h4> 
<p><span style="color:#4da8ee;"><strong>1）如果调度程序已启动并且位于线程上下文中，释放互斥量ulog.output_locker</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）否则，若定义ULOG_USING_ISR_LOG则直接调用rt_hw_interrupt_enable()开中断</strong></span></p> 
<pre><code class="language-cpp">static void output_unlock(void)</code></pre> 
<h4 id="2.6.3%E3%80%81get_log_buf()%E5%87%BD%E6%95%B0">2.6.3、get_log_buf()函数</h4> 
<p><span style="color:#4da8ee;"><strong>1）在线程上下文中，则返回ulog.log_buf_th</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）在中断中，且定义ULOG_USING_ISR_LOG，则返回ulog.log_buf_isr。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>3）在中断中，且未定义ULOG_USING_ISR_LOG，则返回RT_NULL。</strong></span></p> 
<pre><code class="language-cpp">static char *get_log_buf(void)</code></pre> 
<h4 id="2.6.4%E3%80%81do_output()%E5%87%BD%E6%95%B0">2.6.4、do_output()函数</h4> 
<p><span style="color:#4da8ee;"><strong>1）如果定义ULOG_USING_ASYNC_OUTPUT，分配ulog_frame_t结构体，将其放入ulog.async_rbb</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）如果未定义ULOG_USING_ASYNC_OUTPUT，在线程上下文环境，调用ulog_output_to_all_backend()函数输出日志</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>3）如果未定义ULOG_USING_ASYNC_OUTPUT，在中断环境，如果定义ULOG_BACKEND_USING_CONSOLE，则调用ulog_console_backend_output()，因为不能确保所有后端都支持ISR上下文输出。</strong></span></p> 
<pre><code class="language-cpp">static void do_output(rt_uint32_t level, const char *tag, rt_bool_t is_raw, const char *log_buf, rt_size_t log_len)</code></pre> 
<h4 id="2.6.5%E3%80%81ulog_output_to_all_backend()%E5%87%BD%E6%95%B0">2.6.5、ulog_output_to_all_backend()函数</h4> 
<p><span style="color:#ff9900;"><strong>向所有后端输出日志。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>1）如果没有注册后端，则直接调用rt_kputs()输出日志</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）遍历所有后端，查找符合条件的后端(level小于等于backend的out_level)</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>3）向后端输出日志</strong></span></p> 
<p>        <span style="color:#956fe7;"><strong>a、如果未定义ULOG_USING_COLOR或定义了ULOG_USING_SYSLOG，则直接调用backend的output()输出日志</strong></span></p> 
<p>   <span style="color:#956fe7;"><strong>     b、backend的filter成员存在，且调用filter()返回RT_TRUE时，如果backend的support_color为RT_TRUE或 is_raw，则直接调用backend的output()输出日志</strong></span></p> 
<p> <span style="color:#956fe7;"><strong>       c、backend的filter成员存在，且调用filter()返回RT_TRUE时，如果backend不使能颜色时，如果log中存在颜色信息</strong>，<strong>重新计算日志起始地址和日志大小(去除log中相应的颜色信息),再调用output()输出日志</strong></span></p> 
<pre><code class="language-cpp">static void ulog_output_to_all_backend(rt_uint32_t level, const char *tag, rt_bool_t is_raw, const char *log, rt_size_t len)</code></pre> 
<h4 id="2.6.6%E3%80%81ulog_voutput()%E5%87%BD%E6%95%B0">2.6.6、ulog_voutput()函数</h4> 
<p><span style="color:#4da8ee;"><strong>1）全局过滤，tag级别过滤。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）调用ulog_formater()函数或ulog_hex_formater()函数或syslog_formater()函数设置日志格式</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>3）如果定义关键词，且日志中匹配关键词，则不输出。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>4）调用do_output()函数输出日志</strong></span></p> 
<pre><code class="language-cpp">void ulog_voutput(rt_uint32_t level, const char *tag, rt_bool_t newline, const rt_uint8_t *hex_buf, rt_size_t hex_size,
        rt_size_t hex_width, rt_base_t hex_addr, const char *format, va_list args)</code></pre> 
<h4 id="2.6.7%E3%80%81ulog_flush()%E5%87%BD%E6%95%B0">2.6.7、ulog_flush()函数</h4> 
<p><span style="color:#ff9900;"><strong>清除所有后端日志。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>1）如果定义ULOG_USING_ASYNC_OUTPUT，则调用ulog_async_output()函数</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）遍历日志后端，调用backend的flush()函数</strong></span></p> 
<pre><code class="language-cpp">void ulog_flush(void)</code></pre> 
<h2 id="3%E3%80%81%E8%AE%BE%E7%BD%AE%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F">3、设置日志格式</h2> 
<p><span style="color:#ff9900;"><strong>ulog支持带颜色的日志、时间信息(包括时间戳)、级别信息、标签信息、线程信息。</strong></span></p> 
<p></p> 
<h3 id="3.1%E3%80%81%E5%87%BD%E6%95%B0">3.1、函数</h3> 
<h4 id="3.1.1%E3%80%81ulog_head_formater()%E5%87%BD%E6%95%B0">3.1.1、ulog_head_formater()函数</h4> 
<p><span style="color:#ff9900;"><strong>添加日志格式前缀，格式为:[颜色开始信息]+[时间信息]+[日志级别]+[标签信息]+[线程名称]+": "</strong></span></p> 
<pre><code class="language-cpp">rt_size_t ulog_head_formater(char *log_buf, rt_uint32_t level, const char *tag)</code></pre> 
<h4 id="3.1.2%E3%80%81ulog_tail_formater()%E5%87%BD%E6%95%B0">3.1.2、ulog_tail_formater()函数</h4> 
<p><span style="color:#ff9900;"><strong>溢出检查并添加日志格式后缀，格式为:[ULOG_NEWLINE_SIGN宏定义的换行符]+[颜色结束信息]+'\0'</strong></span></p> 
<pre><code class="language-cpp">rt_size_t ulog_tail_formater(char *log_buf, rt_size_t log_len, rt_bool_t newline, rt_uint32_t level)</code></pre> 
<h4 id="3.1.3%E3%80%81ulog_hex_formater()%E5%87%BD%E6%95%B0">3.1.3、ulog_hex_formater()函数</h4> 
<p><span style="color:#ff9900;"><strong>日志格式前缀+缓冲区地址信息+十六进制值+ascii值+日志格式后缀</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>注：不可打印的ascii值则会输出'.'</strong></span></p> 
<pre><code class="language-cpp">rt_size_t ulog_hex_formater(char *log_buf, const char *tag, const rt_uint8_t *buf, rt_size_t size, rt_size_t width, rt_base_t addr)</code></pre> 
<h4 id="3.1.4%E3%80%81ulog_formater()%E5%87%BD%E6%95%B0">3.1.4、ulog_formater()函数</h4> 
<p><span style="color:#ff9900;"><strong>添加日志格式，调用ulog_head_formater()函数添加日志格式前缀，调用ulog_tail_formater()函数添加日志格式后缀。</strong></span></p> 
<pre><code class="language-cpp">rt_size_t ulog_formater(char *log_buf, rt_uint32_t level, const char *tag, rt_bool_t newline,const char *format, va_list args)</code></pre> 
<h2 id="4%E3%80%81%E5%8A%A8%E6%80%81%E8%BF%87%E6%BB%A4%E5%99%A8">4、动态过滤器</h2> 
<pre><code class="language-cpp">struct ulog_tag_lvl_filter
{
    char tag[ULOG_FILTER_TAG_MAX_LEN + 1];
    rt_uint32_t level;
    rt_slist_t list;
};</code></pre> 
<pre><code class="language-cpp">struct rt_ulog
{
   ...
#ifdef ULOG_USING_FILTER
    struct
    {
        /* all tag's level filter */
        rt_slist_t tag_lvl_list;
        /* global filter level, tag and keyword */
        rt_uint32_t level;
        char tag[ULOG_FILTER_TAG_MAX_LEN + 1];
        char keyword[ULOG_FILTER_KW_MAX_LEN + 1];
    } filter;
#endif /* ULOG_USING_FILTER */
};</code></pre> 
<h3 id="4.1%E3%80%81%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0">4.1、接口函数</h3> 
<h4 id="4.1.1%E3%80%81ulog_tag_lvl_list_get()%E5%87%BD%E6%95%B0">4.1.1、ulog_tag_lvl_list_get()函数</h4> 
<p><span style="color:#ff9900;"><strong>该接口用于获取日志过滤器链表filter.tag_lvl_list。</strong></span></p> 
<pre><code class="language-cpp">rt_slist_t *ulog_tag_lvl_list_get(void)</code></pre> 
<h4 id="4.1.2%E3%80%81ulog_global_filter_lvl_set()%E5%87%BD%E6%95%B0">4.1.2、ulog_global_filter_lvl_set()函数</h4> 
<p><span style="color:#ff9900;"><strong>该接口用于设置日志全局过滤器级别filter.level。</strong></span></p> 
<pre><code class="language-cpp">void ulog_global_filter_lvl_set(rt_uint32_t level)</code></pre> 
<h4 id="4.1.3%E3%80%81ulog_global_filter_lvl_get()%E5%87%BD%E6%95%B0">4.1.3、ulog_global_filter_lvl_get()函数</h4> 
<p><span style="color:#ff9900;"><strong>该接口用于获取日志全局过滤器级别filter.level。</strong></span></p> 
<pre><code class="language-cpp">rt_uint32_t ulog_global_filter_lvl_get(void)</code></pre> 
<h4 id="4.1.4%E3%80%81ulog_global_filter_tag_set()%E5%87%BD%E6%95%B0">4.1.4、ulog_global_filter_tag_set()函数</h4> 
<p><span style="color:#ff9900;"><strong>该接口用于设置日志全局过滤器标签filter.tag。</strong></span></p> 
<pre><code class="language-cpp">void ulog_global_filter_tag_set(const char *tag)</code></pre> 
<h4 id="4.1.5%E3%80%81ulog_global_filter_tag_get()%E5%87%BD%E6%95%B0">4.1.5、ulog_global_filter_tag_get()函数</h4> 
<p><span style="color:#ff9900;"><strong>该接口用于获取日志全局过滤器标签filter.tag。</strong></span></p> 
<pre><code class="language-cpp">const char *ulog_global_filter_tag_get(void)</code></pre> 
<h4 id="4.1.6%E3%80%81ulog_global_filter_kw_set()%E5%87%BD%E6%95%B0">4.1.6、ulog_global_filter_kw_set()函数</h4> 
<p><span style="color:#ff9900;"><strong>该接口用于设置日志全局过滤器关键词filter.keyword。</strong></span></p> 
<pre><code class="language-cpp">void ulog_global_filter_kw_set(const char *keyword)</code></pre> 
<h4 id="4.1.7%E3%80%81ulog_global_filter_kw_get()%E5%87%BD%E6%95%B0">4.1.7、ulog_global_filter_kw_get()函数</h4> 
<p><span style="color:#ff9900;"><strong>该接口用于获取日志全局过滤器关键词filter.keyword。</strong></span></p> 
<pre><code class="language-cpp">const char *ulog_global_filter_kw_get(void)</code></pre> 
<h4 id="4.1.8%E3%80%81ulog_tag_lvl_filter_set()%E5%87%BD%E6%95%B0">4.1.8、ulog_tag_lvl_filter_set()函数</h4> 
<p><span style="color:#ff9900;"><strong>通过不同的标签设置过滤器的级别(标签上小于此级别的日志将不输出)。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>1）日志过滤器中未存在对应tag,且级别不是LOG_FILTER_LVL_ALL，则分配ulog_tag_lvl_filter结构体，并将其加入过滤器中。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）日志过滤器中存在对应tag,且级别不是LOG_FILTER_LVL_ALL，则更新标签级别。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>3）日志过滤器中存在对应tag,且级别为LOG_FILTER_LVL_ALL，则从过滤器移除对应标签，并释放内存。</strong></span></p> 
<pre><code class="language-cpp">int ulog_tag_lvl_filter_set(const char *tag, rt_uint32_t level)</code></pre> 
<h4 id="%C2%A04.1.9%E3%80%81ulog_tag_lvl_filter_get()%E5%87%BD%E6%95%B0"> 4.1.9、ulog_tag_lvl_filter_get()函数</h4> 
<p><span style="color:#ff9900;"><strong>当没有找到标签时，它将返回最低级别。当找到标签时，返回该标签的级别。</strong></span></p> 
<pre><code class="language-cpp">rt_uint32_t ulog_tag_lvl_filter_get(const char *tag)</code></pre> 
<h2 id="5%E3%80%81%E5%BC%82%E6%AD%A5%E8%BE%93%E5%87%BA">5、异步输出</h2> 
<p><span style="color:#ff9900;"><strong>在 ulog 中，默认的输出模式是同步模式，在很多场景下用户可能还需要异步模式。用户在调用日志输出 API 时，会将日志缓存到缓冲区中，会有专门负责日志输出的线程取出日志，然后输出到后端。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>异步模式和同步模式针对用户而言，在日志 API 使用上是没有差异的，因为 ulog 在底层处理上会有区分。两者的工作原理区别大致如下图所示：</strong></span></p> 
<p style="text-align:center;"><span style="color:#4da8ee;"><strong><img alt="" src="https://images2.imgbox.com/69/5c/Kz1zor3Y_o.png"></strong></span></p> 
<p><span style="color:#fe2c24;"><strong>注：开启异步模式后，在代码上离得非常近的日志的时间信息几乎是相同的(几乎不占用调用者的时间)。但在同步模式下，日志使用用户线程来输出，由于日志输出要花一定时间，所以每条日志的时间会有一定的间隔。</strong></span></p> 
<h3 id="5.1%E3%80%81%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">5.1、异步模式的优缺点</h3> 
<h4 id="5.1.1%E3%80%81%E4%BC%98%E7%82%B9">5.1.1、优点</h4> 
<p><span style="color:#4da8ee;"><strong>1）日志输出时不会阻塞住当前线程，有些后端输出速率低，使用同步输出模式可能影响当前线程的时序，异步模式不存在该问题。<br> 2）每个使用日志的线程省略了后端输出的动作，所以这些线程的堆栈开销可能也会减少，从这个角度也可以降低整个系统的资源占用。<br> 3）同步模式下的中断日志只能输出到控制台后端，而异步模式下中断日志可以输出到所有后端去。</strong></span></p> 
<h4 id="5.1.2%E3%80%81%E7%BC%BA%E7%82%B9"><strong>5.1.2、缺点</strong></h4> 
<p><span style="color:#4da8ee;"><strong>1）异步模式需要日志缓冲区。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）异步日志的输出需要有专门线程来完成，比如：idle 线程或者用户自定义的线程，用法上略显复杂。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>3）整体感觉异步模式资源占用会比同步模式要高。</strong></span></p> 
<h3 id="5.2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93">5.2、结构体</h3> 
<h4 id="5.2.1%E3%80%81rt_ulog%E7%BB%93%E6%9E%84%E4%BD%93">5.2.1、rt_ulog结构体</h4> 
<p><span style="color:#ff9900;"><strong>rt_ulog中异步输出相关部分如下：</strong></span></p> 
<pre><code class="language-cpp">struct rt_ulog
{
    ...
#ifdef ULOG_USING_ASYNC_OUTPUT
    rt_bool_t async_enabled;
    rt_rbb_t async_rbb;
    /* ringbuffer for log_raw function only */
    struct rt_ringbuffer *async_rb;
    rt_thread_t async_th;
    struct rt_semaphore async_notice;
#endif
    ...

};
</code></pre> 
<table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td><span style="color:#0d0016;"><strong>异步输出相关成员</strong></span></td><td><span style="color:#0d0016;"><strong>说明</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>async_enabled</strong></span></td><td><span style="color:#4da8ee;"><strong>是否使能异步输出</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>async_rbb</strong></span></td><td><span style="color:#4da8ee;"><strong>异步输出环块缓冲区</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>async_rb</strong></span></td><td> <p><span style="color:#4da8ee;"><strong>异步输出环行缓冲区</strong></span></p> <p><span style="color:#fe2c24;"><strong>注：只用于ulog_raw()函数</strong></span></p> </td></tr><tr><td><span style="color:#4da8ee;"><strong>async_th</strong></span></td><td><span style="color:#4da8ee;"><strong>异步输出线程控制块</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>async_notice</strong></span></td><td><span style="color:#4da8ee;"><strong>异步输出信号量</strong></span></td></tr></tbody></table> 
<h4 id="5.2.2%E3%80%81ulog_frame%E7%BB%93%E6%9E%84%E4%BD%93">5.2.2、ulog_frame结构体</h4> 
<p><span style="color:#ff9900;"><strong>异步消息输出通过将消息封装成ulog_frame结构体放入async_rbb异步输出环块缓冲区中。</strong></span></p> 
<pre><code class="language-cpp">
struct ulog_frame
{
    /* magic word is 0x10 ('lo') */
    rt_uint32_t magic:8;
    rt_uint32_t is_raw:1;
    rt_uint32_t log_len:23;
    rt_uint32_t level;
    const char *log;
    const char *tag;
};
typedef struct ulog_frame *ulog_frame_t;</code></pre> 
<h3 id="5.3%E3%80%81%E5%87%BD%E6%95%B0">5.3、函数</h3> 
<h4 id="5.3.1%E3%80%81ulog_async_output_enabled()%E5%87%BD%E6%95%B0">5.3.1、ulog_async_output_enabled()函数</h4> 
<p><span style="color:#ff9900;"><strong>此接口用于启用或禁用异步输出模式，当禁用异步输出模式时，日志将直接输出。</strong></span></p> 
<pre><code class="language-cpp">void ulog_async_output_enabled(rt_bool_t enabled)</code></pre> 
<h4 id="5.3.2%E3%80%81ulog_async_output()%E5%87%BD%E6%95%B0">5.3.2、ulog_async_output()函数</h4> 
<p><span style="color:#ff9900;"><strong>异步输出日志到所有后端。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>1）遍历ulog.async_rbb取出数据，并调用ulog_output_to_all_backend()函数输出日志</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）从ulog.async_rb取出数据，并调用ulog_output_to_all_backend()函数输出日志(级别为LOG_LVL_DBG，标签为"")</strong></span></p> 
<pre><code class="language-cpp">void ulog_async_output(void)</code></pre> 
<h4 id="5.3.3%E3%80%81ulog_async_waiting_log()%E5%87%BD%E6%95%B0">5.3.3、ulog_async_waiting_log()函数</h4> 
<p><span style="color:#ff9900;"><strong>此接口用于等待获取异步输出日志。</strong></span></p> 
<pre><code class="language-cpp">rt_err_t ulog_async_waiting_log(rt_int32_t time)</code></pre> 
<h4 id="5.3.4%E3%80%81async_output_thread_entry()%E5%87%BD%E6%95%B0">5.3.4、async_output_thread_entry()函数</h4> 
<p><span style="color:#4da8ee;"><strong>1）循环调用ulog_async_output()和ulog_async_waiting_log()函数</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）如果2秒(RT_TICK_PER_SECOND * 2)内没有日志输出，调用ulog_flush()刷新日志缓冲区</strong></span></p> 
<pre><code class="language-cpp">static void async_output_thread_entry(void *param)</code></pre> 
<h4 id="5.3.5%E3%80%81ulog_async_init()%E5%87%BD%E6%95%B0">5.3.5、ulog_async_init()函数</h4> 
<p><span style="color:#ff9900;"><strong>该接口创建一个异步输出线程，并启动。</strong></span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td><span style="color:#0d0016;"><strong>线程参数</strong></span></td><td><span style="color:#0d0016;"><strong>说明</strong></span></td></tr><tr><td><strong>线程名</strong></td><td><strong>"ulog_async"</strong></td></tr><tr><td><strong>入口函数</strong></td><td><strong>async_output_thread_entry</strong></td></tr><tr><td><strong>入口函数参数</strong></td><td><strong>&amp;ulog</strong></td></tr><tr><td><strong>栈大小</strong></td><td><strong>ULOG_ASYNC_OUTPUT_THREAD_STACK</strong></td></tr><tr><td><strong>优先级</strong></td><td><strong>ULOG_ASYNC_OUTPUT_THREAD_PRIORITY</strong></td></tr><tr><td><strong>时间片 </strong></td><td><strong>20</strong></td></tr></tbody></table> 
<pre><code class="language-cpp">int ulog_async_init(void)</code></pre> 
<h2 id="6%E3%80%81%E4%B8%AD%E6%96%AD%E8%BE%93%E5%87%BA">6、中断输出</h2> 
<p><span style="color:#ff9900;"><strong>由于ulog 的异步模式具有缓存机制，注册进来的后端内部也可能具有缓存。如果系统出现了 hardfault 、断言等错误情况，但缓存中还有日志没有输出出来，这可能会导致日志丢失的问题，对于查找异常的原因会无从入手。</strong></span></p> 
<pre><code class="language-cpp">struct rt_ulog
{
    ...
#ifdef ULOG_USING_ISR_LOG
    /* the ISR log's line buffer */
    rt_base_t output_locker_isr_lvl;
    char log_buf_isr[ULOG_LINE_BUF_SIZE + 1];
#endif /* ULOG_USING_ISR_LOG */
    ...
};</code></pre> 
<p><span style="color:#4da8ee;"><strong>很多时候需要在中断 ISR 中输出日志，但是中断 ISR 可能会打断正在进行日志输出的线程。要保证中断日志与线程日志互不干涉，就得针对于中断情况进行特殊处理。</strong></span></p> 
<p></p> 
<p><span style="color:#956fe7;"><strong>同步模式下</strong>：</span><span style="color:#0d0016;"><strong>如果线程此时正在输出日志时来了中断，此时如果中断里也有日志要输出，会直接输出到控制台上，不支持输出到其他后端；</strong></span></p> 
<p><span style="color:#956fe7;"><strong>异步模式下</strong>：</span><span style="color:#0d0016;"><strong>如果发生上面的情况，中断里的日志会先放入缓冲区中，最终和线程日志一起交给日志输出线程来处理。</strong></span></p> 
<h2 id="7%E3%80%81%E5%90%8E%E7%AB%AF">7、后端</h2> 
<h3 id="7.1%E3%80%81ulog_backend%E7%BB%93%E6%9E%84%E4%BD%93">7.1、ulog_backend结构体</h3> 
<pre><code class="language-cpp">struct ulog_backend
{
    char name[RT_NAME_MAX];
    rt_bool_t support_color;
    rt_uint32_t out_level;
    void (*init)  (struct ulog_backend *backend);
    void (*output)(struct ulog_backend *backend, rt_uint32_t level, const char *tag, rt_bool_t is_raw, const char *log, rt_size_t len);
    void (*flush) (struct ulog_backend *backend);
    void (*deinit)(struct ulog_backend *backend);
    /* The filter will be call before output. It will return TRUE when the filter condition is math. */
    rt_bool_t (*filter)(struct ulog_backend *backend, rt_uint32_t level, const char *tag, rt_bool_t is_raw, const char *log, rt_size_t len);
    rt_slist_t list;
};
typedef struct ulog_backend *ulog_backend_t;
typedef rt_bool_t (*ulog_backend_filter_t)(struct ulog_backend *backend, rt_uint32_t level, const char *tag, rt_bool_t is_raw, const char *log, rt_size_t len);</code></pre> 
<table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td><span style="color:#0d0016;"><strong>成员</strong></span></td><td><span style="color:#0d0016;"><strong>说明</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>name</strong></span></td><td><span style="color:#4da8ee;"><strong>后端名称</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>support_color</strong></span></td><td><span style="color:#4da8ee;"><strong>是否支持颜色</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>out_level</strong></span></td><td><span style="color:#4da8ee;"><strong>输出级别</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>init</strong></span></td><td><span style="color:#4da8ee;"><strong>初始化函数</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>output</strong></span></td><td><span style="color:#4da8ee;"><strong>输出函数</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>flush</strong></span></td><td><span style="color:#4da8ee;"><strong>刷新缓存函数</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>deinit</strong></span></td><td><span style="color:#4da8ee;"><strong>取消初始化函数</strong></span></td></tr><tr><td><span style="color:#4da8ee;"><strong>filter</strong></span></td><td> <p><span style="color:#4da8ee;"><strong>过滤函数</strong></span></p> <p><strong><span style="color:#fe2c24;">注：定义ULOG_USING_COLOR且未定义ULOG_USING_SYSLOG时，filter()将在输出之前被调用。当过滤条件为math时，它将返回TRUE。</span></strong></p> </td></tr><tr><td><span style="color:#4da8ee;"><strong>list</strong></span></td><td><span style="color:#4da8ee;"><strong>后端链表节点</strong></span></td></tr></tbody></table> 
<h3 id="7.2%E3%80%81%E6%8E%A5%E5%8F%A3">7.2、接口</h3> 
<h4 id="7.2.1%E3%80%81ulog_backend_register()%E5%87%BD%E6%95%B0">7.2.1、ulog_backend_register()函数</h4> 
<p><span style="color:#ff9900;"><strong>该接口用于注册一个日志后端。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>1）调用backend的init()函数</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）设置backend的support_color和name、设置backend的out_level为LOG_FILTER_LVL_ALL</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>3）将backend链进日志后端链表ulog.backend_list</strong></span></p> 
<pre><code class="language-cpp">rt_err_t ulog_backend_register(ulog_backend_t backend, const char *name, rt_bool_t support_color)</code></pre> 
<h4 id="7.2.2%E3%80%81ulog_backend_unregister()%E5%87%BD%E6%95%B0">7.2.2、ulog_backend_unregister()函数</h4> 
<p><span style="color:#ff9900;"><strong>该接口用于取消注册一个日志后端。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>1）调用backend的deinit()函数</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2）将backend从日志后端链表ulog.backend_list移除</strong></span></p> 
<pre><code class="language-cpp">rt_err_t ulog_backend_unregister(ulog_backend_t backend)</code></pre> 
<h4 id="7.2.3%E3%80%81ulog_backend_set_filter()%E5%87%BD%E6%95%B0">7.2.3、ulog_backend_set_filter()函数</h4> 
<p><span style="color:#ff9900;"><strong>设置backend的filter成员。</strong></span></p> 
<pre><code class="language-cpp">rt_err_t ulog_backend_set_filter(ulog_backend_t backend, ulog_backend_filter_t filter)</code></pre> 
<h4 id="7.2.4%E3%80%81ulog_backend_find()%E5%87%BD%E6%95%B0">7.2.4、ulog_backend_find()函数</h4> 
<p><span style="color:#ff9900;"><strong>根据name从日志后端链表ulog.backend_list中查找对应的backend。</strong></span></p> 
<pre><code class="language-cpp">ulog_backend_t ulog_backend_find(const char *name)</code></pre> 
<h4 id="7.2.5%E3%80%81ulog_be_lvl_filter_set()%E5%87%BD%E6%95%B0">7.2.5、ulog_be_lvl_filter_set()函数</h4> 
<p><span style="color:#ff9900;"><strong>设置名称为be_name的backend的out_level成员为level。</strong></span></p> 
<pre><code class="language-cpp">int ulog_be_lvl_filter_set(const char *be_name, rt_uint32_t level)</code></pre> 
<h2></h2>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/76c2ad95bc6deea353a505588efe795c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python自带的idle以及pycharm使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3a4cb0e0251c4e68fb0514b5c53de909/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【UV打印机】RYPC打印软件配置文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>