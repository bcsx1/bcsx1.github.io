<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LearnOpenGL 笔记（一） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LearnOpenGL 笔记（一）" />
<meta property="og:description" content="目录
一、概述
OpenGL到底是什么
核心模式与立即渲染模式
扩展
状态机
二、窗口
视口
渲染循环(Render Loop)
输入
渲染
三、三角形
图形渲染管线
顶点输入
顶点着色器
片段着色器
链接顶点属性
顶点数组对象
索引缓冲对象
四、着色器
数据类型
输入与输出
Uniform
更多属性
从文件读取
五、纹理
纹理环绕方式
纹理过滤
多级渐远纹理Mipmap
加载与创建纹理
应用纹理
纹理单元
六、变换
向量
矩阵
七、坐标系统
正射投影
透视投影
3D
Z缓冲Z-buffer
八、摄像机
摄像机位置
摄像机方向
Look At
自由移动
视角移动-加入鼠标
缩放
词汇表
一、概述 OpenGL到底是什么 一般它被认为是一个API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。
OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。实际的OpenGL库的开发者通常是显卡的生产商。
OpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。
核心模式与立即渲染模式 早期的OpenGL使用立即渲染模式，OpenGL的大多数功能都被库隐藏起来，开发者很少有控制OpenGL如何进行计算的自由。
教程面向OpenGL3.3的核心模式。
扩展 OpenGL的一大特性就是对扩展(Extension)的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。
状态机 OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。
二、窗口 int main() { glfwInit();//初始化 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); //glfwWindowHint函数的第一个参数代表选项的名称，我们可以从很多以GLFW_开头的枚举值中选择；第二个参数接受一个整型，用来设置这个选项的值。 GLFWwindow* window = glfwCreateWindow(800, 600, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/46d531b2714fc5c9dbeff0633f7a8577/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-13T14:42:12+08:00" />
<meta property="article:modified_time" content="2022-02-13T14:42:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LearnOpenGL 笔记（一）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0" rel="nofollow">一、概述</a></p> 
<p id="OpenGL%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:40px;"><a href="#OpenGL%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">OpenGL到底是什么</a></p> 
<p id="_1-toc" style="margin-left:40px;"><a href="#_1" rel="nofollow">核心模式与立即渲染模式</a></p> 
<p id="%E6%89%A9%E5%B1%95-toc" style="margin-left:40px;"><a href="#%E6%89%A9%E5%B1%95" rel="nofollow">扩展</a></p> 
<p id="_3-toc" style="margin-left:40px;"><a href="#_3" rel="nofollow">状态机</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%AA%97%E5%8F%A3-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%AA%97%E5%8F%A3" rel="nofollow">二、窗口</a></p> 
<p id="%E8%A7%86%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E8%A7%86%E5%8F%A3" rel="nofollow">视口</a></p> 
<p id="%E6%B8%B2%E6%9F%93%E5%BE%AA%E7%8E%AF(Render%20Loop)-toc" style="margin-left:40px;"><a href="#%E6%B8%B2%E6%9F%93%E5%BE%AA%E7%8E%AF%28Render%20Loop%29" rel="nofollow">渲染循环(Render Loop)</a></p> 
<p id="%E8%BE%93%E5%85%A5-toc" style="margin-left:40px;"><a href="#%E8%BE%93%E5%85%A5" rel="nofollow">输入</a></p> 
<p id="_6-toc" style="margin-left:40px;"><a href="#_6" rel="nofollow">渲染</a></p> 
<p id="%E4%B8%89%E3%80%81%E4%B8%89%E8%A7%92%E5%BD%A2-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E4%B8%89%E8%A7%92%E5%BD%A2" rel="nofollow">三、三角形</a></p> 
<p id="%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-toc" style="margin-left:40px;"><a href="#%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF" rel="nofollow">图形渲染管线</a></p> 
<p id="%E2%80%8B-toc" style="margin-left:40px;"></p> 
<p id="_2-toc" style="margin-left:40px;"><a href="#_2" rel="nofollow">顶点输入</a></p> 
<p id="%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8" rel="nofollow">顶点着色器</a></p> 
<p id="_4-toc" style="margin-left:40px;"><a href="#_4" rel="nofollow">片段着色器</a></p> 
<p id="_7-toc" style="margin-left:40px;"><a href="#_7" rel="nofollow">链接顶点属性</a></p> 
<p id="_8-toc" style="margin-left:40px;"><a href="#_8" rel="nofollow">顶点数组对象</a></p> 
<p id="_10-toc" style="margin-left:40px;"><a href="#_10" rel="nofollow">索引缓冲对象</a></p> 
<p id="%E5%9B%9B%E3%80%81%E7%9D%80%E8%89%B2%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%9D%80%E8%89%B2%E5%99%A8" rel="nofollow">四、着色器</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">数据类型</a></p> 
<p id="%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA-toc" style="margin-left:40px;"><a href="#%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA" rel="nofollow">输入与输出</a></p> 
<p id="uniform-toc" style="margin-left:40px;"><a href="#uniform" rel="nofollow">Uniform</a></p> 
<p id="_5-toc" style="margin-left:40px;"><a href="#_5" rel="nofollow">更多属性</a></p> 
<p id="%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96-toc" style="margin-left:40px;"><a href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96" rel="nofollow">从文件读取</a></p> 
<p id="%E4%BA%94%E3%80%81%E7%BA%B9%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E7%BA%B9%E7%90%86" rel="nofollow">五、纹理</a></p> 
<p id="%E7%BA%B9%E7%90%86%E7%8E%AF%E7%BB%95%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E7%BA%B9%E7%90%86%E7%8E%AF%E7%BB%95%E6%96%B9%E5%BC%8F" rel="nofollow">纹理环绕方式</a></p> 
<p id="%E7%BA%B9%E7%90%86%E8%BF%87%E6%BB%A4-toc" style="margin-left:40px;"><a href="#%E7%BA%B9%E7%90%86%E8%BF%87%E6%BB%A4" rel="nofollow">纹理过滤</a></p> 
<p id="%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86Mipmap-toc" style="margin-left:40px;"><a href="#%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86Mipmap" rel="nofollow">多级渐远纹理Mipmap</a></p> 
<p id="%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9B%E5%BB%BA%E7%BA%B9%E7%90%86-toc" style="margin-left:40px;"><a href="#%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9B%E5%BB%BA%E7%BA%B9%E7%90%86" rel="nofollow">加载与创建纹理</a></p> 
<p id="%E5%BA%94%E7%94%A8%E7%BA%B9%E7%90%86-toc" style="margin-left:40px;"><a href="#%E5%BA%94%E7%94%A8%E7%BA%B9%E7%90%86" rel="nofollow">应用纹理</a></p> 
<p id="%E7%BA%B9%E7%90%86%E5%8D%95%E5%85%83-toc" style="margin-left:40px;"><a href="#%E7%BA%B9%E7%90%86%E5%8D%95%E5%85%83" rel="nofollow">纹理单元</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%8F%98%E6%8D%A2-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%8F%98%E6%8D%A2" rel="nofollow">六、变换</a></p> 
<p id="%E5%90%91%E9%87%8F-toc" style="margin-left:40px;"><a href="#%E5%90%91%E9%87%8F" rel="nofollow">向量</a></p> 
<p id="%C2%A0%E7%9F%A9%E9%98%B5-toc" style="margin-left:40px;"><a href="#%C2%A0%E7%9F%A9%E9%98%B5" rel="nofollow"> 矩阵</a></p> 
<p id="%E4%B8%83%E3%80%81%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F" rel="nofollow">七、坐标系统</a></p> 
<p id="%E6%AD%A3%E5%B0%84%E6%8A%95%E5%BD%B1-toc" style="margin-left:40px;"><a href="#%E6%AD%A3%E5%B0%84%E6%8A%95%E5%BD%B1" rel="nofollow">正射投影</a></p> 
<p id="%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1-toc" style="margin-left:40px;"><a href="#%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1" rel="nofollow">透视投影</a></p> 
<p id="3d-toc" style="margin-left:40px;"><a href="#3d" rel="nofollow">3D</a></p> 
<p id="z-toc" style="margin-left:40px;"><a href="#z" rel="nofollow">Z缓冲Z-buffer</a></p> 
<p id="%C2%A0%E4%B8%83%E3%80%81%E6%91%84%E5%83%8F%E6%9C%BA-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%83%E3%80%81%E6%91%84%E5%83%8F%E6%9C%BA" rel="nofollow"> 八、摄像机</a></p> 
<p id="1-toc" style="margin-left:40px;"><a href="#1" rel="nofollow">摄像机位置</a></p> 
<p id="2-toc" style="margin-left:40px;"><a href="#2" rel="nofollow">摄像机方向</a></p> 
<p id="look-at-toc" style="margin-left:40px;"><a href="#look-at" rel="nofollow">Look At</a></p> 
<p id="%E8%87%AA%E7%94%B1%E7%A7%BB%E5%8A%A8-toc" style="margin-left:40px;"><a href="#%E8%87%AA%E7%94%B1%E7%A7%BB%E5%8A%A8" rel="nofollow">自由移动</a></p> 
<p id="%E8%A7%86%E8%A7%92%E7%A7%BB%E5%8A%A8-%E5%8A%A0%E5%85%A5%E9%BC%A0%E6%A0%87-toc" style="margin-left:40px;"><a href="#%E8%A7%86%E8%A7%92%E7%A7%BB%E5%8A%A8-%E5%8A%A0%E5%85%A5%E9%BC%A0%E6%A0%87" rel="nofollow">视角移动-加入鼠标</a></p> 
<p id="%E7%BC%A9%E6%94%BE-toc" style="margin-left:40px;"><a href="#%E7%BC%A9%E6%94%BE" rel="nofollow">缩放</a></p> 
<p id="%E8%AF%8D%E6%B1%87%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E8%AF%8D%E6%B1%87%E8%A1%A8" rel="nofollow">词汇表</a></p> 
<hr id="hr-toc"> 
<h2 id="%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0">一、概述</h2> 
<h3 id="OpenGL%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88">OpenGL到底是什么</h3> 
<p>一般它被认为是一个API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。</p> 
<p>OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。实际的OpenGL库的开发者通常是显卡的生产商。</p> 
<p>OpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。</p> 
<h3 id="_1">核心模式与立即渲染模式</h3> 
<p>早期的OpenGL使用立即渲染模式，OpenGL的大多数功能都被库隐藏起来，开发者很少有控制OpenGL如何进行计算的自由。</p> 
<p>教程面向OpenGL3.3的核心模式。</p> 
<h3 id="%E6%89%A9%E5%B1%95">扩展</h3> 
<p>OpenGL的一大特性就是对扩展(Extension)的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。</p> 
<h3 id="_3">状态机</h3> 
<p>OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。</p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E7%AA%97%E5%8F%A3">二、窗口</h2> 
<pre><code class="language-cpp">int main()
{
    glfwInit();//初始化
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
//glfwWindowHint函数的第一个参数代表选项的名称，我们可以从很多以GLFW_开头的枚举值中选择；第二个参数接受一个整型，用来设置这个选项的值。

   GLFWwindow* window = glfwCreateWindow(800, 600, "LearnOpenGL", NULL, NULL);
//窗口的宽和高，窗口的名称
    if (window == NULL)
    {
        std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);

    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);//回调


    return 0;
}</code></pre> 
<p>GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。</p> 
<pre><code class="language-cpp">if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
{
    std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl;
    return -1;
}</code></pre> 
<h3 id="%E8%A7%86%E5%8F%A3">视口</h3> 
<p>告诉OpenGL<span style="color:#fe2c24;">渲染窗口</span>的尺寸大小即视口(Viewport)</p> 
<pre><code>glViewport(0, 0, 800, 600);
</code></pre> 
<p>glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。</p> 
<p>当用户改变窗口的大小的时候，视口也应该被调整。我们可以对窗口注册一个回调函数(Callback Function)，它会在每次窗口大小被调整的时候被调用。</p> 
<pre><code class="language-cpp">void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    glViewport(0, 0, width, height);
}
//注册
glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
</code></pre> 
<h3 id="%E6%B8%B2%E6%9F%93%E5%BE%AA%E7%8E%AF(Render%20Loop)">渲染循环(Render Loop)</h3> 
<pre><code class="language-cpp">while(!glfwWindowShouldClose(window))
//在我们每次循环的开始前检查一次GLFW是否被要求退出
//如果是的话该函数返回true然后渲染循环便结束了
{
    processInput(window);//检测特定的键是否被按下

    glfwSwapBuffers(window);//交换颜色缓冲
    glfwPollEvents();    
//检查有没有触发什么事件（比如键盘输入、鼠标移动等）
//更新窗口状态，并调用对应的回调函数
  
}
  glfwTerminate();//clearing all
  return 0;</code></pre> 
<blockquote> 
 <p><strong>双缓冲(Double Buffer)</strong></p> 
 <p>使用单缓冲绘图时可能会存在图像闪烁的问题。<strong>前</strong>缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在<strong>后</strong>缓冲上绘制。当所有的渲染指令执行完毕后，我们<strong>交换</strong>(Swap)前缓冲和后缓冲，这样图像就立即呈显出来。</p> 
</blockquote> 
<h3 id="%E8%BE%93%E5%85%A5">输入</h3> 
<pre><code class="language-cpp">void processInput(GLFWwindow *window)
//一个窗口以及一个按键作为输入。这个函数将会返回这个按键是否正在被按下。
{
    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}</code></pre> 
<h3 id="_6">渲染</h3> 
<p>所有的渲染(Rendering)操作放到渲染循环中，因为我们想让这些渲染指令在每次渲染循环迭代的时候都能被执行。</p> 
<p>在每个新的渲染迭代开始的时候我们总是希望清屏，否则我们仍能看见上一次迭代的渲染结果，调用glClear函数来清空屏幕的颜色缓冲，可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT。由于现在我们只关心颜色值，所以我们只清空颜色缓冲。</p> 
<p>glClearColor(0.2f, 0.3f, 0.3f, 1.0f);</p> 
<p>glClear(GL_COLOR_BUFFER_BIT);</p> 
<p>当调用glClear函数，清除颜色缓冲之后，整个颜色缓冲都会被填充为glClearColor里所设置的颜色。</p> 
<h2 id="%E4%B8%89%E3%80%81%E4%B8%89%E8%A7%92%E5%BD%A2">三、三角形</h2> 
<blockquote> 
 <ul><li>顶点数组对象：Vertex Array Object，VAO</li><li>顶点缓冲对象：Vertex Buffer Object，VBO</li><li>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO</li></ul> 
</blockquote> 
<p>OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素，3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线管理。</p> 
<p>第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p> 
<p>OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的</p> 
<h3 id="%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF">图形渲染管线</h3> 
<p><img alt="" height="381" src="https://images2.imgbox.com/4a/a2/vyUfuWFf_o.png" width="657"></p> 
<h3 id="%E2%80%8B"></h3> 
<ol><li> 以数组的形式传递3个3D坐标作为图形渲染管线的输入用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)</li><li>顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标</li><li>图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；</li><li>几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。</li><li>光栅化阶段(Rasterization Stage)把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。<span style="color:#fe2c24;"><strong>在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</strong></span></li><li>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</li></ol> 
<h3 id="_2">顶点输入</h3> 
<p>在OpenGL中指定的所有坐标都是3D坐标（x、y和z），OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。</p> 
<pre><code class="language-cpp">float vertices[] = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};</code></pre> 
<p>把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。</p> 
<pre><code class="language-cpp">unsigned int VBO;
glGenBuffers(1, &amp;VBO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);  //使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)。

glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
//把之前定义的顶点数据复制到缓冲的内存中
//第一个参数是目标缓冲的类型,第二个参数指定传输数据的大小(以字节为单位)
//第三个参数是我们希望发送的实际数据。
第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：

GL_STATIC_DRAW ：数据不会或几乎不会改变。
GL_DYNAMIC_DRAW：数据会被改变很多。
GL_STREAM_DRAW ：数据每次绘制时都会改变。</code></pre> 
<h3 id="%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8">顶点着色器</h3> 
<pre><code class="language-cpp">#version 330 core
layout (location = 0) in vec3 aPos;//设定了输入变量的位置值

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
//一个向量有最多4个分量，每个分量值都代表空间中的一个坐标
//它们可以通过vec.x、vec.y、vec.z和vec.w来获取。</code></pre> 
<p>我们必须把位置数据赋值给预定义的gl_Position变量，它在幕后是<code>vec4</code>类型的。</p> 
<p>gl_Position设置的值会成为该顶点着色器的输出。</p> 
<h3 id="_4">片段着色器</h3> 
<pre><code class="language-cpp">#version 330 core
out vec4 FragColor;

void main()
{
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
} </code></pre> 
<h3 id="_7">链接顶点属性</h3> 
<p><img alt="" height="227" src="https://images2.imgbox.com/09/46/FlPIiMnL_o.png" width="865"></p> 
<pre><code class="language-cpp">解析顶点数据:
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
//第二个参数指定顶点属性的大小，第三个参数指定数据的类型
//第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。
//最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。</code></pre> 
<p>使用glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。</p> 
<h3 id="_8">顶点数组对象</h3> 
<p>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。</p> 
<blockquote> 
 <p>OpenGL的核心模式<strong>要求</strong>我们使用VAO，所以它知道该如何处理我们的顶点输入。如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。</p> 
</blockquote> 
<pre><code class="language-cpp">// 1. 绑定VAO
glBindVertexArray(VAO);
// 2. 把顶点数组复制到缓冲中供OpenGL使用
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 3. 设置顶点属性指针
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

[...]

// ..:: 绘制代码（渲染循环中） :: ..
// 4. 绘制物体
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
someOpenGLFunctionThatDrawsOurTriangle();
</code></pre> 
<p>//绘制多个物体时，你首先要生成/配置所有的VAO（和必须的VBO及属性指针)，然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。</p> 
<h3 id="_10">索引缓冲对象</h3> 
<p>索引缓冲对象(Element Buffer Object，EBO，也叫Index Buffer Object，IBO)它专门储存索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点。</p> 
<pre><code class="language-cpp">定义（不重复的）顶点，和绘制出矩形所需的索引
float vertices[] = {
    0.5f, 0.5f, 0.0f,   // 右上角
    0.5f, -0.5f, 0.0f,  // 右下角
    -0.5f, -0.5f, 0.0f, // 左下角
    -0.5f, 0.5f, 0.0f   // 左上角
};

unsigned int indices[] = { // 注意索引从0开始! 
    0, 1, 3, // 第一个三角形
    1, 2, 3  // 第二个三角形
};

unsigned int EBO;
glGenBuffers(1, &amp;EBO);//创建索引缓冲对象
//先绑定EBO然后用glBufferData把索引复制到缓冲里
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

</code></pre> 
<pre><code class="language-cpp">最后的初始化和绘制代码现在看起来像这样：
// ..:: 初始化代码 :: ..
// 1. 绑定顶点数组对象
glBindVertexArray(VAO);
// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
// 4. 设定顶点属性指针
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

[...]

// ..:: 绘制代码（渲染循环中） :: ..
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)


第一个参数指定了我们绘制的模式，这个和glDrawArrays的一样。
第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点。
第三个参数是索引的类型，这里是GL_UNSIGNED_INT。
glBindVertexArray(0);</code></pre> 
<blockquote> 
 <p><strong>线框模式(Wireframe Mode)</strong></p> 
 <p>要想用线框模式绘制你的三角形，你可以通过<code>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</code></p> 
</blockquote> 
<h2 id="%E5%9B%9B%E3%80%81%E7%9D%80%E8%89%B2%E5%99%A8">四、着色器</h2> 
<p>着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。</p> 
<p>着色器是使用一种叫GLSL的类C语言写成的。</p> 
<h3 id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</h3> 
<p>GLSL中包含C等其它语言大部分的默认基础数据类型：<code>int</code>、<code>float</code>、<code>double</code>、<code>uint</code>和<code>bool</code>。</p> 
<p>GLSL中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。</p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/fb/19/kPFQTLiA_o.png" width="491"></p> 
<p> 一个向量的分量可以通过<code>vec.x</code>这种方式获取，这里<code>x</code>是指这个向量的第一个分量。GLSL也允许你对颜色使用<code>rgba</code>，或是对纹理坐标使用<code>stpq</code>访问相同的分量。</p> 
<h3 id="%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA">输入与输出</h3> 
<p>GLSL定义了<code>in</code>和<code>out</code>关键字，顶点着色器应该接收的是一种特殊形式的输入使用<code>location</code>这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。另一个例外是片段着色器，它需要一个<code>vec4</code>颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。</p> 
<pre><code class="language-cpp">//vs
#version 330 core
layout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0

out vec4 vertexColor; // 为片段着色器指定一个颜色输出

void main()
{
    gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数
    vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色
}

//fs
#version 330 core
out vec4 FragColor;

in vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）

void main()
{
    FragColor = vertexColor;
}</code></pre> 
<h3 id="uniform">Uniform</h3> 
<p>uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。</p> 
<p></p> 
<p>uniform vec4 ourColor; // 在OpenGL程序代码中设定这个变量</p> 
<p>这个uniform现在还是空的；我们还没有给它添加任何数据，所以下面我们就做这件事。我们首先需要找到着色器中uniform属性的索引/位置值。当我们得到uniform的索引/位置值后，我们就可以更新它的值了。</p> 
<pre><code class="language-cpp">int vertexColorLocation = glGetUniformLocation(shaderProgram, "ourColor");
//用glGetUniformLocation查询uniform ourColor的位置值。
//我们为查询函数提供着色器程序和uniform的名字
//返回-1就代表没有找到这个位置值。

glUseProgram(shaderProgram);
glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);
//通过glUniform4f函数设置uniform值。
//更新一个uniform之前你必须先使用程序调用glUseProgram</code></pre> 
<p><img alt="" height="286" src="https://images2.imgbox.com/f3/7e/ymYVu5d7_o.png" width="534"></p> 
<h3 id="_5">更多属性</h3> 
<pre><code class="language-cpp">float vertices[] = {
    // 位置              // 颜色
     0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下
    -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下
     0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    // 顶部
};</code></pre> 
<p> 由于现在有更多的数据要发送到顶点着色器，我们有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。</p> 
<p></p> 
<p>layout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1</p> 
<p>因为我们添加了另一个顶点属性，并且更新了VBO的内存，我们就必须重新配置顶点属性指针。</p> 
<pre><code class="language-cpp">// 位置属性
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
// 颜色属性
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));
glEnableVertexAttribArray(1);</code></pre> 
<h3 id="%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96">从文件读取</h3> 
<p>我们使用C++文件流读取着色器内容，储存到几个<code>string</code>对象里：</p> 
<pre><code class="language-cpp">Shader(const char* vertexPath, const char* fragmentPath)
{
    // 1. 从文件路径中获取顶点/片段着色器
    std::string vertexCode;
    std::string fragmentCode;
    std::ifstream vShaderFile;
    std::ifstream fShaderFile;
    // 保证ifstream对象可以抛出异常：
    vShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);
    fShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);
    try 
    {
        // 打开文件
        vShaderFile.open(vertexPath);
        fShaderFile.open(fragmentPath);
        std::stringstream vShaderStream, fShaderStream;
        // 读取文件的缓冲内容到数据流中
        vShaderStream &lt;&lt; vShaderFile.rdbuf();
        fShaderStream &lt;&lt; fShaderFile.rdbuf();       
        // 关闭文件处理器
        vShaderFile.close();
        fShaderFile.close();
        // 转换数据流到string
        vertexCode   = vShaderStream.str();
        fragmentCode = fShaderStream.str();     
    }
    catch(std::ifstream::failure e)
    {
        std::cout &lt;&lt; "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ" &lt;&lt; std::endl;
    }
    const char* vShaderCode = vertexCode.c_str();
    const char* fShaderCode = fragmentCode.c_str();</code></pre> 
<p>下一步，我们需要编译和链接着色器。</p> 
<pre><code class="language-cpp">// 2. 编译着色器
unsigned int vertex, fragment;
int success;
char infoLog[512];

// 顶点着色器
vertex = glCreateShader(GL_VERTEX_SHADER);
glShaderSource(vertex, 1, &amp;vShaderCode, NULL);
glCompileShader(vertex);
// 打印编译错误（如果有的话）
glGetShaderiv(vertex, GL_COMPILE_STATUS, &amp;success);
if(!success)
{
    glGetShaderInfoLog(vertex, 512, NULL, infoLog);
    std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;
};</code></pre> 
<pre><code class="language-cpp">我们会把着色器类全部放在在头文件里
class Shader
{
public:
    // 程序ID
    unsigned int ID;

    // 构造器读取并构建着色器
    Shader(const GLchar* vertexPath, const GLchar* fragmentPath);
    // 使用/激活程序
    void use();
    // uniform工具函数
    void setBool(const std::string &amp;name, bool value) const;  
    void setInt(const std::string &amp;name, int value) const;   
    void setFloat(const std::string &amp;name, float value) const;
};

//
void use() 
{ 
    glUseProgram(ID);
}
void setFloat(const std::string &amp;name, float value) const
{ 
    glUniform1f(glGetUniformLocation(ID, name.c_str()), value); 
}
...


// 着色器程序
ID = glCreateProgram();
glAttachShader(ID, vertex);
glAttachShader(ID, fragment);
glLinkProgram(ID);
// 打印连接错误（如果有的话）
glGetProgramiv(ID, GL_LINK_STATUS, &amp;success);
if(!success)
{
    glGetProgramInfoLog(ID, 512, NULL, infoLog);
    std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;
}

// 删除着色器，它们已经链接到我们的程序中了，已经不再需要了
glDeleteShader(vertex);
glDeleteShader(fragment);</code></pre> 
<p>着色器类使用</p> 
<pre><code class="language-cpp">Shader ourShader("path/to/shaders/shader.vs", "path/to/shaders/shader.fs");
...
while(...)
{
    ourShader.use();
    ourShader.setFloat("someUniform", 1.0f);
    DrawStuff();
}</code></pre> 
<h2 id="%E4%BA%94%E3%80%81%E7%BA%B9%E7%90%86">五、纹理</h2> 
<p>纹理是一个2D图片（甚至也有1D和3D的纹理），每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样。</p> 
<p>纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。</p> 
<p><img alt="" height="339" src="https://images2.imgbox.com/28/ca/sMxPbuSg_o.png" width="444"></p> 
<pre><code class="language-cpp">float texCoords[] = {
    0.0f, 0.0f, // 左下角
    1.0f, 0.0f, // 右下角
    0.5f, 1.0f // 上中
};</code></pre> 
<h3 id="%E7%BA%B9%E7%90%86%E7%8E%AF%E7%BB%95%E6%96%B9%E5%BC%8F">纹理环绕方式</h3> 
<p><img alt="" height="236" src="https://images2.imgbox.com/2c/b6/p4DeDFaw_o.png" width="889"></p> 
<p><img alt="" height="278" src="https://images2.imgbox.com/d1/c6/uJMEHWd3_o.png" width="930"></p> 
<p> 第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。第二个参数需要我们指定设置的选项与应用的<span style="color:#fe2c24;">纹理轴</span>。我们打算配置的是<code>WRAP</code>选项，并且指定<code>S</code>和<code>T</code>轴。最后一个参数需要我们传递一个环绕方式(Wrapping)</p> 
<pre><code class="language-cpp">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</code></pre> 
<h3 id="%E7%BA%B9%E7%90%86%E8%BF%87%E6%BB%A4">纹理过滤</h3> 
<blockquote> 
 <p>图片不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；</p> 
 <p>纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。</p> 
</blockquote> 
<p>GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。OpenGL会选择中心点最接近纹理坐标的那个像素。</p> 
<p><img alt="" height="187" src="https://images2.imgbox.com/37/3e/h9D1aehE_o.png" width="277"></p> 
<p> GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。</p> 
<p><img alt="" height="181" src="https://images2.imgbox.com/55/c0/kp2zSYD5_o.png" width="278"></p> 
<p>差别：GL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出。</p> 
<p><img alt="" height="224" src="https://images2.imgbox.com/13/fe/SKLXmoNd_o.png" width="419"></p> 
<p> 当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。</p> 
<pre><code class="language-cpp">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</code></pre> 
<h3 id="%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86Mipmap">多级渐远纹理Mipmap</h3> 
<p>假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难。</p> 
<p>它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。</p> 
<p> <img alt="" height="269" src="https://images2.imgbox.com/c5/34/nziI40FZ_o.png" width="394"></p> 
<p> 切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。</p> 
<pre><code class="language-cpp">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</code></pre> 
<h3 id="%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9B%E5%BB%BA%E7%BA%B9%E7%90%86">加载与创建纹理</h3> 
<p><code>stb_image.h</code>库</p> 
<pre><code class="language-cpp">#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
通过定义STB_IMAGE_IMPLEMENTATION，预处理器会修改头文件，让其只包含相关的函数定义源码</code></pre> 
<p>生成纹理</p> 
<pre><code class="language-cpp">unsigned int texture;
glGenTextures(1, &amp;texture);
//生成纹理的数量，然后把它们储存在第二个参数的unsigned int数组中

glBindTexture(GL_TEXTURE_2D, texture);
// 为当前绑定的纹理对象设置环绕、过滤方式
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

// 加载并生成纹理
int width, height, nrChannels;
unsigned char *data = stbi_load("container.jpg", &amp;width, &amp;height, &amp;nrChannels, 0);
if (data)
{
//纹理目标(Target),纹理指定多级渐远纹理的级别，纹理储存为何种格式.
//第四个和第五个参数设置最终的纹理的宽度和高度

//第七第八个参数定义了源图的格式和数据类型。
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);

    glGenerateMipmap(GL_TEXTURE_2D);
}
else
{
    std::cout &lt;&lt; "Failed to load texture" &lt;&lt; std::endl;
}
stbi_image_free(data);//释放图像的内存</code></pre> 
<h3 id="%E5%BA%94%E7%94%A8%E7%BA%B9%E7%90%86">应用纹理</h3> 
<pre><code class="language-cpp">float vertices[] = {
//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -
     0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f,   // 右上
     0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f,   // 右下
    -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f,   // 左下
    -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f    // 左上
};
...
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
glEnableVertexAttribArray(2);</code></pre> 
<p>调整顶点着色器使其能够接受顶点坐标为一个顶点属性，并把坐标传给片段着色器</p> 
<pre><code class="language-cpp">layout (location = 2) in vec2 aTexCoord;
out vec2 TexCoord;
void main()
{
    TexCoord = aTexCoord;
}
片段着色器应该接下来会把输出变量TexCoord作为输入变量。
GLSL有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)，它以纹理类型作为后缀
声明一个uniform sampler2D把一个纹理添加到片段着色器中

fs:
in vec2 TexCoord;
uniform sampler2D ourTexture;
void main()
{
    FragColor = texture(ourTexture, TexCoord);
}
//它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。</code></pre> 
<p>现在只剩下在调用glDrawElements之前绑定纹理了，它会自动把纹理赋值给片段着色器的采样器：</p> 
<pre><code class="language-cpp">glBindTexture(GL_TEXTURE_2D, texture);
glBindVertexArray(VAO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code></pre> 
<h3 id="%E7%BA%B9%E7%90%86%E5%8D%95%E5%85%83">纹理单元</h3> 
<p>一个纹理的位置值通常称为一个纹理单元，纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。</p> 
<pre><code class="language-cpp">glActiveTexture(GL_TEXTURE0); // 在绑定纹理之前先激活纹理单元
glBindTexture(GL_TEXTURE_2D, texture);</code></pre> 
<p>激活纹理单元之后，接下来的glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元GL_TEXTURE0默认总是被激活，OpenGL至少保证有16个纹理单元。</p> 
<pre><code class="language-cpp">#version 330 core
...

uniform sampler2D texture1;
uniform sampler2D texture2;

void main()
{
    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);
}</code></pre> 
<p>我们仍然需要编辑片段着色器来接收另一个采样器最终输出颜色现在是两个纹理的结合。</p> 
<p>渲染流程：</p> 
<pre><code class="language-cpp">先绑定两个纹理到对应的纹理单元
glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, texture1); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, texture2);

通过使用glUniform1i设置每个采样器的方式告诉OpenGL每个着色器采样器属于哪个纹理单元。
ourShader.use(); // 不要忘记在设置uniform变量之前激活着色器程序！
glUniform1i(glGetUniformLocation(ourShader.ID, "texture1"), 0); // 手动设置
ourShader.setInt("texture2", 1); // 或者使用着色器类设置</code></pre> 
<blockquote> 
 <p>纹理上下颠倒：OpenGL要求y轴<code>0.0</code>坐标是在图片的底部的，但是图片的y轴<code>0.0</code>坐标通常在顶部。</p> 
 <pre><code>stbi_set_flip_vertically_on_load(true);
</code></pre> 
</blockquote> 
<h2 id="%E5%85%AD%E3%80%81%E5%8F%98%E6%8D%A2">六、变换</h2> 
<h3 id="%E5%90%91%E9%87%8F">向量</h3> 
<p>向量最基本的定义就是一个方向。向量有一个方向(Direction)和大小(Magnitude，也叫做强度或长度)。标量(Scalar)只是一个数字（或者说是仅有一个分量的向量）。</p> 
<p>两个向量相乘是一种很奇怪的情况。普通的乘法在向量上是没有定义的，因为它在视觉上是没有意义的。但是在相乘的时候我们有两种特定情况可以选择：一个是点乘另一个是叉乘(Cross Product)</p> 
<p>叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。</p> 
<p><img alt="" height="193" src="https://images2.imgbox.com/cf/27/n3Y7al6g_o.png" width="198"></p> 
<h3 id="%C2%A0%E7%9F%A9%E9%98%B5"> 矩阵</h3> 
<p><a class="link-info" href="https://space.bilibili.com/88461692#!/channel/detail?cid=9450" rel="nofollow" title="参考">参考</a></p> 
<h2 id="%E4%B8%83%E3%80%81%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F">七、坐标系统</h2> 
<p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。</p> 
<p><img alt="" height="439" src="https://images2.imgbox.com/61/1c/RgMNnpAO_o.png" width="879"></p> 
<ol><li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li><li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li><li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li><li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</li><li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li></ol> 
<h3 id="%E6%AD%A3%E5%B0%84%E6%8A%95%E5%BD%B1">正射投影</h3> 
<pre><code>glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);
</code></pre> 
<p>前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部。通过这四个参数我们定义了近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离。这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。<img alt="" height="216" src="https://images2.imgbox.com/61/2b/M1fp1jKX_o.png" width="259"> </p> 
<h3 id="%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1">透视投影</h3> 
<p>由于透视，这两条线在很远的地方看起来会相交。这正是透视投影想要模仿的效果，它是使用透视投影矩阵来完成的。</p> 
<p>glm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);</p> 
<p>视野/宽高比/平截头体的<strong>近</strong>和<strong>远</strong>平面</p> 
<p><code>glm::perspective</code>所做的其实就是创建了一个定义了可视空间的大<strong>平截头体</strong>，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会受到裁剪。</p> 
<p><img alt="" height="230" src="https://images2.imgbox.com/d2/bc/qBwyEfQ2_o.png" width="266"></p> 
<p> 当使用正射投影时，每一个顶点坐标都会直接映射到裁剪空间中而不经过任何精细的透视除法.</p> 
<h3 id="3d">3D</h3> 
<p>在开始进行3D绘图时，我们首先创建一个模型矩阵。这个模型矩阵包含了位移、缩放与旋转操作，它们会被应用到所有物体的顶点上，以<strong>变换</strong>它们到全局的世界空间。</p> 
<pre><code class="language-cpp">glm::mat4 model;
model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f));

glm::mat4 view;
// 注意，我们将矩阵向我们要进行移动场景的反方向移动。
view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));

glm::mat4 projection;
projection = glm::perspective(glm::radians(45.0f), screenWidth / screenHeight, 0.1f, 100.0f);

传入着色器
#version 330 core
layout (location = 0) in vec3 aPos;
...
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    // 注意乘法要从右向左读
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    ...
}</code></pre> 
<p>将矩阵传入着色器</p> 
<p>int modelLoc = glGetUniformLocation(ourShader.ID, "model")); glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));</p> 
<p>...</p> 
<h3 id="z">Z缓冲Z-buffer</h3> 
<p>GLFW会自动为你生成这样一个缓冲,深度值存储在每个片段里面（作为片段的<strong>z</strong>值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)，它是由OpenGL自动完成的。</p> 
<p>启用深度测试：</p> 
<pre><code>glEnable(GL_DEPTH_TEST);
</code></pre> 
<p>因为我们使用了深度测试，我们也想要在每次渲染迭代之前清除深度缓冲</p> 
<pre><code>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
</code></pre> 
<h2 id="%C2%A0%E4%B8%83%E3%80%81%E6%91%84%E5%83%8F%E6%9C%BA"> 八、摄像机</h2> 
<p>当我们讨论摄像机/观察空间(Camera/View Space)的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标。</p> 
<h3 id="1">摄像机位置</h3> 
<p>获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量。z轴是从屏幕指向你。我们希望摄像机向后移动，我们就沿着z轴的正方向移动。</p> 
<pre><code class="language-cpp">glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);
</code></pre> 
<h3 id="2">摄像机方向</h3> 
<p>指的是摄像机指向哪个方向。摄像机指向z轴负方向，但我们希望方向向量(Direction Vector)指向摄像机的z轴正方向。</p> 
<pre><code class="language-cpp">glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);
glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);</code></pre> 
<p>我们需要的另一个向量是一个<strong>右向量</strong>(Right Vector)，它代表摄像机空间的x轴的正方向。先定义一个<strong>上向量</strong>(Up Vector)。接下来把上向量和第二步得到的方向向量进行叉乘。现在我们已经有了x轴向量和z轴向量，获取一个指向摄像机的正y轴向量就相对简单了：把右向量和方向向量进行叉乘：</p> 
<pre><code class="language-cpp">glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); 
glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));

glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);
</code></pre> 
<h3 id="look-at">Look At</h3> 
<p>用这3个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。</p> 
<p>我们要做的只是定义一个摄像机位置，一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量）。</p> 
<pre><code class="language-cpp">glm::mat4 view;
view = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), 
           glm::vec3(0.0f, 0.0f, 0.0f), 
           glm::vec3(0.0f, 1.0f, 0.0f));</code></pre> 
<h3 id="%E8%87%AA%E7%94%B1%E7%A7%BB%E5%8A%A8">自由移动</h3> 
<p>我们首先将摄像机位置设置为之前定义的cameraPos。方向是当前的位置加上我们刚刚定义的方向向量。这样能保证无论我们怎么移动，摄像机都会注视着目标方向。</p> 
<pre><code class="language-cpp">glm::vec3 cameraPos   = glm::vec3(0.0f, 0.0f,  3.0f);
glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);
glm::vec3 cameraUp    = glm::vec3(0.0f, 1.0f,  0.0f);

view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);

void processInput(GLFWwindow *window)
{
    ...
    float cameraSpeed = 0.05f; // adjust accordingly
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
        cameraPos += cameraSpeed * cameraFront;
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
        cameraPos -= cameraSpeed * cameraFront;
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
}</code></pre> 
<p>当我们按下<strong>WASD</strong>键的任意一个，摄像机的位置都会相应更新。如果我们希望向前或向后移动，我们就把位置向量加上或减去方向向量。如果我们希望向左右移动，我们使用叉乘来创建一个<strong>右向量</strong>(Right Vector)，并沿着它相应移动就可以了。</p> 
<p>目前我们的移动速度是个常量。</p> 
<p>图形程序和游戏通常会跟踪一个时间差(Deltatime)变量，它储存了渲染上一帧所用的时间。我们把所有速度都去乘以deltaTime值。结果就是，如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。</p> 
<pre><code class="language-cpp">float deltaTime = 0.0f; // 当前帧与上一帧的时间差
float lastFrame = 0.0f; // 上一帧的时间

float currentFrame = glfwGetTime();
deltaTime = currentFrame - lastFrame;
lastFrame = currentFrame;

void processInput(GLFWwindow *window)
{
  float cameraSpeed = 2.5f * deltaTime;
  ...
}</code></pre> 
<h3 id="%E8%A7%86%E8%A7%92%E7%A7%BB%E5%8A%A8-%E5%8A%A0%E5%85%A5%E9%BC%A0%E6%A0%87">视角移动-加入鼠标</h3> 
<p>为了能够改变视角，我们需要根据鼠标的输入改变cameraFront向量。</p> 
<p id="_6">欧拉角：欧拉角(Euler Angle)是可以表示3D空间中任何旋转的3个值，俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)。</p> 
<p><img alt="" height="303" src="https://images2.imgbox.com/2a/f7/ODfqsyZ0_o.png" width="870"></p> 
<pre><code class="language-cpp">direction.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw)); 
// 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的
direction.y = sin(glm::radians(pitch));
direction.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));</code></pre> 
<p>偏航角和俯仰角是通过鼠标（或手柄）移动获得的，水平的移动影响偏航角，竖直的移动影响俯仰角。它的原理就是，储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少。如果水平/竖直差别越大那么俯仰角或偏航角就改变越大，也就是摄像机需要移动更多的距离。</p> 
<ol><li>计算鼠标距上一帧的偏移量。</li><li>把偏移量添加到摄像机的俯仰角和偏航角中。</li><li>对偏航角和俯仰角进行最大和最小值的限制。</li><li>计算方向向量。</li><li></ol> 
<pre><code class="language-cpp">glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);//隐藏光标，并捕捉(Capture)它

void mouse_callback(GLFWwindow* window, double xpos, double ypos);

glfwSetCursorPosCallback(window, mouse_callback);

我们必须先在程序中储存上一帧的鼠标位置，我们把它的初始值设置为屏幕的中心
float lastX = 400, lastY = 300;

float xoffset = xpos - lastX;
float yoffset = lastY - ypos; // 注意这里是相反的，因为y坐标是从底部往顶部依次增大的
lastX = xpos;
lastY = ypos;

float sensitivity = 0.05f;
xoffset *= sensitivity;//灵敏度
yoffset *= sensitivity;

yaw   += xoffset;
pitch += yoffset;
给摄像机添加一些限制，这样摄像机就不会发生奇怪的移动了，对于俯仰角，要让用户不能看向高于89度的地方（在90度时视角会发生逆转，所以我们把89度作为极限），同样也不允许小于-89度。
if(pitch &gt; 89.0f)
  pitch =  89.0f;
if(pitch &lt; -89.0f)
  pitch = -89.0f;
通过俯仰角和偏航角来计算以得到真正的方向向量
glm::vec3 front;
front.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw));
front.y = sin(glm::radians(pitch));
front.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));
cameraFront = glm::normalize(front);
</code></pre> 
<h3 id="%E7%BC%A9%E6%94%BE">缩放</h3> 
<p>使用鼠标的滚轮来放大</p> 
<pre><code class="language-cpp">glfwSetScrollCallback(window, scroll_callback);//注册鼠标滚轮的回调函数

void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
{
  if(fov &gt;= 1.0f &amp;&amp; fov &lt;= 45.0f)
    fov -= yoffset;//yoffset值代表我们竖直滚动的大小
  if(fov &lt;= 1.0f)
    fov = 1.0f;
  if(fov &gt;= 45.0f)//45.0f是默认的视野值
    fov = 45.0f;
}</code></pre> 
<p>我们现在在每一帧都必须把透视投影矩阵上传到GPU，但现在使用fov变量作为它的视野： </p> 
<p>projection = glm::perspective(glm::radians(fov), 800.0f / 600.0f, 0.1f, 100.0f);</p> 
<h2 id="%E8%AF%8D%E6%B1%87%E8%A1%A8">词汇表</h2> 
<ul><li><strong>GLAD</strong>： 一个拓展加载库，用来为我们加载并设定所有OpenGL函数指针</li><li><strong>视口(Viewport)</strong>： 我们需要渲染的窗口</li><li><strong>图形管线(Graphics Pipeline)</strong>： 一个顶点在呈现为像素之前经过的全部过程</li><li><strong>着色器(Shader)</strong>： 一个运行在显卡上的小型程序</li><li><strong>顶点数组对象(Vertex Array Object)</strong>： 存储缓冲区和顶点属性状态</li><li><strong>顶点缓冲对象(Vertex Buffer Object)</strong>： 一个调用显存并存储所有顶点数据供显卡使用的缓冲对象</li><li><strong>索引缓冲对象(Element Buffer Object)</strong>： 一个存储索引供索引化绘制使用的缓冲对象</li><li><strong>纹理缠绕(Texture Wrapping)</strong>： 定义了一种当纹理顶点超出范围(0, 1)时指定OpenGL如何采样纹理的模式</li><li><strong>纹理过滤(Texture Filtering)</strong>： 定义了一种当有多种纹素选择时指定OpenGL如何采样纹理的模式</li><li><strong>多级渐远纹理(Mipmaps)</strong>： 被存储的材质的一些缩小版本，根据距观察者的距离会使用材质的合适大小</li><li><strong>纹理单元(Texture Units)</strong>： 通过绑定纹理到不同纹理单元从而允许多个纹理在同一对象上渲染</li><li><strong>GLM</strong>： 一个为OpenGL打造的数学库</li><li><strong>局部空间(Local Space)</strong>： 一个物体的初始空间。所有的坐标都是相对于物体的原点的</li><li><strong>世界空间(World Space)</strong>： 所有的坐标都相对于全局原点</li><li><strong>观察空间(View Space)</strong>： 所有的坐标都是从摄像机的视角观察</li><li><strong>裁剪空间(Clip Space)</strong>： 该空间应用了投影。这个空间应该是一个顶点坐标最终的空间，作为顶点着色器的输出</li><li><strong>屏幕空间(Screen Space)</strong>： 所有的坐标都由屏幕视角来观察</li><li><strong>LookAt矩阵</strong>： 一种特殊类型的观察矩阵，它创建了一个坐标系，其中所有坐标都根据从一个位置正在观察目标的用户旋转或者平移</li></ul> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9179ac99a41b5374c032f3f0f1855574/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux pgrep命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3294afb518dcd6c15aea0c9a1e95bbff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c语言基本语法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>