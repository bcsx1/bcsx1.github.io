<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Leetcode 第1，2，20，21，27，35，53，67，69，217题(Java解法) - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Leetcode 第1，2，20，21，27，35，53，67，69，217题(Java解法)" />
<meta property="og:description" content="Java解leetcode，助力面试之简单10道题（一） 第1题 两数之和解题思路代码 第2题 两数相加(中等题)解题思路代码 第20题 有效的括号解题思路代码 第21题 合并两个有序链表解题思路代码 第27题 移除元素解题思路代码 第35题 搜索插入位置解题思路代码 第53题 最大子序和解题思路代码 第67题 二进制求和解题思路代码 第69题 X的平方根解题思路代码 第217题 存在重复元素解题思路代码 第1题 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入输出nums = [2,7,11,15], target = 9[0,1] 解释：因为 nums[0] &#43; nums[1] == 9 ，返回 [0, 1] 。
示例 2：
输入输出nums = [3,2,4], target = 6[1,2] 示例 3：
输入输出nums = [3,3], target = 6[0,1] 解题思路 本题可使用哈希表和暴力解法，但由于暴力解法是使用嵌套遍历数组，时间复杂度达到了O(n*n)，故不提倡。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8a9dc4fa3e2ff4e161582e849253b9f8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-23T22:30:40+08:00" />
<meta property="article:modified_time" content="2021-06-23T22:30:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Leetcode 第1，2，20，21，27，35，53，67，69，217题(Java解法)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Java解leetcode，助力面试之简单10道题（一）</h4> 
 <ul><li><a href="#font_colorred_1_font_2" rel="nofollow"><font color="red">第1题 两数之和</font></a></li><li><ul><li><a href="#_26" rel="nofollow">解题思路</a></li><li><a href="#_30" rel="nofollow">代码</a></li></ul> 
  </li><li><a href="#font_colorred_2_font_51" rel="nofollow"><font color="red">第2题 两数相加(中等题)</font></a></li><li><ul><li><a href="#_75" rel="nofollow">解题思路</a></li><li><a href="#_78" rel="nofollow">代码</a></li></ul> 
  </li><li><a href="#font_colorred_20_font_115" rel="nofollow"><font color="red">第20题 有效的括号</font></a></li><li><ul><li><a href="#_149" rel="nofollow">解题思路</a></li><li><a href="#_151" rel="nofollow">代码</a></li></ul> 
  </li><li><a href="#font_colorred_21_font_184" rel="nofollow"><font color="red">第21题 合并两个有序链表</font></a></li><li><ul><li><a href="#_203" rel="nofollow">解题思路</a></li><li><a href="#_206" rel="nofollow">代码</a></li></ul> 
  </li><li><a href="#font_colorred_27_font_231" rel="nofollow"><font color="red">第27题 移除元素</font></a></li><li><ul><li><a href="#_250" rel="nofollow">解题思路</a></li><li><a href="#_252" rel="nofollow">代码</a></li></ul> 
  </li><li><a href="#font_colorred_35_font_273" rel="nofollow"><font color="red">第35题 搜索插入位置</font></a></li><li><ul><li><a href="#_296" rel="nofollow">解题思路</a></li><li><a href="#_299" rel="nofollow">代码</a></li></ul> 
  </li><li><a href="#font_colorred_53_font_323" rel="nofollow"><font color="red">第53题 最大子序和</font></a></li><li><ul><li><a href="#_351" rel="nofollow">解题思路</a></li><li><a href="#_353" rel="nofollow">代码</a></li></ul> 
  </li><li><a href="#font_colorred_67_font_369" rel="nofollow"><font color="red">第67题 二进制求和</font></a></li><li><ul><li><a href="#_385" rel="nofollow">解题思路</a></li><li><a href="#_388" rel="nofollow">代码</a></li></ul> 
  </li><li><a href="#font_colorred_69_Xfont_413" rel="nofollow"><font color="red">第69题 X的平方根</font></a></li><li><ul><li><a href="#_430" rel="nofollow">解题思路</a></li><li><a href="#_432" rel="nofollow">代码</a></li></ul> 
  </li><li><a href="#font_colorred_217_font_454" rel="nofollow"><font color="red">第217题 存在重复元素</font></a></li><li><ul><li><a href="#_476" rel="nofollow">解题思路</a></li><li><a href="#_478" rel="nofollow">代码</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="font_colorred_1_font_2"></a><font color="red">第1题 两数之和</font></h2> 
<p><strong>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。<br> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br> 你可以按任意顺序返回答案。</strong></p> 
<p>示例 1：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>nums = [2,7,11,15], target = 9</td><td>[0,1]</td></tr></tbody></table> 
<p><font color="blue">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</font></p> 
<p>示例 2：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>nums = [3,2,4], target = 6</td><td>[1,2]</td></tr></tbody></table> 
<p>示例 3：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>nums = [3,3], target = 6</td><td>[0,1]</td></tr></tbody></table> 
<h3><a id="_26"></a>解题思路</h3> 
<p><font color="green">本题可使用哈希表和暴力解法，但由于暴力解法是使用嵌套遍历数组，时间复杂度达到了O(n*n)，故不提倡。<br> 使用哈希函数来求解此题，首先建立一个哈希表，然后从头开始遍历数组，当目标值减去当前遍历到的数在哈希表中不存在时，将该数插入到哈希表中，如果存在，则返回当前遍历数的索引以及哈希表中查到的值。</font></p> 
<h3><a id="_30"></a>代码</h3> 
<pre><code class="prism language-java"><span class="token comment">// 两数之和：哈希表解法</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Map<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token punctuation">&gt;</span></span> hashtable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立哈希表</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">//遍历数组</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>hashtable<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">//containsKey函数用于判断哈希表中是否存在该值</span>
                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span>hashtable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//如果存在，则返回该值对应的索引以及当前遍历到的数的索引</span>
            <span class="token punctuation">}</span>
            hashtable<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果不存在，则将该值存入哈希表的Key中，将索引下标存入Value中。用这种存储方式，便于使用get函数直接返回value-索引</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//遍历结束，仍未找到两数之和等于目标值，则返回空数组</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>时间复杂度为O(n),n为数组长度<br> 空间复杂度为O(n)</strong></p> 
<h2><a id="font_colorred_2_font_51"></a><font color="red">第2题 两数相加(中等题)</font></h2> 
<p><strong>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br> 请你将两个数相加，并以相同形式返回一个表示和的链表。<br> 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</strong></p> 
<p>示例 1：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>l1 = [2,4,3], l2 = [5,6,4]</td><td>[7,0,8]</td></tr></tbody></table> 
<p><font color="blue">解释：342 + 465 = 807</font></p> 
<p>示例 2：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>l1 = [0], l2 = [0]</td><td>[0]</td></tr></tbody></table> 
<p>示例 3：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</td><td>[8,9,9,9,0,0,0,1]</td></tr></tbody></table> 
<h3><a id="_75"></a>解题思路</h3> 
<p><font color="green">使用常规链表求解，由于输入的两个链表都是倒序存放，所以直接从第一位开始相加，设定一个进位值，在每一次相加时，都加上进位值，当两个链表都遍历相加之后，最后再判断进位是否为1，为1则在数组后加上1。</font></p> 
<h3><a id="_78"></a>代码</h3> 
<pre><code class="prism language-java"><span class="token comment">// 两数相加：链表解法</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        ListNode pre <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设定头指针为链表首部</span>
        ListNode cur <span class="token operator">=</span> pre<span class="token punctuation">;</span><span class="token comment">//设定当前指针</span>
        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//设置carry为进位</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">||</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//都不为空时，进行遍历</span>
            <span class="token keyword">int</span> x <span class="token operator">=</span> l1 <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> l1<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
            <span class="token keyword">int</span> y <span class="token operator">=</span> l2 <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">;</span><span class="token comment">//取l1、l2的值</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> carry<span class="token punctuation">;</span><span class="token comment">//求和</span>
            
            carry <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//进位</span>
            sum <span class="token operator">=</span> sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//加完之后取他的个位数</span>
            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将相加之后的值存入链表中</span>

            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token comment">//下一节点不为空时，访问下一个节点</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>carry <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2个链表遍历完成后，考虑是否有进位，有进位则在链表尾部加上新节点，并存入1</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token comment">//输出链表</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>时间复杂度为O(max(m,n)),m,n为两个链表的长度<br> 空间复杂度为O(1)</strong></p> 
<h2><a id="font_colorred_20_font_115"></a><font color="red">第20题 有效的括号</font></h2> 
<p><strong>给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串 s ，判断字符串是否有效。<br> 有效字符串需满足：</strong><br> <strong>1. 左括号必须用相同类型的右括号闭合<br> 2. 左括号必须以正确的顺序闭合</strong></p> 
<p>示例 1：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>s = “( )”</td><td>true</td></tr></tbody></table> 
<p>示例 2：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>s = “( ) [ ] { }”</td><td>true</td></tr></tbody></table> 
<p>示例 3：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>s = “( ]”</td><td>false</td></tr></tbody></table> 
<p>示例 4：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>s = “( [ ) ]”</td><td>false</td></tr></tbody></table> 
<p>示例 5：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>s = “{ [ ] }”</td><td>true</td></tr></tbody></table> 
<h3><a id="_149"></a>解题思路</h3> 
<p><font color="green">本题使用栈来求解，首先判断括号数量，为奇数则直接输出false。栈的形式是先进后出，后进先出，所以当要进入栈的元素与栈顶元素匹配时，令栈顶元素出栈，否则将该元素入栈。直到遍历完成后，如果栈内仍然存在元素则括号不匹配，输出false，如果栈内为空，则输出true。</font></p> 
<h3><a id="_151"></a>代码</h3> 
<pre><code class="prism language-java"><span class="token comment">// 有效的括号：哈希表加栈</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token comment">//判断括号为奇数还是偶数</span>
        Map<span class="token generics function"><span class="token punctuation">&lt;</span>Character<span class="token punctuation">,</span> Character<span class="token punctuation">&gt;</span></span> pairs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics function"><span class="token punctuation">&lt;</span>Character<span class="token punctuation">,</span> Character<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span>
            <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'}'</span><span class="token punctuation">,</span> <span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//使用哈希表存入相匹配的括号</span>
        Deque<span class="token generics function"><span class="token punctuation">&lt;</span>Character<span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics function"><span class="token punctuation">&lt;</span>Character<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立栈</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">char</span> ch <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//遍历字符串，取出字符串中的字符</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>pairs<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//判断输入的是左括号还是右括号，哈希表的Key都是右括号</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> pairs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//当栈为空或者栈顶元素与当前元素不匹配则输出flase</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果匹配则弹出栈顶元素</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果是左括号，则入栈</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最后返回栈是否为空，如果全部匹配，则栈为空，输出true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>时间复杂度为O(n),n为字符串s的长度<br> 空间复杂度为O(n+∣Σ∣)，其中Σ 表示字符集，本题中字符串只包含 6 种括号，∣Σ∣=6。栈中的字符数量为O(n)，而哈希表使用的空间为O(∣Σ∣)，相加即可得到总空间复杂度</strong></p> 
<h2><a id="font_colorred_21_font_184"></a><font color="red">第21题 合并两个有序链表</font></h2> 
<p><strong>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</strong></p> 
<p>示例 1：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>l1 = [1,2,4], l2 = [1,3,4]</td><td>[1,1,2,3,4,4]</td></tr></tbody></table> 
<p>示例 2：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>l1 = [], l2 = []</td><td>[]</td></tr></tbody></table> 
<p>示例 3：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>l1 = [], l2 = [0]</td><td>[0]</td></tr></tbody></table> 
<h3><a id="_203"></a>解题思路</h3> 
<p><font color="green">简单的链表遍历，同时对两个链表从头遍历，如果l1链表的节点值小，则将该值输出，并让l1指向当前节点的下一节点，l2链表不动，反之将l2链表的值输出，并让l2指向当前节点的下一节点。当一个链表访问结束后，则将另一个链表的剩下值输出，直到两个链表都遍历结束。</font></p> 
<h3><a id="_206"></a>代码</h3> 
<pre><code class="prism language-java"><span class="token comment">// 合并两个有序链表：链表解法</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
           <span class="token keyword">return</span> l2<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>l2 <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
           <span class="token keyword">return</span> l1<span class="token punctuation">;</span>
       <span class="token punctuation">}</span><span class="token comment">//l1或者l2中的一个链表为空时，直接将另一个链表加入</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
           l1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">return</span> l1<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>l2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span>l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">return</span> l2<span class="token punctuation">;</span>
       <span class="token punctuation">}</span><span class="token comment">//比值，将小的值输出，并让当前值较小的链表指向它的下一个节点，另一个节点保持不变</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>时间复杂度为O(m+n),m,n为两个链表的长度<br> 空间复杂度为O(m+n)</strong></p> 
<h2><a id="font_colorred_27_font_231"></a><font color="red">第27题 移除元素</font></h2> 
<p><strong>给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br> 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。<br> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</strong></p> 
<p>示例 1：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>nums = [3,2,2,3], val = 3</td><td>2, nums = [2,2]</td></tr></tbody></table> 
<p><font color="blue">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</font></p> 
<p>示例 2：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>nums = [0,1,2,2,3,0,4,2], val = 2</td><td>5, nums = [0,1,4,0,3]</td></tr></tbody></table> 
<p><font color="blue">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</font></p> 
<h3><a id="_250"></a>解题思路</h3> 
<p><font color="green">本题使用对撞双指针来求解，设一个左指针指向数组首部，设一个右指针指向数组尾部，首先访问左指针的值，如果该值等于目标值，则将该值与右指针指向的值交换，并让右指针左移一位，继续访问左指针，如果左指针指向的值不为目标值，则将左指针右移一位，否则，继续与右指针指向的值交换，直到左指针与右指针相等时，返回左指针，即为删除目标值后的数组。</font></p> 
<h3><a id="_252"></a>代码</h3> 
<pre><code class="prism language-java"><span class="token comment">// 移除元素：双指针</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//左指针指向数组首部</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token comment">//右指针指向数组尾部</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//当左指针小于右指针时</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//判断左指针的值是否为目标值</span>
                nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//如果是则交换左右指针的值</span>
                right<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//然后让右指针左移</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                left<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//否则让左指针右移</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token comment">//返回左指针</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>时间复杂度为O(n),n为数组的长度<br> 空间复杂度为O(1)</strong></p> 
<h2><a id="font_colorred_35_font_273"></a><font color="red">第35题 搜索插入位置</font></h2> 
<p><strong>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br> 你可以假设数组中无重复元素。</strong></p> 
<p>示例 1:</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>[1,3,5,6], 5</td><td>2</td></tr></tbody></table> 
<p>示例 2:</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>[1,3,5,6], 2</td><td>1</td></tr></tbody></table> 
<p>示例 3:</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>[1,3,5,6], 7</td><td>4</td></tr></tbody></table> 
<p>示例 4:</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>[1,3,5,6], 0</td><td>0</td></tr></tbody></table> 
<h3><a id="_296"></a>解题思路</h3> 
<p><font color="green">使用二分查找法求解，设一个l为0，设一个r为数组长度-1，令m为两者的中间数，令输出值为数组长度，如果目标值小于等于数组下标为m的值，则将结果设置为该值，然后令i为中间值+1，否则令j为中间值-1，直到目标值i大于j时，输出中间值即为结果</font></p> 
<h3><a id="_299"></a>代码</h3> 
<pre><code class="prism language-java"><span class="token comment">// 搜索插入位置：二分查找</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token comment">//left为数组首，rigth为数组尾，先令输出结果为数组长度</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//循环条件左小于等于右</span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> left<span class="token punctuation">;</span><span class="token comment">//这里的&gt;&gt;1指right减去left得到的值的二进制向右移一位，等同于除2</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                ans <span class="token operator">=</span> mid<span class="token punctuation">;</span>
                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//目标值小于等于中间值时，让输出结果等于中间值，并令右指向中间值的前一位</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//否则令左指向中间值的后一位</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>时间复杂度为O(log n),二分法的时间复杂度为log n<br> 空间复杂度为O(1)</strong></p> 
<h2><a id="font_colorred_53_font_323"></a><font color="red">第53题 最大子序和</font></h2> 
<p><strong>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</strong><br> 示例 1：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>[nums = [-2,1,-3,4,-1,2,1,-5,4]</td><td>6</td></tr></tbody></table> 
<p><font color="blue">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</font></p> 
<p>示例 2：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>nums = [1]</td><td>1</td></tr></tbody></table> 
<p>示例 3：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>nums = [0]</td><td>0</td></tr></tbody></table> 
<p>示例 4：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>nums = [-1]</td><td>-1</td></tr></tbody></table> 
<p>示例 5：</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>nums = [-100000]</td><td>-100000</td></tr></tbody></table> 
<h3><a id="_351"></a>解题思路</h3> 
<p><font color="green">本题使用动态规划来求解，遍历数组发现，假设以f(i)表示以i为下标结尾的连续子数组的最大和，则f(i)与f(i-1)有关，因为f(i)的最大值等于f(i-1)加上nums[i]与nums[i]之间的最大值。由此使用动态规划遍历数组存储最大值来求解。</font></p> 
<h3><a id="_353"></a>代码</h3> 
<pre><code class="prism language-java"><span class="token comment">// 最大子序和：动态规划</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> maxAns <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            pre <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>pre <span class="token operator">+</span> x<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//比较前一个的最大值加上遍历到的数与遍历到的数，将大的那个存入pre中</span>
            maxAns <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxAns<span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//maxAns更新最大值</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> maxAns<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>时间复杂度为O(n),n为数组的长度<br> 空间复杂度为O(1)</strong></p> 
<h2><a id="font_colorred_67_font_369"></a><font color="red">第67题 二进制求和</font></h2> 
<p><strong>给你两个二进制字符串，返回它们的和（用二进制表示）。<br> 输入为非空字符串且只包含数字 1 和 0。</strong></p> 
<p>示例 1:</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>a = “11”，b = “1”</td><td>“100”</td></tr></tbody></table> 
<p>示例 2:</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>a = “1010”, b = “1011”</td><td>“10101”</td></tr></tbody></table> 
<h3><a id="_385"></a>解题思路</h3> 
<p><font color="green">使用简单的数学方法，创建一个新的字符串ans，设置一个进位数carry，同时遍历字符串a和b，然后相加，直到全部遍历结束，如果遍历结束后，进位数不为0，则在数组尾部加上进位数，然后输出反转字符串。</font></p> 
<h3><a id="_388"></a>代码</h3> 
<pre><code class="prism language-java"><span class="token comment">// 二进制求和：数学</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> String <span class="token function">addBinary</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        StringBuffer ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立新的字符串</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//设立n为字符串a和b的最大长度</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            carry <span class="token operator">+=</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//如果字符串没有遍历结束，则从字符串后面开始输入</span>
            carry <span class="token operator">+=</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//同理字符串a</span>
            ans<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>carry <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//因为是二进制，所以输出结果为相加后的结果对2取余</span>
            carry <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//得到进位数</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>carry <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//遍历结束后，进位数不为0，则追加进位数在字符串末尾</span>
            ans<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        ans<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//字符串反转</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出字符串类型的结果</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>时间复杂度为O(max{|a|,|b|}),a,b分别为两个字符串的长度<br> 空间复杂度为O(1)</strong></p> 
<h2><a id="font_colorred_69_Xfont_413"></a><font color="red">第69题 X的平方根</font></h2> 
<p><strong>实现 int sqrt(int x) 函数。<br> 计算并返回 x 的平方根，其中 x 是非负整数。<br> 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</strong></p> 
<p>示例 1:</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>4</td><td>2</td></tr></tbody></table> 
<p>示例 2:</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>8</td><td>2</td></tr></tbody></table> 
<p><font color="blue">说明: 8 的平方根是 2.82842…,<br> 由于返回类型是整数，小数部分将被舍去。</font></p> 
<h3><a id="_430"></a>解题思路</h3> 
<p><font color="green">使用二分法求解，设l为0，r为目标值，则中间值mid为l+(r+l)/2,判断中间值的平方是否小于等于目标值，如果是，则令输出结果为mid，令左边界l为mid+1，否则令有边界r为mid-1，直到l&gt;r，查找结束。</font></p> 
<h3><a id="_432"></a>代码</h3> 
<pre><code class="prism language-java"><span class="token comment">// X的平方根：二分法</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> x<span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//循环条件</span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//中间值</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> mid <span class="token operator">*</span> mid <span class="token operator">&lt;=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//查找返回值</span>
                ans <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token comment">//中间值的平方比x小，则平方根一定大于等于中间值</span>
                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//令左边界l为中间值加1，重新使用二分法查找</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//如果中间值的平方比x大，则平方根一定小于中间值，令有边界r为中间值-1</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token comment">//最后返回得到的值</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>时间复杂度为O(log x),x为数的大小，二分查找的时间复杂度都为log n<br> 空间复杂度为O(1)</strong></p> 
<h2><a id="font_colorred_217_font_454"></a><font color="red">第217题 存在重复元素</font></h2> 
<p><strong>给定一个整数数组，判断是否存在重复元素。<br> 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</strong></p> 
<p>示例 1:</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>[1,2,3,1]</td><td>true</td></tr></tbody></table> 
<p>示例 2:</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>[1,2,3,4]</td><td>false</td></tr></tbody></table> 
<p>示例 3:</p> 
<table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>[1,1,1,3,3,4,3,2,4,2]</td><td>true</td></tr></tbody></table> 
<h3><a id="_476"></a>解题思路</h3> 
<p><font color="green">本题可使用哈希集合-Set来求解，Set的一个用法就是相同元素只能存放一次，因此使用Set可以判断是否存入了重复元素。</font></p> 
<h3><a id="_478"></a>代码</h3> 
<pre><code class="prism language-java"><span class="token comment">// 存在重复元素：哈希集合Set解法</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsDuplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Set<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立哈希集合</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//遍历数组的一种方法</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//add函数插入x，在set前加入！用于判断插入元素是否存在，如果存在，则执行if语句中的表达式</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//如果遍历结束，没有重复元素，则返回false</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>时间复杂度为O(n),n为数组长度<br> 空间复杂度为O(n)</strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b27b500c2d3129a8d3de2fa1ce52f7d6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机网络体系划分,网络的体系结构及其划分所遵循的原则</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/109672d8be350b894f460773aee14365/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">从网络访问此计算机 注册表位置,网络访问 远程访问注册表路径和子 (Windows 10)  - Windows security | Microsoft Docs...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>