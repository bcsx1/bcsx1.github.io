<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>elasticsearch一些重要的配置参数 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="elasticsearch一些重要的配置参数" />
<meta property="og:description" content="先看一下官网给我们提供的全部的参数配置项 官网地址 官方文档链接：注意版本是8.1Configuring Elasticsearch | Elasticsearch Guide [8.1] | Elastic​编辑https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html
重要（基本）参数 Important Elasticsearch configuration
关于分片和路由的配置 Cluster-level shard allocation and routing settings
分片的配置，用于集群重启时候的分片恢复、副本分配问题、分片平衡问题、以及删除节点的时候触发生效。
master节点负责分片分配的相关问题：包括了分片去哪个节点，以及节点之间的分片平衡（当一个节点上的数据过多，与其它节点分配不均匀的时候，master节点负责重新平衡）。
分片分配相关参数 参数：cluster.routing.allocation.enable
cluster.routing.allocation.enable
用来限制不同的分片能否在某个节点上分配：
all- （默认）允许分配所有类型的分片。
primaries- 只允许分配主分片。
new_primaries- 仅允许新索引的主分片分配。
none- 不允许对任何索引进行任何类型的分片分配。该设置不影响重启节点时本地主分片的恢复。具有未分配主分片副本的重新启动节点将立即恢复该主分片，假设其分配 id 与集群状态中的活动分配 id 之一匹配。
这里的优化点，我们可以靠谱的机器分配主分片。可能有问题的机器，可以限制主分片的分配。
cluster.routing.allocation.node_concurrent_incoming_recoveries
副本在当前节点分配的并发数。比方说，你的索引只有主分片，没有副本。你想要添加副本，则你就要在别的机器上去分配副本。
默认值为：2
增大该配置，可以提升添加副本的速度。但是它意味着花费更多的资源。假如你不考虑集群当前服务能力，就想快速添加副本，则可以增大该配置。具体的可以增加到多大。需要做压力测试。根据不同的机器资源，有不同的效果。
cluster.routing.allocation.node_concurrent_outgoing_recoveries
最大允许同时多少个分片去别的机器上恢复。
默认值为：2
增大该配置，可以提升添加副本的速度。但是它意味着花费更多的资源。假如你不考虑集群当前服务能力，就想快速添加副本，则可以增大该配置。具体的可以增加到多大。需要做压力测试。根据不同的机器资源，有不同的效果。
cluster.routing.allocation.node_concurrent_recoveries
该参数合并了cluster.routing.allocation.node_concurrent_incoming_recoveries 和cluster.routing.allocation.node_concurrent_outgoing_recoveries这两个参数。意思是只配置当前这个参数，以上两个参数都会生效。
cluster.routing.allocation.node_initial_primaries_recoveries
当节点重启后，或者说集群重启后，主分片恢复的并发数。假如一个节点上有20个主分片。那么，如果默认4个并发，则需要分五次，才能把这个主分片全部恢复起来。或者说同时只能有四个主分片一起恢复。
默认值为：4
这个参数可以用来提升集群故障重启后的集群恢复速度。我们可以适当增大它。能够增大多少，也是需要具体的压力测试。根据机器资源不同，可增大就不同。
目前我认为这个参数是和CPU能力挂钩的。
另外我认为：集群恢复，我能可以调大它。不用考虑此时集群服务能力。说白了，主分片如果都没回复全，肯定对外提供查询，它是有问题的。
注意一点，所谓的参数调优，每个参数都不是孤立的，它要和其它参数一起配合来使用。
cluster.routing.allocation.same_shard.host
这个参数只会在一台物理机器上多个节点的时候才会有用。
默认配置：false
cluster.routing.allocation.same_shard.host: true 禁止把副本分配到同一台物理机器上（相同ip地址认为是同一台机器）
cluster.routing.allocation.same_shard.host: false 可以把副本分配到同一台物理机器上。如果一台物理机器只有一个节点，默认为false也没什么问题，因为副本不会分配到同一个机器上。但是一台机器上有多个节点，就失去数据容灾的能力了，也不能将请求均分到其它机器上去。
分片平衡配置 分片平衡问题，对于es集群来说，它其实是希望数据能按大小均匀分不到不同的节点上的。当发生数据倾斜的时候，集群会有一个自动的平衡机制，帮你把分片挪到别的节点上。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/93ac9b8cb10e2971cf8840605b01cab3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-08T17:25:15+08:00" />
<meta property="article:modified_time" content="2023-11-08T17:25:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">elasticsearch一些重要的配置参数</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>先看一下官网给我们提供的全部的参数配置项</h2> 
<h3>官网地址</h3> 
<p><strong>官方文档链接</strong>：注意版本是8.1<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html" rel="nofollow" title="Configuring Elasticsearch | Elasticsearch Guide [8.1] | Elastic​编辑https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html">Configuring Elasticsearch | Elasticsearch Guide [8.1] | Elastic​编辑https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html</a></p> 
<p><img alt="img" src="https://images2.imgbox.com/6d/47/rFERJb6i_o.png"><img alt="" height="1" src="https://images2.imgbox.com/89/e2/NnVl5yeD_o.png" width="1"><img alt="img" src="https://images2.imgbox.com/db/2b/tmktE8bN_o.png"><img alt="" height="1" src="https://images2.imgbox.com/be/61/YuXmHuww_o.png" width="1"></p> 
<h3>重要（基本）参数</h3> 
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html" rel="nofollow" title="Important Elasticsearch configuration">Important Elasticsearch configuration</a></p> 
<p></p> 
<h3>关于分片和路由的配置</h3> 
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-cluster.html" rel="nofollow" title="Cluster-level shard allocation and routing settings">Cluster-level shard allocation and routing settings</a></p> 
<p>分片的配置，用于集群重启时候的分片恢复、副本分配问题、分片平衡问题、以及删除节点的时候触发生效。</p> 
<p>master节点负责分片分配的相关问题：包括了分片去哪个节点，以及节点之间的分片平衡（当一个节点上的数据过多，与其它节点分配不均匀的时候，master节点负责重新平衡）。</p> 
<p></p> 
<h4>分片分配相关参数</h4> 
<p>参数：<strong>cluster.routing.allocation.enable</strong></p> 
<ul><li> <p><strong><code>cluster.routing.allocation.enable</code></strong></p> <p>用来限制不同的分片能否在某个节点上分配：</p> <p><code>all</code>- （<strong>默认</strong>）允许分配所有类型的分片。</p> <p><code>primaries</code>- 只允许分配主分片。</p> <p><code>new_primaries</code>- 仅允许新索引的主分片分配。</p> <p><code>none</code>- 不允许对任何索引进行任何类型的分片分配。该设置不影响重启节点时本地主分片的恢复。具有未分配主分片副本的重新启动节点将立即恢复该主分片，假设其分配 id 与集群状态中的活动分配 id 之一匹配。</p> 
  <blockquote> 
   <p>这里的优化点，我们可以靠谱的机器分配主分片。可能有问题的机器，可以限制主分片的分配。</p> 
  </blockquote> </li><li> <p><strong><code>cluster.routing.allocation.node_concurrent_incoming_recoveries</code></strong></p> <p>副本在当前节点分配的并发数。比方说，你的索引只有主分片，没有副本。你想要添加副本，则你就要在别的机器上去分配副本。</p> <p>默认值为：2</p> 
  <blockquote> 
   <p>增大该配置，可以提升添加副本的速度。但是它意味着花费更多的资源。假如你不考虑集群当前服务能力，就想快速添加副本，则可以增大该配置。具体的可以增加到多大。需要做压力测试。根据不同的机器资源，有不同的效果。</p> 
  </blockquote> </li><li> <p><strong><code>cluster.routing.allocation.node_concurrent_outgoing_recoveries</code></strong></p> <p>最大允许同时多少个分片去别的机器上恢复。</p> <p>默认值为：2</p> 
  <blockquote> 
   <p>增大该配置，可以提升添加副本的速度。但是它意味着花费更多的资源。假如你不考虑集群当前服务能力，就想快速添加副本，则可以增大该配置。具体的可以增加到多大。需要做压力测试。根据不同的机器资源，有不同的效果。</p> 
  </blockquote> </li><li> <p><strong><code>cluster.routing.allocation.node_concurrent_recoveries</code></strong></p> <p>该参数合并了<code>cluster.routing.allocation.node_concurrent_incoming_recoveries</code> 和<code>cluster.routing.allocation.node_concurrent_outgoing_recoveries</code>这两个参数。意思是只配置当前这个参数，以上两个参数都会生效。</p> </li><li> <p><strong><code>cluster.routing.allocation.node_initial_primaries_recoveries</code></strong></p> <p>当节点重启后，或者说集群重启后，主分片恢复的并发数。假如一个节点上有20个主分片。那么，如果默认4个并发，则需要分五次，才能把这个主分片全部恢复起来。或者说同时只能有四个主分片一起恢复。</p> <p>默认值为：4</p> 
  <blockquote> 
   <p>这个参数可以用来提升集群故障重启后的集群恢复速度。我们可以适当增大它。能够增大多少，也是需要具体的压力测试。根据机器资源不同，可增大就不同。</p> 
   <p>目前我认为这个参数是和CPU能力挂钩的。</p> 
   <p>另外我认为：集群恢复，我能可以调大它。不用考虑此时集群服务能力。说白了，主分片如果都没回复全，肯定对外提供查询，它是有问题的。</p> 
   <p>注意一点，所谓的参数调优，每个参数都不是孤立的，它要和其它参数一起配合来使用。</p> 
  </blockquote> </li></ul> 
<p></p> 
<ul><li> <p><strong><code>cluster.routing.allocation.same_shard.host</code></strong></p> <p>这个参数只会在一台物理机器上多个节点的时候才会有用。</p> <p>默认配置：false</p> <p><strong><code>cluster.routing.allocation.same_shard.host</code></strong>: true 禁止把副本分配到同一台物理机器上（相同ip地址认为是同一台机器）</p> <p><strong><code>cluster.routing.allocation.same_shard.host</code></strong>: false 可以把副本分配到同一台物理机器上。如果一台物理机器只有一个节点，默认为false也没什么问题，因为副本不会分配到同一个机器上。但是一台机器上有多个节点，就失去数据容灾的能力了，也不能将请求均分到其它机器上去。</p> </li></ul> 
<p></p> 
<h4>分片平衡配置</h4> 
<p>分片平衡问题，对于es集群来说，它其实是希望数据能按大小均匀分不到不同的节点上的。当发生数据倾斜的时候，集群会有一个自动的平衡机制，帮你把分片挪到别的节点上。</p> 
<blockquote> 
 <p>这里有一个点，就是我们在组建集群的时候，最好能够将每台机器，或者说每个节点，能用的磁盘空间对齐。避免节外生枝。</p> 
</blockquote> 
<p><strong><code>cluster.routing.rebalance.enable</code></strong></p> 
<p>设置哪些分片能够重新平衡：</p> 
<ul><li> <p><code>all</code>- （默认）允许对所有类型的分片进行分片平衡。</p> </li><li> <p><code>primaries</code>- 仅允许对主分片进行分片平衡。</p> </li><li> <p><code>replicas</code>- 仅允许对副本分片进行分片平衡。</p> </li><li> <p><code>none</code>- 任何索引都不允许任何类型的分片平衡。</p> </li></ul> 
<p><strong><code>cluster.routing.allocation.allow_rebalance</code></strong></p> 
<p>指定何时允许分片重新平衡：</p> 
<ul><li> <p><code>always</code>- 始终允许重新平衡。</p> </li><li> <p><code>indices_primaries_active</code>- 仅当分配了集群中的所有主节点时。</p> </li><li> <p><code>indices_all_active</code>- （默认）仅当集群中的所有分片（主分片和副本）都已分配时。这个阶段显然是最安全的。不要掺和太多事，等集群稳定的时候去平衡。</p> </li></ul> 
<p><strong><code>cluster.routing.allocation.cluster_concurrent_rebalance</code></strong></p> 
<p>设置集群中，执行分片重新平衡的并发数。默认值为2的情况下，一个集群中最多能有2个分片同时去执行重新平衡。</p> 
<p>默认值：2</p> 
<p></p> 
<h4>分片平衡规则设置</h4> 
<p>上边只提到了。集群会自动平衡节点中的分片。那策策略是什么呢？或者说规则是什么呢？</p> 
<p><strong><code>cluster.routing.allocation.balance.shard</code></strong></p> 
<p>（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#dynamic-cluster-setting" rel="nofollow" title="动态">动态</a>）定义节点上分配的分片总数的权重因子（浮点数）。默认为<code>0.45f</code>. 提高这一点会增加集群中所有节点上的分片数量相等的趋势。</p> 
<blockquote> 
 <p>从这里我们可以知道，es只能保证分片数量平衡。</p> 
 <p>那么再提出来一个问题：假如分片的大小并不平衡呢？</p> 
</blockquote> 
<p><strong><code>cluster.routing.allocation.balance.index</code></strong></p> 
<p>（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#dynamic-cluster-setting" rel="nofollow" title="动态">动态</a>）定义分配在特定节点（浮点数）上的每个索引的分片数的权重因子。默认为<code>0.55f</code>. 提高这一点会增加集群中所有节点上每个索引的分片数量相等的趋势。</p> 
<p><strong><code>cluster.routing.allocation.balance.threshold</code></strong></p> 
<p>（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#dynamic-cluster-setting" rel="nofollow" title="动态">动态</a>）应该执行的操作的最小优化值（非负浮点）。默认为<code>1.0f</code>. 提高此值将导致集群在优化分片平衡方面不那么积极。</p> 
<p></p> 
<h3>与磁盘相关的分片设置</h3> 
<p>关于磁盘的保护。我们很容易就可以理解，我们的磁盘总不能写满吧？es集群给我们增加了这个控制。特地设置了三个水位线，一个最低水位线，一个控制水位线，一个最高水位线。看下图三条线。这个水位线是说磁盘使用量占比。</p> 
<p><img alt="" height="373" src="https://images2.imgbox.com/6f/ab/1D5Xxtza_o.png" width="946"></p> 
<p>当磁盘空间倾斜的时候，es需要自动调整。假如我们物理节点的磁盘大小不一致。节点A分配1T磁盘，节点B分配10T磁盘，如果同样是每个上边分配相同的分片。同样都写入数据，显然A节点先到达最低水位线。</p> 
<p>所以磁盘有一个限制。当写入磁盘到达橙色低水位线的时候，副本将无法再在这个节点上分配。</p> 
<p>当到达控制水位线，就会进入一个挪分片阶段。这个阶段会把分片挪到别的节点上去，以达到磁盘平衡的目的。</p> 
<p>当所有的节点都达到了控制水位线的时候，就不能再挪分片了，分片也没有地方去了。此时还能继续写入数据，当写入直到最高水位线的时候，不行了，集群不再接受写入请求了！此时能读，能删除。</p> 
<blockquote> 
 <p>这里有一个集群规划-磁盘规划方面的优化点。</p> 
 <p>我们知道这个挪分片的过程，数据不会自己从一个磁盘飞到另外的磁盘。它是要花资源的，占用CPU，占用磁盘IO，占用网络IO。</p> 
 <p>所以我们要尽可能的分配均匀的磁盘给每个节点。尽可能的避免这个挪的过程，从而避免资源占用。</p> 
 <p>另外如何磁盘大小不一样。我们通过上边的参数知道，它是按比例来算的。也就是有可能在极端情况下：假如三个节点，磁盘分别是 1T，10T，10T。假如数据都装85%，这意味着，一次搜索，一个节点处理850G数据，另外两个节点每个处理8.5T。这相当于只有两个节点在工作。从而失去了集群的意义。</p> 
</blockquote> 
<p></p> 
<p>可以使用以下设置来控制基于磁盘的分配：</p> 
<p><strong><code>cluster.routing.allocation.disk.threshold_enabled</code></strong></p> 
<p>（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#dynamic-cluster-setting" rel="nofollow" title="动态">动态</a>）默认为<code>true</code>。设置为<code>false</code>禁用磁盘分配决定器。</p> 
<p><strong><code>cluster.routing.allocation.disk.watermark.low</code> </strong></p> 
<p>（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#dynamic-cluster-setting" rel="nofollow" title="动态">动态</a>）控制磁盘使用的<strong>低水位线</strong>。默认为<code>85%</code>，这意味着 Elasticsearch 不会将分片分配给磁盘使用率超过 85% 的节点。它也可以设置为绝对字节值（如<code>500mb</code>），以防止 Elasticsearch 在可用空间少于指定数量时分配分片。此设置对新创建索引的主分片没有影响，但会阻止分配它们的副本。</p> 
<p><strong><code>cluster.routing.allocation.disk.watermark.high</code> </strong></p> 
<p>（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#dynamic-cluster-setting" rel="nofollow" title="动态">动态</a>）控制水位线。它默认为<code>90%</code>，这意味着 Elasticsearch 将尝试将分片从磁盘使用率高于 <strong>90%</strong> 的节点，开始挪分片去其他节点。</p> 
<p><strong><code>cluster.routing.allocation.disk.watermark.flood_stage</code></strong></p> 
<p>（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#dynamic-cluster-setting" rel="nofollow" title="动态">动态</a>）高水位线，默认为 <strong>95%</strong>。<code>index.blocks.read_only_allow_delete</code>Elasticsearch对在节点上分配了一个或多个分片并且至少有一个磁盘超过洪水阶段的每个索引强制执行只读索引块 ( )。此设置是防止节点耗尽磁盘空间的最后手段。当磁盘利用率低于高水位线时，索引块会自动释放。</p> 
<blockquote> 
 <p>注意以上配置需要对齐，要么都用百分比，要么都指定具体大小。</p> 
</blockquote> 
<p><strong><code>cluster.info.update.interval</code></strong></p> 
<p>（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#dynamic-cluster-setting" rel="nofollow" title="动态">动态</a>）Elasticsearch 应该多久检查一次集群中每个节点的磁盘使用情况。默认为<code>30s</code>.</p> 
<blockquote> 
 <p>以下两个参数没看懂：等看懂了再来补。</p> 
 <p><strong><code>cluster.routing.allocation.disk.watermark.flood_stage.frozen</code></strong></p> 
 <p>(<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#dynamic-cluster-setting" rel="nofollow" title="Dynamic">Dynamic</a>) Controls the flood stage watermark for dedicated frozen nodes, which defaults to 95%.</p> 
 <p><strong><code>cluster.routing.allocation.disk.watermark.flood_stage.frozen.max_headroom</code> </strong></p> 
 <p>(<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#dynamic-cluster-setting" rel="nofollow" title="Dynamic">Dynamic</a>) Controls the max headroom for the flood stage watermark for dedicated frozen nodes. Defaults to 20GB when <code>cluster.routing.allocation.disk.watermark.flood_stage.frozen</code> is not explicitly set. This caps the amount of free space required on dedicated frozen nodes.</p> 
</blockquote> 
<p></p> 
<h3>search相关设置</h3> 
<h4>限制搜索条件包含的搜索子句</h4> 
<p>参数： <strong>indices.query.bool.max_clause_count</strong></p> 
<p>默认值：4096</p> 
<blockquote> 
 <p>这个默认配置是偏大的。这个我们可以调小。用来对集群的保护。</p> 
</blockquote> 
<p></p> 
<h4>聚类结果数（桶的个数，例如你去 agg terms，获取聚类结果）</h4> 
<p>参数： <strong>search.max_buckets</strong></p> 
<p>默认是：65536</p> 
<blockquote> 
 <p>这里建议聚类结果，不要一下子返回，通常情况，可以利用 compsit滚动导出聚类结果。</p> 
 <p>这个不难理解，比方说你一共有100亿数据，让你一下子从集群中拿出20亿。这也不现实，集群做不到这件事，肯定要滚动利用游标的方式导出。</p> 
</blockquote> 
<p></p> 
<h4>嵌套查询的层数</h4> 
<p>就是嵌套查询最多有几层</p> 
<p>参数： <strong>indices.query.bool.max_nested_depth</strong></p> 
<p>默认值：20</p> 
<p></p> 
<h3>index相关配置</h3> 
<h4>是否允许自动创建索引</h4> 
<p>参数： <strong>action.auto_create_index</strong></p> 
<p>默认值：true</p> 
<p></p> 
<h4>删除索引是否要指定索引名称</h4> 
<p>参数： <strong>action.destructive_requires_name</strong></p> 
<p>默认值：false，如果设置为true，则不能通过通配符来删除索引。</p> 
<p></p> 
<h4>是否允许关闭索引</h4> 
<p>参数： <strong>cluster.indices.close.enable</strong></p> 
<p>默认值：true。如果设置为false，则不能关闭索引。</p> 
<blockquote> 
 <p>关闭索引，会释放内存空间，但是不会释放磁盘空间。</p> 
</blockquote> 
<p></p> 
<h4>跨集群数据同步白名单</h4> 
<p>由 ip：port字符串数组组成</p> 
<p>参数： <strong>reindex.remote.whitelist</strong></p> 
<p>例如： <strong>reindex.remote.whitelist</strong> ： ["10.10.10.10:9200", "10.10.10.11.9200:*"]</p> 
<p></p> 
<h4>是否启用内置索引和组件模板</h4> 
<p>参数：<strong>stack.templates.enabled</strong></p> 
<p>默认为<code>true</code>,如果为false，则es不会自动为你创建以下这些索引。</p> 
<p>此设置影响以下内置索引模板：</p> 
<ul><li> <p><code>logs-*-*</code></p> </li><li> <p><code>metrics-*-*</code></p> </li><li> <p><code>synthetics-*-*</code></p> </li></ul> 
<p>此设置还会影响以下内置组件模板：</p> 
<ul><li> <p><code>logs-mappings</code></p> </li><li> <p><code>logs-settings</code></p> </li><li> <p><code>metrics-mappings</code></p> </li><li> <p><code>metrics-settings</code></p> </li><li> <p><code>synthetics-mapping</code></p> </li><li> <p><code>synthetics-settings</code></p> </li></ul> 
<p></p> 
<p></p> 
<h3>控制集群是否能写入数据</h3> 
<p>控制集群只读： <strong>cluster.blocks.read_only</strong></p> 
<p>控制集群可读可以删除： <strong>cluster.blocks.read_only_allow_delete</strong></p> 
<p></p> 
<h3>集群分片数设置</h3> 
<p>限制单个节点最大的分片数：<strong>cluster.max_shards_per_node</strong></p> 
<p>默认值：1000</p> 
<p>所以集群的总的主分片和副本分片总数为 <strong>cluster.max_shards_per_node</strong> * 数据节点的个数</p> 
<p>如果索引被关闭，则其分片数不计数。</p> 
<blockquote> 
 <p>这个很多人给的建议是：每1G堆内存，对应20个分片。假如你给堆分配30G堆内存，则该节点分片数最好不要超过600个。这个默认是每个节点1000个，调优的时候通常是降低这个默认值，而不是增大它。</p> 
</blockquote> 
<p></p> 
<p>限制单个节点上存在冻结的分片： <strong>cluster.max_shards_per_node.frozen</strong></p> 
<p>向理解以下什么冻结的分片，换句话说，就是关闭的分片。比如一个，索引有十个分片，一共两个节点，假如每个节点5个分片，将索引close掉，那么这5个分片就算是冻结分片。如果还不懂，看下边这篇文章。</p> 
<p>关于什么是冻结索引？</p> 
<p><a href="https://blog.51cto.com/noregrets/3048995" rel="nofollow" title="ES冻结索引_51CTO博客_es冻结索引 占多少内存">ES冻结索引_51CTO博客_es冻结索引 占多少内存</a></p> 
<p></p> 
<h3>Field data cache 设置</h3> 
<p>参数： <strong>indices.fielddata.cache.size</strong></p> 
<p>取值：可以是百分比，例如： 20% 。也可以制定是 5GB。</p> 
<p>注意熔断器中也有参数限制Field data cache 的大小。并且默认值是 40%。所以如何设置这个参数的时候要比40%小。</p> 
<p>关于Field data cache，请看下边的这篇文章：</p> 
<p><a href="https://blog.csdn.net/star1210644725/article/details/123785245?spm=1001.2014.3001.5502" title="elasticsearch中 fieldData_elasticsearch fielddata_水的精神的博客-CSDN博客">elasticsearch中 fieldData_elasticsearch fielddata_水的精神的博客-CSDN博客</a></p> 
<blockquote> 
 <p>永远不要尝试打开它。它是性能的杀手。我们不要对text类型的字段排序，聚类！如果真的需要，就同时给它设置一个keyword类型，利用doc values，而不是构造Field data！</p> 
</blockquote> 
<p></p> 
<h3>index buffer cache</h3> 
<p>用作写缓存。分配的是堆空间。</p> 
<p><strong><code>indices.memory.index_buffer_size</code></strong></p> 
<p>接受百分比或字节大小值。它默认为<code>10%</code>，这意味着<code>10%</code>分配给节点的总堆将用作所有分片共享的索引缓冲区大小。</p> 
<p><strong><code>indices.memory.min_index_buffer_size</code></strong></p> 
<p>如果<code>index_buffer_size</code>指定为百分比，则此设置可用于指定绝对最小值。默认为<code>48mb</code>.</p> 
<p><strong><code>indices.memory.max_index_buffer_size</code></strong></p> 
<p>如果<code>index_buffer_size</code>指定为百分比，则此设置可用于指定绝对最大值。默认为无界。</p> 
<p></p> 
<h3>Node query cache</h3> 
<p>节点级别的缓存。</p> 
<p>es节点可以缓存查询的结果。</p> 
<p>参数： <strong>index.queries.cache.enabled</strong> 是否开启节点请求结果缓存。</p> 
<p>默认值：true。代表节点默认是会缓存查询数据的。</p> 
<p>默认情况下，缓存最多可容纳 10000 个查询 。段合并会导致缓存失效！</p> 
<p>参数： <strong>indices.queries.cache.size</strong> 节点分配个查询缓存的堆大小。</p> 
<p>默认值：10%。 也就是说有百分之十的堆空间，用于节点的请求缓存。</p> 
<p>它是LRU的策略来进行替换的。但是不会被GC回收掉！</p> 
<p></p> 
<h3>Shard requests cache</h3> 
<p>分片级别的缓存。</p> 
<p>通常情况下缓存 查询结果为0的数据。例如： <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html" rel="nofollow" title="aggregations">aggregations</a>, and<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html" rel="nofollow" title="suggestions">suggestions</a>.</p> 
<p>为了保证搜索的实时性和搜索结果的最终一致性。分片级别的缓存，会在执行 refreshe 的时候失效。</p> 
<blockquote> 
 <p>所以说，分片级别的缓存生效的时间，取决于 refreshe的时间间隔。缓存和实时性，是不可兼得的一件事请！</p> 
</blockquote> 
<p></p> 
<p>参数：<strong>index.requests.cache.enable</strong> 是否开启分片级别的缓存。</p> 
<p>默认值：true。开启</p> 
<p>另外我们可以在一次请求的时候指定是否缓存本次结果在分片上。</p> 
<pre>GET /my-index-000001/_search?request_cache=true
{
  "size": 0,
  "aggs": {
    "popular_colors": {
      "terms": {
        "field": "colors"
      }
    }
  }
}
​</pre> 
<pre>​</pre> 
<p>参数：<strong>indices.requests.cache.size</strong> 分片缓存占用堆内存的大小</p> 
<p>默认值：1%</p> 
<p></p> 
<h3>快照与恢复配置</h3> 
<p>快照操作的最大并发数。操作包括快照创建，删除和复制。</p> 
<p>参数： <strong>snapshot.max_concurrent_operations</strong></p> 
<p>默认值：1000</p> 
<h4>快照生命周期管理配置</h4> 
<p>是否把记录快照历史操作</p> 
<p>参数： <strong>slm.history_index_enabled</strong></p> 
<p>默认值：true</p> 
<p></p> 
<p>快照的执行周期</p> 
<p>参数： <strong>slm.retention_schedule</strong></p> 
<p>可以是 cron表达式： 0 30 1 * * ?</p> 
<p></p> 
<p>多长时间删除快照</p> 
<p>参数： <strong>slm.retention_duration</strong></p> 
<p>默认值：1小时</p> 
<p></p> 
<p>允许用来快照恢复的url</p> 
<p>参数：<strong>repositories.url.allowed_urls</strong></p> 
<p></p> 
<h3>线程池相关设置</h3> 
<p>通常情况下，我们对es集群下发的命令，例如search、index、agg、suggest，段合并，等等。都交由不同的线程池来完成执行。这个其实不难理解，线程是任务调度的最小单元。对es来说也是。</p> 
<blockquote> 
 <p>先来聊一聊物理机器的CPU</p> 
 <p>一个物理节点对应一个es节点，是理想情况。es会自动检测CPU的个数，这并不难。但是如果一台机器有多个节点，就有问题了。因为es没有那么智能，它会傻傻的以为，当前的CPU都是给自己一个节点用的。这种情况下，会很大程度上降低es的性能。</p> 
 <p>假如一台机器上有多个节点，请告诉node，它该分几个核心！</p> 
</blockquote> 
<p>以下参数可以设置CPU核心数。假如一台机器，总的核心数是32，假如你的机器上分配了两个节点，你可以设置为16，此时每个节点正好分配16个核心。 16核心是一个节点的理想核心数！</p> 
<pre>node.processors: 2</pre> 
<p></p> 
<blockquote> 
 <p>再聊一下线程池！如果熟悉线程池原理，应该知道，线程池可以有固定线程数的线程池，也有弹性的线程池。提交的任务会优先给线程处理，如果处理不过来，自然要把这些任务放在任务队列里。如果任务队列还满的话，那自然要触发拒绝策略了。</p> 
 <p>在看es 线程池相关的配置参数的时候，我们主要关注，线程池的功能，线程池是否是固定线程数，以及其任务队列的大小。</p> 
</blockquote> 
<h4>generic线程池</h4> 
<p>参数：generic</p> 
<p>用于集群运行的幕后工作者，例如：用于节点的发现。</p> 
<h4>用于search的线程池</h4> 
<p>参数：search</p> 
<p>例如： count、search、suggest</p> 
<p>固定线程数：（CPU核心数 * 3 / 2 + 1）</p> 
<p>任务队列：1000</p> 
<p>下边这个我不太懂</p> 
<p><strong><code>search_throttled</code></strong></p> 
<p>For count/search/suggest/get operations on <code>search_throttled indices</code>. Thread pool type is <code>fixed</code> with a size of <code>1</code>, and queue_size of <code>100</code>.</p> 
<p><strong><code>search_coordination</code></strong></p> 
<p>For lightweight search-related coordination operations. Thread pool type is <code>fixed</code> with a size of a max of <code>min(5, (</code><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-threadpool.html#node.processors" rel="nofollow" title="# of allocated processors"># of allocated processors</a><code>) / 2)</code>, and queue_size of <code>1000</code>.</p> 
<p><strong><code>get</code></strong></p> 
<p>For get operations</p> 
<p>固定线程数：CPU核心数</p> 
<p>任务队列：1000</p> 
<p><strong><code>analyze</code></strong></p> 
<p>用于获取语句的执行过程。</p> 
<p>固定线程数：1个线程</p> 
<p>任务队列大小：16</p> 
<p><strong><code>write</code></strong></p> 
<p>写操作：写、删除、更新、批量提交操作</p> 
<p>固定线程数：CPU核心数 + 1</p> 
<p>任务队列大小：10000</p> 
<p><strong><code>snapshot</code></strong></p> 
<p>For snapshot/restore operations. Thread pool type is <code>scaling</code> with a keep-alive of <code>5m</code> and a max of <code>min(5, (</code><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-threadpool.html#node.processors" rel="nofollow" title="# of allocated processors"># of allocated processors</a><code>) / 2)</code>.</p> 
<p>生成快照数据。</p> 
<p>线程数：<code>min(5, (</code>CPU核心数 + 1) / 2) 也就是，最多5个线程。</p> 
<p><strong><code>snapshot_meta</code></strong></p> 
<p>读取快照数据，用来恢复。</p> 
<p>线程数：<code>min(50, (</code>CPU核心数<code>* 3))</code>.</p> 
<p><strong><code>warmer</code></strong></p> 
<p>用于段数据预热</p> 
<p>线程数：<code>min(5, (</code>CPU核心数<code>) / 2)</code>.</p> 
<p><strong><code>refresh</code></strong></p> 
<p>将数据从JVM堆内存，刷新到文件系统，生成段。</p> 
<p>线程数：<code>min(10, (</code>CPU核心数<code>) / 2)</code>.</p> 
<p><strong><code>fetch_shard_started</code></strong></p> 
<p>获取分片状态信息.</p> 
<p>线程数：最大为 CPU核心数*2</p> 
<p><strong><code>fetch_shard_store</code></strong></p> 
<p>获取分片列表.</p> 
<p>线程数：最大为 CPU核心数*2</p> 
<p><strong><code>flush</code></strong></p> 
<p>用于操作文件系统上的段数据（refresh之后的阶段），从文件系统落到磁盘上。</p> 
<p>线程数： <code>min(5, (</code>CPU核心数<code>) / 2)</code>.</p> 
<p><strong><code>force_merge</code></strong></p> 
<p>段合并的线程数。默认为1个线程。</p> 
<blockquote> 
 <p>注意，这个参数不要随意调。比较致命。因为段合并是一个非常花费资源的操作。如果真的要调大，可以在凌晨来段合并。</p> 
</blockquote> 
<p><strong><code>management</code></strong></p> 
<p>用于集群管理</p> 
<p>默认 5 个线程</p> 
<p><strong><code>system_read</code></strong></p> 
<p>系统索引的读.</p> 
<p>线程数： <code>min(5, (</code>CPU核心数<code>) / 2)</code>.</p> 
<p><strong><code>system_write</code></strong></p> 
<p>系统索引的写</p> 
<p>线程数： <code>min(5, (</code>CPU核心数<code>) / 2)</code>.</p> 
<p><strong><code>system_critical_read</code></strong></p> 
<p>For critical read operations on system indices.</p> 
<p>线程数： <code>min(5, (</code>CPU核心数<code>) / 2)</code>.</p> 
<p><strong><code>system_critical_write</code></strong></p> 
<p>For critical write operations on system indices.</p> 
<p>线程数： <code>min(5, (</code><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-threadpool.html#node.processors" rel="nofollow" title="CPU核心数">CPU核心数</a><code>) / 2)</code>.</p> 
<p><strong><code>watcher</code></strong></p> 
<p>用于集群监控</p> 
<p>线程数： <code>min(5 * (</code>CPU核心数<code>), 50)</code></p> 
<p>任务队列：1000</p> 
<p>我们可以通过以下配置，来指定线程数。</p> 
<pre>thread_pool:
   # 指定线程池类型
    write:
        # 指定线程数
        size: 30
        # 指定任务队列大小
        queue_size: 1000</pre> 
<p></p> 
<h3>集群与注册相关配置</h3> 
<p>es有天然的集群自动组成方式。我们只需要简单的配置，节点就会自动组成集群。做分布式应用，es的集群策略是值得我们学习的！</p> 
<p>一起看下和形成集群相关的参数配置</p> 
<ul><li> <p><strong><code>discovery.seed_hosts</code></strong></p> <p>集群的节点列表（意思是指定哪些节点去进行通信，并形成集群）。</p> 
  <ol><li> <p>配置有两种形式：直接指定ip和端口号，多个用逗号分割。注意是ip：port的形式。如果不指定端口的话，默认是9300。9300是es节点间通信的端口。</p> 
    <ol><li> <p>如果地址是ipv4，举个栗子 ["10.10.10.10:9300", "10.10.10.11:9300"]</p> </li><li> <p>如果地址是ipv6，需要用中括号括起来。举个栗子 [ "10.10.10.10:9300", "[::1]:9300"]</p> </li></ol></li><li> <p>也可以通过配置域名的方式。</p> <p>举个栗子： seeds.mydomain.com</p> <p></p> <pre>discovery.seed_hosts:
   - 192.168.1.10:9300
   - 192.168.1.11
   - seeds.mydomain.com
   - [0:0:0:0:0:ffff:c0a8:10c]:9301</pre> <p></p> </li></ol></li><li> <p><strong><code>discovery.seed_providers</code></strong></p> <p>这个参数是用来指定读取集群列表的形式。默认情况下，我们是把地址放在了elasticsearch.yml下，从配置文件中修改。</p> <p>但是假如我们集群的节点需要动态调整的话，不太方便。所以官方给我们提供了其它的形式。比如放在一个单独的文件，我们可以动态的去修改它。</p> <p>下边的案例是我们指定配置的节点列表放在文件里。</p> <pre>discovery.seed_providers: file</pre> <p>然后我们在es的config目录下（和elasticsearch.yml同级的目录），创建一个名字为： unicast_hosts.txt 的文件，然后在文件中放入节点的列表:</p> <pre>10.10.10.5
10.10.10.6:9305
10.10.10.5:10005
# an IPv6 address 注意注释内容用 #开头
[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:9301</pre> <p></p> </li><li> <p><strong><code>discovery.type</code></strong></p> <p>该参数指定了es节点是集群模式。默认是 multi-node 。也就是集群模式，它允许新的节点进来。</p> <p>如果按照以下设置，则单个节点为一个集群。</p> <pre>discovery.type: single-node</pre> <p></p> </li><li> <p><strong><code>cluster.initial_master_nodes</code></strong></p> <p>该参数指定哪些节点可以作为master节点。注意这里指定的是节点的名称。</p> <pre>cluster.initial_master_nodes: 
   - master-node-a
   - master-node-b
   - master-node-c</pre> </li></ul> 
<h4>专家设置<a href="https://github.com/elastic/elasticsearch/edit/8.1/docs/reference/modules/discovery/discovery-settings.asciidoc" title="编辑">编辑</a></h4> 
<p>以下配置都是集群相关的配置，官方不建议修改。如果你熟悉它们，也可以修改！</p> 
<ul><li> <p><strong><code>discovery.cluster_formation_warning_timeout</code></strong></p> <p>默认值 10s</p> <p>假如 经过了 10s，节点还没有形成集群，会记录一条warn级别的日志，</p> <p><code>discovery.cluster_formation_warning_timeout</code>短语开头。<code>master not discovered</code></p> </li><li> <p><strong><code>discovery.find_peers_interval</code></strong></p> <p>默认为<code>1s</code>.</p> <p>设置经过多长时间，进行一次集群发现。</p> </li><li> <p><strong><code>discovery.probe.connect_timeout</code></strong></p> <p>默认为 <code>30s</code>.</p> <p>设置尝试连接到每个地址时的等待时间。</p> </li><li> <p><strong><code>discovery.probe.handshake_timeout</code></strong></p> <p>默认为<code>30s</code>.</p> <p>设置尝试通过握手识别远程节点时等待多长时间。</p> </li><li> <p><strong><code>discovery.request_peers_timeout</code></strong></p> <p>默认为<code>3s</code>.</p> <p>设置节点在再次询问其对等方之后将等待多长时间，然后才认为请求失败。</p> </li><li> <p><strong><code>discovery.find_peers_warning_timeout</code></strong></p> <p>默认为<code>3m</code>.</p> <p>设置节点在开始记录描述连接尝试失败原因的详细消息之前尝试发现其对等点的时间。</p> </li><li> <p><strong><code>discovery.seed_resolver.max_concurrent_resolvers</code></strong></p> <p>默认为<code>10</code>.</p> <p>在节点发现时，节点列表中假如配置了域名的方式，进行DNS查询的并发数。</p> </li><li> <p><strong><code>discovery.seed_resolver.timeout</code></strong></p> <p>默认为<code>5s</code>.</p> <p>在节点发现时，节点列表中假如配置了域名的方式，每次DNS获取地址的超时时间。</p> </li><li> <p><strong><code>cluster.auto_shrink_voting_configuration</code></strong></p> <p>该参数指定是否在投票中排除离开的节点。假如一共四个节点，一个节点的机器坏了，我们认为该节点离开了。</p> <p>该参数默认为 true，代表会自动踢出离开的节点。前提是总的节点数大于等于3.</p> <p>假如设置为false，则不会踢出离开的节点，需要我们通过api来手动踢出。 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/voting-config-exclusions.html" rel="nofollow" title="voting configuration exclusions API">voting configuration exclusions API</a>.</p> </li><li> <p><strong><code>cluster.election.back_off_time</code></strong></p> <p>默认为 <code>100ms</code>.</p> <p>选举失败时，等待的时间。</p> <p>从默认值更改此设置可能会导致您的集群无法选择主节点。</p> </li><li> <p><strong><code>cluster.election.duration</code></strong></p> <p>默认为<code>500ms</code>.</p> <p>设置在选举失败以后每次选举花费多长时间。</p> <p>从默认值更改此设置可能会导致您的集群无法选择主节点。</p> </li><li> <p><strong><code>cluster.election.initial_timeout</code></strong></p> <p>这默认为 <code>100ms</code>.</p> <p>该参数指定在第一选举之前，或者选举失败以后，允许多长时间用来做节点的初始化工作。</p> <p>从默认值更改此设置可能会导致您的集群无法选择主节点。</p> </li><li> <p><strong><code>cluster.election.max_timeout</code></strong></p> <p>设置节点在尝试第一次选举之前等待多长时间的最大上限，防止因为网络不稳定有太多的节点没有加入进来。这默认为<code>10s</code>. 从默认值更改此设置可能会导致您的集群无法选择主节点。</p> </li><li> <p><strong><code>cluster.fault_detection.follower_check.interval</code></strong></p> <p>设置主节点检查从节点的等待时间。默认为<code>1s</code>. 从默认值更改此设置可能会导致您的集群变得不稳定。</p> </li><li> <p><strong><code>cluster.fault_detection.follower_check.timeout</code></strong></p> <p>设置主节点多长时间可以认为从节点不在了。</p> <p>默认为<code>10s</code>. 从默认值更改此设置可能会导致您的集群变得不稳定。</p> </li><li> <p><strong><code>cluster.fault_detection.follower_check.retry_count</code></strong></p> <p>主节点检查从节点的次数，在失败多少次以后，可以认为该节点不在了。</p> <p>默认为<code>3</code>.</p> <p>从默认值更改此设置可能会导致您的集群变得不稳定。</p> </li><li> <p><strong><code>cluster.fault_detection.leader_check.interval</code></strong></p> <p>设置每个节点在选举前等待的时间。</p> <p>默认为 <code>1s</code>.</p> <p>从默认值更改此设置可能会导致您的集群变得不稳定。</p> </li><li> <p><strong><code>cluster.fault_detection.leader_check.timeout</code></strong></p> <p>设置从节点判定主节点不在的时间.</p> <p>默认为<code>10s</code>.</p> <p>从默认值更改此设置可能会导致您的集群变得不稳定。</p> </li><li> <p><strong><code>cluster.fault_detection.leader_check.retry_count</code></strong></p> <p>设置从节点检查主节点是否存在的失败次数。</p> <p>默认为<code>3</code>. 超过三次以后则从节点可以认为主节点不在了。</p> <p>从默认值更改此设置可能会导致您的集群变得不稳定。</p> </li><li> <p><strong><code>cluster.follower_lag.timeout</code></strong></p> <p>集群状态在从节点更新的时间，默认是90s，如果集群状态在90s以后没有在从节点应用成功，则将该从节点从集群中移除。请参阅 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-state-publishing.html" rel="nofollow" title="发布集群状态">发布集群状态</a>。</p> </li><li> <p><strong><code>cluster.max_voting_config_exclusions</code></strong></p> <p>这个参数我暂时没明白是什么意思。</p> 
  <blockquote> 
   <p>(<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#dynamic-cluster-setting" rel="nofollow" title="Dynamic">Dynamic</a>) Sets a limit on the number of voting configuration exclusions at any one time. The default value is <code>10</code>. See <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-adding-removing-nodes.html" rel="nofollow" title="Adding and removing nodes">Adding and removing nodes</a>.</p> 
  </blockquote> </li><li> <p><strong><code>cluster.publish.info_timeout</code></strong></p> <p>默认值为<code>10s</code>。</p> <p>主节点将集群状态应用在所有节点的时间。假如超过了默认值10s，则会记录一条日志。</p> </li><li> <p><strong><code>cluster.publish.timeout</code></strong></p> <p>设置主节点等待集群状态完全发布到所有节点的超时时间，除非<code>discovery.type</code>设置为 <code>single-node</code>。默认值为<code>30s</code>。请参阅<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-state-publishing.html" rel="nofollow" title="发布集群状态">发布集群状态</a>。</p> </li><li> <p><strong><code>cluster.no_master_block</code></strong></p> <p>设置在没有master节点的时候不可以做的操作</p> <p>此设置具有三个有效值：</p> 
  <ol><li> <p><strong><code>all</code></strong>节点上的所有操作（读取和写入操作）都被拒绝。这也适用于 API 集群状态读取或写入操作，例如获取索引设置、更新映射和集群状态 API。</p> </li><li> <p><strong><code>write</code></strong>拒绝写操作。</p> </li><li> <p><strong><code>metadata_write</code></strong>只有元数据写入操作（例如映射更新、路由表更改）被拒绝，但常规索引操作继续工作。根据最后一个已知的集群配置，读取和写入操作成功。这种情况可能会导致部分读取过时数据，因为该节点可能与集群的其余部分隔离。该<code>cluster.no_master_block</code>设置不适用于基于节点的 API（例如，集群统计、节点信息和节点统计 API）。对这些 API 的请求不会被阻止，并且可以在任何可用节点上运行。要使集群完全运行，它必须有一个活动的主节点。</p> </li></ol><p></p> </li><li> <p><strong><code>monitor.fs.health.enabled</code></strong></p> <p>如果<code>true</code>，节点运行定期 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-fault-detection.html#cluster-fault-detection-filesystem-health" rel="nofollow" title="文件系统健康检查">文件系统健康检查</a>。默认为<code>true</code>.</p> </li><li> <p><strong><code>monitor.fs.health.refresh_interval</code></strong></p> <p>每次文件系统检查的时间间隔 。默认为<code>2m</code>.</p> </li><li> <p><strong><code>monitor.fs.health.slow_path_logging_threshold</code></strong></p> <p>检查问阿金系统的时间超过该值，则 Elasticsearch 会记录警告日志。默认为<code>5s</code>.</p> </li></ul> 
<p></p> 
<h3>索引生命周期相关的配置</h3> 
<h4>集群方面配置：</h4> 
<ul><li> <p><strong><code>indices.lifecycle.history_index_enabled</code></strong></p> <p>默认为： true</p> <p>是否将 生命周期相关的操作记录到<code>ilm-history-*</code> indices.</p> </li><li> <p><strong><code>indices.lifecycle.poll_interval</code></strong></p> <p>默认：10m</p> <p>多久检查一次索引生命周期的策略。我们是可以修改索引的生命周期相关的配置的。</p> </li></ul> 
<h4>索引层面的配置</h4> 
<ul><li> <p><strong><code>index.lifecycle.indexing_complete</code></strong></p> <p>是否滚动创建索引。</p> <p>默认为<code>false</code>.</p> </li><li> <p><strong><code>index.lifecycle.name</code></strong></p> <p>用于管理索引的策略名称。有关 Elasticsearch 如何应用策略更改的信息，请参阅<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/update-lifecycle-policy.html" rel="nofollow" title="策略更新">策略更新</a>。</p> </li><li> <p><strong><code>index.lifecyle.origination_date</code></strong></p> <p>单位是long类型的时间戳</p> <p>记录首次创建索引的间。该时间会被用来计算索引的年龄。可以不指定，如果不指定，则需要用下边的参数，并且创建的索引名称为指定格式。</p> </li><li> <p><strong><code>index.lifecycle.parse_origination_date</code></strong></p> <p>是否自动识别首次创建索引的时间。这个时间用来计算索引的年龄。</p> <p>默认为true，当设置为true的时候，会自动从索引中通过名字识别首次创建索引的时间。前提是索引的名字为指定格式。索引名称必须与模式匹配<code>^.*-{date_format}-\\d+</code>，其中<code>date_format</code>is<code>yyyy.MM.dd</code>和尾随数字是可选的。翻转的索引通常会匹配完整格式，例如<code>logs-2016.10.31-000002</code>)。如果索引名称与模式不匹配，则索引创建失败。</p> </li><li> <p><strong><code>index.lifecycle.step.wait_time_threshold</code></strong></p> <p>在 ILM操作期间等待集群解决分配问题的时间 。必须大于<code>1h</code>（1 小时）。默认为 <code>12h</code>（12 小时）。请参阅<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-shrink.html#ilm-shrink-shard-allocation" rel="nofollow" title="分片分配 收缩">分片分配 收缩</a>。</p> </li><li> <p><strong><code>index.lifecycle.rollover_alias</code></strong></p> <p>使用生命周期滚动创建索引要更新的索引别名。</p> </li></ul> 
<h2>更多</h2> 
<h3>生产经验关于参数优化</h3> 
<p>看完还是觉得不够过瘾，或者说觉得不够实用。可以看看我这篇文章（这是我在长期运维千亿级别生产集群的生产经验，个人觉得比上边的更实用一些✿✿ヽ(°▽°)ノ✿）：<a class="link-info" href="https://blog.csdn.net/star1210644725/article/details/134024631?spm=1001.2014.3001.5502" title="几千亿级集群管理，近百个实用优化参数，涵盖集群、索引、客户端">几千亿级集群管理，近百个实用优化参数，涵盖集群、索引、客户端</a></p> 
<p></p> 
<h3>生产经验性能优化</h3> 
<p><a class="link-info" href="https://blog.csdn.net/star1210644725/article/details/134063852?spm=1001.2014.3001.5502" title="ES性能优化最佳实践- 检索性能提升30倍！">ES性能优化最佳实践- 检索性能提升30倍！</a></p> 
<p></p> 
<h3>向量检索优化</h3> 
<p><a class="link-info" href="https://blog.csdn.net/star1210644725/article/details/134021552?spm=1001.2014.3001.5502" title="ES 8.x 向量检索性能测试 &amp; 把向量检索性能提升100倍！">ES 8.x 向量检索性能测试 &amp; 把向量检索性能提升100倍！</a></p> 
<h2></h2>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c22a27abba8347d7c24191657f83153b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ES优化实战 - 小操作节省百分之三十以上的磁盘空间</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26fadcca84956d34eed2a91f9ff938c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用OpenCV 打开摄像头</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>