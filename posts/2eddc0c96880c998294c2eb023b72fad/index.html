<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入学习java源码之ThreadLocal.get()()与ThreadLocal.initialValue() - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入学习java源码之ThreadLocal.get()()与ThreadLocal.initialValue()" />
<meta property="og:description" content="深入学习java源码之ThreadLocal.get()()与 ThreadLocal.initialValue()
并发编程ThreadLocal
线程封闭机制强调局部的概念，就是在写代码的时候，尽量使用局部变量代替全局变量（这种叫做栈封闭），如果一定要使用全局变量，而又想让多个线程之间在访问共享变量的时候互不影响，那就使用ThreadLocal&lt;T&gt;。ThreadLocal&lt;T&gt;提供了一种方式，可以让线程在操作共享变量时，复制该共享变量的一个副本到线程自己的栈空间，以后就操作这个副本空间来代替共享空间，这是一种封闭的手段。
@ThreadSafe pulic class TestNum{ private int num=0; public synchronized int getNextNum(){ &#43;&#43;num; return num; } public static void main(String [] args){ TestNum tn=new TestNum(); TestClass tc1=new TestClass(tn); TestClass tc2=new TestClass(tn); TestClass tc3=new TestClass(tn); tc1.start(); tc2.start(); tc3.start(); } class TestClass extends Thread{ private TestNum tn; public TestClass(TestNum tn){ this.tn=tn; } public void run(){ for(int i=0;i&lt;3;i&#43;&#43;){ System.out.println(&#34;thread-&#34;&#43;Thread.currentThread().getName()&#43;&#34;-&#34;&#43;tn.getNextNum()); } } } } 对于上面的代码，我们使用同步机制的来实现线程安全：tc1-3这三个线程都在访问同一个num空间，并且他们都在干一件事，那就是让这个空间的数字增加，并且能够留下自己的影响（即num&#43;&#43;）。此时，输出的结果最大值一定是num=9。
ThreadLocal
用处：保存线程的独立变量。对一个线程类（继承自Thread)
ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 举个例子，我出门需要先坐公交再做地铁，这里的坐公交和坐地铁就好比是同一个线程内的两个函数，我就是一个线程，我要完成这两个函数都需要同一个东西：公交卡（北京公交和地铁都使用公交卡），那么我为了不向这两个函数都传递公交卡这个变量（相当于不是一直带着公交卡上路），我可以这么做：将公交卡事先交给一个机构，当我需要刷卡的时候再向这个机构要公交卡（当然每次拿的都是同一张公交卡）。这样就能达到只要是我(同一个线程)需要公交卡，何时何地都能向这个机构要的目的。
有人要说了：你可以将公交卡设置为全局变量啊，这样不是也能何时何地都能取公交卡吗？但是如果有很多个人（很多个线程）呢？大家可不能都使用同一张公交卡吧(我们假设公交卡是实名认证的)，这样不就乱套了嘛。现在明白了吧？这就是ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2eddc0c96880c998294c2eb023b72fad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-20T16:13:17+08:00" />
<meta property="article:modified_time" content="2019-01-20T16:13:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入学习java源码之ThreadLocal.get()()与ThreadLocal.initialValue()</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>深入学习java源码之ThreadLocal.get()()与 ThreadLocal.initialValue()</p> 
<p><strong>并发编程ThreadLocal</strong></p> 
<p>线程封闭机制强调局部的概念，就是在写代码的时候，尽量使用局部变量代替全局变量（这种叫做栈封闭），如果一定要使用全局变量，而又想让多个线程之间在访问共享变量的时候互不影响，那就使用ThreadLocal&lt;T&gt;。ThreadLocal&lt;T&gt;提供了一种方式，可以让线程在操作共享变量时，复制该共享变量的一个副本到线程自己的栈空间，以后就操作这个副本空间来代替共享空间，这是一种封闭的手段。</p> 
<pre class="has"><code>@ThreadSafe  
pulic class TestNum{  
    private int num=0;  
    public synchronized int getNextNum(){  
        ++num;  
        return num;  
    }  
    public static void main(String [] args){  
        TestNum tn=new TestNum();  
        TestClass tc1=new TestClass(tn);  
        TestClass tc2=new TestClass(tn);  
        TestClass tc3=new TestClass(tn);  
          
        tc1.start();  
        tc2.start();  
        tc3.start();  
    }  
    class TestClass extends Thread{  
        private TestNum tn;  
        public TestClass(TestNum tn){  
            this.tn=tn;  
        }  
        public void run(){  
            for(int i=0;i&lt;3;i++){  
                System.out.println("thread-"+Thread.currentThread().getName()+"-"+tn.getNextNum());  
            }  
        }  
    }  
}  </code></pre> 
<p>对于上面的代码，我们使用同步机制的来实现线程安全：tc1-3这三个线程都在访问同一个num空间，并且他们都在干一件事，那就是让这个空间的数字增加，并且能够留下自己的影响（即num++）。此时，输出的结果最大值一定是num=9。</p> 
<p><strong><span style="color:#4f4f4f;">ThreadLocal</span></strong></p> 
<p>用处：保存线程的独立变量。对一个线程类（继承自Thread)</p> 
<p style="margin-left:0px;"><span style="color:#4f4f4f;">ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 <br> 举个例子，我出门需要先坐公交再做地铁，这里的坐公交和坐地铁就好比是同一个线程内的两个函数，我就是一个线程，我要完成这两个函数都需要同一个东西：公交卡（<a href="https://www.baidu.com/s?wd=%E5%8C%97%E4%BA%AC%E5%85%AC%E4%BA%A4&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" rel="nofollow">北京公交</a>和地铁都使用公交卡），那么我为了不向这两个函数都传递公交卡这个变量（相当于不是一直带着公交卡上路），我可以这么做：<span style="color:#ff0000;">将公交卡事先交给一个机构，当我需要刷卡的时候再向这个机构要公交卡（当然每次拿的都是同一张公交卡）。这样就能达到只要是我(同一个线程)需要公交卡，何时何地都能向这个机构要的目的</span>。</span></p> 
<p style="margin-left:0px;"><span style="color:#4f4f4f;">有人要说了：你可以将公交卡设置为全局变量啊，这样不是也能何时何地都能取公交卡吗？但是如果有很多个人（很多个线程）呢？大家可不能都使用同一张公交卡吧(我们假设公交卡是实名认证的)，这样不就乱套了嘛。现在明白了吧？这就是ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内<a href="https://www.baidu.com/s?wd=%E9%9A%8F%E6%97%B6%E9%9A%8F%E5%9C%B0&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" rel="nofollow">随时随地</a>可取，隔离其他线程。</span></p> 
<p>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。常用于用户登录控制，如记录session信息。</p> 
<pre class="has"><code>@ThreadSafe  
pulic class TestNum{  
    private ThreadLocal&lt;Integer&gt; num=new ThreadLocal&lt;Integer&gt;(){  
        public Integer initialValue(){  
            return 0;  
        }  
    };  
    public  int getNextNum(){  
        num.set(num.get()+1);  
        return num.get();  
    }  
    public static void main(String [] args){  
        TestNum tn=new TestNum();  
        TestClass tc1=new TestClass(tn);  
        TestClass tc2=new TestClass(tn);  
        TestClass tc3=new TestClass(tn);  
          
        tc1.start();  
        tc2.start();  
        tc3.start();  
    }  
    class TestClass extends Thread{  
        private TestNum tn;  
        public TestClass(TestNum tn){  
            this.tn=tn;  
        }  
        public void run(){  
            for(int i=0;i&lt;3;i++){  
                System.out.println("thread-"+Thread.currentThread().getName()+"-"+tn.getNextNum());  
            }  
        }  
    }  
}  </code></pre> 
<p>对于上面的代码，我们使用线程封闭来完成，tc1-3这三个线程访问共享变量在自己栈空间的一个副本，他们都在干自己的事（不是一件事），只不过在干自己的事的过程中使用到了共享变量这个载体，而且他们也不关心最终对共享变量产生了多少影响。此时，输出的结果最大值一定是num=3（每个线程在干自己的事情）。 <br>  </p> 
<p> </p> 
<p>实现：每个Thread都持有一个TreadLocalMap类型的变量（该类是一个轻量级的Map，功能与map一样，区别是桶里放的是entry而不是entry的链表。功能还是一个map。）以本身为key，以目标为value。<br> 主要方法是get()和set(T a)，set之后在map里维护一个threadLocal -&gt; a，get时将a返回。ThreadLocal是一个特殊的容器。</p> 
<p>假设我们要为每个线程关联一个唯一的序号，在每个线程周期内，我们需要多次访问这个序号，这时我们就可以使用ThreadLocal了</p> 
<pre class="has"><code>import java.util.concurrent.atomic.AtomicInteger;

public class ThreadLocalDemo {
    public static void main(String []args){
        for(int i=0;i&lt;5;i++){
            final Thread t = new Thread(){
                @Override
                public void run(){
                    System.out.println("当前线程:"+Thread.currentThread().getName()+",已分配ID:"+ThreadId.get());
                }
            };
            t.start();
        }
    }
    static   class ThreadId{
        //一个递增的序列，使用AtomicInger原子变量保证线程安全
        private static final AtomicInteger nextId = new AtomicInteger(0);
        //线程本地变量，为每个线程关联一个唯一的序号
        private static final ThreadLocal&lt;Integer&gt; threadId =
                new ThreadLocal&lt;Integer&gt;() {
                    @Override
                    protected Integer initialValue() {
                        return nextId.getAndIncrement();//相当于nextId++,由于nextId++这种操作是个复合操作而非原子操作，会有线程安全问题(可能在初始化时就获取到相同的ID，所以使用原子变量
                    }
                };

       //返回当前线程的唯一的序列，如果第一次get，会先调用initialValue，后面看源码就了解了
        public static int get() {
            return threadId.get();
        }
    }
}</code></pre> 
<p>执行结果,可以看到每个线程都分配到了一个唯一的ID，同时在此线程范围内的"任何地点"，我们都可以通过ThreadId.get()这种方式直接获取。</p> 
<p><img alt="" class="has" height="105" src="https://images2.imgbox.com/07/5d/N6TB4jw1_o.png" width="216"></p> 
<p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p> 
<p>假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。</p> 
<p>　　但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</p> 
<p><img alt="" class="has" height="192" src="https://images2.imgbox.com/13/e0/6yERQL2i_o.png" width="376"></p> 
<p>第一句是取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到&lt;key,value&gt;键值对，注意这里获取键值对传进去的是  this，而不是当前线程t。</p> 
<p>如果获取成功，则返回value值。</p> 
<p>如果map为空，则调用setInitialValue方法返回value。</p> 
<p><img alt="" class="has" height="73" src="https://images2.imgbox.com/8d/78/chYw9VfZ_o.png" width="304"></p> 
<p>在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals。</p> 
<p>成员变量threadLocals是什么：</p> 
<p><img alt="" class="has" height="26" src="https://images2.imgbox.com/06/d6/Erd973qS_o.png" width="395"></p> 
<p>实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类</p> 
<p>ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。</p> 
<p><img alt="" class="has" height="214" src="https://images2.imgbox.com/28/8d/mvRZTVxk_o.png" width="309"></p> 
<p>setInitialValue方法的具体实现：</p> 
<p>就是如果map不为空，就设置键值对，为空，再创建Map，看一下createMap的实现：</p> 
<p><img alt="" class="has" height="60" src="https://images2.imgbox.com/b1/99/Tsd1ZT4a_o.png" width="504"></p> 
<p>ThreadLocal是如何为每个线程创建变量的副本的：</p> 
<p>　　首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p> 
<p>　　初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p> 
<p>　　然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p> 
<p>　　1）实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；</p> 
<p>　　2）为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；</p> 
<p>　　3）在进行get之前，必须先set，否则会报空指针异常；</p> 
<p>如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。</p> 
<p>如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null。</p> 
<p>下面这段代码，即重写了initialValue方法：</p> 
<p>在main线程中就可以直接不用先set而直接调用get了。</p> 
<pre class="has"><code>public class Test {
    ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;(){
        protected Long initialValue() {
            return Thread.currentThread().getId();
        };
    };
    ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;(){;
        protected String initialValue() {
            return Thread.currentThread().getName();
        };
    };
 
     
    public void set() {
        longLocal.set(Thread.currentThread().getId());
        stringLocal.set(Thread.currentThread().getName());
    }
     
    public long getLong() {
        return longLocal.get();
    }
     
    public String getString() {
        return stringLocal.get();
    }
     
    public static void main(String[] args) throws InterruptedException {
        final Test test = new Test();
 
        test.set();
        System.out.println(test.getLong());
        System.out.println(test.getString());
     
         
        Thread thread1 = new Thread(){
            public void run() {
                test.set();
                System.out.println(test.getLong());
                System.out.println(test.getString());
            };
        };
        thread1.start();
        thread1.join();
         
        System.out.println(test.getLong());
        System.out.println(test.getString());
    }
}</code></pre> 
<p><img alt="" class="has" height="152" src="https://images2.imgbox.com/2e/3a/JYyP5zA0_o.png" width="492"></p> 
<p>　　从这段代码的输出结果可以看出，在main线程中和thread1线程中，longLocal保存的副本值和stringLocal保存的副本值都不一样。最后一次在main线程再次打印副本值是为了证明在main线程中和thread1线程中的副本值确实是不同的。</p> 
<p>　　总结一下：</p> 
<p>　　1）实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；</p> 
<p>　　2）为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；</p> 
<p>　　3）在进行get之前，必须先set，否则会报空指针异常；</p> 
<p>ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。</p> 
<pre class="has"><code>private static ThreadLocal&lt;Connection&gt; connectionHolder
= new ThreadLocal&lt;Connection&gt;() {
public Connection initialValue() {
    return DriverManager.getConnection(DB_URL);
}
};
 
public static Connection getConnection() {
return connectionHolder.get();
}</code></pre> 
<pre class="has"><code>private static final ThreadLocal threadSession = new ThreadLocal();
 
public static Session getSession() throws InfrastructureException {
    Session s = (Session) threadSession.get();
    try {
        if (s == null) {
            s = getSessionFactory().openSession();
            threadSession.set(s);
        }
    } catch (HibernateException ex) {
        throw new InfrastructureException(ex);
    }
    return s;
}</code></pre> 
<p>各个线程的value值是相互独立的，本线程的累加操作不会影响到其他线程的值，真正达到了线程内部隔离的效果。</p> 
<pre class="has"><code>public class TestThreadLocal {
    private static final ThreadLocal&lt;Integer&gt; value = new ThreadLocal&lt;Integer&gt;() {
        @Override
        protected Integer initialValue() {
            return 0;
        }
    };
    public static void main(String[] args) {
        for (int i = 0; i &lt; 5; i++) {
            new Thread(new MyThread(i)).start();
        }
    }
    static class MyThread implements Runnable {
        private int index;
        public MyThread(int index) {
            this.index = index;
        }
        public void run() {
            System.out.println("线程" + index + "的初始value:" + value.get());
            for (int i = 0; i &lt; 10; i++) {
                value.set(value.get() + i);
            }
            System.out.println("线程" + index + "的累加value:" + value.get());
        }
    }
}</code></pre> 
<p>执行结果为：</p> 
<p>线程0的初始value:0 <br> 线程3的初始value:0 <br> 线程2的初始value:0 <br> 线程2的累加value:45 <br> 线程1的初始value:0 <br> 线程3的累加value:45 <br> 线程0的累加value:45 <br> 线程1的累加value:45 <br> 线程4的初始value:0 <br> 线程4的累加value:45</p> 
<p>ThreadLocal实现数据源的切换</p> 
<pre class="has"><code>public enum DataSourceEnum {

    MASTER,SLAVE
}
</code></pre> 
<pre class="has"><code>/**
 * 数据源切换类
 * 构建一个DataSourceEnum容器，并提供了向其中设置和获取DataSorceEnum的方法
 */
public class DataSourceContextHolder {

    private static final ThreadLocal&lt;DataSourceEnum&gt; contextHolder = new ThreadLocal&lt;DataSourceEnum&gt;(){

        protected DataSourceEnum initValue(){
            return DataSourceEnum.MASTER;
        }
    };
    
    public static void setDatabaseType(DataSourceEnum type){
        contextHolder.set(type);
    }
    public static DataSourceEnum getDataSourceType(){
        return contextHolder.get();
    }
    public static void clearDataSourceType(){
        contextHolder.remove();
    }
}</code></pre> 
<pre class="has"><code>import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;

public class DynamicDataSource  extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDataSourceType();
    }
}</code></pre> 
<pre class="has"><code>import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.core.env.Environment;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
public class DataSourceConfig {

    @Autowired
    private Environment env;

    @Bean(name="masterDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.master")
    public DataSource masterDataSource()
    {
        return DataSourceBuilder.create().build();
    }

    @Bean(name="slaveDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.slave")
    public DataSource slaveDataSource()
    {
        return DataSourceBuilder.create().build();
    }

    @Primary
    @Bean("dataSource")
    public DynamicDataSource dataSource(@Qualifier("masterDataSource") DataSource master,
                                        @Qualifier("slaveDataSource") DataSource slave)
    {
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        Map targetDataSources = new HashMap();
        targetDataSources.put(DataSourceEnum.MASTER,master);
        targetDataSources.put(DataSourceEnum.SLAVE,slave);
        dynamicDataSource.setTargetDataSources(targetDataSources);
        dynamicDataSource.setDefaultTargetDataSource(master);
        return dynamicDataSource;
    }

    @Primary
    @Bean("sqlSessionFactory")
    public SqlSessionFactory sqlSessionFactory(@Qualifier("masterDataSource") DataSource master,
                                               @Qualifier("slaveDataSource") DataSource slave)throws Exception
    {
        SqlSessionFactoryBean sessionFactoryBean = new SqlSessionFactoryBean();
        sessionFactoryBean.setDataSource(this.dataSource(master,slave));
        sessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(env.getProperty("mybatis.mapper-locations")));
        return sessionFactoryBean.getObject();
    }
    @Bean("transactionManager")
    public DataSourceTransactionManager transactionManager(@Qualifier("dataSource") DynamicDataSource dataSource) throws Exception
    {
        return new DataSourceTransactionManager(dataSource);
    }
}</code></pre> 
<pre class="has"><code>spring:
  application:
    name: TAG_RULE
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    #主数据源
    master:
      driver-class-name: com.mysql.jdbc.Driver
      url: jdbc:mysql://121:33/arcgis?useUnicode=true&amp;characterEncoding=utf-8&amp;useOldAliasMetadataBehavior=true
      username: arcgis
      password: arcgis
    #从数据源
    slave:
      driver-class-name: com.microsoft.sqlserver.jdbc.SQLServerDriver
      url: jdbc:sqlserver://134:33;DatabaseName=arcgis
      username: arcgis
      password: "%$#@!arcgis"
    maximum-pool-size: 100
    max-idle: 10
    max-wait: 10000
    min-idle: 5
    initial-size: 5
    validation-query: SELECT 1

server:
  port: 9001

mybatis:
    mapper-locations: classpath:mapper/*.xml

logging:
  level:
    com:
      looedu:
        mapper: debug</code></pre> 
<p>业务代码实现数据源的切换</p> 
<pre class="has"><code>    public void synData()
    {
        try
        {
            List&lt;TTagRule&gt; ruleList = tagRuleMapper.selectAll();
            if(CollectionUtils.isEmpty(ruleList))
            {
                return;
            }
            DataSourceContextHolder.setDatabaseType(DataSourceEnum.SLAVE);
            List&lt;TagValue&gt; valueList = tagValueMapper.queryTagValueList(ruleList);
            if(CollectionUtils.isEmpty(valueList))
            {
                return;
            }
            DataSourceContextHolder.setDatabaseType(DataSourceEnum.MASTER);
            for(TagValue tv:valueList)
            {
                for(TTagRule rule:ruleList)
                {
                    if(tv.getTagcode().equals(rule.getTagcode()))
                    {
                        tv.setTagname(rule.getTagname());
                        tv.setType(rule.getType());
                        Date now = new Date();
                        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                        tv.setSynTime(sdf.format(now));
                    }
                }
            }
            Map&lt;String,Object&gt; param = new HashMap&lt;String,Object&gt;(1);
            param.put("list",valueList);
            int a = tagValueMapper.insertTagValue(param);
            tagValueMapper.deleteRepeatTagValue();
        }
        catch(Exception e)
        {
            System.out.println(e.getMessage());
            return;
        }

    }</code></pre> 
<p> </p> 
<p><strong>volatile</strong></p> 
<p>volatile包含以下语义：</p> 
<p>（1）<a href="http://lib.csdn.net/base/17" rel="nofollow">Java</a> 存储模型不会对valatile指令的操作进行重排序：这个保证对volatile变量的操作时按照指令的出现顺序执行的。</p> 
<p>（2）volatile变量不会被缓存在寄存器中（只有拥有线程可见）或者其他对CPU不可见的地方，每次总是从主存中读取volatile变量的结果。也就是说对于volatile变量的修改，其它线程总是可见的，并且不是使用自己线程栈内部的变量。也就是在happens-before法则中，对一个valatile变量的写操作后，其后的任何读操作理解可见此写操作的结果。</p> 
<p>尽管volatile变量的特性不错，但是volatile并不能保证线程安全的，也就是说volatile字段的操作不是原子性的，volatile变量只能保证可见性（一个线程修改后其它线程能够理解看到此变化后的结果），要想保证原子性，目前为止只能加锁！</p> 
<p><a name="t4"></a>使用Volatile的原则：</p> 
<p>应用volatile变量的三个原则：</p> 
<p>（1）写入变量不依赖此变量的值，或者只有一个线程修改此变量</p> 
<p>（2）变量的状态不需要与其它变量共同参与不变约束</p> 
<p>（3）访问变量不需要加锁</p> 
<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p> 
<p>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。（然而，如果将值调整为只从单个线程写入，那么可以忽略第一个条件。）</p> 
<p> </p> 
<p><strong>java源码</strong></p> 
<table border="0" cellpadding="3" cellspacing="0"><tbody><tr><th>Modifier and Type</th><th>Method and Description</th></tr><tr id="i0"><td><code><a href="../../java/lang/ThreadLocal.html" rel="nofollow">T</a></code></td><td><code><a href="../../java/lang/ThreadLocal.html#get--" rel="nofollow">get</a>()</code> <p>返回当前线程的此线程局部变量的副本中的值。</p> </td></tr><tr id="i1"><td><code>protected <a href="../../java/lang/ThreadLocal.html" rel="nofollow">T</a></code></td><td><code><a href="../../java/lang/ThreadLocal.html#initialValue--" rel="nofollow">initialValue</a>()</code> <p>返回此线程局部变量的当前线程的“初始值”。</p> </td></tr><tr id="i2"><td><code>void</code></td><td><code><a href="../../java/lang/ThreadLocal.html#remove--" rel="nofollow">remove</a>()</code> <p>删除此线程局部变量的当前线程的值。</p> </td></tr><tr id="i3"><td><code>void</code></td><td><code><a href="../../java/lang/ThreadLocal.html#set-T-" rel="nofollow">set</a>(<a href="../../java/lang/ThreadLocal.html" rel="nofollow">T</a> value)</code> <p>将当前线程的此线程局部变量的副本设置为指定的值。</p> </td></tr><tr id="i4"><td><code>static &lt;S&gt; <a href="../../java/lang/ThreadLocal.html" rel="nofollow">ThreadLocal</a>&lt;S&gt;</code></td><td><code><a href="../../java/lang/ThreadLocal.html#withInitial-java.util.function.Supplier-" rel="nofollow">withInitial</a>(<a href="../../java/util/function/Supplier.html" rel="nofollow">Supplier</a>&lt;? extends S&gt; supplier)</code> <p>创建线程局部变量。</p> </td></tr></tbody></table> 
<pre class="has"><code>package java.lang;
import java.lang.ref.*;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Supplier;

public class ThreadLocal&lt;T&gt; {

    private final int threadLocalHashCode = nextHashCode();

    private static AtomicInteger nextHashCode =
        new AtomicInteger();

    private static final int HASH_INCREMENT = 0x61c88647;

    private static int nextHashCode() {
        return nextHashCode.getAndAdd(HASH_INCREMENT);
    }

    protected T initialValue() {
        return null;
    }

    public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) {
        return new SuppliedThreadLocal&lt;&gt;(supplier);
    }

    public ThreadLocal() {
    }

    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }	
	
    private T setInitialValue() {
        T value = initialValue();
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
        return value;
    }	
	
    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }	
	
     public void remove() {
         ThreadLocalMap m = getMap(Thread.currentThread());
         if (m != null)
             m.remove(this);
     }	
	
    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }	
	
    void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }	
	
    static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) {
        return new ThreadLocalMap(parentMap);
    }

    T childValue(T parentValue) {
        throw new UnsupportedOperationException();
    }

    static final class SuppliedThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; {

        private final Supplier&lt;? extends T&gt; supplier;

        SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) {
            this.supplier = Objects.requireNonNull(supplier);
        }

        @Override
        protected T initialValue() {
            return supplier.get();
        }
    }

    static class ThreadLocalMap {

        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal&lt;?&gt; k, Object v) {
                super(k);
                value = v;
            }
        }

        private static final int INITIAL_CAPACITY = 16;

        private Entry[] table;

        /**
         * The number of entries in the table.
         */
        private int size = 0;

        /**
         * The next size value at which to resize.
         */
        private int threshold; // Default to 0

        /**
         * Set the resize threshold to maintain at worst a 2/3 load factor.
         */
        private void setThreshold(int len) {
            threshold = len * 2 / 3;
        }

        /**
         * Increment i modulo len.
         */
        private static int nextIndex(int i, int len) {
            return ((i + 1 &lt; len) ? i + 1 : 0);
        }

        /**
         * Decrement i modulo len.
         */
        private static int prevIndex(int i, int len) {
            return ((i - 1 &gt;= 0) ? i - 1 : len - 1);
        }

        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {
            table = new Entry[INITIAL_CAPACITY];
            int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);
            table[i] = new Entry(firstKey, firstValue);
            size = 1;
            setThreshold(INITIAL_CAPACITY);
        }
		
        private ThreadLocalMap(ThreadLocalMap parentMap) {
            Entry[] parentTable = parentMap.table;
            int len = parentTable.length;
            setThreshold(len);
            table = new Entry[len];

            for (int j = 0; j &lt; len; j++) {
                Entry e = parentTable[j];
                if (e != null) {
                    @SuppressWarnings("unchecked")
                    ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();
                    if (key != null) {
                        Object value = key.childValue(e.value);
                        Entry c = new Entry(key, value);
                        int h = key.threadLocalHashCode &amp; (len - 1);
                        while (table[h] != null)
                            h = nextIndex(h, len);
                        table[h] = c;
                        size++;
                    }
                }
            }
        }		
		
        private Entry getEntry(ThreadLocal&lt;?&gt; key) {
            int i = key.threadLocalHashCode &amp; (table.length - 1);
            Entry e = table[i];
            if (e != null &amp;&amp; e.get() == key)
                return e;
            else
                return getEntryAfterMiss(key, i, e);
        }		
		
        private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {
            Entry[] tab = table;
            int len = tab.length;

            while (e != null) {
                ThreadLocal&lt;?&gt; k = e.get();
                if (k == key)
                    return e;
                if (k == null)
                    expungeStaleEntry(i);
                else
                    i = nextIndex(i, len);
                e = tab[i];
            }
            return null;
        }		
		
        private void set(ThreadLocal&lt;?&gt; key, Object value) {
            Entry[] tab = table;
            int len = tab.length;
            int i = key.threadLocalHashCode &amp; (len-1);

            for (Entry e = tab[i];
                 e != null;
                 e = tab[i = nextIndex(i, len)]) {
                ThreadLocal&lt;?&gt; k = e.get();

                if (k == key) {
                    e.value = value;
                    return;
                }

                if (k == null) {
                    replaceStaleEntry(key, value, i);
                    return;
                }
            }

            tab[i] = new Entry(key, value);
            int sz = ++size;
            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
                rehash();
        }		
		
        private void remove(ThreadLocal&lt;?&gt; key) {
            Entry[] tab = table;
            int len = tab.length;
            int i = key.threadLocalHashCode &amp; (len-1);
            for (Entry e = tab[i];
                 e != null;
                 e = tab[i = nextIndex(i, len)]) {
                if (e.get() == key) {
                    e.clear();
                    expungeStaleEntry(i);
                    return;
                }
            }
        }		
		
        private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,
                                       int staleSlot) {
            Entry[] tab = table;
            int len = tab.length;
            Entry e;
            int slotToExpunge = staleSlot;
            for (int i = prevIndex(staleSlot, len);
                 (e = tab[i]) != null;
                 i = prevIndex(i, len))
                if (e.get() == null)
                    slotToExpunge = i;

            for (int i = nextIndex(staleSlot, len);
                 (e = tab[i]) != null;
                 i = nextIndex(i, len)) {
                ThreadLocal&lt;?&gt; k = e.get();		
                if (k == key) {
                    e.value = value;

                    tab[i] = tab[staleSlot];
                    tab[staleSlot] = e;

                    // Start expunge at preceding stale entry if it exists
                    if (slotToExpunge == staleSlot)
                        slotToExpunge = i;
                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
                    return;
                }

                if (k == null &amp;&amp; slotToExpunge == staleSlot)
                    slotToExpunge = i;
            }

            // If key not found, put new entry in stale slot
            tab[staleSlot].value = null;
            tab[staleSlot] = new Entry(key, value);

            // If there are any other stale entries in run, expunge them
            if (slotToExpunge != staleSlot)
                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
        }		
		
        private int expungeStaleEntry(int staleSlot) {
            Entry[] tab = table;
            int len = tab.length;

            // expunge entry at staleSlot
            tab[staleSlot].value = null;
            tab[staleSlot] = null;
            size--;

            // Rehash until we encounter null
            Entry e;
            int i;
            for (i = nextIndex(staleSlot, len);
                 (e = tab[i]) != null;
                 i = nextIndex(i, len)) {
                ThreadLocal&lt;?&gt; k = e.get();
                if (k == null) {
                    e.value = null;
                    tab[i] = null;
                    size--;
                } else {
                    int h = k.threadLocalHashCode &amp; (len - 1);
                    if (h != i) {
                        tab[i] = null;

                        // Unlike Knuth 6.4 Algorithm R, we must scan until
                        // null because multiple entries could have been stale.
                        while (tab[h] != null)
                            h = nextIndex(h, len);
                        tab[h] = e;
                    }
                }
            }
            return i;
        }		

        private boolean cleanSomeSlots(int i, int n) {
            boolean removed = false;
            Entry[] tab = table;
            int len = tab.length;
            do {
                i = nextIndex(i, len);
                Entry e = tab[i];
                if (e != null &amp;&amp; e.get() == null) {
                    n = len;
                    removed = true;
                    i = expungeStaleEntry(i);
                }
            } while ( (n &gt;&gt;&gt;= 1) != 0);
            return removed;
        }

        private void rehash() {
            expungeStaleEntries();

            // Use lower threshold for doubling to avoid hysteresis
            if (size &gt;= threshold - threshold / 4)
                resize();
        }

        private void resize() {
            Entry[] oldTab = table;
            int oldLen = oldTab.length;
            int newLen = oldLen * 2;
            Entry[] newTab = new Entry[newLen];
            int count = 0;

            for (int j = 0; j &lt; oldLen; ++j) {
                Entry e = oldTab[j];
                if (e != null) {
                    ThreadLocal&lt;?&gt; k = e.get();
                    if (k == null) {
                        e.value = null; // Help the GC
                    } else {
                        int h = k.threadLocalHashCode &amp; (newLen - 1);
                        while (newTab[h] != null)
                            h = nextIndex(h, newLen);
                        newTab[h] = e;
                        count++;
                    }
                }
            }

            setThreshold(newLen);
            size = count;
            table = newTab;
        }

        /**
         * Expunge all stale entries in the table.
         */
        private void expungeStaleEntries() {
            Entry[] tab = table;
            int len = tab.length;
            for (int j = 0; j &lt; len; j++) {
                Entry e = tab[j];
                if (e != null &amp;&amp; e.get() == null)
                    expungeStaleEntry(j);
            }
        }
    }
}		</code></pre> 
<p>一个<code>int</code>可能原子更新的值。 有关原子变量属性的描述，请参阅<a href="../../../../java/util/concurrent/atomic/package-summary.html" rel="nofollow"><code>java.util.concurrent.atomic</code></a>包规范。 一个<code>AtomicInteger</code>用于诸如原子增量计数器的应用程序中，不能用作<code>Integer</code>的<a href="../../../../java/lang/Integer.html" rel="nofollow">替代品</a> 。 但是，这个类确实扩展了<code>Number</code>以允许通过处理基于数字类的工具和实用程序的统一访问。</p> 
<table border="0" cellpadding="3" cellspacing="0"><tbody><tr><th>Modifier and Type</th><th>Method and Description</th></tr><tr><td><code>int</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#accumulateAndGet-int-java.util.function.IntBinaryOperator-" rel="nofollow">accumulateAndGet</a>(int x, <a href="../../../../java/util/function/IntBinaryOperator.html" rel="nofollow">IntBinaryOperator</a> accumulatorFunction)</code> <p>使用将给定函数应用于当前值和给定值的结果原子更新当前值，返回更新后的值。</p> </td></tr><tr><td><code>int</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#addAndGet-int-" rel="nofollow">addAndGet</a>(int delta)</code> <p>将给定的值原子地添加到当前值。</p> </td></tr><tr><td><code>boolean</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#compareAndSet-int-int-" rel="nofollow">compareAndSet</a>(int expect, int update)</code> <p>如果当前值 <code>==</code>为预期值，则将该值原子设置为给定的更新值。</p> </td></tr><tr><td><code>int</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#decrementAndGet--" rel="nofollow">decrementAndGet</a>()</code> <p>原子减1当前值。</p> </td></tr><tr><td><code>double</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#doubleValue--" rel="nofollow">doubleValue</a>()</code> <p>返回此值 <code>AtomicInteger</code>为 <code>double</code>一个宽元转换后。</p> </td></tr><tr id="i5"><td><code>float</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#floatValue--" rel="nofollow">floatValue</a>()</code> <p>返回此值 <code>AtomicInteger</code>为 <code>float</code>一个宽元转换后。</p> </td></tr><tr id="i6"><td><code>int</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#get--" rel="nofollow">get</a>()</code> <p>获取当前值。</p> </td></tr><tr id="i7"><td><code>int</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#getAndAccumulate-int-java.util.function.IntBinaryOperator-" rel="nofollow">getAndAccumulate</a>(int x, <a href="../../../../java/util/function/IntBinaryOperator.html" rel="nofollow">IntBinaryOperator</a> accumulatorFunction)</code> <p>使用给定函数应用给当前值和给定值的结果原子更新当前值，返回上一个值。</p> </td></tr><tr id="i8"><td><code>int</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#getAndAdd-int-" rel="nofollow">getAndAdd</a>(int delta)</code> <p>将给定的值原子地添加到当前值。</p> </td></tr><tr id="i9"><td><code>int</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#getAndDecrement--" rel="nofollow">getAndDecrement</a>()</code> <p>原子减1当前值。</p> </td></tr><tr id="i10"><td><code>int</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#getAndIncrement--" rel="nofollow">getAndIncrement</a>()</code> <p>原子上增加一个当前值。</p> </td></tr><tr id="i11"><td><code>int</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#getAndSet-int-" rel="nofollow">getAndSet</a>(int newValue)</code> <p>将原子设置为给定值并返回旧值。</p> </td></tr><tr id="i12"><td><code>int</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#getAndUpdate-java.util.function.IntUnaryOperator-" rel="nofollow">getAndUpdate</a>(<a href="../../../../java/util/function/IntUnaryOperator.html" rel="nofollow">IntUnaryOperator</a> updateFunction)</code> <p>用应用给定函数的结果原子更新当前值，返回上一个值。</p> </td></tr><tr id="i13"><td><code>int</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#incrementAndGet--" rel="nofollow">incrementAndGet</a>()</code> <p>原子上增加一个当前值。</p> </td></tr><tr id="i14"><td><code>int</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#intValue--" rel="nofollow">intValue</a>()</code> <p>将 <code>AtomicInteger</code>的值作为 <code>int</code> 。</p> </td></tr><tr id="i15"><td><code>void</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#lazySet-int-" rel="nofollow">lazySet</a>(int newValue)</code> <p>最终设定为给定值。</p> </td></tr><tr id="i16"><td><code>long</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#longValue--" rel="nofollow">longValue</a>()</code> <p>返回此值 <code>AtomicInteger</code>为 <code>long</code>一个宽元转换后。</p> </td></tr><tr id="i17"><td><code>void</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#set-int-" rel="nofollow">set</a>(int newValue)</code> <p>设置为给定值。</p> </td></tr><tr id="i18"><td><code><a href="../../../../java/lang/String.html" rel="nofollow">String</a></code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#toString--" rel="nofollow">toString</a>()</code> <p>返回当前值的String表示形式。</p> </td></tr><tr id="i19"><td><code>int</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#updateAndGet-java.util.function.IntUnaryOperator-" rel="nofollow">updateAndGet</a>(<a href="../../../../java/util/function/IntUnaryOperator.html" rel="nofollow">IntUnaryOperator</a> updateFunction)</code> <p>使用给定函数的结果原子更新当前值，返回更新的值。</p> </td></tr><tr id="i20"><td><code>boolean</code></td><td><code><a href="../../../../java/util/concurrent/atomic/AtomicInteger.html#weakCompareAndSet-int-int-" rel="nofollow">weakCompareAndSet</a>(int expect, int update)</code> <p>如果当前值 <code>==</code>为预期值，则将值设置为给定更新值。</p> </td></tr></tbody></table> 
<pre class="has"><code>package java.util.concurrent.atomic;
import java.util.function.IntUnaryOperator;
import java.util.function.IntBinaryOperator;
import sun.misc.Unsafe;

public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    private volatile int value;

    public AtomicInteger(int initialValue) {
        value = initialValue;
    }

    public AtomicInteger() {
    }

    public final int get() {
        return value;
    }

    public final void set(int newValue) {
        value = newValue;
    }

    public final void lazySet(int newValue) {
        unsafe.putOrderedInt(this, valueOffset, newValue);
    }

    public final int getAndSet(int newValue) {
        return unsafe.getAndSetInt(this, valueOffset, newValue);
    }

    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }

    public final boolean weakCompareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }

    public final int getAndIncrement() {
        return unsafe.getAndAddInt(this, valueOffset, 1);
    }

    public final int getAndDecrement() {
        return unsafe.getAndAddInt(this, valueOffset, -1);
    }

    public final int getAndAdd(int delta) {
        return unsafe.getAndAddInt(this, valueOffset, delta);
    }

    public final int incrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
    }


    public final int decrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, -1) - 1;
    }


    public final int addAndGet(int delta) {
        return unsafe.getAndAddInt(this, valueOffset, delta) + delta;
    }

    public final int getAndUpdate(IntUnaryOperator updateFunction) {
        int prev, next;
        do {
            prev = get();
            next = updateFunction.applyAsInt(prev);
        } while (!compareAndSet(prev, next));
        return prev;
    }

    public final int updateAndGet(IntUnaryOperator updateFunction) {
        int prev, next;
        do {
            prev = get();
            next = updateFunction.applyAsInt(prev);
        } while (!compareAndSet(prev, next));
        return next;
    }

    public final int getAndAccumulate(int x,
                                      IntBinaryOperator accumulatorFunction) {
        int prev, next;
        do {
            prev = get();
            next = accumulatorFunction.applyAsInt(prev, x);
        } while (!compareAndSet(prev, next));
        return prev;
    }

    public final int accumulateAndGet(int x,
                                      IntBinaryOperator accumulatorFunction) {
        int prev, next;
        do {
            prev = get();
            next = accumulatorFunction.applyAsInt(prev, x);
        } while (!compareAndSet(prev, next));
        return next;
    }

    public String toString() {
        return Integer.toString(get());
    }

    public int intValue() {
        return get();
    }

    public long longValue() {
        return (long)get();
    }

    public float floatValue() {
        return (float)get();
    }
    public double doubleValue() {
        return (double)get();
    }

}</code></pre> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bc8761127fe96e8db9aa850a3234949d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python3 http server服务器 上传文件功能实现 upload file</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/164b86cdf01328109acf9e86240ffa46/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VSCode设置默认打开的浏览器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>