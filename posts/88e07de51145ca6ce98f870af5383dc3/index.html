<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>1-3年的java面试题，持续更新中ing - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="1-3年的java面试题，持续更新中ing" />
<meta property="og:description" content="0.String字符串的比较，new string（）和 String str = “”区别，intern()在jdk不同版本中的差异？ String的intern（）的理解
1. 谈谈final, finally, finalize的区别 性质不同
final为关键字；finalize()为方法；finally为区块标志，用于try语句中； 作用
final为用于标识常量的关键字，final标识的关键字存储在常量池中（在这里final常量的具体用法将在下面进行介绍）；finalize()方法在Object中进行了定义，用于在对象“消失”时，由JVM进行调用用于对对象进行垃圾回收，类似于C&#43;&#43;中的析构函数；用户自定义时，用于释放对象占用的资源（比如进行I/0操作）；finally{}用于标识代码块，与try{}进行配合，不论try中的代码执行完或没有执行完（这里指有异常），该代码块之中的程序必定会进行； final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载
finally—再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）
finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的
2. java中创建线程的方法有几种，都有哪些？怎么创建？ 更加详细内容，点击链接
有四种方法，
1）继承Thread类创建线程
2）实现Runnable接口创建线程
3）使用Callable和Future创建线程
4）使用线程池
谈谈对线程池的理解
3. sleep（）和wait（）的区别？ 相同点：
一旦执行方法，都可以使得当前的线程进入阻塞状态。
不同点：
1.两个方法的声明位置不同，Thread类中声明sleep（），Object类中声明wait()
2.调用的要求不同，sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块和同步方法中使用。
3.关于是否释放同步监视器，如果两个方法都使用在同步代码块或者同步方法中，sleep()不会释放锁，wait()会释放锁。
对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。
sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。
在调用sleep()方法的过程中，线程不会释放对象锁。
而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备
从使用角度看，sleep是Thread线程类的方法，而wait是Object顶级类的方法。
sleep可以在任何地方使用，而wait只能在同步方法或者同步块中使用。
CPU及资源锁释放
sleep,wait调用后都会暂停当前线程并让出cpu的执行时间，但不同的是sleep不会释放当前持有的对象的锁资源，到时间后会继续执行，而wait会放弃所有锁并需要notify/notifyAll后重新获取到对象锁资源后才能继续执行。
sleep和wait的区别：
1、sleep是Thread的静态方法，wait是Object的方法，任何对象实例都能调用。
2、sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁(即代码要在synchronized中)。
3、它们都可以被interrupted方法中断。
4. 面试题：对比String、StringBuffer、StringBuilder String(JDK1.0)：不可变字符序列
StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全
StringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全
注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/88e07de51145ca6ce98f870af5383dc3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-30T15:25:53+08:00" />
<meta property="article:modified_time" content="2022-06-30T15:25:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">1-3年的java面试题，持续更新中ing</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="0Stringnew_string_String_str__internjdk_0"></a>0.String字符串的比较，new string（）和 String str = “”区别，intern()在jdk不同版本中的差异？</h3> 
<p><a href="https://blog.csdn.net/qq_2662385590/article/details/124102956?spm=1001.2014.3001.5502">String的intern（）的理解</a></p> 
<h3><a id="1_final_finally_finalize_2"></a>1. 谈谈final, finally, finalize的区别</h3> 
<p><strong>性质不同</strong></p> 
<ol><li>final为关键字；</li><li>finalize()为方法；</li><li>finally为区块标志，用于try语句中；</li></ol> 
<p><strong>作用</strong></p> 
<ol><li>final为用于标识常量的关键字，final标识的关键字存储在常量池中（在这里final常量的具体用法将在下面进行介绍）；</li><li>finalize()方法在Object中进行了定义，用于在对象“消失”时，由JVM进行调用用于对对象进行垃圾回收，类似于C++中的析构函数；用户自定义时，用于释放对象占用的资源（比如进行I/0操作）；</li><li>finally{}用于标识代码块，与try{}进行配合，不论try中的代码执行完或没有执行完（这里指有异常），该代码块之中的程序必定会进行；</li></ol> 
<p>final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载</p> 
<p>finally—再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）</p> 
<p>finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的</p> 
<h3><a id="2_java_20"></a>2. java中创建线程的方法有几种，都有哪些？怎么创建？</h3> 
<p><a href="https://blog.csdn.net/qq_2662385590/article/details/109943328">更加详细内容，点击链接</a></p> 
<p>有四种方法，<br> 1）继承Thread类创建线程</p> 
<p>2）实现Runnable接口创建线程</p> 
<p>3）使用Callable和Future创建线程</p> 
<p>4）使用线程池</p> 
<p><a href="https://blog.csdn.net/qq_2662385590/article/details/124026058">谈谈对线程池的理解</a></p> 
<h3><a id="3_sleepwait_35"></a>3. sleep（）和wait（）的区别？</h3> 
<p>相同点：<br> 一旦执行方法，都可以使得当前的线程进入阻塞状态。<br> 不同点：<br> 1.两个方法的声明位置不同，Thread类中声明sleep（），Object类中声明wait()<br> 2.调用的要求不同，sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块和同步方法中使用。<br> 3.关于是否释放同步监视器，如果两个方法都使用在同步代码块或者同步方法中，sleep()不会释放锁，wait()会释放锁。</p> 
<p>对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。</p> 
<p>sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。</p> 
<p>在调用sleep()方法的过程中，线程不会释放对象锁。</p> 
<p>而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备</p> 
<p>从使用角度看，sleep是Thread线程类的方法，而wait是Object顶级类的方法。</p> 
<p>sleep可以在任何地方使用，而wait只能在同步方法或者同步块中使用。</p> 
<p>CPU及资源锁释放</p> 
<p>sleep,wait调用后都会暂停当前线程并让出cpu的执行时间，但不同的是sleep不会释放当前持有的对象的锁资源，到时间后会继续执行，而wait会放弃所有锁并需要notify/notifyAll后重新获取到对象锁资源后才能继续执行。</p> 
<p>sleep和wait的区别：<br> 1、sleep是Thread的静态方法，wait是Object的方法，任何对象实例都能调用。<br> 2、sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁(即代码要在synchronized中)。<br> 3、它们都可以被interrupted方法中断。</p> 
<h3><a id="4_StringStringBufferStringBuilder_68"></a>4. 面试题：对比String、StringBuffer、StringBuilder</h3> 
<p>String(JDK1.0)：不可变字符序列<br> StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全<br> StringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全<br> 注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。</p> 
<h3><a id="5nginx_76"></a>5.反向代理与正向代理的区别详解与nginx的负载均衡</h3> 
<p><strong>正向代理：顾名思义 客户端发出请求 找到代理服务器 由代理服务器发出真正的请求给真正的服务器 获得响应后 再把数据返回给客户端。</strong><br> 用同一个通俗的例子来解释 就是A想找C借钱 但是C嫌弃A人品不行 于是A找到人品较好的B 由B发出请求找C借钱，借钱给B，B拿到钱之后再把钱转交给A。从始至终C都不知道要把钱给A(因为他要是知道是A借的就不会借了)</p> 
<p><strong>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。</strong></p> 
<p><strong>反向代理：最经典的例子就是nginx 客户端之间找到nginx服务器 由nginx访问真正的服务器 nginx拿到数据之后再把结果返回给客户端。</strong><br> 再举一个栗子<br> 大家访问百度这个域名 www.baidu.com 百度真正的服务器地址我们不需要关心 因为他是由反向代理得来的 我们只需要知道百度这个域名 他就可以自动帮我们转接到真正的服务器 自始至终我们都不需要知道百度服务器真正地址的存在 。<br> 你去超市买东西，超时就是代理服务器，你只和超市有联系，但是超市实际上是从各个供应商拿的商品，但你和供应商没关系。</p> 
<p><strong>nginx还有一个重要作用就是负载均衡 但很多客户端访问地址的时候可以减缓服务器的压力 当三个人访问都是www.baoidu.com这个域名 nginx可以把这三个人的访问请求量分摊到百度的三个服务器上 不用一个服务器处理三个请求 而是三个服务器一个服务器处理一个请求 。</strong></p> 
<h3><a id="6_MVCC_89"></a>6. 什么是MVCC?</h3> 
<p><strong>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 并发控制</strong> 。这项技术使得在InnoDB的事务隔离级别下执行 一致性读 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。<br> MVCC在MySQL InnoDB中的实现<strong>主要是为了提高数据库并发性能，用更好的方式去处理 读-写冲突 ，做到即使有读写冲突时，也能做到 不加锁 ， 非阻塞并发读 ，而这个读指的就是 快照读 , 而非 当前读 。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式</strong>。</p> 
<p><strong>MVCC的实现依赖于：隐藏字段、Undo Log版本链，ReadView实现。</strong><br> <img src="https://images2.imgbox.com/6e/11/6zDyUvUK_o.png" alt="在这里插入图片描述"><br> <strong>ReadView的设计思路</strong><br> <img src="https://images2.imgbox.com/f1/43/Kt4RQc33_o.png" alt="在这里插入图片描述"><br> <strong>ReadView的规则</strong><br> <img src="https://images2.imgbox.com/a7/74/1syX4gsS_o.png" alt="在这里插入图片描述"><br> <strong>总结：</strong><br> <img src="https://images2.imgbox.com/fb/fe/FPTo4sc0_o.png" alt="在这里插入图片描述"><br> <a href="https://blog.csdn.net/qq_2662385590/article/details/124770059?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22124770059%22,%22source%22:%22qq_2662385590%22%7D&amp;ctrtid=4PPj3">详细介绍MVCC文章</a></p> 
<h3><a id="7BTree_102"></a>7.聚簇索引（B+Tree）</h3> 
<p>聚簇索引就是按照每张表的主键构造一颗B+树，<strong>同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页</strong>。<br> <img src="https://images2.imgbox.com/e8/e4/HUY3CkWK_o.png" alt="在这里插入图片描述"></p> 
<p>聚簇索引的特点，优点和缺点，以及限制如下：<br> <img src="https://images2.imgbox.com/2f/1f/1EOfbcaQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fb/89/YRdOAMsJ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="8__111"></a>8. 二级索引（辅助索引、非聚簇索引）</h3> 
<p><strong>二级索引的叶子节点存放的是主键值或指向数据行的指针。</strong><br> <strong>二级索引和聚簇索引主要区别就是叶子结点存放是否一个完整的一行数据，二级索引存放是指向聚簇索引的指针。</strong><br> <img src="https://images2.imgbox.com/0b/e0/CCldUCEM_o.png" alt="在这里插入图片描述"><br> <strong>什么是回表？</strong><br> 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！<br> <img src="https://images2.imgbox.com/4a/76/mosAgNqh_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="9_118"></a>9.聚簇索引和二级索引的区别</h3> 
<p><img src="https://images2.imgbox.com/1b/07/0dQrwekf_o.png" alt="在这里插入图片描述"><br> <strong>聚簇索引的叶子节点存储的是每一个行的数据。<br> 二级索引的叶子节点存储的是每个聚簇索引的主键和构成二级索引的key。</strong><br> <img src="https://images2.imgbox.com/4b/e3/chTyS8fq_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="10BB_123"></a>10.B+与B树的区别</h3> 
<p>下面是B树的图：<br> <img src="https://images2.imgbox.com/9d/23/zNfKqRKb_o.png" alt="在这里插入图片描述"><br> B+ 树和 B 树的差异：</p> 
<ol><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数+1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非叶子节点既保存索引，也保存数据记录 。</li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li></ol> 
<p><strong>B+树的中间节点并不直接存储数据，这样的好处都有什么呢？</strong><br> <strong>首先，B+树查询效率更稳定</strong>。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。<br> <strong>其次，B+树的查询效率更高</strong>。这是因为通常B+树比B树更矮胖（阶数更大，深度更低），查询所需要的磁盘I/0也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。<br> **不仅是对单个关键字的查询上，在查询范围上，B+树的效率也比B树高。**这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p> 
<h3><a id="11B13IO_137"></a>11.B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘I/O?</h3> 
<p><img src="https://images2.imgbox.com/25/7e/boPiMdQr_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="12Hash__B__139"></a>12.Hash 索引与 B+ 树索引的区别?</h3> 
<p><img src="https://images2.imgbox.com/82/89/VYh4Jvcd_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="13_141"></a>13.数据库优化的步骤</h3> 
<p>整个流程划分成了 观察（Show status） 和 行动（Action） 两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。<br> <img src="https://images2.imgbox.com/35/be/T3ZnHMh6_o.png" alt="在这里插入图片描述"></p> 
<ol><li> <p>我们先观察服务器的状态，看是否周期性波动（比如双十一），我们可以使用缓存技术。</p> </li><li> <p>如果加上缓存任然是延迟卡顿，我可以开启SQL慢查询日志，修改long_query_time阈值（默认是10秒），找到慢查询日志文件，使用慢查询日志分析工具mysqldumpslow进行分析，找到执行较慢的SQL语句。<br> <img src="https://images2.imgbox.com/91/bd/QtJHE4Yk_o.png" alt="在这里插入图片描述"></p> </li><li> <p>找到执行比较慢的SQL语句，如果是SQL等待的时间比较长，调优服务器参数，如果是SQL执行时间长，使用分析查询语句EXPLAIN，进行索引优化，数据设计优化等等。</p> </li></ol> 
<p>EXPLAIN 语句输出的各个列的作用如下：<br> <img src="https://images2.imgbox.com/1f/2f/I1BNaOaS_o.png" alt="在这里插入图片描述"></p> 
<ol start="4"><li>如果是SQL语句查询达到瓶颈，我们就需要考虑，主从框架，读写分离，分库分表等等。</li></ol> 
<h3><a id="14_155"></a>14.什么是微服务？微服务架构的优缺点、应用？</h3> 
<p>微服务架构有别于更为传统的单体式方案，可将应用拆分成多个核心功能。每个功能都被称为一项服务，可以单独构建和部署，这意味着各项服务在工作（和出现故障）时不会相互影响。</p> 
<p>优点：<br> 1.<strong>易于开发和维护</strong>：<strong>一个服务只关注一个特定的业务功能，所以它业务清晰，代码量少</strong>。开发和维护单个微服务相当简单。而整个应用是若干个微服务构建而成的，所以整个应用在被维持在一个可控的状态；<br> 2.<strong>局部修改易部署</strong>：<strong>单个应用只要有修改，就得重新部署整个应用，微服务解决了这个问题</strong>。一般来说，对某个微服务进行修改，只需要重新部署这个服务即可；<br> 3.<strong>技术栈不受限</strong>：<strong>在微服务架构中，可以结合业务和团队的特点,合理选用技术栈</strong>。例如有些服务可以使用关系型数据库Mysql，有的服务可以使用非关系型数据库redis。甚至可根据需求，部分服务使用JAVA开发，部分微服务使用Node.js开发<br> 4.<strong>按需收缩</strong>：<strong>可根据需求，实现细粒度的扩展</strong>。例如，系统中的某个微服务遇到了瓶颈，可以结合微服务的特点，增加内存，升级CPU或增加节点。<br> 缺点：<br> 1.<strong>微服务过多，治理成本高，不利于维护系统</strong><br> 2.<strong>分布式系统开发的成本高（容错，分布式事务等）对团队挑战大</strong><br> 3.<strong>性能降低，网络延迟</strong>。<br> 4.<strong>接口调整成本高：微服务之间通过接口进行通信</strong></p> 
<h3><a id="15_168"></a>15.缓存穿透？缓存击穿？缓存雪崩？解决方案？</h3> 
<p><strong>缓存穿透</strong><br> key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。<br> <img src="https://images2.imgbox.com/4a/0f/qHAtvm8r_o.png" alt="在这里插入图片描述"></p> 
<p>解决方案：<br> （1） 对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟<br> （2） 设置可访问的名单（白名单）：<br> 使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。<br> （3） 采用布隆过滤器：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</p> 
<p><strong>缓存击穿</strong><br> key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。<br> <img src="https://images2.imgbox.com/20/cc/iojAPPeW_o.png" alt="在这里插入图片描述"></p> 
<p>解决方案：</p> 
<ol><li>让热点的数据的缓存永不过期。</li><li>采用分布式锁，缓存失效后只有一个线程更新并写入。</li></ol> 
<p><strong>缓存雪崩</strong><br> key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key<br> 正常访问缓存失效瞬间<br> <img src="https://images2.imgbox.com/3b/4f/DlGSyoKQ_o.png" alt="在这里插入图片描述"><br> 解决方案：<br> （1） 构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等）<br> （2） 使用锁或队列：用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况<br> （3） 设置过期标志更新缓存：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。<br> （4） 将缓存失效时间分散开：比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p> 
<h3><a id="16synchronized__Lock__196"></a>16.synchronized 和 Lock 有什么区别？</h3> 
<p> 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</p> 
<p> synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</p> 
<p> synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</p> 
<p> 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</p> 
<p> synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</p> 
<p> Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</p> 
<h3><a id="17spring_209"></a>17.spring事务的传播行为</h3> 
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。事务的传播行为可以由传播属性指定。<br> Spring定义了7种类传播行为:<br> <img src="https://images2.imgbox.com/f6/98/KMDTTBFZ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="18_213"></a>18.谈谈动态代理模式</h3> 
<p>什么是动态代理?<br> 动态代理就是，在程序运行期，创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术。在生成代理对象的过程中，目标对象不变，代理对象中的方法是目标对象方法的增强方法。可以理解为运行期间，对象中方法的动态拦截，在拦截方法的前后执行功能操作。</p> 
<h3><a id="19ThreadLocal_216"></a>19.谈谈ThreadLocal理解</h3> 
<p><a href="https://blog.csdn.net/weixin_44050144/article/details/113061884">最详细的ThreadLocal介绍</a></p> 
<h3><a id="20spring_219"></a>20.spring的循环依赖</h3> 
<p><strong>spring内部通过3级缓存来解决循环依赖 - DefaultSingletonBeanRegistry</strong></p> 
<p>只有单例的bean会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中。</p> 
<p>第一级缓存（也叫单例池）singletonObjects：存放已经经历了完整生命周期的Bean对象。<br> 第二级缓存：earlySingletonObjects，存放早期暴露出来的Bean对象，Bean的生命周期未结束（属性还未填充完。<br> 第三级缓存：Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories，存放可以生成Bean的工厂。<br> <img src="https://images2.imgbox.com/3b/d7/Ns8OZDb5_o.png" alt="在这里插入图片描述"><br> 举例说明：<br> A / B两对象在三级缓存中的迁移说明</p> 
<ol><li>A创建过程中需要B，于是A将自己放到三级缓里面，去实例化B。</li><li>B实例化的时候发现需要A，于是B先查一级缓存，没有，再查二级缓存，还是没有，再查三级缓存，找到了A然后把三级缓存里面的这个A放到二级缓存里面，并删除三级缓存里面的A。</li><li>B顺利初始化完毕，将自己放到一级缓存里面（此时B里面的A依然是创建中状态)，然后回来接着创建A，此时B已经创建结束，直接从一级缓存里面拿到B，然后完成创建，并将A自己放到一级缓存里面。<br> <a href="https://blog.csdn.net/u011863024/article/details/115270840#10_LockSupport_466">详细过程参考这个链接</a></li></ol> 
<h3><a id="21Redis_235"></a>21.Redis加锁的演变过程（从单机到分布式）</h3> 
<p>下面我们以某个商品超卖现象进行加锁解决的过程：</p> 
<ol><li>在单机模式下，单机版的锁synchronized和ReentraLock锁，（<a href="https://blog.csdn.net/qq_2662385590/article/details/124430244">synchronized和ReentraLock锁的区别）</a>可以解决超卖问题。<br> synchronized和ReentraLock锁的区别，在锁的方法，synchronized为死等，而ReentraLock可以控制等待的时间，如使用tryLock()方法，可以控制时间。</li><li>有分布式以后，有出现了超卖现象，我们使用JMeter工具进行测试<br> 解决方案：使用setnx加上try/catch/finally可以解决，但是又出现了新的问题<br> 如果部署微服务jar包的机器宕机了，代码层次没有运行到finally这块，没有解锁。</li><li>如果出现上面异常的话，没办法保证解锁，这个key没有被删除，需要加入一个过期时间限定key。</li><li>设置key+过期时间分开了，必须要合并成一行具备<strong>原子性</strong>。比如stringRedisTemplate.opsForValue() .setIfAbsent(REDIS_LOCK, value, 10L, TimeUnit.SECONDS);<br> 另一个新问题：张冠李戴，删除了别人的锁，如果进程A，设置了加锁10秒钟，而且进程A的业务逻辑代码比较耗时，超过了10秒钟，结果过了时间自动删除了锁，有进来一个进程B，拿到锁进行业务代码，此时进程A 进行解锁，就把进程B的锁给删了。</li><li>解决上面的方法，只能自己删除自己的，不许动别人的。我们可以在finally块的判断 + del删除操作，同样finally块的判断 + del删除操作要是原子操作。可以使用<strong>用lua脚本或者用redis自身的事务</strong>。</li><li>还有一个锁的续期问题？确保RedisLock过期时间大于业务执行时间的问题。锁的续期我们使用<strong>Redisson技术</strong>进行解决，（同样可以解决上面的所有的问题）。</li><li>同样为了让代码变得更加严谨，我们在释放锁的时候加一些判断</li></ol> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> REDIS_LOCK <span class="token operator">=</span> <span class="token string">"REDIS_LOCK"</span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">private</span> <span class="token class-name">Redisson</span> redisson<span class="token punctuation">;</span>

<span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/doSomething"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token class-name">RLock</span> redissonLock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span>REDIS_LOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>
    redissonLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//doSomething</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">//添加后，更保险</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>redissonLock<span class="token punctuation">.</span><span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> redissonLock<span class="token punctuation">.</span><span class="token function">isHeldByCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    		redissonLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>lock.isLocked()：判断要解锁的key是否已被锁定。<br> lock.isHeldByCurrentThread()：判断要解锁的key是否被当前线程持有。</p> 
<p>主要是为了避免一下异常的出现：</p> 
<pre><code class="prism language-java"><span class="token class-name">IllegalMonitorStateException</span><span class="token operator">:</span> attempt <span class="token keyword">to</span> <span class="token namespace">unlock</span> lock，not loked by current thread by node id<span class="token operator">:</span>da6385f<span class="token operator">-</span><span class="token number">81</span>a5<span class="token operator">-</span><span class="token number">4e6</span>c<span class="token operator">-</span>b8c0

</code></pre> 
<h3><a id="22_Redis_280"></a>22. Redis内存淘汰策略</h3> 
<p>redis过期键的删除策略<br> 请问一下如果一个键是过期的，那它到了过期时间之后是不是马上就从内存中被被删除呢？<br> <strong>不是马上删除的</strong>，那过期后到底什么时候被删除呢？？是个什么操作？（接下里听我细细道来）</p> 
<p>三种不同的删除策略</p> 
<ol><li>定时删除 - 总结：对CPU不友好，用处理器性能换取存储空间（拿时间换空间）</li><li>惰性删除 - 总结：对memory不友好，用存储空间换取处理器性能（拿空间换时间）</li><li>定期删除 - 上面两种方案都走极端 - 定期删除 - 定期抽样key，判断是否过期（存在漏网之鱼）定期删除策略是前两种策略的折中。</li></ol> 
<p><strong>定时删除</strong></p> 
<p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作<br> 优点：节约内存，到时就删除，快速释放掉不必要的内存占用<br> 缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量<br> 总结：用处理器性能换取存储空间 （拿时间换空间）</p> 
<p><strong>惰性删除</strong><br> 数据到达过期时间，不做处理。等下次访问该数据时，如果未过期，返回数据 ；发现已过期，删除，返回不存在。<br> 优点：节约CPU性能，发现必须删除的时候才删除<br> 缺点：内存压力很大，出现长期占用内存的数据<br> 总结：用存储空间换取处理器性能（拿空间换时间）</p> 
<p><strong>定期删除</strong></p> 
<p>定期删除策略是前两种策略的折中：</p> 
<p>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</p> 
<p>周期性轮询Redis库中的时效性数据，来用随机抽取的策略，利用过期数据占比的方式控制删除频度</p> 
<p>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</p> 
<p>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</p> 
<p>总结：周期性抽查存储空间（随机抽查，重点抽查）</p> 
<p>经过上述步骤删除策略的任意一种，还有漏洞吗？（肯定有，不然不问）<br> 有什么漏洞呢，如下所示：</p> 
<ol><li>定期删除时，从来没有被抽查到</li><li>惰性删除时，也从来没有被点中使用过</li></ol> 
<p>上述2步骤====&gt;大量过期的key堆积在内存中，导致redis内存空间紧张或者很快耗尽（这个时候就必须有一个解决的方案，要么报异常，要么找个兜底的方法）</p> 
<p>必须要有一个更好的兜底方案：</p> 
<p>内存淘汰策略登场（Redis 6.0.8版本）</p> 
<ol><li>noeviction：不会驱逐任何key</li><li>volatile-lfu：对所有设置了过期时间的key使用LFU算法进行删除</li><li>volatile-Iru：对所有设置了过期时间的key使用LRU算法进行删除</li><li>volatile-random：对所有设置了过期时间的key随机删除</li><li>volatile-ttl：删除马上要过期的key</li><li>allkeys-lfu：对所有key使用LFU算法进行删除</li><li>allkeys-Iru：对所有key使用LRU算法进行删除</li><li>allkeys-random：对所有key随机删除</li></ol> 
<p>如何配置，修改<br> 命令<br> config set maxmemory-policy noeviction<br> config get maxmemory<br> 配置文件 - 配置文件redis.conf的maxmemory-policy参数</p> 
<h3><a id="23Spring_344"></a>23.Spring怎么解决循环依赖？</h3> 
<p>spring内部通过3级缓存来解决循环依赖 - DefaultSingletonBeanRegistry</p> 
<p>只有单例的bean会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中。</p> 
<ol><li>第一级缓存（也叫单例池）singletonObjects：存放已经经历了完整生命周期的Bean对象。</li><li>第二级缓存：earlySingletonObjects，存放早期暴露出来的Bean对象，Bean的生命周期未结束（属性还未填充完。</li><li>第三级缓存：Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories，存放可以生成Bean的工厂。</li></ol> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>support</span><span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSingletonBeanRegistry</span> <span class="token keyword">extends</span> <span class="token class-name">SimpleAliasRegistry</span> <span class="token keyword">implements</span> <span class="token class-name">SingletonBeanRegistry</span> <span class="token punctuation">{<!-- --></span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token comment">/** Cache of singleton objects: bean name to bean instance. */</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> singletonFactories <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/** Cache of early singleton objects: bean name to bean instance. */</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> earlySingletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>A / B两对象在三级缓存中的迁移说明</strong></p> 
<ol><li>A创建过程中需要B，于是A将自己放到三级缓里面，去实例化B。</li><li>B实例化的时候发现需要A，于是B先查一级缓存，没有，再查二级缓存，还是没有，再查三级缓存，找到了A然后把三级缓存里面的这个A放到二级缓存里面，并删除三级缓存里面的A。</li><li>B顺利初始化完毕，将自己放到一级缓存里面（此时B里面的A依然是创建中状态)，然后回来接着创建A，此时B已经创建结束，直接从一级缓存里面拿到B，然后完成创建，并将A自己放到一级缓存里面。</li></ol> 
<p><strong>为什么要有二级缓存？二级缓存具体解决什么问题？</strong><br> 二级缓存是为了解决，在多线程环境中，获取不完整Bean实例。如果只有一级缓存的话，在多线程环境下，我们使用加锁，并发下降，所以放到二级缓存中加锁，解决并发性能，又可以解决循环依赖。增加性能。（注意在二级缓存加锁代码中需要双重检查，解决并发获取的不完整的Bean）<br> <strong>为什么要有三级缓存？三级缓存具体解决什么问题？</strong>（接着吹）<br> 如果只是死循环出现的栈溢出，一级缓存就可以解决，三级缓存的出现，就是为了解决循环依赖中的动态代理，只有二级缓存，其实也是可以解决的，但是（最害怕出现但是）如果出现多次循环依赖，会创建多次的动态代理，所以就有三级缓存。<br> （说明一下多次循环依赖，就是A依赖B，B依赖A，A依赖C，C依赖A，这种场景）<br> <img src="https://images2.imgbox.com/63/6f/g6BkHjjK_o.png" alt="在这里插入图片描述"><br> 这里有一个视频可以帮助我们更好的理解上面的问题和spring解决循环依赖的原理。<br> <a href="https://www.bilibili.com/video/BV1aZ4y1S75v?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click" rel="nofollow">视频参考链接</a></p> 
<h3><a id="24springbean_389"></a>24.spring中bean的生命周期</h3> 
<p>spring中bean的生命周期 <a href="https://blog.csdn.net/qq_2662385590/article/details/123841115?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165182635016781683929279%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165182635016781683929279&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-123841115-null-null.article_score_rank_blog&amp;utm_term=Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&amp;spm=1018.2226.3001.4450">参考这个链接</a><br> bean的更完整的生命周期分为以下七步：<br> （1）通过构造器创建bean实例（调用无参的构造函数）<br> （2）为bean的属性设置值和对其它bean引用（调用set方法）<br> （3）把bean实例传递到bean后置处理器的方法<br> （4）调用bean的初始化方法（初始化方法需要配置）<br> （5）把bean实例传递到bean后置处理器的方法<br> （6）bean的使用（获取到对象）<br> （7）容器关闭，调用bean的销毁的方法（销毁方法需要进行配置）</p> 
<p>如果加上一些实现的接口，spring中bean的生命周期大致可以分为这十个步骤：<br> <img src="https://images2.imgbox.com/78/b5/hOe17UzY_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="25_402"></a>25.主流对象复制框架使用与比较（对象克隆使用的框架比较）</h3> 
<p>在 Java 生态中，有很多第三方框架可以进行对象复制，<strong>分别是Apache的BeanUtils和PropertyUtils、Spring的BeanUtils、Cglib的BeanCopier等</strong>，下面我们一起来了解一下吧！<br> 其中 apache 提供了2个类来实现对象复制，分别<strong>是BeanUtils和PropertyUtils，这两者的区别在于BeanUtils提供类型转换功能，即发现两个JavaBean的同名属性为不同类型时，在支持的数据类型范围内进行转换，而PropertyUtils不支持这个功能！<br> 而spring的BeanUtils和cglib的BeanCopier，因为属性对应的类型不一致，直接跳过复制！</strong><br> <img src="https://images2.imgbox.com/c6/8e/hpOpEVNL_o.png" alt="在这里插入图片描述"><br> <strong>总结</strong></p> 
<ol><li>在低频次下，apache的PropertyUtils效率最高，在高频次下，cglib BeanCopier效率最高；</li><li>apache的BeanUtils，在四个框架中效率最低；</li><li>在高频次下，spring的BeanUtils的效率仅次于cglib BeanCopier；</li><li>因为apache的BeanUtils在进行复制的时候，在支持的数据类型范围内进行转换，所有性能会有些损失，对于数据结构严谨的复制，不建议采用！</li></ol> 
<p><strong>Spring BeanUtils</strong><br> 特点：</p> 
<ol><li>字段名不一致，属性无法复制；</li><li>类型不一致，属性无法复制（直接跳过）。但是注意，如果类型为基本类型以及基本类型的包装类，这种可以转化；</li><li>浅拷贝</li></ol> 
<p><strong>Apache BeanUtils</strong><br> 特点：</p> 
<ol><li>字段名不一致的，属性无法被复制；</li><li>类型不一致的字段，将会进行默认类型转化；</li><li>浅拷贝。</li></ol> 
<p><strong>Apache PropertyUtils</strong><br> 特点：</p> 
<ol><li>字段名不一致的，属性无法被复制；</li><li>类型不一致的字段，不支持数据类型转换；</li><li>浅拷贝。</li></ol> 
<p><strong>cglib BeanCopier</strong><br> 特点：</p> 
<ol><li>字段名不一致，属性无法复制</li><li>类型不一致，属性无法复制（直接跳过）。如果类型为基本类型/基本类型的包装类型，这两者也无法被拷贝。但可自定义转换器实现不同类型的拷贝。</li><li>浅拷贝</li></ol> 
<h3><a id="26Spring_IOCAOP_437"></a>26.Spring IOC和AOP的原理以及实际应用</h3> 
<p>Spring IOC和AOP的原理以及实际应用:<a href="https://blog.csdn.net/qq_2662385590/article/details/124719343?spm=1001.2014.3001.5501">参考链接</a></p> 
<h3><a id="27TCP__439"></a>27.TCP 三次握手和四次挥手的流程</h3> 
<p>TCP协议是7层网络协议中的传输层协议，负责数据的可靠传输。<br> 在建立TCP连接时，需要通过三次握手来建立，过程是：</p> 
<ol><li>客户端向服务端发送一个SYN</li><li>服务端接收到SYN后，给客户端发送一个SYN_ACK</li><li>客户端接收到SYN_ACKJ后，再给服务端发送一个ACK</li></ol> 
<p>在断开TCP连接时，需要通过四次挥手来断开，过程是：</p> 
<ol><li>客户端向服务端发送FN</li><li>服务端接收FN后，向客户端发送CK,表示我接收到了断开连接的请求，客户端你可以不发数据了，不过服务端这边可能还<br> 有数据正在处理</li><li>服务端处理完所有数据后，向客户端发送FN,表示服务端现在可以断开连接</li><li>客户端收到服务端的FIN,向服务端发送ACK,表示客户端也会断开连接了<br> <a href="https://blog.csdn.net/qq_2662385590/article/details/124748743?spm=1001.2014.3001.5501">TCP 三次握手和四次挥手的流程</a></li></ol> 
<h3><a id="28MySQL_454"></a>28.MySQL原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</h3> 
<ol><li>事务的隔离性由 锁机制 实现。</li><li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。</li></ol> 
<p>REDO LOG 称为 重做日志 ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。<br> UNDO LOG 称为 回滚日志 ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。<br> 有的DBA或许会认为 UNDO 是 REDO 的逆过程，其实不然。</p> 
<h3><a id="29redoundo_461"></a>29.redo日志和undo日志的理解和深刻认识</h3> 
<p><a href="https://blog.csdn.net/qq_2662385590/article/details/124769533?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22124769533%22,%22source%22:%22qq_2662385590%22%7D&amp;ctrtid=JXK4t">redo日志和undo日志的理解和深刻认识</a></p> 
<h3><a id="30_464"></a>30.死锁产生的原因，怎么避免死锁？</h3> 
<p><img src="https://images2.imgbox.com/ec/45/uZN1lHHU_o.png" alt="在这里插入图片描述"></p> 
<p>死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种互相等待的现象，若无外力干涉那他们都将无法推进下去。这些一直处于相互等待资源的线程就称为死锁线程。</p> 
<p><img src="https://images2.imgbox.com/68/68/HC2MgINB_o.png" alt="image-20210612222402287"><br> <strong>导致死锁的条件有四个，也就是这四个条件同时满足就会产生死锁。</strong></p> 
<ol><li>互斥条件，共享资源 X 和 Y 只能被一个线程占用；</li><li>请求和保持条件，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</li><li>不可抢占条件，其他线程不能强行抢占线程 T1 占有的资源；</li><li>循环等待条件，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</li></ol> 
<p><strong>按照死锁发生的四个条件，只需要破坏其中的任何一个，就可以解决，但是，互斥条件是没办法破坏的，因为这是互斥锁的基本约束，其他三方条件都有办法来破坏：</strong></p> 
<ol><li>对于“请求和保持”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</li><li>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li><li>对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li></ol> 
<h3><a id="31_483"></a>31.浏览器发出一个请求到收到响应经历了哪些步骤？</h3> 
<ol><li>浏览器解析用户输入的URL,生成一个HTTP格式的请求</li><li>先根据URL域名从本地hosts.文件查找是否有映射IP,如果没有就将域名发送给电脑所配置的DNS进行域名解析，得到IP地址</li><li>浏览器通过操作系统将请求通过四层网络协议发送出去</li><li>途中可能会经过各种路由器、交换机，最终到达服务器</li><li>服务器收到请求后，根据请求所指定的端口，将请求传递给绑定了该端口的应用程序，比如8080被tomcat占用了</li><li>tomcat接收到请求数据后，按照http协议的格式进行解析，解析得到所要访问的servlet</li><li>然后servlet来处理这个请求，如果是SpringMVC中的DispatcherServlet,.那么则会找到对应的Controller中的方法，并执行该方法得到结果</li><li>Tomcat得到响应结果后封装成HTTP响应的格式，并再次通过网络发送给浏览器所在的服务器</li><li>浏览器所在的服务器拿到结果后再传递给浏览器，浏览器则负贵解析并渲染</li></ol> 
<h3><a id="32equlashashcodeequlashashcode_494"></a>32.谈谈equlas()和hashcode()方法的之间的关系（为什么重写equlas方法必须要重写hashcode方法）?</h3> 
<p><strong>hashCode()方法介绍</strong><br> 在Object类中的一个本地方法，作用是获取哈希码（散列码），它是一个int整数，这个哈希码的作用是确定该对象在哈希表中的索引位置。</p> 
<p><strong>为什么要有 hashCode()方法？</strong><br> 以“HashSet 如何检查重复”为例子说明。<br> 当把对象添加到HashSet时，HashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashCode值做比较，如果没有相同的hashCode，则认为没有重复的对象。如果有相同的hashCode（发生碰撞），则会调用equals()方法来判断对象是否相同。如果相同，则不会让其加入成功。如果不同，则重新散列到其他位置。这样就减少使用equals的次数，提高了执行速度。</p> 
<p><strong>重写equals方法，必须重写hashCode方法</strong><br> hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()方法，则两个对象是永远不相等的（即使有同样的数据）。</p> 
<p>如果两个对象相等（equals返回true），则它们的hashCode也一定相等。</p> 
<p>如果两个对象的hashCode相等，但它们不一定相等（equals不一定返回true）。<br> <a href="http://t.csdn.cn/mI8vN" rel="nofollow">详细点击这里</a></p> 
<h3><a id="33MySQLSQL_510"></a>33.常见的MySQL的SQL优化注意事项</h3> 
<ol><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：<br> select id from t where num is null<br> 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<br> select id from t where num=0</li><li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li><li>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：<br> select id from t where num=10 or num=20<br> 可以这样查询：<br> select id from t where num=10<br> union all<br> select id from t where num=20</li><li>in 和 not in 也要慎用，否则会导致全表扫描，如：<br> select id from t where num in(1,2,3)<br> 对于连续的数值，能用 between 就不要用 in 了：<br> select id from t where num between 1 and 3</li><li>下面的查询也将导致全表扫描：<br> select id from t where name like ‘%abc%’ Like查询（非左开头）</li><li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br> select id from t where num/2=100<br> 应改为:<br> select id from t where num=100*2</li><li>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br> select id from t where substring(name,1,3)=‘abc’ // oracle总有的是substr函数。<br> select id from t where datediff(day,createdate,‘2005-11-30’)=0 //查过了确实没有datediff函数。<br> 应改为:<br> select id from t where name like ‘abc%’</li><li>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</li><li>很多时候用 exists 代替 in 是一个好的选择：<br> select num from a where num in(select num from b)<br> 用下面的语句替换：<br> select num from a where exists(select 1 from b where num=a.num)<br> （等等，如果嫌少自行百度）</li></ol> 
<p><strong>适合创建索引条件</strong><br> 　　1、主键自动建立唯一索引<br> 　　2、频繁作为查询条件的字段应该建立索引<br> 　　3、查询中与其他表关联的字段，外键关系建立索引<br> 　　4、单键/组合索引的选择问题，组合索引性价比更高<br> 　　5、查询中排序的字段，排序字段若通过索引去访问将大大提高排序效率<br> 　　6、查询中统计或者分组字段<br> <strong>不适合创建索引条件</strong><br> 　　1、表记录少的<br> 　　2、经常增删改的表或者字段<br> 　　3、where条件里用不到的字段不创建索引<br> 　　4、过滤性不好的不适合建索引</p> 
<h3><a id="34_558"></a>34.我们为什么会限流？限流算法有几种？</h3> 
<p><strong>随着用户的流量突增，后端服务的处理能力是有限的，如果不能处理好突发流量，后端服务很容易就被打垮，导致整个系统崩溃！</strong><br> <strong>限流算法</strong></p> 
<ol><li>计数限流</li><li>固定窗口限流算法</li><li>滑动窗口限流</li><li>漏桶算法</li><li>令牌桶算法<br> <a href="https://blog.csdn.net/billgates_wanbin/article/details/123556273?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165657388416781818736980%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=165657388416781818736980&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-123556273-null-null.142%5Ev26%5Econtrol,157%5Ev15%5Enew_3&amp;utm_term=%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E9%99%90%E6%B5%81%EF%BC%9F%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E6%9C%89%E5%87%A0%E7%A7%8D&amp;spm=1018.2226.3001.4187">详细限流算法参考</a></li></ol> 
<h3><a id="35_EurekaZooKeeper_567"></a>35. Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别？</h3> 
<ol><li>ZooKeeper中的节点服务挂了就要选举，在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的，选举就是改微服务做了集群，必须有一台主其他的都是从</li><li>Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的</li><li>Eureka本质上是一个工程,而ZooKeeper只是一个进程</li><li>Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪</li><li>ZooKeeper保证的是CP，Eureka保证的是AP</li></ol> 
<h3><a id="36HTTPRPC_573"></a>36.说一下HTTP和RPC的区别</h3> 
<p>RPC（即Remote Procedure Call，远程过程调用）和HTTP（HyperText Transfer Protocol，超文本传输协议），两者前者是一种方法，后者则是一种协议。两者都常用于实现服务，在这个层面最本质的区别是RPC服务主要工作在TCP协议之上（也可以在HTTP协议），而HTTP服务工作在HTTP协议之上。由于HTTP协议基于TCP协议，所以RPC服务天然比HTTP更轻量，效率更胜一筹。<br> <strong>RPC服务</strong><br> RPC服务基本架构包含了四个核心的组件，分别是Client,Server,Clent Stub以及Server Stub。<br> <img src="https://images2.imgbox.com/5e/23/Ut0nFc3C_o.png" alt="在这里插入图片描述"><br> <strong>Client （客户端）</strong>：服务调用方。<br> <strong>Server（服务端）</strong>：服务提供方。<br> <strong>Client Stub（客户端存根）</strong>：存放服务端的地址消息，负责将客户端的请求参数打包成网络消息，然后通过网络发送给服务提供方。<br> <strong>Server Stub（服务端存根）</strong>：接收客户端发送的消息，再将客户端请求参数打包成网络消息，然后通过网络远程发送给服务方。</p> 
<p>RPC效率优势明显，在实际开发中，客户端和服务端在技术方案中约定客户端的调用参数和服务端的返回参数之后就可以各自开发，任何客户端只要按照接口定义的规范发送入参都可以调用该RPC服务，服务端也能按接口定义的规范出参返回计算结果。这样既实现了客户端和服务端之间的解耦，也使得RPC接口可以在多个项目中重复利用。</p> 
<p><strong>RPC调用分为同步方式和异步方式。</strong><br> 什么是同步调用？什么是异步调用？同步调用就是客户端等待调用执行完成并返回结果。异步调用就是客户端不等待调用执行完成返回结果，不过依然可以通过回调函数等接收到返回结果的通知。如果客户端并不关心结果，则可以变成一个单向的调用。这个过程有点类似于Java中的callable和runnable接口，我们进行异步执行的时候，如果需要知道执行的结果，就可以使用callable接口，并且可以通过Future类获取到异步执行的结果信息。如果不关心执行的结果，直接使用runnable接口就可以了，因为它不返回结果，当然啦，callable也是可以的，我们不去获取Future就可以了。</p> 
<p><strong>HTTP服务</strong><br> HTTP服务开发即开发ERESTful风格的服务接口。在接口不多、系统之间交互较少的情况下，是一种信息传递的常用通信手段。HTTP接口的优点是简单、直接、开发方便，利用现成的HTTP协议进行传输。在服务开发的时候，约定一个接口文档，严格定义输入和输出，明确每一个接口的请求方法和需要的请求参数及其格式。</p> 
<p>在内部子系统较多、接口较多的情况下，RPC框架的好处就凸显出现了，首先是长连接，不必每次通信都要像HTTP那样三次握手，减少了网络开销；其次是RPC框架一般都有注册中心，有丰富的监控发布方法；RPC接口的发布、下线、动态扩展等对调用方是无感知的、统一化的操作。</p> 
<p><strong>RPC接口和HTTP接口的区别与联系</strong><br> 传输协议</p> 
<ul><li>RPC：可以基于TCP协议，也可以基于HTTP协议。</li><li>HTTP：基于HTTP协议。</li></ul> 
<p>传输效率</p> 
<ul><li>RPC：使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2.0协议，也可以很好地减少报文体积，提高传输效率。</li><li>HTTP：如果时基于HTTP1.1的协议，请求中会包含很多无用的内容；如果是基于HTTP2.0，那么简单地封装一下还是可以作为一个RPC使用的，这时标准RPC框架更多是服务治理。</li></ul> 
<p>性能消耗</p> 
<ul><li>RPC：可以基于thrift实现高效的二进制传输</li><li>HTTP：大部分是通过json实现的，字节大小和序列化耗时都比thrift要更消耗性能</li></ul> 
<p>负载均衡</p> 
<ul><li>RPC：基本都自带了负载均衡策略</li><li>HTTP：需要配置Nginx，HAProxy实现</li></ul> 
<p>服务治理（下游服务新增，重启，下线时如何不影响上游调用者）</p> 
<ul><li>RPC：能做到自动通知，不影响上游</li><li>HTTP：需要事先通知，修改Nginx/HAProxy配置</li></ul> 
<p>RPC主要用于公司内部服务调用，性能消耗低，传输效率高，服务治理方便。HTTP主要用于对外的异构环境，浏览器调用，APP接口调用，第三方接口调用等等。</p> 
<p>RPC和HTTP都可以用于实现远程过程调用，如何选择</p> 
<ul><li>从速度上看，RPC比HTTP更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩</li><li>从难度上看，RPC实现较为复杂，http相对简单</li><li>从灵活性上看，HTTP更胜一筹，因为它不关心实现细节，跨平台，跨语言</li></ul> 
<p>两者有不同的使用场景：</p> 
<ul><li>如果对效率要求更高，并且开发过程使用统一的技术栈，那么RPC还是不错的</li><li>如果需要更加灵活，跨语言、跨平台，显然HTTP更合适</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e5e5199bb0a148f3d7523ff042ce478/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">免费的内网穿透（钉钉）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/356576ae33cfd8787cad4173895c534a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MyBatis的优点有哪些？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>