<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Erlang顺序编程杂项集（上篇） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Erlang顺序编程杂项集（上篇）" />
<meta property="og:description" content="一：apply apply是一个内置函数，它是通过函数名和参数计算该函数的值，其中的函数名和模块名是动态计算得出的。内置函数apply(Mod, Func, [Arg1, Arg2, ..., ArgN])会将模块Mod里的Func函数应用到Arg1, Arg2, ... ArgN这些参数上,它相当于:
Mod:Func(Arg1,Arg2,Arg3,...,ArgN). %%其中上述中Mod是模块，Func是该模块的函数，Arg是参数 所有的 Erlang 内置函数也可以通过 apply 进行调用，方法是假定它们都属于 erlang 模块。因 此，要构建一个对内置函数的动态调用，可以编写以下代码： 1&gt; apply(erlang,atom_to_list,[hello]). &#34;hello&#34; %%这其中就和apply(Mod, Func, [Arg1, Arg2, ..., ArgN])这个一样，erlang 相当于Mod是模块，atom_to_list相当于Func是函数，hello是参数。 注：应当尽量避免使用apply。当函数的参数数量能预先知道时，M:F(Arg1, Arg2, ... ArgN) 这种调用形式要比apply好得多。如果使用apply对函数进行调用，许多分析工具就无法 得知发生了什么，一些特定的编译器优化也不能进行。所以，尽量少用apply，除非绝对有必要。 二：算术表达式 任何类型的值的计算是表达式， 下面的表格展示了所有可用的算术表达式。每种算术操作都有1 或 2个参数（X，Y），这些参数在表格里显示为“整数”或“数字”（数字的意思是此参数可以是整数或浮点数） 操作符描述参数类型优先级&#43; X正数数字1- X负数数字1X * Y进行乘法运算数字2X / Y进行除法运算（一般结果是浮点数）数字2bont X对X执行按位取反（bitwise not）整数2X div YX被Y整除整数2X rem YX除以Y的整数的余数（取余）整数2X band Y对X和Y执行按位与（bitwise and）整数2X &#43; Y进行加法运算数字3X - Y进行减法运算数字3X bor Y对X和Y执行按位或（bitwise or）整数3X bxor Y对X和Y执行按位异或（bitwise xor）整数3X bsl N把X向左算术位移（arithmetic bitshift）N位整数3X bsr N把X向右算法位移N位整数3 这些操作符相互之间根据 优先级 结合。一个复杂算术表达式的求值顺序由所含操作符的优先 级而定：所有优先级为 1 的操作符会首先求值，然后轮到所有优先级为 2 的操作符，以此类推。 可以用括号来改变默认的求值顺序：括号内的表达式会首先求值。优先级相同的操作符遵循 向左结合的规则，从左往右分别求值。 三：元数 一个函数的元数（arity ）是该函数所拥有的参数数量。在 Erlang 里，同一模块里的两个名称 相同、元数不同的函数是 完全 不同的函数。除了碰巧使用同一个名称外，它们之间 毫不相关 。 根据惯例， Erlang 程序员经常将名称相同、元数不同的函数作为辅助函数使用。这里有一个 例子： sum(L) -&gt; sum(L,0), sum([],N) -&gt; N; sum([H|T],N) -&gt; sum(T,H &#43; N)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/1b988219cbdf7b6fe0e14e19524eaef0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-07T23:41:09+08:00" />
<meta property="article:modified_time" content="2023-11-07T23:41:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Erlang顺序编程杂项集（上篇）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong><span style="color:#000000;">一：apply</span></strong></h2> 
<p><strong><span style="color:#000000;">apply是一个内置函数，</span></strong><span style="color:#000000;">它是通过函数名和参数计算该函数的值，其中的函数名和模块名是动态计算得出的。内置函数apply(Mod, Func, [Arg1, Arg2, ..., ArgN])</span><span style="color:#000000;">会将模块</span><span style="color:#000000;">Mod</span><span style="color:#000000;">里的</span><span style="color:#000000;">Func</span><span style="color:#000000;">函数应用到Arg1, Arg2, ... ArgN</span><span style="color:#000000;">这些参数上,它相当于:</span></p> 
<pre><code class="language-Erlang">Mod:Func(Arg1,Arg2,Arg3,...,ArgN).
%%其中上述中Mod是模块，Func是该模块的函数，Arg是参数</code></pre> 
<div>
    
 <div> 
  <span style="color:#000000;">所有的</span> 
  <span style="color:#000000;">Erlang</span> 
  <span style="color:#000000;">内置函数也可以通过</span> 
  <span style="color:#000000;">apply</span> 
  <span style="color:#000000;">进行调用，方法是假定它们都属于</span> 
  <span style="color:#000000;">erlang</span> 
  <span style="color:#000000;">模块。因 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">此，要构建一个对内置函数的动态调用，可以编写以下代码：</span> 
  <pre><code class="language-Erlang">1&gt; apply(erlang,atom_to_list,[hello]).
"hello"

%%这其中就和apply(Mod, Func, [Arg1, Arg2, ..., ArgN])这个一样，erlang
相当于Mod是模块，atom_to_list相当于Func是函数，hello是参数。</code></pre> 
  <p><span style="color:#fe2c24;">注：应当尽量避免使用apply。当函数的参数数量能预先知道时，M:F(Arg1, Arg2, ... ArgN) 这种调用形式要比apply好得多。如果使用apply对函数进行调用，许多分析工具就无法 得知发生了什么，一些特定的编译器优化也不能进行。所以，尽量少用apply，除非绝对有必要。 </span></p> 
  <h2>二：<span style="color:#000000;">算术表达式</span></h2> 
  <div> 
   <strong>任何类型的值的计算是表达式</strong>， 
   <span style="color:#000000;">下面的表格展示了所有可用的算术表达式。每种算术操作都有1</span> 
   <span style="color:#000000;">或</span> 
   <span style="color:#000000;">2个参数（X，Y），这些参数在表格里显示为“整数”或“数字”（数字的意思是此参数可以是整数或浮点数）</span> 
  </div> 
  <div> 
   <table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th>操作符</th><th>描述</th><th>参数类型</th><th>优先级</th></tr></thead><tbody><tr><td>+ X</td><td>正数</td><td>数字</td><td>1</td></tr><tr><td>- X</td><td>负数</td><td>数字</td><td>1</td></tr><tr><td>X * Y</td><td>进行乘法运算</td><td>数字</td><td>2</td></tr><tr><td>X / Y</td><td>进行除法运算（一般结果是浮点数）</td><td>数字</td><td>2</td></tr><tr><td>bont X</td><td>对X执行按位取反（bitwise not）</td><td>整数</td><td>2</td></tr><tr><td>X div Y</td><td>X被Y整除</td><td>整数</td><td>2</td></tr><tr><td>X rem Y</td><td>X除以Y的整数的余数（取余）</td><td>整数</td><td>2</td></tr><tr><td>X band Y</td><td>对X和Y执行按位与（bitwise and）</td><td>整数</td><td>2</td></tr><tr><td>X + Y</td><td>进行加法运算</td><td>数字</td><td>3</td></tr><tr><td>X - Y</td><td>进行减法运算</td><td>数字</td><td>3</td></tr><tr><td>X bor Y</td><td>对X和Y执行按位或（bitwise or）</td><td>整数</td><td>3</td></tr><tr><td>X bxor Y</td><td>对X和Y执行按位异或（bitwise xor）</td><td>整数</td><td>3</td></tr><tr><td>X bsl N</td><td>把X向左算术位移（arithmetic bitshift）N位</td><td>整数</td><td>3</td></tr><tr><td>X bsr N</td><td>把X向右算法位移N位</td><td>整数</td><td>3</td></tr></tbody></table> 
   <div> 
    <span style="color:#000000;">这些操作符相互之间根据</span> 
    <span style="color:#000000;">优先级</span> 
    <span style="color:#000000;">结合。一个复杂算术表达式的求值顺序由所含操作符的优先 </span> 
   </div> 
   <div> 
    <span style="color:#000000;">级而定：所有优先级为</span> 
    <span style="color:#000000;">1</span> 
    <span style="color:#000000;">的操作符会首先求值，然后轮到所有优先级为</span> 
    <span style="color:#000000;">2</span> 
    <span style="color:#000000;">的操作符，以此类推。 </span> 
   </div> 
   <div> 
    <span style="color:#000000;">可以用括号来改变默认的求值顺序：括号内的表达式会首先求值。优先级相同的操作符遵循 </span> 
   </div> 
   <div> 
    <span style="color:#000000;">向左结合的规则，从左往右分别求值。</span> 
   </div> 
   <div></div> 
   <h2><span style="color:#000000;">三：元数</span></h2> 
  </div> 
  <div> 
   <div> 
    <strong><span style="color:#000000;">一个函数的</span><span style="color:#000000;">元数</span><span style="color:#000000;">（</span><span style="color:#000000;">arity</span></strong> 
    <span style="color:#000000;"><strong>）是该函数所拥有的参数数量</strong>。在</span> 
    <span style="color:#000000;">Erlang</span> 
    <span style="color:#000000;">里，同一模块里的两个名称 </span> 
   </div> 
   <div> 
    <span style="color:#000000;">相同、元数不同的函数是</span> 
    <span style="color:#000000;">完全</span> 
    <span style="color:#000000;">不同的函数。除了碰巧使用同一个名称外，它们之间</span> 
    <span style="color:#000000;">毫不相关</span> 
    <span style="color:#000000;">。 </span> 
   </div> 
   <div> 
    <span style="color:#000000;">根据惯例，</span> 
    <span style="color:#000000;">Erlang</span> 
    <span style="color:#000000;">程序员经常将名称相同、元数不同的函数作为辅助函数使用。这里有一个 </span> 
   </div> 
   <div> 
    <span style="color:#000000;">例子：</span> 
    <pre><code class="language-Erlang">sum(L) -&gt; sum(L,0),

sum([],N) -&gt; N;
sum([H|T],N) -&gt; sum(T,H + N).

%% 在这段函数中sum(L)函数累加列表L里的所有元素。它用到一个名为sum/2的辅助函数，但也可以是其他
%% 任何名称。即便把辅助函数命名为hedgehog/2（刺猬），程序的意思也不会有任何变化。不过，
%% sum/2是更好的命名选择，因为它提示程序的读者这是什么，而且还不必发明一个新名称（这总
%% 是很困难的）。
%% 我们经常会通过不导出辅助函数来“隐藏”它们。所以，定义sum(L)的模块只会导出sum/1，
%% 而不会导出sum/2。</code></pre> 
    <h2>四：属性</h2> 
    <div> 
     <span style="color:#000000;">模块属性的语法是</span> 
     <span style="color:#000000;">-AtomTag(...)</span> 
     <span style="color:#000000;">，它们<strong>被用来定义文件的某些属性</strong>。（</span> 
     <span style="color:#fe2c24;">注意：-record(...) </span> 
    </div> 
    <div> 
     <span style="color:#fe2c24;">和-include(...)有着类似的语法，但是不算模块属性。</span> 
     <span style="color:#000000;">）模块属性有两种类型：<strong>预定义型</strong>和<strong>用 </strong></span> 
    </div> 
    <div> 
     <span style="color:#000000;"><strong>户定义型</strong>。</span> 
    </div> 
    <h3><span style="color:#000000;">1.预定义型：</span></h3> 
    <div> 
     <span style="color:#000000;">下列模块属性有着预先定义的含义，必须放置在任何函数定义之前。</span> 
     <pre><code class="language-Erlang">(1) -module(modname).
%% 这是模块声明。modname必须是一个原子。此属性必须是文件里的第一个属性。按照惯例，
%% modname的代码应当保存在名为modname.erl的文件里。如果不这么做，自动代码加载就
%% 不能正常工作。

(2)-import(Mod,[Name1/Arity1,Name2/Arity2,...]).
%% import声明列举了哪些函数需要导入到模块中。上面这个声明的意思是要从Mod模块导入
%% 参数为Arity1的Name1函数，参数为Arity2的Name2函数，等等。
%% 一旦从别的模块里导入了某个函数，调用它的时候就无需指定模块名了。

(3)-export([Name1/Arity1,Name2/Arity2,...]).
%% 导出当前模块里的Name1/Arity1和Name2/Arity2等函数。函数只有被导出后才能在模块
%% 之外调用。

(4)-compile(Options).
%% 添加Options到编译器选项列表中。Options可以是单个编译器选项，也可以是一个编译
%% 器选项列表.

(5)-vsn(Version).
%% 指定模块的版本号。Version可以是任何字面数据类型。Version的值没有什么特别的语
%% 法或含义，但可以用于分析程序或者作为说明文档使用。</code></pre> 
     <p><span style="color:#fe2c24;">注：-compile(export_all).这个编译器选项经常会在调试程序时用到。它会导出模块里的所有函数，无需再显式使用-export标识了。</span></p> 
     <h3><span style="color:#0d0016;"><strong>2.用户定义型：</strong></span></h3> 
     <pre><code class="language-Erlang">-SomeTag(Value).
%% SomeTag必须是一个原子，而Value必须是一个字面数据类型。模块属性的值会被编译进模
%% 块，可以在运行时提取。</code></pre> 
    </div> 
    <div>
      列如： 
     <pre><code class="language-Erlang">%% attrs.erl

-module(attrs).
-vsn(1234).

%% 这两个就是-SomeTag(Value)
-author({joe,armstrong}).
-purpose("example of attributes").

-export([fac/1]).

fac(1)-&gt;1:
fac(N)-N fac(N-1).</code></pre> 
     <p>可以用下面的方式提取这些值：</p> 
     <pre><code class="language-Erlang">1&gt; attrs:module_info().
[{exports,[{fac,1},{module_info,0},{module_info,1}]},
{imports,[]}
{alLribules,[{vsn,[1234]},
            {author,[{joe,armstrong}]},
            {purpose,"example of attributes"}]},
            {compile,[{options,[]}
            {version,"4.8"},
            {time,{2013,5,3,7,36,55},
            {source,"/Users/joe/jaerlang2/code/attrs.erl"}]}]</code></pre> 
     <div> 
      <span style="color:#000000;">源代码文件所含的用户定义属性再一次出现了，它们表现为</span> 
      <span style="color:#000000;">{attributes, ...}</span> 
      <span style="color:#000000;">的下属数据类型。元组{compile, ...}</span> 
      <span style="color:#000000;">包含了编译器添加的信息。</span> 
      <span style="color:#000000;">{version,"4.8"}</span> 
      <span style="color:#000000;">这个值是编译器的版本号，不应与模块属性里定义的vsn</span> 
      <span style="color:#000000;">标签相混淆。在上面的例子里，</span> 
      <span style="color:#000000;">attrs:module_info()</span> 
      <span style="color:#000000;">返回一个属性列表，内含所有与被编译模块相关的元数据。attrs:module_info(X)</span> 
      <span style="color:#000000;">（</span> 
      <span style="color:#000000;">X</span> 
      <span style="color:#000000;">可以是 exports、</span> 
      <span style="color:#000000;">imports</span> 
      <span style="color:#000000;">、</span> 
      <span style="color:#000000;">attributes</span> 
      <span style="color:#000000;">和</span> 
      <span style="color:#000000;">compile</span> 
      <span style="color:#000000;">中的一个）会返回与模块相关的单个属性。请注意，函数module_info/0</span> 
      <span style="color:#000000;">和</span> 
      <span style="color:#000000;">module_info/1</span> 
      <span style="color:#000000;">会在模块编译时自动创建。 </span> 
     </div> 
     <div> 
      <span style="color:#000000;">要运行</span> 
      <span style="color:#000000;">attrs:module_info</span> 
      <span style="color:#000000;">，必须先把</span> 
      <span style="color:#000000;">attrs</span> 
      <span style="color:#000000;">模块的</span> 
      <span style="color:#000000;">beam</span> 
      <span style="color:#000000;">代码加载到</span> 
      <span style="color:#000000;">Erlang</span> 
      <span style="color:#000000;">虚拟机里。也可 </span> 
     </div> 
     <div> 
      <span style="color:#000000;">以使用</span> 
      <span style="color:#000000;">beam_lib</span> 
      <span style="color:#000000;">模块来提取同样的信息，这样就</span> 
      <span style="color:#000000;">不必</span> 
      <span style="color:#000000;">载入</span> 
      <span style="color:#000000;">attrs</span> 
      <span style="color:#000000;">模块了,如：</span> 
      <pre><code class="language-Erlang">2&gt; beam lib:chunks("attrs.beam",[attributes]).
[ok,{attrs,[{attributes,[{author,[{joe,armstrong}]},
                         {purpose,"example of attributes"},
                         {vsn,[1234]}]}]}

%% beam_lib:chunks可以在不载入模块代码的情况下提取模块里的属性数据。</code></pre> 
      <h2>五：块表达式</h2> 
      <div> 
       <span style="color:#000000;">块表达式用于以下情形：代码某处的</span> 
       <span style="color:#000000;">Erlang</span> 
       <span style="color:#000000;">语法要求单个表达式，但我们想使用一个表达式 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">序列。举个例子，在一个形式为</span> 
       <span style="color:#000000;">[E || ...]</span> 
       <span style="color:#000000;">的列表推导中，语法要求</span> 
       <span style="color:#000000;">E</span> 
       <span style="color:#000000;">是单个表达式，但我们也 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">许想要在</span> 
       <span style="color:#000000;">E</span> 
       <span style="color:#000000;">里做不止一件事情。</span> 
       <pre><code class="language-Erlang">begin
   Expr1,
   ...,
   ExprN
end</code></pre> 
       <div> 
        <span style="color:#000000;">你可以用块表达式归组一个表达式序列，就像子句的主体一样。begin ... end的值就是块 </span> 
       </div> 
       <div> 
        <span style="color:#000000;">里<strong>最后那个表达式的值（ExprN）</strong>。</span> 
       </div> 
       <div></div> 
       <h2>六：<span style="color:#000000;">布尔值</span></h2> 
       <div> 
        <strong><span style="color:#000000;">Erlang</span></strong> 
        <span style="color:#000000;"><strong>没有单独的布尔值类型</strong>。不过原子</span> 
        <span style="color:#000000;">true</span> 
        <span style="color:#000000;">和</span> 
        <span style="color:#000000;">false</span> 
        <span style="color:#000000;">具有特殊的含义，可以用来表示布尔值。 </span> 
       </div> 
       <div> 
        <span style="color:#000000;">有时候编写的函数会返回两个可能的原子值中的一个。这时，正确的做法是确保它们返回一 </span> 
       </div> 
       <div> 
        <span style="color:#000000;">个布尔值。与此同时，让你的函数名称反映出它们会返回布尔值也是一个好主意。 </span> 
       </div> 
       <div> 
        <div> 
         <span style="color:#000000;">假设有一个文件列表</span> 
         <span style="color:#000000;">L</span> 
         <span style="color:#000000;">并想把它分成一个打开文件列表和一个关闭文件列表。可 </span> 
        </div> 
        <div> 
         <span style="color:#000000;">以编写以下代码来利用标准库:</span> 
         <pre><code class="language-Erlang">lists:partition(fun is file open/1,L)

%% 但如果用的是fi1 e_state/1函数，恐怕就要先编写一个转换程序才能调用库方法了。

lists:partition(fun (X)-&gt;
                 case file_state(X)of
                    open -&gt; true;
                    closed -&gt; false
                end,L).</code></pre> 
         <h2>七：<span style="color:#000000;">布尔表达式</span></h2> 
         <div> 
          <span style="color:#000000;">可用的布尔表达式有<strong>四种</strong>。 </span> 
         </div> 
         <div> 
          <span style="color:#000000;">（1） </span> 
          <strong><span style="color:#000000;">not B1</span></strong> 
          <span style="color:#000000;">：逻辑非 </span> 
         </div> 
         <div> 
          <span style="color:#000000;">（2） </span> 
          <strong><span style="color:#000000;">B1 and B2</span></strong> 
          <span style="color:#000000;">：逻辑与 </span> 
         </div> 
         <div> 
          <span style="color:#000000;">（3） <strong>B1 or B2</strong></span> 
          <span style="color:#000000;">：逻辑或 </span> 
         </div> 
         <div> 
          <span style="color:#000000;">（4） </span> 
          <strong><span style="color:#000000;">B1 xor B2</span></strong> 
          <span style="color:#000000;">：逻辑异或 </span> 
         </div> 
         <div> 
          <span style="color:#000000;">在所有这些表达式里，</span> 
          <span style="color:#000000;">B1</span> 
          <span style="color:#000000;">和</span> 
          <span style="color:#000000;">B2</span> 
          <span style="color:#000000;">都必须是<strong>布尔值</strong>或者<strong>执行结果为布尔值的表达式</strong>。这里有一 </span> 
         </div> 
         <div> 
          <span style="color:#000000;">些例子：</span> 
          <pre><code class="language-Erlang">1&gt;not true.
false
2&gt;true a
and false.
false
3&gt;true or false.
true
4&gt;(2&gt;1)0r(3&gt;4).
true</code></pre> 
          <h2><strong>八：<span style="color:#000000;">字符集</span></strong></h2> 
          <div> 
           <span style="color:#000000;">从</span> 
           <span style="color:#000000;">Erlang</span> 
           <span style="color:#000000;">的</span> 
           <span style="color:#000000;">R16B</span> 
           <span style="color:#000000;">版开始，</span> 
           <span style="color:#000000;">Erlang</span> 
           <span style="color:#000000;">源代码文件都假定采用</span> 
           <span style="color:#000000;">UTF-8</span> 
           <span style="color:#000000;">字符集编码。在这之前用的是 </span> 
          </div> 
          <div> 
           <span style="color:#000000;">ISO-8859-1</span> 
           <span style="color:#000000;">（</span> 
           <span style="color:#000000;">Latin-1</span> 
           <span style="color:#000000;">）字符集。这就意味着所有</span> 
           <span style="color:#000000;">UTF-8</span> 
           <span style="color:#000000;">可打印字符都能在源代码文件里使用，无 </span> 
          </div> 
          <div> 
           <span style="color:#000000;">需使用任何转义序列。 </span> 
          </div> 
          <div> 
           <span style="color:#000000;">Erlang</span> 
           <span style="color:#000000;">内部没有字符数据类型。字符串其实并不存在，而是由整数列表来表示。用整数列表 </span> 
          </div> 
          <div> 
           <span style="color:#000000;">表示</span> 
           <span style="color:#000000;">Unicode</span> 
           <span style="color:#000000;">字符串是毫无问题的。</span> 
          </div> 
          <div></div> 
          <h2><span style="color:#000000;">九：注释</span></h2> 
          <div> 
           <span style="color:#000000;">Erlang</span> 
           <span style="color:#000000;">里的注释从一个百分号字符（</span> 
           <span style="color:#000000;">%</span> 
           <span style="color:#000000;">）开始，一直延伸到行尾。</span> 
           <span style="color:#000000;">Erlang</span> 
           <span style="color:#000000;">没有块注释。</span> 
          </div> 
          <div> 
           <div> 
            <span style="color:#fe2c24;">注： 在代码示例里经常出现两个百分号字符（%%）。双百分号标记能被Erlang模式的Emacs </span> 
           </div> 
           <div> 
            <span style="color:#fe2c24;">编辑器识别，并启动注释行自动缩进功能。</span> 
           </div> 
           <div></div> 
           <h2><span style="color:#0d0016;">十：动态代码载入</span></h2> 
           <div> 
            <span style="color:#000000;">动态代码载入是内建于</span> 
            <span style="color:#000000;">Erlang</span> 
            <span style="color:#000000;">核心的最惊人特性之一。它的美妙之处在于你无需了解后台的 </span> 
           </div> 
           <div> 
            <span style="color:#000000;">运作就能顺利实现它。 </span> 
           </div> 
           <div> 
            <span style="color:#000000;">它的思路很简单：每当调用</span> 
            <span style="color:#000000;">someModule:someFunction(...)</span> 
            <span style="color:#000000;">时，调用的总是最新版模块 </span> 
           </div> 
           <div> 
            <span style="color:#000000;">里的最新版函数，</span> 
            <span style="color:#000000;">哪怕当代码在模块里运行时重新编译了该模块也是如此</span> 
            <span style="color:#000000;">。 </span> 
           </div> 
           <div> 
            <span style="color:#000000;">如果在</span> 
            <span style="color:#000000;">a</span> 
            <span style="color:#000000;">循环调用</span> 
            <span style="color:#000000;">b</span> 
            <span style="color:#000000;">时重新编译了</span> 
            <span style="color:#000000;">b</span> 
            <span style="color:#000000;">，那么下一次</span> 
            <span style="color:#000000;">a</span> 
            <span style="color:#000000;">调用</span> 
            <span style="color:#000000;">b</span> 
            <span style="color:#000000;">时就会自动调用新版的</span> 
            <span style="color:#000000;">b</span> 
            <span style="color:#000000;">。如果有许 </span> 
           </div> 
           <div> 
            <span style="color:#000000;">多不同进程正在运行而它们都调用了</span> 
            <span style="color:#000000;">b</span> 
            <span style="color:#000000;">，那么当</span> 
            <span style="color:#000000;">b</span> 
            <span style="color:#000000;">被重新编译后，所有这些进程就都会调用新版的 </span> 
           </div> 
           <div> 
            <span style="color:#000000;">b</span> 
            <span style="color:#000000;">。为了了解它的工作原理，我们将编写两个小模块：</span> 
            <span style="color:#000000;">a</span> 
            <span style="color:#000000;">和</span> 
            <span style="color:#000000;">b</span> 
            <span style="color:#000000;">。</span> 
            <span style="color:#000000;">b</span> 
            <span style="color:#000000;">模块非常简单。</span> 
           </div> 
           <div></div> 
           <div> 
            <strong><span style="color:#000000;">b.erl</span></strong> 
            <pre><code class="language-Erlang">-module(b).
-export([x/0]).

×() -&gt; 1.</code></pre> 
            <p><strong>a.erl</strong></p> 
            <pre><code class="language-Erlang">-module(a)
-compile(export_all).

start(Tag)-&gt;
    spawn (fun()-loop(Tag)end).

loop(Tag)-&gt;
    sleep(),
    Val b:x(),
    io:format("Vsn1 (-p)b:x()=-p-n",[Tag,Val]),
    loop(Tag).

sleep()-&gt;
    receive
        after 3000-&gt;true
    end.</code></pre> 
            <p>现在编译a和b,启动两个a进程：</p> 
            <pre><code class="language-Erlang">1&gt; c(b),
Hok,b}

2&gt; c(a).
{ok,a}

3&gt; a:start(one).
&lt;0.41.0&gt;
Vsnl (one)b:x() = 1

4&gt; a:start(two).
&lt;0.43.0&gt;
Vsnl (one)b:x() = 1
Vsnl (two)b:x() = 1
Vsn1 (one)b:x() = 1
Vsn1 (two)b:x() = 1</code></pre> 
            <div> 
             <span style="color:#000000;">这些</span> 
             <span style="color:#000000;">a</span> 
             <span style="color:#000000;">进程休眠</span> 
             <span style="color:#000000;">3</span> 
             <span style="color:#000000;">秒钟后唤醒并调用</span> 
             <span style="color:#000000;">b:x()</span> 
             <span style="color:#000000;">，然后打印出结果。现在进入编辑器，把模块</span> 
             <span style="color:#000000;">b</span> 
             <span style="color:#000000;">改 </span> 
            </div> 
            <div> 
             <span style="color:#000000;">成下面这样：</span> 
             <pre><code class="language-Erlang">%% 修改b.erl
-module(b)
-export([x/0]).

x() -&gt; 2.</code></pre> 
             <div> 
              <span style="color:#000000;">然后在</span> 
              <span style="color:#000000;">shell</span> 
              <span style="color:#000000;">里重新编译</span> 
              <span style="color:#000000;">b</span> 
              <span style="color:#000000;">。就会发生：</span> 
              <pre><code class="language-Erlang">5&gt; c(b).
{ok,b}
Vsnl (one)b:x() = 2
Vsn1 (two)b:x() = 2
Vsnl (one)b:x() = 2
Vsn1 (two)b:x() = 2
...</code></pre> 
              <div> 
               <span style="color:#000000;">两个原版的</span> 
               <span style="color:#000000;">a</span> 
               <span style="color:#000000;">仍然在运行，但现在它们调用了</span> 
               <span style="color:#000000;">新版</span> 
               <span style="color:#000000;">的</span> 
               <span style="color:#000000;">b</span> 
               <span style="color:#000000;">。所以，在模块</span> 
               <span style="color:#000000;">a</span> 
               <span style="color:#000000;">里调用</span> 
               <span style="color:#000000;">b:x()</span> 
               <span style="color:#000000;">时，实 </span> 
              </div> 
              <div> 
               <span style="color:#000000;">际上是在调用“</span> 
               <span style="color:#000000;">b</span> 
               <span style="color:#000000;">的最新版”。我们可以随心所欲地多次修改并重新编译</span> 
               <span style="color:#000000;">b</span> 
               <span style="color:#000000;">，而所有调用它的模块 </span> 
              </div> 
              <div> 
               <span style="color:#000000;">无需特别处理就会自动调用新版的</span> 
               <span style="color:#000000;">b</span> 
               <span style="color:#000000;">。</span> 
              </div> 
              <div>
                如果重新编译a，则会发生原启动的a还运行原来的，而新启动的a会运行新的： 
               <pre><code class="language-Erlang">%% 这里修改a.erl
-module(a).
-compile(export_all).

start(Tag)-&gt;
    spawn(fun()-&gt;loop(Tag)end).

loop(Tag）-&gt;
    sleep(),
    Val b:x(),
    io:format("Vsn2 (-p)b:x()=-p-n",[Tag,Val]),
    loop(Tag).

sleep()-&gt;
    receive
    after 3000 -&gt; true
    end.</code></pre> 
               <p>编译a,并启动第三个a:</p> 
               <pre><code class="language-Erlang">6&gt;c(a).
ok,a}
Vsn1 (one)b:x() = 2
Vsn1 (two)b:x() = 2

7&gt;a:start(three).
&lt;0.53.0&gt;
Vsn1 (one)b:x() = 2
Vsn1 (two)b:x() = 2
Vsn2 (three)b:x() = 2
Vsnl (one)b:x() = 2
Vsn1 (two)b:×() = 2
Vsn2 (three)b:x() = 2</code></pre> 
               <div> 
                <span style="color:#000000;">启动新版的</span> 
                <span style="color:#000000;">a</span> 
                <span style="color:#000000;">后，我们看到了新版正在运行。但是，那些运行最初版</span> 
                <span style="color:#000000;">a </span> 
               </div> 
               <div> 
                <span style="color:#000000;">的现有进程仍然在正常地运行旧版的</span> 
                <span style="color:#000000;">a</span> 
                <span style="color:#000000;">。</span> 
               </div> 
               <div> 
                <span style="color:#fe2c24;">注：当第三次修改a后并编译，则会第一次修改的a会自动终止，Erlang允许一个模块的两个版本同时运行：当前版和旧版。</span> 
               </div> 
               <div></div> 
               <h2><span style="color:#0d0016;"><strong>十一：Erlang 的预处理器</strong></span></h2> 
               <div> 
                <span style="color:#000000;">Erlang</span> 
                <span style="color:#000000;">模块在编译前会自动由</span> 
                <span style="color:#000000;">Erlang</span> 
                <span style="color:#000000;">的预处理器进行处理。预处理器会展开源文件里所有的 </span> 
               </div> 
               <div> 
                <span style="color:#000000;">宏，并插入必要的包含文件。 </span> 
               </div> 
               <div> 
                <span style="color:#000000;">通常情况下，无需查看预处理器的输出，但在特定情形下（比如调试某个有问题的宏时）， </span> 
               </div> 
               <div> 
                <span style="color:#000000;">应该保存预处理器的输出。要查看</span> 
                <span style="color:#000000;">some_module.erl</span> 
                <span style="color:#000000;">模块的预处理结果，可以在操作系统的</span> 
                <span style="color:#000000;">shell </span> 
               </div> 
               <div> 
                <span style="color:#000000;">里输入以下命令。</span> 
                <pre><code class="language-Erlang">$ erlc -P some_module.erl</code></pre> 
               </div> 
               <div> 
                <span style="color:#000000;">这会生成一个名为</span> 
                <span style="color:#000000;">some_module.P</span> 
                <span style="color:#000000;">的清单文件。</span> 
               </div> 
               <div></div> 
               <h2>十二：<span style="color:#000000;">转义序列</span></h2> 
               <div> 
                <span style="color:#000000;">可以在字符串和带引号的原子里使用转义序列来输入任何不可打印的字符。表</span> 
                <span style="color:#000000;">4</span> 
                <span style="color:#000000;">列出了所有 </span> 
               </div> 
               <div> 
                <span style="color:#000000;">可用的转义序列。 </span> 
               </div> 
               <div> 
                <span style="color:#000000;">让我们在</span> 
                <span style="color:#000000;">shell</span> 
                <span style="color:#000000;">里举一些例子来展示这些约定方式是如何工作的。（注意：格式字符串里的</span> 
                <span style="color:#000000;">~w </span> 
               </div> 
               <div> 
                <span style="color:#000000;">是指忠实地打印列表，而不对输出结果进行美化。）如：</span> 
                <pre><code class="language-Erlang">%% 控制字符
1&gt; io:format("~w~n",["\b\d\e\f\n\r\s\t\v"]).
[8,127,27,12,10,13,32,9,11]
ok

%% 字符串里的八进制字符
2&gt; io:format("-w-n",["\123\12\1"]）.
[83,10,1]
ok

%% 字符串里的引号和反斜杠
3&gt; io:format("-w-n",["\'\"\\"]).
[39,34,92]
ok

%% 字符编码
4&gt; io:format("~w-n",["\a\z\A\Z"]).
[97,122,65,90]
ok</code></pre> 
                <p>下面是一个转义序列表：</p> 
                <table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th>转义序列</th><th>含义</th><th>整数编码</th></tr></thead><tbody><tr><td>\b</td><td>退格符</td><td>8</td></tr><tr><td>\d</td><td>删除符</td><td>127</td></tr><tr><td>\e</td><td>换码符</td><td>27</td></tr><tr><td>\f</td><td>换页符</td><td>12</td></tr><tr><td>\n</td><td>换行符</td><td>10</td></tr><tr><td>\r</td><td>回车符</td><td>13</td></tr><tr><td>\s</td><td>空格符</td><td>32</td></tr><tr><td>\t</td><td>制表符</td><td>9</td></tr><tr><td>\v</td><td>垂直制表符</td><td>11</td></tr><tr><td>\x{...}</td><td>十六进制字符（是十六进制字符）</td><td></td></tr><tr><td>\a..\Z或\A..\Z</td><td>Crl+A至Ctrl+Z</td><td>1至26</td></tr><tr><td>\'</td><td>单引号</td><td>39</td></tr><tr><td>\"</td><td>双引号</td><td>34</td></tr><tr><td>\\</td><td>反斜杠</td><td>92</td></tr><tr><td>\C</td><td>C的ASCⅡ编码(C是一个字符)</td><td>(一个整数)</td></tr></tbody></table> 
                <h2>十三：<span style="color:#000000;">表达式和表达式序列</span></h2> 
                <div> 
                 <span style="color:#000000;">在</span> 
                 <span style="color:#000000;">Erlang</span> 
                 <span style="color:#000000;">里，<strong>任何可以执行并生成一个值的事物都被称为</strong></span> 
                 <strong><span style="color:#000000;">表达式</span></strong> 
                 <span style="color:#000000;">（</span> 
                 <span style="color:#000000;">expression</span> 
                 <span style="color:#000000;">）。这就意味着<strong>catch</strong>、</span> 
                 <span style="color:#000000;"><strong>if</strong> </span> 
                 <span style="color:#000000;">和 </span> 
                 <span style="color:#000000;"><strong>try...catch</strong> </span> 
                 <span style="color:#000000;">这些都是表达式。而记录声明和模块属性这些不能被求值，所以它们不是表达式。 </span> 
                </div> 
                <div> 
                 <strong><span style="color:#000000;">表达式序列</span><span style="color:#000000;">（</span><span style="color:#000000;">expression sequence</span></strong> 
                 <span style="color:#000000;"><strong>）是一系列由逗号分隔的表达式</strong>。它们在</span> 
                 <span style="color:#000000;">-&gt;</span> 
                 <span style="color:#000000;">箭头之后随处 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">可见。表达式序列</span> 
                 <span style="color:#000000;">E1, E2,..., En</span> 
                 <span style="color:#000000;">的值被定义为序列最后那个表达式的值，而该表达式在计算 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">时可以使用</span> 
                 <span style="color:#000000;">E1, E2</span> 
                 <span style="color:#000000;">等表达式所创建的绑定。它就等价于</span> 
                 <span style="color:#000000;">LISP</span> 
                 <span style="color:#000000;">里的</span> 
                 <span style="color:#000000;">progn</span> 
                 <span style="color:#000000;">。</span> 
                </div> 
                <h2><br><strong>十四：<span style="color:#000000;">函数引用</span></strong></h2> 
                <div> 
                 <span style="color:#000000;">我们有时想引用在当前或外部模块里定义的某个函数，可以用下列标记实现。</span> 
                 <pre><code class="language-Erlang">(1) fun LocalFunc/Arity
%% 用于引用当前模块里参数为Arity的本地函数LocalFunc。

(2) fun Mod:RemoteFunc/Arity
%% 用于引用Mod模块里参数为Arity的外部函数RemoteFunc。</code></pre> 
                 <p>具体实例：</p> 
                 <pre><code class="language-Erlang">-module(x1).
-export([square/1]).

square(X) -&gt; XX.
double(L) -&gt; lists:map(fun square/1,L).

%% 这square指的就是内部函数，lists:map指的就是外部函数</code></pre> 
                 <div> 
                  <span style="color:#fe2c24;">注：包含模块名的函数引用提供了动态代码升级的切换点。</span> 
                 </div> 
                </div> 
               </div> 
              </div> 
             </div> 
            </div> 
           </div> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<p></p> 
<h2>十五：<span style="color:#000000;">包含文件</span></h2> 
<p><span style="color:#000000;">包含文件的语法为：</span></p> 
<pre><code class="language-Erlang">(1) -include(Filename).
%% 按照Erlang的惯例，包含文件的扩展名是.hrl。FileName应当包含一个绝对或相对路径，
%% 使预处理器能找到正确的文件。

%% 包含库的头文件（library header file）时可以用下面的语法：
(2) -include_lib(Name).</code></pre> 
<p> 实例为：</p> 
<pre><code class="language-Erlang">-include_lib("kernel/include/file.hrl").
%% 在这种情况下，Erlang编译器会找到正确的包含文件。（例子中的kernel是指定义该头
%% 文件的应用。）</code></pre> 
<div> 
 <span style="color:#000000;">包含文件里经常会有记录的定义。如果许多模块需要共享通用的记录定义，就会把它们放到 </span> 
</div> 
<div> 
 <span style="color:#000000;">包含文件里，再由所有需要这些定义的模块包含此文件。</span> 
</div> 
<div></div> 
<h2>十六：<span style="color:#000000;">列表操作：</span><span style="color:#000000;">++</span><span style="color:#000000;">和</span><span style="color:#000000;">--</span></h2> 
<div> 
 <span style="color:#000000;">++ </span> 
 <span style="color:#000000;">和 </span> 
 <span style="color:#000000;">-- </span> 
 <span style="color:#000000;">是用于列表添加和移除的中缀操作符。 </span> 
</div> 
<div> 
 <span style="color:#000000;">A ++ B</span> 
 <span style="color:#000000;">使</span> 
 <span style="color:#000000;">A</span> 
 <span style="color:#000000;">和</span> 
 <span style="color:#000000;">B</span> 
 <span style="color:#000000;">相加（也就是附加）。 </span> 
</div> 
<div> 
 <span style="color:#000000;">A -- B</span> 
 <span style="color:#000000;">从列表</span> 
 <span style="color:#000000;">A</span> 
 <span style="color:#000000;">中移除列表</span> 
 <span style="color:#000000;">B</span> 
 <span style="color:#000000;">。移除的意思是</span> 
 <span style="color:#000000;">B</span> 
 <span style="color:#000000;">中所有元素都会从</span> 
 <span style="color:#000000;">A</span> 
 <span style="color:#000000;">里面去除。请注意：如果 </span> 
</div> 
<div> 
 <span style="color:#000000;">符号</span> 
 <span style="color:#000000;">X</span> 
 <span style="color:#000000;">在</span> 
 <span style="color:#000000;">B</span> 
 <span style="color:#000000;">里只出现了</span> 
 <span style="color:#000000;">K</span> 
 <span style="color:#000000;">次，那么</span> 
 <span style="color:#000000;">A</span> 
 <span style="color:#000000;">只会移除前</span> 
 <span style="color:#000000;">K</span> 
 <span style="color:#000000;">个</span> 
 <span style="color:#000000;">X</span> 
 <span style="color:#000000;">。</span> 
</div> 
<div> 
 <span style="color:#000000;">列如：</span> 
 <pre><code class="language-Erlang">1&gt; [1,2,3]++[4,5,6].
[1,2,3,4,5,6]

2&gt; [a,b,c,1,d,e,1,x,y,1] -- [1].
[a,b,c,d,e,1,x,y,1]

3&gt; [a,b,c,1,d,e,1,×,y,1] -- [1,1].
[a,b,c,d,e,x,y,1]

4&gt; [a,b,c,1,d,e,1,x,y,1] -- [1,1,1].
[a,b,c,d,e,x,y]

5&gt; [a,b,c,1,d,e,1,X,y,1] -- [1,1,1,1].
[a,b,c,d,e,x,y]</code></pre> 
 <div> 
  <span style="color:#000000;">++</span> 
  <span style="color:#000000;">也可以用在模式里。在匹配字符串时，如：</span> 
  <pre><code class="language-Erlang">f("begin" ++ T) -&gt; ...
f("end" ++ T) -&gt; ...
...</code></pre> 
  <div> 
   <span style="color:#000000;">子句</span> 
   <span style="color:#000000;">1</span> 
   <span style="color:#000000;">里的模式会扩展成</span> 
   <span style="color:#000000;">[$b,$e,$g,$i,$n|T]</span> 
   <span style="color:#000000;">。</span>  
  </div> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0fe9e5240a2952f7dab9739724dd0de9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">华为静态路由</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/52883dbe71aec6fe001b13546dddfd57/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Git】Git基础命令操作速记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>