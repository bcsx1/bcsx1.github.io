<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2023前端常见面试题大全 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2023前端常见面试题大全" />
<meta property="og:description" content="1. 什么是作用域？ 变量 产生作用的区域就叫做作用域
2. 作用域的分类 全局作用域
局部作用域
3.局部作用域的分类 函数作用域
块级作用域
4.作用域链 作用域链的本质是变量查找机制
5.作用域链查找规则是什么？ a. 会优先查找自己的作用域
b. 自己的作用域查找不到的话会往上查找父级直到全局作用域
6.什么是垃圾回收机制 是 JS 中一种自动回收或释放内存的机制 简称 GC
7.垃圾回收机制有几种算法？ 引用计数法：IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用
如果这个值的被引用了一次，那么就记录次数1 ， 如果减少一个引用就减1。 如果引用次数是0 ，则释放内存。但它却存在一个致命的问题：嵌套引用。
标记清除法：就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。
无法由根部出发触及到的对象被标记为不再使用，稍后进 行回收
8.什么是闭包？ 就是有权访问另一个函数作用域中变量的函数
9.闭包的表现形式？ 在一个函数内部创建另外一个函数
10.闭包有什么作用？ 封闭数据，实现数据私有，防止数据被意外修改
11.闭包的弊端 容易导致内存泄露
12.什么是变量提升？ 使用 var 声明的变量，会被提升到函数或全局作用域的顶部，这个现象叫做变量提升。
13.用哪个关键词会产生变量提升？ var会存在变量提升，let/const 声明的变量不存在变量提升
14.什么是构造函数 是一种特殊的函数，主要用来初始化对象 ，同时可以用构造函数来快速创建多个类似的对象。
15.构造函数创建对象的过程 创建新对象构造函数this指向新对象执行构造函数代码，修改this，添加新的属性返回新对象 16.伪数组转真数组的方法 1.Array.from
2.Array.prototype.slice.call( )
3…展开运算符
17.什么是JavaScript 中的包装类型 在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台地将基本类型的值转换为对象，这些对象就是包装类型
18. JavaScript有哪些数据类型，它们的区别？ JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f2dc000ea01463ecb7b5f0f3a70863ab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-18T18:02:00+08:00" />
<meta property="article:modified_time" content="2023-05-18T18:02:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2023前端常见面试题大全</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1__2"></a>1. 什么是作用域？</h3> 
<p>变量 产生作用的区域就叫做作用域</p> 
<h3><a id="2__6"></a>2. 作用域的分类</h3> 
<p>全局作用域</p> 
<p>局部作用域</p> 
<h3><a id="3_12"></a>3.局部作用域的分类</h3> 
<p>函数作用域</p> 
<p>块级作用域</p> 
<h3><a id="4_18"></a>4.作用域链</h3> 
<p>作用域链的本质是变量查找机制</p> 
<h3><a id="5_22"></a>5.作用域链查找规则是什么？</h3> 
<p>a. 会优先查找自己的作用域</p> 
<p>b. 自己的作用域查找不到的话会往上查找父级直到全局作用域</p> 
<h3><a id="6_28"></a>6.什么是垃圾回收机制</h3> 
<p>是 <code>JS</code> 中一种自动回收或释放内存的机制 简称 <code>GC</code></p> 
<h3><a id="7_32"></a>7.垃圾回收机制有几种算法？</h3> 
<p><strong>引用计数法</strong>：IE采用的引用计数算法, 定义“<code>内存不再使用</code>”的标准很简单，就是看一个对象是否有指向它的引用</p> 
<p>如果这个值的被引用了一次，那么就记录次数1 ， 如果减少一个引用就减1。 如果引用次数是0 ，则释放内存。但它却存在一个致命的问题：<strong>嵌套引用</strong>。</p> 
<p><strong>标记清除法</strong>：就是从<code>根部</code>（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。</p> 
<p>无法由根部出发触及到的对象被标记为不再使用，稍后进 行回收</p> 
<h3><a id="8_42"></a>8.什么是闭包？</h3> 
<p>就是有权访问另一个函数作用域中变量的函数</p> 
<h3><a id="9_46"></a>9.闭包的表现形式？</h3> 
<p>在一个函数内部创建另外一个函数</p> 
<h3><a id="10_50"></a>10.闭包有什么作用？</h3> 
<p>封闭数据，实现数据私有，防止数据被意外修改</p> 
<h3><a id="11_54"></a>11.闭包的弊端</h3> 
<p>容易导致内存泄露</p> 
<h3><a id="12_58"></a>12.什么是变量提升？</h3> 
<p>使用 <code>var</code> 声明的变量，会被提升到函数或全局作用域的顶部，这个现象叫做变量提升。</p> 
<h3><a id="13_62"></a>13.用哪个关键词会产生变量提升？</h3> 
<p><code>var</code>会存在变量提升，<code>let/const</code> 声明的变量<code>不存在变量提升</code></p> 
<h3><a id="14_66"></a>14.什么是构造函数</h3> 
<p>是一种特殊的函数，主要用来初始化对象 ，同时可以用构造函数来快速创建多个类似的对象。</p> 
<h3><a id="15_70"></a>15.构造函数创建对象的过程</h3> 
<ol><li>创建新对象</li><li>构造函数this指向新对象</li><li>执行构造函数代码，修改this，添加新的属性</li><li>返回新对象</li></ol> 
<h3><a id="16_77"></a>16.伪数组转真数组的方法</h3> 
<p>1.<code>Array.from</code></p> 
<p>2.<code>Array.prototype.slice.call( )</code></p> 
<p>3…展开运算符</p> 
<h3><a id="17JavaScript__87"></a>17.什么是JavaScript 中的包装类型</h3> 
<p>在 <code>JavaScript</code> 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 <code>JavaScript</code> 会在后台地将基本类型的值转换为对象，这些对象就是包装类型</p> 
<h3><a id="18_JavaScript_91"></a>18. JavaScript有哪些数据类型，它们的区别？</h3> 
<p><code>JavaScript</code>共有八种数据类型，分别是 <code>Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt</code>。</p> 
<p>其中 <code>Symbol</code> 和 <code>BigInt</code> 是 ES6 中新增的数据类型</p> 
<p><code>Symbol</code> 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</p> 
<p><code>BigInt</code> 是一种数字类型的数据，<strong>它可以表示任意精度格式的整数</strong>，使用 <code>BigInt</code> 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</p> 
<p>这些数据可以分为原始数据类型和引用数据类型：</p> 
<p>栈：原始数据类型（<code>Undefined、Null、Boolean、Number、String、Symbol 、BigInt</code>）</p> 
<p>堆：引用数据类型（对象、数组和函数）</p> 
<h3><a id="19isNaN__NumberisNaN__107"></a>19.isNaN 和 Number.isNaN 函数的区别</h3> 
<blockquote> 
 <p>重点在于判断 是不是NaN，而不是 <strong>数字</strong></p> 
</blockquote> 
<ol><li>函数 <code>isNaN</code> 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 <code>true</code>，因此非数字值传入也会返回 <code>true</code> ，会影响 <code>NaN</code> 的判断。</li><li>函数 <code>Number.isNaN</code> 只会判断 传入的数据 是不是 一个 <code>NaN</code>,并且不会帮你做类型转换。</li></ol> 
<h3><a id="20_114"></a>20.对原型、原型链的理解</h3> 
<p>原型，也叫原型对象，构造函数的一个属性，名字是 <code>prototype</code>，它本身也是一个对象类型。在构造函数的原型所添加的成员可以被实例所共享。</p> 
<p>原型链，指的基于原型继承的那些对象中，它们是通过 原型 <code>prototype</code> 将彼此联系在一起的，这个关系就叫做原型链。</p> 
<h3><a id="21_120"></a>21.原型链-查找规则</h3> 
<p>① 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。<br> ② 如果没有就查找它的原型（也就是 <code>proto</code> 指向的 <code>prototype</code> 原型对象）<br> ③ 如果还没有就查找原型对象的原型（Object的原型对象）<br> ④ 依此类推一直找到 <code>Object</code> 为止（null）<br> ⑤ <code>proto</code> 对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线</p> 
<h3><a id="22_128"></a>22.什么是递归</h3> 
<p>函数内部自己调用自己, 这个函数就是递归函数，往往都需要添加终止递归的条件。</p> 
<h3><a id="23__132"></a>23.什么是深拷贝 什么是浅拷贝</h3> 
<ol><li> <p>浅拷贝只是针对引用类型数据中的属性做了一层复制，如果被拷贝的属性也是引用类型，那么这个属性只是复制了这个引用地址。</p> <p>做了浅拷贝的对象之间可能会<strong>相互影响</strong></p> </li><li> <p>深拷贝是针对引用类型数据中的属性做无限层级的复制，不管属性是值类型还是引用类型，会完整复制一份。 其在堆内存中<strong>完全开辟了一块内存地址</strong>，并将原有的对象完全复制过来存放</p> <p>做了深拷贝的两个对象之间相互<strong>不会影响</strong></p> </li><li> <p><strong>除了 递归克隆对象、<code>JSON.stringify</code> 两种方式做的拷贝，其他方法全部都是浅拷贝</strong></p> </li></ol> 
<h3><a id="24callapplybind_144"></a>24.call、apply、bind的区别</h3> 
<ol><li>他们三都可以修改 <code>this</code> 指向，</li><li><code>call、apply</code> 在修改 this 指向的同时也会调用原函数、<code>bind</code> 只会返回修改 this 指向后的函数</li><li><code>call</code> 和 <code>apply</code> 接收参数的方式不一样，<code>call</code> 类似普通函数一样接收参数、<code>apply</code> 接收的参数必须都放在一个数组内。</li></ol> 
<h3><a id="25_150"></a>25.什么是防抖和节流</h3> 
<ol><li>所谓节流，就是在连续触发的行为中控制它在 n 秒中只执行一次 可以用在 <strong>轮播图点击效果 、 鼠标移动、页面尺寸缩放 resize、滚动条滚动</strong> 等场景</li><li>所谓防抖，在单位时间内，某个动作只能执行一次，如果在单位时间内多次触发，那么只有最后一次有效，可以用在 <strong>搜索框 业务中</strong>。</li></ol> 
<h2><a id="Ajax_155"></a>二、Ajax面试题</h2> 
<h3><a id="26HTTP__159"></a>26.HTTP 状态码</h3> 
<p><strong>成功（2XX）</strong></p> 
<table><thead><tr><th>状态码</th><th>原因短语</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>表示从客户端发来的请求在服务器端被正确处理</td></tr><tr><td>201</td><td>Created</td><td>请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴<br>通常是在POST请求，或是某些PUT请求之后创建了内容, 进行的返回的响应</td></tr><tr><td>202</td><td>Accepted</td><td>请求服务器已接受，但是尚未处理，不保证完成请求<br>适合异步任务或者说需要处理时间比较长的请求，避免HTTP连接一直占用</td></tr><tr><td>204</td><td>No content</td><td>表示请求成功，但响应报⽂不含实体的主体部分</td></tr><tr><td>206</td><td>Partial Content</td><td>进⾏的是范围请求, 表示服务器已经成功处理了部分 GET 请求<br>响应头中会包含获取的内容范围 (常用于分段下载)</td></tr></tbody></table> 
<p><strong>重定向（3XX）</strong></p> 
<table><thead><tr><th>状态码</th><th>原因短语</th><th>说明</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently</td><td>永久性重定向，表示资源已被分配了新的 URL<br>比如，我们访问 <strong>http</strong>😕/www.baidu.com 会跳转到 <strong>https</strong>😕/www.baidu.com</td></tr><tr><td>302</td><td>Move Temporarily</td><td>临时性重定向，表示资源临时被分配了新的 URL, 支持搜索引擎优化<br>首页, 个人中心, 遇到了需要登录才能操作的内容, 重定向 到 登录页</td></tr><tr><td>303</td><td>See Other</td><td>对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI。</td></tr><tr><td><strong>304</strong></td><td><strong>Not Modified</strong></td><td><strong>自从上次请求后，请求的网页内容未修改过。<br>服务器返回此响应时，不会返回网页内容。(协商缓存)</strong></td></tr><tr><td>307</td><td>Temporary Redirect</td><td>对于POST请求，表示请求还没有被处理，客户端应该向Location里的URI重新发起POST请求。<br>不对请求做额外处理, 正常发送请求, 请求location中的url地址</td></tr></tbody></table> 
<p><strong>客户端错误（4XX）</strong></p> 
<table><thead><tr><th>状态码</th><th>原因短语</th><th>说明</th></tr></thead><tbody><tr><td><strong>400</strong></td><td><strong>Bad Request</strong></td><td><strong>请求报⽂存在语法错误(（传参格式不正确）</strong></td></tr><tr><td>401</td><td>UnAuthorized</td><td>权限认证未通过(没有权限)</td></tr><tr><td>403</td><td>Forbidden</td><td>表示对请求资源的访问被服务器拒绝</td></tr><tr><td>404</td><td>Not Found</td><td>表示在服务器上没有找到请求的资源</td></tr><tr><td>408</td><td>Request Timeout</td><td>客户端请求超时</td></tr><tr><td>409</td><td>Confict</td><td>请求的资源可能引起冲突</td></tr></tbody></table> 
<p><strong>服务端错误（5XX）</strong></p> 
<table><thead><tr><th>状态码</th><th>原因短语</th><th>说明</th></tr></thead><tbody><tr><td>500</td><td>Internal Sever Error</td><td>表示服务器端在执⾏请求时发⽣了错误</td></tr><tr><td>501</td><td>Not Implemented</td><td>请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，<br>或者请求是服务器不⽀持的某个⽅法</td></tr><tr><td>503</td><td>Service Unavailable</td><td>表明服务器暂时处于超负载或正在停机维护，⽆法处理请求</td></tr><tr><td>505</td><td>Http Version Not Supported</td><td>服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本</td></tr></tbody></table> 
<h3><a id="27_DOM___205"></a>27. DOM - 事件流与事件委托</h3> 
<h6><a id="21__207"></a>2.1 事件流</h6> 
<p><strong>事件流</strong>：又称为事件传播，是页面中接收事件的顺序。DOM2级事件规定的事件流包括了3个阶段：</p> 
<ul><li>事件捕获阶段（capture phase）</li><li>处于⽬标阶段（target phase）</li><li>事件冒泡阶段（bubbling phase）</li></ul> 
<p><img src="https://images2.imgbox.com/25/7d/mfdor0wK_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TUiMxAC2-1678461708343)(assets/1676540896648.png)]"></p> 
<p><strong>事件捕获（Event Capturing）</strong></p> 
<p>事件开始由较为不具体的节点接收后，然后开始逐级向下传播到最具体的元素上。</p> 
<p>事件捕获的最大作用在于：事件在到达预定⽬标之前就可以捕获到它。</p> 
<p>如果仍以上面那段 HTML 代码为例，当点击按钮后，在事件捕获的过程中，document 对象会首先接收到这个 <code>click</code> 事件，然后再沿着 DOM 树依次向下，直到 <code>&lt;button&gt;</code>。具体顺序如下：</p> 
<ol><li>document 对象</li><li>html 元素</li><li>body 元素</li><li>button 元素</li></ol> 
<p><strong>事件冒泡（Event Bubbling）</strong></p> 
<p>事件开始由最具体的元素（⽂档中嵌套层次最深的那个节点）接收到后，开始逐级向上传播到较为不具体的节点。</p> 
<pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span> 
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span> 
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span> 
  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>如果点击了上面页面代码中的 <code>&lt;button&gt;</code> 按钮，那么该 <code>click</code> 点击事件会沿着 DOM 树向上逐级传播，在途经的每个节点上都会发生，具体顺序如下：</p> 
<ol><li>button 元素</li><li>body 元素</li><li>html 元素</li><li>document 对象</li></ol> 
<h6><a id="22__259"></a>2.2 事件委托</h6> 
<p>事件委托: 利用了事件冒泡的机制，在较上层位置的元素上添加一个事件监听函数，来管理该元素及其所有子孙元素上的某一类的所有事件。</p> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>222<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>333<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>444<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>555<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token comment">// ⽗元素 </span>
    <span class="token keyword">var</span> list <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'list'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 为⽗元素绑定事件，委托管理它的所有⼦元素li的点击事件 </span>
    list<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">var</span> currentTarget <span class="token operator">=</span> event<span class="token punctuation">.</span>target<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentTarget<span class="token punctuation">.</span>tagName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'li'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">alert</span><span class="token punctuation">(</span>currentTarget<span class="token punctuation">.</span>innerText<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<blockquote> 
 <p>适用场景：在绑定大量事件的时候，可以选择事件委托</p> 
</blockquote> 
<p><strong>优点</strong></p> 
<ul><li>事件委托可以减少事件注册数量，节省内存占⽤!</li><li>当新增⼦元素时，⽆需再次做事件绑定，因此非常适合动态添加元素 (vue解析模板时, 会对新创建的元素, 额外进行绑定的)</li></ul> 
<h3><a id="28_Post__ContentType__295"></a>28. Post 请求中 Content-Type 有哪几种类型？分别有什么特点？</h3> 
<p>主要有以下三种：</p> 
<ul><li><code>application/x-www-form-urlencoded</code>: 原生的 form 表单提交数据，数据会进行编码，较少使用</li><li><code>multipart/form-data</code>：可以上传键值对，也可以上传文件</li><li><code>application/json</code>：以 JSON 字符串的格式传递，效率较高，经常使用</li></ul> 
<p>问：如何设置这三种数据类型？</p> 
<ul><li>urlencoded：使用 <code>encodeURIComponent()</code></li><li>formData: 使用 <code>new FormData()</code></li><li>json: 使用 <code>JSON.stringify()</code></li></ul> 
<h3><a id="29__FormData__API_311"></a>29 . FormData 对象是什么？有哪些 API？</h3> 
<p><strong>FormData</strong> 是一个以 <strong>key/value 形式存储数据的对象</strong>，可以实现<strong>表单数据的序列化</strong>，包括普通的字符串、文件等，主要通过 Ajax <strong>发送表单数据</strong>，可以进行二进制的文件进行上传文件</p> 
<ul><li><code>new FormData()</code>：创建一个新的 FormData 对象， 
  <ul><li>参数为空时，创建一个空的 FormData 对象</li><li>参数为 form 元素时，创建一个包含表单元素各项值的 FormData 对象，详情见示例</li></ul> </li><li><code>FormData.append(key, val)</code>：向 FormData 中添加新的属性值，FormData 对应的属性值存在也不会覆盖原值，而是新增一个值，如果属性不存在则新增一项属性值</li><li><code>FormData.set(key, val)</code>：给 FormData 设置属性值，如果FormData 对应的属性值存在则覆盖原值，否则新增一项属性值</li><li><code>FormData.get(key)</code>：返回在 FormData 对象中与给定键关联的第一个值</li><li><code>FormData.delete(key)</code>：从 FormData 对象里面删除一个键值对</li><li><code>FormData.keys()</code>: 返回一个包含所有键的 iterator 对象</li><li><code>FormData.values()</code>: 返回一个包含所有值的 iterator 对象</li><li><code>FormData.entries()</code>: 返回一个包含所有键值对的 iterator 对象</li></ul> 
<h3><a id="30__promise__328"></a>30 . promise 有哪些常用的方法？作用分别是什么？</h3> 
<p>当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的：</p> 
<ul><li><code>Promise.prototype.then()</code>：为 Promise 实例添加状态改变时的回调函数 
  <ul><li>.then() 的第一个参数为成功时的回调</li><li>.then() 的第二个参数为失败时的回调</li><li>返回值为一个新的 promise</li></ul> </li><li><code>Promise.prototype.catch()</code>：用于指定发生错误时的回调函数 
  <ul><li>作用与 <code>.then(undefined, fn)</code> 一样</li><li>返回值为一个新的 promise</li></ul> </li><li><code>Promise.all()</code>: 获取所有的成功结果，或最先失败的结果 
  <ul><li>接收一个数组作为参数，如果数组项不是 promise 对象，则转换为 promise 对象</li><li>返回值为一个新的 promise，promise 的状态可分为如下两种情况： 
    <ul><li>所有 promise 对象 resolved 时，才 resolved</li><li>只要有一个 promise 对象 rejected 时，就 resolved</li></ul> </li></ul> </li><li><code>Promise.race()</code>: 获取最快的一个 promise 结果, 不论成功或失败 
  <ul><li>接收一个数组作为参数，如果数组项不是 promise 对象，则转换为 promise 对象</li><li>返回值为一个新的 promise，promise 的状态以传入数据的状态为准 
    <ul><li>但凡有一个 promise 为 resolved，就 resolved</li><li>但凡有一个 promise 为 rejected，就 rejected</li></ul> </li></ul> </li></ul> 
<h3><a id="31__352"></a>31. 什么是链式调用？为什么能用链式调用？</h3> 
<p><strong>链式调用</strong>：在调用对象上的某个方法之后，还可以接着调用其他方法，如 <code>[1,2,3].map().filter().concat()</code>、<code>axios({}).then().catch()</code></p> 
<p><strong>原因</strong>：方法的返回值是一个对象，对象上拥有某些方法，所以可以接着一直调用</p> 
<h4><a id="promise__358"></a>promise 对象为什么可以链式调用</h4> 
<ol><li><code>Promise</code> 对象的原型上有 <code>then()</code> 方法，可以被调用</li><li><code>then()</code>方法的返回值是一个新的 <code>Promise</code> 对象 ，状态是 pending</li><li>所以 <code>Promise</code> 最终可形成<code>.then().then().....</code> 这种链式结构</li><li><code>promise</code> 的状态没有改变，不会执行 <code>then</code> 里面的代码</li></ol> 
<p><strong>问题</strong>：如何实现一个 Person，可以满足以下的方式链式调用</p> 
<p><code>person.setName('Jack').setAge(18).sayHi().sleep()</code></p> 
<pre><code class="prism language-JavaScript">// 待实现代码
function Person() {
    this.name = '机器人1号'
    this.age = 100
}

// 待实现代码
Person.prototype.setName = function(name) {
  this.name = name
  return this
}

Person.prototype.setAge = function(age) {
  this.age = age
  return this
}

Person.prototype.sayHi = function() {
  console.log(`name: ${this.name} , age: ${this.age}`)
  return this
}

Person.prototype.sleep = function() {
  console.log('sleep')
  return this
}

const person = new Person()

person.setName('Jack').setAge(18).sayHi().sleep()
</code></pre> 
<h3><a id="32____402"></a>32 . 实现异步编程的方式有哪些？分别有哪些特点？</h3> 
<ul><li>回调函数 
  <ul><li>写法：<code>setTimeout(() =&gt; {}, 1000)</code>、<code>ele.addEventListener('click', () =&gt; {})</code></li><li>特点：将函数作为参数传入，并在特定的时机被调用，比较简单</li><li>说明：多个回调函数嵌套的时候会造成回调函数地狱，耦合度太高，不利于维护</li></ul> </li><li>promise 
  <ul><li>写法：<code>promise.then(() =&gt; {...})</code></li><li>特点：可以将嵌套的回调函数作为链式调用，可维护性增强</li><li>说明：有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确</li></ul> </li><li>async 异步函数</li><li><code>async</code> 声明的异步函数，它的返回值会自动包装为<code>promise</code></li><li><code>async</code>声明的异步函数中可以使用<code>await</code> 来调用其他异步函数</li><li>调用 <code>await</code> ，它会等待<code>promise</code> 执行出结果后将结果返回，可以通过变量接收结果</li><li> 
  <ul><li>写法：<code>async function () { await asyncFn() }</code></li><li>特点：将异步逻辑，转化为同步的顺序书写，更简洁，<strong>推荐使用</strong></li><li>说明：当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行</li></ul> </li></ul> 
<h3><a id="33____420"></a>33 . 浏览器的事件循环机制是什么？执行流程是怎样的？</h3> 
<p>JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事，为了解决单线程运行阻塞问题，JavaScript 用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）</p> 
<blockquote> 
 <p>如果 JS 设置为多线程，一个线程进行了删除 DOM ，另一个添加 DOM，会导致很多数据和页面更新的问题</p> 
</blockquote> 
<p>在 JavaScript 中，所有的任务都可以分为：</p> 
<ul><li><strong>同步任务</strong>：立即执行的任务，同步任务一般会直接进入到主线程中执行</li><li><strong>异步任务</strong>：异步执行的任务，比如ajax网络请求，setTimeout 定时函数等</li></ul> 
<p>微任务和宏任务在浏览器的执行顺序:</p> 
<ul><li>执行<strong>一个宏任务</strong></li><li>执行完<strong>微任务队列</strong></li><li>重复上面的步骤…</li></ul> 
<p><img src="https://images2.imgbox.com/85/8f/ywb4tO6n_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-n01k2jY8-1678461708344)(assets/1676434027852.png)]"></p> 
<p>微任务和宏任务的调度机制也被称作为<strong>事件循环机制 EventLoop</strong></p> 
<ul><li>宏任务 macrotask： 
  <ul><li>script (可以理解为外层同步代码)</li><li>setTimeout</li><li>setInterval</li><li>Ajax</li><li>浏览器触发的 DOM 事件（如 click、resize）</li><li>postMessage</li><li>MessageChannel</li></ul> </li><li>微任务 microTask： 
  <ul><li>promise.then</li><li>MutationObserver</li><li>queueMicrotask</li></ul> </li></ul> 
<p><strong>在代码执行的过程中，同步任务会立即执行，异步任务会通过一些手段和过程才会拿到结果。所以在异步任务等待结果的同时，可先执行其后的同步任务。当异步任务有结果的时候，在回过头来执行异步任务</strong></p> 
<p>EvnentLoop执行的机制就是<strong>先执行同步代码，接着是微任务，然后是宏任务</strong>。</p> 
<h2><a id="git_459"></a>三、git面试题</h2> 
<h3><a id="34_Git_461"></a>34. Git和其他代码管理版本控制系统有什么区别？</h3> 
<p>Git 和其他版本代码管理控制系统（ 如 SVN 和 CVS ）之间的主要区别在于它们的架构和工作方式。Git 是一个<strong>分布式</strong>版本控制系统，每个开发人员都可以拥有一个完整的代码库副本，并在需要时进行合并更改。</p> 
<p>而 SVN 和 CVS 等传统的版本控制系统是基于中央服务器的，每个开发人员都从中央服务器检出代码，然后提交更改</p> 
<h3><a id="35_Git_467"></a>35. Git的三个区域是什么？如何将代码从一个区域移动到另一个区域？</h3> 
<p>Git的三个区域是<strong>工作区、暂存区和本地仓库</strong>。可以通过<code>git add</code>将代码从工作区移动到暂存区，通过<code>git commit</code>将代码从暂存区移动到本地仓库</p> 
<h3><a id="36__471"></a>36. 如何将本地的代码推送到远程仓库？</h3> 
<p>可以通过<code>git push</code>将本地的代码推送到远程仓库。例如，可以使用<code>git push origin master</code>将本地的master分支推送到名为origin的远程仓库。</p> 
<h3><a id="37__475"></a>37. 如何从远程仓库拉取代码到本地？</h3> 
<p>可以通过<code>git pull</code>从远程仓库拉取代码到本地。例如，可以使用<code>git pull origin master</code>从名为origin的远程仓库的master分支拉取最新代码。</p> 
<h3><a id="38Git_479"></a>38.如何在Git中合并两个分支？</h3> 
<p>使用“<code>git merge”</code>命令合并两个分支。例如，要将名为<code>“feature-branch”</code>的分支合并到当前分支，请输入<code>“git merge feature-branch”</code>。</p> 
<h3><a id="39Git_483"></a>39.如何在Git中解决冲突？</h3> 
<p>使用<code>“git merge”</code>命令合并分支时可能会发生冲突。要解决冲突，请手动编辑包含冲突的文件，然后使用<code>“git add”</code>和<code>“git commit”</code>命令提交更改。</p> 
<h3><a id="40_git_flow_487"></a>40.什么是 git flow</h3> 
<p>Git flow是一种Git分支模型，它为团队提供了一种规范化的开发流程，使得代码库更容易管理、维护和协作。它的核心思想是在代码库中维护两个主要的分支：</p> 
<p>一个稳定的主分支(master)，用于发布生产版本；另一个是开发分支(develop)，用于开发新功能和修复错误。此外，git flow还定义了一些支持分支，如feature、</p> 
<p>release、hotfix，它们有助于更好地管理和协作团队成员在不同的开发阶段中的工作。总之，Git flow提供了一种标准化的Git分支模型，使团队能够更</p> 
<p>有效地协作和管理Git代码库。</p> 
<h2><a id="CMS_497"></a>四、CMS项目面试题</h2> 
<h3><a id="41_Axios_501"></a>41. 什么是Axios拦截器？</h3> 
<p>Axios拦截器是Axios提供的一种机制，用于在请求和响应发送之前或之后执行某些操作，比如添加请求头、检查请求参数、处理响应数据等。</p> 
<h3><a id="42Axios_505"></a>42.如何使用Axios拦截器？</h3> 
<p>使用Axios拦截器，需要通过Axios提供的<code>interceptors</code>属性来创建请求和响应拦截器</p> 
<pre><code class="prism language-JavaScript">// 添加请求拦截器
axios.interceptors.request.use(function (config) {
  // 在发送请求之前做些什么
  config.headers.Authorization = localStorage.getItem('token')
  return config;
}, function (error) {
  // 对请求错误做些什么
  return Promise.reject(error);
});

// 添加响应拦截器
axios.interceptors.response.use(function (response) {
  // 对响应数据做点什么
  return response;
}, function (error) {
  // 对响应错误做点什么
  return Promise.reject(error);
});

</code></pre> 
<h3><a id="43Axios_531"></a>43.如何在Axios拦截器中处理错误？</h3> 
<p>在Axios拦截器中处理错误，需要在拦截器的两个回调函数中来处理</p> 
<ol><li>第一个回调函数用来处理 业务状态码的错误</li><li>第二个回调函数用来处理 HTTP响应状态码的错误</li></ol> 
<h3><a id="44JWT_538"></a>44.简述前端JWT的作用及原理，并说明其优缺点。</h3> 
<p>JWT（JSON Web Token）是一种用于在网络应用中传递信息的安全方式。JWT实际上是一段加密的JSON数据，由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。</p> 
<h5><a id="_542"></a>作用：</h5> 
<ol><li>身份认证：JWT可以在用户登录后生成一个JWT，用于后续的身份认证，无需在每个请求中都携带身份信息。</li><li>授权：JWT中可以携带用户的授权信息，使得服务器端可以根据授权信息进行相应的操作，从而实现授权。</li><li>信息交换：JWT可以在不同的系统之间传递信息，比如OAuth2中的AccessToken。</li></ol> 
<h5><a id="_548"></a>优点：</h5> 
<ol><li>无状态：JWT是一种无状态的认证方式，即服务器端不需要保存任何用户信息，使得应用可以更容易地扩展。</li><li>安全性高：由于JWT采用了加密算法，能够保证传输过程中的数据不被篡改和窃取。</li><li>跨平台：由于JWT是一种标准化的认证方式，因此可以在不同的平台上使用。</li></ol> 
<h5><a id="_554"></a>缺点：</h5> 
<ol><li>信息冗余：由于JWT中包含了头部、载荷和签名三部分信息，因此可能会导致信息冗余。</li><li>容易被篡改：如果签名算法不够安全，就有可能被恶意攻击者篡改JWT中的信息。</li><li>无法撤销：由于JWT一旦颁发，就无法撤销，因此如果JWT泄露，就可能导致严重的安全问题。</li></ol> 
<h3><a id="45web_560"></a>45.前端web登录流程</h3> 
<p>前端web登录流程通常涉及以下几个步骤：</p> 
<ol><li>用户输入用户名和密码，并点击“登录”按钮。</li><li>前端代码将用户输入的用户名和密码发送到后端服务器。</li><li>后端服务器接收到前端发送的用户名和密码，并进行身份验证。通常，后端服务器会将用户名和密码与存储在数据库中的用户凭据进行比对，以验证用户身份。</li><li>如果后端服务器验证成功，则会向前端发送一个带有用户信息的令牌（通常是 JSON Web Token）。如果验证失败，则会向前端发送一个错误消息。</li><li>前端代码接收到令牌，并将其存储在浏览器的本地存储中（例如，使用localStorage或sessionStorage）。</li><li>以后，当用户进行需要身份验证的操作时，前端代码将令牌发送到后端服务器以验证用户身份。如果令牌有效，则后端服务器允许该操作。否则，后端服务器将返回一个错误消息。</li></ol> 
<p>总之，前端web登录流程可以归纳为：用户输入凭据 -&gt; 前端发送凭据到后端 -&gt; 后端验证凭据并发送令牌 -&gt; 前端存储令牌并发送到后端以进行身份验证。</p> 
<h3><a id="46iframe_573"></a>46.什么是iframe标签？</h3> 
<p>iframe标签是HTML中的一个标签，它允许将一个HTML文档嵌入到另一个HTML文档中。它可以用于在一个HTML页面中嵌入</p> 
<p>其他网站或自己的HTML页面。iframe标签通过src属性指定要嵌入的HTML文档的URL。</p> 
<h3><a id="47iframe_579"></a>47.iframe标签的缺点是什么？</h3> 
<p>iframe标签的主要缺点是它可能导致性能问题。由于iframe标签需要加载另一个HTML文档，因此它可能导致页面加载速度变</p> 
<p>慢。另外，由于iframe标签可以显示其他网站的内容，因此它也可能导致安全问题。</p> 
<h3><a id="48XSS_585"></a>48.XSS</h3> 
<blockquote> 
 <p>XSS (Cross-Site Scripting)，跨站脚本攻击</p> 
</blockquote> 
<p>XSS（Cross-Site Scripting，跨站脚本攻击）是一种常见的网络安全漏洞，攻击者会利用该漏洞将恶意代码注入到一个网站的</p> 
<p>页面中，然后当用户访问该页面时，恶意代码就会执行，攻击者就可以利用这种方式来窃取用户的敏感信息或者劫持用户的会</p> 
<p>话。</p> 
<p>这种攻击方式通常利用网站未过滤或过滤不严格的用户输入数据，比如<strong>输入框、URL参数</strong>等，攻击者会在这些数据中嵌入恶意</p> 
<p>的脚本代码，当用户在网站上执行了这些脚本代码时，就会产生XSS攻击。</p> 
<p>例如，<strong>攻击者可以在一个论坛的回复框中输入一段恶意的脚本代码，然后当其他用户在查看该回复时，就会执行这段脚本代</strong></p> 
<p><strong>码，从而导致攻击者获取用户的Cookie等敏感信息</strong></p> 
<p>具体来说，网站可以采用以下几种方式来防止XSS攻击：</p> 
<ol><li><strong>输入过滤</strong>： 网站可以对用户输入的数据进行过滤，比如只允许特定的字符集、限制输入长度等。</li><li><strong>输出转义</strong>：网站可以对输出到页面上的数据进行转义，将特殊字符（如&lt;, &gt;, ", '等）转换成HTML实体，从而防止恶意代码的注入。</li><li><strong>使用CSP（Content Security Policy）</strong>：CSP是一种安全策略，它允许网站开发者指定哪些内容是可信的，哪些是不可信的，从而防止恶意代码的注入。</li><li><strong>使用HTTP-only Cookie</strong>：HTTP-only Cookie是一种Cookie属性，它可以防止JavaScript脚本读取或修改Cookie内容，从而防止攻击者利用XSS攻击来盗取用户的Cookie。</li></ol> 
<p>总之，要防止XSS攻击，网站开发者需要充分了解XSS攻击的原理，并采取一系列的措施来确保网站的安全性</p> 
<h3><a id="49CSRF_612"></a>49.CSRF</h3> 
<blockquote> 
 <p>CSRF(Cross Site Request Forgery)，跨站请求伪造</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/d2/cb/jTwxmzyz_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BZkWtsbm-1678461708345)(assets/ljaz32j59h.png)]"></p> 
<p>跨站请求伪造（Cross-Site Request Forgery，CSRF）是一种网络攻击方式，它通常会利用用户已经登录过的身份，来执行一</p> 
<p>些恶意操作，比如删除账户、购买商品等。</p> 
<p>攻击者会在一个恶意网站中构造一个请求，然后引诱用户在已登录的另一个网站上点击一个链接，这个链接会让用户在不知情</p> 
<p>的情况下发送请求到目标网站，这时候目标网站会认为这个请求是合法的，因为它携带了用户已经登录的身份信息，从而执行</p> 
<p>攻击者想要的操作。</p> 
<p>例如，一个攻击者可以在一个恶意网站中构造一个请求，这个请求可以让用户在另一个网站上删除自己的账户，然后攻击者就</p> 
<p>会通过这种方式来盗取用户的账户。</p> 
<p>为了防止CSRF攻击，网站通常会采取一些防范措施，比如<strong>添加随机令牌、验证Referer头、验证请求的来源地址</strong>等。</p> 
<h3><a id="50ajaxaxiosfetch_635"></a>50.ajax、axios、fetch的区别</h3> 
<h5><a id="1AJAX_637"></a>（1）AJAX</h5> 
<p>Ajax 即<code>“AsynchronousJavascriptAndXML”</code>（异步 JavaScript 和 XML），是指一种创建交互式网页应用的开发技术。它是</p> 
<p>一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页</p> 
<p>实现异步更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：</p> 
<ul><li>本身是针对MVC编程，不符合前端MVVM的浪潮</li><li>基于原生XHR开发，XHR本身的架构不清晰</li><li>不符合关注分离（Separation of Concerns）的原则</li><li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li></ul> 
<h5><a id="2Fetch_650"></a>（2）Fetch</h5> 
<p>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</p> 
<p><strong>fetch的优点：</strong></p> 
<ul><li>语法简洁，更加语义化</li><li>基于标准 Promise 实现，支持 async/await</li><li>更加底层，提供的API丰富（request, response）</li><li>脱离了XHR，是ES规范里新的实现方式</li></ul> 
<p><strong>fetch的缺点：</strong></p> 
<ul><li>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li><li>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</li><li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li><li>fetch没有办法原生监测请求的进度，而XHR可以</li></ul> 
<h5><a id="3Axios_668"></a>（3）Axios</h5> 
<ul><li>Axios 是一种基于Promise封装的HTTP客户端，其特点如下：</li><li>浏览器端发起XMLHttpRequests请求</li><li>node端发起http请求</li><li>支持Promise API</li><li>监听请求和返回</li><li>对请求和返回进行转化</li><li>取消请求</li><li>自动转换json数据</li><li>客户端支持抵御XSRF攻击</li></ul> 
<h2><a id="nodejs_680"></a>五、nodejs面试题</h2> 
<h3><a id="51Nodejs_684"></a>51.Node.js是什么？它的主要用途是什么？</h3> 
<p>Node.js是一个基于Chrome V8引擎的JavaScript运行时环境，它允许JavaScript在服务器端运行。Node.js的主要用途是编写服</p> 
<p>务器端应用程序，但它也可以用于编写命令行工具、网络工具和桌面应用程序等。</p> 
<h3><a id="52Nodejs_690"></a>52.Node.js中的包管理器是什么？它有什么作用？</h3> 
<p>Node.js中的包管理器是<code>npm</code>（<code>Node Package Manager</code>）。它是一个用于安装、管理和分享Node.js模块的工具。<code>npm</code>允许你</p> 
<p>通过命令行安装、卸载和更新模块，还可以搜索和分享你的模块。<code>npm</code>还可以自动解决依赖关系，并在安装时将所有需要的模</p> 
<p>块下载到本地。它们可以提高数据处理的效率和安全性。</p> 
<h3><a id="53Nodejs_698"></a>53.Node.js中的缓冲区是什么？它们的作用是什么？</h3> 
<p>答：缓冲区是Node.js中用于处理二进制数据的机制。缓冲区是一个固定大小的内存块，它可以存储任意类型的数据，包括</p> 
<p>ASCII、UTF-8和16进制等。缓冲区可以用于处理文件、网络数据和其他I/O操作，它们可以提高数据处理的效率和安全性。</p> 
<h3><a id="54_Nodejs__704"></a>54.如何处理 Node.js 中的异步操作？</h3> 
<p>在 Node.js 中，异步操作通常通过回调函数来处理。当一个异步操作完成后，会调用回调函数，并将操作结果传递给回调函</p> 
<p>数。开发人员可以在回调函数中处理异步操作的结果，例如输出结果、更新数据等。除了回调函数，<code>Node.js</code> 还提供了</p> 
<p><code>Promise</code>、<code>Async/Await</code> 等方式来处理异步操作</p> 
<h3><a id="55_712"></a>55.什么是模块？如何创建和使用模块？</h3> 
<p>我们分为三大模块，分别是核心模块、自定义模块和第三方模块。</p> 
<p>模块是指一个包含代码的文件或者文件夹。每个模块都拥有自己的作用域，可以通过 <code>require</code> 函数来加载模</p> 
<p>块，并使用模块中的代码。可以通过 <code>exports</code> 或 <code>module.exports</code> 对象来向外暴露模块中的内容，其他模块可以通过 <code>require</code> 函</p> 
<p>数来引用模块中的内容。</p> 
<h3><a id="56webpack_722"></a>56.什么是webpack（必会）</h3> 
<p>​ <code>webpack</code>是一个打包模块化 <code>javascript</code> 的工具，在webpack里一切文件皆模块，通过<code>loader</code>转换文件，通过<code>plugin</code>注入钩子，最后输出由多个模块组合成的文件，<code>webpack</code>专注构建模块化项目</p> 
<h3><a id="57Webpack_726"></a>57.Webpack的优点是什么？（必会）</h3> 
<ol><li>专注于处理模块化的项目，能做到开箱即用，一步到位</li><li>通过plugin扩展，完整好用又不失灵活</li><li>通过loaders扩展, 可以让webpack把所有类型的文件都解析打包</li><li>社区区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展</li></ol> 
<h3><a id="58webpack_733"></a>58.webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全（必会）</h3> 
<p>​ Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p> 
<p>​ 1. 初始化参数：从配置文件读取与合并参数，得出最终的参数</p> 
<pre><code>2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，开始执行编译
3. 确定入口：根据配置中的 entry 找出所有的入口文件
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
5. 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。
</code></pre> 
<p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果</p> 
<h3><a id="59_Webpack__748"></a>59.说一下 Webpack 的热更新原理(必会)</h3> 
<p>​ webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p> 
<p>​ HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该chunk的增量更新。</p> 
<p>​ 后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。</p> 
<h3><a id="60webpackgruntgulp_756"></a>60.webpack与grunt、gulp的不同？（必会）</h3> 
<p>​ <strong>1)</strong> <strong>三者之间的区别</strong></p> 
<p>​ 三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。</p> 
<p>​ grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。</p> 
<p>​ webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。</p> 
<p>​ <strong>2)</strong> <strong>从构建思路来说</strong></p> 
<p>​ gulp和grunt需要开发者将整个前端构建过程拆分成多个<code>Task</code>，并合理控制所有<code>Task</code>的调用关系 webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工</p> 
<p>​ <strong>3)</strong> <strong>对于知识背景来说</strong></p> 
<p>​ gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路</p> 
<h3><a id="61Loader_774"></a>61.有哪些常见的Loader？他们是解决什么问题的？（必会）</h3> 
<p>1、 file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</p> 
<p>2、 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</p> 
<p>3、 source-map-loader：加载额外的 Source Map 文件，以方便断点调试</p> 
<p>4、 image-loader：加载并且压缩图片文件</p> 
<p>5、 babel-loader：把 ES6 转换成 ES5</p> 
<p>6、 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</p> 
<p>7、 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</p> 
<p>8、 eslint-loader：通过 ESLint 检查 JavaScript 代码</p> 
<h3><a id="62LoaderPlugin_792"></a>62.Loader和Plugin的不同？（必会）</h3> 
<p>​ <strong>1)</strong> <strong>不同的作用</strong></p> 
<p>​ Loader直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</p> 
<p>​ Plugin直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p> 
<p><strong>2)</strong> <strong>不同的用法</strong></p> 
<p>​ Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</p> 
<p>​ Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</p> 
<h3><a id="63_805"></a>63.重绘和回流(重排)</h3> 
<h4><a id="1__807"></a>1. 回流（重排）</h4> 
<p>当 <code>Render Tree</code> （<strong>渲染树</strong>）中部分或者全部元素的<strong>布局，尺寸大小，结构</strong>等发生改变时，浏览器就会重新渲染部分或全部文档的过程称为 <strong>回流</strong>。</p> 
<h4><a id="2__811"></a>2. 重绘</h4> 
<p>页面中<strong>元素的颜色，字体，或其他外观属性</strong>改变时，浏览器需要重绘来更新外观(比如：<code>color、background-color、outline</code>等), 称为重绘。</p> 
<blockquote> 
 <p><strong>重绘不一定引起回流（重排），而回流（重排）一定会引起重绘。</strong></p> 
</blockquote> 
<h4><a id="3__817"></a>3. 会导致回流（重排）的操作：</h4> 
<p>1.1 页面的首次刷新<br> 1.2 浏览器的窗口大小发生改变<br> 1.3 元素的大小或位置发生改变<br> 1.4 改变字体的大小<br> 1.5 内容的变化（如：<code>input</code>框的输入，图片的大小）<br> 1.6激活<code>css</code>伪类 （如：<code>:hover</code>）<br> 1.7 脚本操作<code>DOM</code>（添加或者删除可见的<code>DOM</code>元素）<br> 1.8 简单理解影响到布局了，就会有回流</p> 
<p><img src="https://images2.imgbox.com/2d/a8/pQS9110C_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="64_831"></a>64.什么是跨域？</h3> 
<p><strong>跨域</strong>：指的是浏览器不能执行其他网站的脚本。它是由浏览器的<strong>同源策略</strong>造成的，是浏览器对 <a href="https://so.csdn.net/so/search?q=javascript&amp;spm=1001.2101.3001.7020">javascript</a> 施加的<strong>安全限制</strong>。</p> 
<p>通俗的说就是<strong>协议 端口 主机</strong> 三者 <strong>不一致</strong>就会造成<strong>跨域</strong></p> 
<p><strong>解决方案：</strong></p> 
<ol><li>使用代理服务器：可以在本地搭建一个代理服务器，通过代理服务器转发请求，从而解决跨域问题。</li><li>使用 JSONP：JSONP 是一种跨域数据传输方式，可以通过动态插入 script 标签的方式实现跨域访问，JSONP是比较老的一种方案，只支持get请求，不支持post请求</li><li>使用 CORS：CORS 是一种跨域资源共享的方式，可以通过在服务器端配置 HTTP 头信息，让浏览器允许跨域访问。 它通过服务器增加一个特殊的<code>Header[Access-Control-Allow-Origin]</code>来告诉客户端跨域的限制</li><li>使用 WebSocket：WebSocket 是一种基于 TCP 的协议，可以实现双向通信，不存在跨域的限制。</li></ol> 
<h2><a id="vue_845"></a>六、vue面试题</h2> 
<h3><a id="65MVVM_848"></a>65.什么是MVVM</h3> 
<p><strong><code>MVVM</code>，是<code>Model-View-ViewModel</code>的简写，是<code>M</code>-<code>V</code>-<code>VM</code>三部分组成。它本质上就是<code>MVC</code> 的改进版</strong>。</p> 
<p><code>Model</code>（模型） : 表示应用程序中的数据模型，它代表着应用程序中的业务逻辑和状态。</p> 
<p><code>View</code>（视图）: 表示应用程序中的用户界面。</p> 
<p><code>ViewModel</code>（视图模型） : 是一个桥梁，将模型和视图连接在一起，它提供了视图所需的数据和命令，并将用户的输入转换为模型的操作。</p> 
<p>**<code>MVVM</code>采用双向数据绑定，<code>view</code>中数据变化将自动反映到<code>viewmodel</code>上，反之，<code>model</code>中数据变化也将会自动展示在页面上。**把<code>Model</code>和<code>View</code>关联起来的就是<code>ViewModel</code>。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。</p> 
<p><strong><code>MVVM</code>核心思想，是关注<code>model</code>的变化，让<code>MVVM</code>框架利用自己的机制自动更新<code>DOM</code></strong>，也就是所谓的<strong>数据-视图分离，数据不会影响视图</strong>。</p> 
<p><code>MVVM</code> 就是将其中的<code>View</code> 的状态和行为抽象化，其中<code>ViewModel</code>将视图 UI 和业务逻辑分开，它可以取出 <code>Model</code> 的数据同时帮忙处理 <code>View</code> 中由于需要展示内容而涉及的业务逻辑。</p> 
<h3><a id="66vue_864"></a>66.vue的理解？</h3> 
<p><code>Vue.js</code> 是一个<strong>渐进式</strong>的 <code>JavaScript</code> 框架，旨在通过尽可能<code>简单的 API</code> 实现<strong>响应式数据绑定</strong>和<strong>组合的视图组件</strong>。</p> 
<p><code>Vue.js</code> 的核心是<strong>数据驱动视图</strong>，<strong>通过组件内特定的方法实现视图和模型的交互 。</strong></p> 
<p><code>Vue.js</code> 的<strong>响应式系统</strong>可以在<strong>模型数据变化</strong>时，视图会<strong>自动更新</strong>。这意味着，我们可以在不手动操作 <code>DOM</code> 的情况下<strong>改变视图</strong>。</p> 
<p><code>Vue.js</code> 还提供了许多其他功能，如组件系统、路由、状态管理等，可以帮助你构建复杂的单页应用。</p> 
<p>总的来说，<code>Vue.js</code> 是一个轻量级的、易于使用的前端框架，可以帮助你快速构建响应式的 <code>Web</code> 应用。</p> 
<h3><a id="675vue_876"></a>67.说5个vue的指令</h3> 
<ol><li><code>v-bind：</code>绑定属性</li><li><code>v-if</code> 、<code>v-show：</code>条件渲染</li><li><code>v-for：</code> 列表渲染</li><li><code>v-model：</code>双向绑定</li><li><code>v-html：</code>解析html字符串</li><li><code>v-on：</code>绑定事件</li></ol> 
<h3><a id="68vue__885"></a>68.vue 单页面应用</h3> 
<blockquote> 
 <p>vue 是一个单页面应用 ，这个vue项目其实只会有一个 index.html 页面，它内容的<strong>切换本质都是通过切换div来实现模拟多页面的</strong></p> 
</blockquote> 
<p><strong>SPA</strong>单页面应用（<code>SinglePage Web Application</code>，简称 <code>SPA</code>），指的是只有一个<strong>主页面的应用</strong>，一开始只需要加载一次<code>js</code>、<code>css</code>等相关资源，所有内容都包含在主页面上，对每一个功能模块组件化，单页面应用跳转，就是<strong>切换相关组件</strong>，仅仅刷新<strong>局部资源</strong>。（单页面应用指一个系统只加载一次资源，然后下面的操作交互、数据交互是通过router、ajax来进行，页面并没有刷新）</p> 
<p>与传统的多页面应用相比，单页面应用具有许多优势，包括：</p> 
<ul><li><strong>快速响应</strong>：由于不需要重新加载页面，因此 SPA 应用可以快速响应用户的操作。</li><li><strong>减少服务器负载</strong>：由于大部分的处理都是在客户端进行的，因此 SPA 应用可以减少服务器的负载。</li><li><strong>更好的用户体验</strong>：由于 SPA 应用的页面切换非常流畅，因此它可以提供更好的用户体验。</li></ul> 
<p>然而，单页面应用也有一些缺点，包括：</p> 
<ul><li><strong>较难调试</strong>：由于 <code>SPA</code> 应用的代码都在客户端运行，因此调试可能会更加困难。</li><li><strong>首次加载耗时多</strong>：解决方法通过路由懒加载： <strong>可以有效的分担首页所承担的加载压力，减少首页加载用时</strong>。</li><li><strong><code>SEO</code> 难度较大</strong>： 由于所有的内容都在一个页面上<strong>动态替换显示</strong>，所以在 <code>SEO</code> 上其有着天然的弱势。 为了解决这个问题，可以使用服务端渲染（<code>Server-Side Rendering，简称 SSR</code>）技术，在<strong>服务器端渲染 <code>SPA</code> 应用的内容</strong>，使得爬虫可以正常抓取页面内容。</li></ul> 
<h3><a id="69vforvif_903"></a>69.v-for和v-if为什么不能一起使用</h3> 
<p>在<code>vue2</code>中<code>v-for</code>优先级高于<code>v-if</code>，如果二者在同一级标签里面使用，每次都要先<strong>循环</strong>，再<strong>判断</strong>，消耗很多性能。</p> 
<p>解决办法的话，可以在外层包装一个<code>div</code>，使用<code>v-if</code>做一次判断即可。<code>Vue3</code>解决了这个问题，将<code>v-if</code>的优先级调整为高于<code>v-for</code>了。</p> 
<h3><a id="70watch_909"></a>70.计算属性与watch的区别</h3> 
<p><code>computed</code>是用来计算出来一个值的，这个值调用的时候不需要加括号，会根据依赖进行缓存，依赖不变，<code>computed</code>的值不会重新计算。</p> 
<p><code>watch</code>是来监听的，有2个选项</p> 
<ol><li><code>immediate</code>：表示是否要在第一次渲染的时候执行这个函数</li><li><code>deep</code>：如果我们监听一个对象，那么我们要看这个对象里面的属性是否变化，如果某个属性变化了，就去执行一个函数</li></ol> 
<h3><a id="71vuedata_918"></a>71.vue组件中data为什么必须是一个函数</h3> 
<p>在 Vue.js 中，组件的 data 选项必须是<code>一个函数</code>，这是因为每个组件实例都应该有自己的状态，如果 data 不是一个函数，那么所有实例将共享同一个数据对象，这会<strong>导致组件之间的状态混乱</strong>。</p> 
<p>举个例子，假设你有一个组件 A 和组件 B，如果你把 data 写成这样：</p> 
<pre><code class="prism language-javascript">data<span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
  message<span class="token operator">:</span> <span class="token string">'Hello'</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那么组件 A 和组件 B 中的 message 都是同一个值，如果在组件 A 中修改了 message，那么组件 B 中的 message 也会改变。这显然不是你想要的结果。</p> 
<p>因此，Vue.js 要求 data 选项必须是一个函数，这样每个组件实例都可以有自己的 data 对象。你可以这样写：</p> 
<pre><code class="prism language-javascript"><span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>
    message<span class="token operator">:</span> <span class="token string">'Hello'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样就能保证每个组件实例都有自己的 data 对象，组件之间的状态就不会混乱了。</p> 
<h3><a id="72nextTick_944"></a>72.nextTick的理解</h3> 
<p>nextTick 是 Vue.js 中一个用来在<strong>下一个事件循环</strong>中调用回调函数的<strong>方法</strong>。（ 就是你放在 $ nextTick 当中的操作不会立即执行，而是等数据更新、DOM更新完成之后再执行，这样我们拿到的肯定就是最新的了 ）这个方法通常用在<strong>等待数据</strong>或 <strong>DOM 元素更新之后</strong>执行一些代码。也可以说在下一次DOM更新结束后执行其指定的回调</p> 
<p>这句话扩展开来说，就是由于Vue中DOM更新是「异步执行」的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。经常我们会在还未更新的时候就使用了某个元素，这样是拿不到变更后的dom的,所以为了确保能够得到更新后的DOM,所以设置了nextTick()方法。在修改数据之后立即使用这个方法，获取更新后的DOM。简单概括，vue中的nextTick主要用于处理数据动态变化后，DOM还未及时更新的问题，用nextTick可以获取数据更新后最新dom的变化。</p> 
<h3><a id="73_950"></a>73.插槽</h3> 
<p>在 Vue.js 中，插槽（<code>slot</code>）是一种机制，可以在父组件的模板中定义一个占位符，然后在子组件中插入内容。这样，子组件就</p> 
<p>可以在父组件的模板中渲染内容，使得子组件可以更灵活地与父组件进行交互。</p> 
<ul><li>插槽的使用过程其实是<strong>抽取共性、预留不同</strong>；</li><li>我们会将<strong>共同的元素、内容依然在组件内进行封装</strong>；</li><li>同时会将<strong>不同的元素使用slot</strong>作为占位，让外部决定到底显示什么样的元素；</li></ul> 
<p>插槽有两种类型：</p> 
<ul><li>具名插槽：具名插槽使用特定的名称来标识，子组件可以插入到特定的插槽中。</li><li>不具名插槽：不具名插槽没有名称，子组件中的内容会插入到不具名插槽中。</li></ul> 
<h3><a id="74_965"></a>74.路由模式</h3> 
<ul><li>hash模式： 
  <ul><li>浏览器中符号是“<code>#</code>”，#以及#后面的字符称之为 <code>hash</code>，又叫<strong>前端路由</strong></li><li>用 <code>window.location.hash</code> 读取</li><li>hash 虽然在 <code>URL</code> 中，但不会向服务器发送请求</li><li>hash 改变会触发 <code>hashchange</code> 事件， 并根据hash值来修改页面内容</li><li>hash发生变化的<code>url</code>都会被浏览器记录下来，从而实现浏览器的前进后退。</li></ul> </li><li>history模式： 
  <ul><li>history 采用 了<code>HTML5</code> <code>History</code> <code>API</code></li><li>history 模式不仅可以在<code>url</code>里放参数，还可以将数据存放在一个特定的对象中</li><li>它也有个问题：不怕前进，不怕后退，就怕刷新（如果服务器中没有相应的响应或资源，会分分钟刷出一个404来），因为刷新是实实在在地去请求服务器的。</li></ul> </li></ul> 
<h3><a id="75vue_978"></a>75.说说vue的生命周期</h3> 
<p><code>vue</code>组件生命周期：从<strong>创建</strong> 到 <strong>销毁</strong> 的整个过程就是 – <code>Vue</code>实例的 生命周期</p> 
<p>Vue中的生命周期本质上就是<strong>按顺序固定执行一个个的钩子函数</strong>，我们开发者可以在每个函数中写入特定代码来实现我们需要的功能<strong>例如我们常用的ajax请求通常就放在created或者mounted中</strong>。</p> 
<p>vue2的生命周期从分类上来看有如下几种情况：</p> 
<ol><li><strong>组件创建</strong>和<strong>挂载</strong>相关的钩子函数有 
  <ol><li><code>beforeCreate</code></li><li><code>created</code></li><li><code>beforeMount</code></li><li><code>mounted</code></li></ol> </li><li>组件更新相关的钩子函数有 
  <ol><li><code>beforeUpdate</code></li><li><code>updated</code></li></ol> </li><li>组件销毁相关的钩子函数有 
  <ol><li><code>beforeDestroy</code></li><li><code>destroyed</code></li></ol> </li></ol> 
<p>还有一个组件缓存激活相关的钩子函数是：<strong>activated和deactivated</strong>，这两个要<strong>配合keep-alive 缓存</strong>的组件一起使用</p> 
<p><code>kee-alive</code> 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染 。也就是所谓的组件缓存 <a href="https://so.csdn.net/so/search?q=keep-alive&amp;spm=1001.2101.3001.7020">keep-alive</a> ，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们</p> 
<p>vue3总体来说什么周期执行顺序是一样的，<strong>不同点在于beforeCreate和created都被setup函数替代了</strong></p> 
<h3><a id="76vue_1004"></a>76.vue旧地复用策略</h3> 
<p><code>Vue</code>会尽可能的就地（同层级，同位置），对比虚拟<code>dom</code>，复用旧<code>dom</code>结构，进行差异化更新，<code>vue</code>采用的是<strong>diff算法</strong>进行对比。它会先同层级根元素进行比较，如果根元素变化的话，就不考虑复用了，如果根元素没有变化，就会对比同级兄弟元素，默认<strong>按照下标</strong>进行对比复用，如果设置了<code>key</code>就会按照相同<code>key</code>的新旧元素进行对比复用，<code>key</code>必须是一个唯一不重复的<strong>字符串</strong>或者<strong>数值</strong>，<code>key</code>的好处就是可以提高虚拟<code>DOM</code>对比的复用性能。</p> 
<h3><a id="77_1008"></a>77.深度侦听在什么情况下使用？立即侦听什么情况下使用？</h3> 
<p><code>deep</code>（深度侦听）：默认情况下，侦听器无法侦听对象的属性值的变化，如果想实现这个效果，则需要添加<code>deep</code>配置为<code>true</code></p> 
<p><code>handler</code>（固定方法触发）：因为你要添加<code>deep</code>的配置，所以，侦听器的形式要变更为对象形式，只有对象才能添加其它的配置, 同时侦听函数必须为<code>handler</code></p> 
<p><code>immediate</code>（立即侦听）：如果需要默认一进页面就触发一次，添加<code>immediate</code>配置选项为<code>true</code></p> 
<h3><a id="78_1016"></a>78.前置路由守卫</h3> 
<p>全局前置路由守卫: <strong>初始化的时候被调用</strong>，<strong>每次 路由切换之前 被调用</strong>。</p> 
<p><strong>路由跳转之前,</strong> 会触发的一个函数 叫<strong>前置路由守卫</strong></p> 
<p>语法：router.beforeEach((to, from, next) =&gt; {这里可以写路径的跳转判断/有无token值的情况分析})</p> 
<p>作用 : 防止别人猜到网址的hash值后直接跳过登录就可以查看数据</p> 
<p>里面的3个参数：</p> 
<p><code>to</code> : 到哪里去</p> 
<p><code>from</code> : 从哪里来</p> 
<p><code>next</code> : 放行函数 <code>next()</code>:放行 , <code>next(false)</code>:不放行</p> 
<h3><a id="79Vuex_1034"></a>79.Vuex核心属性：</h3> 
<ul><li><strong>state</strong>：定义需要管理的数据</li><li><strong>getters</strong>：state派生出来的数据，相当于state的<strong>计算属性</strong></li><li><strong>mutation</strong>：里面定义的是<strong>同步</strong>的更新数据方法，每个方法里都有两个参数，一个是<code>state</code>，一个是<code>payload</code>，通过<code>store.commit</code>调用</li><li><strong>action</strong>：里面定义的是<strong>异步</strong>的方法，每个方法里面有两个参数，一个是<code>store</code>，一个是<code>payload</code>，通过<code>store.dispatch</code>调用，在<code>actions</code>里也可以提交<code>mutation</code>，通过<code>store.commit</code></li><li><strong>module</strong>：将<code>vuex</code>模块化，可以让每一个模块拥有自己的<code>state</code>、<code>mutation</code>、<code>action</code>、<code>getters</code>，结构清晰，方便管理</li></ul> 
<h3><a id="80Vue2_1042"></a><strong>80.Vue2优点和缺点讲解</strong></h3> 
<p>优点</p> 
<ul><li>轻量级的框架</li><li>双向数据绑定</li><li>组件化开发</li><li>单页面路由</li><li>学习成本低</li><li>虚拟dom</li><li>渐进式框架</li><li>数据和结构的分离</li><li>运行速度快</li><li>插件化</li></ul> 
<p>缺点</p> 
<ul><li>不支持IE8以下</li><li>社区可能没有Angular和React那么丰富</li><li>Vue 不缺入门教程，可是很缺乏高阶教程与文档。同样的还有书籍</li><li>因为是单页面应用，不利于seo优化</li><li>初次加载时耗时多</li></ul> 
<h3><a id="81vuex_1065"></a>81.在使用vuex时怎么实现数据的持久化</h3> 
<p>我们通常是将<strong>数据保存到本地存储中</strong>，当重新<strong>刷新页面后</strong>再<strong>从本地存储中将之前的数据加载回来</strong></p> 
<p><strong>保存到<code>vuex</code>中的<code>state</code>中</strong>。这样就能实现<code>vuex</code>的数据持久化了</p> 
<h3><a id="82_1073"></a>82.三次握手和四次挥手</h3> 
<p>三次握手是用于在俩台计算机之间<code>建立网络连接</code>， 确认双方的接收与发送能力是否正常 ，它包括三个步骤：</p> 
<p>1.客户端向服务端发送连接请求</p> 
<p>2.服务端向客户端发送确认消息，表明服务器<strong>已准备好接受连接</strong></p> 
<p>3.客户端向服务器发送确认消息，表明客户端已收到服务端的确认消息，并准备好开始数据传输</p> 
<p>四次挥手是用于在俩台计算机之间<code>终止网络连接</code>,它包括以下四个步骤：</p> 
<p>1.客户端向服务器发送断开连接请求</p> 
<p>2.服务器向客户端发送确认消息，表明服务器<strong>已收到断开连接的请求</strong>。（服务端收到关闭请求的时候可能这个时候数据还没发送完，所以服务端会先回复一个确认报文，表示自己知道客户端想要关闭连接了，但需要等待数据传输完）</p> 
<p>3.服务器向客户端发送断开连接的请求。（会主动发送FIN报文，告知客户端，服务端准备关闭连接了）</p> 
<p>4.客户端向服务器发送确认消息，表明客户端已收到服务器的断开连接请求，稍后进行断开</p> 
<h4><a id="__1093"></a>扩展、 挥手为什么需要四次？</h4> 
<p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中<strong>ACK报文是用来应答的，SYN报文是用来同步的</strong>。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p> 
<h3><a id="TCPUDP_1097"></a>补充、TCP和UDP的区别</h3> 
<p><code>TCP</code>和<code>UDP</code>都是传输层协议</p> 
<p><code>TCP</code> 是一种面向<strong>有连接的传输层协议</strong>，能够对自己提供的连接实施控制。适用于要求<strong>可靠传输</strong>的应用，例如文件传输。<strong>面向字节流，传输慢</strong> 。</p> 
<p><code>UDP</code> 是一种面向<strong>无连接的传输层协议</strong>，不会对自己提供的连接实施控制。适用于<strong>实时应用</strong>，例如：IP电话、视频会议、直播等。，以<strong>报文的方式传输，效率高</strong> 。</p> 
<table><thead><tr><th align="center"></th><th align="center">UDP</th><th align="center">TCP</th></tr></thead><tbody><tr><td align="center">是否连接</td><td align="center">无连接</td><td align="center">面向连接</td></tr><tr><td align="center">是否可靠</td><td align="center">不可靠传输，不使用流量控制和拥塞控制</td><td align="center">可靠传输，使用流量控制和拥塞控制</td></tr><tr><td align="center">连接对象个数</td><td align="center">一对一，一对多，多对一，多对多</td><td align="center">只能有俩个端点，一对一通信</td></tr><tr><td align="center">传输方式</td><td align="center">面向报文</td><td align="center">面向字节流</td></tr><tr><td align="center">首部开销</td><td align="center">开销小，仅8字节</td><td align="center">最小20字节，最大60字节</td></tr></tbody></table> 
<h3><a id="83_URL__1115"></a>83.一个页面从输入 URL 到页面加载显示完成的过程</h3> 
<p>1、<strong>URL解析</strong>：地址栏输入地址，浏览器对输入内容进行解析，判断URL的合法性，和是否有可用缓存<br> 2、<strong>DNS解析</strong>：域名解析系统（DNS）查找对应的IP地址<br> 3、<strong>建立TCP连接</strong>（三次握手）：浏览器向服务器发起TCP连接，与浏览器建立TCP三次握手<br> 4、<strong>HTTP请求</strong>：浏览器将http请求数据发给服务器（客户端–&gt;服务器）<br> 5、<strong>HTTP响应</strong>：服务器处理收到的请求，返回响应结果至浏览器（服务器–&gt;客户端）<br> 6、<strong>关闭TCP连接</strong>（四次挥手）：数据传输完成后，还要经过四次握手以终止连接<br> 7、<strong>页面渲染</strong>：浏览器解析响应结果，进行页面渲染</p> 
<h3><a id="84vue_1125"></a>84.vue双向数据绑定原理</h3> 
<p>比如说，当在输入框输入文字时，vue会检测到数据的变化，然后<strong>更新对应的视图</strong>。同样，如果你通过代码修改了数据，那么<code>vue</code>也会<strong>自动更新视图</strong>，其原理是通过<strong>数据劫持</strong>和<strong>发布订阅模式</strong>实现的。</p> 
<p>首先，<code>Vue</code>通过<code>Object.defineProperty( )</code>方法对数据进行劫持，监听数据的变化，并通过<code>getter</code>和<code>setter</code>方法对数据进行读写。<br> 其次，Vue通过发布订阅模式，维护了一个订阅者数组，当数据发生变化时，<code>Vue</code>会通知所有订阅者进行更新。因此，当用户在页面上进行修改时，<code>Vue</code>也会自动更新对应的数据，并通知所有订阅者更新视图，同时当数据发生变化时，Vue也会更新对应的视图，通过这样的机制，Vue实现了双向数据绑定，使得数据和视图的变化可以互相影响</p> 
<p>补充：订阅者是Vue中的一个概念，它是一个用于管理更新视图的对象，当数据发生变化时，Vue会通知所有的订阅者进行更新，在Vue中，每一个挂载到视图上的组件，或者每一个watcher，都可以被看成一个订阅者，他们订阅了某一个数据的变化，并等待数据发生变化时进行更新，订阅者是Vue实现双向数据绑定的关键组成部分，管理着数据和视图之间的关系，保证了数据的变化能够及时反应到视图上</p> 
<h3><a id="vue_1136"></a>vue双向数据绑定原理</h3> 
<p>是数据劫持加观察者模式实现的。 大致分成了以下两步：</p> 
<ol><li>通过 Object.defineProperty 劫持数据，收集依赖</li><li>当数据被访问或更新时，通知对应依赖去响应视图的变化 当 Vue 实例被创建时，它会在内部遍历所有数据并使用 Object.defineProperty() 函数为每个属性添加 getter 和 setter。这样，当数据被访问(get)或修改(set)时，Vue 就可以捕获数据并通知观察者(渲染页面)。</li></ol> 
<h3><a id="_Vue30vue20_1143"></a>补充. 双向数据绑定原理之Vue3.0比vue2.0的优势有哪些？</h3> 
<p>vue2.0使用了 <code>Object.defineProperty</code> 的方法，首先它是无法检测到对象属性的新增或者删除，其次无法监听数组的变化，vue在实现数组的响应式时，它使用了一些<code>hack</code>， 把无法监听数组的情况通过<strong>重写数组</strong>的部分方法来实现响应式，这也只限制在数组的<code>push/pop/shift/unshift/splice/sort/reverse</code>七个方法， 其他数组方法及数组的使用则无法检测到 。</p> 
<p>vue3.0 使用了<code>proxy</code>来代替<code>Object.defineProperty</code> ， <code>proxy</code>属性是ES6中新增的一个属性, <code>proxy</code>属性也是一个构造函数,他也可以通过new的方式创建这个函数, proxy直接代理的是<strong>整个对象</strong>而非对象属性,proxy的代理针对的是<strong>整个对象</strong>而不是像<code>object.defineProperty</code>针对<strong>某个属性</strong>, 只需要做一层代理就可以监听同级结构下的所有属性变化,。</p> 
<p><img src="https://images2.imgbox.com/f6/73/HnxslNzG_o.png" alt=""></p> 
<h3><a id="85_1152"></a>85.页面优化：</h3> 
<ul><li>v-if和v-for不能连用</li><li>更多的情况下，使用v-if代替v-show</li><li>要保证key值的唯一</li><li>使用组件懒加载或者图片懒加载</li><li>防抖和节流的使用</li><li>模块按需导入</li><li>打包优化</li><li>使用cdn加载第三方模块</li><li>缓存常用信息</li><li>精灵图，base64</li></ul> 
<h3><a id="_vif___v_show_1167"></a>补充. v-if 和 v- show的区别</h3> 
<p>作用：都是可以实现元素的显示与隐藏</p> 
<ol><li><code>v-show</code> 频繁切换标签，用<code>v-show</code> css手段控制标签显示隐藏</li><li><code>v-if</code> 不频繁切换标签，用<strong>v-if</strong>，创建删除标签显示隐藏，<strong>惰性的</strong>，一开始为<strong>false</strong>的，不会创建标签，性能更好</li></ol> 
<h3><a id="vmodel_1176"></a>补充、v-model的实现原理</h3> 
<p>在 <code>Vue.js</code> 中，<code>v-model</code> 指令是一种语法糖，它的作用是为<strong>表单元素绑定双向数据绑定</strong>。<code>v-model</code> 指令的实现原理是基于<strong>计算属性和事件绑定</strong>。它会将表单元素的 <code>value</code> 属性绑定到<strong>一个计算属性上</strong>，并且在计算属性的 <code>setter</code> 中触发 <code>input</code> 事件来更新 Vue 实例中的数据。</p> 
<h3><a id="vue2filter_1180"></a>补充、vue2中的filter过滤器</h3> 
<p><code>vue2</code>有使用过滤器 <code>vue3</code>已舍弃使用</p> 
<p><code>vue2</code>过滤器的使用：用于一些常见的文本格式化 例如：日期格式化、数字大小写、单位转换、文本格式化等</p> 
<p>过滤器的作用：可以在不改变原数据 只是对数据进行加工处理并返回过滤后的数据，再进行调用处理</p> 
<p>过滤器分为全局过滤器和局部过滤器</p> 
<p>过滤器只能应用在两个地方：<strong><code>双花括号插值</code><strong>和</strong><code>v-bind</code>表达式</strong>(后者从 2.1.0+ 开始支持)。例如</p> 
<pre><code class="prism language-html"><span class="token comment">&lt;!--在双花括号中使用 格式：{<!-- -->{值 | 过滤器的名称}}--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{<!-- -->{3 | addZero}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!--在v-bind中使用 格式：v-bind:id="值 | 过滤器的名称"--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1 | addZero<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>​</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9400a40270a4b24e96880c8d1a4c4a8b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">永久修改pip国内镜像源</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0da80d4f35b10deb14949e854ebb5027/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">通过哪些平台可以了解网络安全技术</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>