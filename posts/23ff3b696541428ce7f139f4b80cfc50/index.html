<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【论文阅读】3D点云 -- PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【论文阅读】3D点云 -- PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation" />
<meta property="og:description" content="前言 本博客详解遵从论文讲述的顺序。但我们要明确该论文的要点，以更好的阅读论文：针对点云的3个特性，pointnet设计的应对方法，以及设计理念。
点云的无序性：网络使用了对称函数 (maxpooling) 来降采样点云的特征点云的各点之间影响：网络将局部点的特征与 全局特征 进行concat，综合信息预测结果点云的几何变化不变性（刚性变换）：网络添加了 T-net，学习一个仿射变换矩阵，来适应点云的旋转平移。
pointnet实现了多种任务：分类、零件分割、语义分割、3D目标检测。但对于本文，更重要的是抓住上面提到的核心点的设计。
虽然在现在来看，在相关研究中pointnet效果不理想，但在当时 pointnet 的提出是开创性的，pointnet&#43;&#43;是在此基础上完成。而后的一系列论文，大多借鉴了pointnet&#43;&#43;的对点云学习方式。
Abstract 【使用点云】点云是一种重要的几何数据结构。由于其不规则的格式，大多数研究人员将这些数据转换为规则的三维体素网格或图像集合。但是，这会使数据变得不必要的庞大，并导致问题。【本文设计】在本文中，我们设计了一种新型的直接使用点云的神经网络，它很好地考虑了输入点的 置换不变性（旋转不变形）。我们的网络名为PointNet，它为从对象分类、零件分割到场景语义解析的应用程序提供了统一的体系结构。
虽然简单，但PointNet是高效的。从经验上看，它表现出强劲的表现，甚至比现有技术更好。理论上，我们提供分析，以了解网络学到了什么，以及为什么网络在输入扰动和损坏方面是健壮的。 1. Introduction 在本文中，我们探讨了能够推理三维几何数据（如点云或网格）的深度学习体系结构。
【点云已有操作】由于点云或网格不是常规格式，大多数研究人员通常会将这些数据转换为常规的三维体素网格或图像集合（例如，视图），然后再将其输入深网体系结构。
【原因】典型的卷积结构需要高度规则的输入数据格式，如图像网格或三维体素，以便执行权重共享和其他内核优化。
【问题】然而，这种数据表示转换会使生成的数据变得不必要的庞大，同时还会引入数据量化，从而模糊数据的自然不变性。
【本论文解决方法】出于这个原因，我们将重点放在使用简单点云的3D几何体的不同输入表示上，并将结果命名为PointNets。点云是简单而统一的结构，避免了网格的组合不规则性和复杂性，因此更易于学习。然而，PointNets仍然必须尊重这样一个事实，即点云只是一组点，因此对其成员的排列是不变的，因此需要在网络计算中进行某些对称化。还需要考虑刚性运动的进一步不变性。
【PointNet是一个统一的体系结构】
它直接将点云作为输入，并为整个输入 输出类别标签，或为输入的每个点输出每个点 分割/部分标签。
我们网络的基本架构出人意料地简单，因为在初始阶段，每个点都被完全独立地处理。
在基本设置中，每个点仅由其三个坐标 (x,y,z)表示。可以通过计算法线和其他局部或全局特征来添加其他维度。【方法的关键是使用单个对称函数max pooling】
网络有效地学习一组优化函数/标准，这些函数/标准 选择点云中感兴趣或信息丰富的点，并对其选择的原因进行编码。网络的最终完全连接层将这些学习到的最佳值聚合到上述整个形状的全局描述符中（形状分类），或用于预测每点标签（形状分段）。【输入格式很容易应用刚性或仿射变换，因为每个点都独立变换】
因此，我们可以添加一个依赖于数据的空间变换网络，该网络尝试在点网处理数据之前对数据进行规范化，以便进一步改进结果。【对方法进行了理论分析和实验评估】
我们证明了我们的网络可以逼近任何连续的集合函数。
更有趣的是，我们的网络通过一组稀疏的关键点学习总结输入点云，这些关键点大致对应于根据可视化显示的对象骨架。理论分析提供了一种理解，为什么我们的点网对输入点的小扰动以及通过点插入（异常值）或删除（缺失数据）而导致的损坏，具有高度鲁棒性。
我们工作的主要贡献如下：
我们设计了一种新颖的深网体系结构，适用于使用三维无序点集；我们展示了如何训练这样一个网络来执行3D形状分类、形状部分分割和场景语义解析任务；我们对我们的方法的稳定性和效率进行了全面的实证和理论分析；我们展示了网络中选定神经元计算的3D特征，并对其性能进行了直观解释。
用神经网络处理无序集的问题是一个非常普遍和基本的问题——我们希望我们的想法也能转移到其他领域。
2. Related Work 【点云特征当前获取方式：针对不同任务手工制作】
点云的大多数现有特征都是针对特定任务手工制作的。点特征通常对点的某些统计特性进行编码，并设计为对某些变换保持不变，这些变换通常分为内在[2,24,3]或外在[20,19,14,10,5]。它们还可以分为局部特征和全局特征。对于特定的任务，找到最佳的特征组合并非易事。
【在3D数据上深度学习】
3D数据有多种流行的表示形式，导致了各种学习方法。
Volumetric CNNs：[28,17,18]是将3D卷积神经网络应用于体素化形状的先驱。然而，由于数据稀疏性和三维卷积的计算成本，体积表示受到其分辨率的限制。FPNN[13]和Vote3D[26]提出了处理稀疏性问题的特殊方法；然而，它们的操作仍然是在稀疏的体积上进行的，因此处理非常大的点云对它们来说是一个挑战。多视图CNN：[23,18]尝试将3D点云或形状渲染为2D图像，然后应用2D conv网络对其进行分类。通过精心设计的图像CNN，这一系列方法在形状分类和检索任务上取得了卓越的性能[21]。但是，将它们扩展到场景理解或其他3D任务（如点分类和形状完成）是非常重要的。光谱CNN：略。基于特征的DNN：[6,8]首先通过提取传统形状特征将3D数据转换为向量，然后使用完全连通的网络对形状进行分类。我们认为它们受到提取特征的表示能力的限制。
【对无序集的深入学习】
从数据结构的角度来看，点云是一组无序的向量。虽然深度学习的大部分工作都集中在常规输入表示上，如序列（在语音和语言处理中）、图像和体积（视频或3D数据），但在点集的深度学习方面做的工作并不多。
Oriol Vinyals等人[25]最近的一项工作研究了这个问题。他们使用具有 注意力机制的读-写网络来消耗无序的输入集，并表明他们的网络具有对数字进行排序的能力。然而，由于他们的工作集中在通用集合和NLP应用程序上，因此集合中缺少几何体的作用。
3. Problem Statement 【输入】我们设计了一个深度学习框架，直接使用无序点集作为输入。点云表示为一组3D点 { P i ∣ i = 1 , . . . , n } \{Pi | i = 1, ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/23ff3b696541428ce7f139f4b80cfc50/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-28T20:00:54+08:00" />
<meta property="article:modified_time" content="2021-10-28T20:00:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【论文阅读】3D点云 -- PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <h3><a id="font_colorblack_1"></a><font color="black">前言</font></h3> 
 <p><font color="black"> 本博客详解遵从论文讲述的顺序。但我们要明确该论文的要点，以更好的阅读论文：针对点云的3个特性，pointnet设计的应对方法，以及设计理念。</font></p> 
 <ul><li><font color="black">点云的无序性：网络使用了对称函数 (maxpooling) 来降采样点云的特征</font></li><li><font color="black">点云的各点之间影响：网络将局部点的特征与 全局特征 进行concat，综合信息预测结果</font></li><li><font color="black">点云的几何变化不变性（刚性变换）：网络添加了 T-net，学习一个仿射变换矩阵，来适应点云的旋转平移。<br>  </font></li></ul> 
 <p><font color="black"> pointnet实现了多种任务：分类、零件分割、语义分割、3D目标检测。但对于本文，更重要的是抓住上面提到的核心点的设计。<br> 虽然在现在来看，在相关研究中pointnet效果不理想，但在当时 pointnet 的提出是开创性的，pointnet++是在此基础上完成。而后的一系列论文，大多借鉴了pointnet++的对点云学习方式。</font></p> 
</blockquote> 
<blockquote> 
 <h3><a id="font_colorblackAbstract_11"></a><font color="black">Abstract</font></h3> 
 <ul><li><font color="black">【使用点云】点云是一种重要的几何数据结构。由于其不规则的格式，大多数研究人员将这些数据转换为规则的三维体素网格或图像集合。但是，这会使数据变得不必要的庞大，并导致问题。</font></li><li><font color="black">【本文设计】在本文中，我们设计了一种新型的直接使用点云的神经网络，它很好地考虑了输入点的 <strong>置换不变性</strong>（旋转不变形）。<font color="blue">我们的网络名为PointNet，它为从对象分类、零件分割到场景语义解析的应用程序提供了统一的体系结构。<br> <font color="black">虽然简单，但PointNet是高效的。从经验上看，它表现出强劲的表现，甚至比现有技术更好。理论上，我们提供分析，以了解网络学到了什么，以及为什么网络在输入扰动和损坏方面是健壮的。</font></font></font></li></ul> 
</blockquote> 
<blockquote> 
 <h3><a id="font_colorblack1_Introduction_16"></a><font color="black">1. Introduction</font></h3> 
 <p><font color="black">在本文中，我们探讨了能够推理三维几何数据（如点云或网格）的深度学习体系结构。<br> <font color="bluen">【<strong>点云已有操作</strong>】<font color="black">由于点云或网格不是常规格式，大多数研究人员通常会将这些数据转换为常规的三维体素网格或图像集合（例如，视图），然后再将其输入深网体系结构。<br> <font color="bluen">【<strong>原因</strong>】<font color="black">典型的卷积结构需要高度规则的输入数据格式，如图像网格或三维体素，以便执行权重共享和其他内核优化。<br> <font color="bluen">【<strong>问题</strong>】<font color="black">然而，这种数据表示转换会使生成的数据变得不必要的庞大，同时还会引入数据量化，从而模糊数据的自然不变性。<br>  </font></font></font></font></font></font></font></p> 
 <p><font color="bluen">【<strong>本论文解决方法</strong>】<font color="black">出于这个原因，我们将重点放在使用简单点云的3D几何体的不同输入表示上，并将结果命名为PointNets。点云是简单而统一的结构，避免了网格的组合不规则性和复杂性，因此更易于学习。然而，PointNets仍然必须尊重这样一个事实，即点云只是一组点，因此对其成员的排列是不变的，因此需要在网络计算中进行某些对称化。还需要考虑刚性运动的进一步不变性。</font></font></p> 
 <ul><li><font color="bluen">【PointNet是一个统一的体系结构】<br> <font color="black">它直接将点云作为输入，并为整个输入 输出类别标签，或为输入的每个点输出每个点 分割/部分标签。<br> 我们网络的基本架构出人意料地简单，因为在初始阶段，每个点都被完全独立地处理。<br> 在基本设置中，每个点仅由其三个坐标 (x,y,z)表示。可以通过计算法线和其他局部或全局特征来添加其他维度。</font></font></li><li><font color="bluen">【方法的关键是使用单个对称函数max pooling】<br> <font color="black">网络有效地学习一组优化函数/标准，这些函数/标准 选择点云中感兴趣或信息丰富的点，并对其选择的原因进行编码。网络的最终完全连接层将这些学习到的最佳值聚合到上述整个形状的全局描述符中（形状分类），或用于预测每点标签（形状分段）。</font></font></li><li><font color="bluen">【输入格式很容易应用刚性或仿射变换，因为每个点都独立变换】<br> <font color="black">因此，我们可以添加一个依赖于数据的空间变换网络，该网络尝试在点网处理数据之前对数据进行规范化，以便进一步改进结果。</font></font></li><li><font color="bluen">【对方法进行了理论分析和实验评估】<br> <font color="black">我们证明了我们的网络可以逼近任何连续的集合函数。<br> 更有趣的是，我们的网络通过一组稀疏的关键点学习总结输入点云，这些关键点大致对应于根据可视化显示的对象骨架。理论分析提供了一种理解，为什么我们的点网对输入点的小扰动以及通过点插入（异常值）或删除（缺失数据）而导致的损坏，具有高度鲁棒性。<br>  </font></font></li></ul> 
 <p><font color="black">我们工作的主要贡献如下：</font></p> 
 <ul><li><font color="black">我们设计了一种新颖的深网体系结构，适用于使用三维无序点集；</font></li><li><font color="black">我们展示了如何训练这样一个网络来执行3D形状分类、形状部分分割和场景语义解析任务；</font></li><li><font color="black">我们对我们的方法的稳定性和效率进行了全面的实证和理论分析；</font></li><li><font color="black">我们展示了网络中选定神经元计算的3D特征，并对其性能进行了直观解释。<br>  </font></li></ul> 
 <p><font color="black">用神经网络处理无序集的问题是一个非常普遍和基本的问题——我们希望我们的想法也能转移到其他领域。</font></p> 
</blockquote> 
<blockquote> 
 <h3><a id="font_colorblack2_Related_Work_48"></a><font color="black">2. Related Work</font></h3> 
 <p><font color="bluen">【点云特征当前获取方式：针对不同任务手工制作】</font></p> 
 <p><font color="black">点云的大多数现有特征都是针对特定任务手工制作的。点特征通常对点的某些统计特性进行编码，并设计为对某些变换保持不变，这些变换通常分为内在[2,24,3]或外在[20,19,14,10,5]。它们还可以分为局部特征和全局特征。对于特定的任务，找到最佳的特征组合并非易事。<br>  </font></p> 
 <p><font color="bluen">【在3D数据上深度学习】<br> <font color="black">3D数据有多种流行的表示形式，导致了各种学习方法。</font></font></p> 
 <ul><li><font color="black">Volumetric CNNs：[28,17,18]是将3D卷积神经网络应用于体素化形状的先驱。然而，由于数据稀疏性和三维卷积的计算成本，体积表示受到其分辨率的限制。FPNN[13]和Vote3D[26]提出了处理稀疏性问题的特殊方法；然而，它们的操作仍然是在稀疏的体积上进行的，因此处理非常大的点云对它们来说是一个挑战。</font></li><li><font color="black">多视图CNN：[23,18]尝试将3D点云或形状渲染为2D图像，然后应用2D conv网络对其进行分类。通过精心设计的图像CNN，这一系列方法在形状分类和检索任务上取得了卓越的性能[21]。但是，将它们扩展到场景理解或其他3D任务（如点分类和形状完成）是非常重要的。</font></li><li><font color="black">光谱CNN：略。</font></li><li><font color="black">基于特征的DNN：[6,8]首先通过提取传统形状特征将3D数据转换为向量，然后使用完全连通的网络对形状进行分类。我们认为它们受到提取特征的表示能力的限制。<br>  </font></li></ul> 
 <p><font color="bluen">【对无序集的深入学习】<br> <font color="black">从数据结构的角度来看，点云是一组无序的向量。虽然深度学习的大部分工作都集中在常规输入表示上，如序列（在语音和语言处理中）、图像和体积（视频或3D数据），但在点集的深度学习方面做的工作并不多。<br> <font color="black">Oriol Vinyals等人[25]最近的一项工作研究了这个问题。他们使用具有 注意力机制的读-写网络来消耗无序的输入集，并表明他们的网络具有对数字进行排序的能力。然而，由于他们的工作集中在通用集合和NLP应用程序上，因此集合中缺少几何体的作用。</font></font></font></p> 
</blockquote> 
<blockquote> 
 <h3><a id="font_colorblack_3_Problem_Statement_66"></a><font color="black"> 3. Problem Statement</font></h3> 
 <p><font color="bluen">【输入】<font color="black">我们设计了一个深度学习框架，直接使用无序点集作为输入。点云表示为一组3D点 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            { 
           
          
            P 
           
          
            i 
           
          
            ∣ 
           
          
            i 
           
          
            = 
           
          
            1 
           
          
            , 
           
          
            . 
           
          
            . 
           
          
            . 
           
          
            , 
           
          
            n 
           
          
            } 
           
          
         
           \{Pi | i = 1, ..., n\} 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{<!-- --></span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mord mathdefault">i</span><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">n</span><span class="mclose">}</span></span></span></span></span>，其中每个点是其坐标加上额外的特征通道（如颜色、法线等）的向量。为简单和清晰起见，除非另有说明，否则我们仅使用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            ( 
           
          
            x 
           
          
            , 
           
          
            y 
           
          
            , 
           
          
            z 
           
          
            ) 
           
          
         
           (x,y,z) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="mclose">)</span></span></span></span></span>坐标作为点的通道。<br> <font color="bluen">【任务】<font color="black">对于对象分类任务，输入点云要么直接从物体采样，要么从场景点云预分割。我们建议的深度网络输出所有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              k 
             
            
           
             k 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span>个候选类的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              k 
             
            
           
             k 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span>个分数。 || 对于语义分割，输入可以是用于零件区域分割的单个对象，也可以是用于对象区域分割的三维场景的子体积。我们的模型将为每个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              n 
             
            
           
             n 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>点和每个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              m 
             
            
           
             m 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>语义子类别输出 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              n 
             
            
              × 
             
            
              m 
             
            
           
             n×m 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>分数。</font></font></font></font></p> 
</blockquote> 
<blockquote> 
 <h3><a id="font_colorblack4Deep_Learning_on_Point_Sets_71"></a><font color="black">4.Deep Learning on Point Sets</font></h3> 
 <p><font color="black">我们的网络体系结构（第4.2节）受 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            R 
           
          
            n 
           
          
         
        
          \mathbb{R}^n 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68889em; vertical-align: 0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>（第4.1节）中点集属性的启发。</font></p> 
 <hr> 
 <h4><a id="font_colorblack_41__74"></a><font color="black"> 4.1. 点云的性质（也是网络设计主要考虑的因素）</font></h4> 
 <p><font color="black">我们的输入是来自欧式空间的点的子集。它有三个主要特性：</font></p> 
 <ul><li><font color="bluen">【无序】<font color="black">与图像中的像素阵列或体积栅格中的体素阵列不同，点云是一组没有特定顺序的点。</font></font></li><li><font color="bluen">【各点之间的互相影响】<font color="black">这些点来自具有距离度量的空间。这意味着点不是孤立的，相邻点形成一个有意义的子集。因此，模型需要能够从附近的点捕获局部结构，以及局部结构之间的组合交互。</font></font></li><li><font color="bluen">【几何变化的不变性】<font color="black">作为几何对象，点集的学习表示应该对某些变换保持不变。例如，一起旋转和平移点不应修改全局点云类别，也不应修改点的分割。</font></font></li></ul> 
 <hr> 
 <h4><a id="font_colorblack42_PointNet_80"></a><font color="black">4.2. PointNet体系结构</font></h4> 
 <p><font color="black">我们的完整网络架构如图2所示，其中分类网络和分割网络共享大部分结构。<br> <img src="https://images2.imgbox.com/b7/e9/gfdUv5On_o.png" alt="请添加图片描述"><br> <font color="bluen">【<strong>PointNet架构</strong>】图2</font></font></p> 
 <ul><li><font color="black">1) 分类网络以n个点作为输入，给输入点云和高维特征应用了仿射变换（T-net），然后通过最大池聚合点特征。</font></li><li><font color="black">2) 输出为k类的分类分数.</font></li><li><font color="black">3) 分割网络是分类网络的扩展。它连接全局和局部特征，并输出每点分数。“mlp”代表多层感知器，括号中的数字是层大小。</font></li><li><font color="black">4) Batchnorm用于具有ReLU的所有图层。Dropout层用于分类网中的最后一个mlp。<br>  </font></li></ul> 
 <p><font color="bluen">【<strong>网络三个关键模块</strong>】分别来来解决点云的3个特性。</font></p> 
 <ul><li><font color="black">【点云的无序性】最大池化层（作为聚合所有点信息的对称函数）</font></li><li><font color="black">【点云的各点之间的互相影响】局部和全局信息聚合结构</font></li><li><font color="black"> 【点云的旋转的不变性】两个对齐输入点和点特征的联合对齐网络。</font></li></ul> 
 <hr> 
 <p><font color="black">我们将在下面的单独段落中讨论这些设计选择背后的原因<br>  <br> <font color="bluen">【无序输入的对称函数】<br> <font color="black">为了使模型对输入置换保持不变，存在三种策略：</font></font></font></p> 
 <ul><li> <p><font color="black"> 1) 将输入排序为规范顺序<br> <font color="black"> 虽然排序听起来像是一个简单的解决方案，但在高维空间中，实际上不存在一个相对于一般意义上的稳定的排序。这很容易用矛盾来说明：<br> 如果存在这种排序策略，它将在高维空间和一维实线之间定义一个双射映射。不难看出，要求排序对于点变动是稳定的，等同于要求该映射在维数减小时依然保持空间接近性，这是在一般情况下无法实现的任务。<br> 因此，排序并不能完全解决排序问题，而且当排序问题持续存在时，网络很难学习从输入到输出的一致映射。如实验（图5）所示，我们发现直接在排序点集上应用MLP的性能很差，尽管略优于直接处理未排序的输入。</font></font></p> </li><li> <p><font color="black"> 2) 将输入作为一个序列来训练RNN，但通过各种排列来增加训练数据<br> <font color="black"> 使用RNN的想法将点集视为序列信号，并希望通过使用随机排列的序列训练RNN，RNN将对输入顺序保持不变。然而，在“顺序事项”[25]中，作者表明顺序确实重要，不能完全忽略。<font color="blue">尽管RNN对长度较小（几十个）的序列的输入排序具有相对较好的鲁棒性，但很难扩展到数千个输入元素，这是点集的常见大小。<font color="black">经验上，我们还表明基于RNN的模型的性能不如我们提出的方法（图5）。</font></font></font></font></p> </li><li> <p><font color="black"> 3) 使用简单的对称函数聚合每个点的信息，本文选择了最大池化。<br> 这里，对称函数以n个向量作为输入，并输出对输入顺序不变的新向量。例如，+和∗ 运算符是对称的二元函数。<br> <font color="black"> 我们的想法是通过对点集中的变换元素应用对称函数来近似定义在点集中的一般函数如下图。<br> 从经验上讲，我们的基本模块非常简单：<font color="blue">我们用多层感知器网络来近似 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
           
            
             
             
               h 
              
             
            
              h 
             
            
          </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span></span></span></span></span>，用单变量函数和最大池函数的组合来近似 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
           
            
             
             
               g 
              
             
            
              g 
             
            
          </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span></span></span></span></span>。<font color="black">实验证明，这种方法效果良好。通过 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
              
                h 
               
              
             
               h 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span></span></span></span></span>的集合，我们可以学习一些 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
              
                f 
               
              
             
               f 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span></span></span></span></span>来捕获集合的不同属性。<br> <img src="https://images2.imgbox.com/46/26/dU7sduei_o.png" alt="请添加图片描述" width="500"></font></font></font></font></p> 
   <blockquote> 
    <p><font color="black">上面的公式可以转化为下面的图。其中【h：高维映射】【g：对称函数 (如maxpooling)】【r：MLP】<br> <img src="https://images2.imgbox.com/ad/d5/KCEsn4k8_o.png" alt="在这里插入图片描述" width="500"><br> <img src="https://images2.imgbox.com/fa/db/jtAfDi2c_o.png" alt="在这里插入图片描述" width="700"></font></p> 
   </blockquote> <p><font color="black">虽然我们的关键模块看起来很简单，但它具有有趣的特性（见第5.3节），并且可以在一些不同的应用程序中实现强大的性能（见第5.1节）。由于我们模块的简单性，我们还能够提供第4.3节所述的理论分析。<br>  </font></p> </li></ul> 
 <p><font color="bluen">【局部和全局信息聚合】</font></p> 
 <ul><li><font color="black">上述部分的输出形成一个向量 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            [ 
           
           
           
             f 
            
           
             1 
            
           
          
            ， 
           
          
            … 
           
          
            ， 
           
           
           
             f 
            
           
             K 
            
           
          
            ] 
           
          
         
           [f_1，…，f_K] 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span>，它是输入集的全局特征。我们可以很容易地训练一个支持向量机或多层感知器分类器，对形状的全局特征进行分类。</font></li><li><font color="black">然而，点分割需要结合局部和全局信息。我们可以通过简单而高效的方式实现这一点。<br> 我们的解决方案如图2（分段网络）所示。在计算全局点云特征向量之后，我们通过将全局特征与每个点特征连接起来，将其反馈给每个点特征。然后，我们基于组合点特征提取新的每点特征，这一次每点特征同时感知局部和全局信息。<br> 通过这种修改，我们的网络能够预测依赖于局部几何和全局语义的每点数量。例如，我们可以准确预测每个点的法线（补充图中的图），验证网络是否能够汇总来自点的局部邻域的信息。在实验环节中，我们还展示了我们的模型在形状部分分割和场景分割方面的最新性能。<br>  </font></li></ul> 
 <p><font color="bluen">【联合对齐网络】<br> <font color="black">如果点云经历某些几何变换（如平移旋转），点云仍然是同一物体，其的语义标记必须保持不变。因此，我们期望通过我们的点集学习的特征对这些变换是不变的。自然的解决方案是在特征提取之前将所有输入集对齐到规范空间。</font></font></p> 
 <ul><li><font color="black">2D图片上：Jaderberg等人[9]引入了空间变换的概念，通过采样和插值对齐2D图像，这是通过在GPU上实现的专门定制层实现的。</font></li><li><font color="black">3D点云上：输入形式允许我们以更简单的方式实现这一目标。我们不需要发明任何新的层，也不需要像在图像中那样引入别名。<br> <img src="https://images2.imgbox.com/ae/67/dpoumCFB_o.png" alt="在这里插入图片描述"><br> <font color="blue">【<strong>T-net的设计</strong>】<font color="black">微型网络，类似于大型网络，由点独立特征提取、最大池和完全连接层等基本模块组成。起到一个仿射变换的作用，应对点云的几何变换不变性。<br> <font color="blue">【应用到点云】<font color="black">（上图左）我们通过一个迷你网络（图2中的T网络）预测仿射变换矩阵，并直接将此变换应用于输入点的坐标。<br> <font color="blue">【应用到高维特征】<font color="black">（上图右）这一思想还可以进一步扩展到特征空间的对齐。<font color="black">我们可以在点特征上插入另一个对齐网络，并预测特征变换矩阵以对齐来自不同输入点云的特征。然而，特征空间中的变换矩阵比空间变换矩阵的维数要高得多，这大大增加了优化的难度。因此，我们在softmax训练损失中添加了一个正则化项。我们<font color="red">将特征变换矩阵约束为接近正交矩阵：<font color="black"><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
                  
                   
                    
                     
                     
                       L 
                      
                      
                      
                        r 
                       
                      
                        e 
                       
                      
                        g 
                       
                      
                     
                    
                      = 
                     
                     
                      
                      
                        ∥ 
                       
                      
                        I 
                       
                      
                        − 
                       
                      
                        A 
                       
                       
                       
                         A 
                        
                       
                         T 
                        
                       
                      
                        ∥ 
                       
                      
                     
                       F 
                      
                     
                       2 
                      
                           
                    
                      ( 
                     
                    
                      2 
                     
                    
                      ) 
                     
                    
                   
                     L_{reg}=\left \|I-AA^T \right \|_F^2 \,\,\,\,\,\,(2) 
                    
                   
                 </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.969438em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.49505em; vertical-align: -0.39971em;"></span><span class="minner"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.86199em;"><span class="" style="top: -2.25599em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∥</span></span></span><span class="" style="top: -2.86199em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∥</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.35001em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.07847em;">I</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.891331em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.86199em;"><span class="" style="top: -2.25599em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∥</span></span></span><span class="" style="top: -2.86199em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∥</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.35001em;"><span class=""></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.09534em;"><span class="" style="top: -2.30029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">F</span></span></span><span class="" style="top: -3.34423em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.39971em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span></span><br> <font color="black">其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
                  
                   
                    
                    
                      A 
                     
                    
                   
                     A 
                    
                   
                 </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span></span></span></span></span>是由T-net 预测的特征对齐矩阵。正交变换不会丢失输入中的信息，因此是需要的。我们发现，通过添加正则化项，优化变得更加稳定，我们的模型获得了更好的性能。</font></font></font></font></font></font></font></font></font></font></font></li></ul> 
 <hr> 
 <h4><a id="font_colorblack43__135"></a><font color="black">4.3. 理论分析</font></h4> 
 <p><font color="black">（这一节不是很懂，但不影响本论文的理解）<br> <font color="bluen">【<strong>通用逼近</strong>】<br> <font color="black">我们首先展示了我们的神经网络对连续集函数的通用逼近能力。通过集函数的连续性，直观地说，对输入点集的一个小扰动，不应该极大地改变函数值，例如分类或分割分数。让 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             χ 
            
           
             = 
            
           
             { 
            
           
             S 
            
           
             : 
            
           
             S 
            
           
             ⊆ 
            
           
             [ 
            
           
             0 
            
           
             , 
            
           
             1 
            
            
            
              ] 
             
            
              m 
             
            
           
             、 
            
           
             ∣ 
            
           
             S 
            
           
             ∣ 
            
           
             = 
            
           
             n 
            
           
             } 
            
           
          
            \chi = \{S : S ⊆ [0, 1]^m 、|S| = n\} 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">χ</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{<!-- --></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.8193em; vertical-align: -0.13597em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mord">∣</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">}</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             f 
            
           
             : 
            
           
             χ 
            
           
             → 
            
           
             R 
            
           
          
            f :\chi → R 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">χ</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span></span></span> 是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             χ 
            
           
          
            \chi 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">χ</span></span></span></span></span> 上关于Hausdorff距离的连续集函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
            
            
              d 
             
            
              H 
             
            
           
             ( 
            
           
             ⋅ 
            
           
             , 
            
           
             ⋅ 
            
           
             ) 
            
           
          
            d_H(·,·) 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mclose">)</span></span></span></span></span>。<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             ∨ 
            
           
             ϵ 
            
           
             &gt; 
            
           
             0 
            
           
             , 
            
           
             ∃ 
            
           
             δ 
            
           
             &gt; 
            
           
             0 
            
           
          
            \vee \epsilon &gt;0, ∃δ &gt; 0 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.59466em; vertical-align: -0.0391em;"></span><span class="mord">∨</span><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">∃</span><span class="mord mathdefault" style="margin-right: 0.03785em;">δ</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>，对于任意 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             S 
            
           
          
            S 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
            
            
              S 
             
             
              
             
               ′ 
              
             
            
           
             ∈ 
            
           
             χ 
            
           
          
            S^{'} \in \chi 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.98158em; vertical-align: -0.0391em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.94248em;"><span class="" style="top: -2.94248em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class=""></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.827829em;"><span class="" style="top: -2.931em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">χ</span></span></span></span></span>，如果<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
            
            
              d 
             
            
              H 
             
            
           
             ( 
            
           
             S 
            
           
             , 
            
            
            
              S 
             
             
              
             
               ′ 
              
             
            
           
             ) 
            
           
             &lt; 
            
           
             δ 
            
           
          
            d_H(S,S^{'})&lt;δ 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.19248em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.94248em;"><span class="" style="top: -2.94248em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class=""></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.827829em;"><span class="" style="top: -2.931em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03785em;">δ</span></span></span></span></span>，则 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             n 
            
           
             ∣ 
            
           
             f 
            
           
             ( 
            
           
             S 
            
           
             ) 
            
           
             − 
            
           
             f 
            
           
             ( 
            
            
            
              S 
             
             
              
             
               ′ 
              
             
            
           
             ) 
            
           
             ∣ 
            
           
             &lt; 
            
           
             ϵ 
            
           
          
            n |f(S) − f(S^{'})| &lt; \epsilon 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.19248em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mclose">)</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.94248em;"><span class="" style="top: -2.94248em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class=""></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.827829em;"><span class="" style="top: -2.931em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span></span>。我们的定理表明，如果在最大池层有足够多的神经元，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             f 
            
           
          
            f 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span></span></span></span></span> 可以由我们的网络任意逼近，即公式(1)中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             K 
            
           
          
            K 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">K</span></span></span></span></span>足够大。<br>  </font></font></font></p> 
 <p><img src="https://images2.imgbox.com/4f/ea/1xou0EVY_o.png" alt="在这里插入图片描述" width="500"></p> 
 <p><font color="black">这个定理的证明可以在我们的补充材料中找到。关键思想是，在最坏的情况下，网络可以通过将空间划分为大小相等的体素，学会将点云转换为体积表示。然而，在实践中，网络学会了一种更聪明的探测空间的策略，我们将在点函数可视化中看到这一点。<br>  </font></p> 
 <p><font color="bluen"> 【<strong>瓶颈维数与稳定性</strong>】<br> <font color="black">理论上和实验上，我们发现我们的网络的表达能力强烈地受到最大池层的维数的影响。在这里，我们提供了一个分析，这也揭示了我们的模型的稳定性相关的属性。<br> 我们定义 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            u 
           
          
            = 
           
           
            
            
              M 
             
            
              A 
             
            
              X 
             
            
            
             
             
               x 
              
             
               i 
              
             
            
              ∈ 
             
            
              S 
             
            
           
          
            { 
           
          
            h 
           
          
            ( 
           
           
           
             x 
            
           
             i 
            
           
          
            ) 
           
          
            } 
           
          
         
           u = \underset{x_i∈S}{MAX}\{h(x_i)\} 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.59443em; vertical-align: -0.844431em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.68333em;"><span class="" style="top: -2.35567em; margin-left: 0em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328086em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class=""><span class="mop"><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.844431em;"><span class=""></span></span></span></span></span></span><span class="mopen">{<!-- --></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></span>是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            f 
           
          
         
           f 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span></span></span></span></span> 的子网，它将 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            [ 
           
          
            0 
           
          
            , 
           
          
            1 
           
           
           
             ] 
            
           
             m 
            
           
          
         
           [0,1]^m 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span></span></span></span> 中的点集映射到K维向量。以下定理告诉我们，输入集中的小损坏或额外噪声点不太可能改变网络的输出：<br> <img src="https://images2.imgbox.com/dc/dd/ttt5hOEA_o.png" alt="在这里插入图片描述" width="500"><br> 我们解释这个定理的含义。<br> （a） 表示如果保留 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             C 
            
           
             S 
            
           
          
         
           C_S 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 中的所有点，则 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            f 
           
          
            ( 
           
          
            S 
           
          
            ) 
           
          
         
           f(S) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mclose">)</span></span></span></span></span>在输入损坏之前保持不变；具有高达 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             N 
            
           
             S 
            
           
          
         
           N_S 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.10903em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的额外噪声点也保持不变。<br> （b） 表示 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             C 
            
           
             S 
            
           
          
         
           C_S 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 仅包含由 公式(1) 中的K确定的有界点数。换句话说，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            f 
           
          
            ( 
           
          
            S 
           
          
            ) 
           
          
         
           f(S) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mclose">)</span></span></span></span></span> 实际上完全由有限子集 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             C 
            
           
             S 
            
           
          
            ⊆ 
           
          
            S 
           
          
         
           C_S⊆ S 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span></span></span></span></span> 决定小于或等于K个元素。因此，我们称 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             C 
            
           
             S 
            
           
          
         
           C_S 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 为S的临界点集，称K为f的瓶颈维数。<br> 结合h的连续性，这解释了我们的模型关于点云的扰动、损坏和额外噪声点的鲁棒性。与机器学习模型中的稀疏性原理类似，获得了鲁棒性。直观地说，我们的网络学习通过一组稀疏的关键点来总结形状。在实验部分，我们看到关键点构成了一个物体的骨架。</font></font></p> 
</blockquote> 
<blockquote> 
 <h3><a id="font_colorblack5_Experiment_156"></a><font color="black">5. Experiment</font></h3> 
 <p><font color="black">实验分为四个部分。<br> 首先，我们展示了点网可以应用于多个3D识别任务（第5.1节）。<br> 其次，我们提供详细的实验来验证我们的网络设计（第5.2节）。<br> 最后，我们将网络学习的内容可视化（第5.3节），并分析时间和空间复杂性（第5.4节）。</font></p> 
 <hr> 
 <h5><a id="font_colorblack51_Applications_162"></a><font color="black">5.1. Applications</font></h5> 
 <p><font color="black">在本节中，我们将展示如何训练我们的网络来执行3D对象分类、对象部分分割和语义场景分割。尽管我们正在开发一种全新的数据表示（点集），但我们能够在多个任务的基准测试中获得相当甚至更好的性能。<br>  </font></p> 
 <p><font color="bluen"> 【<strong>3D对象分类</strong>】<br> <font color="black">我们的网络学习可用于对象分类的全局点云特征。</font></font></p> 
 <ul><li><font color="bluen"> 【数据集】<font color="black">我们在ModelNet40的形状分类基准上 评估我们的模型。来自40个人手工完成的CAD模型用于对象分类，共有12311个，其中9843个训练数据，2468个测试数据。以前的方法侧重于体积和多视图图像表示，我们是第一个直接处理原始点云的方法。</font></font></li><li><font color="bluen"> 【数据处理】<font color="black">我们根据面片面积对网格面上的1024个点进行统一采样，并将它们规格化为一个单位球体。在训练过程中，我们通过沿向上的轴随机旋转对象来增强点云，并通过均值为零且标准偏差为0.02的高斯噪声抖动每个点的位置。</font></font></li><li><font color="bluen"> 【实验】<font color="black">在表1中，我们将我们的模型与以前的工作以及使用MLP对从点云提取的传统特征（点密度、D2、形状轮廓等）进行基线比较。<br> <img src="https://images2.imgbox.com/e9/ad/gpp1nOVx_o.png" alt="在这里插入图片描述" width="500"> </font></font> 
   <ul><li><font color="black">我们的模型在基于3D输入（体积和点云）的方法中实现了最先进的性能。 <font color="blue">由于只有完全连接的层和最大池，我们的网络在推理速度上获得了强大的领先优势，并且可以很容易地在CPU中并行化。</font></font></li><li><font color="black">我们的方法与基于多视图的方法（MVCNN[23]）之间仍然存在一个小差距，我们认为这是由于丢失了可由渲染图像捕获的精细几何细节。<br>  </font></li></ul> </li></ul> 
 <p><font color="bluen"> 【<strong>三维对象零件分割</strong>】<br> <font color="black">零件分割是一项具有挑战性的细粒度三维识别任务。给定三维扫描或网格模型，任务是为每个点或面指定零件类别标签（例如椅子腿、杯柄）。</font></font></p> 
 <ul><li> <p><font color="bluen"> 【数据集】<font color="black">我们对[29]中的ShapeNet零件数据集进行评估，该数据集包含16个类别的16881个形状，共有50个零件进行注释。大多数对象类别都标有两到五个部分。真实注释标记在形状上的采样点上。</font></font></p> </li><li> <p><font color="bluen"> 【评估方法】<font color="black">我们将零件分割描述为逐点分类问题。评估指标是以分数为单位的mIoU。对于C类的每个形状S，要计算形状的mIoU：对于C类中的每个零件类型，计算实际标签和预测之间的IoU。如果实际点和预测点的并集为空，则将部分IoU计算为1。然后我们平均C类中所有零件类型的IOU，以获得该形状的mIoU。为了计算类别的mIoU，我们取该类别中所有形状的mIoU的平均值。</font></font></p> </li><li> <p><font color="bluen"> 【实验比较】<font color="black">在本节中，我们将分割版本PointNet（图2的修改版本，分割网络）与两种传统方法[27]和[29]进行比较，这两种方法都利用了逐点几何特征和形状之间的对应关系，以及我们自己的3D CNN基线。有关3D CNN的详细修改和网络架构，请参阅补充资料。<br> 在表2中，我们报告了每个类别和平均IoU（%）分数。我们观察到平均IoU改善2.3%，我们的净改善率超过了大多数类别的基线方法。</font></font></p> </li><li> <p><font color="bluen"> 【模型完整性测试】<font color="black"> 我们还对模拟Kinect扫描进行了实验，以测试这些方法的鲁棒性。对于ShapeNet零件数据集中的每个CAD模型，我们使用Blensor Kinect模拟器[7]从六个随机视点生成不完整的点云。<br> 我们使用相同的网络架构和训练设置，在完整的形状和部分扫描上训练我们的pointnet。结果表明，我们只损失了5.3%的平均IoU。在图3中，我们给出了完整和部分数据的定性结果。可以看出，尽管部分数据相当具有挑战性，但我们的预测是合理的。<br> <img src="https://images2.imgbox.com/0e/3d/mHVyCZDb_o.png" alt="请添加图片描述" width="500"><br>  </font></font></p> </li></ul> 
 <p><font color="bluen"> 【<strong>场景中的语义分割</strong>】<br> <font color="black">我们的零件分割网络可以很容易地扩展到语义场景分割，其中点标签成为语义对象类，而不是对象零件标签。</font></font></p> 
 <ul><li><font color="bluen"> 【数据集】 <font color="black">我们在 [斯坦福3D语义分析数据集] 上进行了实验[1]。数据集包含6个区域（包括271个房间）的Matterport扫描仪的3D扫描。扫描中的每个点都用13个类别（椅子、桌子、地板、墙壁等加上杂物）中的一个语义标签进行注释。</font></font></li><li><font color="bluen"> 【数据处理】<font color="black">为了准备训练数据，<font color="blue">我们首先将点按房间分割，然后将房间分成面积为1m×1m的块。我们对PointNet的分段式进行训练，以预测每个块中的每个点类。每个点由房间的XYZ、RGB和标准化位置的9维矢量（从0到1）。在训练时，我们在每个区块中随机抽取4096个点。<font color="black">在测试时，我们对所有点进行测试。我们遵循与[1]相同的协议，使用k-fold策略进行训练和测试。</font></font></font></font></li><li><font color="bluen"> 【点特征方式的实验对比】 <font color="black">我们将我们的方法与使用手工制作的点特征的基线进行比较。基线提取相同的9维局部特征和三个附加特征：局部点密度、局部曲率和法线。我们使用标准MLP作为分类器。结果如表3所示，其中我们的PointNet方法明显优于基线方法。在图4中，我们展示了定性分割结果。我们的网络能够输出平滑的预测，并且对缺失点和遮挡具有鲁棒性。<br> <img src="https://images2.imgbox.com/39/75/eFL8H3Mu_o.png" alt="在这里插入图片描述" width="500"><img src="https://images2.imgbox.com/d2/c0/HIUYm3Dn_o.png" alt="在这里插入图片描述" width="500"><br> 图4. 语义分割的定性结果。顶行是带有颜色的输入点云。底行是输出语义分割结果（在点上），以输入相同的摄影机视点来显示。<br>  </font></font></li></ul> 
 <p><font color="bluen"> 【<strong>3D对象检测系统</strong>】<br> <font color="black">基于我们网络的语义分割输出，我们进一步构建了一个3D对象检测系统，使用连接组件进行对象建议（详见补充）。我们与表4中先前最先进的方法进行了比较。<br> 前一种方法基于sliding shape方法（CRF后处理），支持向量机在体素网格中基于局部几何特征和全局房间上下文特征进行训练。<br> 在报告的家具类别中，我们的方法比它有很大的优势。<br> <img src="https://images2.imgbox.com/a6/ce/xCEAjOKe_o.png" alt="在这里插入图片描述" width="500"></font></font></p> 
 <hr> 
 <h4><a id="font_colorblack52_Architecture_Design_Analysis_203"></a><font color="black">5.2. Architecture Design Analysis</font></h4> 
 <p><font color="black">在本节中，我们通过控制实验验证我们的设计选择。我们还展示了网络超参数的影响。<br>  </font></p> 
 <p><font color="bluen"> 【<strong>与其他顺序不变方法的比较</strong>在分类问题上】<br> <font color="black">在第4.2节中提到的，使用无序集输入至少有三种选择。我们使用ModelNet40形状分类问题作为比较这些选项的测试平台，下面的两个控制实验也将使用此任务。<br> <img src="https://images2.imgbox.com/fe/fc/1pz6H5NM_o.png" alt="请添加图片描述" width="700"><br> 图5. 实现顺序不变性的三种方法。应用于点的多层感知器（MLP）由5个隐藏层组成，神经元大小为64,64,64,128,1024，所有点共享一个MLP副本。靠近输出端的MLP由两层组成，尺寸为512,256<br>  </font></font></p> 
 <p><font color="black">我们比较的基线（如图5所示）包括</font></p> 
 <ul><li><font color="bluen">未排序和排序点上的多层感知器（n×3阵列）</font></li><li><font color="bluen">将输入点视为序列的RNN模型</font></li><li><font color="bluen">基于对称函数的模型：<font color="black">我们实验的对称操作包括最大池、平均池和基于注意力的加权和。<br> 注意力方法类似于[25]中的方法，其中从每个点特征预测分数，然后通过计算softmax对分数进行归一化。然后根据归一化分数和点特征计算加权和。<br> <font color="black">如图5所示，maxpooling操作以较大的收益实现了最佳性能，这验证了我们的选择。</font></font></font></li></ul> 
 <p> </p> 
 <p><font color="bluen"> 【<strong>输入和特征转换的有效性</strong>】<br> <img src="https://images2.imgbox.com/49/16/8QXkLOHU_o.png" alt="请添加图片描述" width="500"><br> <font color="black"> 在表5中，我们展示了输入和特征转换（用于对齐）的积极影响。有趣的是，最基本的架构已经实现了相当合理的结果。<br> 使用输入转换可以提高0.8%的性能；正则化损失对于高维变换的工作是必要的；通过结合变换和正则化项，我们获得了最佳性能。<br>  </font></font></p> 
 <p><font color="bluen"> 【<strong>健壮性测试</strong>】<br> <font color="black"> 我们展示了我们的pointnet，虽然简单有效，但对各种输入损坏都是健壮的。我们使用与图5的最大池网络相同的架构。将输入点规格化为单位球体。结果如图6所示。<br> <img src="https://images2.imgbox.com/dc/5b/mNPn5wo4_o.png" alt="在这里插入图片描述" width="800"><br> 图6. pointnet稳健性测试。度量标准是ModelNet40测试集上的总体分类精度。<br> 左：删除点，其中“最远”是指使用最远采样对原始1024个点进行采样。<br> 中：插入，异常值均匀分散在单位球体中。<br> 右：摄动。将高斯噪声独立添加到每个点。<br>  </font></font></p> 
 <p><font color="black">对于漏点，当漏点率为50%时，采用随机输入抽样，精度最远仅下降2.4%和3.8%。如果我们的网络在训练过程中发现了异常点，那么它对异常点也具有鲁棒性。我们评估了两个模型：一个在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           ( 
          
         
           x 
          
         
           , 
          
         
           y 
          
         
           , 
          
         
           z 
          
         
           ) 
          
         
        
          (x,y,z) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="mclose">)</span></span></span></span></span>坐标点上训练；另一个是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           ( 
          
         
           x 
          
         
           , 
          
         
           y 
          
         
           , 
          
         
           z 
          
         
           ) 
          
         
        
          (x,y,z) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="mclose">)</span></span></span></span></span>加上点密度。即使20%的点是异常值，网络的准确率也超过80%。图6右侧显示了网络对点云的扰动的鲁棒性。</font></p> 
 <hr> 
 <h4><a id="font_colorblack53_Visualizing_PointNet_240"></a><font color="black">5.3. Visualizing PointNet</font></h4> 
 <p><img src="https://images2.imgbox.com/c4/8e/fWneOzGu_o.png" alt="在这里插入图片描述" width="400"><br> <font color="black">图7. 关键点和上限形状。虽然关键点共同确定给定形状的全局形状特征，但位于关键点集和上限形状之间的任何点云都会提供完全相同的特征。我们对所有图形进行颜色编码以显示深度信息。<br>  </font></p> 
 <p><font color="black">在图7中，我们可视化了一些样本形状 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           S 
          
         
        
          S 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span></span></span></span></span>的关键点集<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            C 
           
          
            S 
           
          
         
        
          C_S 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和上限形状<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            N 
           
          
            S 
           
          
         
        
          N_S 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.10903em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。两个形状之间的点集将给出完全相同的全局形状特征 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           f 
          
         
           ( 
          
         
           S 
          
         
           ) 
          
         
        
          f(S) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mclose">)</span></span></span></span></span>。<br> 从图7中我们可以清楚地看到，关键点集 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            C 
           
          
            S 
           
          
         
        
          C_S 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 通过最大池化的特征构建，体现了形状的骨架。上限形状 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            N 
           
          
            S 
           
          
         
        
          N_S 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.10903em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 说明了最大可能的点云，该点云与输入点云S具有相同的全局形状特征 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            f 
           
          
            S 
           
          
         
        
          f_S 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            C 
           
          
            S 
           
          
         
        
          C_S 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            N 
           
          
            S 
           
          
         
        
          N_S 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.10903em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 反映了点网的健壮性，这意味着失去一些非关键点根本不会改变全局形状特征 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            f 
           
          
            S 
           
          
         
        
          f_S 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。</font></p> 
 <hr> 
 <h4><a id="font_colorblack54__249"></a><font color="black">5.4. 时空复杂性分析</font></h4> 
 <p><img src="https://images2.imgbox.com/6c/59/fTVtFTFR_o.png" alt="在这里插入图片描述" width="400"><br> <font color="black">表6. 总结了分类PointNet的空间（网络中的参数数量）和时间（浮点运算/示例）复杂性。我们还将PointNet与以前工作中的一组具有代表性的基于体积和多视图的体系结构进行了比较。</font></p> 
 <ul><li><font color="bluen">【成本低】<font color="black">虽然MVCNN[23]和子卷（3D CNN）[18]实现了高性能，但PointNet在计算成本方面更高效：以浮点/样本衡量：效率分别提高了141x和8x。</font></font></li><li><font color="bluen">【空间小】<font color="black">就网络中的#param（少17倍的参数）而言，PointNet比MVCNN更节省空间。</font></font></li><li><font color="bluen">【时间复杂度增长慢】<font color="black">PointNet 的可伸缩性更高，指的是 它的空间和时间复杂性 O(N)，与输入点的数量上是线性关系。然而，由于卷积在计算时间上占主导地位，多视图方法的时间复杂度随图像分辨率的平方增长而增加，而基于体积卷积的方法随体积大小的立方增长。</font></font></li><li><font color="bluen">【具体计算速度】<font color="black">在TensorFlow上使用1080X GPU，PointNet可以每秒处理100多万个点，用于点云分类（约1K个对象/秒）或语义分割（约2个房间/秒），显示出实时应用的巨大潜力。</font></font></li></ul> 
</blockquote> 
<p>​</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d4e3a191eefccdf16e2a6baf947734a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">(三) 三维点云课程---RANSAC结合最小二乘求解点云的地面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/db754af184fa0f66e75870189a8619fa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">常用Linux命令的基本使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>