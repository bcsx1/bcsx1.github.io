<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Git基础学习_p1 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Git基础学习_p1" />
<meta property="og:description" content="文章目录 一、前言二、Git手册学习2.1 Git介绍&amp;前置知识2.2 Git教程2.2.1 导入新项目2.2.2 做更改2.2.3 Git追踪内容而非文件2.2.4 查看项目历史2.2.5 管理分支🔺2.2.6 用Git来协同工作2.2.7 查看历史 三、结尾 一、前言 Git相信大部分从事软件工作的人都听说过，甚至用过。
它是一款版本控制软件，用于管理项目迭代更新。
但大部分时候，你可能只是用过。就我个人而言，能想起来并知道其用途的，就下面几个简单命令，
git init git pull git add git commit git push 还有git remote、git branch等命令会偶尔用一下，但使用时都得上网查询。
虽然大部分情况下，这已经够了。
但偶尔会出现一些特殊情况，可能是操作时序有误导致的冲突，可能是项目真的有损坏。
当然本文并不需要解决这些问题，只是想通过文档学习，对git流程、git基础有个更全面的了解。
我打算从git介绍、git简单命令、git文档教程入手，对git进行进一步学习。
二、Git手册学习 git，是一个傻瓜式的内容跟踪器（Linux内核的首席架构师，也是Git的主要开发者Linus Torvalds是这么说的）。
使用简介如下：
git [-v | --version] [-h | --help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p|--paginate|-P|--no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] [--config-env=&lt;name&gt;=&lt;envvar&gt;] &lt;command&gt; [&lt;args&gt;] 这一长串的命令选项，可以看出其功能之强大，虽然这也不是给一般人用的。不过也别被吓到，根据八二定理，大部分情况下你只需要用到几条简单命令即可，而且现在有许多带GUI的git，图形化操作相对简单许多（即使如此，你还是需要了解Git基本流程）。
2.1 Git介绍&amp;前置知识 Git是一个快速、可扩展、分布式版本控制系统，具有异常丰富的命令集，提供高级操作以及对内部的完全访问。
文档建议从 gittutorial 开始学习，不过在这之前，还有一个非常重要的前置知识，那就是Git的二区一库。
二区是指，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/311a3790100934edf60b29c9a5a16042/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-28T14:25:40+08:00" />
<meta property="article:modified_time" content="2023-12-28T14:25:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Git基础学习_p1</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">一、前言</a></li><li><a href="#Git_21" rel="nofollow">二、Git手册学习</a></li><li><ul><li><a href="#21_Git_34" rel="nofollow">2.1 Git介绍&amp;前置知识</a></li><li><a href="#22_Git_60" rel="nofollow">2.2 Git教程</a></li><li><ul><li><a href="#221__84" rel="nofollow">2.2.1 导入新项目</a></li><li><a href="#222__110" rel="nofollow">2.2.2 做更改</a></li><li><a href="#223_Git_149" rel="nofollow">2.2.3 Git追踪内容而非文件</a></li><li><a href="#224__156" rel="nofollow">2.2.4 查看项目历史</a></li><li><a href="#225__170" rel="nofollow">2.2.5 管理分支</a></li><li><a href="#226_Git_230" rel="nofollow">🔺2.2.6 用Git来协同工作</a></li><li><a href="#227__350" rel="nofollow">2.2.7 查看历史</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_433" rel="nofollow">三、结尾</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_2"></a>一、前言</h2> 
<p>Git相信大部分从事软件工作的人都听说过，甚至用过。<br> 它是一款版本控制软件，用于管理项目迭代更新。<br> 但大部分时候，你可能只是用过。就我个人而言，能想起来并知道其用途的，就下面几个简单命令，</p> 
<pre><code class="prism language-shell"><span class="token function">git</span> init
<span class="token function">git</span> pull
<span class="token function">git</span> <span class="token function">add</span> 
<span class="token function">git</span> commit
<span class="token function">git</span> push
</code></pre> 
<p>还有<code>git remote</code>、<code>git branch</code>等命令会偶尔用一下，但使用时都得上网查询。<br> 虽然大部分情况下，这已经够了。<br> 但偶尔会出现一些特殊情况，可能是操作时序有误导致的冲突，可能是项目真的有损坏。</p> 
<p>当然本文并不需要解决这些问题，只是想通过文档学习，对git流程、git基础有个更全面的了解。</p> 
<p>我打算从git介绍、git简单命令、git文档教程入手，对git进行进一步学习。</p> 
<h2><a id="Git_21"></a>二、Git手册学习</h2> 
<p><strong>git，是一个傻瓜式的内容跟踪器</strong>（Linux内核的首席架构师，也是Git的主要开发者Linus Torvalds是这么说的）。</p> 
<p>使用简介如下：</p> 
<pre><code class="prism language-shell"><span class="token function">git</span> <span class="token punctuation">[</span>-v <span class="token operator">|</span> --version<span class="token punctuation">]</span> <span class="token punctuation">[</span>-h <span class="token operator">|</span> --help<span class="token punctuation">]</span> <span class="token punctuation">[</span>-C <span class="token operator">&lt;</span>path<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>-c <span class="token operator">&lt;</span>name<span class="token operator">&gt;=</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span><span class="token punctuation">]</span>
    <span class="token punctuation">[</span>--exec-path<span class="token punctuation">[</span><span class="token operator">=</span><span class="token operator">&lt;</span>path<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--html-path<span class="token punctuation">]</span> <span class="token punctuation">[</span>--man-path<span class="token punctuation">]</span> <span class="token punctuation">[</span>--info-path<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>-p<span class="token operator">|</span>--paginate<span class="token operator">|</span>-P<span class="token operator">|</span>--no-pager<span class="token punctuation">]</span> <span class="token punctuation">[</span>--no-replace-objects<span class="token punctuation">]</span> <span class="token punctuation">[</span>--bare<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>--git-dir<span class="token operator">=</span><span class="token operator">&lt;</span>path<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--work-tree<span class="token operator">=</span><span class="token operator">&lt;</span>path<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--namespace<span class="token operator">=</span><span class="token operator">&lt;</span>name<span class="token operator">&gt;</span><span class="token punctuation">]</span>
    <span class="token punctuation">[</span>--config-env<span class="token operator">=</span><span class="token operator">&lt;</span>name<span class="token operator">&gt;=</span><span class="token operator">&lt;</span>envvar<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>command<span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>args<span class="token operator">&gt;</span><span class="token punctuation">]</span>
</code></pre> 
<p>这一长串的命令选项，可以看出其功能之强大，虽然这也不是给一般人用的。不过也别被吓到，根据八二定理，大部分情况下你只需要用到几条简单命令即可，而且现在有许多带GUI的git，图形化操作相对简单许多（即使如此，你还是需要了解Git基本流程）。</p> 
<h3><a id="21_Git_34"></a>2.1 Git介绍&amp;前置知识</h3> 
<p>Git是一个快速、可扩展、分布式版本控制系统，具有异常丰富的命令集，提供高级操作以及对内部的完全访问。</p> 
<p>文档建议从 gittutorial 开始学习，不过在这之前，还有一个非常重要的前置知识，那就是Git的二区一库。<br> 二区是指，</p> 
<ul><li> <p>工作区：Wokespace，即受Git管控的项目目录/文件夹。<br> <img src="https://images2.imgbox.com/24/95/qhhtZpO0_o.png" width="80%"></p> </li><li> <p>暂存区：英文是 index 或 stage，也叫索引。一般存放在 .git 目录下的 index 文件中。<br> <img src="https://images2.imgbox.com/0f/8c/gasgyp2W_o.png" width="80%"></p> </li></ul> 
<p>一库指，</p> 
<ul><li>版本库：在工作区有一个隐藏目录 .git ，这个不算工作区，而是Git的版本库。<br> <img src="https://images2.imgbox.com/10/e5/s1AfI3X3_o.png" width="80%"></li></ul> 
<p>三者的简要关系如下，<br> <img src="https://images2.imgbox.com/c7/28/yHzKueCb_o.png" alt="在这里插入图片描述"><br> 可以看到Git的版本库（也就是Git初始化后，项目目录下多出来的那个.git文件夹）里有许多东西，其中最重要的就是暂存区stage（或者叫index），还有Git为我们自动创建的第一个分支master，以及指向master的指针叫HEAD。</p> 
<p>有了以上简单认识，接下来正式进入Git教程。</p> 
<blockquote> 
 <p><strong>注意</strong><br> 本小节内容是后来补的，故与后文可能没那么连贯。<br> 但其内容对了解后文部分操作相当有用。</p> 
</blockquote> 
<h3><a id="22_Git_60"></a>2.2 Git教程</h3> 
<p>gittutorial，这是文档中的章节名，顾名思义，它是git的教程介绍。<br> 本节介绍如何将新项目导入git，对其修改，并将更改共享给其他开发人员。</p> 
<p>首先，可以通过<code>git log --graph</code>等命令获取文档：</p> 
<pre><code class="prism language-bash">$ <span class="token function">man</span> git-log
</code></pre> 
<p>或</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> <span class="token builtin class-name">help</span> log
</code></pre> 
<p>后者会使用手册浏览器；（我装了的是某种GUI Git，在命令行中输入前者并不起作用，后者则会弹出说明文档）</p> 
<blockquote> 
 <p><strong>$</strong> 符号<br> $: (读法和dollar一样),<br> 命令行中的 $ 符号是Linux系统下的用户提示符，表示当前用户是普通用户。<br> 你在windows系统下安装git时，通常会装上vim命令行编辑器，也会看到该符号。</p> 
</blockquote> 
<p>在进行操作前，最好向Git说明你的姓名和电子邮件地址。最简单的方法是：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"Your Name Comes Here"</span>
$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"You@yourdomain.example.com"</span>
</code></pre> 
<h4><a id="221__84"></a>2.2.1 导入新项目</h4> 
<p>假设你一开始有一个tarball（Linux下的打包工具） <em>project.tar.gz</em> 包。你可以把它放在Git版本控制路径之下（能用Git访问到），如下操作：</p> 
<pre><code class="prism language-shell">$ <span class="token function">tar</span> xzf project.tar.gz
$ <span class="token builtin class-name">cd</span> project
$ <span class="token function">git</span> init
</code></pre> 
<p>在windows下前两行通常可以省略，因为可以用图形化的解压工具（winrar/7zip等），解压完直接在解压出的文件夹里右键打开命令行工具（称为bash）并输入 <code>git init</code> 即可。</p> 
<p>Git会回应：</p> 
<pre><code class="prism language-bash">Initialized empty Git repository <span class="token keyword">in</span> .git/
</code></pre> 
<p>现在Git已经初始化了该文件夹，此时你可以看到该目录下多了一个名为 <em>.git</em> 的新文件夹。</p> 
<p>接下来，告诉Git对当前目录下的所有文件进行快照（take a snapshot），用 <code>git add</code>命令（ <em>.</em> 表示当前目录）：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
</code></pre> 
<p>该快照现在存储在Git中称为 <strong>索引（index）</strong> 的暂存区域中。你可以用 <code>git commit</code>将索引的内容持久化到仓库（即版本库）中。<br> （索引相当于一个缓存区，所做修改先添加到索引中，然后再提交最终版。就像考试一样，你先在试卷和草稿纸上写写算算，然后在答题卡上填上答案，最后再提交；而不是试卷上写一个字提交一个字。从整个Git系统来看，这个比喻可能不那么恰当）</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> commit
</code></pre> 
<p>这会提示你输入提交信息（即对此次提交进行简要说明）。输入完后保存退出，就已将项目的第一个版本存储在Git中了（Vim中是这样的，GUI中则是点相应确认按钮）。</p> 
<h4><a id="222__110"></a>2.2.2 做更改</h4> 
<p>修改一些文件，然后将它们的更新内容添加到索引中：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> <span class="token function">add</span> file1 file2 file3
</code></pre> 
<p>现在已经准备好了提交。<br> 你可以使用 <code>git diff</code> 带 <code>--cached</code> 选项来查看将要提交的内容。</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token parameter variable">--cached</span>
</code></pre> 
<p>(若没有 <em>–cached</em> 选项， <em>git diff</em> 则显示你已经做出但尚未添加到索引中的更改)。你也可以使用 <code>git status</code> 来得到Git状态的简况：</p> 
<blockquote> 
 <p>–cached就是缓存，即查看索引的变化（确切讲是索引与上一次提交的不同）；<br> 不加就是查看工作区的变化，工作区相对于于索引的不同。</p> 
</blockquote> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> status
On branch master
Changes to be commited:
	<span class="token punctuation">(</span>use <span class="token string">"git restore --staged&lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>
		modified: file1
		modified: file2
		modified: file3
</code></pre> 
<p>若你需要进一步做更改，请立即进行，然后将新更改的内容添加到索引中。最后，用以下命令进行提交：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> commit
</code></pre> 
<p>这将再次提示你输入描述更改的信息。然后记录项目的新版本。<br> 或者，你可以使用以下命令，而无需预先运行 <code>git add</code></p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-a</span>
</code></pre> 
<p>它会自动关注任何修改过的（但非新的）文件，将它们添加到索引中，然后提交，所有这一切都在一步中完成。（顾名思义，<strong>它不会追踪到新文件，只会追踪更改过的老文件；若你有新建文件，则会被遗漏</strong>）<br> <img src="https://images2.imgbox.com/42/d3/H6T4SegX_o.png" alt="在这里插入图片描述"></p> 
<p>提交消息的注释：虽然不是必须的，但最好以一个简短的（不超过50个字符）行来总结更改，然后空一行，进行更全面的描述，以开始提交消息。<br> 提交消息中第一个空行之前的文本被视为提交标题，并且该标题在整个Git中使用。<br> 例如， <code>git-format-patch</code> 将提交转换为电子邮件，并使用主题行上的标题和正文中的提交的其余部分。</p> 
<h4><a id="223_Git_149"></a>2.2.3 Git追踪内容而非文件</h4> 
<p>许多版本控制系统提供了 <code>add</code> 命令，该命令会告诉系统开始跟踪新文件的更改。</p> 
<p>Git的 <code>add</code> 命令功能更单一且更强大：</p> 
<p><code>git add</code> 作用于新建文件和新更改的文件，这两种情况下，它都会拍摄/记录给定文件的快照并将内容暂存在索引中，准备好包含在下一次提交中。（即新建一个文件也能被追踪到，并非只记录老文件的修改）</p> 
<h4><a id="224__156"></a>2.2.4 查看项目历史</h4> 
<p>你可以随时使用以下命令查看更改的历史记录：</p> 
<pre><code class="prism language-shell">$ <span class="token function">git</span> log
</code></pre> 
<p>若你想要看每一步完整的差异，使用：</p> 
<pre><code class="prism language-shell">$ <span class="token function">git</span> log <span class="token parameter variable">-p</span>
</code></pre> 
<p>通常，每次更改的概述对了解每一步很有用：</p> 
<pre><code class="prism language-shell">$ <span class="token function">git</span> log <span class="token parameter variable">--stat</span> <span class="token parameter variable">--summary</span>
</code></pre> 
<h4><a id="225__170"></a>2.2.5 管理分支</h4> 
<p>单个Git仓库可以维护多个开发分支。<br> 使用以下命令可以创建一个名为 <em>experimental</em> 的新分支：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> branch experimental
</code></pre> 
<p>若你此时运行</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> branch
</code></pre> 
<p>你会得到一份表示现有的分支列表：</p> 
<pre><code class="prism language-bash">  experimental
* master
</code></pre> 
<p><em>experimental</em> 分支是你刚刚创建的分支， <em>master</em> 分支是默认分支。 <code>*</code> 标记了你当前所在的分支；输入：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> switch experimental
</code></pre> 
<p>以切换至 <em>experimental</em> 分支。现在编辑文件，提交更改，然后切换回主分支。</p> 
<pre><code class="prism language-bash"><span class="token punctuation">(</span>edit <span class="token function">file</span><span class="token punctuation">)</span>
$ <span class="token function">git</span> commit <span class="token parameter variable">-a</span>
$ <span class="token function">git</span> switch master
</code></pre> 
<p>检查你刚刚所做的更改是否不再可见，因为它是在 <em>experimental</em> 分支上进行的，且你现在回到了主分支上。</p> 
<blockquote> 
 <p><strong>题外话</strong><br> 以前用过部署在远端的git仓库，觉得切换分支后，内容发生变化是一件稀松平常的事。<br> 但这次在本地试验后，还是觉得很震撼，就在一个文件夹下，我敲一条切换分支的命令，这个文件夹下的文件就变了（惊叹的不是这样的功能实现，而是功能设计）。<br> <img src="https://images2.imgbox.com/d6/e0/cBwvW0xU_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>现在你可以在 <em>master</em> 分支上做一些不同的更改：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">(</span>edit <span class="token function">file</span><span class="token punctuation">)</span>
$ <span class="token function">git</span> commit <span class="token parameter variable">-a</span>
</code></pre> 
<p>此时，两个分支已经有所不同了，每个分支都做了不同的更改。若要合并 <em>experimental</em> 中的更改，请运行：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> merge experimental
</code></pre> 
<p>如果更改没有冲突，就合并完成。若存在冲突，则在有问题的文件中留下标记，以显示冲突。<br> <code>git diff</code> 会显示冲突内容。若你编辑文件，解决完了冲突。<br> 可用 <code>git commit -a</code> 提交合并结果。<br> 最后，用 <code>gitk</code> 会出现一个友好的图形界面来显示历史记录。<br> <img src="https://images2.imgbox.com/b5/3e/daRKqiMn_o.png" alt="在这里插入图片描述"><br> 此时，你可以使用以下命令来删除 <em>experimental</em> 分支：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-d</span> experimental
</code></pre> 
<p>该命令要确保 <em>experimental</em> 分支的更改已经完全在当前分支中了。<br> <img src="https://images2.imgbox.com/85/2f/fk24xBeu_o.png" alt="在这里插入图片描述"><br> 若你在一条名为 <em>crazy-idea</em> 的分支上开发了一阵子，但又不想要这条分支了，你也可以随时用以下命令删除分支：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-D</span> crazy-idea
</code></pre> 
<p>分支很容易获取到，所以在分支上开发新功能是尝试新事物的好方法（即fork新的分支，在新分支上开发功能，开发完毕后合并以扩展主分支）。</p> 
<h4><a id="226_Git_230"></a>🔺2.2.6 用Git来协同工作</h4> 
<p>假设 Alice 已在 <em>/home/alice/project</em> 中用Git仓库开启了一个新项目，且在同一台机器上的Bob也想给该项目贡献代码。</p> 
<p>Bob可以用以下命令：</p> 
<pre><code class="prism language-bash">bob$ <span class="token function">git</span> clone /home/alice/project myrepo
</code></pre> 
<p>这会创建一个新目录 <em>myrepo</em> ，其中包含 Alice仓库的一份克隆。克隆体与原始项目是平等的，拥有自己的原始项目历史记录副本（即Git也会对该克隆体管理，对更改做历史记录）。</p> 
<p>接着，Bob会做一些更改，并提交：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">(</span>edit files<span class="token punctuation">)</span>
bob$ <span class="token function">git</span> commit <span class="token parameter variable">-a</span>
<span class="token punctuation">(</span>repeat as necessary<span class="token punctuation">)</span>
</code></pre> 
<p>当他准备好后，他会告诉 Alice 从 <em>/home/bob/myrepo</em> 拉取（pull）仓库的更改。Alice 需要这样做：</p> 
<pre><code class="prism language-bash">alice$ <span class="token builtin class-name">cd</span> /home/alice/project
alice$ <span class="token function">git</span> pull /home/bob/myrepo master
</code></pre> 
<hr> 
<p>👆 basic<br> 这之前的内容应该属于常用且基础的，这之后的内容算是进阶。<br> 👇 advanced</p> 
<hr> 
<p>这样就将Bob <em>master</em> 分支的更改合并到 Alice的当前分支。若Alice在此期间也做了一些自己的变更，那么她可能需要手动解决冲突。（简单讲就是Alice和Bob都对某些文件做了更改，Alice合并Bob的分支后这部分代码就会冲突，就需要人工判断确定最终改动）。</p> 
<p>因此， <mark><em>pull</em> 命令执行了两个操作：从远程分支获取更改（fetch），然后将它们合并到当前分支中（merge）</mark>。</p> 
<p>一般来讲，Alice会在启动 <em>pull</em> 前，提交她的本地更改。<br> 但若在Bob克隆分支后，Bob的工作与Alice所做的内容冲突，Alice将使用她的 <strong>工作树</strong> 和索引来解决冲突，且已有的本地更改会干扰冲突解决过程（Git仍将执行获取，但会拒绝合并）——Alice将不得不以某种方式摆脱本地更改的干扰，并在该操作后再次 <em>pull</em> 。</p> 
<p>Alice可以使用 <em>fetch</em> 命令先窥视Bob所作的事情而不首先合并。这允许Alice使用特殊标记 <em>FETCH_HEAD</em> 检查Bob所做的事情，以确定Bob的分支上是否有值得拉取的东西，就像这样：</p> 
<pre><code class="prism language-bash">alice$ <span class="token function">git</span> fetch /home/bob/myrepo master
alice$ <span class="token function">git</span> log <span class="token parameter variable">-p</span> HEAD<span class="token punctuation">..</span>FETCH_HEAD
</code></pre> 
<blockquote> 
 <p><strong>HEAD</strong> 与 <strong>FETCH_HEAD</strong><br> <strong>1 HEAD</strong><br> 如果你和我一样，在这之前没有系统地学习过Git。<br> 那看到HEAD和FETCH_HEAD应该会很头疼，所以这里我对这两者做简单介绍。<br> HEAD是Git中非常重要的概念，你可以将它理解为指针或引用（就像C/C++中的指针一样，数据结构中的头指针），它可以指向任意一个节点，并且指向的节点始终为当前工作目录。换句话说，当前工作目录就是HEAD指向的节点，即它是对当前 Commit-ID 的引用。<br> 为了更好地理解HEAD及相关操作，再介绍一下什么情况下会影响HEAD。</p> 
 <ul><li>使用 <code>git commit</code> 时，HEAD会跟着移动，并指向当前分支的最新 Commit-ID。</li><li>使用 <code>git checkout</code> 时，HEAD会跟着移动，并指向对应分支的最新 Commit-ID。</li><li>使用 <code>git reset</code> 时，HEAD会跟着移动，并指向对应分支的指定 Commit-ID。</li></ul> 
 <p><br><strong>2 FETCH_HEAD</strong><br> FETCH_HEAD 是一个版本链接，记录在本地的一个文件中，指向目前已经从远程仓库取下来的分支的末端版本。<br> 而 <code>git fetch</code> 就会将远程仓库的最新版本获取到本地，但不会 <code>merge</code> 。</p> 
</blockquote> 
<p>即使Alice未提交本地更改，该操作也是安全的。范围标记 <em>HEAD…FETCH_HEAD</em> 意思是显示从 <em>FETCH_HEAD</em> 可达的所有内容，但排除可从 <em>HEAD</em> 到达的内容（前不达后达）。</p> 
<p>Alice已经知道导致她当前状态（ <em>HEAD</em> ）的所有内容，并使用该命令查看 Bob 在 Bob所在状态（即 <em>FETCH_HEAD</em> ）中她没有看到的内容。</p> 
<p>若Alice想可视化Bob在历史分叉后做了什么，可用以下命令：</p> 
<pre><code class="prism language-bash">$ gitk HEAD<span class="token punctuation">..</span>FETCH_HEAD
</code></pre> 
<p>这使用了我们之前在 <code>git log</code> 中看到的两点范围表示法。Alice可能想查看两人分支后都做了什么，她可以使用三点的形式来代替两点：</p> 
<pre><code class="prism language-bash">$ gitk HEAD<span class="token punctuation">..</span>.FETCH_HEAD
</code></pre> 
<p>这表示显示从任一者可访问的所有内容，但排除从两者均可访问的任何内容。</p> 
<p>注意，该范围标记法也可以用在 <code>gitk</code> 和 <code>git log</code> 中。</p> 
<p>在查看了 Bob 做了什么后，若没有紧急情况，Alice 也许会继续工作而不拉取 Bob的更改。若Bob的历史记录中确实有 Alice 立即需要的内容，那么Alice可以选择先藏匿/储备（stash）她正在进行的工作，进行一次 <em>pull</em> ，最后再将自己的工作内容在新产生的内容之上进行修改。</p> 
<p>当你在一个紧密联系的小团队中工作时，反复与同一个仓库进行交互很正常。通过给远程仓库定义简写（shorthand，缩略名），可以使其更简洁：</p> 
<pre><code class="prism language-bash">alice$ <span class="token function">git</span> remote <span class="token function">add</span> bob /home/bob/myrepo
</code></pre> 
<p>这样，Alice 可以使用 <code>git fetch</code> 命令单独执行 <code>pull</code> 操作的第一部分，而无需将它们与自己的分支合并：</p> 
<pre><code class="prism language-bash">alice$ <span class="token function">git</span> fetch bob
</code></pre> 
<p>与普通写法不同，当 Alice 使用 <code>git remote</code> 设置的远程仓库简写从 Bob 处获取时，获取的内容将存储在远程跟踪分支（remote-tracking branch）中，在本例中为 <em>bob/master</em> 。所以在这之后：</p> 
<pre><code class="prism language-bash">alice$ <span class="token function">git</span> log <span class="token parameter variable">-p</span> master <span class="token punctuation">..</span>bob/master
</code></pre> 
<p>显示 Bob 自 Alice 的 <em>master</em> 分支 fork 以来所作的所有更改的列表（显示bob/master可达的路径，排除master可达路径）。</p> 
<p>检查这些更改后， Alice 可以将这些更改合并到她的 <em>master</em> 分支中：</p> 
<pre><code class="prism language-bash">alice$ <span class="token function">git</span> merge bob/master
</code></pre> 
<p>该合并也可通过从她自己的远程跟踪分支中拉取来完成，就像这样：</p> 
<pre><code class="prism language-bash">alice$ <span class="token function">git</span> pull <span class="token builtin class-name">.</span> remotes/bob/master
</code></pre> 
<p>注意， <code>git pull</code> 总是合并到当前分支，无论命令行给出了什么。<br> 之后，Bob 可以使用 Alice 的最新更改来更新他的仓库：</p> 
<pre><code class="prism language-bash">bob$ <span class="token function">git</span> pull
</code></pre> 
<p>注意，他并不需要提供 Alice 仓库的路径；当 Bob 克隆 Alice 的存储库时， Git 将她的仓库位置存储在了仓库配置中，并且将该位置用于 pull 操作：</p> 
<pre><code class="prism language-bash">bob$ <span class="token function">git</span> config <span class="token parameter variable">--get</span> remote.origin.url
/home/alice/project
</code></pre> 
<p>（使用 <code>git config -l</code> 可以看到 <code>git clone</code> 创建的完整配置，<code>git config -l</code> 手册解释了每个选项的含义）</p> 
<p>Git还以 <em>origin/master</em> 名称保留了 Alice <em>master</em> 分支的原始副本：</p> 
<pre><code class="prism language-bash">bob$ <span class="token function">git</span> branch <span class="token parameter variable">-r</span>
	origin/master
</code></pre> 
<p>如果 Bob 后来决定在不同的主机上工作，他仍然可以使用 ssh 协议执行 clone 和 pull ：</p> 
<pre><code class="prism language-bash">bob$ <span class="token function">git</span> clone alice.org:/home/alice/project myrepo
</code></pre> 
<p>或者，Git 有本地协议，或者可以使用 http；详情参阅 <em>git-pull(1)</em> 。</p> 
<p>Git也可以在类似 CVS 的模式下使用，具有一个中央仓库，各个用户都可以将更改推送到其中。详情参阅 <em>git-push(1)</em> 和 <em>gitcvs-migration(7)</em> 。</p> 
<h4><a id="227__350"></a>2.2.7 查看历史</h4> 
<p>Git 的历史记录表现为一系列相关联的提交。我们已经看到 <code>git log</code> 可以列出这些提交。请注意，每个 <code>git log</code> 项的第一行还给出了提交的名称（那串长长的英文字符与数字的组合字串）：</p> 
<p><img src="https://images2.imgbox.com/16/01/FByjYBd1_o.png" alt="在这里插入图片描述"><br> 可以将该名称给到 <code>git show</code> 以显示该次提交的细节：<br> <img src="https://images2.imgbox.com/69/da/P34Cdt1r_o.png" alt="在这里插入图片描述"><br> 也有一些其他的方法引用提交。你可以使用名称的任何初始部分（得足够长）来唯一标识提交：</p> 
<p><img src="https://images2.imgbox.com/5c/77/pdVfeDeL_o.png" alt="在这里插入图片描述"><br> 通常，每个提交都会有一个 <em>父</em> 提交，它指向项目的前一个状态：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> show HEAD^ 	<span class="token comment"># 查看HEAD的父亲</span>
$ <span class="token function">git</span> show HEAD^^ 	<span class="token comment"># 查看HEAD的祖父</span>
$ <span class="token function">git</span> show HEAD~4	<span class="token comment"># 查看HEAD的曾曾祖父</span>
</code></pre> 
<p>注意，合并（merge）类型的提交可能会有多于一个的父亲：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> show HEAD^1 <span class="token comment"># 显示HEAD的第一个父亲（同HEAD^）</span>
$ <span class="token function">git</span> show HEAD^2 <span class="token comment"># 显示HEAD的第二个父亲</span>
</code></pre> 
<p>你也可以自己给提交命名：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> tag v2.5 709d387fbd12
</code></pre> 
<p>通过名称 v2.5 来引用 709d387fbd12 。若你打算与其他人共享此名称（例如，确认版本发布），你应该创建一个“标签，tag”对象，并对其进行签名。</p> 
<p>任何需要知道提交的Git命令都可以采用这些名称中的任何一个。例如：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> v2.5 HEAD 		<span class="token comment"># 比较当前HEAD 和 v2.5</span>
$ <span class="token function">git</span> branch stable v2.5 	<span class="token comment"># 基于v2.5开启一条名为stable分支</span>
$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> HEAD^ 	<span class="token comment"># 将当前分支和工作目录回滚至 HEAD^ 的状态</span>
</code></pre> 
<p>特别小心第三条命令：它除了会丢失工作目录的更改外，还会删除此分支中所有之后的提交（类似于回档）。若该分支是包含这些提交的唯一分支，那么它们将会丢失。另外，不要在其他开发人员从中 <code>pull</code> 的公开可见的分支上使用 <code>git reset</code>，因为这会迫使其他开发人员进行不必要的合并以清除历史。若你需要撤销已经推送（push）的更改，请用 <code>git revert</code> 。</p> 
<p><code>git grep</code> 命令可以在项目的任何版本中搜索字符串，因此：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> <span class="token function">grep</span> <span class="token string">"hello"</span> v2.5
</code></pre> 
<p>会搜索 v2.5 中所有出现的 “hello” 。<br> 若省略提交名称， <code>git grep</code> 将搜索它在当前目录中管理的任何文件。因此：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> <span class="token function">grep</span> <span class="token string">"hello"</span>
</code></pre> 
<p>是一种仅搜索Git跟踪的文件的快速方法。</p> 
<p>许多Git命令还接受提交集（即一次多个），可以通过多种方式来指定这些提交。以下是 <code>git log</code> 的一些示例：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> log v2.5<span class="token punctuation">..</span>v2.6		<span class="token comment"># v2.5和v2.6之间的提交，结合前面的HEAD..FETCH_HEAD来看</span>
							<span class="token comment"># 就很清晰，能看到v2.6的路径但排除v2.5的路径，所以就是它们之间的</span>
$ <span class="token function">git</span> log v2.5<span class="token punctuation">..</span>			<span class="token comment"># 自v2.5开始的提交</span>
$ <span class="token function">git</span> log <span class="token parameter variable">--since</span><span class="token operator">=</span><span class="token string">"2 weeks ago"</span>	<span class="token comment"># 过去的两周提交</span>
$ <span class="token function">git</span> log v2.5<span class="token punctuation">..</span> Makefile	<span class="token comment"># 自v2.5开始的 Makefile的提交</span>

</code></pre> 
<p>你也可以给 <code>git log</code> 一个提交的范围，在该范围中第一个参数不一定为第二个参数的祖先；例如，如果分支"stable" 和 “master” 的尖端从一个共同的提交中分离，那么：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> log stable<span class="token punctuation">..</span>master
</code></pre> 
<p>会列出 <em>master</em> 分支所做的提交，而没有 <em>stable</em> 分支做的提交。而：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> log master<span class="token punctuation">..</span>stable
</code></pre> 
<p>会列出 <em>stable</em> 分支所做的提交，而没有 <em>master</em> 分支的提交。</p> 
<p><code>git log</code> 命令有一个缺点：它必须以列表的形式呈现提交。当历史上有开发线分开，然后合并在一起时， <code>git log</code> 显示这些提交的顺序就没有意义了。</p> 
<p>大多数有多个贡献者的项目（如Linux内核或Git本身）都有频繁的合并，而gitk在可视化它们的历史记录方面做的更好。例如：</p> 
<pre><code class="prism language-bash">$ gitk <span class="token parameter variable">--since</span><span class="token operator">=</span><span class="token string">"2 weeks ago"</span> drivers/
</code></pre> 
<p>允许你浏览最近两周的修改了 <em>drivers</em> 目录下的文件提交。（注意：你可以通过按住control键同时按"-“或”+"来调整gitk的字体）</p> 
<p>最后，大多数接受文件名的命令允许你在任何文件名前添加一个提交，以指定文件的版本：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> v2.5:Makefile HEAD:Makefile.in
</code></pre> 
<p>你也可以使用 <code>git show</code> 来查看文件：</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> show v2.5:Makefile
</code></pre> 
<hr> 
<h2><a id="_433"></a>三、结尾</h2> 
<p>本文大部分是gittutorial中的内容，整文偏应用向。<br> 看完该教程，对于你项目的基本修订控制应该是足够了。<br> 然而，为了充分理解Git的深度与功能，本文还有p2，p2重点对对象数据库和索引文件做介绍（本文开头处也提到过，它们是git中简单而重要的思想）。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9899bbfab9e93b5cbf7a082724c6f0d2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Boot 自动配置功能介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ee84894a10611c9493efec17afbc2472/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STL——stack容器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>