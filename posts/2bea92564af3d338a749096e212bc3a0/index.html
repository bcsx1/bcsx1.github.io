<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MyBatis、Spring JDBC 和 Spring Data JPA：选择哪种持久化框架？ - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MyBatis、Spring JDBC 和 Spring Data JPA：选择哪种持久化框架？" />
<meta property="og:description" content="当涉及到选择 Java ORM 框架时，MyBatis、Spring JDBC 和 Spring Data JPA 是最常用的三个框架。以下是每个框架的一些关键特点：
MyBatis：它是一种半自动的 ORM 框架，通过 SQL 映射文件（XML 文件）将 Java 对象映射到关系型数据库中的表。它提供了强大的 SQL 映射功能和动态 SQL 语句生成，使开发人员可以更好地控制 SQL 语句的生成和执行。MyBatis 适合那些需要更高的 SQL 控制权和更多灵活性的项目。
Spring JDBC：它是 Spring 框架的一部分，提供了访问关系型数据库的简单和直接的方式。它不需要任何 ORM 映射或配置文件，通过使用 JdbcTemplate 类，开发人员可以轻松地编写类型安全的 SQL 语句和查询结果映射。Spring JDBC 适合那些需要更直接的 JDBC 访问并且不需要高级 ORM 功能的项目。
Spring Data JPA：它是 Spring Data 子项目的一部分，提供了 JPA 规范的实现。JPA 是 Java 持久化 API 的标准，可以让开发人员将 Java 对象映射到关系型数据库中的表，同时提供了高级 ORM 功能，如缓存和关系映射。Spring Data JPA 通过提供一些简单的接口和默认实现，极大地简化了 JPA 的使用，并提供了多种数据访问的方式。Spring Data JPA 适合那些需要高级 ORM 功能和开发效率的项目。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2bea92564af3d338a749096e212bc3a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-14T14:57:15+08:00" />
<meta property="article:modified_time" content="2023-04-14T14:57:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MyBatis、Spring JDBC 和 Spring Data JPA：选择哪种持久化框架？</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>当涉及到选择 Java ORM 框架时，MyBatis、Spring JDBC 和 Spring Data JPA 是最常用的三个框架。以下是每个框架的一些关键特点：</p> 
<ol><li> <p>MyBatis：它是一种半自动的 ORM 框架，通过 SQL 映射文件（XML 文件）将 Java 对象映射到关系型数据库中的表。它提供了强大的 SQL 映射功能和动态 SQL 语句生成，使开发人员可以更好地控制 SQL 语句的生成和执行。<strong>MyBatis 适合那些需要更高的 SQL 控制权和更多灵活性的项目。</strong></p> </li><li> <p>Spring JDBC：它是 Spring 框架的一部分，提供了访问关系型数据库的简单和直接的方式。它不需要任何 ORM 映射或配置文件，通过使用 JdbcTemplate 类，开发人员可以轻松地编写类型安全的 SQL 语句和查询结果映射。<strong>Spring JDBC 适合那些需要更直接的 JDBC 访问并且不需要高级 ORM 功能的项目。</strong></p> </li><li> <p>Spring Data JPA：它是 Spring Data 子项目的一部分，提供了 JPA 规范的实现。JPA 是 Java 持久化 API 的标准，可以让开发人员将 Java 对象映射到关系型数据库中的表，同时提供了高级 ORM 功能，如缓存和关系映射。Spring Data JPA 通过提供一些简单的接口和默认实现，极大地简化了 JPA 的使用，并提供了多种数据访问的方式。<strong>Spring Data JPA 适合那些需要高级 ORM 功能和开发效率的项目。</strong></p> </li></ol> 
<p>因此，选择 MyBatis、Spring JDBC 还是 Spring Data JPA 取决于项目的需求和开发团队的技术水平。需要根据项目的具体情况进行评估和选择。</p> 
<h2>一 、JdbcTemplate</h2> 
<p>Spring对数据库的操作在jdbc上面做了深层次的封装，使用spring的注入功能，可以把DataSource注册到JdbcTemplate之中。</p> 
<p>我们只需要在使用jdbcTemplate类中使用@Autowired进行注入即可：</p> 
<pre>@Autowired
private JdbcTemplate jdbcTemplate;</pre> 
<h4>1.JdbcTemplate主要提供方法：</h4> 
<p>1.1 execute方法</p> 
<p>execute方法可以用于执行任何SQL语句，一般用于执行DDL语句；</p> 
<pre> public String createTable(){
     String sql = "CREATE TABLE `user` (\n" +
         "  `id` int(11) NOT NULL AUTO_INCREMENT,\n" +
         "  `user_name` varchar(255) DEFAULT NULL,\n" +
         "  `pass_word` varchar(255) DEFAULT NULL,\n" +
         "  PRIMARY KEY (`id`)\n" +
         ") ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;\n" +
         "\n";
     jdbcTemplate.execute(sql);
     return "创建User表成功";
 }</pre> 
<p></p> 
<p>1.2 update方法</p> 
<p>update方法用于执行新增、修改、删除等语句；</p> 
<pre> public void addUser(User user) {
     String sql = "insert into user (username, password) values (?, ?)";
     jdbcTemplate.update(sql, user.getUsername(), user.getPassword());
 }</pre> 
<p></p> 
<p>如上，插入代码用的是update方法，其实增删改用的都是update方法，而查询则是和query相关的方法。</p> 
<pre>public void deleteUser( ) {
    String sql = "delete from user where username= ?";
    jdbcTemplate.update(sql, "小王");
}
​
public void updateUser(User user) {
    String sql = "update user set username=? where username= ?";
    jdbcTemplate.update(sql,  user.getUsername() + "_new", user.getUsername());
}
​
public void updateUser(User user) {
    String sql = "update user set username=? where username= ?";
    jdbcTemplate.update(sql,  user.getUsername() + "_new", user.getUsername());
}
​</pre> 
<p>1.3 batchUpdate方法</p> 
<p>batchUpdate方法用于执行批处理相关语句；</p> 
<pre>public void batchUpdate() {
    String sql="insert into user (name,deptid) values (?,?)";
    List&lt;Object[]&gt; batchArgs=new ArrayList&lt;Object[]&gt;();
    batchArgs.add(new Object[]{"caoyc",6});
    batchArgs.add(new Object[]{"zhh",8});
    batchArgs.add(new Object[]{"cjx",8});
    jdbcTemplate.batchUpdate(sql, batchArgs);
}</pre> 
<p>使用jdbcTempalte的batchUpdate方法，第二个参数传入接口BatchPreparedStatementSetter接口，该接口需要实现两个方法，getBatchSize()用于获得该批数量，setValues(PreapredStatement ps, int i)用于设置每个PreparedStatement</p> 
<pre> public Integer batchSaveWspc(List&lt;DataWspc&gt; wspcList) {
        String sql
            = "insert into db_sjzx.t_data_wspc(c_bh,c_ah,c_corp,c_bpcr,n_pcdf,dt_pcrq,dt_djsj) values(?,?,?,?,?,?,?)";
        jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps, int i) throws SQLException {
                ps.setString(1, UUIDHelper.getUuid());
                ps.setString(2, wspcList.get(i).getAh());
                ps.setString(3, wspcList.get(i).getCorp());
                ps.setString(4, wspcList.get(i).getBpcr());
                ps.setBigDecimal(5, wspcList.get(i).getPcdf());
                Date pcrq = wspcList.get(i).getPcrq();
                java.sql.Date pcrqVO = new java.sql.Date(pcrq.getTime());
                ps.setDate(6, pcrqVO);
                Date djsj = new Date();
                java.sql.Date djsjVO = new java.sql.Date(djsj.getTime());
                ps.setDate(7, djsjVO);
            }
        @Override
        public int getBatchSize() {
            return wspcList.size();
        }
    });
    return wspcList.size();
}</pre> 
<p>1.4 queryForXXX方法</p> 
<p>query方法及queryForXXX方法：用于执行查询相关语句；</p> 
<p>a. 查询表的记录数</p> 
<pre> @Test
 public void test1() {
     String sql = "select count(*) from user";
     Long row = jdbcTemplate.queryForObject(sql, Long.class);
     System.out.println("查询出来的记录数为：" + row);
 }</pre> 
<p>b. 查询返回对象</p> 
<pre>   @Test
   public void test2() {
       String sql = "select username, password from user where username = ?";
       Object[] object = {"mary_new"};
          User user = jdbcTemplate.queryForObject(sql, object,  new UserMapper());
      System.out.println(user);
  }</pre> 
<p>除此之外要实现结构RowMapper来新建一个映射类：</p> 
<pre>public class UserMapper implements RowMapper&lt;User&gt;{
 
     @Override
     public User mapRow(ResultSet resultSet, int rows) throws SQLException {
         User user = new User();
         user.setUsername(resultSet.getString(1));
         user.setPassword(resultSet.getString(2));
         return user;
     }
 }</pre> 
<p>要注意这个UserMapper.java应该要和具体的Sql语句对应。</p> 
<p>c. 查询并返回List集合</p> 
<pre>@Test
public void test3() {
    String sql = "select * from user";
    List&lt;User&gt; users = jdbcTemplate.query(sql, new UserMapper());
    for(User u: users) {
        System.out.println(u);
    }
}</pre> 
<p>c. 查询并返回Map集合</p> 
<pre>public CollectResult collect(CollectParam param) {
        Object[] objects = new Object[] {param.getKpdx(), param.getKpjh().getKsrq(), param.getKpjh().getJsrq()};
        Map&lt;String, Object&gt; countMap
            = jdbcTemplate.queryForMap(CorpTableRouter.genSql(tsgkSpzJasSql.toString(), param.getKpjh().getCorp()), objects);
        List&lt;Map&lt;String, Object&gt;&gt; dataList
            = jdbcTemplate.queryForList(CorpTableRouter.genSql(tsgkSpzSql.toString(), param.getKpjh().getCorp()), objects);
        return tsgkCollectorDate.tsgkDateDetail(countMap, dataList, collectorUtil.getJczbName(param.getJszb().getValue()));
    }</pre> 
<p>··</p> 
<p>对于spring的JdbcTemplate进行结果集查询操作，spring给我们开发的是一系列的query方法，这些查询的方法中回调的接口主有三种：ResultSetExtractor，RowCallbackHandler，RowMapper，这个内容有图有真相：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/06/e2/rxsApc9q_o.jpg"></p> 
<p><a href="https://dzllikelsw-163-com.iteye.com/blog/2038248" rel="nofollow" title="使用spring的JdbcTemplate进行查询的三种回调方式的比较 -  - ITeye博客">使用spring的JdbcTemplate进行查询的三种回调方式的比较 - - ITeye博客</a></p> 
<p></p> 
<h2>二、Mybatis</h2> 
<h3>1.Mybatis介绍</h3> 
<p>MyBatis 是一个基于Java的持久层框架。它提供的持久层框架包括SQL Maps和Data Access Objects（DAO）。</p> 
<p>MyBatis是一个支持<strong>普通SQL查询</strong>，<strong>存储过程</strong>和<strong>高级映射</strong>的优秀<strong>持久层框架</strong>。MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的<strong>XML或注解</strong>用于配置和原始映射，将接口和 Java 的POJO（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录</p> 
<p>每个MyBatis应用程序主要都是使用<strong>SqlSessionFactory</strong>实例的，一个SqlSessionFactory实例可以通过SqlSessionFactoryBuilder获得。SqlSessionFactoryBuilder从一个xml配置文件或者一个预定义的配置类的实例获得配置信息。</p> 
<p>Mybatis核心类：</p> 
<pre> SqlSessionFactory：每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或通过Java的方式构建出 SqlSessionFactory 的实例。SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，建议使用单例模式或者静态单例模式。一个SqlSessionFactory对应配置文件中的一个环境（environment），如果你要使用多个数据库就配置多个环境分别对应一个SqlSessionFactory。

SqlSession：SqlSession是一个接口，它有2个实现类，分别是DefaultSqlSession(默认使用)以及SqlSessionManager。SqlSession通过内部存放的执行器（Executor）来对数据进行CRUD。此外SqlSession不是线程安全的，因为每一次操作完数据库后都要调用close对其进行关闭，官方建议通过try-finally来保证总是关闭SqlSession。

Executor：Executor（执行器）接口有两个实现类，其中BaseExecutor有三个继承类分别是BatchExecutor（重用语句并执行批量更新），ReuseExecutor（重用预处理语句prepared statements），SimpleExecutor（普通的执行器）。以上三个就是主要的Executor。通过下图可以看到Mybatis在Executor的设计上面使用了装饰者模式，我们可以用CachingExecutor来装饰前面的三个执行器目的就是用来实现缓存。

MappedStatement：MappedStatement就是用来存放我们SQL映射文件中的信息包括sql语句，输入参数，输出参数等等。一个SQL节点对应一个MappedStatement对象。</pre> 
<p>　<strong>原理图如下：</strong></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8d/91/U08ra3Iq_o.png"></p> 
<h3>2.mybatis配置文件</h3> 
<h4>configuration.xml</h4> 
<p>创建mybatis的配置文件，配置数据库的信息.</p> 
<p>可以配置多个运行环境，但是每个SqlSessionFactory 实例只能选择一个运行环境</p> 
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;

&lt;configuration&gt;
	
	
	&lt;!-- 加载类路径下的属性文件 --&gt;
	&lt;properties resource="db.properties"/&gt;
	&lt;!-- 设置一个默认的连接环境信息 --&gt;
	&lt;environments default="mysql_developer"&gt;
		&lt;!-- 连接环境信息，取一个任意唯一的名字 --&gt;
		&lt;environment id="mysql_developer"&gt;
			&lt;!-- mybatis使用jdbc事务管理方式 --&gt;
			&lt;transactionManager type="jdbc"/&gt;
			&lt;!-- mybatis使用连接池方式来获取连接 --&gt;
			&lt;dataSource type="pooled"&gt;
				&lt;!-- 配置与数据库交互的4个必要属性 --&gt;
				&lt;property name="driver" value="${mysql.driver}"/&gt;
				&lt;property name="url" value="${mysql.url}"/&gt;
				&lt;property name="username" value="${mysql.username}"/&gt;
				&lt;property name="password" value="${mysql.password}"/&gt;
			&lt;/dataSource&gt;
		&lt;/environment&gt;
		
		
		&lt;!-- 连接环境信息，取一个任意唯一的名字 --&gt;
		&lt;environment id="oracle_developer"&gt;
			&lt;!-- mybatis使用jdbc事务管理方式 --&gt;
			&lt;transactionManager type="jdbc"/&gt;
			&lt;!-- mybatis使用连接池方式来获取连接 --&gt;
			&lt;dataSource type="pooled"&gt;
				&lt;!-- 配置与数据库交互的4个必要属性 --&gt;
				&lt;property name="driver" value="${oracle.driver}"/&gt;
				&lt;property name="url" value="${oracle.url}"/&gt;
				&lt;property name="username" value="${oracle.username}"/&gt;
				&lt;property name="password" value="${oracle.password}"/&gt;
			&lt;/dataSource&gt;
		&lt;/environment&gt;
	&lt;/environments&gt;
    
	&lt;mappers&gt;
        &lt;mapper resource="com/zhao/mapper/UserMapper.xml"/&gt;
    &lt;/mappers&gt;
	
&lt;/configuration&gt;</pre> 
<p>properties（属性）</p> 
<ul><li> <p>将数据库连接的参数单独配置在，db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值。在SqlMapConfig.xml中就不需要对数据库连接参数硬编码。</p> </li></ul> 
<p>settings（全局配置参数）</p> 
<ul><li> <p>mybatis框架在运行时可以调整一些运行参数。比如：开启二级缓存、开启延迟加载。全局参数将会影响mybatis的运行行为。</p> <p><img alt="img" src="https://images2.imgbox.com/72/6d/jFiS0N3g_o.png"></p> </li></ul> 
<p>typeAliases（类型别名）</p> 
<ul><li> <p>单个定义 <img alt="这里写图片描述" src="https://images2.imgbox.com/2d/93/Eo9behNI_o.png"></p> </li><li> <p>批量定义 <img alt="这里写图片描述" src="https://images2.imgbox.com/68/c3/2nlhuIul_o.png"></p> </li><li> <p>mybatis默认支持的别名</p> <p><img alt="img" src="https://images2.imgbox.com/5f/3b/o2wyscD0_o.png"></p> </li><li> <p>environments（环境集合属性对象）</p> 
  <ul><li> <p>environment（环境子属性对象）</p> 
    <ul><li> <p>transactionManager（事务管理）</p> </li><li> <p>dataSource（数据源）</p> </li></ul></li></ul></li><li> <p>mappers（映射器）</p> 
  <ul><li> <p>通过resource <img alt="这里写图片描述" src="https://images2.imgbox.com/81/0e/MLq19W8w_o.png"></p> </li><li> <p>通过class <img alt="这里写图片描述" src="https://images2.imgbox.com/19/e2/MtlIFQYA_o.png"></p> </li><li> <p>通过package(推荐使用) <img alt="这里写图片描述" src="https://images2.imgbox.com/65/2b/rYIQWLiS_o.png"></p> </li></ul></li></ul> 
<h4>XXXXMapper.xml</h4> 
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "mybatis-3-mapper.dtd" &gt;
&lt;mapper namespace="com.zhao.mapper.UsertMapper"&gt;
  
     &lt;!--
        添加用户
        parameterType:指定参数类型为pojo类型
        #{}中指定pojo的属性名，接收到的pojo对象的属性值，mybatis通过OGNL获取对象的值
        SELECT LAST_INSERT_ID():得到刚刚insert进去的记录的主键值，只适用于主键自增
        非主键自的则需要使用uuid()来实现,表的id类型也得设置为tring(详见下面的注释)
        keyProperty：将查询到的主键值设置到SparameterType指定的对象的哪个属性
        order:SELECT LAST_INSERT_ID()执行顺序，相当于insert语句来说它的实现顺序
    --&gt;
    &lt;insert id="insertUser" parameterType="com.nuc.mybatis.po.User"&gt;
      &lt;selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer"&gt;
          SELECT LAST_INSERT_ID()
      &lt;/selectKey&gt;
      insert into user (username,birthday,sex,address) value(#{username},#{birthday},#{sex},#{address})
    &lt;/insert&gt;
    
    &lt;delete id="deleteUser" parameterType="java.lang.Integer"&gt;
        delete from user where id=#{id}
    &lt;/delete&gt;

    &lt;update id="updateUser" parameterType="com.nuc.mybatis.po.User"&gt;
        UPDATE user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address} where id=#{id}
    &lt;/update&gt;
    
        &lt;/select&gt;
    &lt;select id="findUserByName" parameterType="java.lang.String" resultType="com.nuc.mybatis.po.User"&gt;
        select * from user WHERE username LIKE '%${value}%'
    &lt;/select&gt;
    
&lt;/mapper&gt;</pre> 
<p>这个是个简单的插入过程，我们的parameterType是个全路径com.zhao.entity.User，如果每个都写这么全的话 会很麻烦，所以我们可以配置它的别名，当然，别名要配置在configuration.xml中</p> 
<pre>    &lt;typeAliases&gt;
        &lt;typeAlias type="com.zhao.entity.User" alias="User"/&gt;
    &lt;/typeAliases&gt;</pre> 
<p></p> 
<h3>3.mapper开发</h3> 
<h4>mapper开发只需要遵守几个规范即可</h4> 
<ul><li> <p>在mapper.xml中namespace等于mapper接口地址</p> </li><li> <p>mapper.java接口中的方法名和mapper.xml中statement的id一致</p> </li><li> <p>mapper.java接口中的方法输入参数类型和mapper.xml中statement的<strong>parameterType</strong>指定的类型一致。</p> </li><li> <p>mapper.java接口中的方法返回值类型和mapper.xml中statement的<strong>resultType</strong>指定的类型一致。</p> </li></ul> 
<h4>mapper开发xml中的标签介绍</h4> 
<ul><li> <p><strong>parameterType</strong></p> <p>sql语句中需要传入的参数， 类型要与对应的接口方法的类型一致</p> </li><li> <p><strong>resultType</strong></p> <p>使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。</p> </li><li> <p><strong>resultMap</strong></p> <p>mybatis中使用resultMap完成高级输出结果映射。</p> <pre> &lt;resultMap type="Student" id="result"&gt;
     &lt;id column="stu_id" property="id"/&gt;
     &lt;result column="stu_name" property="name"/&gt;&lt;result column="stu_password" 		   property="password"/&gt;
&lt;/resultMap&gt;`</pre> <p></p> </li></ul> 
<p>使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。</p> 
<ul><li> <p><strong>动态sql：if choose trim foreach</strong></p> <p>MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其他类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句有多么痛苦。拼接的时候要确保不能忘了必要的空格，还要注意省掉列名列表最后的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。</p> <p>通常使用动态 SQL 不可能是独立的一部分,MyBatis 当然使用一种强大的动态 SQL 语言来改进这种情形,这种语言可以被用在任意的 SQL 映射语句中。</p> <p>动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处理器相似。在 MyBatis 之前的版本中,有很多的元素需要来了解。MyBatis 3 大大提升了它们,现在用不到原先一半的元素就可以了。MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。</p> 
  <ul><li> <p>if ： test表达式、OGNL：特殊符号写转移字符 where</p> </li><li> <p>choose (when, otherwise) ： choose：&lt;where&gt;标签中，when、otherwise</p> 
    <ul><li> <p>trim (where, set) ：trim：整个，prefix、prefixOverrides1 2前缀覆盖、suffix、suffixOverrides</p> </li></ul></li><li> <p>foreach：foreach：collection、item、separator、open、close、index (遍历list时index是索引，item是当前值；遍历map时index是map的key，item是map的值）</p> </li></ul></li></ul> 
<pre>&lt;select id="findUserInfoByOneParam" parameterType="Map" resultMap="UserInfoResult"&gt;
		select * from userinfo 
		&lt;choose&gt;
			&lt;when test="searchBy=='department'"&gt;
				where department=#{department}
			&lt;/when&gt;
			&lt;when test="searchBy=='position'"&gt;
				where position=#{position}
			&lt;/when&gt;
			&lt;otherwise&gt;
				where gender=#{gender}
			&lt;/otherwise&gt;
		&lt;/choose&gt;
		&lt;if test="d != null and d.id != null"&gt;
    		AND department = #{d.id}
  		&lt;/if&gt;
	&lt;/select&gt;

&lt;delete id="deleteByPriKeys" parameterType="java.lang.String"&gt;  
     delete from product where product_Id in  
     &lt;foreach collection="list" item="productId" open="(" separator="," close=")"&gt;  
         #{productId,jdbcType = VARCHAR}  
     &lt;/foreach&gt;  
 &lt;/delete&gt;  </pre> 
<h4>高级结果集映射</h4> 
<p>eg：查询订单信息，关联查询创建订单的用户信息</p> 
<p>实现思路：使用resultMap将查询结果中的订单信息映射到Orders对象中，在orders类中添加User属性，将关联查询出来的用户信息映射到orders对象中的user属性中。 第一步：Orders类中添加User 的user属性。上面的代码已经添加 第二步：mapper.xml中定义ResultMap及其查询 第三步：接口中定义相应的方法</p> 
<pre>&lt;resultMap type="com.nuc.mybatis.po.Orders" id="OrdersUserResultMap"&gt;

        &lt;id column="id" property="id"/&gt;
        &lt;result column="user_id" property="userId"/&gt;
        &lt;result column="number" property="number"/&gt;
        &lt;result column="createtime" property="createtime"/&gt;
        &lt;result column="note" property="note"/&gt;
    
        &lt;association property="user"  javaType="com.nuc.mybatis.po.User"&gt;
            
            &lt;id column="user_id" property="id"/&gt;
            &lt;result column="username" property="username"/&gt;
            &lt;result column="sex" property="sex"/&gt;
            
            &lt;result column="address" property="address"/&gt;
        &lt;/association&gt;

 &lt;/resultMap&gt;</pre> 
<pre>&lt;!-- 查询订单关联查询用户信息，使用resultmap --&gt;
    &lt;select id="findOrdersUserResultMap" resultMap="OrdersUserResultMap"&gt;
        SELECT
        orders.*,
        USER.username,
        USER.sex,
        USER.address
        FROM
        orders,
        USER
        WHERE orders.user_id = user.id
   &lt;/select&gt;</pre> 
<p></p> 
<ul><li> <p>resultMap： 使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。</p> 
  <ul><li> <p>association： 作用：将关联查询信息映射到一个pojo对象中。 场合：为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中。</p> </li><li> <p>collection： 作用：将关联查询信息映射到一个list集合中。</p> <p>场合：为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，</p> </li></ul></li></ul> 
<h3>Mybatis延迟加载</h3> 
<p>resultMap可以实现高级映射（使用association、collection实现一对一及一对多映射），association、collection具备延迟加载功能。</p> 
<ol><li> <p>Mybatis的延迟加载功能默认是关闭的</p> </li><li> <p>需要在SqlMapConfig.xml文件中通过setting标签配置来开启延迟加载功能</p> </li><li> <p>开启延迟加载的属性： lazyLoadingEnabled：全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载。默认为false aggressiveLazyLoading：当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。默认为true</p> </li><li> <p>配置</p> <pre> &lt;settings&gt;
     &lt;!--开启延迟加载--&gt;
     &lt;setting name="lazyLoadingEnabled" value="true"/&gt;
     &lt;!--关闭积极加载--&gt;
     &lt;setting name="aggressiveLazyLoading" value="false"/&gt;
 &lt;/settings&gt;</pre> </li></ol> 
<h3>4.Mybatis查询缓存</h3> 
<p>mybatis提供查询缓存，用于减轻数据压力，提高数据库性能。如果缓存中有数据就不用从数据库中获取，大大提高系统性能。mybaits提供一级缓存，和二级缓存。</p> 
<ul><li> <p>一级缓存</p> <p>一级缓存是SqlSession级别的缓存。在操作数据库时需要构造 sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。</p> <p>如果是执行两个service调用查询相同 的用户信息，不走一级缓存，因为session方法结束，sqlSession就关闭，一级缓存就清空。</p> </li><li> <p>二级缓存</p> <p>二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</p> <p></p> </li></ul> 
<h3>5. 注解开发</h3> 
<p>MyBatis的注解，主要是用于替换映射文件。而映射文件中无非存放着增删改查的sql映射标签。所以，MyBatis注解，就是替换映射文件中的sql标签。</p> 
<h4>常用CRUD注解开发</h4> 
<p>@Insert ： 插入sql , 和xml insert sql语法完全一样</p> 
<p>@SelectKey：用于替换xml中的&lt;selectKey/&gt;标签，用于返回新插入数据的id值。</p> 
<p>@Select ： 查询sql, 和xml select sql语法完全一样</p> 
<ul><li> <p>statement:获取新插入记录主键值得sql语句</p> </li><li> <p>keyProperty:获取的该主键值返回后初始化对象的那个属性</p> </li><li> <p>resultType:返回值类型</p> </li><li> <p>before:指定主键的生成相对于insert语句的执行先后顺序，该属性不能省略</p> </li></ul> 
<p>@Update ： 更新sql, 和xml update sql语法完全一样</p> 
<p>@Delete ： 删除sql, 和xml delete sql语法完全一样</p> 
<p>@Param ： 入参</p> 
<p>@Results ： 结果集合</p> 
<p>@Result ： 结果</p> 
<pre>public interface IStudentDao {
    @Insert(value={"insert into student(name,age,score) values(#{name},#{age},#{score})"})
    void insertStudent(Student student);    
    
    @Insert("insert into student(name,age,score) values(#{name},#{age},#{score})")
    @SelectKey(statement="select @@identity",resultType=int.class,keyProperty="id",before=false)
    void insertStudentCacheId(Student student);
    
    @Delete(value="delete from student where id=#{id}")
    void deleteStudentById(int id);
    
    @Update("update student set name=#{name},age=#{age},score=#{score} where id=#{id}")
    void updateStudent(Student student);
    
    @Select("select * from student")
    List&lt;Student&gt; selectAllStudents();
    
    @Select("select * from student where id=#{id}")
    Student selectStudentById(int id);
    
    @Select("select * from student where name like '%' #{name} '%'")
    List&lt;Student&gt; selectStudentsByName(String name);
    
}</pre> 
<h4>动态sql</h4> 
<ul><li> <p>脚本sql</p> <p>XML配置方式的动态SQL在上面的xml方式开发中有体现，下面是用&lt;script&gt;的方式把它照搬过来，用注解来实现。适用于xml配置转换到注解配置</p> <pre>@Select("&lt;script&gt;select * from user &lt;if test=\"id !=null \"&gt;where id = #{id} &lt;/if&gt;&lt;/script&gt;")    
public List&lt;User&gt; findUserById(User user);  </pre> <p>很明显，在java中写xml可读性和维护性太差，尤其当SQL很长时，这样写是很痛苦的。</p> </li><li> <p>在方法中构建sql</p> <p>接口中是不能写实现的，所以这里借用内部类来生成动态SQL。增改删也有对应的@InsertProvider、@UpdateProvider、@DeleteProvider，下面是@SelectProvider的使用实例：</p> </li></ul> 
<pre> /**
     * 
     * AjMapper
     * 
     * @description 查询案件信息
     * @param column 法标
     * @param table 表名
     * @return List&lt;Map&lt;String, Object&gt;&gt;
     * @author pujihong
     * @date 2019年3月18日 下午5:11:54
     */
    @SelectProvider(type = AjProvider.class, method = "queryAjList")
    List&lt;ZbAj&gt; getAjList(@Param("column") String column, @Param("table") String table);</pre> 
<pre>/**
     * 
     * AjProvider
     * 
     * @description 指标案件查询
     * @param map 查询信息
     * @return String
     * @author pujihong
     * @date 2019年3月22日 上午10:32:44
     */
    public String queryAjList(Map&lt;String, Object&gt; map) {
        StringBuilder sqlSelect = new StringBuilder();
        String table = (String)map.get("table");
        String column = (String)map.get("column");
        sqlSelect
            .append(
                "select n_ajbs as ajbh,c_ah as ah,c_cbr as cbr,c_cbspt as ts,to_char(d_larq, 'YYYY-MM-DD') as larq,")
            .append("to_char(d_jarq, 'YYYY-MM-DD') as jarq,n_sfxg as sfxg,")
            .append(CorpTableRouter.genSql("#{corp} AS zb ", column))
            .append(CorpTableRouter.genSql("from db_sjzx.#{corp}", table));
        return sqlSelect.toString();
    }</pre> 
<p>这比&lt;script&gt;更加清晰，适用于查询语句不是很长、条件不多的场景，SQL很直观。但是在写很长的SQL时，这样拼接SQL同样会很痛苦</p> 
<ul><li> <p>结构化SQL</p> </li></ul> 
<pre>public String findUserById(User user) {      
    return new SQL(){<!-- -->{      
        SELECT("id,name");      
        SELECT("other");      
        FROM("user");      
        if(user.getId()!=null){      
            WHERE("id = #{id}");      
        }      
        if(user.getName()!=null){      
            WHERE("name = #{name}");      
        }        
    }}.toString();      
} </pre> 
<p>这是把前面的内部类改造一下</p> 
<p>SELECT：表示要查询的字段，如果一行写不完，可以在第二行再写一个SELECT，这两个SELECT会智能的进行合并而不会重复</p> 
<p>FROM和WHERE：跟SELECT一样，可以写多个参数，也可以在多行重复使用，最终会智能合并而不会报错</p> 
<p>这样语句适用于写很长的SQL时，能够保证SQL结构清楚。便于维护，可读性高。但是这种自动生成的SQL和HIBERNATE一样，在实现一些复杂语句的SQL时会束手无策。所以需要根据现实场景，来考虑使用哪一种动态SQL</p> 
<p>上面的例子只是最基本的用法：更多详细用法，可以参考mybatis中文网的专门介绍</p> 
<p><a href="http://www.mybatis.org/mybatis-3/zh/statement-builders.html" rel="nofollow" title="mybatis – MyBatis 3 | SQL 语句构建器">mybatis – MyBatis 3 | SQL 语句构建器</a></p> 
<h4>高级映射结果集一对多</h4> 
<p>结果集映射例子：</p> 
<pre>@Select("select c_bh as bh, c_table as table,c_column as column, c_name as name,c_codetype as codetype  from db_sjzx.t_sync_config")
    @Results(
        {@Result(property = "codes", column = "codetype", id = true, many = @Many(select = "queryCode"，fetchType=FetchType.LAZY))}
    )
    List&lt;SyncConfig&gt; querySyn();

@Select("select c_pid as codeType,c_code as code,c_name as name from db_aty.t_aty_code where c_pid = #{codetype}")
    List&lt;Code&gt; queryCode(@Param("codetype") String codetype);</pre> 
<p>FetchType.LAZY：懒加载，加载一个实体时，定义懒加载的属性不会马上从数据库中加载。 FetchType.EAGER：急加载，加载一个实体时，定义急加载的属性会立即从数据库中加载。</p> 
<p><a href="https://blog.csdn.net/caoxuekun/article/details/76944001" title="mybatis笔记-5-注解（一对一，一对多，多对多）_mybatis注解时1对多不显示多的数据_caoxuekun的博客-CSDN博客">mybatis笔记-5-注解（一对一，一对多，多对多）_mybatis注解时1对多不显示多的数据_caoxuekun的博客-CSDN博客</a></p> 
<p></p> 
<h2>三、Spring Data Jpa</h2> 
<h3>1.简介</h3> 
<ul><li> <p><strong>jap</strong></p> <p>JPA<code>(</code>Java Persistence API<code>)意即Java持久化API，是Sun官方在JDK5.0后提出的Java持久化规范（JSR 338，这些接口所在包为</code>javax.persistence`，详细内容可参考<a href="https://github.com/javaee/jpa-spec" title="GitHub - javaee/jpa-spec">GitHub - javaee/jpa-spec</a>）</p> <p>JPA的出现主要是为了简化持久层开发以及整合ORM技术，结束Hibernate、TopLink、JDO等ORM框架各自为营的局面。JPA是在吸收现有ORM框架的基础上发展而来，易于使用，伸缩性强。总的来说，JPA包括以下3方面的技术：</p> 
  <ul><li> <p><strong>ORM映射元数据</strong>： 支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系</p> </li><li> <p><strong>API</strong>： 操作实体对象来执行CRUD操作</p> </li><li> <p><strong>查询语言</strong>- ： 通过面向对象而非面向数据库的查询语言（<code>JPQL</code>）查询数据，避免程序的SQL语句紧密耦合</p> </li></ul></li><li> <p><strong>Spring Data Jpa</strong></p> <p>Spring Data JPA是Spring Data家族的一部分，可以轻松实现基于JPA的存储库。 此模块处理对基于JPA的数据访问层的增强支持。 它使构建使用数据访问技术的Spring驱动应用程序变得更加容易。</p> <p>Spring Data JPA旨在通过减少实际需要的工作量来显著改善数据访-问层的实现。 作为开发人员，您编写repository接口，包括自定义查找器方法，Spring将自动提供实现。</p> <p class="img-center"><img alt="" src="https://images2.imgbox.com/33/58/QDrjac4p_o.png"></p> <p>Spring Data生态</p> </li></ul> 
<h3>2. 在Spring Boot 的相关配置</h3> 
<pre>server:
  port: 8080
  servlet:
    context-path: /
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=false
    username: root
    password: mysql123
  jpa:
    database: MySQL
    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect
    show-sql: true
    hibernate:
      ddl-auto: update</pre> 
<blockquote> 
 <p>ddl-auto</p> 
</blockquote> 
<ul><li> <p><code>create</code>：每次运行程序时，都会重新创建表，故而数据会丢失</p> </li><li> <p><code>create-drop</code>：每次运行程序时会先创建表结构，然后待程序结束时清空表</p> </li><li> <p><code>upadte</code>：每次运行程序，没有表时会创建表，如果对象发生改变会更新表结构，原有数据不会清空，只会更新（推荐使用）</p> </li><li> <p><code>validate</code>：运行程序会校验数据与数据库的字段类型是否相同，字段不同会报错</p> </li><li> <p><code>none</code>: 禁用DDL处理</p> </li></ul> 
<h3>3.Spring Data Jpa<strong>使用</strong></h3> 
<p>基本查询也分为两种，一种是 Spring Data 默认已经实现，一种是根据查询的方法来自动解析成 SQL。</p> 
<h4>预先生成方法</h4> 
<p>Spring Boot Jpa 默认预先生成了一些基本的CURD的方法，例如：增、删、改等等</p> 
<p>1 继承 JpaRepository</p> 
<pre>public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
}</pre> 
<p>2 使用默认方法</p> 
<pre>@Test
public void testBaseQuery() throws Exception {
    User user=new User();
    userRepository.findAll();
    userRepository.findOne(1l);
    userRepository.save(user);
    userRepository.delete(user);
    userRepository.count();
    userRepository.exists(1l);
    // ...
}</pre> 
<h4>自定义简单查询</h4> 
<p>自定义的简单查询就是根据方法名来自动生成 SQL，主要的语法是<code>findXXBy</code>,<code>readAXXBy</code>,<code>queryXXBy</code>,<code>countXXBy</code>, <code>getXXBy</code>后面跟属性名称：</p> 
<pre>User findByUserName(String userName);</pre> 
<p>也使用一些加一些关键字<code>And</code>、 <code>Or</code></p> 
<pre>User findByUserNameOrEmail(String username, String email);</pre> 
<p>修改、删除、统计也是类似语法</p> 
<pre>Long deleteById(Long id);
Long countByUserName(String userName)</pre> 
<p>基本上 SQL 体系中的关键词都可以使用，例如：<code>LIKE</code>、 <code>IgnoreCase</code>、 <code>OrderBy</code>。</p> 
<pre>List&lt;User&gt; findByEmailLike(String email);
User findByUserNameIgnoreCase(String userName);
List&lt;User&gt; findByUserNameOrderByEmailDesc(String email);</pre> 
<p><strong>具体的关键字，使用方法和生产成SQL如下表所示</strong></p> 
<table><thead><tr><th>Keyword</th><th>Sample</th><th>JPQL snippet</th></tr></thead><tbody><tr><td>And</td><td>findByLastnameAndFirstname</td><td>… where x.lastname = ?1 and x.firstname = ?2</td></tr><tr><td>Or</td><td>findByLastnameOrFirstname</td><td>… where x.lastname = ?1 or x.firstname = ?2</td></tr><tr><td>Is,Equals</td><td>findByFirstnameIs,findByFirstnameEquals</td><td>… where x.firstname = ?1</td></tr><tr><td>Between</td><td>findByStartDateBetween</td><td>… where x.startDate between ?1 and ?2</td></tr><tr><td>LessThan</td><td>findByAgeLessThan</td><td>… where x.age &lt; ?1</td></tr><tr><td>LessThanEqual</td><td>findByAgeLessThanEqual</td><td>… where x.age ⇐ ?1</td></tr><tr><td>GreaterThan</td><td>findByAgeGreaterThan</td><td>… where x.age &gt; ?1</td></tr><tr><td>GreaterThanEqual</td><td>findByAgeGreaterThanEqual</td><td>… where x.age &gt;= ?1</td></tr><tr><td>After</td><td>findByStartDateAfter</td><td>… where x.startDate &gt; ?1</td></tr><tr><td>Before</td><td>findByStartDateBefore</td><td>… where x.startDate &lt; ?1</td></tr><tr><td>IsNull</td><td>findByAgeIsNull</td><td>… where x.age is null</td></tr><tr><td>IsNotNull,NotNull</td><td>findByAge(Is)NotNull</td><td>… where x.age not null</td></tr><tr><td>Like</td><td>findByFirstnameLike</td><td>… where x.firstname like ?1</td></tr><tr><td>NotLike</td><td>findByFirstnameNotLike</td><td>… where x.firstname not like ?1</td></tr><tr><td>StartingWith</td><td>findByFirstnameStartingWith</td><td>… where x.firstname like ?1 (parameter bound with appended %)</td></tr><tr><td>EndingWith</td><td>findByFirstnameEndingWith</td><td>… where x.firstname like ?1 (parameter bound with prepended %)</td></tr><tr><td>Containing</td><td>findByFirstnameContaining</td><td>… where x.firstname like ?1 (parameter bound wrapped in %)</td></tr><tr><td>OrderBy</td><td>findByAgeOrderByLastnameDesc</td><td>… where x.age = ?1 order by x.lastname desc</td></tr><tr><td>Not</td><td>findByLastnameNot</td><td>… where x.lastname &lt;&gt; ?1</td></tr><tr><td>In</td><td>findByAgeIn(Collection ages)</td><td>… where x.age in ?1</td></tr><tr><td>NotIn</td><td>findByAgeNotIn(Collection age)</td><td>… where x.age not in ?1</td></tr><tr><td>TRUE</td><td>findByActiveTrue()</td><td>… where x.active = true</td></tr><tr><td>FALSE</td><td>findByActiveFalse()</td><td>… where x.active = false</td></tr><tr><td>IgnoreCase</td><td>findByFirstnameIgnoreCase</td><td>… where UPPER(x.firstame) = UPPER(?1)</td></tr></tbody></table> 
<h4>复杂查询</h4> 
<p>在实际的开发中我们需要用到分页、删选、连表等查询的时候就需要特殊的方法或者自定义 SQL</p> 
<p>分页查询</p> 
<p>分页查询在实际使用中非常普遍了，Spring Boot Jpa 已经帮我们实现了分页的功能，在查询的方法中，需要传入参数<code>Pageable</code> ,当查询中有多个参数的时候<code>Pageable</code>建议做为最后一个参数传入.</p> 
<pre>Page&lt;User&gt; findALL(Pageable pageable);
Page&lt;User&gt; findByUserName(String userName,Pageable pageable);</pre> 
<p><code>Pageable</code> 是 Spring 封装的分页实现类，使用的时候需要传入页数、每页条数和排序规则</p> 
<pre>public interface NavDefinitionRepository
    extends JpaRepository&lt;NavDefinition, String&gt;, JpaSpecificationExecutor&lt;NavDefinition&gt; {

}@Test
public void testPageQuery() throws Exception {
    int page=1,size=10;
    Sort sort = new Sort(Direction.DESC, "id");
    Pageable pageable = new PageRequest(page, size, sort);
    userRepository.findALL(pageable);
    userRepository.findByUserName("testName", pageable);
}</pre> 
<p>动态条件查询</p> 
<ul><li> <p>接口...Repository再继承一个JpaSpecificationExecutor类</p> </li></ul> 
<pre>public interface NavDefinitionRepository
    extends JpaRepository&lt;NavDefinition, String&gt;, JpaSpecificationExecutor&lt;NavDefinition&gt; {
}</pre> 
<ul><li> <p>创建Specification类，将查询条件添加至CriteriaBuilder中，执行findAll（）方法；</p> </li></ul> 
<pre>public Page&lt;NavDefinition&gt; selectAllByCondition(String appKey, String name, Pageable qp) {
    Specification&lt;NavDefinition&gt; spec
        = (Root&lt;NavDefinition&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) -&gt; {
            List&lt;Predicate&gt; list = new ArrayList&lt;&gt;();
            if (StringUtils.isNotBlank(appKey)) {
                list.add(criteriaBuilder.like(root.get("appKey"), "%" + appKey + "%"));
            }
            if (StringUtils.isNotBlank(name)) {
                list.add(criteriaBuilder.like(root.get("name"), "%" + name + "%"));
            }
            Predicate[] p = new Predicate[list.size()];
            return criteriaBuilder.and(list.toArray(p));
        };
    return navDefinitionRepository.findAll(spec, qp);
}</pre> 
<p>限制查询</p> 
<p>有时候我们只需要查询前N个元素，或者只取前一个实体。</p> 
<pre>User findFirstByOrderByLastnameAsc();
User findTopByOrderByAgeDesc();
Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable);
List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort);
List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable);</pre> 
<h4>自定义SQL查询</h4> 
<p>其实 Spring Data 觉大部分的 SQL 都可以根据方法名定义的方式来实现，但是由于某些原因我们想使用自定义的 SQL 来查询，Spring Data 也是完美支持的；在 SQL 的查询方法上面使用<code>@Query</code>注解，如涉及到删除和修改在需要加上<code>@Modifying</code>.也可以根据需要添加 <code>@Transactional</code>对事物的支持，查询超时的设置等。</p> 
<pre>@Modifying
@Query("update User u set u.userName = ?1 where u.id = ?2")
int modifyByIdAndUserId(String  userName, Long id);
    
@Transactional
@Modifying
@Query("delete from User where id = ?1")
void deleteByUserId(Long id);
  
@Transactional(timeout = 10)
@Query("select u from User u where u.emailAddress = ?1")
User findByEmailAddress(String emailAddress);</pre> 
<h4>多表查询</h4> 
<p>多表查询 Spring Boot Jpa 中有两种实现方式，第一种是利用 Hibernate 的级联查询来实现，第二种是创建一个结果集的接口来接收连表查询后的结果，这里主要第二种方式。</p> 
<p>首先需要定义一个结果集的接口类。</p> 
<pre>public interface HotelSummary {

    City getCity();

    String getName();

    Double getAverageRating();

    default Integer getAverageRatingRounded() {
        return getAverageRating() == null ? null : (int) Math.round(getAverageRating());
    }

}</pre> 
<p>查询的方法返回类型设置为新创建的接口</p> 
<pre>@Query("select h.city as city, h.name as name, avg(r.rating) as averageRating "
        - "from Hotel h left outer join h.reviews r where h.city = ?1 group by h")
Page&lt;HotelSummary&gt; findByCity(City city, Pageable pageable);

@Query("select h.name as name, avg(r.rating) as averageRating "
        - "from Hotel h left outer join h.reviews r  group by h")
Page&lt;HotelSummary&gt; findByCity(Pageable pageable);</pre> 
<p>使用</p> 
<pre>Page&lt;HotelSummary&gt; hotels = this.hotelRepository.findByCity(new PageRequest(0, 10, Direction.ASC, "name"));
for(HotelSummary summay:hotels){
        System.out.println("Name" +summay.getName());
    }</pre> 
<p>在运行中 Spring 会给接口（HotelSummary）自动生产一个代理类来接收返回的结果，代码汇总使用 <code>getXX</code>的形式来获取</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c111983409d202fd361894c6fb331b8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu怎么查看电脑配置(ubuntu怎么查看系统配置)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8fdf1d310920d0ae9a56f4f0e485d32a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python 保留小数点位数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>