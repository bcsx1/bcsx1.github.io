<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数字图像处理】常用知识点以及OpenCv实现的总结！更新中 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数字图像处理】常用知识点以及OpenCv实现的总结！更新中" />
<meta property="og:description" content="文章目录 一、基本概念1.1、距离度量1.2、常见的插值方法1.2.1、最近邻插值1.2.2、双线性插值 二、形态学操作2.1、腐蚀2.2、膨胀2.3、开运算 &#43; cv2.morphologyEx()实现更复杂的形态学操作2.4、闭运算2.5、形态学梯度运算2.6、顶帽2.7、黑帽2.8、击中击不中 三、图像增强3.1、图像增强和图像恢复的区别3.2、空域灰度变换3.2.1、线性变换/分段线性变换3.2.2、非线性变换3.2.3、直方图均衡化/规定化 3.3、空域滤波3.3.1、空域平滑3.3.1.1、均值滤波3.3.1.2、中值滤波3.3.1.3、高斯滤波 3.3.2、空域锐化3.3.2.1、一阶微分算子3.3.2.2、二阶微分算子 3.4、频域增强 四、图像恢复五、边缘检测5.1、边缘检测5.2、一阶微分算子5.2.1、Roberts算子5.2.2、Prewitt算子5.2.3、Sobel算子 5.3、二阶微分算子5.3.1、Laplacian算子5.3.2、Canny算子 六、图像分割6.1、阈值分割6.2、区域生长法6.3、分裂合并法6.4、分水岭分割6.5、聚类分割算法6.6、水平集分割6.7、Graph Cut分割 七、图像表达与描述7.1、全局特征：LBP7.2、简单局部特征：HOG7.2.1、梯度幅度和方向计算7.2.2、计算grid cell中的方向梯度直方图7.2.3、block归一化 7.3、基于关键点检测的局部特征：Harris角点、块检测(DoG, MSER)、SIFT7.3.1、SIFT特征1）构建高斯差分金字塔（Difference of Gaussian，DoG）并进行尺度空间极值检测2）特征点/关键点定位3）特征点/关键点方向的确定4）计算特征描述子5）OpenCv的实现6）旋转不变性、尺度不变性、亮度不变性 八、图像识别8.1、Hough变换8.1.1、算法原理8.1.2、检测直线、圆、椭圆8.1.3、广义hough变换 8.2、距离变换 一、基本概念 1.1、距离度量 下面以两点 a = ( i , j ) a=(i, j) a=(i,j)和 b = ( k , l ) b=(k, l) b=(k,l)为例介绍距离度量。
欧氏距离：是最常用的距离定义，是指在n维空间中，两个点（其实如果是n维空间，点也可以看作n维向量）之间的真实距离：
曼哈顿距离/街区距离：名字由来就是，在曼哈顿街区从一个十字路口到另一个十字路口所走过的距离，此时不是直线距离，而是如下的 D 4 D_4 D4​。也就是说：如果在二维图像中来看，像素点之间只允许横向或纵向移动，像素点之间是4邻接的。
切比雪夫/棋盘距离：在国际象棋中，可以横向、纵向或者斜向移动，那么二维图像中，像素点之间就是8邻接的，即每个点只与它的上、下、左、右、四个对角线方向相邻的8个点之间的距离为1。于棋盘距离为：
余弦相似度：通过计算两个向量之间夹角的余弦值来评估二者之间的相似度：
参考链接：https://blog.csdn.net/yishuihanq/article/details/120283648
1.2、常见的插值方法 1.2.1、最近邻插值 最简单的插值方法：在相邻的四个像素点中，取最近的像素点的值作为输出值(u, v)为待插值点
1.2.2、双线性插值 顾名思义，进行两次线性插值（线性插值就是两个像素点按比例加权即可）：先在x方向上插值，再在y方向上插值
二、形态学操作 形态学操作最基本的运算是腐蚀与膨胀。基于腐蚀与膨胀操作可以实现更复杂的运算：开运算、闭运算、形态学梯度运算、顶帽运算、黑帽运算、击中击不中运算。
2.1、腐蚀 腐蚀最简单理解就是不断消除掉边界区域，即腐蚀操作可以收缩/细化二值图像（最常用的就是二值图像，灰度/彩色图像也可以作为输入）中的前景部分，或者直接去除掉某些小于指定结构体元素的前景区域（也就是说消除掉噪声）。
腐蚀操作的运算过程：假设有图像A和结构体元素B，类似卷积操作，结构体元素B在图像A上移动，其中定义B的中心为锚点，计算B覆盖A的区域中最小值的像素值用来替代锚点的像素，其中B可以是矩形，圆，椭圆等任意形状，需要注意腐蚀膨胀操作的图像一般是二值图（最好保持前景区域为1，背景区域为0）作用：1）消除小颗粒噪声；2）消除目标区域之间的粘连，但同时目标区域的边界也会向内收缩
OpenCv的实现：首先通过cv2.getStructuringElement创建结构体元素或者自定义生成结构体元素，再调用cv2.erode()实现腐蚀操作。 cv2.getStructuringElement(shape, ksize[, anchor]) -&gt; retval &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3c0f86fcd079e5f4685ea7c1a1e2555f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-18T21:39:40+08:00" />
<meta property="article:modified_time" content="2023-07-18T21:39:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数字图像处理】常用知识点以及OpenCv实现的总结！更新中</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、基本概念</a></li><li><ul><li><a href="#11_2" rel="nofollow">1.1、距离度量</a></li><li><a href="#12_16" rel="nofollow">1.2、常见的插值方法</a></li><li><ul><li><a href="#121_17" rel="nofollow">1.2.1、最近邻插值</a></li><li><a href="#122_21" rel="nofollow">1.2.2、双线性插值</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_30" rel="nofollow">二、形态学操作</a></li><li><ul><li><a href="#21_32" rel="nofollow">2.1、腐蚀</a></li><li><a href="#22_65" rel="nofollow">2.2、膨胀</a></li><li><a href="#23__cv2morphologyEx_82" rel="nofollow">2.3、开运算 + cv2.morphologyEx()实现更复杂的形态学操作</a></li><li><a href="#24_108" rel="nofollow">2.4、闭运算</a></li><li><a href="#25_112" rel="nofollow">2.5、形态学梯度运算</a></li><li><a href="#26_116" rel="nofollow">2.6、顶帽</a></li><li><a href="#27_120" rel="nofollow">2.7、黑帽</a></li><li><a href="#28_124" rel="nofollow">2.8、击中击不中</a></li></ul> 
  </li><li><a href="#_126" rel="nofollow">三、图像增强</a></li><li><ul><li><a href="#31_127" rel="nofollow">3.1、图像增强和图像恢复的区别</a></li><li><a href="#32_131" rel="nofollow">3.2、空域灰度变换</a></li><li><ul><li><a href="#321_134" rel="nofollow">3.2.1、线性变换/分段线性变换</a></li><li><a href="#322_150" rel="nofollow">3.2.2、非线性变换</a></li><li><a href="#323_155" rel="nofollow">3.2.3、直方图均衡化/规定化</a></li></ul> 
   </li><li><a href="#33_159" rel="nofollow">3.3、空域滤波</a></li><li><ul><li><a href="#331_160" rel="nofollow">3.3.1、空域平滑</a></li><li><ul><li><a href="#3311_161" rel="nofollow">3.3.1.1、均值滤波</a></li><li><a href="#3312_190" rel="nofollow">3.3.1.2、中值滤波</a></li><li><a href="#3313_202" rel="nofollow">3.3.1.3、高斯滤波</a></li></ul> 
    </li><li><a href="#332_223" rel="nofollow">3.3.2、空域锐化</a></li><li><ul><li><a href="#3321_225" rel="nofollow">3.3.2.1、一阶微分算子</a></li><li><a href="#3322_227" rel="nofollow">3.3.2.2、二阶微分算子</a></li></ul> 
   </li></ul> 
   </li><li><a href="#34_230" rel="nofollow">3.4、频域增强</a></li></ul> 
  </li><li><a href="#_234" rel="nofollow">四、图像恢复</a></li><li><a href="#_236" rel="nofollow">五、边缘检测</a></li><li><ul><li><a href="#51_237" rel="nofollow">5.1、边缘检测</a></li><li><a href="#52_239" rel="nofollow">5.2、一阶微分算子</a></li><li><ul><li><a href="#521Roberts_240" rel="nofollow">5.2.1、Roberts算子</a></li><li><a href="#522Prewitt_261" rel="nofollow">5.2.2、Prewitt算子</a></li><li><a href="#523Sobel_264" rel="nofollow">5.2.3、Sobel算子</a></li></ul> 
   </li><li><a href="#53_282" rel="nofollow">5.3、二阶微分算子</a></li><li><ul><li><a href="#531Laplacian_283" rel="nofollow">5.3.1、Laplacian算子</a></li><li><a href="#532Canny_292" rel="nofollow">5.3.2、Canny算子</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_314" rel="nofollow">六、图像分割</a></li><li><ul><li><a href="#61_315" rel="nofollow">6.1、阈值分割</a></li><li><a href="#62_317" rel="nofollow">6.2、区域生长法</a></li><li><a href="#63_319" rel="nofollow">6.3、分裂合并法</a></li><li><a href="#64_321" rel="nofollow">6.4、分水岭分割</a></li><li><a href="#65_322" rel="nofollow">6.5、聚类分割算法</a></li><li><a href="#66_323" rel="nofollow">6.6、水平集分割</a></li><li><a href="#67Graph_Cut_324" rel="nofollow">6.7、Graph Cut分割</a></li></ul> 
  </li><li><a href="#_326" rel="nofollow">七、图像表达与描述</a></li><li><ul><li><a href="#71LBP_327" rel="nofollow">7.1、全局特征：LBP</a></li><li><a href="#72HOG_339" rel="nofollow">7.2、简单局部特征：HOG</a></li><li><ul><li><a href="#721_348" rel="nofollow">7.2.1、梯度幅度和方向计算</a></li><li><a href="#722grid_cell_364" rel="nofollow">7.2.2、计算grid cell中的方向梯度直方图</a></li><li><a href="#723block_372" rel="nofollow">7.2.3、block归一化</a></li></ul> 
   </li><li><a href="#73HarrisDoG_MSERSIFT_378" rel="nofollow">7.3、基于关键点检测的局部特征：Harris角点、块检测(DoG, MSER)、SIFT</a></li><li><ul><li><a href="#731SIFT_381" rel="nofollow">7.3.1、SIFT特征</a></li><li><ul><li><a href="#1Difference_of_GaussianDoG_388" rel="nofollow">1）构建高斯差分金字塔（Difference of Gaussian，DoG）并进行尺度空间极值检测</a></li><li><a href="#2_398" rel="nofollow">2）特征点/关键点定位</a></li><li><a href="#3_400" rel="nofollow">3）特征点/关键点方向的确定</a></li><li><a href="#4_408" rel="nofollow">4）计算特征描述子</a></li><li><a href="#5OpenCv_416" rel="nofollow">5）OpenCv的实现</a></li><li><a href="#6_430" rel="nofollow">6）旋转不变性、尺度不变性、亮度不变性</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_434" rel="nofollow">八、图像识别</a></li><li><ul><li><a href="#81Hough_435" rel="nofollow">8.1、Hough变换</a></li><li><ul><li><a href="#811_436" rel="nofollow">8.1.1、算法原理</a></li><li><a href="#812_455" rel="nofollow">8.1.2、检测直线、圆、椭圆</a></li><li><a href="#813hough_456" rel="nofollow">8.1.3、广义hough变换</a></li></ul> 
   </li><li><a href="#82_457" rel="nofollow">8.2、距离变换</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、基本概念</h2> 
<h3><a id="11_2"></a>1.1、距离度量</h3> 
<p>下面以两点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         = 
        
       
         ( 
        
       
         i 
        
       
         , 
        
       
         j 
        
       
         ) 
        
       
      
        a=(i, j) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">)</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         b 
        
       
         = 
        
       
         ( 
        
       
         k 
        
       
         , 
        
       
         l 
        
       
         ) 
        
       
      
        b=(k, l) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mclose">)</span></span></span></span></span>为例介绍距离度量。</p> 
<ul><li> <p>欧氏距离：是最常用的距离定义，是指在n维空间中，两个点（其实如果是n维空间，点也可以看作n维向量）之间的真实距离：<br> <img src="https://images2.imgbox.com/f6/76/YpjaGmUp_o.png" alt="在这里插入图片描述"></p> </li><li> <p>曼哈顿距离/街区距离：名字由来就是，在曼哈顿街区从一个十字路口到另一个十字路口所走过的距离，此时不是直线距离，而是如下的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            D 
           
          
            4 
           
          
         
        
          D_4 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。也就是说：如果在二维图像中来看，像素点之间只允许横向或纵向移动，像素点之间是4邻接的。<br> <img src="https://images2.imgbox.com/72/cd/7aupFNyv_o.png" alt="在这里插入图片描述"></p> </li><li> <p>切比雪夫/棋盘距离：在国际象棋中，可以横向、纵向或者斜向移动，那么二维图像中，像素点之间就是8邻接的，即每个点只与它的上、下、左、右、四个对角线方向相邻的8个点之间的距离为1。于棋盘距离为：<br> <img src="https://images2.imgbox.com/da/47/qyUbX6QF_o.png" alt="在这里插入图片描述"></p> </li><li> <p>余弦相似度：通过计算两个向量之间夹角的余弦值来评估二者之间的相似度：<br> <img src="https://images2.imgbox.com/ec/75/urUr1h3r_o.png" alt="在这里插入图片描述"><br> 参考链接：<a href="https://blog.csdn.net/yishuihanq/article/details/120283648">https://blog.csdn.net/yishuihanq/article/details/120283648</a></p> </li></ul> 
<h3><a id="12_16"></a>1.2、常见的插值方法</h3> 
<h4><a id="121_17"></a>1.2.1、最近邻插值</h4> 
<ul><li>最简单的插值方法：在相邻的四个像素点中，取最近的像素点的值作为输出值</li><li>(u, v)为待插值点<br> <img src="https://images2.imgbox.com/0a/8b/oNrLWcIc_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="122_21"></a>1.2.2、双线性插值</h4> 
<ul><li>顾名思义，进行两次线性插值（线性插值就是两个像素点按比例加权即可）：先在x方向上插值，再在y方向上插值<br> <img src="https://images2.imgbox.com/70/8a/1YIVoICF_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/33/3e/KdH7DDfH_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/96/d7/sGymQmO1_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8e/d0/FUtVo8LK_o.png" alt="在这里插入图片描述"></li></ul> 
<h2><a id="_30"></a>二、形态学操作</h2> 
<p>形态学操作最基本的运算是腐蚀与膨胀。基于腐蚀与膨胀操作可以实现更复杂的运算：开运算、闭运算、形态学梯度运算、顶帽运算、黑帽运算、击中击不中运算。</p> 
<h3><a id="21_32"></a>2.1、腐蚀</h3> 
<ul><li>腐蚀最简单理解就是不断消除掉边界区域，即腐蚀操作可以收缩/细化<strong>二值图像（最常用的就是二值图像，灰度/彩色图像也可以作为输入）<strong>中的</strong>前景</strong>部分，或者直接去除掉某些小于指定结构体元素的前景区域（也就是说消除掉噪声）。<br> <img src="https://images2.imgbox.com/30/b3/PQchuKlA_o.png" alt="在这里插入图片描述"></li><li><strong>腐蚀操作的运算过程</strong>：假设有图像A和结构体元素B，类似卷积操作，结构体元素B在图像A上移动，其中定义B的中心为锚点，计算B覆盖A的区域中<strong>最小值</strong>的像素值用来替代<strong>锚点的像素</strong>，其中B可以是矩形，圆，椭圆等任意形状，需要注意<strong>腐蚀膨胀操作</strong>的图像一般是二值图（最好保持前景区域为1，背景区域为0）</li><li><strong>作用</strong>：1）消除小颗粒噪声；2）消除目标区域之间的粘连，但同时目标区域的边界也会向内收缩<br> <img src="https://images2.imgbox.com/2a/32/nSlvFCQ9_o.png" alt="在这里插入图片描述"></li><li><strong>OpenCv的实现</strong>：首先通过cv2.getStructuringElement创建结构体元素或者自定义生成结构体元素，再调用cv2.erode()实现腐蚀操作。</li></ul> 
<pre><code class="prism language-python">cv2<span class="token punctuation">.</span>getStructuringElement<span class="token punctuation">(</span>shape<span class="token punctuation">,</span> ksize<span class="token punctuation">[</span><span class="token punctuation">,</span> anchor<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> retval
<span class="token string">""</span>
返回特定形状和尺寸的结构体元素用于形态学操作
<span class="token number">1</span>）shape：有以下四种可选择的形状
cv2<span class="token punctuation">.</span>MORPH_RECT：矩形元素，矩形内部所有元素都参与运算
cv2<span class="token punctuation">.</span>MORPH_ELLIPSE：以尺寸为ksize的矩形为外接矩形的椭圆元素，只有椭圆内的元素参与运算
cv2<span class="token punctuation">.</span>MORPH_CROSS：十字形元素，以anchor为中心的横向元素和纵向元素参与运算
cv2<span class="token punctuation">.</span>CV_SHAPE_CUSTOM：自定义的结构体元素
<span class="token number">2</span>）ksize：结构体元素的尺寸，（width，height）
<span class="token number">3</span>）anchor：元素内的锚点位置。默认值<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span>，<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>表示锚位于中心。注意，只有十字形元素的形状取决于锚点位置。在其他情况下，锚只是调节形态学操作的结果被移动的程度。（anchorX，anchorY）
<span class="token number">4</span>）values：当shape<span class="token operator">=</span>CV_SHAPE_CUSTOM时，为尺寸为ksize的整数数组。
<span class="token string">""</span>
</code></pre> 
<pre><code class="prism language-python">cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>src<span class="token punctuation">,</span> kernel<span class="token punctuation">[</span><span class="token punctuation">,</span> dst<span class="token punctuation">[</span><span class="token punctuation">,</span> anchor<span class="token punctuation">[</span><span class="token punctuation">,</span> iterations<span class="token punctuation">[</span><span class="token punctuation">,</span> borderType<span class="token punctuation">[</span><span class="token punctuation">,</span> borderValue<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> dst
使用给定的结构体元素实现腐蚀操作（注意：对于多通道图像，每个通道都是独立处理的。）
<span class="token number">1</span>）src：输入图像，一般为二值图，最好转换为前景为<span class="token number">1</span>，背景为<span class="token number">0</span>
<span class="token number">2</span>）kernel：结构体元素，可以是自定义的，也可以是cv2<span class="token punctuation">.</span>getStructuringElement创建的
<span class="token number">3</span>）dst：输出图像，与输入图像具有相同的尺寸和类型
<span class="token number">4</span>）anchor：结构体元素中锚点的位置，默认（<span class="token operator">-</span><span class="token number">1</span>，<span class="token operator">-</span><span class="token number">1</span>）为中心点
<span class="token number">5</span>）iterations：腐蚀被应用的次数，默认为<span class="token number">1</span>，即进行一次腐蚀
<span class="token number">6</span>）borderType和borderValue：略
</code></pre> 
<h3><a id="22_65"></a>2.2、膨胀</h3> 
<ul><li>膨胀操作与腐蚀操作是相反的，是不断对边界区域进行扩张，即膨胀操作可以扩张目标区域的边界或者可以对目标区域内部的小空洞进行填补。<br> <img src="https://images2.imgbox.com/d2/89/fD3mN6hw_o.png" alt="在这里插入图片描述"></li><li><strong>膨胀操作的运算过程</strong>与腐蚀操作类似：假设有图像A和结构体元素B，类似卷积操作，结构体元素B在图像A上移动，其中定义B的中心为锚点，计算B覆盖A的区域中<strong>最大值</strong>的像素值用来替代<strong>锚点的像素</strong>，其中B可以是矩形，圆，椭圆等任意形状，需要注意<strong>腐蚀膨胀操作</strong>的图像一般是二值图（最好保持前景区域为1，背景区域为0）</li><li><strong>作用</strong>：1）填补目标区域中的小空洞；2）合并目标物周围的背景点，目标边界向外部扩张</li><li><strong>OpenCv的实现</strong>：</li></ul> 
<pre><code class="prism language-python">cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>src<span class="token punctuation">,</span> kernel<span class="token punctuation">[</span><span class="token punctuation">,</span> dst<span class="token punctuation">[</span><span class="token punctuation">,</span> anchor<span class="token punctuation">[</span><span class="token punctuation">,</span> iterations<span class="token punctuation">[</span><span class="token punctuation">,</span> borderType<span class="token punctuation">[</span><span class="token punctuation">,</span> borderValue<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> dst
使用给定的结构体元素实现膨胀操作（注意：对于多通道图像，每个通道都是独立处理的。）
<span class="token number">1</span>）src：输入图像，一般为二值图，最好转换为前景为<span class="token number">1</span>，背景为<span class="token number">0</span>
<span class="token number">2</span>）kernel：结构体元素，可以是自定义的，也可以是cv2<span class="token punctuation">.</span>getStructuringElement创建的
<span class="token number">3</span>）dst：输出图像，与输入图像具有相同的尺寸和类型
<span class="token number">4</span>）anchor：结构体元素中锚点的位置，默认（<span class="token operator">-</span><span class="token number">1</span>，<span class="token operator">-</span><span class="token number">1</span>）为中心点
<span class="token number">5</span>）iterations：膨胀被应用的次数，默认为<span class="token number">1</span>，即进行一次膨胀
<span class="token number">6</span>）borderType和borderValue：略
</code></pre> 
<h3><a id="23__cv2morphologyEx_82"></a>2.3、开运算 + cv2.morphologyEx()实现更复杂的形态学操作</h3> 
<ul><li>腐蚀操作和膨胀操作是形态学运算的基础，将腐蚀和膨胀操作进行组合，就可以实现开运算、闭运算、形态学梯度（Morphological Gradient）运算、顶帽运算、黑帽运算、击中击不中等多种不同形式的运算。</li><li>OpenCv可以通过cv2.morphologyEx()实现上述多种更复杂的形态学操作。</li></ul> 
<pre><code class="prism language-python">cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>src<span class="token punctuation">,</span> op<span class="token punctuation">,</span> kernel<span class="token punctuation">[</span><span class="token punctuation">,</span> dst<span class="token punctuation">[</span><span class="token punctuation">,</span> anchor<span class="token punctuation">[</span><span class="token punctuation">,</span> iterations<span class="token punctuation">[</span><span class="token punctuation">,</span> borderType<span class="token punctuation">[</span><span class="token punctuation">,</span> borderValue<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">""</span>
大部分参数与erode和dilate相同：
<span class="token number">1</span>）src：输入图像，一般为二值图，最好转换为前景为<span class="token number">1</span>，背景为<span class="token number">0</span>
<span class="token number">2</span>）op：不同的形态学操作：
MORPH_OPEN：开运算<span class="token punctuation">,</span>先腐蚀后膨胀
MORPH_CLOSE：闭运算，先膨胀后腐蚀
MORPH_GRADIENT：形态学梯度运算，膨胀<span class="token operator">-</span>腐蚀
MORPH_TOPHAT：顶帽运算，原始图像<span class="token operator">-</span>开运算后的图像
MORPH_BLACKHAT：黑帽运算，闭运算后的图像<span class="token operator">-</span>原始图像
<span class="token number">3</span>）kernel：结构体元素，可以是自定义的，也可以是cv2<span class="token punctuation">.</span>getStructuringElement创建的
<span class="token number">4</span>）dst：输出图像，与输入图像具有相同的尺寸和类型
<span class="token number">5</span>）anchor：结构体元素中锚点的位置，默认（<span class="token operator">-</span><span class="token number">1</span>，<span class="token operator">-</span><span class="token number">1</span>）为中心点
<span class="token number">6</span>）iterations：膨胀被应用的次数，默认为<span class="token number">1</span>，即进行一次膨胀
<span class="token number">7</span>）borderType和borderValue：略
<span class="token string">""</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/20/6f/aRYZauEA_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>开运算</strong>：使用同一个结构体元素，对图像进行先腐蚀后膨胀处理的运算。其主要作用与腐蚀运算相似，但是可以保持物体面积大小基本不变。</li><li><strong>作用</strong>：开运算通常用来消除小噪声点或小对象物，消除物体边界<strong>粘连的纤细点</strong>达到分离物体边界的作用。<br> <img src="https://images2.imgbox.com/df/e2/iBhyliwm_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="24_108"></a>2.4、闭运算</h3> 
<ul><li><strong>闭运算</strong>：使用同一个结构体元素，对图像进行先膨胀后腐蚀处理的运算称为闭运算。主要作用与膨胀运算相似，但可以保持物体面积大小基本不变。</li><li><strong>作用</strong>：闭运算通常用来填充目标内细小空洞，连接断开的邻近目标。<br> <img src="https://images2.imgbox.com/d1/10/3pCaR0pn_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="25_112"></a>2.5、形态学梯度运算</h3> 
<ul><li>形态学梯度运算是用图像的膨胀图像减腐蚀图像的操作，该操作可以获取原始图像中前景图像的边缘。<br> <img src="https://images2.imgbox.com/d6/e6/hd7x1sys_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="26_116"></a>2.6、顶帽</h3> 
<ul><li>顶帽运算是用原始图像减去其开运算图像的操作。顶帽运算能够获取图像的噪声信息<br> <img src="https://images2.imgbox.com/8f/4f/dQwWyUON_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="27_120"></a>2.7、黑帽</h3> 
<ul><li>黑帽运算是用闭运算图像减去原始图像的操作。黑帽运算能够获取图像内部的小孔，或前景色中的小黑点<br> <img src="https://images2.imgbox.com/8e/0a/oeLZSP2W_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="28_124"></a>2.8、击中击不中</h3> 
<h2><a id="_126"></a>三、图像增强</h2> 
<h3><a id="31_127"></a>3.1、图像增强和图像恢复的区别</h3> 
<ul><li><strong>图像增强</strong>和<strong>图像恢复</strong>的目的都是要改善/提高图像的质量</li><li><strong>图像增强</strong>更偏向于是一个主观的过程，突出图像中感兴趣的区域，抑制一些不需要的信息</li><li><strong>图像恢复</strong>是一个客观的过程，针对质量降低或者失真的图像，通过建立退化模型，恢复原始的内容或质量。可以理解为图像降质的反向过程</li></ul> 
<h3><a id="32_131"></a>3.2、空域灰度变换</h3> 
<p><strong>参考链接：</strong><a href="https://blog.csdn.net/weixin_43848614/article/details/122285472">https://blog.csdn.net/weixin_43848614/article/details/122285472</a></p> 
<ul><li>灰度变换是通过对图像中每一个像素点进行线性或非线性变换来调整整个图像的灰度范围，以增强图像的对比度，提高图像的质量</li></ul> 
<h4><a id="321_134"></a>3.2.1、线性变换/分段线性变换</h4> 
<ul><li> <p>例如：在曝光不足或过度的情况下，图像灰度可能会局限在一个很小的范围内。这时在显示器上看到的将是一个模糊不清、似乎没有灰度层次的图像。那么可以利用灰度变换扩展灰度范围。<br> <img src="https://images2.imgbox.com/04/0a/sB1lgS21_o.png" alt="在这里插入图片描述"></p> </li><li> <p>下图是对曝光不足的图像采用线性变换对图像每一个像素点的灰度作线性拉伸。可有效地改善图像视觉效果。<br> <img src="https://images2.imgbox.com/69/f2/lIXWO95G_o.png" alt="在这里插入图片描述"></p> </li><li> <p>OpenCv的实现：</p> </li></ul> 
<pre><code class="prism language-python">cv2<span class="token punctuation">.</span>convertScaleAbs<span class="token punctuation">(</span>src<span class="token punctuation">[</span><span class="token punctuation">,</span> dst<span class="token punctuation">[</span><span class="token punctuation">,</span> alpha<span class="token punctuation">[</span><span class="token punctuation">,</span> beta<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">""</span>
对输入图像的每一个像素都执行以下的函数（即依次执行缩放，取绝对值，转换为uint8类型）
dst <span class="token operator">=</span> <span class="token punctuation">(</span>src <span class="token operator">*</span> alpha <span class="token operator">+</span> beta<span class="token punctuation">)</span><span class="token punctuation">.</span>uint8<span class="token punctuation">(</span><span class="token punctuation">)</span>
对于多通道的图像，各个通道独立处理。
<span class="token string">""</span>
</code></pre> 
<h4><a id="322_150"></a>3.2.2、非线性变换</h4> 
<ul><li>对数变换：对每个像素点使用对数函数作为映射函数，可以使最后的结果中，低灰度区域有较大的拉伸，而高灰度区域有较低的拉伸<br> <img src="https://images2.imgbox.com/82/b7/cxw3oUyk_o.png" alt="在这里插入图片描述"></li><li>指数变换：对每个像素点使用指数函数作为映射函数，可以使最后的结果中，低灰度区域有较小的拉伸，而高灰度区域有较大的拉伸<br> <img src="https://images2.imgbox.com/5b/f1/BTyf9vl0_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="323_155"></a>3.2.3、直方图均衡化/规定化</h4> 
<ul><li>直方图均衡化：将原图像的直方图变换为均匀分布的直方图，这样修正后的图像给人的感觉比较协调，能满足人眼视觉要求。<br> <img src="https://images2.imgbox.com/2d/56/IsK10fcO_o.png" alt="在这里插入图片描述"></li><li>直方图规定化：是使原图像灰度直方图变成规定形状的直方图，以便能够增强图像中某些灰度级。</li></ul> 
<h3><a id="33_159"></a>3.3、空域滤波</h3> 
<h4><a id="331_160"></a>3.3.1、空域平滑</h4> 
<h5><a id="3311_161"></a>3.3.1.1、均值滤波</h5> 
<ul><li>均值滤波就是计算模板内各像素的平均值替代模板区域中心点的像素值。模板为<br> <img src="https://images2.imgbox.com/8b/80/zT8vmayw_o.png" alt="在这里插入图片描述"></li><li>作用：算法简单，一定程度上可以缓解噪声的影响，但同时容易在边缘和细节处产生模糊。</li><li>OpenCv的实现：</li></ul> 
<pre><code class="prism language-python">cv2<span class="token punctuation">.</span>blur<span class="token punctuation">(</span>src<span class="token punctuation">,</span> ksize<span class="token punctuation">[</span><span class="token punctuation">,</span> dst<span class="token punctuation">[</span><span class="token punctuation">,</span> anchor<span class="token punctuation">[</span><span class="token punctuation">,</span> borderType<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">""</span>
使用归一化的box <span class="token builtin">filter</span>平滑图像，等同于boxFilter<span class="token punctuation">(</span>src<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> ksize<span class="token punctuation">,</span> anchor<span class="token punctuation">,</span> true<span class="token punctuation">,</span> borderType<span class="token punctuation">)</span>
<span class="token number">1</span>）src：原始图像
<span class="token number">2</span>）ksize：模板的尺寸，<span class="token punctuation">(</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span>
<span class="token number">3</span>）dst：输出图像
<span class="token number">4</span>）anchor：模板的锚点位置，默认为（<span class="token operator">-</span><span class="token number">1</span>， <span class="token operator">-</span><span class="token number">1</span>）为中心点
<span class="token string">""</span>
</code></pre> 
<ul><li>也可以使用cv2.boxFilter平滑图像：<br> <img src="https://images2.imgbox.com/4d/60/txKXSC09_o.png" alt="在这里插入图片描述"></li></ul> 
<pre><code class="prism language-python">cv2<span class="token punctuation">.</span>boxFilter<span class="token punctuation">(</span>src<span class="token punctuation">,</span> ddepth<span class="token punctuation">,</span> ksize<span class="token punctuation">[</span><span class="token punctuation">,</span> dst<span class="token punctuation">[</span><span class="token punctuation">,</span> anchor<span class="token punctuation">[</span><span class="token punctuation">,</span> normalize<span class="token punctuation">[</span><span class="token punctuation">,</span> borderType<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">""</span>
<span class="token number">1</span>）src：输入图像
<span class="token number">2</span>）ddepth：输出图像的深度，<span class="token operator">-</span><span class="token number">1</span>表示与输入图像具有相同的深度
<span class="token number">3</span>）ksize：模板的尺寸，<span class="token punctuation">(</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span>
<span class="token number">4</span>）anchor：模板的锚点位置，默认为（<span class="token operator">-</span><span class="token number">1</span>， <span class="token operator">-</span><span class="token number">1</span>）为中心点
<span class="token number">5</span>）normalize：是否进行归一化
<span class="token string">""</span>
</code></pre> 
<h5><a id="3312_190"></a>3.3.1.2、中值滤波</h5> 
<ul><li>中值滤波是一种非线性滤波方法，它将每个像素周围的像素排序并取中间值替代模板区域中心点的像素值，用于去除图像中的噪声。</li><li>作用：它对脉冲干扰及椒盐噪声的抑制效果好</li><li>OpenCv的实现：</li></ul> 
<pre><code class="prism language-python">cv2<span class="token punctuation">.</span>medianBlur<span class="token punctuation">(</span>src<span class="token punctuation">,</span> ksize<span class="token punctuation">[</span><span class="token punctuation">,</span> dst<span class="token punctuation">]</span><span class="token punctuation">)</span>
使用中值滤波器平滑图像，多通道图像的每个通道都是独立处理的。
<span class="token number">1</span>）src：输入图像，可以是多通道
<span class="token number">2</span>）dst：输出图像
<span class="token number">3</span>）ksize：模板尺寸，必须为奇数，且大于<span class="token number">1</span>，例如<span class="token number">3</span>，<span class="token number">5</span>，<span class="token number">7.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<h5><a id="3313_202"></a>3.3.1.3、高斯滤波</h5> 
<ul><li>高斯滤波是一种线性平滑滤波，适用于消除高斯噪声，广泛应用于图像处理的降噪过程。</li><li>与均值滤波不同，高斯滤波模板中的权重是不相等的，靠近中心点的权重会更大，远离中心点的权重会变小。</li><li>OpenCv的实现：</li></ul> 
<pre><code class="prism language-python">cv2<span class="token punctuation">.</span>GaussianBlur<span class="token punctuation">(</span>src<span class="token punctuation">,</span> ksize<span class="token punctuation">,</span> sigma1<span class="token punctuation">[</span><span class="token punctuation">,</span> dst<span class="token punctuation">[</span><span class="token punctuation">,</span> sigma2<span class="token punctuation">[</span><span class="token punctuation">,</span> borderType<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">1</span>）src：输入图像
<span class="token number">2</span>）ksize：二维高斯核的尺寸
<span class="token number">3</span>）sigma1：沿X方向的高斯核的std，决定了水平方向的权重范围
<span class="token number">4</span>）sigma2：沿Y方向的高斯核的std，决定了垂直方向的权重范围
<span class="token number">5</span>）dst：输出图像
</code></pre> 
<ul><li> <p>高斯滤波其实首先是利用了cv2.getGaussianKernel(ksize, sigma)来获取高斯核，返回的一维高斯核为：<br> <img src="https://images2.imgbox.com/42/13/ZL82d35C_o.png" alt="在这里插入图片描述"></p> </li><li> <p>保边滤波</p> </li><li> <p>双边滤波</p> </li></ul> 
<h4><a id="332_223"></a>3.3.2、空域锐化</h4> 
<p>图像锐化算法是一种用于增强图像中细节和边缘的技术。因此，可以理解为锐化后的图像就是边缘检测以后得图像与原始图像的叠加即可。</p> 
<h5><a id="3321_225"></a>3.3.2.1、一阶微分算子</h5> 
<ul><li>Roberts、Prewitt、Sobel算子</li></ul> 
<h5><a id="3322_227"></a>3.3.2.2、二阶微分算子</h5> 
<ul><li>Laplacian算子、Canny算子，见边缘检测部分</li></ul> 
<h3><a id="34_230"></a>3.4、频域增强</h3> 
<ul><li>高通滤波</li><li>低通滤波</li></ul> 
<h2><a id="_234"></a>四、图像恢复</h2> 
<h2><a id="_236"></a>五、边缘检测</h2> 
<h3><a id="51_237"></a>5.1、边缘检测</h3> 
<p>图像的边缘指的是图像中像素灰度值突然发生变化的区域，因此可以通过导数/微分的方法进行检测。</p> 
<h3><a id="52_239"></a>5.2、一阶微分算子</h3> 
<h4><a id="521Roberts_240"></a>5.2.1、Roberts算子</h4> 
<ul><li>Roberts算子是一种最简单的算子，模板为2*2，采用对角线两元素之差来检测边缘。<br> <img src="https://images2.imgbox.com/c5/0d/4UIkeenf_o.png" alt="在这里插入图片描述"></li><li>计算过程：对于输入图像<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          ( 
         
        
          x 
         
        
          , 
         
        
          y 
         
        
          ) 
         
        
       
         f(x,y) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mclose">)</span></span></span></span></span>，输出图像<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          g 
         
        
          ( 
         
        
          x 
         
        
          , 
         
        
          y 
         
        
          ) 
         
        
       
         g(x, y) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mclose">)</span></span></span></span></span>为（以下各种算子模板的计算过程类似）：<br> <img src="https://images2.imgbox.com/43/b5/zhBr71Qt_o.png" alt="在这里插入图片描述"></li><li>OpenCv的实现：先建立Gx和Gy的模板；再通过cv2.filter2D使用不同模板对输入图像进行类似卷积的操作，得到x和y；最后进行x和y方向的加权（简单相加或者也可以采用平方相加后开根的方式）得到边缘检测的结果。其余算子的实现与此类似，只是建立的模板不同而已。</li></ul> 
<pre><code class="prism language-python">kernelx <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">)</span>
kernely <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">)</span>

cv2<span class="token punctuation">.</span>filter2D<span class="token punctuation">(</span>src<span class="token punctuation">,</span> ddepth<span class="token punctuation">,</span> kernel<span class="token punctuation">[</span><span class="token punctuation">,</span> dst<span class="token punctuation">[</span><span class="token punctuation">,</span> anchor<span class="token punctuation">[</span><span class="token punctuation">,</span> delta<span class="token punctuation">[</span><span class="token punctuation">,</span> borderType<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">1</span>）src：输入图像
<span class="token number">2</span>）ddepth：输出图像的深度，<span class="token operator">-</span><span class="token number">1</span>表示与输入图像相同
<span class="token number">3</span>）kernel：模板，单通道浮点数矩阵
<span class="token number">4</span>）anchor：模板的锚点，默认（<span class="token operator">-</span><span class="token number">1</span>，<span class="token operator">-</span><span class="token number">1</span>）为中心点

absX <span class="token operator">=</span> cv2<span class="token punctuation">.</span>convertScaleAbs<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
absY <span class="token operator">=</span> cv2<span class="token punctuation">.</span>convertScaleAbs<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
Roberts <span class="token operator">=</span> cv2<span class="token punctuation">.</span>addWeighted<span class="token punctuation">(</span>absX<span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> absY<span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="522Prewitt_261"></a>5.2.2、Prewitt算子</h4> 
<ul><li>Prewitt算子的边缘检测结果在水平和垂直方向均比Roberts算子更加明显。<br> <img src="https://images2.imgbox.com/24/08/IMo0kzvm_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="523Sobel_264"></a>5.2.3、Sobel算子</h4> 
<ul><li> <p>在边缘检测中，常用的一种模板是Sobel算子。与Prewitt算子相比，Sobel算子结合了对于像素的位置的影响做了加权，可以降低边缘模糊程度，因此效果更好。<br> <img src="https://images2.imgbox.com/51/48/C6CfN3ol_o.png" alt="在这里插入图片描述"></p> </li><li> <p>OpenCv的实现：</p> </li></ul> 
<pre><code class="prism language-python">cv2<span class="token punctuation">.</span>Sobel<span class="token punctuation">(</span>src<span class="token punctuation">,</span> ddepth<span class="token punctuation">,</span> dx<span class="token punctuation">,</span> dy<span class="token punctuation">[</span><span class="token punctuation">,</span> dst<span class="token punctuation">[</span><span class="token punctuation">,</span> ksize<span class="token punctuation">[</span><span class="token punctuation">,</span> scale<span class="token punctuation">[</span><span class="token punctuation">,</span> delta<span class="token punctuation">[</span><span class="token punctuation">,</span> borderType<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
<span class="token number">1</span>）src：输入图像
<span class="token number">2</span>）ddepth：输出图像的深度
<span class="token number">3</span>）dx：x方向的阶数，
<span class="token number">4</span>）dy：y方向的阶数，
<span class="token number">5</span>）ksize：Sobel kernel的尺寸
</code></pre> 
<ul><li>dx = 1， dy = 0， ksize = 3时：<br> <img src="https://images2.imgbox.com/16/d2/iL30TCtp_o.png" alt="在这里插入图片描述"></li><li>dx = 0，dy = 1，ksize = 3时：<br> <img src="https://images2.imgbox.com/b4/d9/AQKx3XZM_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="53_282"></a>5.3、二阶微分算子</h3> 
<h4><a id="531Laplacian_283"></a>5.3.1、Laplacian算子</h4> 
<ul><li>Laplacian（拉普拉斯）算子是一种二阶导数算子，其具有旋转不变性，可以满足不同方向的图像边缘锐化（边缘检测）的要求。通常情况下，其算子的系数之和需要为零。例如：<br> <img src="https://images2.imgbox.com/13/fd/Q9YYhNtA_o.png" alt="在这里插入图片描述"></li><li>OpenCv的实现</li></ul> 
<pre><code class="prism language-python">cv2<span class="token punctuation">.</span>Laplacian<span class="token punctuation">(</span>src<span class="token punctuation">,</span> ddepth<span class="token punctuation">[</span><span class="token punctuation">,</span> dst<span class="token punctuation">[</span><span class="token punctuation">,</span> ksize<span class="token punctuation">[</span><span class="token punctuation">,</span> scale<span class="token punctuation">[</span><span class="token punctuation">,</span> delta<span class="token punctuation">[</span><span class="token punctuation">,</span> borderType<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
ksize：用于计算二阶导数的孔径大小，必须为正数且为奇数，为<span class="token number">1</span>时是上面的模板，为<span class="token number">4</span>邻接
</code></pre> 
<h4><a id="532Canny_292"></a>5.3.2、Canny算子</h4> 
<ul><li>Canny算子是一种经典的边缘检测算法，被广泛应用于图像处理领域。</li><li>具体过程如下：</li></ul> 
<blockquote> 
 <p>1）使用高斯滤波对图像（一般输入的为灰度图像）进行平滑处理，去除噪声的影响（cv2.GaussianBlur）<br> 2）使用Sobel算子进行边缘检测<br> 3）非极大值抑制：在不同方向计算出的梯度图像中执行NMS，对整个图像每个像素点进行扫描，看看这个点是不是周围像素点最大的，不是则要抑制掉<br> 4）双阈值选取：选择两个阈值，minVal和maxVal，梯度图像中小于minVal的点被认为是非边缘点（肯定不是边缘，抛弃），高于maxVal被认为是强边缘点（肯定为边缘点），处于二者之间的被认为是弱边缘点<br> 5）边缘连接：对于弱边缘点，我们需要查看改点是否与某个强边缘点存在连通性，若存在，则认为是边缘；若不存在，则抛弃掉</p> 
</blockquote> 
<ul><li>OpenCv的实现：</li></ul> 
<pre><code class="prism language-python">cv2<span class="token punctuation">.</span>Canny<span class="token punctuation">(</span>image<span class="token punctuation">,</span> threshold1<span class="token punctuation">,</span> threshold2<span class="token punctuation">[</span><span class="token punctuation">,</span> edges<span class="token punctuation">[</span><span class="token punctuation">,</span> apertureSize<span class="token punctuation">[</span><span class="token punctuation">,</span> L2gradient<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> edges
<span class="token number">1</span>）image：单通道的<span class="token number">8</span><span class="token operator">-</span>bit的输入图像
<span class="token number">2</span>）threshold1：双阈值中的第一个阈值
<span class="token number">3</span>）threshold2：双阈值中的第二个阈值
<span class="token number">4</span>）edges：输出的边缘图，与输入图像具有相同的尺寸和类型
<span class="token number">5</span>）apertureSize：Sobel算子的孔径大小
<span class="token number">6</span>）L2gradient：是否采用L2范数计算梯度幅值，默认为<span class="token boolean">False</span>，即采用L1范数
</code></pre> 
<ul><li>L2gradient含义如下：<br> <img src="https://images2.imgbox.com/e5/30/kpPTfhst_o.png" alt="在这里插入图片描述"><br> 参考链接：<a href="https://blog.csdn.net/weixin_42272768/article/details/111244896">https://blog.csdn.net/weixin_42272768/article/details/111244896</a></li></ul> 
<h2><a id="_314"></a>六、图像分割</h2> 
<h3><a id="61_315"></a>6.1、阈值分割</h3> 
<ul><li>根据图像的灰度直方图设定不同的阈值进行像素分类，使灰度值在同一范围内的像素标记为同一区域从而实现图像中不同部分的分割。</li></ul> 
<h3><a id="62_317"></a>6.2、区域生长法</h3> 
<ul><li>区域生长法首先通过设定一定的规则选取图像中感兴趣区域的种子点，然后设定一致性特征判定规则并基于该准则考虑种子点与周围像素的特征相关性，将具有一致性特征的像素点合并到一起实现种子区域的扩展和生长。</li></ul> 
<h3><a id="63_319"></a>6.3、分裂合并法</h3> 
<ul><li>分裂合并法首先将图像统一分割为相同的小区域，然后确定一个分裂合并的准则以判断各区域特征是否具有一致性，当某个区域符合所设定的分裂的准则将该区域分裂为一定数量的子区域，同时当周围的子区域满足一致性准则时将它们合并到一起，迭代重复上述过程直到所有区域不能够继续分裂合并为止。</li></ul> 
<h3><a id="64_321"></a>6.4、分水岭分割</h3> 
<h3><a id="65_322"></a>6.5、聚类分割算法</h3> 
<h3><a id="66_323"></a>6.6、水平集分割</h3> 
<h3><a id="67Graph_Cut_324"></a>6.7、Graph Cut分割</h3> 
<h2><a id="_326"></a>七、图像表达与描述</h2> 
<h3><a id="71LBP_327"></a>7.1、全局特征：LBP</h3> 
<ul><li>LBP（Local Binary Pattern，局部二值模式）是一种描述图像局部纹理特征的描述符，常用于图像分类、人脸识别和目标检测等领域，具有旋转不变性和灰度不变性。</li><li>从LBP的名字上看，局部实现二值，就是说采用一个模板，将其转化为二值，再进行存储。LBP特征的实现过程如下：</li></ul> 
<blockquote> 
 <p>1）将输入图像转换为灰度图像，一般输入图像为灰度图像<br> 2）采用一个3*3的模板，类似卷积，在图像上依次滑动，对于模板内的每个像素都与中心点的像素进行比较：如果大于等于中心点像素，该位置编码为1；否则编码为0<br> 3）然后对于周围8个像素编码完成后，以顺时针或者逆时针的顺序排列，得到一个8位二进制数，可转换为十进制数字（0-255之间）<br> 4）使用该十进制数字替换中心点像素，即为其的LBP值，遍历完整个图像，得到的就是LBP特征，描述了纹理特征<br> 5）后续也可以对LBP特征图进行直方图的统计，得到LBP特征向量<br> <img src="https://images2.imgbox.com/99/3d/d57MTbW6_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<ul><li>灰度不变性：如果灰度值按比例进行缩放，那么最后相对大小还是不变的，因此LBP特征具有灰度不变性</li><li>旋转不变性：如果得到的8位二进制数字不断旋转，并选择其中最小值最为LBP特征值，那么无论怎么进行旋转，LBP特征图都不变，因此采用这种方式，LBP特征具有旋转不变性</li><li>OpenCv的实现：</li></ul> 
<h3><a id="72HOG_339"></a>7.2、简单局部特征：HOG</h3> 
<ul><li>HOG（Histogram of Oriented Gridients，方向梯度直方图）是用于表征图像局部梯度方向和梯度强度分布的描述子</li><li>HOG特征检测的步骤:</li></ul> 
<blockquote> 
 <p>1）图像预处理：例如，图像缩放、灰度化、伽马校正等<br> 2）梯度计算：在一个8*8的grid cell（官方设定的）中，先计算x方向和y方向的梯度，即水平方向的梯度和垂直方向的梯度，然后就可以计算出每个像素点的梯度幅度和梯度方向：<br> <img src="https://images2.imgbox.com/67/d5/YzMyjVzE_o.png" alt="在这里插入图片描述"><br> 3）计算方向梯度直方图：对梯度方向划分为9个bin，不断累加grid cell中的梯度幅值到9个bin中以构建方向梯度直方图，最后获取9维的向量<br> 4）block归一化：为了减轻光照变化的影响，对包含4个grid cell的16 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          × 
         
        
       
         \times 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span></span> 16的block进行归一化，得到36维的向量（16 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          × 
         
        
       
         \times 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span></span> 16的block在原始图像中每隔8个像素移动）<br> 5）计算得到HOG特征：假如输入图像为64 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          × 
         
        
       
         \times 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span></span> 128，共有7 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          × 
         
        
       
         \times 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span></span> 15=105个block，最终得到的HOG特征为105 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          × 
         
        
       
         \times 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span></span> 36 = 3780维向量</p> 
</blockquote> 
<h4><a id="721_348"></a>7.2.1、梯度幅度和方向计算</h4> 
<ul><li>可以通过ksize = 1的Sobel算子计算x方向和y方向的梯度</li><li>OpenCv的实现：</li></ul> 
<pre><code class="prism language-python">gx <span class="token operator">=</span> cv2<span class="token punctuation">.</span>Sobel<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ksize<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
gy <span class="token operator">=</span> cv2<span class="token punctuation">.</span>Sobel<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> ksize<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
mag<span class="token punctuation">,</span> angle <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cartToPolar<span class="token punctuation">(</span>gx<span class="token punctuation">,</span> gy<span class="token punctuation">,</span> angleInDegrees<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>

cv2<span class="token punctuation">.</span>cartToPolar<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">[</span><span class="token punctuation">,</span> magnitude<span class="token punctuation">[</span><span class="token punctuation">,</span> angle<span class="token punctuation">[</span><span class="token punctuation">,</span> angleInDegrees<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> magnitude<span class="token punctuation">,</span> angle
计算2D向量的幅值和角度
<span class="token number">1</span>）x：x坐标的数组，必须为单精度或者双精度的浮点值数组
<span class="token number">2</span>）y：y坐标的数组
<span class="token number">3</span>）angleInDegrees：角度angle的输出是否为弧度值，默认是弧度值
</code></pre> 
<p><img src="https://images2.imgbox.com/4e/62/8u3P1VzK_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="722grid_cell_364"></a>7.2.2、计算grid cell中的方向梯度直方图</h4> 
<ul><li>在8*8的grid cell中建立方向梯度直方图：根据计算到的幅值和方向，对0-180度的方向划分为9个bin，将对应度数的幅值累加到对应的bin中。<br> <img src="https://images2.imgbox.com/52/e3/jOj7hYYn_o.png" alt="在这里插入图片描述"></li><li>累加过程中需要注意的是：如果角度为10度，则平均分到两个bin中；如果角度位于160-180之间，例如165度，按比例分配到bin = 0和160中<br> <img src="https://images2.imgbox.com/b1/4c/vCIZqKcS_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/dc/b4/mzbmsZqZ_o.png" alt="在这里插入图片描述"></li><li>最终累加结束以后，可以获取一个9维的向量，例如：<br> <img src="https://images2.imgbox.com/44/a4/kT4uAwoO_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="723block_372"></a>7.2.3、block归一化</h4> 
<ul><li>理想情况下，我们希望描述符独立于光照变化。因此，对直方图进行“归一化”，以便它们不受光照变化的影响。</li><li>具体实现：一个包含4个grid cell的block进行归一化（L2/L1）<br> <img src="https://images2.imgbox.com/e6/0d/D8BPZcfT_o.png" alt="在这里插入图片描述">参考链接：<a href="https://blog.csdn.net/yohnyang/article/details/129077773">https://blog.csdn.net/yohnyang/article/details/129077773</a></li></ul> 
<h3><a id="73HarrisDoG_MSERSIFT_378"></a>7.3、基于关键点检测的局部特征：Harris角点、块检测(DoG, MSER)、SIFT</h3> 
<ul><li>SIFT特征描述子生成方法</li><li>SIFT特征如何实现亮度、平移、旋转、缩放变换的不变性</li></ul> 
<h4><a id="731SIFT_381"></a>7.3.1、SIFT特征</h4> 
<ul><li>SIFT特征全称是Scale Invariant Feature Transform，即尺度不变特征变换，具有旋转不变性、尺度不变性、亮度不变性。</li><li>计算过程如下：</li></ul> 
<blockquote> 
 <p>1）构建高斯差分金字塔，并进行尺度空间的极值检测，极值点即为关键点<br> 2）特征点/关键点的定位<br> 3）特征点/关键点的方向确定：构建关键点的梯度方向直方图，并进行统计得到主方向<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          θ 
         
        
       
         \theta 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span></span></span></span></span>，即可得到关键点的信息：(x, y, <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          σ 
         
        
       
         \sigma 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">σ</span></span></span></span></span>, <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          θ 
         
        
       
         \theta 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span></span></span></span></span>)<br> 4）特征描述子的计算：先根据主方向对关键点邻域内的梯度位置和方向旋转<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          θ 
         
        
       
         \theta 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span></span></span></span></span>与主方向对齐以保证旋转不变性，再计算关键点周围4个或16个4*4的grid cell的HOG特征（方向梯度直方图统计），最后得到4<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          × 
         
        
       
         \times 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span></span> 8 = 32或者16<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          × 
         
        
       
         \times 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span></span> 8=128维的特征向量</p> 
</blockquote> 
<h5><a id="1Difference_of_GaussianDoG_388"></a>1）构建高斯差分金字塔（Difference of Gaussian，DoG）并进行尺度空间极值检测</h5> 
<ul><li><strong>高斯尺度空间</strong>：使用不同的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          σ 
         
        
       
         \sigma 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">σ</span></span></span></span></span>值的高斯核对图像进行卷积操作，就可以得到不同<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          σ 
         
        
       
         \sigma 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">σ</span></span></span></span></span>的高斯尺度空间，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          σ 
         
        
       
         \sigma 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">σ</span></span></span></span></span>可以认为是尺度比例因子，越小，对应的尺度越小，其图像就越清晰。<br> <img src="https://images2.imgbox.com/0d/a0/Tw4HVPaA_o.png" alt="在这里插入图片描述"></li><li><strong>高斯差分尺度空间（Difference of Gaussian，DoG尺度空间）</strong>：将相邻的两个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          σ 
         
        
       
         \sigma 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">σ</span></span></span></span></span>值的尺度空间的图像相减就可以构建出高斯查分尺度空间：<br> <img src="https://images2.imgbox.com/cc/3b/yZ7IFOE5_o.png" alt="在这里插入图片描述"></li><li><strong>高斯金字塔</strong>：对图像进行不同分辨率的下采样，并在每一层图像中构建高斯尺度空间</li><li><strong>高斯差分金字塔</strong>：构建好高斯金字塔以后，在相邻的高斯尺度空间相减，就可以得到高斯差分金字塔（DoG金字塔）<br> <img src="https://images2.imgbox.com/d2/88/8iEnEGTO_o.png" alt="在这里插入图片描述"></li><li>DoG尺度空间的极值检测：在高斯差分金字塔的每一层中，对于每一个像素点，将其与同一个尺度空间和相邻尺度空间的所有相邻点进行比较，当其大于或者小于所有相邻点时，我们认为该点为极值点，例如下图，需要与8+9*2=26个像素点进行比较<br> <img src="https://images2.imgbox.com/73/bc/Zht584uc_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="2_398"></a>2）特征点/关键点定位</h5> 
<ul><li>对DoG尺度空间函数—D(x,y,σ) —进行曲线拟合（泰勒二次展开求极值）寻找极值点，进行精确地位置估计</li></ul> 
<h5><a id="3_400"></a>3）特征点/关键点方向的确定</h5> 
<ul><li>确定了各层每个尺度空间中的关键点以后，计算关键点的梯度幅值和梯度方向<br> <img src="https://images2.imgbox.com/9c/4c/wOXxbqlp_o.png" alt="在这里插入图片描述"></li><li>类似HOG特征，通过设定不同数量的bin进行方向梯度直方图的统计<br> <img src="https://images2.imgbox.com/18/bc/UINMu3U1_o.png" alt="在这里插入图片描述"></li><li>于是就可以确定主方向：峰值点为主方向</li><li>因此每个关键点就可以得到4个值(x, y, <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          σ 
         
        
       
         \sigma 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">σ</span></span></span></span></span>, <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          θ 
         
        
       
         \theta 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span></span></span></span></span>)，即位置、尺度、方向。</li></ul> 
<h5><a id="4_408"></a>4）计算特征描述子</h5> 
<ul><li>特征描述子需要包括关键点以及关键点周围邻域（以关键点为中心的4个4$\times$4的grid cell）的像素点的方向梯度直方图的统计信息（HOG特征）</li><li>为了保证特征向量具有旋转不变性，需要以特征点为中心，将特征点附近邻域内图像梯度的位置和方向旋转一个方向角θ，即将原图像x轴转到与主方向相同的方向。<br> <img src="https://images2.imgbox.com/10/95/3eieKw7q_o.png" alt="在这里插入图片描述"></li><li>对于4个grid cell分别进行方向梯度直方图的统计，得到4个8维向量，得到32维向量<br> <img src="https://images2.imgbox.com/cb/c9/sVUdtUyf_o.png" alt="在这里插入图片描述"></li><li>在实际的计算过程中，为了增强匹配的稳健性，Lowe建议对每个关键点使用4×4(16像素x16像素)共16个种子点/grid cell来描述，这样一个关键点就可以产生128维的SIFT特征向量。<br> <img src="https://images2.imgbox.com/2b/5f/P1lSK4oW_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="5OpenCv_416"></a>5）OpenCv的实现</h5> 
<pre><code class="prism language-python">cv2<span class="token punctuation">.</span>SIFT<span class="token punctuation">(</span><span class="token punctuation">[</span>nfeatures<span class="token punctuation">[</span><span class="token punctuation">,</span> nOctaveLayers<span class="token punctuation">[</span><span class="token punctuation">,</span> contrastThreshold<span class="token punctuation">[</span><span class="token punctuation">,</span> edgeThreshold<span class="token punctuation">[</span><span class="token punctuation">,</span> sigma<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
构建SIFT特征检测器的<span class="token builtin">object</span>
sift<span class="token punctuation">.</span>detect<span class="token punctuation">(</span>image<span class="token punctuation">[</span><span class="token punctuation">,</span> mask<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> keypoints
<span class="token number">1</span>）image：输入的<span class="token number">8</span>位灰度图像
<span class="token number">2</span>）mask：可选的输入掩码，标记我们应该检测sift特征的区域
<span class="token number">3</span>）输出的关键点向量
sift<span class="token punctuation">.</span>compute<span class="token punctuation">(</span>image<span class="token punctuation">,</span> keypoints<span class="token punctuation">[</span><span class="token punctuation">,</span> descriptors<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> keypoints<span class="token punctuation">,</span> descriptors
descriptors：输出的描述子矩阵
</code></pre> 
<p>参考链接：<a href="https://blog.csdn.net/shyjhyp11/article/details/118794045">https://blog.csdn.net/shyjhyp11/article/details/118794045</a></p> 
<h5><a id="6_430"></a>6）旋转不变性、尺度不变性、亮度不变性</h5> 
<ul><li>旋转不变性：在计算SIFT特征时，会确定关键点的主方向，并会相对于主方向计算邻域内的SIFT特征描述子，即使图像旋转，主方向也旋转，描述子不会变</li><li>尺度不变性：使用了高斯差分金字塔检测关键点，在不同的尺度空间进行检测，保证了尺度的不变性</li><li>亮度不变性：在计算特征描述子时，是统计了方向梯度直方图（HOG特征），实际上不是绝对亮度信息，因此可以保持亮度不变性。</li></ul> 
<h2><a id="_434"></a>八、图像识别</h2> 
<h3><a id="81Hough_435"></a>8.1、Hough变换</h3> 
<h4><a id="811_436"></a>8.1.1、算法原理</h4> 
<ul><li> <p>Hough（霍夫）变换是将原始图像的坐标空间转换到参数空间，即在原始图像坐标系下的一个点对应了参数坐标系中的一条直线，那么原始图像坐标系下的一条直线对应了参数坐标系中的多条直线相交的点。<br> <img src="https://images2.imgbox.com/28/02/eFOcbyfp_o.png" alt="在这里插入图片描述"></p> </li><li> <p>由此，Hough变换可以检测直线，通过将每个点映射到参数空间，并统计有多少个直线的交点，根据交点就可以确定对应直线的斜率与截距，最终检测出直线。</p> </li><li> <p>OpenCv的实现：</p> </li></ul> 
<pre><code class="prism language-python">cv2<span class="token punctuation">.</span>HoughLinesP<span class="token punctuation">(</span>image<span class="token punctuation">,</span> rho<span class="token punctuation">,</span> theta<span class="token punctuation">,</span> threshold<span class="token punctuation">[</span><span class="token punctuation">,</span> lines<span class="token punctuation">[</span><span class="token punctuation">,</span> minLineLength<span class="token punctuation">[</span><span class="token punctuation">,</span> maxLineGap<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
使用概率霍夫变换在二值图像中查找线段。
<span class="token number">1</span>）image：<span class="token number">8</span>位，单通道二值图像
<span class="token number">2</span>）rho：累加器的距离分辨率，以pixel为单位，一般为<span class="token number">1</span>像素
<span class="token number">3</span>）theta：累加器的角度分辨率，以弧度为单位，一般为<span class="token number">1</span>度
<span class="token number">4</span>）threshold：累加器的阈值，只有大于阈值的线段才会被返回（检测一条直线所需最少的交点。）
<span class="token number">5</span>）minLineLength：最小线段长度，小于改长度不会返回
<span class="token number">6</span>）maxLineGap：表示能被认为在一条直线上的两点的最大距离。
返回lines：输出线段的向量，（x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2）为线段两端点的坐标
</code></pre> 
<h4><a id="812_455"></a>8.1.2、检测直线、圆、椭圆</h4> 
<h4><a id="813hough_456"></a>8.1.3、广义hough变换</h4> 
<h3><a id="82_457"></a>8.2、距离变换</h3>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e0b786c7048826c9ab892f31009bb94b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FPGA学习--蜂鸣器播放音乐</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0642c39e3abda311f22785cf79bf75f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">阿里云OSS的使用----上传文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>