<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构--查找 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构--查找" />
<meta property="og:description" content="目录
1. 查找的基本概念
2. 线性表的查找
3. 树表的查找
3.1 二叉排序树
3.1.1 定义:
3.1.2 存储结构：
3.1.3 二叉排序树的查找
3.1.4 二叉排序树的插入
3.1.5 二叉排序树删除
3.2 平衡二叉树（AVL
3.2.1 为什么要有平衡二叉树
3.2.2 定义
3.3 B-树
3.3.1 m阶的B-树的结构定义：
3.3.2 B-树的性质：
3.3.3 B-树的查找
3.3.4 B-树的插入
3.3.5 B-树的中序遍历
3.3.6 B-树的删除(存疑
3.4 B&#43;树
3.5 红黑树
4. 哈希表的查找
4.1 哈希函数
4.2 哈希函数的构造方法
4.2.1 直接定址法
4.2.2 数字分析法
4.2.3 平方取中法
4.2.4 折叠法
​编辑
4.2.5 除留余数法
4.3 哈希冲突
4.3.1 开放地址法
4.3.2 二次探测
4.3.3 双哈希
4.3.4 拉链法" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/ae48a7b6c05ac9a255e76c43e6ed3f59/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-27T19:07:45+08:00" />
<meta property="article:modified_time" content="2023-12-27T19:07:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构--查找</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="1.%20%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#1.%20%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">1. 查找的基本概念</a></p> 
 <p id="2.%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#2.%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">2. 线性表的查找</a></p> 
 <p id="3.%20%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#3.%20%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">3. 树表的查找</a></p> 
 <p id="3.1%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-toc" style="margin-left:120px;"><a href="#3.1%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91" rel="nofollow">3.1 二叉排序树</a></p> 
 <p id="3.1.1%20%E5%AE%9A%E4%B9%89%3A-toc" style="margin-left:160px;"><a href="#3.1.1%20%E5%AE%9A%E4%B9%89%3A" rel="nofollow">3.1.1 定义:</a></p> 
 <p id="%C2%A03.1.2%20%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%C2%A03.1.2%20%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A" rel="nofollow"> 3.1.2 存储结构：</a></p> 
 <p id="%C2%A03.1.3%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:160px;"><a href="#%C2%A03.1.3%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow"> 3.1.3 二叉排序树的查找</a></p> 
 <p id="3.1.4%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:160px;"><a href="#3.1.4%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">3.1.4 二叉排序树的插入</a></p> 
 <p id="3.1.5%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%88%A0%E9%99%A4-toc" style="margin-left:160px;"><a href="#3.1.5%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%88%A0%E9%99%A4" rel="nofollow">3.1.5 二叉排序树删除</a></p> 
 <p id="3.2%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL-toc" style="margin-left:120px;"><a href="#3.2%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL" rel="nofollow">3.2 平衡二叉树（AVL</a></p> 
 <p id="3.2.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:160px;"><a href="#3.2.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">3.2.1 为什么要有平衡二叉树</a></p> 
 <p id="3.2.2%20%E5%AE%9A%E4%B9%89-toc" style="margin-left:160px;"><a href="#3.2.2%20%E5%AE%9A%E4%B9%89" rel="nofollow">3.2.2 定义</a></p> 
 <p id="3.3%20B-%E6%A0%91-toc" style="margin-left:120px;"><a href="#3.3%20B-%E6%A0%91" rel="nofollow">3.3 B-树</a></p> 
 <p id="3.3.1%20m%E9%98%B6%E7%9A%84B-%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89%EF%BC%9A-toc" style="margin-left:160px;"><a href="#3.3.1%20m%E9%98%B6%E7%9A%84B-%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89%EF%BC%9A" rel="nofollow">3.3.1 m阶的B-树的结构定义：</a></p> 
 <p id="3.3.2%20B-%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%9A-toc" style="margin-left:160px;"><a href="#3.3.2%20B-%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%9A" rel="nofollow">3.3.2 B-树的性质：</a></p> 
 <p id="%C2%A03.3.3%20B-%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:160px;"><a href="#%C2%A03.3.3%20B-%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow"> 3.3.3 B-树的查找</a></p> 
 <p id="3.3.4%20B-%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:160px;"><a href="#3.3.4%20B-%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">3.3.4 B-树的插入</a></p> 
 <p id="3.3.5%20B-%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:160px;"><a href="#3.3.5%20B-%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">3.3.5 B-树的中序遍历</a></p> 
 <p id="3.3.6%20B-%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4(%E5%AD%98%E7%96%91-toc" style="margin-left:160px;"><a href="#3.3.6%20B-%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%28%E5%AD%98%E7%96%91" rel="nofollow">3.3.6 B-树的删除(存疑</a></p> 
 <p id="3.4%20B%2B%E6%A0%91-toc" style="margin-left:120px;"><a href="#3.4%20B%2B%E6%A0%91" rel="nofollow">3.4 B+树</a></p> 
 <p id="3.5%20%E7%BA%A2%E9%BB%91%E6%A0%91-toc" style="margin-left:120px;"><a href="#3.5%20%E7%BA%A2%E9%BB%91%E6%A0%91" rel="nofollow">3.5 红黑树</a></p> 
 <p id="4.%20%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#4.%20%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">4. 哈希表的查找</a></p> 
 <p id="%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0-toc" style="margin-left:160px;"><a href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0" rel="nofollow">4.1 哈希函数</a></p> 
 <p id="%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:160px;"><a href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">4.2 哈希函数的构造方法</a></p> 
 <p id="%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95-toc" style="margin-left:200px;"><a href="#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95" rel="nofollow">4.2.1 直接定址法</a></p> 
 <p id="%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95-toc" style="margin-left:200px;"><a href="#%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95" rel="nofollow">4.2.2 数字分析法</a></p> 
 <p id="%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95-toc" style="margin-left:200px;"><a href="#%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95" rel="nofollow">4.2.3 平方取中法</a></p> 
 <p id="%E6%8A%98%E5%8F%A0%E6%B3%95-toc" style="margin-left:200px;"><a href="#%E6%8A%98%E5%8F%A0%E6%B3%95" rel="nofollow">4.2.4 折叠法</a></p> 
 <p id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0-toc" style="margin-left:200px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0" rel="nofollow">​编辑</a></p> 
 <p id="%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95-toc" style="margin-left:200px;"><a href="#%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95" rel="nofollow">4.2.5 除留余数法</a></p> 
 <p id="%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81-toc" style="margin-left:160px;"><a href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81" rel="nofollow">4.3 哈希冲突</a></p> 
 <p id="%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95-toc" style="margin-left:200px;"><a href="#%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95" rel="nofollow">4.3.1 开放地址法</a></p> 
 <p id="%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B-toc" style="margin-left:200px;"><a href="#%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B" rel="nofollow">4.3.2 二次探测</a></p> 
 <p id="%E5%8F%8C%E5%93%88%E5%B8%8C-toc" style="margin-left:200px;"><a href="#%E5%8F%8C%E5%93%88%E5%B8%8C" rel="nofollow">4.3.3 双哈希</a></p> 
 <p id="%E6%8B%89%E9%93%BE%E6%B3%95-toc" style="margin-left:200px;"><a href="#%E6%8B%89%E9%93%BE%E6%B3%95" rel="nofollow">4.3.4 拉链法</a></p> 
 <p id="4.4%20%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%95%88%E7%8E%87-toc" style="margin-left:160px;"><a href="#4.4%20%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%95%88%E7%8E%87" rel="nofollow">4.4 哈希表的效率</a></p> 
 <hr id="hr-toc"> 
 <p></p> 
 <hr> 
 <p></p> 
</blockquote> 
<h4 id="1.%20%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1. 查找的基本概念</h4> 
<p>根据给定的值，在查找表中确定一个其关键字等于给定值的数据元素。</p> 
<p><strong>主关键字：</strong></p> 
<p><strong>次关键字：</strong></p> 
<p></p> 
<p><strong>查找表分类</strong></p> 
<p>静态查找表（仅查询</p> 
<p>动态查找表（有删除和插入</p> 
<h4 id="2.%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE">2. 线性表的查找</h4> 
<h4 id="3.%20%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE">3. 树表的查找</h4> 
<h5 id="3.1%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91">3.1 二叉排序树</h5> 
<h6 id="3.1.1%20%E5%AE%9A%E4%B9%89%3A">3.1.1 定义:</h6> 
<p>1. 就是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；<br> 2. 若它的右子树不空，则右子树上所有节点的值均大于其根节点的值。</p> 
<p>3. 其左右子树本身又各是一棵二叉排序树</p> 
<p><img alt="" height="332" src="https://images2.imgbox.com/f9/e9/M5LKb9Hp_o.png" width="684"></p> 
<h6 id="%C2%A03.1.2%20%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A"> 3.1.2 存储结构：</h6> 
<pre><code class="language-cpp">typedef int DataType;
typedef struct BST_Node {
    DataType data;
    struct BST_Node *lchild, *rchild;
}BST_T, *BST_P;
</code></pre> 
<pre><code class="language-cpp">void CreateBST(BST_P *T, int a[], int n)
{
    int i;
    for (i = 0; i &lt; n; i++)
    {
        Insert_BST(T, a[i]);
    }
}</code></pre> 
<h6 id="%C2%A03.1.3%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"> 3.1.3 二叉排序树的查找</h6> 
<p>要在二叉树中找出查找最大最小元素是极简单的事情，从根节点一直往左走，直到无路可走就可得到最小值；从根节点一直往右走，直到无路可走，就可以得到最大值。</p> 
<p>查找最小关键字：</p> 
<pre><code class="language-cpp">BST_P SearchMin(BST_P root)
{
    if (root == NULL)
        return NULL;
    if (root-&gt;lchild == NULL)
        return root;
    else  //一直往左孩子找，直到没有左孩子的结点  
        return SearchMin(root-&gt;lchild);
}</code></pre> 
<p>查找最大关键字：</p> 
<pre><code class="language-cpp">BST_P SearchMax(BST_P root)
{
    if (root == NULL)
        return NULL;
    if (root-&gt;rchild == NULL)
        return root;
    else  //一直往右孩子找，直到没有右孩子的结点  
        return SearchMax(root-&gt;rchild);
}</code></pre> 
<p> 递归版查找（找到返回关键字的结点指针，没找到返回NULL）：</p> 
<pre><code class="language-cpp">BST_P Search_BST(BST_P root, DataType key)
{
    if (root == NULL)
        return NULL;
    if (key &gt; root-&gt;data) //查找右子树  
        return Search_BST(root-&gt;rchild, key);
    else if (key &lt; root-&gt;data) //查找左子树  
        return Search_BST(root-&gt;lchild, key);
    else
        return root;
}</code></pre> 
<p>非递归版查找：</p> 
<pre><code class="language-cpp">BST_P Search_BST(BST_P root, DataType key)
{
    BST_P p = root;
    while (p) 
    {       
        if (p-&gt;data == key)  return p;
        p = (key &lt; p-&gt;data) ? p-&gt;lchild : p-&gt;rchild;
    }
    return NULL;
}</code></pre> 
<p></p> 
<h6 id="3.1.4%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5">3.1.4 二叉排序树的插入</h6> 
<p>插入新元素时，可以从根节点开始，遇键值较大者就向左，遇键值较小者就向右，一直到末端，就是插入点。</p> 
<pre><code class="language-cpp">void Insert_BST(BST_P *root, DataType data)
{
    //初始化插入节点
    BST_P p = (BST_P)malloc(sizeof(struct BST_Node));
    if (!p) return;
    p-&gt;data = data;
    p-&gt;lchild = p-&gt;rchild = NULL;

    //空树时，直接作为根节点
    if (*root == NULL)
    {
        *root = p;
        return;
    }

    //是否存在，已存在则返回，不插入
    if (Search_BST(root, data) != NULL) return; 

    //进行插入，首先找到要插入的位置的父节点
    BST_P tnode = NULL, troot = *root;
    while (troot)
    {       
        tnode = troot;
        troot = (data &lt; troot-&gt;data) ? troot-&gt;lchild : troot-&gt;rchild;
    }
    if (data &lt; tnode-&gt;data)
        tnode-&gt;lchild = p;
    else
        tnode-&gt;rchild = p;
}</code></pre> 
<h6 id="3.1.5%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%88%A0%E9%99%A4">3.1.5 二叉排序树删除</h6> 
<p>对于二叉排序树中的节点A，对它的删除分为两种情况：<br> 1、如果A只有一个子节点，就直接将A的子节点连至A的父节点上，并将A删除；</p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/b6/b4/xtjqrwoC_o.png" width="700"></p> 
<p>2、如果A有两个子节点，我们就以右子树内的最小节点取代A，怎么得最小节点，前有有说。</p> 
<p><img alt="" height="960" src="https://images2.imgbox.com/dd/40/w80hH24q_o.jpg" width="1200"></p> 
<p>删除节点代码：</p> 
<pre><code class="language-cpp">void DeleteBSTNode(BST_P *root, DataType data)
{
    BST_P p = *root, parent = NULL, s = NULL;

    if (!p) return;

    if (p-&gt;data == data) //找到要删除的节点了
    {
        /* It's a leaf node */
        if (!p-&gt;rchild &amp;&amp; !p-&gt;lchild) 
            *root = NULL;

        // 只有一个左节点
        else if (!p-&gt;rchild&amp;&amp;p-&gt;lchild) 
            *root = p-&gt;lchild;

        // 只有一个右节点
        else if (!p-&gt;lchild&amp;&amp;p-&gt;rchild) 
            *root = p-&gt;rchild;

        //左右节点都不空
        else 
        {
            s = p-&gt;rchild;
            /* the s without left child */
            if (!s-&gt;lchild)
                s-&gt;lchild = p-&gt;lchild;
            /* the s have left child */
            else 
            {
                /* find the smallest node in the left subtree of s */
                while (s-&gt;lchild) 
                {
                    /* record the parent node of s */
                    parent = s;
                    s = s-&gt;lchild;
                }
                parent-&gt;lchild = s-&gt;rchild;
                s-&gt;lchild = p-&gt;lchild;
                s-&gt;rchild = p-&gt;rchild;
            }
            *root = s;
        }
        free(p);
    }
    else if (data &gt; p-&gt;data) //向右找
        DeleteBSTNode(&amp;(p-&gt;rchild), data);
    else if (data &lt; p-&gt;data) //向左找
        DeleteBSTNode(&amp;(p-&gt;lchild), data);
}</code></pre> 
<h5 id="3.2%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL">3.2 平衡二叉树（AVL</h5> 
<p>在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为<strong>高度平衡树</strong>。</p> 
<h6 id="3.2.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">3.2.1 为什么要有平衡二叉树</h6> 
<p>二叉搜索树一定程度上可以提高搜索效率，但是当原序列有序时，例如序列 A = {1，2，3，4，5，6}，构造二叉搜索树如图 1.1。依据此序列构造的二叉搜索树为右斜树，同时二叉树退化成单链表，搜索效率降低为 O(n)。</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="810" src="https://images2.imgbox.com/c3/8d/F2mKDspS_o.png" width="1200"></p> 
<p></p> 
<p>在此二叉搜索树中查找元素 6 需要查找 6 次。</p> 
<p>二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。同样的序列 A，将其改为图 1.2 的方式存储，查找元素 6 时只需比较 3 次，查找效率提升一倍。</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="804" src="https://images2.imgbox.com/61/75/6aG8oyB1_o.png" width="1200"></p> 
<p></p> 
<p>可以看出当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。</p> 
<p><strong>这种左右子树的高度相差不超过 1 的树为平衡二叉树。</strong></p> 
<h6 id="3.2.2%20%E5%AE%9A%E4%B9%89"><strong>3.2.2 定义</strong></h6> 
<p></p> 
<p>1. 可以是空树。</p> 
<p>2. 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。</p> 
<p>平衡因子</p> 
<p><strong>定义：</strong>某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子<span style="background-color:#ff9900;">只能取 0 、1 或者 -1</span> ，分别对应着左右子树等高，左子树比较高，右子树比较高。</p> 
<p><span style="color:#fe2c24;">结点的平衡因子=结点左子树的高度-结点右子树的高度</span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f4/42/oelB1Vge_o.gif"></p> 
<p>如果在一棵AVL树中插入一个新结点后造成失衡，必须立刻重新调整树的结构，使之恢复平衡</p> 
<p>调整的基本思想</p> 
<p>·在构造二叉排序树的过程中，每插入一个结点，首先检查是否因插入而破坏了树的平衡性</p> 
<p>·若失衡，则<span style="background-color:#fef2f0;">找出最小的平衡子树</span>，<u>在保持二叉排序树特性的前提下，调整最小平衡子树使之成为新的平衡子树 </u></p> 
<blockquote> 
 <p><strong>最小失衡子树</strong>：在新插入的结点向上查找，以<span style="color:#fe2c24;">第一个</span>平衡因子的<strong>绝对值</strong>超过 1 的结点为根的子树称为最小不平衡子树。</p> 
</blockquote> 
<p>也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。</p> 
<p>3个结点</p> 
<p><strong>平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的</strong>。根据旋转的方向有两种处理方式，<strong>左旋</strong> 与 <strong>右旋</strong> 。</p> 
<p>旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。</p> 
<p><img alt="" height="960" src="https://images2.imgbox.com/66/e8/QX8xOStv_o.jpg" width="1200"></p> 
<p><img alt="" height="233" src="https://images2.imgbox.com/83/ce/EhqqV2iz_o.jpg" width="310"> <img alt="" height="230" src="https://images2.imgbox.com/da/a7/MKBZ1fXl_o.jpg" width="307"></p> 
<p><img alt="" height="232" src="https://images2.imgbox.com/cf/47/RIo9Km6n_o.jpg" width="309"> <img alt="" height="232" src="https://images2.imgbox.com/24/5f/G9g65qAG_o.jpg" width="309"></p> 
<p>平衡二叉排序树的构造</p> 
<p>在插入过程中，采用平衡旋转技术</p> 
<blockquote> 
 <p><strong>例题1</strong></p> 
 <p>设有关键码序列{5 ，4 ， 2， 8， 6， 9}构造平衡树</p> 
 <p class="img-center"><img alt="" height="359" src="https://images2.imgbox.com/25/7f/PP7L6F2g_o.jpg" width="351"></p> 
 <p><strong> 例题2</strong></p> 
 <p>设有关键码序列{16 ，3 ，7 ，11 ，9 ，26 ，18 ，14 ，15 }构造平衡树</p> 
 <p class="img-center"><img alt="" height="450" src="https://images2.imgbox.com/e5/c4/51AxLXj3_o.jpg" width="389"></p> 
</blockquote> 
<h5 id="3.3%20B-%E6%A0%91">3.3 B-树</h5> 
<p>是一种平衡的<span style="color:#fe2c24;">多分树</span></p> 
<h6 id="3.3.1%20m%E9%98%B6%E7%9A%84B-%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89%EF%BC%9A">3.3.1 m阶的B-树的结构定义：</h6> 
<p>1. 树的每个结点至多有m棵子树</p> 
<p>2. 若根结点不是叶子结点，则至少有两棵子树</p> 
<p>3. 除根结点之外的所有非终端结点至少有m/2 棵子树</p> 
<p>4. 一个包含 <img alt="x" class="mathcode" src="https://images2.imgbox.com/0b/77/l5si2XY9_o.png">个关键字的结点有 <img alt="x" class="mathcode" src="https://images2.imgbox.com/ba/40/TdyjpdhW_o.png">+1 个孩子；</p> 
<p>5. 所有叶子结点都出现在同一层次，不含任何信息</p> 
<p>6. 一个结点中的所有关键字升序排列，两个关键字 <img alt="k" class="mathcode" src="https://images2.imgbox.com/49/a5/lQHiTRyF_o.png">1 和 <img alt="k" class="mathcode" src="https://images2.imgbox.com/c8/60/GhiZWseo_o.png">2 之间的孩子结点的所有关键字 key 在 (<img alt="k" class="mathcode" src="https://images2.imgbox.com/70/71/t0VU0tom_o.png">1,<img alt="k" class="mathcode" src="https://images2.imgbox.com/d3/97/em67zS6u_o.png">2) 的范围之内。</p> 
<h6 id="3.3.2%20B-%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%9A">3.3.2 B-树的性质：</h6> 
<p>1. 树高平衡，所有叶结点都在同一层</p> 
<p>2. 关键字没有重复，父结点中的关键字是其子结点的分界</p> 
<p>3. B-树把值接近的相关记录放在同一个磁盘页中，从而利用了访问局部性原理</p> 
<p>4. B-树保证树至少有一定比例的结点是满的</p> 
<p class="img-center"><img alt="" height="308" src="https://images2.imgbox.com/24/fc/IVH2HnXX_o.jpg" width="410"></p> 
<p class="img-center"><img alt="" height="308" src="https://images2.imgbox.com/93/c6/HWcbNtMG_o.jpg" width="411"></p> 
<blockquote> 
 <p><img alt="" height="960" src="https://images2.imgbox.com/42/5e/FuwoYCVY_o.jpg" width="1200"></p> 
 <p></p> 
</blockquote> 
<h6 id="%C2%A03.3.3%20B-%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"> 3.3.3 B-树的查找</h6> 
<p><img alt="" height="248" src="https://images2.imgbox.com/3f/44/E0RgiDir_o.jpg" width="330"><img alt="" height="248" src="https://images2.imgbox.com/a0/20/ekFWcIOi_o.jpg" width="331"></p> 
<p>查找的时间取决于两个因素：</p> 
<p>1. 给定关键字所在结点的层次</p> 
<p>2. 结点中关键字的个数</p> 
<h6 id="3.3.4%20B-%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5">3.3.4 B-树的插入</h6> 
<p><strong>插入操作案例</strong></p> 
<p class="img-center"><img alt="" height="571" src="https://images2.imgbox.com/f3/45/1wbWdj6q_o.png" width="1200"></p> 
<p>我们以在上图中插入关键字 <code>I</code> 为例进行说明。其中最小度 <code>t = 2</code> ，一个结点最多可存储 <code>2t - 1 = 3</code> 个结点。</p> 
<p>第一步：访问根结点，发现插入关键字 <code>I</code> 小于 <code>P</code> , 但根结点未满，不分裂，直接访问其第一个孩子结点。</p> 
<p class="img-center"><img alt="" height="580" src="https://images2.imgbox.com/a4/c0/ySv0XqvQ_o.png" width="1200"></p> 
<p>第二步：访问结点 <code>P</code> 的第一个孩子结点 <code>[C、G、L]</code> ，发现第一个孩子结点已满，将第一个孩子结点分裂为两个：</p> 
<p></p> 
<p class="img-center"><img alt="" height="574" src="https://images2.imgbox.com/b8/79/RrFMJiex_o.png" width="1200"></p> 
<p>第三步：将结点 <code>I</code> 插入到结点 <code>L</code> 的第一个左孩子当中，发现 <code>L</code> 的第一个左孩子 <code>[H、J、K]</code> 已满，则将其分裂为两个。</p> 
<p></p> 
<p class="img-center"><img alt="" height="583" src="https://images2.imgbox.com/7a/35/zbjmZKm4_o.png" width="1200"></p> 
<p></p> 
<p>第四步：将结点 <code>I</code> 插入到结点 <code>J</code> 的第一个孩子当中，发现 <code>L</code> 的第一个孩子结点 <code>[H]</code> 未满且为叶子结点，则将 <code>I</code> 直接插入。</p> 
<p></p> 
<p class="img-center"><img alt="" height="607" src="https://images2.imgbox.com/60/1a/ZF3471rd_o.png" width="1200"></p> 
<h6 id="3.3.5%20B-%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><strong>3.3.5 B-树的中序遍历</strong></h6> 
<p>B-树的中序遍历与二叉树的中序遍历也很相似，我们从最左边的孩子结点开始，递归地打印最左边的孩子结点，然后对剩余的孩子和关键字重复相同的过程。最后，递归打印最右边的孩子.</p> 
<p class="img-center"><img alt="" height="571" src="https://images2.imgbox.com/f0/cb/o35rDF9T_o.png" width="1200"></p> 
<p>对于这个图的中序遍历结果为：</p> 
<p></p> 
<p class="img-center"><img alt="" height="119" src="https://images2.imgbox.com/4b/43/Ltqskkyi_o.png" width="1200"></p> 
<h6 id="3.3.6%20B-%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4(%E5%AD%98%E7%96%91">3.3.6 B-树的删除(存疑</h6> 
<p>B-树的删除操作相比于插入操作更为复杂，如果仅仅只是删除叶子结点中的关键字，也非常简单，但是如果删除的是内部节点的，就不得不对结点的孩子进行重新排列。</p> 
<p>与 B-树的插入操作类似，我们必须确保删除操作不违背 B-树的特性。正如插入操作中每一个结点所包含的关键字的个数不能超过 <code>2t -1</code> 一样，删除操作要保证每一个结点包含的关键字的个数不少于 <code>t -1</code> 个（除根结点允许包含比 <code>t -1</code> 少的关键字的个数。</p> 
<p>接下来一一横扫删除操作中可能出现的所有情况。</p> 
<p><strong>初始的 B-树 如图所示，其中  m<code>=3 </code> 每一个结点最多可包含 5 个关键字，至少包含 2个关键字（根结点除外）。</strong></p> 
<p class="img-center"><img alt="" height="571" src="https://images2.imgbox.com/45/91/ObXntuuI_o.png" width="1200"></p> 
<p><strong>1. 待删除的关键字 k 在结点 x 中，且 x 是叶子结点，删除关键字k</strong></p> 
<p>删除 B-树中的关键字 <code>F</code></p> 
<p></p> 
<p class="img-center"><img alt="" height="594" src="https://images2.imgbox.com/36/d9/mmbL1po0_o.png" width="1200"></p> 
<p><strong>2. 待删除的关键字 k 在结点 x 中，且 x 是内部结点，分一下三种情况</strong></p> 
<p><strong>情况一： 如果位于结点 x 中的关键字 k 之前的第一个孩子结点 y 至少有 t 个关键字，则在孩子结点 y 中找到 k 的前驱结点 <img alt="k" class="mathcode" src="https://images2.imgbox.com/b2/21/NkJj6mzR_o.png">0 ，递归地删除关键字 <img alt="k" class="mathcode" src="https://images2.imgbox.com/f0/63/9FrZMsxV_o.png">0 ，并将结点 x 中的关键字 k 替换为 <img alt="k" class="mathcode" src="https://images2.imgbox.com/24/41/jf5N2Bhz_o.png">0 .</strong></p> 
<p>删除 B-树中的关键字 <code>G</code> ，<code>G</code> 的前一个孩子结点 <code>y</code> 为 <code>[D、E、F]</code> ，包含 3个关键字，满足情况一，关键字 <code>G</code> 的直接前驱为关键 <code>F</code> ，删除 <code>F</code> ，然后将 <code>G</code> 替换为 <code>F</code> .</p> 
<p></p> 
<p class="img-center"><img alt="" height="576" src="https://images2.imgbox.com/bc/0f/Q4Ac8kdp_o.png" width="1200"></p> 
<p><strong>情况二： y 所包含的关键字少于 t 个关键字，则检查结点 x 中关键字 k 的后一个孩子结点 z 包含的关键字的个数，如果 z 包含的关键字的个数至少为 t 个，则在 z 中找到关键字 k 的直接后继<img alt="k" class="mathcode" src="https://images2.imgbox.com/c6/41/Z15qmGZj_o.png">0 ,然后删除 <img alt="k" class="mathcode" src="https://images2.imgbox.com/85/ae/0Y2KOhWG_o.png">0 ，并将关键 k 替换为 <img alt="k" class="mathcode" src="https://images2.imgbox.com/c3/e5/RvQswolC_o.png">0 .</strong></p> 
<p>删除 B-树中的关键字 <code>C</code> , <code>y</code> 中包含的关键字的个数为 2 个，小于 <code>t = 3</code> ,结点 <code>[C、G、L]</code> 中的 关键字 <code>C</code> 的后一个孩子 z 为 <code>[D、E、F]</code> 包含 3 个关键字，关键字 <code>C</code> 的直接后继为 <code>D</code> ，删除 <code>D</code> ，然后将 <code>C</code> 替换为 <code>D</code> .</p> 
<p></p> 
<p class="img-center"><img alt="" height="598" src="https://images2.imgbox.com/fe/d7/tB9Dk5G2_o.png" width="1200"></p> 
<p><strong>情况三：如果 y 和 z 都只包含 t -1 个关键字，合并关键字 k 和所有 z 中的关键字到 结点 y 中，结点 x 将失去关键字 k 和孩子结点 z，y 此时包含 2t -1 个关键字，释放结点 z 的空间并递归地从结点 y 中删除关键字 k.</strong></p> 
<p>为了说明这种情况，我们将用下图进行说明。</p> 
<p></p> 
<p class="img-center"><img alt="" height="574" src="https://images2.imgbox.com/34/cc/TvRLcFD9_o.png" width="1200"></p> 
<p>删除关键字 <code>C</code> , 结点 y 包含 2 个关键字 ，结点 z 包含 2 个关键字，均等于 <code>t - 1 = 2</code> 个， 合并关键字 <code>C</code> 和结点 z 中的所有关键字到结点 <code>y</code> 当中：</p> 
<p></p> 
<p class="img-center"><img alt="" height="598" src="https://images2.imgbox.com/d8/b7/jDuH7QUn_o.png" width="1200"></p> 
<p>此时结点 y 为叶子结点，直接删除关键字 <code>C</code></p> 
<p></p> 
<p class="img-center"><img alt="" height="566" src="https://images2.imgbox.com/a2/a8/reOrah66_o.png" width="1200"></p> 
<p><strong>3. 如果关键字 k 不在当前在内部结点 x 中，则确定必包含 k 的子树的根结点 <code>x.c(i)</code> （如果 k 确实在 B-树中）。如果 <code>x.c(i)</code> 只有 t - 1 个关键字，必须执行下面两种情况进行处理：</strong></p> 
<p>首先我们得确认什么是当前内部结点 x ，什么是 <code>x.c(i)</code> ,如下图所示， P 现在不是根结点，而是完整 B-树的一个子树的根结点：</p> 
<p></p> 
<p class="img-center"><img alt="" height="709" src="https://images2.imgbox.com/a9/7c/nbWwf1Vp_o.png" width="1200"></p> 
<p><strong>情况二：如果 <code>x.c(i)</code> 及 <code>x.c(i)</code> 的所有相邻兄弟都只包含 t - 1 个关键字，则将 <code>x.c(i)</code> 与 一个兄弟合并，即将 x 的一个关键字移动至新合并的结点，使之成为该结点的中间关键字，将合并后的结点作为新的 x 结点 .</strong></p> 
<p>情况二上面的图标明了相应的 x 及 <code>x.c(i)</code> ，我们以删除关键字 <code>D</code> 为例，此时当前内部结点 x 不包含关键字 <code>D</code> , 确定是第三种情况，我们可以确认关键 <code>D</code> 一定在结点 x 的第一个孩子结点所在的子树中，结点 x 的第一个孩子结点所在子树的跟结点为 <code>x.c(i) 即 [G、L]</code> . 其中 <code>结点 [G、L]</code> 及其相邻的兄弟结点 <code>[T、W]</code> 都只包含 2 个结点（即 <code>t - 1</code>) ，则将 <code>[G、L]</code> 与 <code>[T、W]</code> 合并，并将结点 x 当中仅有的关键字 <code>P</code> 合并到新结点中；然后将合并后的结点作为新的 x 结点，递归删除关键字 <code>D</code> ，发现D 此时在叶子结点 y 中，直接删除，就是 <strong>1.</strong> 的情况。（此时清晰了很多）</p> 
<p></p> 
<p class="img-center"><img alt="" height="526" src="https://images2.imgbox.com/96/0a/EdpvTzV1_o.png" width="1200"></p> 
<p><strong>情况一：<code>x.c(i)</code> 仅包含 t - 1 个关键字且 <code>x.c(i)</code> 的一个兄弟结点包含至少 t 个关键字，则将 x 的某一个关键字下移到 <code>x.c(i)</code> 中，将 <code>x.c(i)</code> 的相邻的左兄弟或右兄弟结点中的一个关键字上移到 x 当中，将该兄弟结点中相应的孩子指针移到 <code>x.c(i)</code> 中，使得 <code>x.c(i)</code> 增加一个额外的关键字。（一头雾水）</strong></p> 
<p>为了去掉 “一头雾水“，我们在上面情况二删除后的结果上继续进行说明：</p> 
<p></p> 
<p class="img-center"><img alt="" height="628" src="https://images2.imgbox.com/9b/7a/97gEX36t_o.png" width="1200"></p> 
<p>)</p> 
<p>我们以删除结点 <code>[A、B]</code> 中的结点 <code>B</code> 为例，上图中 <code>x.c(i)</code> 包含 2 个关键字，即 t - 1 个关键字， <code>x.c(i)</code> 的一个兄弟结点 <code>[H、J、K]</code> 包含 3 个关键字（满足至少 t 个关键字的要求），则将兄弟结点 <code>[H、J、K]</code> 中的关键字 <code>H</code> 向上移动到 <code>x</code> 中， 将 x 中的关键字 <code>C</code> 下移到 <code>x.c(i)</code> 中；删除关键字 <code>B</code> .</p> 
<p></p> 
<p class="img-center"><img alt="" height="542" src="https://images2.imgbox.com/b4/49/Dxq3QEzL_o.png" width="1200"></p> 
<h5 id="3.4%20B%2B%E6%A0%91">3.4 B+树</h5> 
<p>B+树是B-树的一种变形，是在叶子结点存储信息的树</p> 
<p>定义：</p> 
<p>1. 根结点至少有两棵子树，最多有m棵子树</p> 
<p>2. 每个结点（除根外），至少有[m/2]棵子树，最多有m棵子树</p> 
<p>3. 有n棵子树的结点包含n个关键字</p> 
<p>4. 所有叶子结点在同一层，并包含了所有关键字，按关键字从小到大顺序链接</p> 
<p>5. 所有非终端结点可以作为叶结点的索引，结点中仅包含其子树中最大（或最小）的关键字</p> 
<h5 id="3.5%20%E7%BA%A2%E9%BB%91%E6%A0%91">3.5 红黑树</h5> 
<p>一种高效的自平衡（不是绝对平衡）二叉排序树</p> 
<p>性质：</p> 
<p>1.结点时红色或者黑色的</p> 
<p>2. 根结点时黑色的</p> 
<p>3. 叶子结点都为黑色，且都为空</p> 
<p>4. 红色结点的父节点和子节点都为黑色（不存在两个连续的红色结点</p> 
<p>5. 从任一结点到叶子结点的所有路径都包含相同数量的黑色结点</p> 
<h4 id="4.%20%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE" style="background-color:transparent;">4. 哈希表的查找</h4> 
<blockquote> 
 <p>参考<a class="has-card" href="https://zhuanlan.zhihu.com/p/144296454" rel="nofollow" title="图文并茂详解数据结构之哈希表 - 知乎 (zhihu.com)"><span class="link-card-box"><span class="link-title">图文并茂详解数据结构之哈希表 - 知乎 (zhihu.com)</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/06/d0/SQwuRnj2_o.png" alt="icon-default.png?t=N7T8">https://zhuanlan.zhihu.com/p/144296454</span></span></a></p> 
</blockquote> 
<p>哈希表也叫散列表，哈希表是一种数据结构，它提供了快速的插入操作和查找操作，无论哈希表总中有多少条数据，插入和查找的时间复杂度都是为O(1)，因为哈希表的查找速度非常快，所以在很多程序中都有使用哈希表，例如拼音检查器。</p> 
<p></p> 
<h6 id="%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><strong>4.1 哈希函数</strong></h6> 
<p>哈希函数的作用是帮我们把非int的<strong>「键」</strong>或者<strong>「关键字」</strong>转化成int，可以用来做数组的下标。</p> 
<p class="img-center"><img alt="" height="274" src="https://images2.imgbox.com/35/b7/wtTbzcbB_o.png" width="363"></p> 
<pre><code class="language-cpp"> static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    }</code></pre> 
<p>哈希函数不管怎么实现，都应该满足下面三个基本条件：</p> 
<ul><li>散列函数计算得到的散列值是一个非负整数</li><li>如果 key1 = key2，那 hash(key1) == hash(key2)</li><li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)</li></ul> 
<p>第一点：因为数组的下标是从0开始，所以哈希函数生成的哈希值也应该是非负数</p> 
<p>第二点：同一个key生成的哈希值应该是一样的，因为我们需要通过key查找哈希表中的数据</p> 
<p>第三点：看起来非常合理，但是两个不一样的值通过哈希函数之后可能才生相同的值，因为我们把巨大的空间转出成较小的数组空间时，不能保证每个数字都映射到数组空白处。所以这里就会才生冲突，在哈希表中我们称之为哈希冲突</p> 
<h6 id="%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" style="background-color:transparent;">4.2 哈希函数的构造方法</h6> 
<h6 id="%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95">4.2.1 直接定址法</h6> 
<p><br> 取关键字或关键字的某个线性函数值为哈希地址：<span style="color:#be191c;"><span style="background-color:#fef2f0;">H(key) = key</span> </span>或 <span style="color:#be191c;"><span style="background-color:#fef2f0;">H(key) = a·key + b</span></span><br> 其中a和b为常数，这种哈希函数叫做自身函数。</p> 
<p>注意：由于直接定址所得地址集合和关键字集合的大小相同。因此，对于不同的关键字不会发生冲突。但实际中能使用这种哈希函数的情况很少。</p> 
<p><img alt="" height="326" src="https://images2.imgbox.com/fe/bb/FjEnDQgo_o.png" width="1102"></p> 
<h6 id="%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95" style="background-color:transparent;">4.2.2 数字分析法</h6> 
<p>根据关键码在各个位上的分布情况，选取分布比较均匀的若干位组成散列地址</p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/75/ca/7b3wVxLQ_o.png" width="1036"></p> 
<h6 id="%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95" style="background-color:transparent;">4.2.3 平方取中法</h6> 
<p><br> 取关键字平方后的中间几位为哈希地址。（适用于不知道全部关键字的情况</p> 
<p>通过平方扩大差别，另外中间几位与乘数的每一位相关，由此产生的散列地址较为均匀。这是一种较常用的构造哈希函数的方法。</p> 
<blockquote> 
 <p>将一组关键字(0100，0110，1010，1001，0111)<br> 平方后得(0010000，0012100，1020100，1002001，0012321)<br> 若取表长为1000，则可取中间的三位数作为散列地址集：(100，121，201，020，123)</p> 
</blockquote> 
<h6 id="%E6%8A%98%E5%8F%A0%E6%B3%95" style="background-color:transparent;">4.2.4 折叠法</h6> 
<h6 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0"><img alt="" height="692" src="https://images2.imgbox.com/6e/89/1CdZh2jd_o.png" width="1198"></h6> 
<h6 id="%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95" style="background-color:transparent;">4.2.5 除留余数法</h6> 
<p><br> 取关键字被数p除后所得余数为哈希地址：H(key) = key mod p (p ≤ m)。</p> 
<p>注意：这是一种最简单，也最常用的构造哈希函数的方法。它不仅可以对关键字直接取模(mod)，也可在折迭、平方取中等运算之后取模。值得注意的是，在使用除留余数法时，对p的选择很重要。<span style="background-color:#faa572;">一般情况下可以选p为小于或等于表长（最好接近表长）的质数或不包含小于20的质因素的合数</span><br>  </p> 
<h6 id="%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81" style="background-color:transparent;">4.3 哈希冲突</h6> 
<p>哈希冲突是不可避免的，我们常用解决哈希冲突的方法有两种<strong>「开放地址法」</strong>和<strong>「链表法」</strong></p> 
<h6 id="%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95" style="background-color:transparent;"><strong>4.3.1 开放地址法</strong></h6> 
<p>在开放地址法中，若数据不能直接存放在哈希函数计算出来的数组下标时，就需要寻找其他位置来存放。在开放地址法中有三种方式来寻找其他的位置，分别是<strong>「线性探测」</strong>、<strong>「二次探测」</strong>、<strong>「再哈希法」</strong></p> 
<p><strong>4.3.1.1 线性探测的插入</strong></p> 
<p>在线性探测哈希表中，数据的插入是线性的<span style="background-color:#ffd7b9;">查找空白单元</span>，例如我们将数88经过哈希函数后得到的数组下标是16，但是在数组下标为16的地方已经存在元素，那么就找17,17还存在元素就找18，<u>一直往下找，直到找到空白地方存放元素。</u>我们来看下面这张图</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="341" src="https://images2.imgbox.com/65/a3/p5bzUDIg_o.png" width="535"></p> 
<p>我们向哈希表中添加一个元素<code><span style="background-color:#edf6e8;">钱多多</span></code>，<code><span style="background-color:#edf6e8;">钱多多</span></code>经过哈希函数后得到的数组下标为<code>0</code>，但是在<code>0</code>的位置已经有<code><span style="background-color:#fefcd8;">张三</span></code>了，所以下标往前移，直到下标<code>4</code>才为空，所以就将元素<code><span style="background-color:#edf6e8;">钱多多</span></code>添加到数组下标为<code>4</code>的地方。</p> 
<p><strong>4.3.1.2 线性探测的查找</strong></p> 
<p>线性探测哈希表的查找过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在哈希表中。</p> 
<p><strong>4.3.1.3 线性探测的删除</strong></p> 
<p>线性探测哈希表的删除相对来说比较复杂一点，我们不能简单的把这一项数据删除，让它变成空</p> 
<p>线性探测哈希表在查找的时候，一旦我们通过线性探测方法，<span style="background-color:#e7fafa;">找到一个空闲位置，我们就可以认定哈希表中不存在这个数据。</span>但是，如果这个<u>空闲位置是我们后来删除的</u>，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。</p> 
<p>因此我们需要一个特殊的数据来顶替这个被删除的数据，因为我们的学生学号都是正数，所以我们用学号等于<code>-1</code>来代表被删除的数据。</p> 
<p></p> 
<p class="img-center"><img alt="" height="839" src="https://images2.imgbox.com/5b/85/UHKOXrOb_o.png" width="848"></p> 
<p>这样会带来一个问题，如何在线性探测哈希表中做了多次操作，会导致哈希表中充满了学号为<code>-1</code>的数据项，使的哈希表的效率下降，所以很多哈希表中没有提供删除操作，即使提供了删除操作的，也尽量少使用删除函数。</p> 
<h6 id="%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B" style="background-color:transparent;"><strong>4.3.2 二次探测</strong></h6> 
<p>在线性探测哈希表中，数据会发生聚集，一旦聚集形成，它就会变的越来越大，那些哈希函数后落在聚集范围内的数据项，都需要一步一步往后移动，并且插入到聚集的后面，因此聚集变的越大，聚集增长的越快。</p> 
<p><u>二次探测是防止聚集产生的一种尝试</u>，<span style="background-color:#ffd7b9;">思想是探测相隔较远的单元，而不是和原始位置相邻的单元。</span>在线性探测中，如果哈希函数得到的原始下标是x,线性探测就是x+1,x+2,x+3......，以此类推，而在二次探测中，探测过程是x+1,x+4,x+9,x+16,x+25......,以此类推，到原始距离的步数平方，为了方便理解，我们来看下面这张图</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="744" src="https://images2.imgbox.com/8a/02/pTAN2eHD_o.png" width="1200"></p> 
<p>还是使用线性探测中的例子，在线性探测中，我们从原始探测位置每次往后推一位，最后找到空位置，在线性探测中我们找到<code><span style="background-color:#edf6e8;">钱多多</span></code>的存储位置需要经过4步。在二次探测中，每<span style="background-color:#fbd4d0;">次是原始距离步数的平方</span>，所以我们只需要两次就找到<code><span style="background-color:#edf6e8;">钱多多</span></code>的存储位置。</p> 
<p><strong>二次探测的问题</strong></p> 
<p>二次探测消除了线性探测的聚集问题，这种聚集问题叫做原始聚集，然而，二次探测也产生了新的聚集问题，之所以会产生新的聚集问题，是因为所有映射到同一位置的关键字在寻找空位时，探测的位置都是一样的。</p> 
<p>比如讲1、11、21、31、41依次插入到哈希表中，它们映射的位置都是1，那么11需要以一为步长探测，21需要以四为步长探测，31需要为九为步长探测，41需要以十六为步长探测，<span style="background-color:#fefcd8;">只要有一项映射到1的位置，就需要更长的步长来探测，这个现象叫做二次聚集。</span></p> 
<p>二次聚集不是一个严重的问题，因为二次探测不怎么使用，这里我就不贴出二次探测的源码，因为<strong>「双哈希」</strong>是一种更加好的解决办法。</p> 
<h6 id="%E5%8F%8C%E5%93%88%E5%B8%8C" style="background-color:transparent;"><strong>4.3.3 双哈希</strong></h6> 
<p>双哈希是为了消除原始聚集和二次聚集问题，不管是线性探测还是二次探测，每次的探测步长都是固定的。<span style="background-color:#fefcd8;">双哈希是除了第一个哈希函数外再增加一个哈希函数用来根据关键字生成探测步长</span>，这样即使第一个哈希函数映射到了数组的同一下标，但是探测步长不一样，这样就能够解决聚集的问题。</p> 
<p>第二个哈希函数必须具备如下特点</p> 
<ul><li>和第一个哈希函数不一样</li><li>不能输出为0，因为步长为0，每次探测都是指向同一个位置，将进入死循环，经过试验得出<code>stepSize = constant-(key%constant);</code>形式的哈希函数效果非常好，<code>constant</code>是一个质数并且小于数组容量</li></ul> 
<p>我们将上面的添加改变成双哈希探测，示意图如下：</p> 
<p></p> 
<p class="img-center"><img alt="" height="744" src="https://images2.imgbox.com/76/71/oYmFdVrl_o.png" width="1199"></p> 
<p>双哈希的哈希表写起来来线性探测差不多，就是把探测步长通过<strong>「关键字」</strong>来生成</p> 
<p></p> 
<p><strong>为什么双哈希需要哈希表的容量是一个质数？</strong></p> 
<p>假设我们哈希表的容量为15，某个<strong>「关键字」</strong>经过双哈希函数后得到的数组下标为0，步长为5。那么这个探测过程是0,5,10,0,5,10，一直只会尝试这三个位置，永远找不到空白位置来存放，最终会导致崩溃。</p> 
<p>如果我们哈希表的大小为13，某个<strong>「关键字」</strong>经过双哈希函数后得到的数组下标为0，步长为5。那么这个探测过程是0,5,10,2,7,12,4,9,1,6,11,3。会查找到哈希表中的每一个位置。</p> 
<p>使用开放地址法，不管使用那种策略都会有各种问题，开放地址法不怎么使用，在开放地址法中使用较多的是双哈希策略。</p> 
<p></p> 
<h6 id="%E6%8B%89%E9%93%BE%E6%B3%95" style="background-color:transparent;"><strong>4.3.4 拉链法</strong></h6> 
<p>开放地址法中，通过在哈希表中再寻找一个空位解决冲突的问题，还有一种更加常用的办法是使用<strong>「拉链法」</strong>来解决哈希冲突。<strong>「拉链法」</strong>相对简单很多，<strong>「拉链法」</strong>是每个数组对应一条链表。当某项关键字通过哈希后落到哈希表中的某个位置，把该条数据添加到链表中，其他同样映射到这个位置的数据项也只需要添加到链表中，并不需要在原始数组中寻找空位来存储。下图是<strong>「拉链法」</strong>的示意图。</p> 
<p></p> 
<p class="img-center"><img alt="" height="928" src="https://images2.imgbox.com/9a/d9/lmaCZih9_o.png" width="1103"></p> 
<p><strong>「拉链法」</strong>解决哈希冲突代码比较简单，但是代码比较多，因为需要维护一个链表的操作，我们这里采用有序链表，有序链表不能加快成功的查找，但是可以减少不成功的查找时间，因为只要有一项比查找值大，就说明没有我们需要查找的值，删除时间跟查找时间一样，有序链表能够缩短删除时间。但是有序链表增加了插入时间，我们需要在有序链表中找到正确的插入位置。</p> 
<blockquote> 
 <p><img alt="" height="960" src="https://images2.imgbox.com/f9/d0/oSEQGX4v_o.jpg" width="1200"></p> 
 <p><img alt="" height="960" src="https://images2.imgbox.com/8d/ba/YsEGlAk4_o.jpg" width="1200"></p> 
</blockquote> 
<p></p> 
<h6 id="4.4%20%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%95%88%E7%8E%87" style="background-color:transparent;"><strong>4.4 哈希表的效率</strong></h6> 
<p>在哈希表中执行插入和搜索操作都可以达到O(1)的时间复杂度，在没有哈希冲突的情况下，只需要使用一次哈希函数就可以插入一个新数据项或者查找到一个已经存在的数据项。</p> 
<p>如果发生哈希冲突，插入和查找的时间跟探测长度成正比关系，探测长度取决于装载因子，装载因子是用来表示空位的多少</p> 
<blockquote> 
 <p>参考<a class="has-card" href="https://zhuanlan.zhihu.com/p/146252512" rel="nofollow" title="图解：什么是B树？（心中有 B 树，做人要虚心）一文读懂B-树 - 知乎 (zhihu.com)"><span class="link-card-box"><span class="link-title">图解：什么是B树？（心中有 B 树，做人要虚心）一文读懂B-树 - 知乎 (zhihu.com)</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/f8/a1/6y35qR5s_o.png" alt="icon-default.png?t=N7T8">https://zhuanlan.zhihu.com/p/146252512</span></span></a></p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1e9df4b6d59a2d2e36827e28e7a4b3bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Shell基础编程1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9725101662c334dd6e6a0e3fe75e8b22/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Postman常见问题及解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>