<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2023前端面试题合集（附答案）持续更新中... - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2023前端面试题合集（附答案）持续更新中..." />
<meta property="og:description" content="2023前端面试合集 js基础类1.什么是原型链及原型链存在的意义2.什么是作用域？3.什么是闭包？4.浏览器的渲染过程5.数据类型简介：6.深浅拷贝7.css水平居中的几种方法8.你知道数组有哪些实用高阶函数吗?9.call、apply、bind的区别 Vue类10.vue2和vue3的区别11.route和router的区别12.vue路由两种模式的区别13.keep-alive的生命周期14.mvvm的优势：15.虚拟DOM的作用16.vue如何实现性能优化17.路由的守卫18.Vue 组件中 data 为什么必须是函数？19.ES6的新特性有哪些？20.模块化开发的好处：21.JSON.stringify深拷贝的缺点22.防抖和节流,有什么区别？23.JS中promise对象的作用与使用24.async-await语法25.宏任务和微任务26.v-model和sync修饰符有什么区别27.typescript和javascript区别28.ts中type和interface的区别29.JS的原型与原型链30.什么是虚拟DOM31. vuex Mutations为什么必须是同步32.js事件循环 js基础类 1.什么是原型链及原型链存在的意义 (1).什么是原型链
答:原型链就是每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系就被称为原型链。
简单理解：原型链就是在当前对象中找不到定义的话，会在当前对象的原型对象上继续查找，直至undefined。
(2).原型和原型链存在的意义是什么？
答:实例对象可以共享构造函数原型属性和方法，节省内存。构造函数原型上的属性和方法越多，节省内存越大。
2.什么是作用域？ 作用域分为：1.全局作用域,2. 函数作用域, 3.块级作用域
答:作用域是在运行时代码中的某些特定部分变量，函数和对象的可访问性，作用域决定了代码区块中变量和其他资源的可见性。
3.什么是闭包？ 能够访问其他函数内部变量的函数，被称为闭包。
那种场景会用到，一些事件函数的封装.
闭包本身会带来常驻内存，引用后不会及时销毁.
4.浏览器的渲染过程 当我们在浏览器里输入一个 URL 后，最终会呈现一个完整的网页。会经历以下几个步骤：
1、HTML 的加载
页面上输入 URL 后，会先拿到 HTML 文件。HTML是一个页面的基础，所以会在最开始的时候下载它，下载完毕后就开始对它进行解析
2、其他静态资源的下载
HTML 在解析的过程中，如果发现 HTML 文本里面有一些外部的资源链接，比如 CSS、JS 和图片等，会立即启用别的线程下载这些静态资源。在 head 中遇到 JS 文件时，HTML 的解析会停 下来，等 JS 文件下载结束并且执行完，HTML 的解析工作再接着来，防止 JS 修改已经完成的解析结果
由上得知，JS 文件放在 head 中属于同步加载，会阻塞 DOM 树的构建，进而影响页面的加载。当 JS 文件较多时，页面白屏的时间也会变长
5.数据类型简介： js常用的基本数据类型包括undefined - - (未定义)、null- - (空的)、number - - (数字)、boolean- - (布尔值)、string- - (字符串)、Symbol - - (符号)；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/6784dcf34b860722dd7ed1165cbfd025/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-27T15:07:54+08:00" />
<meta property="article:modified_time" content="2023-12-27T15:07:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2023前端面试题合集（附答案）持续更新中...</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>2023前端面试合集</h4> 
 <ul><li><a href="#js_2" rel="nofollow">js基础类</a></li><li><ul><li><a href="#1_4" rel="nofollow">1.什么是原型链及原型链存在的意义</a></li><li><a href="#2_15" rel="nofollow">2.什么是作用域？</a></li><li><a href="#3_21" rel="nofollow">3.什么是闭包？</a></li><li><a href="#4_29" rel="nofollow">4.浏览器的渲染过程</a></li><li><a href="#5_39" rel="nofollow">5.数据类型简介：</a></li><li><a href="#6_45" rel="nofollow">6.深浅拷贝</a></li><li><a href="#7css_50" rel="nofollow">7.css水平居中的几种方法</a></li><li><a href="#8_59" rel="nofollow">8.你知道数组有哪些实用高阶函数吗?</a></li><li><a href="#9callapplybind_72" rel="nofollow">9.call、apply、bind的区别</a></li></ul> 
  </li><li><a href="#Vue_79" rel="nofollow">Vue类</a></li><li><ul><li><a href="#10vue2vue3_80" rel="nofollow">10.vue2和vue3的区别</a></li><li><a href="#11routerouter_98" rel="nofollow">11.route和router的区别</a></li><li><a href="#12vue_103" rel="nofollow">12.vue路由两种模式的区别</a></li><li><a href="#13keepalive_115" rel="nofollow">13.keep-alive的生命周期</a></li><li><a href="#14mvvm_127" rel="nofollow">14.mvvm的优势：</a></li><li><a href="#15DOM_133" rel="nofollow">15.虚拟DOM的作用</a></li><li><a href="#16vue_138" rel="nofollow">16.vue如何实现性能优化</a></li><li><a href="#17_146" rel="nofollow">17.路由的守卫</a></li><li><a href="#18Vue__data__169" rel="nofollow">18.Vue 组件中 data 为什么必须是函数？</a></li><li><a href="#19ES6_175" rel="nofollow">19.ES6的新特性有哪些？</a></li><li><a href="#20_195" rel="nofollow">20.模块化开发的好处：</a></li><li><a href="#21JSONstringify_202" rel="nofollow">21.JSON.stringify深拷贝的缺点</a></li><li><a href="#22_210" rel="nofollow">22.防抖和节流,有什么区别？</a></li><li><a href="#23JSpromise_282" rel="nofollow">23.JS中promise对象的作用与使用</a></li><li><a href="#24asyncawait_304" rel="nofollow">24.async-await语法</a></li><li><a href="#25_342" rel="nofollow">25.宏任务和微任务</a></li><li><a href="#26vmodelsync_364" rel="nofollow">26.v-model和sync修饰符有什么区别</a></li><li><a href="#27typescriptjavascript_372" rel="nofollow">27.typescript和javascript区别</a></li><li><a href="#28tstypeinterface_376" rel="nofollow">28.ts中type和interface的区别</a></li><li><a href="#29JS_392" rel="nofollow">29.JS的原型与原型链</a></li><li><a href="#30DOM_396" rel="nofollow">30.什么是虚拟DOM</a></li><li><a href="#31_vuex_Mutations_402" rel="nofollow">31. vuex Mutations为什么必须是同步</a></li><li><a href="#32js_410" rel="nofollow">32.js事件循环</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="js_2"></a>js基础类</h2> 
<h3><a id="1_4"></a>1.什么是原型链及原型链存在的意义</h3> 
<p><strong>(1).什么是原型链</strong></p> 
<blockquote> 
 <p>答:原型链就是每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系就被称为原型链。<br> 简单理解：原型链就是在当前对象中找不到定义的话，会在当前对象的原型对象上继续查找，直至undefined。</p> 
</blockquote> 
<p><strong>(2).原型和原型链存在的意义是什么？</strong></p> 
<blockquote> 
 <p>答:实例对象可以共享构造函数原型属性和方法，节省内存。构造函数原型上的属性和方法越多，节省内存越大。</p> 
</blockquote> 
<h3><a id="2_15"></a>2.什么是作用域？</h3> 
<p>作用域分为：1.全局作用域,2. 函数作用域, 3.块级作用域</p> 
<blockquote> 
 <p>答:作用域是在运行时代码中的某些特定部分变量，函数和对象的可访问性，作用域决定了代码区块中变量和其他资源的可见性。</p> 
</blockquote> 
<h3><a id="3_21"></a>3.什么是闭包？</h3> 
<blockquote> 
 <p>能够访问其他函数内部变量的函数，被称为闭包。<br> 那种场景会用到，一些事件函数的封装.<br> 闭包本身会带来常驻内存，引用后不会及时销毁.</p> 
</blockquote> 
<h3><a id="4_29"></a>4.浏览器的渲染过程</h3> 
<blockquote> 
 <p>当我们在浏览器里输入一个 URL 后，最终会呈现一个完整的网页。会经历以下几个步骤：</p> 
</blockquote> 
<p><strong>1、HTML 的加载</strong></p> 
<p>页面上输入 URL 后，会先拿到 HTML 文件。HTML是一个页面的基础，所以会在最开始的时候下载它，下载完毕后就开始对它进行解析</p> 
<p><strong>2、其他静态资源的下载</strong><br> HTML 在解析的过程中，如果发现 HTML 文本里面有一些外部的资源链接，比如 CSS、JS 和图片等，会立即启用别的线程下载这些静态资源。在 head 中遇到 JS 文件时，HTML 的解析会停 下来，等 JS 文件下载结束并且执行完，HTML 的解析工作再接着来，防止 JS 修改已经完成的解析结果</p> 
<blockquote> 
 <p>由上得知，JS 文件放在 head 中属于同步加载，会阻塞 DOM 树的构建，进而影响页面的加载。当 JS 文件较多时，页面白屏的时间也会变长</p> 
</blockquote> 
<h3><a id="5_39"></a>5.数据类型简介：</h3> 
<blockquote> 
 <p>js常用的基本数据类型包括undefined - - (未定义)、null- - (空的)、number - - (数字)、boolean- - (布尔值)、string- - (字符串)、Symbol - - (符号)；</p> 
</blockquote> 
<blockquote> 
 <p>js的引用数据类型也就是对象类型Object- - (对象)，比如：array - - （数组）、function - - （函数）、date - - （时间）等；</p> 
</blockquote> 
<h3><a id="6_45"></a>6.深浅拷贝</h3> 
<blockquote> 
 <p>浅拷贝：浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化</p> 
</blockquote> 
<blockquote> 
 <p>深拷贝： 深拷贝和浅拷贝是针对复杂数据类型（对象及数组）来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p> 
</blockquote> 
<h3><a id="7css_50"></a>7.css水平居中的几种方法</h3> 
<ol><li>margin和width实现,在容器上定义一个固定的宽度,配合margin左右的值为auto。</li><li>内容设置inline-block和父元素text-align:center。</li><li>绝对定位实现水平居中，我想大家也非常的熟悉了，并且用得一定不少。</li><li>css3的flex实现。</li><li>css3的fit-content 。</li></ol> 
<h3><a id="8_59"></a>8.你知道数组有哪些实用高阶函数吗?</h3> 
<blockquote> 
 <p>数组有很多的方法，都很简单方便，向push,pop等等，但是对于高阶函数在实际使用用的很多，现在就来总结一下方法使用及场景首先，什么是高阶函数：高阶函数，就是函数中可以传入另一个函数作为参数的函数。<br> <a href="http://t.csdn.cn/t9X3y" rel="nofollow">点击查看案例详解</a></p> 
</blockquote> 
<ol><li>forEach</li><li>filter</li><li>map</li><li>sort</li><li>some</li><li>every</li><li>reduce</li><li>find</li></ol> 
<h3><a id="9callapplybind_72"></a>9.call、apply、bind的区别</h3> 
<ul><li><strong>call、apply、bind相同点</strong>：都是改变this的指向，传入的第一个参数都是绑定this的指向，在非严格模式中，如果第一个参数是nul或者undefined，会把全局对象（浏览器是window）作为this的值，要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined</li><li><strong>call和apply唯一的区别是</strong>：call传入的是参数列表，apply传入的是数组，也可以是类数组</li><li><strong>bind和call、apply的区别</strong>： bind返回的是一个改变了this指向的函数，便于稍后调用，不像call和apply会立即调用；bind和call很像，传入的也是参数列表，但是可以多次传入，不需要像call，一次传入</li><li><strong>值得注意</strong>：当 bind 返回的函数 使用new作为构造函数时，绑定的 this 值会失效，this指向实例对象，但传入的参数依然生效 （new调用的优先级 &gt; bind调用）</li></ul> 
<h2><a id="Vue_79"></a>Vue类</h2> 
<h3><a id="10vue2vue3_80"></a>10.vue2和vue3的区别</h3> 
<ol><li>双向数据绑定原理不同</li><li>是否支持碎片；</li><li>API类型不同；</li><li>定义数据变量和方法不同；</li><li>生命周期钩子函数不同；</li><li>父子传参不同；</li><li>指令与插槽不同；</li><li>main.js文件不同。</li></ol> 
<blockquote> 
 <p>vue2：vue2不支持碎片。<br> vue3：vue3支持碎片（Fragments），就是说可以拥有多个根节点。<br> vue2：vue2的双向数据绑定是利用ES5的一个APIObject.definePropert() 对数据进行劫持，结合发布订阅模式的方式来实现的。<br> vue3：vue3中使用了ES6的Proxy API对数据代理。相比vue2.x，使用proxy的优势如下：<br> (1).defineProperty只能监听某个属性，不能对全对象监听<br> (2).可以省去for in，闭包等内容来提升效率(直接绑定整个对象即可)<br> (3).可以监听数组，不用再去单独的对数组做特异性操作vue3.x可以检测 到数组内部数据的变化。</p> 
</blockquote> 
<h3><a id="11routerouter_98"></a>11.route和router的区别</h3> 
<blockquote> 
 <p>router为VueRouter的实例，相当于一个全局的路由器对象，里面含有很多属性和子对象，例如history对象。经常用的跳转链接就可以用this.$router.push，和router-link跳转一样。</p> 
</blockquote> 
<blockquote> 
 <p>route相当于当前路由对象。可以获取到一些参数,每一个路由都会有一个router对象，可以从里面获取name,path,params等。</p> 
</blockquote> 
<h3><a id="12vue_103"></a>12.vue路由两种模式的区别</h3> 
<p><strong>hash模式</strong><br> 就是指 url 后面的 # 号以及后面的字符。每次刷新页面时是直接更改 # 后的东西。</p> 
<p>hash 原理：灵活运用了 html的瞄点功能，改变 # 后的路径本质上是更换了当前页面的瞄点，所以不会刷新页面。通过监听浏览器的 onhashchange()事件变化，查找对应的路由规则。</p> 
<blockquote> 
 <p>由于 hash 值变化不会导致浏览器向服务器发出请求，而且 hash 改变会触发 hashchange事件（hashchange只能改变 # 后面的 url片段）；虽然 hash路径出现在URL中，但是不会出现在 HTTP请求中，对后端完全没有影响，因此改变 hash值不会重新加载页面，基本都是使用 hash 来实现前端路由的。</p> 
</blockquote> 
<p><strong>history模式</strong><br> history 原理： 利用 H5的 history中新增的两个API ：pushState()和 replaceState()和一个事件onpopstate监听URL变化。</p> 
<blockquote> 
 <p>包含 back、forward、go方法；history 模式 URL就要和后端进行一致，所以要改为 history也需要后端的配合，否则会报错；history 每次刷新会重新向后端请求整个网址，也就是重新请求服务器。如果后端没有及时响应，就会报错404！。</p> 
</blockquote> 
<h3><a id="13keepalive_115"></a>13.keep-alive的生命周期</h3> 
<p>在组件切换过程中 把切换出去的组件保留在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性</p> 
<blockquote> 
 <p>被包含在 keep-alive 中创建的组件，会多出两个生命周期的钩子: activated（组件激活时使用） 与 deactivated（组价离开时调用）</p> 
</blockquote> 
<blockquote> 
 <p>钩子的触发顺序created-&gt; mounted-&gt; activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated</p> 
</blockquote> 
<p><strong>keep-ailve用法:</strong></p> 
<ul><li>如果需要缓存整个项目，直接在app.vue中用keep-alive包裹router-view即可</li><li>要缓存部分页面，需要在路由地址配置中，在meta属性中添加一个状态，在app.vue中判断一下包裹的router-view即可</li><li>也可以使用exclude和include规定缓存哪个组件不缓存哪个组件</li></ul> 
<h3><a id="14mvvm_127"></a>14.mvvm的优势：</h3> 
<blockquote> 
 <ol><li>mvc和 mvvm 都是一种设计思想，主要就是 mvc 中 controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量 dom 操作提高了页面 渲染性能和加载速度的问题</li><li>mvvm 和 mvc 最大的区别就是：它实现了 view 和 Model 的自动同步，当 model 的属性改变时，我们不用在手动操作 dom 元素来改变 view 的显示，它会自动变化dom</li><li>整体看来，mvvm 比 mvc 精简很多，我们不用在用选择器来频繁的操作 dom</li></ol> 
</blockquote> 
<h3><a id="15DOM_133"></a>15.虚拟DOM的作用</h3> 
<blockquote> 
 <ul><li>维护视图和状态的关系</li><li>复杂视图情况下提升渲染性能</li><li>虚拟 DOM 在更新真实 DOM 之前会通过 Diff 算法来对比两个新旧两个虚拟 DOM 树之间的差异，实现局部更新，最终把差异更新到真实 DOM</li></ul> 
</blockquote> 
<h3><a id="16vue_138"></a>16.vue如何实现性能优化</h3> 
<blockquote> 
 <p><strong>1.代码模块化</strong>,常用的地方封装成单独的组件，在需要用到的地方引用，而不是写过多重复的代码，每一个组件都要明确含义，复用性越高越好，可配置型越强越好，包括咱们的css也可以通过less和sass的自定义css变量来减少重复代码。<br> <strong>2.Vue路由设置成懒加载</strong>，当首屏渲染的时候，能够加快渲染速度。<br> <strong>3.打包优化</strong>,修改vue.config.js中的配置项，把productionSourceMap设置为false，不然最终打包过后会生成一些map文件，如果不关掉，生成环境是可以通过map去查看源码的，并且可以开启gzip压缩，使打包过后体积变小。<br> <strong>4.减少图片使用</strong>，可以用一些css3的效果来代替图片效果，或者使用雪碧图来减少图片的体积。<br> <strong>5.按需引入</strong>,咱们使用的一些第三方库可以通过按需引入的方式加载。避免引入不需要使用的部分，无端增加项目体积<br> <strong>6.使用cdn的方式外部加载一些资源</strong>,比如vue-router、axios等Vue的周边插件，在webpack.config.js里面，externals里面设置一些不必要打包的外部引用模块</p> 
</blockquote> 
<h3><a id="17_146"></a>17.路由的守卫</h3> 
<p><strong>对路由守卫的认识</strong></p> 
<blockquote> 
 <p>路由守卫分为三种：<strong>全局导航守卫，路由守卫，组件内导航守卫</strong>。路由跳转本身是一个比较复杂的过程，但是可以通过导航守卫把这个过程进行细化，可以在每个细化的过程（钩子函数）中进行相应的操作。</p> 
</blockquote> 
<blockquote> 
 <p><strong>路由导航守卫</strong>：导航守卫就是在路由跳转前后的一些钩子函数<br> <strong>路由拦截</strong>：在路由跳转到指定的路有前，可以手动让其跳转到其他的路由界面，并且也可以让跳转停止掉。</p> 
</blockquote> 
<p><strong>路由守卫的分类</strong><br> <strong>1 全局守卫</strong>：</p> 
<ul><li>全局前置守卫：beforeEach 会多次触发，</li><li>全局解析守卫：beforeResolve 解析守卫</li><li>全局后置守卫：afterEach 把组件实例对象传入到组件beforeRouteEnter守卫的next回调中</li></ul> 
<p><strong>2.路由守卫</strong>：</p> 
<ul><li>beforeEnter 路由内的独享守卫</li></ul> 
<p><strong>3.组件内的守卫</strong>：</p> 
<ul><li>beforeRouteEnter 进入组件之前触发，只在进入组件时触发一次</li><li>beforeRouterUpdate 组件更新之前触发（动态参数变化查询字符串变化）进入组件后参数变化可多次触发</li><li>beforeRouterLeave 离开路由组件之前触发 只在离开组件时触发一次</li></ul> 
<h3><a id="18Vue__data__169"></a>18.Vue 组件中 data 为什么必须是函数？</h3> 
<blockquote> 
 <p>因为一个组件是可以共享的，但他们的data是私有的，所以每个组件都要return一个新的data对象，返回一个唯一的对象，不要和其他组件共用一个对象。</p> 
</blockquote> 
<blockquote> 
 <p>如果是对象形式，所有的实例都将共享同一份data的数据对象，一旦某个组件修改了data，所有的实例都将受到影响，这是我们不想要的结果。</p> 
</blockquote> 
<blockquote> 
 <p>这样每一个实例的data属性都是独立的，不会相互影响了。所以，你现在知道为什么vue组件的data必须是函数了吧。这都是因为js本身的特性带来的，跟vue本身设计无关。</p> 
</blockquote> 
<h3><a id="19ES6_175"></a>19.ES6的新特性有哪些？</h3> 
<pre><code> - 新增了块级作用域（let，const）
 - 提供了定义类的语法糖（class）
 - 新增了一种基本数据类型（Symbol）
 - 新增了变量的解构赋值
 - 函数参数允许设置默认值，引入了rest参数，新增了箭头函数。
 - 数组新增了一些API，如isArray / from / of 方法；数组实例新增了 entries()，keys() 和 values() 等方法。
 - 对象和数组新增了扩展运算符
 - ES6新增了模块化（import / export）
 - ES6新增了Set和Map数据结构。
 - ES6原生提供Proxy构造函数，用来生成Proxy实例
 - ES6新增了生成器（Generator）和遍历器（Iterator） 
</code></pre> 
<p><strong>说说解构赋值</strong></p> 
<pre><code> - 解构：分解数据结构。
 - 赋值：为变量赋值。
 - 解构赋值：从数组或者对象中提取值，按照对应的位置，对变量赋值（在数组解构中，只 要解构的目标可以遍历，就可以实现解构赋值）。
</code></pre> 
<h3><a id="20_195"></a>20.模块化开发的好处：</h3> 
<ol><li>避免变量污染，命名冲突</li><li>提高代码复用率</li><li>提高了可维护性</li><li>方便依赖关系管理</li></ol> 
<h3><a id="21JSONstringify_202"></a>21.JSON.stringify深拷贝的缺点</h3> 
<p>1、如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式<br> 2、如果obj里面有RegExp，则打印出来是空对象<br> 3、如果对象中有函数或者undefined，则会直接被丢掉<br> 4、如果json里有对象是由构造函数生成的，则会丢掉对象的constructon<br> 5、如果对象中存在循环引用的情况也无法正确实现深拷贝<br> 6、如果对象中存在NAN，则序列化后会变成null</p> 
<h3><a id="22_210"></a>22.防抖和节流,有什么区别？</h3> 
<blockquote> 
 <p>开发中，经常会遇到以下场景：监听鼠标移动 onmousemove，监听页面滚动 onscroll，监听大小变化 onresize，监听 input 输入，按钮的搜索、提交功能等。这些场景下，事件会被频繁触发，但我们并不想事件被频繁触发，这时就需要通过防抖和节流来限制频繁操作。</p> 
</blockquote> 
<p>防抖和节流都是为了解决事件频繁触发的问题，但在实现原理上有些不同，具体实现原理看下文。</p> 
<p><strong>1.防抖(debounce)：</strong></p> 
<blockquote> 
 <p>防抖触发高频率事件时n秒后只会执行一次，如果n秒内再次触发，则会重新计算。</p> 
</blockquote> 
<p>简单概括：每次触发时都会取消之前的延时调用。</p> 
<p>应用场景：<br> 1.scroll事件滚动<br> 2.浏览器窗口的缩放resize事件<br> 3.搜索框输入查询的时候<br> 4.表单验证<br> 5.按钮的提交事件</p> 
<p>代码：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">debounce</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay <span class="token operator">=</span> <span class="token number">1000</span></span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> time <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取当前this</span>
    <span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token comment">// 判断是否已经存在，如果存在直接清除</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    time <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 使fn 中this，执行当前调用者，并传入参数</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 测试demo</span>
<span class="token keyword">function</span> <span class="token function">logger</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'log -----'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token function">debounce</span><span class="token punctuation">(</span>logger<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><strong>2.节流(thorttle):</strong></p> 
<blockquote> 
 <p>高频事件触发，每次触发事件时设置一个延迟调用方法，并且取消之前延时调用的方法。</p> 
</blockquote> 
<p>简单概括：每次触发事件时都会判断是否等待执行的延时函数。</p> 
<p>代码：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">throttle</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay <span class="token operator">=</span> <span class="token number">1000</span></span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">let</span> time <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token comment">// 如果已经存在定时器了，则 不做处理</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>time<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			time <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
				<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">// 完结时，将time改为null</span>
				time <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>区别：</strong> 降低回调执行频率，节省计算资源。</p> 
<ul><li><strong>防抖和节流本质是不一样的。防抖是将多次执行变为最后一次执行，节流是将<br> 多次执行变成每隔一段事件执行</strong></li><li><strong>函数防抖一定连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行<br> 一次。</strong></li></ul> 
<h3><a id="23JSpromise_282"></a>23.JS中promise对象的作用与使用</h3> 
<blockquote> 
 <p>Promise 它是一个ES6提出一个新语法，用来优化异步代码的写法。<br> promise的作用：ajax是异步请求，多层嵌套会造成回调地狱，promise模拟同步，将异步回调类似于同步来处理业务逻辑。</p> 
</blockquote> 
<p>promise的then方法是异步方法，但会优先于定时器执行。</p> 
<p>1、promise参数是一个函数，这个回调函数有两个形参（自定义，一般约定写为resolve,reject）<br> 2、Promise的三种状态: pending、fulfilled、rejected(未决定,履行,拒绝),同一时间只能存在一种状态,且状态一旦改变就不能再变<br> 3、当状态一旦发送改变 就不会重新改变<br> 4、成功执行.then里的回调函数，失败执行.catch内的回调函数</p> 
<p><strong>特点：</strong></p> 
<p>将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。<br> 流程更加清晰，代码更加优雅。<br> Promise对象提供统一的接口，使得控制异步操作更加容易。</p> 
<p><strong>缺点：</strong></p> 
<p>无法取消Promise，一旦新建它就会立即执行，无法中途取消。<br> 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。<br> 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p> 
<h3><a id="24asyncawait_304"></a>24.async-await语法</h3> 
<blockquote> 
 <p>async,await 是es7中新增的语法，用来进一步改进异步代码的写法，是promise升级版！</p> 
</blockquote> 
<p><strong>async</strong></p> 
<ul><li>async函数返回一个 Promise 对象。</li><li>async函数内部return语句返回的值是Promise 对象的值</li></ul> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f3</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">const</span> r1 <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> r2 <span class="token operator">=</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> r3 <span class="token operator">=</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r1<span class="token punctuation">)</span> <span class="token comment">// 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r2<span class="token punctuation">)</span> <span class="token comment">// Promise, resolved(1)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r3<span class="token punctuation">)</span> <span class="token comment">// Promise, resolved(undefined)</span>
r2<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
r3<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p><strong>await 命令</strong></p> 
<ul><li>await的外层函数必须有一个async.</li><li>正常情况下，await命令后面是一个 Promise 对象，返回该promise的值。如果不是 Promise 对象，就直接返回对应的值。</li></ul> 
<p><strong>async函数内部的执行流程</strong></p> 
<ol><li>在执行async函数(设名为asyncF)时，进入函数内部：</li><li>按序执行同步代码</li><li>遇到await，跳出asyncF函数，</li><li>继续执行后续代码。</li><li>当await后的异步代码执行完成之后，接着执行asyncF中的后续代码。</li></ol> 
<h3><a id="25_342"></a>25.宏任务和微任务</h3> 
<p><strong>为什么任务要分为同步任务和异步任务</strong></p> 
<p>试想一下，如果js的任务都是同步的，那么遇到定时器、网络请求等这类型需要延时执行的任务会发生什么？</p> 
<p>页面可能会瘫痪，需要暂停下来等待这些需要很长时间才能执行完毕的代码</p> 
<p>所以，又引入了异步任务。</p> 
<p>● 同步任务：同步任务不需要进行等待可立即看到执行结果，比如console<br> ● 异步任务：异步任务需要等待一定的时候才能看到结果，比如setTimeout、网络请求</p> 
<p><strong>异步任务，又可以细分为宏任务和微任务。下面列举目前学过的宏任务和微任务。</strong><br> <img src="https://images2.imgbox.com/88/69/rW5FZWDW_o.png" alt="在这里插入图片描述"><br> ● 先执行同步代码<br> ● 遇到宏任务，放入队列<br> ● 遇到微任务，放入微任务队列<br> ● 执行栈为空<br> ○ 将微任务入栈执行<br> ● 所有的微任务完成之后，取出宏任务队列来执行</p> 
<blockquote> 
 <p>宏任务和微任务谁先执行 <strong>答：宏任务</strong></p> 
</blockquote> 
<h3><a id="26vmodelsync_364"></a>26.v-model和sync修饰符有什么区别</h3> 
<p><strong>相同点</strong>：都是语法糖，都可以实现父子组件中的数据的双向通信。<br> <strong>区别点</strong>：格式不同：v-model=“num”, :num.sync=“num”</p> 
<blockquote> 
 <p>v-model：@input + value<br> :num.sync: @update:num</p> 
</blockquote> 
<p>另外需要特别注意的是: v-model只能用一次；.sync可以有多个。</p> 
<h3><a id="27typescriptjavascript_372"></a>27.typescript和javascript区别</h3> 
<p>首先是类型系统不同。TypeScript引入了静态类型检查，这意味着在编译阶段，TypeScript会检查变量的类型，而不是在运行时。这有助于捕捉潜在的错误，同时也使代码更易于理解和维护。</p> 
<blockquote> 
 <p>包括数据绑定,模块化编程,应用方向,编译期间发现错误时间</p> 
</blockquote> 
<h3><a id="28tstypeinterface_376"></a>28.ts中type和interface的区别</h3> 
<blockquote> 
 <p><strong>概念：</strong><br> <strong>type</strong>：类型别名，为类型创建一个新名称。它并不是一个类型，只是一个别名。<br> <strong>interface</strong>：接口，TS 设计出来主要用于定义对象类型，可以对对象的形状进行描述。</p> 
</blockquote> 
<p><strong>区别：</strong></p> 
<ul><li>1.interface可以重复声明，type定义后不能重复声明</li><li>2.interface可以通过“extends”来继承接口，这样既高效又不用重新定义。而type只能通过&amp;来实现类似于继承的功能</li><li>3.type 能够表示非对象类型， 而 interface 则只能表示对象类型。</li></ul> 
<p><strong>type</strong></p> 
<ul><li>可以定义基本类型别名，如type StringType = string</li><li>可以声明联合类型，如 type paramType = number | string;</li><li>可以声明元组类型，如type arrType = [string, string, number]</li><li>定义对象时严谨的来说，type 是引用，而 interface是定义</li></ul> 
<h3><a id="29JS_392"></a>29.JS的原型与原型链</h3> 
<blockquote> 
 <p>1、原型，所有的函数默认都有一个“prototype”这样公有且不可枚举的属性，它会指向另一个对象，这个对象就是原型。</p> 
</blockquote> 
<blockquote> 
 <p>2、原型链，当访问对象的属性或方法时，首先对象会从自身去找，找不到就会往原型中去找，也就是它构造函数的“prototype”中，如果原型中找不到，即构造函数中也没有该属性，就会往原型后面的原型上去找，这样就形成了链式的结构，称为原型链。</p> 
</blockquote> 
<h3><a id="30DOM_396"></a>30.什么是虚拟DOM</h3> 
<blockquote> 
 <p>虚拟DOM就是用普通js对象来描述DOM结构，因为不是真实DOM，所以称之为虚拟DOM。</p> 
</blockquote> 
<p>虚拟 dom 是相对于浏览器所渲染出来的真实 dom而言的，在react，vue等技术出现之前，我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 然后修改样式行为或者结构，来达到更新 ui 的目的。</p> 
<p>这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示 dom 树及其层级结构，那么每次 dom 的更改就变成了对 js 对象的属性的增删改查，这样一来查找 js 对象的属性变化要比查询 dom 树的性能开销小。</p> 
<h3><a id="31_vuex_Mutations_402"></a>31. vuex Mutations为什么必须是同步</h3> 
<blockquote> 
 <p>mutation内部必须是同步函数，异步会导致内部状态难以追踪，devtool难以追踪state的状态.</p> 
</blockquote> 
<p>从官方解释来看，修改state数据必须只能mutations中修改，而假设mutions内部有异步，那么会带来devtool无法准确追踪state变化，因为多个异步并不知道哪个异步会先执行完。但是话说回来，mutations中有异步，依然可以修改state啊，因为业务中我并不太需要知道devtool是如何追踪state的变化，但是为了遵从规范，所有的异步都在actions中处理，mutations只集中干一件事，直接修改state值</p> 
<p>actions是异步操作的，actions中可以有多个异步操作，但是最终的结果依然是交给mutations去修改的，也就是说actions中异步操作的副作用统一交给了mutations去记录</p> 
<p>多个异步任务可以在actions中触发，dispatch(‘xxx’)返回的是一个Promise</p> 
<h3><a id="32js_410"></a>32.js事件循环</h3> 
<blockquote> 
 <p>JS 在解析一段代码时，会将同步代码按顺序排在某个地方，即执行栈，然后依次执行里面的函数。当遇到异步任务时就交给其他线程处理，待当前执行栈所有同步代码执行完成后，会从一个队列中去取出已完成的异步任务的回调加入执行栈继续执行，遇到异步任务时又交给其他线程，…，如此循环往复。而其他异步任务完成后，将回调放入任务队列中待执行栈来取出执行。</p> 
</blockquote> 
<blockquote> 
 <p>JS 按顺序执行执行栈中的方法，每次执行一个方法时，会为这个方法生成独有的执行环境（上下文 context)，待这个方法执行完成后，销毁当前的执行环境，并从栈中弹出此方法（即消费完成），然后继续下一个方法。</p> 
</blockquote> 
<blockquote> 
 <p>可见，在事件驱动的模式下，至少包含了一个执行循环来检测任务队列是否有新的任务。通过不断循环去取出异步回调来执行，这个过程就是事件循环，而每一次循环就是一个事件周期或称为一次 tick。</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ca155e24b5076350b3b364d862f77c30/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">机器学习中异常值的处理方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43758887394d7a2151576644eff36ec4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">cfa一级考生复习经验分享系列（十五）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>