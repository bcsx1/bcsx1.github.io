<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>王者荣耀java版 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="王者荣耀java版" />
<meta property="og:description" content="键盘W,A,S,D键：控制玩家上下左右移动。按钮一：控制英雄发射一个矩形攻击红方小兵。按钮二：控制英雄发射魅惑技能，伤害小兵并让小兵停止移动。技能三：攻击多个敌人并让小兵停止移动。普攻：对小兵造成基础伤害。小兵每隔一段时间自动生成，在王者峡谷下路移动，遇到敌人则自动攻击。防御塔可以自动识别敌人进行攻击。野怪分为RedBuff，BlueBuff,普通野怪，死亡后都可以复活。游戏胜利的条件是红方水晶生命值为零,游戏失败条件是蓝方水晶生命值为零。游戏的设计模式为可以偷塔。
一、主窗口类 package com.sxt; import com.sxt.beast.Beast; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; import java.io.File; import java.util.ArrayList; import javax.sound.sampled.AudioInputStream; import javax.sound.sampled.AudioSystem; import javax.sound.sampled.Clip; import javax.sound.sampled.FloatControl; import javax.swing.JButton; import javax.swing.JFrame; public class GameFrame extends JFrame { // 游戏开始 0， 游戏胜利1，游戏失败2 int state = 0; // 窗口尺寸 final int windowWidth = 1400; final int windowHeight = 700; // 双缓冲图片 private Image offScreenImage = null; // 攻击图片 private Image attack = Toolkit." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/53d633aff1d80fef7aac0165ba9f7146/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-29T14:39:26+08:00" />
<meta property="article:modified_time" content="2023-11-29T14:39:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">王者荣耀java版</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>键盘W,A,S,D键：控制玩家上下左右移动。按钮一：控制英雄发射一个矩形攻击红方小兵。按钮二：控制英雄发射魅惑技能，伤害小兵并让小兵停止移动。技能三：攻击多个敌人并让小兵停止移动。普攻：对小兵造成基础伤害。小兵每隔一段时间自动生成，在王者峡谷下路移动，遇到敌人则自动攻击。防御塔可以自动识别敌人进行攻击。野怪分为RedBuff，BlueBuff,普通野怪，死亡后都可以复活。游戏胜利的条件是红方水晶生命值为零,游戏失败条件是蓝方水晶生命值为零。游戏的设计模式为可以偷塔。</p> 
<h2></h2> 
<h3>一、主窗口类</h3> 
<pre><code class="language-java">package com.sxt;
 
import com.sxt.beast.Beast;
 
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.io.File;
import java.util.ArrayList;
 
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.sound.sampled.FloatControl;
import javax.swing.JButton;
import javax.swing.JFrame;
 
public class GameFrame extends JFrame {
    // 游戏开始 0， 游戏胜利1，游戏失败2
    int state = 0;
    // 窗口尺寸
    final int windowWidth = 1400;
    final  int windowHeight = 700;
    // 双缓冲图片
    private Image offScreenImage = null;
    // 攻击图片
    private Image attack = Toolkit.getDefaultToolkit().getImage("C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\attack.jpg");
    //游戏胜利失败图片
    private Image gameWin = Toolkit.getDefaultToolkit().getImage("C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\gameWin.png");
    private Image gameLose = Toolkit.getDefaultToolkit().getImage("C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\gameLose.png");
    // 游戏背景
    Background background = new Background(this);
    // 游戏玩家
    Champion player = new ChampionDaji(this);
    // 双方小兵
    MinionBlue mb = new MinionBlue(this);
    MinionRed mr = new MinionRed(this);
    //野怪
    public Beast beast = new Beast(this);
    // 防御塔
    Turret turret = new Turret(this);
    // 游戏元素列表
   public ArrayList&lt;GameObject&gt; objList = new ArrayList&lt;&gt;();
    ArrayList&lt;GameObject&gt; redList = new ArrayList&lt;&gt;();// 红色方
    ArrayList&lt;GameObject&gt; blueList = new ArrayList&lt;&gt;();// 蓝色方
    public ArrayList&lt;GameObject&gt; removeList = new ArrayList&lt;&gt;();// 存放将要删除的元素
 
    public void launch() {
        // 设置尺寸
        setSize(windowWidth, windowHeight);
        // 窗口居中
        setLocationRelativeTo(null);
        // 关闭事件
        setDefaultCloseOperation(3);
        // 用户不能调整窗口大小
        setResizable(false);
        // 标题
        setTitle("王者荣耀");
        // 窗口可见
        setVisible(true);
        // 添加键盘监视器
        this.addKeyListener(new GameFrame.KeyMonitor());
        // 添加游戏元素
        objList.add(background);
        objList.add(player);
        objList.addAll(beast.beastList);
        objList.addAll(turret.turretList);
        playMusic();
       for (int i = 0; i &lt; 4; i++) {
            blueList.add(turret.turretList.get(i));
        }
        for (int i = 4; i &lt; 8; i++) {
            redList.add(turret.turretList.get(i));
        }
 
 
        /**
         * 攻击按钮
         */
        JButton button = new JButton();
        button.setSize(130, 132);
        button.setLocation(1150, 430);
        button.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                // 按钮事件
                player.attack(redList);
            }
        });
        this.add(button);
        player.addButton();
        while (true) {
 
            mb.createMinion(this, blueList);
            mr.createMinion(this, redList);
            repaint();
            try {
                Thread.sleep(25);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
 
    public void paint(Graphics g) {
        if (offScreenImage == null) {
            offScreenImage = this.createImage(5984, 4452);
        }
        Graphics gImage = offScreenImage.getGraphics();
       if(state==0){
           turret.isLive();
            for (int i = 0; i &lt; objList.size(); i++) {
                objList.get(i).paintSelf(gImage);
            }
            // 绘制攻击图片
           gImage.drawImage(attack, player.getX() + 500, player.getY() + 100, null);
 
            objList.removeAll(removeList);
        } else if (state ==1) {//游戏胜利
 
            gImage.drawImage(gameWin, player.getX()-700, player.getY()-300 , null);
        } else if (state == 2) {//游戏失败
            gImage.drawImage(gameLose, player.getX()-700, player.getY()-300, null);
        }
        g.drawImage(offScreenImage, -player.getX() + 700, -player.getY() + 350, null);
         // 添加按钮后不能调用键盘事件 因为程序的焦点变成了按钮 this.requestFocus() 把焦点重新改变到游戏界面上
 
        this.requestFocus();
    }
 
    // main方法
    public static void main(String[] args) {
        GameFrame gameFrame = new GameFrame();
        gameFrame.launch();
 
    }
    // 键盘事件
    private class KeyMonitor extends KeyAdapter {
        @Override
        public void keyPressed(KeyEvent e) {
            int key = e.getKeyCode();
            player.keyPressed(e);
        }
 
        @Override
        public void keyReleased(KeyEvent e) {
            int key = e.getKeyCode();
            player.keyReleased(e);
        }
    }
    static Clip clip;
    public static void playMusic() {
        try
        {
            //这里面放 绝对路径，音频必须是wav格式，用音频转换软件 把mp3 转成wav格式
            File musicPath = new File("C:\\Users\\23839\\IdeaProjects\\PlaneWar\\PlayMusic\\bgm.wav");
 
            if(musicPath.exists())
            {
                AudioInputStream audioInput = AudioSystem.getAudioInputStream(musicPath);
                clip = AudioSystem.getClip();
                clip.open(audioInput);
                FloatControl gainControl = (FloatControl)clip.getControl(FloatControl.Type.MASTER_GAIN);
                gainControl.setValue(-20.0f);//设置音量，范围为 -60.0f 到 6.0f
                clip.start();
                clip.loop(Clip.LOOP_CONTINUOUSLY);
            }
            else
            {
            }
        }
        catch(Exception ex)
        {
            ex.printStackTrace();
        }
    }
 
}</code></pre> 
<h3 id="%E4%BA%8C%EF%BC%8C%E6%B8%B8%E6%88%8F%E5%85%83%E7%B4%A0%E7%88%B6%E7%B1%BB">二，游戏元素父类</h3> 
<p>作用：初始化基本变量，定义addHp（）方法，两点之间的距离方法，矩形与矩形的碰撞检测方法，矩形与圆形的碰撞检测方法，定义防御塔，英雄，小兵的攻击方法，用线程实现攻击的冷却时间。</p> 
<pre><code class="language-java">package com.sxt;
 
import java.awt.*;
import java.util.ArrayList;
 
//游戏元素的父类
public abstract class GameObject {
    // 坐标
    private int x;
    private int y;
    // 图片
    private Image img;
    // 游戏界面
    public GameFrame gameFrame;
    // 速度
    private int spd;
    // 初始生命值
    private int hp;
    // 当前生命值
    private int currentHp;
    // 攻击目标
    private GameObject target;
    // 是否有目标
    private boolean hasTarget = false;
    // 攻击距离
    private int dis;
    // 攻击时间间隔
    private int attackCoolDownTime;
    // 攻击是否冷却
    private boolean attackCoolDown = true;
    // 是否存活
    private boolean alive = true;
    //是否被控制
    boolean beControlled = false;
 
    public GameObject(GameFrame gameFrame) {
        this.gameFrame = gameFrame;
    }
 
    public GameObject(int x, int y, GameFrame gameFrame) {
        this.x = x;
        this.y = y;
        this.gameFrame = gameFrame;
    }
 
    public GameObject() {
    }
    public void addHp(Graphics g, int difX, int difY, int width, int height, Color color) {
        // 绘制外部轮廓
        g.setColor(Color.black);
        g.drawRect(getX() - difX, getY() - difY, width, height);
        // 填充矩形
        g.setColor(color);
        g.fillRect(getX() - difX, getY() - difY, (int) (width * getCurrentHp() / getHp()), height);
    }
 
    public double getDis(int x1, int y1, int x2, int y2) {
        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    }
 
    // 矩形矩形碰撞检测
    public boolean recIntersectsRec(Rectangle r1, Rectangle r2) {
        return r1.intersects(r2);
    }
 
    public boolean recIntersectsCir(Rectangle rec, int x, int y, int r) {
        // 矩形于圆相交： 圆心到至少一个矩形定点的距离小于r
        if ((getDis(x, y, rec.x, rec.y) &lt; r) || (getDis(x, y, rec.x, rec.y + rec.height) &lt; r)
                || (getDis(x, y, rec.x + rec.width, rec.y) &lt; r)
                || (getDis(x, y, rec.x + rec.width, rec.y + rec.height) &lt; r)) {
            return true;
        }
        return false;
    }
 
    // 攻击方法
    public void attack(ArrayList&lt;GameObject&gt; gameObjList) {
        if (hasTarget) {
            // 目标离开范围后寻找新的目标
            if (!recIntersectsCir(target.getRec(), getX(), getY(), getDis())) {
                setHasTarget(false);
            }
            // 目标死亡，寻找新目标
            else if (!target.isAlive()) {
                setHasTarget(false);
            } else if (isAttackCoolDown() &amp;&amp; isAlive()) {
                Bullet bullet = null;
                // 防御塔攻击
                if (Turret.class.isAssignableFrom(getClass())) {
                    bullet = new Bullet(gameFrame, this, getTarget(), 500, 50);
                }
                // 小兵攻击
                else if (Minion.class.isAssignableFrom(getClass())) {
                    bullet = new Bullet(gameFrame, this, getTarget(), 50, 30);
                }
                // 玩家攻击
                else if (this instanceof Champion) {
                    bullet = new Bullet(gameFrame, this, getTarget(), 500, 50);
                }
                gameFrame.objList.add(bullet);
                // 线程开始
                new AttackCD().start();
            }
        } else {
            // 遍历列表
            for (GameObject obj : gameObjList) {
                // 判断攻击范围（圆形）与敌方（矩形）是否相交
                if (recIntersectsCir(obj.getRec(), getX(), getY(), getDis())) {
                    // 找到目标
                    setTarget(obj);
                    setHasTarget(true);
                    // 跳出循环
                    break;
                }
            }
            // 玩家是否在攻击范围内
            if (!hasTarget &amp;&amp; gameObjList == gameFrame.blueList) {
                if (recIntersectsCir(gameFrame.player.getRec(), getX(), getY(), getDis())) {
                    // 找到目标
                    setTarget(gameFrame.player);
                    setHasTarget(true);
                }
            }
            else {
                //野怪是否在攻击范围内
                for (GameObject obj : gameFrame.beast.beastList) {
                    // 判断攻击范围（圆形）与敌方（矩形）是否相交
                    if (recIntersectsCir(obj.getRec(), getX(), getY(), getDis())) {
                        // 找到目标
                        setTarget(obj);
                        setHasTarget(true);
                        // 跳出循环
                        break;
                    }
                }
            }
        }
    }
 
    //public abstract void addTurret();
 
    class AttackCD extends Thread {
        public void run() {
            // 将攻击功能设置为冷却状态
            setAttackCoolDown(false);
            // 线程休眠
            try {
                Thread.sleep(attackCoolDownTime);
            } catch (Exception e) {
                e.printStackTrace();
            }
            // 将攻击功能设置为攻击状态
            setAttackCoolDown(true);
            // 线程终止
            this.interrupt();
        }
    }
 
    // 绘制元素
    public abstract void paintSelf(Graphics g);
 
    // 返回矩形
    public abstract Rectangle getRec();
    public int getX() {
        return x;
    }
    public void setX(int x) {
        this.x = x;
    }
    public int getY() {
        return y;
    }
    public void setY(int y) {
        this.y = y;
    }
    public Image getImg() {
        return img;
    }
    public void setImg(String img) {
        this.img = Toolkit.getDefaultToolkit().getImage(img);
    }
    public int getSpd() {
        return spd;
    }
    public void setSpd(int spd) {
        this.spd = spd;
    }
    public int getHp() {
        return hp;
    }
    public void setHp(int hp) {
        this.hp = hp;
    }
    public int getCurrentHp() {
        return currentHp;
    }
    public void setCurrentHp(int currentHp) {
        this.currentHp = currentHp;
    }
    public GameObject getTarget() {
        return target;
    }
    public void setTarget(GameObject target) {
        this.target = target;
    }
    public boolean isHasTarget() {
        return hasTarget;
    }
    public void setHasTarget(boolean hasTarget) {
        this.hasTarget = hasTarget;
    }
    public int getDis() {
        return dis;
    }
    public void setDis(int dis) {
        this.dis = dis;
    }
    public int getAttackCoolDownTime() {
        return attackCoolDownTime;
    }
    public void setAttackCoolDownTime(int attackCoolDownTime) {
        this.attackCoolDownTime = attackCoolDownTime;
    }
    public boolean isAttackCoolDown() {
        return attackCoolDown;
    }
    public void setAttackCoolDown(boolean attackCoolDown) {
        this.attackCoolDown = attackCoolDown;
    }
    public boolean isAlive() {
        return alive;
    }
    public void setAlive(boolean alive) {
        this.alive = alive;
    }
}</code></pre> 
<p> </p> 
<h3 id="%C2%A0%E4%B8%89%EF%BC%8C%E9%98%B2%E5%BE%A1%E5%A1%94%E7%B1%BB">三，防御塔类</h3> 
<p>作用：初始化防御塔并添加到窗口中，游戏失败与胜利方法，在绘制自身方法中通过判断血量删除元素或者绘制防御塔。</p> 
<pre><code class="language-java">package com.sxt;
 
import java.awt.*;
import java.util.ArrayList;
//防御塔类
public  class Turret extends GameObject{
 
    ArrayList&lt;Turret&gt; turretList = new ArrayList&lt;&gt;();
    public Turret turretBlueOne;
    public Turret turretBlueTwo;
    public Turret turretBlueThree;
    public Turret turretBlueBase;
    public Turret turretRedOne;
    public Turret turretRedTwo;
    public Turret turretRedThree;
    public Turret turretRedBase;
 
    public Turret(GameFrame gameFrame) {
        super(gameFrame);
        setImg("C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\turret.png");
 
        // 初始化八个防御塔
        turretList.add(turretBlueOne = new TurretBlue(1860, 3790, gameFrame));
        turretList.add(turretBlueTwo = new TurretBlue(2650, 3820, gameFrame));
        turretList.add(turretBlueThree = new TurretBlue(3995, 3830, gameFrame));
        turretList.add(turretBlueBase = new TurretBlue(1130, 3650, gameFrame));
        turretList.add(turretRedOne = new TurretRed(5100, 3030, gameFrame));
        turretList.add(turretRedTwo = new TurretRed(5120, 2100, gameFrame));
        turretList.add(turretRedThree = new TurretRed(5060, 1570, gameFrame));
        turretList.add(turretRedBase = new TurretRed(4850, 1100, gameFrame));
 
    }
 
    public Turret(int x, int y, GameFrame gameFrame) {
        super(x, y, gameFrame);
        setImg("C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\turret.png");
        setHp(6000);
        setCurrentHp(getHp());
        setAttackCoolDownTime(1000);
        setDis(300);
    }
    public void isLive(){
        if(gameFrame.turret.turretBlueBase.getCurrentHp()==0){
            gameFrame.state=2;
        }
        if(gameFrame.turret.turretRedBase.getCurrentHp()==0){
            gameFrame.state=1;
        }
    }
    @Override
    public void paintSelf(Graphics g) {
        // 生命值为0
        if (getCurrentHp() &lt;= 0) {
            setAlive(false);
            gameFrame.removeList.add(this);
            if (this instanceof TurretBlue) {
                gameFrame.blueList.remove(this);
            } else {
                gameFrame.redList.remove(this);
            }
        } else {
            // 添加生命值
            if (this instanceof TurretBlue) {
                this.addHp(g, 50, 130, 100, 20, Color.GREEN);
                attack(gameFrame.redList);
            } else {
                this.addHp(g, 50, 130, 100, 20, Color.RED);
                attack(gameFrame.blueList);
            }
            g.drawImage(getImg(), getX() - 50, getY() - 100, null);
            g.fillOval(getX(), getY(), 10, 10);
            g.drawRect(getX() - 50, getY() - 100, 100, 180);
            g.drawOval(getX() - 300, getY() - 300, 600, 600);
        }
    }
 
    @Override
    public Rectangle getRec() {
        return new Rectangle(getX() - 50, getY() - 100, 100, 180);
    }
}</code></pre> 
<h4 id="1.%E8%93%9D%E8%89%B2%E9%98%B2%E5%BE%A1%E5%A1%94">1.蓝色防御塔</h4> 
<p>作用：有参构造。</p> 
<pre><code class="language-java">package com.sxt;
//蓝方防御塔
public class TurretBlue extends Turret{
    public TurretBlue(GameFrame gameFrame){
        super(gameFrame);
    }
    public TurretBlue(int x,int y,GameFrame gameFrame){
        super(x,y,gameFrame);
    }
}</code></pre> 
<h4>2.红方防御塔</h4> 
<p>作用：有参构造。</p> 
<pre><code class="language-java">package com.sxt;
//蓝方防御塔
public class TurretRed extends Turret{
    //有参构造
    public TurretRed(GameFrame gameFrame){
        super(gameFrame);
    }
    public TurretRed(int x,int y,GameFrame gameFrame){
        super(x,y,gameFrame);
    }
}</code></pre> 
<h3 id="%E5%9B%9B%EF%BC%8C%E8%8B%B1%E9%9B%84%E7%B1%BB">四，英雄类</h3> 
<p>作用:实现键盘监听，添加按钮，鼠标监听。</p> 
<pre><code class="language-java">package com.sxt;
 
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
 
import javax.swing.JButton;
 
//游戏英雄类
public abstract class Champion extends GameObject {
    // 移动
    public boolean up, down, left, right;
    // 移动图集
    static String[] imgs = new String[8];
    // 第几张图片
    int moveCount = 1;
    //技能图片
    Image abilityOne;
    Image abilityTwo;
    Image abilityThree;
    //技能冷却时间
    int coolDownTimeOne;
    int coolDownTimeTwo;
    int coolDownTimeThree;
    //三个技能是否处于冷却状态
    boolean coolDownOne = true;
    boolean coolDownTwo = true;
    boolean coolDownThree = true;
 
    static {
        for (int i = 1; i &lt; 8; i++) {
            imgs[i] = "C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\move\\" + i + ".png";
        }
    }
    public Champion(GameFrame gameFrame) {
        super(gameFrame);
 
        //定义英雄的图片和坐标
        setImg("C:\\Users\\23839\\IdeaProjects\\HonorOfKings\\src\\imgs\\stand.png");
        setX(700);
        setY(3800);
        setSpd(75);
        setHp(24000);
        setDis(250);
        setAttackCoolDownTime(100);
        setCurrentHp(getHp());
    }
 
    public void keyPressed(KeyEvent e) {
        int key = e.getKeyCode();
        if (key == KeyEvent.VK_D) {
            right = true;}
        if (key == KeyEvent.VK_A) {
            left = true;}
        if (key == KeyEvent.VK_W) {
            up = true;}
        if (key == KeyEvent.VK_S) {
            down = true;}
    }
 
    public void keyReleased(KeyEvent e) {
        int key = e.getKeyCode();
        if (key == KeyEvent.VK_D) {
            right = false;}
        if (key == KeyEvent.VK_A) {
            left = false;}
        if (key == KeyEvent.VK_W) {
            up = false;}
        if (key == KeyEvent.VK_S) {
            down = false;}
    }
    public void move() {
        if (up) {
            setY(getY() - getSpd());
        }
        if (down) {
            setY(getY() + getSpd());
        }
        if (left) {
            setX(getX() - getSpd());
        }
        if (right) {
            setX(getX() + getSpd());
        }
        if (up || down || left || right) {
            setImg(imgs[moveCount]);
            moveCount++;
            if (moveCount == 8) {
                moveCount = 1;
            }
        } else {
            setImg("C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\stand.png");
        }
    }
 
    //添加三个技能按钮
 
    public void addButton() {
        JButton button1 = new JButton();
        button1.setSize(100, 100);
        button1.setLocation(1056, 513);
        button1.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                abilityOne();
            }
        });
        JButton button2 = new JButton();
        button2.setSize(100, 100);
        button2.setLocation(1090, 370);
        button2.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                abilityTwo();
            }
        });
        JButton button3 = new JButton();
        button3.setSize(100, 100);
        button3.setLocation(1220, 300);
        button3.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                abilityThree();
            }
        });
        gameFrame.add(button1);
        gameFrame.add(button2);
        gameFrame.add(button3);
    }
 
    public abstract void abilityOne();
    public abstract void abilityTwo();
    public abstract void abilityThree();
    public abstract void abilityEffect(Graphics g);
 
    @Override
    public void paintSelf(Graphics g) {
        // 生命值为0
        if (getCurrentHp() &lt;= 0) {
            setAlive(false);
            gameFrame.removeList.add(this);
 
        } else {
            // 添加生命值
            addHp(g, 30, 80, 80, 20, Color.GREEN);
            //绘制技能图片
            g.drawImage(abilityOne, getX() + 360, getY() + 180, null);
            g.drawImage(abilityTwo, getX() + 400, getY() + 40, null);
            g.drawImage(abilityThree, getX() + 520, getY() - 30, null);
            // 绘制图片
            g.drawImage(this.getImg(), getX() - 33, getY() - 50, null);
            // 改变画笔颜色
            g.setColor(Color.GREEN);
            // 绘制中心圆点
            g.fillOval(getX(), getY(), 10, 10);
            // 绘制矩形边框
            g.drawRect(getX() - 23, getY() - 50, 60, 120);
            move();
            abilityEffect(g);
        }
    }
 
    @Override
    public Rectangle getRec() {
        return new Rectangle(getX() - 30, getY() - 60, 60, 120);
    }
 
}</code></pre> 
<h3 id="1.%E8%8B%B1%E9%9B%84%E5%A6%B2%E5%B7%B1">1.英雄妲己</h3> 
<p>作用：定义三个技能的具体实现方法，用线程实现技能的冷却时间，控制时间，鼠标监视器实现释放技能一，定义技能效果。</p> 
<pre><code class="language-java">package com.sxt;
 
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Polygon;
import java.awt.Toolkit;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Random;
 
 
 
public class ChampionDaji extends Champion {
 
    // 技能是否处于释放状态
    boolean ifAbilityOne = false;
    boolean ifAbilityTwo = false;
    // 鼠标监视器
   MouseMonitor m;
    // 一技能多边形
    Polygon p;
    // 一技能三角函数
    double sin;
    double cos;
    // 一技能已经攻击过的目标
    ArrayList&lt;GameObject&gt; attacked;
    // 一技能移动次数
    int step = 0;
    // 技能二目标
    GameObject abilityTwoTarget;
    // 技能二子弹
    Bullet abilityTwoBullet;
    // 三技能的五个子弹，释放三技能后重新定义
    Bullet[] bulletList = { new Bullet(), new Bullet(), new Bullet(), new Bullet(), new Bullet() };
 
    public ChampionDaji(GameFrame gameFrame) {
        super(gameFrame);
        abilityOne = Toolkit.getDefaultToolkit().getImage("C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\Daji\\abilityOne.jpg");
        abilityTwo = Toolkit.getDefaultToolkit().getImage("C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\Daji\\abilityTwo.jpg");
        abilityThree = Toolkit.getDefaultToolkit().getImage("C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\Daji\\abilityThree.jpg");
        // 三个技能冷却时间
        coolDownTimeOne = 3000;
        coolDownTimeTwo = 5000;
        coolDownTimeThree = 8000;
    }
 
    public void exit() {
        this.gameFrame.removeMouseListener(m);
    }
 
    public void abilityOneMove() {
        p.translate((int) (50 * cos), -(int) (50 * sin));
        for (GameObject redObj : gameFrame.redList) {
            // 是红色方小兵 &amp;&amp; 发生碰撞 &amp;&amp; 没在attacked列表里
            if (redObj instanceof MinionRed &amp;&amp; p.intersects(redObj.getRec()) &amp;&amp; attacked.indexOf(redObj) == -1) {
                // 小兵扣血，添加到attacked里
                redObj.setCurrentHp(redObj.getCurrentHp() - 400);
                attacked.add(redObj);
            }
        }
    }
 
    @Override
    public void abilityOne() {
        if (coolDownOne) {
            m = new MouseMonitor();
            p = new Polygon();
            gameFrame.addMouseListener(m);
            attacked = new ArrayList&lt;GameObject&gt;();
        }
    }
 
 
    public void abilityTwo() {
        if (coolDownTwo) {
            boolean find = false;
            for (GameObject redObj : gameFrame.objList) {
                // 是红色小兵 &amp;&amp; 距离小于250 &amp;&amp; 存活
                if (redObj instanceof MinionRed &amp;&amp; recIntersectsCir(redObj.getRec(), getX(), getY(), 250)
                        &amp;&amp; redObj.isAlive()) {
                    // 添加子弹
                    abilityTwoBullet = new Bullet(gameFrame, this, redObj, 250, 60, "C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\Daji\\abilityTwoBullet.png");
                    gameFrame.objList.add(abilityTwoBullet);
                    // 给目标赋值
                    abilityTwoTarget = redObj;
                    // 释放二技能
                    ifAbilityTwo = true;
                    find = true;
                    break;
                }
            }
            if (find) {
                new AbilityTwoCD().start();
                find = false;
            }
        }
    }
 
    /**
     * 点击技能三释放技能 先将技能范围内目标储存到targetList里 提前定义五个子弹 技能释放时初始化五个子弹 子弹目标从targetList里随机选择
     * 如果期间目标死亡，制作一个目标替身，生命值设置为true 子弹与目标或替身碰撞后消失
     */
    @Override
    public void abilityThree() {
        if (coolDownThree) {
            // 创建列表来储存目标
            ArrayList&lt;GameObject&gt; targetList = new ArrayList&lt;GameObject&gt;();
            // 遍历redList，找到符合条件的目标，储存到列表里
            for (int i = 0; i &lt; gameFrame.objList.size(); i++) {
                GameObject target = gameFrame.objList.get(i);
                // 是红色小兵 &amp;&amp; 在技能范围里 &amp;&amp; 存活
                if (target instanceof MinionRed &amp;&amp; recIntersectsCir(target.getRec(), getX(), getY(), 250)
                        &amp;&amp; target.isAlive()) {
                    targetList.add(target);
                }
            }
            // 找到目标
            if (targetList.size() != 0) {
                // 创建五个子弹，随机攻击列表里的目标
                Random random = new Random();
                int count = 0; // 统计三技能发射子弹数量
                while (count &lt; 5) {
                    int r = random.nextInt(targetList.size());
                    if (!targetList.get(r).isAlive()) {
                        GameObject substitute = targetList.get(r);
                        substitute.setAlive(true);
                        bulletList[count] = new Bullet(gameFrame, this, substitute, 150, 60,
                                "C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\Daji\\abilityTwoBullet.png");
                    } else {
                        bulletList[count] = new Bullet(gameFrame, this, targetList.get(r), 150, 60,
                                "C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\Daji\\abilityTwoBullet.png");
                    }
                    count++;
                }
                new AbilityThreeBulletCD().start();
                // 三技能进入冷却
                new AbilityThreeCD().start();
            }
        }
    }
 
    @Override
    public void abilityEffect(Graphics g) {
        if (ifAbilityOne) {
            g.setColor(Color.RED);
            g.fillPolygon(p);
            abilityOneMove();
            step++;
            if (step == 10) {
                step = 0;
                ifAbilityOne = false;
            }
        }
        if (ifAbilityTwo) {
            System.out.println(abilityTwoTarget.beControlled);
            if (abilityTwoBullet.getRec().intersects(abilityTwoTarget.getRec())) {
                new AbilityControllCD().start();
                ifAbilityTwo = false;
            }
        }
    }
 
    // 技能一冷却时间
    class AbilityOneCD extends Thread {
        public void run() {
            // 将技能一设置为冷却状态
            coolDownOne = false;
            // 线程休眠
            try {
                // one来表示一技能冷却时间
                int one = coolDownTimeOne;
                while (one &gt; 0) {
                    Thread.sleep(1000);
                    System.out.println("一技能冷却时间： " + one / 1000);
                    one -= 1000;
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            // 将技能一设置为攻击状态
            coolDownOne = true;
            // 线程终止
            this.interrupt();
        }
    }
 
    // 技能二冷却时间
    class AbilityTwoCD extends Thread {
        public void run() {
            // 将技能二设置为冷却状态
            coolDownTwo = false;
            // 线程休眠
            try {
                // one来表示二技能冷却时间
                int two = coolDownTimeTwo;
                while (two &gt; 0) {
                    Thread.sleep(1000);
                    System.out.println("二技能冷却时间： " + two / 1000);
                    two -= 1000;
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            // 将技能二设置为攻击状态
            coolDownTwo = true;
            // 线程终止
            this.interrupt();
        }
    }
 
    // 技能二控制时间
    class AbilityControllCD extends Thread {
        public void run() {
            abilityTwoTarget.beControlled = true;
            // 线程休眠
            try {
                Thread.sleep(20000);
            } catch (Exception e) {
                e.printStackTrace();
            }
            abilityTwoTarget.beControlled = false;
            this.interrupt();
        }
 
    }
    //技能三冷却状态
    class AbilityThreeCD extends Thread {
        public void run() {
            // 将攻击功能设置为冷却状态
            coolDownThree = false;
            // 休眠
            try {
                int three = coolDownTimeThree;
                while (coolDownTimeThree &gt; 0) {
                    Thread.sleep(1000);
                    System.out.println("技能三冷却时间： " + coolDownTimeThree / 1000);
                    coolDownTimeThree -= 1000;
                }
                coolDownTimeThree = three;
            } catch (Exception e) {
                e.printStackTrace();
            }
            // 将攻击功能解除冷却状态
            coolDownThree = true;
            // 线程终止
            this.interrupt();
        }
    }
 
    class AbilityThreeBulletCD extends Thread {
        public void run() {
            // 休眠
            try {
                System.out.println("Thread start");
                gameFrame.objList.add(bulletList[0]);
                Thread.sleep(100);
                gameFrame.objList.add(bulletList[1]);
                Thread.sleep(100);
                gameFrame.objList.add(bulletList[2]);
                Thread.sleep(100);
                gameFrame.objList.add(bulletList[3]);
                Thread.sleep(100);
                gameFrame.objList.add(bulletList[4]);
            } catch (Exception e) {
                e.printStackTrace();
            }
            // 线程终止
            this.interrupt();
        }
    }
 
    // 鼠标监视器
    private class MouseMonitor extends MouseAdapter {
        @Override
        public void mousePressed(MouseEvent e) {// 当鼠标点击时
            int mouseX = e.getX(), mouseY = e.getY(), playerX = 700, playerY = 350;
            double dis = getDis(mouseX, mouseY, playerX, playerY);
            // 三角函数
            cos = (mouseX - playerX) / dis;
            sin = -(mouseY - playerY) / dis;
            // 坐标差
            int difX = (int) (60 * sin);
            int difY = (int) (60 * cos);
            p.addPoint(getX() - difX, getY() - difY);
            p.addPoint(getX() + difX, getY() + difY);
            p.addPoint(getX() + difX + (int) (20 * cos), getY() + difY - (int) (20 * sin));
            p.addPoint(getX() - difX + (int) (20 * cos), getY() - difY - (int) (20 * sin));
            exit();
            new AbilityOneCD().start();
            ifAbilityOne = true;
        }
    }
}</code></pre> 
<h4 id="%E4%BA%94%EF%BC%8C%E5%B0%8F%E5%85%B5%E7%B1%BB">五，小兵类</h4> 
<p>作用：初始化小兵的基本参数，实现找到目标方法，向目标移动方法。每波小兵生成的时间，每个小兵生成的时间，在绘制自身方法中通过判断血量是否为零实现删除元素功能和绘制小兵功能。</p> 
<pre><code class="language-java">package com.sxt;
 
import java.awt.*;
import java.util.ArrayList;
 
public abstract class Minion extends GameObject{
 
    // 是否生成下一个小兵
    private boolean nextMinion = true;
    // 是否生成下一波小兵
    private boolean nextLine = true;
    // 生成小兵数量
    private int minionCount = 0;
    // 是否检测到目标
    private boolean ifFindTarget = false;
 
    public Minion(GameFrame gameFrame) {
        super(gameFrame);
        setHp(800);
        setCurrentHp(getHp());
        setDis(100);
        setAttackCoolDownTime(2000);
    }
 
    /**
     * (1325, 3750) (4425, 3750) (5050, 3125) (5050, 1125)
     */
 
    public abstract void move(ArrayList&lt;GameObject&gt; objList);
 
    public void findTarget(ArrayList&lt;GameObject&gt; objList) {
        for (GameObject obj : objList) {
            if (recIntersectsCir(obj.getRec(), getX(), getY(), 200)) {
                setTarget(obj);
                setIfFindTarget(true);
            }
        }
        if (objList == gameFrame.blueList) {
            if (recIntersectsCir(gameFrame.player.getRec(), getX(), getY(), 200)) {
                setTarget(gameFrame.player);
                setIfFindTarget(true);
            }
        }
    }
 
    public void moveToTarget() {
        int dis = (int) getDis(getX(), getY(), getTarget().getX(), getTarget().getY());
        if(dis!=0) {
            int xSpeed =  (getSpd() * (getTarget().getX() - getX()) / dis);
            int ySpeed = (getSpd() * (getTarget().getY() - getY()) / dis);
            setX(getX() + xSpeed);
            setY(getY() + ySpeed);
        }
    }
 
    public void createMinion(GameFrame gameFrame, ArrayList&lt;GameObject&gt; minionList) {
        if (nextLine) {
            if (nextMinion) {
                // 蓝色方小兵
                if (minionList == this.gameFrame.blueList) {
                    MinionBlue mb = new MinionBlue(gameFrame);
                    gameFrame.objList.add(mb);
                    minionList.add(mb);
                }
                // 红色方小兵
                else {
                    MinionRed mr = new MinionRed(gameFrame);
                    gameFrame.objList.add(mr);
                    minionList.add(mr);
                }
                minionCount++;
                new NextMinion().start();
            }
            if (minionCount == 3) {
                minionCount = 0;
                new NextLine().start();
            }
        }
    }
 
    // 每个小兵生成时间
    class NextMinion extends Thread {
        public void run() {
            nextMinion = false;
            // 休眠1.5s
            try {
                Thread.sleep(1500);
            } catch (Exception e) {
                e.printStackTrace();
            }
            nextMinion = true;
            // 线程终止
            this.interrupt();
        }
    }
 
    // 每波小兵生成时间
    class NextLine extends Thread {
        public void run() {
            nextLine = false;
            // 休眠15s
            try {
                Thread.sleep(15000);
            } catch (Exception e) {
                e.printStackTrace();
            }
            nextLine = true;
            // 线程终止
            this.interrupt();
        }
    }
 
    @Override
    public void paintSelf(Graphics g) {
        // 生命值为0
        if (getCurrentHp() &lt;= 0) {
            setAlive(false);
            gameFrame.removeList.add(this);
            if (this instanceof MinionBlue) {
                gameFrame.blueList.remove(this);
            } else {
                gameFrame.redList.remove(this);
            }
        } else {
            // 添加生命值
            if (this instanceof MinionBlue) {
                this.addHp(g, 17, 28, 45, 10, Color.GREEN);
            } else {
                this.addHp(g, 17, 28, 45, 10, Color.RED);
            }
            g.drawImage(getImg(), getX() - 16, getY() - 16, null);
            g.setColor(Color.RED);
            g.fillOval(getX(), getY(), 10, 10);
            g.drawRect(getX() - 16, getY() - 16, 45, 45);
            g.drawOval(getX() - 200, getY() - 200, 400, 400);
            // 小兵移动
            if (!beControlled) {
                if (this instanceof MinionBlue) {
                    move(gameFrame.redList);
                } else {
                    move(gameFrame.blueList);
                }
            }
        }
    }
 
    @Override
    public Rectangle getRec() {
        return new Rectangle(getX() - 16, getY() - 16, 45, 45);
    }
 
    public boolean isIfFindTarget() {
        return ifFindTarget;
    }
    public void setIfFindTarget(boolean ifFindTarget) {
        this.ifFindTarget = ifFindTarget;
    }
 
}</code></pre> 
<h4 id="%C2%A01.%E7%BA%A2%E6%96%B9%E5%B0%8F%E5%85%B5">1.红方小兵</h4> 
<p>作用：具体的红方小兵移动方法。 </p> 
<pre><code class="language-java">package com.sxt;
 
import java.util.ArrayList;
 
public  class MinionRed extends Minion {
    public MinionRed(GameFrame gameFrame) {
        super(gameFrame);
        setImg("C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\minion\\red.jpg");
        setX(5050);
        setY(1125);
    }
 
    @Override
    public void move(ArrayList&lt;GameObject&gt; objList) {
        if (isIfFindTarget()) {
            // 离开检测范围
            if (!recIntersectsCir(getTarget().getRec(), getX(), getY(), 200)) {
                setIfFindTarget(false);
            } else {
                if (!isHasTarget()) {
                    moveToTarget();
                }
                attack(objList);
            }
        } else {
            findTarget(objList);
            // 原路线移动
            if (getY() &lt; 3125) {
                setSpd(28);
                setY(getY() + getSpd());
            } else if (getY() &lt; 3750 &amp;&amp; getY() &gt;= 3125) {
                setSpd(20);
                setY(getY() + getSpd());
                setX(getX() - getSpd());
            } else if (getY() &gt;= 3750) {
                setSpd(25);
                setX(getX() - getSpd());
            }
        }
    }
 
 
 
 
}</code></pre> 
<h4 id="2.%E8%93%9D%E6%96%B9%E5%B0%8F%E5%85%B5">2.蓝方小兵</h4> 
<p>作用：具体的蓝方小兵移动方法。</p> 
<pre><code class="language-java">package com.sxt;
 
import java.util.ArrayList;
 
public  class MinionBlue extends Minion{
 
    public MinionBlue(GameFrame gameFrame) {
        super(gameFrame);
        setImg("C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\minion\\blue.jpg");
        setX(1325);
        setY(3750);
    }
 
    @Override
    public void move(ArrayList&lt;GameObject&gt; objList) {
        if(isIfFindTarget()) {
            //离开检测范围
            if(!recIntersectsCir(getTarget().getRec(), getX(), getY(), 200)) {
                setIfFindTarget(false);
            }else {
                if(!isHasTarget()) {
                    moveToTarget();
                }
                attack(objList);
            }
        }else {
            findTarget(objList);
            //原路线移动
            if(getX() &lt; 4425) {
                setSpd(5);
                setX(getX() + getSpd());
            }else if(getX() &lt; 5100 &amp;&amp; getX() &gt;= 4425) {
                setSpd(20);
                setX(getX() + getSpd());
                setY(getY() - getSpd());
            }else if(getX() &gt;= 4900) {
                setSpd(18);
                setY(getY() - getSpd());
            }
        }
    }
}</code></pre> 
<h3 id="%E5%85%AD%EF%BC%8C%E5%AD%90%E5%BC%B9%E7%B1%BB">六，子弹类</h3> 
<p>作用：子弹移动方法。</p> 
<pre><code class="language-java">package com.sxt;
 
import java.awt.*;
 
//子弹类
public  class Bullet extends GameObject {
 
    //发射子弹的游戏元素
    GameObject attacker;
    //目标
    GameObject target;
    //攻击力
    int ad;
 
    public Bullet(GameFrame gameFrame, GameObject attacker, GameObject target, int ad, int spd) {
        super(attacker.getX(), attacker.getY(), gameFrame);
        this.attacker = attacker;
        this.target = target;
        setAd(ad);
        setSpd(spd);
    }
 
    public Bullet(GameFrame gameFrame, GameObject attacker, GameObject target, int ad, int spd, String img) {
        super(attacker.getX(), attacker.getY(), gameFrame);
        this.attacker = attacker;
        this.target = target;
        setImg(img);
        setAd(ad);
        setSpd(spd);
    }
 
    public Bullet() {
        super();
    }
 
    public void move() {
        //子弹与目标碰撞，子弹消失，目标减血
        if (recIntersectsRec(getRec(), target.getRec())) {
            target.setCurrentHp(target.getCurrentHp() - getAd());
            gameFrame.removeList.add(this);
        }
        int dis = (int) getDis(getX(), getY(), target.getX(), target.getY());
        if (dis != 0) {
            int xSpeed =  (getSpd() * (target.getX() - getX()) / dis);
            int ySpeed =  (getSpd() * (target.getY() - getY()) / dis);
            setX(getX() + xSpeed);
            setY(getY() + ySpeed);
        }
    }
 
    @Override
    public void paintSelf(Graphics g) {
        g.drawImage(getImg(), getX()-16, getY()-16, null);
        g.setColor(Color.BLACK);
        g.fillOval(getX()-5, getY()-5, 10, 10);
        g.drawRect(getX()-5, getY()-5, 10, 10);
        move();
    }
 
    @Override
    public Rectangle getRec() {
        return new Rectangle(getX()-5, getY()-5, 10, 10);
    }
    public int getAd() {
        return ad;
    }
 
    public void setAd(int ad) {
        this.ad = ad;
    }
}</code></pre> 
<h3 id="%E4%B8%83%EF%BC%8C%E8%83%8C%E6%99%AF%E7%B1%BB">七，背景类</h3> 
<p>作用：初始化背景。</p> 
<pre><code class="language-java">package com.sxt;
 
import java.awt.*;
//背景类
public  class Background extends GameObject{
    public Background(GameFrame gameFrame) {
        super(gameFrame);
    }
 
    Image bg = Toolkit.getDefaultToolkit().getImage("C:\\Users\\23839\\IdeaProjects\\asd\\src\\imgs\\Map.jpg");
 
    public void paintSelf(Graphics g){
        g.drawImage(bg,0,0,null);
 
    }
    @Override
    public Rectangle getRec() {
        return null;
    }
}</code></pre> 
<h3 id="%C2%A0%E5%85%AB%EF%BC%8C%E9%87%8E%E6%80%AA%E7%B1%BB">八，野怪类</h3> 
<p>作用：在绘制自身方法中通过判断血量删除元素或者绘制自身，用线程实现自动复活功能。</p> 
<pre><code class="language-java">package com.sxt.beast;
 
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.util.ArrayList;
 
import com.sxt.*;
 
public class Beast extends GameObject {
 
    public ArrayList&lt;Beast&gt; beastList = new ArrayList&lt;&gt;();
    int width;
    int height;
    // 复活的元素
    Beast beast = null;
 
    public Beast(GameFrame gameFrame) {
        super(gameFrame);
        beastList.add(new RedBuff(3045, 3170, gameFrame));
        beastList.add(new Bear(2800, 2855, gameFrame));
        beastList.add(new Bird(3570, 3380, gameFrame));
        beastList.add(new Xiyi(4585, 2365, gameFrame));
        beastList.add(new BlueBuff(4025, 2295, gameFrame));
        beastList.add(new Wolf(4235, 1945, gameFrame));
    }
 
    public Beast(int x, int y, GameFrame gameFrame) {
        super(x, y, gameFrame);
        setHp(1000);
        setCurrentHp(getHp());
        beast = this;
    }
 
 
    @Override
    public void paintSelf(Graphics g) {
        if (getCurrentHp() &lt;= 0) {
            System.out.println("beast die");
            setAlive(false);
            gameFrame.removeList.add(this);
            gameFrame.beast.beastList.remove(this);
            new ReviveCD().start();
        } else {
            // 添加生命值
            addHp(g, width / 2, 80, width, 20, Color.GREEN);
            g.drawImage(getImg(), getX() - width / 2, getY() - height / 2, null);
            g.setColor(Color.RED);
            g.fillOval(getX(), getY(), 10, 10);
            g.drawOval(getX() - getDis(), getY() - getDis(), 2 * getDis(), 2 * getDis());
        }
    }
 
    @Override
    public Rectangle getRec() {
        return new Rectangle(getX() - width / 2, getY() - height / 2, width, height);
    }
    //野怪复活
    class ReviveCD extends Thread {
        public void run() {
            // 线程休眠
            try {
                Thread.sleep(5000);
            } catch (Exception e) {
                e.printStackTrace();
            }
            Beast reviveBeast;
            if (beast instanceof RedBuff) {
                reviveBeast = new RedBuff(3045, 3170, gameFrame);
            } else if (beast instanceof Bear) {
                reviveBeast = new Bear(2800, 2855, gameFrame);
            } else if (beast instanceof Bird) {
                reviveBeast = new Bird(3570, 3380, gameFrame);
            } else if (beast instanceof Xiyi) {
                reviveBeast = new Xiyi(4585, 2365, gameFrame);
            } else if (beast instanceof BlueBuff) {
                reviveBeast = new BlueBuff(4025, 2295, gameFrame);
            } else {
                reviveBeast = new Wolf(4235, 1945, gameFrame);
            }
            gameFrame.objList.add(reviveBeast);
            gameFrame.beast.beastList.add(reviveBeast);
        }
    }
 
}</code></pre> 
<h4 id="1.%E7%86%8A%E7%B1%BB">1.熊类</h4> 
<pre><code class="language-java">package com.sxt.beast;
import com.sxt.GameFrame;
public class Bear extends Beast {
    public Bear(int x, int y, GameFrame gameFrame) {
        super(x, y, gameFrame);
        setImg("C:\\Users\\23839\\IdeaProjects\\HonorOfKings\\src\\imgs\\beast\\bear.jpg");
        width = 85;
        height = 112;
        setDis(65);
    }
 
}</code></pre> 
<h4 id="2.%E9%B8%9F%E7%B1%BB">2.鸟类</h4> 
<pre><code class="language-java">package com.sxt.beast;
import com.sxt.GameFrame;
public class Bird extends Beast {
    public Bird(int x, int y, GameFrame gameFrame) {
        super(x, y, gameFrame);
        setImg("C:\\Users\\23839\\IdeaProjects\\HonorOfKings\\src\\imgs\\beast\\红隼.jpg");
        width = 122;
        height = 98;
        setDis(125);
    }
 
}</code></pre> 
<h4 id="3.%E8%93%9DBuff">3.蓝Buff</h4> 
<pre><code class="language-java">package com.sxt.beast;
import com.sxt.GameFrame;
public class BlueBuff extends Beast {
    public BlueBuff(int x, int y, GameFrame gameFrame) {
        super(x, y, gameFrame);
        setImg("C:\\Users\\23839\\IdeaProjects\\HonorOfKings\\src\\imgs\\beast\\blueBuff.jpg");
        width = 142;
        height = 176;
        setDis(70);
    }
 
}</code></pre> 
<h4 id="4.%E7%BA%A2Buff">4.红Buff</h4> 
<pre><code class="language-java">package com.sxt.beast;
import com.sxt.GameFrame;
public class RedBuff extends Beast {
    public RedBuff(int x, int y, GameFrame gameFrame) {
        super(x, y, gameFrame);
        setImg("C:\\Users\\23839\\IdeaProjects\\HonorOfKings\\src\\imgs\\beast\\redBuff.jpg");
        width = 103;
        height = 150;
        setDis(70);
    }
}
 </code></pre> 
<h4 id="5.%E7%8B%BC%E7%B1%BB">5.狼类</h4> 
<pre><code class="language-java">package com.sxt.beast;
import com.sxt.GameFrame;
public class Wolf extends Beast {
 
    public Wolf(int x, int y, GameFrame gameFrame) {
        super(x, y, gameFrame);
        setImg("C:\\Users\\23839\\IdeaProjects\\HonorOfKings\\src\\imgs\\beast\\wolf.jpg");
        width = 145;
        height = 140;
        setDis(65);
    }
 
}</code></pre> 
<h4 id="6.%E8%9C%A5%E8%9C%B4%E7%B1%BB">6.蜥蜴类</h4> 
<pre><code class="language-java">package com.sxt.beast;
import com.sxt.GameFrame;
public class Xiyi extends Beast {
 
    public Xiyi(int x, int y, GameFrame gameFrame) {
        super(x, y, gameFrame);
        setImg("C:\\Users\\23839\\IdeaProjects\\HonorOfKings\\src\\imgs\\beast\\蜥蜴.jpg");
        width = 111;
        height = 65;
        setDis(125);
    }
}</code></pre> 
<p>游戏效果</p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/35/79/qaiL7N6Y_o.png" width="1057"></p> 
<p><img alt="" height="471" src="https://images2.imgbox.com/13/48/hO9pYbXJ_o.png" width="1070"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cfe00748f739a6f8415a03aeca5686b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">QCS2290 DFOTA重启后无法切换分区</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/82add214a252fd83f050999b5e067cba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">电脑本机添加默认网页 解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>