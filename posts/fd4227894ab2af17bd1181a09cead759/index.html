<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【erlang】语法篇 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【erlang】语法篇" />
<meta property="og:description" content="要讲清楚erlang的语法，这一章的压力是巨大的，有些遗漏的地方我们会在后面的专题中补充。
数据类型 数字 erlang只有两种数字类型：整数和浮点数。
整数宽度仅受限于内存大小，erlang整数有两种书写格式：
base#value：base进制的整数，base的范围是2至36，十进制可省略base#，value可以使用下划线分隔。$char：字符char的ASCII码，支持转义字符，比如$\n。 浮点数都是64位，遵守IEEE 754标准。浮点数语法没啥特别，可以添加下划线，支持科学计数法，0.1&#43;0.2≠0.3，都是与你的经验相符的。唯一需要注意的是小于0的浮点数中整数部分的0是不能省略的，某些语言可以写.1表示0.1，erlang不支持。
关于0.1&#43;0.2=0.30000000000000004这件事情，居然还有一个专门的网站：https://0.30000000000000004.com/，推荐浏览一下。
字符串 erlang的字符串使用&#34;&#34;包裹。注意erlang并没有字符串类型，String只是整数列表的一种简写形式，许多函数式语言都是如此。比如&#34;abc&#34;就等价于[$a,$b,$c]。字符串中可以使用\x{}包含Unicode字符，比如&#34;a\x{221e}b&#34;表示&#34;a∞b&#34;。
erlang shell在打印整数列表时，如果发现每一项都是可打印的ASCII字符，就会以字符串的形式打印列表。如果要按列表打印，可以使用io:format(&#34;~w~n~, [&#34;abc&#34;]).，如果想打印出列表中的Unicode字符，比如中文，就需要使用io:format(&#34;~ts~n&#34;, [&#34;你好&#34;]).。
erlang中比较神奇的一点是相邻的两个字符串会被合并成一个。
1&gt; &#34;ab&#34; &#34;cd&#34;. &#34;abcd&#34; 布尔 erlang中并没有布尔类型，而是使用原子的true和false来表示布尔值。
原子 说实话我并不知道如何去解释原子这种类型，就像我不知道该如何解释数字类型。你写下一串数字，于是得到一个数字类型，我写下一串字符，于是得到一个原子类型。
原子类型的英文叫atom，表示不可分割的。比如abc是一个原子，它不同于字符串&#34;abc&#34;由a，b，c三个字符组成，原子类型abc就是一个整体，不能分开来看，就像数字123就是一个整体。
原子不需要定义，这大概是最令人困惑的地方。千万不要把原子理解为变量或常量，更不是字符串。它更接近于数字，不管你是否申明或者定义，所有的数字天然就是存在的，原子也是如此，理解了数字，就理解了原子。
在erlang中，原子类型包裹在&#39;&#39;中，可以是任意的ASCII字符，如果是小写字母开头，可以省略单引号，下面是一些原子类型示例：
hello hello_world hello@world hello12345 &#39;hello&#39; &#39;hello world&#39; &#39;&#43;&#39; &#39;123&#39; &#39;@#$%&#39; 熟悉lisp的人一定不会对原子类型感到陌生，但对于c家族语言程序员来说，原子类型着实令人费解。racket中有一种叫keyword的类型，比如&#39;abc，如果你能理解它，那么原子与之是类似的。
列表 列表是函数式语言的基石，如果你学习过Haskell语言，那么应该能瞬间理解erlang的列表。
列表是递归定义的，描述为一个头部“加”一个尾部。尾部可以是一个列表或空列表，空列表是不包含任何元素的特殊列表，是递归退出条件。这里所说的“加”在代码层面面表示一个连接符，erlang用的是|，Haskell用的是:。
erlang使用[]表示空列表，非空列表表示为[H|T]，其中T是一个列表。erlang列表中的元素可以是任意类型，不要求同类型。下面是一些例子。
[] %空列表 [a|[]] %[a] [a|[b|[]]] %[a,b] [a|[b|[c|[]]]] %[a,b,c] 递归嵌套是列表的本质，不过写起来太费劲，erlang提供了简写语法，使用逗号分隔元素，如[1,2,a,b]。
元组 元组是一种长度固定的复合数据类型，使用{}表示，元素之间使用,分隔。在erlang中，无论是元组本身还是它的字段都是匿名的。作为一种编程风格，erlang习惯将元组的名称作为元组的第一个元素。比如一个表示二维坐标的元组可以写成{point, 1 ,3}，元组是可以嵌套的，或者我们可以更近一步写成{point, {x, 1}, {y, 2}}。注意这只是一种编程风格，与语法无关。
记录语法 记录语法可以创建具名元组，就像结构体一样，记录不是一种新的数据类型，本质上它还是元组，编译时会完成这一转换。语法如下：
-record(元组名, { 字段1 [= 默认值1], 字段2 [= 默认值2], ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/fd4227894ab2af17bd1181a09cead759/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-16T23:55:58+08:00" />
<meta property="article:modified_time" content="2023-03-16T23:55:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【erlang】语法篇</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>要讲清楚erlang的语法，这一章的压力是巨大的，有些遗漏的地方我们会在后面的专题中补充。</p> 
<h3><a id="_2"></a>数据类型</h3> 
<h4><a id="_4"></a>数字</h4> 
<p>erlang只有两种数字类型：整数和浮点数。</p> 
<p>整数宽度仅受限于内存大小，erlang整数有两种书写格式：</p> 
<ul><li><code>base#value</code>：base进制的整数，base的范围是2至36，十进制可省略<code>base#</code>，value可以使用下划线分隔。</li><li><code>$char</code>：字符char的ASCII码，支持转义字符，比如<code>$\n</code>。</li></ul> 
<p>浮点数都是64位，遵守IEEE 754标准。浮点数语法没啥特别，可以添加下划线，支持科学计数法，<code>0.1+0.2≠0.3</code>，都是与你的经验相符的。唯一需要注意的是小于0的浮点数中整数部分的0是不能省略的，某些语言可以写<code>.1</code>表示0.1，erlang不支持。</p> 
<p>关于<code>0.1+0.2=0.30000000000000004</code>这件事情，居然还有一个专门的网站：<a href="https://0.30000000000000004.com/" rel="nofollow">https://0.30000000000000004.com/</a>，推荐浏览一下。</p> 
<h4><a id="_17"></a>字符串</h4> 
<p>erlang的字符串使用<code>""</code>包裹。注意erlang并没有字符串类型，String只是整数列表的一种简写形式，许多函数式语言都是如此。比如<code>"abc"</code>就等价于<code>[$a,$b,$c]</code>。字符串中可以使用<code>\x{}</code>包含Unicode字符，比如<code>"a\x{221e}b"</code>表示<code>"a∞b"</code>。</p> 
<p>erlang shell在打印整数列表时，如果发现每一项都是可打印的ASCII字符，就会以字符串的形式打印列表。如果要按列表打印，可以使用<code>io:format("~w~n~, ["abc"]).</code>，如果想打印出列表中的Unicode字符，比如中文，就需要使用<code>io:format("~ts~n", ["你好"]).</code>。</p> 
<p>erlang中比较神奇的一点是相邻的两个字符串会被合并成一个。</p> 
<pre><code class="prism language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token string">"ab"</span> <span class="token string">"cd"</span><span class="token punctuation">.</span>
<span class="token string">"abcd"</span>

</code></pre> 
<h4><a id="_31"></a>布尔</h4> 
<p>erlang中并没有布尔类型，而是使用原子的<code>true</code>和<code>false</code>来表示布尔值。</p> 
<h4><a id="_35"></a>原子</h4> 
<p>说实话我并不知道如何去解释原子这种类型，就像我不知道该如何解释数字类型。你写下一串数字，于是得到一个数字类型，我写下一串字符，于是得到一个原子类型。</p> 
<p>原子类型的英文叫atom，表示不可分割的。比如<code>abc</code>是一个原子，它不同于字符串<code>"abc"</code>由<code>a</code>，<code>b</code>，<code>c</code>三个字符组成，原子类型<code>abc</code>就是一个整体，不能分开来看，就像数字<code>123</code>就是一个整体。</p> 
<p>原子不需要定义，这大概是最令人困惑的地方。千万不要把原子理解为变量或常量，更不是字符串。它更接近于数字，不管你是否申明或者定义，所有的数字天然就是存在的，原子也是如此，理解了数字，就理解了原子。</p> 
<p>在erlang中，原子类型包裹在<code>''</code>中，可以是任意的ASCII字符，如果是小写字母开头，可以省略单引号，下面是一些原子类型示例：</p> 
<pre><code class="prism language-erlang"><span class="token atom">hello</span>
<span class="token atom">hello_world</span>
<span class="token atom">hello@world</span>
<span class="token atom">hello12345</span>
<span class="token quoted-atom atom">'hello'</span>
<span class="token quoted-atom atom">'hello world'</span>
<span class="token quoted-atom atom">'+'</span>
<span class="token quoted-atom atom">'123'</span>
'@<span class="token punctuation">#</span>$<span class="token comment">%'</span>
</code></pre> 
<blockquote> 
 <p>熟悉lisp的人一定不会对原子类型感到陌生，但对于c家族语言程序员来说，原子类型着实令人费解。racket中有一种叫keyword的类型，比如<code>'abc</code>，如果你能理解它，那么原子与之是类似的。</p> 
</blockquote> 
<h4><a id="_59"></a>列表</h4> 
<p>列表是函数式语言的基石，如果你学习过Haskell语言，那么应该能瞬间理解erlang的列表。</p> 
<p>列表是递归定义的，描述为一个头部“加”一个尾部。尾部可以是一个列表或空列表，空列表是不包含任何元素的特殊列表，是递归退出条件。这里所说的“加”在代码层面面表示一个连接符，erlang用的是<code>|</code>，Haskell用的是<code>:</code>。</p> 
<p>erlang使用<code>[]</code>表示空列表，非空列表表示为<code>[H|T]</code>，其中<code>T</code>是一个列表。erlang列表中的元素可以是任意类型，不要求同类型。下面是一些例子。</p> 
<pre><code class="prism language-erlang"><span class="token punctuation">[</span><span class="token punctuation">]</span>              <span class="token comment">%空列表</span>
<span class="token punctuation">[</span><span class="token atom">a</span><span class="token punctuation">|</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>          <span class="token comment">%[a]</span>
<span class="token punctuation">[</span><span class="token atom">a</span><span class="token punctuation">|</span><span class="token punctuation">[</span><span class="token atom">b</span><span class="token punctuation">|</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>      <span class="token comment">%[a,b]</span>
<span class="token punctuation">[</span><span class="token atom">a</span><span class="token punctuation">|</span><span class="token punctuation">[</span><span class="token atom">b</span><span class="token punctuation">|</span><span class="token punctuation">[</span><span class="token atom">c</span><span class="token punctuation">|</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment">%[a,b,c]</span>
</code></pre> 
<p>递归嵌套是列表的本质，不过写起来太费劲，erlang提供了简写语法，使用逗号分隔元素，如<code>[1,2,a,b]</code>。</p> 
<h4><a id="_76"></a>元组</h4> 
<p>元组是一种长度固定的复合数据类型，使用<code>{}</code>表示，元素之间使用<code>,</code>分隔。在erlang中，无论是元组本身还是它的字段都是匿名的。作为一种编程风格，erlang习惯将元组的名称作为元组的第一个元素。比如一个表示二维坐标的元组可以写成<code>{point, 1 ,3}</code>，元组是可以嵌套的，或者我们可以更近一步写成<code>{point, {x, 1}, {y, 2}}</code>。注意这只是一种编程风格，与语法无关。</p> 
<h5><a id="_80"></a>记录语法</h5> 
<p>记录语法可以创建具名元组，就像结构体一样，记录不是一种新的数据类型，本质上它还是元组，编译时会完成这一转换。语法如下：</p> 
<pre><code class="prism language-erlang"><span class="token operator">-</span><span class="token function">record</span><span class="token punctuation">(</span>元组名<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
  字段<span class="token number">1</span> <span class="token punctuation">[</span><span class="token operator">=</span> 默认值<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  字段<span class="token number">2</span> <span class="token punctuation">[</span><span class="token operator">=</span> 默认值<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  字段<span class="token atom">n</span> <span class="token punctuation">[</span><span class="token operator">=</span> 默认值<span class="token atom">n</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
</code></pre> 
<p>记录语法只能用于源文件，无法直接在shell中使用，因为它不是表达式，要在shell中使用需要一些特殊的骚操作。所有的<code>=默认值</code>都是可以省略的，上面的<code>[]</code>表示可省略的，而不是语法。如果在创建元组时未给字段赋值，就会使用默认值，若没有默认值则未<code>undefined</code>。</p> 
<p>在<code>.erl</code>文件中定义的记录无法导出，要在模块外使用只能再导出一个“构造函数”来创建记录。</p> 
<pre><code class="prism language-erlang"><span class="token comment">%first.erl</span>
<span class="token operator">-</span><span class="token function">module</span><span class="token punctuation">(</span><span class="token atom">first</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token operator">-</span><span class="token function">export</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token atom">newPoint</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>

<span class="token operator">-</span><span class="token function">record</span><span class="token punctuation">(</span><span class="token atom">point</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token atom">x</span><span class="token punctuation">,</span> <span class="token atom">y</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token comment">%定义记录</span>

<span class="token comment">%注意参数X和Y是变量，要大写</span>
<span class="token function">newPoint</span><span class="token punctuation">(</span><span class="token variable">X</span><span class="token punctuation">,</span><span class="token variable">Y</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token punctuation">#</span><span class="token atom">point</span><span class="token punctuation">{<!-- --></span><span class="token atom">x</span><span class="token operator">=</span><span class="token variable">X</span><span class="token punctuation">,</span> <span class="token atom">y</span><span class="token operator">=</span><span class="token variable">Y</span><span class="token punctuation">}</span><span class="token punctuation">.</span>
</code></pre> 
<p>然后就可以在erlang shell中生成<code>point</code>元组了。</p> 
<pre><code class="prism language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token atom">first</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token punctuation">{<!-- --></span><span class="token atom">ok</span><span class="token punctuation">,</span><span class="token atom">first</span><span class="token punctuation">}</span>
<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token atom">first</span><span class="token punctuation">:</span><span class="token function">newPoint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token punctuation">{<!-- --></span><span class="token atom">point</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span>

</code></pre> 
<p>以上方式只适合模块内使用，如果需要多模块共享，可以将记录写到<code>.hrl</code>文件中，它类似于头文件，可以被其他文件包含，并且<code>.hrl</code>文件中的记录定义不需要导出。</p> 
<p>新建<code>records.hrl</code>，输入以下内容。</p> 
<pre><code class="prism language-erlang"><span class="token comment">%records.hrl</span>
<span class="token operator">-</span><span class="token function">record</span><span class="token punctuation">(</span><span class="token atom">point</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token atom">x</span><span class="token punctuation">,</span> <span class="token atom">y</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token operator">-</span><span class="token function">record</span><span class="token punctuation">(</span><span class="token atom">color</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token atom">r</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token atom">g</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token atom">b</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
</code></pre> 
<p>在其他模块中使用<code>point</code>或<code>color</code>只需要写上<code>-include("records.hrl")</code>即可，可以写相对路径，也可以写绝对路径。</p> 
<p>在erlang shell中使用可以通过<code>rr("records.hrl")</code>读入头文件。</p> 
<pre><code class="prism language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token function">rr</span><span class="token punctuation">(</span><span class="token string">"records.hrl"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token atom">color</span><span class="token punctuation">,</span><span class="token atom">point</span><span class="token punctuation">]</span>
<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token punctuation">#</span><span class="token atom">point</span><span class="token punctuation">{<!-- --></span><span class="token atom">x</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token atom">y</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">.</span>
<span class="token punctuation">#</span><span class="token atom">point</span><span class="token punctuation">{<!-- --></span><span class="token atom">x</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token atom">y</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">}</span>
<span class="token number">3</span><span class="token operator">&gt;</span> <span class="token punctuation">#</span><span class="token atom">color</span><span class="token punctuation">{<!-- --></span><span class="token atom">r</span><span class="token operator">=</span><span class="token number">255</span><span class="token punctuation">}</span><span class="token punctuation">.</span>
<span class="token punctuation">#</span><span class="token atom">color</span><span class="token punctuation">{<!-- --></span><span class="token atom">r</span> <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">,</span><span class="token atom">g</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token atom">b</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">}</span>

</code></pre> 
<h4><a id="map_147"></a>map</h4> 
<p>map是erlang R17才引入的用来表示映射的数据类型，语法类型记录。创建map的语法如下：</p> 
<pre><code class="prism language-erlang"><span class="token punctuation">#</span><span class="token punctuation">{<!-- --></span><span class="token atom">key1</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token atom">val1</span><span class="token punctuation">,</span> <span class="token atom">key2</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token atom">val2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token atom">keyn</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token atom">valn</span><span class="token punctuation">}</span><span class="token punctuation">.</span>
</code></pre> 
<p>erlang的map是有序的，按键的值升序排序。</p> 
<p>更新map有两种方式，假设我们已经有了一个map：<code>M1=#{a=&gt;1, b=&gt;2}</code>。</p> 
<ol><li><code>M2=M1#{c=&gt;3}</code></li><li><code>M2=M1#{b:=3}</code></li></ol> 
<p>这两种方式可以混用，比如<code>M2=M1#{c=&gt;3, b:=2}</code>，无论哪种方式都会得到一个新的map，新map在旧map上复制而来，但这种复制是轻量的，旧map并不受影响。</p> 
<p>这两种更新方式的一个重要区别是当要更新的键不存在时，<code>=&gt;</code>会将键值插入map，而<code>:=</code>会得到一个错误。使用<code>:=</code>更新map有两个好处：</p> 
<ul><li>当键拼写错误时可以得到一个提示。</li><li><code>:=</code>不会插入新的键，因此新旧map可以共用键描述符，当map非常大时，可以节省不少空间。</li></ul> 
<p>建议是除非要插入新的键，否则应该使用<code>:=</code>更新map。</p> 
<h4><a id="_171"></a>二进制&amp;比特流</h4> 
<p>二进制和比特流用来表示一块无类型的内存区域，在其他语言中有字节数组或字符指针表达类似的含义。二进制和比特流的区别是当一个比特流中的比特数是8的整数倍时，它就是二进制。</p> 
<p>创建二进制或比特流的语法称为位语法，描述如下：</p> 
<pre><code class="prism language-erlang"><span class="token punctuation">&lt;&lt;</span><span class="token punctuation">&gt;&gt;</span>
<span class="token punctuation">&lt;&lt;</span><span class="token variable">E1</span><span class="token punctuation">,</span> <span class="token variable">E2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token variable">Ei</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token variable">En</span><span class="token punctuation">&gt;&gt;</span>
</code></pre> 
<p>其中每个<code>Ei</code>具有以下形式之一：</p> 
<ul><li><code>Value</code></li><li><code>Value:位宽</code></li><li><code>Value/End-Sign-Type-Unit</code></li><li><code>Value:位宽/End-Sign-Type-Unit</code></li></ul> 
<p>位宽表示<code>Value</code>占用几个比特，<code>Value</code>超出位宽会被截断，默认8比特。<br> <code>End</code>表示字节顺序(<a href="https://blog.csdn.net/puss0/article/details/114196882">大端序or小端序</a>)，有3个可选值：</p> 
<ul><li><code>big</code>：大端序，默认值。</li><li><code>little</code>：小端序。</li><li><code>native</code>：由机器的CPU决定。</li></ul> 
<p><code>Sign</code>表示整数有无符号，仅用于模式匹配，有两个可选值：</p> 
<ul><li><code>signed</code>：有符号整数。</li><li><code>unsigned</code>：无符号整数，默认值。</li></ul> 
<p><code>Type</code>表示元素类型，可选值如下：</p> 
<ul><li><code>integer</code>：默认值。</li><li><code>float</code></li><li><code>binary</code></li><li><code>bytes</code></li><li><code>bitstring</code></li><li><code>bits</code></li><li><code>utf8</code></li><li><code>utf16</code></li><li><code>utf32</code></li></ul> 
<p><code>Unit</code>的语法为<code>unit:n</code>，<code>n</code>的取值是1至256。它必须和位宽一起使用，一个元素的总长度等于<code>位宽 × unit</code>。</p> 
<p>示例1，创建二进制，可以使用整数或者字符串。</p> 
<pre><code class="prism language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token variable">X</span> <span class="token operator">=</span> <span class="token punctuation">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&gt;&gt;</span><span class="token punctuation">.</span>
<span class="token punctuation">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&gt;&gt;</span>
<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token variable">Y</span> <span class="token operator">=</span> <span class="token punctuation">&lt;&lt;</span><span class="token string">"abc"</span><span class="token punctuation">&gt;&gt;</span><span class="token punctuation">.</span>
<span class="token punctuation">&lt;&lt;</span><span class="token string">"abc"</span><span class="token punctuation">&gt;&gt;</span>

</code></pre> 
<blockquote> 
 <p>有一点需要注意的是<code>=</code>和<code>&lt;&lt;</code>之间，以及<code>&gt;&gt;</code>和<code>=</code>之间一定要用空格隔开，否则erlang会将<code>=</code>和<code>&lt;</code>解释为<code>&lt;=</code>，将<code>&gt;</code>和<code>=</code>识别为<code>&gt;=</code>，造成语法错误。对于二进制的打印方式，也遵循列表的打印规则。</p> 
</blockquote> 
<p>示例2，指定位宽。</p> 
<pre><code class="prism language-erlang"><span class="token number">3</span><span class="token operator">&gt;</span> <span class="token variable">Z</span> <span class="token operator">=</span> <span class="token punctuation">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">&gt;&gt;</span><span class="token punctuation">.</span>
<span class="token punctuation">&lt;&lt;</span><span class="token number">12</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">&gt;&gt;</span>

</code></pre> 
<p>这是一个比特流，共5个比特，前两个比特是<code>01</code>，后3个比特是<code>100</code>，所以最终结果是<code>01100</code>，十进制就是12。</p> 
<p>示例3，大小端。</p> 
<pre><code class="prism language-erlang"><span class="token number">4</span><span class="token operator">&gt;</span> <span class="token variable">M</span> <span class="token operator">=</span> <span class="token punctuation">&lt;&lt;</span><span class="token number">573</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token operator">/</span><span class="token atom">big</span><span class="token punctuation">&gt;&gt;</span><span class="token punctuation">.</span>
<span class="token punctuation">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">61</span><span class="token punctuation">&gt;&gt;</span>
<span class="token number">5</span><span class="token operator">&gt;</span> <span class="token variable">N</span> <span class="token operator">=</span> <span class="token punctuation">&lt;&lt;</span><span class="token number">573</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token operator">/</span><span class="token atom">little</span><span class="token punctuation">&gt;&gt;</span><span class="token punctuation">.</span>
<span class="token punctuation">&lt;&lt;</span><span class="token number">61</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&gt;&gt;</span>

</code></pre> 
<p>示例4，浮点数。</p> 
<pre><code class="prism language-erlang"><span class="token number">6</span><span class="token operator">&gt;</span> <span class="token variable">K</span> <span class="token operator">=</span> <span class="token punctuation">&lt;&lt;</span><span class="token number">1.0</span><span class="token operator">/</span><span class="token atom">float</span><span class="token punctuation">&gt;&gt;</span><span class="token punctuation">.</span>
<span class="token punctuation">&lt;&lt;</span><span class="token number">63</span><span class="token punctuation">,</span><span class="token number">240</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&gt;&gt;</span>

</code></pre> 
<p>位语法非常适合做协议开发，并且erlang针对二进制做了优化，效率非常高。相比于其他语言去移位，按位与或，erlang位语法结合模式匹配简直爽歪歪。</p> 
<p>更绝的是位语法的模式匹配中，后面的项可以使用前面的结果，比如：</p> 
<pre><code class="prism language-erlang"><span class="token punctuation">&lt;&lt;</span><span class="token variable">Size</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token variable">Data</span><span class="token punctuation">:</span><span class="token variable">Size</span><span class="token operator">/</span><span class="token atom">binary</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&gt;&gt;</span>
</code></pre> 
<p>第一项我们将前4比特解码到<code>Size</code>，接着又使用这个<code>Size</code>提取<code>Data</code>。</p> 
<p>此外，erlang提供了两个有用的函数，可以完成任意的erlang类型和二进制之间的转换，因此可以方便的将erlang类型写入磁盘或网络。</p> 
<ul><li><code>term_to_binary</code>：将erlang类型转成二进制。</li><li><code>binary_to_term</code>：将二进制转成erlang类型。</li></ul> 
<pre><code class="prism language-erlang"><span class="token number">3</span><span class="token operator">&gt;</span> <span class="token variable">B</span> <span class="token operator">=</span> <span class="token function">term_to_binary</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token atom">color</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token punctuation">&lt;&lt;</span><span class="token number">131</span><span class="token punctuation">,</span><span class="token number">104</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">,</span><span class="token number">111</span><span class="token punctuation">,</span><span class="token number">108</span><span class="token punctuation">,</span><span class="token number">111</span><span class="token punctuation">,</span><span class="token number">114</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&gt;&gt;</span>
<span class="token number">4</span><span class="token operator">&gt;</span> <span class="token function">binary_to_term</span><span class="token punctuation">(</span><span class="token variable">B</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token punctuation">{<!-- --></span><span class="token atom">color</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_277"></a>函数</h4> 
<p>做为函数式编程语言，函数也是一种类型。标定一个函数的三元组是<code>模块名:函数名/元数</code>，元数就是函数参数的个数。</p> 
<h5><a id="_281"></a>常规函数</h5> 
<p>我们在<code>.erl</code>文件中书写的函数都是常规函数，语法如下：</p> 
<pre><code class="prism language-erlang">函数名<span class="token punctuation">(</span>模式<span class="token number">11</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>模式<span class="token number">1</span><span class="token atom">n</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">when</span> 关卡序列<span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    函数体<span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
函数名<span class="token punctuation">(</span>模式<span class="token atom">k1</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>模式<span class="token atom">kn</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">when</span> 关卡序列<span class="token atom">k</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    函数体<span class="token atom">k</span><span class="token punctuation">.</span>
</code></pre> 
<p>每个<code>-&gt;</code>前面的叫做函数头，后面的叫做函数体，函数体由若干表达式构成，表达式之间通过<code>,</code>分隔。每个<code>函数头-&gt;函数体;</code>称为一个函数子句，一个完整的函数可以由若干函数子句构成，子句之间使用<code>;</code>分隔，最后一个子句以<code>.</code>结尾。你可以仔细体会以下elang对于标点符号的使用，是不是挺符合经验直觉的。</p> 
<p>函数名是一个原子，因此一般是小写字母开头，如果想用大写字母开头，需要用<code>''</code>包裹，调用时也要这样写，这是原子的规则。</p> 
<p>调用函数时，每个参数会和对应的模式去匹配，因此同一个函数的每个子句的模式数量必须相同，即拥有相同的元数。一旦参数和模式匹配上，就会执行这个子句。当然，还要后面的关卡测试也通过。</p> 
<p><code>when</code>关键字后面的是关卡序列，是可选的。关卡序列由若干布尔表达式组成，它们之间可以使用<code>;</code>或<code>,</code>分隔，区别是<code>;</code>表示逻辑<strong>或</strong>，而<code>,</code>表示逻辑<strong>与</strong>，这一点也与经验直觉相符。</p> 
<p>关卡测试是对模式匹配的补充，函数本质上就是一系列表达式的集合，通过参数来决定执行哪些表达式，而这个决定的过程就是模式匹配和关卡测试。</p> 
<p>下面是一个典中典示例，求斐波拉契数列。</p> 
<pre><code class="prism language-erlang"><span class="token function">fact</span><span class="token punctuation">(</span><span class="token variable">N</span><span class="token punctuation">)</span> <span class="token keyword">when</span> <span class="token variable">N</span><span class="token operator">&gt;</span><span class="token number">0</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token variable">N</span> <span class="token operator">*</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token variable">N</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">fact</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token number">1.</span>   
</code></pre> 
<h5><a id="_313"></a>函数表达式</h5> 
<p>函数表达式常用于高阶函数和erlang shell，将一个函数作为另一个函数的返回值时，也会用到函数表达式。函数表达式语法如下：</p> 
<pre><code class="prism language-erlang"><span class="token keyword">fun</span>
    <span class="token punctuation">[</span>函数名<span class="token punctuation">]</span><span class="token punctuation">(</span>模式<span class="token number">11</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>模式<span class="token number">1</span><span class="token atom">n</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">when</span> 关卡序列<span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
              函数体<span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>函数名<span class="token punctuation">]</span><span class="token punctuation">(</span>模式<span class="token atom">k1</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>模式<span class="token atom">kn</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">when</span> 关卡序列<span class="token atom">k</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
              函数体<span class="token atom">k</span>
<span class="token keyword">end</span><span class="token punctuation">.</span>
</code></pre> 
<p>函数表达式由<code>fun</code>和<code>end</code>界定，中间的内容和常规函数语法非常类似，不过依然有以下两点非常重要的区别：</p> 
<ul><li>函数表达式的函数名是可选的。</li><li>函数表示式的函数名是<strong>变量</strong>。这就意味着函数表达式中的函数名必须是大写字母开头，这一点一定要特别注意。</li></ul> 
<p>还是求斐波拉契数列的例子，这次我们在erlang shell中实现。</p> 
<pre><code class="prism language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token variable">Fun1</span> <span class="token operator">=</span> <span class="token keyword">fun</span> <span class="token variable">Fact</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">Fact</span><span class="token punctuation">(</span><span class="token variable">X</span><span class="token punctuation">)</span> <span class="token keyword">when</span> <span class="token variable">X</span> <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token variable">X</span> <span class="token operator">*</span> <span class="token variable">Fact</span><span class="token punctuation">(</span><span class="token variable">X</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">end</span><span class="token punctuation">.</span>
<span class="token punctuation">#</span><span class="token variable">Fun</span><span class="token operator">&lt;</span><span class="token atom">erl_eval</span><span class="token punctuation">.</span><span class="token number">19.3316493</span><span class="token operator">&gt;</span>
<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token variable">Fun1</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token number">265252859812191058636308480000000</span>

</code></pre> 
<p>如果要将一个常规函数变成一个函数表达式，我们可以通过直接在表达式中调用函数来实现。</p> 
<pre><code class="prism language-erlang"><span class="token keyword">fun</span> <span class="token punctuation">(</span><span class="token variable">Arg1</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token variable">ArgN</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token variable">Name</span><span class="token punctuation">(</span><span class="token variable">Arg1</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token variable">ArgN</span><span class="token punctuation">)</span> <span class="token keyword">end</span><span class="token punctuation">.</span>
</code></pre> 
<p>但是这样写比较冗长，于是erlang提供了下面的语法糖。</p> 
<pre><code class="prism language-erlang"><span class="token keyword">fun</span> <span class="token variable">Name</span><span class="token operator">/</span><span class="token variable">Arity</span><span class="token punctuation">.</span>
<span class="token keyword">fun</span> <span class="token variable">Module</span><span class="token punctuation">:</span><span class="token variable">Name</span><span class="token operator">/</span><span class="token variable">Arity</span><span class="token punctuation">.</span>
</code></pre> 
<p>连<code>end</code>都省了，可以说是非常贴心了。</p> 
<pre><code class="prism language-erlang"><span class="token number">3</span><span class="token operator">&gt;</span> <span class="token variable">Fun2</span> <span class="token operator">=</span> <span class="token keyword">fun</span> <span class="token atom">first</span><span class="token punctuation">:</span><span class="token atom">fact</span><span class="token operator">/</span><span class="token number">1.</span>
<span class="token keyword">fun</span> <span class="token atom">first</span><span class="token punctuation">:</span><span class="token atom">fact</span><span class="token operator">/</span><span class="token number">1</span>
<span class="token number">4</span><span class="token operator">&gt;</span> <span class="token variable">Fun2</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token number">265252859812191058636308480000000</span>
</code></pre> 
<h4><a id="_364"></a>引用</h4> 
<p>这里的引用并不是C++里的引用，erlang的引用是一种全局(包括分布式erlang集群)唯一的数据类型。用途是创建一个独一无二的标签。引用通过内置函数(BIF，Buid In Func)<code>make_ref/0</code>创建，内置函数<code>is_reference/1</code>用来判断一个变量是不是引用。</p> 
<pre><code class="prism language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token variable">R1</span> <span class="token operator">=</span> <span class="token function">make_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token punctuation">#</span><span class="token variable">Ref</span><span class="token operator">&lt;</span><span class="token number">0.2310775775</span><span class="token number">.850132995</span><span class="token number">.77305</span><span class="token operator">&gt;</span>
<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token function">is_reference</span><span class="token punctuation">(</span><span class="token variable">R1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token boolean">true</span>
</code></pre> 
<h3><a id="_375"></a>模块</h3> 
<p>erlang的模块以文件为单位，而不是目录，一个文件就是一个模块。模块中可以定义各种属性，它们具有相似的语法：</p> 
<pre><code class="prism language-erlang"><span class="token operator">-</span>标签<span class="token punctuation">(</span>值<span class="token punctuation">)</span><span class="token punctuation">.</span>
</code></pre> 
<p>标签必须是原子，值必须是字面量。</p> 
<h4><a id="_385"></a>模块属性</h4> 
<p>模块是存放函数的地方，模块属性是对模块的描述，放在模块开头。事实上我们已经见识过了<code>module</code>和<code>export</code>这两个属性，分别用来定义模块和导出函数。模块属性分为预定义属性和自定义属性，自定义属性可以随便写，不做过多介绍；下面主要介绍那些erlang预定义的属性。</p> 
<ul><li> <p><code>-module(模块名).</code></p> <p>定义一个模块的名字，必须是文件的第一行代码，且不可省略。模块名是一个原子，必须和文件名(不带后缀)相同，否则erlang的代码加载机制无法工作。</p> </li><li> <p><code>-export([函数名/元数, ... 函数名/元数]).</code></p> <p>导出函数，可以有0到多个，只有导出的函数才能在模块外访问。</p> </li><li> <p><code>-import(模块名, [函数名/元数, ... 函数名/元数]).</code></p> <p>导入其他模块的函数，一般我们通过<code>模块名:函数名</code>的方式调用函数，而导入之后，就可以直接通过<code>函数名</code>来调用了。</p> </li><li> <p><code>-compile(options).</code></p> <p>编译选项，如果有多个，需要放到元组或者列表里，如<code>{option1, ... optionN}</code>或者<code>[option1, ... optionN]</code>。在开发阶段一个比较有用的选项是<code>export_all</code>，它会导出所有函数，此时编译器会给你一个警告，可以使用<code>nowarn_export_all</code>消除这个警告。完整的编译选项可以查看<a href="https://www.erlang.org/doc/man/compile.html" rel="nofollow">官方文档</a>。</p> </li><li> <p><code>-vsn(版本号)</code></p> <p>版本号可以是一个值或者一个列表，如果有多个<code>-vsn</code>那么所有版本号最终也会被拼接成一个列表。可以通过<code>beam_lib:version/1</code>函数来查看一个模块的版本号，参数是模块名，它输出的是<code>{ok, {模块名, [版本号]}}</code>。如果不指定，默认以模块的MD5值作为版本号。</p> </li><li> <p><code>-on_load(函数名/0).</code></p> <p>在模块被加载后自动执行一个函数。这个函数必须是<strong>无参函数</strong>且必须<strong>返回</strong><code>ok</code>，可以是非导出的，它会在一个新的进程里执行，函数执行完以后，进程立刻终止。</p> </li><li> <p><code>-nifs([函数/元数, ... 函数/元数])</code></p> <p>指明那些函数从动态链接库(<code>.dll</code>，<code>.so</code>)里加载。<code>NIF</code>的含义是Native Implemented Functions。</p> </li></ul> 
<h5><a id="_411"></a>提取模块属性</h5> 
<p>提取模块属性有两种方式：</p> 
<ul><li><code>beam_lib:chunks/2</code>：可以在不载入代码的情况下提取属性。</li><li><code>模块名:module_info/0</code>和<code>attrs:module_info/1</code>：需要先加载代码，这两个函数是由编译器内置到模块中的。</li></ul> 
<p>示例：</p> 
<pre><code class="prism language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token atom">beam_lib</span><span class="token punctuation">:</span><span class="token function">chunks</span><span class="token punctuation">(</span><span class="token string">"first.beam"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token atom">attributes</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token punctuation">{<!-- --></span><span class="token atom">ok</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span><span class="token atom">first</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token atom">attributes</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token atom">vsn</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">338263298016390874136079198029794793513</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token atom">beam_lib</span><span class="token punctuation">:</span><span class="token function">chunks</span><span class="token punctuation">(</span><span class="token string">"first.beam"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token atom">exports</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token punctuation">{<!-- --></span><span class="token atom">ok</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span><span class="token atom">first</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token atom">exports</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token quoted-atom atom">'NewPoint'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                      <span class="token punctuation">{<!-- --></span><span class="token atom">fact</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                      <span class="token punctuation">{<!-- --></span><span class="token atom">maxx</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                      <span class="token punctuation">{<!-- --></span><span class="token atom">module_info</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                      <span class="token punctuation">{<!-- --></span><span class="token atom">module_info</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                      <span class="token punctuation">{<!-- --></span><span class="token atom">start</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token number">3</span><span class="token operator">&gt;</span> <span class="token atom">first</span><span class="token punctuation">:</span><span class="token function">module_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token atom">hello</span> <span class="token atom">erlang</span>
<span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token atom">module</span><span class="token punctuation">,</span><span class="token atom">first</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{<!-- --></span><span class="token atom">exports</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token atom">start</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
           <span class="token punctuation">{<!-- --></span><span class="token quoted-atom atom">'NewPoint'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
           <span class="token punctuation">{<!-- --></span><span class="token atom">fact</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
           <span class="token punctuation">{<!-- --></span><span class="token atom">maxx</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
           <span class="token punctuation">{<!-- --></span><span class="token atom">module_info</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
           <span class="token punctuation">{<!-- --></span><span class="token atom">module_info</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{<!-- --></span><span class="token atom">attributes</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token atom">vsn</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">338263298016390874136079198029794793513</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{<!-- --></span><span class="token atom">compile</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token atom">version</span><span class="token punctuation">,</span><span class="token string">"8.2.3"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
           <span class="token punctuation">{<!-- --></span><span class="token atom">options</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
           <span class="token punctuation">{<!-- --></span><span class="token atom">source</span><span class="token punctuation">,</span><span class="token string">"A:/.../.../.../first.erl"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{<!-- --></span><span class="token atom">md5</span><span class="token punctuation">,</span><span class="token punctuation">&lt;&lt;</span><span class="token number">254</span><span class="token punctuation">,</span><span class="token number">123</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">158</span><span class="token punctuation">,</span><span class="token number">189</span><span class="token punctuation">,</span><span class="token number">141</span><span class="token punctuation">,</span><span class="token number">243</span><span class="token punctuation">,</span><span class="token number">105</span><span class="token punctuation">,</span><span class="token number">179</span><span class="token punctuation">,</span><span class="token number">102</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">130</span><span class="token punctuation">,</span>
        <span class="token number">52</span><span class="token punctuation">,</span><span class="token number">88</span><span class="token punctuation">,</span><span class="token number">41</span><span class="token punctuation">&gt;&gt;</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token number">3</span><span class="token operator">&gt;</span> <span class="token atom">first</span><span class="token punctuation">:</span><span class="token function">module_info</span><span class="token punctuation">(</span><span class="token atom">compile</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token atom">version</span><span class="token punctuation">,</span><span class="token string">"8.2.3"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{<!-- --></span><span class="token atom">options</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{<!-- --></span><span class="token atom">source</span><span class="token punctuation">,</span><span class="token string">"A:/.../.../.../first.erl"</span><span class="token punctuation">}</span><span class="token punctuation">]</span> 
</code></pre> 
<h4><a id="_451"></a>预处理属性</h4> 
<p>预处理属性会在编译之前处理。</p> 
<ul><li> <p><code>-include("file.hrl").</code></p> <p>用来导入record文件。</p> </li><li> <p><code>-define(Macro, Replacement).</code></p> <p>用来定义宏。</p> </li></ul> 
<h4><a id="record_462"></a>record属性</h4> 
<ul><li> <p><code>-record(Record,Fields).</code></p> <p>用来定义具名元组，我们已经在记录语法章节中见识过它了。</p> </li></ul> 
<h4><a id="_468"></a>函数属性</h4> 
<p>函数属性是用来描述函数的属性，用来补充函数的信息。</p> 
<ul><li> <p><code>-file(filename, line).</code></p> <p><code>filename</code>必须是字符串，<code>line</code>必须是正整数。erlang有两个预定义宏<code>?FILE</code>和<code>?LINE</code>表示一个函数所在的文件名和行号，当发生异常时，erlang会告诉你异常的函数在哪个文件的第几行。这个属性可以修改<code>?FILE</code>和<code>?LINE</code>宏，当某个函数的实现和声明不在一起的时候，这个属性就派上用场了，它可以告诉开发者异常函数的真正实现在哪里。</p> <p>在<code>first.erl</code>中输入以下代码：</p> </li></ul> 
<pre><code class="prism language-erlang"><span class="token operator">-</span><span class="token function">module</span><span class="token punctuation">(</span><span class="token atom">first</span><span class="token punctuation">)</span><span class="token punctuation">.</span>

<span class="token operator">-</span><span class="token function">file</span><span class="token punctuation">(</span><span class="token string">"我在这里"</span><span class="token punctuation">,</span> <span class="token number">573</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token function">double</span><span class="token punctuation">(</span><span class="token variable">I</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token variable">I</span><span class="token punctuation">.</span>
</code></pre> 
<pre><code>编译上面的代码会看到如下输出：
</code></pre> 
<pre><code class="prism language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token atom">first</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
我在这里<span class="token punctuation">:</span><span class="token number">574</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token variable">Warning</span><span class="token punctuation">:</span> <span class="token atom">function</span> <span class="token atom">double</span><span class="token operator">/</span><span class="token number">1</span> <span class="token atom">is</span> <span class="token atom">unused</span>
<span class="token punctuation">{<!-- --></span><span class="token atom">ok</span><span class="token punctuation">,</span><span class="token atom">first</span><span class="token punctuation">}</span>

</code></pre> 
<pre><code>由于我们并没有导出`double/1`函数，所以erlang给了我么一条警告，看开头那里，文件名和行号已经是我们指定的值了。注意，这个属性会影响它之后的所有函数，而不是紧挨着它的那一个函数。
</code></pre> 
<ul><li> <p><code>-spec my_function(integer()) -&gt; integer().</code></p> <p>这个属性是对函数类型的补充说明，指示函数出入参的类型，当你在vscode中将鼠标放到<code>io:format</code>函数上是，就会看到一个提示框，里面是一些<code>-spec</code>告诉你该函数入参是什么的时候返回值是什么，类似于一种文档。</p> </li></ul> 
<h4><a id="_499"></a>类型属性</h4> 
<ul><li> <p><code>-type my_type() :: atom() | integer().</code></p> <p>与<code>-spec</code>类似，不过它是用来描述类型的。</p> </li></ul> 
<h4><a id="_505"></a>特性属性</h4> 
<ul><li> <p><code>-feature(FeatureName, enable | disable)</code></p> <p>用来开启erlang特性，必须放在模块开头，<code>-moudle</code>之后，<code>-export</code>之前。</p> </li></ul> 
<h3><a id="_511"></a>表达式</h3> 
<p>函数式语言里没有语句的概念，一切皆是表达式。</p> 
<h4><a id="_515"></a>数值运算</h4> 
<table><thead><tr><th>运算符</th><th><strong>描述</strong></th><th><strong>参数</strong>类型</th></tr></thead><tbody><tr><td>+</td><td>正数</td><td>Number</td></tr><tr><td>-</td><td>负数</td><td>Number</td></tr><tr><td>+</td><td>加</td><td>number</td></tr><tr><td>-</td><td>减</td><td>Number</td></tr><tr><td>*</td><td>乘</td><td>Number</td></tr><tr><td>/</td><td>浮点除法</td><td>Number</td></tr><tr><td>bnot</td><td>按位取反</td><td>Integer</td></tr><tr><td>div</td><td>整数除法</td><td>Integer</td></tr><tr><td>rem</td><td>取余</td><td>Integer</td></tr><tr><td>band</td><td>按位与</td><td>Integer</td></tr><tr><td>bor</td><td>按位或</td><td>Integer</td></tr><tr><td>bxor</td><td>按位异或</td><td>Integer</td></tr><tr><td>bsl</td><td>算术左移</td><td>Integer</td></tr><tr><td>bsr</td><td>算术右移</td><td>Integer</td></tr></tbody></table> 
<p>以上都是运算符，以中缀的形式调用。</p> 
<h4><a id="_537"></a>比较运算</h4> 
<table><thead><tr><th><strong>运算符</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>=&lt;</td><td>小于等于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>==</td><td>等于</td></tr><tr><td>/=</td><td>不等于</td></tr><tr><td>=:=</td><td>严格等于</td></tr><tr><td>=/=</td><td>严格不等于</td></tr></tbody></table> 
<p>注意：</p> 
<ul><li>小于等于和其他语言的写法是相反的。</li><li>相比于等于和不等于，严格版本的等于和不等于还会判断类型，类型和值都相等才判定为相等。</li><li>erlang中任何类型之间都可以比较，规则如下：</li></ul> 
<pre><code class="prism language-erlang"><span class="token atom">number</span> <span class="token operator">&lt;</span> <span class="token atom">atom</span> <span class="token operator">&lt;</span> <span class="token atom">reference</span> <span class="token operator">&lt;</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span> <span class="token atom">port</span> <span class="token operator">&lt;</span> <span class="token atom">pid</span> <span class="token operator">&lt;</span> <span class="token atom">tuple</span> <span class="token operator">&lt;</span> <span class="token atom">map</span> <span class="token operator">&lt;</span> <span class="token atom">nil</span> <span class="token operator">&lt;</span> <span class="token atom">list</span> <span class="token operator">&lt;</span> <span class="token atom">bit</span> <span class="token atom">string</span>
</code></pre> 
<p>示例：</p> 
<pre><code class="prism language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1.0</span><span class="token punctuation">.</span>
<span class="token boolean">true</span>
<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">=:=</span> <span class="token number">1.0</span><span class="token punctuation">.</span>
<span class="token boolean">false</span>
<span class="token number">3</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">/=</span> <span class="token number">1.0</span><span class="token punctuation">.</span>
<span class="token boolean">false</span>
<span class="token number">4</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">=/=</span> <span class="token number">1.0</span><span class="token punctuation">.</span>
<span class="token boolean">true</span>
<span class="token number">5</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token atom">a</span><span class="token punctuation">.</span>
<span class="token boolean">true</span>

</code></pre> 
<h4><a id="_577"></a>布尔运算</h4> 
<table><thead><tr><th>运算符</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>not</td><td>逻辑非</td></tr><tr><td>and</td><td>逻辑与，两边都会求值</td></tr><tr><td>or</td><td>逻辑或，两边都会求值</td></tr><tr><td>xor</td><td>逻辑异或，两边都会求值</td></tr><tr><td>andalso</td><td>短路逻辑与</td></tr><tr><td>orelse</td><td>短路逻辑或</td></tr></tbody></table> 
<p>从Erlang/OTP R13A开始，<code>andalso</code>和<code>orelse</code>不再要求右边的表达式计算到布尔值。因此，它们现在是尾递归的。例如，以下函数在Erlang/OTP R13A和更高版本中是尾递归的。</p> 
<pre><code class="prism language-erlang"><span class="token function">all</span><span class="token punctuation">(</span><span class="token variable">Pred</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token variable">Hd</span><span class="token punctuation">|</span><span class="token variable">Tail</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token variable">Pred</span><span class="token punctuation">(</span><span class="token variable">Hd</span><span class="token punctuation">)</span> <span class="token operator">andalso</span> <span class="token function">all</span><span class="token punctuation">(</span><span class="token variable">Pred</span><span class="token punctuation">,</span> <span class="token variable">Tail</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">all</span><span class="token punctuation">(</span><span class="token variable">_</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token boolean">true</span><span class="token punctuation">.</span>
</code></pre> 
<h4><a id="_598"></a>流程控制</h4> 
<h5><a id="if_600"></a>if</h5> 
<p>语法：</p> 
<pre><code class="prism language-erlang"><span class="token keyword">if</span>
    <span class="token variable">GuardSeq1</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">Body1</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token variable">GuardSeqN</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">BodyN</span>
<span class="token keyword">end</span>
</code></pre> 
<p>一般会在最后加一个<code>true</code>分支作为else，没有<code>true</code>分支并不会导致编译错误，但是在运行时，一旦所有分支都匹配失败，就会引发异常。</p> 
<p>示例：</p> 
<pre><code class="prism language-erlang"><span class="token function">is_greater_than</span><span class="token punctuation">(</span><span class="token variable">X</span><span class="token punctuation">,</span> <span class="token variable">Y</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token keyword">if</span>
        <span class="token variable">X</span><span class="token operator">&gt;</span><span class="token variable">Y</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
            <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token boolean">true</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token comment">% works as an 'else' branch</span>
            <span class="token boolean">false</span>
    <span class="token keyword">end</span><span class="token punctuation">.</span>
</code></pre> 
<h5><a id="case_628"></a>case</h5> 
<p>语法：</p> 
<pre><code class="prism language-erlang"><span class="token keyword">case</span> <span class="token variable">Expr</span> <span class="token keyword">of</span>
    <span class="token variable">Pattern1</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">GuardSeq1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">Body1</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token variable">PatternN</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">GuardSeqN</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">BodyN</span>
<span class="token keyword">end</span>
</code></pre> 
<p>case的语法同函数有点像，如果所有的分支都匹配失败，则会引发一个运行时错误。</p> 
<h5><a id="maybe_644"></a>maybe</h5> 
<p>OTP 25新加的实验性功能，默认关闭，开启方式如下：</p> 
<ul><li>第一步：在源代码中加入<code>-feature(maybe_expr, enable).</code>(紧挨在<code>-module</code>之后)，获得语法上的通行证。</li><li>第二步：使用特性编译代码，这里有以下两种方式可选： 
  <ul><li>在erlang shell中编译：<code>compile:file(first, {feature,maybe_expr,enable}). </code></li><li>在命令行用<code>erlc</code>编译：<code>erlc -enable-feature maybe_expr first.erl</code></li></ul> </li><li>第三步：使用特性打开erlang shell，在命令行中执行<code>erl -enable-feature maybe_expr</code>，现在就可以在erlang shell中实验maybe表达式了。</li></ul> 
<p><code>maybe</code>表达式的语法如下：</p> 
<pre><code class="prism language-erlang"><span class="token atom">maybe</span>
    <span class="token variable">Expr1</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>
    <span class="token variable">ExprN</span>
<span class="token keyword">end</span>
</code></pre> 
<p><code>maybe</code>和<code>end</code>之间的表达式会依次被求值，最后一个表达式的值也是<code>maybe</code>表达式的值。</p> 
<p><code>maybe</code>表达式中支持一种称为条件匹配的模式匹配，语法是<code>Expr1 ?= Expr2</code>。如果匹配成功，它和正常的模式匹配<code>Expr1 = Expr2</code>没啥区别，如果它是<code>maybe</code>中的最后一个表达式，则<code>Expr2</code>也是<code>maybe</code>表达式的值；如果匹配失败，它会将后面的表达式短路，并返回<code>Expr2</code>做为<code>maybe</code>的值。</p> 
<p>示例：</p> 
<pre><code class="prism language-erlang"><span class="token atom">maybe</span>
    <span class="token punctuation">{<!-- --></span><span class="token atom">ok</span><span class="token punctuation">,</span> <span class="token variable">A</span><span class="token punctuation">}</span> ?<span class="token operator">=</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token boolean">true</span> <span class="token operator">=</span> <span class="token variable">A</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token punctuation">{<!-- --></span><span class="token atom">ok</span><span class="token punctuation">,</span> <span class="token variable">B</span><span class="token punctuation">}</span> ?<span class="token operator">=</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token variable">A</span> <span class="token operator">+</span> <span class="token variable">B</span>
<span class="token keyword">end</span>
</code></pre> 
<p>正常情况下，如果函数<code>a/0</code>返回<code>{ok,1}</code>，<code>b/0</code>返回<code>{ok,2}</code>，那么<code>maybe</code>表达式返回<code>1+2</code>等于<code>3</code>。如果<code>a/0</code>或<code>b/0</code>返回<code>error</code>，根据<code>?=</code>的规则，<code>maybe</code>表达式返回<code>error</code>，后面的表达式都不会求值。如果<code>a/0</code>返回负数，第二个<code>=</code>模式匹配失败，异常退出。</p> 
<p><code>maybe</code>表达式中还可以带一个<code>else</code>表达式，语法如下：</p> 
<pre><code class="prism language-erlang"><span class="token atom">maybe</span>
    <span class="token variable">Expr1</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>
    <span class="token variable">ExprN</span>
<span class="token atom">else</span>
    <span class="token variable">Pattern1</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">GuardSeq1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">Body1</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token variable">PatternN</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">GuardSeqN</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">BodyN</span>
<span class="token keyword">end</span>
</code></pre> 
<p>当<code>?=</code>匹配失败是，它的值会和<code>else</code>中的模式进行匹配，如果匹配上，对应分支的表达式会做为整个<code>maybe</code>表达式的结果，如果没有分支匹配上，则会引发一个运行时异常。</p> 
<p>注意<code>maybe</code>和<code>else</code>是两个独立分作用域，<code>maybe</code>中绑定的变量是不能在<code>else</code>中使用的。</p> 
<p>示例：</p> 
<pre><code class="prism language-erlang"><span class="token atom">maybe</span>
    <span class="token punctuation">{<!-- --></span><span class="token atom">ok</span><span class="token punctuation">,</span> <span class="token variable">A</span><span class="token punctuation">}</span> ?<span class="token operator">=</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token boolean">true</span> <span class="token operator">=</span> <span class="token variable">A</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token punctuation">{<!-- --></span><span class="token atom">ok</span><span class="token punctuation">,</span> <span class="token variable">B</span><span class="token punctuation">}</span> ?<span class="token operator">=</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token variable">A</span> <span class="token operator">+</span> <span class="token variable">B</span>
<span class="token atom">else</span>
    <span class="token atom">error</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token atom">error</span><span class="token punctuation">;</span>
    <span class="token atom">wrong</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token atom">error</span>
<span class="token keyword">end</span>
</code></pre> 
<h5><a id="catch_716"></a>catch</h5> 
<p><code>catch</code>用来捕获异常，语法如下：</p> 
<pre><code class="prism language-erlang"><span class="token keyword">catch</span> <span class="token variable">Expr</span>
</code></pre> 
<p>返回<code>Expr</code>的值，如果发生异常，返回异常值。示例如下：</p> 
<pre><code class="prism language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token keyword">catch</span> <span class="token number">1</span><span class="token operator">+</span><span class="token number">2.</span>
<span class="token number">3</span>
<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token keyword">catch</span> <span class="token number">1</span><span class="token operator">+</span><span class="token atom">a</span><span class="token punctuation">.</span>
<span class="token punctuation">{<!-- --></span><span class="token quoted-atom atom">'EXIT'</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span><span class="token atom">badarith</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre> 
<p>erlang有三种方式显示生成一个错误：</p> 
<ul><li><code>throw(Term)</code>返回<code>Term</code>。</li><li><code>exit(Term)</code>返回<code>{'EXIT',Term}</code>。</li><li><code>error(Term)</code>返回<code>{'EXIT',{Reason,Stack}}</code>，<code>Reason</code>是异常原因，<code>Stack</code>是调用栈。</li></ul> 
<p>相比于其他语言要做大量防御式编程，erlang的防御是内建的，因此erlang函数往往可以只处理正常数据，对于异常数据则任其崩溃，监控进程表示：没关系，我会出手。</p> 
<h5><a id="try_741"></a>try</h5> 
<p><code>try</code>表达式是<code>catch</code>的升级版，完整语法如下：</p> 
<pre><code class="prism language-erlang"><span class="token keyword">try</span> <span class="token variable">Exprs</span> <span class="token keyword">of</span>
    <span class="token variable">Pattern1</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">GuardSeq1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">Body1</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token variable">PatternN</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">GuardSeqN</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">BodyN</span>
<span class="token keyword">catch</span>
    <span class="token variable">Class1</span><span class="token punctuation">:</span><span class="token variable">ExceptionPattern1</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token variable">Stacktrace</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">ExceptionGuardSeq1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">ExceptionBody1</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token variable">ClassN</span><span class="token punctuation">:</span><span class="token variable">ExceptionPatternN</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token variable">Stacktrace</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">ExceptionGuardSeqN</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">ExceptionBodyN</span>
<span class="token keyword">after</span>
    <span class="token variable">AfterBody</span>
<span class="token keyword">end</span>
</code></pre> 
<p>嗯…try-catch-finally…妥了🤣。<code>try</code>代码块和<code>case</code>非常像，不再赘述。<code>catch</code>块用来处理异常，不要和<code>catch</code>表达式混淆。<code>Classi</code>是异常的类，有<code>throw</code>、<code>exit</code>和<code>error</code>；<code>Stacktrace</code>必须是一个变量，用来接收调用栈，这两都是可省略的。<code>ExceptionPatterni</code>是用来匹配异常值的模式，<code>ExceptionGuardSeqi</code>是关卡，这些我们已经很熟悉了。如果<code>catch</code>块没能和异常匹配，异常就会继续往外抛。<code>after</code>块用来在最后执行一些清理工作，无论有无异常或异常有无被捕获，它都会执行，而且它的值会被丢弃，但如果<code>AfterBody</code>发生异常，它是不会被捕获的，而且会覆盖之前的异常。</p> 
<p>完整的<code>try</code>表达式语法比较复杂，它有几个简化版本。</p> 
<p>首先是<code>after</code>块可以被省略，如下：</p> 
<pre><code class="prism language-erlang"><span class="token keyword">try</span> <span class="token variable">Exprs</span> <span class="token keyword">of</span>
    <span class="token variable">Pattern1</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">GuardSeq1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">Body1</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token variable">PatternN</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">GuardSeqN</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">BodyN</span>
<span class="token keyword">catch</span>
    <span class="token variable">Class1</span><span class="token punctuation">:</span><span class="token variable">ExceptionPattern1</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token variable">Stacktrace</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">ExceptionGuardSeq1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">ExceptionBody1</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token variable">ClassN</span><span class="token punctuation">:</span><span class="token variable">ExceptionPatternN</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token variable">Stacktrace</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">ExceptionGuardSeqN</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">ExceptionBodyN</span>
<span class="token keyword">end</span>
</code></pre> 
<p>其次是<code>try</code>代码块可以简化，即去掉<code>of</code>及其后面的模式分支，如下：</p> 
<pre><code class="prism language-erlang"><span class="token keyword">try</span> <span class="token variable">Exprs</span>
<span class="token keyword">catch</span>
    <span class="token variable">Class1</span><span class="token punctuation">:</span><span class="token variable">ExceptionPattern1</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token variable">Stacktrace</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">ExceptionGuardSeq1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">ExceptionBody1</span><span class="token punctuation">;</span>
    <span class="token variable">ClassN</span><span class="token punctuation">:</span><span class="token variable">ExceptionPatternN</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token variable">Stacktrace</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">ExceptionGuardSeqN</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">ExceptionBodyN</span>
<span class="token keyword">end</span>
</code></pre> 
<p>最后<code>catch</code>块也可以简化，省略掉<code>class</code>，如下：</p> 
<pre><code class="prism language-erlang"><span class="token keyword">try</span> <span class="token variable">Exprs</span>
<span class="token keyword">catch</span>
    <span class="token variable">ExceptionPattern1</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">ExceptionGuardSeq1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">ExceptionBody1</span><span class="token punctuation">;</span>
    <span class="token variable">ExceptionPatternN</span> <span class="token punctuation">[</span><span class="token keyword">when</span> <span class="token variable">ExceptionGuardSeqN</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
        <span class="token variable">ExceptionBodyN</span>
<span class="token keyword">end</span>
</code></pre> 
<p>示例1，读取文件：</p> 
<pre><code class="prism language-erlang"><span class="token function">termize_file</span><span class="token punctuation">(</span><span class="token variable">Name</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token punctuation">{<!-- --></span><span class="token atom">ok</span><span class="token punctuation">,</span><span class="token variable">F</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token atom">file</span><span class="token punctuation">:</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token variable">Name</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token atom">read</span><span class="token punctuation">,</span><span class="token atom">binary</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">try</span>
        <span class="token punctuation">{<!-- --></span><span class="token atom">ok</span><span class="token punctuation">,</span><span class="token variable">Bin</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token atom">file</span><span class="token punctuation">:</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token variable">F</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">binary_to_term</span><span class="token punctuation">(</span><span class="token variable">Bin</span><span class="token punctuation">)</span>
    <span class="token keyword">after</span>
        <span class="token atom">file</span><span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token variable">F</span><span class="token punctuation">)</span>
    <span class="token keyword">end</span><span class="token punctuation">.</span>
</code></pre> 
<p>示例2，匹配<code>class</code>：</p> 
<pre><code class="prism language-erlang"><span class="token keyword">try</span> <span class="token variable">Expr</span>
<span class="token keyword">catch</span>
    <span class="token atom">throw</span><span class="token punctuation">:</span><span class="token variable">Term</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token variable">Term</span><span class="token punctuation">;</span>
    <span class="token atom">exit</span><span class="token punctuation">:</span><span class="token variable">Reason</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span><span class="token quoted-atom atom">'EXIT'</span><span class="token punctuation">,</span><span class="token variable">Reason</span><span class="token punctuation">}</span>
    <span class="token atom">error</span><span class="token punctuation">:</span><span class="token variable">Reason</span><span class="token punctuation">:</span><span class="token variable">Stk</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span><span class="token quoted-atom atom">'EXIT'</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span><span class="token variable">Reason</span><span class="token punctuation">,</span><span class="token variable">Stk</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token keyword">end</span>
</code></pre> 
<h4><a id="_833"></a>块表达式</h4> 
<p>表达式序列可以通过<code>begin...end</code>打包成一个表达式，如果如下：</p> 
<pre><code class="prism language-erlang"><span class="token atom">begin</span>
   <span class="token variable">Expr1</span><span class="token punctuation">,</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>
   <span class="token variable">ExprN</span>
<span class="token keyword">end</span>
</code></pre> 
<p>块表达式的值是最后一个表达式<code>ExprN</code>的值。</p> 
<h4><a id="_847"></a>模式匹配</h4> 
<p>erlang中的<code>=</code>并不是赋值，而是模式匹配，语法如下：</p> 
<pre><code class="prism language-erlang"><span class="token variable">Expr1</span> <span class="token operator">=</span> <span class="token variable">Expr2</span>
</code></pre> 
<p>模式匹配匹配的是构造函数，所谓模式就是一个值的构造形式，或者说是它具有的形状。模式匹配是函数式语言提取数据结构的唯一方式，学习函数式语言必须掌握模式匹配。</p> 
<p>erlang模式匹配要求<code>=</code>右边的表达式不能有未绑定变量，但左边的表达式可以有未绑定变量。如果模式匹配成功，那么左边未绑定的变量都会被绑定，右边表达式的值会做为整个模式匹配的结果返回。</p> 
<p>例子：</p> 
<pre><code class="prism language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1.</span>
<span class="token number">1</span>
<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">2.</span>
<span class="token operator">*</span><span class="token operator">*</span> <span class="token atom">exception</span> <span class="token atom">error</span><span class="token punctuation">:</span> <span class="token atom">no</span> <span class="token atom">match</span> <span class="token keyword">of</span> <span class="token atom">right</span> <span class="token atom">hand</span> <span class="token atom">side</span> <span class="token atom">value</span> <span class="token number">2</span>
<span class="token number">3</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span><span class="token variable">A</span><span class="token punctuation">,</span><span class="token variable">B</span><span class="token punctuation">}</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token atom">a</span><span class="token punctuation">}</span><span class="token punctuation">.</span>
<span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token atom">a</span><span class="token punctuation">}</span>
<span class="token number">4</span><span class="token operator">&gt;</span> <span class="token variable">A</span><span class="token punctuation">.</span>
<span class="token number">1</span>
<span class="token number">5</span><span class="token operator">&gt;</span> <span class="token variable">B</span><span class="token punctuation">.</span>
<span class="token atom">a</span>
<span class="token number">6</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token variable">C</span><span class="token punctuation">}</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">.</span>
<span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span>
<span class="token number">7</span><span class="token operator">&gt;</span> <span class="token variable">C</span><span class="token punctuation">.</span>
<span class="token number">2</span>
<span class="token number">8</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token variable">H</span><span class="token punctuation">|</span><span class="token variable">T</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token number">9</span><span class="token operator">&gt;</span> <span class="token variable">H</span><span class="token punctuation">.</span>
<span class="token number">1</span>
<span class="token number">10</span><span class="token operator">&gt;</span> <span class="token variable">T</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token number">11</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">|</span><span class="token variable">L</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token number">12</span><span class="token operator">&gt;</span> <span class="token variable">L</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>

</code></pre> 
<p><code>1=1</code>居然也是模式匹配大概是许多初学者最不能理解的地方，我们可以做一个类比来帮助你理解。</p> 
<p>数字是一种类型，就像三角形是一种形状。你写下1和2就像随手画两个三角形，它们肯定不会是完全一样的。而浮点数就像是四边形，不管你怎么画，肯定不会和三角形一样。而像列表、元组这样的类型就像是可以容纳其他图元的形状。总之，不同类型会有不同形状，同一种类型的不同值之间形状也不会完全一样。所谓模式，就是值所具备的形状，而模式匹配，就是就是在匹配这些不同的形状。</p> 
<div align="center"> 
 <img src="https://images2.imgbox.com/25/79/NaQ3bzBC_o.png" width="40%"> 
</div> 
<p>对于变量而言，在模式匹配之前，它们处于任何形状的叠加态，一旦模式匹配完成，它们就会坍缩到一种具体的形状，属实是薛定谔的变量了。</p> 
<h4><a id="_896"></a><code>++</code>和<code>--</code></h4> 
<p>erlang中的<code>++</code>和<code>--</code>不是自增和自减，甚至都和整数没有关系，它们是用来拼接和删除列表的，语法如下：</p> 
<pre><code class="prism language-erlang"><span class="token variable">Expr1</span> <span class="token operator">++</span> <span class="token variable">Expr2</span>
<span class="token variable">Expr1</span> <span class="token operator">--</span> <span class="token variable">Expr2</span>
</code></pre> 
<p>示例：</p> 
<pre><code class="prism language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
</code></pre> 
<p>注意，对于<code>--</code>来说，右边列表中的每个元素在左边列表里只会删除一次。</p> 
<h4><a id="_916"></a>列表和二进制推导</h4> 
<p>列表推导和二进制推导的语法如下：</p> 
<pre><code class="prism language-erlang"><span class="token punctuation">[</span><span class="token variable">Expr</span> <span class="token punctuation">|</span><span class="token punctuation">|</span> <span class="token variable">Qualifier1</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token variable">QualifierN</span><span class="token punctuation">]</span>
<span class="token punctuation">&lt;&lt;</span> <span class="token punctuation">&lt;&lt;</span><span class="token variable">Expr</span><span class="token punctuation">&gt;&gt;</span> <span class="token punctuation">|</span><span class="token punctuation">|</span> <span class="token variable">Qualifier1</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token variable">QualifierN</span> <span class="token punctuation">&gt;&gt;</span>

</code></pre> 
<p><code>Qualifieri</code>可以是一个生成器或一个过滤器。生成器有以下两种：</p> 
<ul><li>列表生成器：<code>Pattern &lt;- ListExpr</code>，<code>ListExpr</code>是一个可以生成列表的表达式。</li><li>二进制生成器：<code>BitstringPattern &lt;= BitStringExpr</code>，<code>BitStringExpr</code>是一个可以产生二进制流的表达式。</li></ul> 
<p>列表生成器既可以用于列表推导，也可以用于二进制推导，二进制生成器也一样。</p> 
<p>过滤器是一个产生布尔值的表达式，如果返回值不是<code>true</code>或<code>false</code>，会产生一个bad filter的运行时异常。</p> 
<p>对于二进制推导，还有一点需要格外注意，如果<code>Expr</code>是包含运算符的复杂表达式，必须用括号<code>()</code>包裹。</p> 
<p>示例：</p> 
<pre><code class="prism language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token variable">X</span><span class="token operator">*</span><span class="token variable">Y</span> <span class="token punctuation">|</span><span class="token punctuation">|</span> <span class="token variable">X</span><span class="token operator">&lt;</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token variable">Y</span><span class="token operator">&lt;</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token variable">X</span><span class="token operator">*</span><span class="token variable">Y</span> <span class="token punctuation">|</span><span class="token punctuation">|</span> <span class="token variable">X</span><span class="token operator">&lt;</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token variable">Y</span><span class="token operator">&lt;</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token variable">X</span><span class="token operator">*</span><span class="token variable">Y</span><span class="token operator">&gt;</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token number">3</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token variable">X</span><span class="token operator">*</span><span class="token variable">Y</span> <span class="token punctuation">|</span><span class="token punctuation">|</span> <span class="token variable">X</span><span class="token operator">&lt;</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token variable">Y</span><span class="token operator">&lt;</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token variable">X</span><span class="token operator">&gt;</span><span class="token number">1</span> <span class="token operator">andalso</span> <span class="token variable">Y</span><span class="token operator">&gt;</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token number">4</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token variable">X</span> <span class="token punctuation">|</span><span class="token punctuation">|</span> <span class="token punctuation">&lt;&lt;</span><span class="token variable">X</span><span class="token punctuation">&gt;&gt;</span> <span class="token operator">&lt;=</span> <span class="token punctuation">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&gt;&gt;</span><span class="token punctuation">]</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token number">5</span><span class="token operator">&gt;</span> <span class="token punctuation">&lt;&lt;</span> <span class="token punctuation">&lt;&lt;</span><span class="token variable">X</span><span class="token punctuation">&gt;&gt;</span> <span class="token punctuation">|</span><span class="token punctuation">|</span> <span class="token variable">X</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">&gt;&gt;</span><span class="token punctuation">.</span>
<span class="token punctuation">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&gt;&gt;</span>
<span class="token number">6</span><span class="token operator">&gt;</span> <span class="token punctuation">&lt;&lt;</span> <span class="token punctuation">&lt;&lt;</span><span class="token punctuation">(</span><span class="token variable">X</span><span class="token operator">+</span><span class="token variable">Y</span><span class="token punctuation">)</span><span class="token punctuation">&gt;&gt;</span> <span class="token punctuation">|</span><span class="token punctuation">|</span> <span class="token punctuation">&lt;&lt;</span><span class="token variable">X</span><span class="token punctuation">&gt;&gt;</span> <span class="token operator">&lt;=</span> <span class="token punctuation">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&gt;&gt;</span><span class="token punctuation">,</span> <span class="token variable">Y</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">&gt;&gt;</span><span class="token punctuation">.</span> 
<span class="token punctuation">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">&gt;&gt;</span>

</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d2613397497cb389896b0b9dbb680c4d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">考虑充电负荷空间可调度特性的分布式电源与电动汽车充电站联合配置方法（Matlab代码实现）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d33c94f089f1d36c69f8edac81da228/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c语言题目01</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>