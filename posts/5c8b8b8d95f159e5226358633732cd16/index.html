<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java常用数据结构优劣势和应用场景 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java常用数据结构优劣势和应用场景" />
<meta property="og:description" content="目录 数组(Array)
定义
优势
劣势
应用场景
Java代码部分
链表(Linked List)
定义
优势
劣势
应用场景
Java代码部分
栈(Stack)
定义
特点
优势
劣势
应用场景
Java代码部分(使用栈)
Java代码部分(使用链表)
队列(Queue)
定义
特点
优势
应用场景
Java代码部分(使用数组)
Java代码部分(使用链表)
二叉树(Binary Tree)
定义
特点
优势
劣势
应用场景
Java代码部分
二叉查找树(Binary Search Tree)
定义
特点
优势
劣势
Java代码部分
堆(Heap)
定义
特点
优势
劣势
应用场景
Java部分代码(最大堆)
散列表/哈希表(Hashing)
定义
特点
优势
劣势
常用的Hash数据结构
应用场景
Java代码部分(查找唯一的字符串)
Java部分代码(计算一个字符串的字符)
图(Graph)
定义
特点
优势
劣势
应用场景
Java代码部分
数组(Array) 定义 数组是由相同类型的元素(element)的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引(index)可以计算出该元素对应的存储地址。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/5c8b8b8d95f159e5226358633732cd16/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-17T20:31:45+08:00" />
<meta property="article:modified_time" content="2023-02-17T20:31:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java常用数据结构优劣势和应用场景</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="main-toc" style="text-align:center;"><strong>目录</strong></h2> 
<p id="%E6%95%B0%E7%BB%84(Array)-toc" style="margin-left:0px;"><a href="#%E6%95%B0%E7%BB%84%28Array%29" rel="nofollow">数组(Array)</a></p> 
<p id="%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E4%B9%89" rel="nofollow">定义</a></p> 
<p id="%E4%BC%98%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E4%BC%98%E5%8A%BF" rel="nofollow">优势</a></p> 
<p id="%E5%8A%A3%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E5%8A%A3%E5%8A%BF" rel="nofollow">劣势</a></p> 
<p id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">应用场景</a></p> 
<p id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86-toc" style="margin-left:80px;"><a href="#Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86" rel="nofollow">Java代码部分</a></p> 
<p id="%E9%93%BE%E8%A1%A8(Linked%20List)-toc" style="margin-left:0px;"><a href="#%E9%93%BE%E8%A1%A8%28Linked%20List%29" rel="nofollow">链表(Linked List)</a></p> 
<p id="%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E4%B9%89" rel="nofollow">定义</a></p> 
<p id="%E4%BC%98%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E4%BC%98%E5%8A%BF" rel="nofollow">优势</a></p> 
<p id="%E5%8A%A3%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E5%8A%A3%E5%8A%BF" rel="nofollow">劣势</a></p> 
<p id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">应用场景</a></p> 
<p id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86-toc" style="margin-left:80px;"><a href="#Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86" rel="nofollow">Java代码部分</a></p> 
<p id="%E6%A0%88(Stack)-toc" style="margin-left:0px;"><a href="#%E6%A0%88%28Stack%29" rel="nofollow">栈(Stack)</a></p> 
<p id="%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E4%B9%89" rel="nofollow">定义</a></p> 
<p id="%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E7%89%B9%E7%82%B9" rel="nofollow">特点</a></p> 
<p id="%E4%BC%98%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E4%BC%98%E5%8A%BF" rel="nofollow">优势</a></p> 
<p id="%E5%8A%A3%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E5%8A%A3%E5%8A%BF" rel="nofollow">劣势</a></p> 
<p id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">应用场景</a></p> 
<p id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86(%E4%BD%BF%E7%94%A8%E6%A0%88)-toc" style="margin-left:80px;"><a href="#Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86%28%E4%BD%BF%E7%94%A8%E6%A0%88%29" rel="nofollow">Java代码部分(使用栈)</a></p> 
<p id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86(%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8)-toc" style="margin-left:80px;"><a href="#Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86%28%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8%29" rel="nofollow">Java代码部分(使用链表)</a></p> 
<p id="%E9%98%9F%E5%88%97(Queue)-toc" style="margin-left:0px;"><a href="#%E9%98%9F%E5%88%97%28Queue%29" rel="nofollow">队列(Queue)</a></p> 
<p id="%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E4%B9%89" rel="nofollow">定义</a></p> 
<p id="%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E7%89%B9%E7%82%B9" rel="nofollow">特点</a></p> 
<p id="%E4%BC%98%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E4%BC%98%E5%8A%BF" rel="nofollow">优势</a></p> 
<p id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">应用场景</a></p> 
<p id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86(%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84)-toc" style="margin-left:80px;"><a href="#Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86%28%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%29" rel="nofollow">Java代码部分(使用数组)</a></p> 
<p id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86(%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8)-toc" style="margin-left:80px;"><a href="#Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86%28%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8%29" rel="nofollow">Java代码部分(使用链表)</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91(Binary%20Tree)-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%28Binary%20Tree%29" rel="nofollow">二叉树(Binary Tree)</a></p> 
<p id="%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E4%B9%89" rel="nofollow">定义</a></p> 
<p id="%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E7%89%B9%E7%82%B9" rel="nofollow">特点</a></p> 
<p id="%E4%BC%98%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E4%BC%98%E5%8A%BF" rel="nofollow">优势</a></p> 
<p id="%E5%8A%A3%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E5%8A%A3%E5%8A%BF" rel="nofollow">劣势</a></p> 
<p id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">应用场景</a></p> 
<p id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86-toc" style="margin-left:80px;"><a href="#Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86" rel="nofollow">Java代码部分</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91(Binary%20Search%20Tree)-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%28Binary%20Search%20Tree%29" rel="nofollow">二叉查找树(Binary Search Tree)</a></p> 
<p id="%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E4%B9%89" rel="nofollow">定义</a></p> 
<p id="%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E7%89%B9%E7%82%B9" rel="nofollow">特点</a></p> 
<p id="%E4%BC%98%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E4%BC%98%E5%8A%BF" rel="nofollow">优势</a></p> 
<p id="%E5%8A%A3%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E5%8A%A3%E5%8A%BF" rel="nofollow">劣势</a></p> 
<p id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86-toc" style="margin-left:80px;"><a href="#Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86" rel="nofollow">Java代码部分</a></p> 
<p id="%E5%A0%86(Heap)-toc" style="margin-left:0px;"><a href="#%E5%A0%86%28Heap%29" rel="nofollow">堆(Heap)</a></p> 
<p id="%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E4%B9%89" rel="nofollow">定义</a></p> 
<p id="%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E7%89%B9%E7%82%B9" rel="nofollow">特点</a></p> 
<p id="%E4%BC%98%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E4%BC%98%E5%8A%BF" rel="nofollow">优势</a></p> 
<p id="%E5%8A%A3%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E5%8A%A3%E5%8A%BF" rel="nofollow">劣势</a></p> 
<p id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">应用场景</a></p> 
<p id="Java%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81(%E6%9C%80%E5%A4%A7%E5%A0%86)-toc" style="margin-left:80px;"><a href="#Java%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%28%E6%9C%80%E5%A4%A7%E5%A0%86%29" rel="nofollow">Java部分代码(最大堆)</a></p> 
<p id="%E6%95%A3%E5%88%97%E8%A1%A8(Hashing)-toc" style="margin-left:0px;"><a href="#%E6%95%A3%E5%88%97%E8%A1%A8%28Hashing%29" rel="nofollow">散列表/哈希表(Hashing)</a></p> 
<p id="%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E4%B9%89" rel="nofollow">定义</a></p> 
<p id="%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E7%89%B9%E7%82%B9" rel="nofollow">特点</a></p> 
<p id="%E4%BC%98%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E4%BC%98%E5%8A%BF" rel="nofollow">优势</a></p> 
<p id="%E5%8A%A3%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E5%8A%A3%E5%8A%BF" rel="nofollow">劣势</a></p> 
<p id="%E5%B8%B8%E7%94%A8%E7%9A%84Hash%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84Hash%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">常用的Hash数据结构</a></p> 
<p id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">应用场景</a></p> 
<p id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86(%E6%9F%A5%E6%89%BE%E5%94%AF%E4%B8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2)-toc" style="margin-left:80px;"><a href="#Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86%28%E6%9F%A5%E6%89%BE%E5%94%AF%E4%B8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%29" rel="nofollow">Java代码部分(查找唯一的字符串)</a></p> 
<p id="Java%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81(%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E7%AC%A6)-toc" style="margin-left:80px;"><a href="#Java%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%28%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E7%AC%A6%29" rel="nofollow">Java部分代码(计算一个字符串的字符)</a></p> 
<p id="%E5%9B%BE(Graph)-toc" style="margin-left:0px;"><a href="#%E5%9B%BE%28Graph%29" rel="nofollow">图(Graph)</a></p> 
<p id="%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E4%B9%89" rel="nofollow">定义</a></p> 
<p id="%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E7%89%B9%E7%82%B9" rel="nofollow">特点</a></p> 
<p id="%E4%BC%98%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E4%BC%98%E5%8A%BF" rel="nofollow">优势</a></p> 
<p id="%E5%8A%A3%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E5%8A%A3%E5%8A%BF" rel="nofollow">劣势</a></p> 
<p id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">应用场景</a></p> 
<p id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86-toc" style="margin-left:80px;"><a href="#Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86" rel="nofollow">Java代码部分</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%95%B0%E7%BB%84(Array)" style="margin-left:.0001pt;text-align:justify;">数组(Array)</h2> 
<h3 id="%E5%AE%9A%E4%B9%89">定义</h3> 
<p style="margin-left:.0001pt;text-align:justify;">数组是由相同类型的元素(element)的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引(index)可以计算出该元素对应的存储地址。</p> 
<p style="margin-left:.0001pt;text-align:left;">最简单的数据结构类型是一维数组。例如，索引为0到9的32位整数数组，可作为在存储器地址2000，2004，2008，...2036中，存储10个变量，因此索引为i的元素即在存储器中的2000+4×i地址。数组第一个元素的存储器地址称为第一地址或基础地址。</p> 
<p style="margin-left:.0001pt;text-align:left;">二维数组，对应于数学上的矩阵概念，可表示为二维矩形格</p> 
<h3 id="%E4%BC%98%E5%8A%BF">优势</h3> 
<p>1. 可随机访问数组内容(寻址容易)</p> 
<p>2. 易于排序和遍历</p> 
<p>3. 可替换多个变量</p> 
<h3 id="%E5%8A%A3%E5%8A%BF">劣势</h3> 
<p>1. 数组的长度固定</p> 
<p>2. 插入与删除难</p> 
<p>3. 若数组的长度很长，数组内元素少，则空间被浪费(容量高，占用率低，空间浪费)</p> 
<p>4. 需要连续的内存来分配</p> 
<h3 id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</h3> 
<p>1. 用于线性方式储存信息</p> 
<p>2. 需要频繁搜索的场景</p> 
<h4 id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86">Java代码部分</h4> 
<pre><code class="language-java">// 数组类型 : 8大基础类型
int[] intArray1, intArray2, intArray3; 
byte[] byteArray1;
short[] shortsArray1;
boolean[] booleanArray1;
long[] longArray1;
float[] floatArray1;
double[] doubleArray1;
char[] charArray1;

// 一维数组的创建与初始化

// 创建方式1 : 已知数组长度
intArray1 = new int[20];

// 创建方式2 : 已知数组元素
intArray2 = new int[]{1,2,3,4,5,6,7,8,9,10}; 
// 或者
intArray2 = {1,2,3,4,5,6,7,8,9,10};

// 创建方式3 : 已知数组长度和元素    
intArray3 = new int [5] {1,2,3,4,​5};

// 二维数组
// 创建方式1
int intArrayOfArray1[][]={<!-- -->{1,2,3},{4,5,6}};

// 创建方式2
int[][] intArrayOfArray2 = new int[4][2];
intArrayOfArray2[i][j] = x; // 分别赋值x常量

// 创建方式3 : 动态申请第二维数组的长度
int[][] intArrayOfArray3 = new int[5][];//五行的长度
for(int i=0; i &lt; intArrayOfArray3.length; i++){
    intArrayOfArray3[i] = new int[i+1]; //列的长度每次都变化。每次都要重新申请空间(长度)
    for(int j=0; j &lt; intArrayOfArray3[i].length; j++)
        intArrayOfArray3[i][j] = i + j;
}

</code></pre> 
<h2 id="%E9%93%BE%E8%A1%A8(Linked%20List)" style="margin-left:.0001pt;text-align:justify;">链表(Linked List)</h2> 
<h3>定义</h3> 
<p>链表是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)</p> 
<h3>优势</h3> 
<p>1. 链表长度可动态分配</p> 
<p>2. 无空间浪费，因为容量和大小总是相等</p> 
<p>3. 易于插入和删除，因为只需要进行一次链条操作(将指针链接到新的节点上即可)</p> 
<p>4. 高效的内存分配</p> 
<h3>劣势</h3> 
<p>1. 如果头节点丢失，链表也会丢失(寻址困难)</p> 
<p>2. 无法随机访问链表内容</p> 
<h3>应用场景</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1. 适用于内存有限的地方</p> 
<p style="margin-left:.0001pt;text-align:justify;">2. 适用于需要频繁插入和删除的应用程序</p> 
<h4 style="margin-left:.0001pt;text-align:justify;">Java代码部分</h4> 
<pre><code class="language-java">import java.util.*;

// 新建链表 : 节点和下一个节点
class LLNode{

	int data;
	LLNode next;
	
	LLNode(int data)
	{
		this.data=data;
		this.next=null;
		
	}
}


class Demo{
	
	LLNode head; // 头结点
	
	// 头部插入新的节点
	LLNode insertInBeg(int key,LLNode head)
	{
		LLNode ttmp=new LLNode(key);
		
		if(head==null)
			head=ttmp;
		
		else
			{
				ttmp.next=head;
				head=ttmp;
			}
		return head;
	}
	
	// 尾部插入新的节点
	LLNode insertInEnd(int key,LLNode head)
	{
		LLNode ttmp=new LLNode(key);
		LLNode ttmp1=head;
		
		if(ttmp1==null)
			head=ttmp;
		else
		{
			while(ttmp1.next!=null)
					ttmp1=ttmp1.next;
			ttmp1.next=ttmp;
			
		}
		
		return head;
			
	}

    // 索引插入新的节点
	LLNode insertAtPos(int key,int pos,LLNode head)
	{
		LLNode ttmp=new LLNode(key);
		
		if(pos==1)
		{
			ttmp.next=head;
			head=ttmp;
		}
		else
		{
			LLNode ttmp1=head;
			for(int i=1;ttmp1!=null &amp;&amp; i&lt;pos;i++)
				ttmp1=ttmp1.next;
			ttmp.next=ttmp1.next;
			ttmp1.next=ttmp;
		}
		
		return head;
	}
	
	// 删除索引位置的一个节点
	LLNode delete(int pos,LLNode head)
	{
		LLNode ttmp=head;
		if(pos==1)
			head=ttmp.next;
		else
		{
			for(int i=1;ttmp!=null &amp;&amp; i&lt;pos-1;i++)
				ttmp=ttmp.next;
			ttmp.next=ttmp.next.next;
		}
		return head;
	}
	
    // 查看链表长度
	int length(LLNode head)
	{
		LLNode ttmp=head;
		int c=0;
		if(ttmp==null)
			return 0;
		else
		{
		 while(ttmp!=null)
			{	ttmp=ttmp.next;
				c++;
			}
		}
		return c;
	}
	
	
    // 链表翻转
	LLNode reverse(LLNode head)
	{
		LLNode prevLNode=null,curLNode=head,nextLNode=null;
		while(curLNode!=null)
		{
			nextLNode=curLNode.next;
			curLNode.next=prevLNode;
			
			prevLNode=curLNode;
			curLNode=nextLNode;
		}
		
		head=prevLNode;
		return head;
	}
	
	
    // 打印链表
	void display(LLNode head)
	{
		LLNode ttmp=head;
		while(ttmp!=null)
			{System.out.print(ttmp.data+" ");
			 ttmp=ttmp.next;
			}
	}
	
    // 程序入口
	public static void main(String[] args)
	{
		LinkedListDemo l=new LinkedListDemo();
		l.head=null;
		Scanner in=new Scanner(System.in);
		 do
	{
 System.out.println("\n********* MENU *********");
	 System.out.println("\n1.Insert In End");
	 System.out.println("\n2.Insert In Beg");
	 System.out.println("\n3.Insert At A  Particular Pos");
	 System.out.println("\n4.Delete At a Pos");
	 System.out.println("\n5.Length");
	 System.out.println("\n6.Reverse");
	 System.out.println("\n7.Display");
	 System.out.println("\n8.EXIT");
	 System.out.println("\nenter ur choice : ");
	 int n=in.nextInt();
	 switch(n)
		{
        case 1: 
             System.out.println("\nenter the value ");
			 l.head=l.insertInEnd(in.nextInt(),l.head);
			 break;
		 case 2: 
             System.out.println("\nenter the value");
			 l.head=l.insertInBeg(in.nextInt(),l.head);
			 break;
		 case 3: 
             System.out.println("\nenter the value");
			 l.head=l.insertAtPos(in.nextInt(),in.nextInt(),l.head);
			 break;
		 case 4: 
			 l.head=l.delete(in.nextInt(),l.head);
			 break;
		 case 5: 
			 System.out.println(l.length(l.head));
			 break;
		 case 6: 
			 l.head=l.reverse(l.head);
			 break;
		 case 7: 
			 l.display(l.head);
		 	 break;
		 case 8: 
             System.exit(0);
		     break;
		 default: 
             System.out.println("\n Wrong Choice!");
		     break;
		}
	 System.out.println("\n do u want to cont... ");
	}while(in.nextInt()==1);

 }
}





Output:

********* MENU *********

1.Insert In End

2.Insert In Beg

3.Insert At A  Particular Pos

4.Delete At a Pos

5.Length

6.Reverse

7.Display

8.EXIT

enter ur choice :
1

enter the value
23

 do u want to cont...
1

********* MENU *********

1.Insert In End

2.Insert In Beg

3.Insert At A  Particular Pos

4.Delete At a Pos

5.Length

6.Reverse

7.Display

8.EXIT

enter ur choice :
1

enter the value
56

 do u want to cont...
1

********* MENU *********

1.Insert In End

2.Insert In Beg

3.Insert At A  Particular Pos

4.Delete At a Pos

5.Length

6.Reverse

7.Display

8.EXIT

enter ur choice :
2

enter the value
10

 do u want to cont...
1

********* MENU *********

1.Insert In End

2.Insert In Beg

3.Insert At A  Particular Pos

4.Delete At a Pos

5.Length

6.Reverse

7.Display

8.EXIT

enter ur choice :
7
10 23 56
 do u want to cont...
1

********* MENU *********

1.Insert In End

2.Insert In Beg

3.Insert At A  Particular Pos

4.Delete At a Pos

5.Length

6.Reverse

7.Display

8.EXIT

enter ur choice :
3

enter the value
67
2

 do u want to cont...
1

********* MENU *********

1.Insert In End

2.Insert In Beg

3.Insert At A  Particular Pos

4.Delete At a Pos

5.Length

6.Reverse

7.Display

8.EXIT

enter ur choice :
7
10 23 67 56
 do u want to cont...
1

********* MENU *********

1.Insert In End

2.Insert In Beg

3.Insert At A  Particular Pos

4.Delete At a Pos

5.Length

6.Reverse

7.Display

8.EXIT

enter ur choice :
4
2

 do u want to cont...
1

********* MENU *********

1.Insert In End

2.Insert In Beg

3.Insert At A  Particular Pos

4.Delete At a Pos

5.Length

6.Reverse

7.Display

8.EXIT

enter ur choice :
7
10 67 56
 do u want to cont...
1

********* MENU *********

1.Insert In End

2.Insert In Beg

3.Insert At A  Particular Pos

4.Delete At a Pos

5.Length

6.Reverse

7.Display

8.EXIT

enter ur choice :
6

 do u want to cont...
1

********* MENU *********

1.Insert In End

2.Insert In Beg

3.Insert At A  Particular Pos

4.Delete At a Pos

5.Length

6.Reverse

7.Display

8.EXIT

enter ur choice :
7
56 67 10
 do u want to cont...
</code></pre> 
<p></p> 
<h2 id="%E6%A0%88(Stack)" style="margin-left:.0001pt;text-align:justify;">栈(Stack)</h2> 
<h3>定义</h3> 
<p style="margin-left:.0001pt;text-align:justify;">栈只允许在有序的线性资料集合的一端(称为堆栈顶端，top)进行加入数据(push)和移除数据(pop)的运算。因而按照后进先出(LIFO, Last In First Out)的原理运作，堆栈常用一维数组或链表来实现</p> 
<h3 id="%E7%89%B9%E7%82%B9" style="margin-left:.0001pt;text-align:justify;">特点</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1. 使用Java的线性数据结构</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 遵循LIFO : 最后进的元素最先出</p> 
<p style="margin-left:.0001pt;text-align:left;">3. 只有顶部的元素可以被访问</p> 
<p style="margin-left:.0001pt;text-align:left;">4. 插入和删除都是从顶部开始的。例如：一叠盘子、椅子等。</p> 
<p style="margin-left:.0001pt;text-align:left;">5. 4个主要操作 : 所有的操作都在恒定时间内进行，即O(1)。</p> 
<p style="margin-left:.0001pt;text-align:left;">        push(ele) - 用来在顶部插入元素</p> 
<p style="margin-left:.0001pt;text-align:left;">        pop() - 从堆栈中删除顶部的元素</p> 
<p style="margin-left:.0001pt;text-align:left;">        isEmpty() - 如果堆栈是空的，返回true</p> 
<p style="margin-left:.0001pt;text-align:left;">        peek() - 获取堆栈的顶部元素</p> 
<h3>优势</h3> 
<p style="margin-left:.0001pt;text-align:left;">1. 以后进先出的方式维护数据</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 最后一个元素可以随时使用</p> 
<p style="margin-left:.0001pt;text-align:left;">3. 所有的操作都是O(1)的复杂性</p> 
<h3>劣势</h3> 
<p>1. 操作被限制在堆栈的顶部<br> 2. 不太灵活</p> 
<h3>应用场景</h3> 
<p>递归(Recursion)<br> 解析(Parsing)<br> 浏览器(Browser)<br> 编辑器(Editors)</p> 
<h4 id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86(%E4%BD%BF%E7%94%A8%E6%A0%88)">Java代码部分(使用栈)</h4> 
<pre><code class="language-java">import java.util.*;

class Stack
{
   int[] a;
   int top;
   Stack()
   {	
	a=new int[100];
	top=-1;
   }
  
  void push(int x)
  {	
	if(top==a.length-1)
	  System.out.println("overflow");
	else
	 a[++top]=x;
   }
   
   int pop()
   {
     if(top==-1)
		{System.out.println("underflow");
	     return -1;
		}
	 else
	   return(a[top--]);
	}
	
	void display()
	{
		for(int i=0;i&lt;=top;i++)
			System.out.print(a[i]+" ");
		System.out.println();	
	}
	
	boolean isEmpty()
	{
		if(top==-1)
			return true;
		else 
			return false;
	}
	
	int peek()
	{
		if(top==-1)
			return -1;
		return (a[top]);
	}
	
	
}

public class Demo
{
	public static void main(String args[])
	{
		
		Stack s=new Stack();
		Scanner in= new Scanner(System.in);
		
		 do
			{System.out.println("\n******** MENU *******");
			 System.out.println("\n1.PUSH");
			 System.out.println("\n2.POP");
			 System.out.println("\n3.PEEK");
			 System.out.println("\n4 IS EMPTY");
			 System.out.println("\n5.EXIT");
			 System.out.println("\n enter ur choice : ");
			 switch(in.nextInt())
				{
				 case 1: 
					 System.out.println("\nenter the value ");
					 s.push(in.nextInt());
					 break;
				 case 2: 
					System.out.println("\n popped element : "+ s.pop());
					 break;
				 
				case 3: 
					System.out.println("\n top element : "+ s.peek());
					 break;
				 case 4: System.out.println("\n is empty : "+ s.isEmpty());
						 break;
				 case 5: System.exit(0);
						 break;
				 default: System.out.println("\n Wrong Choice!");
						  break;
				}
			 System.out.println("\n do u want to cont... ");
			}while(in.nextInt()==1);

	}
}






Output:

******** MENU *******

1.PUSH

2.POP

3.PEEK

4 IS EMPTY

5.EXIT

 enter ur choice :
1

enter the value
12

 do u want to cont...
1

******** MENU *******

1.PUSH

2.POP

3.PEEK

4 IS EMPTY

5.EXIT

 enter ur choice :
1

enter the value
56

 do u want to cont...
1

******** MENU *******

1.PUSH

2.POP

3.PEEK

4 IS EMPTY

5.EXIT

 enter ur choice :
2

 popped element : 56

 do u want to cont...
1

******** MENU *******

1.PUSH

2.POP

3.PEEK

4 IS EMPTY

5.EXIT

 enter ur choice :
4

 is empty : false

 do u want to cont...
1

******** MENU *******

1.PUSH

2.POP

3.PEEK

4 IS EMPTY

5.EXIT

 enter ur choice :
2

 popped element : 12

 do u want to cont...</code></pre> 
<h4 id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86(%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8)">Java代码部分(使用链表)</h4> 
<pre><code class="language-java">import java.util.*;

class LNode
{
	 int data;
	 LNode next;
	 LNode(int d)
	 {
		data=d;
	 }
	 
}

 class Stack
{
	 LNode push(int d,LNode head){  
		
				LNode tmp1 = new LNode(d);
				
				if(head==null)
				   
					head=tmp1;
				
				else
				{
					tmp1.next=head;
					
					head=tmp1;
				}
				return head;
			 }
			 
			 
	 LNode pop(LNode head){
		   
		    if(head==null)
		        System.out.println("underflow");
		   else
				head=head.next;
			return head;
		 }
	

	void display(LNode head){
		
				System.out.println("\n list is : ");
				if(head==null){
					
					System.out.println("no LNodes");
			
					return;
					}
				 
				LNode tmp=head;

				while(tmp!=null){
						
				System.out.print(tmp.data+" ");
					 
				tmp=tmp.next;
					 
					
				}
	       }

    boolean isEmpty(LNode head)
	{
		if(head==null)
			return true;
		else
			return false;
	}
	
	int peek(LNode head)
	{
		if(head==null)
			return -1;
		return head.data;
	}
	
}


public class Demo{
		
		public static void main(String[] args)
		{
		Stack s=new Stack();
		LNode head=null;
		Scanner in=new Scanner(System.in);
		
		 do
			{System.out.println("\n******** MENU *******");
			 System.out.println("\n1.PUSH");
			 System.out.println("\n2.POP");
			 System.out.println("\n3.PEEK");
			 System.out.println("\n4 IS EMPTY"); 
			 System.out.println("\n5 DISPLAY");
			 System.out.println("\n6.EXIT");
			 System.out.println("\n enter ur choice : ");
			 switch(in.nextInt())
				{
				 case 1: 
					 System.out.println("\nenter the value ");
					 head=s.push(in.nextInt(),head);
					 break;
				 case 2: 
					 head=s.pop(head);
					 break;
				 
				case 3: 
				System.out.println("\n top element : "+ s.peek(head));
					 break;
				 case 4: 
System.out.println("\n is empty : "+ s.isEmpty(head));
						 break;
				 case 5: s.display(head); 
						 break;
				 case 6: System.exit(0);
						 break;
				 default: System.out.println("\n Wrong Choice!");
						  break;
				}
			 System.out.println("\n do u want to cont... ");
			}while(in.nextInt()==1);

	}
}





Output
******** MENU *******

1.PUSH

2.POP

3.PEEK

4 IS EMPTY

5 DISPLAY

6.EXIT

 enter ur choice :
1

enter the value
12

 do u want to cont...
1

******** MENU *******

1.PUSH

2.POP

3.PEEK

4 IS EMPTY

5 DISPLAY

6.EXIT

 enter ur choice :
1

enter the value
56

 do u want to cont...
1

******** MENU *******

1.PUSH

2.POP

3.PEEK

4 IS EMPTY

5 DISPLAY

6.EXIT

 enter ur choice :
5

 list is :
56 12
 do u want to cont...
1

******** MENU *******

1.PUSH

2.POP

3.PEEK

4 IS EMPTY

5 DISPLAY

6.EXIT

 enter ur choice :
3

 top element : 56

 do u want to cont...
1

******** MENU *******

1.PUSH

2.POP

3.PEEK

4 IS EMPTY

5 DISPLAY

6.EXIT

 enter ur choice :
4

 is empty : false

 do u want to cont...
1</code></pre> 
<h2 id="%E9%98%9F%E5%88%97(Queue)" style="margin-left:.0001pt;text-align:justify;">队列(Queue)</h2> 
<h3>定义</h3> 
<p style="margin-left:.0001pt;text-align:left;">队列是先进先出(FIFO, First-In-First-Out)的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端(称为rear)进行插入操作，在前端(称为front)进行删除操作。</p> 
<h3>特点</h3> 
<p style="margin-left:.0001pt;text-align:left;">1. 线性数据结构</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 遵循FIFO : 最先进入的元素最先出</p> 
<p style="margin-left:.0001pt;text-align:left;">3. 插入可以从后端进行。</p> 
<p style="margin-left:.0001pt;text-align:left;">4. 删除可以从前端进行。例如：售票处的排队，公共汽车站。</p> 
<p style="margin-left:.0001pt;text-align:left;">5. 4个主要操作 : 所有操作都在恒定时间内进行，即O(1)。</p> 
<p style="margin-left:.0001pt;text-align:left;">        enqueue(ele) - 用来在顶部插入元素</p> 
<p style="margin-left:.0001pt;text-align:left;">        dequeue() - 从队列中删除顶端的元素 </p> 
<p style="margin-left:.0001pt;text-align:left;">        peekfirst() - 获得队列的第一个元素 </p> 
<p>        peeklast() - 获得队列中的最后一个元素</p> 
<h3>优势</h3> 
<p style="margin-left:.0001pt;text-align:left;">1. 以先进先出的方式维护数据</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 从起点插入和从终点删除需要O(1)时间</p> 
<h3>应用场景</h3> 
<p style="margin-left:.0001pt;text-align:left;">1. 调度(Scheduling)</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 保持播放列表(Maintaining playlist)</p> 
<p style="margin-left:.0001pt;text-align:left;">3. 中断处理(Interrupt handling)</p> 
<h4 id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86(%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84)">Java代码部分(使用数组)</h4> 
<pre><code class="language-java">
import java.util.*;

class Queue{

 int front;
 int rear;
 int[] arr;
 
 Queue()
 {
   front=rear=-1;
   arr=new int[10];
  }
  
  void enqueue(int a)
  {
    if(rear==arr.length-1)
		System.out.println("overflow");
	else
		arr[++rear]=a;
	
	if(front==-1)
		front++;
   }
   
   int dequeue()
   {
     int x=-1;
	 if(front==-1)
		System.out.println("underflow");
	 else
		x=arr[front++];
	 if(rear==0)
	     rear--;
	 return x;
    }
	
	void display()
	{
	  for(int i=front;i&lt;=rear;i++)
		System.out.print(arr[i]+" ");

	 System.out.println();


	}
}

public class QueueDemo{

	public static void main(String[] args)
	{
	  Queue ob=new Queue();
	  ob.enqueue(1);
	  ob.enqueue(2);
	  ob.enqueue(3);
	  ob.enqueue(4);
	  ob.enqueue(5);
	  ob.display();
	  ob.dequeue();
	  ob.display();
	 }
}
	  




Output:


1 2 3 4 5 
2 3 4 5 </code></pre> 
<h4>Java代码部分(使用链表)</h4> 
<pre><code class="language-java">class LNode{
	
	int data;
	LNode next;

	LNode(int d)
	{
		data=d;
	}
}


class Queue{

	LNode enqueue(LNode head,int a)
	{
		LNode tmp=new LNode(a);
		if(head==null)
			head=tmp;
		else
		 { 
			LNode tmp1=head;
			while(tmp1.next!=null)
				tmp1=tmp1.next;
			
			tmp1.next=tmp;
		}
		return head;
	}
	
	
	LNode dequeue(LNode head)
	{
		if(head==null)
		        System.out.println("underflow");
		   else
				head=head.next;
			return head;
	}
	
	void display(LNode head)
	{
		
				System.out.println("\n list is : ");
				if(head==null){
					
					System.out.println("no LNodes");
			
					return;
					}
				 
				LNode tmp=head;

				while(tmp!=null){
						
				System.out.print(tmp.data+" ");
					 
				tmp=tmp.next;
					 
					
				}
	}
	
	}
	
	public class QueueDemoLL{
		
		public static void main(String[] args)
		{
			Queue ob=new Queue();
			LNode head=null;
			
			head=ob.enqueue(head,1);
			head=ob.enqueue(head,2);
			head=ob.enqueue(head,3);
			head=ob.enqueue(head,4);
			head=ob.enqueue(head,5);
			ob.display(head);
			head=ob.dequeue(head);
			ob.display(head);
		}
	}




Output

list is : 
1 2 3 4 5 
list is : 
2 3 4 5 </code></pre> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%A0%91(Binary%20Tree)" style="margin-left:.0001pt;text-align:justify;">二叉树(Binary Tree)</h2> 
<h3>定义</h3> 
<p style="margin-left:.0001pt;text-align:left;">二叉树是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。</p> 
<h3>特点</h3> 
<p style="margin-left:.0001pt;text-align:left;">1. 层次化的数据结构</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 最上面的元素被称为树根(root)</p> 
<p style="margin-left:.0001pt;text-align:left;">3. 每个节点在二叉树中最多可以有两个孩子(child)</p> 
<p style="margin-left:.0001pt;text-align:left;">4. 可以使用索引随机地访问元素。例如：文件系统的层次结构</p> 
<p style="margin-left:.0001pt;text-align:left;">5. 常见的遍历方法。</p> 
<p style="margin-left:.0001pt;text-align:left;">        前序遍历preorder(从树根root开始) : 打印-左孩子-右孩子</p> 
<p style="margin-left:.0001pt;text-align:left;">        后序遍历postorder(root) : 左孩子-右孩子-打印 </p> 
<p style="margin-left:.0001pt;text-align:left;">        中序遍历inorder(root)：左孩子-打印-右孩子</p> 
<h3>优势</h3> 
<p style="margin-left:.0001pt;text-align:left;">1. 可以表示具有某种关系的数据</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 插入和搜索的效率更高</p> 
<h3>劣势</h3> 
<p style="margin-left:.0001pt;text-align:left;">1. 排序很困难</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 不太灵活</p> 
<h3>应用场景</h3> 
<p style="margin-left:.0001pt;text-align:left;">1. 文件系统的层次结构</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 二叉树的多种变化具有广泛的应用。</p> 
<h4>Java代码部分</h4> 
<pre><code class="language-java">class TLNode
{
 int data;
 TLNode left,right;
 
 TLNode(int d)
 {
   data=d;
  }
 }
 
 
public class BinaryTree
{
   static void preorder(TLNode r)
   {
		if(r==null)
		    return;
		
		System.out.print(r.data+" ");
		
		preorder(r.left);
		preorder(r.right);
		
   }
   static void inorder(TLNode r)
   {
		if(r==null)
		    return;
		
		
		inorder(r.left);
		System.out.print(r.data+" ");
		inorder(r.right);
		
   }
   static void postorder(TLNode r)
   {
		if(r==null)
		    return;
		
		
		postorder(r.left);
		postorder(r.right);
		System.out.print(r.data+" ");

   }
     
    public static void main(String[] args)
	{
		TLNode root=new TLNode(1);
		
		root.left=new TLNode(2);
		root.right=new TLNode(3);
		
		root.left.left=new TLNode(4);
		root.left.right=new TLNode(5);
		
		root.right.left=new TLNode(6);
		root.right.right=new TLNode(7);
		preorder(root);
		System.out.println();
		
		inorder(root);
		System.out.println();
		
		postorder(root);
		System.out.println();
		
		
	}
}



	 
Output
	
1 2 4 5 3 6 7 
4 2 5 1 6 3 7 
4 5 2 6 7 3 1 
</code></pre> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91(Binary%20Search%20Tree)" style="margin-left:.0001pt;text-align:justify;">二叉查找树(Binary Search Tree)</h2> 
<h3 style="margin-left:.0001pt;text-align:left;">定义</h3> 
<p style="margin-left:.0001pt;text-align:left;">二叉查找树是指一棵空树或者具有下列性质的二叉树：</p> 
<p style="margin-left:.0001pt;text-align:left;">1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</p> 
<p style="margin-left:.0001pt;text-align:left;">3. 任意节点的左、右子树也分别为二叉查找树；</p> 
<h3>特点</h3> 
<p style="margin-left:.0001pt;text-align:left;">1. 具有额外限制的二进制树</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 限制条件:</p> 
<p style="margin-left:.0001pt;text-align:left;">        左边的子节点必须总是小于根节点</p> 
<p style="margin-left:.0001pt;text-align:left;">        右边的子节点必须总是大于根节点</p> 
<p style="margin-left:.0001pt;text-align:left;">3. 插入、删除、搜索比二进制树的效率要高得多</p> 
<h3>优势</h3> 
<p style="margin-left:.0001pt;text-align:left;">1. 保持元素的顺序</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 可以轻松找到树中的最小和最大节点</p> 
<p style="margin-left:.0001pt;text-align:left;">3. 按顺序排列，遍历可以得到排序的元素</p> 
<h3>劣势</h3> 
<p style="margin-left:.0001pt;text-align:left;">1. 不可能有随机访问</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 排序增加了复杂性</p> 
<h4>Java代码部分</h4> 
<pre><code class="language-java">class TLNode{

	int data;
	TLNode left,right;
	
	TLNode(int d)
	{
		data=d;
	}
 }
 
 public class BST{
 
	TLNode root;
	
	TLNode insert(int d,TLNode root)
	{
	  if(root==null)
	    root=new TLNode(d);
	  
      else if(d&lt;=root.data)
		root.left=insert(d,root.left);
	
	  else
		root.right=insert(d,root.right);
	
	  return root;
	}
	
	TLNode search(int d,TLNode root)
	{
		if(root.data==d)
			return root;
		else if(d&lt;root.data)
			return search(d,root.left);
	    else
			return search(d,root.right);
	}
	
	
	
	void inorder(TLNode r)
   {
		if(r==null)
		    return;
		
		
		inorder(r.left);
		System.out.println(r.data);
		inorder(r.right);
		
   }
   

TLNode delete(TLNode root, int data) 
    { 
        
        if (root == null)  return root; 
 
        if (data &lt; root.data) 
            root.left = delete(root.left, data); 
        else if (data &gt; root.data) 
            root.right = delete(root.right, data); 
  
        else
        { 
            
            if (root.left == null) 
                return root.right; 
            else if (root.right == null) 
                return root.left; 
  
            
            root.data = minValue(root.right); 
  
            root.right = delete(root.right, root.data); 
        } 
  
        return root; 
    } 	
   int minValue(TLNode root) 
    { 
        int minv = root.data; 
        while (root.left != null) 
        { 
            minv = root.left.data; 
            root = root.left; 
        } 
        return minv; 
    } 

   
   public static void main(String[] args)
   {
		BST ob=new BST();
		ob.root=ob.insert(50,ob.root); 
                ob.root=ob.insert(30,ob.root); 
                ob.root=ob.insert(20,ob.root); 
                ob.root=ob.insert(20,ob.root); 
                ob.root=ob.insert(70,ob.root); 
                ob.root=ob.insert(60,ob.root); 
                ob.root=ob.insert(80,ob.root);    
		ob.root=ob.delete(ob.root,50);
		System.out.println("******" +ob.root.data);
		ob.inorder(ob.root);
		
		TLNode find=ob.search(30,ob.root);
		if(find==null)
			System.out.println("not found");
		else
			System.out.println("found : "+find.data);
		
		
	}
}

  Output:
  
******60
20
20
30
60
70
80
found : 30</code></pre> 
<h2 id="%E5%A0%86(Heap)" style="margin-left:.0001pt;text-align:justify;">堆(Heap)</h2> 
<h3>定义</h3> 
<p>堆是一种特别的完全二叉树。若是满足以下特性，即可称为堆：“给定堆中任意节点P和C，若P是C的母节点，那么P的值会小于等于(或大于等于)C的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆(min heap)；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆(max heap)。在堆中最顶端的那一个节点，称作根节点(root node)，根节点本身没有母节点(parent node)。</p> 
<h3>特点</h3> 
<p>1. Arr[0]元素将被视为根。</p> 
<p>2. length(A) - 数组的大小</p> 
<p>3. heapSize(A) - 堆的大小</p> 
<p>4. 一般在处理最小和最大元素时使用</p> 
<p>5. 对于第i个节点 :</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>(i-1)/2</td><td>父节点</td></tr><tr><td>(2*i)+1</td><td>左孩子</td></tr><tr><td>(2*i)+2</td><td>右孩子</td></tr></tbody></table> 
<h3>优势</h3> 
<p>1. 可以有2种类型：最小堆和最大堆<br> 2. 最小堆保留最小的元素，顶部和最大堆保留最大的元素<br> 3. 处理最小或最大元素时为O(1)。</p> 
<h3>劣势</h3> 
<p>1. 不可能有随机访问<br> 2. 只有最小或最大元素可供访问</p> 
<h3>应用场景</h3> 
<p>1. 适用于处理优先权的应用(Suitable for applications dealing with priority)<br> 2. 调度算法(Scheduling algorithm)<br> 3. 缓存(caching)</p> 
<h4 id="Java%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81(%E6%9C%80%E5%A4%A7%E5%A0%86)">Java部分代码(最大堆)</h4> 
<pre><code class="language-java">import java.util.*;


class Heap{

	int heapSize;
	
	void build_max_heap(int[] a)
	{
		heapSize=a.length;
		for(int i=(heapSize/2);i&gt;=0;i--)
			max_heapify(a,i);
		
	}
	
	void max_heapify(int[] a,int i)
	{
		int l=2*i+1;
		int r=2*i+2;
		int largest=i;
		if(l&lt;heapSize &amp;&amp;a[l]&gt;a[largest])
			largest=l;
		if(r&lt;heapSize &amp;&amp;a[r]&gt;a[largest])
			largest=r;
		if(largest!=i)
		{
			int t=a[i];
			a[i]=a[largest];
			a[largest]=t;
		    max_heapify(a,largest);
		}
		
	}
	
	//to delete the max element
	
	int extract_max(int[] a)
	{
		if(heapSize&lt;0)
			System.out.println("underflow");
		int max=a[0];
		a[0]=a[heapSize-1];
		heapSize--;
		max_heapify(a,0);
		return max;
	}
	
	void increase_key(int[] a,int i,int key)
	{
		if(key&lt;a[i])
			System.out.println("error");
		a[i]=key;
		while(i&gt;=0 &amp;&amp; a[(i-1)/2]&lt;a[i])
		{
			int t=a[(i-1)/2];
			a[(i-1)/2]=a[i];
			a[i]=t;
			
			i=(i-1)/2;
		}
	}
	
	void print_heap(int a[])
	{
		for(int i=0;i&lt;heapSize;i++)
		    System.out.println(a[i]+" ");
	}
}
	
public class HeapDemo{
	
	public static void main(String[] args)
	{
		Scanner in=new Scanner(System.in);
		int n=in.nextInt();
		int a[]=new int[n];
		
		System.out.println("enter the elements of array");
		
		for(int i=0;i&lt;n;i++)
		  a[i]=in.nextInt();
	         Heap ob=new Heap();
		
		ob.build_max_heap(a);
		ob.print_heap(a);
		
		
		System.out.println("maximum element is : "+ob.extract_max(a));
		ob.print_heap(a);
		System.out.println("maximum element is : "+ob.extract_max(a));
		ob.increase_key(a,6,800);
		ob.print_heap(a);
		   
	}

}

Output
7
enter the elements of array
50 100 10 1 3 20 5
100
50
20
1
3
10
5
maximum element is : 100
50
5
20
1
3
10
maximum element is : 50
800
5
20
1
3
</code></pre> 
<h2 id="%E6%95%A3%E5%88%97%E8%A1%A8(Hashing)" style="margin-left:.0001pt;text-align:justify;">散列表/哈希表(Hashing)</h2> 
<h3>定义</h3> 
<p style="margin-left:.0001pt;text-align:left;">哈希表是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p> 
<h3>特点</h3> 
<p>1. 使用特殊的哈希函数</p> 
<p>2. 散列函数将一个元素映射到一个地址进行存储</p> 
<p>3. 这提供了恒定的时间访问</p> 
<p>4. 任何哈希函数都无法彻底避免碰撞 : 衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。以下是几个Hash函数常见的方法 :</p> 
<p>直接定址法、数字分析法、除留余数法、分段叠加法、平方取中法、伪随机数法</p> 
<p>5. 常见的解决碰撞的方法 :</p> 
<p>开放定址法、链地址法、再哈希法、建立公共溢出区</p> 
<p>Hash的详解 : <a href="https://developer.aliyun.com/article/772971" rel="nofollow" title="HashMap中hash方法的原理-阿里云开发者社区">HashMap中hash方法的原理-阿里云开发者社区</a></p> 
<h3>优势</h3> 
<p>1. 散列函数有助于在恒定时间内获取元素<br> 2. 是存储元素的有效方法</p> 
<h3>劣势</h3> 
<p>1. 冲突性质的解决办法增加了复杂性</p> 
<h3 id="%E5%B8%B8%E7%94%A8%E7%9A%84Hash%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">常用的Hash数据结构</h3> 
<p>HashMap(数组+链表+链地址)、HashSet</p> 
<h3>应用场景</h3> 
<p>1. 适用于需要恒定时间获取的应用</p> 
<h4 id="Java%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86(%E6%9F%A5%E6%89%BE%E5%94%AF%E4%B8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2)">Java代码部分(查找唯一的字符串)</h4> 
<pre><code class="language-java">import java.util.*;

class HashSetDemo1{

	static boolean isUnique(String s)
	{
		HashSet&lt;Character&gt; set =new HashSet&lt;Character&gt;();
		
		for(int i=0;i&lt;s.length();i++)
		    {
				char c=s.charAt(i);
				if(c==' ')
					continue;
				if(set.add(c)==false)
					return false;
					
			}
			
		return true;
	}
	
	
	public static void main(String[] args)
	{
		String s="helo wqty ";
		boolean ans=isUnique(s);
		if(ans)
			System.out.println("string has unique characters");
		else
			System.out.println("string does not have unique characters");

		
		
	}
}

Output:
string has unique characters</code></pre> 
<h4 id="Java%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81(%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E7%AC%A6)">Java部分代码(计算一个字符串的字符)</h4> 
<pre><code class="language-java">import java.util.*;

class HashMapDemo
{

	static void check(String s)
	{
		HashMap&lt;Character,Integer&gt; map=new HashMap&lt;Character,Integer&gt;();
		for(int i=0;i&lt;s.length();i++)
			{char c=s.charAt(i);
			 if(!map.containsKey(c))
				map.put(c,1);
			 else
				map.put(c,map.get(c)+1);
			}
			
		
		
		Iterator&lt;Character&gt; itr = map.keySet().iterator();
		while (itr.hasNext()) {
			Object x=itr.next();
			System.out.println("count of "+x+" : "+map.get(x));
		}
	}
	
	public static void main(String[] args)
	{
		String s="hello";
		check(s);
	}
}

Output
count of e : 1
count of h : 1
count of l : 2
count of o : 1</code></pre> 
<p>Java部分代码(查找字符串中特定的字符)</p> 
<pre><code class="language-java">import java.util.*; 
class hashTabledemo { 
	public static void main(String[] arg) 
	{ 
		// creating a hash table 
		Hashtable&lt;Integer, String&gt; h = 
					new Hashtable&lt;Integer, String&gt;(); 

		Hashtable&lt;Integer, String&gt; h1 = 
					new Hashtable&lt;Integer, String&gt;(); 

		h.put(3, "Geeks"); 
		h.put(2, "forGeeks"); 
		h.put(1, "isBest"); 

		// create a clone or shallow copy of hash table h 
		h1 = (Hashtable&lt;Integer, String&gt;)h.clone(); 

		// checking clone h1 
		System.out.println("values in clone: " + h1); 

		// clear hash table h 
		h.clear(); 

		// checking hash table h 
		System.out.println("after clearing: " + h); 
				System.out.println("values in clone: " + h1); 


	} 
} 

Output
values in clone: {3=Geeks, 2=forGeeks, 1=isBest}
after clearing: {}
values in clone: {3=Geeks, 2=forGeeks, 1=isBest}</code></pre> 
<h2 id="%E5%9B%BE(Graph)" style="margin-left:.0001pt;text-align:justify;">图(Graph)</h2> 
<h3>定义</h3> 
<p style="margin-left:.0001pt;text-align:left;">图是一种抽象数据类型，用于实现数学中图论的无向图和有向图的概念。</p> 
<p style="margin-left:.0001pt;text-align:left;">图的数据结构包含一个有限(可能是可变的)的集合作为节点集合，以及一个无序对(对应无向图)或有序对(对应有向图)的集合作为边(有向图中也称作弧)的集合。节点可以是图结构的一部分，也可以是用整数下标或引用表示的外部实体。</p> 
<p style="margin-left:.0001pt;text-align:left;">图的数据结构还可能包含和每条边相关联的数值(edge value)，例如一个标号或一个数值(即权重，weight；表示花费、容量、长度等)。</p> 
<h3>特点</h3> 
<p>1. 基本上，它是一组边(group of edges)和节点(vertices)。<br> 2. 图形表示法 : G(V, E); 其中V(G)代表一组顶点，E(G)代表一组边。<br> 3. 图可以是有向或无向的<br> 4. 图可以是连接的，也可以是不连接的</p> 
<h3>优势</h3> 
<p>1. 寻找连通性<br> 2. 最短路径<br> 3. 从一个点到另一个点的最小成本<br> 4. 最小生成树</p> 
<h3>劣势</h3> 
<p>1. 存储图（邻接列表和邻接矩阵）可能会使问题更复杂。</p> 
<h3>应用场景</h3> 
<p>1. 适用于电路网络<br> 2. 适用于像Facebook、LinkedIn等应用<br> 3. 医学科学</p> 
<h4>Java代码部分</h4> 
<pre><code class="language-java">import java.util.*;

class Graph
{
	int v;
	LinkedList&lt;Integer&gt; adj[];

	Graph(int v)
	{
		this.v=v;
		adj=new LinkedList[v];
		for(int i=0;i&lt;v;i++)
			adj[i]=new LinkedList&lt;Integer&gt;();
	}


	void addEdge(int u,int v)
	{
		adj[u].add(v);
	}
	
	void BFS(int s)
	{
		boolean[] visited=new boolean[v];
		LinkedList&lt;Integer&gt; q=new LinkedList&lt;Integer&gt;();
		q.add(s);
		visited[s]=true;

		while(!q.isEmpty())
		{
			int x=q.poll();
			System.out.print(x+" ");

			Iterator&lt;Integer&gt; itr=adj[x].listIterator();
			while(itr.hasNext())
			{
			  int p=itr.next();
			  if(visited[p]==false)
				{
					visited[p]=true;
					q.add(p);
				}
			}
		}
	}
	
	
	void DFSUtil(int s,boolean[] visited)
	{
		visited[s]=true;
		System.out.println(s);

		Iterator&lt;Integer&gt; itr=adj[s].listIterator();
		while(itr.hasNext())
		{
			int x=itr.next();
			if(visited[x]==false)
			{                                                        
				//visited[x]=true;

				DFSUtil(x,visited);
			} 
		}
	}
	
	
	void DFS(int s){
		boolean visited[]=new boolean[v];
		DFSUtil(s,visited);
	}

	public static void main(String[] args)
		{
			Graph g=new Graph(4);
			g.addEdge(0,1);
			g.addEdge(0,2);
			g.addEdge(1,2);
			g.addEdge(2,0);
			g.addEdge(2,3);
			g.addEdge(3,3);
			
			g.BFS(2);
			g.DFS(2);

		}
}

Output:
2 0 3 1 2
0
1
3</code></pre> 
<p>参考文章 :</p> 
<p>1. <a href="https://www.mygreatlearning.com/blog/data-structures-using-java/" rel="nofollow" title="Data Structures in Java | Beginners Guide |2023 - Great Learning">Data Structures in Java | Beginners Guide |2023 - Great Learning</a></p> 
<p>2. <a href="https://zh.wikipedia.org/zh-my/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow" title="wikipedia-数据结构">wikipedia-数据结构</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51ac295547f8f3e80aedd9e88134ad17/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用python写抢红包程序的具体代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0dee0b9c81028a4cf683fa79827d57da/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大海捞针 Skia(C&#43;&#43;) 第 3 期：绘制文本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>