<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软件工程（小小总结） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软件工程（小小总结）" />
<meta property="og:description" content="软件工程的概念与发展 软件工程概念的提出与发展 一、软件危机 1、软件开发的速度
2、软件制品的质量
3、软件开发成本
二、软件工程 应用计算机科学理论和技术以及工程原则和方法，按预算和进度实现满足用户要求的软件产品的工程，或以此为研究对象的学科。
三、软件工程的发展 1、20世纪60一80年代初
开发模型、开发方法、支持工具
2、20世纪80年代末一今
软件复用技术、软件生产管理
一、软件开发的本质 1、软件开发的目标 映射将问题域中的概念映射为运营平台层面上的概念 2、软件开发的本质 不同抽象层术语之间的“映射”，以及不同拍象层处理逻辑之间的“映射”。
如何实现这样的映射? 技术问题
如何管理这样的映射? 过程途径
问题建模
3、模型的概念 模型是一个抽象。模型是在特定意图下所确定的角度和抽象层次上对物理系统的描述，通常包含对该系统边界的描述、对系统内各模型元素以及它们之间关系的语义描述
4、模型的类别 概念模型：描述软件是什么软件模型：实现概念模型的软件解决方案包括设计模型、实现模型和部署模型 eg:
在软件开发领域中，“描述了系统是什么”的系统模型被称为：概念模型
本体考查对模型及模型分类的理解和掌握
(1)概念模型：描述软件是什么
2)软件模型：实现概念模型的软件解决方案。包括设计模型、实现模型和部署模型
小结 软件危机的出现，导致了软件工程的引入软件开发的本质，实现问题空间的概念和处理逻辑到解空间的概念和处理逻辑之间的较则。系统建模是指运用所掌握的知识，通过抽象，给出系统的一个结构。模型是一个抽象在软件开发领域，模型有两大类：概念模型 和软件模型。 二、需求获取 温伯格名言:“明白自己在做什么”
杰拉尔德·温伯格Gerald M Weinberg)是著名的软件和系统思想家，美国计算机名人堂代表人物。这个名人堂至今只有20名成员。为中国读者所熟悉的比尔·盖茨和迈克尔·戴尔等也是在他之后方才获得这一计算机界至高无上的殊荣
1、需求与需求获取 1）需求的定义 一个需求是有关一个“要予构造”的陈述，描述了待开发产品 系统功能能力、性能参数或其它性质。
2）需求的基本性质 必要的无歧义的可测的可跟踪的可测量的 3）需求的分类 功能需求，是整个需求的主体非功能需求：性能需求、外部接口需求、设计约束和质量属性需求 !能够区分哪些是功能需求，哪些是性能 需求
功能需求性能需求接口需求设计约束 7类接口: 用户接口，硬件接口，软件接口，通信接口，内存约束，运行，地点需求
质量属性 eg：
分析下列哪些是功能需来?
功能：系统产生月销售报表功能：根据销售金额计算销售税性能：系统应在3秒内计算出销售税设计约束：系统必须使用JAVA语言编写性能：系统至少支持1000个并发访问接口：系统支持TCP IP协议 4）需求发现技术 1、自悟
2、交谈
3、观察
4、小组会
5、提炼
2、需求规约 (SRS) 1）需求规约的定义 *** 是一个软件/产品 /系统所有需求陈述的正式文档，它表达了一个软件/产品 /系统的概念模型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/39de7c25b5fd7df2528f9447c3b2f844/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-16T22:45:00+08:00" />
<meta property="article:modified_time" content="2023-10-16T22:45:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软件工程（小小总结）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>软件工程的概念与发展</h2> 
<h3><a id="_1"></a>软件工程概念的提出与发展</h3> 
<h4><a id="_2"></a>一、软件危机</h4> 
<p>1、软件开发的速度<br> 2、软件制品的质量<br> 3、软件开发成本</p> 
<h4><a id="_6"></a>二、软件工程</h4> 
<p>应用计算机科学理论和技术以及工程原则和方法，按预算和进度实现满足用户要求的软件产品的工程，或以此为研究对象的学科。</p> 
<h4><a id="_8"></a>三、软件工程的发展</h4> 
<p>1、20世纪60一80年代初</p> 
<blockquote> 
 <p>开发模型、开发方法、支持工具</p> 
</blockquote> 
<p>2、20世纪80年代末一今</p> 
<blockquote> 
 <p>软件复用技术、软件生产管理</p> 
</blockquote> 
<h2><a id="_15"></a>一、软件开发的本质</h2> 
<h3><a id="1_16"></a>1、软件开发的目标</h3> 
<ol><li>映射</li><li>将问题域中的概念映射为运营平台层面上的概念</li></ol> 
<p><img src="https://images2.imgbox.com/c3/48/T2OFa9dl_o.jpg" alt=""></p> 
<h3><a id="2_22"></a>2、软件开发的本质</h3> 
<p>不同抽象层术语之间的“映射”，以及不同拍象层处理逻辑之间的“映射”。</p> 
<ul><li>如何实现这样的映射?</li></ul> 
<blockquote> 
 <p>技术问题</p> 
</blockquote> 
<ul><li>如何管理这样的映射?</li></ul> 
<blockquote> 
 <p>过程途径<br> 问题建模</p> 
</blockquote> 
<h3><a id="3_32"></a>3、模型的概念</h3> 
<p>模型是一个抽象。模型是在特定意图下所确定的角度和抽象层次上对物理系统的描述，通常包含对该系统边界的描述、对系统内各模型元素以及它们之间关系的语义描述</p> 
<h3><a id="4_34"></a>4、模型的类别</h3> 
<ol><li>概念模型：描述软件是什么</li><li>软件模型：实现概念模型的软件解决方案包括设计模型、实现模型和部署模型</li></ol> 
<blockquote> 
 <p>eg:<br> 在软件开发领域中，“描述了系统是什么”的系统模型被称为：概念模型<br> 本体考查对模型及模型分类的理解和掌握<br> (1)概念模型：描述软件是什么<br> 2)软件模型：实现概念模型的软件解决方案。包括设计模型、实现模型和部署模型</p> 
</blockquote> 
<h3><a id="_44"></a>小结</h3> 
<ol><li>软件危机的出现，导致了软件工程的引入</li><li>软件开发的本质，实现问题空间的概念和处理逻辑到解空间的概念和处理逻辑之间的较则。</li><li>系统建模是指运用所掌握的知识，通过抽象，给出系统的一个结构。</li><li>模型是一个抽象</li><li>在软件开发领域，模型有两大类：概念模型 和软件模型。</li></ol> 
<h2><a id="_51"></a>二、需求获取</h2> 
<blockquote> 
 <p>温伯格名言:“明白自己在做什么”<br> 杰拉尔德·温伯格Gerald M Weinberg)是著名的软件和系统思想家，美国计算机名人堂代表人物。这个名人堂至今只有20名成员。为中国读者所熟悉的比尔·盖茨和迈克尔·戴尔等也是在他之后方才获得这一计算机界至高无上的殊荣</p> 
</blockquote> 
<h3><a id="1_56"></a>1、需求与需求获取</h3> 
<h4><a id="1_57"></a>1）需求的定义</h4> 
<p>一个需求是有关一个“要予构造”的陈述，描述了待开发产品 系统功能能力、性能参数或其它性质。</p> 
<h4><a id="2_59"></a>2）需求的基本性质</h4> 
<ol><li>必要的</li><li>无歧义的</li><li>可测的</li><li>可跟踪的</li><li>可测量的</li></ol> 
<h4><a id="3_66"></a>3）需求的分类</h4> 
<blockquote> 
 <ol><li>功能需求，是整个需求的主体</li><li>非功能需求：性能需求、外部接口需求、设计约束和质量属性需求</li></ol> 
</blockquote> 
<blockquote> 
 <p>!能够区分哪些是功能需求，哪些是性能 需求</p> 
</blockquote> 
<ol><li>功能需求</li><li>性能需求</li><li>接口需求</li><li>设计约束</li></ol> 
<blockquote> 
 <p>7类接口: 用户接口，硬件接口，软件接口，通信接口，内存约束，运行，地点需求</p> 
</blockquote> 
<ol start="5"><li>质量属性</li></ol> 
<blockquote> 
 <p>eg：<br> 分析下列哪些是功能需来?</p> 
 <ul><li>功能：系统产生月销售报表</li><li>功能：根据销售金额计算销售税</li><li>性能：系统应在3秒内计算出销售税</li><li>设计约束：系统必须使用JAVA语言编写</li><li>性能：系统至少支持1000个并发访问</li><li>接口：系统支持TCP IP协议</li></ul> 
</blockquote> 
<h4><a id="4_88"></a>4）需求发现技术</h4> 
<p>1、自悟<br> 2、交谈<br> 3、观察<br> 4、小组会<br> 5、提炼</p> 
<h3><a id="2_SRS_94"></a>2、需求规约 (SRS)</h3> 
<h4><a id="1__95"></a>1）需求规约的定义 ***</h4> 
<p>是一个软件/产品 /系统所有需求陈述的正式文档，它表达了一个软件/产品 /系统的概念模型</p> 
<h4><a id="2_97"></a>2）需求规约的基本性质</h4> 
<p>1、重要性和稳定性程度：对需求进行分级<br> 2、可修改的<br> 3、完整的：没有被遗漏的需求<br> 4、一致的：不存在互斥的需求</p> 
<h4><a id="3__102"></a>3）需求规约的格式 ***</h4> 
<p>IEEE标准830-1998(IEEE 1998)描述的需求规格说明书模板。<br> 1、引言</p> 
<blockquote> 
 <p>目的、范围、定义、缩略语、参考文献、概述</p> 
</blockquote> 
<p>2、总体描述</p> 
<blockquote> 
 <p>产品描述、产品功能、用户特性、约束、假设和依赖</p> 
</blockquote> 
<p>3、特定需求：是文档的技术核心<br> 4、附录<br> 5、索引</p> 
<h4><a id="4_113"></a>4）需求规约的表达</h4> 
<p>表达需求的语言</p> 
<ol><li>非形式化的需求规约</li><li>半形式化的需求规约</li><li>形式化的需求规约</li></ol> 
<h4><a id="5_119"></a>5）需求规约的作用</h4> 
<p>1、需求规约是软件开发组织和用户之间一份是产品功能及其环境的体现事实上的技术合同书，<br> 2、需求规约是一个管理控制点<br> 3、对于产品 /系统的而设计，需求规约是一个正式的、受控的起始点<br> 4、需求规约是创建产品验收计划和用户指南的基础</p> 
<h3><a id="eg_124"></a>eg:</h3> 
<blockquote> 
 <p>1、根据软件需求分类，下列选项中不属于设计约束的是C.质量属性<br> A. 并发操作B.握手协议C.质量属性D.硬件限制<br> 2、什么是需求规约? 请简述需求规约的作用。<br> 需求规约是一个软件/产品 /系统所有需求陈述的正式文档，它表达了一个软件 /产品 /系统的概念模型<br> 需求规约的作用包括:<br> (1)需求规约是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现。<br> (2) 需求规约是一个管理控制点。<br> (3) 对于产品/系统的而设计，需求规约是一个正式的、受控的起始点。<br> (4) 需求规约是创建产品验收计划和用户指南的基础</p> 
</blockquote> 
<h3><a id="_135"></a>小结</h3> 
<ol><li>正确定义问题，是解决问题的基础</li><li>需求获取是软件开发的基础</li><li>需求的类型主要有功能性和非功能性需求两大类:非功能性需求包括:性能需求、接口需求、设计约束</li><li>质量要求。</li><li>需求规约将上述需求用标准文档表达出来</li><li>需求规约的作用可以概括为4个方面</li></ol> 
<h2><a id="_143"></a>三、结构化方法</h2> 
<p>结构化方法作为一种“思想”工具，可以用于定义需求，建立待建系统的功能模型；可用于定义满足需求的结构，给出一种特定的软件解决方案</p> 
<h3><a id="1__146"></a>1、 结构化需求分析</h3> 
<ol><li>DFD图</li><li>数据字典</li><li>决策树、判定表</li></ol> 
<blockquote> 
 <p>请分析字处理程序的各种需求<br> “用户能有效地纠正文档中的拼写错误。–&gt;业务需求<br> “找出文档中的拼写错误并通过一个提供的替换项列表来供选择替换拼错的词”–&gt;用户需求<br> “找出拼写错误的词并高亮度显示: 显示提供替换词的对话框:实现整个文档范围的替换。"–&gt;用户需求</p> 
</blockquote> 
<h5><a id="_156"></a>需求分析面临的挑战</h5> 
<ul><li>问题空间理解</li><li>人与人之间的通信，“有效沟通</li><li>需求的变化性</li></ul> 
<h5><a id="_161"></a>需求技术的基本特征</h5> 
<ul><li>提供方便通信的机制</li><li>鼓励需求分析人员使用问题空间的术语思考问编写文档</li><li>提供定义系统边界的方法</li><li>提供支持抽象的基本机制</li><li>为需求分析人员提供多种可供选择的方案提供特定的技术，适应需求的变化</li></ul> 
<h4><a id="1_168"></a>1)需求分析中的基本术语</h4> 
<ol><li>数据：客观事物的一种表示</li><li>信息：具有特定语义的数据</li><li>数据是信息的载体</li><li>数据流:数据的流动</li><li>加工：数据变换单元</li><li>数据存储</li><li>数据源和数据潭</li></ol> 
<h5><a id="_177"></a>四个数据要素</h5> 
<p><img src="https://images2.imgbox.com/57/98/rEB0NdUo_o.jpg" alt=""></p> 
<h4><a id="2_179"></a>2）系统功能模型表示方法</h4> 
<ol><li>数据流图(DFD图）</li></ol> 
<blockquote> 
 <p>一种表示数据变换的图形化工具</p> 
</blockquote> 
<ol start="2"><li>数据流程图的元素</li></ol> 
<blockquote> 
 <p>数据源 数据潭，数据流，数据加工，数据 存储</p> 
</blockquote> 
<h4><a id="3_187"></a>3）建模过程</h4> 
<p>1、自顶向下、逐步求精<br> 2、建立系统环境图<br> 3、0层图: 从0层图开始对流程图中的要素编号<br> 4、1层图<br> …</p> 
<h5><a id="_193"></a>数据流图的绘制过程</h5> 
<p>0层图</p> 
<blockquote> 
 <p>要对处理编号:1、2、3…</p> 
</blockquote> 
<p>1层图</p> 
<blockquote> 
 <p>编号规则:1.1,1.2, 2.1,…</p> 
</blockquote> 
<h4><a id="2_200"></a>建模过程2-数据字典</h4> 
<ol><li>定义数据流程图中所有数据流和数据存储的数据结构</li><li>顺序结构：+</li><li>选择结构：|</li><li>重复结构：{ }</li><li>子界：m…n</li></ol> 
<h4><a id="3_207"></a>建模过程3-加工的描述</h4> 
<h5><a id="1_208"></a>(1)判定表</h5> 
<p>判断表(Decision Table)也称为决策表，是一个二维表，它说明了每一种条件组合所产生的结果<br> <img src="https://images2.imgbox.com/23/a1/p3j3Wfzo_o.png" alt="image.png"></p> 
<h5><a id="2_211"></a>(2)判定树</h5> 
<p>判断树 (Decision Tree)也称为决策树，是用来描述在一组不同的条件下，决策的行动是根据不同条件及其取值来选择的处理过程。业务规则的描述通常可以使用判断树这一过程描述工具。<br> <img src="https://images2.imgbox.com/1a/1c/o9IwEBZd_o.png" alt="image.png"></p> 
<h5><a id="3_214"></a>(3)结构化语言</h5> 
<p>若逻辑关系比较简单，可以用结构化自然语言来描述</p> 
<blockquote> 
 <p>如果应发工资低于4500，则无需缴税，否则需要交纳个人收入所得税:<br> IF立发工资&lt;4500<br> 无需缴税<br> ELSE<br> 交纳个人收入所得税</p> 
</blockquote> 
<h4><a id="4_222"></a>4)应用中注意的问题</h4> 
<h5><a id="1_223"></a>1、模型平衡问题</h5> 
<ul><li>DFD图与数据字典的一致</li><li>底层加工的处理逻辑描述，与数据字典一致</li></ul> 
<h5><a id="2_227"></a>2、信息的复杂性控制问题</h5> 
<ul><li>上层数据流可以打包</li><li>下层模块个数:7 ± 2</li><li>每个加工的数据流不能太多:增加层次</li></ul> 
<h4><a id="5_232"></a>5)需求验证</h4> 
<h5><a id="1_233"></a>1、验证:必要性、无歧义性、可测性、可跟踪性、可测量性</h5> 
<h5><a id="2_234"></a>2、需求中发现的错误类型</h5> 
<ul><li>不正确的事实:40%</li><li>遗漏: 31%</li><li>不一致，13%</li><li>歧义性: 5%</li><li>错放: 2%</li><li>其它:9%</li></ul> 
<h5><a id="_242"></a>发现错误的方法</h5> 
<ul><li>审查:65%</li><li>单元测试: 10%</li><li>评估: 10%</li><li>集成: 5%</li></ul> 
<h3><a id="2_248"></a>2、结构化设计</h3> 
<blockquote> 
 <p>总体设计<br> 详细设计</p> 
</blockquote> 
<p>结构化设计的任务<br> 1、定义满足需求所需要的结构<br> 2、确定“怎么做”的问题<br> 3、划分为:</p> 
<ul><li>总体设计: 以系统为对象</li><li>详细设计:以模块为对象</li></ul> 
<h4><a id="1_259"></a>1）总体设计</h4> 
<h5><a id="1_260"></a>1、总体设计的任务:</h5> 
<p>把系统的功能需求分配到一个特定的软件系统结构钟</p> 
<h5><a id="2_262"></a>2、引入了两个概念:</h5> 
<p>模块：软件中具有特定标识的独立成分.<br> 模块调用：模块之间的一种使用关系</p> 
<blockquote> 
 <h6><a id="_265"></a>如何表达模块和模块调用</h6> 
 <p>1、Yourdon提出的模块结构图<br> 2、层次图<br> 3、美国IBM公司提出的HIPO图<br> H: 层次图<br> IP0: 输入 处理 输出图</p> 
</blockquote> 
<h5><a id="_272"></a>模块结构图</h5> 
<p><img src="https://images2.imgbox.com/4a/0f/ijNJ98Ry_o.jpg" alt=""><br> <img src="https://images2.imgbox.com/72/11/rN9sF4Rq_o.png" alt="image.png"></p> 
<h5><a id="_275"></a>层次图</h5> 
<p><img src="https://images2.imgbox.com/b3/d9/DsFtL5iT_o.png" alt="image.png"></p> 
<h5><a id="HIPO_277"></a>HIPO图</h5> 
<p>1、层次图+IPO图<br> 2、每一个模块都有编号<br> <img src="https://images2.imgbox.com/c7/7c/N8XOOuIa_o.png" alt="image.png"></p> 
<h6><a id="1_281"></a>1、总体设计的步骤</h6> 
<p>将DFD图映射为设计层面的模块及模块调用。<br> (1)将DFD图转换为初始的模块结构图<br> (2)基于“高内聚、低耦合”的软件设计原理通过模块化，将初始的模块结构图转化为最终的模块结构图</p> 
<h6><a id="2_285"></a>2、两种映射方法</h6> 
<h6><a id="1__286"></a>(1) 变换设计</h6> 
<p>基于变换的数据流程图是一个线性的顺序结构，由输入、输出和变换中心三部分组成。</p> 
<blockquote> 
 <p>变换型数据流程图是一个线性的顺序结构由输入臂、输出臂和变换中心三部分组成。其中变换中心使系统数据发生本质的变化输入臂将物理输入变换成逻辑输入，而输出臂则将逻辑输出变换成物理输出</p> 
</blockquote> 
<p>如果待分解的模块是一个数据凝聚的模块称该模块为以转换为中心的模块。可以把它分解为输入、处理、输出三大模块。<br> <img src="https://images2.imgbox.com/87/4c/kBRDtGgn_o.png" alt="image.png"></p> 
<h6><a id="2_292"></a>(2)事务设计</h6> 
<p>基于事务的数据流程图中有一个事务处理中心，它将输入分为许多相互平行的加工路径，然后根据输入的属性，选择某一加工路径。</p> 
<blockquote> 
 <p>如果模块为逻辑凝聚的模块，可以将它分解为一个检查业务类型的模块和一个调度模块，根据不同的业务类型，调度模块调用不同的下层模块</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/16/59/8q7j7Rjc_o.png" alt="image.png"></p> 
<h6><a id="3_297"></a>3、模块化及其启发式规则</h6> 
<p>(1) 模块<br> 执行一个特殊任务的一个过程以及相关的数据结构。模块通常由两部分组成:模块接口和模块体<br> (2)模块化的两个问题</p> 
<ul><li>如何将系统分解成软件模块</li></ul> 
<blockquote> 
 <p>“分而治之”和“抽象<br> 自顶向下，逐步求精<br> 形成模块层次结构</p> 
</blockquote> 
<ul><li>如何设计模块</li></ul> 
<h6><a id="4_308"></a>4、模块化</h6> 
<p>把一个待开发的软件分解成若干个简单的、具有高内聚低耦合的模块，这一过程称为模块化</p> 
<h6><a id="1__310"></a>(1) 模块耦合</h6> 
<p>耦合(coupling)是对两个模块之间相互依赖程度的一种度量。模块间的依赖程度越大，则其耦合程度也就越大;反之，模块间的依赖程度越小，则其耦合程度也就越小。</p> 
<blockquote> 
 <p>模块间耦合类型</p> 
 <ul><li>内容耦合:一个模块直接修改或操作另一模块数据</li><li>公共耦合: 两个模块共同引用一个全局数据项</li><li>控制耦合:一个模块向另一模块传递控制信号</li><li>标记耦合:一个模块向两个模块传递一个公共参数</li><li>数据耦合: 模块之间通过参数来传递数据</li></ul> 
</blockquote> 
<h6><a id="2__319"></a>(2) 模块内聚</h6> 
<p>是指一个模块内部个成分之间相互关联程度的度部。也就是说，内聚是对模块内各处理动作组合强度的一种度量。很显然，一个模块的内聚越大越好</p> 
<blockquote> 
 <p>内聚的类型</p> 
 <ul><li>偶然内聚:模块的各成分没有任何关系</li><li>逻辑内聚:逻辑上相关的 处理放在一起</li><li>时间内聚:模块内的功能在同一时间完成</li><li>过程内聚:模块内的处理以特定的次序执行</li><li>通信内聚:操作同一数据集</li><li>顺序内聚:一个成分的输出作为另一成分的输 入</li><li>功能内聚:模块的所有成分完成单一的功能</li></ul> 
</blockquote> 
<h6><a id="3_330"></a>(3)启发式规则</h6> 
<p>“高内聚、低耦合</p> 
<ol><li>改进软件结构，提高软件独立性。模块分解</li><li>模块规模适中</li><li>力求深度、宽度、扇出、扇入适中。</li></ol> 
<blockquote> 
 <ul><li>深度:表示其控制的层数。</li><li>宽度: 同一层次上模块总数的最大值。</li><li>扇出:一个模块直接控制的下级模块的数目。</li><li>扇入: 有多少个上级模块直接调用它</li></ul> 
</blockquote> 
<ol start="4"><li>尽量使模块的作用域在其控制域内</li><li>尽力降低模块接口的复杂度</li></ol> 
<blockquote> 
 <ul><li>模块的控制域:这个模块本身以及所有直接或间接从属它的模块的集合</li><li>模块的作用域:受该模块内一个判断所影响的所有模块的集合</li></ul> 
</blockquote> 
<ol start="6"><li>力求模块功能可以预测</li></ol> 
<h4><a id="2_347"></a>2）详细设计</h4> 
<p>具体描述模块结构图中的每一模块，即给出实现模块功能的实施机制，包括一组例程和数据结构。<br> 详细设计的目标：将总体设计阶段产生的系统高层结构映射为以相关术语表达的低层结构，也是系统的最终结构</p> 
<h5><a id="_350"></a>结构化程序设计方法</h5> 
<p>是一种基于结构的编程方法，即采用顺序结构、选择结构和重复结构进行编程，其中每一结构只允许一个入口和一个出口。<br> 结构化程序设计的本质是：使程序的控制流程线性化，实现程序动态执行顺序符合静态书写的结构，提高程序的可读性</p> 
<h6><a id="1s__353"></a>（1s) 顺序结构</h6> 
<p><img src="https://images2.imgbox.com/68/dc/uHUeRkbg_o.png" alt="image.png"></p> 
<h6><a id="2_355"></a>（2）选择结构</h6> 
<p><img src="https://images2.imgbox.com/9f/11/JspfGfAY_o.png" alt="image.png"></p> 
<h6><a id="3_357"></a>（3）多分支结构</h6> 
<p><img src="https://images2.imgbox.com/20/60/GDXLCbsz_o.png" alt="image.png"></p> 
<h6><a id="4_359"></a>（4）循环结构</h6> 
<p><img src="https://images2.imgbox.com/e9/cd/d0ZBHmbj_o.png" alt="image.png"></p> 
<h5><a id="_361"></a>详细设计工具</h5> 
<h6><a id="1__362"></a>(1) 程序流程图</h6> 
<p>程序流程图：程序流程图又称为程序框图它是历史最悠久使用最广泛的描述过程设计的方法，然而它也是用得最混乱的一种方法。</p> 
<h6><a id="2NS_364"></a>(2)盒图(N-S图)</h6> 
<p>出于要有一种不允许违背结构程序设计精神的图形工具的考虑，Nassi和Shneiderman提出了盒图，又称为N-S图<br> 盒图<br> <img src="https://images2.imgbox.com/a2/4c/Qp9i8nl3_o.png" alt="image.png"></p> 
<h6><a id="3PAD_368"></a>(3)PAD图</h6> 
<p>PAD是问题分析图(Problem AnalysisDiagram)的英文缩写，自1973年由日本日立公司发明以后，已得到一定程度的推广。它用二维树形结构的图来表示程序的控制流，将这种图翻译成程序代码比较容易。下图给出PAD图的基本符号<br> <img src="https://images2.imgbox.com/74/29/CxLjXW63_o.png" alt="image.png"></p> 
<h6><a id="4PDL_371"></a>(4)类程序设计语言PDL</h6> 
<p>PDL也称为伪码，它是用正文形式表示数据和处理过程的设计工具。<br> PDL具有严格的关键字外部语法，用于定义控制结构和数据结构:<br> 一般说来PDL是一种“混杂”语言，它使用一种语言(通常是某种自然语言)的词汇，同时却使用另一种语言(某种结构化的程序设计语言) 的语法</p> 
<h4><a id="_375"></a>设计规约</h4> 
<p>完整准确地描述满足需求规约所要求的所有功能模块，以及伴随功能模块而出现的非功能机制设计规约包括概要设计规约和详细设计规约。</p> 
<h5><a id="1_377"></a>(1)概要设计规约</h5> 
<ol><li>指明高层软件体系结构</li><li>系统环境</li><li>软件模块的结构</li><li>模块描述</li><li>文件结构和全局数据文件的逻辑结构</li><li>测试需求</li></ol> 
<h5><a id="2__385"></a>(2) 详细设计规约</h5> 
<p>详细设计规约主要作为软件设计人员与程序员之间交流的媒体。</p> 
<ol><li>各处理过程的算法</li><li>算法所涉及的全部数据结构的描述</li></ol> 
<h3><a id="_390"></a>小结</h3> 
<ol><li>本章详细介绍了结构化方法，包括结构化分析和结构化设计:</li><li>结构化分析采用“自顶向下、逐步求精”的思想建立系统的概念模型-数据流图:</li><li>结构化设计采用模块化的思想，建立了系统的模块层次结构(控制结构图) :</li><li>模块设计的原则是高内聚、低耦合</li><li>本章的重点是数据流图的绘制，</li></ol> 
<h2><a id="UML_397"></a>四、面向对象方法-UML（统一建模语言）</h2> 
<h3><a id="_398"></a>介绍</h3> 
<p>面向对象技术的发展中，一个重要的里程碑是UML。UML是一种可视化的语言，可用于规约系统制品、构造系统的制品、建立系统制品的文档，可以作为软件需求规约、设计和实现的工具。UML给出了方法学中不同抽象层次术语以及模型表达工具，或者说UML给出规约软件系统/产品的术语和表达格式。</p> 
<h4><a id="UML_400"></a>UML在方法学中不同抽象层次</h4> 
<p><img src="https://images2.imgbox.com/49/0b/mYB7kxcs_o.png" alt="image.png"></p> 
<h4><a id="UML8_402"></a>UML的8大术语</h4> 
<ol><li>类和对象</li><li>接口</li><li>协作</li><li>用况</li><li>主动类</li><li>构件</li><li>制品</li><li>节点</li></ol> 
<h4><a id="_412"></a>描述关系的术语</h4> 
<ol><li>关联</li><li>泛化</li><li>实现</li><li>依赖</li></ol> 
<h4><a id="_418"></a>知识结构</h4> 
<ol><li>UML提供哪些术语，用于抽象表达客观世界中的各的事物</li></ol> 
<blockquote> 
 <ul><li>UML提供哪些术语，用于抽象表达客观世界中的各式的事物之间的关系</li><li>UML提供哪些术话，用于抽象表达客观世界中各种各样的模型</li><li>掌握各种术语</li><li>掌握表达模型的用况图、类图、顺序图、状态图</li></ul> 
</blockquote> 
<h4><a id="_426"></a>面向对象建模过程的步骤</h4> 
<p>1、需求获取<br> 建立用况(use case)模型和用况场景<br> 2、需求分析</p> 
<blockquote> 
 <p>建立活动图和状态图<br> 类图(建立域模型)<br> 顺序图(实现用况</p> 
</blockquote> 
<p>3、编写需求规格说明书<br> 4、需求验证</p> 
<h3><a id="1UML_436"></a>1、UML术语表</h3> 
<ol><li>表达客观事物的术语</li><li>表达关系的术语</li><li>表达组合关系的术语包</li></ol> 
<h4><a id="1_441"></a>1）表达客观事物的术语</h4> 
<h5><a id="_object__442"></a>对象 (object )</h5> 
<p>对象 (object) 是系统中用来描述客观事物实体。一个对象由一组属性和对这组属性进行操作的一组方法组成</p> 
<h5><a id="Class_444"></a>类(Class)</h5> 
<p>类(Class)是具有相同属性、操作、关系和语义的组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和服务两个主要部分</p> 
<h6><a id="_446"></a>类的基本属性</h6> 
<p><img src="https://images2.imgbox.com/ef/2e/snWKeWyY_o.png" alt="image.png"></p> 
<blockquote> 
 <p>(1) 可以有多个属性也可以没有属性。<br> (2) 可见性: public、protected、private<br> (3)多重性<br> (4)初始值<br> (5)性质串<br> (6)作用范围</p> 
</blockquote> 
<h6><a id="_455"></a>类语义的进一步表达</h6> 
<ol><li>详细叙述类的职责</li><li>通过类/操作的注解，详细注释类的定义</li><li>通过类/操作的注解，详细注释各操作的前置条件和后置条件</li><li>详述类的状态机（状态图）</li><li>详述类的内部结构（活动图）</li><li>类与其他类的协作 （协作图）</li></ol> 
<p><img src="https://images2.imgbox.com/b3/66/HR4286zh_o.jpg" alt=""></p> 
<h6><a id="_465"></a>类的语义表达的详细程度取决于建模的意图</h6> 
<ol><li>为了与最终用户和领域专家沟通:较低的形式化手段</li><li>为了支持正向和逆向工程: 采用较高的形式化手段</li><li>为了对模型进行推理，证明其正确性: 采用很高的形式化手段</li></ol> 
<p>Rose<br> <img src="https://images2.imgbox.com/26/eb/CrlblPrt_o.png" alt="image.png"></p> 
<h6><a id="_473"></a>类在建模中的用途</h6> 
<ol><li>模型化问题域中的概念</li><li>建立系统的职责分布模型</li><li>模型化建模中使用的基本类型</li></ol> 
<h6><a id="_478"></a>类要满足的基本条件</h6> 
<p>一个结构良好的类，必须符合下列条件:</p> 
<blockquote> 
 <ul><li>明确抽象了问题域或解域中某个有形事物或念</li><li>包含了一个小的、明确定义的职责集， 并能很好地实现</li><li>清晰地分离了抽象和实现</li></ul> 
</blockquote> 
<h5><a id="_484"></a>接口</h5> 
<h6><a id="_485"></a>接口的含义</h6> 
<p>接口是操作的一个集合，其中每个操作描述了类构件或子系统的一个服务</p> 
<h6><a id="_487"></a>接口的表示</h6> 
<ol><li>采用具有分栏和关键字</li></ol> 
<blockquote> 
 <p>的矩形符号来表示</p> 
</blockquote> 
<ol start="2"><li>采用小圆圈和半圆圈来表示</li></ol> 
<p><img src="https://images2.imgbox.com/d8/eb/eIIOXgnc_o.png" alt="image.png"></p> 
<h6><a id="_495"></a>使用中的问题</h6> 
<ol><li>如何描述接口的语义</li><li>应用中应当注意的问题</li></ol> 
<p><img src="https://images2.imgbox.com/8e/5d/hIucDL8N_o.png" alt="image.png"></p> 
<h6><a id="_501"></a>应用中注意的问题</h6> 
<ol><li>接口智能被其它类目使用，其本身不能访问其它类目</li><li>接口描述类的外部可见操作，通常是该类的一个特定有限行为</li><li>接口不描述其中操作的实现，也没有属性和状态</li><li>接口之间没有关联、泛化、实现和依赖</li></ol> 
<h5><a id="_507"></a>协作</h5> 
<p>协作是一个交互，涉及交互的三要素:交互各方、交互方式以及交互内容<br> <img src="https://images2.imgbox.com/8f/6b/YVPsya3j_o.jpg" alt=""></p> 
<h5><a id="_use_case__510"></a>用况 (use case) /用例</h5> 
<p>对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的、i可观察的结果。<br> <img src="https://images2.imgbox.com/75/dc/x67cC5wW_o.jpg" alt=""><br> <img src="https://images2.imgbox.com/e6/d9/MT4Rhf1N_o.png" alt="image.png"></p> 
<h5><a id="_514"></a>主动类</h5> 
<ol><li>至少具有一个进程或线程的类。能够启动系统的控制活动，并且其对象的行为通常与其它元素行为并发的</li><li>表示方法:两条竖线</li><li>用来模型化系统中的并发行为</li></ol> 
<p><img src="https://images2.imgbox.com/b4/07/Zk5RAk8l_o.png" alt="image.png"></p> 
<h5><a id="_521"></a>构件/组件</h5> 
<ol><li>系统设计中的一种模块化都件,通过外部接口隐藏了它的内部实现</li><li>具有相同接口的构件可以相互替代</li><li>构件可以嵌套</li><li>构件用于表达解空间中可独立标识的成分</li></ol> 
<p><img src="https://images2.imgbox.com/d8/be/HuabtsFL_o.png" alt="image.png"></p> 
<h5><a id="_Artifact_529"></a>制品 (Artifact)</h5> 
<ol><li>系统中包含物理信息的、可替代的物理部件</li><li>部署制品:这类制品是构成一个可执行系统必要而充分的制品，例如: DLL、EXE文件</li><li>工作产品制品:这类制品本质上是开发过程的产物，由源代码文件、数据文件等用来创建部署制品的事物构成</li><li>执行制品:这类制品是作为一个正在运行的系统的结果而被创建的。一般存在于内存之中</li></ol> 
<h5><a id="_535"></a>节点</h5> 
<p>节点是在运行时存在的物理元素通常表示一种具有记忆能力和处理能力的计算机资源<br> <img src="https://images2.imgbox.com/9a/ee/Qe1Iw1Xa_o.png" alt="image.png"></p> 
<h3><a id="2_538"></a>2、表达关系的术语</h3> 
<ol><li>关联</li><li>泛化</li><li>细化</li><li>依赖</li></ol> 
<h4><a id="1Association_544"></a>1）关联(Association)</h4> 
<ol><li>关联反映了类和类之间的静态关系。关联在模型中，特别是在永久业务对象模型中是最基本的关系。</li><li>关联是类目之间的一种结构关系，是对一组具有相同结构、相同链的描述。</li></ol> 
<p><img src="https://images2.imgbox.com/03/36/OFWU7Nds_o.png" alt="image.png"></p> 
<blockquote> 
 <p>导航：一个类推出另一个类(加个箭头)<br> 组合是依赖另一个类的</p> 
</blockquote> 
<h5><a id="_553"></a>关联的语义表达:</h5> 
<ol><li>关联名</li><li>导航</li><li>角色</li><li>可见性( 权限)</li><li>多重性:多重性(Multiplicity) 定义了与一个对象类相联系的对象 类出现一次，该对象 类可能出现的最小和最大的数目</li></ol> 
<h5><a id="_560"></a>关联的语义表达:</h5> 
<ol><li>限定符</li><li>聚合:一个类是另一类的一部分 (空菱心箭头)</li><li>组合:是聚合的一种特殊形式 (实菱心箭头)</li></ol> 
<p><img src="https://images2.imgbox.com/16/c4/bDb9Hktv_o.png" alt="image.png"></p> 
<ol start="3"><li>关联类</li></ol> 
<p>具有关联和类特性的模型元素</p> 
<ol start="4"><li>约束</li></ol> 
<p>有序 （ordered）、无重复的(set)、有重复的 (bag)、有序集合（order set ）、列表（list）、只读 (read only)</p> 
<h4><a id="2_575"></a>2）泛化/继承</h4> 
<p>特殊类 (子类)的对象拥有其一般类(超类)的全部属性与服务，称作特殊类对一般类的继承 (inher itance) ，利用继承 (inher itance) ，子类可以继承父类的属性和方法。子类 / 父类也可分别叫做特殊类 /一般类、子类 /超类、派生类 / 基类等<br> <img src="https://images2.imgbox.com/e9/23/mOdr6alG_o.png" alt="image.png"></p> 
<h4><a id="3_578"></a>3）细化/实现</h4> 
<ol><li>细化是类目之间的语义关系，其中一个类目规约了保证另一类目执行的契约</li><li>用空心三角形的虚线表示</li></ol> 
<p><img src="https://images2.imgbox.com/47/af/MH4sGHoz_o.jpg" alt=""></p> 
<ol start="3"><li>在以下2个地方会使用实现关系:</li></ol> 
<blockquote> 
 <p>接口与实现它们的类和构件之间:<br> 用况与实现它们的协作之间</p> 
</blockquote> 
<h4><a id="4_589"></a>4）依赖</h4> 
<ol><li>依赖是一种使用关系，用于描述一个类目使用另一类目的信息和服务</li><li>用有向虚线段表示</li></ol> 
<p><img src="https://images2.imgbox.com/d6/a8/VFxny56l_o.jpg" alt=""><br> <img src="https://images2.imgbox.com/0b/84/PW3qWJ6A_o.png" alt="image.png"></p> 
<h5><a id="_596"></a>依赖-依赖的的分类:</h5> 
<p>(1) 定(Bind)<br> (2)导出(Derive)<br> (3) 允许 (Permit)<br> (4)实例 (Instantiate)</p> 
<h4><a id="5_601"></a>5）关系术语的使用</h4> 
<ol><li>结构关系</li><li>继承关系</li><li>精化关系</li><li>依赖关系</li></ol> 
<h3><a id="3_607"></a>3、表达组合信息的术语一包</h3> 
<p>包:是模型元素的一个分组，一个包本身可以被嵌套在其它包中，并且可以含有子包和其它类型的模型元素</p> 
<ol><li>包的可见性符号</li><li>包之间的关系</li><li>访问 (use access)</li><li>引入 (import)</li></ol> 
<p><img src="https://images2.imgbox.com/a0/b2/2zzXMign_o.png" alt="image.png"></p> 
<h3><a id="2UML_616"></a>2、UML的模型表达格式</h3> 
<p><img src="https://images2.imgbox.com/22/e4/Nlwzj4Py_o.png" alt="image.png"></p> 
<h4><a id="1_618"></a>1）类图</h4> 
<p>类图 (class diagram) 表达了(系统的静态结构信息，即系统是由哪些类组成的，这些类之间的关系是什么。<br> 类图显示系统各个部分以及怎样将它们组装起来</p> 
<h5><a id="_621"></a>构造类图的三个关键问题是:</h5> 
<ol><li>系统中有哪些需要关心的类?</li><li>这些类是如何描述的?</li><li>这些类之间的联系是什么?</li></ol> 
<h4><a id="2_use_case__626"></a>2）用况图 (use case 图)</h4> 
<p>用况是对一个参与者 (actor ) 使用系统的一项功能时所进行的交互过程的一个文字描述序列<br> 用况图是一种表达系统功能模型的图形化工具<br> include:包含，/扩展<br> <img src="https://images2.imgbox.com/67/e2/buDGsO0I_o.png" alt="image.png"></p> 
<h5><a id="6_631"></a>用况图的6个模型元素:</h5> 
<ol><li>主题</li><li>用况</li><li>参与者: 系统用户、另一个系统时间</li><li>关联、泛化、依赖</li><li>用况是系统开发的起点</li><li>大多数的系统功能都可以表示成用况</li></ol> 
<h4><a id="3_639"></a>3）状态图</h4> 
<blockquote> 
 <p>(一个对象的图)<br> 状态机的图，强调了从一个状态到另一个状态的控制流</p> 
</blockquote> 
<p>状态图 (state chart diagram) 使用状态、事件和转换来记录对象在其生命周期中所历经的状态序列</p> 
<blockquote> 
 <p>始态(实心圆加能头)<br> 终态:(箭头加实心圆)</p> 
</blockquote> 
<ol><li>对象的初始状态是图中任何事件都未对该对象起作用时的状态</li><li>状态代表对象生命周期中的某一瞬间</li><li>转换表明作为对事件的响应结果，对象将从一种状态转换到另一种状态并执行某个动作</li><li>触发状态转换的事件在状态转换字符串中命名。双击一个状态转换，除事件签名以外，还可用字符串为其加注临界条件、动作表达式等标签</li></ol> 
<h5><a id="_3__651"></a>状态图中的 3 个术语:</h5> 
<ol><li>状态：一个实例所处的特定阶段、所具有的对外呈现以及所能提供的服务</li><li>事件</li></ol> 
<blockquote> 
 <ul><li>信号事件</li><li>调用事件</li><li>时间事件</li><li>变化事件</li></ul> 
</blockquote> 
<blockquote> 
 <p>引起状态变化的叫事件</p> 
</blockquote> 
<ol start="3"><li>状态转移</li></ol> 
<h4><a id="4_663"></a>4）顺序图</h4> 
<blockquote> 
 <p>多个对象</p> 
</blockquote> 
<p>顺序图(sequence diagram) 表示了对象之间传送消息的时间顺序，也就是对象之间的交互顺序。<br> 这些交互是指在场景或用况的事件流中发生的。<br> 每一个对象(类人用一条生命线来表示一一即用垂直线代表整个交互过程中对象的生命期。<br> 生命线之间的箭头连线代表消息<br> <img src="https://images2.imgbox.com/44/e1/R5J5mH1a_o.png" alt="image.png"></p> 
<h5><a id="_671"></a>顺序图中的基本元素包括:</h5> 
<ol><li>活动者，指用况中的活动者</li><li>对象，指在用况中的内部对象。</li><li>生命线: 在顺序图中的一个对象下面的竖线，用以显示这个对象的生命期。</li><li>消息，指场景内由事件流定义的内部事件成为在对象和活动者或其他对象之间的消息</li></ol> 
<h6><a id="_677"></a>消息的类型</h6> 
<p>(1)同步消息：返回消息，同步消息假定有一个返回消息司步消息用有实心的箭头表示:返回消息用虚线、箭头也不是实心来表示。<br> (2) 反身消息：消息的发送方和接收方是同一个对象。<br> (3) 异步消息：没有返回值的消息，用非实心箭头表示。<br> (4)定时消息：对消息附加时间约束条件，包括:发送时门接受时间、已用时间等。</p> 
<h5><a id="_682"></a>控制操作子:</h5> 
<p>为了控制交互行为描述的复杂性，以便更清晰地表达顺序图中的复杂控制，UML给出了4中最常用的控制操作子</p> 
<ul><li>1)选择执行操作子(Operator for Optional Evecution)。该控制操作子记为“Opt”由两部分组成，一是监护条件,二是控制体。</li><li>2)条件执行操作子(Operator for Conditional Execution)该控制操作子记为“alt”，控制体通过水平线将其分成一些部分，每一部分表示一个条件分支，每个分支有一个监护条件</li><li>3)并发执行操作子(Operator for Parallel Execution该控制操作子记为“par”，该控制操作子的体通过水平线将其分为多个部分。每一部分表示一个并行计算。在大多数情况下,每一部分涉及不同的生命线。该控制操作子表明，当进入该控制操作子时，所有部分并发执行。</li><li>4)迭代操作子(Operator for lterative Execution)。该控制操作子记为“loop“</li></ul> 
<blockquote> 
 <p>类(Class)是一组具有相同属性、操作、关系和语义的对象的描述<br> 对象是类实例<br> 类的构成成分:类名、属性、操作<br> 类在建模中的主要用途:<br> (1)模型化问题域中的概念<br> (2)建立系统的职责分布模型<br> (3)模型化建模中使用的基本类型</p> 
</blockquote> 
<h3><a id="_697"></a>小结</h3> 
<ol><li>UML提供了跨越问题空间到“运行平台”之间的丰富的建模元素：提供了描述客观事物的8个术语和描述关系的4个术语</li><li>提供了相应的模型表示工具:用况图、类图、状态图、顺序图</li><li>为了表达概念模型和软件模型，UML提供了13种图形化工具</li></ol> 
<h2><a id="_RUP_702"></a>五、面向对象方法 RUP</h2> 
<p>RUP+UML = 面向对象方法</p> 
<blockquote> 
 <p>统一软件开发过程 (Rational UnifiedProcess: RUP) 是对象管理组织 (OMG) 所推荐的一个有关过程的标准。<br> RUP是基于UML的一种过程框架。比较完整地定义了将用户需求转换成产品所需要的活动集并提供了活动指南以及对产生相关文档的要求<br> RUP适应于大多数软件系统的开发，基于构件。</p> 
</blockquote> 
<h3><a id="_708"></a>知识结构</h3> 
<blockquote> 
 <p>过程模型:<br> 1.需求获取模型<br> 2.需求分析模型<br> 3.软件设计模型<br> 4.软件实现模型<br> 5.软件测试模型</p> 
</blockquote> 
<h3><a id="1RUP_716"></a>1、RUP的特点</h3> 
<p>以用况驱动的、以体系结构为中心的迭代、增量式开发。</p> 
<h4><a id="1_718"></a>(1)用况驱动</h4> 
<p>在系统的生存周期中，以用况作为基础，驱动系统有关人员对所要建立系统的功能需求进行交流，驱动系统分析、设计、实现和测试等活动，包括制定计划、分配任务、监控执行和进行测试等，并将它们有机地组织在一起，使各个阶段中都可以回溯到用户的实际需求。</p> 
<h4><a id="2_720"></a>(2)以体系结构为中心</h4> 
<ul><li>系统体系结构:是对系统语义的概括描述对所有项目有关人员都是可以理解的</li><li>关注子系统、构件、接口、协作、关系和节点等重要模型元素，而忽略其它细节</li></ul> 
<h4><a id="3_724"></a>(3)迭代与增量</h4> 
<ul><li>迭代是重复的部分</li><li>增量是增加的部分</li></ul> 
<p><img src="https://images2.imgbox.com/e0/3f/DmlccpmF_o.png" alt="image.png"></p> 
<h5><a id="_730"></a>初始阶段的基本目标</h5> 
<ul><li>获得与特定用况和平台无关的系统体系结构轮廓</li><li>为系统建立商业案例:</li><li>确定项目的边界</li><li>从业务角度指出该项目的价值</li><li>第一个重要的里程碑:生命周期目标(Lifecycle 0bjective) 里程碑</li></ul> 
<h5><a id="_737"></a>细化阶段</h5> 
<ul><li>细化阶段的目标是分析问题领域，建立健全的体系结构基础，编制项目计划，淘汰项目中最高风险的元素</li><li>第二个重要的里程碑:生命周期结构 (LifecyelArchitecture)里程碑</li></ul> 
<h5><a id="_741"></a>构造阶段</h5> 
<ul><li>形成最终的系统体系结构基线</li><li>开发完整的系统</li><li>确保产品可以开始向客户交付</li><li>第三个重要的里程碑:初始功能nitial Operational) 里程碑</li></ul> 
<blockquote> 
 <p>一个过程包括若千个任务，一个人任务包括若千个活动，一个活动有若千个术语</p> 
</blockquote> 
<h3><a id="2_749"></a>2、核心工作流</h3> 
<p>RUP中有9个核心工作流，分为6个核心过程工作流 (Core Process Workflows) 和3个核心支持工作流 (Core Supporting Workflows)<br> 主要核心工作流：需求获取、分析、设计</p> 
<h4><a id="1_752"></a>1）需求获取</h4> 
<ul><li>RUP运用用况 (Use Gase) 技术来获取需求</li><li>需求获取的基本步骤:</li></ul> 
<blockquote> 
 <p>列出候选的需求：特征列表<br> 理解系统语境：领域模型或业务模型<br> 捕获功能需求：用况模型<br> 捕获非功能需求：补充需求或针对一些特定的用况</p> 
 <ol><li>列出候选的需求</li></ol> 
</blockquote> 
<p>搜取特征:是一个新的项 (ltem)及其简要描述</p> 
<blockquote> 
 <ol start="2"><li>理解系统语境</li></ol> 
 <ul><li>创建领域模型或业务模型</li><li>业务用况模型:业务参与者和业务用况</li><li>业务对象模型:三个术语: 工作人员业务实体、工作单元:用交互图和活动图来表达</li></ul> 
 <ol start="3"><li>捕获功能需求:建立系统的用况模型</li></ol> 
 <ul><li>发现和描述参与者</li><li>发现并描述用况</li><li>确定用况的优先级</li><li>精化用况</li><li>构造用户界面模型</li><li>用况模型的结构化</li></ul> 
</blockquote> 
<h4><a id="2_775"></a>2）需求分析</h4> 
<p>需求分析的目标:在系统用况模型的基础上，创建系统分析模型以及在该分析模型视角下的体系结构描述</p> 
<h5><a id="1_777"></a>1.术语</h5> 
<h6><a id="1__778"></a>(1) 分析类:</h6> 
<p>是类的一种衍型，很少有操作和特征标记，而用责任来定义其行为，并且其属性和关系也是概念性的<br> 存在三种不同类型的类：实体类、边界类和控制类<br> <img src="https://images2.imgbox.com/4b/ca/EGB5jCYN_o.png" alt="image.png"></p> 
<h6><a id="2_782"></a>（2)用况细化</h6> 
<ul><li>用况细化是一个协作</li><li>针对一个用况，其行为可以用多个分析类之间的相互作用细化，并记为用况细化</li></ul> 
<p><img src="https://images2.imgbox.com/2c/cf/6NNiRkVj_o.png" alt="image.png"></p> 
<h6><a id="3__788"></a>（3） 分析包</h6> 
<ul><li>分析包体现了“局部化”、“问题分离”等软件设计原理</li><li>分析包把一些变化限制到一个业务过程、一个参与者的行为或一组紧密相关的用况，形成一些不同的分析包</li><li>体现“高内聚、低耦合“</li></ul> 
<h5><a id="2_793"></a>2.分析模型的表达</h5> 
<ul><li>分析模型是由“分析系统”来定义的</li><li>分析系统包含一组具有层次结构的包一个包</li><li>可以包含一些分析类和用况细化</li></ul> 
<h5><a id="3_798"></a>3.分析的主要活动</h5> 
<h6><a id="1__799"></a>活动1: 体系结构分析</h6> 
<ul><li>标识分析包</li><li>处理分析包之间的共性</li><li>标识服务包</li><li>定义分析包的依赖</li><li>标识重要的实体类</li><li>标识分析包和重要实体类的公共特性需求</li></ul> 
<h6><a id="2__807"></a>活动2: 用况分析</h6> 
<ul><li>标识分析类</li><li>描述分析类之间的交互</li></ul> 
<h6><a id="3__811"></a>活动3: 类的分析</h6> 
<ul><li>标识责任</li><li>标识属性</li><li>标识关联和聚合</li><li>包的分析</li></ul> 
<h6><a id="4_817"></a>活动4:包的分析</h6> 
<ul><li>确保分析包尽可能与其它包相对独立</li><li>确保分析包实现了它的目标，即细化了某些领域类或用况</li><li>描述依赖</li></ul> 
<h5><a id="3_822"></a>3.需求分析总结</h5> 
<ul><li>三个术语:分析包、分析类、用况细化</li><li>四个步骤</li></ul> 
<blockquote> 
 <ul><li>体系结构分析</li><li>细化用况</li><li>对类分析</li><li>对包进行分析</li></ul> 
</blockquote> 
<ul><li>一个成果:分析模型(分析系统)</li></ul> 
<p>一个是产品设计，一个是程序设计<br> <img src="https://images2.imgbox.com/30/8a/JjY4TH0m_o.png" alt="image.png"></p> 
<h3><a id="3_835"></a>3、软件设计</h3> 
<ul><li>软件设计：定义满足需求规约所需要的软件结构</li><li>RUP的设计目标：定义满足系统 产品分析模型所规约需求的软件结构。</li></ul> 
<h4><a id="1_839"></a>1）相关术语</h4> 
<ul><li>设计类</li><li>用况细化</li><li>设计子系统</li><li>接口</li></ul> 
<h4><a id="2_845"></a>2）设计模型、部署模型及相关视角下的体系结构描述</h4> 
<h5><a id="1__846"></a>(1) 设计模型:</h5> 
<ul><li>设计子系统</li><li>设计类</li><li>用况细化</li><li>接口</li></ul> 
<h5><a id="2__852"></a>(2) 部署模型:</h5> 
<p>是一个对象模型，描述了系统的物理分布，即如何把功能分布于各个节点上<br> <img src="https://images2.imgbox.com/24/51/cTQN4ca8_o.png" alt="image.png"></p> 
<h5><a id="3_855"></a>（3）设计的主要活动</h5> 
<ul><li>活动1：体系结构设计</li></ul> 
<blockquote> 
 <p>标识节点和它们的网络配置<br> 标识子系统和它们的接口<br> 标识在体系结构方面有意义的设计类和它们的接口<br> 标识一般性的设计机制</p> 
</blockquote> 
<ul><li>活动2：用况的设计</li></ul> 
<blockquote> 
 <p>标识参与用况细化的设计类<br> 标识参与用况细化的子系统和接口</p> 
</blockquote> 
<ul><li>活动3：类的设计</li></ul> 
<blockquote> 
 <p>概括描述设计类<br> 标识操作<br> 标识属性<br> 标识关联和聚合<br> 标识泛化<br> 描述方法</p> 
</blockquote> 
<ul><li>活动4：子系统设计 包的概念</li></ul> 
<blockquote> 
 <p>维护子系统依赖<br> 维护子系统所提供的接口<br> 维护子系统内容</p> 
</blockquote> 
<h4><a id="3RUP_880"></a>3）RUP设计小结</h4> 
<h5><a id="1RUP__881"></a>1.RUP 设计的特点</h5> 
<p>(1) 使用了一种公共的思想来思考设计，并使设计可视化<br> (2)给出了有关子系统、设计类和接口的需求<br> (3) 支持对底线工作的分解，时之称为一些可以由不同开发组尽可能同时处理的、可管理的部分</p> 
<h5><a id="2RUP_885"></a>2.RUP的设计方法</h5> 
<p>(1)给出表达设计模型的基本成分的术语<br> (2)规约了设计模型的语法，指导模型的表达<br> (3)给出了创建设计模型的过程以及相应的指导</p> 
<h5><a id="3RUP_889"></a>3.RUP的设计模型</h5> 
<p>(1)设计子系统和服务子系统，以及它们的依赖、接口和内容<br> (2)设计类，以及它们具有的操作、属性、关系及其实现需求<br> (3)用况细化<br> (4)设计模型视角下的体系结构描述</p> 
<h5><a id="4RUP_894"></a>4、RUP的部署模型</h5> 
<p>(1)节点，它们的特征以及连接<br> (2)主动类到节点的初始映射</p> 
<table><thead><tr><th>分析模型</th><th>设计模型</th></tr></thead><tbody><tr><td>概念模型</td><td>软件模型</td></tr><tr><td>可应用于不同的设计</td><td>特定于一个实现</td></tr><tr><td>使用了三个衍生类: 边界、实体、控制</td><td>使用了多个行生类，依赖实现的语言</td></tr><tr><td>几乎不是形式化的</td><td>是比较形式化的</td></tr><tr><td>开发费用少</td><td>开发费用多</td></tr><tr><td>结构层次少</td><td>结构层次多</td></tr><tr><td>动态的，但很少关注定序方面</td><td>动态的，但更多关注定序方面</td></tr><tr><td>概括给出了系统设计</td><td>表明了系统设计</td></tr><tr><td>整个生命同期内不能修改、增加等</td><td>整个生命周期内应该予以维护</td></tr><tr><td>为构建系统定义一个结构，是基本输入</td><td>构件系统时，尽可能保留分析模形所定义的结构</td></tr></tbody></table> 
<h5><a id="5_911"></a>5、设计阶段的活动</h5> 
<p>(1) 体系结构设计<br> (2)设计用况<br> (3)设计类<br> (4) 设计子系统</p> 
<h5><a id="6RUP_916"></a>6、RUP设计对实现的影响</h5> 
<p>(1)设计子系统和服务子系统由实现子系统予以实现<br> (2)设计类由文件化构件予以实现<br> (3)在规划实现工作时，将要使用用况细化以产生一些“构造”<br> (4)在节点上部署构件、形成分布系统时，将使用部署模型和网络配置</p> 
<h3><a id="4RUP_921"></a>4、RUP的实现与测试</h3> 
<p>编程的构建</p> 
<h4><a id="1RUP_923"></a>1）RUP的实现目标</h4> 
<p>(1)基于设计类和子系统生成构件<br> (2)对构成进行单元测试<br> (3)进行集成和连接<br> (4)把可执行的构件映射到部署模型</p> 
<h4><a id="2RUP_928"></a>2）RUP实现的主要活动</h4> 
<p>(1)实现体系结构<br> (2)集成系统<br> (3)实现子系统<br> (4)实现类<br> (5)完成单元测试</p> 
<h4><a id="3RUP_934"></a>3）RUP的测试</h4> 
<p>包括:内部测试、中间测试和最终测试</p> 
<h4><a id="4RUP_936"></a>4）RUP测试包括的主要活动</h4> 
<p>(1) 计划测试<br> (2)设计测试<br> (3)实现测试<br> (4)执行集成测试<br> (5)执行系统测试<br> (6)评价测试</p> 
<h3><a id="_943"></a>小结</h3> 
<ol><li>RUP是一种软件开发过程框架，基于面向对象符号体系给出了软件开发过程组织及实施的指导。</li><li>RUP框架的典型特征：以用况驱动的、以体系结构为中心的迭代、增量式开发</li><li>RUP与UML是一对“姐妹”，它们构成了种特定的软件开发方法学</li><li>需求获取层的基本术语: 用况，参与者，关联，包含、扩展，泛化等</li><li>系统分析层术语：分析类，用况细化，分析包以及描述关系的依赖、关联等</li><li>系统设计层术语：设计子系统、设计类用况细化等</li></ol> 
<h2><a id="_951"></a>六、软件测试</h2> 
<p>错误是不可避免的，我们要做的就是发现它并改正它。<br> 软件测试是保证软件过程质量和软件产品质量的基础。<br> 软件测试是一种动态评估技术，通过执行程序发现其中的错误。</p> 
<h3><a id="_955"></a>三种软件测试技术:</h3> 
<p>(1)基于程序路径的白盒测试技术<br> (2)基于需求规约的事务流测试技术<br> (3)等价类划分技术</p> 
<h3><a id="1_960"></a>1、软件测试目标与软件测试过程模型</h3> 
<h4><a id="1_961"></a>1）软件测试的对象</h4> 
<p>软件 = 程序 + 文档<br> 测试对象:各个阶段产生的源程序和文档。</p> 
<h4><a id="2_964"></a>2）软件测试的目的</h4> 
<p>测试的目的应该是通过软件测试尽可能多地发现并改正软件种存在的错误。</p> 
<h4><a id="3_966"></a>3）软件测试的定义</h4> 
<ol><li>软件测试(Software Testing)是按照特定规程发现软件错误的的过程。</li><li>使用人工或自动手段，运行或测定某个系统的过程，其目的是检验它是否满足规定的需求，或清楚了解预期结果与实际结果之间的差异。</li></ol> 
<h4><a id="4_970"></a>4）“测试”和“调试”的区别</h4> 
<ol><li>测试证明“失败”，调试证明“正确”</li><li>测试以已知条件开始</li><li>测试时有计划的</li><li>测试是一个发现错误、改正错误、重新测试的 过程</li><li>测试的执行是有规程的</li><li>测试由独立的测试小组完成</li><li>测试的执行和设计可由工具支持</li></ol> 
<h4><a id="5_979"></a>5）测试过程模型</h4> 
<p>1、测试设计</p> 
<ul><li>环境模型</li><li>对象模型</li><li>错误模型</li></ul> 
<p>2、测试执行<br> 3、测试结果比较</p> 
<h3><a id="2__988"></a>2、 软件测试技术</h3> 
<p><img src="https://images2.imgbox.com/3c/ae/8iG4ZTk3_o.png" alt="image.png"><br> 黑盒：功能测试(接口)<br> 白盒：逻辑的测试(里面的数据都看得到)<br> ***重要</p> 
<h4><a id="1_993"></a>1）路径测试技术</h4> 
<ul><li>是一种白盒测试技术</li><li>依据的是程序的逻辑结构。</li><li>采用控制流程图来表达被测程序模型</li><li>通过合理地选择一组穿过程序的路径，以达到某种测量度量</li></ul> 
<h5><a id="a_999"></a>a.控制流程图</h5> 
<p>是一种表示程序控制结构的图形化工具，其基本元素是过程块、节点、判定。<br> <img src="https://images2.imgbox.com/6f/8e/CkQj5lZu_o.png" alt="image.png"></p> 
<blockquote> 
 <p>s1,s2…s4程序块<br> 1,2,3,4:判定</p> 
</blockquote> 
<p>路径:是由链组成的，包含一串指令或语句其长度由链的数目决定<br> 对软件测试而言，限定路径为: 从程序的入口开始，在出口结束</p> 
<h5><a id="b_1007"></a>b.测试策略</h5> 
<p>路径覆盖 (PX) :执行所有可能穿过程序控制流程的路径。 最强的测试度量<br> 语句覆盖 (C1) : 至少执行程序中所有语句一次。最低的测试度量<br> 分支覆盖(P2) :至少将程序中的每个分支执行一次<br> 条件覆盖：与条件组合覆盖</p> 
<blockquote> 
 <p>条件覆盖: true和false 都执行<br> 类似:完整功能，按钮事件和部分功能</p> 
</blockquote> 
<blockquote> 
 <p>语句:判断和语句都要执行<br> 条件:真和假都要出现一遍<br> 分支:所有的分支(语)都执行一遍<br> 路径:所有的路径</p> 
</blockquote> 
<h6><a id="_1020"></a>几种测试覆盖存在以下基本关系:</h6> 
<p>语句覆盖≤分支覆盖≤条件组合覆盖≤路径覆盖</p> 
<blockquote> 
 <p>微码(英语:microode)，又称微指令，是在CISC结构下，运行一些功能复杂的指令时，所分解一系列相对简单的指令。相关的概念最早在1947年开始出现</p> 
</blockquote> 
<h5><a id="c_1024"></a>c.路径选取与用例设计</h5> 
<p>最小的强制性测试需求是语句覆盖率。<br> 路径选取的一般原则:<br> (1）选择最简单的、具有一定功能含义的入口 出口路径；<br> (2)在已选取的基础上，选择无循环的路径，选取短路径 简单路径:<br> (3)选取没有明显功能含义的路径，要研究该路径为什么</p> 
<h4><a id="2_1030"></a>2）基于事务流的测试技术</h4> 
<p>是一种功能测试技术<br> 属于黑盒测试技术</p> 
<h5><a id="a_1033"></a>a.事务:</h5> 
<p>是指从系统用户的角度出发所见到的一个工作单元，有其“生”，有其“亡”</p> 
<ul><li>短信提醒</li><li>节日问候</li><li>数据更新</li></ul> 
<blockquote> 
 <p>事务由一系列操作组成，用“事务流”表达事务流:是系统行为的一种表示方法，为功能测试建立了程序的动作模式事务流程图:表达系统的行为，多个事务流的执行</p> 
</blockquote> 
<p>事务流程图<br> <img src="https://images2.imgbox.com/f9/92/HTNvwCya_o.png" alt="image.png"></p> 
<h5><a id="_1043"></a>事务流程图中的相关概念</h5> 
<p>1、并生:事务处理产生一个新事务，由此这两个事务继续执行<br> 2、丝分裂:事务处理产生两个新事务<br> 3、汇集: 事务的不同活动可以汇集一处<br> 4、吸收:一个事务可以被另一个事务吸食<br> 5、结合: 两个事务结合后产生一个新事务</p> 
<h5><a id="_1049"></a>如何根据事务流程图设计测试用例</h5> 
<ul><li>步骤1: 获得事务流程图</li><li>步骤2:浏览、复审</li><li>步骤3: 用例设计</li><li>步骤4:测试执行</li></ul> 
<h4><a id="3_1055"></a>3）等价类法</h4> 
<p>是根据程序的I/O特性，将程序的输入划分为有限个等价区段，使得从每个区段内抽取的代表性数据进行的测试等价于该区段内任何数据的测试。<br> 对于每个输入条件存在着程序有效输入的 有效的等价类和对程序错误输入的无效等价类。</p> 
<blockquote> 
 <p>eg:<br> 某实数X的取值范围假设为a&lt;X&lt;b，则所有[a+1，b-1]之间的实数构成了有效等价类，而任何[-∞，a]或[b，+∞]之间的实数构成了两个无效等价类。</p> 
</blockquote> 
<ol><li>如果某个输入条件规定了输入数据的取值范围，则可以确立一个有效等价类和两个无效等价类</li><li>如果某个输入条件规定了输入数据的个数，则可以确立一个有效等价类和两个无效等价类</li><li>如果某个输入条件规定了输入数据的一组可能取的值每一个输入值就是一个有效等价类，一个无效等价类</li><li>如果某个输入条件是一个布尔值，则可以划分一个有效等价类和一个无效等价类</li><li>如果某个输入条件规定了必须符合的条件，则可以划分一个有效等价类和一个无效等价类</li><li>若在已划分的某个等价类中各元素在程序中的处理方式不同，则应将此等价类进一步划分为更小的等价类</li></ol> 
<h4><a id="4_1067"></a>4）边值分析法</h4> 
<p>是一种根据I/O边界等价类上或紧靠边界的条件选择测试用例的更有效的方法。</p> 
<blockquote> 
 <p>eg：<br> 给定三个点，判定能否构成三角形，可选取两边之和等于第三边的实例作为边值分析法的测试用例</p> 
</blockquote> 
<h4><a id="5_1072"></a>5）因果图法</h4> 
<p>因一输入条件和果一输出结果，通过因果图将能说明转换成一张判定表，然后为每种输入条件的组合设计测试用例<br> 着重检查输入条件的组合。<br> <img src="https://images2.imgbox.com/7b/72/9TECUfMF_o.png" alt="image.png"><img src="https://images2.imgbox.com/53/28/7HEt1wM5_o.png" alt="image.png"></p> 
<h5><a id="_1076"></a>用因果图生成测试用例的步骤</h5> 
<p>步骤1: 找出模块的原因(输入条件或输入条件的等价类 和结果步骤2: 分析原因与结果之间的对应关系，画出因果图步骤3:在因果图上标识出一些特定的约束和限制条件<br> 步骤4:把因果图转化为判定表<br> 步骤5:把判定表的每一列作为依据，设计测试用例</p> 
<h3><a id="3_1080"></a>3、软件测试步骤</h3> 
<p>软件测试是按照与系统开发相反的方向来进行的。依次为:</p> 
<ul><li>单元测试</li><li>集成测试</li><li>有效性测试</li><li>系统测试</li></ul> 
<h4><a id="1_1087"></a>1）单元测试</h4> 
<blockquote> 
 <p>单元测试(Unit Testing)又称模块测试(ModuleTesting)，或模块分调，用于测试单个程序模块，确定模块的逻辑和功能是否正确。</p> 
</blockquote> 
<p>单元测试采用白盒测试技术。</p> 
<h5><a id="4_1091"></a>单元测试要考虑模块的4个特征:</h5> 
<p>(1) 模块接口<br> (2) 局部数据结构<br> (3)重要的执行路径<br> (4)错误执行路径</p> 
<h5><a id="_1096"></a>单元测试还需要开发驱动模块和承接模块</h5> 
<p>(1)驱动模块:调用被测试模块的模块<br> (2)承接模块:被测试模块调用的模块</p> 
<h4><a id="2_1099"></a>2）集成测试</h4> 
<blockquote> 
 <p>集成测试(Integration Testing)用来测试模块之间接口的正确性，也即模块之间的数据和控制传递。<br> 集成测试是与单元测试平行进行的两种策略:</p> 
 <ul><li>自顶向下的集成测试:需要设计承接模块</li><li>自底向上的集成测试:需求设计驱动模块</li></ul> 
</blockquote> 
<p>每加入新的模块，还要进行回归测试。</p> 
<h4><a id="3_1107"></a>3）有效性测试</h4> 
<blockquote> 
 <p>目标是发现软件实现的功能与需求规格说明书不一致的错误</p> 
</blockquote> 
<p>采用黑盒测试技术<br> ***重要</p> 
<table><thead><tr><th>测试步骤</th><th>测试对象</th><th>测试方法</th><th>测试内容</th><th>特点</th></tr></thead><tbody><tr><td>单元测试</td><td>模块</td><td>白盒测试</td><td>模块接口局部数据结构重要的执行路径错误执行路径</td><td>驱动模块承接模块</td></tr><tr><td>集成测试</td><td>模块的组装模块的接口</td><td>黑盒测试</td><td>模块的接口</td><td></td></tr><tr><td>有效测试</td><td>是否符合用户可见的文档</td><td>黑盒测试</td><td>软件实现的内容与需求说明书的一致性</td><td></td></tr><tr><td>系统测试</td><td>软硬件的协作系统的性能</td><td>黑盒测试</td><td></td><td></td></tr></tbody></table> 
<h3><a id="_1120"></a>小结</h3> 
<p>**等价类</p> 
<ol><li>软件测试是由规程地发现错误的过程；</li><li>软件测试的过程模型: 测试设计、测试执行、测试结果比较；</li><li>两种测试技术:白盒测试和黑盒测试；</li><li>白盒测试：路径测试技术，四种覆盖:语句覆盖分支覆盖、条件覆盖、路径覆盖;</li><li>黑盒测试技术：事务流测试、等价类测试、边界类测试、因果图</li></ol> 
<h2><a id="_1128"></a>七、软件生存周期与管理</h2> 
<blockquote> 
 <p>开发逻辑，是获取正确软件的关键!<br> 软件生命周期是软件产品或系统的一系列相关活动的全周期。生命周期可以划分为若干阶段，每一阶段又包括若干活动和任务。为了更清晰地描述软件过程及其活动和任务，ISO发布了《ISO/IEC软件生存周期过程12207-1995》标准。</p> 
</blockquote> 
<h3><a id="1_1132"></a>1、软件生存周期过程概述</h3> 
<ol><li>《ISO/IEC软件生存周期过程12207-1995》标准</li><li>《ISO/IEC软件生存周期过程12207-2008》标准</li><li>基本思路是:</li></ol> 
<p><img src="https://images2.imgbox.com/23/d6/f63d4Xcc_o.png" alt="image.png"></p> 
<h4><a id="1ISOIEC122071995_1139"></a>1）《ISO/IEC软件生存周期过程12207-1995》标准</h4> 
<h5><a id="_1140"></a>软件生存周期过程的分类:</h5> 
<p>1、基本过程<br> 2、支持过程<br> 3、组织过程</p> 
<h6><a id="a_1144"></a>a.基本过程</h6> 
<p>(1) 指那些与软件生产直接相关的活动集<br> (2)包括5个过程</p> 
<ul><li>获取过程</li><li>供应过程</li><li>开发过程</li><li>运行过程</li><li>维护过程</li></ul> 
<h6><a id="_1153"></a>开发过程包含的活动</h6> 
<ul><li>过程实现</li></ul> 
<blockquote> 
 <p>过程实现包含的任务</p> 
 <ol><li>选择合适的生存周期模型</li><li>选择相应的标准、方法、工具和程序设计语言</li><li>制定实施开发计划</li><li>可以使用一些非交付的软件项。</li></ol> 
</blockquote> 
<ul><li>系统需求分析</li></ul> 
<blockquote> 
 <ol><li>建立系统需求规格说明</li><li>对系统需求进行评估</li></ol> 
 <ul><li>有关获取方面需要的可追踪性</li><li>有关获取方面需要的一致性</li><li>可测试性</li><li>系统体系结构设计的可行性</li><li>运行与维护的可行性</li></ul> 
</blockquote> 
<ul><li>系统体系结构设计</li></ul> 
<blockquote> 
 <ol><li>建立系统的顶层体系结构</li><li>对体系结构及每一项的需求进行评估</li></ol> 
 <ul><li>系统需求的可追踪性</li><li>与系统需求的一致性</li><li>所使用的设计标准和方法的适宜性</li><li>软件项满足其所分配的需求的可行性</li><li>运行与维护的可行性</li></ul> 
</blockquote> 
<ul><li>软件需求分析</li></ul> 
<blockquote> 
 <ol><li>建立软件需求规格说明</li><li>对软件需求进行评估</li><li>联合复审</li></ol> 
</blockquote> 
<ul><li>软件体系结构设计</li></ul> 
<blockquote> 
 <ol><li>把对软件项的需求转变为一种体系结构</li><li>对该软件项的外部接口和各构件之间的接口进行顶层设计</li><li>进行数据库的顶层设计</li><li>编制用户文档的最初版本</li><li>为软件集成定义初步的测试需求文档</li><li>对软件项的体系结构、接口和数据库设计进行评估</li><li>实施联合评审</li></ol> 
</blockquote> 
<ul><li>软件详细设计</li><li>软件编码和测试</li><li>软件集成</li><li>软件合格性测试</li><li>系统集成</li><li>系统合格性测试</li><li>软件安装</li><li>软件验收支持</li></ul> 
<h6><a id="b_1202"></a>b.支持过程</h6> 
<ol><li>是指有关各方按他们的目标所从事的一系列支持活动集。支持活动有助于提高系统或软件产品的质量</li><li>文档过程</li><li>配置管理过程</li><li>质量保证过程</li><li>验证过程</li><li>确认过程</li><li>联合评审过程</li><li>审计过程</li><li>问题解决过程</li></ol> 
<h6><a id="_1213"></a>配置管理过程</h6> 
<ul><li>过程实现:编制配置管理计划</li><li>配置标识:为项目需要标识的并加以控制的软件项及其版本，制定一个方案</li><li>配置控制:标识并记录变更请求</li><li>配置状态统计: 编制管理记录和状态报告</li><li>配置评价</li><li>发布管理和交付</li></ul> 
<h6><a id="c_1221"></a>c.组织过程</h6> 
<ol><li>与软件生产组织有关的活动集。</li><li>包括4个过程:</li></ol> 
<blockquote> 
 <ul><li>管理过程</li><li>基础设施过程</li><li>培训过程</li><li>改进过程</li></ul> 
</blockquote> 
<h6><a id="_1230"></a>管理过程</h6> 
<ol><li>启动与范围定义</li><li>规划</li><li>测量</li><li>执行与控制</li><li>评审与评价</li><li>结束处理</li></ol> 
<h4><a id="2ISOIEC122072008_1238"></a>2）《ISO/IEC软件生存周期过程12207-2008》标准</h4> 
<p>2个过程类、7个过程组、43个过程,</p> 
<h5><a id="2_1240"></a>2个过程类</h5> 
<ol><li>“系统语境的过程“</li><li>“软件开发的过程“</li></ol> 
<p>***重要</p> 
<h5><a id="7_1246"></a>7个过程组:</h5> 
<h6><a id="_1247"></a>系统语境的过程类</h6> 
<blockquote> 
 <p>(1) 协议过程组<br> (2)项目过程组<br> (3) 技术过程组<br> (4)组织上项目使能过程组</p> 
</blockquote> 
<h6><a id="_1253"></a>软件开发的过程类</h6> 
<blockquote> 
 <p>(5)软件实现过程组<br> (6)软件支持过程组<br> (7) 软件复用过程组</p> 
</blockquote> 
<h3><a id="2_1258"></a>2、过程描述</h3> 
<p>结构:过程一&gt;活动一&gt;任务<br> <img src="https://images2.imgbox.com/44/bf/7pPkuvKy_o.png" alt="image.png"></p> 
<ul><li>供应过程</li><li>软件实现过程</li><li>软件需求分析过程</li><li>软件体系结构设计过程</li><li>软件验证过程</li><li>软件确认过程</li></ul> 
<h4><a id="1_1268"></a>1)供应过程</h4> 
<p>1、意图:为获取方提供满足所协商需求的产品或服务<br> 2、活动和任务</p> 
<blockquote> 
 <ul><li>活动1:机遇标识</li><li>活动2:供应方投标</li><li>活动3:合同协商</li><li>活动4: 合同执行</li></ul> 
</blockquote> 
<p>3、结果</p> 
<blockquote> 
 <p>(1)标识了产品或服务的获取方<br> (2) 对获取方的要求作了必要的响应<br> (3)建立了获取方和供应方之间的协议<br> (4) 供应方开发了满足所协商需求的产品 服务<br> (5)按所协商的需求向获取方交付了相应的产品 服务<br> (6)按所协商的需求安装了产品</p> 
</blockquote> 
<h4><a id="2_1284"></a>2)软件实现过程</h4> 
<p>1、意图</p> 
<blockquote> 
 <p>把已规约的行为、接口和实现约束转换为一些动作，创建称为“软件项”的软件产品和服务作为系统元素。</p> 
</blockquote> 
<p>2、活动和任务</p> 
<blockquote> 
 <p>活动:软件实现策略</p> 
</blockquote> 
<p>3、结果</p> 
<blockquote> 
 <p>(1)定义了实现策略<br> (2)标识了有关设计方面的实现技术约束<br> (3)实现了一个软件<br> (4)按提供协议，把该软件打包成一个软件并存储</p> 
</blockquote> 
<h4><a id="3_1297"></a>3)软件需求分析过程</h4> 
<p>1、意图:建立系统软件部分的需求<br> 2、活动和任务</p> 
<blockquote> 
 <p>任务1:建立软件需求和文档<br> 任务2:评估软件需求，并建立相应的评估结果文档<br> 任务3:按软件复审过程进行软件需求复审</p> 
</blockquote> 
<p>3、结果</p> 
<blockquote> 
 <p>(1)需求已分配给系统的软件元素<br> (2)已分析软件需求的正确性和可测性<br> (3)已了解软件需求对运行环境的影响<br> (4)在软件需求和系统需求之间建立了一致性和可跟踪性<br> (5)已定义了实现软件需求的优先级别<br> (6)软件需求已得到批准并按需求进行了调整<br> (7)针对软件需求的更改对成本、进度和技术影响，已进行了相应的评估<br> (8)建立了软件需求的基线，并与有关部门进行了沟通</p> 
</blockquote> 
<h4><a id="4_1314"></a>4)软件体系结构设计</h4> 
<p>1、意图</p> 
<blockquote> 
 <p>为软件的实现和按需求进行验证提供设计方案</p> 
</blockquote> 
<p>2、活动和任务</p> 
<blockquote> 
 <p>软件体系结构设计</p> 
</blockquote> 
<p>3、结果</p> 
<blockquote> 
 <ul><li>开发一种软件体系结构设计，描述实现该软需求的软件项</li><li>设计每一软件项的内部接口和外部接口</li></ul> 
</blockquote> 
<h4><a id="5_1325"></a>5）软件验证过程</h4> 
<p>1、意图:证明软件产品是否满足了所规约的需求<br> 2、活动和任务</p> 
<blockquote> 
 <ul><li>过程实现</li><li>验证</li></ul> 
</blockquote> 
<p>3、结果</p> 
<blockquote> 
 <p>(1)开发并实现了验证策略<br> (2)标识了验证准则<br> (3)执行了所需要的验证活动<br> (4)标识并记录了缺点<br> (5) 给出了可用于客户和其它参与人员的验证活动的结果</p> 
</blockquote> 
<h4><a id="6_1338"></a>6）软件确认过程</h4> 
<p>1、意图:证实所期望使用的软件产品是否满足需求<br> 2、活动和任务</p> 
<blockquote> 
 <ul><li>过程实现</li><li>确认</li></ul> 
</blockquote> 
<p>3、结果</p> 
<blockquote> 
 <ul><li>开发并实现了确认策略</li><li>标识了所有需要的软件工作产品的确认准则</li><li>执行了所需要的确认活动</li><li>标识并记录了发现的问题</li><li>提供了证据证明:软件产品能够按照用户所期望的方式来使用</li><li>给出了可用于客户和其他参与人员的验证活动结 果</li></ul> 
</blockquote> 
<h3><a id="3_1352"></a>3、应用说明</h3> 
<p>是对标准“ISO/IEC系统与软件工程-软件生存周期过程12207-2008”的应用说明<br> 1、系统和软件</p> 
<blockquote> 
 <ul><li>软件是整个系统的组成部分</li><li>区分系统需求分析和软件需求分析</li></ul> 
</blockquote> 
<p>2、与《ISO IEC系统生存周期15288》的关系</p> 
<blockquote> 
 <ul><li>当系统中包括非常重要的非软件因素时，要应用《ISO IEC系统生存周期15288》</li></ul> 
</blockquote> 
<p>3、组织层和项目层</p> 
<blockquote> 
 <p>项目可能由组织执行</p> 
</blockquote> 
<p>4、过程之间的时序关系</p> 
<blockquote> 
 <ul><li>没有明确过程、活动、任务之间的时间依赖的序列。</li><li>支持活动之间的迭代和再现</li></ul> 
</blockquote> 
<p>5、过程分解</p> 
<blockquote> 
 <p>把过程划分为一些小的“片段”</p> 
</blockquote> 
<p>6、生存周期模型和阶段</p> 
<blockquote> 
 <ul><li>用生存周期模型对系统成软件产品的生有模型化</li><li>模型由阶段组成</li></ul> 
</blockquote> 
<p>7、剪裁</p> 
<blockquote> 
 <p>针对特定的情况，修改生存周期过程</p> 
</blockquote> 
<p>***重要(简答题)<br> (概念，优缺点，不同点)</p> 
<h3><a id="4_1380"></a>4、软件生存周期模型</h3> 
<p>含义:是一个包含软件产品开发、运行和维护中有关过程、活动和任务的框架，覆盖了从该系统的需求定义到系统的使用终止。<br> 作用:不但为软件开发确定了一些抽象层，还确定了每一抽象层之间的基本关系</p> 
<ul><li>瀑布模型</li><li>增量模型</li><li>演化模型</li><li>螺旋模型</li><li>喷泉模型</li></ul> 
<h4><a id="1_1389"></a>1）瀑布模型</h4> 
<p><img src="https://images2.imgbox.com/b0/d0/Wf3OX75s_o.png" alt="image.png"></p> 
<h5><a id="_1391"></a>瀑布模型的原理</h5> 
<ol><li>自上而下具有相互衔接的固定顺序。</li><li>每一阶段的输入，即工作对象以及本阶段的工作成果，作为输出传送到下一阶段。</li></ol> 
<h5><a id="_1395"></a>瀑布模型的贡献</h5> 
<ol><li>在决定系统怎样做之前存在一个需求阶段，它鼓励对系统做什么有一个规约。</li><li>在系统构造之前有一个设计阶段，它鼓励规划系统结构</li><li>每一阶段都有评审，允许获取方和用户的参与</li><li>前一步作为下一步被认可的、文档化的基线</li></ol> 
<h5><a id="_1401"></a>瀑布模型存在的问题</h5> 
<ol><li>要求客户能够完整、正确和清晰地表达他们的需求，并要求人员一开始就理解这一应用。</li><li>由于需求的不确定性，使设计、编码和测试阶段都可能发生延期，并且当项目接近结束时，出现了大量的集成和测试工作</li><li>在开始的阶段中，很难评估真正的进度状态，并且直到项目结束之前都不能演示系统的功能。</li><li>在一个项目的早期阶段，过分地强调了基线和里程碑，并可能需要花费更多的时间用于建立一些用处不大的文档。</li></ol> 
<h4><a id="2_1407"></a>2）增量模型</h4> 
<ol><li>增量模型融合了瀑布模型的基本成分(重复应用）和原型实现的迭代特征，该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”</li><li>前提: 需求可结构化</li><li>适用于“技术驱动”的软件产品开发。</li></ol> 
<h5><a id="_1412"></a>原理</h5> 
<p><img src="https://images2.imgbox.com/3b/99/urX3elAY_o.png" alt="image.png"></p> 
<h5><a id="_1414"></a>增量模型的优点</h5> 
<ol><li>第一个可交付版本所需的成本和时间较少</li><li>由于很快发布第一个版本，可以减少用户需求的变更</li><li>允许增量投资，即开始时只对一个或两个增量投资</li></ol> 
<h5><a id="_1419"></a>增量模型的缺点</h5> 
<ol><li>如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定。</li><li>如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布。</li><li>由于进度和配置的复杂性，可能会增大管理成本和超出组织的能力。</li></ol> 
<h4><a id="3_1424"></a>3）演化模型</h4> 
<ol><li>演化模型是一种全局的软件(或产品) 生存周期模型属于迭代开发方法</li><li>演化模型主要针对事先不能完整定义需求的软件开发</li><li>该模型可以表示为:第一次迭代(需求-&gt;设计-&gt;实现-&gt;测试-&gt;集成)-&gt;反馈-&gt;第二次迭代(需求-&gt;设计-&gt; 实现-&gt;测试-&gt;集成)-&gt;反馈-&gt;··…</li></ol> 
<h5><a id="_1429"></a>演化模型的优点</h5> 
<ol><li>任何功能一经开发就能进入测试以便验证是否符合产品需求。</li><li>帮助导引出高质量的产品要求</li><li>减少软件开发活动的盲目性</li></ol> 
<h5><a id="_1434"></a>演化模型的不足</h5> 
<p>很容易弱化需求分析阶段的工作。</p> 
<h4><a id="4_1436"></a>4）螺旋模型</h4> 
<ol><li>螺旋模型是在“瀑布模型”和演化模型的基础上，加入两者都忽略的风险分析所建立的一种软件开发模型</li><li>螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，继而做出应有的反应</li><li>因此特别适用于庞大、复杂并具有高风险的系统</li></ol> 
<blockquote> 
 <p>每一个螺旋都得考虑风险分析</p> 
</blockquote> 
<h5><a id="_1443"></a>原理图</h5> 
<p><img src="https://images2.imgbox.com/2a/7a/OsB5O8r3_o.png" alt="image.png"></p> 
<h5><a id="_1445"></a>工作过程</h5> 
<p>(1)制定计划:确定软件目标，选定实施方案，弄清项目开发的限制条件;<br> (2) 风险分析:分析评估所选方案，考虑如何识别和消除风险;<br> (3)实施工程:实施软件开发和验证<br> (4)客户评估:评价开发工作，提出修正建议，制定下一步计划。</p> 
<blockquote> 
 <p>下一步重复，螺旋上升</p> 
</blockquote> 
<h5><a id="_1452"></a>螺旋模型的特点</h5> 
<ol><li>螺旋模型很大程度上是一种“风险驱动”的方法体系。</li><li>螺旋模型关注解决问题的基本步骤</li></ol> 
<h4><a id="5_1456"></a>5）喷泉模型</h4> 
<ol><li>喷泉模型是一种以用户需求为动力，以过象为驱动的模型，主要用于采用对象技术的软件开发项目。</li><li>喷泉模型认为:软件开发过程自下而上周期的各阶段是相互迭代和无间隙的特性。</li></ol> 
<h5><a id="_1460"></a>喷泉模型原理图</h5> 
<p><img src="https://images2.imgbox.com/c3/b6/UZsRMd3C_o.png" alt="image.png"></p> 
<blockquote> 
 <p>喷泉模型主要用于支持面向对象技术的软件开发</p> 
</blockquote> 
<h3><a id="5_1464"></a>5、过程规划与管理</h3> 
<ol><li>属于“组织上项目使能过程组</li><li>包括四个环节</li></ol> 
<blockquote> 
 <ul><li>过程规划 §</li><li>过程检测 ©</li><li>过程执行(D)</li><li>过程调整 (A)</li></ul> 
</blockquote> 
<h4><a id="1_1473"></a>1）过程建立</h4> 
<p>1、选择软件生存周期模型<br> 2、细化所选择的生存周期模型<br> 3、为每一个活动或任务标识合适的实例数目4、确定活动的时序关系，并检查信息流<br> 5、建立过程计划的文档</p> 
<blockquote> 
 <p>成果:项目的过程计划</p> 
</blockquote> 
<h4><a id="2_1480"></a>2）过程监控</h4> 
<ol><li>软件生存周期过程的监控</li><li>软件生存周期过程改变所产生的影响的评估</li><li>改变的实施</li><li>实现改变</li></ol> 
<h3><a id="_1486"></a>表格总结</h3> 
<p>***重要</p> 
<table><thead><tr><th>生命周期模型</th><th>特点</th></tr></thead><tbody><tr><td>瀑布模型</td><td>自上而下具有相互衔接的固定顺序</td></tr><tr><td>增量模型</td><td>适用于“技术驱动”的软件产品开发</td></tr><tr><td>演化模型</td><td>主要针对事先不能完整定义需求的软件开发</td></tr><tr><td>螺旋模型</td><td>强调风险分析，是一种风险驱动的方法体系</td></tr><tr><td>喷泉模型</td><td>以用户需求为动力，以对象为驱动的模型</td></tr></tbody></table> 
<p>***重要<br> 《ISO /IEC软件生存周期过程12207一1995》标准将过程分为三类：</p> 
<table><thead><tr><th>过程类</th><th>包含过程</th></tr></thead><tbody><tr><td>基本过程</td><td>获取过程；供应过程；开发过程；运行过程；维护过程</td></tr><tr><td>支持过程</td><td>文档过程；配置管理过程；质量保证过程；验证过程；确认过程；联合评审过程；审计过程；问题解决过程</td></tr><tr><td>组织过程</td><td>管理过程；基础设施过程；培训过程；改进过程</td></tr></tbody></table> 
<h3><a id="_1506"></a>小结</h3> 
<ol><li>本章介绍了软件工程的过程规划技术以及过程监控</li><li>软件工程需要做哪些工作，《ISO/IEC系统与软件工程-软件生存周期过程12207-1995 》和ISO/IEC系统与软件工程-软件生存周期过程12207-2008</li><li>软件开发工作的组织: 软件生存周期模型软件项目的过程规划和监控。</li></ol> 
<h2><a id="CMMI_1511"></a>八、集成化能力成熟度模型CMMI</h2> 
<p>仅当对软件过程予以有效管理时，才能实现有效的软件工程<br> 本章关注的是软件过程的改善问题集成产品能力成熟度模型CMMI是针对系统/产品开发的能力成熟度模型，包含一些最佳实践，覆盖了产品从概念到交付和维护的整个生存周期</p> 
<blockquote> 
 <ul><li>CMMI的核心理念</li><li>CMMI的模型部件</li><li>能力等级的划分及各等级的特征</li><li>成熟度等级的划分及各等级的特征</li><li>能力等级和成熟度等级的基本关系</li></ul> 
</blockquote> 
<h3><a id="1_1520"></a>1、背景和原理</h3> 
<h4><a id="1CMMI_1521"></a>1）CMMI的含义</h4> 
<p>Capability Matur ity Model Integration forDevelopment ，集成化能力成熟度模型是由美国国防部与卡内基-梅隆大学和美国国防工业协会共同开发和研制的。</p> 
<h4><a id="2CMMI_1523"></a>2）CMMI的目的</h4> 
<p>其目的是帮助软件企业对软件工程过程进行管理和改进，增强开发与改进能力，从而能按时地、不超预算地开发出高质量的软件</p> 
<blockquote> 
 <p>过程改进</p> 
</blockquote> 
<h4><a id="3CMMI__1527"></a>3）CMMI的构成 **重要</h4> 
<p><img src="https://images2.imgbox.com/8c/7f/eXR6ubaa_o.png" alt="image.png"></p> 
<h4><a id="4CMMI_1529"></a>4）CMMI的应用</h4> 
<p>过程途径的基本假设: 系统或产品的质量高度受开发和维护中所使用的过程质量的影响<br> 质量支撑点:</p> 
<blockquote> 
 <ul><li>人员</li><li>规程和方法</li><li>工具和设备</li></ul> 
</blockquote> 
<h3><a id="2CMMI_1536"></a>2、CMMI的模型部件</h3> 
<ul><li>CMMI是一种过程改善框架</li><li>过程改善:是指人为设计的一个活动程序，其目的是改进组织的过程性能和成熟度，并改进这一程序的结果</li></ul> 
<p>CMMI的模型部件</p> 
<ul><li>由一些过程域组成，过程域有自己的确定专用目标和公共目标。（实心圆角矩形）</li></ul> 
<p><img src="https://images2.imgbox.com/92/88/q58yFYsm_o.jpg" alt=""></p> 
<ul><li>每个专用目标和公共目标的实现，分别依赖一些实践。（实心菱形）</li></ul> 
<p><img src="https://images2.imgbox.com/d7/0d/N4HOsveb_o.jpg" alt=""></p> 
<ul><li>每个专用实践有自己的子实践和确定的典型工作产品符号:实心椭圆，资料性部件。</li></ul> 
<p><img src="https://images2.imgbox.com/e3/0c/8oycqG2i_o.jpg" alt=""></p> 
<ul><li>每个过程域还有意图陈述、简介性注释以及相关过程域</li></ul> 
<blockquote> 
 <p>专用目标:过程域特有的目标<br> 公用目标:几个过程域都可能要用到的目标<br> 目标实现需要依赖实践</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c6/1c/I7D7AcME_o.png" alt="image.png"></p> 
<h4><a id="1_1561"></a>1）过程域</h4> 
<ol><li>过程域：一个业务域中一束相关的实践，当它们一起得以实现时，就满足被认为对该过程域的改善具有重要作用的一组条件。</li><li>CMMI有22个过程域，分为四类</li><li>见下表所示:</li></ol> 
<p>**重要(选择题)</p> 
<table><thead><tr><th>过程域类名</th><th>包括的过程域</th></tr></thead><tbody><tr><td>项目管理类</td><td>规划、监控、定量项目管理、集成项目管理、风险管理、提供方协议管理</td></tr><tr><td>工程类</td><td>需求开发、需求管理、技术解决方案、产品集成、确认、验证</td></tr><tr><td>支持类</td><td>配置管理、过程和产品质量保证、测量与分析原因分析与解决、决策分析与解决</td></tr><tr><td>过程管理类</td><td>组织过程定义、组织过程性能、组织过程培训、组织过程关注、组织创新与部署</td></tr></tbody></table> 
<h4><a id="2_1576"></a>2）专用目标</h4> 
<ol><li>一个过程域中都有一个或多个专用目标</li><li>描述该过程域必须呈现的一些独有特征</li><li>专用目标可用于帮助确定一个过程域是否得以满足</li></ol> 
<h4><a id="3_1581"></a>3）专用实践</h4> 
<ol><li>对于达到专用目标是重要的活动</li><li>期望以专用实践所描述的活动，会导致达到一个过程域的专用目标。</li></ol> 
<h4><a id="4_1585"></a>4）共用目标和共用实践</h4> 
<ol><li>可用于多个过程域</li></ol> 
<h4><a id="5_1588"></a>5）典型工作产品</h4> 
<ol><li>专用实践所产生的输出样品</li></ol> 
<blockquote> 
 <p>专用实践“依据项目，监视项目规划参数的实际值“</p> 
</blockquote> 
<ol start="2"><li>典型工作产品是:重大偏差的记录</li></ol> 
<h4><a id="6_1594"></a>6）子实践</h4> 
<ol><li>子实践是对专用实践、共用实践的详细描述</li></ol> 
<blockquote> 
 <p>专用实践：针对已标识的问题，采取纠正措施<br> 子实践：针对已标识的问题，确定所需要的适当措施，并建立相应的文档</p> 
</blockquote> 
<h4><a id="7_1600"></a>7）共用实践的精化</h4> 
<ol><li>为一个共用实践唯一地应用于一个过程域，提供了 相关的指导</li></ol> 
<h4><a id="8_1603"></a>8）意图描述</h4> 
<ol><li>用来描述过程域的意图</li></ol> 
<blockquote> 
 <p>“组织过程定义”过程域的意图: 建立并维护一组可用的组织过程资产和工作环境标准</p> 
</blockquote> 
<h4><a id="9_1608"></a>9）简介性解释</h4> 
<p>用来描述该过程域中所涉及的主要概念</p> 
<blockquote> 
 <p>在项目规划过程域中，规划从需求开始，定义产品和项目</p> 
</blockquote> 
<h4><a id="10_1612"></a>10）相关过程域</h4> 
<ol><li>用来描述该过程域所引用的相关过程域</li><li>反映了过程域之间的关系</li></ol> 
<h3><a id="3CMMI_1616"></a>3、CMMI的等级</h3> 
<p>两种类型的等级</p> 
<ol><li>能力等级：是一种过程改善路径，该路径可使组织针对单一过程域不断改善该过程域</li><li>成熟度等级：是一种过程改善路径，该路径可使组织针对–组过程域不断改善一组相关的过程域</li></ol> 
<h4><a id="1_1621"></a>1）能力等级</h4> 
<h5><a id="1_1622"></a>1、过程能力:</h5> 
<ul><li>遵循一个过程可达到的预期结果的程度</li><li>表征组织对一个过程域的改善，是不断改善一个给定的过程域的一种手段</li></ul> 
<h5><a id="2_1626"></a>2、能力等级：</h5> 
<p>包含一个共性目标及其相关的共性实践，它们与一个过程域相关联，能够改进组织同那个过程域相关联的过程<br> **重要</p> 
<table><thead><tr><th>能力等级</th><th>描述</th></tr></thead><tbody><tr><td>能力等级0</td><td>未完成级:过程不完整</td></tr><tr><td>能力等级1</td><td>已执行级:实现了过程域的特定目标</td></tr><tr><td>能力等级2</td><td>已管理级:建立了基本的项目管理过程来跟踪费用进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。</td></tr><tr><td>能力等级3</td><td>已定义级:按照组织的裁减指南从组织的标准过程中裁减出来的一个已管理(能力等级 2)过程</td></tr><tr><td>能力等级4</td><td>已量化管理级:使用统计和其他定量技巧控制的个已定义(能力等级 3) 过程。</td></tr><tr><td>能力等级5</td><td>已持续优化级:经过改进的一个量化管理过程</td></tr></tbody></table> 
<h4><a id="2_1639"></a>2）组织成熟度等级</h4> 
<ol><li>成熟度等级是指达到预先定义的一组过程域所有目标的一种过程改善等级。一个成熟度等级是由预先定义的一个过程域集及其相关的一些专用实践和共用实践组成的。</li><li>CMMI的阶段式表示模型定义了5个成熟度等级，在持续的过程改进上，每一等级都是构成下一阶段基础的一个层次，这些等级用从1到5的数字表示。<br> | 成熟度等级 | 描述 |<br> | — | — |<br> | 成熟度等级1:初始级 | 过程是混乱的，应付式的。 |<br> | 成熟度等级2:已管理 | 能确保过程按照预定方针得到计划和执行 |<br> | 成熟度等级3:已定义 | 过程得到了很好地描述和理解，并应用标准、规程、工具及方法来表现。 |<br> | 成熟度等级4:量化管理 | 组织和项目为质量和过程绩效建立了量化目标并将其用作管理过程的标准 |<br> | 成熟度等级5:持续优化 | 点关注通过渐进性和革新性过程改边和技术改进来持续地改进过程的绩效 |</li></ol> 
<h5><a id="_1651"></a>成熟度等级包含的过程域</h5> 
<p><img src="https://images2.imgbox.com/d7/ee/J7MSGUdI_o.png" alt="image.png"></p> 
<h5><a id="_1653"></a>成熟度等级与能力等级的关系</h5> 
<p>(1)为了达到成熟度2级，2级所包含的所有过程域必须达到能力等级2或更高级<br> (2)为了达到成熟度3级，2级、3级所包含的所有过程域必须达到能力等级3或更高级<br> (3)为了达到成熟度4级，2、3、4级所包含的所有过程域必须达到能力等级3或更高级</p> 
<h3><a id="4_1657"></a>4、过程域举例</h3> 
<p>两个过程域:项目规划 (2级) 和需求开发过程 (3级）</p> 
<h4><a id="1_1659"></a>1）项目规划</h4> 
<p>1、意图:建立并维护项目活动计划的定义<br> 2、所要满足的专用目标、共用目标以及所要实施的实践:</p> 
<h5><a id="_1662"></a>专用目标与专用实践</h5> 
<p><img src="https://images2.imgbox.com/c7/52/uXzMkh1y_o.png" alt="image.png"></p> 
<h5><a id="_1664"></a>共用目标和共用实践</h5> 
<table><thead><tr><th>共用目标</th><th>共用实践</th></tr></thead><tbody><tr><td>GG2: 共用目标2</td><td></td></tr><tr><td>把过程制度化为一个已管理过程。</td><td></td></tr><tr><td>对达到共用目标1的专用实践实施了P-D-C-A。</td><td>GP2.1:建立组织策略</td></tr><tr><td>GP2.2:规划过程</td><td></td></tr><tr><td>GP2.3:提供资源GP2.4:指派责任GP2.5:培训人员GP2.6:管理配置</td><td></td></tr><tr><td>GP2.7:标识相关利益方的参与GP2.8:监控过程</td><td></td></tr><tr><td>GP2.9:客观地评估符合型</td><td></td></tr><tr><td>GP2.10: 高层管理视角评审状态</td><td></td></tr></tbody></table> 
<h4><a id="2_1676"></a>2）需求开发</h4> 
<p>1、意图<br> 生成并分析客户需求、产品需求和产品部件需求<br> 2、专用目标和专用实践</p> 
<h5><a id="_1680"></a>专用目标和专用实践</h5> 
<p><img src="https://images2.imgbox.com/05/e6/oXLJv4sY_o.png" alt="image.png"></p> 
<h5><a id="_1682"></a>共用目标和共用实践</h5> 
<table><thead><tr><th>共用目标</th><th>共用实践</th></tr></thead><tbody><tr><td>GG3：把过程制度化为一个已定义过程。</td><td>GP3.1:建立一个已定义过程</td></tr><tr><td>涉及需求开发过程的共用目标2的有关内容</td><td></td></tr><tr><td>GP3.2:收集改进信息</td><td></td></tr></tbody></table> 
<h3><a id="_1689"></a>小结</h3> 
<ol><li>针对开发的CMM是一个有关产品和服务的过程改善的成熟度模型，继承了三个源模型:软件CMM、系统工程CMM、集成产品开发CMM；</li><li>CMMI模型基于过程途径思想，通过过程把软件质量的3个支撑点:受训人员、规程和方法、工具，以开发所期望的系统/产品；</li><li>CMMI提供了两种过程改善路径，一个称为能力等级，另一个称为成熟度等级 ;</li><li>能力等级有6个等级:</li><li>成熟度等级包括4个过程组、5个等级</li></ol> 
<blockquote> 
 <p>注：本博客仅供学习和参考，内容较多，难免会有错误，请大家多多包涵哈🌸🌸<br> 参考视频学习（软件工程-&gt;赵守香）</p> 
</blockquote> 
<p>欢迎您在评论区留下您宝贵的建议<br> 完结撒花啦~~~🌸🌸</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d0af5dd3f83658c9f39f7915e4b2dd7b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【爬虫】data: image/png； base64图片数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/001d02521808bb3b75042f2928d956ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Elasticsearch7.x——Search API详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>