<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android4.0 SDK功能详解 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android4.0 SDK功能详解" />
<meta property="og:description" content="我在eoe的论坛找到的，就复制过来了，跟大家分享一下。
Android 4.0 平台
API等级：14 Android 4.0 是一次重要的平台发布版，为用户和应用程序开发者增加了大量的新特性。在下面我们将讨论的所有新特性和API中，因为它将 Android 3.x 版本中广泛使用的API和全息图像主题带给了小屏幕设备，因此我们说 Android 4.0 是一次重要的平台发布版。作为一名开发者，现在你拥有了单一的平台和统一的 API 框架，使你可以开发，并通过一个APK 来发布你的应用程序，并且可以为运行相同版本 Android(Android 4.0[API级别14]或以上版本) 的手机、平板电脑和其他设备提供优化了的用户体验。
Social APIs in Contacts Provider
User Profile
最新的android包含了一个机主的个人档案，在 ContactsContract.Profile表里，通过新建一个ContactsContract.RawContacts记录， 社交应用程序可以维护一个用户个人资料数据。这个新的联系人数据表的定义不同于以往的联系人数据表的定义，你必须在 CONTENT_RAW_CONTACTS_URI表里新建1个内容。联系人资料在这个表中被加上了&#34;Me&#34;标签，只能单一用户可见。
增加一个新的联系人资料需要 WRITE_PROFILE权限，读取该联系人资料表需要READ_PROFILE权限。大多数的应用程序需要用户资料，甚至是提供数据给该资料。但是读取用户资料是一个敏感的权限，你应该期望用户对需要读取用户资料的应用保持怀疑态度。
Invite Intent
INVITE_CONTACT intent 允许一个应用按照用户意愿，邀请一个联系人进入某个社会网络的行为。接收程序通过它邀请指定的人加入社会网络。大部分的应用将会在这个操作的接收端。例如，内置的people应用程序里，用户详细信息列表上列出了该用户使用的社交应用，用户可以通过社交应用上的&#34;添加联接&#34;按钮调用 invite intent 连接两个人的社会网络。
为了让你的社交应用程序出现在“添加链接”按钮的列表里，你的应用必须提供一个同步适配器来同步你的社交网络中的联系人信息。你必须通过对你的应用程序的同步配置文件增加inviteContactActivity属性 告知系统你的应用回应 INVITE_CONTACT intent 。activity 必须包含一个完全合格的限定名系统才会给其发送invite intent，相关activity 才会检索意图响应的数据，邀请相关的人加入社会网络或者与手机使用者建立连接。
Large photos
android现在支持高分辨率的联系人照片，当你将一个照片放到联系人记录中的时候，系统会把它处理成96x96的缩略图（像之前那样），和一个256x256 文件形式的的显示图片（该系统选择的确切尺寸，在未来可能会有所不同）。你能够为联系人添加一个大的照片在PHOTO列，系统会再加工成相应的缩略图显示照片记录。
Contact Usage Feedback
新的ContactsContract.DataUsageFeedback APIs 允许你追踪用户使用特定的方法联系其他人的频度，例如用户多久使用每个电话号码或邮件。此信息有助于改善与每个人相关联的每个接触方法的排名，并提供更好的建议去联系每个人联系。
Calendar (日历) Provider
新的日历API允许我们读，增加，编辑和删除存储在Calendar Provider的日历、事件与会者，提醒和警示， 各种应用程序和部件可以使用这些API来读取和修改日历事件。然而，一些最引人注目的用例的是同步适配器能够通过Calendar Provider同步其他日历服务的用户的日历，能够一所有的用户事件提供一个统一的存放位置。例如，GOOGLE日历事件，是同步的google日历同步适配器，允许这些事件在android内置的日历软件中查看。
Event intent
如果你想要做的是用户的日历添加事件，你可以使用&#34;vnd.android.cursor.item/event&#34;类型 的ACTION_INSERT intent 开始在日历应用程序的活动，创建新的事件。使用的意图，不需要任何权限并且您可以指定下列额外的事件的详细信息：（事件名，事件开始时间，结束时间，地点，描述，等等。）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/10f747c84347facec2e293c8c98af9ff/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-10-21T14:25:00+08:00" />
<meta property="article:modified_time" content="2011-10-21T14:25:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android4.0 SDK功能详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>我在eoe的论坛找到的，就复制过来了，跟大家分享一下。</p> 
<p>Android 4.0 平台<br><br><span style="color:#FF0000;"><strong>API等级：14 </strong></span><br><br><span style="color:#373737;">Android 4.0 是一次重要的平台发布版，为用户和应用程序开发者增加了大量的新特性。在下面我们将讨论的所有新特性和API中，因为它将 Android 3.x 版本中广泛使用的API和全息图像主题带给了小屏幕设备，因此我们说 Android 4.0 是一次重要的平台发布版。作为一名开发者，现在你拥有了单一的平台和统一的 API 框架，使你可以开发，并通过一个APK 来发布你的应用程序，并且可以为运行相同版本 Android(Android 4.0[API级别14]或以上版本) 的手机、平板电脑和其他设备提供优化了的用户体验。</span><br></p> 
<p><span style="color:#FF0000;"><strong>Social APIs in Contacts Provider</strong></span><br><br>User Profile<br> 最新的android包含了一个机主的个人档案，在 ContactsContract.Profile表里，通过新建一个ContactsContract.RawContacts记录， 社交应用程序可以维护一个用户个人资料数据。这个新的联系人数据表的定义不同于以往的联系人数据表的定义，你必须在 CONTENT_RAW_CONTACTS_URI表里新建1个内容。联系人资料在这个表中被加上了"Me"标签，只能单一用户可见。<br><br> 增加一个新的联系人资料需要 WRITE_PROFILE权限，读取该联系人资料表需要READ_PROFILE权限。大多数的应用程序需要用户资料，甚至是提供数据给该资料。但是读取用户资料是一个敏感的权限，你应该期望用户对需要读取用户资料的应用保持怀疑态度。<br><br>Invite Intent<br> INVITE_CONTACT intent 允许一个应用按照用户意愿，邀请一个联系人进入某个社会网络的行为。接收程序通过它邀请指定的人加入社会网络。大部分的应用将会在这个操作的接收端。例如，内置的people应用程序里，用户详细信息列表上列出了该用户使用的社交应用，用户可以通过社交应用上的"添加联接"按钮调用 invite intent 连接两个人的社会网络。<br><br> 为了让你的社交应用程序出现在“添加链接”按钮的列表里，你的应用必须提供一个同步适配器来同步你的社交网络中的联系人信息。你必须通过对你的应用程序的同步配置文件增加inviteContactActivity属性 告知系统你的应用回应 INVITE_CONTACT intent 。activity 必须包含一个完全合格的限定名系统才会给其发送invite intent，相关activity 才会检索意图响应的数据，邀请相关的人加入社会网络或者与手机使用者建立连接。<br><br>Large photos<br>android现在支持高分辨率的联系人照片，当你将一个照片放到联系人记录中的时候，系统会把它处理成96x96的缩略图（像之前那样），和一个256x256 文件形式的的显示图片（该系统选择的确切尺寸，在未来可能会有所不同）。你能够为联系人添加一个大的照片在PHOTO列，系统会再加工成相应的缩略图显示照片记录。<br><br>Contact Usage Feedback<br>新的ContactsContract.DataUsageFeedback APIs 允许你追踪用户使用特定的方法联系其他人的频度，例如用户多久使用每个电话号码或邮件。此信息有助于改善与每个人相关联的每个接触方法的排名，并提供更好的建议去联系每个人联系。<br><br><br><br><span style="color:#FF0000;"><strong>Calendar (日历) Provider</strong></span><br><br> 新的日历API允许我们读，增加，编辑和删除存储在Calendar Provider的日历、事件与会者，提醒和警示， 各种应用程序和部件可以使用这些API来读取和修改日历事件。然而，一些最引人注目的用例的是同步适配器能够通过Calendar Provider同步其他日历服务的用户的日历，能够一所有的用户事件提供一个统一的存放位置。例如，GOOGLE日历事件，是同步的google日历同步适配器，允许这些事件在android内置的日历软件中查看。<br><br>Event intent<br> 如果你想要做的是用户的日历添加事件，你可以使用"vnd.android.cursor.item/event"类型 的ACTION_INSERT intent 开始在日历应用程序的活动，创建新的事件。使用的意图，不需要任何权限并且您可以指定下列额外的事件的详细信息：（事件名，事件开始时间，结束时间，地点，描述，等等。）<br><br><br><span style="color:#FF0000;"><strong>Voicemail Provider</strong></span><br><br> 新的Voicemail Provider允许应用程序添加语音信箱设备，使目前所有用户的语音邮件在一个单一的视觉呈现。举个例子，很有可能，用户拥有多个语音邮件的来源，如从手机服务供应商和其他VoIP或其他替代的语音服务之一。这些应用可以通过Voicemail Provider APIs添加他们的语音邮箱到该手机中。内置的Phone应用会呈现所有的语音邮箱给用户一个统一的展示。虽然Phone应用是系统唯一的一个应用能够读取所有的语音邮件信箱，但是每个提供语音邮件服务的应用能够读他们加到系统中的邮箱（不能读其他服务的）。<br><br> 由于现在的API不支持第三方应用程序去读系统中所有的语音信箱，他们能够用的api操作是他们提供给用户的语音邮箱。<br><br><br><br><span style="color:#FF0000;"><strong>Multimedia（多媒体）</strong></span><br><br> Android4.0增加了几个新的API ，使应用程序能够与照片，影片，和音乐等媒体交互。<br><br>Media Effects<br> 一个新的媒体效果框架，让您适用于各种图像和视频的视觉效果。例如，图像效果框架让您可以轻松地修复红眼，将图像转换为灰度，亮度调整，调整饱和度，旋转图像，应用鱼眼镜头的效果，等等。该效果框架执行在GPU上，以获得最大的性能。<br><br> 为了最佳效果，效果框架直接应用了OpenGL的纹理，您的应用程序必须有一个有效的OpenGLcontext，才可以使用效果框架的API。应用效果的纹理可以用于位图，视频，甚至相机。不过，也有一定的限制，纹理必须满足：<br> 1、他们必须绑定到一个GL_TEXTURE_2D的纹理图像<br> 2、他们必须至少包含一个mipmap的级别<br><br>Remote control client<br> 新RemoteControlClient允许媒体播放器，使媒体播放器能够被远程控制，如设备锁定屏幕。媒体播放器还可以使遥控器上的显示目前正在播放的媒体，如进度信息和专辑封面的信息。<br><br>Media player<br> 1、加入网络权限就可以使媒体播放器播放网络上的音乐。必须不要忘记加上权限。<br> 2、允许你定义播放习惯。<br><br>Media types<br> 本次的4.0增加了支持的媒体种类:<br> 1、HTTP / HTTPS的实时流媒体协议第3版<br> 2、ADTS的原料AAC音频编码<br> 3、WEBP图像<br> 4、Matroska的视频</p> 
<p></p> 
<p><span style="color:#FF0000;"><strong>Camera类</strong></span><br><br> Camera类包括用于(人脸检测和控制焦距和感光区)的API 。<br><br>face detection 人脸检测<br><br> 相机的应用程序现在可以提高自己的能力啦。作为一门人脸识别的学科，不仅检测人脸特征，而且还检测眼睛和嘴巴。如果你想要使用你的相机来做人脸识别的程序，你必须使用setFaceDetectionListener方法来注册 Camera.FaceDetectionListener对象。然后，您可以启动您的camera surface ，并调用startFaceDetection方法开始检测人脸。<br><br> 如果你实现了 Camera.FaceDetectionListener接口，当系统检测到一个或者更多个人脸时，便会向所调用的接口回调onFaceDetection方法，包括一组Camera.Face 对象。<br><br> Camera.Face类的实例提供有关于人脸识别的各种各样信息，其中包括：<br> 1、一个相对与相机当前视野的所指定人脸边界的矩形框( Rect 对象)。<br> 2、一个1到100之间并用于人脸识别精确度的整数。<br> 每个所检测到的人脸，会分配独一无二的ID。<br> 当识别到眼睛和嘴巴时，都会生成一个 Point 对象。该对象指定眼睛或者嘴巴的空间位置。<br><br> 注意：并不是所有设备都支持人脸识别，你应该先调用getMaxNumDetectedFaces() 方法来保证返回的值大于0，说明你的设备是支持该技术的。当然，还有一些设备可以支持人脸识别，但是不支持眼睛和嘴巴的鉴定，在这种情况下，Camera.Face 对象为空值。<br><br>焦距和感光区域<br><br> 照相机程序现在可以控制焦距和感光的白平衡以及自动曝光。 这两个功能使用新的Camera.Area类来指定照相所集中和所计算的出来的当前视图区域。 Camera.Area类的实例定义该视图边界的矩形区域和面积比重（相对于其他区域，该区域的重要性）。<br><br> 设置焦距或感光度之前，应首先调用getMaxNumFocusAreas()或getMaxNumMeteringAreas()方法。如果这些返回零，则该设备不支持相应的功能。<br><br> 设置焦距调用setFocusAreas() 方法；设置感光度调用setMeteringAreas()方法；这两种方法每次会返回包含所对应焦距或者感光度的Camera.Area 对象列表(List)。 例如，你可以实现一个功能，允许用户设置通过触摸一个预览区域，您再转化到重点领域Camera.Area对象和要求，重点放在该区域的场景，相机。 在现场的面积变化，在这一领域的重点或曝光将不断更新。<br><br>摄像头自动对焦<br><br> 现在，您可以启用连续自动对焦（CAF）拍照。 为了使你的照相程序调用连续自动对焦功能， 需要传递FOCUS_MODE_CONTINUOUS_PICTURE参数到setFocusMode()方法中 。 当准备拍摄照片，调用autoFocus()方法。Camera.AutoFocusCallback对象便立即收到一个回调来指示是否获得到了焦点。 接受到回调值后，如果还需要重新自动对焦，则必须调用cancelAutoFocus()方法。<br> 注意：连续自动对焦功能支持视频拍摄，使用FOCUS_MODE_CONTINUOUS_VIDEO参数。可以参考sdk9版本。<br><br>摄像头的其他功能<br><br> 在录制视频时，您可以调用takePicture()方法保存照片，同时不中断视频的拍摄。 但是，在这样做之前，你应该调用isVideoSnapshotSupported()方法来以确保硬件是否支持这个功能。<br><br> 使用setAutoExposureLock()和setAutoWhiteBalanceLock()方法可以锁定自动曝光和白平衡来防止用户更改这些属性。<br><br> 相机拍摄运行时，可以调用setDisplayOrientation()方法。 在以前的版本中，你只能在运行之前使用，但现在你可以在任何时候改变方向。<br><br>相机广播意图<br><br> Camera.ACTION_NEW_PICTURE ：这表明用户已经占据了新的照片。 内置的摄像头应用程序调用此广播，拍摄照片后，第三方的摄像头应用程序也应该拍摄照片后播出的这一意图。<br> Camera.ACTION_NEW_VIDEO ：这表明用户已经占据了一个新的视频。 内置摄像头的应用程序调用此广播后的视频记录和第三方的摄像头应用程序也应该拍摄视频后播放这一意图。<br><br><br><br><span style="color:#FF0000;"><strong>Android Beam (NDEF Push with NFC)</strong></span><br><br> Android的光束是一个新的NFC功能，允许您发送NDEF的邮件从一台设备到另一台（又称“NDEF推”的过程）。两款Android供电设备支持Android束接近时，数据传输启动（约4厘米），通常与他们的背上抚摸。内部的NDEF消息要共享设备之间的数据可以包含任何数据，例如，人民应用股的接触，采用Android的YouTube股份的视频和浏览器股网址梁。<br><br> 采用Android束的设备之间传输数据，您需要创建一个包含您要共享的信息，而您的活动是NdefMessage前台的NdefMessage。 然后，您必须通过NdefMessage到系统中的两种方法之一：<br> 1、定义一个单独的NdefMessage推，而在活动：<br> setNdefPushMessage()在任何时间设置您要发送的消息。 例如，你可以调用这个方法，并通过您NdefMessageNdefMessage在您的活动onCreate方法。 然后，每当Android的光束与另一个设备激活活动，而在前台，系统的NdefMessage发送到其他设备。<br> 2、定义NdefMessage推Android的梁开始的时间：<br> 实施NfcAdapter.CreateNdefMessageCallback ，在实施createNdefMessage方法返回您要发送的NdefMessage的。 然后通过NfcAdapter.CreateNdefMessageCallback实施setNdefPushMessageCallback<br><br> 在这种情况下，Android的光束是与另一个设备激活时，你的活动，而在前台， createNdefMessage来检索您要NdefMessage的NdefMessage。 这允许您定义NdefMessage只提供一次Android的光束被启动，如果邮件的内容可能会有所不同，整个活动的生活。<br><br> 如果你想运行一些特定的代码，一旦该系统已成功交付NDEF消息到其他设备，你可以NfcAdapter.OnNdefPushCompleteCallbackNfcAdapter.OnNdefPushCompleteCallback和setNdefPushCompleteCallback。 系统将调用onNdefPushComplete()时，邮件将被传递。<br><br> 在接收设备上，系统调度NDEF定期NFC标签以类似的方式推入消息。 该系统调用的意图ACTION_NDEF_DISCOVERED行动启动URL或一个MIME类型设置根据第一的活动，你想回应的活动，你可以声明意图过滤器的网址或你的应用程序关心的MIME类型。 欲了解更多关于标签的信息，调度NFC开发人员指南。<br> 如果你想你NdefMessage NdefMessage携带URI，你现在可以用方便的createUri NdefRecord Uri的对象是一个字符串或一个基于构造一个新NdefRecord NdefRecord 。 如果URI是一个特殊的格式，您希望您的应用程序也收到一个Android束事件期间，您应该为您的活动创造的意图过滤器使用相同的URI方案，以接收传入的NDEF消息。<br><br> 为了保证您的应用程序处理传入的NDEF消息，你也应该通过与您的“Android应用程序记录NdefMessage NdefMessage，即使其他应用程序过滤器相同的意图行动。您可以创建一个Android应用程序通过createApplicationRecord，通过它您的应用程序包的名称。当其他设备接收的的应用程序记录和多个应用程序，处理的指定意图的活动NDEF消息时，系统提供的消息，在应用程序中的活动（基础上的匹配应用程序记录）如果目标设备目前还没有安装您的应用程序，该系统采用的Andr​​oid应用程序的记录，推出Android市场和用户的应用程序以安装。<br><br> 如果您的应用程序不使用NFC API来执行NDEF推消息，则Android提供了一个默认的行为：当您的应用程序是在一台设备在前台和Android的光束被调用另一个Android的供电设备，其他设备接收到一个NDEF一个Android应用程序记录，确定您的应用程序的消息。 如果接收设备已安装的应用程序，系统启动它，如果它不安装，Android的市场开放，并把用户带到您的应用程序，以便安装它。<br><br> 你可以阅读更多有关Android的梁，在其他NFC功能的NFC基础开发指南。 对于一些示例代码使用Android束，看到的 Android 束演示。<br><br><br><br><span style="color:#FF0000;"><strong>Wi-Fi Direct</strong></span><br><br> 现在，Android的支持Wi - Fi的直接点对点点对点（P2P）Android系统的供电设备和其他类型的设备，没有一个热点或互联网连接之间的连接。 Android框架提供了一套Wi - Fi的P2P的API，允许你去发现和连接到其他设备时，每个设备的Wi - Fi的直接支持，然后沟通跨越距离远远长于蓝牙连接迅速​​连接。<br><br> android.net.wifi.p2p ，一个新的软件包，包含所有的API执行同行等连接与Wi - Fi。 你需要与主类是WifiP2pManager ，您可以调用getSystemService(WIFI_P2P_SERVICE)收购。WifiP2pManager包括API，允许您：<br> 1、您P2P连接的应用程序通过调用initialize<br> 2、探索通过调用附近的设备discoverPeers<br><br> 开始通过调用P2P连接connect以及一些其他的接口和类是必要的，如：<br> WifiP2pManager.ActionListener接口，让您能够接收的操作时，如发现同行或连接到他们的成功或失败的回调。<br> WifiP2pManager.PeerListListener界面，您可以收到有关发现同行的信息。 回调提供了一个WifiP2pDeviceList ，您可以从中检索一个WifiP2pDevice范围内的每个设备对象和获取信息，如设备的名称，地址，设备类型，设备支持的WPS配置。<br><br> WifiP2pManager.GroupInfoListener界面，您可以收到一个P2P组信息。 回调提供了一个WifiP2pGroup对象，它提供了所有者，网络名称和密码的信息，如组。<br><br> WifiP2pManager.ConnectionInfoListener界面，您可以得到当前连接的信息。 回调提供了一个WifiP2pInfo对象，它具有信息，如一个组是否已经形成，谁是该组的所有者。<br><br> 为了使用的Wi - Fi P2P的API，你的应用程序必须要求以下用户权限：<br> 1、ACCESS_WIFI_STATE<br> 2、CHANGE_WIFI_STATE<br> 3、INTERNET （虽然你的应用程序不技术上连接到互联网，沟通的Wi - Fi标准的Java套接字直接同行需要Internet权限）。<br><br> Android系统还广播了几种不同的行动，在特定的Wi - Fi P2P事件：<br> 1、WIFI_P2P_CONNECTION_CHANGED_ACTION ：P2P连接状态发生了变化。 这与EXTRA_WIFI_P2P_INFOWifiP2pInfo与EXTRA_NETWORK_INFO NetworkInfo对象的对象EXTRA_NETWORK_INFO EXTRA_NETWORK_INFOEXTRA_WIFI_P2P_INFO EXTRA_WIFI_P2P_INFO 。<br> 2、WIFI_P2P_STATE_CHANGED_ACTION ：P2P的状态已经改变之间的启用和禁用。 它携带EXTRA_WIFI_STATE要么WIFI_P2P_STATE_DISABLED或WIFI_P2P_STATE_ENABLED<br> WIFI_P2P_PEERS_CHANGED_ACTION等设备的列表已经改变。<br> 3、WIFI_P2P_THIS_DEVICE_CHANGED_ACTION ：该设备的细节已经改变。<br> 见的WifiP2pManager文档了解更多信息。 也期待在Wi - Fi的直接演示示例应用程序。<br><br><br><span style="color:#FF0000;"><strong>Bluetooth Health Devices</strong></span><br><br> 机器人现在支持蓝牙的健康概况设备，使您可以创建使用蓝牙医疗设备，如心率监视器，血液米，温度计，和规模，支持蓝牙通信的应用。<br><br> 定期耳机支持A2DP设备，你必须调用getProfileProxy()BluetoothProfile.ServiceListener和HEALTH的廓型与文件代理对象建立连接。<br><br> 一旦你获得健康概况代理（ BluetoothHealth对象），成对的医疗设备的连接和沟通包括以下新的蓝牙类：<br> BluetoothHealthCallback ：您必须扩展这个类实现回调方法接收应用程序的注册状态和蓝牙信道状态的变化更新。<br><br> BluetoothHealthAppConfiguration ：在您的回调BluetoothHealthCallback ，您会收到此对象的实例，它提供了有关可用的蓝牙医疗设备，您必须使用执行各种操作，如启动和终止连接的BluetoothHealth信息BluetoothHealth的API。<br><br><br><span style="color:#FF0000;"><strong>Accessibility</strong></span><br><br> Android的4.0提高为视障用户新的探索，触摸模式和扩展API，允许您提供有关视图内容的更多信息，或开发先进的辅助功能。<br><br>通过触控模式的新扩展功能<br><br> 视力减退的用户现在可以探索通过屏幕触摸并拖动手指在屏幕上听到的内容的语音描述。 因为探索，触摸模式就像一个虚拟的光标工程，它允许屏幕阅读器，以确定描述性的文字相同的方式，屏幕阅读器可以轨迹球通过阅读所提供的信息，当android:contentDescription ：contentDescriptionsetContentDescription后，一个模拟的“悬停”事件。 所以，认为这是一个提醒，你应该提供的意见，在您的应用程序的描述性文字，特别ImageButton的EditText EditText ImageView ImageView的和其他部件，可能不是自然包含说明性文字。<br><br><span style="color:#ff00ff;">视图的辅助<br><br></span><br><br><span style="color:#ff00ff;">面向有障碍的人群的新功能<br><br></span><br><br>其他辅助功能的API<br><br><br><br><span style="color:#FF0000;"><strong>拼写检查服务</strong></span><br><br> 一个新的拼写检查框架，允许应用程序用类似于输入法框架的方法来创建拼写检查。创建一个拼写检查，你必须实现一个继承自SpellCheckerService类和SpellCheckerService.Session类的服务，以便接口回调方法来提供基于文本的拼写检查。在SpellCheckerService.Session的回调方法里面，你必须返回拼写建议的SuggestionsInfo对象<br><br> 一个拼写检查服务的应用，必须声明服务所需的BIND_TEXT_SERVICE权限。服务也必须声明一个intent-filter，它的action属性为&lt;action android:name="android.service.textservice.SpellCheckerService" /&gt;，<br><br> 并且应该包含一个&lt;meta-data&gt;元素，来声明拼写检查的配置信息。<br><br><br><span style="color:#FF0000;"><strong>语音朗读引擎（TTS）</strong></span><br><br> android的TTS已经显著的扩大了，它允许应用程序非常简便的实现自定义TTS，当应用程序在选在TTS引擎时，想要使用几个包含新的API的TTS引擎。<br><br>使用TTS引擎<br><br> 在Android以前的版本里面，使用系统提供的TTS引擎，你应该使用TextToSpeech类，来执行TTS操作，或者你用setEngineByPackageName()方法来自定义一个引擎。在Android4.0，setEngineByPackageName()方法已经过时了，现在你可以通过一个新的TextToSpeeck的构造方法来指定引擎，该方法接收一个TTS引擎的包名。<br> 你还可以通过getEngines()来查询可用的TTS引擎，这个方法返回一个TextToSpeech.EngineInfo对象的集合，改对象包含引擎的图标、标签和包名等信息。<br><br>建立TTS引擎<br><br> 在以前，自定义引擎的要求是引擎得使用一个无证本地头文件，在Android4.0，有一套完整的API框架来建立TTS引擎。<br><br> 一个基本的设置要求是需要一个响应了INTENT_ACTION_TTS_SERVICE意图的TextToSpeeckService的实现，一个TTS引擎的主要工作发生在一个继承TextToSpeechService的service的onSynthesizeText()回调里面，系统给这个方法提供了两个对象：<br> SynthesisRequest：它包含多种数据，包括合成的文字，环境，语速和语调<br> SynthesisRequest：这是一个你的TTS引擎提供了音频流的接口。首先，引擎必须调用start()方法，来表明已经准备好提供音频数据，然后，调用audioAvailable()方法，传递一个byte buffer的音频数据。一旦你的引擎通过了所有的音频，调用done().<br> 现在，改框架支持一个真正创建TTS引擎的API，本地代码实现的支持已经被删除。查找一篇关于兼容层得博客，你可以把你旧的TTS引擎转换到新的框架下。<br><br><br><br><span style="color:#FF0000;"><strong>网络使用</strong></span><br><br> Android4.0使用户能够精确地、明显的看到他们的应用程序正在使用多少网络数据，应用程序设置允许用户管理并设置网络数据的使用权，甚至禁止某个应用使用后台数据。为了避免您的应用程序被禁止访问后台数据，你应该优化策略，更加有效的利用连接数据，并且调整您的应用依赖的有效连接的类型。<br><br> 如果你的应用执行很多网络交互，你应该提供一些设置，允许用户来控制应用程序数据，例如，多久执行同步数据，是否只在WIFI环境下执行上传下载操作，是否使用数据漫游等等，通过提供这些设置，当用户处理数据管制时，就不太可能禁用你的应用程序来访问数据，因为他们可以更加精确地控制应用程序的数据使用。如果你提供了preference的activity来设置这些，你应该在它的清单文件里面声明intent-filter，并且action为ACTION_MANAGE_NETWORK_USAGE，例如：<br> &lt;activity android:name="DataPreferences" android:label="@string/title_preferences"&gt;<br> &lt;intent-filter&gt;<br> &lt;action android:name="android.intent.action.MANAGE_NETWORK_USAGE" /&gt;<br> &lt;category android:name="android.intent.category.DEFAULT" /&gt;<br> &lt;/intent-filter&gt;<br> &lt;/activity&gt;<br><br> 这个intent-filter向系统表明，这个Activity是来控制应用程序的数据使用的，所以，当用户在Setting里面检查你的应用程序使用了多少数据时，就会显示一个"View application settings"的按钮，来启动你自己的preference activity，这样用户就可以更加详细的指导应用程序所使用的数据了。<br><br> 还要注意，getBackgroundDataSetting()现在已经被弃用了，它总是返回true，可以用getActiveNetWorkInfo()来替换。<br><br> 当你尝试任何网络交互时，你应该总是调用getActiveNetWorkInfo()来获得短期当前网络信息NetWorkInfo，并且调用isConnected()放来来检查设备是否连接，然后，你可以检查其他连接属性，例如是否漫游、是否连接到WIFI。<br><br><span style="color:#FF0000;"><strong>RenderScript</strong></span><br><br> 新增加了三个特点到RenderScript：<br> 1、离屏渲染到一个帧缓冲对象<br> 2、视图内渲染<br> 3、RenderScript为每一个框架APIS<br><br> Allocation类现在支持一个USAGE_GRAPHICS_RENDER_TARGET内存空间，它允许你直接的渲染和当做一个帧缓冲对象来使用。<br><br> RSTextureView提供了一个在一个View里面显示RenderScript图形，不像RSSurfaceView，它创建了一个单独的窗口。这个关键的区别允许你做一些事情，例如移动、转换或者和画RenderScript图像一样，在一个布局里面的view里，激活一个RSTextureView。<br><br> Script.foEach()方法允许你调用从VM的RenderScript来计算脚本和自动委托给设备上可用的核心，你不用直接使用这个方法，但是你写的任何一个计算RenderScript都会有一个forEach()方法，你可以调用它在RenderScript类的反射里面，<br><br> 你可以通过一个输入Allocation给进程来调用forEach()方法的发射，输出Allocation来写结果，一个FidldPacker数据结构来使RenderScript获得更多信息，只有其中一个Allocation是必须得，数据机构是可选的。<br><br><span style="color:#FF0000;"><strong>企业</strong></span><br><br> android4.0扩展了企业应用程序的功能，使其具有以下特点：<br><br>VPNService<br> 新的VPNService允许应用程序构建他们自己的VPN，作为一个Service运行。一个VPN服务，创建一个与它自己的地址和路由规则的虚拟网络接口，并且通过一个文件描述符执行所有读写操作。<br> 要创建一个VPN服务，需要用到VpnService.Builder，它允许你指定网络地址，DNS服务器，网络路由等等，当完成时，你可以通过调用establish()方法建立接口，她返回一个ParcelFileDescriptor对象。<br> 由于VPN服务可以截取数据包，存在安全隐患。因此，如果你实现VpnService，那么你的服务必须要求BIND_VPN_SERVICE，来确保只有系统能绑定它(只有系统被授权这个权限——应用程序不能要求),然后，使用你的VPN服务，用户必须在系统设置中手动启用它。<br><br>设备政策<br> 应用程序管理设备的限制条件，现在可以禁止相机使用setCameraDisabled()和USES_POLICY_DISABLE_CAMERA属性。<br><br>证书管理<br> 新的KeyChain类提供了允许你导入和访问系统密钥存储器中正数的API，证书简化安装的客户端证书（来验证用户的身份）和证书颁发机构证书（以验证服务器的身份）。如Web浏览器或电子邮件客户端应用程序可以访问已安装的证书来验证用户到服务器。详见KeyChain的文档。<br><br><br><br><span style="color:#FF0000;"><strong>设备传感器</strong></span><br> 在Android4.0新加了两个传感器类型：<br> 1、TYPE_AMBIENT_TEMPERATURE：一个提供环境（室）温度（摄氏度）的温度传感器 。<br> 2、TYPE_RELATIVE_HUMIDITY：提供以百分比的相对环境（室内）湿度：湿度传感器。<br><br> 如果设备有TYPE_AMBIENT_TEMPERATURE和 TYPE_RELATIVE_HUMIDITY传感器，你可以用它们来计算露点和绝对湿度。<br><br> 以前的温度传感器，TYPE_TEMPERATURE，已被弃用。您应该使用TYPE_AMBIENT_TEMPERATURE传感器来代替。<br><br> 此外，Android的三大综合传感器已大大提高，所以他们现在有更低的延迟和平滑输出 。这些传感器包括重力感应器（TYPE_GRAVITY），旋转矢量传感器（TYPE_ROTATION_VECTOR），和线性加速度传感器（TYPE_LINEAR_ACCELERATION）。改进的传感器依靠陀螺仪传感器，以提高它们的输出，因此，设备上出现的传感器，有一个陀螺仪。</p> 
<p></p> 
<p><span style="color:#FF0000;"><strong>Action Bar工具栏</strong></span><br><br> Action Bar已经更新,提供几种新的行为。最重要的是,该系统管理Action Bar优美的尺寸和结构在更小的屏幕上运行时为了提供一个最佳的用户体验所有屏幕尺寸。例如,当屏幕狭窄(例如,当一个手机在肖像取向),Action Bar的导航标签出现在一个“堆叠柱形”,直接出现在下面的主要Action Bar。你也可以选择在一个“Split action bar”,这地方都运行项目在一个独立的当屏幕底部的屏幕缩小。<br><br>Split action bar分裂工具栏<br> 如果你的功能条包括几个行动项目,不是所有的人都会融入动作条在一条狭窄的屏幕,所以这个系统会把更多的人进入溢流菜单。然而,机器人4.0允许你使“Split action bar”,使更多的行动项目就会出现在屏幕上在一个独立的功能条在屏幕的底部。为了使分裂的动作条,加上机器人:uiOptions以“splitActionBarWhenNarrow“要么你的&lt;应用&gt;标签或者个人在你&lt;活动&gt;标签体现文件。当被激活后,系统会增加一个额外的功能条屏幕底下的所有行动项目时,屏幕窄(没有行动项目将出现在主要的动作条)。<br><br> 如果你想使用这个导航标签ActionBar提供的。标签的api,但不需要的主要动作条上(你想只有链接出现在顶端),然后使分裂的动作条如上所述,也称setDisplayShowHomeEnabled(错误的)禁用应用程序的图标的动作条。一无所功能条中的主要行为,它是唯一的disappears-all导航标签在顶部和行动项目在屏幕的底部。<br><br>Action bar styles功能样式<br> 如果你想要申请习惯的功能条上的造型,你可以用新的风格和性能backgroundStacked backgroundSplit应用背景或颜色堆叠柱形和Split action bar。你也可以将这些风格与setStackedBackgroundDrawable在运行时()和setSplitBackgroundDrawable()。<br><br><br>Action provider功能提供<br><br> 新ActionProvider类允许你创建一个专门处理运行项目。一个行动Action provider可以定义一个行动的观点,一个默认的动作行为,与每项行动子菜单,它是相互关联的。当你想创造一个行动项目时,动态的行为(比如一个变量作用的观点,默认的行动,或者子菜单),延长ActionProvider是个好办法,以创造一个可用的组件,而不是处理各项行动项目或活动转换你的碎片。<br><br> 例如,ShareActionProvider的延伸,是ActionProvider行动使“分享”的动作条。而不是用传统项目,调用ACTION_SEND意图,你可以使用这一功能有一个行动提供了一个下拉列表的观点与应用程序处理ACTION_SEND意图。当用户选择一个应用程序使用的功能,ShareActionProvider要选择和行动提供更快的存取到应用当中。<br><br> 要声明一个行动提供一项功能,包括android:actionProviderClass属性在&lt;item&gt;元素为你的活动中的选项菜单,类名的功能提供更有价值的。例如:<br><br> Java代码：<br><br> &lt;item android:id="@+id/menu_share" android:title="Share" android:showAsAction="ifRoom" android:actionProviderClass="android.widget.ShareActionProvider" /&gt;<br> 你的onCreateOptionsMenu()回收方法在活动中，搜索一个实例，在菜单功能中提供设置的意图：<br><br> Java代码：<br><br> public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.options, menu); ShareActionProvider shareActionProvider = (ShareActionProvider) menu.findItem(R.id.menu_share).getActionProvider(); // Set the share intent of the share action provider. shareActionProvider.setShareIntent(createShareIntent()); ... return super.onCreateOptionsMenu(menu);<br> }<br><br> 利用ShareActionProvider为例,看ApiDemos ActionBarActionProviderActivity。<br><br><br>Collapsible action views可分解的功能视图<br> 看步骤时,提供一个意图反应观点去绑定他们的行动视图状态和传统项功能的国家。在此之前,只有SearchView崩溃的时候才支持作为行动的观点,但是现在你可以添加一个行动看任何行动项目和扩展状态之间切换(动作片的观点是可见的)和倒塌的状态(行动项目是可见)。<br><br> 声明一个行动项目,包含一个反应观点是折叠的,包括“collapse Action View“标记,android:show As Action属性为&lt;item&gt;元素在菜单的XML文件。当一个行动受到意图开关的扩展和崩溃的时候，注册的一个实例Menu Item。On Action Expand Listener有关<br> MenuItem通过电话set On Action Expand Listener。 通常,你会这样做在on Create Options Menu回收。<br><br> 控制湿陷性行为的观点,你可以叫collapse Action View和expand Action View分别Menu Item。<br><br> 当创建一个定制的行动的观点,你也可以执行新的Collapsible Action View接口调用时接受这种意图正在扩大并崩溃。<br><br>Other APIs for action bar其它api为功能条<br><br> •setHomeButtonEnabled()是你指定的图标/标志 表现这个按钮来驾船回家或“上”(通过“真”使它像一个按钮)。<br> setLogo和setIcon(),允许你可以自定义动作条的图标或标志的运行时间。<br><br> •Fragment.setMenuVisibility()让你启用或禁用的可见性的选项菜单项公告的碎片。这是有益的,如果碎片被添加到活动,但不可见的,因此应该被隐藏的菜单项。<br> •FragmentManager.invalidateOptionsMenu()让你解除本活动在不同的菜单的生命周期中碎片从活动采用等效方法可能得到的。<br><br><br><br><span style="color:#FF0000;"><strong>User Interface and Views用户界面和观点</strong></span><br><br> 介绍android 4.0各种新观点和其它UI组件。<br><br>GridLayout网格布局<br> GridLayout 是一个新的视角地方子视图在一个矩形网格。不像TableLayout,GridLayout依靠扁平式,不用中间观点，如表行提供结构。相反,我们指定哪些行(s)和列(s)他们应该占据(单元可以跨越多行和/或列),在默认情况下,是奠定在网格顺序的行和列。GridLayout取向决定是否连续的默认了孩子水平或垂直。间隔空间的我们可能被指定或者通过，使用新的空间景观实例或设置相应的参数对我们。<br><br> 看到ApiDemos为案例,使用GridLayout。<br><br>TextureView结构视图<br> TextureView是一个全新的视角,允许你来显示内容流,比如视频或一个开放式绘图介面现场。虽然SurfaceView相似,TextureView是独特的,因为它表现得像一个普通的观点,而不是创造另一个窗口,所以你可以把它像其他视图对象。例如,你可以申请转变,有生命的,它使用ViewPropertyAnimator,或调整其混浊setAlpha()。<br><br> 你要慎重,TextureView只是在一个硬件加速的窗口。<br><br>Switch widget开关窗口<br> 你可以用android:textOn 和 android:textOff属性指明文字出现在交换机在断断续续的设置。机器人:文本属性也允许你方标签和开关。<br><br> 一个案例为使用开关,看到开关。xml文件和相关布局开关的活动。<br><br>Popup menus弹出菜单<br> 介绍了Android的PopupMenu 3.0创造短语境菜单弹出一个锚点你指定(通常为重点项目的选择)。Android 4.0扩展PopupMenu和两个有用的特点:<br><br> 你现在可以很容易从XML的弹出菜单,菜单资源与充气(),通过菜单资源ID。<br> 你也可以创建一个PopupMenu。接收一个回调函数OnDismissListener当菜单注销。<br><br>Preferences选择权<br> 一个新的TwoStatePreference抽象类作为依据,提供“偏好选择选项。新SwitchPreference是一个扩展,提供了一种TwoStatePreference开关窗口的观点,允许用户偏好设定打开或关闭开关,不需要开一个额外的偏好屏幕或对话框。例如,设置应用程序使用一个SwitchPreference及蓝牙无线网络的设置。<br><br>System themes系统主题<br><br> 对所有应用都默认主题的目标android4.0(通过设置或者targetSdkVersion或minSdkVersion“14 "或更高版本)现在是“设备默认为“主题:Theme.DeviceDefault。 这或许是最黑暗的Holo主题或者一个不同的黑暗主题的具体规定装置。<br><br> 这个主题是保证不改变到另一个设备运行相同的版本的android。如果你明确适用于任何的主题。你的主题活动,是可以放心,这些主题将不会改变角色在不同的设备在同一平台版本。<br><br> 如果你希望你的应用程序融入整个装置的主题(如当不同的原始设备制造商提供不同的默认主题为系统),你应该明确适用的主题从这个主题。DeviceDefault。<br><br>Options menu button选项菜单按钮<br> 从android4.0,你会发现手机硬件不再需要一个菜单按钮。然而,你不需要去担心这个，如果你现有的应用程序提供了一个选项菜单并且希望会有一个菜单按钮。确保现有的程序继续,该系统提供了一个在萤幕上的菜单按钮的程序被设计为旧版的android。<br><br> 最好的用户体验,新的和更新程序应该使用ActionBar提供菜单项和设置targetSdkVersion“14 "利用最新的框架默认的行为。<br><br>Controls for system UI visibility控制系统用户界面<br> 从早期的Android,系统已经成功一个UI组件称为状态栏,蕴藏在顶部手机设备传输信息如载波信号、时间、通知,等等。Android系统，3.0增加的装置,制度在屏幕的底部提供系统导航的控制(家,回来,等等),又一个接口用于传统的元素提供状态栏。在Android 4.0,该系统提供了一种新型的系统界面称为导航栏。你可能会考虑导航栏一个re-tuned版本的系统设计handsets-it容器提供导航的控制装置不需要硬件同行操纵系统,但它留下了系统用户界面和酒吧的通知设置控制。这样,一种装置,它提供了导航栏也有状态栏在顶部。<br><br> 直到今天,您可以隐藏状态栏上使用手机FLAG_FULLSCREEN标志。在Android 4.0,控制系统api容器的知名度已经被更新,以便更好地反映了对系统行为的容器和导航栏。<br><br> SYSTEM_UI_FLAG_LOW_PROFILE标记取代了行STATUS_BAR_HIDDEN标志。 当设置时,这个标志使“低调”模式为系统的容器或导航栏。导航按钮暗淡,其他元素酒吧也隐藏系统。使这是有益的创造更多的引人入胜的游戏系统按钮。<br><br> SYSTEM_UI_FLAG_VISIBLE标记取代了行STATUS_BAR_VISIBLE标记,要求系统容器或导航栏可见。<br> SYSTEM_UI_FLAG_HIDE_NAVIGATION行是一种新的标记要求导航栏隐藏完全。 注意,这只是工作为导航栏采用手机(不隐藏系统容器)。导航栏尽快返回查看系统接收用户输入的信息。因此,该模式是有用的主要是为视频回放或其他案件中,整个屏幕是需要的,但用户输入并不是必须的。<br><br> 您可以设置每一个这样的标志和导航栏系统调用setSystemUiVisibility()在任何观点在你的活动。视窗管理器(OR-together)结合标记从所有的观点在你的窗口并把它们应用到系统界面只要你的窗口有输入焦点。当你失去窗口输入焦点(用户导航,你的应用程序,或者出现一个对话框),你的标记停止生效。同样的,如果你把那些观点从视图层次中他们的标记不再适用。<br><br> 其他事件同步活动改变系统能见度UI(例如,隐藏的动作条或其他用户界面控制该系统界面隐藏),你应该登记的景色。OnSystemUiVisibilityChangeListener时要通知知名度的系统导航栏栏或改变。<br><br> 看到OverscanActivity演示不同的系统用户界面选项。<br><br><br><br><br><span style="color:#FF0000;"><strong>输入框架</strong></span><br><br> Android 4.0增加了对光标悬停事件、手写笔、鼠标按钮事件的支持。<br><br>悬停事件<br><br> View类现在支持“悬停”事件，通过对指针设备（如鼠标或其他设备驱动屏幕上的光标）支持，使得其用户交互更加丰富。<br><br> 为了接收控件上的悬停事件，需要实现View.OnHoverListener，并通过setOnHoverListener() 进行注册。当悬停事件触发时，您的监听器onHover()就会被调用， 参数中含有触发悬停的View和悬停事件MotionEvent。 悬停事件可以是下列操作之一：<br> ACTION_HOVER_ENTER<br> ACTION_HOVER_EXIT<br> ACTION_HOVER_MOVE<br><br> 如果你在View.OnHoverListener中 onHover()处理了此事件，则应该返回真。 如果返回false，则悬停事件将被继续分派到它的父视图中。<br><br> 如果你的应用程序使用到了随着状态改变外观的控件，如按钮或其他控件。那么恭喜你，现在可以通过android:state_hovered 和state_hovered属性状态列表提供不同的背景绘制来响应悬停事件。<br> SDK中提供了对于悬停事件的示范，请参看ApiDemos工程中的Hover类。<br><br>手写笔和鼠标按钮事件<br><br> Android现在提供新的APIs,用于接收来自手写设备的输入，如数字化仪平板电脑周边设备或启用手写触摸屏的输入。<br><br> 手写输入，可以模拟触摸和鼠标的输入。当手写笔在接触数字化仪上面移动时，应用程序就可以接收到触摸事件，这和用手指触摸显示屏效果是一样的。 当手写笔是悬停在数字化仪之上，应用程序接收到悬停事件，这和鼠标触发的悬停事件效果是一样的。<br><br> 通过MotionEvent 中的 getToolType()可以得到每一个指针设备中的“工具类型“，您的应用程序可以以此区分手指，鼠标，手写笔和擦出动作。目前定义的工具类型：TOOL_TYPE_UNKNOWN 、 TOOL_TYPE_FINGER、TOOL_TYPE_MOUSE 、TOOL_TYPE_STYLUS 、TOOL_TYPE_ERASER 。通过查询工具类型，您的应用程序可以根据从手指或鼠标输入不同的方式来分别处理输入。<br><br> 你也可以通过MotionEvent中的getButtonState()方法，来查询鼠标或者按钮的状态。目前定义的<br> 按钮状态是：<br> BUTTON_PRIMARY<br> BUTTON_SECONDARY<br> BUTTON_TERTIARY <br> BUTTON_BACKBU<br> BUTTON_FORWARD<br><br> 为了方便起见，后面鼠标按钮被自动映射到KEYCODE_BACKKEYCODE_FORWARD键，应用程序可以处理这些按键，支持鼠标按钮的基础和前进导航。<br><br> 此外，一些手写输入设备也可以提供笔尖和数字化仪的距离，手写笔的倾斜角度，手写笔的方向角，使我们能够得到更精确的位置和接触压力。 您可以通过向getAxisValue()输入AXIS_DISTANCE ， AXIS_TILT ，和AXIS_ORIENTATION 几个Axis Codes来查询这些信息。<br><br> SDK提供了工具类型、按钮状态和 Axis Codes使用的演示，请参看ApiDemos工程中的TouchPaint类。<br></p> 
<p><span style="color:#FF0000;"><strong>Properties</strong></span><br><br> 新的Property类提供了一个快速，高效和简单的方式来对任何对象指定一个属性，调用者可以通过它来完成设置/获取该对象的值。同时，也允许来传递字段/方法引用的功能，并允许通过代码来获取字段/方法的值，即使我们不知道字段/方法的一些具体的信息。<br><br> 比如，如果你想设置foo对象的bar字段的值，你以前需要这样来写：<br> foo.bar = value;<br><br> 如果你想调用foo对象中的私有字段bar,你以前需要这样来写：<br> foo.setBar(value);<br><br> 然而，如果你想传递foo实例和通过其它的代码来设置bar字段的值，在android sdk4.0以前是没法做到的。<br><br> 使用Property类，你可以在Foo类中定义一个Property对象BAR，这样你就可以通过Foo类中的foo实例来设置它的值，如下：<br> BAR.set(foo, value);<br><br> 所以现在View类就可以充分利用Property类来让我们可以设置一些字段。比如在android 3.0时加入到View中的转换的属性（ROTATION, ROTATION_X, TRANSLATION_X等等）<br><br> ObjectAnimator类也可以使用Property 类，你可以用Property来创建一个ObjectAnimator ，它会更快，更高效，比基于字符串的方法更据有类型安全性。<br><br><br><br><span style="color:#FF0000;"><strong>Hardware Acceleration硬件加速</strong></span><br><br> 从android 4.0开始，所有的窗口都会默认开启硬件加速。当然，我们的程序中得把targetSdkVersion 和 minSdkVersion这两个值设置成14或者更高。通过硬件加速可以使用户体验到动画更流畅，滚动时再流畅，也会提高程序的整体的性能.<br><br> 如果有必要，用户可以手动禁止硬件加速。在AndroidManifest文件中可以利用　hardwareAccelerated 　属性来对个别个的&lt;activity&gt;元素或者&lt;application&gt;元素禁止硬件加速。用户也可以在代码中对个别的View进行禁止硬件加速，如：<br> setLayerType(LAYER_TYPE_SOFTWARE).<br><br> 更多关于硬件加速的信息，包括不支持的绘图操作列表，可以查看Hardware Acceleration 文档<br><br><br><br><span style="color:#FF0000;"><strong>JNI的变化</strong></span>　<br><br> 在android以前的版本中，JNI本地的引用不是间接的句柄；android 利用的是直接的指针。在垃圾收集器没有移动对象之前，这不是一个问题.　但是好像能工作是因为可能已经写了一些存在bug的代码.<br><br> JNI本地引用的详细信息（里里外外）都写在了JIN 提示的Local and Global References中。在android 4.0中，CheckJNI已经被增强，以便用来检测这些错误。请关注android开发者的博客，来了解一般的JNI引用的错误和怎么样解决他们。<br><br> 关于JNI的这些改变只是影响那些目标是android 4.0以上的程序，也就是说 targetSdkVersion 和 minSdkVersion等于14或者更高的程序　.如果你设置的值比14低，那么JNI的本地引用还是和以前一样.<br><br><br><br><span style="color:#FF0000;"><strong>WebKit浏览器引擎</strong></span><br><br> 1、WebKit更新到534.30版本<br> 2、在WebView和内置的浏览器中支持印度的字体（梵文，孟加拉语，泰米尔语，需要通过复杂的字形来组合的字符）<br> 3、在WebView和内置的浏览器中支持埃塞俄比亚语，格鲁吉亚语，亚美尼亚语的字体。<br> 4、支持WebDriver,通过它可以使得利用WebView来测试程序更加的容易<br><br>Android 浏览器<br>浏览器程序添加了下面的一些特征来支持web程序。<br> 更新了V8 javaScript编译器，以提交性能。<br> 另外显著的增强了android 3.0的一些功能<br> 1、在所有的页面上支持固定位置元素<br> 2、HTML上媒体的捕获<br> 3、设备方向事件<br> 4、css中3d的转换<br><br><br><span style="color:#FF0000;"><strong>Permissions权限</strong></span><br><br> 下面是新添加的权限<br> 1、ADD_VOICEMAIL:允许语音信箱服务来添加一个语音邮件到设备　<br> 2、BIND_TEXT_SERVICE:实现了SpellCheckerService 服务的服务必须添加这个权限<br> 3、BIND_VPN_SERVICE:实现了VpnService 服务的服务必须添加这个权限<br> 4、READ_PROFILE: 提供一个读权限给 ContactsContract.Profile提供器<br> 5、WRITE_PROFILE: 提供一个写权限给 ContactsContract.Profile提供器<br><br><br><br><span style="color:#FF0000;"><strong>Device Features设备特征</strong></span><br><br> 下面是新添加的设备特征<br> 1、FEATURE_WIFI_DIRECT: 声明些应用程序WIFI来进行点对点和通信<br> 2、对于在android 4.0(api 级别14)上所有的api的变化，请看API Differences Report文档</p> 
<p></p> 
<p><span style="color:#FF0000;"><strong>以前的API</strong></span><br><br> 除了上面讲到的API，Android4.0还支持之前发布的所有API。因为Android3.X平台只支持大屏幕的设备，如果你主要为手持设备进行开发，你不需要担心当前版本增加的所有API。<br><br> 现在我们看一下你可能会忽略掉的一些值得注意的地方，现在它们在手持设备上也可以使用了。<br><br>Android3.0<br> 1、Fragment：一个框架组件，允许你将activity中不同的元素分离到自包含的模块中，每个模块定义自己的UI和生命周期。详情请看Fragments。<br> 2、Action Bar：activity中的传统的标题栏的一个替代品。左侧包含一个应用logo，并且为菜单项提供了新接口。详情请看Action Bar。<br> 3、Loader：一个框架组件，方便在组合的UI中异步加载数据，可以动态获取数据而不用担心阻塞主线程。详情请看Loaders。<br> 4、System clipboard：应用可以使用系统的剪贴板拷贝和粘贴数据（不仅仅是文本内容）。可以剪贴的数据包括：普通文本，一个URL，或者是一个intent。详情请看Copy and Paste。<br> 5、Drag and drop：在view中内置了一个API集合，可以方便的进行拖拽的开发。详情请看Drag and Drop。<br> 6、一个全新的灵活的动画框架，你可以让任何对象（例如：view，drawable，fragment，object等等）的任何属性动起来，并且定义动画的各种属性，例如：持续时间，补间内容，如何重复等等。新框架使得在Android上开发动画比以前更简单。详情请看Property Animation。<br> 7、RenderScript graphics and compute engine：RenderScript提供高性能的3D图片呈现，和高性能的本地级别的计算API，你可以用C（标准C99）来写，提供了你希望的从本地环境执行的性能，同时可以跨越各种CPU和GPU。详情请看RenderScript。<br> 8、Hardware accelerated 2D graphics：你可以为你的应用开启OpenGL呈现功能，通过在你的manifest文件的&lt;application&gt;元素中设置{android:hardwareAccelerated=”true”}，也可以为每个activity单独设置。可以使得动画更加平滑，滚动更加平滑，提高整体性能和用户的交互响应。<br><br> 请注意：如果你把应用的minSdkVersion或者是targetSdkVersion设置为14或者更高，硬件加速器是默认开启的。<br><br>Android3.1<br> 1、USB APIs：通过强大的API，可以在应用中整合已经连接的外围设备。API基于USB和内置在平台的服务，包括对USB宿主和设备进行交互的支持。详情请看USB Host and Accessory。<br> 2、MTP/PTP APIs：应用可以和直接连接的照相机或者是其他PTP设备交互，在设备附加和移除的时候收到通知，管理这些设备的文件和存储，进行文件和元数据的交换。MTP APIs实现了PTP（图片传输协议），PTP是MTP（媒体传输协议）的子集。详情请看android.mtp。<br> 3、RTP APIs：Android开放了内置的RTP（实时传输协议）的API，在应用中可以用来管理实时和交互数据流。尤其是，在提供VOIP的应用，视频通话，视频会议，可以用API初始化音频流的会话，在网络上传输和接受数据流。详情请看android.net.rtp。<br> 4、支持操纵杆和普通的手势输入。<br> 更多详情请查看Android 3.1 Platform。<br><br><br><br><span style="color:#FF0000;"><strong>API Level</strong></span><br><br> Android4.0的标识为14，是系统本身存储的标识。这个标识被我们称为API等级，帮助系统在安装应用之前，准确的确定一个应用是否和系统兼容，在你的应用中引入Android4.0的API，需要你的代码在支持API Level14甚至更高的平台编译通过。如果需要，可以在manifest文件的&lt;use-sdk&gt;元素中添加 android:minSdkVersion=”14”。<br><br><br><span style="color:#FF0000;"><strong>内置的应用</strong></span><br><br> 在系统中内置了下面的应用。<br></p> 
<table class="t_table" cellspacing="0"><tbody><tr><td> 
    <ul><li><br><br></li><li>API的演示 </li><li>Browser浏览器 </li><li>Calculator计算器 </li><li>Calendar日历 </li><li>Camera相机 </li><li>Clock时钟 </li><li>Custom Locale自定义区域 </li><li>Dev Tools开发工具 </li><li>Downloads下载 </li><li>Email电子邮件 </li><li>Gallery画廊<br></li></ul></td><td> 
    <ul><li><br><br></li><li>Gestures Builder手势生成器 </li><li>Messaging消息 </li><li>Music音乐 </li><li>People人民 </li><li>Phone电话 </li><li>Search搜索 </li><li>Settings设置 </li><li>Speech Recorder语音记录器 </li><li>Speech Recorder语音记录器 </li><li>Widget Preview小工具预览<br></li></ul></td></tr></tbody></table> 
<br> 
<br> 
<br> 
<span style="color:#FF0000;"><strong>语言环境</strong></span> 
<br> 
<br> 系统映像包含在下载的SDK平台提供的各种内置的语言环境。在某些情况下，特定​​区域的字符串的语言环境。在其他情况下，使用了默认的语言版本。下面列出的Android 3.0系统映像的语言。 
<br> 阿拉伯，埃及（ar_EG） 
<br> Arabic, Israel (ar_IL)阿拉伯，以色列（ar_IL） 
<br> Bulgarian, Bulgaria (bg_BG)保加利亚，保加利亚（bg_BG） 
<br> Catalan, Spain (ca_ES)加泰罗尼亚，西班牙（ca_ES） 
<br> Czech, Czech Republic (cs_CZ)捷克，捷克共和国（cs_CZ） 
<br> Danish, Denmark(da_DK)丹麦，丹麦（da_DK） 
<br> German, Austria (de_AT)德国，奥地利（de_AT） 
<br> German, Switzerland (de_CH)德国，瑞士（de_CH） 
<br> German, Germany (de_DE)德国，德国（de_DE的） 
<br> German, Liechtenstein (de_LI)德国，列支敦士登（de_LI） 
<br> Greek, Greece (el_GR)希腊，希腊（el_GR） 
<br> English, Australia (en_AU)英国，澳大利亚（en_AU） 
<br> English, Canada (en_CA)英国，加拿大（en_CA） 
<br> English, Britain (en_GB)英文，英国（en_GB） 
<br> English, Ireland (en_IE)英国，爱尔兰（en_IE） 
<br> English, India (en_IN)英国，印度（en_IN） 
<br> English, New Zealand (en_NZ)英国，新西兰（en_NZ） 
<br> English, Singapore(en_SG)英国，新加坡（en_SG） 
<br> English, US (en_US)英国，美国（en_US） 
<br> English, Zimbabwe (en_ZA)英国，津巴布韦（en_ZA） 
<br> Spanish (es_ES)西班牙语（es_ES） 
<br> Spanish, US (es_US)西班牙，美国（es_US） 
<br> Finnish, Finland (fi_FI)芬兰，芬兰（fi_FI） 
<br> French, Belgium (fr_BE)法国，比利时（fr_BE） 
<br> French, Canada (fr_CA)法国，加拿大（fr_CA） 
<br> French, Switzerland (fr_CH)法国，瑞士（fr_CH） 
<br> French, France (fr_FR)法国，法国（fr_FR） 
<br> Hebrew, Israel (he_IL)以色列希伯来文，（he_IL） 
<br> Hindi, India (hi_IN)印地语，印度（hi_IN） 
<br> Croatian, Croatia (hr_HR)克罗地亚，克罗地亚（hr_HR） 
<br> Hungarian, Hungary (hu_HU)匈牙利，匈牙利（hu_HU） 
<br> Indonesian, Indonesia (id_ID)印度尼西亚，印度尼西亚（id_ID） 
<br> Italian, Switzerland (it_CH)意大利，瑞士（it_CH） 
<br> Italian, Italy (it_IT)意大利，意大利（it_IT） 
<br> Japanese (ja_JP)日语（ja_JP） 
<br> Korean (ko_KR)韩国（ko_KR） 
<br> Lithuanian, Lithuania (lt_LT)立陶宛，立陶宛（lt_LT） 
<br> Latvian, Latvia (lv_LV)拉脱维亚，拉脱维亚（lv_LV） 
<br> Norwegian bokmål, Norway (nb_NO)挪威巴克摩，挪威（nb_NO） 
<br> Dutch, Belgium (nl_BE)荷兰，比利时（nl_BE） 
<br> Dutch, Netherlands (nl_NL)荷兰，荷兰（nl_NL） 
<br> Polish (pl_PL)波兰（pl_PL） 
<br> Portuguese, Brazil (pt_BR)葡萄牙，巴西（pt_BR） 
<br> Portuguese, Portugal (pt_PT)葡萄牙，葡萄牙（pt_PT） 
<br> Romanian, Romania (ro_RO)罗马尼亚，罗马尼亚（ro_RO） 
<br> Russian (ru_RU)俄罗斯（ru_RU） 
<br> Slovak, Slovakia (sk_SK)斯洛伐克，斯洛伐克（sk_SK） 
<br> Slovenian, Slovenia (sl_SI)斯洛文尼亚，斯洛文尼亚（sl_SI） 
<br> Serbian (sr_RS)塞尔维亚语（sr_RS） 
<br> Swedish, Sweden (sv_SE)瑞典，瑞典（sv_​​SE） 
<br> Thai, Thailand (th_TH)泰国，泰国（th_TH） 
<br> Tagalog, Philippines (tl_PH)他加禄语，菲律宾（tl_PH） 
<br> Turkish, Turkey (tr_TR)土耳其，土耳其（tr_TR） 
<br> Ukrainian, Ukraine (uk_UA)乌克兰，乌克兰（uk_UA） 
<br> Vietnamese, Vietnam (vi_VN)越南，越南（vi_VN） 
<br> Chinese, PRC (zh_CN)中国，中国（ZH_CN） 
<br> Chinese, Taiwan (zh_TW)中国，台湾（zh_TW） 
<br> 
<br> 
<br> 
<span style="color:#FF0000;"><strong>仿真器样机</strong></span> 
<br> 下载平台包括以下的仿真器样机： 
<br> 
<br> 
<ul><li>QVGA (240x320, low density, small screen) QVGA（240X320，密度低，小屏幕） </li><li>WQVGA400 (240x400, low density, normal screen) WQVGA400（240X400，密度低，正常屏幕） </li><li>WQVGA432 (240x432, low density, normal screen) WQVGA432（240x432，密度低，正常屏幕） </li><li>HVGA (320x480, medium density, normal screen)为HVGA（320x480的，中密度，正常屏幕） </li><li>WVGA800 (480x800, high density, normal screen) WVGA800（480X800，高密度，正常屏幕） </li><li>WVGA854 (480x854 high density, normal screen) WVGA854（480X854密度高，正常屏幕） </li><li>WXGA720 (1280x720, extra-high density, normal screen) <strong><span style="font-size:13px;"><span style="color:#ff3d3d;">new</span></span></strong> WXGA720（1280 × 720，超高密度，正常屏幕）<strong><span style="font-size:13px;"><span style="color:#ff3d3d;">新</span></span></strong> </li><li>WSVGA (1024x600, medium density, large screen) <strong><span style="font-size:13px;"><span style="color:#ff3d3d;">new</span></span></strong> WSVGA（1024X600，中密度，大屏幕）<strong><span style="font-size:13px;"><span style="color:#ff3d3d;">新</span></span></strong> </li><li>WXGA (1280x800, medium density, xlarge screen) WXGA（1280 × 800，中密度，XLARGE屏幕）<br></li></ul> 
<p><br> 最新的Andr​​oid设备模拟器上测试您的应用程序，您可以创建新WXGA720皮肤（这是一个xhdpi，正常的屏幕设备）的AVD。注意模拟器目前不支持屏幕上的导航栏没有硬件导航按钮的设备新，所以使用该皮肤时，您必须使用“主页”按钮的<em>键盘</em>按键首页，“后退<em>”</em>按钮<em>的ESC，</em> F2或页面<em>为</em> “菜单”按钮。<br> 然而，由于性能问题，在模拟器运行时如WXGA720皮肤的高分辨率屏幕，我们建议您主要使用传统的WVGA800皮肤（hdpi，正常屏幕），以测试您的应用程序。</p> 
<p></p> 
<p><span style="color:#ff0000;"><strong>注明：QQ技术交流群：108614806 感兴趣的加一下。</strong></span></p> 
<p><br><br></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b66ce1158be8614a72128887fe40d6df/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">erlang学习： mnesia的分布式功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dcfa335cbeabe5a5c16b1a09f912e08d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Introduction to the AMQP 0-9-1 Model</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>