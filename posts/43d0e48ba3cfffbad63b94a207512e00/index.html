<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计组03：20min导图复习 中央处理器 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计组03：20min导图复习 中央处理器" />
<meta property="og:description" content="🐳前言 图源：文心一言
考研笔记整理，纯复习向，思维导图基本就是全部内容了，不会涉及较深的知识点~~🥝🥝
第1版：查资料、画思维导图~🧩🧩 编辑： 梅头脑🌸
参考用书：王道考研《2024年 计算机组成原理考研复习指导》
参考视频：5.1_CPU的功能和基本结构_哔哩哔哩_bilibili
🦮思维导图 ​
🌸思维导图为整理王道教材计算机组成原理 第5章中央处理器，如果看不清的话，可以试试存到本地然后放大~🌸博文后面会以大纲的形式复述一遍，面向复习，不会写得很详细，且可能有误；如果想仔细了解知识点，或许可以考虑以下两种方式~ 王道咸鱼老师的视频：5.1_CPU的功能和基本结构_哔哩哔哩_bilibili较为重要的内容有从网络找相关配图并给出原文链接，点击配图的链接可以传送到各位大佬博文，也很适合快速复习~ 📇目录 目录
🐳前言
🦮思维导图
📇目录
🐳中央处理器
🐋CPU的功能和基本结构
🐚组成
🐚功能
🐋指令执行过程
🐚指令周期
🐚备注
🐋指令周期的数据流
🐚取指周期【FE】
🐚间址周期【IND】
🐚执行周期【EX】
🐚中断周期【INT】
🐚指令执行方案
🐋数据通路的功能和基本结构
🐚功能
🐚基本结构
🐋控制器的功能和工作原理
🐚控制器的主要功能
🐚硬布线控制器【组合逻辑控制器】
🐚微操作控制器
🐋指令流水线
🐚提高处理机并行性
🐚指令的执行过程
🐚流水线的设计原则
🐚流水线的基本实现
🐚流水线的冒险与处理
🐚流水线的性能指标
🐚高级流水线技术
🐋多处理器的基本概念
🐚计算机体系
🐚硬件多线程
🐚多核处理器
🔚结语
🐳中央处理器 🐋CPU的功能和基本结构 🐚组成 控制器 功能 负责协调并控制计算机各部件执行的指令序列，包括取指令、分析指令和执行指令 类型 硬布线控制器微程序控制器 组成 程序计数器【PC】 功能 欲执行指令在主存中的存放地址，在取值周期末修改，可自增或执行无条件转移指令【例，JMP】位数 存储字长【PC存放的地址，指向存储器的存储单元；存储容量决定存储单元总数，编址与寻址方式决定每次访问几个存储单元】单位 精简指令集【RISC】：指令长度相同，以指令字为单位，也可以以字节为单位复杂指令集【CISC】：指令长度不同，以字节为单位备注1：PC自增 RISC，有时&#34;&#43;1&#34;为地址增加1条指令长度【&#43;指令字长/编址单位】，而非地址增加1个编址单位可通过自增硬件实现【图中标注PC&#43;1】，或者使用多路选择器MUX连接ALU实现【15年考题】，或者使用加法器实现备注2：PC跳转 在一条无条件跳转指令【JMP】的指令周期内，PC的值被修改2次：PC自增(&#43;指令字长/编址单位)与跳转PC跳转的目标地址=指令字长/编址单位 x（1&#43;OFFSET偏移字段），其中OFFSET表示偏移指令条数指令译码器 仅对操作码字段进行译码，向控制器提供特定的操作信号指令寄存器【IR】 功能：保存当前正在执行的那条指令位数：取决于指令字长存储器地址寄存器【MAR】 存放要访问的主存单元的地址存储器数据寄存器【MDR】 存放向主存写入的信息或从主存读出的信息微操作信号发生器【CU】 根据IR的内容（指令），PSW的内容（状态信息）及时序信号，产生控制信号时序系统 产生各种时序信号，他们都由统一时钟分频得到 运算器 功能 接收从控制器从来的命令并执行相应的动作，对数据进行加工和处理 组成 算数逻辑单元【ALU】 备注：有可能和第2章 数据的表示和运算 以及第4章 指令系统 联合考试进行算数/逻辑运算逻辑元件​​​​​​​ 一条线路的通断 三态门：控制功能部件是否输出，控制信号为In、out结尾多条通路的选择 地址译码器：n位可控制2^n个设备多路选择器：n位可控制n个设备暂存寄存器 功能：暂存从主存读来的数据用途：CPU内部单总线方式，防止总线在两个输入端输入相同的信号累加寄存器【ACC】 通用寄存器，用于存放ALU运算的结果信息，可以作为加法运算的一个输入端，例，执行加法、乘法指令通用寄存器组 功能：用于存放操作数和各种地址信息等，可通过编程制定各种功能位数：取决于机器字长程序状态寄存器【PSW】 保存由算数逻辑运算指令或测试指令的结果而建立的各种状态信息，如进位【CY】、溢出【OV】控制信息，如允许中断【IF】，中断置位指令为CPU做出判断，如执行条件转移指令【IF、CMP】移位器 对操作数或运算结果进行移位运算计数器【CT】 控制乘除运算的操作步骤 🐚功能 指令控制：完成取指令、分析指令和执行指令的操作操作控制：管理并产生由内存取出的每条指令的操作信号，把操作信号送往相应的部件，控制部件按要求动作时间控制：为每条指令按时间顺序提供应有的控制信号数据加工：对数据进行算数和逻辑运算中断处理：对计算机运行过程中的异常情况和特殊请求进行处理 图源：CPU工作原理和电路图_百度知道" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/43d0e48ba3cfffbad63b94a207512e00/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-11T17:41:48+08:00" />
<meta property="article:modified_time" content="2023-11-11T17:41:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计组03：20min导图复习 中央处理器</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%F0%9F%90%B3%E5%89%8D%E8%A8%80"><strong>🐳</strong>前言</h2> 
<p class="img-center"><img alt="" height="512" src="https://images2.imgbox.com/d4/58/lFoYaRIx_o.png" width="512"></p> 
<p style="text-align:center;">图源：文心一言</p> 
<p>考研笔记整理，纯复习向，思维导图基本就是全部内容了，不会涉及较深的知识点~~🥝🥝</p> 
<ul><li>第1版：查资料、画思维导图~🧩🧩</li></ul> 
<p><strong>编辑：</strong> 梅头脑🌸</p> 
<p><strong>参考用书：</strong><a href="https://so.csdn.net/so/search?q=%E7%8E%8B%E9%81%93&amp;spm=1001.2101.3001.7020" title="王道">王道</a>考研《2024年 计算机组成原理考研复习指导》</p> 
<p><strong>参考视频：</strong><a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=62" rel="nofollow" title="5.1_CPU的功能和基本结构_哔哩哔哩_bilibili">5.1_CPU的功能和基本结构_哔哩哔哩_bilibili</a></p> 
<hr> 
<h2 id="%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE">🦮思维导图</h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/8a/0d/zkAzYAQk_o.png" width="1200">​</p> 
<ul><li>🌸思维导图为整理王道教材<strong>计算机组成原理 第5章中央处理器</strong>，如果看不清的话，可以试试存到本地然后放大~</li><li>🌸博文后面会以大纲的形式复述一遍，面向复习，不会写得很详细，且可能有误；如果想仔细了解知识点，或许可以考虑以下两种方式~ 
  <ul><li><strong>王道咸鱼老师</strong>的视频：<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=62" rel="nofollow" title="5.1_CPU的功能和基本结构_哔哩哔哩_bilibili">5.1_CPU的功能和基本结构_哔哩哔哩_bilibili</a></li><li>较为重要的内容有从网络找相关配图并给出原文链接，点击配图的链接可以传送到各位<strong>大佬博文</strong>，也很适合快速复习~</li></ul></li></ul> 
<hr> 
<h2 id="%F0%9F%93%87%E7%9B%AE%E5%BD%95">📇目录</h2> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%F0%9F%90%B3%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%F0%9F%90%B3%E5%89%8D%E8%A8%80" rel="nofollow">🐳前言</a></p> 
<p id="%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE-toc" style="margin-left:0px;"><a href="#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE" rel="nofollow">🦮思维导图</a></p> 
<p id="%F0%9F%93%87%E7%9B%AE%E5%BD%95-toc" style="margin-left:0px;"><a href="#%F0%9F%93%87%E7%9B%AE%E5%BD%95" rel="nofollow">📇目录</a></p> 
<p id="%F0%9F%90%B3%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8-toc" style="margin-left:0px;"><a href="#%F0%9F%90%B3%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8" rel="nofollow">🐳中央处理器</a></p> 
<p id="%F0%9F%90%8BCPU%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#%F0%9F%90%8BCPU%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84" rel="nofollow">🐋CPU的功能和基本结构</a></p> 
<p id="%F0%9F%90%9A%E7%BB%84%E6%88%90-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E7%BB%84%E6%88%90" rel="nofollow">🐚组成</a></p> 
<p id="%F0%9F%90%9A%E5%8A%9F%E8%83%BD-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E5%8A%9F%E8%83%BD" rel="nofollow">🐚功能</a></p> 
<p id="%F0%9F%90%8B%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%F0%9F%90%8B%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B" rel="nofollow">🐋指令执行过程</a></p> 
<p id="%F0%9F%90%9A%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F" rel="nofollow">🐚指令周期</a></p> 
<p id="%F0%9F%90%9A%E5%A4%87%E6%B3%A8-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E5%A4%87%E6%B3%A8" rel="nofollow">🐚备注</a></p> 
<p id="%F0%9F%90%8B%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81-toc" style="margin-left:40px;"><a href="#%F0%9F%90%8B%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81" rel="nofollow">🐋指令周期的数据流</a></p> 
<p id="%F0%9F%90%9A%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F%E3%80%90FE%E3%80%91-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F%E3%80%90FE%E3%80%91" rel="nofollow">🐚取指周期【FE】</a></p> 
<p id="%F0%9F%90%9A%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F%E3%80%90IND%E3%80%91-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F%E3%80%90IND%E3%80%91" rel="nofollow">🐚间址周期【IND】</a></p> 
<p id="%F0%9F%90%9A%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F%E3%80%90EX%E3%80%91-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F%E3%80%90EX%E3%80%91" rel="nofollow">🐚执行周期【EX】</a></p> 
<p id="%F0%9F%90%9A%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F%E3%80%90INT%E3%80%91-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F%E3%80%90INT%E3%80%91" rel="nofollow">🐚中断周期【INT】</a></p> 
<p id="%F0%9F%90%9A%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88" rel="nofollow">🐚指令执行方案</a></p> 
<p id="%F0%9F%90%8B%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#%F0%9F%90%8B%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84" rel="nofollow">🐋数据通路的功能和基本结构</a></p> 
<p id="%F0%9F%90%9A%E5%8A%9F%E8%83%BD-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E5%8A%9F%E8%83%BD" rel="nofollow">🐚功能</a></p> 
<p id="%F0%9F%90%9A%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84" rel="nofollow">🐚基本结构</a></p> 
<p id="%F0%9F%90%8B%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#%F0%9F%90%8B%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">🐋控制器的功能和工作原理</a></p> 
<p id="%F0%9F%90%9A%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD" rel="nofollow">🐚控制器的主要功能</a></p> 
<p id="%F0%9F%90%9A%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%E3%80%90%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E5%99%A8%E3%80%91-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%E3%80%90%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E5%99%A8%E3%80%91" rel="nofollow">🐚硬布线控制器【组合逻辑控制器】</a></p> 
<p id="%F0%9F%90%9A%E5%BE%AE%E6%93%8D%E4%BD%9C%E6%8E%A7%E5%88%B6%E5%99%A8-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E5%BE%AE%E6%93%8D%E4%BD%9C%E6%8E%A7%E5%88%B6%E5%99%A8" rel="nofollow">🐚微操作控制器</a></p> 
<p id="%F0%9F%90%8B%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF-toc" style="margin-left:40px;"><a href="#%F0%9F%90%8B%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF" rel="nofollow">🐋指令流水线</a></p> 
<p id="%F0%9F%90%9A%E6%8F%90%E9%AB%98%E5%A4%84%E7%90%86%E6%9C%BA%E5%B9%B6%E8%A1%8C%E6%80%A7-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E6%8F%90%E9%AB%98%E5%A4%84%E7%90%86%E6%9C%BA%E5%B9%B6%E8%A1%8C%E6%80%A7" rel="nofollow">🐚提高处理机并行性</a></p> 
<p id="%F0%9F%90%9A%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B" rel="nofollow">🐚指令的执行过程</a></p> 
<p id="%F0%9F%90%9A%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99" rel="nofollow">🐚流水线的设计原则</a></p> 
<p id="%F0%9F%90%9A%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0" rel="nofollow">🐚流水线的基本实现</a></p> 
<p id="%F0%9F%90%9A%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%86%92%E9%99%A9%E4%B8%8E%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%86%92%E9%99%A9%E4%B8%8E%E5%A4%84%E7%90%86" rel="nofollow">🐚流水线的冒险与处理</a></p> 
<p id="%F0%9F%90%9A%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87" rel="nofollow">🐚流水线的性能指标</a></p> 
<p id="%F0%9F%90%9A%E9%AB%98%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E9%AB%98%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF" rel="nofollow">🐚高级流水线技术</a></p> 
<p id="%F0%9F%90%8B%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%F0%9F%90%8B%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">🐋多处理器的基本概念</a></p> 
<p id="%F0%9F%90%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB" rel="nofollow">🐚计算机体系</a></p> 
<p id="%F0%9F%90%9A%E7%A1%AC%E4%BB%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E7%A1%AC%E4%BB%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B" rel="nofollow">🐚硬件多线程</a></p> 
<p id="%F0%9F%90%9A%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8-toc" style="margin-left:80px;"><a href="#%F0%9F%90%9A%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8" rel="nofollow">🐚多核处理器</a></p> 
<p id="%F0%9F%94%9A%E7%BB%93%E8%AF%AD-toc" style="margin-left:0px;"><a href="#%F0%9F%94%9A%E7%BB%93%E8%AF%AD" rel="nofollow">🔚结语</a></p> 
<hr> 
<h2 id="%F0%9F%90%B3%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8" style="margin-left:.0001pt;"><strong>🐳<span style="color:#000000;">中央处理器</span></strong></h2> 
<ul><li style="text-align:left;"> <h3 id="%F0%9F%90%8BCPU%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84" style="background-color:transparent;"><strong>🐋<span style="color:#000000;">CPU的功能和基本结构</span></strong></h3> 
  <ul><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E7%BB%84%E6%88%90" style="background-color:transparent;"><strong>🐚<span style="color:#000000;">组成</span></strong></h4> 
    <ul><li style="text-align:left;"><strong><span style="color:#000000;">控制器</span></strong> 
      <ul><li style="text-align:left;"><span style="color:#000000;">功能</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">负责协调并控制计算机各部件执行的指令序列，包括取指令、分析指令和执行指令</span></li></ul> 
        </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">类型</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">硬布线控制器</span></li><li style="text-align:left;"><span style="color:#000000;">微程序控制器</span></li></ul> 
        </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">组成</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">程序计数器【PC】</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">功能</span> 
             <ul><li style="text-align:left;"><span style="color:#000000;">欲执行指令在主存中的存放地址，在取值周期末修改，可自增或执行无条件转移指令【例，JMP】</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">位数</span> 
             <ul><li style="text-align:left;"><span style="color:#000000;">存储字长【PC存放的地址，指向存储器的存储单元；存储容量决定存储单元总数，编址与寻址方式决定每次访问几个存储单元】</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">单位</span> 
             <ul><li style="text-align:left;"><span style="color:#000000;">精简指令集【RISC】：指令长度相同，以指令字为单位，也可以以字节为单位</span></li><li style="text-align:left;"><span style="color:#000000;">复杂指令集【CISC】：指令长度不同，以字节为单位</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">备注1：PC自增</span> 
             <ul><li style="text-align:left;"><span style="color:#000000;">RISC，有时"+1"为地址增加1条指令长度【+指令字长/编址单位】，而非地址增加1个编址单位</span></li><li style="text-align:left;"><span style="color:#000000;">可通过自增硬件实现【图中标注PC+1】，或者使用多路选择器MUX连接ALU实现【15年考题】，或者使用加法器实现</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">备注2：PC跳转</span> 
             <ul><li style="text-align:left;"><span style="color:#000000;">在一条无条件跳转指令【JMP】的指令周期内，PC的值被修改2次：PC自增(+指令字长/编址单位)与跳转</span></li><li style="text-align:left;"><span style="color:#000000;">PC跳转的目标地址=指令字长/编址单位 x（1+OFFSET偏移字段），其中OFFSET表示偏移指令条数</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">指令译码器</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">仅对操作码字段进行译码，向控制器提供特定的操作信号</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">指令寄存器【IR】</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">功能：保存当前正在执行的那条指令</span></li><li style="text-align:left;"><span style="color:#000000;">位数：取决于指令字长</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">存储器地址寄存器【MAR】</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">存放要访问的主存单元的地址</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">存储器数据寄存器【MDR】</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">存放向主存写入的信息或从主存读出的信息</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">微操作信号发生器【CU】</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">根据IR的内容（指令），PSW的内容（状态信息）及时序信号，产生控制信号</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">时序系统</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">产生各种时序信号，他们都由统一时钟分频得到</span></li></ul></li></ul> 
        </blockquote> </li></ul></li><li style="text-align:left;"><strong><span style="color:#000000;">运算器</span></strong> 
      <ul><li style="text-align:left;"><span style="color:#000000;">功能</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">接收从控制器从来的命令并执行相应的动作，对数据进行加工和处理</span></li></ul> 
        </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">组成</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">算数逻辑单元【ALU】</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">备注：有可能和第2章 数据的表示和运算 以及第4章 指令系统 联合考试</span></li><li style="text-align:left;"><span style="color:#000000;">进行算数/逻辑运算</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">逻辑元件</span><span style="color:#000000;">​​​​​​​</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">一条线路的通断</span> 
             <ul><li style="text-align:left;"><span style="color:#000000;">三态门：控制功能部件是否输出，控制信号为In、out结尾</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">多条通路的选择</span> 
             <ul><li style="text-align:left;"><span style="color:#000000;">地址译码器：n位可控制2^n个设备</span></li><li style="text-align:left;"><span style="color:#000000;">多路选择器：n位可控制n个设备</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">暂存寄存器</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">功能：暂存从主存读来的数据</span></li><li style="text-align:left;"><span style="color:#000000;">用途：CPU内部单总线方式，防止总线在两个输入端输入相同的信号</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">累加寄存器【ACC】</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">通用寄存器，用于存放ALU运算的结果信息，可以作为加法运算的一个输入端，例，执行加法、乘法指令</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">通用寄存器组</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">功能：用于存放操作数和各种地址信息等，可通过编程制定各种功能</span></li><li style="text-align:left;"><span style="color:#000000;">位数：取决于机器字长</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">程序状态寄存器【PSW】</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">保存由算数逻辑运算指令或测试指令的结果而建立的各种状态信息，如进位【CY】、溢出【OV】</span></li><li style="text-align:left;"><span style="color:#000000;">控制信息，如允许中断【IF】，中断置位指令</span></li><li style="text-align:left;"><span style="color:#000000;">为CPU做出判断，如执行条件转移指令【IF、CMP】</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">移位器</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">对操作数或运算结果进行移位运算</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">计数器【CT】</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">控制乘除运算的操作步骤</span></li></ul></li></ul> 
        </blockquote> </li></ul></li></ul></li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E5%8A%9F%E8%83%BD" style="background-color:transparent;"><strong>🐚<span style="color:#000000;">功能</span></strong></h4> 
    <blockquote> 
     <ul><li style="text-align:left;"><span style="color:#000000;">指令控制：完成取指令、分析指令和执行指令的操作</span></li><li style="text-align:left;"><span style="color:#000000;">操作控制：管理并产生由内存取出的每条指令的操作信号，把操作信号送往相应的部件，控制部件按要求动作</span></li><li style="text-align:left;"><span style="color:#000000;">时间控制：为每条指令按时间顺序提供应有的控制信号</span></li><li style="text-align:left;"><span style="color:#000000;">数据加工：对数据进行算数和逻辑运算</span></li><li style="text-align:left;"><span style="color:#000000;">中断处理：对计算机运行过程中的异常情况和特殊请求进行处理</span></li></ul> 
     <p style="text-align:center;"><img alt="" height="644" src="https://images2.imgbox.com/42/8f/I5knVAta_o.png" width="863"></p> 
     <p style="text-align:center;"><span style="color:#000000;">图源：</span><a href="https://zhidao.baidu.com/question/94083312.html" rel="nofollow" title="CPU工作原理和电路图_百度知道">CPU工作原理和电路图_百度知道</a></p> 
     <p style="text-align:center;"><img alt="" height="1067" src="https://images2.imgbox.com/f7/47/pgxkzxHP_o.png" width="1200"></p> 
     <p style="text-align:center;">图源：<a href="https://blog.csdn.net/alodonoa/article/details/117167426" title="【精选】(计算机组成原理5.1CPU的功能和基本结构)_-CSDN博客">【精选】(计算机组成原理5.1CPU的功能和基本结构)_-CSDN博客</a></p> 
    </blockquote> </li></ul></li><li style="text-align:left;"> <h3 id="%F0%9F%90%8B%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><strong>🐋<span style="color:#000000;">指令执行过程</span></strong></h3> 
  <ul><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><strong>🐚</strong><span style="color:#000000;">指令周期</span></h4> 
    <blockquote> 
     <ul><li style="text-align:left;"><span style="color:#000000;">指令周期</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">CPU从主存中取出并执行一条指令的时间</span></li><li style="text-align:left;"><span style="color:#000000;">不同指令的指令周期可能不同</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">机器周期</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">也称CPU周期，通过一次总线事务访问一次主存或I/O的时间</span></li><li style="text-align:left;"><span style="color:#000000;">一个指令周期常用若干机器周期表示【例，取指、间址、执行、中断】，周期数根据指令的不同可相应调整</span></li><li style="text-align:left;"><span style="color:#000000;">分类</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">定长的机器周期，每个机器包含的节拍数相等，通过计时区分指令阶段的转换</span></li><li style="text-align:left;"><span style="color:#000000;">不定长的机器周期，每个机器包含的节拍数不等，通过设定操作区分指令阶段的转换</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">时钟周期</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">一个机器周期由包含若干时钟周期，是计算机工作的最小时间周期</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">工作脉冲</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">控制器的最小时间单位，起定时触发作用，一个时钟周期有一个工作脉冲</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">存储周期</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">存储器进行两次独立的存储器操作（两次读或写操作）所需的最小间隔时间</span></li></ul></li></ul> 
     <p style="text-align:center;"><img alt="" height="150" src="https://images2.imgbox.com/7b/c9/WvpzKVPL_o.png" width="474"></p> 
     <p style="text-align:center;">图源：<a href="https://www.modb.pro/db/439663" rel="nofollow" title="404 - 墨天轮">404 - 墨天轮</a></p> 
    </blockquote> </li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E5%A4%87%E6%B3%A8"><strong>🐚</strong><span style="color:#000000;">备注</span></h4> 
    <blockquote> 
     <ul><li style="text-align:left;"><span style="color:#000000;">以下指令的注释风格大概为唐朔飞老师的版本，感兴趣也可参考袁春风老师的版本</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">R1寄存器间接寻址 减去 R2寄存器直接寻址 的数值 存入 R3寄存器</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">唐老师：((R1)) - (R2) → R3</span></li><li style="text-align:left;"><span style="color:#000000;">袁老师：M[R[1]] - R[2]→R[3]</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">MDR的内容写入PC</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">唐老师：(MDR) → PC</span></li><li style="text-align:left;"><span style="color:#000000;">袁老师：MDR → PC</span></li></ul></li></ul></li></ul> 
    </blockquote> </li><li style="text-align:left;"> <h3 id="%F0%9F%90%8B%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81"><strong>🐋</strong><span style="color:#000000;">指令周期的数据流</span></h3> 
    <ul><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F%E3%80%90FE%E3%80%91"><strong>🐚</strong><span style="color:#000000;">取指周期【FE】</span></h4> 
      <ul><li style="text-align:left;"><span style="color:#000000;">任务</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">根据 【PC】中存放的指令地址 从【主存】中取出指令字 并放入【IR】中</span></li><li style="text-align:left;"><span style="color:#000000;">取指操作是控制器固有的功能，不需要在操作码的控制下完成</span></li></ul> 
        </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">备注</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">可能访存，也可不访存【例，如果没有Cache与指令预取技术，则指令在主存，每个指令周期需要访存至少1次】</span></li><li style="text-align:left;"><span style="color:#000000;">以下为单字长指令访存举栗【多字长指令需要多次访存】</span></li></ul> 
        </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">数据流向</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">取指</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">将PC存放的指令地址，放入地址寄存器MAR：（PC）→MAR 或  （PC）→BUS→MAR | PCout和MARin有效</span></li><li style="text-align:left;"><span style="color:#000000;">CU发出主存读信号：1→R</span></li><li style="text-align:left;"><span style="color:#000000;">根据地址从主存取回指令，放入数据寄存器MDR等待信号稳定：M（MAR）→MDR | MDRinE、MemR有效</span></li><li style="text-align:left;"><span style="color:#000000;">数据寄存器MDR信号稳定后，放入指令寄存器：MDR→IR | MDRout和IRin有效</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">其它</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">指令译码：OP（IR）→CU</span></li><li style="text-align:left;"><span style="color:#000000;">PC自增：（PC）+1→PC | PC+1有效</span></li></ul></li></ul> 
         <p style="text-align:center;"><img alt="" height="306" src="https://images2.imgbox.com/b2/ce/FGvXnlml_o.png" width="640"></p> 
         <p style="text-align:center;">图源：<a href="https://juejin.cn/post/7022313020550283294" rel="nofollow" title="计算机组成原理——指令执行过程 - 掘金">计算机组成原理——指令执行过程 - 掘金</a></p> 
        </blockquote> </li></ul></li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F%E3%80%90IND%E3%80%91"><strong>🐚</strong><span style="color:#000000;">间址周期【IND】</span></h4> 
      <ul><li style="text-align:left;"><span style="color:#000000;">任务</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">取出【操作数】的有效地址</span></li><li style="text-align:left;"><span style="color:#000000;">寄存器和存储器间接寻址的步骤不同</span></li></ul> 
        </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">备注</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">非指令周期必须包含的阶段</span></li><li style="text-align:left;"><span style="color:#000000;">可能访存，也可不访存【例，取存储器地址需访存，取寄存器地址无需访存】</span></li><li style="text-align:left;"><span style="color:#000000;">以下为存储器一次间接寻址举栗【存储器多次间接寻址需要多次访存】【寄存器间接寻址不需要访存】</span></li></ul> 
        </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">数据流向</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">将指令中的形式地址，放入MAR：Ad（IR）→MAR | MARin有效</span></li><li style="text-align:left;"><span style="color:#000000;">CU发出主存读信号：1→R</span></li><li style="text-align:left;"><span style="color:#000000;">根据形式地址取回指令有效地址，放入数据寄存器：M（MAR）→MDR | MDRinE、MemR有效</span></li></ul> 
         <p style="text-align:center;"><img alt="" height="283" src="https://images2.imgbox.com/4b/02/pwPpLsmt_o.png" width="640"></p> 
         <p style="text-align:center;">图源：​​​​​​​<a href="https://juejin.cn/post/7022313020550283294" rel="nofollow" title="计算机组成原理——指令执行过程 - 掘金">计算机组成原理——指令执行过程 - 掘金</a></p> 
        </blockquote> </li></ul></li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F%E3%80%90EX%E3%80%91"><strong>🐚</strong><span style="color:#000000;">执行周期【EX】</span></h4> 
      <ul><li style="text-align:left;"><span style="color:#000000;">任务</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">取操作数，根据IR中的指令字的操作码通过ALU操作产生执行结果</span></li><li style="text-align:left;"><span style="color:#000000;">不同指令的执行周期操作不同，因此没有统一的数据流向</span></li><li style="text-align:left;"><span style="color:#000000;">常见功能</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">运算</span> 
             <ul><li style="text-align:left;"><span style="color:#000000;">算数运算、逻辑运算、清零、移位、取反、取补码 等</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">转移</span> 
             <ul><li style="text-align:left;"><span style="color:#000000;">有条件转移【BAN、BRANCH】，无条件转移【JMP】等</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">传送</span> 
             <ul><li style="text-align:left;"><span style="color:#000000;">访存：存数【STORE】、取数【LOAD】</span></li><li style="text-align:left;"><span style="color:#000000;">不访存：寄存器传送【MOVE】</span></li></ul></li></ul></li></ul> 
        </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">备注</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">可能访存，也可不访存【例，JMP指令不访存】</span></li><li style="text-align:left;"><span style="color:#000000;">以下为加法举栗【好像真题很喜欢考访存】</span></li></ul> 
        </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">数据流向【运算】</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">运算部件</span> 
          <blockquote> 
           <ul><li style="text-align:left;"><span style="color:#000000;">ALU、加法器、乘法器、除法器、符号扩展器/零扩展器</span></li><li style="text-align:left;"><span style="color:#000000;">移位寄存器、取反寄存器、自增自减寄存器、特殊功能寄存器</span></li><li style="text-align:left;"><span style="color:#000000;">门电路</span></li></ul> 
          </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">运算步骤</span> 
          <blockquote> 
           <ul><li style="text-align:left;"><span style="color:#000000;">取数【需访存】</span> 
             <ul><li style="text-align:left;"><span style="color:#000000;">将指令或寄存器中的有效地址，放入MAR：Ad（IR）→MAR，或MDR→MAR | MDRout与MARin有效</span></li><li style="text-align:left;"><span style="color:#000000;">CU发出主存读信号：1→R</span></li><li style="text-align:left;"><span style="color:#000000;">根据有效地址取回数据，放入数据寄存器：M（MAR）→MDR | MDRinE、MemR有效</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">运算【不访存】</span> 
             <ul><li style="text-align:left;"><span style="color:#000000;">累加寄存器 + MDR的数据，求和放回累加寄存器：（ACC）+MDR→ACC | ACCout和ALUin有效</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">存数【需访存】</span> 
             <ul><li style="text-align:left;"><span style="color:#000000;">将指令中的有效地址，放入MAR：Ad（IR）→MAR | MARin有效</span></li><li style="text-align:left;"><span style="color:#000000;">CU发出主存写信号：1→W</span></li><li style="text-align:left;"><span style="color:#000000;">将ACC寄存器的内容，放入数据寄存器：（ACC）→MDR | ACCout、MDRin和MDRinE有效</span></li><li style="text-align:left;"><span style="color:#000000;">根据有效地址，将数据寄存器的数据存入内存指定位置：（MDR）→M（MAR）| MDRout和MemW有效</span></li></ul></li></ul> 
           <p style="text-align:center;"><img alt="" height="404" src="https://images2.imgbox.com/4b/58/jTTfL2d1_o.png" width="600"></p> 
           <p style="text-align:center;">图源：<a href="https://zhuanlan.zhihu.com/p/139694705" rel="nofollow" title="CPU执行程序的原理（简化过程） - 知乎">CPU执行程序的原理（简化过程） - 知乎</a></p> 
          </blockquote> </li></ul></li><li style="text-align:left;"><span style="color:#000000;">数据流向【转移】</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">比较【CMP】，生成标志位CF、ZF、OF、SF；指令寄存器与标志寄存器相与，通过或门输出标志</span></li><li style="text-align:left;"><span style="color:#000000;">指令寻址方式，根据地址码：(1)相对寻址，PC+偏移量；(2)直接寻址</span></li></ul> 
        </blockquote> </li></ul></li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F%E3%80%90INT%E3%80%91"><strong>🐚</strong><span style="color:#000000;">中断周期【INT】</span></h4> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">任务</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">与I/O设备交互时，每条执行周期结束前需查询有无中断信号，是否需要进入中断响应阶段</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">备注</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">可能访存，也可不访存【例，若有中断信号，保护程序断点需访存，若无中断信号则无需响应】</span></li><li style="text-align:left;"><span style="color:#000000;">非指令周期必须包含的阶段</span></li><li style="text-align:left;"><span style="color:#000000;">以下为进入中断响应举栗</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">数据流向</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">栈顶指针</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">修改栈顶指针【向低地址增加】：（SP）-1→SP</span></li><li style="text-align:left;"><span style="color:#000000;">栈顶指针位置，存入地址寄存器：（SP）→MAR</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">保存断点</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">CU发出主存写信号：1→W</span></li><li style="text-align:left;"><span style="color:#000000;">程序断点，存入数据寄存器：（PC）→MDR | PCout和MDRin有效</span></li><li style="text-align:left;"><span style="color:#000000;">程序断点，存入主存的栈顶位置：（MDR）→M（MAR）| MDRout和MemW有效</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">中断地址</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">PC指向中断处理地址：向量地址→PC | PCin有效</span></li></ul></li></ul></li></ul> 
      </blockquote> </li></ul></li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88"><strong>🐚</strong><span style="color:#000000;">指令执行方案</span></h4> 
    <blockquote> 
     <ul><li style="text-align:left;"><span style="color:#000000;">单指令周期</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">所有指令的机器周期数相等</span></li><li style="text-align:left;"><span style="color:#000000;">指令之间串行执行</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">多指令周期</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">不要求指令的执行时间相等</span></li><li style="text-align:left;"><span style="color:#000000;">指令之间串行执行</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">流水线</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">指令之间并行执行</span></li></ul></li></ul> 
    </blockquote> </li></ul></li><li style="text-align:left;"> <h3 id="%F0%9F%90%8B%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><strong>🐋<span style="color:#000000;">数据通路的功能和基本结构</span></strong></h3> 
  <ul><li style="text-align:left;"> <h4><strong>🐚</strong><span style="color:#000000;">功能</span></h4> 
    <blockquote> 
     <ul><li style="text-align:left;"><span style="color:#000000;">数据在功能部件之间传送的路径称为数据通路，包括数据通路上流经的部件</span></li></ul> 
    </blockquote> </li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><strong>🐚</strong><span style="color:#000000;">基本结构</span></h4> 
    <blockquote> 
     <ul><li style="text-align:left;"><span style="color:#000000;">CPU内部单总线方式</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">描述：所有寄存器的输入端和输出端都链接到一条公共通路上</span></li><li style="text-align:left;"><span style="color:#000000;">特点：结构简单，数据容易冲突，性能较低</span></li><li style="text-align:left;"><span style="color:#000000;">备注</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">ALU需要配合暂存器使用</span></li><li style="text-align:left;"><span style="color:#000000;">不能配合单周期处理器工作，无法同时传送不同部件需要的控制信号</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">CPU内部多总线方式</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">描述：所有寄存器的输入端和输出端都连接到多条公共通路上</span></li><li style="text-align:left;"><span style="color:#000000;">特点：相比单总线提高效率，相比专用通路降低设计成本</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">专用数据通路方式</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">描述：指令执行过程中的数据和地址的流动方向安排连接线路</span></li><li style="text-align:left;"><span style="color:#000000;">特点：性能较高，但硬件量大</span></li></ul></li></ul> 
    </blockquote> </li></ul></li><li style="text-align:left;"> <h3 id="%F0%9F%90%8B%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><strong>🐋<span style="color:#000000;">控制器的功能和工作原理</span></strong></h3> 
  <ul><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD" style="background-color:transparent;"><strong>🐚</strong><span style="color:#000000;">控制器的主要功能</span></h4> 
    <blockquote> 
     <ul><li style="text-align:left;"><span style="color:#000000;">从主存中取出指令，并指出下一条指令在主存中的位置</span></li><li style="text-align:left;"><span style="color:#000000;">对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作</span></li><li style="text-align:left;"><span style="color:#000000;">指挥并控制CPU、主存、输入和输出设备之间的数据流动方向</span></li></ul> 
    </blockquote> </li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%E3%80%90%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E5%99%A8%E3%80%91"><strong>🐚</strong><span style="color:#000000;">硬布线控制器【组合逻辑控制器】</span></h4> 
    <blockquote> 
     <ul><li style="text-align:left;"><span style="color:#000000;">CU输入信号来源</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">指令信息</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">指令的操作码是控制单元的输入信号，它与时钟配合产生不同的控制信号</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">时序系统</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">产生机器周期信号和节拍信号，一个时钟脉冲使控制单元发送一个操作命令，或发送一组需要同时执行的操作命令</span></li><li style="text-align:left;"><span style="color:#000000;">时钟周期</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度正好对应一个时钟周期</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">机器周期</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">机器周期可视为所有指令执行过程中的一个基准时间</span></li><li style="text-align:left;"><span style="color:#000000;">定长的机器周期：以可能出现的最大节拍数【通常是访存节拍数】作为参考</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">指令周期</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">取指、间址、执行、中断</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">反馈信号【标志】</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">控制单元有时需依赖CPU当前所处的状态产生控制信号</span></li><li style="text-align:left;"><span style="color:#000000;">可能的来源：ACC、PSW、I/O、主存</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">CPU的控制方式</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">【总线定时】：同步控制方式 | 异步控制方式 | 联合控制方式 </span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">硬布线控制单元设计</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">列出微操作命令的操作时间表</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">机器周期</span></li><li style="text-align:left;"><span style="color:#000000;">每条指令完成的微操作控制信号</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">进行微操作信号综合</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">机器周期^节拍^脉冲^操作码^机器状态条件</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">画出微操作命令的逻辑视图</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">画出每个微操作信号的逻辑电路图，并用逻辑门电路实现</span></li></ul></li></ul></li></ul> 
     <p style="text-align:center;"><img alt="" height="826" src="https://images2.imgbox.com/5a/7b/TqeDAYPE_o.png" width="1200"></p> 
     <p style="text-align:center;">图源：<a href="https://blog.csdn.net/weixin_43715360/article/details/120608224" title="硬布线控制器（CU）一个很懒的人的博客-CSDN博客">硬布线控制器（CU）一个很懒的人的博客-CSDN博客</a></p> 
    </blockquote> </li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E5%BE%AE%E6%93%8D%E4%BD%9C%E6%8E%A7%E5%88%B6%E5%99%A8"><strong>🐚</strong><span style="color:#000000;">微操作控制器</span></h4> 
    <ul><li style="text-align:left;"><span style="color:#000000;">微程序</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">把每条机器指令编写成一个程序，每个微程序包括若干微指令，每条微指令对应一个或几个微操作命令【控制序列的最小单位】</span></li><li style="text-align:left;"><span style="color:#000000;">微指令←微程序←指令←程序</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">微操作：执行过程</span></li><li style="text-align:left;"><span style="color:#000000;">微命令：控制信号</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">相容性微命令：同时产生，共同完成某一些微操作</span></li><li style="text-align:left;"><span style="color:#000000;">互斥性微命令：机器中不允许同时出现的微命令</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">备注</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">机器指令的地址码字段——操作数位置</span></li><li style="text-align:left;"><span style="color:#000000;">机器指令的操作码字段——微程序入口地址</span></li><li style="text-align:left;"><span style="color:#000000;">微指令的微地址码字段——下一条微指令的位置</span></li><li style="text-align:left;"><span style="color:#000000;">微指令的微操作数字段——这一条微指令的微操作</span></li></ul></li></ul> 
      </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">微程序控制器组成</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">微地址形成部件</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">产生初始微地址和后继微地址，以保证微地址的连续运行</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">顺序逻辑</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">控制指令执行顺序</span></li><li style="text-align:left;"><span style="color:#000000;">可以处理中断、转移等特殊情况</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">微地址寄存器【CMAR】</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">也称微PC，接收微地址形成部件送来的微地址，为在CM中读取微指令作准备</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">控制存储器【CM】</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">微程序控制器的核心部件，用于存放个指令对应的微程序</span></li><li style="text-align:left;"><span style="color:#000000;">控制存储器用于存放微程序，在CPU内部，用ROM实现</span></li><li style="text-align:left;"><span style="color:#000000;">控制存储器的微程序个数 = 机器指令数+取指、间址和中断等公共的微程序数</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">微指令寄存器【CMDR】</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">也称微IR，存放从CM中取出的微指令</span></li><li style="text-align:left;"><span style="color:#000000;">位数同微指令字长相等</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">地址译码</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">将地址码转化为存储单元的控制信号</span></li></ul></li></ul> 
      </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">工作过程</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">微指令入口</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">执行取微指令公共操作，将 取指微程序的入口地址 送入 微地址寄存器【CMAR】</span></li><li style="text-align:left;"><span style="color:#000000;">根据微地址寄存器【CMAR】的存放地址，微指令寄存器【CMDR】从控制存储器【CM】读出微指令</span></li><li style="text-align:left;"><span style="color:#000000;">根据程序计数器【PC】的内容，从主存中取出机器指令，并存入指令寄存器【IR】</span></li><li style="text-align:left;"><span style="color:#000000;">指令寄存器【IR】存放指令的操作码字段【OP】通过 微地址形成部件 产生该机器指令所对应的微指令序列的起始地址</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">微指令序列</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">根据【顺序逻辑】的标志信息，确定下一条微指令的存放地址，并送入微地址寄存器【CMAR】</span></li><li style="text-align:left;"><span style="color:#000000;">微地址寄存器【CMAR】的信息经过地址译码，选中地址在控制寄存器【CM】中指向的指令</span></li><li style="text-align:left;"><span style="color:#000000;">微指令寄存器【CMDR】</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">功能：从控制存储器【CM】中逐条取出对应的微指令并执行</span></li><li style="text-align:left;"><span style="color:#000000;">操作码：微指令的操作码字段解析为 【CPU内部和系统总线】的控制信号</span></li><li style="text-align:left;"><span style="color:#000000;">下地址：的地址码字段指出下一条指令所在的地址，流入【顺序逻辑】循环执行</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">执行完对应于一条微指令的一个微程序后，又返回到取指微程序的入口地址，开始下一条机器指令的循环</span></li></ul></li></ul> 
       <p style="text-align:center;"><img alt="" height="358" src="https://images2.imgbox.com/51/fc/Ipn1w7I8_o.png" width="474"></p> 
       <p style="text-align:center;">图源：<a href="https://baike.baidu.com/pic/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8/3219845/1/8b82b9014a90f603eb75cdbb3012b31bb151ed01" rel="nofollow" title="微程序控制器图片_百度百科">微程序控制器图片_百度百科</a></p> 
      </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">编码方式</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">直接编码方式</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">无须译码，微指令字段中每位都代表一个微命令</span></li><li style="text-align:left;"><span style="color:#000000;">直观、执行速度快，但是指令字长过长，造成控制存储器容量极大</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">字段直接编码方式</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">把微命令分成若干小字段，把互斥性微命令组合在同一字段中，相容性微命令组合在不同字段中</span></li><li style="text-align:left;"><span style="color:#000000;">可以缩短指令字长，但因为要通过译码电路再发出微命令，因此比直接编码方式慢</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">字段间接编码方式</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">一个字段的微命令需由拎一个字段中的某些微命令来解释</span></li><li style="text-align:left;"><span style="color:#000000;">可进一步缩短微指令字长，但削弱了微指令的并行控制能力</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">微指令的格式</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">水平型微指令</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">指令中的一位对应一个控制信号，有时输出为1，否则为0</span></li><li style="text-align:left;"><span style="color:#000000;">一条水平型微指令定义并执行几种并行的基本操作</span></li><li style="text-align:left;"><span style="color:#000000;">预留每组的全0状态：表示什么都不做</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">垂直型微指令</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">一条垂直型微指令只能定义并执行一种基本操作</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">混合型微指令</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">在垂直型微指令的基础上增加一些不太复杂的并行操作</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">微程序控制单元的设计步骤</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">写出对应的机器指令的微操作命令及节拍安排</span></li><li style="text-align:left;"><span style="color:#000000;">确定微指令格式</span></li><li style="text-align:left;"><span style="color:#000000;">编写微指令码点</span></li></ul></li></ul> 
      </blockquote> </li></ul></li></ul></li><li style="text-align:left;"> <h3 id="%F0%9F%90%8B%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><strong>🐋<span style="color:#000000;">指令流水线</span></strong></h3> 
  <ul><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E6%8F%90%E9%AB%98%E5%A4%84%E7%90%86%E6%9C%BA%E5%B9%B6%E8%A1%8C%E6%80%A7"><strong>🐚</strong><span style="color:#000000;">提高处理机并行性</span></h4> 
    <blockquote> 
     <ul><li style="text-align:left;"><span style="color:#000000;">时间并行【流水线技术】：将一个任务分为不同的子阶段，每个阶段在不同的功能部件上并行执行，不一定需要设置重复的部件</span></li><li style="text-align:left;"><span style="color:#000000;">空间并行【超标量处理机】：在一个处理机馁设置多个执行相同任务的功能部件，并让这些部件并行工作，例如设置很多CPU同时工作</span></li><li style="text-align:left;"><span style="color:#000000;">备注：所有的RISC与部分CISC采用流水线技术</span></li></ul> 
    </blockquote> </li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><strong>🐚</strong><span style="color:#000000;">指令的执行过程</span></h4> 
    <blockquote> 
     <ul><li style="text-align:left;"><span style="color:#000000;">【MIPS架构】：取指【IF】、译码/读寄存器【ID】、执行/计算地址【EX】、访存【MEM】、写回【WB】</span></li></ul> 
    </blockquote> </li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><strong>🐚</strong><span style="color:#000000;">流水线的设计原则</span></h4> 
    <blockquote> 
     <ul><li style="text-align:left;"><span style="color:#000000;">指令流水段个数：以最复杂指令所用的功能段个数为准</span></li><li style="text-align:left;"><span style="color:#000000;">流水段的长度：以最复杂的操作所花的时间为准【单周期CPU】</span></li><li style="text-align:left;"><span style="color:#000000;">指令集的特征</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">指令长度尽量一致：有利于简化取指令和译码操作</span></li><li style="text-align:left;"><span style="color:#000000;">指令格式尽量规整：尽量保证源寄存器的位置相同</span></li><li style="text-align:left;"><span style="color:#000000;">采用Load/Store指令：其它指令都不能访问存储器，减少操作步骤</span></li><li style="text-align:left;"><span style="color:#000000;">数据和指令在存储器内“对齐”存放：减少访存次数</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">流水线的表示方法：时空图，横坐标表示时间，纵坐标表示空间</span></li></ul> 
    </blockquote> </li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><strong>🐚</strong><span style="color:#000000;">流水线的基本实现</span></h4> 
    <blockquote> 
     <ul><li style="text-align:left;"><span style="color:#000000;">取指【IF】</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">程序计数器【PC】</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">PC值作为地址从指令寄存器中取出第一条指令字</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">指令存储器【RD】</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">取出的指令字通过指令存储器【RD】的输入端送入 IF/ID 流水寄存器</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">下条指令地址的计算逻辑</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">计算PC+4</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">送入PC输入端，以便在下一条时钟周期取下条指令</span></li><li style="text-align:left;"><span style="color:#000000;">送入 IF/ID 流水寄存器，以备后续使用</span></li></ul></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">IF/ID 流水寄存器</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">锁存从指令存储器取出的指令字</span></li><li style="text-align:left;"><span style="color:#000000;">PC+4的值</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">译码/读寄存器【ID】</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">操作控制器【OP】</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">根据 IF/ID 流水寄存器 的指令字生成各段需要的控制信号</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">寄存器堆【WE】</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">对于1w访存指令，根据指令字中的rs、rt取出寄存器堆中的值RS和RT</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">符号扩展单元</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">将指令字中的16位立即数符号扩展为32位</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">多路选择器</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">根据指令字生成指令可能的写寄存编号WriteReg#</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">ID/EX 流水寄存器</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">锁存从寄存器堆中取出的两个数RS和RT（指令中两个操作数字段对应的寄存器值）</span></li><li style="text-align:left;"><span style="color:#000000;">写寄存器编号WriteReg#</span></li><li style="text-align:left;"><span style="color:#000000;">立即数符号扩展的值</span></li><li style="text-align:left;"><span style="color:#000000;">PC+4等后端可能用到的操作数</span></li><li style="text-align:left;"><span style="color:#000000;">控制信号</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">执行/计算地址【EX】</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">算数逻辑单元【ALU】</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">不固定，由具体指令确定</span></li><li style="text-align:left;"><span style="color:#000000;">例如，1w指令，EX主要计算访存地址 : ID/EX 流水寄存器 + 符号扩展后的立即数 = 访存地址 → EX/MEM流水寄存器</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">分支地址计算模块</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">计算分支地址，生成分支跳转信号 BranchTaken</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">EX/MEM 流水寄存器</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">ALU运算结果</span></li><li style="text-align:left;"><span style="color:#000000;">RT作为数据存储器待写入数据WriteData</span></li><li style="text-align:left;"><span style="color:#000000;">写寄存器编号WriteReg#</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">访存【MEM】</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">数据存储器读写模块</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">不固定，由具体指令确定</span></li><li style="text-align:left;"><span style="color:#000000;">例如，1w指令，根据 EX/MEM 流水寄存器中锁存的访存地址、写入数据和内存读写控制信号MemWrite对存储器进行读或写操作</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">MEM/WB 流水寄存器</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">数据存储器读出数据</span></li><li style="text-align:left;"><span style="color:#000000;">ALU运算结果</span></li><li style="text-align:left;"><span style="color:#000000;">写寄存器编号WriteReg#</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">写回【WB】</span> 
       <ul><li style="text-align:left;"><span style="color:#000000;">寄存器写入控制模块</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">将 MEM/WB 流水寄存器中的数据存储器读出的数据 写回 指令寄存器WriteReg#</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">备注：以上主要包含数据通路的组合逻辑。实际上，时序逻辑，以及一大堆看着脑袋疼的控制信号还没有写——</span></li></ul> 
     <p style="text-align:center;"><img alt="" height="399" src="https://images2.imgbox.com/e6/08/5nZyLTyl_o.png" width="657"></p> 
     <p style="text-align:center;">图源：<a href="http://t.zoukankan.com/yanzs-p-13788261.html" rel="nofollow" title="体系结构笔记------MIPS流水线的简单实现 - 走看看">体系结构笔记------MIPS流水线的简单实现 - 走看看</a></p> 
    </blockquote> </li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%86%92%E9%99%A9%E4%B8%8E%E5%A4%84%E7%90%86"><strong>🐚</strong><span style="color:#000000;">流水线的冒险与处理</span></h4> 
    <ul><li style="text-align:left;"><span style="color:#000000;">结构冒险</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">资源冲突</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">多条指令在同一时刻争用统一资源</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">解决方法</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">前一指令访存时，使后一条相关指令（以及后续指令）暂停一个时钟周期</span></li><li style="text-align:left;"><span style="color:#000000;">单独设置数据寄存器和指令寄存器，使取数和取指令操作各自在不同的存储器中进行【数据Cache与指令Cache分离】</span></li></ul></li></ul> 
       <p style="text-align:center;"><img alt="" height="1200" src="https://images2.imgbox.com/84/6a/5p0xvuQf_o.png" width="1200"></p> 
       <p style="text-align:center;">图源：<a href="https://hitsz-cslab.gitee.io/cpu/lab3/3-hazard/" rel="nofollow" title="指令相关与流水线冒险 | 哈工大（深圳） (gitee.io)">指令相关与流水线冒险 | 哈工大（深圳） (gitee.io)</a></p> 
      </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">数据冒险</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">数据冲突</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">下一条指令会用到当前计算的结果，可分为写后读、读后写、写后写</span></li><li style="text-align:left;"><span style="color:#000000;">主要为ID段【读寄存器】、WB段【写寄存器】与MEM段【写内存】的冲突</span></li><li style="text-align:left;"><span style="color:#000000;">若采用按序发射、按序完成时，只可能出现“写后读”冲突【RAW相关】</span> 
           <ul><li style="text-align:left;"><span style="color:#000000;">最常见的是同一变量在WB段【写寄存器】与ID段【读寄存器】的冲突</span></li><li style="text-align:left;"><span style="color:#000000;">简单情况：可以检查箭头的右侧（写），与其后指令的左侧（读）是否有冲突，若相邻且不采用转发技术一般都会冲突</span></li><li style="text-align:left;"><span style="color:#000000;">复杂情况：画流水线时序图，通常间隔3条无阻塞的指令后（与第1条指令WB时间并行的MEM、EX、ID），第4条指令不会出现冲突</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">若采用乱序发射，可能出现“读后写”冲突</span></li><li style="text-align:left;"><span style="color:#000000;">若采用多个功能部件，例如同时使用运算器，可能出现“写后写”冲突</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">解决方法</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">数据相关的指令及其后续指令都暂停一至几个周期，可分为 硬件堵塞stall 和 软件插入NOP指令（空指令）两种方法</span></li><li style="text-align:left;"><span style="color:#000000;">设置相关专用通路，直接把前一条指令的ALU计算结果作为自己的输入数据开始计算过程，无需等到写回WB段【数据旁路技术 | 转发技术】</span></li><li style="text-align:left;"><span style="color:#000000;">对数据相关的指令编译优化，调整指令顺序</span></li></ul></li></ul> 
       <p style="text-align:center;"><img alt="" height="650" src="https://images2.imgbox.com/e7/dc/lICLuD7w_o.png" width="1152"></p> 
       <p style="text-align:center;">图源：<a href="https://hitsz-cslab.gitee.io/cpu/lab3/4-handleDH/" rel="nofollow" title="数据冒险的处理 - 哈工大（深圳） (gitee.io)">数据冒险的处理 - 哈工大（深圳） (gitee.io)</a></p> 
      </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">控制冒险</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">控制冒险</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">指令通常是顺序执行的，有时遇到改变指令执行顺序，例如执行转移、调用或返回等指令，会改变PC的值</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">解决方法</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">对转移指令进行分支预测，尽早转移目标地址</span></li><li style="text-align:left;"><span style="color:#000000;">预取转移成功和不成功两个控制流方向上的目标指令，就是两个方向同时执行</span></li><li style="text-align:left;"><span style="color:#000000;">加快和提前形成条件码，适用于条件转移指令</span></li><li style="text-align:left;"><span style="color:#000000;">提高转移方向的猜准率</span></li></ul></li></ul> 
       <p style="text-align:center;"><img alt="" height="1200" src="https://images2.imgbox.com/6e/ba/ZqnkC3SV_o.png" width="1200"></p> 
       <p style="text-align:center;">图源：<a href="https://hitsz-cslab.gitee.io/cpu/lab3/3-hazard/" rel="nofollow" title="指令相关与流水线冒险 - | 哈工大（深圳） (gitee.io)">指令相关与流水线冒险 - | 哈工大（深圳） (gitee.io)</a></p> 
      </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">备注</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">空指令和暂停时钟周期属于解决冒险的万金油技术（感觉实际相当于这段串行处理：若我不用流水线，阁下又如何用流水线的冒险为难我？狗头.jpg）</span></li></ul> 
      </blockquote> </li></ul></li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><strong>🐚</strong><span style="color:#000000;">流水线的性能指标</span></h4> 
    <ul><li style="text-align:left;"><span style="color:#000000;">流水线的吞吐率TP</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">基本公式</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">﻿<img alt="TP=n/T_k" class="mathcode" src="https://images2.imgbox.com/b5/42/1l99YvfN_o.png">，n：任务数，Tk：完成n的任务所用的总时间</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">流水线</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">理想：<img alt="TP=n/[(k+n-1)\Delta t]" class="mathcode" src="https://images2.imgbox.com/2e/a8/VrHV6G2D_o.png">﻿，n：任务数，k：流水线段数，k+n-1：k段流水线消耗的时钟周期个数，t：时钟周期</span></li><li style="text-align:left;"><span style="color:#000000;">极限：<img alt="TP_{max}=n/\Delta t" class="mathcode" src="https://images2.imgbox.com/f6/12/eTO8sS8o_o.png">，n：任务数，t：时钟周期</span></li></ul></li></ul> 
      </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">流水线的加速比S</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">基本公式</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;"><img alt="S=T_0/T_k" class="mathcode" src="https://images2.imgbox.com/56/2b/easOmQ9G_o.png">﻿，T0：顺序执行的时间，Tk：使用流水线的总时间</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">流水线</span> 
         <ul><li style="text-align:left;"><span style="color:#000000;">理想：<img alt="S=kn\Delta t/[(k+n-1)\Delta t]=kn/[(k+n-1)]" class="mathcode" src="https://images2.imgbox.com/90/f7/WhDBLMeu_o.png">﻿，n：任务数，k：流水线段数，k+n-1：k段流水线消耗的时钟周期个数，t：时钟周期</span></li><li style="text-align:left;"><span style="color:#000000;">极限：﻿<img alt="S_{max}=k" class="mathcode" src="https://images2.imgbox.com/0e/33/YryoDjOR_o.png">，n：任务数，t：时钟周期</span></li></ul></li></ul> 
      </blockquote> </li></ul></li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E9%AB%98%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><strong>🐚</strong><span style="color:#000000;">高级流水线技术</span></h4> 
    <ul><li style="text-align:left;"><span style="color:#000000;">超标量流水线技术</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">内置多条流水线（例如，度为4就是4条流水线并行），每个时钟周期内可并发多条独立指令【CPI＜1】，其实质是以空间换取时间</span></li><li style="text-align:left;"><span style="color:#000000;">需要结合动态调度技术减少并行指令的冲突，提高指令并行性</span></li></ul> 
      </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">超长指令字技术</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">将多条能并行操作的指令组合成一条具有多个操作码字段的超长字指令（可达几百位），对于优化编译器和指令寄存器的要求更高</span></li></ul> 
      </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">超流水线技术</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">通过提高流水线主频的方式来提升流水线性能，能缩短流水线功能段的处理时间</span></li></ul> 
      </blockquote> </li></ul></li></ul></li><li style="text-align:left;"> <h3 id="%F0%9F%90%8B%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><strong>🐋<span style="color:#000000;">多处理器的基本概念</span></strong></h3> 
  <ul><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB"><strong>🐚</strong><span style="color:#000000;">计算机体系</span></h4> 
    <ul><li style="text-align:left;"><span style="color:#000000;">单指令流单数据流结构【SISD】</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">处理器在一段时间内仅执行一条指令，因此不是数据级并行</span></li><li style="text-align:left;"><span style="color:#000000;">仅包含一个处理器+一个存储器，可以采用流水线、多个功能部件</span></li><li style="text-align:left;"><span style="color:#000000;">计组学习基本就是这种的</span></li></ul> 
      </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">单指令流多数据流结构【SIMD】</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">基础版本</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">一个指令流同时对多个数据流进行并行处理，一般称为数据级并行技术</span></li><li style="text-align:left;"><span style="color:#000000;">通常采用一个指令控制部件+多个处理单元，每个单元都有自己的地址寄存器，不同处理单元执行同一条指令所处理的数据是不同的</span></li><li style="text-align:left;"><span style="color:#000000;">擅长使用处理for循环，不擅长处理switch与case</span></li></ul> 
        </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">变体版本【向量处理器】</span> 
        <blockquote> 
         <ul><li style="text-align:left;"><span style="color:#000000;">实现了直接操作一维数组【向量】指令集的CPU</span></li><li style="text-align:left;"><span style="color:#000000;">在特定工作环境中极大地提升了性能，尤其是数值模拟或者相似的领域中</span></li></ul> 
        </blockquote> </li></ul></li><li style="text-align:left;"><span style="color:#000000;">多指令流单数据流结构【MISD】</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">资源浪费，实际上不存在这样的计算机</span></li></ul> 
      </blockquote> </li><li style="text-align:left;"><span style="color:#000000;">多指令流多数据流结构【MIMD】</span> 
      <blockquote> 
       <ul><li style="text-align:left;"><span style="color:#000000;">多条指令分别处理多个不同的数据，一般称为线程级并行技术，甚至可以做到线程级以上并行</span></li><li style="text-align:left;"><span style="color:#000000;">多计算机系统：每个计算机节点都具有各自的私有存储器，并具备独立的主存地址空间</span></li><li style="text-align:left;"><span style="color:#000000;">多处理器系统【SMP】：具有共享的单一地址空间，通过存取指令来访问系统中的所有存储器</span></li></ul> 
      </blockquote> </li></ul></li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E7%A1%AC%E4%BB%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B"><strong>🐚</strong><span style="color:#000000;">硬件多线程</span></h4> 
    <blockquote> 
     <ul><li style="text-align:left;"><span style="color:#000000;">细粒度线程：多个线程之间轮流交叉执行指令；多条线程之间的指令不相关，可以乱序执行</span></li><li style="text-align:left;"><span style="color:#000000;">粗粒度线程：仅在一个线程出现了较大的阻塞时，才切换线程</span></li><li style="text-align:left;"><span style="color:#000000;">同时多线程：在同一个时钟周期中，发射多个不同线程中的多条指令执行</span></li></ul> 
    </blockquote> </li><li style="text-align:left;"> <h4 id="%F0%9F%90%9A%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8"><strong>🐚</strong><span style="color:#000000;">多核处理器</span></h4> 
    <blockquote> 
     <ul><li style="text-align:left;"><span style="color:#000000;">基本概念：将多个处理单元集成到单个CPU中，每个处理单元称为一个核；每个核可以拥有自己的Cache，也可以共享同一个Cache</span></li><li style="text-align:left;"><span style="color:#000000;">体系要求：多指令流多数据流结构【MIMD】才能充分发挥硬件的性能</span></li></ul> 
    </blockquote> </li></ul></li></ul> 
<hr> 
<h2 id="%F0%9F%94%9A%E7%BB%93%E8%AF%AD">🔚结语</h2> 
<p>😶‍🌫️博文到此结束，写得模糊或者有误之处，欢迎小伙伴留言讨论与批评，督促博主优化内容~</p> 
<p>🌟博文若有帮助，欢迎小伙伴动动可爱的小手<strong>默默给个赞支持一下</strong>，博主肝文的动力++~</p> 
<p>🌸博主可能会佛系更新思维导图，在这里：</p> 
<p><a class="has-card" href="https://blog.csdn.net/weixin_42789937/category_12434026.html?spm=1001.2014.3001.5482" title="计算机组成原理_梅头脑_的博客-CSDN博客"><span class="link-card-box"><span class="link-title">计算机组成原理_梅头脑_的博客-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/82/10/acgvm3lH_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/weixin_42789937/category_12434026.html?spm=1001.2014.3001.5482</span></span></a><a class="has-card" href="https://blog.csdn.net/weixin_42789937/category_12434025.html" title="操作系统_梅头脑_的博客-CSDN博客"><span class="link-card-box"><span class="link-title">操作系统_梅头脑_的博客-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/b7/cc/mPLRO8Dt_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/weixin_42789937/category_12434025.html</span></span></a>🌸博主也有整理数据结构学习笔记，在这里：</p> 
<p><a class="has-card" href="https://blog.csdn.net/weixin_42789937/category_12262100.html?spm=1001.2014.3001.5482" title="数据结构_梅头脑_的博客-CSDN博客"><span class="link-card-box"><span class="link-title">数据结构_梅头脑_的博客-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/a6/48/W95WGvSv_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/weixin_42789937/category_12262100.html?spm=1001.2014.3001.5482</span></span></a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/95dc64b1ecb3789f8f87f7e227dc689c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">拓扑排序软件设计——ToplogicalSort_app（含有源码、需求分析、可行性分析、概要设计、用户使用手册）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/89e5e923acba2ba20e1da05548e4d95b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Java开发】之获取客户端真实 IP 地址</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>