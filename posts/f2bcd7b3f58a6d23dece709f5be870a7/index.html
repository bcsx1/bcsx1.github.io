<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STL详解（很全） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STL详解（很全）" />
<meta property="og:description" content="目录
概述
STL六大组件简介 三大组件介绍
1.容器
2.算法
3.迭代器 常用容器
1. string容器
string容器基本概念
string容器常用操作 2. vector容器
vector容器基本概念
vector迭代器
vector的数据结构
vector常用API操作
3. deque容器
deque容器基本概念 deque容器实现原理
deque常用API
4. stack容器
stack容器基本概念
stack没有迭代器
stack常用API
5. queue容器
queue容器基本概念
queue没有迭代器
queue常用API 6. list容器
list容器基本概念
list容器的迭代器 list容器的数据结构
list常用API
7. set/multiset容器
set容器基本概念
multiset容器基本概念
set常用API 对组(pair)
8. map/multimap容器
map/multimap基本概念 map/multimap常用API
STL容器使用时机
概述 长久以来，软件界一直希望建立一种可重复利用的东西，以及一种得以制造出”可重复运用的东西”的方法，从函数(functions)，类别(classes),函数库(function libraries),类别库(class libraries)、各种组件，从模块化设计，到面向对象(object oriented )，为的就是复用性的提升。
复用性必须建立在某种标准之上。但是在许多环境下，就连软件开发最基本的数据结构(data structures) 和算法(algorithm)都未能有一套标准。大量程序员被迫从事大量重复的工作，竟然是为了完成前人已经完成而自己手上并未拥有的程序代码，这不仅是人力资源的浪费，也是挫折与痛苦的来源。
为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性(相互合作性,interoperability),诞生了STL。
STL(Standard Template Library,标准模板库)，是惠普实验室开发的一系列软件的统称。现在主要出现在 c&#43;&#43;中，但是在引入 c&#43;&#43;之前该技术已经存在很长时间了。
STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f2bcd7b3f58a6d23dece709f5be870a7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-13T14:46:32+08:00" />
<meta property="article:modified_time" content="2022-01-13T14:46:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STL详解（很全）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E6%A6%82%E8%BF%B0" rel="nofollow">概述</a></p> 
<p id="STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B%C2%A0-toc" style="margin-left:0px;"><a href="#STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B%C2%A0" rel="nofollow">STL六大组件简介 </a></p> 
<p id="%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D" rel="nofollow">三大组件介绍</a></p> 
<p id="1.%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#1.%E5%AE%B9%E5%99%A8" rel="nofollow">1.容器</a></p> 
<p id="2.%E7%AE%97%E6%B3%95-toc" style="margin-left:40px;"><a href="#2.%E7%AE%97%E6%B3%95" rel="nofollow">2.算法</a></p> 
<p id="3.%E8%BF%AD%E4%BB%A3%E5%99%A8%C2%A0-toc" style="margin-left:40px;"><a href="#3.%E8%BF%AD%E4%BB%A3%E5%99%A8%C2%A0" rel="nofollow">3.迭代器 </a></p> 
<p id="%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8" rel="nofollow">常用容器</a></p> 
<p id="1.%20string%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#1.%20string%E5%AE%B9%E5%99%A8" rel="nofollow">1. string容器</a></p> 
<p id="string%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#string%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">string容器基本概念</a></p> 
<p id="string%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%C2%A0-toc" style="margin-left:80px;"><a href="#string%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%C2%A0" rel="nofollow">string容器常用操作 </a></p> 
<p id="2.%20vector%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#2.%20vector%E5%AE%B9%E5%99%A8" rel="nofollow">2. vector容器</a></p> 
<p id="vector%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#vector%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">vector容器基本概念</a></p> 
<p id="vector%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:80px;"><a href="#vector%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow">vector迭代器</a></p> 
<p id="vector%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#vector%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">vector的数据结构</a></p> 
<p id="vector%E5%B8%B8%E7%94%A8API%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#vector%E5%B8%B8%E7%94%A8API%E6%93%8D%E4%BD%9C" rel="nofollow">vector常用API操作</a></p> 
<p id="3.%20deque%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#3.%20deque%E5%AE%B9%E5%99%A8" rel="nofollow">3. deque容器</a></p> 
<p id="deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%C2%A0-toc" style="margin-left:80px;"><a href="#deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%C2%A0" rel="nofollow">deque容器基本概念 </a></p> 
<p id="deque%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#deque%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" rel="nofollow">deque容器实现原理</a></p> 
<p id="deque%E5%B8%B8%E7%94%A8API-toc" style="margin-left:80px;"><a href="#deque%E5%B8%B8%E7%94%A8API" rel="nofollow">deque常用API</a></p> 
<p id="4.%20stack%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#4.%20stack%E5%AE%B9%E5%99%A8" rel="nofollow">4. stack容器</a></p> 
<p id="stack%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#stack%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">stack容器基本概念</a></p> 
<p id="stack%E6%B2%A1%E6%9C%89%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:80px;"><a href="#stack%E6%B2%A1%E6%9C%89%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow">stack没有迭代器</a></p> 
<p id="stack%E5%B8%B8%E7%94%A8API-toc" style="margin-left:80px;"><a href="#stack%E5%B8%B8%E7%94%A8API" rel="nofollow">stack常用API</a></p> 
<p id="5.%20queue%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#5.%20queue%E5%AE%B9%E5%99%A8" rel="nofollow">5. queue容器</a></p> 
<p id="queue%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#queue%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">queue容器基本概念</a></p> 
<p id="queue%E6%B2%A1%E6%9C%89%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:80px;"><a href="#queue%E6%B2%A1%E6%9C%89%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow">queue没有迭代器</a></p> 
<p id="queue%E5%B8%B8%E7%94%A8API%C2%A0-toc" style="margin-left:80px;"><a href="#queue%E5%B8%B8%E7%94%A8API%C2%A0" rel="nofollow">queue常用API </a></p> 
<p id="6.%20list%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#6.%20list%E5%AE%B9%E5%99%A8" rel="nofollow">6. list容器</a></p> 
<p id="%C2%A0list%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#%C2%A0list%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">list容器基本概念</a></p> 
<p id="list%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%C2%A0-toc" style="margin-left:80px;"><a href="#list%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%C2%A0" rel="nofollow">list容器的迭代器 </a></p> 
<p id="list%E5%AE%B9%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#list%E5%AE%B9%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">list容器的数据结构</a></p> 
<p id="list%E5%B8%B8%E7%94%A8API-toc" style="margin-left:80px;"><a href="#list%E5%B8%B8%E7%94%A8API" rel="nofollow">list常用API</a></p> 
<p id="7.%20set%2Fmultiset%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#7.%20set%2Fmultiset%E5%AE%B9%E5%99%A8" rel="nofollow">7. set/multiset容器</a></p> 
<p id="set%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#set%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">set容器基本概念</a></p> 
<p id="multiset%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#multiset%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">multiset容器基本概念</a></p> 
<p id="set%E5%B8%B8%E7%94%A8API%C2%A0-toc" style="margin-left:80px;"><a href="#set%E5%B8%B8%E7%94%A8API%C2%A0" rel="nofollow">set常用API </a></p> 
<p id="%E5%AF%B9%E7%BB%84(pair)-toc" style="margin-left:80px;"><a href="#%E5%AF%B9%E7%BB%84%28pair%29" rel="nofollow">对组(pair)</a></p> 
<p id="8.%20map%2Fmultimap%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#8.%20map%2Fmultimap%E5%AE%B9%E5%99%A8" rel="nofollow">8. map/multimap容器</a></p> 
<p id="map%2Fmultimap%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%C2%A0-toc" style="margin-left:80px;"><a href="#map%2Fmultimap%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%C2%A0" rel="nofollow">map/multimap基本概念 </a></p> 
<p id="map%2Fmultimap%E5%B8%B8%E7%94%A8API-toc" style="margin-left:80px;"><a href="#map%2Fmultimap%E5%B8%B8%E7%94%A8API" rel="nofollow">map/multimap常用API</a></p> 
<p id="STL%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-toc" style="margin-left:0px;"><a href="#STL%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA" rel="nofollow">STL容器使用时机</a></p> 
<hr id="hr-toc"> 
<h2>概述</h2> 
<p> </p> 
<p>长久以来，软件界一直希望建立一种可重复利用的东西，以及一种得以制造出”可重复运用的东西”的方法，从函数(functions)，类别(classes),函数库(function libraries),类别库(class libraries)、各种组件，从模块化设计，到面向对象(object oriented )，为的就是复用性的提升。</p> 
<p>复用性必须建立在某种标准之上。但是在许多环境下，就连软件开发最基本的数据结构(data structures) 和算法(algorithm)都未能有一套标准。大量程序员被迫从事大量重复的工作，竟然是为了完成前人已经完成而自己手上并未拥有的程序代码，这不仅是人力资源的浪费，也是挫折与痛苦的来源。</p> 
<p>为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性(相互合作性,interoperability),诞生了STL。</p> 
<p>STL(Standard Template Library,标准模板库)，是惠普实验室开发的一系列软件的统称。现在主要出现在 c++中，但是在引入 c++之前该技术已经存在很长时间了。</p> 
<p>STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)。</p> 
<p>容器和算法之间通过迭代器进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。</p> 
<p>STL(Standard Template Library)标准模板库,在我们 c++标准程序库中隶属于 STL 的占到了 80%以上。</p> 
<h2 id="STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B%C2%A0">STL六大组件简介 </h2> 
<p>STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:<strong>容器</strong>、<strong>算法</strong>、<strong>迭代器</strong>、<strong>仿函数</strong>、<strong>适配器（配接器）</strong>、<strong>空间配置器</strong>。</p> 
<p><strong>容器</strong>：各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。</p> 
<p><strong>算法</strong>：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</p> 
<p><strong>迭代器</strong>：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</p> 
<p><strong>仿函数</strong>：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template</p> 
<p><strong>适配器</strong>：一种用来修饰容器或者仿函数或迭代器接口的东西。</p> 
<p><strong>空间配置器：</strong>负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.</p> 
<p>STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。</p> 
<p><strong>STL的优点很明显了：</strong></p> 
<ul><li>STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</li><li>STL 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互运作</li><li>程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。这样他们就可以把精力放在程序开发的别的方面。</li><li>STL 具有<strong>高可重用性</strong>，<strong>高性能</strong>，<strong>高移植性</strong>，<strong>跨平台</strong>的优点。</li></ul> 
<p>        <strong>高可重用性：</strong>STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。<br>        <strong> 高性能：</strong>如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。<br>         <strong>高移植性</strong>：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。</p> 
<h2 id="%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D">三大组件介绍</h2> 
<h3 id="1.%E5%AE%B9%E5%99%A8">1.容器</h3> 
<p>几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。<br> 常用的数据结构：<strong>数组</strong>(array) , <strong>链表</strong>(list), tree(<strong>树</strong>)，<strong>栈</strong>(stack), <strong>队列</strong>(queue), <strong>集合</strong>(set),<strong>映射表</strong>(map), 根据数据在容器中的排列特性，这些数据分为序列式容器和关联式容器两种。</p> 
<ul><li>序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。</li><li>关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器<br>  </li></ul> 
<h3 id="2.%E7%AE%97%E6%B3%95">2.算法</h3> 
<p>算法，问题的解法，以有限的步骤，解决逻辑或数学上的问题。</p> 
<p>我们所编写的每个程序都是一个算法，其中的每个函数也都是一个算法，毕竟它们都是用来解决或大或小的逻辑问题或数学问题。STL收录的算法经过了数学上的效能分析与证明，是极具复用价值的，包括常用的排序，查找等等。特定的算法往往搭配特定的数据结构，算法与数据结构相辅相成。</p> 
<p>算法分为:质变算法和非质变算法。</p> 
<ul><li>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</li><li>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等<br>  </li></ul> 
<h3 id="3.%E8%BF%AD%E4%BB%A3%E5%99%A8%C2%A0">3.迭代器 </h3> 
<p>迭代器(iterator)是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。 在&lt;&lt;Design Patterns&gt;&gt;一书中提供了23种设计模式的完整描述， 其中iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p> 
<p>迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器(container)和算法(algorithms)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。</p> 
<p>从技术角度来看，容器和算法的泛型化并不困难，c++的class template和function template可分别达到目标，如果设计出两这个之间的良好的胶着剂，才是大难题。</p> 
<p><strong>迭代器的种类: </strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td style="width:90px;"><strong>迭代器</strong></td><td style="width:268px;"><strong>功能</strong></td><td style="width:292px;"><strong>描述</strong></td></tr><tr><td style="width:90px;">输入迭代器</td><td style="width:268px;">提供对数据的只读访问</td><td style="width:292px;">只读，支持++、==、!=</td></tr><tr><td style="width:90px;">输出迭代器</td><td style="width:268px;">提供对数据的只写访问</td><td style="width:292px;">只写，支持++</td></tr><tr><td style="width:90px;">前向迭代器</td><td style="width:268px;">提供读写操作，并能向前推进迭代器</td><td style="width:292px;">只读，支持++、==、!=</td></tr><tr><td style="width:90px;">双向迭代器</td><td style="width:268px;">提供读写操作，并能向前和向后操作</td><td style="width:292px;">读写，支持++、--</td></tr><tr><td style="width:90px;">随机访问迭代器</td><td style="width:268px;">提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器</td><td style="width:292px;">读写，支持++、--、+n、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table> 
<p><strong>演示： </strong></p> 
<p></p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

//STL 中的容器 算法 迭代器
void test01(){
	vector&lt;int&gt; v; //STL 中的标准容器之一 ：动态数组
	v.push_back(1); //vector 容器提供的插入数据的方法
	v.push_back(5);
	v.push_back(3);
	v.push_back(7);
	//迭代器
	vector&lt;int&gt;::iterator pStart = v.begin(); //vector 容器提供了 begin()方法 返回指向第一个元素的迭代器
	vector&lt;int&gt;::iterator pEnd = v.end(); //vector 容器提供了 end()方法 返回指向最后一个元素下一个位置的迭代器
	//通过迭代器遍历
	while (pStart != pEnd){
		cout &lt;&lt; *pStart &lt;&lt; " ";
		pStart++;
	}
	cout &lt;&lt; endl;
	//算法 count 算法 用于统计元素的个数
	int n = count(pStart, pEnd, 5);
	cout &lt;&lt; "n:" &lt;&lt; n &lt;&lt; endl;
}
//STL 容器不单单可以存储基础数据类型，也可以存储类对象
class Teacher
{
public:
	Teacher(int age) :age(age){};
	~Teacher(){};
public:
	int age;
};
void test02(){
	vector&lt;Teacher&gt; v; //存储 Teacher 类型数据的容器
	Teacher t1(10), t2(20), t3(30);
	v.push_back(t1);
	v.push_back(t2);
	v.push_back(t3);
	vector&lt;Teacher&gt;::iterator pStart = v.begin();
	vector&lt;Teacher&gt;::iterator pEnd = v.end();
	//通过迭代器遍历
	while (pStart != pEnd){
		cout &lt;&lt; pStart-&gt;age &lt;&lt; " ";
		pStart++;
	}
	cout &lt;&lt; endl;
}
//存储 Teacher 类型指针
void test03(){
	vector&lt;Teacher*&gt; v; //存储 Teacher 类型指针
	Teacher* t1 = new Teacher(10);
	Teacher* t2 = new Teacher(20);
	Teacher* t3 = new Teacher(30);
	v.push_back(t1);
	v.push_back(t2);
	v.push_back(t3);
	//拿到容器迭代器
	vector&lt;Teacher*&gt;::iterator pStart = v.begin();
	vector&lt;Teacher*&gt;::iterator pEnd = v.end();
	//通过迭代器遍历
	while (pStart != pEnd){
		cout &lt;&lt; (*pStart)-&gt;age &lt;&lt; " ";
		pStart++;
	}
	cout &lt;&lt; endl;
}
//容器嵌套容器 难点
void test04()
{
	vector&lt; vector&lt;int&gt; &gt; v;
	vector&lt;int&gt;v1;
	vector&lt;int&gt;v2;
	vector&lt;int&gt;v3;

	for (int i = 0; i &lt; 5;i++)
	{
		v1.push_back(i);
		v2.push_back(i * 10);
		v3.push_back(i * 100);
	}
	v.push_back(v1);
	v.push_back(v2);
	v.push_back(v3);

	for (vector&lt; vector&lt;int&gt; &gt;::iterator it = v.begin(); it != v.end();it++)
	{
		for (vector&lt;int&gt;::iterator subIt = (*it).begin(); subIt != (*it).end(); subIt ++)
		{
			cout &lt;&lt; *subIt &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}
} 
int main(){
	//test01();
	//test02();
	//test03();
	test04();
	system("pause");
	return EXIT_SUCCESS;
}
</code></pre> 
<h2 id="%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8">常用容器</h2> 
<h3 id="1.%20string%E5%AE%B9%E5%99%A8">1. string容器</h3> 
<h4 id="string%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">string容器基本概念</h4> 
<p>C风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种string类，定义在头文件&lt;string&gt;。<br> string和c风格字符串对比：</p> 
<ul><li>char*是一个指针，string是一个类<br> string封装了char*，管理这个字符串，是一个char*型的容器。</li><li>string封装了很多实用的成员方法<br> 查找find，拷贝copy，删除delete 替换replace，插入insert</li><li>不用考虑内存释放和越界<br> string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</li></ul> 
<h4 id="string%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%C2%A0">string容器常用操作 </h4> 
<p><strong>string 构造函数</strong> </p> 
<pre><code>string();//创建一个空的字符串 例如: string str;      
string(const string&amp; str);//使用一个string对象初始化另一个string对象
string(const char* s);//使用字符串s初始化
string(int n, char c);//使用n个字符c初始化 
</code></pre> 
<p><strong>string基本赋值操作</strong> </p> 
<pre><code>string&amp; operator=(const char* s);//char*类型字符串 赋值给当前的字符串
string&amp; operator=(const string &amp;s);//把字符串s赋给当前的字符串
string&amp; operator=(char c);//字符赋值给当前的字符串
string&amp; assign(const char *s);//把字符串s赋给当前的字符串
string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串
string&amp; assign(const string &amp;s);//把字符串s赋给当前字符串
string&amp; assign(int n, char c);//用n个字符c赋给当前字符串
string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串
</code></pre> 
<p><strong>string存取字符操作</strong></p> 
<pre><code>char&amp; operator[](int n);//通过[]方式取字符
char&amp; at(int n);//通过at方法获取字符，会检查下标越界问题</code></pre> 
<p><strong>string拼接操作</strong> </p> 
<pre><code>string&amp; operator+=(const string&amp; str);//重载+=操作符
string&amp; operator+=(const char* str);//重载+=操作符
string&amp; operator+=(const char c);//重载+=操作符
string&amp; append(const char *s);//把字符串s连接到当前字符串结尾
string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾
string&amp; append(const string &amp;s);//同operator+=()
string&amp; append(const string &amp;s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾
string&amp; append(int n, char c);//在当前字符串结尾添加n个字符c
</code></pre> 
<p><strong>string查找和替换</strong></p> 
<pre><code>int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找
int find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找
int find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置
int find(const char c, int pos = 0) const;  //查找字符c第一次出现位置
int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找
int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找
int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置
int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置
string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str
string&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s
</code></pre> 
<p><strong>string比较操作</strong></p> 
<pre><code>/*
compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。
比较区分大小写，比较时参考字典顺序，排越前面的越小。
大写的A比小写的a小。
*/
int compare(const string &amp;s) const;//与字符串s比较
int compare(const char *s) const;//与字符串s比较
</code></pre> 
<p><strong>string子串</strong></p> 
<pre><code>string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串</code></pre> 
<p><strong>string插入和删除操作</strong></p> 
<pre><code>string&amp; insert(int pos, const char* s); //插入字符串
string&amp; insert(int pos, const string&amp; str); //插入字符串
string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符c
string&amp; erase(int pos, int n = npos);//删除从Pos开始的n个字符 
</code></pre> 
<p><strong>string和c-style字符串转换</strong></p> 
<pre><code>//string 转 char*
string str = "it";
const char* cstr = str.c_str();
//char* 转 string 
char* s = "it";
string str(s);</code></pre> 
<blockquote> 
 <p>在c++中存在一个从const char*到string的隐式类型转换，却不存在从一个string对象到C_string的自动类型转换。对于string类型的字符串，可以通过c_str()函数返回string对象对应的C_string.</p> 
 <p>通常，程序员在整个程序中应坚持使用string类对象，直到必须将内容转化为char*时才将其转换为C_string.</p> 
</blockquote> 
<p>为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但当字符串的内存被重新分配之后，可能发生错误. </p> 
<pre><code>string s = "abcdefg";
char&amp; a = s[2];
char&amp; b = s[3];

a = '1';
b = '2';

cout &lt;&lt; s &lt;&lt; endl;
cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;

s = "pppppppppppppppppppppppp";

//a = '1';
//b = '2';

cout &lt;&lt; s &lt;&lt; endl;
cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;
</code></pre> 
<h3 id="2.%20vector%E5%AE%B9%E5%99%A8">2. vector容器</h3> 
<h4 id="vector%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">vector容器基本概念</h4> 
<p>vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间的运用的灵活性。</p> 
<p>Array是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间，可以，一切琐碎得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。</p> 
<p>Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就要求一个大块头的array了。</p> 
<p>Vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，一旦vector旧空间满了，如果客户每新增一个元素，vector内部只是扩充一个元素的空间，实为不智，因为所谓的扩充空间(不论多大)，一如刚所说，是”配置新空间-数据移动-释放旧空间”的大工程,时间成本很高，应该加入某种未雨绸缪的考虑，稍后我们便可以看到vector的空间配置策略。</p> 
<p><img alt="" height="313" src="https://images2.imgbox.com/51/b3/PCnmQffy_o.png" width="626"></p> 
<h4 id="vector%E8%BF%AD%E4%BB%A3%E5%99%A8">vector迭代器</h4> 
<p>Vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，因为vector迭代器所需要的操作行为，如operaroe*, operator-&gt;, operator++, operator–, operator+, operator-, operator+=, operator-=, 普通指针天生具备。</p> 
<p>Vector支持随机存取，而普通指针正有着这样的能力。所以vector提供的是随机访问迭代器(Random Access Iterators).</p> 
<p>根据上述描述，如果我们写如下的代码：</p> 
<pre><code>vector&lt;int&gt;::iterator it1;
vector&lt;Teacher&gt;::iterator it2;</code></pre> 
<p>it1的型别其实就是Int*,it2的型别其实就是Teacher*.</p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

int main(){

	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10;i ++){
		v.push_back(i);
		cout &lt;&lt; v.capacity() &lt;&lt; endl;  // v.capacity()容器的容量
	}


	system("pause");
	return EXIT_SUCCESS;
}
</code></pre> 
<h4 id="vector%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">vector的数据结构</h4> 
<p>Vector所采用的数据结构非常简单，线性连续空间，它以两个迭代器_Myfirst和_Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器_Myend指向整块连续内存空间的尾端。</p> 
<p>为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这边是容量的概念。换句话说，一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所。</p> 
<blockquote> 
 <p>所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。这是程序员容易犯的一个错误，务必小心。</p> 
</blockquote> 
<h4 id="vector%E5%B8%B8%E7%94%A8API%E6%93%8D%E4%BD%9C">vector常用API操作</h4> 
<p><strong>vector构造函数</strong> </p> 
<pre><code>vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数
vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。
vector(n, elem);//构造函数将n个elem拷贝给本身。
vector(const vector &amp;vec);//拷贝构造函数。</code></pre> 
<pre><code>//例子 使用第二个构造函数 我们可以...
int arr[] = {2,3,4,1,9};
vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int)); </code></pre> 
<p><strong>vector常用赋值操作</strong></p> 
<pre><code>assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
vector&amp; operator=(const vector  &amp;vec);//重载等号操作符
swap(vec);// 将vec与本身的元素互换。</code></pre> 
<p><strong>vector大小操作</strong></p> 
<pre><code>size();//返回容器中元素的个数
empty();//判断容器是否为空
resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。
capacity();//容器的容量
reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。</code></pre> 
<p><strong>vector数据存取操作</strong></p> 
<pre><code>at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。
operator[];//返回索引idx所指的数据，越界时，运行直接报错
front();//返回容器中第一个数据元素
back();//返回容器中最后一个数据元素</code></pre> 
<p><strong>vector插入和删除操作</strong></p> 
<pre><code>insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele.
push_back(ele); //尾部插入元素ele
pop_back();//删除最后一个元素
erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素
erase(const_iterator pos);//删除迭代器指向的元素
clear();//删除容器中所有元素</code></pre> 
<p>vector 小demo: 巧用swap，收缩内存空间</p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

int main(){

	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 100000;i ++){
		v.push_back(i);
	}

	cout &lt;&lt; "capacity:" &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; "size:" &lt;&lt; v.size() &lt;&lt; endl;

	//此时 通过resize改变容器大小
	v.resize(10);

	cout &lt;&lt; "capacity:" &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; "size:" &lt;&lt; v.size() &lt;&lt; endl;

	//容量没有改变
	vector&lt;int&gt;(v).swap(v);

	cout &lt;&lt; "capacity:" &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; "size:" &lt;&lt; v.size() &lt;&lt; endl;


	system("pause");
	return EXIT_SUCCESS;
}</code></pre> 
<p> 运行结果：<br><img alt="" height="134" src="https://images2.imgbox.com/c5/2a/Ni0A4u4g_o.png" width="371"> </p> 
<p><strong>reserve预留空间</strong> </p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

int main(){

	vector&lt;int&gt; v;

	//预先开辟空间
	v.reserve(100000);

	int* pStart = NULL;
	int count = 0;
	for (int i = 0; i &lt; 10000000;i ++){
		v.push_back(i);
		if (pStart != &amp;v[0]){
			pStart = &amp;v[0];
			count++;
		}
	}

	cout &lt;&lt; "count:" &lt;&lt; count &lt;&lt; endl;

	system("pause");
	return EXIT_SUCCESS;
}</code></pre> 
<p>运行结果：<br><img alt="" height="67" src="https://images2.imgbox.com/72/e4/IGceCYxR_o.png" width="442"></p> 
<h3 id="3.%20deque%E5%AE%B9%E5%99%A8">3. deque容器</h3> 
<h4 id="deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%C2%A0">deque容器基本概念 </h4> 
<p>vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。</p> 
<p>所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。</p> 
<p><img alt="" height="510" src="https://images2.imgbox.com/c4/a8/TfqMAa0H_o.png" width="905"></p> 
<p>Deque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能.</p> 
<p>虽然deque容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque.</p> 
<h4 id="deque%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">deque容器实现原理</h4> 
<p>deque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector,array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。</p> 
<p>deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p> 
<p>既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。</p> 
<p>deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。</p> 
<p> <img alt="" height="382" src="https://images2.imgbox.com/d1/0b/w61LgxZ1_o.png" width="589"></p> 
<h4 id="deque%E5%B8%B8%E7%94%A8API">deque常用API</h4> 
<p><strong>deque构造函数</strong> </p> 
<pre><code>deque&lt;T&gt; deqT;//默认构造形式
deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。
deque(n, elem);//构造函数将n个elem拷贝给本身。
deque(const deque &amp;deq);//拷贝构造函数。</code></pre> 
<p><strong>deque赋值操作</strong></p> 
<pre><code>assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
deque&amp; operator=(const deque &amp;deq); //重载等号操作符 
swap(deq);// 将deq与本身的元素互换</code></pre> 
<p><strong>deque大小操作</strong></p> 
<pre><code>deque.size();//返回容器中元素的个数
deque.empty();//判断容器是否为空
deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。
</code></pre> 
<p><strong>deque双端插入和删除操作</strong></p> 
<pre><code>push_back(elem);//在容器尾部添加一个数据
push_front(elem);//在容器头部插入一个数据
pop_back();//删除容器最后一个数据
pop_front();//删除容器第一个数据</code></pre> 
<p><strong>deque数据存取</strong></p> 
<pre><code>at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。
operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。
front();//返回第一个数据。
back();//返回最后一个数据
</code></pre> 
<p><strong>deque插入操作</strong></p> 
<pre><code>insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。
</code></pre> 
<p><strong>deque删除操作</strong></p> 
<pre><code>clear();//移除容器的所有数据
erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);//删除pos位置的数据，返回下一个数据的位置。
</code></pre> 
<h3 id="4.%20stack%E5%AE%B9%E5%99%A8">4. stack容器</h3> 
<h4 id="stack%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">stack容器基本概念</h4> 
<p>stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口，形式如图所示。stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。<br> 有元素推入栈的操作称为:push,将元素推出stack的操作称为pop.</p> 
<p> <img alt="" height="356" src="https://images2.imgbox.com/2b/68/gOqEWGLq_o.png" width="404"></p> 
<h4 id="stack%E6%B2%A1%E6%9C%89%E8%BF%AD%E4%BB%A3%E5%99%A8">stack没有迭代器</h4> 
<p> stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。stack不提供遍历功能，也不提供迭代器。</p> 
<h4 id="stack%E5%B8%B8%E7%94%A8API">stack常用API</h4> 
<p><strong>stack构造函数</strong> </p> 
<pre><code>stack&lt;T&gt; stkT;//stack采用模板类实现， stack对象的默认构造形式： 
stack(const stack &amp;stk);//拷贝构造函数</code></pre> 
<p> <strong>stack赋值操作</strong></p> 
<pre><code>stack&amp; operator=(const stack &amp;stk);//重载等号操作符</code></pre> 
<p> <strong>stack数据存取操作</strong></p> 
<pre><code>push(elem);//向栈顶添加元素
pop();//从栈顶移除第一个元素
top();//返回栈顶元素</code></pre> 
<p> <strong>stack大小操作</strong></p> 
<pre><code>empty();//判断堆栈是否为空
size();//返回堆栈的大小</code></pre> 
<h3 id="5.%20queue%E5%AE%B9%E5%99%A8">5. queue容器</h3> 
<h4 id="queue%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">queue容器基本概念</h4> 
<p>queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素。 </p> 
<p><img alt="" height="234" src="https://images2.imgbox.com/64/14/QalyfhbL_o.png" width="508"></p> 
<h4 id="queue%E6%B2%A1%E6%9C%89%E8%BF%AD%E4%BB%A3%E5%99%A8">queue没有迭代器</h4> 
<p>queue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。queue不提供遍历功能，也不提供迭代器。 </p> 
<h4 id="queue%E5%B8%B8%E7%94%A8API%C2%A0">queue常用API </h4> 
<p><strong>queue构造函数</strong></p> 
<pre><code>queue&lt;T&gt; queT;//queue采用模板类实现，queue对象的默认构造形式：
queue(const queue &amp;que);//拷贝构造函数</code></pre> 
<p><strong>queue存取、插入和删除操作</strong></p> 
<pre><code>push(elem);//往队尾添加元素
pop();//从队头移除第一个元素
back();//返回最后一个元素
front();//返回第一个元素
</code></pre> 
<p> <strong>queue赋值操作</strong></p> 
<pre><code>queue&amp; operator=(const queue &amp;que);//重载等号操作符</code></pre> 
<p> <strong>queue大小操作</strong></p> 
<pre><code>empty();//判断队列是否为空
size();//返回队列的大小
</code></pre> 
<h3 id="6.%20list%E5%AE%B9%E5%99%A8">6. list容器</h3> 
<h4 id="%C2%A0list%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><strong>list容器基本概念</strong></h4> 
<p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p> 
<p>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p> 
<p>相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。</p> 
<p>list和vector是两个最常被使用的容器。</p> 
<p>list容器是一个双向链表。</p> 
<p><img alt="" height="346" src="https://images2.imgbox.com/d7/2c/YTQ9dSz2_o.png" width="572"></p> 
<ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li><li>链表灵活，但是空间和时间额外耗费较大</li></ul> 
<h4 id="list%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%C2%A0">list容器的迭代器 </h4> 
<p>list容器不能像vector一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。</p> 
<p>list迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取操作。所谓”list正确的递增，递减、取值、成员取用”是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员。</p> 
<p>由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是Bidirectional Iterators.</p> 
<p>list有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。</p> 
<h4 id="list%E5%AE%B9%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">list容器的数据结构</h4> 
<p>list容器不仅是一个双向链表，而且还是一个循环的双向链表。 </p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;list&gt;
using namespace std;

int main(){

	list&lt;int&gt; myList;
	for (int i = 0; i &lt; 10; i ++){
		myList.push_back(i);
	}

	list&lt;int&gt;::_Nodeptr node =  myList._Myhead-&gt;_Next;

	for (int i = 0; i &lt; myList._Mysize * 2;i++){
		cout &lt;&lt; "Node:" &lt;&lt; node-&gt;_Myval &lt;&lt; endl;
		node = node-&gt;_Next;
		if (node == myList._Myhead){
			node = node-&gt;_Next;
		}
	}

	system("pause");
	return EXIT_SUCCESS;
}</code></pre> 
<h4 id="list%E5%B8%B8%E7%94%A8API">list常用API</h4> 
<p><strong>list构造函数</strong> </p> 
<pre><code>list&lt;T&gt; lstT;//list采用采用模板类实现,对象的默认构造形式：
list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身。
list(n,elem);//构造函数将n个elem拷贝给本身。
list(const list &amp;lst);//拷贝构造函数。</code></pre> 
<p><strong>list数据元素插入和删除操作</strong></p> 
<pre><code>push_back(elem);//在容器尾部加入一个元素
pop_back();//删除容器中最后一个元素
push_front(elem);//在容器开头插入一个元素
pop_front();//从容器开头移除第一个元素
insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。
clear();//移除容器的所有数据
erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);//删除pos位置的数据，返回下一个数据的位置。
remove(elem);//删除容器中所有与elem值匹配的元素。
</code></pre> 
<p><strong>list大小操作</strong></p> 
<pre><code>size();//返回容器中元素的个数
empty();//判断容器是否为空
resize(num);//重新指定容器的长度为num，
若容器变长，则以默认值填充新位置。
如果容器变短，则末尾超出容器长度的元素被删除。
resize(num, elem);//重新指定容器的长度为num，
若容器变长，则以elem值填充新位置。
如果容器变短，则末尾超出容器长度的元素被删除。</code></pre> 
<p><strong>list赋值操作</strong></p> 
<pre><code>assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
list&amp; operator=(const list &amp;lst);//重载等号操作符
swap(lst);//将lst与本身的元素互换。</code></pre> 
<p><strong>list数据的存取</strong></p> 
<pre><code>front();//返回第一个元素。
back();//返回最后一个元素。
</code></pre> 
<p><strong>list反转排序</strong></p> 
<pre><code>reverse();//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。
sort(); //list排序
</code></pre> 
<h3 id="7.%20set%2Fmultiset%E5%AE%B9%E5%99%A8">7. set/multiset容器</h3> 
<h4 id="set%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">set容器基本概念</h4> 
<p>set的特性是。所有元素都会根据元素的键值自动被排序。set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值。set不允许两个元素有相同的键值。</p> 
<p>我们不可以通过set的迭代器改变set元素的值，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种const_iterator.</p> 
<p>set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。</p> 
<h4 id="multiset%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><strong>multiset容器基本概念</strong></h4> 
<p>multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。set和multiset的底层实现是红黑树.</p> 
<h4 id="set%E5%B8%B8%E7%94%A8API%C2%A0">set常用API </h4> 
<p><strong>set构造函数</strong> </p> 
<pre><code>set&lt;T&gt; st;//set默认构造函数：
mulitset&lt;T&gt; mst; //multiset默认构造函数: 
set(const set &amp;st);//拷贝构造函数</code></pre> 
<p><strong>set赋值操作</strong></p> 
<pre><code>set&amp; operator=(const set &amp;st);//重载等号操作符
swap(st);//交换两个集合容器</code></pre> 
<p><strong>set大小操作</strong></p> 
<pre><code>size();//返回容器中元素的数目
empty();//判断容器是否为空</code></pre> 
<p> <strong>set插入和删除操作</strong></p> 
<pre><code>insert(elem);//在容器中插入元素。
clear();//清除所有元素
erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(elem);//删除容器中值为elem的元素。
</code></pre> 
<p> <strong>set查找操作</strong></p> 
<pre><code>find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();
count(key);//查找键key的元素个数
lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。
upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。
equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。</code></pre> 
<p> <strong>set的返回值 指定set排序规则举例:</strong></p> 
<pre><code>//插入操作返回值
void test01(){

	set&lt;int&gt; s;
	pair&lt;set&lt;int&gt;::iterator,bool&gt; ret = s.insert(10);
	if (ret.second){
		cout &lt;&lt; "插入成功:" &lt;&lt; *ret.first &lt;&lt; endl;
	}
	else{
		cout &lt;&lt; "插入失败:" &lt;&lt; *ret.first &lt;&lt; endl;
	}
	
	ret = s.insert(10);
	if(ret.second){
		cout &lt;&lt; "插入成功:" &lt;&lt; *ret.first &lt;&lt; endl;
	}
	else{
		cout &lt;&lt; "插入失败:" &lt;&lt; *ret.first &lt;&lt; endl;
	}

}

struct MyCompare02{
	bool operator()(int v1,int v2){
		return v1 &gt; v2;
	}
};

//set从大到小
void test02(){

	srand((unsigned int)time(NULL));
	//我们发现set容器的第二个模板参数可以设置排序规则，默认规则是less&lt;_Kty&gt;
	set&lt;int, MyCompare02&gt; s;
	for (int i = 0; i &lt; 10;i++){
		s.insert(rand() % 100);
	}
	
	for (set&lt;int, MyCompare02&gt;::iterator it = s.begin(); it != s.end(); it ++){
		cout &lt;&lt; *it &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}

//set容器中存放对象
class Person{
public:
	Person(string name,int age){
		this-&gt;mName = name;
		this-&gt;mAge = age;
	}
public:
	string mName;
	int mAge;
};


struct MyCompare03{
	bool operator()(const Person&amp; p1,const Person&amp; p2){
		return p1.mAge &gt; p2.mAge;
	}
};

void test03(){

	set&lt;Person, MyCompare03&gt; s;

	Person p1("aaa", 20);
	Person p2("bbb", 30);
	Person p3("ccc", 40);
	Person p4("ddd", 50);

	s.insert(p1);
	s.insert(p2);
	s.insert(p3);
	s.insert(p4);

	for (set&lt;Person, MyCompare03&gt;::iterator it = s.begin(); it != s.end(); it++){
		cout &lt;&lt; "Name:" &lt;&lt; it-&gt;mName &lt;&lt; " Age:" &lt;&lt; it-&gt;mAge &lt;&lt; endl;
	}

}
</code></pre> 
<h4 id="%E5%AF%B9%E7%BB%84(pair)">对组(pair)</h4> 
<p>对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。<br> 类模板：<code>template &lt;class T1, class T2&gt; struct pair.</code> </p> 
<p>创建对组: </p> 
<pre><code>//第一种方法创建一个对组
pair&lt;string, int&gt; pair1(string("name"), 20);
cout &lt;&lt; pair1.first &lt;&lt; endl; //访问pair第一个值
cout &lt;&lt; pair1.second &lt;&lt; endl;//访问pair第二个值
//第二种
pair&lt;string, int&gt; pair2 = make_pair("name", 30);
cout &lt;&lt; pair2.first &lt;&lt; endl;
cout &lt;&lt; pair2.second &lt;&lt; endl;
//pair=赋值
pair&lt;string, int&gt; pair3 = pair2;
cout &lt;&lt; pair3.first &lt;&lt; endl;
cout &lt;&lt; pair3.second &lt;&lt; endl;
</code></pre> 
<h3 id="8.%20map%2Fmultimap%E5%AE%B9%E5%99%A8">8. map/multimap容器</h3> 
<h4 id="map%2Fmultimap%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%C2%A0">map/multimap基本概念 </h4> 
<p>map的特性是，所有元素都会根据元素的键值自动排序。</p> 
<p>map所有的元素都是pair,同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。</p> 
<p>我们不可以通过map的迭代器改变map的键值, 因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，那么是可以的。</p> 
<p>map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。</p> 
<p>multimap和map的操作类似，唯一区别multimap键值可重复。</p> 
<p>map和multimap都是以红黑树为底层实现机制。</p> 
<h4 id="map%2Fmultimap%E5%B8%B8%E7%94%A8API">map/multimap常用API</h4> 
<p><strong>map构造函数</strong> </p> 
<pre><code>map&lt;T1, T2&gt; mapTT;//map默认构造函数: 
map(const map &amp;mp);//拷贝构造函数
</code></pre> 
<p><strong>map赋值操作</strong></p> 
<pre><code>map&amp; operator=(const map &amp;mp);//重载等号操作符
swap(mp);//交换两个集合容器
</code></pre> 
<p><strong>map大小操作</strong></p> 
<pre><code>size();//返回容器中元素的数目
empty();//判断容器是否为空
</code></pre> 
<p><strong>map插入数据元素操作</strong></p> 
<pre><code>map.insert(...); //往容器插入元素，返回pair&lt;iterator,bool&gt;
map&lt;int, string&gt; mapStu;
// 第一种 通过pair的方式插入对象
mapStu.insert(pair&lt;int, string&gt;(3, "小张"));
// 第二种 通过pair的方式插入对象
mapStu.insert(make_pair(-1, "校长"));
// 第三种 通过value_type的方式插入对象
mapStu.insert(map&lt;int, string&gt;::value_type(1, "小李"));
// 第四种 通过数组的方式插入值
mapStu[3] = "小刘";
mapStu[5] = "小王";
</code></pre> 
<p><strong>map删除操作</strong></p> 
<pre><code>clear();//删除所有元素
erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg,end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(keyElem);//删除容器中key为keyElem的对组。
</code></pre> 
<p><strong>map查找操作</strong> </p> 
<pre><code>find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();
count(keyElem);//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。
lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。
upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。
equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。
</code></pre> 
<p> <strong>multimap案例</strong></p> 
<pre><code>//公司今天招聘了5个员工，5名员工进入公司之后，需要指派员工在那个部门工作
//人员信息有: 姓名 年龄 电话 工资等组成
//通过Multimap进行信息的插入 保存 显示
//分部门显示员工信息 显示全部员工信息

#define _CRT_SECURE_NO_WARNINGS

#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;

//multimap 案例
//公司今天招聘了 5 个员工，5 名员工进入公司之后，需要指派员工在那个部门工作
//人员信息有: 姓名 年龄 电话 工资等组成
//通过 Multimap 进行信息的插入 保存 显示
//分部门显示员工信息 显示全部员工信息


#define SALE_DEPATMENT 1 //销售部门
#define DEVELOP_DEPATMENT 2 //研发部门
#define FINACIAL_DEPATMENT 3 //财务部门
#define ALL_DEPATMENT 4 //所有部门

//员工类
class person{
public:
	string name; //员工姓名
	int age; //员工年龄
	double salary; //员工工资
	string tele; //员工电话
};

//创建5个员工
void CreatePerson(vector&lt;person&gt;&amp; vlist){

	string seed = "ABCDE";
	for (int i = 0; i &lt; 5; i++){
		person p;
		p.name = "员工";
		p.name += seed[i];
		p.age = rand() % 30 + 20;
		p.salary = rand() % 20000 + 10000;
		p.tele = "010-8888888";
		vlist.push_back(p);
	}

}

//5名员工分配到不同的部门
void PersonByGroup(vector&lt;person&gt;&amp; vlist, multimap&lt;int, person&gt;&amp; plist){


	int operate = -1; //用户的操作

	for (vector&lt;person&gt;::iterator it = vlist.begin(); it != vlist.end(); it++){

		cout &lt;&lt; "当前员工信息:" &lt;&lt; endl;
		cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;name &lt;&lt; " 年龄:" &lt;&lt; it-&gt;age &lt;&lt; " 工资:" &lt;&lt; it-&gt;salary &lt;&lt; " 电话：" &lt;&lt; it-&gt;tele &lt;&lt; endl;
		cout &lt;&lt; "请对该员工进行部门分配(1 销售部门, 2 研发部门, 3 财务部门):" &lt;&lt; endl;
		scanf("%d", &amp;operate);

		while (true){

			if (operate == SALE_DEPATMENT){  //将该员工加入到销售部门
				plist.insert(make_pair(SALE_DEPATMENT, *it));
				break;
			}
			else if (operate == DEVELOP_DEPATMENT){
				plist.insert(make_pair(DEVELOP_DEPATMENT, *it));
				break;
			}
			else if (operate == FINACIAL_DEPATMENT){
				plist.insert(make_pair(FINACIAL_DEPATMENT, *it));
				break;
			}
			else{
				cout &lt;&lt; "您的输入有误，请重新输入(1 销售部门, 2 研发部门, 3 财务部门):" &lt;&lt; endl;
				scanf("%d", &amp;operate);
			}

		}

	}
	cout &lt;&lt; "员工部门分配完毕!" &lt;&lt; endl;
	cout &lt;&lt; "***********************************************************" &lt;&lt; endl;

}

//打印员工信息
void printList(multimap&lt;int, person&gt;&amp; plist, int myoperate){

	if (myoperate == ALL_DEPATMENT){
		for (multimap&lt;int, person&gt;::iterator it = plist.begin(); it != plist.end(); it++){
			cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;second.name &lt;&lt; " 年龄:" &lt;&lt; it-&gt;second.age &lt;&lt; " 工资:" &lt;&lt; it-&gt;second.salary &lt;&lt; " 电话：" &lt;&lt; it-&gt;second.tele &lt;&lt; endl;
		}
		return;
	}

	multimap&lt;int, person&gt;::iterator it = plist.find(myoperate);
	int depatCount = plist.count(myoperate);
	int num = 0;
	if (it != plist.end()){
		while (it != plist.end() &amp;&amp; num &lt; depatCount){
			cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;second.name &lt;&lt; " 年龄:" &lt;&lt; it-&gt;second.age &lt;&lt; " 工资:" &lt;&lt; it-&gt;second.salary &lt;&lt; " 电话：" &lt;&lt; it-&gt;second.tele &lt;&lt; endl;
			it++;
			num++;
		}
	}
}

//根据用户操作显示不同部门的人员列表
void ShowPersonList(multimap&lt;int, person&gt;&amp; plist, int myoperate){

	switch (myoperate)
	{
	case SALE_DEPATMENT:
		printList(plist, SALE_DEPATMENT);
		break;
	case DEVELOP_DEPATMENT:
		printList(plist, DEVELOP_DEPATMENT);
		break;
	case FINACIAL_DEPATMENT:
		printList(plist, FINACIAL_DEPATMENT);
		break;
	case ALL_DEPATMENT:
		printList(plist, ALL_DEPATMENT);
		break;
	}
}

//用户操作菜单
void PersonMenue(multimap&lt;int, person&gt;&amp; plist){

	int flag = -1;
	int isexit = 0;
	while (true){
		cout &lt;&lt; "请输入您的操作((1 销售部门, 2 研发部门, 3 财务部门, 4 所有部门, 0退出)：" &lt;&lt; endl;
		scanf("%d", &amp;flag);

		switch (flag)
		{
		case SALE_DEPATMENT:
			ShowPersonList(plist, SALE_DEPATMENT);
			break;
		case DEVELOP_DEPATMENT:
			ShowPersonList(plist, DEVELOP_DEPATMENT);
			break;
		case FINACIAL_DEPATMENT:
			ShowPersonList(plist, FINACIAL_DEPATMENT);
			break;
		case ALL_DEPATMENT:
			ShowPersonList(plist, ALL_DEPATMENT);
			break;
		case 0:
			isexit = 1;
			break;
		default:
			cout &lt;&lt; "您的输入有误，请重新输入!" &lt;&lt; endl;
			break;
		}

		if (isexit == 1){
			break;
		}
	}

}

int main(){

	vector&lt;person&gt;  vlist; //创建的5个员工 未分组
	multimap&lt;int, person&gt; plist; //保存分组后员工信息

	//创建5个员工
	CreatePerson(vlist);
	//5名员工分配到不同的部门
	PersonByGroup(vlist, plist);
	//根据用户输入显示不同部门员工信息列表 或者 显示全部员工的信息列表
	PersonMenue(plist);

	system("pause");
	return EXIT_SUCCESS;
}
</code></pre> 
<p> 运行结果：<br><img alt="" height="602" src="https://images2.imgbox.com/f2/57/ovKuN0sx_o.png" width="594"></p> 
<h2 id="STL%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA">STL容器使用时机</h2> 
<p> <img alt="" height="145" src="https://images2.imgbox.com/c6/35/8oNoWWBS_o.png" width="663"></p> 
<p><strong>vector的使用场景：</strong>比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</p> 
<p><strong>deque的使用场景：</strong>比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</p> 
<p><strong>vector与deque的比较：</strong></p> 
<ol><li>vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。</li><li>如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</li><li>deque支持头部的快速插入与快速移除，这是deque的优点。</li></ol> 
<p><strong>list的使用场景：</strong>比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</p> 
<p><strong>set的使用场景：</strong>比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。</p> 
<p><strong>map的使用场景：</strong>比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8fd57b202dc466bf22af5865d9bce952/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[Java 一道简单的排序题]</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/741de92544e7118100f0353daab79b62/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QtAV 播放rtsp视频流</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>