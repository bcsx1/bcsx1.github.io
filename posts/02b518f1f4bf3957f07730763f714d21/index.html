<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>es6的重点 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="es6的重点" />
<meta property="og:description" content="promise对象
因为回调地狱
一种是各种回调函数互相依赖，关系错综复杂，容易在造成错误
另一种是各种回调里嵌套各种回调，关系错综复杂，麻烦的很
为了解决这种问题promise就来了
三种状态：pending 初始状态 fullfilled 成功状态 rejected 失败状态 再恰当时机就会改变成成功或失败
*****promise是同步的，遇到了直接等待执行就可以，不需要像异步一样跳过然后再回来的时候回调。
let pormise = new Promise((res,rej)=&gt;{
//初始化promise状态：pending
console.log(‘111’)
***
//一般这个时候都要执行异步操作，通常是发送ajax请求，开启定时器（因为这个地方下写的异步就res，rej两种结果所以使回调变得简单）
setTimeout(()=&gt;{
console.log(‘333’)
//根据异步任务的返回结果来修改promise的状态
//异步任务执行成功
res(‘this is success’); //修改promise状态为fullfilled
//异步执行失败
rej(‘this is defeat’) //修改promise状态为rejected失败 注意两者只能执行一个
},2000)
})
console.log(‘222’)
promise.then((data)=&gt;{console.log(data,‘succes’)},(err)=&gt;{console.log(err,‘defeat’)}) //promise的回调会产生两个函数前者是成功的回调如果状态为fullfilled则执行第一个箭头函数
状态为rejected则执行第二个回调函数
.then可以链式操作，前提是前面的then返回一个promise对象供其接收
*****前面res和rej里面可以传递参数给后面promise的回调接收。
–111-222-333
***ajax里的success和error也是这个思想
promise练习
function getNews(url){
let promise = new Promise((res,rej)=&gt;{
//发送ajax请求（这个地方用原生的）
let xmlHttp = new XmlHttpRequest()
xmlHttp.onreadystatechange = function(){ //原生的话这个方法是监听ajax的状态改变一共有0-4 5种状态
if(xmlHttp.responseText=4){
if(xmlHttp.status200){
res(xmlHttp.responseText) //获取到的数据" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/02b518f1f4bf3957f07730763f714d21/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-01T19:06:22+08:00" />
<meta property="article:modified_time" content="2020-11-01T19:06:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">es6的重点</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <hr> 
<p>promise对象</p> 
<p>因为回调地狱<br> 一种是各种回调函数互相依赖，关系错综复杂，容易在造成错误<br> 另一种是各种回调里嵌套各种回调，关系错综复杂，麻烦的很</p> 
<p>为了解决这种问题promise就来了<br> 三种状态：pending 初始状态 fullfilled 成功状态 rejected 失败状态 再恰当时机就会改变成成功或失败</p> 
<p>*****promise是同步的，遇到了直接等待执行就可以，不需要像异步一样跳过然后再回来的时候回调。</p> 
<p>let pormise = new Promise((res,rej)=&gt;{<!-- --><br> //初始化promise状态：pending<br> console.log(‘111’)<br> ***<br> //一般这个时候都要执行异步操作，通常是发送ajax请求，开启定时器（因为这个地方下写的异步就res，rej两种结果所以使回调变得简单）<br> setTimeout(()=&gt;{<!-- --><br> console.log(‘333’)<br> //根据异步任务的返回结果来修改promise的状态<br> //异步任务执行成功<br> res(‘this is success’); //修改promise状态为fullfilled<br> //异步执行失败<br> rej(‘this is defeat’) //修改promise状态为rejected失败 注意两者只能执行一个<br> },2000)<br> })<br> console.log(‘222’)</p> 
<p>promise.then((data)=&gt;{console.log(data,‘succes’)},(err)=&gt;{console.log(err,‘defeat’)}) //promise的回调会产生两个函数前者是成功的回调如果状态为fullfilled则执行第一个箭头函数<br> 状态为rejected则执行第二个回调函数</p> 
<p>.then可以链式操作，前提是前面的then返回一个promise对象供其接收<br> *****前面res和rej里面可以传递参数给后面promise的回调接收。</p> 
<p>–111-222-333<br> ***ajax里的success和error也是这个思想</p> 
<p>promise练习</p> 
<p>function getNews(url){<!-- --><br> let promise = new Promise((res,rej)=&gt;{<!-- --><br> //发送ajax请求（这个地方用原生的）<br> let xmlHttp = new XmlHttpRequest()<br> xmlHttp.onreadystatechange = function(){ //原生的话这个方法是监听ajax的状态改变一共有0-4 5种状态<br> if(xmlHttp.responseText=<mark>4){<!-- --><br> if(xmlHttp.status</mark>200){<!-- --><br> res(xmlHttp.responseText) //获取到的数据<br> }else{<!-- --><br> rej(’ wrong’)<br> }<br> }<br> }</p> 
<pre><code>xmlHttp.open('Get',url) //这个地方是原生ajax的第一步通过get方法，接收url传过来的数据
xmlHttp.send() //发送请求
</code></pre> 
<p>})<br> return promise<br> }</p> 
<p>getNews(‘http://localhost:3000/news?id=2’).then((data)=&gt;{console.log（data<br> let url = JSON.parse(data).commentsUrl<br> let comment = ‘http://localhost:3000/’+url<br> getNews(comment)<br> ）},(err)=&gt;{}).then(<br> (data)=&gt;{console.log(data)},()=&gt;{} //上面getNews又重新带新的url运行了一遍走的是res这边重新接收data<br> )</p> 
<h3><a id="node%0Aroutergetnewsfunctionreqresnext%0A%09ressetAccessControlAllowOrigin_%0A%09let_id__reqqueryid%0A%09let_news__%0A%09%09idid%0A%09%09title123%0A%09%09commentsUrlcommentsnewsIdid%0A%0A%09resjsonnews%0A%0Aroutergetcommentsfunctionreqresnext%0A%09ressetAccessControlAllowOrigin_%0A%09let_newId__reqquerynewId%0A%09let_comments__id1newIdid2newId%0A%09resjsoncomments%0A_69"></a>node后端<br> router.get(’/news’,function(req,res,next){<!-- --><br> res.set(‘Access-Control-Allow-Origin’,’<em>’); //解决跨域问题的<br> let id = req.query.id;<br> let news = {<!-- --><br> id:id,<br> title:‘123’,<br> commentsUrl：’/comments?newsId=’+id<br> };<br> res.json(news);<br> })<br> router.get(’/comments’,function(req,res,next){<!-- --><br> res.set(‘Access-Control-Allow-Origin’,’</em>’); //解决跨域问题的<br> let newId = req.query.newId<br> let comments = [{id:1,newId},{id:2,newId}]<br> res.json(comments)<br> })</h3> 
<p>symbol<br> es6新添加的一种数据类型（已有的：String，Number，boolean，null，undefined，对象）<br> symbol的属性值对应的值是唯一的–解决命名冲突问题<br> symbol值不能与其他数据进行计算，字符串拼串也不行<br> for in ,of 遍历时不会遍历symbol属性</p> 
<h3><a id="let_symbol__Symbol_new%0A1let_obj___objsymbolhello_symbol%0A2let_symbol__Symbolone_%0A3es611symbol_93"></a>let symbol = Symbol() //不用new<br> 1、let obj = {} obj[symbol]=‘hello’ /作为对象里的symbol值<br> 2、let symbol = Symbol(‘one’) //传参标识<br> 3、es6提供了11个内置的symbol值</h3> 
<p>interator（迭代器）遍历器是一种接口机制，为不同的数据接口结构提供统一的访问机制</p> 
<p>就是有个next，一个next之后指针指向下一个，然后再next，每一个指针指向都有一个值<br> 直到最后next的指向没有值的时候值是undefined，结束</p> 
<p>//模拟指针对象<br> function myInterator(){<!-- --><br> let index = 0<br> return {<!-- --><br> next:function(){ //为什么这边要用两个return啊，还有再一个函数呢（<em><strong>这里就用到了闭包可以让index变量延迟存在</strong></em>）<br> return index&lt;arr.length? {value:arr[index++],done:false}:{value:undefined,done:true}<br> }<br> }<br> let arr = [2,4,6,‘aqw’]<br> let interator = myInterator(arr)<br> console.log(interator.next()) 2 false<br> console.log(interator.next()) 4 false<br> console.log(interator.next()) 6 false<br> console.log(interator.next()) undefined true<br> console.log(interator.next()) undefined true</p> 
<p>}<br> 。。。底层原理在这</p> 
<p>//这一套原理es6已经将iterator接口部署到指定的数据类型上，可以使用for of去循环遍历<br> **<em>数组，字符串，arguments，set容器，map容器（对象不可以哦 就是对象是不能用for of 的）<br> （其实对象也可以但是很麻烦要用到Symbol.interator。obj[Symbol.iterator]=function</em> mytest(){} 把对象转换成指针对象那种的 ）<br> let str = ‘ascece’<br> for(let i of str){<!-- --><br> console.log(i)<br> }<br> –&gt;a s c e c e</p> 
<p>function fun(){<!-- --><br> for(let i of arguments){<!-- --><br> console.log(i)<br> }<br> }<br> fun(1,4,5,‘qwe’)</p> 
<p>*****arguments是用来收集函数实参的，上面这个函数()里没有参数但是arguments帮忙接收了<br> *****arguments其实是一个伪数组，是不能调用数组的方法的比如foreach。</p> 
<h3><a id="forinES5keykey%0AforofES6valuevalue%0Aforinkey%0AforofvalueMapSet_141"></a>for-in是ES5标准，遍历的是key（可遍历对象、数组或字符串的key）；<br> for-of是ES6标准，遍历的是value（可遍历对象、数组或字符串的value）。<br> ***for-in总是得到对象的key或数组、字符串的下标。<br> ***for-of总是得到对象的value或数组、字符串的值，另外还可以用于遍历Map和Set</h3> 
<p>Generator函数（es6提供解决异步编程的方案之一 promise还是脱离不了回调）<br> 是一个状态机封装了不同的状态数据，用来生成遍历器对象，可暂停函数</p> 
<p>function与函数名之间有一个星号**，内部用yield语句描述当前状态</p> 
<p>function* myGenerator(){<!-- --><br> yield ‘hello’;<br> yield ‘olleh’<br> }<br> let my = myGenerator() 返回的是指针对象<br> my.next() //不下一个next的话不会到olleh的</p> 
<h3><a id="news%0AjQuery%0Afunction_getNewsurl%0A%09geturlfunctiondata%0A%09let_url__httplocalhost3000datacommentsUrl%0A%09SXnext__nexturlGenerator%0A%09%09nodenextnext%0A%09%09generator%0A%0A%0Afunction_sendxml%0A%09let_url__yield_getNewshttplocalhost3000newsid3%0A%09yield_getNewsurl%0A%0Alet_SX__sendXml%0ASXnext_158"></a>接上面那个后端news的<br> 这次用jQuery写前端<br> function getNews(url){<!-- --><br> $.get(url,function(data){<!-- --><br> let url = ‘http://localhost:3000’+data.commentsUrl;<br> SX.next() //通过这个next把这个地方的url传给下一个Generator函数<br> ***<em>这就是为什么node时候必须写next的原因了，就是指针对象啊不next是出不来下一个变量的<br> 在这里面就是generator函数是返回指针对象的<br> })<br> }<br> function</em> sendxml(){<!-- --><br> let url = yield getNews(‘http://localhost:3000/news?id=3’)<br> yield getNews(url)<br> }<br> let SX = sendXml()<br> SX.next()</h3> 
<p>async函数（真正意义上解决异步回调问题，同步流程表达异步）<br> 本质是Generator语法糖<br> 把里面的yield换成 await（异步操作）<br> 之前的话有异步是直接跳过等到执行完同步再回来执行异步的回调<br> <strong>但是await的话直接就要等待完这个异步执行完结束后才继续执行同步（强行先执行异步的回调）</strong><br> **而且返回的是promise对象可以.then执行下一步，不需要next()，promise虽然也是同步的，但是里面有异步还是异步</p> 
<p>一般都是async和promise一起用<br> async function getNews(){<!-- --><br> return new Promise((res,rej)=&gt;{<!-- --><br> $.ajax({<!-- --><br> method:‘Get’,<br> url,<br> success:data =&gt;{res(data)},<br> error:err =&gt;{rej()}<br> })<br> })<br> }<br> async function sendXml(){<!-- --><br> let result = await getNews(‘http…’)<br> console.log(result)<br> result = await getNews(‘http…’+result.commenturl)<br> }</p> 
<h3><a id="sendXml_199"></a>sendXml()</h3> 
<p>class类使用详解</p> 
<p>之前是通过原型加构造函数实现继承</p> 
<p>//定义一个类<br> class Person {<!-- --><br> constructor(name,age){} //类的构造方法 （与原型里的一样）<br> showName(){} //类的一般方法<br> //将方法定义在原型里</p> 
<p>}<br> let person = new Person(‘a’,12)<br> person.showName()</p> 
<h3><a id="%0Aclass_Sperson_extends_Person_%0A%09constructorsuper_%0A%0A_proto_constructor_215"></a>//子类<br> class Sperson extends Person {<!-- --><br> constructor(){super() //调用父类的构造方法}<br> }<br> 这个一看就会要很多个原型以及_proto_里的constructor构造函数</h3> 
<p>其他实用的方法</p> 
<p>字符串的<br> 1、includes(str) :判断是否包含指定的字符串</p> 
<p>let str = 'sadec2 ’<br> console.log(str.includes(‘t’)) false</p> 
<p>2、starsWith（str）：判读是否以指定的字符串开头</p> 
<p>let str = 'sadec2 ’<br> console.log(str.includes(‘t’)) false</p> 
<p>3、endsWith(str): 判断是否以制定字符串结尾</p> 
<p>let str = 'sadec2 ’<br> console.log(str.includes(‘t’)) false</p> 
<p>4、repeat(count): 判断指定次数</p> 
<p>let str = ‘12’<br> console.log(str.repeat(3)) 121212</p> 
<p>小数的<br> 用0b可以把二进制转换为十进制<br> console.log(0b1010) //10<br> 用0o可以把八进制转换为十进制<br> console.log(0o56) //46<br> 判断这个数是不是有限大的数<br> Number.isFinite(12) //false<br> 判断这个数是不是 不是数字<br> Number.isNaN(12) //false</p> 
<h3><a id="NumberparseInt123abc123_123%0ANumberparseInta123abc123_NaN%0A%0AMathtrunc12389_123_254"></a>Number.parseInt(‘123abc123’) //123<br> Number.parseInt(‘a123abc123’) //NaN<br> 删除小数点后的数字<br> Math.trunc(123.89) //123</h3> 
<p>数组方法的扩展</p> 
<p>Array.form(v) //将伪数组或可遍历的对象转换为数组（可以用数组的方法）</p> 
<p>let btn = document.getElementByTagName(‘button’)<br> Array.form(btn).ForEach()</p> 
<p>2、Array.of(v1,v2,v3) :将一系列值转换为数组****</p> 
<p>let arr = Array.of(1,5,‘abc’,true) //[1,5,‘abc’,true]</p> 
<p>3、find(function(value,index,arr){return true}) 找出第一个满足条件并返回true元素</p> 
<p>4、findIndex(function(value,index,arr){return true}) 找出第一个满足条件并返回true元素的下标</p> 
<hr> 
<p>对象方法扩展<br> Object.is(v1,v2)<br> 判断两个值是否完全相等<br> console.log(0==-0) //true<br> console.log(NaN==NaN) //false NAN不代表任何一个数字<br> Object.is(0,-0) //false 这里的都相反是因为这个方法是把值都当做字符串形式的<br> Object.is(NaN,NaN) //true</p> 
<p>Object.assign(target,source1,source2)<br> 将原对象的属性复制到目标对象</p> 
<p>let obj = {}<br> obj.<em>ptoto</em> = obj2<br> 直接操作__proto__属性</p> 
<hr> 
<p>set、map容器</p> 
<p>Set容器：无序的不可重复的多个value的集合体（方法有add、delete、has、clear）<br> ***去重的话可以用这个，直接把重复的干掉<br> let arr = [1,2,2,4]<br> let arr1 = []<br> let set = new Set(arr)<br> for(let i in set){<!-- --><br> arr1.push(i)<br> }<br> console.log(arr1)</p> 
<p>let set = new Set([1,2,4,6,2,8]) -&gt;[1,2,4,6,8] 不重复 ******<br> set.add(7) -&gt;[1,2,4,6,8,7]<br> set.size -&gt;长度<br> set.has(8) -&gt;true是否有<br> set.clear() -&gt;清空到空状态</p> 
<p>Map容器：无序的key不重复的key-value的集合体（方法有get、set、delete、has、clear）<br> let map = new Map([[21,‘qwe’],[‘fr’,‘qwe’]]) //{21=&gt;qwe,fr=&gt;qwe}</p> 
<p>for of 都可以循环这两个容器</p> 
<hr> 
<p>深拷贝与浅拷贝</p> 
<p>let a = ‘abcd’<br> let a2 = a<br> a2 = ‘’<br> console.log(a) //abcd<br> 基本数据类型拷贝后会生成一份新的数据，修改不会影响原数据</p> 
<p>let obj = {username:‘kobe’,age:’’}<br> let obj2 =obj<br> obj2.username = ‘wade’<br> console.log(obj.usename) //wade<br> obj2堆里指向的原来的obj</p> 
<p><em><strong><strong><strong>所以我们在拷贝数组/对象时，没有生成新的数据而是复制了一份引用,修改拷贝后的数据会影响原来的数据</strong></strong></strong></em></p> 
<p>****数据拷贝的方法：<br> 1、直接赋值给一个变量 (浅拷贝)<br> 2、Object.assign() 将所有枚举属性的值从一个或多个源对象分配到目标对象，并返回目标对象（浅拷贝）<br> const target = { a: 1, b: 2 };</p> 
<p>const source = { b: 4, c: 5 };</p> 
<p>const returnedTarget = Object.assign(target, source);</p> 
<p>console.log(target);<br> // expected output: Object { a: 1, b: 4, c: 5 }</p> 
<p>console.log(returnedTarget);<br> // expected output: Object { a: 1, b: 4, c: 5 }</p> 
<p>3、Array.prototype.concat() （浅拷贝） 就直接。concat()后面不跟参数就是一个拷贝</p> 
<p>4、Array.prototype.slice() 浅拷贝<br> 5、JSON.parse(JSON.stringify()) 深拷贝（深度克隆）**拷贝数据里不能有函数它处理不了<br> stringify里只能放obj/array<br> 判断的是否深浅的依据就是转换数据的时候是转成什么样的形式</p> 
<p><em><strong><strong>所以说深浅拷贝只是针对于数组和对象对于其他数据来说是没有深浅拷贝这一说的</strong></strong></em><br> **浅拷贝就是最常见的普通复制数组对象<br> 就是简单地拷贝引用，修改了拷贝以后的数据会影响原数据（只要修改会影响原数据就是浅拷贝）</p> 
<p>而<strong>深拷贝就类似于其他的基本数据了，拷贝的时候生成新数据，修改拷贝以后的数据不会影响原数据</strong>*</p> 
<p>知识点（回顾）<br> 如何判断数据类型 arr–Array 注typeof判断不了array<br> 用Object.prototype.toString.call(传进来的参数).slice(8,-1) 用这个可判断</p> 
<p>****枚举对象枚举出来的是key值，枚举数组出来的是下标<br> let obj = {name:“l”,age:“21”}<br> for(let i in obj){<!-- --><br> console.log(i)<br> }<br> // name age<br> let arr = [3,4,5]<br> for(let i in arr){<!-- --><br> console.log(i)<br> }<br> // 1,2,3</p> 
<p>判断实现一个深度克隆<br> function clone(target){<!-- --><br> let result,targetp = Object.prototype.toString.call(target).slice(8,-1)<br> if(targetp===‘object’){<!-- --><br> result = {}<br> }else if (targetp===‘Array’){<!-- --><br> result = []<br> }else{<!-- --><br> return target<br> }<br> for (let i in target){<!-- --><br> let value = target[i]<br> if(Object.prototype.toString.call(value).slice(8,-1)=== ‘Object’||‘Array’){<!-- --><br> result[i]=clone(value)<br> }<br> }<br> }<br> 深拷贝使得数据更为安全<br> 数组，对象的拷贝一般都是会改变原数据值的，深拷贝了就不会了，就tm这么简单</p> 
<hr> 
<h3><a id="%0A12thiswindow%0A3eval4_410"></a>严格模式<br> 1、变量必须声明2、禁止自定义的函数this指向window<br> 3、创建eval作用域4、对象不能重名属性</h3> 
<h3><a id="es5_object%0A1Objectcreateprototypedescriptors_%0Aobj__%0Aobj2___Objectcreateobjsex%0A%09value12%0A%09writabletrue_%0A%09configurabletrue_%0A%09enumerabletrue_for_in_%0A%0A2ObjectdefinePropertiesobjectdescriptors_%0Alet_obj2__fkobelbryant%0AObjectdefinePropertiesobj2%0A%09fullname%0A%09%09getfunction_%0A%09%09%09return_thisfthisl%0A%09%09setfunctiondata%0A%09%09%09consolelogsetdata_%0A%0A%0A_414"></a>es5的 object拓展&amp;&amp;&amp;&amp;<br> 1、Object.create(prototype,[descriptors]) 以指定对象为原型创建新的对象<br> obj = {}<br> obj2 = Object.create(obj,{sex:{<!-- --><br> value:‘12’,<br> writable:true //可改变值的<br> configurable:true //可删的<br> enumerable:true //是否能用for in 枚举<br> }})<br> 2、Object.defineProperties(object,descriptors) 为指定的多个对象扩展属性<br> let obj2 = {f:‘kobe’,l:‘bryant’}<br> Object.defineProperties(obj2,{<!-- --><br> fullname:{<!-- --><br> get:function(){ //获取扩展属性<br> return this.f+’’+this.l}<br> set：function(data){<!-- --><br> console.log(‘set()’,data) //监听扩展属性，发生变化时自动回调<br> }<br> }<br> })</h3> 
<h3><a id="let_const%0Aconsoleloga%0Avar_a__3%0Aundefined_435"></a>***let不存在变量提升，可声明变量 const定义一个常量并且不能修改，也不存在变量提升<br> console.log(a)<br> var a = 3<br> 这种的不会是undefined了，而是报错，这也非常有好处</h3> 
<p>post与get<br> 最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数<br> 正是因为get直接把参数写在url上，所以get比post更不安全，而且get传送参数是有长度限制的post没有<br> 也正是因为在url中只能进行url编码，参数会被保留在浏览历史记录里，数据类型只接受ASCII字符<br> 而post都不限制</p> 
<p>获取请求数据的话<br> ‘comment?id=’+id</p> 
<p>get: let id = req.query.id //这个query是url里的请求 ,id是问号后面的<br> post: let id = req.request.body.id //request是接收的请求，从这个地方就看出不同</p> 
<h3><a id="%0Aget%0Apostpost_452"></a>另一点很重要的是<br> get用于信息获取，并不会影响资源内容<br> 而post表示可能修改服务器上的资源请求，用post必须要到表单</h3> 
<p>变量的解构赋值</p> 
<p>对象的解构赋值最常用export那个原理就这个<br> let obj = {username:‘q’,age:“12”}<br> let {username,age} = obj key值一定要一样<br> console.log(usename,age)<br> 这里的username就是obj.username,age同理</p> 
<p>数组结构赋值<br> let arr = [1,2,4,5]<br> let [a,b,c] = arr //这边这个是下标<br> console.log(a,b,c) //1,2,4</p> 
<h3><a id="%0Afunction_foousenameage%0A%09consolelogusenameage%0A%0Afooobject_469"></a>函数解构赋值<br> function foo({usename,age}){<!-- --><br> console.log(usename,age)<br> }<br> foo(object)</h3> 
<h3><a id="%0AThisthisthisthisWindows%0A_let_obj___a1bfunctionbtonclick__consolelogthis_function_thisobj%0A_let_obj___a1bbtonclick__consolelogthis_thiswindow_475"></a>箭头函数<br> 箭头函数的This看外层是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有则this是Windows<br> let obj = {a:1,b:function(){bt.onclick = ()=&gt;{console.log(this)}}} 上层找到function this就是obj<br> let obj = {a:1,b:()=&gt;{<!-- -->{bt.οnclick= ()=&gt;{ console.log(this)}}} 上层还是箭头函数再上一层的话没有函数了this就是window</h3>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ea4e35cb89153a16b3ccff18d52301bb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【组合数学】 普通型母函数（整数拆分问题，多重集的组合问题）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/59545093b96606f0c951e49d56847933/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java中的binarySearch方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>