<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux_study_1 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux_study_1" />
<meta property="og:description" content="Linux系统下.ko文件是什么文件？.so文件是什么文件... 5
我有一个文件abc.txt，我想用bunzip2压缩工具进行压缩！... 5
insmod(installmodule)5
记mount NFS遇到的一个问题(-o nolock)6
关于C语言结构体赋值(LINUX内核风格). 6
sprintf格式... 8
sprintf格式... 8
标识符... 9
宽度... 10
精度... 11
指示符... 11
指定参数... 14
注释问题... 15
解决 multiple definitionof15
Fopen函数简介... 16
strtok. 17
编辑本段原型... 17
编辑本段功能... 17
编辑本段说明... 18
编辑本段返回值... 18
编辑本段使用... 18
strncmp用法... 18
fwrite. 18
编辑本段函数名... 18
编辑本段功能... 18
编辑本段用法... 19
编辑本段程序示例... 19
#pragma pack. 21
编辑本段对齐方式... 21
gcc 错误搜集1. 22
如何解决warning:no newline at end of file?. 22" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/0cffcc199662a2219967bc7ea80ff51e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-08-27T14:03:12+08:00" />
<meta property="article:modified_time" content="2014-08-27T14:03:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux_study_1</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a target="_blank" rel="nofollow">Linux系统下.ko文件是什么文件？.so文件是什么文件<span style="color:windowtext">... </span><span style="color:windowtext">5</span></a></p> 
<p><a target="_blank" rel="nofollow">我有一个文件abc.txt，我想用bunzip2压缩工具进行压缩！<span style="color:windowtext">... </span><span style="color:windowtext">5</span></a></p> 
<p><a target="_blank" rel="nofollow">insmod(installmodule)<span style="color:windowtext">5</span></a></p> 
<p><a target="_blank" rel="nofollow">记mount NFS遇到的一个问题(-o nolock)<span style="color:windowtext">6</span></a></p> 
<p><a target="_blank" rel="nofollow">关于C语言结构体赋值(LINUX内核风格)<span style="color:windowtext">. </span><span style="color:windowtext">6</span></a></p> 
<p><a target="_blank" rel="nofollow">sprintf格式<span style="color:windowtext">... </span><span style="color:windowtext">8</span></a></p> 
<p><a target="_blank" rel="nofollow">sprintf格式<span style="color:windowtext">... </span><span style="color:windowtext">8</span></a></p> 
<p><a target="_blank" rel="nofollow">标识符<span style="color:windowtext">... </span><span style="color:windowtext">9</span></a></p> 
<p><a target="_blank" rel="nofollow">宽度<span style="color:windowtext">... </span><span style="color:windowtext">10</span></a></p> 
<p><a target="_blank" rel="nofollow">精度<span style="color:windowtext">... </span><span style="color:windowtext">11</span></a></p> 
<p><a target="_blank" rel="nofollow">指示符<span style="color:windowtext">... </span><span style="color:windowtext">11</span></a></p> 
<p><a target="_blank" rel="nofollow">指定参数<span style="color:windowtext">... </span><span style="color:windowtext">14</span></a></p> 
<p><a target="_blank" rel="nofollow">注释问题<span style="color:windowtext">... </span><span style="color:windowtext">15</span></a></p> 
<p><a target="_blank" rel="nofollow">解决 multiple definitionof<span style="color:windowtext">15</span></a></p> 
<p><a target="_blank" rel="nofollow">Fopen函数简介<span style="color:windowtext">... </span><span style="color:windowtext">16</span></a></p> 
<p><a target="_blank" rel="nofollow">strtok<span style="color:windowtext">. </span><span style="color:windowtext">17</span></a></p> 
<p><a target="_blank" rel="nofollow">编辑本段原型<span style="color:windowtext">... </span><span style="color:windowtext">17</span></a></p> 
<p><a target="_blank" rel="nofollow">编辑本段功能<span style="color:windowtext">... </span><span style="color:windowtext">17</span></a></p> 
<p><a target="_blank" rel="nofollow">编辑本段说明<span style="color:windowtext">... </span><span style="color:windowtext">18</span></a></p> 
<p><a target="_blank" rel="nofollow">编辑本段返回值<span style="color:windowtext">... </span><span style="color:windowtext">18</span></a></p> 
<p><a target="_blank" rel="nofollow">编辑本段使用<span style="color:windowtext">... </span><span style="color:windowtext">18</span></a></p> 
<p><a target="_blank" rel="nofollow">strncmp用法<span style="color:windowtext">... </span><span style="color:windowtext">18</span></a></p> 
<p><a target="_blank" rel="nofollow">fwrite<span style="color:windowtext">. </span><span style="color:windowtext">18</span></a></p> 
<p><a target="_blank" rel="nofollow">编辑本段函数名<span style="color:windowtext">... </span><span style="color:windowtext">18</span></a></p> 
<p><a target="_blank" rel="nofollow">编辑本段功能<span style="color:windowtext">... </span><span style="color:windowtext">18</span></a></p> 
<p><a target="_blank" rel="nofollow">编辑本段用法<span style="color:windowtext">... </span><span style="color:windowtext">19</span></a></p> 
<p><a target="_blank" rel="nofollow">编辑本段程序示例<span style="color:windowtext">... </span><span style="color:windowtext">19</span></a></p> 
<p><a target="_blank" rel="nofollow">#pragma pack<span style="color:windowtext">. </span><span style="color:windowtext">21</span></a></p> 
<p><a target="_blank" rel="nofollow">编辑本段对齐方式<span style="color:windowtext">... </span><span style="color:windowtext">21</span></a></p> 
<p><a target="_blank" rel="nofollow">gcc 错误搜集1<span style="color:windowtext">. </span><span style="color:windowtext">22</span></a></p> 
<p><a target="_blank" rel="nofollow">如何解决warning:no newline at end of file?<span style="color:windowtext">. </span><span style="color:windowtext">22</span></a></p> 
<p><a target="_blank" rel="nofollow">结构体初始化赋值={0}，GCC打开-Wall选项编译会警告，大家探讨一下<span style="color:windowtext">... </span><span style="color:windowtext">22</span></a></p> 
<p><a target="_blank" rel="nofollow">windows 如何查看端口占用情况?<span style="color:windowtext">. </span><span style="color:windowtext">23</span></a></p> 
<p><a target="_blank" rel="nofollow">memmove、memcpy和memccpy简介<span style="color:windowtext">... </span><span style="color:windowtext">24</span></a></p> 
<p><a target="_blank" rel="nofollow">流控制<span style="color:windowtext">... </span><span style="color:windowtext">25</span></a></p> 
<p><a target="_blank" rel="nofollow">字符串操作函数<span style="color:windowtext">... </span><span style="color:windowtext">26</span></a></p> 
<p><a target="_blank" rel="nofollow">使用pthread_mutex_t锁的例子<span style="color:windowtext">... </span><span style="color:windowtext">27</span></a></p> 
<p><a target="_blank" rel="nofollow">linux下select 和 poll的用法<span style="color:windowtext">... </span><span style="color:windowtext">29</span></a></p> 
<p><a target="_blank" rel="nofollow">ioctl<span style="color:windowtext">. </span><span style="color:windowtext">30</span></a></p> 
<p><a target="_blank" rel="nofollow">套接口操作：<span style="color:windowtext">... </span><span style="color:windowtext">33</span></a></p> 
<p><a target="_blank" rel="nofollow">文件操作：<span style="color:windowtext">... </span><span style="color:windowtext">33</span></a></p> 
<p><a target="_blank" rel="nofollow">编辑本段定义<span style="color:windowtext">... </span><span style="color:windowtext">33</span></a></p> 
<p><a target="_blank" rel="nofollow">编辑本段必要性<span style="color:windowtext">... </span><span style="color:windowtext">34</span></a></p> 
<p><a target="_blank" rel="nofollow">编辑本段实现操作<span style="color:windowtext">... </span><span style="color:windowtext">34</span></a></p> 
<p><a target="_blank" rel="nofollow">编辑本段其他信息<span style="color:windowtext">... </span><span style="color:windowtext">35</span></a></p> 
<p><a target="_blank" rel="nofollow">Mkdir函数<span style="color:windowtext">... </span><span style="color:windowtext">35</span></a></p> 
<p><a target="_blank" rel="nofollow">信号量sem_wait sem_post<span style="color:windowtext">36</span></a></p> 
<p><a target="_blank" rel="nofollow">Linux下开启/关闭防火墙命令<span style="color:windowtext">... </span><span style="color:windowtext">39</span></a></p> 
<p><a target="_blank" rel="nofollow">Linux下配置ip、子网掩码、网关，并把他们保存在指定的文件中，每次启动后不用重新设置。<span style="color:windowtext">    </span><span style="color:windowtext">40</span></a></p> 
<p><a target="_blank" rel="nofollow">Linux的关机与重启命令<span style="color:windowtext">... </span><span style="color:windowtext">40</span></a></p> 
<p><a target="_blank" rel="nofollow">安装RPM包或者安装源码包<span style="color:windowtext">... </span><span style="color:windowtext">41</span></a></p> 
<p><a target="_blank" rel="nofollow">Linux rpm 命令参数使用详解［介绍和应用］<span style="color:windowtext">... </span><span style="color:windowtext">53</span></a></p> 
<p><a target="_blank" rel="nofollow">GCC警告选项例解<span style="color:windowtext">... </span><span style="color:windowtext">62</span></a></p> 
<p><a target="_blank" rel="nofollow">Csocket基本原理<span style="color:windowtext">... </span><span style="color:windowtext">74</span></a></p> 
<p><a target="_blank" rel="nofollow">从问题看本质：socket到底是什么？<span style="color:windowtext">... </span><span style="color:windowtext">78</span></a></p> 
<p><a target="_blank" rel="nofollow">半双工通信<span style="color:windowtext">... </span><span style="color:windowtext">83</span></a></p> 
<p><a target="_blank" rel="nofollow">MFC打开/保存文件对话框:CFileDialog<span style="color:windowtext">. </span><span style="color:windowtext">83</span></a></p> 
<p><a target="_blank" rel="nofollow">setsockopt的各种使用<span style="color:windowtext">... </span><span style="color:windowtext">84</span></a></p> 
<p><a target="_blank" rel="nofollow">使用CFile类对文件进行读写<span style="color:windowtext">... </span><span style="color:windowtext">86</span></a></p> 
<p><a target="_blank" rel="nofollow">MFC同步类<span style="color:windowtext">... </span><span style="color:windowtext">90</span></a></p> 
<p><a target="_blank" rel="nofollow">同步对象的适用场合<span style="color:windowtext">... </span><span style="color:windowtext">90</span></a></p> 
<p><a target="_blank" rel="nofollow">等待类CSingleLock<span style="color:windowtext">. </span><span style="color:windowtext">90</span></a></p> 
<p><a target="_blank" rel="nofollow">TTS<span style="color:windowtext">. </span><span style="color:windowtext">92</span></a></p> 
<p><a target="_blank" rel="nofollow">-qws命令<span style="color:windowtext">... </span><span style="color:windowtext">92</span></a></p> 
<p><a target="_blank" rel="nofollow">ultraedit 自动缩进修改<span style="color:windowtext">... </span><span style="color:windowtext">94</span></a></p> 
<p><a target="_blank" rel="nofollow">typedef 函数指针的用法<span style="color:windowtext">... </span><span style="color:windowtext">95</span></a></p> 
<p><a target="_blank" rel="nofollow">﻿【转】（转）MFC中TRACE的用法<span style="color:windowtext">... </span><span style="color:windowtext">99</span></a></p> 
<p><a target="_blank" rel="nofollow">linux c语言定时器<span style="color:windowtext">... </span><span style="color:windowtext">100</span></a></p> 
<p><a target="_blank" rel="nofollow">Linux下查看文件和文件夹大小的df和du命令<span style="color:windowtext">... </span><span style="color:windowtext">105</span></a></p> 
<p><a target="_blank" rel="nofollow">linux 查看文件属性命令<span style="color:windowtext">... </span><span style="color:windowtext">107</span></a></p> 
<p><a target="_blank" rel="nofollow">pthread_attr_init线程属性<span style="color:windowtext">... </span><span style="color:windowtext">107</span></a></p> 
<p><a target="_blank" rel="nofollow">1．线程属性<span style="color:windowtext">... </span><span style="color:windowtext">107</span></a></p> 
<p><a target="_blank" rel="nofollow">2、线程的分离状态<span style="color:windowtext">... </span><span style="color:windowtext">108</span></a></p> 
<p><a target="_blank" rel="nofollow">3、线程的继承性<span style="color:windowtext">... </span><span style="color:windowtext">110</span></a></p> 
<p><a target="_blank" rel="nofollow">4、线程的调度策略<span style="color:windowtext">... </span><span style="color:windowtext">110</span></a></p> 
<p><a target="_blank" rel="nofollow">5、线程的调度参数<span style="color:windowtext">... </span><span style="color:windowtext">111</span></a></p> 
<p><a target="_blank" rel="nofollow">vsnprintf<span style="color:windowtext">112</span></a></p> 
<p><a target="_blank" rel="nofollow">目 录<span style="color:windowtext">... </span><span style="color:windowtext">112</span></a></p> 
<p><a target="_blank" rel="nofollow">1函数简介<span style="color:windowtext">... </span><span style="color:windowtext">113</span></a></p> 
<p><a target="_blank" rel="nofollow">2用法实例<span style="color:windowtext">... </span><span style="color:windowtext">113</span></a></p> 
<p><a target="_blank" rel="nofollow">SOCKADDR_IN<span style="color:windowtext">.. </span><span style="color:windowtext">114</span></a></p> 
<p><a target="_blank" rel="nofollow">目 录<span style="color:windowtext">... </span><span style="color:windowtext">114</span></a></p> 
<p><a target="_blank" rel="nofollow">1基本结构<span style="color:windowtext">... </span><span style="color:windowtext">115</span></a></p> 
<p><a target="_blank" rel="nofollow">2参数说明<span style="color:windowtext">... </span><span style="color:windowtext">115</span></a></p> 
<p><a target="_blank" rel="nofollow">AF_INET和PF_INET的细微不同<span style="color:windowtext">... </span><span style="color:windowtext">117</span></a></p> 
<p><a target="_blank" rel="nofollow">popen<span style="color:windowtext">. </span><span style="color:windowtext">117</span></a></p> 
<p><a target="_blank" rel="nofollow">pthread_cond_signal和pthread_cond_wait简介<span style="color:windowtext">... </span><span style="color:windowtext">119</span></a></p> 
<p><a target="_blank" rel="nofollow">linux 下route命令<span style="color:windowtext">... </span><span style="color:windowtext">125</span></a></p> 
<p><a target="_blank" rel="nofollow">UNIX环境高级编程读书笔记（十一）—终端IO （3）<span style="color:windowtext">... </span><span style="color:windowtext">128</span></a></p> 
<p><a target="_blank" rel="nofollow">select()函数以及FD_ZERO、FD_SET、FD_CLR、FD_ISSET<span style="color:windowtext">. </span><span style="color:windowtext">132</span></a></p> 
<p><a target="_blank" rel="nofollow">ioctl 函数<span style="color:windowtext">... </span><span style="color:windowtext">136</span></a></p> 
<p><a target="_blank" rel="nofollow">（C语言）共用体union的用法举例<span style="color:windowtext">... </span><span style="color:windowtext">140</span></a></p> 
<p><a target="_blank" rel="nofollow">Linux下getsockopt/setsockopt 函数说明<span style="color:windowtext">... </span><span style="color:windowtext">143</span></a></p> 
<p><a target="_blank" rel="nofollow">SVN多版本库配置问题<span style="color:windowtext">... </span><span style="color:windowtext">146</span></a></p> 
<p><a target="_blank" rel="nofollow">windows 下本机配置svn以及多版本库的创建<span style="color:windowtext">... </span><span style="color:windowtext">147</span></a></p> 
<p><a target="_blank" rel="nofollow">【C/C++】Linux下使用system()函数一定要谨慎<span style="color:windowtext">... </span><span style="color:windowtext">151</span></a></p> 
<p><a target="_blank" rel="nofollow">fork()函数 UNIX<span style="color:windowtext">.. </span><span style="color:windowtext">154</span></a></p> 
<p><a target="_blank" rel="nofollow">头文件：<span style="color:windowtext">... </span><span style="color:windowtext">154</span></a></p> 
<p><a target="_blank" rel="nofollow">函数原型：<span style="color:windowtext">... </span><span style="color:windowtext">154</span></a></p> 
<p><a target="_blank" rel="nofollow">函数说明：<span style="color:windowtext">... </span><span style="color:windowtext">155</span></a></p> 
<p><a target="_blank" rel="nofollow">为什么fork会返回两次？<span style="color:windowtext">... </span><span style="color:windowtext">155</span></a></p> 
<p><a target="_blank" rel="nofollow">Linux下/proc目录简介<span style="color:windowtext">... </span><span style="color:windowtext">156</span></a></p> 
<p><a target="_blank" rel="nofollow">shell的条件分支语句：<span style="color:windowtext">... </span><span style="color:windowtext">162</span></a></p> 
<p><a target="_blank" rel="nofollow">shell判断文件file存在：<span style="color:windowtext">... </span><span style="color:windowtext">163</span></a></p> 
<p><a target="_blank" rel="nofollow">在 /dev 中创建设备<span style="color:windowtext">... </span><span style="color:windowtext">163</span></a></p> 
<p><a target="_blank" rel="nofollow">6.8.1. 创建初始设备节点<span style="color:windowtext">... </span><span style="color:windowtext">163</span></a></p> 
<p><a target="_blank" rel="nofollow">6.8.2. 挂载ramfs 并填充/dev 目录<span style="color:windowtext">... </span><span style="color:windowtext">163</span></a></p> 
<p><a target="_blank" rel="nofollow">linux 目录树<span style="color:windowtext">... </span><span style="color:windowtext">164</span></a></p> 
<p><a target="_blank" rel="nofollow">虚拟内存盘<span style="color:windowtext">... </span><span style="color:windowtext">173</span></a></p> 
<p><a target="_blank" rel="nofollow">CramFS 文件系统的制作<span style="color:windowtext">... </span><span style="color:windowtext">174</span></a></p> 
<p><a target="_blank" rel="nofollow">【摘】编程质量--内存移动函数<span style="color:windowtext">... </span><span style="color:windowtext">176</span></a></p> 
<p><a target="_blank" rel="nofollow">vim与复制，删除，粘贴，块操作以及快速替换功能<span style="color:windowtext">... </span><span style="color:windowtext">180</span></a></p> 
<p><a target="_blank" rel="nofollow">先谈一下基于块的复制，删除，粘贴操作<span style="color:windowtext">... </span><span style="color:windowtext">181</span></a></p> 
<p><a target="_blank" rel="nofollow">使用块选的好处<span style="color:windowtext">... </span><span style="color:windowtext">181</span></a></p> 
<p><a target="_blank" rel="nofollow">批量替换列块<span style="color:windowtext">... </span><span style="color:windowtext">181</span></a></p> 
<p><a target="_blank" rel="nofollow">与移动相关<span style="color:windowtext">... </span><span style="color:windowtext">182</span></a></p> 
<p><a target="_blank" rel="nofollow">与复制相关<span style="color:windowtext">... </span><span style="color:windowtext">183</span></a></p> 
<p><a target="_blank" rel="nofollow">复原以及重做操作<span style="color:windowtext">... </span><span style="color:windowtext">183</span></a></p> 
<p><a target="_blank" rel="nofollow">替换模式<span style="color:windowtext">... </span><span style="color:windowtext">183</span></a></p> 
<p><a target="_blank" rel="nofollow">移动光标<span style="color:windowtext">... </span><span style="color:windowtext">183</span></a></p> 
<p><a target="_blank" rel="nofollow">在一行内移动光标<span style="color:windowtext">... </span><span style="color:windowtext">184</span></a></p> 
<p><a target="_blank" rel="nofollow">插入文本<span style="color:windowtext">... </span><span style="color:windowtext">184</span></a></p> 
<p><a target="_blank" rel="nofollow">删除和移动文本<span style="color:windowtext">... </span><span style="color:windowtext">185</span></a></p> 
<p><a target="_blank" rel="nofollow">修改文本<span style="color:windowtext">... </span><span style="color:windowtext">185</span></a></p> 
<p><a target="_blank" rel="nofollow">复制文本<span style="color:windowtext">... </span><span style="color:windowtext">186</span></a></p> 
<p><a target="_blank" rel="nofollow">如何画程序流程图<span style="color:windowtext">... </span><span style="color:windowtext">186</span></a></p> 
<p><a target="_blank" rel="nofollow">10个比viso好的流程图制作软件<span style="color:windowtext">... </span><span style="color:windowtext">193</span></a></p> 
<p><a target="_blank" rel="nofollow">Linuxpthread_mutex_init()函数<span style="color:windowtext">... </span><span style="color:windowtext">194</span></a></p> 
<p><a target="_blank" rel="nofollow">条件变量、pthread_cond_init<span style="color:windowtext">195</span></a></p> 
<p><a target="_blank" rel="nofollow">1.初始化条件变量pthread_cond_init<span style="color:windowtext">195</span></a></p> 
<p><a target="_blank" rel="nofollow">2.阻塞在条件变量上pthread_cond_wait<span style="color:windowtext">196</span></a></p> 
<p><a target="_blank" rel="nofollow">3.解除在条件变量上的阻塞pthread_cond_signal<span style="color:windowtext">196</span></a></p> 
<p><a target="_blank" rel="nofollow">4.阻塞直到指定时间pthread_cond_timedwait<span style="color:windowtext">197</span></a></p> 
<p><a target="_blank" rel="nofollow">5.释放阻塞的所有线程pthread_cond_broadcast<span style="color:windowtext">197</span></a></p> 
<p><a target="_blank" rel="nofollow">6.释放条件变量pthread_cond_destroy<span style="color:windowtext">. </span><span style="color:windowtext">197</span></a></p> 
<p><a target="_blank" rel="nofollow">7.唤醒丢失问题<span style="color:windowtext">... </span><span style="color:windowtext">198</span></a></p> 
<p><a target="_blank" rel="nofollow">#ifdef __cplusplus 有什么作用<span style="color:windowtext">... </span><span style="color:windowtext">198</span></a></p> 
<p><a target="_blank" rel="nofollow">Linux系统中的poll函数<span style="color:windowtext">... </span><span style="color:windowtext">207</span></a></p> 
<p><a target="_blank" rel="nofollow">ubuntu下配置vim<span style="color:windowtext">.. </span><span style="color:windowtext">210</span></a></p> 
<p><a target="_blank" rel="nofollow">VIM查找替换归纳总结zz<span style="color:windowtext">. </span><span style="color:windowtext">211</span></a></p> 
<p><a target="_blank" rel="nofollow">Linux下转换字符集(UTF8转换)（转）<span style="color:windowtext">... </span><span style="color:windowtext">212</span></a></p> 
<p><a target="_blank" rel="nofollow">pthread_attr_setdetachstate<span style="color:windowtext">. </span><span style="color:windowtext">216</span></a></p> 
<p><a target="_blank" rel="nofollow">pthread_attr_init线程属性<span style="color:windowtext">... </span><span style="color:windowtext">217</span></a></p> 
<p><a target="_blank" rel="nofollow">Linux信号量线程控制<span style="color:windowtext">... </span><span style="color:windowtext">223</span></a></p> 
<p><a target="_blank" rel="nofollow">C语言中printf格式化输出函数<span style="color:windowtext">... </span><span style="color:windowtext">226</span></a></p> 
<p><a target="_blank" rel="nofollow">例解GNUC之typeof<span style="color:windowtext">232</span></a></p> 
<p><a target="_blank" rel="nofollow">预编译语句中#与##的作用<span style="color:windowtext">... </span><span style="color:windowtext">234</span></a></p> 
<p><br> <a target="_blank" href="http://blog.csdn.net/lhuoshan/article/details/5410398" rel="noopener noreferrer"><span style="color:windowtext">Linux</span><span style="color:windowtext">系统下</span><span style="color:windowtext">.ko</span><span style="color:windowtext">文件是什么文件？</span><span style="color:windowtext">.so</span><span style="color:windowtext">文件是什么文件</span><span style="color:black">？</span></a><a target="_blank" name="_Toc362336339"></a><a target="_blank" name="_Toc362419919"></a><a target="_blank" name="_Toc369176373"></a><a target="_blank" name="_Toc376251194"></a></p> 
<p>A：.ko（kernel object），内核模块，可以在linux内核起来之后动态的加载和卸载</p> 
<p>    .so（shared object）用户层的动态库与（.a对应），使用同一个.so的程序在运行只需要该.so的一份拷贝</p> 
<h4><a target="_blank" name="_Toc376251195"></a><a target="_blank" name="_Toc369176374"></a><a target="_blank" name="_Toc362419920"></a><a target="_blank" name="_Toc362336340">我有一个文件abc.txt</a>，我想用bunzip2压缩工具进行压缩！</h4> 
<p><strong><span style="color:#2A2A2A; background:#F5FAFF">我有一个文件</span><span style="color:#2A2A2A; background:#F5FAFF">abc.txt</span><span style="color:#2A2A2A; background:#F5FAFF">，我想用</span><span style="color:#2A2A2A; background:#F5FAFF">bunzip2</span><span style="color:#2A2A2A; background:#F5FAFF">压缩工具进行压缩</span></strong></p> 
<p><span style="color:#2A2A2A; background:#F5FAFF">#bzip2 abc.txt</span></p> 
<p><em><span style="color:rgb(100,100,100)">注释：压缩后会得到一个压缩文件</span><span style="color:rgb(100,100,100)">abc.txt.bz2</span><span style="color:rgb(100,100,100)">，同时原</span><span style="color:rgb(100,100,100)">abc.txt</span><span style="color:rgb(100,100,100)">会被删除。（这点很重要哦，</span><span style="color:rgb(100,100,100)">linux</span><span style="color:rgb(100,100,100)">考试会问到这一点）</span></em></p> 
<p style="background:#F5FAFF"><strong><span style="color:#2A2A2A">如果有一个文件</span><span style="color:#2A2A2A">abc.txt.bz2</span><span style="color:#2A2A2A">，想解压缩：</span></strong></p> 
<p style="background:#F5FAFF"><span style="color:#2A2A2A">#bunzip2 abc.txt.bz2</span></p> 
<p style="background:#F5FAFF"><em><span style="color:#2A2A2A">注释：解压后会得到</span><span style="color:#2A2A2A">abc.txt</span><span style="color:#2A2A2A">，而原</span><span style="color:#2A2A2A">abc.txt.bz2</span><span style="color:#2A2A2A">会被删除。</span></em></p> 
<h4><strong> <a target="_blank" href="http://www.linuxso.com/command/insmod.html" rel="nofollow noopener noreferrer">insmod</a><a target="_blank" name="_Toc362336341"></a><a target="_blank" name="_Toc362419921"></a><a target="_blank" name="_Toc369176375"></a><a target="_blank" name="_Toc376251196"></a>(install mo<a target="_blank" href="http://www.linuxso.com/command/du.html" rel="nofollow noopener noreferrer">du</a>le)</strong></h4> 
<p style="background:#F5FAFF"><strong>功能说明：</strong>载入模块 install loadable kernel module</p> 
<p style="background:#F5FAFF"><strong>语法：</strong>insmod [-fkmpsvxX][-o&lt;模块名称&gt;][模块文件][符号名称= 符号值]</p> 
<p style="background:#F5FAFF"><strong>参数：</strong></p> 
<p style="background:#F5FAFF">-f 　不检查目前kernel版本与模块编译时的kernel版本是否一致，强制将模块载入。<br> -k 　将模块设置为自动卸除。<br> -m 　输出模块的载入信息。<br> -o   &lt;模块名称&gt; 　指定模块的名称，可使用模块文件的文件名。<br> -p 　测试模块是否能正确地载入kernel。<br> -s 　将所有信息记录在系统记录文件中。<br> -v 　执行时显示详细的信息。<br> -x 　不要汇出模块的外部符号。<br> -X 　汇出模块所有的外部符号，此为预设置。</p> 
<p style="background:#F5FAFF"><strong>使用说明：</strong>Linux有许多功能是通过模块的方式，在需要时才载入kernel。如此可使kernel较为精简，进而提高效率，以及保有较大的弹性。这类可载入的模块，通常是设备驱动程序。</p> 
<p style="background:#F5FAFF">insmod<a target="_blank" href="http://www.linuxso.com/command/" rel="nofollow noopener noreferrer">命令</a>主要用于在Linux 2.4内核之前加载Linux内核模块命令。对于通过此命令加载的Linux内核模块，系统不仅不会自动解决内核模块之间的依赖关系，而且还要求将模块路径写详细。所以在Linux 2.6内核出现时，此命令已渐渐被遗忘。</p> 
<p style="background:#F5FAFF">加载RAID1阵列级别模块，如下所示：</p> 
<p style="background:#F5FAFF">[root@rhel5 boot]# insmod /lib/modules/2.6.</p> 
<p style="background:#F5FAFF">18-8.el5/kernel/drivers/md/ra<a target="_blank" href="http://www.linuxso.com/command/id.html" rel="nofollow noopener noreferrer">id</a>1.ko  </p> 
<p style="background:#F5FAFF">[root@rhel5 boot]# <a target="_blank" href="http://www.linuxso.com/command/ls.html" rel="nofollow noopener noreferrer">ls</a>mod |<a target="_blank" href="http://www.linuxso.com/command/grep.html" rel="nofollow noopener noreferrer">grep</a> raid1  </p> 
<p style="background:#F5FAFF">raid1                  25153  0 </p> 
<p style="background:#F5FAFF">从以上显示结果可知，RAID1模块已加载成功。只是在使用insmod命令加载模块时，需要使用绝对路径方能加载，且加载时无法自动解决依赖关系。</p> 
<h2 style="background:#EEEEEE"><a target="_blank" name="_Toc376251197"></a><a target="_blank" name="_Toc369176376"></a><a target="_blank" name="_Toc362419922"></a><a target="_blank" name="_Toc362336342">记</a>mountNFS遇到的一个问题(-onolock)</h2> 
<p style="background:#F5FAFF"><span style="background:white">前两天</span><a target="_self"><strong><span style="color:#009999; background:white">测试</span></strong></a><span style="background:white">过程中，测试机始终</span><a target="_self"><strong><span style="color:#009999; background:white">mount</span></strong></a><span style="background:white">不上我们的</span><a target="_self"><strong><span style="color:#009999; background:white">nfs</span></strong></a><span style="background:white">。</span><br> <span style="background:white">比如我使用命令：</span><span style="background:white">mount vt-nfs:/share  /mnt/share</span><br> <span style="background:white">开始是</span><span style="background:white">mount</span><span style="background:white">命令一直</span><span style="background:white">hang</span><span style="background:white">在那里（卡住了）；另一种情况是，有类似如下的错误输出：</span><br> <span style="background:white">portmap:</span><span style="background:white"> </span><a target="_self"><strong><span style="color:#009999; background:white">server</span></strong></a><span style="background:white"> </span><span style="background:white">localhost not responding, timed out</span><br> <span style="background:white">RPC: failed to contact portmap (errno -5).</span><br> <span style="background:white">lockd_up: makesock failed, error=-5</span><br> <br> <span style="background:white">经过找了很久才发现了解决方案：</span><br> <span style="background:white">nfs mount </span><span style="background:white">默认选项包括文件锁，依赖于</span><span style="background:white">portmap</span><span style="background:white">提供的动态端口分配功能；</span><br> <span style="background:white">简单的解决方法：</span><span style="background:white">kill </span><span style="background:white">文件锁（</span><span style="background:white">lockd</span><span style="background:white">）或者</span><span style="background:white">mount -o</span><span style="background:white"> </span><a target="_self"><strong><span style="color:#009999; background:white">nolock</span></strong></a><br> <br> <span style="background:white">nolock</span><span style="background:white">这个选项是针对</span><span style="background:white">NFS</span><span style="background:white">所特有的：</span><span style="background:white">Disable NFS locking. Do not start lockd. This hasto be used with some old NFS servers that don't support locking.</span><br> <br> <span style="background:white">命令改为：</span><strong><span style="background:white">mount -o nolock my-nfs:/share  /mnt/share</span></strong><br> <span style="background:white">这样就可以正常</span><a target="_self"><strong><span style="color:#009999; background:white">工作</span></strong></a><span style="background:white">了。</span><br> <br> <span style="background:white">BTW</span><span style="background:white">：</span><br> <span style="background:white">mount iso</span><span style="background:white">文件常用命令</span><span style="background:white"> mount -o loop disk1.iso /mnt/disk</span><br> <span style="background:white">mount</span><span style="background:white">一个本地的目录</span><span style="background:white"> mount --bind  ./dir1 ./dir2</span><br> <br> <span style="background:white">参考：</span><br> <span style="background:white">http://blog.chinaunix.net/space.php?uid=24499&amp;do=blog&amp;cuid=480784</span><br> <span style="background:white">http://linux.die.net/man/8/mount</span><br> <span style="background:white"><a target="_blank" href="http://linux.die.net/man/5/nfs" rel="nofollow noopener noreferrer">http://linux.die.net/man/5/nfs</a></span></p> 
<h3><a target="_blank" name="_Toc376251198"></a><a target="_blank" name="_Toc369176377"></a><a target="_blank" name="_Toc362419923"></a><a target="_blank" name="_Toc362336343"><span style="color:#003366">关于</span></a><span style="color:#003366">C</span><span style="color:#003366">语言结构体赋值</span><span style="color:#003366">(LINUX</span><span style="color:#003366">内核风格</span><span style="color:#003366">)</span></h3> 
<p><a target="_blank" href="http://helloxchen.itpub.net/post/42725/508908" rel="nofollow noopener noreferrer">http://helloxchen.itpub.net/post/42725/508908</a></p> 
<p><span style="color:#003366">作者</span><span style="color:#003366">helloxchen 16:53 | </span> <a target="_blank" href="http://helloxchen.itpub.net/post/42725/508908" rel="nofollow noopener noreferrer"><span style="color:#999966">静态链接网址</span></a> |  <a target="_blank" href="http://helloxchen.itpub.net/post/42725/508908" rel="nofollow noopener noreferrer"><span style="color:#999966">最新回复</span><span style="color:#999966">(0)</span></a> |  <a target="_blank" href="http://helloxchen.itpub.net/trackbacks/42725/508908" rel="nofollow noopener noreferrer"><span style="color:#999966">引用</span><span style="color:#999966">(1)</span></a> | <a target="_blank" href="http://helloxchen.itpub.net/category/42725/66606" rel="nofollow noopener noreferrer"><span style="color:#999966">Linux_C</span></a></p> 
<p><span style="color:#555554">1 </span><span style="color:#555554">对成员<strong><span style="background:#FF9999">赋值</span></strong></span><span style="color:#555554">.</span></p> 
<p><span style="color:#555554">例如结构体</span><span style="color:#555554">struct st1 {<!-- --></span></p> 
<p><span style="color:#555554">int a;</span></p> 
<p><span style="color:#555554">int b;</span></p> 
<p><span style="color:#555554">int c;</span></p> 
<p><span style="color:#555554">}</span><span style="color:#555554"><br> 1.1 </span><span style="color:#555554">用</span><span style="color:#555554">{}</span><span style="color:#555554">形式</span><span style="color:#555554">.</span><span style="color:#555554"><br> struct st1 st1 = {1,2,3);</span><br> 1.2 linux kernel<span style="color:#555554">风格</span><span style="color:#555554">.</span><span style="color:#555554"><br> struct st1 st1 = {<!-- --></span><br> .a = 1;<br> .b = 2;<br> };</p> 
<p><span style="color:#555554">//</span><span style="color:#555554">注</span><span style="color:#555554">此风格（即在成员变量之前加点</span><span style="color:#555554">“.”</span><span style="color:#555554">）</span><span style="color:#555554">,</span><span style="color:#555554">可以不按成员变量的顺序进行赋值。如可以为</span></p> 
<p><span style="color:#555554">struct st1 st1 = {<!-- --></span></p> 
<p><span style="color:#555554">.c = 3;</span><span style="color:#555554"><br> .a = 1;</span><br> .b = 2;<br> };<br> <br> 2 <span style="color:#555554">对整体<strong><span style="background:#FF9999">赋值</span></strong></span><span style="color:#555554">.</span><span style="color:#555554"><br> struct st1 a,b;</span><br> b = a;<br> <br> 3<span style="color:#555554"> </span><strong><span style="color:#555554; background:#FFFF66">结构体</span></strong><span style="color:#555554">作为<strong><span style="background:#99FF99">函数</span></strong>返回值对另一个<strong><span style="background:#FFFF66">结构体</span><span style="background:#FF9999">赋值</span></strong></span><span style="color:#555554">.</span><span style="color:#555554"><br> struct st1 func1();</span><br> struct st1 a= func1();<br> <br> <span style="color:#555554">举例</span><span style="color:#555554">:</span><span style="color:#555554"><br> [ctest]# vi t.c</span><span style="color:#555554"> </span><span style="color:#555554"><br> <br> #include &lt;stdio.h&gt;</span><br> <br> struct st1 {<!-- --><br> int e1;<br> int e2;<br> };<br> <br> struct st1 func1()<br> {<!-- --><br> struct st1 h = { 77, 88};<br> return h;<br> }<br> <br> int main()<br> {<!-- --><br> struct st1 a= { 33, 44};<br> struct st1 b = {<!-- --><br> .e1 = 55,<br> };<br> struct st1 c;<br> struct st1 d;<br> c = a;<br> d = func1();<br> printf("e1 e2 is %d %dn", a.e1, a.e2);<br> printf("e1 e2 is %d %dn", b.e1, b.e2);<br> printf("e1 e2 is %d %dn", c.e1, c.e2);<br> printf("e1 e2 is %d %dn", d.e1, d.e2);<br> return 0;<br> }<br> "t.c" 29L, 420Cwritten<span style="color:#555554"> </span><span style="color:#555554"><br> [ctest]# gcc -o a t.c</span><br> [ctest]# ./a<span style="color:#555554"> </span><span style="color:#555554"><br> e1 e2 is 33 44</span><br> e1 e2 is 55 0<br> e1 e2 is 33 44<br> e1 e2 is 77 88</p> 
<p><span style="color:#555554"><a target="_blank" href="http://blog.163.com/a3563@126/blog/static/54675706200710134410126/" rel="nofollow noopener noreferrer"><strong><span style="color:#999966">http://blog.163.com/a3563@126/blog/static/54675706200710134410126/</span></strong></a></span></p> 
<h3><a target="_blank" name="_Toc376251199"></a><a target="_blank" name="_Toc369176378"></a><a target="_blank" name="_Toc362419924"></a><a target="_blank" name="_Toc362336344"><span style="color:#4B4B4B">sprintf</span></a><span style="color:#4B4B4B">格式</span></h3> 
<p><span style="color:rgb(75,75,75)">                                      </span></p> 
<p><span style="color:#4B4B4B"> </span></p> 
<h4><a target="_blank" name="_Toc376251200"></a><a target="_blank" name="_Toc369176379"></a><a target="_blank" name="_Toc362419925"></a><a target="_blank" name="_Toc362336345"></a><a target="_blank" name="sprintf.a5.d5.a5.a9.a1.bc.a5.de.a5.c3.a5">sprintf</a>格式</h4> 
<p><span style="color:#4B4B4B">Ruby</span><span style="color:#4B4B4B">的</span><span style="color:#4B4B4B">sprintf</span><span style="color:#4B4B4B">格式与</span><span style="color:#4B4B4B">C</span><span style="color:#4B4B4B">语言的</span><span style="color:blue">sprintf(3)</span><span style="color:#4B4B4B">基本相同。但还是有些差别</span><span style="color:#4B4B4B">: </span><span style="color:#4B4B4B">它没有针对</span><span style="color:#4B4B4B">C</span><span style="color:#4B4B4B">特有类型的修饰符</span><span style="color:#4B4B4B">,</span><span style="color:#4B4B4B">如</span><span style="color:#4B4B4B">short</span><span style="color:#4B4B4B">或</span><span style="color:#4B4B4B">long</span><span style="color:#4B4B4B">等</span><span style="color:#4B4B4B">; </span><span style="color:#4B4B4B">它包含</span><span style="color:#4B4B4B">2</span><span style="color:#4B4B4B">进制数的指示符</span><span style="color:#4B4B4B">(%b); </span><span style="color:#4B4B4B">它不支持</span><span style="color:#4B4B4B">sprintf</span><span style="color:#4B4B4B">的方言式的语法。</span></p> 
<p><span style="color:#4B4B4B">下面就对</span><span style="color:#4B4B4B">ruby</span><span style="color:#4B4B4B">的</span><span style="color:#4B4B4B">sprintf</span><span style="color:#4B4B4B">格式进行详细的说明。</span></p> 
<p><span style="color:#4B4B4B">sprintf</span><span style="color:#4B4B4B">格式的规格如下所示。</span><code><span style="color:#4B4B4B">[]</span></code><span style="color:#4B4B4B">中的部分是可选的。</span></p> 
<pre><span style="color:#4B4B4B">%[</span><span style="color:#4B4B4B">指定参数$][</span>标识符][宽度][.精度]指示符</pre> 
<p><span style="color:#4B4B4B">若想输出</span><span style="color:#4B4B4B">`</span><code><span style="color:#4B4B4B">%</span></code><span style="color:#4B4B4B">'</span><span style="color:#4B4B4B">本身时</span><span style="color:#4B4B4B">, </span><span style="color:#4B4B4B">请这样</span><span style="color:#4B4B4B">`</span><code><span style="color:#4B4B4B">%%</span></code><span style="color:#4B4B4B">'</span><span style="color:#4B4B4B">处理。</span></p> 
<p><span style="color:#4B4B4B">下面就分别介绍一下各元素的用法。</span></p> 
<h4><a target="_blank" name="_Toc376251201"></a><a target="_blank" name="_Toc369176380"></a><a target="_blank" name="_Toc362419926"></a><a target="_blank" name="_Toc362336346"></a><a target="_blank" name="a.a5.d5.a5.e9.a5.b0">标识符</a></h4> 
<p><span style="color:#4B4B4B">标识符包括</span><span style="color:#4B4B4B">`#', `+', ` '(</span><span style="color:#4B4B4B">空格</span><span style="color:#4B4B4B">), `-'</span><span style="color:#4B4B4B">和</span><span style="color:#4B4B4B">`0'</span><span style="color:#4B4B4B">这</span><span style="color:#4B4B4B">5</span><span style="color:#4B4B4B">个。</span></p> 
<p><a target="_blank" name="a.23"><span style="color:#4B4B4B">#</span></a></p> 
<p><span style="color:#4B4B4B">使用</span><span style="color:#4B4B4B">2</span><span style="color:#4B4B4B">进制、</span><span style="color:#4B4B4B">8</span><span style="color:#4B4B4B">进制、</span><span style="color:#4B4B4B">16</span><span style="color:#4B4B4B">进制的指示符</span><span style="color:#4B4B4B">(`b', `o', `x', `X')</span><span style="color:#4B4B4B">时</span><span style="color:#4B4B4B">, </span><span style="color:#4B4B4B">会分别添加</span><span style="color:#4B4B4B">"0b","0", "0x", "0X"</span><span style="color:#4B4B4B">前缀。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%#b", 10) # =&gt; "0b1010"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#o", 10) # =&gt; "012"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#x", 10) # =&gt; "0xa"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#X", 10) # =&gt; "0XA"</span></pre> 
<p><span style="color:#4B4B4B">对于浮点数</span><span style="color:#4B4B4B"> (`f', `e', `E', `g', `G'), </span><span style="color:#4B4B4B">则必定在输出中添加</span><span style="color:#4B4B4B">"."</span><span style="color:#4B4B4B">。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%.0f", 10) # =&gt; "10"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#.0f", 10) # =&gt; "10."</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%.0e", 10) # =&gt; "1e+01"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#.0e", 10) # =&gt; "1.e+01"</span></pre> 
<p><span style="color:#4B4B4B">`g',`G'</span><span style="color:#4B4B4B">除了具有上述特性外</span><span style="color:#4B4B4B">, </span><span style="color:#4B4B4B">还会在末尾添加多余的</span><span style="color:#4B4B4B">0</span><span style="color:#4B4B4B">。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%.05g", 10) # =&gt; "10"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#.05g", 10) # =&gt; "10.000"</span></pre> 
<p><a target="_blank" name="a.2b"><span style="color:#4B4B4B">+</span></a></p> 
<p><span style="color:#4B4B4B">使输出字符串带上符号。如果是正数的话</span><span style="color:#4B4B4B">, </span><span style="color:#4B4B4B">就会添加</span><span style="color:#4B4B4B">`+'</span><span style="color:#4B4B4B">。它只对数值指示符</span><span style="color:#4B4B4B">(`d', `i', `b', `o', `x', `X', `u', `f', `e', `E', `g', `G')</span><span style="color:#4B4B4B">起作用。另外</span><span style="color:#4B4B4B">, </span><span style="color:#4B4B4B">如果是</span><span style="color:#4B4B4B">`b', `o', `x', `X', `u'</span><span style="color:#4B4B4B">的话</span><span style="color:#4B4B4B">, </span><span style="color:#4B4B4B">则会为负数添加</span><span style="color:#4B4B4B">`-'</span><span style="color:#4B4B4B">。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%d", 1)   # =&gt; "1"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%+d", 1)  # =&gt; "+1"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%x", -1)  # =&gt; "..f"  # ".." </span><span style="color:#4B4B4B">表示f</span>无限延续</pre> 
<pre><span style="color:#4B4B4B">p sprintf("%+x", -1) # =&gt; "-1"</span></pre> 
<p><a target="_blank" name="a.27.20.27.28.a5.b9.a5.da.a1.bc.a5.b9.29"><span style="color:#4B4B4B">' '(</span></a><span style="color:#4B4B4B">空格</span><span style="color:#4B4B4B">)</span></p> 
<p><span style="color:#4B4B4B">与</span><span style="color:#4B4B4B">`+'</span><span style="color:#4B4B4B">相同</span><span style="color:#4B4B4B">, </span><span style="color:#4B4B4B">用空格来代替正号</span><span style="color:#4B4B4B">`+'</span><span style="color:#4B4B4B">。它只对数值指示符</span><span style="color:#4B4B4B">(`d', `i', `b', `o', `x',`X', `u', `f', `e', `E', `g', `G')</span><span style="color:#4B4B4B">起作用。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%d", 1)   # =&gt; "1"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%+d", 1)  # =&gt; "+1"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("% d", 1)  # =&gt; " 1"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%x", -1)  # =&gt; "..f"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("% x", 1)  # =&gt; " 1"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("% x", -1) # =&gt; "-1"</span></pre> 
<p><a target="_blank" name="a-"><span style="color:#4B4B4B">-</span></a></p> 
<p><span style="color:#4B4B4B">使输出内容靠左</span><span style="color:#4B4B4B">. </span> <span style="color:#4B4B4B">若尚未指定</span><span style="color:#4B4B4B"><a target="_blank" href="http://rubycn.ce-lab.net/man/sprintf_format.html#a.c9.fd" rel="nofollow noopener noreferrer" title="sprintf格式 (224d)">宽度</a></span><span style="color:#4B4B4B">的话</span><span style="color:#4B4B4B">,</span><span style="color:#4B4B4B">则不起作用。</span></p> 
<p><a target="_blank" name="a0"><span style="color:#4B4B4B">0</span></a></p> 
<p><span style="color:#4B4B4B">当输出内容靠右时</span><span style="color:#4B4B4B">, </span> <span style="color:#4B4B4B">使用</span><span style="color:#4B4B4B">`0'</span><span style="color:#4B4B4B">而并非空格来填充多余部分。</span></p> 
<p><span style="color:#4B4B4B">它只对数值指示符</span><span style="color:#4B4B4B">(`d', `i', `b', `o', `x', `X', `u', `f', `g', `G')</span><span style="color:#4B4B4B">起作用</span><span style="color:#4B4B4B">(</span><span style="color:#4B4B4B">对</span><span style="color:#4B4B4B">`e', `E'</span><span style="color:#4B4B4B">无效</span><span style="color:#4B4B4B">)</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%010d", 10)</span></pre> 
<pre><span style="color:#4B4B4B"># =&gt; "0000000010"</span></pre> 
<p><span style="color:#4B4B4B">与</span><span style="color:#4B4B4B">`#'</span><span style="color:#4B4B4B">一起使用时</span><span style="color:#4B4B4B">, </span><span style="color:#4B4B4B">输出情况如下。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%#010x", 10)  # =&gt; "0x0000000a"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#010o", 10)  # =&gt; "0000000012"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#010b", 10)  # =&gt; "0b00001010"</span></pre> 
<p><span style="color:#4B4B4B">它等同于下例。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%#10.8x", 10) # =&gt; "0x0000000a"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#10.9o", 10) # =&gt; "0000000012"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#10.8b", 10) # =&gt; "0b00001010"</span></pre> 
<p><span style="color:#4B4B4B">通常情况下</span><span style="color:#4B4B4B">, </span><span style="color:#4B4B4B">会输出如下内容。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%#10x", 10)   # =&gt; "       0xa"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#10o", 10)   # =&gt; "       012"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#10b", 10)   # =&gt; "    0b1010"</span></pre> 
<h4><a target="_blank" name="_Toc376251202"></a><a target="_blank" name="_Toc369176381"></a><a target="_blank" name="_Toc362419927"></a><a target="_blank" name="_Toc362336347"></a><a target="_blank" name="a.c9.fd">宽度</a></h4> 
<p><span style="color:#4B4B4B">以非</span><span style="color:#4B4B4B">0</span><span style="color:#4B4B4B">数字开头的数串负责指定宽度。宽度是指生成字符串的宽度</span><span style="color:#4B4B4B">, </span><span style="color:#4B4B4B">它不受后文中的</span><span style="color:#4B4B4B"><a target="_blank" href="http://rubycn.ce-lab.net/man/sprintf_format.html#a.c0.ba.c5.d9" rel="nofollow noopener noreferrer" title="sprintf格式 (224d)">精度</a></span><span style="color:#4B4B4B">的限制。</span></p> 
<p><span style="color:#4B4B4B">确定宽度时</span><span style="color:#4B4B4B">, </span><span style="color:#4B4B4B">也会考虑</span><span style="color:#4B4B4B"><a target="_blank" href="http://rubycn.ce-lab.net/man/sprintf_format.html#a.a5.d5.a5.e9.a5.b0" rel="nofollow noopener noreferrer" title="sprintf格式 (224d)">标识符</a></span><span style="color:#4B4B4B">中附加的</span><span style="color:#4B4B4B">" ","+","-", "0b", "0", "0x","0X"</span><span style="color:#4B4B4B">的长度。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%#05x", 10) # =&gt; "0x00a"</span></pre> 
<p><span style="color:#4B4B4B">宽度是指</span><span style="color:#4B4B4B">"</span><span style="color:#4B4B4B">必要的最小宽度</span><span style="color:#4B4B4B">". </span><span style="color:#4B4B4B">若结果字符串的宽度超过指定宽度时</span><span style="color:#4B4B4B">, </span><span style="color:#4B4B4B">指定宽度就会失效。</span></p> 
<p><span style="color:#4B4B4B">若将宽度指定为</span><span style="color:#4B4B4B">`*'</span><span style="color:#4B4B4B">时</span><span style="color:#4B4B4B">, </span><span style="color:#4B4B4B">将从参数中取得宽度值。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%10s", "foo")    # =&gt; "       foo"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%*s", 10, "foo") # =&gt; "       foo"</span></pre> 
<h4><a target="_blank" name="_Toc376251203"></a><a target="_blank" name="_Toc369176382"></a><a target="_blank" name="_Toc362419928"></a><a target="_blank" name="_Toc362336348"></a><a target="_blank" name="a.c0.ba.c5.d9">精度</a></h4> 
<p><span style="color:#4B4B4B">紧跟在</span><span style="color:#4B4B4B">"."</span><span style="color:#4B4B4B">后面的数串表示精度</span><span style="color:#4B4B4B">(</span><span style="color:#4B4B4B">若只有</span><span style="color:#4B4B4B">"."</span><span style="color:#4B4B4B">的话，则为</span><span style="color:#4B4B4B">".0")</span><span style="color:#4B4B4B">。若遇到整数的指示符</span><span style="color:#4B4B4B">(`d', `i', `b', `o', `x',`X', `u')</span><span style="color:#4B4B4B">的话，精度表示数值部分的长度。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%10.5d", 1)  # =&gt; "     00001"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#10.5x", 1) # =&gt; "   0x00001"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%+10.5x", 1) # =&gt; "    +00001"</span></pre> 
<p><span style="color:#4B4B4B">若遇到浮点数的指示符</span><span style="color:#4B4B4B">(`f')</span><span style="color:#4B4B4B">的话，它表示小数部分的位数。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%10.5f", 1)   # =&gt; "   1.00000"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%10.5f", 10)  # =&gt; "  10.00000"</span></pre> 
<p><span style="color:#4B4B4B">若遇到浮点数的指示符</span><span style="color:#4B4B4B">(`e', `E', `g', `G')</span><span style="color:#4B4B4B">的话，它表示有效位数。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%10.5e", 1)   # =&gt; "1.00000e+00"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%10.5e", 10)  # =&gt; "1.00000e+01"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%10.5g",  10)  # =&gt; "        10"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#10.5G", 10)  # =&gt; "    10.000"</span></pre> 
<p><span style="color:#4B4B4B">如果是字符串指示符</span><span style="color:#4B4B4B">(`s', `p')</span><span style="color:#4B4B4B">的话，将会按照精度的规定来检查参数中的字符串长度，并切除多余部分。若将宽度和精度设为同值的话，则只输出参数字符串中的符合精度规定的部分。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%10.2s", "foo")  # =&gt; "        fo"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%5.5s", "foo")     # =&gt; # =&gt; "  foo"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%5.5s", "foobar")  # =&gt; # =&gt; "fooba"</span></pre> 
<p><span style="color:#4B4B4B">若将精度设为</span><span style="color:#4B4B4B">`*'</span><span style="color:#4B4B4B">的话，将从参数中提取精度的值。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%.5s", "foobar")    # =&gt; "fooba"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%.*s", 5, "foobar") # =&gt; "fooba"</span></pre> 
<h4><a target="_blank" name="_Toc376251204"></a><a target="_blank" name="_Toc369176383"></a><a target="_blank" name="_Toc362419929"></a><a target="_blank" name="_Toc362336349"></a><a target="_blank" name="a.bb.d8.bc.a8.bb.d2">指示符</a></h4> 
<p><span style="color:#4B4B4B">指示符指出参数的类型，且是必选的。大体说来它包括：</span></p> 
<p align="left"><span style="color:#4B4B4B">·        </span><span style="color:#4B4B4B">表示字符串的指示符</span><span style="color:#4B4B4B">: `c', `s', `p'</span></p> 
<p align="left"><span style="color:#4B4B4B">·        </span><span style="color:#4B4B4B">表示整数的指示符</span><span style="color:#4B4B4B">: `d', `i', `u', `b', `o', `x', `X',</span></p> 
<p align="left"><span style="color:#4B4B4B">·        </span><span style="color:#4B4B4B">表示浮点数的指示符</span><span style="color:#4B4B4B">: `f', `g', `e', `E', `G'</span></p> 
<p><span style="color:#4B4B4B">这几类。</span></p> 
<p><a target="_blank" name="c"><span style="color:#4B4B4B">c</span></a></p> 
<p><span style="color:#4B4B4B">将参数的数值</span><span style="color:#4B4B4B">(0×255)</span><span style="color:#4B4B4B">看作是字符代码，并输出对应的字符。若参数并非数值、</span><span style="color:#4B4B4B">String</span><span style="color:#4B4B4B">、</span><span style="color:#4B4B4B"> nil,true</span><span style="color:#4B4B4B">或</span><span style="color:#4B4B4B">false</span><span style="color:#4B4B4B">的话，将尝试用</span><span style="color:#4B4B4B">to_int</span><span style="color:#4B4B4B">方法进行变换。</span></p> 
<p><span style="color:#4B4B4B">此时，只有</span><span style="color:#4B4B4B"><a target="_blank" href="http://rubycn.ce-lab.net/man/sprintf_format.html#a.a5.d5.a5.e9.a5.b0" rel="nofollow noopener noreferrer" title="sprintf格式 (224d)">标识符</a></span>`-'<span style="color:#4B4B4B">和</span><span style="color:#4B4B4B">"<a target="_blank" href="http://rubycn.ce-lab.net/man/sprintf_format.html#a.c9.fd" rel="nofollow noopener noreferrer" title="sprintf格式 (224d)">宽度</a></span>"<span style="color:#4B4B4B">的设定是有效的。</span></p> 
<p><a target="_blank" name="s"><span style="color:#4B4B4B">s</span></a></p> 
<p><span style="color:#4B4B4B">输出字符串。</span></p> 
<p><span style="color:#4B4B4B">若参数并非</span><span style="color:blue">String</span><span style="color:#4B4B4B">对象的话，将使用</span><span style="color:#4B4B4B">to_s</span><span style="color:#4B4B4B">方法对其进行变换。</span></p> 
<p><a target="_blank" name="p"><span style="color:#4B4B4B">p</span></a></p> 
<p><span style="color:blue">ruby 1.8 </span><span style="color:blue">特性</span><span style="color:#4B4B4B">: </span><span style="color:#4B4B4B">输出</span><span style="color:blue">Object#inspect</span><span style="color:#4B4B4B">的结果。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%s", [1, 2, 3])      # =&gt; "123"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%p", [1, 2, 3])      # =&gt; "[1, 2, 3]"</span></pre> 
<p><a target="_blank" name="d"><span style="color:#4B4B4B">d</span></a></p> 
<p><a target="_blank" name="i"><span style="color:#4B4B4B">i</span></a></p> 
<p><span style="color:#4B4B4B">以</span><span style="color:#4B4B4B">10</span><span style="color:#4B4B4B">进制整数的形式输出参数中的数值。</span></p> 
<p><span style="color:#4B4B4B">若参数并非整数，则使用与</span><span style="color:blue">Integer</span><span style="color:#4B4B4B">函数相同的规则将其变为整数。</span></p> 
<p><a target="_blank" name="u"><span style="color:#4B4B4B">u</span></a></p> 
<p><span style="color:#4B4B4B">将参数的数值看作是无符号整数，并以</span><span style="color:#4B4B4B">10</span><span style="color:#4B4B4B">进制整数的形式输出它。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%u", -1) # =&gt; "..4294967295"</span></pre> 
<p><span style="color:#4B4B4B">上面的代码会输出</span><span style="color:#4B4B4B"> p ".." + 0xffff_ffff.to_s</span><span style="color:#4B4B4B">。</span></p> 
<p><span style="color:blue">ruby 1.7 </span><span style="color:blue">特性</span><span style="color:#4B4B4B">: </span><span style="color:#4B4B4B">在</span><span style="color:#4B4B4B">version 1.7</span><span style="color:#4B4B4B">中，不会附加</span><span style="color:#4B4B4B">".."</span><span style="color:#4B4B4B">。若是</span><span style="color:#4B4B4B">'%u'</span><span style="color:#4B4B4B">的话，则将参数看作是定长整数。此时，对于负整数</span><span style="color:#4B4B4B">n</span><span style="color:#4B4B4B">来说</span></p> 
<pre><span style="color:#4B4B4B">printf("%u", n)</span></pre> 
<p><span style="color:#4B4B4B">与</span></p> 
<pre><span style="color:#4B4B4B">printf("%d", n &amp; ~(-1 &lt;&lt; n.size*8))</span></pre> 
<p><span style="color:#4B4B4B">是一个意思。</span></p> 
<p><a target="_blank" name="b"><span style="color:#4B4B4B">b</span></a></p> 
<p><a target="_blank" name="o"><span style="color:#4B4B4B">o</span></a></p> 
<p><a target="_blank" name="X"><span style="color:#4B4B4B">x</span></a></p> 
<p><span style="color:#4B4B4B">X</span></p> 
<p><span style="color:#4B4B4B">分别以</span><span style="color:#4B4B4B">2</span><span style="color:#4B4B4B">进制、</span><span style="color:#4B4B4B">8</span><span style="color:#4B4B4B">进制、</span><span style="color:#4B4B4B">16</span><span style="color:#4B4B4B">进制、</span><span style="color:#4B4B4B">16</span><span style="color:#4B4B4B">进制</span><span style="color:#4B4B4B">(</span><span style="color:#4B4B4B">大写字母</span><span style="color:#4B4B4B">)</span><span style="color:#4B4B4B">字符串的形式输出整数。</span></p> 
<p><span style="color:#4B4B4B">若使用了</span><span style="color:#4B4B4B">`#' </span> <span style="color:#4B4B4B">标识符的话，则分别在前面添加</span><span style="color:#4B4B4B">"0b", "0", "0x", "0X"</span><span style="color:#4B4B4B">。</span></p> 
<p><span style="color:#4B4B4B">若没有使用</span><span style="color:#4B4B4B">`+', ` ' </span> <span style="color:#4B4B4B">标识符时，将在负数的前面</span><span style="color:#4B4B4B">(</span><span style="color:#4B4B4B">若有</span><span style="color:#4B4B4B">`#' </span><span style="color:#4B4B4B">标识符，则在</span><span style="color:#4B4B4B">"0x"</span><span style="color:#4B4B4B">等的后面</span><span style="color:#4B4B4B">)</span><span style="color:#4B4B4B">添加</span><span style="color:#4B4B4B">".."</span><span style="color:#4B4B4B">。这表示最高位字符无限延伸，它采用了</span><span style="color:#4B4B4B">2</span><span style="color:#4B4B4B">的补数形式来表现负数。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%#b", 10)    # =&gt; "0b1010"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#o", 10)    # =&gt; "012"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#x", 10)    # =&gt; "0xa"</span></pre> 
<pre><span style="color:#4B4B4B"># </span><span style="color:#4B4B4B">对负数添加".."</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#b", -1)    # =&gt; "0b..1"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#o", -1)    # =&gt; "0..7"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%#x", -1)    # =&gt; "0x..f"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%10x", -1)   # =&gt; "       ..f"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%-10x", -1)  # =&gt; "..f       "</span></pre> 
<pre><span style="color:#4B4B4B"># </span><span style="color:#4B4B4B">若指定了"</span>精度"的话，则不会添加".."</pre> 
<pre><span style="color:#4B4B4B">p sprintf("%.10x", -1)  # =&gt; "ffffffffff"</span></pre> 
<p><a target="_blank" name="f"><span style="color:#4B4B4B">f</span></a></p> 
<p><a target="_blank" name="E"><span style="color:#4B4B4B">e</span></a></p> 
<p><span style="color:#4B4B4B">E</span></p> 
<p><a target="_blank" name="G"><span style="color:#4B4B4B">g</span></a></p> 
<p><span style="color:#4B4B4B">G</span></p> 
<p><span style="color:#4B4B4B">`f' </span><span style="color:#4B4B4B">以小数点形式</span><span style="color:#4B4B4B">(xxx.xxx)</span><span style="color:#4B4B4B">输出数值。</span></p> 
<p><span style="color:#4B4B4B">`e' </span><span style="color:#4B4B4B">以指数形式</span><span style="color:#4B4B4B">(x.xxxe+xx)</span><span style="color:#4B4B4B">输出数值。</span></p> 
<p><span style="color:#4B4B4B">`g' </span><span style="color:#4B4B4B">的情况比较特殊。当指数小于</span><span style="color:#4B4B4B">-4</span><span style="color:#4B4B4B">或者超出精度范围时，它采用</span><span style="color:#4B4B4B">`e'</span><span style="color:#4B4B4B">方式进行输出。除此之外，它采用</span><span style="color:#4B4B4B">`f'</span><span style="color:#4B4B4B">方式进行输出。另外，它会删除小数部分尾部的</span><span style="color:#4B4B4B">0</span><span style="color:#4B4B4B">。</span></p> 
<p><span style="color:#4B4B4B">大写字母指示符</span><span style="color:#4B4B4B">(`E', `G')</span><span style="color:#4B4B4B">会将输出中的字母变为大写形式。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%f", 1.0) # =&gt; "1.000000"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%e", 1.0) # =&gt; "1.000000e+00"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%g", 1.0) # =&gt; "1"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%f", 10.1) # =&gt; "10.100000"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%e", 10.1) # =&gt; "1.010000e+01"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%g", 10.1) # =&gt; "10.1"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%g", 10 ** 6)  # =&gt; "1e+06"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%g", 10 ** -5) # =&gt; "1e-05"</span></pre> 
<p><span style="color:#4B4B4B">精度的缺省值为</span><span style="color:#4B4B4B">6</span><span style="color:#4B4B4B">。</span></p> 
<p><span style="color:#4B4B4B">若遇到无限大值或</span><span style="color:#4B4B4B">NaN(Not a Number)</span><span style="color:#4B4B4B">时，输出情况如下。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%f",  1.0/0)  # =&gt; "inf"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%f", -1.0/0)  # =&gt; "-inf"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%f",  0.0/0)  # =&gt; "nan"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%E",  1.0/0)  # =&gt; "INF"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%E", -1.0/0)  # =&gt; "-INF"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%E",  0.0/0)  # =&gt; "NAN"</span></pre> 
<h4><a target="_blank" name="_Toc376251205"></a><a target="_blank" name="_Toc369176384"></a><a target="_blank" name="_Toc362419930"></a><a target="_blank" name="_Toc362336350"></a><a target="_blank" name="a.b0.fa.bf.f4.bb.d8.c4.ea">指定参数</a></h4> 
<p><span style="color:#4B4B4B">这部分的利用频率最低，所以放在最后。</span></p> 
<p><a target="_blank" name="nth.24"><span style="color:#4B4B4B">nth$</span></a></p> 
<p><span style="color:#4B4B4B">表示将使用第</span><var><span style="color:#4B4B4B">nth</span></var><span style="color:#4B4B4B">个参数进行格式化操作。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%1$d, %1$x, %1$o", 10)</span></pre> 
<pre><span style="color:#4B4B4B">=&gt; "10, a, 12"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%3$d, %2$x, %1$o", 1, 2, 3)</span></pre> 
<pre><span style="color:#4B4B4B">=&gt; "3, 2, 1"</span></pre> 
<p><span style="color:#4B4B4B">若您不想改变参数的顺序而只想改变格式的话，也可以使用它。</span></p> 
<pre><span style="color:#4B4B4B">case ENV['LC_TIME']</span></pre> 
<pre><span style="color:#4B4B4B">when /^ja_JP/</span></pre> 
<pre><span style="color:#4B4B4B">fmt = "%1$d</span><span style="color:#4B4B4B">年%2$d</span>月%3$d日"</pre> 
<pre><span style="color:#4B4B4B">else</span></pre> 
<pre><span style="color:#4B4B4B">fmt = "%2$02d/%03$2d/%1$02d"</span></pre> 
<pre><span style="color:#4B4B4B">end</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf(fmt, 1, 4, 22)</span></pre> 
<pre><span style="color:#4B4B4B">=&gt; "04/22/01"</span></pre> 
<p><span style="color:#4B4B4B">您也可以先插入</span><span style="color:#4B4B4B">"*"</span><span style="color:#4B4B4B">，然后借用参数来设定</span><span style="color:#4B4B4B">"<a target="_blank" href="http://rubycn.ce-lab.net/man/sprintf_format.html#a.c9.fd" rel="nofollow noopener noreferrer" title="sprintf格式 (224d)">宽度</a></span>"<span style="color:#4B4B4B">和</span><span style="color:#4B4B4B">"<a target="_blank" href="http://rubycn.ce-lab.net/man/sprintf_format.html#a.c0.ba.c5.d9" rel="nofollow noopener noreferrer" title="sprintf格式 (224d)">精度</a></span>"<span style="color:#4B4B4B">的值。</span></p> 
<pre><span style="color:#4B4B4B">p sprintf("%5.2f", 1);              # =&gt; " 1.00"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%*.*f", 5, 2, 1);        # =&gt; " 1.00"</span></pre> 
<pre><span style="color:#4B4B4B">p sprintf("%1$*2$.*3$f", 1, 5, 2);  # =&gt; " 1.00</span></pre> 
<p style="background:#F5FAFF"> </p> 
<p style="background:#F5FAFF"> </p> 
<h3><a target="_blank" name="_Toc376251206"></a><a target="_blank" name="_Toc369176385"></a><a target="_blank" name="_Toc362419931"><span style="color:#4B4B4B">注释问题</span></a></h3> 
<p align="right"><span style="color:#999999">2009-06-24 10:27</span><span style="color:#999999"> </span><span style="color:#999999">157</span><span style="color:#999999">人阅读</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/xiaolh/article/details/4293636#comments" rel="noopener noreferrer"><span style="color:#336699">评论</span></a></span>(0)<span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" title="收藏"><span style="color:#336699">收藏</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/xiaolh/article/details/4293636#report" title="举报" rel="noopener noreferrer"><span style="color:#336699">举报</span></a></span></p> 
<p><span style="color:#333333">====================================================================<br> //  Some comment<br> //  /<br> //  Some more comment<br> <br> int main(int, char **) { return 0; }      </span><span style="color:#333333"> </span><span style="color:#333333"><br> ====================================================================<br> <br> compiling with g++ will yield the following warning:<br> <a target="_blank" name="OLE_LINK2"></a><a target="_blank" name="OLE_LINK1">x.cc:2:2:warning: multi-line comment</a> <br>  </span></p> 
<p><span style="color:#333333">What isthe point of this warning?  Shouldn't the preprocessor<br> &gt; &gt; &gt; just ignore everything between the // and the end-of-line?<br> &gt; &gt;</span><span style="color:#333333"> </span><span style="color:#333333"><br> &gt; &gt; No, backslash-newline conversion happens before comments<br> &gt; &gt; are discarded.  You really do have a multi-line comment;<br> &gt; &gt; one that would be dangerous if your next line weren't a<br> &gt; &gt; comment as well.</span></p> 
<p><span style="color:#333333">在</span><span style="color:#333333">//</span><span style="color:#333333">注释行的最后不能加</span><span style="color:#333333"> \ ,</span><span style="color:#333333">加</span><span style="color:#333333"> \ </span><span style="color:#333333">表示下一行看成是注释，如果下一行不是注释的话会出错</span></p> 
<h3><a target="_blank" name="_Toc376251207"></a><a target="_blank" name="_Toc369176386">解决 multipledefinition of</a></h3> 
<p align="left"><span style="color:rgb(85,85,85)">总结了解决multipledefinition of</span><a target="_blank" name="Post"></a>的方法：</p> 
<p align="left"><span style="color:#555555">问题原因：<br>     </span>当多个文件包含同一个头文件时，并且你的.H里面没有加上条件编译<br> #ifndef TEST_H<br> #define TEST_H<br> #endif<br> 就会独立的解释,然后生成每个文件生成独立的标示符。在编译器连接时，就会将工程中所有的符号整合在一起，由于，文件中有重名变量，于是就出现了重复定义的错误。<span style="color:#555555"> </span><span style="color:#555555"><br> <br> </span><span style="color:#555555">方法1</span>：<br>     给每一个头文件加上条件编译，避免该文件被多次引用时被多次解释，这是个应该是习惯。这个方法会解决大部分低级问题。<br> <br> 方法2：<br>     当方法1无效时，可以把所有的全局变量放入一个头文件 global.h (名字随意起，但要加条件编译)中，每一个变量前面加extern，声明一下这些变量将在其它文件中定义。 然后建立一个和头文件名字对应的.cor .cpp文件 如global.c。在里面声明所有的全局变量。例如：void(*Handl_Display)();<br> 然后，让涉及到全局变量的文件include ”global.h“。这样编译时，会先对global.c编译生成一个global.o ，然后再和其它文件的.o链接生成可执行文件。<br> <br> 方法3：<br>     懒人方法，在所有的全局变量前加上static ，声明成静止变量。也能解决问题。<br>      所有的方法都是网来的，O(∩_∩)O哈哈~<br>      谢谢所有的提供方法的哥们~</p> 
<p>函数fopen</p> 
<h3><a target="_blank" name="_Toc376251208"></a><a target="_blank" name="_Toc369176387"></a><a target="_blank" name="1_1"></a><a target="_blank" name="sub656681_1_1"></a>Fopen函数简介</h3> 
<p><strong>函数功能：</strong>打开一个<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a></p> 
<p><strong>函数原型：</strong>FILE* f<a target="_blank" href="http://baike.baidu.com/view/26337.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">open</span></a>(const char * path,const char * mode);</p> 
<p><strong>相关函数：</strong><a target="_blank" href="http://baike.baidu.com/view/26337.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">open</span></a>，<a target="_blank" href="http://baike.baidu.com/view/656642.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">fclose</span></a>，<a target="_blank" href="http://baike.baidu.com/view/3133774.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">fopen_s</span></a><sup><span style="color:#3366CC">[1]</span></sup><a target="_blank" name="ref_%5B1%5D_656681"></a>，_wfopen</p> 
<p><strong>所需库：</strong>&lt;<a target="_blank" href="http://baike.baidu.com/view/538727.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">stdio.h</span></a>&gt;</p> 
<p><strong>返回值：</strong><a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>顺利打开后，指向该流的<a target="_blank" href="http://baike.baidu.com/view/5019859.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件指针</span></a>就会被返回。如果<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>打开失败则返回NULL，并把<a target="_blank" href="http://baike.baidu.com/view/1600019.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">错误代码</span></a>存在errno 中。</p> 
<p>一般而言，打开<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>后会作一些文件读取或写入的动作，若打开文件失败，接下来的读写动作也无法顺利进行，所以一般在f<a target="_blank" href="http://baike.baidu.com/view/26337.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">open</span></a>()后作错误判断及处理。</p> 
<p><strong>参数说明：</strong></p> 
<p>参数path<a target="_blank" href="http://baike.baidu.com/view/263416.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">字符</span></a>串包含欲打开的<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>路径及文件名，参数mode字符串则代表着流<a target="_blank" href="http://baike.baidu.com/view/665254.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">形态</span></a>。</p> 
<p>mode有下列几种形态字符串:</p> 
<p>r 以<a target="_blank" href="http://baike.baidu.com/view/1060618.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">只读</span></a>方式打开<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>，该文件必须存在。</p> 
<p>r+ 以可读写方式打开<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>，该文件必须存在。</p> 
<p>rb+ 读写打开一个<a target="_blank" href="http://baike.baidu.com/view/1473761.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">二进制文件</span></a>，允许读写<a target="_blank" href="http://baike.baidu.com/view/38752.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">数据</span></a>。</p> 
<p>rw+ 读写打开一个文本<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>，允许读和写。</p> 
<p>w 打开只写<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>，若文件存在则文件长度清为0，即该文件内容会消失。若<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>不存在则建立该文件。</p> 
<p>w+ 打开可读写<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>，若文件存在则文件长度清为零，即该文件内容会消失。若<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>不存在则建立该文件。</p> 
<p>a 以附加的<a target="_blank" href="http://baike.baidu.com/view/199787.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">方式</span></a>打开只写<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>。若<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）</p> 
<p>a+ 以附加方式打开可读写的<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>。若<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）</p> 
<p>wb 只写打开或新建一个<a target="_blank" href="http://baike.baidu.com/view/1473761.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">二进制文件</span></a>；只允许写数据。</p> 
<p>wb+ 读写打开或建立一个<a target="_blank" href="http://baike.baidu.com/view/1473761.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">二进制文件</span></a>，允许读和写。</p> 
<p>ab+ 读写打开一个<a target="_blank" href="http://baike.baidu.com/view/1473761.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">二进制文件</span></a>，允许读或在文件末追加数据。</p> 
<p>at+ 打开一个叫string的文件，a表示append,就是说写入处理的时候是接着原来文件已有内容写入，不是从头写入覆盖掉，t表示打开文件的类型是文本文件，+号表示对文件既可以读也可以写。</p> 
<p>上述的形态字符串都可以再加一个b字符，如rb、w+b或ab+等组合，加入b 字符用来告诉函数库以二进制模式打开文件。如果不加b，表示默认加了t，即rt,wt,其中t表示以<a target="_blank" href="http://baike.baidu.com/view/404466.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文本模式</span></a>打开文件。由f<a target="_blank" href="http://baike.baidu.com/view/26337.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">open</span></a>()所建立的新<a target="_blank" href="http://baike.baidu.com/view/345685.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件</span></a>会具有S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666)权限，此文件权限也会参考umask值。</p> 
<p>有些C<a target="_blank" href="http://baike.baidu.com/view/3279760.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">编译系统</span></a>可能不完全提供所有这些功能，有的C<a target="_blank" href="http://baike.baidu.com/view/26783.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">版本</span></a>不用"r+","w+","a+",而用"rw","wr","ar"等，读者注意所用系统的规定。</p> 
<p><strong>二进制和文本模式的区别</strong></p> 
<p>1.在windows系统中，文本模式下，文件以""代表换行。若以文本模式打开文件，并用fputs等函数写入换行符"\n"时，函数会自动在"\n"前面加上"\r"。即实际写入文件的是""。</p> 
<p>2.在类Unix/Linux系统中文本模式下，文件以"\n"代表换行。所以Linux系统中在文本模式和二进制模式下并无区别。</p> 
<h3><a target="_blank" name="_Toc376251209"></a><a target="_blank" name="_Toc369176388">strtok</a></h3> 
<div> 
 <p><strong>目录</strong></p> 
</div> 
<p><a target="_blank" name="STAT_ONCLICK_UNSUBMIT_CATALOG"></a><a target="_blank" href="http://baike.baidu.com/view/1028553.htm#1" rel="nofollow noopener noreferrer"><span style="color:#136EC2">原型</span></a></p> 
<p><a target="_blank" href="http://baike.baidu.com/view/1028553.htm#2" rel="nofollow noopener noreferrer"><span style="color:#136EC2">功能</span></a></p> 
<p><a target="_blank" href="http://baike.baidu.com/view/1028553.htm#3" rel="nofollow noopener noreferrer"><span style="color:#136EC2">说明</span></a></p> 
<p><a target="_blank" href="http://baike.baidu.com/view/1028553.htm#4" rel="nofollow noopener noreferrer"><span style="color:#136EC2">返回值</span></a></p> 
<p><a target="_blank" href="http://baike.baidu.com/view/1028553.htm#5" rel="nofollow noopener noreferrer"><span style="color:#136EC2">使用</span></a></p> 
<p><a target="_blank" href="http://baike.baidu.com/view/1028553.htm#6" rel="nofollow noopener noreferrer"><span style="color:#136EC2">其他相关信息</span></a></p> 
<p style="background:#FAFAFA"><span style="color:#136EC2">展开</span></p> 
<div> 
 <p><a target="_blank" href="http://baike.baidu.com/view/1028553.htm#1" rel="nofollow noopener noreferrer"><span style="color:#136EC2">原型</span></a></p> 
 <p><a target="_blank" href="http://baike.baidu.com/view/1028553.htm#2" rel="nofollow noopener noreferrer"><span style="color:#136EC2">功能</span></a></p> 
 <p><a target="_blank" href="http://baike.baidu.com/view/1028553.htm#3" rel="nofollow noopener noreferrer"><span style="color:#136EC2">说明</span></a></p> 
 <p><a target="_blank" href="http://baike.baidu.com/view/1028553.htm#4" rel="nofollow noopener noreferrer"><span style="color:#136EC2">返回值</span></a></p> 
 <p><a target="_blank" href="http://baike.baidu.com/view/1028553.htm#5" rel="nofollow noopener noreferrer"><span style="color:#136EC2">使用</span></a></p> 
 <p><a target="_blank" href="http://baike.baidu.com/view/1028553.htm#6" rel="nofollow noopener noreferrer"><span style="color:#136EC2">其他相关信息</span></a></p> 
 <p style="background:#FAFAFA"><span style="color:#136EC2">展开</span></p> 
</div> 
<h4><a target="_blank" name="_Toc376251210"></a><a target="_blank" name="_Toc369176389"><span style="color:#3366CC">编辑本段</span></a><a target="_blank" name="1"></a><a target="_blank" name="sub1028553_1"></a>原型</h4> 
<p>char *strtok(char s[], const char *delim);</p> 
<h4><span style="color:#3366CC"><a target="_blank" href="http://baike.baidu.com/view/1028553.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">编辑本段</span></a></span><a target="_blank" name="_Toc369176390"></a><a target="_blank" name="_Toc376251211"></a><a target="_blank" name="2"></a><a target="_blank" name="sub1028553_2"></a>功能</h4> 
<p>分解字符串为一组字符串。s为要分解的字符串，delim为<a target="_blank" href="http://baike.baidu.com/view/1268377.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">分隔符</span></a>字符串。</p> 
<p>例如：strtok("abc,def,ghi",",")，最后可以分割成为abc defghi.尤其在点分十进制的IP中提取应用较多。</p> 
<h3><span style="color:#3366CC"><a target="_blank" href="http://baike.baidu.com/view/1028553.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">编辑本段</span></a></span><a target="_blank" name="_Toc369176391"></a><a target="_blank" name="_Toc376251212"></a><a target="_blank" name="3"></a><a target="_blank" name="sub1028553_3"></a>说明</h3> 
<p>strtok()用来将字符串分割成一个个片段。参数s指向欲分割的<a target="_blank" href="http://baike.baidu.com/view/263416.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">字符</span></a>串，参数delim则为分割字符串中包含的所有字符。当strtok()在参数s的字符串中发现参数delim中包涵的分割字符时,则会将该字符改为\0 字符。在第一次调用时，strtok()必需给予参数s字符串，往后的调用则将参数s设置成NULL。每次调用成功则返回指向被分割出片段的<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">指针</span></a>。</p> 
<h4><span style="color:#3366CC"><a target="_blank" href="http://baike.baidu.com/view/1028553.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">编辑本段</span></a></span><a target="_blank" name="_Toc369176392"></a><a target="_blank" name="_Toc376251213"></a><a target="_blank" name="4"></a><a target="_blank" name="sub1028553_4"></a>返回值</h4> 
<p>从s开头开始的一个个被分割的串。当没有被分割的串时则返回NULL。</p> 
<p>所有delim中包含的字符都会被滤掉，并将被滤掉的地方设为一处分割的节点。</p> 
<h4><span style="color:#3366CC"><a target="_blank" href="http://baike.baidu.com/view/1028553.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">编辑本段</span></a></span><a target="_blank" name="_Toc369176393"></a><a target="_blank" name="_Toc376251214"></a><a target="_blank" name="5"></a><a target="_blank" name="sub1028553_5"></a>使用</h4> 
<p>strtok函数会破坏被分解字符串的完整，调用前和调用后的s已经不一样了。如果</p> 
<p>要保持原字符串的完整，可以使用strchr和sscanf的组合等。</p> 
<h3><a target="_blank" name="_Toc376251215"></a><a target="_blank" name="_Toc369176394">strncmp</a>用法</h3> 
<p>函数名:strncmp</p> 
<p>功 能: 串比较</p> 
<p>用 法: intstrncmp(char *str1, char *str2, int maxlen);</p> 
<p>说明:此函数功能即比较<a target="_blank" href="http://baike.baidu.com/view/263416.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">字符</span></a>串str1和str2的前maxlen个字符。如果前maxlen<a target="_blank" href="http://baike.baidu.com/view/60408.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">字节</span></a>完全相等，返回值就=0；在前maxlen字节比较过程中，如果出现str1[n]与str2[n]不等，则返回（str1[n]-str2[n]）。</p> 
<h3><a target="_blank" name="_Toc376251216"></a><a target="_blank" name="_Toc369176395">fwrite</a></h3> 
<div> 
 <p><strong>目录</strong></p> 
</div> 
<p><a target="_blank" href="http://baike.baidu.com/view/656700.htm#1" rel="nofollow noopener noreferrer"><span style="color:#136EC2">函数名</span></a></p> 
<p><a target="_blank" href="http://baike.baidu.com/view/656700.htm#2" rel="nofollow noopener noreferrer"><span style="color:#136EC2">功能</span></a></p> 
<p><a target="_blank" href="http://baike.baidu.com/view/656700.htm#3" rel="nofollow noopener noreferrer"><span style="color:#136EC2">用法</span></a></p> 
<p><a target="_blank" href="http://baike.baidu.com/view/656700.htm#4" rel="nofollow noopener noreferrer"><span style="color:#136EC2">程序示例</span></a></p> 
<h4><span style="color:#3366CC"><a target="_blank" href="http://baike.baidu.com/view/656700.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">编辑本段</span></a></span><a target="_blank" name="_Toc369176396"></a><a target="_blank" name="_Toc376251217"></a><a target="_blank" name="sub656700_1"></a>函数名</h4> 
<p>fwrite</p> 
<h4><span style="color:#3366CC"><a target="_blank" href="http://baike.baidu.com/view/656700.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">编辑本段</span></a></span><a target="_blank" name="_Toc369176397"></a><a target="_blank" name="_Toc376251218"></a><a target="_blank" name="sub656700_2"></a>功能</h4> 
<p><a target="_blank" href="http://baike.baidu.com/view/1219.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">C</span><span style="color:#136EC2">语言</span></a>函数，向文件写入一个数据块</p> 
<h4><span style="color:#3366CC"><a target="_blank" href="http://baike.baidu.com/view/656700.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">编辑本段</span></a></span><a target="_blank" name="_Toc369176398"></a><a target="_blank" name="_Toc376251219"></a><a target="_blank" name="sub656700_3"></a>用法</h4> 
<p>size_t fwrite(const void* buffer, size_t size, size_t count, FILE*stream);</p> 
<p>注意：这个函数以二进制形式对文件进行操作，不局限于文本文件</p> 
<p>返回值：返回实际写入的<a target="_blank" href="http://baike.baidu.com/view/702806.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">数据块</span></a>数目</p> 
<p>（1）buffer：是一个<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">指针</span></a>，对fwrite来说，是要输出数据的地址；</p> 
<p>（2）size：要写入内容的单字节数；</p> 
<p>（3）count:要进行写入size字节的<a target="_blank" href="http://baike.baidu.com/view/178581.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">数据项</span></a>的个数；</p> 
<p>（4）stream:目标<a target="_blank" href="http://baike.baidu.com/view/5019859.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件指针</span></a>；</p> 
<p>（5）<span style="color:red">返回实际写入的数据项个数</span><span style="color:red">count</span><span style="color:red">。</span></p> 
<p>说明：写入到文件的哪里？ 这个与文件的打开模式有关，如果是w+，则是从filepointer指向的地址开始写，替换掉之后的内容，文件的长度可以不变，stream的位置移动count个数；如果是a+，则从文件的末尾开始添加，文件长度加大。</p> 
<p>fseek对此函数有作用，但是fwrite<sup><span style="color:#3366CC">[1]</span></sup><a target="_blank" name="ref_%5B1%5D_656700"></a>函数写到用户空间缓冲区，并未同步到文件中，所以修改后要将内存与文件同步可以用fflush（FILE *fp）函数同步。</p> 
<h4><span style="color:#3366CC"><a target="_blank" href="http://baike.baidu.com/view/656700.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">编辑本段</span></a></span><a target="_blank" name="_Toc369176399"></a><a target="_blank" name="_Toc376251220"></a><a target="_blank" name="sub656700_4"></a>程序示例</h4> 
<p><strong>示例一：</strong></p> 
<p>#include &lt;stdio.h&gt;</p> 
<p>struct mystruct</p> 
<p>{<!-- --></p> 
<p>int i;</p> 
<p>char ch;</p> 
<p>};</p> 
<p>int main(void)</p> 
<p>{<!-- --></p> 
<p>FILE *stream;</p> 
<p>struct mystruct s;</p> 
<p>if ((stream = fopen("TEST.$$$", "wb")) ==NULL) /* open file TEST.$$$ */</p> 
<p>{<!-- --></p> 
<p>fprintf(stderr, "Cannot open output file.\n");</p> 
<p>return 1;</p> 
<p>}</p> 
<p>s.i = 0;</p> 
<p>s.ch = 'A';</p> 
<p>fwrite(&amp;s, sizeof(s), 1, stream); /* 写的struct文件*/</p> 
<p>fclose(stream); /*关闭文件*/</p> 
<p>return 0;</p> 
<p>}</p> 
<p><strong>示例二：</strong></p> 
<p>#include&lt;stdio.h&gt;</p> 
<p>#define SIZE 1</p> 
<p>typedef struct</p> 
<p>{<!-- --></p> 
<p>char name[10];</p> 
<p>int num;</p> 
<p>int age;</p> 
<p>char addr[15];</p> 
<p>}student;</p> 
<p>student stu[SIZE];</p> 
<p>void save()</p> 
<p>{<!-- --></p> 
<p>FILE *fp;</p> 
<p>int i;</p> 
<p>if((fp=fopen("dat.txt","w"))==NULL)</p> 
<p>{<!-- --></p> 
<p>printf("无法打开此文件!\n");</p> 
<p>return;</p> 
<p>}</p> 
<p>for(i=0;i&lt;SIZE;i++)</p> 
<p>if(fwrite(&amp;stu[i], sizeof(student), 1, fp) != 1)</p> 
<p>printf("文件写入错误。!\n");</p> 
<p>fclose(fp);</p> 
<p>}</p> 
<p>void main()</p> 
<p>{<!-- --></p> 
<p>int i;</p> 
<p>for(i=0;i&lt;SIZE;i++)</p> 
<p>scanf("%s%d%d%s",&amp;stu[i].name,&amp;stu[i].num,&amp;stu[i].age,&amp;stu[i].addr);</p> 
<p>save();</p> 
<p>}</p> 
<p><strong>示例三：</strong></p> 
<p>/* fwrite example : write buffer */</p> 
<p>#include &lt;stdio.h&gt;</p> 
<p>int main ()</p> 
<p>{<!-- --></p> 
<p>FILE * pFile;</p> 
<p>char buffer[] = { 'x' , 'y' , 'z' };</p> 
<p>pFile = fopen ( "myfile.bin" , "wb" );</p> 
<p>fwrite (buffer , sizeof(buffer), 1 , pFile );</p> 
<p>fclose (pFile);</p> 
<p>return 0;</p> 
<p>}</p> 
<p>//称为myfile.bin的一个文件被创建并存储到它的缓冲区的内容。为了简单起见，该缓冲区包含Char元素，但它可以包含任何其他类型。.</p> 
<p>sizeof(buffer)<a target="_blank" href="http://baike.baidu.com/view/8420446.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">字节数组</span></a>的长度(在这种情况下，它是三个，因为数组有三个元素，每次一个字节)。</p> 
<p><strong>示例四：</strong></p> 
<p>//程序示例fwrite fread fseek</p> 
<p>FILE *fp;</p> 
<p>char msg[] = "file content";</p> 
<p>char buf[20];</p> 
<p>fp = fopen("d:\\a\\a.txt","w+");</p> 
<p>if (NULL == fp)</p> 
<p>{<!-- --></p> 
<p>printf("The file doesn't exist!\n");</p> 
<p>return -1;</p> 
<p>}</p> 
<p>fwrite(msg,strlen(msg),1,fp);//把字符串内容写入到文件</p> 
<p>fseek(fp,0,SEEK_SET);//定位文件指针到文件开始位置</p> 
<p>fread(buf,strlen(msg),1,fp);//把文件内容读入到缓存</p> 
<p>buf[strlen(msg)] = '\0';//删除缓存内多余的空间</p> 
<p>printf("buf = %s\n",buf);</p> 
<p>printf("strlen(buf) = %d\n",strlen(buf));</p> 
<h3><a target="_blank" name="_Toc376251221"></a><a target="_blank" name="_Toc369176400">#pragma pack</a></h3> 
<div> 
 <p><strong>目录</strong></p> 
</div> 
<p><a target="_blank" href="http://baike.baidu.com/view/2317161.htm#1" rel="nofollow noopener noreferrer"><span style="color:#136EC2">对齐方式</span></a></p> 
<p><a target="_blank" href="http://baike.baidu.com/view/2317161.htm#2" rel="nofollow noopener noreferrer"><span style="color:#136EC2">对齐用法详解</span></a></p> 
<h4><span style="color:#3366CC"><a target="_blank" href="http://baike.baidu.com/view/2317161.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">编辑本段</span></a></span><a target="_blank" name="_Toc369176401"></a><a target="_blank" name="_Toc376251222"></a><a target="_blank" name="sub2317161_1"></a>对齐方式</h4> 
<p>程序编译器对结构的存储的特殊处理确实提高CPU存储<a target="_blank" href="http://baike.baidu.com/view/296689.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">变量</span></a>的速度，但是有时候也带来了一些麻烦，我们也屏蔽掉变量默认的对齐方式，自己可以设定变量的对齐方式。</p> 
<p>编译器中提供了<a target="_blank" href="http://baike.baidu.com/view/1451188.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">#pragma</span></a> pack(n)来设定<a target="_blank" href="http://baike.baidu.com/view/296689.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">变量</span></a>以n<a target="_blank" href="http://baike.baidu.com/view/1523557.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">字节对齐</span></a>方式。n<a target="_blank" href="http://baike.baidu.com/view/1523557.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">字节对齐</span></a>就是说<a target="_blank" href="http://baike.baidu.com/view/296689.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">变量</span></a>存放的起始地址的<a target="_blank" href="http://baike.baidu.com/view/1254177.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">偏移量</span></a>有两种情况：第一、如果n大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式，第二、如果n小于该变量的类型所占用的字节数，那么偏移量为n的倍数，不用满足默认的对齐方式。结构的总大小也有个约束条件，分下面两种情况：如果n大于所有<a target="_blank" href="http://baike.baidu.com/view/684821.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">成员变量</span></a>类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数；否则必须为n的倍数。</p> 
<p>下面举例说明其用法。</p> 
<p><a target="_blank" href="http://baike.baidu.com/view/1451188.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">#pragma</span></a> pack(push) //保存对齐状态</p> 
<p><a target="_blank" href="http://baike.baidu.com/view/1451188.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">#pragma</span></a> pack(4)//设定为4<a target="_blank" href="http://baike.baidu.com/view/1523557.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">字节对齐</span></a></p> 
<p>struct test</p> 
<p>{<!-- --></p> 
<p>char m1;</p> 
<p>double m4;</p> 
<p>int m3;</p> 
<p>};</p> 
<p><a target="_blank" href="http://baike.baidu.com/view/1451188.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">#pragma</span></a> pack(pop)//恢复对齐状态</p> 
<p>以上<a target="_blank" href="http://baike.baidu.com/view/204974.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">结构体</span></a>的大小为16，下面分析其存储情况，首先为m1分配空间，其<a target="_blank" href="http://baike.baidu.com/view/1254177.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">偏移量</span></a>为0，满足我们自己设定的对齐方式（4<a target="_blank" href="http://baike.baidu.com/view/1523557.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">字节对齐</span></a>），m1大小为1个字节。接着开始为m4分配空间，这时其<a target="_blank" href="http://baike.baidu.com/view/1254177.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">偏移量</span></a>为4，需要补足3个字节，这样使偏移量满足为n=4的倍数（因为sizeof(double)大于4）,m4占用8个字节。接着为m3分配空间，这时其<a target="_blank" href="http://baike.baidu.com/view/1254177.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">偏移量</span></a>为12，满足为4的倍数，m3占用4个字节。这时已经为所有<a target="_blank" href="http://baike.baidu.com/view/684821.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">成员变量</span></a>分配了空间，共分配了16个字节，满足为n的倍数。如果把上面的<a target="_blank" href="http://baike.baidu.com/view/1451188.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">#pragma</span></a> pack(4)改为<a target="_blank" href="http://baike.baidu.com/view/1451188.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">#pragma</span></a> pack(8)，那么我们可以得到结构的大小为24。</p> 
<h3><a target="_blank" name="_Toc376251223"></a><a target="_blank" name="_Toc369176402"><span style="color:#3A3A3A">gcc </span></a><span style="color:#3A3A3A">错误搜集</span><span style="color:#3A3A3A">1</span></h3> 
<p><span style="color:#454545">以下错误，都是在别的编译编译正确，而在</span><span style="color:#454545">GCC</span><span style="color:#454545">的错误。</span><span style="color:#454545">dev c++</span></p> 
<p><span style="color:#454545">错误提示：</span><span style="color:#454545">48 D:\××.c [Warning] malformed'#pragma pack(push[, id], &lt;n&gt;)' - ignored</span></p> 
<p><span style="color:#454545">#pragma pack(push)<br> #pragma pack(1)</span></p> 
<p><span style="color:#454545">struct tagPhysStruct<br> {<!-- --><br>  *****</span></p> 
<p><span style="color:#454545">#pragma pack(pop)</span></p> 
<p><span style="color:#454545">修改</span><span style="color:#454545">开头两行合并为一行。</span><span style="color:#454545">#pragmapack(push</span><span style="color:#454545">，</span><span style="color:#454545">1)</span></p> 
<h3><a target="_blank" name="_Toc376251224"></a><a target="_blank" name="_Toc369176403"><span style="color:#3A3A3A">如何解决</span></a><span style="color:#3A3A3A">warning: no newline at end of file?</span></h3> 
<p><span style="color:#454545">今天写了一段代码</span><span style="color:#454545">, </span> <span style="color:#454545">是在</span><span style="color:#454545">Windows</span><span style="color:#454545">下编辑的</span><span style="color:#454545">, </span><span style="color:#454545">保存后放在</span><span style="color:#454545">linux</span><span style="color:#454545">系统下编译</span><span style="color:#454545">.</span></p> 
<p><span style="color:#454545">gcc</span><span style="color:#454545">和</span><span style="color:#454545">cc</span><span style="color:#454545">都产生以下的警告</span><span style="color:#454545">:<br> a.h:1:2: warning: no newline at end of file</span></p> 
<p><span style="color:#454545">后来发现解决这个问题产生的原因是源文件的最后一行没有回车符造成的</span><span style="color:#454545">; </span><span style="color:#454545">解决的办法很简单</span><span style="color:#454545">, </span> <span style="color:#454545">在最后一行敲一个回车</span><span style="color:#454545">, </span> <span style="color:#454545">然后保存</span><span style="color:#454545">, </span><span style="color:#454545">重新编译</span><span style="color:#454545">.</span></p> 
<h3><a target="_blank" name="_Toc376251225"></a><a target="_blank" name="_Toc369176404">结构体初始化赋值={0}</a>，GCC打开-Wall选项编译会警告，大家探讨一下</h3> 
<p><span style="color:#666666">比如结构体的第一个成员变量是数组或者嵌套的小结构体，</span><span style="color:#666666">linux</span><span style="color:#666666">下编译时</span><span style="color:#666666">gcc</span><span style="color:#666666">打开</span><span style="color:#666666">-Wall</span><span style="color:#666666">选项时会报告警类似如下：</span><span style="color:#666666"><br> <br> </span><span style="color:#666666">警告：‘</span><span style="color:#666666">char [100]</span><span style="color:#666666">’</span><span style="color:#666666">的初始值设定周围缺少花括号</span><span style="color:#666666"><br> </span><span style="color:#666666">警告：‘</span><span style="color:#666666">struct_a_s</span><span style="color:#666666">’</span><span style="color:#666666">的初始值设定周围缺少花括号</span><span style="color:#666666"><br> <br> </span><span style="color:#666666">因为本来数组或者结构体就得使用</span><span style="color:#666666">{}</span><span style="color:#666666">赋值，但是被嵌套了以后应该使用</span><span style="color:#666666">={<!-- -->{<!-- --></span><span style="color:#666666">第一个成员变量的指定初始化值</span><span style="color:#666666">}</span><span style="color:#666666">，第二个成员变量的指定初始化值</span><span style="color:#666666">}</span><span style="color:#666666">来初始化。故而报警了。</span><span style="color:#666666"><br> </span><span style="color:#666666">基于此，我分析有两种情况：</span><span style="color:#666666"><br> </span><span style="color:#666666">一、指定初始化只是第一个成员变量的第一个值，比如数组的第一个值，或者嵌套的小结构体的第一个成员变量的值被指定初始化为</span><span style="color:#666666">0</span><span style="color:#666666">，其他未指定的值根据</span><span style="color:#666666">gcc</span><span style="color:#666666">的编译器来初始化，但是在</span><span style="color:#666666">gcc</span><span style="color:#666666">下</span><span style="color:#666666">gdb</span><span style="color:#666666">走读代码发现并不符合“静态区初始化为</span><span style="color:#666666">0</span><span style="color:#666666">，动态区随机”规则，而是未指定的都初始化为</span><span style="color:#666666">0</span><span style="color:#666666">；</span><span style="color:#666666"><br> </span><span style="color:#666666">二、指定初始化只是第一个成员变量的值。</span></p> 
<h3><a target="_blank" name="_Toc376251226"></a><a target="_blank" name="_Toc369176405">windows </a>如何查看端口占用情况?</h3> 
<p style="background:#EFEFEF">开始--运行--cmd进入命令提示符 输入netstat-ano 即可看到所有连接的PID 之后在任务管理器中找到这个PID所对应的程序如果任务管理器中<strong>没有PID</strong>这一项,可以在任务管理器中选"查看"-"选择列" <br> <br>         经常，我们在启动应用的时候发现系统需要的端口被别的程序占用，如何知道谁占有了我们需要的端口，很多人都比较头疼，下面就介绍一种非常简单的方法，希望对大家有用 <br> <br> 假如我们需要确定谁占用了我们的9050端口 <br> <br> 1、Windows平台 <br> 在windows命令行窗口下执行： <br> 1.查看所有的端口占用情况</p> 
<p style="background:#EFEFEF">C:\&gt;<strong>netstat -ano</strong></p> 
<p style="background:#EFEFEF">  协议    本地地址                    外部地址              状态                  PID</p> 
<p style="background:#EFEFEF">  TCP   127.0.0.1:1434         0.0.0.0:0             LISTENING       3236<br>   TCP   127.0.0.1:5679        0.0.0.0:0             LISTENING       4168<br>   TCP   127.0.0.1:7438        0.0.0.0:0             LISTENING       4168<br>   TCP   127.0.0.1:8015        0.0.0.0:0             LISTENING       1456<br>   TCP    192.168.3.230:139     0.0.0.0:0             LISTENING       4<br>   TCP    192.168.3.230:1957    220.181.31.225:443     ESTABLISHED    3068<br>   TCP    192.168.3.230:2020    183.62.96.189:1522     ESTABLISHED    1456<br>   TCP    192.168.3.230:2927    117.79.91.18:80       ESTABLISHED     4732<br>   TCP    192.168.3.230:2929    117.79.91.18:80       ESTABLISHED     4732<br>   TCP    192.168.3.230:2930     117.79.91.18:80       ESTABLISHED     4732<br>   TCP    192.168.3.230:2931    117.79.91.18:80       ESTABLISHED     4732</p> 
<p style="background:#EFEFEF"> </p> 
<p style="background:#EFEFEF">2.查看指定端口的占用情况<br> C:\&gt;<strong>netstat -aon|findstr "9050"</strong></p> 
<p style="background:#EFEFEF">  协议    本地地址                    外部地址              状态                  PID</p> 
<p style="background:#EFEFEF">  TCP    127.0.0.1:9050        0.0.0.0:0             LISTENING       2016</p> 
<p style="background:#EFEFEF">P: 看到了吗，端口被进程号为2016的进程占用，继续执行下面命令： （也可以去任务管理器中查看pid对应的进程）</p> 
<p style="background:#EFEFEF">3.查看PID对应的进程<br> C:\&gt;<strong>tasklist|findstr "2016"</strong></p> 
<p style="background:#EFEFEF"> 映像名称                      PID 会话名             会话#      内存使用<br>  ========================= ======== ================<br>  tor.exe                    2016Console                0     16,064 K <br> <br> P:很清楚吧，tor占用了你的端口。</p> 
<p style="background:#EFEFEF"> </p> 
<p style="background:#EFEFEF">4.结束该进程</p> 
<p style="background:#EFEFEF">C:\&gt;<strong>taskkill /f /t /im tor.exe</strong></p> 
<h3><a target="_blank" name="_Toc376251227"></a><a target="_blank" name="_Toc369176406">memmove</a>、memcpy和memccpy简介</h3> 
<p>memmove、memcpy和memccpy三个函数都是内存的拷贝，从一个缓冲区拷贝到另一个缓冲区。<br> memmove(void *dest,void*src,int count)<br> memcpy(void *dest,void *src,int count)<br> memccpy(void*dest,void*src,int ch,int count)<br> <br> 表头文件: #include &lt;string.h&gt;<br> 定义函数: void *memcpy(void *dest, const void *src, size_t n)<br> 函数说明: memcpy()用来拷贝src所指的内存内容前n个字节到dest所指的内存地址上。与strcpy()不同的是,memcpy()会完整的复制n个字节,不会因为遇到字符串结束'\0'而结束<br> 返回值:   返回指向dest的指针<br> <br> 表头文件: #include &lt;string.h&gt;<br> 定义函数: void *memccpy(void *dest, const void *src, int c, size_tn);<br> 函数说明: memccpy()用来拷贝src所指的内存内容前n个字节到dest所指的地址上。与memcpy()不同的是,memccpy()如果在src中遇到某个特定值(int c)立即停止复制。<br> 返回值:   返回指向dest中值为c的下一个字节指针。返回值为0表示在src所指内存前n个字节中没有值为c的字节。<br> <br> 表头文件: #include &lt;string.h&gt;<br> 定义函数: void *memmove(void *dest, const void *src, size_t n);<br> 函数说明:memmove()是从一个缓冲区移动到另一个缓冲区中。 <br> 返回值:   返回指向dest指针。<br> <br> 当dest &lt;= src-count 或dest&gt;= src+count时，以上三个函数均不会产生覆盖问题，即源数据不会被更改。<br> 若不在以上范围内，则源数据会被更改。<br> <br> 如:<br> char a[]={'a','b'};<br> char b[]={'c','d','e','f','g','h'};<br> memmove(a,b,sizeof(b));<br> 或是直接char *p=b+2;memmove(p,b,sizeof(b));<br> 输出数据会发现b中数据输出已被更改。<br> 发现即使a数组指向的空间不够存储数据，也能够移动成功。<br> 原因|dest - src |&lt;count<br> <br> 如果在使用这些函数时，分配给足够的空间，然后再使用就不会出现覆盖问题。也就是说如果外部分配给的空间不足以存储要拷贝的数据时，就有可能出现源数据被覆盖更改的问题。<br> <br> #include &lt;stdio.h&gt;<br> #include &lt;stdlib.h&gt;<br> #include &lt;string.h&gt;<br> <br> void main(void)<br> {<!-- --><br>  int i=0; <br>     chara[9]={'a','b','c','d','e','f','g','h','\0'};<br>  char p[2]={'q','w'};//或char *p=a+2;<br>  memmove(p,a,sizeof(a));<br>     puts(a);<br>  printf("_____________________________________________\n");<br>  puts(p);<br>  printf("_____________________________________________\n");<br>   for(i =0;i&lt;10;i++)<br>    printf("%c %d\n",*(a+i),a+i);<br>  printf("_____________________________________________\n");<br>  for(i =0;i&lt;8;i++)<br>    printf("%c %d\n",*(p+i),p+i); <br> }<br> 观察输出结果。<br> 把memmove(p,a,sizeof(a));改为memcpy(p,a,sizeof(a));或memccpy(p,a,'e',sizeof(a));再观察输出结果。<br> 可以看出在目的存储空间不足时，便会出现源数据被覆盖改变的问题。<br> 如果目的存储空间分配足够的空间，则便不会出现覆盖问题。</p> 
<h3><a target="_blank" name="_Toc376251228"></a><a target="_blank" name="_Toc369176407">流控制</a></h3> 
<p>串口的流控是指数据流。数据在两个串口之间传输时，常常会出现丢失数据的现象，或者两台计算机的处理速度不同，如<a target="_blank" href="http://baike.baidu.com/view/1437416.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">台式机</span></a>与单片机之间的通信，接收端<a target="_blank" href="http://baike.baidu.com/view/1503706.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">数据缓冲区</span></a>已满，则此时继续发送来的数据就会丢失。当接收端数据处理不过来时，就发出"不再接收"的信号，发送端就停止发送，直到收到“可以继续发送”的信号再发送数据。PC机中常用的两种流控制分别是硬件流控制（包括RTS/CTS、DTR/DSR等）和软件流控制<a target="_blank" href="http://baike.baidu.com/view/1161414.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">XON/XOFF</span></a>。</p> 
<p>基于OSI七层模型的流控制的类型包括：Buffering（<a target="_blank" href="http://baike.baidu.com/view/907.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">缓存</span></a>）、Window（基于窗口）、Congestionavoidance（冲突避免）。</p> 
<p>2.硬件流控制</p> 
<p>硬件流控制常用的有RTS/CTS流控制和DTR/DSR（数据终端就绪/数据设置就绪）流控制。</p> 
<p>硬件流控制必须将相应的电缆线连上，用RTS/CTS（请求发送/<a target="_blank" href="http://baike.baidu.com/view/7026396.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">清除发送</span></a>）流控制时，应将通讯两端的RTS、CTS线对应相连，<a target="_blank" href="http://baike.baidu.com/view/543316.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">数据终端设备</span></a>（如计算机）使用RTS来起始<a target="_blank" href="http://baike.baidu.com/view/1074.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">调制解调器</span></a>或其它数据通讯设备的数据流，而数据通讯设备（如调制解调器）则用CTS来起动和暂停来自计算机的数据流。这种硬件握手方式的过程为：我们在<a target="_blank" href="http://baike.baidu.com/view/3281.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">编程</span></a>时根据接收端缓冲区大小设置一个高位标志（可为缓冲区大小的75%）和一个低位标志（可为缓冲区大小的25%），当缓冲区内数据量达到高位时，我们在接收端将CTS线置低电平（送逻辑0），当发送端的程序检测到CTS为低后，就停止发送数据，直到接收端缓冲区的数据量低于低位而将CTS置高电平。RTS则用来标明接收设备有没有准备好接收数据。</p> 
<p>常用的流控制还有还有DTR/DSR（数据终端就绪/数据设置就绪）。我们在此不再详述。</p> 
<p>3.软件流控制</p> 
<p>由于电缆线的限制，我们在普通的控制通讯中一般不用硬件流控制，而用软件流控制。一般通过XON/XOFF来实现软件流控制。常用方法是：当接收端的输入缓冲区内数据量超过设定的高位时，就向数据发送端发出XOFF字符（十进制的19或Control-S，设备编程说明书应该有详细阐述），发送端收到XOFF字符后就立即停止发送数据；当接收端的输入缓冲区内数据量低于设定的低位时，就向数据发送端发出XON字符（十进制的17或Control-Q），发送端收到XON字符后就立即开始发送数据。一般可以从设备配套源程序中找到发送的是什么字符。</p> 
<p>应该注意，若传输的是二进制数据，标志字符也有可能在<a target="_blank" href="http://baike.baidu.com/view/166248.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">数据流</span></a>中出现而引起误操作，这是软件流控制的缺陷，而硬件流控制不会有这个问题。</p> 
<h3><a target="_blank" name="_Toc376251229"></a><a target="_blank" name="_Toc369176408">字符串操作函数</a></h3> 
<p> </p> 
<table border="0" cellspacing="0" cellpadding="0" width="628"><tbody><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/175.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strtok()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">字符串分割函数</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/174.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strstr()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">字符串查找函数</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/173.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strspn()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">字符查找函数</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/172.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strrchr()</span></a></p> </td><td> <p align="left"><span style="color:#333333">定位字符串中最后出现的指定字符</span></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/171.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strpbrk()</span></a></p> </td><td> <p align="left"><span style="color:#333333">定位字符串中第一个出现的指定字符</span></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/170.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strncpy()</span></a></p> </td><td> <p align="left"><span style="color:#333333">复制字符串</span></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/169.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strncat()</span></a></p> </td><td> <p align="left"><span style="color:#333333">字符串连接函数</span></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/168.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strncasecmp()</span></a></p> </td><td> <p align="left"><span style="color:#333333">字符串比较函数</span><span style="color:#333333">(</span><span style="color:#333333">忽略大小写</span><span style="color:#333333">)</span></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/167.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strlen()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">字符串长度计算函数</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/166.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strdup()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">复制字符串</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/165.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strcspn()</span></a></p> </td><td> <p align="left"><span style="color:#333333">查找字符串</span></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/164.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strcpy()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">复制字符串</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/163.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strcoll()</span></a></p> </td><td> <p align="left"><span style="color:#333333">字符串比较函数</span><span style="color:#333333">(</span><span style="color:#333333">按字符排列次序</span><span style="color:#333333">)</span></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/162.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strcmp()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">字符串比较函数</span><span style="color:#333333">(</span><span style="color:#333333">比较字符串</span><span style="color:#333333">)</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/161.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strchr()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">字符串查找函数</span><span style="color:#333333">(</span><span style="color:#333333">返回首次出现字符的位置</span><span style="color:#333333">)</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/160.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strcat()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">连接字符串</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/159.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strcasecmp()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">字符串比较函数</span><span style="color:#333333">(</span><span style="color:#333333">忽略大小写比较字符串</span><span style="color:#333333">)</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/158.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">rindex()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">字符串查找函数</span><span style="color:#333333">(</span><span style="color:#333333">返回最后一次出现的位置</span><span style="color:#333333">)</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/151.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">index()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">字符串查找函数</span><span style="color:#333333">(</span><span style="color:#333333">返回首次出现的位置</span><span style="color:#333333">)</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/133.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">toupper()</span></a></p> </td><td> <p align="left"><span style="color:#333333">字符串转换函数</span><span style="color:#333333">(</span><span style="color:#333333">小写转大写</span><span style="color:#333333">)</span></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/132.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">tolower()</span></a></p> </td><td> <p align="left"><span style="color:#333333">字符串转换函数</span><span style="color:#333333">(</span><span style="color:#333333">大写转小写</span><span style="color:#333333">)</span></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/131.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">toascii()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">将整数转换成合法的</span><span style="color:#333333">ASCII</span><span style="color:#333333">码字符</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/130.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strtoul()</span></a></p> </td><td> <p align="left"><span style="color:#333333">将字符串转换成无符号长整型数</span></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/129.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strtol()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">将字符串转换成长整型数</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/128.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">strtod()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">将字符串转换成浮点数</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/127.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">gcvt()</span></a></p> </td><td> <p align="left"><span style="color:#333333">将浮点型数转换为字符串</span><span style="color:#333333">(</span><span style="color:#333333">四舍五入</span><span style="color:#333333">)</span></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/126.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">atol()</span></a></p> </td><td> <p align="left"><span style="color:#333333">将字符串转换成长整型数</span></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/125.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">atoi()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">将字符串转换成整型数</span></strong></p> </td></tr><tr><td> <p align="left"><a target="_blank" href="http://see.xidian.edu.cn/cpp/html/124.html" rel="nofollow noopener noreferrer"><span style="color:#0066FF">atof()</span></a></p> </td><td> <p align="left"><strong><span style="color:#333333">将字符串转换成浮点型数</span></strong></p> </td></tr><tr><td colspan="2"> <p align="left"> </p> </td></tr></tbody></table> 
<p> </p> 
<h3><a target="_blank" name="_Toc376251230"></a><a target="_blank" name="_Toc369176409">使用pthread_mutex_t</a>锁的例子</h3> 
<p>linux下为了多线程同步，通常用到锁的概念。<br> posix下抽象了一个锁类型的结构：ptread_mutex_t。通过对该结构的操作，来判断资源是否可以访问。顾名思义，加锁(lock)后，别人就无法打开，只有当锁没有关闭(unlock)的时候才能访问资源。<br> 它主要用如下5个函数进行操作。<br> 1：pthread_mutex_init(pthread_mutex_t * mutex,constpthread_mutexattr_t *attr);<br> 初始化锁变量mutex。attr为锁属性，NULL值为默认属性。<br> 2：pthread_mutex_lock(pthread_mutex_t *mutex);加锁<br> 3：pthread_mutex_tylock(pthread_mutex_t *mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。<br> <br> 4：pthread_mutex_unlock(pthread_mutex_t *mutex);释放锁<br> 5：pthread_mutex_destroy(pthread_mutex_t *mutex);使用完后释放<br> <br> 下面经典例子为创建两个线程对sum从1加到100。前面第一个线程从1－49，后面从50－100。主线程读取最后的加值。为了防止资源竞争，用了pthread_mutex_t 锁操作。<br> #include&lt;stdlib.h&gt;<br> #include&lt;stdio.h&gt;<br> #include&lt;unistd.h&gt;<br> #include&lt;pthread.h&gt;<br> typedef struct ct_sum<br> { int sum;<br>   pthread_mutex_t lock;<br> }ct_sum;<br> void * add1(void * cnt)<br> {     <br>    <br>     pthread_mutex_lock(&amp;(((ct_sum*)cnt)-&gt;lock));<br>     int i;<br>         for( i=0;i&lt;50;i++)<br>         {(*(ct_sum*)cnt).sum+=i;<br>         <br>         }<br>     pthread_mutex_unlock(&amp;(((ct_sum*)cnt)-&gt;lock));<br>     pthread_exit(NULL);<br>     return 0;<br> }<br> void * add2(void *cnt)<br> {     <br>     int i;<br>     cnt= (ct_sum*)cnt;<br>     pthread_mutex_lock(&amp;(((ct_sum*)cnt)-&gt;lock));<br>     for( i=50;i&lt;101;i++)<br>     {    (*(ct_sum*)cnt).sum+=i;<br>         <br>     }<br>     pthread_mutex_unlock(&amp;(((ct_sum*)cnt)-&gt;lock));<br>     pthread_exit(NULL);<br>     return 0;<br> }<br> <br> <br> int main(void)<br> { int i;<br>   pthread_t ptid1,ptid2;<br>   int sum=0;<br>   ct_sum cnt;<br>   pthread_mutex_init(&amp;(cnt.lock),NULL);<br>   cnt.sum=0;<br> <br>   pthread_create(&amp;ptid1,NULL,add1,&amp;cnt);<br> pthread_create(&amp;ptid2,NULL,add2,&amp;cnt);<br>  <br>  pthread_mutex_lock(&amp;(cnt.lock));<br>  printf("sum %d\n",cnt.sum);<br>  pthread_mutex_unlock(&amp;(cnt.lock));<br> <br>  pthread_join(ptid1,NULL);<br>  pthread_join(ptid2,NULL);<br>   pthread_mutex_destroy(&amp;(cnt.lock));<br>   return 0;<br> }</p> 
<h3><a target="_blank" name="_Toc376251231"></a><a target="_blank" name="_Toc369176410">linux</a>下select 和 poll的用法 </h3> 
<p> </p> 
<p>select()函数的作用 </p> 
<p>系统调用select和poll的后端实现，用这两个系统调用来查询设备是否可读写，或是否处于某种状态。如果poll为空，则驱动设备会被认为即可读又可写，返回值是一个状态掩码 如何使用select()函数? </p> 
<p>select()函数的接口主要是建立在一种叫'fd_set'类型的基础上。它('fd_set') 是一组文件描述符(fd)的集合。由于fd_set类型的长度在不同平台上不同，因此应该用一组标准的宏定义来处理此类变量：   </p> 
<p>fd_set set; </p> 
<p>FD_ZERO(&amp;set); /* 将set清零 */ FD_SET(fd, &amp;set); /* 将fd加入set */ FD_CLR(fd, &amp;set); /* 将fd从set中清除 */ FD_ISSET(fd, &amp;set); /* 如果fd在set中则真 */  </p> 
<p>在过去，一个fd_set通常只能包含少于等于32个文件描述符，因为fd_set其实只用了一个int的比特矢量来实现，在大多数情况下，检查 fd_set能包括任意值的文件描述符是系统的责任，但确定你的fd_set到底能放多少有时你应该检查/修改宏FD_SETSIZE的值。*这个值是系统相关的*，同时检查你的系统中的select() 的man手册。有一些系统对多于1024个文件描述符的支持有问题。[译者注： Linux就是这样的系统！你会发现sizeof(fd_set)的结果是128(*8 = FD_SETSIZE=1024) 尽管很少你会遇到这种情况。]   </p> 
<p>select的基本接口十分简单：   </p> 
<p>int select(int nfds, fd_set *readset, fd_set *writeset, fd_set *exceptset, struct timeval *timeout);  其中：   nfds  </p> 
<p>需要检查的文件描述符个数，数值应该比是三组fd_set中最大数 更大，而不是实际文件描述符的总数。 readset  </p> 
<p>用来检查可读性的一组文件描述符。 writeset </p> 
<p>用来检查可写性的一组文件描述符。 exceptset </p> 
<p>用来检查意外状态的文件描述符。(注：错误并不是意外状态) timeout </p> 
<p>NULL指针代表无限等待，否则是指向timeval结构的指针，代表最 长等待时间。(如果其中tv_sec和tv_usec都等于0, 则文件描述符 的状态不被影响，但函数并不挂起)  </p> 
<p> </p> 
<p> </p> 
<p>Linux快速入门Linux快速入门（...Linux快速入门（...</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>函数将返回响应操作的对应操作文件描述符的总数，且三组数据均在恰当位置被修改，只有响应操作的那一些没有修改。接着应该用FD_ISSET宏来查找返回的文件描述符组。   </p> 
<p>这里是一个简单的测试单个文件描述符可读性的例子：   </p> 
<p>int isready(int fd) { int rc; fd_set fds; struct timeval tv;  </p> 
<p>FD_ZERO(&amp;fds); FD_SET(fd,&amp;fds); </p> 
<p>// tv.tv_sec = tv.tv_usec = 0;  </p> 
<p>//rc = select(fd+1, &amp;fds, NULL, NULL, &amp;tv); rc = select(fd+1, &amp;fds, NULL, NULL, NULL); if (rc &lt; 0) return -1;  </p> 
<p>return FD_ISSET(fd,&amp;fds) ? 1 : 0; }  </p> 
<p>当然如果我们把NULL指针作为fd_set传入的话，这就表示我们对这种操作的发生不感兴趣，但select() 还是会等待直到其发生或者超过等待时间。   </p> 
<p>[译者注：在Linux中，timeout指的是程序在非sleep状态中度过的时间，而不是实际上过去的时间，这就会引起和非Linux平台移植上的时间不等问题。移植问题还包括在System V风格中select()在函数退出前会把timeout设为未定义的 NULL状态，而在BSD中则不是这样， Linux在这点上遵从System V，因此在重复利用timeout指针问题上也应该注意。]  Linux下select调用的过程: </p> 
<p>1.用户层应用程序调用select(),底层调用poll()) 2.核心层调用sys_select() ------&gt; do_select() </p> 
<p>最终调用文件描述符fd对应的struct file类型变量的struct file_operations *f_op的poll函数。 poll指向的函数返回当前可否读写的信息。 1)如果当前可读写，返回读写信息。 </p> 
<p>2)如果当前不可读写，则阻塞进程，并等待驱动程序唤醒，重新调用poll函数，或超时返回。 3.驱动需要实现poll函数。 </p> 
<p>当驱动发现有数据可以读写时，通知核心层，核心层重新调用poll指向的函数查询信息。 poll_wait(filp,&amp;wait_q,wait) // 此处将当前进程加入到等待队列中，但并不阻塞 在中断中使用wake_up_interruptible(&amp;wait_q)唤醒等待队列 </p> 
<h3><a target="_blank" name="_Toc376251232"></a><a target="_blank" name="_Toc369176411">ioctl</a></h3> 
<p>函数名:ioctl</p> 
<p>头文件：#include&lt;sys/ioctl.h&gt;</p> 
<p>功 能: 控制I/O设备 ，提供了一种获得设备信息和向设备发送控制参数的手段。用于向设备发控制和配置命令 ，有些命令需要控制参数，这些数据是不能用read/ write 读写的,称为Out-of-band数据。也就是说,read /write 读写的数据是in-band数据,是I/O操作的主体，而ioctl 命令传送的是控制信息,其中的数据是辅助的数据。</p> 
<p>用 法: intioctl(int handle, int cmd,[int *argdx, int argcx]);</p> 
<p>返回值：成功为0，出错为-1</p> 
<p>usr/include/asm-generic/ioctl.h中定义的宏的注释：</p> 
<p>#define _IOC_NRBITS 8 //序数（number）字段的<a target="_blank" href="http://baike.baidu.com/view/2307934.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">字位</span></a>宽度，8bits</p> 
<p>#define _IOC_TYPEBITS 8 //幻数（type）字段的<a target="_blank" href="http://baike.baidu.com/view/2307934.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">字位</span></a>宽度，8bits</p> 
<p>#define _IOC_SIZEBITS 14 //大小（size）字段的<a target="_blank" href="http://baike.baidu.com/view/2307934.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">字位</span></a>宽度，14bits</p> 
<p>#define _IOC_DIRBITS 2 //方向（direction）字段的<a target="_blank" href="http://baike.baidu.com/view/2307934.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">字位</span></a>宽度，2bits</p> 
<p>#define _IOC_NRMASK ((1 &lt;&lt; _IOC_NRBITS)-1) //序数字段的掩码，0x000000FF</p> 
<p>#define _IOC_TYPEMASK ((1 &lt;&lt; _IOC_TYPEBITS)-1) //幻数字段的掩码，0x000000FF</p> 
<p>#define _IOC_SIZEMASK ((1 &lt;&lt; _IOC_SIZEBITS)-1) //大小字段的掩码，0x00003FFF</p> 
<p>#define _IOC_DIRMASK ((1 &lt;&lt; _IOC_DIRBITS)-1) //方向字段的掩码，0x00000003</p> 
<p>#define _IOC_NRSHIFT 0 //序数字段在整个字段中的位移，0</p> 
<p>#define _IOC_TYPESHIFT (_IOC_NRSHIFT+_IOC_NRBITS) //幻数字段的位移，8</p> 
<p>#define _IOC_SIZESHIFT (_IOC_TYPESHIFT+_IOC_TYPEBITS) //大小字段的位移，16</p> 
<p>#define _IOC_DIRSHIFT (_IOC_SIZESHIFT+_IOC_SIZEBITS) //方向字段的位移，30</p> 
<p>/*</p> 
<p>* Direction bits.</p> 
<p>*/</p> 
<p>#define _IOC_NONE 0U //没有数据传输</p> 
<p>#define _IOC_WRITE 1U //向设备写入数据，驱动程序必须从<a target="_blank" href="http://baike.baidu.com/view/4274331.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">用户空间</span></a>读入数据</p> 
<p>#define _IOC_READ 2U //从设备中读取数据，<a target="_blank" href="http://baike.baidu.com/view/1048.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">驱动程序</span></a>必须向<a target="_blank" href="http://baike.baidu.com/view/4274331.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">用户空间</span></a>写入数据</p> 
<p>#define _IOC(dir,type,nr,size) \</p> 
<p>(((dir) &lt;&lt; _IOC_DIRSHIFT) | \</p> 
<p>((type) &lt;&lt; _IOC_TYPESHIFT) | \</p> 
<p>((nr) &lt;&lt; _IOC_NRSHIFT) | \</p> 
<p>((size) &lt;&lt; _IOC_SIZESHIFT))</p> 
<p>/*</p> 
<p>* used to create numbers</p> 
<p>*/</p> 
<p>//构造无参数的命令编号</p> 
<p>#define _IO(type,nr) _IOC(_IOC_NONE,(type),(nr),0)</p> 
<p>//构造从<a target="_blank" href="http://baike.baidu.com/view/1048.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">驱动程序</span></a>中读取数据的命令编号</p> 
<p>#define _IOR(type,nr,size)_IOC(_IOC_READ,(type),(nr),sizeof(size))</p> 
<p>//用于向<a target="_blank" href="http://baike.baidu.com/view/1048.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">驱动程序</span></a>写入数据命令</p> 
<p>#define _IOW(type,nr,size) _IOC(_IOC_WRITE,(type),(nr),sizeof(size))</p> 
<p>//用于双向传输</p> 
<p>#define _IOWR(type,nr,size)_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))</p> 
<p>/*</p> 
<p>*used to decode ioctl numbers..</p> 
<p>*/</p> 
<p>//从命令参数中解析出数据方向，即写进还是读出</p> 
<p>#define _IOC_DIR(nr) (((nr) &gt;&gt; _IOC_DIRSHIFT) &amp;_IOC_DIRMASK)</p> 
<p>//从命令参数中解析出幻数type</p> 
<p>#define _IOC_TYPE(nr) (((nr) &gt;&gt; _IOC_TYPESHIFT) &amp;_IOC_TYPEMASK)</p> 
<p>//从命令参数中解析出序数number</p> 
<p>#define _IOC_NR(nr) (((nr) &gt;&gt; _IOC_NRSHIFT) &amp;_IOC_NRMASK)</p> 
<p>//从命令参数中解析出用户数据大小</p> 
<p>#define _IOC_SIZE(nr) (((nr) &gt;&gt; _IOC_SIZESHIFT) &amp;_IOC_SIZEMASK)</p> 
<p>/* ...and for the drivers/sound files... */</p> 
<p>#define IOC_IN (_IOC_WRITE &lt;&lt; _IOC_DIRSHIFT)</p> 
<p>#define IOC_OUT (_IOC_READ &lt;&lt; _IOC_DIRSHIFT)</p> 
<p>#define IOC_INOUT ((_IOC_WRITE|_IOC_READ) &lt;&lt; _IOC_DIRSHIFT)</p> 
<p>#define IOCSIZE_MASK (_IOC_SIZEMASK &lt;&lt; _IOC_SIZESHIFT)</p> 
<p>#define IOCSIZE_SHIFT (_IOC_SIZESHIFT)</p> 
<p>程序例:</p> 
<p>#include &lt;stdlib.h&gt;</p> 
<p>#include &lt;stdio.h&gt;</p> 
<p>#include &lt;sys/ioctl.h&gt;</p> 
<p>int main(void) {<!-- --></p> 
<p>..int stat;</p> 
<p>/* use func 8 to determine if the default drive is removable */</p> 
<p>..stat = ioctl(0, 8, 0, 0);</p> 
<p>..if (!stat)</p> 
<p>....printf("Drive %c is removable.\n", getdisk() + 'A');</p> 
<p>..else</p> 
<p>....printf("Drive %c is not removable.\n", getdisk() +'A');</p> 
<p>..return 0;</p> 
<p>}</p> 
<p>int ioctl( int fd, int request, .../* void *arg */ ) 详解</p> 
<p>第三个参数总是一个<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">指针</span></a>，但指针的类型依赖于request参数。我们可以把和网络相关的请求划分为6类：</p> 
<p><a target="_blank" href="http://baike.baidu.com/view/567586.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">套接口</span></a>操作</p> 
<p>文件操作</p> 
<p>接口操作</p> 
<p>ARP 高速缓存操作</p> 
<p>路由表操作</p> 
<p>流系统</p> 
<p>下表列出了网络相关ioctl请求的request 参数以及arg 地址必须指向的<a target="_blank" href="http://baike.baidu.com/view/675645.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">数据类型</span></a>：</p> 
<table border="1" cellspacing="0" cellpadding="0" width="576"><tbody><tr><td> <p>类别</p> </td><td> <p>Request</p> </td><td> <p>说明</p> </td><td> <p>数据类型</p> </td></tr><tr><td> <p><strong>套</strong></p> <p><strong>接</strong></p> <p><strong>口</strong></p> </td><td> <p>SIOCATMARK</p> <p>SIOCSPGRP</p> <p>SIOCGPGRP</p> </td><td> <p>是否位于带外标记</p> <p>设置套接口的进程ID 或进程组ID</p> <p>获取套接口的进程ID 或进程组ID</p> </td><td> <p>int</p> <p>int</p> <p>int</p> </td></tr><tr><td> <p><strong>文</strong></p> <p><strong>件</strong></p> </td><td> <p>FIONBIO</p> <p>FIOASYNC</p> <p>FIONREAD</p> <p>FIOSETOWN</p> <p>FIOGETOWN</p> </td><td> <p>设置/ 清除非阻塞I/O 标志</p> <p>设置/ 清除信号驱动异步I/O 标志</p> <p>获取接收缓存区中的字节数</p> <p>设置文件的进程ID 或进程组ID</p> <p>获取文件的进程ID 或进程组ID</p> </td><td> <p>int</p> <p>int</p> <p>int</p> <p>int</p> <p>int</p> </td></tr><tr><td> <p><strong>接</strong></p> <p><strong>口</strong></p> </td><td> <p>SIOCGIFCONF</p> <p>SIOCSIFADDR</p> <p>SIOCGIFADDR</p> <p>SIOCSIFFLAGS</p> <p>SIOCGIFFLAGS</p> <p>SIOCSIFDSTADDR</p> <p>SIOCGIFDSTADDR</p> <p>SIOCGIFBRDADDR</p> <p>SIOCSIFBRDADDR</p> <p>SIOCGIFNETMASK</p> <p>SIOCSIFNETMASK</p> <p>SIOCGIFMETRIC</p> <p>SIOCSIFMETRIC</p> <p>SIOCGIFMTU</p> <p>SIOCxxx</p> </td><td> <p>获取所有接口的清单</p> <p>设置接口地址</p> <p>获取接口地址</p> <p>设置接口标志</p> <p>获取接口标志</p> <p>设置点到点地址</p> <p>获取点到点地址</p> <p>获取广播地址</p> <p>设置广播地址</p> <p>获取子网掩码</p> <p>设置子网掩码</p> <p>获取接口的测度</p> <p>设置接口的测度</p> <p>获取接口MTU</p> <p>（还有很多取决于系统的实现）</p> </td><td> <p>struct ifconf</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> </td></tr><tr><td> <p><strong>ARP</strong></p> </td><td> <p>SIOCSARP</p> <p>SIOCGARP</p> <p>SIOCDARP</p> </td><td> <p>创建/ 修改ARP 表项</p> <p>获取ARP 表项</p> <p>删除ARP 表项</p> </td><td> <p>struct arpreq</p> <p>struct arpreq</p> <p>struct arpreq</p> </td></tr><tr><td> <p><strong>路</strong></p> <p><strong>由</strong></p> </td><td> <p>SIOCADDRT</p> <p>SIOCDELRT</p> </td><td> <p>增加路径</p> <p>删除路径</p> </td><td> <p>struct rtentry</p> <p>struct rtentry</p> </td></tr><tr><td> <p><strong>流</strong></p> </td><td> <p>I_xxx</p> </td><td> <p> </p> </td><td> <p> </p> </td></tr></tbody></table> 
<h4><a target="_blank" name="_Toc376251233"></a><a target="_blank" name="_Toc369176412">套接口操作：</a></h4> 
<p>明确用于套接口操作的ioctl请求有三个, 它们都要求ioctl的第三个参数是指向某个整数的一个指针。</p> 
<p>SIOCATMARK: 如果本套接口的的度指针当前位于带外标记，那就通过由第三个参数指向的整数返回一个非0值；否则返回一个0值。POSIX以函数sockatmark替换本请求。</p> 
<p>SIOCGPGRP ： 通过第三个参数指向的整数返回本套接口的进程ID或进程组ID，该ID指定针对本套接口的SIGIO或SIGURG信号的接收进程。本请求和fcntl的F_GETOWN命令等效，POSIX标准化的是fcntl函数。</p> 
<p>SIOCSPGRP ： 把本套接口的进程ID或者进程组ID设置成第三个参数指向的整数，该ID指定针对本套接口的SIGIO或SIGURG信号的接收进程，本请求和fcntl的F_SETOWN命令等效，POSIX标准化的是fcntl操作。</p> 
<h4><a target="_blank" name="_Toc376251234"></a><a target="_blank" name="_Toc369176413">文件操作：</a></h4> 
<p>以下5个请求都要求ioctl的第三个参数指向一个整数。</p> 
<p>FIONBIO ： 根据ioctl的第三个参数指向一个0或非0值分别清除或设置本套接口的非阻塞标志。本请求和O_NONBLOCK文件状态标志等效，而该标志通过fcntl的F_SETFL命令清除或设置。</p> 
<p>FIOASYNC ： 根据ioctl的第三个参数指向一个0值或非0值分别清除或设置针对本套接口的信号驱动异步I/O标志，它决定是否收取针对本套接口的异步I/O信号（SIGIO）。本请求和O_ASYNC文件状态标志等效，而该标志可以通过fcntl的F_SETFL命令清除或设置。</p> 
<p>FIONREAD ： 通过由ioctl的第三个参数指向的整数返回当前在本套接口接收缓冲区中的字节数。本特性同样适用于文件，管道和终端。</p> 
<p>FIOSETOWN ： 对于套接口和SIOCSPGRP等效。</p> 
<p>FIOGETOWN ： 对于套接口和SIOCGPGRP等效。</p> 
<h4><a target="_blank" name="_Toc376251235"></a><a target="_blank" name="_Toc369176414">编辑本段</a><a target="_blank" name="sub1081282_2"></a>定义</h4> 
<p>ioctl是<a target="_blank" href="http://baike.baidu.com/view/15565.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">设备驱动程序</span></a>中对设备的<a target="_blank" href="http://baike.baidu.com/view/1431426.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">I/O</span><span style="color:#136EC2">通道</span></a>进行管理的函数。所谓对I/O通道进行管理，就</p> 
<p>是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。它的调用个数</p> 
<p>如下：</p> 
<p>int ioctl(int fd, int cmd, …)；</p> 
<p>其中fd就是用户程序打开设备时使用open函数返回的文件标示符，cmd就是用户程序对设</p> 
<p>备的控制命令，至于后面的省略号，那是一些补充参数，一般最多一个，有或没有是和</p> 
<p>cmd的意义相关的。</p> 
<p>ioctl函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支</p> 
<p>持，用户就能在用户程序中使用ioctl函数控制设备的I/O通道。</p> 
<h4><a target="_blank" name="_Toc376251236"></a><a target="_blank" name="_Toc369176415">编辑本段</a><a target="_blank" name="sub1081282_3"></a>必要性</h4> 
<p>如果不用IOCTL的话，也能实现对设备I/O通道的控制，但那就是蛮拧了。例如，我们可</p> 
<p>以在驱动程式中实现WRITE的时候检查一下是否有特别约定的数据流通过，如果有的话，</p> 
<p>那么后面就跟着控制命令（一般在SOCKET编程中常常这样做）。不过如果这样做的话，会</p> 
<p>导致代码分工不明，程式结构混乱，程式员自己也会头昏眼花的。</p> 
<p>所以，我们就使用IOCTL来实现控制的功能。要记住，用户程式所作的只是通过命令码告</p> 
<p>诉驱动程式他想做什么，至于怎么解释这些命令和怎么实现这些命令，这都是驱动程式要</p> 
<p>做的事情。</p> 
<h4><a target="_blank" name="_Toc376251237"></a><a target="_blank" name="_Toc369176416">编辑本段</a><a target="_blank" name="sub1081282_4"></a>实现操作</h4> 
<p>读者只要把write换成ioctl，就知道用户程式的ioctl是怎么和驱动程式中的ioctl实现联系在一起的了。</p> 
<p>我这里说一个大概思路，因为我觉得《Linux设备驱动程式》这本书已说的非常清晰</p> 
<p>了，不过得花一些时间来看。</p> 
<p>在驱动程式中实现的ioctl函数体内，实际上是有一个switch{case}结构，每一个case对</p> 
<p>应一个命令码，做出一些相应的操作。怎么实现这些操作，这是每一个程式员自己的事</p> 
<p>情，因为设备都是特定的，这里也没法说。关键在于怎么样组织命令码，因为在ioctl中</p> 
<p>命令码是唯一联系用户程式命令和驱动程式支持的途径。</p> 
<p>命令码的组织是有一些讲究的，因为我们一定要做到命令和设备是一一对应的，这样才不</p> 
<p>会将正确的命令发给错误的设备，或是把错误的命令发给正确的设备，或是把错误的</p> 
<p>命令发给错误的设备。这些错误都会导致不可预料的事情发生，而当程式员发现了这些奇</p> 
<p>怪的事情的时候，再来调试程式查找错误，那将是非常困难的事情。</p> 
<p>所以在Linux核心中是这样定义一个命令码的：</p> 
<p>____________________________________</p> 
<p>| 设备类型| 序列号| 方向|数据尺寸|</p> 
<p>|----------|--------|------|--------|</p> 
<p>| 8 bit | 8 bit |2 bit |8~14 bit|</p> 
<p>|----------|--------|------|--------|</p> 
<p>这样一来，一个命令就变成了一个整数形式的命令码。不过命令码非常的不直观，所以</p> 
<p>Linux Kernel中提供了一些宏，这些宏可根据便于理解的字符串生成命令码，或是从</p> 
<p>命令码得到一些用户能理解的字符串以标明这个命令对应的设备类型、设备序列号、数</p> 
<p>据传送方向和数据传输尺寸。</p> 
<p>这些宏我就不在这里解释了，具体的形式请读者察看Linux核心原始码中的和，文件里给</p> 
<p>除了这些宏完整的定义。这里我只多说一个地方，那就是"幻数"。</p> 
<p>幻数是个字母，数据长度也是8，所以就用一个特定的字母来标明设备类型，这和用一</p> 
<p>个数字是相同的，只是更加利于记忆和理解。就是这样，再没有更复杂的了。</p> 
<p>更多的说了也没有，读者还是看一看原始码吧，推荐各位阅读《Linux设备驱动程式》所</p> 
<p>带原始码中的short一例，因为他比较短小，功能比较简单，能看明白ioctl的功能和细</p> 
<p>节。</p> 
<h4><a target="_blank" name="_Toc376251238"></a><a target="_blank" name="_Toc369176417">编辑本段</a><a target="_blank" name="sub1081282_5"></a>其他信息</h4> 
<p>cmd参数怎么得出</p> 
<p>这里确实要说一说，cmd参数在用户程式端由一些宏根据设备类型、序列号、传送方向、</p> 
<p>数据尺寸等生成，这个整数通过<a target="_blank" href="http://baike.baidu.com/view/47173.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">系统调用</span></a>传递到内核中的驱动程式，再由驱动程式使用解</p> 
<p>码宏从这个整数中得到设备的类型、序列号、传送方向、数据尺寸等信息，然后通过</p> 
<p>switch{case}结构进行相应的操作。</p> 
<p>要透彻理解，只能是通过阅读原始码，我这篇文章实际上只是个引子。Cmd参数的组织</p> 
<p>还是比较复杂的，我认为要搞熟他还是得花不少时间的，不过这是值得的，驱动程式中最</p> 
<p>难的是对中断的理解。</p> 
<p>五、 小结</p> 
<p>ioctl其实没有什么非常难的东西需要理解，关键是理解cmd命令码是怎么在用户程式里生成</p> 
<p>并在驱动程式里解析的，程式员最主要的工作量在switch{case}结构中，因为对设备的</p> 
<p>I/O控制都是通过这一部分的代码实现的。</p> 
<h3><a target="_blank" name="_Toc376251239"></a><a target="_blank" name="_Toc369176418">Mkdir</a>函数</h3> 
<p><span style="color:#333333; background:whitesmoke">原型：</span><span style="color:#333333; background:whitesmoke">int mkdir (const char *filename, mode_t mode)</span><span style="color:#333333"><br> <br> </span><span style="color:#333333; background:whitesmoke">返回</span><span style="color:#333333; background:whitesmoke">0</span><span style="color:#333333; background:whitesmoke">表示成功，返回</span><span style="color:#333333; background:whitesmoke">-1</span><span style="color:#333333; background:whitesmoke">表述出错。使用该函数需要包含头文件</span><span style="color:#333333; background:whitesmoke">sys/stat.h</span><span style="color:#333333"><br> <span style="background:whitesmoke">mode </span></span><span style="color:#333333; background:whitesmoke">表示新目录的权限，可以取以下值：</span><span style="color:#333333"><br> <span style="background:whitesmoke">S_IRUSR</span><br> <span style="background:whitesmoke">S_IREAD</span><br> <span style="background:whitesmoke">    Read permission bit for the owner of the file. On many systems this bit is 0400. S_IREAD is an obsolete synonym provided for BSD compatibility.</span><br> <span style="background:whitesmoke">S_IWUSR</span><br> <span style="background:whitesmoke">S_IWRITE</span><br> <span style="background:whitesmoke">    Write permission bit for the owner of the file. Usually 0200. S_IWRITE is an obsolete synonym provided for BSD compatibility.</span><br> <span style="background:whitesmoke">S_IXUSR</span><br> <span style="background:whitesmoke">S_IEXEC</span><br> <span style="background:whitesmoke">    Execute (for ordinary files) or search (for directories) permission bit for the owner of the file. Usually 0100. S_IEXEC is an obsolete synonym provided for BSD compatibility.</span><br> <span style="background:whitesmoke">S_IRWXU</span><br> <span style="background:whitesmoke">    This is equivalent to (S_IRUSR | S_IWUSR | S_IXUSR).</span><br> <span style="background:whitesmoke">S_IRGRP</span><br> <span style="background:whitesmoke">    Read permission bit for the group owner of the file. Usually 040.</span><br> <span style="background:whitesmoke">S_IWGRP</span><br> <span style="background:whitesmoke">    Write permission bit for the group owner of the file. Usually 020.</span><br> <span style="background:whitesmoke">S_IXGRP</span><br> <span style="background:whitesmoke">    Execute or search permission bit for the group owner of the file. Usually 010.</span><br> <span style="background:whitesmoke">S_IRWXG</span><br> <span style="background:whitesmoke">    This is equivalent to (S_IRGRP | S_IWGRP | S_IXGRP).</span><br> <span style="background:whitesmoke">S_IROTH</span><br> <span style="background:whitesmoke">    Read permission bit for other users. Usually 04.</span><br> <span style="background:whitesmoke">S_IWOTH</span><br> <span style="background:whitesmoke">    Write permission bit for other users. Usually 02.</span><br> <span style="background:whitesmoke">S_IXOTH</span><br> <span style="background:whitesmoke">    Execute or search permission bit for other users. Usually 01.</span><br> <span style="background:whitesmoke">S_IRWXO</span><br> <span style="background:whitesmoke">    This is equivalent to (S_IROTH | S_IWOTH | S_IXOTH).</span><br> <span style="background:whitesmoke">S_ISUID</span><br> <span style="background:whitesmoke">    This is the set-user-ID on execute bit, usually 04000. See How Change Persona.</span><br> <span style="background:whitesmoke">S_ISGID</span><br> <span style="background:whitesmoke">    This is the set-group-ID on execute bit, usually 02000. See How Change Persona.</span><br> <span style="background:whitesmoke">S_ISVTX</span><br> <span style="background:whitesmoke">    This is the sticky bit, usually 01000.</span></span></p> 
<p><span style="color:#333333; background:whitesmoke"> </span></p> 
<h3><a target="_blank" name="_Toc376251240"></a><a target="_blank" name="_Toc369176419"><span style="color:#3A3A3A">信号量</span></a><span style="color:#3A3A3A"> sem_wait sem_post</span></h3> 
<p><span style="color:#454545">信号量的数据类型为结构</span><span style="color:#454545">sem_t</span><span style="color:#454545">，它本质上是一个长整型的数。函数</span><span style="color:#454545">sem_init</span><span style="color:#454545">（）用来初始化一个信号量。它的原型为：　　</span></p> 
<p><span style="color:#454545">extern int sem_init __P((sem_t *__sem, int __pshared, unsigned int __value));</span></p> 
<p><span style="color:#454545">sem</span><span style="color:#454545">为指向信号量结构的一个指针；</span><span style="color:#454545">pshared</span><span style="color:#454545">不为０时此信号量在进程间共享，否则只能为当前进程的所有线程共享；</span><span style="color:#454545">value</span><span style="color:#454545">给出了信号量的初始值。　　</span></p> 
<p><span style="color:#454545">函数</span><span style="color:#454545">sem_post( sem_t *sem )</span><span style="color:#454545">用来增加信号量的值。当有线程阻塞在这个信号量上时，调用这个函数会使其中的一个线程不在阻塞，选择机制同样是由线程的调度策略决定的。　　</span></p> 
<p><span style="color:#454545">函数</span><span style="color:#454545">sem_wait( sem_t *sem )</span><span style="color:#454545">被用来阻塞当前线程直到信号量</span><span style="color:#454545">sem</span><span style="color:#454545">的值大于</span><span style="color:#454545">0</span><span style="color:#454545">，解除阻塞后将</span><span style="color:#454545">sem</span><span style="color:#454545">的值减一，表明公共资源经使用后减少。函数</span><span style="color:#454545">sem_trywait( sem_t *sem )</span><span style="color:#454545">是函数</span><span style="color:#454545">sem_wait</span><span style="color:#454545">（）的非阻塞版本，它直接将信号量</span><span style="color:#454545">sem</span><span style="color:#454545">的值减一。　　</span></p> 
<p><span style="color:#454545">函数</span><span style="color:#454545">sem_destroy(sem_t *sem)</span><span style="color:#454545">用来释放信号量</span><span style="color:#454545">sem</span><span style="color:#454545">。　</span></p> 
<p><span style="color:#454545">信号量用</span><span style="color:#454545">sem_init</span><span style="color:#454545">函数创建的，下面是它的说明：</span><span style="color:#454545"><br> </span><span style="color:#454545">#include&lt;semaphore.h&gt;<br> int sem_init (sem_t *sem, int pshared, unsigned int value);<br> <br> </span><span style="color:#454545">这个函数的作用是对由</span><span style="color:#454545">sem</span><span style="color:#454545">指定的信号量进行初始化，设置好它的共享选项，并指定一个整数类型的初始值。</span><span style="color:#454545">pshared</span><span style="color:#454545">参数控制着信号量的类型。如果</span><span style="color:#454545">pshared</span><span style="color:#454545">的值是０，就表示它是当前里程的局部信号量；否则，其它进程就能够共享这个信号量。我们现在只对不让进程共享的信号量感兴趣。　（这个参数受版本影响），　</span><span style="color:#454545">pshared</span><span style="color:#454545">传递一个非零将会使函数调用失败。</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">　　这两个函数控制着信号量的值，它们的定义如下所示：</span><span style="color:#454545"><br> </span><span style="color:#454545"><br> </span><span style="color:#454545">#include&lt;semaphore.h&gt;<br> int sem_wait(sem_t * sem);<br> int sem_post(sem_t * sem);<br> <br> </span><span style="color:#454545">这两个函数都要用一个由</span><span style="color:#454545">sem_init</span><span style="color:#454545">调用初始化的信号量对象的指针做参数。</span><span style="color:#454545"><br> sem_post</span><span style="color:#454545">函数的作用是给信号量的值加上一个</span><span style="color:#454545">“1”</span><span style="color:#454545">，它是一个</span><span style="color:#454545">“</span><span style="color:#454545">原子操作</span><span style="color:#454545">”</span><span style="color:#454545">－－－即同时对同一个信号量做加</span><span style="color:#454545">“1”</span><span style="color:#454545">操作的两个线程是不会冲突的；而同时对同一个文件进行读、加和写操作的两个程序就有可能会引起冲突。信号量的值永远会正确地加一个</span><span style="color:#454545">“2”</span><span style="color:#454545">－－因为有两个线程试图改变它。</span><span style="color:#454545"><br> sem_wait</span><span style="color:#454545">函数也是一个原子操作，它的作用是从信号量的值减去一个</span><span style="color:#454545">“1”</span><span style="color:#454545">，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为</span><span style="color:#454545">2</span><span style="color:#454545">的信号量调用</span><span style="color:#454545">sem_wait(),</span><span style="color:#454545">线程将会继续执行，介信号量的值将减到</span><span style="color:#454545">1</span><span style="color:#454545">。如果对一个值为</span><span style="color:#454545">0</span><span style="color:#454545">的信号量调用</span><span style="color:#454545">sem_wait()</span><span style="color:#454545">，这个函数就会地等待直到有其它线程增加了这个值使它不再是</span><span style="color:#454545">0</span><span style="color:#454545">为止。如果有两个线程都在</span><span style="color:#454545">sem_wait()</span><span style="color:#454545">中等待同一个信号量变成非零值，那么当它被第三个线程增加一个</span><span style="color:#454545">“1”</span><span style="color:#454545">时，等待线程中只有一个能够对信号量做减法并继续执行，另一个还将处于等待状态。</span><span style="color:#454545"><br> </span><span style="color:#454545">信号量这种</span><span style="color:#454545">“</span><span style="color:#454545">只用一个函数就能原子化地测试和设置</span><span style="color:#454545">”</span><span style="color:#454545">的能力下正是它的价值所在。还有另外一个信号量函数</span><span style="color:#454545">sem_trywait</span><span style="color:#454545">，它是</span><span style="color:#454545">sem_wait</span><span style="color:#454545">的非阻塞搭档。</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">最后一个信号量函数是</span><span style="color:#454545">sem_destroy</span><span style="color:#454545">。这个函数的作用是在我们用完信号量对它进行清理。下面的定义：</span><span style="color:#454545"><br> #include&lt;semaphore.h&gt;<br> int sem_destroy (sem_t *sem);<br> </span><span style="color:#454545">这个函数也使用一个信号量指针做参数，归还自己战胜的一切资源。在清理信号量的时候如果还有线程在等待它，用户就会收到一个错误。</span><span style="color:#454545"><br> </span><span style="color:#454545">与其它的函数一样，这些函数在成功时都返回</span><span style="color:#454545">“0”</span><span style="color:#454545">。</span></p> 
<p><span style="color:#454545">#include &lt;stdio.h&gt;<br> #include &lt;unistd.h&gt;<br> #include &lt;stdlib.h&gt;<br> #include &lt;string.h&gt;<br> #include &lt;pthread.h&gt;<br> #include &lt;semaphore.h&gt;</span></p> 
<p><span style="color:#454545">sem_t bin_sem;<br> void *thread_function1(void *arg)<br> {<!-- --><br> printf("thread_function1--------------sem_wait\n");<br> sem_wait(&amp;bin_sem);<br> printf("sem_wait\n");<br> while (1)<br> {<!-- --><br> }<br> }</span></p> 
<p><span style="color:#454545">void*thread_function2(void *arg)<br> {<!-- --><br> printf("thread_function2--------------sem_post\n");<br> sem_post(&amp;bin_sem);<br> printf("sem_post\n");<br> while (1)<br> {<!-- --><br> }<br> }</span></p> 
<p><span style="color:#454545"><br> <br> int main()<br> {<!-- --><br> int res;<br> pthread_t a_thread;<br> void *thread_result;<br> <br> res = sem_init(&amp;bin_sem, 0, 0);<br> if (res != 0)<br> {<!-- --><br> perror("Semaphore initialization failed");<br> }<br> printf("sem_init\n");<br> res = pthread_create(&amp;a_thread, NULL, thread_function1, NULL);<br> if (res != 0)<br> {<!-- --><br> perror("Thread creation failure");<br> }<br> printf("thread_function1\n");<br> sleep (5);<br> printf("sleep\n");<br> res = pthread_create(&amp;a_thread, NULL, thread_function2, NULL);<br> if (res != 0)<br> {<!-- --><br> perror("Thread creation failure");<br> }<br> while (1)<br> {<!-- --><br> }<br> }</span></p> 
<p><span style="color:#454545"><br> sem_init<br> thread_function1<br> thread_function1--------------sem_wait<br> sleep<br> thread_function2--------------sem_post<br> sem_wait<br> sem_post</span></p> 
<h3><a target="_blank" name="_Toc376251241"></a><a target="_blank" name="_Toc369176420">Linux</a>下开启/关闭防火墙命令</h3> 
<p>1) 永久性生效，重启后不会复原</p> 
<pre>开启： chkconfig iptables on</pre> 
<pre>关闭： chkconfig iptables off</pre> 
<pre>2) 即时生效，重启后复原</pre> 
<pre>开启： service iptables start</pre> 
<pre>关闭： service iptables stop</pre> 
<pre>需要说明的是对于Linux下的其它服务都可以用以上命令执行开启和关闭操作。</pre> 
<pre>在当开启了防火墙时，做如下设置，开启相关端口，</pre> 
<pre>修改/etc/sysconfig/iptables 文件，添加以下内容：</pre> 
<pre>-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</pre> 
<pre>-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT</pre> 
<p>二.UBuntu关闭防火墙<br> iptables -A INPUT -i !   PPP0   -j ACCEPT</p> 
<p>三.CentOS Linux防火墙配置及关闭</p> 
<p>执行”setup”命令启动文字模式配置实用程序,在”选择一种工具”中选择”防火墙配置”,然后选择”运行工具”按钮,出现防火墙配置界面,将”安全级别”设为”禁用”,然后选择”确定”即可.</p> 
<p>或者用命令:<br> #/sbin/iptables -I INPUT -p tcp –dport 80 -j ACCEPT<br> #/sbin/iptables -I INPUT -p tcp –dport 22 -j ACCEPT<br> #/etc/rc.d/init.d/iptables save<br> 这样重启计算机后,防火墙默认已经开放了80和22端口<br> 这里应该也可以不重启计算机：<br> #/etc/init.d/iptables restart</p> 
<p><strong><a target="_blank" href="http://www.linuxidc.com/Linux/2008-04/12461.htm" rel="nofollow noopener noreferrer"><span style="color:#108AC6">防火墙的关闭</span></a>，关闭其服务即可：</strong><br> 查看防火墙信息：<br> #/etc/init.d/iptables status<br> 关闭防火墙服务：<br> #/etc/init.d/iptables stop<br> 永久关闭？不知道怎么个永久法：<br> #chkconfig –level 35 iptables off</p> 
<h3><a target="_blank" name="_Toc376251242"></a><a target="_blank" name="_Toc369176421">Linux</a>下配置ip、子网掩码、网关，并把他们保存在指定的文件中，每次启动后不用重新设置。</h3> 
<p><span style="color:#333333">1、 </span><span style="color:#333333; background:whitesmoke">可以把它放在</span><span style="color:#333333; background:whitesmoke">/etc/rc.d/init.d/rc.local</span><span style="color:#333333; background:whitesmoke">文件中</span><span style="color:#333333"><br> <span style="background:whitesmoke">ifconfig eth0 192.168.10.50 netmask 255.255.0.0</span><br> <span style="background:whitesmoke">route add default gw 192.168.1.1</span><br> <span style="background:whitesmoke">2</span></span><span style="color:#333333; background:whitesmoke">、配置网卡的配置文件</span><span style="color:#333333"><br> </span><span style="color:#333333; background:whitesmoke">创建或修改此文件</span><span style="color:#333333; background:whitesmoke">/etc/sysconfig/network-scripts/ifcfg-eth0#ifcfg-eth0</span><span style="color:#333333"><br> <span style="background:whitesmoke">DEVICE=eth0</span><br> <span style="background:whitesmoke">BOOTPROTO=static</span><br> <span style="background:whitesmoke">BROADCAST=192.168.10.255</span><br> <span style="background:whitesmoke">IPADDR=192.168.10.50</span><br> <span style="background:whitesmoke">NETMASK=255.255.255.0</span><br> <span style="background:whitesmoke">NETWORK=192.168.10.0</span><br> <span style="background:whitesmoke">ONBOOT=yes</span><br> <span style="background:whitesmoke">TYPE=Ethernet</span><br> <span style="background:whitesmoke">USERCTL=no</span><br> <span style="background:whitesmoke">PEERDNS=no</span><br> <span style="background:whitesmoke">GATEWAY= </span><br> <span style="background:whitesmoke">##Add to tail of /etc/sysconfig/static-routes</span><br> <span style="background:whitesmoke">eth0 192.168.1.1</span></span></p> 
<h3><a target="_blank" href="http://www.ezloo.com/2009/05/linux_poweroff_and_reboot.html" rel="nofollow noopener noreferrer"><span style="color:#326693">Linux</span><span style="color:#326693">的关机与重启命令</span></a><a target="_blank" name="_Toc369176422"></a><a target="_blank" name="_Toc376251243"></a></h3> 
<p>作者: Aillo, 发布于2009-05-10, 在<a target="_blank" href="http://www.ezloo.com/archives/system.html" rel="nofollow noopener noreferrer"><span style="color:#326693">系统</span></a>分类下, 1条<a target="_blank" href="http://www.ezloo.com/2009/05/linux_poweroff_and_reboot.html#comments" rel="nofollow noopener noreferrer"><span style="color:#326693">留言</span></a>。</p> 
<p>重启命令：<br> 1、reboot<br> 2、shutdown -r now 立刻重启(root用户使用)<br> 3、shutdown -r 10 过10分钟自动重启(root用户使用) <br> 4、shutdown -r 20:35 在时间为20:35时候重启(root用户使用)<br> 如果是通过shutdown命令设置重启的话，可以用shutdown -c命令取消重启</p> 
<p>关机命令：<br> 1、halt   立刻关机<br> 2、poweroff  立刻关机<br> 3、shutdown -h now 立刻关机(root用户使用)<br> 4、shutdown -h 10 10分钟后自动关机<br> 如果是通过shutdown命令设置关机的话，可以用shutdown -c命令取消重启</p> 
<h3><a target="_blank" name="_Toc376251244"></a><a target="_blank" name="_Toc369176423">安装</a>RPM包或者安装源码包</h3> 
<p>在windows下安装一个软件很轻松，只要双击.exe的文件，安装提示连续“下一步”即可，然而linux系统下安装一个软件似乎并不那么轻松了，因为我们不是在图形界面下。所以你要学会如何在linux下安装一个软件。</p> 
<p>在前面的内容中多次提到的yum，这个yum是Redhat所特有的安装RPM程序包的工具，使用起来相当方便。因为使用RPM安装某一个程序包有可能会因为该程序包依赖另一个程序包而无法安装。而使用yum工具就可以连同依赖的程序包一起安装。当然CentOS同样可以使用yum工具，而且在CentOS中你可以免费使用yum，但Redhat中只有当你付费后才能使用yum，默认是无法使用yum的。在介绍yum之前先说一说RPM相关的东西。</p> 
<p>【<strong>RPM工具</strong>】</p> 
<p>RPM是”Redhat Package Manager”的缩写，根据名字也能猜到这是Redhat公司开发出来的。RPM 是以一种数据库记录的方式来将你所需要的套件安装到你的Linux 主机的一套管理程序。也就是说，你的linux系统中存在着一个关于RPM的数据库，它记录了安装的包以及包与包之间依赖相关性。RPM包是预先在linux机器上编译好并打包好的文件，安装起来非常快捷。但是也有一些缺点，比如安装的环境必须与编译时的环境一致或者相当；包与包之间存在着相互依赖的情况；卸载包时需要先把依赖的包卸载掉，如果依赖的包是系统所必须的，那就不能卸载这个包，否则会造成系统崩溃。</p> 
<p>如果你的光驱中还有系统安装盘的话，你可以通过”mount /dev/cdrom /mnt”命令把光驱挂载到/mnt目录下，那么你会在/mnt/CentOS目录下看到很多.rpm的文件，这就是RPM包了。</p> 
<p></p> 
<p>每一个rpm包的名称都由”-“和”.”分成了若干部分。就拿 a2ps-4.13b-57.2.el5.i386.rpm 这个包来解释一下，<span style="color:red">a2ps </span><span style="color:red">为包名；</span><span style="color:red">4.13b</span><span style="color:red">则为版本信息；</span><span style="color:red">57.2.el5</span><span style="color:red">为发布版本号；</span><span style="color:red">i386</span><span style="color:red">为运行平台</span>。其中运行平台常见的有i386,i586, i686, x86_64 ，需要你注意的是cpu目前是分32位和64位的，i386,i586和i686都为32位平台，x86_64则代表为64位的平台。另外有些rpm包并没有写具体的平台而是noarch，这代表这个rpm包没有硬件平台限制。例如 alacarte-0.10.0-1.fc6.noarch.rpm。下面介绍一下rpm常用的命令。</p> 
<p>1）安装一个rpm包</p> 
<p></p> 
<p>-i ：安装的意思</p> 
<p>-v ：可视化</p> 
<p>-h ：显示安装进度</p> 
<p>另外在安装一个rpm包时常用的附带参数有：</p> 
<p>--force 强制安装，即使覆盖属于其他包的文件也要安装</p> 
<p>--nodeps 当要安装的rpm包依赖其他包时，即使其他包没有安装，也要安装这个包</p> 
<p>2）升级一个rpm包</p> 
<p>rpm-Uvh filename -U ：即升级的意思</p> 
<p>3）卸载一个rpm包</p> 
<p>rpm -efilename 这里的filename是通过rpm的查询功能所查询到的，稍后会作介绍。</p> 
<p></p> 
<p>卸载时后边跟的filename和安装时的是有区别的。上面命令提到的 “|”在linux系统中用的非常多也非常有用，它是一个管道符，用来把前面运行的结果传递给后面的命令。以后会做详细介绍，而后出现的grep命令则是用来过滤某个关键词的工具，在后续章节中会做详细介绍。</p> 
<p>4）查询一个包是否安装</p> 
<p>rpm -qrpm包名（这里的包名，是不带有平台信息以及后缀名的）</p> 
<p></p> 
<p>如果加上了平台信息以及后缀名反而不能查出来。你还可以查询当前系统中所安装的所有rpm包。</p> 
<p></p> 
<p>因为太多，所以笔者列出前十个。</p> 
<p>5）得到一个rpm包的相关信息</p> 
<p>rpm -qi 包名 （同样不需要加平台信息与后缀名）</p> 
<p></p> 
<p>6）列出一个rpm包安装的文件</p> 
<p>rpm -ql 包名</p> 
<p></p> 
<p>通过上面的命令可以看出vim是通过安装vim-enhanced-7.0.109-6.el5这个rpm包得来的。那么反过来如何通过一个文件去查找是由安装哪个rpm包得来的？</p> 
<p>7）列出某一个文件属于哪个rpm包</p> 
<p>rpm -qf 文件的绝对路径</p> 
<p></p> 
<p>前面讲过如何查找一个文件（可执行命令）的绝对路径</p> 
<p></p> 
<p>所以你也可以把这两条命令连起来写</p> 
<p></p> 
<p>看到了吗，whichvim 这条命令是由两个反引号引起来的，这代表引用反引号里面的命令所产生的结果。关于rpm工具的使用还有很多内容，笔者就不一一列举了，只要你掌握上面这些内容，完全够你平时工作用的了。</p> 
<p>【<strong>yum工具</strong>】</p> 
<p>介绍完rpm工具后，还需要你掌握最常用的yum工具，这个工具比rpm工具好用多了，当然前提是你使用的linux系统是支持yum的。yum最大的优势在于可以联网去下载所需要的rpm包，然后自动安装，在这个工程中如果要安装的rpm包有依赖关系，yum会帮你解决掉这些依赖关系依次安装所有rpm包。下面笔者介绍常用的yum 命令。</p> 
<p>1） 列出所有可用的rpm包 “yum list “</p> 
<p></p> 
<p>限于篇幅，笔者只列举出来前7个包信息。从上例中可以看到有”mirrors.163.com”信息出现，这是在告诉用户，它是从mirrors.163.com这里下载到的rpm包资源。如果你使用的是CentOS则你可以从/etc/yum.repos.d/CentOS-Base.repo这个文件下看到相关的配置信息。从上面的例子中你还可以看到最左侧是rpm包名字，中间是版本信息，最右侧是安装信息，如果安装了就显示installed，未安装则显示base或者extras，如果是该rpm包已安装但需要升级则显示updates。</p> 
<p>2）搜索一个rpm包 “yum search [相关关键词]”</p> 
<p></p> 
<p>除了这样搜索外，笔者常用的是利用grep来过滤</p> 
<p></p> 
<p>相信你也会喜欢用后者吧，这样看起来简明的多。</p> 
<p>3）安装一个rpm包 “yum install [-y] [rpm包名]”</p> 
<p>如果不加-y选项，则会以与用户交互的方式安装，首先是列出需要安装的rpm包信息，然后会问用户是否需要安装，输入y则安装，输入n则不安装。而笔者嫌这样太麻烦，所以直接加上-y选项，这样就省略掉了问用户是否安装的那一步。</p> 
<p>4）卸载一个rpm包 “yum remove [-y] [rpm包名]”</p> 
<p></p> 
<p>卸载和安装一样，你也可以直接加上-y选项来省略掉和用户交互的步骤。在这里笔者要提醒你一下，卸载某个rpm包一定要看清楚了，不要连其他重要的rpm包一起卸载了，以免影响正常的业务。</p> 
<p>4）升级一个rpm包 “yum update [-y] [rpm包]”</p> 
<p></p> 
<p>以上介绍了如何使用yum搜索、安装、卸载以及升级一个rpm包，如果你掌握了这些那么你就已经可以解决日常工作中遇到的与rpm包相关问题了。当然yum工具还有好多其他好用的命令，笔者不在列举出来，如果你感兴趣就去man一下吧。除此之外，笔者还会教你一些关于yum的小应用。</p> 
<p><strong>1 使用本地的光盘来制作一个yum源</strong></p> 
<p>有时候你的linux系统不能联网，当然就不能很便捷的使用联网的yum源了，这时候就需要你自己会利用linux系统光盘制作一个yum源。具体步骤如下：</p> 
<p>a.挂载光盘</p> 
<p>[root@fortest Server]# mount -t iso9660 -o loop /dev/cdrom /mnt</p> 
<p>b.删除/etc/yum.repos.d目录所有的repo文件</p> 
<p>[root@fortest Server]# rm -rf /etc/yum.repos.d/*</p> 
<p>c.创建新文件dvd.repo</p> 
<p>[root@fortest Server]# vim /etc/yum.repos.d/dvd.repo</p> 
<p>加入以下内容：</p> 
<p>[dvd]</p> 
<p>name=install dvd</p> 
<p>baseurl=file:///mnt</p> 
<p>enabled=1</p> 
<p>gpgcheck=0</p> 
<p>d.刷新repos,生成缓存</p> 
<p>[root@fortest Server]#yum makecache</p> 
<p>然后就可以使用yum命令安装你所需要的软件包了</p> 
<p><strong>2 利用yum工具下载一个rpm包</strong></p> 
<p>有时，我们需要下载一个rpm包，只是下载下来，拷贝给其他机器使用，前面也介绍过yum安装rpm包的时候，首先得下载这个rpm包然后再去安装，所以使用yum完全可以做到只下载而不安装。</p> 
<p>a. 首选要安装 yum-downloadonly</p> 
<p># yum install -y yum-downloadonly.noarch</p> 
<p>b. 下载一个rpm包而不安装</p> 
<p># yum install test.rpm -y --downloadonly //这样虽然下载了，但是并没有保存到我们想要的目录下，那么如何指定目录呢？</p> 
<p>c. 下载到指定目录</p> 
<p># yum install test.rpm -y --downloadonly --downloaddir=/usr/local/src</p> 
<p></p> 
<p>【<strong>安装源码包</strong>】</p> 
<p>其实，在linux下面安装一个源码包是最常用的，笔者在日常的管理工作中，大部分软件都是通过源码安装的。安装一个源码包，是需要我们自己把源代码编译成二进制的可执行文件。如果你读得懂这些源代码，那么你就可以去修改这些源代码自定义功能，然后再去编译成你想要的。使用源码包的好处除了可以自定义修改源代码外还可以定制相关的功能，因为源码包在编译的时候是可以附加额外的选项的。</p> 
<p>源码包的编译用到了linux系统里的编译器，常见的源码包一般都是用C语言开发的，这也是因为C语言为linux上最标准的程序语言。Linux上的C语言编译器叫做gcc，利用它就可以把C语言变成可执行的二进制文件。所以如果你的机器上没有安装gcc就没有办法去编译源码。你可以使用 yum install -y gcc 来完成安装。</p> 
<p>安装一个源码包，通常需要三个步骤：</p> 
<p>1. ./config 在这一步可以定制功能，加上相应的选项即可，具有有什么选项可以通过”./config--help ”命令来查看。在这一步会自动检测你的linux系统与相关的套件是否有编译该源码包时需要的库，因为一旦缺少某个库就不能完成编译。只有检测通过后才会生成一个Makefile文件。</p> 
<p>2. make 使用这个命令会根据Makefile文件中预设的参数进行编译，这一步其实就是gcc在工作了。</p> 
<p>3. make install 安装步骤，生成相关的软件存放目录和配置文件的过程。</p> 
<p>上面介绍的3步并不是所有的源码包软件都一样的，笔者以前也曾经遇到过，安装步骤并不是这样，也就是说源码包的安装并非具有一定的标准安装步骤。这就需要你拿到源码包解压后，然后进入到目录找相关的帮助文档，通常会以INSTALL或者README为文件名。所以，你一定要去看一下。下面笔者会编译安装一个源码包来帮你更深刻的去理解如何安装源码包。</p> 
<p>1. 下载一个源码包</p> 
<p></p> 
<p>这里要提一下，建议以后你把所有下载的源码包放到/usr/local/src/目录下，这个并不是必须的，只是一个约定。方便你和你的同事将来更好的去运维这台服务器。wget即为下载的命令，后边跟源码包的下载地址。该地址为笔者从网上找的一个apache的下载地址。</p> 
<p>2. 解压源码包</p> 
<p></p> 
<p>一般的源码包都是一个压缩包，如何解压一个.tar.gz的包上一章讲过的。</p> 
<p>3. 配置相关的选项，并生成Makefile</p> 
<p></p> 
<p>使用./config--help 可以查看可用的选项。一般常用的有”--prefix=PREFIX“ 这个选项的意思是定义软件包安装到哪里。到这里，笔者再提一个小小的约定，通常源码包都是安装在/usr/local/目录下的。比如，我们把apache安装在/usr/local/apache2下，那么这里就应该这样写” --prefix=/usr/local/apache2”。其他还有好多选项，如果你有耐心你可以挨个去看一看都有什么作用。</p> 
<p></p> 
<p>笔者在这里只定义了apache的安装目录，其他都是默认。回车后，开始执行check操作。</p> 
<p></p> 
<p>等check结束后生成了Makefile文件</p> 
<p></p> 
<p>除了查看有没有生成Makefile文件来判定有没有完成./config 的操作外，还可以通过这个命令”echo $?”来判定，如果是0，则表示上一步操作成功完成，否则就是没有成功。</p> 
<p></p> 
<p>4. 进行编译</p> 
<p></p> 
<p>这一步操作，就是把源代码编译成二进制的可执行文件，这一步也是最漫长的一步，编译时间的长短取决于源代码的多少和机器配置。</p> 
<p>5. 安装</p> 
<p></p> 
<p>在安装前，先确认上一步操作是否成功完成。</p> 
<p></p> 
<p>makeinstall 会创建相应的目录以及文件。当完成安装后，会在/usr/local目录下多了一个apache2目录，这就是apache所安装的目录了。</p> 
<p></p> 
<p>其实在日常的源码安装工作中，并不是每个都像笔者这样顺利完成安装的，遇到错误不能完成安装的情况是很多的。通常都是因为缺少某一个库文件导致的。这就需要你仔细琢磨报错信息或者查看当前目录下的config.log去得到相关的信息。另外，如果自己不能解决那就去网上google一下吧，通常你会得到你想要的答案。</p> 
<h3><a target="_blank" name="_Toc376251245"></a><a target="_blank" name="_Toc369176424">Linux rpm </a>命令参数使用详解［介绍和应用］</h3> 
<p align="center" style="background:#DEF5FC"><span style="color:#131313">全屏阅读</span></p> 
<div> 
 <p align="center"><span style="color:#999999">2013-03-0823:03:47</span><span style="color:#131313"> </span><span style="color:#999999">作者：</span><span style="color:red"><a target="_blank" href="http://www.wangruiyu.cn/author/nick" rel="nofollow noopener noreferrer" title="由 王睿宇 发布"><span style="color:#999999">王睿宇</span></a></span><span style="color:#131313"> </span><span style="color:#999999">所属分类：</span><span style="color:#999999"><a target="_blank" href="http://www.wangruiyu.cn/category/linux" rel="nofollow noopener noreferrer" title="查看 Linux 中的全部文章"><span style="color:#999999">Linux</span></a></span><span style="color:#131313"> </span><span style="color:#999999">阅读：</span><span style="color:#999999">322</span><span style="color:#131313"> </span><span style="color:#999999">评论：</span><span style="color:#999999"><a target="_blank" href="http://www.wangruiyu.cn/44.html#respond" rel="nofollow noopener noreferrer" title="《Linux rpm 命令参数使用详解［介绍和应用］》上的评论"><span style="color:#999999">0</span></a></span></p> 
</div> 
<div style="background:#DEF5FC"> 
 <p><span style="color:#131313">标签：</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://www.wangruiyu.cn/tag/linux" rel="nofollow noopener noreferrer"><span style="color:#999999">Linux</span></a>,</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://www.wangruiyu.cn/tag/rpm" rel="nofollow noopener noreferrer"><span style="color:#999999">rpm</span></a>,</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://www.wangruiyu.cn/tag/yum" rel="nofollow noopener noreferrer"><span style="color:#999999">YUM</span></a></span></p> 
</div> 
<p><span style="color:#131313">·</span><span style="color:#131313">  </span><span style="color:#131313">·</span><span style="color:#131313">  </span><strong><span style="color:#131313">RPM</span><span style="color:#131313">是</span><span style="color:#131313">RedHat Package Manager</span><span style="color:#131313">（</span><span style="color:#131313">RedHat</span><span style="color:#131313">软件包管理工具）类似</span><span style="color:#131313">Windows</span><span style="color:#131313">里面的</span><span style="color:#131313">“</span><span style="color:#131313">添加</span><span style="color:#131313">/</span><span style="color:#131313">删除程序</span><span style="color:#131313">”</span></strong></p> 
<p><span style="color:#131313">rpm </span><span style="color:#131313">执行安装包</span><span style="color:#131313"><br> </span><span style="color:#131313">二进制包（</span><span style="color:#131313">Binary</span><span style="color:#131313">）以及源代码包（</span><span style="color:#131313">Source</span><span style="color:#131313">）两种。二进制包可以直接安装在计算机中，而源代码包将会由</span><span style="color:#131313">RPM</span><span style="color:#131313">自动编译、安装。源代码包经常以</span><span style="color:#131313">src.rpm</span><span style="color:#131313">作为后缀名。</span></p> 
<p><span style="color:#131313">常用命令组合：</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><span style="color:#131313">－</span><span style="color:#131313">ivh</span><span style="color:#131313">：安装显示安装进度</span><span style="color:#131313">--install--verbose--hash<br> </span><span style="color:#131313">－</span><span style="color:#131313">Uvh</span><span style="color:#131313">：升级软件包</span><span style="color:#131313">--Update</span><span style="color:#131313">；</span><span style="color:#131313"><br> </span><span style="color:#131313">－</span><span style="color:#131313">qpl</span><span style="color:#131313">：列出</span><span style="color:#131313">RPM</span><span style="color:#131313">软件包内的文件信息</span><span style="color:#131313">[Query Package list]</span><span style="color:#131313">；</span><span style="color:#131313"><br> </span><span style="color:#131313">－</span><span style="color:#131313">qpi</span><span style="color:#131313">：列出</span><span style="color:#131313">RPM</span><span style="color:#131313">软件包的描述信息</span><span style="color:#131313">[Query Package install package(s)]</span><span style="color:#131313">；</span><span style="color:#131313"><br> </span><span style="color:#131313">－</span><span style="color:#131313">qf</span><span style="color:#131313">：查找指定文件属于哪个</span><span style="color:#131313">RPM</span><span style="color:#131313">软件包</span><span style="color:#131313">[Query File]</span><span style="color:#131313">；</span><span style="color:#131313"><br> </span><span style="color:#131313">－</span><span style="color:#131313">Va</span><span style="color:#131313">：校验所有的</span><span style="color:#131313">RPM</span><span style="color:#131313">软件包，查找丢失的文件</span><span style="color:#131313">[View Lost]</span><span style="color:#131313">；</span><span style="color:#131313"><br> </span><span style="color:#131313">－</span><span style="color:#131313">e</span><span style="color:#131313">：删除包</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><span style="color:#131313"> </span></p> 
<p><span style="color:#131313"> </span></p> 
<p><span style="color:#131313">rpm -q samba //</span><span style="color:#131313">查询程序是否安装</span><span style="color:#131313">rpm -ivh  /media/cdrom/RedHat/RPMS/samba-3.0.10-1.4E.i386.rpm //</span><span style="color:#131313">按路径安装并显示进度</span><span style="color:#131313"><br> rpm -ivh --relocate /=/opt/gaim gaim-1.3.0-1.fc4.i386.rpm    //</span><span style="color:#131313">指定安装目录</span><span style="color:#131313">rpm -ivh --test gaim-1.3.0-1.fc4.i386.rpm</span><span style="color:#131313"> //</span><span style="color:#131313">用来检查依赖关系；并不是真正的安装；</span><span style="color:#131313"><br> rpm -Uvh --oldpackage gaim-1.3.0-1.fc4.i386.rpm //</span><span style="color:#131313">新版本降级为旧版本</span><span style="color:#131313">rpm -qa | grep httpd</span><span style="color:#131313"> </span><span style="color:#131313">＃</span><span style="color:#131313">[</span><span style="color:#131313">搜索指定</span><span style="color:#131313">rpm</span><span style="color:#131313">包是否安装</span><span style="color:#131313">]--all</span><span style="color:#131313">搜索</span><span style="color:#131313">*httpd*<br> rpm -ql httpd</span><span style="color:#131313">　　　　　　　　　＃</span><span style="color:#131313">[</span><span style="color:#131313">搜索</span><span style="color:#131313">rpm</span><span style="color:#131313">包</span><span style="color:#131313">]--list</span><span style="color:#131313">所有文件安装目录</span><span style="color:#131313">rpm -qpi Linux-1.4-6.i368.rpm</span><span style="color:#131313">　＃</span><span style="color:#131313">[</span><span style="color:#131313">查看</span><span style="color:#131313">rpm</span><span style="color:#131313">包</span><span style="color:#131313">]--query--package--install package</span><span style="color:#131313">信息</span><span style="color:#131313"><br> rpm -qpf Linux-1.4-6.i368.rpm</span><span style="color:#131313">　＃</span><span style="color:#131313">[</span><span style="color:#131313">查看</span><span style="color:#131313">rpm</span><span style="color:#131313">包</span><span style="color:#131313">]--file<br> rpm -qpR file.rpm</span><span style="color:#131313">　　　　　　　＃</span><span style="color:#131313">[</span><span style="color:#131313">查看包</span><span style="color:#131313">]</span><span style="color:#131313">依赖关系</span><span style="color:#131313"><br> rpm2cpio file.rpm |cpio -div    </span><span style="color:#131313">＃</span><span style="color:#131313">[</span><span style="color:#131313">抽出文件</span><span style="color:#131313">]</span></p> 
<p><span style="color:#131313">rpm -ivh file.rpm </span><span style="color:#131313">　＃</span><span style="color:#131313">[</span><span style="color:#131313">安装新的</span><span style="color:#131313">rpm]--install--verbose--hash<br> rpm -ivh</span></p> 
<p><span style="color:#131313">rpm -Uvh file.rpm    </span><span style="color:#131313">＃</span><span style="color:#131313">[</span><span style="color:#131313">升级一个</span><span style="color:#131313">rpm]--upgrade<br> rpm -e file.rpm      </span><span style="color:#131313">＃</span><span style="color:#131313">[</span><span style="color:#131313">删除一个</span><span style="color:#131313">rpm</span><span style="color:#131313">包</span><span style="color:#131313">]--erase</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><span style="color:#131313">常用参数：</span></p> 
<p><span style="color:#131313">Install/Upgrade/Erase options:</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><span style="color:#131313">-i, --install                     install package(s)<br> -v, --verbose                     provide more detailed output<br> -h, --hash                        print hash marks as package installs (good with -v)<br> -e, --erase                       erase (uninstall) package<br> -U, --upgrade=&lt;packagefile&gt;+      upgrade package(s)<br> </span><span style="color:#131313">－</span><span style="color:#131313">-replacepkge                    </span><span style="color:#131313">无论软件包是否已被安装，都强行安装软件包</span><span style="color:#131313"><br> --test                            </span><span style="color:#131313">安装测试，并不实际安装</span><span style="color:#131313"><br> --nodeps                          </span><span style="color:#131313">忽略软件包的依赖关系强行安装</span><span style="color:#131313"><br> --force                           </span><span style="color:#131313">忽略软件包及文件的冲突</span><span style="color:#131313">Query options (with -q or --query):<br> -a, --all                         query/verify all packages<br> -p, --package                     query/verify a package file<br> -l, --list                        list files in package<br> -d, --docfiles                    list all documentation files<br> -f, --file                        query/verify package(s) owning file</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><strong><span style="color:#131313">RPM</span><span style="color:#131313">源代码包装安装</span></strong></p> 
<p><span style="color:#131313">.src.rpm</span><span style="color:#131313">结尾的文件，这些文件是由软件的源代码包装而成的，用户要安装这类</span><span style="color:#131313">RPM</span><span style="color:#131313">软件包，必须使用命令：</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><span style="color:#131313">rpm</span><span style="color:#131313">--recompile</span><span style="color:#131313">vim-4.6-4.src.rpm   </span><span style="color:#131313">＃这个命令会把源代码解包并编译、安装它，如果用户使用命令：</span><span style="color:#131313">rpm</span><span style="color:#131313">--rebuild</span><span style="color:#131313">vim-4.6-4.src.rpm</span><span style="color:#131313">　　＃在安装完成后，还会把编译生成的可执行文件重新包装成</span><span style="color:#131313">i386.rpm</span><span style="color:#131313">的</span><span style="color:#131313">RPM</span><span style="color:#131313">软件包。</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><strong><span style="color:#131313">偶不喜欢写比较复杂的东东，麻烦的话</span><span style="color:#131313">`</span><span style="color:#131313">不过做为参考</span><span style="color:#131313">`</span><span style="color:#131313">偶还素转了一位哒人的</span><span style="color:#131313">`</span><span style="color:#131313">写的真很全面</span><span style="color:#131313">`</span></strong></p> 
<p><span style="color:#131313"> </span></p> 
<p><strong><span style="color:#131313">作者：</span></strong><span style="color:#131313">北南南北</span><span style="color:#131313"><br> </span><strong><span style="color:#131313">来自：</span></strong><span style="color:#131313">LinuxSir.Org<br> </span><strong><span style="color:#131313">提要：</span></strong><span style="color:#131313">RPM </span><span style="color:#131313">是</span><span style="color:#131313"> Red Hat PackageManager </span><span style="color:#131313">的缩写，原意是</span><span style="color:#131313">Red Hat </span><span style="color:#131313">软件包管理；本文介绍</span><span style="color:#131313">RPM</span><span style="color:#131313">，并结合实例来解说</span><span style="color:#131313">RPM</span><span style="color:#131313">手工安装、查询等应用；</span></p> 
<p><strong><span style="color:#131313"><br> <strong>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</strong><br> </span><span style="color:#131313">正文：</span><span style="color:#131313"><br> <strong>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</strong></span></strong></p> 
<p><span style="color:#131313">RPM </span><span style="color:#131313">是</span><span style="color:#131313"> Red Hat Package Manager </span><span style="color:#131313">的缩写，本意是</span><span style="color:#131313">Red Hat </span><span style="color:#131313">软件包管理，顾名思义是</span><span style="color:#131313">RedHat </span><span style="color:#131313">贡献出来的软件包管理；在</span><span style="color:#131313">Fedora </span><span style="color:#131313">、</span><span style="color:#131313">Redhat</span><span style="color:#131313">、</span><span style="color:#131313">Mandriva</span><span style="color:#131313">、</span><span style="color:#131313">SuSE</span><span style="color:#131313">、</span><span style="color:#131313">YellowDog</span><span style="color:#131313">等主流发行版本，以及在这些版本基础上二次开发出来的发行版采用；</span></p> 
<p><span style="color:#131313">RPM</span><span style="color:#131313">包里面都包含什么？里面包含可执行的二进制程序，这个程序和</span><span style="color:#131313">Windows</span><span style="color:#131313">的软件包中的</span><span style="color:#131313">.exe</span><span style="color:#131313">文件类似是可执行的；</span><span style="color:#131313">RPM</span><span style="color:#131313">包中还包括程序运行时所需要的文件，这也和</span><span style="color:#131313">Windows</span><span style="color:#131313">的软件包类似，</span><span style="color:#131313">Windows</span><span style="color:#131313">的程序的运行，除了</span><span style="color:#131313">.exe</span><span style="color:#131313">文件以外，也有其它的文件；</span></p> 
<p><span style="color:#131313">一个</span><span style="color:#131313">RPM </span><span style="color:#131313">包中的应用程序，有时除了自身所带的附加文件保证其正常以外，还需要其它特定版本文件，这就是软件包的依赖关系；依赖关系并不是</span><span style="color:#131313">Linux</span><span style="color:#131313">特有的，</span><span style="color:#131313"> Windows</span><span style="color:#131313">操作系统中也是同样存在的；比如我们在</span><span style="color:#131313">Windows</span><span style="color:#131313">系统中运行</span><span style="color:#131313">3D</span><span style="color:#131313">游戏，在安装的时候，他可能会提示，要安装</span><span style="color:#131313">Direct 9 </span><span style="color:#131313">；</span><span style="color:#131313">Linux</span><span style="color:#131313">和</span><span style="color:#131313">Windows</span><span style="color:#131313">原理是差不多的；</span></p> 
<p><span style="color:#131313">软件安装流程图：</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><strong><span style="color:#131313"><br> </span><span style="color:#131313">本文使用范围：</span><span style="color:#131313"><br> </span></strong><span style="color:#131313"><br> 1</span><span style="color:#131313">、本文是对</span><span style="color:#131313">RPM</span><span style="color:#131313">管理的软件的说明，对通过</span><span style="color:#131313">file.tar.gz </span><span style="color:#131313">或</span><span style="color:#131313">file.tar.bz2</span><span style="color:#131313">源码包用</span><span style="color:#131313"> make ;make install </span><span style="color:#131313">安装的软件无效；</span><span style="color:#131313"><br> 2</span><span style="color:#131313">、安装软件时，最好用各自发行版所提供的系统软件包管理工具，对于</span><span style="color:#131313">Fedora/Redhat </span><span style="color:#131313">您可以参考如下文章；</span></p> 
<p><span style="color:#131313">1</span><span style="color:#131313">）</span><span style="color:#131313">Fedora </span><span style="color:#131313">系统管理软件包工具</span><span style="color:#131313"> system-config-packages</span><span style="color:#131313">，方便的添加和移除系统安装盘提供的软件包，详情请看</span><span style="color:#131313">《</span><span style="color:#131313">Fedora </span><span style="color:#131313">软件包管理器</span><span style="color:#131313">system-config-packages</span><span style="color:#131313">》</span></p> 
<p><span style="color:#131313">2</span><span style="color:#131313">）</span><span style="color:#131313">Redhat </span><span style="color:#131313">系统管理软件包工具</span><span style="color:#131313">,</span><span style="color:#131313">新一点的系统应该是</span><span style="color:#131313"> redhat-config-packages </span><span style="color:#131313">，用法和</span><span style="color:#131313">《</span><span style="color:#131313">Fedora </span><span style="color:#131313">软件包管理器</span><span style="color:#131313">system-config-packages</span><span style="color:#131313">》</span><span style="color:#131313">一样；</span></p> 
<p><span style="color:#131313">3</span><span style="color:#131313">）</span><span style="color:#131313">apt + synaptic </span><span style="color:#131313">软件包在线安装、移除、升级工具；</span><span style="color:#131313">用法：《用</span><span style="color:#131313">apt+synaptic </span><span style="color:#131313">在线安装或升级</span><span style="color:#131313">Fedoracore 4.0 </span><span style="color:#131313">软件包》</span><span style="color:#131313"><br> 4</span><span style="color:#131313">）</span><span style="color:#131313">yum </span> <span style="color:#131313">软件包在线安装、升级、移除工具；用法：《</span><span style="color:#131313">Fedora/Redhat </span><span style="color:#131313">在线安装更新软件包，</span><span style="color:#131313">yum </span><span style="color:#131313">篇》</span></p> 
<p><span style="color:#131313">5</span><span style="color:#131313">）所有的</span><span style="color:#131313">yum</span><span style="color:#131313">和</span><span style="color:#131313">apt </span><span style="color:#131313">教程</span><span style="color:#131313">《</span><span style="color:#131313">apt and yum</span><span style="color:#131313">》</span></p> 
<p><span style="color:#131313">目前</span><span style="color:#131313"> apt</span><span style="color:#131313">和</span><span style="color:#131313">yum </span><span style="color:#131313">已经极为成熟了，建议我们安装软件时，采用</span><span style="color:#131313">apt</span><span style="color:#131313">或者</span><span style="color:#131313">yum </span><span style="color:#131313">；如果安装系统盘提供的软件包，可以用</span><span style="color:#131313"> system-config-packages </span><span style="color:#131313">或</span><span style="color:#131313">redhat-config-packages </span><span style="color:#131313">；</span></p> 
<p><strong><span style="color:#131313"><br> </span><span style="color:#131313">一、</span><span style="color:#131313">RPM</span><span style="color:#131313">包管理的用途；</span></strong></p> 
<p><span style="color:#131313">1</span><span style="color:#131313">、可以安装、删除、升级和管理软件；当然也支持在线安装和升级软件；</span><span style="color:#131313"><br> 2</span><span style="color:#131313">、通过</span><span style="color:#131313">RPM</span><span style="color:#131313">包管理能知道软件包包含哪些文件，也能知道系统中的某个文件属于哪个软件包；</span><span style="color:#131313"><br> 3</span><span style="color:#131313">、可以在查询系统中的软件包是否安装以及其版本；</span><span style="color:#131313"><br> 4</span><span style="color:#131313">、作为开发者可以把自己的程序打包为</span><span style="color:#131313">RPM </span><span style="color:#131313">包发布；</span><span style="color:#131313"><br> 5</span><span style="color:#131313">、软件包签名</span><span style="color:#131313">GPG</span><span style="color:#131313">和</span><span style="color:#131313">MD5</span><span style="color:#131313">的导入、验证和签名发布</span><span style="color:#131313"><br> 6</span><span style="color:#131313">、依赖性的检查，查看是否有软件包由于不兼容而扰乱了系统；</span></p> 
<p><strong><span style="color:#131313"><br> </span><span style="color:#131313">二、</span><span style="color:#131313">RPM</span><span style="color:#131313">的使用权限；</span><span style="color:#131313"><br> </span></strong><span style="color:#131313"><br> RPM</span><span style="color:#131313">软件的安装、删除、更新只有</span><span style="color:#131313">root</span><span style="color:#131313">权限才能使用；对于查询功能任何用户都可以操作；如果普通用户拥有安装目录的权限，也可以进行安装；</span></p> 
<p><strong><span style="color:#131313"><br> </span><span style="color:#131313">三、</span><span style="color:#131313">rpm</span><span style="color:#131313">的一点简单用法；</span><span style="color:#131313"><br> </span></strong><span style="color:#131313"><br> </span><span style="color:#131313">我们除了软件包管理器以外，还能通过</span><span style="color:#131313">rpm </span><span style="color:#131313">命令来安装；是不是所有的软件包都能通过</span><span style="color:#131313">rpm </span><span style="color:#131313">命令来安装呢？不是的，文件以</span><span style="color:#131313">.rpm </span><span style="color:#131313">后缀结尾的才行；有时我们在一些网站上找到</span><span style="color:#131313">file.rpm </span><span style="color:#131313">，都要用</span><span style="color:#131313"> rpm </span> <span style="color:#131313">来安装；</span><span style="color:#131313"><br> </span><strong><span style="color:blue"><br> </span><span style="color:blue">一）初始化</span><span style="color:blue">rpm</span><span style="color:blue">数据库；</span><span style="color:blue"><br> </span></strong><span style="color:#131313"><br> </span><span style="color:#131313">通过</span><span style="color:#131313">rpm </span> <span style="color:#131313">命令查询一个</span><span style="color:#131313">rpm </span><span style="color:#131313">包是否安装了，也是要通过</span><span style="color:#131313">rpm </span><span style="color:#131313">数据库来完成的；所以我们要经常用下面的两个命令来初始化</span><span style="color:#131313">rpm </span><span style="color:#131313">数据库；</span></p> 
<p><code><span style="color:#131313">[root@localhostbeinan]# rpm --initdb</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">[root@localhost beinan]# rpm --rebuilddb </span></code><code><span style="color:#131313">注：这个要花好长时间；</span></code></p> 
<p><span style="color:#131313">注：这两个参数是极为有用，有时</span><span style="color:#131313">rpm</span><span style="color:#131313">系统出了问题，不能安装和查询，大多是这里出了问题；</span><span style="color:#131313"><br> </span><strong><span style="color:blue"><br> </span><span style="color:blue">二）</span><span style="color:blue">RPM</span><span style="color:blue">软件包管理的查询功能：</span><span style="color:blue"><br> </span></strong><span style="color:#131313"><br> </span><span style="color:#131313">命令格式</span></p> 
<p><code><span style="color:#131313">rpm {-q|--query}[select-options] [query-options]</span></code></p> 
<p><span style="color:#131313">RPM</span><span style="color:#131313">的查询功能是极为强大，是极为重要的功能之一；举几个常用的例子，更为详细的具体的，请参考</span><span style="color:#131313">#man rpm<br> </span><span style="color:blue"><br> 1</span><span style="color:blue">、对系统中已安装软件的查询；</span></p> 
<p><span style="color:#131313">1</span><span style="color:#131313">）查询系统已安装的软件；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">语法：</span></code><code><span style="color:#131313">rpm-q </span></code><code><span style="color:#131313">软件名</span></code></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostbeinan]# rpm -q gaim</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">gaim-1.3.0-1.fc4</span></code></p> 
<p><span style="color:#131313">-q</span><span style="color:#131313">就是</span><span style="color:#131313"> --query </span><span style="color:#131313">，中文意思是</span><span style="color:#131313">“</span><span style="color:#131313">问</span><span style="color:#131313">”</span><span style="color:#131313">，此命令表示的是，是不是系统安装了</span><span style="color:#131313">gaim </span><span style="color:#131313">；如果已安装会有信息输出；如果没有安装，会输出</span><span style="color:#131313">gaim </span><span style="color:#131313">没有安装的信息；</span></p> 
<p><span style="color:#131313">查看系统中所有已经安装的包，要加</span><span style="color:#131313"> -a</span><span style="color:#131313">参数</span><span style="color:#131313">；</span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -qa</span></code></p> 
<p><span style="color:#131313">如果分页查看，再加一个管道</span><span style="color:#131313"> |</span><span style="color:#131313">和</span><span style="color:#131313">more</span><span style="color:#131313">命令；</span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -qa |more</span></code></p> 
<p><span style="color:#131313">在所有已经安装的软件包中查找某个软件，比如说</span><span style="color:#131313">gaim </span><span style="color:#131313">；可以用</span><span style="color:#131313"> grep </span> <span style="color:#131313">抽取出来；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -qa |grep gaim</span></code></p> 
<p><span style="color:#131313">上面这条的功能和</span><span style="color:#131313">rpm -q gaim </span><span style="color:#131313">输出的结果是一样的；</span></p> 
<p><span style="color:#131313">2</span><span style="color:#131313">）查询一个已经安装的文件属于哪个软件包；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">语法</span></code><code><span style="color:#131313">rpm -qf </span></code><code><span style="color:#131313">文件名</span></code></p> 
<p><span style="color:#131313">注：文件名所在的绝对路径要指出</span><span style="color:#131313"> </span></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -qf /usr/lib/libacl.la</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">libacl-devel-2.2.23-8</span></code></p> 
<p><span style="color:#131313">3</span><span style="color:#131313">）查询已安装软件包都安装到何处；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">语法：</span></code><code><span style="color:#131313">rpm-ql </span></code><code><span style="color:#131313">软件名</span></code><code><span style="color:#131313">或</span></code><code><span style="color:#131313"> rpm rpmquery -ql </span></code><code><span style="color:#131313">软件名</span></code></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -ql lynx</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">[root@localhost RPMS]# rpmquery -ql lynx</span></code></p> 
<p><span style="color:#131313">4</span><span style="color:#131313">）查询一个已安装软件包的信息</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">语法格式：</span></code><code><span style="color:#131313">rpm -qi </span></code><code><span style="color:#131313">软件名</span></code></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -qi lynx</span></code></p> 
<p><span style="color:#131313">5</span><span style="color:#131313">）查看一下已安装软件的配置文件；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">语法格式：</span></code><code><span style="color:#131313">rpm-qc </span></code><code><span style="color:#131313">软件名</span></code></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -qc lynx</span></code></p> 
<p><span style="color:#131313">6</span><span style="color:#131313">）查看一个已经安装软件的文档安装位置：</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">语法格式：</span></code><code><span style="color:#131313">rpm -qd </span></code><code><span style="color:#131313">软件名</span></code></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -qd lynx</span></code></p> 
<p><span style="color:#131313">7</span><span style="color:#131313">）查看一下已安装软件所依赖的软件包及文件；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">语法格式：</span></code><code><span style="color:#131313">rpm -qR </span></code><code><span style="color:#131313">软件名</span></code></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><code><span style="color:#131313">[root@localhostbeinan]# rpm -qR rpm-python</span></code></p> 
<p><span style="color:#131313">查询已安装软件的总结：对于一个软件包已经安装，我们可以把一系列的参数组合起来用；比如</span><span style="color:#131313"> rpm -qil </span><span style="color:#131313">；比如：</span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -qil lynx</span></code></p> 
<p><span style="color:blue"><br> 2</span><span style="color:blue">、对于未安装的软件包的查看：</span><span style="color:blue"><br> </span><span style="color:#131313"><br> </span><span style="color:#131313">查看的前提是您有一个</span><span style="color:#131313">.rpm </span><span style="color:#131313">的文件，也就是说对既有软件</span><span style="color:#131313">file.rpm</span><span style="color:#131313">的查看等；</span></p> 
<p><span style="color:#131313">1</span><span style="color:#131313">）查看一个软件包的用途、版本等信息；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">语法：</span></code><code><span style="color:#131313">rpm -qpi file.rpm</span></code></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -qpi lynx-2.8.5-23.i386.rpm</span></code></p> 
<p><span style="color:#131313">2</span><span style="color:#131313">）查看一件软件包所包含的文件；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">语法：</span></code><code><span style="color:#131313">rpm -qpl file.rpm</span></code></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -qpl lynx-2.8.5-23.i386.rpm</span></code></p> 
<p><span style="color:#131313">3</span><span style="color:#131313">）查看软件包的文档所在的位置；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">语法：</span></code><code><span style="color:#131313">rpm -qpd file.rpm</span></code></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -qpd lynx-2.8.5-23.i386.rpm</span></code></p> 
<p><span style="color:#131313">5</span><span style="color:#131313">）查看一个软件包的配置文件；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">语法：</span></code><code><span style="color:#131313">rpm -qpc file.rpm</span></code></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -qpc lynx-2.8.5-23.i386.rpm</span></code></p> 
<p><span style="color:#131313">4</span><span style="color:#131313">）查看一个软件包的依赖关系</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">语法：</span></code><code><span style="color:#131313">rpm -qpR file.rpm</span></code></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><code><span style="color:#131313">[root@localhostarchives]# rpm -qpR yumex_0.42-3.0.fc4_noarch.rpm</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">/bin/bash</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">/usr/bin/python</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">config(yumex) = 0.42-3.0.fc4</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">pygtk2</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">pygtk2-libglade</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">rpmlib(CompressedFileNames) &lt;= 3.0.4-1</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">usermode</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">yum &gt;= 2.3.2</span></code></p> 
<p><strong><span style="color:#131313"><br> </span><span style="color:#131313">三）软件包的安装、升级、删除等；</span></strong></p> 
<p><span style="color:blue"><br> 1</span><span style="color:blue">、安装和升级一个</span><span style="color:blue">rpm </span> <span style="color:blue">包；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostbeinan]#rpm -vih file.rpm </span> </code><code><span style="color:#131313">注：这个是用来安装一个新的</span></code><code><span style="color:#131313">rpm</span></code><code><span style="color:#131313">包；</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">[root@localhost beinan]#rpm -Uvh file.rpm </span></code><code><span style="color:#131313">注：这是用来升级一个</span></code><code><span style="color:#131313">rpm </span></code><code><span style="color:#131313">包；</span></code></p> 
<p><span style="color:#131313">如果有依赖关系的，请解决依赖关系，其实软件包管理器能很好的解决依赖关系，请看前面的软件包管理器的介绍；如果您在软件包管理器中也找不到依赖关系的包；那只能通过编译他所依赖的包来解决依赖关系，或者强制安装；</span></p> 
<p><span style="color:#131313">语法结构：</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostbeinan]# rpm -ivh file.rpm --nodeps --force</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">[root@localhost beinan]# rpm -Uvh file.rpm --nodeps --force</span></code></p> 
<p><span style="color:#131313">更多的参数，请查看</span><span style="color:#131313">man rpm</span></p> 
<p><span style="color:#131313">举例应用：</span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -ivh lynx-2.8.5-23.i386.rpm</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">Preparing... ########################################### [100%]</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">      1:lynx########################################### [100%]</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">[root@localhost RPMS]# rpm -ivh --replacepkgslynx-2.8.5-23.i386.rpm</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">Preparing... ########################################### [100%]</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">      1:lynx########################################### [100%]</span></code></p> 
<p><span style="color:#131313">注：</span><span style="color:#131313"> --replacepkgs </span><span style="color:#131313">参数是以已安装的软件再安装一次；有时没有太大的必要；</span></p> 
<p><span style="color:#131313">测试安装参数</span><span style="color:#131313">--test </span> <span style="color:#131313">，用来检查依赖关系；并不是真正的安装；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -ivh --test gaim-1.3.0-1.fc4.i386.rpm</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">Preparing... ########################################### [100%]</span></code></p> 
<p><span style="color:#131313">由新版本降级为旧版本，要加</span><span style="color:#131313">--oldpackage </span><span style="color:#131313">参数；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -qa gaim</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">gaim-1.5.0-1.fc4</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">[root@localhost RPMS]# rpm -Uvh --oldpackagegaim-1.3.0-1.fc4.i386.rpm</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">Preparing... ########################################### [100%]</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">      1:gaim########################################### [100%]</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">[root@localhost RPMS]# rpm -qa gaim</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">gaim-1.3.0-1.fc4</span></code></p> 
<p><span style="color:#131313">为软件包指定安装目录：要加</span><span style="color:#131313">-relocate </span><span style="color:#131313">参数；下面的举例是把</span><span style="color:#131313">gaim-1.3.0-1.fc4.i386.rpm</span><span style="color:#131313">指定安装在</span><span style="color:#131313"> /opt/gaim </span><span style="color:#131313">目录中；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -ivh --relocate /=/opt/gaim gaim-1.3.0-1.fc4.i386.rpm</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">Preparing... ########################################### [100%]</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">      1:gaim########################################### [100%]</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">[root@localhost RPMS]# ls /opt/</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">gaim</span></code></p> 
<p><span style="color:#131313">为软件包指定安装目录：要加</span><span style="color:#131313">-relocate </span><span style="color:#131313">参数；下面的举例是把</span><span style="color:#131313">lynx-2.8.5-23.i386.rpm </span><span style="color:#131313">指定安装在</span><span style="color:#131313"> /opt/lynx </span><span style="color:#131313">目录中；</span><span style="color:#131313"><br> [root@localhost RPMS]# rpm -ivh --relocate /=/opt/lynx --badreloclynx-2.8.5-23.i386.rpm<br> Preparing... ########################################### [100%]<br> 1:lynx ########################################### [100%]</span></p> 
<p><span style="color:#131313">我们安装在指定目录中的程序如何调用呢？一般执行程序，都放在安装目录的</span><span style="color:#131313">bin</span><span style="color:#131313">或者</span><span style="color:#131313">sbin</span><span style="color:#131313">目录中；看下面的例子；如果有错误输出，就做相应的链接，用</span><span style="color:#131313"> ln -s </span><span style="color:#131313">；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# /opt/lynx/usr/bin/lynx</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">Configuration file /etc/lynx.cfg is not available.</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">[root@localhost RPMS]# ln -s /opt/lynx/etc/lynx.cfg/etc/lynx.cfg</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">[root@localhost RPMS]# /opt/lynx/usr/bin/lynx www.linuxsir.org</span></code></p> 
<p><span style="color:blue"><br> 2</span><span style="color:blue">、删除一个</span><span style="color:blue">rpm </span> <span style="color:blue">包；</span></p> 
<p><span style="color:#131313">首先您要学会查询</span><span style="color:#131313">rpm</span><span style="color:#131313">包</span><span style="color:#131313">；请看前面的说明；</span></p> 
<p><span style="color:#131313">[root@localhost beinan]#rpm -e </span><span style="color:#131313">软件包名</span></p> 
<p><span style="color:#131313">举例：我想移除</span><span style="color:#131313">lynx</span><span style="color:#131313">包，完整的操作应该是：</span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -e lynx</span></code></p> 
<p><span style="color:#131313">如果有依赖关系，您也可以用</span><span style="color:#131313">--nodeps</span><span style="color:#131313">忽略依赖的检查来删除。但尽可能不要这么做，最好用软件包管理器</span><span style="color:#131313"> systerm-config-packages </span><span style="color:#131313">来删除或者添加软件；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostbeinan]# rpm -e lynx --nodeps</span></code></p> 
<p><strong><span style="color:#131313"><br> </span><span style="color:#131313">四、导入签名：</span><span style="color:#131313"><br> </span></strong><span style="color:#131313"><br> [root@localhost RPMS]# rpm --import </span><span style="color:#131313">签名文件</span></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostfc40]# rpm --import RPM-GPG-KEY</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">[root@localhost fc40]# rpm --import RPM-GPG-KEY-fedora</span></code></p> 
<p><span style="color:#131313">关于</span><span style="color:#131313">RPM</span><span style="color:#131313">的签名功能，详情请参见</span><span style="color:#131313">man rpm<br> <strong><br> </strong></span><strong><span style="color:#131313">五、</span><span style="color:#131313">RPM</span><span style="color:#131313">管理包管理器支持网络安装和查询；</span><span style="color:#131313"><br> </span></strong><span style="color:#131313"><br> </span><span style="color:#131313">比如我们想通过</span><span style="color:#131313"> Fedora Core 4.0 </span><span style="color:#131313">的一个镜像查询、安装软件包；</span></p> 
<p><span style="color:#131313">地址：</span></p> 
<p><span style="color:#131313">http://mirrors.kernel.org/fedora/core/4/i386/os/Fedora/RPMS/</span></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><span style="color:#131313">命令格式：</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">rpm </span></code><code><span style="color:#131313">参数</span></code><code><span style="color:#131313"> rpm</span></code><code><span style="color:#131313">包文件的</span></code><code><span style="color:#131313">http</span></code><code><span style="color:#131313">或者</span></code><code><span style="color:#131313">ftp</span></code><code><span style="color:#131313">的地址</span></code></p> 
<p><code><span style="color:#131313"># rpm -qpi</span></code><span style="color:#131313"> </span><code><span style="color:#131313"><a target="_blank" href="http://mirrors.kernel.org/fedora/core/4/i386/os/" rel="nofollow noopener noreferrer"><span style="color:#0196E3">http://mirrors.kernel.org/fedora/core/4/i386/os/</span></a></span></code><span style="color:#131313"> </span><code><span style="color:#131313">Fedora/RPMS/gaim-1.3.0-1.fc4.i386.rpm</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313"># rpm -ivh</span></code><span style="color:#131313"> </span><code><span style="color:#131313"><a target="_blank" href="http://mirrors.kernel.org/fedora/core/4/i386/os/" rel="nofollow noopener noreferrer"><span style="color:#0196E3">http://mirrors.kernel.org/fedora/core/4/i386/os/</span></a></span></code><span style="color:#131313"> </span><code><span style="color:#131313">Fedora/RPMS/gaim-1.3.0-1.fc4.i386.rpm</span></code></p> 
<p><span style="color:#131313">举一反三吧；</span></p> 
<p><strong><span style="color:#131313"><br> </span><span style="color:#131313">六、对已安装软件包查询的一点补充；</span></strong></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# updatedb</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">[root@localhost RPMS]# locate </span></code><code><span style="color:#131313">软件名或文件名</span></code></p> 
<p><span style="color:#131313">通过</span><span style="color:#131313">updatedb</span><span style="color:#131313">，我们可以用</span><span style="color:#131313">locate </span><span style="color:#131313">来查询一些软件安装到哪里了；系统初次安装时要执行</span><span style="color:#131313">updatedb </span><span style="color:#131313">，每隔一段时间也要执行一次；以保持已安装软件库最新；</span><span style="color:#131313">updatedb </span><span style="color:#131313">是</span><span style="color:#131313">slocate</span><span style="color:#131313">软件包所有；如果您没有这个命令，就得安装</span><span style="color:#131313">slocate </span><span style="color:#131313">；</span></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# locate gaim</span></code></p> 
<p><strong><span style="color:#131313"><br> </span><span style="color:#131313">七、从</span><span style="color:#131313">rpm</span><span style="color:#131313">软件包抽取文件；</span></strong></p> 
<p><code><span style="color:#131313">命令格式：</span></code><code><span style="color:#131313">rpm2cpio file.rpm |cpio -div</span></code></p> 
<p><span style="color:#131313">举例：</span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm2cpio gaim-1.3.0-1.fc4.i386.rpm |cpio -div</span></code></p> 
<p><span style="color:#131313">抽取出来的文件就在当用操作目录中的</span><span style="color:#131313">usr </span><span style="color:#131313">和</span><span style="color:#131313">etc</span><span style="color:#131313">中；</span></p> 
<p><span style="color:#131313">其实这样抽到文件不如指定安装目录来安装软件来的方便；也一样可以抽出文件；</span></p> 
<p><span style="color:#131313">为软件包指定安装目录：要加</span><span style="color:#131313">-relocate </span><span style="color:#131313">参数；下面的举例是把</span><span style="color:#131313">gaim-1.3.0-1.fc4.i386.rpm</span><span style="color:#131313">指定安装在</span><span style="color:#131313"> /opt/gaim </span><span style="color:#131313">目录中；</span></p> 
<p><span style="color:#131313"> </span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# rpm -ivh --relocate /=/opt/gaim gaim-1.3.0-1.fc4.i386.rpm</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">Preparing... ########################################### [100%]</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">      1:gaim########################################### [100%]</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">[root@localhost RPMS]# ls /opt/</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">gaim</span></code></p> 
<p><span style="color:#131313">这样也能一目了然；</span><span style="color:#131313">gaim</span><span style="color:#131313">的所有文件都是安装在</span><span style="color:#131313">/opt/gaim </span><span style="color:#131313">中，我们只是把</span><span style="color:#131313">gaim </span><span style="color:#131313">目录备份一下，然后卸掉</span><span style="color:#131313">gaim</span><span style="color:#131313">；这样其实也算提取文件的一点用法；</span></p> 
<p><strong><span style="color:#131313"><br> </span><span style="color:#131313">八、</span><span style="color:#131313">RPM</span><span style="color:#131313">的配置文件；</span><span style="color:#131313"><br> </span></strong><span style="color:#131313"><br> RPM</span><span style="color:#131313">包管理，的配置文件是</span><span style="color:#131313"> rpmrc </span><span style="color:#131313">，我们可以在自己的系统中找到；比如</span><span style="color:#131313">Fedora Core 4.0</span><span style="color:#131313">中的</span><span style="color:#131313">rpmrc </span><span style="color:#131313">文件位于；</span></p> 
<p><code><span style="color:#131313">[root@localhostRPMS]# locate rpmrc</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">/usr/lib/rpm/rpmrc</span></code><span style="color:#131313"><br> </span><code><span style="color:#131313">/usr/lib/rpm/redhat/rpmrc</span></code></p> 
<p><span style="color:#131313">我们可以通过</span><span style="color:#131313">rpm --showrc </span><span style="color:#131313">查看；具体的还得我们自己来学习。呵。。。不要问我，我也不懂；只要您看了这篇文章，认为对您有用，您的水平就和我差不多；咱们水平是一样的，所以我不能帮助您了；请理解；</span><span style="color:#131313"><br> <strong><br> </strong></span><strong><span style="color:#131313">九、</span><span style="color:#131313">src.rpm</span><span style="color:#131313">的用法：</span><span style="color:#131313"><br> </span></strong><span style="color:#131313"><br> </span><span style="color:#131313">《</span><span style="color:#131313">file.src.rpm </span><span style="color:#131313">使用方法的简介》</span></p> 
<p><strong><span style="color:#131313"><br> </span><span style="color:#131313">后记：</span></strong><span style="color:#131313">Fedora/Redhat </span><span style="color:#131313">入门教程中的软件包管理篇，我已经写了很多了；目前还缺少通过源码包安装软件我方法以及一篇总结性的文档；我想在最近两天补齐，这两篇我以前写过；重新整理一下贴出来就行了；</span></p> 
<p><span style="color:#131313">以我的水平来看，写</span><span style="color:#131313">Fedora</span><span style="color:#131313">入门教程是极为费力气的，只能一点一点的完善和补充；我所写的教程是面对的是对</span><span style="color:#131313">Linux</span><span style="color:#131313">一无所知新手；教程中实例应用占大部份；我发现没有实例的情况下，新手不如看</span><span style="color:#131313">man </span><span style="color:#131313">；能看</span><span style="color:#131313">man</span><span style="color:#131313">了，当然也不是什么新手；</span></p> 
<p><span style="color:#131313">经常在论坛上看一些弟兄的提问，虽然一问话解说过去也能应付；但想让大家更方便一点，不如写系统入门教程；虽然所花的时间要长一点；</span></p> 
<h3><a target="_blank" name="_Toc376251246"></a><a target="_blank" name="_Toc369176425">GCC</a>警告选项例解</h3> 
<p>发布时间：2007-01-0117:26:00  来源： ChinaUnix博客 　  作者： ChinaUnix博客 　  点击：358</p> 
<p><br> 程序员是追求完美的一族，即使是一般的程序员大多也都不想看到自己的程序中有甚至那么一点点的瑕疵。遇到任意一条编译器警告都坚决不放过。有人会说：我们可以使用比编译器更加严格的静态代码检查工具，如<br> <span style="color:#4A664D">splint</span><br> 。 这个建议也很不错。不过lint工具使用起来较繁琐，有时候还需要记住一些特定符号并插入到你自己的代码中才行，门槛较高，这也让很多人止步于此。那么我 们就从此放弃么？不，如今的编译器做得都很好，它可以帮助我们的找到绝大多数可能出现问题的代码，前提是你要学会控制编译器去找到这些问题代码，而熟悉编 译器的警告选项恰恰是体现控制力的好方法。当你可以自如控制编译器警告输出的时候，你就算是’入道’了，同时你对语言的理解也更进一步了。<br> 有人说：我就是用一个-Wall选项就可以了，一般选手可以这么做，而且他可以不知道-Wall会跟踪哪些类型的问题；但是高级选手是不会只使用-Wall的，他会把每条警告都研究的很透彻，会在Makefile中列出他想让编译器输出哪些类型的警告以替代-Wall，他会屏蔽掉那些对他的代码’毫 无用处’的警告(很可能他使用了编译器对语言的扩展功能)，他会有个和编译器交流的过程。<br> 俗话说：’工欲善其事，必先利其器’，一直在工作中使用<br> <span style="color:#4A664D">GNU C</span><br> 编译器(以下简称GCC)，这里对GCC的一些警告选项细致的分析，并列举几个简单的例子[注1]供分析参考。<br> 1. -Wall集合警告选项<br> 我们平时可能大多数情况只使用-Wall编译警告选项，实际上-Wall选项是一系列警告编译选项的集合。下面逐一分析这一集合中的各个选项：<br> [-Wchar-subscripts]<br> 如果数组使用char类型变量做为下标值的话，则发出警告。因为在某些平台上char可能默认为signedchar，一旦溢出，就可能导致某些意外的结果。<br> e.g.<br> /* test_signed_char.c */<br> ＃include <br> int main () {<!-- --><br>          char     c       = 255; // 我们以为char是无符号的，其范围应该是[0,255]<br>          int      i       = 0;<br>          int      a[256];<br>          for (i = 0; i type `char’<br> 其输出结果：<br> -1<br> -41Array7476<br> 1<br> 从输出结果来看SolarisArray/gcc 3.2上char默认实现类型为signedchar；在WindowsXP/gcc-3.4.2上也是一样。<br> Windows上的输出结果：<br> -1<br> 16 (随机值)<br> 1<br> [-Wcomment]<br> 当’/*’出现在 ’/* ...*/’注释中，或者’＼’出现在’// ...’注释结尾处时，使用-Wcomment会给出警告。不要小觑这些马虎代码，它很可能会影响程序的运行结果。如下面的例子：<br> e.g.<br> /*<br> * test_comment.c<br> * gcc -Wcomment test_comment.c<br> */<br> ＃include <br> int main() {<!-- --><br>          int      a       = 1;<br>          int      b       = 2;<br>          int      c       = 0; // ok just test＼<br>          c = a + b;<br>          /*<br>           * 这里我们期待c = 3<br>           * /* 但实际上输出c = 0<br>           */<br>          printf("the c is %d＼n",c);<br>          return 0;<br> }<br> gcc -Wcomment test_comment.c<br> test_comment.c:10:30: warning: multi-line comment<br> test_comment.c:15:12: warning: "/*" within comment<br> 输出：<br> the c is 0<br> [-Wformat]<br> 检查printf和scanf等格式化输入输出函数的格式字符串与参数类型的匹配情况，如果发现不匹配则发出警告。某些时候格式字符串与参数类型的不匹配会导致程序运行错误，所以这是个很有用的警告选项。<br> e.g.<br> /*<br> * test_format.c<br> */<br> ＃include <br> int main() {<!-- --><br>          long     l       = 1;<br>          double d       = 55.67;<br>          printf("%d＼n",l);<br>          printf("%d＼n",d);<br>          return 0;<br> }<br> gcc -Wformat test_format.c<br> test_format.c: In function `main’:<br> test_format.c:10: warning: int format, long int arg (arg 2)<br> test_format.c:11: warning: int format, double arg (arg 2)<br> 输出：<br> 1<br> 1078711746<br> [-Wimplicit]<br> 该警告选项实际上是-Wimplicit-int和-Wimplicit-function-declaration两个警告选项的集合。前者在声明函数却未指明函数返回类型时给出警告，后者则是在函数声明前调用该函数时给出警告。<br> e.g.<br> /*<br> * test_implicit.c<br> */<br> ＃include <br> add(int a, int b) { //函数没有声明返回类型<br>          return a + b;<br> }<br> int test() {<!-- --><br>          int      a       = 0;<br>          int      b       = 0;<br>          int      c       = 0;<br>          int      d       = 0;<br>          c = add(a, b);<br>          d = sub(a, b); //未声明sub的函数原型<br>          return 0;<br> }<br> gcc -Wimplicit -c test_implicit.c<br> test_implicit.c:7: warning: return type defaults to `int’<br> test_implicit.c: In function `test’:<br> test_implicit.c:18: warning: implicit declaration of function `sub’<br> [-Wmissing-braces]<br> 当聚合类型或者数组变量的初始化表达式没有’充分’用括号{}括起时，给出警告。文字表述很难理解，举例说明则清晰些。看下面的例子：<br> e.g.<br> /*<br> * test_missing_braces.c<br> */<br> struct point {<!-- --><br>          int      x;<br>          int      y;<br> };<br> struct line {<!-- --><br>          struct point start;<br>          struct point end;<br> };<br> typedef struct line line;<br> int main() {<!-- --><br>          int     array1[2][2]     = {11, 12, 13, 14};<br>          int     array2[2][2]     = {<!-- -->{11, 12}, {13, 14}}; // ok<br>          line     l1              = {1, 1, 2, 2};<br>          line     l2              = {<!-- -->{2, 2}, {3, 3}};// ok<br>          return 0;<br> }<br> gcc -Wmissing-braces test_missing_braces.c<br> test_missing_braces.c: In function `main’:<br> test_missing_braces.c:1Array: warning: missing braces around initializer<br> test_missing_braces.c:1Array: warning: (near initialization for `array1[0]’)<br> test_missing_braces.c:21: warning: missing braces around initializer<br> test_missing_braces.c:21: warning: (near initialization for `l1.start’)<br> [-Wparentheses]<br> 这是一个很有用的警告选项，它能帮助你从那些看起来语法正确但却由于操作符优先级或者代码结构’障眼’而导致错误运行的代码中解脱出来。好长的一个长句，还是看例子理解吧！:)<br> e.g.<br> /*<br> * test_parentheses.c<br> * gcc -Wparentheses test_parentheses.c<br> */<br> ＃include <br> int main() {<!-- --><br>          int      a       = 1;<br>          int      b       = 1;<br>          int      c       = 1;<br>          int      d       = 1;<br>          if (a &amp;&amp; b || c) { // 人们很难记住逻辑操作符的操作顺序，所以编译器建议加上()<br>                  ;<br>          }<br>          if (a == 12)<br>                  if(b)<br>                         d = Array; <br>          else<br>                  d= 10; //从代码的缩进上来看，这句仿佛是if(a == 12)的else分支<br>          printf("the d is %d＼n",d); //期待d= 10, 而结果却是1<br>          return 0;<br> }<br> gcc -Wparentheses test_parentheses.c<br> test_parentheses.c: In function `main’:<br> test_parentheses.c:13: warning: suggest parentheses around &amp;&amp; within ||<br> test_parentheses.c:17: warning: suggest explicit braces to avoid ambiguous`else’<br> 输出：<br> the d is 1<br> [-Wsequence-point]<br> 关于顺序点(sequencepoint)，在C标准中有解释，不过很晦涩。我们在平时编码中尽量避免写出与实现相关、受实现影响的代码便是了。而-Wsequence-point选项恰恰可以帮我们这个忙，它可以帮我们查出这样的代码来，并给出其警告。<br> e.g.<br> /*<br> * test_sequence_point.c<br> * gcc -Wsequence-point test_sequence_point.c<br> */<br> ＃include <br> int main() {<!-- --><br>          int      i = 12;<br>          i = i--;<br>          printf("the i is %d＼n",i);<br>          return 0;<br> }<br> gcc -Wsequence-point test_sequence_point.c<br> test_sequence_point.c: In function `main’:<br> test_sequence_point.c:10: warning: operation on `i’ may be undefined<br> 在两个平台上给出的编译警告都是一致的，但是输出结果却大相径庭。<br> Solaris输出：<br> the i is 11<br> Windows输出：<br> the i is 12<br> 类似的像这种与顺序点相关的代码例子有：<br> i = i++;<br> a<em> =b[i++] <br> a[i++] = i<br> 等等...<br> [-Wswitch]<br> 这个选项的功能浅显易懂，通过文字描述也可以清晰的说明。当以一个枚举类型(enum)作为switch语句的索引时但却没有处理default情况，或者没有处理所有枚举类型定义范围内的情况时，该选项会给处警告。<br> e.g.<br> /*<br> * test_switch1.c<br> */<br> enum week {<!-- --><br>          SUNDAY,<br>          MONDAY,<br>          TUESDAY /* only an example , we omittedthe others */<br> };<br> int test1() {<!-- --><br>          enum week       w        = SUNDAY;<br>          switch(w) {<!-- --><br>                 case SUNDAY:<br>                         break; // without default or the other casehandlings<br>          };<br>          return 0;<br> }<br> int test2() { // Ok, won’t invoke even a warning<br>          enum week       w        = SUNDAY;<br>          switch(w) {<!-- --><br>                 case SUNDAY:<br>                         break;<br>                 default:<br>                         break;               <br>          };<br>          return 0;<br> }<br> int test3() { // Ok, won’t invoke even a warning<br>          enum week       w        = SUNDAY;<br>          switch(w) {<!-- --><br>                 case SUNDAY:<br>                         break;<br>                 case MONDAY:<br>                         break;<br>                 case TUESDAY:<br>                         break;            <br>          };<br>          return 0;<br> }<br> gcc -Wswitch -c test_switch.c<br> test_switch.c: In function `test1’:<br> test_switch.c:16: warning: enumeration value `MONDAY’ not handled in switch<br> test_switch.c:16: warning: enumeration value `TUESDAY’ not handled in switch<br> [-Wunused]<br> -Wunused是-Wunused-function、-Wunused-label、-Wunused-variable、-Wunused-value选项的集合，-Wunused-parameter需单独使用。<br> (1) -Wunused-function用来警告存在一个未使用的static函数的定义或者存在一个只声明却未定义的static函数，参见下面例子中的func1和func2；<br> (2) -Wunused-label用来警告存在一个使用了却未定义或者存在一个定义了却未使用的label，参加下面例子中的func3和func7；<br> (3) -Wunused-variable用来警告存在一个定义了却未使用的局部变量或者非常量static变量；参见下面例子中func5和var1；<br> (4) -Wunused-value用来警告一个显式计算表达式的结果未被使用；参见下面例子中func6<br> (5) -Wunused-parameter用来警告一个函数的参数在函数的实现中并未被用到，参见下面例子中func4。<br> 下面是一个综合的例子<br> e.g.<br> /*<br> * test_unused.c<br> */<br> static void func1(); //to prove function used but never defined<br> static void func2(); //to prove function defined but not used<br> static void func3(); //to prove label used but never defined<br> static void func7(); //to prove label defined but never used<br> static void func4(int a); //to prove parameter declared but not used<br> static void func5(); //to prove local variable defined but not used<br> static void func6(); //to prove value evaluated but not used<br> static int var1;<br> void test() {<!-- --><br>          func1();<br>          func3();<br>          func4(4);<br>          func5();<br>          func6();<br> }<br> static void func2() {<!-- --><br>          ; // do nothing<br> }<br> static void func3() {<!-- --><br>          goto over;<br> }<br> static void func4(int a) {<!-- --><br>          ; // do nothing<br> }<br> static void func5() {<!-- --><br>          int      a = 0;<br> }<br> static void func6() {<!-- --><br>          int      a = 0;<br>          int      b = 6;<br>          a + b;<br> }<br> gcc -Wunused-parameter -c test_unused.c //如果不是用-Wunused-parameter，则func4函数将不被警告。<br> test_unused.c: In function `func3’:<br> test_unused.c:30: label `over’ used but not defined<br> test_unused.c: In function `func7’:<br> test_unused.c:35: warning: deprecated use of label at end of compound statement<br> test_unused.c:34: warning: label `over’ defined but not used<br> test_unused.c: In function `func4’:<br> test_unused.c:37: warning: unused parameter `a’<br> test_unused.c: In function `func5’:<br> test_unused.c:42: warning: unused variable `a’<br> test_unused.c: In function `func6’:<br> test_unused.c:48: warning: statement with no effect<br> test_unused.c: At top level:<br> test_unused.c:6: warning: `func1’used but never defined<br> test_unused.c:25: warning: `func2’defined but not used<br> test_unused.c:14: warning: `var1’defined but not used<br> [-Wuninitialized]<br> 该警告选项用于检查一个局部自动变量在使用之前是否已经初始化了或者在一个longjmp调用可能修改 一个non-volatileautomatic variable时给出警告。目前编译器还不是那么smart，所以对有些可以正确按照程序员的意思运行的代码还是给出警告。而且该警告选项需要和’-O’选项一起使用，否则你得不到任何uinitialized的警告。<br> e.g.<br> /*<br> * test_uninitialized.c<br> */<br> int test(int y) {<!-- --><br>          int      x;<br>          switch (y) {<!-- --><br>                 case 1:<br>                         x = 11;<br>                         break;<br>                 case 2:<br>                         x = 22;<br>                         break;<br>                 case 3:<br>                         x = 33;<br>                         break;<br>          }<br>          return x;<br> }<br> gcc -Wuninitialized -O -c test_uninitialized.c<br> test_uninitialized.c: In function `test’:<br> test_uninitialized.c:6: warning: `x’ might be used uninitialized in thisfunction<br> 2、非-Wall集合警告选项<br> 以下讨论的这些警告选项并不包含在-Wall中，需要程序员显式添加。<br> [-Wfloat-equal]<br> 该项用来检查浮点值是否出现在相等比较的表达式中。<br> e.g.<br> /*<br> * test_float_equal.c<br> */<br> void test(int i) {<!-- --><br>          double d = 1.5;<br>          if (d == i) {<!-- --><br>                  ;<br>          }<br> }<br> gcc -Wfloat-equal -c test_float_equal.c<br> test_float_equal.c: In function `test’:<br> test_float_equal.c:8: warning: comparing floating point with == or != is unsafe<br> [-Wshadow]<br> 当局部变量遮蔽(shadow)了参数、全局变量或者是其他局部变量时，该警告选项会给我们以警告信息。<br> e.g.<br> /*<br> * test_shadow.c<br> */<br> int      g;<br> void test(int i) {<!-- --><br>          short    i;<br>          double g;<br> }<br> gcc -Wshadow -c test_shadow.c<br> test_shadow.c: In function `test’:<br> test_shadow.c:Array: warning: declaration of `i’ shadows a parameter<br> test_shadow.c:10: warning: declaration of `g’ shadows a global declaration<br> test_shadow.c:6: warning: shadowed declaration is here<br> [-Wbad-function-cast]<br> 当函数(准确地说应该是函数返回类型)被转换为非匹配类型时，均产生警告。<br> e.g.<br> /*<br> * test_bad_func_case.c<br> */<br> int add(int a, int b) {<!-- --><br>          return a+b;<br> }<br> void test() {<!-- --><br>          char *p = (char*)add(1, 13);<br> }<br> gcc -Wbad-function-cast -c test_bad_func_case.c<br> test_bad_func_case.c: In function `test’:<br> test_bad_func_case.c:11: warning: cast does not match function type<br> [-Wcast-qual]<br> 当去掉修饰源Target的限定词(如const)时，给出警告。<br> e.g.<br> /*<br> * test_cast_qual.c<br> */<br> void test() {<!-- --><br>          char            c        = 0;<br>          const char      *p       = &amp;c;<br>          char            *q;<br>          q = (char*)p;<br> }<br> gcc -Wcast-qual -c test_cast_qual.c<br> test_cast_qual.c: In function `test’:<br> test_cast_qual.c:10: warning: cast discards qualifiers from pointer target type<br> [-Wcast-align]<br> 这是个非常有用的选项，特别是对于在Solaris这样的对内存对齐校验的平台尤其重要。它用于在从对齐系数小的地址(如char*)转换为对齐系数大的地址(如int*)转换时给出警告。<br> e.g.<br> /*<br> * test_cast_align.c<br> */<br> ＃include <br> int main() {<!-- --><br>          char     c = 1;<br>          char     *p =&amp;c; //ok<br>          int      *q =(int*)p; //bad align-cast<br>          printf("the *q is %d＼n",*q);<br>          return 0;<br> }<br> gcc -Wcast-align test_cast_align.c<br> test_cast_align.c: In function `main’:<br> test_cast_align.c:Array: warning: cast increases required alignment of targettype<br> 输出：<br> 总线错误(（主存储器）信息转储)//on Solaris Array<br> [-Wsign-compare]<br> 在有符号数和无符号数进行值比较时，有符号数可能在比较之前被转换为无符号数而导致结果错误。使用该选项会对这样的情况给出警告。<br> e.g.<br> /*<br> * test_sign_compare.c<br> */<br> ＃include <br> int main() {<!-- --><br>          unsigned int     i =128;<br>          signed int       j =-1;<br>          if (i  j＼n");<br>          }<br>          return 0;<br> }<br> gcc -Wsign-compare test_sign_compare.c<br> test_sign_compare.c: In function `main’:<br> test_sign_compare.c:10: warning: comparison between signed and unsigned<br> 输出：<br> i type<br> test_unreachable.c:Array: warning: will never be executed<br> [-Wconvertion]<br> 由于原型定义而引起的定点和浮点数之间的隐式转换(强制转换)或者由有符号数和无符号数之间隐式转换转换引起的警告。<br> e.g.<br> /*<br> * test_conversion.c<br> */<br> ＃include <br> void getdouble(double d) {<!-- --><br>          ;       // do nothing<br> }<br> int main() {<!-- --><br>          unsigned int     k;<br>          int             n        = 12;<br>          k = -1;<br>          k = (unsigned int)-1; // ok, explicitconversion ,no warning<br>          getdouble(n);<br>          return 0;<br> }<br> gcc -Wconversion test_conversion.c<br> test_conversion.c: In function `main’:<br> test_conversion.c:15: warning: negative integer implicitly converted tounsigned type<br> test_conversion.c:18: warning: passing arg 1 of `getdouble’ as floating ratherthan integer due to prototype<br> 3、-Wtraditional和-W<br> 这两个警告选项其实也都是一些组合(大部分都在上面提到过)，前者用来在代码中使用了标准C不同于传统C的特性时，发出警告；后者也是针对一些事件打开一个警告集合。关于它们的说明具体可参见’<br> <span style="color:#4A664D">Using the GNU Compiler Collection</span></em></p> 
<p> </p> 
<h3><a target="_blank" name="_Toc376251247"></a><a target="_blank" name="_Toc369176426">Csocket</a>基本原理</h3> 
<p align="right"><span style="color:#999999">2009-03-20 20:09</span><span style="color:#999999"> </span><span style="color:#999999">1259</span><span style="color:#999999">人阅读</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/mengde007/article/details/4009062#comments" rel="noopener noreferrer"><span style="color:#336699">评论</span></a></span>(0)<span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" title="收藏"><span style="color:#336699">收藏</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/mengde007/article/details/4009062#report" title="举报" rel="noopener noreferrer"><span style="color:#336699">举报</span></a></span></p> 
<p align="left"><span style="color:#333333"><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=socket" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">socket</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=server" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">server</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=%e7%bd%91%e7%bb%9c" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">网络</span></a></span><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=sockets" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">sockets</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=thread" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">thread</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=stream" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">stream</span></a></p> 
<p><span style="color:#333333">我通过几个采用</span><span style="color:#333333"> CSocket </span><span style="color:#333333">类编写并基于</span><span style="color:#333333">Client/Server </span><span style="color:#333333">（客户端</span><span style="color:#333333">/ </span> <span style="color:#333333">服务端）的网络聊天和传输文件的程式</span><span style="color:#333333"> </span><span style="color:#333333">，在调试这些程式的过程中，追踪深入至</span><span style="color:#333333">CSocket </span><span style="color:#333333">类核心源码</span><span style="color:#333333">SockCore.cpp </span><span style="color:#333333">，</span><span style="color:#333333">对于</span><span style="color:#333333">CSocket </span><span style="color:#333333">类的运行机制可谓是一览无遗，并且对于阻塞和非阻塞方式下的</span><span style="color:#333333">socket </span><span style="color:#333333">程式的编写也是稍有体会。</span></p> 
<p><span style="color:red">阅读本文请先注意</span><span style="color:red"> :</span></p> 
<p><span style="color:#333333">•  </span><span style="color:#333333">这里的阻塞和非阻塞的概念仅适用于</span><span style="color:#333333">Server </span><span style="color:#333333">端</span><span style="color:#333333">socket </span> <span style="color:#333333">程式。</span></p> 
<p><span style="color:#333333">• socket </span><span style="color:#333333">意为套接字，他和</span><span style="color:#333333">Socket </span><span style="color:#333333">不同，请注意首字母的大小写。</span></p> 
<p><span style="color:#333333">说明：客户端和服务端的通信简单来讲：服务端</span><span style="color:#333333"> socket </span><span style="color:#333333">负责监听，应答，接收和发送消息，而客户端</span><span style="color:#333333">socket </span><span style="color:#333333">只是连接，应答，接收，发送消息。此外，如果你对于采用</span><span style="color:#333333">CSocket </span><span style="color:#333333">类编写</span><span style="color:#333333">Client/Server </span><span style="color:#333333">网络程式的原理不是非常了解，请先查询一下（</span><span style="color:#333333"> </span><strong><span style="color:#333333">详见：参考书籍和在线帮助</span><span style="color:#333333"> </span></strong><span style="color:#333333">）。</span></p> 
<p><span style="color:#333333">在此之前，有必要先讲述一下：</span><span style="color:#333333">网络传输服务提供者，</span><span style="color:#333333"> ws2_32.dll </span><span style="color:#333333">，</span><span style="color:#333333"> socket </span> <span style="color:#333333">事件</span><span style="color:#333333">和</span><span style="color:#333333"> socket window </span><span style="color:#333333">。</span></p> 
<p><strong><span style="color:orange">1. </span><span style="color:orange">网络传输服务提供者（网络传输服务进程），</span><span style="color:orange">Socket </span><span style="color:orange">事件，</span><span style="color:orange"> SocketWindow</span></strong></p> 
<p><span style="color:#333333">网络传输服务提供者</span><span style="color:#333333">（</span><span style="color:#333333"> transport service provider </span><span style="color:#333333">）是以</span><span style="color:#333333"> DLL </span> <span style="color:#333333">的形式存在的，在</span><span style="color:#333333"> windows</span><span style="color:#333333">操作系统启动时由服务进程</span><span style="color:#333333">svchost.exe </span><span style="color:#333333">加载。当</span><span style="color:#333333">socket </span> <span style="color:#333333">被创建时，调用</span><span style="color:#333333">API </span> <span style="color:#333333">函数</span><span style="color:#333333"> Socket </span><span style="color:#333333">（在</span><span style="color:#333333"> ws2_32.dll</span><span style="color:#333333">中），</span><span style="color:#333333"> Socket </span><span style="color:#333333">函数会传递三个参数</span><span style="color:#333333"> : </span><span style="color:#333333">地址族，套接字类型</span><span style="color:#333333"> (</span><span style="color:#333333"> </span><strong><span style="color:#333333">注</span><span style="color:#333333"> 2</span><span style="color:#333333"> </span></strong><span style="color:#333333">)</span><span style="color:#333333">和协议，这三个参数决定了是由哪一个类型的</span><span style="color:#333333">网络传输服务提供者</span><span style="color:#333333">来启动网络传输服务功能。所有的网络通信正是由网络传输服务提供者完成</span><span style="color:#333333">, </span><span style="color:#333333">这里将</span><span style="color:#333333">网络传输服务提供者</span><span style="color:#333333">称为</span><span style="color:#333333">网络传输服务进程</span><span style="color:#333333">更有助于理解，因为前文已提到</span><span style="color:#333333">网络传输服务提供者</span><span style="color:#333333">是由</span><span style="color:#333333"> svchost.exe </span><span style="color:#333333">服务进程所加载的。</span></p> 
<p><span style="color:#333333">当</span><span style="color:#333333"> Client </span> <span style="color:#333333">端</span><span style="color:#333333"> socket </span><span style="color:#333333">和</span><span style="color:#333333"> Server </span><span style="color:#333333">端</span><span style="color:#333333"> socket </span> <span style="color:#333333">相互通信时，两端均会触发</span><span style="color:#333333"> socket </span><span style="color:#333333">事件</span><span style="color:#333333"> :</span></p> 
<p><span style="color:#333333">这里仅简要说明两个</span><span style="color:#333333"> socket </span><span style="color:#333333">事件</span><span style="color:#333333">：</span></p> 
<p><span style="color:#333333">FD_CONNECT:</span><span style="color:#333333">连接事件</span><span style="color:#333333"> , </span><span style="color:#333333">通常</span><span style="color:#333333"> Client </span> <span style="color:#333333">端</span><span style="color:#333333"> socket </span><span style="color:#333333">调用</span><span style="color:#333333"> socketAPI </span><span style="color:#333333">函数</span><span style="color:#333333"> Connect</span><span style="color:#333333">时所触发，这个事件发生在</span><span style="color:#333333">Client </span><span style="color:#333333">端。</span></p> 
<p><span style="color:#333333">FD_ACCEPT</span><span style="color:#333333">：正在引入的连接事件，通常</span><span style="color:#333333">Server </span><span style="color:#333333">端</span><span style="color:#333333">socket </span> <span style="color:#333333">正在接收来自</span><span style="color:#333333">Client </span> <span style="color:#333333">端</span><span style="color:#333333">socket </span><span style="color:#333333">连接时触发，这个事件发生在</span><span style="color:#333333">Server </span><span style="color:#333333">端。</span></p> 
<p><span style="color:#333333">网络传输服务进程</span><span style="color:#333333">将</span><span style="color:#333333"> socket </span><span style="color:#333333">事件</span><span style="color:#333333">保存至</span><span style="color:#333333"> socket </span><span style="color:#333333">的事件队列中。</span></p> 
<p><span style="color:#333333">此外，</span><span style="color:#333333">网络传输服务进程</span><span style="color:#333333">还会向</span><span style="color:#333333"> socketwindow </span><span style="color:#333333">发送消息</span><span style="color:#333333">WM_SOCKET_NOTIFY , </span><span style="color:#333333">通知有</span><span style="color:#333333">socket </span> <span style="color:#333333">事件</span><span style="color:#333333">产生，见下文对</span><span style="color:#333333"> socketwindow </span><span style="color:#333333">的周详说明：</span></p> 
<p><span style="color:#333333">调用</span><span style="color:#333333"> CSocket::Create </span><span style="color:#333333">函数后，</span><span style="color:#333333"> socket </span><span style="color:#333333">被创建。</span><span style="color:#333333"> socket </span><span style="color:#333333">创建过程中调用</span><span style="color:#333333">CAsyncSocket::AttachHandle(SOCKET hSocket, CAsyncSocket* pSocket, BOOL bDead) </span><span style="color:#333333">。该函数的作用是：</span></p> 
<p><span style="color:#333333">a. </span><span style="color:#333333">将</span><span style="color:#333333"> socket </span><span style="color:#333333">实例句柄和</span><span style="color:#333333"> socket </span><span style="color:#333333">指针添加至</span><span style="color:#333333">当前模块状态</span><span style="color:#333333">（</span><span style="color:#333333"> </span><strong><span style="color:#333333">注</span><span style="color:#333333"> 1</span></strong><span style="color:#333333"> </span><span style="color:#333333">）的一个映射表变量</span><span style="color:#333333"> m_pmapSocketHandle </span><span style="color:#333333">中。</span></p> 
<p><span style="color:#333333">b. </span><span style="color:#333333">在</span><span style="color:#333333">AttachHandle </span><span style="color:#333333">过程中，会</span><span style="color:#333333">new </span> <span style="color:#333333">一个</span><span style="color:#333333">CSocketWnd </span> <span style="color:#333333">实例</span><span style="color:#333333">( </span><span style="color:#333333">基于</span><span style="color:#333333"> CWnd </span><span style="color:#333333">派生</span><span style="color:#333333"> ) </span> <span style="color:#333333">，这里将这个实例称之为</span><span style="color:#333333"> socketwindow </span><span style="color:#333333">，进一步理解为他是存放所有</span><span style="color:#333333">sockets </span><span style="color:#333333">的消息池</span><span style="color:#333333">（</span><span style="color:#333333"> window </span><span style="color:#333333">消息），请仔细查看，这里</span><span style="color:#333333"> socket </span><span style="color:#333333">后多加了一个</span><span style="color:#333333"> s </span> <span style="color:#333333">，表示创建的多个</span><span style="color:#333333"> socket </span> <span style="color:#333333">将共享一个</span><span style="color:#333333">消息池</span><span style="color:#333333">。</span></p> 
<p><span style="color:#333333">c. </span><span style="color:#333333">当</span><span style="color:#333333"> Client </span><span style="color:#333333">端</span><span style="color:#333333"> socket </span> <span style="color:#333333">和</span><span style="color:#333333"> Server </span><span style="color:#333333">端相互通信时</span><span style="color:#333333"> , </span><span style="color:#333333">此时</span><span style="color:#333333">网络传输服务进程</span><span style="color:#333333">向</span><span style="color:#333333"> socket window </span><span style="color:#333333">发送消息</span><span style="color:#333333">WM_SOCKET_NOTIFY </span><span style="color:#333333">，需要说明的是</span><span style="color:#333333">CSocketWnd </span><span style="color:#333333">窗口句柄保存在</span><span style="color:#333333">当前模块状态</span><span style="color:#333333">的</span><span style="color:#333333">m_hSocketWindow </span><span style="color:#333333">变量中。</span></p> 
<p><span style="color:#333333"> </span></p> 
<p><strong><span style="color:orange">2. </span><span style="color:orange">阻塞模式</span></strong></p> 
<p><span style="color:#333333">阻塞模式下</span><span style="color:#333333"> Server </span> <span style="color:#333333">端和</span><span style="color:#333333"> Client </span><span style="color:#333333">端之间的通信处于同步状态下。</span></p> 
<p><span style="color:#333333">在</span><span style="color:#333333"> Server </span> <span style="color:#333333">端直接实例化</span><span style="color:#333333"> CSocket</span><span style="color:#333333">类，调用</span><span style="color:#333333"> Create </span><span style="color:#333333">方法创建</span><span style="color:#333333"> socket </span><span style="color:#333333">，然后调用方法</span><span style="color:#333333"> Listen </span><span style="color:#333333">开始侦听，最后用一个</span><span style="color:#333333"> while </span><span style="color:#333333">循环阻塞调用</span><span style="color:#333333"> Accept </span><span style="color:#333333">函数用于等待来自</span><span style="color:#333333"> Client </span><span style="color:#333333">端的连接，如果这个</span><span style="color:#333333"> socket </span><span style="color:#333333">在主线程（主程式）中运行，这将导致主线程的阻塞。因此，需要创建一个新的线程以运行</span><span style="color:#333333">socket </span><span style="color:#333333">服务。</span></p> 
<p><span style="color:#333333">调试跟踪至</span><span style="color:#333333"> CSocket::Accept </span><span style="color:#333333">函数源码：</span><span style="color:#333333"> </span><strong><span style="color:#333333"><br> </span></strong><span style="color:#333333"><br> <span style="background:beige">while(!Accept(...))</span></span><span style="color:#333333; background:beige"> </span><span style="color:#333333; background:beige"><br> {<!-- --></span><span style="color:#333333; background:beige"> </span><span style="color:#333333; background:beige"><br>     if (GetLastError() == WSAEWOULDBLOCK) //  The socket ismarked as nonblocking and no connections are present to be accepted.</span><span style="color:#333333; background:beige"> </span><span style="color:#333333; background:beige"><br>         PumpMessage(FD_ACCEPT);</span><span style="color:#333333; background:beige"> </span><span style="color:#333333; background:beige"><br>     else</span><span style="color:#333333; background:beige"> </span><span style="color:#333333; background:beige"><br>         return FALSE;</span><span style="color:#333333; background:beige"> </span><span style="color:#333333; background:beige"><br> }</span></p> 
<p><span style="color:#333333">他不断调用</span><span style="color:#333333"> CAsyncSocket::Accept </span><span style="color:#333333">（</span><span style="color:#333333"> CSocket</span><span style="color:#333333">派生自</span><span style="color:#333333">CAsyncSocket </span><span style="color:#333333">类）判断</span><span style="color:#333333">Server </span> <span style="color:#333333">端</span><span style="color:#333333">socket </span><span style="color:#333333">的事件队列中是否存在正在引入的连接事件</span><span style="color:#333333">- FD_ACCEPT </span><span style="color:#333333">（见</span><span style="color:#333333">1 </span> <span style="color:#333333">），换句话说，就是判断是否有来自</span><span style="color:#333333">Client </span><span style="color:#333333">端</span><span style="color:#333333">socket </span> <span style="color:#333333">的连接请求。</span></p> 
<p><span style="color:#333333">如果当前</span><span style="color:#333333"> Server </span> <span style="color:#333333">端</span><span style="color:#333333"> socket </span><span style="color:#333333">的事件队列中存在正在引入的连接事件，</span><span style="color:#333333">Accept </span><span style="color:#333333">返回一个非</span><span style="color:#333333">0 </span> <span style="color:#333333">值。否则，</span><span style="color:#333333"> Accept </span> <span style="color:#333333">返回</span><span style="color:#333333"> 0 </span><span style="color:#333333">，此时调用</span><span style="color:#333333">GetLastError </span><span style="color:#333333">将返回错误代码</span><span style="color:#333333">WSAEWOULDBLOCK </span><span style="color:#333333">，表示队列中无所有连接请求。</span></p> 
<p><span style="color:#333333">注意到在循环体内有一句代码：</span></p> 
<p><span style="color:#333333; background:beige">PumpMessage(FD_ACCEPT);</span></p> 
<p><span style="color:#333333">PumpMessage</span><span style="color:#333333">作为一个消息泵使得</span><span style="color:#333333">socket window </span><span style="color:#333333">中的消息能够维持在活动状态。</span></p> 
<p><span style="color:#333333">实际跟踪进入</span><span style="color:#333333"> PumpMessage </span><span style="color:#333333">中，发现这个消息泵和</span><span style="color:#333333"> Accept </span><span style="color:#333333">函数的调用并不相关，他只是使非常少的</span><span style="color:#333333">socket window </span><span style="color:#333333">消息（典型的是</span><span style="color:#333333">WM_PAINT </span><span style="color:#333333">窗口重绘消息）处于活动状态，而绝大部分的</span><span style="color:#333333">socket window </span><span style="color:#333333">消息被阻塞，被阻塞的消息中含有</span><span style="color:#333333">WM_SOCKET_NOTIFY </span><span style="color:#333333">。</span></p> 
<p><span style="color:#333333">非常显然，如果没有来自</span><span style="color:#333333"> Client </span><span style="color:#333333">端</span><span style="color:#333333"> socket </span> <span style="color:#333333">的连接请求，</span><span style="color:#333333"> CSocket</span><span style="color:#333333">就会不断调用</span><span style="color:#333333"> Accept </span><span style="color:#333333">产生循环阻塞，直到有来自</span><span style="color:#333333"> Client </span><span style="color:#333333">端</span><span style="color:#333333"> socket </span> <span style="color:#333333">的连接请求而解除阻塞。</span></p> 
<p><span style="color:#333333">阻塞解除后，表示</span><span style="color:#333333"> Server </span><span style="color:#333333">端</span><span style="color:#333333"> socket </span> <span style="color:#333333">和</span><span style="color:#333333"> Client </span><span style="color:#333333">端</span><span style="color:#333333"> socket </span><span style="color:#333333">已成功连接，</span><span style="color:#333333"> Server </span><span style="color:#333333">端和</span><span style="color:#333333"> Client </span> <span style="color:#333333">端彼此相互调用</span><span style="color:#333333"> Send </span> <span style="color:#333333">和</span><span style="color:#333333"> Receive</span><span style="color:#333333">方法开始通信。</span></p> 
<p><strong><span style="color:orange">3. </span><span style="color:orange">非阻塞模式</span></strong></p> 
<p><span style="color:#333333">在非阻塞模式下</span><span style="color:#333333">利用</span><span style="color:#333333"> socket </span><span style="color:#333333">事件</span><span style="color:#333333">的消息机制，</span><span style="color:#333333"> Server </span><span style="color:#333333">端和</span><span style="color:#333333"> Client </span> <span style="color:#333333">端之间的通信处于异步状态下。</span></p> 
<p><span style="color:#333333">通常需要从</span><span style="color:#333333"> CSocket </span> <span style="color:#333333">类派生一个新类，派生新类的目的是重载</span><span style="color:#333333">socket </span><span style="color:#333333">事件</span><span style="color:#333333">的消息函数，然后在</span><span style="color:#333333"> socket </span><span style="color:#333333">事件</span><span style="color:#333333">的消息函数中添入合适的代码以完成</span><span style="color:#333333"> Client </span><span style="color:#333333">端和</span><span style="color:#333333"> Server </span> <span style="color:#333333">端之间的通信，和阻塞模式相比，非阻塞模式无需创建一个新线程。</span></p> 
<p><span style="color:#333333">这里将讨论当</span><span style="color:#333333"> Server </span> <span style="color:#333333">端</span><span style="color:#333333"> socket </span><span style="color:#333333">事件</span><span style="color:#333333">－</span><span style="color:#333333"> FD_ACCEPT </span><span style="color:#333333">被触发后，该事件的处理函数</span><span style="color:#333333">OnAccept </span><span style="color:#333333">是怎么进一步被触发的。其他事件的处理函数如</span><span style="color:#333333">OnConnect, OnReceive </span><span style="color:#333333">等的触发方式和此类似。</span></p> 
<p><span style="color:#333333">在</span><span style="color:#333333"> 1 </span><span style="color:#333333">中已提到</span><span style="color:#333333">Client/Server </span><span style="color:#333333">端通信时，</span><span style="color:#333333">Server </span><span style="color:#333333">端</span><span style="color:#333333">socket </span> <span style="color:#333333">正在接收来自</span><span style="color:#333333">Client </span> <span style="color:#333333">端</span><span style="color:#333333">socket </span><span style="color:#333333">连接请求，这将会触发</span><span style="color:#333333">FD_ACCEPT </span><span style="color:#333333">事件，同时</span><span style="color:#333333">Server </span><span style="color:#333333">端的</span><span style="color:#333333">网络传输服务进程</span><span style="color:#333333">向</span><span style="color:#333333"> Server </span><span style="color:#333333">端的</span><span style="color:#333333"> socketwindow (CSocketWnd </span><span style="color:#333333">）发送事件通知消息</span><span style="color:#333333">WM_SOCKET_NOTIFY , </span><span style="color:#333333">通知有</span><span style="color:#333333">FD_ACCEPT </span><span style="color:#333333">事件产生</span><span style="color:#333333">, CsocketWnd </span><span style="color:#333333">在收到事件通知消息后，调用消息处理函数</span><span style="color:#333333">OnSocketNotify:</span><span style="color:#333333"> </span><span style="color:#333333"><br> <br> <span style="background:beige">LRESULT CSocketWnd::OnSocketNotify(WPARAMwParam, LPARAM lParam)</span></span><span style="color:#333333; background:beige"> </span><span style="color:#333333; background:beige"><br> {<!-- --></span><span style="color:#333333; background:beige"> </span><span style="color:#333333; background:beige"><br>  CSocket::AuxQueueAdd(WM_SOCKET_NOTIFY, wParam, lParam);</span><span style="color:#333333; background:beige"> </span><span style="color:#333333; background:beige"><br>  CSocket::ProcessAuxQueue();</span><span style="color:#333333; background:beige"> </span><span style="color:#333333; background:beige"><br>  return 0L ;</span><span style="color:#333333; background:beige"> </span><span style="color:#333333; background:beige"><br> }</span></p> 
<p><span style="color:#333333">消息参数</span><span style="color:#333333"> wParam </span> <span style="color:#333333">是</span><span style="color:#333333"> socket </span><span style="color:#333333">的句柄，</span><span style="color:#333333"> lParam </span><span style="color:#333333">是</span><span style="color:#333333"> socket </span> <span style="color:#333333">事件</span><span style="color:#333333">。这里稍作解释一下，</span><span style="color:#333333"> CSocketWnd </span><span style="color:#333333">类是作为</span><span style="color:#333333"> CSocket</span><span style="color:#333333">类的</span><span style="color:#333333">友元类</span><span style="color:#333333">，这意味着他能访问</span><span style="color:#333333"> CSocket</span><span style="color:#333333">类中的保护和私有成员函数和变量，</span><span style="color:#333333">AuxQueueAdd </span><span style="color:#333333">和</span><span style="color:#333333">ProcessAuxQueue </span><span style="color:#333333">是</span><span style="color:#333333">CSocket </span> <span style="color:#333333">类的静态成员函数，如果你对友元不熟悉，请迅速找本有关</span><span style="color:#333333">C++ </span><span style="color:#333333">书看一下友元的使用方法吧！</span><span style="color:#333333"> </span><span style="color:#333333"><br> ProcessAuxQueue </span><span style="color:#333333">是实质处理</span><span style="color:#333333">socket </span><span style="color:#333333">事件</span><span style="color:#333333">的函数，在该函数中有这样一句代码：</span></p> 
<p><span style="color:#333333; background:beige">CAsyncSocket* pSocket =CAsyncSocket::LookupHandle((SOCKET)wParam, TRUE);</span></p> 
<p><span style="color:#333333">其实也就是由</span><span style="color:#333333"> socket </span> <span style="color:#333333">句柄得到发送事件通知消息的</span><span style="color:#333333"> socket </span><span style="color:#333333">指针</span><span style="color:#333333"> pSocket</span><span style="color:#333333">：从</span><span style="color:#333333">m_pmapSocketHandle </span><span style="color:#333333">中查找（见</span><span style="color:#333333">1 </span> <span style="color:#333333">）！</span></p> 
<p><span style="color:#333333">最后，</span><span style="color:#333333"> WSAGETSELECTEVENT(lParam) </span><span style="color:#333333">会取出事件类型，在一个简单的</span><span style="color:#333333">switch </span><span style="color:#333333">语句中判断事件类型并调用事件处理函数。</span><span style="color:#333333"> </span><span style="color:#333333"><br> </span><span style="color:#333333">在这里，事件类型是</span><span style="color:#333333">FD_ACCEPT </span><span style="color:#333333">，当然就调用</span><span style="color:#333333">pSocket-&gt;OnAccept </span><span style="color:#333333">！</span></p> 
<p><span style="color:#333333"> </span></p> 
<p><strong><span style="color:orange">本文的结束：</span></strong></p> 
<p><span style="color:#333333">Server </span><span style="color:#333333">端</span><span style="color:#333333"> socket </span><span style="color:#333333">处于阻塞调用模式下，他必须在一个新创建的线程中工作，防止主线程被阻塞。</span></p> 
<p><span style="color:#333333">当有多个</span><span style="color:#333333"> Client </span> <span style="color:#333333">端</span><span style="color:#333333"> socket </span><span style="color:#333333">和</span><span style="color:#333333"> Server </span><span style="color:#333333">端</span><span style="color:#333333"> socket </span> <span style="color:#333333">连接及通信时，</span><span style="color:#333333"> Server </span> <span style="color:#333333">端采用阻塞模式就显得不适合了，应该采用非阻塞模式</span><span style="color:#333333">, </span><span style="color:#333333">利用</span><span style="color:#333333"> socket </span> <span style="color:#333333">事件</span><span style="color:#333333">的消息机制来接受多个</span><span style="color:#333333"> Client </span><span style="color:#333333">端</span><span style="color:#333333"> socket </span> <span style="color:#333333">的连接请求并进行通信。</span></p> 
<p><span style="color:#333333">在非阻塞模式下，利用</span><span style="color:#333333"> CSocketWnd </span><span style="color:#333333">作为所有</span><span style="color:#333333"> sockets</span><span style="color:#333333">的消息池，是实现</span><span style="color:#333333">socket </span><span style="color:#333333">事件</span><span style="color:#333333">的消息机制的关键技术。</span></p> 
<p><span style="color:#333333"><br> </span><span style="color:#333333">文中存在用词不妥和可能存在的技术问题，请大家原谅，也请批评指正，谢谢！</span><span style="color:#333333"> </span><span style="color:#333333"><br> <br> <br> </span><strong><span style="color:orange">注：</span></strong></p> 
<p><span style="color:#333333">1. </span><span style="color:#333333">当前模块状态</span></p> 
<p><span style="color:#333333">用于保存当前线程和模块状态的一个结构，能通过</span><span style="color:#333333">AfxGetThreadModule() </span><span style="color:#333333">获得。</span><span style="color:#333333">AFX_MODULE_THREAD_STATE </span><span style="color:#333333">在</span><span style="color:#333333">CSocket </span> <span style="color:#333333">重新定义为</span><span style="color:#333333">_AFX_SOCK_THREAD_STATE </span><span style="color:#333333">。</span></p> 
<p><span style="color:#333333">2.socket </span><span style="color:#333333">类型</span></p> 
<p><span style="color:#333333">在</span><span style="color:#333333"> TCP/IP </span> <span style="color:#333333">协议中，</span><span style="color:#333333">Client/Server </span> <span style="color:#333333">网络程式采用</span><span style="color:#333333">TCP </span><span style="color:#333333">协议：即</span><span style="color:#333333"> socket </span><span style="color:#333333">类型为</span><span style="color:#333333"> SOCK_STREAM</span><span style="color:#333333">，他是可靠的连接方式。在这里不采用</span><span style="color:#333333">UDP </span><span style="color:#333333">协议：即</span><span style="color:#333333"> socket </span><span style="color:#333333">类型为</span><span style="color:#333333">SOCK_DGRAM </span><span style="color:#333333">，他是不可靠的连接方式。</span></p> 
<p> </p> 
<h3><a target="_blank" name="_Toc376251248"></a><a target="_blank" name="_Toc369176427">从问题看本质：</a>socket到底是什么？</h3> 
<p align="right"><span style="color:#999999">分类：</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/YEYUANGEN/article/category/875918" rel="noopener noreferrer"><span style="color:#336699">4.</span><span style="color:#336699">网络与云</span></a></span><span style="color:#999999">2011-09-2210:32</span><span style="color:#999999"> </span><span style="color:#999999">2151</span><span style="color:#999999">人阅读</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/yeyuangen/article/details/6799575?reload#comments" rel="noopener noreferrer"><span style="color:#336699">评论</span></a></span>(1)<span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" title="收藏"><span style="color:#336699">收藏</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/yeyuangen/article/details/6799575?reload#report" title="举报" rel="noopener noreferrer"><span style="color:#336699">举报</span></a></span></p> 
<p align="left"><span style="color:#333333"><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=socket" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">socket</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">数据结构</span></a></span><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=%e6%9c%8d%e5%8a%a1%e5%99%a8" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">服务器</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=%e7%bd%91%e7%bb%9c" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">网络</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=server" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">server</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=unix" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">unix</span></a></p> 
<p><strong><span style="color:#333333">一、问题的引入</span><span style="color:#333333">——socket</span><span style="color:#333333">的引入是为了解决不同计算机间进程间通信的问题</span></strong></p> 
<p><em><strong><span style="color:#333333">1.socket</span><span style="color:#333333">与进程的关系</span></strong></em></p> 
<p><span style="color:#333333">1).socket</span><span style="color:#333333">与进程间的关系</span><span style="color:#333333">:</span><span style="color:#333333">socket   </span><span style="color:#333333">用来让一个进程和其他的进程互通信息</span><span style="color:#333333">(IPC)</span><span style="color:#333333">，而</span><span style="color:#333333">Socket</span><span style="color:#333333">接口是</span><span style="color:#333333">TCP/IP</span><span style="color:#333333">网络的</span><span style="color:#333333">API</span><span style="color:#333333">接口函数。</span></p> 
<p><span style="color:#333333">2).</span><span style="color:#333333">进程间通信（本机内）</span></p> 
<p><span style="color:#333333">进程间通信（不同计算机，要联网）</span></p> 
<p><span style="color:#333333"> </span></p> 
<p><em><strong><span style="color:#333333">2</span><span style="color:#333333">、</span><span style="color:#333333">socket</span><span style="color:#333333">与文件的关系</span><span style="color:#333333">——</span><span style="color:#333333">如何理解</span><span style="color:#333333">socket</span><span style="color:#333333">是种特殊的</span><span style="color:#333333">I/O?</span></strong></em></p> 
<p><span style="color:#333333">1</span><span style="color:#333333">）</span><span style="color:#333333">Socket</span><span style="color:#333333">最先应用于</span><span style="color:#333333">Unix</span><span style="color:#333333">操作系统</span><span style="color:#333333">,</span><span style="color:#333333">如果了解</span><span style="color:#333333">Unix</span><span style="color:#333333">系统的</span><span style="color:#333333">I/O</span><span style="color:#333333">的话，就很容易了解</span><span style="color:#333333">Socket</span><span style="color:#333333">了，因为</span><span style="color:#333333">Socket</span><span style="color:#333333">数据传输其实就是一种特殊的</span><span style="color:#333333">I/O</span><span style="color:#333333">。</span><span style="color:#333333"> </span></p> 
<p><span style="color:#333333">2</span><span style="color:#333333">）可对其进行文件操作</span></p> 
<p><span style="color:#333333">3</span><span style="color:#333333">）有文件描述符。而文件描述符的本质是一个非负整数。只是用于区分。类似的还有进程</span><span style="color:#333333">ID</span><span style="color:#333333">。</span></p> 
<p><em><strong><span style="color:#333333">3.</span><span style="color:#333333">服务器端口与连接个数的关系</span></strong></em><span style="color:#333333"><br> 1</span><span style="color:#333333">）服务端在</span><span style="color:#333333">8088</span><span style="color:#333333">上监听，然后生成一个新的</span><span style="color:#333333">socket</span><span style="color:#333333">与</span><span style="color:#333333">client</span><span style="color:#333333">通讯。</span><span style="color:#333333">(</span><span style="color:#333333">注意：服务器端监听端口是</span><span style="color:#333333"><br> </span><span style="color:#333333">不变的，但</span><span style="color:#333333">socket</span><span style="color:#333333">连接可以一直生成，一个线程对应一个</span><span style="color:#333333">socket.)<br> </span><span style="color:#333333">同一时刻，一个端口只能建立一个连接。</span><span style="color:#333333"> <br> </span><span style="color:#333333">在一个端口监听，但是在监听端口的同时，生成一个等待队列，每一个来自客户端的连接都会送入等待队列中，服务器利用一定的算法进行选择相应的连接请求处理，所以在一个端口可以监听多各请求嘛。如果同时的连接过多，服务器相应每个连接的时间就会相应的变长。就会变慢。</span><span style="color:#333333"><br> 2</span><span style="color:#333333">）</span><span style="color:#333333">QQ</span><span style="color:#333333">的实现方法就是在登陆的时候告诉服务器你已经登陆，发送消息的时候，首先你会发送一个包给服务器，服务器查看你需要发送的对方是否在线，如果在线就返回包告诉你对方在线，然后你就会和对方建立一个连接，然后直接发消息给对方，如果对方不在线，那么就会通过服务器转发你这次的消息</span><span style="color:#333333"><br> 3</span><span style="color:#333333">）网络</span><span style="color:#333333">IO</span><span style="color:#333333">数与你的</span><span style="color:#333333">CPU</span><span style="color:#333333">数目一致将是比较好的选择（考虑到多线程多进程可以提高效率）。</span><span style="color:#333333"> <br> </span><span style="color:#333333">没有必要每个客户分配一个端口。绝对是一种无谓的浪费。</span><span style="color:#333333"> </span></p> 
<p><span style="color:#333333"><br> <em><strong>4.</strong></em></span><em><strong><span style="color:#333333">有人知道</span><span style="color:#333333">socket</span><span style="color:#333333">监听的一个端口</span><span style="color:#333333">.</span><span style="color:#333333">最多可以有多少个客户连接</span><span style="color:#333333">? </span></strong></em><span style="color:#333333"><br> 1</span><span style="color:#333333">）</span><span style="color:#333333">listen()</span><span style="color:#333333">中有个参数，应该是确定并行连接客户数？！</span><span style="color:#333333"><br> 2</span><span style="color:#333333">）</span><span style="color:#333333">The   maximum   length   of   the  queue   of   pending   connections.   If   this  value   is   SOMAXCONN,   then   the  underlying   service   provider   responsible   for  socket   s   will   set   the   backlog  to   a   maximum   "reasonable "   value.  There   is   no   standard   provision   to  find   out   the   actual   backlog  value.   <br> 3</span><span style="color:#333333">）</span><span style="color:#333333">linux2.4</span><span style="color:#333333">下，最多可以有</span><span style="color:#333333">1024</span><span style="color:#333333">个</span><span style="color:#333333">socket</span><span style="color:#333333">连接</span><span style="color:#333333"><br> 4</span><span style="color:#333333">）同时连接请求好像是</span><span style="color:#333333">5</span><span style="color:#333333">个（是连接请求，不是连接），可保持的链接理论上是</span><span style="color:#333333">65535</span><span style="color:#333333">（</span><span style="color:#333333">2</span><span style="color:#333333">字节的</span><span style="color:#333333">SOCKET</span><span style="color:#333333">端口号），</span></p> 
<p><span style="color:#333333">3.Socket</span><span style="color:#333333">是网络上运行的两个程序间双向通讯的一端，它既可以接受请求，也可以发送请求，利用它可以较为方便的编写网络上数据的传递。</span></p> 
<p><em><strong><span style="color:#333333">5.</span><span style="color:#333333">问：现在</span><span style="color:#333333">server</span><span style="color:#333333">与</span><span style="color:#333333">client</span><span style="color:#333333">想建立</span><span style="color:#333333">socket</span><span style="color:#333333">连接，</span><span style="color:#333333">server</span><span style="color:#333333">仅知道</span><span style="color:#333333">client</span><span style="color:#333333">的</span><span style="color:#333333">IP</span><span style="color:#333333">，端口号不知道，能建立连接吗</span><span style="color:#333333">?</span><span style="color:#333333">怎么建立呢？有没有代码看看？</span></strong></em><span style="color:#333333"><br> </span><span style="color:#333333">答：</span><span style="color:#333333">C</span><span style="color:#333333">和</span><span style="color:#333333">S</span><span style="color:#333333">是相对而言的，发起连接的一方就是</span><span style="color:#333333">C</span><span style="color:#333333">，而监听端口接受连接的一方就是</span><span style="color:#333333">S</span><span style="color:#333333">，</span><span style="color:#333333">C</span><span style="color:#333333">如果不知道</span><span style="color:#333333">S</span><span style="color:#333333">监听的端口，怎么发起连接呢，</span><span style="color:#333333"><br> </span><span style="color:#333333">另外，对于</span><span style="color:#333333">S</span><span style="color:#333333">而言，端口是</span><span style="color:#333333">S</span><span style="color:#333333">上各个服务的区分标志，如果用错误的端口号去连接，是不能获得正确的服务的。</span><span style="color:#333333"><br> <strong><u>client</u></strong></span><strong><u><span style="color:#333333">的端口是不需要指定的，</span><span style="color:#333333">Server</span><span style="color:#333333">绑定端口，然后监听，</span><span style="color:#333333">client</span><span style="color:#333333">使用</span><span style="color:#333333">server</span><span style="color:#333333">的</span><span style="color:#333333">IP</span><span style="color:#333333">和端口建立</span><span style="color:#333333">socket</span><span style="color:#333333">连接</span><span style="color:#333333"> </span></u></strong></p> 
<p><span style="color:#333333"> </span></p> 
<p><strong><span style="color:#333333">6.</span><span style="color:#333333">精彩问答</span></strong></p> 
<p><strong><span style="color:#333333">问</span><span style="color:#333333">：看到的文章上说</span><span style="color:#333333">“</span><span style="color:#333333">每个网络通信循环地进出主计算机的</span><span style="color:#333333">TCP   </span><span style="color:#333333">应用层。它被两个所连接的号码唯一地识别。这两个号码合起来叫做套接字</span><span style="color:#333333">.</span><span style="color:#333333">组成套接字的这两个号码就是机器的</span><span style="color:#333333">IP   </span><span style="color:#333333">地址和</span><span style="color:#333333">TCP   </span> <span style="color:#333333">软件所使用的端口号。</span><span style="color:#333333">” </span></strong><span style="color:#333333"><br> </span><strong><span style="color:#333333">又说</span><span style="color:#333333">“</span><span style="color:#333333">通过</span><span style="color:#333333">socket</span><span style="color:#333333">（）函数可以创建一个套接字，然后再把它绑定到端口号</span><span style="color:#333333">...” </span></strong><span style="color:#333333"><br> </span><strong><span style="color:#333333">那么套接字</span><span style="color:#333333">socket</span><span style="color:#333333">的概念究竟到哪里为止呢？是仅限于</span><span style="color:#333333">socket()</span><span style="color:#333333">返回的文件描述符？还是是</span><span style="color:#333333">IP</span><span style="color:#333333">和端口号的组合？如果是，那么</span><span style="color:#333333">socket()</span><span style="color:#333333">调用之后产生的套接字描述符的作用是什么呢？</span><span style="color:#333333">   </span><span style="color:#333333">套接字描述符，</span><span style="color:#333333">IP</span><span style="color:#333333">地址，端口号三者间的关系是怎样的？</span><span style="color:#333333"> </span></strong><span style="color:#333333"><br> </span><strong><span style="color:#333333">谢谢各位前辈解答。</span></strong><span style="color:#333333"><br> </span><strong><span style="color:#333333">答</span><span style="color:#333333">：一个</span><span style="color:#333333">socket</span><span style="color:#333333">句柄代表两个地址对</span><span style="color:#333333">   “</span><span style="color:#333333">本地</span><span style="color:#333333">ip:port”--“</span><span style="color:#333333">远程</span><span style="color:#333333">ip:port”</span></strong><span style="color:#333333"><br> </span><strong><span style="color:#333333">问</span><span style="color:#333333">：那么</span><span style="color:#333333">socket</span><span style="color:#333333">的概念到底到那里为止呢？比如，利用</span><span style="color:#333333">socket()</span><span style="color:#333333">可以产生一个套接字句柄，可是在</span><span style="color:#333333">bind()   </span><span style="color:#333333">或者</span><span style="color:#333333">   connect   ()   </span><span style="color:#333333">之前它只是一个文件描述符，和</span><span style="color:#333333">linux</span><span style="color:#333333">中其他的文件描述符一样。</span><span style="color:#333333"> </span></strong><span style="color:#333333"><br> </span><strong><span style="color:#333333">如果说</span><span style="color:#333333">socket</span><span style="color:#333333">代表一个两个地址对，那么句柄的作用是不是仅仅是在</span><span style="color:#333333">bind()   </span><span style="color:#333333">或者</span><span style="color:#333333">   connect   ()   </span><span style="color:#333333">之后的用于区分和标记这样的地址对呢？因为这样他才能和网络的概念联系起来。这样的话，</span><span style="color:#333333">socket</span><span style="color:#333333">的意义应该是说用文件描述符描述的通信双方的</span><span style="color:#333333">IP</span><span style="color:#333333">地址和端口号地址对？（而文件描述符是区分这些地址对的标记？</span><span style="color:#333333">)</span></strong><span style="color:#333333"><br> </span><strong><span style="color:#333333">答</span><span style="color:#333333">：</span><span style="color:#333333">socket</span><span style="color:#333333">为内核对象，由操作系统内核来维护其缓冲区，引用计数，并且可以在多个进程中使用。</span><span style="color:#333333"> </span></strong><span style="color:#333333"><br> </span><strong><span style="color:#333333">至于称它为</span><span style="color:#333333">“</span><span style="color:#333333">句柄</span><span style="color:#333333">”“</span><span style="color:#333333">文件描述符</span><span style="color:#333333">”</span><span style="color:#333333">都是一样的，它只不过是内核开放给用户进程使用的整数而已</span></strong><span style="color:#333333"><br> </span><strong><span style="color:#333333">问：谢谢楼上，是我没描述清楚。对于</span><span style="color:#333333">“</span><span style="color:#333333">句柄</span><span style="color:#333333">”</span><span style="color:#333333">和</span><span style="color:#333333">“</span><span style="color:#333333">文件描述符</span><span style="color:#333333">”</span><span style="color:#333333">我没有异议。</span><span style="color:#333333"> </span></strong><span style="color:#333333"><br> </span><strong><span style="color:#333333">我想我的问题是在于句柄和</span><span style="color:#333333">ip</span><span style="color:#333333">、</span><span style="color:#333333">port</span><span style="color:#333333">的关系，不知道我这样说对否：</span><span style="color:#333333"> </span></strong><span style="color:#333333"><br> <strong>1.   </strong></span><strong><span style="color:#333333">每一个</span><span style="color:#333333">socket   </span><span style="color:#333333">本质上都是指一个</span><span style="color:#333333">ip</span><span style="color:#333333">地址和端口对</span><span style="color:#333333"> </span></strong><span style="color:#333333"><br> <strong>2.   </strong></span><strong><span style="color:#333333">为了操作这样的地址对，使用了文件描述符</span><span style="color:#333333"> </span></strong><span style="color:#333333"><br> <strong>3.   socket</strong></span><strong><span style="color:#333333">（）函数只创建了一个普通的文件描述符，在进行</span><span style="color:#333333">bind</span><span style="color:#333333">（）或者</span><span style="color:#333333">connect()</span><span style="color:#333333">之前并不能说创建了用于网络通讯的套接字</span><span style="color:#333333"> </span></strong><span style="color:#333333"><br> <strong>4.   </strong></span><strong><span style="color:#333333">只有在进行了</span><span style="color:#333333">bind</span><span style="color:#333333">（）或者</span><span style="color:#333333">connect()</span><span style="color:#333333">之后</span><span style="color:#333333">socket</span><span style="color:#333333">才被创立起来</span></strong><span style="color:#333333"><br> </span><strong><span style="color:#333333">答</span><span style="color:#333333">：</span><span style="color:#333333">socket</span><span style="color:#333333">（）创建了一个</span><span style="color:#333333">socket</span><span style="color:#333333">内核对象。</span><span style="color:#333333"> </span></strong><span style="color:#333333"><br> <strong>accept</strong></span><strong><span style="color:#333333">或者</span><span style="color:#333333">connect</span><span style="color:#333333">后，才可以对</span><span style="color:#333333">socket</span><span style="color:#333333">句柄读写。因为只有在</span><span style="color:#333333">   connect</span><span style="color:#333333">或者</span><span style="color:#333333">bind,listen,accept</span><span style="color:#333333">后才会设置好</span><span style="color:#333333">socket</span><span style="color:#333333">内核对象里边的</span><span style="color:#333333">ip</span><span style="color:#333333">和端口</span><span style="color:#333333"> </span></strong></p> 
<p><strong><span style="color:#333333">二、</span><span style="color:#333333">socket</span><span style="color:#333333">和端口理解</span></strong></p> 
<p><span style="color:#333333">一个</span><span style="color:#333333">socket</span><span style="color:#333333">句柄代表两个地址对</span><span style="color:#333333"> “</span><span style="color:#333333">本地</span><span style="color:#333333">ip:port”--“</span><span style="color:#333333">远程</span><span style="color:#333333">ip:port” <br> </span><span style="color:#333333">在</span><span style="color:#333333">windows</span><span style="color:#333333">下叫句柄，在</span><span style="color:#333333">linux</span><span style="color:#333333">下叫文件描述符</span><span style="color:#333333"> <br> socket</span><span style="color:#333333">为内核对象，由操作系统内核来维护其缓冲区，引用计数，并且可以在多个进程中使用。</span><span style="color:#333333"> </span><span style="color:#333333">至于称它为</span><span style="color:#333333">“</span><span style="color:#333333">句柄</span><span style="color:#333333">”“</span><span style="color:#333333">文件描述符</span><span style="color:#333333">”</span><span style="color:#333333">都是一样的</span><span style="color:#333333"><br> </span><span style="color:#333333">我假定读者已经对于</span><span style="color:#333333">socket</span><span style="color:#333333">连接的建立过程和各种状态转换比较熟悉了，因为这篇文档的目的是澄清概念，而不是介绍概念。</span><span style="color:#333333"> <br> </span><span style="color:#333333">在使用</span><span style="color:#333333">socket</span><span style="color:#333333">编程时，我们都知道在网络通信以前首先要建立连接，而连接的建立是通过对</span><span style="color:#333333">socket</span><span style="color:#333333">的一些操作来完成的。那么，建立连接的过程大致可以分为以下几步：</span><span style="color:#333333"> <br> 1</span><span style="color:#333333">）</span><span style="color:#333333">建立</span><span style="color:#333333">socket</span><span style="color:#333333">套接字。</span><span style="color:#333333"> <br> 2</span><span style="color:#333333">）</span><span style="color:#333333">给套接字赋予地址，这个地址不是通常的网络地址的概念。</span><span style="color:#333333"> <br> 3</span><span style="color:#333333">）</span><span style="color:#333333">建立</span><span style="color:#333333">socket</span><span style="color:#333333">连接。</span><span style="color:#333333"> <br> <br> 1</span><span style="color:#333333">．</span><span style="color:#333333">建立</span><span style="color:#333333">socket</span><span style="color:#333333">套接字。</span><span style="color:#333333"> <br> </span><span style="color:#333333">使用</span><span style="color:#333333">socket</span><span style="color:#333333">建立套接字的时候，我们实际上是建立了一个数据结构。这个数据结构最主要</span><span style="color:#333333"><br> </span><span style="color:#333333">的信息是指定了连接的种类和使用的协议，此外还有一些关于连接队列操作的结构字段</span><span style="color:#333333"><br> </span><span style="color:#333333">（这里就先不涉及他们了）。</span><span style="color:#333333"> <br> </span><span style="color:#333333">当我们使用</span><span style="color:#333333">socket</span><span style="color:#333333">函数以后，如果成功的话会返回一个</span><span style="color:#333333">int</span><span style="color:#333333">型的描述符，它指向前面那个</span><span style="color:#333333"><br> </span><span style="color:#333333">被维护在内核里的</span><span style="color:#333333">socket</span><span style="color:#333333">数据结构。我们的任何操作都是通过这个描述符而作用到那个数</span><span style="color:#333333"><br> </span><span style="color:#333333">据结构上的。这就像是我们在建立一个文件后得到一个文件描述符一样，对文件的操作都</span><span style="color:#333333"><br> </span><span style="color:#333333">是通过文件描述符来进行的，而不是直接作用到</span><span style="color:#333333">inode</span><span style="color:#333333">数据结构上。我之所以用文件描述</span><span style="color:#333333"><br> </span><span style="color:#333333">符举例，是因为</span><span style="color:#333333">socket</span><span style="color:#333333">数据结构也是和</span><span style="color:#333333">inode</span><span style="color:#333333">数据结构密切相关，它不是独立存在于内核</span><span style="color:#333333"><br> </span><span style="color:#333333">中的，而是位于一个</span><span style="color:#333333">VFS inode</span><span style="color:#333333">结构中。所以，有一些比较抽象的特性，我们可以用文件</span><span style="color:#333333"><br> </span><span style="color:#333333">操作来不恰当的进行类比以加深理解。</span><span style="color:#333333"> <br> </span><span style="color:#333333">如前所述，当建立了这个套接字以后，我们可以获得一个象文件描述符那样的套接字描述</span><span style="color:#333333"><br> </span><span style="color:#333333">符。就象我们对文件进行操作那样，我们可以通过向套接字里面写数据将数据传送到我们</span><span style="color:#333333"><br> </span><span style="color:#333333">指定的地方，这个地方可以是远端的主机，也可以是本地的主机。如果你有兴趣的话，还</span><span style="color:#333333"><br> </span><span style="color:#333333">可以用</span><span style="color:#333333">socket</span><span style="color:#333333">机制来实现</span><span style="color:#333333">IPC</span><span style="color:#333333">，不过效率比较低，试试也就行了（我没有试过）。</span><span style="color:#333333"> <br> <br> 2</span><span style="color:#333333">．</span><span style="color:#333333">给套接字赋予地址。</span><span style="color:#333333"> <br> </span><span style="color:#333333">依照建立套接字的目的不同，赋予套接字地址的方式有两种：服务器端使用</span><span style="color:#333333">bind</span><span style="color:#333333">，客户端</span><span style="color:#333333"><br> </span><span style="color:#333333">使用</span><span style="color:#333333">connetc</span><span style="color:#333333">。</span><span style="color:#333333"> <br> Bind: <br> </span><span style="color:#333333">我们都知道，只要使用</span><span style="color:#333333">IP, prot</span><span style="color:#333333">就可以区分一个</span><span style="color:#333333">tcp/ip</span><span style="color:#333333">连接（当然这个连接指的是一个</span><span style="color:#333333"><br> </span><span style="color:#333333">连接通道，如果要区分特定的主机间的连接，还需要第三个属性</span><span style="color:#333333"> hostname</span><span style="color:#333333">）。</span><span style="color:#333333"> <br> </span><span style="color:#333333">我们可以使用</span><span style="color:#333333">bind</span><span style="color:#333333">函数来为一个使用在服务器端例程中的套接字赋予通信的地址和端口。</span><span style="color:#333333"><br> </span><span style="color:#333333">在这里我们称通信的</span><span style="color:#333333">IP</span><span style="color:#333333">地址和端口合起来构成了一个</span><span style="color:#333333">socket</span><span style="color:#333333">地址，而指定一个</span><span style="color:#333333">socket</span><span style="color:#333333">使</span><span style="color:#333333"><br> </span><span style="color:#333333">用特定的</span><span style="color:#333333">IP</span><span style="color:#333333">和</span><span style="color:#333333">port</span><span style="color:#333333">组合来进行通行的过程就是赋予这个</span><span style="color:#333333">socket</span><span style="color:#333333">一个地址。</span><span style="color:#333333"> <br> </span><span style="color:#333333">要赋予</span><span style="color:#333333">socket</span><span style="color:#333333">地址，就得使用一个数据结构来指明特定的</span><span style="color:#333333">socket</span><span style="color:#333333">地址，这个数据结构就</span><span style="color:#333333"><br> </span><span style="color:#333333">是</span><span style="color:#333333">struct sockaddr</span><span style="color:#333333">。对它的使用我就不说了，因为这篇文档的目的是澄清概念而不是说</span><span style="color:#333333"><br> </span><span style="color:#333333">明使用方法。</span><span style="color:#333333">Bind</span><span style="color:#333333">函数的作用就是将这个特定的标注有</span><span style="color:#333333">socket</span><span style="color:#333333">地址信息的数据结构和</span><span style="color:#333333"><br> socket</span><span style="color:#333333">套接字联系起来，即赋予这个套接字一个地址。但是在具体实现上，他们两个是怎</span><span style="color:#333333"><br> </span><span style="color:#333333">么联系在一起的，我还不知道。</span><span style="color:#333333"> <br> </span><span style="color:#333333">一个特定的</span><span style="color:#333333">socket</span><span style="color:#333333">的地址的生命期是</span><span style="color:#333333">bind</span><span style="color:#333333">成功以后到连接断开前。你可以建立一个</span><span style="color:#333333"><br> socket</span><span style="color:#333333">数据结构和</span><span style="color:#333333">socket</span><span style="color:#333333">地址的数据结构，但是在没有</span><span style="color:#333333">bind</span><span style="color:#333333">以前他们两个是没有关系</span><span style="color:#333333"><br> </span><span style="color:#333333">的，在</span><span style="color:#333333">bind</span><span style="color:#333333">以后他们两个才有了关系。这种关系一直维持到连接的结束，当一个连接结束</span><span style="color:#333333"><br> </span><span style="color:#333333">时，</span><span style="color:#333333">socket</span><span style="color:#333333">数据结构和</span><span style="color:#333333">socket</span><span style="color:#333333">地址的数据结构还都存在，但是他们两个已经没有关系</span><span style="color:#333333"><br> </span><span style="color:#333333">了。如果你要是用这个套接字在</span><span style="color:#333333">socket</span><span style="color:#333333">地址上重新进行连接时，需重新</span><span style="color:#333333">bind</span><span style="color:#333333">他们两个。再</span><span style="color:#333333"><br> </span><span style="color:#333333">注明一次，我说的这个连接是一个连接通道，而不是特定的主机之间的连接。</span><span style="color:#333333"> <br> Bind</span><span style="color:#333333">指定的</span><span style="color:#333333">IP</span><span style="color:#333333">通常是本地</span><span style="color:#333333">IP</span><span style="color:#333333">（一般不特别指定，而使用</span><span style="color:#333333">INADDR_ANY</span><span style="color:#333333">来声明），而最主要</span><span style="color:#333333"><br> </span><span style="color:#333333">的作用是指定端口。在服务器端的</span><span style="color:#333333">socket</span><span style="color:#333333">进行了</span><span style="color:#333333">bind</span><span style="color:#333333">以后就是用</span><span style="color:#333333">listen</span><span style="color:#333333">来在这个</span><span style="color:#333333">socket<br> </span><span style="color:#333333">地址上准备进行连接。</span><span style="color:#333333"> <br> connect: <br> </span><span style="color:#333333">对于客户端来说，是不会使用</span><span style="color:#333333">bind</span><span style="color:#333333">的（并不是不能用，但没什么意义），他们会通过</span><span style="color:#333333"><br> connet</span><span style="color:#333333">函数来建立</span><span style="color:#333333">socket</span><span style="color:#333333">和</span><span style="color:#333333">socket</span><span style="color:#333333">地址之间的关系。其中的</span><span style="color:#333333">socket</span><span style="color:#333333">地址是它想要连接的</span><span style="color:#333333"><br> </span><span style="color:#333333">服务器端的</span><span style="color:#333333">socket</span><span style="color:#333333">地址。在</span><span style="color:#333333">connect</span><span style="color:#333333">建立</span><span style="color:#333333">socket</span><span style="color:#333333">和</span><span style="color:#333333">socket</span><span style="color:#333333">地址两者关系的同时，它也在</span><span style="color:#333333"><br> </span><span style="color:#333333">尝试着建立远端的连接。</span><span style="color:#333333"> <br> 3</span><span style="color:#333333">．</span><span style="color:#333333">建立</span><span style="color:#333333">socket</span><span style="color:#333333">连接。</span><span style="color:#333333"> <br> </span><span style="color:#333333">对于准备建立一个连接，服务器端要两个步骤：</span><span style="color:#333333">bind, listen</span><span style="color:#333333">；客户端一个步骤：</span><span style="color:#333333"><br> connct</span><span style="color:#333333">。如果服务器端</span><span style="color:#333333">accept</span><span style="color:#333333">一个</span><span style="color:#333333">connect</span><span style="color:#333333">，而客户端得到了这个</span><span style="color:#333333">accept</span><span style="color:#333333">的确认，那么</span><span style="color:#333333"><br> </span><span style="color:#333333">一个连接就建立了。</span><span style="color:#333333"><br>  </span></p> 
<p><strong><span style="color:#333333">三、客户</span><span style="color:#333333">/</span></strong><span style="color:#333333"><a target="_blank" href="http://server.chinaitlab.com/" rel="nofollow noopener noreferrer"><strong><span style="color:#333333">服务器</span></strong></a></span><strong><span style="color:#333333">模式模式的理解</span></strong></p> 
<p><span style="color:#333333">   </span><span style="color:#333333">客户</span><span style="color:#333333">/</span><span style="color:#333333">服务器模式采取的是主动请求方式：</span></p> 
<p><span style="color:#333333">   </span><span style="color:#333333">首先服务器方要先启动，并根据请求提供相应服务：</span></p> 
<p><span style="color:#333333">   1. </span><span style="color:#333333">打开一通信通道并告知本地主机，它愿意在某一公认地址上（周知口，如</span><span style="color:#333333">FTP</span><span style="color:#333333">为</span><span style="color:#333333">21</span><span style="color:#333333">）接收客户请求；</span></p> 
<p><span style="color:#333333">   2. </span><span style="color:#333333">等待客户请求到达该端口；</span></p> 
<p><span style="color:#333333">   3. </span><span style="color:#333333">接收到重复服务请求，处理该请求并发送应答信号。接收到并发服务请求，要激活一新进程来处理这个客户请求（如</span><span style="color:#333333">UNIX</span><span style="color:#333333">系统中用</span><span style="color:#333333">fork</span><span style="color:#333333">、</span><span style="color:#333333">exec</span><span style="color:#333333">）。新进程处理此客户请求，并不需要对其它请求作出应答。服务完成后，关闭此新进程与客户的通信链路，并终止。</span></p> 
<p><span style="color:#333333">   4. </span><span style="color:#333333">返回第二步，等待另一客户请求。</span></p> 
<p><span style="color:#333333">   5. </span><span style="color:#333333">关闭服务器</span></p> 
<p><span style="color:#333333">   </span><span style="color:#333333">客户方：</span></p> 
<p><span style="color:#333333">   1. </span><span style="color:#333333">打开一通信通道，并连接到服务器所在主机的特定端口；</span></p> 
<p><span style="color:#333333">   2. </span><span style="color:#333333">向服务器发服务请求报文，等待并接收应答；继续提出请求</span><span style="color:#333333">......</span></p> 
<p><span style="color:#333333">   3. </span><span style="color:#333333">请求结束后关闭通信通道并终止。</span></p> 
<p><span style="color:#333333">   </span><span style="color:#333333">从上面所描述过程可知：</span></p> 
<p><span style="color:#333333">   1. </span><span style="color:#333333">客户与服务器进程的作用是非对称的，因此编码不同。</span></p> 
<p><span style="color:#333333">   2. </span><span style="color:#333333">服务进程一般是先涌纪</span><span style="color:#333333"></span><span style="color:#333333">纪</span><span style="color:#333333"></span><span style="color:#333333">户请求而启动的。只要系统运行，该服务进程一直存在，直到正常或强迫终止。</span></p> 
<h3><a target="_blank" name="_Toc376251249"></a><a target="_blank" name="_Toc369176428">半双工通信</a></h3> 
<p>即Half-duplexCommunication。这种<a target="_blank" href="http://baike.baidu.com/view/250713.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">通信方式</span></a>可以实现双向的通信，但不能在两个方向上同时进行，必须轮流交替地进行。也就是说，通信信道的每一段都可以是发送端，也可以是接收端。但同一时刻里，信息只能有一个传输方向。如日常生活中的例子有步话机通信,对讲机等。</p> 
<p>半双工传输的协议是称为线路规程的过程的一部分，它是<a target="_blank" href="http://baike.baidu.com/view/571842.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">OSI</span><span style="color:#136EC2">模型</span></a>的第二层，数据链路层所包含的一项功能</p> 
<h3><a target="_blank" name="_Toc376251250"></a><a target="_blank" name="_Toc369176429">MFC</a>打开/保存文件对话框:CFileDialog</h3> 
<p style="background:#FAF7EF"><strong><span style="color:#393939">CFileDialog</span></strong></p> 
<p style="background:#FAF7EF"><span style="color:#393939"><br> </span><span style="color:#393939">文件选择对话框的使用：首先构造一个对象并提供相应的参数，构造函数原型如下：</span><span style="color:#393939"> </span><span style="color:#393939"><br> CFileDialog::CFileDialog( BOOL bOpenFileDialog,</span></p> 
<p style="background:#FAF7EF"><span style="color:#393939">LPCTSTRlpszDefExt = NULL,</span></p> 
<p style="background:#FAF7EF"><span style="color:#393939">LPCTSTRlpszFileName = NULL,</span></p> 
<p style="background:#FAF7EF"><span style="color:#393939">DWORDdwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,</span></p> 
<p style="background:#FAF7EF"><span style="color:#393939"> LPCTSTRlpszFilter = NULL,</span></p> 
<p style="background:#FAF7EF"><span style="color:#393939">CWnd*pParentWnd = NULL ,</span></p> 
<p style="background:#FAF7EF"><span style="color:#393939"> DWORDdwSize = 0<br> );<br> <br> <br> <br> </span><span style="color:#393939">参数意义如下：</span><span style="color:#393939"> </span><span style="color:#393939"><br> <br> bOpenFileDialog </span><span style="color:#393939">为</span><span style="color:#393939">TRUE</span><span style="color:#393939">则显示打开对话框，为</span><span style="color:#393939">FALSE</span><span style="color:#393939">则显示保存对话文件对话框。</span><span style="color:#393939"> </span><span style="color:#393939"><br> lpszDefExt </span><span style="color:#393939">指定默认的文件扩展名。</span><span style="color:#393939"> </span><span style="color:#393939"><br> lpszFileName </span><span style="color:#393939">指定默认的文件名。</span><span style="color:#393939"> </span><span style="color:#393939"><br> dwFlags </span><span style="color:#393939">指明一些特定风格。</span><span style="color:#393939"> </span><span style="color:#393939"><br> lpszFilter </span><span style="color:#393939">是最重要的一个参数，它指明可供选择的文件类型和相应的扩展名。参数格式如：</span><span style="color:#393939"> </span><span style="color:#393939"><br> "<a target="_blank" name="OLE_LINK3">Chart Files (*.xlc)|*.xlc|Worksheet Files(*.xls)|*.xls|Data Files (*.xlc;*.xls)|*.xlc; *.xls|All Files (*.*)|*.*||"</a>;</span><span style="color:#393939">文件类型说明和扩展名间用</span><span style="color:#393939"> | </span><span style="color:#393939">分隔，同种类型文件的扩展名间可以用</span><span style="color:#393939"> ; </span><span style="color:#393939">分割，每种文件类型间用</span><span style="color:#393939"> | </span><span style="color:#393939">分隔，末尾用</span><span style="color:#393939"> || </span> <span style="color:#393939">指明。</span><span style="color:#393939"> </span><span style="color:#393939"><br> pParentWnd </span><span style="color:#393939">为父窗口指针。</span></p> 
<p style="background:#FAF7EF"><span style="color:#393939">dwSize</span></p> 
<p style="background:#FAF7EF"><span style="color:#393939">The size of the </span><strong>OPENFILENAME</strong> structure. This value is dependent onthe operating system version, so MFC can determine the appropriate kind ofdialog box to create (for example, new Windows 2000 dialogs as opposed to NT4dialogs). The default size of 0 means that the MFC code will determine theproper dialog box size to use based on the operating system version on whichthe program is run.</p> 
<p style="background:#FAF7EF"><span style="color:#393939"><br> </span><span style="color:#393939">创建文件对话框可以使用</span><span style="color:#393939">DoModal()</span><span style="color:#393939">，在返回后可以利用下面的函数得到用户选择：</span><span style="color:#393939"> </span><span style="color:#393939"><br> CString CFileDialog::GetPathName( ) </span><span style="color:#393939">得到完整的文件名，包括目录名和扩展名如：</span><span style="color:#393939">c: est est1.txt </span><br> CString CFileDialog::GetFileName( ) <span style="color:#393939">得到完整的文件名，包括扩展名如：</span><span style="color:#393939">test1.txt </span><br> CString CFileDialog::GetExtName( ) <span style="color:#393939">得到完整的文件扩展名，如：</span><span style="color:#393939">txt </span><br> CString CFileDialog::GetFileTitle ( ) <span style="color:#393939">得到完整的文件名，不包括目录名和扩展名如：</span><span style="color:#393939">test1 </span><br> POSITION CFileDialog::GetStartPosition( ) <span style="color:#393939">对于选择了多个文件的情况得到第一个文件位置。</span><span style="color:#393939"> </span><span style="color:#393939"><br> CString CFileDialog::GetNextPathName( POSITION&amp; pos ) </span><span style="color:#393939">对于选择了多个文件的情况得到下一个文件位置，并同时返回当前文件名。但必须已经调用过</span><span style="color:#393939">POSITION CFileDialog::GetStartPosition( )</span><span style="color:#393939">来得到最初的</span><span style="color:#393939">POSITION</span><span style="color:#393939">变量。</span><span style="color:#393939"> </span><span style="color:#393939"><br> <br> <br> <br> </span><span style="color:#393939">例如</span><span style="color:#393939"><br> <br> {<!-- --><br> CString </span><br> FilePathName;<br> CFileDialog dlg(TRUE);///TRUE<span style="color:#393939">为</span><span style="color:#393939">OPEN</span><span style="color:#393939">对话框，</span><span style="color:#393939">FALSE</span><span style="color:#393939">为</span><span style="color:#393939">SAVE AS</span><span style="color:#393939">对话框</span></p> 
<p style="background:#FAF7EF"><span style="color:#393939">//dlg.m_ofn.lpstrInitialDir=_T("d:\\"); //</span><span style="color:#393939">这里就设置了对话框的默认目录</span><span style="color:#393939">d</span><span style="color:#393939">盘</span></p> 
<p style="background:#FAF7EF"><span style="color:#393939">if(dlg.DoModal()==IDOK)<br> FilePathName=dlg.GetPathName();<br> } </span><br> <span style="color:#393939">相关信息：</span><span style="color:#393939">CFileDialog</span><span style="color:#393939">用于取文件名的几个成员函数：</span><span style="color:#393939"><br> </span><span style="color:#393939">假如选择的文件是</span><span style="color:#393939">C:WINDOWSTEST.EXE<br> </span><span style="color:#393939">则</span><span style="color:#393939">:<br> (1)GetPathName();</span><span style="color:#393939">取文件名全称，包括完整路径。取回</span><span style="color:#393939">C:WINDOWSTEST.EXE<br> (2)GetFileTitle();</span><span style="color:#393939">取文件全名：</span><span style="color:#393939">TEST.EXE<br> (3)GetFileName();</span><span style="color:#393939">取回</span><span style="color:#393939">TEST<br> (4)GetFileExt();</span><span style="color:#393939">取扩展名</span><span style="color:#393939">EXE</span></p> 
<p><a target="_blank" name="_Toc376251251"></a><a target="_blank" name="_Toc369176430">setsockopt</a>的各种使用<br> <span style="color:#333333; background:whitesmoke">1. </span><span style="color:#333333; background:whitesmoke">如果在已经处于</span><span style="color:#333333; background:whitesmoke"> ESTABLISHED</span><span style="color:#333333; background:whitesmoke">状态下的</span><span style="color:#333333; background:whitesmoke">socket(</span><span style="color:#333333; background:whitesmoke">一般由端口号和标志符区分）调用</span><span style="color:#333333"><br> <span style="background:whitesmoke">closesocket</span></span><span style="color:#333333; background:whitesmoke">（一般不会立即关闭而经历</span><span style="color:#333333; background:whitesmoke">TIME_WAIT</span><span style="color:#333333; background:whitesmoke">的过程）后想继续重用该</span><span style="color:#333333; background:whitesmoke">socket</span><span style="color:#333333; background:whitesmoke">：</span><span style="color:#333333"><br> <span style="background:whitesmoke">BOOL bReuseaddr=TRUE;</span><br> <span style="background:whitesmoke">setsockopt(s,SOL_SOCKET ,SO_REUSEADDR,(const char*)&amp;bReuseaddr,sizeof(BOOL));</span><br> <span style="background:whitesmoke">2. </span></span><span style="color:#333333; background:whitesmoke">如果要已经处于连接状态的</span><span style="color:#333333; background:whitesmoke">soket</span><span style="color:#333333; background:whitesmoke">在调用</span><span style="color:#333333; background:whitesmoke">closesocket</span><span style="color:#333333; background:whitesmoke">后强制关闭，不经历</span><span style="color:#333333"><br> <span style="background:whitesmoke">TIME_WAIT</span></span><span style="color:#333333; background:whitesmoke">的过程：</span><span style="color:#333333"><br> <span style="background:whitesmoke">BOOL bDontLinger = FALSE; </span><br> <span style="background:whitesmoke">setsockopt(s,SOL_SOCKET,SO_DONTLINGER,(const char*)&amp;bDontLinger,sizeof(BOOL));</span><br> <span style="background:whitesmoke">3.</span></span><span style="color:#333333; background:whitesmoke">在</span><span style="color:#333333; background:whitesmoke">send(),recv()</span><span style="color:#333333; background:whitesmoke">过程中有时由于网络状况等原因，发收不能预期进行</span><span style="color:#333333; background:whitesmoke">,</span><span style="color:#333333; background:whitesmoke">而设置收发时限：</span><span style="color:#333333"><br> <span style="background:whitesmoke">int nNetTimeout=1000;//1</span></span><span style="color:#333333; background:whitesmoke">秒</span><span style="color:#333333"><br> <span style="background:whitesmoke">//</span></span><span style="color:#333333; background:whitesmoke">发送时限</span><span style="color:#333333"><br> <span style="background:whitesmoke">setsockopt(socket</span></span><span style="color:#333333; background:whitesmoke">，</span><span style="color:#333333; background:whitesmoke">SOL_S0CKET,SO_SNDTIMEO</span><span style="color:#333333; background:whitesmoke">，</span><span style="color:#333333; background:whitesmoke">(char *)&amp;nNetTimeout,sizeof(int));</span><span style="color:#333333"><br> <span style="background:whitesmoke">//</span></span><span style="color:#333333; background:whitesmoke">接收时限</span><span style="color:#333333"><br> <span style="background:whitesmoke">setsockopt(socket</span></span><span style="color:#333333; background:whitesmoke">，</span><span style="color:#333333; background:whitesmoke">SOL_S0CKET,SO_RCVTIMEO</span><span style="color:#333333; background:whitesmoke">，</span><span style="color:#333333; background:whitesmoke">(char *)&amp;nNetTimeout,sizeof(int));</span><span style="color:#333333"><br> <span style="background:whitesmoke">4.</span></span><span style="color:#333333; background:whitesmoke">在</span><span style="color:#333333; background:whitesmoke">send()</span><span style="color:#333333; background:whitesmoke">的时候，返回的是实际发送出去的字节</span><span style="color:#333333; background:whitesmoke">(</span><span style="color:#333333; background:whitesmoke">同步</span><span style="color:#333333; background:whitesmoke">)</span><span style="color:#333333; background:whitesmoke">或发送到</span><span style="color:#333333; background:whitesmoke">socket</span><span style="color:#333333; background:whitesmoke">缓冲区的字节</span><span style="color:#333333"><br> <span style="background:whitesmoke">(</span></span><span style="color:#333333; background:whitesmoke">异步</span><span style="color:#333333; background:whitesmoke">);</span><span style="color:#333333; background:whitesmoke">系统默认的状态发送和接收一次为</span><span style="color:#333333; background:whitesmoke">8688</span><span style="color:#333333; background:whitesmoke">字节</span><span style="color:#333333; background:whitesmoke">(</span><span style="color:#333333; background:whitesmoke">约为</span><span style="color:#333333; background:whitesmoke">8.5K)</span><span style="color:#333333; background:whitesmoke">；在实际的过程中发送数据</span><span style="color:#333333"><br> </span><span style="color:#333333; background:whitesmoke">和接收数据量比较大，可以设置</span><span style="color:#333333; background:whitesmoke">socket</span><span style="color:#333333; background:whitesmoke">缓冲区，而避免了</span><span style="color:#333333; background:whitesmoke">send(),recv()</span><span style="color:#333333; background:whitesmoke">不断的循环收发：</span><span style="color:#333333"><br> <span style="background:whitesmoke">// </span></span><span style="color:#333333; background:whitesmoke">接收缓冲区</span><span style="color:#333333"><br> <span style="background:whitesmoke">int nRecvBuf=32*1024;//</span></span><span style="color:#333333; background:whitesmoke">设置为</span><span style="color:#333333; background:whitesmoke">32K</span><span style="color:#333333"><br> <span style="background:whitesmoke">setsockopt(s,SOL_SOCKET,SO_RCVBUF,(const char*)&amp;nRecvBuf,sizeof(int));</span><br> <span style="background:whitesmoke">//</span></span><span style="color:#333333; background:whitesmoke">发送缓冲区</span><span style="color:#333333"><br> <span style="background:whitesmoke">int nSendBuf=32*1024;//</span></span><span style="color:#333333; background:whitesmoke">设置为</span><span style="color:#333333; background:whitesmoke">32K</span><span style="color:#333333"><br> <span style="background:whitesmoke">setsockopt(s,SOL_SOCKET,SO_SNDBUF,(const char*)&amp;nSendBuf,sizeof(int));</span><br> <span style="background:whitesmoke">5. </span></span><span style="color:#333333; background:whitesmoke">如果在发送数据的时，希望不经历由系统缓冲区到</span><span style="color:#333333; background:whitesmoke">socket</span><span style="color:#333333; background:whitesmoke">缓冲区的拷贝而影响</span><span style="color:#333333"><br> </span><span style="color:#333333; background:whitesmoke">程序的性能：</span><span style="color:#333333"><br> <span style="background:whitesmoke">int nZero=0;</span><br> <span style="background:whitesmoke">setsockopt(socket</span></span><span style="color:#333333; background:whitesmoke">，</span><span style="color:#333333; background:whitesmoke">SOL_S0CKET,SO_SNDBUF</span><span style="color:#333333; background:whitesmoke">，</span><span style="color:#333333; background:whitesmoke">(char *)&amp;nZero,sizeof(nZero));</span><span style="color:#333333"><br> <span style="background:whitesmoke">6.</span></span><span style="color:#333333; background:whitesmoke">同上在</span><span style="color:#333333; background:whitesmoke">recv()</span><span style="color:#333333; background:whitesmoke">完成上述功能</span><span style="color:#333333; background:whitesmoke">(</span><span style="color:#333333; background:whitesmoke">默认情况是将</span><span style="color:#333333; background:whitesmoke">socket</span><span style="color:#333333; background:whitesmoke">缓冲区的内容拷贝到系统缓冲区</span><span style="color:#333333; background:whitesmoke">)</span><span style="color:#333333; background:whitesmoke">：</span><span style="color:#333333"><br> <span style="background:whitesmoke">int nZero=0;</span><br> <span style="background:whitesmoke">setsockopt(socket</span></span><span style="color:#333333; background:whitesmoke">，</span><span style="color:#333333; background:whitesmoke">SOL_S0CKET,SO_RCVBUF</span><span style="color:#333333; background:whitesmoke">，</span><span style="color:#333333; background:whitesmoke">(char *)&amp;nZero,sizeof(int));</span><span style="color:#333333"><br> <span style="background:whitesmoke">7.</span></span><span style="color:#333333; background:whitesmoke">一般在发送</span><span style="color:#333333; background:whitesmoke">UDP</span><span style="color:#333333; background:whitesmoke">数据报的时候，希望该</span><span style="color:#333333; background:whitesmoke">socket</span><span style="color:#333333; background:whitesmoke">发送的数据具有广播特性：</span><span style="color:#333333"><br> <span style="background:whitesmoke">BOOL bBroadcast=TRUE; </span><br> <span style="background:whitesmoke">setsockopt(s,SOL_SOCKET,SO_BROADCAST,(const char*)&amp;bBroadcast,sizeof(BOOL));</span><br> <span style="background:whitesmoke">8.</span></span><span style="color:#333333; background:whitesmoke">在</span><span style="color:#333333; background:whitesmoke">client</span><span style="color:#333333; background:whitesmoke">连接服务器过程中，如果处于非阻塞模式下的</span><span style="color:#333333; background:whitesmoke">socket</span><span style="color:#333333; background:whitesmoke">在</span><span style="color:#333333; background:whitesmoke">connect()</span><span style="color:#333333; background:whitesmoke">的过程中可</span><span style="color:#333333"><br> </span><span style="color:#333333; background:whitesmoke">以设置</span><span style="color:#333333; background:whitesmoke">connect()</span><span style="color:#333333; background:whitesmoke">延时</span><span style="color:#333333; background:whitesmoke">,</span><span style="color:#333333; background:whitesmoke">直到</span><span style="color:#333333; background:whitesmoke">accpet()</span><span style="color:#333333; background:whitesmoke">被呼叫</span><span style="color:#333333; background:whitesmoke">(</span><span style="color:#333333; background:whitesmoke">本函数设置只有在非阻塞的过程中有显著的</span><span style="color:#333333"><br> </span><span style="color:#333333; background:whitesmoke">作用，在阻塞的函数调用中作用不大</span><span style="color:#333333; background:whitesmoke">)</span><span style="color:#333333"><br> <span style="background:whitesmoke">BOOL bConditionalAccept=TRUE;</span><br> <span style="background:whitesmoke">setsockopt(s,SOL_SOCKET,SO_CONDITIONAL_ACCEPT,(const char*)&amp;bConditionalAccept,sizeof(BOOL));</span><br> <span style="background:whitesmoke">9.</span></span><span style="color:#333333; background:whitesmoke">如果在发送数据的过程中</span><span style="color:#333333; background:whitesmoke">(send()</span><span style="color:#333333; background:whitesmoke">没有完成，还有数据没发送</span><span style="color:#333333; background:whitesmoke">)</span><span style="color:#333333; background:whitesmoke">而调用了</span><span style="color:#333333; background:whitesmoke">closesocket(),</span><span style="color:#333333; background:whitesmoke">以前我们</span><span style="color:#333333"><br> </span><span style="color:#333333; background:whitesmoke">一般采取的措施是</span><span style="color:#333333; background:whitesmoke">"</span><span style="color:#333333; background:whitesmoke">从容关闭</span><span style="color:#333333; background:whitesmoke">"shutdown(s,SD_BOTH),</span><span style="color:#333333; background:whitesmoke">但是数据是肯定丢失了，如何设置让程序满足具体</span><span style="color:#333333"><br> </span><span style="color:#333333; background:whitesmoke">应用的要求</span><span style="color:#333333; background:whitesmoke">(</span><span style="color:#333333; background:whitesmoke">即让没发完的数据发送出去后在关闭</span><span style="color:#333333; background:whitesmoke">socket)</span><span style="color:#333333; background:whitesmoke">？</span><span style="color:#333333"><br> <span style="background:whitesmoke">struct linger {<!-- --></span><br> <span style="background:whitesmoke">u_short l_onoff;</span><br> <span style="background:whitesmoke">u_short l_linger;</span><br> <span style="background:whitesmoke">};</span><br> <span style="background:whitesmoke">linger m_sLinger;</span><br> <span style="background:whitesmoke">m_sLinger.l_onoff=1;//(</span></span><span style="color:#333333; background:whitesmoke">在</span><span style="color:#333333; background:whitesmoke">closesocket()</span><span style="color:#333333; background:whitesmoke">调用</span><span style="color:#333333; background:whitesmoke">,</span><span style="color:#333333; background:whitesmoke">但是还有数据没发送完毕的时候容许逗留</span><span style="color:#333333; background:whitesmoke">)</span><span style="color:#333333"><br> <span style="background:whitesmoke">// </span></span><span style="color:#333333; background:whitesmoke">如果</span><span style="color:#333333; background:whitesmoke">m_sLinger.l_onoff=0;</span><span style="color:#333333; background:whitesmoke">则功能和</span><span style="color:#333333; background:whitesmoke">2.)</span><span style="color:#333333; background:whitesmoke">作用相同</span><span style="color:#333333; background:whitesmoke">;</span><span style="color:#333333"><br> <span style="background:whitesmoke">m_sLinger.l_linger=5;//(</span></span><span style="color:#333333; background:whitesmoke">容许逗留的时间为</span><span style="color:#333333; background:whitesmoke">5</span><span style="color:#333333; background:whitesmoke">秒</span><span style="color:#333333; background:whitesmoke">)</span><span style="color:#333333"><br> <span style="background:whitesmoke">setsockopt(s,SOL_SOCKET,SO_LINGER,(const char*)&amp;m_sLinger,sizeof(linger));</span><br> <span style="background:whitesmoke">Note:1.</span></span><span style="color:#333333; background:whitesmoke">在设置了逗留延时，用于一个非阻塞的</span><span style="color:#333333; background:whitesmoke">socket</span><span style="color:#333333; background:whitesmoke">是作用不大的，最好不用</span><span style="color:#333333; background:whitesmoke">;</span><span style="color:#333333"><br> <span style="background:whitesmoke">2.</span></span><span style="color:#333333; background:whitesmoke">如果想要程序不经历</span><span style="color:#333333; background:whitesmoke">SO_LINGER</span><span style="color:#333333; background:whitesmoke">需要设置</span><span style="color:#333333; background:whitesmoke">SO_DONTLINGER</span><span style="color:#333333; background:whitesmoke">，或者设置</span><span style="color:#333333; background:whitesmoke">l_onoff=0</span><span style="color:#333333; background:whitesmoke">；</span><span style="color:#333333"><br> <span style="background:whitesmoke">10.</span></span><span style="color:#333333; background:whitesmoke">还一个用的比较少的是在</span><span style="color:#333333; background:whitesmoke">SDI</span><span style="color:#333333; background:whitesmoke">或者是</span><span style="color:#333333; background:whitesmoke">Dialog</span><span style="color:#333333; background:whitesmoke">的程序中，可以记录</span><span style="color:#333333; background:whitesmoke">socket</span><span style="color:#333333; background:whitesmoke">的调试信息：</span><span style="color:#333333"><br> <span style="background:whitesmoke">(</span></span><span style="color:#333333; background:whitesmoke">前不久做过这个函数的测试，调式信息可以保存，包括</span><span style="color:#333333; background:whitesmoke">socket</span><span style="color:#333333; background:whitesmoke">建立时候的参数</span><span style="color:#333333; background:whitesmoke">,</span><span style="color:#333333; background:whitesmoke">采用的</span><span style="color:#333333"><br> </span><span style="color:#333333; background:whitesmoke">具体协议，以及出错的代码都可以记录下来）</span><span style="color:#333333"><br> <span style="background:whitesmoke">BOOL bDebug=TRUE;</span><br> <span style="background:whitesmoke">setsockopt(s,SOL_SOCKET,SO_DEBUG,(const char*)&amp;bDebug,sizeof(BOOL));</span><br> <span style="background:whitesmoke">11.</span></span><span style="color:#333333; background:whitesmoke">附加：往往通过</span><span style="color:#333333; background:whitesmoke">setsockopt()</span><span style="color:#333333; background:whitesmoke">设置了缓冲区大小，但还不能满足数据的传输需求，</span><span style="color:#333333"><br> </span><span style="color:#333333; background:whitesmoke">我的习惯是自己写个处理网络缓冲的类，动态分配内存</span><span style="color:#333333; background:whitesmoke">;</span><span style="color:#333333; background:whitesmoke">下面我将这个类写出，希望对</span><span style="color:#333333"><br> </span><span style="color:#333333; background:whitesmoke">初学者有所帮助：</span></p> 
<p> </p> 
<h3><a target="_blank" name="_Toc376251252"></a><a target="_blank" name="_Toc369176431">使用</a>CFile类对文件进行读写</h3> 
<p align="right"><span style="color:#999999">2011-05-27 09:55</span><span style="color:#999999"> </span><span style="color:#999999">2028</span><span style="color:#999999">人阅读</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/tianxw1209/article/details/6449335#comments" rel="noopener noreferrer"><span style="color:#336699">评论</span></a></span>(0)<span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" title="收藏"><span style="color:#336699">收藏</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/tianxw1209/article/details/6449335#report" title="举报" rel="noopener noreferrer"><span style="color:#336699">举报</span></a></span></p> 
<p align="left"><span style="color:#333333"><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=mfc" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">mfc</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=file" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">file</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=windows" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">windows</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=c" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">c</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=%e7%a3%81%e7%9b%98" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">磁盘</span></a></span><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=api" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">api</span></a></p> 
<p><span style="color:#333333">CFile</span><span style="color:#333333">类提供了对文件进行打开，关闭，读，写，删除，重命名以及获取文件信息等文件操作的基本功能，足以处理任意类型的文件操作</span></p> 
<p><span style="color:#333333"><br> </span><span style="color:#333333">一个读写文件的例子：</span><span style="color:#333333"><br> </span><span style="color:#333333">文件</span><span style="color:#333333">I/O</span></p> 
<p><span style="color:#333333">　　虽然使用</span><span style="color:#333333">CArchive</span><span style="color:#333333">类内建的序列化功能是保存和加载持久性数据的便捷方式，但有时在程序中需要对文件处理过程拥有更多的控制权，对于这种文件输入输出（</span><span style="color:#333333">I/O</span><span style="color:#333333">）服务的需求，</span><span style="color:#333333">Windows</span><span style="color:#333333">提供了一系列相关的</span><span style="color:#333333">API</span><span style="color:#333333">函数，并由</span><span style="color:#333333">MFC</span><span style="color:#333333">将其封装为</span><span style="color:#333333">CFile</span><span style="color:#333333">类，提供了对文件进行打开，关闭，读，写，删除，重命名以及获取文件信息等文件操作的基本功能，足以处理任意类型的文件操作。</span><span style="color:#333333">CFile</span><span style="color:#333333">类是</span><span style="color:#333333">MFC</span><span style="color:#333333">文件类的基类，支持无缓冲的二进制输入输出，也可以通过与</span><span style="color:#333333">CArchive</span><span style="color:#333333">类的配合使用而支持对</span><span style="color:#333333">MFC</span><span style="color:#333333">对象的带缓冲的序列化。</span></p> 
<p><span style="color:#333333">CFile</span><span style="color:#333333">类包含有一个公有型数据成员</span><span style="color:#333333">m_hFile</span><span style="color:#333333">，该数据成员包含了同</span><span style="color:#333333">CFile</span><span style="color:#333333">类对象相关联的文件句柄。如果没有指定句柄，则该值为</span><span style="color:#333333">CFile::hFileNull</span><span style="color:#333333">。由于该数据成员所包含的意义取决于派生的类，因此一般并不建议使用</span><span style="color:#333333">m_hFile</span><span style="color:#333333">。</span></p> 
<p><span style="color:#333333">　　通过</span><span style="color:#333333">CFile</span><span style="color:#333333">类来打开文件可以采取两种方式：一种方式是先构造一个</span><span style="color:#333333">CFile</span><span style="color:#333333">类对象然后再调用成员函数</span><span style="color:#333333">Open</span><span style="color:#333333">（）打开文件，另一种方式则直接使用</span><span style="color:#333333">CFile</span><span style="color:#333333">类的构造函数去打开一个文件。下面的语句分别演示了用这两种方法打开磁盘文件</span><span style="color:#333333">“C:/TestFile.txt”</span><span style="color:#333333">的过程：</span></p> 
<p><span style="color:#333333">// </span><span style="color:#333333">先构造一个实例，然后再打开文件</span><span style="color:#333333"><br> CFile file;<br> file.Open(“C://TestFile.txt”, CFile::modeReadWrite);<br> ……<br> // </span><span style="color:#333333">直接通过构造函数打开文件</span><span style="color:#333333"><br> CFile file(“C://TestFile.txt”, CFile::modeReadWrite);</span></p> 
<p><span style="color:#333333">　　其中参数</span><span style="color:#333333">CFile::modeReadWrite</span><span style="color:#333333">是打开文件的模式标志，</span><span style="color:#333333">CFile</span><span style="color:#333333">类中与之类似的标志还有十几个，现集中列表如下：</span></p> 
<p><span style="color:#333333">文件模式标志</span><span style="color:#333333">说明</span><span style="color:#333333"> </span><span style="color:#333333"><br> CFile::modeCreate  </span><span style="color:#333333">创建方式打开文件，如文件已存在则将其长度设置为</span><span style="color:#333333">0</span><span style="color:#333333"> </span><span style="color:#333333"><br> CFile::modeNoInherit  </span><span style="color:#333333">不允许继承</span><span style="color:#333333"> </span><span style="color:#333333"><br> CFile::modeNoTruncate </span><span style="color:#333333">创建文件时如文件已存在不对其进行截断</span><span style="color:#333333"> </span><span style="color:#333333"><br> CFile::modeRead </span><span style="color:#333333">只读方式打开文件</span><span style="color:#333333"> </span><span style="color:#333333"><br> CFile::modeReadWrite </span><span style="color:#333333">读写方式打开文件</span><span style="color:#333333"> </span><span style="color:#333333"><br> CFile::modeWrite </span><span style="color:#333333">写入方式打开文件</span><span style="color:#333333"> </span><span style="color:#333333"><br> CFile::shareCompat </span><span style="color:#333333">在使用过程中允许其他进程同时打开文件</span><span style="color:#333333"> </span><span style="color:#333333"><br> CFile::shareDenyNone </span><span style="color:#333333">在使用过程中允许其他进程对文件进行读写</span><span style="color:#333333"> </span><span style="color:#333333"><br> CFile::shareDenyRead </span><span style="color:#333333">在使用过程中不允许其他进程对文件进行读取</span><span style="color:#333333"> </span><span style="color:#333333"><br> CFile::shareDenyWrite </span><span style="color:#333333">在使用过程中不允许其他进程对文件进行写入</span><span style="color:#333333"> </span><span style="color:#333333"><br> CFile::shareExclusive  </span><span style="color:#333333">取消对其他进程的所有访问</span><span style="color:#333333"> </span><span style="color:#333333"><br> CFile::typeBinary </span><span style="color:#333333">设置文件为二进制模式</span><span style="color:#333333"> </span><span style="color:#333333"><br> CFile::typeText </span><span style="color:#333333">设置文件为文本模式</span></p> 
<p><span style="color:#333333">　　这些标志可以通过</span><span style="color:#333333">“</span><span style="color:#333333">或</span><span style="color:#333333">”</span><span style="color:#333333">运算符而同时使用多个，并以此来满足多种需求。例如，需要以读写方式打开文件，如果文件不存在就创建一个新的，如果文件已经存在则不将其文件长度截断为</span><span style="color:#333333">0</span><span style="color:#333333">。为满足此条件，可用</span><span style="color:#333333">CFile::modeCreate</span><span style="color:#333333">、</span><span style="color:#333333">CFile::modeReadWrite</span><span style="color:#333333">和</span><span style="color:#333333">CFile::modeNoTruncate</span><span style="color:#333333">等几种文件模式标志来打开文件：</span></p> 
<p><span style="color:#333333">CFilefile ("C://TestFile.txt", CFile::modeCreate | CFile::modeReadWrite |CFile::modeNoTruncate);</span></p> 
<p><span style="color:#333333">　　在打开的文件不再使用时需要将其关闭，即可以用成员函数</span><span style="color:#333333">Close</span><span style="color:#333333">（）关闭也可以通过</span><span style="color:#333333">CFile</span><span style="color:#333333">类的析构函数来完成。当采取后一种方式时，如果文件还没有被关闭，析构函数将负责隐式调用</span><span style="color:#333333">Close</span><span style="color:#333333">（）函数去关闭文件，这也表明创建在堆上的</span><span style="color:#333333">CFile</span><span style="color:#333333">类对象在超出范围后将自动被关闭。由于调用了对象的析构函数，因此在文件被关闭的同时</span><span style="color:#333333">CFile</span><span style="color:#333333">对象也被销毁，而采取</span><span style="color:#333333">Close</span><span style="color:#333333">（）方式关闭文件后，</span><span style="color:#333333">CFile</span><span style="color:#333333">对象仍然存在。所以，在显式调用</span><span style="color:#333333">Close</span><span style="color:#333333">（）函数关闭一个文件后可以继续用同一个</span><span style="color:#333333">CFile</span><span style="color:#333333">对象去打开其他的文件。</span></p> 
<p><span style="color:#333333">　　文件读写是最常用的文件操作方式，主要由</span><span style="color:#333333">CFile</span><span style="color:#333333">类成员函数</span><span style="color:#333333">Read</span><span style="color:#333333">（）、</span><span style="color:#333333">Write</span><span style="color:#333333">（）来实现。其函数原型分别为：</span></p> 
<p><span style="color:#333333">UINTRead( void* lpBuf, UINT nCount );<br> void Write( const void* lpBuf, UINT nCount );</span></p> 
<p><span style="color:#333333">　　参数</span><span style="color:#333333">lpBuf</span><span style="color:#333333">为指向存放数据的缓存的指针，</span><span style="color:#333333">nCount</span><span style="color:#333333">为要读入或写入的字节数，</span><span style="color:#333333">Read</span><span style="color:#333333">（）返回的为实际读取的字节数，该数值小于或等于</span><span style="color:#333333">nCount</span><span style="color:#333333">，如果小于</span><span style="color:#333333">nCount</span><span style="color:#333333">则说明已经读到文件末尾，可以结束文件读取，如继续读取，将返回</span><span style="color:#333333">0</span><span style="color:#333333">。因此通常可以将实际读取字节数是否小于指定读取的字节数或是否为</span><span style="color:#333333">0</span><span style="color:#333333">作为判断文件读取是否到达结尾的依据。下面这段代码演示了对文件进行一次性写入和循环多次读取的处理过程：</span></p> 
<p><span style="color:#333333">// </span><span style="color:#333333">创建、写入方式打开文件</span><span style="color:#333333"><br> CFile file;<br> file.Open("C://TestFile.txt", CFile::modeWrite | CFile::modeCreate);<br> // </span><span style="color:#333333">写入文件</span><span style="color:#333333"><br> memset(WriteBuf, 'a', sizeof(WriteBuf));<br> file.Write(WriteBuf, sizeof(WriteBuf));<br> // </span><span style="color:#333333">关闭文件</span><span style="color:#333333"><br> file.Close();<br> // </span><span style="color:#333333">只读方式打开文件</span><span style="color:#333333"><br> file.Open("C://TestFile.txt", CFile::modeRead);<br> while (true)<br> {<!-- --><br> // </span><span style="color:#333333">读取文件数据</span><span style="color:#333333"><br> int ret = file.Read(ReadBuf, 100);<br> ……<br> // </span><span style="color:#333333">如果到达文件结尾则中止循环</span><span style="color:#333333"><br> if (ret &lt; 100)<br> break;<br> }<br> // </span><span style="color:#333333">关闭文件</span><span style="color:#333333"><br> file.Close();</span></p> 
<p><span style="color:#333333">Write</span><span style="color:#333333">（）和</span><span style="color:#333333">Read</span><span style="color:#333333">（）函数执行完后将自动移动文件指针，因此不必再显示调用</span><span style="color:#333333">Seek</span><span style="color:#333333">（）函数去定位文件指针。包含有文件定位函数的完整代码如下所示：</span></p> 
<p><span style="color:#333333">// </span><span style="color:#333333">创建、写入方式打开文件</span><span style="color:#333333"><br> CFile file;<br> file.Open("C://TestFile.txt", CFile::modeWrite | CFile::modeCreate);<br> // </span><span style="color:#333333">写入文件</span><span style="color:#333333"><br> memset(WriteBuf, 'a', sizeof(WriteBuf));<br> file.SeekToBegin();<br> file.Write(WriteBuf, sizeof(WriteBuf));<br> // </span><span style="color:#333333">关闭文件</span><span style="color:#333333"><br> file.Close();<br> // </span><span style="color:#333333">只读方式打开文件</span><span style="color:#333333"><br> file.Open("C://TestFile.txt", CFile::modeRead);<br> while (true)<br> {<!-- --><br> // </span><span style="color:#333333">文件指针</span><span style="color:#333333"><br> static int position = 0;<br> // </span><span style="color:#333333">移动文件指针</span><span style="color:#333333"><br> file.Seek(position, CFile::begin);<br> // </span><span style="color:#333333">读取文件数据</span><span style="color:#333333"><br> int ret = file.Read(ReadBuf, 100);<br> position += ret;<br> ……<br> // </span><span style="color:#333333">如果到达文件结尾则中止循环</span><span style="color:#333333"><br> if (ret &lt; 100)<br> break;<br> }<br> // </span><span style="color:#333333">关闭文件</span><span style="color:#333333"><br> file.Close();</span></p> 
<p><span style="color:#333333"> </span></p> 
<p><span style="color:#333333">补充：</span></p> 
<p><span style="color:#333333">使用</span><span style="color:#333333">CFile</span><span style="color:#333333">类对文件进行按结构读取</span><span style="color:#333333">,</span><span style="color:#333333">如：</span></p> 
<p><span style="color:#333333">CFilefileRead,fileWrite;<br>  fileRead.Open(_T("E://a.dat"),CFile::modeRead);//</span><span style="color:#333333">这里使用宏</span><span style="color:#333333">_T<br>  fileWrite.Open(_T("E://backup.txt"),CFile::modeCreate |CFile::modeWrite);</span></p> 
<p><span style="color:#333333">VIDEOHEADER *videoheader=new VIDEOHEADER();<br> fileRead.Read(videoheader,sizeof(VIDEOHEADER));</span></p> 
<p><span style="color:#333333">charbuf[sizeof(VIDEOHEADER)*8];<br> sprintf(buf,"videoheader.cCommandID:%s ,videoheader-&gt;cCommandID);</span><span style="color:#333333">通过</span><span style="color:#333333">sprintf</span><span style="color:#333333">对我们需要写入文件中的数据进行格式化，这样在文件中存储的数据就是以这里定义的格式显示的。</span></p> 
<h3><a target="_blank" name="_Toc376251253"></a><a target="_blank" name="_Toc369176432"><span style="color:#333333">MFC</span></a><span style="color:#333333">同步类</span></h3> 
<p align="left"><span style="color:#333333">·        </span><span style="color:#333333">CCriticalSection </span><span style="color:#333333">临界区：在用户模式工作</span><span style="color:#333333"> </span><span style="color:#333333">(</span><span style="color:#333333"> </span><span style="color:#333333">遇到加锁等待时会进入内核模式</span><span style="color:#333333"> </span><span style="color:#333333">)</span><span style="color:#333333"> </span><span style="color:#333333">，使用与保护线程间共享资源，一个线程可以多次</span><span style="color:#333333"> </span><span style="color:#333333">Lock</span><span style="color:#333333"> </span><span style="color:#333333">不会错。不支持在多进程之间工作。将一段代码置入临界区，只允许最多一个线程进入执行这段代码。一个临界区仅在创建它的进程中有效。</span></p> 
<p align="left"><span style="color:#333333">·        </span><span style="color:#333333">CMutex </span><span style="color:#333333">互斥量：在内核模式工作，除支持临界区的功能外，还可以为互斥量命名，以便在多进程中工作。互斥量比临界区耗资源。一个时刻至多只允许一个线程访问某资源，未被占用时处于有信号状态，可以实现对共享资源的互斥访问。</span></p> 
<p align="left"><span style="color:#333333">·        </span><span style="color:#333333">CEvent </span><span style="color:#333333">事件：在内核模式工作，适用于某一线程等待某事件发生才执行的场合。</span></p> 
<p align="left"><span style="color:#333333">·        </span><span style="color:#333333">CSemaphore </span><span style="color:#333333">信号量</span><span style="color:#333333"> </span><span style="color:#333333">(</span><span style="color:#333333"> </span><span style="color:#333333">信号灯</span><span style="color:#333333"> </span><span style="color:#333333">)</span><span style="color:#333333"> </span><span style="color:#333333">：在内核模式工作，适用于允许特定个数的线程执行某任务。允许一定数目的线程访问某个共享资源，常用来控制访问共享资源的线程数量。</span></p> 
<h3><a target="_blank" name="_Toc376251254"></a><a target="_blank" name="_Toc369176433"><span style="color:#333333">同步对象的适用场合</span></a></h3> 
<p align="left"><span style="color:#333333">·        </span><span style="color:#333333">1.</span><span style="color:#333333">如果某个线程必须等待某些事件发生后才能存取相应的资源，则用</span><span style="color:#333333"> </span><span style="color:#333333">CEvent</span></p> 
<p align="left"><span style="color:#333333">·        </span><span style="color:#333333">2.</span><span style="color:#333333">如果一个应用程序同时可以有多个线程存取相应资源，则用</span><span style="color:#333333"> </span><span style="color:#333333">CSemaphore</span></p> 
<p align="left"><span style="color:#333333">·        </span><span style="color:#333333">3.</span><span style="color:#333333">如果多个应用程序</span><span style="color:#333333"> </span><span style="color:#333333">(</span><span style="color:#333333"> </span><span style="color:#333333">多个线程</span><span style="color:#333333"> </span><span style="color:#333333">)</span><span style="color:#333333"> </span><span style="color:#333333">同时存取相应资源，则用</span><span style="color:#333333"> </span><span style="color:#333333">CMutex</span><span style="color:#333333"> </span><span style="color:#333333">，否则用</span><span style="color:#333333">CCriticalSection</span></p> 
<h3><a target="_blank" name="_Toc376251255"></a><a target="_blank" name="_Toc369176434"><span style="color:#333333">等待类</span></a><span style="color:#333333">CSingleLock</span></h3> 
<p><span style="color:#333333">一个</span><span style="color:#333333"> </span><span style="color:#333333">CSingleLock</span><span style="color:#333333"> </span><span style="color:#333333">类对象代表一种访问控制机制，这种机制用于控制在一个多线程程序中对一个资源的访问。为了使用同步类</span><span style="color:#333333"> </span><span style="color:#333333">CSemaphore</span><span style="color:#333333"> </span><span style="color:#333333">、</span><span style="color:#333333"> </span><span style="color:#333333">CMutex</span><span style="color:#333333"> </span><span style="color:#333333">、</span><span style="color:#333333"> </span><span style="color:#333333">CCriticalSection</span><span style="color:#333333"> </span><span style="color:#333333">、</span><span style="color:#333333">CEvent</span><span style="color:#333333"> </span><span style="color:#333333">所创建的同步对象，你必须创建一个</span><span style="color:#333333"> </span><span style="color:#333333">CSingleLock</span><span style="color:#333333"> </span><span style="color:#333333">或者</span><span style="color:#333333"> </span><span style="color:#333333">CMultiLock</span><span style="color:#333333"> </span><span style="color:#333333">对象来等待和释放这个同步对象。当你只需要每次等待一个对象时，则用</span><span style="color:#333333"> </span><span style="color:#333333">CsingleLock</span><span style="color:#333333"> </span><span style="color:#333333">，否则用</span><span style="color:#333333">CMultiLock</span><span style="color:#333333"> </span><span style="color:#333333">。</span></p> 
<p><span style="color:#333333">要使用一个</span><span style="color:#333333"> </span><span style="color:#333333">CSingleLock</span><span style="color:#333333"> </span><span style="color:#333333">对象，在被控制资源的类中的一个成员函数内部调用</span><span style="color:#333333">CSingleLock</span><span style="color:#333333"> </span><span style="color:#333333">的构造函数。然后调用</span><span style="color:#333333"> </span><span style="color:#333333">IsLock</span><span style="color:#333333"> </span><span style="color:#333333">成员函数来确定这个资源是否可用。如果资源是可用的，则继续该成员函数的其余部分。</span></p> 
<pre style="background:ghostwhite"><span style="color:#333333">CSingleLock::CSingle<strong>Lock</strong></span>( CSyncObject* pObject, BOOL bInitialLock = <strong>FALSE</strong> );</pre> 
<pre style="background:ghostwhite"><span style="color:#333333">pObject       </span><span style="color:#333333">指向要被访问的同步对象。不能是</span><span style="color:#333333">NULL</span></pre> 
<pre style="background:ghostwhite"><span style="color:#333333">bInitial<strong>Lock</strong></span>  <span style="color:#333333">指示是否要在最初尝试访问所提供的对象</span></pre> 
<pre style="background:ghostwhite"><span style="color:#333333"> </span></pre> 
<pre style="background:ghostwhite"><span style="color:#333333">BOOL CSingleLock::IsLocked() </span></pre> 
<pre style="background:ghostwhite"><span style="color:#333333">返回值：如果对象被加锁则返回非零值；否则返回</span><span style="color:#009999">0</span><span style="color:#333333">。</span><span style="color:#333333">此成员函数用来确定与</span><span style="color:#333333">CSingleLock</span><span style="color:#333333">对象相关的对象是否没有发信号（不能使用）。</span></pre> 
<pre style="background:ghostwhite"><span style="color:#333333"> </span></pre> 
<pre style="background:ghostwhite"><span style="color:#333333">BOOL CSingleLock::</span><strong><span style="color:#333333">Lock</span></strong><span style="color:#333333">( DWORD dwTimeOut = INFINITE );</span></pre> 
<pre style="background:ghostwhite"><span style="color:#333333">返回值：如果函数成功则返回非零值；否则返回</span><span style="color:#333333">0</span><span style="color:#333333">。</span></pre> 
<pre style="background:ghostwhite"><span style="color:#333333">参数：</span><span style="color:#333333">dwTimeOut      </span><span style="color:#333333">指定等待要被利用的同步对象的时间数量。如果是</span><span style="color:#333333">INFINITE</span><span style="color:#333333">，则</span><strong><span style="color:#333333">Lock</span></strong><span style="color:#333333">等待直到该对象在返回之前可用。</span></pre> 
<pre style="background:ghostwhite"><span style="color:#333333">说明：此成员函数用来获取对由同步对象控制的资源的访问，这个访问要提供给</span><span style="color:#333333">CSingleLock</span><span style="color:#333333">构造函数。如果同步对象是可用的，</span><strong><span style="color:#333333">Lock</span></strong><span style="color:#333333">将成功返回，而且线程拥有了该对象。如果此同步对象是不可用的，则</span><strong><span style="color:#333333">Lock</span></strong><span style="color:#333333">将等待此同步对象在</span><span style="color:#333333">dwTimeOut</span><span style="color:#333333">参数指定的时间内变为可用。如果此同步对象在指定的时间内没有变为可用的，则</span><strong><span style="color:#333333">Lock</span></strong><span style="color:#333333">返回失败。</span></pre> 
<pre style="background:ghostwhite"></pre> 
<pre style="background:ghostwhite"><span style="color:#333333">BOOL  CSingleLock::Unlock( );</span></pre> 
<pre style="background:ghostwhite"><span style="color:#333333">BOOL  CSingleLock::Un<strong>lock</strong></span>( LONG lCount, LPLONG lPrevCount = <strong>NULL</strong> );</pre> 
<pre style="background:ghostwhite"><span style="color:#333333">返回值：如果函数成功则返回非零值；否则返回</span><span style="color:#333333">0</span><span style="color:#333333">。</span></pre> 
<pre style="background:ghostwhite"><span style="color:#333333">参数：</span><span style="color:#333333"> lCount:</span><span style="color:#333333">要释放的访问数目。必须要大于</span><span style="color:#333333">0</span><span style="color:#333333">。如果指定的数量要导致对象的计数超过它的最大值，则计数不改变，并且函数返回</span><span style="color:#333333">FALSE</span><span style="color:#333333">。</span></pre> 
<pre style="background:ghostwhite"><span style="color:#333333">lPrevCount:</span><span style="color:#333333">指向一个用来接收同步对象的先前计数的变量。如果是</span><span style="color:#333333">NULL</span><span style="color:#333333">，则不返回先前的计数。</span></pre> 
<pre style="background:ghostwhite"><span style="color:#333333">说明：此成员函数用来释放由</span><span style="color:#333333">CSingle<strong>Lock</strong></span><span style="color:#333333">拥有的同步对象。由</span><span style="color:#333333">CSingleLock</span><span style="color:#333333">的析构函数类调用这个函数。如果你需要释放一个信号的多于一个的访问计数，可以使用</span><span style="color:#333333">Unlock</span><span style="color:#333333">的第二种形式，并指定要释放的访问数目。</span></pre> 
<p><span style="color:#333333">在</span><span style="color:#333333"> </span><span style="color:#333333">MFC</span><span style="color:#333333"> </span><span style="color:#333333">中，具有等待功能的类</span><span style="color:#333333"> </span><span style="color:#333333">CSingleLock</span><span style="color:#333333"> </span><span style="color:#333333">和</span><span style="color:#333333"> </span><span style="color:#333333">CMultiLock</span><span style="color:#333333"> </span><span style="color:#333333">封装了</span><span style="color:#333333"> </span><span style="color:#333333">Win32</span><span style="color:#333333"> </span><span style="color:#333333">中的等待函数</span><span style="color:#333333">WaitForSingleObject()</span><span style="color:#333333"> </span><span style="color:#333333">和</span><span style="color:#333333"> </span><span style="color:#333333">WaitForMultipleObjects() </span><span style="color:#333333"> </span></p> 
<h3><a target="_blank" name="_Toc376251256"></a><a target="_blank" name="_Toc369176435">TTS</a></h3> 
<pre style="background:#F1FEDD">TTS的全称为Text To Speech，即“从文本到语音”。它是同时运用语言学和心理学的杰出之作，在内置芯片的支持之下，通过<a target="_blank" href="http://zhidao.baidu.com/search?word=%C9%F1%BE%AD%CD%F8%C2%E7&amp;fr=qb_search_exp&amp;ie=gbk" rel="nofollow noopener noreferrer"><span style="color:#2D64B3">神经网络</span></a>的设计，把文字智能地转化为自然语音流。 

    TTS技术对文本文件进行实时转换，转换时间之短可以秒计算。在其特有智能语音控制器作用下，文本输出的语音<a target="_blank" href="http://zhidao.baidu.com/search?word=%D2%F4%C2%C9&amp;fr=qb_search_exp&amp;ie=gbk" rel="nofollow noopener noreferrer"><span style="color:#2D64B3">音律</span></a>流畅，使得听者在听取信息时感觉自然，毫无机器语音输出的冷漠与生涩感。TTS<a target="_blank" href="http://zhidao.baidu.com/search?word=%D3%EF%D2%F4%BA%CF%B3%C9&amp;fr=qb_search_exp&amp;ie=gbk" rel="nofollow noopener noreferrer"><span style="color:#2D64B3">语音合成</span></a>技术即将覆盖国标一、二级汉字，具有英文接口，自动识别中、英文，支持中英文混读。所有声音采用真人普通话为标准发音，实现了120-150个汉字/秒的快速<a target="_blank" href="http://zhidao.baidu.com/search?word=%D3%EF%D2%F4%BA%CF%B3%C9&amp;fr=qb_search_exp&amp;ie=gbk" rel="nofollow noopener noreferrer"><span style="color:#2D64B3">语音合成</span></a>，朗读<a target="_blank" href="http://zhidao.baidu.com/search?word=%CB%D9%B6%C8%B4%EF&amp;fr=qb_search_exp&amp;ie=gbk" rel="nofollow noopener noreferrer"><span style="color:#2D64B3">速度达</span></a>3-4个汉字/秒，使用户可以听到清晰悦耳的音质和连贯流畅的语调。</pre> 
<pre style="background:#F1FEDD"> </pre> 
<h3><a target="_blank" name="_Toc376251257"></a><a target="_blank" name="_Toc369176436">-qws</a>命令</h3> 
<pre style="background:#F1FEDD">运行嵌入式程序</pre> 
<p>在嵌入式QT版本中，程序需要服务器或自己作为服务器程序。服务器程序构造的方法是构造一个QApplication::GuiServe类型的QApplication对象。或者使用-qws命令选项启动程序。</p> 
<p> </p> 
<p>Using a Single Display</p> 
<p>使用-qws选项</p> 
<p>接下来的程序可以当做客户端来运行，只要不使用-qws选项。那么客户端程序就会自动连接到服务程序中。</p> 
<p> </p> 
<p>using Mutiple Displays</p> 
<p>嵌入式版本中运行多个县市同时运行。两种方式可以实现，要么多次运行服务程序，要么使用read-mae Multi screen driver</p> 
<p>当多个服务程序运行时，每个程序必须使用-display选项指定显示驱动，或者使用QWS_DISPLAY环境变量来指定。</p> 
<p>服务程序运行时：</p> 
<p>./mysecondserverapplication -qws -display"QVFb:2"</p> 
<p>客户程序运行时：</p> 
<p>./myclientapplication -display"QVFb:2"</p> 
<p> </p> 
<p>若想在不同显示器移动应用程序，则只能通过Muti显示器实现。</p> 
<p>./myserverapplication -qws -display"Multi: QVFb:0</p> 
<p>QVFb:1:offset=0,0 VNC:offset=640,0 :2"</p> 
<p> </p> 
<p>程序启动命令选项：</p> 
<p>-fn&lt;font&gt;         定义程序的字体，例如./myapplication -fn helvetica</p> 
<p> </p> 
<p>-bg&lt;color&gt;                设置程序默认背景颜色例如./myapplication -bg blue，颜色名称必须能被QColor类构造函数识别</p> 
<p> </p> 
<p>-btn&lt;color&gt;                设置默认的按钮颜色，例如./myapplication -btn green 同样颜色必须被认识</p> 
<p> </p> 
<p>-fg&lt;color&gt;                设置foreground颜色，例如./myapplication -fg 'dark blue' 同上需被认识</p> 
<p> </p> 
<p>-name &lt;objectname&gt;    设置应用程序名字例如./myapplication -nametexteditapplication</p> 
<p> </p> 
<p>-title &lt;title&gt;        设置应用程序标题。./myapplication -title 'Text Edit'</p> 
<p> </p> 
<p>-geometry&lt;width&gt;x&lt;height&gt;+&lt;Xoffset&gt;+&lt;Yoffset&gt;</p> 
<p>设置窗口大小， ./myapplication-geometry 300x200+50+50</p> 
<p> </p> 
<p>-keyboard                    启动键盘</p> 
<p> </p> 
<p>-nokeyboard                关闭键盘</p> 
<p> </p> 
<p>-mouse                        启动鼠标</p> 
<p> </p> 
<p>-nomouse                    关闭鼠标</p> 
<p> </p> 
<p>-qws                            设置为服务程序</p> 
<p> </p> 
<p>-display                    设置显示器驱动</p> 
<p> </p> 
<p>-decoration&lt;style&gt;</p> 
<p>设置程序的风格，例如./myapplication-decoration windows，只支持windows default styled</p> 
<h3><a target="_blank" name="_Toc376251258"></a><a target="_blank" name="_Toc369176437">ultraedit </a>自动缩进修改  </h3> 
<p>2011-04-29 18:31:41|  分类： <a target="_blank" href="http://blank-dic.blog.163.com/blog/#m=0&amp;t=1&amp;c=fks_087071087095083068087083084095087087081066092080084065" rel="nofollow noopener noreferrer" title="教程技巧"><span style="color:windowtext">教程技巧</span></a>|字号 订阅</p> 
<p>经常在一行之后回车,或者在if else之后回车,光标不是和上一行对齐,而是向后移动了4个空格(如果是设置是4的话),这样看起来让人很不爽,</p> 
<p>自动缩进的修改点,有三个地方,作用不一,自己去体会</p> 
<p>1.高级-》配置-》编辑器显示-》格式化</p> 
<p>2.找到wordfile.uew 文件进行修改,</p> 
<p>一般wordfile.uew 文件的目录是C:\Documents andSettings\***\Application Data\IDMComp\UltraEdit\而不是你的安装目录</p> 
<p><br> 找到/IndentStrings = "{" "if" "else"":"  </p> 
<p>把 if, else, :去掉就可以了 </p> 
<p>然后重新启动ultraedit.</p> 
<p>3.艺术样式</p> 
<p><a target="_blank" href="http://hi.baidu.com/begin_think/blog/item/a40f4a2eeb9af7341e308976.html" rel="nofollow noopener noreferrer"><span style="color:windowtext">http://hi.baidu.com/begin_think/blog/item/a40f4a2eeb9af7341e308976.html</span></a> </p> 
<p> 工作的时候，要经常拿到别人的代码来改，有些人不太注重编程风格，代码看上去很乱，所以不得不用一些自动排格式的软件先来“格式化”一下，以前我总用VC来排，可是用VC始终感觉太麻烦，而且它的排版功能太死板了，跟自己的风格有些差别，所以想到用UE来试试，没想到真的能改出和自己编程的风格类似的代码。下面就说说我是如何设置UE让它能按我的想法来排版的：</p> 
<p><br> 首先单击帮助工具栏（根据设置的不同可能在其他工具栏上）上的“艺术样式”按钮，<br> <a target="_blank" href="http://hiphotos.baidu.com/ok2222991/pic/item/20dd20ad337e3e2c4b36d684.jpg" rel="nofollow noopener noreferrer"></a><br> 弹出如下对话框<br> <br> 然后就可以按照自己的习惯设置缩进的方式了，如果对排版没有特别的要求，默认的选择就可以了，在这种设置状态下，switch后的case是不会缩进的，如果要让case缩进，那么需要选中切换或大小写（就是switch和case，翻译的问题），最好不要两个都选，否则case会缩进两个单位，如果要case后的语句也缩进就选切换，如果只缩进case就选大小写，按照我的习惯是选择切换。其他的选择就看程序员自己的习惯了。<br> 样式我选择的是ANSI，除了GUN，到没有感觉和其他样式有什么区别，有时间再来研究下吧。<br> UE默认情况下制表符是占两个空格，习惯四个空格的可以选菜单栏中的高级-配置-编辑器-自动换行/制表符设置，将缩进空格改为4就可以了。</p> 
<h3><a target="_blank" name="_Toc376251259"></a><a target="_blank" name="_Toc369176438">typedef </a>函数指针的用法</h3> 
<p align="left"><span style="color:#3366FF">在网上搜索函数指针，看到一个例子。开始没看懂，想放弃，可是转念一想，这个用法迟早要弄懂的，现在多花点时间看懂它，好过以后碰到了要再花一倍时间来弄懂它。其实很多时候都是这样，如果每次到难一点的内容，总想着下次我再来解决它，那就永远也学不到东西。</span></p> 
<p align="left"><span style="color:#3366FF">后面那个例子加了注释，是我对这种用法的理解，希望对新手有所帮助。</span></p> 
<p align="left">进入正文：</p> 
<p align="left">　<strong><span style="color:maroon">代码简化</span></strong>, 促进跨平台开发的目的.</p> 
<p align="left">　typedef 行为有点像 #define 宏，用其实际类型替代同义字。</p> 
<p align="left">　不同点：typedef 在<strong><span style="color:maroon">编译时被解释</span></strong>，因此让编译器来应付<strong><span style="color:maroon">超越预处理器能力的文本替换</span></strong>。</p> 
<p align="left"><strong><span style="color:purple">用法一：</span></strong></p> 
<p align="left"><strong><span style="color:purple">typedef</span> <span style="color:purple">int</span></strong> (*MYFUN)<strong><span style="color:purple">(int, int)</span></strong>; <br> 这种用法一般用在给<strong><span style="color:maroon">函数定义别名</span></strong>的时候<br> 上面的例子定义<strong><span style="color:#003300">MYFUN</span> </strong>是一个<strong><span style="color:#003300">函数指针</span></strong>, 函数类型是带两个int 参数, 返回一个int <br> <br> 在<strong><span style="color:#003300">分析</span></strong>这种形式的定义的时候可以用下面的方法: <br> <strong>先去掉<span style="color:#003300">typedef </span><span style="color:#003300">和别名</span></strong>, <strong><span style="color:#003300">剩下的就是原变量的类型</span><span style="color:#003300">.</span> <br> <span style="color:#003300">去掉</span><span style="color:#003300">typedef</span><span style="color:#003300">和</span><span style="color:#003300">MYFUN</span><span style="color:#003300">以后就剩</span><span style="color:#003300">:</span></strong> <br> int (*)(int, int)</p> 
<p align="left"><strong><span style="color:purple">用法二：</span></strong></p> 
<p align="left">typedef给变量类型定义一个<strong><span style="color:purple">别名</span></strong>.</p> 
<p align="left"><strong><span style="color:maroon">typedef</span></strong> struct{ <br> int a; <br> int b; <br> }<strong><span style="color:maroon">MY_TYPE</span></strong>; <br> <br> 这里把一个未命名结构直接取了一个叫MY_TYPE的别名, 这样如果你想定义结构的实例的时候就可以这样: <br> MY_TYPE tmp;</p> 
<p align="left"><strong>第二种用法<span style="color:#003300">：</span><span style="color:#003300">typedef</span> <span style="color:#3366FF">原变量类型</span> <span style="color:#333300">别名</span></strong></p> 
<p align="left">简单的函数指针的用法</p> 
<p align="left">//形式1：返回类型（*函数名）（参数表）</p> 
<p align="left">char（*pFun)(int);</p> 
<p align="left">//<strong><span style="color:maroon">typedef</span> <span style="color:purple">char(*</span></strong>pFun<strong><span style="color:purple">)(int)  //</span><span style="color:purple">跟上一行功能等同</span></strong></p> 
<p align="left"><strong><span style="color:purple">/*typedef</span><span style="color:purple">的功能是</span><span style="color:maroon">定义新的类型</span><span style="color:purple">。第一句就是定义了一种</span><span style="color:purple">PTRFUN</span><span style="color:purple">的类型，并定义这种类型为</span><span style="color:maroon">指向某种函数的指针</span><span style="color:purple">，这种函数以一个</span><span style="color:purple">int</span><span style="color:purple">为参数并返回</span><span style="color:purple">char</span><span style="color:purple">类型。</span><span style="color:purple">*/</span></strong></p> 
<p align="left">char glFun(int a){return;}</p> 
<p align="left">void main()</p> 
<p align="left">{<!-- --></p> 
<p align="left">pFun =glFun;</p> 
<p align="left">(*pFun)(2);</p> 
<p align="left">}</p> 
<p align="left">第一行定义了一个指针变量<strong><span style="color:maroon">pFun</span></strong>.它是一个指向某种函数的指针，这种函数参数是一个int类型，返回值是char类型。<strong>只有第一句我们还无法使用这个指针，因为我们还未对它进行<span style="color:maroon">赋值</span></strong>。</p> 
<p align="left">第二行定义了一个函数<strong><span style="color:maroon">glFun().</span></strong>该函数正好是一个以int为参数返回char的函数。我们要从指针的层次上理解函数-<strong><span style="color:maroon">函数的函数名实际上就是一个指针</span></strong>，<strong><span style="color:maroon">函数名</span></strong>指向<strong><span style="color:maroon">该函数的代码在内存中的首地址</span></strong>。</p> 
<p align="left">下面是一个例子：</p> 
<p align="left" style="background:rgb(248,248,248)"><span style="color:silver">C</span><span style="color:silver">代码</span><span style="color:silver"> </span><span style="color:silver"><a target="_blank" href="http://fouri.javaeye.com/blog/483974" rel="nofollow noopener noreferrer" title="复制代码"></a></span></p> 
<div style="background:#F8F8F8"> 
 <p align="left"><span style="color:#5C5C5C">1.  </span><span style="color:#008200">//#include&lt;iostream.h&gt; </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">2.  </span><span style="color:gray">#include&lt;stdio.h&gt; </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">3.  </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">4.  </span><strong><span style="color:#7F0055">typedef</span> <span style="color:seagreen">int</span></strong> (*FP_CALC)(<strong><span style="color:seagreen">int</span></strong>, <strong><span style="color:seagreen">int</span></strong>);   </p> 
 <p align="left"><span style="color:#5C5C5C">5.  </span><span style="color:#008200">//</span><span style="color:#008200">注意这里不是函数声明而是函数定义，它是一个地址，你可以直接输出</span><span style="color:#008200">add</span><span style="color:#008200">看看</span><span style="color:#008200"> </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">6.  </span><strong><span style="color:seagreen">int</span></strong> add(<strong><span style="color:seagreen">int</span></strong> a, <strong><span style="color:seagreen">int</span></strong> b)   </p> 
 <p align="left"><span style="color:#5C5C5C">7.  </span>{  </p> 
 <p align="left"><span style="color:#5C5C5C">8.  </span>     <strong><span style="color:#7F0055">return</span></strong> a + b;   </p> 
 <p align="left"><span style="color:#5C5C5C">9.  </span>}  </p> 
 <p align="left"><span style="color:#5C5C5C">10.  </span><strong><span style="color:seagreen">int</span></strong> sub(<strong><span style="color:seagreen">int</span></strong> a, <strong><span style="color:seagreen">int</span></strong> b)   </p> 
 <p align="left"><span style="color:#5C5C5C">11.  </span>{   </p> 
 <p align="left"><span style="color:#5C5C5C">12.  </span>     <strong><span style="color:#7F0055">return</span></strong> a - b;   </p> 
 <p align="left"><span style="color:#5C5C5C">13.  </span>}   </p> 
 <p align="left"><span style="color:#5C5C5C">14.  </span><strong><span style="color:seagreen">int</span></strong> mul(<strong><span style="color:seagreen">int</span></strong> a, <strong><span style="color:seagreen">int</span></strong> b)   </p> 
 <p align="left"><span style="color:#5C5C5C">15.  </span>{   </p> 
 <p align="left"><span style="color:#5C5C5C">16.  </span>     <strong><span style="color:#7F0055">return</span></strong> a * b;   </p> 
 <p align="left"><span style="color:#5C5C5C">17.  </span>}   </p> 
 <p align="left"><span style="color:#5C5C5C">18.  </span><strong><span style="color:seagreen">int</span></strong> div(<strong><span style="color:seagreen">int</span></strong> a, <strong><span style="color:seagreen">int</span></strong> b)   </p> 
 <p align="left"><span style="color:#5C5C5C">19.  </span>{   </p> 
 <p align="left"><span style="color:#5C5C5C">20.  </span>     <strong><span style="color:#7F0055">return</span></strong> b? a/b : -1;   </p> 
 <p align="left"><span style="color:#5C5C5C">21.  </span>}   </p> 
 <p align="left"><span style="color:#5C5C5C">22.  </span><span style="color:#008200">//</span><span style="color:#008200">定义一个函数，参数为</span><span style="color:#008200">op</span><span style="color:#008200">，返回一个指针。该指针类型为</span><span style="color:#008200">拥有两个</span><span style="color:#008200">int</span><span style="color:#008200">参数、</span><span style="color:#008200"> </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">23.  </span><span style="color:#008200">//</span><span style="color:#008200">返回类型为</span><span style="color:#008200">int </span><span style="color:#008200">的函数指针。它的作用是根据操作符返回相应函数的地址</span><span style="color:#008200"> </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">24.  </span>FP_CALC calc_func(<strong><span style="color:seagreen">char</span></strong> op)   </p> 
 <p align="left"><span style="color:#5C5C5C">25.  </span>{   </p> 
 <p align="left"><span style="color:#5C5C5C">26.  </span>     <strong><span style="color:#7F0055">switch</span></strong> (op)   </p> 
 <p align="left"><span style="color:#5C5C5C">27.  </span>      {   </p> 
 <p align="left"><span style="color:#5C5C5C">28.  </span>     <strong><span style="color:#7F0055">case</span></strong> <span style="color:blue">'+'</span>: <strong><span style="color:#7F0055">return</span></strong> add;<span style="color:#008200">//</span><span style="color:#008200">返回函数的地址</span><span style="color:#008200"> </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">29.  </span>     <strong><span style="color:#7F0055">case</span></strong> <span style="color:blue">'-'</span>: <strong><span style="color:#7F0055">return</span></strong> sub;   </p> 
 <p align="left"><span style="color:#5C5C5C">30.  </span>     <strong><span style="color:#7F0055">case</span></strong> <span style="color:blue">'*'</span>: <strong><span style="color:#7F0055">return</span></strong> mul;   </p> 
 <p align="left"><span style="color:#5C5C5C">31.  </span>     <strong><span style="color:#7F0055">case</span></strong> <span style="color:blue">'/'</span>: <strong><span style="color:#7F0055">return</span></strong> div;   </p> 
 <p align="left"><span style="color:#5C5C5C">32.  </span>     <strong><span style="color:#7F0055">default</span></strong>:   </p> 
 <p align="left"><span style="color:#5C5C5C">33.  </span>         <strong><span style="color:#7F0055">return</span></strong> NULL;   </p> 
 <p align="left"><span style="color:#5C5C5C">34.  </span>      }   </p> 
 <p align="left"><span style="color:#5C5C5C">35.  </span>     <strong><span style="color:#7F0055">return</span></strong> NULL;   </p> 
 <p align="left"><span style="color:#5C5C5C">36.  </span>}   </p> 
 <p align="left"><span style="color:#5C5C5C">37.  </span><span style="color:#008200">//s_calc_func</span><span style="color:#008200">为函数，它的参数是</span><span style="color:#008200"> op</span><span style="color:#008200">，</span><span style="color:#008200"> </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">38.  </span><span style="color:#008200">//</span><span style="color:#008200">返回值为一个拥有</span><span style="color:#008200">两个</span><span style="color:#008200">int</span><span style="color:#008200">参数、返回类型为</span><span style="color:#008200">int </span><span style="color:#008200">的函数指针</span><span style="color:#008200"> </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">39.  </span><strong><span style="color:seagreen">int</span></strong> (*s_calc_func(<strong><span style="color:seagreen">char</span></strong> op)) (<strong><span style="color:seagreen">int</span></strong>, <strong><span style="color:seagreen">int</span></strong>)   </p> 
 <p align="left"><span style="color:#5C5C5C">40.  </span>{   </p> 
 <p align="left"><span style="color:#5C5C5C">41.  </span>     <strong><span style="color:#7F0055">return</span></strong> calc_func(op);   </p> 
 <p align="left"><span style="color:#5C5C5C">42.  </span>}   </p> 
 <p align="left"><span style="color:#5C5C5C">43.  </span><span style="color:#008200">//</span><span style="color:#008200">最终用户直接调用的函数，该函数接收两个</span><span style="color:#008200">int</span><span style="color:#008200">整数，和一个算术运算符，返回两数的运算结果</span><span style="color:#008200"> </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">44.  </span><strong><span style="color:seagreen">int</span></strong> calc(<strong><span style="color:seagreen">int</span></strong> a, <strong><span style="color:seagreen">int</span></strong> b, <strong><span style="color:seagreen">char</span></strong> op)   </p> 
 <p align="left"><span style="color:#5C5C5C">45.  </span>{   </p> 
 <p align="left"><span style="color:#5C5C5C">46.  </span>      FP_CALC fp =calc_func(op); <span style="color:#008200">//</span><span style="color:#008200">根据预算符得到各种运算的函数的地址</span><span style="color:#008200"> </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">47.  </span>         <strong><span style="color:seagreen">int</span></strong> (*s_fp)(<strong><span style="color:seagreen">int</span></strong>, <strong><span style="color:seagreen">int</span></strong>) = s_calc_func(op);<span style="color:#008200">//</span><span style="color:#008200">用于测试</span><span style="color:#008200"> </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">48.  </span>         <span style="color:#008200">// ASSERT(fp ==s_fp);    // </span><span style="color:#008200">可以断言这俩是相等的</span><span style="color:#008200"> </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">49.  </span>     <strong><span style="color:#7F0055">if</span></strong> (fp) <strong><span style="color:#7F0055">return</span></strong> fp(a, b);<span style="color:#008200">//</span><span style="color:#008200">根据上一步得到的函数的地址调用相应函数，并返回结果</span><span style="color:#008200"> </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">50.  </span>     <strong><span style="color:#7F0055">else</span> <span style="color:#7F0055">return</span></strong> -1;   </p> 
 <p align="left"><span style="color:#5C5C5C">51.  </span>}   </p> 
 <p align="left"><span style="color:#5C5C5C">52.  </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">53.  </span><strong><span style="color:#7F0055">void</span></strong> main()   </p> 
 <p align="left"><span style="color:#5C5C5C">54.  </span>{      </p> 
 <p align="left"><span style="color:#5C5C5C">55.  </span>    <strong><span style="color:seagreen">int</span></strong> a = 100, b = 20;   </p> 
 <p align="left"><span style="color:#5C5C5C">56.  </span>  </p> 
 <p align="left"><span style="color:#5C5C5C">57.  </span>      printf(<span style="color:blue">"calc(%d, %d, %c)= %d\n"</span>, a, b, <span style="color:blue">'+'</span>, calc(a, b, <span style="color:blue">'+'</span>));   </p> 
 <p align="left"><span style="color:#5C5C5C">58.  </span>      printf(<span style="color:blue">"calc(%d, %d, %c)= %d\n"</span>, a, b, <span style="color:blue">'-'</span>, calc(a, b, <span style="color:blue">'-'</span>));   </p> 
 <p align="left"><span style="color:#5C5C5C">59.  </span>      printf(<span style="color:blue">"calc(%d, %d, %c)= %d\n"</span>, a, b, <span style="color:blue">'*'</span>, calc(a, b, <span style="color:blue">'*'</span>));   </p> 
 <p align="left"><span style="color:#5C5C5C">60.  </span>      printf(<span style="color:blue">"calc(%d, %d, %c)= %d\n"</span>, a, b, <span style="color:blue">'/'</span>, calc(a, b, <span style="color:blue">'/'</span>));   </p> 
 <p align="left"><span style="color:#5C5C5C">61.  </span>}  </p> 
</div> 
<p align="left">//#include&lt;iostream.h&gt;</p> 
<p align="left">#include&lt;stdio.h&gt;</p> 
<p align="left">typedef int(*FP_CALC)(int, int);</p> 
<p align="left">//注意这里不是函数声明而是函数定义，它是一个地址，你可以直接输出add看看</p> 
<p align="left">int add(int a, int b)</p> 
<p align="left">{<!-- --></p> 
<p align="left">return a + b;</p> 
<p align="left">}</p> 
<p align="left">int sub(int a, int b)</p> 
<p align="left">{<!-- --></p> 
<p align="left">return a - b;</p> 
<p align="left">}</p> 
<p align="left">int mul(int a, int b)</p> 
<p align="left">{<!-- --></p> 
<p align="left">return a * b;</p> 
<p align="left">}</p> 
<p align="left">int div(int a, int b)</p> 
<p align="left">{<!-- --></p> 
<p align="left">return b? a/b : -1;</p> 
<p align="left">}</p> 
<p align="left">//定义一个函数，参数为op，返回一个指针。该指针类型为 拥有两个int参数、</p> 
<p align="left">//返回类型为int 的函数指针。它的作用是根据操作符返回相应函数的地址</p> 
<p align="left">FP_CALCcalc_func(char op)</p> 
<p align="left">{<!-- --></p> 
<p align="left">switch (op)</p> 
<p align="left">{<!-- --></p> 
<p align="left">case '+': returnadd;//返回函数的地址</p> 
<p align="left">case '-': return sub;</p> 
<p align="left">case '*': return mul;</p> 
<p align="left">case '/': return div;</p> 
<p align="left">default:</p> 
<p align="left">return NULL;</p> 
<p align="left">}</p> 
<p align="left">return NULL;</p> 
<p align="left">}</p> 
<p align="left">//s_calc_func为函数，它的参数是 op，</p> 
<p align="left">//返回值为一个拥有 两个int参数、返回类型为int 的函数指针</p> 
<p align="left">int(*s_calc_func(char op)) (int, int)</p> 
<p align="left">{<!-- --></p> 
<p align="left">return calc_func(op);</p> 
<p align="left">}</p> 
<p align="left">//最终用户直接调用的函数，该函数接收两个int整数，和一个算术运算符，返回两数的运算结果</p> 
<p align="left">int calc(int a, intb, char op)</p> 
<p align="left">{<!-- --></p> 
<p align="left">FP_CALC fp =calc_func(op); //根据预算符得到各种运算的函数的地址</p> 
<p align="left">int (*s_fp)(int, int)= s_calc_func(op);//用于测试</p> 
<p align="left">// ASSERT(fp ==s_fp);   // 可以断言这俩是相等的</p> 
<p align="left">if (fp) return fp(a,b);//根据上一步得到的函数的地址调用相应函数，并返回结果</p> 
<p align="left">else return -1;</p> 
<p align="left">}</p> 
<p align="left">void main()</p> 
<p align="left">{<!-- --></p> 
<p align="left">int a = 100, b = 20;</p> 
<p align="left">printf("calc(%d,%d, %c) = %d\n", a, b, '+', calc(a, b, '+'));</p> 
<p align="left">printf("calc(%d,%d, %c) = %d\n", a, b, '-', calc(a, b, '-'));</p> 
<p align="left">printf("calc(%d,%d, %c) = %d\n", a, b, '*', calc(a, b, '*'));</p> 
<p align="left">printf("calc(%d,%d, %c) = %d\n", a, b, '/', calc(a, b, '/'));</p> 
<p align="left">}</p> 
<p align="left">运行结果</p> 
<p align="left">   calc(100, 20, +) = 120</p> 
<p align="left">   calc(100, 20, -) = 80</p> 
<p align="left">   calc(100, 20, *) = 2000</p> 
<p align="left">   calc(100, 20, /) = 5</p> 
<p align="left">来自: <a target="_blank" href="http://hi.baidu.com/%D6%EC%CF%E9/blog/item/482290cb4b6dfeed53664fda.html" rel="nofollow noopener noreferrer"><span style="color:#1D58D1">http://hi.baidu.com/%D6%EC%CF%E9/blog/item/482290cb4b6dfeed53664fda.html</span></a></p> 
<h3><a target="_blank" name="_Toc376251260"></a><a target="_blank" name="_Toc369176439">﻿</a><span style="color:#3A3A3A">【转】（转）</span><span style="color:#3A3A3A">MFC</span><span style="color:#3A3A3A">中</span><span style="color:#3A3A3A">TRACE</span><span style="color:#3A3A3A">的用法</span></h3> 
<p><span style="color:#454545">个人总结：最近看网络编程是碰到了</span><span style="color:#454545">TRACE</span><span style="color:#454545">语句，不知道在哪里输出，查了一晚上资料也没找出来，今天终于在</span><span style="color:#454545">CSDN</span><span style="color:#454545">上找到了，真是个高地方啊，方法如下：</span></p> 
<p><span style="color:#454545">1.</span><span style="color:#454545">在</span><span style="color:#454545">MFC</span><span style="color:#454545">中加入</span><span style="color:#454545">TRACE</span><span style="color:#454545">语句</span></p> 
<p><span style="color:#454545">2.</span><span style="color:#454545">在</span><span style="color:#454545">TOOLS-&gt;MFCTRACER</span><span style="color:#454545">中选择</span><span style="color:#454545">“ENABLE TRACING”</span><span style="color:#454545">点击</span><span style="color:#454545">OK</span></p> 
<p><span style="color:#454545">3.</span><span style="color:#454545">进行调试运行，</span><span style="color:#454545">GO(F5)</span><span style="color:#454545">（特别注意：不是执行</span><span style="color:#454545">‘</span><span style="color:#454545">！</span><span style="color:#454545">’</span><span style="color:#454545">以前之所以不能看到</span><span style="color:#454545">TRACE</span><span style="color:#454545">内容，是因为不是调试执行，而是</span><span style="color:#454545">‘</span><span style="color:#454545">！</span><span style="color:#454545">’</span><span style="color:#454545">了，切记，切记）</span></p> 
<p><span style="color:#454545">4.</span><span style="color:#454545">然后就会在</span><span style="color:#454545">OUTPUT</span><span style="color:#454545">中的</span><span style="color:#454545">DEBUG</span><span style="color:#454545">窗口中看到</span><span style="color:#454545">TRACE</span><span style="color:#454545">内容了，调试执行会自动从</span><span style="color:#454545">BUILD</span><span style="color:#454545">窗口跳到</span><span style="color:#454545">DEBUG</span><span style="color:#454545">窗口，在那里就看到</span><span style="color:#454545">TRACE</span><span style="color:#454545">的内容了，</span><span style="color:#454545">^_^</span></p> 
<p><span style="color:#454545">以下是找的</span><span style="color:#454545">TRACE</span><span style="color:#454545">的详细介绍：</span></p> 
<p><span style="color:#454545"> </span><span style="color:#454545">＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</span></p> 
<p><span style="color:#454545">      TRACE</span><span style="color:#454545">宏对于</span><span style="color:#454545">VC</span><span style="color:#454545">下程序调试来说是很有用的东西，有着类似</span><span style="color:#454545">printf</span><span style="color:#454545">的功能；该宏仅仅在程序的</span><span style="color:#454545">DEBUG</span><span style="color:#454545">版本中出现，当</span><span style="color:#454545">RELEASE</span><span style="color:#454545">的时候该宏就完全消息了，从而帮助你调式也在</span><span style="color:#454545">RELEASE</span><span style="color:#454545">的时候减少代码量。</span></p> 
<p><span style="color:#454545">使用非常简单，格式如下：</span></p> 
<p><span style="color:#454545">TRACE("DDDDDDDDDDD");</span></p> 
<p><span style="color:#454545">TRACE("wewe%d",333);</span></p> 
<p><span style="color:#454545">同样还存在</span><span style="color:#454545">TRACE0</span><span style="color:#454545">，</span><span style="color:#454545">TRACE1</span><span style="color:#454545">，</span><span style="color:#454545">TRACE2</span><span style="color:#454545">。。。分别对应</span><span style="color:#454545">0</span><span style="color:#454545">，</span><span style="color:#454545">1</span><span style="color:#454545">，</span><span style="color:#454545">2</span><span style="color:#454545">。。个参数</span></p> 
<p><span style="color:#454545">TRACE</span><span style="color:#454545">信息输出到</span><span style="color:#454545">VC IDE</span><span style="color:#454545">环境的输出窗口（该窗口是你编译项目出错提示的哪个窗口），但仅限于你在</span><span style="color:#454545">VC</span><span style="color:#454545">中运行你的</span><span style="color:#454545">DEBUG</span><span style="color:#454545">版本的程序。</span></p> 
<p><span style="color:#454545">TRACE</span><span style="color:#454545">信息还可以使用</span><span style="color:#454545">DEBUGVIEW</span><span style="color:#454545">来捕获到。这种情况下，你不能在</span><span style="color:#454545">VC</span><span style="color:#454545">的</span><span style="color:#454545">IDE</span><span style="color:#454545">环境中运行你的程序，而将</span><span style="color:#454545">BUILD</span><span style="color:#454545">好的</span><span style="color:#454545">DEBUG</span><span style="color:#454545">版本的程序单独运行，这个时候可以在</span><span style="color:#454545">DEBUGVIEW</span><span style="color:#454545">的窗口看到</span><span style="color:#454545">DEBUGVIE</span><span style="color:#454545">格式的输出了。</span></p> 
<p><span style="color:#454545">VC</span><span style="color:#454545">中</span><span style="color:#454545">TRACE</span><span style="color:#454545">的用法有以下四种：</span></p> 
<p><span style="color:#454545">1:</span></p> 
<p><span style="color:#454545">TRACE   </span><span style="color:#454545">，就是不带动态参数输出字符串</span><span style="color:#454545">,  </span><span style="color:#454545">类似</span><span style="color:#454545">C</span><span style="color:#454545">的</span><span style="color:#454545">printf("</span><span style="color:#454545">输出字符串</span><span style="color:#454545">"); </span><br>     <br> 2:</p> 
<p><span style="color:#454545">TRACE   </span><span style="color:#454545">中的字符串可以带一个参数输出</span><span style="color:#454545">  , </span><span style="color:#454545">类似</span><span style="color:#454545">C</span><span style="color:#454545">的</span><span style="color:#454545">printf("...%d",</span><span style="color:#454545">变量</span><span style="color:#454545">);</span></p> 
<p><span style="color:#454545">3:</span></p> 
<p><span style="color:#454545">TRACE   </span><span style="color:#454545">可以带两个参数输出，类似</span><span style="color:#454545">C</span><span style="color:#454545">的</span><span style="color:#454545">printf("...%d...%f",</span><span style="color:#454545">变量</span><span style="color:#454545">1,</span><span style="color:#454545">变量</span><span style="color:#454545">2);</span></p> 
<p><span style="color:#454545">4:</span></p> 
<p><span style="color:#454545">TRACE </span><span style="color:#454545">可以带三个参数输出，类似</span><span style="color:#454545">C</span><span style="color:#454545">的</span><span style="color:#454545">printf("...%d</span><span style="color:#454545">，</span><span style="color:#454545">%d,%d",</span><span style="color:#454545">变量</span><span style="color:#454545">1,</span><span style="color:#454545">变量</span><span style="color:#454545">2</span><span style="color:#454545">，变量</span><span style="color:#454545">3);</span></p> 
<p><span style="color:#454545">TRACE </span><span style="color:#454545">宏有点象我们以前在</span><span style="color:#454545">C</span><span style="color:#454545">语言中用的</span><span style="color:#454545">Printf</span><span style="color:#454545">函数，使程序在运行过程中输出一些调试信息，使我们能了解程序的一些状态。但有一点不同的是：</span></p> 
<p><span style="color:#454545"><br> TRACE </span><span style="color:#454545">宏只有在调试状态下才有所输出，而以前用的</span><span style="color:#454545">Printf</span><span style="color:#454545">函数在任何情况下都有输出。和</span><span style="color:#454545">Printf</span><span style="color:#454545">函数一样，</span><span style="color:#454545">TRACE</span><span style="color:#454545">函数可以接受多个参数如：</span></p> 
<p><span style="color:#454545">int x = 1;<br> int y = 16;<br> float z = 32.0;<br> TRACE( "This is a TRACE statement\n" );<br> TRACE( "The value of x is %d\n", x );<br> TRACE( "x = %d and y = %d\n", x, y );<br> TRACE( "x = %d and y = %x and z = %f\n", x, y, z );</span></p> 
<p><span style="color:#454545">要注意的是</span><span style="color:#454545">TRACE</span><span style="color:#454545">宏只对</span><span style="color:#454545">Debug </span><span style="color:#454545">版本的工程产生作用，在</span><span style="color:#454545">Release</span><span style="color:#454545">版本的工程中，</span><span style="color:#454545">TRACE</span><span style="color:#454545">宏将被忽略。</span></p> 
<h3><a target="_blank" name="_Toc376251261"></a><a target="_blank" name="_Toc369176440"><span style="color:#3A3A3A">linux c</span></a><span style="color:#3A3A3A">语言定时器</span></h3> 
<p><span style="color:#454545">linux</span><span style="color:#454545">定时器的使用使用定时器的目的无非是为了周期性的执行某一任务，或者是到了一个指定时间去执行某一个任务。要达到这一目的，一般有两个常见的比较有效的方法。一个是用</span><span style="color:#454545">linux</span><span style="color:#454545">内部的三个定时器，另一个是用</span><span style="color:#454545">sleep,usleep</span><span style="color:#454545">函数让进程睡眠一段时间，其实，还有一个方法，那就是用</span><span style="color:#454545">gettimeofday,difftime</span><span style="color:#454545">等自己来计算时间间隔，然后时间到了就执行某一任务，但是这种方法效率低，所以不常用。</span></p> 
<p><span style="color:#454545">首先来看看</span><span style="color:#454545">linux</span><span style="color:#454545">操作系统为每一个进程提供的</span><span style="color:#454545">3</span><span style="color:#454545">个内部计时器。</span></p> 
<p><span style="color:#454545">ITIMER_REAL: </span><span style="color:#454545">给一个指定的时间间隔，按照实际的时间来减少这个计数，当时间间隔为</span><span style="color:#454545">0</span><span style="color:#454545">的时候发出</span><span style="color:#454545">SIGALRM</span><span style="color:#454545">信号</span></p> 
<p><span style="color:#454545">ITIMER_VIRTUAL: </span><span style="color:#454545">给定一个时间间隔，当进程执行的时候才减少计数，时间间隔为</span><span style="color:#454545">0</span><span style="color:#454545">的时候发出</span><span style="color:#454545">SIGVTALRM</span><span style="color:#454545">信号</span></p> 
<p><span style="color:#454545">ITIMER_PROF: </span><span style="color:#454545">给定一个时间间隔，当进程执行或者是系统为进程调度的时候，减少计数，时间到了，发出</span><span style="color:#454545">SIGPROF</span><span style="color:#454545">信号，这个和</span><span style="color:#454545">ITIMER_VIRTUAL</span><span style="color:#454545">联合，常用来计算系统内核时间和用户时间。</span></p> 
<p><span style="color:#454545">用到的函数有：</span></p> 
<p><span style="color:#454545">#include&lt;sys/time.h&gt;<br> int getitimer(int which, struct itimerval *value);<br> int setitimer(int which, struct itimerval*newvalue, struct itimerval*oldvalue);<br> strcut timeval<br> {<!-- --><br> long tv_sec; /*</span><span style="color:#454545">秒</span><span style="color:#454545">*/<br> long tv_usec; /*</span><span style="color:#454545">微秒</span><span style="color:#454545">*/<br> };<br> struct itimerval<br> {<!-- --><br> struct timeval it_interval; /*</span><span style="color:#454545">时间间隔</span><span style="color:#454545">*/<br> struct timeval it_value;   /*</span><span style="color:#454545">当前时间计数</span><span style="color:#454545">*/<br> };</span></p> 
<p><span style="color:#454545">it_interval</span><span style="color:#454545">用来指定每隔多长时间执行任务，</span><span style="color:#454545">it_value</span><span style="color:#454545">用来保存当前时间离执行任务还有多长时间。比如说，</span><span style="color:#454545">你指定</span><span style="color:#454545">it_interval</span><span style="color:#454545">为</span><span style="color:#454545">2</span><span style="color:#454545">秒</span><span style="color:#454545">(</span><span style="color:#454545">微秒为</span><span style="color:#454545">0)</span><span style="color:#454545">，开始的时候我们把</span><span style="color:#454545">it_value</span><span style="color:#454545">的时间也设定为</span><span style="color:#454545">2</span><span style="color:#454545">秒（微秒为</span><span style="color:#454545">0</span><span style="color:#454545">），当过了一秒，</span><span style="color:#454545">it_value</span><span style="color:#454545">就减少一个为</span><span style="color:#454545">1</span><span style="color:#454545">，</span><span style="color:#454545">再过</span><span style="color:#454545">1</span><span style="color:#454545">秒，则</span><span style="color:#454545">it_value</span><span style="color:#454545">又减少</span><span style="color:#454545">1</span><span style="color:#454545">，变为</span><span style="color:#454545">0</span><span style="color:#454545">，这个时候发出信号（告诉用户时间到了，可以执行任务了），并且系统自动把</span><span style="color:#454545">it_value</span><span style="color:#454545">的时间重置为</span><span style="color:#454545">it_interval</span><span style="color:#454545">的值，即</span><span style="color:#454545">2</span><span style="color:#454545">秒，再重新计数。</span></p> 
<p><span style="color:#454545">为了帮助你理解这个问题，我们来看一个例子：</span></p> 
<p align="left"><span style="color:#454545">1.    </span><span style="color:#454545">#include &lt;sys/time.h&gt;</span></p> 
<p align="left"><span style="color:#454545">2.    </span><span style="color:#454545">#include &lt;stdio.h&gt;</span></p> 
<p align="left"><span style="color:#454545">3.    </span><span style="color:#454545">#include &lt;unistd.h&gt;</span></p> 
<p align="left"><span style="color:#454545">4.    </span><span style="color:#454545">#include &lt;signal.h&gt;</span></p> 
<p align="left"><span style="color:#454545">5.    </span><span style="color:#454545">#include &lt;string.h&gt;</span></p> 
<p align="left"><span style="color:#454545">6.    </span><span style="color:#454545"> </span></p> 
<p align="left"><span style="color:#454545">7.    </span><span style="color:#454545">static char msg[] = “time isrunning out\n”;</span></p> 
<p align="left"><span style="color:#454545">8.    </span><span style="color:#454545">static int len;</span></p> 
<p align="left"><span style="color:#454545">9.    </span><span style="color:#454545"> </span></p> 
<p align="left"><span style="color:#454545">10. </span><span style="color:#454545">// </span><span style="color:#454545">向标准错误输出信息，告诉用户时间到了</span></p> 
<p align="left"><span style="color:#454545">11. </span><span style="color:#454545">void prompt_info(int signo)</span></p> 
<p align="left"><span style="color:#454545">12. </span><span style="color:#454545">{<!-- --></span></p> 
<p align="left"><span style="color:#454545">13. </span><span style="color:#454545">write(STDERR_FILENO, msg,len);</span></p> 
<p align="left"><span style="color:#454545">14. </span><span style="color:#454545">}</span></p> 
<p align="left"><span style="color:#454545">15. </span><span style="color:#454545"> </span></p> 
<p align="left"><span style="color:#454545">16. </span><span style="color:#454545">// </span><span style="color:#454545">建立信号处理机制</span></p> 
<p align="left"><span style="color:#454545">17. </span><span style="color:#454545">void init_sigaction(void)</span></p> 
<p align="left"><span style="color:#454545">18. </span><span style="color:#454545">{<!-- --></span></p> 
<p align="left"><span style="color:#454545">19. </span><span style="color:#454545">struct sigaction tact;</span></p> 
<p align="left"><span style="color:#454545">20. </span><span style="color:#454545"> </span></p> 
<p align="left"><span style="color:#454545">21. </span><span style="color:#454545">/*</span><span style="color:#454545">信号到了要执行的任务处理函数为</span><span style="color:#454545">prompt_info*/</span></p> 
<p align="left"><span style="color:#454545">22. </span><span style="color:#454545">tact.sa_handler = prompt_info;</span></p> 
<p align="left"><span style="color:#454545">23. </span><span style="color:#454545">tact.sa_flags = 0;</span></p> 
<p align="left"><span style="color:#454545">24. </span><span style="color:#454545">/*</span><span style="color:#454545">初始化信号集</span><span style="color:#454545">*/</span></p> 
<p align="left"><span style="color:#454545">25. </span><span style="color:#454545">sigemptyset(&amp;tact.sa_mask);</span></p> 
<p align="left"><span style="color:#454545">26. </span><span style="color:#454545">/*</span><span style="color:#454545">建立信号处理机制</span><span style="color:#454545">*/</span></p> 
<p align="left"><span style="color:#454545">27. </span><span style="color:#454545">sigaction(SIGALRM, &amp;tact,NULL);</span></p> 
<p align="left"><span style="color:#454545">28. </span><span style="color:#454545">}</span></p> 
<p align="left"><span style="color:#454545">29. </span><span style="color:#454545"> </span></p> 
<p align="left"><span style="color:#454545">30. </span><span style="color:#454545">void init_time()</span></p> 
<p align="left"><span style="color:#454545">31. </span><span style="color:#454545">{<!-- --></span></p> 
<p align="left"><span style="color:#454545">32. </span><span style="color:#454545">struct itimerval value;</span></p> 
<p align="left"><span style="color:#454545">33. </span><span style="color:#454545"> </span></p> 
<p align="left"><span style="color:#454545">34. </span><span style="color:#454545">/*</span><span style="color:#454545">设定执行任务的时间间隔为</span><span style="color:#454545">2</span><span style="color:#454545">秒</span><span style="color:#454545">0</span><span style="color:#454545">微秒</span><span style="color:#454545">*/</span></p> 
<p align="left"><span style="color:#454545">35. </span><span style="color:#454545">value.it_value.tv_sec = 2;</span></p> 
<p align="left"><span style="color:#454545">36. </span><span style="color:#454545">value.it_value.tv_usec = 0;</span></p> 
<p align="left"><span style="color:#454545">37. </span><span style="color:#454545">/*</span><span style="color:#454545">设定初始时间计数也为</span><span style="color:#454545">2</span><span style="color:#454545">秒</span><span style="color:#454545">0</span><span style="color:#454545">微秒</span><span style="color:#454545">*/</span></p> 
<p align="left"><span style="color:#454545">38. </span><span style="color:#454545">value.it_interval =value.it_value;</span></p> 
<p align="left"><span style="color:#454545">39. </span><span style="color:#454545">/*</span><span style="color:#454545">设置计时器</span><span style="color:#454545">ITIMER_REAL*/</span></p> 
<p align="left"><span style="color:#454545">40. </span><span style="color:#454545">setitimer(ITIMER_REAL,&amp;value, NULL);</span></p> 
<p align="left"><span style="color:#454545">41. </span><span style="color:#454545">}</span></p> 
<p align="left"><span style="color:#454545">42. </span><span style="color:#454545"> </span></p> 
<p align="left"><span style="color:#454545">43. </span><span style="color:#454545">int main()</span></p> 
<p align="left"><span style="color:#454545">44. </span><span style="color:#454545">{<!-- --></span></p> 
<p align="left"><span style="color:#454545">45. </span><span style="color:#454545">len = strlen(msg);</span></p> 
<p align="left"><span style="color:#454545">46. </span><span style="color:#454545">init_sigaction();</span></p> 
<p align="left"><span style="color:#454545">47. </span><span style="color:#454545">init_time();</span></p> 
<p align="left"><span style="color:#454545">48. </span><span style="color:#454545">while ( 1 );</span></p> 
<p align="left"><span style="color:#454545">49. </span><span style="color:#454545">exit(0);</span></p> 
<p align="left"><span style="color:#454545">50. </span><span style="color:#454545">}</span></p> 
<p><span style="color:#454545">该程序的</span><span style="color:#454545">ITMER_REAL</span><span style="color:#454545">定时器，每隔</span><span style="color:#454545">2</span><span style="color:#454545">秒钟都会发送一个</span><span style="color:#454545">SIGALRM</span><span style="color:#454545">信号，当主函数接收到了这个信号之后，调用信号处理函数</span><span style="color:#454545">prompt_info</span><span style="color:#454545">在标准错误上输出</span><span style="color:#454545">timeis running out</span><span style="color:#454545">这个字符串。</span></p> 
<p><span style="color:#454545">对于</span><span style="color:#454545">ITIMER_VIRTUAL</span><span style="color:#454545">和</span><span style="color:#454545">ITIMER_PROF</span><span style="color:#454545">的使用方法类似，当你在</span><span style="color:#454545">setitimer</span><span style="color:#454545">里面设置的定时器为</span><span style="color:#454545">ITIMER_VIRTUAL</span><span style="color:#454545">的时候，你把</span><span style="color:#454545">sigaction</span><span style="color:#454545">里面的</span><span style="color:#454545">SIGALRM</span><span style="color:#454545">改为</span><span style="color:#454545">SIGVTALARM,</span><span style="color:#454545">同理，</span><span style="color:#454545">ITIMER_PROF</span><span style="color:#454545">对应</span><span style="color:#454545">SIGPROF</span><span style="color:#454545">。</span></p> 
<p><span style="color:#454545">不过，你可能会注意到，当你用</span><span style="color:#454545">ITIMER_VIRTUAL</span><span style="color:#454545">和</span><span style="color:#454545">ITIMER_PROF</span><span style="color:#454545">的时候，你拿一个秒表，你会发现程序输出字符串的时间间隔会不止</span><span style="color:#454545">2</span><span style="color:#454545">秒，甚至</span><span style="color:#454545">5-6</span><span style="color:#454545">秒才会输出一个，至于为什么，自己好好琢磨一下</span><span style="color:#454545">^_^</span></p> 
<p><span style="color:#454545">下面我们来看看用</span><span style="color:#454545">sleep</span><span style="color:#454545">以及</span><span style="color:#454545">usleep</span><span style="color:#454545">怎么实现定时执行任务。</span></p> 
<p align="left"><span style="color:#454545">1.    </span><span style="color:#454545">#include &lt;signal.h&gt;</span></p> 
<p align="left"><span style="color:#454545">2.    </span><span style="color:#454545">#include &lt;unistd.h&gt;</span></p> 
<p align="left"><span style="color:#454545">3.    </span><span style="color:#454545">#include &lt;string.h&gt;</span></p> 
<p align="left"><span style="color:#454545">4.    </span><span style="color:#454545">#include &lt;stdio.h&gt;</span></p> 
<p align="left"><span style="color:#454545">5.    </span><span style="color:#454545"> </span></p> 
<p align="left"><span style="color:#454545">6.    </span><span style="color:#454545">static char msg[] = “Ireceived a msg.\n”;</span></p> 
<p align="left"><span style="color:#454545">7.    </span><span style="color:#454545">int len;</span></p> 
<p align="left"><span style="color:#454545">8.    </span><span style="color:#454545">void show_msg(int signo)</span></p> 
<p align="left"><span style="color:#454545">9.    </span><span style="color:#454545">{<!-- --></span></p> 
<p align="left"><span style="color:#454545">10. </span><span style="color:#454545">write(STDERR_FILENO, msg,len);</span></p> 
<p align="left"><span style="color:#454545">11. </span><span style="color:#454545">}</span></p> 
<p align="left"><span style="color:#454545">12. </span><span style="color:#454545">int main()</span></p> 
<p align="left"><span style="color:#454545">13. </span><span style="color:#454545">{<!-- --></span></p> 
<p align="left"><span style="color:#454545">14. </span><span style="color:#454545">struct sigaction act;</span></p> 
<p align="left"><span style="color:#454545">15. </span><span style="color:#454545">union sigval tsval;</span></p> 
<p align="left"><span style="color:#454545">16. </span><span style="color:#454545"> </span></p> 
<p align="left"><span style="color:#454545">17. </span><span style="color:#454545">act.sa_handler = show_msg;</span></p> 
<p align="left"><span style="color:#454545">18. </span><span style="color:#454545">act.sa_flags = 0;</span></p> 
<p align="left"><span style="color:#454545">19. </span><span style="color:#454545">sigemptyset(&amp;act.sa_mask);</span></p> 
<p align="left"><span style="color:#454545">20. </span><span style="color:#454545">sigaction(50, &amp;act, NULL);</span></p> 
<p align="left"><span style="color:#454545">21. </span><span style="color:#454545"> </span></p> 
<p align="left"><span style="color:#454545">22. </span><span style="color:#454545">len = strlen(msg);</span></p> 
<p align="left"><span style="color:#454545">23. </span><span style="color:#454545">while ( 1 )</span></p> 
<p align="left"><span style="color:#454545">24. </span><span style="color:#454545">{<!-- --></span></p> 
<p align="left"><span style="color:#454545">25. </span><span style="color:#454545">sleep(2); /*</span><span style="color:#454545">睡眠</span><span style="color:#454545">2</span><span style="color:#454545">秒</span><span style="color:#454545">*/</span></p> 
<p align="left"><span style="color:#454545">26. </span><span style="color:#454545">/*</span><span style="color:#454545">向主进程发送信号，实际上是自己给自己发信号</span><span style="color:#454545">*/</span></p> 
<p align="left"><span style="color:#454545">27. </span><span style="color:#454545">sigqueue(getpid(), 50, tsval);</span></p> 
<p align="left"><span style="color:#454545">28. </span><span style="color:#454545">}</span></p> 
<p align="left"><span style="color:#454545">29. </span><span style="color:#454545">return 0;</span></p> 
<p align="left"><span style="color:#454545">30. </span><span style="color:#454545">}</span></p> 
<p><span style="color:#454545">看到了吧，这个要比上面的简单多了，而且你用秒表测一下，时间很准，指定</span><span style="color:#454545">2</span><span style="color:#454545">秒到了就给你输出一个字符串。所以，如果你只做一般的定时，到了时间去执行一个任务，这种方法是最简单的。</span></p> 
<p><span style="color:#454545">下面我们来看看，通过自己计算时间差的方法来定时：</span></p> 
<p align="left"><span style="color:#454545">1.    </span><span style="color:#454545">#include &lt;signal.h&gt;</span></p> 
<p align="left"><span style="color:#454545">2.    </span><span style="color:#454545">#include &lt;unistd.h&gt;</span></p> 
<p align="left"><span style="color:#454545">3.    </span><span style="color:#454545">#include &lt;string.h&gt;</span></p> 
<p align="left"><span style="color:#454545">4.    </span><span style="color:#454545">#include &lt;stdio.h&gt;</span></p> 
<p align="left"><span style="color:#454545">5.    </span><span style="color:#454545">#include &lt;time.h&gt;</span></p> 
<p align="left"><span style="color:#454545">6.    </span><span style="color:#454545"> </span></p> 
<p align="left"><span style="color:#454545">7.    </span><span style="color:#454545">static char msg[] = “Ireceived a msg.\n”;</span></p> 
<p align="left"><span style="color:#454545">8.    </span><span style="color:#454545">int len;</span></p> 
<p align="left"><span style="color:#454545">9.    </span><span style="color:#454545">static time_t lasttime;</span></p> 
<p align="left"><span style="color:#454545">10. </span><span style="color:#454545">void show_msg(int signo)</span></p> 
<p align="left"><span style="color:#454545">11. </span><span style="color:#454545">{<!-- --></span></p> 
<p align="left"><span style="color:#454545">12. </span><span style="color:#454545">write(STDERR_FILENO, msg,len);</span></p> 
<p align="left"><span style="color:#454545">13. </span><span style="color:#454545">}</span></p> 
<p align="left"><span style="color:#454545">14. </span><span style="color:#454545">int main()</span></p> 
<p align="left"><span style="color:#454545">15. </span><span style="color:#454545">{<!-- --></span></p> 
<p align="left"><span style="color:#454545">16. </span><span style="color:#454545">struct sigaction act;</span></p> 
<p align="left"><span style="color:#454545">17. </span><span style="color:#454545">union sigval tsval;</span></p> 
<p align="left"><span style="color:#454545">18. </span><span style="color:#454545"> </span></p> 
<p align="left"><span style="color:#454545">19. </span><span style="color:#454545">act.sa_handler = show_msg;</span></p> 
<p align="left"><span style="color:#454545">20. </span><span style="color:#454545">act.sa_flags = 0;</span></p> 
<p align="left"><span style="color:#454545">21. </span><span style="color:#454545">sigemptyset(&amp;act.sa_mask);</span></p> 
<p align="left"><span style="color:#454545">22. </span><span style="color:#454545">sigaction(50, &amp;act, NULL);</span></p> 
<p align="left"><span style="color:#454545">23. </span><span style="color:#454545"> </span></p> 
<p align="left"><span style="color:#454545">24. </span><span style="color:#454545">len = strlen(msg);</span></p> 
<p align="left"><span style="color:#454545">25. </span><span style="color:#454545">time(&amp;lasttime);</span></p> 
<p align="left"><span style="color:#454545">26. </span><span style="color:#454545">while ( 1 )</span></p> 
<p align="left"><span style="color:#454545">27. </span><span style="color:#454545">{<!-- --></span></p> 
<p align="left"><span style="color:#454545">28. </span><span style="color:#454545">time_t nowtime;</span></p> 
<p align="left"><span style="color:#454545">29. </span><span style="color:#454545">/*</span><span style="color:#454545">获取当前时间</span><span style="color:#454545">*/</span></p> 
<p align="left"><span style="color:#454545">30. </span><span style="color:#454545">time(&amp;nowtime);</span></p> 
<p align="left"><span style="color:#454545">31. </span><span style="color:#454545">/*</span><span style="color:#454545">和上一次的时间做比较，如果大于等于</span><span style="color:#454545">2</span><span style="color:#454545">秒，则立刻发送信号</span><span style="color:#454545">*/</span></p> 
<p align="left"><span style="color:#454545">32. </span><span style="color:#454545">if (nowtime – lasttime &gt;=2)</span></p> 
<p align="left"><span style="color:#454545">33. </span><span style="color:#454545">{<!-- --></span></p> 
<p align="left"><span style="color:#454545">34. </span><span style="color:#454545">/*</span><span style="color:#454545">向主进程发送信号，实际上是自己给自己发信号</span><span style="color:#454545">*/</span></p> 
<p align="left"><span style="color:#454545">35. </span><span style="color:#454545">sigqueue(getpid(), 50, tsval);</span></p> 
<p align="left"><span style="color:#454545">36. </span><span style="color:#454545">lasttime = nowtime;</span></p> 
<p align="left"><span style="color:#454545">37. </span><span style="color:#454545">}</span></p> 
<p align="left"><span style="color:#454545">38. </span><span style="color:#454545">}</span></p> 
<p align="left"><span style="color:#454545">39. </span><span style="color:#454545">return 0;</span></p> 
<p align="left"><span style="color:#454545">40. </span><span style="color:#454545">}</span></p> 
<p><span style="color:#454545">这个和上面不同之处在于，是自己手工计算时间差的，如果你想更精确的计算时间差，你可以把</span><span style="color:#454545">time </span><span style="color:#454545">函</span>数换成gettimeofday，这个可以精确到微妙。</p> 
<p>上面介绍的几种定时方法各有千秋，在计时效率上、方法上和时间的精确度上也各有不同，采用哪种方法，就看你程序的需要</p> 
<p>itimerval时钟的使用#include&lt;stdio.h&gt;<br> #include&lt;signal.h&gt;<br> #include&lt;sys/time.h&gt;//itimerval结构体的定义<br> <br> int handle_count=0;<br> void set_time(void)<br> {<!-- --><br>    struct itimerval itv;<br>    itv.it_interval.tv_sec=10;//自动装载，之后每10秒响应一次<br>    itv.it_interval.tv_usec=0;<br>    itv.it_value.tv_sec=5;//第一次定时的时间<br>    itv.it_value.tv_usec=0;<br>    setitimer(ITIMER_REAL,&amp;itv,NULL);<br> }<br> <br> void alarm_handle(int sig)<br> {<!-- --><br>    handle_count++;<br>    printf("have handle count is %d\n",handle_count);<br> }<br> <br> void main(void)<br> {<!-- --><br> <span style="color:#454545">   struct itimerval itv;<br>    signal(SIGALRM,alarm_handle);<br>    set_time();<br>    </span><br>    while(1){<!-- --><br>    getitimer(ITIMER_REAL,&amp;itv);<br>    printf("pass second is %d\n",(int)itv.it_value.tv_sec);<br>    sleep(1);<br>    }<br>    <br>    return;<br> }</p> 
<h3><a target="_blank" name="_Toc376251262"></a><a target="_blank" name="_Toc369176441"><span style="color:#3A3A3A">Linux</span></a><span style="color:#3A3A3A">下查看文件和文件夹大小的</span><span style="color:#3A3A3A">df</span><span style="color:#3A3A3A">和</span><span style="color:#3A3A3A">du</span><span style="color:#3A3A3A">命令</span></h3> 
<p align="center"><span style="color:#0066FF">来源：</span><span style="color:#0066FF"><a target="_blank" href="http://www.yayu.org/" rel="nofollow noopener noreferrer"><span style="color:black">芽雨快跑</span></a></span>  <span style="color:#0066FF">时间</span><span style="color:#0066FF">: 2009-02-09 18:07:41  </span><span style="color:#0066FF">浏览</span><span style="color:#0066FF">: 102518 </span><span style="color:#0066FF">次</span><span style="color:#0066FF">  </span><span style="color:#0066FF">评论</span><span style="color:#0066FF">: 1853 </span><span style="color:#0066FF">篇</span></p> 
<p align="right"><span style="color:#0066FF">Tags : </span><a target="_blank" href="http://www.yayu.org/tags.php?name=df" rel="nofollow noopener noreferrer"><span style="color:black">df</span></a> <a target="_blank" href="http://www.yayu.org/tags.php?name=du" rel="nofollow noopener noreferrer"><span style="color:black">du</span></a> <a target="_blank" href="http://www.yayu.org/tags.php?name=%CE%C4%BC%FE%B4%F3%D0%A1" rel="nofollow noopener noreferrer"><span style="color:black">文件大小</span></a>  </p> 
<p>   当磁盘大小超过标准时会有报警提示，这时如果掌握df和du命令是非常明智的选择。</p> 
<p>   df可以查看一级文件夹大小、使用比例、档案系统及其挂入点，但对文件却无能为力。<br>     du可以查看文件及文件夹的大小。</p> 
<p>   两者配合使用，非常有效。比如用df查看哪个一级目录过大，然后用df查看文件夹或文件的大小，如此便可迅速确定症结。</p> 
<p>   下面分别简要介绍</p> 
<p>    <strong>df命令可以显示目前所有文件系统的可用空间及使用情形</strong>，请看下列这个例子：</p> 
<div align="center"> 
 <table border="0" cellspacing="0" cellpadding="0" width="95%"><tbody><tr><td style="background:#FDFDDF"> <p><strong><span style="color:#990000">以下是代码片段：</span></strong></p> <p>[yayug@yayu ~]$ df -h<br> Filesystem            Size  Used Avail Use% Mounted on<br> /dev/sda1             3.9G  300M  3.4G   8% /<br> /dev/sda7             100G  188M   95G   1% /data0<br> /dev/sdb1             133G   80G   47G  64% /data1<br> /dev/sda6             7.8G  218M  7.2G   3% /var<br> /dev/sda5             7.8G  166M  7.2G   3% /tmp<br> /dev/sda3             9.7G  2.5G  6.8G  27% /usr<br> tmpfs                 2.0G     0  2.0G   0% /dev/shm</p> </td></tr></tbody></table> 
</div> 
<p>   参数 -h 表示使用「Human-readable」的输出，也就是在档案系统大小使用 GB、MB 等易读的格式。</p> 
<p>   上面的命令输出的第一个字段（Filesystem）及最后一个字段（Mounted on）分别是档案系统及其挂入点。我们可以看到 /dev/sda1 这个分割区被挂在根目录下。</p> 
<p>   接下来的四个字段 Size、Used、Avail、及 Use% 分别是该分割区的容量、已使用的大小、剩下的大小、及使用的百分比。 FreeBSD下，当硬盘容量已满时，您可能会看到已使用的百分比超过 100%，因为 FreeBSD 会留一些空间给 root，让 root 在档案系统满时，还是可以写东西到该档案系统中，以进行管理。</p> 
<p>   <strong> du：查询文件或文件夹的磁盘使用空间</strong></p> 
<p>   如果当前目录下文件和文件夹很多，使用不带参数du的命令，可以循环列出所有文件和文件夹所使用的空间。这对查看究竟是那个地方过大是不利的，所以得指定深入目录的层数，参数：--max-depth=，这是个极为有用的参数！如下，注意使用“*”，可以得到文件的使用空间大小.</p> 
<p>    <strong>提醒</strong>：一向命令比linux复杂的FreeBSD，它的du命令指定深入目录的层数却是比linux简化，为 -d。</p> 
<div align="center"> 
 <table border="0" cellspacing="0" cellpadding="0" width="95%"><tbody><tr><td style="background:#FDFDDF"> <p><strong><span style="color:#990000">以下是代码片段：</span></strong></p> <p>[root@bsso yayu]# du -h --max-depth=1 work/testing<br> 27M     work/testing/logs<br> 35M     work/testing</p> <p>[root@bsso yayu]# du -h --max-depth=1 work/testing/*<br> 8.0K    work/testing/func.php<br> 27M     work/testing/logs<br> 8.1M    work/testing/nohup.out<br> 8.0K    work/testing/testing_c.php<br> 12K     work/testing/testing_func_reg.php<br> 8.0K    work/testing/testing_get.php<br> 8.0K    work/testing/testing_g.php<br> 8.0K    work/testing/var.php</p> <p>[root@bsso yayu]# du -h --max-depth=1 work/testing/logs/<br> 27M     work/testing/logs/</p> <p>[root@bsso yayu]# du -h --max-depth=1 work/testing/logs/*<br> 24K     work/testing/logs/errdate.log_show.log<br> 8.0K    work/testing/logs/pertime_show.log<br> 27M     work/testing/logs/show.log</p> </td></tr></tbody></table> 
</div> 
<p>   值得注意的是，看见一个针对du和df命令异同的文章：《<a target="_blank" href="http://www.diybl.com/course/6_system/linux/Linuxjs/2008716/133217.html" rel="nofollow noopener noreferrer"><span style="color:black">du df </span><span style="color:black">差异导致文件系统误报解决</span></a>》。</p> 
<p>   du 统计文件大小相加 <br>     df  统计数据块使用情况</p> 
<p>   如果有一个进程在打开一个大文件的时候,这个大文件直接被rm 或者mv掉，则du会更新统计数值，df不会更新统计数值,还是认为空间没有释放。直到这个打开大文件的进程被Kill掉。</p> 
<p>   如此一来在定期删除/var/spool/clientmqueue下面的文件时，如果没有杀掉其进程，那么空间一直没有释放。</p> 
<p>   使用下面的命令杀掉进程之后，系统恢复。<br>     fuser -u /var/spool/clientmqueue</p> 
<p><span style="color:rgb(0,153,2)">du</span><span style="color:rgb(0,153,2)">查看目录大小，</span><span style="color:rgb(0,153,2)">df</span><span style="color:rgb(0,153,2)">查看磁盘使用情况。</span><span style="color:#009902"><br> </span><span style="color:rgb(0,153,2)">我常使用的命令（必要时，</span><span style="color:rgb(0,153,2)">sudo</span><span style="color:rgb(0,153,2)">使用</span><span style="color:rgb(0,153,2)">root</span><span style="color:rgb(0,153,2)">权限），</span><span style="color:#009902"><br> 1.</span><span style="color:rgb(0,153,2)">查看某个目录的大小：</span><span style="color:rgb(0,153,2)">du -hs /home/master/documents</span><span style="color:#009902"><br>   </span><span style="color:rgb(0,153,2)">查看目录下所有目录的大小并按大小降序排列：</span><span style="color:rgb(0,153,2)">sudo du -sm /etc/* | sort -nr | less</span><span style="color:#009902"><br> 2.</span><span style="color:rgb(0,153,2)">查看磁盘使用情况（文件系统的使用情况）：</span><span style="color:rgb(0,153,2)">sudo df -h</span><span style="color:#009902"><br>   df --block-size=GB</span><br> <br> -h<span style="color:rgb(0,153,2)">是使输出结果更易于人类阅读；</span><span style="color:rgb(0,153,2)">du -s</span><span style="color:rgb(0,153,2)">只展示目录的使用总量（不分别展示各个子目录情况），</span><span style="color:rgb(0,153,2)">-m</span><span style="color:rgb(0,153,2)">是以</span><span style="color:rgb(0,153,2)">MB</span><span style="color:rgb(0,153,2)">为单位展示目录的大小（当然</span><span style="color:rgb(0,153,2)">-k/-g</span><span style="color:rgb(0,153,2)">就是</span><span style="color:rgb(0,153,2)">KB/GB</span><span style="color:rgb(0,153,2)">了）。</span><span style="color:#009902"><br> </span><span style="color:rgb(0,153,2)">更多信息，还是</span><span style="color:rgb(0,153,2)">man du </span><span style="color:rgb(0,153,2)">和</span><span style="color:rgb(0,153,2)"> man df </span><span style="color:rgb(0,153,2)">来获得吧。</span></p> 
<h3><span style="color:#3A3A3A"><a target="_blank" href="http://www.blogjava.net/lifw/archive/2008/08/27/225073.html" rel="nofollow noopener noreferrer"><span style="color:#3A3A3A">linux </span><span style="color:#3A3A3A">查看文件属性命令</span></a></span><a target="_blank" name="_Toc369176442"></a><a target="_blank" name="_Toc376251263"></a></h3> 
<p>1,ls<br>     ls -a 查看所有文件<br>     ls -l 查看详细的属性<br>   <br> 2,lsattr<br>     查看文件的扩展属性,<br>     如果文件被　chattr +i   添加了写保护,<br>     用lsattr可以看到添加的属性<br> <br> 3,file<br> 查看文件的类型<br> <br> 4,stat<br>     查看文件的状态</p> 
<h3><a target="_blank" name="_Toc376251264"></a><a target="_blank" name="_Toc369176443"><span style="color:#3A3A3A">pthread_attr_init</span></a><span style="color:#3A3A3A">线程属性</span></h3> 
<p align="right"><span style="color:#999999">分类：</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/pbymw8iwm/article/category/863753" rel="noopener noreferrer"><span style="color:#CA0000">linux</span></a></span><span style="color:#999999">2011-08-2610:41</span><span style="color:#999999"> </span><span style="color:#999999">4390</span><span style="color:#999999">人阅读</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/pbymw8iwm/article/details/6721038#comments" rel="noopener noreferrer"><span style="color:#CA0000">评论</span></a></span>(8)<span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" title="收藏"><span style="color:#CA0000">收藏</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/pbymw8iwm/article/details/6721038#report" title="举报" rel="noopener noreferrer"><span style="color:#CA0000">举报</span></a></span></p> 
<p align="left"><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=thread" rel="noopener noreferrer"><span style="color:#CA0000; background:#EEEEEE">thread</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=pthreads" rel="noopener noreferrer"><span style="color:#CA0000; background:#EEEEEE">pthreads</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=struct" rel="noopener noreferrer"><span style="color:#CA0000; background:#EEEEEE">struct</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=null" rel="noopener noreferrer"><span style="color:#CA0000; background:#EEEEEE">null</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=join" rel="noopener noreferrer"><span style="color:#CA0000; background:#EEEEEE">join</span></a></p> 
<p align="right" style="background:#EEEEEE">目录<a target="_blank" href="http://blog.csdn.net/pbymw8iwm/article/details/6721038" title="系统根据文章中H1到H6标签自动生成文章目录" rel="noopener noreferrer"><span style="color:#CA0000">(?)</span></a><a target="_blank" href="http://blog.csdn.net/pbymw8iwm/article/details/6721038" title="展开" rel="noopener noreferrer"><span style="color:#CA0000">[+]</span></a></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<h4><a target="_blank" name="_Toc376251265"></a><a target="_blank" name="_Toc369176444">1</a>．线程属性</h4> 
<p>       线程具有属性，用pthread_attr_t表示，在对该结构进行处理之前必须进行初始化，在使用后需要对其去除初始化。我们用pthread_attr_init函数对其初始化，用pthread_attr_destroy对其去除初始化。</p> 
<p> </p> 
<p>1．</p> 
<table border="0" cellspacing="0" cellpadding="0" align="left"><tbody><tr><td> <p>名称:：</p> </td><td> <p>pthread_attr_init/pthread_attr_destroy</p> </td></tr><tr><td> <p>功能：</p> </td><td> <p>对线程属性初始化/去除初始化</p> </td></tr><tr><td> <p>头文件：</p> </td><td> <p>#include&lt;pthread.h&gt;</p> </td></tr><tr><td> <p>函数原形：</p> </td><td> <p>int pthread_attr_init(pthread_attr_t*attr);</p> <p>int pthread_attr_destroy(pthread_attr_t*attr);</p> </td></tr><tr><td> <p>参数：</p> </td><td> <p>Attr   线程属性变量</p> </td></tr><tr><td> <p>返回值：</p> </td><td> <p>若成功返回0，若失败返回-1。</p> </td></tr></tbody></table> 
<p>      </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> 调用pthread_attr_init之后，pthread_t结构所包含的内容就是操作系统实现支持的线程所有属性的默认值。</p> 
<p>       如果要去除对pthread_attr_t结构的初始化，可以调用pthread_attr_destroy函数。如果pthread_attr_init实现时为属性对象分配了动态内存空间，pthread_attr_destroy还会用无效的值初始化属性对象，因此如果经pthread_attr_destroy去除初始化之后的pthread_attr_t结构被pthread_create函数调用，将会导致其返回错误。</p> 
<p> </p> 
<p>线程属性结构如下：</p> 
<p>typedefstruct</p> 
<p>{<!-- --></p> 
<p>       int                               detachstate;   线程的分离状态</p> 
<p>       int                               schedpolicy;  线程调度策略</p> 
<p>       structsched_param              schedparam;  线程的调度参数</p> 
<p>       int                               inheritsched;  线程的继承性</p> 
<p>       int                                scope;       线程的作用域</p> 
<p>       size_t                           guardsize;   线程栈末尾的警戒缓冲区大小</p> 
<p>       int                                stackaddr_set;</p> 
<p>       void*                          stackaddr;   线程栈的位置</p> 
<p>       size_t                           stacksize;    线程栈的大小</p> 
<p>}pthread_attr_t;</p> 
<p> </p> 
<p>每个个属性都对应一些函数对其查看或修改。下面我们分别介绍。</p> 
<p> </p> 
<h4><a target="_blank" name="_Toc376251266"></a><a target="_blank" name="_Toc369176445">2</a>、线程的分离状态</h4> 
<p><strong>       </strong>线程的分离状态决定一个线程以什么样的方式来终止自己。在默认情况下线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</p> 
<p>而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。程序员应该根据自己的需要，选择适当的分离状态。所以如果我们在创建线程时就知道不需要了解线程的终止状态，则可以pthread_attr_t结构中的detachstate线程属性，让线程以分离状态启动。</p> 
<p><strong> </strong></p> 
<p>2．</p> 
<table border="0" cellspacing="0" cellpadding="0" align="left"><tbody><tr><td> <p>名称:：</p> </td><td> <p>pthread_attr_getdetachstate/pthread_attr_setdetachstate</p> </td></tr><tr><td> <p>功能：</p> </td><td> <p>获取/修改线程的分离状态属性</p> </td></tr><tr><td> <p>头文件：</p> </td><td> <p>#include&lt;pthread.h&gt;</p> </td></tr><tr><td> <p>函数原形：</p> </td><td> <p>int pthread_attr_getdetachstate(const pthread_attr_t *attr,int *detachstate);</p> <p>int pthread_attr_setdetachstate(pthread_attr_t *attr,intdetachstate);</p> </td></tr><tr><td> <p>参数：</p> </td><td> <p>Attr   线程属性变量</p> <p>Detachstate  线程的分离状态属性</p> </td></tr><tr><td> <p>返回值：</p> </td><td> <p>若成功返回0，若失败返回-1。</p> </td></tr></tbody></table> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>可以使用pthread_attr_setdetachstate函数把线程属性detachstate设置为下面的两个合法值之一：设置为PTHREAD_CREATE_DETACHED,以分离状态启动线程；或者设置为PTHREAD_CREATE_JOINABLE,正常启动线程。可以使用pthread_attr_getdetachstate函数获取当前的datachstate线程属性。</p> 
<p> </p> 
<p>以分离状态创建线程</p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p>#iinclude&lt;pthread.h&gt;</p> <p> </p> <p>void *child_thread(void *arg)</p> <p>{<!-- --></p> <p>printf(“child thread run!\n”);</p> <p>}</p> <p> </p> <p>int main(int argc,char *argv[ ])</p> <p>{<!-- --></p> <p>      pthread_ttid;</p> <p>      pthread_attr_tattr;</p> <p> </p> <p>      pthread_attr_init(&amp;attr);</p> <p>      pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</p> <p>      pthread_create(&amp;tid,&amp;attr,fn,arg);</p> <p>      pthread_attr_destroy(&amp;attr);</p> <p>      sleep(1);</p> <p>}</p> </td></tr></tbody></table> 
<p><strong> </strong></p> 
<h4><a target="_blank" name="_Toc376251267"></a><a target="_blank" name="_Toc369176446"><strong>3</strong></a><strong>、线程的继承性</strong></h4> 
<p><strong>       </strong>函数pthread_attr_setinheritsched和pthread_attr_getinheritsched分别用来设置和得到线程的继承性，这两个函数的定义如下：</p> 
<p> </p> 
<p>3.</p> 
<table border="0" cellspacing="0" cellpadding="0" align="left"><tbody><tr><td> <p>名称:：</p> </td><td> <p>pthread_attr_getinheritsched</p> <p>pthread_attr_setinheritsched</p> </td></tr><tr><td> <p>功能：</p> </td><td> <p>获得/设置线程的继承性</p> </td></tr><tr><td> <p>头文件：</p> </td><td> <p>#include&lt;pthread.h&gt;</p> </td></tr><tr><td> <p>函数原形：</p> </td><td> <p>int pthread_attr_getinheritsched(const pthread_attr_t*attr,int *inheritsched);</p> <p>int pthread_attr_setinheritsched(pthread_attr_t *attr,intinheritsched);</p> </td></tr><tr><td> <p>参数：</p> </td><td> <p>attr            线程属性变量</p> <p>inheritsched     线程的继承性</p> </td></tr><tr><td> <p>返回值：</p> </td><td> <p>若成功返回0，若失败返回-1。</p> </td></tr></tbody></table> 
<p>      </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> 这两个函数具有两个参数，第1个是指向属性对象的指针，第2个是继承性或指向继承性的指针。继承性决定调度的参数是从创建的进程中继承还是使用在schedpolicy和schedparam属性中显式设置的调度信息。Pthreads不为inheritsched指定默认值，因此如果你关心线程的调度策略和参数，必须先设置该属性。</p> 
<p>       继承性的可能值是PTHREAD_INHERIT_SCHED（表示新现成将继承创建线程的调度策略和参数）和PTHREAD_EXPLICIT_SCHED（表示使用在schedpolicy和schedparam属性中显式设置的调度策略和参数）。</p> 
<p>       如果你需要显式的设置一个线程的调度策略或参数，那么你必须在设置之前将inheritsched属性设置为PTHREAD_EXPLICIT_SCHED.</p> 
<p>       下面我来讲进程的调度策略和调度参数。我会结合下面的函数给出本函数的程序例子。</p> 
<p> </p> 
<p> </p> 
<h4><a target="_blank" name="_Toc376251268"></a><a target="_blank" name="_Toc369176447"><strong>4</strong></a><strong>、线程的调度策略</strong></h4> 
<p>       函数pthread_attr_setschedpolicy和pthread_attr_getschedpolicy分别用来设置和得到线程的调度策略。</p> 
<p> </p> 
<p>4.</p> 
<table border="0" cellspacing="0" cellpadding="0" align="left"><tbody><tr><td> <p>名称:：</p> </td><td> <p>pthread_attr_getschedpolicy</p> <p>pthread_attr_setschedpolicy</p> </td></tr><tr><td> <p>功能：</p> </td><td> <p>获得/设置线程的调度策略</p> </td></tr><tr><td> <p>头文件：</p> </td><td> <p>#include&lt;pthread.h&gt;</p> </td></tr><tr><td> <p>函数原形：</p> </td><td> <p>int pthread_attr_getschedpolicy(const pthread_attr_t*attr,int *policy);</p> <p>int pthread_attr_setschedpolicy(pthread_attr_t *attr,intpolicy);</p> </td></tr><tr><td> <p>参数：</p> </td><td> <p>attr           线程属性变量</p> <p>policy         调度策略</p> </td></tr><tr><td> <p>返回值：</p> </td><td> <p>若成功返回0，若失败返回-1。</p> </td></tr></tbody></table> 
<p>      </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> 这两个函数具有两个参数，第1个参数是指向属性对象的指针，第2个参数是调度策略或指向调度策略的指针。调度策略可能的值是先进先出（SCHED_FIFO）、轮转法（SCHED_RR）,或其它（SCHED_OTHER）。</p> 
<p>       SCHED_FIFO策略允许一个线程运行直到有更高优先级的线程准备好，或者直到它自愿阻塞自己。在SCHED_FIFO调度策略下，当有一个线程准备好时，除非有平等或更高优先级的线程已经在运行，否则它会很快开始执行。</p> 
<p>    SCHED_RR(轮循)策略是基本相同的，不同之处在于：如果有一个SCHED_RR</p> 
<p>策略的线程执行了超过一个固定的时期(时间片间隔)没有阻塞，而另外的SCHED_RR或SCHBD_FIPO策略的相同优先级的线程准备好时，运行的线程将被抢占以便准备好的线程可以执行。</p> 
<p>    当有SCHED_FIFO或SCHED_RR策赂的线程在一个条件变量上等持或等持加锁同一个互斥量时，它们将以优先级顺序被唤醒。即，如果一个低优先级的SCHED_FIFO线程和一个高优先织的SCHED_FIFO线程都在等待锁相同的互斥且，则当互斥量被解锁时，高优先级线程将总是被首先解除阻塞。</p> 
<p> </p> 
<h4><a target="_blank" name="_Toc376251269"></a><a target="_blank" name="_Toc369176448"><strong>5</strong></a><strong>、线程的调度参数</strong></h4> 
<p>       函数pthread_attr_getschedparam 和pthread_attr_setschedparam分别用来设置和得到线程的调度参数。</p> 
<p> </p> 
<p>5.</p> 
<table border="0" cellspacing="0" cellpadding="0" align="left"><tbody><tr><td> <p>名称:：</p> </td><td> <p>pthread_attr_getschedparam</p> <p>pthread_attr_setschedparam</p> </td></tr><tr><td> <p>功能：</p> </td><td> <p>获得/设置线程的调度参数</p> </td></tr><tr><td> <p>头文件：</p> </td><td> <p>#include&lt;pthread.h&gt;</p> </td></tr><tr><td> <p>函数原形：</p> </td><td> <p>int pthread_attr_getschedparam(const pthread_attr_t*attr,struct sched_param *param);</p> <p>int pthread_attr_setschedparam(pthread_attr_t *attr,conststruct sched_param *param);</p> </td></tr><tr><td> <p>参数：</p> </td><td> <p>attr           线程属性变量</p> <p>param          sched_param结构</p> </td></tr><tr><td> <p>返回值：</p> </td><td> <p>若成功返回0，若失败返回-1。</p> </td></tr></tbody></table> 
<p>      </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>这两个函数具有两个参数，第1个参数是指向属性对象的指针，第2个参数是sched_param结构或指向该结构的指针。结构sched_param在文件/usr/include/bits/sched.h中定义如下：</p> 
<p>      </p> 
<p>struct sched_param</p> 
<p>{<!-- --></p> 
<p>       intsched_priority;</p> 
<p>};</p> 
<p> </p> 
<p>结构sched_param的子成员sched_priority控制一个优先权值，大的优先权值对应高的优先权。系统支持的最大和最小优先权值可以用sched_get_priority_max函数和sched_get_priority_min函数分别得到。</p> 
<p> </p> 
<p>注意：如果不是编写实时程序，不建议修改线程的优先级。因为，调度策略是一件非常复杂的事情，如果不正确使用会导致程序错误，从而导致死锁等问题。如：在多线程应用程序中为线程设置不同的优先级别，有可能因为共享资源而导致优先级倒置。</p> 
<p> </p> 
<p> </p> 
<h3><a target="_blank" name="_Toc376251270"></a><a target="_blank" name="_Toc369176449">vsnprintf</a></h3> 
<p><span style="color:#333333">_vsnprintf</span><span style="color:#333333">，</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/2315895.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">C</span><span style="color:#136EC2">语言库函数</span></a></span><span style="color:#333333">之一，属于可变参数。用于向字符串中打印数据、数据格式用户自定义。</span></p> 
<h4><a target="_blank" name="_Toc376251271"></a><a target="_blank" name="_Toc369176450">目 </a>录</h4> 
<p><span style="color:#B2B2B2">1</span><a target="_blank" href="http://baike.baidu.com/view/3838242.htm#1" rel="nofollow noopener noreferrer"><span style="color:rgb(51,51,51)">函数简介</span></a></p> 
<p><span style="color:#B2B2B2">2</span><a target="_blank" href="http://baike.baidu.com/view/3838242.htm#2" rel="nofollow noopener noreferrer"><span style="color:rgb(51,51,51)">用法实例</span></a></p> 
<h4><a target="_blank" name="_Toc376251272"></a><a target="_blank" name="_Toc369176451">1</a><a target="_blank" name="sub3838242_1"></a>函数简介<a target="_blank" href="http://baike.baidu.com/view/3838242.htm" rel="nofollow noopener noreferrer" title="编辑本段"></a></h4> 
<p><span style="color:#333333">头文件</span><span style="color:#333333">:</span></p> 
<p><span style="color:#333333">#include &lt;stdarg.h&gt;</span></p> 
<p><span style="color:#333333">函数声明</span><span style="color:#333333">:</span></p> 
<pre style="background:white">int vsnprintf(char *str, size_t size,  const  char  *format,  va_list ap);</pre> 
<p><span style="color:#333333">参数说明</span><span style="color:#333333">:</span></p> 
<p align="left"><span style="color:#333333">1. </span><span style="color:#333333">char *str [out],</span><span style="color:#333333">把生成的格式化的字符串存放在这里</span><span style="color:#333333">.</span></p> 
<p align="left"><span style="color:#333333">2. </span><span style="color:#333333">size_t size [in], buffer</span><span style="color:#333333">可接受的最大字节数</span><span style="color:#333333">,</span><span style="color:#333333">防止产生</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/209670.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">数组</span></a></span><span style="color:#333333">越界</span><span style="color:#333333">.</span></p> 
<p align="left"><span style="color:#333333">3. </span><span style="color:#333333">const char *format [in], </span><span style="color:#333333">指定输出格式的字符串，它决定了你需要提供的可变参数的类型、个数和顺序。</span></p> 
<p align="left"><span style="color:#333333">4. </span><span style="color:#333333">va_list  ap [in],va_list<a target="_blank" href="http://baike.baidu.com/view/296689.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">变量</span></a></span>.va:variable-argument:<span style="color:#333333">可变参数</span></p> 
<p><span style="color:#333333">函数功能：将可变参数格式化输出到一个字符数组。</span></p> 
<p><span style="color:#333333">用法类似于</span><span style="color:#333333">vsprintf</span><span style="color:#333333">，不过加了</span><span style="color:#333333">size</span><span style="color:#333333">的限制，防止了内存溢出（</span><span style="color:#333333">size</span><span style="color:#333333">为</span><span style="color:#333333">str</span><span style="color:#333333">所指的存储空间的大小）。</span></p> 
<p><span style="color:#333333">返回值：执行成功，返回写入到字符数组</span><span style="color:#333333">str</span><span style="color:#333333">中的字符个数（不包含终止符），最大不超过</span><span style="color:#333333">size</span><span style="color:#333333">；执行失败，返回负值，并置</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/3485007.htm" rel="nofollow noopener noreferrer"><em><span style="color:#136EC2">errno</span></em></a>.</span><sup><span style="color:#3366CC">[1]</span></sup><a target="_blank" name="ref_%5B1%5D_3838242"></a></p> 
<p><span style="color:#333333">备注</span><span style="color:#333333">:</span></p> 
<p><span style="color:#333333">linux</span><span style="color:#333333">环境下是</span><span style="color:#333333">:vsnprintf</span></p> 
<p><span style="color:#333333">VC6</span><span style="color:#333333">环境下是</span><span style="color:#333333">:_vsnprintf</span></p> 
<h4><a target="_blank" name="_Toc376251273"></a><a target="_blank" name="_Toc369176452">2</a><a target="_blank" name="sub3838242_2"></a>用法实例<a target="_blank" href="http://baike.baidu.com/view/3838242.htm" rel="nofollow noopener noreferrer" title="编辑本段"></a></h4> 
<p><span style="color:#333333">int mon_log(char* format, ...)</span></p> 
<p><span style="color:#333333">{<!-- --></span></p> 
<p><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/1213054.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">va_list</span></a>vArgList; //</span><span style="color:#333333">定义一个</span><span style="color:#333333">va_list</span><span style="color:#333333">型的</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/296689.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">变量</span></a></span>,<span style="color:#333333">这个变量是指向参数的</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">指针</span></a></span>.</p> 
<p><span style="color:#333333">va_start(vArgList, format); //</span><span style="color:#333333">用</span><span style="color:#333333">va_start</span><strong><span style="color:#333333">宏</span></strong><span style="color:#333333">初始化</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/296689.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">变量</span></a></span>,<span style="color:#333333">这个宏的第二个参数是第一个可变参数的前一个参数</span><span style="color:#333333">,</span><span style="color:#333333">是一个固定的参数</span><span style="color:#333333">.</span></p> 
<p><strong><span style="color:#333333">_vsnprintf</span></strong><span style="color:#333333">(str_tmp, 3, format, vArgList);//</span><span style="color:#333333">注意</span><span style="color:#333333">,</span><span style="color:#333333">不要漏掉前面的</span><span style="color:#333333">_</span></p> 
<p><span style="color:#333333">va_end(vArgList); //</span><span style="color:#333333">用</span><span style="color:#333333">va_end</span><strong><span style="color:#333333">宏</span></strong><span style="color:#333333">结束可变参数的获取</span></p> 
<p><span style="color:#333333">return 0;</span></p> 
<p><span style="color:#333333">}</span></p> 
<p><span style="color:#333333">//</span><span style="color:#333333">调用上面的函数</span></p> 
<p><span style="color:#333333">mon_log("%d,%d,%d,%d", 1,2,3,4);</span></p> 
<p><span style="color:#333333">返回值用法：</span></p> 
<p><span style="color:#333333">#include &lt;stdio.h&gt;</span></p> 
<p><span style="color:#333333">#include &lt;stdlib.h&gt;</span></p> 
<p><span style="color:#333333">#include &lt;stdarg.h&gt;</span></p> 
<p><span style="color:#333333">char *</span></p> 
<p><span style="color:#333333">make_message(const char *fmt, ...) {<!-- --></span></p> 
<p><span style="color:#333333">/* </span><span style="color:#333333">初始时假设我们只需要不超过</span><span style="color:#333333">100</span><span style="color:#333333">字节大小的空间</span><span style="color:#333333"> */</span></p> 
<p><span style="color:#333333">int n, size = 100;</span></p> 
<p><span style="color:#333333">char *p;</span></p> 
<p><span style="color:#333333">va_list ap;</span></p> 
<p><span style="color:#333333">if ((p = (char *)malloc(size)) == NULL)</span></p> 
<p><span style="color:#333333">return NULL;</span></p> 
<p><span style="color:#333333">while (1) {<!-- --></span></p> 
<p><span style="color:#333333">/* </span><span style="color:#333333">尝试在申请的空间中进行打印操作</span><span style="color:#333333"> */</span></p> 
<p><span style="color:#333333">va_start(ap, fmt);</span></p> 
<p><span style="color:#333333">n = vsnprintf (p, size, fmt, ap);</span></p> 
<p><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/1529354.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">va_end</span></a>(ap);</span></p> 
<p><span style="color:#333333">/* </span><span style="color:#333333">如果</span><span style="color:#333333">vsnprintf</span><span style="color:#333333">调用成功，返回该字符串</span><span style="color:#333333">*/</span></p> 
<p><span style="color:#333333">if (n &gt; -1 &amp;&amp; n &lt; size)</span></p> 
<p><span style="color:#333333">return p;</span></p> 
<p><span style="color:#333333">/* vsnprintf</span><span style="color:#333333">调用失败</span><span style="color:#333333">(n&lt;0)</span><span style="color:#333333">或者</span><span style="color:#333333">p</span><span style="color:#333333">的空间不足够容纳</span><span style="color:#333333">size</span><span style="color:#333333">大小的字符串</span><span style="color:#333333">(n&gt;=size)</span><span style="color:#333333">，尝试申请更大的空间</span><span style="color:#333333">*/</span></p> 
<p><span style="color:#333333">size *= 2; /* </span><span style="color:#333333">两倍原来大小的空间</span><span style="color:#333333"> */</span></p> 
<p><span style="color:#333333">if ((p = (char *)realloc(p, size)) == NULL)</span></p> 
<p><span style="color:#333333">return NULL;</span></p> 
<p><span style="color:#333333">}</span></p> 
<p><span style="color:#333333">}</span></p> 
<p><span style="color:#333333">int main() {<!-- --></span></p> 
<p><span style="color:#333333">/* </span><span style="color:#333333">调用上面的函数</span><span style="color:#333333"> */</span></p> 
<p><span style="color:#333333">char* str = make_message("%d,%d,%d,%d",5,6,7,8);</span></p> 
<p><span style="color:#333333">printf("%s\n",str);</span></p> 
<p><span style="color:#333333">free(str); // we allocate the memory in the make_messagefunction, so we should release it by caller(main function).</span></p> 
<p><span style="color:#333333">return 0;</span></p> 
<p><span style="color:#333333">}</span></p> 
<h3><a target="_blank" name="_Toc376251274"></a><a target="_blank" name="_Toc369176453">SOCKADDR_IN</a></h3> 
<h4><a target="_blank" name="_Toc376251275"></a><a target="_blank" name="_Toc369176454">目 </a>录</h4> 
<p><span style="color:#B2B2B2">1</span><a target="_blank" href="http://baike.baidu.com/link?url=EraXkKPQ74yyylMcLQ2o5tWCbeHegTgvu7XAa067P915gCWYyXW52sH6FgZ1juYL48gJ00VadPvZUnIjTKD4R_#1" rel="nofollow noopener noreferrer"><span style="color:rgb(51,51,51)">基本结构</span></a></p> 
<p><span style="color:#B2B2B2">2</span><a target="_blank" href="http://baike.baidu.com/link?url=EraXkKPQ74yyylMcLQ2o5tWCbeHegTgvu7XAa067P915gCWYyXW52sH6FgZ1juYL48gJ00VadPvZUnIjTKD4R_#2" rel="nofollow noopener noreferrer"><span style="color:rgb(51,51,51)">参数说明</span></a></p> 
<p><span style="color:#B2B2B2">3</span><a target="_blank" href="http://baike.baidu.com/link?url=EraXkKPQ74yyylMcLQ2o5tWCbeHegTgvu7XAa067P915gCWYyXW52sH6FgZ1juYL48gJ00VadPvZUnIjTKD4R_#3" rel="nofollow noopener noreferrer"><span style="color:rgb(51,51,51)">经典案例</span></a></p> 
<h4><a target="_blank" name="_Toc376251276"></a><a target="_blank" name="_Toc369176455">1</a><a target="_blank" name="sub2355183_1"></a>基本结构<a target="_blank" href="http://baike.baidu.com/link?url=EraXkKPQ74yyylMcLQ2o5tWCbeHegTgvu7XAa067P915gCWYyXW52sH6FgZ1juYL48gJ00VadPvZUnIjTKD4R_" rel="nofollow noopener noreferrer" title="编辑本段"></a></h4> 
<p><span style="color:#333333">在</span><span style="color:#333333">windows/linux</span><span style="color:#333333">下有下面结构：</span></p> 
<p><strong><span style="color:#333333">sockaddr</span><span style="color:#333333">结构</span></strong></p> 
<p><span style="color:#333333">struct sockaddr {<!-- --></span></p> 
<p><span style="color:#333333">unsigned short sa_family; /* address family, AF_xxx */</span></p> 
<p><span style="color:#333333">char sa_data[14]; /* 14 bytes of protocol address */</span></p> 
<p><span style="color:#333333">};</span></p> 
<p><span style="color:#333333">sa_family</span><span style="color:#333333">是地址家族，一般都是</span><span style="color:#333333">“AF_xxx”</span><span style="color:#333333">的形式。通常大多用的是都是</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/3634059.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">AF_INET</span></a>,</span><span style="color:#333333">代表</span><span style="color:#333333">TCP/IP</span><span style="color:#333333">协议族。</span></p> 
<p><span style="color:#333333">sa_data</span><span style="color:#333333">是</span><span style="color:#333333">14</span><span style="color:#333333">字节</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/1252611.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">协议地址</span></a></span><span style="color:#333333">。</span></p> 
<p><span style="color:#333333">此</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/9900.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">数据结构</span></a></span><span style="color:#333333">用做</span><span style="color:#333333">bind</span><span style="color:#333333">、</span><span style="color:#333333">connect</span><span style="color:#333333">、</span><span style="color:#333333">recvfrom</span><span style="color:#333333">、</span><span style="color:#333333">sendto</span><span style="color:#333333">等函数的参数，指明地址信息。但一般编程中并不直接针对此</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/9900.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">数据结构</span></a></span><span style="color:#333333">操作，而是使用另一个与</span><span style="color:#333333">sockaddr</span><span style="color:#333333">等价的数据结构</span></p> 
<p><strong><span style="color:#333333">sockaddr_in</span><span style="color:#333333">（在</span><span style="color:#333333">netinet/in.h</span><span style="color:#333333">中定义）：</span></strong></p> 
<p><span style="color:#333333">struct sockaddr_in {<!-- --></span></p> 
<p><span style="color:#333333">short sin_family; /* Address family */</span></p> 
<p><span style="color:#333333">unsigned short sin_port; /* Port number */</span></p> 
<p><span style="color:#333333">struct</span><span style="color:#333333"> </span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/2907631.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">in_addr</span></a></span><span style="color:#333333"> </span><span style="color:#333333">sin_addr; /* Internetaddress */</span></p> 
<p><span style="color:#333333">unsigned char sin_zero[8]; /* Same size as struct sockaddr */</span></p> 
<p><span style="color:#333333">};</span></p> 
<p><span style="color:#333333">在</span><span style="color:#333333">linux</span><span style="color:#333333">下：</span></p> 
<p><strong><span style="color:#333333">in_addr</span><span style="color:#333333">结构</span></strong></p> 
<p><span style="color:#333333">typedef struct</span><span style="color:#333333"> </span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/2907631.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">in_addr</span></a>{<!-- --></span></p> 
<p><span style="color:#333333">unsigned long s_addr;</span></p> 
<p><span style="color:#333333">};</span></p> 
<p><span style="color:#333333">在</span><span style="color:#333333">windows</span><span style="color:#333333">下：</span></p> 
<p><span style="color:#333333">typedef struct</span><span style="color:#333333"> </span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/2907631.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">in_addr</span></a>{<!-- --></span></p> 
<p><span style="color:#333333">union{<!-- --></span></p> 
<p><span style="color:#333333">struct{unsigned char s_b1,s_b2,s_b3,s_b4;} S_un_b;</span></p> 
<p><span style="color:#333333">struct{unsigned short s_w1,s_w2;} S_un_w;</span></p> 
<p><span style="color:#333333">unsigned long S_addr;</span></p> 
<p><span style="color:#333333">} S_un;</span></p> 
<p><span style="color:#333333">} IN_ADDR;</span></p> 
<h4><a target="_blank" name="_Toc376251277"></a><a target="_blank" name="_Toc369176456"><span style="color:#E9E9E9">2</span></a><a target="_blank" name="sub2355183_2"></a>参数说明<a target="_blank" href="http://baike.baidu.com/link?url=EraXkKPQ74yyylMcLQ2o5tWCbeHegTgvu7XAa067P915gCWYyXW52sH6FgZ1juYL48gJ00VadPvZUnIjTKD4R_" rel="nofollow noopener noreferrer" title="编辑本段"></a></h4> 
<p><span style="color:#333333">sin_family</span><span style="color:#333333">指代协议族，在</span><span style="color:#333333">socket</span><span style="color:#333333">编程中只能是</span><span style="color:#333333">AF_INET</span></p> 
<p><span style="color:#333333">sin_port</span><span style="color:#333333">存储</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/642103.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">端口号</span></a></span><span style="color:#333333">（使用网络</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/567601.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">字节顺序</span></a></span><span style="color:#333333">），在</span><span style="color:#333333">linux</span><span style="color:#333333">下，端口号的范围</span><span style="color:#333333">0~65535,</span><span style="color:#333333">同时</span><span style="color:#333333">0~1024</span><span style="color:#333333">范围的端口号已经被系统使用或保留。</span></p> 
<p><span style="color:#333333">s<a target="_blank" href="http://baike.baidu.com/view/2907631.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">in_addr</span></a></span><span style="color:#333333">存储</span><span style="color:#333333">IP</span><span style="color:#333333">地址，使用</span><span style="color:#333333">in_addr</span><span style="color:#333333">这个</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/9900.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">数据结构</span></a></span></p> 
<p><span style="color:#333333">sin_zero</span><span style="color:#333333">是为了让</span><span style="color:#333333">sockaddr</span><span style="color:#333333">与</span><span style="color:#333333">sockaddr_in</span><span style="color:#333333">两个</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/9900.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">数据结构</span></a></span><span style="color:#333333">保持大小相同而保留的空字节。</span></p> 
<p><span style="color:#333333">s_addr</span><span style="color:#333333">按照网络字节顺序存储</span><span style="color:#333333">IP</span><span style="color:#333333">地址</span></p> 
<p><span style="color:#333333">sockaddr_in</span><span style="color:#333333">和</span><span style="color:#333333">sockaddr</span><span style="color:#333333">是并列的结构，指向</span><span style="color:#333333">sockaddr_in</span><span style="color:#333333">的</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/204974.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">结构体</span></a></span><span style="color:#333333">的</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">指针</span></a></span><span style="color:#333333">也可以指向</span></p> 
<p><span style="color:#333333">sockaddr</span><span style="color:#333333">的</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/204974.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">结构体</span></a></span><span style="color:#333333">，并代替它。也就是说，你可以使用</span><span style="color:#333333">sockaddr_in</span><span style="color:#333333">建立你所需要的信息</span><span style="color:#333333">,</span></p> 
<p><span style="color:#333333">然后用</span><span style="color:#333333">bzero</span><span style="color:#333333">函数初始化就可以了</span><span style="color:#333333">bzero((char*)&amp;mysock,sizeof(mysock));//</span><span style="color:#333333">初始化</span></p> 
<p><span style="color:#333333">sockaddr_in mysock;</span></p> 
<p><span style="color:#333333">bzero((char*)&amp;mysock,sizeof(mysock));</span></p> 
<p><span style="color:#333333">mysock.sa_family=AF_INET;</span></p> 
<p><span style="color:#333333">mysock.sin_port=htons(1234);//1234</span><span style="color:#333333">是</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/642103.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">端口号</span></a></span></p> 
<p> </p> 
<p><span style="color:#333333"> </span></p> 
<p><span style="color:#333333">mysock.s<a target="_blank" href="http://baike.baidu.com/view/2907631.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">in_addr</span></a>.s_addr=inet_addr("192.168.0.1");</span></p> 
<p>相关函数：inet_addr,inet_aton, inet_ntoa, htonl, htons， MAKEWORD，WSASocket, WSAHtons……</p> 
<p><strong><span style="color:#E9E9E9">3</span></strong><a target="_blank" name="sub2355183_3"></a>经典案例<a target="_blank" href="http://baike.baidu.com/link?url=EraXkKPQ74yyylMcLQ2o5tWCbeHegTgvu7XAa067P915gCWYyXW52sH6FgZ1juYL48gJ00VadPvZUnIjTKD4R_" rel="nofollow noopener noreferrer" title="编辑本段"></a></p> 
<p><span style="color:#333333">服务端：</span></p> 
<p><span style="color:#333333">int main()<br> {<!-- --><br> //</span><span style="color:#333333">创建</span><span style="color:#333333">socket<br> int sockfd=socket(PF_LOCAL, SOCK_DGRAM, 0);<br> if(sockfd==-1)<br> perror("</span><span style="color:#333333">创建</span><span style="color:#333333">socket</span><span style="color:#333333">失败</span><span style="color:#333333">"),exit(-1);<br> //</span><span style="color:#333333">准备通信地址</span><span style="color:#333333"><br> struct sockaddr_un addr;<br> addr.sun_family = PF_UNIX;<br> strcpy(addr.sun_path,"a.sock");</span><span style="color:#333333"> </span><span style="color:#333333"><br> //</span><span style="color:#333333">绑定</span><span style="color:#333333"><br> int res = bind(sockfd,</span><span style="color:#333333"> </span><span style="color:#333333"><br> (struct sockaddr*)&amp;addr, sizeof(addr));<br> if(res==-1)perror("</span><span style="color:#333333">绑定失败</span><span style="color:#333333">"),exit(-1);<br> printf("</span><span style="color:#333333">绑定成功</span><span style="color:#333333">\n");<br> //</span><span style="color:#333333">通信</span><span style="color:#333333">(</span><span style="color:#333333">用读写文件方式</span><span style="color:#333333">)<br> char buf[100] = {};<br> read(sockfd, buf, sizeof(buf));</span><span style="color:#333333"> </span><span style="color:#333333"><br> printf("</span><span style="color:#333333">收到信息</span><span style="color:#333333">:%s\n",buf);<br> //</span><span style="color:#333333">关闭</span><span style="color:#333333">socket<br> close(sockfd);</span><span style="color:#333333"> </span><span style="color:#333333"><br> }</span></p> 
<p><span style="color:#333333">客户端：</span></p> 
<p><span style="color:#333333">int main()<br> {<!-- --><br> int sockfd=socket(PF_LOCAL, SOCK_DGRAM, 0);<br> if(sockfd==-1)<br> perror("</span><span style="color:#333333">创建</span><span style="color:#333333">socket</span><span style="color:#333333">失败</span><span style="color:#333333">"),exit(-1);<br> struct sockaddr_un addr;<br> addr.sun_family = PF_UNIX;<br> strcpy(addr.sun_path,"a.sock");</span><span style="color:#333333"> </span><span style="color:#333333"><br> //</span><span style="color:#333333">连接</span><span style="color:#333333"><br> int res = connect(sockfd,</span><span style="color:#333333"> </span><span style="color:#333333"><br> (struct sockaddr*)&amp;addr, sizeof(addr));<br> if(res==-1)perror("</span><span style="color:#333333">失败</span><span style="color:#333333">"),exit(-1);<br> printf("</span><span style="color:#333333">成功</span><span style="color:#333333">\n");<br> write(sockfd, "Hello, Socket!", 14);<br> close(sockfd);</span><span style="color:#333333"> </span><span style="color:#333333"><br> }</span></p> 
<h3><a target="_blank" name="_Toc376251278"></a><a target="_blank" name="_Toc369176457"><span style="color:#454545">AF_INET</span></a><span style="color:#454545">和</span><span style="color:#454545">PF_INET</span><span style="color:#454545">的细微不同</span></h3> 
<p><span style="color:#454545">在写网络程序的时候，建立</span><span style="color:#454545">TCP socket</span><span style="color:#454545">：</span><span style="color:#454545"><br>     sock = socket(PF_INET, SOCK_STREAM, 0);<br> </span><span style="color:#454545">然后在绑定本地地址或连接远程地址时需要初始化</span><span style="color:#454545">sockaddr_in</span><span style="color:#454545">结构，其中指定</span><span style="color:#454545">addressfamily</span><span style="color:#454545">时一般设置为</span><span style="color:#454545">AF_INET</span><span style="color:#454545">，即使用</span><span style="color:#454545">IP</span><span style="color:#454545">。</span></p> 
<p><span style="color:#454545">相关头文件中的定义：</span><span style="color:#454545">AF = Address Family<br>                  PF = Protocol Family<br>                 AF_INET = PF_INET</span></p> 
<p><span style="color:#454545">所以在</span><span style="color:#454545">windows</span><span style="color:#454545">中</span><strong><span style="color:#454545">AF</span></strong><span style="color:#454545">_INET</span><span style="color:#454545">与</span><strong><span style="color:#454545">PF</span></strong><span style="color:#454545">_INET</span><span style="color:#454545">完全一样</span><span style="color:#454545">. </span><span style="color:#454545">而在</span><span style="color:#454545">Unix/Linux</span><span style="color:#454545">系统中，在不同的版本中这两者有微小差别</span><span style="color:#454545">.</span><span style="color:#454545">对于</span><span style="color:#454545">BSD,</span><span style="color:#454545">是</span><strong><span style="color:#454545">AF</span></strong><span style="color:#454545">,</span><span style="color:#454545">对于</span><span style="color:#454545">POSIX</span><span style="color:#454545">是</span><strong><span style="color:#454545">PF.</span></strong></p> 
<p><span style="color:#454545">理论上建立</span><span style="color:#454545">socket</span><span style="color:#454545">时是指定协议，应该用</span><span style="color:#454545">PF_xxxx</span><span style="color:#454545">，设置地址时应该用</span><span style="color:#454545">AF_xxxx</span><span style="color:#454545">。当然</span><span style="color:#454545">AF_INET</span><span style="color:#454545">和</span><span style="color:#454545">PF_INET</span><span style="color:#454545">的值是相同的，混用也不会有太大的问题。</span></p> 
<p><span style="color:#454545">在函数</span><span style="color:#454545">socketpair</span><span style="color:#454545">与</span><span style="color:#454545">socket</span><span style="color:#454545">的</span><span style="color:#454545">domain</span><span style="color:#454545">参数中有</span><span style="color:#454545">AF_UNIX,AF_LOCAL,AF_INET,PF_UNIX,PF_LOCAL,PF_INET.<br> </span><span style="color:#454545">这几个参数有</span><span style="color:#454545">AF_UNIX=AF_LOCAL,PF_UNIX=PF_LOCAL, AF_LOCAL=PF_LOCAL<strong>,AF_INET=PF_INET.<br> </strong>**</span><span style="color:#454545">建议</span><span style="color:#454545">:</span><span style="color:#454545">对于</span><span style="color:#454545">socketpair</span><span style="color:#454545">与</span><span style="color:#454545">socket</span><span style="color:#454545">的</span><span style="color:#454545">domain</span><span style="color:#454545">参数</span><span style="color:#454545">,</span><span style="color:#454545">使用</span><span style="color:#454545">PF_LOCAL</span><span style="color:#454545">系列</span><span style="color:#454545">,<br> </span><span style="color:#454545">而在初始化套接口地址结构时</span><span style="color:#454545">,</span><span style="color:#454545">则使用</span><span style="color:#454545">AF_LOCAL.<br> </span><span style="color:#454545">例如</span><span style="color:#454545">:<br> z = socket(PF_LOCAL, SOCK_STREAM, 0);<br> adr_unix.sin_family = AF_LOCAL;</span></p> 
<h3><a target="_blank" name="_Toc376251279">popen</a></h3> 
<p>计算机科学中的进程I/O函数，与pclose函数一起使用。</p> 
<p>目 录</p> 
<p>1<a target="_blank" href="http://baike.baidu.com/view/2445803.htm#1" rel="nofollow noopener noreferrer"><span style="color:windowtext">头文件</span></a></p> 
<p>2<a target="_blank" href="http://baike.baidu.com/view/2445803.htm#2" rel="nofollow noopener noreferrer"><span style="color:windowtext">函数定义</span></a></p> 
<p>3<a target="_blank" href="http://baike.baidu.com/view/2445803.htm#3" rel="nofollow noopener noreferrer"><span style="color:windowtext">函数说明</span></a></p> 
<p>4<a target="_blank" href="http://baike.baidu.com/view/2445803.htm#4" rel="nofollow noopener noreferrer"><span style="color:windowtext">返回值</span></a></p> 
<p>5<a target="_blank" href="http://baike.baidu.com/view/2445803.htm#5" rel="nofollow noopener noreferrer"><span style="color:windowtext">返回错误</span></a></p> 
<p>6<a target="_blank" href="http://baike.baidu.com/view/2445803.htm#6" rel="nofollow noopener noreferrer"><span style="color:windowtext">使用举例</span></a></p> 
<p>7<a target="_blank" href="http://baike.baidu.com/view/2445803.htm#7" rel="nofollow noopener noreferrer"><span style="color:windowtext">真实示例</span></a></p> 
<p><span style="color:#E9E9E9">1</span><a target="_blank" name="sub2445803_1"></a>头文件</p> 
<table border="0" cellspacing="0" cellpadding="0" width="659"><tbody><tr><td> <p>1</p> </td><td> <p><code>#include &lt;stdio.h&gt;</code></p> </td></tr></tbody></table> 
<p><span style="color:#E9E9E9">2</span><a target="_blank" name="sub2445803_2"></a>函数定义</p> 
<table border="0" cellspacing="0" cellpadding="0" width="659"><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p><code>FILE</code> <code>* popen ( const</code> <code>char</code> <code>* command , const</code> <code>char</code> <code>* type );</code></p> <p><code>int</code> <code>pclose ( FILE</code> <code>* stream );</code></p> </td></tr></tbody></table> 
<p><span style="color:#E9E9E9">3</span><a target="_blank" name="sub2445803_3"></a>函数说明</p> 
<p>popen() 函数通过创建一个管道，调用 fork 产生一个子进程，执行一个shell 以<a target="_blank" href="http://baike.baidu.com/view/70069.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">运行命令</span></a>来开启一个进程。这个进程必须由 pclose() 函数关闭，而不是 fclose() 函数。pclose() 函数关闭标准 I/O 流，等待命令执行结束，然后返回 shell 的终止状态。如果 shell 不能被执行，则 pclose() 返回的终止状态与 shell 已执行 exit 一样。</p> 
<p>type<span style="color:#333333"> </span>参数只能是读或者写中的一种，得到的返回值（标准 I/O 流）也具有和 type 相应的只读或只写类型。如果 type 是 "r" 则文件指针连接到 command 的标准输出；如果 type 是 "w" 则文件指针连接到 command 的标准输入。</p> 
<p>command<span style="color:#333333"> </span>参数是一个指向以 NULL 结束的 shell 命令字符串的<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">指针</span></a>。这行命令将被传到 bin/sh 并使用-c 标志，shell 将执行这个命令。</p> 
<p>popen<span style="color:#333333"> </span>的返回值是个标准 I/O 流，必须由<span style="color:#333333"> </span>pclose<span style="color:#333333"> </span>来终止。前面提到这个流是单向的。所以向这个流写内容相当于写入该命令的标准输入；命令的标准输出和调用<span style="color:#333333"> </span>popen<span style="color:#333333"> </span>的进程相同。与之相反的，从流中读数据相当于读取命令的标准输出；命令的标准输入和调用<span style="color:#333333"> </span>popen<span style="color:#333333"> </span>的进程相同。</p> 
<p><span style="color:#E9E9E9">4</span><a target="_blank" name="sub2445803_4"></a><span style="color:#333333">返回值</span></p> 
<p>如果调用 fork() 或 pipe() 失败，或者不能分配内存将返回NULL，否则返回标准 I/O 流。</p> 
<p><span style="color:#E9E9E9">5</span><a target="_blank" name="sub2445803_5"></a><span style="color:#333333">返回错误</span></p> 
<p>popen<span style="color:#333333"> </span>没有为<a target="_blank" href="http://baike.baidu.com/view/549628.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">内存分配</span></a>失败设置 errno 值。</p> 
<p>如果调用 fork() 或 pipe() 时出现错误，errno 被设为相应的错误类型。</p> 
<p>如果 type 参数不合法，errno将返回EINVAL。</p> 
<p><span style="color:#E9E9E9">6</span><a target="_blank" name="6"></a><a target="_blank" name="sub2445803_6"></a><span style="color:#333333">使用举例</span></p> 
<table border="0" cellspacing="0" cellpadding="0" width="659"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> </td><td> <p><code>if((fp=popen("/usr/bin/uptime","r"))==NULL);</code></p> <p><code>{<!-- --></code></p> <p><code>    sprintf(buf,"error: %s\n", strerror(errno));</code></p> <p><code>    ....//</code><code>异常处理</code></p> <p><code>}</code></p> <p><code>else</code></p> <p><code>{<!-- --></code></p> <p><code>    ....</code></p> <p><code>    pclose(fp);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>7<a target="_blank" name="7"></a><a target="_blank" name="sub2445803_7"></a>真实示例</p> 
<table border="0" cellspacing="0" cellpadding="0" width="659"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> </td><td> <p><code>#define _LINE_LENGTH 300</code></p> <p><code>int</code> <code>get_path_total(const</code> <code>char</code> <code>*path, long</code> <code>long* total) {<!-- --></code></p> <p><code>    int</code> <code>err=-1;</code></p> <p><code>    FILE</code> <code>*file;</code></p> <p><code>    char</code> <code>line[_LINE_LENGTH];</code></p> <p><code>    char</code> <code>*p;</code></p> <p><code>    char</code> <code>tmp[100];</code></p> <p><code>    char</code> <code>*token;</code></p> <p><code>    sprintf(tmp, "df %s", path);</code></p> <p><code>    file = popen(tmp, "r");</code></p> <p><code>    if</code> <code>(file != NULL) {<!-- --></code></p> <p><code>        if</code> <code>(fgets(line, _LINE_LENGTH, file) != NULL) {<!-- --></code></p> <p><code>            if</code> <code>(fgets(line, _LINE_LENGTH, file) != NULL) {<!-- --></code></p> <p><code>                token = strtok(line, " ");</code></p> <p><code>                if</code> <code>(token != NULL) {<!-- --></code></p> <p><code>                // printf("token=%s\n", token);</code></p> <p><code>            }</code></p> <p><code>            token = strtok(NULL, " ");</code></p> <p><code>            if</code> <code>(token != NULL) {<!-- --></code></p> <p><code>            // printf("token=%s\n", token);</code></p> <p><code>            *total=atoll(token)/1024;//k/1024</code></p> <p><code>            err=0;</code></p> <p><code>            }</code></p> <p><code>        }</code></p> <p><code>    }</code></p> <p><code>    pclose(file);</code></p> <p><code>    }</code></p> <p><code>return</code> <code>err;</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<h3><a target="_blank" name="_Toc376251280">pthread_cond_signal</a>和pthread_cond_wait简介</h3> 
<p align="left"><span style="color:#333333">原文：</span><span style="color:#333333"> </span></p> 
<p align="left"><span style="color:#333333"><a target="_blank" href="http://www.eefocus.com/blog/link2url.php?link=http%3A%2F%2Fapps.hi.baidu.com%2Fshare%2Fdetail%2F19786281" rel="nofollow noopener noreferrer"><span style="color:#F59513">http://apps.hi.baidu.com/share/detail/19786281</span></a></span></p> 
<p align="left"><span style="color:#333333"><a target="_blank" href="http://www.eefocus.com/blog/link2url.php?link=http%3A%2F%2Fhi.baidu.com%2Fboobleoo0%2Fblog%2Fitem%2F5f935039a37c58f8b311c77f.html" rel="nofollow noopener noreferrer"><span style="color:#F59513">http://hi.baidu.com/boobleoo0/blog/item/5f935039a37c58f8b311c77f.html</span></a> </span></p> 
<p align="left"><span style="color:#333333"><a target="_blank" href="http://www.eefocus.com/blog/link2url.php?link=http%3A%2F%2Ftopic.csdn.net%2Fu%2F20110105%2F16%2F12717238-9816-4571-a03d-e8b603724946.html" rel="nofollow noopener noreferrer"><span style="color:#F59513">http://topic.csdn.net/u/20110105/16/12717238-9816-4571-a03d-e8b603724946.html</span></a> </span></p> 
<p align="left"><span style="color:#993300">   pthread_cond_wait() </span><span style="color:navy">用于阻塞当前线程，等待别的线程使用</span><span style="color:#993300">pthread_cond_signal()</span><span style="color:navy">或</span><span style="color:#FF9900">pthread_cond_broadcast</span><span style="color:#FF9900">来唤醒它</span><span style="color:navy">。</span><span style="color:#993300"> pthread_cond_wait() </span><span style="color:navy">必须与</span><span style="color:navy">pthread_mutex </span><span style="color:navy">配套使用。</span><span style="color:#FF6600">pthread_cond_wait()</span><span style="color:navy">函数一进入</span><span style="color:navy">wait</span><span style="color:navy">状态就会自动</span><span style="color:navy">release mutex</span><span style="color:navy">。当其他线程通过</span><span style="color:#FF9900">pthread_cond_signal()</span><span style="color:navy">或</span><span style="color:#FF9900">pthread_cond_broadcast</span><span style="color:navy">，把该线程唤醒，使</span><span style="color:navy">pthread_cond_wait()</span><span style="color:navy">通过（返回）时，该线程又自动获得该</span><span style="color:navy">mutex</span><span style="color:navy">。</span></p> 
<p align="left"><span style="color:#333333">  </span><span style="color:fuchsia">pthread_cond_signal</span><span style="color:navy">函数的作用是发送一个信号给另外一个正在处于阻塞等待状态的线程</span><span style="color:navy">,</span><span style="color:navy">使其脱离阻塞状态</span><span style="color:navy">,</span><span style="color:navy">继续执行</span><span style="color:navy">.</span><span style="color:navy">如果没有线程处在阻塞等待状态</span><span style="color:navy">,pthread_cond_signal</span><span style="color:navy">也会成功返回。</span></p> 
<p align="left"><span style="color:navy">  </span><span style="color:navy">使用</span><span style="color:navy">pthread_cond_signal</span><span style="color:navy">一般不会有</span><span style="color:navy">“</span><span style="color:navy">惊群现象</span><span style="color:navy">”</span><span style="color:navy">产生，他最多只给一个线程发信号。假如有多个线程正在阻塞等待着这个条件变量的话，那</span><span style="color:navy">么是根据各等待线程优先级的高低确定哪个线程接收到信号开始继续执行。如果各线程优先级相同，则根据等待时间的长短来确定哪个线程获得信号。但无论如何一</span><span style="color:navy">个</span><span style="color:navy">pthread_cond_signal</span><span style="color:navy">调用最多发信一次。</span></p> 
<p align="left"><span style="color:#993300">  </span><span style="color:navy">但是</span><span style="color:#993300">pthread_cond_signal</span><span style="color:navy">在多处理器上可能同时唤醒多个线程，当你只能让一个线程处理某个任务时，其它被唤醒的线程就需要继续</span><span style="color:navy"> wait</span><span style="color:navy">，而且规范要求</span><span style="color:#FF6600">pthread_cond_signal</span><span style="color:navy">至少唤醒一个</span><span style="color:navy">pthread_cond_wait</span><span style="color:navy">上的线程，其实有些实现为了简单在单处理器上也会唤醒多个线程</span><span style="color:navy">. </span></p> 
<p align="left"><span style="color:navy">   </span><span style="color:navy">另外，某些应用，如线程池，</span><span style="color:#FF9900">pthread_cond_broadcast</span><span style="color:navy">唤醒全部线程，但我们通常只需要一部分线程去做执行任务，所以其它的线程需要继续</span><span style="color:navy">wait.</span><span style="color:navy">所以强烈推荐对</span><span style="color:navy">pthread_cond_wait() </span><span style="color:navy">使用</span><span style="color:navy">while</span><span style="color:navy">循环来做条件判断</span><span style="color:navy">.</span></p> 
<p align="left"><span style="color:#333333">以下就是一个来自</span><span style="color:#333333">MAN</span><span style="color:#333333">的示例</span></p> 
<p align="left"><span style="color:#333333">  Consider two shared variables xand y, protected by the mutex mut, and a condition vari-</span></p> 
<p align="left"><span style="color:#333333">       able condthat is to be signaled whenever x becomes greater than y.</span></p> 
<div> 
 <p align="left"><span style="color:#333333">              </span><span style="color:#000088">int</span><span style="color:#333333"> x</span><span style="color:#666600">,</span><span style="color:#333333">y</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333">              </span><span style="color:#660066">pthread_mutex_t</span><span style="color:#333333"> mut </span><span style="color:#666600">=</span><span style="color:#333333"> PTHREAD_MUTEX_INITIALIZER</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333">              </span><span style="color:#660066">pthread_cond_t</span><span style="color:#333333"> cond </span><span style="color:#666600">=</span><span style="color:#333333"> PTHREAD_COND_INITIALIZER</span><span style="color:#666600">;</span></p> 
</div> 
<p align="left"><span style="color:#333333">       Waiting untilx is greater than y is performed as follows:</span></p> 
<div> 
 <p align="left"><span style="color:#333333">              pthread_mutex_lock</span><span style="color:#666600">(&amp;</span><span style="color:#333333">mut</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">              </span><span style="color:#000088">while</span><span style="color:#666600">(</span><span style="color:#333333">x </span><span style="color:#666600">&lt;=</span><span style="color:#333333"> y</span><span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#333333">                     pthread_cond_wait</span><span style="color:#666600">(&amp;</span><span style="color:#333333">cond</span><span style="color:#666600">,</span><span style="color:#666600">&amp;</span><span style="color:#333333">mut</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">              </span><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#333333">              </span><span style="color:#880000">/* operate on x and y */</span></p> 
 <p align="left"><span style="color:#333333">              pthread_mutex_unlock</span><span style="color:#666600">(&amp;</span><span style="color:#333333">mut</span><span style="color:#666600">);</span></p> 
</div> 
<p align="left"><span style="color:#333333">       Modificationson x and y that may cause x to become greater than y should signal the con-</span></p> 
<p align="left"><span style="color:#333333">       dition ifneeded:</span></p> 
<div> 
 <p align="left"><span style="color:#333333">              pthread_mutex_lock</span><span style="color:#666600">(&amp;</span><span style="color:#333333">mut</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">              </span><span style="color:#880000">/* modify x and y */</span></p> 
 <p align="left"><span style="color:#333333">              </span><span style="color:#000088">if</span><span style="color:#666600">(</span><span style="color:#333333">x </span><span style="color:#666600">&gt;</span><span style="color:#333333"> y</span><span style="color:#666600">)</span><span style="color:#333333">pthread_cond_broadcast</span><span style="color:#666600">(&amp;</span><span style="color:#333333">cond</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">              pthread_mutex_unlock</span><span style="color:#666600">(&amp;</span><span style="color:#333333">mut</span><span style="color:#666600">);</span></p> 
</div> 
<p align="left"><span style="color:navy">pthread_cond_signal</span><span style="color:navy">函数与条件变量的典型应用就是用来实现</span><span style="color:navy">producer/consumer</span><span style="color:navy">模型。</span></p> 
<p align="left"><strong><span style="color:#333333">示例</span><span style="color:#333333">1</span></strong></p> 
<div> 
 <p align="left"><span style="color:#880000">#include</span></p> 
 <p align="left"><span style="color:#880000">#include</span></p> 
 <p align="left"><span style="color:#880000">#include</span></p> 
 <p align="left"><span style="color:#880000">#include</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#880000">#define</span><span style="color:#333333"> BUFFER_SIZE </span><span style="color:#006666">8</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#000088">struct</span><span style="color:#660066">Products</span></p> 
 <p align="left"><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#000088">int</span><span style="color:#333333"> buffer</span><span style="color:#666600">[</span><span style="color:#333333">BUFFER_SIZE</span><span style="color:#666600">];</span></p> 
 <p align="left"><span style="color:#880000">/*</span><span style="color:#880000">保证存取操作的原子性 互斥性*/</span></p> 
 <p align="left"><span style="color:#660066">pthread_mutex_t</span><span style="color:#333333"> locker</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#880000">/*</span><span style="color:#880000">是否可读*/</span><span style="color:#333333">           </span></p> 
 <p align="left"><span style="color:#660066">pthread_cond_t</span><span style="color:#333333"> notEmpty</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#880000">/*</span><span style="color:#880000">是否可写*/</span><span style="color:#333333">  </span></p> 
 <p align="left"><span style="color:#660066">pthread_cond_t</span><span style="color:#333333"> notFull</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#000088">int</span><span style="color:#333333"> posReadFrom</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#000088">int</span><span style="color:#333333"> posWriteTo</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#666600">};</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#000088">int</span><span style="color:#660066">BufferIsFull</span><span style="color:#666600">(</span><span style="color:#000088">struct</span><span style="color:#660066">Products</span><span style="color:#666600">*</span><span style="color:#333333"> products</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#000088">if</span><span style="color:#666600">((</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">posWriteTo </span><span style="color:#666600">+</span><span style="color:#006666">1</span><span style="color:#666600">)</span><span style="color:#666600">%</span><span style="color:#333333"> BUFFER_SIZE </span><span style="color:#666600">==</span><span style="color:#333333"> products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">posReadFrom</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#000088">return</span><span style="color:#666600">(</span><span style="color:#006666">1</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#000088">return</span><span style="color:#666600">(</span><span style="color:#006666">0</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#000088">int</span><span style="color:#660066">BufferIsEmpty</span><span style="color:#666600">(</span><span style="color:#000088">struct</span><span style="color:#660066">Products</span><span style="color:#666600">*</span><span style="color:#333333"> products</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#000088">if</span><span style="color:#666600">(</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">posWriteTo </span><span style="color:#666600">==</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">posReadFrom</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#000088">return</span><span style="color:#666600">(</span><span style="color:#006666">1</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#000088">return</span><span style="color:#666600">(</span><span style="color:#006666">0</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#880000">/*</span><span style="color:#880000">制造产品*/</span><span style="color:#666600">。</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#000088">void</span><span style="color:#660066">Produce</span><span style="color:#666600">(</span><span style="color:#000088">struct</span><span style="color:#660066">Products</span><span style="color:#666600">*</span><span style="color:#333333"> products</span><span style="color:#666600">,</span><span style="color:#000088">int</span><span style="color:#333333"> item</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#880000">/*</span><span style="color:#880000">原子操作*/</span></p> 
 <p align="left"><span style="color:#333333">pthread_mutex_lock</span><span style="color:#666600">(&amp;</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">locker</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#880000">/*</span><span style="color:#880000">无空间可写入*/</span></p> 
 <p align="left"><span style="color:#000088">while</span><span style="color:#666600">(</span><span style="color:#660066">BufferIsFull</span><span style="color:#666600">(</span><span style="color:#333333">products</span><span style="color:#666600">))</span></p> 
 <p align="left"><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#333333">pthread_cond_wait</span><span style="color:#666600">(&amp;</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">notFull</span><span style="color:#666600">,</span><span style="color:#666600">&amp;</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">locker</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#666600">}</span><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#880000">/*</span><span style="color:#880000">写入数据*/</span></p> 
 <p align="left"><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">buffer</span><span style="color:#666600">[</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">posWriteTo</span><span style="color:#666600">]</span><span style="color:#666600">=</span><span style="color:#333333"> item</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">posWriteTo</span><span style="color:#666600">++;</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#000088">if</span><span style="color:#666600">(</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">posWriteTo </span><span style="color:#666600">&gt;=</span><span style="color:#333333">BUFFER_SIZE</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">posWriteTo </span><span style="color:#666600">=</span><span style="color:#006666">0</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#880000">/*</span><span style="color:#880000">发信*/</span></p> 
 <p align="left"><span style="color:#333333">pthread_cond_signal</span><span style="color:#666600">(&amp;</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">notEmpty</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#880000">/*</span><span style="color:#880000">解锁*/</span></p> 
 <p align="left"><span style="color:#333333">pthread_mutex_unlock</span><span style="color:#666600">(&amp;</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">locker</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#000088">int</span><span style="color:#660066">Consume</span><span style="color:#666600">(</span><span style="color:#000088">struct</span><span style="color:#660066">Products</span><span style="color:#666600">*</span><span style="color:#333333"> products</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#000088">int</span><span style="color:#333333"> item</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#333333">pthread_mutex_lock</span><span style="color:#666600">(&amp;</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">locker</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#880000">/*</span><span style="color:#880000">为空时持续等待,</span>无数据可读*/</p> 
 <p align="left"><span style="color:#000088">while</span><span style="color:#666600">(</span><span style="color:#660066">BufferIsEmpty</span><span style="color:#666600">(</span><span style="color:#333333">products</span><span style="color:#666600">))</span></p> 
 <p align="left"><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#333333">pthread_cond_wait</span><span style="color:#666600">(&amp;</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">notEmpty</span><span style="color:#666600">,</span><span style="color:#666600">&amp;</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">locker</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#880000">/*</span><span style="color:#880000">提取数据*/</span></p> 
 <p align="left"><span style="color:#333333">item </span><span style="color:#666600">=</span><span style="color:#333333"> products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">buffer</span><span style="color:#666600">[</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">posReadFrom</span><span style="color:#666600">];</span></p> 
 <p align="left"><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">posReadFrom</span><span style="color:#666600">++;</span></p> 
 <p align="left"><span style="color:#880000">/*</span><span style="color:#880000">如果到末尾,</span>从头读取*/</p> 
 <p align="left"><span style="color:#000088">if</span><span style="color:#666600">(</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">posReadFrom </span><span style="color:#666600">&gt;=</span><span style="color:#333333">BUFFER_SIZE</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">posReadFrom </span><span style="color:#666600">=</span><span style="color:#006666">0</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#333333">pthread_cond_signal</span><span style="color:#666600">(&amp;</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">notFull</span><span style="color:#666600">);</span><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#333333">pthread_mutex_unlock</span><span style="color:#666600">(&amp;</span><span style="color:#333333">products</span><span style="color:#666600">-&gt;</span><span style="color:#333333">locker</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#000088">return</span><span style="color:#333333"> item</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#880000">#define</span><span style="color:#333333"> END_FLAG </span><span style="color:#666600">(-</span><span style="color:#006666">1</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#000088">struct</span><span style="color:#660066">Products</span><span style="color:#333333"> products</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#000088">void</span><span style="color:#666600">*</span><span style="color:#660066">ProducerThread</span><span style="color:#666600">(</span><span style="color:#000088">void</span><span style="color:#666600">*</span><span style="color:#333333">data</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#000088">int</span><span style="color:#333333"> i</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#000088">for</span><span style="color:#666600">(</span><span style="color:#333333">i </span><span style="color:#666600">=</span><span style="color:#006666">0</span><span style="color:#666600">;</span><span style="color:#333333"> i </span><span style="color:#666600">&lt;</span><span style="color:#006666">16</span><span style="color:#666600">;</span><span style="color:#666600">++</span><span style="color:#333333">i</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#333333">printf</span><span style="color:#666600">(</span><span style="color:#008800">"producer: %d\n"</span><span style="color:#666600">,</span><span style="color:#333333"> i</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#660066">Produce</span><span style="color:#666600">(&amp;</span><span style="color:#333333">products</span><span style="color:#666600">,</span><span style="color:#333333"> i</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#660066">Produce</span><span style="color:#666600">(&amp;</span><span style="color:#333333">products</span><span style="color:#666600">,</span><span style="color:#333333">END_FLAG</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#000088">return</span><span style="color:#333333"> NULL</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#000088">void</span><span style="color:#666600">*</span><span style="color:#660066">ConsumerThread</span><span style="color:#666600">(</span><span style="color:#000088">void</span><span style="color:#666600">*</span><span style="color:#333333">data</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#000088">int</span><span style="color:#333333"> item</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#000088">while</span><span style="color:#666600">(</span><span style="color:#006666">1</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#333333">item </span><span style="color:#666600">=</span><span style="color:#660066">Consume</span><span style="color:#666600">(&amp;</span><span style="color:#333333">products</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#000088">if</span><span style="color:#666600">(</span><span style="color:#333333">END_FLAG </span><span style="color:#666600">==</span><span style="color:#333333"> item</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#333333">       </span><span style="color:#000088">break</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333">printf</span><span style="color:#666600">(</span><span style="color:#008800">"consumer: %d\n"</span><span style="color:#666600">,</span><span style="color:#333333"> item</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#000088">return</span><span style="color:#666600">(</span><span style="color:#333333">NULL</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#000088">int</span><span style="color:#333333"> main</span><span style="color:#666600">(</span><span style="color:#000088">int</span><span style="color:#333333"> argc</span><span style="color:#666600">,</span><span style="color:#000088">char</span><span style="color:#666600">*</span><span style="color:#333333"> argv</span><span style="color:#666600">[])</span></p> 
 <p align="left"><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#660066">pthread_t</span><span style="color:#333333"> producer</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#660066">pthread_t</span><span style="color:#333333"> consumer</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#000088">int</span><span style="color:#333333"> result</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#333333">pthread_create</span><span style="color:#666600">(&amp;</span><span style="color:#333333">producer</span><span style="color:#666600">,</span><span style="color:#333333"> NULL</span><span style="color:#666600">,</span><span style="color:#666600">&amp;</span><span style="color:#660066">ProducerThread</span><span style="color:#666600">,</span><span style="color:#333333">NULL</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">pthread_create</span><span style="color:#666600">(&amp;</span><span style="color:#333333">consumer</span><span style="color:#666600">,</span><span style="color:#333333">NULL</span><span style="color:#666600">,</span><span style="color:#666600">&amp;</span><span style="color:#660066">ConsumerThread</span><span style="color:#666600">,</span><span style="color:#333333">NULL</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#333333">pthread_join</span><span style="color:#666600">(</span><span style="color:#333333">producer</span><span style="color:#666600">,</span><span style="color:#666600">(</span><span style="color:#000088">void</span><span style="color:#666600">*)&amp;</span><span style="color:#333333">result</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">pthread_join</span><span style="color:#666600">(</span><span style="color:#333333">consumer</span><span style="color:#666600">,</span><span style="color:#666600">(</span><span style="color:#000088">void</span><span style="color:#666600">*)&amp;</span><span style="color:#333333">result</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333"> </span></p> 
 <p align="left"><span style="color:#000088">exit</span><span style="color:#666600">(</span><span style="color:#333333">EXIT_SUCCESS</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#666600">}</span></p> 
</div> 
<p align="left"><span style="color:#333333">示例</span><span style="color:#333333">2</span></p> 
<p align="left"><span style="color:#333333">pthread_cond_broadcast</span><span style="color:#333333">的是使用</span></p> 
<div> 
 <p align="left"><span style="color:#660066">pthread_mutex_t</span><span style="color:#333333"> mymutex1 </span><span style="color:#666600">=</span><span style="color:#333333"> PTHREAD_MUTEX_INITIALIZER</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#660066">pthread_mutex_t</span><span style="color:#333333"> mymutex2 </span><span style="color:#666600">=</span><span style="color:#333333"> PTHREAD_MUTEX_INITIALIZER</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#660066">pthread_cond_t</span><span style="color:#333333"> mycond </span><span style="color:#666600">=</span><span style="color:#333333"> PTHREAD_COND_INITIALIZER</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333"> </span><span style="color:#000088">void</span><span style="color:#666600">*</span><span style="color:#333333">mythread1</span><span style="color:#666600">(</span><span style="color:#000088">void</span><span style="color:#666600">*</span><span style="color:#333333">param</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#333333"> </span><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#333333">  pthread_mutex_lock</span><span style="color:#666600">(&amp;</span><span style="color:#333333">mymutex1</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">  pthread_cond_wait</span><span style="color:#666600">(&amp;</span><span style="color:#333333">mycond</span><span style="color:#666600">,&amp;</span><span style="color:#333333">mymutex1</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">  fprintf</span><span style="color:#666600">(</span><span style="color:#333333">stderr</span><span style="color:#666600">,</span><span style="color:#008800">"this is mythread1.\n"</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">  pthread_mutex_unlock</span><span style="color:#666600">(&amp;</span><span style="color:#333333">mymutex1</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">  </span><span style="color:#000088">return</span><span style="color:#333333">NULL</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333"> </span><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#333333"> </span><span style="color:#000088">void</span><span style="color:#666600">*</span><span style="color:#333333">mythread2</span><span style="color:#666600">(</span><span style="color:#000088">void</span><span style="color:#666600">*</span><span style="color:#333333">param</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#333333"> </span><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#333333">  pthread_mutex_lock</span><span style="color:#666600">(&amp;</span><span style="color:#333333">mymutex2</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">  pthread_cond_wait</span><span style="color:#666600">(&amp;</span><span style="color:#333333">mycond</span><span style="color:#666600">,&amp;</span><span style="color:#333333">mymutex2</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">  fprintf</span><span style="color:#666600">(</span><span style="color:#333333">stderr</span><span style="color:#666600">,</span><span style="color:#008800">"this is mythread2.\n"</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">  pthread_mutex_unlock</span><span style="color:#666600">(&amp;</span><span style="color:#333333">mymutex2</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">  </span><span style="color:#000088">return</span><span style="color:#333333"> NULL</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333"> </span><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#333333"> </span><span style="color:#000088">int</span><span style="color:#333333"> main</span><span style="color:#666600">(</span><span style="color:#000088">int</span><span style="color:#333333"> argc</span><span style="color:#666600">,</span><span style="color:#000088">char</span><span style="color:#666600">*</span><span style="color:#333333"> argv</span><span style="color:#666600">[],</span><span style="color:#000088">char</span><span style="color:#666600">*</span><span style="color:#333333">envp</span><span style="color:#666600">[])</span></p> 
 <p align="left"><span style="color:#333333"> </span><span style="color:#666600">{<!-- --></span></p> 
 <p align="left"><span style="color:#333333">  </span><span style="color:#000088">int</span><span style="color:#333333"> i</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333">  </span><span style="color:#660066">pthread_t</span><span style="color:#333333">tid1</span><span style="color:#666600">,</span><span style="color:#333333">tid2</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333">  pthread_create</span><span style="color:#666600">(&amp;</span><span style="color:#333333">tid1</span><span style="color:#666600">,</span><span style="color:#333333">NULL</span><span style="color:#666600">,</span><span style="color:#333333">mythread1</span><span style="color:#666600">,</span><span style="color:#333333">NULL</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">  pthread_create</span><span style="color:#666600">(&amp;</span><span style="color:#333333">tid2</span><span style="color:#666600">,</span><span style="color:#333333">NULL</span><span style="color:#666600">,</span><span style="color:#333333">mythread2</span><span style="color:#666600">,</span><span style="color:#333333">NULL</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">  sleep</span><span style="color:#666600">(</span><span style="color:#006666">2</span><span style="color:#666600">)</span></p> 
 <p align="left"><span style="color:#333333">  </span><span style="color:#000088">if</span><span style="color:#666600">(</span><span style="color:#333333">pthread_cond_broadcast</span><span style="color:#666600">(&amp;</span><span style="color:#333333">mycond</span><span style="color:#666600">)){<!-- --></span></p> 
 <p align="left"><span style="color:#333333">  printf</span><span style="color:#666600">(</span><span style="color:#008800">"error\n"</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">  </span><span style="color:#000088">return</span><span style="color:#006666">1</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333">  </span><span style="color:#666600">}</span></p> 
 <p align="left"><span style="color:#333333">  </span><span style="color:#000088">void</span><span style="color:#666600">*</span><span style="color:#333333">res</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333">  pthread_join</span><span style="color:#666600">(</span><span style="color:#333333">tid1</span><span style="color:#666600">,</span><span style="color:#666600">&amp;</span><span style="color:#333333">res</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">  pthread_join</span><span style="color:#666600">(</span><span style="color:#333333">tid2</span><span style="color:#666600">,</span><span style="color:#666600">&amp;</span><span style="color:#333333">res</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">  printf</span><span style="color:#666600">(</span><span style="color:#008800">"thisis main thread.\n"</span><span style="color:#666600">);</span></p> 
 <p align="left"><span style="color:#333333">  </span><span style="color:#000088">return</span><span style="color:#006666">0</span><span style="color:#666600">;</span></p> 
 <p align="left"><span style="color:#333333"> </span><span style="color:#666600">}</span></p> 
</div> 
<h3><a target="_blank" name="_Toc376251281">linux </a>下route命令</h3> 
<p style="background:#BCD3E5"><span style="color:#464646">      </span><span style="color:#464646">为了让设备能访问另一个子网，需要在设备里增加路由到子网络，下面是一些资料。基本操作如下：</span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">一般来说，都是为了能访问别的子网才设置路由的，比如说，你的主机处于</span><span style="color:#464646">192.168.10.0/24</span><span style="color:#464646">，而你想访问</span><span style="color:#464646">192.168.20.0/24</span><span style="color:#464646">网的主机，当然你知道一个网关</span><span style="color:#464646">IP</span><span style="color:#464646">，例如</span><span style="color:#464646">192.168.10.1</span><span style="color:#464646">（必须和你主机处于同一子网），那么，你可以这样配置路由。</span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">添加路由</span></p> 
<p style="background:#BCD3E5"><span style="color:#990030">route</span><span style="color:#464646"> </span><span style="color:#990030">add -net</span><span style="color:#464646"> </span><strong><span style="color:#464646">192.168.20.0</span></strong><span style="color:#464646"> </span><span style="color:#990030">netmask</span><span style="color:#464646"> </span><strong><span style="color:#464646">255.255.255.0</span></strong><span style="color:#464646"> </span><span style="color:#990030">gw</span><span style="color:#464646"> </span><strong><span style="color:#464646">192.168.10.1</span></strong></p> 
<p style="background:#BCD3E5"><span style="color:#464646">查看路由状态</span></p> 
<p style="background:#BCD3E5"><span style="color:#990030">route -n</span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">删除路由</span></p> 
<p style="background:#BCD3E5"><span style="color:#990030">route del -net</span><span style="color:#464646"> </span><strong><span style="color:#464646">192.168.20.0</span></strong><span style="color:#464646"> </span><span style="color:#990030">netmask</span><span style="color:#464646"> </span><strong><span style="color:#464646">255.255.255.0</span></strong></p> 
<p style="background:#BCD3E5"><span style="color:#464646"> </span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">摘自鸟哥的私房菜</span><span style="color:#464646"><br> </span><span style="color:#464646">路由修改</span><span style="color:#464646"> route       <br>    </span><span style="color:#464646"> </span><span style="color:#464646">我们在</span><span style="color:#464646"><a target="_blank" href="http://linux.vbird.org/linux_server/0110network_basic.php" rel="nofollow noopener noreferrer">网路基础</a></span><span style="color:#464646">的时候谈过关于路由的问题，两部主机之间一定要有路由才能够互通</span><span style="color:#464646"> TCP/IP </span><span style="color:#464646">的协定，否则就无法进行连线啊！</span><span style="color:#464646"><br> </span><span style="color:#464646">一般来说，只要有网路介面，该介面就会产生一个路由，例如在鸟哥实验室内部的主机有一个</span><span style="color:#464646"> eth0 </span><span style="color:#464646">及 </span><span style="color:#464646">lo </span><span style="color:#464646">，所以：</span><span style="color:#464646"><br> [root@linux ~]# route [-nee]<br> [root@linux ~]# route add [-net|-host] [</span><span style="color:#464646">网域或主机</span><span style="color:#464646">] netmask [mask] [gw|dev]<br> [root@linux ~]# route del [-net|-host] [</span><span style="color:#464646">网域或主机</span><span style="color:#464646">] netmask [mask] [gw|dev]<br> </span><span style="color:#464646">观察的参数：</span><span style="color:#464646"><br>    -n  </span><span style="color:#464646">：不要使用通讯协定或主机名称，直接使用 </span><span style="color:#464646">IP </span><span style="color:#464646">或 </span><span style="color:#464646">port number</span><span style="color:#464646">；</span><span style="color:#464646"><br>    -ee </span><span style="color:#464646">：使用更详细的资讯来显示</span><span style="color:#464646"><br> </span><span style="color:#464646">增加</span><span style="color:#464646"> (add) </span><span style="color:#464646">与删除 </span><span style="color:#464646">(del) </span><span style="color:#464646">路由的相关参数：</span><span style="color:#464646"><br>    -net    </span><span style="color:#464646">：表示后面接的路由为一个网域；</span><span style="color:#464646"><br>    -host   </span><span style="color:#464646">：表示后面接的为连接到单部主机的路由；</span><span style="color:#464646"><br>    netmask </span><span style="color:#464646">：与网域有关，可以设定 </span><span style="color:#464646">netmask </span><span style="color:#464646">决定网域的大小；</span><span style="color:#464646"><br>    gw      </span><span style="color:#464646">：</span><span style="color:#464646">gateway </span><span style="color:#464646">的简写，后续接的是 </span><span style="color:#464646">IP </span><span style="color:#464646">的数值喔，与 </span><span style="color:#464646">dev </span><span style="color:#464646">不同；</span><span style="color:#464646"><br>    dev     </span><span style="color:#464646">：如果只是要指定由那一块网路卡连线出去，则使用这个设定，后面接 </span><span style="color:#464646">eth0 </span><span style="color:#464646">等</span><span style="color:#464646"><br> </span><span style="color:#464646">范例一：单纯的观察路由状态</span><span style="color:#464646"><br> [root@linux ~]# route -n<br> Kernel IP routing table<br> Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br> 192.168.10.0    0.0.0.0         255.255.255.0   U     0      0        0 eth0<br> 169.254.0.0     0.0.0.0         255.255.0.0     U     0      0        0 eth0<br> 0.0.0.0         192.168.10.30   0.0.0.0         UG    0      0        0 eth0<br> [root@linux ~]# route<br> Kernel IP routing table<br> Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br> 192.168.10.0    *               255.255.255.0   U     0      0        0 eth0<br> 169.254.0.0     *               255.255.0.0     U     0      0        0 eth0<br> default         server.cluster  </span><span style="color:#464646"> </span><span style="color:#464646">   </span><span style="color:#464646">0.0.0.0         UG    0      0        0 eth0<br> </span><span style="color:#464646">  </span><span style="color:#464646"> </span><span style="color:#464646">由上面的例子当中仔细观察</span><span style="color:#464646"> route </span><span style="color:#464646">与 </span><span style="color:#464646">route -n </span><span style="color:#464646">的输出结果，你可以发现有加 </span><span style="color:#464646">-n</span><span style="color:#464646">参数的主要是显示出 </span><span style="color:#464646">IP </span><span style="color:#464646">，至于使用 </span><span style="color:#464646">route </span><span style="color:#464646">而已的话，显示的则是『主机名称』喔！也就是说，在预设的情况下， </span><span style="color:#464646">route </span><span style="color:#464646">会去找出该 </span><span style="color:#464646">IP </span><span style="color:#464646">的主机名称，如果找不到呢？就会显示的钝钝的</span><span style="color:#464646">(</span><span style="color:#464646">有点小慢</span><span style="color:#464646">)</span><span style="color:#464646">，所以说，鸟哥通常都直接使用 </span><span style="color:#464646">route -n </span><span style="color:#464646">啦！由上面看起来，我们也知道 </span><span style="color:#464646">default = 0.0.0.0/0.0.0.0 </span><span style="color:#464646">，而上面的资讯有哪些你必须要知道的呢？</span><span style="color:#464646"><br>                </span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">· </span><span style="color:#464646">Destination, Genmask</span><span style="color:#464646">：这两个玩意儿就是分别是 </span><span style="color:#464646">network </span><span style="color:#464646">与</span><span style="color:#464646">netmask </span><span style="color:#464646">啦！所以这两个咚咚就组合成为一个完整的网域囉！</span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">· </span><span style="color:#464646">Gateway</span><span style="color:#464646">：该网域是通过那个 </span><span style="color:#464646">gateway </span><span style="color:#464646">连接出去的？ </span>如果显示 <span style="color:#464646">0.0.0.0 </span><span style="color:#464646">表示该路由是直接由本机传送，亦即可以透过区域网路的 </span><span style="color:#464646">MAC </span><span style="color:#464646">直接传讯；如果有显示 </span><span style="color:#464646">IP </span><span style="color:#464646">的话，表示该路由需要经过路由器 </span><span style="color:#464646">(</span><span style="color:#464646">通讯闸</span><span style="color:#464646">) </span><span style="color:#464646">的帮忙才能够传送出去。</span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">· </span><span style="color:#464646">Flags</span><span style="color:#464646">：总共有多个旗标，代表的意义如下：                        </span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">o </span><span style="color:#464646">U (route is up)</span><span style="color:#464646">：该路由是启动的；                       </span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">o </span><span style="color:#464646">H (target is a host)</span><span style="color:#464646">：目标是一部主机 </span><span style="color:#464646">(IP) </span><span style="color:#464646">而非网域；                       </span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">o </span><span style="color:#464646">G (use gateway)</span><span style="color:#464646">：需要透过外部的主机 </span><span style="color:#464646">(gateway) </span><span style="color:#464646">来转递封包；                       </span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">o </span><span style="color:#464646">R (reinstate route for dynamic routing)</span><span style="color:#464646">：使用动态路由时，恢复路由资讯的旗标；                       </span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">o </span><span style="color:#464646">D (dynamically installed by daemon or redirect)</span><span style="color:#464646">：已经由服务或转 </span><span style="color:#464646">port </span><span style="color:#464646">功能设定为动态路由                       </span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">o </span><span style="color:#464646">M (modified from routing daemon or redirect)</span><span style="color:#464646">：路由已经被修改了；                       </span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">o </span><span style="color:#464646">!  (reject route)</span><span style="color:#464646">：这个路由将不会被接受</span><span style="color:#464646">(</span><span style="color:#464646">用来抵挡不安全的网域！</span><span style="color:#464646">)</span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">· </span><span style="color:#464646">Iface</span><span style="color:#464646">：这个路由传递封包的介面。</span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">此外，观察一下上面的路由排列顺序喔，依序是由小网域</span><span style="color:#464646">(192.168.10.0/24 </span><span style="color:#464646">是 </span><span style="color:#464646">Class C)</span><span style="color:#464646">，逐渐到大网域</span><span style="color:#464646">(169.254.0.0/16 Class B) </span><span style="color:#464646">最后则是预设路由 </span><span style="color:#464646">(0.0.0.0/0.0.0.0)</span><span style="color:#464646">。然后当我们要判断某个网路封包应该如何传送的时候，该封包会经由这个路由的过程来判断喔！举例来说，我上头仅有三个路由，若我有一个传往 </span><span style="color:#464646">192.168.10.20 </span><span style="color:#464646">的封包要传递，那首先会找 </span><span style="color:#464646">192.168.10.0/24 </span><span style="color:#464646">这个网域的路由，找到了！所以直接由 </span><span style="color:#464646">eth0 </span><span style="color:#464646">传送出去；如果是传送到 </span><span style="color:#464646">Yahoo </span><span style="color:#464646">的主机呢？ </span><span style="color:#464646">Yahoo </span><span style="color:#464646">的主机 </span><span style="color:#464646">IP </span><span style="color:#464646">是 </span><span style="color:#464646">202.43.195.52</span><span style="color:#464646">，我通过判断 </span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">1)</span><span style="color:#464646">不是</span><span style="color:#464646"> 192.168.10.0/24</span><span style="color:#464646">，</span><span style="color:#464646"><br>        </span>2)<span style="color:#464646">不是 </span><span style="color:#464646">169.254.0.0/16 </span><span style="color:#464646">结果到达 </span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">3)0/0 </span><span style="color:#464646">时，</span><span style="color:#464646">OK</span><span style="color:#464646">！传出去了，透过 </span><span style="color:#464646">eth0 </span><span style="color:#464646">将封包传给 </span><span style="color:#464646">192.168.10.30</span><span style="color:#464646">那部 </span><span style="color:#464646">gateway </span><span style="color:#464646">主机啊！所以说，路由是有顺序的。因此当你重复设定多个同样的路由时，例如在你的主机上的两张网路卡设定为相同网域的 </span><span style="color:#464646">IP </span><span style="color:#464646">时，会出现什么情况？会出现如下的情况：</span><span style="color:#464646"><br> Kernel IP routing table<br> Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br> 192.168.10.0    0.0.0.0         255.255.255.0   U     0      0        0 eth0<br> 192.168.10.0    0.0.0.0         255.255.255.0   U     0      0        0 eth1<br> </span><span style="color:#464646">也就是说，由于路由是依照顺序来排列与传送的，所以不论封包是由那个介面</span><span style="color:#464646"> (eth0, eth1) </span><span style="color:#464646">所接收，都会由上述的 </span><span style="color:#464646">eth0 </span><span style="color:#464646">传送出去，所以，在一部主机上面设定两个相同网域的 </span><span style="color:#464646">IP </span><span style="color:#464646">本身没有什么意义！有点多此一举就是了。除非是类似虚拟主机 </span><span style="color:#464646">(Xen, VMware </span><span style="color:#464646">等软体</span><span style="color:#464646">) </span><span style="color:#464646">所架设的多主机时，才会有这个必要～</span><span style="color:#464646"><br> </span><span style="color:#464646">范例二：路由的增加与删除</span><span style="color:#464646"><br> [root@linux ~]# route del -net 169.254.0.0 netmask 255.255.0.0 dev eth0<br> # </span><span style="color:#464646">上面这个动作可以删除掉 </span><span style="color:#464646">169.254.0.0/16 </span><span style="color:#464646">这个网域！</span><span style="color:#464646"><br> # </span><span style="color:#464646">请注意，在删除的时候，需要将路由表上面出现的资讯都写入</span><span style="color:#464646"><br> # </span><span style="color:#464646">包括  </span><span style="color:#464646">netmask , dev </span><span style="color:#464646">等等参数喔！注意注意</span><span style="color:#464646"><br> [root@linux ~]# route add -net 192.168.100.0 netmask 255.255.255.0 dev eth0<br> # </span><span style="color:#464646">透过 </span><span style="color:#464646">route add </span><span style="color:#464646">来增加一个路由！请注意，这个路由必须要能够与你互通。</span><span style="color:#464646"><br> # </span><span style="color:#464646">举例来说，如果我下达底下的指令就会显示错误：</span><span style="color:#464646"><br> # route add -net 192.168.200.0 netmask 255.255.255.0 gw 192.168.200.254<br> # </span><span style="color:#464646">因为我的环境内仅有 </span><span style="color:#464646">192.168.10.100 </span><span style="color:#464646">这个 </span><span style="color:#464646">IP </span><span style="color:#464646">，所以不能与 </span><span style="color:#464646">192.168.200.254<br> # </span><span style="color:#464646">这个网段直接使用 </span><span style="color:#464646">MAC </span><span style="color:#464646">互通！这样说，可以理解喔！？</span><span style="color:#464646"><br> [root@linux ~]# route add default gw 192.168.10.30<br> # </span><span style="color:#464646">增加预设路由的方法！请注意，只要有一个预设路由就够了喔！</span><span style="color:#464646"><br> # </span><span style="color:#464646">在这个地方如果您随便设定后，记得使用底下的指令重新设定你的网路</span><span style="color:#464646"><br> # /etc/init.d/network restart<br>       </span><span style="color:#464646">如果是要进行路由的删除与增加，那就得要参考上面的例子了，其实，使用</span><span style="color:#464646"> man route </span><span style="color:#464646">里面的资料就很丰富了！仔细查阅一下囉！你只要记得，当出现『</span><span style="color:#464646">SIOCADDRT: Network is unreachable</span><span style="color:#464646">』这个错误时，肯定是由于 </span><span style="color:#464646">gw </span><span style="color:#464646">后面接的 </span><span style="color:#464646">IP </span><span style="color:#464646">无法直接与您的网域沟通 </span><span style="color:#464646">(Gateway </span><span style="color:#464646">并不在你的网域内</span><span style="color:#464646">)</span><span style="color:#464646">，所以，赶紧检查一下是否输入错误啊！加油吧！</span></p> 
<p style="background:#BCD3E5"><span style="color:#464646"> </span></p> 
<p style="background:#BCD3E5"><span style="color:#464646"># route </span><span style="color:#464646">命令添加的路由，机器重启或者网卡重启后就没掉了，在</span><span style="color:#464646">linux</span><span style="color:#464646">下设置永久路由的方法：</span><span style="color:#464646"><br> 1.</span><span style="color:#464646">在</span><span style="color:#464646">/etc/rc.local</span><span style="color:#464646">里添加</span><span style="color:#464646"><br> 2.</span><span style="color:#464646">在</span><span style="color:#464646">/etc/sysconfig/network</span><span style="color:#464646">里添加到末尾</span><span style="color:#464646"><br> 3./etc/sysconfig/static-router :<br> any net x.x.x.x/24 gw y.y.y.y</span></p> 
<p style="background:#BCD3E5"><span style="color:#464646"> </span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">===========================================================================================   </span>WINDOWS<span style="color:#464646">下的route</span>命令：</p> 
<p style="background:#BCD3E5"><span style="color:#464646">简单的的操作如下，</span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">查看路由状态：route print</span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">只查看ipv4</span>（ipv6）路由状态：routeprint -4(-6)</p> 
<p style="background:#BCD3E5"><span style="color:#464646">添加路由：route add </span>目的网络 mask 子网掩码 网关 ——重启机器或网卡失效</p> 
<p style="background:#BCD3E5"><span style="color:#464646">route add 192.168.20.0 mask 255.255.255.0 192.168.10.1</span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">添加永久：route -p add </span>目的网络 mask 子网掩码网关</p> 
<p style="background:#BCD3E5"><span style="color:#464646">route -p add 192.168.20.0 mask 255.255.255.0 192.168.10.1</span></p> 
<p style="background:#BCD3E5"><span style="color:#464646">删除路由：route delete </span> 目的网络 mask 子网掩码</p> 
<p style="background:#BCD3E5"><span style="color:#464646">route delete 192.168.20.0 mask 255.255.255.0</span></p> 
<div align="center"> 
 <table border="0" cellspacing="0" cellpadding="0" width="660"><tbody><tr><td> <h3><a target="_blank" name="_Toc376251282">UNIX</a>环境高级编程读书笔记（十一）—终端IO （3）</h3> </td></tr><tr><td> 
     <div align="center"> 
      <table border="0" cellspacing="0" cellpadding="0" width="80%"></table> 
     </div> </td></tr><tr><td> <p align="center">来源: ChinaUnix博客 　日期： 2007.04.09 15:09　(共有条评论) <a target="_blank" href="http://linux.chinaunix.net/bbs/thread-954704-1-1.html" rel="nofollow noopener noreferrer"><span style="color:#0044B6">我要评论</span></a></p> </td></tr><tr><td> <p align="left"> </p> </td></tr><tr><td> <p align="left">2.<br> 名称:：<br> cfgetispeed/cfgetospeed/cfsetispeed/cfsetospeed<br> 功能：<br> 波特率函数<br> 头文件：<br> #include <br> 函数原形：<br> speed_t cfgetispeed(const struct termios *termptr);<br> speed_t cfgetospeed(const struct termios *termptr);<br> int cfsetispeed(struct termios *termotr,speed_t speed);<br> int cfsetospeed(struct termios *termotr,speed_t speed);<br> 参数：<br> <br> 返回值：<br> 返回波特率（ cfgetispeed， cfgetospeed）<br> 若成功返回0，若出错则返回-1（ cfsetispeed， cfsetospeed）<br>        波特率是一个以往采用的术语，现在它指的是“位/秒”。虽然大多数终端设备对输入和输出使用同一波特率，但是只要硬件许可，可以将它们设置为两个不同值。<br> <br> 3．<br> 名称:：<br> tcdrain/tcflow/tcflush/tcsendbreak<br> 功能：<br> 行控制函数<br> 头文件：<br> #include <br> 函数原形：<br> int tcdrain(int filedes);<br> int tcglow(int files,int action);<br> int tcflush(int files,int queue);<br> int tcsendbread(int filedes,int duration);<br> 参数：<br> filedes     终端I/O所对应的文件的文件描述符<br> 返回值：<br> 若成功返回0，若出错则返回-1<br>        tcdrain函数等待所有输出都被发送。tcflow用于对输入和输出流控制进行控制。action参数应当是下列四个值：<br>        TCOOFF        输出被挂起<br>        TCOON         以前被挂起的输出被重新启动<br>        TCIOFF     系统发送一个STOP字符。这将使终端设备暂停发送数据。<br>        TCION          系统发送一个START字符。这将使终端恢复发送数据。<br> tcflush函数刷清输入缓存或输出缓存。queue参数应当是下列三个参数之一：<br>        TCIFLUSH     刷清输入队列<br>        TCOFLUSH    刷清输出队列<br>        TCIOFLUSH  刷清输入、输出队列<br> tcsendbread函数在一个指定的时间区间内发送连续的0位流。若duration参数为0，则此种发送延续0.25~0.5秒之间。<br> <br> 4．<br> 名称:：<br> ctermid(char *ptr);<br> 功能：<br> 决定终端的名字<br> 头文件：<br> #include <br> 函数原形：<br> char *ctermid(char *ptr);<br> 参数：<br> ptr  存放控制终端名的数组<br> 返回值：<br> 若成功则返回指向控制终端名的指针，若出错则返回指向空字符串的指针。<br>        ctermid可却定终端的名字。<br>        如果ptr是非空，则它被认为是一个指针，指向长度至少为L_ctermid字节的数组，进程的控制终端名存放在该数组中。参数L_ctermid定义在中。若ptr是是一个空指针，则该函数为数组分配空间。同样，进程的控制终端名存放在该数组中。<br> 大部分UNIX系统中，控制终端的名称是/dev/tty/。所以此函数的主要作用是帮助提高向其他操作系统的可移植性。<br> <br> 5．<br> 名称:：<br> isatty<br> 功能：<br> 判断文件是不是一个终端设备文件<br> 头文件：<br> #include <br> 函数原形：<br> int isatty(int filedes);<br> 参数：<br> filedes     终端I/O所对应的文件的文件描述符<br> 返回值：<br> 若终端设备则为1，否则为0。<br> isatty函数用于判断文件是不是一个终端设备。下面是实例：<br> <br> /*11_2.c*/<br> #include <br> <br> int main(void)<br> {<!-- --><br> printf(“fd 0:%s\n”,isatty(0)?”tty”:”not a tty”);<br> printf(“fd 1:%s\n”,isatty(1)?”tty”,”not a tty”);<br> printf(“fd2:%s\n”,isatty(2)?”tty”,”not a tty”); <br> exit(0);<br> }<br> <br> 下面是运行结果：<br> #./11_2<br> fd 0:tty<br> fd 1:tty<br> fd 2:tty<br> #./11_2 /dev/null<br> fd 0:not a tty<br> fd: 1:tty<br> fd2:not a tty<br> <br> 6．<br> 名称:：<br> ttyname<br> 功能：<br> 判断是不是终端设备文件如果是打印路径名<br> 头文件：<br> #include <br> 函数原形：<br> char *ttyname(int filedes);<br> 参数：<br> filedes     终端I/O所对应的文件的文件描述符<br> 返回值：<br> 指向终端路径名的指针，若出错则为NULL<br>        每个文件系统有一个唯一的设备号（stat结构中的st_dev字段），文件系统每个目录项有唯一的i节点号（stat结构中的st_ino字段）。ttyname会读/dev目录，寻找具有相同设备号和i节点编号的表项。在此函数中设定当找到一个匹配的设备号和匹配的i节点号时，就找到了所希望的目录项。<br> #include <br> #include <br> #include <br> <br> int main(void)<br> {<!-- --><br> char *name;<br> <br> if(isatty(0))<br> {<!-- --><br>     name=ttyname(0);<br>     if(name==NULL)<br>         name=”undefined”;<br>     printf(“fd 0:%s\n”,name);<br> }<br> else<br>     printf(“not a tty\n”);<br> <br> if(isatty(1))<br> {<!-- --><br>     name=ttyname(1);<br>     if(name==NULL)<br>         name=”undefined”);<br>     printf(“fd 1:%s\n”,name);<br> }<br> else<br>     printf(“not a tty\n”);<br> <br> if(isatty(2))<br> {<!-- --><br>     name=ttyname(2);<br>     if(name==NULL)<br>         name=”undefined”);<br>     printf(“not a tty\n”);<br> }<br> else<br>     printf(“not a tty\n”);<br> exit(0);<br> }<br> #./11_3<br> fd 0: /dev/tty1<br> fd 1: /dev/tty1<br> fd 2: /dev/tty1<br> #./11_3 /dev/null<br> fd 0: /dev/console<br> fd1: /dev/tty1<br> not a tty</p> </td></tr></tbody></table> 
</div> 
<h3><a target="_blank" name="_Toc376251283">select()</a>函数以及FD_ZERO、FD_SET、FD_CLR、FD_ISSET</h3> 
<p><span style="color:#454545">select</span><span style="color:#454545">函数用于在非阻塞中，当一个套接字或一组套接字有信号时通知你，系统提供</span><span style="color:#454545">select</span><span style="color:#454545">函数来实现多路复用输入</span><span style="color:#454545">/</span><span style="color:#454545">输出模型，原型：</span><span style="color:#454545"> <br>          #include &lt;sys/time.h&gt; <br>          #include &lt;unistd.h&gt; <br>          int select(int maxfd,fd_set *rdset,fd_set *wrset,fd_set *exset,struct timeval *timeout); <br>      </span><span style="color:#454545">参数</span><span style="color:#454545">maxfd</span><span style="color:#454545">是需要监视的最大的文件描述符值</span><span style="color:#454545">+1</span><span style="color:#454545">；</span><span style="color:#454545">rdset,wrset,exset</span><span style="color:#454545">分别对应于需要检测的可读文件描述符的集合，可写文件描述符的集</span><span style="color:#454545"> </span><span style="color:#454545">合及异常文件描述符的集合。</span><span style="color:#454545">struct timeval</span><span style="color:#454545">结构用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回值为</span><span style="color:#454545">0</span><span style="color:#454545">。</span><span style="color:#454545"> <br>      fd_set</span><span style="color:#454545">（它比较重要所以先介绍一下）是一组文件描述字</span><span style="color:#454545">(fd)</span><span style="color:#454545">的集合，它用一位来表示一个</span><span style="color:#454545">fd</span><span style="color:#454545">（下面会仔细介绍），对于</span><span style="color:#454545">fd_set</span><span style="color:#454545">类型通过下面四个宏来操作：</span><span style="color:#454545"> <br>       FD_ZERO(fd_set *fdset);</span><span style="color:#454545">将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。</span><span style="color:#454545"> <br>       FD_SET(int fd, fd_set *fdset);</span><span style="color:#454545">用于在文件描述符集合中增加一个新的文件描述符。</span><span style="color:#454545"> <br>       FD_CLR(int fd, fd_set *fdset);</span><span style="color:#454545">用于在文件描述符集合中删除一个文件描述符。</span><span style="color:#454545"> <br>       FD_ISSET(int fd, fd_set *fdset);</span><span style="color:#454545">用于测试指定的文件描述符是否在该集合中。</span><span style="color:#454545">         <br>      </span><span style="color:#454545">过去，一个</span><span style="color:#454545">fd_set</span><span style="color:#454545">通常只能包含</span><span style="color:#454545">&lt;32</span><span style="color:#454545">的</span><span style="color:#454545">fd</span><span style="color:#454545">（文件描述字），因为</span><span style="color:#454545">fd_set</span><span style="color:#454545">其实只用了一个</span><span style="color:#454545">32</span><span style="color:#454545">位矢量来表示</span><span style="color:#454545">fd</span><span style="color:#454545">；现在</span><span style="color:#454545">,UNIX</span><span style="color:#454545">系统通常会在头文件</span><span style="color:#454545">&lt;sys/select.h&gt;</span><span style="color:#454545">中定义常量</span><span style="color:#454545">FD_SETSIZE</span><span style="color:#454545">，它是数据类型</span><span style="color:#454545">fd_set</span><span style="color:#454545">的描述字数量，其值通常是</span><span style="color:#454545">1024</span><span style="color:#454545">，这样就能表示</span><span style="color:#454545">&lt;1024</span><span style="color:#454545">的</span><span style="color:#454545">fd</span><span style="color:#454545">。根据</span><span style="color:#454545">fd_set</span><span style="color:#454545">的位矢量实现，我们可以重新理解操作</span><span style="color:#454545">fd_set</span><span style="color:#454545">的四个宏：</span><span style="color:#454545"> <br>      fd_set set;<br>      FD_ZERO(&amp;set);      <br>      FD_SET(0, &amp;set);    <br>      FD_CLR(4, &amp;set);      <br>      FD_ISSET(5, &amp;set);    <br> ―――――――――――――――――――――――――――――――――――――――<br> </span><span style="color:#454545">注意</span><span style="color:#454545">fd</span><span style="color:#454545">的最大值必须</span><span style="color:#454545">&lt;FD_SETSIZE</span><span style="color:#454545">。</span><span style="color:#454545"><br> ―――――――――――――――――――――――――――――――――――――――</span></p> 
<p><span style="color:#454545">     select</span><span style="color:#454545">函数的接口比较简单：</span><span style="color:#454545"><br>      int select(int nfds, fd_set *readset, fd_set *writeset,fd_set* exceptset, struct tim *timeout);</span></p> 
<p><span style="color:#454545">功能：</span><span style="color:#454545"><br>      </span><span style="color:#454545">测试指定的</span><span style="color:#454545">fd</span><span style="color:#454545">可读？可写？有异常条件待处理？</span><span style="color:#454545">      <br> </span><span style="color:#454545">参数：</span></p> 
<p><span style="color:#454545">—— nfds     <br>      </span><span style="color:#454545">需要检查的文件描述字个数（即检查到</span><span style="color:#454545">fd_set</span><span style="color:#454545">的第几位），数值应该比三组</span><span style="color:#454545">fd_set</span><span style="color:#454545">中所含的最大</span><span style="color:#454545">fd</span><span style="color:#454545">值更大，一般设为三组</span><span style="color:#454545">fd_set</span><span style="color:#454545">中所含的最大</span><span style="color:#454545">fd</span><span style="color:#454545">值加</span><span style="color:#454545">1</span><span style="color:#454545">（如在</span><span style="color:#454545">readset,writeset,exceptset</span><span style="color:#454545">中所含最大的</span><span style="color:#454545">fd</span><span style="color:#454545">为</span><span style="color:#454545">5</span><span style="color:#454545">，则</span><span style="color:#454545">nfds=6</span><span style="color:#454545">，因为</span><span style="color:#454545">fd</span><span style="color:#454545">是从</span><span style="color:#454545">0</span><span style="color:#454545">开始的）。设这个值是为提高效率，使函数不必检查</span><span style="color:#454545">fd_set</span><span style="color:#454545">的所有</span><span style="color:#454545">1024</span><span style="color:#454545">位。</span><span style="color:#454545"><br> —— readset    <br>      </span><span style="color:#454545">用来检查可读性的一组文件描述字。</span><span style="color:#454545"><br> —— writeset<br>      </span><span style="color:#454545">用来检查可写性的一组文件描述字。</span><span style="color:#454545"><br> —— exceptset<br>      </span><span style="color:#454545">用来检查是否有异常条件出现的文件描述字。</span><span style="color:#454545">(</span><span style="color:#454545">注：错误不包括在异常条件之内</span><span style="color:#454545">)<br> —— timeout<br>      </span><span style="color:#454545">用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回值为</span><span style="color:#454545">0</span><span style="color:#454545">。</span><span style="color:#454545"> <br>      </span><span style="color:#454545">有三种可能：</span><span style="color:#454545"><br>        1.timeout=NULL</span><span style="color:#454545">（阻塞：</span><span style="color:#454545">select</span><span style="color:#454545">将一直被阻塞，直到某个文件描述符上发生了事件）</span><span style="color:#454545"><br>        2.timeout</span><span style="color:#454545">所指向的结构设为非零时间（等待固定时间：如果在指定的时间段里有事件发生或者时间耗尽，函数均返回）</span><span style="color:#454545"><br>        3.timeout</span><span style="color:#454545">所指向的结构，时间设为</span><span style="color:#454545">0</span><span style="color:#454545">（非阻塞：仅检测描述符集合的状态，然后立即返回，并不等待外部事件的发生）</span></p> 
<p><span style="color:#454545">返回值：</span><span style="color:#454545">      <br>      </span><span style="color:#454545">返回对应位仍然为</span><span style="color:#454545">1</span><span style="color:#454545">的</span><span style="color:#454545">fd</span><span style="color:#454545">的总数。</span></p> 
<p><span style="color:#454545">Remarks</span><span style="color:#454545">：</span><span style="color:#454545"><br>      </span><span style="color:#454545">三组</span><span style="color:#454545">fd_set</span><span style="color:#454545">均将某些</span><span style="color:#454545">fd</span><span style="color:#454545">位置</span><span style="color:#454545">0</span><span style="color:#454545">，只有那些可读，可写以及有异常条件待处理的</span><span style="color:#454545">fd</span><span style="color:#454545">位仍然为</span><span style="color:#454545">1</span><span style="color:#454545">。</span></p> 
<p><span style="color:#454545">举个例子，比如</span><span style="color:#454545">recv(),    </span><span style="color:#454545">在没有数据到来调用它的时候</span><span style="color:#454545">,</span><span style="color:#454545">你的线程将被阻塞</span><span style="color:#454545">,</span><span style="color:#454545">如果数据一直不来</span><span style="color:#454545">,</span><span style="color:#454545">你的线程就要阻塞很久</span><span style="color:#454545">.</span><span style="color:#454545">这样显然不好</span><span style="color:#454545">.    <br> </span><span style="color:#454545">所以采用</span><span style="color:#454545">select</span><span style="color:#454545">来查看套节字是否可读</span><span style="color:#454545">(</span><span style="color:#454545">也就是是否有数据读了</span><span style="color:#454545">)    <br> </span><span style="color:#454545">步骤如下</span><span style="color:#454545">——    <br> socket    s;    <br> .....    <br> fd_set    set;    <br> while(1)    <br> {        <br>        FD_ZERO(&amp;set);//</span><span style="color:#454545">将你的套节字集合清空</span><span style="color:#454545">    <br>        FD_SET(s,    &amp;set);//</span><span style="color:#454545">加入你感兴趣的套节字到集合</span><span style="color:#454545">,</span><span style="color:#454545">这里是一个读数据的套节字</span><span style="color:#454545">s    <br>        select(0,&amp;set,NULL,NULL,NULL);//</span><span style="color:#454545">检查套节字是否可读</span><span style="color:#454545">,    <br>                                                          //</span><span style="color:#454545">很多情况下就是是否有数据</span><span style="color:#454545">(</span><span style="color:#454545">注意</span><span style="color:#454545">,</span><span style="color:#454545">只是说很多情况</span><span style="color:#454545">)    <br>                                                          //</span><span style="color:#454545">这里</span><span style="color:#454545">select</span><span style="color:#454545">是否出错没有写</span><span style="color:#454545">    <br>        if(FD_ISSET(s,    &amp;set)    //</span><span style="color:#454545">检查</span><span style="color:#454545">s</span><span style="color:#454545">是否在这个集合里面</span><span style="color:#454545">,    <br>        {                                    //select</span><span style="color:#454545">将更新这个集合</span><span style="color:#454545">,</span><span style="color:#454545">把其中不可读的套节字去掉</span><span style="color:#454545">    <br>                                            //</span><span style="color:#454545">只保留符合条件的套节字在这个集合里面</span><span style="color:#454545">                           <br>                recv(s,...);    <br>        }    <br>        //do    something    here    <br> } </span></p> 
<p><span style="color:#454545">     </span><span style="color:#454545">理解</span><span style="color:#454545">select</span><span style="color:#454545">模型的关键在于理解</span><span style="color:#454545">fd_set,</span><span style="color:#454545">为说明方便，取</span><span style="color:#454545">fd_set</span><span style="color:#454545">长度为</span><span style="color:#454545">1</span><span style="color:#454545">字节，</span><span style="color:#454545">fd_set</span><span style="color:#454545">中的每一</span><span style="color:#454545">bit</span><span style="color:#454545">可以对应一个文件描述符</span><span style="color:#454545">fd</span><span style="color:#454545">。则</span><span style="color:#454545">1</span><span style="color:#454545">字节长的</span><span style="color:#454545">fd_set</span><span style="color:#454545">最大可以对应</span><span style="color:#454545">8</span><span style="color:#454545">个</span><span style="color:#454545">fd</span><span style="color:#454545">。</span><span style="color:#454545"><br>      </span><span style="color:#454545">（</span><span style="color:#454545">1</span><span style="color:#454545">）执行</span><span style="color:#454545">fd_set set; FD_ZERO(&amp;set);</span><span style="color:#454545">则</span><span style="color:#454545">set</span><span style="color:#454545">用位表示是</span><span style="color:#454545">0000,0000</span><span style="color:#454545">。</span><span style="color:#454545"><br>      </span><span style="color:#454545">（</span><span style="color:#454545">2</span><span style="color:#454545">）若</span><span style="color:#454545">fd</span><span style="color:#454545">＝</span><span style="color:#454545">5,</span><span style="color:#454545">执行</span><span style="color:#454545">FD_SET(fd,&amp;set);</span><span style="color:#454545">后</span><span style="color:#454545">set</span><span style="color:#454545">变为</span><span style="color:#454545">0001,0000(</span><span style="color:#454545">第</span><span style="color:#454545">5</span><span style="color:#454545">位置为</span><span style="color:#454545">1)<br>      </span><span style="color:#454545">（</span><span style="color:#454545">3</span><span style="color:#454545">）若再加入</span><span style="color:#454545">fd</span><span style="color:#454545">＝</span><span style="color:#454545">2</span><span style="color:#454545">，</span><span style="color:#454545">fd=1,</span><span style="color:#454545">则</span><span style="color:#454545">set</span><span style="color:#454545">变为</span><span style="color:#454545">0001,0011<br>      </span><span style="color:#454545">（</span><span style="color:#454545">4</span><span style="color:#454545">）执行</span><span style="color:#454545">select(6,&amp;set,0,0,0)</span><span style="color:#454545">阻塞等待</span><span style="color:#454545"><br>      </span><span style="color:#454545">（</span><span style="color:#454545">5</span><span style="color:#454545">）若</span><span style="color:#454545">fd=1,fd=2</span><span style="color:#454545">上都发生可读事件，则</span><span style="color:#454545">select</span><span style="color:#454545">返回，此时</span><span style="color:#454545">set</span><span style="color:#454545">变为</span><span style="color:#454545">0000,0011</span><span style="color:#454545">。注意：没有事件发生的</span><span style="color:#454545">fd=5</span><span style="color:#454545">被清空。</span><span style="color:#454545"><br>      </span><span style="color:#454545">基于上面的讨论，可以轻松得出</span><span style="color:#454545">select</span><span style="color:#454545">模型的特点：</span><span style="color:#454545"><br>      </span><span style="color:#454545">（</span><span style="color:#454545">1)</span><span style="color:#454545">可监控的文件描述符个数取决与</span><span style="color:#454545">sizeof(fd_set)</span><span style="color:#454545">的值。我这边服务</span><span style="color:#454545"> </span><span style="color:#454545">器上</span><span style="color:#454545">sizeof(fd_set)</span><span style="color:#454545">＝</span><span style="color:#454545">512</span><span style="color:#454545">，每</span><span style="color:#454545">bit</span><span style="color:#454545">表示一个文件描述符，则我服务器上支持的最大文件描述符是</span><span style="color:#454545">512*8=4096</span><span style="color:#454545">。据说可调，另有说虽</span><span style="color:#454545"> </span><span style="color:#454545">然可调，但调整上限受于编译内核时的变量值。本人对调整</span><span style="color:#454545">fd_set</span><span style="color:#454545">的大小不太感兴趣，参考</span><span style="color:#454545"><a target="_blank" href="http://www.cppblog.com/" rel="nofollow noopener noreferrer"><span style="color:#5F9BCD">http://www.cppblog.com</span></a>/CppExplore/archive/2008/03/21/45061.html</span><span style="color:#454545">中的模型</span><span style="color:#454545">2</span><span style="color:#454545">（</span><span style="color:#454545">1</span><span style="color:#454545">）可以有效突破</span><span style="color:#454545">select</span><span style="color:#454545">可监控的文件描述符上限。</span><span style="color:#454545"><br>      </span><span style="color:#454545">（</span><span style="color:#454545">2</span><span style="color:#454545">）将</span><span style="color:#454545">fd</span><span style="color:#454545">加入</span><span style="color:#454545">select</span><span style="color:#454545">监控集的同时，还要再使用一个数据结构</span><span style="color:#454545">array</span><span style="color:#454545">保存放到</span><span style="color:#454545">select</span><span style="color:#454545">监控集中的</span><span style="color:#454545">fd</span><span style="color:#454545">，一是用于再</span><span style="color:#454545">select </span><span style="color:#454545">返回后，</span><span style="color:#454545">array</span><span style="color:#454545">作为源数据和</span><span style="color:#454545">fd_set</span><span style="color:#454545">进行</span><span style="color:#454545">FD_ISSET</span><span style="color:#454545">判断。二是</span><span style="color:#454545">select</span><span style="color:#454545">返回后会把以前加入的但并无事件发生的</span><span style="color:#454545">fd</span><span style="color:#454545">清空，则每次开始</span><span style="color:#454545"> select</span><span style="color:#454545">前都要重新从</span><span style="color:#454545">array</span><span style="color:#454545">取得</span><span style="color:#454545">fd</span><span style="color:#454545">逐一加入（</span><span style="color:#454545">FD_ZERO</span><span style="color:#454545">最先），扫描</span><span style="color:#454545">array</span><span style="color:#454545">的同时取得</span><span style="color:#454545">fd</span><span style="color:#454545">最大值</span><span style="color:#454545">maxfd</span><span style="color:#454545">，用于</span><span style="color:#454545">select</span><span style="color:#454545">的第一个</span><span style="color:#454545"> </span><span style="color:#454545">参数。</span><span style="color:#454545"><br>      </span><span style="color:#454545">（</span><span style="color:#454545">3</span><span style="color:#454545">）可见</span><span style="color:#454545">select</span><span style="color:#454545">模型必须在</span><span style="color:#454545">select</span><span style="color:#454545">前循环</span><span style="color:#454545">array</span><span style="color:#454545">（加</span><span style="color:#454545">fd</span><span style="color:#454545">，取</span><span style="color:#454545">maxfd</span><span style="color:#454545">），</span><span style="color:#454545">select</span><span style="color:#454545">返回后循环</span><span style="color:#454545">array</span><span style="color:#454545">（</span><span style="color:#454545">FD_ISSET</span><span style="color:#454545">判断是否有时间发生）。</span><span style="color:#454545"><br>      </span><span style="color:#454545">下面给一个伪码说明基本</span><span style="color:#454545">select</span><span style="color:#454545">模型的服务器模型：</span><span style="color:#454545"><br> array[slect_len];<br> nSock=0;<br> array[nSock++]=listen_fd;(</span><span style="color:#454545">之前</span><span style="color:#454545">listen port</span><span style="color:#454545">已绑定并</span><span style="color:#454545">listen)<br> maxfd=listen_fd;<br> while{<!-- --><br>     FD_ZERO(&amp;set);<br>     foreach (fd in array) <br>     {<!-- --><br>         fd</span><span style="color:#454545">大于</span><span style="color:#454545">maxfd</span><span style="color:#454545">，则</span><span style="color:#454545">maxfd=fd<br>         FD_SET(fd,&amp;set)<br>     }<br>     res=select(maxfd+1,&amp;set,0,0,0)</span><span style="color:#454545">；</span><span style="color:#454545"><br>     if(FD_ISSET(listen_fd,&amp;set))<br>     {<!-- --><br>         newfd=accept(listen_fd);<br>         array[nsock++]=newfd;<br>              if(--res=0) continue<br>     }<br>     foreach </span><span style="color:#454545">下标</span><span style="color:#454545">1</span><span style="color:#454545">开始</span><span style="color:#454545"> (fd in array) <br>     {<!-- --><br>         if(FD_ISSET(fd,&amp;set))<br>            </span><span style="color:#454545">执行读等相关操作</span><span style="color:#454545"><br>            </span><span style="color:#454545">如果错误或者关闭，则要删除该</span><span style="color:#454545">fd</span><span style="color:#454545">，将</span><span style="color:#454545">array</span><span style="color:#454545">中相应位置和最后一个元素互换就好，</span><span style="color:#454545">nsock</span><span style="color:#454545">减一</span><span style="color:#454545"><br>               if(--res=0) continue<br>     }<br> }<br>      </span><span style="color:#454545">使用</span><span style="color:#454545">select</span><span style="color:#454545">函数的过程一般是：</span><span style="color:#454545"><br>      </span><span style="color:#454545">先调用宏</span><span style="color:#454545">FD_ZERO</span><span style="color:#454545">将指定的</span><span style="color:#454545">fd_set</span><span style="color:#454545">清零，然后调用宏</span><span style="color:#454545">FD_SET</span><span style="color:#454545">将需要测试的</span><span style="color:#454545">fd</span><span style="color:#454545">加入</span><span style="color:#454545">fd_set</span><span style="color:#454545">，接着调用函数</span><span style="color:#454545">select</span><span style="color:#454545">测试</span><span style="color:#454545">fd_set</span><span style="color:#454545">中的所有</span><span style="color:#454545">fd</span><span style="color:#454545">，最后用宏</span><span style="color:#454545">FD_ISSET</span><span style="color:#454545">检查某个</span><span style="color:#454545">fd</span><span style="color:#454545">在函数</span><span style="color:#454545">select</span><span style="color:#454545">调用后，相应位是否仍然为</span><span style="color:#454545">1</span><span style="color:#454545">。</span></p> 
<p><span style="color:#454545">     </span><span style="color:#454545">以下是一个测试单个文件描述字可读性的例子：</span><span style="color:#454545"><br>       int isready(int fd)<br>       {<!-- --><br>           int rc;<br>           fd_set fds;<br>           struct tim tv;     <br>           FD_ZERO(&amp;fds);<br>           FD_SET(fd,&amp;fds);<br>           tv.tv_sec = tv.tv_usec = 0;     <br>           rc = select(fd+1, &amp;fds, NULL, NULL, &amp;tv);<br>           if (rc &lt; 0)    //error<br>           return -1;     <br>           return FD_ISSET(fd,&amp;fds) ? 1 : 0;<br>       }<br>      </span><span style="color:#454545">下面还有一个复杂一些的应用：</span><span style="color:#454545"><br>      //</span><span style="color:#454545">这段代码将指定测试</span><span style="color:#454545">Socket</span><span style="color:#454545">的描述字的可读可写性，因为</span><span style="color:#454545">Socket</span><span style="color:#454545">使用的也是</span><span style="color:#454545">fd<br> uint32 SocketWait(TSocket *s,bool rd,bool wr,uint32 timems)     <br> {<!-- --><br>       fd_set rfds,wfds;<br> #ifdef _WIN32<br>       TIM tv;<br> #else<br>       struct tim tv;<br> #endif     <br>       FD_ZERO(&amp;rfds);<br>       FD_ZERO(&amp;wfds); <br>       if (rd)      //TRUE<br>       FD_SET(*s,&amp;rfds);    //</span><span style="color:#454545">添加要测试的描述字</span><span style="color:#454545"> <br>       if (wr)      //FALSE<br>         FD_SET(*s,&amp;wfds); <br>       tv.tv_sec=timems/1000;      //second<br>       tv.tv_usec=timems%1000;      //ms <br>       for (;;) //</span><span style="color:#454545">如果</span><span style="color:#454545">errno==EINTR</span><span style="color:#454545">，反复测试缓冲区的可读性</span><span style="color:#454545"><br>            switch(select((*s)+1,&amp;rfds,&amp;wfds,NULL,<br>                (timems==TIME_INFINITE?NULL:&amp;tv))) //</span><span style="color:#454545">测试在规定的时间内套接口接收缓冲区中是否有数据可读</span><span style="color:#454545"><br>           {                                               //0</span><span style="color:#454545">－－超时，</span><span style="color:#454545">-1</span><span style="color:#454545">－－出错</span><span style="color:#454545"><br>           case 0:     <br>                return 0; <br>           case (-1):    <br>                if (SocketError()==EINTR)<br>                     break;               <br>                return 0; //</span><span style="color:#454545">有错但不是</span><span style="color:#454545">EINTR <br>            default:<br>                if (FD_ISSET(*s,&amp;rfds)) //</span><span style="color:#454545">如果</span><span style="color:#454545">s</span><span style="color:#454545">是</span><span style="color:#454545">fds</span><span style="color:#454545">中的一员返回非</span><span style="color:#454545">0</span><span style="color:#454545">，否则返回</span><span style="color:#454545">0<br>                     return 1;<br>                if (FD_ISSET(*s,&amp;wfds))<br>                     return 2;<br>                return 0;<br>           };<br> }</span></p> 
<h3><a target="_blank" name="_Toc376251284">ioctl </a>函数</h3> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">本函数影响由fd 参数引用的一个打开的文件。</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">#include&lt;unistd.h&gt;</p> 
<p align="left" style="background:rgb(239,239,239)">int ioctl( int fd, int request, .../* void *arg */ );</p> 
<p align="left" style="background:rgb(239,239,239)">返回0 ：成功    -1 ：出错</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">第三个参数总是一个指针，但指针的类型依赖于request 参数。</p> 
<p align="left" style="background:rgb(239,239,239)">我们可以把和网络相关的请求划分为6 类：</p> 
<p align="left" style="background:rgb(239,239,239)">套接口操作</p> 
<p align="left" style="background:rgb(239,239,239)">文件操作</p> 
<p align="left" style="background:rgb(239,239,239)">接口操作</p> 
<p align="left" style="background:rgb(239,239,239)">ARP 高速缓存操作</p> 
<p align="left" style="background:rgb(239,239,239)">路由表操作</p> 
<p align="left" style="background:rgb(239,239,239)">流系统</p> 
<p align="left" style="background:rgb(239,239,239)">下表列出了网络相关ioctl 请求的request 参数以及arg 地址必须指向的数据类型：</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<table border="0" cellspacing="0" cellpadding="0" width="576"><tbody><tr><td> <p align="center">类别</p> </td><td> <p align="center">Request</p> </td><td> <p align="center">说明</p> </td><td> <p align="center">数据类型</p> </td></tr><tr><td> <p align="left"><strong>套</strong></p> <p align="left"><strong>接</strong></p> <p align="left"><strong>口</strong></p> </td><td> <p align="left">SIOCATMARK</p> <p align="left">SIOCSPGRP</p> <p align="left">SIOCGPGRP</p> </td><td> <p align="left">是否位于带外标记</p> <p align="left">设置套接口的进程ID 或进程组ID</p> <p align="left">获取套接口的进程ID 或进程组ID</p> </td><td> <p align="left">int</p> <p align="left">int</p> <p align="left">int</p> </td></tr><tr><td> <p align="left"> </p> <p align="left"><strong>文</strong></p> <p align="left"><strong> </strong></p> <p align="left"><strong>件</strong></p> <p align="left"> </p> <p align="left"> </p> </td><td> <p align="left">FIONBIN</p> <p align="left">FIOASYNC</p> <p align="left">FIONREAD</p> <p align="left">FIOSETOWN</p> <p align="left">FIOGETOWN</p> <p align="left"> </p> </td><td> <p align="left">设置/ 清除非阻塞I/O 标志</p> <p align="left">设置/ 清除信号驱动异步I/O 标志</p> <p align="left">获取接收缓存区中的字节数</p> <p align="left">设置文件的进程ID 或进程组ID</p> <p align="left">获取文件的进程ID 或进程组ID</p> </td><td> <p align="left">int</p> <p align="left">int</p> <p align="left">int</p> <p align="left">int</p> <p align="left">int</p> </td></tr><tr><td> <p align="left"> </p> <p align="left"> </p> <p align="left"> </p> <p align="left"> </p> <p align="left"><strong>接</strong></p> <p align="left"><strong>口</strong></p> <p align="left"><strong> </strong></p> <p align="left"><strong> </strong></p> <p align="left"><strong> </strong></p> <p align="left"><strong> </strong></p> <p align="left"><strong> </strong></p> <p align="left"><strong> </strong></p> <p align="left"><strong> </strong></p> <p align="left"><strong> </strong></p> <p align="left"><strong> </strong></p> <p align="left"> </p> </td><td> <p align="left">SIOCGIFCONF</p> <p align="left">SIOCSIFADDR</p> <p align="left">SIOCGIFADDR</p> <p align="left">SIOCSIFFLAGS</p> <p align="left">SIOCGIFFLAGS</p> <p align="left">SIOCSIFDSTADDR</p> <p align="left">SIOCGIFDSTADDR</p> <p align="left">SIOCGIFBRDADDR</p> <p align="left">SIOCSIFBRDADDR</p> <p align="left">SIOCGIFNETMASK</p> <p align="left">SIOCSIFNETMASK</p> <p align="left">SIOCGIFMETRIC</p> <p align="left">SIOCSIFMETRIC</p> <p align="left">SIOCGIFMTU</p> <p align="left">SIOCxxx</p> </td><td> <p align="left">获取所有接口的清单</p> <p align="left">设置接口地址</p> <p align="left">获取接口地址</p> <p align="left">设置接口标志</p> <p align="left">获取接口标志</p> <p align="left">设置点到点地址</p> <p align="left">获取点到点地址</p> <p align="left">获取广播地址</p> <p align="left">设置广播地址</p> <p align="left">获取子网掩码</p> <p align="left">设置子网掩码</p> <p align="left">获取接口的测度</p> <p align="left">设置接口的测度</p> <p align="left">获取接口MTU</p> <p align="left">（还有很多取决于系统的实现）</p> </td><td> <p align="left">struct ifconf</p> <p align="left">struct ifreq</p> <p align="left">struct ifreq</p> <p align="left">struct ifreq</p> <p align="left">struct ifreq</p> <p align="left">struct ifreq</p> <p align="left">struct ifreq</p> <p align="left">struct ifreq</p> <p align="left">struct ifreq</p> <p align="left">struct ifreq</p> <p align="left">struct ifreq</p> <p align="left">struct ifreq</p> <p align="left">struct ifreq</p> <p align="left">struct ifreq</p> </td></tr><tr><td> <p align="left"> </p> <p align="left"><strong>ARP</strong></p> </td><td> <p align="left">SIOCSARP</p> <p align="left">SIOCGARP</p> <p align="left">SIOCDARP</p> </td><td> <p align="left">创建/ 修改ARP 表项</p> <p align="left">获取ARP 表项</p> <p align="left">删除ARP 表项</p> </td><td> <p align="left">struct arpreq</p> <p align="left">struct arpreq</p> <p align="left">struct arpreq</p> </td></tr><tr><td> <p align="left"><strong>路</strong></p> <p align="left"><strong>由</strong></p> </td><td> <p align="left">SIOCADDRT</p> <p align="left">SIOCDELRT</p> </td><td> <p align="left">增加路径</p> <p align="left">删除路径</p> </td><td> <p align="left">struct rtentry</p> <p align="left">struct rtentry</p> </td></tr><tr><td> <p align="left"><strong>流</strong></p> </td><td> <p align="left">I_xxx</p> </td><td> <p align="left"> </p> </td><td> <p align="left"> </p> </td></tr></tbody></table> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)"><strong>套接口操作：</strong></p> 
<p align="left" style="background:rgb(239,239,239)">明确用于套接口操作的ioctl 请求有三个, 它们都要求ioctl 的第三个参数是指向某个整数的一个指针。</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">SIOCATMARK:    如果本套接口的的度指针当前位于带外标记，那就通过由第三个参数指向的整数返回一个非0 值；否则返回一个0 值。POSIX 以函数sockatmark 替换本请求。</p> 
<p align="left" style="background:rgb(239,239,239)">SIOCGPGRP ：       通过第三个参数指向的整数返回本套接口的进程ID 或进程组ID ，该ID 指定针对本套接口的SIGIO 或SIGURG 信号的接收进程。本请求和fcntl 的F_GETOWN 命令等效，POSIX 标准化的是fcntl 函数。</p> 
<p align="left" style="background:rgb(239,239,239)">SIOCSPGRP ：     把本套接口的进程ID 或者进程组ID 设置成第三个参数指向的整数，该ID 指定针对本套接口的SIGIO 或SIGURG 信号的接收进程，本请求和fcntl 的F_SETOWN 命令等效，POSIX 标准化的是fcntl 操作。</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)"><strong>文件操作：</strong></p> 
<p align="left" style="background:rgb(239,239,239)">以下5 个请求都要求ioctl 的第三个参数指向一个整数。</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">FIONBIO ：        根据ioctl 的第三个参数指向一个0 或非0 值分别清除或设置本套接口的非阻塞标志。本请求和O_NONBLOCK 文件状态标志等效，而该标志通过fcntl 的F_SETFL 命令清除或设置。</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">FIOASYNC ：      根据iocl 的第三个参数指向一个0 值或非0 值分别清除或设置针对本套接口的信号驱动异步I/O 标志，它决定是否收取针对本套接口的异步I/O 信号（SIGIO ）。本请求和O_ASYNC 文件状态标志等效，而该标志可以通过fcntl 的F_SETFL 命令清除或设置。</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">FIONREAD ：     通过由ioctl 的第三个参数指向的整数返回当前在本套接口接收缓冲区中的字节数。本特性同样适用于文件，管道和终端。</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">FIOSETOWN ：    对于套接口和SIOCSPGRP 等效。</p> 
<p align="left" style="background:rgb(239,239,239)">FIOGETOWN ：    对于套接口和SIOCGPGRP 等效。</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">接口配置：</p> 
<p align="left" style="background:rgb(239,239,239)">得到系统中所有接口由SIOCGIFCONF 请求完成，该请求使用ifconf 结构，ifconf 又使用ifreq</p> 
<p align="left" style="background:rgb(239,239,239)">结构，如下所示：</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">Struct ifconf{<!-- --></p> 
<p align="left" style="background:rgb(239,239,239)">    intifc_len;                // 缓冲区的大小</p> 
<p align="left" style="background:rgb(239,239,239)">    union{<!-- --></p> 
<p align="left" style="background:rgb(239,239,239)">        caddr_tifcu_buf;        // input fromuser-&gt;kernel</p> 
<p align="left" style="background:rgb(239,239,239)">        struct ifreq*ifcu_req;    // return of structures returned</p> 
<p align="left" style="background:rgb(239,239,239)">    }ifc_ifcu;</p> 
<p align="left" style="background:rgb(239,239,239)">};</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">#define  ifc_buf ifc_ifcu.ifcu_buf    //buffer address</p> 
<p align="left" style="background:rgb(239,239,239)">#define  ifc_req ifc_ifcu.ifcu_req    //array of structures returned</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">#define  IFNAMSIZ  16</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">struct ifreq{<!-- --></p> 
<p align="left" style="background:rgb(239,239,239)">    charifr_name[IFNAMSIZ];          // interface name, e.g., “le0”</p> 
<p align="left" style="background:rgb(239,239,239)">    union{<!-- --></p> 
<p align="left" style="background:rgb(239,239,239)">        structsockaddr ifru_addr;</p> 
<p align="left" style="background:rgb(239,239,239)">        structsockaddr ifru_dstaddr;</p> 
<p align="left" style="background:rgb(239,239,239)">        structsockaddr ifru_broadaddr;</p> 
<p align="left" style="background:rgb(239,239,239)">        shortifru_flags;</p> 
<p align="left" style="background:rgb(239,239,239)">        intifru_metric;</p> 
<p align="left" style="background:rgb(239,239,239)">        caddr_tifru_data;</p> 
<p align="left" style="background:rgb(239,239,239)">    }ifr_ifru;</p> 
<p align="left" style="background:rgb(239,239,239)">};</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">#define ifr_addr     ifr_ifru.ifru_addr           // address</p> 
<p align="left" style="background:rgb(239,239,239)">#define ifr_dstaddr   ifr_ifru.ifru_dstaddr        // otner end of p-to-p link</p> 
<p align="left" style="background:rgb(239,239,239)">#define ifr_broadaddrifr_ifru.ifru_broadaddr    // broadcast address</p> 
<p align="left" style="background:rgb(239,239,239)">#define ifr_flags    ifr_ifru.ifru_flags        // flags</p> 
<p align="left" style="background:rgb(239,239,239)">#define ifr_metric   ifr_ifru.ifru_metric      // metric</p> 
<p align="left" style="background:rgb(239,239,239)">#define ifr_data     ifr_ifru.ifru_data        // for use byinterface</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">再调用ioctl 前我们必须先分撇一个缓冲区和一个ifconf 结构，然后才初始化后者。如下图</p> 
<p align="left" style="background:rgb(239,239,239)">展示了一个ifconf 结构的初始化结构，其中缓冲区的大小为1024 ，ioctl 的第三个参数指向</p> 
<p align="left" style="background:rgb(239,239,239)">这样一个ifconf 结构。</p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p align="left">ifc_len</p> </td></tr><tr><td> <p align="left"> Ifc_buf</p> </td></tr></tbody></table> 
<p align="left" style="background:rgb(239,239,239)">1024</p> 
<p align="left" style="background:rgb(239,239,239)">---------------------&gt; 缓存</p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)"> </p> 
<p align="left" style="background:rgb(239,239,239)">假设内核返回2 个ifreq 结构，ioctl 返回时通过同一个ifconf 结构缓冲区填入了那2 个ifreq 结构，ifconf 结构的ifc_len 成员也被更新，以反映存放在缓冲区中的信息量</p> 
<p align="left" style="background:rgb(239,239,239)">一般来讲ioctl在用户程序中的调用是：</p> 
<p align="left" style="background:rgb(239,239,239)"><span style="color:red">ioctl(int fd,int command, (char*)argstruct)</span></p> 
<p align="left" style="background:rgb(239,239,239)">ioctl调用与网络编程有关（本文只讨论这一点），文件描述符fd实际上是由socket()系统调用返回的。<span style="color:red">参数</span><span style="color:red">command</span><span style="color:red">的取值由</span><span style="color:red">/usr/include/linux/sockios.h</span> 所规定。这些command的由于功能的不同，可分为以下几个小类：<br> • 改变路由表 (例如 SIOCADDRT, SIOCDELRT), <br> • 读/更新ARP/RARP 缓存(如：SIOCDARP,SIOCSRARP), <br> • 一般的与网络接口有关的(例如 SIOCGIFNAME, SIOCSIFADDR 等等) <br> 在Gooodies目录下有很多样例程序展示了如何使用ioctl。当你看这些程序时，注意参数argstruct是与参数command相关的。例如，与 路由表相关的ioctl使用rtentry这种结构，rtentry定义在/usr/include/linux/route.h（参见例子 adddefault.c）。与ARP有关的ioctl调用使用arpreq结构，arpreq定义在/usr/include/linux /if_arp.h（参见例子arpread.c）</p> 
<p align="left" style="background:rgb(239,239,239)">与网络接口有关的ioctl调用使用的command参数通常看起来像SIOCxIFyyyy的形式，这里x要 么是S（设定set，写write），要么是G（得到get，读read）。在getifinfo.c程序中就使用了这种形式的command参数来读 IP地址，硬件地址，广播地址和得到与网络接口有关的一些标志（flag）。在这些ioctl调用中，第三个参数是ifreq结构，它在/usr /include/linux/if.h中定义。在某些情况下， ioctrl调用可能会使用到在sockios.h之外的新的定义，例如，WaveLAN无线网络卡会保</p> 
<p> </p> 
<h3><a target="_blank" name="_Toc376251285">（</a>C语言）共用体union的用法举例</h3> 
<p align="right"><span style="color:#999999">分类：</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/jiangnanyouzi/article/category/474283" rel="noopener noreferrer"><span style="color:#336699">程序语言</span></a></span><span style="color:#999999">2008-10-27 15:14</span><span style="color:#999999"> </span><span style="color:#999999">16926</span><span style="color:#999999">人阅读</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/jiangnanyouzi/article/details/3158702#comments" rel="noopener noreferrer"><span style="color:#336699">评论</span></a></span>(8)<span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" title="收藏"><span style="color:#336699">收藏</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/jiangnanyouzi/article/details/3158702#report" title="举报" rel="noopener noreferrer"><span style="color:#336699">举报</span></a></span></p> 
<p align="left"><span style="color:#333333"><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=%e8%af%ad%e8%a8%80" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">语言</span></a></span><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=c" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">c</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=struct" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">struct</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=matrix" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">matrix</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=float" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">float</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=%e7%bc%96%e7%a8%8b" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">编程</span></a></p> 
<p><span style="color:#333333">以前在学校学习C</span>语言的时候一直搞不懂那个共用体union有什么用的。工作之后才发现它的一些妙用，现举例如下：<br> <br> 1. 为了方便看懂代码。<br> <br> 比如说想写一个3 * 3的矩阵，可以这样写：<br> [ <span style="color:#333333">注：下面用红色部分标记的地方是后来添加上去的，谢谢</span><span style="color:#333333">yrqing718</span><span style="color:#333333">的提醒！</span><span style="color:#333333">]</span></p> 
<div style="background:#F8F8F8"> 
 <ol start="1" type="1"><li style="color:rgb(92,92,92)"><strong><span style="color:#006699">struct</span></strong>  Matrix </li><li style="color:#5C5C5C; background:white">{ </li><li style="color:rgb(92,92,92)">    <strong><span style="color:#006699">union</span></strong> </li><li style="color:#5C5C5C; background:white">    { </li><li style="color:#5C5C5C; background:white">        <span style="color:red">struct</span> </li><li style="color:#5C5C5C; background:white">        <span style="color:red">{<!-- --></span> </li><li style="color:#5C5C5C; background:white">            <span style="color:black">float</span><span style="color:black"> </span><span style="color:black"> _f11, _f12, _f13, _f21, _f22, _f23, _f31, _f32, _f33;</span> </li><li style="color:#5C5C5C; background:white">        <span style="color:red">};</span> </li><li style="color:#5C5C5C; background:white">        <span style="color:black">float</span>  f[3][3]; </li><li style="color:rgb(92,92,92)">    }_matrix; </li><li style="color:#5C5C5C; background:white">}; </li><li style="color:rgb(92,92,92)">  </li><li style="color:#5C5C5C; background:white"><strong><span style="color:#006699">struct</span></strong>  Matrix m; </li><li style="color:rgb(92,92,92)"> </li></ol> 
</div> 
<p><span style="color:#333333"><br> </span><span style="color:#333333">这两个东西共同使用相同的空间，所以没有空间浪费，在需要整体用矩阵的时候可以用</span><span style="color:#333333"><br> m._matrix.f </span><span style="color:#333333">（比如说传参，或者是整体赋值等）；需要用其中的几个元素的时候可以用</span><span style="color:#333333">m._matrix._f11</span><span style="color:#333333">那样可以避免用</span><span style="color:#333333">m.f[0][0]</span><span style="color:#333333">（这样不大直观，而且容易出错）。</span><span style="color:#333333"><br> <br> 2. </span><span style="color:#333333">用在强制类型转换上（比强制类型转换更加容易看懂）</span><span style="color:#333333"><br> </span><span style="color:#333333">下面举几个例子：</span><span style="color:#333333"><br> <br> </span><span style="color:#333333">（</span><span style="color:#333333">1</span><span style="color:#333333">）</span><span style="color:#333333">. </span><span style="color:#333333">判断系统用的是</span><span style="color:#333333">bigendian </span><span style="color:#333333">还是</span><span style="color:#333333"> little endian</span><span style="color:#333333">（其定义大家可以到网上查相关资料，此略）</span></p> 
<div style="background:#F8F8F8"> 
 <ol start="1" type="1"><li style="color:rgb(92,92,92)"><span style="color:gray">#define TRUE 1</span> </li><li style="color:#5C5C5C; background:white"><span style="color:gray">#define FALSE 0</span> </li><li style="color:rgb(92,92,92)"><span style="color:gray">#define BOOL int</span> </li><li style="color:rgb(92,92,92)"><span style="color:gray"><br> <br> </span></li><li style="color:#5C5C5C; background:white">  </li><li style="color:rgb(92,92,92)"><span style="color:black">BOOL</span>  isBigEndian() </li><li style="color:#5C5C5C; background:white">{ </li><li style="color:rgb(92,92,92)">    <span style="color:black">int</span>  i = 1;   <span style="color:#008200">/* i = 0x00000001*/</span> </li><li style="color:#5C5C5C; background:white">    <span style="color:black">char</span>  c = *(<span style="color:black">char</span>  *)&amp;i; <span style="color:#008200">/* </span><span style="color:#008200">注意不能写成</span><span style="color:#008200"> char c = (char)i; */</span> </li><li style="color:rgb(92,92,92)">    <strong><span style="color:#006699">return</span></strong>  (<span style="color:black">int</span> )c != i; </li><li style="color:#5C5C5C; background:white">}</li></ol> 
</div> 
<p><span style="color:#333333">如果是</span><span style="color:#333333">littleendian</span><span style="color:#333333">字节序的话，那个</span><span style="color:#333333">i= 1</span><span style="color:#333333">；的内存从小到大依次放的是：</span><span style="color:#333333">0x010x00 0x00 0x00</span><span style="color:#333333">，如是，按照</span><span style="color:#333333">i</span><span style="color:#333333">的起始地址变成按照</span><span style="color:#333333">char*</span><span style="color:#333333">方式（</span><span style="color:#333333">1</span><span style="color:#333333">字节）存取，即得</span><span style="color:#333333">c= 0x01</span><span style="color:#333333">；</span><span style="color:#333333"><br> </span><span style="color:#333333">反之亦然</span><span style="color:#333333"><br> <br> </span><span style="color:#333333">也许看起来不是很清晰，下面来看一下这个：</span></p> 
<div style="background:#F8F8F8"> 
 <ol start="1" type="1"><li style="color:rgb(92,92,92)"><span style="color:black">BOOL</span>  isBigEndian() </li><li style="color:#5C5C5C; background:white">{ </li><li style="color:rgb(92,92,92)">    <strong><span style="color:#006699">union</span></strong> </li><li style="color:#5C5C5C; background:white">    { </li><li style="color:rgb(92,92,92)">        <span style="color:black">int</span>  i; </li><li style="color:#5C5C5C; background:white">        <span style="color:black">char</span>  c; </li><li style="color:rgb(92,92,92)">    }test; </li><li style="color:#5C5C5C; background:white">     </li><li style="color:rgb(92,92,92)">    test.c = 2; </li><li style="color:#5C5C5C; background:white">  </li><li style="color:rgb(92,92,92)">    <strong><span style="color:#006699">return</span></strong>  test.i != 2; </li><li style="color:#5C5C5C; background:white">}</li></ol> 
</div> 
<p><span style="color:#333333">这里用的是</span><span style="color:#333333">union</span><span style="color:#333333">来控制这个共享布局，有个知识点就是</span><span style="color:#333333">union</span><span style="color:#333333">里面的成员</span><span style="color:#333333">c</span><span style="color:#333333">和</span><span style="color:#333333">i</span><span style="color:#333333">都是从低地址开始对齐的。同样可以得到如此结果，而且不用转换，清晰一些。</span><span style="color:#333333"><br> <br> </span><span style="color:#333333">什么，不觉得清晰？？那再看下面的例子：</span><span style="color:#333333"><br> <br> </span><span style="color:#333333">（</span><span style="color:#333333">2</span><span style="color:#333333">）</span><span style="color:#333333">. </span><span style="color:#333333">将</span><span style="color:#333333">littleendian</span><span style="color:#333333">下的</span><span style="color:#333333">longlong</span><span style="color:#333333">类型的值换成</span><span style="color:#333333"> bigendian</span><span style="color:#333333">类型的值。已经知道系统提供了下面的</span><span style="color:#333333">api</span><span style="color:#333333">：</span><span style="color:#333333">longhtonl(long lg);</span><span style="color:#333333">作用是把所有的字节序换成大端字节序。因此得出下面做法：</span></p> 
<div style="background:#F8F8F8"> 
 <ol start="1" type="1"><li style="color:rgb(92,92,92)"><span style="color:black">long</span>  <span style="color:black">long</span>  htonLL(<span style="color:black">long</span>  <span style="color:black">long</span>  lg) </li><li style="color:#5C5C5C; background:white">{ </li><li style="color:rgb(92,92,92)">    <strong><span style="color:#006699">union</span></strong>   </li><li style="color:#5C5C5C; background:white">    { </li><li style="color:rgb(92,92,92)">        <strong><span style="color:#006699">struct</span></strong>   </li><li style="color:#5C5C5C; background:white">        {  </li><li style="color:rgb(92,92,92)">            <span style="color:black">long</span>  low; </li><li style="color:#5C5C5C; background:white">            <span style="color:black">long</span>  high; </li><li style="color:rgb(92,92,92)">        }val_1; </li><li style="color:#5C5C5C; background:white">        <span style="color:black">long</span>  <span style="color:black">long</span>  val_2; </li><li style="color:rgb(92,92,92)">    }val_arg, val_ret; </li><li style="color:rgb(92,92,92)">  </li><li style="color:#5C5C5C; background:white">  </li><li style="color:rgb(92,92,92)">    <strong><span style="color:#006699">if</span></strong> ( isBigEndian() ) </li><li style="color:#5C5C5C; background:white">        <strong><span style="color:#006699">return</span></strong>  lg; </li><li style="color:rgb(92,92,92)">    val_arg.val_2 = lg; </li><li style="color:rgb(92,92,92)">  </li><li style="color:#5C5C5C; background:white">  </li><li style="color:rgb(92,92,92)">    val_ret.val_1.low = htonl( val_arg.val_1.high ); </li><li style="color:#5C5C5C; background:white">    val_ret.val_1.high = htonl( val_arg.val_1.low );     </li><li style="color:rgb(92,92,92)">  </li><li style="color:rgb(92,92,92)">    <strong><span style="color:#006699">return</span></strong>  val_ret.val_2; </li><li style="color:#5C5C5C; background:white">}</li></ol> 
</div> 
<p><span style="color:#333333">只要把内存结构的草图画出来就比较容易明白了。</span><span style="color:#333333"><br> <br> (3).</span><span style="color:#333333">为了理解</span><span style="color:#333333">c++</span><span style="color:#333333">类的布局，再看下面一个例子。有如下类：</span></p> 
<div style="background:#F8F8F8"> 
 <ol start="1" type="1"><li style="color:rgb(92,92,92)"><strong><span style="color:#006699">class</span></strong>  Test </li><li style="color:#5C5C5C; background:white">{ </li><li style="color:rgb(92,92,92)"><strong><span style="color:#006699">public</span></strong> : </li><li style="color:#5C5C5C; background:white">    <span style="color:black">float</span>  getFVal(){ <strong><span style="color:#006699">return</span></strong>  f;} </li><li style="color:rgb(92,92,92)"><strong><span style="color:#006699">private</span></strong> : </li><li style="color:#5C5C5C; background:white">    <span style="color:black">int</span>  i; </li><li style="color:rgb(92,92,92)">    <span style="color:black">char</span>  c; </li><li style="color:#5C5C5C; background:white">    <span style="color:black">float</span>  f; </li><li style="color:rgb(92,92,92)">}; </li><li style="color:rgb(92,92,92)">Test t;</li></ol> 
</div> 
<p style="background:#E7E5DC"><span style="color:#333333"> </span></p> 
<p><span style="color:#333333">不能在类</span><span style="color:#333333">Test</span><span style="color:#333333">中增加代码，给对象中的</span><span style="color:#333333">f</span><span style="color:#333333">赋值</span><span style="color:#333333">7.0f.</span></p> 
<div style="background:#F8F8F8"> 
 <ol start="1" type="1"><li style="color:rgb(92,92,92)"><strong><span style="color:#006699">class</span></strong>  Test_Cpy </li><li style="color:#5C5C5C; background:white">{ </li><li style="color:rgb(92,92,92)"> <strong><span style="color:#006699">public</span></strong> : </li><li style="color:#5C5C5C; background:white">    <span style="color:black">float</span>  getVal(){ <strong><span style="color:#006699">return</span></strong>  f;} </li><li style="color:rgb(92,92,92)">    <span style="color:black">float</span>  setVal(<span style="color:black">float</span>  f){ <strong><span style="color:#006699">this</span></strong> -&gt;f = f;} </li><li style="color:#5C5C5C; background:white"><strong><span style="color:#006699">private</span></strong> : </li><li style="color:rgb(92,92,92)">    <span style="color:black">int</span>  i; </li><li style="color:#5C5C5C; background:white">    <span style="color:black">char</span>  c; </li><li style="color:rgb(92,92,92)">    <span style="color:black">float</span>  f; </li><li style="color:#5C5C5C; background:white">}; </li><li style="color:rgb(92,92,92)">  </li><li style="color:#5C5C5C; background:white">.... </li><li style="color:rgb(92,92,92)">  </li><li style="color:#5C5C5C; background:white"><span style="color:black">int</span>  main() </li><li style="color:rgb(92,92,92)">{ </li><li style="color:#5C5C5C; background:white">    Test t; </li><li style="color:rgb(92,92,92)">    <strong><span style="color:#006699">union</span></strong> </li><li style="color:#5C5C5C; background:white">    { </li><li style="color:rgb(92,92,92)">         Test t1,  </li><li style="color:#5C5C5C; background:white">         Test_Cpy t2; </li><li style="color:rgb(92,92,92)">    }test; </li><li style="color:#5C5C5C; background:white">  </li><li style="color:rgb(92,92,92)">    test.t2.setVal(7.0f); </li><li style="color:#5C5C5C; background:white">    t = test.t1; </li><li style="color:rgb(92,92,92)">    assert( t.getVal() == 7.0f );    </li><li style="color:#5C5C5C; background:white">  </li><li style="color:rgb(92,92,92)">    <strong><span style="color:#006699">return</span></strong>  0; </li><li style="color:#5C5C5C; background:white">}</li></ol> 
</div> 
<p><span style="color:#333333">说明：因为在增加类的成员函数时候，那个类的对象的布局基本不变。因此可以写一个与</span><span style="color:#333333">Test</span><span style="color:#333333">类一样结构的类</span><span style="color:#333333">Test_Cpy</span><span style="color:#333333">，而多了一个成员函数</span><span style="color:#333333">setVal</span><span style="color:#333333">，再用</span><span style="color:#333333">uinon</span><span style="color:#333333">结构对齐，就可以给私有变量赋值了。（这种方法在有虚机类和虚函数机制时可能失灵，故不可移植）至于详细的讨论，网上有，这个例子在实际中没有用途，只是用来考察这个内存布局的使用而已</span><span style="color:#333333">.<br> <br> union</span><span style="color:#333333">在操作系统底层的代码中用的比较多，因为它在内存共赏布局上方便且直观。所以网络编程，协议分析，内核代码上有一些用到</span><span style="color:#333333">union</span><span style="color:#333333">都比较好懂，简化了设计。</span></p> 
<p><span style="color:#333333">功能描述：</span><span style="color:#333333"> </span><span style="color:#333333"><br> </span><span style="color:#333333">获取或者设置与某个套接字关联的选</span><span style="color:#333333">项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时，选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该</span><span style="color:#333333">将层的值指定为</span><span style="color:#333333">SOL_SOCKET</span><span style="color:#333333">。为了操作其它层的选项，控制选项的合适协议号必须给出。例如，为了表示一个选项由</span><span style="color:#333333">TCP</span><span style="color:#333333">协议解析，层应该设定为协议</span><span style="color:#333333">号</span><span style="color:#333333">TCP</span><span style="color:#333333">。</span></p> 
<h3><a target="_blank" name="_Toc376251286"><span style="color:#333333">Linux</span></a><span style="color:#333333">下getsockopt/setsockopt</span>函数说明  </h3> 
<p><span style="color:#333333"><br> </span><span style="color:#333333">用法：</span><span style="color:#333333"> </span><span style="color:#333333"><br> #include &lt;sys/types.h&gt;<br> #include &lt;sys/socket.h&gt;</span></p> 
<p><span style="color:#333333">int getsockopt(int sock,int level, int optname, void *optval, socklen_t *optlen);</span></p> 
<p><span style="color:#333333">int setsockopt(int sock,int level, int optname, const void *optval, socklen_t optlen);</span></p> 
<p><span style="color:#333333">参数：</span><span style="color:#333333">  </span><span style="color:#333333"> </span><span style="color:#333333"><br> sock</span><span style="color:#333333">：将要被设置或者获取选项的套接字。</span><span style="color:#333333"><br> level</span><span style="color:#333333">：选项所在的协议层。</span><span style="color:#333333"><br> optname</span><span style="color:#333333">：需要访问的选项名。</span><span style="color:#333333"><br> optval</span><span style="color:#333333">：对于</span><span style="color:#333333">getsockopt()</span><span style="color:#333333">，指向返回选项值的缓冲。对于</span><span style="color:#333333">setsockopt()</span><span style="color:#333333">，指向包含新选项值的缓冲。</span><span style="color:#333333"><br> optlen</span><span style="color:#333333">：对于</span><span style="color:#333333">getsockopt()</span><span style="color:#333333">，作为入口参数时，选项值的最大长度。作为出口参数时，选项值的实际长度。对于</span><span style="color:#333333">setsockopt()</span><span style="color:#333333">，现选项的长度。</span></p> 
<p><span style="color:#333333">   </span><span style="color:#333333"> </span><span style="color:#333333"><br> </span><span style="color:#333333">返回说明：</span><span style="color:#333333">  </span><span style="color:#333333"> </span><span style="color:#333333"><br> </span><span style="color:#333333">成功执行时，返回</span><span style="color:#333333">0</span><span style="color:#333333">。失败返回</span><span style="color:#333333">-1</span><span style="color:#333333">，</span><span style="color:#333333">errno</span><span style="color:#333333">被设为以下的某个值</span><span style="color:#333333">  </span><span style="color:#333333"> </span><span style="color:#333333"><br> EBADF</span><span style="color:#333333">：</span><span style="color:#333333">sock</span><span style="color:#333333">不是有效的文件描述词</span><span style="color:#333333"><br> EFAULT</span><span style="color:#333333">：</span><span style="color:#333333">optval</span><span style="color:#333333">指向的内存并非有效的进程空间</span><span style="color:#333333"><br> EINVAL</span><span style="color:#333333">：在调用</span><span style="color:#333333">setsockopt()</span><span style="color:#333333">时，</span><span style="color:#333333">optlen</span><span style="color:#333333">无效</span><span style="color:#333333"><br> ENOPROTOOPT</span><span style="color:#333333">：指定的协议层不能识别选项</span><span style="color:#333333"><br> ENOTSOCK</span><span style="color:#333333">：</span><span style="color:#333333">sock</span><span style="color:#333333">描述的不是套接字</span></p> 
<p><span style="color:#333333">level</span><span style="color:#333333">指定控制套接字的层次</span><span style="color:#333333">.</span><span style="color:#333333">可以取三种值</span><span style="color:#333333">:</span><span style="color:#333333"> </span><span style="color:#333333"><br> 1)SOL_SOCKET:</span><span style="color:#333333">通用套接字选项</span><span style="color:#333333">.</span><span style="color:#333333"> </span><span style="color:#333333"><br> 2)IPPROTO_IP:IP</span><span style="color:#333333">选项</span><span style="color:#333333">.</span><span style="color:#333333"> </span><span style="color:#333333"><br> 3)IPPROTO_TCP:TCP</span><span style="color:#333333">选项</span><span style="color:#333333">.</span><span style="color:#333333"><br> optname</span><span style="color:#333333">指定控制的方式</span><span style="color:#333333">(</span><span style="color:#333333">选项的名称</span><span style="color:#333333">),</span><span style="color:#333333">我们下面详细解释　</span></p> 
<p><span style="color:#333333">optval</span><span style="color:#333333">获得或者是设置套接字选项</span><span style="color:#333333">.</span><span style="color:#333333">根据选项名称的数据类型进行转换　</span></p> 
<p><span style="color:#333333"><br> </span><span style="color:#333333">选项名称　　　　　　　　说明　　　　　　　　　　　　　　　　　　数据类型</span><span style="color:#333333"> </span><span style="color:#333333"><br> ========================================================================</span><span style="color:#333333"> </span><span style="color:#333333"><br> </span><span style="color:#333333">SOL_SOCKET</span><span style="color:#333333"> </span><span style="color:#333333"><br> ------------------------------------------------------------------------</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_BROADCAST</span><span style="color:#333333">　　　　　　允许发送广播数据　　　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_DEBUG</span><span style="color:#333333">　　　　　　　　允许调试　　　　　　　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_DONTROUTE</span><span style="color:#333333">　　　　　　不查找路由　　　　　　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_ERROR</span><span style="color:#333333">　　　　　　　　获得套接字错误　　　　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_KEEPALIVE</span><span style="color:#333333">　　　　　　保持连接　　　　　　　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_LINGER</span><span style="color:#333333">延迟关闭连接　　　　　　　　　　　　　　</span><span style="color:#333333">structlinger</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_OOBINLINE</span><span style="color:#333333">　　　　　　带外数据放入正常数据流　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_RCVBUF</span><span style="color:#333333">接收缓冲区大小　　　　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_SNDBUF</span><span style="color:#333333">发送缓冲区大小　　　　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_RCVLOWAT</span><span style="color:#333333">接收缓冲区下限　　　　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_SNDLOWAT</span><span style="color:#333333">发送缓冲区下限　　　　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_RCVTIMEO</span><span style="color:#333333">接收超时　　　　　　　　　　　　　　　　</span><span style="color:#333333">structtimeval</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_SNDTIMEO</span><span style="color:#333333">发送超时　　　　　　　　　　　　　　　　</span><span style="color:#333333">structtimeval</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_REUSERADDR</span><span style="color:#333333">允许重用本地地址和端口　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_TYPE</span><span style="color:#333333">获得套接字类型　　　　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> SO_BSDCOMPAT</span><span style="color:#333333">　　　　　　与</span><span style="color:#333333">BSD</span><span style="color:#333333">系统兼容　　　　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> ========================================================================<br> </span><span style="color:#333333">IPPROTO_IP</span><span style="color:#333333"> </span><span style="color:#333333"><br> ------------------------------------------------------------------------<br> IP_HDRINCL</span><span style="color:#333333">　　　　　　　在数据包中包含</span><span style="color:#333333">IP</span><span style="color:#333333">首部　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> IP_OPTINOS</span><span style="color:#333333">IP</span><span style="color:#333333">首部选项　　　　　　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> IP_TOS</span><span style="color:#333333">　　　　　　　　　服务类型</span><span style="color:#333333"> </span><span style="color:#333333"><br> IP_TTL</span><span style="color:#333333">　　　　　　　　　生存时间　　　　　　　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> ========================================================================<br> </span><span style="color:#333333">IPPRO_TCP</span><span style="color:#333333"> </span><span style="color:#333333"><br> ------------------------------------------------------------------------<br> TCP_MAXSEG</span><span style="color:#333333">TCP</span><span style="color:#333333">最大数据段的大小　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> TCP_NODELAY</span><span style="color:#333333">不使用</span><span style="color:#333333">Nagle</span><span style="color:#333333">算法　　　　　　　　　　　　</span><span style="color:#333333">int</span><span style="color:#333333"> </span><span style="color:#333333"><br> ========================================================================</span></p> 
<p><span style="color:#333333">返回说明：</span><span style="color:#333333">  </span><span style="color:#333333"> </span><span style="color:#333333"><br> </span><span style="color:#333333">成功执行时，返回</span><span style="color:#333333">0</span><span style="color:#333333">。失败返回</span><span style="color:#333333">-1</span><span style="color:#333333">，</span><span style="color:#333333">errno</span><span style="color:#333333">被设为以下的某个值</span><span style="color:#333333">  </span><span style="color:#333333"> </span><span style="color:#333333"><br> EBADF</span><span style="color:#333333">：</span><span style="color:#333333">sock</span><span style="color:#333333">不是有效的文件描述词</span><span style="color:#333333"><br> EFAULT</span><span style="color:#333333">：</span><span style="color:#333333">optval</span><span style="color:#333333">指向的内存并非有效的进程空间</span><span style="color:#333333"><br> EINVAL</span><span style="color:#333333">：在调用</span><span style="color:#333333">setsockopt()</span><span style="color:#333333">时，</span><span style="color:#333333">optlen</span><span style="color:#333333">无效</span><span style="color:#333333"><br> ENOPROTOOPT</span><span style="color:#333333">：指定的协议层不能识别选项</span><span style="color:#333333"><br> ENOTSOCK</span><span style="color:#333333">：</span><span style="color:#333333">sock</span><span style="color:#333333">描述的不是套接字</span></p> 
<p><span style="color:#333333">SO_RCVBUF</span><span style="color:#333333">和</span><span style="color:#333333">SO_SNDBUF</span><span style="color:#333333">每个套接口都有一个发送缓冲区和一个接收缓冲区，使用这两个套接口选项可以改变缺省缓冲区大小。</span></p> 
<p><span style="color:#333333">// </span><span style="color:#333333">接收缓冲区</span><span style="color:#333333"><br> int nRecvBuf=32*1024;         //</span><span style="color:#333333">设置为</span><span style="color:#333333">32K<br> setsockopt(s,SOL_SOCKET,SO_RCVBUF,(const char*)&amp;nRecvBuf,sizeof(int));</span></p> 
<p><span style="color:#333333"><br> //</span><span style="color:#333333">发送缓冲区</span><span style="color:#333333"><br> int nSendBuf=32*1024;//</span><span style="color:#333333">设置为</span><span style="color:#333333">32K<br> setsockopt(s,SOL_SOCKET,SO_SNDBUF,(const char*)&amp;nSendBuf,sizeof(int));</span></p> 
<p><span style="color:#333333">注意：</span></p> 
<p><span style="color:#333333">当设置</span><span style="color:#333333">TCP</span><span style="color:#333333">套接口接收缓冲区的大小时，函数调用顺序是很重要的，因为</span><span style="color:#333333">TCP</span><span style="color:#333333">的窗口规模选项是在建立连接时用</span><span style="color:#333333">SYN</span><span style="color:#333333">与对方互换得到的。对于客户，</span><span style="color:#333333">SO_RCVBUF</span><span style="color:#333333">选项必须在</span><span style="color:#333333">connect</span><span style="color:#333333">之前设置；对于服务器，</span><span style="color:#333333">SO_RCVBUF</span><span style="color:#333333">选项必须在</span><span style="color:#333333">listen</span><span style="color:#333333">前设置。</span></p> 
<h3><a target="_blank" name="_Toc376251287">SVN</a>多版本库配置问题</h3> 
<p align="center">阅读：<span style="color:red">651</span>次   时间：2012-07-3120:41:12   字体：[<span style="color:#0A0064">大</span> <span style="color:#0A0064">中</span> <span style="color:#0A0064">小</span>]</p> 
<p>刚接触SVN的时候，因为对它不了解，又在Windows下面，被它的多版本库配置问题困扰很久，一直找不到完美解决方案，今天无意中在Linux下配置SVN时，发现它本身是支持的，通过配置--config-file参数指定全局的配置文件实现。写下此文来纠正以前错误的配置方式（主要是Windows系统下），分享给大家。</p> 
<p>Linux和Windows下处理基本上一样的，先来看Linux下的svnserve的帮助信息：</p> 
<p align="left">1.       [root@localhost ~]# svnserve --help  </p> 
<p align="left">2.       usage: svnserve [-d | -i | -t | -X] [options]  </p> 
<p align="left">3.         </p> 
<p align="left">4.       Valid options:  </p> 
<p align="left">5.         -d [--daemon]            : daemon mode  </p> 
<p align="left">6.         -i [--inetd]             : inetd mode  </p> 
<p align="left">7.         -t [--tunnel]            : tunnel mode  </p> 
<p align="left">8.         -X [--listen-once]       : listen-once mode (useful for debugging)  </p> 
<p align="left">9.         -r [--root] ARG          : root of directory to serve  </p> 
<p align="left">10.       -R [--read-only]         : force read only, overriding repository config file  </p> 
<p align="left">11.       --config-file ARG        : read configuration from file ARG  </p> 
<p align="left">12.       --listen-port ARG        : listen port  </p> 
<p align="left">13.                                  [mode: daemon, listen-once]  </p> 
<p align="left">14.       --listen-host ARG        : listen hostname or IP address  </p> 
<p align="left">15.                                  [mode: daemon, listen-once]  </p> 
<p align="left">16.       -T [--threads]           : use threads instead of fork [mode: daemon]  </p> 
<p align="left">17.       --foreground             : run in foreground (useful for debugging)  </p> 
<p align="left">18.                                  [mode: daemon]  </p> 
<p align="left">19.       --log-file ARG           : svnserve log file  </p> 
<p align="left">20.       --pid-file ARG           : write server process ID to file ARG  </p> 
<p align="left">21.                                  [mode: daemon, listen-once]  </p> 
<p align="left">22.       --tunnel-user ARG        : tunnel username (default is current uid's name)  </p> 
<p align="left">23.                                  [mode: tunnel]  </p> 
<p align="left">24.       -h [--help]              : display this help  </p> 
<p align="left">25.       --version                : show program version information  </p> 
<p>通常启动SVN服务，仅指定SVN版本库的根目录，如下：</p> 
<p align="left">1.       svnserve -d -r /data/svn  </p> 
<p>然后在/data/svn下创建多个版本库：</p> 
<p align="left">1.       cd /data/svn  </p> 
<p align="left">2.       svnadmin create repos1  </p> 
<p align="left">3.       svnadmin create repos2  </p> 
<p>再依次配置repos1和repos2等版本库下的conf/svnserve.conf、conf/passwd、conf/authz文件。</p> 
<p>问题便来了，因为大多数的时候，同一个用户需要用相同的帐号和密码去访问不同的版本库，这时的权限配置就不好处理了，以前看其他人的解决方法是在svnserve.conf中指定passwd和authz的路径时用相对路径指到同一个文件。这是一个可行的方法，但新增版本库的时候，就得更改svnserve.conf文件，不方便。</p> 
<p>仔细看svnserve的帮助信息，大家都会发现有一个--config-file参数，这个参数就是用来指定svnserve.conf路径的，说到这，问题已经明了，只要在启动SVN服务的时候，指定--config-file参数，只要指定了此参数，所有的权限都由参数指定的svnserve.conf控制，而每个版本库conf目录下的svnserve.conf的配置都会忽略掉。</p> 
<p align="left">1.       svnserve -d -r /data/svn --config-file /data/svn/svnserve.conf  </p> 
<p>Windows下使用的是CollabNet的Subversion Server，它安装的服务，指定的ImagePath形式为："d:Program Files (x86)CollabNetSubversionServersvnserve.exe" --service -r "e:svn_repository"--listen-port "3690" ，是没有指定--config-file参数的，因此导致我等刚接触SVN的新手会被多版本库的配置问题纠结，现在只要到注册表更改一下SVN所在服务的ImagePath参数，追加上--config-file参数：</p> 
<p align="left">1.       "d:Program Files (x86)CollabNetSubversion Serversvnserve.exe" --service -r "e:svn_repository" --listen-port "3690" --config-file "e:svn_repositoryconfsvnserve.conf"  </p> 
<p>以上中使用的路径等，请自行转换成各自对应的路径。</p> 
<h3><a target="_blank" name="_Toc376251288">windows </a>下本机配置svn以及多版本库的创建</h3> 
<p><span style="color:#454545">软件下载</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">服务器和客户端安装</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">建立版本库（</span><span style="color:#454545">Repository</span><span style="color:#454545">）</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">配置用户和权限</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">运行独立服务器</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">初始化导入</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">基本客户端操作</span></p> 
<p><span style="color:#454545">建立多版本库</span><span style="color:#454545"><br> <br> <br> 1</span><span style="color:#454545">、软件下载</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">下载</span><span style="color:#454545">Subversion</span><span style="color:#454545">服务器程序。</span><span style="color:#454545"><br> <br> <br> </span><span style="color:#454545">下载</span><span style="color:#454545">Subversion</span><span style="color:#454545">的</span><span style="color:#454545">Windows</span><span style="color:#454545">客户端</span><span style="color:#454545">TortoiseSVN</span><span style="color:#454545">及简体中文语言安装包。</span><span style="color:#454545"><br> <br> http://tortoisesvn.net/downloads<br> <br> svnservice</span><span style="color:#454545">下载</span><span style="color:#454545"><br> <br> http://bbs.iusesvn.com/attachment.php?aid=12<br> <br> 2</span><span style="color:#454545">、服务器和客户端安装</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">服务器安装，直接运行安装程序，根据提示安装即可，这样我们就有了一套服务器可以运行的环境。</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">安装</span><span style="color:#454545">TortoiseSVN</span><span style="color:#454545">，同样直接运行安装程序，按照提示安装即可，不过最后完成后会提示是否重启，其实重启只是使</span><span style="color:#454545">svn</span><span style="color:#454545">工作拷贝在</span><span style="color:#454545">windows</span><span style="color:#454545">中的特殊样式生效，与所有的实际功能无关，这里为了立刻看到好的效果，还是重新启动机器。</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">重启完毕后安装简体中文语言包</span><span style="color:#454545">,</span><span style="color:#454545">然后在随便一个目录右击</span><span style="color:#454545">,</span><span style="color:#454545">就会发现多出了一些</span><span style="color:#454545">SVN</span><span style="color:#454545">相关菜单</span><span style="color:#454545">, </span><span style="color:#454545">选择其中的</span><span style="color:#454545">TortoiseSVN,</span><span style="color:#454545">再选择子菜单</span><span style="color:#454545">"Settings",</span><span style="color:#454545">设置</span><span style="color:#454545">Language</span><span style="color:#454545">为</span><span style="color:#454545">"</span><span style="color:#454545">中文</span><span style="color:#454545">(</span><span style="color:#454545">简体</span><span style="color:#454545">)"</span><span style="color:#454545">。</span><span style="color:#454545"><br> <br> 3</span><span style="color:#454545">、建立版本库（</span><span style="color:#454545">Repository</span><span style="color:#454545">）</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">运行</span><span style="color:#454545">Subversion</span><span style="color:#454545">服务器需要首先要建立一个版本库（</span><span style="color:#454545">Repository</span><span style="color:#454545">），可以看作服务器上存放数据的数据库，在安装了</span><span style="color:#454545">Subversion</span><span style="color:#454545">服务器之后，可以直接运行，如：</span><span style="color:#454545"><br> <br> svnadmin create F:\svn\repository<br> <br> </span><span style="color:#454545">就会在目录</span><span style="color:#454545">F:\svn\repository</span><span style="color:#454545">下创建一个版本库。</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">我们也可以使用</span><span style="color:#454545">TortoiseSVN</span><span style="color:#454545">图形化的完成这一步：</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">在目录</span><span style="color:#454545">D:\svn\repository</span><span style="color:#454545">下</span><span style="color:#454545">"</span><span style="color:#454545">右键</span><span style="color:#454545">-&gt;TortoiseSVN-&gt;</span><span style="color:#454545">在此创建文件库</span><span style="color:#454545">"</span><span style="color:#454545">，然后可以选择版本库模式，这里使用默认</span><span style="color:#454545">,fsfs</span><span style="color:#454545">方式即可，然后就创建了一系列目录和文件。</span><span style="color:#454545"> </span><span style="color:#454545"><br> <br> 4</span><span style="color:#454545">、配置用户和权限</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">打开</span><span style="color:#454545">F:\svn\repository,</span><span style="color:#454545">你会发现已经多了一些目录和文件</span><span style="color:#454545">,</span><span style="color:#454545">打开</span><span style="color:#454545">conf</span><span style="color:#454545">子目录</span><span style="color:#454545">, </span><span style="color:#454545">打开</span><span style="color:#454545">svnserve.conf</span><span style="color:#454545">文件</span><span style="color:#454545">, </span><span style="color:#454545">这里行前凡是有</span><span style="color:#454545">#</span><span style="color:#454545">的都等于是被注释忽略了</span><span style="color:#454545">, </span><span style="color:#454545">你可以把</span><span style="color:#454545">#</span><span style="color:#454545">去掉让那一行生效</span><span style="color:#454545">, </span><span style="color:#454545">或者自己新添加行</span><span style="color:#454545">. </span> <span style="color:#454545">里面的英文注释已经详细说明了各种设置的含义</span><span style="color:#454545">,</span><span style="color:#454545">最后你设置</span><span style="color:#454545">[general]</span><span style="color:#454545">小节中行前没有</span><span style="color:#454545">#</span><span style="color:#454545">号的内容为</span><span style="color:#454545">:<br> <br> anon-access = none<br> auth-access = write<br> password-db = passwd<br> </span><span style="color:#454545">一定要把空格给删了，否则会出错</span><span style="color:#454545">svnserve.conf:12:Option expected</span></p> 
<p><span style="color:#454545"><br> </span><span style="color:#454545">含义是</span><span style="color:#454545">:<br> <br> </span><span style="color:#454545">未验证用户无任何权限</span><span style="color:#454545">(</span><span style="color:#454545">如果把</span><span style="color:#454545">none</span><span style="color:#454545">修改为</span><span style="color:#454545">read</span><span style="color:#454545">就是给予读权限</span><span style="color:#454545">)<br> </span><span style="color:#454545">已验证用户给予写权限</span><span style="color:#454545">(</span><span style="color:#454545">当然也能读</span><span style="color:#454545">)<br> </span><span style="color:#454545">密码数据存放到</span><span style="color:#454545">passwd</span><span style="color:#454545">文件中</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">然后打开同目录的</span><span style="color:#454545">passwd</span><span style="color:#454545">文件来设置帐户</span><span style="color:#454545">:<br> <br> </span><span style="color:#454545">同样</span><span style="color:#454545">, </span> <span style="color:#454545">设置</span><span style="color:#454545">[users]</span><span style="color:#454545">小节中行前没有</span><span style="color:#454545">#</span><span style="color:#454545">号的内容</span><span style="color:#454545">, </span><span style="color:#454545">例如</span><span style="color:#454545">:</span></p> 
<p><span style="color:#454545">admin =ren<br> <br> </span><span style="color:#454545">含义是</span><span style="color:#454545">:<br> <br> </span><span style="color:#454545">用户</span><span style="color:#454545">admin</span><span style="color:#454545">的密码为</span><span style="color:#454545">ren<br> <br> 5</span><span style="color:#454545">、运行独立服务器</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">安装</span><span style="color:#454545">subversion</span><span style="color:#454545">的</span><span style="color:#454545">bin</span><span style="color:#454545">目录下不知为何没有</span><span style="color:#454545">svnservice.exe</span><span style="color:#454545">，将</span><span style="color:#454545">svnservice.exe</span><span style="color:#454545">放在</span><span style="color:#454545">subversion</span><span style="color:#454545">的</span><span style="color:#454545">bin</span><span style="color:#454545">目录下。</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">在</span><span style="color:#454545">dos</span><span style="color:#454545">控制台状态下</span><span style="color:#454545">cd </span><span style="color:#454545">进入</span><span style="color:#454545">subversion</span><span style="color:#454545">的安装目录的</span><span style="color:#454545">bin</span><span style="color:#454545">目录，</span></p> 
<p><span style="color:#454545">svnservice -install -d-r F:\svn\repository (</span><span style="color:#454545">该操作中可能出现</span><span style="color:#454545">CreateServicefailed - Commandline set: "-d" "-r" "F:\svn\repository"</span><span style="color:#454545">错误，此时执行</span><span style="color:#454545">svnservice-remove</span><span style="color:#454545">命令即可</span><span style="color:#454545">)</span></p> 
<p><span style="color:#454545">sc config svnservicestart= auto</span></p> 
<p><span style="color:#454545">net start svnservice</span></p> 
<p><em><span style="color:#454545">在</span><span style="color:#454545">win7</span><span style="color:#454545">下可能出现如下问题</span></em></p> 
<p><em><span style="color:#454545">OpenSCManagerFAILED 5: Access is denied.</span></em></p> 
<p><span style="color:#454545">怀疑是</span><span style="color:#454545">win7</span><span style="color:#454545">和</span><span style="color:#454545">vista</span><span style="color:#454545">的</span><span style="color:#454545">UAC</span><span style="color:#454545">问题，打开开始菜单，找到命令行的快捷方式，右键，以管理员身份运行，</span></p> 
<p><span style="color:#454545">svnserivce -install -d-r </span><span style="color:#454545">。。。。。。</span></p> 
<p><span style="color:#454545"><br> 6</span><span style="color:#454545">、初始化导入</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">打开</span><span style="color:#454545">"</span><span style="color:#454545">我的电脑</span><span style="color:#454545">",</span><span style="color:#454545">在你需要进行版本控制的目录上右击</span><span style="color:#454545">,</span><span style="color:#454545">选择</span><span style="color:#454545">TortoiseSVN,</span><span style="color:#454545">再选择子菜单</span><span style="color:#454545">"</span><span style="color:#454545">导入</span><span style="color:#454545">...",</span><span style="color:#454545">设置</span><span style="color:#454545">"</span><span style="color:#454545">文件库</span><span style="color:#454545">url"</span><span style="color:#454545">为</span><span style="color:#454545">svn://localhost</span><span style="color:#454545">点确定后就会提示文件正在导入</span><span style="color:#454545">. </span><br> <br> <span style="color:#454545">需要注意的是，这里是</span><span style="color:#454545">svn</span><span style="color:#454545">文件库与</span><span style="color:#454545">svn</span><span style="color:#454545">服务是同一台计算机的情况</span><span style="color:#454545">, </span><span style="color:#454545">所以可用</span><span style="color:#454545">localhost,</span><span style="color:#454545">其它机器如果要访问</span><span style="color:#454545">svn</span><span style="color:#454545">服务</span><span style="color:#454545">, </span><span style="color:#454545">应该用</span><span style="color:#454545">svn://svn</span><span style="color:#454545">服务器的</span><span style="color:#454545">IP</span><span style="color:#454545">地址</span><span style="color:#454545">, </span><span style="color:#454545">例如</span><span style="color:#454545">svn://192.168.1.125<br> <br> 7</span><span style="color:#454545">、基本客户端操作</span><span style="color:#454545"><br> <br> <br> </span><span style="color:#454545">创建一个准备用来存放版本控制工程的目录</span><span style="color:#454545">,</span><span style="color:#454545">例如</span><span style="color:#454545">d:\project,</span><span style="color:#454545">然后在</span><span style="color:#454545">"</span><span style="color:#454545">我的电脑</span><span style="color:#454545">"</span><span style="color:#454545">中右击这个目录</span><span style="color:#454545">, </span><span style="color:#454545">选择</span><span style="color:#454545">"SVN</span><span style="color:#454545">取出</span><span style="color:#454545">...",</span><span style="color:#454545">设置</span><span style="color:#454545">"</span><span style="color:#454545">文件库</span><span style="color:#454545">url"</span><span style="color:#454545">为</span><span style="color:#454545">svn://svn</span><span style="color:#454545">服务器的</span><span style="color:#454545">IP</span><span style="color:#454545">地址</span><span style="color:#454545">, </span><span style="color:#454545">接下来会问你用户名和帐号</span><span style="color:#454545">, </span><span style="color:#454545">你就填写前面搭建服务器端所设置的用户</span><span style="color:#454545">admin</span><span style="color:#454545">密码</span><span style="color:#454545">zhang<br> <br> </span><span style="color:#454545">点确定后就会提示文件正在取出到</span><span style="color:#454545">d:\project<br> <br> </span><span style="color:#454545">至此</span><span style="color:#454545">, SVN</span><span style="color:#454545">客户端配置完成</span><span style="color:#454545">, </span><span style="color:#454545">你会看到</span><span style="color:#454545">d:\project</span><span style="color:#454545">及其下面的文件都被标记了绿色对勾</span><span style="color:#454545"><br> <br> </span><span style="color:#454545">简单日常使用</span><span style="color:#454545">:<br> <br> </span><span style="color:#454545">要取得工程的当前的最新版本</span><span style="color:#454545">,</span><span style="color:#454545">右击</span><span style="color:#454545">d:\project,</span><span style="color:#454545">选择</span><span style="color:#454545">"SVN</span><span style="color:#454545">更新</span><span style="color:#454545">"<br> <br> </span><span style="color:#454545">你更改工程后</span><span style="color:#454545">,</span><span style="color:#454545">要将你的修改更新到</span><span style="color:#454545">SVN,</span><span style="color:#454545">右击</span><span style="color:#454545">d:\project,</span><span style="color:#454545">选择</span><span style="color:#454545">"SVN</span><span style="color:#454545">提交</span><span style="color:#454545">" </span><span style="color:#454545">，谨慎的话请先更新到</span><span style="color:#454545">SVN</span><span style="color:#454545">最新版本后再提交。</span></p> 
<p><span style="color:#454545">8</span><span style="color:#454545">、建立多版本库</span></p> 
<p><span style="color:#454545">svn </span><span style="color:#454545">在一个版本库下管理多个工程，不会为每个工程建一个版本库，这样会导致版本库跳跃，所以有时必须建立多个版本库</span></p> 
<p><span style="color:#454545">svn </span><span style="color:#454545">在一个版本库下管理多个工程会导致版本库跳跃，所以有时必须建立多个版本库</span></p> 
<p><span style="color:#454545">(1)</span><span style="color:#454545">、把所有的版本库的放在一个统一的目录下</span><span style="color:#454545">(</span><span style="color:#454545">如</span><span style="color:#454545">F:\svn)</span><span style="color:#454545">，在此目录下我们要建立两个工程的版本库</span><span style="color:#454545">Respontory1</span><span style="color:#454545">和</span><span style="color:#454545">Respontory2</span><span style="color:#454545">（必须先建好这两个文件夹）。</span></p> 
<p><span style="color:#454545">(2)</span><span style="color:#454545">、创建第一个项目</span><span style="color:#454545">project1</span><span style="color:#454545">版本库，命令：</span><span style="color:#454545">svnadmincreate F\svnroot\Respontory1</span></p> 
<p><span style="color:#454545">(3)</span><span style="color:#454545">、创建第二个项目</span><span style="color:#454545">project2</span><span style="color:#454545">版本库，命令：</span><span style="color:#454545">svnadmincreate F:\svnroot\Respontory2</span><span style="color:#454545">，当然这两步也可以用</span><span style="color:#454545">TortoiseSVN</span><span style="color:#454545">建立</span></p> 
<p><span style="color:#454545">(4)</span><span style="color:#454545">、为了便于管理，将所有版本库的密码和权限设置在同一个文件下面，操作步骤如下：</span></p> 
<p><span style="color:#454545">     A</span><span style="color:#454545">、取出</span><span style="color:#454545">Respontory1</span><span style="color:#454545">下面</span><span style="color:#454545">conf</span><span style="color:#454545">文件夹下的</span><span style="color:#454545">authz</span><span style="color:#454545">和</span><span style="color:#454545">passwd</span><span style="color:#454545">两个文件到</span><span style="color:#454545">svn</span><span style="color:#454545">根目录下面</span></p> 
<p><span style="color:#454545">      B</span><span style="color:#454545">、修改每个版本库目录</span><span style="color:#454545">conf</span><span style="color:#454545">文件夹下面的</span><span style="color:#454545">svnserve.conf</span><span style="color:#454545">文件，</span><span style="color:#454545">将</span></p> 
<p><span style="color:#454545">           # anon-access = read</span><span style="color:#454545">，</span><span style="color:#454545">#auth-access = write</span><span style="color:#454545">，</span><span style="color:#454545">#password-db = passwd</span><span style="color:#454545">，</span><span style="color:#454545">#authz-db = authz</span></p> 
<p><span style="color:#454545">           </span><span style="color:#454545">修改为：</span></p> 
<p><span style="color:#454545">           anon-access = none</span><span style="color:#454545">，</span><span style="color:#454545">auth-access= write</span><span style="color:#454545">，</span><span style="color:#454545">password-db= ../../passwd</span><span style="color:#454545">，</span><span style="color:#454545">authz-db= ../../authz</span></p> 
<p><span style="color:#454545">          (password-db = ../../passwd</span><span style="color:#454545">，</span><span style="color:#454545">authz-db= ../../authz</span><span style="color:#454545">代表相对路径而非绝对路径</span><span style="color:#454545">)</span></p> 
<p><span style="color:#454545">      </span><span style="color:#454545">如果不需要分角色，那么可以不设置</span><span style="color:#454545">authz-db</span></p> 
<p><span style="color:#454545">(5)</span><span style="color:#454545">、</span><span style="color:#454545">dos</span><span style="color:#454545">控制台状态下</span><span style="color:#454545">cd </span><span style="color:#454545">进入</span><span style="color:#454545">subversion</span><span style="color:#454545">的安装目录的</span><span style="color:#454545">bin</span><span style="color:#454545">目录，</span></p> 
<p><span style="color:#454545">svnservice -install -d-r F:\svn\   (</span><span style="color:#454545">该操作中可能出现</span><span style="color:#454545">CreateServicefailed - Commandline set: "-d" "-r" "F:\svn\repository"</span><span style="color:#454545">错误，此时执行</span><span style="color:#454545">svnservice-remove</span><span style="color:#454545">命令即可</span><span style="color:#454545">)</span></p> 
<p><span style="color:#454545">sc config svnservicestart= auto</span></p> 
<p><span style="color:#454545">net start svnservice</span></p> 
<p><span style="color:#454545">到此为止就配置成功了你可以将两个工程导入到这两个版本库中，而且版本号不相互影响。</span></p> 
<h3><a target="_blank" name="_Toc376251289">【C/C++</a>】Linux下使用system()函数一定要谨慎</h3> 
<p><em><strong><span style="color:#AA0000">15</span></strong></em><span style="color:#666666">人收藏此文章</span><span style="color:#666666">,</span><span style="color:#666666"> </span><span style="color:#666666"><a target="_blank" title="添加到收藏夹"><span style="color:#AA0000">我要收藏</span></a></span><span style="color:#666666">发表于</span><span style="color:#666666">1</span><span style="color:#666666">年前</span><span style="color:#666666">(2012-04-15 00:35) , </span><span style="color:#666666">已有</span><strong><span style="color:#AA0000">16021</span></strong><span style="color:#666666">次阅读</span><span style="color:#666666">，共</span><strong><span style="color:#AA0000"><a target="_blank" href="http://my.oschina.net/renhc/blog/53580#comments" rel="nofollow noopener noreferrer"><span style="color:#AA0000">3</span></a></span></strong><span style="color:#666666">个评论</span></p> 
<p><span style="color:#333333">曾经的曾经，被</span><span style="color:#333333">system()</span><span style="color:#333333">函数折磨过，之所以这样，是因为对</span><span style="color:#333333">system()</span><span style="color:#333333">函数了解不够深入。只是简单的知道用这个函数执行一个系统命令，这远远不够，它的返回值、它所执行命令的返回值以及命令执行失败原因如何定位，这才是重点。当初因为这个函数风险较多，故抛弃不用，改用其他的方法。这里先不说我用了什么方法，这里必须要搞懂</span><span style="color:#333333">system()</span><span style="color:#333333">函数，因为还是有很多人用了</span><span style="color:#333333">system()</span><span style="color:#333333">函数，有时你不得不面对它。</span></p> 
<p><span style="color:#333333"> </span></p> 
<p><strong><span style="color:#333333">先来看一下</span><span style="color:#333333">system()</span><span style="color:#333333">函数的简单介绍：</span></strong></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>1</code></p> </td><td> <p><code>#include &lt;stdlib.h&gt;</code></p> </td></tr><tr><td> <p><code>2</code></p> </td><td colspan="2"> <p><code>int</code> <code>system(const</code> <code>char</code> <code>*command);</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333">system() executes a command specified in command bycalling /bin/sh -c command, and returns after the command has been completed.During execution of the command, SIGCHLD will be blocked, and SIGINT andSIGQUIT will be ignored.</span></p> 
<p><span style="color:#333333">system()</span><span style="color:#333333">函数调用</span><span style="color:#333333">/bin/sh</span><span style="color:#333333">来执行参数指定的命令，</span><span style="color:#333333">/bin/sh </span><span style="color:#333333">一般是一个软连接，指向某个具体的</span><span style="color:#333333">shell</span><span style="color:#333333">，比如</span><span style="color:#333333">bash</span><span style="color:#333333">，</span><span style="color:#333333">-c</span><span style="color:#333333">选项是告诉</span><span style="color:#333333">shell</span><span style="color:#333333">从字符串</span><span style="color:#333333">command</span><span style="color:#333333">中读取命令；</span></p> 
<p><span style="color:#333333">在该</span><span style="color:#333333">command</span><span style="color:#333333">执行期间，</span><span style="color:#333333">SIGCHLD</span><span style="color:#333333">是被阻塞的，好比在说：</span><span style="color:#333333">hi</span><span style="color:#333333">，内核，这会不要给我送</span><span style="color:#333333">SIGCHLD</span><span style="color:#333333">信号，等我忙完再说；</span></p> 
<p><span style="color:#333333">在该</span><span style="color:#333333">command</span><span style="color:#333333">执行期间，</span><span style="color:#333333">SIGINT</span><span style="color:#333333">和</span><span style="color:#333333">SIGQUIT</span><span style="color:#333333">是被忽略的，意思是进程收到这两个信号后没有任何动作。</span></p> 
<p><span style="color:#333333"> </span></p> 
<p><strong><span style="color:#333333">再来看一下</span><span style="color:#333333">system()</span><span style="color:#333333">函数返回值：</span></strong></p> 
<p><span style="color:#333333">The value returned is -1 on error (e.g. fork(2) failed), and thereturn status of the command otherwise. This latter return status is in theformat specified in wait(2). Thus, the exit code of the command will beWEXITSTATUS(status). In case /bin/sh could not be executed, the exit statuswill be that of a command that does exit(127).</span></p> 
<p><span style="color:#333333">If the value of command is NULL, system() returns nonzero if theshell is available, and zero if not.</span></p> 
<p><span style="color:#333333">为了更好的理解</span><span style="color:#333333">system()</span><span style="color:#333333">函数返回值，需要了解其执行过程，实际上</span><span style="color:#333333">system()</span><span style="color:#333333">函数执行了三步操作：</span></p> 
<p><span style="color:#333333">1.fork</span><span style="color:#333333">一个子进程；</span></p> 
<p><span style="color:#333333">2.</span><span style="color:#333333">在子进程中调用</span><span style="color:#333333">exec</span><span style="color:#333333">函数去执行</span><span style="color:#333333">command</span><span style="color:#333333">；</span></p> 
<p><span style="color:#333333">3.</span><span style="color:#333333">在父进程中调用</span><span style="color:#333333">wait</span><span style="color:#333333">去等待子进程结束。</span></p> 
<p><span style="color:#333333">对于</span><span style="color:#333333">fork</span><span style="color:#333333">失败，</span><span style="color:#333333">system()</span><span style="color:#333333">函数返回</span><span style="color:#333333">-1</span><span style="color:#333333">。</span></p> 
<p><span style="color:#333333">如果</span><span style="color:#333333">exec</span><span style="color:#333333">执行成功，也即</span><span style="color:#333333">command</span><span style="color:#333333">顺利执行完毕，则返回</span><span style="color:#333333">command</span><span style="color:#333333">通过</span><span style="color:#333333">exit</span><span style="color:#333333">或</span><span style="color:#333333">return</span><span style="color:#333333">返回的值。</span></p> 
<p><span style="color:#333333">（注意，</span><span style="color:#333333">command</span><span style="color:#333333">顺利执行不代表执行成功，比如</span><span style="color:#333333">command</span><span style="color:#333333">：</span><span style="color:#333333">"rm debuglog.txt"</span><span style="color:#333333">，不管文件存不存在该</span><span style="color:#333333">command</span><span style="color:#333333">都顺利执行了）</span></p> 
<p><span style="color:#333333">如果</span><span style="color:#333333">exec</span><span style="color:#333333">执行失败，也即</span><span style="color:#333333">command</span><span style="color:#333333">没有顺利执行，比如被信号中断，或者</span><span style="color:#333333">command</span><span style="color:#333333">命令根本不存在，</span><span style="color:#333333">system()</span><span style="color:#333333">函数返回</span><span style="color:#333333">127.</span></p> 
<p><span style="color:#333333">如果</span><span style="color:#333333">command</span><span style="color:#333333">为</span><span style="color:#333333">NULL</span><span style="color:#333333">，则</span><span style="color:#333333">system()</span><span style="color:#333333">函数返回非</span><span style="color:#333333">0</span><span style="color:#333333">值，一般为</span><span style="color:#333333">1.</span></p> 
<p><span style="color:#333333"> </span></p> 
<p><strong><span style="color:#333333">看一下</span><span style="color:#333333">system()</span><span style="color:#333333">函数的源码</span></strong></p> 
<p><span style="color:#333333">看完这些，我想肯定有人对</span><span style="color:#333333">system()</span><span style="color:#333333">函数返回值还是不清楚，看源码最清楚，下面给出一个</span><span style="color:#333333">system()</span><span style="color:#333333">函数的实现：</span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>01</code></p> </td><td colspan="2"> <p><code>int</code> <code>system(const</code> <code>char</code> <code>* cmdstring)</code></p> </td></tr><tr><td> <p><code>02</code></p> </td><td> <p><code>{<!-- --></code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>03</code></p> </td><td> <p><code>    pid_t pid;</code></p> </td></tr><tr><td> <p><code>04</code></p> </td><td colspan="2"> <p><code>    int</code> <code>status;</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>05</code></p> </td><td> <p> </p> </td></tr><tr><td> <p><code>06</code></p> </td><td colspan="2"> <p><code>if(cmdstring == NULL)</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>07</code></p> </td><td> <p><code>{<!-- --></code></p> </td></tr><tr><td> <p><code>08</code></p> </td><td colspan="2"> <p><code>    return</code> <code>(1);</code> <code>//</code><code>如果cmdstring为空，返回非零值，一般为1</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>09</code></p> </td><td> <p><code>}</code></p> </td></tr><tr><td> <p><code>10</code></p> </td><td> <p> </p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>11</code></p> </td><td colspan="2"> <p><code>if((pid = fork())&lt;0)</code></p> </td></tr><tr><td> <p><code>12</code></p> </td><td> <p><code>{<!-- --></code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>13</code></p> </td><td colspan="2"> <p><code>    status = -1;</code> <code>//fork</code><code>失败，返回-1</code></p> </td></tr><tr><td> <p><code>14</code></p> </td><td> <p><code>}</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>15</code></p> </td><td colspan="2"> <p><code>else</code> <code>if(pid == 0)</code></p> </td></tr><tr><td> <p><code>16</code></p> </td><td> <p><code>{<!-- --></code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>17</code></p> </td><td> <p><code>    execl("/bin/sh",</code> <code>"sh",</code> <code>"-c", cmdstring, (char</code> <code>*)0);</code></p> </td></tr><tr><td> <p><code>18</code></p> </td><td colspan="2"> <p><code>    _exit(127);</code> <code>// exec</code><code>执行失败返回127，注意exec只在失败时才返回现在的进程，成功的话现在的进程就不存在啦~~</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>19</code></p> </td><td> <p><code>}</code></p> </td></tr><tr><td> <p><code>20</code></p> </td><td colspan="2"> <p><code>else</code> <code>//</code><code>父进程</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>21</code></p> </td><td> <p><code>{<!-- --></code></p> </td></tr><tr><td> <p><code>22</code></p> </td><td colspan="2"> <p><code>    while(waitpid(pid, &amp;status, 0) &lt; 0)</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>23</code></p> </td><td> <p><code>    {<!-- --></code></p> </td></tr><tr><td> <p><code>24</code></p> </td><td colspan="2"> <p><code>        if(errno</code> <code>!= EINTR)</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>25</code></p> </td><td> <p><code>        {<!-- --></code></p> </td></tr><tr><td> <p><code>26</code></p> </td><td colspan="2"> <p><code>            status = -1;</code> <code>//</code><code>如果waitpid被信号中断，则返回-1</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>27</code></p> </td><td colspan="2"> <p><code>            break;</code></p> </td></tr><tr><td> <p><code>28</code></p> </td><td> <p><code>        }</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>29</code></p> </td><td colspan="2"> <p><code>    }</code></p> </td></tr><tr><td> <p><code>30</code></p> </td><td> <p><code>}</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>31</code></p> </td><td> <p> </p> </td></tr><tr><td> <p><code>32</code></p> </td><td colspan="2"> <p><code>    return</code> <code>status;</code> <code>//</code><code>如果waitpid成功，则返回子进程的返回状态</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>33</code></p> </td><td> <p><code>}</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333">仔细看完这个</span><span style="color:#333333">system()</span><span style="color:#333333">函数的简单实现，那么该函数的返回值就清晰了吧，那么什么时候</span><span style="color:#333333">system()</span><span style="color:#333333">函数返回</span><span style="color:#333333">0</span><span style="color:#333333">呢？只在</span><span style="color:#333333">command</span><span style="color:#333333">命令返回</span><span style="color:#333333">0</span><span style="color:#333333">时。</span></p> 
<p><span style="color:#333333"> </span></p> 
<p><strong><span style="color:#333333">看一下该怎么监控</span><span style="color:#333333">system()</span><span style="color:#333333">函数执行状态</span></strong></p> 
<p><span style="color:#333333">这里给我出的做法：</span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>01</code></p> </td><td> <p><code>int</code> <code>status;</code></p> </td></tr><tr><td> <p><code>02</code></p> </td><td colspan="2"> <p><code>if(NULL == cmdstring)</code> <code>//</code><code>如果cmdstring为空趁早闪退吧，尽管system()函数也能处理空指针</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>03</code></p> </td><td> <p><code>{<!-- --></code></p> </td></tr><tr><td> <p><code>04</code></p> </td><td colspan="2"> <p><code>    return</code> <code>XXX;</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>05</code></p> </td><td> <p><code>}</code></p> </td></tr><tr><td> <p><code>06</code></p> </td><td colspan="2"> <p><code>status =</code> <code>system(cmdstring);</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>07</code></p> </td><td colspan="2"> <p><code>if(status &lt; 0)</code></p> </td></tr><tr><td> <p><code>08</code></p> </td><td> <p><code>{<!-- --></code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>09</code></p> </td><td colspan="2"> <p><code>    printf("cmd: %s\t error: %s", cmdstring,</code> <code>strerror(errno));</code> <code>// </code><code>这里务必要把errno信息输出或记入Log</code></p> </td></tr><tr><td> <p><code>10</code></p> </td><td> <p><code>    return</code> <code>XXX;</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>11</code></p> </td><td> <p><code>}</code></p> </td></tr><tr><td> <p><code>12</code></p> </td><td> <p> </p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>13</code></p> </td><td colspan="2"> <p><code>if(WIFEXITED(status))</code></p> </td></tr><tr><td> <p><code>14</code></p> </td><td> <p><code>{<!-- --></code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>15</code></p> </td><td colspan="2"> <p><code>    printf("normal termination, exit status = %d\n", WEXITSTATUS(status));</code> <code>//</code><code>取得cmdstring执行结果</code></p> </td></tr><tr><td> <p><code>16</code></p> </td><td> <p><code>}</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>17</code></p> </td><td colspan="2"> <p><code>else</code> <code>if(WIFSIGNALED(status))</code></p> </td></tr><tr><td> <p><code>18</code></p> </td><td> <p><code>{<!-- --></code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>19</code></p> </td><td colspan="2"> <p><code>    printf("abnormal termination,signal number =%d\n", WTERMSIG(status));</code> <code>//</code><code>如果cmdstring被信号中断，取得信号值</code></p> </td></tr><tr><td> <p><code>20</code></p> </td><td> <p><code>}</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>21</code></p> </td><td colspan="2"> <p><code>else</code> <code>if(WIFSTOPPED(status))</code></p> </td></tr><tr><td> <p><code>22</code></p> </td><td> <p><code>{<!-- --></code></p> </td></tr></tbody></table> 
<p><span style="color:#333333"> </span></p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><code>23</code></p> </td><td colspan="2"> <p><code>    printf("process stopped, signal number =%d\n", WSTOPSIG(status));</code> <code>//</code><code>如果cmdstring被信号暂停执行，取得信号值</code></p> </td></tr><tr><td> <p><code>24</code></p> </td><td> <p><code>}</code></p> </td></tr></tbody></table> 
<p><span style="color:#333333">到于取得子进程返回值的相关介绍可以参考另一篇文章：</span><span style="color:#333333"><a target="_blank" href="http://my.oschina.net/renhc/blog/35116" rel="nofollow noopener noreferrer"><span style="color:#4466BB">http://my.oschina.net/renhc/blog/35116</span></a></span></p> 
<p><span style="color:#333333"> </span></p> 
<p><span style="color:#333333">system()</span><span style="color:#333333">函数用起来很容易出错，返回值太多，而且返回值很容易跟</span><span style="color:#333333">command</span><span style="color:#333333">的返回值混淆。这里推荐使用</span><span style="color:#333333">popen()</span><span style="color:#333333">函数替代，关于</span><span style="color:#333333">popen()</span><span style="color:#333333">函数的简单使用也可以通过上面的链接查看。</span></p> 
<p><span style="color:#333333">popen()</span><span style="color:#333333">函数较于</span><span style="color:#333333">system()</span><span style="color:#333333">函数的优势在于使用简单，</span><span style="color:#333333">popen()</span><span style="color:#333333">函数只返回两个值：</span><span style="color:#333333"><br> </span><span style="color:#333333">成功返回子进程的</span><span style="color:#333333">status</span><span style="color:#333333">，使用</span><span style="color:#333333">WIFEXITED</span><span style="color:#333333">相关宏就可以取得</span><span style="color:#333333">command</span><span style="color:#333333">的返回结果；</span><span style="color:#333333"><br> </span><span style="color:#333333">失败返回</span><span style="color:#333333">-1</span><span style="color:#333333">，我们可以使用</span><span style="color:#333333">perro()</span><span style="color:#333333">函数或</span><span style="color:#333333">strerror()</span><span style="color:#333333">函数得到有用的错误信息。</span></p> 
<p><span style="color:#333333">这篇文章只涉及了</span><span style="color:#333333">system()</span><span style="color:#333333">函数的简单使用，还没有谈及</span><span style="color:#333333">SIGCHLD</span><span style="color:#333333">、</span><span style="color:#333333">SIGINT</span><span style="color:#333333">和</span><span style="color:#333333">SIGQUIT</span><span style="color:#333333">对</span><span style="color:#333333">system()</span><span style="color:#333333">函数的影响，事实上，之所以今天写这篇文章，是因为项目中因有人使用了</span><span style="color:#333333">system()</span><span style="color:#333333">函数而造成了很严重的事故。现像是</span><span style="color:#333333">system()</span><span style="color:#333333">函数执行时会产生一个错误：</span><span style="color:#333333">“</span><span style="color:#333333">No child processes</span><span style="color:#333333">”</span><span style="color:#333333">。</span></p> 
<p><span style="color:#333333">关于这个错误的分析，感兴趣的朋友可以看一下：</span><span style="color:#333333"><a target="_blank" href="http://my.oschina.net/renhc/blog/54582" rel="nofollow noopener noreferrer"><span style="color:#4466BB">http://my.oschina.net/renhc/blog/54582</span></a></span></p> 
<p><span style="color:#333333">返回值：</span><span style="color:#333333">若成功调用一次则返回两个值，子进程返回</span><span style="color:#333333">0</span><span style="color:#333333">，</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/8507578.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">父进程</span></a></span><span style="color:#333333">返回子进程</span><span style="color:#333333">ID</span><span style="color:#333333">；否则，出错返</span><strong></strong></p> 
<p> </p> 
<h3><a target="_blank" href="http://baike.baidu.com/link?url=Nt1hW7_sWISsMPDjIM28DrslLZLULqmVQ3lyj_I9-bJun_Va3ABpMMaN2WeCi6pWuMaTC9E2-XNxjJBpInZzma#1" rel="nofollow noopener noreferrer">fork()函数 UNIX</a><a target="_blank" name="_Toc376251290"></a> </h3> 
<h4><a target="_blank" name="_Toc376251291"></a><a target="_blank" name="sub1952900_1_1"></a>头文件：</h4> 
<p><span style="color:#333333">#<strong>include</strong>&lt;unistd.h&gt;</span></p> 
<p><span style="color:#333333">#<strong>include</strong>&lt;sys/types.h&gt;</span></p> 
<h4><a target="_blank" name="_Toc376251292"></a><a target="_blank" name="1_2"></a><a target="_blank" name="sub1952900_1_2"></a>函数原型：</h4> 
<p><em><span style="color:#333333">pid_t fork</span></em><span style="color:#333333">(</span><span style="color:#333333"> </span><strong><span style="color:#333333">void</span></strong><span style="color:#333333">);</span></p> 
<p><span style="color:#333333">（</span><span style="color:#333333">pid_t</span><span style="color:#333333">是一个</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/2076445.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">宏定义</span></a></span><span style="color:#333333">，其实质是</span><span style="color:#333333">int </span><span style="color:#333333">被定义在</span><span style="color:#333333">#<strong>include</strong>&lt;<em>sys/types.h</em>&gt;</span><span style="color:#333333">中）</span></p> 
<p><span style="color:#333333">返回值：</span><span style="color:#333333">若成功调用一次则返回两个值，子进程返回</span><span style="color:#333333">0</span><span style="color:#333333">，</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/8507578.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">父进程</span></a></span><span style="color:#333333">返回子进程</span><span style="color:#333333">ID</span><span style="color:#333333">；否则，出错返回</span><span style="color:#333333">-1</span></p> 
<h4><a target="_blank" name="_Toc376251293"></a><a target="_blank" name="1_3"></a><a target="_blank" name="sub1952900_1_3"></a>函数说明：</h4> 
<p><span style="color:#333333">一个现有进程可以调用</span><span style="color:#333333">fork</span><span style="color:#333333">函数创建一个新进程。由</span><span style="color:#333333">fork</span><span style="color:#333333">创建的新进程被称为子进程（</span><span style="color:#333333">childprocess</span><span style="color:#333333">）。</span><span style="color:#333333">fork</span><span style="color:#333333">函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回</span><span style="color:#333333">0</span><span style="color:#333333">值而</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/8507578.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">父进程</span></a></span><span style="color:#333333">中返回子进程</span><span style="color:#333333">ID</span><span style="color:#333333">。</span></p> 
<p><span style="color:#333333">子进程是</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/8507578.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">父进程</span></a></span><span style="color:#333333">的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/1375172.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">存储空间</span></a></span><span style="color:#333333">的</span><span style="color:#333333">“</span><span style="color:#333333">副本</span><span style="color:#333333">”</span><span style="color:#333333">，这意味着父子进程间不共享这些存储空间。</span></p> 
<p><span style="color:#333333">UNIX</span><span style="color:#333333">将复制</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/8507578.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">父进程</span></a></span><span style="color:#333333">的</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/1507129.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">地址空间</span></a></span><span style="color:#333333">内容给子进程，因此，子进程有了独立的地址空间。在不同的</span><span style="color:#333333">UNIX(Like)</span><span style="color:#333333">系统下，我们无法确定</span><span style="color:#333333">fork</span><span style="color:#333333">之后是子进程先运行还是父进程先运行，这依赖于系统的实现。所以在移植代码的时候我们不应该对此作出任何的假设。</span></p> 
<h4><a target="_blank" name="_Toc376251294"></a><a target="_blank" name="1_4"></a><a target="_blank" name="sub1952900_1_4"></a>为什么fork会返回两次？</h4> 
<p><span style="color:#333333">由于在复制时复制了</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/8507578.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">父进程</span></a></span><span style="color:#333333">的</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/76043.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">堆栈段</span></a></span><span style="color:#333333">，所以两个进程都停留在</span><span style="color:#333333">fork</span><span style="color:#333333">函数中，等待返回。因此</span><span style="color:#333333">fork</span><span style="color:#333333">函数会返回两次，一次是在</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/8507578.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">父进程</span></a></span><span style="color:#333333">中返回，另一次是在子进程中返回，这两次的返回值是不一样的。过程如下图</span></p> 
<p><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/picview/1952900/1952900/0/b853d6fc9db294a1fd037f7d.html" rel="nofollow noopener noreferrer"></a></span></p> 
<p><span style="color:#333333">调用</span><span style="color:#333333">fork</span><span style="color:#333333">之后，数据、</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/93201.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">堆栈</span></a></span><span style="color:#333333">有两份，代码仍然为一份但是这个</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/1315853.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">代码段</span></a></span><span style="color:#333333">成为两个进程的共享代码段都从</span><span style="color:#333333">fork</span><span style="color:#333333">函数中返回，箭头表示各自的执行处。当父子进程有一个想要修改数据或者堆栈时，两个进程真正分裂。</span></p> 
<p><span style="color:#333333">示例代码：</span></p> 
<p><span style="color:#333333">#<strong>include</strong>&lt;<em>sys/types.h</em>&gt; //</span><span style="color:#333333">对于此程序而言此头文件用不到</span></p> 
<p><span style="color:#333333">#<strong>include</strong>&lt;<em>unistd.h</em>&gt;</span></p> 
<p><span style="color:#333333">#<strong>include</strong>&lt;<em>stdio.h</em>&gt;</span></p> 
<p><strong><span style="color:#333333">#include</span></strong><span style="color:#333333">&lt;stdlib.h&gt;</span></p> 
<p><strong><span style="color:#333333">int</span><span style="color:#333333"> </span></strong><span style="color:#333333">main(<strong>int</strong></span><strong><span style="color:#333333"> </span></strong><span style="color:#333333">argc,</span><span style="color:#333333"> </span><strong><span style="color:#333333">char</span><span style="color:#333333"> </span></strong><span style="color:#333333">**argv )</span></p> 
<p><span style="color:#333333">{<!-- --></span></p> 
<p><strong><span style="color:#333333">pid_t</span><span style="color:#333333"> </span></strong><span style="color:#333333">pid= fork();</span></p> 
<p><strong><span style="color:#333333">if</span><span style="color:#333333"> </span></strong><span style="color:#333333">(pid&lt; 0)</span></p> 
<p><span style="color:#333333">{<!-- --></span></p> 
<p><span style="color:#333333">fprintf(stderr, "error!");</span></p> 
<p><span style="color:#333333">}</span></p> 
<p><strong><span style="color:#333333">else</span><span style="color:#333333"> </span><span style="color:#333333">if</span></strong><span style="color:#333333">(0 == pid )</span></p> 
<p><span style="color:#333333">{<!-- --></span></p> 
<p><span style="color:#333333">printf("This is the child process!");</span></p> 
<p><span style="color:#333333">_exit(0);</span></p> 
<p><span style="color:#333333">}</span></p> 
<p><strong><span style="color:#333333">else</span></strong></p> 
<p><strong><span style="color:#333333">{<!-- --></span></strong></p> 
<p><span style="color:#333333">printf("This is the parent process! child process id =%d", pid);</span></p> 
<p><span style="color:#333333">}</span></p> 
<p><span style="color:#333333">//</span><span style="color:#333333">可能需要时候</span><span style="color:#333333">wait</span><span style="color:#333333">或</span><span style="color:#333333">waitpid</span><span style="color:#333333">函数等待子进程的结束并获取结束状态</span></p> 
<p><strong><span style="color:#333333">exit(</span></strong><span style="color:#333333">0);</span></p> 
<p><span style="color:#333333">}</span></p> 
<p><span style="color:#333333">注意！样例代码仅供参考，样例代码存在着父进程在子进程结束前结束的可能性。必要的时候可以使用</span><span style="color:#333333">wait</span><span style="color:#333333">或</span><span style="color:#333333"> waitpid</span><span style="color:#333333">函数让父进程等待子进程的结束并获取子进程的返回状态。</span></p> 
<p><span style="color:#333333">fork()</span><span style="color:#333333">在</span><span style="color:#333333">Linux</span><span style="color:#333333">系统中的返回值是没有</span><span style="color:#333333">NULL</span><span style="color:#333333">的</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">Error Codes</span></p> 
<p><span style="color:#333333">出错返回</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/627766.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">错误信息</span></a></span><span style="color:#333333">如下</span><span style="color:#333333">:</span></p> 
<p><em><span style="color:#333333">EAGAIN</span></em></p> 
<p><span style="color:#333333">达到进程数上限</span><span style="color:#333333">.</span></p> 
<p><em><span style="color:#333333">ENOMEM</span></em></p> 
<p><span style="color:#333333">没有足够空间给一个新进程分配</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">fork</span><span style="color:#333333">函数的特点概括起来就是</span><span style="color:#333333">“</span><span style="color:#333333">调用一次，返回两次</span><span style="color:#333333">”</span><span style="color:#333333">，在</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/8507578.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">父进程</span></a></span><span style="color:#333333">中调用一次，在父进程和子进程中各返回一次。</span></p> 
<p><span style="color:#333333">fork</span><span style="color:#333333">的另一个特性是所有由</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/8507578.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">父进程</span></a></span><span style="color:#333333">打开的描述符都被复制到子进程中。父、子进程中相同编号的</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/1303430.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件描述符</span></a></span><span style="color:#333333">在</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/1366.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">内核</span></a></span><span style="color:#333333">中指向同一个</span><span style="color:#333333">file<a target="_blank" href="http://baike.baidu.com/view/204974.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">结构体</span></a></span><span style="color:#333333">，也就是说，</span><span style="color:#333333">file</span><span style="color:#333333">结构体的</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/4163962.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">引用计数</span></a></span><span style="color:#333333">要增加。</span></p> 
<h3><a target="_blank" href="http://blog.csdn.net/zdwzzu2006/article/details/7747977" rel="noopener noreferrer">Linux下/proc目录简介</a><a target="_blank" name="_Toc376251295"></a></h3> 
<p align="right"><span style="color:#999999">分类：</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/zdwzzu2006/article/category/457019" rel="noopener noreferrer"><span style="color:#336699">Java</span></a></span><span style="color:#999999">2012-07-1502:22</span><span style="color:#999999"> </span><span style="color:#999999">7896</span><span style="color:#999999">人阅读</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/zdwzzu2006/article/details/7747977#comments" rel="noopener noreferrer"><span style="color:#336699">评论</span></a></span>(0)<span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" title="收藏"><span style="color:#336699">收藏</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/zdwzzu2006/article/details/7747977#report" title="举报" rel="noopener noreferrer"><span style="color:#336699">举报</span></a></span></p> 
<p align="left"><span style="color:#333333"><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=linux" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">linux</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=linux%e5%86%85%e6%a0%b8" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">linux</span><span style="color:#336699; background:#EEEEEE">内核</span></a></span><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=filesystems" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">filesystems</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=protocols" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">protocols</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=cache" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">cache</span></a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=timer" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">timer</span></a></p> 
<p><span style="color:#555555">1. /proc</span><span style="color:#555555">目录</span><span style="color:#555555"><br> Linux </span><span style="color:#555555">内核提供了一种通过</span><span style="color:#555555"> /proc </span><span style="color:#555555">文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。</span><span style="color:#555555">proc</span><span style="color:#555555">文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。</span></p> 
<p><span style="color:#555555">用户和应用程序可以通过</span><span style="color:#555555">proc</span><span style="color:#555555">得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取</span><span style="color:#555555">proc</span><span style="color:#555555">文件时，</span><span style="color:#555555">proc</span><span style="color:#555555">文件系统是动态从系统内核读出所需信息并提交的。下面列出的这些文件或子文件夹，并不是都是在你的系统中存在，这取决于你的内核配置和装载的模块。另外，在</span><span style="color:#555555">/proc</span><span style="color:#555555">下还有三个很重要的目录：</span><span style="color:#555555">net</span><span style="color:#555555">，</span><span style="color:#555555">scsi</span><span style="color:#555555">和</span><span style="color:#555555">sys</span><span style="color:#555555">。</span><span style="color:#555555"> Sys</span><span style="color:#555555">目录是可写的，可以通过它来访问或修改内核的参数，而</span><span style="color:#555555">net</span><span style="color:#555555">和</span><span style="color:#555555">scsi</span><span style="color:#555555">则依赖于内核配置。例如，如果系统不支持</span><span style="color:#555555">scsi</span><span style="color:#555555">，则</span><span style="color:#555555">scsi </span><span style="color:#555555">目录不存在。</span></p> 
<p><span style="color:#555555">除了以上介绍的这些，还有的是一些以数字命名的目录，它们是进程目录。系统中当前运行的每一个进程都有对应的一个目录在</span><span style="color:#555555">/proc</span><span style="color:#555555">下，以进程的</span><span style="color:#555555"> PID</span><span style="color:#555555">号为目录名，它们是读取进程信息的接口。而</span><span style="color:#555555">self</span><span style="color:#555555">目录则是读取进程本身的信息接口，是一个</span><span style="color:#555555">link</span><span style="color:#555555">。</span></p> 
<p><span style="color:#555555">2. </span><span style="color:#555555">子文件或子文件夹</span><span style="color:#555555"><br> /proc/buddyinfo </span><span style="color:#555555">每个内存区中的每个</span><span style="color:#555555">order</span><span style="color:#555555">有多少块可用，和内存碎片问题有关</span></p> 
<p><span style="color:#555555">/proc/cmdline </span><span style="color:#555555">启动时传递给</span><span style="color:#555555">kernel</span><span style="color:#555555">的参数信息</span></p> 
<p><span style="color:#555555">/proc/cpuinfo cpu</span><span style="color:#555555">的信息</span></p> 
<p><span style="color:#555555">/proc/crypto </span><span style="color:#555555">内核使用的所有已安装的加密密码及细节</span></p> 
<p><span style="color:#555555">/proc/devices </span><span style="color:#555555">已经加载的设备并分类</span></p> 
<p><span style="color:#555555"><br> /proc/dma </span><span style="color:#555555">已注册使用的</span><span style="color:#555555">ISA DMA</span><span style="color:#555555">频道列表</span></p> 
<p><span style="color:#555555">/proc/execdomains Linux</span><span style="color:#555555">内核当前支持的</span><span style="color:#555555">execution domains</span></p> 
<p><span style="color:#555555">/proc/fb </span><span style="color:#555555">帧缓冲设备列表，包括数量和控制它的驱动</span></p> 
<p><span style="color:#555555">/proc/filesystems </span><span style="color:#555555">内核当前支持的文件系统类型</span></p> 
<p><span style="color:#555555">/proc/interrupts x86</span><span style="color:#555555">架构中的每个</span><span style="color:#555555">IRQ</span><span style="color:#555555">中断数</span></p> 
<p><span style="color:#555555">/proc/iomem </span><span style="color:#555555">每个物理设备当前在系统内存中的映射</span></p> 
<p><span style="color:#555555">/proc/ioports </span><span style="color:#555555">一个设备的输入输出所使用的注册端口范围</span></p> 
<p><span style="color:#555555">/proc/kcore </span><span style="color:#555555">代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于</span><span style="color:#555555">RAM</span><span style="color:#555555">大小加上</span><span style="color:#555555">4kb</span></p> 
<p><span style="color:#555555">/proc/kmsg </span><span style="color:#555555">记录内核生成的信息，可以通过</span><span style="color:#555555">/sbin/klogd</span><span style="color:#555555">或</span><span style="color:#555555">/bin/dmesg</span><span style="color:#555555">来处理</span></p> 
<p><span style="color:#555555">/proc/loadavg </span><span style="color:#555555">根据过去一段时间内</span><span style="color:#555555">CPU</span><span style="color:#555555">和</span><span style="color:#555555">IO</span><span style="color:#555555">的状态得出的负载状态，与</span><span style="color:#555555">uptime</span><span style="color:#555555">命令有关</span></p> 
<p><span style="color:#555555">/proc/locks </span><span style="color:#555555">内核锁住的文件列表</span></p> 
<p><span style="color:#555555">/proc/mdstat </span><span style="color:#555555">多硬盘，</span><span style="color:#555555">RAID</span><span style="color:#555555">配置信息</span><span style="color:#555555">(md=multipledisks)</span></p> 
<p><span style="color:#555555">/proc/meminfo RAM</span><span style="color:#555555">使用的相关信息</span></p> 
<p><span style="color:#555555">/proc/misc </span><span style="color:#555555">其他的主要设备</span><span style="color:#555555">(</span><span style="color:#555555">设备号为</span><span style="color:#555555">10)</span><span style="color:#555555">上注册的驱动</span></p> 
<p><span style="color:#555555">/proc/modules </span><span style="color:#555555">所有加载到内核的模块列表</span></p> 
<p><span style="color:#555555">/proc/mounts </span><span style="color:#555555">系统中使用的所有挂载</span></p> 
<p><span style="color:#555555">/proc/mtrr </span><span style="color:#555555">系统使用的</span><span style="color:#555555">Memory Type Range Registers (MTRRs)</span></p> 
<p><span style="color:#555555">/proc/partitions </span><span style="color:#555555">分区中的块分配信息</span></p> 
<p><span style="color:#555555">/proc/pci </span><span style="color:#555555">系统中的</span><span style="color:#555555">PCI</span><span style="color:#555555">设备列表</span></p> 
<p><span style="color:#555555">/proc/slabinfo </span><span style="color:#555555">系统中所有活动的</span><span style="color:#555555"> slab </span><span style="color:#555555">缓存信息</span></p> 
<p><span style="color:#555555">/proc/stat </span><span style="color:#555555">所有的</span><span style="color:#555555">CPU</span><span style="color:#555555">活动信息</span></p> 
<p><span style="color:#555555">/proc/sysrq-trigger </span><span style="color:#555555">使用</span><span style="color:#555555">echo</span><span style="color:#555555">命令来写这个文件的时候，远程</span><span style="color:#555555">root</span><span style="color:#555555">用户可以执行大多数的系统请求关键命令，就好像在本地终端执行一样。要写入这个文件，需要把</span><span style="color:#555555">/proc/sys/kernel/sysrq</span><span style="color:#555555">不能设置为</span><span style="color:#555555">0</span><span style="color:#555555">。这个文件对</span><span style="color:#555555">root</span><span style="color:#555555">也是不可读的</span></p> 
<p><span style="color:#555555">/proc/uptime </span><span style="color:#555555">系统已经运行了多久</span></p> 
<p><span style="color:#555555">/proc/swaps </span><span style="color:#555555">交换空间的使用情况</span></p> 
<p><span style="color:#555555">/proc/version Linux</span><span style="color:#555555">内核版本和</span><span style="color:#555555">gcc</span><span style="color:#555555">版本</span></p> 
<p><span style="color:#555555">/proc/bus </span><span style="color:#555555">系统总线</span><span style="color:#555555">(Bus)</span><span style="color:#555555">信息，例如</span><span style="color:#555555">pci/usb</span><span style="color:#555555">等</span></p> 
<p><span style="color:#555555">/proc/driver </span><span style="color:#555555">驱动信息</span></p> 
<p><span style="color:#555555">/proc/fs </span><span style="color:#555555">文件系统信息</span></p> 
<p><span style="color:#555555">/proc/ide ide</span><span style="color:#555555">设备信息</span></p> 
<p><span style="color:#555555">/proc/irq </span><span style="color:#555555">中断请求设备信息</span></p> 
<p><span style="color:#555555">/proc/net </span><span style="color:#555555">网卡设备信息</span></p> 
<p><span style="color:#555555">/proc/scsi scsi</span><span style="color:#555555">设备信息</span></p> 
<p><span style="color:#555555">/proc/tty tty</span><span style="color:#555555">设备信息</span></p> 
<p><span style="color:#555555">/proc/net/dev </span><span style="color:#555555">显示网络适配器及统计信息</span></p> 
<p><span style="color:#555555">/proc/vmstat </span><span style="color:#555555">虚拟内存统计信息</span></p> 
<p><span style="color:#555555">/proc/vmcore </span><span style="color:#555555">内核</span><span style="color:#555555">panic</span><span style="color:#555555">时的内存映像</span></p> 
<p><span style="color:#555555">/proc/diskstats </span><span style="color:#555555">取得磁盘信息</span></p> 
<p><span style="color:#555555">/proc/schedstat kernel</span><span style="color:#555555">调度器的统计信息</span></p> 
<p><span style="color:#555555">/proc/zoneinfo </span><span style="color:#555555">显示内存空间的统计信息，对分析虚拟内存行为很有用</span></p> 
<p><span style="color:#555555">以下是</span><span style="color:#555555">/proc</span><span style="color:#555555">目录中进程</span><span style="color:#555555">N</span><span style="color:#555555">的信息</span></p> 
<p><span style="color:#555555">/proc/N pid</span><span style="color:#555555">为</span><span style="color:#555555">N</span><span style="color:#555555">的进程信息</span></p> 
<p><span style="color:#555555">/proc/N/cmdline </span><span style="color:#555555">进程启动命令</span></p> 
<p><span style="color:#555555">/proc/N/cwd </span><span style="color:#555555">链接到进程当前工作目录</span></p> 
<p><span style="color:#555555">/proc/N/environ </span><span style="color:#555555">进程环境变量列表</span></p> 
<p><span style="color:#555555">/proc/N/exe </span><span style="color:#555555">链接到进程的执行命令文件</span></p> 
<p><span style="color:#555555">/proc/N/fd </span><span style="color:#555555">包含进程相关的所有的文件描述符</span></p> 
<p><span style="color:#555555">/proc/N/maps </span><span style="color:#555555">与进程相关的内存映射信息</span></p> 
<p><span style="color:#555555">/proc/N/mem </span><span style="color:#555555">指代进程持有的内存，不可读</span></p> 
<p><span style="color:#555555">/proc/N/root </span><span style="color:#555555">链接到进程的根目录</span></p> 
<p><span style="color:#555555">/proc/N/stat </span><span style="color:#555555">进程的状态</span></p> 
<p><span style="color:#555555">/proc/N/statm </span><span style="color:#555555">进程使用的内存的状态</span></p> 
<p><span style="color:#555555">/proc/N/status </span><span style="color:#555555">进程状态信息，比</span><span style="color:#555555">stat/statm</span><span style="color:#555555">更具可读性</span></p> 
<p><span style="color:#555555">/proc/self </span><span style="color:#555555">链接到当前正在运行的进程</span></p> 
<p><span style="color:#555555">3. </span><span style="color:#555555">例子</span><span style="color:#555555"><br> 3.1 /proc/<br> <a target="_blank" href="mailto:yafang@QA:~%24" rel="nofollow noopener noreferrer"><span style="color:#015F91">yafang@QA:~$</span></a> ls/proc/</span></p> 
<p><span style="color:#555555">1      16819  21242 2180   2494 8768        interrupts    partitions</span></p> 
<p><span style="color:#555555">116    16820  21244 2181   2524 885         iomem         sched_debug</span></p> 
<p><span style="color:#555555">11740  17901  21245  21810  2525 acpi        ioports       scsi</span></p> 
<p><span style="color:#555555">11742  17903  21247  21812 3     asound      irq           self</span></p> 
<p><span style="color:#555555">11743  17904  2131   21813 39    buddyinfo   kallsyms      slabinfo</span></p> 
<p><span style="color:#555555">13452  18362  21319  21923 4    bus         kcore         stat</span></p> 
<p><span style="color:#555555">13454  18364  2132   2193  41    cgroups     key-users     swaps</span></p> 
<p><span style="color:#555555">13455  18365  2139   21933 42    cmdline      kmsg         sys</span></p> 
<p><span style="color:#555555">149    19451  2142  2209   5    cpuinfo      kpagecount   sysrq-trigger</span></p> 
<p><span style="color:#555555">150    19453  21572 2212   5330  crypto      kpageflags    sysvipc</span></p> 
<p><span style="color:#555555">151    19454  21574 2219   596   devices     loadavg       timer_list</span></p> 
<p><span style="color:#555555">152    2     21575  2243   597   diskstats   locks         timer_stats</span></p> 
<p><span style="color:#555555">15771  2083   2158  2260   6    dma         meminfo       tty</span></p> 
<p><span style="color:#555555">15773  2092   21625  2261  617   driver      misc          uptime</span></p> 
<p><span style="color:#555555">15774  2101   21627  2262  619   execdomains  modules      version</span></p> 
<p><span style="color:#555555">16232  21112  21628  2263  7    fb          mounts        vmallocinfo</span></p> 
<p><span style="color:#555555">16234  21115  2165   2264  804   filesystems mtrr          vmstat</span></p> 
<p><span style="color:#555555">16235  21116  2167   2265  8765  fs          net           zoneinfo</span></p> 
<p><span style="color:#555555">16811  2112   2177  2338   8767 ide          pagetypeinfo</span></p> 
<p><span style="color:#555555">3.2 /proc/sys<br> </span><span style="color:#555555">系统信息和内核参数</span></p> 
<p><span style="color:#555555"><a target="_blank" href="mailto:yafang@QA:~%24" rel="nofollow noopener noreferrer"><span style="color:#015F91">yafang@QA:~$</span></a> ls/proc/sys</span></p> 
<p><span style="color:#555555">debug  dev  fs  kernel  net  vm</span></p> 
<p><span style="color:#555555">3.3 /proc/net<br> </span><span style="color:#555555">网卡设备信息</span></p> 
<p><span style="color:#555555"><a target="_blank" href="mailto:yafang@QA:~%24" rel="nofollow noopener noreferrer"><span style="color:#015F91">yafang@QA:~$</span></a> ls/proc/net</span></p> 
<p><span style="color:#555555">anycast6   ip6_flowlabel  netfilter raw6       sockstat6    udplite</span></p> 
<p><span style="color:#555555">arp       ip6_mr_cache   netlink   route      softnet_stat  udplite6</span></p> 
<p><span style="color:#555555">dev       ip6_mr_vif     netstat    rt6_stats stat          unix</span></p> 
<p><span style="color:#555555">dev_mcast  ip_mr_cache   packet     rt_acct   tcp           vlan</span></p> 
<p><span style="color:#555555">dev_snmp6  ip_mr_vif     protocols  rt_cache  tcp6          wireless</span></p> 
<p><span style="color:#555555">if_inet6   ipv6_route    psched     snmp       tr_rif</span></p> 
<p><span style="color:#555555">igmp      mcfilter      ptype      snmp6      udp</span></p> 
<p><span style="color:#555555">igmp6     mcfilter6     raw        sockstat   udp6</span></p> 
<p><span style="color:#555555">3.4 /proc/scsi<br> SCSI</span><span style="color:#555555">设备信息</span></p> 
<p><span style="color:#555555"><a target="_blank" href="mailto:yafang@QA:~%24" rel="nofollow noopener noreferrer"><span style="color:#015F91">yafang@QA:~$</span></a> ls/proc/scsi</span></p> 
<p><span style="color:#555555">device_info  scsi</span></p> 
<p><span style="color:#555555">3.5 /proc/modules <br> </span><span style="color:#555555">所有加载到内核的模块列表</span></p> 
<p><span style="color:#555555"><a target="_blank" href="mailto:root@BDSP-A-2-1-2" rel="nofollow noopener noreferrer"><span style="color:#015F91">root@BDSP-A-2-1-2</span></a>:~# cat /proc/modules</span></p> 
<p><span style="color:#555555">bdspboard 8486 2 dspcontrol, Live 0xe134c000</span></p> 
<p><span style="color:#555555">dspcontrol 9575 1 clkmon, Live 0xe135b000</span></p> 
<p><span style="color:#555555">clkmon 6765 1 - Live 0xe136c000</span></p> 
<p><span style="color:#555555">diagint 6635 1 - Live 0xe1379000</span></p> 
<p><span style="color:#555555">bdsprio 10775 2 srioif,tsi577, Live 0xe9389000</span></p> 
<p><span style="color:#555555">tsi577 17998 1 srioif, Live 0xe939e000</span></p> 
<p><span style="color:#555555">srioif 7329 0 - Live 0xe93b2000</span></p> 
<p><span style="color:#555555">linux_kernel_bde 54666 1 linux_user_bde, Live 0xf1417000(P)</span></p> 
<p><span style="color:#555555">linux_user_bde 17849 0 - Live 0xf1427000 (P)</span></p> 
<p><span style="color:#555555"><a target="_blank" href="mailto:root@BDSP-A-2-1-2" rel="nofollow noopener noreferrer"><span style="color:#015F91">root@BDSP-A-2-1-2</span></a>:~#</span></p> 
<p><span style="color:#555555">3.6 /proc/devices <br> </span><span style="color:#555555">已经加载的设备并分类</span></p> 
<p><span style="color:#555555"><a target="_blank" href="mailto:root@BCNMB-A" rel="nofollow noopener noreferrer"><span style="color:#015F91">root@BCNMB-A</span></a>:~#cat /proc/devices</span></p> 
<p><span style="color:#555555"><br> Character devices:</span></p> 
<p><span style="color:#555555">  1 mem</span></p> 
<p><span style="color:#555555">  2 pty</span></p> 
<p><span style="color:#555555">  3 ttyp</span></p> 
<p><span style="color:#555555">  4 /dev/vc/0</span></p> 
<p><span style="color:#555555">  4 tty</span></p> 
<p><span style="color:#555555">  4 ttyS</span></p> 
<p><span style="color:#555555">  5 /dev/tty</span></p> 
<p><span style="color:#555555">  5 /dev/console</span></p> 
<p><span style="color:#555555">  5 /dev/ptmx</span></p> 
<p><span style="color:#555555">  7 vcs</span></p> 
<p><span style="color:#555555"> 10 misc</span></p> 
<p><span style="color:#555555"> 13 input</span></p> 
<p><span style="color:#555555"> 89 i2c</span></p> 
<p><span style="color:#555555"> 90 mtd</span></p> 
<p><span style="color:#555555">116 linux-user-bde2</span></p> 
<p><span style="color:#555555">117 linux-kernel-bde2</span></p> 
<p><span style="color:#555555">126 linux-user-bde</span></p> 
<p><span style="color:#555555">127 linux-kernel-bde</span></p> 
<p><span style="color:#555555">128 ptm</span></p> 
<p><span style="color:#555555">136 pts</span></p> 
<p><span style="color:#555555">180 usb</span></p> 
<p><span style="color:#555555">189 usb_device</span></p> 
<p><span style="color:#555555">245 ext_alarm</span></p> 
<p><span style="color:#555555">251 ipmidev</span></p> 
<p><span style="color:#555555">252 usb_endpoint</span></p> 
<p><span style="color:#555555">253 usbmon</span></p> 
<p><span style="color:#555555">254 rtc</span></p> 
<p><span style="color:#555555"> </span></p> 
<p><span style="color:#555555">Block devices:</span></p> 
<p><span style="color:#555555">  1 ramdisk</span></p> 
<p><span style="color:#555555">  8 sd</span></p> 
<p><span style="color:#555555"> 31 mtdblock</span></p> 
<p><span style="color:#555555"> 65 sd</span></p> 
<p><span style="color:#555555"> 66 sd</span></p> 
<p><span style="color:#555555"> 67 sd</span></p> 
<p><span style="color:#555555"> 68 sd</span></p> 
<p><span style="color:#555555"> 69 sd</span></p> 
<p><span style="color:#555555"> 70 sd</span></p> 
<p><span style="color:#555555"> 71 sd</span></p> 
<p><span style="color:#555555">128 sd</span></p> 
<p><span style="color:#555555">129 sd</span></p> 
<p><span style="color:#555555">130 sd</span></p> 
<p><span style="color:#555555">131 sd</span></p> 
<p><span style="color:#555555">132 sd</span></p> 
<p><span style="color:#555555">133 sd</span></p> 
<p><span style="color:#555555">134 sd</span></p> 
<p><span style="color:#555555">135 sd</span></p> 
<p><span style="color:#555555"> </span></p> 
<p><span style="color:#555555"><br> <a target="_blank" href="mailto:root@BCNMB-A" rel="nofollow noopener noreferrer"><span style="color:#015F91">root@BCNMB-A</span></a>:~#</span></p> 
<p><span style="color:#555555">3.7 /proc/partitions <br> </span><span style="color:#555555">分区中的块分配信息</span></p> 
<p><span style="color:#555555"><a target="_blank" href="mailto:root@BDSP-A-2-1-2" rel="nofollow noopener noreferrer"><span style="color:#015F91">root@BDSP-A-2-1-2</span></a>:~# cat /proc/partitions</span></p> 
<p><span style="color:#555555">major minor  #blocks  name</span></p> 
<p><span style="color:#555555">  31       0        512 mtdblock0</span></p> 
<p><span style="color:#555555">  31       1        512 mtdblock1</span></p> 
<p><span style="color:#555555">  31       2     123904 mtdblock2</span></p> 
<p><span style="color:#555555">  31       3       4096 mtdblock3</span></p> 
<p><span style="color:#555555">  31       4       1024 mtdblock4</span></p> 
<p><span style="color:#555555">  31       5       1024 mtdblock5</span></p> 
<p><span style="color:#555555">  31       6        512 mtdblock6</span></p> 
<p><span style="color:#555555">  31       7        512 mtdblock7</span></p> 
<p><span style="color:#555555">  31       8     123904 mtdblock8</span></p> 
<p><span style="color:#555555">  31       9       4096 mtdblock9</span></p> 
<p><span style="color:#555555">  31      10       1024 mtdblock10</span></p> 
<p><span style="color:#555555">  31      11       1024 mtdblock11</span></p> 
<p><span style="color:#555555">  31      12    1048576 mtdblock12</span></p> 
<p><span style="color:#555555"><a target="_blank" href="mailto:root@BDSP-A-2-1-2" rel="nofollow noopener noreferrer"><span style="color:#015F91">root@BDSP-A-2-1-2</span></a>:~#</span></p> 
<p><span style="color:#555555">3.8 /proc/version<br> Linux</span><span style="color:#555555">内核版本和</span><span style="color:#555555">gcc</span><span style="color:#555555">版本</span></p> 
<p><span style="color:#555555"><a target="_blank" href="mailto:root@BDSP-A-2-1-2" rel="nofollow noopener noreferrer"><span style="color:#015F91">root@BDSP-A-2-1-2</span></a>:~# cat /proc/version</span></p> 
<p><span style="color:#555555">Linux version 2.6.34.6-WR4.0.0.0_standard (<a target="_blank" href="mailto:satomi@CharlieBrown" rel="nofollow noopener noreferrer"><span style="color:#015F91">satomi@CharlieBrown</span></a>)(gcc version 4.4.1 (Wind River Linux Sourcery G++ 4.4-291) ) #1 SMP PREEMPT FriNov 26 16:07:47 CST 2010</span></p> 
<p><span style="color:#555555"><a target="_blank" href="mailto:root@BDSP-A-2-1-2" rel="nofollow noopener noreferrer"><span style="color:#015F91">root@BDSP-A-2-1-2</span></a>:~#</span></p> 
<p><span style="color:#555555">3.9 /proc/sys/fs/file-max<br> </span><span style="color:#555555">该文件指定了可以分配的文件句柄的最大数目。如果用户得到的错误消息声明由于打开文件数已经达到了最大值，从而他们不能打开更多文件，则可能需要增加该值。可将这个值设置成有任意多个文件，并且能通过将一个新数字值写入该文件来更改该值。默认设置时</span><span style="color:#555555">4096</span><span style="color:#555555">。</span></p> 
<p><span style="color:#555555">改变内核的参数，用</span><span style="color:#555555">vi</span><span style="color:#555555">编辑或</span><span style="color:#555555">echo</span><span style="color:#555555">参数重定向到文件中。</span></p> 
<p><span style="color:#555555"># cat /proc/sys/fs/file-max</span></p> 
<p><span style="color:#555555">4096</span></p> 
<p><span style="color:#555555"># echo 8192 &gt; /proc/sys/fs/file-max</span></p> 
<p><span style="color:#555555"># cat /proc/sys/fs/file-max</span></p> 
<p><span style="color:#555555">8192  </span></p> 
<p><span style="color:#555555">如果优化了参数，则可以把它们写成添加到文件</span><span style="color:#555555">rc.local</span><span style="color:#555555">中，使它在系统启动时自动完成修改</span></p> 
<p align="left"><a target="_blank" name="_Toc376251296">shell</a>的条件分支语句：<br> iflist1<br> then <br> list2<br> fi<br> 其中list1其实就是一个命令列表，列表只有一项时就是单个命令。if的条件就是列表中最后一个命令执行的返回值。<br> 所以要判断某个命令执行的返回值，只要直接把命令放在if后面就行了，千万不要画蛇添足地加上反引号！看例子：</p> 
<p align="left" style="background:rgb(247,247,247)">1.  $if true; then echo TRUE; fi</p> 
<p align="left" style="background:rgb(247,247,247)">2.  TRUE</p> 
<p align="left" style="background:rgb(247,247,247)">3.   </p> 
<p align="left" style="background:rgb(247,247,247)">4.  $if true; false; then echo TRUE; else echo FALSE; fi</p> 
<p align="left" style="background:rgb(247,247,247)">5.  FALSE</p> 
<p align="left" style="background:rgb(247,247,247)">6.   </p> 
<p align="left" style="background:rgb(247,247,247)">7.  $if true; false; true; then echo TRUE; else echo FALSE; fi</p> 
<p align="left" style="background:rgb(247,247,247)">8.  TRUE</p> 
<p align="left" style="background:rgb(247,247,247)">复制代码</p> 
<p><br> <br> `cmd`及其另一种形式$(cmd)，叫做“命令替换”，就是把其中的命令执行后的“标准输出”(注意不是“返回值”！)代换到命令行，然后再执行代换后得到的新命令行。<br> <br> 所以:<br> if `ls foo`; then do sth; fi<br> 这种写法是很奇怪的，也不能说它是错的，而且它确实能够执行，但起码可以认为该写法概念不清、逻辑混乱。</p> 
<p><br> <a target="_blank" name="_Toc376251297">shell</a>判断文件file存在：<br> 其实关于判断文件存在与否，shell有专用的测试方法：<br> if [ -e file ]; then cmd; fi<br> 判断file存在，且是普通文件：<br> if [ -f file ]; then cmd; fi<br> 判断目录存在：<br> if [ -d path ]; then cmd; fi<br> 判断文件存在且可执行：<br> if [ -x file ]; then cmd; fi</p> 
<div style="background:#F5F6F7"> 
 <h2 align="center"><a target="_blank" name="_Toc376251298">在</a> /dev 中创建设备</h2> 
</div> 
<h3><a target="_blank" name="_Toc376251299">6.8.1. </a>创建初始设备节点</h3> 
<p><span style="color:#333333">内核在引导时要求某些设备节点必须存在</span><span style="color:#333333">(</span><span style="color:#333333">特别是</span><span style="color:#333333"> </span><tt><span style="color:#333333">console</span></tt><span style="color:#333333"> </span><span style="color:#333333">和</span><span style="color:#333333"> </span><tt><span style="color:#333333">null</span></tt><span style="color:#333333"> </span><span style="color:#333333">)</span><span style="color:#333333">，这些设备节点必须创建在硬盘上才能使得内核在</span><span style="color:#333333"> </span><strong>udev</strong><span style="color:#333333"> </span><span style="color:#333333">尚未启动之前就可以使用它们，特别是当系统以单用户模式启动</span><span style="color:#333333">(</span><span style="color:#333333">仅允许使用</span><span style="color:#333333"> </span><tt><span style="color:#333333">console</span></tt><span style="color:#333333">)</span><span style="color:#333333">的时候更是如此。使用下面的命令来创建这些节点：</span></p> 
<div style="background:#E5E5E5"> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">mknod -m 600 /dev/console c 5 1</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">mknod -m 666 /dev/null c 1 3</span></strong></kbd></pre> 
</div> 
<h3><a target="_blank" name="_Toc376251300">6.8.2. </a>挂载 ramfs 并填充 /dev 目录</h3> 
<p><span style="color:#333333">推荐的向</span><span style="color:#333333"> </span><tt><span style="color:#333333">/dev</span></tt><span style="color:#333333"> </span><span style="color:#333333">目录填充设备的方法是在</span><span style="color:#333333"> </span><tt><span style="color:#333333">/dev</span></tt><span style="color:#333333"> </span><span style="color:#333333">上挂载一个虚拟文件系统</span><span style="color:#333333">(</span><span style="color:#333333">比如</span><span style="color:#333333"> </span><tt><span style="color:#333333">tmpfs</span></tt><span style="color:#333333">)</span><span style="color:#333333">，然后在设备被检测到或被访问到的时候</span><span style="color:#333333">(</span><span style="color:#333333">通常是在系统引导的过程中</span><span style="color:#333333">)</span><span style="color:#333333">动态创建设备节点。既然现在新的系统尚未被引导，那么就有必要通过挂载</span><span style="color:#333333"> </span><tt><span style="color:#333333">/dev</span></tt><span style="color:#333333"> </span><span style="color:#333333">来手工完成</span><span style="color:#333333"> LFS-Bootscripts </span><span style="color:#333333">将来要做的事情：</span></p> 
<div style="background:#E5E5E5"> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">mount -nvt tmpfs none /dev</span></strong></kbd></pre> 
</div> 
<p><span style="color:#333333">Udev</span><span style="color:#333333">软件包是实际用于在</span><span style="color:#333333"> </span><tt><span style="color:#333333">/dev</span></tt><span style="color:#333333"> </span><span style="color:#333333">目录中添加设备的工具。但是由于它要在后面的步骤中才被安装，我们现在必须手动创建一个必需的设备文件的最小集合，以便继续构建我们的系统。</span><span style="color:#333333">[</span><span style="color:#333333">注意</span><span style="color:#333333">]</span><span style="color:#333333">前面创建的</span><span style="color:#333333"> console </span><span style="color:#333333">和</span><span style="color:#333333"> null </span><span style="color:#333333">设备文件</span><span style="color:#333333">(</span><span style="color:#333333">保存在硬盘上</span><span style="color:#333333">)</span><span style="color:#333333">被新挂载的</span><span style="color:#333333"> tmpfs </span><span style="color:#333333">文件系统隐藏了，所以这里还要再创建一次。</span></p> 
<div style="background:#E5E5E5"> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">mknod -m 622 /dev/console c 5 1</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">mknod -m 666 /dev/null c 1 3</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">mknod -m 666 /dev/zero c 1 5</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">mknod -m 666 /dev/ptmx c 5 2</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">mknod -m 666 /dev/tty c 5 0</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">mknod -m 444 /dev/random c 1 8</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">mknod -m 444 /dev/urandom c 1 9</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">chown -v root:tty /dev/{console,ptmx,tty}</span></strong></kbd></pre> 
</div> 
<p><span style="color:#333333">有一些在系统启动的时候由</span><span style="color:#333333"> LFS-Bootscripts </span><span style="color:#333333">创建的符号连接和目录是</span><span style="color:#333333"> LFS </span><span style="color:#333333">系统所必须的。既然目前只是</span><span style="color:#333333"> chroot </span><span style="color:#333333">后的环境而不是真实启动后的环境，那么就需要在这里先创建他们：</span></p> 
<div style="background:#E5E5E5"> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">ln -sv /proc/self/fd /dev/fd</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">ln -sv /proc/self/fd/0 /dev/stdin</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">ln -sv /proc/self/fd/1 /dev/stdout</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">ln -sv /proc/self/fd/2 /dev/stderr</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">ln -sv /proc/kcore /dev/core</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">mkdir -v /dev/pts</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">mkdir -v /dev/shm</span></strong></kbd></pre> 
</div> 
<p><span style="color:#333333">最后在新建的目录中挂载虚拟内核文件系统：</span></p> 
<div style="background:#E5E5E5"> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span></strong></kbd></pre> 
 <pre style="background:#E5E5E5"><kbd><strong><span style="color:#101310">mount -vt tmpfs none /dev/shm</span></strong></kbd></pre> 
</div> 
<p><span style="color:#333333">上面的</span><span style="color:#333333"> </span><strong>mount</strong><span style="color:#333333"> </span><span style="color:#333333">命令可能会导致下面的警告信息：</span></p> 
<div style="background:#E9E9E9"> 
 <pre style="background:#E9E9E9"><tt>can't open /etc/fstab: No such file or directory.</tt></pre> 
</div> 
<p><span style="color:#333333">因为在挂载文件系统时需要</span><span style="color:#333333"> </span><tt><span style="color:#333333">/etc/fstab</span></tt><span style="color:#333333"> </span><span style="color:#333333">文件的指示，但是该文件目前尚未被创建，不过你可以安全的忽略它，该文件系统仍然会被正确的挂载。</span></p> 
<p align="left"><a target="_blank" name="_Toc376251301">linux </a><a target="_blank" href="http://blog.chinaunix.net/uid-28449808-id-3754576.html" rel="nofollow noopener noreferrer"><span style="color:windowtext">目录树</span></a><span style="color:#565656"> </span><span style="color:#BBBABA">2013-05-31 19:54:24</span></p> 
<p align="left"><span style="color:#19599B">分类：</span><span style="color:#19599B"> </span><span style="color:#BBBABA">LINUX</span></p> 
<p align="left"><span style="color:#666666">linux</span><span style="color:#666666">根文件系统中一般有下面的几个目录：</span></p> 
<p align="left"><span style="color:#666666">/bin</span></p> 
<p align="left"><span style="color:#666666">该目录下的命令可以被root</span>与一般账号所使用，由于这些命令在挂接其它文件系统之前就可以使用，所以/bin目录必须和根文件系统在同一个分区中。</p> 
<p align="left"><span style="color:#666666">/bin</span><span style="color:#666666">目录下常用的命令有：cat</span>、chgrp、chmod、cp、ls、sh、kill、mount、umount、mkdir、[、test等。其中“[”命令就是test命令，我们在利用Busybox制作根文件系统时，在生成的bin目录下，可以看到一些可执行的文件，也就是可用的一些命令。</p> 
<p align="left"><span style="color:#666666"> /sbin</span><span style="color:#666666"> </span><span style="color:#666666">目录</span></p> 
<p align="left"><span style="color:#666666">该目录下存放系统命令，即只有系统管理员（俗称最高权限的root</span>）能够使用的命令，系统命令还可以存放在/usr/sbin,/usr/local/sbin目录下，/sbin目录中存放的是基本的系统命令，它们用于启动系统和修复系统等，与/bin目录相似，在挂接其他文件系统之前就可以使用/sbin，所以/sbin目录必须和根文件系统在同一个分区中。</p> 
<p align="left"><span style="color:#666666">/sbin</span><span style="color:#666666">目录下常用的命令有：shutdown</span>、reboot、fdisk、fsck、init等，<a target="_blank" href="http://baike.baidu.com/view/119278.htm" rel="nofollow noopener noreferrer"><span style="color:windowtext">本地用户</span></a>自己安装的系统命令放在/usr/local/sbin目录下。</p> 
<p align="left"><span style="color:#666666">/dev</span><span style="color:#666666">目录</span></p> 
<p align="left"><span style="color:#666666">该目录下存放的是设备与设备接口的文件，设备文件是Linux</span>中特有的文件类型，在Linux系统下，以文件的方式访问各种设备，即通过读写某个设备文件操作某个具体硬件。比如通过"dev/ttySAC0"文件可以操作串口0，通过"/dev/mtdblock1"可以访问MTD设备的第2个分区。比较重要的文件有/dev/null, /dev/zero, /dev/tty,/dev/lp*等。</p> 
<p align="left"><span style="color:#666666">/etc</span><span style="color:#666666">目录</span></p> 
<p align="left"><span style="color:#666666">该目录下存放着系统主要的配置文件，例如人员的账号密码文件、各种服务的其实文件等。一般来说，此目录的各文件属性是可以让一般用户查阅的，但是只有root</span>有权限修改。对于PC上的Linux系统，/etc目录下的文件和目录非常多，这些目录文件是可选的，它们依赖于系统中所拥有的应用程序，依赖于这些程序是否需要配置文件。在<a target="_blank" href="http://baike.baidu.com/view/6115.htm" rel="nofollow noopener noreferrer"><span style="color:windowtext">嵌入式系统</span></a>中，这些内容可以大为精减。</p> 
<p align="left"><span style="color:#666666">/lib</span><span style="color:#666666">目录</span></p> 
<p align="left"><span style="color:#666666">该目录下存放共享库和可加载（<a target="_blank" href="http://baike.baidu.com/view/1048.htm" rel="nofollow noopener noreferrer"><span style="color:windowtext">驱动程序</span></a></span>），共享库用于启动系统。运行根文件系统中的可执行程序，比如：/bin /sbin<span style="color:#666666"> </span><span style="color:#666666">目录下的程序。</span></p> 
<p align="left"><span style="color:#666666">/home</span><span style="color:#666666">目录</span></p> 
<p align="left"><span style="color:#666666">系统默认的用户文件夹，它是可选的，对于每个普通用户，在/home</span>目录下都有一个以用户名命名的子目录，里面存放用户相关的配置文件</p> 
<p align="left"><span style="color:#666666">/root</span><span style="color:#666666">目录</span></p> 
<p align="left"><span style="color:#666666">系统管理员（root</span>）的主文件夹，即是根用户的目录，与此对应，普通用户的目录是/home下的某个子目录。</p> 
<p align="left"><span style="color:#666666">/usr</span><span style="color:#666666">目录</span></p> 
<p align="left"><span style="color:#666666">/usr</span><span style="color:#666666">目录的内容可以存在另一个分区中，在系统启动后再挂接到根文件系统中的/usr</span>目录下。里面存放的是共享、只读的程序和数据，这表明/usr目录下的内容可以在多个主机间共享，这些主要也符合<a target="_blank" href="http://baike.baidu.com/view/1513206.htm" rel="nofollow noopener noreferrer"><span style="color:windowtext">FHS</span></a>标准的。/usr中的文件应该是只读的，其他主机相关的，可变的文件应该保存在其他目录下，比如/var。/usr目录在<a target="_blank" href="http://baike.baidu.com/view/30741.htm" rel="nofollow noopener noreferrer"><span style="color:windowtext">嵌入式</span></a>中可以精减。</p> 
<p align="left"><span style="color:#666666">/var</span><span style="color:#666666">目录</span></p> 
<p align="left"><span style="color:#666666">与/usr</span>目录相反，/var目录中存放可变的数据，比如spool目录（mail,news），log文件，临时文件。</p> 
<p align="left"><span style="color:#666666">/proc</span><span style="color:#666666">目录</span></p> 
<p align="left"><span style="color:#666666">这是一个空目录，常作为proc</span>文件系统的挂接点，proc文件系统是个虚拟的文件系统，它没有实际的存储设备，里面的目录，文件都是由<a target="_blank" href="http://baike.baidu.com/view/1366.htm" rel="nofollow noopener noreferrer"><span style="color:windowtext">内核</span></a></p> 
<p align="left"><span style="color:#666666">临时生成的，用来表示系统的运行状态，也可以操作其中的文件控制系统。</span></p> 
<p align="left"><span style="color:#666666">/mnt</span><span style="color:#666666">目录</span></p> 
<p align="left"><span style="color:#666666">用于临时挂载某个文件系统的挂接点，通常是空目录，也可以在里面创建一引起空的子目录，比如/mnt/cdram /mnt/hda1</span><span style="color:#666666"> </span><span style="color:#666666">。用来临时挂载光盘、移动存储设备等。</span></p> 
<p align="left"><span style="color:#666666">/tmp</span><span style="color:#666666">目录</span></p> 
<p align="left"><span style="color:#666666">用于存放临时文件，通常是空目录，一些需要生成临时文件的程序用到的/tmp</span>目录下，所以/tmp目录必须存在并可以访问。</p> 
<p align="left"><span style="color:#666666">内核分区表：</span></p> 
<p align="left"><span style="color:#666666">0x000000000000-0x000000100000 : "mtdblock0 u-boot1MB"</span></p> 
<p align="left"><span style="color:#666666">0x000000100000-0x000001000000 : "mtdblock1 kernel15MB"</span></p> 
<p align="left"><span style="color:#666666">0x000001000000-0x000002400000 : "mtdblock2 ramdisk20MB"</span></p> 
<p align="left"><span style="color:#666666">0x000002400000-0x000003800000 : "mtdblock3 cramfs20MB"</span></p> 
<p align="left"><span style="color:#666666">0x000003800000-0x000006000000 : "mtdblock4 jffs220MB"</span></p> 
<p align="left"><span style="color:#666666">0x000006000000-0x000008800000 : "mtdblock5 yaffs240MB"</span></p> 
<p align="left"><span style="color:#666666">0x000008800000-0x00000b000000 : "mtdblock6 ubifs40MB"</span></p> 
<p align="left"><span style="color:#666666">0x00000b000000-0x00000e200000 : "mtdblock7 apps50MB"</span></p> 
<p align="left"><span style="color:#666666">0x00000e200000-0x000011400000 : "mtdblock8 data50MB"</span></p> 
<p align="left"><span style="color:#666666">1.</span><span style="color:#666666">首先创建目录树框架</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost rootfs]$ tree</span></p> 
<p align="left"><span style="color:#666666">.</span></p> 
<p align="left"><span style="color:#666666">|-- apps</span></p> 
<p align="left"><span style="color:#666666">|-- bin</span></p> 
<p align="left"><span style="color:#666666">|-- data</span></p> 
<p align="left"><span style="color:#666666">|-- dev</span></p> 
<p align="left"><span style="color:#666666">|-- etc</span></p> 
<p align="left"><span style="color:#666666">|  </span><span style="color:#666666"> </span><span style="color:#666666">`-- init.d</span></p> 
<p align="left"><span style="color:#666666">|-- lib</span></p> 
<p align="left"><span style="color:#666666">|-- mnt</span></p> 
<p align="left"><span style="color:#666666">|  </span><span style="color:#666666"> </span><span style="color:#666666">|-- dev</span></p> 
<p align="left"><span style="color:#666666">|  </span><span style="color:#666666"> </span><span style="color:#666666">|-- nfs</span></p> 
<p align="left"><span style="color:#666666">|  </span><span style="color:#666666"> </span><span style="color:#666666">|-- sdc</span></p> 
<p align="left"><span style="color:#666666">|  </span><span style="color:#666666"> </span><span style="color:#666666">`-- usb</span></p> 
<p align="left"><span style="color:#666666">|-- proc</span></p> 
<p align="left"><span style="color:#666666">|-- root</span></p> 
<p align="left"><span style="color:#666666">|-- sbin</span></p> 
<p align="left"><span style="color:#666666">|-- sys</span></p> 
<p align="left"><span style="color:#666666">|-- tmp</span></p> 
<p align="left"><span style="color:#666666">|-- usr</span></p> 
<p align="left"><span style="color:#666666">|  </span><span style="color:#666666"> </span><span style="color:#666666">|-- bin</span></p> 
<p align="left"><span style="color:#666666">|  </span><span style="color:#666666"> </span><span style="color:#666666">|-- lib</span></p> 
<p align="left"><span style="color:#666666">|  </span><span style="color:#666666"> </span><span style="color:#666666">|-- sbin</span></p> 
<p align="left"><span style="color:#666666">|</span><span style="color:#666666"> </span><span style="color:#666666">  `--share</span></p> 
<p align="left"><span style="color:#666666">`-- var</span></p> 
<p align="left"><span style="color:#666666">2.</span><span style="color:#666666">在/dev</span>目录下创建设备节点：</p> 
<p align="left"><span style="color:#666666">[lingyun@localhost dev]$ sudo mknod -m 755 console c 5 1</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost dev]$ sudo mknod -m 755 null c 1 3</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost dev]$ sudo mknod -m 755 ttyS0 c 4 64</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost dev]$ sudo mknod mtdblock0 b 31 0</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost dev]$ sudo mknod mtdblock1 b 31 1</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost dev]$ sudo mknod mtdblock2 b 31 2</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost dev]$ sudo mknod mtdblock3 b 31 3</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost dev]$ sudo mknod mtdblock4 b 31 4</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost dev]$ sudo mknod mtdblock5 b 31 5</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost dev]$ sudo mknod mtdblock6 b 31 6</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost dev]$ sudo mknod mtdblock7 b 31 7</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost dev]$ sudo mknod mtdblock8 b 31 8</span></p> 
<p align="left"><span style="color:#666666">3.</span><span style="color:#666666">在var</span><span style="color:#666666"> </span><span style="color:#666666">目录下创建符号链接文件:</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost var]$ ln -s ../tmp lock</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost var]$ ln -s ../tmp log</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost var]$ ln -s ../tmp run</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost var]$ ln -s ../tmp tmp</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost var]$ ls -l</span></p> 
<p align="left"><span style="color:#666666">total 0</span></p> 
<p align="left"><span style="color:#666666">lrwxrwxrwx 1 lingyun trainning 6 May 27 13:39 lock -&gt;../tmp</span></p> 
<p align="left"><span style="color:#666666">lrwxrwxrwx 1 lingyun trainning 6 May 27 13:39 log -&gt;../tmp</span></p> 
<p align="left"><span style="color:#666666">lrwxrwxrwx 1 lingyun trainning 6 May 27 13:39 run -&gt;../tmp</span></p> 
<p align="left"><span style="color:#666666">lrwxrwxrwx 1 lingyun trainning 6 May 27 13:39 tmp -&gt;../tmp</span></p> 
<p align="left"><span style="color:#666666">/var/tmp</span><span style="color:#666666"> </span><span style="color:#666666"><br> </span><span style="color:#666666">　　比/tmp</span>大或需要存较长时间的临时文件.</p> 
<p align="left"><span style="color:#666666">/var/lock</span><span style="color:#666666"> </span><span style="color:#666666"><br> </span><span style="color:#666666">　　锁定文件.</span>许多程序遵循在/var/lock<span style="color:#666666"> </span><span style="color:#666666">中产生一个锁定文件的约定，以支持他们正在使用某个特定的设备或文件.</span>其他程序注意到这个锁定文件，将不试图使用这个设备或文件.</p> 
<p align="left"><span style="color:#666666">/var/log</span><span style="color:#666666"> </span><span style="color:#666666"><br> </span><span style="color:#666666">　　各种程序的log</span>文件，特别是login (/var/log/wtmp log所有到系统的登录和注销)<span style="color:#666666"> </span><span style="color:#666666">和syslog (/var/log/messages</span><span style="color:#666666"> </span><span style="color:#666666">里存储所有核心和系统程序信息. /var/log</span><span style="color:#666666"> </span><span style="color:#666666">里的文件经常不确定地增长，应该定期清除</span></p> 
<p align="left"><span style="color:#666666">/var/run</span><span style="color:#666666"> </span><span style="color:#666666"><br> </span><span style="color:#666666">　　保存到下次引导前有效的关于系统的信息文件.</span>例如，/var/run/utmp<span style="color:#666666"> </span><span style="color:#666666">包含当前登录的用户的信息.</span></p> 
<p align="left"><span style="color:#666666">4.</span><span style="color:#666666">在/etc</span>目录下增加fstab，hostname，inittab，mdev.conf，passwd，protocols，resolv.conf，services，</p> 
<p align="left"><span style="color:#666666">group</span><span style="color:#666666">，hosts</span>，issue，mtab，profile，shadow文件</p> 
<p align="left"><span style="color:#666666">inittab</span><span style="color:#666666">文件:</span></p> 
<p align="left"><span style="color:#666666"># /etc/inittab</span></p> 
<p align="left"><span style="color:#666666"># mount all the file systems specified in /etc/fstab</span></p> 
<p align="left"><span style="color:#666666">::sysinit:/bin/mount </span><span style="color:#666666">–a                                           </span><span style="color:#666666"> </span><span style="color:#666666"> //</span><span style="color:#666666">系统启动后自动挂载fstab</span>文件中指定的虚拟文件系统</p> 
<p align="left"><span style="color:#666666">#Use mdev as hotplug to auto mount USB storage or SD card</span><span style="color:#666666"> </span><span style="color:#666666">             //</span><span style="color:#666666">系统使能hotplug</span>功能，当然还需要一些挂载脚本文件</p> 
<p align="left"><span style="color:#666666">::sysinit:/bin/echo /sbin/mdev &gt;/proc/sys/kernel/hotplug</span></p> 
<p align="left"><span style="color:#666666">::sysinit:/sbin/mdev -s</span></p> 
<p align="left"><span style="color:#666666">#make shm, pts support</span></p> 
<p align="left"><span style="color:#666666">::sysinit:/bin/mkdir -p /dev/pts</span></p> 
<p align="left"><span style="color:#666666">::sysinit:/bin/mkdir -p /dev/shm</span></p> 
<p align="left"><span style="color:#666666">::sysinit:/bin/mount -t devpts devpts /dev/pts</span></p> 
<p align="left"><span style="color:#666666">#Mount our apps/infopartition                                 </span><span style="color:#666666"> </span><span style="color:#666666">       //</span><span style="color:#666666">挂载nand flash</span><span style="color:#666666"> </span><span style="color:#666666">分区</span></p> 
<p align="left"><span style="color:#666666">null::wait:/bin/mount -o sync,noatime,ro -t jffs2/dev/mtdblock7 /apps</span></p> 
<p align="left"><span style="color:#666666">null::wait:/bin/mount -o sync,noatime,ro -t jffs2/dev/mtdblock8 /data</span></p> 
<p align="left"><span style="color:#666666">#Set hostname</span></p> 
<p align="left"><span style="color:#666666">null::sysinit:/bin/hostname -F /etc/hostname</span></p> 
<p align="left"><span style="color:#666666">#Initialize the user account files</span></p> 
<p align="left"><span style="color:#666666">#null::wait:/usr/sbin/initpwd</span></p> 
<p align="left"><span style="color:#666666">#Enable console logon</span></p> 
<p align="left"><span style="color:#666666">null::respawn:/sbin/getty -L ttyS0 115200vt100                </span></p> 
<p align="left"><span style="color:#666666">null::sysinit:/bin/mkdir -p /tmp/logs</span></p> 
<p align="left"><span style="color:#666666">null::sysinit:/bin/mkdir -p /tmp/stat</span></p> 
<p align="left"><span style="color:#666666"># now run any rc scripts</span></p> 
<p align="left"><span style="color:#666666">null::wait:/etc/init.d/rcS</span></p> 
<p align="left"><span style="color:#666666"># system daemon</span></p> 
<p align="left"><span style="color:#666666">null::respawn:/sbin/syslogd -n</span></p> 
<p align="left"><span style="color:#666666">null::respawn:/sbin/klogd -n</span></p> 
<p align="left"><span style="color:#666666"># Stuff to do before rebooting</span></p> 
<p align="left"><span style="color:#666666">null::shutdown:/bin/umount /apps</span></p> 
<p align="left"><span style="color:#666666">null::shutdown:/bin/umount /data</span></p> 
<p align="left"><span style="color:#666666">null::shutdown:/bin/killall klogd</span></p> 
<p align="left"><span style="color:#666666">null::shutdown:/bin/killall syslogd</span></p> 
<p align="left"><span style="color:#666666">null::shutdown:/bin/umount -a -r</span></p> 
<p align="left"><span style="color:#666666">fstab</span><span style="color:#666666">文件:</span></p> 
<p align="left"><span style="color:#666666">/etc/fstab: static file system information.</span></p> 
<p align="left"><span style="color:#666666">#</span><span style="color:#666666"> </span><span style="color:#666666">    </span><span style="color:#666666"> </span><span style="color:#666666">  </span><span style="color:#666666"> </span><span style="color:#666666">        </span></p> 
<p align="left"><span style="color:#666666">/dev/root      </span><span style="color:#666666"> </span><span style="color:#666666">/             </span><span style="color:#666666"> </span><span style="color:#666666">ext2    </span><span style="color:#666666"> </span><span style="color:#666666">rw,noauto        </span><span style="color:#666666"> </span><span style="color:#666666">0     </span><span style="color:#666666"> </span><span style="color:#666666">1</span></p> 
<p align="left"><span style="color:#666666">proc          </span><span style="color:#666666"> </span><span style="color:#666666">/proc         </span><span style="color:#666666"> </span><span style="color:#666666">proc    </span><span style="color:#666666"> </span><span style="color:#666666">defaults         </span><span style="color:#666666"> </span><span style="color:#666666">0     </span><span style="color:#666666"> </span><span style="color:#666666">0</span></p> 
<p align="left"><span style="color:#666666">tmpfs        </span><span style="color:#666666"> </span><span style="color:#666666"> /dev   </span><span style="color:#666666"> </span><span style="color:#666666">       tmpfs   </span><span style="color:#666666"> </span><span style="color:#666666">defaults         </span><span style="color:#666666"> </span><span style="color:#666666">0     </span><span style="color:#666666"> </span><span style="color:#666666">0</span></p> 
<p align="left"><span style="color:#666666">ramfs        </span><span style="color:#666666"> </span><span style="color:#666666">/tmp         </span><span style="color:#666666"> </span><span style="color:#666666"> ramfs   </span><span style="color:#666666"> </span><span style="color:#666666">defaults         </span><span style="color:#666666"> </span><span style="color:#666666">0     </span><span style="color:#666666"> </span><span style="color:#666666">0</span></p> 
<p align="left"><span style="color:#666666">sysfs        </span><span style="color:#666666"> </span><span style="color:#666666">/sys          </span><span style="color:#666666"> </span><span style="color:#666666">sysfs   </span><span style="color:#666666"> </span><span style="color:#666666">defaults         </span><span style="color:#666666"> </span><span style="color:#666666">0     </span><span style="color:#666666"> </span><span style="color:#666666">0</span></p> 
<p align="left"><span style="color:#666666">hostname</span><span style="color:#666666">文件:</span></p> 
<p align="left"><span style="color:#666666">MINI2440</span></p> 
<p align="left"><span style="color:#666666">shadow</span><span style="color:#666666">文件:                             </span></p> 
<p align="left"><span style="color:#666666">修改虚拟机root</span>用户的密码：</p> 
<p align="left"><span style="color:#666666">[lingyun@localhost etc]$ sudo passwd root</span></p> 
<p align="left"><span style="color:#666666">Changing password for user root.</span></p> 
<p align="left"><span style="color:#666666">New password:</span></p> 
<p align="left"><span style="color:#666666">BAD PASSWORD: it is based on a dictionary word</span></p> 
<p align="left"><span style="color:#666666">BAD PASSWORD: is too simple</span></p> 
<p align="left"><span style="color:#666666">Retype new password:</span></p> 
<p align="left"><span style="color:#666666">passwd: all authentication tokens updated successfully.</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost etc]$ sudo head -n 2 /etc/shadow</span></p> 
<p align="left"><span style="color:#666666">root:$6$4o1aUL4K$fexvf1D74DjTIAfXZkEyrPuQWu38iPx2CrfC91Sx09331RBDDV0iEZ/GIX9vWMaIRij6VSaHbhuEM98X6ag9B.:15852:0:99999:7:::</span></p> 
<p align="left"><span style="color:#666666">bin:*:15513:0:99999:7:::</span></p> 
<p align="left"><span style="color:#666666">将以上两行内容拷贝到制作的根文件系统/etc/shadow</span>中。注意：我现在是在虚拟机上做文件系统。</p> 
<p align="left"><span style="color:#666666">group</span><span style="color:#666666">文件:              </span><span style="color:#666666"> </span><span style="color:#666666">       </span></p> 
<p align="left"><span style="color:#666666">root:x:0:                                                    </span><span style="color:#666666"> </span><span style="color:#666666">  //</span><span style="color:#666666">为root</span>用户创建一个分组</p> 
<p align="left"><span style="color:#666666">passwd</span><span style="color:#666666">文件:</span></p> 
<p align="left"><span style="color:#666666">root:x:0:0:root:/root:/bin/sh             </span><span style="color:#666666"> </span><span style="color:#666666">                          //</span><span style="color:#666666">每个系统都必需有个root</span>用户</p> 
<p align="left"><span style="color:#666666">hosts</span><span style="color:#666666">文件:</span></p> 
<p align="left"><span style="color:#666666">127.0.0.1      </span><span style="color:#666666"> </span><span style="color:#666666">localhost                                  </span><span style="color:#666666"> </span><span style="color:#666666">     //pinglocalhost</span><span style="color:#666666">就相当于ping 127.0.0.1<br> <br> <br> </span></p> 
<p align="left"><span style="color:#666666">issue</span><span style="color:#666666">文件:                                                </span><span style="color:#666666"> </span><span style="color:#666666">   //</span><span style="color:#666666">文件中的内容为系统登录时的提示信息</span></p> 
<p align="left"><span style="color:#666666">Welcome to LinuxWorld!!!                 </span></p> 
<p align="left"><span style="color:#666666">mdev.conf</span><span style="color:#666666">文件:                                         </span><span style="color:#666666"> </span><span style="color:#666666">     //</span><span style="color:#666666">系统自动挂载文件，比如我们插上U</span>盘后，自动挂载</p> 
<p align="left"><span style="color:#666666">sd[a-h]*[0-9]    </span><span style="color:#666666"> </span><span style="color:#666666">0:00660       </span><span style="color:#666666"> </span><span style="color:#666666">*(/usr/sbin/hotplug /media/usb)</span></p> 
<p align="left"><span style="color:#666666">sd[a-h]          </span><span style="color:#666666"> </span><span style="color:#666666">0:00660       </span><span style="color:#666666"> </span><span style="color:#666666">*(/usr/sbin/hotplug /media/usb)</span></p> 
<p align="left"><span style="color:#666666">ub[a-h]*[0-9]    </span><span style="color:#666666"> </span><span style="color:#666666">0:00660       </span><span style="color:#666666"> </span><span style="color:#666666">*(/usr/sbin/hotplug /media/usb)</span></p> 
<p align="left"><span style="color:#666666">ub[a-h]          </span><span style="color:#666666"> </span><span style="color:#666666">0:00660       </span><span style="color:#666666"> </span><span style="color:#666666">*(/usr/sbin/hotplug /media/usb)</span></p> 
<p align="left"><span style="color:#666666">mmcblk[0-9]p[0-9] 0:00660       </span><span style="color:#666666"> </span><span style="color:#666666">@(/bin/mount /dev/$MDEV /media/mmc)</span></p> 
<p align="left"><span style="color:#666666">mmcblk[0-9]      </span><span style="color:#666666"> </span><span style="color:#666666">0:00660       </span><span style="color:#666666"> </span><span style="color:#666666">$(/bin/umount/media/mmc)               </span></p> 
<p align="left"><span style="color:#666666">profile</span><span style="color:#666666">文件:                                                        </span></p> 
<p align="left"><span style="color:#666666">export PATH=\</span></p> 
<p align="left"><span style="color:#666666">/bin:\</span></p> 
<p align="left"><span style="color:#666666">/sbin:\</span></p> 
<p align="left"><span style="color:#666666">/usr/bin:\</span></p> 
<p align="left"><span style="color:#666666">/usr/sbin:\</span></p> 
<p align="left"><span style="color:#666666">/apps/tools:\</span></p> 
<p align="left"><span style="color:#666666">/apps/bin:\</span></p> 
<p align="left"><span style="color:#666666">export PS1='\w &gt;: '</span></p> 
<p align="left"><span style="color:#666666">export USER=`id -un`</span></p> 
<p align="left"><span style="color:#666666">export LOGNAME=$USER</span></p> 
<p align="left"><span style="color:#666666">export HOSTNAME=`/bin/hostname`</span></p> 
<p align="left"><span style="color:#666666">export HISTSIZE=500</span></p> 
<p align="left"><span style="color:#666666">export HISTFILESIZE=500</span></p> 
<p align="left"><span style="color:#666666">export PAGER='/bin/more '</span></p> 
<p align="left"><span style="color:#666666">export EDITOR='/bin/vi'</span></p> 
<p align="left"><span style="color:#666666">export INPUTRC=/etc/inputrc</span></p> 
<p align="left"><span style="color:#666666">export network_cfg_dir=/apps/etc/network</span></p> 
<p align="left"><span style="color:#666666">export LD_LIBRARY_PATH=/lib:/usr/lib:/apps/lib:/apps/libs</span></p> 
<p align="left"><span style="color:#666666">### Some aliases</span></p> 
<p align="left"><span style="color:#666666">alias vim='vi'</span></p> 
<p align="left"><span style="color:#666666">alias ll='ls -l'</span></p> 
<p align="left"><span style="color:#666666">alias l.='ls -d .*'</span></p> 
<p align="left"><span style="color:#666666">alias df='df -h' </span></p> 
<p align="left"><span style="color:#666666">protocols</span><span style="color:#666666">文件:                        </span><span style="color:#666666"> </span><span style="color:#666666">                     //</span><span style="color:#666666">指定协议端口号</span></p> 
<p align="left"><span style="color:#666666"># /etc/protocols:</span></p> 
<p align="left"><span style="color:#666666">ip     </span><span style="color:#666666"> </span><span style="color:#666666">0      </span><span style="color:#666666"> </span><span style="color:#666666">IP            </span></p> 
<p align="left"><span style="color:#666666">icmp   </span><span style="color:#666666"> </span><span style="color:#666666">1      </span><span style="color:#666666"> </span><span style="color:#666666">ICMP         </span></p> 
<p align="left"><span style="color:#666666">igmp   </span><span style="color:#666666"> </span><span style="color:#666666">2      </span><span style="color:#666666"> </span><span style="color:#666666">IGMP           </span></p> 
<p align="left"><span style="color:#666666">ggp    </span><span style="color:#666666"> </span><span style="color:#666666">3      </span><span style="color:#666666"> </span><span style="color:#666666">GGP      </span><span style="color:#666666"> </span><span style="color:#666666">     </span></p> 
<p align="left"><span style="color:#666666">ipencap 4 </span><span style="color:#666666"> </span><span style="color:#666666">     IP-ENCAP      </span></p> 
<p align="left"><span style="color:#666666">st     </span><span style="color:#666666"> </span><span style="color:#666666">5      </span><span style="color:#666666"> </span><span style="color:#666666">ST            </span></p> 
<p align="left"><span style="color:#666666">tcp    </span><span style="color:#666666"> </span><span style="color:#666666">6      </span><span style="color:#666666"> </span><span style="color:#666666">TCP           </span></p> 
<p align="left"><span style="color:#666666">egp    </span><span style="color:#666666"> </span><span style="color:#666666">8 </span><span style="color:#666666"> </span><span style="color:#666666">     EGP       </span><span style="color:#666666"> </span><span style="color:#666666">     </span></p> 
<p align="left"><span style="color:#666666">pup    </span><span style="color:#666666"> </span><span style="color:#666666">12     </span><span style="color:#666666"> </span><span style="color:#666666">PUP           </span></p> 
<p align="left"><span style="color:#666666">udp    </span><span style="color:#666666"> </span><span style="color:#666666">17     </span><span style="color:#666666"> </span><span style="color:#666666">UDP    </span><span style="color:#666666"> </span><span style="color:#666666">      </span></p> 
<p align="left"><span style="color:#666666">hmp    </span><span style="color:#666666"> </span><span style="color:#666666">20     </span><span style="color:#666666"> </span><span style="color:#666666">HMP      </span><span style="color:#666666"> </span><span style="color:#666666">     </span></p> 
<p align="left"><span style="color:#666666">xns-idp 22   </span><span style="color:#666666"> </span><span style="color:#666666">  XNS-IDP      </span></p> 
<p align="left"><span style="color:#666666">rdp    </span><span style="color:#666666"> </span><span style="color:#666666">27     </span><span style="color:#666666"> </span><span style="color:#666666">RDP          </span><span style="color:#666666"> </span><span style="color:#666666"> </span></p> 
<p align="left"><span style="color:#666666">iso-tp4 29     </span><span style="color:#666666"> </span><span style="color:#666666">ISO-TP4        </span></p> 
<p align="left"><span style="color:#666666">xtp    </span><span style="color:#666666"> </span><span style="color:#666666">36     </span><span style="color:#666666"> </span><span style="color:#666666">XTP     </span><span style="color:#666666"> </span><span style="color:#666666">      </span></p> 
<p align="left"><span style="color:#666666">ddp    </span><span style="color:#666666"> </span><span style="color:#666666">37</span><span style="color:#666666"> </span><span style="color:#666666">     DDP        </span><span style="color:#666666"> </span><span style="color:#666666">    </span></p> 
<p align="left"><span style="color:#666666">idpr-cmtp      </span><span style="color:#666666"> </span><span style="color:#666666">39     </span><span style="color:#666666"> </span><span style="color:#666666">IDPR-CMTP    </span></p> 
<p align="left"><span style="color:#666666">rspf   </span><span style="color:#666666"> </span><span style="color:#666666">73     </span><span style="color:#666666"> </span><span style="color:#666666">RSPF           </span></p> 
<p align="left"><span style="color:#666666">vmtp   </span><span style="color:#666666"> </span><span style="color:#666666">81     </span><span style="color:#666666"> </span><span style="color:#666666">VMTP        </span><span style="color:#666666"> </span><span style="color:#666666">   </span></p> 
<p align="left"><span style="color:#666666">ospf   </span><span style="color:#666666"> </span><span style="color:#666666">89     </span><span style="color:#666666"> </span><span style="color:#666666">OSPFIGP      </span><span style="color:#666666"> </span><span style="color:#666666"> </span></p> 
<p align="left"><span style="color:#666666">ipip   </span><span style="color:#666666"> </span><span style="color:#666666">94     </span><span style="color:#666666"> </span><span style="color:#666666">IPIP         </span><span style="color:#666666"> </span><span style="color:#666666">        </span></p> 
<p align="left"><span style="color:#666666">encap  </span><span style="color:#666666"> </span><span style="color:#666666">98     </span><span style="color:#666666"> </span><span style="color:#666666">ENCAP</span></p> 
<p align="left"><span style="color:#666666">resolv.conf</span><span style="color:#666666">文件：</span></p> 
<p align="left"><span style="color:#666666">nameserver 4.2.2.2</span></p> 
<p align="left"><span style="color:#666666">nameserver 8.8.8.8</span></p> 
<p align="left"><span style="color:#666666">servers</span><span style="color:#666666">文件：</span></p> 
<p align="left"><span style="color:#666666">这个文件我们直接用虚拟机中/etc/servers</span>文件，主要是提供的相关服务，比如ftp</p> 
<p align="left"><span style="color:#666666">mtab</span><span style="color:#666666">文件：</span></p> 
<p align="left"><span style="color:#666666">不需要加任何内容，它</span>记载的是现在系统已经装载的文件系统，包括操作系统建立的虚拟文件等；而/etc/fstab是系统准备装载的。直接使用mount就是通过查询它而来的。</p> 
<p align="left"><span style="color:#666666">4.</span><span style="color:#666666">在init.d</span>目录下增加文件rcS <span style="color:#666666"> </span><span style="color:#666666">S01_network</span><span style="color:#666666"> </span><span style="color:#666666"> S99_rcsApp</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost init.d]$ cat rcS</span></p> 
<p align="left"><span style="color:#666666">#!/bin/sh</span></p> 
<p align="left"><span style="color:#666666">for i in /etc/init.d/S??* ;do</span></p> 
<p align="left"><span style="color:#666666">       </span><span style="color:#666666"> </span><span style="color:#666666">$i</span></p> 
<p align="left"><span style="color:#666666">done</span></p> 
<p align="left"><span style="color:#666666">[lingyun@localhost init.d]$ cat S99_rcsApp</span></p> 
<p align="left"><span style="color:#666666">#!/bin/sh</span></p> 
<p align="left"><span style="color:#666666">if (test -d /apps/etc/init.d)</span></p> 
<p align="left"><span style="color:#666666">then</span></p> 
<p align="left"><span style="color:#666666">    </span><span style="color:#666666"> </span><span style="color:#666666">for i in /apps/etc/init.d/S??* ;do</span></p> 
<p align="left"><span style="color:#666666">           </span><span style="color:#666666"> </span><span style="color:#666666"> $i</span></p> 
<p align="left"><span style="color:#666666">    </span><span style="color:#666666"> </span><span style="color:#666666">done</span></p> 
<p align="left"><span style="color:#666666">fi</span></p> 
<p align="left"><span style="color:#666666">5.</span><span style="color:#666666">编译busybox</span>，根文件系统的命令都来自busybox</p> 
<p align="left"><span style="color:#666666"><br> <br> <br> <br> <br> <br> <br> </span><span style="color:#666666">静态编译，并指定交叉编译器的路径<br> <br> <br> <br> </span></p> 
<p align="left"><span style="color:#666666">指定命令的安装路径<br> <br> <br> </span>注意：busybox-1.20.2目录和rootfs目录在同一个目录下！<br> 在make ，make install之后,，rootfs中的bin，sbin 目录，就有了文件系统需要的命令！<br> <br> Init进程<br> <br> <br> 以上已经成功的创建了一个根文件系统目录树。</p> 
<h3><a target="_blank" name="_Toc376251302">虚拟内存盘</a></h3> 
<p><strong><span style="color:#333333">ramdisk</span></strong><span style="color:#333333">即虚拟内存盘（虚拟内存盘）。</span></p> 
<p><span style="color:#333333">虚拟内存盘是通过软件将一部分</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/1082.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">内存</span></a></span><span style="color:#333333">（</span><span style="color:#333333">RAM</span><span style="color:#333333">）模拟为</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/4480.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">硬盘</span></a></span><span style="color:#333333">来使用的一种技术。相对于直接的硬盘文件访问来说，这种技术可以极大的提高在其上进行的文件访问的速度。但是</span><span style="color:#333333">RAM</span><span style="color:#333333">的易失性也意味着当关闭电源后这部分数据将会丢失。但是在一般情况下，传递到</span><span style="color:#333333">RAM</span><span style="color:#333333">盘上的数据都是在硬盘或别处永久贮存的文件的一个拷贝。经由适当的配置，可以实现当系统重启后重新建立虚拟盘。</span></p> 
<p><strong>简介</strong></p> 
<p><sup><span style="color:#3366CC">[1]</span></sup><a target="_blank" name="ref_%5B1%5D_325580"></a><span style="color:#333333">虚拟内存盘是通过软件将一部分</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/1082.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">内存</span></a></span><span style="color:#333333">（</span><span style="color:#333333">RAM</span><span style="color:#333333">）模拟为</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/4480.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">硬盘</span></a></span><span style="color:#333333">来使用的一种技术。相对于直接的硬盘文件访问来说，这种技术可以极大的提高在其上进行的文件访问的速度。但是</span><span style="color:#333333">RAM</span><span style="color:#333333">的易失性也意味着当关闭电源后这部分数据将会丢失。但是在一般情况下，传递到</span><span style="color:#333333">RAM</span><span style="color:#333333">盘上的数据都是在硬盘或别处永久贮存的文件的一个拷贝。经由适当的配置，可以实现当系统重启后重新建立虚拟盘。</span><a target="_blank" name="sub325580_2"></a></p> 
<p><strong>原理和用途</strong></p> 
<p><span style="color:#333333">虚拟内存盘使用计算机内存的一部分来模拟一个硬盘。在</span><span style="color:#333333">DOS/windows</span><span style="color:#333333">下由相应的软件利用系统分配给它的内存空间来实现这种模拟。</span><span style="color:#333333">linux</span><span style="color:#333333">系统可以使用其</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/1366.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">内核</span></a></span><span style="color:#333333">支持的机制来实现。</span></p> 
<p><span style="color:#333333">虚拟内存盘还可以使用带有压缩机制的</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/266589.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">文件系统</span></a></span><span style="color:#333333">，例如：</span><span style="color:#333333">cramfs</span><span style="color:#333333">。这是因为一般的</span><span style="color:#333333">RAM</span><span style="color:#333333">盘的容量一般都较小，且</span><span style="color:#333333">RAM</span><span style="color:#333333">的存储空间比硬盘的要宝贵得多，价格也比硬盘要来得高，所以这样做是很合理的。</span></p> 
<p><span style="color:#333333">虚拟内存盘的一个用途是做为</span><span style="color:#333333">Web<a target="_blank" href="http://baike.baidu.com/view/907.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">缓存</span></a></span><span style="color:#333333">，这样可以提高加载页面的速度，因为硬盘的存取速度远小于内存（</span><span style="color:#333333">RAM</span><span style="color:#333333">）的存取速度</span><sup><span style="color:#3366CC">[2]</span></sup><a target="_blank" name="ref_%5B2%5D_325580"></a><span style="color:#333333">。由于</span><span style="color:#333333">RAM</span><span style="color:#333333">的易失性，这一措施还带来了安全性上的好处</span><sup><span style="color:#3366CC">[3]</span></sup><a target="_blank" name="ref_%5B3%5D_325580"></a><span style="color:#333333">。</span><a target="_blank" name="sub325580_3"></a></p> 
<p><strong>实现及软件</strong></p> 
<p><span style="color:#333333">DOS</span><span style="color:#333333">系统：</span><span style="color:#333333">XMSDSK</span><span style="color:#333333">；</span></p> 
<p><span style="color:#333333">Windows</span><span style="color:#333333">系统：</span><span style="color:#333333">VSuite</span><span style="color:#333333"> </span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/753453.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">Ramdisk</span></a></span><span style="color:#333333">；</span></p> 
<p><span style="color:#333333">linux</span><span style="color:#333333">系统：直接</span><span style="color:#333333"><a target="_blank" href="http://baike.baidu.com/view/902.htm" rel="nofollow noopener noreferrer"><span style="color:#136EC2">格式化</span></a></span><span style="color:#333333">并挂载</span><span style="color:#333333">/dev/ramX</span><span style="color:#333333">即可（</span><span style="color:#333333">X</span><span style="color:#333333">是内存盘序号）</span></p> 
<h3><a target="_blank" name="_Toc376251303"><span style="color:#9ABAE6">CramFS </span> </a><span style="color:#9ABAE6">文件系统的制作</span>  </h3> 
<p><span style="color:#659AE3">2010-11-0415:06:56|  </span><span style="color:#659AE3">分类：</span><span style="color:#659AE3"> </span><span style="color:#659AE3"><a target="_blank" href="http://vicyliu1984.blog.163.com/blog/#m=0&amp;t=1&amp;c=fks_084066080086080071084094081095087087084071085084085065" rel="nofollow noopener noreferrer" title="Linux file system 文件系统"><span style="color:#0F75DD">Linux file syste</span></a></span><span style="color:#184B75">|</span><span style="color:#0F75DD">字号</span><span style="color:#0F75DD"> </span><span style="color:#0F75DD">订阅</span></p> 
<p>1. 准备根文件系统</p> 
<p>    创建工作目录：$mkdir /rootfs</p> 
<p>    创建根文件系统的目录：$cd /rootfs</p> 
<p>                                            $mkdirbin dev etc home lib mnt proc sbin sys tmp var usr (12个目录）</p> 
<p>                                           $mkdir etc/init.d</p> 
<p>2. 创建设备文件</p> 
<p>    复制当前系统的设备文件：$cp -dpR /dev/rootfs/dev</p> 
<p>    如果使用 linux 2.6.x.x 内核，应该有节点 console、null 。如果在 /rootfs/dev 目录下没有这些节点，则转到 /rootfs/dev/目录来创建：</p> 
<p>                  $mknodconsole c 5 1</p> 
<p>                 $mknod null c 1 3</p> 
<p>    缺少这些设备，会在启动 shell 时出现提示“Warning: unable to open an initialconsole. Kernel panic- not syncing: Attempted to kill init！” 的错误。</p> 
<p>3. 准备目录系统启动所要的文件：linuxrc、rcS、inittab、fstab 四个文件。</p> 
<p>    linuxrc 文件（位于 "/"）的内容如下：</p> 
<p>        #！/bin/sh</p> 
<p>        echo  "mount /etc as ramfs"</p> 
<p>        /bin/mount -f -t cramfs -o remount, ro /dev/bon/2 /</p> 
<p>        /bin/mount -t ramfs ramfs /var</p> 
<p>        /bin/mkdir -p /var/tmp</p> 
<p>        /bin/mkdir -p /var/run</p> 
<p>         /bin/mkdir-p /var/log</p> 
<p>        /bin/mkdir -p /var/lock</p> 
<p>         /bin/mkdir-p /var/empty</p> 
<p>         #/bin/mount-t usbdevfs none /proc/bus/usb exec /sbin/init</p> 
<p>    rcS 文件位于/etc/init.d/)的内容如下：</p> 
<p>       #！/bin/sh</p> 
<p>        /bin/mount-a</p> 
<p>    这连个文件生成后，应该使其具有执行的权限，用chmod 来修改</p> 
<p>    inittab 文件位于 /etc 的内容如下：</p> 
<p>       #This is run first except when booting</p> 
<p>        ::sysinit:/etcinit.d/rcS</p> 
<p>       #Start an "askfirst" shell on the console</p> 
<p>       #::askfirst: ~/bin/bash</p> 
<p>       ::askfirst:~/bin/sh</p> 
<p>        #Stuffto do when restarting the init process</p> 
<p>       ::restart: /sbin/init</p> 
<p>        #Stuff to do before rebooting</p> 
<p>       :: ctrlaltdel: /sbin/reboot</p> 
<p>       :: shutdown: /bin/umount -a -r</p> 
<p>    fstab 文件位于 /etc 的内容如下所示：</p> 
<p>       none /proc proc defaults 0 0</p> 
<p>       none /dev/pts devpts mode=0622 0 0</p> 
<p>       tmpfs /dev/shm tmpfs defaults 0 0</p> 
<p>4. 将编译好的 BusyBox 的_install 目录下的三个文件夹用 tar 命令打包复制到 /rootfs 目录，解压后删除打包文件。</p> 
<p>5. 将一些常用的 lib 文件复制到 /rootfs/lib/ 目录下，例如： ld-2.5.so、libc-2.5.so等文件以及其符号链接。注意这些lib 文件指的是交叉编译工具链的 lib 文件，即位于 /arm-linux-gcc/lib 下的lib 文件。在复制时应该注意采用打包后解包方式复制，以保证符号链接的正确性和完整性。</p> 
<p>6. 生成CramFS 文件系统映像文件 cram.img</p> 
<p>    $ mkcramfs/rootfs cram.img</p> 
<p>    将工作目录 rootfs 作为根目录制作 CramFS 文件系统，这将经历一个处理和压缩的过程。压缩完成后，就可以测试下生成的 cram.img 文件了。</p> 
<p>    下面命令挂载 CramFS 的文件系统：</p> 
<p>    $mount -o loop-t cramfs /cram.img/mnt           将cram.img 文件系统加载到 /mnt</p> 
<p>    $ ls /mnt</p> 
<p>7. 将映像文件 cram.img 下载并写入目标板的 root 分区，正确配置 Linux 的内核启动参数，启动。                                 </p> 
<h3><a target="_blank" name="_Toc376251304">【摘】编程质量--内存移动函数</a>  </h3> 
<p><span style="color:#4992B4">2009-11-0811:39:34|  </span><span style="color:#4992B4">分类：</span><span style="color:#4992B4"> </span><span style="color:#4992B4"><a target="_blank" href="http://blog.163.com/feyeye@126/blog/#m=0&amp;t=1&amp;c=fks_087069080095083064081087084095080085084066084087086074" rel="nofollow noopener noreferrer" title="c语言杂记"><span style="color:#0C4468">c</span><span style="color:#0C4468">语言杂记</span></a></span><span style="color:#7196A7">|</span><span style="color:#0C4468">字号</span><span style="color:#0C4468"> </span><span style="color:#0C4468">订阅</span></p> 
<p> </p> 
<p>写一个函数，完成内存移动，并为其写一个简单的测试用例来进行测试。</p> 
<p>够简单的吧？有的同学很快就写出了答案，详见程序清单1与程序清单2。</p> 
<p>程序清单 1 V0.1版程序</p> 
<p>void MyMemMove(char *dst,char *src,intcount)</p> 
<p>{<!-- --></p> 
<p>while(count--)</p> 
<p>{<!-- --></p> 
<p>*dst++ = *src++;</p> 
<p>}</p> 
<p>}</p> 
<p>程序清单 2 测试用例</p> 
<p>void Test()</p> 
<p>{<!-- --></p> 
<p>char p1[256] = ”hello,world!”;</p> 
<p>char p2[256] = {0};</p> 
<p>MyMemMove(p2,p1,strlen(p1));</p> 
<p>printf(“%s”,p2);</p> 
<p>}</p> 
<p>客观地讲，相比那些交白卷或者函数声明都不会写的同学来说，能够写出这段代码的同学已经非常不错了，至少在C语言这门课程上已经达到了现行高校的教育目标，但是离企业的用人要求还有一定的距离。我们不妨将上面的程序称为V0.1版本，看看还有没有什么地方可以改进。</p> 
<p>首先我们看看函数声明是否合理，V0.1版的程序将源地址和目的地址都用char *来表示，这样当然也没有什么问题，但是让其他人使用起来却很不方便，假如现在要将count个连续的结构体对象移动到另外一个地方去，如果要使用v0.1的程序的话，正确的写法如下：</p> 
<p>MyMemMove((char *)dst,(char *)src,sizeof(TheStruct)*count)</p> 
<p>也就是说我们需要将结构体指针强制转换成char * 才能够正常工作，这样除了字符串以外其它的类型都不可避免地要进行指针强制转换，否则编译器就会呱呱叫，比如在VC++2008下就会出现这样的错误：</p> 
<p>error C2664: 'MyMemMove' : cannot convertparameter 1 from 'TheStruct *' to 'char *'</p> 
<p>那么如何解决这个问题呢？其实很简单，我们知道有一种特别的指针，任何类型的指针都可以对它赋值，那就是void *，所以应该将源地址和目的地址都用void*来表示。当然函数体的内容也要作相应的改变，这样我们就得到了V0.2版的程序。</p> 
<p>程序清单 3 V0.2版程序</p> 
<p>void MyMemMove(void *dst,void *src,intcount)</p> 
<p>{<!-- --></p> 
<p>while (count--)</p> 
<p>{<!-- --></p> 
<p>*(char *)dst = *(char *)src;</p> 
<p>dst = (char *)dst + 1;</p> 
<p>src = (char *)src + 1;</p> 
<p>}</p> 
<p>}</p> 
<p>有的同学可能会问，这里面不是还有指针强制转换吗？只不过是换了地方。没错，强制指针转换确实是从使用者的代码转移到了库的代码里，但我们可以将MyMemMove理解为库，而将Test理解为使用者，事实上通过调整之后的效果却有天壤之别，V0.1是一逸永劳，而V0.2是一劳永逸！</p> 
<p>还有几个细节需要注意，为了实现链式表达式，我们应该将返回值也改为void *。此外，如果我们不小心将“*(char*)dst = *(char *)src;”写反了，写成“*(char *)src = *(char *)dst;”编译照样通过，而为了找出这个错误又得花费不少时间。注意到src所指向的内容在这个函数内不应该被改变，所有对src所指的内容赋值都应该被禁止，所以这个参数应该用const修饰，如果有类似的错误在编译时就能够被发现：</p> 
<p>error C3892: 'src' : you cannot assign to avariable that is const</p> 
<p>作为程序员犯错误在所难免，但是我们可以利用相对难犯错误的机器，也就是编译器来降低犯错误的概率，这样我们就得到了V0.3版的程序。</p> 
<p>程序清单 4 V0.3版程序</p> 
<p>void * MyMemMove(void *dst,const void*src,int count)</p> 
<p>{<!-- --></p> 
<p>void *ret=dst;</p> 
<p>while (count--)</p> 
<p>{<!-- --></p> 
<p>*(char *)dst = *(char *)src;</p> 
<p>dst = (char *)dst + 1;</p> 
<p>src = (char *)src + 1;</p> 
<p>}</p> 
<p>return ret;</p> 
<p>}</p> 
<p>现在再来考虑这样一种情况，有使用者这样调用库：MyMemMove(NULL,src, count)，这是完全可能的，因为一般来说这些地址都是程序计算出来的，那就难免会算错，出现零地址或者其它的非法地址也不足为奇。可以预料的是，如果出现这种情况的话，则程序马上就会down掉，更糟糕的是你不知道错误出在哪里，于是不得不投入大量的精力在浩瀚的代码中寻找bug。解决这类问题的通用办法是对输入参数作合法性检查，也就是V0.4版程序。</p> 
<p>程序清单 5 V0.4版程序</p> 
<p>void * MyMemMove(void *dst,const void*src,int count)</p> 
<p>{<!-- --></p> 
<p>void *ret=dst;</p> 
<p>if (NULL==dst||NULL ==src)</p> 
<p>{<!-- --></p> 
<p>return dst;</p> 
<p>}</p> 
<p>while (count--)</p> 
<p>{<!-- --></p> 
<p>*(char *)dst = *(char *)src;</p> 
<p>dst = (char *)dst + 1;</p> 
<p>src = (char *)src + 1;</p> 
<p>}</p> 
<p>return ret;</p> 
<p>}</p> 
<p>上面之所以写成“if(NULL==dst||NULL ==src)”而不是写成“if (dst == NULL || src == NULL)”，也是为了降低犯错误的概率。我们知道，在C语言里面“==”和“=”都是合法的运算符，如果我们不小心写成了“if (dst = NULL || src = NULL)”还是可以编译通过，而意思却完全不一样了，但是如果写成“if (NULL=dst||NULL =src)”，则编译的时候就通不过了，所以我们要养成良好的程序设计习惯：常量与变量作条件判断时应该把常量写在前面。</p> 
<p>V0.4版的代码首先对参数进行合法性检查，如果不合法就直接返回，这样虽然程序dwon掉的可能性降低了，但是性能却大打折扣了，因为每次调用都会进行一次判断，特别是频繁的调用和性能要求比较高的场合，它在性能上的损失就不可小觑。</p> 
<p>如果通过长期的严格测试，能够保证使用者不会使用零地址作为参数调用MyMemMove函数，则希望有简单的方法关掉参数合法性检查。我们知道宏就有这种开关的作用，所以V0.5版程序也就出来了。</p> 
<p>程序清单 6 V0.5版程序</p> 
<p>void * MyMemMove(void *dst,const void*src,int count)</p> 
<p>{<!-- --></p> 
<p>void *ret=dst;</p> 
<p>#ifdef DEBUG</p> 
<p>if (NULL==dst||NULL ==src)</p> 
<p>{<!-- --></p> 
<p>return dst;</p> 
<p>}</p> 
<p>#endif</p> 
<p>while (count--)</p> 
<p>{<!-- --></p> 
<p>*(char *)dst = *(char *)src;</p> 
<p>dst = (char *)dst + 1;</p> 
<p>src = (char *)src + 1;</p> 
<p>}</p> 
<p>return ret;</p> 
<p>}</p> 
<p>如果在调试时我们加入“#defineDEBUG”语句，增强程序的健壮性，那么在调试通过后我们再改为“#undef DEBUG”语句，提高程序的性能。事实上在标准库里已经存在类似功能的宏：assert，而且更加好用，它还可以在定义DEBUG时指出代码在那一行检查失败，而在没有定义DEBUG时完全可以把它当作不存在。assert(_Expression)的使用非常简单，当_Expression为0时，调试器就可以出现一个调试错误，有了这个好东西代码就容易多了。</p> 
<p>程序清单 7 V0.6版程序</p> 
<p>void * MyMemMove(void *dst,const void*src,int count)</p> 
<p>{<!-- --></p> 
<p>assert(dst);</p> 
<p>assert(src);</p> 
<p>void *ret=dst;</p> 
<p>while (count--)</p> 
<p>{<!-- --></p> 
<p>*(char *)dst = *(char *)src;</p> 
<p>dst = (char *)dst + 1;</p> 
<p>src = (char *)src + 1;</p> 
<p>}</p> 
<p>return ret;</p> 
<p>}</p> 
<p>一旦调用者的两个指针参数其中一个为零，就会出现如图1所示的错误，而且指示了哪一行非常容易查错。</p> 
<p>图 1 assert（NULL）时，显示错误</p> 
<p>到目前为止，在语言层面上，我们的程序基本上没有什么问题了，那么是否真的就没有问题了呢？这就要求程序员从逻辑上考虑了，这也是优秀程序员必须具备的素质，那就是思维的严谨性，否则程序就会有非常隐藏的bug，就这个例子来说，如果用户用下面的代码来调用你的程序。</p> 
<p>程序清单 8 重叠的内存测试</p> 
<p>void Test()</p> 
<p>{<!-- --></p> 
<p>char p [256]= "hello,world!";</p> 
<p>MyMemMove(p+1,p,strlen(p)+1);</p> 
<p>printf("%s\n",p);</p> 
<p>}</p> 
<p>如果你身边有电脑，你可以试一下，你会发现输出并不是我们期待的“hhello,world!”（在“hello world！”前加个h），而是“hhhhhhhhhhhhhh”，这是什么原因呢？原因出在源地址区间和目的地址区间有重叠的地方，V0.6版的程序无意之中将源地址区间的内容修改了！有些反映快的同学马上会说我从高地址开始拷贝。粗略地看，似乎能解决这个问题，虽然区间是重叠了，但是在修改以前已经拷贝了，所以不影响结果。但是仔细一想，这其实是犯了和上面一样的思维不严谨的错误，因为用户这样调用还是会出错：</p> 
<p>MyMemMove( p, p+1, strlen(p)+1);</p> 
<p>所以最完美的解决方案还是判断源地址和目的地址的大小，才决定到底是从高地址开始拷贝还是低地址开始拷贝，所以V0.7顺利成章地出来了。</p> 
<p>程序清单 9 V0.7版程序</p> 
<p>void * MyMemMove(void *dst,const void*src,int count)</p> 
<p>{<!-- --></p> 
<p>assert(dst);</p> 
<p>assert(src);</p> 
<p>void * ret = dst;</p> 
<p>if (dst &lt;= src || (char *)dst &gt;=((char *)src + count)) {<!-- --></p> 
<p>while (count--) {<!-- --></p> 
<p>*(char *)dst = *(char *)src;</p> 
<p>dst = (char *)dst + 1;</p> 
<p>src = (char *)src + 1;</p> 
<p>}</p> 
<p>}</p> 
<p>else {<!-- --></p> 
<p>dst = (char *)dst + count - 1;</p> 
<p>src = (char *)src + count - 1;</p> 
<p>while (count--) {<!-- --></p> 
<p>*(char *)dst = *(char *)src;</p> 
<p>dst = (char *)dst - 1;</p> 
<p>src = (char *)src - 1;</p> 
<p>}</p> 
<p>}</p> 
<p>return(ret);</p> 
<p>}</p> 
<p>经过以上7个版本的修改，我们的程序终于可以算是“工业级”了。回头再来看看前面的测试用例，就会发现那根本就算不上是测试用例，因为它只调用了最正常的一种情况，根本达不到测试的目的。有了上面的经历，测试用例也就相应地出现了，我们不妨用字符数组来模拟内存。</p> 
<p>程序清单 10 相对全面的测试用例</p> 
<p>void Test()</p> 
<p>{<!-- --></p> 
<p>char p1[256] = "hello,world!";</p> 
<p>char p2[256] = {0};</p> 
<p>MyMemMove(p2,p1,strlen(p1)+1);</p> 
<p>printf("%s\n",p2);</p> 
<p>MyMemMove(NULL,p1,strlen(p1)+1);</p> 
<p>MyMemMove(p2,NULL,strlen(p1)+1);</p> 
<p>MyMemMove(p1+1,p1,strlen(p1)+1);</p> 
<p>printf("%s\n",p1);</p> 
<p>MyMemMove(p1,p1+1,strlen(p1)+1);</p> 
<p>printf("%s\n",p1);</p> 
<p>}</p> 
<p>初写代码的时候，往往考虑的是程序正常工作的情况该怎么处理。当你有了几年经验，写了几万行代码后就会发现，处理异常部分的分支代码有时比正常的主干线代码还要多，而这也正是高质量程序和一般程序拉开差距的地方。如果把软件产品当作一台机器，那么这样一个个细小的函数和类就是零部件，只有当这些零部件质量都很高时，整个软件产品的质量才会高，不然就会像前几年的国产轿车一样，今天这个零件罢工明天那个零件休息。而作为检验这些零部件的测试用例，一定要模拟各种恶劣的环境，将零部件隐藏的缺陷暴露出来，从这意义上说，编写测试用例的程序员要比软件设计的程序员思维要更严谨才行</p> 
<p> </p> 
<h3><a target="_blank" href="http://blog.csdn.net/tsuliuchao/article/details/8131537" rel="noopener noreferrer"><span style="color:#666666">vim</span><span style="color:#666666">与复制，删除，粘贴，块操作以及快速替换功能</span></a><a target="_blank" name="_Toc376251305"></a></h3> 
<p><span style="color:#999999">分类：</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/tsuliuchao/article/category/533866" rel="noopener noreferrer"><span style="color:#6A3906">Linux</span><span style="color:#6A3906">学习</span></a></span><span style="color:#999999">2012-10-3110:48</span><span style="color:#999999"> </span><span style="color:#999999">2419</span><span style="color:#999999">人阅读</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/tsuliuchao/article/details/8131537#comments" rel="noopener noreferrer"><span style="color:#6A3906">评论</span></a></span>(0)<span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" title="收藏"><span style="color:#6A3906">收藏</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/tsuliuchao/article/details/8131537#report" title="举报" rel="noopener noreferrer"><span style="color:#6A3906">举报</span></a></span></p> 
<p><span style="color:#362E2B">目录</span><span style="color:#362E2B"><a target="_blank" href="http://blog.csdn.net/tsuliuchao/article/details/8131537" title="系统根据文章中H1到H6标签自动生成文章目录" rel="noopener noreferrer"><span style="color:#6A3906">(?)</span></a><a target="_blank" href="http://blog.csdn.net/tsuliuchao/article/details/8131537" title="展开" rel="noopener noreferrer"><span style="color:#6A3906">[+]</span></a></span></p> 
<p><span style="color:#362E2B; background:red">掌握如下命令有什么好办法，我可以告诉你唯手熟尔！！</span><span style="color:#362E2B; background:#CC0000">多看多练</span><span style="color:#362E2B"><br> </span><span style="color:#362E2B">对于</span><span style="color:#362E2B">VIM</span><span style="color:#362E2B">而言</span><span style="color:#362E2B">,</span><span style="color:#362E2B">复制，删除，粘贴的操作应该是非常多的。这次也做一个总结，关于处理</span><span style="color:#362E2B">VIM</span><span style="color:#362E2B">下的复制，删除，粘贴等操作。</span><span style="color:#362E2B"><br> </span><span style="color:#362E2B">学会使用帮助文件，命令的帮助入口，就是</span><span style="color:#362E2B">”<strong>:help </strong></span><strong><span style="color:#362E2B">命令名</span></strong><span style="color:#362E2B">“</span><span style="color:#362E2B">。例如，对于</span><span style="color:#362E2B">”<strong>j</strong>“</span><span style="color:#362E2B">命令，查看它的帮助，使用</span><span style="color:#362E2B">”<strong>:help j</strong>“</span></p> 
<h4><a target="_blank" name="_Toc376251306"></a><a target="_blank" name="t0"></a>先谈一下基于块的复制，删除，粘贴操作</h4> 
<div align="center"> 
 <span style="color:#362E2B"></span> 
 <hr size="2" width="100%" align="center"> 
</div> 
<p><a target="_blank" name="_Toc376251307">使用块选的好处</a><span style="color:#362E2B">：</span><span style="color:#362E2B"><br> </span><span style="color:#362E2B">对于</span><span style="color:#362E2B">vim</span><span style="color:#362E2B">几乎提到的都是以行为单位的操作。那么如果我想要搞定的是一个区块范围呢</span><span style="color:#362E2B">(</span><span style="color:#362E2B">我特别喜欢像使用</span><span style="color:#362E2B">windows</span><span style="color:#362E2B">下的文本编辑器一样去使用块的选择</span></p> 
<p><span style="color:#362E2B">当我们按下</span><span style="color:#362E2B">v </span><span style="color:#362E2B">戒者</span><span style="color:#362E2B">V </span><span style="color:#362E2B">戒者</span><span style="color:#362E2B">[Ctrl]+v </span> <span style="color:#362E2B">时，</span><span style="color:#362E2B">这个时候光标移劢过癿地方就会开始反白。</span></p> 
<p><a target="_blank" name="t1"></a><span style="color:#666666">区块选择的按键意义</span> 【不使用鼠标，来选择块】</p> 
<div align="center"> 
 <span style="color:#362E2B"></span> 
 <hr size="2" width="100%" align="center"> 
</div> 
<p><span style="color:#FF6666">v                                    </span><span style="color:#FF6666">字符选择，会将光标经过癿地方反白选择！</span></p> 
<p><span style="color:#FF6666">V(</span><span style="color:#FF6666">大写</span><span style="color:#FF6666">)                         </span><span style="color:#FF6666">行选择，会将光标经过癿行反白选择！（常用，配合上下左右键，进行区域选择，很爽！！！）</span></p> 
<p><span style="color:#FF6666">[Ctrl]+v                          </span><span style="color:#FF6666">区块选择，可以用长方形癿方式选择资料</span></p> 
<p><span style="color:#FF6666">y                                    </span><span style="color:#FF6666">将反白癿地方复制起来</span><span style="color:#FF6666">d </span><span style="color:#FF6666">将反白癿地方删除掉</span></p> 
<p><span style="color:#362E2B"><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/myjavawork/201103/201103312318016049.png" rel="nofollow noopener noreferrer"></a></span></p> 
<h4><a target="_blank" name="_Toc376251308">批量替换列块</a></h4> 
<p><span style="color:#362E2B">原始状态：</span></p> 
<p><span style="color:#362E2B">将光标指到第一行</span><span style="color:#362E2B">V</span><span style="color:#362E2B">处，然后</span><span style="color:#362E2B">ctrl-v</span><span style="color:#362E2B">选择，如下</span></p> 
<p><span style="color:#362E2B">选择完成后，接着按</span><span style="color:#362E2B">c</span><span style="color:#362E2B">键，输入你要替换后的文字，最后</span><span style="color:#362E2B">ESC,</span><span style="color:#362E2B">看看成果如下，</span></p> 
<p><a target="_blank" name="t2"></a><span style="color:#666666">以行或者是以单词为单位的删除操作</span></p> 
<div align="center"> 
 <span style="color:#362E2B"></span> 
 <hr size="2" width="100%" align="center"> 
</div> 
<p><span style="color:red">对字符操作：</span><span style="color:#362E2B"><br> </span><span style="color:#330099">x,X                </span><span style="color:#330099">在一行字当中，</span><span style="color:#330099">x</span><span style="color:#330099">为向后删除一个字符</span><span style="color:#330099">(</span><span style="color:#330099">相当亍</span><span style="color:#330099">[del] </span><span style="color:#330099">按键</span><span style="color:#330099">)</span><span style="color:#330099">，</span><strong><span style="color:#330099">X</span></strong><span style="color:#330099"> </span><span style="color:#330099">为向前删除一个字符</span><span style="color:#330099">(</span><span style="color:#330099">相当亍</span><span style="color:#330099">[backspace] </span><span style="color:#330099">亦即是退格键</span><span style="color:#330099">)(</span><span style="color:#330099">常用</span><span style="color:#330099">)</span></p> 
<p><span style="color:#330099">nx                  n </span><span style="color:#330099">为数字，连续向后删除</span><span style="color:#330099">n </span><span style="color:#330099">个字符。丼例来说，我要连续删除</span><span style="color:#330099">10 </span><span style="color:#330099">个字符，</span><span style="color:#330099">『</span><span style="color:#330099">10x</span><span style="color:#330099">』。</span></p> 
<p><span style="color:#330099">d$                  </span><span style="color:#330099">删除游标所在处，到该行行尾的所有字符</span></p> 
<p><span style="color:#330099">d0                  </span><span style="color:#330099">删除游标所在处</span><span style="color:#330099">，到该行行首的所有字符</span><span style="color:#362E2B"><br> </span><span style="color:red"> </span><span style="color:red">对行操作：</span></p> 
<p><span style="color:#330099">dd                   </span><span style="color:#330099">删除游标所在的那一整列</span><span style="color:#330099">(</span><span style="color:#330099">常用</span><span style="color:#330099">)</span></p> 
<p><span style="color:#330099">ndd                 n </span><span style="color:#330099">为数字。删除光标所在的行向下</span><span style="color:#330099">n</span><span style="color:#330099">行，例如</span><span style="color:#330099"> 20dd </span><span style="color:#330099">则是删除</span><span style="color:#330099"> 20</span><span style="color:#330099">行</span><span style="color:#330099"> (</span><span style="color:#330099">常用</span><span style="color:#330099">)</span></p> 
<p><span style="color:#330099">d1G                </span><span style="color:#330099">删除光标所在到第一行的所有数据</span></p> 
<p><span style="color:#330099">dG                  </span><span style="color:#330099">删除光标所在到最后一行的所有数据</span></p> 
<h4><a target="_blank" name="_Toc376251309">与移动相关</a></h4> 
<div align="center"> 
 <span style="color:#362E2B"></span> 
 <hr size="2" width="100%" align="center"> 
</div> 
<p><span style="color:#000099">移动到行首：</span><span style="color:#000099">gg</span></p> 
<p><span style="color:#000099">移动到行尾</span><span style="color:#000099">：字符</span><span style="color:#000099">$</span></p> 
<p><span style="color:#362E2B">       </span><span style="color:#362E2B">小注</span><span style="color:#362E2B">:</span><span style="color:#362E2B">命令</span><span style="color:#362E2B">”<strong>G</strong>“</span><span style="color:#362E2B">前可以加上数字，在这里，数字的含义并不是倍数，而是你打算跳转的行号。例如，你想跳转到文件的第</span><span style="color:#362E2B">1234</span><span style="color:#362E2B">行，只需输入</span><span style="color:#362E2B">”<strong>1234G</strong>“</span><span style="color:#362E2B">。</span></p> 
<p><span style="color:#000099">字符</span><span style="color:#000099">0</span><span style="color:#000099">：第一个非空字符前</span></p> 
<p><span style="color:#000099">字符</span><span style="color:#000099">^</span><span style="color:#000099">：第一个非空字符上</span></p> 
<p><span style="color:#000099">上下左右：</span><span style="color:#000099">h,j, k, l</span></p> 
<p><span style="color:#362E2B">       </span><span style="color:#362E2B">小注</span><span style="color:#362E2B">:</span><span style="color:#362E2B">如同许多</span><span style="color:#362E2B">vim</span><span style="color:#362E2B">命令一样，可以在这些键前加一个数字，表示移动的倍数。例如，</span><span style="color:#362E2B">”<strong>10j</strong>“</span><span style="color:#362E2B">表示向下移动</span><span style="color:#362E2B">10</span><span style="color:#362E2B">行；</span><span style="color:#362E2B">”<strong>10l</strong>“</span><span style="color:#362E2B">表示向右移动</span><span style="color:#362E2B">10</span><span style="color:#362E2B">列。</span></p> 
<p><span style="color:#362E2B">翻页：</span></p> 
<p><span style="color:#362E2B">       </span><span style="color:#362E2B">小注</span><span style="color:#362E2B">:</span><span style="color:#362E2B">通常使</span><span style="color:red">用</span><strong><span style="color:red">CTRL-B</span></strong><span style="color:red">和</span><strong><span style="color:red">CTRL-F</span></strong><span style="color:#362E2B">来进行翻页，它们的功能等同于</span><span style="color:#362E2B">PageUp</span><span style="color:#362E2B">和</span><span style="color:#362E2B">PageDown</span><span style="color:#362E2B">。</span><strong><span style="color:#FF6666">CTRL-B</span></strong><span style="color:#FF6666">和</span><strong><span style="color:#FF6666">CTRL-F</span></strong><span style="color:#362E2B">前也可以加上数字，来表示向上或向下翻多少页</span></p> 
<p><span style="color:#362E2B">      </span><span style="color:#362E2B">小注</span><span style="color:#362E2B">: </span><span style="color:#362E2B">在文件中移动，你可能会迷失自己的位置，这时使用</span><span style="color:#362E2B">”<strong>CTRL-G</strong>“</span><span style="color:#362E2B">命令，查看一下自己位置。这个命令会显示出光标的位置及其它信息。为了避免迷失，你可以打开行号显示；使用</span><span style="color:#362E2B">”<strong>:set number</strong>“</span><span style="color:#362E2B">命令后，会在每一行前显示出行号，可以更方便的定位的跳转（</span><strong><span style="color:#362E2B">:help‘number’</span></strong><span style="color:#362E2B">）</span></p> 
<p><span style="color:#000099">移动到指定字符：</span><span style="color:#000099"> </span><span style="color:#000099">使用</span><span style="color:#000099">f, t, F,T</span><span style="color:#000099">命令。</span><span style="color:#000099">  </span><span style="color:#3333FF">  </span></p> 
<p><span style="color:#362E2B">        </span><span style="color:#362E2B">小注：</span><span style="color:#362E2B">“<strong>f</strong>“</span><span style="color:#362E2B">命令移动到光标右边的指定字符上，例如，</span><span style="color:#362E2B">”<strong>fx</strong>“</span><span style="color:#362E2B">，会把移动到光标右边的第一个</span><span style="color:#362E2B">’x'</span><span style="color:#362E2B">字符上。</span><span style="color:#362E2B">”<strong>F</strong>“</span><span style="color:#362E2B">命令则反方向查找，也就是移动到光标左边的指定字符上。</span></p> 
<p><span style="color:#362E2B">“<strong>t</strong>“</span><span style="color:#362E2B">命令和</span><span style="color:#362E2B">”<strong>f</strong>“</span><span style="color:#362E2B">命令的区别在于，它移动到光标右边的指定字符之前。例如，</span><span style="color:#362E2B">”<strong>tx</strong>“</span><span style="color:#362E2B">会移动到光标右边第一个</span><span style="color:#362E2B">’x'</span><span style="color:#362E2B">字符的前面。</span><span style="color:#362E2B">”<strong>T</strong>“</span><span style="color:#362E2B">命令是</span><span style="color:#362E2B">”<strong>t</strong>“</span><span style="color:#362E2B">命令的反向版本，它移动到光标右边的指定字符之后。</span></p> 
<p><span style="color:#362E2B">这四个命令只在当前行中移动光标，光标不会跨越回车换行符。</span></p> 
<p><span style="color:#362E2B">可以在命令前面使用数字，表示倍数。例如，</span><span style="color:#362E2B">”<strong>3fx</strong>“</span><span style="color:#362E2B">表示移动到光标右边的第</span><span style="color:#362E2B">3</span><span style="color:#362E2B">个</span><span style="color:#362E2B">’x'</span><span style="color:#362E2B">字符上。</span></p> 
<p><span style="color:#362E2B">“<strong>;</strong>“</span><span style="color:#362E2B">命令重复前一次输入的</span><span style="color:#362E2B">f,t, F, T</span><span style="color:#362E2B">命令，而</span><span style="color:#362E2B">”<strong>,</strong>“</span><span style="color:#362E2B">命令会反方向重复前一次输入的</span><span style="color:#362E2B">f,t, F, T</span><span style="color:#362E2B">命令。这两个命令前也可以使用数字来表示倍数。</span></p> 
<p><span style="color:#362E2B"> </span></p> 
<h4><a target="_blank" name="_Toc376251310">与复制相关</a></h4> 
<div align="center"> 
 <span style="color:#362E2B"></span> 
 <hr size="2" width="100%" align="center"> 
</div> 
<p><span style="color:#330099">yy                </span><span style="color:#330099">复制游标所在癿那一行</span><span style="color:#330099">(</span><span style="color:#330099">常用</span><span style="color:#330099">)</span></p> 
<p><span style="color:#330099">y1G              </span><span style="color:#330099">复制光标所在列到第一列癿所有数据</span></p> 
<p><span style="color:#330099">yG               </span><span style="color:#330099">复制光标所在列到最后一列癿所有数据</span></p> 
<p><span style="color:#330099">y0               </span><span style="color:#330099">复制光标所在癿那个字符到该行行首癿所有数据</span></p> 
<p><span style="color:#330099">y$               </span><span style="color:#330099">复制光标所在癿那个字符到该行行尾癿所有数据</span></p> 
<p><span style="color:#362E2B"> </span></p> 
<h4><a target="_blank" name="_Toc376251311"></a><a target="_blank" name="t3"></a>复原以及重做操作</h4> 
<div align="center"> 
 <span style="color:#362E2B"></span> 
 <hr size="2" width="100%" align="center"> 
</div> 
<p><span style="color:#000066">u </span><span style="color:#000066">复原前一个劢作。</span><span style="color:#000066">(</span><span style="color:#000066">常用</span><span style="color:#000066">)</span></p> 
<p><span style="color:#000066">[Ctrl]+r </span><span style="color:#000066">重做上一个动作。</span><span style="color:#000066">(</span><span style="color:#000066">常用</span><span style="color:#000066">)</span></p> 
<h4><a target="_blank" name="_Toc376251312"></a><a target="_blank" name="t4"></a>替换模式</h4> 
<div align="center"> 
 <span style="color:#362E2B"></span> 
 <hr size="2" width="100%" align="center"> 
</div> 
<p><span style="color:#362E2B"><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/myjavawork/201103/201103312318017967.png" rel="nofollow noopener noreferrer"></a></span></p> 
<p><span style="color:#362E2B"> </span></p> 
<p><span style="color:#330099">关键是</span><span style="color:#330099">“R “ </span> <span style="color:#330099">取代模式</span><span style="color:#330099">,</span><span style="color:#330099">它可以快速的替换以及插入数据</span><span style="color:#330099">(</span><span style="color:#330099">类似于</span><span style="color:#330099"> word</span><span style="color:#330099">中的</span><span style="color:#330099">即点即输</span><span style="color:#330099">)</span><span style="color:#330099">的功能。</span></p> 
<h4><a target="_blank" name="_Toc376251313">移动光标</a></h4> 
<table border="1" cellspacing="1" cellpadding="0" width="259"><tbody><tr><td> <p>命令</p> </td><td> <p>功能</p> </td></tr><tr><td> <p>h</p> </td><td> <p>光标左移</p> </td></tr><tr><td> <p>l(或空格键)</p> </td><td> <p>光标右移</p> </td></tr><tr><td> <p>k(或[Ctrl+p])</p> </td><td> <p>光标上移</p> </td></tr><tr><td> <p>j(或[Ctrl+n])</p> </td><td> <p>光标下移</p> </td></tr><tr><td> <p>[Ctrl+f]</p> </td><td> <p>向前翻页</p> </td></tr><tr><td> <p>[Ctrl+b]</p> </td><td> <p>向后翻页</p> </td></tr><tr><td> <p>[Ctrl+d]</p> </td><td> <p>向前翻半页</p> </td></tr><tr><td> <p>[Ctrl+u]</p> </td><td> <p>向后翻半页</p> </td></tr><tr><td> <p>1G</p> </td><td> <p>跳到文件首</p> </td></tr><tr><td> <p>40G</p> </td><td> <p>跳到第40行</p> </td></tr><tr><td> <p>G</p> </td><td> <p>跳到文件尾</p> </td></tr><tr><td> <p>[Ctrl+g]</p> </td><td> <p>显示当前行号及文件的百分比</p> </td></tr><tr><td> <p>:set number</p> </td><td> <p>显示所有带行号的行</p> </td></tr></tbody></table> 
<p><a target="_blank" name="_Toc376251314">在一行内移动光标</a><br> <span style="color:#362E2B">B</span><span style="color:#362E2B">、</span><span style="color:#362E2B">E</span><span style="color:#362E2B">和</span><span style="color:#362E2B">W</span><span style="color:#362E2B">命令的作用与</span><span style="color:#362E2B">b</span><span style="color:#362E2B">、</span><span style="color:#362E2B">e</span><span style="color:#362E2B">和</span><span style="color:#362E2B">w</span><span style="color:#362E2B">的作用一样，只是后者忽略了标点符号。</span></p> 
<table border="1" cellspacing="1" cellpadding="0" width="260"><tbody><tr><td> <p>命令</p> </td><td> <p>功能</p> </td></tr><tr><td> <p>b</p> </td><td> <p>向后移动到单词首</p> </td></tr><tr><td> <p>e</p> </td><td> <p>向前移动到单词尾</p> </td></tr><tr><td> <p>w</p> </td><td> <p>向前移动到单词首</p> </td></tr><tr><td> <p>0或|</p> </td><td> <p>移动到行首</p> </td></tr><tr><td> <p>30|</p> </td><td> <p>移动到第30列</p> </td></tr><tr><td> <p>^</p> </td><td> <p>移动到本行的第一个单词的首字符</p> </td></tr><tr><td> <p>$</p> </td><td> <p>移动到行尾</p> </td></tr></tbody></table> 
<h4><a target="_blank" name="_Toc376251315">插入文本</a></h4> 
<table border="1" cellspacing="1" cellpadding="0" width="261"><tbody><tr><td> <p>命令</p> </td><td> <p>功能</p> </td></tr><tr><td> <p>i</p> </td><td> <p>在光标的左侧插入字符</p> </td></tr><tr><td> <p>20i-[Esc]</p> </td><td> <p>插入20个连字符</p> </td></tr><tr><td> <p>I</p> </td><td> <p>在行首插入字符</p> </td></tr><tr><td> <p>[Ctrl+v][Ctrl+b]</p> </td><td> <p>插入[Ctrl+b]字符</p> </td></tr><tr><td> <p>[Ctrl+v][Esc]</p> </td><td> <p>插入[Esc]字符</p> </td></tr><tr><td> <p>a</p> </td><td> <p>在光标的右侧添加文本</p> </td></tr><tr><td> <p>A</p> </td><td> <p>在行尾添加文本</p> </td></tr><tr><td> <p>o</p> </td><td> <p>在当前行下面插入一空行</p> </td></tr><tr><td> <p>O</p> </td><td> <p>在当前行上面插入一空行</p> </td></tr><tr><td> <p>:set showmode</p> </td><td> <p>当vi处在输入模式下时显示提示信息</p> </td></tr><tr><td> <p>:set sm</p> </td><td> <p>即时显示配对的)或}</p> </td></tr><tr><td> <p>:set ts=n</p> </td><td> <p>把制表符设置为n(默认为8)</p> </td></tr><tr><td> <p>:set ai</p> </td><td> <p>下一行从前一行的缩进位置开始</p> </td></tr></tbody></table> 
<h4><a target="_blank" name="_Toc376251316">删除和移动文本</a></h4> 
<table border="1" cellspacing="1" cellpadding="0" width="263"><tbody><tr><td> <p>命令</p> </td><td> <p>功能</p> </td></tr><tr><td> <p>x</p> </td><td> <p>删除光标所在的字符</p> </td></tr><tr><td> <p>6x</p> </td><td> <p>删除光标位置的字符以及右侧的5个字符</p> </td></tr><tr><td> <p>X</p> </td><td> <p>删除前一个字符</p> </td></tr><tr><td> <p>dd</p> </td><td> <p>删除当前行</p> </td></tr><tr><td> <p>4dd</p> </td><td> <p>删除4行</p> </td></tr><tr><td> <p>64dd</p> </td><td> <p>删除64行</p> </td></tr><tr><td> <p>dw</p> </td><td> <p>删除一个单词</p> </td></tr><tr><td> <p>d0</p> </td><td> <p>删除到行首</p> </td></tr><tr><td> <p>d$</p> </td><td> <p>删除到行尾</p> </td></tr><tr><td> <p>d</p> </td><td> <p>删除一个区域(只用于vim)</p> </td></tr><tr><td> <p>p</p> </td><td> <p>把被剪切的文本粘贴到下面（整行）或右侧（部分行）</p> </td></tr><tr><td> <p>P</p> </td><td> <p>把被剪切的文本粘贴到上面(整行)或左侧(部分行)</p> </td></tr><tr><td> <p>"add</p> </td><td> <p>把当前行粘贴到缓冲区a里</p> </td></tr><tr><td> <p>"ap</p> </td><td> <p>把缓冲区a里的内容粘贴到当前位置</p> </td></tr><tr><td> <p>J</p> </td><td> <p>把当前行于下一行合并为一行</p> </td></tr><tr><td> <p>xp</p> </td><td> <p>调换两个字符的位置</p> </td></tr></tbody></table> 
<h4><a target="_blank" name="_Toc376251317">修改文本</a></h4> 
<table border="1" cellspacing="1" cellpadding="0" width="331"><tbody><tr><td> <p>命令</p> </td><td> <p>功能</p> </td></tr><tr><td> <p>rch</p> </td><td> <p>把光标位置的字符替换为ch</p> </td></tr><tr><td> <p>R</p> </td><td> <p>替换光标右边的文本</p> </td></tr><tr><td> <p>s</p> </td><td> <p>把光标所在的字符替换为任意个字符</p> </td></tr><tr><td> <p>S</p> </td><td> <p>替换整行内容</p> </td></tr><tr><td> <p>cw</p> </td><td> <p>修改一个单词</p> </td></tr><tr><td> <p>c</p> </td><td> <p>修改区域里的文本(vim)</p> </td></tr><tr><td> <p>~</p> </td><td> <p>改变所扫描的或区域里的字母的大小写</p> </td></tr><tr><td> <p>!tr'[a-z]''[A-Z]'</p> </td><td> <p>把区域里的字母转换为大写(vim)</p> </td></tr><tr><td> <p>!tr'[A-Z]''[a-z]'</p> </td><td> <p>把区域里的字母转换为小写(vim)</p> </td></tr></tbody></table> 
<h4><a target="_blank" name="_Toc376251318">复制文本</a></h4> 
<table border="1" cellspacing="1" cellpadding="0" width="200"><tbody><tr><td> <p>命令</p> </td><td> <p>功能</p> </td></tr><tr><td> <p>yy</p> </td><td> <p>复制当前行</p> </td></tr><tr><td> <p>6yy</p> </td><td> <p>复制六行</p> </td></tr><tr><td> <p>yw</p> </td><td> <p>复制单词</p> </td></tr><tr><td> <p>y</p> </td><td> <p>复制区域(vim)</p> </td></tr><tr><td> <p>p</p> </td><td> <p>把复制的文本粘贴到右边或下面</p> </td></tr><tr><td> <p>P</p> </td><td> <p>把复制的文本粘贴到左边或上面</p> </td></tr></tbody></table> 
<p><span style="color:#362E2B"> </span></p> 
<p><span style="color:#362E2B">还有一个博客，总结的比较详细，推荐一下</span></p> 
<p><span style="color:#362E2B">http://www.cnblogs.com/tzhangofseu/archive/2011/12/17/2290955.html</span></p> 
<p><span style="color:#362E2B">更多</span><span style="color:#362E2B"><a target="_blank" href="http://blog.csdn.net/tsuliuchao/article/details/8131537" title="累计分享0次" rel="noopener noreferrer"><span style="color:#454545">0</span></a></span></p> 
<p><span style="color:#666666">·</span><span style="color:#666666">  </span><span style="color:#666666">上一篇：</span><span style="color:#666666"><a target="_blank" href="http://blog.csdn.net/tsuliuchao/article/details/8116499" rel="noopener noreferrer"><span style="color:#6A3906">Objective-C</span><span style="color:#6A3906">中</span></a></span><span style="color:#6A3906"> copy, tetain, assign ,readonly , readwrite, nonatomic</span><span style="color:#6A3906">区别</span></p> 
<p> </p> 
<p> </p> 
<h3><a target="_blank" href="http://blog.csdn.net/yp395234871/article/details/4712802" rel="noopener noreferrer">如何画程序流程图</a><a target="_blank" name="_Toc376251319"></a></h3> 
<p align="right"><span style="color:#999999">2009-10-22 13:04</span><span style="color:#999999"> </span><span style="color:#999999">41469</span><span style="color:#999999">人阅读</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/yp395234871/article/details/4712802#comments" rel="noopener noreferrer"><span style="color:#336699">评论</span></a></span>(12)<span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" title="收藏"><span style="color:#336699">收藏</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/yp395234871/article/details/4712802#report" title="举报" rel="noopener noreferrer"><span style="color:#336699">举报</span></a></span></p> 
<p align="left"><span style="color:#333333"><a target="_blank" href="http://www.csdn.net/tag/charts" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">charts</span></a><a target="_blank" href="http://www.csdn.net/tag/resources" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">resources</span></a><a target="_blank" href="http://www.csdn.net/tag/system" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">system</span></a><a target="_blank" href="http://www.csdn.net/tag/network" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">network</span></a><a target="_blank" href="http://www.csdn.net/tag/%e5%9b%be%e5%bd%a2" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">图形</span></a></span><a target="_blank" href="http://www.csdn.net/tag/%e7%ae%97%e6%b3%95" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">算法</span></a></p> 
<p><span style="color:#333333">看</span><span style="color:#333333">PST</span><span style="color:#333333">代码很多天了</span><span style="color:#333333">,</span><span style="color:#333333">里面的读写流程看懂了</span><span style="color:#333333">,</span><span style="color:#333333">又忘了</span><span style="color:#333333">,</span><span style="color:#333333">再看</span><span style="color:#333333">,</span><span style="color:#333333">再忘</span><span style="color:#333333">,</span><span style="color:#333333">归咎于笔记的不完善与可读性差</span><span style="color:#333333">,</span><span style="color:#333333">今天开始学习流程图</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">下面介绍一下<strong>标准程序流程图的符号及使用约定</strong></span></p> 
<p><span style="color:#333333">一</span><span style="color:#333333">,</span><span style="color:#333333">引言</span></p> 
<p><span style="color:#333333">程序流程图</span><span style="color:#333333">(Progran flowchart)</span><span style="color:#333333">作为一种算法表达工具</span><span style="color:#333333">,</span><span style="color:#333333">早已为工国计算机工作者和广大计算机用户十分熟悉和普通使用</span><span style="color:#333333">.</span><span style="color:#333333">然而它的一个明显缺点在于缺乏统一的规范化符号表示和严格的使用规则</span><span style="color:#333333">.</span><span style="color:#333333">最近</span><span style="color:#333333">,</span><span style="color:#333333">国家标准局批准的国家标准</span><span style="color:#333333">(GB1525-89)&lt;&lt;</span><span style="color:#333333">信息处理</span><span style="color:#333333">--</span><span style="color:#333333">数据流程图</span><span style="color:#333333">,</span><span style="color:#333333">程序流程图</span><span style="color:#333333">,</span><span style="color:#333333">系统流程图</span><span style="color:#333333">,</span><span style="color:#333333">程序网络图和系统资源图的文件编制符号及约定</span><span style="color:#333333">&gt;&gt;</span><span style="color:#333333">为我们推荐了一套标准化符号和使用约定</span><span style="color:#333333">.</span><span style="color:#333333">由于该标准是与国际标准化组织公布的标准</span><span style="color:#333333">ISO5807--85Information processing--Documentation symbols and comventions for data,programand system flowcharts,program network charts and system resources charts</span><span style="color:#333333">是一致的</span><span style="color:#333333">,</span><span style="color:#333333">这里将其中程序流程图部分摘录出来</span><span style="color:#333333">,</span><span style="color:#333333">并做了一些解释</span><span style="color:#333333">,</span><span style="color:#333333">供读者参考</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">根据这一标准画出的程序流程图我们称为标准流程图</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">二</span><span style="color:#333333">,</span><span style="color:#333333">符号</span></p> 
<p><span style="color:#333333">程序流程图表示了程序的操作顺序</span><span style="color:#333333">.</span><span style="color:#333333">它应包括</span><span style="color:#333333">:</span></p> 
<p><span style="color:#333333">(1)</span><span style="color:#333333">指明实际处理操作的处理符号</span><span style="color:#333333">,</span><span style="color:#333333">包括根据逻辑条件确定要执行的路径的符号</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">(2)</span><span style="color:#333333">指明控制流的流线符号</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">(3)</span><span style="color:#333333">便于读写程序流程图的特殊符号</span><span style="color:#333333">.</span></p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><a target="_blank" href="https://p-blog.csdn.net/images/p_blog_csdn_net/yp395234871/608575/o_clip_image002_2.jpg" rel="nofollow noopener noreferrer"></a></p> </td></tr></tbody></table> 
<p><span style="color:#333333"><br> </span><span style="color:#333333">以下给出标准流程图所用的符号及其简要说明</span><span style="color:#333333">,</span><span style="color:#333333">请参看图</span><span style="color:#333333">1.</span></p> 
<p><span style="color:#333333">图</span><span style="color:#333333">1 </span><span style="color:#333333">标准程序流程图符号</span></p> 
<p><span style="color:#333333">1.</span><span style="color:#333333">数据</span><span style="color:#333333">---- </span><span style="color:#333333">平行四边形表示数据</span><span style="color:#333333">,</span><span style="color:#333333">其中可注明数据名</span><span style="color:#333333">,</span><span style="color:#333333">来源</span><span style="color:#333333">,</span><span style="color:#333333">用途或其它的文字说明</span><span style="color:#333333">.</span><span style="color:#333333">此符号并不限定数据的媒体</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">2.</span><span style="color:#333333">处理</span><span style="color:#333333">---- </span><span style="color:#333333">矩形表示各种处理功能</span><span style="color:#333333">.</span><span style="color:#333333">例如</span><span style="color:#333333">,</span><span style="color:#333333">执行一个或一组特定的操作</span><span style="color:#333333">,</span><span style="color:#333333">从而使信息的值</span><span style="color:#333333">,</span><span style="color:#333333">信息形世或所在位置发生变化</span><span style="color:#333333">,</span><span style="color:#333333">或是确定对某一流向的选择</span><span style="color:#333333">.</span><span style="color:#333333">矩形内可注明处理名或其简工功能</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">3.</span><span style="color:#333333">特定处理</span><span style="color:#333333">---- </span><span style="color:#333333">带有双纵边线的矩形表示已命名的特定处理</span><span style="color:#333333">.</span><span style="color:#333333">该处理为在另外地方已得到详细说明的一个操作或一组操作</span><span style="color:#333333">,</span><span style="color:#333333">便如子例行程序</span><span style="color:#333333">,</span><span style="color:#333333">模块</span><span style="color:#333333">.</span><span style="color:#333333">矩形内可注明特定处理名或其简要功能</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">4.</span><span style="color:#333333">准备</span><span style="color:#333333">---- </span><span style="color:#333333">六边形符号表示准备</span><span style="color:#333333">.</span><span style="color:#333333">它表示修改一条指令或一组指令以影响随后的活动</span><span style="color:#333333">.</span><span style="color:#333333">例如</span><span style="color:#333333">,</span><span style="color:#333333">设置开关</span><span style="color:#333333">,</span><span style="color:#333333">修改变址寄存器</span><span style="color:#333333">,</span><span style="color:#333333">初始化例行程序</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">5.</span><span style="color:#333333">判断</span><span style="color:#333333">----- </span><span style="color:#333333">菱形表示判断或开关</span><span style="color:#333333">.</span><span style="color:#333333">菱形内可注明判断的条件</span><span style="color:#333333">.</span><span style="color:#333333">它只有一个入口</span><span style="color:#333333">,</span><span style="color:#333333">但可以有若干个可供选择的出口</span><span style="color:#333333">,</span><span style="color:#333333">在对符号内定义折条件求值后</span><span style="color:#333333">,</span><span style="color:#333333">有一个且仅有一个出口被激活</span><span style="color:#333333">.</span><span style="color:#333333">求值结果可在表示出口路径的流线附近写出</span><span style="color:#333333">.</span></p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><a target="_blank" href="https://p-blog.csdn.net/images/p_blog_csdn_net/yp395234871/608575/o_clip_image004_2.jpg" rel="nofollow noopener noreferrer"></a></p> </td></tr></tbody></table> 
<p><span style="color:#333333"><br> 6.</span><span style="color:#333333">循环界限</span><span style="color:#333333">---- </span> <span style="color:#333333">循环界限为去上角矩形表示年界限和去下角矩形的下界限构成</span><span style="color:#333333">,</span><span style="color:#333333">分别表示循环的开始和循环的结束</span><span style="color:#333333">. </span><span style="color:#333333">图</span><span style="color:#333333">2 </span><span style="color:#333333">两种循环表示</span></p> 
<p><span style="color:#333333">一对符号内应注明同一循环标识符</span><span style="color:#333333">.</span><span style="color:#333333">可根据检验终止循环条件在循环的开始还是在循环的末尾</span><span style="color:#333333">,</span><span style="color:#333333">将其条件分别在上界限符内注明</span><span style="color:#333333">(</span><span style="color:#333333">如</span><span style="color:#333333">:</span><span style="color:#333333">当</span><span style="color:#333333">A&gt;B)</span><span style="color:#333333">或在下界限符内注明</span><span style="color:#333333">(</span><span style="color:#333333">如</span><span style="color:#333333">:</span><span style="color:#333333">直到</span><span style="color:#333333">C&lt;D).</span><span style="color:#333333">图</span><span style="color:#333333">2</span><span style="color:#333333">给出了当终止条件成立时进入循环和直到终止条件成立退出循环的两种不同的表示</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">7.</span><span style="color:#333333">连接符</span><span style="color:#333333">---- </span><span style="color:#333333">圆表示连接符</span><span style="color:#333333">,</span><span style="color:#333333">用以表明转向流程图的它处</span><span style="color:#333333">,</span><span style="color:#333333">或从流程图它处转入</span><span style="color:#333333">.</span><span style="color:#333333">它是流线的断点</span><span style="color:#333333">.</span><span style="color:#333333">在图内注明某一标识符</span><span style="color:#333333">,</span><span style="color:#333333">表明该流线将在具有相同标识符的另一连接符处继续下去</span><span style="color:#333333">(</span><span style="color:#333333">参看以下关于连接符使用的约定</span><span style="color:#333333">).</span></p> 
<p><span style="color:#333333">8.</span><span style="color:#333333">端点符</span><span style="color:#333333">---- </span><span style="color:#333333">扁圆形表示转向外部环境或从外部环境转入的端点符</span><span style="color:#333333">.</span><span style="color:#333333">例如</span><span style="color:#333333">,</span><span style="color:#333333">程序流程的起始或结束</span><span style="color:#333333">,</span><span style="color:#333333">数据的外部使用起点或终点</span><span style="color:#333333">.</span></p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><a target="_blank" href="https://p-blog.csdn.net/images/p_blog_csdn_net/yp395234871/608575/o_clip_image006_2.jpg" rel="nofollow noopener noreferrer"></a></p> </td></tr></tbody></table> 
<p><span style="color:#333333"><br> 9.</span><span style="color:#333333">注解符</span><span style="color:#333333">---- </span> <span style="color:#333333">注解符由纵边线和虚线构成</span><span style="color:#333333">,</span><span style="color:#333333">用以标识注解的内容</span><span style="color:#333333">.</span><span style="color:#333333">虚线须连接到被注解的符号或符号组合上</span><span style="color:#333333">.</span><span style="color:#333333">注解的正文应靠近纵边线</span><span style="color:#333333">.</span><span style="color:#333333">请参看图</span><span style="color:#333333">3</span><span style="color:#333333">给出的注解符使用示例</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">图</span><span style="color:#333333">3 </span><span style="color:#333333">注解符的使用</span></p> 
<p><span style="color:#333333">10.</span><span style="color:#333333">流线</span><span style="color:#333333"> ----- </span><span style="color:#333333">直线表示控制流的流线</span><span style="color:#333333">.</span><span style="color:#333333">关于流线上表示流向的箭头</span><span style="color:#333333">,</span><span style="color:#333333">其使用方法见后面的约定</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">11.</span><span style="color:#333333">虚线</span><span style="color:#333333"> ---- </span><span style="color:#333333">虚线用于表明被注解的范围或连接被注解部分与注解正文</span><span style="color:#333333">,</span><span style="color:#333333">也参看图</span><span style="color:#333333">3.</span></p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><a target="_blank" href="https://p-blog.csdn.net/images/p_blog_csdn_net/yp395234871/608575/o_clip_image008_2.jpg" rel="nofollow noopener noreferrer"></a></p> </td></tr></tbody></table> 
<p><span style="color:#333333"><br> 12.</span><span style="color:#333333">省略符</span><span style="color:#333333"> ---- </span><span style="color:#333333">若流程图中有些部分无需给出符号的具体形式和数量</span><span style="color:#333333">,</span><span style="color:#333333">可用三点构成的省略符</span><span style="color:#333333">.</span><span style="color:#333333">省略符应夹在流线符号之中或流线符号之间</span><span style="color:#333333">,</span><span style="color:#333333">参看图</span><span style="color:#333333">4.</span></p> 
<p><span style="color:#333333">图</span><span style="color:#333333">4 </span><span style="color:#333333">省略符的使用</span></p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><a target="_blank" href="https://p-blog.csdn.net/images/p_blog_csdn_net/yp395234871/608575/o_clip_image010_2.jpg" rel="nofollow noopener noreferrer"></a></p> </td></tr></tbody></table> 
<p><span style="color:#333333"><br> 13.</span><span style="color:#333333">并行方式</span><span style="color:#333333"> ---- </span><span style="color:#333333">一对平行线表示同步进行两个或两个以上并行方式的操作</span><span style="color:#333333">.</span><span style="color:#333333">并行方式的示例如图</span><span style="color:#333333">5,</span><span style="color:#333333">图中在处理</span><span style="color:#333333">A</span><span style="color:#333333">完成后才能进行处理</span><span style="color:#333333">C,D</span><span style="color:#333333">和</span><span style="color:#333333">E;</span><span style="color:#333333">同样</span><span style="color:#333333">,</span><span style="color:#333333">处理</span><span style="color:#333333">F</span><span style="color:#333333">要等处理</span><span style="color:#333333">B,C,D</span><span style="color:#333333">完成以后进行</span><span style="color:#333333">.</span><span style="color:#333333">但处理</span><span style="color:#333333">C</span><span style="color:#333333">可以处理</span><span style="color:#333333">D</span><span style="color:#333333">开始和</span><span style="color:#333333">(</span><span style="color:#333333">或</span><span style="color:#333333">)</span><span style="color:#333333">结束前开始和</span><span style="color:#333333">(</span><span style="color:#333333">或</span><span style="color:#333333">)</span><span style="color:#333333">结束</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">图</span><span style="color:#333333">5 </span><span style="color:#333333">并行方式示例</span></p> 
<p><span style="color:#333333">三</span><span style="color:#333333">,</span><span style="color:#333333">使用约定</span></p> 
<p><span style="color:#333333">关于流程图符号的使用约定</span><span style="color:#333333">,</span><span style="color:#333333">简要地说明以下几点</span><span style="color:#333333">:</span></p> 
<p><span style="color:#333333">1.</span><span style="color:#333333">图的布局</span></p> 
<p><span style="color:#333333">流程图中所用的符号应该均心地分布</span><span style="color:#333333">,</span><span style="color:#333333">连线保持合理的长度</span><span style="color:#333333">,</span><span style="color:#333333">并尽量少使用长线</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">2.</span><span style="color:#333333">符号的形状</span></p> 
<p><span style="color:#333333">流程图中多数符号内的空白供标注说明性文字</span><span style="color:#333333">.</span><span style="color:#333333">使用各种符号应注意符号的外形和各符号大小的统一</span><span style="color:#333333">,</span><span style="color:#333333">避免使符号变形或各符号大小比例不一</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">3.</span><span style="color:#333333">符号内的说明文字</span></p> 
<p><span style="color:#333333">应使符号内的说明文字尽可能简明</span><span style="color:#333333">.</span><span style="color:#333333">通常按从左向右和从上向下方式书写</span><span style="color:#333333">,</span><span style="color:#333333">并与流向无关</span><span style="color:#333333">.</span><span style="color:#333333">如果说明文字较多</span><span style="color:#333333">,</span><span style="color:#333333">符号内写不完</span><span style="color:#333333">,</span><span style="color:#333333">可使用注解符</span><span style="color:#333333">.</span><span style="color:#333333">若注解符干扰或影响到图形的流程</span><span style="color:#333333">,</span><span style="color:#333333">应将正文写在另外一页上</span><span style="color:#333333">,</span><span style="color:#333333">并注明引用符号</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">4.</span><span style="color:#333333">符号标识符</span></p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><a target="_blank" href="https://p-blog.csdn.net/images/p_blog_csdn_net/yp395234871/608575/o_clip_image012_2.jpg" rel="nofollow noopener noreferrer"></a></p> </td></tr></tbody></table> 
<p><span style="color:#333333"><br> </span><span style="color:#333333">为符号规定标识符是为了便于其它文件引用该符号</span><span style="color:#333333">.</span><span style="color:#333333">便如</span><span style="color:#333333">,</span><span style="color:#333333">程序清单中引用到流程图中的特定符号</span><span style="color:#333333">.</span><span style="color:#333333">符号标识符一般写在符号的左上角</span><span style="color:#333333">,</span><span style="color:#333333">参看图</span><span style="color:#333333">6(a).</span></p> 
<p><span style="color:#333333">图</span><span style="color:#333333">6 </span><span style="color:#333333">符号标识符和符号描述符</span></p> 
<p><span style="color:#333333">5.</span><span style="color:#333333">符号描述符</span></p> 
<p><span style="color:#333333">为便于进一步理解符号的功能</span><span style="color:#333333">,</span><span style="color:#333333">可标注符号描述符</span><span style="color:#333333">.</span><span style="color:#333333">通常描述符写在符号的右上角</span><span style="color:#333333">,</span><span style="color:#333333">如图</span><span style="color:#333333">6(b)</span><span style="color:#333333">所示</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">6.</span><span style="color:#333333">详细表示</span></p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><a target="_blank" href="https://p-blog.csdn.net/images/p_blog_csdn_net/yp395234871/608575/o_clip_image014_2.jpg" rel="nofollow noopener noreferrer"></a></p> </td></tr></tbody></table> 
<p><span style="color:#333333"><br> </span><span style="color:#333333">在处理符号或数据符号中画一横线</span><span style="color:#333333">,</span><span style="color:#333333">表明该符号在同一文件集中的其它地言有更为详细的表示</span><span style="color:#333333">.</span><span style="color:#333333">横线在符号内靠近项端</span><span style="color:#333333">,</span><span style="color:#333333">详细表示的标识符写在符号内横线之上</span><span style="color:#333333">,</span><span style="color:#333333">见图</span><span style="color:#333333">7(a).</span><span style="color:#333333">端点符用作详细表示的开始符号和结束符号</span><span style="color:#333333">,</span><span style="color:#333333">在此符号中应给出加横线符号中的标识符</span><span style="color:#333333">,</span><span style="color:#333333">见图</span><span style="color:#333333">7(b).</span></p> 
<p><span style="color:#333333">图</span><span style="color:#333333">7 </span><span style="color:#333333">加横线符号及其详细表示</span></p> 
<p><span style="color:#333333">7.</span><span style="color:#333333">流线</span></p> 
<p><span style="color:#333333">(1)</span><span style="color:#333333">标准流向与箭头的使用</span></p> 
<p><span style="color:#333333">流线的标准流向是从左到右和从上到下</span><span style="color:#333333">.</span><span style="color:#333333">沿标准流向的流线可不用箭头指示流向</span><span style="color:#333333">,</span><span style="color:#333333">但沿非标准流向的流线应用箭头指示充向</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">(2)</span><span style="color:#333333">流线的交叉</span></p> 
<p><span style="color:#333333">应当尽量避免流线的交叉</span><span style="color:#333333">.</span><span style="color:#333333">即使出现流线的交叉</span><span style="color:#333333">,</span><span style="color:#333333">交叉的流线之间也没有任何逻辑关系</span><span style="color:#333333">,</span><span style="color:#333333">并不对流向产生任何影响</span><span style="color:#333333">,</span><span style="color:#333333">如图</span><span style="color:#333333">8(a)</span><span style="color:#333333">所示</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">(3)</span><span style="color:#333333">流线的汇集</span></p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><a target="_blank" href="https://p-blog.csdn.net/images/p_blog_csdn_net/yp395234871/608575/o_clip_image016_2.jpg" rel="nofollow noopener noreferrer"></a></p> </td></tr></tbody></table> 
<p><span style="color:#333333"><br> </span><span style="color:#333333">两条或多条进入线可以汇集成一条输出线</span><span style="color:#333333">,</span><span style="color:#333333">此时各连接点应要互错工以提高清晰度</span><span style="color:#333333">,</span><span style="color:#333333">并用箭头表示流向</span><span style="color:#333333">,</span><span style="color:#333333">如图</span><span style="color:#333333">8(b)</span><span style="color:#333333">所示</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">图</span><span style="color:#333333">8 </span><span style="color:#333333">汉线的交叉与流线的汇集</span></p> 
<p><span style="color:#333333">(4)</span><span style="color:#333333">符号流线进出</span></p> 
<p><span style="color:#333333">一般情况下</span><span style="color:#333333">,</span><span style="color:#333333">流线应从符号的左边或项端进入</span><span style="color:#333333">,</span><span style="color:#333333">并从右边或底端离开</span><span style="color:#333333">.</span><span style="color:#333333">其进出点均应对准符号的中心</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">(5)</span><span style="color:#333333">连接符</span></p> 
<p><span style="color:#333333">为避免出现流线交叉和使用长线</span><span style="color:#333333">,</span><span style="color:#333333">或某个流程图能在另一页上延续</span><span style="color:#333333">,</span><span style="color:#333333">可用连接符将流线截断</span><span style="color:#333333">.</span><span style="color:#333333">截断始端的连接符称为出口连接符</span><span style="color:#333333">,</span><span style="color:#333333">载断末端的连接符称为入口连接符</span><span style="color:#333333">.</span><span style="color:#333333">两连接符中用同一标识符</span><span style="color:#333333">.</span></p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><a target="_blank" href="https://p-blog.csdn.net/images/p_blog_csdn_net/yp395234871/608575/o_clip_image018_2.jpg" rel="nofollow noopener noreferrer"></a></p> </td></tr></tbody></table> 
<p><span style="color:#333333"><br> </span><span style="color:#333333">换页截断可用与连接符相连的注解符表示</span><span style="color:#333333">,</span><span style="color:#333333">如图</span><span style="color:#333333">9</span><span style="color:#333333">所示</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">图</span><span style="color:#333333">9 </span><span style="color:#333333">出口连接符与入口连接符</span></p> 
<p><span style="color:#333333">8.</span><span style="color:#333333">多出口判断的两种表示方法</span></p> 
<p><span style="color:#333333">(1)</span><span style="color:#333333">直接从判断符号引出多条流线</span><span style="color:#333333">,</span><span style="color:#333333">如图</span><span style="color:#333333">10(a)</span><span style="color:#333333">所示</span><span style="color:#333333">.</span></p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><a target="_blank" href="https://p-blog.csdn.net/images/p_blog_csdn_net/yp395234871/608575/o_clip_image020_2.jpg" rel="nofollow noopener noreferrer"></a></p> </td></tr></tbody></table> 
<p><span style="color:#333333"><br> (2)</span><span style="color:#333333">从判断符号引聘条流线</span><span style="color:#333333">,</span><span style="color:#333333">再从它引出多条流线</span><span style="color:#333333">,</span><span style="color:#333333">如图</span><span style="color:#333333">10(b)</span><span style="color:#333333">所示</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">图</span><span style="color:#333333">10 </span><span style="color:#333333">多出口判断</span></p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><a target="_blank" href="https://p-blog.csdn.net/images/p_blog_csdn_net/yp395234871/608575/o_clip_image022_2.jpg" rel="nofollow noopener noreferrer"></a></p> </td></tr></tbody></table> 
<p><span style="color:#333333"><br> </span><span style="color:#333333">多出口判断的每个出口都应标有相应的条件值</span><span style="color:#333333">,</span><span style="color:#333333">用以反映它所引出的逻辑路径</span><span style="color:#333333">,</span><span style="color:#333333">如图</span><span style="color:#333333">11</span><span style="color:#333333">所示</span><span style="color:#333333">.</span></p> 
<p><span style="color:#333333">图</span><span style="color:#333333">11 </span><span style="color:#333333">多出口判断出口处标出条件值</span></p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><a target="_blank" href="https://p-blog.csdn.net/images/p_blog_csdn_net/yp395234871/608575/o_clip_image024_2.jpg" rel="nofollow noopener noreferrer"></a></p> </td></tr></tbody></table> 
<p><span style="color:#333333"><br> </span><span style="color:#333333">四</span><span style="color:#333333">, </span><span style="color:#333333">示例</span></p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><a target="_blank" href="https://p-blog.csdn.net/images/p_blog_csdn_net/yp395234871/608575/o_clip_image002%5B4%5D.jpg" rel="nofollow noopener noreferrer"></a></p> </td></tr></tbody></table> 
<h3><a target="_blank" name="_Toc376251320">10</a>个比viso好的流程图制作软件</h3> 
<p><strong><span style="color:#363636">1</span><span style="color:#363636">、</span><span style="color:#363636"><a target="_blank" href="http://staruml.sourceforge.net/en/" rel="nofollow noopener noreferrer"><span style="color:#0169DE">StarUML</span></a></span></strong></p> 
<p>　　一款知名的免费开源的UML建模工具。</p> 
<p>　　</p> 
<p><strong><span style="color:#363636">2</span><span style="color:#363636">、</span><span style="color:#363636"><a target="_blank" href="http://argouml.tigris.org/" rel="nofollow noopener noreferrer"><span style="color:#0169DE">ArgoUML</span></a></span></strong></p> 
<p>　　另一个著名的开源UML建模软件，ArgoUML支持Windows、Mac、Linux等主流操作系统。</p> 
<p>　　</p> 
<p><strong><span style="color:#363636">3</span><span style="color:#363636">、</span><span style="color:#363636"><a target="_blank" href="http://www.openoffice.org/product/draw.html" rel="nofollow noopener noreferrer"><span style="color:#0169DE">OpenOffice Draw</span></a></span></strong></p> 
<p>　　OpenOffice是一个可代替微软Office办公套件的免费产品，虽然没有微软Office那么庞大复杂，但可满足一般需求。其中的Draw就是用来设计diagrams的。</p> 
<p>　　</p> 
<p><strong><span style="color:#363636">4</span><span style="color:#363636">、</span><span style="color:#363636"><a target="_blank" href="http://dia-installer.de/index.html.en" rel="nofollow noopener noreferrer"><span style="color:#0169DE">Dia Diagram Editor</span></a></span></strong></p> 
<p>　　Dia跟Visio高度相似，可<a target="_blank" href="http://blog.yiyidu.com/2012_1829.html" rel="nofollow noopener noreferrer"><span style="color:#0169DE">制作流程图</span></a>、建筑设计图、UML模型图等等，Dia同样免费开源，支持Windows、Linux和Mac OS X等OS。</p> 
<p>　　</p> 
<p><strong><span style="color:#363636">5</span><span style="color:#363636">、</span><span style="color:#363636"><a target="_blank" href="http://pencil.evolus.vn/en-US/Home.aspx" rel="nofollow noopener noreferrer"><span style="color:#0169DE">Pencil Project</span></a></span></strong></p> 
<p>　　Pencil Project是一个用于创建流程图和界面原型的开源设计工具。</p> 
<p>　　</p> 
<p><strong><span style="color:#363636">6</span><span style="color:#363636">、</span><span style="color:#363636"><a target="_blank" href="http://www.yworks.com/en/products_yed_about.html" rel="nofollow noopener noreferrer"><span style="color:#0169DE">yEd Graph Editor</span></a></span></strong></p> 
<p>　　yEd图像编辑器是一个用于快速高效制作高质量流程图的桌面软件，可运行于Windows、Unix/Linux和Mac OS X平台。它支持从.xls和XML格式导入数据，可导出为多种位图或矢量图片格式：PNG, JPG, SVG, PDF, SWF。</p> 
<p>　　</p> 
<p><strong><span style="color:#363636">7</span><span style="color:#363636">、</span><span style="color:#363636"><a target="_blank" href="http://www.omnigroup.com/products/omnigraffle/" rel="nofollow noopener noreferrer"><span style="color:#0169DE">OmniGraffle</span></a></span></strong></p> 
<p>　　OmniGraffle支持Mac电脑和iPad平板。</p> 
<p>　　</p> 
<p><strong><span style="color:#363636">8</span><span style="color:#363636">、</span><span style="color:#363636"><a target="_blank" href="http://www.corel.com/corel/category.jsp?rootCat=cat20146&amp;cat=cat3430091" rel="nofollow noopener noreferrer"><span style="color:#0169DE">CorelDRAW</span></a></span></strong></p> 
<p>　　流行的矢量图形绘制和排版软件，同样可制作流程图，价格：499美元。</p> 
<p>　　</p> 
<p><strong><span style="color:#363636">9</span><span style="color:#363636">、</span><span style="color:#363636"><a target="_blank" href="http://inkscape.org/" rel="nofollow noopener noreferrer"><span style="color:#0169DE">Inkscape</span></a></span></strong></p> 
<p>　　开源的矢量图形编辑器，提供类似于Illustrator、CorelDraw和Xara X的功能。</p> 
<p>　　</p> 
<p><strong><span style="color:#363636">10</span><span style="color:#363636">、</span><span style="color:#363636"><a target="_blank" href="https://cacoo.com/" rel="nofollow noopener noreferrer"><span style="color:#0169DE">cacoo</span></a></span></strong></p> 
<p>　　一个<a target="_blank" href="http://blog.yiyidu.com/2012_1828.html" rel="nofollow noopener noreferrer"><span style="color:#0169DE">在线流程图制作</span></a>软件，提供免费、Plus和Team三个Plan，免费用户可保存最多25张图表</p> 
<h3> <a target="_blank" name="_Toc376251321">Linuxpthread_mutex_init()</a>函数</h3> 
<p align="left"><span style="color:#555555">2011-09-19 10:32:15</span></p> 
<p align="left"><span style="color:#555555">标签：<a target="_blank" href="http://blog.51cto.com/tag-pthread_mutex_init%28%29.html" rel="nofollow noopener noreferrer"><span style="color:#015F91">pthread_mutex_init()</span></a></span><span style="color:#555555"> </span><span style="color:#555555"><a target="_blank" href="http://blog.51cto.com/tag-Linux.html" rel="nofollow noopener noreferrer"><span style="color:#015F91">Linux</span></a></span><span style="color:#555555"> </span><span style="color:#555555"><a target="_blank" href="http://blog.51cto.com/tag-%E4%BC%91%E9%97%B2.html" rel="nofollow noopener noreferrer"><span style="color:#015F91">休闲</span></a></span><span style="color:#555555"> </span><span style="color:#555555"><a target="_blank" href="http://blog.51cto.com/tag-%E8%81%8C%E5%9C%BA.html" rel="nofollow noopener noreferrer"><span style="color:#015F91">职场</span></a></span></p> 
<p align="left"><span style="color:#555555">    </span><span style="color:#555555">函数原型：Int pthread_mutex_init(pthread_mutex_t  *restrict_mutex,constpthread_mutextattr_t *restrict attr)</span></p> 
<p align="left"><span style="color:#555555">    </span><span style="color:#555555">该函数主要用于多线程中互斥锁的初始化。</span></p> 
<p align="left"><span style="color:#555555">   </span><span style="color:#555555">如果attr</span>为空的话，则是默认属性，而默认属性的快速互斥锁。</p> 
<p align="left"><span style="color:#555555">   pthread_mutex_init</span><span style="color:#555555">完成成功后会返回0</span>，其他值都是错误的。</p> 
<p align="left"><span style="color:#555555">   intpthread_mutextattr_destroy(pthread_mutextattr_t *restrict_mutext)</span></p> 
<p align="left"><span style="color:#555555">   </span><span style="color:#555555">该函数是销毁线程互斥锁</span></p> 
<p align="left"><span style="color:#555555">   </span><span style="color:#555555">设定互斥锁的作用域：</span></p> 
<p align="left"><span style="color:#555555">    Intpthread_mutextattr_setpshared(pthread_mutexattr_t *restrict mutext, intpshared)</span></p> 
<p align="left"><span style="color:#555555">    </span><span style="color:#555555">在多线程中是共享互斥锁的。</span></p> 
<p align="left"><span style="color:#555555">    </span><span style="color:#555555">如果想在多个进程中共享互斥锁，可以把pshared</span>设置PTHREAD_PROCESS_SHARED</p> 
<p align="left"><span style="color:#555555">    </span><span style="color:#555555">如果只想在有同属于一个进程创建的线程中共享互斥锁，则可以把pshared</span>设置为PTHREAD_PROCESS_PRIVATE</p> 
<p align="left"><span style="color:#555555">    </span><span style="color:#555555">获得互斥锁的作用域：</span></p> 
<p align="left"><span style="color:#555555">     intpthread_mutexattr_getpshared(pthread_mutexattr_t *restrict mutext,int*pshared);</span></p> 
<p align="left"><span style="color:#555555">     </span><span style="color:#555555">设定互斥锁类型的属性：</span></p> 
<p align="left"><span style="color:#555555">     intpthread_mutexattr_settype(pthread_mutexattr_t *restrict mutext,int type)</span></p> 
<p align="left"><span style="color:#555555">     </span><span style="color:#555555">其中type</span>类型都有：</p> 
<p align="left"><span style="color:#555555">    PTHREAD_MUTEX_NOMRAL</span><span style="color:#555555">：此类型的互斥锁不会检测死锁</span></p> 
<p align="left"><span style="color:#555555">    </span><span style="color:#555555">而其中的缺省值值是PTHREAD_MUTEX_DEFAULT</span></p> 
<p align="left"><span style="color:#555555">    PTHREAD_MUTEX_ERRORCHECK:</span><span style="color:#555555">是提供错误检查</span></p> 
<p align="left"><span style="color:#555555">     intpthread_mutexattr_setprotocal(pthread_mutexattr_t *attr,int protocal)</span></p> 
<p align="left"><span style="color:#555555">     protocal</span><span style="color:#555555">可以设置互斥锁属性的协议</span></p> 
<p align="left"><span style="color:#555555">    PTHREAD_PRIO_NONE</span></p> 
<p align="left"><span style="color:#555555">    PTHREAD_PRIO_INHERIT</span></p> 
<p align="left"><span style="color:#555555">    PTHREAD_PRIO_PROTECT</span></p> 
<p> </p> 
<h3><a target="_blank" href="http://blog.csdn.net/ffilman/article/details/4871920" rel="noopener noreferrer">条件变量、pthread_cond_init</a><a target="_blank" name="_Toc376251322"></a></h3> 
<p align="right"><span style="color:#999999">2009-11-25 16:22</span><span style="color:#999999"> </span><span style="color:#999999">8687</span><span style="color:#999999">人阅读</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/ffilman/article/details/4871920#comments" rel="noopener noreferrer"><span style="color:#336699">评论</span></a></span>(5)<span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" title="收藏"><span style="color:#336699">收藏</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/ffilman/article/details/4871920#report" title="举报" rel="noopener noreferrer"><span style="color:#336699">举报</span></a></span></p> 
<p align="left"><span style="color:#333333"><a target="_blank" href="http://www.csdn.net/tag/signal" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">signal</span></a><a target="_blank" href="http://www.csdn.net/tag/%e6%b5%8b%e8%af%95" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">测试</span></a></span><a target="_blank" href="http://www.csdn.net/tag/null" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">null</span></a></p> 
<p align="right" style="background:#EEEEEE"><span style="color:#333333">目录</span><span style="color:#333333"><a target="_blank" href="http://blog.csdn.net/ffilman/article/details/4871920" title="系统根据文章中H1到H6标签自动生成文章目录" rel="noopener noreferrer"><span style="color:#336699">(?)</span></a><a target="_blank" href="http://blog.csdn.net/ffilman/article/details/4871920" title="展开" rel="noopener noreferrer"><span style="color:#336699">[+]</span></a></span></p> 
<p><span style="color:#333333"> </span></p> 
<h4><a target="_blank" name="_Toc376251323">1.</a>初始化条件变量pthread_cond_init</h4> 
<p>#include &lt;pthread.h&gt;<br> int pthread_cond_init(pthread_cond_t *cv,<br> const pthread_condattr_t *cattr);<br> 返回值：函数成功返回0；任何其他返回值都表示错误</p> 
<p>初始化一个条件变量。当参数cattr为空指针时，函数创建的是一个缺省的条件变量。否则条件变量的属性将由cattr中的属性值来决定。调用 pthread_cond_init函数时，参数cattr为空指针等价于cattr中的属性为缺省属性，只是前者不需要cattr所占用的内存开销。这个函数返回时，条件变量被存放在参数cv指向的内存中。</p> 
<p>可以用宏PTHREAD_COND_INITIALIZER来初始化静态定义的条件变量，使其具有缺省属性。这和用pthread_cond_init函数动态分配的效果是一样的。初始化时不进行错误检查。如：</p> 
<p>pthread_cond_t cv = PTHREAD_COND_INITIALIZER;</p> 
<p>不能由多个线程同时初始化一个条件变量。当需要重新初始化或释放一个条件变量时，应用程序必须保证这个条件变量未被使用。</p> 
<p> </p> 
<h4><a target="_blank" name="_Toc376251324">2.</a>阻塞在条件变量上pthread_cond_wait</h4> 
<p>#include &lt;pthread.h&gt;<br> int pthread_cond_wait(pthread_cond_t *cv,<br> pthread_mutex_t *mutex);<br> 返回值：函数成功返回0；任何其他返回值都表示错误</p> 
<p>函数将解锁mutex参数指向的互斥锁，并使当前线程阻塞在cv参数指向的条件变量上。</p> 
<p>被阻塞的线程可以被pthread_cond_signal函数，pthread_cond_broadcast函数唤醒，也可能在被信号中断后被唤醒。</p> 
<p>pthread_cond_wait函数的返回并不意味着条件的值一定发生了变化，必须重新检查条件的值。</p> 
<p>pthread_cond_wait函数返回时，相应的互斥锁将被当前线程锁定，即使是函数出错返回。</p> 
<p>一般一个条件表达式都是在一个互斥锁的保护下被检查。当条件表达式未被满足时，线程将仍然阻塞在这个条件变量上。当另一个线程改变了条件的值并向条件变量发出信号时，等待在这个条件变量上的一个线程或所有线程被唤醒，接着都试图再次占有相应的互斥锁。</p> 
<p>阻塞在条件变量上的线程被唤醒以后，直到pthread_cond_wait()函数返回之前条件的值都有可能发生变化。所以函数返回以后，在锁定相应的互斥锁之前，必须重新测试条件值。最好的测试方法是循环调用pthread_cond_wait函数，并把满足条件的表达式置为循环的终止条件。如：</p> 
<p>pthread_mutex_lock();<br> while (condition_is_false)<br>  pthread_cond_wait();<br> pthread_mutex_unlock();</p> 
<p>阻塞在同一个条件变量上的不同线程被释放的次序是不一定的。</p> 
<p>注意：pthread_cond_wait()函数是退出点，如果在调用这个函数时，已有一个挂起的退出请求，且线程允许退出，这个线程将被终止并开始执行善后处理函数，而这时和条件变量相关的互斥锁仍将处在锁定状态。</p> 
<p> </p> 
<h4><a target="_blank" name="_Toc376251325">3.</a>解除在条件变量上的阻塞pthread_cond_signal</h4> 
<p>#include &lt;pthread.h&gt;<br> int pthread_cond_signal(pthread_cond_t *cv);<br> 返回值：函数成功返回0；任何其他返回值都表示错误</p> 
<p>函数被用来释放被阻塞在指定条件变量上的一个线程。</p> 
<p>必须在互斥锁的保护下使用相应的条件变量。否则对条件变量的解锁有可能发生在锁定条件变量之前，从而造成死锁。</p> 
<p>唤醒阻塞在条件变量上的所有线程的顺序由调度策略决定，如果线程的调度策略是SCHED_OTHER类型的，系统将根据线程的优先级唤醒线程。</p> 
<p>如果没有线程被阻塞在条件变量上，那么调用pthread_cond_signal()将没有作用。</p> 
<p> </p> 
<h4><a target="_blank" name="_Toc376251326">4.</a>阻塞直到指定时间pthread_cond_timedwait</h4> 
<p>#include &lt;pthread.h&gt;<br> #include &lt;time.h&gt;<br> int pthread_cond_timedwait(pthread_cond_t *cv,<br> pthread_mutex_t *mp, const structtimespec * abstime);<br> 返回值：函数成功返回0；任何其他返回值都表示错误</p> 
<p>函数到了一定的时间，即使条件未发生也会解除阻塞。这个时间由参数abstime指定。函数返回时，相应的互斥锁往往是锁定的，即使是函数出错返回。</p> 
<p>注意：pthread_cond_timedwait函数也是退出点。</p> 
<p>超时时间参数是指一天中的某个时刻。使用举例：</p> 
<p>pthread_timestruc_t to;<br> to.tv_sec = time(NULL) + TIMEOUT;<br> to.tv_nsec = 0;</p> 
<p>超时返回的错误码是ETIMEDOUT。</p> 
<p> </p> 
<h4><a target="_blank" name="_Toc376251327">5.</a>释放阻塞的所有线程pthread_cond_broadcast</h4> 
<p>#include &lt;pthread.h&gt;<br> int pthread_cond_broadcast(pthread_cond_t *cv);<br> 返回值：函数成功返回0；任何其他返回值都表示错误</p> 
<p>函数唤醒所有被pthread_cond_wait函数阻塞在某个条件变量上的线程，参数cv被用来指定这个条件变量。当没有线程阻塞在这个条件变量上时，pthread_cond_broadcast函数无效。</p> 
<p>由于pthread_cond_broadcast函数唤醒所有阻塞在某个条件变量上的线程，这些线程被唤醒后将再次竞争相应的互斥锁，所以必须小心使用pthread_cond_broadcast函数。</p> 
<p> </p> 
<h4><a target="_blank" name="_Toc376251328"></a><a target="_blank" name="t5"></a>6.释放条件变量pthread_cond_destroy</h4> 
<p>#include &lt;pthread.h&gt;<br> int pthread_cond_destroy(pthread_cond_t *cv);<br> 返回值：函数成功返回0；任何其他返回值都表示错误</p> 
<p>释放条件变量。</p> 
<p>注意：条件变量占用的空间并未被释放。</p> 
<p> </p> 
<h4><a target="_blank" name="_Toc376251329"></a><a target="_blank" name="t6"></a>7.唤醒丢失问题</h4> 
<p>在线程未获得相应的互斥锁时调用pthread_cond_signal或pthread_cond_broadcast函数可能会引起唤醒丢失问题。</p> 
<p>唤醒丢失往往会在下面的情况下发生：</p> 
<p>一个线程调用pthread_cond_signal或pthread_cond_broadcast函数；</p> 
<p>另一个线程正处在测试条件变量和调用pthread_cond_wait函数之间；</p> 
<p>没有线程正在处在阻塞等待的状态下</p> 
<h3><a target="_blank" href="http://blog.csdn.net/thanklife/article/details/7362893" rel="noopener noreferrer">#ifdef __cplusplus 有什么作用</a><a target="_blank" name="_Toc376251330"></a></h3> 
<p>一般用于将C++代码以标准C形式输出（即以C的形式被调用），这是因为C++虽然常被认为是C的超集，但是C++的编译器还是与C的编译器不同的。C中调用C++中的代码这样定义会是安全的。</p> 
<p> </p> 
<p>一般的考虑跨平台使用方法如下：</p> 
<p> </p> 
<p>#ifdefined(__cplusplus)||defined(c_plusplus)//跨平台定义方法</p> 
<p>extern "C"{<!-- --></p> 
<p>#endif</p> 
<p>//... 正常的声明段</p> 
<p>#ifdefined(__cplusplus)||defined(c_plusplus)</p> 
<p>}</p> 
<p>#endif </p> 
<p> </p> 
<p>简单的用在windows下可以如下定义:</p> 
<p><span style="color:#EE6600; background:yellow">#ifdef</span>   <span style="color:blue; background:#CCFFFF"> __cplusplus</span></p> 
<p>extern "C"{<!-- --></p> 
<p>//... 正常的声明段</p> 
<p>}</p> 
<p>#endif</p> 
<p> </p> 
<p> </p> 
<p><span style="color:red">某一网文：</span></p> 
<p> </p> 
<p><span style="color:#EE6600; background:yellow">#ifdef</span><span style="color:blue; background:#CCFFFF">__cplusplus</span> 是什么意思？</p> 
<p>时常在cpp的代码之中看到这样的代码:</p> 
<p><span style="color:#EE6600; background:yellow">#ifdef</span><span style="color:blue; background:#CCFFFF">__cplusplus</span></p> 
<p>extern"C"{<!-- --></p> 
<p>#endif</p> 
<p>//一段代码</p> 
<p><span style="color:#EE6600; background:yellow">#ifdef</span><span style="color:blue; background:#CCFFFF">__cplusplus</span></p> 
<p>}</p> 
<p>#endif</p> 
<p>这样的代码到底是什么意思呢？</p> 
<p>首先，__cplusplus是cpp中的自定义宏，那么定义了这个宏的话表示这是一段cpp的代码，也就是说，上面的代码的含义是:</p> 
<p>    如果这是一段cpp的代码，那么加入extern"C"{和}处理其中的代码。</p> 
<p> </p> 
<p>    要明白为何使用extern"C"，还得从cpp中对函数的重载处理开始说起。在c++中，为了支持重载机制，在编译生成的汇编码中，要对函数的名字进行一些处理，加入比如函数的返回类型等等.而在C中，只是简单的函数名字而已，不会加入其他的信息.也就是说:C++和C对产生的函数名字的处理是不一样的.</p> 
<p>比如下面的一段简单的函数，我们看看加入和不加入extern"C"产生的汇编代码都有哪</p> 
<p>些变化:</p> 
<p> </p> 
<p>intf(void)</p> 
<p>{<!-- --></p> 
<p>return1;</p> 
<p>}</p> 
<p>在加入extern"C"的时候产生的汇编代码是:</p> 
<p>.file"test.cxx"</p> 
<p>.text</p> 
<p>.align2</p> 
<p>.globl_f</p> 
<p>.def_f;.scl2;.type32;.endef</p> 
<p>_f:</p> 
<p>pushl%ebp</p> 
<p>movl%esp，%ebp</p> 
<p>movl$1，%eax</p> 
<p>popl%ebp</p> 
<p>ret</p> 
<p>但是不加入了extern"C"之后</p> 
<p>.file"test.cxx"</p> 
<p>.text</p> 
<p>.align2</p> 
<p>.globl__Z1fv</p> 
<p>.def__Z1fv;.scl2;.type 32;.endef</p> 
<p>__Z1fv:</p> 
<p>pushl%ebp</p> 
<p>movl%esp，%ebp</p> 
<p>movl$1，%eax</p> 
<p>popl%ebp</p> 
<p>ret</p> 
<p>两段汇编代码同样都是使用gcc-S命令产生的，所有的地方都是一样的，唯独是产生的</p> 
<p>函数名，一个是_f，一个是__Z1fv。</p> 
<p>明白了加入与不加入extern"C"之后对函数名称产生的影响，我们继续我们的讨论:为什</p> 
<p>么需要使用extern"C"呢？C++之父在设计C++之时，考虑到当时已经存在了大量的C代码，</p> 
<p>为了支持原来的C代码和已经写好C库，需要在C++中尽可能的支持C，而extern"C"就是</p> 
<p>其中的一个策略。</p> 
<p>试想这样的情况:一个库文件已经用C写好了而且运行得很良好，这个时候我们需要使</p> 
<p>用这个库文件，但是我们需要使用C++来写这个新的代码。如果这个代码使用的是C++的</p> 
<p>方式链接这个C库文件的话，那么就会出现链接错误.我们来看一段代码:首先，我们使用C</p> 
<p>的处理方式来写一个函数，也就是说假设这个函数当时是用C写成的:</p> 
<p>//f1.c</p> 
<p>extern"C"</p> 
<p>{<!-- --></p> 
<p>voidf1()</p> 
<p>{<!-- --></p> 
<p>return;</p> 
<p>}</p> 
<p>}</p> 
<p>编译命令是:gcc-cf1.c-of1.o产生了一个叫f1.o的库文件。再写一段代码调用这个f1</p> 
<p>函数:</p> 
<p>//test.cxx</p> 
<p>//这个extern表示f1函数在别的地方定义，这样可以通过</p> 
<p>//编译，但是链接的时候还是需要</p> 
<p>//链接上原来的库文件.</p> 
<p>externvoidf1();</p> 
<p>intmain()</p> 
<p>{<!-- --></p> 
<p>f1();</p> 
<p>return0;</p> 
<p>}</p> 
<p>通过gcc-ctest.cxx-otest.o产生一个叫test.o的文件。然后，我们使用gcctest.of1.o来</p> 
<p>链接两个文件，可是出错了，错误的提示是:</p> 
<p>test.o(.text+0x1f):test.cxx:undefinereferenceto'f1()'</p> 
<p>也就是说，在编译test.cxx的时候编译器是使用C++的方式来处理f1()函数的，但是实</p> 
<p>际上链接的库文件却是用C的方式来处理函数的，所以就会出现链接过不去的错误:因为链</p> 
<p>接器找不到函数。</p> 
<p>因此，为了在C++代码中调用用C写成的库文件，就需要用extern"C"来告诉编译器:</p> 
<p>这是一个用C写成的库文件，请用C的方式来链接它们。</p> 
<p>比如，现在我们有了一个C库文件，它的头文件是f.h，产生的lib文件是f.lib，那么我</p> 
<p>们如果要在C++中使用这个库文件，我们需要这样写:</p> 
<p>extern"C"</p> 
<p>{<!-- --></p> 
<p>#include"f.h"</p> 
<p>}</p> 
<p>回到上面的问题，如果要改正链接错误，我们需要这样子改写test.cxx:</p> 
<p>extern"C"</p> 
<p>{<!-- --></p> 
<p>externvoidf1();</p> 
<p>}</p> 
<p>intmain()</p> 
<p>{<!-- --></p> 
<p>f1();</p> 
<p>return0;</p> 
<p>}</p> 
<p>重新编译并且链接就可以过去了.</p> 
<p>总结</p> 
<p>C和C++对函数的处理方式是不同的.extern"C"是使C++能够调用C写作的库文件的一</p> 
<p>个手段，如果要对编译器提示使用C的方式来处理函数的话，那么就要使用extern"C"来说</p> 
<p>明。 </p> 
<p><span style="color:red">另一篇文章：</span></p> 
<p> </p> 
<p><span style="color:#EE6600; background:yellow">#ifdef</span> <span style="color:blue; background:#CCFFFF"> __cplusplus</span> </p> 
<p><span style="color:#EE6600; background:yellow">#ifdef</span> <span style="color:blue; background:#CCFFFF"> __cplusplus</span> 倒底是什么意思？</p> 
<p>时常在cpp的代码之中看到这样的代码:</p> 
<p><span style="color:#EE6600; background:yellow">#ifdef</span> <span style="color:blue; background:#CCFFFF"> __cplusplus</span></p> 
<p>extern "C" {<!-- --></p> 
<p>#endif</p> 
<p>//一段代码</p> 
<p><span style="color:#EE6600; background:yellow">#ifdef</span> <span style="color:blue; background:#CCFFFF"> __cplusplus</span></p> 
<p>}</p> 
<p>#endif</p> 
<p>　　这样的代码到底是什么意思呢？首先，__cplusplus是cpp中的自定义宏，那么定义了这个宏的话表示这是一段cpp的代码，也就是说，上面的代码的含义是:如果这是一段cpp的代码，那么加入extern "C"{和}处理其中的代码。</p> 
<p>　　要明白为何使用extern"C"，还得从cpp中对函数的重载处理开始说起。在c++中，为了支持重载机制，在编译生成的汇编码中，要对函数的名字进行一些处理，加入比如函数的返回类型等等.而在C中，只是简单的函数名字而已，不会加入其他的信息.也就是说:C++和C对产生的函数名字的处理是不一样的.</p> 
<p>　　比如下面的一段简单的函数，我们看看加入和不加入extern "C"产生的汇编代码都有哪些变化:</p> 
<p>int f(void)</p> 
<p>{<!-- --></p> 
<p>return 1;</p> 
<p>}</p> 
<p>　　在加入extern"C"的时候产生的汇编代码是:</p> 
<p>.file "test.cxx"</p> 
<p>.text</p> 
<p>.align 2</p> 
<p>.globl _f</p> 
<p>.def _f; .scl 2; .type 32; .endef</p> 
<p>_f:</p> 
<p>pushl %ebp</p> 
<p>movl %esp， %ebp</p> 
<p>movl $1， %eax</p> 
<p>popl %ebp</p> 
<p>ret</p> 
<p>　　但是不加入了extern"C"之后</p> 
<p>.file "test.cxx"</p> 
<p>.text</p> 
<p>.align 2</p> 
<p>.globl __Z1fv</p> 
<p>.def __Z1fv; .scl 2; .type 32; .endef</p> 
<p>__Z1fv:</p> 
<p>pushl %ebp</p> 
<p>movl %esp， %ebp</p> 
<p>movl $1， %eax</p> 
<p>popl %ebp</p> 
<p>ret</p> 
<p>　　两段汇编代码同样都是使用gcc-S命令产生的，所有的地方都是一样的，唯独是产生的函数名，一个是_f，一个是__Z1fv。</p> 
<p>　　明白了加入与不加入extern"C"之后对函数名称产生的影响，我们继续我们的讨论:为什么需要使用extern"C"呢？C++之父在设计C++之时，考虑到当时已经存在了大量的C代码，为了支持原来的C代码和已经写好C库，需要在C++中尽可能的支持C，而extern "C"就是其中的一个策略。</p> 
<p>　　试想这样的情况:一个库文件已经用C写好了而且运行得很良好，这个时候我们需要使用这个库文件，但是我们需要使用C++来写这个新的代码。如果这个代码使用的是C++的方式链接这个C库文件的话，那么就会出现链接错误.我们来看一段代码:首先，我们使用C的处理方式来写一个函数，也就是说假设这个函数当时是用C写成的:</p> 
<p>//f1.c</p> 
<p>extern "C"</p> 
<p>{<!-- --></p> 
<p>void f1()</p> 
<p>{<!-- --></p> 
<p>return;</p> 
<p>}</p> 
<p>}</p> 
<p>　　编译命令是:gcc -cf1.c -o f1.o 产生了一个叫f1.o的库文件。再写一段代码调用这个f1函数:</p> 
<p>// test.cxx</p> 
<p>//这个extern表示f1函数在别的地方定义，这样可以通过</p> 
<p>//编译，但是链接的时候还是需要</p> 
<p>//链接上原来的库文件.</p> 
<p>extern void f1();</p> 
<p>int main()</p> 
<p>{<!-- --></p> 
<p>f1();</p> 
<p>return 0;</p> 
<p>}</p> 
<p>　　通过gcc -ctest.cxx -o test.o 产生一个叫test.o的文件。然后，我们使用gcctest.o f1.o来链接两个文件，可是出错了，错误的提示是:</p> 
<p>test.o(.text + 0x1f):test.cxx: undefinereference to 'f1()'</p> 
<p>　　也就是说，在编译test.cxx的时候编译器是使用C++的方式来处理f1()函数的，但是实际上链接的库文件却是用C的方式来处理函数的，所以就会出现链接过不去的错误:因为链接器找不到函数。</p> 
<p>　　因此，为了在C++代码中调用用C写成的库文件，就需要用extern "C"来告诉编译器:这是一个用C写成的库文件，请用C的方式来链接它们。</p> 
<p>　　比如，现在我们有了一个C库文件，它的头文件是f.h，产生的lib文件是f.lib，那么我们如果要在C++中使用这个库文件，我们需要这样写:</p> 
<p>extern "C"</p> 
<p>{<!-- --></p> 
<p>#include "f.h"</p> 
<p>}</p> 
<p>　　回到上面的问题，如果要改正链接错误，我们需要这样子改写test.cxx:</p> 
<p>extern "C"</p> 
<p>{<!-- --></p> 
<p>extern void f1();</p> 
<p>}</p> 
<p>int main()</p> 
<p>{<!-- --></p> 
<p>f1();</p> 
<p>return 0;</p> 
<p>}</p> 
<p>　　重新编译并且链接就可以过去了.</p> 
<p>　　总结</p> 
<p>C和C++对函数的处理方式是不同的.extern"C"是使C++能够调用C写作的库文件的一个手段，如果要对编译器提示使用C的方式来处理函数的话，那么就要使用extern "C"来说明。</p> 
<p>1.引言</p> 
<p>C++语言的创建初衷是“a better C”，但是这并不意味着C++中类似C语言的全局变量和函数所采用的编译和连接方式与C语言完全相同。作为一种欲与C兼容的语言，C++保留了一部分过程式语言的特点（被世人称为“不彻底地面向对象”），因而它可以定义不属于任何类的全局变量和函数。但是，C++毕竟是一种面向对象的程序设计语言，为了支持函数的重载，C++对全局函数的处理方式与C有明显的不同。</p> 
<p>2.从标准头文件说起</p> 
<p>某企业曾经给出如下的一道面试题：</p> 
<p>面试题</p> 
<p>为什么标准头文件都有类似以下的结构？</p> 
<p>#ifndef __INCvxWorksh</p> 
<p>#define __INCvxWorksh</p> 
<p><span style="color:#EE6600; background:yellow">#ifdef</span> <span style="color:blue; background:#CCFFFF"> __cplusplus</span></p> 
<p>extern "C" {<!-- --></p> 
<p>#endif</p> 
<p><span style="color:#EE6600; background:yellow">#ifdef</span> <span style="color:blue; background:#CCFFFF"> __cplusplus</span></p> 
<p>}</p> 
<p>#endif</p> 
<p>#endif</p> 
<p>分析</p> 
<p>显然，头文件中的编译宏“#ifndef__INCvxWorksh、#define__INCvxWorksh、#endif” 的作用是防止该头文件被重复引用。</p> 
<p>那么</p> 
<p><span style="color:#EE6600; background:yellow">#ifdef</span> <span style="color:blue; background:#CCFFFF"> __cplusplus</span></p> 
<p>extern "C" {<!-- --></p> 
<p>#endif</p> 
<p><span style="color:#EE6600; background:yellow">#ifdef</span> <span style="color:blue; background:#CCFFFF"> __cplusplus</span></p> 
<p>}</p> 
<p>#endif</p> 
<p>的作用又是什么呢？我们将在下文一一道来。</p> 
<p>3.深层揭密extern "C"</p> 
<p>extern "C" 包含双重含义，从字面上即可得到：首先，被它修饰的目标是“extern”的；其次，被它修饰的目标是“C”的。让我们来详细解读这两重含义。</p> 
<p>（1） 被extern "C"限定的函数或变量是extern类型的；</p> 
<p>extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。记住，下列语句：</p> 
<p>extern int a;</p> 
<p>仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。</p> 
<p>通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块 A编译生成的目标代码中找到此函数。</p> 
<p>与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。</p> 
<p>（2） 被extern "C"修饰的变量和函数是按照C语言方式编译和连接的；</p> 
<p>未加extern “C”声明时的编译方式</p> 
<p>首先看看C++中对类似C的函数是怎样编译的。</p> 
<p>作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：</p> 
<p>void foo( int x, int y );</p> 
<p>该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。_foo_int_int这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo(int x, int y )与void foo( intx, float y )编译生成的符号是不相同的，后者为_foo_int_float。</p> 
<p>同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以"."来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。</p> 
<p>未加extern"C"声明时的连接方式</p> 
<p>假设在C++中，模块A的头文件如下：</p> 
<p>// 模块A头文件　moduleA.h</p> 
<p>#ifndef MODULE_A_H</p> 
<p>#define MODULE_A_H</p> 
<p>int foo( int x, int y );</p> 
<p>#endif</p> 
<p>在模块B中引用该函数：</p> 
<p>// 模块B实现文件　moduleB.cpp</p> 
<p>＃i nclude"moduleA.h"</p> 
<p>foo(2,3);</p> 
<p>实际上，在连接阶段，连接器会从模块A生成的目标文件moduleA.obj中寻找_foo_int_int这样的符号！</p> 
<p>加extern"C"声明后的编译和连接方式</p> 
<p>加extern"C"声明后，模块A的头文件变为：</p> 
<p>// 模块A头文件　moduleA.h</p> 
<p>#ifndef MODULE_A_H</p> 
<p>#define MODULE_A_H</p> 
<p>extern "C" int foo( int x, int y);</p> 
<p>#endif</p> 
<p>在模块B的实现文件中仍然调用foo( 2,3 )，其结果是：</p> 
<p>（1）模块A编译生成foo的目标代码时，没有对其名字进行特殊处理，采用了C语言的方式；</p> 
<p>（2）连接器在为模块B的目标代码寻找foo(2,3)调用时，寻找的是未经修改的符号名_foo。</p> 
<p>如果在模块A中函数声明了foo为extern "C"类型，而模块B中包含的是extern int foo( int x, int y ) ，则模块B找不到模块A中的函数；反之亦然。</p> 
<p>所以，可以用一句话概括extern“C”这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）：</p> 
<p>实现C++与C及其它语言的混合编程。</p> 
<p>明白了C++中extern "C"的设立动机，我们下面来具体分析extern "C"通常的使用技巧。</p> 
<p>4.extern "C"的惯用法</p> 
<p>（1）在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理：</p> 
<p>extern "C"</p> 
<p>{<!-- --></p> 
<p>＃i nclude"cExample.h"</p> 
<p>}</p> 
<p>而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern "C"声明，在.c文件中包含了extern"C"时会出现编译语法错误。</p> 
<p>笔者编写的C++引用C函数例子工程中包含的三个文件的源代码如下：</p> 
<p>#ifndef C_EXAMPLE_H</p> 
<p>#define C_EXAMPLE_H</p> 
<p>extern int add(int x,int y);</p> 
<p>#endif</p> 
<p>＃i nclude"cExample.h"</p> 
<p>int add( int x, int y )</p> 
<p>{<!-- --></p> 
<p>return x + y;</p> 
<p>}</p> 
<p>// c++实现文件，调用add：cppFile.cpp</p> 
<p>extern "C"</p> 
<p>{<!-- --></p> 
<p>＃i nclude"cExample.h"</p> 
<p>}</p> 
<p>int main(int argc, char* argv[])</p> 
<p>{<!-- --></p> 
<p>add(2,3);</p> 
<p>return 0;</p> 
<p>}</p> 
<p>如果C++调用一个C语言编写的.DLL时，当包括.DLL的头文件或声明接口函数时，应加extern "C"{　}。</p> 
<p>（2）在C中引用C++语言中的函数和变量时，C++的头文件需添加extern "C"，但是在C语言中不能直接引用声明了extern "C"的该头文件，应该仅将C文件中将C++中定义的extern "C"函数声明为extern类型。</p> 
<p>笔者编写的C引用C++函数例子工程中包含的三个文件的源代码如下：</p> 
<p>//C++头文件 cppExample.h</p> 
<p>#ifndef CPP_EXAMPLE_H</p> 
<p>#define CPP_EXAMPLE_H</p> 
<p>extern "C" int add( int x, int y);</p> 
<p>#endif</p> 
<p>//C++实现文件 cppExample.cpp</p> 
<p>＃i nclude"cppExample.h"</p> 
<p>int add( int x, int y )</p> 
<p>{<!-- --></p> 
<p>return x + y;</p> 
<p>}</p> 
<p>extern int add( int x, int y );</p> 
<p>int main( int argc, char* argv[] )</p> 
<p>{<!-- --></p> 
<p>add( 2, 3 ); </p> 
<p>return 0;</p> 
<p>}</p> 
<h3><a target="_blank" name="_Toc376251331">Linux</a>系统中的poll函数</h3> 
<p><span style="color:#737373">2012</span><span style="color:#737373">年</span><span style="color:#737373">07</span><span style="color:#737373">月</span><span style="color:#737373">17</span><span style="color:#737373">日</span><span style="color:#737373"> </span><span style="color:#737373">⁄</span><span style="color:#737373"> <a target="_blank" href="http://www.chinabin.cn/category/efficient-work/commands" rel="nofollow noopener noreferrer" title="查看Linux命令中的全部文章"><span style="color:#737373">Linux</span><span style="color:#737373">命令</span></a></span> <span style="color:#737373">⁄</span><span style="color:#737373"> <a target="_blank" href="http://www.chinabin.cn/efficient-work/commands/59.html#respond" rel="nofollow noopener noreferrer" title="《Linux系统中的poll函数》上的评论"><span style="color:#737373">暂无评论</span></a></span></p> 
<p>poll()函数：这个函数是某些Unix系统提供的用于执行与select()函数同等功能的函数。</p> 
<p>函数声明：</p> 
<p>    #include &lt;poll.h&gt;</p> 
<p>    int poll(struct pollfd *fds, nfds_t nfds, int timeout);</p> 
<p>参数说明：</p> 
<p>    fds 是一个struct pollfd结构类型的数组，用来存放需要检测其状态的socket描述符或者文件描述符。每次调用这个函数之后，系统不会清空这个数组，因此操作起来比较方便。这一点和select()函数不同，调用select()函数之后，select()函数会清空它所检测的socket描述符集合，导致每次调用select()之前都必须把socket重新加入集合中。所以，select()函数适合检测一个socket描述符的清空，而poll()函数适合于大量socket描述符的情况。</p> 
<p>    nfds 是 nfds_t类型的参数，用来标记数组fds中的结构体元素的总数量。</p> 
<p>    timeout 是poll函数调用阻塞的时间，单位是毫秒。</p> 
<p>返回值：</p> 
<p>    &gt;0：数组fds中准备好读、写或者出错状态的描述符的总数量。</p> 
<p>    ==0：没有任何文件描述符准备好读、写或者出错。这个时间是由第三个参数来指定的。(0，立刻返回/+n，n毫秒/-1，一直等待)</p> 
<p>    &lt;0：poll函数调用失败，同时会自动设置全局变量errno；</p> 
<p>需要注意的是，如果待检测的文件描述符为负值，则对这个描述符的检测就会被忽略。</p> 
<p>    所以，poll() 函数的功能和返回值的含义与 select() 函数的功能和返回值的含义是完全一样的，两者之间的差别就是内部实现方式不一样，select()函数基本上可以在所有支持文件描述符操作的系统平台上运行(如：Linux 、Unix 、Windows、MacOS等)，可移植性好，而poll()函数则只有个别的的操作系统提供支持(如：SunOS、Solaris、AIX、HP提供支持，但是Linux不提供支持)，可移植性差。</p> 
<p>struct pollfd结构</p> 
<p>typedef struct pollfd{<!-- --></p> 
<p>    int fd;</p> 
<p>    short    events;    //感兴趣的事件</p> 
<p>    short    revents;    //实际发生的事件</p> 
<p>}    pollfd_t;</p> 
<p>typedef    unsigned    longnfds_t;</p> 
<p>经常检测的事件标记：POLLIN/POLLRDNORM(可读)、POLLOUT/POLLWRNORM(可写)、POLLERR(出错)或者是他们的与。如 POLLIN|POLLOUT|POLLERR。</p> 
<p>检测可读：if(fds[index].revents&amp; POLLIN) == POLLIN)    //接收数据</p> 
<p>检测可写：if((fds[index].revents&amp; POLLOUT) == POLLOUT)    //发送数据</p> 
<p>检测出错：if((fds[index].revents&amp; POLLERR) == pOLLERR)    //异常处理 </p> 
<p> </p> 
<p>应用实例：</p> 
<p> </p> 
<p> </p> 
<p>#include &lt;stdio.h&gt;</p> 
<p>#include &lt;stdlib.h&gt;</p> 
<p>#include &lt;unistd.h&gt;</p> 
<p>#include &lt;sys/socket.h&gt;</p> 
<p>#include &lt;sys/types.h&gt;</p> 
<p>#include &lt;netinet/in.h&gt;</p> 
<p>#include &lt;netdb.h&gt;</p> 
<p>#include &lt;string.h&gt;</p> 
<p>#include &lt;errno.h&gt;</p> 
<p>#include &lt;poll.h&gt;</p> 
<p> </p> 
<p>#define  LISTENQ  1024</p> 
<p>#define  MAXLINE  1024</p> 
<p>#define  OPEN_MAX  50000</p> 
<p>#define  SERVER_PORT  3333</p> 
<p> </p> 
<p>int  main(int argc,char **argv)</p> 
<p>{<!-- --></p> 
<p>  int  i,max,listenfd,connfd,sockfd;</p> 
<p>  int  nready;</p> 
<p>  size_t  n;</p> 
<p>  socklen_t  clilen;</p> 
<p>  struct  sockaddr_in  servaddr,cliaddr;</p> 
<p>  struct  hostent  *hp;</p> 
<p>  char  buf[1024];</p> 
<p>  struct  pollfd  client[OPEN_MAX];</p> 
<p> </p> 
<p>  if(argc != 2){<!-- --></p> 
<p>    printf("usage:%s &lt;hostname&gt;\n",argv[0]);</p> 
<p>    exit(1);</p> 
<p>  }</p> 
<p> </p> 
<p>  if((listenfd = socket(AF_INET,SOCK_STREAM,0)) &lt; 0){<!-- --></p> 
<p>    printf("socket error!\n");</p> 
<p>    exit(1);</p> 
<p>  }</p> 
<p> </p> 
<p>  bzero(&amp;servaddr,sizeof(servaddr));</p> 
<p>  servaddr.sin_family = AF_INET;</p> 
<p> </p> 
<p>  if(!(hp = gethostbyname(argv[1]))){<!-- --></p> 
<p>    printf("gethostbyname error!\n");</p> 
<p>    exit(1);</p> 
<p>  }</p> 
<p>  bcopy(hp-&gt;h_addr,(struct sockaddr*)&amp;servaddr.sin_addr,hp-&gt;h_length);</p> 
<p> </p> 
<p>  servaddr.sin_port = htons(SERVER_PORT);</p> 
<p> </p> 
<p>  if(bind(listenfd,(struct sockaddr*)&amp;servaddr,sizeof(servaddr)) &lt; 0){<!-- --></p> 
<p>    printf("bind error!\n");</p> 
<p>    exit(1);</p> 
<p>  }</p> 
<p> </p> 
<p>  listen(listenfd,LISTENQ);</p> 
<p> </p> 
<p>  client[0].fd = listenfd;</p> 
<p>  client[0].events = POLLIN;</p> 
<p> </p> 
<p>  for(i=1;i&lt;OPEN_MAX;i++){<!-- --></p> 
<p>    client[i].fd = -1;</p> 
<p>  }</p> 
<p>  max = 0;</p> 
<p> </p> 
<p>  while(1){<!-- --></p> 
<p>    nready = poll(client,max+1,-1);</p> 
<p> </p> 
<p>    if(client[0].revents &amp; POLLIN){<!-- --></p> 
<p>      connfd = accept(listenfd,(struct sockaddr*)&amp;servaddr,&amp;clilen);</p> 
<p>      for(i=1;i&lt;OPEN_MAX;++i){<!-- --></p> 
<p>        if(client[i].fd &lt; 0){<!-- --></p> 
<p>          client[i].fd = connfd;</p> 
<p>          client[i].events = POLLIN;</p> 
<p>          break;</p> 
<p>        }</p> 
<p>        if(i == OPEN_MAX){<!-- --></p> 
<p>          printf("too many clients\n");</p> 
<p>          exit(1);</p> 
<p>        }</p> 
<p>        if(i&gt;max)</p> 
<p>          max = i;</p> 
<p>        if(--nready &lt;= 0)</p> 
<p>          continue;</p> 
<p>      }</p> 
<p> </p> 
<p>      for(i=i;i&lt;max;i++){<!-- --></p> 
<p>        if((sockfd = client[i].fd) &lt; 0)</p> 
<p>          continue;</p> 
<p>        if(client[i].revents &amp; (POLLIN|POLLERR)){<!-- --></p> 
<p>          if((n = read(sockfd,buf,MAXLINE)) &lt; 0){<!-- --></p> 
<p>            if(errno == ECONNRESET){<!-- --></p> 
<p>              close(sockfd);</p> 
<p>              client[i].fd = -1;</p> 
<p>            }</p> 
<p>            else</p> 
<p>              printf("read error\n");</p> 
<p>          }</p> 
<p>          else if(n==0){<!-- --></p> 
<p>            close(sockfd);</p> 
<p>            client[i].fd = -1;</p> 
<p>          }</p> 
<p>          else</p> 
<p>            write(sockfd,buf,n);</p> 
<p> </p> 
<p>          if(--nready &lt;= 0)</p> 
<p>            break;</p> 
<p>        }</p> 
<p>      }</p> 
<p>    }</p> 
<p>  }</p> 
<p>}</p> 
<h3><a target="_blank" href="http://www.cnblogs.com/276815076/archive/2010/09/09/1822598.html" rel="nofollow noopener noreferrer">ubuntu下配置vim</a><a target="_blank" name="_Toc376251332"></a></h3> 
<p><span style="color:#333333">1</span><span style="color:#333333">、安装</span><span style="color:#333333">vim<br>        sudo apt-get install vim-full<br> 2</span><span style="color:#333333">、配置文件的位置</span><span style="color:#333333"><br> </span><span style="color:#333333">在目录</span><span style="color:#333333">/etc/vim</span><span style="color:#333333">下面，有个名为</span><span style="color:#333333">vimrc</span><span style="color:#333333">的文件，这是系统中公共的</span><span style="color:#333333">vim</span><span style="color:#333333">配置文件，对所有用户都有效。</span><span style="color:#333333"><br>        3</span><span style="color:#333333">、设置语法高亮显示</span><span style="color:#333333"><br> 1) </span><span style="color:#333333">打开</span><span style="color:#333333">vimrc</span><span style="color:#333333">，添加以下语句来使得语法高亮显示：</span><span style="color:#333333"><br> syntax on<br> 2) </span><span style="color:#333333">如果此时语法还是没有高亮显示，那么在</span><span style="color:#333333">/etc</span><span style="color:#333333">目录下的</span><span style="color:#333333">profile</span><span style="color:#333333">文件中添加以下语句：</span><span style="color:#333333"><br> export TERM=xterm-color<br>      </span><span style="color:#333333"> </span><span style="color:#333333"><br>        4</span><span style="color:#333333">、设置</span><span style="color:#333333">Windows</span><span style="color:#333333">风格的</span><span style="color:#333333">C/C++</span><span style="color:#333333">自动缩进（添加以下</span><span style="color:#333333">set</span><span style="color:#333333">语句到</span><span style="color:#333333">vimrc</span><span style="color:#333333">中）</span><span style="color:#333333"><br>              1</span><span style="color:#333333">）设置（软）制表符宽度为</span><span style="color:#333333">4</span><span style="color:#333333">：</span><span style="color:#333333"><br>                            set tabstop=4<br>                            set softtabstop=4<br>              2</span><span style="color:#333333">）设置缩进的空格数为</span><span style="color:#333333">4<br>                          set shiftwidth=4<br>              3</span><span style="color:#333333">）设置自动缩进：即每行的缩进值与上一行相等；使用</span><span style="color:#333333">noautoindent </span><span style="color:#333333">取消设置：</span><span style="color:#333333"><br> set autoindent<br>              4</span><span style="color:#333333">）设置使用</span><span style="color:#333333"> C/C++ </span><span style="color:#333333">语言的自动缩进方式：</span><span style="color:#333333"><br>                          set cindent<br>              5</span><span style="color:#333333">）设置</span><span style="color:#333333">C/C++</span><span style="color:#333333">语言的具体缩进方式：</span><span style="color:#333333"><br>                            set cinoptions={0,1s,t0,n-2,p2s,(03s,=.5s,&gt;1s,=1s,:1s<br>              6</span><span style="color:#333333">）如果想在左侧显示文本的行号，可以用以下语句：</span><span style="color:#333333"><br>                          set nu<br>              7</span><span style="color:#333333">）最后，如果没有下列语句，就加上吧：</span><span style="color:#333333"><br> if &amp;term=="xterm"<br> set t_Co=8<br>              sett_Sb=^[[4%dm<br> set t_Sf=^[[3%dm<br> endif</span></p> 
<h3><a target="_blank" name="_Toc376251333">VIM</a>查找替换归纳总结zz</h3> 
<p><a target="_blank" href="http://spaces.msn.com/dingy/blog/cns!2F24B9E66A542581!327.entry" rel="nofollow noopener noreferrer"><span style="color:#258FB8">http://spaces.msn.com/dingy/blog/cns!2F24B9E66A542581!327.entry</span></a><span style="color:#444444"> </span>VIM中常用的替换模式总结。</p> 
<p>1，简单替换表达式</p> 
<p>替换命令可以在全文中用一个单词替换另一个单词：</p> 
<p>:%s/four/4/g</p> 
<p> </p> 
<p>”%” 范围前缀表示在所有行中执行替换。最后的 “g” 标记表示替换行中的所有匹配点。如果仅仅对当前行进行操作，那么只要去掉%即可</p> 
<p>  如果你有一个象 “thirtyfour” 这样的单词，上面的命令会出错。这种情况下，这个单词会被替换成”thirty4”。要解决这个问题，用“\&lt;” 来指定匹配单词开头：</p> 
<p>      :%s/\&lt;four/4/g</p> 
<p>显然，这样在处理 “fourty” 的时候还是会出错。用“\&gt;” 来解决这个问题：</p> 
<p>      :%s/\&lt;four\&gt;/4/g</p> 
<p>如果你在编码，你可能只想替换注释中的 “four”，而保留代码中的。由于这很难指定，可以在替换命令中加一个 “c” 标记，这样，Vim 会在每次替换前提示你：</p> 
<p>      :%s/\&lt;four\&gt;/4/gc</p> 
<p>2，删除多余的空格</p> 
<p>要删除这些每行后面多余的空格，可以执行如下命令：</p> 
<p>      :%s/\s\+$//</p> 
<p>命令前面指明范围是 “%”，所以这会作用于整个文件。”substitute”命令的匹配模式是</p> 
<p>“\s\+$”。这表示行末（$）前的一个或者多个（\+）空格（\s）。替换命令的 “to” 部分是空的：”//”。这样就会删除那些匹配的空白字符。</p> 
<p>3，匹配重复性模式</p> 
<p>星号项 “*” 规定在它前面的项可以重复任意次。因此:</p> 
<p>      /a*</p> 
<p>匹配 “a”，”aa”，”aaa”，等等。但也匹配 “” (空字串)，因为零次也包含在内。星号 “*” 仅仅应用于那个紧邻在它前面的项。因此 “ab*” 匹配 “a”，”ab”，”abb”,”abbb”，等等。如要多次重复整个字符串，那么该字符串必须被组成一个项。组成一项的方法就是在它前面加 “\(“，后面加 “\)”。因此这个命令:</p> 
<p>      /\(ab\)*</p> 
<p>匹配: “ab”，”abab”，”ababab”，等等。而且也匹配“”。</p> 
<p>要避免匹配空字串，使用 “\+”。这表示前面一项可以被匹配一次或多次。</p> 
<p>      /ab\+</p> 
<p>匹配 “ab”，”abb”，”abbb”，等等。它不匹配 后面没有跟随 “b” 的 “a”。</p> 
<p>要匹配一个可选项，用 “\=”。 例如:</p> 
<p>      /folders\=</p> 
<p>匹配 “folder” 和 “folders”。</p> 
<p>4，指定重复次数</p> 
<p>要匹配某一项的特定次数重复，使用 “\{n,m}” 这样的形式。其中“n” 和 “m” 都是数字。在它前面的那个项将被重复 “n” 到 “m” 次(|inclusive| 包含 “n” 和 “m”)。例如:</p> 
<p>      /ab\{3,5}</p> 
<p>匹配 “abbb”，”abbbb” 以及 “abbbbb”。</p> 
<p>  当 “n” 省略时，被默认为零。当 “m” 省略时，被默认为无限大。当“,m” 省略时，就表示重复正好 “n” 次。例如:</p> 
<p>      模式          匹配次数</p> 
<p>      \{,4}           0，1，2，3 或 4</p> 
<p>      \{3,}           3，4，5，等等</p> 
<p>      \{0,1}          0 或 1，同 \=</p> 
<p>      \{0,}           0 或更多，同 *</p> 
<p>      \{1,}           1 或更多，同 \+</p> 
<p>      \{3}            3</p> 
<p>5，多选一匹配</p> 
<p>在一个查找模式中，”或” 运算符是 “\|”。例如:</p> 
<p>      /foo\|bar</p> 
<p>这个命令匹配了 “foo” 或 “bar”。更多的抉择可以连在后面:</p> 
<p>      /one\|two\|three</p> 
<p>匹配 “one”，”two” 或 “three”。</p> 
<p>  如要匹配其多次重复，那么整个抉择结构须置于 “\(” 和 “\)” 之间:</p> 
<p>      /\(foo\|bar\)\+</p> 
<p>这个命令匹配 “foo”，”foobar”，”foofoo”，”barfoobar”，等等。</p> 
<p>  再举个例子:</p> 
<p>      /end\(if\|while\|for\)</p> 
<p>这个命令匹配 “endif”，”endwhile”和 “endfor”。</p> 
<p> </p> 
<h3><a target="_blank" href="http://blog.csdn.net/fpmystar/article/details/3952766" rel="noopener noreferrer">Linux下转换字符集(UTF8转换)（转）</a><a target="_blank" name="_Toc376251334"></a></h3> 
<p><span style="color:#999999">分类：</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/fpmystar/article/category/513069" rel="noopener noreferrer"><span style="color:#336699">linux</span><span style="color:#336699">研究</span></a></span><span style="color:#999999">2009-03-0314:14</span><span style="color:#999999"> </span><span style="color:#999999">2616</span><span style="color:#999999">人阅读</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/fpmystar/article/details/3952766#comments" rel="noopener noreferrer"><span style="color:#336699">评论</span></a></span>(0)<span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" title="收藏"><span style="color:#336699">收藏</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/fpmystar/article/details/3952766#report" title="举报" rel="noopener noreferrer"><span style="color:#336699">举报</span></a></span></p> 
<p><span style="color:#333333"><a target="_blank" href="http://www.csdn.net/tag/linux" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">linux</span></a><a target="_blank" href="http://www.csdn.net/tag/%e8%af%ad%e8%a8%80" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">语言</span></a></span><a target="_blank" href="http://www.csdn.net/tag/class" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">class</span></a><a target="_blank" href="http://www.csdn.net/tag/%e7%bc%96%e7%a8%8b" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">编程</span></a><a target="_blank" href="http://www.csdn.net/tag/file" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">file</span></a><a target="_blank" href="http://www.csdn.net/tag/c" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">c</span></a></p> 
<p><span style="color:#333333"> </span><span style="color:#333333">在</span><span style="color:#333333">LINUX</span><span style="color:#333333">上进行编码转换时</span><span style="color:#333333">,</span><span style="color:#333333">既可以利用</span><span style="color:#333333">iconv</span><span style="color:#333333">函数族编程实现</span><span style="color:#333333">,</span><span style="color:#333333">也可以利用</span><span style="color:#333333">iconv</span><span style="color:#333333">命令来实现</span><span style="color:#333333">,</span><span style="color:#333333">只不过后者是针对文件的</span><span style="color:#333333">,</span><span style="color:#333333">即将指定文件从一种编码转换为另一种编码。</span><span style="color:#333333"><br> </span><span style="color:#333333">一、利用</span><span style="color:#333333">iconv</span><span style="color:#333333">函数族进行编码转换</span><span style="color:#333333"><br> iconv</span><span style="color:#333333">函数族的头文件是</span><span style="color:#333333">iconv.h,</span><span style="color:#333333">使用前需包含之。</span><span style="color:#333333"><br> #include &lt;iconv.h&gt;<br> iconv</span><span style="color:#333333">函数族有三个函数</span><span style="color:#333333">,</span><span style="color:#333333">原型如下</span><span style="color:#333333">:<br> (1) iconv_t iconv_open(const char *tocode, const char *fromcode);<br> </span><span style="color:#333333">此函数说明将要进行哪两种编码的转换</span><span style="color:#333333">,tocode</span><span style="color:#333333">是目标编码</span><span style="color:#333333">,fromcode</span><span style="color:#333333">是原编码</span><span style="color:#333333">,</span><span style="color:#333333">该函数返回一个转换句柄</span><span style="color:#333333">,</span><span style="color:#333333">供以下两个函数使用。</span><span style="color:#333333"><br> (2) size_t iconv(iconv_t cd,char **inbuf,size_t *inbytesleft,char**outbuf,size_t *outbytesleft);<br> </span><span style="color:#333333">此函数从</span><span style="color:#333333">inbuf</span><span style="color:#333333">中读取字符</span><span style="color:#333333">,</span><span style="color:#333333">转换后输出到</span><span style="color:#333333">outbuf</span><span style="color:#333333">中</span><span style="color:#333333">,inbytesleft</span><span style="color:#333333">用以记录还未转换的字符数</span><span style="color:#333333">,outbytesleft</span><span style="color:#333333">用以记录输出缓冲的剩余空间。</span></p> 
<p><span style="color:#333333">(3) int iconv_close(iconv_t cd);<br> </span><span style="color:#333333">此函数用于关闭转换句柄</span><span style="color:#333333">,</span><span style="color:#333333">释放资源。</span><span style="color:#333333"><br> </span><span style="color:#333333">例子</span><span style="color:#333333">1:</span><span style="color:#333333">用</span><span style="color:#333333">C</span><span style="color:#333333">语言实现的转换示例程序</span><span style="color:#333333"><br> <br> /* f.c :</span><span style="color:#333333"> </span><span style="color:red">代码转换示例</span><span style="color:red">C</span><span style="color:red">程序</span><span style="color:#333333"> </span><span style="color:#333333">*/</span><strong><span style="color:red">具体讲，自己的验证实现是根据文中的</span><span style="color:red">f.c</span><span style="color:red">实现的</span></strong><span style="color:#333333"><br> #include &lt;iconv.h&gt;<br> #define OUTLEN 255<br> main()<br> {<!-- --><br> char *in_utf8 = "</span><span style="color:#333333">姝ｅ</span><span style="color:#333333">?</span><span style="color:#333333">ㄥ</span><span style="color:#333333">??</span><span style="color:#333333">瑁</span><span style="color:#333333">?";</span><span style="color:red">&lt;=======</span><span style="color:red">此字符串似乎并不是</span><span style="color:red">“</span><span style="color:red">正在安装</span><span style="color:red">”</span><span style="color:red">四个字的</span><span style="color:red">UTF8</span><span style="color:red">的对照串，</span><span style="color:#333333"><br> char *in_gb2312 = "</span><span style="color:#333333">正在安装</span><span style="color:#333333">";<br> char out[OUTLEN];<br> <br> //unicode</span><span style="color:#333333">码转为</span><span style="color:#333333">gb2312</span><span style="color:#333333">码</span><span style="color:#333333"><br> rc = u2g(in_utf8,strlen(in_utf8),out,OUTLEN);<br> printf("unicode--&gt;gb2312 out=%sn",out);<br> //gb2312</span><span style="color:#333333">码转为</span><span style="color:#333333">unicode</span><span style="color:#333333">码</span><span style="color:#333333"><br> rc = g2u(in_gb2312,strlen(in_gb2312),out,OUTLEN);<br> printf("gb2312--&gt;unicode out=%sn",out);<br> }<br> //</span><span style="color:#333333">代码转换</span><span style="color:#333333">:</span><span style="color:#333333">从一种编码转为另一种编码</span><span style="color:#333333"><br> int code_convert(char *from_charset,char *to_charset,char *inbuf,int inlen,char*outbuf,int outlen)<br> {<!-- --><br> iconv_t cd;<br> int rc;<br> char **pin = &amp;inbuf;<br> char **pout = &amp;outbuf;<br> <br> cd = iconv_open(to_charset,from_charset);<br> if (cd==0) return -1;<br> memset(outbuf,0,outlen);<br> if (iconv(cd,pin,&amp;inlen,pout,&amp;outlen)==-1) return -1;<br> iconv_close(cd);<br> return 0;<br> }<br> //UNICODE</span><span style="color:#333333">码转为</span><span style="color:#333333">GB2312</span><span style="color:#333333">码</span><span style="color:#333333"><br> int u2g(char *inbuf,int inlen,char *outbuf,int outlen)<br> {<!-- --><br> return code_convert("utf-8","gb2312",inbuf,inlen,outbuf,outlen);<br> }<br> //GB2312</span><span style="color:#333333">码转为</span><span style="color:#333333">UNICODE</span><span style="color:#333333">码</span><span style="color:#333333"><br> int g2u(char *inbuf,size_t inlen,char *outbuf,size_t outlen)<br> {<!-- --><br> returncode_convert("gb2312","utf-8",inbuf,inlen,outbuf,outlen);<br> }<br> <br> </span><span style="color:#333333">例子</span><span style="color:#333333">2:</span><span style="color:#333333">用</span><span style="color:#333333">C++</span><span style="color:#333333">语言实现的转换示例程序</span><span style="color:#333333"><br> <br> /* f.cpp : </span><span style="color:#333333">代码转换示例</span><span style="color:#333333">C++</span><span style="color:#333333">程序</span><span style="color:#333333"> */<br> #include &lt;iconv.h&gt;<br> #include &lt;iostream&gt;<br> <br> #define OUTLEN 255<br> <br> using namespace std;<br> <br> // </span><span style="color:#333333">代码转换操作类</span><span style="color:#333333"><br> class CodeConverter {<!-- --><br> private:<br> iconv_t cd;<br> public:<br> // </span><span style="color:#333333">构造</span><span style="color:#333333"><br> CodeConverter(const char *from_charset,const char *to_charset) {<!-- --><br> cd = iconv_open(to_charset,from_charset);<br> }<br> <br> // </span><span style="color:#333333">析构</span><span style="color:#333333"><br> ~CodeConverter() {<!-- --><br> iconv_close(cd);<br> }<br> <br> // </span><span style="color:#333333">转换输出</span><span style="color:#333333"><br> int convert(char *inbuf,int inlen,char *outbuf,int outlen) {<!-- --><br> char **pin = &amp;inbuf;<br> char **pout = &amp;outbuf;<br> <br> memset(outbuf,0,outlen);<br> return iconv(cd,pin,(size_t *)&amp;inlen,pout,(size_t *)&amp;outlen);<br> }<br> };<br> <br> int main(int argc, char **argv)<br> {<!-- --><br> char *in_utf8 = "</span><span style="color:#333333">姝ｅ</span><span style="color:#333333">?</span><span style="color:#333333">ㄥ</span><span style="color:#333333">??</span><span style="color:#333333">瑁</span><span style="color:#333333">?";<br> char *in_gb2312 = "</span><span style="color:#333333">正在安装</span><span style="color:#333333">";<br> char out[OUTLEN];<br> <br> // utf-8--&gt;gb2312<br> CodeConverter cc = CodeConverter("utf-8","gb2312");<br> cc.convert(in_utf8,strlen(in_utf8),out,OUTLEN);<br> cout &lt;&lt; "utf-8--&gt;gb2312 in=" &lt;&lt; in_utf8 &lt;&lt;",out=" &lt;&lt; out &lt;&lt; endl;<br> <br> // gb2312--&gt;utf-8<br> CodeConverter cc2 = CodeConverter("gb2312","utf-8");<br> cc2.convert(in_gb2312,strlen(in_gb2312),out,OUTLEN);<br> cout &lt;&lt; "gb2312--&gt;utf-8 in=" &lt;&lt; in_gb2312 &lt;&lt;",out=" &lt;&lt; out &lt;&lt; endl;<br> }<br> <br> <br> </span><span style="color:#333333">二、利用</span><span style="color:#333333">iconv</span><span style="color:#333333">命令进行编码转换</span><span style="color:#333333"><br> <br> iconv</span><span style="color:#333333">命令用于转换指定文件的编码</span><span style="color:#333333">,</span><span style="color:#333333">默认输出到标准输出设备</span><span style="color:#333333">,</span><span style="color:#333333">亦可指定输出文件。</span><span style="color:#333333"><br> <br> </span><span style="color:#333333">用法：</span><span style="color:#333333">iconv [</span><span style="color:#333333">选项</span><span style="color:#333333">...][</span><span style="color:#333333">文件</span><span style="color:#333333">...]<br> <br> </span><span style="color:#333333">有如下选项可用</span><span style="color:#333333">:<br> <br> </span><span style="color:#333333">输入</span><span style="color:#333333">/</span><span style="color:#333333">输出格式规范：</span><span style="color:#333333"><br> -f, --from-code=</span><span style="color:#333333">名称</span><span style="color:#333333">原始文本编码</span><span style="color:#333333"><br> -t, --to-code=</span><span style="color:#333333">名称</span><span style="color:#333333">输出编码</span><span style="color:#333333"><br> <br> </span><span style="color:#333333">信息：</span><span style="color:#333333"><br> -l, --list </span><span style="color:#333333">列举所有已知的字符集</span><span style="color:#333333"><br> <br> </span><span style="color:#333333">输出控制：</span><span style="color:#333333"><br> -c </span><span style="color:#333333">从输出中忽略无效的字符</span><span style="color:#333333"><br> -o, --output=FILE </span><span style="color:#333333">输出文件</span><span style="color:#333333"><br> -s, --silent </span><span style="color:#333333">关闭警告</span><span style="color:#333333"><br> --verbose </span><span style="color:#333333">打印进度信息</span><span style="color:#333333"><br> <br> -?, --help </span><span style="color:#333333">给出该系统求助列表</span><span style="color:#333333"><br> --usage </span><span style="color:#333333">给出简要的用法信息</span><span style="color:#333333"><br> -V, --version </span><span style="color:#333333">打印程序版本号</span><span style="color:#333333"><br> <br> </span><span style="color:#333333">例子</span><span style="color:#333333">:<br> iconv -f utf-8 -t gb2312 aaa.txt &gt;bbb.txt<br> </span><span style="color:#333333">这个命令读取</span><span style="color:#333333">aaa.txt</span><span style="color:#333333">文件，从</span><span style="color:#333333">utf-8</span><span style="color:#333333">编码转换为</span><span style="color:#333333">gb2312</span><span style="color:#333333">编码</span><span style="color:#333333">,</span><span style="color:#333333">其输出定向到</span><span style="color:#333333">bbb.txt</span><span style="color:#333333">文件。</span></p> 
<p> </p> 
<h3><a target="_blank" href="http://blog.csdn.net/lhf_tiger/article/details/8291984" rel="noopener noreferrer">pthread_attr_setdetachstate</a><a target="_blank" name="_Toc376251335"></a></h3> 
<p><span style="color:#999999">分类：</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/lhf_tiger/article/category/858937" rel="noopener noreferrer"><span style="color:#336699">Linux </span><span style="color:#336699">系列</span></a></span><span style="color:#999999">2012-12-1317:45</span><span style="color:#999999"> </span><span style="color:#999999">988</span><span style="color:#999999">人阅读</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/lhf_tiger/article/details/8291984#comments" rel="noopener noreferrer"><span style="color:#336699">评论</span></a></span>(0)<span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" title="收藏"><span style="color:#336699">收藏</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/lhf_tiger/article/details/8291984#report" title="举报" rel="noopener noreferrer"><span style="color:#336699">举报</span></a></span></p> 
<p><span style="color:#333333">在任何一个时间点上，线程是可结合的（</span><span style="color:#333333">joinable</span><span style="color:#333333">），或者是分离的（</span><span style="color:#333333">detached</span><span style="color:#333333">）。一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。</span></p> 
<p><span style="color:#333333">        </span><span style="color:#333333">线程的分离状态决定一个线程以什么样的方式来终止自己。在默认情况下线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束。只有当</span><span style="color:#333333">pthread_join</span><span style="color:#333333">（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。程序员应该根据自己的需要，选择适当的分离状态。所以如果我们在创建线程时就知道不需要了解线程的终止状态，则可以</span><span style="color:#333333">pthread_attr_t</span><span style="color:#333333">结构中的</span><span style="color:#333333">detachstate</span><span style="color:#333333">线程属性，让线程以分离状态启动。</span></p> 
<p><span style="color:#333333">设置线程分离状态的函数为</span><span style="color:#333333">pthread_attr_setdetachstate</span><span style="color:#333333">（</span><span style="color:#333333">pthread_attr_t*attr, int detachstate</span><span style="color:#333333">）。第二个参数可选为</span><span style="color:#333333">PTHREAD_CREATE_DETACHED</span><span style="color:#333333">（分离线程）和</span><span style="color:#333333"> PTHREAD_CREATE_JOINABLE</span><span style="color:#333333">（非分离线程）。这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在</span><span style="color:#333333">pthread_create</span><span style="color:#333333">函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用</span><span style="color:#333333">pthread_create</span><span style="color:#333333">的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用</span><span style="color:#333333">pthread_cond_timewait</span><span style="color:#333333">函数，让这个线程等待一会儿，留出足够的时间让函数</span><span style="color:#333333">pthread_create</span><span style="color:#333333">返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如</span><span style="color:#333333">wait</span><span style="color:#333333">（）之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</span></p> 
<p><span style="color:#333333">另外一个可能常用的属性是线程的优先级，它存放在结构</span><span style="color:#333333">sched_param</span><span style="color:#333333">中。用函数</span><span style="color:#333333">pthread_attr_getschedparam</span><span style="color:#333333">和函数</span><span style="color:#333333">pthread_attr_setschedparam</span><span style="color:#333333">进行存放，一般说来，我们总是先取优先级，对取得的值修改后再存放回去。</span></p> 
<p><strong><span style="color:#333333">线程等待</span><span style="color:#333333">——</span><span style="color:#333333">正确处理线程终止</span></strong></p> 
<p><span style="color:#333333">#include &lt;pthread.h&gt;</span></p> 
<p><span style="color:#333333">void pthread_exit(void *retval);</span></p> 
<p><span style="color:#333333">void pthread_join(pthread_t th,void *thread_return);//</span><span style="color:#333333">挂起等待</span><span style="color:#333333">th</span><span style="color:#333333">结束</span><span style="color:#333333">,*thread_return=retval;</span></p> 
<p><span style="color:#333333">int pthread_detach(pthread_t th);</span></p> 
<p><span style="color:#333333">如果线程处于</span><span style="color:#333333">joinable</span><span style="color:#333333">状态，则只能只能被创建他的线程等待终止。</span></p> 
<p><span style="color:#333333">在</span><span style="color:#333333">Linux</span><span style="color:#333333">平台默认情况下，虽然各个线程之间是相互独立的，一个线程的终止不会去通知或影响其他的线程。但是已经终止的线程的资源并不会随着线程的终止而得到释放，我们需要调用</span><span style="color:#333333">pthread_join() </span><span style="color:#333333">来获得另一个线程的终止状态并且释放该线程所占的资源。（说明：线程处于</span><span style="color:#333333">joinable</span><span style="color:#333333">状态下）</span></p> 
<p><span style="color:#333333">调用该函数的线程将挂起，等待</span><span style="color:#333333">th </span><span style="color:#333333">所表示的线程的结束。</span><span style="color:#333333">thread_return </span><span style="color:#333333">是指向线程</span><span style="color:#333333">th </span> <span style="color:#333333">返回值的指针。需要注意的是</span><span style="color:#333333">th </span> <span style="color:#333333">所表示的线程必须是</span><span style="color:#333333">joinable </span> <span style="color:#333333">的，即处于非</span><span style="color:#333333">detached</span><span style="color:#333333">（游离）状态；并且只可以有唯一的一个线程对</span><span style="color:#333333">th </span><span style="color:#333333">调用</span><span style="color:#333333">pthread_join() </span><span style="color:#333333">。如果</span><span style="color:#333333">th </span> <span style="color:#333333">处于</span><span style="color:#333333">detached </span> <span style="color:#333333">状态，那么对</span><span style="color:#333333">th </span><span style="color:#333333">的</span><span style="color:#333333">pthread_join() </span><span style="color:#333333">调用将返回错误。</span></p> 
<p><span style="color:#333333">如果不关心一个线程的结束状态，那么也可以将一个线程设置为</span><span style="color:#333333">detached </span><span style="color:#333333">状态，从而让操作系统在该线程结束时来回收它所占的资源。将一个线程设置为</span><span style="color:#333333">detached</span><span style="color:#333333">状态可以通过两种方式来实现。一种是调用</span><span style="color:#333333">pthread_detach() </span><span style="color:#333333">函数，可以将线程</span><span style="color:#333333">th </span> <span style="color:#333333">设置为</span><span style="color:#333333">detached </span> <span style="color:#333333">状态。另一种方法是在创建线程时就将它设置为</span><span style="color:#333333">detached </span><span style="color:#333333">状态，首先初始化一个线程属性变量，然后将其设置为</span><span style="color:#333333">detached </span><span style="color:#333333">状态，最后将它作为参数传入线程创建函数</span><span style="color:#333333">pthread_create()</span><span style="color:#333333">，这样所创建出来的线程就直接处于</span><span style="color:#333333">detached </span><span style="color:#333333">状态。</span></p> 
<p><span style="color:#333333">创建</span><span style="color:#333333">detach </span> <span style="color:#333333">线程：</span></p> 
<p><span style="color:#333333">pthread_t tid;</span></p> 
<p><span style="color:#333333">pthread_attr_t attr;</span></p> 
<p><span style="color:#333333">pthread_attr_init(&amp;attr);</span></p> 
<p><span style="color:#333333">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span></p> 
<p><span style="color:#333333">pthread_create(&amp;tid, &amp;attr, THREAD_FUNCTION, arg);</span></p> 
<p><span style="color:#333333">总之为了在使用</span><span style="color:#333333">pthread </span> <span style="color:#333333">时避免线程的资源在线程结束时不能得到正确释放，从而避免产生潜在的内存泄漏问题，在对待线程结束时，要确保该线程处于</span><span style="color:#333333">detached </span><span style="color:#333333">状态，否着就需要调用</span><span style="color:#333333">pthread_join() </span><span style="color:#333333">函数来对其进行资源回收。</span></p> 
<p><span style="color:#333333"> </span></p> 
<h3><a target="_blank" href="http://blog.csdn.net/pbymw8iwm/article/details/6721038" rel="noopener noreferrer"><span style="color:black">pthread_attr_init</span><span style="color:black">线程属性</span></a><a target="_blank" name="_Toc376251336"></a></h3> 
<p><strong>1．线程属性</strong></p> 
<p>       线程具有属性，用pthread_attr_t表示，在对该结构进行处理之前必须进行初始化，在使用后需要对其去除初始化。我们用pthread_attr_init函数对其初始化，用pthread_attr_destroy对其去除初始化。</p> 
<p> </p> 
<p>1．</p> 
<table border="0" cellspacing="0" cellpadding="0" align="left"><tbody><tr><td> <p>名称:：</p> </td><td> <p>pthread_attr_init/pthread_attr_destroy</p> </td></tr><tr><td> <p>功能：</p> </td><td> <p>对线程属性初始化/去除初始化</p> </td></tr><tr><td> <p>头文件：</p> </td><td> <p>#include&lt;pthread.h&gt;</p> </td></tr><tr><td> <p>函数原形：</p> </td><td> <p>int pthread_attr_init(pthread_attr_t*attr);</p> <p>int pthread_attr_destroy(pthread_attr_t*attr);</p> </td></tr><tr><td> <p>参数：</p> </td><td> <p>Attr   线程属性变量</p> </td></tr><tr><td> <p>返回值：</p> </td><td> <p>若成功返回0，若失败返回-1。</p> </td></tr></tbody></table> 
<p>      </p> 
<p> 调用pthread_attr_init之后，pthread_t结构所包含的内容就是操作系统实现支持的线程所有属性的默认值。</p> 
<p>       如果要去除对pthread_attr_t结构的初始化，可以调用pthread_attr_destroy函数。如果pthread_attr_init实现时为属性对象分配了动态内存空间，pthread_attr_destroy还会用无效的值初始化属性对象，因此如果经pthread_attr_destroy去除初始化之后的pthread_attr_t结构被pthread_create函数调用，将会导致其返回错误。</p> 
<p> </p> 
<p>线程属性结构如下：</p> 
<p>typedefstruct</p> 
<p>{<!-- --></p> 
<p>       int                               detachstate;   线程的分离状态</p> 
<p>       int                               schedpolicy;  线程调度策略</p> 
<p>       structsched_param              schedparam;  线程的调度参数</p> 
<p>       int                               inheritsched;  线程的继承性</p> 
<p>       int                                scope;       线程的作用域</p> 
<p>       size_t                           guardsize;   线程栈末尾的警戒缓冲区大小</p> 
<p>       int                                stackaddr_set;</p> 
<p>       void*                          stackaddr;   线程栈的位置</p> 
<p>       size_t                           stacksize;    线程栈的大小</p> 
<p>}pthread_attr_t;</p> 
<p> </p> 
<p>每个个属性都对应一些函数对其查看或修改。下面我们分别介绍。</p> 
<p> </p> 
<p><strong>二、线程的分离状态</strong></p> 
<p><strong>       </strong>线程的分离状态决定一个线程以什么样的方式来终止自己。在默认情况下线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</p> 
<p>而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。程序员应该根据自己的需要，选择适当的分离状态。所以如果我们在创建线程时就知道不需要了解线程的终止状态，则可以pthread_attr_t结构中的detachstate线程属性，让线程以分离状态启动。</p> 
<p><strong> </strong></p> 
<p>2．</p> 
<table border="0" cellspacing="0" cellpadding="0" align="left"><tbody><tr><td> <p>名称:：</p> </td><td> <p>pthread_attr_getdetachstate/pthread_attr_setdetachstate</p> </td></tr><tr><td> <p>功能：</p> </td><td> <p>获取/修改线程的分离状态属性</p> </td></tr><tr><td> <p>头文件：</p> </td><td> <p>#include&lt;pthread.h&gt;</p> </td></tr><tr><td> <p>函数原形：</p> </td><td> <p>int pthread_attr_getdetachstate(const pthread_attr_t *attr,int *detachstate);</p> <p>int pthread_attr_setdetachstate(pthread_attr_t *attr,intdetachstate);</p> </td></tr><tr><td> <p>参数：</p> </td><td> <p>Attr   线程属性变量</p> <p>Detachstate  线程的分离状态属性</p> </td></tr><tr><td> <p>返回值：</p> </td><td> <p>若成功返回0，若失败返回-1。</p> </td></tr></tbody></table> 
<p> </p> 
<p>可以使用pthread_attr_setdetachstate函数把线程属性detachstate设置为下面的两个合法值之一：设置为PTHREAD_CREATE_DETACHED,以分离状态启动线程；或者设置为PTHREAD_CREATE_JOINABLE,正常启动线程。可以使用pthread_attr_getdetachstate函数获取当前的datachstate线程属性。</p> 
<p> </p> 
<p>以分离状态创建线程</p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p>#iinclude&lt;pthread.h&gt;</p> <p> </p> <p>void *child_thread(void *arg)</p> <p>{<!-- --></p> <p>printf(“child thread run!\n”);</p> <p>}</p> <p> </p> <p>int main(int argc,char *argv[ ])</p> <p>{<!-- --></p> <p>      pthread_ttid;</p> <p>      pthread_attr_tattr;</p> <p> </p> <p>      pthread_attr_init(&amp;attr);</p> <p>      pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</p> <p>      pthread_create(&amp;tid,&amp;attr,fn,arg);</p> <p>      pthread_attr_destroy(&amp;attr);</p> <p>      sleep(1);</p> <p>}</p> </td></tr></tbody></table> 
<p><strong> </strong></p> 
<p><strong>三、线程的继承性</strong></p> 
<p><strong>       </strong>函数pthread_attr_setinheritsched和pthread_attr_getinheritsched分别用来设置和得到线程的继承性，这两个函数的定义如下：</p> 
<p> </p> 
<p>3.</p> 
<table border="0" cellspacing="0" cellpadding="0" align="left"><tbody><tr><td> <p>名称:：</p> </td><td> <p>pthread_attr_getinheritsched</p> <p>pthread_attr_setinheritsched</p> </td></tr><tr><td> <p>功能：</p> </td><td> <p>获得/设置线程的继承性</p> </td></tr><tr><td> <p>头文件：</p> </td><td> <p>#include&lt;pthread.h&gt;</p> </td></tr><tr><td> <p>函数原形：</p> </td><td> <p>int pthread_attr_getinheritsched(const pthread_attr_t*attr,int *inheritsched);</p> <p>int pthread_attr_setinheritsched(pthread_attr_t *attr,intinheritsched);</p> </td></tr><tr><td> <p>参数：</p> </td><td> <p>attr            线程属性变量</p> <p>inheritsched     线程的继承性</p> </td></tr><tr><td> <p>返回值：</p> </td><td> <p>若成功返回0，若失败返回-1。</p> </td></tr></tbody></table> 
<p>      </p> 
<p> 这两个函数具有两个参数，第1个是指向属性对象的指针，第2个是继承性或指向继承性的指针。继承性决定调度的参数是从创建的进程中继承还是使用在schedpolicy和schedparam属性中显式设置的调度信息。Pthreads不为inheritsched指定默认值，因此如果你关心线程的调度策略和参数，必须先设置该属性。</p> 
<p>       继承性的可能值是PTHREAD_INHERIT_SCHED（表示新现成将继承创建线程的调度策略和参数）和PTHREAD_EXPLICIT_SCHED（表示使用在schedpolicy和schedparam属性中显式设置的调度策略和参数）。</p> 
<p>       如果你需要显式的设置一个线程的调度策略或参数，那么你必须在设置之前将inheritsched属性设置为PTHREAD_EXPLICIT_SCHED.</p> 
<p>       下面我来讲进程的调度策略和调度参数。我会结合下面的函数给出本函数的程序例子。</p> 
<p> </p> 
<p> </p> 
<p><strong>四、线程的调度策略</strong></p> 
<p>       函数pthread_attr_setschedpolicy和pthread_attr_getschedpolicy分别用来设置和得到线程的调度策略。</p> 
<p> </p> 
<p>4.</p> 
<table border="0" cellspacing="0" cellpadding="0" align="left"><tbody><tr><td> <p>名称:：</p> </td><td> <p>pthread_attr_getschedpolicy</p> <p>pthread_attr_setschedpolicy</p> </td></tr><tr><td> <p>功能：</p> </td><td> <p>获得/设置线程的调度策略</p> </td></tr><tr><td> <p>头文件：</p> </td><td> <p>#include&lt;pthread.h&gt;</p> </td></tr><tr><td> <p>函数原形：</p> </td><td> <p>int pthread_attr_getschedpolicy(const pthread_attr_t*attr,int *policy);</p> <p>int pthread_attr_setschedpolicy(pthread_attr_t *attr,intpolicy);</p> </td></tr><tr><td> <p>参数：</p> </td><td> <p>attr           线程属性变量</p> <p>policy         调度策略</p> </td></tr><tr><td> <p>返回值：</p> </td><td> <p>若成功返回0，若失败返回-1。</p> </td></tr></tbody></table> 
<p>      </p> 
<p> </p> 
<p>  这两个函数具有两个参数，第1个参数是指向属性对象的指针，第2个参数是调度策略或指向调度策略的指针。调度策略可能的值是先进先出（SCHED_FIFO）、轮转法（SCHED_RR）,或其它（SCHED_OTHER）。</p> 
<p>       SCHED_FIFO策略允许一个线程运行直到有更高优先级的线程准备好，或者直到它自愿阻塞自己。在SCHED_FIFO调度策略下，当有一个线程准备好时，除非有平等或更高优先级的线程已经在运行，否则它会很快开始执行。</p> 
<p>    SCHED_RR(轮循)策略是基本相同的，不同之处在于：如果有一个SCHED_RR</p> 
<p>策略的线程执行了超过一个固定的时期(时间片间隔)没有阻塞，而另外的SCHED_RR或SCHBD_FIPO策略的相同优先级的线程准备好时，运行的线程将被抢占以便准备好的线程可以执行。</p> 
<p>    当有SCHED_FIFO或SCHED_RR策赂的线程在一个条件变量上等持或等持加锁同一个互斥量时，它们将以优先级顺序被唤醒。即，如果一个低优先级的SCHED_FIFO线程和一个高优先织的SCHED_FIFO线程都在等待锁相同的互斥且，则当互斥量被解锁时，高优先级线程将总是被首先解除阻塞。</p> 
<p> </p> 
<p><strong>五、线程的调度参数</strong></p> 
<p>       函数pthread_attr_getschedparam 和pthread_attr_setschedparam分别用来设置和得到线程的调度参数。</p> 
<p> </p> 
<p>5.</p> 
<table border="0" cellspacing="0" cellpadding="0" align="left"><tbody><tr><td> <p>名称:：</p> </td><td> <p>pthread_attr_getschedparam</p> <p>pthread_attr_setschedparam</p> </td></tr><tr><td> <p>功能：</p> </td><td> <p>获得/设置线程的调度参数</p> </td></tr><tr><td> <p>头文件：</p> </td><td> <p>#include&lt;pthread.h&gt;</p> </td></tr><tr><td> <p>函数原形：</p> </td><td> <p>int pthread_attr_getschedparam(const pthread_attr_t*attr,struct sched_param *param);</p> <p>int pthread_attr_setschedparam(pthread_attr_t *attr,conststruct sched_param *param);</p> </td></tr><tr><td> <p>参数：</p> </td><td> <p>attr           线程属性变量</p> <p>param          sched_param结构</p> </td></tr><tr><td> <p>返回值：</p> </td><td> <p>若成功返回0，若失败返回-1。</p> </td></tr></tbody></table> 
<p>      </p> 
<p>这两个函数具有两个参数，第1个参数是指向属性对象的指针，第2个参数是sched_param结构或指向该结构的指针。结构sched_param在文件/usr/include/bits/sched.h中定义如下：</p> 
<p>      </p> 
<p>structsched_param</p> 
<p>{<!-- --></p> 
<p>       intsched_priority;</p> 
<p>};</p> 
<p> </p> 
<p>结构sched_param的子成员sched_priority控制一个优先权值，大的优先权值对应高的优先权。系统支持的最大和最小优先权值可以用sched_get_priority_max函数和sched_get_priority_min函数分别得到。</p> 
<p> </p> 
<p>注意：如果不是编写实时程序，不建议修改线程的优先级。因为，调度策略是一件非常复杂的事情，如果不正确使用会导致程序错误，从而导致死锁等问题。如：在多线程应用程序中为线程设置不同的优先级别，有可能因为共享资源而导致优先级倒置。</p> 
<p> </p> 
<p>6.</p> 
<p><a target="_blank" href="http://linux.die.net/man/3/sched_get_priority_min" rel="nofollow noopener noreferrer"><span style="color:#CA0000">http://linux.die.net/man/3/sched_get_priority_min</span></a> </p> 
<p>Synopsis</p> 
<p><strong>#include &lt;<a target="_blank" href="http://linux.die.net/include/sched.h" rel="nofollow noopener noreferrer"><span style="color:#660000">sched.h</span></a>&gt;</strong></p> 
<p>int sched_get_priority_max(int <em>policy</em><strong>);<br> </strong>int sched_get_priority_min(int <em>policy</em><strong>); </strong></p> 
<p>Description</p> 
<p>The <em>sched_get_priority_max</em>()and <em>sched_get_priority_min</em>()functions shall return the appropriate maximum or minimum, respectively, forthe scheduling policy specified by<em>policy</em>.</p> 
<p>The value of <em>policy</em> shallbe one of the scheduling policy values defined in <em>&lt;<a target="_blank" href="http://linux.die.net/include/sched.h" rel="nofollow noopener noreferrer"><span style="color:#660000">sched.h</span></a>&gt;</em>.</p> 
<p>Return Value</p> 
<p>If successful, the <em>sched_get_priority_max</em>()and <em>sched_get_priority_min</em>()functions shall return the appropriate maximum or minimum values, respectively.If unsuccessful, they shall return a value of -1 and set <em>errno</em> to indicate theerror.</p> 
<p>Errors</p> 
<p>The <em>sched_get_priority_max</em>()and <em>sched_get_priority_min</em>()functions shall fail if:</p> 
<p><strong>EINVAL</strong></p> 
<p>The value of the <em>policy</em> parameterdoes not represent a defined scheduling policy.</p> 
<p> </p> 
<p>   下面是上面几个函数的程序例子：</p> 
<p> </p> 
<p>#include &lt;string.h&gt;<br> #include&lt;pthread.h&gt;<br> #include&lt;sched.h&gt;<br> void *child_thread(void *arg)<br> {<!-- --><br> int policy = 0;<br> int max_priority = 0,min_priority = 0;<br> struct sched_param param;<br> pthread_attr_t attr;<br>  <br> pthread_attr_init(&amp;attr);<br> pthread_attr_setinheritsched(&amp;attr,PTHREAD_EXPLICIT_SCHED);<br> pthread_attr_getinheritsched(&amp;attr,&amp;policy);<br> if(policy == PTHREAD_EXPLICIT_SCHED){<!-- --><br> printf("Inheritsched:PTHREAD_EXPLICIT_SCHED\n");<br> }<br> if(policy == PTHREAD_INHERIT_SCHED){<!-- --><br> printf("Inheritsched:PTHREAD_INHERIT_SCHED\n");<br> }<br>  <br> pthread_attr_setschedpolicy(&amp;attr,SCHED_RR);<br> pthread_attr_getschedpolicy(&amp;attr,&amp;policy);<br> if(policy == SCHED_FIFO){<!-- --><br> printf("Schedpolicy:SCHED_FIFO\n");<br> }<br> if(policy == SCHED_RR){<!-- --><br> printf("Schedpolicy:SCHED_RR\n");<br> }<br> if(policy == SCHED_OTHER){<!-- --><br> printf("Schedpolicy:SCHED_OTHER\n");<br> }<br> max_priority = sched_get_priority_max(policy);<br> min_priority = sched_get_priority_min(policy);<br> printf("Maxpriority:%u\n",max_priority);<br> printf("Minpriority:%u\n",min_priority);<br>  <br> param.sched_priority = max_priority;<br> pthread_attr_setschedparam(&amp;attr,&amp;param);<br> printf("sched_priority:%u\n",param.sched_priority);<br> pthread_attr_destroy(&amp;attr);<br> }<br>  <br> int main(int argc,char *argv[ ])<br> {<!-- --><br> pthread_t child_thread_id; <br> pthread_create(&amp;child_thread_id,NULL,child_thread,NULL);<br> pthread_join(child_thread_id,NULL);<br> }</p> 
<p>==[23]==gaoke@dev64_23:~/code$g++ -o test gaoke.cpp -lpthread<br> ==[23]==gaoke@dev64_23:~/code$./test<br> Inheritsched:PTHREAD_EXPLICIT_SCHED<br> Schedpolicy:SCHED_RR<br> Maxpriority:99<br> Minpriority:1<br> sched_priority:99</p> 
<p> </p> 
<h3><a target="_blank" href="http://blog.csdn.net/chary8088/article/details/4798928" rel="noopener noreferrer">Linux信号量线程控制</a><a target="_blank" name="_Toc376251337"></a></h3> 
<p><span style="color:#999999">分类：</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/chary8088/article/category/199928" rel="noopener noreferrer"><span style="color:#336699">程序相关</span></a></span><span style="color:#999999">2009-11-11 16:31</span><span style="color:#999999"> </span><span style="color:#999999">1237</span><span style="color:#999999">人阅读</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/chary8088/article/details/4798928#comments" rel="noopener noreferrer"><span style="color:#336699">评论</span></a></span>(0)<span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" title="收藏"><span style="color:#336699">收藏</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/chary8088/article/details/4798928#report" title="举报" rel="noopener noreferrer"><span style="color:#336699">举报</span></a></span></p> 
<p><span style="color:#333333"><a target="_blank" href="http://www.csdn.net/tag/linux" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">linux</span></a><a target="_blank" href="http://www.csdn.net/tag/null" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">null</span></a><a target="_blank" href="http://www.csdn.net/tag/join" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">join</span></a><a target="_blank" href="http://www.csdn.net/tag/struct" rel="noopener noreferrer"><span style="color:#336699; background:#EEEEEE">struct</span></a></span></p> 
<p><span style="color:#333333"> </span><span style="color:#333333">线程中互斥锁的使用，达到对共享资源互斥使用。除了使用互斥锁，信号量，也就是操作系统中所提到的</span><span style="color:#333333">PV</span><span style="color:#333333">原语，能达到互斥和同步的效果，这就是今天我们所要讲述的信号量线程控制。</span></p> 
<p><span style="color:#333333">PV</span><span style="color:#333333">原语是对整数计数器信号量</span><span style="color:#333333">sem</span><span style="color:#333333">的操作，一次</span><span style="color:#333333">P</span><span style="color:#333333">操作可使</span><span style="color:#333333">sem</span><span style="color:#333333">减一，而一次</span><span style="color:#333333">V</span><span style="color:#333333">操作可是</span><span style="color:#333333">sem</span><span style="color:#333333">加一。进程（或线程）根据信号量的值来判断是否对公共资源具有访问权限。当信号量的值大于零或等于零的时候，该进程（或线程）具有对公共资源访问的权限，否则，当信号量的值小于时，该进程（或线程）就会被阻塞，直到信号量的值大于或等于一。</span></p> 
<p><span style="color:#333333">1</span><span style="color:#333333">、在</span><span style="color:#333333">LINUX</span><span style="color:#333333">中，实现了</span><span style="color:#333333">POSIX</span><span style="color:#333333">的无名信号量，主要用于线程间的互斥同步，下面将简单介绍一些函数接口：</span></p> 
<p><span style="color:#333333">（</span><span style="color:#333333">1</span><span style="color:#333333">）、</span><span style="color:#333333">sem_init</span></p> 
<p><span style="color:#333333">功能：</span><span style="color:#333333">        </span><span style="color:#333333">用于创建一个信号量，并初始化信号量的值。</span></p> 
<p><span style="color:#333333">头文件：</span><span style="color:#333333">      &lt;semaphore.h&gt;</span></p> 
<p><span style="color:#333333">函数原型：</span><span style="color:#333333">    int sem_init (sem_t* sem, int pshared, unsigned int value);</span></p> 
<p><span style="color:#333333">函数传入值：</span><span style="color:#333333">  sem:</span><span style="color:#333333">信号量。</span></p> 
<p><span style="color:#333333">                   pshared:</span><span style="color:#333333">决定信号量能否在几个进程间共享。由于目前</span><span style="color:#333333">LINUX</span><span style="color:#333333">还没有实现进</span></p> 
<p><span style="color:#333333">                              </span><span style="color:#333333">程间共享信息量，所以这个值只能取</span><span style="color:#333333">0</span><span style="color:#333333">。</span></p> 
<p><span style="color:#333333">函数返回值：</span><span style="color:#333333">  0</span><span style="color:#333333">：成功。</span></p> 
<p><span style="color:#333333">                  -1</span><span style="color:#333333">：失败。</span></p> 
<p><span style="color:#333333">（</span><span style="color:#333333">2</span><span style="color:#333333">）其他函数。</span></p> 
<p><span style="color:#333333">int sem_wait       (sem_t* sem);</span></p> 
<p><span style="color:#333333">int sem_trywait   (sem_t* sem);</span></p> 
<p><span style="color:#333333">int sem_post       (sem_t* sem);</span></p> 
<p><span style="color:#333333">int sem_getvalue (sem_t* sem);</span></p> 
<p><span style="color:#333333">int sem_destroy   (sem_t* sem);</span></p> 
<p><span style="color:#333333">功能：</span><span style="color:#333333">sem_wait</span><span style="color:#333333">和</span><span style="color:#333333">sem_trywait</span><span style="color:#333333">相当于</span><span style="color:#333333">P</span><span style="color:#333333">操作，它们都能将信号量的值减一，两者的区别在</span></p> 
<p><span style="color:#333333">        </span><span style="color:#333333">于若信号量的值小于零时，</span><span style="color:#333333">sem_wait</span><span style="color:#333333">将会阻塞进程，而</span><span style="color:#333333">sem_trywait</span><span style="color:#333333">则会立即返回。</span></p> 
<p><span style="color:#333333">        sem_post</span><span style="color:#333333">相当于</span><span style="color:#333333">V</span><span style="color:#333333">操作，它将信号量的值加一，同时发出唤醒的信号给等待的进程</span></p> 
<p><span style="color:#333333">       </span><span style="color:#333333">（或线程）。</span></p> 
<p><span style="color:#333333">        sem_getvalue </span><span style="color:#333333">得到信号量的值。</span></p> 
<p><span style="color:#333333">        sem_destroy </span><span style="color:#333333">摧毁信号量。</span></p> 
<p><span style="color:#333333">函数传入值：</span><span style="color:#333333">sem:</span><span style="color:#333333">信号量。</span></p> 
<p><span style="color:#333333">函数返回值：</span><span style="color:#333333">同上。</span></p> 
<p><span style="color:#333333">2</span><span style="color:#333333">、函数实现。</span></p> 
<p><span style="color:silver">[cpp] </span><a target="_blank" href="http://blog.csdn.net/chary8088/article/details/4798928" title="view plain" rel="noopener noreferrer"><span style="color:#A0A0A0">view plain</span></a><a target="_blank" href="http://blog.csdn.net/chary8088/article/details/4798928" title="copy" rel="noopener noreferrer"><span style="color:#A0A0A0">copy</span></a></p> 
<p><span style="color:gray">#include &lt;stdio.h&gt;  </span>  </p> 
<p><span style="color:gray">#include &lt;stdlib.h&gt;  </span>  </p> 
<p><span style="color:gray">#include &lt;unistd.h&gt;  </span>  </p> 
<p><span style="color:gray">#include &lt;pthread.h&gt;  </span>  </p> 
<p><span style="color:gray">#include &lt;semaphore.h&gt;  </span>  </p> 
<p><span style="color:gray">#include &lt;errno.h&gt;  </span>  </p> 
<p>   </p> 
<p><span style="color:gray">#define return_if_fail(p)  /   </span>  </p> 
<p>        <strong><span style="color:#006699">if</span></strong>(!p){printf (<span style="color:blue">"[%s]: func error!"</span>, __func__);<strong><span style="color:#006699">return</span></strong> NULL;}     </p> 
<p>    </p> 
<p><strong><span style="color:#006699">typedef</span> <span style="color:#006699">struct</span></strong> _PrivInfo     </p> 
<p>{     </p> 
<p>  sem_t    sem;     </p> 
<p>  <strong><span style="color:seagreen">int</span></strong>      lock_var;     </p> 
<p>  <strong><span style="color:seagreen">time_t</span></strong>   end_time;     </p> 
<p>}PrivInfo;     </p> 
<p>    </p> 
<p><strong><span style="color:#006699">static</span> <span style="color:#006699">void</span></strong> info_init (PrivInfo* thiz);     </p> 
<p><strong><span style="color:#006699">static</span> <span style="color:#006699">void</span></strong> *pthread_func_1 (<strong><span style="color:#006699">void</span></strong>* thiz);     </p> 
<p><strong><span style="color:#006699">static</span> <span style="color:#006699">void</span></strong> *pthread_func_2 (<strong><span style="color:#006699">void</span></strong>* thiz);     </p> 
<p>    </p> 
<p><strong><span style="color:seagreen">int</span></strong> main (<strong><span style="color:seagreen">int</span></strong> argc, <strong><span style="color:seagreen">char</span></strong>** argv)     </p> 
<p>{     </p> 
<p>  pthread_t pt_1 = 0;     </p> 
<p>  pthread_t pt_2 = 0;     </p> 
<p>  <strong><span style="color:seagreen">int</span></strong> ret = 0;     </p> 
<p>  PrivInfo* thiz = NULL;     </p> 
<p>    </p> 
<p>  thiz = (PrivInfo* )malloc (<strong><span style="color:#006699">sizeof</span></strong> (PrivInfo));     </p> 
<p>  <strong><span style="color:#006699">if</span></strong> (thiz == NULL)     </p> 
<p>  {     </p> 
<p>    printf (<span style="color:blue">"[%s]:Failed to malloc PrivInfo./n"</span>);     </p> 
<p>    <strong><span style="color:#006699">return</span></strong> -1;     </p> 
<p>  }     </p> 
<p>    </p> 
<p>  info_init (thiz);     </p> 
<p>       </p> 
<p>  ret = pthread_create (&amp;pt_1, NULL, pthread_func_1, thiz);     </p> 
<p>  <strong><span style="color:#006699">if</span></strong> (ret != 0)     </p> 
<p>  {     </p> 
<p>    perror (<span style="color:blue">"pthread_1_create:"</span>);     </p> 
<p>  }     </p> 
<p>    </p> 
<p>  ret = pthread_create (&amp;pt_1, NULL, pthread_func_2, thiz);     </p> 
<p>  <strong><span style="color:#006699">if</span></strong> (ret != 0)     </p> 
<p>  {     </p> 
<p>    perror (<span style="color:blue">"pthread_2_create:"</span>);     </p> 
<p>  }     </p> 
<p>    </p> 
<p>  pthread_join (pt_1, NULL);     </p> 
<p>  pthread_join (pt_2, NULL);     </p> 
<p>    </p> 
<p>  sem_destroy (&amp;thiz-&gt;sem);     </p> 
<p>  free (thiz);     </p> 
<p>  thiz = NULL;     </p> 
<p>    </p> 
<p>  <strong><span style="color:#006699">return</span></strong> 0;     </p> 
<p>}     </p> 
<p>    </p> 
<p><strong><span style="color:#006699">static</span> <span style="color:#006699">void</span></strong> info_init (PrivInfo* thiz)     </p> 
<p>{     </p> 
<p>    </p> 
<p>   thiz-&gt;lock_var = 0;     </p> 
<p>   thiz-&gt;end_time = time(NULL) + 10;     </p> 
<p>    </p> 
<p>   sem_init (&amp;thiz-&gt;sem, 0,  1);     </p> 
<p>    </p> 
<p>   <strong><span style="color:#006699">return</span></strong>;     </p> 
<p>}     </p> 
<p>    </p> 
<p><strong><span style="color:#006699">static</span> <span style="color:#006699">void</span></strong> *pthread_func_1 (<strong><span style="color:#006699">void</span></strong>* th)     </p> 
<p>{   </p> 
<p>  return_if_fail(th);  </p> 
<p>    </p> 
<p>  <strong><span style="color:seagreen">int</span></strong> i = 0;     </p> 
<p>  PrivInfo* thiz = (PrivInfo*)th;  </p> 
<p>  <strong><span style="color:#006699">while</span></strong> (time(NULL) &lt; thiz-&gt;end_time)     </p> 
<p>  {     </p> 
<p>     sem_wait (&amp;thiz-&gt;sem);     </p> 
<p>     printf (<span style="color:blue">"pthread: pthread1 get lock./n"</span>);     </p> 
<p>     printf (<span style="color:blue">"the lock_var = %d/n"</span>, thiz-&gt;lock_var);   </p> 
<p>     <strong><span style="color:#006699">for</span></strong> (i = 0; i &lt; 2; i ++)     </p> 
<p>     {     </p> 
<p>         thiz-&gt;lock_var ++;     </p> 
<p>         sleep (1);     </p> 
<p>     }     </p> 
<p>    </p> 
<p>     sem_post (&amp;thiz-&gt;sem);     </p> 
<p>       </p> 
<p>     sleep (1);    </p> 
<p>  }     </p> 
<p>  </p> 
<p>  </p> 
<p>   <strong><span style="color:#006699">return</span></strong> NULL;     </p> 
<p>}     </p> 
<p>    </p> 
<p><strong><span style="color:#006699">static</span> <span style="color:#006699">void</span></strong> *pthread_func_2 (<strong><span style="color:#006699">void</span></strong>* th)     </p> 
<p>{    </p> 
<p>   return_if_fail(th);  </p> 
<p>    </p> 
<p>   PrivInfo* thiz = (PrivInfo*)th;  </p> 
<p>   <strong><span style="color:#006699">while</span></strong> (time (NULL) &lt; thiz-&gt;end_time)     </p> 
<p>   {     </p> 
<p>      sem_wait (&amp;thiz-&gt;sem);     </p> 
<p>      printf (<span style="color:blue">"pthread2: pthread2 get lock!/n"</span>);     </p> 
<p>      printf (<span style="color:blue">"the lock_var = %d/n"</span>, thiz-&gt;lock_var);         </p> 
<p>      sem_post (&amp;thiz-&gt;sem);     </p> 
<p>      sleep (3);     </p> 
<p>   }     </p> 
<p>   <strong><span style="color:#006699">return</span></strong> NULL;     </p> 
<p>}   </p> 
<h3><a target="_blank" href="http://blog.csdn.net/xuefu2008/article/details/4645026" rel="noopener noreferrer">C语言中printf格式化输出函数 </a><a target="_blank" name="_Toc376251338"></a></h3> 
<p>分类：<a target="_blank" href="http://blog.csdn.net/xuefu2008/article/category/602148" rel="noopener noreferrer">C语言</a> 2009-10-09 11:18 24081人阅读 <a target="_blank" href="http://blog.csdn.net/xuefu2008/article/details/4645026#comments" rel="noopener noreferrer"> 评论</a>(1) <a target="_blank" title="收藏">收藏</a><a target="_blank" href="http://blog.csdn.net/xuefu2008/article/details/4645026#report" title="举报" rel="noopener noreferrer">举报</a></p> 
<p><a target="_blank" href="http://www.csdn.net/tag/%e8%af%ad%e8%a8%80" rel="noopener noreferrer">语言</a><a target="_blank" href="http://www.csdn.net/tag/c" rel="noopener noreferrer">c</a><a target="_blank" href="http://www.csdn.net/tag/%e6%89%a9%e5%b1%95" rel="noopener noreferrer">扩展</a></p> 
<p>目录<a target="_blank" href="http://blog.csdn.net/xuefu2008/article/details/4645026" title="系统根据文章中H1到H6标签自动生成文章目录" rel="noopener noreferrer">(?)</a><a target="_blank" href="http://blog.csdn.net/xuefu2008/article/details/4645026" title="展开" rel="noopener noreferrer">[+]</a></p> 
<p>用 法:</p> 
<p>　　intprintf(const char *format,[argument]);</p> 
<p>　　format 参数输出的格式，定义格式为：</p> 
<p>　　%[flags][width][.perc][F|N|h|l]type</p> 
<p>　　规定数据输出方式，具体如下：</p> 
<p>　　1.type 含义如下：</p> 
<p>　　d 有符号10进制整数</p> 
<p>　　i 有符号10进制整数</p> 
<p>　　o 有符号8进制整数</p> 
<p>　　u 无符号10进制整数</p> 
<p>　　x 无符号的16进制数字，并以小写abcdef表示</p> 
<p>　　X 无符号的16进制数字，并以大写ABCDEF表示</p> 
<p>　　F/f 浮点数</p> 
<p>　　E/e 用科学表示格式的浮点数</p> 
<p>　　g 使用%f和%e表示中的总的位数表示最短的来表示浮点数 G 同g格式，但表示为指数</p> 
<p>　　c 单个字符</p> 
<p>　　s 字符串</p> 
<p>　　% 显示百分号本身</p> 
<p>　　p 显示一个指针，near指针表示为：XXXX</p> 
<p>　　far 指针表示为：XXXX：YYYY</p> 
<p>　　n 相连参量应是一个指针，其中存放已写字符的个数</p> 
<p>　　2.flags 规定输出格式，取值和含义如下：</p> 
<p>　　无 右对齐，左边填充0和空格</p> 
<p>　　- 左对齐，右边填充空格</p> 
<p>　　+ 在数字前增加符号 + 或 -</p> 
<p>　　一个空格 只对负数显示符号</p> 
<p>　　# 当type=c,s,d,i,u时没有影响</p> 
<p>　　type=o,x,X时，分别在数值前增加'0',"0x","0X"</p> 
<p>　　type=e,E,f时，总是使用小数点</p> 
<p>　　type=g,G时，除了数值为0外总是显示小数点 3.width 用于控制显示数值的宽度，取值和含义如下n(n=1,2,3...) 宽度至少为n位，不够以空格填充</p> 
<p>　　0n(n=1,2,3...)宽度至少为n位，不够左边以0填充 * 格</p> 
<p>　　式列表中，下一个参数还是width4.prec 用于控制小数点后面的位数，取值和含义如下：</p> 
<p>　　无 按缺省精度显示</p> 
<p>　　0 当type=d,i,o,u,x时，没有影响</p> 
<p>　　type=e,E,f时，不显示小数点</p> 
<p>　　n(n=1,2,3...)当type=e,E,f时表示的最大小数位数</p> 
<p>　　type=其他，表示显示的最大宽度 .*</p> 
<p>　　格式列表中，下一个参数还是width</p> 
<p>　　5.F|N|h|l 表示指针是否是远指针或整数是否是长整数</p> 
<p>　　F 远指针</p> 
<p>　　n 近指针</p> 
<p>　　h短整数或单精度浮点数</p> 
<p>　　l 长整数或双精度浮点数</p> 
<p>　　1.一般格式</p> 
<p>　　printf(格式控制，输出表列）</p> 
<p>　　例如：printf("i=%d,ch=%c/n",i,ch);</p> 
<p>　　说明:</p> 
<p>　　(1)“格式控制”是用双撇号括起来的字符串，也称“转换控制字符串”，它包括两种信息：</p> 
<p>　　①格式说明：由“%”和格式字符组成，它的作用是将输出的数据转换为指定的格式输出。</p> 
<p>　　②普通字符，即需要原样输出的字符。</p> 
<p>　　（2）“输出表列”是需要输出的一些数据，可以是表达式</p> 
<p>　　(3）printf函数的一般形式可以表示为</p> 
<p>　　printf(参数1，参数2，……，参数n)</p> 
<p>　　功能是将参数2～参数n按参数1给定的格式输出</p> 
<p>　　2.格式字符（9种）</p> 
<p>　　（1）d（或i）格式符。用来输出十进制整数，有以下几种用法：</p> 
<p>　　①%d，按整型数据的实际长度输出。</p> 
<p>　　②%md，m为指定的输出字段的宽度。如果数据的位数小于m，则左端补以空格，若大于m，则按实际位数输出。</p> 
<p>　　③%ld(%mld 也可)，输出长整型数据。</p> 
<p>　　例如：longa=123456;</p> 
<p>　　printf("%ld",a);</p> 
<p>　　（2）o格式符，以八进制数形式输出整数。格式：%o，%mo,%lo，%mlo都可。</p> 
<p>　　（3）x(或X)格式符，以十六进制数形式输出整数。格式：%x，%mx,%lx，%mlx都可。</p> 
<p>　　(4)u格式符，用来输出unsigned型数据，即无符号数，以十进制数形式输出。格式：%u，%mu,%lu都可。</p> 
<p>　　参见:li4-3.c/*无符号数据的输出*/</p> 
<p>　　(5)c格式符，用来输出一个字符。格式：%c，%mc都可。</p> 
<p>　　(6)s格式符，用来输出一个字符串。格式：%s，%ms,%-ms，%m.ns，%-m.ns都可。</p> 
<p>　　参见：li4-5.c/*字符串的输出*/</p> 
<p>　　（7）f格式符，用来输出实数（包括单、双精度），以小数形式输出。格式：%f，%m.nf，%-m.nf都可。</p> 
<p>　　注意：单精度实数的有效位数一般为7位，双精度为16位。</p> 
<p>　　参见：li4-6.c/*输出单精度实数时的有效位数*/</p> 
<p>　　li4-7.c/*输出双精度实数时的有效位数*/</p> 
<p>　　li4-8.c/*输出实数时指定小数位数*/</p> 
<p>　　（8）e(或E)格式符，以指数形式输出实数。格式：%e，%m.ne，%-m.ne都可。</p> 
<p>　　(9)g(或G)格式符，用来输出实数，它根据数值的大小，自动选f格式或e格式（选择输出时占宽度较小的一种）。</p> 
<p>　　3.说明</p> 
<p>　　（1）除了X、E、G（用大写字母表示）外，其他格式字符必须用小写字母；</p> 
<p>　　（2）“格式控制”字符串内可以包含转义字符；</p> 
<p>　　（3）如果想输出字符“%”，则应该在“格式控制”字符串中用连续两个%表示，如：</p> 
<p>　　printf("%f%%",1.0/3);</p> 
<p>　　（4）格式字符表参见下表</p> 
<p>　　表4.1 printf格式字符</p> 
<p>　　格式字符 说明</p> 
<p>　　d,i 以带符号的十进制形式输出整数（正数不输出符号）</p> 
<p>　　o 以八进制无符号形式输出整数（不输出前导符0）</p> 
<p>　　x,X 以十六进制无符号形式输出整数（不输出前导符0x）,用x则输出十六进制数的a～f时以小写形式输出，用X时，则以大写字母输出</p> 
<p>　　u 以无符号十进制形式输出整数</p> 
<p>　　c 以字符形式输出，只输出一个字符</p> 
<p>　　s 输出字符串</p> 
<p>　　f 以小数形式输出单、双精度数，隐含输出6位小数</p> 
<p>　　e,E 以指数形式输出实数</p> 
<p>　　g,G 选用%f或%e格式中输出宽度较短的一种格式，不输出无意义的0</p> 
<p>　　表4.2 printf的附加格式说明字符</p> 
<p>　　字符</p> 
<p>　　说明</p> 
<p>　　字母l</p> 
<p>　　用于长整型整数，可加在格式符d、o、x、u前面</p> 
<p>　　m(代表一个正整数)</p> 
<p>　　数据最小宽度</p> 
<p>　　n(代表一个正整数)</p> 
<p>　　对实数，表示输出n位小数；对字符串，表示截取的字符个数</p> 
<p>　　-</p> 
<p>　　输出的数字或字符在域内向左靠 </p> 
<p>程序例:</p> 
<p>　　#include &lt;stdio.h&gt;</p> 
<p>　　int main()</p> 
<p>　　{<!-- --></p> 
<p>　　printf("Hello,world/n");</p> 
<p>　　while(1);</p> 
<p>　　}</p> 
<p>　　#include&lt;stdio.h&gt;</p> 
<p>　　int main()</p> 
<p>　　{<!-- --></p> 
<p>　　int i = 1, j=2;</p> 
<p>　　printf("%d%d/n",i,j);</p> 
<p>　　while(1);</p> 
<p>　　} </p> 
<p>printf 命令</p> 
<p>　　<strong>用途</strong></p> 
<p>　　写格式化输出。</p> 
<p>　　<strong>语法</strong></p> 
<p>　　printfFormat [ Argument ... ]</p> 
<p>　　<strong>描述</strong></p> 
<p>　　printf 命令转换、格式化并写 Argument 参数到标准输出。Argument 参数是由 Format 参数控制格式化的。格式化输出行不能超出 LINE_MAX 字节长度。</p> 
<p>　　下列环境变量影响printf 命令的执行：</p> 
<p>　　LANG 在 LC_ALL 和相应的环境变量（以 LC_ 开头）没有指定语言环境时，确定语言环境编目使用的语言环境。</p> 
<p>　　LC_ALL 确定用于覆盖由 LANG 或其它任何 LC_ 环境变量设置的任何语言环境编目值的语言环境。</p> 
<p>　　LC_CTYPE 确定把文本字节数据顺序解释为字符的语言环境；例如，单一字节对应多字节字符的参数。</p> 
<p>　　LC_MESSAGES 确定写消息使用的语言。</p> 
<p>　　LC_NUMERIC 确定数字格式编排的语言环境。此环境变量影响使用 e、E、f、g 和 G 转换字符编写的数字的格式。</p> 
<p>　　Format 参数是包含三种对象类型的一个字符串：</p> 
<p>　　* 无格式字符复制到输出流。</p> 
<p>　　* 转换规范，每个规范导致在值参数列表中检索 0 个或更多个项。</p> 
<p>　　* 以下转义序列。在复制到输出流时，这些序列导致它们的相关操作在有此功能的设备上显示：</p> 
<p>　　// 反斜杠</p> 
<p>　　/a 警告</p> 
<p>　　/b 退格</p> 
<p>　　/f 换页</p> 
<p>　　/n 换行</p> 
<p>　　/r 回车</p> 
<p>　　/t 跳格</p> 
<p>　　/v 垂直跳格</p> 
<p>　　/ddd ddd 是 1、2 或 3 位八进制数字。这些转义序列作为由八进制数指定的具有数字值的字节显示。</p> 
<p>　　Argument 参数是一个或多个字符串的列表，它在 Format 参数的控制下被写到标准输出。</p> 
<p>　　Format 参数在必要的情况下会经常重新使用以满足 Argument 参数。将好像提供了空字符串 Argument 一样评估任何额外的 c 或者 s 转换规范；其它额外转换规范将好像提供了 0 Argument 一样评估。此处 Format 参数不包含转换规范仅出现 Argument 参数，结果是不确定的。</p> 
<p>　　每个 Format 参数中的转换规范都具有如下顺序的语法：</p> 
<p>　　1. % （百分号）。</p> 
<p>　　2. 零或更多的选项，修改转换规范的含义。选项字符和它们的含义是：</p> 
<p>　　- 转换结果在字段中左对齐。</p> 
<p>　　+ 符号转换结果常以符号（+ 或者 -）开始。</p> 
<p>　　空格 如果符号转换的第一个字符不是符号，结果的前缀将是空格。如果空格和 + 选项字符都显示，则忽略空格选项字符。</p> 
<p>　　# 此选项指定值转换到备用格式。对于 c、d、i, u 和 s 转换，选项没有作用。对于 o 转换，它增加精度来强制结果的第一数字是 a、0（零）。对于 x 和 X 转换，非零结果分别具有 0x 或 0X 前缀。对于 e、E、 f、g 和 G 转换，结果通常包含基数字符，即使基数字符后没有数字。对于 g 和 G 转换，结尾零不象通常一样除去。</p> 
<p>　　0 对于 d、i、o、 u、x、e、 E、f、g 和 G 转换，前导零（跟在符号或底数的后面）用于填充字段宽度，将不用空格填充。如果显示 0（零）和 -（减号）选项，0（零）选项被忽略。对于 d、i、o、u、x 和 X 转换，如果指定精度，0（零）选项将被忽略。</p> 
<p>　　注:</p> 
<p>　　其它转换，没有定义其行为。</p> 
<p>　　3. 可选的指定最小值字段宽度的十进制数字字符串。如果转换值字符少于字段宽度，该字段将从左到右按指定的字段宽度填充。如果指定了左边调整选项，字段将在右边填充。如果转换结果宽于字段宽度，将扩展该字段以包含转换后的结果。不会发生截断。然而，小的精度可能导致在右边发生截断。</p> 
<p>　　4. 可选的精度。精度是一个 ．（点）后跟十进制数字字符串。如果没有给出精度，按 0（零）对待。精度指定：</p> 
<p>　　* d、o、i、 u、x 或 X 转换的最少数字显示位数。</p> 
<p>　　* e 和 f 转换的基数字符后的最少数字显示位数。</p> 
<p>　　* g 转换的最大有效数字位数。</p> 
<p>　　* s 转换中字符串的最大打印字节数目。</p> 
<p>　　5. 指示要应用的转换类型的一个字符，例如：</p> 
<p>　　% 不进行转换。打印一个 %（百分号）。</p> 
<p>　　d, i 接受整数值并将它转换为有符号的十进制符号表示法。精度指定显示的最小数字位数。如果值转换后可以用更少的位数来表示，将使用前导零扩展。缺省精度是 1。精度为零的零值转换的结果是空字符串。用零作为前导字符来指定字段宽度，导致用前导零填充字段宽度值。</p> 
<p>　　o 接受整数值并将它转换为有符号的八进制符号表示法。精度指定显示的最小数字位数。如果值转换后可以用更少的位数来表示，将使用前导零扩展。缺省精度是 1。精度为零的零值转换的结果是空字符串。用零作为前导字符来指定字段宽度，导致用前导零填充字段宽度值。不用八进制值表示字段宽度。</p> 
<p>　　u 接受整数值并将它转换为无符号的十进制符号表示法。精度指定显示的最小数字位数。如果值转换后可以用更少的位数来表示，将使用前导零扩展。缺省精度是 1。精度为零的零值转换的结果是空字符串。用零作为前导字符来指定字段宽度，导致用前导零填充字段宽度值。</p> 
<p>　　x, X 接受整数值并将它转换为十六进制符号表示法。字母 abcdef 用于 x 转换，字母 ABCDEF 用于 X 转换。精度指定显示的最小数字位数。如果值转换后可以用更少的位数来表示，将使用前导零扩展。缺省精度是 1。精度为零的零值转换的结果是空字符串。用零作为前导字符来指定字段宽度，导致用前导零填充字段宽度值。</p> 
<p>　　f 接受浮点或者双精度值并将它转换为十进制符号表示法，格式为 [-]ddd.ddd。基数字符（在这里显示为十进制点）后的数字位数等于规定的精度。LC_NUMERIC 语言环境编目确定在这个格式中使用的基数字符。如果不指定精度，则输出六个数字。如果精度是 0（零），将不显示基数字符。</p> 
<p>　　e, E 接受浮点或者双精度值并将它转换为指数表示的形式 [-]d.dde{+|-}dd。在基数字符前有一个数字（在这里显示为十进制点），基数字符后的数字位数等于规定的精度。 LC_NUMERIC 语言环境编目确定在这个格式中使用的基数字符。如果不指定精度，则输出六个数字。如果精度是 0（零），将不显示基数字符。E转换字符在指数前生成带 E 而不是带 e 的数字。指数通常至少包含两个数字。然而，如果要打印的指数值大于两个数字，必要时需要打印附加指数数字。</p> 
<p>　　g、G 接受浮点和双精度值并转换为 f 或 e 转换字符的样式（或在 G 转换的情况下是 E），用精度指定有效数字的个数。尾零将从结果中除去。基数字符只有在其后是数字时显示。使用的样式取决于转换的值。样式 g 仅在转换的指数结果小于 -4，或大于或等于精度时使用。</p> 
<p>　　c 接受值将其作为字符串并打印字符串中的第一个字符。</p> 
<p>　　s 接受值将其作为字符串并打印字符串中的字符直到字符串结束或者达到精度指示的字符个数。如果没有指定精度，打印全部字符直到出现第一个空字符。</p> 
<p>　　b 接受值将其作为字符串，可能包含反斜杠转义序列。打印来自转换字符串的字节直到字符串结束或者达到精度规范指示的字节数。如果没有指定精度，打印全部字节直到出现第一个空字符。</p> 
<p>　　支持下列反斜杠转义序列：</p> 
<p>　　* 先前列出的反斜杠转义序列在 Format 参数描述下。这些转义序列将被转换到它们表示的单个字符。</p> 
<p>　　* /c（反斜杠 c）序列，它不显示并使 printf 命令忽略 Format 参数中的字符串参数包含的剩余的所有字符串，所有剩余的字符串参数和所有附加字符。</p> 
<p>　　退出状态</p> 
<p>　　该命令返回以下出口值：</p> 
<p>　　0 成功完成。</p> 
<p>　　&gt;0 发生错误。</p> 
<p>　　<strong>示例</strong></p> 
<p>　　1. 输入下列命令：</p> 
<p>　　printf("%5d%4d/n",1213,43);</p> 
<p>　　产生下列输出：</p> 
<p>　　_1213_ _43</p> 
<p>　　三次使用 Format 参数打印所有给定字符串。0（零）由 printf 命令提供以满足最后的 %4d 转换规格。</p> 
<p>　　2. 输入下列命令</p> 
<p>　　printf("%c %c/n",78,79);</p> 
<p>　　产生下列输出：</p> 
<p>　　N_O</p> 
<p>　　<strong>文件</strong></p> 
<p>　　/usr/bin/printf包含 printf 命令。</p> 
<p> </p> 
<h3><a target="_blank" href="http://blog.csdn.net/npy_lp/article/details/6989676" rel="noopener noreferrer">例解GNU C之typeof </a><a target="_blank" name="_Toc376251339"></a></h3> 
<p>分类：<a target="_blank" href="http://blog.csdn.net/npy_lp/article/category/918585" rel="noopener noreferrer">漫谈C语言</a> 2011-11-24 15:01 1386人阅读 <a target="_blank" href="http://blog.csdn.net/npy_lp/article/details/6989676#comments" rel="noopener noreferrer"> 评论</a>(1) <a target="_blank" title="收藏">收藏</a><a target="_blank" href="http://blog.csdn.net/npy_lp/article/details/6989676#report" title="举报" rel="noopener noreferrer">举报</a></p> 
<p><a target="_blank" href="http://www.csdn.net/tag/c" rel="noopener noreferrer">c</a><a target="_blank" href="http://www.csdn.net/tag/linux%e5%86%85%e6%a0%b8" rel="noopener noreferrer">linux内核</a><a target="_blank" href="http://www.csdn.net/tag/%e7%bc%96%e8%af%91%e5%99%a8" rel="noopener noreferrer">编译器</a><a target="_blank" href="http://www.csdn.net/tag/%e6%96%87%e6%a1%a3" rel="noopener noreferrer">文档</a><a target="_blank" href="http://www.csdn.net/tag/gcc" rel="noopener noreferrer">gcc</a><a target="_blank" href="http://www.csdn.net/tag/%e8%af%ad%e8%a8%80" rel="noopener noreferrer">语言</a></p> 
<p>    前言：计算机语言是编译器和程序员交流的依据和规范，GNU C是GCC特有的功能，在Linux内核中被广泛应用。</p> 
<p>    帮助文档：<a target="_blank" href="http://gcc.gnu.org/onlinedocs/gcc-4.6.2/gcc/C-Extensions.html#C-Extensions" rel="nofollow noopener noreferrer">http://gcc.gnu.org/onlinedocs/gcc-4.6.2/gcc/C-Extensions.html#C-Extensions</a></p> 
<p> </p> 
<p>    关键字typeof用于获取表达式的数据类型。</p> 
<p>    简单例子，如清单1： </p> 
<p><strong>[cpp]</strong> <a target="_blank" href="http://blog.csdn.net/npy_lp/article/details/6989676" title="view plain" rel="noopener noreferrer"> viewplain</a><a target="_blank" href="http://blog.csdn.net/npy_lp/article/details/6989676" title="copy" rel="noopener noreferrer">copy</a></p> 
<p>char *chptr01;  </p> 
<p>  </p> 
<p>typeof (*chptr01) ch; //等价于char ch;  </p> 
<p>  </p> 
<p>typeof (ch) *chptr02; //等价于char *chptr02;   </p> 
<p>  </p> 
<p>typeof (chptr01) chparray[5]; //等价于char *chparray[5];  </p> 
<p>    例子中chptr01的数据类型为char *，*chptr01的数据类型为char。</p> 
<p>    复杂的例子，如清单2： </p> 
<p><strong>[cpp]</strong> <a target="_blank" href="http://blog.csdn.net/npy_lp/article/details/6989676" title="view plain" rel="noopener noreferrer"> viewplain</a><a target="_blank" href="http://blog.csdn.net/npy_lp/article/details/6989676" title="copy" rel="noopener noreferrer">copy</a></p> 
<p>#include &lt;stdio.h&gt;  </p> 
<p>  </p> 
<p>#define array(type, size) typeof(type [size])  </p> 
<p>  </p> 
<p>int func(int num)  </p> 
<p>{  </p> 
<p>    return num + 5;  </p> 
<p>}  </p> 
<p>  </p> 
<p>int main(void)  </p> 
<p>{  </p> 
<p>    typeof (func) *pfunc = func; //等价于int (*pfunc)(int) = func;  </p> 
<p>    printf("pfunc(10) = %d\n", (*pfunc)(10));  </p> 
<p>  </p> 
<p>    array(char, ) charray = "hello world!"; //等价于char charray[] = "hello world!";  </p> 
<p>    typeof (char *) charptr = charray; //等价于char *charptr = charray;  </p> 
<p>  </p> 
<p>    printf("%s\n", charptr);  </p> 
<p>  </p> 
<p>    return 0;  </p> 
<p>}  </p> 
<p>    例子输出结果： </p> 
<p><strong>[cpp]</strong> <a target="_blank" href="http://blog.csdn.net/npy_lp/article/details/6989676" title="view plain" rel="noopener noreferrer"> viewplain</a><a target="_blank" href="http://blog.csdn.net/npy_lp/article/details/6989676" title="copy" rel="noopener noreferrer">copy</a></p> 
<p>pfunc(10) = 15  </p> 
<p>hello world!  </p> 
<p>    如果typeof的操作数是一个数据类型，那么它的结果就是这个数据类型，如第16行。</p> 
<p>    在Linux内核中的应用，如清单3： </p> 
<p><strong>[cpp]</strong> <a target="_blank" href="http://blog.csdn.net/npy_lp/article/details/6989676" title="view plain" rel="noopener noreferrer"> viewplain</a><a target="_blank" href="http://blog.csdn.net/npy_lp/article/details/6989676" title="copy" rel="noopener noreferrer">copy</a></p> 
<p>/* linux-2.6.38.8/include/linux/kernel.h */  </p> 
<p>  </p> 
<p>#define min(x, y) ({                \  </p> 
<p>    typeof(x) _min1 = (x);          \  </p> 
<p>    typeof(y) _min2 = (y);          \  </p> 
<p>    (void) (&amp;_min1 == &amp;_min2);      \  </p> 
<p>    _min1 &lt; _min2 ? _min1 : _min2; })  </p> 
<p>  </p> 
<p>#define max(x, y) ({                \  </p> 
<p>    typeof(x) _max1 = (x);          \  </p> 
<p>    typeof(y) _max2 = (y);          \  </p> 
<p>    (void) (&amp;_max1 == &amp;_max2);      \  </p> 
<p>    _max1 &gt; _max2 ? _max1 : _max2; })  </p> 
<p>    通过typeof获得x和y的数据类型，然后定义两个临时变量，并把x和y的值分别赋给这两个临时变量，最后进行比较。</p> 
<p>    另外，宏定义中(void)(&amp;_min1 ==&amp;_min2)语句的作用是用来警告x和y不能属于不同的数据类型</p> 
<h3><a target="_blank" name="_Toc376251340">预编译语句中#</a>与##的作用 </h3> 
<p>2012-12-08 10:44 <a target="_blank" href="http://www.baidu.com/p/yangsong12156?from=zhidao" rel="nofollow noopener noreferrer"> yangsong12156</a> | 分类：<a target="_blank" href="http://zhidao.baidu.com/browse/93" rel="nofollow noopener noreferrer">其他编程语言</a> | 浏览3745次 </p> 
<p>分享到： </p> 
<p>2012-12-08 11:16 网友采纳 </p> 
<pre># 和 ## 操作符是和#define宏使用的. 使用# 使在#后的首个参数返回为一个带引号的字符串. 例如, 命令 
    #define to_string( s ) # s
将会使编译器把以下命令 
    cout &lt;&lt; to_string( Hello World! ) &lt;&lt; endl;
理解为 
    cout &lt;&lt; "Hello World!" &lt;&lt; endl;
使用##连结##前后的内容. 例如, 命令 
    #define concatenate( x, y ) x ## y
...
int xy = 10;
...
将会使编译器把 
    cout &lt;&lt; concatenate( x, y ) &lt;&lt; endl;
解释为 
    cout &lt;&lt; xy &lt;&lt; endl;
理所当然,将会在标准输出处显示'10'.</pre> 
<p> </p> 
<p> </p> 
<p> </p> 
<h2><a target="_blank" href="http://blog.csdn.net/wealoong/article/details/7566546" rel="noopener noreferrer"><span style="color:#333333">request_irq() | </span><span style="color:#333333">注册中断服务</span></a></h2> 
<p align="right"><span style="color:#999999">分类：</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/wealoong/article/category/1146762" rel="noopener noreferrer"><span style="color:#FF9900">irq</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/wealoong/article/category/1179556" rel="noopener noreferrer"><span style="color:#FF9900">内核</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/wealoong/article/category/1245452" rel="noopener noreferrer"><span style="color:#FF9900">linux</span></a></span><span style="color:#999999">2012-05-1422:16</span><span style="color:#999999"> </span><span style="color:#999999">3310</span><span style="color:#999999">人阅读</span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/wealoong/article/details/7566546#comments" rel="noopener noreferrer"><span style="color:#FF9900">评论</span></a></span>(2)<span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" title="收藏"><span style="color:#FF9900">收藏</span></a></span><span style="color:#999999"> </span><span style="color:#999999"><a target="_blank" href="http://blog.csdn.net/wealoong/article/details/7566546#report" title="举报" rel="noopener noreferrer"><span style="color:#FF9900">举报</span></a></span></p> 
<p align="left"><a target="_blank" href="http://www.csdn.net/tag/random" rel="noopener noreferrer"><span style="color:#FF9900; background:#EEEEEE">random</span></a><a target="_blank" href="http://www.csdn.net/tag/struct" rel="noopener noreferrer"><span style="color:#FF9900; background:#EEEEEE">struct</span></a><a target="_blank" href="http://www.csdn.net/tag/linux%e5%86%85%e6%a0%b8" rel="noopener noreferrer"><span style="color:#FF9900; background:#EEEEEE">linux</span><span style="color:#FF9900; background:#EEEEEE">内核</span></a><a target="_blank" href="http://www.csdn.net/tag/timer" rel="noopener noreferrer"><span style="color:#FF9900; background:#EEEEEE">timer</span></a><a target="_blank" href="http://www.csdn.net/tag/action" rel="noopener noreferrer"><span style="color:#FF9900; background:#EEEEEE">action</span></a><a target="_blank" href="http://www.csdn.net/tag/linux" rel="noopener noreferrer"><span style="color:#FF9900; background:#EEEEEE">linux</span></a></p> 
<p align="right" style="background:#EEEEEE">目录<a target="_blank" href="http://blog.csdn.net/wealoong/article/details/7566546" title="系统根据文章中H1到H6标签自动生成文章目录" rel="noopener noreferrer"><span style="color:#FF9900">(?)</span></a><a target="_blank" href="http://blog.csdn.net/wealoong/article/details/7566546" title="展开" rel="noopener noreferrer"><span style="color:#FF9900">[+]</span></a></p> 
<table border="0" cellpadding="0" width="763"><tbody><tr><td> <h2>参考  ： ARM Linux 中断机制分析.pdf</h2> <h2><a target="_blank" href="http://blog.csdn.net/hongtao_liu/article/details/4263176" rel="noopener noreferrer"><span style="color:#FF9900">linux-2.6.26</span><span style="color:#FF9900">内核中</span><span style="color:#FF9900">ARM</span><span style="color:#FF9900">中断实现详解（</span><span style="color:#FF9900">1</span><span style="color:#FF9900">）</span></a></h2> <p>一、中断注册方法<strong></strong></p> <p>在linux内核中用于申请中断的函数是request_irq（），函数原型在Kernel/irq/manage.c中定义：<strong></strong></p> <p>int request_irq(unsigned int irq, irq_handler_t handler,<br>                          unsigned long irqflags, const char *devname, void *dev_id)<strong></strong></p> <p><strong>irq是要申请的硬件中断号</strong>。<strong></strong></p> <p><strong>handler是向系统注册的中断处理函数</strong>，是一个回调函数，中断发生时，系统调用这个函数，dev_id参数将被传递给它。<strong></strong></p> <p><strong>irqflags是中断处理的属性，</strong>若设置了IRQF_DISABLED （老版本中的SA_INTERRUPT，本版zhon已经不支持了），则表示中断处理程序是快速处理程序，快速处理程序被调用时屏蔽所有中断，慢速处理程序不屏蔽；若设置了IRQF_SHARED （老版本中的SA_SHIRQ），则表示多个设备共享中断，若设置了IRQF_SAMPLE_RANDOM（老版本中的SA_SAMPLE_RANDOM），表示对系统熵有贡献，对系统获取随机数有好处。（这几个flag是可以通过或的方式同时使用的）<strong></strong></p> <h2>devname设置中断名称，通常是<u>设备驱动程序的名称  </u>在cat /proc/interrupts中可以看到此名称。</h2> <p><strong>dev_id在中断共享时会用到，一般设置为这个设备的<span style="color:#CC33CC">设备结构体</span></strong>或者NULL。<strong></strong></p> <p>request_irq()返回0表示成功，返回-INVAL表示中断号无效或处理函数指针为NULL，返回-EBUSY表示中断已经被占用且不能共享。<strong></strong></p> <p>==================================================================================================================================<strong></strong></p> <h2>request_irq() | 注册中断服务</h2> <p>在 2.4 内核和 2.6内核中都使用 <strong>request_irq()</strong> 函数来注册中断服务函数。在 2.4 内核中，需要包含的头文件是 #include &lt;linux/sched.h&gt; ，2.6 内核中需要包含的头文件则是<br> #include &lt;linux/interrupt.h&gt; 。函数原型如下：</p> <p align="left">·         2.4 内核</p> <p><strong><span style="color:#CC0000">int</span></strong><span style="color:#CC0000"> </span><span style="color:#CC0000">request_irq</span> (<strong><span style="color:#00BB00">unsignedint</span></strong>irq,<strong><span style="color:#00BB00">void</span></strong> (<span style="color:#666666">*</span>handler)(<strong><span style="color:#00BB00">int</span></strong>,<strong><span style="color:#00BB00">void</span></strong><span style="color:#666666">*</span>,<strong><span style="color:#AA22FF">struct</span></strong>pt_regs<span style="color:#666666">*</span>),<strong><span style="color:#00BB00">unsignedlong</span></strong>frags,<strong><span style="color:#AA22FF">const</span><span style="color:#00BB00">char</span></strong><span style="color:#666666">*</span>device,<strong><span style="color:#00BB00">void</span></strong><span style="color:#666666">*</span>dev_id);</p> <p align="left">·         2.6 内核</p> <p><span style="color:red">request_irq</span>(<strong><span style="color:#00BB00">unsignedint</span></strong>irq,irq_handler_thandler,<strong><span style="color:#00BB00">unsignedlong</span></strong>flags,<strong><span style="color:#AA22FF">const</span><span style="color:#00BB00">char</span></strong><span style="color:#666666">*</span>name,<strong><span style="color:#00BB00">void</span></strong><span style="color:#666666">*</span>dev);<br> <br> <strong>参数说明</strong>：<br> <br> 在发生对应于第 1个参数 <strong><span style="color:#FF00CC">irq</span></strong> 的中断时，则调用第 2 个参数<strong><span style="color:#FF00CC">handler</span></strong> 为要注册的中断服务函数(也就是把 handler() 中断服务函数注册到内核中 )。<br> <br> 第 3 个参数 <strong><span style="color:#FF00CC">flags</span></strong> 指定了<u>快速中断或中断共享等中断处理属性</u>。在 2.6 教新的内核里(我的是 2.6.27 ~ 2.6.31 )，在 linux/interrupt.h 中定义操作这个参数的宏如下：</p> <p>引用</p> <p><em><span style="color:#008800">/*</span><br> <em><span style="color:#008800"> * These correspond to the IORESOURCE_IRQ_* defines in</span><br> <span style="color:#008800"> * linux/ioport.h to select the interrupt line behaviour.  When</span><br> <span style="color:#008800"> * requesting an interrupt without specifying a IRQF_TRIGGER, the</span><br> <span style="color:#008800"> * setting should be assumed to be "as already configured", which</span><br> <span style="color:#008800"> * may be as per machine or firmware initialisation.</span></em><br> <span style="color:#008800"><br> </span><em><span style="color:#3333FF">#define IRQF_TRIGGER_NONE0x00000000</span></em><span style="color:#3333FF"><br> <em>#define IRQF_TRIGGER_RISING 0x00000001<br> #define IRQF_TRIGGER_FALLING 0x00000002   <br> #define IRQF_TRIGGER_HIGH 0x00000004                  </em></span><span style="color:#008800">指定中断触发类型：高电平有效。新增加的标志</span><span style="color:#008800"> </span><span style="color:#3333FF"><br> <em>#define IRQF_TRIGGER_LOW 0x00000008<br> #define IRQF_TRIGGER_MASK (IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW | \<br> IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)<br> #define IRQF_TRIGGER_PROBE 0x00000010</em></span></em></p> <p><em><span style="color:#008800">/*</span><br> <em><span style="color:#008800">* These flags used only by the kernel as part of the</span> <span style="color:#008800"> irq handling routines.</span><br> <span style="color:#008800">*                registered first in an shared interrupt is considered for</span><br> <span style="color:#008800">*                performance reasons)</span><br> <span style="color:#008800">*/</span></em><span style="color:#008800"><br> </span></em><span style="color:blue">#define IRQF_DISABLED           0x00000020        </span><em><span style="color:#008800">* IRQF_DISABLED - keep irqs disabled when calling the action handler</span></em><br> <span style="color:blue">#define IRQF_SAMPLE_RANDOM      0x00000040</span><em><span style="color:#008800">* IRQF_SAMPLE_RANDOM - irq is used to feed the random generator</span></em><br> <span style="color:blue">#define IRQF_SHARED             0x00000080</span><em><span style="color:#008800">* IRQF_SHARED - allow sharing the irq among several devices</span></em></p> <p><span style="color:blue">#define IRQF_PROBE_SHARED       0x00000100</span><em><span style="color:#008800">* IRQF_PROBE_SHARED - set by callers when they expect sharing mismatches to occur</span><span style="color:#008800"><br> </span></em><span style="color:blue">#define IRQF_TIMER              0x00000200</span><em><span style="color:#008800">* IRQF_TIMER - Flag to mark this interrupt as timer interrupt</span></em></p> <p><span style="color:blue">#define IRQF_PERCPU             0x00000400</span><em><span style="color:#008800">* IRQF_PERCPU - Interrupt is per cpu</span><br> </em><span style="color:blue">#define IRQF_NOBALANCING        0x00000800</span><em><span style="color:#008800">* IRQF_NOBALANCING - Flag to exclude this interrupt from irq balancing</span><br> </em><span style="color:blue">#define IRQF_IRQPOLL            0x00001000</span><em><span style="color:#008800">* IRQF_IRQPOLL - Interrupt is used for polling (only the interrupt that is</span></em><br> 早期一点的 2.6 内核这里一般以 SA_ 前缀开头，如：</p> <p><span style="color:blue">SA_INTERRUPT</span>   表示禁止其他中断；(对应于 IRQF_DISABLED )<br> <span style="color:blue">SA_SHIRQ</span>             表示共享相同的中断号 (对应于 IRQF_SHARED )<br> <span style="color:blue">SA_SAMPLE_RANDOM</span>   此宏会影响到 RANDOM 的处理( 对应于 IRQF_SAMPLE_RANDOM )。<br> <br> 第 4 个参数 <span style="color:#FF00CC">name</span><span style="color:#FF00CC">，</span>通常是<u>设备驱动程序的名称</u>。改值用在 /proc/interrupt 系统 (虚拟) 文件上，或内核发生中断错误时使用。<br> <br> 第 5 个参数 <strong><span style="color:#FF00CC">dev_id </span><span style="color:#FF00CC">中断名称</span></strong> 可作为共享中断时的中断区别参数，也可以用来指定中断服务函数需要参考的数据地址。建议将<span style="color:#CC33CC">设备结构指针</span>作为<span style="color:#CC33CC">dev_id</span><span style="color:#CC33CC">参数</span></p> <p>int request_irq(unsigned int irq, irq_handler_t handler,<br>         <em><strong>IRQF_SHARED</strong></em>, const char *devname, void *dev_id)</p> <p>很多权威资料中都提到，中断共享注册时的注册函数中的dev_id参数是必不可少的，并且dev_id的值必须唯一。那么这里提供唯一的dev_id值的究竟是做什么用的？</p> <p>根据我们前面中断模型的知识，可以看出发生中断时，内核并不判断究竟是共享中断线上的哪个设备产生了中断，它会循环执行所有该中断线上注册的中断处理函数（即irqaction-&gt;handler函数）。因此irqaction-&gt;handler函数有责任识别出是否是自己的硬件设备产生了中断，然后再执行该中断处理函数。通常是通过读取该硬件设备提供的中断flag标志位进行判断。那既然kernel循环执行该中断线上注册的所有irqaction-&gt;handler函数，把识别究竟是哪个硬件设备产生了中断这件事交给中断处理函数本身去做，那request_irq的dev_id参数究竟是做什么用的？</p> <p>很多资料中都建议将<span style="color:#CC33CC">设备结构指针</span>作为<span style="color:#CC33CC">dev_id</span><span style="color:#CC33CC">参数</span>。在中断到来时，迅速地根据硬件寄存器中的信息比照传入的dev_id参数判断是否是本设备的中断，若不是，应迅速返回。这样的说法没有问题，也是我们编程时都遵循的方法。但事实上并不能够说明为什么中断共享必须要设置dev_id。</p> <p>下面解释一下dev_id参数为什么必须的，而且是必须唯一的。</p> <p>当调用free_irq注销中断处理函数时（通常卸载驱动时其中断处理函数也会被注销掉），因为dev_id是唯一的，所以可以通过它来判断从共享中断线上的多个中断处理程序中删除指定的一个。如果没有这个参数，那么kernel不可能知道给定的中断线上到底要删除哪一个处理程序。</p> <p> </p> <p>注销函数定义在Kernel/irq/manage.c中定义： <br>    <span style="color:#CC0000"> </span><span style="color:#CC0000">void free_irq</span>(unsigned int irq, void *dev_id)</p> <p><br> <strong>返回值</strong>：<br> 函数运行正常时返回 0 ，否则返回对应错误的负值。<br> <br> <strong>示例代码片段</strong>：</p> <p>引用</p> <p>irqreturn_t <span style="color:#00A000">xxx_interrupt</span> (<strong><span style="color:#00BB00">int</span></strong>irq,<strong><span style="color:#00BB00">void</span></strong><span style="color:#666666">*</span>dev_id)<br> {<!-- --><br>         ...<br> <br>         <strong><span style="color:#AA22FF">return</span></strong> (IRQ_HANDLED);<br> }<br> <br> <strong><span style="color:#00BB00">int</span></strong> <span style="color:#00A000">xxx_open</span> (<strong><span style="color:#AA22FF">struct</span></strong> inode <span style="color:#666666">*</span>inode,<strong><span style="color:#AA22FF">struct</span></strong>file<span style="color:#666666">*</span>filp)<br> {<!-- --><br>         <strong><span style="color:#AA22FF">if</span></strong> (<span style="color:#666666">!</span>request_irq (XXX_IRQ,xxx_interruppt,IRQF_DISABLED,<span style="color:#BB4444">"xxx"</span>,<span style="color:#AA22FF">NULL</span>)){<!-- --><br> <br>                 <em><span style="color:#008800">/*</span><span style="color:#008800">正常注册*/</span></em><br>         }<br> <br>         <strong><span style="color:#AA22FF">return</span></strong> (<span style="color:#666666">0</span>);<br> }</p> <p>============================================================================</p> <p align="center">内核中的中断处理模型</p> <p>内核版本： Linux 2.6.19</p> <p>Kernel中断处理模型结构图如下：</p> <p><a target="_blank" href="http://photo.blog.sina.com.cn/showpic.html#blogid=4ce2cdfa0100a5cs&amp;url=http://static10.photo.sina.com.cn/orignal/4ce2cdfa4527dc569ebc9" rel="nofollow noopener noreferrer"></a></p> <p>下面简单介绍一下：</p> <p>1． Linux定义了名字为irq_desc的中断例程描述符表：(include/linux/irq.h)</p> <p>struct irqdesc irq_desc[NR_IRQS];</p> <p>NR_IRQS表示中断源的数目。</p> <p>2． irq_desc［］是一个指向irq_desc结构的数组， irq_desc结构是各个设备中断服务例程的描述符。</p> 
    <table border="1" cellspacing="0" cellpadding="0" width="95%" style="background:#F1F1F1"><tbody><tr><td> <p><code><span style="color:blue">struct</span></code> <code>irq_desc {<!-- --></code><br> <code>irq_flow_handler_t</code> <code>handle_irq;</code><br> <code><span style="color:blue">struct</span></code> <code>irq_chip</code> <code>*chip;</code><br> <code><span style="color:blue">void</span></code> <code>*handler_data;</code><br> <code><span style="color:blue">void</span></code> <code>*chip_data;</code><br> <code><span style="color:#CC0000">struct irqaction</span></code><span style="color:#CC0000"> </span><code><span style="color:#CC0000">*action;</span></code><br> <code><span style="color:blue">unsigned int</span></code> <code>status;</code></p> <p><span style="color:blue">unsigned int</span>depth;<br> <span style="color:blue">unsigned int</span> wake_depth;<br> <span style="color:blue">unsigned int</span> irq_count;<br> <span style="color:blue">unsigned int</span> irqs_unhandled;<br> spinlock_t lock;<br> <span style="color:blue">#ifdef</span> CONFIG_SMP<br> cpumask_t affinity;<br> <span style="color:blue">unsigned int</span> cpu;<br> <span style="color:blue">#endif</span><br> <span style="color:blue">#if</span> defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)<br> cpumask_t pending_mask;<br> <span style="color:blue">#endif</span><br> <span style="color:blue">#ifdef</span> CONFIG_PROC_FS<br> <span style="color:blue">struct</span> proc_dir_entry*dir;<br> <span style="color:blue">#endif</span><br> <span style="color:blue">const char</span> *name;<br> } ____cacheline_aligned;<br> <br> </p> </td></tr></tbody></table> <p>Irq_desc结构体中的成员action指向该中断号对应的irqaction结构体链表。Irqaction结构体定义如下：</p> 
    <table border="1" cellspacing="0" cellpadding="0" width="95%" style="background:#F1F1F1"><tbody><tr><td> <p><code><span style="color:#9900FF">// include/linux/interrupt.h</span></code><span style="color:#CC00FF"><br> </span><code><span style="color:blue">struct</span></code> <code>irqaction</code><code><span style="color:#0000CC">{<!-- --></span></code><br> <code>irq_handler_t handler</code><code><span style="color:#0000CC">;</span></code> <code><span style="color:#9900FF">// </span></code><code><span style="color:#9900FF">指向中断服务程序</span></code><span style="color:#9900FF"> </span><br> <code><span style="color:blue">unsigned</span></code> <code><span style="color:blue">long</span></code> <code>flags</code><code><span style="color:#0000CC">;</span></code> <code><span style="color:#9900FF">// </span></code><code><span style="color:#9900FF">中断标志</span></code><br> <code><span style="color:blue">unsigned</span></code> <code><span style="color:blue">long</span></code> <code>mask</code><code><span style="color:#0000CC">;</span></code> <code><span style="color:#9900FF">// </span></code><code><span style="color:#9900FF">中断掩码</span></code><br> <code><span style="color:blue">const</span></code> <code><span style="color:blue">char</span></code> <code><span style="color:#0000CC">*</span></code><code>name</code><code><span style="color:#0000CC">;</span></code><code><span style="color:#9900FF">// I/O</span></code><code><span style="color:#9900FF">设备名</span></code></p> <p><code><span style="color:blue">void *</span></code><code>dev_id;</code><code><span style="color:#9900FF">// </span></code><code><span style="color:#9900FF">设备标识</span></code><br> <code><span style="color:blue">struct</span></code> <code>irqaction</code><code><span style="color:#0000CC">*</span></code><code>next</code><code><span style="color:#0000CC">;</span></code><code><span style="color:#9900FF">// </span></code><code><span style="color:#9900FF">指向下一个描述符</span></code></p> <p><code><span style="color:blue">int</span></code> <code>irq</code><code><span style="color:#0000CC">;</span></code><code><span style="color:#9900FF">// IRQ</span></code><code><span style="color:#9900FF">线</span></code><br> <code><span style="color:blue">struct</span></code> <code>proc_dir_entry</code> <code><span style="color:#0000CC">*</span></code><code>dir</code><code><span style="color:#0000CC">;</span></code><span style="color:#0000CC"> </span><code><span style="color:#9900FF">// </span></code><code><span style="color:#9900FF">指向IRQn</span>相关的/proc/irq/n目录的描述符</code><br> <code><span style="color:#0000CC">};</span></code></p> </td></tr></tbody></table> <p>其中关键的handler成员指向了该设备的中断服务程序，<strong>由执行request_irq时建立。</strong></p> <p>3． 在驱动程序初始化时，若使用到中断，通常调用函数request_irq（）建立该驱动程序对应的irqaction结构体，并把它登记到irq_desc [irq_num]-&gt;action链表中。Iqr_num为驱动程序申请的中断号。</p> <p>request_irq（）函数的原型如下：</p> 
    <table border="1" cellspacing="0" cellpadding="0" width="95%" style="background:#F1F1F1"><tbody><tr><td> <p><span style="color:#9900FF">// kernel/irq/manage.c</span><br> <code><span style="color:blue">int</span></code> <code>request_irq</code><code><span style="color:#0000CC">(</span></code><code><span style="color:blue">unsignedint</span></code> <code>irq</code><code><span style="color:#0000CC">,</span></code><br> <code>irqreturn_t</code> <code><span style="color:#0000CC">(*</span></code><code>handler</code><code><span style="color:#0000CC">)(</span></code><code><span style="color:blue">int</span></code><code><span style="color:#0000CC">,</span></code><code><span style="color:blue">void</span></code><code><span style="color:#0000CC">*,</span></code><code><span style="color:blue">struct</span></code> <code>pt_regs</code><code><span style="color:#0000CC">*),</span></code><br> <code><span style="color:blue">unsignedlong</span></code> <code>irqflags</code><code><span style="color:#0000CC">,</span></code><br> <code><span style="color:blue">const</span></code> <code><span style="color:blue">char</span></code> <code><span style="color:#0000CC">*</span></code><code>devname</code><code><span style="color:#0000CC">,</span></code><br> <code><span style="color:blue">void</span></code> <code><span style="color:#0000CC">*</span></code><code>dev_id</code><code><span style="color:#0000CC">);</span></code></p> </td></tr></tbody></table> <p><strong><span style="color:#996600">参数irq</span>是设备中断求号，在向irq_desc []数组登记时，它做为数组的下标。把中断号为irq的irqaction结构体的首地址写入irq_desc [irq]-&gt;action。这样就把设备的中断请求号与该设备的中断服务例程irqaction联系在一起了。</strong></p> <p><strong><span style="color:#996600">这样当CPU</span>接收到中断请求后，就可以根据中断号通过irq_desc []找到该设备的中断服务程序。</strong>流程如上图所示。</p> <p>4． 关于共享中断</p> <p>共享中断的不同设备的iqraction结构体都会添加进该中断号对应的irq_desc结构体的action成员所指向的irqaction链表内。当内核发生中断时，它会依次调用该链表内所有的handler函数。因此，若驱动程序需要使用共享中断机制，其中断处理函数必须有能力识别是否是自己的硬件产生了中断。通常是通过读取该硬件设备提供的中断flag标志位进行判断。</p> </td></tr></tbody></table> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae9a9d0dada21f68112ebfc8a67a2bab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">完全卸载oracle11g步骤</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/20476582af6df152c2bf7cbb1159ecaa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">取整，向上取整，向下取整</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>