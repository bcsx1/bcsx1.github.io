<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>系统架构设计师教程（九）软件可靠性基础知识 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="系统架构设计师教程（九）软件可靠性基础知识" />
<meta property="og:description" content="软件可靠性基础知识 9.1 软件可靠性基本概念9.1.1 软件可靠性定义9.1.2 软件可靠性的定量描述9.1.3 可靠性目标9.1.4 可靠性测试的意义9.1.5 广义的可靠性测试与狭义的可靠性测试 9.2 软件可靠性建模9.2.1 影响软件可靠性的因素9.2.2 软件可靠性的建模方法9.2.3 软件的可靠性模型分类 9.3 软件可靠性管理9.4 软件可靠性设计9.4.1 容错设计技术9.4.2 检错技术9.4.3 降低复杂度设计9.4.4 系统配置技术 9.5 软件可靠性测试9.5.1 软件可靠性测试概述9.5.2 定义软件运行剖面9.5.3 可靠性测试用例设计9.5.4 可靠性测试的实施 9.6 软件可靠性评价9.6.1 软件可靠性评价概述9.6.2 怎样选择可靠性模型9.6.3 可靠性数据的收集9.6.4软件可靠性的评估和预测 9.1 软件可靠性基本概念 随着软件在现代军事和商用系统中的广泛应用，软件可靠性成为越来越重要的研究领域。国外从20世纪60年代后期开始加强对软件可靠性的研究工作，形成了较为系统的软件可靠性工程体系，同时各主要工业强国也确立了专门的研究计划和课题。而国内对于软件可靠性的研究起步较晚，与国外在软件可靠性量化理论、度量标准、建模技术、设计方法和测试技术等方面存在较大差距。因此，需要加强国内对软件可靠性的研究和发展，提高软件系统的可靠性和安全性。
9.1.1 软件可靠性定义 软件可靠性是指在规定的时间周期内，在特定条件下，软件能够完成其规定功能的能力。与硬件相比，软件具有复杂性、物理退化、唯一性和版本更新快的特点。
软件可靠性的定义是在规定的时间内，软件不引起系统失效的概率，与系统输入和已知缺陷相关。软件可靠性的框架性定义包括规定的时间、规定的条件和所要求的功能。
这一定义使用内在的缺陷和外在的失效关系描述软件可靠性，并通过概率方法进行量化评估，使人们能够建立数学模型分析软件可靠性。
9.1.2 软件可靠性的定量描述 软件可靠性可以通过数学表达式来描述，其中涉及到一些概念和变量。下面是对软件可靠性的定量描述和相关概念的总结：
规定时间：包括自然时间（日历时间）、运行时间（从启动到结束的时间段）和执行时间（CPU执行指令的时间总和）。以执行时间作为度量软件可靠性最准确的方式。
失效概率：表示软件在某一时刻t之前出现失效的概率，用F(t)表示。具有初始化失效概率为0、随时间递增且趋向于1的特征。
可靠度：可靠度是表示软件在规定条件下、规定时间内不发生失效的概率，用R(t)表示。可通过可靠度的公式R(t)=1-F(t)来计算。
失效强度：失效强度是单位时间内软件系统出现失效的概率。用f(t)表示失效强度函数。
平均失效前时间（MTTF）：指系统从开始运行到发生故障之间的平均时间。可以通过积分计算得到。
平均恢复前时间（MTTR）：指从发生故障到修复成功所需的平均时间。
平均故障间隔时间（MTBF）：指失效或维护所需的平均时间，包括故障时间和维护设备的时间。
需要注意的是，在描述软件可靠性时需要明确软件对象、定义失效情况、假设硬件无故障、考虑运行环境等因素。同时，可靠性可以以概率或可能性加以度量，并且可靠性既可以在时间域上动态度量，也可以在数据域上表态度量。
另外，运行剖面用于定义系统使用条件，即测试环境和测试数据等问题。
9.1.3 可靠性目标 在定量分析软件可靠性时，除了考虑失效发生的概率外，还需要关注失效对软件运行的严重程度。为了描述软件失效的严重程度，引入了失效严重程度类的概念，用于定义具有相同影响程度的失效集合。失效严重程度类的划分可以基于成本影响和系统能力影响等标准，并常用数量级来进行等级划分。考虑到客户对软件性能的期望，可靠性目标可以用可靠度、故障强度和平均失效时间等指标来描述，需根据项目需求平衡可靠性、交付时间和成本。因此，建立定量的可靠性指标需要确定系统的运行模式、定义故障的严重性等级和确定故障强度目标。
9.1.4 可靠性测试的意义 软件可靠性问题日益受到软件工程专家的关注，研究人员开始投入大量资源研究软件可靠性的设计、评估和测试等方面。软件可靠性问题对软件工程实践、生产活动和社会活动产生深远影响，以下几个方面可以说明这一点：
软件失效可能造成灾难性后果：软件失效可能导致严重的后果，例如控制系统程序中的一个错误导致宇宙飞行失败。随着计算机和软件在各行各业的广泛应用，如军事系统、民航指挥系统、银行支付系统和交通调控系统等，严重的软件失效可能导致经济损失甚至危及人们的生命安全和国家安全。
软件失效在计算机系统失效中的比例较高：研究表明，在计算机系统失效中，约有80%与软件有关。这是因为软件系统的复杂性很高，即使是相对简单的程序，其路径数也可能非常庞大。因此，在软件开发过程中很难通过全路径覆盖测试来发现所有潜在的缺陷，也难以完全消除软件缺陷。
软件可靠性技术不成熟：与硬件可靠性技术相比，软件可靠性技术仍然相对不成熟。例如，在硬件可靠性领域，故障树分析 (FTA)、失效模式与效应分析 (FMEA) 等技术已经比较成熟，并且容错技术得到广泛应用。然而，在软件可靠性领域，这些技术似乎还没有定型。
软件费用不断增加：与硬件元器件成本不断下降形成鲜明对比的是，软件费用呈现增长趋势。软件可靠性问题是导致软件费用增加的主要原因之一。
对软件的依赖性增加：随着计算机技术在各个领域的广泛应用，系统对软件的依赖性越来越强。随着软件在生产活动和社会生活中的影响日益增大，软件可靠性问题在软件工程和整个计算机工程领域的重要性也越来越突出。
因此，软件可靠性问题的重要性凸显了发展以发现软件可靠性缺陷为目的的可靠性设计与测试技术的迫切性。
9.1.5 广义的可靠性测试与狭义的可靠性测试 广义的软件可靠性测试是指为了最终评价软件系统的可靠性而运用建模、统计、试验、分析和评价等一系列手段对软件系统实施的一种测试。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/a1633f4ca8a98f10a76d41a39dd16247/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-21T23:20:20+08:00" />
<meta property="article:modified_time" content="2023-12-21T23:20:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">系统架构设计师教程（九）软件可靠性基础知识</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>软件可靠性基础知识</h4> 
 <ul><li><a href="#91__1" rel="nofollow">9.1 软件可靠性基本概念</a></li><li><ul><li><a href="#911__5" rel="nofollow">9.1.1 软件可靠性定义</a></li><li><a href="#912__12" rel="nofollow">9.1.2 软件可靠性的定量描述</a></li><li><a href="#913__33" rel="nofollow">9.1.3 可靠性目标</a></li><li><a href="#914__35" rel="nofollow">9.1.4 可靠性测试的意义</a></li><li><a href="#915__49" rel="nofollow">9.1.5 广义的可靠性测试与狭义的可靠性测试</a></li></ul> 
  </li><li><a href="#92__53" rel="nofollow">9.2 软件可靠性建模</a></li><li><ul><li><a href="#921__54" rel="nofollow">9.2.1 影响软件可靠性的因素</a></li><li><a href="#922__63" rel="nofollow">9.2.2 软件可靠性的建模方法</a></li><li><a href="#923__66" rel="nofollow">9.2.3 软件的可靠性模型分类</a></li></ul> 
  </li><li><a href="#93__82" rel="nofollow">9.3 软件可靠性管理</a></li><li><a href="#94__135" rel="nofollow">9.4 软件可靠性设计</a></li><li><ul><li><a href="#941__144" rel="nofollow">9.4.1 容错设计技术</a></li><li><a href="#942__153" rel="nofollow">9.4.2 检错技术</a></li><li><a href="#943__165" rel="nofollow">9.4.3 降低复杂度设计</a></li><li><a href="#944__172" rel="nofollow">9.4.4 系统配置技术</a></li></ul> 
  </li><li><a href="#95__180" rel="nofollow">9.5 软件可靠性测试</a></li><li><ul><li><a href="#951__181" rel="nofollow">9.5.1 软件可靠性测试概述</a></li><li><a href="#952__187" rel="nofollow">9.5.2 定义软件运行剖面</a></li><li><a href="#953__194" rel="nofollow">9.5.3 可靠性测试用例设计</a></li><li><a href="#954__200" rel="nofollow">9.5.4 可靠性测试的实施</a></li></ul> 
  </li><li><a href="#96__208" rel="nofollow">9.6 软件可靠性评价</a></li><li><ul><li><a href="#961__209" rel="nofollow">9.6.1 软件可靠性评价概述</a></li><li><a href="#962__216" rel="nofollow">9.6.2 怎样选择可靠性模型</a></li><li><a href="#963__225" rel="nofollow">9.6.3 可靠性数据的收集</a></li><li><a href="#964_227" rel="nofollow">9.6.4软件可靠性的评估和预测</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="91__1"></a>9.1 软件可靠性基本概念</h2> 
<p>随着软件在现代军事和商用系统中的广泛应用，软件可靠性成为越来越重要的研究领域。国外从20世纪60年代后期开始加强对软件可靠性的研究工作，形成了较为系统的软件可靠性工程体系，同时各主要工业强国也确立了专门的研究计划和课题。而国内对于软件可靠性的研究起步较晚，与国外在软件可靠性量化理论、度量标准、建模技术、设计方法和测试技术等方面存在较大差距。因此，需要加强国内对软件可靠性的研究和发展，提高软件系统的可靠性和安全性。</p> 
<h3><a id="911__5"></a>9.1.1 软件可靠性定义</h3> 
<p>软件可靠性是指在规定的时间周期内，在特定条件下，软件能够完成其规定功能的能力。与硬件相比，软件具有<strong>复杂性</strong>、<strong>物理退化</strong>、<strong>唯一性</strong>和<strong>版本更新快</strong>的特点。</p> 
<p>软件可靠性的定义是在规定的时间内，软件不引起系统失效的概率，与系统输入和已知缺陷相关。软件可靠性的框架性定义包括规定的时间、规定的条件和所要求的功能。</p> 
<p>这一定义使用内在的缺陷和外在的失效关系描述软件可靠性，并通过概率方法进行量化评估，使人们能够建立数学模型分析软件可靠性。</p> 
<h3><a id="912__12"></a>9.1.2 软件可靠性的定量描述</h3> 
<p>软件可靠性可以通过数学表达式来描述，其中涉及到一些概念和变量。下面是对软件可靠性的定量描述和相关概念的总结：</p> 
<ol><li> <p>规定时间：包括自然时间（日历时间）、运行时间（从启动到结束的时间段）和执行时间（CPU执行指令的时间总和）。以执行时间作为度量软件可靠性最准确的方式。</p> </li><li> <p>失效概率：表示软件在某一时刻t之前出现失效的概率，用F(t)表示。具有初始化失效概率为0、随时间递增且趋向于1的特征。</p> </li><li> <p>可靠度：可靠度是表示软件在规定条件下、规定时间内不发生失效的概率，用R(t)表示。可通过可靠度的公式R(t)=1-F(t)来计算。</p> </li><li> <p>失效强度：失效强度是单位时间内软件系统出现失效的概率。用f(t)表示失效强度函数。</p> </li><li> <p>平均失效前时间（MTTF）：指系统从开始运行到发生故障之间的平均时间。可以通过积分计算得到。</p> </li><li> <p>平均恢复前时间（MTTR）：指从发生故障到修复成功所需的平均时间。</p> </li><li> <p>平均故障间隔时间（MTBF）：指失效或维护所需的平均时间，包括故障时间和维护设备的时间。</p> </li></ol> 
<p>需要注意的是，在描述软件可靠性时需要明确软件对象、定义失效情况、假设硬件无故障、考虑运行环境等因素。同时，可靠性可以以概率或可能性加以度量，并且可靠性既可以在时间域上动态度量，也可以在数据域上表态度量。</p> 
<p>另外，运行剖面用于定义系统使用条件，即测试环境和测试数据等问题。</p> 
<h3><a id="913__33"></a>9.1.3 可靠性目标</h3> 
<p>在定量分析软件可靠性时，除了考虑失效发生的概率外，还需要关注失效对软件运行的严重程度。为了描述软件失效的严重程度，引入了失效严重程度类的概念，用于定义具有相同影响程度的失效集合。失效严重程度类的划分可以基于成本影响和系统能力影响等标准，并常用数量级来进行等级划分。考虑到客户对软件性能的期望，可靠性目标可以用可靠度、故障强度和平均失效时间等指标来描述，需根据项目需求平衡可靠性、交付时间和成本。因此，建立定量的可靠性指标需要确定系统的运行模式、定义故障的严重性等级和确定故障强度目标。</p> 
<h3><a id="914__35"></a>9.1.4 可靠性测试的意义</h3> 
<p>软件可靠性问题日益受到软件工程专家的关注，研究人员开始投入大量资源研究软件可靠性的设计、评估和测试等方面。软件可靠性问题对软件工程实践、生产活动和社会活动产生深远影响，以下几个方面可以说明这一点：</p> 
<ol><li> <p>软件失效可能造成灾难性后果：软件失效可能导致严重的后果，例如控制系统程序中的一个错误导致宇宙飞行失败。随着计算机和软件在各行各业的广泛应用，如军事系统、民航指挥系统、银行支付系统和交通调控系统等，严重的软件失效可能导致经济损失甚至危及人们的生命安全和国家安全。</p> </li><li> <p>软件失效在计算机系统失效中的比例较高：研究表明，在计算机系统失效中，约有80%与软件有关。这是因为软件系统的复杂性很高，即使是相对简单的程序，其路径数也可能非常庞大。因此，在软件开发过程中很难通过全路径覆盖测试来发现所有潜在的缺陷，也难以完全消除软件缺陷。</p> </li><li> <p>软件可靠性技术不成熟：与硬件可靠性技术相比，软件可靠性技术仍然相对不成熟。例如，在硬件可靠性领域，故障树分析 (FTA)、失效模式与效应分析 (FMEA) 等技术已经比较成熟，并且容错技术得到广泛应用。然而，在软件可靠性领域，这些技术似乎还没有定型。</p> </li><li> <p>软件费用不断增加：与硬件元器件成本不断下降形成鲜明对比的是，软件费用呈现增长趋势。软件可靠性问题是导致软件费用增加的主要原因之一。</p> </li><li> <p>对软件的依赖性增加：随着计算机技术在各个领域的广泛应用，系统对软件的依赖性越来越强。随着软件在生产活动和社会生活中的影响日益增大，软件可靠性问题在软件工程和整个计算机工程领域的重要性也越来越突出。</p> </li></ol> 
<p>因此，软件可靠性问题的重要性凸显了发展以发现软件可靠性缺陷为目的的可靠性设计与测试技术的迫切性。</p> 
<h3><a id="915__49"></a>9.1.5 广义的可靠性测试与狭义的可靠性测试</h3> 
<p>广义的软件可靠性测试是指为了最终评价软件系统的可靠性而运用建模、统计、试验、分析和评价等一系列手段对软件系统实施的一种测试。<br> <img src="https://images2.imgbox.com/58/c9/CsIAk9WR_o.png" alt="在这里插入图片描述"><br> 软件可靠性测试是为了获取可靠性数据，根据预先确定的测试用例，在软件的预期使用环境中对软件进行的一种测试。它是面向缺陷的测试，以用户将要使用的方式来测试软件，每次测试代表用户将要完成的一组操作。可靠性测试的目的包括发现软件系统的各种缺陷，为软件的使用和维护提供可靠性数据，以及确认软件是否达到可靠性的定量要求。</p> 
<h2><a id="92__53"></a>9.2 软件可靠性建模</h2> 
<h3><a id="921__54"></a>9.2.1 影响软件可靠性的因素</h3> 
<p>软件可靠性评估是一个复杂的过程，需要建立可靠性模型来预测和评估软件的可靠性。可靠性模型将复杂系统的可靠性分解为简单系统的可靠性，以便于定量预计、分配、估算和评价整个系统的可靠性。</p> 
<p>影响软件可靠性的因素众多，其中主要因素包括缺陷的引入、发现和清除。缺陷的引入受软件产品特性和开发过程特性的影响，而缺陷的发现和清除则依赖于用户的操作方式和运行环境。</p> 
<p>从技术的角度来看，影响软件可靠性的因素包括运行环境、软件规模、软件内部结构、开发方法和开发环境以及可靠性投入。不同的运行环境下，软件的可靠性表现会有所不同。软件规模的大小也会对可靠性产生影响，大型软件通常存在更多的缺陷。软件的内部结构复杂度越高，可能存在更多的软件缺陷。采用不同的开发方法和开发环境也会对可靠性产生显著影响。此外，开发者在可靠性设计、管理、测试和评价方面的投入也会影响软件的可靠性。</p> 
<p>总之，软件可靠性受到许多因素的影响，其中有些因素之间的关系尚未确定。建立可靠性模型可以帮助我们更好地理解和评估软件的可靠性，从而提高软件的质量和可靠性水平。</p> 
<h3><a id="922__63"></a>9.2.2 软件可靠性的建模方法</h3> 
<p>一个可靠的软件可靠性模型通常包括模型假设、性能度量、参数估计方法和数据要求。绝大多数模型都有代表性假设、独立性假设和相同性假设。模型的参数可以通过统计分析或使用软件属性和开发过程进行估计和预测。确定了模型的参数后，可以表示失效过程的各种特性，如平均失效数、失效强度和失效区间的概率分布。在预测将来的故障行为时，应保持模型参数的稳定性。一个好的软件可靠性模型应该基于可靠的假设、简单、计算有用的量、给出好的未来失效行为映射，并可广泛应用。建立一个有用的软件可靠性模型需要理论研究、工具建造和实际经验的支持。而应用一个好的模型则可以在实际工作中以较少的资源产生好的效益。</p> 
<h3><a id="923__66"></a>9.2.3 软件的可靠性模型分类</h3> 
<p>有效的软件可靠性模型应考虑多种因素，并尽可能简明地反映出来。自1972年以来，已经有近百种软件可靠性统计分析模型出现。这些模型可以大致分为以下十类：</p> 
<ol><li>种子法模型：利用一再捕获抽样技术估计程序中的错误数，通过在程序中预先设定错误种子并根据测试结果估计程序中残留的错误数。</li><li>失效率类模型：用于研究程序的失效率，包括几何De-eutrophication模型、Schick-Wolverton模型、Goal和Okumoto不完全排错模型等。</li><li>曲线拟合类模型：使用回归分析方法研究软件复杂性、缺陷数、失效率等，包括参数方法和非参数方法。</li><li>可靠性增长模型：用增长函数描述软件在检错过程中的可靠性改进，如Duane模型、Weibull模型等。</li><li>程序结构分析模型：根据程序及其调用关系形成一个可靠性分析网络，通过计算每个结点的可靠性、结点间转换的可靠性和转换概率得出整体可靠性。</li><li>输入域分类模型：选取输入域中的样本点运行程序，通过测试运行的成功/失效率推断软件的使用可靠性，如Nelson模型、Bastani的基于输入域的随机过程模型。</li><li>执行路径分析方法模型：计算程序中各逻辑路径和错误路径的执行概率，综合得出软件的使用可靠性，如Shooman分解模型。</li><li>非齐次泊松过程模型：以单位时间的失效次数为独立泊松随机变量，预测在未来某个时间点的累计失效数，如Musa的指数模型、Goel和Okumoto的NHPP模型等。</li><li>马尔可夫过程模型：描述软件的故障转移过程，包括线性死亡模型和非静态线性死亡模型。</li><li>贝叶斯模型：利用失效率的试验前分布和当前的测试失效信息评估软件的可靠性，适用于开发过程了解充分且具有良好继承性的情况。</li></ol> 
<p>此外，根据模型的不同属性，可将可靠性模型进行更详细的分类，如时间域、失效数类、失效数分布、有限类和无限类等。</p> 
<h2><a id="93__82"></a>9.3 软件可靠性管理</h2> 
<p>软件可靠性管理是指将软件可靠性活动贯穿于软件开发的全过程，以全面提高和保证软件可靠性为目标的管理形式。它是软件工程管理的一部分，涉及软件开发各个阶段的可靠性目标、计划、进度、任务和修正措施等内容。</p> 
<p>在软件可靠性管理中，各个阶段可能进行的主要活动包括：</p> 
<ol><li>需求分析阶段：</li></ol> 
<ul><li>确定软件的可靠性目标。</li><li>分析可能影响可靠性的因素。</li><li>确定可靠性的验收标准。</li><li>制定可靠性管理框架。</li><li>制定可靠性文档编写规范。</li><li>制订可靠性活动初步计划。</li><li>确定可靠性数据收集规范。</li></ul> 
<ol start="2"><li>概要设计阶段：</li></ol> 
<ul><li>确定可靠性度量。</li><li>制定详细的可靠性验收方案。</li><li>进行可靠性设计。</li><li>收集可靠性数据。</li><li>调整可靠性活动计划。</li><li>明确后续阶段的可靠性活动的详细计划。</li><li>编制可靠性文档。</li></ul> 
<ol start="3"><li>详细设计阶段：</li></ol> 
<ul><li>进行可靠性设计。</li><li>进行可靠性预测，确定可靠性度量的估计值。</li><li>调整可靠性活动计划。</li><li>收集可靠性数据。</li><li>明确后续阶段的可靠性活动的详细计划。</li><li>编制可靠性文档。</li></ul> 
<ol start="4"><li>编码阶段：</li></ol> 
<ul><li>进行可靠性测试（包括单元测试）。</li><li>进行排错。</li><li>调整可靠性活动计划。</li><li>收集可靠性数据。</li><li>明确后续阶段的可靠性活动的详细计划。</li><li>编制可靠性文档。</li></ul> 
<ol start="5"><li>测试阶段：</li></ol> 
<ul><li>进行可靠性测试（包括集成测试和系统测试）。</li><li>进行排错。</li><li>进行可靠性建模。</li><li>进行可靠性评价。</li><li>调整可靠性活动计划。</li><li>收集可靠性数据。</li><li>明确后续阶段的可靠性活动的详细计划。</li><li>编制可靠性文档。</li></ul> 
<ol start="6"><li>实施阶段：</li></ol> 
<ul><li>进行可靠性测试（包括验收测试）。</li><li>进行排错。</li><li>收集可靠性数据。</li><li>调整可靠性模型。</li><li>进行可靠性评价。</li><li>编制可靠性文档。</li><li></ul> 
<p>需要指出的是，软件可靠性管理的具体内容可能因软件之间的差异和对可靠性的期望不同而有所不同。目前，可靠性管理还停留在定性描述的水平上，很难用量化的指标进行管理。同时，可靠性管理规范的制定和实施效果也需要进一步提高。因此，如何在有限的可靠性投入下达到预期的可靠性目标仍然是软件项目管理者面临的挑战，可靠性管理的研究仍然是一个长期的课题。</p> 
<h2><a id="94__135"></a>9.4 软件可靠性设计</h2> 
<p>在软件开发的测试阶段，虽然利用各种测试手段收集测试数据并利用软件可靠性模型来评估或预测软件的可靠性，可以在一定程度上改善软件的可靠性，但这些测试活动并不能从根本上提高软件的可靠性，也难以保证软件的可靠性。同时，对由设计导致的软件缺陷进行修改可能会付出昂贵的代价。实践证明，保障软件可靠性最有效、最经济、最重要的手段是在软件设计阶段采取措施进行可靠性控制。</p> 
<p>可靠性设计是指在常规的软件设计中，应用各种方法和技术，使程序设计在兼顾用户的功能和性能需求的同时，全面满足软件的可靠性要求，即采用一些技术手段，把可靠性“设计”到软件中去。软件可靠性设计技术就是为了提高和保障软件的可靠性而在软件设计阶段运用的一种特殊的设计技术。</p> 
<p>软件可靠性设计技术包括容错设计、检错设计和降低复杂度设计等技术。这些技术旨在在满足提高软件质量要求的前提下，以提高和保障软件可靠性为最终目标，在软件的总体设计框架中使用，并且不能与其他设计原则相冲突。此外，软件可靠性设计应确定软件的可靠性目标，并在考虑功能度、用户需求和开发费用之后确定合适的可靠性目标。</p> 
<p>因此，可靠性设计是软件工程中关键的一环，它强调在软件设计阶段就考虑和解决软件的可靠性问题，以减少后期修复缺陷的成本和难度。通过合理运用可靠性设计技术，可以大大提高软件的可靠性，确保软件系统长期稳定可靠地运行。</p> 
<h3><a id="941__144"></a>9.4.1 容错设计技术</h3> 
<p>针对软件失效后果特别严重的场合，如飞机的飞行控制系统、空中交通管制系统及核反应堆安全控制系统等，可采用容错设计方法。常用的软件容错技术主要有恢复块设计、N版本程序设计和冗余设计三种方法。</p> 
<ol><li> <p>恢复块设计是选择一组操作作为容错设计单元，从而把普通的程序块变成恢复块。一个恢复块包含有若干个功能相同、设计差异的程序块文本，每一时刻有一个文本处于运行状态。一旦该文本出现故障，则用备份文本加以替换，从而构成“动态冗余”。</p> </li><li> <p>N版本程序设计的核心是通过设计出多个模块或不同版本，对于相同初始条件和相同输入的操作结果，实行多数表决，防止其中某一软件模块/版本的故障提供错误的服务，以实现软件容错。</p> </li><li> <p>冗余设计改善软件可靠性的一个重要技术是冗余设计。在软件系统中，冗余技术的运用有所区别。冗余设计技术实现的原理是在一套完整的软件系统之外，设计一种不同路径、不同算法或不同实现方法的模块或系统作为备份，在出现故障时可以使用冗余的部分进行替换，从而维持软件系统的正常运行。</p> </li></ol> 
<h3><a id="942__153"></a>9.4.2 检错技术</h3> 
<p>在软件系统中，对于不需要在线容错或无法采用冗余设计技术的部分，可以使用检错技术来提高可靠性。检错技术的实现成本通常较低，但它不能自动解决故障，需要进行人工干预。</p> 
<p>在采用检错设计技术时，需要考虑以下几个要素：</p> 
<ol><li>检测对象：包括检测点和检测内容。检测点应放置在容易出错且对系统影响较大的地方，检测内容应选择具有代表性且易于判断的指标。</li><li>检测延时：从软件发生故障到被检测出来存在一定延时，该延时的长短对故障处理至关重要。因此，在设计时应充分考虑检测延时，并根据需要更换检测对象或方式。</li><li>实现方式：常见的实现方式包括判断返回结果、计算运行时间和设置状态标志位等。选择自检的实现方式应根据具体情况进行选择。</li><li>处理方式：大多数检错技术采用“查出故障一停止软件系统运行一报警”的处理方式。但对于需要实时处理的故障，也可以选择不停止或部分停止软件系统运行。</li></ol> 
<p>综上所述，通过采用检错技术可以及时发现软件故障并进行报警，提高软件系统的可靠性。</p> 
<h3><a id="943__165"></a>9.4.3 降低复杂度设计</h3> 
<p>软件复杂性是指软件内部结构的复杂程度，包括模块复杂性和结构复杂性。过高的软件复杂性容易导致软件缺陷增多，从而降低软件可靠性。因此，在设计软件时应考虑降低复杂性，简化结构、缩短代码长度和优化数据流向，以提高软件可靠性。</p> 
<p>在软件可靠性设计中，除了容错设计、检错设计和降低复杂度设计技术，还可以运用硬件可靠性设计中的一些方法，如故障树分析 (FTA) 和失效模式与效应分析 (FMEA)。然而，由于软件与硬件的差异，这些方法在软件可靠性设计中的应用效果有限。</p> 
<p>综上所述，通过降低软件复杂性、采用容错设计和检错设计技术，以及借鉴硬件可靠性设计中的方法，可以提高软件系统的可靠性。</p> 
<h3><a id="944__172"></a>9.4.4 系统配置技术</h3> 
<p>服务器集群技术常用的集群类型有以下几种：</p> 
<ol><li>高可用性集群：该类型的集群旨在提供高可靠性的服务。它通常包括双活（Active/Active）或者热备（Active/Standby）模式，它们可以通过共享存储或者网络文件系统实现数据同步和故障切换。</li><li>负载均衡集群：该类型的集群旨在平衡多台服务器的负载，从而提供更好的性能和可扩展性。负载均衡器会根据一定的算法将请求分发到不同的服务器上处理，以达到均衡负载的目的。</li><li>应用程序集群：该类型的集群旨在提供可扩展的应用程序服务。它通常使用分布式应用程序架构，将应用程序分解为独立的模块，并将这些模块部署到不同的服务器上。应用程序集群可以通过负载均衡器进行请求分发，以实现可伸缩性和高可用性。</li></ol> 
<p>总之，服务器集群技术通过多台服务器之间的协作与配合，可以提供更高的可靠性、可扩展性、性能等优点。但是，相较于双机热备技术，服务器集群技术需要更高的成本和复杂度，需要对网络、存储等技术有更高的要求。</p> 
<h2><a id="95__180"></a>9.5 软件可靠性测试</h2> 
<h3><a id="951__181"></a>9.5.1 软件可靠性测试概述</h3> 
<p>软件测试者可以采用多种方法进行软件测试，每种方法都有其局限性和适用范围。通过这些方法进行测试可以暴露一定数量和类别的缺陷，并实现软件可靠性增长。但是，测试结果不能直接用于软件可靠性评价，需要进行分析处理后才能使用可靠性模型进行评价。</p> 
<p>软件可靠性测试包含多个主要活动，如可靠性目标的确定、运行剖面的开发、测试用例的设计、测试实施和测试结果的分析等。在进行软件可靠性测试时还需要考虑对软件开发进度和成本的影响，最好在受控的自动测试环境下由专业测试机构完成。</p> 
<p>软件可靠性测试是一种有效的软件测试和可靠性评价技术，可以帮助开发高可靠性与高安全性软件系统。但是，软件可靠性测试在工程上仍需获得广泛应用，还需要解决许多实际问题。</p> 
<h3><a id="952__187"></a>9.5.2 定义软件运行剖面</h3> 
<p>定义软件的运行剖面需要建立马尔可夫链模型来表示用户的行为，并通过弧连接状态表示不同激励导致的转换。开发使用模型涉及对用户和用法进行分层，分配概率估计可以基于现有数据、用户交谈、原型分析和专家意见。最佳的方法是使用实际的用户数据，其次是预期使用数据，最差的方法是将每个状态的弧分配相同的概率。</p> 
<p>在准备可靠性测试时，需要充分分析和考虑软件的实际运行情况，因为不同的运行剖面可能导致不同的可靠性表现。在测试中，应该注意到最频繁出现的操作和输入可能具有较高的故障率，但也要注意边界、跃迁情况和关键功能，需要构造专门的运行剖面进行补充测试。</p> 
<p>一个产品可能需要多个运行剖面，特别是针对关键操作需要单独定义运行剖面。</p> 
<h3><a id="953__194"></a>9.5.3 可靠性测试用例设计</h3> 
<p>在软件可靠性测试中，首先需要定义一个与实际运行环境相匹配的运行剖面，然后使用该剖面来驱动测试，以反映真实的使用情况。为了选择合适的测试用例，可以使用统计方法来开发和生成测试用例，并为每个运行剖面元素分配概率和关键因素值，然后根据这些因素来分配测试资源。</p> 
<p>在测试中，应优先测试最重要或最频繁使用的功能，以尽早发现可能对可靠性产生最大影响的故障，并确保按时交付软件。设计测试用例时，应考虑一般情况、极限情况以及边界值情况。测试用例应包括标识、被测对象、测试环境和条件、测试输入、操作步骤、预期输出、结果判断以及特殊需求。</p> 
<p>除了常规的测试用例集，可靠性测试还应重点考虑与可靠性密切相关的特殊情况。在测试中，可以使用"强化输入"，即更恶劣的输入条件，以评估软件系统的可靠性。</p> 
<h3><a id="954__200"></a>9.5.4 可靠性测试的实施</h3> 
<ol><li>在进行软件可靠性测试前，需要检查软件需求与设计文档的一致性，以及软件开发过程中形成的文档的准确性、完整性和与程序的一致性。</li><li>受控测试是软件可靠性测试的基础，需要确保测试过程中的每个测试用例都使用相同的软件版本。</li><li>除了统计测试，有时还需要进行非统计测试以满足客户要求、合同规定或标准约束。</li><li>软件的可测试性对软件可靠性测试至关重要，难点在于判断测试用例的运行成功与失败。</li><li>软件可靠性数据是可靠性评价的基础，应该记录测试过程中的相关信息，并编写《软件可靠性测试报告》进行总结归纳。</li><li>规范化可靠性测试过程有利于获得真实有效的数据，从而为最终得到客观的可靠性评价结果奠定基础。</li></ol> 
<h2><a id="96__208"></a>9.6 软件可靠性评价</h2> 
<h3><a id="961__209"></a>9.6.1 软件可靠性评价概述</h3> 
<ol><li>软件可靠性评价适用于软件开发过程和最终软件系统，用于估计当前软件的可靠性水平、预测达到相应可靠性水平所需时间和工作量，并评估最终软件产品的可靠性水平。</li><li>在软件开发过程中，可以使用软件可靠性模型来评估软件的可靠性，并确定是否可以终止测试和发布软件。</li><li>对于最终软件产品，软件可靠性评价结合可靠性验证测试，验证软件的执行与需求的一致性，并确定最终软件产品的可靠性水平。<br> 软件可靠性评价需要选择合适的可靠性模型，收集软件可靠性数据，并运用统计技术和其他手段对数据进行处理，以进行可靠性评估和预测。</li></ol> 
<p>以上是软件可靠性评价的核心要点。</p> 
<h3><a id="962__216"></a>9.6.2 怎样选择可靠性模型</h3> 
<p>选择可靠性模型时需要考虑以下几个因素：</p> 
<ol><li>模型假设的适用性：模型的假设必须符合软件系统的实际情况，并且与现有的软件系统冲突的因素应该可以忽略不计。</li><li>预测的能力与质量：模型应该能够准确地根据现有和历史的可靠性数据预测将来的可靠性和失效概率。选择成熟、广泛应用的模型能提高预测能力和质量。</li><li>模型输出值是否满足评价需求：根据可靠性测试的目的确定需要精确估计的可靠性定量指标，确保所选模型能够输出满足评价需求的结果。</li><li>模型使用的简便性：模型需要的数据易于收集，并且收集成本不能超过预算；模型应该简单易懂，测试人员不需要深入研究数学理论；最好能够使用工具实现数据输入，减少额外工作量。</li></ol> 
<p>尽管可供选择的可靠性模型有限，但以上因素可以帮助选择适合的模型进行可靠性评价</p> 
<h3><a id="963__225"></a>9.6.3 可靠性数据的收集</h3> 
<p>可靠性数据对于软件可靠性评价至关重要。然而，在数据收集工作中存在一些问题，包括规范不统一、连续性不足、缺乏有效的数据收集手段、数据完整性和准确性不足等。为了解决这些问题，需要及早确定可靠性模型并明确可靠性数据规范，制订可行的数据收集计划，并重视测试数据的整理和分析。同时，充分利用数据库来存储和分析可靠性数据也是一种有效的方法。通过这些措施可以提高软件可靠性评价的准确性和有效性。</p> 
<h3><a id="964_227"></a>9.6.4软件可靠性的评估和预测</h3> 
<p>软件可靠性的评估和预测主要目的是为了评估软件系统的可靠性状况，并预测将来一段时间的可靠性水平。常见的需要利用软件可靠性评价解答的问题包括判断是否达到可靠性目标、投入多少资源才能达到可靠性目标，以及在软件系统投入实际运行后能否达到用户使用的可靠性水平。目前有许多支持软件可靠性估计的软件工具，但对于可靠性要求很高的系统，必须进行大量测试才能得出高置信度的结果。即便如此，仍然可能没有任何失效发生，这时可以假设测试是基于二项式分布的，并对可靠性作保守估计。软件可靠性评价技术和方法主要依据选用的软件可靠性模型，统计方法和技术可以作为可靠性模型的补充、完善和修正，例如失效数据的图形分析法和试探性数据分析技术等。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b4246641c834a33af38e9f2ae66259f0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python---TCP 客户端程序开发</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58e17a2bef459135d4dc3aa24779eb23/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构 | 北京大学期末试卷查漏补缺</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>