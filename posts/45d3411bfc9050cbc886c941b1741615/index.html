<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STL详解（九） 映射容器map - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STL详解（九） 映射容器map" />
<meta property="og:description" content="一、map简介 1、 什么是Map Map是STL的一个关联容器，翻译为映射，数组也是一种映射。如：int a[10] 是int 到 int的映射，而a[5]=25,是把5映射到25。数组总是将int类型映射到其他类型。这带来一个问题，有时候希望把string映射成一个int ，数组就不方便了，这时就可以使用map。map可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）。
map提供关键字到值的映射 ，其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个称为该关键字的值，由于这个特性.
普通 int 数组是 map&lt;int ,int &gt; a。字符到整型的映射，就是 map&lt;char ,int &gt; a，而字符串到整型的映射，就必须是 map&lt;string , int &gt; a。map的键和值也可以是STL容器，如 map&lt; set&lt;int&gt; ,string&gt; a,而且键和值都是唯一的。
map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。
map的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。对于迭代器来说，可以修改实值，而不能修改key。
2、map的功能 自动建立Key － value的对应。key 和 value可以是任意你需要的类型。 根据key值快速查找记录，查找的复杂度基本是Log(N)，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次。 快速插入Key -Value 记录。快速删除记录根据Key 修改value记录。遍历所有记录。 3、使用map map对象是模板类，需要关键字和存储对象两个模板参数：
std:map&lt;int,string&gt; personnel;
这样就定义了一个用int作为索引,并拥有相关联的指向string的指针。为了使用方便，可以对模板类进行一下类型定义，
typedef map&lt;int,CString&gt; mapc
mapc enumMap;
二、 map的基本操作函数： begin() 返回指向map头部的迭代器
end() 返回指向map末尾的迭代器
rbegin() 返回一个指向map尾部的逆向迭代器
rend() 返回一个指向map头部的逆向迭代器
lower_bound() 返回键值&gt;=给定元素的第一个位置
upper_bound() 返回键值&gt;给定元素的第一个位置" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/45d3411bfc9050cbc886c941b1741615/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-10T18:14:14+08:00" />
<meta property="article:modified_time" content="2023-11-10T18:14:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STL详解（九） 映射容器map</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、map简介</h2> 
<p></p> 
<h4>       1、 什么是Map</h4> 
<p>        Map是STL的一个关联容器，翻译为映射，数组也是一种映射。如：int a[10] 是int 到 int的映射，而a[5]=25,是把5映射到25。数组总是将int类型映射到其他类型。这带来一个问题，有时候希望把string映射成一个int ，数组就不方便了，这时就可以使用map。map可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）。</p> 
<p>        map提供关键字到值的映射 ，其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个称为该关键字的值，由于这个特性.</p> 
<p>         普通 int 数组是 map&lt;int ,int &gt; a。字符到整型的映射，就是 map&lt;char ,int &gt; a，而字符串到整型的映射，就必须是 map&lt;string , int &gt; a。map的键和值也可以是STL容器，如 map&lt; set&lt;int&gt; ,string&gt; a,而且键和值都是唯一的。</p> 
<p>        map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。</p> 
<p>        map的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。对于迭代器来说，可以修改实值，而不能修改key。</p> 
<p></p> 
<h4>2、map的功能</h4> 
<ul><li> 自动建立Key － value的对应。key 和 value可以是任意你需要的类型。</li><li><strong> 根据key值快速查找记录，查找的复杂度基本是Log</strong>(N)，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次。</li><li> 快速插入Key -Value 记录。</li><li>快速删除记录</li><li>根据Key 修改value记录。</li><li>遍历所有记录。</li></ul> 
<p></p> 
<h4>3、使用map</h4> 
<p>       map对象是模板类，需要关键字和存储对象两个模板参数：</p> 
<p>std:map&lt;<strong>int</strong>,string&gt; personnel;</p> 
<p>       这样就定义了一个用int作为索引,并拥有相关联的指向string的指针。为了使用方便，可以对模板类进行一下类型定义，</p> 
<p><strong>typedef     </strong>map&lt;<strong>int</strong>,CString&gt;     mapc</p> 
<p>mapc   enumMap;</p> 
<p></p> 
<h2>二、   map的基本操作函数：</h2> 
<p>    </p> 
<p><strong>begin</strong>()         返回指向map头部的迭代器</p> 
<p><strong>end</strong>()           返回指向map末尾的迭代器</p> 
<p><strong>rbegin</strong>()        返回一个指向map尾部的逆向迭代器</p> 
<p><strong>rend</strong>()          返回一个指向map头部的逆向迭代器</p> 
<p><strong>lower_bound</strong>()   返回键值&gt;=给定元素的第一个位置</p> 
<p><strong>upper_bound</strong>()    返回键值&gt;给定元素的第一个位置</p> 
<p> <strong>empty</strong>()         如果map为空则返回true   </p> 
<p><strong>max_size</strong>()      返回可以容纳的最大元素个数    </p> 
<p><strong>size</strong>()          返回map中元素的个数</p> 
<p><strong>clear</strong>(）        删除所有元素</p> 
<p><strong>count</strong>()         返回指定元素出现的次数</p> 
<p><strong>equal_range</strong>()   返回特殊条目的迭代器对</p> 
<p><strong>erase</strong>()         删除一个元素</p> 
<p><strong>swap</strong>()           交换两个map</p> 
<p><strong>find</strong>()          查找一个元素</p> 
<p><strong>get_allocator</strong>() 返回map的配置器</p> 
<p> <strong>insert</strong>()        插入元素</p> 
<p> <strong>key_comp</strong>()      返回比较元素key的函数</p> 
<p> <strong>value_comp</strong>()     返回比较元素value的函数</p> 
<p></p> 
<h2>三、map容器函数详解</h2> 
<p></p> 
<h4>1、 map的构造函数</h4> 
<p>        map共提供了6个构造函数，这块涉及到内存分配器这些东西，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：</p> 
<p> map&lt;string , int &gt;mapstring;      </p> 
<p> map&lt;int ,string &gt;mapint;</p> 
<p> map&lt;sring, char&gt;mapstring;</p> 
<p> map&lt; char ,string&gt;mapchar;</p> 
<p>map&lt;char ,int&gt;mapchar;  </p> 
<p>map&lt;int ,char &gt;mapint；</p> 
<p></p> 
<p></p> 
<p>5、     数据的插入</p> 
<p></p> 
<p>在构造map容器后，我们就可以往里面插入数据了。这里讲三种插入数据的方法：</p> 
<p></p> 
<p>第一种：用insert函数插入pair数据，下面举例说明(以下代码虽然是随手写的，应该可以在VC和GCC下编译通过，大家可以运行下看什么效果，在VC下请加入这条语句，屏蔽4786警告 ＃pragma warning (disable:4786) )</p> 
<p></p> 
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="view plain">view plain</a> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="copy">copy</a></p> 
<p></p> 
<ol><li>//数据的插入--第一种：用insert函数插入pair数据  </li><li>#include &lt;map&gt;  </li><li>  </li><li>#include &lt;string&gt;  </li><li>  </li><li>#include &lt;iostream&gt;  </li><li>  </li><li>using namespace std;  </li><li>  </li><li>int main()  </li><li>  </li><li>{  </li><li>  </li><li>    map&lt;int, string&gt; mapStudent;  </li><li>  </li><li>    mapStudent.insert(pair&lt;int, string&gt;(1, "student_one"));  </li><li>  </li><li>    mapStudent.insert(pair&lt;int, string&gt;(2, "student_two"));  </li><li>  </li><li>    mapStudent.insert(pair&lt;int, string&gt;(3, "student_three"));  </li><li>  </li><li>    map&lt;int, string&gt;::iterator iter;  </li><li>  </li><li>    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </li><li>  </li><li>       cout&lt;&lt;iter-&gt;first&lt;&lt;' '&lt;&lt;iter-&gt;second&lt;&lt;endl;  </li><li>  </li><li>}  </li></ol> 
<p></p> 
<p></p> 
<p>第二种：用insert函数插入value_type数据，下面举例说明</p> 
<p></p> 
<p></p> 
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="view plain">view plain</a> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="copy">copy</a></p> 
<p></p> 
<ol><li>//第二种：用insert函数插入value_type数据，下面举例说明  </li><li>  </li><li>#include &lt;map&gt;  </li><li>  </li><li>#include &lt;string&gt;  </li><li>  </li><li>#include &lt;iostream&gt;  </li><li>  </li><li>using namespace std;  </li><li>  </li><li>int main()  </li><li>  </li><li>{  </li><li>  </li><li>    map&lt;int, string&gt; mapStudent;  </li><li>  </li><li>    mapStudent.insert(map&lt;int, string&gt;::value_type (1, "student_one"));  </li><li>  </li><li>    mapStudent.insert(map&lt;int, string&gt;::value_type (2, "student_two"));  </li><li>  </li><li>    mapStudent.insert(map&lt;int, string&gt;::value_type (3, "student_three"));  </li><li>  </li><li>    map&lt;int, string&gt;::iterator iter;  </li><li>  </li><li>    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </li><li>  </li><li>       cout&lt;&lt;iter-&gt;first&lt;&lt;' '&lt;&lt;iter-&gt;second&lt;&lt;endl;  </li><li>  </li><li>}  </li></ol> 
<p><br> 第三种：用数组方式插入数据，下面举例说明</p> 
<p></p> 
<p></p> 
<p></p> 
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="view plain">view plain</a> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="copy">copy</a></p> 
<p></p> 
<ol><li>//第三种：用数组方式插入数据，下面举例说明  </li><li>  </li><li>#include &lt;map&gt;  </li><li>  </li><li>#include &lt;string&gt;  </li><li>  </li><li>#include &lt;iostream&gt;  </li><li>  </li><li>using namespace std;  </li><li>  </li><li>int main()  </li><li>  </li><li>{  </li><li>  </li><li>    map&lt;int, string&gt; mapStudent;  </li><li>  </li><li>    mapStudent[1] = "student_one";  </li><li>  </li><li>    mapStudent[2] = "student_two";  </li><li>  </li><li>    mapStudent[3] = "student_three";  </li><li>  </li><li>    map&lt;int, string&gt;::iterator iter;  </li><li>  </li><li>    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </li><li>  </li><li>        cout&lt;&lt;iter-&gt;first&lt;&lt;' '&lt;&lt;iter-&gt;second&lt;&lt;endl;  </li><li>  </li><li>}  </li></ol> 
<p></p> 
<p></p> 
<p></p> 
<p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明</p> 
<p></p> 
<p>mapStudent.insert(map&lt;int, string&gt;::value_type (1, "student_one"));</p> 
<p></p> 
<p>mapStudent.insert(map&lt;int, string&gt;::value_type (1, "student_two"));</p> 
<p></p> 
<p>上面这两条语句执行后，map中1这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下</p> 
<p></p> 
<p>pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair;</p> 
<p></p> 
<p>Insert_Pair = mapStudent.insert(map&lt;int, string&gt;::value_type (1, "student_one"));</p> 
<p></p> 
<p>我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。</p> 
<p></p> 
<p>下面给出完成代码，演示插入成功与否问题</p> 
<p></p> 
<p></p> 
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="view plain">view plain</a> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="copy">copy</a></p> 
<p></p> 
<ol><li>//验证插入函数的作用效果  </li><li>#include &lt;map&gt;  </li><li>  </li><li>#include &lt;string&gt;  </li><li>  </li><li>#include &lt;iostream&gt;  </li><li>  </li><li>using namespace std;  </li><li>  </li><li>int main()  </li><li>  </li><li>{  </li><li>  </li><li>    map&lt;int, string&gt; mapStudent;  </li><li>  </li><li>    pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair;  </li><li>  </li><li>    Insert_Pair = mapStudent.insert(pair&lt;int, string&gt;(1, "student_one"));  </li><li>  </li><li>    if(Insert_Pair.second == true)  </li><li>  </li><li>        cout&lt;&lt;"Insert Successfully"&lt;&lt;endl;  </li><li>  </li><li>    else  </li><li>  </li><li>        cout&lt;&lt;"Insert Failure"&lt;&lt;endl;  </li><li>  </li><li>    Insert_Pair = mapStudent.insert(pair&lt;int, string&gt;(1, "student_two"));  </li><li>  </li><li>    if(Insert_Pair.second == true)  </li><li>  </li><li>        cout&lt;&lt;"Insert Successfully"&lt;&lt;endl;  </li><li>  </li><li>    else  </li><li>  </li><li>        cout&lt;&lt;"Insert Failure"&lt;&lt;endl;  </li><li>  </li><li>    map&lt;int, string&gt;::iterator iter;  </li><li>  </li><li>    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </li><li>  </li><li>       cout&lt;&lt;iter-&gt;first&lt;&lt;' '&lt;&lt;iter-&gt;second&lt;&lt;endl;  </li><li>  </li><li>}  </li></ol> 
<p><br> 大家可以用如下程序，看下用数组插入在数据覆盖上的效果</p> 
<p></p> 
<p></p> 
<p></p> 
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="view plain">view plain</a> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="copy">copy</a></p> 
<p></p> 
<ol><li>//验证数组形式插入数据的效果  </li><li>  </li><li>#include &lt;map&gt;  </li><li>  </li><li>#include &lt;string&gt;  </li><li>  </li><li>#include &lt;iostream&gt;  </li><li>  </li><li>using namespace std;  </li><li>  </li><li>int main()  </li><li>  </li><li>{  </li><li>  </li><li>    map&lt;int, string&gt; mapStudent;  </li><li>  </li><li>    mapStudent[1] = "student_one";  </li><li>  </li><li>    mapStudent[1] = "student_two";  </li><li>  </li><li>    mapStudent[2] = "student_three";  </li><li>  </li><li>    map&lt;int, string&gt;::iterator iter;  </li><li>  </li><li>    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </li><li>  </li><li>       cout&lt;&lt;iter-&gt;first&lt;&lt;' '&lt;&lt;iter-&gt;second&lt;&lt;endl;  </li><li>}  </li></ol> 
<p></p> 
<p></p> 
<p>6、      map的大小</p> 
<p></p> 
<p>在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数，用法如下：</p> 
<p></p> 
<p>Int nSize = mapStudent.size();</p> 
<p></p> 
<p></p> 
<p>7、     数据的遍历</p> 
<p></p> 
<p>这里也提供三种方法，对map进行遍历</p> 
<p></p> 
<p>第一种：应用前向迭代器，上面举例程序中到处都是了，略过不表</p> 
<p></p> 
<p>第二种：应用反相迭代器，下面举例说明，要体会效果，请自个动手运行程序</p> 
<p></p> 
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="view plain">view plain</a> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="copy">copy</a></p> 
<p></p> 
<ol><li>//第二种，利用反向迭代器  </li><li>  </li><li>#include &lt;map&gt;  </li><li>  </li><li>#include &lt;string&gt;  </li><li>  </li><li>#include &lt;iostream&gt;  </li><li>  </li><li>using namespace std;  </li><li>  </li><li>int main()  </li><li>  </li><li>{  </li><li>  </li><li>    map&lt;int, string&gt; mapStudent;  </li><li>  </li><li>    mapStudent.insert(pair&lt;int, string&gt;(1, "student_one"));  </li><li>  </li><li>    mapStudent.insert(pair&lt;int, string&gt;(2, "student_two"));  </li><li>  </li><li>    mapStudent.insert(pair&lt;int, string&gt;(3, "student_three"));  </li><li>  </li><li>    map&lt;int, string&gt;::reverse_iterator iter;  </li><li>  </li><li>    for(iter = mapStudent.rbegin(); iter != mapStudent.rend(); iter++)  </li><li>  </li><li>        cout&lt;&lt;iter-&gt;first&lt;&lt;"  "&lt;&lt;iter-&gt;second&lt;&lt;endl;  </li><li>  </li><li>}  </li></ol> 
<p></p> 
<p></p> 
<p>第三种，用数组的形式，程序说明如下：</p> 
<p></p> 
<p></p> 
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="view plain">view plain</a> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="copy">copy</a></p> 
<p></p> 
<ol><li>//第三种：用数组方式，程序说明如下  </li><li>  </li><li>#include &lt;map&gt;  </li><li>  </li><li>#include &lt;string&gt;  </li><li>  </li><li>#include &lt;iostream&gt;  </li><li>  </li><li>using namespace std;  </li><li>  </li><li>int main()  </li><li>  </li><li>{  </li><li>  </li><li>    map&lt;int, string&gt; mapStudent;  </li><li>  </li><li>    mapStudent.insert(pair&lt;int, string&gt;(1, "student_one"));  </li><li>  </li><li>    mapStudent.insert(pair&lt;int, string&gt;(2, "student_two"));  </li><li>  </li><li>    mapStudent.insert(pair&lt;int, string&gt;(3, "student_three"));  </li><li>  </li><li>    int nSize = mapStudent.size();  </li><li>  </li><li>//此处应注意，应该是 for(int nindex = 1; nindex &lt;= nSize; nindex++)  </li><li>//而不是 for(int nindex = 0; nindex &lt; nSize; nindex++)  </li><li>  </li><li>    for(int nindex = 1; nindex &lt;= nSize; nindex++)  </li><li>  </li><li>        cout&lt;&lt;mapStudent[nindex]&lt;&lt;endl;  </li><li>  </li><li>}  </li></ol> 
<p></p> 
<p></p> 
<p>8、    查找并获取map中的元素（包括判定这个关键字是否在map中出现）</p> 
<p></p> 
<p></p> 
<p>在这里我们将体会，map在数据插入时保证有序的好处。</p> 
<p></p> 
<p>要判定一个数据（关键字）是否在map中出现的方法比较多，这里标题虽然是数据的查找，在这里将穿插着大量的map基本用法。</p> 
<p></p> 
<p>这里给出三种数据查找方法</p> 
<p></p> 
<p>第一种：用count函数来判定关键字是否出现，其缺点是无法定位数据出现位置,由于map的特性，一对一的映射关系，就决定了count函数的返回值只有两个，要么是0，要么是1，出现的情况，当然是返回1了</p> 
<p></p> 
<p>第二种：用find函数来定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器。</p> 
<p><strong>查找map中是否包含某个关键字条目用find</strong>()<strong>方法，传入的参数是要查找的key，在这里需要提到的是begin</strong>()<strong>和end</strong>()两个成员，</p> 
<p>分别代表map对象中第一个条目和最后一个条目，这两个数据的类型是iterator.</p> 
<p></p> 
<p>程序说明</p> 
<p></p> 
<p></p> 
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="view plain">view plain</a> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="copy">copy</a></p> 
<p></p> 
<ol><li>#include &lt;map&gt;  </li><li>  </li><li>#include &lt;string&gt;  </li><li>  </li><li>#include &lt;iostream&gt;  </li><li>  </li><li>using namespace std;  </li><li>  </li><li>int main()  </li><li>  </li><li>{  </li><li>  </li><li>    map&lt;int, string&gt; mapStudent;  </li><li>  </li><li>    mapStudent.insert(pair&lt;int, string&gt;(1, "student_one"));  </li><li>  </li><li>    mapStudent.insert(pair&lt;int, string&gt;(2, "student_two"));  </li><li>  </li><li>    mapStudent.insert(pair&lt;int, string&gt;(3, "student_three"));  </li><li>  </li><li>    map&lt;int, string&gt;::iterator iter;  </li><li>  </li><li>    iter = mapStudent.find(1);  </li><li>  </li><li>    if(iter != mapStudent.end())  </li><li>  </li><li>       cout&lt;&lt;"Find, the value is "&lt;&lt;iter-&gt;second&lt;&lt;endl;  </li><li>  </li><li>    else  </li><li>  </li><li>       cout&lt;&lt;"Do not Find"&lt;&lt;endl;  </li><li>      </li><li>    return 0;  </li><li>}  </li></ol> 
<p><br> 通过map对象的方法获取的iterator数据类型是一个std::pair对象，包括两个数据 iterator-&gt;first和 iterator-&gt;second分别代表关键字和存储的数据。</p> 
<p></p> 
<p></p> 
<p></p> 
<p>第三种：这个方法用来判定数据是否出现，是显得笨了点，但是，我打算在这里讲解</p> 
<p></p> 
<p>lower_bound函数用法，这个函数用来返回要查找关键字的下界(是一个迭代器)</p> 
<p></p> 
<p>upper_bound函数用法，这个函数用来返回要查找关键字的上界(是一个迭代器)</p> 
<p></p> 
<p>例如：map中已经插入了1，2，3，4的话，如果lower_bound(2)的话，返回的2，而upper-bound（2）的话，返回的就是3</p> 
<p></p> 
<p>Equal_range函数返回一个pair，pair里面第一个变量是Lower_bound返回的迭代器，pair里面第二个迭代器是Upper_bound返回的迭代器，如果这两个迭代器相等的话，则说明map中不出现这个关键字，</p> 
<p>程序说明</p> 
<p></p> 
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="view plain">view plain</a> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="copy">copy</a></p> 
<p></p> 
<ol><li>#include &lt;map&gt;  </li><li>  </li><li>#include &lt;string&gt;  </li><li>  </li><li>#include &lt;iostream&gt;  </li><li>  </li><li>using namespace std;  </li><li>  </li><li>int main()  </li><li>  </li><li>{  </li><li>  </li><li>    map&lt;int, string&gt; mapStudent;  </li><li>  </li><li>    mapStudent[1] = "student_one";  </li><li>  </li><li>    mapStudent[3] = "student_three";  </li><li>  </li><li>    mapStudent[5] = "student_five";  </li><li>  </li><li>    map&lt;int, string&gt;::iterator iter;  </li><li>  </li><li>    iter = mapStudent.lower_bound(1);  </li><li>  </li><li>    //返回的是下界1的迭代器  </li><li>  </li><li>        cout&lt;&lt;iter-&gt;second&lt;&lt;endl;  </li><li>  </li><li>    iter = mapStudent.lower_bound(2);  </li><li>  </li><li>    //返回的是下界3的迭代器  </li><li>  </li><li>        cout&lt;&lt;iter-&gt;second&lt;&lt;endl;  </li><li>  </li><li>    iter = mapStudent.lower_bound(3);  </li><li>  </li><li>    //返回的是下界3的迭代器  </li><li>  </li><li>        cout&lt;&lt;iter-&gt;second&lt;&lt;endl;  </li><li>  </li><li>    iter = mapStudent.upper_bound(2);  </li><li>  </li><li>    //返回的是上界3的迭代器  </li><li>  </li><li>        cout&lt;&lt;iter-&gt;second&lt;&lt;endl;  </li><li>  </li><li>    iter = mapStudent.upper_bound(3);  </li><li>  </li><li>    //返回的是上界5的迭代器  </li><li>  </li><li>        cout&lt;&lt;iter-&gt;second&lt;&lt;endl;  </li><li>  </li><li>    pair&lt;map&lt;int, string&gt;::iterator, map&lt;int, string&gt;::iterator&gt; mappair;  </li><li>  </li><li>    mappair = mapStudent.equal_range(2);  </li><li>  </li><li>    if(mappair.first == mappair.second)  </li><li>  </li><li>        cout&lt;&lt;"Do not Find"&lt;&lt;endl;  </li><li>  </li><li>    else  </li><li>  </li><li>        cout&lt;&lt;"Find"&lt;&lt;endl;  </li><li>  </li><li>    mappair = mapStudent.equal_range(3);  </li><li>  </li><li>    if(mappair.first == mappair.second)  </li><li>  </li><li>        cout&lt;&lt;"Do not Find"&lt;&lt;endl;  </li><li>  </li><li>    else  </li><li>  </li><li>        cout&lt;&lt;"Find"&lt;&lt;endl;  </li><li>  </li><li>    return 0;  </li><li>}  </li></ol> 
<p><br> 9、    从map中删除元素</p> 
<p></p> 
<p></p> 
<p></p> 
<p>移除某个map中某个条目用erase（）</p> 
<p>该成员方法的定义如下：</p> 
<p>iterator erase（iterator it);//通过一个条目对象删除</p> 
<p>iterator erase（iterator first，iterator last）//删除一个范围</p> 
<p>size_type erase(const Key&amp;key);//通过关键字删除</p> 
<p>clear()就相当于enumMap.erase(enumMap.begin(),enumMap.end());</p> 
<p></p> 
<p>这里要用到erase函数，它有三个重载了的函数，下面在例子中详细说明它们的用法</p> 
<p></p> 
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="view plain">view plain</a> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="copy">copy</a></p> 
<p></p> 
<ol><li>#include &lt;map&gt;  </li><li>  </li><li>#include &lt;string&gt;  </li><li>  </li><li>#include &lt;iostream&gt;  </li><li>  </li><li>using namespace std;  </li><li>  </li><li>int main()  </li><li>  </li><li>{  </li><li>  </li><li>       map&lt;int, string&gt; mapStudent;  </li><li>  </li><li>       mapStudent.insert(pair&lt;int, string&gt;(1, "student_one"));  </li><li>  </li><li>       mapStudent.insert(pair&lt;int, string&gt;(2, "student_two"));  </li><li>  </li><li>       mapStudent.insert(pair&lt;int, string&gt;(3, "student_three"));  </li><li>  </li><li>        //如果你要演示输出效果，请选择以下的一种，你看到的效果会比较好  </li><li>  </li><li>       //如果要删除1,用迭代器删除  </li><li>  </li><li>       map&lt;int, string&gt;::iterator iter;  </li><li>  </li><li>       iter = mapStudent.find(1);  </li><li>  </li><li>       mapStudent.erase(iter);  </li><li>  </li><li>       //如果要删除1，用关键字删除  </li><li>  </li><li>       int n = mapStudent.erase(1);//如果删除了会返回1，否则返回0  </li><li>  </li><li>       //用迭代器，成片的删除  </li><li>  </li><li>       //一下代码把整个map清空  </li><li>  </li><li>       mapStudent.erase( mapStudent.begin(), mapStudent.end() );  </li><li>  </li><li>       //成片删除要注意的是，也是STL的特性，删除区间是一个前闭后开的集合  </li><li>  </li><li>       //自个加上遍历代码，打印输出吧  </li><li>  </li><li>}  </li></ol> 
<p><br> 10、    map中的swap用法</p> 
<p></p> 
<p>map中的swap不是一个容器中的元素交换，而是两个容器所有元素的交换。</p> 
<p></p> 
<p>11、     排序 ·  map中的sort问题</p> 
<p>map中的元素是自动按Key升序排序，所以不能对map用sort函数；</p> 
<p>这里要讲的是一点比较高深的用法了,排序问题，STL中默认是采用小于号来排序的，以上代码在排序上是不存在任何问题的，因为上面的关键字是int 型，它本身支持小于号运算，在一些特殊情况，比如关键字是一个结构体，涉及到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过 不去，下面给出两个方法解决这个问题。</p> 
<p></p> 
<p>第一种：小于号重载，程序举例。</p> 
<p></p> 
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="view plain">view plain</a> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="copy">copy</a></p> 
<p></p> 
<ol><li>#include &lt;iostream&gt;  </li><li>#include &lt;string&gt;  </li><li>#include &lt;map&gt;  </li><li>using namespace std;  </li><li>  </li><li>typedef struct tagStudentinfo  </li><li>  </li><li>{  </li><li>  </li><li>       int      niD;  </li><li>  </li><li>       string   strName;  </li><li>  </li><li>       bool operator &lt; (tagStudentinfo const&amp; _A) const  </li><li>  </li><li>       {     //这个函数指定排序策略，按niD排序，如果niD相等的话，按strName排序  </li><li>  </li><li>            if(niD &lt; _A.niD) return true;  </li><li>  </li><li>            if(niD == _A.niD)  </li><li>  </li><li>                return strName.compare(_A.strName) &lt; 0;  </li><li>  </li><li>        return false;  </li><li>  </li><li>       }  </li><li>  </li><li>}Studentinfo, *PStudentinfo; //学生信息  </li><li>  </li><li>int main()  </li><li>  </li><li>{  </li><li>  </li><li>    int nSize;   //用学生信息映射分数  </li><li>  </li><li>    map&lt;Studentinfo, int&gt;mapStudent;  </li><li>  </li><li>    map&lt;Studentinfo, int&gt;::iterator iter;  </li><li>  </li><li>    Studentinfo studentinfo;  </li><li>  </li><li>    studentinfo.niD = 1;  </li><li>  </li><li>    studentinfo.strName = "student_one";  </li><li>  </li><li>    mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 90));  </li><li>  </li><li>    studentinfo.niD = 2;  </li><li>  </li><li>    studentinfo.strName = "student_two";  </li><li>  </li><li>    mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 80));  </li><li>  </li><li>    for (iter=mapStudent.begin(); iter!=mapStudent.end(); iter++)  </li><li>  </li><li>        cout&lt;&lt;iter-&gt;first.niD&lt;&lt;' '&lt;&lt;iter-&gt;first.strName&lt;&lt;' '&lt;&lt;iter-&gt;second&lt;&lt;endl;  </li><li>  </li><li>    return 0;  </li><li>}  </li></ol> 
<p><br> 第二种：仿函数的应用，这个时候结构体中没有直接的小于号重载，程序说明</p> 
<p></p> 
<p></p> 
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="view plain">view plain</a> <a href="http://blog.csdn.net/shawn_hou/article/details/38035577#" title="copy">copy</a></p> 
<p></p> 
<ol><li>//第二种：仿函数的应用，这个时候结构体中没有直接的小于号重载，程序说明  </li><li>  </li><li>#include &lt;iostream&gt;  </li><li>  </li><li>#include &lt;map&gt;  </li><li>  </li><li>#include &lt;string&gt;  </li><li>  </li><li>using namespace std;  </li><li>  </li><li>typedef struct tagStudentinfo  </li><li>  </li><li>{  </li><li>  </li><li>       int      niD;  </li><li>  </li><li>       string   strName;  </li><li>  </li><li>}Studentinfo, *PStudentinfo; //学生信息  </li><li>  </li><li>class sort  </li><li>  </li><li>{  </li><li>  </li><li>public:  </li><li>  </li><li>    bool operator() (Studentinfo const &amp;_A, Studentinfo const &amp;_B) const  </li><li>  </li><li>    {  </li><li>  </li><li>        if(_A.niD &lt; _B.niD)  </li><li>  </li><li>            return true;  </li><li>  </li><li>        if(_A.niD == _B.niD)  </li><li>  </li><li>            return _A.strName.compare(_B.strName) &lt; 0;  </li><li>  </li><li>    return false;  </li><li>  </li><li>    }  </li><li>};  </li><li>  </li><li>int main()  </li><li>  </li><li>{   //用学生信息映射分数  </li><li>  </li><li>    map&lt;Studentinfo, int, sort&gt;mapStudent;  </li><li>  </li><li>    map&lt;Studentinfo, int&gt;::iterator iter;  </li><li>  </li><li>    Studentinfo studentinfo;  </li><li>  </li><li>    studentinfo.niD = 1;  </li><li>  </li><li>    studentinfo.strName = "student_one";  </li><li>  </li><li>    mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 90));  </li><li>  </li><li>    studentinfo.niD = 2;  </li><li>  </li><li>    studentinfo.strName = "student_two";  </li><li>  </li><li>    mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 80));  </li><li>  </li><li>    for (iter=mapStudent.begin(); iter!=mapStudent.end(); iter++)  </li><li>  </li><li>        cout&lt;&lt;iter-&gt;first.niD&lt;&lt;' '&lt;&lt;iter-&gt;first.strName&lt;&lt;' '&lt;&lt;iter-&gt;second&lt;&lt;endl;  </li><li>}  </li></ol> 
<p></p> 
<p></p> 
<p>由于STL是一个统一的整体，map的很多用法都和STL中其它的东西结合在一起，比如在排序上，这里默认用的是小于号，即less&lt;&gt;，如果要从大到小排序呢，这里涉及到的东西很多，在此无法一一加以说明。</p> 
<p></p> 
<p>还要说明的是，map中由于它内部有序，由红黑树保证，因此很多函数执行的时间复杂度都是log2N的，如果用map函数可以实现的功能，而STL Algorithm也可以完成该功能，建议用map自带函数，效率高一些。</p> 
<p></p> 
<p>下面说下，map在空间上的特性，否则，估计你用起来会有时候表现的比较郁闷，由于map的每个数据对应红黑树上的一个节点，这个节点在不保存你的 数据时，是占用16个字节的，一个父节点指针，左右孩子指针，还有一个枚举值（标示红黑的，相当于平衡二叉树中的平衡因子），我想大家应该知道，这些地方 很费内存了吧，不说了……</p> 
<p></p> 
<p></p> 
<h2 style="background-color:transparent;">四、map应用实例</h2> 
<p></p> 
<p>1、P3613 【深基15.例2】寄包柜</p> 
<p>１、水果：</p> 
<p>夏天来了~~好开心啊,呵呵,好多好多水果~~，Joe经营着一个不大的水果店.他认为生存之道就是经营最受顾客欢迎的水果.现在他想要一份水果销售情况的明细表,　这样Joe就可以很容易掌握所有水果的销售情况了.</p> 
<p><strong>输入：</strong>第一行正整数N(0&lt;N&lt;=10)表示有N组测试数据，每组测试数据的第一行是一个整数M(0&lt;M&lt;=100),表示工有M次成功的交易.其后有M行数据,每行表示一次交易　，由水果名称(小写字母组成　，长度不超过80),水果产地(小写字母组成,长度不超过80)和交易的水果数目(正整数,不超过100)组成.</p> 
<p><strong>输出：</strong>对于每一组测试数据,请你输出一份排版格式正确(请分析样本输出)的水果销售情况明细表.这份明细表包括所有水果的产地,名称和销售数目的信息.水果先按产地分类,产地按字母顺序排列;同一产地的水果按照名称排序,名称按字母顺序排序.<br> 两组测试数据之间有一个空行.最后一组测试数据之后没有空行.</p> 
<p><strong>输入样式：</strong></p> 
<p style="margin-left:0cm;">1</p> 
<p style="margin-left:0cm;">5</p> 
<p style="margin-left:0cm;">apple shandong 3</p> 
<p style="margin-left:0cm;">pineapple guangdong 1</p> 
<p style="margin-left:0cm;">sugarcane guangdong 1</p> 
<p style="margin-left:0cm;">pineapple guangdong 3</p> 
<p style="margin-left:0cm;">pineapple guangdong 1</p> 
<p style="margin-left:0cm;"></p> 
<p><strong>输出样式：</strong></p> 
<p style="margin-left:0cm;">guangdong</p> 
<p style="margin-left:0cm;">   |----pineapple(5)</p> 
<p style="margin-left:0cm;">   |----sugarcane(1)</p> 
<p style="margin-left:0cm;">shandong</p> 
<p style="margin-left:0cm;">   |----apple(3)</p> 
<pre class="has"><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
list&lt;int&gt; all[10005];
int main()
{   map&lt;string,map&lt;string,int&gt; &gt; p;
    map&lt;string,int&gt; q;
    map&lt;string,map&lt;string,int&gt; &gt;::iterator i;
    map&lt;string,int&gt;::iterator j;
    int n,m,t;
    string str1,str2;
    cin&gt;&gt;n;
    while(n--)
    {
        p.clear();
        q.clear();
        cin&gt;&gt;m;
        while(m--)
        {
            cin&gt;&gt;str1&gt;&gt;str2&gt;&gt;t;
            p[str2][str1]+=t;
        }
        for(i=p.begin();i!=p.end();i++)
        {
            cout&lt;&lt;i-&gt;first&lt;&lt;endl;
            q=i-&gt;second;
            for(j=q.begin();j!=q.end();j++)
                cout&lt;&lt;"   |----"&lt;&lt;j-&gt;first&lt;&lt;"("&lt;&lt;j-&gt;second&lt;&lt;")"&lt;&lt;endl;
        }
        if(n)
            cout&lt;&lt;endl;
    }
}</code></pre> 
<p>HDU1075<br>   这个题目是对字符串的处理（用字典树也可以），具体就是会判断初始终止条件，熟练运用map容器，但是显然我还做不到，会继续学习STL，我要和你混熟</p> 
<p><br> #include&lt;iostream&gt;<br> #include&lt;string&gt;<br> #include&lt;map&gt;<br> using namespace std;<br> //const int N 3005;<br> map&lt;string,string&gt; mapp;<br> bool Char(char ch)<br> {<!-- --><br>     if(ch&gt;='a'&amp;&amp;ch&lt;='z')<br>         return true;<br>     return false;<br> }<br> int main()<br> {<!-- --><br>     string str1,str2;<br>     cin&gt;&gt;str1;//忽略start<br>     while(cin&gt;&gt;str1)<br>     {<!-- --><br>         if(str1=="END") break;<br>         cin&gt;&gt;str2;<br>         mapp[str2]=str1;<br>     }<br>     cin&gt;&gt;str1;<br>     getline(cin,str1);<br>     while(getline(cin,str1))<br>     {<!-- --><br>         str2="";//空<br>         if(str1=="END")  break;<br>         for(int i=0;i&lt;str1.size();i++)<br>         {<!-- --><br>             if(Char(str1[i]))//如果是字母的话就存上<br>                 str2+=str1[i];<br>             else<br>             {<!-- --><br>                 if(mapp[str2]!="")<br>                     cout&lt;&lt;mapp[str2];<br>                 else<br>                     cout&lt;&lt;str2;<br>                 cout&lt;&lt;str1[i];<br>                 str2="";<br>             }<br>         }<br>         cout&lt;&lt;endl;<br>     }<br>     return 0;<br> }</p> 
<p>HDU 1004(非STL解法见1004传送门）</p> 
<p><br> #include&lt;iostream&gt;<br> #include&lt;map&gt;<br> #include&lt;string&gt;<br> using namespace std;<br> int main()<br> {<!-- --><br>     int n;<br>     string str;<br>     while(cin&gt;&gt;n,n)<br>     {<!-- --><br>         map&lt;string,int&gt;mapp;<br>         map&lt;string,int&gt;:: iterator pr;<br>         for(int i=0;i&lt;n;i++)<br>         {<!-- --><br>             cin&gt;&gt;str;<br>             mapp[str]++;//将元素存入map容器中<br>         }<br>         int maxn=0;<br>         for(pr = mapp.begin();pr != mapp.end();pr++)<br>         {<!-- --><br>             if(pr-&gt;second &gt; maxn)<br>             {<!-- --><br>                 maxn = pr-&gt;second;<br>                 str = pr-&gt;first;<br>             }<br>         }<br>         cout&lt;&lt;str&lt;&lt;endl;<br>     }<br>     return 0;<br> }</p> 
<p></p> 
<p>ZOJ 2724</p> 
<p>用结构体存储各元素，优先队列存储存储结构体</p> 
<p>#include&lt;iostream&gt;//zoj 2724<br> #include&lt;queue&gt;<br> #include&lt;string&gt;<br> #include&lt;cstdio&gt;<br> using namespace std;<br> struct Compare<br> {<!-- --><br>     char str[30];<br>     int m;<br>     int pr;//优先级<br>     friend bool operator &lt;(Compare a,Compare b)<br>     {<!-- --><br>         return a.pr&gt;b.pr;<br>     }<br> };<br> priority_queue&lt;Compare&gt;it;<br> int main()<br> {<!-- --><br>     Compare pluss;<br>     string str1;<br>     while(cin&gt;&gt;str1)<br>     {<!-- --><br>         if(str1=="GET")<br>         {<!-- --><br>             if(it.empty())<br>             {<!-- --><br>                 cout&lt;&lt;"EMPTY QUEUE!"&lt;&lt;endl;<br>                 continue;<br>             }<br>             pluss=it.top();<br>             it.pop();//移除这个元素<br>             cout&lt;&lt;pluss.str&lt;&lt;" "&lt;&lt;pluss.m&lt;&lt;endl;<br>         }<br>         if(str1=="PUT")<br>         {<!-- --><br>             scanf("%s%d%d",pluss.str,&amp;pluss.m,&amp;pluss.pr);<br>             it.push(pluss);<br>         }<br>     }<br>     return 0;<br> }<br>  </p> 
<p>HDU1004   Let the Balloon Rise<br> Description</p> 
<p>在ACM比赛中，你每解决一道题，你就可以获得一个气球，不同颜色的气球代表你解决了不同的问题。在WJL同学参加的一场ACM比赛中，他发现场面上有N个气球，并熟练的说出了气球的颜色。</p> 
<p>请你编写一个程序，找出气球数量最多的颜色。</p> 
<p>Input</p> 
<p>有多组样例输入。</p> 
<p>每组样例第一行输入一个整数N (0 &lt; N &lt;= 1000) ，代表一共有N个气球。若N=0，则代表输入结束，你不需要输出任何信息。<br> 接下来N行每行输入一个不多于15个字母的字符串代表颜色。</p> 
<p>Output</p> 
<p>对于每组样例数据，在单独的一行内输出数量最多的那种颜色的气球。（数据保证输出是唯一的） </p> 
<p>Sample Input</p> 
<p>5<br> green<br> red<br> blue<br> red<br> red<br> 3<br> pink<br> orange<br> pink<br> 0<br> Sample Output</p> 
<p>red<br> pink<br> #include&lt;stdio.h&gt;<br> #include&lt;map&gt;<br> #include&lt;string&gt;<br> #include&lt;iostream&gt;<br> using namespace std;<br> typedef pair&lt;string,int&gt; psi;<br> int main()<br> {<!-- --><br>     int n;<br>     while(cin&gt;&gt;n,n){<!-- --><br>         map&lt;string,int&gt;ma;<br>         map&lt;string,int&gt;::iterator x;<br>         map&lt;string,int&gt;::iterator y;<br>         for(int i=0;i&lt;n;i++){<!-- --><br>             char str[20];<br>             cin&gt;&gt;str;<br>             x=ma.find(str);//返回被查找元素的位置，没有则返回ma.end(),第一次肯定没有,所以下面用pair添上<br>             if(x==ma.end())<br>                 ma.insert(psi(str,1));<br>             else<br>                 ma[str]++; //str是key,ma[key]返回的是value,但不能写成ma[value],这样写也不会返回key<br>         }<br>         int MAX=0;<br>         for(x=ma.begin();x!=ma.end();x++){<!-- --><br>             if(x-&gt;second &gt;= MAX){ //x-&gt;second,这里的second代表value,整体表示value<br>                 MAX = x-&gt;second;<br>                 y=x;<br>             }<br>         }<br>         cout&lt;&lt;y-&gt;first&lt;&lt;endl;//这里的first代表key<br>     }<br>     return 0;<br> }<br>  </p> 
<p></p> 
<p></p> 
<p></p> 
<table align="center" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p></p> </td></tr></tbody></table>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6f237be2a04c1124a4fc3606117f1320/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用idea23做简单的javaweb项目（servlet）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/66d56cc703a903ad4325c1c2b5088742/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STL详解（二） 栈容器Stack</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>