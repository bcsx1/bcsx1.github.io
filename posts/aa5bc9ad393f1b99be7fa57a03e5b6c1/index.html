<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>10-锁（synchronized和Lock） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="10-锁（synchronized和Lock）" />
<meta property="og:description" content="目录
1.内置锁：synchronized（JVM中内置了）
1.1.synchronized基本用法
1.1.1.修饰静态方法（锁粒度太大，用得少）（不能修饰静态变量）
---&gt;PS：上述代码中synchronized是如何保证线程安全问题的？
1.1.2.修饰普通方法（锁粒度太大，用得少）
1.1.3.修饰代码块（最常用）
---&gt;PS：3种常用场景：
1.2.synchronized特性
1.2.1.互斥性/排他性
---&gt;PS：公平锁 VS 非公平锁
1.2.2.刷新内存
1.2.3.可重入性
1.3.synchronized实现原理
（面试必问）synchronized是如何实现的？
1.3.1.监视器
1.3.2.底层实现
1.3.3.执行流程
1.4.synchronized历史发展进程
2.可重入锁/手动锁：Lock（Lock是一个接口,通常所说的可重入锁是指Lock的一个实现子类ReentrantLock)
2.1.Lock实现步骤：
①创建锁对象Lock lock = new ReentrantLock();
②加锁lock.lock();
③释放锁lock.unlock();
---&gt;注意事项：
a.unlock()一定要放在finally里，否则可能导致锁资源永久占用问题。
b.lock()要放到try外（官方建议）或try中的首行（问题不大）。
2.2.Lock指定锁类型——公平锁和非公平锁
3.（面试必问）synchronized VS Lock（ReentrantLock）
①Lock 更灵活，有更多的方法，比如tryLock()。粒度可以更小（不明显）。
②Lock（接口级别）需要开发者手动操作锁（加/释放）；而 synchronized 是 JVM 层面提供的锁，自动进行加锁和释放锁操作，对于开发者是无感的。
③Lock 只能修饰代码块；而 synchronized 可以修饰普通方法、静态方法和代码块。
④锁类型不同：Lock 默认是非公平锁，但可以指定为公平锁；而 synchronized 只能是非公平锁。
⑤调用Lock和synchronized线程等待锁的状态不同：lock会变为WAITING；而synchronized会变为BLOCKED。
使用锁（最主要有以下2种）是Java中解决线程安全问题最主要的手段 。
1.内置锁：synchronized（JVM中内置了） 1.1.synchronized基本用法 1.1.1.修饰静态方法（锁粒度太大，用得少）（不能修饰静态变量） public class ThreadSynchronized { //变量 private static int number = 0; static class Counter{ //循环次数 private static int MAX_COUNT = 1000000; //&#43;&#43;方法 public synchronized static void incr() { for (int i = 0; i &lt; MAX_COUNT; i&#43;&#43;) { number&#43;&#43;; } } //--方法 public synchronized static void decr() { for (int i = 0; i &lt; MAX_COUNT; i&#43;&#43;) { number--; } } } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { Counter." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/aa5bc9ad393f1b99be7fa57a03e5b6c1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-29T16:51:22+08:00" />
<meta property="article:modified_time" content="2023-08-29T16:51:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">10-锁（synchronized和Lock）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E5%86%85%E7%BD%AE%E9%94%81%EF%BC%9Asynchronized%EF%BC%88JVM%E4%B8%AD%E5%86%85%E7%BD%AE%E4%BA%86%EF%BC%89-toc" style="margin-left:0px;"><a href="#1.%E5%86%85%E7%BD%AE%E9%94%81%EF%BC%9Asynchronized%EF%BC%88JVM%E4%B8%AD%E5%86%85%E7%BD%AE%E4%BA%86%EF%BC%89" rel="nofollow">1.内置锁：synchronized（JVM中内置了）</a></p> 
<p id="1.1.synchronized%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#1.1.synchronized%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" rel="nofollow">1.1.synchronized基本用法</a></p> 
<p id="1.1.1.%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%88%E9%94%81%E7%B2%92%E5%BA%A6%E5%A4%AA%E5%A4%A7%EF%BC%8C%E7%94%A8%E5%BE%97%E5%B0%91%EF%BC%89%EF%BC%88%E4%B8%8D%E8%83%BD%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.1.1.%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%88%E9%94%81%E7%B2%92%E5%BA%A6%E5%A4%AA%E5%A4%A7%EF%BC%8C%E7%94%A8%E5%BE%97%E5%B0%91%EF%BC%89%EF%BC%88%E4%B8%8D%E8%83%BD%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%89" rel="nofollow">1.1.1.修饰静态方法（锁粒度太大，用得少）（不能修饰静态变量）</a></p> 
<p id="---%3EPS%EF%BC%9A%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E4%B8%ADsynchronized%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F-toc" style="margin-left:80px;"><a href="#---%3EPS%EF%BC%9A%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E4%B8%ADsynchronized%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F" rel="nofollow">---&gt;PS：上述代码中synchronized是如何保证线程安全问题的？</a></p> 
<p id="1.1.2.%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%EF%BC%88%E9%94%81%E7%B2%92%E5%BA%A6%E5%A4%AA%E5%A4%A7%EF%BC%8C%E7%94%A8%E5%BE%97%E5%B0%91%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.1.2.%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%EF%BC%88%E9%94%81%E7%B2%92%E5%BA%A6%E5%A4%AA%E5%A4%A7%EF%BC%8C%E7%94%A8%E5%BE%97%E5%B0%91%EF%BC%89" rel="nofollow">1.1.2.修饰普通方法（锁粒度太大，用得少）</a></p> 
<p id="1.1.3.%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.1.3.%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89" rel="nofollow">1.1.3.修饰代码块（最常用）</a></p> 
<p id="---%3EPS%EF%BC%9A3%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-toc" style="margin-left:80px;"><a href="#---%3EPS%EF%BC%9A3%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A" rel="nofollow">---&gt;PS：3种常用场景：</a></p> 
<p id="1.2.synchronized%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#1.2.synchronized%E7%89%B9%E6%80%A7" rel="nofollow">1.2.synchronized特性</a></p> 
<p id="1.2.1.%E4%BA%92%E6%96%A5%E6%80%A7%2F%E6%8E%92%E4%BB%96%E6%80%A7-toc" style="margin-left:80px;"><a href="#1.2.1.%E4%BA%92%E6%96%A5%E6%80%A7%2F%E6%8E%92%E4%BB%96%E6%80%A7" rel="nofollow">1.2.1.互斥性/排他性</a></p> 
<p id="---%3EPS%EF%BC%9A%E5%85%AC%E5%B9%B3%E9%94%81%20VS%20%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81-toc" style="margin-left:80px;"><a href="#---%3EPS%EF%BC%9A%E5%85%AC%E5%B9%B3%E9%94%81%20VS%20%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81" rel="nofollow">---&gt;PS：公平锁 VS 非公平锁</a></p> 
<p id="1.2.2.%E5%88%B7%E6%96%B0%E5%86%85%E5%AD%98-toc" style="margin-left:80px;"><a href="#1.2.2.%E5%88%B7%E6%96%B0%E5%86%85%E5%AD%98" rel="nofollow">1.2.2.刷新内存</a></p> 
<p id="1.2.3.%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7-toc" style="margin-left:80px;"><a href="#1.2.3.%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7" rel="nofollow">1.2.3.可重入性</a></p> 
<p id="1.3.synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#1.3.synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" rel="nofollow">1.3.synchronized实现原理</a></p> 
<p id="%EF%BC%88%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%EF%BC%89synchronized%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%EF%BC%89synchronized%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F" rel="nofollow">（面试必问）synchronized是如何实现的？</a></p> 
<p id="1.3.1.%E7%9B%91%E8%A7%86%E5%99%A8-toc" style="margin-left:80px;"><a href="#1.3.1.%E7%9B%91%E8%A7%86%E5%99%A8" rel="nofollow">1.3.1.监视器</a></p> 
<p id="1.3.2.%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#1.3.2.%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0" rel="nofollow">1.3.2.底层实现</a></p> 
<p id="1.3.3.%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-toc" style="margin-left:80px;"><a href="#1.3.3.%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B" rel="nofollow">1.3.3.执行流程</a></p> 
<p id="1.4.synchronized%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95%E8%BF%9B%E7%A8%8B-toc" style="margin-left:40px;"><a href="#1.4.synchronized%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95%E8%BF%9B%E7%A8%8B" rel="nofollow">1.4.synchronized历史发展进程</a></p> 
<p id="2.%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%2F%E6%89%8B%E5%8A%A8%E9%94%81%EF%BC%9ALock%EF%BC%88Lock%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%2C%E9%80%9A%E5%B8%B8%E6%89%80%E8%AF%B4%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E6%98%AF%E6%8C%87Lock%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0%E5%AD%90%E7%B1%BBReentrantLock)-toc" style="margin-left:0px;"><a href="#2.%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%2F%E6%89%8B%E5%8A%A8%E9%94%81%EF%BC%9ALock%EF%BC%88Lock%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%2C%E9%80%9A%E5%B8%B8%E6%89%80%E8%AF%B4%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E6%98%AF%E6%8C%87Lock%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0%E5%AD%90%E7%B1%BBReentrantLock%29" rel="nofollow">2.可重入锁/手动锁：Lock（Lock是一个接口,通常所说的可重入锁是指Lock的一个实现子类ReentrantLock)</a></p> 
<p id="2.1.Lock%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2.1.Lock%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A" rel="nofollow">2.1.Lock实现步骤：</a></p> 
<p id="%E2%91%A0%E5%88%9B%E5%BB%BA%E9%94%81%E5%AF%B9%E8%B1%A1Lock%20lock%20%3D%20new%20ReentrantLock()%3B-toc" style="margin-left:80px;"><a href="#%E2%91%A0%E5%88%9B%E5%BB%BA%E9%94%81%E5%AF%B9%E8%B1%A1Lock%20lock%20%3D%20new%20ReentrantLock%28%29%3B" rel="nofollow">①创建锁对象Lock lock = new ReentrantLock();</a></p> 
<p id="%E2%91%A1%E5%8A%A0%E9%94%81lock.lock()%3B-toc" style="margin-left:80px;"><a href="#%E2%91%A1%E5%8A%A0%E9%94%81lock.lock%28%29%3B" rel="nofollow">②加锁lock.lock();</a></p> 
<p id="%E2%91%A2%E9%87%8A%E6%94%BE%E9%94%81lock.unlock()%3B-toc" style="margin-left:80px;"><a href="#%E2%91%A2%E9%87%8A%E6%94%BE%E9%94%81lock.unlock%28%29%3B" rel="nofollow">③释放锁lock.unlock();</a></p> 
<p id="---%3E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#---%3E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A" rel="nofollow">---&gt;注意事项：</a></p> 
<p id="a.unlock()%E4%B8%80%E5%AE%9A%E8%A6%81%E6%94%BE%E5%9C%A8finally%E9%87%8C%EF%BC%8C%E5%90%A6%E5%88%99%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E9%94%81%E8%B5%84%E6%BA%90%E6%B0%B8%E4%B9%85%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%E3%80%82-toc" style="margin-left:80px;"><a href="#a.unlock%28%29%E4%B8%80%E5%AE%9A%E8%A6%81%E6%94%BE%E5%9C%A8finally%E9%87%8C%EF%BC%8C%E5%90%A6%E5%88%99%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E9%94%81%E8%B5%84%E6%BA%90%E6%B0%B8%E4%B9%85%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%E3%80%82" rel="nofollow">a.unlock()一定要放在finally里，否则可能导致锁资源永久占用问题。</a></p> 
<p id="b.lock()%E8%A6%81%E6%94%BE%E5%88%B0try%E5%A4%96%EF%BC%88%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%EF%BC%89%E6%88%96try%E4%B8%AD%E7%9A%84%E9%A6%96%E8%A1%8C%EF%BC%88%E9%97%AE%E9%A2%98%E4%B8%8D%E5%A4%A7%EF%BC%89%E3%80%82-toc" style="margin-left:80px;"><a href="#b.lock%28%29%E8%A6%81%E6%94%BE%E5%88%B0try%E5%A4%96%EF%BC%88%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%EF%BC%89%E6%88%96try%E4%B8%AD%E7%9A%84%E9%A6%96%E8%A1%8C%EF%BC%88%E9%97%AE%E9%A2%98%E4%B8%8D%E5%A4%A7%EF%BC%89%E3%80%82" rel="nofollow">b.lock()要放到try外（官方建议）或try中的首行（问题不大）。</a></p> 
<p id="2.2.Lock%E6%8C%87%E5%AE%9A%E9%94%81%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81-toc" style="margin-left:40px;"><a href="#2.2.Lock%E6%8C%87%E5%AE%9A%E9%94%81%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81" rel="nofollow">2.2.Lock指定锁类型——公平锁和非公平锁</a></p> 
<p id="3.%EF%BC%88%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%EF%BC%89synchronized%20VS%20Lock%EF%BC%88ReentrantLock%EF%BC%89-toc" style="margin-left:0px;"><a href="#3.%EF%BC%88%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%EF%BC%89synchronized%20VS%20Lock%EF%BC%88ReentrantLock%EF%BC%89" rel="nofollow">3.（面试必问）synchronized VS Lock（ReentrantLock）</a></p> 
<p id="%E2%91%A0Lock%20%E6%9B%B4%E7%81%B5%E6%B4%BB%EF%BC%8C%E6%9C%89%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E6%AF%94%E5%A6%82tryLock()%EF%BC%9B%E7%B2%92%E5%BA%A6%E5%8F%AF%E4%BB%A5%E6%9B%B4%E5%B0%8F%EF%BC%88%E4%B8%8D%E6%98%8E%E6%98%BE%EF%BC%89%E3%80%82-toc" style="margin-left:40px;"><a href="#%E2%91%A0Lock%20%E6%9B%B4%E7%81%B5%E6%B4%BB%EF%BC%8C%E6%9C%89%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E6%AF%94%E5%A6%82tryLock%28%29%EF%BC%9B%E7%B2%92%E5%BA%A6%E5%8F%AF%E4%BB%A5%E6%9B%B4%E5%B0%8F%EF%BC%88%E4%B8%8D%E6%98%8E%E6%98%BE%EF%BC%89%E3%80%82" rel="nofollow">①Lock 更灵活，有更多的方法，比如tryLock()。粒度可以更小（不明显）。</a></p> 
<p id="%E2%91%A1Lock%EF%BC%88%E6%8E%A5%E5%8F%A3%E7%BA%A7%E5%88%AB%EF%BC%89%E9%9C%80%E8%A6%81%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%8A%A8%E6%93%8D%E4%BD%9C%E9%94%81%EF%BC%88%E5%8A%A0%2F%E9%87%8A%E6%94%BE%EF%BC%89%EF%BC%8C%E8%80%8C%20Synchronized%20%E6%98%AF%20JVM%20%E5%B1%82%E9%9D%A2%E6%8F%90%E4%BE%9B%E7%9A%84%E9%94%81%EF%BC%8C%E8%87%AA%E5%8A%A8%E8%BF%9B%E8%A1%8C%E5%8A%A0%E9%94%81%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%AF%B9%E4%BA%8E%E5%BC%80%E5%8F%91%E8%80%85%E6%98%AF%E6%97%A0%E6%84%9F%E7%9A%84%E3%80%82-toc" style="margin-left:40px;"><a href="#%E2%91%A1Lock%EF%BC%88%E6%8E%A5%E5%8F%A3%E7%BA%A7%E5%88%AB%EF%BC%89%E9%9C%80%E8%A6%81%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%8A%A8%E6%93%8D%E4%BD%9C%E9%94%81%EF%BC%88%E5%8A%A0%2F%E9%87%8A%E6%94%BE%EF%BC%89%EF%BC%8C%E8%80%8C%20Synchronized%20%E6%98%AF%20JVM%20%E5%B1%82%E9%9D%A2%E6%8F%90%E4%BE%9B%E7%9A%84%E9%94%81%EF%BC%8C%E8%87%AA%E5%8A%A8%E8%BF%9B%E8%A1%8C%E5%8A%A0%E9%94%81%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%AF%B9%E4%BA%8E%E5%BC%80%E5%8F%91%E8%80%85%E6%98%AF%E6%97%A0%E6%84%9F%E7%9A%84%E3%80%82" rel="nofollow">②Lock（接口级别）需要开发者手动操作锁（加/释放）；而 synchronized 是 JVM 层面提供的锁，自动进行加锁和释放锁操作，对于开发者是无感的。</a></p> 
<p id="%E2%91%A2Lock%20%E5%8F%AA%E8%83%BD%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E8%80%8C%20Synchronized%20%E5%8F%AF%E4%BB%A5%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%82-toc" style="margin-left:40px;"><a href="#%E2%91%A2Lock%20%E5%8F%AA%E8%83%BD%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E8%80%8C%20Synchronized%20%E5%8F%AF%E4%BB%A5%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%82" rel="nofollow">③Lock 只能修饰代码块；而 synchronized 可以修饰普通方法、静态方法和代码块。</a></p> 
<p id="%E2%91%A3%E9%94%81%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%EF%BC%9ALock%20%E9%BB%98%E8%AE%A4%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E4%BD%86%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E4%B8%BA%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E8%80%8C%20Synchronized%20%E5%8F%AA%E8%83%BD%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E3%80%82-toc" style="margin-left:40px;"><a href="#%E2%91%A3%E9%94%81%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%EF%BC%9ALock%20%E9%BB%98%E8%AE%A4%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E4%BD%86%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E4%B8%BA%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E8%80%8C%20Synchronized%20%E5%8F%AA%E8%83%BD%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E3%80%82" rel="nofollow">④锁类型不同：Lock 默认是非公平锁，但可以指定为公平锁；而 synchronized 只能是非公平锁。</a></p> 
<p id="%E2%91%A4%E8%B0%83%E7%94%A8Lock%E5%92%8Csynchronized%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8D%E5%90%8C%EF%BC%9Alock%E4%BC%9A%E5%8F%98%E4%B8%BAWAITING%EF%BC%8C%E8%80%8Csynchronized%E4%BC%9A%E5%8F%98%E4%B8%BABLOCKED%E3%80%82-toc" style="margin-left:40px;"><a href="#%E2%91%A4%E8%B0%83%E7%94%A8Lock%E5%92%8Csynchronized%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8D%E5%90%8C%EF%BC%9Alock%E4%BC%9A%E5%8F%98%E4%B8%BAWAITING%EF%BC%8C%E8%80%8Csynchronized%E4%BC%9A%E5%8F%98%E4%B8%BABLOCKED%E3%80%82" rel="nofollow">⑤调用Lock和synchronized线程等待锁的状态不同：lock会变为WAITING；而synchronized会变为BLOCKED。</a></p> 
<hr id="hr-toc"> 
<p>使用<strong>锁</strong>（最主要有以下2种）是Java中<strong>解决线程安全问题</strong>最主要的手段 。</p> 
<h2 id="1.%E5%86%85%E7%BD%AE%E9%94%81%EF%BC%9Asynchronized%EF%BC%88JVM%E4%B8%AD%E5%86%85%E7%BD%AE%E4%BA%86%EF%BC%89">1.内置锁：synchronized（JVM中内置了）</h2> 
<h3 id="1.1.synchronized%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">1.1.synchronized基本用法</h3> 
<h4 id="1.1.1.%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%88%E9%94%81%E7%B2%92%E5%BA%A6%E5%A4%AA%E5%A4%A7%EF%BC%8C%E7%94%A8%E5%BE%97%E5%B0%91%EF%BC%89%EF%BC%88%E4%B8%8D%E8%83%BD%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%89">1.1.1.修饰静态方法（锁粒度太大，用得少）（不能修饰静态变量）</h4> 
<pre><code class="language-java">public class ThreadSynchronized {
    //变量
    private static int number = 0;

    static class Counter{
        //循环次数
        private static int MAX_COUNT = 1000000;

        //++方法
        public synchronized static void incr() {
            for (int i = 0; i &lt; MAX_COUNT; i++) {
                number++;
            }
        }

        //--方法
        public synchronized static void decr() {
            for (int i = 0; i &lt; MAX_COUNT; i++) {
                number--;
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -&gt; {
            Counter.incr();
        });
        t1.start();

        Thread t2 = new Thread(() -&gt; {
            Counter.decr();
        });
        t2.start();

        t1.join();
        t2.join();
        System.out.println("最终的结果：" + number);
    }
}
</code></pre> 
<p><img alt="" height="104" src="https://images2.imgbox.com/6f/f7/i4JlVLuI_o.png" width="450"></p> 
<blockquote> 
 <h4 id="---%3EPS%EF%BC%9A%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E4%B8%ADsynchronized%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><strong>---&gt;PS：上述代码中synchronized是如何保证线程安全问题的？</strong></h4> 
 <p><img alt="" height="225" src="https://images2.imgbox.com/3f/fb/EYULEAw3_o.png" width="500"></p> 
 <ul><li>当使用synchronized给整个方法加锁时，其效率极低，甚至比单线程还慢。</li><li>性能的好坏取决于synchronized修饰的范围，范围越大，安全性越高，性能越低；反之，锁的粒度越小，修饰的代码越少，安全性越低，性能越高。</li></ul> 
</blockquote> 
<h4 id="1.1.2.%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%EF%BC%88%E9%94%81%E7%B2%92%E5%BA%A6%E5%A4%AA%E5%A4%A7%EF%BC%8C%E7%94%A8%E5%BE%97%E5%B0%91%EF%BC%89">1.1.2.修饰普通方法（锁粒度太大，用得少）</h4> 
<pre><code class="language-java">public class ThreadSynchronized2 {
    //变量
    private static int number = 0;

    static class Counter{
        //循环次数
        private static int MAX_COUNT = 1000000;

        //++方法
        public synchronized void incr() {
            for (int i = 0; i &lt; MAX_COUNT; i++) {
                number++;
            }
        }

        //--方法
        public synchronized void decr() {
            for (int i = 0; i &lt; MAX_COUNT; i++) {
                number--;
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        Thread t1 = new Thread(() -&gt; {
            counter.incr();
        });
        t1.start();

        Thread t2 = new Thread(() -&gt; {
            counter.decr();
        });
        t2.start();

        t1.join();
        t2.join();
        System.out.println("最终的结果：" + number);
    }
}
</code></pre> 
<p><img alt="" height="112" src="https://images2.imgbox.com/02/82/cN6y3Xyg_o.png" width="450"></p> 
<h4 id="1.1.3.%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89">1.1.3.修饰代码块（最常用）</h4> 
<pre><code class="language-java">public class ThreadSynchronized3 {
    //变量
    private static int number = 0;

    static class Counter{
        //循环次数
        private static int MAX_COUNT = 1000000;

        //++方法
        public void incr() {
            for (int i = 0; i &lt; MAX_COUNT; i++) {
                synchronized (this) { //注意：synchronized (加锁的对象)，两个方法里加锁的对象要一样
                    number++;
                }
            }
        }

        //--方法
        public void decr() {
            for (int i = 0; i &lt; MAX_COUNT; i++) {
                synchronized (this) { //注意：synchronized (加锁的对象)，两个方法里加锁的对象要一样
                    number--;
                }
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        Thread t1 = new Thread(() -&gt; {
            counter.incr();
        });
        t1.start();

        Thread t2 = new Thread(() -&gt; {
            counter.decr();
        });
        t2.start();

        t1.join();
        t2.join();
        System.out.println("最终的结果：" + number);
    }
}
</code></pre> 
<p><img alt="" height="108" src="https://images2.imgbox.com/ee/23/BojgEYT4_o.png" width="450"></p> 
<blockquote> 
 <h4 id="---%3EPS%EF%BC%9A3%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><strong>---&gt;PS：3种常用场景：</strong></h4> 
 <ol><li><strong>this(非静态方法)</strong></li><li><strong>xxx.class</strong></li><li><strong>自定义锁对象（更灵活，最常用）</strong></li></ol> 
 <p><strong>①使用synchronized时，对于同一个业务的多个线程加锁对象，一定要是同一个对象（加同一把锁），否则加锁无效。</strong></p> 
 <p><img alt="" height="387" src="https://images2.imgbox.com/05/64/OKJj5ACY_o.png" width="300"></p> 
 <p><img alt="" height="103" src="https://images2.imgbox.com/b7/48/7HRG8xRo_o.png" width="300"></p> 
 <p><strong>②synchronized修饰代码块，代码块在静态方法中时，不能使用this对象，否则会直接报错。</strong></p> 
 <p><img alt="" height="98" src="https://images2.imgbox.com/5e/b3/BCW5D3yt_o.png" width="600"></p> 
 <p>那么改为使用类型：</p> 
 <p><img alt="" height="96" src="https://images2.imgbox.com/de/b0/AthCRpKH_o.png" width="250"></p> 
 <p><strong>③自定义锁对象（普通/静态（加static）都可以）</strong></p> 
 <p><img alt="" height="216" src="https://images2.imgbox.com/f2/8f/gwT4WvYd_o.png" width="300"></p> 
 <p><img alt="" height="101" src="https://images2.imgbox.com/17/c6/bJC0mGLA_o.png" width="150"></p> 
</blockquote> 
<h3 id="1.2.synchronized%E7%89%B9%E6%80%A7">1.2.synchronized特性</h3> 
<h4 id="1.2.1.%E4%BA%92%E6%96%A5%E6%80%A7%2F%E6%8E%92%E4%BB%96%E6%80%A7">1.2.1.互斥性/排他性</h4> 
<p><span style="color:#333333;">synchronized（非公平锁）会起到互斥效果，某个线程执⾏到某个对象的 synchronized 中时，其他线程如果也执⾏到同⼀个对象 synchronized 就会阻塞等待。</span></p> 
<ul><li><span style="color:#333333;">进⼊ synchronized 修饰的代码块, 相当于加锁。</span></li><li><span style="color:#333333;">退出 synchronized 修饰的代码块, 相当于解锁。</span></li></ul> 
<p><img alt="" height="143" src="https://images2.imgbox.com/3f/65/OwJLXrzN_o.png" width="500"></p> 
<blockquote> 
 <h4 id="---%3EPS%EF%BC%9A%E5%85%AC%E5%B9%B3%E9%94%81%20VS%20%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81">---&gt;PS：公平锁 VS 非公平锁</h4> 
 <ul><li><strong>公平锁</strong>：按资排辈，先到先得。需要“唤醒”这一步操作，会牺牲一定的性能。(线程发现锁占用，尝试获取锁一段时间后，进入休眠状态，进入排队队列中等待。上一个线程释放锁后，会唤醒排队等候的其他线程中最前面的线程从阻塞状态又切换至运行状态）</li><li><strong>非公平锁</strong>：来得早不如来得巧，不需要“唤醒”，性能高。（线程1发现锁占用，尝试获取锁一段时间后，进入休眠状态。此时线程2来了，处于运行状态，尝试获取锁，此时刚好上一个线程释放了锁，那么线程2直接得到了锁并去运行它的任务了。排队等待的其他线程获取锁的顺序不是按照访问的顺序先来先到的，而是由线程自己竞争，随机获取到锁）Java里所有的锁默认是非公平锁。</li></ul> 
</blockquote> 
<p><span style="color:#333333;">synchronized⽤的锁是存在Java<strong>对象头</strong>（隐藏的属性）⾥的：</span></p> 
<p><span style="color:#333333;">Java中每个对象都有一个隐藏的对象头，它用来存储拥有当前锁的线程ID；它有一个标识，标识当前锁是被占用状态还是闲置状态。</span></p> 
<p><img alt="" height="183" src="https://images2.imgbox.com/ee/cd/I0byvEBR_o.png" width="80"></p> 
<ul><li><span style="color:#0d0016;">可粗略理解成, 每个对象在内存中存储时, 都存有⼀块内存（对象头）表示当前的 "锁定" 状态(类似于厕所的 "有⼈/⽆⼈")。</span></li><li><span style="color:#0d0016;">如果当前是 "⽆⼈" 状态, 那么就可以使⽤, 使⽤时需要设为 "有⼈" 状态。</span></li><li><span style="color:#0d0016;">如果当前是 "有⼈" 状态, 那么其他⼈⽆法使⽤, 只能排队。</span></li></ul> 
<p><img alt="" height="198" src="https://images2.imgbox.com/af/78/0HY2H9aO_o.png" width="400"></p> 
<p><span style="color:#0d0016;"><strong>理解 "阻塞等待"：</strong></span></p> 
<p><span style="color:#0d0016;">针对每⼀把锁，操作系统内部都维护了⼀个等待队列。当这个锁被某个线程占有的时候，其他线程</span><span style="color:#0d0016;">尝试进⾏加锁，就加不上了，就会阻塞等待，⼀直等到之前的线程解锁之后，由操作系统唤醒⼀个</span><span style="color:#0d0016;">新的线程，再来获取到这个锁。</span></p> 
<p><span style="color:#0d0016;"><strong>注意：</strong></span></p> 
<p><span style="color:#0d0016;">上⼀个线程解锁之后，下⼀个线程并不是⽴即就能获取到锁，⽽是要靠操作系统来"唤醒"，这也就是操作系统线程调度的⼀部分⼯作。</span></p> 
<p><span style="color:#0d0016;">假设有 A B C 三个线程，线程 A 先获取到锁，然后 B 尝试获取锁，然后 C 再尝试获取锁，此时B 和 C 都在阻塞队列中排队等待。但是当 A 释放锁之后，虽然 B ⽐ C 先来的，但是 B 不⼀定就</span><span style="color:#0d0016;">能获取到锁，⽽是和 C 重新竞争，并不遵守先来后到的规则。</span></p> 
<h4 id="1.2.2.%E5%88%B7%E6%96%B0%E5%86%85%E5%AD%98">1.2.2.刷新内存</h4> 
<p><span style="color:#333333;">synchronized 的⼯作过程：</span></p> 
<ol><li><span style="color:#333333;">获得互斥锁。</span></li><li><span style="color:#333333;">从主内存拷贝变量的最新副本到⼯作的内存。 </span></li><li><span style="color:#333333;">执⾏代码。</span></li><li><span style="color:#333333;">将更改后的共享变量的值刷新到主内存。 </span></li><li><span style="color:#333333;">释放互斥锁。</span></li></ol> 
<div> 
 <p><span style="color:#333333;">所以 synchronized 也能保证<strong>内存可见性</strong>。</span></p> 
</div> 
<h4 id="1.2.3.%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7">1.2.3.可重入性</h4> 
<p><span style="color:#333333;">synchronized 同步块对同⼀条线程来说是可重⼊的，不会出现⾃⼰把⾃⼰锁死的问题。</span></p> 
<pre><code class="language-java">/**
 * synchronized 可重入性测试
 */
public class ThreadSynchronized4 {
    public static void main(String[] args) {
        synchronized (ThreadSynchronized4.class) {
            System.out.println("当前主线程已经得到了锁"); //当执行到此行代码时，表示已经获得锁
            synchronized (ThreadSynchronized4.class) { //同一个线程获取锁两次
                System.out.println("当前主线程再次得到了锁"); //若两行代码都能打印，说明具备可重入性
            }
        }
    }
}</code></pre> 
<p><img alt="" height="136" src="https://images2.imgbox.com/ca/7e/DxQBD3pS_o.png" width="350"></p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/51/e9/ChF5PONX_o.png" width="700"></p> 
<h3 id="1.3.synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">1.3.synchronized实现原理</h3> 
<blockquote> 
 <h4 id="%EF%BC%88%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%EF%BC%89synchronized%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span style="color:#0d0016;">（面试必问）synchronized是如何实现的？</span></h4> 
 <p><span style="color:#0d0016;"><strong>①在Java代码层面：</strong></span></p> 
 <p><span style="color:#0d0016;">synchronized加锁的对象里有一个的隐藏的对象头，这个对象头（可看作一个类）里有很多属性，其中比较关注的两个属性是：<span style="background-color:#d7d8d9;">是否加锁的标识</span>和<span style="background-color:#d7d8d9;">拥有当前锁的线程id</span>。</span></p> 
 <p><span style="color:#0d0016;">每次进⼊ synchronized 修饰的代码块时，会去对象头中先判断加锁的标识，再判断拥有当前锁的线程id，从而决定当前线程能否往下继续执行。</span></p> 
 <ul><li><span style="color:#0d0016;">判断加锁标识为false-&gt;对象头未加锁，当前线程可以进入synchronized 修饰的代码块，并设置加锁标识为true，设置拥有当前锁的线程id为此线程id。</span></li><li><span style="color:#0d0016;">判断加锁标识为true-&gt;对象头已加锁，需进一步判断拥有当前锁的线程id是否为此线程id，若是，则继续往下执行；否则，不能往下执行，需要等待锁资源释放后重新竞争再获取锁。</span></li></ul> 
 <p><span style="color:#0d0016;"><strong>②在JVM层面和操作系统层面：</strong></span></p> 
 <p><span style="color:#0d0016;">synchronized同步锁是通过<strong>JVM</strong>内置的Monitor监视器实现的，而监视器又是依赖<strong>操作系统</strong>的互斥锁Mutex实现的。↓</span></p> 
</blockquote> 
<h4 id="1.3.1.%E7%9B%91%E8%A7%86%E5%99%A8">1.3.1.监视器</h4> 
<p>监视器是一个概念或者说是一个机制，它用来保障在任何时候，只有一个线程能够执行指定区域的代码。</p> 
<blockquote> 
 <p>一个监视器像是一个建筑，建筑里有一个特殊的房间，这个房间同一时刻只能被一个线程占有。</p> 
 <p>一个线程从进入该房间到离开该房间，可以全程独占该房间的所有数据。</p> 
 <ul><li>进入该建筑叫做<strong>进入监视器</strong>（entering the monitor）；</li><li>进入该房间叫做<strong>获得监视器</strong>（acquiring the monitor）；</li><li>独自占有该房间叫做<strong>拥有监视器</strong>（owing the monitor）；</li><li>离开该房间叫做<strong>释放监视器</strong>（releasing the monitor）；</li><li>离开该建筑叫做<strong>退出监视器</strong>（exiting the monitor）。</li></ul> 
 <p>严格意义说，监视器和锁的概念是不同的，但很多地方将二者互相指代。</p> 
</blockquote> 
<h4 id="1.3.2.%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">1.3.2.底层实现</h4> 
<blockquote> 
 <p>查看字节码：</p> 
 <p><img alt="" height="276" src="https://images2.imgbox.com/1d/62/DZXRPN1J_o.png" width="450"></p> 
 <p>只能通过命令去看：</p> 
 <p><img alt="" height="362" src="https://images2.imgbox.com/88/5e/exZvTGfw_o.png" width="450"></p> 
 <p><img alt="" height="152" src="https://images2.imgbox.com/f3/66/b6necuEY_o.png" width="600"></p> 
 <p><img alt="" height="799" src="https://images2.imgbox.com/e0/a0/qidQ0n7y_o.png" width="700"></p> 
</blockquote> 
<pre><code class="language-java">public class ThreadSynchronized5 {
    public static void main(String[] args) {
        synchronized (ThreadSynchronized5.class) {
            for (int i = 0; i &lt; 10; i++) {
                System.out.println(i);
            }
        }
    }
}
</code></pre> 
<p><img alt="" height="253" src="https://images2.imgbox.com/e1/b2/xKUYwk9M_o.png" width="400"></p> 
<p>源代码.java运行后就会在out目录下生成字节码文件.class，用命令查看字节码：</p> 
<p><img alt="" height="728" src="https://images2.imgbox.com/88/2f/tP91SXBw_o.png" width="700"></p> 
<p>在字节码中，main方法中多了一对monitorenter和monitorexit指令，分别表示进入监视器和退出监视器。可知synchronized是依赖Monitor监视器实现的。</p> 
<h4 id="1.3.3.%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">1.3.3.执行流程</h4> 
<p>在Java中，synchronized是非公平锁，也是可重入锁（指一个线程获取到锁之后，可以重复得到该锁）。</p> 
<p>在HotSpot虚拟机（JVM的一种）中，Monitor底层是由C++实现的，它的实现对象是ObjectMonitor（隐藏的对象头），ObjectMonitor结构体的实现如下：</p> 
<pre><code class="language-cpp">//结构体如下
ObjectMonitor::ObjectMonitor() {  
  _header       = NULL;  
  _count       = 0;  
  _waiters      = 0,  
  _recursions   = 0;       //线程的重入次数
  _object       = NULL;  
  _owner        = NULL;    //标识拥有该monitor的线程
  _WaitSet      = NULL;    //等待线程组成的双向循环链表，_WaitSet是第一个节点
  _WaitSetLock  = 0 ;  
  _Responsible  = NULL ;  
  _succ         = NULL ;  
  _cxq          = NULL ;    //多线程竞争锁进入时的单向链表
  FreeNext      = NULL ;  
  _EntryList    = NULL ;    //_owner从该双向循环链表中唤醒线程结点，_EntryList是第一个节点
  _SpinFreq     = 0 ;  
  _SpinClock    = 0 ;  
  OwnerIsThread = 0 ;  
}  
</code></pre> 
<p>以上代码中几个关键属性：</p> 
<ol><li>_count：记录该线程获取锁的次数。</li><li>_recursions：线程重入锁的次数。</li><li>_owner：拥有者，是持有该ObjectMonitor（监视器）对象的线程，记录的是线程id。</li><li>_EntryList：监控集合，存放的是处于阻塞状态的线程队列，在多线程下，竞争失败的线程会进入EntryList队列。</li><li>_WaitSet：待授权集合，存放的是处于wait状态的线程队列，当线程执行了wait()方法之后，会进入WaitSet队列。</li></ol> 
<p>监视器执行流程如下：</p> 
<ol><li>线程通过CAS（是乐观锁里的一个对比并替换机制）尝试获取锁，如果获取成功，就将owner字段设置为当前线程，说明当前线程已经持有锁，并将recursions重入次数的属性+1。如果获取失败，则先通过自旋CAS尝试获取锁，如果还是失败则将当前线程放入到EntryList监控队列（阻塞）。</li><li>当拥有锁的线程执行了wait方法之后，线程释放锁，将owner变量恢复为null状态，同时将该线程放入WaitSet待授权队列中等待被唤醒。</li><li>当调用notify方法时，随机唤醒WaitSet队列中的某一个线程，当调用notifyAll时，唤醒所有的WaitSet中的线程尝试获取锁。</li><li>线程执行完释放了锁之后，会唤醒EntryList中的所有线程尝试获取锁。</li></ol> 
<p><img alt="" height="351" src="https://images2.imgbox.com/9c/62/jl7QBh1z_o.png" width="500"></p> 
<h3 id="1.4.synchronized%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95%E8%BF%9B%E7%A8%8B">1.4.synchronized历史发展进程</h3> 
<ul><li>在JDK1.6之前（多使用Lock）synchronized使用很少，那时synchronized默认使用重量级锁实现，所以性能较差。</li><li>在JDK1.6时，synchronized做了优化。<strong>锁升级</strong>流程如下：</li></ul> 
<ol><li><strong>无锁</strong>：没有线程访问时默认是无锁状态，加了synchronized也是无锁状态。有线程访问时才加锁。更大程度上减少锁带来的程序上的开销。</li><li><strong>偏向锁</strong>：当有一个线程访问时会升级为偏向锁。(在对象头里存了这样一把锁，后面再来线程时会判断，如果线程id和拥有锁的线程id相同，会让它进去，只偏向某一个线程，其他线程来了之后要继续等)</li><li><strong>轻量级锁</strong>：当有多个线程访问时会升级为轻量级锁。</li><li><strong>重量级锁</strong>：当有更多线程访问时会升级为重量级锁。</li></ol> 
<ul><li>Oracle也有设计<strong>锁降级</strong>的功能。当线程访问变少时，会由重量级锁-&gt;降级为轻量级锁-&gt;偏向锁-&gt;无锁。但是这个机制目前还没有完善，只是有一个设计的思想和理念。</li></ul> 
<blockquote> 
 <p>锁升级/降级就好比HashMap在JDK1.8之后底层实现：<strong>数组+链表/红黑树</strong>（存储结构的升级/降级）</p> 
 <ul><li>当数组长度&gt;8且链表长度&gt;64，会将链表升级为红黑树。</li><li>当数组长度&lt;8且链表长度&lt;64，会将红黑树降级为链表。</li></ul> 
</blockquote> 
<h2 id="2.%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%2F%E6%89%8B%E5%8A%A8%E9%94%81%EF%BC%9ALock%EF%BC%88Lock%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%2C%E9%80%9A%E5%B8%B8%E6%89%80%E8%AF%B4%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E6%98%AF%E6%8C%87Lock%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0%E5%AD%90%E7%B1%BBReentrantLock)">2.可重入锁/手动锁：Lock（Lock是一个接口,通常所说的可重入锁是指Lock的一个实现子类ReentrantLock)</h2> 
<p>比synchronized更灵活，功能更多~</p> 
<h3 id="2.1.Lock%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A">2.1.Lock实现步骤：</h3> 
<h4 id="%E2%91%A0%E5%88%9B%E5%BB%BA%E9%94%81%E5%AF%B9%E8%B1%A1Lock%20lock%20%3D%20new%20ReentrantLock()%3B">①创建锁对象Lock lock = new ReentrantLock();</h4> 
<h4 id="%E2%91%A1%E5%8A%A0%E9%94%81lock.lock()%3B">②加锁lock.lock();</h4> 
<h4 id="%E2%91%A2%E9%87%8A%E6%94%BE%E9%94%81lock.unlock()%3B">③释放锁lock.unlock();</h4> 
<p><img alt="" height="105" src="https://images2.imgbox.com/32/1f/XqbPjtk5_o.png" width="400"></p> 
<pre><code class="language-java">import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 手动锁（可重入锁的基本使用）
 */
public class ThreadLock {
    public static void main(String[] args) {
        //1.创建锁对象
        Lock lock = new ReentrantLock();
        //2.加锁操作
        lock.lock();
        try{
            //业务代码（可能会非常复杂-&gt;可能会导致异常，后面的代码就不执行了，锁就无法释放，当前线程会永久占用锁资源）
            //所以要用try-catch-finally（可以没有catch）
            System.out.println("你好，ReentrantLock.");
        } finally {
            //3.释放锁（一定要放在finally中）
            lock.unlock(); 
        }
    }
}
</code></pre> 
<p><img alt="" height="102" src="https://images2.imgbox.com/78/fc/BBjPVP5b_o.png" width="300"></p> 
<blockquote> 
 <h4 id="---%3E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span style="color:#0d0016;">---&gt;注意事项：</span></h4> 
 <h4 id="a.unlock()%E4%B8%80%E5%AE%9A%E8%A6%81%E6%94%BE%E5%9C%A8finally%E9%87%8C%EF%BC%8C%E5%90%A6%E5%88%99%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E9%94%81%E8%B5%84%E6%BA%90%E6%B0%B8%E4%B9%85%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%E3%80%82"><span style="color:#0d0016;">a.unlock()一定要放在finally里，否则可能导致锁资源永久占用问题。</span></h4> 
 <h4 id="b.lock()%E8%A6%81%E6%94%BE%E5%88%B0try%E5%A4%96%EF%BC%88%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%EF%BC%89%E6%88%96try%E4%B8%AD%E7%9A%84%E9%A6%96%E8%A1%8C%EF%BC%88%E9%97%AE%E9%A2%98%E4%B8%8D%E5%A4%A7%EF%BC%89%E3%80%82"><span style="color:#0d0016;">b.lock()要放到try外（官方建议）或try中的首行（问题不大）。</span></h4> 
 <p><a class="link-info has-card" href="https://docs.oracle.com/javase/8/docs/api/" rel="nofollow" title="oracle官方文档中的说明"><span class="link-card-box"><span class="link-title">oracle官方文档中的说明</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/89/44/wjTzLBpu_o.png">https://docs.oracle.com/javase/8/docs/api/</span></span></a></p> 
 <pre><code class="language-java">lock.lock();  
try {
    
} finally {
    lock.unlock()
}</code></pre> 
 <pre><code class="language-java">try {
    lock.lock(); 
    int n = 1/0; 
} finally {
    lock.unlock()
}</code></pre> 
 <p>↓不行：</p> 
 <pre><code class="language-java">try {
    int n = 1/0;
    lock.lock();  
} finally {
    lock.unlock()
}</code></pre> 
 <div> 
  <span style="color:#262626;">原因有两个： </span> 
 </div> 
 <ol><li><span style="color:#262626;">如果放在 try ⾥⾯，因为 try 代码中的异常导致<strong>加锁失败</strong>，但<strong>还会执行</strong> finally <strong>释放锁</strong>的操作。 未加锁却释放锁，肯定会报错。</span></li><li><span style="color:#262626;">报错信息中：unlock 异常会覆盖 try ⾥⾯的业务异常，从而增加调式程序和修复程序的复杂度，增加排查错误的难度。 </span></li></ol> 
 <p><img alt="" height="383" src="https://images2.imgbox.com/c8/4d/E3PRyHki_o.png" width="500"></p> 
 <p><img alt="" height="375" src="https://images2.imgbox.com/40/7e/OSMwdVaO_o.png" width="600"></p> 
</blockquote> 
<pre><code class="language-java">import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ThreadLock2 {
    private static int number = 0;

    static class Counter{
        //1.创建锁对象
        private static Lock lock = new ReentrantLock();

        //循环次数
        private static int MAX_COUNT = 1000000;

        //++方法
        public static void incr() {
            for (int i = 0; i &lt; MAX_COUNT; i++) {
                lock.lock(); //2.加锁
                try{
                    number++;
                } finally {
                    lock.unlock(); //3.释放锁
                }
            }
        }

        //--方法
        public static void decr() {
            for (int i = 0; i &lt; MAX_COUNT; i++) {
                lock.lock();
                try{
                    number--;
                } finally {
                    lock.unlock();
                }
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -&gt; {
            Counter.incr();
        });
        t1.start();

        Thread t2 = new Thread(() -&gt; {
            Counter.decr();
        });
        t2.start();

        t1.join();
        t2.join();
        System.out.println("最终的结果：" + number);
    }
}
</code></pre> 
<p><img alt="" height="101" src="https://images2.imgbox.com/84/e3/DM7E0jIu_o.png" width="300"></p> 
<h3 id="2.2.Lock%E6%8C%87%E5%AE%9A%E9%94%81%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81">2.2.Lock指定锁类型——公平锁和非公平锁</h3> 
<p>查看源码：</p> 
<p><img alt="" height="208" src="https://images2.imgbox.com/84/31/PtulO3m9_o.png" width="500"></p> 
<pre><code class="language-java">//1.创建锁对象
Lock lock = new ReentrantLock(true); //公平锁
Lock lock = new ReentrantLock(); //非公平锁
Lock lock = new ReentrantLock(false); //非公平锁</code></pre> 
<p>使用公平锁比使用非公平锁要慢！</p> 
<h2 id="3.%EF%BC%88%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%EF%BC%89synchronized%20VS%20Lock%EF%BC%88ReentrantLock%EF%BC%89">3.（面试必问）synchronized VS Lock（ReentrantLock）</h2> 
<h3 id="%E2%91%A0Lock%20%E6%9B%B4%E7%81%B5%E6%B4%BB%EF%BC%8C%E6%9C%89%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E6%AF%94%E5%A6%82tryLock()%EF%BC%9B%E7%B2%92%E5%BA%A6%E5%8F%AF%E4%BB%A5%E6%9B%B4%E5%B0%8F%EF%BC%88%E4%B8%8D%E6%98%8E%E6%98%BE%EF%BC%89%E3%80%82"><span style="color:#262626;">①Lock 更灵活，有更多的方法，比如tryLock()。粒度可以更小（不明显）。</span></h3> 
<pre><code class="language-java">boolean result = lock.tryLock(); //判断拿这个锁是否成功</code></pre> 
<pre><code class="language-java">boolean result = lock.tryLock(5, TimeUnit.SECONDS); //设置最大等待时间和单位，最多等5s，5s后如果还是没拿到锁，就不等了，返回false</code></pre> 
<pre><code class="language-java">//设置动态等待时间
for (int i = 0; i &lt; 15; i++) {
   boolean result = lock.tryLock(1 + i, TimeUnit.SECONDS);
}
//第一次设置最大等待时间为1s，如果1s后没有获取到锁，继续循环，下一次最大等待时间就是2s，如果没得到，第3次就等待3s.</code></pre> 
<pre><code class="language-java">import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ThreadLock4 {
    public static void main(String[] args) throws InterruptedException {
        Lock lock = new ReentrantLock();

//        synchronized (lock) { //如果获取锁失败会死等，直到拿到锁，执行业务代码
//
//        }

        boolean result = lock.tryLock(5, TimeUnit.SECONDS);
        if(result) {
            //获取锁成功，执行相应的代码

        } else {
            //获取锁失败，执行相应的业务
            //可以灵活处理，可以不等这个锁了，执行其他的业务操作；或回到最初代码，再去执行拿锁操作。可以人为控制。

        }
    }
}</code></pre> 
<h3 id="%E2%91%A1Lock%EF%BC%88%E6%8E%A5%E5%8F%A3%E7%BA%A7%E5%88%AB%EF%BC%89%E9%9C%80%E8%A6%81%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%8A%A8%E6%93%8D%E4%BD%9C%E9%94%81%EF%BC%88%E5%8A%A0%2F%E9%87%8A%E6%94%BE%EF%BC%89%EF%BC%8C%E8%80%8C%20Synchronized%20%E6%98%AF%20JVM%20%E5%B1%82%E9%9D%A2%E6%8F%90%E4%BE%9B%E7%9A%84%E9%94%81%EF%BC%8C%E8%87%AA%E5%8A%A8%E8%BF%9B%E8%A1%8C%E5%8A%A0%E9%94%81%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%AF%B9%E4%BA%8E%E5%BC%80%E5%8F%91%E8%80%85%E6%98%AF%E6%97%A0%E6%84%9F%E7%9A%84%E3%80%82"><span style="color:#262626;">②Lock（接口级别）需要开发者手动操作锁（加/释放）；而 synchronized 是 JVM 层面提供的锁，自动进行加锁和释放锁操作，对于开发者是无感的。</span></h3> 
<h3 id="%E2%91%A2Lock%20%E5%8F%AA%E8%83%BD%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E8%80%8C%20Synchronized%20%E5%8F%AF%E4%BB%A5%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%82"><span style="color:#262626;">③Lock 只能修饰代码块；而 synchronized 可以修饰普通方法、静态方法和代码块。 </span></h3> 
<h3 id="%E2%91%A3%E9%94%81%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%EF%BC%9ALock%20%E9%BB%98%E8%AE%A4%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E4%BD%86%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E4%B8%BA%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E8%80%8C%20Synchronized%20%E5%8F%AA%E8%83%BD%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E3%80%82"><span style="color:#262626;">④锁类型不同：Lock 默认是非公平锁，但可以指定为公平锁；而 synchronized 只能是非公平锁。</span></h3> 
<h3 id="%E2%91%A4%E8%B0%83%E7%94%A8Lock%E5%92%8Csynchronized%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8D%E5%90%8C%EF%BC%9Alock%E4%BC%9A%E5%8F%98%E4%B8%BAWAITING%EF%BC%8C%E8%80%8Csynchronized%E4%BC%9A%E5%8F%98%E4%B8%BABLOCKED%E3%80%82"><span style="color:#262626;">⑤调用Lock和synchronized线程等待锁的状态不同：lock会变为WAITING；而synchronized会变为BLOCKED。</span></h3> 
<pre><code class="language-java">import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ThreadLock4 {
    public static void main(String[] args) throws InterruptedException {
        Lock lock = new ReentrantLock();

        Thread t1 = new Thread(() -&gt; {
           lock.lock();
            System.out.println("线程1得到了锁");
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                System.out.println("线程1释放锁");
                lock.unlock();
            }
        });
        t1.start();

        Thread t2 = new Thread(() -&gt; {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            lock.lock();
            try{
                System.out.println("线程2得到了锁");
            } finally {
                System.out.println("线程2释放锁");
                lock.unlock();
            }
        });
        t2.start();

        t1.join();
        t2.join();
    }
}
</code></pre> 
<p><img alt="" height="185" src="https://images2.imgbox.com/08/a0/Gv2fb4UT_o.png" width="500"></p> 
<p>Lock：</p> 
<pre><code class="language-java">public class ThreadLock4 {
    public static void main(String[] args) throws InterruptedException {
        Lock lock = new ReentrantLock();

        Thread t1 = new Thread(() -&gt; {
           lock.lock();
            System.out.println("线程1得到了锁");
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                System.out.println("线程1释放锁");
                lock.unlock();
            }
        });
        t1.start();

        Thread t2 = new Thread(() -&gt; {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            lock.lock();
            try{
                System.out.println("线程2得到了锁");
            } finally {
                System.out.println("线程2释放锁");
                lock.unlock();
            }
        });
        t2.start();

        Thread.sleep(1500);
        System.out.println("线程2的状态：" + t2.getState());

        t1.join();
        t2.join();
    }
}
</code></pre> 
<p><img alt="" height="200" src="https://images2.imgbox.com/0c/52/6zUAbXWi_o.png" width="350"></p> 
<p>synchronized：</p> 
<pre><code class="language-java">public class ThreadLock4 {
    public static void main(String[] args) throws InterruptedException {
        Lock lock = new ReentrantLock();

        Thread t1 = new Thread(() -&gt; {
            synchronized (ThreadLock4.class) {
                System.out.println("线程1得到了锁");
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("线程1释放锁");
            }
        });
        t1.start();

        Thread t2 = new Thread(() -&gt; {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (ThreadLock4.class) {
                System.out.println("线程2得到了锁");
                System.out.println("线程2释放锁");
            }
        });
        t2.start();

        Thread.sleep(1500);
        System.out.println("线程2的状态：" + t2.getState());

        t1.join();
        t2.join();
    }
}
</code></pre> 
<p><img alt="" height="200" src="https://images2.imgbox.com/40/66/8DC4QFhZ_o.png" width="350"></p> 
<p>Lock和synchronized线程2都不是runnable运行状态。因为如果一直让线程2尝试获取锁，就会造成资源的浪费。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c10170773860cc8fffcf5ef81a2c12ba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用数组方式创建二叉树--堆</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/957461809bbae7bf3ed9611e78658d54/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Altium Designer导入元器件3D封装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>