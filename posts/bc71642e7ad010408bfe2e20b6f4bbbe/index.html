<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>05 排序算法【数据结构与算法学习笔记(Java)】 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="05 排序算法【数据结构与算法学习笔记(Java)】" />
<meta property="og:description" content="数据结构与算法（Java实现） 我的学习资料：
视频：尚硅谷Java数据结构与java算法（Java数据结构与算法）
书籍：《大话数据结构》
笔记中包括学习的内容，代码，同时自己总结了知识点速记（部分会带页内跳转，可点击跳转）供快速回顾和记忆学到的知识点。
六、排序算法（Sort Algorithm） 排序也称排序算法(SortAlgorithm)，排序是将 一组数据，依 指定的顺序进行 排列的过程。
6.1 分类 内部排序法（重点）
指将需要处理的所有数据都加载到 内部存储器( 内存)中进行排序。
外部排序法
数据量过大，无法全部加载到内存中，需要借助 外部存储( 文件等)进行排序。
常见的排序算法分类如图：
6.2 算法的时间复杂度 6.2.1 度量一个程序(算法)执行时间的两种方法 事后统计的方法
把程序这段程序运行起来，然后计时。这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较哪个算法速度更快。
事前估算的方法
通过分析某个算法的时间复杂度来判断哪个算法更优。
6.2.2 时间频度 时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。 一个算法中的语句执行次数称为语句频度或时间频度。记为 T(n)。
举例说明-基本案例
比如计算 1-100 所有数字之和, 我们设计两种算法：
举例说明-忽略常数项
结论: 2n&#43;20 和 2n 随着 n 变大，执行曲线无限接近, 20 可以忽略3n&#43;10 和 3n 随着 n 变大，执行曲线无限接近, 10 可以忽略 举例说明-忽略低次项
结论: 2n2&#43;3n&#43;10 和 2n2 随着 n 变大, 执行曲线无限接近, 可以忽略 3n&#43;10n2&#43;5n&#43;20 和 n2随着 n 变大,执行曲线无限接近, 可以忽略 5n&#43;20 举例说明-忽略系数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/bc71642e7ad010408bfe2e20b6f4bbbe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-09T15:57:43+08:00" />
<meta property="article:modified_time" content="2021-03-09T15:57:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">05 排序算法【数据结构与算法学习笔记(Java)】</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Java_0"></a>数据结构与算法（Java实现）</h2> 
<p>我的学习资料：<br> 视频：<a href="https://www.bilibili.com/video/BV1E4411H73v?p=43&amp;spm_id_from=pageDriver" rel="nofollow">尚硅谷Java数据结构与java算法（Java数据结构与算法）</a><br> 书籍：《大话数据结构》<br> 笔记中包括学习的内容，代码，同时自己总结了知识点速记（部分会带页内跳转，可点击跳转）供快速回顾和记忆学到的知识点。</p> 
<h2><a id="Sort_Algorithm_5"></a>六、排序算法（Sort Algorithm）</h2> 
<p>排序也称排序算法(SortAlgorithm)，排序是将 一组数据，依 指定的顺序进行 排列的过程。</p> 
<h3><a id="61__7"></a>6.1 分类</h3> 
<ul><li> <p>内部排序法（重点）<br> 指将需要处理的所有数据都加载到 内部存储器( 内存)中进行排序。</p> </li><li> <p>外部排序法<br> 数据量过大，无法全部加载到内存中，需要借助 外部存储( 文件等)进行排序。</p> </li><li> <p>常见的排序算法分类如图：<br> <img src="https://images2.imgbox.com/76/69/SHHgHzC5_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h3><a id="62__17"></a>6.2 算法的时间复杂度</h3> 
<h4><a id="621__18"></a>6.2.1 度量一个程序(算法)执行时间的两种方法</h4> 
<ul><li> <p>事后统计的方法<br> 把程序这段程序运行起来，然后计时。这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较哪个算法速度更快。</p> </li><li> <p>事前估算的方法<br> 通过分析某个算法的<strong>时间复杂度</strong>来判断哪个算法更优。</p> </li></ul> 
<h4><a id="622__25"></a>6.2.2 时间频度</h4> 
<p>时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。 <strong>一个算法中的语句执行次数称为语句频度或时间频度</strong>。记为 T(n)。</p> 
<ul><li>举例说明-基本案例<br> 比如计算 1-100 所有数字之和, 我们设计两种算法：<br> <img src="https://images2.imgbox.com/b5/3b/VsKoguox_o.png" alt="在这里插入图片描述"></li><li>举例说明-忽略常数项<br> <img src="https://images2.imgbox.com/8f/5d/hpJ5nF9Z_o.png" alt="在这里插入图片描述"><br> 结论:</li></ul> 
<ol><li>2n+20 和 2n 随着 n 变大，执行曲线无限接近, 20 可以忽略</li><li>3n+10 和 3n 随着 n 变大，执行曲线无限接近, 10 可以忽略</li></ol> 
<ul><li>举例说明-忽略低次项<br> <img src="https://images2.imgbox.com/5d/fa/K9yIUrPb_o.png" alt="在这里插入图片描述"><br> 结论:</li></ul> 
<ol><li>2n<sup>2</sup>+3n+10 和 2n<sup>2</sup> 随着 n 变大, 执行曲线无限接近, 可以忽略 3n+10</li><li>n<sup>2</sup>+5n+20 和 n<sup>2</sup>随着 n 变大,执行曲线无限接近, 可以忽略 5n+20</li></ol> 
<ul><li>举例说明-忽略系数<br> <img src="https://images2.imgbox.com/c4/8c/tXJtnjXh_o.png" alt="在这里插入图片描述"><br> 结论:</li></ul> 
<ol><li>随着 n 值变大，5n<sup>2</sup>+7n 和 3n<sup>2</sup> + 2n ，执行曲线重合, 说明 这种情况下, 5 和 3 可以忽略。</li><li>而 n<sup>3</sup>+5n 和 6n<sup>3</sup>+4n ，执行曲线分离，说明多少次方式关键。</li></ol> 
<h4><a id="623__45"></a>6.2.3 时间复杂度</h4> 
<ol><li>一般情况下， <strong>算法中的基本操作语句的重复执行次数是<mark>问题规模 n</mark> 的某个函数</strong>，用 T(n)表示，若有某个辅助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。记作 T(n)= Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。</li><li>T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同，但时间复杂度相同，都为 O(n<sup>2</sup>)。</li><li>计算时间复杂度的方法：</li></ol> 
<ul><li>用常数 1 代替运行时间中的所有加法常数 T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1</li><li>修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 =&gt; T(n) = n²</li><li>去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li></ul> 
<h4><a id="624__53"></a>6.2.4 常见的时间复杂度</h4> 
<ul><li>常数阶 O(1)</li><li>对数阶 O(log2n)</li><li>线性阶 O(n)</li><li>平方阶 O(n<sup>2</sup>)</li><li>立方阶 O(n<sup>3</sup>)</li><li>k 次方阶 O(n<sup>k</sup>)</li><li>指数阶 O(2<sup>n</sup>)</li></ul> 
<p>常见的时间复杂度对应的图:<br> <img src="https://images2.imgbox.com/27/ee/yvkaHFvX_o.png" alt="在这里插入图片描述"><br> 说明：</p> 
<ol><li>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n<sup>2</sup>)＜Ο(n<sup>3</sup>)＜ Ο(n<sup>k</sup>) ＜Ο(2<sup>n</sup>) ，随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</li><li>从图中可见，我们应该尽可能避免使用指数阶的算法。</li></ol> 
<ul><li>常数阶<br> <img src="https://images2.imgbox.com/c4/9a/CMVKKSEx_o.png" alt="在这里插入图片描述"></li><li>对数阶 O(log2n)<br> <img src="https://images2.imgbox.com/6f/87/6cA8FexZ_o.png" alt="在这里插入图片描述"></li><li>线性阶 O(n)<br> <img src="https://images2.imgbox.com/d0/53/uVWAUlDA_o.png" alt="在这里插入图片描述"></li><li>线性对数阶 O(nlogN)<br> <img src="https://images2.imgbox.com/c9/81/XW7HyVJh_o.png" alt="在这里插入图片描述"></li><li>平方阶 O(n<sup>2</sup>)<br> <img src="https://images2.imgbox.com/9d/05/qm6Ylhz1_o.png" alt="在这里插入图片描述"></li><li>立方阶 O(n<sup>3</sup>)、K 次方阶 O(n<sup>k</sup>)<br> 说明：参考上面的 O(n<sup>2</sup>) 去理解就好了，O(n³)相当于三层 n 循环，其它的类似</li></ul> 
<h4><a id="625__79"></a>6.2.5 平均时间复杂度和最坏时间复杂度</h4> 
<ol><li>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</li><li>最坏情况下的时间复杂度称最坏时间复杂度。 **一般讨论的时间复杂度均是最坏情况下的时间复杂度。**这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</li><li>平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。<br> <img src="https://images2.imgbox.com/59/30/tc7iVboz_o.png" alt="在这里插入图片描述"></li></ol> 
<h3><a id="63__84"></a>6.3 算法的空间复杂度简介</h3> 
<h4><a id="631__85"></a>6.3.1 基本介绍</h4> 
<ol><li>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。</li><li>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例如<strong>快速排序和归并排序算法, 基数排序</strong>就属于这种情况。</li><li>在做算法分析时，主要讨论的是时间复杂度。 <strong>从用户使用体验上看 ， 更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。</strong></li></ol> 
<h3><a id="64_Bubble_Sorting_90"></a>6.4 冒泡排序（Bubble Sorting）</h3> 
<h4><a id="641__91"></a>6.4.1 基本介绍</h4> 
<p>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）, 依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。<br> 优化：<br> 因为排序的过程中，各元素不断接近自己的位置， 如果一趟比较下来没有进行过交换 ， 就说明序列有序，因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，再进行)</p> 
<h4><a id="642__95"></a>6.4.2 演示冒泡过程的例子（图解）</h4> 
<p><img src="https://images2.imgbox.com/6a/8e/vsW5DLQr_o.png" alt="在这里插入图片描述"><br> 小结上面的图解过程:<br> (1) 一共进行 【数组的大小 - 1】 次大的循环，第i次大循环都将确定第i大的数的位置，放在倒数第i的位置上，i次大循环中需要比较的次数为【数组内未通过大循环确定位置的数-1-已经确定数的个数】，理解：因为是数两两比较，2个数比1次，3个数比2次。<br> (2)每一趟排序的次数在逐渐的减少<br> (3) 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化。</p> 
<ul><li>代码演示冒泡排序的具体过程：<br> <img src="https://images2.imgbox.com/84/4d/wnl8xrkD_o.png" alt="在这里插入图片描述"><br> 第1次大循环将第1大的数10的位置确定，在倒数第1的位置上<br> <img src="https://images2.imgbox.com/f4/b6/SEJU7gQK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e7/cc/4iIMHHp5_o.png" alt="在这里插入图片描述"><br> 第2次大循环将第2大的数9的位置确定，在倒数第2的位置上<br> <img src="https://images2.imgbox.com/64/8d/QNc0Dso6_o.png" alt="在这里插入图片描述"><br> 以此类推，一共应该进行【数组大小-1】次大循环，即5-1=4趟：<br> <img src="https://images2.imgbox.com/dd/f5/DHcmlJw8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cd/5f/66DfOGH6_o.png" alt="在这里插入图片描述"><br> 结果：<br> <img src="https://images2.imgbox.com/56/1c/h6KUukPd_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="643__114"></a>6.4.3 冒泡排序代码</h4> 
<p>冒泡排序法的时间复杂度O(n<sup>2</sup>)</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span>  arr<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        BubbleSort<span class="token punctuation">.</span><span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            
            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> j <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&gt;</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<ul><li>运行结果<br> <img src="https://images2.imgbox.com/e9/16/V4Ak2nPc_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="644__143"></a>6.4.4 冒泡排序优化代码</h4> 
<p>优化方法：<br> 设置一个标志标识在某次大循环中是否发生过交换，若没有发生过交换，证明已经有序，可以退出排序。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span>  arr<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        BubbleSort<span class="token punctuation">.</span><span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> flag <span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//标识变量，交换true，未交换false</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> j <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&gt;</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    flag<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
                    temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span><span class="token operator">+</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"趟排序后的数组"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token comment">//进行优化的地方：如果在一趟排序中未发生过交换次序，则证明已经有序，可以退出排序</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                flag <span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//如果发生过排序flag已经变为true，需要重置为false进行下次判断</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//如果没交换，则有序，所以退出</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="645__182"></a>6.4.5 冒泡排序时间测试</h4> 
<p>测试冒泡排序的速度，创建包含80000个随机数的数组。<br> 记录开始时间和结束时间，使用System.currentTimeMillis()</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">//        int[]  arr={3,9,-1,10,-2};</span>
<span class="token comment">//        BubbleSort.bubbleSort(arr);</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">80000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">80000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//生成[0,80000)之间的数</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取开始时间</span>
        <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> endTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取结束时间</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序运行时间为"</span><span class="token operator">+</span><span class="token punctuation">(</span>endTime<span class="token operator">-</span>startTime<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"毫秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

</code></pre> 
<ul><li>运行结果：<br> <img src="https://images2.imgbox.com/31/60/0pgzfj1F_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="65_select_sort_204"></a>6.5 选择排序（select sort）</h3> 
<h4><a id="651_205"></a>6.5.1基本介绍</h4> 
<p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到<br> 排序的目的。</p> 
<h4><a id="652__208"></a>6.5.2 选择排序思想</h4> 
<p>选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从 arr[0] ~ arr[n-1]中选取最小值，与 arr[0]交换，第二次从 arr[1]~ arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]~ arr[n-1]中选取最小值，与 arr[2]交换，…，第 i 次从 arr[i-1]~ arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~ arr[n-1]中选取最小值，与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。</p> 
<h4><a id="653__211"></a>6.5.3 选择排序思路分析图</h4> 
<p><img src="https://images2.imgbox.com/2c/e1/pI6aEK6D_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/be/b4/3SheEbM1_o.png" alt="在这里插入图片描述"><br> 小结上面的图解过程:<br> (1) 一共进行 【数组的大小 - 1】 次大的循环。<br> (2) 第i次大循环都将确定第i小的数的位置，放在第i的位置上。<br> (3) i次大循环中需要进行小循环，假定第i个位置为最小数，是假定最小数，然后依次和它后面的数进行比较，如果有比它更小的数，就【重新记录】最小数和它的坐标，【小循环结束后的最小数和假定最小数位置交换】，所以需要与假定最小数比较的起始位置为第【i+1】个位置到【数组末尾】。<br> (4)优化：如果小循环结束后最小数就是假定最小数，就不用交换。</p> 
<h4><a id="654__221"></a>6.5.4 选择排序代码</h4> 
<p>选择排序时间复杂度O(n<sup>2</sup>)</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelectSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">selectSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> min<span class="token punctuation">;</span>
        <span class="token keyword">int</span> minIndex<span class="token punctuation">;</span>
        <span class="token comment">//大循环，【数组大小-1】次</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//位置i是假定最小数</span>
            min <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            minIndex <span class="token operator">=</span>i<span class="token punctuation">;</span>
            <span class="token comment">//小循环，找到最小数，从假定最小数的后一个位置【i+1】到【数组末尾】比较</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>min<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//如果有比假定最小数小的数，【重新记录】最小数的位置和大小</span>
                    min<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    minIndex<span class="token operator">=</span>j<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//如果最小数和假定最小数位置不一样，则交换它们的位置</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>minIndex<span class="token operator">!=</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>运行结果：<br> <img src="https://images2.imgbox.com/b6/66/nrWrCnGm_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="655__258"></a>6.5.5 选择排序时间测试</h4> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelectSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">//        int[] arr ={3,9,-1,10,-2};</span>
<span class="token comment">//        selectSort(arr);</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">80000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">80000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//生成[0,80000)之间的数</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取开始时间</span>
        <span class="token function">selectSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> endTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取开始时间</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序运行时间为"</span><span class="token operator">+</span><span class="token punctuation">(</span>endTime<span class="token operator">-</span>startTime<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"毫秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> min<span class="token punctuation">;</span>
        <span class="token keyword">int</span> minIndex<span class="token punctuation">;</span>
        <span class="token comment">//大循环，【数组大小-1】次</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//位置i是假定最小数</span>
            min <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            minIndex <span class="token operator">=</span>i<span class="token punctuation">;</span>
            <span class="token comment">//小循环，找到最小数，从假定最小数的后一个位置【i+1】到【数组末尾】比较</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>min<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//如果有比假定最小数小的数，【重新记录】最小数的位置和大小</span>
                    min<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    minIndex<span class="token operator">=</span>j<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//如果最小数和假定最小数位置不一样，则交换它们的位置</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>minIndex<span class="token operator">!=</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token comment">//        System.out.println("排序后数组：");</span>
<span class="token comment">//        System.out.println(Arrays.toString(arr));</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>运行结果：<br> <img src="https://images2.imgbox.com/9c/d8/Q8p7XZ6b_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="66_Insertion_Sorting_302"></a>6.6 插入排序（Insertion Sorting）</h3> 
<h4><a id="661_303"></a>6.6.1基本介绍</h4> 
<p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</p> 
<h4><a id="662__305"></a>6.6.2 插入排序思想</h4> 
<p>插入排序（Insertion Sorting）的基本思想是：<strong>把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素</strong>，无序表中包含有 **n-1 个元素，**排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p> 
<p><img src="https://images2.imgbox.com/92/4a/mslOtu5G_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="663__310"></a>6.6.3 插入排序思路分析图</h4> 
<p><img src="https://images2.imgbox.com/a6/d9/D4VLKNSH_o.png" alt="在这里插入图片描述"><br> 感觉老师的推导解释不如大话数据结构的扑克容易理解。<br> 大话数据结构的解释：</p> 
<p><img src="https://images2.imgbox.com/32/82/BSpBdtui_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8a/e7/ylMZQEhN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a3/f5/G9qYbUu9_o.png" alt="在这里插入图片描述"><br> 小结：<br> 大话数据结构的哨兵在数组0的位置，使用起来不方便，我们可以不这样写，而是另外创建一个变量insertVal来保存待插入的值。</p> 
<ol><li>假定数组第一个数（坐标0）是有序的，所以要将坐标为【1】一直到到【数组末尾的数】进行插入。</li><li>插入时将待插入值进行【保存至insertVal】，然后从【待插入值位置insertIndex - 1的位置】依次往前比较，如果遇到的值比待插入值大，那么这个值就要往后挪一个位置【arr [insertIndex+1] = arr [insertIndex]】，然后【待插入值继续往前比较（即 insertIndex–）】，直到找到刚好比待插入值小的数的位置。</li><li>【insertIndex+1】的位置刚好就是要插入的位置，将insertVal值赋值过去即可。</li></ol> 
<h4><a id="664__324"></a>6.6.4 直接插入排序代码</h4> 
<p>直接插入排序时间复杂度O(n<sup>2</sup>)</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsetSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">insertSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">//直接插入排序</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    	<span class="token keyword">int</span> insertVal <span class="token operator">=</span><span class="token number">0</span>；
    	<span class="token keyword">int</span> insertIndex<span class="token operator">=</span><span class="token number">1</span>；
        <span class="token comment">//第0个元素有序，坐标从1到数组末尾开始插入</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//保存待插入值，防止前面的元素后移将它覆盖</span>
            insertVal <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">//待插入的位置从待插入元素的前一个位置开始比较</span>
            insertIndex <span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token comment">//如果位置&gt;=0合法且元素值大于待插入值，元素后移一位，待插入值再继续往前比较</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>insertIndex<span class="token operator">&gt;=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>insertIndex<span class="token punctuation">]</span><span class="token operator">&gt;</span>insertVal<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                arr<span class="token punctuation">[</span>insertIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>insertIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
                insertIndex<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//循环过后的位置是比待插入值小的位置，所以应该在这个位置往后一个开始插入</span>
            arr<span class="token punctuation">[</span>insertIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>insertVal<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>运行结果：<br> <img src="https://images2.imgbox.com/c4/5a/aGFjcPiU_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="665__358"></a>6.6.5 直接插入排序时间测试</h4> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">80000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">80000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//生成[0,80000)之间的数</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取开始时间</span>
        <span class="token function">insertSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> endTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取开始时间</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序运行时间为"</span><span class="token operator">+</span><span class="token punctuation">(</span>endTime<span class="token operator">-</span>startTime<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"毫秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ul><li>运行结果：<br> <img src="https://images2.imgbox.com/79/29/l3akAymi_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="67__Shell_Sort_374"></a>6.7 希尔排序（ Shell Sort）</h3> 
<h4><a id="671__375"></a>6.7.1 直接插入排序的缺点</h4> 
<p>我们看简单的插入排序可能存在的问题.<br> 数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1( 最小), 这样的过程是：<br> {2,3,4,5,6,6}<br> {2,3,4,5,5,6}<br> {2,3,4,4,5,6}<br> {2,3,3,4,5,6}<br> {2,2,3,4,5,6}<br> {1,2,3,4,5,6}<br> 结论: <strong>当需要插入的数是较小的数时，后移的次数明显增多，对 效率有影响</strong>.</p> 
<h4><a id="672__385"></a>6.7.2 希尔排序基本介绍</h4> 
<p>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种 插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为<strong>缩小增量排序</strong>。</p> 
<h4><a id="673__387"></a>6.7.3 希尔排序思想</h4> 
<p>希尔排序是把记录<strong>按下标的一定增量分组，对每组使用直接插入排序算法排序</strong>；随着增量逐渐减少，每组包含的关键词越来越多， 当<strong>增量减至 1 时</strong>，整个文件恰被分成一组，算法便终止</p> 
<h4><a id="674__389"></a>6.7.4 希尔排序的示意图</h4> 
<p><img src="https://images2.imgbox.com/31/a4/3RwhdRhh_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/16/30/Hwxeh8ke_o.png" alt="在这里插入图片描述"><br> 希尔排序在对有序序列在插入时可采用<strong>交换法或者移动法</strong>，移动法较为高效。</p> 
<ul><li>交换法代码推导<br> <img src="https://images2.imgbox.com/eb/a5/IDz2neXm_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0a/46/p7H7oMkQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ca/f6/14GU89Zb_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/25/97/vq1fZNNe_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e0/75/HfBHZ8yh_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/23/63/xNeHN5v7_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="675__401"></a>6.7.5 希尔排序代码（插入序列采用交换法）</h4> 
<pre><code class="prism language-java"><span class="token comment">//希尔排序(缩小增量排序)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShellSort</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">shellSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//在序列插入时采用交换法实现希尔排序</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>gap<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span>gap<span class="token operator">/=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//遍历各个组中的所有元素（共gap组），步长gap</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span>gap<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span>gap<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">-=</span>gap<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token comment">//如果当前元素大于加上步长后的元素，则交换位置</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&gt;</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
                        arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<ul><li>运行结果：<br> <img src="https://images2.imgbox.com/66/f6/FXAiXC2T_o.png" alt="在这里插入图片描述"><br> 时间测试：<br> <img src="https://images2.imgbox.com/e3/59/Q4DYyHan_o.png" alt="在这里插入图片描述"><br> 时间较长，这是交换法带来的缺点，所以用移动法</li></ul> 
<h4><a id="676__436"></a>6.7.6 希尔排序代码（插入序列采用移动法）</h4> 
<pre><code class="prism language-java">    <span class="token comment">//在序列插入时采用移动法实现希尔排序</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shellSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

        <span class="token comment">//增量为gap并且逐步缩小增量</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>gap<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span>gap<span class="token operator">/=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//采用插入排序法的思想，保存待插入值和下标</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span>gap<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//                int j=i;</span>
                <span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span>gap<span class="token punctuation">;</span>
<span class="token comment">//                if(arr[j]&gt;arr[j+gap]){<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&gt;</span>temp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//前面的数组认为有序，因此只有比有序数组最后一个小才才有向前比的必要，否则，没必要往前比</span>
                    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&gt;</span>temp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                        j<span class="token operator">-=</span>gap<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">//当退出while循环后，就给temp找到了位置</span>
                    arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  
</code></pre> 
<ul><li>运行结果：<br> <img src="https://images2.imgbox.com/2c/0d/Jmu2Y6Tu_o.png" alt="在这里插入图片描述"></li><li>时间测试：<br> <img src="https://images2.imgbox.com/70/c5/AHY6RcYM_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="677__467"></a>6.7.7 希尔排序时间复杂度</h4> 
<p>希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得排序的效率提高。这里“增量"的选取就非常关键了。可究竟应该选取什么样的增量才是最好,目前还是一个数学难题，迄今为止还没有人找到一种最好的增量序列。不过大量的研究表明，当增量序列为 dlta[k]=2<sup>t-k+1</sup>-1(0&lt;=k&lt;=t≤⌊ log<sub>2</sub>(n+1)⌋时，可以获得不错的效果，其时间复杂度为O(n<sup>3/2</sup>)，要好于直接排序的O(n<sup>2</sup>)。需要注意：<strong>增量序列的最后一个增量值必须等于1才行</strong>。另外由于记录是跳跃式的移动，希尔排序不是一种稳定的排序算法。</p> 
<h3><a id="68__Quick_Sort_470"></a>6.8 快速排序（ Quick Sort）</h3> 
<h4><a id="681__471"></a>6.8.1 快速排序基本介绍</h4> 
<p>快速排序（Quicksort）是对<strong>冒泡排序</strong>的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序， <strong>整个排序过程可以递归进行</strong>，以此达到整个数据变成有序序列。</p> 
<h4><a id="682__473"></a>6.8.2 快速排序示意图</h4> 
<p><img src="https://images2.imgbox.com/c0/c2/xD8yeCsJ_o.png" alt="希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种 插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为**缩小增量排序**。"><br> <img src="https://images2.imgbox.com/41/27/OtDcUIBy_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="683__477"></a>6.8.3 快速排序代码</h4> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">78</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">567</span><span class="token punctuation">,</span><span class="token number">70</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> temp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//pivot是中轴值的意思</span>
        <span class="token keyword">int</span> pivot <span class="token operator">=</span>arr<span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> l <span class="token operator">=</span>left<span class="token punctuation">;</span>
        <span class="token keyword">int</span> r <span class="token operator">=</span>right<span class="token punctuation">;</span>
        <span class="token comment">//while循环将比pivot小的值放pivot左边，比它大的放右边</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//在pivot左边一直找，找到比它大的为止</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">&lt;</span>pivot<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                l<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//在pivot右边一直找，找到比它小的为止</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">&gt;</span>pivot<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                r<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//如果lr坐标发生重叠，说明pivot左边的都比他小，右边的都比他大，目的达成，退出此while循环</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">&gt;=</span>r<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//通过temp将比pivot大的数往右边换，小的数往左边换</span>
            temp <span class="token operator">=</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>
            <span class="token comment">//如果有一个指针指向了中轴值，那么另一个指针应该向中间挪动一次</span>
            <span class="token comment">// 防止进入中轴值和另一个数一直交换的死循环</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">==</span>pivot<span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">==</span>pivot<span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//退出while循环证明：pivot左边的都比他小，右边的都比他大，</span>
        <span class="token comment">//则需要进行pivot的左右递归来进行下一步排序</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            l<span class="token operator">++</span><span class="token punctuation">;</span>
            r<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>r<span class="token punctuation">)</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token operator">&gt;</span>l<span class="token punctuation">)</span><span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>l<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<ul><li>运行结果：<br> <img src="https://images2.imgbox.com/08/b5/9Rgo1nC2_o.png" alt="在这里插入图片描述"><br> 时间测试：<br> <img src="https://images2.imgbox.com/a2/1c/RqZfdXOy_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="69__Merging_Sort_531"></a>6.9 归并排序（ Merging Sort）</h3> 
<h4><a id="691__532"></a>6.9.1 归并排序基本介绍</h4> 
<p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的 <strong>分治</strong> （divide-and-conquer ）策略（分治法将问题分(divide)成一些 <strong>小的问题然后递归求解</strong>，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。</p> 
<h4><a id="692_1_534"></a>6.9.2 归并排序示意图1-基本思想</h4> 
<p><img src="https://images2.imgbox.com/d6/9c/mCVuDr5U_o.png" alt="在这里插入图片描述"><br> 现将数组分两部分，再分两部分。。。分的部分只是单纯的分开，为了给后面的“治”提供一个递归的条件。分阶段来理解为递归拆分子序列的过程。</p> 
<h4><a id="693__2_537"></a>6.9.3 归并排序思想示意图 2-合并相邻有序子序列:</h4> 
<p>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。左边有序序列的指针i，右边有序序列的指针 j。<br> <img src="https://images2.imgbox.com/42/9b/EJITjBHm_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="694__540"></a>6.9.4 归并排序代码</h4> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//        int[] arr = new int[8];</span>
<span class="token comment">//        for (int i=0;i&lt;arr.length;i++){<!-- --></span>
<span class="token comment">//            arr[i]=(int)(Math.random()*arr.length);</span>
<span class="token comment">//        }</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//归并排序需要额外空间</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//分+合并的方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token comment">向左递归进行分解</span>
            <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//向右递归进行分解</span>
            <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//合并</span>
            <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * @Param: arr 待排序数组
     * @Param: left 左边有序序列的初始索引
     * @Param: mid 中间索引
     * @Param: right 右边索引
     * @Param: temp  做中转的数组
     */</span>
    <span class="token comment">//合并的方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> left <span class="token punctuation">,</span><span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>


        <span class="token keyword">int</span> i <span class="token operator">=</span>left<span class="token punctuation">;</span><span class="token comment">//  初始化 i, 左边有序序列的初始索引</span>
        <span class="token keyword">int</span> j<span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 初始化 j, 右边有序序列的初始索引</span>
        <span class="token keyword">int</span> t <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//中转数组temp的坐标</span>

        <span class="token comment">//一、将左边序列与右边序列相比较，小的放进temp数组</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//二、将未放完的序列全部放入temp数组中</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token comment">//将中转temp数组内容从0放回arr的tempLeft位置（左边序列的初始索引）,注意，并不是每次都拷贝所有</span>
        t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> tempLeft<span class="token operator">=</span>left<span class="token punctuation">;</span><span class="token comment">//开始放入</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>tempLeft<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            arr<span class="token punctuation">[</span>tempLeft<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>运行结果：<br> <img src="https://images2.imgbox.com/58/c9/glopYySV_o.png" alt="在这里插入图片描述"></li></ul> 
<p>时间测试：<br> <img src="https://images2.imgbox.com/c0/b0/Rd3XH2MC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="610__Radix_sort_Sort_613"></a>6.10 基数排序（ Radix sort Sort）</h3> 
<h4><a id="6101__614"></a>6.10.1 基数排序基本介绍</h4> 
<ol><li>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾<br> 名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</li><li>基数排序法是属于稳定性的排序，基数排序法的是效率高的 稳定性排序法</li><li>基数排序(Radix Sort)是桶排序的扩展</li><li>基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：<strong>将整数按位数切割成不同的数字，然后按每个位数分别比较</strong>。</li></ol> 
<h4><a id="6102__621"></a>6.10.2 基数排序基本思想</h4> 
<ul><li>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li></ul> 
<h4><a id="6103__623"></a>6.10.3 基数排序示意图</h4> 
<p>将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序<br> 假设有10个桶（图中蓝色矩形），一个桶就是一个数组，一行桶就是个二维数组。<br> 第一轮排序：</p> 
<ol><li>将每个元素的个位数取出，然后看这个数应该放在哪个对应的桶。如53的个位数是3，则53放在下标为3的桶，其他数相同。</li><li>按照这个桶的顺序（即按照桶的下标依次取出数据，放入原来的数组）。</li><li>第一轮排序后依次取出arr={542,53,3,14,214,748}</li></ol> 
<p>第二轮排序：<br> 4. 将每个元素的十位数取出，然后看这个数应该放在哪个对应的桶。如543的十位数是4，则542放在下标为4的桶，其他数相同，3没有十位数，因此放在0号桶。<br> 5. 按照这个桶的顺序（即按照桶的下标依次取出数据，放入原来的数组）。<br> 6. 第二轮排序后依次取出arr={3,14,214,52,748,53}<br> <img src="https://images2.imgbox.com/bb/f3/GsgwLmvd_o.png" alt="在这里插入图片描述"></p> 
<p>第三轮排序：</p> 
<ol><li>将每个元素的百位数取出，然后看这个数应该放在哪个对应的桶。如3，14没有百位数，放入0，214百位数是2，放入2号桶。</li><li>按照这个桶的顺序（即按照桶的下标依次取出数据，放入原来的数组）。</li><li>第三轮排序后依次取出arr={3,14,53,214,542,748}<br> <img src="https://images2.imgbox.com/b8/13/09ESVYVF_o.png" alt="在这里插入图片描述"><br> 因为最大数是三位数，所以只需要比到百位数，即三轮排序后结束排序。<br> 每个桶的大小都为arr.length，因此基数排序是用空间换时间的经典算法。</li></ol> 
<h4><a id="6104__644"></a>6.10.4 基数排序代码</h4> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RadixSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span> <span class="token punctuation">]</span> arr <span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">53</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">542</span><span class="token punctuation">,</span><span class="token number">748</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">214</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//        int[] arr =new int[80000];</span>
<span class="token comment">//        for (int i=0;i&lt;arr.length;i++){<!-- --></span>
<span class="token comment">//            arr[i] = (int)(Math.random()*80000);//生成[0,80000)之间的数</span>
<span class="token comment">//        }</span>
<span class="token comment">//</span>
<span class="token comment">//        long startTime = System.currentTimeMillis();//获取开始时间</span>
<span class="token comment">//        radixSort(arr);</span>
<span class="token comment">//        long endTime = System.currentTimeMillis();//获取开始时间</span>
<span class="token comment">//        System.out.println("程序运行时间为"+(endTime-startTime)+"毫秒");</span>

        <span class="token function">radixSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

        <span class="token comment">//一维桶的个数应该是覆盖每个位置上可能出现的数字，为0-9，10个数，所以一维桶的个数是10</span>
        <span class="token comment">//每个一维桶的大小应该为待排序数组含有元素的个数，所以是基数排序是用空间换时间的典型算法。</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numInBucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//记录对应序号桶中放入数的个数</span>

        <span class="token comment">//遍历找到最大的数</span>
        <span class="token keyword">int</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>max<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                max <span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//根据最大数来确定比的轮数</span>
        <span class="token keyword">int</span> turn <span class="token operator">=</span> <span class="token punctuation">(</span>max<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//i控制比较轮数，j用来取数据的个十百千位</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>turn<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">=</span>j<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

            <span class="token comment">//依次取出数组同一个位的数来放入对应桶中，第一轮取出个位，第二轮取出十位，第三轮取出百位</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> bucketNo <span class="token operator">=</span> arr<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">/</span> j <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">// 第一轮 748/1%10 =8（取出个位） 第二轮 748/10% =4（取出百位）</span>
                <span class="token comment">//将数放入对应的桶中</span>
                bucket<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span><span class="token punctuation">[</span>numInBucket<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>

                <span class="token comment">//对应序号桶中放入数的个数+1</span>
                numInBucket<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span><span class="token operator">=</span>numInBucket<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//index用来指示从桶中取出的数应该放回arr的哪个地方</span>
            <span class="token keyword">int</span> index <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>t<span class="token operator">&lt;</span>numInBucket<span class="token punctuation">.</span>length<span class="token punctuation">;</span>t<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>numInBucket<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

                    <span class="token comment">//将对应桶内的数字放回数组</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span> numInBucket<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
                        index<span class="token operator">++</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                numInBucket<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
<span class="token comment">//            System.out.println("第"+(i+1)+"轮结果："+Arrays.toString(arr));</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>运行结果：<br> <img src="https://images2.imgbox.com/bc/d7/AHZPZmy4_o.png" alt="在这里插入图片描述"></li></ul> 
<p>时间测试：<br> <img src="https://images2.imgbox.com/0a/f8/aLF2FXIW_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="101__716"></a>10.1 堆排序</h3> 
<h4><a id="1011__717"></a>10.1.1 堆排序基本介绍</h4> 
<ol><li>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为 O(nlogn)，它也是不稳定排序。</li><li>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。</li><li>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</li><li>大顶堆举例说明<br> 完全二叉树最好的存储方式就是用数组，因为用数组的标号可以直接反映叶子结点和双亲结点<br> 如果从0开始编号，那么标号i的左孩子2<em>i+1，右孩子2</em>i+2。<br> <img src="https://images2.imgbox.com/73/76/aglPCThQ_o.png" alt="在这里插入图片描述"></li><li>小顶堆举例说明<br> <img src="https://images2.imgbox.com/0c/2c/Xi8xIJ8a_o.png" alt="在这里插入图片描述"></li><li>一般<strong>升序</strong>采用<strong>大顶堆</strong>，<strong>降序</strong>采用<strong>小顶堆</strong></li></ol> 
<h4><a id="1012__728"></a>10.1.2 堆排序基本思想</h4> 
<p>堆排序的基本思想是：</p> 
<ol><li>将待排序序列构造成一个大顶堆</li><li>此时，整个序列的最大值就是堆顶的根节点。</li><li>将其与末尾元素进行交换，此时末尾就为最大值。</li><li>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了。<br> 可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</li></ol> 
<h4><a id="1013__735"></a>10.1.3 堆排序步骤图解说明</h4> 
<p>要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。</p> 
<p>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。原始的数组 [4, 6, 8, 5, 9]</p> 
<ol><li>.假设给定无序序列结构如下<br> <img src="https://images2.imgbox.com/c9/e4/gnlc5ISP_o.png" alt="在这里插入图片描述"></li><li>.我们将序列变成一个大顶堆，其实就是<strong>从下往上、从右到左，将每个非终端结点（非叶结点）当做根结点，将其和子树调整成大顶堆</strong>。由完全二叉树的性质：<br> <img src="https://images2.imgbox.com/16/c8/npf8RhiZ_o.png" alt="在这里插入图片描述"></li></ol> 
<ul><li>性质：二叉树的根结点从0开始编号，则i号结点的双亲编号为【<code>(i-1)/2</code>】，左孩子的编号为【<code>2i+1</code>】，右孩子的编号为【<code>2i+2</code>】。</li></ul> 
<p>从下到上，从右到左处理第一个非叶结点：</p> 
<ul><li>首先，从下到上，从左到右的第一个非叶结点是最后一个结点的双亲。</li><li>下标从0开始，一共有arr.length个元素，最后一个结点的编号是 i = arr.length-1，由性质，它的双亲编号是(i-1)/2=( arr.length-1-1)/2=arr.length/2-1。</li><li>因此我们从最后一个非叶结点（标号arr.length/2-1=5/2-1=2-1=1号）开始从下往上、从右到左当做根结点进行调整，但是<strong>调整时是从所定的根结点开始从上到下来调整的，调整的范围是被改动过的范围</strong>。</li><li>1号结点的值是6，根据大顶堆的定义，大顶堆根结点值要大于等于它的孩子结点，因此将6与它的左右孩子5和9中较大者进行比较即可，9&gt;5，因此根结点6与9比较，6&lt;9，因此这个根树中6和9互换位置完成这个根结点的大顶堆。<br> <img src="https://images2.imgbox.com/2c/10/ZvtLALmN_o.png" alt="在这里插入图片描述"></li></ul> 
<ol start="3"><li>.找到第二个非叶节点，它的标号是【上一个非叶结点标号 - 1】 即【1-1=0】号，值为4，同理，由于[4,9,8]中左孩子 9 最大，根4 和 9 交换。<br> <img src="https://images2.imgbox.com/1a/5f/U94cgkpv_o.png" alt="在这里插入图片描述"></li><li>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6。<br> <img src="https://images2.imgbox.com/d7/5c/WUmgNB8b_o.png" alt="在这里插入图片描述"><br> 此时，我们就将一个无序序列构造成了一个大顶堆。</li></ol> 
<ul><li>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</li></ul> 
<ol><li>.将堆顶元素 9 和末尾元素 4 进行交换<br> <img src="https://images2.imgbox.com/3e/65/v0IDDukM_o.png" alt="在这里插入图片描述"></li><li>.重新调整结构，使其继续满足堆定义<br> <img src="https://images2.imgbox.com/0b/8a/Z5dY5lWz_o.png" alt="在这里插入图片描述"></li><li>.再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.<br> <img src="https://images2.imgbox.com/ca/ff/kk2VTQ0v_o.png" alt="在这里插入图片描述"></li><li>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序<br> <img src="https://images2.imgbox.com/f5/5a/oKleVgJR_o.png" alt="在这里插入图片描述"><br> 再简单总结下堆排序的基本思路：<br> 1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;<br> 2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;<br> 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</li></ol> 
<h4><a id="1014__769"></a>10.1.4 堆排序代码</h4> 
<p>二叉树用顺序存储的数组实现，标号从0开始</p> 
<ul><li>从右到左，从下到上取非叶结点为根将其调整为一个大顶堆（adjustHeap），【右→左，下→上】-&gt;【arr.length/2-1 递减→标号0】<br> 重复以下过程：</li><li>顶端（标号0）与末尾j的元素交换，这些元素中最大值被沉到末尾“取出”，所以末尾向前定义一位【j- -】</li><li>将剩余的元素继续调整为大顶堆</li><li>直到末尾 j=0</li></ul> 
<p>循环调整为大顶堆（adjustHeap）的过程：</p> 
<ul><li>指针i指向【要调整的位置】，开始是【根的位置】，将根的值存入【temp】</li><li>循环调整开始：</li><li>指针k指向值较大的左或右孩子结点（如果有左右孩子的话），因此k以【2*k+1】方式递增</li><li>判断是否有右孩子，如果有，则将k指向值较大的孩子</li><li>判断【temp】与孩子谁大：</li><li> 
  <ol><li>孩子大，不符合大顶堆定义，需要调整，指针i指向【要调整的位置】,因此将孩子的值给要调整的位置 arr[i] =arr[k]，孩子的位置发生了改变，需要以孩子为根向下重新调整，因此将孩子的位置赋值给要调整的位置 i=k，进入下一轮循环。</li></ol> </li><li> 
  <ol start="2"><li>temp大，即temp已经大于左右孩子，复合大顶堆的定义，无需调整，退出循环。</li></ol> </li><li>循环过后：</li><li>i已经指向了需要调整的最终位置，将temp值放入位置i</li></ul> 
<p>调整为大顶堆的过程类似将最开始的根值temp备份视为第一个要调整的位置，然后从其孩子开始看，如果temp值比大孩子的值小，那么孩子的值先拽过去覆盖原来要调整的位置，同时这个孩子的位置变为下一个待调整位置，从孩子的孩子继续看，一直这样有大的就拽上来，最终一直到temp大于它的左右孩子结点，符合大顶堆的定义，那么就可以退出循环，将temp值放入上一次的待调整位置。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">heapSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">//从右到左，从下到上的第一个非叶结点开始先调整为一个大顶堆</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//调整后将大顶堆的顶端与当前末尾交换位置，继续调整为大顶堆</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//将数组arr[]，非叶结点标号i,元素最大标号length</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">adjustHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">//i指向【要调整的位置】，开始是根结点的位置</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将根结点的值进行存储</span>
        <span class="token comment">//从2*i+1是标号i的左孩子,k指向值较大的左孩子或者右孩子</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>length<span class="token punctuation">;</span>k<span class="token operator">=</span>k<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;=</span>length <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                k<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//如果右孩子大于左孩子，那么k指向右孩子</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//如果左或右孩子的值大于根的值，不符合大顶堆，需要调整</span>
            <span class="token comment">//将孩子值赋值给待调整位置的值，相当于我们对【以孩子为根的树】进行了调整，所以将i指向孩子的位置k</span>
            <span class="token comment">//进行下一轮调整</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&gt;</span>temp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
                i<span class="token operator">=</span>k<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
               <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//如果左或右孩子的值小于根的值，符合大顶堆，无需调整，退出循环</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//循环过后，i已经指向了最后的待调整位置，将temp放入</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_837"></a>堆排序的应用</h3> 
<h3><a id="1__Top_K_838"></a>1. 利用堆求 Top K</h3> 
<p>我把这种求 Top K 的问题抽象成两类。一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。另一类是针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。</p> 
<p>针对静态数据，如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出取数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK) 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，所以时间复杂度就是 O(nlogK)。</p> 
<p>针对动态数据求得 Top K 就是实时 Top K。怎么理解呢？我举一个例子。一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前 K 大数据。如果每次询问前 K 大数据，我们都基于当前的数据重新计算的话，那时间复杂度就是O(nlogK)，n 表示当前的数据的大小。实际上，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以里立刻返回给他。</p> 
<h3><a id="2_844"></a>2.堆的应用三：利用堆求中位数</h3> 
<p>我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。</p> 
<h3><a id="611__847"></a>6.11 常用排序算法总结和对比</h3> 
<h4><a id="6111__848"></a>6.11.1 一张排序算法的比较图</h4> 
<p><img src="https://images2.imgbox.com/45/45/SUXLP86e_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="6112__850"></a>6.11.2 相关术语解释：</h4> 
<ol><li>稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；</li><li>不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面；</li><li>内排序：所有排序操作都在内存中完成；</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度： 一个算法执行所耗费的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 不占用额外内存</li><li>Out-place: 占用额外内存</li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/439725e4a4fabd17847e91facb3cde1c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">04 递归问题【数据结构与算法学习笔记(Java)】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a99a9910820cd0ec49e57d1bac2fff1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">10. 多路查找树【数据结构与算法学习笔记(Java)】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>