<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vivado 下 IP核之双端口 RAM 读写 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vivado 下 IP核之双端口 RAM 读写" />
<meta property="og:description" content="目录
Vivado 下 IP核之双端口 RAM 读写
1、RAM IP 核简介
2、实验任务
3、程序设计
3.1、RAM IP 核配置
3.2、顶层模块设计
（1）绘制波形图
4、编写代码
4.1、顶层模块 ip_2port_ram
4.2、RAM 写模块设计
4.3、ram_wr 模块代码
4.4、RAM 读模块设计
4.5、ram_rd 模块代码
5、仿真验证
5.1、编写 TB 文件
5.2、仿真验证
6、下载验证
6.1、引脚约束
6.2、添加 ILA IP 核进行在线调试
6.3、上板验证
7、本章总结
Vivado 下 IP核之双端口 RAM 读写 1、RAM IP 核简介 双端口 RAM 是指拥有两个读写端口的 RAM，有伪双端口 RAM（一个端口只能读，另一个端口只能写）和真双端口 RAM（两个端口都可以进行读写操作）之分。一般当我们需要同时对存储器进行读写操作时会使用到双端口 RAM，例如有一个 FIFO 存储器，我们需要同时对其进行数据的写入和读出，这时候就需要一个写端口和一个读端口了。接下来我们看下双端口 RAM 的框图。 在上一章中我们介绍过了单端口 RAM 的框图，本章将带着大家一起了解一下双端口 RAM 的框图，为 了方便大家进行对比，这里我们将上一章介绍的单端口 RAM 的框图也展示出来，如下图所示：
首先介绍的是简单双端口（也称为伪双端口）RAM，需要注意的是简单双端口 RAM 的端口 A 只能写不能读，端口 B 只能读不能写。BMG IP 核配置成简单双端口 RAM 的框图如下图所示。 与单端口 RAM 不同的是， 伪双端口 RAM 输入有两路时钟信号 CLKA/CLKB；独立的两组地址信号 ADDRA/ADDRB；Port A 仅提供 DINA 写数据总线，作为数据的写入口；Port B 仅提供数据读的功能，读出的数据为 DOUTB。这里我们仅对新出现的信号进行讲解，其它信号在单端口 RAM 中已经讲解过了，其中不同端口的同名（同功能）信号以 A 和 B 做为区分，各个新端口（这些信号很少使用，我们一般不用关注）的功能描述如下： INJECTSBITERR：Inject Single-Bit Error 的简写，即注入单 bit 错误，仅适用于 Xilinx Zynq-7000 和 7 系列芯片的 ECC 配置。 INJECTDBITERR：Inject Double-Bit Error 的简写，即注入双 bit 错误，同样仅适用于 Xilinx Zynq-7000 和 7 系列芯片的 ECC 配置。 SBITERR：Single-Bit Error 的简写，即单 bit 错误，标记内存中存在的单 bit 错误，该错误已在输出总线上自动更正。 DBITERR：Double-Bit Error 的简写，即双 bit 错误，标记内存中存在双 bit 错误，需要注意的是内置的ECC 解码模块不能自动纠正双 bit 错误。 RDADDRECC：Read Address for ECC Error output 的简写，即读地址 ECC 错误输出，同样仅适用于 Xilinx Zynq-7000 和 7 系列芯片的 ECC 配置。 接着介绍一下真双端口 RAM，其两个端口（A 和 B）均可进行读/写操作。BMG IP 核配置成真双端口 RAM 的框图如下图所示。 真双端口 RAM 提供了两个独立的读写端口（A 和 B），既可以同时读，也可以同时写，也可以一个读一个写。通过框图对比可以发现，真双端口 RAM 只是将单端口 RAM 的所有信号做了一个复制处理，不同端口的同一信号以 A 和 B 作为区分，所以这里我们就不再赘述各个端口的功能了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/6c44eedd9c05ed9dbfb8f85c8961e2e2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-20T20:18:03+08:00" />
<meta property="article:modified_time" content="2023-11-20T20:18:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vivado 下 IP核之双端口 RAM 读写</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="Vivado%20%E4%B8%8B%20IP%E6%A0%B8%E4%B9%8B%E5%8F%8C%E7%AB%AF%E5%8F%A3%20RAM%20%E8%AF%BB%E5%86%99-toc" style="margin-left:0px;"><a href="#Vivado%20%E4%B8%8B%20IP%E6%A0%B8%E4%B9%8B%E5%8F%8C%E7%AB%AF%E5%8F%A3%20RAM%20%E8%AF%BB%E5%86%99" rel="nofollow">Vivado 下 IP核之双端口 RAM 读写</a></p> 
<p id="1%E3%80%81RAM%20IP%20%E6%A0%B8%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#1%E3%80%81RAM%20IP%20%E6%A0%B8%E7%AE%80%E4%BB%8B" rel="nofollow">1、RAM IP 核简介</a></p> 
<p id="2%E3%80%81%E5%AE%9E%E9%AA%8C%E4%BB%BB%E5%8A%A1-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%AE%9E%E9%AA%8C%E4%BB%BB%E5%8A%A1" rel="nofollow">2、实验任务</a></p> 
<p id="3%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" rel="nofollow">3、程序设计</a></p> 
<p id="3.1%E3%80%81RAM%20IP%20%E6%A0%B8%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#3.1%E3%80%81RAM%20IP%20%E6%A0%B8%E9%85%8D%E7%BD%AE" rel="nofollow">3.1、RAM IP 核配置</a></p> 
<p id="3.2%E3%80%81%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1-toc" style="margin-left:80px;"><a href="#3.2%E3%80%81%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1" rel="nofollow">3.2、顶层模块设计</a></p> 
<p id="%EF%BC%881%EF%BC%89%E7%BB%98%E5%88%B6%E6%B3%A2%E5%BD%A2%E5%9B%BE-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E7%BB%98%E5%88%B6%E6%B3%A2%E5%BD%A2%E5%9B%BE" rel="nofollow">（1）绘制波形图</a></p> 
<p id="4%E3%80%81%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81" rel="nofollow">4、编写代码</a></p> 
<p id="4.1%E3%80%81%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97%C2%A0ip_2port_ram-toc" style="margin-left:80px;"><a href="#4.1%E3%80%81%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97%C2%A0ip_2port_ram" rel="nofollow">4.1、顶层模块 ip_2port_ram</a></p> 
<p id="4.2%E3%80%81RAM%20%E5%86%99%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1-toc" style="margin-left:80px;"><a href="#4.2%E3%80%81RAM%20%E5%86%99%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1" rel="nofollow">4.2、RAM 写模块设计</a></p> 
<p id="4.3%E3%80%81ram_wr%20%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#4.3%E3%80%81ram_wr%20%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81" rel="nofollow">4.3、ram_wr 模块代码</a></p> 
<p id="4.4%E3%80%81RAM%20%E8%AF%BB%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1-toc" style="margin-left:80px;"><a href="#4.4%E3%80%81RAM%20%E8%AF%BB%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1" rel="nofollow">4.4、RAM 读模块设计</a></p> 
<p id="4.5%E3%80%81ram_rd%20%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#4.5%E3%80%81ram_rd%20%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81" rel="nofollow">4.5、ram_rd 模块代码</a></p> 
<p id="5%E3%80%81%E4%BB%BF%E7%9C%9F%E9%AA%8C%E8%AF%81-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E4%BB%BF%E7%9C%9F%E9%AA%8C%E8%AF%81" rel="nofollow">5、仿真验证</a></p> 
<p id="5.1%E3%80%81%E7%BC%96%E5%86%99%20TB%20%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#5.1%E3%80%81%E7%BC%96%E5%86%99%20TB%20%E6%96%87%E4%BB%B6" rel="nofollow">5.1、编写 TB 文件</a></p> 
<p id="5.2%E3%80%81%E4%BB%BF%E7%9C%9F%E9%AA%8C%E8%AF%81-toc" style="margin-left:80px;"><a href="#5.2%E3%80%81%E4%BB%BF%E7%9C%9F%E9%AA%8C%E8%AF%81" rel="nofollow">5.2、仿真验证</a></p> 
<p id="6%E3%80%81%E4%B8%8B%E8%BD%BD%E9%AA%8C%E8%AF%81-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E4%B8%8B%E8%BD%BD%E9%AA%8C%E8%AF%81" rel="nofollow">6、下载验证</a></p> 
<p id="6.1%E3%80%81%E5%BC%95%E8%84%9A%E7%BA%A6%E6%9D%9F-toc" style="margin-left:80px;"><a href="#6.1%E3%80%81%E5%BC%95%E8%84%9A%E7%BA%A6%E6%9D%9F" rel="nofollow">6.1、引脚约束</a></p> 
<p id="6.2%E3%80%81%E6%B7%BB%E5%8A%A0%20ILA%C2%A0IP%20%E6%A0%B8%E8%BF%9B%E8%A1%8C%E5%9C%A8%E7%BA%BF%E8%B0%83%E8%AF%95-toc" style="margin-left:80px;"><a href="#6.2%E3%80%81%E6%B7%BB%E5%8A%A0%20ILA%C2%A0IP%20%E6%A0%B8%E8%BF%9B%E8%A1%8C%E5%9C%A8%E7%BA%BF%E8%B0%83%E8%AF%95" rel="nofollow">6.2、添加 ILA IP 核进行在线调试</a></p> 
<p id="6.3%E3%80%81%E4%B8%8A%E6%9D%BF%E9%AA%8C%E8%AF%81-toc" style="margin-left:80px;"><a href="#6.3%E3%80%81%E4%B8%8A%E6%9D%BF%E9%AA%8C%E8%AF%81" rel="nofollow">6.3、上板验证</a></p> 
<p id="7%E3%80%81%E6%9C%AC%E7%AB%A0%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E6%9C%AC%E7%AB%A0%E6%80%BB%E7%BB%93" rel="nofollow">7、本章总结</a></p> 
<hr id="hr-toc"> 
<h2><span style="color:#0d0016;">Vivado 下 IP核之双端口 RAM 读写</span></h2> 
<h3 id="1%E3%80%81RAM%20IP%20%E6%A0%B8%E7%AE%80%E4%BB%8B"><span style="color:#000000;"><strong>1、RAM IP </strong></span><span style="color:#000000;"><strong>核简介 </strong></span></h3> 
<p><span style="color:#000000;">     <strong><span style="background-color:#ffd900;">  双端口 RAM </span></strong></span><strong><span style="color:#000000;"><span style="background-color:#ffd900;">是指拥有两个读写端口的 </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">RAM</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">，有伪双端口 </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">RAM</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">（一个端口只能读，另一个端口只能写）和真双端口 RAM</span></span></strong><span style="color:#000000;"><strong><span style="background-color:#ffd900;">（两个端口都可以进行读写操作）之分</span></strong>。一般当我们<strong><span style="background-color:#a2e043;">需要同时对存储器进行读写操作时会使用到双端口 RAM</span></strong></span><span style="color:#0d0016;"><span style="background-color:#38d8f0;">，</span></span><span style="color:#000000;"><strong><span style="background-color:#38d8f0;">例如有一个 </span></strong></span><strong><span style="color:#000000;"><span style="background-color:#38d8f0;">FIFO </span></span></strong><span style="color:#000000;"><strong><span style="background-color:#38d8f0;">存储器，我们需要同时对其进行数据的写入和读出，这时候就需要一个写端口和一个读端口了。</span></strong>接下来我们看下双端口 RAM </span><span style="color:#000000;">的框图。 </span></p> 
<p><span style="color:#000000;">       在上一章中我们介绍过了单端口 RAM </span><span style="color:#000000;">的框图，本章将带着大家一起了解一下双端口 </span><span style="color:#000000;">RAM </span><span style="color:#000000;">的框图，为 了方便大家进行对比，这里我们将上一章介绍的单端口 RAM </span><span style="color:#000000;">的框图也展示出来，如下图所示：</span></p> 
<p><img alt="" height="235" src="https://images2.imgbox.com/67/76/5p9QUsgE_o.png" width="494"></p> 
<p>       <span style="color:#000000;">首先介绍的是<strong>简单双端口（也称为伪双端口）RAM，需要注意的是简单双端口 </strong></span><strong><span style="color:#000000;">RAM </span><span style="color:#000000;">的端口 </span><span style="color:#000000;">A </span><span style="color:#000000;">只能写不能读，端口 B </span><span style="color:#000000;">只能读不能写。</span></strong><span style="color:#000000;">BMG IP </span><span style="color:#000000;">核配置成简单双端口 </span><span style="color:#000000;">RAM </span><span style="color:#000000;">的框图如下图所示。 </span></p> 
<p><img alt="" height="318" src="https://images2.imgbox.com/c5/13/wXEP5fdw_o.png" width="493"></p> 
<p>       <span style="color:#000000;">与单端口 RAM 不同的是，<strong><span style="background-color:#ffd900;">   伪双端口 </span></strong></span><strong><span style="color:#000000;"><span style="background-color:#ffd900;">RAM </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">输入有两路时钟信号 </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">CLKA/CLKB</span></span></strong><span style="color:#000000;"><span style="background-color:#ffd900;">；独立的两组地址信号 ADDRA/ADDRB；</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">Port A </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">仅提供 </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">DINA </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">写数据总线，作为数据的写入口；</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">Port B </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">仅提供数据读的功能，读出的数据为 DOUTB</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">。</span>这里我们仅对新出现的信号进行讲解，其它信号在单端口 </span><span style="color:#000000;">RAM </span><span style="color:#000000;">中已经讲解过了，其中不同端口的同名（同功能）信号以 A </span><span style="color:#000000;">和 </span><span style="color:#000000;">B </span><span style="color:#000000;">做为区分，各个新端口（这些信号很少使用，我们一般不用关注）的功能描述如下： </span></p> 
<ul><li><span style="color:#000000;">INJECTSBITERR：</span><span style="color:#000000;">Inject Single-Bit Error </span><span style="color:#000000;">的简写，即注入单 </span><span style="color:#000000;">bit </span><span style="color:#000000;">错误，仅适用于 </span><span style="color:#000000;">Xilinx Zynq-7000 </span><span style="color:#000000;">和 </span><span style="color:#000000;">7 </span><span style="color:#000000;">系列芯片的 ECC </span><span style="color:#000000;">配置。 </span></li><li><span style="color:#000000;">INJECTDBITERR：</span><span style="color:#000000;">Inject Double-Bit Error </span><span style="color:#000000;">的简写，即注入双 </span><span style="color:#000000;">bit </span><span style="color:#000000;">错误，同样仅适用于 </span><span style="color:#000000;">Xilinx Zynq-7000 和 7 </span><span style="color:#000000;">系列芯片的 </span><span style="color:#000000;">ECC </span><span style="color:#000000;">配置。 </span></li><li><span style="color:#000000;">SBITERR：</span><span style="color:#000000;">Single-Bit Error </span><span style="color:#000000;">的简写，即单 </span><span style="color:#000000;">bit </span><span style="color:#000000;">错误，标记内存中存在的单 </span><span style="color:#000000;">bit </span><span style="color:#000000;">错误，该错误已在输出总线上自动更正。 </span></li><li><span style="color:#000000;">DBITERR：</span><span style="color:#000000;">Double-Bit Error </span><span style="color:#000000;">的简写，即双 </span><span style="color:#000000;">bit </span><span style="color:#000000;">错误，标记内存中存在双 </span><span style="color:#000000;">bit </span><span style="color:#000000;">错误，需要注意的是内置的ECC 解码模块不能自动纠正双 </span><span style="color:#000000;">bit </span><span style="color:#000000;">错误。 </span></li><li><span style="color:#000000;">RDADDRECC：</span><span style="color:#000000;">Read Address for ECC Error output </span><span style="color:#000000;">的简写，即读地址 </span><span style="color:#000000;">ECC </span><span style="color:#000000;">错误输出，同样仅适用于 </span><span style="color:#000000;">Xilinx Zynq-7000 和 </span><span style="color:#000000;">7 </span><span style="color:#000000;">系列芯片的 </span><span style="color:#000000;">ECC </span><span style="color:#000000;">配置。 </span></li></ul> 
<p><span style="color:#000000;">       接着介绍一下<strong>真双端口 RAM</strong></span><strong><span style="color:#000000;">，其两个端口（</span><span style="color:#000000;">A </span><span style="color:#000000;">和 </span><span style="color:#000000;">B</span><span style="color:#000000;">）均可进行读</span><span style="color:#000000;">/</span></strong><span style="color:#000000;"><strong>写操作</strong>。</span><span style="color:#000000;">BMG IP </span><span style="color:#000000;">核配置成真双端口 RAM 的框图如下图所示。 </span></p> 
<p><img alt="" height="363" src="https://images2.imgbox.com/0b/2f/2F9bx2Qo_o.png" width="508"></p> 
<p><span style="color:#000000;">       <strong>真双端口 RAM </strong></span><strong><span style="color:#000000;">提供了两个独立的读写端口（</span><span style="color:#000000;">A </span><span style="color:#000000;">和 </span><span style="color:#000000;">B</span></strong><span style="color:#000000;"><strong>），既可以同时读，也可以同时写，也可以一个读一个写。</strong>通过框图对比可以发现，真双端口 RAM </span><span style="color:#000000;">只是将单端口 </span><span style="color:#000000;">RAM </span><span style="color:#000000;">的所有信号做了一个复制处理，不同端口的同一信号以 A </span><span style="color:#000000;">和 </span><span style="color:#000000;">B </span><span style="color:#000000;">作为区分，所以这里我们就不再赘述各个端口的功能了。</span></p> 
<p><span style="color:#000000;">        下方我们列出了三种静态 RAM </span><span style="color:#000000;">的端口对比表，让大家能更直观的看出各静态 </span><span style="color:#000000;">RAM </span><span style="color:#000000;">的端口差异，其中 “√”表示有，“×”表示无。</span></p> 
<p><img alt="" height="731" src="https://images2.imgbox.com/c3/fb/JwKySCNU_o.png" width="636"></p> 
<p> <span style="color:#000000;">       通过对比我们可以发现无论是哪种双端口 RAM</span><span style="color:#000000;">，其地址线、时钟线和使能线等控制信号都有两组，所以双端口 RAM </span><span style="color:#000000;">可以实现在不同时钟域下的读</span><span style="color:#000000;">/</span><span style="color:#000000;">写，且可以同时对不同的地址进行读</span><span style="color:#000000;">/</span><span style="color:#000000;">写，这便大大提高了我们数据处理的灵活性。但是两组信号线也相应的加大了双端口 RAM </span><span style="color:#000000;">的使用难度，因为端口使能，读写使能，地址和写数据等控制信号我们都需要分别给出两组，这样才能驱使两个端口都处于我们需要的工作状态， 这里仅凭文字描述大家理解起来可能会有些吃力，所以在稍后的小节中我们会结合波形图（图 24.3.9</span><span style="color:#000000;">）进行更详细的讲解。 </span></p> 
<p><span style="color:#000000;">       <strong>需要注意的是在<span style="background-color:#a2e043;">伪双端口模式下</span>我们需<span style="background-color:#a2e043;">要避免读写冲突</span>；在<span style="background-color:#ffd900;">真双端口模式下</span>我们需<span style="background-color:#ffd900;">要避免读写冲突和</span></strong></span><span style="color:#000000;"><strong><span style="background-color:#ffd900;">写写冲突</span>。</strong>下面我们分别看下读写冲突和写写冲突是什么。</span></p> 
<p><span style="color:#000000;"><strong>1、读写冲突：即同时刻读写同一地址所出现的冲突，</strong>例如理论上我们已经向某个地址写入了新的数据，我们也希望可以同时读到这个地址内新写入的数据，但实际上，这个新数据还没有写入 RAM </span><span style="color:#000000;">中，所以我们读出来的可能是 RAM </span><span style="color:#000000;">默认值，或者是 </span><span style="color:#000000;">RAM </span><span style="color:#000000;">该地址中上一次的值，这便是读写冲突。读写冲突示意图</span><span style="color:#000000;">如下所示： </span></p> 
<p><img alt="" height="189" src="https://images2.imgbox.com/76/c4/uT87t4nG_o.png" width="617"></p> 
<p><span style="color:#000000;">       由上图可知<strong>当发生读写冲突时，读优先的模式下读出的是读地址中存储的上一个数据；写优先模式时读出的是未知的数据“XX</strong></span><span style="color:#000000;"><strong>”。</strong> </span></p> 
<p><span style="color:#000000;"><strong>2、写写冲突：表示两个端口写使能同时有效且写地址相同，此时需要关断一个写，把两个写端口都需要更新的值处理到一个写端口上。</strong>切记任何双端口 RAM </span><span style="color:#000000;">都不支持写写冲突。写写冲突示意图</span><span style="color:#000000;">如下所示</span><span style="color:#000000;">： </span></p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/7e/75/ZzGUBbyi_o.png" width="617"></p> 
<p>       <span style="color:#000000;">由上图可知当发生写写冲突时，发生冲突的地址写入的是未知的数据“XX</span><span style="color:#000000;">”。 </span></p> 
<p><span style="color:#000000;"><span style="background-color:#a2e043;">       综上可知，真双端口 RAM </span></span><span style="color:#000000;"><span style="background-color:#a2e043;">的读写更为灵活，但相应的也更加难以驾驭，因为真双端口不仅需要考虑读写冲突，还要考虑写写冲突，而在大部分设计中我们用的都是伪双端口RAM</span></span><span style="color:#000000;"><span style="background-color:#a2e043;">，所以本章我们以伪双端口</span></span><span style="color:#000000;"><span style="background-color:#a2e043;">RAM 的读写为例，讲解一下如何避免程序中的读写冲突。一般发生读写冲突的时候，我们<strong>可以通过错开读写地址的方法来避免读写冲突，</strong>我们在本次实验中所使用的就是这种方法，在后文中会进行讲解；<strong>或者通过写穿通到读方法来处理冲突数据</strong>，</span>这里我们简单做下讲解，如下图所示：</span></p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/79/5d/hmrTe5Wk_o.png" width="595"></p> 
<p>       <span style="color:#000000;">从图中我们可以看出，Cycle 2 </span><span style="color:#000000;">时，读和写地址不同，读可以正常读到数据，但是到 </span><span style="color:#000000;">Cycle 3 </span><span style="color:#000000;">时，读和写地址相同且读写都有效，此处如果不做特殊处理，那么读数据是无效的。需要我们把写数据寄存一拍同步到读侧，即把最新的写数据直接赋给读数据，这便是写穿通到读。 </span></p> 
<h3 id="2%E3%80%81%E5%AE%9E%E9%AA%8C%E4%BB%BB%E5%8A%A1"><strong>2、实验任务</strong></h3> 
<p><span style="color:#000000;">       本章实验任务是将 Xilinx BMG IP </span><span style="color:#000000;">核配置成一个同步的伪双端口 </span><span style="color:#000000;">RAM </span><span style="color:#000000;">并对其进行读写操作，然后通过仿真观察波形是否正确，最后将设计下载到 FPGA </span><span style="color:#000000;">开发板中，并通过在线调试工具对实验结果进行观察。</span></p> 
<h3 id="3%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><strong><span style="color:#0d0016;">3、<strong>程序设计</strong></span></strong></h3> 
<h4 id="3.1%E3%80%81RAM%20IP%20%E6%A0%B8%E9%85%8D%E7%BD%AE"><span style="color:#000000;"><strong>3.1、RAM IP </strong></span><span style="color:#000000;"><strong>核配置 </strong></span></h4> 
<p><span style="color:#000000;">      首先我们创建一个名为 “ip_2port_ram</span><span style="color:#000000;">” 的空白工程，然后点击 </span><span style="color:#000000;">Vivado </span><span style="color:#000000;">软件左侧“</span><span style="color:#000000;">Flow Navigator</span><span style="color:#000000;">”栏中的“IP Catalog</span><span style="color:#000000;">”，如下图所示：</span></p> 
<p><img alt="" height="193" src="https://images2.imgbox.com/17/48/ndqGfHPi_o.png" width="223"></p> 
<p><span style="color:#000000;">      在 “</span><span style="color:#000000;">IP Catalog</span><span style="color:#000000;">” 窗口的搜索栏中输入 “</span><span style="color:#000000;">Block Memory</span><span style="color:#000000;">” 关键字后，出现唯一匹配的 “</span><span style="color:#000000;">Block Memory Generator”，如下图所示（图中出现的两个 </span><span style="color:#000000;">IP </span><span style="color:#000000;">核为同一个 </span><span style="color:#000000;">BMG IP </span><span style="color:#000000;">核）：</span></p> 
<p><img alt="" height="272" src="https://images2.imgbox.com/dc/1d/GnJsMRtb_o.png" width="466"></p> 
<p><strong><span style="color:#0d0016;">      其实，前面的步骤与单端口 RAM 的配置是一样的，我们在 Memory Type 选择“Simple Dual Port RAM” 简单双端口 RAM，其余设置不变。 </span></strong></p> 
<p><span style="color:#000000;">“Basic</span><span style="color:#000000;">”选项卡配置界面如下图所示。 </span></p> 
<p><img alt="" height="552" src="https://images2.imgbox.com/6d/27/Hql5OR0O_o.png" width="569"></p> 
<p><span style="color:#000000;">      因为本章是创建一个同步的伪双端口 RAM</span><span style="color:#000000;">，所以 “</span><span style="color:#000000;">Memory Type</span><span style="color:#000000;">（存储类型）” 我们<strong><span style="background-color:#ffd900;">选择 “Simple Dual Port RAM</span></strong></span><strong><span style="color:#000000;"><span style="background-color:#ffd900;">（伪双端口 </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">RAM</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">）”，并勾选 “</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">Common Clock</span></span></strong><span style="color:#000000;"><strong><span style="background-color:#ffd900;">（同步时钟）” 选项</span></strong>，其余设置保存默认即可。下面我们对 “ECC Options</span><span style="color:#000000;">” 做一下扩充讲解，感兴趣的同学可以看一下。</span></p> 
<p><span style="color:#000000;"><span style="background-color:#ffd900;">       </span><strong><span style="background-color:#ffd900;">当存储类型（Memory Type</span></strong></span><strong><span style="color:#000000;"><span style="background-color:#ffd900;">）设置为伪双端口时才可以用 </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">ECC</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">，</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">ECC </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">的主要作用是单 </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">bit </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">纠错和双 </span></span></strong><span style="color:#000000;"><strong><span style="background-color:#ffd900;">bit 检错，</span></strong>在启用后我们可以在写操作期间将单 bit</span><span style="color:#000000;">（</span><span style="color:#000000;">Single Bit Error Injection</span><span style="color:#000000;">）或双 </span><span style="color:#000000;">bit</span><span style="color:#000000;">（</span><span style="color:#000000;">Double Bit Error Injection</span><span style="color:#000000;">）错误注入到指定位置。这里我们不需要注入错误码，所以保存默认选项“No ECC</span><span style="color:#000000;">”即可。 接下来我们对“Port A Options</span><span style="color:#000000;">”和“</span><span style="color:#000000;">Port B Options</span><span style="color:#000000;">”选项卡进行配置，如下图所示： </span></p> 
<p><img alt="" height="703" src="https://images2.imgbox.com/89/76/rYup4iIo_o.png" width="546"></p> 
<p>        <span style="color:#000000;">“Port A Options</span><span style="color:#000000;">” 和 “</span><span style="color:#000000;">Port B Options</span><span style="color:#000000;">” 选项卡下各参数含义在上一章中我们已经做过详细的讲解了， 还不熟悉的同学可以回顾一下上一章的内容。 </span></p> 
<p><strong><span style="color:#000000;"><span style="background-color:#a2e043;">       需要注意的是，只有端口 A </span></span><span style="color:#000000;"><span style="background-color:#a2e043;">的写数据位宽和写深度是可以任意配置的。端口 </span></span><span style="color:#000000;"><span style="background-color:#a2e043;">B </span></span><span style="color:#000000;"><span style="background-color:#a2e043;">的读数据位宽必须与端口 A </span></span><span style="color:#000000;"><span style="background-color:#a2e043;">的写数据位宽存在比例关系（上一节中已讲解过支持的比例关系）；端口 </span></span><span style="color:#000000;"><span style="background-color:#a2e043;">B </span></span><span style="color:#000000;"><span style="background-color:#a2e043;">的读深度是当端口 </span></span><span style="color:#000000;"><span style="background-color:#a2e043;">A </span></span><span style="color:#000000;"><span style="background-color:#a2e043;">的写数据位宽、端口 A </span></span><span style="color:#000000;"><span style="background-color:#a2e043;">的写深度和对端口 </span></span><span style="color:#000000;"><span style="background-color:#a2e043;">B </span></span></strong><span style="color:#000000;"><strong><span style="background-color:#a2e043;">的读数据位宽确定后，自动确定的。</span></strong> </span></p> 
<p><span style="color:#000000;">       接下来是“Other Options</span><span style="color:#000000;">”选项卡，同上一章一样，该选项卡无需配置，保存默认即可。 </span></p> 
<p><span style="color:#000000;">       最后一个是“Summary</span><span style="color:#000000;">”选项卡，该界面显示了我们配置的存储器的类型，消耗的 </span><span style="color:#000000;">BRAM </span><span style="color:#000000;">资源等信息，我们直接点击“OK</span><span style="color:#000000;">”按钮完成 </span><span style="color:#000000;">BMG IP </span><span style="color:#000000;">核的配置，如下图所示：</span></p> 
<p><img alt="" height="701" src="https://images2.imgbox.com/73/ca/o2d5wI5G_o.png" width="576"></p> 
<h4 id="3.2%E3%80%81%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><strong><span style="color:#0d0016;">3.2、<strong>顶层模块设计</strong></span></strong></h4> 
<p><span style="color:#000000;">       本次实验的目的是为了将 Xilinx BMG IP </span><span style="color:#000000;">核配置成一个<strong>伪双端口 </strong></span><strong><span style="color:#000000;">RAM </span></strong><span style="color:#000000;"><strong>并对其进行读写操作</strong>，因此可以给模块命名为<strong> ip_2port_ram</strong></span><span style="color:#000000;">。因为伪双端口的数据线，地址线及其他信号线都是相互独立的，所以这里我们<strong>将读写分为两个子模块，分别命名为 ram_rd</strong></span><strong><span style="color:#000000;">（读模块）和 </span><span style="color:#000000;">ram_wr</span></strong><span style="color:#000000;"><strong>（写模块）；系统时钟和系统复位信号</strong>大家已经很熟悉了，这里就不再多讲了；本次的实验结果我们仍是通过在线调试工具进行观察，所以没有需要输出到 IO </span><span style="color:#000000;">上的信号。由上述分析我们可以画出一个大致的模块框图，如下图所示： </span></p> 
<p><img alt="" height="309" src="https://images2.imgbox.com/b2/e1/0dBWNiIA_o.png" width="598"></p> 
<h4 id="%EF%BC%881%EF%BC%89%E7%BB%98%E5%88%B6%E6%B3%A2%E5%BD%A2%E5%9B%BE"><span style="color:#0d0016;"><strong>（1）<strong>绘制波形图</strong></strong></span></h4> 
<p><span style="color:#000000;">       首先我们梳理一下顶层模块中各个信号的波形变化。因为本次实验中的信号皆为内部信号，所以为了方便区分，我们用绿色标记端口 A</span><span style="color:#000000;">（写端口）相关的信号名，用红色标记端口 </span><span style="color:#000000;">B</span><span style="color:#000000;">（读端口）的信号名，用蓝色标记两个端口之间的交互信号。这里我们以读写 64 </span><span style="color:#000000;">个（0~63）数据为例，绘制出如下波形图： </span></p> 
<p><img alt="" height="256" src="https://images2.imgbox.com/a6/95/KodYoRSi_o.png" width="547"></p> 
<p><span style="color:#000000;">       由上图可以看出，除了和伪双端口有关的信号外，我们还引入了一个读启动信号（</span><span style="color:#000000;">rd_flag</span><span style="color:#000000;">），该信号的作用是错开两个端口的启动时间，以此达到错开读写地址，防止读写冲突的目的。回到波形图上，为了能读出有效数据，我们先使能了端口 A</span><span style="color:#000000;">，因为端口 </span><span style="color:#000000;">A </span><span style="color:#000000;">只能进行写操作，且我们也需要它一直向 RAM </span><span style="color:#000000;">中写入数据，所以当端口 </span><span style="color:#000000;">A </span><span style="color:#000000;">使能后，我们就一直拉高 </span><span style="color:#000000;">WEA </span><span style="color:#000000;">信号，让其一直处于写状态，并从 0 </span><span style="color:#000000;">开始累加地址，向 </span><span style="color:#000000;">0~63 </span><span style="color:#000000;">地址中循环写入数据。当写完一半的数据时，我们通过拉高 </span><span style="color:#000000;">rd_flag </span><span style="color:#000000;">信号 来使能端口 B</span><span style="color:#000000;">，让端口 </span><span style="color:#000000;">B </span><span style="color:#000000;">开始工作，并从 </span><span style="color:#000000;">0 </span><span style="color:#000000;">地址开始循环读出 </span><span style="color:#000000;">0~63 </span><span style="color:#000000;">地址内存储的数据。因为启动两个端口的时间存在误差，且读写的时钟速率相同，所以读写地址就会相应的错开，以此达到避免读写冲突的目的。 </span></p> 
<p><span style="color:#000000;"><strong><span style="background-color:#a2e043;">这里有几点需要大家注意：</span></strong> </span></p> 
<ul><li><span style="color:#000000;">1、伪双端 </span><span style="color:#000000;">RAM </span><span style="color:#000000;">时，因为端口 </span><span style="color:#000000;">A </span><span style="color:#000000;">只能写不能读，所以 </span><span style="color:#000000;">WEA </span><span style="color:#000000;">可以理解为端口 </span><span style="color:#000000;">A </span><span style="color:#000000;">的写使能信号（高有效）。 </span></li><li><span style="color:#000000;">2、哪怕我们只错开一个地址，也是可以避免读写冲突的，这里我们在写完一半的数据时拉高 </span><span style="color:#000000;">rd_flag </span><span style="color:#000000;">信号，只是为了方便我们进行观察而多错开了一些地址而已。 </span></li><li><span style="color:#000000;">3、端口 </span><span style="color:#000000;">B </span><span style="color:#000000;">只能读，其没有像 </span><span style="color:#000000;">WEA </span><span style="color:#000000;">一样的读写使能信号，所以当端口使能后，便一直处于读状态。 </span></li></ul> 
<h3 id="4%E3%80%81%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81"><strong>4、编写代码</strong></h3> 
<h4 id="4.1%E3%80%81%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97%C2%A0ip_2port_ram"><span style="color:#0d0016;"><strong>4.1、顶层模块 ip_2port_ram</strong></span></h4> 
<p><span style="color:#000000;">         因为本次实验除了调用 BMG IP </span><span style="color:#000000;">核外还需要例化一个读模块（</span><span style="color:#000000;">ram_rd</span><span style="color:#000000;">）和一个写模块（</span><span style="color:#000000;">ram_wr</span><span style="color:#000000;">），所 以我们需要创建一个顶层模块来例化 IP </span><span style="color:#000000;">核与读</span><span style="color:#000000;">/</span><span style="color:#000000;">写模块，这里我们可以将顶层模块命名为 </span><span style="color:#000000;">ip_2port_ram</span><span style="color:#000000;">，代码如下：</span></p> 
<pre><code>`timescale 1ns / 1ps
//
// Company: 
// Engineer: 
// 
// Create Date: 2023/06/09 17:23:17
// Design Name: 
// Module Name: ip_2port_ram
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//
//实验任务：
//本章实验任务是将 Xilinx BMG IP 核配置成一个同步的伪双端口 RAM 并对其进行读写操作，
//然后通过仿真观察波形是否正确，最后将设计下载到 FPGA 开发板中，
//并通过在线调试工具对实验结果进行观察。

//本次实验除了调用 BMG IP 核外还需要例化一个读模块（ram_rd）和一个写模块（ram_wr），
//所以我们需要创建一个顶层模块来例化 IP 核与读/写模块。
module ip_2port_ram(
   input     sys_clk,       //系统时钟
   input     sys_rst_n      //系统复位，低电平有效
   );

//wire define
wire ram_wr_en ; //端口 A 使能
wire ram_wr_we ; //ram 端口 A 写使能
wire ram_rd_en ; //端口 B 使能
wire rd_flag ;   //读启动标志
wire [5:0] ram_wr_addr; //ram 写地址
wire [7:0] ram_wr_data; //ram 写数据
wire [5:0] ram_rd_addr; //ram 读地址
wire [7:0] ram_rd_data; //ram 读数据

//*****************************************************
//** main code
//*****************************************************

//RAM 写模块
ram_wr u_ram_wr(
    .clk            (sys_clk       ),
    .rst_n          (sys_rst_n     ),
    
    .rd_flag        (rd_flag       ),
    .ram_wr_en      (ram_wr_en     ),
    .ram_wr_we      (ram_wr_we     ),
    .ram_wr_addr    (ram_wr_addr   ),
    .ram_wr_data    (ram_wr_data   )
    );

//简单双端口 RAM
blk_mem_gen_0 u_blk_mem_gen_0 (
     .clka      (sys_clk       ),    // input wire clka
     .ena       (ram_wr_en     ),    // input wire ena
     .wea       (ram_wr_we     ),    // input wire [0 : 0] wea
     .addra     (ram_wr_addr   ),    // input wire [5 : 0] addra
     .dina      (ram_wr_data   ),    // input wire [7 : 0] dina
     .clkb      (sys_clk       ),    // input wire clkb
     .enb       (ram_rd_en     ),    // input wire enb
     .addrb     (ram_rd_addr   ),    // input wire [5 : 0] addrb
     .doutb     (ram_rd_data   )     // output wire [7 : 0] doutb
     );

//RAM 读模块 
ram_rd u_ram_rd(
.clk (sys_clk ),
.rst_n (sys_rst_n ),

.rd_flag (rd_flag ),
.ram_rd_en (ram_rd_en ),
.ram_rd_addr (ram_rd_addr),
.ram_rd_data (ram_rd_data)
);

endmodule

</code></pre> 
<p><span style="color:#000000;">可以看出 ip_2port_ram </span><span style="color:#000000;">顶层模块只是例化了 </span><strong><span style="color:#000000;">IP </span><span style="color:#000000;">核（</span><span style="color:#000000;">blk_mem_gen_0</span></strong><span style="color:#000000;"><strong>）</strong>、<strong>读模块（</strong></span><strong><span style="color:#000000;">ram_rd</span></strong><span style="color:#000000;"><strong>）</strong>和<strong>写模块（ram_wr</strong></span><span style="color:#000000;"><strong>）</strong>，其中<strong><span style="background-color:#ffd900;">写模块负责产生 </span></strong></span><strong><span style="color:#000000;"><span style="background-color:#ffd900;">RAM IP </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">核写操作所需的所有数据、地址、写使能信号以及启动读模块的标志信号（rd_flag</span></span></strong><span style="color:#000000;"><strong><span style="background-color:#ffd900;">）</span></strong>；<strong><span style="background-color:#a2e043;">读模块负责产生 </span></strong></span><strong><span style="color:#000000;"><span style="background-color:#a2e043;">RAM IP </span></span><span style="color:#000000;"><span style="background-color:#a2e043;">核读操作所需的地址，并将读出的数据也连接至读模块。 </span></span></strong></p> 
<h4 id="4.2%E3%80%81RAM%20%E5%86%99%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span style="color:#000000;"><strong>4.2、RAM </strong></span><span style="color:#000000;"><strong>写模块设计 </strong></span></h4> 
<p><span style="color:#000000;">       首先介绍下 RAM </span><span style="color:#000000;">写模块的设计，在 </span><span style="color:#000000;">RAM </span><span style="color:#000000;">写模块中，我们的输入信号主要有系统时钟信号和系统复位 信号；输出有控制写 RAM </span><span style="color:#000000;">所需的 </span><span style="color:#000000;">ram_wr_en</span><span style="color:#000000;">（写端口使能）、</span><span style="color:#000000;">ram_wr_we</span><span style="color:#000000;">（写使能）、</span><span style="color:#000000;">ram_wr_addr</span><span style="color:#000000;">（写地址）和 ram_wr_data</span><span style="color:#000000;">（写数据）这四个信号，以及控制读模块启动 </span><span style="color:#000000;">rd_flag</span><span style="color:#000000;">（读启动）信号。由上述分析绘制出如下图所示的模块框图：</span></p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/cf/50/ZzVzK96P_o.png" width="649"></p> 
<p><span style="color:#000000;"><strong>绘制波形图 </strong></span></p> 
<p><span style="color:#000000;">在编写代码前，我们先大致梳理一下模块的端口时序，并绘制出如下波形图： </span></p> 
<p><img alt="" height="235" src="https://images2.imgbox.com/46/0a/H3wNL86E_o.png" width="591"></p> 
<p><span style="color:#000000;">        因为我们需要一直向 RAM </span><span style="color:#000000;">中写入数据，所以当复位结束后，我们就将 </span><span style="color:#000000;">ram_wr_en</span><span style="color:#000000;">（写端口使能）和 ram_wr_we（</span><span style="color:#000000;">ram </span><span style="color:#000000;">写使能）一直置为高。当写使能拉高后，写地址一直在 </span><span style="color:#000000;">0~63 </span><span style="color:#000000;">之间循环计数，并向对应的RAM 地址中写入数据，当写地址第一次计数到 </span><span style="color:#000000;">31 </span><span style="color:#000000;">时，将 </span><span style="color:#000000;">rd_flag </span><span style="color:#000000;">信号拉高并保持，以启动读模块进行读操作。</span></p> 
<h4 id="4.3%E3%80%81ram_wr%20%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81"><span style="color:#0d0016;">4.3、ram_wr 模块代码</span></h4> 
<p><strong><span style="color:#000000;"><span style="background-color:#a2e043;">  ram_wr 模块用于产生 RAM </span></span></strong><span style="color:#000000;"><strong><span style="background-color:#a2e043;">写操作所需的信号以及读启动信号  </span>，</strong>其代码如下所示： </span></p> 
<pre><code>`timescale 1ns / 1ps
//
// Company: 
// Engineer: 
// 
// Create Date: 2023/06/09 17:46:51
// Design Name: 
// Module Name: ram_wr
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//

//ram_wr 模块用于产生 RAM 写操作所需的信号以及读启动信号
module ram_wr(
    input      clk,       //时钟信号
    input      rst_n,     //复位信号，低电平有效
    
    //RAM 写端口操作 
    output ram_wr_we ,       //ram 写使能
    output reg ram_wr_en ,   //端口使能
    output reg rd_flag ,     //读启动信号
    output reg [5:0] ram_wr_addr ,   //ram 写地址 
    output [7:0] ram_wr_data         //ram 写数据
    );

//*****************************************************
//** main code
//*****************************************************

//ram_wr_we 为高电平表示写数据
assign ram_wr_we = ram_wr_en ; 
//因为写模块要循环向 ram 的 0~63 地址中写入数据，
//所以当写端口使能后，写使能信号就一直为高.

//写数据与写地址相同，因位宽不等，所以高位补 0
assign ram_wr_data = {2'b0,ram_wr_addr} ;
//当写使能信号拉高后，写地址就会在 0~63 之间循环计数（如代码第 32~39 行所示），
//并向 RAM 中写入相应的数据。

//控制 RAM 使能信号
always @(posedge clk or negedge rst_n) begin
     if(!rst_n)
          ram_wr_en &lt;= 1'b0;
     else
          ram_wr_en &lt;= 1'b1;
end

//写地址信号 范围:0~63 
always @(posedge clk or negedge rst_n) begin
    if(!rst_n) 
         ram_wr_addr &lt;= 6'd0;
    else if(ram_wr_addr &lt; 6'd63 &amp;&amp; ram_wr_we)
         ram_wr_addr &lt;= ram_wr_addr + 1'b1;
    else
         ram_wr_addr &lt;= 6'd0;
end

//当写入 32 个数据（0~31）后，拉高读启动信号
always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
         rd_flag &lt;= 1'b0;
    else if(ram_wr_addr == 6'd31) 
         rd_flag &lt;= 1'b1;
    else
         rd_flag &lt;= rd_flag;
end 
//为了避免读写冲突，我们引入了读启动信号（rd_flag），
//当地址第一次计数到31 时，拉高 rd_flag 信号，使读模块开始工作，
//这样做就可以将读地址和写地址错开，防止在同一时刻对en同一地址进行读和写。

endmodul
</code></pre> 
<h4 id="4.4%E3%80%81RAM%20%E8%AF%BB%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span style="color:#000000;"><strong>4.4、RAM </strong></span><span style="color:#000000;"><strong>读模块设计 </strong></span></h4> 
<p><span style="color:#000000;">       首先介绍下 RAM </span><span style="color:#000000;">读模块的设计，<span style="background-color:#ffd900;">在 </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">RAM </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">读模块中，我们的输入信号主要有系统时钟信号、系统复位信号、从 RAM </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">中读出的数据（</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">ram_rd_data</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">）以及我们自己定义的读启动标志信号（</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">rd_flag</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">）；输出有控制读 RAM </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">所需的 </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">ram_rd_en</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">（读端口使能）和 </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">ram_rd_addr</span></span><span style="color:#000000;"><span style="background-color:#ffd900;">（读地址）这两个信号。</span>由上述分析绘制出如下图所示的模块框图： </span></p> 
<p><img alt="" height="172" src="https://images2.imgbox.com/12/67/twacVlLM_o.png" width="530"></p> 
<p> <span style="color:#000000;">模块端口与功能描述如下表所示：</span></p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/8f/9f/AZla5ehy_o.png" width="610"></p> 
<p> <span style="color:#000000;"><strong>绘制波形图 </strong></span></p> 
<p><span style="color:#000000;">在编写代码前，我们先大致梳理一下模块的端口时序，并绘制出如下波形图： </span></p> 
<p><img alt="" height="173" src="https://images2.imgbox.com/1f/61/SrM1OLOc_o.png" width="577"></p> 
<p>        <span style="color:#000000;">因为我们需要一直从 RAM 中读出数据，所以当复位结束且读启动信号拉高后，我们就将 ram_rd_en（读端口使能）一直置为高。当读端口使能后，读地址就会一直在 0~63 </span><span style="color:#000000;">之间循环计数，并读出对应 </span><span style="color:#000000;">RAM地址中的数据，<strong>需要注意的是读数据的输出会比读地址晚一个时钟周期</strong>。 </span></p> 
<h4 id="4.5%E3%80%81ram_rd%20%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81"><strong><span style="color:#0d0016;">4.5、ram_rd 模块代码</span></strong></h4> 
<p><strong><span style="color:#000000;"><span style="background-color:#ffd900;">ram_rd 模块用于产生 </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">RAM </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">读操作所需的信号，并接引从 </span></span><span style="color:#000000;"><span style="background-color:#ffd900;">RAM </span></span></strong><span style="color:#000000;"><strong><span style="background-color:#ffd900;">中读出的数据</span></strong>，其代码如下所示：</span></p> 
<pre><code>`timescale 1ns / 1ps
//
// Company: 
// Engineer: 
// 
// Create Date: 2023/06/09 17:56:49
// Design Name: 
// Module Name: ram_rd
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//

//ram_rd 模块用于产生 RAM 读操作所需的信号，并接引从 RAM 中读出的数据.
module ram_rd(
   input    clk ,     //时钟信号
   input    rst_n ,   //复位信号，低电平有效
   
   //RAM 读端口操作 
   input             rd_flag ,      //读启动标志
   input [7:0]       ram_rd_data,   //ram 读数据
   output            ram_rd_en ,    //端口使能
   output reg [5:0]  ram_rd_addr    //ram 读地址 
   );
//*****************************************************
//** main code
//*****************************************************

//控制 RAM 使能信号
assign ram_rd_en = rd_flag; 

//读地址信号 范围:0~63 
always @(posedge clk or negedge rst_n) begin
     if(!rst_n) 
          ram_rd_addr &lt;= 6'd0;
     else if(ram_rd_addr &lt; 6'd63 &amp;&amp; ram_rd_en)
          ram_rd_addr &lt;= ram_rd_addr + 1'b1;
     else
          ram_rd_addr &lt;= 6'd0;
end

endmodule
//当读启动信号拉高后，读端口将被使能；当读端口使能后，
//读地址会在 0~63 之间循环计算，从而读出对应 RAM 地址中的数据。

</code></pre> 
<h3 id="5%E3%80%81%E4%BB%BF%E7%9C%9F%E9%AA%8C%E8%AF%81"><span style="color:#000000;"><strong>5、仿真验证 </strong></span></h3> 
<h4 id="5.1%E3%80%81%E7%BC%96%E5%86%99%20TB%20%E6%96%87%E4%BB%B6"><span style="color:#000000;"><strong>5.1、编写 </strong></span><span style="color:#000000;"><strong>TB </strong></span><span style="color:#000000;"><strong>文件 </strong></span></h4> 
<p><span style="color:#000000;">        我们接下来先对代码进行仿真，因为本章实验我们<strong>只有系统时钟和系统复位这两个输入信号</strong>，所以仿真文件也只需要编写这两个信号的激励即可，TestBench </span><span style="color:#000000;">代码如下： </span></p> 
<pre><code>`timescale 1ns / 1ps      //仿真单位/仿真精度
//
// Company: 
// Engineer: 
// 
// Create Date: 2023/06/09 18:01:40
// Design Name: 
// Module Name: tb_ip_2port_ram
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//

//本实验我们只有系统时钟和系统复位这两个输入信号，
//所以仿真文件也只需要编写这两个信号的激励即可。
module tb_ip_2port_ram();

//parameter define
parameter CLK_PERIOD = 20; //50MHz系统时钟(一个周期是20ns：1/50MHz=0.02us=20ns)
                            //200MHz系统时钟(一个周期是5ns：1/200MHz=0.005us=5ns)

//reg define
reg sys_clk;
reg sys_rst_n;

//信号初始化
initial begin
     sys_clk = 1'b0;
     sys_rst_n = 1'b0;
     #200
     sys_rst_n = 1'b1;
end

//产生时钟
always #(CLK_PERIOD/2) sys_clk = ~sys_clk;

ip_2port_ram u_ip_2port_ram(
    .sys_clk      (sys_clk      ),
    .sys_rst_n    (sys_rst_n    )
    );

endmodule

</code></pre> 
<h4 id="5.2%E3%80%81%E4%BB%BF%E7%9C%9F%E9%AA%8C%E8%AF%81"><span style="color:#000000;"><strong>5.2、仿真验证 </strong></span></h4> 
<p><span style="color:#000000;">通过仿真我们得到了以下波形图： </span></p> 
<p><img alt="" height="428" src="https://images2.imgbox.com/b4/c7/Lu5wXN85_o.png" width="1075"></p> 
<p><img alt="" height="428" src="https://images2.imgbox.com/dd/92/XQ60aFMK_o.png" width="1081"></p> 
<p><img alt="" height="421" src="https://images2.imgbox.com/a3/ef/tvNnblvR_o.png" width="1077"></p> 
<h3 id="6%E3%80%81%E4%B8%8B%E8%BD%BD%E9%AA%8C%E8%AF%81"><strong><span style="color:#0d0016;">6、下载验证</span></strong><span style="color:#000000;"><strong> </strong></span></h3> 
<h4 id="6.1%E3%80%81%E5%BC%95%E8%84%9A%E7%BA%A6%E6%9D%9F"><span style="color:#000000;"><strong>6.1、引脚约束 </strong></span></h4> 
<p><span style="color:#000000;">在仿真验证完成后，接下来对引脚进行分配，并上板验证。本实验中，系统时钟、按键复位的管脚分配如下表所示： </span></p> 
<p><img alt="" height="130" src="https://images2.imgbox.com/f2/3d/watLb734_o.png" width="657"></p> 
<p><strong>约束文件 ip_2port_ram.xdc 内容如下：</strong></p> 
<pre><code>############## clock define 时钟引脚、电平信号约束##### Pro-FPGA##################
set_property -dict {PACKAGE_PIN R4 IOSTANDARD LVCMOS15} [get_ports sys_clk]
############## reset key define##########################
set_property -dict {PACKAGE_PIN U7 IOSTANDARD LVCMOS15} [get_ports sys_rst_n]</code></pre> 
<h4 id="6.2%E3%80%81%E6%B7%BB%E5%8A%A0%20ILA%C2%A0IP%20%E6%A0%B8%E8%BF%9B%E8%A1%8C%E5%9C%A8%E7%BA%BF%E8%B0%83%E8%AF%95"><span style="color:#000000;"><strong>6.2、添加 ILA</strong></span><span style="color:#000000;"><strong> IP </strong></span><span style="color:#000000;"><strong>核进行在线调试 </strong></span></h4> 
<p><span style="color:#000000;"><strong>添加 ILA</strong></span><span style="color:#000000;"><strong> IP 核的方法见：</strong></span><a href="https://blog.csdn.net/yishuihanq/article/details/131126970?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22131126970%22%2C%22source%22%3A%22yishuihanq%22%7D" title=" Vivado 下 IP核之单端口 RAM 读写_OliverH-yishuihan的博客-CSDN博客"> Vivado 下 IP核之单端口 RAM 读写_OliverH-yishuihan的博客-CSDN博客</a></p> 
<p><span style="background-color:#ffd900;">中的：</span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">“5.2、添加 ILA IP 核进行在线调试”</span></strong></span></p> 
<p><span style="color:#000000;">接下来添加 ILA IP </span><span style="color:#000000;">核，将 </span><span style="color:#000000;">ram_wr_en</span><span style="color:#000000;">（</span><span style="color:#000000;">1</span><span style="color:#000000;">位）、</span><span style="color:#000000;">ram_wr_we</span><span style="color:#000000;">（</span><span style="color:#000000;">1</span><span style="color:#000000;">位）、</span><span style="color:#000000;">ram_rd_en</span><span style="color:#000000;">（1位）、</span><span style="color:#000000;">rd_flag</span><span style="color:#000000;">（</span><span style="color:#000000;">1位）、ram_wr_addr</span><span style="color:#000000;">（6 位）、</span><span style="color:#000000;">ram_wr_data</span><span style="color:#000000;">（8 位）、</span><span style="color:#000000;">ram_rd_addr</span><span style="color:#000000;">（6 位）和 </span><span style="color:#000000;">ram_rd_data</span><span style="color:#000000;">（8 位）信号添加至观察列表中，添加 ILA IP </span><span style="color:#000000;">核的方法这里不再赘述，本例程是将 </span><span style="color:#000000;">ILA </span><span style="color:#000000;">例化在了顶层模块（</span><span style="color:#000000;">ip_2port_ram</span><span style="color:#000000;">）中， 例化代码如下所示</span></p> 
<pre><code>ila_0 u_ila_0 (
     .clk         (sys_clk     ),     // input wire clk
     
     .probe0      (ram_wr_en    ),    // input wire [0:0] probe0 
     .probe1      (ram_wr_we    ),    // input wire [0:0] probe1 
     .probe2      (ram_rd_en    ),    // input wire [0:0] probe2 
     .probe3      (rd_flag      ),    // input wire [0:0] probe3 
     .probe4      (ram_wr_addr  ),    // input wire [5:0] probe4 
     .probe5      (ram_wr_data  ),    // input wire [7:0] probe5 
     .probe6      (ram_rd_addr  ),    // input wire [5:0] probe6 
     .probe7      (ram_rd_data  )     // input wire [7:0] probe7
);</code></pre> 
<h4 id="6.3%E3%80%81%E4%B8%8A%E6%9D%BF%E9%AA%8C%E8%AF%81"><strong><span style="color:#0d0016;">6.3、上板验证</span></strong></h4> 
<p><span style="color:#000000;">        编译工程并生成比特流文件后，将下载器一端连接电脑，另一端与开发板上的 JTAG </span><span style="color:#000000;">下载口连接，连接</span><span style="color:#000000;">电源线，并打开开发板的电源开关。</span></p> 
<p><span style="color:#000000;">        点击 Vivado </span><span style="color:#000000;">左侧“</span><span style="color:#000000;">Flow Navigator</span><span style="color:#000000;">”窗口最下面的“</span><span style="color:#000000;">Open Hardware Manager</span><span style="color:#000000;">”，如果此时 </span><span style="color:#000000;">Vivado </span><span style="color:#000000;">软件识别到了下载器，则点击“Hardware</span><span style="color:#000000;">”窗口中“</span><span style="color:#000000;">Progam Device</span><span style="color:#000000;">”，在弹出的界面中选择“</span><span style="color:#000000;">Program</span><span style="color:#000000;">”下载程序。 </span></p> 
<p><span style="color:#000000;">       双端口 ram </span><span style="color:#000000;">的读写在 </span><span style="color:#000000;">ILA </span><span style="color:#000000;">中观察到的波形如下图所示： </span></p> 
<p><img alt="" height="551" src="https://images2.imgbox.com/41/e8/ToNeurvt_o.png" width="656"></p> 
<p><span style="color:#000000;">       由在线调试观察可知，上板验证结果与仿真结果是一致的，写端口和读端口能够同时对 ram </span><span style="color:#000000;">进行相应的操作，且没有发生读写冲突现象，至此说明了 IP </span><span style="color:#000000;">核之双端口 </span><span style="color:#000000;">RAM </span><span style="color:#000000;">实验验证成功。</span></p> 
<h3 id="7%E3%80%81%E6%9C%AC%E7%AB%A0%E6%80%BB%E7%BB%93"><span style="color:#000000;"><strong>7、本章总结 </strong></span></h3> 
<p><span style="color:#000000;">       本章节我们主要讲解了双端口 RAM </span><span style="color:#000000;">的概念，使用场景，读写冲突处理，也介绍了 </span><span style="color:#000000;">Vivado </span><span style="color:#000000;">软件中如何将 BGM IP </span><span style="color:#000000;">核配置成伪双端口 </span><span style="color:#000000;">RAM </span><span style="color:#000000;">的方法，并通过错时的方法避免了双端口 </span><span style="color:#000000;">RAM </span><span style="color:#000000;">发生读写冲突的情况。</span></p> 
<p></p> 
<p><span style="color:#0d0016;">Vivado 下 IP核之双端口 RAM 读写，工程源码下载地址：</span></p> 
<p><a class="has-card" href="https://download.csdn.net/download/yishuihanq/88555759" title="Vivado下IP核之双端口RAM读写资源-CSDN文库"><span class="link-card-box"><span class="link-title">Vivado下IP核之双端口RAM读写资源-CSDN文库</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/04/22/EyVpNyCS_o.png" alt="icon-default.png?t=N7T8">https://download.csdn.net/download/yishuihanq/88555759</span></span></a></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aae4cec5f8034845fbff4e9c81b94731/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">初阶结构体</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0edc947ce8c61c6ddcd749909222331c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python元类Type和Object的关系</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>