<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>testbench常用语句 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="testbench常用语句" />
<meta property="og:description" content="与可综合Verilog代码所不同的是，testbench Verilog是在计算机主机上的仿真器中执行的。testbench Verilog的许多构造与C语言相似，我们可在代码中包括复杂的语言结构和顺序语句的算法。
1 always块和initial块
Verilog有两种进程语句：always块和initial块。always块内的进程语句，可用来模拟抽象的电路。
出于模拟的目的，always块可以包括：用以指定与不同结构之间的传播延迟等同的时序结构；或等待指定事件的时序结构。敏感列表有时可忽略。比方说，我们用下面的代码片段来模拟时钟信号，该信号每20个时间单位在0~1间变换一次，且永远执行下去。
always
begin
clk=1;
#20;
clk=0;
#20);
end
initial块内也有进程语句，但是仅在仿真之初被执行。其简单语法如下：
initial
begin
进程语句;
end
initail块常用于设置变量的初始值。注意，initial块不可被综合。
2 进程语句
进程语句应用于initial块、always块、function和task之中。最常用的进程语句为：
· 阻塞赋值
· 非阻塞赋值
· if表达式
· case表达式
· 循环表达式
我们讨论过阻塞和阻塞赋值，if和case语句。
Verilog支持的循环结构有：for、while、repeat和forever。for循环的简单语法为：
for([initial_assignment]; [end_condition]; [step_assignment])
begin
[procedural_statements;]
end
举个例子，我们可以使用下面的语句来清除16位寄存器文件的内容：
integer i;
. . .
for(i=0; i&lt;16; i=i&#43;1)
reg_file[i]=0;
注意当循环体内只有一条语句的话，begin和end限定词可以略去。
while循环的简单语法如下：
while([end_condition])
begin
[procedural_statements;]
end
循环体内的语句连续重复执行，直到达到指定的终止条件[end_condition]为止。比方说上面的清寄存器文件的操作可以使用while循环来描述：
integer i;
. . .
while(i&lt;16)
begin
reg_file[i]=0;
i=i&#43;1;
en
repeat循环的简单语法如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/884cd5b1b372f1fb5f6ea0b02b658fbe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-05T16:26:30+08:00" />
<meta property="article:modified_time" content="2023-02-05T16:26:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">testbench常用语句</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>与可综合Verilog代码所不同的是，testbench Verilog是在计算机主机上的仿真器中执行的。testbench Verilog的许多构造与C语言相似，我们可在代码中包括复杂的语言结构和顺序语句的算法。</p> 
<p>1 always块和initial块</p> 
<p>Verilog有两种进程语句：always块和initial块。always块内的进程语句，可用来模拟抽象的电路。</p> 
<p>出于模拟的目的，always块可以包括：用以指定与不同结构之间的传播延迟等同的时序结构；或等待指定事件的时序结构。敏感列表有时可忽略。比方说，我们用下面的代码片段来模拟时钟信号，该信号每20个时间单位在0~1间变换一次，且永远执行下去。</p> 
<p>always</p> 
<p>begin</p> 
<p>clk=1;</p> 
<p>#20;</p> 
<p>clk=0;</p> 
<p>#20);</p> 
<p>end</p> 
<p>initial块内也有进程语句，但是仅在仿真之初被执行。其简单语法如下：</p> 
<p>initial</p> 
<p>begin</p> 
<p>进程语句;</p> 
<p>end</p> 
<p>initail块常用于设置变量的初始值。注意，initial块不可被综合。</p> 
<p>2 进程语句</p> 
<p>进程语句应用于initial块、always块、function和task之中。最常用的进程语句为：</p> 
<p>· 阻塞赋值</p> 
<p>· 非阻塞赋值</p> 
<p>· if表达式</p> 
<p>· case表达式</p> 
<p>· 循环表达式</p> 
<p>我们讨论过阻塞和阻塞赋值，if和case语句。</p> 
<p>Verilog支持的循环结构有：for、while、repeat和forever。for循环的简单语法为：</p> 
<p>for([initial_assignment]; [end_condition]; [step_assignment])</p> 
<p>begin</p> 
<p>[procedural_statements;]</p> 
<p>end</p> 
<p>举个例子，我们可以使用下面的语句来清除16位寄存器文件的内容：</p> 
<p>integer i;</p> 
<p>. . .</p> 
<p>for(i=0; i&lt;16; i=i+1)</p> 
<p>reg_file[i]=0;</p> 
<p>注意当循环体内只有一条语句的话，begin和end限定词可以略去。</p> 
<p>while循环的简单语法如下：</p> 
<p>while([end_condition])</p> 
<p>begin</p> 
<p>[procedural_statements;]</p> 
<p>end</p> 
<p>循环体内的语句连续重复执行，直到达到指定的终止条件[end_condition]为止。比方说上面的清寄存器文件的操作可以使用while循环来描述：</p> 
<p>integer i;</p> 
<p>. . .</p> 
<p>while(i&lt;16)</p> 
<p>begin</p> 
<p>reg_file[i]=0;</p> 
<p>i=i+1;</p> 
<p>en</p> 
<p>repeat循环的简单语法如下：</p> 
<p>repeat([number])</p> 
<p>begin</p> 
<p>[procedual_statements;]</p> 
<p>end</p> 
<p>循环体内的语句被重复执行指定数次，该数可通过[number]来指定。比方说，我们可以将上面的操作替换为repeat循环：</p> 
<p>integer i;</p> 
<p>. . .</p> 
<p>repeat(16)</p> 
<p>begin</p> 
<p>[procedural_statements;]</p> 
<p>end</p> 
<p>forever循环，正如其名，重复执行其主体直至仿真结束位置。循环体内常包括一定的时序控制结构，以致周期性推迟执行。比方说，我们换一种方式来描述时钟信号，该信号每10个时间单位翻转一次，且永远运行下去。</p> 
<p>initial</p> 
<p>begin</p> 
<p>clk=1’b0;</p> 
<p>forever</p> 
<pre><code>#10 clk=~clk;
</code></pre> 
<p>end</p> 
<p>3 时序控制</p> 
<p>在testbench中，必须指定不同信号有效和无效或等待某事件或条件的时间。有三种时序控制结构：</p> 
<p>· 时延控制：#[delay_time]</p> 
<p>· 事件控制：@([event], [event], …]</p> 
<p>· 等待语句：wait([boolean_expression])</p> 
<p>此外还有一个编译器指令，`timescale，也与时序规范有关。</p> 
<p>4 时延控制</p> 
<p>时延控制使用#符号来指示，其后为延迟的时间单位数值。</p> 
<p>如果时延控制放置在左手边，那么整条语句的执行都会被延迟。比方说，</p> 
<p>. . .</p> 
<p>#10 a=1’b0;</p> 
<p>#5 y=a|b;</p> 
<p>. . .</p> 
<p>假设当前时间为t，上面的语句表示，a于t+10时刻得到0值；又过了5个时间单位后（即于t+15时刻）a|b表达式被计算，其结果被赋给y。</p> 
<p>如果实验控制被放置在右手边，那么表达式将会被立即运算，但是延迟后再赋给左手边。如：</p> 
<p>. . .</p> 
<p>#10 a=1’b0;</p> 
<pre><code>y=#5 a|b;
</code></pre> 
<p>. . .</p> 
<p>a于t+10时刻得到0值；a|b表达式被立即运算（即在t+10时刻），但其结果却在t+15时刻才赋给y。</p> 
<p>一般情况下，我们使用时延控制生成激励的方式来替代传播延迟的模拟。下面的格式使得代码显得更加直观。</p> 
<p>. . .</p> 
<p>a=1’b0;// a gets 0</p> 
<p>#10; // the 0 value lasts 10 time units</p> 
<p>a-1’b1;// a changes to 10</p> 
<p>#5; // the 1 value lasts 5 time units</p> 
<p>a=1’b0;// a changes to 0</p> 
<p>#20 // the 0 value lasts 20 time units</p> 
<p>. . .</p> 
<p>…</p> 
<p>5 事件控制</p> 
<p>事件控制使用@符号来指示，其后为敏感列表，用于指定所需事件。其使用与always块内的事件类似。事件即敏感列表中的信号改变其值（信号跳变）的时刻。可加入posedge和negedge关键字以指定所需的跳变边沿（上升沿和下降沿）。在testbench中，直到指定事件发生，语句才可跳过延迟，继续执行。事件控制的一个常见应用为：使用时钟信号来同步激励的生成。比方说，下面的代码片段中，en信号被激活持续一个时钟周期。</p> 
<p>localparam delta=1;</p> 
<p>. . .</p> 
<p>@(posedgeclk);// wait for the rising edge of clk</p> 
<p>#delta; // wait for delta to avoid hold=time violation</p> 
<p>en=1’b1; // assert en to 1</p> 
<p>@(posedgeclk);// wait for the next rising edge of clk</p> 
<p>#delta; // wait for delta to avoid hold-time violation</p> 
<p>en=1’b0; // assert en to 0</p> 
<p>换一种方式，我们可以在时钟信号的下降沿断言或解除断言en。</p> 
<p>. . .</p> 
<p>@(negedgeclk)// wait for the falling edge of clk</p> 
<p>en=1’b1; // assert en to 1</p> 
<p>@(negedgeclk)// wait for the next falling edge of clk</p> 
<p>en=1’b0;</p> 
<p>. . .</p> 
<p>6 等待语句</p> 
<p>wait语句用以等待指定条件。其简单语法如下：</p> 
<p>wait[boolean_expression]</p> 
<p>直到[boolean_expression]被计算为真，后面语句才可跳过延迟，继续执行。比方说，我们可以这样写代码：</p> 
<p>wait(state<mark>READ &amp;&amp; mem_ready</mark>1’b1) [statement_to_get_data];</p> 
<p>我们也可以使用wait语句来延迟执行。比方说，我们可以等计数器数到15才激活某信号：</p> 
<p>. . .</p> 
<p>wait(counter==4’b1111);// wait until counter is 15</p> 
<p>. . . // continue</p> 
<p>wait语句有时很想事件控制。后者是等待某信号的跳变边沿，而前者是等待指定条件，有时可理解为电平敏感。</p> 
<p>7 timescale指令</p> 
<p>编译器指令用以控制编译和预处理verilog代码，他们通过重音符号（<code>）来指明。重音符号常位于键盘的左上角。与时间有关的指令是</code>timescale指令</p> 
<p>`timescale [time_unit] / [time_precision]</p> 
<p>time_unit指定计时和延时的测量单位，time_precision则是指定仿真器的精度。</p> 
<p>比方说，指令</p> 
<p>`timescale10ns/1ns</p> 
<p>则说明仿真单位为10ns，精度为1ns。当指定如下代码中的延时，</p> 
<p>#5 y = a &amp; b;</p> 
<p>表明实际上的延时为50ns（即5*10ns）。</p> 
<p>也可以指定小数形式的单位延时，比方说</p> 
<p>#5.12345 y = a &amp; b;</p> 
<p>则说明实际延时为51.2345ns。因为精度是1ns， 所以在仿真中就取整为51ns。精度越少，仿真的准确性越高，但是会减慢仿真的速度。</p> 
<p>time_unit和time_precision的数字部分可以为1、10和100，时间单元可以是s（秒）、ms（毫秒）、us（微秒）、ns（纳秒）和ps（皮秒）。</p> 
<p>8 系统控制函数和任务</p> 
<p>Verilog有一组预定义的系统函数，以$打头，执行与系统相关的操作，如仿真控制、文件读取等。下面我们讲一下一些常用的函数和任务。</p> 
<p>数据类型转换函数</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         u 
        
       
         n 
        
       
         s 
        
       
         i 
        
       
         g 
        
       
         n 
        
       
         e 
        
       
         d 
        
       
         和 
        
       
      
        unsigned和 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord cjk_fallback">和</span></span></span></span></span>signed函数执行介于无符号数和有符号数类型之间的转换。</p> 
<p>仿真时间函数</p> 
<p>仿真时间函数返回当前的仿真时间，如<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         t 
        
       
         i 
        
       
         m 
        
       
         e 
        
       
         、 
        
       
      
        time、 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">im</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">、</span></span></span></span></span>stime和$realtime函数分别以64位整数、32位整数和实数的形式返回时间。</p> 
<p>仿真控制任务</p> 
<p>有两种仿真控制函数：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         i 
        
       
         n 
        
       
         i 
        
       
         s 
        
       
         h 
        
       
         和 
        
       
      
        finish和 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">ini</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">和</span></span></span></span></span>stop。其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         i 
        
       
         n 
        
       
         i 
        
       
         s 
        
       
         h 
        
       
         任务用于终止仿真并跳出仿真器； 
        
       
      
        finish任务用于终止仿真并跳出仿真器； 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">ini</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">任务用于终止仿真并跳出仿真器；</span></span></span></span></span>stop任务则用于中止仿真。在Modelsim中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         t 
        
       
         o 
        
       
         p 
        
       
         任务则是返回到交互模式。在开发流程中，我们有时会停在 
        
       
         M 
        
       
         o 
        
       
         d 
        
       
         e 
        
       
         l 
        
       
         s 
        
       
         i 
        
       
         m 
        
       
         环境中，来进一步编辑或测试波形，因此代码中使用的是 
        
       
      
        stop任务则是返回到交互模式。在开发流程中，我们有时会停在Modelsim环境中，来进一步编辑或测试波形，因此代码中使用的是 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord cjk_fallback">任务则是返回到交互模式。在开发流程中，我们有时会停在</span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">s</span><span class="mord mathnormal">im</span><span class="mord cjk_fallback">环境中，来进一步编辑或测试波形，因此代码中使用的是</span></span></span></span></span>stop。</p> 
<p>显示任务</p> 
<p>在Modelsim中，仿真的结果可以以波形的形式显示，也可以以文本的形式显示。四种主要的显示任务有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
         i 
        
       
         s 
        
       
         p 
        
       
         l 
        
       
         a 
        
       
         y 
        
       
         、 
        
       
      
        display、 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right: 0.0197em;">pl</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mord cjk_fallback">、</span></span></span></span></span>write、<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         t 
        
       
         r 
        
       
         o 
        
       
         b 
        
       
         e 
        
       
         和 
        
       
      
        strobe和 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">和</span></span></span></span></span>monitor，它们语法类似。在Modelsim中，文本是在控制面板显示的。</p> 
<p>$display的语法与C语言中的打印函数类似。其简单语法为：</p> 
<p>$display([format_string], [argument], [argument], …);</p> 
<p>如：</p> 
<p>$display(“at %d; signal x = %b”, $time, x);</p> 
<p>其结果的形式如下：</p> 
<p>at 5100； signal x = 00110001</p> 
<p>最常用的转移符号有%d、%b、%o、%h、%c、%s和%g，对应分别为十进制、二进制、八进制、十六进制、字符、字符串和实数。</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         w 
        
       
         r 
        
       
         i 
        
       
         t 
        
       
         e 
        
       
         任务几乎和 
        
       
      
        write任务几乎和 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">任务几乎和</span></span></span></span></span>diplay等同，除了其执行之后并不跳到下一行显示。而是一直显示在当前位置。显示下一行字符\n，必须手动添加，以创建一个行中断。</p> 
<p>Verilog可结合time step的概念来塑造仿真延时。每个time step中可以发生很多活动。<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         t 
        
       
         r 
        
       
         o 
        
       
         b 
        
       
         e 
        
       
         与 
        
       
      
        strobe与 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">与</span></span></span></span></span>display任务类似。代替立即执行的是，$strobe任务是在当前仿真的time step的结尾执行的。它可以规避由于竞争冒险造成的不匹配的数据显示。</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
         o 
        
       
         n 
        
       
         i 
        
       
         t 
        
       
         o 
        
       
         r 
        
       
         任务是非常通用的命令。鉴于 
        
       
      
        monitor任务是非常通用的命令。鉴于 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">ni</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0278em;">or</span><span class="mord cjk_fallback">任务是非常通用的命令。鉴于</span></span></span></span></span>displat、<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         w 
        
       
         r 
        
       
         i 
        
       
         t 
        
       
         e 
        
       
         、 
        
       
      
        write、 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">、</span></span></span></span></span>strobe任务是在一旦它们被执行的情况下才显示文本，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
         o 
        
       
         n 
        
       
         i 
        
       
         t 
        
       
         o 
        
       
         r 
        
       
         任务则是当其参数发生变化时即显示文本。 
        
       
      
        monitor任务则是当其参数发生变化时即显示文本。 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">ni</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0278em;">or</span><span class="mord cjk_fallback">任务则是当其参数发生变化时即显示文本。</span></span></span></span></span>monitor任务提供了简单的富有弹性的方式来跟踪仿真。比方说，我们可以在testbench中添加如下的代码：</p> 
<p>initial</p> 
<p>begin</p> 
<p>$display(“time test_in0 test_in1 test_out”);</p> 
<p>$monitot(“%d %b %b %b”,</p> 
<pre><code>        $time, test_in0, test_in1, test_out);
</code></pre> 
<p>end</p> 
<p>Modelsim的控制面板中显示的文本仿真结果如下（示例）：</p> 
<p>time test_in0 test_in1 test_out</p> 
<p>0 00 00 1</p> 
<p>200 01 00 0</p> 
<p>400 01 11 0</p> 
<p>. . .</p> 
<p>文件I/O系统函数和任务</p> 
<p>Veirlog提供一组用于访问外部数据文件的函数和任务。文件可以通过<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         o 
        
       
         p 
        
       
         e 
        
       
         n 
        
       
         和 
        
       
      
        fopen和 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">和</span></span></span></span></span>fclose函数来打开和关闭。$fopen的语法为：</p> 
<p>[mcd_names] = $fopen(“[file_name]”);</p> 
<p>$fopen函数返回一个与文件相关的32位的多通道描述子。这个描述子我们可以认为是一个32位的标志，它代表一个文件（亦即一个通道）。最低位LSB保留，用以只是标准输出（console）。当使用函数调用的文件被成功打开，则返回的描述子的值得某位会被置一。例如，0…0010表示打开第一个文件，0…0100表示打开第二个文件，依次类推。若函数的返回值为0，则表示文件未能成功打开。</p> 
<p>一旦某个文件被打开，我们就可以向其内写入数据。可用的四种显示系统任务为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         d 
        
       
         i 
        
       
         s 
        
       
         p 
        
       
         l 
        
       
         a 
        
       
         y 
        
       
         ， 
        
       
      
        fdisplay， 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">fd</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right: 0.0197em;">pl</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mord cjk_fallback">，</span></span></span></span></span>fwrite，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         s 
        
       
         t 
        
       
         r 
        
       
         o 
        
       
         b 
        
       
         e 
        
       
         和 
        
       
      
        fstrobe和 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">和</span></span></span></span></span>fmonitor。这些任务的用法类似于先前的$display等，除了其第一参数为描述子以外。</p> 
<p>$fdisplay([mcd_name], [format_string], …);</p> 
<p>下面给出一个简单的代码片段。</p> 
<p>integer log_file, both_file;</p> 
<p>localparam con_file =32’h0000_0001;// console</p> 
<p>initialbegin</p> 
<pre><code>log_file  = $fopenZ("my_log");

if(log_file == 0)

    $display("Fail to open log file");// write console

both_file = log_file | con_file;



// write to both console and log_file

$fdisplay(both_file,"Simulation started");

. . .

// write to log_file only

$fdisplay(log_file, ...);

. . .

// write to

$fdisplay(both_file,"Simulation ended");

$fclose(log_file);
</code></pre> 
<p>end</p> 
<p>注意我们可以通过对多个描述子进行位运算来创建一个描述子，比方说both_file变量。当both_file被使用时，就可以同时对console和log_file进行操作。</p> 
<p>有两个任务可以从文件中载入数据，分别为:<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         r 
        
       
         e 
        
       
         a 
        
       
         d 
        
       
         m 
        
       
         e 
        
       
         m 
        
       
         b 
        
       
         ， 
        
       
      
        readmemb， 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">mb</span><span class="mord cjk_fallback">，</span></span></span></span></span>readmemh。这些任务假设外置文件中存储了memory-array的内容，然后读出这些内容存到一个变量中。<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         r 
        
       
         e 
        
       
         a 
        
       
         d 
        
       
         m 
        
       
         e 
        
       
         m 
        
       
         b 
        
       
         ， 
        
       
      
        readmemb， 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">mb</span><span class="mord cjk_fallback">，</span></span></span></span></span>readmemh所假设的文件格式分别为二进制和十六进制，相应地，它们的语法格式为：</p> 
<p>$readmemb(“[file_name]”, [mem_variable]);</p> 
<p>$readmemh(“{file_name]”, [mem_variable]);</p> 
<p>下面的片段描述如何载入一个8x4的存储阵列：</p> 
<p>reg[3:0] v_mem [0:7];</p> 
<p>. . .</p> 
<p>$readmemb(“vector.txt”, v_mem);</p> 
<p>vector.txt应该包含八个4bit的使用空格分割的二进制数据。</p> 
<p>有了文件操作函数和任务，就可以使用外部文件来指定测试模型，以及记录仿真结果。下面给出一个案例。</p> 
<p>`timescale1ns/1ns</p> 
<p>moduleeq2_file_tb;</p> 
<p>// signal declaration</p> 
<p>reg[1:0] test_in0, test_in1;</p> 
<p>wiretest_out;</p> 
<p>integer log_file, console_file, out_file;</p> 
<p>reg[3:0] v_mem [0:7];</p> 
<p>integer i;</p> 
<p>// instantiate the circuit under test</p> 
<p>eq2_sop eq2_sop_inst (</p> 
<pre><code>.a(test_in0),

.b(test_in1),

.aeqb(test_out)
</code></pre> 
<p>);</p> 
<p>initialbegin</p> 
<pre><code>// setup output fil

log_file = $fopen("eqlog.txt"

if(!log_file) $fdisplay("Cannot open log file");

console_file =32'h0000_0001;

out_file = log_file | console_file;



// read test vector

#readmemb("vector.txt", v_mem);   

// test generator iterating throught 8 pattens

for(i=0; i&lt;8; i=i+1)begin

    {test_in0, test_in1} = v_mem[i];

end



// stop simulation

$fclose(log_file);

$stop;
</code></pre> 
<p>end</p> 
<p>// text display</p> 
<p>initialbegin</p> 
<pre><code>$fdisplay(out_file,"   time    test_in0    test_in1    test_out");

$fdisplay(out_file,"           (a)         (b)         (aeqb)");

$fmoitor(out_file,"    d    %b          %b          %b",

    $time, test_in0, test_in1, test_out);
</code></pre> 
<p>end</p> 
<p>endmodule</p> 
<p>指定的test pattern为4位二进制格式，存储在vector.txt中。文件内容为：</p> 
<p>1</p> 
<p>2</p> 
<p>3</p> 
<p>4</p> 
<p>5</p> 
<p>6</p> 
<p>7</p> 
<p>8</p> 
<p>00_00</p> 
<p>01_00</p> 
<p>01_11</p> 
<p>10_10</p> 
<p>10_00</p> 
<p>11_11</p> 
<p>11_01</p> 
<p>00_10</p> 
<p>注意：“_”只起连接数字，分隔开容易区分位数的作用，和verilog其他地方的用法一致。</p> 
<p>上面的文件被载入到二维的v_mem变量中。仿真的结果被写入console和log_file中。log_file的内容为：</p> 
<p>time test_in0 test_in1 test_out</p> 
<pre><code>    (a)         (b)         (aeqb)
</code></pre> 
<p>0 00 00 1</p> 
<p>200 01 00 0</p> 
<p>400 01 11 0</p> 
<p>600 10 10 1</p> 
<p>800 10 11 0</p> 
<p>1000 11 00 1</p> 
<p>1200 11 01 0</p> 
<p>1400 00 10 0</p> 
<p>log_file为一般的文本文件，可使用其他文本编辑器编辑。</p> 
<p>9 用户自定义函数和任务</p> 
<p>待续</p> 
<p>转载自：http://blog.sina.com.cn/s/blog_78699cbf01016mvt.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/01f42597711277d85babf4986e321c96/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决UOS缺少term.h和curses.h的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bdc5913026c6aed5f67a60ade88d43bc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux 常用操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>