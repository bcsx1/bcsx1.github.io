<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常见医疗扫描图像处理步骤 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="常见医疗扫描图像处理步骤" />
<meta property="og:description" content="常见医疗扫描图像处理步骤 一 下载必要包 skimage需要更新到最新0.13版本，否则会报错，ImportError: cannot import name label。
sudo pip install scikit-image -U -i https://pypi.tuna.tsinghua.edu.cn/simple 二 数据格式 2.1 dicom
当前医疗竞赛官方数据集格式 data-science-bowl-2017。数据列表如下: 后缀为 .dcm。 每个病人的一次扫描CT(scan)可能有几十到一百多个dcm数据文件(slices)。可以使用 python的dicom包读取，读取示例代码如下:
dicom.read_file(&#39;/data/lung_competition/stage1/7050f8141e92fa42fd9c471a8b2f50ce/498d16aa2222d76cae1da144ddc59a13.dcm&#39;) 一般使用其pixl_array数据
slices = [dicom.read_file(os.path.join(folder_name,filename)) for filename in os.listdir(folder_name)] slices = np.stack([s.pixel_array for s in slices]) 2.2 mhd格式
mhd格式是另外一种数据格式，来源于(LUNA2016)[https://luna16.grand-challenge.org/data/]。每个病人一个mhd文件和一个同名的raw文件。如下:
一个mhd通常有几百兆，对应的raw文件只有1kb。mhd文件需要借助python的SimpleITK包来处理。SimpleITK 示例代码如下:
import SimpleITK as sitk itk_img = sitk.ReadImage(img_file) img_array = sitk.GetArrayFromImage(itk_img) # indexes are z,y,x (notice the ordering) num_z, height, width = img_array.shape #heightXwidth constitute the transverse plane origin = np." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/7886e267c3a99a0ae92041174217e96b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-06-09T15:02:13+08:00" />
<meta property="article:modified_time" content="2017-06-09T15:02:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常见医疗扫描图像处理步骤</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="常见医疗扫描图像处理步骤">常见医疗扫描图像处理步骤</h3> 
<hr> 
<h3 id="一-下载必要包">一 下载必要包</h3> 
<p>skimage需要更新到最新0.13版本，否则会报错，ImportError: cannot import name label。</p> 
<pre class="prettyprint"><code class=" hljs avrasm">sudo pip install scikit-image  -U -i  https://pypi<span class="hljs-preprocessor">.tuna</span><span class="hljs-preprocessor">.tsinghua</span><span class="hljs-preprocessor">.edu</span><span class="hljs-preprocessor">.cn</span>/simple</code></pre> 
<h3 id="二-数据格式">二 数据格式</h3> 
<p><strong>2.1 dicom</strong></p> 
<p>当前医疗竞赛官方数据集格式 <a href="https://www.kaggle.com/c/data-science-bowl-2017/data" rel="nofollow">data-science-bowl-2017</a>。数据列表如下: <br> <img title="" alt="这里写图片描述" src="https://images2.imgbox.com/1c/dc/IMhgXFDF_o.png"> <br> 后缀为 .dcm。 <br> 每个病人的一次扫描CT(scan)可能有几十到一百多个dcm数据文件(slices)。可以使用 python的dicom包读取，读取示例代码如下:</p> 
<pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-title">dicom</span>.read_file('/<span class="hljs-typedef"><span class="hljs-keyword">data</span>/lung_competition/stage1/7050f8141e92fa42fd9c471a8b2f50ce/498d16aa2222d76cae1da144ddc59a13.dcm')</span></code></pre> 
<p>一般使用其pixl_array数据</p> 
<pre class="prettyprint"><code class=" hljs avrasm">slices = [dicom<span class="hljs-preprocessor">.read</span>_file(os<span class="hljs-preprocessor">.path</span><span class="hljs-preprocessor">.join</span>(folder_name,filename)) for filename <span class="hljs-keyword">in</span> os<span class="hljs-preprocessor">.listdir</span>(folder_name)]
slices = np<span class="hljs-preprocessor">.stack</span>([s<span class="hljs-preprocessor">.pixel</span>_array for s <span class="hljs-keyword">in</span> slices])</code></pre> 
<p><strong>2.2 mhd格式</strong></p> 
<p>mhd格式是另外一种数据格式，来源于(LUNA2016)[<a href="https://luna16.grand-challenge.org/data/%5D" rel="nofollow noopener noreferrer" target="_blank">https://luna16.grand-challenge.org/data/]</a>。每个病人一个mhd文件和一个同名的raw文件。如下:</p> 
<p><img title="" alt="这里写图片描述" src="https://images2.imgbox.com/18/d9/GNFtZVe7_o.png"></p> 
<p>一个mhd通常有几百兆，对应的raw文件只有1kb。mhd文件需要借助python的SimpleITK包来处理。SimpleITK 示例代码如下:</p> 
<pre class="prettyprint"><code class=" hljs avrasm">import SimpleITK as sitk
itk_img = sitk<span class="hljs-preprocessor">.ReadImage</span>(img_file) 
img_array = sitk<span class="hljs-preprocessor">.GetArrayFromImage</span>(itk_img) <span class="hljs-preprocessor"># indexes are z,y,x (notice the ordering)</span>
num_z, height, width = img_array<span class="hljs-preprocessor">.shape</span>        <span class="hljs-preprocessor">#heightXwidth constitute the transverse plane</span>
origin = np<span class="hljs-preprocessor">.array</span>(itk_img<span class="hljs-preprocessor">.GetOrigin</span>())      <span class="hljs-preprocessor"># x,y,z  Origin in world coordinates (mm)</span>
spacing = np<span class="hljs-preprocessor">.array</span>(itk_img<span class="hljs-preprocessor">.GetSpacing</span>())    <span class="hljs-preprocessor"># spacing of voxels in world coor. (mm)</span></code></pre> 
<p>需要注意的是，SimpleITK的img_array的数组不是直接的像素值，而是相对于CT扫描中原点位置的差值，需要做进一步转换。转换步骤参考 <a href="http://www.simpleitk.org/SimpleITK/help/documentation.html" rel="nofollow noopener noreferrer" target="_blank">SimpleITK</a>图像转换</p> 
<p><strong>2.3 查看CT扫描文件软件</strong></p> 
<p>一个开源免费的查看软件 <a href="http://ric.uthscsa.edu/mango/" rel="nofollow noopener noreferrer" target="_blank">mango</a> <br> <img title="" alt="这里写图片描述" src="https://images2.imgbox.com/71/a2/X2Eg2VYv_o.png"></p> 
<h3 id="三-dicom格式数据处理过程">三 dicom格式数据处理过程</h3> 
<p><strong>3.1 处理思路</strong></p> 
<p>首先，需要明白的是医学扫描图像(scan)其实是三维图像，使用代码读取之后开源查看不同的切面的切片(slices)，可以从不同轴切割</p> 
<p><img title="" alt="这里写图片描述" src="https://images2.imgbox.com/f9/eb/WZZzwyMk_o.png"></p> 
<p>如下图展示了一个病人CT扫描图中，其中部分切片slices</p> 
<p><img title="" alt="这里写图片描述" src="https://images2.imgbox.com/0b/90/BBVSkztB_o.png"></p> 
<p>其次，CT扫描图是包含了所有组织的，如果直接去看，看不到任何有用信息。需要做一些预处理,预处理中一个重要的概念是放射剂量，衡量单位为HU(Hounsfield Unit)，下表是不同放射剂量对应的组织器官</p> 
<p><img title="" alt="这里写图片描述" src="https://images2.imgbox.com/a6/5f/xcoWdgXh_o.png"></p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">Hounsfield Unit </span>=<span class="hljs-string"> pixel_value * rescale_slope + rescale_intercept</span></code></pre> 
<p>一般情况rescale slope = 1, intercept = -1024。 <br> 灰度值是pixel value经过重重LUT转换得到的用来进行显示的值，而这个转换过程是不可逆的，也就是说，灰度值无法转换为ct值。只能根据窗宽窗位得到一个大概的范围。 pixel value经过modality lut得到Hu，但是怀疑pixelvalue的读取出了问题。dicom文件中存在（0028，0106）（0028，0107）两个tag，分别是最大最小pixel value，可以用来检验你读取的pixel value 矩阵是否正确。 <br> LUT全称look up table，实际上就是一张像素灰度值的映射表，它将实际采样到的像素灰度值经过一定的变换如阈值、反转、二值化、对比度调整、线性变换等，变成了另外一 个与之对应的灰度值，这样可以起到突出图像的有用信息，增强图像的光对比度的作用。 <br> 首先去除超过 -2000的pixl_array，CT扫描边界之外的像素值固定为-2000(dicom和mhd都是这个值)。第一步是设定这些值为0，当前对应为空气（值为0）</p> 
<p>slices[slices == -2000] = 0</p> 
<p>上表中肺部组织的HU数值为-500,但通常是大于这个值，比如-320、-400。挑选出这些区域，然后做其他变换抽取出肺部像素点。抽取出这些特征，最后将其存储为ndarray的npy格式，供给卷积神经网络。</p> 
<p><strong>3.2 先载入必要的包</strong></p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>
<span class="hljs-string">'''
this script is used for basic process of lung 2017 in Data Science Bowl
'''</span>

<span class="hljs-keyword">import</span> glob
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> SimpleITK <span class="hljs-keyword">as</span> sitk

<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <span class="hljs-comment"># linear algebra</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd <span class="hljs-comment"># data processing, CSV file I/O (e.g. pd.read_csv)</span>
<span class="hljs-keyword">import</span> skimage, os
<span class="hljs-keyword">from</span> skimage.morphology <span class="hljs-keyword">import</span> ball, disk, dilation, binary_erosion, remove_small_objects, erosion, closing, reconstruction, binary_closing
<span class="hljs-keyword">from</span> skimage.measure <span class="hljs-keyword">import</span> label,regionprops, perimeter
<span class="hljs-keyword">from</span> skimage.morphology <span class="hljs-keyword">import</span> binary_dilation, binary_opening
<span class="hljs-keyword">from</span> skimage.filters <span class="hljs-keyword">import</span> roberts, sobel
<span class="hljs-keyword">from</span> skimage <span class="hljs-keyword">import</span> measure, feature
<span class="hljs-keyword">from</span> skimage.segmentation <span class="hljs-keyword">import</span> clear_border
<span class="hljs-keyword">from</span> skimage <span class="hljs-keyword">import</span> data
<span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> ndimage <span class="hljs-keyword">as</span> ndi
<span class="hljs-keyword">import</span> matplotlib
<span class="hljs-comment">#matplotlib.use('Agg')</span>
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">from</span> mpl_toolkits.mplot3d.art3d <span class="hljs-keyword">import</span> Poly3DCollection
<span class="hljs-keyword">import</span> dicom
<span class="hljs-keyword">import</span> scipy.misc
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</code></pre> 
<p>DICOM是医学图像中标准文件，这些文件包含了诸多的 <br> 元数据信息（比如像素尺寸，每个维度的一像素代表真实世界里的长度）。如下代码是载入一个扫描面，包含了多个切片(slices)，我们仅简化的将其存储为python列表。数据集中每个目录都是一个扫描面集（一个病人）。有个元数据域丢失，即Z轴方向上的像素尺寸，也即切片的厚度 。所幸，我们可以用其他值推测出来，并加入到元数据中。</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-comment"># Load the scans in given folder path</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_scan</span><span class="hljs-params">(path)</span>:</span>
    slices = [dicom.read_file(path + <span class="hljs-string">'/'</span> + s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> os.listdir(path)]
    slices.sort(key = <span class="hljs-keyword">lambda</span> x: int(x.ImagePositionPatient[<span class="hljs-number">2</span>]))
    <span class="hljs-keyword">try</span>:
        slice_thickness = np.abs(slices[<span class="hljs-number">0</span>].ImagePositionPatient[<span class="hljs-number">2</span>] - slices[<span class="hljs-number">1</span>].ImagePositionPatient[<span class="hljs-number">2</span>])
    <span class="hljs-keyword">except</span>:
        slice_thickness = np.abs(slices[<span class="hljs-number">0</span>].SliceLocation - slices[<span class="hljs-number">1</span>].SliceLocation)

    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> slices:
        s.SliceThickness = slice_thickness

    <span class="hljs-keyword">return</span> slices</code></pre> 
<p><strong>3.3 像素转换为HU单元</strong></p> 
<p>有些扫描面有圆柱形扫描边界，但是输出图像是正方形。边界之外的像素值固定为-2000,。第一步是设定这些值为0，当前对应为空气（值为0）。然后回到HU单元，乘以rescale比率并加上intercept(存储在扫描面的元数据中)。</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_pixels_hu</span><span class="hljs-params">(slices)</span>:</span>
    image = np.stack([s.pixel_array <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> slices])
    <span class="hljs-comment"># Convert to int16 (from sometimes int16), </span>
    <span class="hljs-comment"># should be possible as values should always be low enough (&lt;32k)</span>
    image = image.astype(np.int16)
    <span class="hljs-comment"># Set outside-of-scan pixels to 0</span>
    <span class="hljs-comment"># The intercept is usually -1024, so air is approximately 0</span>
    image[image == -<span class="hljs-number">2000</span>] = <span class="hljs-number">0</span>

</code></pre> 
<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-preprocessor"># Convert to Hounsfield units (HU)</span>
    for slice_number <span class="hljs-keyword">in</span> range(len(slices)):

        intercept = slices[slice_number]<span class="hljs-preprocessor">.RescaleIntercept</span>
        slope = slices[slice_number]<span class="hljs-preprocessor">.RescaleSlope</span>

        if slope != <span class="hljs-number">1</span>:
            image[slice_number] = slope * image[slice_number]<span class="hljs-preprocessor">.astype</span>(np<span class="hljs-preprocessor">.float</span>64)
            image[slice_number] = image[slice_number]<span class="hljs-preprocessor">.astype</span>(np<span class="hljs-preprocessor">.int</span>16)

        image[slice_number] += np<span class="hljs-preprocessor">.int</span>16(intercept)

    return np<span class="hljs-preprocessor">.array</span>(image, dtype=np<span class="hljs-preprocessor">.int</span>16)</code></pre> 
<p>可以查看病人的扫描HU值分布情况</p> 
<pre class="prettyprint"><code class=" hljs avrasm">first_patient = load_scan(INPUT_FOLDER + patients[<span class="hljs-number">0</span>])
first_patient_pixels = get_pixels_hu(first_patient)
plt<span class="hljs-preprocessor">.hist</span>(first_patient_pixels<span class="hljs-preprocessor">.flatten</span>(), bins=<span class="hljs-number">80</span>, color=<span class="hljs-string">'c'</span>)
plt<span class="hljs-preprocessor">.xlabel</span>(<span class="hljs-string">"Hounsfield Units (HU)"</span>)
plt<span class="hljs-preprocessor">.ylabel</span>(<span class="hljs-string">"Frequency"</span>)
plt<span class="hljs-preprocessor">.show</span>()</code></pre> 
<p><img title="" alt="这里写图片描述" src="https://images2.imgbox.com/9e/e2/EvP4bXiY_o.png"></p> 
<p><strong>3.4重新采样</strong></p> 
<p>不同扫描面的像素尺寸、粗细粒度是不同的。这不利于我们进行CNN任务，我们可以使用同构采样。 <br> 一个扫描面的像素区间可能是[2.5,0.5,0.5],即切片之间的距离为2.5mm。可能另外一个扫描面的范围是[1.5,0.725,0.725]。这可能不利于自动分析。 <br> 常见的处理方法是从全数据集中以固定的同构分辨率重新采样。如果我们选择，将所有的东西采样为1mmx1mmx1mm像素，我们可以使用3D卷积网络</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resample</span><span class="hljs-params">(image, scan, new_spacing=[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])</span>:</span>
    <span class="hljs-comment"># Determine current pixel spacing</span>
    spacing = map(float, ([scan[<span class="hljs-number">0</span>].SliceThickness] + scan[<span class="hljs-number">0</span>].PixelSpacing))
    spacing = np.array(list(spacing))
    resize_factor = spacing / new_spacing
    new_real_shape = image.shape * resize_factor
    new_shape = np.round(new_real_shape)
    real_resize_factor = new_shape / image.shape
    new_spacing = spacing / real_resize_factor

    image = scipy.ndimage.interpolation.zoom(image, real_resize_factor, mode=<span class="hljs-string">'nearest'</span>)

    <span class="hljs-keyword">return</span> image, new_spacing</code></pre> 
<p>现在重新取样病人的像素，将其映射到一个同构分辨率 1mm x1mm x1mm。</p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">pix_resampled, spacing </span>=<span class="hljs-string"> resample(first_patient_pixels, first_patient, [1,1,1])</span></code></pre> 
<p>输出肺部扫描的3D图像方法</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_3d</span><span class="hljs-params">(image, threshold=-<span class="hljs-number">300</span>)</span>:</span>

    <span class="hljs-comment"># Position the scan upright, </span>
    <span class="hljs-comment"># so the head of the patient would be at the top facing the camera</span>
    p = image.transpose(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)

    verts, faces = measure.marching_cubes(p, threshold)
    fig = plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))
    ax = fig.add_subplot(<span class="hljs-number">111</span>, projection=<span class="hljs-string">'3d'</span>)
    <span class="hljs-comment"># Fancy indexing: `verts[faces]` to generate a collection of triangles</span>
    mesh = Poly3DCollection(verts[faces], alpha=<span class="hljs-number">0.1</span>)
    face_color = [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>]
    mesh.set_facecolor(face_color)
    ax.add_collection3d(mesh)
    ax.set_xlim(<span class="hljs-number">0</span>, p.shape[<span class="hljs-number">0</span>])
    ax.set_ylim(<span class="hljs-number">0</span>, p.shape[<span class="hljs-number">1</span>])
    ax.set_zlim(<span class="hljs-number">0</span>, p.shape[<span class="hljs-number">2</span>])
    plt.show()</code></pre> 
<p>打印函数有个阈值参数，来打印特定的结构，比如tissue或者骨头。400是一个仅仅打印骨头的阈值(HU对照表)</p> 
<pre class="prettyprint"><code class=" hljs erlang"><span class="hljs-function"><span class="hljs-title">plot_3d</span><span class="hljs-params">(pix_resampled, <span class="hljs-number">400</span>)</span></span></code></pre> 
<p><img title="" alt="这里写图片描述" src="https://images2.imgbox.com/2f/89/hWGDzSPh_o.jpg"></p> 
<p><strong>3.5 输出一个病人scans中所有切面slices</strong></p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_ct_scan</span><span class="hljs-params">(scan)</span>:</span>
    <span class="hljs-string">'''
            plot a few more images of the slices
    :param scan:
    :return:
    '''</span>
    f, plots = plt.subplots(int(scan.shape[<span class="hljs-number">0</span>] / <span class="hljs-number">20</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, figsize=(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>))
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, scan.shape[<span class="hljs-number">0</span>], <span class="hljs-number">5</span>):
        plots[int(i / <span class="hljs-number">20</span>), int((i % <span class="hljs-number">20</span>) / <span class="hljs-number">5</span>)].axis(<span class="hljs-string">'off'</span>)
        plots[int(i / <span class="hljs-number">20</span>), int((i % <span class="hljs-number">20</span>) / <span class="hljs-number">5</span>)].imshow(scan[i], cmap=plt.cm.bone)</code></pre> 
<p>此方法的效果示例如下:</p> 
<p><img title="" alt="这里写图片描述" src="https://images2.imgbox.com/14/de/dIdweiul_o.png"></p> 
<p>3.6 定义分割出CT切面里面肺部组织的函数</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_segmented_lungs</span><span class="hljs-params">(im, plot=False)</span>:</span>

    <span class="hljs-string">'''
    This funtion segments the lungs from the given 2D slice.
    '''</span>
    <span class="hljs-keyword">if</span> plot == <span class="hljs-keyword">True</span>:
        f, plots = plt.subplots(<span class="hljs-number">8</span>, <span class="hljs-number">1</span>, figsize=(<span class="hljs-number">5</span>, <span class="hljs-number">40</span>))
    <span class="hljs-string">'''
    Step 1: Convert into a binary image.
    '''</span>
    binary = im &lt; <span class="hljs-number">604</span>
    <span class="hljs-keyword">if</span> plot == <span class="hljs-keyword">True</span>:
        plots[<span class="hljs-number">0</span>].axis(<span class="hljs-string">'off'</span>)
        plots[<span class="hljs-number">0</span>].set_title(<span class="hljs-string">'binary image'</span>)
        plots[<span class="hljs-number">0</span>].imshow(binary, cmap=plt.cm.bone)

    <span class="hljs-string">'''
    Step 2: Remove the blobs connected to the border of the image.
    '''</span>
    cleared = clear_border(binary)
    <span class="hljs-keyword">if</span> plot == <span class="hljs-keyword">True</span>:
        plots[<span class="hljs-number">1</span>].axis(<span class="hljs-string">'off'</span>)
        plots[<span class="hljs-number">1</span>].set_title(<span class="hljs-string">'after clear border'</span>)
        plots[<span class="hljs-number">1</span>].imshow(cleared, cmap=plt.cm.bone)

    <span class="hljs-string">'''
    Step 3: Label the image.
    '''</span>
    label_image = label(cleared)
    <span class="hljs-keyword">if</span> plot == <span class="hljs-keyword">True</span>:
        plots[<span class="hljs-number">2</span>].axis(<span class="hljs-string">'off'</span>)
        plots[<span class="hljs-number">2</span>].set_title(<span class="hljs-string">'found all connective graph'</span>)
        plots[<span class="hljs-number">2</span>].imshow(label_image, cmap=plt.cm.bone)
    <span class="hljs-string">'''
    Step 4: Keep the labels with 2 largest areas.
    '''</span>
    areas = [r.area <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> regionprops(label_image)]
    areas.sort()
    <span class="hljs-keyword">if</span> len(areas) &gt; <span class="hljs-number">2</span>:
        <span class="hljs-keyword">for</span> region <span class="hljs-keyword">in</span> regionprops(label_image):
            <span class="hljs-keyword">if</span> region.area &lt; areas[-<span class="hljs-number">2</span>]:
                <span class="hljs-keyword">for</span> coordinates <span class="hljs-keyword">in</span> region.coords:
                       label_image[coordinates[<span class="hljs-number">0</span>], coordinates[<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span>
    binary = label_image &gt; <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> plot == <span class="hljs-keyword">True</span>:
        plots[<span class="hljs-number">3</span>].axis(<span class="hljs-string">'off'</span>)
        plots[<span class="hljs-number">3</span>].set_title(<span class="hljs-string">' Keep the labels with 2 largest areas'</span>)
        plots[<span class="hljs-number">3</span>].imshow(binary, cmap=plt.cm.bone)
    <span class="hljs-string">'''
    Step 5: Erosion operation with a disk of radius 2. This operation is
    seperate the lung nodules attached to the blood vessels.
    '''</span>
    selem = disk(<span class="hljs-number">2</span>)
    binary = binary_erosion(binary, selem)
    <span class="hljs-keyword">if</span> plot == <span class="hljs-keyword">True</span>:
        plots[<span class="hljs-number">4</span>].axis(<span class="hljs-string">'off'</span>)
        plots[<span class="hljs-number">4</span>].set_title(<span class="hljs-string">'seperate the lung nodules attached to the blood vessels'</span>)
        plots[<span class="hljs-number">4</span>].imshow(binary, cmap=plt.cm.bone)
    <span class="hljs-string">'''
    Step 6: Closure operation with a disk of radius 10. This operation is
    to keep nodules attached to the lung wall.
    '''</span>
    selem = disk(<span class="hljs-number">10</span>)
    binary = binary_closing(binary, selem)
    <span class="hljs-keyword">if</span> plot == <span class="hljs-keyword">True</span>:
        plots[<span class="hljs-number">5</span>].axis(<span class="hljs-string">'off'</span>)
        plots[<span class="hljs-number">5</span>].set_title(<span class="hljs-string">'keep nodules attached to the lung wall'</span>)
        plots[<span class="hljs-number">5</span>].imshow(binary, cmap=plt.cm.bone)
    <span class="hljs-string">'''
    Step 7: Fill in the small holes inside the binary mask of lungs.
    '''</span>
    edges = roberts(binary)
    binary = ndi.binary_fill_holes(edges)
    <span class="hljs-keyword">if</span> plot == <span class="hljs-keyword">True</span>:
        plots[<span class="hljs-number">6</span>].axis(<span class="hljs-string">'off'</span>)
        plots[<span class="hljs-number">6</span>].set_title(<span class="hljs-string">'Fill in the small holes inside the binary mask of lungs'</span>)
        plots[<span class="hljs-number">6</span>].imshow(binary, cmap=plt.cm.bone)
    <span class="hljs-string">'''
    Step 8: Superimpose the binary mask on the input image.
    '''</span>
    get_high_vals = binary == <span class="hljs-number">0</span>
    im[get_high_vals] = <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> plot == <span class="hljs-keyword">True</span>:
        plots[<span class="hljs-number">7</span>].axis(<span class="hljs-string">'off'</span>)
        plots[<span class="hljs-number">7</span>].set_title(<span class="hljs-string">'Superimpose the binary mask on the input image'</span>)
        plots[<span class="hljs-number">7</span>].imshow(im, cmap=plt.cm.bone)

    <span class="hljs-keyword">return</span> im</code></pre> 
<p>此方法每个步骤对图像做不同的处理，效果如下:</p> 
<p><img title="" alt="这里写图片描述" src="https://images2.imgbox.com/6b/0a/GjR5Qii3_o.png"></p> 
<p><strong>3.7 肺部图像分割</strong></p> 
<p>为了减少有问题的空间，我们可以分割肺部图像（有时候是附近的组织）。这包含一些步骤，包括区域增长和形态运算，此时，我们只分析相连组件。 <br> 步骤如下：</p> 
<ul><li>阈值图像（-320HU是个极佳的阈值，但是此方法中不是必要）</li><li>处理相连的组件，以决定当前患者的空气的标签，以1填充这些二值图像</li><li>可选：当前扫描的每个轴上的切片，选定最大固态连接的组织（当前患者的肉体和空气），并且其他的为0。以掩码的方式填充肺部结构。</li><li>只保留最大的气袋（人类躯体内到处都有气袋）</li></ul> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">largest_label_volume</span><span class="hljs-params">(im, bg=-<span class="hljs-number">1</span>)</span>:</span>
    vals, counts = np.unique(im, return_counts=<span class="hljs-keyword">True</span>)
    counts = counts[vals != bg]
    vals = vals[vals != bg]
    <span class="hljs-keyword">if</span> len(counts) &gt; <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> vals[np.argmax(counts)]
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">segment_lung_mask</span><span class="hljs-params">(image, fill_lung_structures=True)</span>:</span>

    <span class="hljs-comment"># not actually binary, but 1 and 2. </span>
    <span class="hljs-comment"># 0 is treated as background, which we do not want</span>
    binary_image = np.array(image &gt; -<span class="hljs-number">320</span>, dtype=np.int8)+<span class="hljs-number">1</span>
    labels = measure.label(binary_image)

    <span class="hljs-comment"># Pick the pixel in the very corner to determine which label is air.</span>
    <span class="hljs-comment">#   Improvement: Pick multiple background labels from around the patient</span>
    <span class="hljs-comment">#   More resistant to "trays" on which the patient lays cutting the air </span>
    <span class="hljs-comment">#   around the person in half</span>
    background_label = labels[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]

    <span class="hljs-comment">#Fill the air around the person</span>
    binary_image[background_label == labels] = <span class="hljs-number">2</span>


    <span class="hljs-comment"># Method of filling the lung structures (that is superior to something like </span>
    <span class="hljs-comment"># morphological closing)</span>
    <span class="hljs-keyword">if</span> fill_lung_structures:
        <span class="hljs-comment"># For every slice we determine the largest solid structure</span>
        <span class="hljs-keyword">for</span> i, axial_slice <span class="hljs-keyword">in</span> enumerate(binary_image):
            axial_slice = axial_slice - <span class="hljs-number">1</span>
            labeling = measure.label(axial_slice)
            l_max = largest_label_volume(labeling, bg=<span class="hljs-number">0</span>)

            <span class="hljs-keyword">if</span> l_max <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>: <span class="hljs-comment">#This slice contains some lung</span>
                binary_image[i][labeling != l_max] = <span class="hljs-number">1</span>

    binary_image -= <span class="hljs-number">1</span> <span class="hljs-comment">#Make the image actual binary</span>
    binary_image = <span class="hljs-number">1</span>-binary_image <span class="hljs-comment"># Invert it, lungs are now 1</span>

    <span class="hljs-comment"># Remove other air pockets insided body</span>
    labels = measure.label(binary_image, background=<span class="hljs-number">0</span>)
    l_max = largest_label_volume(labels, bg=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">if</span> l_max <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>: <span class="hljs-comment"># There are air pockets</span>
        binary_image[labels != l_max] = <span class="hljs-number">0</span>

    <span class="hljs-keyword">return</span> binary_image</code></pre> 
<p>查看切割效果</p> 
<pre class="prettyprint"><code class=" hljs mathematica">segmented_lungs = segment_lung_mask(pix_resampled, <span class="hljs-keyword">False</span>)
segmented_lungs_fill = segment_lung_mask(pix_resampled, <span class="hljs-keyword">True</span>)
plot_3d(segmented_lungs, <span class="hljs-number">0</span>)</code></pre> 
<p><img title="" alt="这里写图片描述" src="https://images2.imgbox.com/2a/eb/ZZSckRNM_o.jpg"></p> 
<p>我们可以将肺内的结构也包含进来（结节是固体），不仅仅只是肺部内的空气</p> 
<pre class="prettyprint"><code class=" hljs erlang"><span class="hljs-function"><span class="hljs-title">plot_3d</span><span class="hljs-params">(segmented_lungs_fill, <span class="hljs-number">0</span>)</span></span></code></pre> 
<p><img title="" alt="这里写图片描述" src="https://images2.imgbox.com/ae/6b/fM0h2LRK_o.jpg"></p> 
<p>使用掩码时，要注意首先进行形态扩充(python的skimage的skimage.morphology)操作（即使用圆形kernel，结节是球体），参考 python形态操作。这会在所有方向（维度）上扩充掩码。仅仅肺部的空气+结构将不会包含所有结节，事实上有可能遗漏黏在肺部一侧的结节（这会经常出现，所以建议最好是扩充掩码）。</p> 
<p><strong>3.8 数据预处理</strong></p> 
<p><strong>归一化处理</strong> <br> 当前的值范围是[-1024,2000]。任意大于400的值都是我们所感兴趣的，因为它们都是不同反射密度下的骨头。LUNA16竞赛中常用来做归一化处理的阈值集是-1000和400.以下代码</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-comment">#归一化</span>
MIN_BOUND = -<span class="hljs-number">1000.0</span>
MAX_BOUND = <span class="hljs-number">400.0</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">normalize</span><span class="hljs-params">(image)</span>:</span>
    image = (image - MIN_BOUND) / (MAX_BOUND - MIN_BOUND)
    image[image&gt;<span class="hljs-number">1</span>] = <span class="hljs-number">1.</span>
    image[image&lt;<span class="hljs-number">0</span>] = <span class="hljs-number">0.</span>
    <span class="hljs-keyword">return</span> image</code></pre> 
<p><strong>0值中心化</strong> <br> 简单来说就是所有像素值减去均值。LUNA16竞赛中的均值大约是0.25. <br> 不要对每一张图像做零值中心化（此处像是在kernel中完成的）CT扫描器返回的是校准后的精确HU计量。不会出现普通图像中会出现某些图像低对比度和明亮度的情况</p> 
<pre class="prettyprint"><code class=" hljs python">PIXEL_MEAN = <span class="hljs-number">0.25</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zero_center</span><span class="hljs-params">(image)</span>:</span>
    image = image - PIXEL_MEAN
    <span class="hljs-keyword">return</span> image
</code></pre> 
<p><strong>3.9 存储每个病人scan的所有slice肺部特征</strong></p> 
<p>下述代码为main函数中整体过程</p> 
<pre class="prettyprint"><code class=" hljs lua"> lung_head_dir = <span class="hljs-string">'/data/lung_competition/stage1/'</span>
    img_save_head = <span class="hljs-string">'/data/lung_competition/roi_images/'</span>
    patient_scans_list = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">os</span>.listdir(lung_head_dir) <span class="hljs-keyword">if</span> <span class="hljs-built_in">os</span>.path.isdir(<span class="hljs-built_in">os</span>.path.join(lung_head_dir,x))]
    #patient_labels_file = <span class="hljs-string">'/data/lung_competition/stage1_labels.csv'</span>
    #patient_labels = pd.read_csv(patient_labels_file)
    selem = ball(<span class="hljs-number">2</span>)
    #<span class="hljs-built_in">print</span>(patient_scans_list)
    <span class="hljs-keyword">for</span> scan <span class="hljs-keyword">in</span> patient_scans_list:
        scan_files = <span class="hljs-built_in">os</span>.path.join(lung_head_dir,scan)
        ct_scan = read_ct_scan(scan_files)
        save_npy_path = <span class="hljs-built_in">os</span>.path.join(img_save_head, scan)
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">os</span>.path.exists(save_npy_path):
            <span class="hljs-built_in">os</span>.mkdir(save_npy_path)</code></pre> 
<p>存储病人scan的所有slice肺部特征的关键代码为</p> 
<pre class="prettyprint"><code class=" hljs perl">segmented_ct_scan = segment_lung_from_ct_scan(ct_scan)
save_npy = save_npy_path+<span class="hljs-string">'.npy'</span>
np.save(save_npy,segmented_ct_scan)
<span class="hljs-keyword">print</span>(<span class="hljs-string">'file %s saved ..'</span><span class="hljs-variable">%save_npy</span>)
plot_ct_scan(segmented_ct_scan)</code></pre> 
<h3 id="四-mhd格式数据处理过程">四 mhd格式数据处理过程</h3> 
<p><strong>4.1 处理思路</strong></p> 
<p>mhd的数据只是格式与dicom不一样，其实质包含的都是病人扫描。处理MHD需要借助SimpleIKT这个包，处理思路详情可以参考Data Science Bowl2017的toturail Data Science Bowl 2017。需要注意的是MHD格式的数据没有HU值，它的值域范围与dicom很不同。 <br> 我们以LUNA2016年的数据处理流程为例。参考代码为 LUNA2016数据切割</p> 
<p><strong>4.2 载入必要的包</strong></p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">import</span> SimpleITK <span class="hljs-keyword">as</span> sitk
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> csv
<span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> glob
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
file_list=glob(luna_subset_path+<span class="hljs-string">"*.mhd"</span>)
<span class="hljs-comment">#####################</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># Helper function to get rows in data frame associated </span>
<span class="hljs-comment"># with each file</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_filename</span><span class="hljs-params">(case)</span>:</span>
    <span class="hljs-keyword">global</span> file_list
    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> file_list:
        <span class="hljs-keyword">if</span> case <span class="hljs-keyword">in</span> f:
            <span class="hljs-keyword">return</span>(f)
<span class="hljs-comment">#</span>
<span class="hljs-comment"># The locations of the nodes</span>
df_node = pd.read_csv(luna_path+<span class="hljs-string">"annotations.csv"</span>)
df_node[<span class="hljs-string">"file"</span>] = df_node[<span class="hljs-string">"seriesuid"</span>].apply(get_filename)
df_node = df_node.dropna()
<span class="hljs-comment">#####</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># Looping over the image files</span>
<span class="hljs-comment">#</span>
fcount = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> img_file <span class="hljs-keyword">in</span> file_list:
    <span class="hljs-keyword">print</span> <span class="hljs-string">"Getting mask for image file %s"</span> % img_file.replace(luna_subset_path,<span class="hljs-string">""</span>)
    mini_df = df_node[df_node[<span class="hljs-string">"file"</span>]==img_file] <span class="hljs-comment">#get all nodules associate with file</span>
    <span class="hljs-keyword">if</span> len(mini_df)&gt;<span class="hljs-number">0</span>:       <span class="hljs-comment"># some files may not have a nodule--skipping those </span>
        biggest_node = np.argsort(mini_df[<span class="hljs-string">"diameter_mm"</span>].values)[-<span class="hljs-number">1</span>]   <span class="hljs-comment"># just using the biggest node</span>
        node_x = mini_df[<span class="hljs-string">"coordX"</span>].values[biggest_node]
        node_y = mini_df[<span class="hljs-string">"coordY"</span>].values[biggest_node]
        node_z = mini_df[<span class="hljs-string">"coordZ"</span>].values[biggest_node]
        diam = mini_df[<span class="hljs-string">"diameter_mm"</span>].values[biggest_node]</code></pre> 
<p><strong>4.3 LUNA16的MHD格式数据的值</strong></p> 
<p>一直在寻找MHD格式数据的处理方法，对于dicom格式的CT有很多论文根据其HU值域可以轻易地分割肺、骨头、血液等，但是对于MHD没有这样的参考。从LUNA16论坛得到的解释是，LUNA16的MHD数据已经转换为HU值了，不需要再使用slope和intercept来做rescale变换了。此论坛主题下，有人提出MHD格式没有提供pixel spacing(mm) 和 slice thickness(mm) ，而标准文件annotation.csv文件中结节的半径和坐标都是mm单位，最后确认的是MHD格式文件中只保留了体素尺寸以及坐标原点位置，没有保存slice thickness。如此来说，dicom才是原始数据格式。</p> 
<p><strong>4.4 坐标体系变换</strong></p> 
<p>MHD值得坐标体系是体素，以mm为单位。结节的位置是CT scanner坐标轴里面相对原点的mm值，需要将其转换到真实坐标轴位置，可以使用SimpleITK包中的 GetOrigin() <code>GetSpacing()</code>。图像数据是以512x512数组的形式给出的。 <br> 坐标变换如</p> 
<p><img title="" alt="这里写图片描述" src="https://images2.imgbox.com/ff/51/VboUXlWs_o.png"> </p> 
<p>相应的代码处理如下:</p> 
<pre class="prettyprint"><code class=" hljs avrasm">k_img = sitk<span class="hljs-preprocessor">.ReadImage</span>(img_file) 
img_array = sitk<span class="hljs-preprocessor">.GetArrayFromImage</span>(itk_img) <span class="hljs-preprocessor"># indexes are z,y,x (notice the ordering)</span>
center = np<span class="hljs-preprocessor">.array</span>([node_x,node_y,node_z])   <span class="hljs-preprocessor"># nodule center</span>
origin = np<span class="hljs-preprocessor">.array</span>(itk_img<span class="hljs-preprocessor">.GetOrigin</span>())      <span class="hljs-preprocessor"># x,y,z  Origin in world coordinates (mm)</span>
spacing = np<span class="hljs-preprocessor">.array</span>(itk_img<span class="hljs-preprocessor">.GetSpacing</span>())    <span class="hljs-preprocessor"># spacing of voxels in world coor. (mm)</span>
v_center =np<span class="hljs-preprocessor">.rint</span>((center-origin)/spacing)  <span class="hljs-preprocessor"># nodule center in voxel space (still x,y,z ordering)</span>
</code></pre> 
<p>在LUNA16的标注CSV文件中标注了结节中心的X,Y,Z轴坐标，但是实际取值的时候取的是Z轴最后三层的数组(img_array)。 <br> 下述代码只提取了包含结节的最后三个slice的数据</p> 
<pre class="prettyprint"><code class=" hljs perl">i=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i_z in range(<span class="hljs-keyword">int</span>(v_center[<span class="hljs-number">2</span>])-<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span>(v_center[<span class="hljs-number">2</span>])+<span class="hljs-number">2</span>):
    mask = make_mask(center,diam,i_z<span class="hljs-variable">*spacing</span>[<span class="hljs-number">2</span>]+origin[<span class="hljs-number">2</span>],width,height,spacing,origin)
    masks[i] = mask
    imgs[i] = matrix2int16(img_array[i_z])
    i+=<span class="hljs-number">1</span>
np.save(output_path+<span class="hljs-string">"images_<span class="hljs-variable">%d</span>.npy"</span> % (fcount) ,imgs)
np.save(output_path+<span class="hljs-string">"masks_<span class="hljs-variable">%d</span>.npy"</span> % (fcount) ,masks)</code></pre> 
<p><strong>4.5 查看结节</strong></p> 
<p>以下代码用于查看原始CT和结mask</p> 
<pre class="prettyprint"><code class=" hljs livecodeserver">import matplotlib.pyplot <span class="hljs-keyword">as</span> plt
imgs = np.<span class="hljs-built_in">load</span>(output_path+<span class="hljs-string">'images_0.npy'</span>)
masks = np.<span class="hljs-built_in">load</span>(output_path+<span class="hljs-string">'masks_0.npy'</span>)
<span class="hljs-keyword">for</span> i <span class="hljs-operator">in</span> range(<span class="hljs-built_in">len</span>(imgs)):
    print <span class="hljs-string">"image %d"</span> % i
    fig,ax = plt.subplots(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,figsize=[<span class="hljs-number">8</span>,<span class="hljs-number">8</span>])
    ax[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>].imshow(imgs[i],cmap=<span class="hljs-string">'gray'</span>)
    ax[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>].imshow(masks[i],cmap=<span class="hljs-string">'gray'</span>)
    ax[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>].imshow(imgs[i]*masks[i],cmap=<span class="hljs-string">'gray'</span>)
    plt.show()
    raw_input(<span class="hljs-string">"hit enter to cont : "</span>)</code></pre> 
<p><img title="" alt="这里写图片描述" src="https://images2.imgbox.com/26/f1/noP0t8jN_o.png"></p> 
<p><strong>4.6 包含结节位置信息的mhd格式数据特征</strong></p> 
<p>参考一个开源代码实现 <a href="https://github.com/booz-allen-hamilton/DSB3Tutorial/blob/master/Tutorial.ipynb" target="_blank" rel="noopener noreferrer">UNET训练肺组织结节分割</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6370db43e2f1d3f7e9b6f5981b961d05/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">fastboot 常用命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2bc5f406024dd1474691b15beae03dc0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MUI back返回父页面，同时刷新父页面</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>