<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>开源项目解读 —— Self-Operating Computer Framework # 长期主义 # 价值 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="开源项目解读 —— Self-Operating Computer Framework # 长期主义 # 价值" />
<meta property="og:description" content="价值：生成主函数业务逻辑函数思维导图，帮助理解，PR到开源项目，希望帮助大家理解IPA工作原理，国内没有好的开源项目，我就来翻译分析解读，给大家抛砖引玉。思维导图打算用文心一言配合其思维导图插件实现。
开源链接：OthersideAI/self-operating-computer: A framework to enable multimodal models to operate a computer. (github.com)
目录
目录
整体代码框架 核心代码逻辑
capture_screen_with_cursor # 用光标捕获屏幕
capture_mini_screenshot_with_cursor # 将截图和网格一起保存
add_grid_to_image # 给图像配上网格 keyboard_type# 用于通过程序模拟键盘输入
search # 模拟在操作系统中搜索文本。具体来说，它会模拟按下“开始”键（在Windows中）或“Command”和“空格”键（在MacOS中），然后输入提供的文本并按下“Enter”键。
keyboard_type# 用于通过程序模拟键盘输入
&#34;extract_json_from_string&#34; and &#34;convert_percent_to_decimal&#34;# 从json提取字符与把百分数转换为小数点
draw_label_with_background # 在屏幕上绘制一个网格，并在网格的每个交叉点上添加百分比标签。该函数可以捕获在 Linux 和 macOS 系统上工作。
click_at_percentage # 在屏幕上点击指定百分比的位置
mouse_click # 在屏幕上点击指定百分比的位置
summarize # 用于使用预先训练好的模型来生成摘要。该函数可以捕获屏幕截图并将其作为输入提供给模型。该函数可以尝试使用两个预训练模型：`gpt-4-vision-preview` 和 `gemini-pro-vision`。
parse_response # 用于该函数解析与 AI 对话交互的响应。该函数可以捕获不同的响应类型，例如点击、输入文本或搜索查询。总之，`parse_response` 函数将响应解析为字典，其中包含一个表示响应类型的字符串和一个与响应类型相关的数据
get_next_action_from_gemini_pro_vision # 该函数使用预训练的模型`gemini-pro-vision`生成下一个操作。该函数可以捕获屏幕截图并将其作为输入提供给模型。
get_next_action_from_openai # 该函数使用 OpenAI 的 GPT-4 模型生成下一个操作。该函数可以捕获屏幕截图并将其作为输入提供给模型。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/b25fce40e0e71a58202032dc68048962/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-27T15:43:20+08:00" />
<meta property="article:modified_time" content="2023-12-27T15:43:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">开源项目解读 —— Self-Operating Computer Framework # 长期主义 # 价值</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>价值：</strong>生成主函数业务逻辑函数思维导图，帮助理解，PR到开源项目，希望帮助大家理解IPA工作原理，国内没有好的开源项目，我就来翻译分析解读，给大家抛砖引玉。思维导图打算用文心一言配合其思维导图插件实现。</p> 
<p><strong>开源链接：</strong><a href="https://github.com/OthersideAI/self-operating-computer" title="OthersideAI/self-operating-computer: A framework to enable multimodal models to operate a computer. (github.com)">OthersideAI/self-operating-computer: A framework to enable multimodal models to operate a computer. (github.com)</a></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%C2%A0" rel="nofollow">整体代码框架 </a></p> 
<p id="%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91-toc" style="margin-left:0px;"><a href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91" rel="nofollow">核心代码逻辑</a></p> 
<p id="capture_screen_with_cursor%20%23%C2%A0%E7%94%A8%E5%85%89%E6%A0%87%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95-toc" style="margin-left:80px;"><a href="#capture_screen_with_cursor%20%23%C2%A0%E7%94%A8%E5%85%89%E6%A0%87%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95" rel="nofollow">capture_screen_with_cursor # 用光标捕获屏幕</a></p> 
<p id="%C2%A0capture_mini_screenshot_with_cursor%20%23%C2%A0%E5%B0%86%E6%88%AA%E5%9B%BE%E5%92%8C%E7%BD%91%E6%A0%BC%E4%B8%80%E8%B5%B7%E4%BF%9D%E5%AD%98-toc" style="margin-left:80px;"><a href="#%C2%A0capture_mini_screenshot_with_cursor%20%23%C2%A0%E5%B0%86%E6%88%AA%E5%9B%BE%E5%92%8C%E7%BD%91%E6%A0%BC%E4%B8%80%E8%B5%B7%E4%BF%9D%E5%AD%98" rel="nofollow"> capture_mini_screenshot_with_cursor # 将截图和网格一起保存</a></p> 
<p id="add_grid_to_image%20%23%C2%A0%E7%BB%99%E5%9B%BE%E5%83%8F%E9%85%8D%E4%B8%8A%E7%BD%91%E6%A0%BC%C2%A0-toc" style="margin-left:80px;"><a href="#add_grid_to_image%20%23%C2%A0%E7%BB%99%E5%9B%BE%E5%83%8F%E9%85%8D%E4%B8%8A%E7%BD%91%E6%A0%BC%C2%A0" rel="nofollow">add_grid_to_image # 给图像配上网格 </a></p> 
<p id="keyboard_type%23%C2%A0%E7%94%A8%E4%BA%8E%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5-toc" style="margin-left:80px;"><a href="#keyboard_type%23%C2%A0%E7%94%A8%E4%BA%8E%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5" rel="nofollow">keyboard_type# 用于通过程序模拟键盘输入</a></p> 
<p id="%C2%A0search%20%23%C2%A0%E6%A8%A1%E6%8B%9F%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%90%9C%E7%B4%A2%E6%96%87%E6%9C%AC%E3%80%82%E5%85%B7%E4%BD%93%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%AE%83%E4%BC%9A%E6%A8%A1%E6%8B%9F%E6%8C%89%E4%B8%8B%E2%80%9C%E5%BC%80%E5%A7%8B%E2%80%9D%E9%94%AE%EF%BC%88%E5%9C%A8Windows%E4%B8%AD%EF%BC%89%E6%88%96%E2%80%9CCommand%E2%80%9D%E5%92%8C%E2%80%9C%E7%A9%BA%E6%A0%BC%E2%80%9D%E9%94%AE%EF%BC%88%E5%9C%A8MacOS%E4%B8%AD%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%87%E6%9C%AC%E5%B9%B6%E6%8C%89%E4%B8%8B%E2%80%9CEnter%E2%80%9D%E9%94%AE%E3%80%82-toc" style="margin-left:80px;"><a href="#%C2%A0search%20%23%C2%A0%E6%A8%A1%E6%8B%9F%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%90%9C%E7%B4%A2%E6%96%87%E6%9C%AC%E3%80%82%E5%85%B7%E4%BD%93%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%AE%83%E4%BC%9A%E6%A8%A1%E6%8B%9F%E6%8C%89%E4%B8%8B%E2%80%9C%E5%BC%80%E5%A7%8B%E2%80%9D%E9%94%AE%EF%BC%88%E5%9C%A8Windows%E4%B8%AD%EF%BC%89%E6%88%96%E2%80%9CCommand%E2%80%9D%E5%92%8C%E2%80%9C%E7%A9%BA%E6%A0%BC%E2%80%9D%E9%94%AE%EF%BC%88%E5%9C%A8MacOS%E4%B8%AD%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%87%E6%9C%AC%E5%B9%B6%E6%8C%89%E4%B8%8B%E2%80%9CEnter%E2%80%9D%E9%94%AE%E3%80%82" rel="nofollow"> search # 模拟在操作系统中搜索文本。具体来说，它会模拟按下“开始”键（在Windows中）或“Command”和“空格”键（在MacOS中），然后输入提供的文本并按下“Enter”键。</a></p> 
<p id="%C2%A0keyboard_type%23%C2%A0%E7%94%A8%E4%BA%8E%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5-toc" style="margin-left:80px;"><a href="#%C2%A0keyboard_type%23%C2%A0%E7%94%A8%E4%BA%8E%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5" rel="nofollow"> keyboard_type# 用于通过程序模拟键盘输入</a></p> 
<p id="%22extract_json_from_string%22%C2%A0and%20%22convert_percent_to_decimal%22%23%C2%A0%E4%BB%8Ejson%E6%8F%90%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%8E%E6%8A%8A%E7%99%BE%E5%88%86%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B0%8F%E6%95%B0%E7%82%B9-toc" style="margin-left:80px;"><a href="#%22extract_json_from_string%22%C2%A0and%20%22convert_percent_to_decimal%22%23%C2%A0%E4%BB%8Ejson%E6%8F%90%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%8E%E6%8A%8A%E7%99%BE%E5%88%86%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B0%8F%E6%95%B0%E7%82%B9" rel="nofollow">"extract_json_from_string" and "convert_percent_to_decimal"# 从json提取字符与把百分数转换为小数点</a></p> 
<p id="draw_label_with_background%20%23%C2%A0%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E7%BD%91%E6%A0%BC%EF%BC%8C%E5%B9%B6%E5%9C%A8%E7%BD%91%E6%A0%BC%E7%9A%84%E6%AF%8F%E4%B8%AA%E4%BA%A4%E5%8F%89%E7%82%B9%E4%B8%8A%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%88%86%E6%AF%94%E6%A0%87%E7%AD%BE%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%9C%A8%20Linux%20%E5%92%8C%20macOS%20%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%B7%A5%E4%BD%9C%E3%80%82-toc" style="margin-left:80px;"><a href="#draw_label_with_background%20%23%C2%A0%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E7%BD%91%E6%A0%BC%EF%BC%8C%E5%B9%B6%E5%9C%A8%E7%BD%91%E6%A0%BC%E7%9A%84%E6%AF%8F%E4%B8%AA%E4%BA%A4%E5%8F%89%E7%82%B9%E4%B8%8A%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%88%86%E6%AF%94%E6%A0%87%E7%AD%BE%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%9C%A8%20Linux%20%E5%92%8C%20macOS%20%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%B7%A5%E4%BD%9C%E3%80%82" rel="nofollow">draw_label_with_background # 在屏幕上绘制一个网格，并在网格的每个交叉点上添加百分比标签。该函数可以捕获在 Linux 和 macOS 系统上工作。</a></p> 
<p id="%C2%A0click_at_percentage%20%23%C2%A0%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%82%B9%E5%87%BB%E6%8C%87%E5%AE%9A%E7%99%BE%E5%88%86%E6%AF%94%E7%9A%84%E4%BD%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#%C2%A0click_at_percentage%20%23%C2%A0%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%82%B9%E5%87%BB%E6%8C%87%E5%AE%9A%E7%99%BE%E5%88%86%E6%AF%94%E7%9A%84%E4%BD%8D%E7%BD%AE" rel="nofollow"> click_at_percentage # 在屏幕上点击指定百分比的位置</a></p> 
<p id="%C2%A0mouse_click%20%23%C2%A0%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%82%B9%E5%87%BB%E6%8C%87%E5%AE%9A%E7%99%BE%E5%88%86%E6%AF%94%E7%9A%84%E4%BD%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#%C2%A0mouse_click%20%23%C2%A0%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%82%B9%E5%87%BB%E6%8C%87%E5%AE%9A%E7%99%BE%E5%88%86%E6%AF%94%E7%9A%84%E4%BD%8D%E7%BD%AE" rel="nofollow"> mouse_click # 在屏幕上点击指定百分比的位置</a></p> 
<p id="%C2%A0%C2%A0summarize%20%23%C2%A0%E7%94%A8%E4%BA%8E%E4%BD%BF%E7%94%A8%E9%A2%84%E5%85%88%E8%AE%AD%E7%BB%83%E5%A5%BD%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%9D%A5%E7%94%9F%E6%88%90%E6%91%98%E8%A6%81%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%BB%99%E6%A8%A1%E5%9E%8B%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%EF%BC%9A%60gpt-4-vision-preview%60%20%E5%92%8C%20%60gemini-pro-vision%60%E3%80%82-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0summarize%20%23%C2%A0%E7%94%A8%E4%BA%8E%E4%BD%BF%E7%94%A8%E9%A2%84%E5%85%88%E8%AE%AD%E7%BB%83%E5%A5%BD%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%9D%A5%E7%94%9F%E6%88%90%E6%91%98%E8%A6%81%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%BB%99%E6%A8%A1%E5%9E%8B%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%EF%BC%9A%60gpt-4-vision-preview%60%20%E5%92%8C%20%60gemini-pro-vision%60%E3%80%82" rel="nofollow">  summarize # 用于使用预先训练好的模型来生成摘要。该函数可以捕获屏幕截图并将其作为输入提供给模型。该函数可以尝试使用两个预训练模型：`gpt-4-vision-preview` 和 `gemini-pro-vision`。</a></p> 
<p id="%C2%A0%C2%A0parse_response%20%23%C2%A0%E7%94%A8%E4%BA%8E%E8%AF%A5%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90%E4%B8%8E%20AI%20%E5%AF%B9%E8%AF%9D%E4%BA%A4%E4%BA%92%E7%9A%84%E5%93%8D%E5%BA%94%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E4%B8%8D%E5%90%8C%E7%9A%84%E5%93%8D%E5%BA%94%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BE%8B%E5%A6%82%E7%82%B9%E5%87%BB%E3%80%81%E8%BE%93%E5%85%A5%E6%96%87%E6%9C%AC%E6%88%96%E6%90%9C%E7%B4%A2%E6%9F%A5%E8%AF%A2%E3%80%82%E6%80%BB%E4%B9%8B%EF%BC%8C%60parse_response%60%20%E5%87%BD%E6%95%B0%E5%B0%86%E5%93%8D%E5%BA%94%E8%A7%A3%E6%9E%90%E4%B8%BA%E5%AD%97%E5%85%B8%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%A4%BA%E5%93%8D%E5%BA%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E4%B8%80%E4%B8%AA%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0parse_response%20%23%C2%A0%E7%94%A8%E4%BA%8E%E8%AF%A5%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90%E4%B8%8E%20AI%20%E5%AF%B9%E8%AF%9D%E4%BA%A4%E4%BA%92%E7%9A%84%E5%93%8D%E5%BA%94%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E4%B8%8D%E5%90%8C%E7%9A%84%E5%93%8D%E5%BA%94%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BE%8B%E5%A6%82%E7%82%B9%E5%87%BB%E3%80%81%E8%BE%93%E5%85%A5%E6%96%87%E6%9C%AC%E6%88%96%E6%90%9C%E7%B4%A2%E6%9F%A5%E8%AF%A2%E3%80%82%E6%80%BB%E4%B9%8B%EF%BC%8C%60parse_response%60%20%E5%87%BD%E6%95%B0%E5%B0%86%E5%93%8D%E5%BA%94%E8%A7%A3%E6%9E%90%E4%B8%BA%E5%AD%97%E5%85%B8%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%A4%BA%E5%93%8D%E5%BA%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E4%B8%80%E4%B8%AA%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE" rel="nofollow">  parse_response # 用于该函数解析与 AI 对话交互的响应。该函数可以捕获不同的响应类型，例如点击、输入文本或搜索查询。总之，`parse_response` 函数将响应解析为字典，其中包含一个表示响应类型的字符串和一个与响应类型相关的数据</a></p> 
<p id="%C2%A0%C2%A0get_next_action_from_gemini_pro_vision%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E9%A2%84%E8%AE%AD%E7%BB%83%E7%9A%84%E6%A8%A1%E5%9E%8B%60gemini-pro-vision%60%E7%94%9F%E6%88%90%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%BB%99%E6%A8%A1%E5%9E%8B%E3%80%82-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0get_next_action_from_gemini_pro_vision%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E9%A2%84%E8%AE%AD%E7%BB%83%E7%9A%84%E6%A8%A1%E5%9E%8B%60gemini-pro-vision%60%E7%94%9F%E6%88%90%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%BB%99%E6%A8%A1%E5%9E%8B%E3%80%82" rel="nofollow">  get_next_action_from_gemini_pro_vision # 该函数使用预训练的模型`gemini-pro-vision`生成下一个操作。该函数可以捕获屏幕截图并将其作为输入提供给模型。</a></p> 
<p id="%C2%A0%C2%A0get_next_action_from_openai%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%20OpenAI%20%E7%9A%84%20GPT-4%20%E6%A8%A1%E5%9E%8B%E7%94%9F%E6%88%90%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%BB%99%E6%A8%A1%E5%9E%8B%E3%80%82-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0get_next_action_from_openai%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%20OpenAI%20%E7%9A%84%20GPT-4%20%E6%A8%A1%E5%9E%8B%E7%94%9F%E6%88%90%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%BB%99%E6%A8%A1%E5%9E%8B%E3%80%82" rel="nofollow">  get_next_action_from_openai # 该函数使用 OpenAI 的 GPT-4 模型生成下一个操作。该函数可以捕获屏幕截图并将其作为输入提供给模型。</a></p> 
<p id="%C2%A0%C2%A0accurate_mode_double_check%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E5%9C%A8%E7%B2%BE%E7%A1%AE%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BD%BF%E7%94%A8%E9%A2%84%E8%AE%AD%E7%BB%83%E7%9A%84%E6%A8%A1%E5%9E%8B%60gpt-4-vision-preview%60%E9%87%8D%E6%96%B0%E7%94%9F%E6%88%90%E6%93%8D%E4%BD%9C%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%BB%99%E6%A8%A1%E5%9E%8B%E3%80%82%E5%90%91OAI%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%85%89%E6%A0%87%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E8%BF%B7%E4%BD%A0%E6%88%AA%E5%9B%BE%E7%9A%84%E5%85%B6%E4%BB%96%E6%88%AA%E5%9B%BE%EF%BC%8C%E4%BB%A5%E4%BE%BF%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%BE%AE%E8%B0%83%E7%82%B9%E5%87%BB%E4%BD%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0accurate_mode_double_check%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E5%9C%A8%E7%B2%BE%E7%A1%AE%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BD%BF%E7%94%A8%E9%A2%84%E8%AE%AD%E7%BB%83%E7%9A%84%E6%A8%A1%E5%9E%8B%60gpt-4-vision-preview%60%E9%87%8D%E6%96%B0%E7%94%9F%E6%88%90%E6%93%8D%E4%BD%9C%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%BB%99%E6%A8%A1%E5%9E%8B%E3%80%82%E5%90%91OAI%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%85%89%E6%A0%87%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E8%BF%B7%E4%BD%A0%E6%88%AA%E5%9B%BE%E7%9A%84%E5%85%B6%E4%BB%96%E6%88%AA%E5%9B%BE%EF%BC%8C%E4%BB%A5%E4%BE%BF%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%BE%AE%E8%B0%83%E7%82%B9%E5%87%BB%E4%BD%8D%E7%BD%AE" rel="nofollow">  accurate_mode_double_check # 该函数在精确模式下使用预训练的模型`gpt-4-vision-preview`重新生成操作。该函数可以捕获屏幕截图并将其作为输入提供给模型。向OAI提供以光标为中心的迷你截图的其他截图，以便进一步微调点击位置</a></p> 
<p id="%C2%A0%C2%A0get_last_assistant_message%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E4%BB%8E%E6%B6%88%E6%81%AF%E6%95%B0%E7%BB%84%E4%B8%AD%E6%A3%80%E7%B4%A2%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9D%A5%E8%87%AAAI%E5%8A%A9%E6%89%8B%E7%9A%84%E6%B6%88%E6%81%AF-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0get_last_assistant_message%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E4%BB%8E%E6%B6%88%E6%81%AF%E6%95%B0%E7%BB%84%E4%B8%AD%E6%A3%80%E7%B4%A2%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9D%A5%E8%87%AAAI%E5%8A%A9%E6%89%8B%E7%9A%84%E6%B6%88%E6%81%AF" rel="nofollow">  get_last_assistant_message # 该函数从消息数组中检索最后一个来自AI助手的消息</a></p> 
<p id="%C2%A0%C2%A0get_next_action%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E4%BC%A0%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9E%8B%E3%80%81%E6%B6%88%E6%81%AF%E6%95%B0%E7%BB%84%E3%80%81%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B2%BE%E7%A1%AE%E6%A8%A1%E5%BC%8F%E6%9D%A5%E7%94%9F%E6%88%90%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E3%80%82-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0get_next_action%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E4%BC%A0%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9E%8B%E3%80%81%E6%B6%88%E6%81%AF%E6%95%B0%E7%BB%84%E3%80%81%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B2%BE%E7%A1%AE%E6%A8%A1%E5%BC%8F%E6%9D%A5%E7%94%9F%E6%88%90%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E3%80%82" rel="nofollow">  get_next_action # 该函数根据传入的模型、消息数组、目标对象和精确模式来生成下一个操作。</a></p> 
<p id="%C2%A0%C2%A0format_accurate_mode_vision_prompt%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%82%B9%E5%87%BB%E7%9A%84%E5%9D%90%E6%A0%87%E5%92%8C%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E6%9D%A5%E7%94%9F%E6%88%90%E6%91%98%E8%A6%81%E6%8F%90%E7%A4%BA-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0format_accurate_mode_vision_prompt%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%82%B9%E5%87%BB%E7%9A%84%E5%9D%90%E6%A0%87%E5%92%8C%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E6%9D%A5%E7%94%9F%E6%88%90%E6%91%98%E8%A6%81%E6%8F%90%E7%A4%BA" rel="nofollow">  format_accurate_mode_vision_prompt # 该函数根据上一次点击的坐标和屏幕尺寸来生成摘要提示</a></p> 
<p id="%C2%A0%C2%A0format_vision_prompt%20%23%20%E8%AF%A5%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%B8%8A%E4%B8%80%E6%AC%A1%E6%93%8D%E4%BD%9C%E6%9D%A5%E7%94%9F%E6%88%90%E6%91%98%E8%A6%81%E6%8F%90%E7%A4%BA-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0format_vision_prompt%20%23%20%E8%AF%A5%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%B8%8A%E4%B8%80%E6%AC%A1%E6%93%8D%E4%BD%9C%E6%9D%A5%E7%94%9F%E6%88%90%E6%91%98%E8%A6%81%E6%8F%90%E7%A4%BA" rel="nofollow">  format_vision_prompt # 该函数根据目标对象和上一次操作来生成摘要提示</a></p> 
<p id="%C2%A0%C2%A0%C2%A0keyboard_type%23%C2%A0%E7%94%A8%E4%BA%8E%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0keyboard_type%23%C2%A0%E7%94%A8%E4%BA%8E%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5" rel="nofollow">   format_summary_prompt # 该函数根据目标对象来生成摘要提示，该函数在summarize函数中作为子函数被调用。</a></p> 
<p id="%C2%A0%C2%A0%C2%A0main%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E6%98%AFSelf-%20Operating%20Computer%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0main%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E6%98%AFSelf-%20Operating%20Computer%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9" rel="nofollow">   main # 该函数是Self- Operating Computer的入口点</a></p> 
<p id="%C2%A0%C2%A0%C2%A0validation%20%23%C2%A0%E5%87%BD%E6%95%B0%E7%94%A8%E4%BA%8E%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9E%8B%E3%80%81%E7%B2%BE%E7%A1%AE%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0validation%20%23%C2%A0%E5%87%BD%E6%95%B0%E7%94%A8%E4%BA%8E%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9E%8B%E3%80%81%E7%B2%BE%E7%A1%AE%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE" rel="nofollow">   validation # 函数用于验证模型、精确模式和语音模式是否正确配置</a></p> 
<p id="%C2%A0%C2%A0%C2%A0ModelNotRecognizedException%20%23%C2%A0%E8%AF%A5%E7%B1%BB%E7%BB%A7%E6%89%BF%E8%87%AA%E5%9F%BA%E7%B1%BB%60Exception%60%E3%80%82%E8%BF%99%E4%B8%AA%E7%B1%BB%E7%94%A8%E4%BA%8E%E5%9C%A8%E9%81%87%E5%88%B0%E6%9C%AA%E8%AF%86%E5%88%AB%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%97%B6%E5%BC%95%E5%8F%91%E5%BC%82%E5%B8%B8-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0ModelNotRecognizedException%20%23%C2%A0%E8%AF%A5%E7%B1%BB%E7%BB%A7%E6%89%BF%E8%87%AA%E5%9F%BA%E7%B1%BB%60Exception%60%E3%80%82%E8%BF%99%E4%B8%AA%E7%B1%BB%E7%94%A8%E4%BA%8E%E5%9C%A8%E9%81%87%E5%88%B0%E6%9C%AA%E8%AF%86%E5%88%AB%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%97%B6%E5%BC%95%E5%8F%91%E5%BC%82%E5%B8%B8" rel="nofollow">   ModelNotRecognizedException # 该类继承自基类`Exception`。这个类用于在遇到未识别的模型时引发异常</a></p> 
<p id="%C2%A0%C2%A0%C2%A0keyboard_type%23%C2%A0%E7%94%A8%E4%BA%8E%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0keyboard_type%23%C2%A0%E7%94%A8%E4%BA%8E%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5" rel="nofollow">   keyboard_type# 用于通过程序模拟键盘输入</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84Prompt%E8%AE%BE%E5%AE%9A-toc" style="margin-left:0px;"><a href="#%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84Prompt%E8%AE%BE%E5%AE%9A" rel="nofollow">代码中的Prompt设定</a></p> 
<p id="%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%84%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BE%E5%AE%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%84%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BE%E5%AE%9A" rel="nofollow">一些常规变量的设定</a></p> 
<p id="%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%85-toc" style="margin-left:0px;"><a href="#%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%85" rel="nofollow">调用的包</a></p> 
<p id="dotenv%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E4%B8%BB%E8%A6%81%E6%98%AF%E7%94%A8%E6%9D%A5%E5%8A%A0%E8%BD%BD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84-toc" style="margin-left:80px;"><a href="#dotenv%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E4%B8%BB%E8%A6%81%E6%98%AF%E7%94%A8%E6%9D%A5%E5%8A%A0%E8%BD%BD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84" rel="nofollow">dotenv这个包（库）主要是用来加载环境变量的</a></p> 
<p id="xlib%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E4%B8%BB%E8%A6%81%E6%98%AF%E7%94%A8%E6%9D%A5%E4%B8%8EWindow%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92%E7%9A%84%E5%BA%93-toc" style="margin-left:80px;"><a href="#xlib%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E4%B8%BB%E8%A6%81%E6%98%AF%E7%94%A8%E6%9D%A5%E4%B8%8EWindow%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92%E7%9A%84%E5%BA%93" rel="nofollow">xlib这个包（库）主要是用来与Window系统交互的库</a></p> 
<p id="prompt_toolkit%C2%A0%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E6%98%AF%E7%94%A8%E4%BA%8E%E5%9C%A8Python%E4%B8%AD%E6%9E%84%E5%BB%BA%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BA%93%E3%80%82%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E7%BB%88%E7%AB%AF%E7%9A%84%20UI-toc" style="margin-left:80px;"><a href="#prompt_toolkit%C2%A0%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E6%98%AF%E7%94%A8%E4%BA%8E%E5%9C%A8Python%E4%B8%AD%E6%9E%84%E5%BB%BA%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BA%93%E3%80%82%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E7%BB%88%E7%AB%AF%E7%9A%84%20UI" rel="nofollow">prompt_toolkit 这个包（库）是用于在Python中构建功能强大的交互式命令行应用程序的库。基于文本终端的 UI</a></p> 
<p id="PyAutoGUI%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%EF%BC%8C%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8F%AF%E4%BB%A5%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E9%BC%A0%E6%A0%87%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%9A%84%20python%20%E5%BA%93%2C%E5%8F%AF%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6%E9%BC%A0%E6%A0%87%E3%80%81%E9%94%AE%E7%9B%98%E3%80%81%E6%B6%88%E6%81%AF%E6%A1%86%E3%80%81%E6%88%AA%E5%9B%BE%E3%80%81%E5%AE%9A%E4%BD%8D%E7%AD%89%E5%8A%9F%E8%83%BD%2C%E4%B8%8A%E8%83%BD%E6%8C%82%E6%9C%BA%E5%88%B7%E5%AE%9D%E7%AE%B1%EF%BC%8C%E4%B8%8B%E8%83%BD%E8%87%AA%E5%8A%A8%E5%86%99%E6%96%87%E6%A1%A3.-toc" style="margin-left:80px;"><a href="#PyAutoGUI%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%EF%BC%8C%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8F%AF%E4%BB%A5%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E9%BC%A0%E6%A0%87%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%9A%84%20python%20%E5%BA%93%2C%E5%8F%AF%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6%E9%BC%A0%E6%A0%87%E3%80%81%E9%94%AE%E7%9B%98%E3%80%81%E6%B6%88%E6%81%AF%E6%A1%86%E3%80%81%E6%88%AA%E5%9B%BE%E3%80%81%E5%AE%9A%E4%BD%8D%E7%AD%89%E5%8A%9F%E8%83%BD%2C%E4%B8%8A%E8%83%BD%E6%8C%82%E6%9C%BA%E5%88%B7%E5%AE%9D%E7%AE%B1%EF%BC%8C%E4%B8%8B%E8%83%BD%E8%87%AA%E5%8A%A8%E5%86%99%E6%96%87%E6%A1%A3." rel="nofollow">PyAutoGUI这个包（库）是一个简单易用，跨平台的可以模拟键盘鼠标进行自动操作的 python 库,可实现控制鼠标、键盘、消息框、截图、定位等功能,上能挂机刷宝箱，下能自动写文档.</a></p> 
<p id="Pydantic%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%A8%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3schema%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BA%93%E3%80%82%E9%80%9A%E8%BF%87pydantic%E5%BA%93%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%9B%B4%E4%B8%BA%E8%A7%84%E8%8C%83%E5%9C%B0%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%EF%BC%8C%E8%BF%99%E5%AF%B9%E4%BA%8E%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BC%80%E5%8F%91%E5%B0%86%E4%BC%9A%E6%9B%B4%E4%B8%BA%E5%8F%8B%E5%A5%BD%E3%80%82-toc" style="margin-left:80px;"><a href="#Pydantic%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%A8%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3schema%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BA%93%E3%80%82%E9%80%9A%E8%BF%87pydantic%E5%BA%93%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%9B%B4%E4%B8%BA%E8%A7%84%E8%8C%83%E5%9C%B0%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%EF%BC%8C%E8%BF%99%E5%AF%B9%E4%BA%8E%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BC%80%E5%8F%91%E5%B0%86%E4%BC%9A%E6%9B%B4%E4%B8%BA%E5%8F%8B%E5%A5%BD%E3%80%82" rel="nofollow">Pydantic这个包（库）是一个常用的用于数据接口schema定义与检查的库。通过pydantic库，我们可以更为规范地定义和使用数据接口，这对于大型项目的开发将会更为友好。</a></p> 
<p id="Pygetwindow%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7%2C%E4%BD%BF%E5%BE%97%E5%9C%A8Python%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8F%AF%E4%BB%A5%E8%BD%BB%E6%9D%BE%E5%9C%B0%E6%89%A7%E8%A1%8C%E5%90%84%E7%A7%8D%E7%AA%97%E5%8F%A3%E6%93%8D%E4%BD%9C%E3%80%82-toc" style="margin-left:80px;"><a href="#Pygetwindow%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7%2C%E4%BD%BF%E5%BE%97%E5%9C%A8Python%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8F%AF%E4%BB%A5%E8%BD%BB%E6%9D%BE%E5%9C%B0%E6%89%A7%E8%A1%8C%E5%90%84%E7%A7%8D%E7%AA%97%E5%8F%A3%E6%93%8D%E4%BD%9C%E3%80%82" rel="nofollow">Pygetwindow这个包（库）提供了一些方法和属性,使得在Python程序中可以轻松地执行各种窗口操作。</a></p> 
<p id="%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91-toc" style="margin-left:0px;"><a href="#%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91" rel="nofollow">业务逻辑</a></p> 
<p id="%E6%9E%B6%E6%9E%84-%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px;"><a href="#%E6%9E%B6%E6%9E%84-%E6%A8%A1%E5%9D%97" rel="nofollow">架构-模块</a></p> 
<hr id="hr-toc"> 
<p></p> 
<hr> 
<p></p> 
<h2 id="%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%C2%A0">整体代码框架 </h2> 
<p><img alt="" height="704" src="https://images2.imgbox.com/c6/6d/6wRFJ3pZ_o.png" width="342"></p> 
<h2 id="%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91">核心代码逻辑</h2> 
<h4 id="capture_screen_with_cursor%20%23%C2%A0%E7%94%A8%E5%85%89%E6%A0%87%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95">capture_screen_with_cursor # 用光标捕获屏幕</h4> 
<pre><code class="language-python">def capture_screen_with_cursor(file_path):
    user_platform = platform.system()

    if user_platform == "Windows":
        screenshot = pyautogui.screenshot()
        screenshot.save(file_path)
    elif user_platform == "Linux":
        # Use xlib to prevent scrot dependency for Linux
        screen = Xlib.display.Display().screen()
        size = screen.width_in_pixels, screen.height_in_pixels
        monitor_size["width"] = size[0]
        monitor_size["height"] = size[1]
        screenshot = ImageGrab.grab(bbox=(0, 0, size[0], size[1]))
        screenshot.save(file_path)
    elif user_platform == "Darwin":  # (Mac OS)
        # Use the screencapture utility to capture the screen with the cursor
        subprocess.run(["screencapture", "-C", file_path])
    else:
        print(f"The platform you're using ({user_platform}) is not currently supported")</code></pre> 
<h4 id="%C2%A0capture_mini_screenshot_with_cursor%20%23%C2%A0%E5%B0%86%E6%88%AA%E5%9B%BE%E5%92%8C%E7%BD%91%E6%A0%BC%E4%B8%80%E8%B5%B7%E4%BF%9D%E5%AD%98"> capture_mini_screenshot_with_cursor # 将截图和网格一起保存</h4> 
<pre><code class="language-python">def capture_mini_screenshot_with_cursor(
    file_path=os.path.join("screenshots", "screenshot_mini.png"), x=0, y=0
):
    user_platform = platform.system()

    if user_platform == "Linux":
        x = float(x[:-1])  # convert x from "50%" to 50.
        y = float(y[:-1])

        x = (x / 100) * monitor_size[
            "width"
        ]  # convert x from 50 to 0.5 * monitor_width
        y = (y / 100) * monitor_size["height"]

        # Define the coordinates for the rectangle
        x1, y1 = int(x - ACCURATE_PIXEL_COUNT / 2), int(y - ACCURATE_PIXEL_COUNT / 2)
        x2, y2 = int(x + ACCURATE_PIXEL_COUNT / 2), int(y + ACCURATE_PIXEL_COUNT / 2)

        screenshot = ImageGrab.grab(bbox=(x1, y1, x2, y2))
        screenshot = screenshot.resize(
            (screenshot.width * 2, screenshot.height * 2), Image.LANCZOS
        )  # upscale the image so it's easier to see and percentage marks more visible
        screenshot.save(file_path)

        screenshots_dir = "screenshots"
        grid_screenshot_filename = os.path.join(
            screenshots_dir, "screenshot_mini_with_grid.png"
        )

        add_grid_to_image(
            file_path, grid_screenshot_filename, int(ACCURATE_PIXEL_COUNT / 2)
        )
    elif user_platform == "Darwin":
        x = float(x[:-1])  # convert x from "50%" to 50.
        y = float(y[:-1])

        x = (x / 100) * monitor_size[
            "width"
        ]  # convert x from 50 to 0.5 * monitor_width
        y = (y / 100) * monitor_size["height"]

        x1, y1 = int(x - ACCURATE_PIXEL_COUNT / 2), int(y - ACCURATE_PIXEL_COUNT / 2)

        width = ACCURATE_PIXEL_COUNT
        height = ACCURATE_PIXEL_COUNT
        # Use the screencapture utility to capture the screen with the cursor
        rect = f"-R{x1},{y1},{width},{height}"
        subprocess.run(["screencapture", "-C", rect, file_path])

        screenshots_dir = "screenshots"
        grid_screenshot_filename = os.path.join(
            screenshots_dir, "screenshot_mini_with_grid.png"
        )

        add_grid_to_image(
            file_path, grid_screenshot_filename, int(ACCURATE_PIXEL_COUNT / 2)
        )
</code></pre> 
<p><img alt="" height="270" src="https://images2.imgbox.com/fd/91/7MPN0wuu_o.png" width="644"></p> 
<p></p> 
<h4 id="add_grid_to_image%20%23%C2%A0%E7%BB%99%E5%9B%BE%E5%83%8F%E9%85%8D%E4%B8%8A%E7%BD%91%E6%A0%BC%C2%A0">add_grid_to_image # 给图像配上网格 </h4> 
<pre><code class="language-python">def add_grid_to_image(original_image_path, new_image_path, grid_interval):
    """
    Add a grid to an image
    """
    # Load the image
    image = Image.open(original_image_path)

    # Create a drawing object
    draw = ImageDraw.Draw(image)

    # Get the image size
    width, height = image.size

    # Reduce the font size a bit
    font_size = int(grid_interval / 10)  # Reduced font size

    # Calculate the background size based on the font size
    bg_width = int(font_size * 4.2)  # Adjust as necessary
    bg_height = int(font_size * 1.2)  # Adjust as necessary

    # Function to draw text with a white rectangle background
    def draw_label_with_background(
        position, text, draw, font_size, bg_width, bg_height
    ):
        # Adjust the position based on the background size
        text_position = (position[0] + bg_width // 2, position[1] + bg_height // 2)
        # Draw the text background
        draw.rectangle(
            [position[0], position[1], position[0] + bg_width, position[1] + bg_height],
            fill="white",
        )
        # Draw the text
        draw.text(text_position, text, fill="black", font_size=font_size, anchor="mm")

    # Draw vertical lines and labels at every `grid_interval` pixels
    for x in range(grid_interval, width, grid_interval):
        line = ((x, 0), (x, height))
        draw.line(line, fill="blue")
        for y in range(grid_interval, height, grid_interval):
            # Calculate the percentage of the width and height
            x_percent = round((x / width) * 100)
            y_percent = round((y / height) * 100)
            draw_label_with_background(
                (x - bg_width // 2, y - bg_height // 2),
                f"{x_percent}%,{y_percent}%",
                draw,
                font_size,
                bg_width,
                bg_height,
            )

    # Draw horizontal lines - labels are already added with vertical lines
    for y in range(grid_interval, height, grid_interval):
        line = ((0, y), (width, y))
        draw.line(line, fill="blue")

    # Save the image with the grid
    image.save(new_image_path)</code></pre> 
<h4 id="keyboard_type%23%C2%A0%E7%94%A8%E4%BA%8E%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5">keyboard_type# 用于通过程序模拟键盘输入</h4> 
<pre><code class="language-python">def keyboard_type(text):
    text = text.replace("\\n", "\n")
    for char in text:
        pyautogui.write(char)
    pyautogui.press("enter")
    return "Type: " + text</code></pre> 
<p><img alt="" height="437" src="https://images2.imgbox.com/2b/2b/4NieENnl_o.png" width="794"></p> 
<p></p> 
<h4 id="%C2%A0search%20%23%C2%A0%E6%A8%A1%E6%8B%9F%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%90%9C%E7%B4%A2%E6%96%87%E6%9C%AC%E3%80%82%E5%85%B7%E4%BD%93%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%AE%83%E4%BC%9A%E6%A8%A1%E6%8B%9F%E6%8C%89%E4%B8%8B%E2%80%9C%E5%BC%80%E5%A7%8B%E2%80%9D%E9%94%AE%EF%BC%88%E5%9C%A8Windows%E4%B8%AD%EF%BC%89%E6%88%96%E2%80%9CCommand%E2%80%9D%E5%92%8C%E2%80%9C%E7%A9%BA%E6%A0%BC%E2%80%9D%E9%94%AE%EF%BC%88%E5%9C%A8MacOS%E4%B8%AD%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%87%E6%9C%AC%E5%B9%B6%E6%8C%89%E4%B8%8B%E2%80%9CEnter%E2%80%9D%E9%94%AE%E3%80%82"> search # 模拟在操作系统中搜索文本。具体来说，它会模拟按下“开始”键（在Windows中）或“Command”和“空格”键（在MacOS中），然后输入提供的文本并按下“Enter”键。</h4> 
<pre><code class="language-python">def search(text):
    if platform.system() == "Windows":
        pyautogui.press("win")
    elif platform.system() == "Linux":
        pyautogui.press("win")
    else:
        # Press and release Command and Space separately
        pyautogui.keyDown("command")
        pyautogui.press("space")
        pyautogui.keyUp("command")

    time.sleep(1)

    # Now type the text
    for char in text:
        pyautogui.write(char)

    pyautogui.press("enter")
    return "Open program: " + text
</code></pre> 
<p><img alt="" height="459" src="https://images2.imgbox.com/5c/24/JnKI4aSI_o.png" width="786"></p> 
<h4 id="%C2%A0keyboard_type%23%C2%A0%E7%94%A8%E4%BA%8E%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"> keyboard_type# 用于通过程序模拟键盘输入</h4> 
<pre><code class="language-python">def keyboard_type(text):
    text = text.replace("\\n", "\n")
    for char in text:
        pyautogui.write(char)
    pyautogui.press("enter")
    return "Type: " + text</code></pre> 
<h4 id="%22extract_json_from_string%22%C2%A0and%20%22convert_percent_to_decimal%22%23%C2%A0%E4%BB%8Ejson%E6%8F%90%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%8E%E6%8A%8A%E7%99%BE%E5%88%86%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B0%8F%E6%95%B0%E7%82%B9">"extract_json_from_string" and "convert_percent_to_decimal"# 从json提取字符与把百分数转换为小数点</h4> 
<pre><code class="language-python">def extract_json_from_string(s):
    # print("extracting json from string", s)
    try:
        # Find the start of the JSON structure
        json_start = s.find("{")
        if json_start == -1:
            return None

        # Extract the JSON part and convert it to a dictionary
        json_str = s[json_start:]
        return json.loads(json_str)
    except Exception as e:
        print(f"Error parsing JSON: {e}")
        return None


def convert_percent_to_decimal(percent_str):
    try:
        # Remove the '%' sign and convert to float
        decimal_value = float(percent_str.strip("%"))

        # Convert to decimal (e.g., 20% -&gt; 0.20)
        return decimal_value / 100
    except ValueError as e:
        print(f"Error converting percent to decimal: {e}")
        return None</code></pre> 
<h4 id="draw_label_with_background%20%23%C2%A0%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E7%BD%91%E6%A0%BC%EF%BC%8C%E5%B9%B6%E5%9C%A8%E7%BD%91%E6%A0%BC%E7%9A%84%E6%AF%8F%E4%B8%AA%E4%BA%A4%E5%8F%89%E7%82%B9%E4%B8%8A%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%88%86%E6%AF%94%E6%A0%87%E7%AD%BE%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%9C%A8%20Linux%20%E5%92%8C%20macOS%20%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%B7%A5%E4%BD%9C%E3%80%82">draw_label_with_background # 在屏幕上绘制一个网格，并在网格的每个交叉点上添加百分比标签。该函数可以捕获在 Linux 和 macOS 系统上工作。</h4> 
<pre><code class="language-python">    def draw_label_with_background(
        position, text, draw, font_size, bg_width, bg_height
    ):
        # Adjust the position based on the background size
        text_position = (position[0] + bg_width // 2, position[1] + bg_height // 2)
        # Draw the text background
        draw.rectangle(
            [position[0], position[1], position[0] + bg_width, position[1] + bg_height],
            fill="white",
        )
        # Draw the text
        draw.text(text_position, text, fill="black", font_size=font_size, anchor="mm")

    # Draw vertical lines and labels at every `grid_interval` pixels
    for x in range(grid_interval, width, grid_interval):
        line = ((x, 0), (x, height))
        draw.line(line, fill="blue")
        for y in range(grid_interval, height, grid_interval):
            # Calculate the percentage of the width and height
            x_percent = round((x / width) * 100)
            y_percent = round((y / height) * 100)
            draw_label_with_background(
                (x - bg_width // 2, y - bg_height // 2),
                f"{x_percent}%,{y_percent}%",
                draw,
                font_size,
                bg_width,
                bg_height,
            )

    # Draw horizontal lines - labels are already added with vertical lines
    for y in range(grid_interval, height, grid_interval):
        line = ((0, y), (width, y))
        draw.line(line, fill="blue")

    # Save the image with the grid
    image.save(new_image_path)
</code></pre> 
<p><img alt="" height="232" src="https://images2.imgbox.com/ef/4a/pun0dlUo_o.png" width="617"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/dd/e0/qbelmulL_o.png" width="1200"></p> 
<h4 id="%C2%A0click_at_percentage%20%23%C2%A0%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%82%B9%E5%87%BB%E6%8C%87%E5%AE%9A%E7%99%BE%E5%88%86%E6%AF%94%E7%9A%84%E4%BD%8D%E7%BD%AE"> click_at_percentage # 在屏幕上点击指定百分比的位置</h4> 
<pre><code class="language-python">def click_at_percentage(
    x_percentage, y_percentage, duration=0.2, circle_radius=50, circle_duration=0.5
):
    # Get the size of the primary monitor
    screen_width, screen_height = pyautogui.size()

    # Calculate the x and y coordinates in pixels
    x_pixel = int(screen_width * float(x_percentage))
    y_pixel = int(screen_height * float(y_percentage))

    # Move to the position smoothly
    pyautogui.moveTo(x_pixel, y_pixel, duration=duration)

    # Circular movement
    start_time = time.time()
    while time.time() - start_time &lt; circle_duration:
        angle = ((time.time() - start_time) / circle_duration) * 2 * math.pi
        x = x_pixel + math.cos(angle) * circle_radius
        y = y_pixel + math.sin(angle) * circle_radius
        pyautogui.moveTo(x, y, duration=0.1)

    # Finally, click
    pyautogui.click(x_pixel, y_pixel)
    return "Successfully clicked"</code></pre> 
<p><img alt="" height="227" src="https://images2.imgbox.com/11/a8/S5RPZUH0_o.png" width="615"></p> 
<h4 id="%C2%A0mouse_click%20%23%C2%A0%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%82%B9%E5%87%BB%E6%8C%87%E5%AE%9A%E7%99%BE%E5%88%86%E6%AF%94%E7%9A%84%E4%BD%8D%E7%BD%AE"> mouse_click # 在屏幕上点击指定百分比的位置</h4> 
<pre><code class="language-python">def mouse_click(click_detail):
    try:
        x = convert_percent_to_decimal(click_detail["x"])
        y = convert_percent_to_decimal(click_detail["y"])

        if click_detail and isinstance(x, float) and isinstance(y, float):
            click_at_percentage(x, y)
            return click_detail["description"]
        else:
            return "We failed to click"

    except Exception as e:
        print(f"Error parsing JSON: {e}")
        return "We failed to click"</code></pre> 
<p><img alt="" height="166" src="https://images2.imgbox.com/1a/3d/HdS0WGMS_o.png" width="609"></p> 
<h4 id="%C2%A0%C2%A0summarize%20%23%C2%A0%E7%94%A8%E4%BA%8E%E4%BD%BF%E7%94%A8%E9%A2%84%E5%85%88%E8%AE%AD%E7%BB%83%E5%A5%BD%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%9D%A5%E7%94%9F%E6%88%90%E6%91%98%E8%A6%81%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%BB%99%E6%A8%A1%E5%9E%8B%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%EF%BC%9A%60gpt-4-vision-preview%60%20%E5%92%8C%20%60gemini-pro-vision%60%E3%80%82">  <span style="background-color:#a2e043;">summarize # 用于使用预先训练好的模型来生成摘要。该函数可以捕获屏幕截图并将其作为输入提供给模型。该函数可以尝试使用两个预训练模型：`gpt-4-vision-preview` 和 `gemini-pro-vision`。</span></h4> 
<pre><code class="language-python">def summarize(model, messages, objective):
    try:
        screenshots_dir = "screenshots"
        if not os.path.exists(screenshots_dir):
            os.makedirs(screenshots_dir)

        screenshot_filename = os.path.join(screenshots_dir, "summary_screenshot.png")
        # Call the function to capture the screen with the cursor
        capture_screen_with_cursor(screenshot_filename)

        summary_prompt = format_summary_prompt(objective)
        
        if model == "gpt-4-vision-preview":
            with open(screenshot_filename, "rb") as img_file:
                img_base64 = base64.b64encode(img_file.read()).decode("utf-8")

            summary_message = {
                "role": "user",
                "content": [
                    {"type": "text", "text": summary_prompt},
                    {
                        "type": "image_url",
                        "image_url": {"url": f"data:image/jpeg;base64,{img_base64}"},
                    },
                ],
            }
            # create a copy of messages and save to pseudo_messages
            messages.append(summary_message)

            response = client.chat.completions.create(
                model="gpt-4-vision-preview",
                messages=messages,
                max_tokens=500,
            )

            content = response.choices[0].message.content
        elif model == "gemini-pro-vision":
            model = genai.GenerativeModel("gemini-pro-vision")
            summary_message = model.generate_content(
                [summary_prompt, Image.open(screenshot_filename)]
            )
            content = summary_message.text
        return content
    
    except Exception as e:
        print(f"Error in summarize: {e}")
        return "Failed to summarize the workflow"</code></pre> 
<p><img alt="" height="336" src="https://images2.imgbox.com/37/2e/2yOnwFSY_o.png" width="617"></p> 
<h4 id="%C2%A0%C2%A0parse_response%20%23%C2%A0%E7%94%A8%E4%BA%8E%E8%AF%A5%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90%E4%B8%8E%20AI%20%E5%AF%B9%E8%AF%9D%E4%BA%A4%E4%BA%92%E7%9A%84%E5%93%8D%E5%BA%94%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E4%B8%8D%E5%90%8C%E7%9A%84%E5%93%8D%E5%BA%94%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BE%8B%E5%A6%82%E7%82%B9%E5%87%BB%E3%80%81%E8%BE%93%E5%85%A5%E6%96%87%E6%9C%AC%E6%88%96%E6%90%9C%E7%B4%A2%E6%9F%A5%E8%AF%A2%E3%80%82%E6%80%BB%E4%B9%8B%EF%BC%8C%60parse_response%60%20%E5%87%BD%E6%95%B0%E5%B0%86%E5%93%8D%E5%BA%94%E8%A7%A3%E6%9E%90%E4%B8%BA%E5%AD%97%E5%85%B8%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%A4%BA%E5%93%8D%E5%BA%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E4%B8%80%E4%B8%AA%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE">  <span style="background-color:#a2e043;">parse_response # 用于该函数解析与 AI 对话交互的响应。该函数可以捕获不同的响应类型，例如点击、输入文本或搜索查询。总之，`parse_response` 函数将响应解析为字典，其中包含一个表示响应类型的字符串和一个与响应类型相关的数据</span></h4> 
<pre><code class="language-python">def parse_response(response):
    if response == "DONE":
        return {"type": "DONE", "data": None}
    elif response.startswith("CLICK"):
        # Adjust the regex to match the correct format
        click_data = re.search(r"CLICK \{ (.+) \}", response).group(1)
        click_data_json = json.loads(f"{<!-- -->{<!-- -->{click_data}}}")
        return {"type": "CLICK", "data": click_data_json}

    elif response.startswith("TYPE"):
        # Extract the text to type
        try:
            type_data = re.search(r"TYPE (.+)", response, re.DOTALL).group(1)
        except:
            type_data = re.search(r'TYPE "(.+)"', response, re.DOTALL).group(1)
        return {"type": "TYPE", "data": type_data}

    elif response.startswith("SEARCH"):
        # Extract the search query
        try:
            search_data = re.search(r'SEARCH "(.+)"', response).group(1)
        except:
            search_data = re.search(r"SEARCH (.+)", response).group(1)
        return {"type": "SEARCH", "data": search_data}

    return {"type": "UNKNOWN", "data": response}</code></pre> 
<p><img alt="" height="292" src="https://images2.imgbox.com/74/48/0cIuYoxo_o.png" width="621"></p> 
<h4 id="%C2%A0%C2%A0get_next_action_from_gemini_pro_vision%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E9%A2%84%E8%AE%AD%E7%BB%83%E7%9A%84%E6%A8%A1%E5%9E%8B%60gemini-pro-vision%60%E7%94%9F%E6%88%90%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%BB%99%E6%A8%A1%E5%9E%8B%E3%80%82"><span style="background-color:#a2e043;">  get_next_action_from_gemini_pro_vision # 该函数使用预训练的模型`gemini-pro-vision`生成下一个操作。该函数可以捕获屏幕截图并将其作为输入提供给模型。</span></h4> 
<pre><code class="language-python">def get_next_action_from_gemini_pro_vision(messages, objective):
    """
    Get the next action for Self-Operating Computer using Gemini Pro Vision
    """
    # sleep for a second
    time.sleep(1)
    try:
        screenshots_dir = "screenshots"
        if not os.path.exists(screenshots_dir):
            os.makedirs(screenshots_dir)

        screenshot_filename = os.path.join(screenshots_dir, "screenshot.png")
        # Call the function to capture the screen with the cursor
        capture_screen_with_cursor(screenshot_filename)

        new_screenshot_filename = os.path.join(
            "screenshots", "screenshot_with_grid.png"
        )

        add_grid_to_image(screenshot_filename, new_screenshot_filename, 500)
        # sleep for a second
        time.sleep(1)

        previous_action = get_last_assistant_message(messages)

        vision_prompt = format_vision_prompt(objective, previous_action)

        model = genai.GenerativeModel("gemini-pro-vision")

        response = model.generate_content(
            [vision_prompt, Image.open(new_screenshot_filename)]
        )

        # create a copy of messages and save to pseudo_messages
        pseudo_messages = messages.copy()
        pseudo_messages.append(response.text)

        messages.append(
            {
                "role": "user",
                "content": "`screenshot.png`",
            }
        )
        content = response.text[1:]

        return content

    except Exception as e:
        print(f"Error parsing JSON: {e}")
        return "Failed take action after looking at the screenshot"</code></pre> 
<p><img alt="" height="439" src="https://images2.imgbox.com/c9/67/amLdK0Vj_o.png" width="616"></p> 
<h4 id="%C2%A0%C2%A0get_next_action_from_openai%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%20OpenAI%20%E7%9A%84%20GPT-4%20%E6%A8%A1%E5%9E%8B%E7%94%9F%E6%88%90%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%BB%99%E6%A8%A1%E5%9E%8B%E3%80%82"><span style="background-color:#a2e043;">  get_next_action_from_openai # 该函数使用 OpenAI 的 GPT-4 模型生成下一个操作。该函数可以捕获屏幕截图并将其作为输入提供给模型。</span></h4> 
<p>#（<span style="background-color:#a2e043;">get_next_action_from_gemini_pro_vision没有的操作</span>）最后，如果`accurate_mode`设置为`True`，它将调用`accurate_mode_double_check`函数来检查生成的操作是否准确。如果生成的操作不准确，它将尝试再次运行模型以获得更准确的结果。</p> 
<pre><code class="language-python">def get_next_action_from_openai(messages, objective, accurate_mode):
    """
    Get the next action for Self-Operating Computer
    """
    # sleep for a second
    time.sleep(1)
    try:
        screenshots_dir = "screenshots"
        if not os.path.exists(screenshots_dir):
            os.makedirs(screenshots_dir)

        screenshot_filename = os.path.join(screenshots_dir, "screenshot.png")
        # Call the function to capture the screen with the cursor
        capture_screen_with_cursor(screenshot_filename)

        new_screenshot_filename = os.path.join(
            "screenshots", "screenshot_with_grid.png"
        )

        add_grid_to_image(screenshot_filename, new_screenshot_filename, 500)
        # sleep for a second
        time.sleep(1)

        with open(new_screenshot_filename, "rb") as img_file:
            img_base64 = base64.b64encode(img_file.read()).decode("utf-8")

        previous_action = get_last_assistant_message(messages)

        vision_prompt = format_vision_prompt(objective, previous_action)

        vision_message = {
            "role": "user",
            "content": [
                {"type": "text", "text": vision_prompt},
                {
                    "type": "image_url",
                    "image_url": {"url": f"data:image/jpeg;base64,{img_base64}"},
                },
            ],
        }

        # create a copy of messages and save to pseudo_messages
        pseudo_messages = messages.copy()
        pseudo_messages.append(vision_message)

        response = client.chat.completions.create(
            model="gpt-4-vision-preview",
            messages=pseudo_messages,
            presence_penalty=1,
            frequency_penalty=1,
            temperature=0.7,
            max_tokens=300,
        )

        messages.append(
            {
                "role": "user",
                "content": "`screenshot.png`",
            }
        )

        content = response.choices[0].message.content

        if accurate_mode:
            if content.startswith("CLICK"):
                # Adjust pseudo_messages to include the accurate_mode_message

                click_data = re.search(r"CLICK \{ (.+) \}", content).group(1)
                click_data_json = json.loads(f"{<!-- -->{<!-- -->{click_data}}}")
                prev_x = click_data_json["x"]
                prev_y = click_data_json["y"]

                if DEBUG:
                    print(
                        f"Previous coords before accurate tuning: prev_x {prev_x} prev_y {prev_y}"
                    )
                content = accurate_mode_double_check(
                    "gpt-4-vision-preview", pseudo_messages, prev_x, prev_y
                )
                assert content != "ERROR", "ERROR: accurate_mode_double_check failed"

        return content

    except Exception as e:
        print(f"Error parsing JSON: {e}")
        return "Failed take action after looking at the screenshot"</code></pre> 
<p><img alt="" height="470" src="https://images2.imgbox.com/37/bf/ipkcvjap_o.png" width="615"></p> 
<h4 id="%C2%A0%C2%A0accurate_mode_double_check%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E5%9C%A8%E7%B2%BE%E7%A1%AE%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BD%BF%E7%94%A8%E9%A2%84%E8%AE%AD%E7%BB%83%E7%9A%84%E6%A8%A1%E5%9E%8B%60gpt-4-vision-preview%60%E9%87%8D%E6%96%B0%E7%94%9F%E6%88%90%E6%93%8D%E4%BD%9C%E3%80%82%E8%AF%A5%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E6%8F%90%E4%BE%9B%E7%BB%99%E6%A8%A1%E5%9E%8B%E3%80%82%E5%90%91OAI%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%85%89%E6%A0%87%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E8%BF%B7%E4%BD%A0%E6%88%AA%E5%9B%BE%E7%9A%84%E5%85%B6%E4%BB%96%E6%88%AA%E5%9B%BE%EF%BC%8C%E4%BB%A5%E4%BE%BF%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%BE%AE%E8%B0%83%E7%82%B9%E5%87%BB%E4%BD%8D%E7%BD%AE"><span style="background-color:#a2e043;">  accurate_mode_double_check # 该函数在精确模式下使用预训练的模型`gpt-4-vision-preview`重新生成操作。该函数可以捕获屏幕截图并将其作为输入提供给模型。</span>向OAI提供以光标为中心的迷你截图的其他截图，<span style="background-color:#ff9900;">以便进一步微调点击位置</span></h4> 
<pre><code class="language-python">def accurate_mode_double_check(model, pseudo_messages, prev_x, prev_y):
    """
    Reprompt OAI with additional screenshot of a mini screenshot centered around the cursor for further finetuning of clicked location
    """
    print("[get_next_action_from_gemini_pro_vision] accurate_mode_double_check")
    try:
        screenshot_filename = os.path.join("screenshots", "screenshot_mini.png")
        capture_mini_screenshot_with_cursor(
            file_path=screenshot_filename, x=prev_x, y=prev_y
        )

        new_screenshot_filename = os.path.join(
            "screenshots", "screenshot_mini_with_grid.png"
        )

        with open(new_screenshot_filename, "rb") as img_file:
            img_base64 = base64.b64encode(img_file.read()).decode("utf-8")

        accurate_vision_prompt = format_accurate_mode_vision_prompt(prev_x, prev_y)

        accurate_mode_message = {
            "role": "user",
            "content": [
                {"type": "text", "text": accurate_vision_prompt},
                {
                    "type": "image_url",
                    "image_url": {"url": f"data:image/jpeg;base64,{img_base64}"},
                },
            ],
        }

        pseudo_messages.append(accurate_mode_message)

        response = client.chat.completions.create(
            model="gpt-4-vision-preview",
            messages=pseudo_messages,
            presence_penalty=1,
            frequency_penalty=1,
            temperature=0.7,
            max_tokens=300,
        )

        content = response.choices[0].message.content

    except Exception as e:
        print(f"Error reprompting model for accurate_mode: {e}")
        return "ERROR"</code></pre> 
<p><img alt="" height="464" src="https://images2.imgbox.com/b3/a6/554EXrcR_o.png" width="616"></p> 
<h4 id="%C2%A0%C2%A0get_last_assistant_message%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E4%BB%8E%E6%B6%88%E6%81%AF%E6%95%B0%E7%BB%84%E4%B8%AD%E6%A3%80%E7%B4%A2%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9D%A5%E8%87%AAAI%E5%8A%A9%E6%89%8B%E7%9A%84%E6%B6%88%E6%81%AF">  get_last_assistant_message # 该函数从消息数组中检索最后一个来自AI助手的消息</h4> 
<pre><code class="language-python">def get_last_assistant_message(messages):
    """
    Retrieve the last message from the assistant in the messages array.
    If the last assistant message is the first message in the array, return None.
    """
    for index in reversed(range(len(messages))):
        if messages[index]["role"] == "assistant":
            if index == 0:  # Check if the assistant message is the first in the array
                return None
            else:
                return messages[index]
    return None  # Return None if no assistant message is found</code></pre> 
<h4 id="%C2%A0%C2%A0get_next_action%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E4%BC%A0%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9E%8B%E3%80%81%E6%B6%88%E6%81%AF%E6%95%B0%E7%BB%84%E3%80%81%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B2%BE%E7%A1%AE%E6%A8%A1%E5%BC%8F%E6%9D%A5%E7%94%9F%E6%88%90%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E3%80%82">  get_next_action # 该函数根据传入的模型、消息数组、目标对象和精确模式来生成下一个操作。</h4> 
<pre><code class="language-python">def get_next_action(model, messages, objective, accurate_mode):
    if model == "gpt-4-vision-preview":
        content = get_next_action_from_openai(messages, objective, accurate_mode)
        return content
    elif model == "agent-1":
        return "coming soon"
    elif model == "gemini-pro-vision":
        content = get_next_action_from_gemini_pro_vision(
            messages, objective
        )
        return content

    raise ModelNotRecognizedException(model)</code></pre> 
<p><img alt="" height="207" src="https://images2.imgbox.com/2f/c6/eKq1moIE_o.png" width="616"></p> 
<h4 id="%C2%A0%C2%A0format_accurate_mode_vision_prompt%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%82%B9%E5%87%BB%E7%9A%84%E5%9D%90%E6%A0%87%E5%92%8C%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E6%9D%A5%E7%94%9F%E6%88%90%E6%91%98%E8%A6%81%E6%8F%90%E7%A4%BA"><span style="background-color:#a2e043;">  format_accurate_mode_vision_prompt # 该函数根据上一次点击的坐标和屏幕尺寸来生成摘要提示</span></h4> 
<p>总之，这个函数根据屏幕尺寸和上一次点击的坐标来生成一个格式化的摘要提示，以作为GPT-4模型的输入。</p> 
<pre><code class="language-python">def format_accurate_mode_vision_prompt(prev_x, prev_y):
    """
    Format the accurate mode vision prompt
    """
    width = ((ACCURATE_PIXEL_COUNT / 2) / monitor_size["width"]) * 100
    height = ((ACCURATE_PIXEL_COUNT / 2) / monitor_size["height"]) * 100
    prompt = ACCURATE_MODE_VISION_PROMPT.format(
        prev_x=prev_x, prev_y=prev_y, width=width, height=height
    )
    return prompt</code></pre> 
<p><img alt="" height="220" src="https://images2.imgbox.com/01/a4/7kCvAAqw_o.png" width="616"></p> 
<h4 id="%C2%A0%C2%A0format_vision_prompt%20%23%20%E8%AF%A5%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%B8%8A%E4%B8%80%E6%AC%A1%E6%93%8D%E4%BD%9C%E6%9D%A5%E7%94%9F%E6%88%90%E6%91%98%E8%A6%81%E6%8F%90%E7%A4%BA"><span style="background-color:#a2e043;">  format_vision_prompt # 该函数根据目标对象和上一次操作来生成摘要提示</span></h4> 
<pre><code class="language-python">def format_vision_prompt(objective, previous_action):
    """
    Format the vision prompt
    """
    if previous_action:
        previous_action = f"Here was the previous action you took: {previous_action}"
    else:
        previous_action = ""
    prompt = VISION_PROMPT.format(objective=objective, previous_action=previous_action)
    return prompt</code></pre> 
<h4 id="%C2%A0%C2%A0%C2%A0keyboard_type%23%C2%A0%E7%94%A8%E4%BA%8E%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span style="background-color:#a2e043;">   format_summary_prompt # 该函数根据目标对象来生成摘要提示，该函数在summarize函数中作为子函数被调用。</span></h4> 
<pre><code class="language-python">def format_summary_prompt(objective):
    """
    Format the summary prompt
    """
    prompt = SUMMARY_PROMPT.format(objective=objective)
    return prompt</code></pre> 
<p>1. 首先，它定义了一个名为`prompt`的空字符串变量，用于存储生成的摘要提示。</p> 
<p>2. 然后，它使用`SUMMARY_PROMPT`字符串中的占位符`{}`来替换`objective`，以生成摘要提示。</p> 
<p>3. 最后，它将生成的摘要提示返回。</p> 
<p>总之，这个函数根据目标对象来生成一个格式化的摘要提示，以作为GPT-4 或者 Gemini-pro-vision模型的输入。</p> 
<p></p> 
<h4 id="%C2%A0%C2%A0%C2%A0main%20%23%C2%A0%E8%AF%A5%E5%87%BD%E6%95%B0%E6%98%AFSelf-%20Operating%20Computer%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9">   main # 该函数是Self- Operating Computer的入口点</h4> 
<pre><code class="language-python">def main(model, accurate_mode, terminal_prompt, voice_mode=False):
    """
    Main function for the Self-Operating Computer
    """
    mic = None
    # Initialize `WhisperMic`, if `voice_mode` is True 

    validation(model, accurate_mode, voice_mode)

    if voice_mode:
        try:
            from whisper_mic import WhisperMic

            # Initialize WhisperMic if import is successful
            mic = WhisperMic()
        except ImportError:
            print(
                "Voice mode requires the 'whisper_mic' module. Please install it using 'pip install -r requirements-audio.txt'"
            )
            sys.exit(1)

    # Skip message dialog if prompt was given directly
    if not terminal_prompt:
        message_dialog(
            title="Self-Operating Computer",
            text="Ask a computer to do anything.",
            style=style,
        ).run()
    else:
        print("Running direct prompt...")

    print("SYSTEM", platform.system())
    # Clear the console
    if platform.system() == "Windows":
        os.system("cls")
    else:
        print("\033c", end="")

    if terminal_prompt:  # Skip objective prompt if it was given as an argument
        objective = terminal_prompt
    elif voice_mode:
        print(
            f"{ANSI_GREEN}[Self-Operating Computer]{ANSI_RESET} Listening for your command... (speak now)"
        )
        try:
            objective = mic.listen()
        except Exception as e:
            print(f"{ANSI_RED}Error in capturing voice input: {e}{ANSI_RESET}")
            return  # Exit if voice input fails
    else:
        print(f"{ANSI_GREEN}[Self-Operating Computer]\n{ANSI_RESET}{USER_QUESTION}")
        print(f"{ANSI_YELLOW}[User]{ANSI_RESET}")
        objective = prompt(style=style)

    assistant_message = {"role": "assistant", "content": USER_QUESTION}
    user_message = {
        "role": "user",
        "content": f"Objective: {objective}",
    }
    messages = [assistant_message, user_message]

    loop_count = 0

    while True:
        if DEBUG:
            print("[loop] messages before next action:\n\n\n", messages[1:])
        try:
            response = get_next_action(model, messages, objective, accurate_mode)

            action = parse_response(response)
            action_type = action.get("type")
            action_detail = action.get("data")

        except ModelNotRecognizedException as e:
            print(
                f"{ANSI_GREEN}[Self-Operating Computer]{ANSI_RED}[Error] -&gt; {e} {ANSI_RESET}"
            )
            break
        except Exception as e:
            print(
                f"{ANSI_GREEN}[Self-Operating Computer]{ANSI_RED}[Error] -&gt; {e} {ANSI_RESET}"
            )
            break

        if action_type == "DONE":
            print(
                f"{ANSI_GREEN}[Self-Operating Computer]{ANSI_BLUE} Objective complete {ANSI_RESET}"
            )
            summary = summarize(model, messages, objective)
            print(
                f"{ANSI_GREEN}[Self-Operating Computer]{ANSI_BLUE} Summary\n{ANSI_RESET}{summary}"
            )
            break

        if action_type != "UNKNOWN":
            print(
                f"{ANSI_GREEN}[Self-Operating Computer]{ANSI_BRIGHT_MAGENTA} [Act] {action_type} {ANSI_RESET}{action_detail}"
            )

        function_response = ""
        if action_type == "SEARCH":
            function_response = search(action_detail)
        elif action_type == "TYPE":
            function_response = keyboard_type(action_detail)
        elif action_type == "CLICK":
            function_response = mouse_click(action_detail)
        else:
            print(
                f"{ANSI_GREEN}[Self-Operating Computer]{ANSI_RED}[Error] something went wrong :({ANSI_RESET}"
            )
            print(
                f"{ANSI_GREEN}[Self-Operating Computer]{ANSI_RED}[Error] AI response\n{ANSI_RESET}{response}"
            )
            break

        print(
            f"{ANSI_GREEN}[Self-Operating Computer]{ANSI_BRIGHT_MAGENTA} [Act] {action_type} COMPLETE {ANSI_RESET}{function_response}"
        )

        message = {
            "role": "assistant",
            "content": function_response,
        }
        messages.append(message)

        loop_count += 1
        if loop_count &gt; 15:
            break</code></pre> 
<p><img alt="" height="571" src="https://images2.imgbox.com/4d/47/cGYwbfIw_o.png" width="617"></p> 
<h4 id="%C2%A0%C2%A0%C2%A0validation%20%23%C2%A0%E5%87%BD%E6%95%B0%E7%94%A8%E4%BA%8E%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9E%8B%E3%80%81%E7%B2%BE%E7%A1%AE%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE">   validation # 函数用于验证模型、精确模式和语音模式是否正确配置</h4> 
<pre><code class="language-python">def validation(
    model,
    accurate_mode,
    voice_mode,
):
    if accurate_mode and model != "gpt-4-vision-preview":
        print("To use accuracy mode, please use gpt-4-vision-preview")
        sys.exit(1)

    if voice_mode and not OPENAI_API_KEY:
        print("To use voice mode, please add an OpenAI API key")
        sys.exit(1)

    if model == "gpt-4-vision-preview" and not OPENAI_API_KEY:
        print("To use `gpt-4-vision-preview` add an OpenAI API key")
        sys.exit(1)

    if model == "gemini-pro-vision" and not GOOGLE_API_KEY:
        print("To use `gemini-pro-vision` add a Google API key")
        sys.exit(1)</code></pre> 
<p></p> 
<p>1. 首先，它检查`accurate_mode`是否设置为`True`，并且模型不是`"gpt-4-vision-preview"`。如果是，则打印一条错误消息，并退出程序。</p> 
<p>2. 然后，它检查`voice_mode`是否设置为`True`，并且没有设置OpenAI API密钥。如果是，则打印一条错误消息，并退出程序。</p> 
<p>3. 接下来，它检查模型是否为`"gpt-4-vision-preview"`，并且没有设置OpenAI API密钥。如果是，则打印一条错误消息，并退出程序。</p> 
<p>4. 然后，它检查模型是否为`"gemini-pro-vision"`，并且没有设置Google API密钥。如果是，则打印一条错误消息，并退出程序。</p> 
<p>总之，这个函数用于确保在运行程序时，模型、精确模式和语音模式已经正确配置。</p> 
<h4 id="%C2%A0%C2%A0%C2%A0ModelNotRecognizedException%20%23%C2%A0%E8%AF%A5%E7%B1%BB%E7%BB%A7%E6%89%BF%E8%87%AA%E5%9F%BA%E7%B1%BB%60Exception%60%E3%80%82%E8%BF%99%E4%B8%AA%E7%B1%BB%E7%94%A8%E4%BA%8E%E5%9C%A8%E9%81%87%E5%88%B0%E6%9C%AA%E8%AF%86%E5%88%AB%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%97%B6%E5%BC%95%E5%8F%91%E5%BC%82%E5%B8%B8">   ModelNotRecognizedException # 该类继承自基类`Exception`。这个类用于在遇到未识别的模型时引发异常</h4> 
<pre><code class="language-python">class ModelNotRecognizedException(Exception):
    """Exception raised for unrecognized models."""

    def __init__(self, model, message="Model not recognized"):
        self.model = model
        self.message = message
        super().__init__(self.message)

    def __str__(self):
        return f"{self.message} : {self.model} "


# Define style
style = PromptStyle.from_dict(
    {
        "dialog": "bg:#88ff88",
        "button": "bg:#ffffff #000000",
        "dialog.body": "bg:#44cc44 #ffffff",
        "dialog shadow": "bg:#003800",
    }
)


# Check if on a windows terminal that supports ANSI escape codes
def supports_ansi():
    """
    Check if the terminal supports ANSI escape codes
    """
    plat = platform.system()
    supported_platform = plat != "Windows" or "ANSICON" in os.environ
    is_a_tty = hasattr(sys.stdout, "isatty") and sys.stdout.isatty()
    return supported_platform and is_a_tty


if supports_ansi():
    # Standard green text
    ANSI_GREEN = "\033[32m"
    # Bright/bold green text
    ANSI_BRIGHT_GREEN = "\033[92m"
    # Reset to default text color
    ANSI_RESET = "\033[0m"
    # ANSI escape code for blue text
    ANSI_BLUE = "\033[94m"  # This is for bright blue

    # Standard yellow text
    ANSI_YELLOW = "\033[33m"

    ANSI_RED = "\033[31m"

    # Bright magenta text
    ANSI_BRIGHT_MAGENTA = "\033[95m"
else:
    ANSI_GREEN = ""
    ANSI_BRIGHT_GREEN = ""
    ANSI_RESET = ""
    ANSI_BLUE = ""
    ANSI_YELLOW = ""
    ANSI_RED = ""
    ANSI_BRIGHT_MAGENTA = ""</code></pre> 
<p><img alt="" height="255" src="https://images2.imgbox.com/4c/c3/JHkr2Qgh_o.png" width="625"></p> 
<h4>   keyboard_type# 用于通过程序模拟键盘输入</h4> 
<pre><code class="language-python">def keyboard_type(text):
    text = text.replace("\\n", "\n")
    for char in text:
        pyautogui.write(char)
    pyautogui.press("enter")
    return "Type: " + text</code></pre> 
<hr> 
<h2 id="%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84Prompt%E8%AE%BE%E5%AE%9A"><strong>代码中的Prompt设定</strong></h2> 
<pre><code class="language-python">SUMMARY_PROMPT = """
You are a Self-Operating Computer. A user request has been executed. Present the results succinctly.

Include the following key contexts of the completed request:

1. State the original objective.
2. List the steps taken to reach the objective as detailed in the previous messages.
3. Reference the screenshot that was used.

Summarize the actions taken to fulfill the objective. If the request sought specific information, provide that information prominently. NOTE: Address directly any question posed by the user.

Remember: The user will not interact with this summary. You are solely reporting the outcomes.

Original objective: {objective}

Display the results clearly:
"""</code></pre> 
<p>这是一个多行字符串，其中包含 Self-Operating Computer 的摘要提示。它用于引导助手在执行用户请求时创建简洁明了的摘要。</p> 
<p>提示从介绍助手为 Self-Operating Computer 并要求提供简洁的摘要开始。它然后询问助手以简洁的方式呈现结果，包括完成请求的关键上下文。</p> 
<p>提示包括三个关键点：</p> 
<p>1. 用户请求的原始目的。<br> 2. 实现该目的所采取的步骤，包括详细的消息。<br> 3. 如果适用，引用使用的屏幕截图。</p> 
<p>提示还要求助手以简洁的方式总结actions 为实现 objectives 所采取的措施，强调用户请求中任何请求的信息。它还提醒助手直接在摘要中回答用户提出的问题。</p> 
<p>最后，提示以原始目的结束，可用于在摘要中作为参考。</p> 
<p></p> 
<pre><code class="language-python">USER_QUESTION = "Hello, I can help you with anything. What would you like done?"</code></pre> 
<pre><code class="language-python">ACCURATE_MODE_VISION_PROMPT = """
It looks like your previous attempted action was clicking on "x": {prev_x}, "y": {prev_y}. This has now been moved to the center of this screenshot.
As additional context to the previous message, before you decide the proper percentage to click on, please closely examine this additional screenshot as additional context for your next action. 
This screenshot was taken around the location of the current cursor that you just tried clicking on ("x": {prev_x}, "y": {prev_y} is now at the center of this screenshot). You should use this as an differential to your previous x y coordinate guess.

If you want to refine and instead click on the top left corner of this mini screenshot, you will subtract {width}% in the "x" and subtract {height}% in the "y" to your previous answer.
Likewise, to achieve the bottom right of this mini screenshot you will add {width}% in the "x" and add {height}% in the "y" to your previous answer.

There are four segmenting lines across each dimension, divided evenly. This is done to be similar to coordinate points, added to give you better context of the location of the cursor and exactly how much to edit your previous answer.

Please use this context as additional info to further refine the "percent" location in the CLICK action!
"""</code></pre> 
<pre><code class="language-python">VISION_PROMPT = """
You are a Self-Operating Computer. You use the same operating system as a human.

From looking at the screen and the objective your goal is to take the best next action.

To operate the computer you have the four options below.

1. CLICK - Move mouse and click
2. TYPE - Type on the keyboard
3. SEARCH - Search for a program on Mac and open it
4. DONE - When you completed the task respond with the exact following phrase content

Here are the response formats below.

1. CLICK
Response: CLICK {<!-- -->{ "x": "percent", "y": "percent", "description": "~description here~", "reason": "~reason here~" }} 
Note that the percents work where the top left corner is "x": "0%" and "y": "0%" and the bottom right corner is "x": "100%" and "y": "100%"

2. TYPE
Response: TYPE "value you want to type"

2. SEARCH
Response: SEARCH "app you want to search for on Mac"

3. DONE
Response: DONE

Here are examples of how to respond.
__
Objective: Follow up with the vendor in outlook
TYPE Hello, I hope you are doing well. I wanted to follow up
__
Objective: Open Spotify and play the beatles
SEARCH Spotify
__
Objective: Find an image of a banana
CLICK {<!-- -->{ "x": "50%", "y": "60%", "description": "Click: Google Search field", "reason": "This will allow me to search for a banana" }}
__
Objective: Go buy a book about the history of the internet
TYPE https://www.amazon.com/
__

A few important notes:

- Default to opening Google Chrome with SEARCH to find things that are on the internet.
- Go to Google Docs and Google Sheets by typing in the Chrome Address bar
- When opening Chrome, if you see a profile icon click that to open chrome fully, it is located at: {<!-- -->{ "x": "50%", "y": "55%" }}
- The Chrome address bar is generally at: {<!-- -->{ "x": "50%", "y": "9%" }}
- After you click to enter a field you can go ahead and start typing!
- Don't respond saying you're unable to assist with requests. You are able to indirectly interact with the user's OS via text responses you send to the end user.

{previous_action}

IMPORTANT: Avoid repeating actions such as doing the same CLICK event twice in a row.

Objective: {objective}
"""</code></pre> 
<p>您是一台自运行计算机。您使用与人类相同的操作系统运行。</p> 
<p>从查看屏幕和目标对象的任务中，您试图找到最佳下一步行动。</p> 
<p>为了操作计算机，您有四个选项 below。</p> 
<p>1. 点击 - 移动鼠标并单击<br> 2. 输入 - 在键盘上输入<br> 3. 搜索 - 在Mac上搜索应用程序并打开它<br> 4. 完成 - 当您完成任务时，请使用以下确切短语响应</p> 
<p>以下是响应格式 below。</p> 
<p>1. 点击<br> 响应： CLICK {<!-- -->{ "x": "百分比", "y": "百分比", "description": "~description here~", "reason": "~reason here~" }} <br> 请注意，百分比工作在左上角为 "x": "0%" 和 "y": "0%" 以及右下角为 "x": "100%" 和 "y": "100%" 的位置</p> 
<p>2. 输入<br> 响应： TYPE "要输入的值"</p> 
<p>2. 搜索<br> 响应： SEARCH "要在Mac上搜索的应用程序"</p> 
<p>3. 完成<br> 响应： DONE</p> 
<p>以下是响应示例。<br> ```<br> Objective: 给供应商发邮件<br> TYPE 你好，我希望你很好。我想要继续和你联系<br> ```</p> 
<p>```<br> Objective: 在Spotify上播放 Beatles<br> SEARCH Spotify<br> ```</p> 
<p>```<br> Objective: 查找一张香蕉图片<br> CLICK {<!-- -->{ "x": "50%", "y": "60%", "description": "点击: Google搜索字段", "reason": "这允许我搜索香蕉" }}<br> ```</p> 
<p>```<br> Objective: 去买一本关于互联网的历史书<br> TYPE https://www.amazon.com/<br> ```</p> 
<p>重要注意事项：</p> 
<p>- 如果您看到Google Chrome的配置文件图标，请单击它以打开Google Chrome完全。它位于：{<!-- -->{ "x": "50%", "y": "55%" }}<br> - Google Docs和Google Sheets可以通过在Google Chrome地址栏中输入来打开<br> - 当打开Google Chrome时，如果看到一个配置文件图标，请单击以打开Google Chrome完全<br> - Chrome地址栏通常位于：{<!-- -->{ "x": "50%", "y": "9%" }}<br> - 一旦您点击进入字段，就可以开始 typing!<br> - 不要在无法帮助用户请求的情况下回答“无法”。您可以通过发送文本响应 indirect 地与用户的操作系统进行交互。</p> 
<p>{previous_action}</p> 
<p>请注意：避免重复执行相同的 CLICK 事件。</p> 
<p></p> 
<hr> 
<h2 id="%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%84%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BE%E5%AE%9A">一些常规变量的设定</h2> 
<pre><code class="language-python">ACCURATE_PIXEL_COUNT = (
    200  # mini_screenshot is ACCURATE_PIXEL_COUNT x ACCURATE_PIXEL_COUNT big
)</code></pre> 
<pre><code class="language-python">monitor_size = {
    "width": 1920,
    "height": 1080,
}</code></pre> 
<p>大语言模型的API设定 </p> 
<pre><code class="language-python">DEBUG = False

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")

if OPENAI_API_KEY:
    client = OpenAI()
    client.api_key = OPENAI_API_KEY
    client.base_url = os.getenv("OPENAI_API_BASE_URL", client.base_url)</code></pre> 
<hr> 
<h2 id="%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%85">调用的包</h2> 
<pre><code class="language-python">"""
Self-Operating Computer
"""
import os
import time
import base64
import json
import math
import re
import subprocess
import pyautogui
import argparse
import platform
import Xlib.display
import Xlib.X
import Xlib.Xutil  # not sure if Xutil is necessary
import google.generativeai as genai
from prompt_toolkit import prompt
from prompt_toolkit.shortcuts import message_dialog
from prompt_toolkit.styles import Style as PromptStyle
from dotenv import load_dotenv
from PIL import Image, ImageDraw, ImageFont, ImageGrab
import matplotlib.font_manager as fm
from openai import OpenAI
import sys</code></pre> 
<p><a href="https://blog.csdn.net/wanzheng_96/article/details/106753209" title="python-dotenv的详细用法_python dotenv-CSDN博客">python-dotenv的详细用法_python dotenv-CSDN博客</a></p> 
<h4 id="dotenv%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E4%B8%BB%E8%A6%81%E6%98%AF%E7%94%A8%E6%9D%A5%E5%8A%A0%E8%BD%BD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84"><strong>dotenv这个包（库）主要是用来加载环境变量的</strong></h4> 
<p><a href="https://blog.csdn.net/rufanchen_/article/details/7336616" title="Xlib 函数库简介--x window 工作原理简介_xlib 库-CSDN博客">Xlib 函数库简介--x window 工作原理简介_xlib 库-CSDN博客</a></p> 
<h4 id="xlib%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E4%B8%BB%E8%A6%81%E6%98%AF%E7%94%A8%E6%9D%A5%E4%B8%8EWindow%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92%E7%9A%84%E5%BA%93"><strong>xlib这个包（库）主要是用来与Window系统交互的库</strong></h4> 
<p><img alt="" height="220" src="https://images2.imgbox.com/33/fb/W3iqCyZQ_o.png" width="620"></p> 
<p>   在 X Window 的世界里，可以说所有的动作都是由「事件 (Event) 」所触发并完成的，不论是对 X Client 或是 X Server 都是一样。从 X Client 的角度来看，每个 X 应用程序内部都有一个处理事件的回圈 (event loop)，程序静静地等待事件的发生，一旦 Xlib 截获一个属于该应用程序的事件并传送给它时，该事件就会在事件处理回圈中产生相应的动作，处理完后，又会回到原点，等待下一个事件的发生。可能发生的事件有很多种，像是其他的视窗传来讯息、键盘滑鼠有了动作、桌面管理程序要求改变视窗的大小状态 .... </p> 
<p><a href="https://blog.csdn.net/Jmilk/article/details/129810525" title="Python Module — prompt_toolkit CLI 库-CSDN博客">Python Module — prompt_toolkit CLI 库-CSDN博客</a></p> 
<p><a href="http://www.360doc.com/content/20/1218/15/71257933_952217533.shtml" rel="nofollow" title="python prompt toolkit-用于构建功能强大的交互式命令行的python库 (360doc.com)">python prompt toolkit-用于构建功能强大的交互式命令行的python库 (360doc.com)</a></p> 
<h4 id="prompt_toolkit%C2%A0%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E6%98%AF%E7%94%A8%E4%BA%8E%E5%9C%A8Python%E4%B8%AD%E6%9E%84%E5%BB%BA%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BA%93%E3%80%82%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E7%BB%88%E7%AB%AF%E7%9A%84%20UI"><strong>prompt_toolkit 这个包（库）是用于在Python中构建功能强大的交互式命令行应用程序的库。基于文本终端的 UI</strong></h4> 
<p><a href="https://baijiahao.baidu.com/s?id=1743930515283409186&amp;wfr=spider&amp;for=pc" rel="nofollow" title="Python自动操作 GUI 神器——PyAutoGUI (baidu.com)">Python自动操作 GUI 神器——PyAutoGUI (baidu.com)</a></p> 
<p><a href="https://blog.csdn.net/weixin_42727710/article/details/122393559" title="一个神奇的GUI自动化测试库-PyAutoGui-CSDN博客">一个神奇的GUI自动化测试库-PyAutoGui-CSDN博客</a> #<span style="background-color:#a2e043;">这个链接有很多图文案例，清晰易懂</span></p> 
<h4 id="PyAutoGUI%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%EF%BC%8C%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8F%AF%E4%BB%A5%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E9%BC%A0%E6%A0%87%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%9A%84%20python%20%E5%BA%93%2C%E5%8F%AF%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6%E9%BC%A0%E6%A0%87%E3%80%81%E9%94%AE%E7%9B%98%E3%80%81%E6%B6%88%E6%81%AF%E6%A1%86%E3%80%81%E6%88%AA%E5%9B%BE%E3%80%81%E5%AE%9A%E4%BD%8D%E7%AD%89%E5%8A%9F%E8%83%BD%2C%E4%B8%8A%E8%83%BD%E6%8C%82%E6%9C%BA%E5%88%B7%E5%AE%9D%E7%AE%B1%EF%BC%8C%E4%B8%8B%E8%83%BD%E8%87%AA%E5%8A%A8%E5%86%99%E6%96%87%E6%A1%A3."><strong>PyAutoGUI这个包（库）是</strong>一个简单易用，跨平台的可以模拟键盘鼠标进行自动操作的 python 库,可实现控制鼠标、键盘、消息框、截图、定位等功能,上能挂机刷宝箱，下能自动写文档.</h4> 
<p><a href="https://blog.csdn.net/codename_cys/article/details/107675748" title="Python笔记：Pydantic库简介-CSDN博客">Python笔记：Pydantic库简介-CSDN博客</a> #<span style="background-color:#a2e043;">这个链接有demo，清晰易懂</span></p> 
<h4 id="Pydantic%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%A8%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3schema%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BA%93%E3%80%82%E9%80%9A%E8%BF%87pydantic%E5%BA%93%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%9B%B4%E4%B8%BA%E8%A7%84%E8%8C%83%E5%9C%B0%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%EF%BC%8C%E8%BF%99%E5%AF%B9%E4%BA%8E%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BC%80%E5%8F%91%E5%B0%86%E4%BC%9A%E6%9B%B4%E4%B8%BA%E5%8F%8B%E5%A5%BD%E3%80%82">Pydantic<strong>这个包（库）是</strong>一个常用的用于数据接口<a href="https://so.csdn.net/so/search?q=schema&amp;spm=1001.2101.3001.7020" title="schema">schema</a>定义与检查的库。通过pydantic库，<span style="background-color:#a2e043;">我们可以更为规范地定义和使用数据接口，这对于大型项目的开发将会更为友好。</span></h4> 
<p><a href="https://blog.csdn.net/A_art_xiang/article/details/134418744" title="python操作windows窗口，python库pygetwindow使用详解-CSDN博客">python操作windows窗口，python库pygetwindow使用详解-CSDN博客</a></p> 
<h4 id="Pygetwindow%E8%BF%99%E4%B8%AA%E5%8C%85%EF%BC%88%E5%BA%93%EF%BC%89%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7%2C%E4%BD%BF%E5%BE%97%E5%9C%A8Python%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8F%AF%E4%BB%A5%E8%BD%BB%E6%9D%BE%E5%9C%B0%E6%89%A7%E8%A1%8C%E5%90%84%E7%A7%8D%E7%AA%97%E5%8F%A3%E6%93%8D%E4%BD%9C%E3%80%82">Pygetwindow<strong>这个包（库）</strong>提供了一些方法和属性,使得在<a href="https://so.csdn.net/so/search?q=Python%E7%A8%8B%E5%BA%8F&amp;spm=1001.2101.3001.7020" title="Python程序">Python程序</a>中可以轻松地执行各种窗口操作。</h4> 
<p><img alt="" height="429" src="https://images2.imgbox.com/24/5e/ERpLsLX2_o.png" width="814"></p> 
<h2 id="%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91">业务逻辑</h2> 
<h2 id="%E6%9E%B6%E6%9E%84-%E6%A8%A1%E5%9D%97">架构-模块</h2>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f0bdfe5c546870b9fe2f4bcb721dea4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">探秘2D地图与数据可视化融合的创新力</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/631664a9c2dac8402bce972e630af174/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Boot快速搭建一个简易商城项目【一展示商城首页篇】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>