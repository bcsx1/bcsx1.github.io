<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux Grep 正则表达式示例 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux Grep 正则表达式示例" />
<meta property="og:description" content="转载自：Linux Grep 正则表达式示例
grep 是 Linux 中用于文本处理的最有用和功能最强大的命令之一。在本文中，我们将探讨如何在 grep 的 GNU 版本中使用正则表达式的基础，该版本在大多数 Linux 操作系统中默认可用
grep是 Linux 中用于文本处理的最有用和功能最强大的命令之一。grep在一个或多个输入文件中搜索与正则表达式匹配的行，并将每条匹配的行写入到标准输出。
正则表达式是与一组字符串匹配的模式。模式由运算符，文字字符和元字符组成，它们具有特殊的含义。GNU grep支持三种正则表达式语法 Basic，Extended 和 Perl-compatible。
当没有给出正则表达式类型时，grep以 Basic 的形式调用，grep将搜索模式解释为基本 Basic 正则表达式。要将模式解释为扩展 Extended 的正则表达式，请使用-E/--extended-regexp选项。
在 GNU grep的实现中，基本正则表达式和扩展正则表达式语法之间在功能上没有区别，且两者一样。
唯一的区别是，在基本正则表达式中的元字符?，&#43;，{，|，(和)被解释为文字字符，即不将这些字符作为正则解释。
为了在使用基本正则表达式时保持元字符的特殊含义，必须使用反斜杠\对字符进行转义。稍后我们将解释这些和其他元字符的含义。
通常，您应始终将正则表达式括在单引号中，以避免 shell 解释和执行元字符在 shell 在意义。
字符匹配 grep命令的最基本用法是在文件中搜索字符或字符串。除了在可以搜索文件的内容之外，grep 还可以搜索标准输入的内容。
例如要搜索使用bash作为默认的登录 shell 用户，则可以在/etc/passwd文件中搜索包含bash字符串的所有行。
以下grep命令将搜索文件的内容，然后打印包含使用 bash 作为登录 shell 的用户：
grep bash /etc/passwd 输出应如下所示：
root:x:0:0:root:/root:/bin/bash myfreax:x:1000:1000:myfreax:/home/myfreax:/bin/bash 在此示例中，字符串bash是一个基本的正则表达式，由四个字符组成。这告诉grep搜索紧随其后的b，a，s，h字符串。
默认情况下，grep命令区分大小写。这意味着将大写和小写字符视为不同的字符。要在搜索时忽略大小写，请使用-i/--ignore-case选项。
值得一提的是grep将搜索模式作为字符串而不是单词进行搜索 / 查找。因此，如果您要搜索gnu，grep还将打印在较大的单词中嵌入 gnu 的行。例如cygnus或magnum。
如果搜索一个完全限定的字符串或者包含空格的字符串，则需要将其用单引号或双引号引起来，这：
grep &#34;Gnome Display Manager&#34; /etc/passwd 行头与行尾 ^脱字符号表示与行的开头的字符串匹配。如果正则表达式以^开头，grep将在每行的开头开始匹配^之后的字符串。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/4064f88e8db16958c053737d467abdc6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-06T10:24:43+08:00" />
<meta property="article:modified_time" content="2022-09-06T10:24:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux Grep 正则表达式示例</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>转载自：<a href="https://www.myfreax.com/regular-expressions-in-grep/" rel="nofollow">Linux Grep 正则表达式示例</a></p> 
</blockquote> 
<blockquote> 
 <p>grep 是 Linux 中用于文本处理的最有用和功能最强大的命令之一。在本文中，我们将探讨如何在 grep 的 GNU 版本中使用正则表达式的基础，该版本在大多数 Linux 操作系统中默认可用</p> 
</blockquote> 
<p><code>grep</code>是 Linux 中用于文本处理的最有用和功能最强大的命令之一。<code>grep</code>在一个或多个输入文件中搜索与正则表达式匹配的行，并将每条匹配的行写入到标准输出。</p> 
<p>正则表达式是与一组字符串匹配的模式。模式由运算符，文字字符和元字符组成，它们具有特殊的含义。GNU <code>grep</code>支持三种正则表达式语法 Basic，Extended 和 Perl-compatible。</p> 
<p>当没有给出正则表达式类型时，<code>grep</code>以 Basic 的形式调用，<code>grep</code>将搜索模式解释为基本 Basic 正则表达式。要将模式解释为扩展 Extended 的正则表达式，请使用<code>-E</code>/<code>--extended-regexp</code>选项。</p> 
<p>在 GNU <code>grep</code>的实现中，基本正则表达式和扩展正则表达式语法之间在功能上没有区别，且两者一样。</p> 
<p>唯一的区别是，在基本正则表达式中的元字符<code>?</code>，<code>+</code>，<code>{<!-- --></code>，<code>|</code>，<code>(</code>和<code>)</code>被解释为文字字符，即不将这些字符作为正则解释。</p> 
<p>为了在使用基本正则表达式时保持元字符的特殊含义，必须使用反斜杠<code>\</code>对字符进行转义。稍后我们将解释这些和其他元字符的含义。</p> 
<p>通常，您应始终将正则表达式括在单引号中，以避免 shell 解释和执行元字符在 shell 在意义。</p> 
<h3><a id="_18"></a>字符匹配</h3> 
<p><code>grep</code>命令的最基本用法是在文件中搜索字符或字符串。除了在可以搜索文件的内容之外，grep 还可以搜索标准输入的内容。</p> 
<p>例如要搜索使用<code>bash</code>作为默认的登录 shell 用户，则可以在<code>/etc/passwd</code>文件中搜索包含<code>bash</code>字符串的所有行。</p> 
<p>以下<code>grep</code>命令将搜索文件的内容，然后打印包含使用 bash 作为登录 shell 的用户：</p> 
<pre><code>grep bash /etc/passwd
</code></pre> 
<p>输出应如下所示：</p> 
<pre><code>root:x:0:0:root:/root:/bin/bash
myfreax:x:1000:1000:myfreax:/home/myfreax:/bin/bash
</code></pre> 
<p>在此示例中，字符串<code>bash</code>是一个基本的正则表达式，由四个字符组成。这告诉<code>grep</code>搜索紧随其后的<code>b</code>，<code>a</code>，<code>s</code>，<code>h</code>字符串。</p> 
<p>默认情况下，<code>grep</code>命令区分大小写。这意味着将大写和小写字符视为不同的字符。要在搜索时忽略大小写，请使用<code>-i</code>/<code>--ignore-case</code>选项。</p> 
<p>值得一提的是<code>grep</code>将搜索模式作为字符串而不是单词进行搜索 / 查找。因此，如果您要搜索<code>gnu</code>，<code>grep</code>还将打印在较大的单词中嵌入 gnu 的行。例如<code>cygnus</code>或<code>magnum</code>。</p> 
<p>如果搜索一个完全限定的字符串或者包含空格的字符串，则需要将其用单引号或双引号引起来，这：</p> 
<pre><code>grep "Gnome Display Manager" /etc/passwd
</code></pre> 
<h3><a id="_50"></a>行头与行尾</h3> 
<p><code>^</code>脱字符号表示与行的开头的字符串匹配。如果正则表达式以<code>^</code>开头，<code>grep</code>将在每行的开头开始匹配<code>^</code>之后的字符串。</p> 
<p>以下<code>grep</code>命令将从文件<code>file.txt</code>中搜索以字符串<code>linux</code>开头的行：</p> 
<pre><code>grep '^linux' file.txt
</code></pre> 
<p><code>$</code>美元符号与行的结尾字符串匹配。<code>$</code>之后表示你需要搜索的内容。<code>grep</code>将在每行的行尾匹配<code>$</code>之后的字符串。</p> 
<p>以下<code>grep</code>命令将从文件<code>file.txt</code>中搜索以字符串 linux 结尾的行：</p> 
<pre><code>grep 'linux$' file.txt
</code></pre> 
<p>除了搜索行的开头和结尾，您还可以组合使用由<code>^关键词$</code>构造的正则表达式。将允许搜索指定的内容，不是嵌入大字符串匹配的行。</p> 
<p>另一个有用的例子是组合使用<code>^$</code>模式匹配所有空行，即开头与结束都没有内容。这在查找空行时特别有用。</p> 
<p>以下<code>grep</code>命令将从文件<code>file.txt</code>中搜索仅包含<code>linux</code>的行：</p> 
<pre><code>grep '^linux$' file.txt
</code></pre> 
<h3><a id="_79"></a>匹配单个字符</h3> 
<p><code>.</code>符号是与任何单个字符匹配的元字符。</p> 
<p>例如，要包括 kan，然后有两个字符并以字符串 roo” 结尾的任何内容，则可以使用以下模式：</p> 
<pre><code>grep 'kan..roo' file.txt
</code></pre> 
<h3><a id="_90"></a>中括号表达式</h3> 
<p><code>[]</code>中括号表达式允许将字符括在中括号<code>[]</code>来匹配一组字符。即从中括号<code>[]</code>内的字符串任意使用一个字符来匹配行。</p> 
<p>例如，以下<code>grep</code>命令将从文件<code>file.txt</code>中搜索包含<code>accept</code>或<code>accent</code>的行：</p> 
<pre><code>grep 'acce[np]t' file.txt
</code></pre> 
<p>如果方括号内的第一个字符是符号<code>^</code>，则它将匹配方括号中未括起来的任意字符。</p> 
<p>以下模式将匹配包含除<code>l</code>之外的<code>co.a</code>字符串，<code>.</code>表示任意字符。例如<code>coca</code>，<code>cobalt</code>的任意字符串组合，但不匹配包含<code>cola</code>的行 。</p> 
<p>例如，以下<code>grep</code>命令将从文件<code>file.txt</code>中搜索不<code>cola</code>的行：</p> 
<pre><code>grep 'co[^l]a' file.txt
</code></pre> 
<p>您可以通过指定以连字符分隔的范围的第一个和最后一个字符来构造范围表达式，在中括号表达式内指定一系列字符，而不是一个一个地写完所有字符。</p> 
<p>例如，<code>[a-e]</code>等同于<code>[abcde]</code>，<code>[1-3]</code>等同于<code>[123]</code>。以下表达式匹配以大写字母开头的每一行：</p> 
<pre><code>grep '^[A-Z]' file.txt
</code></pre> 
<p><code>grep</code>还支持中括号包含的预定义字符类别。<code>[:alnum:]</code>表示匹配单个数字与字母字符，与<code>[0-9A-Za-z]</code>一样。<code>[:alpha:]</code>表示匹配单个字母字符，与<code>[A-Za-z]</code>一样。</p> 
<p><code>[:blank:]</code>表示匹配单个空格和制表符。<code>[:digit:]</code>表示匹配单个数字<code>0 1 2 3 4 5 6 7 8 9</code>。</p> 
<p>[:lower:] 表示匹配单个小写字母字符，与<code>[a-z]</code>一样。[:upper:] 表示匹配单个大写字母，与<code>[A-Z]</code>一样。</p> 
<h3><a id="_125"></a>量词</h3> 
<p>量词可让您指定匹配项必须出现的次数，即匹配关键词可以被多次匹配。以下是一些 GNU <code>grep</code>支持的量词。</p> 
<p><code>*</code>表示匹配零次或者多次。<code>?</code>表示将前一项匹配零或一次，<code>+</code>表示匹配前一项一次或多次。{n} 匹配前一项<code>n</code>次，<code>n</code>是数字。</p> 
<p><code>{n,}</code>至少匹配 n 次。 <code>{,m}</code>最多匹配前一项 m 次。 {n,m} 匹配前一项必须出现次数是从 n-m 次，如果是 {2,4}，即 2 至 4 次。</p> 
<p>现在我们已经了解正则表达式的量词，接下来我们将使用量词作为示例。在 grep 使用量词进行搜索，以及如何避免 shell 解释特殊字符<code>*</code>，<code>?</code>等。</p> 
<p><code>*</code>字符与前面的字符匹配零次或多次。以下<code>grep</code>命令示例将匹配<code>sright</code>，<code>right</code> ，<code>ssright</code>等。</p> 
<p>正则表达式<code>s*right</code>的<code>*</code>量词表示匹配 s 字符零次或者多次，即没有上限，可以是很多<code>sssss</code>。<code>'s*right'</code>给正则表达式使用单引号，也是避免 shell 解释特殊字符的方式。</p> 
<pre><code>echo right |  grep 's*right'
echo ssright |  grep 's*right'
</code></pre> 
<p>以下是更高级的模式，它匹配所有以大写字母开头，以句点或逗号结尾的行。 <code>.*</code>正则表达式表示匹配任意数量的任何字符。</p> 
<p>以下<code>grep</code>命令<code>-E</code>选项表示使用扩展正则表达式。<code>^</code>表示行的开始位置，<code>[A-Z]</code>表示 A 到大 Z：</p> 
<pre><code>grep -E '^[A-Z].*[.,]$' file.txt
</code></pre> 
<p><code>?</code>使前一字符成为可选，并且只能匹配一次。以下 grep 命令将同时匹配<code>bright</code>和<code>right</code>。</p> 
<p>你会这里的<code>?</code>字符的前面多了反斜杠。如果你使用的是基本正则表达式则需要反斜杠转义<code>?</code>字符避免 shell 的解释与执行。</p> 
<pre><code>grep 'b\?right' file.txt
</code></pre> 
<p>以下<code>grep -E</code>是使用扩展正则表达式的方式匹配<code>'\b?right'</code>模式，因此不需要转义那些有特殊含义的字符。</p> 
<pre><code>grep -E 'b?right' file.txt
</code></pre> 
<p><code>+</code>字符与上一项匹配一次或多次。 以下将匹配<code>sright</code>和<code>ssright</code>，但不匹配<code>right</code>。</p> 
<p>以下 grep 命令选项<code>-E</code> 表示使用扩展正则表达式，模式<code>'s+'</code> 表示必须存在一个<code>s</code>或者多个<code>s</code>字符，没有上限。</p> 
<pre><code>grep -E 's+right' file.txt
</code></pre> 
<p>大括号字符<code>{}</code>允许您指定确切的数字，匹配次数必须在指定的范围内。以下 grep 命令将匹配 3 到 9 位数字的整数。</p> 
<p>在以下<code>'[[:digit:]]{3,9}'</code>模式中，[:digit:] 表示 0 到 9 的数字，<code>[[:digit:]]</code>则表示 [0-9]，<code>{3,9}</code>表示匹配 3 到 9 次，即可行必须包含有 3 到 9 个连续的数字。</p> 
<pre><code>grep -E '[[:digit:]]{3,9}' file.txt
</code></pre> 
<h3><a id="_183"></a>或运算</h3> 
<p>竖线<code>|</code>或运算符使您可以指定不同的可能匹配项，这些匹配项可以是文字字符串或正则表达式。在所有正则表达式运算符中，此运算符的优先级最低。</p> 
<p>在下面的示例中，我们搜索 <a href="https://www.myfreax.com/nginx-log-files/" rel="nofollow">Nginx 的错误日志文件</a>中出现单词<code>fatal</code>，<code>error</code>和<code>critical</code>行，如果使用扩展的正则表达式，则不需要对<code>|</code>进行转义。</p> 
<pre><code>grep 'fatal\|error\|critical' /var/log/nginx/error.log
grep -E 'fatal|error|critical' /var/log/nginx/error.log
</code></pre> 
<h3><a id="_195"></a>分组</h3> 
<p>分组是正则表达式的一项功能，可让您将模式分组并将其作为引用。可使用括号<code>()</code>创建分组。使用基本正则表达式时，必须用反斜杠<code>\</code>对括号进行转义。</p> 
<p>正则表达式可以有多个组。结果，匹配捕获的组通常保存在数组中，数组的成员与匹配的组顺序相同。这通常只是匹配组本身的顺序。</p> 
<p>匹配的组保存在数组中，如果需要对捕获的组进行引用。可使用<code>$1, ..., $9</code>对捕获的组进行引用。</p> 
<p>以下示例同时匹配<code>fear</code>和<code>less</code>。 量词<code>?</code>使<code>(fear)</code>组成为可选。</p> 
<pre><code>grep -E '(fear)?less' file.txt
</code></pre> 
<h3><a id="_210"></a>反斜杠表达式</h3> 
<p>GNU <code>grep</code>包含几个由反斜杠和常规字符组成的元字符。以下是一些最常见的特殊反斜杠表达式。</p> 
<p><code>\b</code>匹配单词边界。<code>&lt;</code>匹配单词开头的空字符串。<code>&gt;</code>在单词末尾匹配一个空字符串。 <code>\w</code>匹配一个单词。<code>\s</code>匹配空格。</p> 
<p>以下模式将匹配单独的单词<code>abject</code>和<code>object</code>。 如果嵌入较大的单词，则不会匹配这些单词：</p> 
<pre><code>grep '\b[ao]bject\b' file.txt
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e5400ead120da59c554bda95e8e0a22/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mac系统下word和excel设置文件打开密码，输入密码才能打开文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f5325e9f84fe760f3dc5778804e2fc0b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uni-app真机调试报错：TypeError: null is not an object (evaluating ‘data.height‘) __ERROR</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>