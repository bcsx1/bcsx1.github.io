<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android13 Wifi启动流程分析 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android13 Wifi启动流程分析" />
<meta property="og:description" content="Android13 Wifi启动流程分析 文章目录 Android13 Wifi启动流程分析一、正常开关wifi 启动流程1、WifiManager2、WifiServiceImpl3、ActiveModeWarden4、ConcreteClientModeManager5、WifiNative6、WifiVendorHal7、HalDeviceManager8、wifi.cpp 二、重启设备时自动开启wifi流程1、系统服务启动 SystemServer2、WifiService3、WifiServiceImpl4、ActiveModeWarden 三、其他1、Android13 Wifi启动 完整流程：2、日志查看关键字和可以查看到的关键信息正常开启wifi日志：正常关闭wifi日志：缺少wifi硬件模组是开启wifi日志： 3、wifi开关状态值4、之前写的一些wifi相关的知识 本文对Android13 wifi 开启流程进行梳理，有需要的可以看看。
如果遇到wifi 打不开问题，可以依照这个流程进行分析，看看具体是哪个流程出现问题。
如果后续需要分析比Android13 更新的代码可以对比参考，毕竟Android11的代码变动比较大。
本文最后有流程总结，代码分析过程还有最大一个亮点，每个类的流程分析都标志了数字，避免读着读着就迷路了。
最后还有wifi开关相关日志过程分析。
一、正常开关wifi 启动流程 1、WifiManager WifiManager 是给应用暴露的api接口类
packages\modules\Wifi\framework\java\android\net\wifi\WifiManager.java
@SystemService(Context.WIFI_SERVICE) public class WifiManager { public boolean setWifiEnabled(boolean enabled) { try { // (1)调用 Service 的 setWifiEnabled 方法 return mService.setWifiEnabled(mContext.getOpPackageName(), enabled); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } } 2、WifiServiceImpl WifiServiceImpl 是Manager接口具体实现类
packages\modules\Wifi\service\java\com\android\server\wifi\WifiServiceImpl.java
public class WifiServiceImpl extends BaseWifiService { private static final String TAG = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/0c4d907cd58b0eeaa153ce6984f6665d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-21T20:16:09+08:00" />
<meta property="article:modified_time" content="2023-12-21T20:16:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android13 Wifi启动流程分析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Android13_Wifi_0"></a>Android13 Wifi启动流程分析</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Android13_Wifi_0" rel="nofollow">Android13 Wifi启动流程分析</a></li><li><ul><li><a href="#wifi__15" rel="nofollow">一、正常开关wifi 启动流程</a></li><li><ul><li><a href="#1WifiManager_17" rel="nofollow">1、WifiManager</a></li><li><a href="#2WifiServiceImpl_38" rel="nofollow">2、WifiServiceImpl</a></li><li><a href="#3ActiveModeWarden_86" rel="nofollow">3、ActiveModeWarden</a></li><li><a href="#4ConcreteClientModeManager_178" rel="nofollow">4、ConcreteClientModeManager</a></li><li><a href="#5WifiNative_256" rel="nofollow">5、WifiNative</a></li><li><a href="#6WifiVendorHal_348" rel="nofollow">6、WifiVendorHal</a></li><li><a href="#7HalDeviceManager_375" rel="nofollow">7、HalDeviceManager</a></li><li><a href="#8wificpp_469" rel="nofollow">8、wifi.cpp</a></li></ul> 
   </li><li><a href="#wifi_581" rel="nofollow">二、重启设备时自动开启wifi流程</a></li><li><ul><li><a href="#1_SystemServer_587" rel="nofollow">1、系统服务启动 SystemServer</a></li><li><a href="#2WifiService_651" rel="nofollow">2、WifiService</a></li><li><a href="#3WifiServiceImpl_674" rel="nofollow">3、WifiServiceImpl</a></li><li><a href="#4ActiveModeWarden_707" rel="nofollow">4、ActiveModeWarden</a></li></ul> 
   </li><li><a href="#_795" rel="nofollow">三、其他</a></li><li><ul><li><a href="#1Android13_Wifi__797" rel="nofollow">1、Android13 Wifi启动 完整流程：</a></li><li><a href="#2_824" rel="nofollow">2、日志查看</a></li><li><ul><li><a href="#_826" rel="nofollow">关键字和可以查看到的关键信息</a></li><li><a href="#wifi_860" rel="nofollow">正常开启wifi日志：</a></li><li><a href="#wifi_914" rel="nofollow">正常关闭wifi日志：</a></li><li><a href="#wifiwifi_955" rel="nofollow">缺少wifi硬件模组是开启wifi日志：</a></li></ul> 
    </li><li><a href="#3wifi_1020" rel="nofollow">3、wifi开关状态值</a></li><li><a href="#4wifi_1067" rel="nofollow">4、之前写的一些wifi相关的知识</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>本文对Android13 wifi 开启流程进行梳理，有需要的可以看看。</p> 
<p>如果遇到wifi 打不开问题，可以依照这个流程进行分析，看看具体是哪个流程出现问题。</p> 
<p>如果后续需要分析比Android13 更新的代码可以对比参考，毕竟Android11的代码变动比较大。</p> 
<p>本文最后有流程总结，代码分析过程还有最大一个亮点，每个类的流程分析都标志了数字，避免读着读着就迷路了。</p> 
<p>最后还有wifi开关相关日志过程分析。</p> 
<h3><a id="wifi__15"></a>一、正常开关wifi 启动流程</h3> 
<h4><a id="1WifiManager_17"></a>1、WifiManager</h4> 
<p>WifiManager 是给应用暴露的api接口类</p> 
<p>packages\modules\Wifi\framework\java\android\net\wifi\WifiManager.java</p> 
<pre><code>@SystemService(Context.WIFI_SERVICE)
public class WifiManager {

    public boolean setWifiEnabled(boolean enabled) {
        try {
        	// (1)调用 Service 的 setWifiEnabled 方法
            return mService.setWifiEnabled(mContext.getOpPackageName(), enabled);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
</code></pre> 
<h4><a id="2WifiServiceImpl_38"></a>2、WifiServiceImpl</h4> 
<p>WifiServiceImpl 是Manager接口具体实现类</p> 
<p>packages\modules\Wifi\service\java\com\android\server\wifi\WifiServiceImpl.java</p> 
<pre><code>public class WifiServiceImpl extends BaseWifiService {

    private static final String TAG = "WifiService";
    
    // (1) setWifiEnabled 方法
    public synchronized boolean setWifiEnabled(String packageName, boolean enable) {

        // If Airplane mode is enabled, only privileged apps are allowed to toggle Wifi
        if (mSettingsStore.isAirplaneModeOn() &amp;&amp; !isPrivileged) {
            mLog.err("setWifiEnabled in Airplane mode: only Settings can toggle wifi").flush(); //异常日志
            return false;
        }
...
		 // (2)  继续追踪setWifiEnabledInternal 方法
        setWifiEnabledInternal(packageName, enable, callingUid, callingPid, isPrivileged);
        return true;
    }

	// (3)  查看 setWifiEnabledInternal 方法实现
    private void setWifiEnabledInternal(String packageName, boolean enable,
            int callingUid, int callingPid, boolean isPrivileged) {
        // (4) 这里有打印哦，打印哪个应用打开还是关闭wifi 的日志 
        mLog.info("setWifiEnabled package=% uid=% enable=% isPrivileged=%").c(packageName)
                .c(callingUid).c(enable).c(isPrivileged).flush(); //wifi 打开日志
 。。。
        // (5) 继续追踪 ActiveModeWarden.wifiToggled
        mActiveModeWarden.wifiToggled(new WorkSource(callingUid, packageName));
        mLastCallerInfoManager.put(WifiManager.API_WIFI_ENABLED, Process.myTid(),
		callingUid, callingPid, packageName, enable); //一些属性的保存，可以不用管
    }
	
}

</code></pre> 
<p>WifiServiceImpl 的打印TAG 是 WifiService，wifi 开关有比较多相关日志，主要是看出开关日志和哪个应用调用的开关。</p> 
<h4><a id="3ActiveModeWarden_86"></a>3、ActiveModeWarden</h4> 
<p>里面有一些关键日志，调试可以查看该日志。</p> 
<p>packages\modules\Wifi\service\java\com\android\server\wifi\ActiveModeWarden.java</p> 
<pre><code>public class ActiveModeWarden {

	private static final String TAG = "WifiActiveModeWarden";

	//(1) wifi打开消息发送方法
    public void wifiToggled(WorkSource requestorWs) {
        mWifiController.sendMessage(WifiController.CMD_WIFI_TOGGLED, requestorWs);
    }

		//(2) wifi打开消息的接收
		//内部类，wifi执行打开是Disable 的状态
        class DisabledState extends BaseState {
            @Override
            public void enter() {
                log("DisabledState.enter()");
                super.enter();
                if (hasAnyModeManager()) {
                    Log.e(TAG, "Entered DisabledState, but has active mode managers");
                }
            }

            @Override
            public boolean processMessageFiltered(Message msg) {
                switch (msg.what) {
               		 //(3) wifi打开消息处理
                    case CMD_WIFI_TOGGLED:
                    case CMD_SCAN_ALWAYS_MODE_CHANGED:
                        handleStaToggleChangeInDisabledState((WorkSource) msg.obj);
                        break;
						}
                    default:
                        return NOT_HANDLED;
				}
			return HANDLED;
			}

		
		 //(4) 内部类的处理方法 handleStaToggleChangeInDisabledState
        private void handleStaToggleChangeInDisabledState(WorkSource requestorWs) {
            if (shouldEnableSta()) {
                startPrimaryOrScanOnlyClientModeManager(requestorWs);
                transitionTo(mEnabledState);
            }
        }
	}
	
	//(4) 具体的处理方法 startPrimaryOrScanOnlyClientModeManager
    private boolean startPrimaryOrScanOnlyClientModeManager(WorkSource requestorWs) {
        //（5）这里其实是判断了wifi_on那个Settings属性
        ActiveModeManager.ClientRole role = getRoleForPrimaryOrScanOnlyClientModeManager();
        if (role == ROLE_CLIENT_PRIMARY) { //（6）wifi 打开是进这里
            return startPrimaryClientModeManager(requestorWs);
        } else if (role == ROLE_CLIENT_SCAN_ONLY) {
            return startScanOnlyClientModeManager(requestorWs);
        } else {
            return false;
        }
    }

	
	// (7)继续追踪方法
    private boolean startPrimaryClientModeManager(WorkSource requestorWs) {
        Log.d(TAG, "Starting primary ClientModeManager in connect mode");
        //（8）这里创建了 ConcreteClientModeManager 对象，看起来没做啥，其实创建对象会做事情
		ConcreteClientModeManager manager = mWifiInjector.makeClientModeManager(
                new ClientListener(), requestorWs, ROLE_CLIENT_PRIMARY, mVerboseLoggingEnabled);
				mClientModeManagers.add(manager); //连接对象被接入队列管理，可以不用关注，断开会被移除
        mLastPrimaryClientModeManagerRequestorWs = requestorWs;
        return true;
    }

	
}

</code></pre> 
<p>ActiveModeWarden 的日志 TAG 是 WifiActiveModeWarden，该文件的日志有打印目前wifi是从哪个状态进入进行操作的日志。</p> 
<p>往下走的 ConcreteClientModeManager 对象 比较特殊，你只要创建它，它就会默认执行开启wifi，往下看它的代码实现就可以看到，所以这里manager 未调用方法，只是加入到队列管理中，很多人可能会看懵，但是继续往下看它的构造方法就明白了。</p> 
<h4><a id="4ConcreteClientModeManager_178"></a>4、ConcreteClientModeManager</h4> 
<p>ConcreteClientModeManager 相关一个系统层的wifi Manager，系统内部使用；</p> 
<p>Android11 中没有 ConcreteClientModeManager ，只有 ClientModeManager。</p> 
<p>packages\modules\Wifi\service\java\com\android\server\wifi\ConcreteClientModeManager.java</p> 
<pre><code>public class ConcreteClientModeManager implements ClientModeManager {
    private static final String TAG = "WifiClientModeManager";

	//(1) ConcreteClientModeManager 构造方法
    ConcreteClientModeManager(Context context,...) {
        mContext = context;
        mWifiNative = wifiNative;
...
		//(2)构造方法中，发送wifi开启
        mStateMachine.sendMessage(ClientModeStateMachine.CMD_START, mTargetRoleChangeInfo);
    }

		//(3)内部状态类，接收消息
		//内部类，未开启wifi前是IdleState状态
        private class IdleState extends State {
            @Override
            public void enter() {
                Log.d(getTag(), "entering IdleState");
                mClientInterfaceName = null;
                mIfaceIsUp = false;
            }
			
            @Override
            public boolean processMessage(Message message) {
                switch (message.what) {
               		 //(3)接收消息
                    case CMD_START:
                        // Always start in scan mode first.
                        RoleChangeInfo roleChangeInfo = (RoleChangeInfo) message.obj;
						// (4) native 方法调用，拉起节点，一般是wlan0
                        mClientInterfaceName = mWifiNative.setupInterfaceForClientInScanMode(
                                mWifiNativeInterfaceCallback, roleChangeInfo.requestorWs);
                        if (TextUtils.isEmpty(mClientInterfaceName)) {
                            Log.e(getTag(), "Failed to create ClientInterface. Sit in Idle");
                            takeBugReportInterfaceFailureIfNeeded(
                                    "Wi-Fi scan STA interface HAL failure");
                            mModeListener.onStartFailure(ConcreteClientModeManager.this);
                            break;
                        }
                        if (roleChangeInfo.role instanceof ClientConnectivityRole) { //默认是进入这里
                            sendMessage(CMD_SWITCH_TO_CONNECT_MODE, roleChangeInfo);
                            transitionTo(mStartedState);
                        } else {
                            mScanRoleChangeInfoToSetOnTransition = roleChangeInfo;
                            transitionTo(mScanOnlyModeState);
                        }
                        break;
                    default:
                        Log.d(getTag(), "received an invalid message: " + message);
                        return NOT_HANDLED;
                }
                return HANDLED;
            }
		}

		
}
</code></pre> 
<p>ConcreteClientModeManager 的日志 TAG 是 WifiClientModeManager，</p> 
<p>该文件的日志有也是包含了一些状态下的操作信息。</p> 
<p>Android11 中 ClientModeManager 的日志 TAG 是 WifiClientModeManager。</p> 
<h4><a id="5WifiNative_256"></a>5、WifiNative</h4> 
<p>WifiNative 是一个统筹调用底层接口的类，这个类往下的逻辑看起来好像没有太大修改。</p> 
<p>packages\modules\Wifi\service\java\com\android\server\wifi\WifiNative.java</p> 
<pre><code>public class WifiNative {
    private static final String TAG = "WifiNative";

    private final WifiVendorHal mWifiVendorHal;
    private final IfaceManager mIfaceMgr = new IfaceManager(); //内部类，调用的Iface

    public String setupInterfaceForClientInScanMode(
            @NonNull InterfaceCallback interfaceCallback, @NonNull WorkSource requestorWs) {
        synchronized (mLock) {
            if (!startHal()) { //(1) 初始化驱动和vendor hal
                Log.e(TAG, "Failed to start Hal");
                mWifiMetrics.incrementNumSetupClientInterfaceFailureDueToHal();
                return null;
            }
			// (2) 初始化interface
            Iface iface = mIfaceMgr.allocateIface(Iface.IFACE_TYPE_STA_FOR_SCAN);
            if (iface == null) {
                Log.e(TAG, "Failed to allocate new STA iface");
                return null;
            }
            iface.externalListener = interfaceCallback;
            iface.name = createStaIface(iface, requestorWs);
            if (TextUtils.isEmpty(iface.name)) {
                Log.e(TAG, "Failed to create iface in vendor HAL");
                mIfaceMgr.removeIface(iface.id);
                mWifiMetrics.incrementNumSetupClientInterfaceFailureDueToHal();
                return null;
            }
			// (3)初始化wificond
            if (!mWifiCondManager.setupInterfaceForClientMode(iface.name, Runnable::run,
                    new NormalScanEventCallback(iface.name),
                    new PnoScanEventCallback(iface.name))) {
                Log.e(TAG, "Failed to setup iface in wificond=" + iface.name);
                teardownInterface(iface.name);
                mWifiMetrics.incrementNumSetupClientInterfaceFailureDueToWificond();
                return null;
            }
            iface.networkObserver = new NetworkObserverInternal(iface.id);
			//(4)监听interface的down/up
            if (!registerNetworkObserver(iface.networkObserver)) {
                Log.e(TAG, "Failed to register network observer for iface=" + iface.name);
                teardownInterface(iface.name);
                return null;
            }
			//(5)启动supplicant监听(但是此时supplicant进程还未启动)
            mWifiMonitor.startMonitoring(iface.name);
            // Just to avoid any race conditions with interface state change callbacks,
            // update the interface state before we exit.
            onInterfaceStateChanged(iface, isInterfaceUp(iface.name));
            mWifiVendorHal.enableLinkLayerStats(iface.name);
            Log.i(TAG, "Successfully setup " + iface); //成功启动wifi节点

			//(6)获取芯片支持的wifi feature
            iface.featureSet = getSupportedFeatureSetInternal(iface.name);
            return iface.name;
        }
    }

	//(7) 继续分析：初始化驱动
    private boolean startHal() {
        synchronized (mLock) {
            if (!mIfaceMgr.hasAnyIface()) { //(8) 判断节点是否存在
                if (mWifiVendorHal.isVendorHalSupported()) { //(9) 判断底层是否支持
                    if (!mWifiVendorHal.startVendorHal()) { //(10) **重点：判断是否可以正常启动节点
                        Log.e(TAG, "Failed to start vendor HAL");
                        return false;
                    }
                    if (SdkLevel.isAtLeastS()) {
                        mWifiVendorHal.setCoexUnsafeChannels(mCachedCoexUnsafeChannels, mCachedCoexRestrictions);
                    }
                } else {
                    Log.i(TAG, "Vendor Hal not supported, ignoring start.");
                }
            }
            registerWificondListenerIfNecessary();
            return true;
        }
    }
	
}
</code></pre> 
<h4><a id="6WifiVendorHal_348"></a>6、WifiVendorHal</h4> 
<p>packages\modules\Wifi\service\java\com\android\server\wifi\WifiVendorHal.java</p> 
<pre><code>/**
 * Vendor HAL via HIDL
 */
public class WifiVendorHal {

    private final HalDeviceManager mHalDeviceManager;
    
    // （1）追踪 startVendorHal
    public boolean startVendorHal() {
        synchronized (sLock) {
        	//(2) 关键 mHalDeviceManager.start
            if (!mHalDeviceManager.start()) {
                mLog.err("Failed to start vendor HAL").flush();
                return false;
            }
            mLog.info("Vendor Hal started successfully").flush();
            return true;
        }
    }
}
</code></pre> 
<h4><a id="7HalDeviceManager_375"></a>7、HalDeviceManager</h4> 
<pre><code>import android.hardware.wifi.V1_0.IWifi;

/**
 * Handles device management through the HAL (HIDL) interface.
 */
public class HalDeviceManager {
    private static final String TAG = "HalDevMgr";

    private IWifi mWifi;
	
	//(1) 继续追踪 HalDeviceManager.start
	public boolean start() {
        return startWifi();
    }

	//(2) startWifi 实现
    private boolean startWifi() {
        if (VDBG) Log.d(TAG, "startWifi");
        initIWifiIfNecessary();
        synchronized (mLock) {
            try {
                if (mWifi == null) {
                    Log.w(TAG, "startWifi called but mWifi is null!?");
                    return false;
                } else {
                    int triedCount = 0;
                    while (triedCount &lt;= START_HAL_RETRY_TIMES) { //最多启动start三次
                        WifiStatus status = mWifi.start();
                        if (status.code == WifiStatusCode.SUCCESS) {
                            initIWifiChipDebugListeners();
                            managerStatusListenerDispatch();
                            if (triedCount != 0) { //（3）启动慢，一次没有启动成功的情况，这里才会有日志！
                                Log.d(TAG, "start IWifi succeeded after trying " + triedCount + " times");
                            }
                            WifiChipInfo[] wifiChipInfos = getAllChipInfo();
                            if (wifiChipInfos != null) {
                                mCachedStaticChipInfos =
                                        convertWifiChipInfoToStaticChipInfos(getAllChipInfo());
                                saveStaticChipInfoToStore(mCachedStaticChipInfos);
                            } else {
                                Log.e(TAG, "Started wifi but could not get current chip info.");
                            }
                            return true;
                        } else if (status.code == WifiStatusCode.ERROR_NOT_AVAILABLE) {
                            // Should retry. Hal might still be stopping. the registered event
                            // callback will not be cleared.
                            Log.e(TAG, "Cannot start IWifi: " + statusString(status)
                                    + ", Retrying...");
                            try {
                                Thread.sleep(START_HAL_RETRY_INTERVAL_MS);
                            } catch (InterruptedException ignore) {
                                // no-op
                            }
                            triedCount++;
                        } else {
                            // Should not retry on other failures.
                            // Will be handled in the onFailure event.
                            Log.e(TAG, "Cannot start IWifi: " + statusString(status));
                            return false;
                        }
                    }
                    Log.e(TAG, "Cannot start IWifi after trying " + triedCount + " times");
                    return false;
                }
            } catch (RemoteException e) {
                Log.e(TAG, "startWifi exception: " + e);
                return false;
            }
        }
    }
	
}

</code></pre> 
<p>WifiNative往下大致流程：</p> 
<pre><code>WifiNative -&gt; WifiVendorHal -&gt; HalDeviceManager

WifiNative.startHal() -&gt; 
WifiVendorHal.startVendorHal() -&gt;
HalDeviceManager.start() -&gt; 
HalDeviceManager.startWifi()
</code></pre> 
<p>HalDeviceManager 往下的 Hal 层代码是直接调用硬件接口的了。<br> 并且 IWifi 这些 接口类是系统编译生成的，没有具体的IWifi.java 文件,只有相关的class文件。</p> 
<h4><a id="8wificpp_469"></a>8、wifi.cpp</h4> 
<p>Hal 层代码</p> 
<p>hardware\interfaces\wifi\1.6\default\wifi.cpp</p> 
<pre><code>Return&lt;void&gt; Wifi::start(start_cb hidl_status_cb) {
    return validateAndCall(this, WifiStatusCode::ERROR_UNKNOWN, &amp;Wifi::startInternal,
                           hidl_status_cb);
}


WifiStatus Wifi::startInternal() {
    if (run_state_ == RunState::STARTED) {
        return createWifiStatus(WifiStatusCode::SUCCESS);
    } else if (run_state_ == RunState::STOPPING) {
        return createWifiStatus(WifiStatusCode::ERROR_NOT_AVAILABLE, "HAL is stopping");
    }
    WifiStatus wifi_status = initializeModeControllerAndLegacyHal();
    if (wifi_status.code == WifiStatusCode::SUCCESS) {
        // Register the callback for subsystem restart
        const auto&amp; on_subsystem_restart_callback = [this](const std::string&amp; error) {
            WifiStatus wifi_status = createWifiStatus(WifiStatusCode::ERROR_UNKNOWN, error);
            for (const auto&amp; callback : event_cb_handler_.getCallbacks()) {
                LOG(INFO) &lt;&lt; "Attempting to invoke onSubsystemRestart "
                             "callback";
                if (!callback-&gt;onSubsystemRestart(wifi_status).isOk()) {
                    LOG(ERROR) &lt;&lt; "Failed to invoke onSubsystemRestart callback";
                } else {
                    LOG(INFO) &lt;&lt; "Succeeded to invoke onSubsystemRestart "
                                 "callback";
                }
            }
        };

        // Create the chip instance once the HAL is started.
        android::hardware::wifi::V1_0::ChipId chipId = kPrimaryChipId;
        for (auto&amp; hal : legacy_hals_) {
            chips_.push_back(
                    new WifiChip(chipId, chipId == kPrimaryChipId, hal, mode_controller_,
                                 std::make_shared&lt;iface_util::WifiIfaceUtil&gt;(iface_tool_, hal),
                                 feature_flags_, on_subsystem_restart_callback));
            chipId++;
        }
        run_state_ = RunState::STARTED;
        for (const auto&amp; callback : event_cb_handler_.getCallbacks()) {
            if (!callback-&gt;onStart().isOk()) {
                LOG(ERROR) &lt;&lt; "Failed to invoke onStart callback";
            };
        }
        LOG(INFO) &lt;&lt; "Wifi HAL started";
    } else {
        for (const auto&amp; callback : event_cb_handler_.getCallbacks()) {
            if (!callback-&gt;onFailure(wifi_status).isOk()) {
                LOG(ERROR) &lt;&lt; "Failed to invoke onFailure callback";
            }
        }
        LOG(ERROR) &lt;&lt; "Wifi HAL start failed";
        // Clear the event callback objects since the HAL start failed.
        event_cb_handler_.invalidate();
    }
    return wifi_status;
}

WifiStatus Wifi::initializeModeControllerAndLegacyHal() {
    // ... ...
    mode_controller_-&gt;initialize();				// 加载驱动 driver_tool_-&gt;LoadDriver()
    
    legacy_hals_ = legacy_hal_factory_-&gt;getHals();
    for (auto&amp; hal : legacy_hals_) {
        legacy_hal::wifi_error legacy_status = hal-&gt;initialize();
        // ... ...
    }
    // ... ...
}

std::vector&lt;std::shared_ptr&lt;WifiLegacyHal&gt;&gt; WifiLegacyHalFactory::getHals() {
    if (legacy_hals_.empty()) {
        // 先从已链接的so库中初始化vendor hal的接口(函数指针赋值)
        // 如果失败，证明是多wifi芯片的设备，需要从descriptor.xml初始化
        if (!initVendorHalDescriptorFromLinked()) initVendorHalsDescriptorList();
        for (auto&amp; desc : descs_) {
            std::shared_ptr&lt;WifiLegacyHal&gt; hal =
                    std::make_shared&lt;WifiLegacyHal&gt;(iface_tool_, desc.fn, desc.primary);
            legacy_hals_.push_back(hal);
        }
    }

    return legacy_hals_;
}


</code></pre> 
<p>wifi.cpp 主要工作：</p> 
<pre><code>通过wifi_mode_controller加载驱动
初始化所有的HAL接口(legacy_hal_factory_-&gt;getHals())
initVendorHalDescriptorFromLinked
initVendorHalsDescriptorList
</code></pre> 
<p>wifi.cpp 已经是底层硬件实现了，这块代码其实我也不怎么了解，再往下不做具体分析了。</p> 
<p>这篇文章对底层逻辑讲得详细一下：<br> https://blog.csdn.net/weixin_40588186/article/details/132837372</p> 
<h3><a id="wifi_581"></a>二、重启设备时自动开启wifi流程</h3> 
<p>系统启动时，其实就多了startServer的过程，并且在startOtherService中打开wifi。</p> 
<p>init.rc那些就不说了，直接从Java部分说起。</p> 
<h4><a id="1_SystemServer_587"></a>1、系统服务启动 SystemServer</h4> 
<p>SystemServer 是包含Java入口的类，并且启动了很多Android 关键服务。</p> 
<p>frameworks\base\services\java\com\android\server\SystemServer.java</p> 
<pre><code>/**
 * Entry point to {@code system_server}.
 */
public final class SystemServer implements Dumpable {

private static final String WIFI_SERVICE_CLASS =        "com.android.server.wifi.WifiService";

    /**
     * The main entry point from zygote.
     */
     //(1)Java 端启动入口
    public static void main(String[] args) {
        new SystemServer().run();
    }

	//（2）启动系统服务
    private void run() {
        // Start services.
        try {
            t.traceBegin("StartServices");
            startBootstrapServices(t);//设备启动服务，电源管理和设备管理服务
            startCoreServices(t); //核心服务
            startOtherServices(t);//(3)其他服务，AMS、WIFI、蓝牙那些
            startApexServices(t);//启动app相关服务，这个是Android13 才有的。
        } catch (Throwable ex) {
            Slog.e("System", "******************************************");
            Slog.e("System", "************ Failure starting system services", ex);
            throw ex;
        } finally {
            t.traceEnd(); // StartServices
        }

    }

	//（4）other服务启动
    private void startOtherServices(@NonNull TimingsTraceAndSlog t) {
            //（5）wifi服务启动
            if (context.getPackageManager().hasSystemFeature(
                    PackageManager.FEATURE_WIFI)) {
                // Wifi Service must be started first for wifi-related services.
                t.traceBegin("StartWifi");  //（6）刚开机可以看到这些日志
                mSystemServiceManager.startServiceFromJar(
                        WIFI_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH);
                t.traceEnd();
                t.traceBegin("StartWifiScanning");
                mSystemServiceManager.startServiceFromJar(
                        WIFI_SCANNING_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH);
                t.traceEnd();
            }
            。。。
    }

}
</code></pre> 
<h4><a id="2WifiService_651"></a>2、WifiService</h4> 
<p>wifi服务类，并不是对外暴露的，对接的是SystemServer</p> 
<p>packages\modules\Wifi\service\java\com\android\server\wifi\WifiService.java</p> 
<pre><code>public final class WifiService extends SystemService {
    
    private final WifiServiceImpl mImpl;
	@Override
    public void onBootPhase(int phase) {
        if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
            mImpl.checkAndStartWifi(); // （1）检查是否需要启动wifi
        } else if (phase == SystemService.PHASE_BOOT_COMPLETED) {
            mImpl.handleBootCompleted();
        }
    }
}
</code></pre> 
<h4><a id="3WifiServiceImpl_674"></a>3、WifiServiceImpl</h4> 
<p>wifi 启动的具体实现类，对接的是WifiManager 接口方法。</p> 
<p>packages\modules\Wifi\service\java\com\android\server\wifi\WifiServiceImpl.java</p> 
<pre><code>public class WifiServiceImpl extends BaseWifiService {
    private static final String TAG = "WifiService";
	
	// （1）检查是否需要启动wifi
	public void checkAndStartWifi() {
        mWifiThreadRunner.post(() -&gt; {
    
    		//这里有打印wifi是否需要启动，具体实现是判断Settings.Global.WIFI_ON
    		//但是这个方法内并未使用这个属性
            // Check if wi-fi needs to be enabled
            boolean wifiEnabled = mSettingsStore.isWifiToggleEnabled();
            Log.i(TAG,"WifiService starting up with Wi-Fi " + (wifiEnabled ? "enabled" : "disabled"));

...
            mActiveModeWarden.start(); //（2）在这里判断是否开启
            registerForCarrierConfigChange();
            mWifiInjector.getAdaptiveConnectivityEnabledSettingObserver().initialize();
            mIsWifiServiceStarted = true;
        });

    }
}
</code></pre> 
<h4><a id="4ActiveModeWarden_707"></a>4、ActiveModeWarden</h4> 
<p>wifi 状态处理，比较中间的</p> 
<p>packages\modules\Wifi\service\java\com\android\server\wifi\ActiveModeWarden.java</p> 
<pre><code>public class ActiveModeWarden {
	private static final String TAG = "WifiActiveModeWarden";

    private final WifiController mWifiController;
    
    /** Begin listening to broadcasts and start the internal state machine. */
    //（1）ActiveModeWarden.start
    public void start() {
    ...
    	//（2） 调用Controller 状态机 start
		mWifiController.start();
    }

    private class WifiController extends StateMachine {
        private static final String TAG = "WifiController";

		@Override
        public void start() {
            boolean isAirplaneModeOn = mSettingsStore.isAirplaneModeOn();
            boolean isWifiEnabled = mSettingsStore.isWifiToggleEnabled();
            boolean isScanningAlwaysAvailable = mSettingsStore.isScanAlwaysAvailable();
            boolean isLocationModeActive = mWifiPermissionsUtil.isLocationModeEnabled();
			
			//（3） 这里也有打开wifi 是否需要开启wifi的日志
            log("isAirplaneModeOn = " + isAirplaneModeOn
                    + ", isWifiEnabled = " + isWifiEnabled
                    + ", isScanningAvailable = " + isScanningAlwaysAvailable
                    + ", isLocationModeActive = " + isLocationModeActive);
                    
            ActiveModeManager.ClientRole role = getRoleForPrimaryOrScanOnlyClientModeManager();
            if (role == ROLE_CLIENT_PRIMARY) { //**（4）这个比较隐蔽，wifi开启是开启就是进入这里
                 startPrimaryClientModeManager(mLastPrimaryClientModeManagerRequestorWs);
                setInitialState(mEnabledState);
            } else if (role == ROLE_CLIENT_SCAN_ONLY) {
                startScanOnlyClientModeManager(mLastScanOnlyClientModeManagerRequestorWs);
                setInitialState(mEnabledState);
            } else { //如果是不需要开启wifi，就是默认进入Disabled状态
                setInitialState(mDisabledState);
            }
            mWifiMetrics.noteWifiEnabledDuringBoot(mSettingsStore.isWifiToggleEnabled());

            // Initialize the lower layers before we start.
            mWifiNative.initialize();
            super.start();
        }
    }
    	//(5) 具体的处理方法 startPrimaryOrScanOnlyClientModeManager
    private boolean startPrimaryOrScanOnlyClientModeManager(WorkSource requestorWs) {
        //（6）这里其实是判断了wifi_on那个Settings属性
        ActiveModeManager.ClientRole role = getRoleForPrimaryOrScanOnlyClientModeManager();
        if (role == ROLE_CLIENT_PRIMARY) { //（7）wifi 打开是进这里
            return startPrimaryClientModeManager(requestorWs);
        } else if (role == ROLE_CLIENT_SCAN_ONLY) {
            return startScanOnlyClientModeManager(requestorWs);
        } else {
            return false;
        }
    }

	
	// (8)继续追踪方法
    private boolean startPrimaryClientModeManager(WorkSource requestorWs) {
        Log.d(TAG, "Starting primary ClientModeManager in connect mode");
        //（9）这里创建了 ConcreteClientModeManager 对象，看起来没做啥，其实创建对象会做事情
		ConcreteClientModeManager manager = mWifiInjector.makeClientModeManager(
                new ClientListener(), requestorWs, ROLE_CLIENT_PRIMARY, mVerboseLoggingEnabled);
				mClientModeManagers.add(manager); //连接对象被接入队列管理，可以不用关注，断开会被移除
        mLastPrimaryClientModeManagerRequestorWs = requestorWs;
        return true;
    }

}
</code></pre> 
<p>上面第4点看到，wifi开启是调用到 startPrimaryClientModeManager 方法和上面正常开启wifi调用到的第3步的ActiveModeWarden.wifiToggled里面后面调用到的方法是一个方法。</p> 
<p>所以往后的流程接着往ConcreteClientModeManager看就可以看到了。</p> 
<h3><a id="_795"></a>三、其他</h3> 
<h4><a id="1Android13_Wifi__797"></a>1、Android13 Wifi启动 完整流程：</h4> 
<pre><code>(1) WifiManager.java
(2) WifiServiceImpl.java
(3) ActivityModenWarden.java
(4) ConcreteClientModeManager.java
(5) WifiNative.java
(6) WIfiVendorHar.java
(7) HalDeviceManager.java
(8) wifi.cpp //HAl层
(9) HAl 往下
</code></pre> 
<p>Android11 完整流程图：</p> 
<p><img src="https://images2.imgbox.com/16/3f/gx2T1TGM_o.png" alt="在这里插入图片描述"></p> 
<p>Android13 完整流程图：</p> 
<p><img src="https://images2.imgbox.com/c9/46/m2exsPdK_o.png" alt="在这里插入图片描述"></p> 
<p>不同Android11 部分用黄色标记出来了。</p> 
<p>其实正常情况，流程大多是没啥用处的，除非有特殊需求要需要改，但是wifi异常分析是经常遇到的，这种情况就要查看日志，需要找到关键时间点，进一步确定异常原因了，下面的日志可能会有一些帮助。</p> 
<h4><a id="2_824"></a>2、日志查看</h4> 
<h5><a id="_826"></a>关键字和可以查看到的关键信息</h5> 
<pre><code>关键字 : 关键信息
WifiService：查看WifiServiceImpl调用信息，一些api调用日志和wifi 开关日志
WifiController：ActiveModeWarden 内部状态机的一些信息
WifiActiveModeWarden：ActiveModeWarden 过程日志
WifiClientModeManager：ConcreteClientModeManager的过程日志
WifiNative：底层调用情况日志，异常情况会有明显日志
（底层）
HalDevMgr：HalDeviceManager 过程日志，和异常提示
WifiVendorHal：Hal过程日志和异常日志
android.hardware.wifi：底层hardware包相关日志

</code></pre> 
<p>一般情况关键日志主要看 WifiService 和 WifiNative , 根据发生问题时间点再仔细研究即可。</p> 
<p>多个日志打印的命令：</p> 
<pre><code>logcat | grep -E "WifiService|WifiController|WifiActiveModeWarden|WifiClientModeManager|WifiNative"
</code></pre> 
<p>测试打印部分日志如下：</p> 
<h5><a id="wifi_860"></a>正常开启wifi日志：</h5> 
<pre><code>//（1）清除一下日志
bsp:/ $ logcat -c

//（2）过滤关键字日志
bsp:/ $logcat | grep -E "WifiService|WifiController|WifiActiveModeWarden|WifiClientModeManager|WifiNative" 

//(3)打开wifi 的应用包名和uid， uid =1000 表示普通的系统应用， enable=true 表示打开
12-21 16:57:37.448   979  1393 I WifiService: setWifiEnabled package=com.skg.settings uid=1000 enable=true isPrivileged=true

//(4)其他一下状态信息
12-21 16:57:37.453   979  1275 D WifiActiveModeWarden: Starting primary ClientModeManager in connect mode
12-21 16:57:37.453   979  1275 D WifiController: DisabledState.exit()
12-21 16:57:37.453   979  1275 D WifiController: EnabledState.enter()

//(5) wlan0 节点开始打开
12-21 16:57:37.582   979  1275 I WifiNative: Successfully setup Iface:{Name=wlan0,Id=13,Type=STA_SCAN}
12-21 16:57:37.585   979  1275 D WifiClientModeManager[wlan0]: entering StartedState
12-21 16:57:37.599   979  1275 D WifiActiveModeWarden: setting wifi state to: 2

//(6)系统发送wifi 开关状态广播， 说明系统发出wifi 开关状态变化的广播 WIFI_STATE_CHANGED_ACTION 是 ConcreteClientModeManager 发出的
12-21 16:57:37.600   979  1275 D WifiClientModeManager[wlan0]: Sending broadcast=WIFI_STATE_CHANGED_ACTION EXTRA_WIFI_STATE=2 EXTRA_PREVIOUS_WIFI_STATE=1

//(7) 应用查询wifi状态日志， uid=1000 是uid系统apk
12-21 16:57:37.610   979  9543 I WifiService: getWifiEnabledState uid=10097
12-21 16:57:37.637   979 24139 I WifiService: getWifiEnabledState uid=1000
12-21 16:57:37.641   979 24139 I WifiService: getWifiEnabledState uid=1000

//(8) wlan0 节点成功打开
12-21 16:57:37.674   979  1275 I WifiNative: Successfully switched to connectivity mode on iface=Iface:{Name=wlan0,Id=13,Type=STA_CONNECTIVITY}

//(9)中间一些信息
12-21 16:57:37.674   979  1275 D WifiClientModeManager[wlan0]: entering ConnectModeState, starting ClientModeImpl
12-21 16:57:37.679   979  1275 V WifiClientModeManager[wlan0]: ClientModeManager started in role: Role: ROLE_CLIENT_PRIMARY, RequestorWs: WorkSource{1000 com.skg.settings}, ModeListener: com.android.server.wifi.ActiveModeWarden$ClientListener@ded9fb6
12-21 16:57:37.685   979  1275 V WifiActiveModeWarden: ModeManager added ConcreteClientModeManager{id=10580945 iface=wlan0 role=ROLE_CLIENT_PRIMARY}

//(11)设置  CountryCode ，00 应该是无效的，CN，US 那些才有用的，不过wifi 开启对CountryCode 没有要求，热点才有要求
12-21 16:57:37.695   979  1275 D WifiNative: onSetCountryCodeSucceeded: 00
12-21 16:57:37.699   979  1275 V WifiActiveModeWarden: Primary ClientModeManager changed from null to ConcreteClientModeManager{id=10580945 iface=wlan0 role=ROLE_CLIENT_PRIMARY}

//(12) wifi 完成打开的状态
12-21 16:57:37.699   979  1275 D WifiActiveModeWarden: setting wifi state to: 3
</code></pre> 
<p>这里看到wifi 从打开标识 setWifiEnabled 开始，到完成打开一般只用一秒不到。</p> 
<p>重点可以关注：WifiService 和 WifiNative 相关的日志，其中 WifiService 在后续扫描过程也是会有一些日志。</p> 
<h5><a id="wifi_914"></a>正常关闭wifi日志：</h5> 
<pre><code>bsp:/ $logcat | grep -E "WifiService|WifiController|WifiActiveModeWarden|WifiClientModeManager|WifiNative"

//（1）关闭 wifi 的应用包名和uid， uid =1000 表示普通的系统应用， enable=false 表示关闭
12-21 18:24:01.039   967  1554 I WifiService: setWifiEnabled package=com.skg.settings uid=1000 enable=false isPrivileged=true

//（2）状态机那些准备关闭wifi
12-21 18:24:01.044   967  1212 D WifiActiveModeWarden: Shutting down all client mode managers
12-21 18:24:01.051   967  1212 D WifiClientModeManager[wlan0]:  currentstate: ConnectModeState

//（3）进入正在关闭wifi状态0
12-21 18:24:01.055   967  1212 D WifiActiveModeWarden: setting wifi state to: 0

//（4）发送广播 正在关闭WiFi，EXTRA_WIFI_STATE=0 当前状态是正在关闭， EXTRA_PREVIOUS_WIFI_STATE=3 之前状态是打开
12-21 18:24:01.059   967  1212 D WifiClientModeManager[wlan0]: Sending broadcast=WIFI_STATE_CHANGED_ACTION EXTRA_WIFI_STATE=0 EXTRA_PREVIOUS_WIFI_STATE=3
12-21 18:24:01.065   967  1212 D WifiClientModeManager[wlan0]: The target role change info null
12-21 18:24:01.065   967  1212 D WifiClientModeManager[wlan0]: Continue to stop wifi

//（5）进入已关闭wifi状态1
12-21 18:24:01.065   967  1212 D WifiActiveModeWarden: setting wifi state to: 1
//发送广播 正在已WiFi，EXTRA_WIFI_STATE=1 是当前进入已关闭wifi状态，EXTRA_PREVIOUS_WIFI_STATE=0 表示上一个状态是正在关闭wifi状态
12-21 18:24:01.066   967  1212 D WifiClientModeManager[wlan0]: Sending broadcast=WIFI_STATE_CHANGED_ACTION EXTRA_WIFI_STATE=1 EXTRA_PREVIOUS_WIFI_STATE=0


//（6）移除节点信息
12-21 18:24:01.094   967  1212 D WifiNative: IfaceManager#removeIface: id=1, pre-map={1=Iface:{Name=wlan0,Id=1,Type=STA_CONNECTIVITY}}
12-21 18:24:01.127   967  1212 D WifiClientModeManager[wlan0]: STA iface wlan0 was destroyed, stopping client mode
12-21 18:24:01.127   967  1212 W WifiClientModeManager[wlan0]: Received mWifiNativeInterfaceCallback.onDestroyed callback when no ClientModeImpl instance is active.

//（7）完成节点关闭
12-21 18:24:01.127   967  1212 I WifiNative: Successfully torn down Iface:{Name=wlan0,Id=1,Type=STA_CONNECTIVITY}
12-21 18:24:01.128   967  1212 I WifiNative: Successfully initiated teardown for iface=wlan0

</code></pre> 
<h5><a id="wifiwifi_955"></a>缺少wifi硬件模组是开启wifi日志：</h5> 
<pre><code>bsp:/ $logcat | grep -E "WifiService|WifiController|WifiActiveModeWarden|WifiClientModeManager|WifiNative"

//(1)打开wifi 的应用包名和uid， uid =1000 表示普通的系统应用， enable=true 表示打开
12-21 18:56:50.905   967  2954 I WifiService: setWifiEnabled package=com.skg.settings uid=1000 enable=true isPrivileged=true

//(2)准备打开 wifi
12-21 18:56:50.907   967  1212 D WifiActiveModeWarden: Starting primary ClientModeManager in connect mode
12-21 18:56:50.908   967  1212 D WifiController: DisabledState.exit()
12-21 18:56:50.908   967  1212 D WifiController: EnabledState.enter()

//(3)无法打开，进入闲置状态
12-21 18:56:50.908   967  1212 D WifiClientModeManager[unknown]: entering IdleState
12-21 18:56:50.966   967  1212 D WifiNative: IfaceManager#allocateIface: type=2, pre-map={}

//(4)Hal 层有异常 died
12-21 18:56:50.969   967  1212 I WifiNative: Vendor HAL died. Cleaning up internal state.

//(5)Hal 层无法创建节点
12-21 18:56:50.970   967  1212 E WifiNative: Failed to create iface in vendor HAL

//(6)移除节点
12-21 18:56:50.970   967  1212 D WifiNative: IfaceManager#removeIface: id=2, pre-map={2=Iface:{Name=null,Id=2,Type=STA_SCAN}}
12-21 18:56:50.970   967  1212 E WifiClientModeManager[unknown]: Failed to create ClientInterface. Sit in Idle
12-21 18:56:50.970   967  1212 E WifiActiveModeWarden: ClientModeManager start failed!ConcreteClientModeManager{id=6808585 iface=null role=null}
12-21 18:56:50.970   967  1212 V WifiActiveModeWarden: ModeManager removed ConcreteClientModeManager{id=6808585 iface=null role=null}
12-21 18:56:50.978   967  1212 E WifiActiveModeWarden: One of the native daemons died. Triggering recovery
12-21 18:56:50.979   967  1212 E WifiSelfRecovery: Triggering recovery for reason: WifiNative Failure
12-21 18:56:50.979   967  1212 E WifiSelfRecovery: Restarting wifi for reason: WifiNative Failure
12-21 18:56:50.979   967  1212 D WifiController: STA disabled, return to DisabledState.

//（7）有可能多次循环该异常日志
12-21 18:56:50.979   967  1212 D WifiController: EnabledState.exit()
12-21 18:56:50.979   967  1212 D WifiController: DisabledState.enter()
12-21 18:56:50.979   967  1212 D WifiController: Recovery triggered, already in disabled state
12-21 18:56:50.995   967  1212 I WifiNative: Vendor HAL died. Cleaning up internal state.
12-21 18:56:50.995   967  1212 E WifiActiveModeWarden: One of the native daemons died. Triggering recovery
12-21 18:56:50.995   967  1212 E WifiSelfRecovery: Triggering recovery for reason: WifiNative Failure
12-21 18:56:50.995   967  1212 E WifiSelfRecovery: Restarting wifi for reason: WifiNative Failure
12-21 18:56:50.995   967  1212 D WifiController: Recovery triggered, already in disabled state
12-21 18:56:52.981   967  1212 D WifiController: Recovery in progress, start wifi
12-21 18:56:52.984   967  1212 D WifiActiveModeWarden: Starting primary ClientModeManager in connect mode
12-21 18:56:52.985   967  1212 D WifiController: DisabledState.exit()
12-21 18:56:52.985   967  1212 D WifiController: EnabledState.enter()
12-21 18:56:52.985   967  1212 D WifiClientModeManager[unknown]: entering IdleState
。。。

</code></pre> 
<p>重新测试看从（2）准备打开到（3）异常情况，查看整个logcat日志，发现还有部分底层的打印：</p> 
<pre><code>12-21 19:14:26.660   967  1212 D HalDevMgr: initIWifiIfNecessary
12-21 19:14:26.664   967  1212 I android_os_HwBinder: HwBinder: Starting thread pool for getting: android.hardware.wifi@1.0::IWifi/default
12-21 19:14:26.666   442   442 I android.hardware.wifi@1.0-service-lazy: Wifi HAL stopped
12-21 19:14:26.667   967  1212 I WifiVendorHal: Device Manager onStatusChanged. isReady(): false, isStarted(): false
12-21 19:14:26.667   967  1212 I WifiNative: Vendor HAL died. Cleaning up internal state.
</code></pre> 
<h4><a id="3wifi_1020"></a>3、wifi开关状态值</h4> 
<p>从WifiManager.java 代码看wifi 开关、关闭是有过程状态的：</p> 
<pre><code>    /**
     * The lookup key for an int that indicates whether Wi-Fi is enabled,
     * disabled, enabling, disabling, or unknown.  Retrieve it with
     * {@link android.content.Intent#getIntExtra(String,int)}.
     *
     * @see #WIFI_STATE_DISABLED //1
     * @see #WIFI_STATE_DISABLING //0 
     * @see #WIFI_STATE_ENABLED //3
     * @see #WIFI_STATE_ENABLING //2
     * @see #WIFI_STATE_UNKNOWN //4
     */
    public static final String EXTRA_WIFI_STATE = "wifi_state";
    
     /**
     * Broadcast intent action indicating that Wi-Fi has been enabled, disabled,
     * enabling, disabling, or unknown. One extra provides this state as an int.
     * Another extra provides the previous state, if available.  No network-related
     * permissions are required to subscribe to this broadcast.
     *
     * &lt;p class="note"&gt;This broadcast is not delivered to manifest receivers in
     * applications that target API version 26 or later.
     *
     * @see #EXTRA_WIFI_STATE //广播的wifi状态值数据
     * @see #EXTRA_PREVIOUS_WIFI_STATE
     */
    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
    public static final String WIFI_STATE_CHANGED_ACTION =
        "android.net.wifi.WIFI_STATE_CHANGED";
</code></pre> 
<p>这里可以看到从wifi开关状态广播变化中的额外信息可以看到：</p> 
<p>1 是关闭状态，3是打开状态，0 是正在关闭，2是正在打开；</p> 
<p>这几个状态变化的过程，正常都是有广播的。</p> 
<h4><a id="4wifi_1067"></a>4、之前写的一些wifi相关的知识</h4> 
<p>汇总：</p> 
<p>https://so.csdn.net/so/search?q=wifi&amp;t=blog&amp;u=wenzhi20102321</p> 
<p>Android10 系统应用wifi连接和静态ip代理设置：</p> 
<p>https://blog.csdn.net/wenzhi20102321/article/details/123675077</p> 
<p>Android adb shell svc 知识详解：</p> 
<p>https://blog.csdn.net/wenzhi20102321/article/details/132779708</p> 
<p>Android无线Wifi开发：</p> 
<p>https://blog.csdn.net/wenzhi20102321/article/details/53871216</p> 
<p>Android13 wifi状态问题分析：</p> 
<p>https://blog.csdn.net/wenzhi20102321/article/details/130411508</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/075c651c040195b51fc1434f1b401fc0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">孩子还是有一颗网安梦——Bandit通关教程：Level 18 → Level 19</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9b20680557b5a4f1a4a0f902721bba35/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SSH无密登陆配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>