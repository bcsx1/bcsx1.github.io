<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 基础知识 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; 基础知识" />
<meta property="og:description" content="C&#43;&#43; 基础知识 一、 语法：1.指针常量/常量指针2. 内存模型3. 引用4. C&#43;&#43;中面向对象的三大特性5. 纯虚函数和抽象类6. 文件操作7. 模板与泛型8. STL 一、 语法： 1.指针常量/常量指针 指针常量：顾名思义，指针是一个常量， 所以指针的指向不能改变，指针指向的值可以改变。常量指针：顾名思义，指向常量的指针，指针的指向可以改变，指针指向的值不能改变。 2. 内存模型 代码区： 用户写的所有代码都会放在代码区，二进制格式。代码区是共享的：相对于线程来说，代码区内的所有代码都是共享的，因为有可能用户会多次执行exe文件，开辟多次线程，所有多个线程可以共享同一份代码数据即可运行程序。代码区是只读的：使其只读的原因是防止程序意外地修改了它的指令。 全局区：
存放全局变量和静态变量以及常量，该区域的数据在程序结束后由操作系统释放. 全局变量：只要不是写在函数体中的变量都称之为全局变量。
静态变量:
在普通变量前加上static，属于静态变量。局部静态变量和全局静态变量都属于全局区：
常量：
字符串常量：
只要是用” xxx” 的都是字符串常量
const修饰的量：
const修饰的全局变量：属于全局区
cosnt修饰的局部变量：在方法体中属于局部变量不属于全局区
总结：C&#43;&#43;在程序运行前需要在内存中开辟代码区、全局区。全局区存放全局变量，static修饰的静态变量，常量(字符串常量，全局常量)
栈区：
由编译器自动分配释放, 存放函数的参数值,局部变量等。
注意事项：不要返回局部变量的地址，因为方法体中的局部变量是分配在栈区中的，只要方法执行完后，栈区开辟的数据空间就由编译器自动释放
堆区：
由程序员分配和释放,若程序员不释放,程序全部结束时由操作系统回收
利用new在堆区开辟内存：
利用delete释放内存
总结：不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程
3. 引用 引用的本质：引用的本质就是给一个变量起别名
引用必须在定义的时候就初始化。引用在初始化后，不可以改变
引用的底层实现：引用的本质就是定义一个指针常量来指向a，所以这也能解释引用不能修改的原因。
引用在C&#43;&#43;中的使用：
引用在函数中做值传递的应用：
函数中参数的值传递一般有三种方式：
值传递：
地址传递：
引用传递：
常量引用作为新参：表示传来的参数不能修改，只能读取：
引用传递和地址传递都能实现数值交换的需求，主要原理在于他们传递的都是地址。通过地址操作原来的栈中的a、b数据。而通过值传递则不能实现，因为值传递还是会在栈中分配另一份空间，函数中也是操作另一份空间中的内容，原空间中的值不变。
引用在函数中做返回值的应用：
注意：不能将局部变量的引用返回
引用可以作为函数的左值：
4. C&#43;&#43;中面向对象的三大特性 封装：
封装的意义以及访问权限：
将属性和行为作为一个整体，表现生活中的事物。可以给属性和行为加以权限控制
三种权限
①公共权限 public 类外可以访问 子类继承能访问" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/9dcbe0877240534d4041a636f767c88b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-11T22:20:41+08:00" />
<meta property="article:modified_time" content="2023-03-11T22:20:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 基础知识</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>C++ 基础知识</h4> 
 <ul><li><ul><li><a href="#__1" rel="nofollow">一、 语法：</a></li><li><ul><li><a href="#1_2" rel="nofollow">1.指针常量/常量指针</a></li><li><a href="#2__5" rel="nofollow">2. 内存模型</a></li><li><a href="#3__45" rel="nofollow">3. 引用</a></li><li><a href="#4_C_76" rel="nofollow">4. C++中面向对象的三大特性</a></li><li><a href="#5__163" rel="nofollow">5. 纯虚函数和抽象类</a></li><li><a href="#6__177" rel="nofollow">6. 文件操作</a></li><li><a href="#7__198" rel="nofollow">7. 模板与泛型</a></li><li><a href="#8_STL_228" rel="nofollow">8. STL</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="__1"></a>一、 语法：</h3> 
<h4><a id="1_2"></a>1.指针常量/常量指针</h4> 
<ol><li>指针常量：顾名思义，<strong>指针是一个常量</strong>， 所以指针的指向不能改变，指针指向的值可以改变。</li><li>常量指针：顾名思义，<strong>指向常量的指针</strong>，指针的指向可以改变，指针指向的值不能改变。</li></ol> 
<h4><a id="2__5"></a>2. 内存模型</h4> 
<ol><li>代码区： 
  <ol><li>用户写的所有代码都会放在<strong>代码区</strong>，二进制格式。</li><li>代码区是<strong>共享的</strong>：相对于线程来说，代码区内的所有代码都是共享的，因为有可能用户会多次执行exe文件，开辟多次线程，所有多个线程可以共享同一份代码数据即可运行程序。</li><li>代码区是<strong>只读的</strong>：使其只读的原因是防止程序意外地修改了它的指令。</li></ol> </li><li>全局区：<br> 存放<strong>全局变量</strong>和<strong>静态变量</strong>以及<strong>常量</strong>，该区域的数据在程序结束后<strong>由操作系统释放.</strong> 
  <ol><li> <p>全局变量：只要不是写在<strong>函数体中</strong>的变量都称之为全局变量。<br> <img src="https://images2.imgbox.com/a0/6a/hdgqjDXW_o.png" alt="在这里插入图片描述"></p> </li><li> <p>静态变量:<br> 在普通变量前<strong>加上static</strong>，属于静态变量。局部静态变量和全局静态变量都属于全局区：<br> <img src="https://images2.imgbox.com/50/27/nMuBrPm3_o.png" alt="在这里插入图片描述"></p> </li><li> <p>常量：</p> 
    <ol><li> <p>字符串常量：<br> 只要是用” xxx” 的都是字符串常量</p> </li><li> <p>const修饰的量：<br> const修饰的<strong>全局变量</strong>：属于全局区<br> <img src="https://images2.imgbox.com/da/59/nbTVjDAs_o.png" alt="在这里插入图片描述"></p> <p>cosnt修饰的<strong>局部变量</strong>：在方法体中属于局部变量不属于全局区</p> </li></ol> </li></ol> </li></ol> 
<p>总结：C++<strong>在程序运行前</strong>需要在内存中开辟代码区、全局区。全局区存放全局变量，static修饰的静态变量，常量(字符串常量，全局常量)</p> 
<ol start="3"><li> <p>栈区：<br> 由<strong>编译器自动分配释放</strong>, 存放函数的<strong>参数值</strong>,<strong>局部变量</strong>等。<br> 注意事项：<strong>不要返回局部变量的地址</strong>，因为方法体中的局部变量是分配在栈区中的，只要方法执行完后，栈区开辟的数据空间就由编译器自动释放<br> <img src="https://images2.imgbox.com/3b/55/GdXfN8A1_o.png" alt="在这里插入图片描述"></p> </li><li> <p>堆区：<br> 由<strong>程序员分配和释放</strong>,若程序员不释放,程序全部结束时由操作系统回收<br> 利用<strong>new</strong>在堆区开辟内存：<br> <img src="https://images2.imgbox.com/60/aa/WHXSPKT5_o.png" alt="在这里插入图片描述"><br> 利用<strong>delete</strong>释放内存<br> <img src="https://images2.imgbox.com/14/d9/vdIZuTzz_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<p>总结：不同区域存放的数据，赋予不同的生命周期, 给我们<strong>更大的灵活编程</strong></p> 
<h4><a id="3__45"></a>3. 引用</h4> 
<ol><li> <p>引用的本质：引用的本质就是<strong>给一个变量起别名</strong><br> <img src="https://images2.imgbox.com/9d/93/LKXAlHPx_o.png" alt="在这里插入图片描述"> <img src="https://images2.imgbox.com/78/5c/q2aKpoqN_o.png" alt="在这里插入图片描述"><br> 引用必须在定义的时候就初始化。引用在初始化后，不可以改变<br> <img src="https://images2.imgbox.com/23/4b/UrO448Pk_o.png" alt="在这里插入图片描述"> <img src="https://images2.imgbox.com/de/26/MpR3VhUg_o.png" alt="在这里插入图片描述"></p> </li><li> <p>引用的底层实现：引用的本质就是定义一个<strong>指针常量</strong>来指向a，所以这也能解释引用不能修改的原因。<br> <img src="https://images2.imgbox.com/43/09/XumesqLS_o.png" alt="在这里插入图片描述"></p> </li><li> <p>引用在C++中的使用：</p> 
  <ol><li> <p>引用在函数中做值传递的应用：<br> 函数中参数的值传递一般有三种方式：<br> <img src="https://images2.imgbox.com/78/4b/5Kr2cXjg_o.png" alt="在这里插入图片描述"></p> <p>值传递：<br> <img src="https://images2.imgbox.com/80/f8/jKzFkMt0_o.png" alt="在这里插入图片描述"><br> 地址传递：<br> <img src="https://images2.imgbox.com/ff/8f/2cdPnIoM_o.png" alt="在这里插入图片描述"></p> <p>引用传递：<br> <img src="https://images2.imgbox.com/7c/53/7PyJosK0_o.png" alt="在这里插入图片描述"><br> 常量引用作为新参：表示传来的参数不能修改，只能读取：<br> <img src="https://images2.imgbox.com/45/f5/IUScMcym_o.png" alt="在这里插入图片描述"></p> </li></ol> <p>引用传递和地址传递都能实现数值交换的需求，主要原理在于<strong>他们传递的都是地址</strong>。通过地址操作原来的栈中的a、b数据。而通过值传递则不能实现，因为值传递还是会在栈中分配另一份空间，函数中也是操作另一份空间中的内容，原空间中的值不变。</p> 
  <ol start="2"><li>引用在函数中做返回值的应用：<br> 注意：不能将局部变量的引用返回<br> <img src="https://images2.imgbox.com/07/7d/A2UDVDnf_o.png" alt="在这里插入图片描述"><br> 引用可以作为函数的左值：<br> <img src="https://images2.imgbox.com/2c/f8/8i1KJ8Rd_o.png" alt="在这里插入图片描述"></li></ol> </li></ol> 
<h4><a id="4_C_76"></a>4. C++中面向对象的三大特性</h4> 
<ol><li> <p>封装：</p> 
  <ol><li> <p>封装的意义以及访问权限：<br> 将属性和行为<strong>作为一个整体</strong>，表现生活中的事物。可以给属性和行为加以<strong>权限控制</strong><br> 三种权限<br> ①公共权限 public 类外可以访问 子类继承能访问<br> ②保护权限 protected 类外不可以访问 子类继承可以访问<br> ③私有权限 private 类外不可以访问 子类继承不可以访问</p> </li><li> <p>类的构造与析构：</p> <p><img src="https://images2.imgbox.com/65/00/RX2Eq5om_o.png" alt="在这里插入图片描述"><br> //拷贝构造<br> Person p3 = Person(p2);<br> Person p5 = p4;</p> </li><li> <p>深度拷贝和浅拷贝：<br> 简单来说浅拷贝就是在对象进行拷贝的时候对对象中的属性进行<strong>简单的赋值操作</strong>，例如对象L1属于L类，L1中有一个属性m是指向在堆区开辟的一块内存空间。当调用L L2(L1)进行拷贝操作时，由于是浅拷贝，所以直接将L1中的值赋给L2，故L2中的m属性会直接将<strong>L1中的m属性的值拷贝过来</strong>，那么最终L1、L2的m属性都<strong>指向堆区的同一份空间</strong>。如果哪天L1进行析构函数的调用，将自身的所有属性都释放掉，包括L1.m指向的那一块堆区空间。那么L1释放掉后，若L2再去执行析构时也会和L1一样去释放自身的所有属性，由于L1已经把堆区那一片空间释放掉了，所以L2再去释放就会报错。根本原因在于L2是进行浅拷贝的L1值，<strong>导致L2、L1指向同一份空间</strong>。正确的做法是应该采用深拷贝，L2在拷贝L1时，同样给L2.m属性<strong>分配一块堆区空间</strong>。<br> 编译器<strong>默认提供的拷贝方法就是浅拷贝</strong>。</p> </li><li> <p>类中的静态成员<br> 所有对象<strong>共享同一份数据</strong>，在<strong>编译阶段分配内存</strong>，类<strong>内声明，类外初始化</strong><br> （1）类的静态成员是属于类而不属于对象，所以他不是类的单个对象所有。<br> （2）静态成员只存在一个，不像普通的成员，每创建一个对象，就会创建一组普通的成员。<br> （3）父类中定义了静态成员，则整个继承体系中只有一个这样的成员，无论派生出多少个子类。静态成员是存储在全局区的。<br> <img src="https://images2.imgbox.com/d8/8b/KRrlodeZ_o.png" alt="在这里插入图片描述"></p> </li><li> <p>this</p> 
    <ol><li>C++中，类内的<strong>成员变量和成员函数分开存储</strong>。只有<strong>非静态成员变量才属于类的对象上</strong>。因为C++中成员变量和成员函数是分开存储的，类中每一个非静态函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，那么问题是：这一块代码是如何区分那个对象调用自己的呢？c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象。this指针是隐含每一个非静态成员函数内的一种指针，this指针不需要定义，直接使用即可。</li><li>this指针的用途：<br> 当形参和成员变量同名时，可用this指针来区分。<br> 在类的非静态成员函数中返回对象本身，可使用return *this。</li><li>C++中允许空指针调用成员函数，前提是该方法中没有用到this。依据上面所讲，C++中所有对象的方法都是统一放在一个地方，当某个对象调用方法时会隐含的将this指针传入，如果方法中用到了该对象的属性，那么会默认的用this去访问，若指针为空那么this就访问不到。<br> <img src="https://images2.imgbox.com/b9/00/SdYUTRCy_o.png" alt="在这里插入图片描述"> <img src="https://images2.imgbox.com/79/58/jRioNB5U_o.png" alt="在这里插入图片描述"><br> 因为showPersonAge中访问了非静态成员变量m_Age，而p又没有初始化，所以this = NULL。最终访问错误。</li></ol> </li><li> <p>常函数与常对象</p> 
    <ol><li>常函数：<br> 成员函数后加const后我们称为这个函数为常函数<br> 常函数内不可以修改该类的对象中成员的属性<br> 成员属性声明时加关键字mutable后，在常函数中依然可以修改</li><li>常对象：<br> 对象后面加const后称之为常对象，常对象不能修改对象中的属性值，并且常对象只能调用常函数。</li></ol> </li><li> <p>友元<br> 生活中你的家有客厅(Public)，有你的卧室(Private)客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去但是呢，你也可以允许你的好闺蜜好基友进去。在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术友元的目的就是让一个函数或者类访问另一个类中私有成员友元的关键字为 friend友元的三种实现。</p> </li><li> <p>运算符重载<br> <img src="https://images2.imgbox.com/41/bc/a6fwSucI_o.png" alt="在这里插入图片描述"></p> </li></ol> </li><li> <p>继承：<br> <strong>继承的语法</strong>：class 子类 : 继承方式 父类<br> <strong>继承方式</strong>一共有三种，子类B继承父类A以不同的方式继承会得到不同的效果<br> <img src="https://images2.imgbox.com/d9/11/Y7jsqcx4_o.png" alt="在这里插入图片描述"><br> 公共继承：A中属性的访问权限到了B中还是不变。<br> 保护继承：A中private变量访问权限到了B中不变，其他的都变为protect<br> 私有继承：A中所有的属性都变为private</p> <p>注：子类会把父类无论什么访问权限的属性都继承下去。<br> 如果有子类中有同名的成员属性，那么想要访问父类中的属性就必须添加作用域来调用：<br> <img src="https://images2.imgbox.com/47/59/Lfc2f3GY_o.png" alt="在这里插入图片描述"><br> <strong>构造、析构顺序</strong>：继承中是先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反。</p> </li><li> <p>多态：</p> 
  <ol><li> <p>多态问题涉及到<strong>地址早绑定、晚绑定</strong>问题。<br> <strong>地址早绑定</strong>：在编译阶段就确定了函数地址。<br> <strong>地址晚绑定</strong>：如果想要地址晚绑定则需要指定virtual关键字<br> <img src="https://images2.imgbox.com/b2/22/KvbtFEzV_o.png" alt="在这里插入图片描述"></p> </li><li> <p>多态满足条件：<br> ①有继承关系<br> ②子类重写父类中的虚函数<br> ③父类指针或引用指向子类对象</p> </li><li> <p><strong>动态多态底层实现原理</strong>：<br> 我们已经知道：类的成员函数不属于某个对象，该函数是放在代码区。<br> <img src="https://images2.imgbox.com/35/f8/TFCdFhiO_o.png" alt="在这里插入图片描述"> <img src="https://images2.imgbox.com/2b/7a/cfjKjbLa_o.png" alt="在这里插入图片描述"><br> 当Animal类中的speak()方法没有加virtual关键字时，调用sizeof(Animal)结果是1，因为C++编译器会给每个空对象也分配一个字节空间，为了区分空对象占内存的位置，每个空对象也应该有一个独一无二的内存地址 <br> 而如果加上virtual关键字，那么c++会为该类维护一个虚函数表(vftable)，并用一个虚函数表执政(vfptr)指向该表<br> <img src="https://images2.imgbox.com/ec/86/6uTRrX2C_o.png" alt="在这里插入图片描述"><br> 所以只要类中有虚函数，那么c++就会开辟一个空间vftable存放这些虚函数的地址如&amp;WLM::fun1()，&amp;WLM::fun2()，并且生成一个vftptr指向该表，将vftptr隐含的保存到该类中，所以sizeof(WLM)=8 多出来一个vftptr的空间<br> <img src="https://images2.imgbox.com/db/29/8FUF7JJJ_o.png" alt="在这里插入图片描述"><br> 如果发生继承，那么子类中也会将该vfptr也复制一份到子类对象中<br> <img src="https://images2.imgbox.com/36/b5/PmuSVjyY_o.png" alt="在这里插入图片描述">———&gt;<img src="https://images2.imgbox.com/a0/49/0H7v0T80_o.png" alt="在这里插入图片描述"><br> 当子类重写父类中的虚函数时，子类中的<strong>虚函数表内部会替换成子类</strong>的重写后的虚函数地址。<br> <img src="https://images2.imgbox.com/42/ed/3Z195VW7_o.png" alt="在这里插入图片描述"><br> 总结：因为我们在父类中写了virtual虚函数，父类的类内部结构就会发生变换，生成了一个vfptr虚函数指针，指向虚函数表，表中记录了类中的虚函数入口地址，当子类继承父类后，子类内部也会有一个虚函数指针，同样也指向属于子类的虚函数表。若子类重写了父类中的虚函数，那么子类中的虚函数表中的虚函数入口地址则被子类替换成重写后的虚函数入口地址。如果发生多态，则调用的则是虚函数表中子类重写的虚函数。</p> </li></ol> </li></ol> 
<h4><a id="5__163"></a>5. 纯虚函数和抽象类</h4> 
<ol><li>纯虚函数：<br> 在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将<strong>虚函数改为纯虚函数</strong><br> 纯虚函数语法：<strong>virtual 返回值类型 函数名 （参数列表）= 0</strong><br> <strong>当类中有了纯虚函数，这个类也称为抽象类</strong></li><li>虚析构的作用：<br> 当我们实现多态时，如果子类中的属性有指向某块堆区，<strong>delete时是不会走子类中的析构，而是会去走父类中的虚构函数</strong><br> <img src="https://images2.imgbox.com/51/0f/1IaGpHS7_o.png" alt="在这里插入图片描述"><br> 如上：Animal animal 实现多态，<strong>但delete animal不会走Cat中的虚构</strong><br> <img src="https://images2.imgbox.com/9d/78/EsYZEXUp_o.png" alt="在这里插入图片描述"> <img src="https://images2.imgbox.com/d8/63/7bZMfsVB_o.png" alt="在这里插入图片描述"><br> 解决方式：<strong>将父类中的析构函数改为虚析构</strong><br> <img src="https://images2.imgbox.com/4f/cf/HiZZlBWd_o.png" alt="在这里插入图片描述"> —&gt;<img src="https://images2.imgbox.com/82/1e/7I1trhZO_o.png" alt="在这里插入图片描述"><br> 这样 delete animal 后，就会走子类Cat的虚析构函数。</li></ol> 
<h4><a id="6__177"></a>6. 文件操作</h4> 
<ol><li> <p>定义：<br> 程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放，所以需要通过文件可以将数据持久化。<br> C++ 中对文件的操作需要包含头文件 &lt; fstream &gt;<br> 文件类型分为两种：</p> </li><li> <p>文件类型：<br> <strong>文本文件</strong> - 文件以文本的ASCII码形式存储在计算机中<br> <strong>二进制文件</strong> - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂<br> 操作文件的三大类：<br> <em>&lt; ofstream&gt;：写操作</em><br> <em>&lt; ifstream&gt;： 读操作</em><br> <em>&lt; fstream&gt;： 读写操作</em></p> </li><li> <p>文件操作步骤：<br> ①包含头文件：#include &lt; fstream &gt;;<br> ②创建流对象：ofstream ofs; 或 ifstream ifs;<br> ③打开文件： ofs.open(“文件路径”,打开方式);<br> <img src="https://images2.imgbox.com/1a/16/32iI5LjI_o.png" alt="在这里插入图片描述"><br> ④读/写 数据：ofs &lt;&lt; “写入的数据”;<br> ⑤关闭文件： ofs.close();</p> </li></ol> 
<h4><a id="7__198"></a>7. 模板与泛型</h4> 
<ol><li> <p>函数模板：<br> 普通函数与函数模板区别：<br> ①普通函数调用时可以发生自动类型转换（隐式类型转换）<br> ②函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换。如果利用显示指定类型的方式，可以发生隐式类型转换<br> ③<strong>建议使用显示指定类型的方式调用函数模板</strong>，因为可以自己确定通用类型T<br> ④如果函数模板和普通函数都可以实现，优先调用普通函数，可以通过空模板参数列表来强制调用函数模板<br> <img src="https://images2.imgbox.com/05/cb/2mLHXkkv_o.png" alt="在这里插入图片描述"><br> ⑤函数模板也可以发生重载，如果函数模板可以产生更好的匹配,优先调用函数模板<br> <img src="https://images2.imgbox.com/35/8c/hAUaqgT5_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6d/d0/8VLM53Tj_o.png" alt="在这里插入图片描述"></p> </li><li> <p>类模板：用template+typename 或 template+class都行：<br> <img src="https://images2.imgbox.com/87/c4/x4Hzv8O9_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/18/88/xFIcHm2H_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c1/0e/PaNPu9Y0_o.png" alt="在这里插入图片描述"><br> 类模板中成员函数创建时机：<br> 普通类中的成员函数一开始就可以创建，类模板中的成员函数<strong>只在调用时才创建</strong><br> <img src="https://images2.imgbox.com/6a/45/BTLNK5Kw_o.png" alt="在这里插入图片描述"></p> </li><li> <p>类模板作为函数参数的调用更加优雅：<br> <img src="https://images2.imgbox.com/3b/73/mz46mD8K_o.png" alt="在这里插入图片描述"></p> </li><li> <p>类模板与继承：<br> 当子类继承的父类是一个类模板时，子类在声明的时候，<strong>要指定出父类中T的类型</strong><br> 如果不指定，编译器无法给子类分配内存<br> 如果想灵活指定出父类中T的类型，子类也需变为类模板<br> <img src="https://images2.imgbox.com/70/eb/efPSuQn1_o.png" alt="在这里插入图片描述"></p> </li><li> <p>类模板分文件编写：<br> 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到<br> 将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</p> </li></ol> 
<h4><a id="8_STL_228"></a>8. STL</h4> 
<p>SLT六大组件：<strong>容器、算法 、迭代器、仿函数、适配器、空间配置器</strong></p> 
<ol><li> <p>容器：vector、list、deque、set、map等</p> 
  <ol><li> <p>vector：<br> <img src="https://images2.imgbox.com/d4/81/J67MQnaJ_o.png" alt="在这里插入图片描述"><br> 向容器中插入数据：v.push_back()<br> 遍历的三种方法：<br> <img src="https://images2.imgbox.com/1d/88/zydLP6Ox_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/89/00/dqu02AlQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d2/ce/WpOPjdcw_o.png" alt="在这里插入图片描述"><br> vector与数组的区别：不同之处在于<strong>数组是静态空间</strong>，而<strong>vector可以动态扩展</strong>。并不是在原空间之后续接新空间，而是找更大的内存空间，然后将<strong>原数据拷贝新空间</strong>，释放原空间。</p> </li><li> <p>list</p> </li><li> <p>deque</p> </li><li> <p>set</p> </li><li> <p>map</p> </li></ol> </li><li> <p>算法</p> </li><li> <p>迭代器</p> </li><li> <p>仿函数</p> </li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e78748de85f5ba338a2f5388a1f5985e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端学习笔记（三）：js基础</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a0a3080df6f847e660cbca985cbd0d65/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">音视频开发学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>