<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java实现图的基本操作 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java实现图的基本操作" />
<meta property="og:description" content="一、实验目的 1、熟练掌握图的邻接矩阵和邻接表存储结构；
2、掌握图的创建方法；
3、掌握求顶点度的方法；
4、掌握图的深度优先和广度优先遍历方法；
5、掌握图的邻接矩阵和邻接表存储结构的转换。
二、实验内容 1、分别定义图的邻接矩阵和邻接表存储结构；
2、分别在两种存储结构下根据输入的顶点和边（或弧）创建图；
3、分别在两种存储结构下实现求顶点度的操作；
4、分别在两种存储结构下实现图的深度和广度优先遍历算法；
5、实现图的邻接矩阵和邻接表存储结构的转换。
三、实验步骤 1、定义图的存储结构
2、实现图的创建方法，并创建一个如下的图：
3、实现求第一个邻接点firstAdjVex()和下一个邻接点nextAdjVex()的操作；
4、写一个算法，求各个顶点的度；
5、对创建的图进行深度优先和广度优先遍历。
6、将邻接表存储的有向图转换为邻接矩阵或将邻接矩阵存储的图转换为邻接表。
四、代码及运行结果 import java.util.*; public class ALGraph implements IGraph{ private GraphKind kind; private int vexNum, arcNum; public VNode[] vexs; public ALGraph(GraphKind kind, int vexNum, int arcNum, VNode[] vexs) { this.kind = kind; this.arcNum = arcNum; this.vexNum = vexNum; this.vexs = vexs; } public ALGraph() { this(null, 0, 0, null); } public void createGraph() { Scanner sc = new Scanner(System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/9f8a9013f838fc1128ec4688e4f72c40/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-25T11:58:57+08:00" />
<meta property="article:modified_time" content="2023-01-25T11:58:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java实现图的基本操作</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="">一、实验目的</h2> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">1、熟练掌握图的邻接矩阵和邻接表存储结构；</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">2、掌握图的创建方法；</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">3、掌握求顶点度的方法；</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">4、掌握图的深度优先和广度优先遍历方法；</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">5、掌握图的邻接矩阵和邻接表存储结构的转换。</p> 
 <h2 style="">二、实验内容</h2> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">1、分别定义图的邻接矩阵和邻接表存储结构；</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">2、分别在两种存储结构下根据输入的顶点和边（或弧）创建图；</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">3、分别在两种存储结构下实现求顶点度的操作；</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">4、分别在两种存储结构下实现图的深度和广度优先遍历算法；</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">5、实现图的邻接矩阵和邻接表存储结构的转换。</p> 
 <h2 style="">三、实验步骤</h2> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">1、定义图的存储结构</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">2、实现图的创建方法，并创建一个如下的图：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:425px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:64.2353%;height:0;"> 
    <img src="https://images2.imgbox.com/0d/a3/OuBs9gYt_o.png" style="margin-left:;display:block;width:425px;margin-top:-64.2353%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">3、实现求第一个邻接点firstAdjVex()和下一个邻接点nextAdjVex()的操作；</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">4、写一个算法，求各个顶点的度；</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">5、对创建的图进行深度优先和广度优先遍历。</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">6、将邻接表存储的有向图转换为邻接矩阵或将邻接矩阵存储的图转换为邻接表。</p> 
 <h2 style="">四、代码及运行结果</h2> 
 <pre class="kdocs-java"><code class="language-java">import java.util.*;
public class ALGraph implements IGraph{
    private GraphKind kind;
    private int vexNum, arcNum;
    public VNode[] vexs;

    public ALGraph(GraphKind kind, int vexNum, int arcNum, VNode[] vexs) {
        this.kind = kind;
        this.arcNum = arcNum;
        this.vexNum = vexNum;
        this.vexs = vexs;
    }

    public ALGraph() {
        this(null, 0, 0, null);
    }

    public void createGraph() {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入图的类型");
        GraphKind kind = GraphKind.valueOf(sc.next());
        switch (kind) {
            case DG:
                createDG();
                return;
        }
    }

    public void createDG() {
        Scanner sc = new Scanner(System.in);
        System.out.println("请分别输入图的顶点数，图的边数：");
        vexNum = sc.nextInt();
        arcNum = sc.nextInt();
        vexs = new VNode[vexNum];
        System.out.println("请分别输入图的各顶点：");
        for (int v = 0; v &lt; vexNum; v++) {
            vexs[v] = new VNode(sc.next());
        }
        System.out.println("请输入各边顶点");
        for (int k = 0; k &lt; arcNum; k++) {
            int v = locateVex(sc.next());
            int u = locateVex(sc.next());
            addArc(v, u);
        }
    }

    public void addArc(int v, int u) {
        ArcNode arc = new ArcNode(u);
        arc.nextArc = vexs[v].firstArc;
        vexs[v].firstArc = arc;
    }

    public int locateVex(Object vex) {
        for (int v = 0; v &lt; vexNum; v++)
            if (vexs[v].data.equals(vex))
                return v;
        return -1;
    }

    public int getVexNum() {
        return vexNum;
    }

    public int getArcNum() {
        return arcNum;
    }

    public VNode[] getVexs(){
        return vexs;
    }

    public GraphKind getKind(){
        return kind;
    }

    public Object getVex(int v){
        return vexs[v].data;
    }

    public Object nextAdjVex() {
        Scanner sc = new Scanner(System.in);
        System.out.println("输入顶点及其一个邻接点求下一个邻接点");
        Object V = sc.next();
        Object W = sc.next();
        int v = locateVex(V);
        int w = locateVex(W);
        try {
            int s = nextAdjVex(v,w);
            return vexs[s].data;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
    public int nextAdjVex(int v, int w) throws Exception{
        if (v&lt;0&amp;&amp;v&gt;=vexNum)
            throw new Exception("不存在");
        VNode vex=vexs[v];
        ArcNode arcvw=null;
        for (ArcNode arc=vex.firstArc;arc!=null;arc=arc.nextArc){
            if (arc.adjVex==w){
                arcvw=arc;
                break;
            }
        }
        if (arcvw!=null&amp;&amp;arcvw.nextArc!=null)
            return arcvw.nextArc.adjVex;
        else
            return -1;
    }


    public Object firstAdjVex() {
        Scanner sc = new Scanner(System.in);
        System.out.println("输入顶点求第一个邻接点");
        Object V = sc.next();
        int v = locateVex(V);
        int w=firstAdjVex(v);
        VNode vex=vexs[w];
        return vex.data;
    }
    public int firstAdjVex(int v){
        VNode vex=vexs[v];
        if (vex.firstArc!=null)
            return vex.firstArc.adjVex;
        else
            return -1;
    }


    //广度优先遍历
    private static boolean[]visited;
    public static void BFSTraverse(ALGraph G) {
        visited = new boolean[G.getVexNum()];
        for (int v=0;v&lt;G.getVexNum();v++){
            visited[v]=false;
        }
        for (int v=0;v&lt;G.getVexNum();v++){
            if(!visited[v])
                BFS(G,v);
        }
    }
    private static void BFS(ALGraph G,int v){
        visited[v]=true;
        System.out.print(G.getVex(v).toString()+" ");
        LinkQueue Q=new LinkQueue();
        Q.offer(v);
        while(!Q.isEmpty()){
            int u=(Integer)Q.poll();
            try {
                for(int w=G.firstAdjVex(u); w&gt;=0; w=G.nextAdjVex(u,w))
                    if (visited[w]==false){
                        System.out.print(G.getVex(w).toString() +" ");
                        visited[w]=true;
                        Q.offer(w);
                    }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    //深度优先遍历
    public static void DFSTraverse(ALGraph G){
        visited = new boolean[G.getVexNum()];
        for (int v=0;v&lt;G.getVexNum();v++){
            visited[v]=false;
        }
        for (int v=0;v&lt;G.getVexNum();v++){
            if(!visited[v])
                DFS(G,v);
        }
    }
    private static void DFS(ALGraph G,int v) {
        visited[v] = true;
        System.out.print(G.getVex(v).toString() + " ");
        try {
            for(int w=G.firstAdjVex(v); w&gt;=0; w=G.nextAdjVex(v,w))
                if (visited[w]==false)
                    DFS(G,w);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public int Degree(){
        Scanner sc = new Scanner(System.in);
        System.out.println("输入顶点求度");
        Object d = sc.next();
        int v = locateVex(d);
        return outDegree(v)+inDegree(v);
    }

    public int outDegree(int v) {
        int count = 0;
        for (ArcNode arc=vexs[v].firstArc;arc!=null;arc=arc.nextArc){
            count++;
        }
        return count;
    }

    public int inDegree(int v) {
        int count = 0;
        for(int u = 0; u &lt; vexNum; u++) {
            for (ArcNode arc=vexs[u].firstArc;arc!=null;arc=arc.nextArc) {
                if (arc.adjVex==v)
                    ++count;
            }
        }
        return count;
    }

    public void print(){
        System.out.println("邻接表为");
        for(int u = 0; u &lt; vexNum; u++) {
            System.out.print(vexs[u].data+"-&gt;");
            for (ArcNode arc = vexs[u].firstArc; arc != null; arc = arc.nextArc) {
                System.out.print(arc.adjVex+"-&gt;");
            }
            System.out.println();
        }
    }




    public void exchange(ALGraph G) {
        int vexNum,arcNum;
        vexNum = G.getVexNum();
        arcNum = G.getArcNum();
        Object[] vexs;
        int[][] arcs;
        vexs = new Object[vexNum];
        for (int v = 0; v &lt; vexNum; v++) {
            vexs[v] = G.vexs[v];
        }
        arcs = new int[vexNum][vexNum];
        for (int v = 0; v &lt; vexNum; v++) {
            for (int u = 0; u &lt; vexNum; u++) {
                arcs[v][u] = 0;
            }
        }
        for (int v=0; v &lt; arcNum; v++) {
            if (G.vexs[v].firstArc == null)
                break;
            else
                for (ArcNode arc=G.vexs[v].firstArc;arc!=null;arc=arc.nextArc) {
                    arcs[v][arc.adjVex] = 1;
                }
        }
        System.out.println("转化后邻接矩阵为");
        for (int v = 0; v &lt; vexNum; v++) {
            for (int u = 0; u &lt; vexNum; u++) {
                System.out.print(arcs[v][u]+" ");
            }
            System.out.println();
        }

    }

}
</code></pre> 
 <pre class="kdocs-java"><code class="language-java">public class ALGraphTest {
    public static void main(String[] args) {
        ALGraph t=new ALGraph();
        t.createGraph();
        t.print();
        Object m=t.firstAdjVex();
        System.out.println("第一个邻接点是"+m);
        Object n = t.nextAdjVex();
        System.out.println("下一个邻接点是"+n);
        System.out.println("广度优先遍历结果为：");
        ALGraph.BFSTraverse(t);
        System.out.println();
        System.out.println("深度优先遍历结果为：");
        ALGraph.DFSTraverse(t);
        System.out.println();
        System.out.println("度为"+t.Degree());
        t.exchange(t);
    }
}
</code></pre> 
 <pre class="kdocs-java"><code class="language-java">public class ArcNode {
    public int adjVex;
    public ArcNode nextArc;
    public ArcNode(){
        this(-1,null);
    }
    public ArcNode(int adjVex){
        this(adjVex,null);
    }
    public ArcNode(int adjVex,ArcNode nextArc){
        this.adjVex=adjVex;
        this.nextArc=nextArc;
    }
}
</code></pre> 
 <pre class="kdocs-java"><code class="language-java">public enum GraphKind {
    UDG,
    DG,
    UDN,
    DN
}
</code></pre> 
 <pre class="kdocs-java"><code class="language-java">public interface IGraph{
    void createGraph();
    int getVexNum();
    int getArcNum();
    Object getVex(int v);
    int locateVex(Object vex);
    int firstAdjVex(int v);
    int nextAdjVex(int v,int w) throws Exception;
}
</code></pre> 
 <pre class="kdocs-java"><code class="language-java">public interface IQueue&lt;T&gt; {
    void clear();

    boolean isEmpty();

    int length();

    T peek();

    void offer(T x);

    T poll();
}
</code></pre> 
 <pre class="kdocs-java"><code class="language-java">//空队列时，size = 0 &amp;&amp; front = null &amp;&amp; rear = null

public class LinkQueue&lt;T&gt; implements IQueue&lt;T&gt; {
    Node&lt;T&gt; front;
    Node&lt;T&gt; rear;
    int size;

    static class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; next;

        Node(T e, Node&lt;T&gt; p) {
            data = e;
            next = p;
        }
    }


    public boolean isEmpty() {
        return size == 0;
    }

    public int length() {
        return size;
    }

    public T peek() {
        if (front == null)
            return null;
        else
            return front.data;
    }

    public void offer(T x) {
        if (front == null) {
            front = rear = new Node&lt;&gt;(x, null);
        } else {
            rear = rear.next = new Node&lt;&gt;(x, null);
            // rear = rear.next;
        }
        size++;
    }

    public T poll() {
        if (front == null)
            return null;
        else {
            Node&lt;T&gt; p = front;
            front = front.next;

            T data = p.data;
            p.data = null;
            p.next = null;

            size--;

            if (front == null) {// 删除的是最后1个元素
                rear = null;// front肯定是null
                assert (size == 0);
            }

            return data;
        }
    }

    public void clear() {
        while (front != null) {
            Node&lt;T&gt; p = front;
            front = front.next;

            p.data = null;
            p.next = null;
        }
        size = 0;
        rear = null;
    }

    public String toString() {
        Node&lt;T&gt; p = front;
        String result = getClass().getName() + ":";
        while (p != null) {
            result += p.data + " ";
            p = p.next;
        }
        return result;
    }


}</code></pre> 
 <pre class="kdocs-java"><code class="language-java">public class LinkQueue2&lt;T&gt; implements IQueue&lt;T&gt; {
    Node&lt;T&gt; front;
    Node&lt;T&gt; rear;
    int size;

    static class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; next;

        Node(T e, Node&lt;T&gt; p) {
            data = e;
            next = p;
        }
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int length() {
        return size;
    }

    public T peek() {
        if (size == 0)
            return null;
        else
            return front.data;
    }

    public void offer(T x) {
        if (size == 0) {
            front = rear = new Node&lt;&gt;(x, null);
        } else {
            rear = rear.next = new Node&lt;&gt;(x, null);
            //rear = rear.next;
        }
        size++;
    }

    public T poll() {
        if (size == 0)
            return null;
        else {
            Node&lt;T&gt; p = front;
            front = front.next;

            T data = p.data;
            p.data = null;
            p.next = null;

            size--;
/*
            if (size == 0) {// 删除的是最后1个元素,不要这一段也可以，因为总是用size==0判断队空
                rear = null;// front肯定是null
                assert (front == null);
            }
*/

            return data;
        }
    }

    public void clear() {
        for(; size != 0; --size) {//没有用front != null
            Node&lt;T&gt; p = front;
            front = front.next;

            p.data = null;
            p.next = null;
        }
        //size == 0,front == null, rear=?
    }

    public String toString() {
        Node&lt;T&gt; p = front;
        int i = size;
        String result = getClass().getName() + ":";
        while (i-- != 0) {
            result += p.data + " ";
            p = p.next;
        }
        return result;
    }


}
</code></pre> 
 <pre class="kdocs-java"><code class="language-java">import java.util.*;


public class MGraph {
    public final static int INFINITY = Integer.MAX_VALUE;
    private GraphKind kind;
    private int vexNum, arcNum;
    private Object[] vexs;
    private int[][] arcs;

    public MGraph(GraphKind kind, int vexNum, int arcNum, Object[] vexs, int[][] arcs) {
        this.kind = kind;
        this.vexNum = vexNum;
        this.arcNum = arcNum;
        this.vexs = vexs;
        this.arcs = arcs;
    }

    public MGraph() {
        this(null, 0, 0, null, null);
    }

    public void createGraph() {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入图的类型");
        GraphKind kind = GraphKind.valueOf(sc.next());
        switch (kind) {
            case DG:
                createDG();
                return;
        }
    }

    private void createDG() {
        Scanner sc = new Scanner(System.in);
        System.out.println("输入顶点数，边数");
        vexNum = sc.nextInt();
        arcNum = sc.nextInt();
        vexs = new Object[vexNum];
        System.out.println("输入各个顶点");
        for (int v = 0; v &lt; vexNum; v++) {
            vexs[v] = sc.next();
        }
        arcs = new int[vexNum][vexNum];
        for (int v = 0; v &lt; vexNum; v++) {
            for (int u = 0; u &lt; vexNum; u++) {
                arcs[v][u] = 0;
            }
        }
        System.out.println("输入矩阵为1的各个边的两个顶点");
        for (int k=0; k &lt; arcNum; k++) {
            int v = locateVex(sc.next());
            int u = locateVex(sc.next());
            arcs[v][u] = 1;
        }
    }

    public int locateVex(Object vex){
        for(int v=0;v&lt;vexNum;v++)
            if(vexs[v].equals(vex))
                return v;
        return -1;
    }

    public Object getVex(int v){
        return vexs[v];
    }

    //求第一个邻接点
    /*
    //第一种写法因为忘记已经给出的函数locateVex()而导致代码冗杂
    public Object firstAdjVex(){
        Scanner sc=new Scanner(System.in);
        System.out.println("输入顶点");
        Object V=sc.next();
        int s;
        for (int v = 0; v &lt; vexNum; v++) {
            if(vexs[v].equals(V)) {
                try {
                    s=firstAdjVex(v);
                    return vexs[s];
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        return null;
    }
    */
    //第二种写法使用了函数locateVex()
    public Object firstAdjVex() {
        Scanner sc = new Scanner(System.in);
        System.out.println("输入顶点求第一个邻接点");
        Object V = sc.next();
        int v = locateVex(V);
        try {
            int s=firstAdjVex(v);
            return vexs[s];
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
    public int firstAdjVex(int v)throws Exception{
        if(v&lt;0&amp;&amp;v&gt;=vexNum)
            throw new Exception("不存在");
        for (int j=0;j&lt;vexNum;j++)
            if (arcs[v][j]==1)
                return j;
        return -1;
    }


    //求下一个邻接点
    public Object nextAdjVex() {
        Scanner sc = new Scanner(System.in);
        System.out.println("输入顶点及其一个邻接点求下一个邻接点");
        Object V = sc.next();
        Object W = sc.next();
        int v = locateVex(V);
        int w = locateVex(W);
        try {
            int s=nextAdjVex(v,w);
            return vexs[s];
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
    public int nextAdjVex(int v,int w)throws Exception{
        if (v&lt;0 &amp;&amp; v&gt;=vexNum)
            throw new Exception("不存在");
        for (int j=w+1;j&lt;vexNum;j++)
            if (arcs[v][j]==1)
                return j;
        return -1;
    }

    //度
    public int Degree(){
        Scanner sc = new Scanner(System.in);
        System.out.println("输入顶点求度");
        Object d = sc.next();
        int v = locateVex(d);
        return outDegree(v)+inDegree(v);
    }

    //出度
    public int outDegree() {
        Scanner sc = new Scanner(System.in);
        //System.out.println("输入顶点求出度");
        Object a = sc.next();
        int v = locateVex(a);
        return outDegree(v);
    }
    public int outDegree(int v) {
        int count = 0;
        for(int i = 0 ; i &lt; vexNum; i++) {
            if(arcs[v][i] != 0 )
                count++;
        }
        return count;
    }

    //入度
    public int inDegree() {
        Scanner sc = new Scanner(System.in);
        //System.out.println("输入顶点求入度");
        Object b = sc.next();
        int v = locateVex(b);
        return inDegree(v);
    }
    public int inDegree(int v) {
        int count = 0;
        for(int i = 0 ; i &lt; vexNum; i++) {
            if(arcs[i][v] != 0 )
                count++;
        }
        return count;
    }

    //广度优先遍历
    private static boolean[]visited;
    public static void BFSTraverse(MGraph G) {
        visited = new boolean[G.getVexNum()];
        for (int v=0;v&lt;G.getVexNum();v++){
            visited[v]=false;
        }
        for (int v=0;v&lt;G.getVexNum();v++){
            if(!visited[v])
                BFS(G,v);
        }
    }
    private static void BFS(MGraph G,int v){
        visited[v]=true;
        System.out.print(G.getVex(v).toString()+" ");
        LinkQueue Q=new LinkQueue();
        Q.offer(v);
        while(!Q.isEmpty()){
            int u=(Integer)Q.poll();
            try {
                for(int w=G.firstAdjVex(u); w&gt;=0; w=G.nextAdjVex(u,w))
                    if (visited[w]==false){
                        System.out.print(G.getVex(w).toString() +" ");
                        visited[w]=true;
                        Q.offer(w);
                    }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    //深度优先遍历
    public static void DFSTraverse(MGraph G){
        visited = new boolean[G.getVexNum()];
        for (int v=0;v&lt;G.getVexNum();v++){
            visited[v]=false;
        }
        for (int v=0;v&lt;G.getVexNum();v++){
            if(!visited[v])
                DFS(G,v);
        }
    }
    private static void DFS(MGraph G,int v) {
        visited[v] = true;
        System.out.print(G.getVex(v).toString() + " ");
        try {
            for(int w=G.firstAdjVex(v); w&gt;=0; w=G.nextAdjVex(v,w))
                if (visited[w]==false)
                    DFS(G,w);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public GraphKind getKind(){
        return kind;
    }

    public int[][] getArcs(){
        return arcs;
    }

    public Object[] getVexs(){
        return vexs;
    }

    public int getVexNum(){
        return vexNum;
    }

    public int getArcNum(){
        return arcNum;
    }

    //打印邻接矩阵检验
    public void print(){
        System.out.println("邻接矩阵为");
        for (int v = 0; v &lt; vexNum; v++) {
            for (int u = 0; u &lt; vexNum; u++) {
                System.out.print(arcs[v][u]+" ");
            }
            System.out.println();
        }
    }

    public void exchange(MGraph G) {
        int vexNum, arcNum;
        vexNum = G.getVexNum();
        arcNum = G.getArcNum();
        VNode[] vexs;
        vexs = new VNode[vexNum];
        for (int v = 0; v &lt; vexNum; v++) {
            vexs[v] = new VNode(G.vexs[v]);
        }
        for (int v = 0; v &lt; arcNum; v++) {
            for (int u = 0; u &lt; arcNum; u++) {
                if (arcs[v][u] == 1) {
                    ArcNode arc = new ArcNode(u);
                    arc.nextArc = vexs[v].firstArc;
                    vexs[v].firstArc = arc;
                }
            }
        }
        System.out.println("转换后的邻接表为");
        for(int u = 0; u &lt; vexNum; u++) {
            System.out.print(vexs[u].data+"-&gt;");
            for (ArcNode arc = vexs[u].firstArc; arc != null; arc = arc.nextArc) {
                System.out.print(arc.adjVex+"-&gt;");
            }
            System.out.println();
        }

    }

}</code></pre> 
 <pre class="kdocs-java"><code class="language-java">public class MGraphTest {
    public static void main(String[] args){
        MGraph t=new MGraph();
        t.createGraph();
        t.print();
        System.out.println();
        Object m=t.firstAdjVex();
        System.out.println("该结点的第一个邻接点的是"+m);
        Object n=t.nextAdjVex();
        System.out.println("下一个邻接点是"+n);
        System.out.println("此节点的度为"+t.Degree());
        System.out.println("广度优先遍历结果为：");
        MGraph.BFSTraverse(t);
        System.out.println();
        System.out.println("深度优先遍历结果为：");
        MGraph.DFSTraverse(t);
        System.out.println();
        t.exchange(t);
    }
}
</code></pre> 
 <pre class="kdocs-java"><code class="language-java">public class VNode {
    public Object data;
    public ArcNode firstArc;
    public VNode(){
        this(null,null);
    }
    public VNode(Object data){
        this(data,null);
    }
    public VNode(Object data,ArcNode firstArc){
        this.data=data;
        this.firstArc=firstArc;
    }
}
</code></pre> 
 <p style="">运行结果：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:246px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:243.90244%;height:0;"> 
    <img src="https://images2.imgbox.com/0f/bd/AuEsBreO_o.png" style="margin-left:;display:block;width:246px;margin-top:-243.90244%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:284px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:211.26761%;height:0;"> 
    <img src="https://images2.imgbox.com/31/53/0lnKUDMH_o.png" style="margin-left:;display:block;width:284px;margin-top:-211.26761%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h2 style="">五、问题讨论</h2> 
 <p style="text-align:null;">1、图的邻接矩阵和邻接表的存储结构各有什么特点？</p> 
 <p style="text-align:null;">邻接表特点:</p> 
 <p style="text-align:null;">(1)在无向图的邻接表中,顶点vi的度恰好等于该顶点的邻接表中边结点的个数;而在有向图中,顶点vi的邻接表中边结点的个数仅为该顶点的出度,若要求顶点的入度,则需遍历整个邻接表。有时为了便于求有向图中顶点的入度,可以通过建立一个有向图的逆邻接表得到,所谓逆邻接表,就是对图中的每个顶点vi建立一个链接以vi为终点的弧的边表。</p> 
 <p style="text-align:null;">(2)对于有n个顶点和e条边的无向图,其邻接表有n个顶点结点和2e个边结点,而对于有n个顶点和条弧的有向图,其邻接表有n个顶点结点和e个弧结点。显然,对于稀疏图,邻接表比邻接矩阵节省存储空间。</p> 
 <p style="text-align:null;">邻接矩阵特点:</p> 
 <p style="text-indent:1.4em;text-align:null;">用邻接矩阵存储图,虽然能很好地确定图中的任意两个顶点之间是否有边,但是不论是求任一顶点的度,还是查找任一顶点的邻接点,都需要访问对应的一行或一列中的所有的数据元素,其时间复杂度为O(n)。而要确定图中有多少条边,则必须按行对每个数据元素进行检测,花费的时间代价较大,其时间复杂度为O(n²)。从空间上看,不论图中的顶点之间是否有边,都要在邻接矩阵中保留存储空间,其空间复杂度为O(n²),空间效率较低,这也是邻接矩阵的局限性。</p> 
 <p style="text-align:null;">2、对于稀疏图和稠密图分别选择邻接矩阵和邻接表中的哪个存储更合适？</p> 
 <p style="padding-left:1.4em;text-align:null;">稀疏图邻接表更合适，稠密图邻接矩阵更合适。</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cd4e23d562c918a2bca7330c7a6f8546/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RSA, ElGama, ECC公钥算法的对比</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a41a35644238cd081f7082cc4853e42c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Bus Hound 工具抓取串口数据（PC端抓取USB转串口数据）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>