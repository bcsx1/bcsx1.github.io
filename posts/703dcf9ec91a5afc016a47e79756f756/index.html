<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统概念——期中复习 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统概念——期中复习" />
<meta property="og:description" content="文章目录 【第1章】 导论1.1 中断1.2 计算机系统体系结构1.3 操作系统体系结构 【第2章】 操作系统结构2.1 系统调用与系统程序 【第3章】 进程3.1 进程的概念、内存映像、PCB3.2 进程的状态图3.3 进程的上下文切换3.4 综合 【第4章】线程4.0 动机4.1 线程的结构4.2 多线程模型4.3 Amdal定律 【第5章】CPU调度【第6章】进程同步6.1 临界区问题6.2 Peterson算法6.3 硬件指令6.4 信号量6.5 实现经典同步问题 【第7章】死锁7.1 死锁的概念与特征7.2 死锁避免7.3 死锁检测7.4 死锁恢复 【第1章】 导论 1.1 中断 （1）中断处理的过程
当CPU中断时，它暂时停止正在做的事。然后通过中断向量间接调用中断处理子程序，子程序调用终端服务处理程序。接着CPU立即转到中断服务管理开始地址，开始执行。执行结束后，CPU重新执行被中断的运算。
（2）理解操作系统是由中断驱动的
除了初始化外，系统只能通过中断、陷阱、系统调用、异常、IO操作等才会再次进入内核模式。
1.2 计算机系统体系结构 （1）单处理器系统
有一个CPU能够执行一个通用指令集，包含用户进程的指令。绝大多数系统还包括其他特定目的的处理器。
（2）多处理器系统
非对称多处理
有“主-从关系”。一个主处理器控制系统，其他处理器向主处理器要任务或做预先定义的任务。
对称多处理
没有“主从关系”。每个处理器都要完成操作系统的所有任务。
1.3 操作系统体系结构 （1）多道程序系统
定义
通过组织进程使CPU总有一个进程可以执行，从而提高CPU的利用率。
思想
操作系统将多个进程保存在内存中，并从中选择一个进程来执行。当一个进程需要等待时，会切换到另一个进程。
优点
① 资源利用率高：多道程序共享计算机资源
② 吞吐量大：CPU和其他资源保持忙碌状态。
（2）分时系统
定义
分时系统是多道程序系统的延申。虽然CPU还是通过进程的切换来执行多个进程，但是由于切换频率很高，用户可以在程序运行期间预期交互。
【第2章】 操作系统结构 2.1 系统调用与系统程序 （1）理解系统调用、API、系统调用接口、用户程序、系统程序
系统调用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/703dcf9ec91a5afc016a47e79756f756/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-30T23:33:56+08:00" />
<meta property="article:modified_time" content="2021-11-30T23:33:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统概念——期中复习</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">【第1章】 导论</a></li><li><ul><li><a href="#11__2" rel="nofollow">1.1 中断</a></li><li><a href="#12__10" rel="nofollow">1.2 计算机系统体系结构</a></li><li><a href="#13__19" rel="nofollow">1.3 操作系统体系结构</a></li></ul> 
  </li><li><a href="#2__33" rel="nofollow">【第2章】 操作系统结构</a></li><li><ul><li><a href="#21__34" rel="nofollow">2.1 系统调用与系统程序</a></li></ul> 
  </li><li><a href="#3__51" rel="nofollow">【第3章】 进程</a></li><li><ul><li><a href="#31_PCB_52" rel="nofollow">3.1 进程的概念、内存映像、PCB</a></li><li><a href="#32__70" rel="nofollow">3.2 进程的状态图</a></li><li><a href="#33__77" rel="nofollow">3.3 进程的上下文切换</a></li><li><a href="#34__85" rel="nofollow">3.4 综合</a></li></ul> 
  </li><li><a href="#4_91" rel="nofollow">【第4章】线程</a></li><li><ul><li><a href="#40__92" rel="nofollow">4.0 动机</a></li><li><a href="#41__98" rel="nofollow">4.1 线程的结构</a></li><li><a href="#42__108" rel="nofollow">4.2 多线程模型</a></li><li><a href="#43_Amdal_136" rel="nofollow">4.3 Amdal定律</a></li></ul> 
  </li><li><a href="#5CPU_145" rel="nofollow">【第5章】CPU调度</a></li><li><a href="#6_147" rel="nofollow">【第6章】进程同步</a></li><li><ul><li><a href="#61__148" rel="nofollow">6.1 临界区问题</a></li><li><a href="#62_Peterson_159" rel="nofollow">6.2 Peterson算法</a></li><li><a href="#63__177" rel="nofollow">6.3 硬件指令</a></li><li><a href="#64__197" rel="nofollow">6.4 信号量</a></li><li><a href="#65__210" rel="nofollow">6.5 实现经典同步问题</a></li></ul> 
  </li><li><a href="#7_215" rel="nofollow">【第7章】死锁</a></li><li><ul><li><a href="#71__216" rel="nofollow">7.1 死锁的概念与特征</a></li><li><a href="#72__236" rel="nofollow">7.2 死锁避免</a></li><li><a href="#73__256" rel="nofollow">7.3 死锁检测</a></li><li><a href="#74__258" rel="nofollow">7.4 死锁恢复</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>【第1章】 导论</h2> 
<h3><a id="11__2"></a>1.1 中断</h3> 
<p><strong>（1）中断处理的过程</strong><br> 当CPU中断时，它暂时停止正在做的事。然后通过中断向量间接调用中断处理子程序，子程序调用终端服务处理程序。接着CPU立即转到中断服务管理开始地址，开始执行。执行结束后，CPU重新执行被中断的运算。</p> 
<p><strong>（2）理解操作系统是由中断驱动的</strong><br> <img src="https://images2.imgbox.com/63/85/rP2TGmu3_o.png" alt="在这里插入图片描述"><br> <mark>除了初始化外，系统只能通过中断、陷阱、系统调用、异常、IO操作等才会再次进入内核模式。</mark></p> 
<h3><a id="12__10"></a>1.2 计算机系统体系结构</h3> 
<p><strong>（1）单处理器系统</strong><br> <mark>有一个CPU能够执行一个通用指令集</mark>，包含用户进程的指令。绝大多数系统还包括其他特定目的的处理器。<br> <strong>（2）多处理器系统</strong><br> <strong>非对称多处理</strong><br> 有“主-从关系”。一个主处理器控制系统，其他处理器向主处理器要任务或做预先定义的任务。<br> <strong>对称多处理</strong><br> 没有“主从关系”。每个处理器都要完成操作系统的所有任务。</p> 
<h3><a id="13__19"></a>1.3 操作系统体系结构</h3> 
<p><strong>（1）多道程序系统</strong><br> <strong>定义</strong><br> <mark>通过组织进程使CPU总有一个进程可以执行</mark>，从而提高CPU的利用率。<br> <strong>思想</strong><br> 操作系统将多个进程<mark>保存</mark>在内存中，并从中<mark>选择</mark>一个进程来<mark>执行</mark>。当一个进程需要<mark>等待</mark>时，会<mark>切换</mark>到另一个进程。<br> <strong>优点</strong><br> ① 资源利用率高：多道程序共享计算机资源<br> ② 吞吐量大：CPU和其他资源保持忙碌状态。</p> 
<p><strong>（2）分时系统</strong><br> <strong>定义</strong><br> 分时系统是多道程序系统的延申。虽然CPU还是通过进程的切换来执行多个进程，但是由于切换频率很高，用户可以在程序运行期间预期交互。</p> 
<h2><a id="2__33"></a>【第2章】 操作系统结构</h2> 
<h3><a id="21__34"></a>2.1 系统调用与系统程序</h3> 
<p><strong>（1）理解系统调用、API、系统调用接口、用户程序、系统程序</strong><br> <strong>系统调用</strong><br> 提供了操作系统提供的服务。允许用户请求操作系统的服务。由OS内核提供接口。<br> <strong>应用程序接口API</strong><br> 一系列适用于应用程序员的函数，包括传递给每个函数的参数及返回值。<br> 后台组成API的函数为实际的系统调用<br> <strong>系统调用接口</strong><br> 程序设计语言的运行时支持系统（与编译器一起的预先构造的函数库）提供了系统调用接口，作为应用程序与操作系统的系统调用的链接</p> 
<p><strong>操作系统如何处理一个调用系统调用的用户应用</strong><br> <mark>用户应用程序通过API调用系统调用接口</mark>，系统调用接口维护了一个与系统调用相关的列表索引，通过列表调用相应的系统调用。<br> （用户程序 --&gt; API --&gt; 系统调用接口 --&gt; 系统调用）</p> 
<p><strong>系统程序</strong><br> 提供了程序开发和执行的环境。同时提供了基本的功能，用户在解决公共问题时不用自己写程序了。</p> 
<h2><a id="3__51"></a>【第3章】 进程</h2> 
<h3><a id="31_PCB_52"></a>3.1 进程的概念、内存映像、PCB</h3> 
<p>此部分主要值得是考察进程的概念部分<br> <strong>（1）进程的定义</strong><br> 进程是运行的程序实例</p> 
<p><strong>（2）进程的内存映像</strong><br> <strong>组成</strong><br> 由文本段、数据段、堆栈组成<br> <strong>作用</strong><br> ① 文本段：保存程序代码<br> ② 数据段：保存全局变量<br> ③ 栈：保存临时数据，局部变量、函数参数、返回地址<br> ④ 堆：进程运行期间动态分配的内存</p> 
<p><strong>（3）进程控制块</strong><br> <strong>组成</strong><br> 进程的状态、编号、寄存器值、内存界限、打开文件列表等。</p> 
<h3><a id="32__70"></a>3.2 进程的状态图</h3> 
<p>进程的状态图要牢记，并理解进程的状态转换的原理。<br> <strong>（1）进程的状态与状态图</strong><br> <img src="https://images2.imgbox.com/aa/1b/28X4eEpA_o.png" alt="在这里插入图片描述"><br> <strong>（2）如何实现进程状态的切换？</strong><br> 通过<mark>中断、系统调用</mark>，切换到内核模式，从而切换进程的状态。</p> 
<h3><a id="33__77"></a>3.3 进程的上下文切换</h3> 
<p><strong>（1）什么是上下文切换？为什么要进行上下文切换？</strong><br> ① 当CPU切换另一个进程时，需要保存当前进程的状态并恢复新进程的状态<br> ② 一个事件完成可能需要多次进程切换，而进程间的信息不同，所以要上下文切换。</p> 
<p><strong>（2）上下文切换的步骤</strong><br> <mark>将旧进程的上下文保存在PCB中，并且装入经调度将执行的新进程的上下文。</mark><br> <img src="https://images2.imgbox.com/d2/84/gh0At0oB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="34__85"></a>3.4 综合</h3> 
<p><strong>（1）结合PCB，状态图，上下文切换描述进程切换的过程</strong><br> （状态转换 + 上下文切换）<br> ① 通过中断、系统调用，进入内核模式，然后切换进程的状态。<br> ② 将旧进程的上下文保存在PCB中，装入经调度将要执行的新进程的上下文信息。</p> 
<h2><a id="4_91"></a>【第4章】线程</h2> 
<h3><a id="40__92"></a>4.0 动机</h3> 
<p><strong>（1）多线程的优点</strong><br> ① <mark>响应度高</mark>：多线程即使<mark>部分阻塞或执行较冗长</mark>的操作时，程序仍能继续执行。<br> ② <mark>资源共享</mark>：线程默认共享其所属进程的内存和资源<br> ③ <mark>经济</mark>：创建和切换进程开销较大，因为资源共享，创建和切换线程更为经济<br> ④ <mark>多处理器体系结构的利用</mark>：使每个进程能并行运行在不同的处理器上。</p> 
<h3><a id="41__98"></a>4.1 线程的结构</h3> 
<p>这部分注意线程与进程结构上的区别，以及线程与进程的联系<br> <strong>（1）线程的内存结构</strong><br> 由<mark>线程ID，寄存器，独立的栈组成</mark>。<br> 与所属同一进程的其他线程<mark>共享代码段、数据段、堆</mark>等操作系统资源。<br> <img src="https://images2.imgbox.com/fd/85/yu4FcZMs_o.png" alt="在这里插入图片描述"><br> <strong>（2）线程与进程的关系</strong><br> ① 线程和进程都是函数，线程的所有代码都保存在所属进程的代码段中。<br> ② 线程的响应度高且更为经济</p> 
<h3><a id="42__108"></a>4.2 多线程模型</h3> 
<p>注意用户线程与内核线程的区别、各种多线程模型的定义及其优缺点（并发性、线程数量）<br> <strong>（1）用户线程与内核线程的区别</strong><br> ① 用户线程<mark>不受内核支持，也不受内核管理</mark>。通过用户级线程库实现<br> ② 内核线程受操作系统直接支持和管理。内核在内核空间实现了线程的创建、调度和管理</p> 
<p><strong>（2）多对一模型</strong><br> <strong>定义</strong><br> 将多个用户级线程映射到一个内核线程<br> <strong>优点</strong><br> <mark>执行效率高</mark>：线程管理由线程库在用户空间进行<br> <strong>缺点</strong><br> <mark>并发性差</mark>：一次只有一个线程能访问内核。当此线程执行了阻塞系统调用，则整个进程会阻塞。</p> 
<p><strong>（3）一对一模型</strong><br> <strong>定义</strong><br> 将每个用户线程映射到一个内核线程<br> <strong>优点</strong><br> <mark>高并发性</mark>：当一个线程执行阻塞系统调用时，其他线程能继续执行<br> <mark>缺点</mark>：线程数量受限</p> 
<p><strong>（4）多对多模型</strong><br> <strong>定义</strong><br> 多路复用了许多用户线程到<u>同样数量或更小数量</u>的内核线程上<br> <strong>优点</strong><br> ① <mark>高并发性</mark><br> ② <mark>运行创建多个用户线程</mark></p> 
<h3><a id="43_Amdal_136"></a>4.3 Amdal定律</h3> 
<p>理解Amdal定律<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          S 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
         
         
           1 
          
          
          
            p 
           
          
            + 
           
           
            
            
              1 
             
            
              − 
             
            
              p 
             
            
           
             n 
            
           
          
         
        
       
         S(n)=\frac{1}{p+\frac{1-p}{n}} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.45366em; vertical-align: -1.13222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.21278em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.897216em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.44611em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.13222em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span><br> 其中，<mark>p是串行工作部分比例，n是并行节点个数。</mark><br> ① 随着并行节点个数增加，性能会有所提升。<br> ② 性能提升有上限，上限值为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          1 
         
        
          p 
         
        
       
      
        \frac{1}{p} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.32622em; vertical-align: -0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.845108em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.481108em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p> 
<h2><a id="5CPU_145"></a>【第5章】CPU调度</h2> 
<h2><a id="6_147"></a>【第6章】进程同步</h2> 
<h3><a id="61__148"></a>6.1 临界区问题</h3> 
<p>这部分主要注意临界区的三个条件、临界区的特点。<br> <strong>（1）临界区的三个条件</strong><br> ① <mark>互斥</mark>：当进程在其临界区内执行，其他进程都不能在其临界区内执行<br> ② <mark>有空让进</mark>：没有进程在临界区内执行时，允许不在剩余区内执行的进程在临界区内执行<br> ③ <mark>有限等待</mark>：从一个进程请求进入临界区，到请求被允许为止，其他进程允许进入其临界区的次数有限</p> 
<p><strong>（2）临界区的特点</strong><br> ① 每个进程必须请求进入其临界区<br> ② 当进程在其临界区内执行，其他进程都不能在其临界区内执行</p> 
<h3><a id="62_Peterson_159"></a>6.2 Peterson算法</h3> 
<p>这部分需要理解Peterson的算法思路，并能结合临界区的三个条件分析分析改变算法是否正确<br> <strong>（1）Peterson算法</strong><br> Peterson是<mark>基于程序指令顺序执行</mark>的算法。由于现代计算机体系架构执行<mark>基本机器语言指令</mark>（编译器、处理器会进行<mark>指令重排</mark>，导致算法出错），Peterson算法在这类机器上不能确保正确运行。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	turn <span class="token operator">=</span> j<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> j<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> flag<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// 临界区</span>
	flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token comment">// 剩余区</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>（2）flag[i]和turn=j语句可以交换顺序吗？</strong><br> 不可以交换。如图所示：会导致A, B 两个同时进入临界区，不满足互斥条件。<br> <img src="https://images2.imgbox.com/32/3f/6yM8VziH_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="63__177"></a>6.3 硬件指令</h3> 
<p>需要关注为什么多处理系统不能采取单处理器系统的中断屏蔽方式解决临界区问题。还需理解常见的两种硬件指令的互斥实现、互斥+有限等待实现。<br> <strong>（1）为什么多处理系统不能采取单处理器系统的中断屏蔽方式解决临界区问题</strong><br> ① 多处理器上<mark>消息传递</mark>给所有处理器，这会导致每次<mark>进入临界区延迟</mark>，而<mark>降低系统效率</mark>。<br> ② 影响了系统时钟</p> 
<p><strong>（2）使用TestAndSet指令实现互斥和有限等待</strong><br> <strong>定义</strong><br> <img src="https://images2.imgbox.com/fd/19/li47ANth_o.png" alt="在这里插入图片描述"><br> <strong>互斥实现</strong><br> <img src="https://images2.imgbox.com/46/e4/CxLF830e_o.png" alt="在这里插入图片描述"><br> <strong>有限等待实现</strong><br> <img src="https://images2.imgbox.com/3b/5b/TITGlPJJ_o.png" alt="在这里插入图片描述"><br> <strong>（3）使用compare_and_set指令实现互斥、有限等待</strong><br> <strong>定义</strong><br> <img src="https://images2.imgbox.com/61/14/IIphp1V4_o.png" alt="在这里插入图片描述"><br> <strong>互斥实现</strong><br> <img src="https://images2.imgbox.com/27/6f/jQ6ns81J_o.png" alt="在这里插入图片描述"><br> <strong>有限等待实现</strong><br> <img src="https://images2.imgbox.com/6b/98/wdPAziF9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="64__197"></a>6.4 信号量</h3> 
<p>需要关注两种信号量的基本实现（互斥锁）与为避免盲等的实现方式<br> <strong>（1）基本实现</strong><br> <img src="https://images2.imgbox.com/5f/07/dhNQgJ2p_o.png" alt="在这里插入图片描述"><br> 当一个进程进入临界区，其他试图进入其临界区的进程进入连续的循环（盲等）。<br> <strong>（2）避免盲等的实现</strong><br> 执行wait()操作时，发现信号值不为正，则必须等待。然而进程不是盲等而是<mark>阻塞自己</mark>，并放入相关的<mark>等待队列</mark>中。可以在其他进程执行signal()操作后重新执行，通过wakeup()唤醒自己。<br> <strong>信号量结构</strong><br> <img src="https://images2.imgbox.com/06/3b/ODrPgxiy_o.png" alt="在这里插入图片描述"><br> <strong>wait()</strong><br> <img src="https://images2.imgbox.com/12/42/R2Vg0uZx_o.png" alt="在这里插入图片描述"><br> <strong>signal()</strong><br> <img src="https://images2.imgbox.com/de/80/pdSWoQqy_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="65__210"></a>6.5 实现经典同步问题</h3> 
<p><strong>（1）有限等待问题</strong><br> <img src="https://images2.imgbox.com/00/5c/dFIHG1Nt_o.png" alt="在这里插入图片描述"><br> <strong>（2）第一读者问题</strong><br> <img src="https://images2.imgbox.com/e3/6c/d7DZf8J5_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="7_215"></a>【第7章】死锁</h2> 
<h3><a id="71__216"></a>7.1 死锁的概念与特征</h3> 
<p>注意死锁产生的四个必要条件，以及资源分配图中死锁的判断。<br> <strong>（1）死锁的定义</strong><br> 如果<mark>一组进程中的每个进程都在等待一个事件</mark>，而这个<mark>事件只能由这一组进程中的另一进程引起</mark>，那么这组进程处于死锁状态</p> 
<p><strong>（2）死锁产生的必要条件</strong><br> ① 互斥：至少有一个资源处于非共享模式，即一次只能一个进程使用<br> ② 占有并等待：一个进程<mark>至少占有一个资源，并等待另一资源</mark>。这一资源被其他进程占有<br> ③ 非抢占：资源不能被抢占<br> ④ 循环等待</p> 
<p><strong>（3）资源分配图中死锁的判断</strong><br> ① 如果分配图<mark>没有环</mark>，则系统<mark>没有进程死锁</mark><br> ② 如果分配图<mark>有环</mark>，那么可能存在死锁<br> <strong>情况1</strong>：每个资源类型刚好有一个实例<br> 有环意味着出现死锁。环是死锁存在的<mark>充分必要条件</mark><br> <strong>情况2</strong>：每个资源有多个实例<br> 环是死锁存在的<mark>必要条件</mark>。<br> 当进程集合处于循环等待时，陷入死锁状态。否则，进程可以释放资源打破环。</p> 
<h3><a id="72__236"></a>7.2 死锁避免</h3> 
<p>注意死锁与不安全状态的关系，并理解资源分配图法、银行家算法实现死锁避免<br> <strong>（1）死锁与不完全状态间的关系</strong><br> ① <mark>死锁是不安全状态。不安全状态可能导致发生死锁</mark><br> （死锁 ∈ 不安全状态）<br> ② 在不安全状态下，操作系统不能阻止进程以会导致死锁的方式申请资源。</p> 
<p><strong>（2）资源分配图算法</strong><br> <strong>应用场景</strong><br> 每个资源类型只有一个实例的资源分配系统</p> 
<p><strong>需求边</strong><br> 引入一新类型的边“需求边”，需求边<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          P 
         
        
          i 
         
        
       
         → 
        
        
        
          R 
         
        
          j 
         
        
       
      
        P_i \to R_j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.969438em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.00773em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span>表示<mark>进程i在将来某个时候申请资源j</mark>。在资源分配图中用虚线表示</p> 
<p><strong>算法理解</strong><br> 采用环检测算法，检测安全性<br> ① 如果没有环存在，系统分配使系统处于安全状态。<br> ② 如果<mark>有环</mark>，系统分配会使系统<mark>处于不安全状态</mark>。<br> <img src="https://images2.imgbox.com/ba/13/Us5gcpwN_o.png" alt="在这里插入图片描述"><br> <strong>（3）银行家算法</strong></p> 
<h3><a id="73__256"></a>7.3 死锁检测</h3> 
<h3><a id="74__258"></a>7.4 死锁恢复</h3> 
<p>了解死锁恢复的两种常见方式<br> <strong>（1）死锁恢复的常用方式</strong><br> 1.进程终止<br> ① 终止所有死锁进程<br> ② 一次只终止一个进程直到死锁被打破<br> 2.资源抢占<br> （需要处理的问题选择一个牺牲品–&gt;回滚–&gt;饥饿）</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3bfe622f4bcdd6a833fdcc6434929fba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Educoder头歌数据结构-二叉排序树的查找</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0982ac406b6e84a7abbf8b614f416bd0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">统计字符串中数字字符的个数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>