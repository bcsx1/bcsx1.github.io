<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux GPIO 驱动 （gpiolib） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux GPIO 驱动 （gpiolib）" />
<meta property="og:description" content="1.前情 基于 linux gpio 会在 /sys/class/gpio 目录下会生成 export, unexport 文件，当然也有 gpiochipx 文件，gpiochipx 是对引脚的管理，如某一个 chip 可能控制着一定数量的引脚，在相应目录下 ngpio 是控制的数量。 执行 echo 4 &gt; /sys/class/gpio/export 的时候会在 /sys/class/gpio 目录下生成 gpio4 目录，在这个目录下会有 如 value, edge, direction 等相关文件，value 是当前值， edge 是引脚触发方式，direction 是引脚输入，输出方式。但是 echo 之后如何产生这个的呢。
过程扫描
在一开始的初始化过程中有函数 gpiolib_dev_init 被导出为 core_initcall (gpio/gpiolib.c)
此函数调用 bus_register 注册 gpio ，对应生成 /sys/bus/gpio 目录
再调用 alloc_chrdev_region
再进行gpiochip 的设置 gpiochip_setup_devs
这会对总数量 的 gpiochip 进行处理，对每个调用 gpiochip_sysfs_register，文件到了 gpiolib-sysfs.c 中
调用 device_create_wtih_groups来创建 gpiochip%d
此函数对应的参数为 gpio_class 即一个 class 类" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/bccd722844fec01cecf6fbd11e23c9af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-13T00:00:05+08:00" />
<meta property="article:modified_time" content="2021-04-13T00:00:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux GPIO 驱动 （gpiolib）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1_0"></a>1.前情</h3> 
<p>基于 linux gpio 会在 /sys/class/gpio 目录下会生成 export, unexport 文件，当然也有 gpiochipx 文件，gpiochipx 是对引脚的管理，如某一个 chip 可能控制着一定数量的引脚，在相应目录下 ngpio 是控制的数量。 执行 echo 4 &gt; /sys/class/gpio/export 的时候会在 /sys/class/gpio 目录下生成 gpio4 目录，在这个目录下会有 如 value, edge, direction 等相关文件，value 是当前值， edge 是引脚触发方式，direction 是引脚输入，输出方式。但是 echo 之后如何产生这个的呢。</p> 
<p>过程扫描<br> 在一开始的初始化过程中有函数 gpiolib_dev_init 被导出为 core_initcall (gpio/gpiolib.c)<br> 此函数调用 bus_register 注册 gpio ，对应生成 /sys/bus/gpio 目录<br> 再调用 alloc_chrdev_region<br> 再进行gpiochip 的设置 gpiochip_setup_devs<br> 这会对总数量 的 gpiochip 进行处理，对每个调用 gpiochip_sysfs_register，文件到了 gpiolib-sysfs.c 中<br> 调用 device_create_wtih_groups来创建 gpiochip%d<br> 此函数对应的参数为 gpio_class 即一个 class 类<br> 此 class 定义的名称是 gpio, 同时定义了 attr<br> attr 包括 export - export _store, unexport - unexport_store<br> 前者是属性名，后者是函数<br> 也就是 echo 动作为触发 export_store 函数<br> 此函数 调用 gpio_request 准备引脚<br> 再调用 gpiod_export 在此函数中调用 device_create_with_groups 来创建 gpio%d，以及其它事项；</p> 
<p>、简述</p> 
<p>2、Gpiolib 相关数据结构分析</p> 
<p>2.1 gpio_chip 结构</p> 
<p>2.2 gpio_desc 结构</p> 
<p>2.3 gpio_device 结构</p> 
<p>3、Gpiolib 对接芯片底层</p> 
<p>3.1、注册 GPIO 资源（gpiochip_add）</p> 
<p>3.2、gpiochip_add_data_with_key</p> 
<p>4、Gpiolib 为其他驱动提供的 APIs</p> 
<p>4.1、gpio_request</p> 
<p>4.2、gpio_direction_input/gpio_direction_output</p> 
<p>4.3、gpiod_set_value/gpiod_get_value</p> 
<h3><a id="1_43"></a>1、简述</h3> 
<p>GPIO 资源是相对来说较为简单，而且比较通用（比如 LED 灯），而 Linux 的 GPIO 驱动属于 Linux Driver 中较为容易上手的部分，但是简单归简单，在 Linux 系统中，要使用 GPIO 资源，还是需要了解一些内容。</p> 
<p>Linux Kernel 中对 GPIO 资源进行了抽象，抽象出一个叫做 Gpiolib 的东东，这个东东作为 GPIO 资源的管理核心存在：<br> <img src="https://images2.imgbox.com/5a/a0/HoKp0q7I_o.png" alt="在这里插入图片描述"><br> 中间层是 Gpiolib，用于管理系统中的 GPIO。Gpiolib 汇总了 GPIO 的通用操作，根据 GPIO 的特性，Gpiolib 对上（其他 Drivers）提供的一套统一通用的操作 GPIO 的软件接口，屏蔽了不同芯片的具体实现。对下，Gpiolib 提供了针对不同芯片操作的一套 framework，针对不同芯片，只需要实现 Specific Chip Driver ，然后使用 Gpiolib 提供的注册函数，将其挂接到 Gpiolib 上，这样就完成了这一套东西。</p> 
<p>对于其他驱动来说，比如 LED 灯驱动，就需要用到通用的 Gpiolib 的函数来进行 I/O 口的操作。</p> 
<h3><a id="2Gpiolib__55"></a>2、Gpiolib 相关数据结构分析</h3> 
<p>先分析数据结构，Gpiolib 其实就是围绕几个数据结构在做文章，数据结构以及抽象层次清楚了，代码自然很快。</p> 
<p>数据结构主要定义在 include/linux/gpio/driver.h 和 /drivers/gpio/gpiolib.h 中</p> 
<p>首先看一个数据结构，叫 struct gpio_chip （include/linux/gpio/driver.h）：<br> struct gpio_chip {<!-- --><br> const char *label;<br> struct gpio_device *gpiodev;<br> struct device *parent;<br> struct module *owner;</p> 
<pre><code>int			(*request)(struct gpio_chip *chip,
					unsigned offset);
void			(*free)(struct gpio_chip *chip,
					unsigned offset);
int			(*get_direction)(struct gpio_chip *chip,
					unsigned offset);
int			(*direction_input)(struct gpio_chip *chip,
					unsigned offset);
int			(*direction_output)(struct gpio_chip *chip,
					unsigned offset, int value);
int			(*get)(struct gpio_chip *chip,
					unsigned offset);
int			(*get_multiple)(struct gpio_chip *chip,
					unsigned long *mask,
					unsigned long *bits);
void			(*set)(struct gpio_chip *chip,
					unsigned offset, int value);
void			(*set_multiple)(struct gpio_chip *chip,
					unsigned long *mask,
					unsigned long *bits);
int			(*set_config)(struct gpio_chip *chip,
				      unsigned offset,
				      unsigned long config);
int			(*to_irq)(struct gpio_chip *chip,
					unsigned offset);

void			(*dbg_show)(struct seq_file *s,
					struct gpio_chip *chip);

int			(*init_valid_mask)(struct gpio_chip *chip);

int			base;
u16			ngpio;
const char		*const *names;
bool			can_sleep;
</code></pre> 
<p>…</p> 
<p>};</p> 
<p>gpio_chip 这个数据结构一看，很多函数指针结构，明眼人秒懂，此结构是为了抽象 GPIO 的所有操作，同时适配不同芯片的一个 common 的结构，所以，这个结构是要开出去给其他芯片进行特定的操作赋值的，比如你是 Qcom 的芯片，那么你需要实现你的这些 gpio_chip 的内容</p> 
<p>2.1 gpio_chip 结构<br> 一般的，在一个芯片中，针对所有的 I/O 口都会有配置，默认状态有些是 I/O 口全部默认 GPIO 输入（稳当）。一般芯片会提供管脚复用的功能（后期的 Linux 版本中，使用 pin control 来抽象），要使用 GPIO ，则首先需要配置他为 GPIO 功能，而不是其他的服用功能。</p> 
<p>而针对 GPIO 呢，有一些通用的特性，比如设置 GPIO 的方向，读 GPIO 的电平（输入的时候），写 GPIO 的电平（输出的时候），GPIO 作为外部中断输入，等等。</p> 
<p>gpio_chip 的抽象，其实是对 GPIO 一组 Bank 的抽象，通常在硬件上，一个芯片对 IO 口来说，分为了很多个 Bank，每个 Bank 分为了 N 组 GPIO。</p> 
<p>比如：1 个 SoC 将 I/O 分为了 4 个 Bank：</p> 
<p>Bank 1：GPIOA ～ GPIOB</p> 
<p>Bank 2：GPIOC ～ GPIOD</p> 
<p>Bank 3：GPIOE ～ GPIOF</p> 
<p>Bank 4：GPIOG ～ GPIOH</p> 
<p>然鹅，每个 Bank 都有 N 组寄存器来表示 GPIO 的操作，比如：</p> 
<p>Bank 1 中，针对 GPIO A：</p> 
<p>GPIOA_CFG 来表示对 GPIO A 的配置</p> 
<p>GPIOA_PULL 来表示对 GPIO A 的上下拉的配置</p> 
<p>GPIOA_DIR 来表示对 GPIO A 配置成为输入或者输出</p> 
<p>GPIOA_DATA 来表示 GPIO A 设置为输出的时候设置为高低或者输入的时候读高低</p> 
<p>当然，Bank 1 中 针对 GPIO B，也是一样的操作：</p> 
<p>GPIOB_CFG 来表示对 GPIO B 的配置</p> 
<p>GPIOB_PULL 来表示对 GPIO B 的上下拉的配置</p> 
<p>GPIOB_DIR 来表示对 GPIO B 配置成为输入或者输出</p> 
<p>GPIOB_DATA 来表示 GPIO B 设置为输出的时候设置为高低或者输入的时候读高低</p> 
<p>上面说的是一个 Bank 的情况，那么芯片有好几个 Bank，所以它们都是类似的，这里不在赘述。</p> 
<p>所以整体结构是如下所示（这里只是打个比方，有的芯片 Bank 很多，寄存器也很多）：<br> <img src="https://images2.imgbox.com/57/a8/KUcDFwSS_o.png" alt="在这里插入图片描述"><br> Linux Driver Gpiolib 对他们的抽象，使用 gpio_chip 对应了一组 Bank 描述，比如 Bank ·1，用一个 gpio_chip 来抽象</p> 
<p><img src="https://images2.imgbox.com/c6/ac/0wtrcVVv_o.png" alt="在这里插入图片描述"><br> 那么多个 Bank ，就用指针，或者数组来表示咯。当然这里可能说得有点不准确，gpio_chip 只是抽象了一组 Bank 的统一的接口而已。</p> 
<p>那么对于一颗芯片底层来说，需要根据芯片手册 Datasheet，来实现这些结构的接口。</p> 
<p>2.2 gpio_desc 结构<br> 既然系统分为多个 Bank，每个 Bank 又由几组组成，那么每个 GPIO 实体就由一个 gpio_desc 来描述：<br> struct gpio_desc {<!-- --><br> struct gpio_device <em>gdev;<br> unsigned long flags;<br> /</em> flag symbols are bit numbers <em>/<br> #define FLAG_REQUESTED 0<br> #define FLAG_IS_OUT 1<br> #define FLAG_EXPORT 2 /</em> protected by sysfs_lock <em>/<br> #define FLAG_SYSFS 3 /</em> exported via /sys/class/gpio/control <em>/<br> #define FLAG_ACTIVE_LOW 6 /</em> value has active low <em>/<br> #define FLAG_OPEN_DRAIN 7 /</em> Gpio is open drain type <em>/<br> #define FLAG_OPEN_SOURCE 8 /</em> Gpio is open source type <em>/<br> #define FLAG_USED_AS_IRQ 9 /</em> GPIO is connected to an IRQ <em>/<br> #define FLAG_IRQ_IS_ENABLED 10 /</em> GPIO is connected to an enabled IRQ <em>/<br> #define FLAG_IS_HOGGED 11 /</em> GPIO is hogged <em>/<br> #define FLAG_TRANSITORY 12 /</em> GPIO may lose value in sleep or reset */</p> 
<pre><code>/* Connection label */
const char		*label;
/* Name of the GPIO */
const char		*name;
</code></pre> 
<p>};<br> 这个结构比较简单，可以看到，他包含了一个 gpio_device 的结构和 flag，以及 lable 和 name；</p> 
<p>gdev 指针指向了这个 gpio_desc 所属的 gpio_device（马上描述），flag 代表了这个 GPIO 的属性状态；<br> <img src="https://images2.imgbox.com/84/2c/OW7V4hlr_o.png" alt="在这里插入图片描述"><br> 看起来 gpio_chip 和 gpio_desc 应该是包含关系，但是 Kernel 中并没有直接将其两个结构联系上，而是通过另外一个结构将其联系在一起，这个结构就是 gpio_device。</p> 
<p>2.3 gpio_device 结构<br> gpio_device 应该算是大内总管了（最新的内核有，Linux 3 版本的内核没有这个），如果说 gpio_chip 是对一个 Bank 的 GPIO 的硬件的具体抽象的话，那么 gpio_device 就是软件层面上对一个 Bank 的 GPIO 进行管理的单元，它的数据结构是：</p> 
<p>struct gpio_device {<!-- --><br> int id;<br> struct device dev;<br> struct cdev chrdev;<br> struct device *mockdev;<br> struct module *owner;<br> struct gpio_chip *chip;<br> struct gpio_desc *descs;<br> int base;<br> u16 ngpio;<br> const char *label;<br> void *data;<br> struct list_head list;</p> 
<p>#ifdef CONFIG_PINCTRL<br> /*<br> * If CONFIG_PINCTRL is enabled, then gpio controllers can optionally<br> * describe the actual pin range which they serve in an SoC. This<br> * information would be used by pinctrl subsystem to configure<br> * corresponding pins for gpio usage.<br> */<br> struct list_head pin_ranges;<br> #endif<br> };<br> 在这个 gpio_device 结构中，包含了 gpio_chip（对接芯片的操作集），gpio_desc（一些 GPIO 的描述）；这个结构贯穿了整个 Gpiolib，因为 gpio_device 代表的是一个 Bank，一般的 GPIO 有多个 Bank，所以 Kernel 中，对这 gpio_device 的组织是由一个 gpio_devices 的链表构成（此处是多个 device，所以后面加了 s），在 gpiolib.c：</p> 
<p>LIST_HEAD(gpio_devices);<br> <img src="https://images2.imgbox.com/3d/e7/DdmhF7qz_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3Gpiolib__221"></a>3、Gpiolib 对接芯片底层</h3> 
<p>先聊聊 Gpiolib 是怎么对接到底层实际的驱动的。在前面的 2.1 部分讲过，底层需要对接的，其实对接的部分只有那些通用的操作，其实也就是 gpio_chip 这个玩意，所以，对接底层的部分，主要关心的是这个结构体，并且对这个结构体进行赋值的过程。</p> 
<p>在底层对接到 Gpiolib 的时候，主要是对 gpio_chip 进行实现，然后调用 gpiochip_add 的接口，向 Gpiolib 注册你的 GPIO 。</p> 
<p>实现的过程，主要是根据芯片手册，实现对应的 GPIO 的操作，也就是说，把寄存器操作编程成为函数，对接到这个 gpio_chip 结构体上。</p> 
<p>打个比方，对应 Exynos 4 来说：</p> 
<p>static struct s3c_gpio_chip exynos4_gpio_common_4bit[] = {<!-- --><br> {<!-- --><br> .base = S5P_VA_GPIO1,<br> .eint_offset = 0x0,<br> .group = 0,<br> .chip = {<!-- --><br> .base = EXYNOS4_GPA0(0),<br> .ngpio = EXYNOS4_GPIO_A0_NR,<br> .label = “GPA0”,<br> },<br> }, {<!-- --><br> .base = (S5P_VA_GPIO1 + 0x20),<br> .eint_offset = 0x4,<br> .group = 1,<br> .chip = {<!-- --><br> .base = EXYNOS4_GPA1(0),<br> .ngpio = EXYNOS4_GPIO_A1_NR,<br> .label = “GPA1”,<br> },<br> }, {<!-- --><br> .base = (S5P_VA_GPIO1 + 0x40),<br> .eint_offset = 0x8,<br> .group = 2,<br> .chip = {<!-- --><br> .base = EXYNOS4_GPB(0),<br> .ngpio = EXYNOS4_GPIO_B_NR,<br> .label = “GPB”,<br> },<br> }, {<!-- --><br> …<br> }<br> 定义好了各个 Bank 的基地址和 GPIO 的个数。以及支持中断的情况。</p> 
<p>在他的初始化函数中：<br> static __init int exynos4_gpiolib_init(void)<br> {<!-- --><br> struct s3c_gpio_chip *chip;<br> int i;<br> int nr_chips;</p> 
<pre><code>/* GPIO common part  */

chip = exynos4_gpio_common_4bit;
nr_chips = ARRAY_SIZE(exynos4_gpio_common_4bit);

for (i = 0; i &lt; nr_chips; i++, chip++) {
	if (chip-&gt;config == NULL)
		chip-&gt;config = &amp;gpio_cfg;
	if (chip-&gt;base == NULL)
		pr_err("No allocation of base address for [common gpio]");
}

samsung_gpiolib_add_4bit_chips(exynos4_gpio_common_4bit, nr_chips);

/* Only 4210 GPIO  part */
if (soc_is_exynos4210()) {
	chip = exynos4210_gpio_4bit;
	nr_chips = ARRAY_SIZE(exynos4210_gpio_4bit);

	for (i = 0; i &lt; nr_chips; i++, chip++) {
		if (chip-&gt;config == NULL)
			chip-&gt;config = &amp;gpio_cfg;
		if (chip-&gt;base == NULL)
			pr_err("No allocation of base address [4210 gpio]");
	}

	samsung_gpiolib_add_4bit_chips(exynos4210_gpio_4bit, nr_chips);
} else {
/* Only 4212/4412 GPIO part */
	chip = exynos4212_gpio_4bit;
	nr_chips = ARRAY_SIZE(exynos4212_gpio_4bit);

	for (i = 0; i &lt; nr_chips; i++, chip++) {
		if (chip-&gt;config == NULL)
			chip-&gt;config = &amp;gpio_cfg;
		if (chip-&gt;base == NULL)
			pr_err("No allocation of base address [4212 gpio]");
	}

	samsung_gpiolib_add_4bit_chips(exynos4212_gpio_4bit, nr_chips);
}
</code></pre> 
<p>…<br> }</p> 
<p>调用了 xxx_gpiolib_add_xxxx 的函数，在这一些列的调用中，就将 gpio_chip 结构体相关的成员进行了赋值，并最终调用到了 gpiochip_add 函数，将其注册到了内核的 Gpiolib 子系统。大致的流程是这样的，一些细节，可能由于版本不一致，内容有细微区别。</p> 
<p>当然，在较新的内核版本中，Kernel 提供了 devm 的接口，用于管理使用的内存情况，那么这个 gpiochip_add_data 变为了：</p> 
<p>devm_gpiochip_add_data<br> 接下来我们看看这个注册 GPIO 的函数。</p> 
<p>3.1、注册 GPIO 资源（gpiochip_add）<br> 前面也说过了，注册一个 GPIO 资源使用接口：</p> 
<p>int gpiochip_add(struct gpio_chip *chip)</p> 
<p>传入的结构是 gpio_chip，也就是一个 Bank 的描述，那么实际上， CPU 的 GPIO 控制器有多个 I/O Bank，那换句话说，需要 Kernel 管理的 GPIO Bank 的部分，都需要调用这个接口，注册进内核（当然，你也可以野蛮的 Bypass）；</p> 
<p>在旧的 Kernel 中，对接底层的部分，是每个 Bank 直接调用了 gpiochip_add 函数，新的内核支持传入 data，也就是带私有数据，所以新内核支持的注册接口是：gpiochip_add_data(chip, data)</p> 
<p>他的定义是：<br> #define gpiochip_add_data(chip, data) <br> gpiochip_add_data_with_key(chip, data, NULL, NULL)<br> 参数的含义，chip 也是 gpio_chip 的结构，data 是 void * data，私有数据。</p> 
<p>为了兼容以前的驱动，所以在新的结构中 gpiochip_add 的定义是：<br> static inline int gpiochip_add(struct gpio_chip *chip)<br> {<!-- --><br> return gpiochip_add_data(chip, NULL);<br> }<br> 也就是不带 data 的调用；</p> 
<p>当然，Gpiolib 也支持带 devm 的接口，管理其内存：<br> int devm_gpiochip_add_data(struct device *dev, struct gpio_chip *chip,<br> void *data)<br> {<!-- --><br> struct gpio_chip **ptr;<br> int ret;</p> 
<pre><code>ptr = devres_alloc(devm_gpio_chip_release, sizeof(*ptr),
		     GFP_KERNEL);
if (!ptr)
	return -ENOMEM;

ret = gpiochip_add_data(chip, data);
if (ret &lt; 0) {
	devres_free(ptr);
	return ret;
}

*ptr = chip;
devres_add(dev, ptr);

return 0;
</code></pre> 
<p>}<br> EXPORT_SYMBOL_GPL(devm_gpiochip_add_data);<br> 所以，可以看到，前前后后的几个注册的接口，最后全部汇集到：gpiochip_add_data_with_key<br> <img src="https://images2.imgbox.com/3a/f8/Z8ydOxdy_o.png" alt="在这里插入图片描述"><br> 接下来就来分析一下这个接口；<br> 3.2、gpiochip_add_data_with_key<br> 这个函数分成几次来看，先是 part 1：<br> …<br> part 1 start<br> …</p> 
<p>int gpiochip_add_data_with_key(struct gpio_chip *chip, void *data,<br> struct lock_class_key *lock_key,<br> struct lock_class_key *request_key)<br> {<!-- --><br> unsigned long flags;<br> int status = 0;<br> unsigned i;<br> int base = chip-&gt;base;<br> struct gpio_device *gdev;</p> 
<pre><code>/*
 * First: allocate and populate the internal stat container, and
 * set up the struct device.
 */
gdev = kzalloc(sizeof(*gdev), GFP_KERNEL);
if (!gdev)
	return -ENOMEM;
gdev-&gt;dev.bus = &amp;gpio_bus_type;
gdev-&gt;chip = chip;
chip-&gt;gpiodev = gdev;
if (chip-&gt;parent) {
	gdev-&gt;dev.parent = chip-&gt;parent;
	gdev-&gt;dev.of_node = chip-&gt;parent-&gt;of_node;
}
</code></pre> 
<p>#ifdef CONFIG_OF_GPIO<br> /* If the gpiochip has an assigned OF node this takes precedence */<br> if (chip-&gt;of_node)<br> gdev-&gt;dev.of_node = chip-&gt;of_node;<br> else<br> chip-&gt;of_node = gdev-&gt;dev.of_node;<br> #endif</p> 
<pre><code>gdev-&gt;id = ida_simple_get(&amp;gpio_ida, 0, 0, GFP_KERNEL);
if (gdev-&gt;id &lt; 0) {
	status = gdev-&gt;id;
	goto err_free_gdev;
}
dev_set_name(&amp;gdev-&gt;dev, "gpiochip%d", gdev-&gt;id);
device_initialize(&amp;gdev-&gt;dev);
dev_set_drvdata(&amp;gdev-&gt;dev, gdev);
if (chip-&gt;parent &amp;&amp; chip-&gt;parent-&gt;driver)
	gdev-&gt;owner = chip-&gt;parent-&gt;driver-&gt;owner;
else if (chip-&gt;owner)
	/* TODO: remove chip-&gt;owner */
	gdev-&gt;owner = chip-&gt;owner;
else
	gdev-&gt;owner = THIS_MODULE;
</code></pre> 
<p>…<br> part 1 end<br> …</p> 
<p>}<br> part 1 中，因为传入的结构是 gpio_chip，他代表了是一个 Bank，但是并没有 gpio_device 的结构，所以，在这个函数中，首先分配一个 gpio_device 的结构，并将其结构体成员的 chip ，等等进行赋值，建立起相关的结构联系。</p> 
<p>再看 part 2：<br> …<br> part 2 start<br> …<br> gdev-&gt;descs = kcalloc(chip-&gt;ngpio, sizeof(gdev-&gt;descs[0]), GFP_KERNEL);<br> if (!gdev-&gt;descs) {<!-- --><br> status = -ENOMEM;<br> goto err_free_ida;<br> }</p> 
<pre><code>if (chip-&gt;ngpio == 0) {
	chip_err(chip, "tried to insert a GPIO chip with zero lines\n");
	status = -EINVAL;
	goto err_free_descs;
}

if (chip-&gt;ngpio &gt; FASTPATH_NGPIO)
	chip_warn(chip, "line cnt %u is greater than fast path cnt %u\n",
	chip-&gt;ngpio, FASTPATH_NGPIO);

gdev-&gt;label = kstrdup_const(chip-&gt;label ?: "unknown", GFP_KERNEL);
if (!gdev-&gt;label) {
	status = -ENOMEM;
	goto err_free_descs;
}

gdev-&gt;ngpio = chip-&gt;ngpio;
gdev-&gt;data = data;
</code></pre> 
<p>…<br> part 2 end<br> …<br> part 2 中，由于 1 个 Bank不仅仅只有一个 GPIO，所以 gpio_chip-&gt;ngpio 的结构表示了这个 Bank 一共的 GPIO 个数，每一个 GPIO 使用一个 gpio_desc 表示，所以，这里分配了 ngpio 个 descs；</p> 
<p>最后是 part 3：<br> …<br> part 3 start<br> … <br> spin_lock_irqsave(&amp;gpio_lock, flags);</p> 
<pre><code>/*
 * TODO: this allocates a Linux GPIO number base in the global
 * GPIO numberspace for this chip. In the long run we want to
 * get *rid* of this numberspace and use only descriptors, but
 * it may be a pipe dream. It will not happen before we get rid
 * of the sysfs interface anyways.
 */
if (base &lt; 0) {
	base = gpiochip_find_base(chip-&gt;ngpio);
	if (base &lt; 0) {
		status = base;
		spin_unlock_irqrestore(&amp;gpio_lock, flags);
		goto err_free_label;
	}
	/*
	 * TODO: it should not be necessary to reflect the assigned
	 * base outside of the GPIO subsystem. Go over drivers and
	 * see if anyone makes use of this, else drop this and assign
	 * a poison instead.
	 */
	chip-&gt;base = base;
}
gdev-&gt;base = base;

status = gpiodev_add_to_list(gdev);
if (status) {
	spin_unlock_irqrestore(&amp;gpio_lock, flags);
	goto err_free_label;
}

spin_unlock_irqrestore(&amp;gpio_lock, flags);

for (i = 0; i &lt; chip-&gt;ngpio; i++)
	gdev-&gt;descs[i].gdev = gdev;
</code></pre> 
<p>#ifdef CONFIG_PINCTRL<br> INIT_LIST_HEAD(&amp;gdev-&gt;pin_ranges);<br> #endif</p> 
<pre><code>status = gpiochip_set_desc_names(chip);
if (status)
	goto err_remove_from_list;

status = gpiochip_irqchip_init_valid_mask(chip);
if (status)
	goto err_remove_from_list;

status = gpiochip_alloc_valid_mask(chip);
if (status)
	goto err_remove_irqchip_mask;

status = gpiochip_add_irqchip(chip, lock_key, request_key);
if (status)
	goto err_remove_chip;

status = of_gpiochip_add(chip);
if (status)
	goto err_remove_chip;

status = gpiochip_init_valid_mask(chip);
if (status)
	goto err_remove_chip;

for (i = 0; i &lt; chip-&gt;ngpio; i++) {
	struct gpio_desc *desc = &amp;gdev-&gt;descs[i];

	if (chip-&gt;get_direction &amp;&amp; gpiochip_line_is_valid(chip, i))
		desc-&gt;flags = !chip-&gt;get_direction(chip, i) ?
				(1 &lt;&lt; FLAG_IS_OUT) : 0;
	else
		desc-&gt;flags = !chip-&gt;direction_input ?
				(1 &lt;&lt; FLAG_IS_OUT) : 0;
}

acpi_gpiochip_add(chip);

machine_gpiochip_add(chip);

/*
 * By first adding the chardev, and then adding the device,
 * we get a device node entry in sysfs under
 * /sys/bus/gpio/devices/gpiochipN/dev that can be used for
 * coldplug of device nodes and other udev business.
 * We can do this only if gpiolib has been initialized.
 * Otherwise, defer until later.
 */
if (gpiolib_initialized) {
	status = gpiochip_setup_dev(gdev);
	if (status)
		goto err_remove_chip;
}
return 0;
</code></pre> 
<p>err_remove_chip:<br> acpi_gpiochip_remove(chip);<br> gpiochip_free_hogs(chip);<br> of_gpiochip_remove(chip);<br> gpiochip_free_valid_mask(chip);<br> err_remove_irqchip_mask:<br> gpiochip_irqchip_free_valid_mask(chip);<br> err_remove_from_list:<br> spin_lock_irqsave(&amp;gpio_lock, flags);<br> list_del(&amp;gdev-&gt;list);<br> spin_unlock_irqrestore(&amp;gpio_lock, flags);<br> err_free_label:<br> kfree_const(gdev-&gt;label);<br> err_free_descs:<br> kfree(gdev-&gt;descs);<br> err_free_ida:<br> ida_simple_remove(&amp;gpio_ida, gdev-&gt;id);<br> err_free_gdev:<br> /* failures here can mean systems won’t boot… */<br> pr_err("%s: GPIOs %d…%d (%s) failed to register, %d\n", <strong>func</strong>,<br> gdev-&gt;base, gdev-&gt;base + gdev-&gt;ngpio - 1,<br> chip-&gt;label ? : “generic”, status);<br> kfree(gdev);<br> return status;<br> …<br> part 3 end<br> … <br> 在 part 3 中，base 代表了每个 Bank 的编号，将其赋值；然后通过 gpiodev_add_to_list(gdev) 将这个 gdev 挂到全局的 gpio_devices ：<br> static int gpiodev_add_to_list(struct gpio_device *gdev)<br> {<!-- --><br> struct gpio_device *prev, *next;</p> 
<pre><code>if (list_empty(&amp;gpio_devices)) {
	/* initial entry in list */
	list_add_tail(&amp;gdev-&gt;list, &amp;gpio_devices);
	return 0;
}

next = list_entry(gpio_devices.next, struct gpio_device, list);
if (gdev-&gt;base + gdev-&gt;ngpio &lt;= next-&gt;base) {
	/* add before first entry */
	list_add(&amp;gdev-&gt;list, &amp;gpio_devices);
	return 0;
}

prev = list_entry(gpio_devices.prev, struct gpio_device, list);
if (prev-&gt;base + prev-&gt;ngpio &lt;= gdev-&gt;base) {
	/* add behind last entry */
	list_add_tail(&amp;gdev-&gt;list, &amp;gpio_devices);
	return 0;
}

list_for_each_entry_safe(prev, next, &amp;gpio_devices, list) {
	/* at the end of the list */
	if (&amp;next-&gt;list == &amp;gpio_devices)
		break;

	/* add between prev and next */
	if (prev-&gt;base + prev-&gt;ngpio &lt;= gdev-&gt;base
			&amp;&amp; gdev-&gt;base + gdev-&gt;ngpio &lt;= next-&gt;base) {
		list_add(&amp;gdev-&gt;list, &amp;prev-&gt;list);
		return 0;
	}
}

dev_err(&amp;gdev-&gt;dev, "GPIO integer space overlap, cannot add chip\n");
return -EBUSY;
</code></pre> 
<p>}<br> 接着就是设置一些 name 字段，配置中断之类的，初始化每个 desc[] 结构的 flags，最后调用：<br> if (gpiolib_initialized) {<!-- --><br> status = gpiochip_setup_dev(gdev);<br> if (status)<br> goto err_remove_chip;<br> }<br> return 0;<br> 然后，不出意外的话，返回 0；</p> 
<p>这里说一下 gpiochip_setup_dev 调用，这个是在 Gpiolib init 的时候调用 gpiochip_setup_devs：<br> static int __init gpiolib_dev_init(void)<br> {<!-- --><br> int ret;</p> 
<pre><code>/* Register GPIO sysfs bus */
ret = bus_register(&amp;gpio_bus_type);
if (ret &lt; 0) {
	pr_err("gpiolib: could not register GPIO bus type\n");
	return ret;
}

ret = alloc_chrdev_region(&amp;gpio_devt, 0, GPIO_DEV_MAX, "gpiochip");
if (ret &lt; 0) {
	pr_err("gpiolib: failed to allocate char dev region\n");
	bus_unregister(&amp;gpio_bus_type);
} else {
	gpiolib_initialized = true;
	gpiochip_setup_devs();
}
return ret;
</code></pre> 
<p>}<br> core_initcall(gpiolib_dev_init);<br> 而这个 gpiochip_setup_devs 对每一个 gpio_devicecs 节点调用：gpiochip_setup_dev：<br> static void gpiochip_setup_devs(void)<br> {<!-- --><br> struct gpio_device *gdev;<br> int err;</p> 
<pre><code>list_for_each_entry(gdev, &amp;gpio_devices, list) {
	err = gpiochip_setup_dev(gdev);
	if (err)
		pr_err("%s: Failed to initialize gpio device (%d)\n",
		       dev_name(&amp;gdev-&gt;dev), err);
}
</code></pre> 
<p>}<br> 最后到：<br> static int gpiochip_setup_dev(struct gpio_device *gdev)<br> {<!-- --><br> int status;</p> 
<pre><code>cdev_init(&amp;gdev-&gt;chrdev, &amp;gpio_fileops);
gdev-&gt;chrdev.owner = THIS_MODULE;
gdev-&gt;dev.devt = MKDEV(MAJOR(gpio_devt), gdev-&gt;id);

status = cdev_device_add(&amp;gdev-&gt;chrdev, &amp;gdev-&gt;dev);
if (status)
	return status;

chip_dbg(gdev-&gt;chip, "added GPIO chardev (%d:%d)\n",
	 MAJOR(gpio_devt), gdev-&gt;id);

status = gpiochip_sysfs_register(gdev);
if (status)
	goto err_remove_device;

/* From this point, the .release() function cleans up gpio_device */
gdev-&gt;dev.release = gpiodevice_release;
pr_debug("%s: registered GPIOs %d to %d on device: %s (%s)\n",
	 __func__, gdev-&gt;base, gdev-&gt;base + gdev-&gt;ngpio - 1,
	 dev_name(&amp;gdev-&gt;dev), gdev-&gt;chip-&gt;label ? : "generic");

return 0;
</code></pre> 
<p>err_remove_device:<br> cdev_device_del(&amp;gdev-&gt;chrdev, &amp;gdev-&gt;dev);<br> return status;<br> }<br> 其实就是注册了字符设备，并且添加到了 sysfs；</p> 
<p>个人理解，因为不知道这个 init 和我们的对接底层的驱动的 init 谁先执行到，所以用了一个变量 gpiolib_initialized 来表示当前的 Gpiolib 是不是已经完成了相关的字符设备的注册，如果是 Gpiolib 先去 init 的话，那么 gpiolib_initialized ture，芯片对接底层的部分错过 gpio_chip setup 的机会，所以需要重新调用这个 gpiochip_setup_dev 接口，反之 OK；</p> 
<p>到这里，对接底层驱动的部分基本上 OK 了，小伙伴们需要按照自己芯片的 Specific 去做自己的 gpio_chip 结构并最终通过 gpiochip_add_data 添加到 Gpiolib 子系统中；</p> 
<p>还有一点需要注意到的是，小伙伴们需要自行定义一些结构，来获得并表示自己 Bank 的虚拟地址等等，这样才能操作到实际的硬件寄存器；</p> 
<h3><a id="4Gpiolib__APIs_717"></a>4、Gpiolib 为其他驱动提供的 APIs</h3> 
<p>在对接底层完成后，Gpiolib 为其他的驱动提供了一些列的调用接口：</p> 
<p>1、gpio_request：向内核申请 gpio</p> 
<p>要使用 GPIO 首先应该向内核进行申请，返回 0，代表申请成功，可以进行后续操作</p> 
<p>2、gpio_free： 对应 gpio_request，是使用完gpio以后把gpio释放掉</p> 
<p>3、gpio_direction_input ：设置 GPIO 为输入</p> 
<p>4、gpio_direction_output：设置 GPIO 为输出</p> 
<p>5、gpio_get_value ：读取 GPIO 的值</p> 
<p>6、gpio_set_value：设置 GPIO 口的值<br> 4.1、gpio_request<br> 其他驱动使用 GPIO 的时候呢，需要先调用这个接口，向 Gpiolib 进行申请 GPIO ：<br> int gpio_request(unsigned gpio, const char *label)<br> {<!-- --><br> struct gpio_desc *desc = gpio_to_desc(gpio);</p> 
<pre><code>/* Compatibility: assume unavailable "valid" GPIOs will appear later */
if (!desc &amp;&amp; gpio_is_valid(gpio))
	return -EPROBE_DEFER;

return gpiod_request(desc, label);
</code></pre> 
<p>}<br> EXPORT_SYMBOL_GPL(gpio_request);<br> 他传入的参数有一个 gpio 和一个 label，gpio 参数是一个数字，代表着板子上 GPIO 的编号，什么叫编号呢？请注意，这里的编号，有别于 Datasheet 中的编号，要知道这个，我们先好好了解一下 gpio_chip-&gt;base 的成员，打个比如，很多人都了解过三星的 2440 或者 6410 的芯片，对于他们的 GPIO 定义，我们来看看如何定义这个 gpio_chip-&gt;base 成员的：<br> static struct samsung_gpio_chip s3c64xx_gpios_4bit[] = {<!-- --><br> #ifdef CONFIG_ARCH_S3C64XX<br> {<!-- --><br> .chip = {<!-- --><br> .base = S3C64XX_GPA(0),<br> .ngpio = S3C64XX_GPIO_A_NR,<br> .label = “GPA”,<br> },<br> }, {<!-- --><br> .chip = {<!-- --><br> .base = S3C64XX_GPB(0),<br> .ngpio = S3C64XX_GPIO_B_NR,<br> .label = “GPB”,<br> },<br> }, {<!-- --><br> .chip = {<!-- --><br> .base = S3C64XX_GPC(0),<br> .ngpio = S3C64XX_GPIO_C_NR,<br> .label = “GPC”,<br> },<br> …<br> }<br> 这里我们看到的 .base 就是 gpio_chip-&gt;base ，他别定义为 S3C64XX_GPA(0)、S3C64XX_GPB(0)、S3C64XX_GPC(0)…他定义在：</p> 
<p>gpio_samsung.h<br> /* GPIO bank sizes */<br> #define S3C64XX_GPIO_A_NR (8)<br> #define S3C64XX_GPIO_B_NR (7)<br> #define S3C64XX_GPIO_C_NR (8)<br> #define S3C64XX_GPIO_D_NR (5)<br> #define S3C64XX_GPIO_E_NR (5)<br> #define S3C64XX_GPIO_F_NR (16)<br> #define S3C64XX_GPIO_G_NR (7)<br> #define S3C64XX_GPIO_H_NR (10)<br> #define S3C64XX_GPIO_I_NR (16)<br> #define S3C64XX_GPIO_J_NR (12)<br> #define S3C64XX_GPIO_K_NR (16)<br> #define S3C64XX_GPIO_L_NR (15)<br> #define S3C64XX_GPIO_M_NR (6)<br> #define S3C64XX_GPIO_N_NR (16)<br> #define S3C64XX_GPIO_O_NR (16)<br> #define S3C64XX_GPIO_P_NR (15)<br> #define S3C64XX_GPIO_Q_NR (9)</p> 
<p>/* GPIO bank numbes */</p> 
<p>/* CONFIG_S3C_GPIO_SPACE allows the user to select extra</p> 
<ul><li>space for debugging purposes so that any accidental</li><li>change from one gpio bank to another can be caught.<br> */</li></ul> 
<p>#define S3C64XX_GPIO_NEXT(__gpio) <br> ((__gpio##_START) + (__gpio##_NR) + CONFIG_S3C_GPIO_SPACE + 1)</p> 
<p>enum s3c_gpio_number {<!-- --><br> S3C64XX_GPIO_A_START = 0,<br> S3C64XX_GPIO_B_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_A),<br> S3C64XX_GPIO_C_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_B),<br> S3C64XX_GPIO_D_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_C),<br> S3C64XX_GPIO_E_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_D),<br> S3C64XX_GPIO_F_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_E),<br> S3C64XX_GPIO_G_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_F),<br> S3C64XX_GPIO_H_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_G),<br> S3C64XX_GPIO_I_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_H),<br> S3C64XX_GPIO_J_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_I),<br> S3C64XX_GPIO_K_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_J),<br> S3C64XX_GPIO_L_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_K),<br> S3C64XX_GPIO_M_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_L),<br> S3C64XX_GPIO_N_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_M),<br> S3C64XX_GPIO_O_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_N),<br> S3C64XX_GPIO_P_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_O),<br> S3C64XX_GPIO_Q_START = S3C64XX_GPIO_NEXT(S3C64XX_GPIO_P),<br> };</p> 
<p>/* S3C64XX GPIO number definitions. */</p> 
<p>#define S3C64XX_GPA(_nr) (S3C64XX_GPIO_A_START + (_nr))<br> #define S3C64XX_GPB(_nr) (S3C64XX_GPIO_B_START + (_nr))<br> #define S3C64XX_GPC(_nr) (S3C64XX_GPIO_C_START + (_nr))<br> #define S3C64XX_GPD(_nr) (S3C64XX_GPIO_D_START + (_nr))<br> #define S3C64XX_GPE(_nr) (S3C64XX_GPIO_E_START + (_nr))<br> #define S3C64XX_GPF(_nr) (S3C64XX_GPIO_F_START + (_nr))<br> #define S3C64XX_GPG(_nr) (S3C64XX_GPIO_G_START + (_nr))<br> #define S3C64XX_GPH(_nr) (S3C64XX_GPIO_H_START + (_nr))<br> #define S3C64XX_GPI(_nr) (S3C64XX_GPIO_I_START + (_nr))<br> #define S3C64XX_GPJ(_nr) (S3C64XX_GPIO_J_START + (_nr))<br> #define S3C64XX_GPK(_nr) (S3C64XX_GPIO_K_START + (_nr))<br> #define S3C64XX_GPL(_nr) (S3C64XX_GPIO_L_START + (_nr))<br> #define S3C64XX_GPM(_nr) (S3C64XX_GPIO_M_START + (_nr))<br> #define S3C64XX_GPN(_nr) (S3C64XX_GPIO_N_START + (_nr))<br> #define S3C64XX_GPO(_nr) (S3C64XX_GPIO_O_START + (_nr))<br> #define S3C64XX_GPP(_nr) (S3C64XX_GPIO_P_START + (_nr))<br> #define S3C64XX_GPQ(_nr) (S3C64XX_GPIO_Q_START + (_nr))</p> 
<p>有上面的定义可知：</p> 
<p>Bank A base -&gt; S3C64XX_GPA(0) -&gt; 0</p> 
<p>Bank B base -&gt; S3C64XX_GPB(0) -&gt; S3C64XX_GPIO_A_START(=0) + S3C64XX_GPIO_A_NR(=8)</p> 
<p>Bank C base -&gt; S3C64XX_GPC(0) -&gt; S3C64XX_GPIO_B_START(8) + S3C64XX_GPIO_B_NR(=7)</p> 
<p>…<br> 所以呢，所有的 GPIO 都是按照这个从 0 开始的顺序进行编号的，在这款芯片软件层的对接 Gpiolib 的实现上，每一个 Bank 的 base 被设计成为了上一个 GPIO 的起始位置，加上上一个 GPIO 的个数，最终得出，所有的 GPIO 都是按照顺序，在软件层面上，进行统一编号，这个 gpio_chip-&gt;base 值，就是指的每个 Bank 的起始编号！</p> 
<p>言归正传，gpio_request 函数中的这个 gpio 入参，就是指的这些被编号了的 GPIO 的号码，你要他，就要翻他的牌！</p> 
<p>在 gpio_request 实现中，首先调用了 gpio_to_desc 去根据传入的 gpio 的牌子，去索引到 gpio_desc 结构（还记得么，一个 gpio_desc 表征了一个 GPIO 的实例）<br> struct gpio_desc *gpio_to_desc(unsigned gpio)<br> {<!-- --><br> struct gpio_device *gdev;<br> unsigned long flags;</p> 
<pre><code>spin_lock_irqsave(&amp;gpio_lock, flags);

list_for_each_entry(gdev, &amp;gpio_devices, list) {
	if (gdev-&gt;base &lt;= gpio &amp;&amp;
	    gdev-&gt;base + gdev-&gt;ngpio &gt; gpio) {
		spin_unlock_irqrestore(&amp;gpio_lock, flags);
		return &amp;gdev-&gt;descs[gpio - gdev-&gt;base];
	}
}

spin_unlock_irqrestore(&amp;gpio_lock, flags);

if (!gpio_is_valid(gpio))
	WARN(1, "invalid GPIO %d\n", gpio);

return NULL;
</code></pre> 
<p>}<br> EXPORT_SYMBOL_GPL(gpio_to_desc);<br> 可以看到，其实就是遍历了 gpio_devices ，然后如果你传入的编号在这个 Bank 之内，OK，给你返回这个这个 desc 结构；</p> 
<p>然后调用到 Gpiolib 的 gpiod_request：</p> 
<p>int gpiod_request(struct gpio_desc *desc, const char *label)<br> {<!-- --><br> int status = -EPROBE_DEFER;<br> struct gpio_device *gdev;</p> 
<pre><code>VALIDATE_DESC(desc);
gdev = desc-&gt;gdev;

if (try_module_get(gdev-&gt;owner)) {
	status = gpiod_request_commit(desc, label);
	if (status &lt; 0)
		module_put(gdev-&gt;owner);
	else
		get_device(&amp;gdev-&gt;dev);
}

if (status)
	gpiod_dbg(desc, "%s: status %d\n", __func__, status);

return status;
</code></pre> 
<p>}<br> 走到 gpiod_request_commit：<br> static int gpiod_request_commit(struct gpio_desc *desc, const char *label)<br> {<!-- --><br> struct gpio_chip *chip = desc-&gt;gdev-&gt;chip;<br> int status;<br> unsigned long flags;<br> unsigned offset;</p> 
<pre><code>spin_lock_irqsave(&amp;gpio_lock, flags);

/* NOTE:  gpio_request() can be called in early boot,
 * before IRQs are enabled, for non-sleeping (SOC) GPIOs.
 */

if (test_and_set_bit(FLAG_REQUESTED, &amp;desc-&gt;flags) == 0) {
	desc_set_label(desc, label ? : "?");
	status = 0;
} else {
	status = -EBUSY;
	goto done;
}

if (chip-&gt;request) {
	/* chip-&gt;request may sleep */
	spin_unlock_irqrestore(&amp;gpio_lock, flags);
	offset = gpio_chip_hwgpio(desc);
	if (gpiochip_line_is_valid(chip, offset))
		status = chip-&gt;request(chip, offset);
	else
		status = -EINVAL;
	spin_lock_irqsave(&amp;gpio_lock, flags);

	if (status &lt; 0) {
		desc_set_label(desc, NULL);
		clear_bit(FLAG_REQUESTED, &amp;desc-&gt;flags);
		goto done;
	}
}
if (chip-&gt;get_direction) {
	/* chip-&gt;get_direction may sleep */
	spin_unlock_irqrestore(&amp;gpio_lock, flags);
	gpiod_get_direction(desc);
	spin_lock_irqsave(&amp;gpio_lock, flags);
}
</code></pre> 
<p>done:<br> spin_unlock_irqrestore(&amp;gpio_lock, flags);<br> return status;<br> }<br> 针对这 GPIO，如果没人去 FLAG_REQUESTED 的话，那么按照传入的 label 设置他的标签，在获得他的一些方向，等状态；</p> 
<p>如果已经被 FLAG_REQUESTED 了的话，返回 -EBUSY，请求 GPIO 失败。<br> 4.2、gpio_direction_input/gpio_direction_output<br> 当 request 成功后，你就可以用你成功的这个 gpio 来搞事情了，如果要读 GPIO 状态，则需要配置成为 input，写的话，配置 output（点个 LED 灯）；</p> 
<p>这个两个函数很简单：<br> static inline int gpio_direction_input(unsigned gpio)<br> {<!-- --><br> return gpiod_direction_input(gpio_to_desc(gpio));<br> }<br> static inline int gpio_direction_output(unsigned gpio, int value)<br> {<!-- --><br> return gpiod_direction_output_raw(gpio_to_desc(gpio), value);<br> }<br> 不在过多分析，其实就是根据传入的 gpio 的编号，也是转换成为了 desc 后，获得了 Bank 的 gpio_chip 结构，然后调用了挂接上去的 direction_input/direction_output 而已，我们看一个实际的底层实现：<br> static int samsung_gpiolib_4bit2_input(struct gpio_chip *chip,<br> unsigned int offset)<br> {<!-- --><br> struct samsung_gpio_chip *ourchip = to_samsung_gpio(chip);<br> void __iomem *base = ourchip-&gt;base;<br> void __iomem *regcon = base;<br> unsigned long con;</p> 
<pre><code>if (offset &gt; 7)
	offset -= 8;
else
	regcon -= 4;

con = __raw_readl(regcon);
con &amp;= ~(0xf &lt;&lt; con_4bit_shift(offset));
__raw_writel(con, regcon);

pr_debug("%s: %p: CON %08lx\n", __func__, base, con);

return 0;
</code></pre> 
<p>}<br> static int samsung_gpiolib_4bit2_output(struct gpio_chip *chip,<br> unsigned int offset, int value)<br> {<!-- --><br> struct samsung_gpio_chip *ourchip = to_samsung_gpio(chip);<br> void __iomem *base = ourchip-&gt;base;<br> void __iomem *regcon = base;<br> unsigned long con;<br> unsigned long dat;<br> unsigned con_offset = offset;</p> 
<pre><code>if (con_offset &gt; 7)
	con_offset -= 8;
else
	regcon -= 4;

con = __raw_readl(regcon);
con &amp;= ~(0xf &lt;&lt; con_4bit_shift(con_offset));
con |= 0x1 &lt;&lt; con_4bit_shift(con_offset);

dat = __raw_readl(base + GPIODAT_OFF);

if (value)
	dat |= 1 &lt;&lt; offset;
else
	dat &amp;= ~(1 &lt;&lt; offset);

__raw_writel(dat, base + GPIODAT_OFF);
__raw_writel(con, regcon);
__raw_writel(dat, base + GPIODAT_OFF);

pr_debug("%s: %p: CON %08lx, DAT %08lx\n", __func__, base, con, dat);

return 0;
</code></pre> 
<p>}<br> 4.3、gpiod_set_value/gpiod_get_value<br> 读 GPIO 和 写 GPIO 差不多，这里不在多说，一眼便知；</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b1e5a97ef848d27e31b73385923c3219/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RTF(富文本格式)与HTML(超文本标记语言)的区别？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c3f30695770846c56c4fb3faac639370/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据库原理及应用】经典题库附答案（14章全）——第二章：关系数据库知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>