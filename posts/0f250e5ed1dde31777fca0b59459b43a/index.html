<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue源码学习 - 模版编译 和 组件渲染/更新过程 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue源码学习 - 模版编译 和 组件渲染/更新过程" />
<meta property="og:description" content="目录 前言一、什么是 模板编译？二、模板编译 到 render 函数字符串的流程三、深入模板编译源码baseCompile ()parse() - 解析阶段optimize() - 优化阶段generate() - 生成阶段（1）了解 render函数字符串 和 with 语法（2）generate（3）genElement() 四、组件渲染/更新 完整过程初识组件渲染/更新组件渲染/更新过程（1）初次渲染过程（2）更新过程（3）异步渲染 疑问点整理 前言 这是一个系列学习源码的文章，感兴趣的可以继续阅读其他文章
Vue源码学习 - new Vue初始化都做了什么？
Vue源码学习 - 数据响应式原理
Vue源码学习 - 异步更新队列 和 nextTick原理
Vue源码学习 - 虚拟Dom 和 diff算法
一、什么是 模板编译？ 平时开发写的 &lt;template&gt;&lt;/template&gt; 以及里面的变量、表达式、指令等，不是html语法，是浏览器识别不出来的。所以需要将 template 转化成一个 JS 函数，这样浏览器就可以执行这一个函数并渲染出对应的 HTML 元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。
主要流程就是：
提取出模板中的原生和非原生 HTML，比如绑定的属性、事件、指令、变量等。经过一些处理生成 render 函数字符串。render 函数再将模板内容生成对应的 vnode。再经过 patch 过程（Diff）得到要渲染到视图中的 vnode。最后根据 vnode 创建真实 DOM 节点，也就是原生 HTML 插入到视图中，完成渲染。 上面的1、2、3条就是模板编译的过程。具体是怎么编译生成 render 函数字符串的，继续往下看。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/0f250e5ed1dde31777fca0b59459b43a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-19T10:12:50+08:00" />
<meta property="article:modified_time" content="2023-09-19T10:12:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue源码学习 - 模版编译 和 组件渲染/更新过程</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#__8" rel="nofollow">一、什么是 模板编译？</a></li><li><a href="#__render__23" rel="nofollow">二、模板编译 到 render 函数字符串的流程</a></li><li><a href="#_37" rel="nofollow">三、深入模板编译源码</a></li><li><ul><li><a href="#baseCompile__38" rel="nofollow">baseCompile ()</a></li><li><a href="#parse___119" rel="nofollow">parse() - 解析阶段</a></li><li><a href="#optimize___178" rel="nofollow">optimize() - 优化阶段</a></li><li><a href="#generate___211" rel="nofollow">generate() - 生成阶段</a></li><li><ul><li><a href="#1_render__with__234" rel="nofollow">（1）了解 render函数字符串 和 with 语法</a></li><li><a href="#2generate_286" rel="nofollow">（2）generate</a></li><li><a href="#3genElement_310" rel="nofollow">（3）genElement()</a></li></ul> 
  </li></ul> 
  </li><li><a href="#__373" rel="nofollow">四、组件渲染/更新 完整过程</a></li><li><ul><li><a href="#_374" rel="nofollow">初识组件渲染/更新</a></li><li><a href="#_392" rel="nofollow">组件渲染/更新过程</a></li><li><ul><li><a href="#1_394" rel="nofollow">（1）初次渲染过程</a></li><li><a href="#2_413" rel="nofollow">（2）更新过程</a></li><li><a href="#3_425" rel="nofollow">（3）异步渲染</a></li></ul> 
   </li><li><a href="#_434" rel="nofollow">疑问点整理</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言</h2> 
<p>这是一个系列学习源码的文章，感兴趣的可以继续阅读其他文章<br> <a href="https://blog.csdn.net/weixin_45811256/article/details/131708328">Vue源码学习 - new Vue初始化都做了什么？</a><br> <a href="https://blog.csdn.net/weixin_45811256/article/details/131713560">Vue源码学习 - 数据响应式原理</a><br> <a href="https://blog.csdn.net/weixin_45811256/article/details/131814963">Vue源码学习 - 异步更新队列 和 nextTick原理</a><br> <a href="https://blog.csdn.net/weixin_45811256/article/details/131815014">Vue源码学习 - 虚拟Dom 和 diff算法</a></p> 
<h2><a id="__8"></a>一、什么是 模板编译？</h2> 
<p>平时开发写的 <code>&lt;template&gt;&lt;/template&gt;</code> 以及里面的变量、表达式、指令等，不是html语法，是浏览器识别不出来的。所以需要将 <code>template</code> 转化成一个 <code>JS 函数</code>，这样浏览器就可以执行这一个函数并渲染出对应的 HTML 元素，就可以让视图跑起来了，这一个转化的过程，就成为<code>模板编译</code>。</p> 
<p>主要流程就是：</p> 
<blockquote> 
 <ol><li><strong>提取出模板中的原生和非原生 HTML，比如绑定的属性、事件、指令、变量等。</strong></li><li><strong>经过一些处理生成 <code>render</code> 函数字符串。</strong></li><li><strong><code>render</code> 函数再将模板内容生成对应的 <code>vnode</code>。</strong></li><li><strong>再经过 <code>patch</code> 过程（Diff）得到要渲染到视图中的 <code>vnode</code>。</strong></li><li><strong>最后根据 vnode 创建<code>真实 DOM</code> 节点，也就是原生 HTML 插入到视图中，完成渲染。</strong></li></ol> 
</blockquote> 
<p>上面的1、2、3条就是模板编译的过程。具体是怎么编译生成 render 函数字符串的，继续往下看。</p> 
<h2><a id="__render__23"></a>二、模板编译 到 render 函数字符串的流程</h2> 
<p>主要有三个阶段：<strong><code>解析 parse；优化 optimise；生成 generate，最终生成可执行函数 render</code></strong>。</p> 
<ol><li> <p><strong>模板解析阶段</strong>： 使用大量的正则表达式提取出 <code>&lt;template&gt;&lt;/template&gt;</code> 模板里的标签、属性、变量等信息，并解析成 <code>抽象语法树 AST</code>。</p> </li><li> <p><strong>优化阶段</strong>：<code>遍历 AST</code> ，找到其中的一些 <code>静态节点</code> 并 <code>标记</code>，方便在页面重渲染的时候进行 diff 比较时，直接跳过这些静态节点，优化 runtime 的性能。</p> </li><li> <p><strong>生成阶段</strong> ：将最终的 <code>AST</code> 转化为 <code>render</code> 函数字符串。</p> </li></ol> 
<p>render 函数字符串的生成是在 <code>beforeCreate</code> 钩子函数之前完成的。vue2源码里就是这样写的，instance文件夹 =&gt; init.ts</p> 
<p><img src="https://images2.imgbox.com/76/d8/ZglXDFxe_o.png" alt="在这里插入图片描述"></p> 
<p>这三步分别对应三个函数，后面会挨个介绍，先看一下 <strong>baseCompile</strong> 源码中是在哪里调用的。</p> 
<h2><a id="_37"></a>三、深入模板编译源码</h2> 
<h3><a id="baseCompile__38"></a>baseCompile ()</h3> 
<p>这是模板编译的入口函数，接收两个参数：</p> 
<ul><li><code>template</code>：要转换的模板字符串</li><li><code>options</code>：转换时需要的参数</li></ul> 
<pre><code class="prism language-javascript"><span class="token comment">// src/compiler/index.ts</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> createCompiler <span class="token operator">=</span> <span class="token function">createCompilerCreator</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">baseCompile</span><span class="token punctuation">(</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> string<span class="token punctuation">,</span>  <span class="token comment">// 要转换的模板字符串</span>
  <span class="token literal-property property">options</span><span class="token operator">:</span> CompilerOptions  <span class="token comment">// 转换时需要的参数</span>
<span class="token punctuation">)</span><span class="token operator">:</span> CompiledResult <span class="token punctuation">{<!-- --></span>

  <span class="token comment">// 1. 进行模板编译，并将结果保存为抽象语法树 AST</span>
  <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span>   
  <span class="token comment">// 没有禁用静态优化的话</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>optimize <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
  <span class="token comment">// 2. 遍历 AST，找到其中的一些静态节点并标记</span>
    <span class="token function">optimize</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
 <span class="token comment">//  3. 将最终的 AST 转化为 render渲染函数</span>
  <span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>
    ast<span class="token punctuation">,</span>
    <span class="token literal-property property">render</span><span class="token operator">:</span> code<span class="token punctuation">.</span>render<span class="token punctuation">,</span>  <span class="token comment">// 返回渲染函数 render</span>
    <span class="token literal-property property">staticRenderFns</span><span class="token operator">:</span> code<span class="token punctuation">.</span>staticRenderFns
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>就这么几行代码，三步，调用了三个方法很清晰。</p> 
<p>我们先看一下最后 <code>return</code> 出去的是个啥，再来深入这三步分别调用的方法源码，也好更清楚的知道这三步分别是要做哪些处理。</p> 
<p>比如有这样的模板：</p> 
<pre><code class="prism language-javascript"><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span>name<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
</code></pre> 
<p>打印一下编译后的结果，也就是上面源码 return 出去的结果，看看是啥。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 把 模板 编译成 抽象语法树 AST</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">ast</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">attrsList</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">'app'</span> <span class="token punctuation">}</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token literal-property property">attrsMap</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'app'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">rawAttrsMap</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">parent</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
    <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{<!-- --></span>
        <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
        <span class="token literal-property property">expression</span><span class="token operator">:</span> <span class="token string">'_s(name)'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">tokens</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token punctuation">{<!-- --></span> <span class="token string-property property">'@binding'</span><span class="token operator">:</span> <span class="token string">'name'</span> <span class="token punctuation">}</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">'{<!-- -->{name}}'</span><span class="token punctuation">,</span>
        <span class="token keyword">static</span><span class="token operator">:</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token literal-property property">plain</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">attrs</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">'"app"'</span><span class="token punctuation">,</span> <span class="token literal-property property">dynamic</span><span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token punctuation">}</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token keyword">static</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">staticRoot</span><span class="token operator">:</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">render</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">with(this){return _c('div',{attrs:{"id":"app"}},[_v(_s(name))])}</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  <span class="token literal-property property">staticRenderFns</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token literal-property property">errors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token literal-property property">tips</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里暂时看不明白也没有关系，注意看return 里提到的三步都干了什么？</p> 
<ul><li><strong><code>ast</code></strong> ：就是第一步生成的。</li><li><strong><code>static</code></strong>： 就是静态节点标记，是在第二步中的根据 <code>ast</code> 里的 <code>type</code> 加上去的。（具体的type类型可看下面的表格）</li><li><strong><code>render</code></strong>：就是第三步生成的。</li></ul> 
<p>有个大概的印象了，然后再来看源码。</p> 
<h3><a id="parse___119"></a>parse() - 解析阶段</h3> 
<p>这个方法就是解析器的主函数，它通过多个正则方法提取出 <code>&lt;template&gt;&lt;/template&gt;</code> 模板字符串里所有的<code>tag</code>、<code>props</code>、<code>children</code> 信息，生成一个对应结构的 <code>AST</code> 对象。</p> 
<p><strong>核心步骤：调用 <code>parseHTML()</code> 对 模板字符串 进行解析。</strong></p> 
<blockquote> 
 <ul><li>解析到 开始标签、结束标签、文本、注释分别进行不同的处理。</li><li>解析过程中遇到 文本信息 ，就调用文本解析器 <code>parseText()</code> 进行文本解析。</li><li>解析过程中遇到 包含过滤器 ，就调用过滤器解析器 <code>parseFilters()</code> 进行解析。</li><li><strong>每一步解析的结果都合并到一个对象上（就是最后的 AST）.</strong></li></ul> 
</blockquote> 
<pre><code class="prism language-javascript"><span class="token comment">// src/complier/parser/index.ts</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">template</span><span class="token operator">:</span> string<span class="token punctuation">,</span> <span class="token literal-property property">options</span><span class="token operator">:</span> CompilerOptions</span><span class="token punctuation">)</span><span class="token operator">:</span> ASTElement <span class="token punctuation">{<!-- --></span>
  <span class="token function">parseHTML</span><span class="token punctuation">(</span>template<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    warn<span class="token punctuation">,</span>
    <span class="token literal-property property">expectHTML</span><span class="token operator">:</span> options<span class="token punctuation">.</span>expectHTML<span class="token punctuation">,</span>
    <span class="token literal-property property">isUnaryTag</span><span class="token operator">:</span> options<span class="token punctuation">.</span>isUnaryTag<span class="token punctuation">,</span>
    <span class="token literal-property property">canBeLeftOpenTag</span><span class="token operator">:</span> options<span class="token punctuation">.</span>canBeLeftOpenTag<span class="token punctuation">,</span>
    <span class="token literal-property property">shouldDecodeNewlines</span><span class="token operator">:</span> options<span class="token punctuation">.</span>shouldDecodeNewlines<span class="token punctuation">,</span>
    <span class="token literal-property property">shouldDecodeNewlinesForHref</span><span class="token operator">:</span> options<span class="token punctuation">.</span>shouldDecodeNewlinesForHref<span class="token punctuation">,</span>
    <span class="token literal-property property">shouldKeepComment</span><span class="token operator">:</span> options<span class="token punctuation">.</span>comments<span class="token punctuation">,</span>
    <span class="token literal-property property">outputSourceRange</span><span class="token operator">:</span> options<span class="token punctuation">.</span>outputSourceRange<span class="token punctuation">,</span>
    
    <span class="token comment">// 解析到 开始标签 时调用，如&lt;div&gt;</span>
    <span class="token function">start</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> unary<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token comment">// unary 是否是自闭合标签，如 &lt;img /&gt;</span>
     <span class="token comment">// ...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    
    <span class="token comment">// 解析到 结束标签 时调用，如&lt;/div&gt;</span>
    <span class="token function">end</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token comment">// ...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token comment">// 解析 文本 时调用</span>
    <span class="token function">chars</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">text</span><span class="token operator">:</span> string<span class="token punctuation">,</span> start<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span> end<span class="token operator">?</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 这里会判断判断很多东西，来看它是不是带变量的动态文本</span>
      <span class="token comment">// 然后创建动态文本或静态文本对应的 AST 节点</span>
     <span class="token comment">// ...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    
    <span class="token comment">// 解析到注释时调用</span>
    <span class="token function">comment</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">text</span><span class="token operator">:</span> string<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
</code></pre> 
<p>上面解析文本时调用的 <code>chars()</code> 会根据不同类型节点加上不同 <code>type</code>，来标记 AST <code>节点类型</code>，这个属性在下一步标记的时候会用到。</p> 
<table><thead><tr><th>type</th><th>AST节点类型</th></tr></thead><tbody><tr><td>1</td><td>元素节点</td></tr><tr><td>2</td><td>包含变量的动态文本节点</td></tr><tr><td>3</td><td>没有变量的纯文本节点（静态节点）</td></tr></tbody></table> 
<h3><a id="optimize___178"></a>optimize() - 优化阶段</h3> 
<p>这个函数就是在 <code>AST</code> 里找出 <code>静态节点 和 静态根节点</code>，并添加<code>标记</code>，为了后面 <code>patch</code> 过程中就会跳过静态节点的对比，直接<code>克隆</code>一份过去，从而优化了 <code>patch</code> 的性能。这个我们在上一篇虚拟dom和diff算法里也讲过（patchVnode 函数）。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// src/compiler/optimizer.ts</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">optimize</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">root</span><span class="token operator">:</span> ASTElement <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  <span class="token literal-property property">options</span><span class="token operator">:</span> CompilerOptions</span>
<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span>
  isStaticKey <span class="token operator">=</span> <span class="token function">genStaticKeysCached</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>staticKeys <span class="token operator">||</span> <span class="token string">''</span><span class="token punctuation">)</span>
  isPlatformReservedTag <span class="token operator">=</span> options<span class="token punctuation">.</span>isReservedTag <span class="token operator">||</span> no
  <span class="token comment">// 标记静态节点</span>
  <span class="token function">markStatic</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
  <span class="token comment">// 标记静态根节点</span>
  <span class="token function">markStaticRoots</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>具体函数里面的代码，大致过程是这样的：（有个了解就好）</p> 
<p><strong>标记静态节点（markStatic）</strong>：就是判断 type 值，参考上面表格。</p> 
<ul><li>type值为1：就是包含子元素的节点；设置 static 为 false；并递归子节点，直到标记完所有的子节点。</li><li>type值为2：设置 static 为 false。</li><li>type值为3：就是不包含子节点和动态属性的纯文本节点，设置 static 为 true；patch的时候就会跳过这个，直接克隆一份过去。</li></ul> 
<p><strong>标记静态根节点（markStaticRoots）</strong>：静态根节点是指在组件渲染过程中不会发生变化的整个子树；原理和标记静态节点基本相同，只是需要满足下面条件的节点才算是静态根节点。</p> 
<ul><li>节点本身必须是静态节点</li><li>必须有子节点</li><li>子节点不能只有一个文本节点</li></ul> 
<h3><a id="generate___211"></a>generate() - 生成阶段</h3> 
<p>这个就是生成 <code>render 函数字符串</code> ，就是说最终会返回下面这样的东西。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 比如有这么个模板</span>
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span> name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token comment">// 上面模板编译后返回的 render 字段 就是这样的</span>
<span class="token literal-property property">render</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">with(this){return _c('div',{attrs:{"id":"app"}},[_v(_s(name))])}</span><span class="token template-punctuation string">`</span></span>

<span class="token comment">// 把内容格式化一下，容易理解一点</span>
<span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token function">_c</span><span class="token punctuation">(</span>
    <span class="token string">'div'</span><span class="token punctuation">,</span>
    <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">attrs</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span><span class="token string-property property">"id"</span><span class="token operator">:</span><span class="token string">"app"</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>  <span class="token function">_v</span><span class="token punctuation">(</span><span class="token function">_s</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>了解虚拟 DOM 就可以看出来，上面的 render 正是虚拟 DOM 的结构，就是把一个标签分为 <code>tag</code>、<code>props</code>、<code>children</code>。<br> 在看 generate 源码之前，我们要先了解一下上面这最后返回的 <code>render</code> 字段是什么意思。</p> 
<h4><a id="1_render__with__234"></a>（1）了解 render函数字符串 和 with 语法</h4> 
<p>这个 <code>with</code> 是用来欺骗词法作用域的关键字，它可以让我们更快的引用一个对象上的多个属性。</p> 
<p>下面先用一个例子来展示 with 语法与普通语法的不同。<br> 不使用with语法执行程序时：</p> 
<pre><code class="prism language-javascript"> <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'铁锤妹妹'</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span> <span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 铁锤妹妹</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// 18</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>sex<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
</code></pre> 
<p>使用with语法执行程序时：</p> 
<pre><code class="prism language-javascript"> <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'铁锤妹妹'</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span> <span class="token punctuation">}</span>
 <span class="token keyword">with</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment">// 铁锤妹妹  不需要写 obj.name 了</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token comment">// 18   不需要写 obj.age了</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sex<span class="token punctuation">)</span> <span class="token comment">// 会报错！！！</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p><strong>with 语法总结：</strong></p> 
<ul><li>with 语法会改变词法作用域中的属性指向，当做 obj 属性来查找。</li><li>如果在 <code>{ }</code> 内找不到匹配的 <code>obj</code> 属性会报错。</li><li><code>with</code> 要谨慎使用，它打破了 <code>作用域规则</code>，会让其 <code>易读性变差</code>。</li></ul> 
<p>那 <code>_c、 _v 和 _s</code> 是什么呢？</p> 
<pre><code class="prism language-javascript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">installRenderHelpers</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">target</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  target<span class="token punctuation">.</span>_s <span class="token operator">=</span> toString  <span class="token comment">// 转字符串函数</span>
  target<span class="token punctuation">.</span>_v <span class="token operator">=</span> createTextVNode  <span class="token comment">// 创建文本节点函数</span>
<span class="token punctuation">}</span>

<span class="token comment">// 补充</span>
_c <span class="token operator">=</span> createElement <span class="token comment">// 创建虚拟节点函数</span>
</code></pre> 
<p>到此为止我们再来看下返回的 render 字段，就会清楚多了。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 欺骗词法作用域，将该作用域里所有属姓和方法都指向当前组件</span>
  <span class="token keyword">return</span> <span class="token function">_c</span><span class="token punctuation">(</span> <span class="token comment">// 创建一个虚拟节点</span>
    <span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token comment">// 标签为 div</span>
    <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">attrs</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span><span class="token string-property property">"id"</span><span class="token operator">:</span><span class="token string">"app"</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 有一个属性 id 为 'app'</span>
    <span class="token punctuation">[</span>  <span class="token function">_v</span><span class="token punctuation">(</span><span class="token function">_s</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span> <span class="token comment">// 是一个文本节点，所以把获取到的动态属性 name 转成字符串</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>接下来我们再来看 generate() 源码。</p> 
<h4><a id="2generate_286"></a>（2）generate</h4> 
<p>就是先判断 AST 是不是为空，不为空就根据 AST 创建 vnode，否则就创建一个空div 的 vnode。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// src/complier/codegen/index.ts</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">generate</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">ast</span><span class="token operator">:</span> ASTElement <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  <span class="token literal-property property">options</span><span class="token operator">:</span> CompilerOptions</span>
<span class="token punctuation">)</span><span class="token operator">:</span> CodegenResult <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CodegenState</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
  <span class="token comment">// 就是先判断 AST 是不是为空，不为空就根据 AST 创建 vnode，否则就创建一个空div的 vnode</span>
  <span class="token keyword">const</span> code <span class="token operator">=</span> ast
    <span class="token operator">?</span> ast<span class="token punctuation">.</span>tag <span class="token operator">===</span> <span class="token string">'script'</span>
      <span class="token operator">?</span> <span class="token string">'null'</span>
      <span class="token operator">:</span> <span class="token function">genElement</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token string">'_c("div")'</span>
  <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">render</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">with(this){return </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>code<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">}</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    <span class="token literal-property property">staticRenderFns</span><span class="token operator">:</span> state<span class="token punctuation">.</span>staticRenderFns
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看出这里面主要就是通过 <code>genElement()</code> 方法来创建 <code>vnode</code> 的，所以我们来看一下它的源码，看是怎么创建的。</p> 
<h4><a id="3genElement_310"></a>（3）genElement()</h4> 
<p>就是一堆 <code>if/else</code> 判断传进来的 AST 元素节点的属性来执行不同的生成函数。<br> 这里还可以发现另一个知识点： <strong><code>v-for 的优先级要高于 v-if，因为先判断 for 的</code></strong>。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// src/complier/codegen/index.ts</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">genElement</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">el</span><span class="token operator">:</span> ASTElement<span class="token punctuation">,</span> <span class="token literal-property property">state</span><span class="token operator">:</span> CodegenState</span><span class="token punctuation">)</span><span class="token operator">:</span> string <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    el<span class="token punctuation">.</span>pre <span class="token operator">=</span> el<span class="token punctuation">.</span>pre <span class="token operator">||</span> el<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>pre
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>staticRoot <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>el<span class="token punctuation">.</span>staticProcessed<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">genStatic</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>once <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>el<span class="token punctuation">.</span>onceProcessed<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// v-once</span>
    <span class="token keyword">return</span> <span class="token function">genOnce</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>for <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>el<span class="token punctuation">.</span>forProcessed<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">// v-for</span>
    <span class="token keyword">return</span> <span class="token function">genFor</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>if <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>el<span class="token punctuation">.</span>ifProcessed<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">// v-if</span>
    <span class="token keyword">return</span> <span class="token function">genIf</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
    
    <span class="token comment">// template 节点 &amp;&amp; 没有插槽 &amp;&amp; 没有 pre 标签</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>tag <span class="token operator">===</span> <span class="token string">'template'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>el<span class="token punctuation">.</span>slotTarget <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>state<span class="token punctuation">.</span>pre<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">genChildren</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">'void 0'</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>tag <span class="token operator">===</span> <span class="token string">'slot'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">// v-slot</span>
    <span class="token keyword">return</span> <span class="token function">genSlot</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// component or element</span>
    <span class="token keyword">let</span> code
    <span class="token comment">// 如果有子组件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>component<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      code <span class="token operator">=</span> <span class="token function">genComponent</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>component<span class="token punctuation">,</span> el<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">let</span> data
      <span class="token keyword">const</span> maybeComponent <span class="token operator">=</span> state<span class="token punctuation">.</span><span class="token function">maybeComponent</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
      <span class="token comment">// 获取元素属性 props</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>el<span class="token punctuation">.</span>plain <span class="token operator">||</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>pre <span class="token operator">&amp;&amp;</span> maybeComponent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        data <span class="token operator">=</span> <span class="token function">genData</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">let</span> <span class="token literal-property property">tag</span><span class="token operator">:</span> string <span class="token operator">|</span> <span class="token keyword">undefined</span>
      <span class="token keyword">const</span> bindings <span class="token operator">=</span> state<span class="token punctuation">.</span>options<span class="token punctuation">.</span>bindings
      <span class="token keyword">if</span> <span class="token punctuation">(</span>maybeComponent <span class="token operator">&amp;&amp;</span> bindings <span class="token operator">&amp;&amp;</span> bindings<span class="token punctuation">.</span>__isScriptSetup <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        tag <span class="token operator">=</span> <span class="token function">checkBindingType</span><span class="token punctuation">(</span>bindings<span class="token punctuation">,</span> el<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tag<span class="token punctuation">)</span> tag <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">'</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>el<span class="token punctuation">.</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'</span><span class="token template-punctuation string">`</span></span>
      <span class="token comment">// 获取元素子节点</span>
      <span class="token keyword">const</span> children <span class="token operator">=</span> el<span class="token punctuation">.</span>inlineTemplate <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">genChildren</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
      code <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">_c(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>
        data <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token string">''</span> <span class="token comment">// data</span>
      <span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>
        children <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>children<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token string">''</span> <span class="token comment">// children</span>
      <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> state<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      code <span class="token operator">=</span> state<span class="token punctuation">.</span>transforms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> code<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回上面作为 with 作用域执行的内容</span>
    <span class="token keyword">return</span> code
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>每一种类型调用的生成函数就不一一列举了，总的来说最后创建出来的 vnode 节点类型无非就三种，元素节点、文本节点、注释节点</p> 
<h2><a id="__373"></a>四、组件渲染/更新 完整过程</h2> 
<h3><a id="_374"></a>初识组件渲染/更新</h3> 
<p>讲完上完的内容，我们再来讲一个与 编译模板 关联性很强的知识点：<strong><code>组件渲染/更新过程</code></strong>。</p> 
<p>一个组件，从 渲染到页面上开始，再到修改 data 去触发更新（数据驱动视图），它背后的原理是什么，下面是需要掌握的要点。</p> 
<ul><li><strong>事实上，组件在渲染之前，会先进行 <code>模板编译</code>，模板 <code>template</code> 会编译成 <code>render</code> 函数。</strong></li><li><strong>之后就是数据的监听了，就是vue的 <code>响应式数据</code> 。通过操作 <code>Object.defineProperty()</code>，去监听 <code>data</code> 属性，触发<code>getter</code> 和 <code>setter</code>方法，来实现数据实时更新。</strong></li><li><strong>监听完数据之后，就是执行 <code>render</code> 函数，生成 <code>vnode</code>。</strong></li><li><strong>到了 <code>vnode</code> （即vdom）这一步后，会进行 <code>patch(elem,vnode)</code> 和 <code>patch(vnode,newVnode)</code> 的比较。根据对比的结果，Vue 会将更新的内容应用到 <code>真实 DOM</code> 上，使页面显示与最新的虚拟 DOM 结果保持一致。</strong></li></ul> 
<p>这一部分还是挺重要的，前几篇文章我们明白了如何生成 render渲染函数、数据响应式原理、什么是虚拟dom？diff算法？但是对于它们之间的联系还是有些模糊的，这里就直接把前几篇的内容串联起来了。继续往下看吧。</p> 
<p>如有需要，可去查看我的前几篇文章学习。<br> <a href="https://blog.csdn.net/weixin_45811256/article/details/131708328">Vue源码学习 - new Vue初始化都做了什么？</a><br> <a href="https://blog.csdn.net/weixin_45811256/article/details/131713560">Vue源码学习 - 数据响应式原理</a><br> <a href="https://blog.csdn.net/weixin_45811256/article/details/131815014">Vue源码学习 - 虚拟Dom 和 diff算法</a></p> 
<h3><a id="_392"></a>组件渲染/更新过程</h3> 
<p>组件渲染和更新过程主要经过以下三个步骤：<strong><code>初次渲染过程 =》 更新过程 =》 异步渲染</code></strong>。</p> 
<h4><a id="1_394"></a>（1）初次渲染过程</h4> 
<p>初次渲染过程，即组件第一次渲染是怎么样的。具体有以下 三个步骤：（参考vue生命周期）</p> 
<ul><li><strong>解析组件模板</strong>：解析 <code>template</code> 模板为 <code>render</code> 函数。</li><li><strong>创建组件实例</strong>：在渲染之前，Vue 会创建组件的实例。（会初始化组件的props，data，methods，computed，watch）</li><li><strong>触发响应式</strong>：当组件实例化之后，将数据传递给 <code>render</code> 函数 进行渲染时，会监听 <code>data</code> 属性 ，触发<code>getter</code> 和 <code>setter</code> 方法。</li><li><strong>执行渲染函数</strong>：执行 <code>render</code> 渲染函数，生成 <code>vnode</code>，进行 <code>patch(elem,vnode)</code> 。</li></ul> 
<p>下面就这几个步骤来进行依次讲解。</p> 
<p><strong>1.1）触发响应式</strong><br> 监听 <code>data</code> 属性，这时我们就需要触发响应式，也就是渲染数据。</p> 
<p>这个阶段我们需要执行 <code>render</code> 函数， <code>render</code> 函数会触发 <code>getter</code> 方法，因为数据没有进行更新，只是进行渲染。只有在进行更新的时候才会操作 <code>setter</code> 方法。</p> 
<p><strong>1.2）执行渲染函数</strong><br> 最后，当数据渲染完毕后，就会执行第一步生成的 <code>render</code> 渲染函数，渲染函数会根据组件的状态和数据生成 <code>虚拟DOM树</code> ，之后进行 <code>patch(elem,vnode)</code>。</p> 
<h4><a id="2_413"></a>（2）更新过程</h4> 
<p>在这个阶段，将会修改 <code>data</code>，并且触发 <code>setter</code>（注意：在此之前 <code>data</code> 在 <code>getter</code> 中已经被依赖收集、监听）</p> 
<p>触发完 <code>setter</code> 之后，重新执行 <code>render</code> 函数，并生成 <code>newVode</code>，最后进行 <code>patch(vnode, newVode)</code>的 diff 比较。</p> 
<p>通过对比，Vue 可以找出需要进行更新的部分，从而减少操作真实 DOM 的次数。根据对比的结果，Vue 会将更新的内容应用到真实 DOM 上，使页面显示与最新的虚拟 DOM 结果保持一致。</p> 
<p>组件渲染/更新完整流程图：（用一张网上的图片）<br> <img src="https://images2.imgbox.com/b8/a9/GInxXxY9_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_425"></a>（3）异步渲染</h4> 
<p>在渲染和更新结束之后，我们的程序可能还有可能会发生 <code>多个程序</code> 同时加载，这就涉及到一个 <code>异步渲染</code> 问题。</p> 
<p><strong>多个数据变更，直接更新视图多次的话，性能就会降低，所以对视图更新做一个异步更新的队列，避免不必要的计算和 DOM 操作。在下一轮事件循环的时候，刷新队列并执行已去重的工作（nextTick的回调函数），组件重新渲染，更新视图。</strong></p> 
<p>异步渲染问题，我们用 <code>$nextTick</code> 来解决。</p> 
<p>对DOM异步更新渲染视图，感兴趣的可以移步去看另一篇系列文章： <a href="https://blog.csdn.net/weixin_45811256/article/details/131814963">Vue源码学习 - 异步更新队列 和 nextTick原理</a></p> 
<h3><a id="_434"></a>疑问点整理</h3> 
<p><strong>1. Vue 组件在渲染过程中为什么不直接加载数据，而是先解析模板转化成一个 render 函数呢？</strong></p> 
<blockquote> 
 <p>render 函数字符串的生成是在 <code>beforeCreate</code> 钩子函数之前完成的。<br> 这是因为 Vue 的渲染过程可以分为两个阶段：<code>编译阶段</code> 和 <code>运行阶段</code>。</p> 
 <ul><li><strong>编译阶段</strong>：在组件被实例化之前，需要先进行模板编译。这个阶段会将模板解析并转换为可执行的 render 函数。编译阶段会分析模板的结构和指令，生成一个抽象语法树（AST），然后根据 AST 生成 render 函数。在这个阶段，Vue并不会加载实际的数据，因为具体的数据是在组件实例化后才传入的。</li><li><strong>运行阶段</strong>：在组件实例化后，会触发运行阶段。Vue会调用之前生成的 render 函数，并将组件的数据传入。这时候，render 函数会根据传入的数据生成 虚拟DOM，并进行 diff 算法的对比，最终更新到 真实DOM 上。</li></ul> 
</blockquote> 
<p><strong>2. 将数据与渲染过程分开的好处？</strong></p> 
<blockquote> 
 <ul><li><strong>分离关注点</strong>：将模板和数据分开，使得组件的关注点更加清晰。模板负责描述组件的结构和样式，而数据负责描述组件的状态和行为。这样可以使得组件的开发更加模块化和可维护。</li><li><strong>性能优化</strong>：通过将模板编译为 render 函数，Vue 可以在编译阶段进行一些优化操作，如静态节点提前标记、事件监听器的优化等。这样可以减少运行时的开销，提高组件的渲染性能。</li></ul> 
</blockquote> 
<p>可参考：<br> <a href="https://juejin.cn/post/7011294489335562247" rel="nofollow">render 函数是怎么来的？深入浅出 Vue 中的模板编译</a><br> <a href="https://juejin.cn/post/6978965732633608222" rel="nofollow">模板编译template的背后，究竟发生了什么事？</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5463ae8c7a0c5be08909af37494aeab2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu更改开机默认启动内核</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d20ef789dc6447c2b249901b8ddb968b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">日增进：如何用sql求基金连涨、连跌天数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>