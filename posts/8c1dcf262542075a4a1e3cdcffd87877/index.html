<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode刷题总结文档 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LeetCode刷题总结文档" />
<meta property="og:description" content="前言 本文的刷题顺序依照代码随想录进行，因此题目板块的划分也和代码随想录一致。每个版块我会按照以下内容进行组织：
该类型题目的特征时间复杂度值得一讲的相关题目知识
文章目录 前言正文数组二分查找移除元素 &amp; 有序数组的平方 &amp; 长度最小的子数组螺旋矩阵总结 链表设计链表k个一组翻转链表环形链表 &amp; 删除倒数第k个链表节点总结 哈希表字符匹配数组k个元素之和等于特定值总结 字符串反转字符串字符串匹配（比哈希表中的字符匹配更为复杂）总结 栈和队列栈的相关应用队列的相关应用 二叉树深度优先遍历广度优先遍历（层序遍历）二叉树解题技巧总结 回溯算法组合问题排列问题有向图的所有可行路径棋盘问题总结 贪心算法对有左右比较关系的数组使用贪心算法对进行包含关系的数组使用贪心算法巧用状态转移，简化贪婪判断 动态规划类型题总结1------背包问题类型题总结2------股票买卖的最佳时机类型题总结3------子序列与子数组相关问题 单调栈图多线程编程通用的细节问题 正文 数组 二分查找 特征：有序数组中找特定组合的快速查询方法时间复杂度： O ( l o g n ) O(logn) O(logn)值得一讲的相关题目知识： 对于求平方根的题目：#69 x的平方根和#367 有效的完全平方数 如果是截取式返回，便可以将其转化成一个查找问题，采用二分法快速定位到应截取的整数平方根；也可以采用牛顿迭代法， x n &#43; 1 = x n − f ( x n ) / f ′ ( x n ) x_{n&#43;1}=x_n-f(x_n)/f&#39;(x_n) xn&#43;1​=xn​−f(xn​)/f′(xn​)，但需要注意的是，面对截取式返回而采用牛顿迭代法，必须保证f(x)的单调性，同时初始取值必须大于截取的整数平方根，否则可能出现1.99999被截取为1的情形（正确值应该是2） 移除元素 &amp; 有序数组的平方 &amp; 长度最小的子数组 特征 要求只遍历一遍数组就解决问题，不要重复遍历要求原地操作，最好不使用新的空间来存储数组 时间复杂度： O ( n ) O(n) O(n)，空间复杂度： O ( 1 ) O(1) O(1)值得一讲的相关题目知识： 该类题目在只遍历一遍数组的限制下，核心要义就是使用双指针，通过指针的不同作用，来完成原地操作更新值的需求。 比如#26 删除有序数组中的重复项和#283 移动零使用的快慢指针，快指针用来遍历数组，慢指针则用来指向更新位置或者#977 有序数组的平方中双指针分别指向首和尾，从首尾两个方向依序从大到小插入至新数组又如#209 长度最小的子数组，采用滑动窗口思想，双指针分别代表窗口的起始和终止位置，窗口内的累加和始终保持小于目标值的状态，每遇到一次大于等于情况发生，记录一次最小长度还有#76 最小覆盖子串，也是采用滑动窗口思想，窗口内始终保持小于覆盖目标字符串状态 螺旋矩阵 特征 要求按照→↓←↑的顺序遍历二维数组（因为该顺序像螺旋一样，故得名） 时间复杂度： O ( n 2 ) O(n^2) O(n2)，空间复杂度： O ( 1 ) O(1) O(1)我的解题思路：在这里，我对边界的设置与代码随想录的想法不同，左右视为列遍历，由column控制for循环上限；上下视为行遍历，由row控制for循环上限。每执行完一次列/行遍历，row/column减一上限。直至row或column其中一个为0。该方案的好处是完全不需要关心矩阵最后一行/列如何特殊处理，都是由一个统一原则控制，代码如下 总结 数组部分的困难题目主要体现在字符串的各种操作上，如#76 最小覆盖子串这种。这种类型虽然难，但我总结出了两条通用的技巧：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8c1dcf262542075a4a1e3cdcffd87877/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-19T16:39:31+08:00" />
<meta property="article:modified_time" content="2023-09-19T16:39:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode刷题总结文档</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p>本文的刷题顺序依照<a href="https://programmercarl.com/" rel="nofollow">代码随想录</a>进行，因此题目板块的划分也和代码随想录一致。每个版块我会按照以下内容进行组织：</p> 
<ul><li>该类型题目的特征</li><li>时间复杂度</li><li>值得一讲的相关题目知识<br> 
  <div class="toc"> 
   <h4>文章目录</h4> 
   <ul><li><ul><li><a href="#_0" rel="nofollow">前言</a></li><li><a href="#_7" rel="nofollow">正文</a></li><li><ul><li><a href="#_8" rel="nofollow">数组</a></li><li><ul><li><a href="#_9" rel="nofollow">二分查找</a></li><li><a href="#_____16" rel="nofollow">移除元素 &amp; 有序数组的平方 &amp; 长度最小的子数组</a></li><li><a href="#_27" rel="nofollow">螺旋矩阵</a></li><li><a href="#_33" rel="nofollow">总结</a></li></ul> 
      </li><li><a href="#_42" rel="nofollow">链表</a></li><li><ul><li><a href="#_43" rel="nofollow">设计链表</a></li><li><a href="#k_50" rel="nofollow">k个一组翻转链表</a></li><li><a href="#__k_61" rel="nofollow">环形链表 &amp; 删除倒数第k个链表节点</a></li><li><a href="#_71" rel="nofollow">总结</a></li></ul> 
      </li><li><a href="#_80" rel="nofollow">哈希表</a></li><li><ul><li><a href="#_84" rel="nofollow">字符匹配</a></li><li><a href="#k_91" rel="nofollow">数组k个元素之和等于特定值</a></li><li><a href="#_101" rel="nofollow">总结</a></li></ul> 
      </li><li><a href="#_112" rel="nofollow">字符串</a></li><li><ul><li><a href="#_113" rel="nofollow">反转字符串</a></li><li><a href="#_123" rel="nofollow">字符串匹配（比哈希表中的字符匹配更为复杂）</a></li><li><a href="#_138" rel="nofollow">总结</a></li></ul> 
      </li><li><a href="#_159" rel="nofollow">栈和队列</a></li><li><ul><li><a href="#_169" rel="nofollow">栈的相关应用</a></li><li><a href="#_178" rel="nofollow">队列的相关应用</a></li></ul> 
      </li><li><a href="#_188" rel="nofollow">二叉树</a></li><li><ul><li><a href="#_193" rel="nofollow">深度优先遍历</a></li><li><a href="#_203" rel="nofollow">广度优先遍历（层序遍历）</a></li><li><a href="#_210" rel="nofollow">二叉树解题技巧</a></li><li><a href="#_224" rel="nofollow">总结</a></li></ul> 
      </li><li><a href="#_233" rel="nofollow">回溯算法</a></li><li><ul><li><a href="#_234" rel="nofollow">组合问题</a></li><li><a href="#_247" rel="nofollow">排列问题</a></li><li><a href="#_253" rel="nofollow">有向图的所有可行路径</a></li><li><a href="#_257" rel="nofollow">棋盘问题</a></li><li><a href="#_262" rel="nofollow">总结</a></li></ul> 
      </li><li><a href="#_266" rel="nofollow">贪心算法</a></li><li><ul><li><a href="#_267" rel="nofollow">对有左右比较关系的数组使用贪心算法</a></li><li><a href="#_271" rel="nofollow">对进行包含关系的数组使用贪心算法</a></li><li><a href="#_279" rel="nofollow">巧用状态转移，简化贪婪判断</a></li></ul> 
      </li><li><a href="#_288" rel="nofollow">动态规划</a></li><li><ul><li><a href="#1_289" rel="nofollow">类型题总结1------背包问题</a></li><li><a href="#2_306" rel="nofollow">类型题总结2------股票买卖的最佳时机</a></li><li><a href="#3_318" rel="nofollow">类型题总结3------子序列与子数组相关问题</a></li></ul> 
      </li><li><a href="#_334" rel="nofollow">单调栈</a></li><li><a href="#_343" rel="nofollow">图</a></li><li><a href="#_351" rel="nofollow">多线程编程</a></li><li><a href="#_365" rel="nofollow">通用的细节问题</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </div></li></ul> 
<h3><a id="_7"></a>正文</h3> 
<h4><a id="_8"></a>数组</h4> 
<h5><a id="_9"></a>二分查找</h5> 
<ul><li>特征：<strong>有序数组</strong>中找<strong>特定组合</strong>的<strong>快速查询</strong>方法</li><li>时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          l 
         
        
          o 
         
        
          g 
         
        
          n 
         
        
          ) 
         
        
       
         O(logn) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></li><li>值得一讲的相关题目知识： 
  <ul><li>对于求平方根的题目：<a href="https://leetcode.cn/problems/sqrtx/" rel="nofollow">#69 x的平方根</a>和<a href="https://leetcode.cn/problems/valid-perfect-square/" rel="nofollow">#367 有效的完全平方数</a> 
    <ul><li>如果是截取式返回，便可以将其转化成一个查找问题，采用二分法快速定位到应截取的整数平方根；也可以采用牛顿迭代法，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
             
             
               x 
              
              
              
                n 
               
              
                + 
               
              
                1 
               
              
             
            
              = 
             
             
             
               x 
              
             
               n 
              
             
            
              − 
             
            
              f 
             
            
              ( 
             
             
             
               x 
              
             
               n 
              
             
            
              ) 
             
            
              / 
             
             
             
               f 
              
             
               ′ 
              
             
            
              ( 
             
             
             
               x 
              
             
               n 
              
             
            
              ) 
             
            
           
             x_{n+1}=x_n-f(x_n)/f'(x_n) 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6389em; vertical-align: -0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2083em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.0019em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7519em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，但需要注意的是，面对截取式返回而采用牛顿迭代法，必须保证f(x)的<strong>单调性</strong>，同时<strong>初始取值必须大于截取的整数平方根</strong>，否则可能出现1.99999被截取为1的情形（正确值应该是2）</li></ul> </li></ul> </li></ul> 
<h5><a id="_____16"></a>移除元素 &amp; 有序数组的平方 &amp; 长度最小的子数组</h5> 
<ul><li>特征 
  <ul><li>要求<strong>只遍历一遍数组</strong>就解决问题，不要重复遍历</li><li>要求<strong>原地操作</strong>，最好不使用新的空间来存储数组</li></ul> </li><li>时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         O(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，空间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          1 
         
        
          ) 
         
        
       
         O(1) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></li><li>值得一讲的相关题目知识： 
  <ul><li>该类题目在只遍历一遍数组的限制下，核心要义就是使用双指针，通过指针的不同作用，来完成原地操作更新值的需求。 
    <ul><li>比如<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/" rel="nofollow">#26 删除有序数组中的重复项</a>和<a href="https://leetcode.cn/problems/move-zeroes/" rel="nofollow">#283 移动零</a>使用的<strong>快慢指针</strong>，快指针用来遍历数组，慢指针则用来指向更新位置</li><li>或者<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/" rel="nofollow">#977 有序数组的平方</a>中双指针分别指向<strong>首和尾</strong>，从首尾两个方向依序从大到小插入至新数组</li><li>又如<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/" rel="nofollow">#209 长度最小的子数组</a>，采用<strong>滑动窗口思想</strong>，双指针分别代表窗口的起始和终止位置，窗口内的累加和始终保持小于目标值的状态，每遇到一次大于等于情况发生，记录一次最小长度</li><li>还有<a href="https://leetcode.cn/problems/minimum-window-substring/description/" rel="nofollow">#76 最小覆盖子串</a>，也是采用<strong>滑动窗口思想</strong>，窗口内始终保持小于覆盖目标字符串状态</li></ul> </li></ul> </li></ul> 
<h5><a id="_27"></a>螺旋矩阵</h5> 
<ul><li>特征 
  <ul><li>要求按照→↓←↑的顺序遍历二维数组（因为该顺序像螺旋一样，故得名）</li></ul> </li><li>时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
         
         
           n 
          
         
           2 
          
         
        
          ) 
         
        
       
         O(n^2) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，空间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          1 
         
        
          ) 
         
        
       
         O(1) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></li><li>我的解题思路：在这里，我对边界的设置与代码随想录的想法不同，左右视为列遍历，由column控制for循环上限；上下视为行遍历，由row控制for循环上限。每执行完一次列/行遍历，row/column减一上限。直至row或column其中一个为0。该方案的好处是完全不需要关心矩阵最后一行/列如何特殊处理，都是由一个统一原则控制，<a href="https://leetcode.cn/problems/spiral-matrix-ii/solutions/2020179/luo-xuan-ju-zhen-qiu-jie-si-lu-by-ce-shi-70kw/" rel="nofollow">代码如下</a></li></ul> 
<h5><a id="_33"></a>总结</h5> 
<p>数组部分的困难题目主要体现在字符串的各种操作上，如<a href="https://leetcode.cn/problems/minimum-window-substring/description/" rel="nofollow">#76 最小覆盖子串</a>这种。这种类型虽然难，但我总结出了两条通用的技巧：</p> 
<ul><li>大多采用<strong>滑动窗口法</strong>，通过滑动窗口来保证一次遍历完成任务</li><li>记住ASCII码上限为128，可通过<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          i 
         
        
          n 
         
        
          t 
         
        
          [ 
         
        
          128 
         
        
          ] 
         
        
       
         int[128] 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">128</span><span class="mclose">]</span></span></span></span></span>来表示所有ASCII的映射，比利用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          M 
         
        
          a 
         
        
          p 
         
        
       
         Map 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>进行相关操作更加简洁</li></ul> 
<p>另外，数组结构在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         J 
        
       
         a 
        
       
         v 
        
       
         a 
        
       
      
        Java 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0962em;">J</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">a</span></span></span></span></span>中作为以下类的底层实现：</p> 
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          A 
         
        
          r 
         
        
          r 
         
        
          a 
         
        
          y 
         
        
          L 
         
        
          i 
         
        
          s 
         
        
          t 
         
        
       
         ArrayList 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right: 0.0278em;">rr</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span></span>：所以该类的删除操作时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         O(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，这是在编程中经常被忽视的一点</li></ul> 
<p><img src="https://images2.imgbox.com/c8/52/FUlBX8wE_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_42"></a>链表</h4> 
<h5><a id="_43"></a>设计链表</h5> 
<ul><li>特征： 
  <ul><li>全面的链表基础题，要求完成链表的增删查功能</li></ul> </li><li>时间复杂度：查询为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         O(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，增删操作为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          1 
         
        
          ) 
         
        
       
         O(1) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>（这是链表结构的特点，<strong>查询慢，增删快</strong>）</li><li>值得一讲的相关题目知识： 
  <ul><li><a href="https://leetcode.cn/problems/design-linked-list/description/" rel="nofollow">#707 设计链表</a>这个题有一个需要注意的点，Java中实例化对象是存储存在堆里的，而这部分内存将由JVM的垃圾回收机制在特定的时刻回收。因此，这里为了做到删除链表节点，必须把对该节点的<strong>所有强引用置为null</strong></li></ul> </li></ul> 
<h5><a id="k_50"></a>k个一组翻转链表</h5> 
<ul><li>特征： 
  <ul><li>要求<strong>一次扫描</strong>完成k个一组的翻转，同时要保证在<strong>最后剩余节点总数小于k时，不翻转</strong></li><li>要求原地操作，且必须<strong>移动节点完成翻转而不是交换值</strong></li></ul> </li><li>时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         O(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，空间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          1 
         
        
          ) 
         
        
       
         O(1) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></li><li>值得一讲的相关题目知识： 
  <ul><li>这是一类题，简单的如<a href="https://leetcode.cn/problems/reverse-linked-list/" rel="nofollow">#206 反转链表</a>（此时k为无限大）；中等难度的如<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/" rel="nofollow">#24 两两交换链表中的节点</a>（此时k为2）；困难的如<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/" rel="nofollow">#25 K 个一组翻转链表</a>（此时k为任意值）</li><li>要解决这类题，抓住两个指导思想： 
    <ul><li>k个一组形成子串，子串应该独立翻转，即翻转时应该认为每一子串<strong>都是断开</strong>的</li><li>一组子串的<strong>翻转完成</strong>后，应该完成两件事：一是<strong>串联上一子串</strong>的尾节点；二是<strong>记录当前字串</strong>的尾节点</li></ul> </li></ul> </li></ul> 
<h5><a id="__k_61"></a>环形链表 &amp; 删除倒数第k个链表节点</h5> 
<ul><li>特征： 
  <ul><li>要求<strong>一次扫描</strong>，完成对应条件节点的检索</li><li>要求<strong>原地操作</strong></li></ul> </li><li>时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         O(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，空间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          1 
         
        
          ) 
         
        
       
         O(1) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></li><li>值得一讲的相关题目知识： 
  <ul><li>这里我们仅扩展<a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/" rel="nofollow">#142 环形链表II</a>，因为它包含了两类双指针应用： 
    <ul><li><strong>快慢指针</strong>：快指针遍历速度是慢指针的两倍，从而保证快指针更快到达环内，且在环形内时，每轮移动靠近慢指针的速度为1（不会错过慢指针）</li><li><strong>间隔指针</strong>：由于要求一次扫描，而链表又是难以回溯和直接定位的，所以通过间隔指针来同步扫描链表，从而同时定位相隔k个距离的节点；这种思想在<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" rel="nofollow">#19 删除链表的倒数第 N 个结点</a>中也有所体现</li></ul> </li></ul> </li></ul> 
<h5><a id="_71"></a>总结</h5> 
<p>链表一节，核心有两个：</p> 
<ul><li>应用<strong>虚拟头节点</strong>，解决头节点的pre节点不存在的孤立现象</li><li>应用<strong>双指针法</strong>（我们介绍了两类双指针，分别是<strong>快慢指针</strong>以及<strong>间隔指针</strong>），解决一次扫描与原地操作限制</li></ul> 
<p>另外，链表结构在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         J 
        
       
         a 
        
       
         v 
        
       
         a 
        
       
      
        Java 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0962em;">J</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">a</span></span></span></span></span>中作为以下类的底层实现：</p> 
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          L 
         
        
          i 
         
        
          n 
         
        
          k 
         
        
          e 
         
        
          d 
         
        
          L 
         
        
          i 
         
        
          s 
         
        
          t 
         
        
       
         LinkedList 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right: 0.0315em;">ink</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span></span>：所以该类的查询操作时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         O(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，应尽量避免使用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          L 
         
        
          i 
         
        
          n 
         
        
          k 
         
        
          e 
         
        
          d 
         
        
          L 
         
        
          i 
         
        
          s 
         
        
          t 
         
        
       
         LinkedList 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right: 0.0315em;">ink</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span></span>结构来设计查询过多的业务</li></ul> 
<p><img src="https://images2.imgbox.com/14/35/wSrhgq7Z_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_80"></a>哈希表</h4> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          h 
         
        
          a 
         
        
          s 
         
        
          h 
         
        
          T 
         
        
          a 
         
        
          b 
         
        
          l 
         
        
          e 
         
        
          I 
         
        
          D 
         
        
          = 
         
        
          h 
         
        
          a 
         
        
          s 
         
        
          h 
         
        
          C 
         
        
          o 
         
        
          d 
         
        
          e 
         
        
          ( 
         
        
          k 
         
        
          e 
         
        
          y 
         
        
          ) 
         
        
          % 
         
        
          t 
         
        
          a 
         
        
          b 
         
        
          l 
         
        
          e 
         
        
          S 
         
        
          i 
         
        
          z 
         
        
          e 
         
        
       
         hashTable ID = hashCode(key) \% tableSize 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mord mathnormal" style="margin-right: 0.0359em;">ey</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span></span></span></span></span></span><br> 综上，哈希表就是一个保证<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         1 
        
       
         ) 
        
       
      
        O(1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>查找时间复杂度的工具，也因此被大量用于查找特定元素存在与否的场景</p> 
<h5><a id="_84"></a>字符匹配</h5> 
<ul><li>特征： 
  <ul><li>给定两个字符串，对字符串进行规定的匹配操作</li></ul> </li><li>时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         O(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，空间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         O(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></li><li>值得一讲的相关题目知识： 
  <ul><li>这里涉及到的题目有<a href="https://leetcode.cn/problems/valid-anagram/" rel="nofollow">#242 有效的字母异位词</a>，<a href="https://leetcode.cn/problems/ransom-note/" rel="nofollow">#383 赎金信</a>。这类题目的关键在于认识到字符匹配可以先用哈希表收集字符串各个字符的情况，然后再通过哈希表快速查找某个字符是否出现。这样做可以将<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            O 
           
          
            ( 
           
           
           
             n 
            
           
             2 
            
           
          
            ) 
           
          
         
           O(n^2) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>的时间复杂度缩小至<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            O 
           
          
            ( 
           
          
            n 
           
          
            ) 
           
          
         
           O(n) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>。此外，对于字符匹配，使用<strong>数组结构</strong>做哈希表要远比Map运行速度更快。</li></ul> </li></ul> 
<h5><a id="k_91"></a>数组k个元素之和等于特定值</h5> 
<ul><li>特点： 
  <ul><li>要求返回所有可能的<strong>元素组合</strong>，而不是<strong>位置组合</strong></li><li>要求元素组合<strong>去重</strong></li></ul> </li><li>时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
         
         
           n 
          
          
          
            k 
           
          
            − 
           
          
            1 
           
          
         
        
          ) 
         
        
       
         O(n^{k-1}) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0991em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8491em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，空间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          1 
         
        
          ) 
         
        
       
         O(1) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></li><li>值得一讲的相关题目知识： 
  <ul><li>例如<a href="https://leetcode.cn/problems/3sum/" rel="nofollow">#15 三数之和</a>，<a href="https://leetcode.cn/problems/4sum/" rel="nofollow">#18 四数之和</a>，解题思路抓住两个关键点： 
    <ul><li>（1）如何去重：元素按<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
             
             
               i 
              
             
               1 
              
             
            
              &lt; 
             
            
              . 
             
            
              . 
             
            
              . 
             
            
              . 
             
            
              &lt; 
             
             
             
               i 
              
             
               k 
              
             
            
           
             i_1&lt;....&lt;i_k 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8095em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord">....</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8095em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的顺序，依次加入for循环，保证元素组合<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              ( 
             
             
             
               i 
              
             
               1 
              
             
            
              , 
             
            
              . 
             
            
              . 
             
            
              . 
             
            
              , 
             
             
             
               i 
              
             
               k 
              
             
            
              ) 
             
            
           
             (i_1,...,i_k) 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>是从小到大递增的，此其一；限制<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
             
             
               i 
              
              
              
                1... 
               
              
                k 
               
              
             
            
              ( 
             
            
              t 
             
            
              ) 
             
            
              ! 
             
            
              = 
             
             
             
               i 
              
              
              
                1... 
               
              
                k 
               
              
             
            
              ( 
             
            
              t 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
           
             i_{1...k}(t)!=i_{1...k}(t-1) 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1...</span><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)!</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1...</span><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>，保证同位置元素不重复，此其二。</li><li>（2）如何精简查询过程：<strong>先排序</strong>，保证数组从小到大；固定前k-2个元素，第k-1和k个元素满足<strong>互斥性</strong>，即为了保证和为特定值，<strong>k-1增大必定导致k减小</strong>。因此前者<strong>从前往后</strong>遍历，后者<strong>从后往前</strong>遍历，<strong>相交时</strong>则证明k-1继续向后将无法找到满足和为特定值的组合，退出对k-1的遍历。双指针的使用将两层for循环缩小至一层</li></ul> </li></ul> </li></ul> 
<h5><a id="_101"></a>总结</h5> 
<p>哈希表一节，核心有两个：</p> 
<ul><li>掌握<strong>哈希特征</strong>：用于根据关键词快速查询，查询时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          1 
         
        
          ) 
         
        
       
         O(1) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></li><li>掌握<strong>三类哈希结构</strong>，<strong>数组型</strong>——解决字符统计问题；<strong>Set型</strong>——解决去重统计问题；<strong>Map型</strong>——解决需要明确的<strong>Key-Value</strong>结构问题</li></ul> 
<p>由于Map和Set都需要额外维护哈希表，因此不管是修改还是查询速度，两者都是要慢于数组型的</p> 
<p>如上所述，哈希结构在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         J 
        
       
         a 
        
       
         v 
        
       
         a 
        
       
      
        Java 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0962em;">J</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">a</span></span></span></span></span>中作为以下类的底层实现：</p> 
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          H 
         
        
          a 
         
        
          s 
         
        
          h 
         
        
          S 
         
        
          e 
         
        
          t 
         
        
       
         HashSet 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span></span>：作用为去重统计和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          1 
         
        
          ) 
         
        
       
         O(1) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>查询</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          H 
         
        
          a 
         
        
          s 
         
        
          h 
         
        
          M 
         
        
          a 
         
        
          p 
         
        
       
         HashMap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>：作用为Key-Value映射和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          1 
         
        
          ) 
         
        
       
         O(1) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>查询</li></ul> 
<h4><a id="_112"></a>字符串</h4> 
<h5><a id="_113"></a>反转字符串</h5> 
<ul><li>特征： 
  <ul><li>给定一个字符串，要求按规定进行整体或局部反转</li></ul> </li><li>时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         O(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，空间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          1 
         
        
          ) 
         
        
       
         O(1) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></li><li>值得一讲的相关题目知识： 
  <ul><li>仅包含整体反转或仅包含局部反转 
    <ul><li>整体反转如<a href="https://leetcode.cn/problems/reverse-string/" rel="nofollow">#344 反转字符串</a>：利用双指针，对反转对应位置进行值交换，直到前指针大于等于后指针</li><li>局部反转如<a href="https://leetcode.cn/problems/reverse-string-ii/" rel="nofollow">#541 反转字符串II</a>：与整体反转原理一致，但需要多次进行</li></ul> </li><li>既包含整体反转，又包含局部反转，从而达到反转语序而局部不变的目的 
    <ul><li>如<a href="https://leetcode.cn/problems/reverse-words-in-a-string/" rel="nofollow">#151 反转字符串中的单词</a>以及<a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" rel="nofollow">#剑指offer58 左旋转字符串</a>：反转原理一致，但需要通过局部的再反转来达到局部顺序归位的目的</li></ul> </li></ul> </li></ul> 
<h5><a id="_123"></a>字符串匹配（比哈希表中的字符匹配更为复杂）</h5> 
<ul><li>特征： 
  <ul><li>给定一个匹配串(n)和模式串(m)，返回模式串在匹配串中第一次出现的位置</li></ul> </li><li>时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          m 
         
        
          + 
         
        
          n 
         
        
          ) 
         
        
       
         O(m+n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，空间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          m 
         
        
          ) 
         
        
       
         O(m) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></li><li>原理性分析（KMP算法简述） 
  <ul><li><strong>真前后缀</strong>：以头字符为开头，某一字符为末尾，范围内所有不包含末尾字符的子串为前缀，所有不包含头字符的子串为后缀</li><li><strong>KMP核心思想</strong>：进行扫描时，模式串当前待匹配字符的<strong>最大前缀字符串</strong>已完成匹配，若当前待匹配字符与匹配串不匹配，取最大前缀字符串的<strong>最大相等前后缀长度</strong>，即可将模式串的对应前缀与匹配串的对应后缀再次对应起来，从而找到新的匹配出发点（而不需要重新查找）</li><li><strong>KMP关键点</strong>：如何求解每个字符<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            i 
           
          
         
           i 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span>的最大相等前后缀长度是问题关键，设该长度以函数<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            π 
           
          
         
           \pi 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span></span></span></span></span>表示，字符串以<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            s 
           
          
         
           s 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></span>表示，在进行以下推导后，我们可以得出使得<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            π 
           
          
            ( 
           
          
            i 
           
          
            ) 
           
          
            = 
           
          
            j 
           
          
            + 
           
          
            1 
           
          
         
           \pi(i)=j+1 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            j 
           
          
         
           j 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span>的表达式: 
    <ul><li>已知<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              π 
             
            
              ( 
             
            
              i 
             
            
              ) 
             
            
              = 
             
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
              + 
             
            
              1 
             
            
           
             \pi(i)=\pi(i-1)+1 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>的前提是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              s 
             
            
              [ 
             
            
              i 
             
            
              ] 
             
            
              = 
             
            
              s 
             
            
              [ 
             
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
              ] 
             
            
           
             s[i]=s[\pi(i-1)] 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)]</span></span></span></span></span>(这部分证明不难，可参见<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/732236/shi-xian-strstr-by-leetcode-solution-ds6y/" rel="nofollow">Leetcode解析</a>)，令<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              j 
             
            
              = 
             
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
           
             j=\pi(i-1) 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>，当<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              s 
             
            
              [ 
             
            
              i 
             
            
              ] 
             
            
              = 
             
            
              s 
             
            
              [ 
             
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
              ] 
             
            
           
             s[i]=s[\pi(i-1)] 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)]</span></span></span></span></span>，就有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              π 
             
            
              ( 
             
            
              i 
             
            
              ) 
             
            
              = 
             
            
              j 
             
            
              + 
             
            
              1 
             
            
           
             \pi(i)=j+1 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span></li><li>如果<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              s 
             
            
              [ 
             
            
              i 
             
            
              ] 
             
            
              ! 
             
            
              = 
             
            
              s 
             
            
              [ 
             
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
              ] 
             
            
           
             s[i]!=s[\pi(i-1)] 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]!</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)]</span></span></span></span></span>，证明<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              π 
             
            
              ( 
             
            
              i 
             
            
              ) 
             
            
              &lt; 
             
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
           
             \pi(i)&lt;\pi(i-1) 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>，而<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
           
             \pi(i-1) 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>的定义给出了等式<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              s 
             
            
              [ 
             
            
              0 
             
            
              : 
             
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
              − 
             
            
              1 
             
            
              ] 
             
            
              = 
             
            
              s 
             
            
              [ 
             
            
              i 
             
            
              − 
             
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
              : 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ] 
             
            
           
             s[0:\pi(i-1)-1]=s[i-\pi(i-1):i-1] 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7429em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span>，其中必存在后缀子串满足<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              s 
             
            
              [ 
             
            
              j 
             
            
              : 
             
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
              − 
             
            
              1 
             
            
              ] 
             
            
              = 
             
            
              s 
             
            
              [ 
             
            
              i 
             
            
              − 
             
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
              + 
             
            
              j 
             
            
              : 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ] 
             
            
           
             s[j:\pi(i-1)-1]=s[i-\pi(i-1)+j:i-1] 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7429em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></li><li>此时，如果能找到一个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              j 
             
            
           
             j 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span>，使得<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              s 
             
            
              [ 
             
            
              0 
             
            
              : 
             
            
              j 
             
            
              − 
             
            
              1 
             
            
              ] 
             
            
              = 
             
            
              s 
             
            
              [ 
             
            
              j 
             
            
              : 
             
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
              − 
             
            
              1 
             
            
              ] 
             
            
           
             s[0:j-1]=s[j:\pi(i-1)-1] 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span>，且<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              s 
             
            
              [ 
             
            
              i 
             
            
              ] 
             
            
              = 
             
            
              s 
             
            
              [ 
             
            
              j 
             
            
              ] 
             
            
           
             s[i]=s[j] 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span></span></span></span></span>时，由于<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              s 
             
            
              [ 
             
            
              0 
             
            
              : 
             
            
              j 
             
            
              − 
             
            
              1 
             
            
              ] 
             
            
              = 
             
            
              s 
             
            
              [ 
             
            
              i 
             
            
              − 
             
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
              + 
             
            
              j 
             
            
              : 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ] 
             
            
           
             s[0:j-1]=s[i-\pi(i-1)+j:i-1] 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7429em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span>，我们仍可以得出<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              π 
             
            
              ( 
             
            
              i 
             
            
              ) 
             
            
              = 
             
            
              j 
             
            
              + 
             
            
              1 
             
            
           
             \pi(i)=j+1 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>。当<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              j 
             
            
              = 
             
            
              π 
             
            
              ( 
             
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
           
             j=\pi(\pi(i-1)-1) 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>时满足<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              s 
             
            
              [ 
             
            
              0 
             
            
              : 
             
            
              j 
             
            
              − 
             
            
              1 
             
            
              ] 
             
            
              = 
             
            
              s 
             
            
              [ 
             
            
              j 
             
            
              : 
             
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
              − 
             
            
              1 
             
            
              ] 
             
            
           
             s[0:j-1]=s[j:\pi(i-1)-1] 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span>，如果此时的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              j 
             
            
           
             j 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span>仍不能使得<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              s 
             
            
              [ 
             
            
              i 
             
            
              ] 
             
            
              = 
             
            
              s 
             
            
              [ 
             
            
              j 
             
            
              ] 
             
            
           
             s[i]=s[j] 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span></span></span></span></span>，则按照递推公式<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              j 
             
            
              = 
             
            
              π 
             
            
              ( 
             
            
              . 
             
            
              . 
             
            
              . 
             
            
              π 
             
            
              ( 
             
            
              . 
             
            
              . 
             
            
              . 
             
            
              ) 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
           
             j=\pi(...\pi(...)-1) 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord">...</span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord">...</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>继续找下去</li><li>综上，我们只需要记住一个<strong>关键点</strong>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              j 
             
            
           
             j 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span>的递推公式为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              π 
             
            
              ( 
             
            
              . 
             
            
              . 
             
            
              . 
             
            
              π 
             
            
              ( 
             
            
              . 
             
            
              . 
             
            
              . 
             
            
              ) 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
           
             \pi(...\pi(...)-1) 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord">...</span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord">...</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>，且初始值设置为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              π 
             
            
              ( 
             
            
              i 
             
            
              − 
             
            
              1 
             
            
              ) 
             
            
           
             \pi(i-1) 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>，当<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              s 
             
            
              [ 
             
            
              i 
             
            
              ] 
             
            
              = 
             
            
              s 
             
            
              [ 
             
            
              j 
             
            
              ] 
             
            
           
             s[i]=s[j] 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span></span></span></span></span>时，才有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              π 
             
            
              ( 
             
            
              i 
             
            
              ) 
             
            
              = 
             
            
              j 
             
            
              + 
             
            
              1 
             
            
           
             \pi(i)=j+1 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span></li></ul> </li><li><strong>KMP实现</strong>：根据关键点，我们可以梳理出实现KMP中的next数组(即<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            π 
           
          
         
           \pi 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span></span></span></span></span>函数)的方法：设立双指针，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            i 
           
          
            = 
           
          
            1 
           
          
            , 
           
          
            j 
           
          
            = 
           
          
            π 
           
          
            ( 
           
          
            0 
           
          
            ) 
           
          
            = 
           
          
            0 
           
          
         
           i=1,j=\pi(0)=0 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span>，当<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            s 
           
          
            [ 
           
          
            i 
           
          
            ] 
           
          
            = 
           
          
            s 
           
          
            [ 
           
          
            j 
           
          
            ] 
           
          
         
           s[i]=s[j] 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span></span></span></span></span>时，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            π 
           
          
            ( 
           
          
            i 
           
          
            ) 
           
          
            = 
           
          
            j 
           
          
            + 
           
          
            1 
           
          
         
           \pi(i)=j+1 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            i 
           
          
         
           i 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            j 
           
          
         
           j 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span>同时向后推，否则令<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            j 
           
          
            = 
           
          
            π 
           
          
            ( 
           
          
            j 
           
          
            − 
           
          
            1 
           
          
            ) 
           
          
         
           j=\pi(j-1) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>，直至满足<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            s 
           
          
            [ 
           
          
            i 
           
          
            ] 
           
          
            = 
           
          
            s 
           
          
            [ 
           
          
            j 
           
          
            ] 
           
          
         
           s[i]=s[j] 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span></span></span></span></span>。若<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            j 
           
          
            = 
           
          
            0 
           
          
         
           j=0 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span>时仍不满足，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            π 
           
          
            ( 
           
          
            i 
           
          
            ) 
           
          
            = 
           
          
            0 
           
          
         
           \pi(i)=0 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            i 
           
          
         
           i 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span>向后推；有了next数组后，只需要一次扫描匹配串，当出现不匹配时，通过next数组回退模式串，匹配串不移动，进行重新匹配工作。</li></ul> </li><li>值得一讲的相关题目知识：<a href="https://leetcode.cn/problems/repeated-substring-pattern/description/" rel="nofollow">#459 重复的子字符串</a>一题中，在使用KMP进行字符串匹配前，先通过一个叠加操作，复制原本的字符串并拼接在字符串后，然后掐头去尾，如果在中间重新找到原字符串，则说明该字符串是具备旋转不变性的，即可得到递推公式<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          s 
         
        
          [ 
         
        
          j 
         
        
          ] 
         
        
          = 
         
        
          s 
         
        
          [ 
         
        
          j 
         
        
          + 
         
        
          i 
         
        
          ] 
         
        
          = 
         
        
          s 
         
        
          [ 
         
        
          j 
         
        
          + 
         
        
          2 
         
        
          i 
         
        
          ] 
         
        
          = 
         
        
          . 
         
        
          . 
         
        
          . 
         
        
       
         s[j]=s[j+i]=s[j+2i]=... 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.1056em;"></span><span class="mord">...</span></span></span></span></span>，即原字符串是可重复的；另一方面，如果原字符串是可重复的，复制一份拼接后就一定可以在中间重新找到原字符串。<strong>因此，当且仅当原字符串可重复，我们才能在中间重新找到原字符串（充分必要）</strong></li></ul> 
<h5><a id="_138"></a>总结</h5> 
<p>字符串相关的题目，由于多数对辅助空间有限制，所以能用到双指针的机会很多；而对于字符串匹配的任务，使用KMP算法可以严格限制时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         m 
        
       
         + 
        
       
         n 
        
       
         ) 
        
       
      
        O(m+n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，其原理性梳理如上，只要掌握所总结的关键点，相信可以顺利写出next数组的生成代码</p> 
<p>这里再总结一些字符串题目的小技巧：</p> 
<ul><li>Java中，直接处理字符串比较难，一般将其转为StringBuilder或char[]来处理</li></ul> 
<pre><code class="prism language-java"><span class="token comment">// 构造</span>
<span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
<span class="token comment">// 修改</span>
sb<span class="token punctuation">.</span><span class="token function">setCharAt</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 删除</span>
sb<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token comment">// 左闭右开</span>
<span class="token comment">// 更多详见https://www.runoob.com/java/java-stringbuffer.html</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token comment">//构造</span>
<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ac <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_159"></a>栈和队列</h4> 
<p>Java中，一般使用LinkedList或ArrayDeque来实现栈和队列，两者的实例化对象相同，仅通过调用方法的不同来区分是栈还是队列</p> 
<blockquote> 
 <p>需要注意的是，LinkedList与ArrayDeque的底层结构分别是链表和数组，这意味着LinkedList可以添加空指针null作为表值，因为这不会影响LinkedList对链表长度的判断（只有当表指针为null时，才表明链表结束）。但ArrayDeque不能添加null作为值，否则会抛出<code>空指针异常</code>，这是因为变长数组判断长度的标准就是结尾的null标识（需要注意，变长数组不等于ArrayList，ArrayList是可以添加null的）。因此在用<strong>统一迭代法书写二叉树遍历代码时，只能使用LinkedList作为栈，从而使用null来标识中间节点</strong></p> 
</blockquote> 
<p>以ArrayDeque为例，其队列API为(<code>add, remove, element</code>)都会在特定情况抛出异常，不利于直接在程序中做判断，因此使用队列时多用<code>offer, poll, peek</code>三个方法，由于deque是双端队列，所以该三个方法又分别有两个变形，总计6个方法)<br> <img src="https://images2.imgbox.com/5c/ab/pgbqWIQs_o.png" alt="在这里插入图片描述"><br> 栈的API为<br> <img src="https://images2.imgbox.com/2e/ad/u7smJOIT_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_169"></a>栈的相关应用</h5> 
<ul><li>特征： 
  <ul><li>进行的操作多与邻居相关（大部分应用场景为相邻匹配）</li><li>通过栈结构完成的相邻匹配任务，一般流程为在出现待匹配元素时，查看栈顶元素是否可匹配，匹配后弹出栈顶元素</li></ul> </li><li>相邻匹配相关题目总结： 
  <ul><li>括号匹配：<a href="https://leetcode.cn/problems/valid-parentheses/" rel="nofollow">#20 有效的括号</a>，<a href="https://leetcode.cn/problems/generate-parentheses/" rel="nofollow">#22 括号生成</a>。</li><li>重复字符匹配：<a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/" rel="nofollow">#1047 删除字符串中的所有相邻重复项</a></li><li>后缀表达式计算：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" rel="nofollow">#150 逆波兰表达式求值</a>，后缀的运算符号方便计算机从前向后扫描的计算</li></ul> </li></ul> 
<h5><a id="_178"></a>队列的相关应用</h5> 
<p>先插一句题外话，如果对优先队列(<code>PriorityQueue</code>)底层结构——<strong>堆</strong>不够了解的，可以参看<a href="https://blog.csdn.net/l0919160205/article/details/90584394">这篇讲堆排序的博客</a>，在实现堆的时候可以参考这篇博客：<a href="https://blog.csdn.net/weixin_43008154/article/details/129265168">上移和下移堆节点的最优写法</a></p> 
<ul><li>特殊队列： 
  <ul><li>优先队列：按照优先级出队列，而不是先后顺序</li><li>单调队列：与优先队列的堆结构不同，单调队列保持顺序性</li></ul> </li><li>相关题目知识： 
  <ul><li><a href="https://leetcode.cn/problems/sliding-window-maximum/" rel="nofollow">#239 滑动窗口最大值</a>：单调队列或优先队列都可以辅助求解，重点是<strong>维护已扫描区域最大值的查找更新</strong></li><li><a href="https://leetcode.cn/problems/top-k-frequent-elements/submissions/400888976/" rel="nofollow">#347 前 K 个高频元素</a>：只进行部分排序，所以可以选择<strong>构造堆</strong>（也可以选择快速排序，通过信标索引与部分排序分界点的关系，来执行<strong>单边递归</strong>）</li></ul> </li></ul> 
<h4><a id="_188"></a>二叉树</h4> 
<p>二叉树可经由<strong>数组或链表</strong>实现，考虑到二叉树的可扩展性以及图形表达，一般使用链表作为二叉树的底层结构。对于以数组实现的完全二叉树（如堆结构），可考虑如下父子节点关系：</p> 
<blockquote> 
 <p>父节点标号为<strong>k</strong>，其左子节点为<strong>2k+1</strong>，右子节点为<strong>2k+2</strong></p> 
</blockquote> 
<h5><a id="_193"></a>深度优先遍历</h5> 
<ul><li>特征 
  <ul><li>优先向下探索，直到叶子结点为止</li></ul> </li><li>分类 
  <ul><li>前序遍历：<strong>中</strong>左右</li><li>中序遍历：左<strong>中</strong>右</li><li>后序遍历：左右<strong>中</strong></li></ul> </li><li>实现 
  <ul><li>递归法：传入参数与返回值（传入当前节点），递归终止条件（当前节点为null），单次递归逻辑（按访问顺序，决定中间节点的读取时机）</li><li>迭代法：按节点访问顺序入栈，为标识中间节点，在压入中间节点后紧接着压入null空指针</li></ul> </li></ul> 
<h5><a id="_203"></a>广度优先遍历（层序遍历）</h5> 
<ul><li>特征 
  <ul><li>优先进行层遍历，一层访问完才进入下一层</li></ul> </li><li>实现 
  <ul><li>递归法：传入参数与返回值（传入当前节点以及当前深度，以深度进行递归时结果的层级区分），递归终止条件（当前节点为null），单次递归逻辑（每次进入深度+1，节点放入对应层级，递归时先左后右，保证从左到右）</li><li>迭代法：使用队列结构，在遍历队列前，队列为当前层的所有节点，在遍历队列后，队列为下一层所有节点</li></ul> </li></ul> 
<h5><a id="_210"></a>二叉树解题技巧</h5> 
<ul><li><strong>递归分治</strong>：二叉树的题使用递归分治，左右子树分别递归执行同一任务，再由根节点汇总，从而<strong>自顶向下的解决问题</strong>，并在递归返回过程中<strong>自底向上的重构内容</strong> 
  <ul><li>适用题目：左右子树各自收集内容并由根节点做汇总的相关题目，如 
    <ul><li>二叉树的<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" rel="nofollow">最大深度</a>与<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" rel="nofollow">最小深度</a>：左右子树各自计算最大深度，由根节点最终挑选最大的一个</li><li><a href="https://leetcode.cn/problems/balanced-binary-tree/" rel="nofollow">判断平衡二叉树</a>：左右子树各自判断是否为平衡二叉树，再由根节点汇总判断</li><li><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" rel="nofollow">从中序和后序遍历构造二叉树</a>，<a href="https://leetcode.cn/problems/maximum-binary-tree/" rel="nofollow">最大二叉树</a>：左右子树各自构造树结构并返回头节点，再由根节点关联各自头节点</li></ul> </li></ul> </li><li><strong>左右分治</strong>：即按照左子树和右子树所呈现的不同性质，来分别进行访问任务 
  <ul><li>适用题目：左子树与右子树拥有不同性质的相关题目，如 
    <ul><li><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/submissions/402977173/" rel="nofollow">二叉树的最近公共祖先</a>：p和q的最近公共祖先表现出如下性质：若某一节点为最近公共祖先，p和q一定位于该节点及其子树上，且p和q一定不同时位于该节点的左右任一子树。因此，就可利用<strong>p和q分居左右子树的性质</strong>，来使左右子树<strong>分别进行p和q的查找与返回</strong>，从而确定<strong>最近的公共祖先</strong></li><li>二叉搜索树的相关题目：二叉搜索树的性质为——其<strong>左子树均小于当前节点</strong>，<strong>右子树均大于当前节点</strong>，因此是一个天然进行左右差分的类型 
      <ul><li><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/" rel="nofollow">二叉搜索树中的搜索</a>：按搜索值与节点的大小关系，决定对左右子树的访问。与之原理完全相同的还有<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" rel="nofollow">二叉搜索树的插入</a></li><li><a href="https://leetcode.cn/problems/delete-node-in-a-bst/" rel="nofollow">删除二叉搜索树节点</a>：删除操作将待删除节点分为<strong>四种情况</strong>，分别对应其<strong>左右子树的存在与否</strong>，其中<strong>左右子树均存在时</strong>的处理方案就运用到左右分治的思想，将左子树完整插入到右子树的最左侧最深处节点，再返回右子树根节点</li><li><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/" rel="nofollow">修剪二叉搜索树</a>：小于左边界时，以节点右子树进行修剪重塑，返回重塑后的根节点以替换删除节点；大于右边界时同理</li></ul> </li></ul> </li></ul> </li></ul> 
<h5><a id="_224"></a>总结</h5> 
<p>二叉树的题目无外乎以下三种：</p> 
<ul><li><strong>构造二叉树</strong>：一般使用前序遍历，先建立根节点，再利用<strong>递归分治</strong>思想关联左子树与右子树头节点</li><li><strong>求二叉树的属性</strong>：一般使用后序遍历，先获得子树的返回值，再根据返回值不断递归统计</li><li><strong>修改二叉树的结构</strong>：一般以修改<strong>二叉搜索树</strong>为主，所以主要用中序遍历，从而利用起二叉搜索树的有序性质</li></ul> 
<p>该部分的思维导图如下：</p> 
<p><img src="https://images2.imgbox.com/6e/a5/DTLpCNOW_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_233"></a>回溯算法</h4> 
<h5><a id="_234"></a>组合问题</h5> 
<ol><li><strong>组合问题与单调性息息相关，对一个整数数组进行组合时，如整数数组满足单调性，则组合问题的两个方面均有所简化：</strong></li></ol> 
<ul><li>剪枝：由于数组的单调性，当某次遍历达到临界值后，依序进行的后续遍历则一定大于临界值，从而可直接剪除</li><li>避免重复组合：由于数组的单调性，顺序挑选元素也可保证挑选元素的大小顺序，从而由小到大的生成不重复组合</li></ul> 
<ol start="2"><li><strong>在以下情形下，整数数组的组合问题需要要具备单调性</strong></li></ol> 
<ul><li>包含同层去重的问题，如<a href="https://leetcode.cn/problems/subsets-ii/description/" rel="nofollow">子集II</a>，<a href="https://leetcode.cn/problems/combination-sum-ii/" rel="nofollow">组合总和II</a>。如果整数数组<strong>不能具备单调性</strong>，则需要使用额外的辅助集，如<a href="https://leetcode.cn/problems/non-decreasing-subsequences/description/" rel="nofollow">递增子序列</a>使用<strong>set</strong>记录同层中已访问过的元素，来避免同层重复；如应用于子集II和组合总和II中，还额外需要进行层间的去重</li><li>K数之和的类似问题，如<a href="https://leetcode.cn/problems/combination-sum/" rel="nofollow">组合总和</a>，<a href="https://leetcode.cn/problems/combination-sum-iii/" rel="nofollow">组合总和III</a>，具备单调性后可方便剪枝</li></ul> 
<ol start="3"><li><strong>子集的组合与组合总和以及切割问题是不同的</strong></li></ol> 
<ul><li>总和的组合需要等于某个深度时，路径收集器才能加入结果集，与之类似的，切割问题需要完全切割数组，才能将路径收集器加入结果集，因此两者都是在<strong>叶子节点时将收集的结果加入集合</strong></li><li>子集的组合则不限制是否完全切割，也不限制到达某个深度，因此其构造树的<strong>每个节点均可以加入集合</strong></li></ul> 
<h5><a id="_247"></a>排列问题</h5> 
<p>与组合问题不同的是，排列问题没有<strong>层间+1</strong>的约束，而仅仅要求剔除每层所选的元素，因此当剔除数组中间的元素时，排列的难点就来了——如何来表示传输到下一层的子数组：</p> 
<ul><li>第一种方法时间复杂度较高，但胜在思路简单：使用一个<strong>used数组</strong>来标识路径所遍历的节点位置，每一层在选取元素时，只能选取未被标示的元素</li><li>第二种方法时间复杂度较第一种更低：每次将<strong>选取的元素</strong>与<strong>数组的首位元素</strong>做交换，然后传入下层时<strong>首位地址+1</strong>。在回溯阶段，再将交换的元素还原（值得注意的是，本方法在去重阶段将无法使用排序法，因为交换元素后单调性被打破，因此只能使用哈希去重）</li></ul> 
<h5><a id="_253"></a>有向图的所有可行路径</h5> 
<p>该类题对有向图进行深度优先搜索，因此多采用递归形式求解。又由于需要找到所有可行路径，所以在递归中还带有回溯操作</p> 
<ul><li>如<a href="https://leetcode.cn/problems/reconstruct-itinerary/" rel="nofollow">重新安排行程</a>，即通过深度优先搜索，找到一条可达的最小排序路径</li></ul> 
<h5><a id="_257"></a>棋盘问题</h5> 
<p>棋盘问题在性能接受范围内，均可采用枚举的方法解决，即对棋盘格按左右，上下顺序依次递归与回溯，从而遍历所有可能解并找到符合条件的最终解</p> 
<ul><li>如<a href="https://leetcode.cn/problems/n-queens/" rel="nofollow">N皇后</a>：同层通过for循环控制一个N皇后的落点，层间则通过递归来组织所有N皇后的遍历，每一个落点均需考察其先驱落点所产生的的禁区</li><li>如<a href="https://leetcode.cn/problems/sudoku-solver/description/" rel="nofollow">解数独</a>：每个棋盘格通过for循环控制所有可选元素，在获取到该格的某个可选元素后，按按从左至右，从上至下的顺序依次组织递归，遍历所有棋盘格</li></ul> 
<h5><a id="_262"></a>总结</h5> 
<p>回溯算法最难排查的错误一般都出现在回溯的顺序上，因此一定要遵循下面的原则进行编程：</p> 
<ul><li><strong>回溯与遍历的顺序一定是一一相反对应</strong>：当一次遍历涉及到多组元素顺序的交换时，一定要拆分成一步步来，这样在回溯中才可以清晰地判定是否与遍历的顺序成一一相反对应。<br> <img src="https://images2.imgbox.com/28/f0/tLGx4R18_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="_266"></a>贪心算法</h4> 
<h5><a id="_267"></a>对有左右比较关系的数组使用贪心算法</h5> 
<p>这类题有一个很巧妙的辅助分析手段，即从左至右绘制数组值的波动图，然后对波峰/波谷使用贪心算法分析，例如：</p> 
<ul><li><a href="https://leetcode.cn/problems/candy/" rel="nofollow">分发糖果</a>中，我们首先绘制了从左至右孩子的<strong>评分变化曲线</strong>，然后显而易见的发现<strong>波谷分得的糖果总为1</strong>，<strong>波峰分得的糖果为左右的高位+1</strong>，而波峰与波谷之间的糖果分配则遵循单调性原则，因此该题就可以很好地利用贪心算法求解</li></ul> 
<h5><a id="_271"></a>对进行包含关系的数组使用贪心算法</h5> 
<p>这类题的巧思一种是覆盖面积法，主要针对顺序固定的包含关系，即在从左至右的扫描过程中，不断优化当前子区间可能的最大覆盖范围，当超出覆盖范围后，表示当前子区间的任务完成</p> 
<ul><li><a href="https://leetcode.cn/problems/partition-labels/description/" rel="nofollow">划分字母区间</a>中，我们首先收集了每个字母的最远下标，然后在依次扫描的过程中，根据当前字母的最远下标不断更新子字符串的最大覆盖范围，从而使得同一字母仅落在一个子串内，且子串被分割的尽可能多</li><li><a href="https://leetcode.cn/problems/jump-game/" rel="nofollow">跳跃游戏</a>中，我们也是在依次扫描过程中更新当前子区间的最远覆盖范围，若某次扫描后将末尾覆盖进来，则跳跃可以到达末尾</li></ul> 
<p>如果顺序可更改，那么首先进行排序，排序后再使用覆盖面积法则是一个很好的想法，例如下面一类重叠区间问题（其本身就是一个<strong>覆盖面积</strong>的问题）：</p> 
<ul><li><a href="https://leetcode.cn/problems/merge-intervals/description/" rel="nofollow">在合并区间</a>中，我们首先对二维数组表示的区间集，根据其左边界进行升序排列（有关二维数组的排序写法可参看<a href="https://blog.csdn.net/weixin_43008154/article/details/129288976?spm=1001.2014.3001.5501">我的另一篇博客</a>），由此，在合并过程中，我们就仅需和最后记录的子区间作比较即可决定当前区间的去留</li></ul> 
<h5><a id="_279"></a>巧用状态转移，简化贪婪判断</h5> 
<p>这类题的特点是针对不同的状态，需要采用不同的转移方程（转移方程就涉及到贪婪策略）。因此一个有效的解题思路就是：</p> 
<ul><li>首先定义完备且符合题意的状态组，符合题意是指状态组不仅要包含所有的可能性，还要可解决问题</li><li>然后根据状态组的可能组合，定义不同状态间的状态转移方程</li><li>最后确定状态初始值以及状态转移顺序</li></ul> 
<p>例如在<a href="https://leetcode.cn/problems/binary-tree-cameras/description/" rel="nofollow">监控二叉树</a>中，我们定义的是三状态，如果仅定义是否被覆盖两个状态，就无法解决问题</p> 
<h4><a id="_288"></a>动态规划</h4> 
<h5><a id="1_289"></a>类型题总结1------背包问题</h5> 
<ul><li>动态规划的关键一：设计递推变量与递推公式 
  <ul><li>递推变量的<strong>结束位</strong>一定与<strong>结果</strong>强关联</li><li>递推函数一定可以从<strong>初始</strong>推导至<strong>结束</strong></li><li>举例说明——<a href="https://leetcode.cn/problems/target-sum/" rel="nofollow">目标和问题</a>：由于递推变量的<strong>结束位</strong>一定与<strong>结果</strong>强关联，考虑设计递推变量为表达式数目；此为总的思路，然后就是细化该思路，找到某一个符合递推思想的表达式数目，本题便是从正数集的和为i的表达式数目入手解决问题</li></ul> </li><li>动态规划的关键二：如何区分传统的动规（如跳跃游戏）和背包问题 
  <ul><li>背包问题的一大特色是元素任取，因此其隐含的物品维所给出的定义（在0-i之中任取）就非常重要了，它将任取的行为转变成了传统动规中按顺序取得行为，从而使得动规可解</li></ul> </li><li>动态规划的关键三：01背包和完全背包的区别 
  <ul><li>对背包容量遍历顺序的不同：01背包从后向前遍历背包容量，保证位于后面的容量更新价值时使用的是未包含当前物品的容量价值；完全背包从前向后，保证后面的容量更新价值时，前面已包含当前物品</li><li>由上可知，01背包在使用一维数组存储时，背包与物品的遍历顺序无法交换，必须先物品，再背包，避免更新价值时使用了已覆盖的价值</li><li>完全背包则分为两种情况： 
    <ul><li>如果递推函数使用的是<strong>max类型</strong>，求取的是最大装包重量之类的，那么先背包与先物品都是一致的，因为此时是否对任取物品范围做限制并不会影响最终结果；</li><li>如果递推函数使用的是<strong>sum类型</strong>，求取的是组合数目之类的，那么只能<strong>先物品</strong>，因为在一个背包容量下进行所有物品的遍历，会导致后续sum时出现重复的组合统计，先物品可以保证组合去重</li><li>如果递推函数使用的是<strong>sum类型</strong>，求取的是排列数目，只能<strong>后物品</strong>，因为只需要最后一位的选择不同，其都将属于不同的组合</li><li><strong>sum排列类型</strong>我总结为其要求的是sum[最后一位是物品i]+sum[最后一位不是物品i]，因为只对最后一位有要求，所以使用<strong>先背包后物品</strong>是符合的；而<strong>sum组合类型</strong>要求的是sum[组合内包含i]+sum[组合内不包含i]，对整个组合提出要求，所以使用<strong>先物品后背包</strong>加以限制</li><li>换言之，先背包还是先物品的本质是是否对特殊的组合（即元素相同但顺序不同）有需求，如果有需求，则应选择先背包，让前缀背包包含其所有的可能；如果没有需求，则应该选择先物品，给出限制</li></ul> </li></ul> </li></ul> 
<h5><a id="2_306"></a>类型题总结2------股票买卖的最佳时机</h5> 
<p>该类型题的一大特色是递推变量不再是单维问题，而是有多个维度，针对多个维度分别设计了递推函数，从而解决问题。与之有异曲同工之妙的有贪婪算法中的<a href="https://leetcode.cn/problems/binary-tree-cameras/" rel="nofollow">二叉树上的最少监控头</a>。我对股票买卖型的题有如下总结经验：</p> 
<blockquote> 
 <p>设置2<em>k+1个状态<br> 1. dp[i][0]：第一次持有前i时的总现金，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           d 
          
         
           p 
          
         
           [ 
          
         
           i 
          
         
           ] 
          
         
           [ 
          
         
           0 
          
         
           ] 
          
         
           = 
          
         
           d 
          
         
           p 
          
         
           [ 
          
         
           i 
          
         
           − 
          
         
           1 
          
         
           ] 
          
         
           [ 
          
         
           0 
          
         
           ] 
          
         
        
          dp[i][0] = dp[i-1][0] 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></span><br> 2. dp[i][2</em>j-1]：第j次持有，且当前下标为i时的总现金，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          d 
         
        
          p 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          [ 
         
        
          2 
         
        
          ∗ 
         
        
          j 
         
        
          − 
         
        
          1 
         
        
          ] 
         
        
          = 
         
        
          m 
         
        
          a 
         
        
          x 
         
        
          ( 
         
        
          d 
         
        
          p 
         
        
          [ 
         
        
          i 
         
        
          − 
         
        
          1 
         
        
          ] 
         
        
          [ 
         
        
          2 
         
        
          ∗ 
         
        
          j 
         
        
          − 
         
        
          2 
         
        
          ] 
         
        
          − 
         
        
          p 
         
        
          r 
         
        
          i 
         
        
          c 
         
        
          e 
         
        
          s 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          , 
         
        
          d 
         
        
          p 
         
        
          [ 
         
        
          i 
         
        
          − 
         
        
          1 
         
        
          ] 
         
        
          [ 
         
        
          2 
         
        
          ∗ 
         
        
          j 
         
        
          − 
         
        
          1 
         
        
          ] 
         
        
          ) 
         
        
       
         dp[i][2*j-1] = max(dp[i-1][2*j-2]-prices[i], dp[i-1][2*j-1]) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">])</span></span></span></span></span><br> 3. dp[i][2*j]：第j次卖出后，第j+1次持有前且当前下标为i时的总现金，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          d 
         
        
          p 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          [ 
         
        
          2 
         
        
          ∗ 
         
        
          j 
         
        
          ] 
         
        
          = 
         
        
          m 
         
        
          a 
         
        
          x 
         
        
          ( 
         
        
          d 
         
        
          p 
         
        
          [ 
         
        
          i 
         
        
          − 
         
        
          1 
         
        
          ] 
         
        
          [ 
         
        
          2 
         
        
          ∗ 
         
        
          j 
         
        
          − 
         
        
          1 
         
        
          ] 
         
        
          + 
         
        
          p 
         
        
          r 
         
        
          i 
         
        
          c 
         
        
          e 
         
        
          s 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          , 
         
        
          d 
         
        
          p 
         
        
          [ 
         
        
          i 
         
        
          − 
         
        
          1 
         
        
          ] 
         
        
          [ 
         
        
          2 
         
        
          ∗ 
         
        
          j 
         
        
          ] 
         
        
          ) 
         
        
       
         dp[i][2*j] = max(dp[i-1][2*j-1]+prices[i], dp[i-1][2*j]) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">])</span></span></span></span></span><br> 初始化方案1：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          d 
         
        
          p 
         
        
          [ 
         
        
          0 
         
        
          ] 
         
        
          [ 
         
        
          0 
         
        
          ] 
         
        
          = 
         
        
          0 
         
        
          , 
         
        
          d 
         
        
          p 
         
        
          [ 
         
        
          0 
         
        
          ] 
         
        
          [ 
         
        
          1 
         
        
          ] 
         
        
          = 
         
        
          − 
         
        
          p 
         
        
          r 
         
        
          i 
         
        
          c 
         
        
          e 
         
        
          s 
         
        
          [ 
         
        
          0 
         
        
          ] 
         
        
          , 
         
        
          d 
         
        
          p 
         
        
          [ 
         
        
          0 
         
        
          ] 
         
        
          [ 
         
        
          2 
         
        
            
         
        
          t 
         
        
          o 
         
        
            
         
        
          e 
         
        
          n 
         
        
          d 
         
        
          ] 
         
        
          = 
         
        
          I 
         
        
          n 
         
        
          t 
         
        
          e 
         
        
          g 
         
        
          e 
         
        
          r 
         
        
          . 
         
        
          M 
         
        
          I 
         
         
         
           N 
          
         
           V 
          
         
        
          A 
         
        
          L 
         
        
          U 
         
        
          E 
         
        
       
         dp[0][0]=0, dp[0][1]=-prices[0], dp[0][2\ to\ end]=Integer.MIN_VALUE 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">−</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace"> </span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mspace"> </span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.0278em;">er</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3283em;"><span class="" style="top: -2.55em; margin-left: -0.109em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.2222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right: 0.109em;">LU</span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span></span></span></span></span>(隐含假设为只能当天买入，第二天卖出)<br> 初始化方案2：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          d 
         
        
          p 
         
        
          [ 
         
        
          0 
         
        
          ] 
         
        
          [ 
         
        
          0 
         
        
          ] 
         
        
          = 
         
        
          0 
         
        
          , 
         
        
          d 
         
        
          p 
         
        
          [ 
         
        
          0 
         
        
          ] 
         
        
          [ 
         
        
          2 
         
        
          ∗ 
         
        
          j 
         
        
          − 
         
        
          1 
         
        
          ] 
         
        
          = 
         
        
          − 
         
        
          p 
         
        
          r 
         
        
          i 
         
        
          c 
         
        
          e 
         
        
          s 
         
        
          [ 
         
        
          0 
         
        
          ] 
         
        
          , 
         
        
          d 
         
        
          p 
         
        
          [ 
         
        
          0 
         
        
          ] 
         
        
          [ 
         
        
          2 
         
        
          ∗ 
         
        
          j 
         
        
          ] 
         
        
          = 
         
        
          0 
         
        
       
         dp[0][0]=0, dp[0][2*j-1]=-prices[0], dp[0][2*j]=0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">−</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span>(隐含假设为可以当天买入当天卖出无数次)<br> <strong>重点：初始化方案1由于多了对前缀值是否为不可取值的判断，因此其可能出现最后一天不在最后一笔交易时取到最大，所得结果必须通过遍历手段再拿到最大值；初始化方案2由于当天可买卖无数次，因此一定在最后一笔交易时取到最大</strong><br> 时间复杂度O(n * k)</p> 
</blockquote> 
<h5><a id="3_318"></a>类型题总结3------子序列与子数组相关问题</h5> 
<p>首先应明确子序列和子数组的区别：<strong>子数组是连续的子序列</strong></p> 
<p>子序列和子数组的相关题目是动态规划方法的天然产物，因为其最终结果正是来自于不断地递推<strong>前缀子序列/子数组</strong></p> 
<p>求解子序列与子数组类型的题，其巧思主要集中在递推变量的设计上，我将其总结为两大类：</p> 
<ul><li>考虑递推变量的设计内容： 
  <ul><li>如果求解过程对前缀子序列的结尾与当前子序列的结尾<strong>没有特殊限制（如要求连续或者递增）</strong>，那么此时的递推变量设计可直接反映结果，<font color="lightblue">例如设置为0~i的范围内的最大子序列值</font></li><li>如果求解过程中前缀子序列的结尾与当前子序列的结尾<strong>有特殊限制</strong>，那么此时递推变量的设计还应考虑到前缀子序列结尾的可追溯性，<font color="lightblue">例如设置为0~i的范围内以nums[i]结尾的最大子序列值</font></li></ul> </li><li>考虑 递推变量的设计维度： 
  <ul><li>如果<strong>待求解的数组有多个</strong>，或者需要多个<strong>辅助信标</strong>，在无法精简的情况下，<font color="lightblue">递推变量应考虑设计多维以切实反映所有可能</font></li></ul> </li></ul> 
<p>由子序列问题扩展来的<strong>编辑距离类型的题</strong>，其递推变量的设计规则符合上述总结的1-1</p> 
<p>如果加上<strong>回文限制</strong>，递推变量在符合点1.1的前提下，还需要考虑应回文对首尾信标的同时需求，从而将递推变量的维度扩展为2</p> 
<h4><a id="_334"></a>单调栈</h4> 
<p>单调栈是指一个栈里的元素是有序排列的，基于其特性，单调栈在求解以下需求时有着重要作用：</p> 
<ul><li>当我们需要知道索引<code>i</code>对应元素的<strong>前一更大元素</strong>以及<strong>后一更大元素</strong>时</li></ul> 
<p>这类型的代表题目如<a href="https://leetcode.cn/problems/trapping-rain-water/description/" rel="nofollow">接雨水</a>，<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/" rel="nofollow">柱状图中最大的矩形</a>，这两个题之所以放在一起说，是因为它们在如下两个方面表现出的异质性：</p> 
<ul><li>接雨水中，单调栈采用的是<strong>单调递减策略</strong>，以保证栈顶前一元素小于（去除了等于的可能）栈顶元素，从而形成凹槽；柱状图中，单调栈采用的是<strong>单调递增策略</strong>，从而形成凸起</li><li>接雨水中，当待加入元素与栈顶元素相等时，会将栈顶元素弹出，以保证前一更大的成立；柱状图中，在获取前一更小时，需要不断收集弹出的相等元素，直到出现前一更小。因此，<strong>在单调栈中最为特殊的就是等于时的处理手段</strong>，这因具体问题而异</li></ul> 
<h4><a id="_343"></a>图</h4> 
<p>图类型的问题主要围绕深度优先搜索与广度优先搜索做文章，我比较喜欢用广度优先搜索，因为：</p> 
<ul><li>不论是拓扑排序，又或者是最短路问题等，都可以用广度优先搜索解决</li></ul> 
<p>代表题型拓扑排序：<a href="https://leetcode.cn/problems/QA2IGt/" rel="nofollow">LCR 113. 课程表 II</a>，无权边的最短路：<a href="https://leetcode.cn/problems/2bCMpM/" rel="nofollow">LCR 107. 01 矩阵</a>，有权边的最短路：<a href="https://leetcode.cn/problems/path-with-minimum-effort/" rel="nofollow">1631. 最小体力消耗路径</a></p> 
<ul><li>拓扑排序中，核心思路为：使用队列结构，队列中只存放入度为0的节点，每次从队列中弹出一个节点，都清空该节点对应的出度，并将入度归零的节点加入队列。由此，队列的弹出顺序就是拓扑排序结果</li><li>无权边的最短路与有权边的最短路问题的区别在于：无权边的最短路是每次以队列弹出节点为搜索中心，加入其下一步能到达的节点，并标记为已搜索；而有权边不同，虽然也是每次以队列弹出节点为搜索中心，加入其下一步能到达的节点，但队列采用优先队列结构，只有当某个节点被弹出时，才标记为已搜索</li></ul> 
<h4><a id="_351"></a>多线程编程</h4> 
<p>一般会遇到的多线程问题，都是一个套路，即要求按照一定顺序调度多线程，因此多线程编程的关键点我总结为：</p> 
<ul><li>如何来推进顺序</li><li>未到顺序时线程如何等待</li></ul> 
<p>这就引出了多线程的一个核心公式：</p> 
<pre><code class="prism language-bash">volatile int count<span class="token punctuation">;</span> //顺序标识符
while<span class="token punctuation">(</span>count <span class="token operator">!=</span> <span class="token string">"本线程的id"</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>//自旋等待<span class="token punctuation">}</span>
<span class="token punctuation">..</span>.//执行处理逻辑
count<span class="token operator">&lt;</span>-推进顺序
</code></pre> 
<h4><a id="_365"></a>通用的细节问题</h4> 
<ul><li>Java通常情况下不能自定义重载运算符，因此对于包装类，如果直接食用Integer1 = Integer2，那么这一判断只能在特殊情况下成立（即Integer在被装载进常量池的Integer包装类范围内）。因此，包装类的等于判断必须使用equals，比大小则必须使用compareTo。<strong>Java仅为我们提供了一种运算符重载，即包装类与基本类型的自动装箱与拆箱机制</strong></li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/581201af942e08e7a87dbab51d389887/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">YOLO系列</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a2fe2b3bf9d71cdea7efd06ed04a6336/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;学习(4)】C&#43;&#43;构造函数后面的冒号</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>