<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>各种排序算法实现原理和代码及适用范围总结 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="各种排序算法实现原理和代码及适用范围总结" />
<meta property="og:description" content="排序算法可以分为内部排序和外部排序，内部排序又可以分为插入类、交换类、选择类、归并类排序，归并排序通常也应用于外部排序，但采用的是多路归并排序。
内部排序有：
插入类排序：直接插入、折半插入、希尔排序；
交换类排序：冒泡排序、快速排序；
选择类排序：简单（直接）选择排序、堆排序；
归并类排序：归并排序；
外部排序：需要在内外存之间多次交换数据才能进行；
1、直接插入排序
基本思路：L(i)为待排序表中一个元素，前一子序列L[1...i-1]为有序子序列，后一子序列L[i&#43;1...n]为无序子序列，为了实现将元素L(i)插入到已有序的子序列L[1...i-1]中，需进行以下操作：
1）查找出L(i)在L[1...i-1]中的插入位置k；
2）将L[k...i-1]中所有元素全部后移一个位置；
3）将L(i)复制到L(k)。
过程：就是将后面无序子序列中的每一个元素依次往前面有序子序列中插入到相应的位置，初始时将待排序列的第一个元素作为有序子序列的一个元素。
插入图为：
Java代码实现：
import java.util.Scanner;
//用Java实现直接插入排序
public class DirectInsertSort {
public static void InsertSort(int A[],int n){
int k,j;
for(int i=1;i&lt;n;i&#43;&#43;){
if(A[i]&lt;A[i-1]){
k = A[i];
for(j=i-1;j&gt;=0 &amp;&amp; k&lt;A[j];j--){
A[j&#43;1]=A[j];
}
A[j&#43;1]=k;
}
}
}
public static void main(String [] args){
int A[] = new int[10];
System.out.println(&#34;请输入数值插入到已声明的数组中：&#34;);
Scanner reader = new Scanner(System.in);
for(int i = 0;i&lt;A.length;i&#43;&#43;)
{
//System.out.println(&#34;请输入第&#34;&#43;(i&#43;1)&#43;&#34;个数字：&#34;);
int In = reader." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3ae88775cd829115d31895e51b7cf334/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-15T18:01:24+08:00" />
<meta property="article:modified_time" content="2019-08-15T18:01:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">各种排序算法实现原理和代码及适用范围总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>排序算法可以分为内部排序和外部排序，内部排序又可以分为插入类、交换类、选择类、归并类排序，归并排序通常也应用于外部排序，但采用的是多路归并排序。</p> 
<p>内部排序有：</p> 
<p>插入类排序：直接插入、折半插入、希尔排序；</p> 
<p>交换类排序：冒泡排序、快速排序；</p> 
<p>选择类排序：简单（直接）选择排序、堆排序；</p> 
<p>归并类排序：归并排序；</p> 
<p>外部排序：需要在内外存之间多次交换数据才能进行；</p> 
<p>1、直接插入排序</p> 
<p>基本思路：L(i)为待排序表中一个元素，前一子序列L[1...i-1]为有序子序列，后一子序列L[i+1...n]为无序子序列，为了实现将元素L(i)插入到已有序的子序列L[1...i-1]中，需进行以下操作：</p> 
<p>1）查找出L(i)在L[1...i-1]中的插入位置k；</p> 
<p>2）将L[k...i-1]中所有元素全部后移一个位置；</p> 
<p>3）将L(i)复制到L(k)。</p> 
<p>过程：就是将后面无序子序列中的每一个元素依次往前面有序子序列中插入到相应的位置，初始时将待排序列的第一个元素作为有序子序列的一个元素。</p> 
<p>插入图为：</p> 
<p><img alt="" class="has" height="378" src="https://images2.imgbox.com/62/99/zPhzh44N_o.png" width="877"></p> 
<p>Java代码实现：</p> 
<p>import java.util.Scanner;</p> 
<p>//用Java实现直接插入排序<br> public class DirectInsertSort {<!-- --><br>     public static void InsertSort(int A[],int n){<!-- --><br>         int k,j;<br>         for(int i=1;i&lt;n;i++){<!-- --><br>             if(A[i]&lt;A[i-1]){<!-- --><br>                 k = A[i];<br>                 for(j=i-1;j&gt;=0 &amp;&amp; k&lt;A[j];j--){<!-- --><br>                     A[j+1]=A[j];<br>                 }<br>                 A[j+1]=k;<br>             }<br>         }<br>     }<br> public static void main(String [] args){<!-- --><br>     int A[] = new int[10];<br>     System.out.println("请输入数值插入到已声明的数组中：");<br>     Scanner reader = new Scanner(System.in);<br>     for(int i = 0;i&lt;A.length;i++)<br>     {<!-- --><br>         //System.out.println("请输入第"+(i+1)+"个数字：");<br>         int In = reader.nextInt();<br>         A[i] = In;<br>     }<br>     InsertSort(A,A.length);<br>     System.out.println("排序后的数组元素序列为：");<br>     for(int i = 0;i&lt;A.length;i++){<!-- --><br>         System.out.print(A[i]+" ");<br>     }<br> }<br> }<br> 时间复杂度：最好情况下O(n),表中元素基本有序，每插入一个元素，都只需比较一次而不用移动元素，最坏情况和平均情况下都是O(n^2),最坏情况是表中元素基本逆序，平均情况下指待排序表中元素是随机的。</p> 
<p>空间的复杂度：O(1)</p> 
<p>直接插入排序是一个稳定的排序方法。</p> 
<p>2、折半插入排序</p> 
<p>基本思路：上面的直接插入排序算法在每趟插入的过程中都进行了两项工作：1）从前面的字表中 查找出待插入元素应该被插入的位置；2)给插入位置腾出空间，将待插入元素复制到表中的插入位置；边比较边移动元素。而折半插入排序是将比较和移动操作分离开来，先折半查找出元素的待插入位置，在统一移动待插入位置之后的所有元素，当采用顺序存贮的线性表且数据量较小时可以采用折半插入排序算法，另一方面查找有序子表时采用折半查找来实现。</p> 
<p> </p> 
<p>Java代码实现：</p> 
<p>import java.util.Scanner;</p> 
<p>public class ZheBanInsertSort {<!-- --><br>     public static void ZheBan_InsertSort(int A[],int n){<!-- --><br>     int i,j,k,low,high,mid;<br>     for(i=1;i&lt;n;i++){<!-- --><br>         k = A[i];<br>         low = 0;high = i-1;<br>         while(low&lt;=high){//折半查找，确定查找位置<br>             mid = (low+high)/2;<br>             if(k&lt;=A[mid])<br>                 high = mid-1;<br>             else<br>                 low = mid+1;<br>         }<br>         for(j=i-1;j&gt;=high+1;j--){<!-- --><br>             A[j+1] = A[j];//统一后移元素，空出插入位置<br>         }<br>         A[high+1] = k;<br>     }<br> }<br>     public static void main(String [] args){<!-- --><br>         int A[] = new int[10];<br>         System.out.println("请输入数值插入到已声明的数组中：");<br>         Scanner reader = new Scanner(System.in);<br>         for(int i = 0;i&lt;A.length;i++)<br>         {<!-- --><br>             //System.out.println("请输入第"+(i+1)+"个数字：");<br>             int In = reader.nextInt();<br>             A[i] = In;<br>         }<br>         ZheBan_InsertSort(A,A.length);<br>         System.out.println("排序后的数组元素序列为：");<br>         for(int i = 0;i&lt;A.length;i++){<!-- --><br>             System.out.print(A[i]+" ");<br>         }<br>     }<br> }<br> 时间复杂度：折半插入排序仅仅是减少了比较元素的次数，约为O(nlogn),与待排序表的初始状态无关，仅取决于表中的元素个数n，而元素的移动次数没有改变，仍为O(n^2)，因此时间复杂度为O(nlogn)+O(n^2)=O(n^2)。</p> 
<p>空间复杂度：O(1)</p> 
<p>折半插入排序是一个稳定的排序方法。</p> 
<p>3、希尔排序</p> 
<p>直接插入排序算法适用于基本有序的排序表和数据量不大的排序表，基于这两点提出希尔排序，或称为缩小增量排序。</p> 
<p>基本思路：先将待排序表分割成若干个形如L[i,i+d,i+2d,...i+kd]的“特殊”子表，分别进行直接插入排序，当整个表中元素局部基本有序时再对全体记录进行一次直接插入排序（最后一趟）。先取一个小于n的步长d1,把表中全部记录分成d1个组，所有距离为d1的倍数的记录放在同一个组中，在各组中进行直接插入排序；然后取第二个步长d2&lt;d1，重复上述过程，直到所取到的dt=1，即所有记录已放在同一组中，在进行直接插入排序，此时已经具有较好的局部有序性，因此可以很快得到排序结果。</p> 
<p>插入图为：</p> 
<p><img alt="" class="has" height="430" src="https://images2.imgbox.com/3b/02/BGHbDiLM_o.png" width="804"></p> 
<p>Java代码如下：</p> 
<p>import java.util.Scanner;</p> 
<p>public class SellSort {<!-- --><br>     public static void ShellSort1(int A[],int n){<!-- --><br>         int i,j,k,dk=n/2;<br>         while(dk&gt;0){<!-- --><br>             for(i = dk+1;i&lt;n;i++){<!-- --><br>                 k = A[i];<br>                 j = i-dk;<br>                 while(j&gt;=0&amp;&amp;k&lt;A[j]){<!-- --><br>                     A[j+dk] = A[j];<br>                     j = j-dk;<br>                 }<br>                 A[j+dk] = k; <br>             }<br>             dk = dk/2;<br>         }<br>     }<br>     public static void ShellSort2(int A[],int n){<!-- --><br>         int i,j,k,dk;<br>         for(dk=n/2;dk&gt;=1;dk=dk/2){<!-- --><br>             for(i=dk+1;i&lt;n;i++){<!-- --><br>                 if(A[i]&lt;A[i-dk]){<!-- --><br>                     k = A[i];<br>                     for(j=i-dk;j&gt;=0&amp;&amp;k&lt;A[j];j=j-dk)<br>                         A[j+dk] = A[j];<br>                     A[j+dk] = k;<br>                 }<br>             }<br>         }<br>     }<br>     public static void main(String [] args){<!-- --><br>         int A[] = new int[10];<br>         System.out.println("请输入数值插入到已声明的数组中：");<br>         Scanner reader = new Scanner(System.in);<br>         for(int i = 0;i&lt;A.length;i++)<br>         {<!-- --><br>             //System.out.println("请输入第"+(i+1)+"个数字：");<br>             int In = reader.nextInt();<br>             A[i] = In;<br>         }<br>         ShellSort1(A,A.length);<br>         //ShellSort2(A,A.length);<br>         System.out.println("排序后的数组元素序列为：");<br>         for(int i = 0;i&lt;A.length;i++){<!-- --><br>             System.out.print(A[i]+" ");<br>         }<br>     }<br> }<br> 时间复杂度：最好情况下为O(n^1.3)，最坏情况下为O(n^2)，平均情况下为O(nlogn)~O(n^2)</p> 
<p>空间复杂度：O(1)</p> 
<p>希尔排序是一个不稳定的排序算法，仅适用于线性表为顺序存储的情况</p> 
<p>4、冒泡排序</p> 
<p>基本思路：假设待排序表长为n，从前往后或从后往前两两比较相邻元素值，若为逆序，则交换两者的顺序，直到序列比较完，称为一趟冒泡排序，共进行n-1趟冒泡过程。</p> 
<p>示例图为：</p> 
<p><img alt="" class="has" height="378" src="https://images2.imgbox.com/b2/c5/yZFfkB2j_o.png" width="834"></p> 
<p>这里例举三个冒泡排序过程，他们移动和交换元素的次数都不相同：</p> 
<p>//第一种冒泡排序算法,性能最差的一种<br>     public static void BubbleSort1(int a[],int n){<!-- --><br>         int i,j;<br>         for(i=0;i&lt;n;i++){//表示n次排序过程<br>             for(j=1;j&lt;n;j++){//一趟冒泡过程<br>                 if(a[j-1]&gt;a[j]){//前面的数据大于后面的数据就交换<br>                     int temp;<br>                     temp = a[j-1];<br>                     a[j-1] = a[j];<br>                     a[j] = temp;<br>                 }<br>             }<br>         }<br>     }</p> 
<p>//第二种冒泡排序算法，减少了比较数据的次数<br>     public static void BubbleSort2(int a[],int n){<!-- --><br>         int i,j;<br>         for(i=0;i&lt;n;i++){//表示n次排序过程<br>             for(j=1;j&lt;n-i;j++){//一趟冒泡过程<br>                 if(a[j-1]&gt;a[j]){//前面的数据大于后面的数据就交换<br>                     int temp;<br>                     temp = a[j-1];<br>                     a[j-1] = a[j];<br>                     a[j] = temp;<br>                 }<br>             }<br>         }<br>     }</p> 
<p>//第三种冒泡排序算法<br>         public static void BubbleSort3(int a[],int n){<!-- --><br>             Boolean exchange = true;<br>             int k = n-1;<br>             while(exchange){<!-- --><br>                 exchange = false;<br>                 for(int i=0;i&lt;k;i++){<!-- --><br>                     if(a[i]&gt;a[i+1]){<!-- --><br>                         int temp;<br>                         temp = a[i];<br>                         a[i] = a[i+1];<br>                         a[i+1] = temp;<br>                         exchange = true;//交换后就置为true<br>                     }<br>                 }<br>                 k = k-1;//最大值交换到最终位置，相应减1，减少了比较和交换次数<br>             }<br>         }</p> 
<p>数据验证代码：</p> 
<p>public static void main(String args[]){<!-- --><br>         Scanner in = new Scanner(System.in);<br>         System.out.println("请从控制台输入数据：");<br>         //int a[]={10,56,32,98,75,12,3,59,87,16},i=0;<br>         String str[] = in.nextLine().split(" ");//字符串以空格分隔，得到的是字符串<br>         int num[] = new int[str.length];//创建并初始化数组，用于存储整形数据的数组，将字符串转为整型数据后存入num数组中<br>         for(int i=0;i&lt;str.length;i++){<!-- --><br>             num[i] = Integer.parseInt(String.valueOf(str[i]));<br>         }<br>         //while(in.hasNextInt()){<!-- --><br>         //    a[i++]=in.nextInt();<br>             //BubbleSort1(a,a.length);<br>         //}<br>         System.out.println("排序前转为数组中的整型数据为：");<br>         for(int i=0;i&lt;num.length;i++){<!-- --><br>             System.out.print(num[i]+" ");<br>         }<br>         System.out.println("\n使用三种冒泡排序算法排序后的结果为");<br>         int[] num_Bubble1 = num;<br>         int[] num_Bubble2 = num;<br>         BubbleSort1(num_Bubble1,num_Bubble1.length);//使用冒泡排序算法1对数据进行排序<br>         System.out.println("排序后的数组中的数据为：");<br>         for(int i=0;i&lt;num_Bubble1.length;i++){<!-- --><br>             System.out.print(num_Bubble1[i]+" ");<br>         }<br>         BubbleSort2(num_Bubble2,num_Bubble2.length);//使用冒泡排序算法2对数据进行排序<br>         System.out.println("\n排序后的数组中的数据为：");<br>         for(int i=0;i&lt;num_Bubble2.length;i++){<!-- --><br>             System.out.print(num_Bubble2[i]+" ");<br>         }<br>         BubbleSort3(num_Bubble2,num_Bubble2.length);//使用冒泡排序算法2对数据进行排序<br>         System.out.println("\n排序后的数组中的数据为：");<br>         for(int i=0;i&lt;num.length;i++){<!-- --><br>             System.out.print(num[i]+" ");<br>         }<br>     }</p> 
<p>时间复杂度：最好情况下（初始序列基本有序时）O(n)，平均情况下和最坏情况下都为O(n^2)</p> 
<p>空间复杂度：O(1)</p> 
<p>冒泡排序是一个稳定的排序算法</p> 
<p>5、快速排序</p> 
<p>基本思路：快速排序是对冒泡排序的一种改进，基本思想是基于分治法的：在待排序表L[1...n]中任取一个元素（一般是待排序表的第一个元素）作为基准，通过一趟排序将待排序表划分为独立的两部分L[1...k-1]和L[k+1...n]，使得L[1...k-1]中的所有元素小于基准元素，L[k+1...n]中的所有元素大于或等于基准元素，基准元素放在了最终位置L[k]上，这个过程称为一趟快速排序，后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，此时所有元素放在了其最终位置上。</p> 
<p>实例图为：</p> 
<p><img alt="" class="has" height="348" src="https://images2.imgbox.com/46/4e/VqvLpvax_o.png" width="847"></p> 
<p>Java代码如下：</p> 
<p>import java.util.Scanner;</p> 
<p>public class QuickSort {<!-- --><br>     //基准划分操作过程<br>     public static int Partition(int a[],int low,int high){<!-- --><br>         int pivot = a[low];//将当前表中第一个元素设为基准值，对表进行划分<br>         while(low&lt;high){<!-- --><br>             while(low&lt;high &amp;&amp; a[high]&gt;=pivot)<br>                 high--;<br>             if(low&lt;high){<!-- --><br>                 a[low] = a[high];<br>                 low++;<br>             }<br>             while(low&lt;high &amp;&amp; a[low]&lt;pivot)<br>                 low++;<br>             if(low&lt;high){<!-- --><br>                 a[high] = a[low];<br>                 high--;<br>             }<br>         }<br>         a[low] = pivot;<br>         return low;<br>     }<br>     //快速排序算法的递归过程<br>     public static void QuickSort_recurrence(int a[],int low,int high){<!-- --><br>         if(low&lt;high){//递归跳出条件<br>             //Partition（）属于划分操作，将表a[]划分为满足小于基准值的所有数据在左边大于基准值的所有数据在右边的两个子表<br>             int pivotPosition = Partition(a,low,high);//基于基准值划分两部分<br>             QuickSort_recurrence(a,low,pivotPosition-1);//依次对两个子表递归排序<br>             QuickSort_recurrence(a,pivotPosition+1,high);<br>         }<br>     }<br>     public static void main(String args[]){<!-- --><br>         System.out.println("请输入待排序的数据到数组中：");<br>         Scanner sc = new Scanner(System.in);<br>         String str[] = sc.nextLine().split(" ");//以空格相隔输入各个数据<br>         int num[] = new int[str.length];//数组创建及初始化<br>         for(int i=0;i&lt;str.length;i++){<!-- --><br>             num[i] = Integer.parseInt(String.valueOf(str[i]));<br>         }<br>         QuickSort_recurrence(num,0,num.length-1);//调用快速排序算法进行排序<br>         System.out.println("排序后的结果为：");<br>         for(int i=0;i&lt;num.length;i++){<!-- --><br>             System.out.print(num[i]+" ");<br>         }<br>     }<br> }<br> 时间复杂度：最好情况下和平均情况下（数据元素随机分布）为O(nlogn),最坏情况下（待排序表基本有序或基本逆序时）为O(n^2)</p> 
<p>空间复杂度：平均情况下为O(logn)，最坏情况下为O(n)</p> 
<p>快速排序是所有内部排序算法中平均性能最优的排序算法，适用于元素随机分布的情况，是一个不稳定的排序算法。</p> 
<p>6、简单（直接）选择排序</p> 
<p>基本思路：第i趟在后面n-i+1（i=1,2,3,...n-1）个待排序元素中选取关键字最小的元素，作为前面有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩下一个，就不用再选了，假设待排序表为L[1...n]，第i趟排序即从L[i...n]中选择关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置，进行n-1趟就使排序表有序。</p> 
<p>示例图为：</p> 
<p><img alt="" class="has" height="387" src="https://images2.imgbox.com/ff/c0/G31gxABb_o.png" width="868"></p> 
<p>Java代码如下：</p> 
<p>import java.util.Scanner;</p> 
<p>//简单（直接）选择排序<br> public class Direct_EasySelectSort {<!-- --><br>     public static void Direct_Easy_SelectSort(int a[],int n){<!-- --><br>         //对表a做简单选择排序，从0存储位置开始排序<br>         for(int i=0;i&lt;n-1;i++){//进行n-1趟<br>             int min = i;<br>             for(int j=i+1;j&lt;n;j++){//在a[i+1...n]数组中选择关键字最小的元素<br>                 if(a[j]&lt;a[min])<br>                     min = j;//找出关键字最小的元素，记录它的数组下标<br>             }<br>                 if(min!=i){//选择最小元素值与a[i]元素交换位置<br>                     int temp = a[i];<br>                     a[i] = a[min];<br>                     a[min] = temp;<br>                 }<br>         }<br>     }<br>     public static void main(String args[]){<!-- --><br>         System.out.println("请输入待排序的数据到数组中：");<br>         Scanner sc = new Scanner(System.in);<br>         String str[] = sc.nextLine().split(" ");<br>         int num[] = new int[str.length];<br>         for(int i=0;i&lt;num.length;i++){<!-- --><br>             num[i] = Integer.parseInt(String.valueOf(str[i]));<br>         }<br>         Direct_Easy_SelectSort(num,num.length);//调用简单选择排序算法对数组中的数据进行排序<br>         System.out.println("排序后的数组元素为：");<br>         for(int i=0;i&lt;num.length;i++){<!-- --><br>             System.out.print(num[i]+" ");<br>         }<br>     }<br> }<br> 时间复杂度：由于元素间比较的次数与序列的初始状态无关，始终有n(n-1)/2,因此平均情况、最好情况、最坏情况都是O(n^2)</p> 
<p>空间复杂度：O(1)</p> 
<p>简单选择排序是一个不稳定的排序算法</p> 
<p>7、堆排序</p> 
<p>堆排序也是选择排序中的一种，是一种树形选择排序方法，特点是：在排序过程中，将L[1...n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大或最小的元素。</p> 
<p>堆的定义如下：</p> 
<p>1）L(i)&lt;=L(2i)且L(i)&lt;=L(2i+1)【小根堆】或L(i)&gt;=L(2i)且L(i)&gt;=L(2i+1)【大根堆】</p> 
<p>以大根堆为例，最大元素存放在根节点中，且对其任意非根节点，它的值小于或等于其双亲节点值；在小根堆中正好相反，根节点是最小元素。</p> 
<p>堆排序分为两个步骤：1）创建初始堆；2）将堆顶元素与堆底元素交换位置，破坏堆的定义，重新调整堆，再重复这样的操作</p> 
<p><strong>细节</strong>：由于在堆排序中需要依靠数组下标来方便得到双亲节点与其子节点的关系，因此在调整堆的过程中这里数组a[0]的作用只用来暂存元素，不存储实际元素的位置，牺牲一个数组元素空间位置，输出排序后的结果时从1到n输出，实际只有n个元素，但须创建n+1个元素的数组。</p> 
<p>示例图为：</p> 
<p><img alt="" class="has" height="561" src="https://images2.imgbox.com/19/65/HmCkknH2_o.png" width="836"></p> 
<p>Java代码如下：</p> 
<p>import java.util.Scanner;</p> 
<p>public class BigRootHeapSort {<!-- --><br>     public static void AdjustDown(int a[],int k,int length){<!-- --><br>         //函数AdjustDown将元素k向下进行调整成大根堆<br>         a[0] = a[k];//a[0]暂存元素,仅作为替代值<br>         for(int i=k*2;i&lt;=length;i=i*2){<!-- --><br>             if(i&lt;length &amp;&amp; a[i]&lt;a[i+1]){<!-- --><br>                 i++;//取左右子节点中关键字较大的子节点的下标<br>             }<br>             if(a[0]&gt;a[i])//被筛选节点小于双亲节点，筛选结束<br>                 break;<br>             else{<!-- --><br>                 a[k] = a[i];//将a[i]调整到双亲节点上<br>                 k=i;//修改k值，以便继续向下筛选<br>             }<br>         }<br>         a[k] = a[0];//被筛选节点值放入最终位置<br>     }<br>     //插入元素时，重新整理成大根堆，使用向上调整堆的算法<br>     public static void AdjustUp(int a[],int k){<!-- --><br>         //参数k为向上调整的节点，也是堆的元素个数<br>         a[0] =a[k];<br>         int i = k/2;//若节点值大于双亲节点，则将双亲节点向下调，并继续向上比较<br>         while(i&gt;0 &amp;&amp; a[i]&lt;a[0]){//循环跳出条件<br>             a[k] = a[i];//双亲节点往下调<br>             k=i;<br>             i = k/2;//继续向上比较<br>         }<br>         a[k] = a[0];//复制到最终位置<br>     }<br>     public static void BuildMaxHeap(int a[],int length){<!-- --><br>         //初始创建大根堆<br>         for(int i=length/2;i&gt;0;i--){//从i=n/2到1反复调整堆<br>             AdjustDown(a,i,length);<br>         }<br>     }<br>     public static void HeapSort(int a[],int length){<!-- --><br>         //进行堆排序<br>         BuildMaxHeap(a,length);//初始创建大根堆<br>         for(int i=length;i&gt;1;i--){//n-1趟的交换和建堆过程<br>             int temp = a[i];//堆顶元素和堆底元素交换位置，删除元素时也是用同样的交换方法先将最大元素放在堆底，再取出堆底元素进行删除<br>             a[i] = a[1];<br>             a[1] = temp;<br>             AdjustDown(a,1,i-1);//整理，把剩余的i-1个元素重新调整成堆<br>         }<br>     }<br>     public static void main(String args[]){<!-- --><br>         //这里将a[0]元素置为0，便于大根堆的调整与交换，实际上存入了n个数但只会用到n-1个数<br>         System.out.println("请输入待排序的数据到数组中：");<br>         Scanner sc = new Scanner(System.in);<br>         String str[] = sc.nextLine().split(" ");<br>         int num[] = new int[str.length];<br>         for(int i=0;i&lt;num.length;i++){<!-- --><br>             num[i] = Integer.parseInt(String.valueOf(str[i]));<br>         }<br>         System.out.println("形成大根堆后元素排列顺序为：");<br>         BuildMaxHeap(num,num.length-1);//调用大根堆创建过程算法排列数组元素<br>         for(int i=1;i&lt;num.length;i++)<br>             System.out.print(num[i]+" ");<br>         System.out.println("\n堆排序后的数组元素为：");<br>         HeapSort(num,num.length-1);//调用堆排序算法对数组元素排序<br>         for(int i=1;i&lt;num.length;i++)<br>             System.out.print(num[i]+" ");<br>     }<br> }</p> 
<p>时间复杂度：在最好、最坏、平均情况下堆排序都为O(nlogn)</p> 
<p>空间复杂度：O(1)</p> 
<p>堆排序是一个不稳定的排序算法</p> 
<p>8、归并排序</p> 
<p>归并排序有多路归并和2-路归并，在内部排序中一般使用2-路归并排序，在外部排序中使用多路归并排序</p> 
<p>基本思路：归并排序与基于交换、选择等排序思想不一样，归并是将两个或两个以上的有序表组合成一个新的有序表。假定待排序表含有n个记录，可以看成是n个有序的子表，每个子表长度为1，然后两两归并，得到n/2（向上取整）个长度为2或1的有序表；在两两归并，如此反复，直到合并成一个长度为n的有序表为止。</p> 
<p>递归形式的2-路归并排序算法是基于分治的，其过程为：</p> 
<p>分解：将含有n个元素的待排序表分成各含n/2个元素的子表，采用2-路归并排序算法对两个子表递归地进行排序；</p> 
<p>合并：合并两个已排好序的子表得到排序结果；</p> 
<p>示例图为：</p> 
<p><img alt="" class="has" height="358" src="https://images2.imgbox.com/03/69/xHEvW60S_o.png" width="817"></p> 
<p>Java代码如下：</p> 
<p>import java.util.Scanner;</p> 
<p>public class MergeIntoSort {<!-- --><br>     public static void Merge(int a[],int low,int mid,int high){<!-- --><br>         //表a的两段a[low...mid]和a[mid+1...high]各自有序，将它们合并成一个有序表<br>         //设立铺助数组b[]<br>         int b[] = new int[a.length];<br>         for(int i=low;i&lt;=high;i++){<!-- --><br>             b[i]=a[i];//将a中所有元素复制到b数组中<br>         }<br>         int i,j,k;<br>         for(i=low,j=mid+1,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++){<!-- --><br>             if(b[i]&lt;=b[j])//比较b数组左右两段中的元素<br>                 a[k] = b[i++];//小的数复制到a数组中<br>             else//不能改为if(b[i]&gt;b[j])<br>                 a[k] = b[j++];<br>         }<br>         while(i&lt;=mid)<br>             a[k++] = b[i++];//若前段未复制完，直接复制<br>         while(j&lt;=high)<br>             a[k++] = b[j++];//若后段未复制完，直接复制<br>     }<br>     //使用递归形式的分治法进行归并排序<br>     public static void MergeSort(int a[],int low,int high){<!-- --><br>         if(low&lt;high){<!-- --><br>             int mid = (low+high)/2;//从中间划分两个子序列<br>             MergeSort(a,low,mid);//对左侧子序列进行递归排序<br>             MergeSort(a,mid+1,high);//对右侧子序列进行递归排序<br>             Merge(a,low,mid,high);//划分之后归并<br>         }<br>     }<br>     public static void main(String args[]){<!-- --><br>         System.out.println("请输入待排序的数据到数组中：");<br>         Scanner sc = new Scanner(System.in);<br>         String str[] = sc.nextLine().split(" ");<br>         int num[] = new int[str.length];<br>         for(int i=0;i&lt;num.length;i++){<!-- --><br>             num[i] = Integer.parseInt(String.valueOf(str[i]));<br>         }<br>         //调用归并排序算法进行排序<br>         MergeSort(num,0,num.length-1);<br>         System.out.println("排序后的结果为：");<br>         for(int i=0;i&lt;num.length;i++){<!-- --><br>             System.out.print(num[i]+" ");<br>         }<br>     }<br> }<br> 时间复杂度：平均、最好、最坏情况下都为O(nlogn)</p> 
<p>空间复杂度：需要n个单元的铺助空间，因此为O(n)</p> 
<p>2-路归并排序算法是一个稳定的排序算法；</p> 
<p><strong>注：一般而言，对于N个元素进行k-路归并排序时，排序的趟数m满足k^m=N,可得m=logk(N)，又考虑到m为整数，所以m=|logk(N)|(向上取整)</strong></p> 
<p>9、基数排序</p> 
<p>基本思路：</p> 
<p>基数排序不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先排序（MSD）和最低位优先排序(LSD)。</p> 
<p>以三位数的元素为例，可将元素看作为（K^3,K^2,K^1）组合，K^3是百位上的数字，K^2是十位上的数字，K^1是个位上的数字，使用最高位优先排序方法，在排序过程中，首先根据百位上的数字（K^3）进行排序，按各元素在百位上的取值，分配到各个子序列（称为桶）中，然后然后再按桶的编号，逐桶进行递归地基数排序，在每个桶中，子序列的规模已经大大减少，同时桶中所有元素在百位上的数字取值相同，这时，按各元素的十位上的数字（K^2）取值继续进行桶式分配，之后还对各个子桶中的元素按个位（K^1）进行分配，从而使得待排序序列所有元素排好序。</p> 
<p>示例图为：</p> 
<p><img alt="" class="has" height="391" src="https://images2.imgbox.com/5a/41/x4Tog3Tl_o.png" width="858"></p> 
<p>相应代码如下：</p> 
<p><img alt="" class="has" height="631" src="https://images2.imgbox.com/2f/9a/pTXbUyA0_o.png" width="768"></p> 
<p><strong>各个排序算法比较及其适用范围说明：</strong></p> 
<p><img alt="" class="has" height="582" src="https://images2.imgbox.com/78/1c/YN2DRdEG_o.png" width="790"></p> 
<p>各种排序算法的使用范围总结：</p> 
<p>      (1)当数据规模较小的时候，可以使用简单的排序算法如直接插入排序或直接选择排序。</p> 
<p>      (2)当待排序表的初始状态已经基本有序时，可以使用直接插入排序（希尔排序）或冒泡排序。</p> 
<p>当数据规模较大时，应采用时间复杂度为O(nlogn)的排序方法：快速排序、堆排序、归并排序。</p> 
<p>      (3)当数据规模较大时，应用速度快的排序算法。可以考虑快速排序。当记录随机分布的时候，快排的平均时间最短，但可能出现最坏的情况，这时候的时间复杂度是O(n^2)，且递归深度为n，所需的栈空间为O(n)。</p> 
<p>      (4)堆排序不会出现快排那样的最坏情况，且堆排序所需的辅助空间比快排要少。但这两种算法都不是稳定的，若要求排序时稳定，可以考虑用归并排序。</p> 
<p>       (5)归并排序可以用于内部排序，也可以用于外部排序。在外部排序时，通常采用多路归并，并且通过解决长顺串的合并，产生长的初始串，提高主机与外设并行能力等措施，以减少访问外存次数，提高外排序的效率。</p> 
<p>     （6）当数据规模很大，记录的关键字位数较少且可以分解时，采用基数排序较好。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d560780822794765ec449808b01eb8cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue组件中，data为什么必须是个函数，而不是对象</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b60050f9c2dcfebd03171bc2aab7cef2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java获取指定范围内的随机小数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>