<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android RecyclerView 使用完全解析 体验艺术般的控件 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android RecyclerView 使用完全解析 体验艺术般的控件" />
<meta property="og:description" content="转载请标明出处： http://blog.csdn.net/lmj623565791/article/details/45059587； 本文出自:【张鸿洋的博客】
概述 RecyclerView出现已经有一段时间了，相信大家肯定不陌生了，大家可以通过导入support-v7对其进行使用。 据官方的介绍，该控件用于在有限的窗口中展示大量数据集，其实这样功能的控件我们并不陌生，例如：ListView、GridView。
那么有了ListView、GridView为什么还需要RecyclerView这样的控件呢？整体上看RecyclerView架构，提供了一种插拔式的体验，高度的解耦，异常的灵活，通过设置它提供的不同LayoutManager，ItemDecoration , ItemAnimator实现令人瞠目的效果。
你想要控制其显示的方式，请通过布局管理器LayoutManager你想要控制Item间的间隔（可绘制），请通过ItemDecoration你想要控制Item增删的动画，请通过ItemAnimator你想要控制点击、长按事件，请自己写（擦，这点尼玛。） 基本使用 鉴于我们对于ListView的使用特别的熟悉，对比下RecyclerView的使用代码：
mRecyclerView = findView(R.id.id_recyclerview); //设置布局管理器 mRecyclerView.setLayoutManager(layout); //设置adapter mRecyclerView.setAdapter(adapter) //设置Item增加、移除动画 mRecyclerView.setItemAnimator(new DefaultItemAnimator()); //添加分割线 mRecyclerView.addItemDecoration(new DividerItemDecoration( getActivity(), DividerItemDecoration.HORIZONTAL_LIST)); ok，相比较于ListView的代码，ListView可能只需要去设置一个adapter就能正常使用了。而RecyclerView基本需要上面一系列的步骤，那么为什么会添加这么多的步骤呢？
那么就必须解释下RecyclerView的这个名字了，从它类名上看，RecyclerView代表的意义是，我只管Recycler View，也就是说RecyclerView只管回收与复用View，其他的你可以自己去设置。可以看出其高度的解耦，给予你充分的定制自由（所以你才可以轻松的通过这个控件实现ListView,GirdView，瀑布流等效果）。
Just like ListView Activity package com.zhy.sample.demo_recyclerview; import java.util.ArrayList; import java.util.List; import android.os.Bundle; import android.support.v7.app.ActionBarActivity; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.support.v7.widget.RecyclerView.ViewHolder; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; public class HomeActivity extends ActionBarActivity { private RecyclerView mRecyclerView; private List&lt;String&gt; mDatas; private HomeAdapter mAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/b02933fec91537eefaed1fb78e0f7049/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-04-16T09:07:16+08:00" />
<meta property="article:modified_time" content="2015-04-16T09:07:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android RecyclerView 使用完全解析 体验艺术般的控件</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>转载请标明出处： <br> <a href="http://blog.csdn.net/lmj623565791/article/details/45059587">http://blog.csdn.net/lmj623565791/article/details/45059587</a>； <br> 本文出自:<a href="http://blog.csdn.net/lmj623565791/">【张鸿洋的博客】</a></p> 
</blockquote> 
<h4 id="概述">概述</h4> 
<p>RecyclerView出现已经有一段时间了，相信大家肯定不陌生了，大家可以通过导入support-v7对其进行使用。 <br> 据官方的介绍，该控件用于在有限的窗口中展示大量数据集，其实这样功能的控件我们并不陌生，例如：ListView、GridView。</p> 
<p>那么有了ListView、GridView为什么还需要RecyclerView这样的控件呢？整体上看RecyclerView架构，提供了一种插拔式的体验，高度的解耦，异常的灵活，通过设置它提供的不同LayoutManager，ItemDecoration , ItemAnimator实现令人瞠目的效果。</p> 
<ul><li>你想要控制其显示的方式，请通过布局管理器LayoutManager</li><li>你想要控制Item间的间隔（可绘制），请通过ItemDecoration</li><li>你想要控制Item增删的动画，请通过ItemAnimator</li><li>你想要控制点击、长按事件，请自己写（擦，这点尼玛。）</li></ul> 
<h4 id="基本使用">基本使用</h4> 
<p>鉴于我们对于ListView的使用特别的熟悉，对比下RecyclerView的使用代码：</p> 
<pre class="prettyprint"><code class="language-java hljs ">mRecyclerView = findView(R.id.id_recyclerview);
<span class="hljs-comment">//设置布局管理器</span>
mRecyclerView.setLayoutManager(layout);
<span class="hljs-comment">//设置adapter</span>
mRecyclerView.setAdapter(adapter)
<span class="hljs-comment">//设置Item增加、移除动画</span>
mRecyclerView.setItemAnimator(<span class="hljs-keyword">new</span> DefaultItemAnimator());
<span class="hljs-comment">//添加分割线</span>
mRecyclerView.addItemDecoration(<span class="hljs-keyword">new</span> DividerItemDecoration(
                getActivity(), DividerItemDecoration.HORIZONTAL_LIST));</code></pre> 
<p>ok，相比较于ListView的代码，ListView可能只需要去设置一个adapter就能正常使用了。而RecyclerView基本需要上面一系列的步骤，那么为什么会添加这么多的步骤呢？</p> 
<p>那么就必须解释下RecyclerView的这个名字了，从它类名上看，RecyclerView代表的意义是，我只管Recycler View，也就是说RecyclerView只管回收与复用View，其他的你可以自己去设置。可以看出其高度的解耦，给予你充分的定制自由（所以你才可以轻松的通过这个控件实现ListView,GirdView，瀑布流等效果）。</p> 
<h4 id="just-like-listview">Just like ListView</h4> 
<ul><li>Activity</li></ul> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">package</span> com.zhy.sample.demo_recyclerview;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">import</span> android.os.Bundle;
<span class="hljs-keyword">import</span> android.support.v7.app.ActionBarActivity;
<span class="hljs-keyword">import</span> android.support.v7.widget.LinearLayoutManager;
<span class="hljs-keyword">import</span> android.support.v7.widget.RecyclerView;
<span class="hljs-keyword">import</span> android.support.v7.widget.RecyclerView.ViewHolder;
<span class="hljs-keyword">import</span> android.view.LayoutInflater;
<span class="hljs-keyword">import</span> android.view.View;
<span class="hljs-keyword">import</span> android.view.ViewGroup;
<span class="hljs-keyword">import</span> android.widget.TextView;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ActionBarActivity</span>
{<!-- --></span>

    <span class="hljs-keyword">private</span> RecyclerView mRecyclerView;
    <span class="hljs-keyword">private</span> List&lt;String&gt; mDatas;
    <span class="hljs-keyword">private</span> HomeAdapter mAdapter;

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span>(Bundle savedInstanceState)
    {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.activity_single_recyclerview);

        initData();
        mRecyclerView = (RecyclerView) findViewById(R.id.id_recyclerview);
        mRecyclerView.setLayoutManager(<span class="hljs-keyword">new</span> LinearLayoutManager(<span class="hljs-keyword">this</span>));
        mRecyclerView.setAdapter(mAdapter = <span class="hljs-keyword">new</span> HomeAdapter());

    }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initData</span>()
    {
        mDatas = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-string">'A'</span>; i &lt; <span class="hljs-string">'z'</span>; i++)
        {
            mDatas.add(<span class="hljs-string">""</span> + (<span class="hljs-keyword">char</span>) i);
        }
    }

    class HomeAdapter extends RecyclerView.Adapter&lt;HomeAdapter.MyViewHolder&gt;
    {

        <span class="hljs-annotation">@Override</span>
        <span class="hljs-keyword">public</span> MyViewHolder <span class="hljs-title">onCreateViewHolder</span>(ViewGroup parent, <span class="hljs-keyword">int</span> viewType)
        {
            MyViewHolder holder = <span class="hljs-keyword">new</span> MyViewHolder(LayoutInflater.from(
                    HomeActivity.<span class="hljs-keyword">this</span>).inflate(R.layout.item_home, parent,
                    <span class="hljs-keyword">false</span>));
            <span class="hljs-keyword">return</span> holder;
        }

        <span class="hljs-annotation">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span>(MyViewHolder holder, <span class="hljs-keyword">int</span> position)
        {
            holder.tv.setText(mDatas.get(position));
        }

        <span class="hljs-annotation">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span>()
        {
            <span class="hljs-keyword">return</span> mDatas.size();
        }

        class MyViewHolder extends ViewHolder
        {

            TextView tv;

            <span class="hljs-keyword">public</span> <span class="hljs-title">MyViewHolder</span>(View view)
            {
                <span class="hljs-keyword">super</span>(view);
                tv = (TextView) view.findViewById(R.id.id_num);
            }
        }
    }

}</code></pre> 
<ul><li>Activity的布局文件</li></ul> 
<pre class="prettyprint"><code class="language-xml hljs "><span class="hljs-tag">&lt;<span class="hljs-title">RelativeLayout</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attribute">xmlns:tools</span>=<span class="hljs-value">"http://schemas.android.com/tools"</span>
    <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
    <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span> &gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-title">android.support.v7.widget.RecyclerView
</span>        <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/id_recyclerview"</span>
         <span class="hljs-attribute">android:divider</span>=<span class="hljs-value">"#ffff0000"</span>
           <span class="hljs-attribute">android:dividerHeight</span>=<span class="hljs-value">"10dp"</span>
        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span> /&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-title">RelativeLayout</span>&gt;</span></code></pre> 
<ul><li>Item的布局文件</li></ul> 
<pre class="prettyprint"><code class="language-xml hljs "><span class="hljs-pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">FrameLayout</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
    <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"#44ff0000"</span>
    <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span> &gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-title">TextView
</span>        <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/id_num"</span>
        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"50dp"</span>
        <span class="hljs-attribute">android:gravity</span>=<span class="hljs-value">"center"</span>
        <span class="hljs-attribute">android:text</span>=<span class="hljs-value">"1"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">FrameLayout</span>&gt;</span></code></pre> 
<p>这么看起来用法与ListView的代码基本一致哈~~ <br> 看下效果图：</p> 
<p><img src="https://images2.imgbox.com/e2/5e/L2cZLiHU_o.png" width="400px"></p> 
<p>看起来好丑，Item间应该有个分割线，当你去找时，你会发现RecyclerView并没有支持divider这样的属性。那么怎么办，你可以给Item的布局去设置margin，当然了这种方式不够优雅，我们文章开始说了，我们可以自由的去定制它，当然我们的分割线也是可以定制的。</p> 
<h4 id="itemdecoration">ItemDecoration</h4> 
<p>我们可以通过该方法添加分割线： <br> <code>mRecyclerView.addItemDecoration()</code> <br> 该方法的参数为RecyclerView.ItemDecoration，该类为抽象类，官方目前并没有提供默认的实现类（我觉得最好能提供几个）。 <br> 该类的源码：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItemDecoration</span> {<!-- --></span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span>(Canvas c, RecyclerView parent, State state) {
            onDraw(c, parent);
 }


<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDrawOver</span>(Canvas c, RecyclerView parent, State state) {
            onDrawOver(c, parent);
 }

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getItemOffsets</span>(Rect outRect, View view, RecyclerView parent, State state) {
            getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(),
                    parent);
}

<span class="hljs-annotation">@Deprecated</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getItemOffsets</span>(Rect outRect, <span class="hljs-keyword">int</span> itemPosition, RecyclerView parent) {
            outRect.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
 }
</code></pre> 
<p>当我们调用<code>mRecyclerView.addItemDecoration()</code>方法添加decoration的时候，RecyclerView在绘制的时候，去会绘制decorator，即调用该类的onDraw和onDrawOver方法，</p> 
<ul><li>onDraw方法先于drawChildren</li><li>onDrawOver在drawChildren之后，一般我们选择复写其中一个即可。</li><li>getItemOffsets 可以通过outRect.set()为每个Item设置一定的偏移量，主要用于绘制Decorator。</li></ul> 
<p>接下来我们看一个<code>RecyclerView.ItemDecoration</code>的实现类，该类很好的实现了RecyclerView添加分割线（当使用LayoutManager为LinearLayoutManager时）。 <br> 该类参考自：<a href="http://blog.csdn.net/lmj623565791/article/details/38173061">DividerItemDecoration</a></p> 
<pre class="prettyprint"><code class="language-java hljs ">
<span class="hljs-keyword">package</span> com.zhy.sample.demo_recyclerview;

<span class="hljs-comment">/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * limitations under the License.
 */</span>

<span class="hljs-keyword">import</span> android.content.Context;
<span class="hljs-keyword">import</span> android.content.res.TypedArray;
<span class="hljs-keyword">import</span> android.graphics.Canvas;
<span class="hljs-keyword">import</span> android.graphics.Rect;
<span class="hljs-keyword">import</span> android.graphics.drawable.Drawable;
<span class="hljs-keyword">import</span> android.support.v7.widget.LinearLayoutManager;
<span class="hljs-keyword">import</span> android.support.v7.widget.RecyclerView;
<span class="hljs-keyword">import</span> android.support.v7.widget.RecyclerView.State;
<span class="hljs-keyword">import</span> android.util.Log;
<span class="hljs-keyword">import</span> android.view.View;


<span class="hljs-javadoc">/**
 * This class is from the v7 samples of the Android SDK. It's not by me!
 * &lt;p/&gt;
 * See the license above for details.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DividerItemDecoration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ItemDecoration</span> {<!-- --></span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] ATTRS = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{
            android.R.attr.listDivider
    };

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> VERTICAL_LIST = LinearLayoutManager.VERTICAL;

    <span class="hljs-keyword">private</span> Drawable mDivider;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mOrientation;

    <span class="hljs-keyword">public</span> <span class="hljs-title">DividerItemDecoration</span>(Context context, <span class="hljs-keyword">int</span> orientation) {
        <span class="hljs-keyword">final</span> TypedArray a = context.obtainStyledAttributes(ATTRS);
        mDivider = a.getDrawable(<span class="hljs-number">0</span>);
        a.recycle();
        setOrientation(orientation);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrientation</span>(<span class="hljs-keyword">int</span> orientation) {
        <span class="hljs-keyword">if</span> (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"invalid orientation"</span>);
        }
        mOrientation = orientation;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span>(Canvas c, RecyclerView parent) {
        Log.v(<span class="hljs-string">"recyclerview - itemdecoration"</span>, <span class="hljs-string">"onDraw()"</span>);

        <span class="hljs-keyword">if</span> (mOrientation == VERTICAL_LIST) {
            drawVertical(c, parent);
        } <span class="hljs-keyword">else</span> {
            drawHorizontal(c, parent);
        }

    }


    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawVertical</span>(Canvas c, RecyclerView parent) {
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> left = parent.getPaddingLeft();
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> right = parent.getWidth() - parent.getPaddingRight();

        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childCount = parent.getChildCount();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++) {
            <span class="hljs-keyword">final</span> View child = parent.getChildAt(i);
            android.support.v7.widget.RecyclerView v = <span class="hljs-keyword">new</span> android.support.v7.widget.RecyclerView(parent.getContext());
            <span class="hljs-keyword">final</span> RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child
                    .getLayoutParams();
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> top = child.getBottom() + params.bottomMargin;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bottom = top + mDivider.getIntrinsicHeight();
            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(c);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawHorizontal</span>(Canvas c, RecyclerView parent) {
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> top = parent.getPaddingTop();
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bottom = parent.getHeight() - parent.getPaddingBottom();

        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childCount = parent.getChildCount();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++) {
            <span class="hljs-keyword">final</span> View child = parent.getChildAt(i);
            <span class="hljs-keyword">final</span> RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child
                    .getLayoutParams();
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> left = child.getRight() + params.rightMargin;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> right = left + mDivider.getIntrinsicHeight();
            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(c);
        }
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getItemOffsets</span>(Rect outRect, <span class="hljs-keyword">int</span> itemPosition, RecyclerView parent) {
        <span class="hljs-keyword">if</span> (mOrientation == VERTICAL_LIST) {
            outRect.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mDivider.getIntrinsicHeight());
        } <span class="hljs-keyword">else</span> {
            outRect.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mDivider.getIntrinsicWidth(), <span class="hljs-number">0</span>);
        }
    }
}</code></pre> 
<p>该实现类可以看到通过读取系统主题中的 <code>android.R.attr.listDivider</code>作为Item间的分割线，并且支持横向和纵向。如果你不清楚它是怎么做到的读取系统的属性用于自身，请参考我的另一篇博文：<a href="http://blog.csdn.net/lmj623565791/article/details/38173061">Android 深入理解Android中的自定义属性</a></p> 
<p>获取到listDivider以后，该属性的值是个Drawable，在<code>getItemOffsets</code>中，outRect去设置了绘制的范围。onDraw中实现了真正的绘制。</p> 
<p>我们在原来的代码中添加一句：</p> 
<pre class="prettyprint"><code class="language-java hljs ">mRecyclerView.addItemDecoration(<span class="hljs-keyword">new</span> DividerItemDecoration(<span class="hljs-keyword">this</span>,
DividerItemDecoration.VERTICAL_LIST));</code></pre> 
<p>ok，现在再运行，就可以看到分割线的效果了。</p> 
<p><img src="https://images2.imgbox.com/90/44/UQd4ok9h_o.png" width="400px"></p> 
<p>该分割线是系统默认的，你可以在theme.xml中找到该属性的使用情况。那么，使用系统的listDivider有什么好处呢？就是方便我们去随意的改变，该属性我们可以直接声明在：</p> 
<pre class="prettyprint"><code class="language-xml hljs "> <span class="hljs-comment">&lt;!-- Application theme. --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">style</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"AppTheme"</span> <span class="hljs-attribute">parent</span>=<span class="hljs-value">"AppBaseTheme"</span>&gt;</span><span class="css">
      &lt;<span class="hljs-tag">item</span> <span class="hljs-tag">name</span>="<span class="hljs-tag">android</span><span class="hljs-pseudo">:listDivider"</span>&gt;<span class="hljs-at_rule">@<span class="hljs-keyword">drawable/divider_bg&lt;/item&gt;</span>  
    </span></span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span></code></pre> 
<p>然后自己写个drawable即可，下面我们换一种分隔符：</p> 
<pre class="prettyprint"><code class="language-java hljs ">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;
&lt;shape xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    android:shape=<span class="hljs-string">"rectangle"</span> &gt;

    &lt;gradient
        android:centerColor=<span class="hljs-string">"#ff00ff00"</span>
        android:endColor=<span class="hljs-string">"#ff0000ff"</span>
        android:startColor=<span class="hljs-string">"#ffff0000"</span>
        android:type=<span class="hljs-string">"linear"</span> /&gt;
    &lt;size android:height=<span class="hljs-string">"4dp"</span>/&gt;

&lt;/shape&gt;</code></pre> 
<p>现在的样子是：</p> 
<p><img src="https://images2.imgbox.com/6f/f3/U5U8jNTp_o.png" width="400px"></p> 
<p>当然了，你可以根据自己的需求，去随意的绘制，反正是画出来的，随便玩~~</p> 
<p>ok，看到这，你可能觉得，这玩意真尼玛麻烦，完全不能比拟的心爱的ListView。那么继续看。</p> 
<h4 id="layoutmanager">LayoutManager</h4> 
<p>好了，上面实现了类似ListView样子的Demo，通过使用其默认的LinearLayoutManager。</p> 
<p>RecyclerView.LayoutManager吧，这是一个抽象类，好在系统提供了3个实现类：</p> 
<ol><li>LinearLayoutManager 现行管理器，支持横向、纵向。</li><li>GridLayoutManager 网格布局管理器</li><li>StaggeredGridLayoutManager 瀑布就式布局管理器</li></ol> 
<p>上面我们已经初步体验了下LinearLayoutManager，接下来看GridLayoutManager。</p> 
<ul><li>GridLayoutManager</li></ul> 
<p>我们尝试去实现类似GridView，秒秒钟的事情：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//mRecyclerView.setLayoutManager(new LinearLayoutManager(this));</span>
        mRecyclerView.setLayoutManager(<span class="hljs-keyword">new</span> GridLayoutManager(<span class="hljs-keyword">this</span>,<span class="hljs-number">4</span>));</code></pre> 
<p>只需要修改LayoutManager即可，还是很nice的。</p> 
<p>当然了，改为GridLayoutManager以后，对于分割线，前面的DividerItemDecoration就不适用了，主要是因为它在绘制的时候，比如水平线，针对每个child的取值为：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> left = parent.getPaddingLeft();
<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> right = parent.getWidth() - parent.getPaddingRight();</code></pre> 
<p>因为每个Item一行，这样是没问题的。而GridLayoutManager时，一行有多个childItem，这样就多次绘制了，并且GridLayoutManager时，Item如果为最后一列（则右边无间隔线）或者为最后一行（底部无分割线）。</p> 
<p>针对上述，我们编写了<code>DividerGridItemDecoration</code>。</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">package</span> com.zhy.sample.demo_recyclerview;

<span class="hljs-keyword">import</span> android.content.Context;
<span class="hljs-keyword">import</span> android.content.res.TypedArray;
<span class="hljs-keyword">import</span> android.graphics.Canvas;
<span class="hljs-keyword">import</span> android.graphics.Rect;
<span class="hljs-keyword">import</span> android.graphics.drawable.Drawable;
<span class="hljs-keyword">import</span> android.support.v7.widget.GridLayoutManager;
<span class="hljs-keyword">import</span> android.support.v7.widget.RecyclerView;
<span class="hljs-keyword">import</span> android.support.v7.widget.RecyclerView.LayoutManager;
<span class="hljs-keyword">import</span> android.support.v7.widget.RecyclerView.State;
<span class="hljs-keyword">import</span> android.support.v7.widget.StaggeredGridLayoutManager;
<span class="hljs-keyword">import</span> android.view.View;

<span class="hljs-javadoc">/**
 * 
 *<span class="hljs-javadoctag"> @author</span> zhy
 * 
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DividerGridItemDecoration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ItemDecoration</span>
{<!-- --></span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] ATTRS = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] { android.R.attr.listDivider };
    <span class="hljs-keyword">private</span> Drawable mDivider;

    <span class="hljs-keyword">public</span> <span class="hljs-title">DividerGridItemDecoration</span>(Context context)
    {
        <span class="hljs-keyword">final</span> TypedArray a = context.obtainStyledAttributes(ATTRS);
        mDivider = a.getDrawable(<span class="hljs-number">0</span>);
        a.recycle();
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span>(Canvas c, RecyclerView parent, State state)
    {

        drawHorizontal(c, parent);
        drawVertical(c, parent);

    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSpanCount</span>(RecyclerView parent)
    {
        <span class="hljs-comment">// 列数</span>
        <span class="hljs-keyword">int</span> spanCount = -<span class="hljs-number">1</span>;
        LayoutManager layoutManager = parent.getLayoutManager();
        <span class="hljs-keyword">if</span> (layoutManager <span class="hljs-keyword">instanceof</span> GridLayoutManager)
        {

            spanCount = ((GridLayoutManager) layoutManager).getSpanCount();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (layoutManager <span class="hljs-keyword">instanceof</span> StaggeredGridLayoutManager)
        {
            spanCount = ((StaggeredGridLayoutManager) layoutManager)
                    .getSpanCount();
        }
        <span class="hljs-keyword">return</span> spanCount;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawHorizontal</span>(Canvas c, RecyclerView parent)
    {
        <span class="hljs-keyword">int</span> childCount = parent.getChildCount();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++)
        {
            <span class="hljs-keyword">final</span> View child = parent.getChildAt(i);
            <span class="hljs-keyword">final</span> RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child
                    .getLayoutParams();
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> left = child.getLeft() - params.leftMargin;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> right = child.getRight() + params.rightMargin
                    + mDivider.getIntrinsicWidth();
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> top = child.getBottom() + params.bottomMargin;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bottom = top + mDivider.getIntrinsicHeight();
            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(c);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawVertical</span>(Canvas c, RecyclerView parent)
    {
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childCount = parent.getChildCount();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++)
        {
            <span class="hljs-keyword">final</span> View child = parent.getChildAt(i);

            <span class="hljs-keyword">final</span> RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child
                    .getLayoutParams();
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> top = child.getTop() - params.topMargin;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bottom = child.getBottom() + params.bottomMargin;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> left = child.getRight() + params.rightMargin;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> right = left + mDivider.getIntrinsicWidth();

            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(c);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLastColum</span>(RecyclerView parent, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> spanCount,
            <span class="hljs-keyword">int</span> childCount)
    {
        LayoutManager layoutManager = parent.getLayoutManager();
        <span class="hljs-keyword">if</span> (layoutManager <span class="hljs-keyword">instanceof</span> GridLayoutManager)
        {
            <span class="hljs-keyword">if</span> ((pos + <span class="hljs-number">1</span>) % spanCount == <span class="hljs-number">0</span>)<span class="hljs-comment">// 如果是最后一列，则不需要绘制右边</span>
            {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (layoutManager <span class="hljs-keyword">instanceof</span> StaggeredGridLayoutManager)
        {
            <span class="hljs-keyword">int</span> orientation = ((StaggeredGridLayoutManager) layoutManager)
                    .getOrientation();
            <span class="hljs-keyword">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL)
            {
                <span class="hljs-keyword">if</span> ((pos + <span class="hljs-number">1</span>) % spanCount == <span class="hljs-number">0</span>)<span class="hljs-comment">// 如果是最后一列，则不需要绘制右边</span>
                {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                }
            } <span class="hljs-keyword">else</span>
            {
                childCount = childCount - childCount % spanCount;
                <span class="hljs-keyword">if</span> (pos &gt;= childCount)<span class="hljs-comment">// 如果是最后一列，则不需要绘制右边</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLastRaw</span>(RecyclerView parent, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> spanCount,
            <span class="hljs-keyword">int</span> childCount)
    {
        LayoutManager layoutManager = parent.getLayoutManager();
        <span class="hljs-keyword">if</span> (layoutManager <span class="hljs-keyword">instanceof</span> GridLayoutManager)
        {
            childCount = childCount - childCount % spanCount;
            <span class="hljs-keyword">if</span> (pos &gt;= childCount)<span class="hljs-comment">// 如果是最后一行，则不需要绘制底部</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (layoutManager <span class="hljs-keyword">instanceof</span> StaggeredGridLayoutManager)
        {
            <span class="hljs-keyword">int</span> orientation = ((StaggeredGridLayoutManager) layoutManager)
                    .getOrientation();
            <span class="hljs-comment">// StaggeredGridLayoutManager 且纵向滚动</span>
            <span class="hljs-keyword">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL)
            {
                childCount = childCount - childCount % spanCount;
                <span class="hljs-comment">// 如果是最后一行，则不需要绘制底部</span>
                <span class="hljs-keyword">if</span> (pos &gt;= childCount)
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            } <span class="hljs-keyword">else</span>
            <span class="hljs-comment">// StaggeredGridLayoutManager 且横向滚动</span>
            {
                <span class="hljs-comment">// 如果是最后一行，则不需要绘制底部</span>
                <span class="hljs-keyword">if</span> ((pos + <span class="hljs-number">1</span>) % spanCount == <span class="hljs-number">0</span>)
                {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                }
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getItemOffsets</span>(Rect outRect, <span class="hljs-keyword">int</span> itemPosition,
            RecyclerView parent)
    {
        <span class="hljs-keyword">int</span> spanCount = getSpanCount(parent);
        <span class="hljs-keyword">int</span> childCount = parent.getAdapter().getItemCount();
        <span class="hljs-keyword">if</span> (isLastRaw(parent, itemPosition, spanCount, childCount))<span class="hljs-comment">// 如果是最后一行，则不需要绘制底部</span>
        {
            outRect.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mDivider.getIntrinsicWidth(), <span class="hljs-number">0</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isLastColum(parent, itemPosition, spanCount, childCount))<span class="hljs-comment">// 如果是最后一列，则不需要绘制右边</span>
        {
            outRect.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mDivider.getIntrinsicHeight());
        } <span class="hljs-keyword">else</span>
        {
            outRect.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mDivider.getIntrinsicWidth(),
                    mDivider.getIntrinsicHeight());
        }
    }
}
</code></pre> 
<p>主要在<code>getItemOffsets</code>方法中，去判断如果是最后一行，则不需要绘制底部；如果是最后一列，则不需要绘制右边，整个判断也考虑到了<code>StaggeredGridLayoutManager</code>的横向和纵向，所以稍稍有些复杂。最重要还是去理解，如何绘制什么的不重要。一般如果仅仅是希望有空隙，还是去设置item的margin方便。</p> 
<p>最后的效果是：</p> 
<p><img src="https://images2.imgbox.com/b0/ae/JHoO3l2L_o.gif" width="400px"></p> 
<p>ok，看到这，你可能还觉得RecyclerView不够强大？</p> 
<p>但是如果我们有这么个需求，纵屏的时候显示为ListView，横屏的时候显示两列的GridView，我们RecyclerView可以轻松搞定，而如果使用ListView去实现还是需要点功夫的~~~</p> 
<p>当然了，这只是皮毛，下面让你心服口服。</p> 
<ul><li>StaggeredGridLayoutManager </li></ul> 
<p>瀑布流式的布局，其实他可以实现<code>GridLayoutManager</code>一样的功能，仅仅按照下列代码：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// mRecyclerView.setLayoutManager(new GridLayoutManager(this,4));</span>
        mRecyclerView.setLayoutManager(<span class="hljs-keyword">new</span> StaggeredGridLayoutManager(<span class="hljs-number">4</span>,        StaggeredGridLayoutManager.VERTICAL));</code></pre> 
<p>这两种写法显示的效果是一致的，但是注意StaggeredGridLayoutManager构造的第二个参数传一个orientation，如果传入的是<code>StaggeredGridLayoutManager.VERTICAL</code>代表有多少列；那么传入的如果是<code>StaggeredGridLayoutManager.HORIZONTAL</code>就代表有多少行，比如本例如果改为：</p> 
<pre class="prettyprint"><code class="language-java hljs ">mRecyclerView.setLayoutManager(<span class="hljs-keyword">new</span> StaggeredGridLayoutManager(<span class="hljs-number">4</span>,
        StaggeredGridLayoutManager.HORIZONTAL));</code></pre> 
<p>那么效果为：</p> 
<p><img src="https://images2.imgbox.com/9a/13/lrDXzJvG_o.gif" width="400px"></p> 
<p>可以看到，固定为4行，变成了左右滑动。有一点需要注意，如果是横向的时候，item的宽度需要注意去设置，毕竟横向的宽度没有约束了，应为控件可以横向滚动了。 <br> 如果你需要一样横向滚动的GridView，那么恭喜你。</p> 
<p>ok，接下来准备看大招，如果让你去实现个瀑布流，最起码不是那么随意就可以实现的吧？但是，如果使用RecyclerView，分分钟的事。 <br> 那么如何实现？其实你什么都不用做，只要使用<code>StaggeredGridLayoutManager</code>我们就已经实现了，只是上面的item布局我们使用了固定的高度，下面我们仅仅在适配器的<code>onBindViewHolder</code>方法中为我们的item设置个随机的高度（代码就不贴了，最后会给出源码下载地址），看看效果图：</p> 
<p><img src="https://images2.imgbox.com/a3/c5/h4hbAUAP_o.gif" width="400px"></p> 
<p>是不是棒棒哒，通过RecyclerView去实现ListView、GridView、瀑布流的效果基本上没有什么区别，而且可以仅仅通过设置不同的LayoutManager即可实现。</p> 
<p>还有更nice的地方，就在于item增加、删除的动画也是可配置的。接下来看一下ItemAnimator。</p> 
<h4 id="itemanimator">ItemAnimator</h4> 
<p>ItemAnimator也是一个抽象类，好在系统为我们提供了一种默认的实现类，期待系统多 <br> 添加些默认的实现。</p> 
<p>借助默认的实现，当Item添加和移除的时候，添加动画效果很简单:</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 设置item动画</span>
mRecyclerView.setItemAnimator(<span class="hljs-keyword">new</span> DefaultItemAnimator());</code></pre> 
<p>系统为我们提供了一个默认的实现，我们为我们的瀑布流添加以上一行代码，效果为：</p> 
<p><img src="https://images2.imgbox.com/3a/c2/opxqTohn_o.gif" width="400px"></p> 
<p>如果是GridLayoutManager呢？动画效果为：</p> 
<p><img src="https://images2.imgbox.com/b7/09/Bo434GLI_o.gif" width="400px"></p> 
<p>注意，这里更新数据集不是用<code>adapter.notifyDataSetChanged()</code>而是 <br> <code>notifyItemInserted(position)</code>与<code>notifyItemRemoved(position)</code> <br> 否则没有动画效果。 <br> 上述为adapter中添加了两个方法：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addData</span>(<span class="hljs-keyword">int</span> position) {
        mDatas.add(position, <span class="hljs-string">"Insert One"</span>);
        notifyItemInserted(position);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeData</span>(<span class="hljs-keyword">int</span> position) {
            mDatas.remove(position);
        notifyItemRemoved(position);
    }</code></pre> 
<p>Activity中点击MenuItem触发：</p> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onCreateOptionsMenu</span>(Menu menu)
    {
        getMenuInflater().inflate(R.menu.main, menu);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onCreateOptionsMenu(menu);
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onOptionsItemSelected</span>(MenuItem item)
    {
        <span class="hljs-keyword">switch</span> (item.getItemId())
        {
        <span class="hljs-keyword">case</span> R.id.id_action_add:
            mAdapter.addData(<span class="hljs-number">1</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> R.id.id_action_delete:
            mAdapter.removeData(<span class="hljs-number">1</span>);
            <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }</code></pre> 
<p>好了，到这我对这个控件已经不是一般的喜欢了~~~</p> 
<p>当然了只提供了一种动画，那么我们肯定可以去自定义各种nice的动画效果。 <br> 高兴的是，github上已经有很多类似的项目了，这里我们直接引用下：<a href="https://github.com/gabrielemariotti/RecyclerViewItemAnimators">RecyclerViewItemAnimators</a>，大家自己下载查看。 <br> 提供了<code>SlideInOutLeftItemAnimator</code>,<code>SlideInOutRightItemAnimator</code>, <br> <code>SlideInOutTopItemAnimator</code>,<code>SlideInOutBottomItemAnimator</code>等动画效果。</p> 
<h4 id="click-and-longclick">Click and LongClick</h4> 
<p>不过一个挺郁闷的地方就是，系统没有提供ClickListener和LongClickListener。 <br> 不过我们也可以自己去添加，只是会多了些代码而已。 <br> 实现的方式比较多，你可以通过mRecyclerView.addOnItemTouchListener去监听然后去判断手势， <br> 当然你也可以通过adapter中自己去提供回调，这里我们选择后者，前者的方式，大家有兴趣自己去实现。</p> 
<p>那么代码也比较简单：</p> 
<pre class="prettyprint"><code class="language-java hljs ">class HomeAdapter extends RecyclerView.Adapter&lt;HomeAdapter.MyViewHolder&gt;
{

<span class="hljs-comment">//...</span>
    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OnItemClickLitener</span>
    {<!-- --></span>
        <span class="hljs-keyword">void</span> onItemClick(View view, <span class="hljs-keyword">int</span> position);
        <span class="hljs-keyword">void</span> onItemLongClick(View view , <span class="hljs-keyword">int</span> position);
    }

    <span class="hljs-keyword">private</span> OnItemClickLitener mOnItemClickLitener;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOnItemClickLitener</span>(OnItemClickLitener mOnItemClickLitener)
    {
        <span class="hljs-keyword">this</span>.mOnItemClickLitener = mOnItemClickLitener;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span>(<span class="hljs-keyword">final</span> MyViewHolder holder, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> position)
    {
        holder.tv.setText(mDatas.get(position));

        <span class="hljs-comment">// 如果设置了回调，则设置点击事件</span>
        <span class="hljs-keyword">if</span> (mOnItemClickLitener != <span class="hljs-keyword">null</span>)
        {
            holder.itemView.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener()
            {
                <span class="hljs-annotation">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span>(View v)
                {
                    <span class="hljs-keyword">int</span> pos = holder.getLayoutPosition();
                    mOnItemClickLitener.onItemClick(holder.itemView, pos);
                }
            });

            holder.itemView.setOnLongClickListener(<span class="hljs-keyword">new</span> OnLongClickListener()
            {
                <span class="hljs-annotation">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onLongClick</span>(View v)
                {
                    <span class="hljs-keyword">int</span> pos = holder.getLayoutPosition();
                    mOnItemClickLitener.onItemLongClick(holder.itemView, pos);
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                }
            });
        }
    }
<span class="hljs-comment">//...</span>
}
</code></pre> 
<p>adapter中自己定义了个接口，然后在onBindViewHolder中去为holder.itemView去设置相应 <br> 的监听最后回调我们设置的监听。</p> 
<p>最后别忘了给item添加一个drawable:</p> 
<pre class="prettyprint"><code class="language-xml hljs "><span class="hljs-pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">selector</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span> &gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">item</span> <span class="hljs-attribute">android:state_pressed</span>=<span class="hljs-value">"true"</span> <span class="hljs-attribute">android:drawable</span>=<span class="hljs-value">"@color/color_item_press"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">item</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">item</span> <span class="hljs-attribute">android:drawable</span>=<span class="hljs-value">"@color/color_item_normal"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">item</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">selector</span>&gt;</span>
</code></pre> 
<p>Activity中去设置监听：</p> 
<pre class="prettyprint"><code class="language-java hljs ">
        mAdapter.setOnItemClickLitener(<span class="hljs-keyword">new</span> OnItemClickLitener()
        {

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemClick</span>(View view, <span class="hljs-keyword">int</span> position)
            {
                Toast.makeText(HomeActivity.<span class="hljs-keyword">this</span>, position + <span class="hljs-string">" click"</span>,
                        Toast.LENGTH_SHORT).show();
            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemLongClick</span>(View view, <span class="hljs-keyword">int</span> position)
            {
                Toast.makeText(HomeActivity.<span class="hljs-keyword">this</span>, position + <span class="hljs-string">" long click"</span>,
                        Toast.LENGTH_SHORT).show();
                        mAdapter.removeData(position);
            }
        });
</code></pre> 
<p>测试效果：</p> 
<p><img src="https://images2.imgbox.com/e8/76/Nz1rcwPX_o.gif" width="400px"></p> 
<p>ok，到此我们基本介绍了RecylerView常见用法，包含了：</p> 
<ul><li>系统提供了几种LayoutManager的使用；</li><li>如何通过自定义ItemDecoration去设置分割线，或者一些你想作为分隔的drawable，注意这里 <br> 巧妙的使用了系统的listDivider属性，你可以尝试添加使用divider和dividerHeight属性。</li><li>如何使用ItemAnimator为RecylerView去添加Item移除、添加的动画效果。</li><li>介绍了如何添加ItemClickListener与ItemLongClickListener。</li></ul> 
<p>可以看到RecyclerView可以实现：</p> 
<ul><li>ListView的功能</li><li>GridView的功能</li><li>横向ListView的功能，参考<a href="http://blog.csdn.net/lmj623565791/article/details/38173061">Android 自定义RecyclerView 实现真正的Gallery效果</a></li><li>横向ScrollView的功能</li><li>瀑布流效果</li><li>便于添加Item增加和移除动画</li></ul> 
<p>整个体验下来，感觉这种插拔式的设计太棒了，如果系统再能提供一些常用的分隔符，多添加些动画效果就更好了。</p> 
<p>通过简单改变下LayoutManager，就可以产生不同的效果，那么我们可以根据手机屏幕的宽度去动态设置LayoutManager，屏幕宽度一般的，显示为ListView；宽度稍大的显示两列的GridView或者瀑布流（或者横纵屏幕切换时变化，有点意思~）；显示的列数和宽度成正比。甚至某些特殊屏幕，让其横向滑动~~再选择一个nice的动画效果，相信这种插件式的编码体验一定会让你迅速爱上RecyclerView。</p> 
<h4 id="参考资料">参考资料</h4> 
<p><a href="http://blog.csdn.net/lmj623565791/article/details/38173061">Android 自定义RecyclerView 实现真正的Gallery效果</a></p> 
<p><a href="https://www.grokkingandroid.com/first-glance-androids-recyclerview/" rel="nofollow">A First Glance at Android’s RecyclerView</a></p> 
<p><a href="https://github.com/gabrielemariotti/RecyclerViewItemAnimators">https://github.com/gabrielemariotti/RecyclerViewItemAnimators</a></p> 
<p><a href="https://gist.github.com/alexfu/0f464fc3742f134ccd1e" rel="nofollow">DividerItemDecoration</a></p> 
<blockquote> 
 <p>群号：423372824 <br> <a href="http://download.csdn.net/detail/lmj623565791/8598329">源码下载</a> <br> 微信公众号：hongyangAndroid <br> （欢迎关注，第一时间推送博文信息） <br> <img src="https://images2.imgbox.com/79/56/aEh4jV1y_o.jpg" width="200px"></p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/176e00bc3145b26684c4631e021214f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java设计模式之观察者模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f87388b112806814495dd4d5d83bf45b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mysql group by top N的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>