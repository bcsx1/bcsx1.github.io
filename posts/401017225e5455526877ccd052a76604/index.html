<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GRBL源码详解步进电机的算法学习笔记（STM32）一篇带你学完GRBL算法初版 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GRBL源码详解步进电机的算法学习笔记（STM32）一篇带你学完GRBL算法初版" />
<meta property="og:description" content="提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
GRBL源码中步进电机的算法学习笔记（STM32）
前言 GRBL源码中算法部分的学习是我在公司研发激光切割机（三轴）期间研究的一套关于步进电机驱动控制的常见算法，以下内容都以激光切割机来举例，话不多说直接上干货。（以下内容皆为个人理解，如有错误可以在评论区揪出，希望大家一同讨论，共同进步）
一、简看GRBL的工作流程 对于一台激光切割机来说，当你想要雕刻一个圆
第一步：（将指令或图片G代码通过串口发送给MCU）
首先从上位机LaserGRBL/lightburn软件解析想要雕刻的圆，然后上位机将解析后的数据通过串口发送给MCU，MCU判断串口收到的数据是G代码还是“$”指令（该部分对应的函数为： protocol_execute_line）。
在本次举例中，圆会被解析成G代码，所以MCU通过源码中的Gcode解释器（Gcode解释器在源码中对应的函数为：gc_execute_line），但如果是指令则通过源码system_execute_line这个函数进行处理
第二部：（将接受到的G代码进行分析，从而调用对应的算法函数进行处理）
注：本文暂时不讨论指令如何处理和G代码如何分析只讨论算法
当Gcode解释器解释到数据是圆的时候，将会先计算圆心的坐标，然后再调用mc_arc函数将圆拆分成一段段小的线段（算法部分也就是从mc_arc这个函数开始）
{
算法部分
1、mc_arc() —&gt; 将圆拆分成小线段，并计算线段的起点与终点的坐标
2、mc_line() —&gt; 将线段与线段之间的切换速度进行计算
3、planner_recalculate（） —&gt; 基于切换速度和前瞻算法，设定线段的最佳起始速度和结束速度
4、st_prep_buffer（）—&gt; 梯形算法，将速度换算成每一步需要的时间，最后将时间数据通过定时器，改变输出频率作用到步进电机
}
二、算法部分（所有算法解释内容目前只放在代码块中体现） 1.mc_arc 代码如下（示例）：
void mc_arc(float *position, float *target, float *offset, float radius, float feed_rate, uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)//计算圆弧被拆分后，每一个坐标的位置并传送给mc_line() #endif { float center_axis0 = position[axis_0] &#43; offset[axis_0];//position为当前位置坐标，offset为圆心相对于当前位置的偏移量 float center_axis1 = position[axis_1] &#43; offset[axis_1]; float r_axis0 = -offset[axis_0]; //假设圆心为0时，当前位置的坐标 // Radius vector from center to current location float r_axis1 = -offset[axis_1]; float rt_axis0 = target[axis_0] - center_axis0;//假设圆心为0时，终点位置的坐标 float rt_axis1 = target[axis_1] - center_axis1; uint16_t segments; float theta_per_segment; float linear_per_segment; float cos_T,sin_T; float sin_Ti; float cos_Ti; float r_axisi; uint16_t i; uint8_t count = 0; // CCW angle between position and target from circle center." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/401017225e5455526877ccd052a76604/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-09T16:51:13+08:00" />
<meta property="article:modified_time" content="2023-11-09T16:51:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GRBL源码详解步进电机的算法学习笔记（STM32）一篇带你学完GRBL算法初版</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档</p> 
</blockquote> 
<p>GRBL源码中步进电机的算法学习笔记（STM32）</p> 
<hr> 
<h2><a id="_7"></a>前言</h2> 
<p>GRBL源码中算法部分的学习是我在公司研发激光切割机（三轴）期间研究的一套关于步进电机驱动控制的常见算法，以下内容都以激光切割机来举例，话不多说直接上干货。（以下内容皆为个人理解，如有错误可以在评论区揪出，希望大家一同讨论，共同进步）</p> 
<hr> 
<h2><a id="GRBL_12"></a>一、简看GRBL的工作流程</h2> 
<p>对于一台激光切割机来说，当你想要雕刻一个圆<br> 第一步：（将指令或图片G代码通过串口发送给MCU）<br> 首先从上位机LaserGRBL/lightburn软件解析想要雕刻的圆，然后上位机将解析后的数据通过串口发送给MCU，MCU判断串口收到的数据是G代码还是“$”指令（该部分对应的函数为： protocol_execute_line）。<br> 在本次举例中，圆会被解析成G代码，所以MCU通过源码中的Gcode解释器（Gcode解释器在源码中对应的函数为：gc_execute_line），但如果是指令则通过源码system_execute_line这个函数进行处理</p> 
<p>第二部：（将接受到的G代码进行分析，从而调用对应的算法函数进行处理）<br> 注：本文暂时不讨论指令如何处理和G代码如何分析只讨论算法<br> 当Gcode解释器解释到数据是圆的时候，将会先计算圆心的坐标，然后再调用mc_arc函数将圆拆分成一段段小的线段（算法部分也就是从mc_arc这个函数开始）<br> {<!-- --><br> 算法部分<br> 1、mc_arc() —&gt; 将圆拆分成小线段，并计算线段的起点与终点的坐标<br> 2、mc_line() —&gt; 将线段与线段之间的切换速度进行计算<br> 3、planner_recalculate（） —&gt; 基于切换速度和前瞻算法，设定线段的最佳起始速度和结束速度<br> 4、st_prep_buffer（）—&gt; 梯形算法，将速度换算成每一步需要的时间，最后将时间数据通过定时器，改变输出频率作用到步进电机<br> }</p> 
<h2><a id="_28"></a>二、算法部分（所有算法解释内容目前只放在代码块中体现）</h2> 
<h3><a id="1mc_arc_29"></a>1.mc_arc</h3> 
<p>代码如下（示例）：</p> 
<pre><code class="prism language-c">  <span class="token keyword">void</span> <span class="token function">mc_arc</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span>position<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>target<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>offset<span class="token punctuation">,</span> <span class="token keyword">float</span> radius<span class="token punctuation">,</span> <span class="token keyword">float</span> feed_rate<span class="token punctuation">,</span>
    <span class="token class-name">uint8_t</span> invert_feed_rate<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> axis_0<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> axis_1<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> axis_linear<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> is_clockwise_arc<span class="token punctuation">)</span><span class="token comment">//计算圆弧被拆分后，每一个坐标的位置并传送给mc_line()</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">float</span> center_axis0 <span class="token operator">=</span> position<span class="token punctuation">[</span>axis_0<span class="token punctuation">]</span> <span class="token operator">+</span> offset<span class="token punctuation">[</span>axis_0<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//position为当前位置坐标，offset为圆心相对于当前位置的偏移量</span>
	<span class="token keyword">float</span> center_axis1 <span class="token operator">=</span> position<span class="token punctuation">[</span>axis_1<span class="token punctuation">]</span> <span class="token operator">+</span> offset<span class="token punctuation">[</span>axis_1<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">float</span> r_axis0 <span class="token operator">=</span> <span class="token operator">-</span>offset<span class="token punctuation">[</span>axis_0<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//假设圆心为0时，当前位置的坐标 // Radius vector from center to current location</span>
	<span class="token keyword">float</span> r_axis1 <span class="token operator">=</span> <span class="token operator">-</span>offset<span class="token punctuation">[</span>axis_1<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">float</span> rt_axis0 <span class="token operator">=</span> target<span class="token punctuation">[</span>axis_0<span class="token punctuation">]</span> <span class="token operator">-</span> center_axis0<span class="token punctuation">;</span><span class="token comment">//假设圆心为0时，终点位置的坐标</span>
	<span class="token keyword">float</span> rt_axis1 <span class="token operator">=</span> target<span class="token punctuation">[</span>axis_1<span class="token punctuation">]</span> <span class="token operator">-</span> center_axis1<span class="token punctuation">;</span>
	<span class="token class-name">uint16_t</span> segments<span class="token punctuation">;</span>
	<span class="token keyword">float</span> theta_per_segment<span class="token punctuation">;</span>
	<span class="token keyword">float</span> linear_per_segment<span class="token punctuation">;</span>
	<span class="token keyword">float</span> cos_T<span class="token punctuation">,</span>sin_T<span class="token punctuation">;</span>
	<span class="token keyword">float</span> sin_Ti<span class="token punctuation">;</span>
	<span class="token keyword">float</span> cos_Ti<span class="token punctuation">;</span>
	<span class="token keyword">float</span> r_axisi<span class="token punctuation">;</span>
	<span class="token class-name">uint16_t</span> i<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  
	<span class="token comment">// CCW angle between position and target from circle center. Only one atan2() trig computation required.</span>
	<span class="token comment">// 计算圆弧的终点向量∠B - 起始向量∠A的夹角对应的夹角弧度数,参考函数arctan(y/x) = ∠A  和 tan（∠B - ∠A）= tan∠B - tan∠A / 1 + tan∠A * tan∠B的算法</span>
	<span class="token comment">//angular_travel = arctan（∠B - ∠A） = (Yb/Xb - Ya/Xa) / (1 + Ya/Xa * Yb/Xb) -- 上下同时 *XaXb</span>
	<span class="token comment">//angular_travel = (Yb*Xa - Ya*Xb) / (Xa*Xb + Ya*Yb)</span>
	<span class="token comment">//夹角弧度数 = 同心角大小映射到pi上</span>
	<span class="token keyword">float</span> angular_travel <span class="token operator">=</span> <span class="token function">atan2</span><span class="token punctuation">(</span>r_axis0<span class="token operator">*</span>rt_axis1<span class="token operator">-</span>r_axis1<span class="token operator">*</span>rt_axis0<span class="token punctuation">,</span> r_axis0<span class="token operator">*</span>rt_axis0<span class="token operator">+</span>r_axis1<span class="token operator">*</span>rt_axis1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//atan2的返回值是弧度</span>


<span class="token keyword">if</span> <span class="token punctuation">(</span>is_clockwise_arc<span class="token punctuation">)</span><span class="token comment">//顺时针 //判断是顺时针还是逆时针，①终点向量与x轴的弧度制减去起始向量与x轴的弧度制的差为angular_travel</span>
	<span class="token punctuation">{<!-- --></span> 
		<span class="token comment">//由①可知，如果圆弧顺时针移动，角度应该是负值，如果计算出的角度为正值，需要在计算出的角度基础上减去2*pi（pi为圆周率）</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>angular_travel <span class="token operator">&gt;=</span> <span class="token operator">-</span>ARC_ANGULAR_TRAVEL_EPSILON<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> angular_travel <span class="token operator">-=</span> <span class="token number">2</span><span class="token operator">*</span>M_PI<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token punctuation">}</span> 
	<span class="token keyword">else</span><span class="token comment">//逆时针</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//由①可知，如果圆弧逆时针移动，角度应该是正值，如果计算出的角度为负值，需要在计算出的角度基础上加上2*pi（pi为圆周率）</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>angular_travel <span class="token operator">&lt;=</span> ARC_ANGULAR_TRAVEL_EPSILON<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> angular_travel <span class="token operator">+=</span> <span class="token number">2</span><span class="token operator">*</span>M_PI<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to</span>
	<span class="token comment">// (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit</span>
	<span class="token comment">// is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.</span>
	<span class="token comment">// For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.</span>
	<span class="token comment">//settings.arc_tolerance这个参数是用于计算每一个线段的长度。arc_tolerance越小分出来的线段越多，插补越精确</span>
	<span class="token comment">//segments = （弧长） / （每一小段的长度）；判断可以分成多少份。//本行的详细解释在代码块下方的②处</span>
	segments <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token operator">*</span>angular_travel<span class="token operator">*</span>radius<span class="token punctuation">)</span><span class="token operator">/</span>
						  <span class="token function">sqrt</span><span class="token punctuation">(</span>settings<span class="token punctuation">.</span>arc_tolerance<span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>radius <span class="token operator">-</span> settings<span class="token punctuation">.</span>arc_tolerance<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>segments<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
		<span class="token comment">// Multiply inverse feed_rate to compensate for the fact that this movement is approximated</span>
		<span class="token comment">// by a number of discrete segments. The inverse feed_rate should be correct for the sum of </span>
		<span class="token comment">// all segments.</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>invert_feed_rate<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> feed_rate <span class="token operator">*=</span> segments<span class="token punctuation">;</span> <span class="token punctuation">}</span>

		theta_per_segment <span class="token operator">=</span> angular_travel<span class="token operator">/</span>segments<span class="token punctuation">;</span><span class="token comment">//细分后，每一段对应的弧度制的大小</span>
		linear_per_segment <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token punctuation">[</span>axis_linear<span class="token punctuation">]</span> <span class="token operator">-</span> position<span class="token punctuation">[</span>axis_linear<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span>segments<span class="token punctuation">;</span> <span class="token comment">//axis_linear，除了圆弧平面之外的第三个轴，即与圆弧平面垂直的轴</span>
		<span class="token comment">// 三角函数的泰勒级数Computes: cos（theta_per_segment） = 1 - theta_per_segment^2/2, \
										 sin（theta_per_segment） = theta_per_segment - theta_per_segment^3/6)</span>


		cos_T <span class="token operator">=</span> <span class="token number">2.0</span> <span class="token operator">-</span> theta_per_segment<span class="token operator">*</span>theta_per_segment<span class="token punctuation">;</span><span class="token comment">//每份弧度数对应的2*cos pi/x</span>
		sin_T <span class="token operator">=</span> theta_per_segment<span class="token operator">*</span><span class="token number">0.16666667</span><span class="token operator">*</span><span class="token punctuation">(</span>cos_T <span class="token operator">+</span> <span class="token number">4.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//每份弧度数对应的sin pi/x</span>
		cos_T <span class="token operator">*=</span> <span class="token number">0.5</span><span class="token punctuation">;</span><span class="token comment">//每份弧度数对应的cosθ</span>
		<span class="token comment">//cosθ = 1 - θ^2 / 2</span>
		<span class="token comment">//sinθ = θ - θ^3 / 6 </span>

		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>segments<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span> <span class="token comment">// Increment (segments-1).</span>
			<span class="token comment">//下方为计算旋转 ②单位角弧度 后的终点坐标原理：</span>
				<span class="token comment">//r_axis0、r_axis1分别是圆点到起始坐标的x、y轴的偏移量</span>
			<span class="token comment">//所以 设“偏移前”的起始坐标为（r_axis0，r_axis1），且假设C为当前角度，T为②单位弧度，半径为r那么</span>
			<span class="token comment">//r_axis0 = r * cosC</span>
			<span class="token comment">//r_axis1 = r * sinC</span>
			<span class="token comment">//那么 设“偏移T°后”的起始坐标为（r_axis0'，r_axis1'）</span>
			<span class="token comment">//r_axis0' = r * cos(C + T) = r*cosC*cosT - r*sinC*sinT = r_axis0*cosT - r_axis1*sinT</span>
			<span class="token comment">//r_axis1' = r * sin(C + T) = r*sinC*cosT + r*cosC*sinT = r_axis1*cosT + r_axis0*sinT = r_axis0*sin_T + r_axis1*cos_T</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> N_ARC_CORRECTION<span class="token punctuation">)</span> 
			<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// Apply vector rotation matrix. ~40 usec</span>
			  <span class="token comment">//r_axisi是个中间装载值，起到一个暂存的作用</span>
			  <span class="token comment">//cos_T和sin_T是圆弧被细分后的每份角弧度的sin和cos值，②设每份角弧度也叫单位弧度</span>
			  <span class="token comment">//r_axis0、r_axis1分别是当前起始坐标相对于圆心在x、y轴的偏移量</span>
				r_axisi <span class="token operator">=</span> r_axis0<span class="token operator">*</span>sin_T <span class="token operator">+</span> r_axis1<span class="token operator">*</span>cos_T<span class="token punctuation">;</span><span class="token comment">//计算当前坐标偏移单位角弧度后y轴的坐标，暂存于r_axisi</span>
				r_axis0 <span class="token operator">=</span> r_axis0<span class="token operator">*</span>cos_T <span class="token operator">-</span> r_axis1<span class="token operator">*</span>sin_T<span class="token punctuation">;</span><span class="token comment">//计算当前坐标偏移单位角弧度后x轴的坐标</span>
				r_axis1 <span class="token operator">=</span> r_axisi<span class="token punctuation">;</span>
				count<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> 
			<span class="token punctuation">{<!-- --></span>      
				<span class="token comment">// Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec</span>
				<span class="token comment">// Compute exact location by applying transformation matrix from initial radius vector(=-offset).</span>
				cos_Ti <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>i<span class="token operator">*</span>theta_per_segment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算第i个细分小线段的坐标于最开始的起始坐标的夹角的cos值</span>
				sin_Ti <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span>i<span class="token operator">*</span>theta_per_segment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算第i个细分小线段的坐标于最开始的起始坐标的夹角的sin值</span>
				r_axis0 <span class="token operator">=</span> <span class="token operator">-</span>offset<span class="token punctuation">[</span>axis_0<span class="token punctuation">]</span><span class="token operator">*</span>cos_Ti <span class="token operator">+</span> offset<span class="token punctuation">[</span>axis_1<span class="token punctuation">]</span><span class="token operator">*</span>sin_Ti<span class="token punctuation">;</span><span class="token comment">//计算从最开始坐标偏移至当前坐标的总弧度后的x轴的坐标</span>
				r_axis1 <span class="token operator">=</span> <span class="token operator">-</span>offset<span class="token punctuation">[</span>axis_0<span class="token punctuation">]</span><span class="token operator">*</span>sin_Ti <span class="token operator">-</span> offset<span class="token punctuation">[</span>axis_1<span class="token punctuation">]</span><span class="token operator">*</span>cos_Ti<span class="token punctuation">;</span><span class="token comment">//计算从最开始坐标偏移至当前坐标的总弧度后的y轴的坐标</span>
				count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// Update arc_target location</span>
			<span class="token comment">//以上代码都是基于圆心为0，现在圆心为center_axis0，center_axis1</span>
			<span class="token comment">//总结一下三行就是将偏移后的真实坐标存放在position[axis_0]，position[axis_1]</span>
			position<span class="token punctuation">[</span>axis_0<span class="token punctuation">]</span> <span class="token operator">=</span> center_axis0 <span class="token operator">+</span> r_axis0<span class="token punctuation">;</span>
			position<span class="token punctuation">[</span>axis_1<span class="token punctuation">]</span> <span class="token operator">=</span> center_axis1 <span class="token operator">+</span> r_axis1<span class="token punctuation">;</span>
			position<span class="token punctuation">[</span>axis_linear<span class="token punctuation">]</span> <span class="token operator">+=</span> linear_per_segment<span class="token punctuation">;</span>
		  
			<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">USE_LINE_NUMBERS</span></span>
				<span class="token function">mc_line</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> feed_rate<span class="token punctuation">,</span> invert_feed_rate<span class="token punctuation">,</span> line_number<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
				<span class="token function">mc_line</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> feed_rate<span class="token punctuation">,</span> invert_feed_rate<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
			<span class="token comment">// Bail mid-circle on system abort. Runtime command check already performed by mc_line.</span>
			<span class="token comment">//系统中止标志。 强制退出回到主循环以进行重置。</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>sys<span class="token punctuation">.</span>abort<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Ensure last segment arrives at target location.</span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">USE_LINE_NUMBERS</span></span>
	<span class="token function">mc_line</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> feed_rate<span class="token punctuation">,</span> invert_feed_rate<span class="token punctuation">,</span> line_number<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
	<span class="token function">mc_line</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> feed_rate<span class="token punctuation">,</span> invert_feed_rate<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b0/0d/wZkMruVb_o.png" alt="在这里插入图片描述"><br> ②、上图的“弧ABC”就是“每一小段长度”对应的弧长，“每一小段的长度” <sup>2</sup> = 2AC<sup>2</sup> = 2(OB<sup>2</sup> - (OB - BD)<sup>2</sup> )= 4OB<em>BD - BD<sup>2</sup><br> 其中OB = radius，BD = arc_tolerance<br> 所以segment（份数）= angular_travel</em>radius)（总弧长）/ sqrt(settings.arc_tolerance*(2<em>radius - settings.arc_tolerance))<br> {<!-- --><br> //segments = （总弧长） / （每一小段的长度）；判断可以分成多少份。//本行的详细解释在代码块下方的②处<br> segments = floor(fabs(0.5</em>angular_travel<em>radius)/<br> sqrt(settings.arc_tolerance</em>(2*radius - settings.arc_tolerance)) );<br> }</p> 
<h3><a id="2mc_lineplan_buffer_line_165"></a>2.mc_line中的plan_buffer_line</h3> 
<p>代码如下（示例）：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">plan_buffer_line</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span>target<span class="token punctuation">,</span> <span class="token keyword">float</span> feed_rate<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> invert_feed_rate<span class="token punctuation">)</span> <span class="token comment">//拐点速度计算--&gt;v^2 = a * r（即：线与线之间切换时的速度）</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">{<!-- --></span>

  <span class="token class-name">int32_t</span> target_steps<span class="token punctuation">[</span>N_AXIS<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">float</span> unit_vec<span class="token punctuation">[</span>N_AXIS<span class="token punctuation">]</span><span class="token punctuation">,</span> delta_mm<span class="token punctuation">;</span>
  <span class="token class-name">uint8_t</span> idx<span class="token punctuation">;</span>
  <span class="token keyword">float</span> inverse_unit_vec_value<span class="token punctuation">;</span>
  <span class="token keyword">float</span> inverse_millimeters<span class="token punctuation">;</span>  <span class="token comment">// Inverse millimeters to remove multiple float divides	</span>
  <span class="token keyword">float</span> junction_cos_theta<span class="token punctuation">;</span>
  <span class="token keyword">float</span> sin_theta_d2<span class="token punctuation">;</span>

  <span class="token comment">// Prepare and initialize new block</span>
	<span class="token comment">//尾插链表，先进先出队列逻辑</span>
  <span class="token class-name">plan_block_t</span> <span class="token operator">*</span>block <span class="token operator">=</span> <span class="token operator">&amp;</span>block_buffer<span class="token punctuation">[</span>block_buffer_head<span class="token punctuation">]</span><span class="token punctuation">;</span>
  block<span class="token operator">-&gt;</span>step_event_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//该节点的两个轴中步数最大的那个轴的步数值</span>
  block<span class="token operator">-&gt;</span>millimeters <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//当前节点的剩余执行距离</span>
  block<span class="token operator">-&gt;</span>direction_bits <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//轴运动方向</span>
  block<span class="token operator">-&gt;</span>acceleration <span class="token operator">=</span> SOME_LARGE_VALUE<span class="token punctuation">;</span><span class="token comment">//稍后缩小至最大加速度 // Scaled down to maximum acceleration later</span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">USE_LINE_NUMBERS</span></span>
    block<span class="token operator">-&gt;</span>line_number <span class="token operator">=</span> line_number<span class="token punctuation">;</span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

  <span class="token comment">// Compute and store initial move distance data.</span>
  <span class="token comment">// TODO: After this for-loop, we don't touch the stepper algorithm data. Might be a good idea</span>
  <span class="token comment">// to try to keep these types of things completely separate from the planner for portability.</span>

  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">COREX</span><span class="token comment">//settings.steps_per_mm每毫米行走的步数，即x step/mm</span></span>
    target_steps<span class="token punctuation">[</span>A_MOTOR<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token punctuation">[</span>A_MOTOR<span class="token punctuation">]</span><span class="token operator">*</span>settings<span class="token punctuation">.</span>steps_per_mm<span class="token punctuation">[</span>A_MOTOR<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token operator">?</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>A_MOTOR<span class="token punctuation">]</span><span class="token operator">*</span>settings<span class="token punctuation">.</span>steps_per_mm<span class="token punctuation">[</span>A_MOTOR<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>A_MOTOR<span class="token punctuation">]</span><span class="token operator">*</span>settings<span class="token punctuation">.</span>steps_per_mm<span class="token punctuation">[</span>A_MOTOR<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//x轴电机要运行的步数，并四舍五入</span>
    target_steps<span class="token punctuation">[</span>B_MOTOR<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token punctuation">[</span>B_MOTOR<span class="token punctuation">]</span><span class="token operator">*</span>settings<span class="token punctuation">.</span>steps_per_mm<span class="token punctuation">[</span>B_MOTOR<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token operator">?</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>B_MOTOR<span class="token punctuation">]</span><span class="token operator">*</span>settings<span class="token punctuation">.</span>steps_per_mm<span class="token punctuation">[</span>B_MOTOR<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>B_MOTOR<span class="token punctuation">]</span><span class="token operator">*</span>settings<span class="token punctuation">.</span>steps_per_mm<span class="token punctuation">[</span>B_MOTOR<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//y轴电机要运行的步数，并四舍五入</span>
    block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>A_MOTOR<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">labs</span><span class="token punctuation">(</span><span class="token punctuation">(</span>target_steps<span class="token punctuation">[</span>X_AXIS<span class="token punctuation">]</span><span class="token operator">-</span>pl<span class="token punctuation">.</span>position<span class="token punctuation">[</span>X_AXIS<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>target_steps<span class="token punctuation">[</span>Y_AXIS<span class="token punctuation">]</span><span class="token operator">-</span>pl<span class="token punctuation">.</span>position<span class="token punctuation">[</span>Y_AXIS<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>B_MOTOR<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">labs</span><span class="token punctuation">(</span><span class="token punctuation">(</span>target_steps<span class="token punctuation">[</span>X_AXIS<span class="token punctuation">]</span><span class="token operator">-</span>pl<span class="token punctuation">.</span>position<span class="token punctuation">[</span>X_AXIS<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>target_steps<span class="token punctuation">[</span>Y_AXIS<span class="token punctuation">]</span><span class="token operator">-</span>pl<span class="token punctuation">.</span>position<span class="token punctuation">[</span>Y_AXIS<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token comment">//N_AXIS即xyz三轴</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> idx<span class="token operator">&lt;</span>N_AXIS<span class="token punctuation">;</span> idx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//①</span>
	  <span class="token comment">//target，为激光头期望移动到的坐标，坐标的单位为mm</span>
	  <span class="token comment">//feed_rate，线段的最大运行速度</span>
	  <span class="token comment">//steps_per_mm值，也就是每毫米代表的轴移动步数per/mm</span>
    target_steps<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">*</span>settings<span class="token punctuation">.</span>steps_per_mm<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">*</span>settings<span class="token punctuation">.</span>steps_per_mm<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">*</span>settings<span class="token punctuation">.</span>steps_per_mm<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	  <span class="token comment">//电机从原点到目标点的各轴要执行的步数</span>
	  
    block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">labs</span><span class="token punctuation">(</span>target_steps<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">-</span> pl<span class="token punctuation">.</span>position<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//各个轴从当前坐标移动到期望坐标的步数</span>
    block<span class="token operator">-&gt;</span>step_event_count <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>block<span class="token operator">-&gt;</span>step_event_count<span class="token punctuation">,</span> block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//各个轴需要的移动步数中，取最高的放置在参数block-&gt;step_event_count中</span>
    delta_mm <span class="token operator">=</span> <span class="token punctuation">(</span>target_steps<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">-</span> pl<span class="token punctuation">.</span>position<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span>settings<span class="token punctuation">.</span>steps_per_mm<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//从当前坐标移动到期望坐标所需要移动的距离（单位: mm）</span>
   	unit_vec<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> delta_mm<span class="token punctuation">;</span> <span class="token comment">// Store unit vector numerator. Denominator computed later.</span>
        
    <span class="token comment">// Set direction bits. Bit enabled always means direction is negative.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta_mm <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token comment">//如果Delta_mm为负数，那么就要反向行走</span>
	<span class="token punctuation">{<!-- --></span>
		block<span class="token operator">-&gt;</span>direction_bits <span class="token operator">|=</span> <span class="token function">get_direction_pin_mask</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// Incrementally compute total move distance by Euclidean norm. First add square of each term.</span>
    block<span class="token operator">-&gt;</span>millimeters <span class="token operator">+=</span> delta_mm<span class="token operator">*</span>delta_mm<span class="token punctuation">;</span><span class="token comment">//每个轴平方的累加</span>
  <span class="token punctuation">}</span><span class="token comment">//①</span>
  
  
  block<span class="token operator">-&gt;</span>millimeters <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>block<span class="token operator">-&gt;</span>millimeters<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Complete millimeters calculation with sqrt()</span>
  <span class="token comment">//将x、y轴要运行的距离的平方和再开根号，即三角行的第三边计算公式</span>
  
  <span class="token comment">// Bail if this is a zero-length block. Highly unlikely to occur.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>block<span class="token operator">-&gt;</span>step_event_count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">//如果最大要执行的步数为0，那么就直接退出函数</span>
  
  <span class="token comment">// Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)</span>
  <span class="token comment">// TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>feed_rate <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> feed_rate <span class="token operator">=</span> SOME_LARGE_VALUE<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// Scaled down to absolute max/rapids rate later//暂无</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>invert_feed_rate<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> feed_rate <span class="token operator">*=</span> block<span class="token operator">-&gt;</span>millimeters<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//暂无</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>feed_rate <span class="token operator">&lt;</span> MINIMUM_FEED_RATE<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> feed_rate <span class="token operator">=</span> MINIMUM_FEED_RATE<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// Prevents step generation round-off condition.//暂无</span>

  inverse_millimeters <span class="token operator">=</span> <span class="token number">1.0</span><span class="token operator">/</span>block<span class="token operator">-&gt;</span>millimeters<span class="token punctuation">;</span>  <span class="token comment">// 取第三边的倒数Inverse millimeters to remove multiple float divides	</span>
  junction_cos_theta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  
  <span class="token keyword">for</span> <span class="token punctuation">(</span>idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> idx<span class="token operator">&lt;</span>N_AXIS<span class="token punctuation">;</span> idx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	  <span class="token comment">/*主要公式 acc[x] = Acc * (x / (√x^2 + y^2))
				 acc[y] = Acc * (y / (√x^2 + y^2))
	  所以		 Acc0 = acc[x] / (x / (√x^2 + y^2)) 、 Acc1 = acc[y] / (y / (√x^2 + y^2))
				 Acc = min(Acc0 ,Acc1);
	  */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>unit_vec<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">// Avoid divide by zero.</span>
      unit_vec<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">*=</span> inverse_millimeters<span class="token punctuation">;</span>  <span class="token comment">// Complete unit vector calculation  //unit_vec[x] = x / (√x^2 + y^2)</span>
      inverse_unit_vec_value <span class="token operator">=</span> <span class="token function">fabs</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token operator">/</span>unit_vec<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Inverse to remove multiple float divides. // inverse_unit_vec_value[x] = (√x^2 + y^2) / x</span>

      <span class="token comment">// Check and limit feed rate against max individual axis velocities and accelerations</span>
      feed_rate <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>feed_rate<span class="token punctuation">,</span> settings<span class="token punctuation">.</span>max_rate<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">*</span>inverse_unit_vec_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过分量计算速度</span>
      block<span class="token operator">-&gt;</span>acceleration <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>block<span class="token operator">-&gt;</span>acceleration<span class="token punctuation">,</span> settings<span class="token punctuation">.</span>acceleration<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">*</span>inverse_unit_vec_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过分量计算加速度</span>

      <span class="token comment">// Incrementally compute cosine of angle between previous and current path. Cos(theta) of the junction</span>
      <span class="token comment">// between the current move and the previous move is simply the dot product of the two unit vectors, </span>
      <span class="token comment">// where prev_unit_vec is negative. Used later to compute maximum junction speed.</span>
      junction_cos_theta <span class="token operator">-=</span> pl<span class="token punctuation">.</span>previous_unit_vec<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">*</span> unit_vec<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token comment">//计算加速度Acc ，计算速度rate</span>
  
  <span class="token comment">// TODO: Need to check this method handling zero junction speeds when starting from rest.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>block_buffer_head <span class="token operator">==</span> block_buffer_tail<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  
    <span class="token comment">// Initialize block entry speed as zero. Assume it will be starting from rest. Planner will correct this later.</span>
    block<span class="token operator">-&gt;</span>entry_speed_sqr <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    block<span class="token operator">-&gt;</span>max_junction_speed_sqr <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> <span class="token comment">// Starting from rest. Enforce start from zero velocity.</span>
  
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>junction_cos_theta <span class="token operator">&gt;</span> <span class="token number">0.999999</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//  For a 0 degree acute junction, just set minimum junction speed. </span>
      block<span class="token operator">-&gt;</span>max_junction_speed_sqr <span class="token operator">=</span> MINIMUM_JUNCTION_SPEED<span class="token operator">*</span>MINIMUM_JUNCTION_SPEED<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
      junction_cos_theta <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>junction_cos_theta<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.999999</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Check for numerical round-off to avoid divide by zero.</span>
      sin_theta_d2 <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token operator">-</span>junction_cos_theta<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Trig half angle identity. Always positive.</span>

      <span class="token comment">// TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the</span>
      <span class="token comment">// two junctions. However, this shouldn't be a significant problem except in extreme circumstances.</span>
      block<span class="token operator">-&gt;</span>max_junction_speed_sqr <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span> MINIMUM_JUNCTION_SPEED<span class="token operator">*</span>MINIMUM_JUNCTION_SPEED<span class="token punctuation">,</span>
                                   <span class="token punctuation">(</span>block<span class="token operator">-&gt;</span>acceleration <span class="token operator">*</span> settings<span class="token punctuation">.</span>junction_deviation <span class="token operator">*</span> sin_theta_d2<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token operator">-</span>sin_theta_d2<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span><span class="token comment">//计算出拐角速度的平方</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Store block nominal speed</span>
  block<span class="token operator">-&gt;</span>nominal_speed_sqr <span class="token operator">=</span> feed_rate<span class="token operator">*</span>feed_rate<span class="token punctuation">;</span> <span class="token comment">// 上位机传过来的期望速度的平方(mm/min). Always &gt; 0</span>
  
  <span class="token comment">// Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.</span>
  block<span class="token operator">-&gt;</span>max_entry_speed_sqr <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>block<span class="token operator">-&gt;</span>max_junction_speed_sqr<span class="token punctuation">,</span> 
                                   <span class="token function">min</span><span class="token punctuation">(</span>block<span class="token operator">-&gt;</span>nominal_speed_sqr<span class="token punctuation">,</span> pl<span class="token punctuation">.</span>previous_nominal_speed_sqr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//求出理论值的最大拐角速度</span>
  
  <span class="token comment">// Update previous path unit_vector and nominal speed (squared)</span>
  <span class="token function">memcpy</span><span class="token punctuation">(</span>pl<span class="token punctuation">.</span>previous_unit_vec<span class="token punctuation">,</span> unit_vec<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>unit_vec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新分量速度在pl.previous_unit_vec[]，pl.previous_unit_vec[] = unit_vec[]</span>
  pl<span class="token punctuation">.</span>previous_nominal_speed_sqr <span class="token operator">=</span> block<span class="token operator">-&gt;</span>nominal_speed_sqr<span class="token punctuation">;</span><span class="token comment">//更新标称速度，用来给下一条线段进行对比</span>
    
  <span class="token comment">// Update planner position  更新激光头的坐标</span>
  <span class="token function">memcpy</span><span class="token punctuation">(</span>pl<span class="token punctuation">.</span>position<span class="token punctuation">,</span> target_steps<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>target_steps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pl.position[] = target_steps[]</span>

  <span class="token comment">// New block is all set. Update buffer head and next buffer head indices.</span>
  <span class="token comment">//运行以下函数之前，假设当前节点block_buffer_head为head_node</span>
  block_buffer_head <span class="token operator">=</span> next_buffer_head<span class="token punctuation">;</span>  <span class="token comment">//buffer_head指向当前节点head_node的下一个节点</span>
  next_buffer_head <span class="token operator">=</span> <span class="token function">plan_next_block_index</span><span class="token punctuation">(</span>block_buffer_head<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//buffer_next指向当前节点head_node的下一个节点的下一个节点</span>
  <span class="token comment">//以下函数planner_recalculate()会用到关于上诉节点改变后的节点，用来追溯最开始的head_node</span>
  
  <span class="token comment">// Finish up by recalculating the plan with the new block.</span>
  <span class="token function">planner_recalculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h3><a id="3planner_recalculate_312"></a>3.planner_recalculate</h3> 
<p>代码如下（示例）：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">planner_recalculate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//运动规划-》前瞻算法，和后顾算法</span>
<span class="token punctuation">{<!-- --></span>   
	<span class="token comment">// Initialize block index to the last block in the planner buffer.</span>
	<span class="token comment">//在plan_buffer_line这个函数中提及到了block_buffer_head这个节点已经变为了自己的下一个节点</span>
	<span class="token class-name">uint8_t</span> block_index <span class="token operator">=</span> <span class="token function">plan_prev_block_index</span><span class="token punctuation">(</span>block_buffer_head<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将block_index变成当前处理的节点的坐标</span>
		
	<span class="token comment">// Bail. Can't do anything with one only one plan-able block.</span>

	<span class="token keyword">float</span> entry_speed_sqr<span class="token punctuation">;</span>
	<span class="token class-name">plan_block_t</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
	<span class="token class-name">plan_block_t</span> <span class="token operator">*</span>current <span class="token operator">=</span> <span class="token operator">&amp;</span>block_buffer<span class="token punctuation">[</span>block_index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//current为当前节点</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>block_index <span class="token operator">==</span> block_buffer_planned<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
	  
	<span class="token comment">// Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last</span>
	<span class="token comment">// block in buffer. Cease planning when the last optimal planned or tail pointer is reached.</span>
	<span class="token comment">// NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.</span>


	<span class="token comment">// Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.</span>
	<span class="token comment">//current即是当前链表中最后一个处理的线段（也是最新处理的线段）现在设退出时的速度（即末速度）v1为0，那么v1^2 - v0^2 = 2ax可以推出进入是的初速度为2ax</span>
	current<span class="token operator">-&gt;</span>entry_speed_sqr <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span> current<span class="token operator">-&gt;</span>max_entry_speed_sqr<span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>current<span class="token operator">-&gt;</span>acceleration<span class="token operator">*</span>current<span class="token operator">-&gt;</span>millimeters<span class="token punctuation">)</span><span class="token punctuation">;</span>

	block_index <span class="token operator">=</span> <span class="token function">plan_prev_block_index</span><span class="token punctuation">(</span>block_index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将block_index变成当前线段的上一个线段的坐标</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>block_index <span class="token operator">==</span> block_buffer_planned<span class="token punctuation">)</span><span class="token comment">// 当【Only two plannable blocks in buffer】. Reverse pass complete.</span>
	<span class="token punctuation">{<!-- --></span> 
		<span class="token comment">// Check if the first block is the tail. If so, notify stepper to update its current parameters.</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>block_index <span class="token operator">==</span> block_buffer_tail<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token function">st_update_plan_block_parameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token punctuation">}</span> 
	<span class="token keyword">else</span> <span class="token comment">// 当【Three or more plan-able blocks】</span>
	<span class="token punctuation">{<!-- --></span> 
		<span class="token keyword">while</span> <span class="token punctuation">(</span>block_index <span class="token operator">!=</span> block_buffer_planned<span class="token punctuation">)</span>				<span class="token comment">//无t公式要理解清楚方向的定义！！！</span>
		<span class="token punctuation">{<!-- --></span><span class="token comment">//这段代码的含义是从当前线段往前推，直到所有的线段都优化过退出循环，\
		   即每条线段的初速度不能超过线段设置的最大初速度的限制</span>
			next <span class="token operator">=</span> current<span class="token punctuation">;</span>
			current <span class="token operator">=</span> <span class="token operator">&amp;</span>block_buffer<span class="token punctuation">[</span>block_index<span class="token punctuation">]</span><span class="token punctuation">;</span>
			block_index <span class="token operator">=</span> <span class="token function">plan_prev_block_index</span><span class="token punctuation">(</span>block_index<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// Check if next block is the tail block(=planned block). If so, update current stepper parameters.</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>block_index <span class="token operator">==</span> block_buffer_tail<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token function">st_update_plan_block_parameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 

			<span class="token comment">// Compute maximum entry speed decelerating over the current block from its exit speed.</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-&gt;</span>entry_speed_sqr <span class="token operator">!=</span> current<span class="token operator">-&gt;</span>max_entry_speed_sqr<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				entry_speed_sqr <span class="token operator">=</span> next<span class="token operator">-&gt;</span>entry_speed_sqr <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">*</span>current<span class="token operator">-&gt;</span>acceleration<span class="token operator">*</span>current<span class="token operator">-&gt;</span>millimeters<span class="token punctuation">;</span><span class="token comment">//从最后一个块的退出速度当作初速度往前推（且最后一块的退出速度为0）</span>
				
				<span class="token keyword">if</span> <span class="token punctuation">(</span>entry_speed_sqr <span class="token operator">&lt;</span> current<span class="token operator">-&gt;</span>max_entry_speed_sqr<span class="token punctuation">)</span>
					current<span class="token operator">-&gt;</span>entry_speed_sqr <span class="token operator">=</span> entry_speed_sqr<span class="token punctuation">;</span>
				<span class="token keyword">else</span>
					current<span class="token operator">-&gt;</span>entry_speed_sqr <span class="token operator">=</span> current<span class="token operator">-&gt;</span>max_entry_speed_sqr<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>    

	<span class="token comment">// Forward Pass: Forward plan the acceleration curve from the planned pointer onward.</span>
	<span class="token comment">// Also scans for optimal plan breakpoints and appropriately updates the planned pointer.</span>
	next <span class="token operator">=</span> <span class="token operator">&amp;</span>block_buffer<span class="token punctuation">[</span>block_buffer_planned<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Begin at buffer planned pointer</span>
	block_index <span class="token operator">=</span> <span class="token function">plan_next_block_index</span><span class="token punctuation">(</span>block_buffer_planned<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	
	<span class="token keyword">while</span> <span class="token punctuation">(</span>block_index <span class="token operator">!=</span> block_buffer_head<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span> <span class="token comment">//这段代码的含义是从第一个没有优化过的线段往前，直到到达当前线段时退出循环，\
	    即每条线段的末速度不能超过下一条线段的初速度，这样多条线段才能保持连续的速度运行</span>
		current <span class="token operator">=</span> next<span class="token punctuation">;</span>
		next <span class="token operator">=</span> <span class="token operator">&amp;</span>block_buffer<span class="token punctuation">[</span>block_index<span class="token punctuation">]</span><span class="token punctuation">;</span>

		<span class="token comment">// Any acceleration detected in the forward pass automatically moves the optimal planned</span>
		<span class="token comment">// pointer forward, since everything before this is all optimal. In other words, nothing</span>
		<span class="token comment">// can improve the plan from the buffer tail to the planned pointer by logic.</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-&gt;</span>entry_speed_sqr <span class="token operator">&lt;</span> next<span class="token operator">-&gt;</span>entry_speed_sqr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
		  entry_speed_sqr <span class="token operator">=</span> current<span class="token operator">-&gt;</span>entry_speed_sqr <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">*</span>current<span class="token operator">-&gt;</span>acceleration<span class="token operator">*</span>current<span class="token operator">-&gt;</span>millimeters<span class="token punctuation">;</span>
		  <span class="token comment">// If true, current block is full-acceleration and we can move the planned pointer forward.</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>entry_speed_sqr <span class="token operator">&lt;</span> next<span class="token operator">-&gt;</span>entry_speed_sqr<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				next<span class="token operator">-&gt;</span>entry_speed_sqr <span class="token operator">=</span> entry_speed_sqr<span class="token punctuation">;</span> <span class="token comment">// Always &lt;= max_entry_speed_sqr. Backward pass sets this.</span>
				block_buffer_planned <span class="token operator">=</span> block_index<span class="token punctuation">;</span> <span class="token comment">// Set optimal plan pointer.</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// Any block set at its maximum entry speed also creates an optimal plan up to this</span>
		<span class="token comment">// point in the buffer. When the plan is bracketed by either the beginning of the</span>
		<span class="token comment">// buffer and a maximum entry speed or two maximum entry speeds, every block in between</span>
		<span class="token comment">// cannot logically be further improved. Hence, we don't have to recompute them anymore.</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>next<span class="token operator">-&gt;</span>entry_speed_sqr <span class="token operator">==</span> next<span class="token operator">-&gt;</span>max_entry_speed_sqr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> block_buffer_planned <span class="token operator">=</span> block_index<span class="token punctuation">;</span> <span class="token punctuation">}</span>
		block_index <span class="token operator">=</span> <span class="token function">plan_next_block_index</span><span class="token punctuation">(</span> block_index <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="4st_prep_buffer_407"></a>4.st_prep_buffer</h3> 
<p>代码如下（示例）：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">st_prep_buffer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">float</span> inv_2_accel<span class="token punctuation">;</span>
	<span class="token keyword">float</span> decel_dist<span class="token punctuation">;</span>
	<span class="token keyword">float</span> exit_speed_sqr<span class="token punctuation">;</span>
	<span class="token keyword">float</span> intersect_distance<span class="token punctuation">;</span>
	<span class="token class-name">segment_t</span> <span class="token operator">*</span>prep_segment<span class="token punctuation">;</span>
	<span class="token keyword">float</span> dt_max<span class="token punctuation">;</span> <span class="token comment">// Maximum segment time</span>
	<span class="token keyword">float</span> dt<span class="token punctuation">;</span> <span class="token comment">// Initialize segment time</span>
	<span class="token keyword">float</span> time_var<span class="token punctuation">;</span> <span class="token comment">// Time worker variable</span>
	<span class="token keyword">float</span> mm_var<span class="token punctuation">;</span> <span class="token comment">// mm-Distance worker variable</span>
	<span class="token keyword">float</span> speed_var<span class="token punctuation">;</span> <span class="token comment">// Speed worker variable   </span>
	<span class="token keyword">float</span> mm_remaining<span class="token punctuation">;</span> <span class="token comment">// New segment distance from end of block.</span>
	<span class="token keyword">float</span> minimum_mm<span class="token punctuation">;</span> <span class="token comment">// Guarantee at least one step.</span>
	<span class="token keyword">float</span> steps_remaining<span class="token punctuation">;</span> <span class="token comment">// Convert mm_remaining to steps</span>
    <span class="token keyword">float</span> n_steps_remaining<span class="token punctuation">;</span> <span class="token comment">// Round-up current steps remaining</span>
    <span class="token keyword">float</span> last_n_steps_remaining<span class="token punctuation">;</span> <span class="token comment">// Round-up last steps remaining</span>
	<span class="token keyword">float</span> inv_rate<span class="token punctuation">;</span>
	<span class="token class-name">uint32_t</span> cycles<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>sys<span class="token punctuation">.</span>state <span class="token operator">&amp;</span> <span class="token punctuation">(</span>STATE_HOLD<span class="token operator">|</span>STATE_MOTION_CANCEL<span class="token operator">|</span>STATE_SAFETY_DOOR<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
    <span class="token comment">// Check if we still need to generate more segments for a motion suspend.</span>
	  <span class="token comment">//检查我们是否仍需要为运动暂停生成更多段。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prep<span class="token punctuation">.</span>current_speed <span class="token operator">==</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// Nothing to do. Bail.</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">while</span> <span class="token punctuation">(</span>segment_buffer_tail <span class="token operator">!=</span> segment_next_head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// Check if we need to fill the buffer.检查我们是否需要填充缓冲区。</span>

    <span class="token comment">// Determine if we need to load a new planner block or if the block has been replanned. </span>
	  <span class="token comment">// 确定是否需要加载新的规划器块或者该块是否已被重新规划。</span>
	  <span class="token comment">//判断当前线段拆分时间片是否完成，如果没有完成，pl_block不为空，if里的语句不会被执行。 \
	  如果pl_block为空，说明当前线段时间片拆分完成，执行if里的语句，开始把下一条线段的信息读出来进行时间片拆分</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pl_block <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      pl_block <span class="token operator">=</span> <span class="token function">plan_get_current_block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Query planner for a queued block</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>pl_block <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// No planner blocks. Exit.</span>
                      
      <span class="token comment">// Check if the segment buffer completed the last planner block. If so, load the Bresenham</span>
      <span class="token comment">// data for the block. If not, we are still mid-block and the velocity profile was updated. </span>
	  <span class="token comment">//检查段缓冲区是否完成了最后一个规划器块。 如果是，则加载该块的 Bresenham 数据。 \
		如果没有，我们仍然处于中间状态并且速度剖面已更新。</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>prep<span class="token punctuation">.</span>flag_partial_block<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//表示最后一个块已完成的标志。是时候装一个新的了。</span>
        prep<span class="token punctuation">.</span>flag_partial_block <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">// Reset flag</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Increment stepper common data index to store new planner block data. </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">++</span>prep<span class="token punctuation">.</span>st_block_index <span class="token operator">==</span> <span class="token punctuation">(</span>SEGMENT_BUFFER_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> prep<span class="token punctuation">.</span>st_block_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        
        <span class="token comment">// Prepare and copy Bresenham algorithm segment data from the new planner block, so that</span>
        <span class="token comment">// when the segment buffer completes the planner block, it may be discarded when the </span>
        <span class="token comment">// segment buffer finishes the prepped block, but the stepper ISR is still executing it. </span>
        st_prep_block <span class="token operator">=</span> <span class="token operator">&amp;</span>st_block_buffer<span class="token punctuation">[</span>prep<span class="token punctuation">.</span>st_block_index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//开辟新的队列st_block_buffer  存放新线段拆分时间片计算过程数据</span>
        st_prep_block<span class="token operator">-&gt;</span>direction_bits <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>direction_bits<span class="token punctuation">;</span><span class="token comment">//将运动方向赋值给st_prep_block-&gt;direction_bits</span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING</span></span>
          st_prep_block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>X_AXIS<span class="token punctuation">]</span> <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>X_AXIS<span class="token punctuation">]</span><span class="token punctuation">;</span>
          st_prep_block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>Y_AXIS<span class="token punctuation">]</span> <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>Y_AXIS<span class="token punctuation">]</span><span class="token punctuation">;</span>
          st_prep_block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>Z_AXIS<span class="token punctuation">]</span> <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>Z_AXIS<span class="token punctuation">]</span><span class="token punctuation">;</span>
          st_prep_block<span class="token operator">-&gt;</span>step_event_count <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>step_event_count<span class="token punctuation">;</span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
		<span class="token comment">// With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS </span>
		<span class="token comment">// level, such that we never divide beyond the original data anywhere in the algorithm.</span>
		<span class="token comment">// If the original data is divided, we can lose a step from integer roundoff.</span>
		<span class="token comment">//AMASS功能用于平滑脉冲频率太慢的线段，如果AMASS功能使能，线段步数放大MAX_AMASS_LEVEL倍，\
		  但是定时器定时间隔将会缩短，相当于定时器中断加快了，\
		  更多次的中断累积才输出一个脉冲，这样输出脉冲变得更平滑了</span>
          st_prep_block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>X_AXIS<span class="token punctuation">]</span> <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>X_AXIS<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> MAX_AMASS_LEVEL<span class="token punctuation">;</span>
          st_prep_block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>Y_AXIS<span class="token punctuation">]</span> <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>Y_AXIS<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> MAX_AMASS_LEVEL<span class="token punctuation">;</span>
          st_prep_block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>Z_AXIS<span class="token punctuation">]</span> <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>steps<span class="token punctuation">[</span>Z_AXIS<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> MAX_AMASS_LEVEL<span class="token punctuation">;</span>
          st_prep_block<span class="token operator">-&gt;</span>step_event_count <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>step_event_count <span class="token operator">&lt;&lt;</span> MAX_AMASS_LEVEL<span class="token punctuation">;</span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
        
        <span class="token comment">// Initialize segment buffer data for generating the segments.</span>
        prep<span class="token punctuation">.</span>steps_remaining <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>step_event_count<span class="token punctuation">;</span>	<span class="token comment">//将3轴之中运动最长的轴作为step_event_count，并且赋给steps_remaining</span>
        prep<span class="token punctuation">.</span>step_per_mm <span class="token operator">=</span> prep<span class="token punctuation">.</span>steps_remaining<span class="token operator">/</span>pl_block<span class="token operator">-&gt;</span>millimeters<span class="token punctuation">;</span><span class="token comment">//换算成（x step/mm）,并赋值给step_per_mm</span>
        prep<span class="token punctuation">.</span>req_mm_increment <span class="token operator">=</span> REQ_MM_INCREMENT_SCALAR<span class="token operator">/</span>prep<span class="token punctuation">.</span>step_per_mm<span class="token punctuation">;</span><span class="token comment">//1.25 / steep_per_mm(暂时不知道目的) -》一step能走多少mm 并 * 1.25</span>
        
        prep<span class="token punctuation">.</span>dt_remainder <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> <span class="token comment">// Reset for new planner block</span>


		<span class="token comment">/ zx /</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sys<span class="token punctuation">.</span>state <span class="token operator">&amp;</span> <span class="token punctuation">(</span>STATE_HOLD<span class="token operator">|</span>STATE_MOTION_CANCEL<span class="token operator">|</span>STATE_SAFETY_DOOR<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>             <span class="token comment"></span>
          <span class="token comment">// Override planner block entry speed and enforce deceleration during feed hold.</span>
			<span class="token comment">//覆盖规划程序块的进入速度并在进给保持期间强制减速。						  </span>
          prep<span class="token punctuation">.</span>current_speed <span class="token operator">=</span> prep<span class="token punctuation">.</span>exit_speed<span class="token punctuation">;</span> 										  <span class="token comment"></span>
          pl_block<span class="token operator">-&gt;</span>entry_speed_sqr <span class="token operator">=</span> prep<span class="token punctuation">.</span>exit_speed<span class="token operator">*</span>prep<span class="token punctuation">.</span>exit_speed<span class="token punctuation">;</span>  				  <span class="token comment"></span>
        <span class="token punctuation">}</span>																				  <span class="token comment"></span>
        <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> prep<span class="token punctuation">.</span>current_speed <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>pl_block<span class="token operator">-&gt;</span>entry_speed_sqr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>	<span class="token comment">//sqrt开根号	  </span>
		<span class="token comment">/ zx /</span>
      <span class="token punctuation">}</span>
       
      <span class="token comment">/* --------------------------------------------------------------------------------- 
         Compute the velocity profile of a new planner block based on its entry and exit
         speeds, or recompute the profile of a partially-completed planner block if the 
         planner has updated it. For a commanded forced-deceleration, such as from a feed 
         hold, override the planner velocities and decelerate to the target exit speed.
	  
	  根据新规划器块的进入和退出速度计算其速度剖面，或者如果规划器已更新则重新计算部分完成的规划器块的剖面。
	  对于命令强制减速（例如进给保持），忽略规划器速度并减速到目标退出速度。
      */</span>
      prep<span class="token punctuation">.</span>mm_complete <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> <span class="token comment">// 默认速度曲线在距块末端 0.0mm 处完成。// Default velocity profile complete at 0.0mm from end of block.</span>
      inv_2_accel <span class="token operator">=</span> <span class="token number">0.5</span><span class="token operator">/</span>pl_block<span class="token operator">-&gt;</span>acceleration<span class="token punctuation">;</span> <span class="token comment">//inv_2_accel = (1 / 2a);方便个下面的加速度计算公式使用</span>
      
	  <span class="token keyword">if</span> <span class="token punctuation">(</span>sys<span class="token punctuation">.</span>state <span class="token operator">&amp;</span> <span class="token punctuation">(</span>STATE_HOLD<span class="token operator">|</span>STATE_MOTION_CANCEL<span class="token operator">|</span>STATE_SAFETY_DOOR<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">//[Forced Deceleration to Zero Velocity]//系统报错，xy轴速度强制为0</span>
	<span class="token comment">//该if满足条件的话，该步骤的目的是强制减速为0 //[Forced Deceleration to Zero Velocity]</span>
        <span class="token comment">// Compute velocity profile parameters for a feed hold in-progress. This profile overrides</span>
        <span class="token comment">// the planner block profile, enforcing a deceleration to zero speed.</span>
		<span class="token comment">// 计算正在进行的进给保持的速度曲线参数。 该配置文件覆盖规划器块配置文件，强制减速至零速度。</span>
	  
	    prep<span class="token punctuation">.</span>ramp_type <span class="token operator">=</span> RAMP_DECEL<span class="token punctuation">;</span><span class="token comment">//设置标志位为减速</span>
	    <span class="token comment">// Compute decelerate distance relative to end of block.</span>
	    decel_dist <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>millimeters <span class="token operator">-</span> inv_2_accel<span class="token operator">*</span>pl_block<span class="token operator">-&gt;</span>entry_speed_sqr<span class="token punctuation">;</span> <span class="token comment">//判断现在剩下的距离pl_block-&gt;millimeters是否可以满足让当前速度pl_block-&gt;entry_speed_sqr减速到0  //zhaoxin</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>decel_dist <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//此次运算不足以让速度减为0</span>
          <span class="token comment">// Deceleration through entire planner block. End of feed hold is not in this block.</span>
          prep<span class="token punctuation">.</span>exit_speed <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>pl_block<span class="token operator">-&gt;</span>entry_speed_sqr<span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span>pl_block<span class="token operator">-&gt;</span>acceleration<span class="token operator">*</span>pl_block<span class="token operator">-&gt;</span>millimeters<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算退出时的速度   //zhaoxin</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
          prep<span class="token punctuation">.</span>mm_complete <span class="token operator">=</span> decel_dist<span class="token punctuation">;</span> <span class="token comment">// End of feed hold.</span>
          prep<span class="token punctuation">.</span>exit_speed <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// [Normal Operation]正常操作</span>
        <span class="token comment">// Compute or recompute velocity profile parameters of the prepped planner block.</span>
		  <span class="token comment">//计算或重新计算准备好的规划器块的速度剖面参数。</span>
		prep<span class="token punctuation">.</span>ramp_type <span class="token operator">=</span> RAMP_ACCEL<span class="token punctuation">;</span> <span class="token comment">// Initialize as acceleration ramp.//设置标志位为加速</span>
        prep<span class="token punctuation">.</span>accelerate_until <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>millimeters<span class="token punctuation">;</span>   <span class="token comment">//zhaoxin</span>
        prep<span class="token punctuation">.</span>exit_speed <span class="token operator">=</span> <span class="token function">plan_get_exec_block_exit_speed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回下一个块的进入速度，当做当前块的退出速度，具体数据可联系前瞻算法</span>
        exit_speed_sqr <span class="token operator">=</span> prep<span class="token punctuation">.</span>exit_speed<span class="token operator">*</span>prep<span class="token punctuation">.</span>exit_speed<span class="token punctuation">;</span><span class="token comment">//计算退出速度的平方</span>
		  <span class="token comment">/*减速阶段距离intersect_distance的计算推导公式有三个
		  Vmax^2 - Vo^2 = 2aS1;   //Vo为初速度，S1为加速阶段距离
		  Vmax^2 - Ve^2 = 2aS2;   //Ve为末速度，S2为减速阶段距离
		  S1 + S2 = S总;		  //S总为当前线段的可移动距离
		  
		  accelerate_until 和 decelerate_after这两个参数具体代表的意思为如下线段
	                                        maximum_speed (&lt; nominal_speed) -&gt;  + 
                    +--------+ &lt;- maximum_speed (= nominal_speed)          /|`                                         
                   /          `                                           / | `                      
 current_speed -&gt; +            `                                         /  |  + &lt;- exit_speed
                  |             + &lt;- exit_speed                         /   |  |                       
                  +-------------+                     current_speed -&gt; +----+--+                   
                   time --&gt;  ^  ^                                           ^  ^                       
                             |  |                                           |  |                       
                decelerate_after(in mm)                             decelerate_after(in mm)
                    ^           ^                                           ^  ^
                    |           |                                           |  |
                accelerate_until(in mm)                             accelerate_until(in mm)
		  */</span>
        intersect_distance <span class="token operator">=</span>
                <span class="token number">0.5</span><span class="token operator">*</span><span class="token punctuation">(</span>pl_block<span class="token operator">-&gt;</span>millimeters<span class="token operator">+</span>inv_2_accel<span class="token operator">*</span><span class="token punctuation">(</span>pl_block<span class="token operator">-&gt;</span>entry_speed_sqr<span class="token operator">-</span>exit_speed_sqr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>intersect_distance <span class="token operator">&gt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span><span class="token comment">//说明改线段需要减速阶段，所以下面需要判断，将来处于哪一个阶段</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>intersect_distance <span class="token operator">&lt;</span> pl_block<span class="token operator">-&gt;</span>millimeters<span class="token punctuation">)</span><span class="token comment">//剩余的距离大于所需要的减速距离，代表该if代表本次线段不止只有减速阶段</span>
			<span class="token punctuation">{<!-- --></span> <span class="token comment">// Either trapezoid or triangle types   //zhaoxin</span>
				<span class="token comment">//注意，以下计算对于加速状态或者匀速状态，该计算结果也为0// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.</span>
				prep<span class="token punctuation">.</span>decelerate_after <span class="token operator">=</span> inv_2_accel<span class="token operator">*</span><span class="token punctuation">(</span>pl_block<span class="token operator">-&gt;</span>nominal_speed_sqr<span class="token operator">-</span>exit_speed_sqr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算线段最大限制速度减速到末速度需要的减速距离</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>prep<span class="token punctuation">.</span>decelerate_after <span class="token operator">&lt;</span> intersect_distance<span class="token punctuation">)</span><span class="token comment">//上位机设置的最大速度nominal_speed_sqr所需要的减速距离decelerate_after 小于 理论计算出的减速距离intersect_distance（）</span>
					<span class="token punctuation">{<!-- --></span><span class="token comment">//以上条件满足，则代表理论需要的距离，满足 当前设置的最大速度nominal_speed_sqr减速为指定退出速度exit_speed_sqr所需要的距离intersect_distance</span>
					prep<span class="token punctuation">.</span>maximum_speed <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>pl_block<span class="token operator">-&gt;</span>nominal_speed_sqr<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>pl_block<span class="token operator">-&gt;</span>entry_speed_sqr <span class="token operator">==</span> pl_block<span class="token operator">-&gt;</span>nominal_speed_sqr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">//如果初速度等于最大限制速度，那么线段只有匀速或者减速过程</span>
					<span class="token comment">// Cruise-deceleration or cruise-only type.</span>
						prep<span class="token punctuation">.</span>ramp_type <span class="token operator">=</span> RAMP_CRUISE<span class="token punctuation">;</span>
					<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
						<span class="token comment">// Full-trapezoid or acceleration-cruise types//具有加速，匀速和减速</span>
						prep<span class="token punctuation">.</span>accelerate_until <span class="token operator">-=</span> inv_2_accel<span class="token operator">*</span><span class="token punctuation">(</span>pl_block<span class="token operator">-&gt;</span>nominal_speed_sqr<span class="token operator">-</span>pl_block<span class="token operator">-&gt;</span>entry_speed_sqr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//总距离 减去 该线段加速时需使用的距离</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">//减速距离大于交点距离，说明线段设置的最大限制速度大于交点处的最大速度，那么线段只有三角形状的加速和减速过程，没有匀速过程</span>
					prep<span class="token punctuation">.</span>accelerate_until <span class="token operator">=</span> intersect_distance<span class="token punctuation">;</span>
					prep<span class="token punctuation">.</span>decelerate_after <span class="token operator">=</span> intersect_distance<span class="token punctuation">;</span>
					prep<span class="token punctuation">.</span>maximum_speed <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token operator">*</span>pl_block<span class="token operator">-&gt;</span>acceleration<span class="token operator">*</span>intersect_distance<span class="token operator">+</span>exit_speed_sqr<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>          
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//剩余的距离不足以让速度减下来，则进入全减速状态// Deceleration-only type</span>
				prep<span class="token punctuation">.</span>ramp_type <span class="token operator">=</span> RAMP_DECEL<span class="token punctuation">;</span>
				<span class="token comment">// prep.decelerate_after = pl_block-&gt;millimeters;</span>
				prep<span class="token punctuation">.</span>maximum_speed <span class="token operator">=</span> prep<span class="token punctuation">.</span>current_speed<span class="token punctuation">;</span><span class="token comment">//将当前速度设置为最大速度</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//减速距离为0，则代表仅设置为加速		// Acceleration-only type</span>
			prep<span class="token punctuation">.</span>accelerate_until <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
			<span class="token comment">// prep.decelerate_after = 0.0;</span>
			prep<span class="token punctuation">.</span>maximum_speed <span class="token operator">=</span> prep<span class="token punctuation">.</span>exit_speed<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>

    <span class="token comment">// Initialize new segment</span>
    prep_segment <span class="token operator">=</span> <span class="token operator">&amp;</span>segment_buffer<span class="token punctuation">[</span>segment_buffer_head<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// Set new segment to point to the current segment data block.</span>
    prep_segment<span class="token operator">-&gt;</span>st_block_index <span class="token operator">=</span> prep<span class="token punctuation">.</span>st_block_index<span class="token punctuation">;</span>

    <span class="token comment">/*------------------------------------------------------------------------------------
		Compute the average velocity of this new segment by determining the total distance
	traveled over the segment time DT_SEGMENT. The following code first attempts to create 
	a full segment based on the current ramp conditions. If the segment time is incomplete 
	when terminating at a ramp state change, the code will continue to loop through the
	progressing ramp states to fill the remaining segment execution time. However, if 
	an incomplete segment terminates at the end of the velocity profile, the segment is 
	considered completed despite having a truncated execution time less than DT_SEGMENT.
		The velocity profile is always assumed to progress through the ramp sequence:
	acceleration ramp, cruising state, and deceleration ramp. Each ramp's travel distance
	may range from zero to the length of the block. Velocity profiles can end either at 
	the end of planner block (typical) or mid-block at the end of a forced deceleration, 
	such as from a feed hold.
	通过确定段时间 DT_SEGMENT 内行驶的总距离来计算该新段的平均速度。 
	以下代码首先尝试根据当前斜坡条件创建完整段。
	如果在斜坡状态更改时终止时段时间不完整，则代码将继续循环遍历正在进行的斜坡状态以填充剩余的段执行时间。
	但是，如果不完整的段在速度曲线末尾终止，则尽管截断的执行时间小于 DT_SEGMENT，但该段仍被视为已完成。
	始终假定速度曲线按照斜坡序列进行：加速斜坡、巡航状态和减速斜坡。
	每个坡道的行驶距离范围可以从零到块的长度。
	速度曲线可以在规划器块的末端（典型）结束，也可以在强制减速（例如进给保持）结束时的中间块结束。
    */</span>
    dt_max <span class="token operator">=</span> DT_SEGMENT<span class="token punctuation">;</span> <span class="token comment">// Maximum segment time</span>
    time_var <span class="token operator">=</span> dt_max<span class="token punctuation">;</span> <span class="token comment">// Time worker variable</span>
	dt<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">;</span> <span class="token comment">// Initialize segment time</span>
    mm_remaining <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>millimeters<span class="token punctuation">;</span> <span class="token comment">//新段距块末尾的距离。// New segment distance from end of block.   //zhaoxin</span>
    minimum_mm <span class="token operator">=</span> mm_remaining<span class="token operator">-</span>prep<span class="token punctuation">.</span>req_mm_increment<span class="token punctuation">;</span> <span class="token comment">//保证至少一步。 // Guarantee at least one step.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>minimum_mm <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> minimum_mm <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>prep<span class="token punctuation">.</span>ramp_type<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">case</span> RAMP_ACCEL<span class="token operator">:</span> <span class="token comment">//加速</span>
          <span class="token comment">// NOTE: Acceleration ramp only computes during first do-while loop.</span>
          speed_var <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>acceleration<span class="token operator">*</span>time_var<span class="token punctuation">;</span><span class="token comment">//单位时间内，加速度的变化值</span>
          mm_remaining <span class="token operator">-=</span> time_var<span class="token operator">*</span><span class="token punctuation">(</span>prep<span class="token punctuation">.</span>current_speed <span class="token operator">+</span> <span class="token number">0.5</span><span class="token operator">*</span>speed_var<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//总距离mm_remaining 减去 本次加速时使用的距离</span>
		  <span class="token comment">//time_var*(prep.current_speed + 0.5*speed_var)的意思是：S = Vcur * t + 0.5 * Acc * t^2 ;(mm)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>mm_remaining <span class="token operator">&lt;</span> prep<span class="token punctuation">.</span>accelerate_until<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//当总距离mm_remaining不断减少，直到改线段加速斜坡完成时，进入if语句 // End of acceleration ramp.</span>
				<span class="token comment">// Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.</span>
				mm_remaining <span class="token operator">=</span> prep<span class="token punctuation">.</span>accelerate_until<span class="token punctuation">;</span> <span class="token comment">// NOTE: 0.0 at EOB</span>
				time_var <span class="token operator">=</span> <span class="token number">2.0</span><span class="token operator">*</span><span class="token punctuation">(</span>pl_block<span class="token operator">-&gt;</span>millimeters<span class="token operator">-</span>mm_remaining<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>prep<span class="token punctuation">.</span>current_speed<span class="token operator">+</span>prep<span class="token punctuation">.</span>maximum_speed<span class="token punctuation">)</span><span class="token punctuation">;</span> 
			<span class="token comment">/*	上诉公式的意义
					Vc-&gt;当前速度, Vm-&gt;加速曲线的最终速度
					Vc + Acc * time_var = Vm --》 time_var * Acc = Vm - Vc ①
					Vm^2 - Vc^2 = 2*Acc*S    --》 2*Acc*S = (Vm + Vc) * (Vm - Vc) ②
					timer_var = 2 * S / (Vm + Vc) &lt;- ① / ②
				*/</span>
				<span class="token comment">//zhaoxin</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>mm_remaining <span class="token operator">==</span> prep<span class="token punctuation">.</span>decelerate_after<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//加速完成后剩下的总距离mm_remaining == 减速需要的距离decelerate_after，则代表本次线段有加速和减速（且加速已完成）</span>
					prep<span class="token punctuation">.</span>ramp_type <span class="token operator">=</span> RAMP_DECEL<span class="token punctuation">;</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//加速完成后剩下的总距离mm_remaining &gt; 减速需要的距离decelerate_after则代表本次线段有加速、匀速和减速（且加速已完成）</span>
					prep<span class="token punctuation">.</span>ramp_type <span class="token operator">=</span> RAMP_CRUISE<span class="token punctuation">;</span> 
				<span class="token punctuation">}</span>
				prep<span class="token punctuation">.</span>current_speed <span class="token operator">=</span> prep<span class="token punctuation">.</span>maximum_speed<span class="token punctuation">;</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// Acceleration only. </span>
            prep<span class="token punctuation">.</span>current_speed <span class="token operator">+=</span> speed_var<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> RAMP_CRUISE<span class="token operator">:</span> <span class="token comment">//匀速</span>
          <span class="token comment">// NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.</span>
          <span class="token comment">// NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To </span>
          <span class="token comment">//   prevent this, simply enforce a minimum speed threshold in the planner.</span>
          mm_var <span class="token operator">=</span> mm_remaining <span class="token operator">-</span> prep<span class="token punctuation">.</span>maximum_speed<span class="token operator">*</span>time_var<span class="token punctuation">;</span><span class="token comment">//当总距离mm_var不断减少，直到改线段匀速完成时，进入if语句 </span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>mm_var <span class="token operator">&lt;</span> prep<span class="token punctuation">.</span>decelerate_after<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">///当总距离mm_var不断减少，直到改线段匀速完成时，进入if语句  // End of cruise. </span>
            <span class="token comment">// Cruise-deceleration junction or end of block.</span>
			  time_var <span class="token operator">=</span> <span class="token punctuation">(</span>mm_remaining <span class="token operator">-</span> prep<span class="token punctuation">.</span>decelerate_after<span class="token punctuation">)</span><span class="token operator">/</span>prep<span class="token punctuation">.</span>maximum_speed<span class="token punctuation">;</span><span class="token comment">//当前剩余的总距离 减去 减速阶段的距离 == 匀速阶段的距离（且只要有匀速阶段，那么就一定能达到最大速度maximum_speed）</span>
            mm_remaining <span class="token operator">=</span> prep<span class="token punctuation">.</span>decelerate_after<span class="token punctuation">;</span> <span class="token comment">// NOTE: 0.0 at EOB</span>
            prep<span class="token punctuation">.</span>ramp_type <span class="token operator">=</span> RAMP_DECEL<span class="token punctuation">;</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// Cruising only.         </span>
            mm_remaining <span class="token operator">=</span> mm_var<span class="token punctuation">;</span> 
          <span class="token punctuation">}</span> 
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span> <span class="token comment">// case RAMP_DECEL: 减速</span>
          <span class="token comment">// NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.</span>
          speed_var <span class="token operator">=</span> pl_block<span class="token operator">-&gt;</span>acceleration<span class="token operator">*</span>time_var<span class="token punctuation">;</span> <span class="token comment">// Used as delta speed (mm/min)</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>prep<span class="token punctuation">.</span>current_speed <span class="token operator">&gt;</span> speed_var<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// Check if at or below zero speed.</span>
            <span class="token comment">// Compute distance from end of segment to end of block.</span>
			mm_var <span class="token operator">=</span> mm_remaining <span class="token operator">-</span> time_var<span class="token operator">*</span><span class="token punctuation">(</span>prep<span class="token punctuation">.</span>current_speed <span class="token operator">-</span> <span class="token number">0.5</span><span class="token operator">*</span>speed_var<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//减去本次循环在这个减速减速阶段所运行的距离 //time_var*(prep.current_speed - 0.5*speed_var)的意思是 = Vcur * t + 0.5 * (-Acc) * t^2 ;(mm)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>mm_var <span class="token operator">&gt;</span> prep<span class="token punctuation">.</span>mm_complete<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// Deceleration only.</span>
              mm_remaining <span class="token operator">=</span> mm_var<span class="token punctuation">;</span>
              prep<span class="token punctuation">.</span>current_speed <span class="token operator">-=</span> speed_var<span class="token punctuation">;</span>
              <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// Segment complete. Exit switch-case statement. Continue do-while loop.</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span> <span class="token comment">// End of block or end of forced-deceleration.</span>
          time_var <span class="token operator">=</span> <span class="token number">2.0</span><span class="token operator">*</span><span class="token punctuation">(</span>mm_remaining<span class="token operator">-</span>prep<span class="token punctuation">.</span>mm_complete<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>prep<span class="token punctuation">.</span>current_speed<span class="token operator">+</span>prep<span class="token punctuation">.</span>exit_speed<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算这段减速所需要的时间</span>
          mm_remaining <span class="token operator">=</span> prep<span class="token punctuation">.</span>mm_complete<span class="token punctuation">;</span> 
      <span class="token punctuation">}</span>
	  
	  
      dt <span class="token operator">+=</span> time_var<span class="token punctuation">;</span> <span class="token comment">// Add computed ramp time to total segment time.</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>dt <span class="token operator">&lt;</span> dt_max<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> time_var <span class="token operator">=</span> dt_max <span class="token operator">-</span> dt<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// **Incomplete** At ramp junction.</span>
      <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>mm_remaining <span class="token operator">&gt;</span> minimum_mm<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span> <span class="token comment">//检查非常慢的零步段。 Check for very slow segments with zero steps.</span>
          <span class="token comment">//增加分段时间以确保分段中至少前进一步。覆盖和循环 Increase segment time to ensure at least one step in segment. Override and loop</span>
          <span class="token comment">//通过距离计算，直到minimum_mm或mm_complete。 through distance calculations until minimum_mm or mm_complete.</span>
          dt_max <span class="token operator">+=</span> DT_SEGMENT<span class="token punctuation">;</span>
          time_var <span class="token operator">=</span> dt_max <span class="token operator">-</span> dt<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//【经过一次阶段后剩下的总距离mm_remaining】 &lt;= 【minimum_mm = 进入循环前的总距离millimeters - 每一步能移动的距离（且放大了1.25倍）】--》便可以退出循环</span>
					<span class="token comment">//即：【运动前的距离millimeters - 运动后的距离mm_remaining &gt;= 每一步能移动的距离minimum_mm（且该距离minimum_mm放大了1.25倍)】便可以退出循环</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// **Complete** Exit loop. Segment execution time maxed.</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>mm_remaining <span class="token operator">&gt;</span> prep<span class="token punctuation">.</span>mm_complete<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// **Complete** Exit loop. Profile complete.</span>

   
    <span class="token comment">/* -----------------------------------------------------------------------------------
       Compute segment step rate, steps to execute, and apply necessary rate corrections.
       NOTE: Steps are computed by direct scalar conversion of the millimeter distance 
       remaining in the block, rather than incrementally tallying the steps executed per
       segment. This helps in removing floating point round-off issues of several additions. 
       However, since floats have only 7.2 significant digits, long moves with extremely 
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */</span>

	steps_remaining <span class="token operator">=</span> prep<span class="token punctuation">.</span>step_per_mm<span class="token operator">*</span>mm_remaining<span class="token punctuation">;</span> <span class="token comment">//将运动后剩余的距离转换成步数// Convert mm_remaining to steps</span>
	n_steps_remaining <span class="token operator">=</span> <span class="token function">ceil</span><span class="token punctuation">(</span>steps_remaining<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将运动后剩下的步数向上取整// Round-up current steps remaining</span>
	last_n_steps_remaining <span class="token operator">=</span> <span class="token function">ceil</span><span class="token punctuation">(</span>prep<span class="token punctuation">.</span>steps_remaining<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将整条线段中，运动步数最多的一个轴的步数向上取整 // Round-up last steps remaining</span>
	prep_segment<span class="token operator">-&gt;</span>n_step <span class="token operator">=</span> last_n_steps_remaining <span class="token operator">-</span> n_steps_remaining<span class="token punctuation">;</span> <span class="token comment">//总步数 减去 运动后剩余的步数 = 本次循环运动所需要的步数 Compute number of steps to execute.</span>
    
    <span class="token comment">// Bail if we are at the end of a feed hold and don't have a step to execute.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prep_segment<span class="token operator">-&gt;</span>n_step <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>sys<span class="token punctuation">.</span>state <span class="token operator">&amp;</span> <span class="token punctuation">(</span>STATE_HOLD<span class="token operator">|</span>STATE_MOTION_CANCEL<span class="token operator">|</span>STATE_SAFETY_DOOR<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Less than one step to decelerate to zero speed, but already very close. AMASS </span>
        <span class="token comment">// requires full steps to execute. So, just bail.</span>
        prep<span class="token punctuation">.</span>current_speed <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> <span class="token comment">// NOTE: (=0.0) Used to indicate completed segment calcs for hold.</span>
        prep<span class="token punctuation">.</span>dt_remainder <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
        prep<span class="token punctuation">.</span>steps_remaining <span class="token operator">=</span> n_steps_remaining<span class="token punctuation">;</span>
        pl_block<span class="token operator">-&gt;</span>millimeters <span class="token operator">=</span> prep<span class="token punctuation">.</span>steps_remaining<span class="token operator">/</span>prep<span class="token punctuation">.</span>step_per_mm<span class="token punctuation">;</span> <span class="token comment">// Update with full steps.   //zhaoxin</span>
        <span class="token function">plan_cycle_reinitialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         
        <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// Segment not generated, but current step data still retained.</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Compute segment step rate. Since steps are integers and mm distances traveled are not,</span>
    <span class="token comment">// the end of every segment can have a partial step of varying magnitudes that are not </span>
    <span class="token comment">// executed, because the stepper ISR requires whole steps due to the AMASS algorithm. To</span>
    <span class="token comment">// compensate, we track the time to execute the previous segment's partial step and simply</span>
    <span class="token comment">// apply it with the partial step distance to the current segment, so that it minutely</span>
    <span class="token comment">// adjusts the whole segment rate to keep step output exact. These rate adjustments are </span>
    <span class="token comment">// typically very small and do not adversely effect performance, but ensures that Grbl</span>
    <span class="token comment">// outputs the exact acceleration and velocity profiles as computed by the planner.</span>
    dt <span class="token operator">+=</span> prep<span class="token punctuation">.</span>dt_remainder<span class="token punctuation">;</span> <span class="token comment">//加上前一段未满一步所需要的执行时间 Apply previous segment partial step execute time</span>
    inv_rate <span class="token operator">=</span> dt<span class="token operator">/</span><span class="token punctuation">(</span>last_n_steps_remaining <span class="token operator">-</span> steps_remaining<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//计算出每步需要的时间 // Compute adjusted step rate inverse</span>
    prep<span class="token punctuation">.</span>dt_remainder <span class="token operator">=</span> <span class="token punctuation">(</span>n_steps_remaining <span class="token operator">-</span> steps_remaining<span class="token punctuation">)</span><span class="token operator">*</span>inv_rate<span class="token punctuation">;</span><span class="token comment">//将本次循环 不足一步 所需要的执行时间// Update segment partial step time</span>
																	<span class="token comment">//假设本次执行1.25步，那么dt_remainder就是0.25步所需要执行的时间</span>
    <span class="token comment">// Compute CPU cycles per step for the prepped segment.</span>
    cycles <span class="token operator">=</span> <span class="token function">ceil</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token operator">*</span>inv_rate<span class="token operator">*</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token operator">*</span>TICKS_PER_MICROSECOND <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//每步需要的时间设置为定时器的定时时间间隔 // (cycles/step)    </span>


    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        </span></span>
      <span class="token comment">// Compute step timing and multi-axis smoothing level.</span>
      <span class="token comment">// NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cycles <span class="token operator">&lt;</span> AMASS_LEVEL1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> prep_segment<span class="token operator">-&gt;</span>amass_level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
      <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cycles <span class="token operator">&lt;</span> AMASS_LEVEL2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> prep_segment<span class="token operator">-&gt;</span>amass_level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cycles <span class="token operator">&lt;</span> AMASS_LEVEL3<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> prep_segment<span class="token operator">-&gt;</span>amass_level <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> prep_segment<span class="token operator">-&gt;</span>amass_level <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    
        cycles <span class="token operator">&gt;&gt;=</span> prep_segment<span class="token operator">-&gt;</span>amass_level<span class="token punctuation">;</span> 
        prep_segment<span class="token operator">-&gt;</span>n_step <span class="token operator">&lt;&lt;=</span> prep_segment<span class="token operator">-&gt;</span>amass_level<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cycles <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> prep_segment<span class="token operator">-&gt;</span>cycles_per_tick <span class="token operator">=</span> cycles<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// &lt; 65536 (4.1ms @ 16MHz)</span>
	  <span class="token comment">/************************************************************
		此处可以得知AMASS算法使用的是16MHz下不分频的固定定时时间
	  ************************************************************/</span>
      <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> prep_segment<span class="token operator">-&gt;</span>cycles_per_tick <span class="token operator">=</span> <span class="token number">0xffff</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// Just set the slowest speed possible.</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>CPU_MAP_ATMEGA328P<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span><span class="token punctuation">(</span>CPU_MAP_ATMEGA2560<span class="token punctuation">)</span></span></span>

      <span class="token comment">// Compute step timing and timer prescalar for normal step generation.</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cycles <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// &lt; 65536  (4.1ms @ 16MHz)  4.1ms&lt;==1(不分频)*最大可填入65535/16MHz (本分支可以产生的最长的定时时间)</span>
        prep_segment<span class="token operator">-&gt;</span>prescaler <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// prescaler: 0</span>
        prep_segment<span class="token operator">-&gt;</span>cycles_per_tick <span class="token operator">=</span> cycles<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cycles <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// &lt; 524288 (32.8ms@16MHz)     32.8ms&lt;==8分频*最大可填入65535/16MHz </span>
        prep_segment<span class="token operator">-&gt;</span>prescaler <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// prescaler: 8</span>
        prep_segment<span class="token operator">-&gt;</span>cycles_per_tick <span class="token operator">=</span> cycles <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> 
        prep_segment<span class="token operator">-&gt;</span>prescaler <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// prescaler: 64</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cycles <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// &lt; 4194304 (262ms@16MHz)        262ms&lt;&lt;==64分频*最大可填入65535/16MHz   </span>
          prep_segment<span class="token operator">-&gt;</span>cycles_per_tick <span class="token operator">=</span>  cycles <span class="token operator">&gt;&gt;</span> <span class="token number">6</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// Just set the slowest speed possible. (Around 4 step/sec.)</span>
          prep_segment<span class="token operator">-&gt;</span>cycles_per_tick <span class="token operator">=</span> <span class="token number">0xffff</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>		<span class="token comment">//end of CPU_MAP_ATMEGA328P &amp; CPU_MAP_ATMEGA2560</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>CPU_MAP_STM32F10X<span class="token punctuation">)</span></span></span>
      <span class="token comment">//将cycles值变成定时器定时的时间</span>
      <span class="token comment">//stm32的psc寄存器16位，分频可以设置的细化一些 </span>
      <span class="token comment">//每一定时分支隔断条件：cycles &lt; 65535*2^r (r=0,1,2,...) </span>
      <span class="token comment">//每一定时分支最长时间(s)=(4.5*2^r)*65535/72MHz</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cycles <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// &lt; 65536  (4.1ms @ 72MHz)    </span>
        prep_segment<span class="token operator">-&gt;</span>prescaler <span class="token operator">=</span> <span class="token number">8</span> <span class="token punctuation">;</span> <span class="token comment">// prescaler: 4.5 </span>
        prep_segment<span class="token operator">-&gt;</span>cycles_per_tick <span class="token operator">=</span> cycles<span class="token operator">&gt;&gt;</span><span class="token number">1</span><span class="token punctuation">;</span>      
      <span class="token punctuation">}</span> 
      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cycles <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// &lt; 131072 (8.2ms@72MHz) </span>
        prep_segment<span class="token operator">-&gt;</span>prescaler <span class="token operator">=</span> <span class="token number">8</span> <span class="token punctuation">;</span>   <span class="token comment">// prescaler: 9                  </span>
        prep_segment<span class="token operator">-&gt;</span>cycles_per_tick <span class="token operator">=</span> cycles<span class="token operator">&gt;&gt;</span><span class="token number">1</span> <span class="token punctuation">;</span>  
      <span class="token punctuation">}</span> 
      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cycles <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// &lt; 262144 (16.4ms@72MHz) </span>
        prep_segment<span class="token operator">-&gt;</span>prescaler <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span>   <span class="token comment">// prescaler: 18                  </span>
        prep_segment<span class="token operator">-&gt;</span>cycles_per_tick <span class="token operator">=</span> cycles <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span>   
      <span class="token punctuation">}</span>
      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cycles <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// &lt; 524288 (32.8ms@72MHz) </span>
        prep_segment<span class="token operator">-&gt;</span>prescaler <span class="token operator">=</span>  <span class="token number">35</span><span class="token punctuation">;</span>  <span class="token comment">// prescaler: 36                   </span>
        prep_segment<span class="token operator">-&gt;</span>cycles_per_tick <span class="token operator">=</span> cycles <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">;</span>    
      <span class="token punctuation">}</span> 
      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cycles <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// &lt; 1048576 (65.5ms@72MHz) </span>
        prep_segment<span class="token operator">-&gt;</span>prescaler <span class="token operator">=</span>  <span class="token number">71</span><span class="token punctuation">;</span>  <span class="token comment">// prescaler: 72                </span>
        prep_segment<span class="token operator">-&gt;</span>cycles_per_tick <span class="token operator">=</span> cycles <span class="token operator">&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">;</span>  
      <span class="token punctuation">}</span> 
      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cycles <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// &lt; 2097152 (131ms@72MHz) </span>
        prep_segment<span class="token operator">-&gt;</span>prescaler <span class="token operator">=</span>  <span class="token number">143</span><span class="token punctuation">;</span> <span class="token comment">// prescaler: 144                </span>
        prep_segment<span class="token operator">-&gt;</span>cycles_per_tick <span class="token operator">=</span> cycles <span class="token operator">&gt;&gt;</span> <span class="token number">5</span><span class="token punctuation">;</span>   
      <span class="token punctuation">}</span> 
      <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> 
        prep_segment<span class="token operator">-&gt;</span>prescaler <span class="token operator">=</span> <span class="token number">287</span><span class="token punctuation">;</span>  <span class="token comment">// prescaler: 288             </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cycles <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>   <span class="token comment">// &lt; 4194304 (262ms@72MHz)</span>
          prep_segment<span class="token operator">-&gt;</span>cycles_per_tick <span class="token operator">=</span>  cycles <span class="token operator">&gt;&gt;</span> <span class="token number">6</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// Just set the slowest speed possible. (Around 4 step/sec.)</span>
          prep_segment<span class="token operator">-&gt;</span>cycles_per_tick <span class="token operator">=</span> <span class="token number">0xffff</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>		<span class="token comment">//end of CPU_MAP_STM32F10X</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

    <span class="token comment">// Segment complete! Increment segment buffer indices.</span>
    segment_buffer_head <span class="token operator">=</span> segment_next_head<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">++</span>segment_next_head <span class="token operator">==</span> SEGMENT_BUFFER_SIZE <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> segment_next_head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment">// Setup initial conditions for next segment.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mm_remaining <span class="token operator">&gt;</span> prep<span class="token punctuation">.</span>mm_complete<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
      <span class="token comment">// Normal operation. Block incomplete. Distance remaining in block to be executed.</span>
      pl_block<span class="token operator">-&gt;</span>millimeters <span class="token operator">=</span> mm_remaining<span class="token punctuation">;</span>      <span class="token comment">//zhaoxin</span>
      prep<span class="token punctuation">.</span>steps_remaining <span class="token operator">=</span> steps_remaining<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> 
      <span class="token comment">// End of planner block or forced-termination. No more distance to be executed.</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>mm_remaining <span class="token operator">&gt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// At end of forced-termination.</span>
        <span class="token comment">// Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete</span>
        <span class="token comment">// the segment queue, where realtime protocol will set new state upon receiving the </span>
        <span class="token comment">// cycle stop flag from the ISR. Prep_segment is blocked until then.</span>
        prep<span class="token punctuation">.</span>current_speed <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> <span class="token comment">// NOTE: (=0.0) Used to indicate completed segment calcs for hold.</span>
        prep<span class="token punctuation">.</span>dt_remainder <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
        prep<span class="token punctuation">.</span>steps_remaining <span class="token operator">=</span> <span class="token function">ceil</span><span class="token punctuation">(</span>steps_remaining<span class="token punctuation">)</span><span class="token punctuation">;</span>

        pl_block<span class="token operator">-&gt;</span>millimeters <span class="token operator">=</span> prep<span class="token punctuation">.</span>steps_remaining<span class="token operator">/</span>prep<span class="token punctuation">.</span>step_per_mm<span class="token punctuation">;</span> <span class="token comment">// Update with full steps. //zhaoxin</span>
        <span class="token function">plan_cycle_reinitialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// Bail!</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// End of planner block</span>
        <span class="token comment">// The planner block is complete. All steps are set to be executed in the segment buffer.</span>
        pl_block <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// Set pointer to indicate check and load next planner block.</span>
        <span class="token function">plan_discard_current_block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>      
</code></pre> 
<hr> 
<h2><a id="_858"></a>总结</h2> 
<p>本文到此暂时告一段落，由于学习GRBL算法部分是前一段时间的事情了，然后被工作繁忙耽误了很长一段时间才抽空写了这篇博客，所以本篇博客并不完善只是初稿，后续还会继续给予本篇博客完善算法部分的详细内容，咱先发出来试试水</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb35cbd17d0f51a661ac2df61a68a83e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c&#43;&#43;之函数对象与内建函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6ec818897c9cbbaee4f161a7c70a6521/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">卫星测高重力与重力反演地形</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>