<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GAMES101 梳理 / 个人向图形学笔记 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GAMES101 梳理 / 个人向图形学笔记" />
<meta property="og:description" content="Games101 前言 对闫令琪老师在GAMES101课程讲的东西进行梳理，主要是为了把所有知识点过一遍，说明白why、how、what的问题，不涉及具体的线性代数、计算机、物理、信号处理、数值处理等具体知识。加了一些其他地方看来的资料。
本人菜鸟，如果哪里不对，欢迎指正！
Lecture2 线性代数 Lecture3-4 坐标变换 1、二维的坐标变化 2、三维的坐标变化 model：把模型从本地坐标转换成世界坐标。
view：把世界坐标转换成观察坐标。先把相机放到某一位置，在保持相机的方向，把相机移动到原点。
projection：包括正交投影和透视投影。正交投影：无视z坐标，移动到原点；透视投影：把平截头体压缩成立方体，再进行正交投影。经过这一步得到标准化坐标。
*在一般的图形学渲染管线里，mvp都是发生在几何阶段的，具体过程是，先进行mv矩阵变换，然后对顶点进行着色（包括法向量、纹理坐标、颜色等），之后投影矩阵变换，得到一个标准化立方体（正交投影得到标准立方体好理解，但其实透视投影得到的也是标准立方体，经过压缩之后的），之后经过视锥剔除这一步操作，避免不必要的时间消耗，此时得到的还是标准化立方体，顶点的坐标还是三维的，然后经过视口变换，得到对应屏幕大小的二维图像，此时的顶点包括所有需要的信息（包括法向量、纹理坐标、颜色等）。然后进入光栅化阶段，先进行三角形处理，对顶点与顶点之间做插值，然后做光栅化，对应到像素，然后做shadding（包括纹理映射），对像素着色，之后做可视化处理、alpha测试、模板测试等，上屏到显示设备。
*矩阵相乘的顺序是从右往左，矩阵变换的顺序应该是——缩放、旋转、平移。
为什么引入齐次坐标？ 区分向量和点，更易于表示仿射变换
*仿射变换就是线性的几何变换加上一个平移，包括旋转、缩放、平移、切变。
Lecture5-6 Rasterization 光栅化 1、光栅化设备介绍 为什么模型用三角形？ 最基本的几何平面；保证是平面；容易进行插值操作（重心坐标）
2、怎么判断三角形和像素的关系？ 实际上就是用像素对图像进行采样，会出现锯齿（aliasing）。
解决方法：出现锯齿，进行反走样（antialiasing），先进行模糊操作再进行采样。
为什么模糊操作可以反走样？采样就相当于在时域用冲激函数对原函数做乘积，而采样频率越低，冲激函数频率越低，在频域的表现，冲激函数频率越高。而频域的原函数对冲激函数进行卷积操作，相当于对原函数图像的重复，冲激函数频率越高，越容易出现混叠。模糊操作消去了高频信号，高频信号便不容易混叠。
*傅里叶变换，时域与频域，高频与低频，卷积算子。 *时域的卷积相当于频域的乘积，时域的乘积相当于频域的卷积。
真正的反走样不好算。可能是因为进行滤波之后不好判断三角形和像素的关系？ 现实点的解决方法：
1、提高分辨率，就不关图形学的事儿了；
2、MSAA（multisampling AA)/超采样，把一个像素变成多个像素进行采样，得到的值求平均，还是用一个像素来表现，近似了模糊的操作，并没有提高分辨率，缺点是效率问题（问了老师，老师把antialising叫做反混淆，实际指的可能就是MSAA？）；
3、FXAA（fast approximate AA），图像处理层面，对生成的锯齿图去锯齿；
4、TAA（temporal AA），把MSAA对样本的处理分布在时间上。
5、超分辨率/超采样/DLSS（deap learning super sampling）
*这一块的前提好像就是模型的复杂度/图像的分辨率足够，采样点不足。如果采样点足够多，就不会出现锯齿现象！
Lecture7-9 shading shading：给物体施加材质的过程。包括光照和texture。
可见性，Z-buffering Blinn-Phong反射模型 specular高光：与观察方向有关
diffuse漫反射：与观察方向无关，光线打过来，均匀地反射到四面八方。
ambient环境光：可以设置为常数
这里的光线考虑衰减，I/r^2，实际衰减的是irradiance（单位面积的光的power）
shading frequency 对面shading（flat）
对vertex做shading（gouraud）
对像素做shading（phong shading）
图形渲染管线 三维空间顶点经过mvp矩阵变换，变成屏幕空间的顶点。
屏幕空间的顶点，经过三角形处理，组成三角形。
三角形经过光栅化，变成fragment。
fragment经过shading，计算光照、纹理映射（比如采用布林冯模型、微表面模型，就在此处进行相应的计算），变成fragment。
带材质的fragment经过framebuffer（比如深度处理），变成屏幕上的图像。
*具体过程是，先进行mv矩阵变换，然后对顶点进行着色（包括法向量、纹理坐标、颜色等），之后投影矩阵变换，得到一个标准化立方体（正交投影得到标准立方体好理解，但其实透视投影得到的也是标准立方体，经过压缩之后的），之后经过视锥剔除这一步操作，避免不必要的时间消耗，此时得到的还是标准化立方体，顶点的坐标还是三维的，然后经过视口变换，得到对应屏幕大小的二维图像，此时的顶点包括所有需要的信息（包括法向量、纹理坐标、颜色等）。然后进入光栅化阶段，先进行三角形处理，对顶点与顶点之间做插值，然后做光栅化，对应到像素，然后做shadding（包括纹理映射），对像素着色，之后做可视化处理、alpha测试、模板测试等，上屏到显示设备。
材质映射 *重心坐标，用来做插值 texture magnification 如果纹理太小怎么办？纹理上一个texel被图像上多个pixel包含，texel不够用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/99c0bb418e35bb7b80c0e3c59557796e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-26T23:37:55+08:00" />
<meta property="article:modified_time" content="2022-11-26T23:37:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GAMES101 梳理 / 个人向图形学笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Games101_0"></a>Games101</h2> 
<h4><a id="_1"></a>前言</h4> 
<p>对闫令琪老师在GAMES101课程讲的东西进行梳理，主要是为了把所有知识点过一遍，说明白why、how、what的问题，不涉及具体的线性代数、计算机、物理、信号处理、数值处理等具体知识。加了一些其他地方看来的资料。<br> 本人菜鸟，如果哪里不对，欢迎指正！</p> 
<h4><a id="Lecture2__4"></a><em>Lecture2 线性代数</em></h4> 
<h4><a id="Lecture34__5"></a><em>Lecture3-4 坐标变换</em></h4> 
<h6><a id="1_6"></a>1、二维的坐标变化</h6> 
<h6><a id="2_7"></a>2、三维的坐标变化</h6> 
<p>model：把模型从本地坐标转换成世界坐标。<br> view：把世界坐标转换成观察坐标。先把相机放到某一位置，在保持相机的方向，把相机移动到原点。<br> projection：包括正交投影和透视投影。正交投影：无视z坐标，移动到原点；透视投影：把平截头体压缩成立方体，再进行正交投影。经过这一步得到标准化坐标。<br> *在一般的图形学渲染管线里，mvp都是发生在几何阶段的，具体过程是，先进行mv矩阵变换，然后对顶点进行着色（包括法向量、纹理坐标、颜色等），之后投影矩阵变换，得到一个标准化立方体（正交投影得到标准立方体好理解，但其实透视投影得到的也是标准立方体，经过压缩之后的），之后经过视锥剔除这一步操作，避免不必要的时间消耗，此时得到的还是标准化立方体，顶点的坐标还是三维的，然后经过视口变换，得到对应屏幕大小的二维图像，此时的顶点包括所有需要的信息（包括法向量、纹理坐标、颜色等）。然后进入光栅化阶段，先进行三角形处理，对顶点与顶点之间做插值，然后做光栅化，对应到像素，然后做shadding（包括纹理映射），对像素着色，之后做可视化处理、alpha测试、模板测试等，上屏到显示设备。<br> *矩阵相乘的顺序是从右往左，矩阵变换的顺序应该是——缩放、旋转、平移。</p> 
<h6><a id="_13"></a>为什么引入齐次坐标？</h6> 
<p>区分向量和点，更易于表示仿射变换<br> *仿射变换就是线性的几何变换加上一个平移，包括旋转、缩放、平移、切变。</p> 
<h4><a id="Lecture56_Rasterization__16"></a><em>Lecture5-6 Rasterization 光栅化</em></h4> 
<h6><a id="1_17"></a>1、光栅化设备介绍</h6> 
<h6><a id="_18"></a>为什么模型用三角形？</h6> 
<p>最基本的几何平面；保证是平面；容易进行插值操作（重心坐标）</p> 
<h6><a id="2_20"></a>2、怎么判断三角形和像素的关系？</h6> 
<p>实际上就是用像素对图像进行采样，会出现锯齿（aliasing）。<br> 解决方法：出现锯齿，进行反走样（antialiasing），先进行模糊操作再进行采样。<br> 为什么模糊操作可以反走样？采样就相当于在时域用冲激函数对原函数做乘积，而采样频率越低，冲激函数频率越低，在频域的表现，冲激函数频率越高。而频域的原函数对冲激函数进行卷积操作，相当于对原函数图像的重复，冲激函数频率越高，越容易出现混叠。模糊操作消去了高频信号，高频信号便不容易混叠。</p> 
<h6><a id="_24"></a>*傅里叶变换，时域与频域，高频与低频，卷积算子。</h6> 
<p>*时域的卷积相当于频域的乘积，时域的乘积相当于频域的卷积。</p> 
<h6><a id="_26"></a>真正的反走样不好算。可能是因为进行滤波之后不好判断三角形和像素的关系？</h6> 
<p>现实点的解决方法：<br> 1、提高分辨率，就不关图形学的事儿了；<br> 2、MSAA（multisampling AA)/超采样，把一个像素变成多个像素进行采样，得到的值求平均，还是用一个像素来表现，近似了模糊的操作，并没有提高分辨率，缺点是效率问题（问了老师，老师把antialising叫做反混淆，实际指的可能就是MSAA？）；<br> 3、FXAA（fast approximate AA），图像处理层面，对生成的锯齿图去锯齿；<br> 4、TAA（temporal AA），把MSAA对样本的处理分布在时间上。<br> 5、超分辨率/超采样/DLSS（deap learning super sampling）<br> *这一块的前提好像就是模型的复杂度/图像的分辨率足够，采样点不足。如果采样点足够多，就不会出现锯齿现象！</p> 
<h4><a id="Lecture79_shading_34"></a><em>Lecture7-9 shading</em></h4> 
<p>shading：给物体施加材质的过程。包括光照和texture。</p> 
<h6><a id="Zbuffering_36"></a>可见性，Z-buffering</h6> 
<h6><a id="BlinnPhong_37"></a>Blinn-Phong反射模型</h6> 
<p>specular高光：与观察方向有关<br> diffuse漫反射：与观察方向无关，光线打过来，均匀地反射到四面八方。<br> ambient环境光：可以设置为常数<br> 这里的光线考虑衰减，I/r^2，实际衰减的是irradiance（单位面积的光的power）</p> 
<h6><a id="shading_frequency_42"></a>shading frequency</h6> 
<p>对面shading（flat）<br> 对vertex做shading（gouraud）<br> 对像素做shading（phong shading）</p> 
<h6><a id="_46"></a>图形渲染管线</h6> 
<p>三维空间顶点经过mvp矩阵变换，变成屏幕空间的顶点。<br> 屏幕空间的顶点，经过三角形处理，组成三角形。<br> 三角形经过光栅化，变成fragment。<br> fragment经过shading，计算光照、纹理映射（比如采用布林冯模型、微表面模型，就在此处进行相应的计算），变成fragment。<br> 带材质的fragment经过framebuffer（比如深度处理），变成屏幕上的图像。<br> *具体过程是，先进行mv矩阵变换，然后对顶点进行着色（包括法向量、纹理坐标、颜色等），之后投影矩阵变换，得到一个标准化立方体（正交投影得到标准立方体好理解，但其实透视投影得到的也是标准立方体，经过压缩之后的），之后经过视锥剔除这一步操作，避免不必要的时间消耗，此时得到的还是标准化立方体，顶点的坐标还是三维的，然后经过视口变换，得到对应屏幕大小的二维图像，此时的顶点包括所有需要的信息（包括法向量、纹理坐标、颜色等）。然后进入光栅化阶段，先进行三角形处理，对顶点与顶点之间做插值，然后做光栅化，对应到像素，然后做shadding（包括纹理映射），对像素着色，之后做可视化处理、alpha测试、模板测试等，上屏到显示设备。</p> 
<h6><a id="_53"></a>材质映射</h6> 
<h6><a id="_54"></a>*重心坐标，用来做插值</h6> 
<h6><a id="texture_magnification_55"></a>texture magnification</h6> 
<p>如果纹理太小怎么办？纹理上一个texel被图像上多个pixel包含，texel不够用。<br> 方法：用插值的方法补texel！近邻、双线性、双次立方。<br> 如果纹理过大怎么办？图像一个pixel包含多个texel（摩尔纹）。<br> 方法：mipmap。mipmap的好处，额外的内存开销小，只有原来的三分之一；缺点，只能对正方形区域查询，有的pixel包括的texel是斜着的一条区域，mipmap仍然不能表现该区域的属性。<br> 改良：ripmap，各向异性过滤，开销是原来的三倍。</p> 
<h6><a id="_61"></a>材质的应用</h6> 
<p>环境贴图、环境光（包括很多游戏大作的画面非常好，有些就是提前计算好光照，做成光照贴图）、<br> *环境贴图可以是球面或立方体面<br> 纹理不只可以表示颜色，也可以表示高度/法向量（bump/normal），只是影响了shading计算，没有真正地改变顶点的位置。用displacement mapping，可以实际上改变顶点的位置。（bump/normal这一步，纹理影响shading，作用于fragment，在fragment做shading的阶段进行处理；而如果是displacement，应该是顶点处理阶段进行。看来，着色频率的选取跟纹理贴图的应用有实际的对应关系。）<br> 三维噪声函数定义纹理，在任意点都能取得相应的值。（参考隐式的几何表达。）</p> 
<h4><a id="Lecture1012__66"></a><em>Lecture10-12 几何</em></h4> 
<h6><a id="1_67"></a>1、显式/隐式几何表达</h6> 
<p><strong>隐式的几何表达</strong><br> 代数公式、水平集、分形/自相似（fractals)<br> CSG（constructive solid geometry）：通过简单几何体的布尔运算获得复杂的几何体、<br> 距离函数：指的是到几何体点的最小距离，当两个几何体的点近，通过融合距离函数，生成新的几何体<br> <strong>显式的几何表达</strong>：直接或由参数映射，给出几何体上的点<br> 点云、几何面、.obj（不太理解为什么把.obj模型文件也归在这儿）<br> <strong>隐式集合表达的好处</strong>：<br> 很好区分内外关系，光线追踪时易于求交，处理拓扑结构方便，紧凑的表达<br> <strong>隐式几何表达的坏处</strong>：<br> 对于一些复杂几何形状很难表示</p> 
<h6><a id="2_78"></a>2、曲线</h6> 
<p>描述物体/相机的运动过程（animation）需要用到曲线。<br> 曲线就是贝塞尔曲线，用一些控制点+插值的方法对曲线进行控制。<br> 贝塞尔曲线的代数表达（德卡斯特里奥算法）、性质（比如曲线包含在控制点的凸包内）。<br> 分段贝塞尔曲线（及判断连续性）。<br> 样条：表示曲线的分段多项式函数。简单来说就是控制曲线的函数。<br> B-样条：既有贝塞尔曲线的性质，相比起来又需要更多的信息，比样条短（指的是函数表达？）。可以进一步推广为NURBS（非均匀有理b样条）。闫老师说B样条很有可能是图形学里最难的一块儿，所以了解下就差不多了。对了，B样条属于数值分析的一块儿内容。</p> 
<h6><a id="3_85"></a>3、曲面</h6> 
<p>曲面是由贝塞尔曲线表达的。<br> 1、曲面细分<br> Loop细分：只能对三角形进行，一分四，优化可以靠加权重进行。<br> Catmull-Clark细分：对矩形进行，先找奇异点，奇异面。<br> 2、曲面简化<br> 靠曲面坍缩进行。<br> 二次度量误差：每次细分要保证新的点到原来的边的距离之和最短，迭代此过程动态进行。</p> 
<h4><a id="Lecture13_16__93"></a><em>Lecture13- 16 光线追踪</em></h4> 
<h5><a id="1shadow_mapping_94"></a>1、shadow mapping</h5> 
<h6><a id="_95"></a>光栅化的问题</h6> 
<p>光栅化的渲染是将场景的渲染任务按层次拆解：物体——三角面——像素。这种拆解会导致全局信息的丢失，因此光栅化实现不了软阴影、间接光照等。</p> 
<h6><a id="shadow_mapping_97"></a>shadow mapping</h6> 
<p>光栅化没法考虑全局光照（GI），只能计算直接光照，没法考虑光源与物体间的遮挡，无法计算阴影。那怎么产生阴影的效果？用shadow mapping！但是只能处理点/方向光源，只能产生硬阴影（要么在阴影里，要么不在）。<br> key：一个点不在阴影里，就要同时被光线和相机看到。如果只被光线看到，不被相机看到，就不会被渲染；如果被光线看到，没被相机看到，就是阴影。<br> 实现：先从光源渲染，得到深度图；再从相机出发，经物体折射到相机，得到第二份深度，和原深度图对比，数值不同，则表示物体被遮挡，产生阴影。<br> 问题：画面会脏，数值精度问题（浮点数的相等不好判断，可以改判大小，或加个bias，但效果不好）；受限于shadow mapping的分辨率；只能产生<strong>硬阴影</strong>。<br> 应用：所有的3d游戏和早期动画。</p> 
<h5><a id="2_Ray_Casting_by_Author_Appel_103"></a>2、光线投射 Ray Casting （by Author Appel）</h5> 
<p>从相机出发，对于每个像素点向场景投射光线，直到光线与场景中第一个物体相交，在交点处，根据物体本身性质、光源属性和光照模型等来计算像素点的颜色；<br> 光线投射只考虑投射光线，光线与物体相交后不会继续跟踪，不考虑后续的折射、反射等。<br> 一般认为光线投射是光线追踪的前身。<br> <img src="https://images2.imgbox.com/6d/85/fMtNat61_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3whittedstyle__109"></a>3、whitted-style 光线追踪</h5> 
<p>想法：从照相机逐像素投射光线，在三维空间中经过传播、反射、折射（设置停止次数），然后从光源向空间中所有打到的点投射光线，求该点的颜色，最后沿视线打回到像素上。<br> <img src="https://images2.imgbox.com/f9/5c/Pwi5Uzl4_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fd/71/h9DV8boW_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4_113"></a>4、光线-面求交优化</h5> 
<p>最笨的方法是对每个像素打视线，对所有三角形面求交，在空间中反射、折射几次求几次，太费事。有以下几个方法：</p> 
<ol><li>视线对三角形所在的面求交，再判断是否和三角形相交，或者通过重心坐标的想法，直接和三角形联立出方程组，如果求得的结果使得重心坐标成立（非负且小于1），则与三角形有交点，其他情况都不成立。</li><li>包围盒AABB(axis-aligned bounding box)<br> 通过包围盒，对光线-面求交做优化。通过几个截面进行判断，光线经过包围盒，就必须要在每个截面都进入包围盒（有负值没关系），就是最晚进入包围盒和最早出包围盒的一段时间，当前者小于后者，且后者大于0，光线与包围盒有交集。</li><li>基于空间划分</li></ol> 
<ul><li>均匀空间划分（uniform spatial partitions）<br> 用均匀网格对空间进行划分，先判断光线跟网格有没有交点，再判断光线跟物体有没有交点。对均匀分布的场景，比如湖边的草地，效果尚可，但是对“运动场中的茶壶”这样的场景，效率较低。<br> 空间划分（KD-Tree、Oct-Tree、BSP-Tree）</li><li>KD-Tree是按照几个轴依次划分。数据结构用二叉树表示，中间节点存储的是格子和指向孩子节点的指针。叶子节点存储的是格子和实际的物体。KD-Tree可能出现一个物体被多个格子存储的情况，该怎么判断格子存储的是物体的哪些部分呢？这是比较难计算的，所以引进下面的方法。</li><li>物体划分（BVH）<br> 基于物体进行划分，不存在一个物体被多个格子存储的情况，但是格子与格子之间可能出现重叠，数据结构类似KD-Tree。如何划分？保证划分后物体在两个格子的数量较均匀。</li></ul> 
<h5><a id="5_125"></a>5、辐射度量学</h5> 
<p>whitted-style在物理上并不准确，只能表示镜面反射、折射（无法表示glossy材质）， 打到漫反射就停止，无法继续计算，所以得到的效果也不真实，为了用真实的物理量进行渲染，引进辐射度量学的知识。<br> 1、几个概念<br> energy：光的能量，以焦耳做单位。<br> flux/power：功率，单位时间的光的能量，相比energy，更常用于对光的能量的度量。<br> intensity：单位立体角的power。用 I 表示。<br> irradiance：单位面积的power。 用 E 表示。<br> radiance：单位立体角、单位面积的power。用 L 表示。<br> 2、双线性反射分布函数 BRDF（bidirectional reflectance distribution function）<br> BRDF是一个函数，将入射的irradiance映射成出射的radiance。简单来说，BRDF决定了对于入射光，如何分配出射的光。<br> 3、Reflection Equation<br> L=E+KE （K是BRDF和角度的积分）<br> 出射的光等于自身发出的光加从别的光源打过来的光。<br> 经过推导，得Rendering Equation： L=E+KE+(K^2)E+…<br> 其中 E和KE就是光栅化能计算的部分。<br> 4、概率论的回顾<br> X是随机变量（将事件映射为随机变量的取值），P(x)是对应的概率。略。</p> 
<h5><a id="6pathtracing__142"></a>6、path-tracing 路径追踪</h5> 
<p>因为whitted-style光线追踪还有这样那样的问题（如打到漫反射就停止等），提出path-tracing。路径追踪从属于光线追踪，也是用来计算全局光照的，它是绝对物理正确的。<br> 基本思想：从一个像素打出光线，在空间中折射、反射、漫反射…直到打到光源为止；在光线遇到表面需要反射时，以表面法线为中心做一个半球，向半球上的若干方向引出射线，递归计算这束光纤中，每条光线对表面上这个点的光照贡献。<br> <img src="https://images2.imgbox.com/50/a1/qdb40iMa_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="7Kajiya_146"></a>7、Kajiya渲染方程：</h5> 
<p><img src="https://images2.imgbox.com/eb/25/xzaFdVcp_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="_148"></a>一些问题</h6> 
<p>（1）定积分的求解<br> 计算的时候用蒙特卡洛积分近似计算。<br> （2）光线的数量会爆炸<br> 一个像素只有在打出一条光线的情况下，才不会计算爆炸，但是一条光线会产生噪声，所以一个像素打出数条。<br> （3）光线迭代的终止<br> 那么打出的光线什么时候停止呢？一是每次迭代生成随机数，根据随机数直接截断；二是引进俄罗斯轮盘赌方法，设置概率p，当光线打在物体上，有p的概率继续走，或者停止。<br> （4）如果光源面积比较小，从相机发射的光线到达光源的概率变小，有很多光线被浪费（提前截停），产生大量的噪声<br> 不对半球上的立体角积分，而是在光源上采样，对光源方向采样。<br> <img src="https://images2.imgbox.com/55/a5/aC4eAcxs_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="8_158"></a>8、体积光线投射</h5> 
<p><img src="https://images2.imgbox.com/46/e6/92KLusDf_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3f/96/Q2E1Ax40_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="8_161"></a>8、光线步进</h5> 
<p><img src="https://images2.imgbox.com/81/7b/GFPC9dof_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="9_164"></a>9、总结及其他全局光照方法</h5> 
<p><img src="https://images2.imgbox.com/ea/8a/VsBodyUV_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0e/24/9BjLbwHv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3b/c8/ilBfzXdd_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/63/a6/W8csNxqu_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_169"></a>其他光线追踪方法</h5> 
<p>particle tracing、光子映射、VCM、Metropolis light transport…</p> 
<h5><a id="Reference_171"></a>Reference</h5> 
<p>除了Games101，此处还参考了<a href="https://www.bilibili.com/video/BV1Mi4y1d7pX?p=2&amp;vd_source=08687d547d4502603e866450fdb1527b" rel="nofollow">百人计划课程</a></p> 
<h4><a id="Lecture17__173"></a><em>Lecture17 材质和外观</em></h4> 
<p>材质就是BRDF！</p> 
<h6><a id="1_175"></a>1、一些物理</h6> 
<p>镜面反射、漫反射、glossy、几种特殊的折射…<br> costics（焦散）：水底的条状的高亮，原因是水面的凹凸不平，导致光线经过折射打到一条带上。<br> 斯涅尔定律：入射折射率×入射角的正弦值=出射折射率x出射角的正弦值。经过推导，当入射折射率大于出射折射率，有可能发生全反射。引申：斯涅尔窗。<br> 菲涅尔项：视线垂直于物体的表面，物体的反射较弱；视线平行于物体的表面，物体的反射较强（一个例子是低头看湖面，水很清澈，反射弱，看远处的湖面，远山倒影，反射强）。绝缘体和导体的菲涅尔项有较大差异。<br> <img src="https://images2.imgbox.com/b7/83/hUGUIecU_o.png" alt="在这里插入图片描述"><br> F0是平面基础反射率，即垂直看物体表面时候的反射率。<br> <strong>下图：绝缘体（如玻璃）的菲涅尔反射率随着观察角度变化的趋势</strong><br> <img src="https://images2.imgbox.com/0e/e1/n4l4ddOY_o.png" alt="在这里插入图片描述"><br> <strong>下图：导体（如Glossy的金属）的菲涅尔反射率随着观察角度变化的趋势</strong><img src="https://images2.imgbox.com/c0/71/MessBSJ1_o.png" alt="在这里插入图片描述"><br> 补充：光线如果被物体完全反射，则物体不带有颜色，如果被物体部分吸收，则呈现颜色。</p> 
<h6><a id="2_186"></a>2、微表面模型</h6> 
<p>PBR（基于物理渲染）渲染管线之所以能够比较真实地表现各种不同的材质，是因为它采用了更加复杂的材质模型。在PBR渲染管线出现之前，我们通常采用的材质模型由三部分组成：环境光（Ambient）、漫反射（Diffuse）以及镜面反射（Specular）。但是这种模型难以模拟出表面不同的粗糙程度造成的不同反射效果，导致它模拟出来的材质在视觉上看起来更加接近于塑料的光滑表面。<br> PBR渲染管线中采用的是一种叫做微表面（Microfacet Model）的材质模型，它基于物理的观察，认为物体表面由很多凹凸不平的微小镜面组成。这些具有不同大小、方向的微表面在对入射光线进行反射时产生了不同的反射效果，从而使得人眼能观察到不同的材质属性，比如物体的粗糙程度就可以用微表面模型的法向量分布表示。因此，微表面模型能够更加真实地模拟各种不同的材质。</p> 
<h6><a id="3_189"></a>3、其他</h6> 
<p>1、各向同性和各向异性。前者是微表面没有方向性，后者是微表面有明显的方向性（如经过拉丝处理的金属，铝制品、光盘等，这些物体往往呈现出特别的高光。）。<br> 2、BRDF的性质：非负性、可逆性、线性可加性、能量守恒…<br> 3、BRDF的测量、存储…</p> 
<h4><a id="Lecture18__193"></a><em>Lecture18 先进的渲染技术</em></h4> 
<h6><a id="1_194"></a>1、现代光线传播</h6> 
<p>先介绍两个概念，无偏方法和有偏方法。无偏是不管样本有多少，都会得到正确的结果；而有偏是随着样本的多少，结果会变化，如果样本无限多，结果是正确的，那么这种有偏方法就能称为consistent。<br> 1、双向路径追踪BDPT（Bidirectional path tracing）<br> 从光源和相机各打出一条光线，连接终点。BDPT对光源情况比较复杂的场景效果不错。无偏的方法。<br> 2、MLT（Metropolis light transport）<br> 应用马尔科夫链和蒙特卡罗方法。以一定的概率扰动光线的传播，得到一条新的路径。但是收敛的时间不能确定，导致画面比较脏。无偏的方法。<br> 3、光子映射（Photon mapping）<br> 从光源打出光线，到漫反射停止，再从相机打出光线，到漫反射停止，收集平面上周围的N个光子，光子越多就越亮。当N取值小，画面会脏，当N取值大，画面会糊。是consistent的方法，打出无限多的光线，得到的结果很真实。对SDS（specular-diffuse-specular）的路径和caustics（中文翻为焦散但不准确）效果不错。<br> 4、Vertex connection and merging（VCM）<br> BDPT和Photo mapping的结合，想法是对BDPT，如果两边打出的光线不能连接，也不浪费这样的光线，利用光子映射把能融合的光子融合起来。常被用于电影产业。有偏的方法。<br> 5、实时辐射度 Instant Radiosity（IR）<br> 把光线打出，然后把光线的落点也当成光源，进行渲染。优点是计算快，而且对漫反射场景渲染效果好，缺点是不能处理glossy材质，而且场景缝隙会产生亮点。</p> 
<h6><a id="2_206"></a>2、外观建模</h6> 
<p>非表面模型：<br> 1、散射介质：<br> 雾、云…视线在物体里任意方向任意距离传播，在每个着点对光源进行着色。<br> 2、头发/毛发：<br> 头发是柱状模型，可以直接反射，也可以发生折射进入内部。<br> 3、颗粒材质<br> 如沙子，可以用程序生成。<br> 表面模型：<br> 1、次表面散射（Subsurface scattering）<br> 光线是可以打入物体内部的，如皮肤、玉石等等。用BSSRDF渲染人物比BRDF效果好。<br> 2、衣物<br> 衣服的渲染分三种，当作表面、当作散射介质、当作实际的构造。实际的构造指的是，纤维构成股，股构成线，线编制成衣服。<br> 3、细节表面 Detailed appearance<br> 真实的世界很复杂，物体的表面会有瑕疵、磨损。微表面模型的BRDF的NDF（法线分布）不该是均匀的。不同材质的微表面模型的NDF呈不同的分布。最近的趋势是波动光学，当物体足够小，光呈波动性，比如纯色的物体，当在一个光源下进行观察时，呈花色。<br> 程序化生成 Procedural Appearance<br> 利用噪声函数生成三维的纹理。<br> 拓展：闫令琪老师博士期间的三个研究：动物毛发模型、实时光线追踪、细节表面。</p> 
<h4><a id="Lecture19_camera_224"></a><em>Lecture19 camera</em></h4> 
<p>传感器接收到的是irradiance，无法判别方向，所以传感器需要镜头（透镜）来给接收到的光按方向区分开，不然就是模糊的一片。传统的针孔照相机的原理也是如此（针孔照相机无景深效果，景深是因为有透镜）。<br> 焦距和fov（field of view）：焦距越短，fov越大（广角镜头）。<br> 光圈和fov：光圈越大，f数越小（f数是焦距/光圈直径），虚化越重。<br> 曝光三要素：光圈、快门、ISO。<br> defocus blur：coc（circle of confusion）指的是，是因为透镜的原因，实际拍照时，被摄物体不在焦点，成像不是清晰的一个点，而是变成coc。光圈大，coc大，虚化重。<br> depth of field：景深（清晰焦段的深度），只要coc足够小（比像素小），得到的画面就是清晰的，而在焦点附近，有一段深度（景深），我们认为它是清晰的。大焦距，浅景深；大光圈，浅景深。</p> 
<h4><a id="Lecture20__231"></a><em>Lecture20 颜色和感知</em></h4> 
<h6><a id="1_232"></a>1、光场</h6> 
<p>全光函数：θ、φ（观察的方向）、Vx、Vy、Vz（位置）、λ（波长/颜色）、t（时间）<br> 光场：θ、φ（观察的方向）、Vx、Vy、Vz（位置）。光场即是，在任何一个位置，任何一个方向，都能知道光的强度。因为光是无限的直线，所以可以简化为四维函数（用包围盒围起一个场景，通过查询uv坐标确定位置；或可以用两个平面上的两对uv确定）。<br> 光场相机：相机的传感器接收到的是irradiance，无法确定光的方向，光场相机就是对每个单位面积的irradiance，加一个透镜进行分方向的操作。光场相机可以在后期重新对焦、移动相机位置。</p> 
<h6><a id="2_236"></a>2、颜色</h6> 
<p>光谱：在光谱上400-700nm波长的光为可见光。<br> 谱功率密度SPD（spectral power distribution）：光线在光谱上的能量分布（不同光线的SPD不同，所以本身能被人看见的颜色也不同）。<br> 注：光线本身是不带颜色的，颜色是人赋予的属性。就像如果收音机是生物，那光线对它来说是带有声音属性的一样。</p> 
<h6><a id="3_240"></a>3、颜色的生物基础</h6> 
<p>人眼相当于照相机，瞳孔相当于光圈，晶状体调节焦距，视网膜相当于传感器。视网膜上有两种细胞，柱状细胞和锥状细胞，前者感受光的强度，后者感受光的颜色。锥状细胞分为三种，S、M、L，对光的不同波长的感受能力不同。人观察到颜色的过程是：光线被三种细胞感受到，光线本身的SPD（光在不同波长的分布）和三种细胞对不同波长的感受曲线进行积分得到的三个数S、M、L，传到人脑的视觉部分，得到的颜色的感知。</p> 
<h6><a id="4_242"></a>4、色彩空间</h6> 
<p>CIE RGB：色域有限，要得到某些颜色，r需设为负值。<br> CIE XYZ：人为设置<br> HSV：饱和度、色相、亮度<br> CIELAB：三轴，亮度和两对互补色（红-绿，蓝-黄）<br> CMYK：用于印刷，减色系统（RGB：加色）</p> 
<h4><a id="Lecture2122_Animation_248"></a><em>Lecture21-22 Animation</em></h4> 
<p>animation怎么翻译？模拟、仿真、动画…大致就是考量模型怎么动起来。可以是衣服仿真，可以是流体仿真……animation是和渲染分割开的单独步骤，先考量顶点的位置，再进行渲染。</p> 
<h6><a id="1animation_250"></a>1、关键帧animation（利用插值、样条）</h6> 
<h6><a id="2animation_251"></a>2、基于物理的animation</h6> 
<p>1、质点弹簧系统（mass spring system）。需要考虑的是弹簧拽着的力、系统的损耗。可以通过质点弹簧系统模拟绳子、布料。<br> 2、粒子系统（partical system）。大致需要考虑的是粒子间的排斥力、吸引力、整体的方向。可以模拟流体、飞鸟……</p> 
<h6><a id="3_254"></a>3、运动学</h6> 
<p>1、正向运动学。直接控制每个节点的位置。缺点是不能让艺术家直接地控制。<br> 2、逆向运动学。直接拽着叶节点移动。</p> 
<h6><a id="4RIGGING_257"></a>4、RIGGING</h6> 
<p>rigging的中文：蒙皮、操偶、软选取……<br> 如果想使一个模型运动，控制所有的顶点移动，太繁琐，所以为模型加上控制点（骨骼），通过控制控制点，周围相关联的顶点都跟着移动。RIGGING的实现可以参考之前的贝塞尔曲线，不直接控制，而是通过控制点间接控制。对模型形状变化做blend，实际blend的是控制点。</p> 
<h6><a id="5_260"></a>5、动作捕捉</h6> 
<h6><a id="6pipeline_261"></a>6、动画制作pipeline</h6> 
<p>idea——原画集——完整的设计（人物、故事、场景）——layout（布景）——建模——材质——rigging——animation——VFX（视觉效果）——lighting&amp;渲染——合成——2DVFX——颜色校正——done。</p> 
<h6><a id="7_263"></a>7、解粒子位置的常微分方程</h6> 
<p>欧拉方法：不稳定、有误差<br> 优化的欧拉方法：中点法、自适应步长调整（按不同的ΔT跑欧拉，选择最优步长）、隐式欧拉方法、Verlet积分（基于位置）。引申：龙格库塔解ODE（常微分方程）</p> 
<h6><a id="8_266"></a>8、流体模拟</h6> 
<p>欧拉方法和拉格朗日方法、MPM（material point method，结合欧拉、拉格朗日方法）。</p> 
<h2><a id="PBR_268"></a>PBR专讲</h2> 
<p>PBR（Physically Based Rendering）：基于物理的渲染；PBR是一套框架/工作流，基于此框架可以很好地实现真实感渲染的效果<br> 包括：</p> 
<ol><li>基于物理的材质</li><li>基于物理的光照</li><li>基于物理的摄像机</li></ol> 
<h2><a id="1_274"></a>1、基于物理的材质（光照模型）</h2> 
<p>需要满足三个条件：</p> 
<ol><li>基于微平面（Microfacet）的表面模型</li><li>能量守恒</li><li>基于物理的BRDF</li></ol> 
<h4><a id="11_279"></a>1.1、微平面理论</h4> 
<p>微平面理论的理想是：将物体表面做成无数微观、有随机朝向的理想镜面反射的小平面。<br> <img src="https://images2.imgbox.com/73/49/d8LElszI_o.png" alt="请添加图片描述"></p> 
<h4><a id="12_282"></a>1.2、能量守恒</h4> 
<p>概念：出射光的能量永远不能大于入射光的能量。<br> 表现：随着粗糙度的上升，镜面反射区域会增加，为了保持能量守恒，镜面反射区域的平均亮度会下降。<br> <img src="https://images2.imgbox.com/20/93/w97skpGw_o.png" alt="请添加图片描述"><br> <img src="https://images2.imgbox.com/a4/8f/MMWTzN7w_o.png" alt="请添加图片描述"></p> 
<h4><a id="121_287"></a>1.2.1、如何做到能量守恒</h4> 
<p>使用能量反射方程：<br> <img src="https://images2.imgbox.com/42/d0/jxxM40tl_o.png" alt="请添加图片描述"><br> <img src="https://images2.imgbox.com/d5/50/FF4ICcXs_o.png" alt="请添加图片描述"><br> 能量反射方程的理解：<br> 出射光的强度 = 入射光导致的反射光的强度 + 自身发出的光的强度<br> 入射光导致的反射光的强度 = 反射系数/BxDF * 入射光强度 * 入射光的衰减<br> 入射光的衰减：半角向量 dot 法线 （半角向量是入射光和视线的夹角）</p> 
<h4><a id="122BRDF_295"></a>1.2.2、BRDF</h4> 
<p>双向反射分布函数 / Bidirectional Reflectrance Distribution Function<br> BSDF = BRDF + BTDF （T ：Transmitted Scatter / 折射）<br> <img src="https://images2.imgbox.com/10/0c/ZokZpMsG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="123BRDF_299"></a>1.2.3、怎么计算BRDF</h4> 
<p>一般把BRDF分为漫反射和高光反射（包括纯镜面反射</p> 
<h6><a id="BRDF_301"></a>BRDF的漫反射</h6> 
<p>漫反射部分通常采用Lambert光照模型（经验模型）</p> 
<table><tbody><tr><td> <img src="https://images2.imgbox.com/c2/07/pMxKLeR8_o.png"> </td><td> <img src="https://images2.imgbox.com/8b/52/TgYbecuN_o.png"> </td></tr></tbody></table> 
<p><img src="https://images2.imgbox.com/80/03/temNhK4I_o.png" alt="请添加图片描述"></p> 
<h6><a id="BRDF_310"></a>BRDF的高光反射（传统</h6> 
<p>传统的高光反射部分采用Phong或Blinn-Phong模型（都是经验模型）；<br> Phong考虑的是反射光线的方向和视角方向，Blinn-Phong考虑的是半角向量和法线。<br> <img src="https://images2.imgbox.com/41/31/yGA5mMpj_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="BRDF_314"></a>BRDF基于物理的高光反射</h6> 
<p>基于物理的高光反射，是利用<strong>Cook-Torrance反射率</strong>方程来计算光照，此方程对BRDF的部分进行更新，包括漫反射和高光反射，从而更新能量守恒公式，得出一个视觉上正确的结果。<br> <img src="https://images2.imgbox.com/cd/78/X0qDS50Y_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="NDF__D_317"></a>法线分布函数（NDF / D）</h6> 
<p><img src="https://images2.imgbox.com/1e/98/ewe1ERnC_o.png" alt="在这里插入图片描述"><br> 法线分布函数考量了法线对光线衰减带来的影响，是GGX光照模型，此前涉及到的Blinn-Phong光照模型也考量了法线对光线衰减带来的影响，但GGX光照模型的效果更好。<br> <img src="https://images2.imgbox.com/f9/75/tPIP3C7Y_o.jpg" alt="在这里插入图片描述"></p> 
<h6><a id="G_321"></a>几何（遮蔽）函数（G）</h6> 
<p>基于物理的材质里面，使用的是微平面理论，每个微平面互不干扰，但实际世界中，物体表面的凹凸是存在相互遮挡的。<br> <img src="https://images2.imgbox.com/90/29/mXAdEv4q_o.png" alt="在这里插入图片描述"><br> 几何（遮蔽）函数所做的就是在统计学上近似地求解了微平面间相互/自身遮蔽的比率。遮蔽会导致光线能量的损耗。<br> <img src="https://images2.imgbox.com/cb/e7/6hXZTUTB_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d3/19/nUWDN6l0_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="F_327"></a>菲涅尔方程（F）</h6> 
<p><img src="https://images2.imgbox.com/95/a0/1Gb6VjmY_o.png" alt="在这里插入图片描述"></p> 
<table><tbody><tr><td><img src="https://images2.imgbox.com/4e/58/UL08qQPl_o.png"></td><td><img src="https://images2.imgbox.com/40/2b/KxTuzADC_o.jpg"></td></tr></tbody></table> 
<h6><a id="GGX_332"></a>补充：GGX</h6> 
<p>ggx是一种微表面反射光照模型，这种光照模型材质可以很好地表现金属高光边缘的消散效果。<img src="https://images2.imgbox.com/02/0c/jxWHqQ4S_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="_335"></a>总结</h6> 
<p>使用Cook-Torrance反射率方程来计算出射光<br> <img src="https://images2.imgbox.com/fe/13/JsXEA4ZF_o.png" alt="请添加图片描述"><br> Lamert处理漫反射<br> <img src="https://images2.imgbox.com/91/dc/hNC0ZLL0_o.png" alt="请添加图片描述"></p> 
<p>其中，D，法线分布函数<br> <img src="https://images2.imgbox.com/ed/aa/VICnzyVY_o.jpg" alt="请添加图片描述"></p> 
<p>G，几何遮蔽函数<br> <img src="https://images2.imgbox.com/40/bd/Acdc4Vzu_o.png" alt="请添加图片描述"></p> 
<p>F，菲涅尔公式<br> <img src="https://images2.imgbox.com/70/48/otutFPwm_o.png" alt="请添加图片描述"></p> 
<h4><a id="BRDF_349"></a>扩展：迪士尼原则的BRDF</h4> 
<p>迪士尼提出的BRDF规范，原则包括：</p> 
<ol><li>应使用直观的参数，而不是物理类的晦涩参数</li><li>参数应尽可能少</li><li>参数在其合理范围内应该为0到1</li><li>允许参数在有意义时超出正常的合理范围</li><li>所有参数组合应尽可能健壮和合理</li></ol> 
<p>用了11个参数即可非常真实地模拟出金属、非金属以及不同粗糙度的材质光照结果：<img src="https://images2.imgbox.com/df/31/Pr7lk78R_o.jpg" alt="请添加图片描述"></p> 
<h4><a id="Unity_URPPBR_358"></a>Unity URP的PBR材质</h4> 
<p>分为高光流/漫反射流和金属度/粗糙度两套工作流，区别主要在于高光流提供SpecularMap，金属流提供MetallicMap。<br> <img src="https://images2.imgbox.com/e5/f9/5yoURsaf_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/13/76/Fuq8pwzR_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2_361"></a>2、基于物理的相机</h2> 
<h4><a id="Bloom_362"></a>自发光和Bloom特效</h4> 
<h6><a id="Bloom_363"></a>造成Bloom的原因：</h6> 
<ol><li>高亮的值使得数码相机的传感器饱和，并且泄漏到临近的传感器单元。</li><li>光线在摄像机镜头内反射。</li><li>相机镜头内或者表面有灰尘。</li></ol> 
<p>像素的最终亮度取决于相机的设置，EV值决定了是否产生Bloom的效果。当入射的亮度超过了传感器本身最大的亮度值，就会产生Bloom。</p> 
<h6><a id="Bloom_369"></a>如何设计白天和夜晚效果一致的Bloom。</h6> 
<p>对于自发光表面：可以给设计师提供工具控制Bloom。给自发光表面定义“曝光补偿”，用于调整它的强度，确保该强度超过饱和点。该项是场景全局值，额外的曝光被注入场景内，使得自发光表面变亮或者变暗。</p> 
<h2><a id="_371"></a>一些知识</h2> 
<h3><a id="_372"></a>曲面细分着色器和几何着色器</h3> 
<h4><a id="_373"></a>曲面细分着色器</h4> 
<p>曲面细分，英文称Tessellation，如果直译的话应该译作“镶嵌化处理技术”。由ATI开发，微软采纳后将其加入DirectX 11，成为DirectX 11的组成部分之一。由于这种技术广泛的应用在曲面的几何处理上，因此国内翻译时通常译作“曲面细分”。但实际上，这种技术不是只能用在曲面的细分处理上。</p> 
<h5><a id="_375"></a>曲面细分着色器的应用</h5> 
<p><img src="https://images2.imgbox.com/97/58/4Vo861Yb_o.png" alt="在这里插入图片描述"></p> 
<ol><li>面细分、线细分；</li><li>可以用来制作海浪、雪地里出现的脚印；</li><li>改变物体形状用法线贴图不是真的改变物体表面，用置换贴图可以做到真正改变物体表面，精度不够的话可以采用置换贴图+曲面细分着色器。</li></ol> 
<h5><a id="_380"></a>使用曲面细分着色器的好处</h5> 
<p>那么为什么不直接使用更精细的模型、贴图呢？因为使用曲面细分着色器可以根据距离或一些规则动态调整模型的复杂度，带来更好的性能；可复用性。</p> 
<h4><a id="_382"></a>几何着色器</h4> 
<p>在顶点和片段着色器之间有一个可选的几何着色器(Geometry Shader)，几何着色器的输入是一个图元（如点或三角形）的一组顶点。几何着色器可以在顶点发送到下一着色器阶段之前对它们随意变换。然而，几何着色器最有趣的地方在于，它能够将（这一组）顶点变换为完全不同的图元，并且还能生成比原来更多的顶点。<img src="https://images2.imgbox.com/c5/5a/KR1DfWbO_o.png" alt="在这里插入图片描述"><br> 做一些几何的绘制，可以用来做一些简单的几何动画；可以做爆破之类的特效；也可以定义草地，结合曲面细分着色器，得到一个动态调整密度的草地，远疏近密。</p> 
<h4><a id="_385"></a>着色器的执行顺序</h4> 
<p><img src="https://images2.imgbox.com/cf/51/2BpjeMEX_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/92/92/WSyTIIM8_o.png" alt="在这里插入图片描述"><br> <strong>Hull Shader</strong>主要作用是用来定义一些细分的参数，比如每条边上如何细分和内部三角形如何细分<br> <strong>Domain Shader</strong>它的空间在重心空间，我们需要把这个重心空间转换到我们要用的空间.</p> 
<h5><a id="Reference_390"></a>Reference</h5> 
<p><a href="https://www.bilibili.com/video/BV1XX4y1A7Ns?p=2&amp;vd_source=08687d547d4502603e866450fdb1527b" rel="nofollow">技术美术百人计划】图形 3.3 曲面细分与几何着色器 大规模草渲染</a><br> <a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/09%20Geometry%20Shader/" rel="nofollow">LearnOpenGL-几何着色器</a><br> <a href="https://www.yuque.com/docs/share/4941142e-6c9e-4f6d-8e53-ee053ef42a2e?#" rel="nofollow">百人计划 学生笔记</a><br> <a href="https://blog.csdn.net/whitebreeze/article/details/118314622">百人计划 学生笔记</a></p> 
<h3><a id="Light_Probes_395"></a>Light Probes</h3> 
<h4><a id="Reference_396"></a>Reference</h4> 
<p>【Joseph Bennett, Global Illumination on a Mobile Phone: Scalable Real-time Global Illumination using Sparse Radiance Probes, 2019】<br> <a href="https://www.bilibili.com/video/BV15f4y1b7AY/?spm_id_from=333.337.search-card.all.click&amp;vd_source=08687d547d4502603e866450fdb1527b" rel="nofollow">Light Probes 基本理论介绍</a></p> 
<h4><a id="Global_illuminationGI_399"></a>Global illumination（GI）</h4> 
<ol><li>直接光照 Directional illumination</li><li><strong>间接光照</strong> Indirect illumination</li><li>环境光遮蔽 Ambient Occlusion</li><li>反射、折射、散射 Reflections、Refraction、Scattering</li><li>Shadow</li><li>焦散 Caustics<br> …<br> <img src="https://images2.imgbox.com/de/25/yrgMkdXS_o.png" alt="在这里插入图片描述"></li></ol> 
<h4><a id="Indirect_illumination_408"></a>Indirect illumination</h4> 
<p><img src="https://images2.imgbox.com/89/bf/TT4BEzEP_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Light_Probes__Theory_410"></a>Light Probes - Theory</h4> 
<p>还是要从Kajiya在1986年的渲染方程讲起…<br> <img src="https://images2.imgbox.com/b5/d7/MXCPaTkn_o.png" alt="在这里插入图片描述"><br> 对于Kajiya的渲染方程求解，需要考虑积分项和BRDF，所以效率不高，一个优化的想法是，假设场景中所有物体的表面都是漫反射兰伯特材质——<br> <img src="https://images2.imgbox.com/a2/cc/nMEitqoX_o.png" alt="在这里插入图片描述"><br> 则渲染方程可以写作——<br> <img src="https://images2.imgbox.com/84/12/bteqFhj7_o.png" alt="在这里插入图片描述"><br> 其中ρ就是BRDF项，除以PI是经过数学推导的。但还是需要积分的求解，而光小球的概念则不需要积分求解——<br> <img src="https://images2.imgbox.com/f2/d5/CPfdGDrm_o.png" alt="在这里插入图片描述"><br> 通过在场景中摆很多小球，在计算某点在某个方向观察的亮度时，就可以通过计算这些小球上对应的方向的光照强度值得到的加权平均来近似。就好像每个小球是一个球形的Texture2D纹理，按照方向对所有小球上纹理对应方向的颜色值做加权平均即可快速得到某点的颜色值。<br> <img src="https://images2.imgbox.com/77/77/InzwbplR_o.png" alt="在这里插入图片描述"><br> 而公式中的ωi，即是小球的权重，小球的权重是通过计算小球到待计算光照的点的距离而得出的。<br> <img src="https://images2.imgbox.com/dc/2e/4cYzEnDk_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Light_Probes_423"></a>Light Probes使用中的一些问题</h4> 
<h6><a id="_424"></a>视差</h6> 
<p><img src="https://images2.imgbox.com/65/66/NPqQs8Om_o.png" alt="在这里插入图片描述"><br> 在计算场景中左上角的物体对x点的光照影响时，如果所有光小球的采样都是按照x点到物体的方向来，那结果就不对，所以要让光小球向物体方向进行采样。</p> 
<h6><a id="_427"></a>遮挡</h6> 
<p><img src="https://images2.imgbox.com/49/7d/15Q3EFiW_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="SRPSparse_Radiance_Probes_429"></a>SRP（Sparse Radiance Probes</h4> 
<p><img src="https://images2.imgbox.com/48/9e/AtAM96Tw_o.png" alt="在这里插入图片描述"><br> 其中红框是引入的可视性误差。</p> 
<h4><a id="Light_Probes___Spherical_harmonic_432"></a>光小球Light Probes的存储问题 — 球谐函数 Spherical harmonic</h4> 
<p>对于一个比较大的场景，可能要放比较多的光小球。每个光小球存储一个Texture2D的纹理的话，内存消耗是比较大的，所以引入<strong>球谐函数</strong>做一个近似计算。<br> 要了解球谐函数，就要先讲一下<strong>傅里叶变换 Furious transform</strong>——<br> <img src="https://images2.imgbox.com/ea/26/RMfsKc0n_o.png" alt="在这里插入图片描述"><br> 对于，一个在时域上分布的信号，可以在频域上，拆解成一个系数<em>基函数的和来模拟，这就是傅里叶变换。<br> <img src="https://images2.imgbox.com/5b/63/UyAejDt9_o.png" alt="在这里插入图片描述"><br> 其中c是系数，f是基函数。<br> 而球谐函数相当于是在极坐标系下的傅里叶变换，将小球在极坐标系下(θ, φ)的值f(θ, φ)表示为一系列系数</em>基函数的和。<br> <img src="https://images2.imgbox.com/a7/03/obWWbQ01_o.png" alt="在这里插入图片描述"><br> 如下图表示了取前n项所获得的小球和原小球 / 原信号的对比示意图。<br> <img src="https://images2.imgbox.com/49/b5/0VVNa3Y4_o.png" alt="在这里插入图片描述"><br> Unity使用球谐函数一般取前3-4项。<br> 使用cubemap通过球谐函数来生成Light Probes里的Probe的过程如下图所示：<br> <img src="https://images2.imgbox.com/e0/4c/MyiQp45O_o.png" alt="在这里插入图片描述"><br> 首先对于cubemap的图像，表示成球的样子（其中越亮的地方，在图中的小球的展示就越突出），作为原始图像信号，用球谐函数表示，然后取前n项作为Probe的表示。<br> 这样做的好处就是</p> 
<ol><li>可以减少内存的占用，用球谐函数来代替Texture2D；</li><li>在做球谐函数的信号变换时，可以去高频信息，比如边缘、噪声等，因为使用Light Probes的前提是假设场景中的表面都是漫反射的，所以去除高频信息在肉眼上是看不出差别的。</li></ol> 
<h3><a id="_451"></a>前向渲染和延迟渲染</h3> 
<p>前向渲染就是先计算光照再裁剪，延迟渲染就是先裁剪再计算光照。</p> 
<h4><a id="_453"></a>前向渲染</h4> 
<p>最基础，大多数引擎使用的标准。前向渲染的过程是，对每个几何体，逐个进行渲染管线的绘制，从顶点着色器、曲面细分着色器、几何着色器、片段着色器，生成一系列片段，然后进行深度测试，对最终可见的像素进行渲染生成。前向渲染是线性的，当场景中有多个几何体时，就挨个对其进行渲染，完成一个再继续下一个。<br> <strong>前向渲染的好处：</strong><br> 当需要使用多个着色模型，渲染管线里存在多种着色模型和渲染技术时，前向渲染很好支持，而且对于半透明物体的生成效果不错。在大多数手游里采用此种渲染方式。<br> <strong>前向渲染的缺点：</strong><br> （1）无效渲染太多，在渲染管线里，几何体间存在遮挡关系，按照前向渲染，渲染完一个几何体后，再渲染下一个几何体，如果之前渲染的几何体的部分被后一个渲染的几何体挡着，那被挡着的这部分就是无效的计算。<br> （2）难以支持过多的光源，对于需要逐像素进行计算的光源，渲染一个几何体时需要做对每个光源逐像素进行光源计算。比如m个物体，n个光源，那么渲染整个场景需要进行m*n次光照计算，而且其中还有许多计算被挡住了。<br> <strong>解决前向渲染的一些方法 / 前向实时剔除：</strong><br> （1）early-z<br> 对于片段，先进行深度测试，先计算光照<br> 对于光栅化生成的片段，先进行深度测试，利用zbuffer剔除看不见的片段，再进行片段的着色、光照计算。而不是传统的图形渲染管线里的，先进行片段着色、光照计算，再进行深度测试。<br> （2）z-prepass<br> 执行两次顶点着色器，第一遍计算深度，渲染时只渲染通过深度测试的片段<br> early-z在计算光照前对片段进行了深度剔除，但还是存在一些问题，比如对第一个几何体进行渲染时，此时深度通道/zbuffer是没有深度信息的，所有的片段都通过了深度测试，进行了渲染，但其中有一些渲染是无效渲染，是会被之后的片段所遮挡的片段。所以z-prepass针对这样的问题，对整个场景中的所有模型都渲染一遍，只计算深度信息，将所有深度信息写入z-buffer，然后再进行一次渲染，只渲染通过深度测试的片段。这种方法虽然避免了因深度遮挡而产生的无效的光照计算，但是进行了两次顶点着色器，所以适用于顶点数量不是很多但是光源很复杂的情况。<br> （3）Hi-z<br> 上面都是在GPU阶段进行的，Hi-z是在CPU阶段进行的，对提交到GPU的几何体，先进行遮挡测试，如果几何体被遮挡了就不会提交到GPU。这种方法直接减少了GPU需要渲染的几何体数量，适用于几何体数量多且细碎的场景。</p> 
<h4><a id="_469"></a>延迟渲染</h4> 
<p>延迟渲染就是把光照计算延迟到深度测试之后的渲染方式，适合场景中实时光照很多的情况，可以对每个光源按逐像素的方式计算。<br> z-prepass也是先进行深度测试，再进行光照计算，那么延迟渲染跟z-prepass有啥区别呢？区别在于g-buffer，z-prepass在计算完所有几何体的深度之后，对几何体还是逐个完成渲染的，但延迟渲染计算完深度之后，把所有几何体的信息发送到g-buffer，之后就跟有多少个几何体、有多少模型没关系了，接下来的操作都是对g-buffer的数据整体进行的。g-buffer保存渲染一个像素所需要的信息，不同的引擎对于g-buffer的处理也不一样，对于一个pbr的引擎来说，可能包括法向量、颜色、深度、材质等等。<br> 如果前向渲染m个物体和n个光源计算产生的计算量是m*n，那么延迟渲染的计算量就是m+n。这是因为延迟渲染的思路就是把所有几何体的信息都渲染到g-buffer中，然后对g-buffer整体进行光照计算，g-buffer中存储的信息都是最终会呈现在屏幕上的，不存在无效计算。</p> 
<h4><a id="_473"></a>延迟渲染的步骤：</h4> 
<p>延迟渲染分为GBuffer阶段和光照阶段，我们来看其具体步骤：</p> 
<ol><li>执行一个GBuffer Pass，通过多目标渲染（Multiple Render Targets，MRT）技术，将最终会显示到屏幕上的像素的颜色（BaseColor）、深度（Depth）、法线（Normal）等信息写入多个RT/纹理中，这些纹理组成了GBuffer。</li><li>执行Lighting Pass，逐像素分别从GBuffer的纹理中取出需要的信息，运行像素着色器计算出最终的颜色缓冲进行显示。</li></ol> 
<h4><a id="MSAA_477"></a>为什么说延迟渲染不能MSAA？</h4> 
<ol><li>MSAA本质上是一种发生在光栅化阶段的技术，也就是几何阶段后，着色阶段前，用这个技术需要用到场景中的几何信息</li><li>延迟渲染因为需要节省光照计算的原因，事先把所有信息都放在了GBuffer上，着色计算的时候已经丢失了几何信息</li><li>正常的延迟渲染肯定兼容不了MSAA，因为GBuffer丢了几何信息，如果一定要兼容那么就想办法在GBuffer那一层把几何信息也记录下来，具体怎么去兼容可以找资料，有人实现过</li><li>十几年前的DX9时代不支持MSAA，DX10.1支持MSAA，所以不要再说延迟渲染不支持硬件抗锯齿啦。</li></ol> 
<p><strong>延迟渲染的优点：</strong> 所有几何体都写入g-buffer，光照计算跟场景中有多少个物体、多少个三角形无关，不存在无效的计算，只渲染可见的像素。<br> <strong>延迟渲染的缺点：</strong><br> （1）要求场景中shader/渲染方式的种类比较少，如果渲染方式很多，对每个模型、材质都需要使用不同的shader，那么在g-buffer里该存哪些信息呢？延迟渲染对于程序和项目管理是个优点，可以提高性能、提升效率，但是对于美术是个缺点，限制了效果的表现。<br> （2）前向渲染只需要深度缓冲和最终的颜色缓冲就行，但延迟渲染需要缓冲的信息太多了，带宽开销增加，所以手机多使用前向渲染，延迟渲染不适用于手机，因为手机的带宽小，没法在缓冲区保存这么多数据。<br> 原神的手游尝试了延迟渲染。<br> （3）对于半透明无能为力，半透明物体需要等不透明物体延迟渲染渲染完后，再用前向渲染渲染出来。</p> 
<h4><a id="_489"></a>分块延迟渲染</h4> 
<p>虽然延迟渲染已经让减少了光源数量带来的计算开销，但光源更多了还是撑不住<br> 所以引入分块延迟渲染，g-buffer分成小块，对每个块分析受到哪些光源影响，然后逐块进行着色。</p> 
<h4><a id="_492"></a>关于引擎</h4> 
<p>现在的游戏引擎比如Unity和UE4 ，不管是延迟渲染还是前向渲染都有做支持，你可以在这两个引擎中选择一种渲染管线来使用。虽然二者都支持两种渲染管线，但是给人们的印象里，还是Unity用前向渲染的比较多，而UE4则几乎是代表了延迟渲染，实际体验中也可以得出相似的结论。</p> 
<p>现在一般做次世代游戏都选择UE4，比如《地平线零之曙光》《盗贼之海》《星球大战》等。</p> 
<p>而风格化的游戏都不太选择UE4，Unity对风格化的游戏具有更好的支持，可以很方便的配置各种渲染效果。而UE4如果想要方便的获得一个风格化效果，只能是靠后处理来实现，而要想获得真正理想的风格化效果，就需要花很大力气来改管线了。</p> 
<p>手游一般都是前向渲染，而且国内的手游一般都是用Unity做的，最近这些年也有很多项目开始使用UE4做手游了，但是即使是使用UE4做手游也都是前向渲染。</p> 
<p>这里不得不提一个异类就是《原神》，作为使用Unity开发的手游，居然使用了延迟渲染管线，可以说是一次非常有前瞻性的尝试了。我认为随着以后手机的性能不断进步，人们对画面质量的要求越来越高，延迟渲染也迟早会在手机上铺开的。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/86e87f688c8356d1355af9372c680e18/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQL中常用的聚合函数，知道这些就够了</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d5e733a23bc78a94f6e3621e41cd41b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">答案解析（C语言版本）——第五届“传智杯”全国大学生计算机大赛（初赛）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>