<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【笔试】python刷题笔记（基础）！ - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【笔试】python刷题笔记（基础）！" />
<meta property="og:description" content="数据结构与算法框架： 本人在b站的《剑指offer》讲解视频（比较通俗易懂的类型，当时代码能力一般，欢迎交流和批评指正）： https://www.bilibili.com/video/BV145411x76D
https://www.bilibili.com/video/BV1oi4y1G7eJ
1.while True 必须和break结合，无异常时执行try，异常时执行except，break退出循环。 while True: try: do something except: break 2.raw_input()与input() python2 存在raw_input()和input()两个函数
raw_input()将所有输入作为字符串看待，并且返回字符串类型
input()只用于数字的输入，返回所输入数字类型
python3 只存在input()函数，接收任意类型的输入，并且将输入默认为字符串类型处理，返回字符串类型，相当于python2的raw_input().
3.赋值a=b时，如果开辟新地址，b变化不会影响a；如果没有开辟新地址，则a、b做相同变化。 （1）可变对象、不可变对象： 可变对象：址传递，改变值不改变地址。（列表、字典、集合） 不可变对象：值传递，改变值必须改变地址。（数字、字符串、元组） （2）赋值、深拷贝和浅拷贝的区别: （深、浅拷贝分析的是可变对象情形下的的地址） 对于可变对象类型 List、Dictionary、Set，举例：列表alist和a： import copy a=[1,[2,3]] alist=a #赋值 alist=copy.copy(a) #浅拷贝 alist=copy.deepcopy(a) #深拷贝 alist.append(1) alist[0]=2 1）赋值：地址a和alist地址一样；改变alist，a作相同变化，。
2）copy.copy( )浅拷贝: 父对象开辟新地址，子对象地址不变。
3）copy.deepcopy( )深拷贝：父对象和子对象都开辟新地址。
4.链表 单向链表节点的表示：
class Node(object): #单向链表节点类 def __init__(self,data,next = None): self.data = data self.next = next 节点实例化：
node=Node(&#39;A&#39;,Node(&#39;B&#39;,Node(&#39;C&#39;))) 整体：
5.位运算： a=60,b=13。 n小于0时，用补码表示：
if n &lt; 0: n = n &amp; 0xffffffff 6." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/fe7e46a62962eddaede9d2bc57e43655/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-04T21:39:36+08:00" />
<meta property="article:modified_time" content="2020-05-04T21:39:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【笔试】python刷题笔记（基础）！</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>数据结构与算法框架：</h2> 
<p><img alt="" height="1022" src="https://images2.imgbox.com/77/7b/tNiLG4Uq_o.png" width="671"></p> 
<h2>本人在b站的《剑指offer》讲解视频（比较通俗易懂的类型，当时代码能力一般，欢迎交流和批评指正）：</h2> 
<p><a href="https://www.bilibili.com/video/BV145411x76D" rel="nofollow">https://www.bilibili.com/video/BV145411x76D</a></p> 
<p><a href="https://www.bilibili.com/video/BV1oi4y1G7eJ" rel="nofollow">https://www.bilibili.com/video/BV1oi4y1G7eJ</a></p> 
<h2>1.while True 必须和break结合，无异常时执行try，异常时执行except，break退出循环。</h2> 
<pre><code class="language-python">while True:
    try:
        do something
    except:
        break</code></pre> 
<h3> </h3> 
<h2>2.raw_input()与input()</h2> 
<h3>python2</h3> 
<p>存在<strong>raw_input()</strong>和<strong>input()</strong>两个函数</p> 
<p><strong>raw_input()</strong>将所有输入作为字符串看待，并且返回字符串类型</p> 
<p><strong>input()</strong>只用于<span style="color:#f33b45;">数字</span>的输入，返回所输入数字类型</p> 
<h3> python3</h3> 
<p>只存在<strong>input()</strong>函数，接收任意类型的输入，并且将输入默认为字符串类型处理，返回字符串类型，相当于python2的raw_input().</p> 
<h3> </h3> 
<h2>3.赋值a=b时，如果开辟新地址，b变化不会影响a；如果没有开辟新地址，则a、b做相同变化。</h2> 
<h3><strong>（1）可变对象、不可变对象：</strong></h3> 
<h3><span style="color:#f33b45;">可变对象：址传递，改变值不改变地址。（列表、字典、集合）</span></h3> 
<h4><span style="color:#f33b45;">不可变对象：值传递，改变值必须改变地址。（数字、字符串、元组）</span></h4> 
<h3>（2）赋值、深拷贝和浅拷贝的区别:</h3> 
<h4>（深、浅拷贝分析的是<span style="color:#7c79e5;">可变对象</span>情形下的的地址）</h4> 
<h4><span style="color:#3399ea;">对于可变对象类型 List、Dictionary、Set，举例：列表alist和a：</span></h4> 
<pre><code class="language-python">import copy
a=[1,[2,3]]
alist=a #赋值
alist=copy.copy(a)  #浅拷贝
alist=copy.deepcopy(a)  #深拷贝

alist.append(1)
alist[0]=2</code></pre> 
<p><strong>1）赋值：地址a和alist地址一样；改变alist，a作相同变化，。</strong></p> 
<p><strong>2）copy.copy( )浅拷贝: 父对象开辟新地址，子对象地址不变。</strong></p> 
<p><strong>3）copy.deepcopy( )深拷贝：父对象和子对象都开辟新地址。</strong></p> 
<h3> </h3> 
<h2>4.链表</h2> 
<p><img alt="" height="134" src="https://images2.imgbox.com/9b/e3/5Fn1gBwz_o.png" width="603"></p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/56/f7/jkduB6RT_o.png" width="717"></p> 
<p><strong>单向链表节点的表示：</strong></p> 
<pre><code class="language-python">class Node(object):  #单向链表节点类
	def __init__(self,data,next = None):
		self.data = data
		self.next = next</code></pre> 
<p><strong>节点实例化：</strong></p> 
<pre><code class="language-python">node=Node('A',Node('B',Node('C')))</code></pre> 
<p><img alt="" height="117" src="https://images2.imgbox.com/81/27/Wn5jtUVs_o.png" width="337"></p> 
<p><strong>整体：</strong></p> 
<p><img alt="" src="https://images2.imgbox.com/05/31/fGYRLLVd_o.png"></p> 
<h3> </h3> 
<h2>5.位运算：</h2> 
<h4>a=60,b=13。</h4> 
<p><img alt="" height="394" src="https://images2.imgbox.com/a7/69/DUXj3rrL_o.png" width="838"></p> 
<p>n小于0时，用补码表示：</p> 
<pre><code class="language-python">if n &lt; 0:
    n = n &amp; 0xffffffff</code></pre> 
<h3> </h3> 
<h2>6.算数运算符：</h2> 
<p><strong>注意：python3中， / 返回float，// 返回int</strong></p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/a0/7c/rtDiFyoX_o.png" width="834"></p> 
<h3> </h3> 
<h2>7.python3中，range()用法和列表切片经常搞混：</h2> 
<h3>（1）range()返回的不是列表，而是一个包含索引的对象:</h3> 
<p>range（）是一个函数，用的是<strong>括号</strong>和<strong>逗号</strong>。</p> 
<pre><code class="language-python">for i in range(n):           #顺着取索引，0~n-1
for i in range(n-1,-1,-1)    #倒着取索引，n-1~0</code></pre> 
<h3>（2）列表切片：</h3> 
<p>切片是取列表，用的是<strong>中括号</strong>和<strong>冒号</strong>。</p> 
<pre><code class="language-python">list = [1, 2, 3, 4, 5, 6, 7 ]
list2[1:5]     #[2, 3, 4, 5]
</code></pre> 
<h3> </h3> 
<h2>8.用<span style="color:#3399ea;">sys模块</span>输入：</h2> 
<h3>A、用input()输入：</h3> 
<pre><code class="language-python">a=int(input())   #数字 
b=list(map(int,input().split()))  #数字元素的列表
print(a,b)</code></pre> 
<h3>B、用sys模块输入：</h3> 
<pre><code class="language-python">import sys</code></pre> 
<h4><strong>（1）控制台<span style="color:#f33b45;">单个数字</span>输入：</strong></h4> 
<pre><code class="language-python">a=int(sys.stdin.readline().strip())</code></pre> 
<h4><strong>（2）把这一行用空格分开的数字，变为<span style="color:#f33b45;">列表：</span></strong></h4> 
<pre><code class="language-python">b=list(map(int,sys.stdin.readline().strip().split()))</code></pre> 
<h4>（3）指定行数 输入多行数据 返回<span style="color:#f33b45;">二维list</span>：</h4> 
<pre><code class="language-python">c=[]
for i in range(a): 
    cc=list(map(int,sys.stdin.readline().strip().split())) 
    c.append(cc)
print(c)    
</code></pre> 
<h4>（4）不指定行数 输入多行数据 返回<span style="color:#f33b45;">二维list</span>：</h4> 
<pre><code class="language-python">d=[]
while True:
    try:
        dd=list(map(int,sys.stdin.readline().strip().split()))
        if not dd:
                break
        d.append(dd)
    except:
        break
print(d)</code></pre> 
<h3> </h3> 
<h2>9.子结构和子树的区别：</h2> 
<h3><strong>子树的意思是：</strong></h3> 
<p><strong>包含了一个结点，就得包含这个结点下的所有节点，一棵大小为n的二叉树有n个子树，就是分别以每个结点为根的子树。</strong></p> 
<h3><strong>子结构的意思是：</strong></h3> 
<p><strong>包含了一个结点，可以只取左子树或者右子树，或者都不取。</strong></p> 
<p> </p> 
<h2><strong>10、列表：</strong></h2> 
<h3><strong>（1）插入：</strong></h3> 
<h4><strong>.append(a)   #在末尾加上元素a</strong></h4> 
<h4><strong>.insert(index,a)   #在指定位置index处加入元素a</strong></h4> 
<h4><strong>.extend([1,2])     #加入新列表</strong></h4> 
<h4><strong>a=a+b         #直接加法</strong></h4> 
<h3><strong>（2）删除：</strong></h3> 
<h4><strong>.pop()      #删除末尾元素</strong></h4> 
<h4><strong>切片        #列表删除元素还可以进行切片操作。</strong></h4> 
<p> </p> 
<h2><strong>11.a=[ ]或a=0或a=None，</strong></h2> 
<h2><strong>都可代表<span style="color:#f33b45;">False</span>的意思，当not a 时相当于<span style="color:#f33b45;">True</span>。</strong></h2> 
<p> </p> 
<h2>13.树的创建与各种遍历：</h2> 
<h2>（BFS，DFS==前，中，后）（非递归方式）</h2> 
<p><img alt="" height="313" src="https://images2.imgbox.com/60/70/B1XNcAjR_o.png" width="444"></p> 
<h3> </h3> 
<pre><code class="language-python">#树的遍历
class Node ():
    def __init__(self,data,left=None,right=None):  #也是值在前面，指针在后面，默认为None
        self.data=data
        self.left=left
        self.right=right
class Tree():
    def __init__(self,base):
        self.base=base
    def bfs(self,node):
        queue=[]
        queue.append(node)
        while queue:
            temp=queue.pop(0)
            print(temp.data, end=' ')
            left=temp.left
            right=temp.right
            if left:
                queue.append(left)
            if right:
                queue.append(right)
    def fro(self,node):   #前序遍历==DFS
        if not node:
            return
        stack=[]
        stack.append(node)
        while stack:
            temp=stack.pop()
            print(temp.data, end=' ')
            right=temp.right
            left=temp.left
            if right:
                stack.append(right)
            if left:
                stack.append(left)
    def mid(self,node):  #左-根-右,左节点放在栈的最右边
        if not node:
            return
        stack = []
        while stack or node:
            while node:
                stack.append(node)
                node = node.left
            node = stack.pop()
            print(node.data,end=' ')
            node = node.right
    def beh(self,node):
        if not node:
            return
        stack = []
        while stack or node:
            while node:
                stack.append(node)
                node = node.left if node.left else node.right
            node = stack.pop()
            print(node.data,end=' ')
            if stack and stack[-1].left == node:
                node = stack[-1].right
            else:
                node = None

base = Node(1,Node(2, Node(4), Node(5)), Node(3, Node(6), Node(7)))  # 树的根节点
tree = Tree(base)  # 树

print('BFS')
tree.bfs(tree.base)
print('\n')

print('前序遍历==DFS')
tree.fro(tree.base)
print('\n')

print('中序遍历')
tree.mid(tree.base)
print('\n')

print('后序遍历')
tree.beh(tree.base)
print('\n')</code></pre> 
<h3> </h3> 
<h2>13、图的BFS、DFS：</h2> 
<p><img alt="" height="348" src="https://images2.imgbox.com/46/fa/pOpa4CMb_o.png" width="368"></p> 
<pre><code class="language-python"># 定义无向图结构（相当于字典，键是一个节点，值是列表(储存相关联的所有节点)）
graph = {
    "A": ["B","C"],
    "B": ["A", "C", "D"],
    "C": ["A", "B", "D","E"],
    "D": ["B", "C", "E","F"],
    "E": ["C", "D"],
    "F": ["D"],
}

def BFS(graph,vertex):
    # 使用列表作为队列
    queue = []
    # 将首个节点添加到队列中
    queue.append(vertex)
    # 使用集合来存放已访问过的节点
    looked = set()
    # 将首个节点添加到集合中表示已访问
    looked.add(vertex)
    # 当队列不为空时进行遍历
    while(len(queue)&gt;0):
        # 从队列头部取出一个节点并查询该节点的相邻节点
        temp = queue.pop(0)
        nodes = graph[temp]
        # 遍历该节点的所有相邻节点
        for w in nodes:
            # 判断节点是否存在于已访问集合中,即是否已被访问过
            if w not in looked:
                # 若未被访问,则添加到队列中,同时添加到已访问集合中,表示已被访问
                queue.append(w)
                looked.add(w)
        print(temp,end=' ')

def DFS(graph,vertex):
    # 使用列表作为栈
    stack = []
    # 将首个元素添加到队列中
    stack.append(vertex)
    # 使用集合来存放已访问过的节点
    looked = set()
    # 将首个节点添加到集合中表示已访问
    looked.add(vertex)
    # 当队列不为空时进行遍历
    while len(stack)&gt;0:
        # 从栈尾取出一个节点并查询该节点的相邻节点
        temp = stack.pop()
        nodes = graph[temp]
        # 遍历该节点的所有相邻节点
        for w in nodes:
            # 判断节点是否存在于已访问集合中,即是否已被访问过
            if w not in looked:
                # 若未被访问,则添加到栈中,同时添加到已访问集合中,表示已被访问
                stack.append(w)
                looked.add(w)
        print(temp,end=' ')
# 由于无向图无根节点，则需要手动传入首个节点，此处以"A"为例
print("BFS",end=" ")
BFS(graph,"A")
print("")
print("DFS",end=" ")
DFS(graph,"A")

BFS A B C D E F 
DFS A C E D F B 

</code></pre> 
<h2><br> 14.二叉搜索树：</h2> 
<h3>又称为二叉排序树（二叉查找树），它或许是一棵空树，或许是具有以下性质的二叉树：</h3> 
<h3>1.若它的左子树不为空，则左子树上所有的节点的值小于根节点的值<br> 2.若它的右子树不为空，则右子树上所有的节点的值都大于根节点的值<br> 3.它的左右子树也分别是二叉搜索树</h3> 
<h3>#中序遍历可以按顺序排列</h3> 
<p> </p> 
<h2>15.排序函数：</h2> 
<h2>sorted(iterable, cmp=None, key=None, reverse=False)</h2> 
<h3>lambda函数：</h3> 
<pre><code>add = lambda x, y : x+y
add(1,2)  # 结果为3</code></pre> 
<p> </p> 
<h2>17.itertools.permutations(ss)</h2> 
<h3>输出字符串排序的不同方法，每个方法一个组合，集合成一个非常规对象，有重复的</h3> 
<pre><code class="language-python">import itertools
class Solution:
    def Permutation(self, ss):
        # write code here
        if not ss:
            return []
        return sorted(list(set(map(''.join, itertools.permutations(ss)))))

#map(''.join,A)  转化为字符串组成的对象

#set()  返回无重复元素集，降重;可以看作不能重复的集合，也可看做set（）对象。

#list() 转化为列表

#sorted()  排序</code></pre> 
<h3> </h3> 
<h2>18.max( )函数、min( )函数：</h2> 
<h3>max(x,y,z):返回x,y,z中最大元素。</h3> 
<h3>max([1,1,2]):返回[1,1,2]中最大元素。（列表）</h3> 
<p> </p> 
<h2>19.次数问题：创建字典，以元素为键，次数为值。</h2> 
<pre><code class="language-python">d={}
numbers=[1,1,2,2,2,3,3,3]
for i in numbers:
    try:
        dict[i]+=1
    except:
        dict[i]=1</code></pre> 
<h3>pop( )、get()、del</h3> 
<h3>对字典排序用sorted排序：（列表既可用sort也可用sorted）</h3> 
<pre><code class="language-python">a={1:2,3:4,5:1}
b=dict(sorted(a.items(),key=lambda b:b[1]))
print(b)</code></pre> 
<p> </p> 
<h2>20.考试执行时，多用try-except语句避免异常：</h2> 
<h3>try-except</h3> 
<pre><code class="language-python">try:
    fun()
    do something1
expect:
    do something2</code></pre> 
<h3>while-True-try-except（解决处理多个case）(最后再加，避免无法调试)</h3> 
<p> </p> 
<pre><code class="language-python">while True:
    try:
        a=sys.stdin.readline().strip()
        if not a:
            break
        fun()

    except:
        break</code></pre> 
<h3> </h3> 
<h2>21.sorted( )和sort( )的小区别：</h2> 
<pre><code class="language-python">#sort()改变了a，且不能赋值给b。
a=[1,4,3,2]
a.sort()
print(a)

#sorted()未改变a，改变后的对象赋值给b。
a=[1,4,3,2]
b=sorted(a)
print(a,b)</code></pre> 
<h3> </h3> 
<h2>22.tab与空格的问题：</h2> 
<h4>（1）tab与空格不能混用：同一列不能一个用tab，一个用空格。（pycharm里处理过的，所以只要对齐，就不用担心）</h4> 
<h4>（2）建议缩进都用4个空格的长度（考试时一定要检查）</h4> 
<p> </p> 
<h2>23.python中，{集合}不支持索引。</h2> 
<p> </p> 
<h2>24.题义有时候很迷，直接看输入描述、输出描述，看的还明白些。</h2> 
<p> </p> 
<h2>25.tuple可以作为字典的键，list不能。</h2> 
<p> </p> 
<h2>26.索引函数</h2> 
<h3>（1）字符串找索引函数：find、rfind</h3> 
<p><strong>s.find('a')：返回s中a的最小索引</strong></p> 
<p><strong>s.rfind('a')：返回s中a的最大索引</strong></p> 
<h3>（2）列表索引函数：index</h3> 
<p><strong>list.index(a)：返回list中a的最小索引</strong></p> 
<p> </p> 
<h2>27.collections库</h2> 
<pre><code>import collections
d = collections.OrderedDict() #有序字典(输出顺序与添加顺序有关//无序字典无关)
a = collections.Counter(b)    #计数器，Counter类型，加dict变成计数字典</code></pre> 
<h3> </h3> 
<h2>28.if和elif的区别：</h2> 
<h4>if：会一直遍历完所有的if，不管你想判断的条件有没有遍历到，他都会继续执行完所有的if。</h4> 
<h4>elif ：走到符合查询条件的语句后，后面所有的elif和else就不会再被执行。</h4> 
<p> </p> 
<h2>29.五大算法思想（最优解算法）：</h2> 
<h4><span style="color:#f33b45;">（1）贪心算法：</span></h4> 
<p><strong>在对问题求解时，总是作出在当前看来是最好的选择。（一件事情分为很多步，每步都做最好的选择）（局部最优&gt;&gt;全局最优，必须无后效性）</strong></p> 
<h4><span style="color:#f33b45;">（2）动态规划算法：</span></h4> 
<p><strong>每次决策依赖于当前状态，又随即引起 ‘状态的转移’。一个‘决策序列’就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。（经分解后得到的子问题往往不是互相独立的，即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）</strong></p> 
<h4><span style="color:#f33b45;">（3）分治法：</span></h4> 
<p><strong>分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</strong></p> 
<h4><span style="color:#f33b45;">（4）DFS（深度优先搜索）：</span></h4> 
<p><strong><span style="color:#f33b45;">（回溯法=DFS+剪枝）</span></strong></p> 
<p><strong>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</strong></p> 
<h4><span style="color:#f33b45;">（5）BFS（广度优先搜索、分支限界法）：</span></h4> 
<p><strong>类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</strong></p> 
<h3> </h3> 
<h2><strong>30.图：</strong></h2> 
<p><img alt="" src="https://images2.imgbox.com/65/46/Y32htqP3_o.png"></p> 
<h3> </h3> 
<h2>32.哈希表（散列表）：</h2> 
<p><strong>       哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表或哈希表。具体表现为： 存储位置 = f(key)</strong></p> 
<h3> </h3> 
<h2>33.堆：</h2> 
<p><img alt="" height="444" src="https://images2.imgbox.com/b4/3f/b1BapYt5_o.png" width="507"></p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/88/1c/ifp7YQSi_o.png" width="539"></p> 
<h3> </h3> 
<h2>34.if-elif-else形成一套，只执行第一个满足条件的；后面再遇到if就是第二套:</h2> 
<h2><img alt="" height="280" src="https://images2.imgbox.com/62/5d/BThdB9iX_o.png" width="529"></h2> 
<h2>输出：</h2> 
<h2><img alt="" height="83" src="https://images2.imgbox.com/55/20/gwbbiKX5_o.png" width="55"></h2> 
<h3> </h3> 
<h2>35.round(x,2)       #把x换为两位小数的浮点型</h2> 
<h3> </h3> 
<h2>36.平衡二叉树（AVL）：</h2> 
<h3>定义：</h3> 
<p>一棵<strong>空树</strong>或<strong>它的左右两个子树的高度差的绝对值不超过1</strong>，并且<strong>左右两个子树都是一棵平衡二叉树</strong>。</p> 
<h3>平衡树的判定：</h3> 
<pre><code class="language-python">#遍历每个结点，借助一个获取树深度的递归函数，根据该结点的左右子树高度差判断是否平衡，然后递归地对左右子树进行判断。
class Solution:
    def IsBalanced_Solution(self, pRoot):
        # write code here
        if pRoot == None:
            return True
        
        if abs(self.TreeDepth(pRoot.left)-self.TreeDepth(pRoot.right)) &gt; 1:
            return False
        return self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right)
       
    def TreeDepth(self, pRoot):   #计算树的深度
        # write code here
        if pRoot == None:
            return 0
        nLeft = self.TreeDepth(pRoot.left)  #左子树的深度
        nRight = self.TreeDepth(pRoot.right)
        return max(nLeft+1,nRight+1)</code></pre> 
<h3> </h3> 
<h2>37.return可以返回一个判定语句，根据语句真实性选择True或False。</h2> 
<p><img alt="" height="194" src="https://images2.imgbox.com/7b/1c/7712vO2e_o.png" width="541"></p> 
<h3> </h3> 
<h2>38.字符串：</h2> 
<h3> （1）join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串</h3> 
<h4><span style="color:#f33b45;">（把str插入序列元素之间）</span></h4> 
<pre><code class="language-python">str.join(sequence)</code></pre> 
<h3> </h3> 
<h2>39.操作文件：</h2> 
<h3>读取txt文件：</h3> 
<p><strong>open（）函数</strong>打开txt文件，返回 ‘file’ 类型；</p> 
<p><strong>file.readline( )方法 </strong>按照每一行划分，返回字符串组成的列表。</p> 
<pre><code class="language-python">file = open('validation.txt','r')
number_list=file.readlines()
for i in range(len(number_list)):
    number_list[i]=number_list[i].strip()
print(number_list)</code></pre> 
<h3> </h3> 
<h2>40.操作文件夹：</h2> 
<h3>读取文件夹，返回文件名组成的列表：   #参数为路径，后面要有‘/’</h3> 
<pre><code class="language-python">a=os.listdir('velodyne/')   #参数为路径，后面要有‘/’
print(a)</code></pre> 
<h3>移动文件：                      #参数为文件名，要有文件名的后缀</h3> 
<pre><code class="language-python">shutil.move(src_path+number+'.bin',target_path+number+'.bin') #文件名</code></pre> 
<h3> </h3> 
<h2>44、精心选择的数据结构可以带来更高的运行或者存储效率，数据结构往往同高效的检索算法和索引技术有关。</h2> 
<h4><strong>①队列：先入先出；单队列；双端队列。 </strong></h4> 
<p><img alt="" height="110" src="https://images2.imgbox.com/b6/98/VWRqjtLy_o.png" width="989"></p> 
<h4><strong>②数组：最基本的数据结构；保存数据的个数在分配内存时是确定的；可以插入或删除数据。 </strong></h4> 
<p><img alt="" height="150" src="https://images2.imgbox.com/09/13/diUMZtho_o.png" width="589"></p> 
<h4><strong>③堆：一棵按顺序排列的完全二叉树。在存储时没有任何限制，可以访问任意节点。    </strong></h4> 
<p><strong>最大堆:每个节点的值都大于等于它的孩子节点。    </strong></p> 
<p><strong>最小堆:每个节点的值都小于等于它的孩子节点。    对于下标为i的节点，它的子树的左节点的下标为2i,右节点为2i+1，父亲的节点下标为i/2（向下取整）。 </strong></p> 
<h4><strong>④栈（stack）：桶状线性结构；先进后出；只能在栈顶进行插入、删除操作。</strong></h4> 
<p><img alt="" height="128" src="https://images2.imgbox.com/69/8d/3sCzd2Ay_o.png" width="340"></p> 
<h4><strong>⑤链表：在非连续的内存单元中保存数据；通过指针将各个内存单元链接在一起，最后一个节点的指针指向 NULL；不需要提前分配固定大小存储空间，当需要存储数据的时候分配一块内存并将这块内存插入链表中； 双链表；循环链表。</strong></h4> 
<p><img alt="" height="532" src="https://images2.imgbox.com/9f/43/i4vn62ve_o.png" width="1027"></p> 
<h4>⑥树：</h4> 
<p><img alt="" height="267" src="https://images2.imgbox.com/28/a5/6xczzmAh_o.png" width="603"></p> 
<h4>⑦图[G（V，E）]：有向图；无向图；图上的边或弧带有权则称为网；若任意两顶点都是连通的，则图就是连通图，有向则称为强连通图；无向图中连通且n个顶点n-1条边称为生成树；有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。</h4> 
<p><img alt="" height="259" src="https://images2.imgbox.com/2f/31/MEg6Qetf_o.png" width="1029"></p> 
<h2>45、如何判断单向链表中是否有环?      </h2> 
<p>看快慢指针是否相遇。</p> 
<h2>46、哪种数据结构可以实现递归？        </h2> 
<p><strong>栈</strong>可以实现；递归需要保存正在计算的上下文， 等待当前计算完成后弹出，再继续计算， 只有栈先进后出的特性才能实现。</p> 
<h2>47、计算一个二叉树的最大距离有两个情况。</h2> 
<p><strong>情况A</strong>: 路径经过左子树的最深节点，通过根节点，再到右子树的最深节点。</p> 
<p><strong>情况B</strong>: 路径不穿过根节点，而是左子树或右子树的最大距离路径，取其大者。 只需要计算这两个情况的路径距离，并取其大者，就是该二叉树的最大距离。<img alt="" height="248" src="https://images2.imgbox.com/d5/08/Ji2G75zL_o.png" width="973"></p> 
<h2>48、关于树：树的定义使用了递归的方式。</h2> 
<p><img alt="" height="276" src="https://images2.imgbox.com/2e/95/ivHBttD5_o.png" width="352">                                 <img alt="" height="312" src="https://images2.imgbox.com/30/9a/N26iWOpP_o.png" width="331"></p> 
<h3>存储方式：</h3> 
<h4>顺序存储→数组→满二叉树</h4> 
<h4>链式存储→链表→其他二叉树</h4> 
<p><img alt="" height="274" src="https://images2.imgbox.com/e3/02/EFysYv45_o.png" width="723"></p> 
<h3> </h3> 
<h3> </h3> 
<h2><strong>49、霍夫曼树（最优二叉树）：一种带权路径长度最短的二叉树。</strong></h2> 
<h4><strong>主要作用：数据压缩、缩短编码长度。</strong></h4> 
<h4><strong>带权路径长度：WPL=（W1*L1+W2*L2+W3*L3+...+Wn*Ln），N个权值Wi（i=1,2,...n）构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li（i=1,2,...n）。可以证明霍夫曼树的WPL是最小的。</strong></h4> 
<h4><strong>霍夫曼编码：C（2）+D（4）→T1（6）、B（5）+T1（6）→T2（11）、A（7）+T2（11）→霍夫曼树，算出霍夫曼树。然后</strong>从根节点出发，向左标记为0，向右标记为1，将字母串进行编码。</h4> 
<p><img alt="" height="252" src="https://images2.imgbox.com/6d/64/iDTrf2sY_o.png" width="289"><img alt="" height="249" src="https://images2.imgbox.com/3a/71/kIXSfEXa_o.png" width="269"><img alt="" height="352" src="https://images2.imgbox.com/27/e7/CHJdGtUV_o.png" width="676"></p> 
<h2>50.线索二叉树：若结点的左子树为空，则该结点的左孩子指针指向其前驱结点。<br> 若结点的右子树为空，则该结点的右孩子指针指向其后继结点。</h2> 
<h4><strong>前驱节点：中序遍历前一个节点</strong></h4> 
<h4><strong>后继节点：中序遍历后一个节点</strong></h4> 
<h3> </h3> 
<h2>51、</h2> 
<h3>类变量：类名.变量名（定义时）（所有实例均可调用）</h3> 
<h3>实例变量：self.变量名（定义时）（当前实例调用）</h3> 
<h3> </h3> 
<h2>52、子类调用父类方法：</h2> 
<pre><code class="language-python">class 子类（父类）：
    def __init__(self,父类变量，父类变量，子类变量):
        父类.__init__(self，父类变量，父类变量)
        self.子类变量=子类变量
    def 子类方法（self）：
        pass                         #这样，子类的实例就能用父类的方法了。
</code></pre> 
<p> </p> 
<h2>53.查找：</h2> 
<h3>（1）二分查找（数组排好序，有重复，返回第一个）：</h3> 
<pre><code class="language-python">def b_search(lst, val): #让left、right相遇，返回left
    if not lst:
        return -1
    left = 0
    right = len(lst) - 1

    while left &lt; right:
        mid = (left+right) // 2
        if lst[mid] &gt;=val:
            right=mid
        else:
            left = mid + 1
    if lst[left]!=val:
        return -1
    return left

lst=[1,2,3,4,4,4,4,4,4,4,4,4,4,4,4]
print(b_search(lst,5))</code></pre> 
<h3>（2）特别大的数据量，实现查找、排序：</h3> 
<h4>a、位图法</h4> 
<p>位图法是我在编程珠玑上看到的一种比较新颖的方法，思路比较巧妙效率也很高。</p> 
<p>使用场景举例：对2G的数据量进行排序，这是基本要求。</p> 
<p>数据：1、每个数据不大于8亿；2、数据类型位int；3、每个数据最多重复一次。</p> 
<p>内存：最多用200M的内存进行操作。</p> 
<p>首先对占用的内存进行判断，每个数据不大于8亿，那么8亿是一个什么概念呢。</p> 
<p>**</p> 
<p>1 byte = 8 bit（位）</p> 
<p>1024 byte = 8*1024 bit = 1k</p> 
<p>1024 k = 8*1024*1024 bit = 1M = 8388608 bit</p> 
<p>**</p> 
<p>也就是1M=8388608位</p> 
<p>而位图法的基本思想就是利用一位代表一个数字，例如3位上为1,则说明3在数据中出现过，若为0，则说明3在数据中没有出现过。所以当题目中出现每个数据最多重复一次这个条件时，我们可以考虑使用位图法来进行大数据排序。</p> 
<p>那么假如使用位图法来进行这题的排序，内存占用多少呢。由题目知道每个数据不大于8亿，那么我们就需要8亿位，占用800000000/8388608=95M的空间，满足最多使用200M内存进行操作的条件，这也是这题能够使用位图法来解决的一个基础。</p> 
<h4>b、堆排序法</h4> 
<p>堆排序是4种平均时间复杂度为nlogn的排序方法之一，其优点在于当求M个数中的前n个最大数，和最小数的时候性能极好。所以当从海量数据中要找出前m个最大值或最小值，而对其他值没有要求时，使用堆排序法效果很好。</p> 
<p>使用场景：从1亿个整数里找出100个最大的数</p> 
<p>步骤：</p> 
<p>（1）读取前100个数字，建立最大值堆。（这里采用堆排序将空间复杂度讲得很低，要排序1亿个数，但一次性只需读取100个数字，或者设置其他基数，不需要1次性读完所有数据，降低对内存要求）</p> 
<p>（2）依次读取余下的数，与最大值堆作比较，维持最大值堆。可以每次读取的数量为一个磁盘页面，将每个页面的数据依次进堆比较，这样节省IO时间。</p> 
<p>（3）将堆进行排序，即可得到100个有序最大值。</p> 
<p>堆排序是一种常见的算法，但了解其的使用场景能够帮助我们更好的理解它。</p> 
<h4>c、较为通用的分治策略</h4> 
<p>分治策略师对常见复杂问题的一种万能的解决方法，虽然很多情况下，分治策略的解法都不是最优解，但是其通用性很强。分治法的核心就是将一个复杂的问题通过分解抽象成若干个简单的问题。</p> 
<p>应用场景：10G的数据，在2G内存的单台机器上排序的算法</p> 
<p>我的想法，这个场景既没有介绍数据是否有重复，也没有给出数据的范围，也不是求最大的个数。而通过分治虽然可能需要的io次数很多，但是对解决这个问题还是具有一定的可行性的。</p> 
<p>步骤：</p> 
<p>（1）从大数据中抽取样本，将需要排序的数据切分为多个样本数大致相等的区间，例如：1-100，101-300…</p> 
<p>（2）将大数据文件切分为多个小数据文件，这里要考虑IO次数和硬件资源问题，例如可将小数据文件数设定为1G（要预留内存给执行时的程序使用）</p> 
<p>（3）使用最优的算法对小数据文件的数据进行排序，将排序结果按照步骤1划分的区间进行存储</p> 
<p>（4）对各个数据区间内的排序结果文件进行处理，最终每个区间得到一个排序结果的文件</p> 
<p>（5）将各个区间的排序结果合并。通过分治将大数据变成小数据进行处理，再合并。</p> 
<p> </p> 
<h2>54.排序：</h2> 
<p>参考：<a href="https://blog.csdn.net/Dby_freedom/article/details/82154869">https://blog.csdn.net/Dby_freedom/article/details/82154869</a></p> 
<p><img alt="" src="https://images2.imgbox.com/99/d7/EvIP7Q2Y_o.png"></p> 
<h3>（1）冒泡排序：</h3> 
<p>时间复杂度为O（n2）,空间复杂度为O(1) 。第一次把最大的冒泡到右边，第二次把第二大的冒泡到右边。</p> 
<pre><code class="language-python">def bubble_sort(lst):
    for j in range(len(lst)-1,0,-1):  #每一次冒泡把最大的移到j的位置，一共n-1次
        for i in range(j):  #i不包括j的位置，i+1可以到j
            if lst[i]&gt;lst[i+1]:
                lst[i],lst[i+1]=lst[i+1],lst[i]
    return lst

lst=[3,2,1,4,5,6]
print(bubble_sort(lst))</code></pre> 
<h3>（2）归并排序：</h3> 
<pre><code class="language-python">def merge_sort(lst):
    if(len(lst) &lt;= 1):
        return lst
    left = merge_sort(lst[:len(lst)//2])
    right = merge_sort(lst[len(lst)//2:len(lst)])
    result = []
    while len(left) &gt; 0 and len(right)&gt; 0:
        if( left[0] &gt; right[0]):
            result.append(right.pop(0))
        else:
            result.append(left.pop(0))

    if(len(left)&gt;0):
        result.extend(merge_sort(left))
    else:
        result.extend(merge_sort(right))
    return result</code></pre> 
<h3>（3）插入排序：</h3> 
<p>（把<strong>未排序部分</strong>的<strong>第一个元素</strong>插入到<strong>排序部分</strong>合理的位置）</p> 
<p><img alt="" src="https://images2.imgbox.com/6c/72/xMOLUqv0_o.gif"></p> 
<pre><code class="language-python">def insert_sort(ary):
	for i in range(1, len(ary)):
		key = i - 1
		mark = ary[i]    # 注： 必须将ary[i]赋值为mark，不能直接用ary[i]
		while key &gt;= 0 and ary[key] &gt; mark:
			ary[key+1] = ary[key]
			key -= 1
		ary[key+1] = mark
	return ary
</code></pre> 
<h3><span style="color:#f33b45;">（4）希尔排序（不稳定）：</span></h3> 
<pre><code class="language-python">
def shell_sort(ary):
    count = len(ary)
    gap = round(count / 2)
    # 双杠用于整除（向下取整），在python直接用 “/” 得到的永远是浮点数，
    # 用round()得到四舍五入值
    while gap &gt;= 1:
        for i in range(gap, count):
            temp = ary[i]
            j = i
            while j - gap &gt;= 0 and ary[j - gap] &gt; temp:  # 到这里与插入排序一样了
                ary[j] = ary[j - gap]
                j -= gap
            ary[j] = temp
        gap = round(gap / 2)
    return ary

</code></pre> 
<h3><span style="color:#f33b45;">（5）堆排序（不稳定）：</span></h3> 
<p>将待排序的序列构成一个大顶堆,这个时候整个序列的最大值就是堆顶的根节点,将它与末尾节点进行交换,然后末尾变成了最大值,然后剩余n-1个元素重新构成一个堆,这样得到这n个元素的次大值,反复进行以上操作便得到一个有序序列。</p> 
<pre><code class="language-python">def heap_sort(ary):
	n = len(ary)
	first = int(n/2-1)    #最后一个非叶子节点
	for start in range(first,-1,-1):    #构建最大堆
		max_heapify(ary,start,n-1)
	for end in range(n-1,0,-1):    #堆排，将最大跟堆转换成有序数组
		ary[end],ary[0] = ary[0], ary[end]    #将根节点元素与最后叶子节点进行互换，取出最大根节点元素，对剩余节点重新构建最大堆
		max_heapify(ary,0,end-1)    #因为end上面取的是n-1，故而这里直接放end-1，相当于忽略了最后最大根节点元素ary[n-1]
	return ary


#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点
#start为当前需要调整最大堆的位置，end为调整边界
def max_heapify(ary,start,end):
	root = start
	while True:
		child = root * 2 + 1    #调整节点的子节点
		if child &gt; end:
			break
		if child + 1 &lt;= end and ary[child] &lt; ary[child+1]:
			child = child + 1   #取较大的子节点
		if ary[root] &lt; ary[child]:    #较大的子节点成为父节点
			ary[root], ary[child] = ary[child], ary[root]    #交换
			root = child
		else:
			break</code></pre> 
<h3><span style="color:#f33b45;">（6）选择排序（不稳定）：</span></h3> 
<p>把<strong>未排序部分</strong>最小的（min）移动到<strong>排序部分</strong>的结尾。</p> 
<p>（选择和冒泡有点像，都是把挑选出<strong>未排序部分</strong>的极值，移动到<strong>排序部分。</strong></p> 
<p>但是冒泡排序用的是冒泡的方式；选择排序用的是选择（逐一比较）的方式）</p> 
<pre><code class="language-python">def select_sort(lst):
    n = len(lst)
    for i in range(0,n):
        min = i                             #最小元素下标标记
        for j in range(i+1,n):
            if lst[j] &lt; lst[min] :
                min = j                     #找到最小值的下标
        lst[min],lst[i] = lst[i],lst[min]   #交换两者
    return lst</code></pre> 
<h3><span style="color:#f33b45;">（7）快速排序（不稳定）：</span></h3> 
<pre><code class="language-python">def quick_sort(lst, start, end):
    if start&gt;=end:
        return lst
    left=start
    right=end
    mid=lst[left]  #两个边界start、end，两个指针left、right；一个比较值mid
    while left&lt;right:
        #右边比mid小的，和mid索引交换（此时mid索引为left）;右边小于等于mid的，移动游标
        while left&lt;right and mid &lt;=lst[right]:
            right-=1
        lst[left],lst[right]=lst[right],lst[left]
        #左边比mid大的移到右边，和mid索引换（此时mid索引为right）
        while left&lt;right and mid&gt;=lst[left]:
            left+=1
        lst[left],lst[right]=lst[right],lst[left]
    #把mid索引重置为起始索引
    mid=lst[left]
    #对mid左右两部分分别快排，mid不要再包含进去
    #不用再次切片，函数后两个参数就是切片
    quick_sort(lst,start,left)
    quick_sort(lst,left+1,end)
    return lst</code></pre> 
<h3>（8）top-K问题的解法：</h3> 
<h4>a、局部淘汰法 -- 借助“冒泡排序”获取TopK</h4> 
<p><strong>思路：</strong>（1）可以避免对所有数据进行排序，只排序部分；（2）冒泡排序是每一轮排序都会获得一个最大值，则K轮排序即可获得TopK。</p> 
<p><strong>时间复杂度空间复杂度：</strong>（1）时间复杂度：排序一轮是O(N)，则K次排序总时间复杂度为：O(KN)。（2）空间复杂度：O(K)，用来存放获得的topK，也可以O(1)遍历原数组的最后K个元素即可。</p> 
<h4>b、局部淘汰法 --"堆排序"获取TopK</h4> 
<p><strong>思路：</strong>（1）堆：分为大顶堆（堆顶元素大于其他所有元素）和小顶堆（堆顶其他元素小于所有其他元素）。（2）我们使用小顶堆来实现。（3）取出K个元素放在另外的数组中，对这K个元素进行建堆。（4）然后循环从K下标位置遍历数据，只要元素大于堆顶，我们就将堆顶赋值为该元素，然后重新调整为小顶堆。（5）循环完毕后，K个元素的堆数组就是我们所需要的TopK。</p> 
<p><strong>时间复杂度与空间复杂度：</strong>（1）时间复杂度：每次对K个元素进行建堆，时间复杂度为：O(KlogK)，加上N-K次的循环，则总时间复杂度为O((K+(N-K))logK)，即O(NlogK)，其中K为想要获取的TopK的数量N为总数据量。（2）空间复杂度：O(K)，只需要新建一个K大小的数组用来存储topK即可。</p> 
<h4>c、分治法 -- 借助”快速排序“方法获取TopK</h4> 
<p><strong>思路：</strong>（1）比如有10亿的数据，找处Top1000，我们先将10亿的数据分成1000份，每份100万条数据。（2）在每一份中找出对应的Top 1000，整合到一个数组中，得到100万条数据，这样过滤掉了999%%的数据。（3）使用快速排序对这100万条数据进行”一轮“排序，一轮排序之后指针的位置指向的数字假设为S，会将数组分为两部分，一部分大于S记作Si，一部分小于S记作Sj。（4）如果Si元素个数大于1000，我们对Si数组再进行一轮排序，再次将Si分成了Si和Sj。如果Si的元素小于1000，则我们需要在Sj中获取1000-count(Si)个元素的，也就是对Sj进行排序（5）如此递归下去即可获得TopK。</p> 
<p><strong>时间复杂度与空间复杂度：</strong>（1）时间复杂度：一份获取前TopK的时间复杂度：O((N/n)logK)。则所有份数为：O(NlogK)，但是分治法我们会使用多核多机的资源，比如我们有S个线程同时处理。则时间复杂度为：O((N/S)logK)。之后进行快排序，一次的时间复杂度为：O(N),假设排序了M次之后得到结果，则时间复杂度为：O(MN)。所以 ，总时间复杂度大约为O(MN+(N/S)logK) 。（2）空间复杂度：需要每一份一个数组，则空间复杂度为O(N)。</p> 
<h3> </h3> 
<h2>55、哈希表：</h2> 
<p><strong>Hash函数</strong>就是根据<strong>key</strong>计算出应该存储地址的位置<strong>id/index</strong>（就可得到<strong>value</strong>），而哈希表是基于哈希函数建立的一种查找表。</p> 
<pre><code class="language-python">class HashTable:
    def __init__(self, size):
        self.elem = [None for i in range(size)]  # 使用list数据结构作为哈希表元素保存方法
        self.count = size  # 最大表长
 
    def hash(self, key):
        return key % self.count  # 散列函数采用除留余数法
 
    def insert_hash(self, key, value):
        """插入关键字到哈希表内"""
        address = self.hash(key)  # 求散列地址
        while self.elem[address]:  # 当前位置已经有数据了，发生冲突。
            address = (address + 1) % self.count  # 线性探测下一地址是否可用
        self.elem[address] = value  # 没有冲突则直接保存。
 
    def search_hash(self, key):
        """查找关键字，返回布尔值"""
        star = address = self.hash(key)
        while self.elem[address] != key:
            address = (address + 1) % self.count
            if not self.elem[address] or address == star:  # 说明没找到或者循环到了开始的位置
                return False
        return True
 </code></pre> 
<h3>解决哈希冲突：</h3> 
<h4>a）开放定址法（用探查序列再搞一次）</h4> 
<p>为产生冲突的地址<img alt="" src="https://images2.imgbox.com/e7/77/L7SYV2nN_o.png">求得一个地址序列<img alt="" src="https://images2.imgbox.com/79/29/JqHCgOLC_o.png">(<img alt="" src="https://images2.imgbox.com/8f/97/Dx6xTSIy_o.png">),其中<img alt="" src="https://images2.imgbox.com/c0/b8/OkL7iKBL_o.png">。其中m为表的长度,而增量<img alt="" src="https://images2.imgbox.com/ec/fc/rhxtm7DQ_o.png">有三种取值方法,根据三种探查序列划分：线性探测再散列,平方探测再散列,随即探测再散列。</p> 
<h4>b）链地址法（冲突时建立链表）</h4> 
<p>将所有Hash地址相同的记录都链接在同一链表中。</p> 
<h4>c）再Hash法（再哈希一次，直到不产生冲突）</h4> 
<p>同时构造多个不同的Hash函数,当产生冲突时,计算另一个Hash函数地址直到不再发生冲突为止。</p> 
<h4>d）建立公共溢出区</h4> 
<p>将Hash表分为基本表和溢出表,若是与基本表发生冲突,都放入溢出表。</p> 
<p> </p> 
<h2>56. 大顶堆怎么插入删除？</h2> 
<h4>插入:</h4> 
<p>在一个大顶堆之后插入新的元素可能会破坏堆的结构,此时需要找到新插入节点的父节点,对堆进行自下而上的调整使其变成一个大顶堆。</p> 
<h4>删除:</h4> 
<p>将堆的最后一个元素填充到删除元素的位置,然后调整堆结构构造出新的大顶堆</p> 
<p> </p> 
<h2>57.堆栈区别？</h2> 
<h4>一、空间分配区别：</h4> 
<p>1）栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。（类）</p> 
<p>2）堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。（实例）</p> 
<h4>二、缓存方式区别：</h4> 
<p>1）栈使用的是一级缓存，他们通常都是被调用时处于存储空间中，调用完毕立即释放；</p> 
<p>2）堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p> 
<p>堆：内存中，存储的是引用数据类型，引用数据类型无法确定大小，堆实际上是一个在内存中使用到内存中零散空间的链表结构的存储空间，堆的大小由引用类型的大小直接决定，引用类型的大小的变化直接影响到堆的变化</p> 
<p>栈：是内存中存储值类型的，大小为2M，超出则会报错，内存溢出</p> 
<h4>三、数据结构区别：</h4> 
<p>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；</p> 
<p>栈（数据结构）：一种先进后出的数据结构。特点：先进后出，吃了吐。</p> 
<p> </p> 
<h2>58.栈溢出有哪些情况？</h2> 
<p>1）局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。</p> 
<p>2）递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</p> 
<p>3）指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</p> 
<p> </p> 
<h2>59.递归和动态规划的异同：</h2> 
<p>用递归能解决的问题，一般都可以用动态规划来解决。</p> 
<h4>递归：</h4> 
<p><span style="color:#f33b45;">自顶向下</span>，先解决大问题，再把大问题分解成小问题解决。</p> 
<p>缺点：会重复计算相同的问题，相当耗时。</p> 
<p>优点：不会记录每个问题的结果，所以内存消耗相对小。</p> 
<h4>动态规划：</h4> 
<p><span style="color:#f33b45;">自下向上</span>，先解决小问题，再合并为解决大问题。</p> 
<p>缺点：会记录每一个问题的结果，内存消耗较大。</p> 
<p>优点：不会计算相同问题，时间消耗较小。</p> 
<p> </p> 
<h2>60.列表、元组、集合、字典：</h2> 
<p><img alt="" height="311" src="https://images2.imgbox.com/2e/fc/OkF4TjDk_o.png" width="865"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1da690ffd21fdb5088e6f6188fd1b9de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ASP.NET Core SignalR.NET 客户端</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/167ce1a079f19a66c4bbfced805c44cf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android Sdk Manager not found 解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>