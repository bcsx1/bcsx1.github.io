<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ消息队列实战（3）—— RabbitMQ中消息的可靠性传输和确认机制 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RabbitMQ消息队列实战（3）—— RabbitMQ中消息的可靠性传输和确认机制" />
<meta property="og:description" content="有过网络编程的经历，或者了解TCP协议的童鞋都知道：TCP协议通过它的ack机制（应答机制）保证了TCP包传输的可靠性，在面试中必问的TCP连接的三次握手和四次挥手就是对该知识点的考验。我们也知道，RabbitMQ是建立在AMQP协议之上的，这个应用层的协议为了保证消息传递的可靠性，也借鉴了TCP的这种思想，构成了自己一套消息ACK机制。
AMQP的ACK实际上包含了两个方面：第一个是在生产者端，当消息到达了指定的交换机，进行一次确认；另外一个是在消费端，消息从队列到了消费者，消费者进行自动或者手动ack。
但是从应用层面上来讲，在确保消息的可靠性这方面，单单靠RabbitMQ的应答机制，还远远不能满足需求。让我们来看下，一个消息从产生到消费的过程中要经过什么环节：
（1）生产者连接RabbitMQ代理
（2）生产者发布消息到交换机
（3）交换机路由消息到队列
（4）消费者连接RabbitMQ代理
（5）消费者从队列获取到消息
上面5个环节中，无论哪个环节出错，导致的最终结果就是生产者发送的消息无法发送到消费者，也就无法完成业务。遇到这种情况，最简单的解决方案就是把出错的消息持久化到数据库中，然后使用定时任务定时轮询去发送，如果超过一定的次数，人工进行介入。这也是在下文中笔者的处理思路。不过本文旨在说明处理方法，不会细化到实现保存出错消息的代码。下面，我们就来分别学习下，针对上述5中不同的场景下出错时，在代码中怎样感知，并进行处理。
一、生产者或者消费者连接不到RabbitMQ代理
首先，我们将上述5个环节中的第1个和第4个环节进行了合并，因为本质上都是由于RabbitMQ的代理发生了宕机或者通信问题，导致生产者或者消费者连接不到服务器所致。
此时，会在我们会在代码中捕获到两种异常：IOException和TimeoutException，IOException是在RabbitMQ的服务器宕机时抛出，而TimeoutException是由于通信原因或者其它原因，连接RabbitMQ服务器超时时抛出，不管是哪种，我们都能在代码中捕获到，并进行下一步的处理：
代码片段1-1：
ConnectionFactory factory = new ConnectionFactory(); factory.setHost(this.rabbitMqHost); factory.setPort(this.rabbitMqPort); factory.setConnectionTimeout(this.rabbitMqTimeOut); factory.setUsername(this.rabbitMqUsername); factory.setPassword(this.rabbitMqPassword); factory.setVirtualHost(&#34;/&#34;); Connection connection = null; Channel channel = null; try { try { connection = factory.newConnection(); channel = connection.createChannel(); channel.exchangeDeclare(&#34;direct-exchange&#34;, &#34;direct&#34;, true, false, null); channel.queueDeclare(&#34;test-queue&#34;, true, false, false, null); com.rabbitmq.client.AMQP.Queue.BindOk ok = channel.queueBind(&#34;test-queue&#34;, &#34;direct-exchange&#34;, &#34;test-queue&#34;); channel.basicPublish(&#34;1direct-exchange&#34;, &#34;test-queue&#34;, null, msg.getBytes(&#34;UTF-8&#34;)); } catch (IOException e) { System.out.println(&#34;服务器拒绝连接。&#34;); e.printStackTrace(); saveToDB(msg); } catch (TimeoutException e) { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/33fd7f0503a9dbf54fc20ad71b4196ef/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-06T22:15:00+08:00" />
<meta property="article:modified_time" content="2023-03-06T22:15:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ消息队列实战（3）—— RabbitMQ中消息的可靠性传输和确认机制</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 有过网络编程的经历，或者了解TCP协议的童鞋都知道：TCP协议通过它的ack机制（应答机制）保证了TCP包传输的可靠性，在面试中必问的TCP连接的三次握手和四次挥手就是对该知识点的考验。我们也知道，RabbitMQ是建立在AMQP协议之上的，这个应用层的协议为了保证消息传递的可靠性，也借鉴了TCP的这种思想，构成了自己一套消息ACK机制。</span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> AMQP的ACK实际上包含了两个方面：第一个是在生产者端，当消息到达了指定的交换机，进行一次确认；另外一个是在消费端，消息从队列到了消费者，消费者进行自动或者手动ack。</span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 但是从应用层面上来讲，在确保消息的可靠性这方面，单单靠RabbitMQ的应答机制，还远远不能满足需求。让我们来看下，一个消息从产生到消费的过程中要经过什么环节：</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">（1）生产者连接RabbitMQ代理</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">（2）生产者发布消息到交换机</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">（3）交换机路由消息到队列</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">（4）消费者连接RabbitMQ代理</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">（5）消费者从队列获取到消息</span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">上面5个环节中，无论哪个环节出错，导致的最终结果就是生产者发送的消息无法发送到消费者，也就无法完成业务。遇到这种情况，最简单的解决方案就是把出错的消息持久化到数据库中，然后使用定时任务定时轮询去发送，如果超过一定的次数，人工进行介入。这也是在下文中笔者的处理思路。不过本文旨在说明处理方法，不会细化到实现保存出错消息的代码。下面，我们就来分别学习下，针对上述5中不同的场景下出错时，在代码中怎样感知，并进行处理。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:15pt;"><span class="kdocs-bold" style="font-weight:bold;">一、生产者或者消费者连接不到RabbitMQ代理</span></span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 首先，我们将上述5个环节中的第1个和第4个环节进行了合并，因为本质上都是由于RabbitMQ的代理发生了宕机或者通信问题，导致生产者或者消费者连接不到服务器所致。</span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">此时，会在我们会在代码中捕获到两种异常：IOException和TimeoutException，IOException是在RabbitMQ的服务器宕机时抛出，而TimeoutException是由于通信原因或者其它原因，连接RabbitMQ服务器超时时抛出，不管是哪种，我们都能在代码中捕获到，并进行下一步的处理：</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">代码片段1-1：</span></span></p> 
 <pre class="kdocs-java"><code class="language-java">ConnectionFactory factory = new ConnectionFactory();
    factory.setHost(this.rabbitMqHost);
    factory.setPort(this.rabbitMqPort);
    factory.setConnectionTimeout(this.rabbitMqTimeOut);
    factory.setUsername(this.rabbitMqUsername);
    factory.setPassword(this.rabbitMqPassword);
    factory.setVirtualHost("/");
    Connection connection = null;
    Channel channel = null;
    try {
        try {
            connection = factory.newConnection();
            channel = connection.createChannel();
            channel.exchangeDeclare("direct-exchange", "direct", true, false, null);
            channel.queueDeclare("test-queue", true, false, false, null);
            com.rabbitmq.client.AMQP.Queue.BindOk ok = channel.queueBind("test-queue", "direct-exchange", "test-queue");
            channel.basicPublish("1direct-exchange", "test-queue", null, msg.getBytes("UTF-8"));
        } catch (IOException e) {
            System.out.println("服务器拒绝连接。");
            e.printStackTrace();
            saveToDB(msg);
        } catch (TimeoutException e) {
            System.out.println("连接服务器超时。");
            e.printStackTrace();
            saveToDB(msg);
        }
    } finally {
        closeChanelAndConnection(connection, channel);
    }</code></pre> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:9pt;">saveToDB就是我们用来将消息保存到数据库中的方法，这里只是为了演示，并未真正实现；</span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">closeChanelAndConnection()用来关闭Connnect和Channel资源，其代码如下：</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">代码片段1-2：</span></span></p> 
 <pre class="kdocs-java"><code class="language-java">private void closeChanelAndConnection(Connection connection, Channel channel) {
    if (channel != null &amp;&amp; channel.isOpen()) {
        try {
            channel.close();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }
    if (connection != null &amp;&amp; connection.isOpen()) {
        try {
            connection.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:15pt;"><span class="kdocs-bold" style="font-weight:bold;">二、生产者消息发送到交换机</span></span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">在上文发送消息的代码片段中，我们先创建了交换机、队列并进行了绑定，然后在第17行进行消息的发送。但是如果在第17行代码执行之前，目标交换机被删除或者干脆第17代码写的交换机的名称错误，要发送到的交换机根本不存在。此时RabbitMQ的客户端会抛出一个</span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">ShutdownSignalException类型的异常，我们可以在这个异常处理里面进行同样错误消息的持久化：</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">代码片段2-1：</span></span></p> 
 <pre class="kdocs-java"><code class="language-java">catch (ShutdownSignalException e) {
    System.out.println("交换机故障或者不存在。");
    e.printStackTrace();
    saveToDB(msg);
}</code></pre> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">这是最简单的处理交换机不存在的方法。</span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">正常情况，下生产者客户端向交换机发送消息之后，采用的是发后即忘的方式。也就是说，消息发送后，不管消息有没有到达，生产者都不会管，也不会重试。但是现在我们也需要实现：确保消息一定到达了交换机，没有到达则持久化消息。要实现这一功能，则需要开启通道的手动confirm功能，并且有三种方案：</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">方案一，消息逐条阻塞confirm</span></span></p></li></ul> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">请看下面的代码片段：</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 第7行：开启channel的确认模式</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 第11行：调用channel.waitForConfirms()方法，阻塞等待通道确认的消息。这个方法会阻塞当前的线程，它的返回结果是一个boolean值，true代表成功将消息发布到交换机，false代表消息没有发布到交换机，在这里我们还是把它存储到数据库中。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">代码片段2-2:</span></span></p> 
 <pre class="kdocs-java"><code class="language-java">try {
    connection = factory.newConnection();
    channel = connection.createChannel();
    channel.exchangeDeclare("direct-exchange", "direct", true, false, null);
    channel.queueDeclare("test-queue", true, false, false, null);
    com.rabbitmq.client.AMQP.Queue.BindOk ok = channel.queueBind("test-queue", "direct-exchange", "test-queue");
    channel.confirmSelect();
    for (int i = 0; i &lt; 10; i++) {
        String newMsg = msg + i;
        channel.basicPublish("direct-exchange", "test-queue", null, newMsg.getBytes("UTF-8"));
        if (channel.waitForConfirms()) {
            System.out.println("发送成功");
        } else {
            System.out.println("消息发送失败");
            saveToDB(newMsg);
        }
    }
} </code></pre> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">方案二，消息批量阻塞confirm</span></span></p></li></ul> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">上述进行消息确认的过程，由于是逐条阻塞等待，势必影响消息发送的效率，RabbitMQ还提供了另外一种批量确认的方式，以加快通道confirm模式下消息的处理效率：</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">代码片段2-3:</span></span></p> 
 <pre class="kdocs-java"><code class="language-java">try {
    connection = factory.newConnection();
    channel = connection.createChannel();
    channel.exchangeDeclare("direct-exchange", "direct", true, false, null);
    channel.queueDeclare("test-queue", true, false, false, null);
    com.rabbitmq.client.AMQP.Queue.BindOk ok = channel.queueBind("test-queue", "direct-exchange", "test-queue");
    channel.confirmSelect();
    for (int i = 0; i &lt; 10; i++) {
        String newMsg = msg + i;
        channel.basicPublish("direct-exchange", "test-queue", null, newMsg.getBytes("UTF-8"));
    }
    channel.waitForConfirmsOrDie();
} </code></pre> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">第10行就是我们调用waitForConfirmsOrDie方法，等待批量的消息确认，在此模式下发送消息的效率的确提高了，但是结果是我们没有办法处理失败的消息，因为无从知道哪些消息发送失败了。</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">方案三，异步方式confirm</span></span></p></li></ul> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;"> </span>仅仅批量方式阻塞confirm对于RabbitMQ的吞吐量要求来说，还是远远不够的，为了更进一步提升效率，RabbitMQ还支持异步Confirm的方式。这种异步方式，要求先创建一个确认信息的监听器：</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">代码片段2-4:</span></span></p> 
 <pre class="kdocs-java"><code class="language-java">public class MyConfirmListener implements ConfirmListener {

    private Map&lt;Long, String&gt; msgMap;

    public MyConfirmListener(Map&lt;Long, String&gt; msgMap) {
        this.msgMap = msgMap;
    }

    @Override
    public void handleAck(long deliveryTag, boolean multiple) throws IOException {
        System.out.println("发送的消息得到了回应");
        System.out.println("ack: deliveryTag = " + deliveryTag + " multiple: " + multiple);
    }

    @Override
    public void handleNack(long deliveryTag, boolean multiple) throws IOException {
        System.out.println("发送的消息没有得到回应");
        System.out.println("nack: deliveryTag = " + deliveryTag + " multiple: " + multiple);
        if (msgMap != null &amp;&amp; msgMap.containsKey(deliveryTag)) {
            saveToDB(msgMap.get(deliveryTag));
        }
    }
    private void saveToDB(String msg) {
        System.out.println("消息保存到数据库成功:" + msg);
    }
}</code></pre> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">可以看到，监听器主要实现了两个方法handleAck和handleNack，这里要先解释下ack和nack的区别：在正常情况下，当RabbitMQ接收到消息后会返回一个ack消息。但是当由于RabbitMQ内存出现错误，它没有接受到消息或是接受到不完整消息时，它会返回一个nack消息。handleAck和handleNack就是用来处理这两种消息的。</span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">handleAck和handleNack具有两个参数，一个参数是deliveryTag，信道在设置成confirm模式后，每个信道会对其发送的消息进行计数，deliveryTag就是计数的数值。deliveryTag也可以理解为消息ID，针对每个通道来说，它是唯一的。第3行的msgMap就是用来存储deliveryTag和消息的对应关系，而如果一旦接受到了nack消息，就可以通过这个编号获取到消息，并保存到数据库中（第19~21行）。multiple是指是否是批量确认的消息，比如deliveryTag是10，而multiple是true的话，表明deliveryTag10之前的消息全部批量confirm完成。</span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 完成了监听器的定义，接下来就需要在发送时使用，使用的代码如下：</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">代码片段2-5:</span></span></p> 
 <pre class="kdocs-java"><code class="language-java">try {
    connection = factory.newConnection();
    channel = connection.createChannel();
    channel.exchangeDeclare("direct-exchange", "direct", true, false, null);
    channel.queueDeclare("test-queue", true, false, false, null);
    com.rabbitmq.client.AMQP.Queue.BindOk ok = channel.queueBind("test-queue", "direct-exchange", "test-queue");
    channel.confirmSelect();
    HashMap&lt;Long, String&gt; map = new HashMap(32);
    for (int i = 0; i &lt; 10; i++) {
        String newMsg = msg + i;
        channel.basicPublish("direct-exchange", "test-queue", null, newMsg.getBytes("UTF-8"));
        map.put((long) (i + 1), newMsg);
    }
    channel.addConfirmListener(new MyConfirmListener(map));
} </code></pre> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">与批量阻塞的方式确认消息相比，异步确认的方式在性能上具有大的提升，而且还支持错误消息的处理。其实 channel.addConfirmListener方法（第14行），除了接受一个ConfirmListener类型的参数之外，还有另外一个方法，可以接受两个ConfirmCallback参数：</span></p> 
 <pre class="kdocs-java"><code class="language-java">ConfirmListener addConfirmListener(ConfirmCallback var1, ConfirmCallback var2);</code></pre> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 其本质只不过是使用时定义两个ConfirmCallback类，分别处理ack和nack消息，其内部实现其实也是调用了addConfirmListener(ConfirmListener var1)方法，这可以通过查看其源码看到：</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">代码片段2-6:</span></span></p> 
 <pre class="kdocs-java"><code class="language-java">public ConfirmListener addConfirmListener(final ConfirmCallback ackCallback, final ConfirmCallback nackCallback) {
    ConfirmListener confirmListener = new ConfirmListener() {
        public void handleAck(long deliveryTag, boolean multiple) throws IOException {
            ackCallback.handle(deliveryTag, multiple);
        }

        public void handleNack(long deliveryTag, boolean multiple) throws IOException {
            nackCallback.handle(deliveryTag, multiple);
        }
    };
    this.addConfirmListener(confirmListener);
    return confirmListener;
}</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:15pt;"><span class="kdocs-bold" style="font-weight:bold;">三、交换机消息路由到队列</span></span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 想要弄清楚消息由交换机到队列的的可靠性传输的机制，我们先要看下basicPublish方法完整的定义：</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">代码片段3-1:</span></span></p> 
 <pre class="kdocs-java"><code class="language-java">public void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body) throws IOException;</code></pre> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">在上文的代码中，我们只用了basicPublish包含四个参数的重载的版本，在代码片段3-1中的版本中多了两个参数：mandatory和immediate。</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">mandatory为true时，如果exchange根据自身类型和消息routeKey无法找到一个符合条件的queue时，那么会调用basic.return方法将消息返还给生产者；为false时，出现上述情形broker会直接将消息扔掉。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">immediate为true时，如果exchange在将消息route到queue(s)时发现对应的queue上没有消费者，那么这条消息不会放入队列中。为false时，出现上述情形，broker会直接将消息扔掉。</span></p></li></ul> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 显然我们之前一直用的四个参数的basicPublish，mandatory和immediate默认值都是false，也就是说一旦交换机找不到目标队列，那么它会把消息给抛弃。而即使所有的队列都没有消费者订阅，消息也会存放到队列中。所以在使用默认的basicPublish和mandatory下，我们是无法确认消息已经准确路由到队列的。如果要达到这个目的，首先要使用basicPublish的全参数版本，而且mandatory设置为true，immediate设置为默认值false即可。</span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 在采用了上述全参数版本的basicPublish之后，我们想要接收到交换机返回来的消息，还需要自定义一个ReturnListener，用来监听消息返回的事件：</span></p> 
 <pre class="kdocs-java"><code class="language-java">public class MyReturnListener implements ReturnListener {
    @Override
    public void handleReturn(int replyCode, String replyText,
                             String exchange, String routingKey,
                             AMQP.BasicProperties properties, byte[] body) throws IOException {
        System.out.println("以下消息不可达");
        System.out.println("replyCode: " + replyCode);
        System.out.println("replyText: " + replyText);
        System.out.println("exchange: " + exchange);
        System.out.println("routingKey: " + routingKey);
        System.out.println("properties: " + properties);
        System.out.println("body: " + new String(body));
    }
}</code></pre> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">ReturnListener中的handleReturn方法就是用来处理返回消息的回调方法，我们先看下，它的几个参数：</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">replyCode —— 在消息被返回时，为返回原因定义的错误码</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">replyText —— 返回原因的描述</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">exchange —— 交换机名称</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">routingKey —— 路由键</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">properties —— 消息附带的属性</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">body —— 消息内容</span></p></li></ul> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 自定义完成返回消息的监听器之后，就可以使用它来监听交换机返回的消息了，完整的发送代码如下：</span></p> 
 <pre class="kdocs-java"><code class="language-java">try {
    try {
        connection = factory.newConnection();
        channel = connection.createChannel();
        channel.exchangeDeclare("direct-exchange", "direct", true, false, null);
        channel.queueDeclare("test-queue", true, false, false, null);
        com.rabbitmq.client.AMQP.Queue.BindOk ok = channel.queueBind("test-queue", "direct-exchange", "test-queue");
        channel.basicPublish("direct-exchange", "test-queue1", true, false, MessageProperties.PERSISTENT_BASIC, msg.getBytes("UTF-8"));
        channel.addReturnListener(new MyReturnListener());
    } catch (IOException e) {
        System.out.println("服务器拒绝连接。");
        e.printStackTrace();
        saveToDB(msg);
    } catch (TimeoutException e) {
        System.out.println("连接服务器超时。");
        e.printStackTrace();
        saveToDB(msg);
    } catch (ShutdownSignalException e) {
        System.out.println("交换机故障或者不存在。");
        e.printStackTrace();
        saveToDB(msg);
    }
} </code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 第8行：在使用basicPublish时，第3个参数mandatory设置为了true</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 第9行：将自定义的监听器添加到了channel</span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 完成了上述的设置之后，如果不出意外，当我们发送消息，如果消息不能到达目标的队列，消息就会被返回，程序就会打印类似下面的提示：</span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1230px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:22.195122%;height:0;"> 
    <img src="https://images2.imgbox.com/86/c9/Dcoaxcli_o.png" style="margin-left:;display:block;width:1230px;margin-top:-22.195122%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">同样的，和addConfirmListener方法类似，addReturnListener也有一个接受ReturnCallback类型参数的版本，它实际上在内部也是使用了自定义的ReturnListener，如下所示：</span></p> 
 <pre class="kdocs-java"><code class="language-java">public ReturnListener addReturnListener(ReturnCallback returnCallback) {
    ReturnListener returnListener = (replyCode, replyText, exchange, routingKey, properties, body) -&gt; {
        returnCallback.handle(new Return(replyCode, replyText, exchange, routingKey, properties, body));
    };
    this.addReturnListener(returnListener);
    return returnListener;
}</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:15pt;"><span class="kdocs-bold" style="font-weight:bold;">四、消息发送到消费者</span></span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">上文中，我们介绍了生产者端几个关键环节的消息的确认或者返还机制。接下来，再学习下消费者端消息的确认机制。我们先来看下，消费者处理消息的方式有哪些：</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">订阅并消费消息</span></p></li></ul> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">这是最常用的一个api，主要用来订阅队列上的消息并进行消费，如果有多个消费者订阅了同一个队列，默认采用轮询的方式分别发送给某一个消费者。它还有其它几个重载版本，但是大同小异，感兴趣的童鞋可以去专门研究下。</span></p> 
 <pre class="kdocs-java"><code class="language-java">String basicConsume(String queue, boolean autoAck, Consumer callback) throws IOException ；</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">queue —— 队列名称。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">autoAck —— 是否自动确认，默认是true，消息者在接受到消息后马上就会进行自动的ack；如果是false，则需要我们调用channel.basicAck手动进行ack</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">callback —— 装配的Consumer对象用来处理消息。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">返回值 —— 返回值是consumerTag，为每个消费者都定义了一个唯一的consumerTag，如果需要取消消息订阅需要用到consumerTag。</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">取消订阅消息</span></p></li></ul> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 取消对队列的订阅，取消之后消费者不再获取该队列中的消息。</span></p> 
 <pre class="kdocs-java"><code class="language-java">void basicCancel(String consumerTag) throws IOException;</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">consumerTag —— basicConsume返回的basicConsume</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">主动获取消息</span></p></li></ul> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">并不建议使用这种主动获取消息的方式来读取消息，实际上在basicGet内部所调用的是rabbitmq获取消息的get命令，而这个get命令内部又包含了订阅消息和取消订阅两个过程，也就是说每一次get，都伴随着订阅和取消订阅两个过程，造成了极大的资源浪费。笔者在工作过程中就看到过有开发人员在一个while循环里面用的get方法来获取消息，造成的结果就是占用了大量的CPU，队列一直处于running状态。</span></p> 
 <pre class="kdocs-java"><code class="language-java">GetResponse basicGet(String queue, boolean autoAck) throws IOException;</code></pre> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">queue —— 队列名称。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">autoAck —— 是否自动确认，默认是true，消息者在接受到消息后马上就会进行自动的ack；如果是false，则需要我们调用channel.basicAck手动进行ack</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">手动确认消息</span></p></li></ul> 
 <pre class="kdocs-java"><code class="language-java"> void basicAck(long deliveryTag, boolean multiple) throws IOException；</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">deliveryTag—— 每个通道投递消息的计数，从1开始递增</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">multiple——是否是批量处理，如果是true，消费者在确认时会等待若干消息一起确认。</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">手动拒绝单个消息</span></p></li></ul> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">使用basicReject可以手动拒绝消息，拒绝后的消息可以选择销毁，也可以选择放回到原来的队列中。但是需要注意，如果消息返回到了原来的队列，在只有这一个消费者的情况下，可能会造成无限循环发送和拒绝。</span></p> 
 <pre class="kdocs-java"><code class="language-java">void basicReject(long deliveryTag, boolean requeue) throws IOException</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">deliveryTag—— 每个通道投递消息的计数，从1开始递增</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">requeue —— 是否将消息返回到原队列，true是是，false是否。</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">手动拒绝批量消息</span></p></li></ul> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 使用basicNack可以进行批量消息的拒绝。</span></p> 
 <pre class="kdocs-java"><code class="language-java">void basicNack(long deliveryTag, boolean multiple, boolean requeue) throws IOException;</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">deliveryTag—— 每个通道投递消息的计数，从1开始递增</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">multiple——是否是批量处理，如果是true，消费者在确认时会等待若干消息一起拒绝。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">requeue —— 是否将消息返回到原队列，true是是，false是否。</span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"> 要使用手动的ack，第1步，我们需要在消费者中手动调用basicAck进行确认，如下代码中第26行：</span></p> 
 <pre class="kdocs-java"><code class="language-java">public class TestConsumer implements Consumer {
    Channel channel = null;
    public TestConsumer(Channel channel) {
        this.channel = channel;
    }
    /**
     * create by: Hyman
     * description: 成功接受到消息后调用该方法
     * create time: 2021/7/6
     */
    @Override
    public void handleConsumeOk(String consumerTag) {
        System.out.println(consumerTag);
    }
    /* 其它方法 */
    /**
     * create by: Hyman
     * description: 处理消息的方法
     * create time: 2021/7/6
     */
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties basicProperties, byte[] bytes) throws IOException {
        String str = new String(bytes);
        Long deliveryTag = envelope.getDeliveryTag();
        System.out.println("TestConsumer —— 接受到的字符串是：" + str + ",deliveryTag是:" + deliveryTag);
        channel.basicAck(deliveryTag, true);
    }
}</code></pre> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:9pt;">第2步，是在使用basicConsume时设置第2个参数autoAck为false</span></p> 
 <pre class="kdocs-java"><code class="language-java">Consumer consumer = new TestConsumer(channel);
String consumerTag = channel.basicConsume("test-queue", false, consumer);</code></pre> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">有的朋友可能会有疑问？RabbitMQ中消费者手动ack有什么用，用自动ack不是挺好的吗？试想一下这种场景：假设消费者在处理消息时由于业务非常复杂，处理的效率很低。如果我们进行手动ack，则完全可以做到先处理好业务，最后再去ack，这样在业务处理时，由于上一个消息没有ack，即使队列中有新消息，broker也不会再发送给当前的消费者。这就避免了自动ack时，大量消息堆积到消费者的内存中造成内存的急剧膨胀，甚至最后内存溢出。而且在多个消费者订阅同一个队列时，手动ack还可以做到只把消息发送给闲置的消费者，增加整体消息的处理效率。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:15pt;"><span class="kdocs-bold" style="font-weight:bold;">五、关于RabbitMQ的事务</span></span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">因为在介绍RabbitMQ的可靠性传输，这里有必要提一下RabbitMQ的事务。在RabbitMQ中有自己的事务机制，可以通过下面的方法使用事务：</span></p> 
 <pre class="kdocs-java"><code class="language-java">channel.txSelect();//开启事务
//发送多个消息
channel.txCommit();//提交事务</code></pre> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">RabbitMQ事务保证的是在开启事务后发送的多条消息一定能够到达broker，一旦其中有消息没有到达，那么该条消息之后的所有消息就不会再发送了，而且前面的消息也会被回滚。</span><span class="kdocs-fontSize" style="font-size:16pt;">但是，</span><span class="kdocs-fontSize" style="font-size:9pt;">这里要划重点，<span class="kdocs-bold" style="font-weight:bold;">RabbitMQ事务性能很差，开启事务之后会降低2~10倍的吞吐量。</span></span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">所以，基本上不会在实际中使用RabbitMQ事务。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:15pt;"><span class="kdocs-bold" style="font-weight:bold;">六、总结：</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">（1）生产者或者消费者可以捕获IOException 和TimeoutException 来处理连接不到broker的问题，暂时将消息持久化到数据库，然后利用定时任务重试发送。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">（2）生产者可以捕获ShutdownSignalException异常来处理找不到交换机的问题。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">（3）消息从生产者到交换机可以进行手动的confirm，confirm的方式有三种：单个消息阻塞confirm、批量消息阻塞confirm和异步confirm（ConfirmListener），异步confirm消息的处理效率最高</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">（4）可以设置消息找不到队列时，交换机将消息返回给生产者，生产者通过添加ReturnListener实例的方式监听返回消息的事件</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">（5）消费者在获取消息时可以自动ack，也可以手动ack，在消费者处理消息耗时很长的业务场景中，建议使用手动ack。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">（6）RabbitMQ有自己的事务，可以保证多条消息一起到达broker或者回滚，但是使用其的性能很低，在实际中基本不会使用。</span></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b02708d82923befad81cd79f54169be/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PageHelper 使用不当引发的 SQL 出现两个 limit</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f3a6695f9886be9dbbefba4ee562ab9d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Kafka】一文详解零拷贝原理……</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>