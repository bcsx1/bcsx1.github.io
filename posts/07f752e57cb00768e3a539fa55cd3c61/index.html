<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux下搭建iSCSI共享存储的方法 Linux-IO Target 方式CentOS7-1810下实现 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux下搭建iSCSI共享存储的方法 Linux-IO Target 方式CentOS7-1810下实现" />
<meta property="og:description" content="iSCSI（internet SCSI）技术由IBM公司研究开发，是一个供硬件设备使用的、可以在IP协议的上层运行的SCSI指令集，这种指令集合可以实现在IP网络上运行SCSI协议，使其能够在诸如高速千兆以太网上进行路由选择。iSCSI技术是一种新储存技术，该技术是将现有SCSI接口与以太网络(Ethernet)技术结合，使服务器可与使用IP网络的储存装置互相交换资料。
iSCSI分为服务端和客户端，服务端需要安装scsi target用来共享存储设备，客户端需要安装iscsi initiator用来连接target端，将target端共享的设备挂载到initiator本地，可以对其进行分区，格式化等操作
一、iSCSI实现数据的访问需要的条件：
1、iSCSI客户端具有的特性：
iSCSI initiator是发起I/O操作的启动者；需要通过发现过程请求远端快设备；可以与target进行持久连接；在Linux系统中可以使用iscsi-initiator-utils软件包来模拟实现；
2、iSCSI服务器端具有的特性：
iSCSI target是I/O操作的执行者；需要导出一个或多个块设备供启动者（initiator）使用；在Linux系统中可以使用两种target工具，分别为tgt，和targetcli，这里先介绍TGT的方法，TGT是Fujita Tomonori于2006年底将SCSI Target Framework (STGT/TGT) 引入Linux内核。它在内核中有一个库，可协助内核控制目标驱动程序，TGT是用户态实现的iscsi target，所有目标处理都在用户空间进行。在2010年底，LIO(Linux-IO)项目被选择来代替TGT作为内核态实现的iscsi target。当选择LIO替换TGT时，它的实现已经进行了调整，以允许TGT用户空态模块继续运行，因此TGT社区支持在内核中包含LIO。在Linux内核 2.6.38 之前都是TGT。
3、iSCSI 命名规则
iSCSI 使用全球唯一的名称标识 iSCSI 设备（目标或启动器）。此名称类似于与光纤通道设备相关联的全球名称 (WWN)，可作为一种通用的设备识别方式使用。
iSCSI 名称有两种不同格式。第一种是通过iSCSI限定名以 iqn.开头通常称为“IQN 名称”。第二种是通过企业唯一标识符，以eui.开头也称为“EUI 名称”，此方法不常用。
有关 iSCSI 命名要求和字符串配置文件的更多详细信息，请参见 IETF 网站上的 RFC 3721 和 RFC 3722。
iSCSI 限定名
iSCSI 限定名采用 iqn.yyyy-mm.naming-authority:unique name 的形式，其中：
yyyy-mm ：
表示“年份-月份“，是公司成立的年份和月份，这里的公司一般为安装软件的这个公司，当然了可以随意选个时间
naming-authority ：
通常是公司的 Internet 域名的逆转格式。例如，pipci 公司的 iSCSI 限定名形式可能是 iqn.2018-01.cc.pipci.iscsi。此名称表示 pipci.cc域名于 2018 年 1 月注册，iscsi 是pipci.cc的子域，子域名可有可无。
unique name：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/07f752e57cb00768e3a539fa55cd3c61/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-25T23:48:13+08:00" />
<meta property="article:modified_time" content="2020-03-25T23:48:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux下搭建iSCSI共享存储的方法 Linux-IO Target 方式CentOS7-1810下实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>iSCSI（internet SCSI）技术由IBM公司研究开发，是一个供硬件设备使用的、可以在IP协议的上层运行的SCSI指令集，这种指令集合可以实现在IP网络上运行SCSI协议，使其能够在诸如高速千兆以太网上进行路由选择。iSCSI技术是一种新储存技术，该技术是将现有SCSI接口与以太网络(Ethernet)技术结合，使服务器可与使用IP网络的储存装置互相交换资料。</p> 
<p>iSCSI分为服务端和客户端，服务端需要安装scsi target用来共享存储设备，客户端需要安装iscsi initiator用来连接target端，将target端共享的设备挂载到initiator本地，可以对其进行分区，格式化等操作</p> 
<p><img alt="" src="https://images2.imgbox.com/39/1a/dnxqsdau_o.png"></p> 
<p> </p> 
<p><img alt="" src="https://images2.imgbox.com/6e/1b/e2eslOUs_o.png"></p> 
<p><strong>一、iSCSI实现数据的访问需要的条件：</strong></p> 
<p><strong>1、iSCSI客户端具有的特性：</strong><br> iSCSI initiator是发起I/O操作的启动者；需要通过发现过程请求远端快设备；可以与target进行持久连接；在Linux系统中可以使用iscsi-initiator-utils软件包来模拟实现；</p> 
<p><strong>2、iSCSI服务器端具有的特性：</strong><br> iSCSI target是I/O操作的执行者；需要导出一个或多个块设备供启动者（initiator）使用；在Linux系统中可以使用两种target工具，分别为tgt，和targetcli，这里先介绍TGT的方法，TGT是Fujita Tomonori于2006年底将SCSI Target Framework (STGT/TGT) 引入Linux内核。它在内核中有一个库，可协助内核控制目标驱动程序，TGT是用户态实现的iscsi target，所有目标处理都在用户空间进行。在2010年底，LIO(Linux-IO)项目被选择来代替TGT作为内核态实现的iscsi target。当选择LIO替换TGT时，它的实现已经进行了调整，以允许TGT用户空态模块继续运行，因此TGT社区支持在内核中包含LIO。在Linux内核 2.6.38 之前都是TGT。</p> 
<p><strong>3、iSCSI 命名规则</strong><br> iSCSI 使用全球唯一的名称标识 iSCSI 设备（目标或启动器）。此名称类似于与光纤通道设备相关联的全球名称 (WWN)，可作为一种通用的设备识别方式使用。<br> iSCSI 名称有两种不同格式。第一种是通过iSCSI限定名以 iqn.开头通常称为“IQN 名称”。第二种是通过企业唯一标识符，以eui.开头也称为“EUI 名称”，此方法不常用。<br> 有关 iSCSI 命名要求和字符串配置文件的更多详细信息，请参见 IETF 网站上的 RFC 3721 和 RFC 3722。</p> 
<p>iSCSI 限定名<br> iSCSI 限定名采用 iqn.yyyy-mm.naming-authority:unique name 的形式，其中：<br> yyyy-mm ：<br> 表示“年份-月份“，是公司成立的年份和月份，这里的公司一般为安装软件的这个公司，当然了可以随意选个时间</p> 
<p>naming-authority ：<br> 通常是公司的 Internet 域名的逆转格式。例如，pipci 公司的 iSCSI 限定名形式可能是 iqn.2018-01.cc.pipci.iscsi。此名称表示 pipci.cc域名于 2018 年 1 月注册，iscsi 是pipci.cc的子域，子域名可有可无。</p> 
<p>unique name：<br> 是希望使用的任何名称，如主机的名称或sn号。必须确保在冒号后面分配的任何名称都是唯一的，例如：<br><br> iqn.2018-01.cc.pipci.iscsi:host1<br> iqn.2018-01.cc.pipci.iscsi:name1<br> iqn.2018-01.cc.pipci.iscsi:sn1999</p> 
<p>企业唯一标识符<br> 企业唯一标识符采用 eui.&lt;16 hex digits&gt; 的形式。<br> 例如，eui.0123456789ABCDEF。<br> 16 位十六进制数字是 IEEE EUI（扩展唯一标识符）格式的 64 位数的文本表示形式。前 24 位是 IEEE 向特定公 司注册的公司 ID。后 40 位由持有该公司 ID 的实体分配，并且必须是唯一的。 在许多情况下，人们都会选择 IQN 格式，而不是 EUI 格式，因为 IQN 格式方便阅读，并且是一种更友好的名 称分配方式。</p> 
<p><br><strong>二、iSCSI initiator发现iSCSI target的过程：</strong></p> 
<p>ISCSI initiator按照配置文件/etc/iscsi/iscsid.conf中配置的相应项目利用iSCSI的发现机制在网络中收索目标设备target<br> ISCSI target将返回有效的iqn名称给iSCSI initiator<br> ISCSI target按照配置的验证方式接受initiator的登录并返回目标设备target标识<br> ISCSI initiator发生查询请求给target请求查询target的相关信息<br> target响应initiator的查询请求，并将设备的有关信息返回给initiator<br> initiator创建可以的目标设备target列表</p> 
<p><strong>三、iSCSI设备的特性：</strong></p> 
<p>支持ACL（访问控制列表）<br> 支持两种挑战握手协议CHAP（ChallengeHandshake Authentication Protocol）的认证方式<br> 支持多通道（multipath）<br> 支持sendtargets发现机制<br> 支持动态目标端发现<br> 具备异步事件通知入口<br> 支持即时数据更新<br> 支持动态设备重配<br> 支持自动挂接iSCSI技术<br> 支持IPV6技术</p> 
<p><strong>四、iSCSI设备名称</strong><br> iSCSI设备在iSCSI启动端（Initiator）导入的时候，其内核将按当前的设备情况给iSCSI设备分配一个本地SCSI设备名（例如/dev/sda或/dev/sdb等），如果导入的iSCSI设备已被分区，在导入iSCSI设备建立本地SCSI设备的同时也会建立相应的分区设备名（例如/dev/sda1、/dev/sda5等等），但要注意的是此SCSI设备名并不是每次导入是都是固定的，比如你的主机之前没有/dev/sda设备，你导入了iSCSI设备，其被内核命名为/dev/sda;之后你将其取消了导入，并重新挂接了一个热插拔设备（如U盘或移动硬盘），这个热插拔设备占据的/dev/sda设备；你又从新导入了iSCSI设备，此时其被内核分配的设备名就成了/dev/sdb。</p> 
<p><strong>五、为什么要搭建iSCSI共享存储，因为穷！！！，如果有钱最好的方法是买一台真正的存储，因为没钱还要做很多需要共享存储才能测试的功能，比如 Oracle RAC ，虚拟化的HA等都需要一台共享存储，下面将介绍通过Linux 软件来实现iscsi目标器，从而自己搭建一台iscsi存储，组建iscsi</strong></p> 
<p>六<strong>、Linux-IO简介</strong><br> Linux-IO Target在Linux内核中（linux 2.6.38后），用软件实现各种SCSI Target，其支持的SAN技术中所有流行的存储协议包括Fibre Channel（Qlogic，linux3.5）、FCoE（linux3.0）、iSCSI（linux 3.1）、iSER (Mellanox InfiniBand，linux3.10), SRP (Mellanox InfiniBand，linux3.3), USB等，同时还能为本机生成模拟的SCSI设备，以及为虚拟机提供基于virtio的SCSI设备。Linux-IO Target使用户能够使用相对廉价的Linux系统实现SCSI、SAN的各种功能，而不用购买昂贵的专业设备。</p> 
<p>1. 架构</p> 
<p><img alt="" src="https://images2.imgbox.com/7c/7c/NMR5rPDl_o.png"></p> 
<p> </p> 
<p> </p> 
<p><br> 上图显示了Linux-IO Target的各个组件。LIO模拟了通用的SCSI设备，并且实现了SPC-3和4。接着，通过各种各样的backstore对象，来导入真正的后端存储，最后连接上各种前端Fabric模块，来导出模拟的SCSI设备。无论是Fibre Channel、FCoE、iSCSI还是vhost（即virtio），都只是一种Fabric技术，我们可以将其理解成传输协议，而在这些传输协议中传输的SCSI命令则总是由核心的SCSI设备处理的。要支持新的Fabric技术，并不需要修改核心的SCSI设备和后端存储模块，只需要按照该Fabric技术的规范实现对SCSI命令的传输就可以了。iSCSI技术就是把SCSI命令放在TCP/IP中传输，vhost技术就是把SCSI命令放在virtio队列中传输。</p> 
<p>Generic Target Engine：实现了SAM中规定的一个SCSI target的功能，主要是SCSI协议的解析。它通过Fabric模块和initiator通信，通过backstore和具体的存储设备通信。Fabric modules：实现了LIO的前端，即SCSI协议传输层的模块。可以通过Fabric Hardware Abstraction Layer(F-HAL)来为LIO增加新的fabric模块。</p> 
<p>Backstores：实现了LIO的后端，即访问磁盘数据的方式。可以通过Storage Hardware Abstraction Layer（S-HAL）在LIO中增加新的存储硬件的支持。通常使用BLOCKIO和FILEIO。</p> 
<p><strong>2. 使用方法</strong></p> 
<p>Linux-IO Target则在内核态实现了对Target的模拟，配置管理则采用了更为“现代化”的基于sysfs的方式，提供了友好的用户态管理工具。从内核的2.6.38版起，Linux内核都包含Linux-IO Target的相关模块。在用户态，各大发行版都打包了targetcli和rtslib，其中targetcli程序用于配置、管理，rtslib则提供Python编程接口。</p> 
<p>以iSCSI为例，Linux-IO Target的配置结构如图1所示。处于最后端的是各种各样的Linux的存储设备。Linux-IO Target支持的后端存储设备包括Ramdisk、通用块设备和文件，也可以直接映射本地SCSI设备。Linux-IO Target通过创建backstore存储对象来导入这些存储设备。它可以使用各种SAN传输技术来导出这些存储对象。首先，基于某种SAN技术（例如iSCSI）创建一个Target。接着，在Target里创建一个TPG（Target Portal Group）。每个Target下可以创建多个TPG，每个TPG包含了一组入口（Portal）。然后在TPG里创建LUN，并将特定的存储对象与特定的LUN关联起来。最后在TPG里创建一个或者多个入口，对iSCSI来说，每个Portal就是一个IP地址和端口的组合。为了更精确的控制对LUN的访问，还可以在TPG之下创建各种ACL规则。</p> 
<p><br> targetcli<br> targetcli是Linux-IO Target的用户态的管理配置工具。用户可以使用yum或apt-get直接从各大发行版的官方仓库安装，对于较老的linux版本需要自己编译源码安装。targetcli提供一个类似shell的界面，各种Target、TPG、LUN、backstore对象则被组织成目录树的形式，用户可以用ls、cd命令来浏览目录树，用create、delete命令来创建和删除各种对象。浏览配置，就是浏览目录树，创建删除各种对象，就是在目录树的各级节点中创建新的节点。同时targetcli还提供了常见的shell命令辅助编辑功能，例如TAB智能补全、上下键切换命令历史、Ctrl + R搜索命令历史。凡是有不熟悉的命令，都可以用help命令查询使用说明。其实，对于我们来说，配置LIO主要就是使用targetcli</p> 
<p>rtslib<br> rtslib是一个Python程序库，让用户可以以编程的方式配置Linux-IO Target的各项功能。rtslib中的对象也被组织成树状结构，并且与我们在targetcli中熟悉的各种对象也很相似。熟悉了targetcli的操作之后，用rtslib编程就变得十分容易</p> 
<p><strong>七、安装配置工具targetcli</strong></p> 
<p>--------------------------------------------------<br> [root@CentOS7 ~]# yum -y install targetcli 　　　　　　 #安装软件</p> 
<p>[root@CentOS7 ~]# systemctl enable target.service 　　 #设置服务程序target开机启动，默认不启动，很重要<br> [root@CentOS7 ~]# systemctl start target.service 　　      #启动服务程序target，很重要</p> 
<p>--------------------------------------------------<br><strong>安装完targetcli将会生成/etc/target/saveconfig.json用于保存配置，在安装完程序后必须执行systemctl enable target.service设置服务程序target开机启动，同时启动这个服务。否则配置完的数据不能保存到/etc/target/saveconfig.json文件中，重启系统后进入targetcli命令后将不能看到上次创建的target配置</strong>。</p> 
<p><br><strong>八、关闭防火墙或开启TCP 3260 端口，LIO通过TCP的3260端口来进行数据的传输</strong></p> 
<p><strong>九、使用targetcli创建后端存储对象</strong><br> targetcli命令有两种模式，一种是交互式模式，一种是命令行模式。输入targetcli 回车就进入交互式模式，进入交互式模式可以使用ls,pwd,cd等命令<br> --------------------------------------------------<br><strong>1. targetcli初始提示</strong><br> [root@CentOS7 ~]# targetcli<br> Warning: Could not load preferences file /root/.targetcli/prefs.bin.<br> targetcli shell version 2.1.fb49<br> Copyright 2011-2013 by Datera, Inc and others.<br> For help on commands, type 'help'.</p> 
<p>/&gt;　　　　　　　　　　　　　　　　 #在这里按2次TAB键可以查看所有可用的命令，在每个目录下都可以通过这种方式查看可用的命令<br> * / @last backstores/ iscsi/ loopback/ vhost/ bookmarks<br> cd clearconfig exit get help ls pwd refresh<br> restoreconfig saveconfig sessions set status version<br> /&gt;</p> 
<p>--------------------------------------------------</p> 
<p><strong>2. 在交互模式下列出初始目录树，输入ls命令，targetcli便将当前的目录树输出</strong><br> --------------------------------------------------<br> /&gt; ls<br> o- / ................................................... [...]<br> 　　o- backstores ........................................ [...]<br> 　　| o- block ............................ [Storage Objects: 0]<br> 　　| o- fileio ............................. [Storage Objects: 0]<br> 　　| o- pscsi ............................. [Storage Objects: 0]<br> 　　| o- ramdisk .......................... [Storage Objects: 0]<br> 　　o- iscsi ................................................ [Targets: 0]<br> 　　o- loopback ........................................ [Targets: 0]<br> 　　o- vhost .............................................. [Targets: 0]<br> /&gt;<br> --------------------------------------------------</p> 
<p>命令行实现：<br> --------------------------------------------------<br> [root@CentOS7 ~]# targetcli ls<br> o- / ................................................... [...]<br> 　　o- backstores ........................................ [...] 　　　　   #用户配置后端存储目录，下面有4个子目录分别创建不同类型的存储资源<br> 　　| o- block ............................ [Storage Objects: 0] 　　  #配置块设备目录，可以是磁盘驱动器，分区，逻辑卷，多路径设备，只要块设备都可以<br> 　　| o- fileio ............................. [Storage Objects: 0]　　   #配置文件(镜像img)目录，根据一个事先准备的文件，提供存储功能<br> 　　| o- pscsi ............................. [Storage Objects: 0] 　　  #配置物理scsi设备目录，不推荐使用<br> 　　| o- ramdisk .......................... [Storage Objects: 0]　　 #配置内存存储目录，利用内存当做存储。<br> 　　o- iscsi .............................................. [Targets: 0] 　　   #配置iSCSI目标<br> 　　o- loopback ...................................... [Targets: 0]<br> 　　o- vhost ............................................ [Targets: 0]<br> [root@CentOS7 ~]#<br> --------------------------------------------------</p> 
<p><strong>2、创建物理磁盘结构作为target后端的物理存储（事先已经准备好了一个5G的磁盘做备用）</strong><br> --------------------------------------------------<br> [root@CentOS7 ~]# targetcli<br> Warning: Could not load preferences file /root/.targetcli/prefs.bin.<br> targetcli shell version 2.1.fb49<br> Copyright 2011-2013 by Datera, Inc and others.<br> For help on commands, type 'help'.</p> 
<p>/&gt; cd backstores/block　　　　　　　　　　　　     #进入block子目录来通过块设备创建target后端存储资源<br> /backstores/block&gt; create lun1 /dev/sdb 　  　　　 #通过create命令创建名字为lun1的存储资源<br> Created block storage object lun1 using /dev/sdb.</p> 
<p>/backstores/block&gt; ls　　　　　　　　　　　　　　 #查看创建的存储资源<br> o- block ............................................................... [Storage Objects: 1]<br> 　　o- lun1 ...................... [/dev/sdc (5.0GiB) write-thru deactivated] 　　　　 #新创建的<br> 　　　　o- alua ........................................................ [ALUA Groups: 1]<br> 　　　　　　o- default_tg_pt_gp ..... [ALUA state: Active/optimized]<br> /backstores/block&gt;<br> --------------------------------------------------</p> 
<p>命令行的实现:<br> [root@CentOS7 ~]# targetcli /backstores/block create name=lun1 dev=/dev/sdb</p> 
<p><br><strong>3、创建文件和内存作为target后端的物理存储</strong><br> --------------------------------------------------<br> /backstores&gt; cd fileio/ 　　　　　　　　　　　　　　     #进入fileio子目录来通过文件创建target后端存储资源<br> /backstores/fileio&gt; create lun1 /tmp/lun1.img　　　　 #/tmp/lun1.img文件的大小是你想用资源的大小，可以通过dd命令创建空文件<br> Created fileio lun1 with size 1073741824 #这个文件的大小是1G</p> 
<p>/backstores/fileio&gt; cd ../ramdisk　　　　       #进入ramdisk子目录来通过内存创建target后端存储资源<br> /backstores/ramdisk&gt; create rd0 10MB 　　 #使用10MB的内存空间创建名称为rd0的存储资源<br> Created ramdisk rd0 with size 10MB.<br> /backstores/ramdisk&gt;<br> --------------------------------------------------</p> 
<p>命令行的实现:<br> [root@CentOS7 ~]# targetcli /backstores/fileio create name=lun1 file_or_dev=/tmp/lun1.img<br> [root@CentOS7 ~]# targetcli /backstores/ramdisk create name=rd0 size=10MB</p> 
<p><br><strong>4、查看创建的存储资源</strong><br> --------------------------------------------------<br> /backstores&gt; ls<br> o- backstores ................................................................................ [...]<br> 　　o- block ....................................................... [Storage Objects: 1]<br> 　　|    o- lun1 ................. [/dev/sdc (5.0GiB) write-thru deactivated] 　　　　　       　#基于块的<br> 　　| 　　 o- alua .................................................... [ALUA Groups: 1]<br> 　　| 　　       o- default_tg_pt_gp ... [ALUA state: Active/optimized]<br> 　　o- fileio ................................................. [Storage Objects: 1　　]　　　　　　          #基于文件的<br> 　　|    o- lun1... . [/tmp/lun1.img (0 bytes) write-back deactivated]<br> 　　| 　　 o- alua .................................................... [ALUA Groups: 1]<br> 　　|               o- default_tg_pt_gp ..... [ALUA state: Active/optimized]<br> o- pscsi ................................................................ [Storage Objects: 0]<br> o- ramdisk ........................................................... [Storage Objects: 1]　　　　　　　　#基于内存的<br> 　　o- rd0 ..................................................... [(10.0MiB) deactivated]<br> 　　     o- alua .......................................................... [ALUA Groups: 1]<br> 　　　　o- default_tg_pt_gp ........... [ALUA state: Active/optimized]<br> --------------------------------------------------</p> 
<p><br><strong>5、删除刚才创建的存储资源以block/为例子，其他目录的一样</strong><br> --------------------------------------------------<br> /backstores&gt; cd block/　　　　　 　 #进入创建的子目录删除<br> /backstores/block&gt; delete 　 　 　　 #输入删除命令delete按两下TAB键，查看操作提示<br> lun1 name= 　　　　　　　　　　　 #delete命令后可以接的参数<br> /backstores/block&gt; delete lun1 　　 #delete命令后输入资源名直接回车删除<br> Deleted storage object lun1.<br> /backstores/block&gt; ls<br> o- block ................................ [Storage Objects: 0] 　　 #成功删除<br> /backstores/block&gt;<br> --------------------------------------------------</p> 
<p>命令行的实现:<br> [root@CentOS7 ~]# targetcli /backstores/block delete name=lun1</p> 
<p>可以创建fileio和ramdisk类型的backstore对象，还可以创建block和pscsi对象。block对象可以用来导入一般的块设备，比如/dev/hdaX、/dev/sdX、/dev/vgX/lvX等。pscsi对象可以用来导入系统里已有的SCSI设备（即lsscsi列出的设备），所有SAN的前端收到的SCSI命令都会透传到pscsi导入的设备。需要注意，Linux-IO Target所模拟的SCSI设备实现了SPC-2、SCP-3和SPC-4规范，也就是说Persistent Reservations (PRs)、Asymmetric Logical Unit Assignment (ALUA)和vStorage APIs for Array Integration (VAAI)等高端SCSI特性都有实现。但是主机上的现有SCSI设备则未必实现了SPC-4，因此在需要高端SCSI特性的场合，最好通过block对象来导入/dev/sdX这样的设备，而不是通过pscsi。</p> 
<p><strong>十、 使用targetcli创建iSCSI目标</strong></p> 
<p><strong>1、创建iSCSI目标</strong><br> --------------------------------------------------<br> /iscsi&gt; create 　　　　　　　　 #create命令后面如果不加任何参数会自动创建一个target同时iqn号也是随机的<br> Created target iqn.2003-01.org.linux-iscsi.debian.x8664:sn.aea77a8eef23.<br> Created TPG 1.<br> Global pref auto_add_default_portal=true<br> Created default portal listening on all IPs (0.0.0.0), port 3260.</p> 
<p>/iscsi&gt; delete iqn.2003-01.org.linux-iscsi.debian.x8664:sn.aea77a8eef23 　　   #删除这个随机的iqn<br> Deleted Target iqn.2003-01.org.linux-iscsi.debian.x8664:sn.aea77a8eef23.</p> 
<p>/iscsi&gt; create iqn.2019-10.cc.pipci.iscsi:debian.tgt1 　　　　　　　　　　　　 #创建一个方便记忆的iqn，但是要保证唯一性<br> Created target iqn.2019-10.cc.pipci.iscsi:debian.tgt1.<br> Created TPG 1.<br> Global pref auto_add_default_portal=true<br> Created default portal listening on all IPs (0.0.0.0), port 3260.</p> 
<p>/iscsi&gt; ls<br> o- iscsi ............................................................... [Targets: 1]<br>     o- iqn.2019-10.cc.pipci.iscsi:debian.tgt1 ........ [TPGs: 1] 　　#创建的target，以iqn名字的目录形式存在<br> 　　o- tpg1 .................................... [no-gen-acls, no-auth] 　　#同时创建子目录TPG<br>          o- acls ............................................................ [ACLs: 0] 　　#ACL（访问控制列表）控制子目录<br> 　　o- luns .......................................................... [LUNs: 0] 　 　#用于关联存储资源子目录<br> 　　o- portals ................................................... [Portals: 1] 　　#监听的端口资源<br> 　　     o- 0.0.0.0:3260 ................................................ [OK]<br> /iscsi&gt;<br> --------------------------------------------------</p> 
<p>命令行实现：<br> [root@CentOS7 ~]# targetcli /iscsi create iqn.2019-10.cc.pipci.iscsi:debian.tgt1　　 #创建<br> [root@CentOS7 ~]# targetcli /iscsi delete iqn.2019-10.cc.pipci.iscsi:debian.tgt1　　 #删除<br> --------------------------------------------------</p> 
<p><strong>2、关联后端存储资源</strong><br> --------------------------------------------------<br> /iscsi&gt; cd iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1/luns　　　　 #进入到关联子目录<br> /iscsi/iqn.20...gt1/tpg1/luns&gt; create /backstores/block/lun1 　  　 #通过命令create命令关联/backstores/block/lun1是上面创建的存储资源，要注意路径<br> Created LUN 0. 　　　　　　　　　　　　　　　　　　　　　　　 #默认创建lUN0<br> /iscsi/iqn.20...gt1/tpg1/luns&gt; ls　　　　　　　　　　　　　       　 #查看关联的存储资源<br> o- luns ..................................................................... [LUNs: 1]<br>      o- lun0 ..........[block/lun1 (/dev/sdc) (default_tg_pt_gp)] 　    　 #已经关联的存储资源<br><br> /iscsi/iqn.20...gt1/tpg1/luns&gt; delete 0 　　　　　　　　　　　   　 #解除关联，在delete后面直接输入LUN号就可以<br> Deleted LUN 0.<br> /iscsi/iqn.20...gt1/tpg1/luns&gt;<br> --------------------------------------------------</p> 
<p>命令实现：<br> 关联<br> [root@CentOS7 ~]# targetcli /iscsi/iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1/luns create /backstores/block/lun1<br> 解除关联<br> [root@CentOS7 ~]# targetcli /iscsi/iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1/luns delete 0</p> 
<p><strong>3、配置ACL（访问控制列表）</strong><br> ACL的作用是允许那些initiator可以访问target，target使用initiator的iqn来标识initiator。在ACL配置目录执行 set attribute generate_node_acls=0使用自定义的acl实现访问控制，则需要设置访问权限控制列表acl（默认就是这种），acl参数目录用于存放能够访问target端共享存储资源的initiator的iqn。在客户端访问时，只要iscsi客户端的iqn名称与服务端设置的访问控制列表中的iqn名称一致即可访问。如果不想使用ACL可以在ACL配置目录执行 set attribute generate_node_acls=1使用自动生成acl节点，这样不添加initiator的iqn也允许initiator访问。</p> 
<p>--------------------------------------------------<br> /iscsi/iqn.20...ian.tgt1/tpg1&gt; cd acls　　　　　　　　　　　　　　　　　　　　 #进入ACL配置目录<br> /iscsi/iqn.20...gt1/tpg1/acls&gt; create iqn.2019-10.cc.pipci.iscsi:clinet.sn8888 　　 #添加允许访问的iqn号<br> Created Node ACL for iqn.2019-10.cc.pipci.iscsi:clinet.sn8888<br> Created mapped LUN 0.<br> /iscsi/iqn.20...gt1/tpg1/acls&gt; ls 　　　　　　　　　　　　　　　　 #查看<br> o- acls ........................................................................... [ACLs: 1]<br>     o- iqn.2019-10.cc.pipci.iscsi:clinet.sn8888 [Mapped LUNs: 1] 　　 #允许访问的iqn<br> 　　o- mapped_lun0 ............................. [lun0 block/lun1 (rw)]<br><br> /iscsi/iqn.20...gt1/tpg1/acls&gt; delete iqn.2019-10.cc.pipci.iscsi:clinet.sn8888　　 #删除iqn<br> Deleted Node ACL iqn.2019-10.cc.pipci.iscsi:clinet.sn8888.<br> --------------------------------------------------</p> 
<p>配置自动生成acl节点</p> 
<p>--------------------------------------------------<br> /iscsi&gt; ls<br> o- iscsi .............................................................. [Targets: 1]<br>     o- iqn.2019-10.cc.pipci.iscsi:debian.tgt1 ........ [TPGs: 1]<br> 　　o- tpg1 .................................... [no-gen-acls, no-auth] 　　#no-gen-acls表示自定义的acl实现访问控制，默认值<br> 　　     o- acls ....................................................... [ACLs: 0]<br> 　　     o- luns .......................................................[LUNs: 1]<br> 　　     | o- lun0 ....[block/lun1 (/dev/sdc) (default_tg_pt_gp)]<br> 　　    o- portals ...................................................... [Portals: 1]<br> 　　　　o- 0.0.0.0:3260 .................................................... [OK]<br> /iscsi&gt;<br> /iscsi&gt; cd iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1/ 　　　　　      　 #必须进入TPG目录下才可以更改<br> /iscsi/iqn.20...ian.tgt1/tpg1&gt; set attribute generate_node_acls=1 　　 #配置成自动生成acl节点<br> Parameter generate_node_acls is now '1'.<br> /iscsi/iqn.20...ian.tgt1/tpg1&gt; ls<br> o- tpg1 ......................................... [gen-acls, no-auth] 　　 #修改成功<br> o- acls .......................................... [ACLs: 0]<br> o- luns .......................................... [LUNs: 1]<br> | o- lun0 ........[block/lun1 (/dev/sdc) (default_tg_pt_gp)]<br> o- portals .................................... [Portals: 1]<br> o- 0.0.0.0:3260 ..................................... [OK]<br> /iscsi/iqn.20...ian.tgt1/tpg1&gt;<br> --------------------------------------------------<br><strong>一旦配置成自动生成acl节点，当initiator认证成功后，再配置成自定义的acl实现访问控制是无效的 只有重启系统后恢复正常，我感觉这个是因为有认证记忆的功能</strong></p> 
<p>命令实现：<br> 添加iqn：<br> [root@CentOS7 ~]# targetcli /iscsi/iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1/acls create iqn.2019-10.cc.pipci.iscsi:clinet.sn8888<br> 删除iqn<br> [root@CentOS7 ~]# targetcli /iscsi/iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1/acls delete iqn.2019-10.cc.pipci.iscsi:clinet.sn8888<br> 配置自动生成acl节点<br> [root@CentOS7 ~]# targetcli /iscsi/iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1 set attribute generate_node_acls=1</p> 
<p><strong>4、设置target端的监听IP地址和端口号，以发现target</strong><br> 有的服务器可能有多块网卡，那么到底是那块网卡或IP地址对外提供共享资源哪，我们可以手动在portals参数目录里设置监听的IP地址和端口，默认是监听所有地址的。</p> 
<p>先删除默认的0.0.0.0这样不太安全<br> --------------------------------------------------<br> /iscsi/iqn.20...ian.tgt1/tpg1&gt; ls<br> o- tpg1 .................................. [gen-acls, no-auth]<br> 　　o- acls .......................................... [ACLs: 0]<br> 　　o- luns .......................................... [LUNs: 1]<br> 　　| o- lun0 ........[block/lun1 (/dev/sdc) (default_tg_pt_gp)]<br> 　　o- portals .................................... [Portals: 1]<br> 　　　　o- 0.0.0.0:3260 ..................................... [OK] 　　     #默认监听0.0.0.0也就是所有的IP地址，端口3260</p> 
<p>/iscsi/iqn.20...ian.tgt1/tpg1&gt; cd portals/　　　　　　　 　 #进入portals目录配置<br> /iscsi/iqn.20.../tpg1/portals&gt; delete 0.0.0.0 3260　　　　   #先删除 0.0.0.0地址，地址后面必须有端口号<br> Deleted network portal 0.0.0.0:3260<br> /iscsi/iqn.20.../tpg1/portals&gt;<br> --------------------------------------------------</p> 
<p>创建默认监听的端口<br> --------------------------------------------------<br> /iscsi/iqn.20.../tpg1/portals&gt; create 192.168.1.16<br> Using default IP port 3260 　　　　　　　　　　　　 # 如果上面的IP地址后面不加端口号会加上默认的3260，如果加端口在IP地址后面空格端口号就可以<br> Created network portal 192.168.1.16:3260.<br> /iscsi/iqn.20.../tpg1/portals&gt; ls<br> o- portals ...................................... [Portals: 1]<br> o- 192.168.1.16:3260 .................................. [OK] 　 　# 更改成功<br> /iscsi/iqn.20.../tpg1/portals&gt;<br> --------------------------------------------------</p> 
<p>命令实现：<br> 删除监听的IP<br> [root@CentOS7 ~]# targetcli /iscsi/iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1/portals delete 0.0.0.0 3260<br> 添加监听的IP和端口号，不加端口号使用默认的3260<br> [root@CentOS7 ~]# targetcli /iscsi/iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1/portals create 192.168.1.16 3260</p> 
<p><br><strong>十一、配置服务端 targetcli CHAP（质询握手身份验证协议） 认证</strong><br> 认证分为全局配置和局部配置<br> 在 /iscsi 下为全局配置。<br> 在 iscsi/iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1/ 下为单个Target的配置，配置只对单个IQN生效为局部配置</p> 
<p>全局配置下只能设置发现认证，局部配置只能设置登录认证，其中每种认证又分为单向认证和双向认证</p> 
<p>发现认证和登录认证的意思就和名字一样</p> 
<p>单向认证是指initiator端在发现target端的时候，要提供正确的认证才能发现在target端的iSCSI服务</p> 
<p>双向认证是指在单向认证的基础上，target端需要正确设置initiator端设置的认证才能被initiator端发现</p> 
<p>无论那种认证都是在target端配置的</p> 
<p><br><strong>十二、全局配置下的发现认证</strong></p> 
<p>1、单向认证（target服务器认证initiator）</p> 
<p>查看默认配置<br> --------------------------------------------------<br> /&gt; cd iscsi/　　　　　　　　　　　      　　　 #进入到iscsi/目录进行全局配置<br> /iscsi&gt; get discovery_auth　　　　　　　　 #查看发现认证状态<br> DISCOVERY_AUTH CONFIG GROUP<br> ===========================<br> enable=False 　　　　　　　　 #没有开启<br> -----------<br> The enable discovery_auth parameter.</p> 
<p>mutual_password= 　　　    　 #双向认真的密码<br> ----------------<br> The mutual_password discovery_auth parameter.</p> 
<p>mutual_userid= 　　　　　 　 #双向认真的用户名<br> --------------<br> The mutual_userid discovery_auth parameter.</p> 
<p>password= 　　　　　　　　   #单向认真的密码<br> ---------------<br> The password discovery_auth parameter.</p> 
<p>userid= 　　　　　　　　　　#单向认真的用户名<br> ------------<br> The userid discovery_auth parameter.</p> 
<p>--------------------------------------------------</p> 
<p>命令实现：<br> [root@CentOS7 ~]# targetcli /iscsi/ get discovery_auth 　　 #查看发现认证状态</p> 
<p><br> 配置用户名密码<br> --------------------------------------------------<br> /iscsi&gt; set discovery_auth enable=1 　　　　 #数字1表示开启0表示关闭<br> Parameter enable is now 'True'.<br> /iscsi&gt; set discovery_auth userid=laopi 　　 #添加用户laopi<br> Parameter userid is now 'laopi'.<br> /iscsi&gt; set discovery_auth password=pi1234　　 #设置认证密码pi1234<br> Parameter password is now 'pi1234'.<br> /iscsi&gt; get discovery_auth enable userid password<br> enable=True<br> userid=laopi<br> password=pi1234<br> /iscsi&gt;<br> --------------------------------------------------</p> 
<p>命令实现：<br> [root@CentOS7 ~]# targetcli /iscsi/ set discovery_auth enable=1　　　 　 　　  #数字1表示开启0表示关闭<br> [root@CentOS7 ~]# targetcli /iscsi/ set discovery_auth userid=laopi　    　　　  #添加用户laopi<br> [root@CentOS7 ~]# targetcli /iscsi/ set discovery_auth password=pi1234 　　   #设置认证密码pi1234</p> 
<p><strong>这时我们需要设置initiator端的配置文件/etc/iscsi/iscsid.conf，才能运行发现</strong><br> --------------------------------------------------<br> # *************<br> # CHAP Settings<br> # *************<br> .............</p> 
<p>discovery.sendtargets.auth.authmethod = CHAP #开启CHAP</p> 
<p># To set a discovery session CHAP username and password for the initiator<br> # authentication by the target(s), uncomment the following lines:<br> discovery.sendtargets.auth.username = laopi #添加用户名<br> discovery.sendtargets.auth.password = pi1234 #添加密码</p> 
<p>--------------------------------------------------</p> 
<p><strong>2、设置双向认证（必须建立在单向认证的基础上，因为在initiator登录的时候要先进行单项认证）</strong></p> 
<p>配置mutual用户名密码<br> --------------------------------------------------　　<br> /iscsi&gt; set discovery_auth mutual_userid=laopimal 　　　　 #添加mutual用户名<br> Parameter mutual_userid is now 'laopimal'.<br> /iscsi&gt; set discovery_auth mutual_password=pi123456 　　 #设置mutual用户名密码<br> Parameter mutual_password is now 'pi123456'.</p> 
<p>/iscsi&gt; get discovery_auth　　　　　　　　　　　　　　　　 #查看发现认证状态<br> DISCOVERY_AUTH CONFIG GROUP<br> ===========================<br> enable=True<br> -----------<br> The enable discovery_auth parameter.</p> 
<p>mutual_password=pi123456<br> ------------------------<br> The mutual_password discovery_auth parameter.</p> 
<p>mutual_userid=laopimal　　　　　　　　　　　　　　 #添加成功<br> ----------------------<br> The mutual_userid discovery_auth parameter.</p> 
<p>password=pi1234<br> ---------------<br> The password discovery_auth parameter.</p> 
<p>userid=laopi 　　　　　　　　　　　　　　　　　　　 #双向认证单项认证用户必须已经存在<br> ------------<br> The userid discovery_auth parameter.<br> --------------------------------------------------</p> 
<p>命令实现：<br> [root@CentOS7 ~]# targetcli /iscsi/ set discovery_auth mutual_userid=laopimal　　　　 #添加mutual用户名<br> [root@CentOS7 ~]# targetcli /iscsi/ set discovery_auth mutual_password=pi123456 　　  #设置mutual用户名密码<br> [root@CentOS7 ~]# targetcli /iscsi/ get discovery_auth #查看发现认证状态</p> 
<p><strong>这时我们需要设置initiator端的配置文件/etc/iscsi/iscsid.conf，才能运行发现</strong><br> --------------------------------------------------<br> # *************<br> # CHAP Settings<br> # *************<br> .............</p> 
<p>discovery.sendtargets.auth.authmethod = CHAP 　　     #开启CHAP</p> 
<p><br> discovery.sendtargets.auth.username = laopi　　　  　 #添加用户名<br> discovery.sendtargets.auth.password = pi1234　　　　 #添加密码</p> 
<p>discovery.sendtargets.auth.username_in = laopimal　　 #添加mutual用户名<br> discovery.sendtargets.auth.password_in = pi123456 　　#添加mutual用户名密码<br> --------------------------------------------------</p> 
<p><br><br><strong>十三、局部配置下的登录认证，这个我一直没实验成功，可能是没找到合适方法，待以后在深入研究吧</strong><br> --------------------------------------------------<br> 1、单向认证（target服务器认证initiator）</p> 
<p>/iscsi&gt; cd iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1/ 　　 　　  #局部认证要在target对应的iqn下配置<br> /iscsi/iqn.20...ian.tgt1/tpg1&gt;set attribute authentication=1 　　#开启账号密码验证访问控制，开启后无论initiator端是否成功设置都不能登录，默认是关闭，请不要开启，通过attribute authentication=0 关闭</p> 
<p>/iscsi/iqn.20...ian.tgt1/tpg1&gt; set auth userid=laopi 　　 　　　   #添加用户laopi<br> Parameter userid is now 'laopi'.<br> /iscsi/iqn.20...ian.tgt1/tpg1&gt; set auth password=pi1234 　　       #设置认证密码pi1234<br> Parameter password is now 'pi1234'.<br> /iscsi/iqn.20...ian.tgt1/tpg1&gt; get auth　　 　　　　　　　　　　 #查看登录证状态<br> AUTH CONFIG GROUP<br> =================<br> mutual_password=<br> ----------------<br> The mutual_password auth parameter.</p> 
<p>mutual_userid=<br> --------------<br> The mutual_userid auth parameter.</p> 
<p>password=pi1234<br> ---------------<br> The password auth parameter.</p> 
<p>userid=laopi<br> ------------<br> The userid auth parameter.<br> --------------------------------------------------</p> 
<p>命令实现：<br> 添加用户laopi<br> [root@CentOS7 ~]# targetcli /iscsi/iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1 set auth userid=laopi<br> 设置认证密码pi1234<br> [root@CentOS7 ~]# targetcli /iscsi/iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1 set auth password=pi1234<br> 查看登录认证状态<br> [root@CentOS7 ~]# targetcli /iscsi/iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1 get auth</p> 
<p>这时我们需要设置initiator端的配置文件/etc/iscsi/iscsid.conf，才能登录发现<br> --------------------------------------------------<br> # *************<br> # CHAP Settings<br> # *************<br> .............</p> 
<p>node.session.auth.authmethod = CHAP 　　       #开启CHAP</p> 
<p>node.session.auth.username = laopi　　　   　 #添加用户名<br> node.session.auth.password = pi1234 　　 　　#添加用户名密码<br> --------------------------------------------------</p> 
<p> </p> 
<p><strong>2、设置双向认证（必须建立在单向认证的基础上，因为在initiator登录的时候要先进行单项认证）</strong></p> 
<p>配置mutual用户名密码<br> --------------------------------------------------<br> /iscsi/iqn.20...ian.tgt1/tpg1&gt; set auth mutual_userid=laopimal 　　　　 #添加mutual用户名<br> Parameter mutual_userid is now 'laopimal'.<br> /iscsi/iqn.20...ian.tgt1/tpg1&gt; set auth mutual_password=pi123456   　　#设置mutual用户名密码<br> Parameter mutual_password is now 'pi123456'.<br> /iscsi/iqn.20...ian.tgt1/tpg1&gt; get auth<br> AUTH CONFIG GROUP<br> =================<br> mutual_password=pi123456<br> ------------------------<br> The mutual_password auth parameter.</p> 
<p>mutual_userid=laopimal<br> ----------------------<br> The mutual_userid auth parameter.</p> 
<p>password=pi1234<br> -----------------<br> The password auth parameter.</p> 
<p>userid=laopi 　　　　　　　　　　　　 #双向认证单项认证用户必须已经存在<br> --------------<br> The userid auth parameter.<br> --------------------------------------------------</p> 
<p>命令实现：<br> 添加用户laopimal<br> [root@CentOS7 ~]# targetcli /iscsi/iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1 set auth mutual_userid=laopimal<br> 设置认证密码pi123456<br> [root@CentOS7 ~]# targetcli /iscsi/iqn.2019-10.cc.pipci.iscsi:debian.tgt1/tpg1 set auth mutual_password=pi123456</p> 
<p>这时我们需要设置initiator端的配置文件/etc/iscsi/iscsid.conf，在能运行发现<br> --------------------------------------------------<br> # *************<br> # CHAP Settings<br> # *************<br> .............</p> 
<p>node.session.auth.authmethod = CHAP 　　　　 #开启CHAP</p> 
<p>node.session.auth.username = laopi　      　 　　 #添加用户名<br> node.session.auth.password = pi1234 　　　    　#添加用户名密码</p> 
<p>node.session.auth.username_in = laopimal 　　 #添加mutual用户名<br> node.session.auth.password_in = pi123456　　  #添加mutual用户密码</p> 
<p>--------------------------------------------------</p> 
<p><br><strong>十四、保持配置，重启生效</strong><br> 在交互模式下默认创建完配置exit退出时会主动将配置保存到配置文件/etc/rtslib-fb-target/saveconfig.json中，重启后生效<br> --------------------------------------------------<br> /&gt; ls<br> o-     / ................................................................................ [...]<br> 　　o- backstores ............................................................ [...]<br> 　　| o- block ........................................ [Storage Objects: 1]<br> 　　| | o- lun1 ....... [/dev/sdb (5.0GiB) write-thru activated]<br> 　　| o- fileio ......................................... [Storage Objects: 0]<br> 　　| o- pscsi ......................................... [Storage Objects: 0]<br> 　　| o- ramdisk ................................... [Storage Objects: 0]<br> 　　o- iscsi ......................................................... [Targets: 1]<br> 　　|    o- iqn.2019-10.cc.pipci.iscsi:debian.tgt1 ...... [TPGs: 1]<br> 　　| 　　 o- tpg1 ................................ [no-gen-acls, no-auth]<br> 　　| 　　　　 o- acls ................................................. [ACLs: 0]<br> 　　| 　　　　 o- luns ............................................... [LUNs: 1]<br> 　　|　　　　 | o- lun0 ....................... [block/lun1 (/dev/sdb)]<br> 　　| 　　　　 o- portals ........................................ [Portals: 1]<br> 　　| 　　　　　　 o- 0.0.0.0:3260 ................................... [OK]<br> 　　o- loopback .................................................... [Targets: 0]<br> 　　o- vhost ........................................................... [Targets: 0]<br> /&gt; exit<br> Global pref auto_save_on_exit=true 　　　　　　　　　　　   　 #提示全局配置下是推出自动保持配置。<br> Last 10 configs saved in /etc/rtslib-fb-target/backup.<br> Configuration saved to /etc/rtslib-fb-target/saveconfig.json　　 #提示已经保持配置<br> [root@CentOS7 ~]#<br> --------------------------------------------------<br> 上面的操作如果不是exit退出，而是Ctrl+C组合键提出，这样不会保持到配置文件中</p> 
<p>交互模式下手动保持配置和清楚配置<br> --------------------------------------------------<br> /&gt; saveconfig 　　　　　　　　　　　　　　　　　　　　　 　　　 #在交互模式的根目录下通过这个命令直接回车保持配置到默认配置文件<br> Last 10 configs saved in /etc/rtslib-fb-target/backup.<br> Configuration saved to /etc/rtslib-fb-target/saveconfig.json</p> 
<p>/&gt; saveconfig savefile=/tmp/lio.conf 　　　　　　　　　　　　　　 #我们也可以指定保存到其他文件，用于备份，这个文件不需要提前创建<br> Configuration saved to /tmp/lio.conf<br> /&gt;<br> /&gt; clearconfig confirm=true　　　　　　　　　　　　　　　　           #当我们想清楚所以配置可以通过这个命令完成<br> All configuration cleared<br> /&gt;</p> 
<p>--------------------------------------------------</p> 
<p>命令实现：<br> [root@CentOS7 ~]# targetcli saveconfig 　　　　　　　　　　  　　 #保存到默认文件<br> [root@CentOS7 ~]# targetcli saveconfig savefile=/tmp/lio.conf 　　 #保存到制定文件<br> [root@CentOS7 ~]# targetcli clearconfig confirm=true 　　　　　　 #这个不会清除配置文件中的配置，如果想清楚配置文件中的配置需要执行完这个操作才保存一次</p> 
<p> </p> 
<p><strong>十五、initiator客户端配置</strong></p> 
<p>这里就不介绍了前面的<a href="https://www.cnblogs.com/pipci/p/11617842.html" rel="nofollow" id="cb_post_title_url">Linux下搭建iSCSI共享存储的方法 TGT 方式 CentOS6.9系统下</a>里面有详细的使用方法</p> 
<p> </p> 
<p> </p> 
<p>参考资料：</p> 
<p><a href="https://wiki.archlinux.org/index.php/ISCSI_Target_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" rel="nofollow">https://wiki.archlinux.org/index.php/ISCSI_Target_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p> 
<p><a href="https://wiki.debian.org/SAN/iSCSI/LIO" rel="nofollow">https://wiki.debian.org/SAN/iSCSI/LIO</a></p> 
<p><a href="http://manpages.ubuntu.com/manpages/xenial/man8/targetcli.8.html" rel="nofollow">http://manpages.ubuntu.com/manpages/xenial/man8/targetcli.8.html</a></p> 
<p><a href="http://linux-iscsi.org/wiki/Targetcli" rel="nofollow">http://linux-iscsi.org/wiki/Targetcli</a></p> 
<p> <a href="https://www.holoem.com/?p=784" rel="nofollow">https://www.holoem.com/?p=784</a></p> 
<p><a href="http://www.mamicode.com/info-detail-2496160.html" rel="nofollow">http://www.mamicode.com/info-detail-2496160.html</a> </p> 
<p><a href="https://blog.csdn.net/weixin_42179528/article/details/90311361">https://blog.csdn.net/weixin_42179528/article/details/90311361</a></p> 
<p><a href="https://blog.51cto.com/zhuxu91313/2154819" rel="nofollow">https://blog.51cto.com/zhuxu91313/2154819</a></p> 
<p><a href="http://www.udpwork.com/item/13114.html" rel="nofollow">http://www.udpwork.com/item/13114.html</a></p> 
<p><a href="http://scst.sourceforge.net/comparison.html" rel="nofollow">http://scst.sourceforge.net/comparison.html</a></p> 
<p><a href="https://blog.csdn.net/u014106644/article/details/84565912">https://blog.csdn.net/u014106644/article/details/84565912</a></p> 
<p><a href="https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/linux_io_target%25e4%25bb%258b%25e7%25bb%258d_%25e4%25b8%2580?lang=en" rel="nofollow">https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/linux_io_target%25e4%25bb%258b%25e7%25bb%258d_%25e4%25b8%2580?lang=en</a> </p> 
<p> <a href="https://blog.csdn.net/zxlld/article/details/51829046">https://blog.csdn.net/zxlld/article/details/51829046</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8f451c034c724855b09a8037bfccba9f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Docker——1.起源</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/80bec7f6854d8baf0ddc7685390b8ff5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">anaconda下安装tensorflow过慢，导致安装失败</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>