<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#开发，.NET、C基础知识 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#开发，.NET、C基础知识" />
<meta property="og:description" content="转载地址：原文链接 https://www.cnblogs.com/Can-daydayup/p/8921990.html 前言： 学习是一个循序渐进的过程，作为一名.Net软件工程师我们需要学习和掌握的东西非常的多，本章主要是记录下前段时间面试中经常遇到的一些基础常识，这里只是大致的概括还有很多需要学习的东西需要不断的学习和积累。
访问修饰符：
public:公有访问，不受任何限制。
private:私有访问，只限于本类成员访问。
protected:受保护的，只限于本类和子类访问。
internal:内部访问，只限于本项目内访问，其他的不能访问
protected internal:内部保护访问，只限于本项目或是子类访问，其他的不能访问
枚举：
是由一组特定常量构成的一组数据结构，是值类型的一种特殊形式，当需要一个由指定常量集合组成的数据类型时，使用枚举类型。枚举声明可以显式地声明 byte、sbyte、short、ushort、int、uint、long 或 ulong 类型作为对应的基础类型。没有显式地声明基础类型的枚举声明意味着所对应的基础类型是 int，在代码中使用枚举，可以将以前笨拙的代码变得优雅简单，更加直观，方便记忆。
枚举在什么地方适用呢？
一条普遍规则是，任何使用常量的地方，例如目前用 switch 代码切换常量的地方。如果只有单独一个值（例如，鞋的最大尺寸，或者笼子中能装猴子的最大数目），则还是把这个任务留给常量吧。但是，如果定义了一组值，而这些值中的任何一个都可以用于特定的数据类型，那么将枚举用在这个地方最适合不过。
WebAPI 和 WebService的区别：
（https://blog.csdn.net/cysong168/article/details/51433986）webapi使用的是http协议，而webservices采用的是soap协议webapi是无状态的，相对于webserives更轻量级。webapi支持get，和post等http请求
http soap关系：
http是一个客户端和服务器端请求和应答的标准（TCP）。http协议其目的是为了提供一种发布和接收htttp页面的方法一http协议的客户端与服务器的交互：由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。soap 协议：它描述了一种在分散或分布式的环境中如何交换信息的轻量级协议。soap在http协议的基础上，一个基于XML的协议。
不同：都是底层的通信协议，请求包的格式不同而已，soap包是XML格式,http纯文本格式。
WCF和WEB API我该选择哪个？
1、当你想创建一个支持消息、消息队列、双工通信的服务时，你应该选择WCF
2、当你想创建一个服务，可以用更快速的传输通道时，像TCP、Named Pipes或者甚至是UDP（在WCF4.5中）,在其他传输通道不可用的时候也可以支持HTTP
3、当你想创建一个基于HTTP的面向资源的服务并且可以使用HTTP的全部特征时（比如URIs、request/response头，缓存，版本控制，多种内容格式），你应该选择Web API
4、当你想让你的服务用于浏览器、手机、iPhone和平板电脑时，你应该选择Web API
hashmap和hashTable的区别：
1.hashTable是Dictionary的子类，HashMap是Map接口的一个实现的类
2.Hashtable中的方法是同步的，而HashMap中的方法缺省情况为非同步
3.HashTabe不允许null值，而hashmap允许有null4.hashtable默认长度是11，增长方式是0ld*2&#43;1，而hashmap则默认是16，而且一定是2的指数
如何理解委托和事件？
委托相当于c或者c&#43;&#43;中的指针，委托能够把方法当做参数传递，并且提高程序的可扩展性。
事件：以一种特殊的委托
委托具有如下特点：
1.委托相当于c&#43;&#43;中的指针，但是他是安全类型
2.委托可以把方法当做参数传递
3.委托可以定义回调方法
4.委托可以链接在一起，例如:可以对多个事件调用多个方法
5.方法不需要与委托前面精确匹配
UDP连接和tcp连接的异同：
两者都可以实现远程通讯，而主要区别在于tcp需要保持连接，而Udp不需要，由此可以看出udp更高的效率和占用资源更少，但是tcp传输数据更可靠
.Net身份验证的方式有哪几种：
默认值为 Windows。 在Web.config 文件中，通过 节可以配置 ASP.NET 使用的安全身份验证模式，以标识传入的用户。 … 节的mode 为必选的属性。指定应用程序的默认身份验证模式。
此属性可以为下列值之一： Windows ：将 Windows 验证指定为默认的身份验证模式。将它与以下任意形式的 Microsoft Internet 信息服务 (IIS) 身份验证结合起来使用：基本、摘要、集成 Windows 身份验证 (NTLM/Kerberos) 或证书。在这种情况下，您的应用程序将身份验证责任委托给基础 IIS。 Forms ：将 ASP." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/0ae0cdd5e08bd5775ffb7d9a1ac6177f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-10T11:31:47+08:00" />
<meta property="article:modified_time" content="2023-07-10T11:31:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#开发，.NET、C基础知识</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_httpswwwcnblogscomCandaydayupp8921990htmlhttpswwwcnblogscomCandaydayupp8921990html_1"></a>转载地址：<a href="https://www.cnblogs.com/Can-daydayup/p/8921990.html" rel="nofollow">原文链接 https://www.cnblogs.com/Can-daydayup/p/8921990.html</a></h2> 
<h3><a id="_2"></a><strong>前言：</strong></h3> 
<p><strong>学习是一个循序渐进的过程，作为一名.Net软件工程师我们需要学习和掌握的东西非常的多，本章主要是记录下前段时间面试中经常遇到的一些基础常识，这里只是大致的概括还有很多需要学习的东西需要不断的学习和积累。</strong></p> 
<p><strong>访问修饰符：</strong><br> public:公有访问，不受任何限制。<br> private:私有访问，只限于本类成员访问。<br> protected:受保护的，只限于本类和子类访问。<br> internal:内部访问，只限于本项目内访问，其他的不能访问<br> protected internal:内部保护访问，只限于本项目或是子类访问，其他的不能访问</p> 
<p><strong>枚举：</strong></p> 
<p>是由一组特定常量构成的一组数据结构，是值类型的一种特殊形式，当需要一个由指定常量集合组成的数据类型时，使用枚举类型。枚举声明可以显式地声明 byte、sbyte、short、ushort、int、uint、long 或 ulong 类型作为对应的基础类型。没有显式地声明基础类型的枚举声明意味着所对应的基础类型是 int，在代码中使用枚举，可以将以前笨拙的代码变得优雅简单，更加直观，方便记忆。</p> 
<p><strong>枚举在什么地方适用呢？</strong></p> 
<p>一条普遍规则是，任何使用常量的地方，例如目前用 switch 代码切换常量的地方。如果只有单独一个值（例如，鞋的最大尺寸，或者笼子中能装猴子的最大数目），则还是把这个任务留给常量吧。但是，如果定义了一组值，而这些值中的任何一个都可以用于特定的数据类型，那么将枚举用在这个地方最适合不过。</p> 
<p><strong>WebAPI 和 WebService的区别：</strong></p> 
<p>（<a href="https://blog.csdn.net/cysong168/article/details/51433986">https://blog.csdn.net/cysong168/article/details/51433986</a>）webapi使用的是http协议，而webservices采用的是soap协议webapi是无状态的，相对于webserives更轻量级。webapi支持get，和post等http请求</p> 
<p><strong>http soap关系：</strong></p> 
<p>http是一个客户端和服务器端请求和应答的标准（TCP）。http协议其目的是为了提供一种发布和接收htttp页面的方法一http协议的客户端与服务器的交互：由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。soap 协议：它描述了一种在分散或分布式的环境中如何交换信息的轻量级协议。soap在http协议的基础上，一个基于XML的协议。</p> 
<p>不同：都是底层的通信协议，请求包的格式不同而已，soap包是XML格式,http纯文本格式。</p> 
<p><strong>WCF和WEB API我该选择哪个？</strong></p> 
<p>1、当你想创建一个支持消息、消息队列、双工通信的服务时，你应该选择WCF</p> 
<p>2、当你想创建一个服务，可以用更快速的传输通道时，像TCP、Named Pipes或者甚至是UDP（在WCF4.5中）,在其他传输通道不可用的时候也可以支持HTTP</p> 
<p>3、当你想创建一个基于HTTP的面向资源的服务并且可以使用HTTP的全部特征时（比如URIs、request/response头，缓存，版本控制，多种内容格式），你应该选择Web API</p> 
<p>4、当你想让你的服务用于浏览器、手机、iPhone和平板电脑时，你应该选择Web API</p> 
<p><strong>hashmap和hashTable的区别：</strong></p> 
<p>1.hashTable是Dictionary的子类，HashMap是Map接口的一个实现的类</p> 
<p>2.Hashtable中的方法是同步的，而HashMap中的方法缺省情况为非同步</p> 
<p>3.HashTabe不允许null值，而hashmap允许有null4.hashtable默认长度是11，增长方式是0ld*2+1，而hashmap则默认是16，而且一定是2的指数</p> 
<p><strong>如何理解委托和事件？</strong></p> 
<p>委托相当于c或者c++中的指针，委托能够把方法当做参数传递，并且提高程序的可扩展性。</p> 
<p><strong>事件：以一种特殊的委托</strong></p> 
<p><strong>委托具有如下特点：</strong></p> 
<p>1.委托相当于c++中的指针，但是他是安全类型</p> 
<p>2.委托可以把方法当做参数传递</p> 
<p>3.委托可以定义回调方法</p> 
<p>4.委托可以链接在一起，例如:可以对多个事件调用多个方法</p> 
<p>5.方法不需要与委托前面精确匹配</p> 
<p><strong>UDP连接和tcp连接的异同：</strong></p> 
<p>两者都可以实现远程通讯，而主要区别在于tcp需要保持连接，而Udp不需要，由此可以看出udp更高的效率和占用资源更少，但是tcp传输数据更可靠</p> 
<p><strong>.Net身份验证的方式有哪几种：</strong></p> 
<p>默认值为 Windows。 在Web.config 文件中，通过 节可以配置 ASP.NET 使用的安全身份验证模式，以标识传入的用户。 … 节的mode 为必选的属性。指定应用程序的默认身份验证模式。</p> 
<p>此属性可以为下列值之一： Windows ：将 Windows 验证指定为默认的身份验证模式。将它与以下任意形式的 Microsoft Internet 信息服务 (IIS) 身份验证结合起来使用：基本、摘要、集成 Windows 身份验证 (NTLM/Kerberos) 或证书。在这种情况下，您的应用程序将身份验证责任委托给基础 IIS。 Forms ：将 ASP.NET 基于窗体的身份验证指定为默认身份验证模式。Passport ：将 Microsoft Passport Network 身份验证指定为默认身份验证模式。 None ：不指定任何身份验证。您的应用程序仅期待匿名用户，否则它将提供自己的身份验证。</p> 
<p><strong>在c#中object类：</strong></p> 
<p>1、类Object是 .NET Framework 中所有类、结构、枚举和委托的最终基类。</p> 
<p>2、C#通常不要求类显示声明从 Object 的继承，因为继承是隐式的。</p> 
<p>3、因为 .NET Framework 中的所有类均从 Object 派生，所以 Object 类中定义的每个方法可用于系统中的所有对象。 派生类也可以重写这些方法中的某些。</p> 
<p><strong>高内聚,低耦合的理解：</strong></p> 
<p>内聚：是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系；</p> 
<p>耦合：是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</p> 
<p><strong>C#面向对象思想主要包括：封装，继承，多态：</strong><br> 封装：用抽象的数据类型将数据类型和基本的方法操作封装在一起，在数据保护在抽象类型内部 （封装就是把数据或者函数集合在一个个的类中，封装的对象被称为抽象对象，封装的意义是防止或保护代码被我们无意的破坏，提高代码的重用性，职责分配）</p> 
<p>继承：子类拥有父类的所有数据和操作<br> 多态：一个程序中同名的不同方法的共存情况（方法重载和重写）</p> 
<p><strong>C#面向切面编程（AOP）：</strong></p> 
<p>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程（<a href="https://www.cnblogs.com/landeanfen/p/4782370.html" rel="nofollow">https://www.cnblogs.com/landeanfen/p/4782370.html</a>）</p> 
<p>一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。<br> 这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。<br> AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。</p> 
<p><strong>重载和重写的区别：</strong></p> 
<p>重载：方法名相同参数个数和参数类型不同<br> 重写：当子类继承父类，子类中的方法与父类中的方法名，参数类型和参数个数完全相同则称为子类重写了父类方法（需要一override字标示）（对基类成员的 重写）</p> 
<p><strong>概述反射和序列化：</strong></p> 
<p>反射:程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性 （就如：实例化对应的类，然后通过实例字段获取对应的方法）序列化:序列化是将对象转换为容易传输的格式的过程。例如，可以序列化一个对象，然后使用 HTTP 通过 Internet 在客户端和服务器之间传输该对象。在另一端，反序列化将从该流重新构造对象。</p> 
<p><strong>C#中的构造函数:</strong></p> 
<p>每次创建类或结构，将会调用其构造函数。类或结构中可以创建多个不个不同参数的构造函数，程序员可以对不同构造函数设置默认值，约束条件，并编写灵活易读的代码。</p> 
<p><strong>构造函数的特点：</strong></p> 
<p>a:构造函数与类名相同</p> 
<p>b:构造函数没有返回值</p> 
<p>c:可以带参数，也可以不带参数</p> 
<p>d:每个类中必须要有都应一个构造函数，一般假如不需要经常用到的话可以不需要声明构造函数，因为程序在编译的时候会自己调用无参的构造函数。</p> 
<p><strong>类成员有多少种访问方式：</strong></p> 
<p>a:实例成员，可以通过类的实例访问</p> 
<p>b：静态成员可以直接通过类访问</p> 
<p><strong>简单描述 string str=null;string str=“”,请尽量用文字说明区别（要点：说明详细的内存空间分配）前者声明变量不会分配内存空间；后者创建了一个空的字符类型，并且分配了对应的内存空间</strong><br> String str=new String(“加油”);创建了几个string object？<br> 创建了两个，一个对象是加油 一个是指向"加油"的str<br> String 类是否可以被继承：不能，因为String类是selead类</p> 
<p><strong>简单描述.NET里class和struct（结构）异同：</strong></p> 
<p>类和结构有很多相似之处：结构可以实现接口，并且具有于类相同的成员类型不同：结构是值类型而非引用类型，结构不能继承，结构存储在堆栈或者内联上。</p> 
<p><strong>值类型：</strong></p> 
<p>整数，浮点数，高精度浮点数，布尔，字符，结构，枚举</p> 
<p><strong>引用类型：</strong></p> 
<p>对象（Object），字符串，类，接口，委托，数组</p> 
<p><strong>sealed（又称密封类）修饰的类有哪些特点：</strong></p> 
<p>sealed修饰的类防止此类被派生出其他的类，如果密封类被指定为其它的基类则编译出错（密封类同时不能为抽象类）</p> 
<p><strong>C#.NET里面抽象类和接口有什么区别?</strong></p> 
<p>**声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。**<strong>接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</strong></p> 
<p><strong>接 口:</strong>(1) 接口不能被实例化</p> 
<p>(2) 接口只能包含方法声明</p> 
<p>(3) 接口的成员包括方法、属性、索引器、事件</p> 
<p>(4) 接口中不能包含常量、字段(域)、构造函数、析构函数、静态成员。<br> (5) 接口中的所有成员默认为public，因此接口中不能有private修饰符</p> 
<p>(6) 派生类必须实现接口的所有成员</p> 
<p>(7) 一个类可以直接实现多个接口，接口之间用逗号隔开</p> 
<p>(8) 一个接口可以有多个父接口，实现该接口的类必须实现所有父接口中的所有成员</p> 
<p><strong>抽象类和接口 :</strong></p> 
<p>相同点和不同点（<a href="http://www.cnblogs.com/ronli/archive/2011/10/26/2224654.html" rel="nofollow">http://www.cnblogs.com/ronli/archive/2011/10/26/2224654.html</a>）</p> 
<p>相同点:</p> 
<p>1. 都不能被直接实例化，都可以通过继承实现其抽象方法。</p> 
<p>2. 都是面向抽象编程的技术基础，实现了诸多的设计模式。</p> 
<p>不同点:</p> 
<p>1. 接口支持多继承；抽象类不能实现多继承。</p> 
<p>2. 接口只能定义抽象规则；抽象类既可以定义规则，还可能提供已实现的成员。</p> 
<p>3. 接口是一组行为规范；抽象类是一个不完全的类，着重族的概念。</p> 
<p>4. 接口可以用于支持回调；抽象类不能实现回调，因为继承不支持。</p> 
<p>5. 接口只包含方法、属性、索引器、事件的签名，但不能定义字段和包含实现的方法；抽象类可以定义字段、属性、包含实现的方法</p> 
<p><strong>.net中dataset和datareader的区别:</strong></p> 
<p>首先，datareader是在线对象，用来以只读只进方式读取数据。只读，就是只能通过它获取数据而不能修改数据，只进，就是读取记录的游标只会不断前进，比如说读取了第5条记录以后就不能返回去读取第2条记录而dataset是离线对象，它就好像是一个数据库，也可以说是数据库的一个副本，你可以对dataset进行离线编辑修改，之后提交回数据库，实现数据的离线操作</p> 
<p><strong>sql语句中int转varchar：</strong></p> 
<p>2011-02-12 10:39SELECT parent_id_list+‘,’+cast(id AS varchar(10)) FROM mytable<br> 或者cast也可以用convert来代替<br> 同时看到有网友有这样的需求，它想把1转成varchar的”000001″这样的串，但是cast函数是只会转成”1″，所以要借用right函数select right(’00000000′ CAST(@i as varchar)</p> 
<p><strong>1).数据库多表连接查询可以分为哪几种？并且各有什么作用？</strong></p> 
<p><strong>主要分为五种:</strong> a:主键条件关联查询（表中至少有一个匹配与inner join…on 相似）</p> 
<pre><code>          b:inner join ...on内连接查询（表中有至少一个匹配，则返回匹配的行）

          c:left join....on 左连接查询（右边表没有匹配，也从左边表返回所有的行） 

          d:right join...on 右连接查询（左边表没有匹配，也从右边表返回所有行）

          e:full join...on 全连接查询（就是返回两个表中的所有行）
</code></pre> 
<p><strong>数据库中的存储过程和sql语句有优缺点：</strong></p> 
<p>数据库存储过程优点：</p> 
<p>a:代码精简一致，代码重用性强，可以实现模块化程序设计</p> 
<p>b：运行速度快，提高程序的性能， 因为存储程序只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次， 所以使用存储过程可提高数据库执行速度</p> 
<p>c:可维护性高，只需创建存储过程一次并将其存储在数据库中，以后即可在程序中调用该过程任意次。存储过程可独立于程序源代码而单独修改，而不需要 更 改 ，测试以及重新部署程序集。</p> 
<p>d： 有安全机制，可授予没有直接执行存储过程中语句的权限的用户，也可执行该存储过程的权限。另外可以防止用户直接访问表，强制用户使用存储过程 执行特定的任务。</p> 
<p>e: 减少网络流量，在网络中要发送的数百行代码，可由一条执行其存储过程代码的一条单独语句就可实现（多条sql语句这里简化成立一个存储过程）</p> 
<p>不足：</p> 
<p>a:架构不清醒不利于面向对象： 存储过程不太适合面向对象的设计，无法采用面向对象的方式将业务逻辑进行封装，业务逻辑在存储层实现，增加了业务和存储的耦合，代码的可读性也会降低。</p> 
<p>b:可移植性差：过多的使用存储过程会降低系统的移植性。在对存储进行相关扩展时，可能会增加一些额外的工作。</p> 
<p><strong>T-sql语句：</strong></p> 
<p>可移植性强，语句灵活查询速度比存储过程要慢</p> 
<p><strong>数据库存储过程和T-sql语句的选择：</strong></p> 
<p>在一些新的项目开发过程中一般不推荐优先使用数据库存储过程，一般数据库存储过程适用于一般业务逻辑复杂，涉及到了多表操作，并且查询大批量的数据的时候。例如后台大批量查询，以及定期更新等。</p> 
<p>（1）当一个事务涉及到多个SQL语句时或者涉及到对多个表的操作时可以考虑应用存储过程</p> 
<p>（2）在一个事务的完成需要很复杂的商业逻辑时可以考虑应用存储过程</p> 
<p>（3）比较复杂的统计和汇总可以考虑应用后台存储过程</p> 
<p>**数据库常用类型及其含义:**注：</p> 
<p>（Unicode 是「字符集」,UTF-8 是「编码规则」）</p> 
<p>Char，NChar 定长，速度快，占空间大，需处理</p> 
<p>Varchar，Nvarchar，text 不定长，空间小，速度慢，无需处理</p> 
<p>Nchar、NVarchar、NTEXT处理Unicode码</p> 
<p>char、varchar最多能存储8000个英文，4000个汉字。可以看出使用nchar、nvarchar数据类型时不用担心输入的字符是英文还是汉字，较为方便但在存储英文时数量上有些损失。</p> 
<p><strong>如何使用这些类型：</strong> 如果你肯定存储的数据长度，而且不包中文的，可以选择char类型。</p> 
<pre><code>               如果肯定存储的数据长度，但可能包括中文，可以选择nchar类型。

               如果不确定存储的数据长度，存储只有英文、数字的最好用varchar 

               如果不确定存储的数据长度，也有可能有中文，可以选择nvarchar类型  
</code></pre> 
<p><strong>XML和json数据传输格式的优缺点：</strong></p> 
<p>什么是 XML?XML 指可扩展标记语言（EXtensible Markup Language）XML 是一种标记语言，很类似 HTMLXML 的设计宗旨是传输数据，而非显示数据XML 标签没有被预定义。您需要自行定义标签。XML 被设计为具有自我描述性。XML 是 W3C 的推荐标准</p> 
<p>什么是json？JSON 是纯文本JSON 具有“自我描述性”（人类可读）JSON 具有层级结构（值中存在值）JSON 可通过 JavaScript 进行解析JSON 数据可使用 AJAX 进行传输</p> 
<p>区别：xml（可扩展性标记语言）和json两者都是一种跨平台，跨语言的数据传输格式，xml可以自定义标签而json是有规定的文本格式，json 的适用范围有限而xml没有，但是xml看起来比较复杂，json简单。</p> 
<p><strong>XSLT？</strong></p> 
<p>是一种可扩展的样式表文件，使用xsl可以格式化xml格式，并且能够将xml转化为另一种格式的输出</p> 
<p><strong>用.net做B/S结构的系统，您是用几层结构来开发，每一层之间的关系以及为什么要这样分层？</strong> 答：从下至上分别为：数据访问层、业务逻辑层（又或成为领域层）、表示层</p> 
<p>数据访问层：有时候也称为是持久层，其功能主要是负责数据库的访问</p> 
<p>业务逻辑层：是整个系统的核心，它与这个系统的业务（领域）有关 是表现层与数据访问的的桥梁（起到了逻辑判断）</p> 
<p>表示层：是系统的UI部分，负责使用者与整个系统的交互。</p> 
<p>优点： 分工明确，条理清晰，易于调试，而且具有可扩展性</p> 
<p>缺点： 增加成本。</p> 
<p><strong>分层式结构究竟其优势何在？</strong></p> 
<p>1、开发人员可以只关注整个结构中的其中某一层；</p> 
<p>2、可以很容易的用新的实现来替换原有层次的实现；</p> 
<p>3、可以降低层与层之间的依赖；</p> 
<p>4、有利于标准化；</p> 
<p>5、利于各层逻辑的复用。</p> 
<p>概括来说，分层式设计可以达至如下目的：分散关注、松散耦合、逻辑复用、标准定义、易于拓展</p> 
<p><strong>分层式结构也不可避免具有一些缺陷：</strong></p> 
<p>1、降低了系统的性能。这是不言而喻的。如果不采用分层式结构，很多业务可以直接造访数据库，以此获取相应的数据，如今却必须通过中间层来完成。</p> 
<p>2、有时会导致级联的修改。这种修改尤其体现在自上而下的方向。如果在表示层中需要增加一个功能，为保证其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码。</p> 
<p><strong>MVC 编程模式MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式：</strong></p> 
<p>Model（模型）表示应用程序核心（比如数据库记录列表）</p> 
<p>View（视图）显示数据（数据库记录）</p> 
<p>Controller（控制器）处理输入（写入数据库记录）</p> 
<p>MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制。</p> 
<p>Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据</p> 
<p>View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。</p> 
<p>Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</p> 
<p>MVC 分层有助于管理复杂的应用程序，因为您可以在一个时间内专门关注一个方面。例如，您可以在不依赖业务逻辑的情况下专注于视图设计。同时也让应用程序的测试更加容易。MVC 分层同时也简化了分组开发。不同的开发人员可同时开发视图、控制器逻辑和业务逻辑。</p> 
<p><strong>mvc的优点：</strong></p> 
<p>1.通过把项目分成model view和controller，使得复杂项目更加容易维护。</p> 
<p>2.没有使用view state和服务器表单控件，可以更方便的控制应用程序的行为</p> 
<p>3.应用程序通过controller来控制程序请求，可以提供丰富的url重写。</p> 
<p>4.对单元测试的支持更加出色</p> 
<p>5.在团队开发模式下表现更出众</p> 
<p><strong>MVC的不足：</strong></p> 
<p>（1）增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</p> 
<p>（2）视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</p> 
<p>（3）视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</p> 
<p><strong>asp.net如何实现MVC模式，举例说明！web/business/dataaccess</strong></p> 
<p><strong>列举ASP.NET 页面之间传递值的几种方式</strong></p> 
<p>1.response. Redirect() QueryString()…</p> 
<p>2.使用Session变量</p> 
<p>3.使用Server.Transfer(只能在同一站点中进行url重定向，而且url和url中的参数不会在浏览器中显示)</p> 
<p>4.application和Cookie<br> <strong>请说明在.net中常用的几种页面间传递参数的方法，并说出他们的优缺点</strong><br> QueryString 传递一个或多个安全性要求不高或是结构简单的数值。</p> 
<p>但是对于传递数组或对象的话，就不能用这个方法了 session(viewstate) 简单，但易丢失 作用于用户个人,过量的存储会导致服务器内存资源的耗尽。</p> 
<p>application 对象的作用范围是整个全局，也就是说对所有用户都有效。其常用的方法用Lock和UnLock</p> 
<p>cookie 简单，但可能不支持，可能被伪造 Cookie是存放在客户端的，而session是存放在服务器端的。而且Cookie的使用要配合ASP.NET内置对象Request来使用 input ttype=“hidden” 简单，可能被伪造 url参数简单，显示于地址栏，长度有限</p> 
<p>Server.Transfer 把流程从当前页面引导到另一个页面中，新的页面使用前一个页面的应答流 数据库稳定，安全，但性能相对弱</p> 
<p><strong>什么是Viewstate？它有什么作用？</strong></p> 
<p>ViewState用来保存页面状态，就是说提交之后我们还可以看到文本框里面的内容就是ViewState保存的功劳。 ViewState只维护当前页面的状态，不同页面之间不能共享，Session可以。 ViewState你可以理解为一个隐藏控件</p> 
<p><strong>ASP.Net页面生命周期 ：</strong>（重要）<a href="https://www.cnblogs.com/xhwy/archive/2012/05/20/2510178.html" rel="nofollow">https://www.cnblogs.com/xhwy/archive/2012/05/20/2510178.html</a><br> 当我们在浏览器地址栏中输入网址，回车查看页面时，这时会向服务器端（IIS）发送一个request请求，服务器就会判断发送过来的请求页面， 完全识别 HTTP 页面处理程序类后，ASP.NET 运行时将调用处理程序的 ProcessRequest 方法来处理请求，来创建页面对象。通常情况下，无需更改此方法的实现，因为它是由 Page 类提供的。接下来被创建页面对象的ProcessRequest方法使页面经历了各个阶段：初始化、加载视图状态信息和回发数据、加载页面的用户代码以及执行回发服务器端事件。之后，页面进入显示模式：收集更新的视图状态，生成 HTML 代码并随后将代码发送并输出控制台。最后，卸载页面，并认为请求处理完毕。其中页面对象ProcessRequest方法 完成的这一系列事件的处理过程就是Asp.Net页面生命周期。</p> 
<p><strong>我的理解：</strong><br> 首先在对应的浏览器中输入对应的网址对服务器发送请求（request）服务器识别浏览器的http请求，通过调用processrequest方法来处理请求，创建页面对象然后通过创建processrequest方法使页面经历了：初始化,加载试图状态信息，和回发数据，加 载用户代码及执行返回服务器端的事件。之后页面进入显示模式：收集更新的试图状态，生成html代码将代码发送输出在浏览器中展示。最后卸载页面，并认为请求处理完毕</p> 
<p><strong>每个页面的生命周期为用户的每一次访问，也就是说每一次客户端与服务器之间的一个往返过程.全局变量的生命周期在此之间.</strong></p> 
<p>1. Page_Init();</p> 
<p>2. Load ViewState and Postback data;</p> 
<p>3. Page_Load();</p> 
<p>4. Handle control events;</p> 
<p>5. Page_PreRender();</p> 
<p>6. Page_Render();</p> 
<p>7. Unload event;</p> 
<p>8. Dispose method called;</p> 
<p><strong>ADO.net中常用的对象有哪些？</strong></p> 
<p>分别描述一下。</p> 
<p>Connection 数据库连接对象</p> 
<p>Command 执行数据库命令</p> 
<p>DataAdapter 连接数据，执行数据库命令，填充DataSet</p> 
<p>DataSet 数据在内存中的缓存，数据结构</p> 
<p>DataReader 只读向前的读取数据库</p> 
<p><strong>DataReader和DataSet的异同</strong></p> 
<p>1.与数据库连接：DataReader:面向连接，只读，只进，只能向前读，读完数据就断开连接；（无法对获取的数据进行操作）</p> 
<p>DataSet:非面向连接，把数据加载到sql缓存池中，然后断开连接；</p> 
<p>2.处理数据速度：DataReader:速度快；DataSet:速度慢；</p> 
<p>3.更新数据库：DataReader:更新后，没有办法还原到原来的数据库；DataSet:更新后，可以还原回原来的数据库；</p> 
<p>4.支持分页排序:DataReader:不支持分页与排序；DataSet:支持分页与排序，从内存中直接读取前多少条（假分页）；</p> 
<p>5.占用内存:DataReader:占用内存小；DataSet:占用内存大；</p> 
<p><strong>DataSet可以比作一个内存中的数据库，DataTable是一个内存中的数据表，DataSet里可以存储多个DataTable</strong></p> 
<p><strong>说出你所了解的数据库访问组件(例如ADO，至少4种)</strong></p> 
<p>答：ADO，ADO.Net，MDAC(Microsoft Data Access Components)，Microsoft SQL Server OLE DB Provider，Microsoft Jet OLE DB Provider，Desktop Database Drivers ODBC Driver，Visual FoxPro ODBC Driver</p> 
<p><strong>什么是装箱和拆箱？</strong></p> 
<p>答：从值类型接口转换到引用类型装箱。从引用类型转换到值类型拆箱。装箱（boxing）是将 值类型的数据转化成引用类型，int i=3; object o = i ;便是装箱过程，而拆箱(unboxing)是将饮用类型数据转换值类型,比如int j = (int)o；属于拆箱</p> 
<p><strong>接口含义：接口是指一组函数成员而不实现他们的引用类型，通常只能通过接和类的继承，继承接口要实 其全部方法</strong></p> 
<p><strong>什么时候使用抽象类，什么时候用接口 ：</strong><br> 接口用于规范，抽象类用于共性。</p> 
<p>接口中只能声明方法，属性，事件，索引器。而抽象类中可以有方法的实现，也可以定义非静态的类变量。</p> 
<p>抽象类是类，所以只能被单继承，但是接口却可以一次实现多个。</p> 
<p>抽象类可以提供某些方法的部分实现，接口不可以.抽象类的实例是它的子类给出的。接口的实例是实现接口的类给出的。再抽象类中加入一个方法，那么它的子类就同时有了这个方法。而在接口中加入新的方法，那么实现它的类就要重新编写（这就是为什么说接口是一个类的规范了）。接口成员被定义为公共的，但抽象类的成员也可以是私有的、受保护的、内部的或受保护的内部成员（其中受保护的内部成员只能在应用程序的代码或派生类中访问）。此外接口不能包含字段、构造函数、析构函数、静态成员或常量。 <strong>枚举的使用：<a href="https://www.cnblogs.com/claspcn/p/5218520.html" rel="nofollow">https://www.cnblogs.com/claspcn/p/5218520.html</a></strong></p> 
<p><strong>委托和事件：</strong>（<a href="http://www.tracefact.net/tech/009.html" rel="nofollow">http://www.tracefact.net/tech/009.html</a>）委托 和 事件在 .Net Framework中的应用非常广泛，然而，较好地理解委托和事件对很多接触C#时间不长的人来说并不容易。它们就像是一道槛儿，过了这个槛的人，觉得真是太容易了，而没有过去的人每次见到委托和事件就觉得心里别（biè）得慌，混身不自在。本文中，我将通过两个范例由浅入深地讲述什么是委托、为什么要使用委托、事件的由来、.Net Framework中的委托和事件、委托和事件对Observer设计模式的意义，对它们的中间代码也做了讨论。 <strong>const和readonly有什么区别？</strong></p> 
<p>const关键字用来声明编译时常量，readonly用来声明运行时常量。</p> 
<p>用sealed修饰的类有什么特点 sealed 修饰符用于防止从所修饰的类派生出其它类,如果一个密封类被指定为其他类的基类，则会发生编译时错误。 密封类不能同时为抽象类。 sealed 修饰符主要用于防止非有意的派生，但是它还能促使某些运行时优化。具体说来，由于密封类永远不会有任何派生类，所以对密封类的实例的虚拟函数成员的调用可以转换为非虚拟调用来处理。</p> 
<p><strong>虚函数的用法</strong></p> 
<p>1)virtual指明一成员函数为虚函数,而virtual仅用于类的定义里,在类外可不加此关键字.</p> 
<p>2)一个类的成员函数被定义为虚函数时,子类该函数仍保持虚函数特征.</p> 
<p>3)子类覆盖此函数时,定义里可不加virtual关键字,但函数声明要和基类的完全一致!且此声明是必须的.</p> 
<p>4)不是纯虚函数时,父类的虚函数必须要实现; 而若将父类的虚函数设定为纯虚函数时,子类必需要覆盖之而且必须要实现之!</p> 
<p><strong>解释virtual、sealed、override和abstract的区别 virtual申明虚方法的关键字，说明该方法可以被重写 sealed说明该类不可被继承 override重写基类的方法 abstract申明抽象类和抽象方法的关键字，抽象方法不提供实现，由子类实现，抽象类不可实例化。</strong> <strong>c#继承：</strong></p> 
<p>base表示对象基类的实例（使用base可以调用基类中的成员）base 表示当前对象基类的实例(使用base关键字可以调用基类的成员)this表示当前类的实例</p> 
<p>在静态方法中不可以使用base和this关键字</p> 
<p><strong>派生类会继承基类所有的成员但是构造函数和析构函数不会被继承</strong></p> 
<p><strong>什么是析构函数：</strong></p> 
<p>析构函数(destructor) 与构造函数相反，当对象脱离其作用域时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。</p> 
<p><strong>注意如果派生类的方法和基类的方法同名则基类中的方法将会被隐藏如果需要隐藏则可以使用关键字new来隐藏如果不写new关键字默认处理为隐藏虽然基类中同名的方法被隐藏了但是还是可以通过base关键字来调用</strong></p> 
<p><strong>进程和线程的区别？</strong></p> 
<p>进程是系统进行资源分配和调度的单位；</p> 
<p>线程是CPU调度和分配的单位，一个进程可以有多个线程，这些线程共享这个进程的资源。</p> 
<p><strong>堆和栈的区别：</strong></p> 
<p>栈：由编译器自动分配、释放。在函数体中定义的变量通常在栈上。</p> 
<p>堆：一般由程序员分配释放。用new、malloc等分配内存函数分配得到的就是在堆上。</p> 
<p>概述：<br> 栈（Stack）由系统管理生存期，存储代码执行和调用路径，执行或调用完毕即从栈中清除；</p> 
<p>堆（Heap）中保存值和对象，调用完毕之后依然存在，由垃圾回收器查找栈中有无指向该值或对象的引用，无则从堆中删除</p> 
<p><strong>C# ref与out区别:</strong></p> 
<p>1、使用ref型参数时，传入的参数必须先被初始化。对out而言，必须在方法中对其完成初始化。</p> 
<p>2、使用ref和out时，在方法的参数和执行方法时，都要加Ref或Out关键字。以满足匹配。</p> 
<p>3、out适合用在需要retrun多个返回值的地方，而ref则用在需要被调用的方法修改调用者的引用的时候。</p> 
<p><strong>你对泛型了解吗？简单说明一下泛型的有什么好处？</strong></p> 
<p>泛型：通过参数化类型来实现在同一份代码上操作多种数据类型。利用“参数化类型”将类型抽象化，从而实现灵活的复用 好处是——类型安全和减少装箱、拆箱。提高性能、类型安全和质量，减少重复性的编程任务</p> 
<p><strong>C#中所有对象共同的基类是什么？ System.Object.</strong></p> 
<p><strong>如何在C#中实现继承？ 在类名后加上一个冒号，再加上基类的名称。</strong></p> 
<p><strong>私有成员会被继承么？ 会，但是不能被访问。所以看上去他们似乎是不能被继承的，但实际上确实被继承了。 (是有成员能够被继承，但是不能够被访问)</strong></p> 
<p><strong>new的三种用法</strong></p> 
<p>答：实例化对象，隐藏基类方法。</p> 
<p>运算符（创建对象，创建值类型的默认构造函数）</p> 
<p>修饰作用（隐藏基类中的继承对象，子类中的对象覆盖基类中的版本）</p> 
<p><strong>string是值类型还是引用类型?引用类型</strong></p> 
<p><strong>String类与StringBuilder类有什么区别？为什么在.Net类库中要同时存在这2个类？</strong></p> 
<p>(简答)stringBuilder比string更节约内存,所以stringBuilder更快String 对象是不可改变的。</p> 
<p>每次使用 System.String 类中的方法之一或进行运算时（如赋值、拼接等）时，都要在内存中创建一个新的字符串对象，这就需要为该新对象分配新的空间。而 StringBuilder 则不会。在需要对字符串执行重复修改的情况下，与创建新的 String 对象相关的系统开销可能会非常昂贵。</p> 
<p>如果要修改字符串而不创建新的对象，则可以使用 System.Text.StringBuilder 类。例如，当在一个循环中将许多字符串连接在一起时，使用 StringBuilder 类可以提升性能。</p> 
<p><strong>Session有什么重大BUG，微软提出了什么方法加以解决？</strong></p> 
<p>答：是iis中由于有进程回收机制，系统繁忙的话Session会丢失，可以用Sate server或SQL Server数据库的方式存储Session不过这种方式比较慢，而且无法捕获Session的END事件</p> 
<p><strong>c#中的三元运算符是 ？：</strong></p> 
<p><strong>.能用foreach遍历访问的对象需要实现(Ienumber) 接口或声明 ( GetEnumerator)方法的类型。</strong></p> 
<p><strong>.&lt;%# %&gt; 和 &lt;% %&gt; 有什么区别？</strong></p> 
<p>&lt;%# %&gt;表示绑定的数据源 &lt;% %&gt;是服务器端代码块</p> 
<p><strong>C#可否对内存进行直接的操作？</strong></p> 
<p>在.net下，.net引用了垃圾回收（GC）功能，它替代了程序员 不过在C#中，不能直接实现Finalize方法，而是在析构函数中调用基类的Finalize()方法</p> 
<p><strong>DateTime是否可以为null?</strong></p> 
<p>不能，因为其为Struct类型，而结构属于值类型，值类型不能为null,只有引用类型才能被赋值null</p> 
<p>DateTime.Parse(myString); 这行代码有什么问题？有问题，当myString不能满足时间格式要求的时候，会引发异常，建议使用DateTime.TryParse()</p> 
<p><strong>net的错误处理机制是:采用try-&gt;catch-&gt;finally结构， 为什么不提倡catch(Exception) try…catch在出现异常的时候影响性能; 应该捕获更具体得异常，比如IOExeception,OutOfMemoryException等 catch(Exception e){throw e;}和catch(Exception e){throw;}的区别将发生的异常对象抛出，另一个只是抛出异常，并没有抛出原异常对象）</strong></p> 
<p><strong>我应该如何允许连接池？</strong></p> 
<p>对于.NET应用程序而言，默认为允许连接池。（这意味着你可以不必为这件事情做任何的事情）当然，如果你可以在SQLConnection对象的连接字符串中加进Pooling=true;确保你的应用程序允许连接池的使用。（pooling=true）5． 我应该如何禁止连接池？ADO.NET默认为允许数据库连接池，如果你希望禁止连接池，可以使用如下的方式：1) 使用SQLConnection对象时，往连接字符串加入如下内容：Pooling=False;2) 使用OLEDBConnection对象时，往连接字符串加入如下内容：OLE DB Services=-4;</p> 
<p><strong>提高.NET的性能</strong></p> 
<p>1 使用异步方式调用Web服务和远程对象只要有可能就要避免在请求的处理过程中对Web服务和远程对象的同步调用，因为它占用的是的ASP.NET 线程池中的工作线程，这将直接影响Web服务器响应其它请求的能力。</p> 
<p>2 使用适当的Caching策略来提高性能</p> 
<p>3 判断字符串，不要用"“比较。//避免 if(strABC!=null &amp;&amp; strABC!=”") {}//推荐 if(!strABC.IsNullOrEmpty) {}</p> 
<p>4 页面优化</p> 
<p>5 用完马上关闭数据库连接</p> 
<p>6 尽量使用存储过程，并优化查询语句</p> 
<p>7 只读数据访问用SqlDataReader，不要使用DataSet</p> 
<p><strong>请解释转发与跳转的区别 转发就是服务端的跳转A页面提交数据到B页面,B页面进行处理然后从服务端跳转到其它页面 跳转就是指客户端的跳转</strong></p> 
<p><strong>什么叫应用程序域？</strong></p> 
<p>答：应用程序域可以理解为一种轻量级进程。起到安全的作用。占用资源小。</p> 
<p><strong>CTS、CLS、CLR分别作何解释？</strong></p> 
<p>答：CTS：通用语言系统。CLS：通用语言规范。CLR：公共语言运行库。</p> 
<p><strong>请解释web.config文件中的重要节点</strong></p> 
<p>appSettings包含自定义应用程序设置</p> 
<p>system.web 系统配置</p> 
<p>compilation动态调试编译设置</p> 
<p>customErrors自定义错误信息设置</p> 
<p>authentication身份验证,此节设置应用程序的身份验证策略</p> 
<p>authorization授权, 此节设置应用程序的授权策略.</p> 
<p><strong>请解释ASP。NET中的web页面与其隐藏类之间的关系？</strong></p> 
<p>ASP.NET页面一般都对应一个隐藏类,一般都在ASP.NET页面的声明中指定了隐藏类例如一个页面Tst1.aspx的页面声明如下 &lt;%@ Page language=“c#” Codebehind=“Tst1.aspx.cs” AutoEventWireup=“false” Inherits=“T1.Tst1” %&gt; Codebehind=“Tst1.aspx.cs” 表明经编译此页面时使用哪一个代码文件 Inherits=“T1.Tst1” 表用运行时使用哪一个隐藏类</p> 
<p><strong>当发现不能读取页面上的输入的数据时很有可能是什么原因造成的？怎么解决？</strong></p> 
<p>很有可能是在Page_Load中数据处理时没有进行Page的IsPostBack属性判断</p> 
<p>请解释什么是上下文对象，在什么情况下要使用上下文对象 上下文对象是指HttpContext类的Current 属性，当我们在一个普通类中要访问内置对象(Response,Request,Session,Server,Appliction等)时就要以使用此对象</p> 
<p><strong>解释一下ajax及实现原理</strong></p> 
<p>答：Ajax的核心是JavaScript对象XmlHttpRequest，它使您可以使用JavaScript向服务器提出请求并处理响应， 而不阻塞用户，异步请求。</p> 
<h3><a id="_640"></a>总结：</h3> 
<p>这篇总结就先到这里，推荐大家学习《CLR via C#》和《.net软件之美》对C#了解到深入有很大的帮助。</p> 
<p>本文转自 <a href="https://www.cnblogs.com/Can-daydayup/p/8921990.html" rel="nofollow">https://www.cnblogs.com/Can-daydayup/p/8921990.html</a>，如有侵权，请联系删除。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a6d526672df77067931a18bb5c251894/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【阿里云盘】自动每日签到，无需部署，无需服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6c78f49a5554070828aafe9654de1855/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">做了3年Java，靠着这份面试题跟答案，我从15K变成了30K</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>