<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;STL面试详解 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;STL面试详解" />
<meta property="og:description" content="1.什么是C&#43;&#43;STL?
C&#43;&#43; STL从广义来讲包括了三类：算法，容器和迭代器。
算法包括排序，复制等常用算法，以及不同容器特定的算法。容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。迭代器就是在不暴露容器内部结构的情况下对容器的遍历。 2.什么时候需要用hash_map？
总体来说，hash_map 查找速度会比 map 快，而且查找速度基本和数据数据量大小无关，属于常数级别;而 map 的查找速度是 log(n) 级别。
并不一定常数就比 log(n) 小，hash 还有 hash 函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑 hash_map。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map 可能会让你陷入尴尬，特别是当你的 hash_map 对象特别多时，你就更无法控制了。而且 hash_map 的构造速度较慢。
现在知道如何选择了吗？权衡三个因素: 查找速度, 数据量, 内存使用 。
3.STL中的hashtable的底层实现？
STL中的hashtable使用的是开链法解决hash冲突问题，如下图所示。
hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作
在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。
4.vector的底层原理
（1）vector的底层原理
vector底层是一个动态数组，包含三个迭代器，start和finish之间是已经被使用的空间范围，end_of_storage是整块连续空间包括备用空间的尾部。
当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间【vector内存增长机制】。
当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。
因此，对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器会都失效了。
（2）vector中的reserve和resize的区别
reserve是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化push_back），就可以提高效率，其次还可以减少多次要拷贝数据的问题。reserve只是保证vector中的空间大小（capacity）最少达到参数所指定的大小n。reserve()只有一个参数。
resize()可以改变有效空间的大小，也有改变默认值的功能。capacity的大小也会随着改变。resize()可以有多个参数。
（3）vector中的size和capacity的区别
size表示当前vector中有多少个元素（finish – start），而capacity函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage – start）。
（4）vector的元素类型可以是引用吗？
vector的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此vector的元素类型不能是引用。
（5）vector迭代器失效的情况
当插入一个元素到vector中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。
当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要it=vec.erase(it);。
（6）正确释放vector的内存(clear(), swap(), shrink_to_fit())
vec.clear()：清空内容，但是不释放内存。
vector().swap(vec)：清空内容，且释放内存，想得到一个全新的vector。
vec.shrink_to_fit()：请求容器降低其capacity和size匹配。
vec.clear();vec.shrink_to_fit();：清空内容，且释放内存。
（7）vector 扩容为什么要以1.5倍或者2倍扩容?
根据查阅的资料显示，考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2倍的方式扩容，或者以1.5倍的方式扩容。
以2倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间：
（8）vector的常用函数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/987b619a2f662781bab9023cbd540bab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-28T16:52:45+08:00" />
<meta property="article:modified_time" content="2022-09-28T16:52:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;STL面试详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:left;"><strong>1.什么是C++STL?</strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">C++ STL</span><span style="color:#34495e;">从广义来讲包括了三类：算法，容器和迭代器。</span></span></p> 
<ul><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">算法包括排序，复制等常用算法，以及不同容器特定的算法。</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是</span><span style="color:#34495e;">list</span><span style="color:#34495e;">，</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">等，关联式容器就是</span><span style="color:#34495e;">set</span><span style="color:#34495e;">，</span><span style="color:#34495e;">map</span><span style="color:#34495e;">等。</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</span></span></li><li style="text-align:left;"></ul> 
<p style="margin-left:0cm;"><strong>2.什么时候需要用hash_map？</strong></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">总体来说，</span><span style="color:#34495e;">hash_map </span><span style="color:#34495e;">查找速度会比</span><span style="color:#34495e;"> map </span><span style="color:#34495e;">快，而且查找速度基本和数据数据量大小无关，属于常数级别</span><span style="color:#34495e;">;</span><span style="color:#34495e;">而</span><span style="color:#34495e;"> map </span><span style="color:#34495e;">的查找速度是</span><span style="color:#34495e;"> log(n) </span><span style="color:#34495e;">级别。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">并不一定常数就比</span><span style="color:#34495e;"> log(n) </span><span style="color:#34495e;">小，</span><span style="color:#34495e;">hash </span><span style="color:#34495e;">还有</span><span style="color:#34495e;"> hash </span><span style="color:#34495e;">函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑</span><span style="color:#34495e;"> hash_map</span><span style="color:#34495e;">。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，</span><span style="color:#34495e;">hash_map </span><span style="color:#34495e;">可能会让你陷入尴尬，特别是当你的</span><span style="color:#34495e;"> hash_map </span><span style="color:#34495e;">对象特别多时，你就更无法控制了。而且</span><span style="color:#34495e;"> hash_map </span><span style="color:#34495e;">的构造速度较慢。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">现在知道如何选择了吗？权衡三个因素</span><span style="color:#34495e;">: </span><span style="color:#34495e;">查找速度</span><span style="color:#34495e;">, </span><span style="color:#34495e;">数据量</span><span style="color:#34495e;">, </span><span style="color:#34495e;">内存使用</span> <span style="color:#34495e;">。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>3.STL中的hashtable的底层实现？</strong></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">STL</span><span style="color:#34495e;">中的</span><span style="color:#34495e;">hashtable</span><span style="color:#34495e;">使用的是<strong>开链法</strong>解决</span><span style="color:#34495e;">hash</span><span style="color:#34495e;">冲突问题，如下图所示。</span></span></p> 
<p style="margin-left:0cm;"><img alt="" height="434" src="https://images2.imgbox.com/5c/99/sNXpJxW1_o.png" width="896"></p> 
<p></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">hashtable</span><span style="color:#34495e;">中的</span><span style="color:#34495e;">bucket</span><span style="color:#34495e;">所维护的</span><span style="color:#34495e;">list</span><span style="color:#34495e;">既不是</span><span style="color:#34495e;">list</span><span style="color:#34495e;">也不是</span><span style="color:#34495e;">slist</span><span style="color:#34495e;">，而是其自己定义的由</span><span style="color:#34495e;">hashtable_node</span><span style="color:#34495e;">数据结构组成的</span><span style="color:#34495e;">linked-list</span><span style="color:#34495e;">，而</span><span style="color:#34495e;">bucket</span><span style="color:#34495e;">聚合体本身使用</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">进行存储。</span><span style="color:#34495e;">hashtable</span><span style="color:#34495e;">的迭代器只提供前进操作，不提供后退操作</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">在</span><span style="color:#34495e;">hashtable</span><span style="color:#34495e;">设计</span><span style="color:#34495e;">bucket</span><span style="color:#34495e;">的数量上，其内置了</span><span style="color:#34495e;">28</span><span style="color:#34495e;">个质数</span><span style="color:#34495e;">[53, 97, 193,…,429496729]</span><span style="color:#34495e;">，在创建</span><span style="color:#34495e;">hashtable</span><span style="color:#34495e;">时，会根据存入的元素个数选择大于等于元素个数的质数作为</span><span style="color:#34495e;">hashtable</span><span style="color:#34495e;">的容量（</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">的长度），其中每个</span><span style="color:#34495e;">bucket</span><span style="color:#34495e;">所维护的</span><span style="color:#34495e;">linked-list</span><span style="color:#34495e;">长度也等于</span><span style="color:#34495e;">hashtable</span><span style="color:#34495e;">的容量。如果插入</span><span style="color:#34495e;">hashtable</span><span style="color:#34495e;">的元素个数超过了</span><span style="color:#34495e;">bucket</span><span style="color:#34495e;">的容量，就要进行重建</span><span style="color:#34495e;">table</span><span style="color:#34495e;">操作，即找出下一个质数，创建新的</span><span style="color:#34495e;">buckets vector</span><span style="color:#34495e;">，重新计算元素在新</span><span style="color:#34495e;">hashtable</span><span style="color:#34495e;">的位置。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>4.vector的底层原理</strong></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">1</span><span style="color:#34495e;">）</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">的底层原理</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">vector</span><span style="color:#34495e;">底层是一个动态数组，包含三个迭代器，</span><span style="color:#34495e;">start</span><span style="color:#34495e;">和</span><span style="color:#34495e;">finish</span><span style="color:#34495e;">之间是已经被使用的空间范围，</span><span style="color:#34495e;">end_of_storage</span><span style="color:#34495e;">是整块连续空间包括备用空间的尾部。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">当空间不够装下数据（</span><span style="color:#34495e;">vec.push_back(val)</span><span style="color:#34495e;">）时，会自动申请另一片更大的空间（</span><span style="color:#34495e;">1.5</span><span style="color:#34495e;">倍或者</span><span style="color:#34495e;">2</span><span style="color:#34495e;">倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间【</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">内存增长机制】。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">当释放或者删除（</span><span style="color:#34495e;">vec.clear()</span><span style="color:#34495e;">）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">因此，对</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">的任何操作一旦引起了空间的重新配置，指向原</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">的所有迭代器会都失效了。</span></span></p> 
<p style="margin-left:0cm;"><img alt="" height="650" src="https://images2.imgbox.com/dd/5b/HIUGjf3g_o.png" width="781"></p> 
<p></p> 
<p style="margin-left:0cm;"></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">2</span><span style="color:#34495e;">）</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">中的</span><span style="color:#34495e;">reserve</span><span style="color:#34495e;">和</span><span style="color:#34495e;">resize</span><span style="color:#34495e;">的区别</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">reserve</span><span style="color:#34495e;">是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化</span><span style="color:#34495e;">push_back</span><span style="color:#34495e;">），就可以提高效率，其次还可以减少多次要拷贝数据的问题。</span><span style="color:#34495e;">reserve</span><span style="color:#34495e;">只是保证</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">中的空间大小（</span><span style="color:#34495e;">capacity</span><span style="color:#34495e;">）最少达到参数所指定的大小</span><span style="color:#34495e;">n</span><span style="color:#34495e;">。</span><strong><span style="color:#34495e;">reserve()</span></strong><strong><span style="color:#34495e;">只有一个参数。</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">resize()</span><span style="color:#34495e;">可以改变有效空间的大小，也有改变默认值的功能。</span><span style="color:#34495e;">capacity</span><span style="color:#34495e;">的大小也会随着改变。</span><span style="color:#34495e;">resize()</span><span style="color:#34495e;">可以有多个参数。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">3</span><span style="color:#34495e;">）</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">中的</span><span style="color:#34495e;">size</span><span style="color:#34495e;">和</span><span style="color:#34495e;">capacity</span><span style="color:#34495e;">的区别</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">size</span><span style="color:#34495e;">表示当前</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">中有多少个元素（</span><span style="color:#34495e;">finish – start</span><span style="color:#34495e;">），而</span><span style="color:#34495e;">capacity</span><span style="color:#34495e;">函数则表示它已经分配的内存中可以容纳多少元素（</span><span style="color:#34495e;">end_of_storage – start</span><span style="color:#34495e;">）。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">4</span><span style="color:#34495e;">）</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">的元素类型可以是引用吗？</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">vector</span><span style="color:#34495e;">的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">的元素类型不能是引用。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">5</span><span style="color:#34495e;">）</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">迭代器失效的情况</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">当插入一个元素到</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">当删除容器中一个元素后</span><span style="color:#34495e;">,</span><span style="color:#34495e;">该迭代器所指向的元素已经被删除，那么也造成迭代器失效。</span><span style="color:#34495e;">erase</span><span style="color:#34495e;">方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要</span><span style="color:#34495e;">it=vec.erase(it);</span><span style="color:#34495e;">。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">6</span><span style="color:#34495e;">）正确释放</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">的内存</span><span style="color:#34495e;">(clear(), swap(), shrink_to_fit())</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">vec.clear()</span><span style="color:#34495e;">：清空内容，但是不释放内存。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">vector().swap(vec)</span><span style="color:#34495e;">：清空内容，且释放内存，想得到一个全新的</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">vec.shrink_to_fit()</span><span style="color:#34495e;">：请求容器降低其</span><span style="color:#34495e;">capacity</span><span style="color:#34495e;">和</span><span style="color:#34495e;">size</span><span style="color:#34495e;">匹配。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">vec.clear();vec.shrink_to_fit();</span><span style="color:#34495e;">：清空内容，且释放内存。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">7</span><span style="color:#34495e;">）</span><span style="color:#34495e;">vector </span><span style="color:#34495e;">扩容为什么要以</span><span style="color:#34495e;">1.5</span><span style="color:#34495e;">倍或者</span><span style="color:#34495e;">2</span><span style="color:#34495e;">倍扩容</span><span style="color:#34495e;">?</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">根据查阅的资料显示，考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以</span><span style="color:#34495e;">2</span><span style="color:#34495e;">倍的方式扩容，或者以</span><span style="color:#34495e;">1.5</span><span style="color:#34495e;">倍的方式扩容。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">以</span><span style="color:#34495e;">2</span><span style="color:#34495e;">倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为</span><span style="color:#34495e;">(1,2)</span><span style="color:#34495e;">之间：</span></span></p> 
<p style="margin-left:0cm;"></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">8</span><span style="color:#34495e;">）</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">的常用函数</span></strong></span></p> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><code><span style="color:#000000;">vector</span><span style="color:#999999;">&lt;</span><span style="color:#0077aa;">int</span><span style="color:#999999;">&gt;</span><span style="color:#dd4a68;">vec</span><span style="color:#999999;">(</span><span style="color:#990055;">10</span><span style="color:#999999;">,</span><span style="color:#990055;">100</span><span style="color:#999999;">);</span></code><code>创建<span style="color:#990055;"><span style="background-color:#ffffff;">10</span></span>个元素<span style="background-color:#ffffff;"><span style="color:#999999;">,</span></span>每个元素值为<span style="color:#990055;"><span style="background-color:#ffffff;">100</span></span></code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">vec</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">resize</span><span style="color:#999999;">(</span>r<span style="color:#999999;"><span style="background-color:#ffffff;">,</span></span>vector<span style="color:#999999;">&lt;</span><span style="color:#0077aa;">int</span><span style="color:#999999;">&gt;(</span>c<span style="color:#999999;">,</span><span style="color:#990055;">0</span><span style="color:#999999;">));</span>二维数组初始化</code></span><span style="background-color:#ffffff;"><span style="color:#dd4a68;">reverse</span><span style="color:#999999;">(</span></span>vec<span style="background-color:#ffffff;"><span style="color:#999999;">.</span><span style="color:#dd4a68;">begin</span><span style="color:#999999;">(),</span></span>vec<span style="background-color:#ffffff;"><span style="color:#999999;">.</span><span style="color:#dd4a68;">end</span><span style="color:#999999;">())</span></span>将元素翻转<span style="background-color:#ffffff;"><span style="color:#dd4a68;">sort</span><span style="color:#999999;">(</span><code><span style="color:#000000;">vec</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">begin</span><span style="color:#999999;">(),</span>vec<span style="color:#999999;">.</span><span style="color:#dd4a68;">end</span><span style="color:#999999;">());</span>排序，默认升序排列</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">vec</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">push_back</span><span style="color:#999999;">(</span>val<span style="color:#999999;"><span style="background-color:#ffffff;">);</span></span>尾部插入数字</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">vec</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">size</span><span style="color:#999999;">();</span>向量大小</code></span><span style="background-color:#ffffff;"><span style="color:#dd4a68;">find</span><span style="color:#999999;">.</span></span>vec<span style="background-color:#ffffff;"><span style="color:#999999;">.</span><span style="color:#dd4a68;">begin</span><span style="color:#999999;">(),</span></span>vec<span style="background-color:#ffffff;"><span style="color:#999999;">.</span><span style="color:#dd4a68;">end</span><span style="color:#999999;">(),</span><span style="color:#990055;">1</span><span style="color:#999999;">);</span></span>查找元素</pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><code><span style="color:#000000;">iterator </span><span style="color:#9a6e3a;"><span style="background-color:#ffffff;">=</span></span>vec<span style="color:#999999;">.</span><span style="color:#dd4a68;">erase</span><span style="color:#999999;">(</span>iterator<span style="color:#999999;"><span style="background-color:#ffffff;">)</span></span>删除元素</code></span></pre> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>5.</strong><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">list </span><span style="color:#34495e;">底层原理及其相关面试题</span></strong></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">1</span><span style="color:#34495e;">）</span><span style="color:#34495e;">list</span><span style="color:#34495e;">的底层原理</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">list</span><span style="color:#34495e;">的底层是一个<strong>双向链表</strong>，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">list</span><span style="color:#34495e;">不支持随机存取，<strong>适合需要大量的插入和删除</strong>，而不关心随即存取的应用场景。</span></span></p> 
<p style="margin-left:0cm;"><img alt="" height="676" src="https://images2.imgbox.com/cf/b4/IbRwgU6Y_o.png" width="975"></p> 
<p></p> 
<p style="margin-left:0cm;"></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">2</span><span style="color:#34495e;">）</span><span style="color:#34495e;">list</span><span style="color:#34495e;">的常用函数</span></strong></span></p> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><code><span style="color:#000000;">list</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">push_back</span><span style="color:#999999;">(</span>elem<span style="color:#999999;"><span style="background-color:#ffffff;">)</span></span>在尾部加入一个数据</code></span></pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><code><span style="color:#000000;">list</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">pop_back</span><span style="color:#999999;">()</span>删除尾部数据</code></span></pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><code><span style="color:#000000;">list</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">push_front</span><span style="color:#999999;">(</span>elem<span style="color:#999999;"><span style="background-color:#ffffff;">)</span></span>在头部插入一个数据</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">list</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">pop_front</span><span style="color:#999999;">()</span>删除头部数据</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">list</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">size</span><span style="color:#999999;">()</span>返回容器中实际数据的个数</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">list</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">sort</span><span style="color:#999999;">()</span> 排序，默认由小到大</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">list</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">unique</span><span style="color:#999999;">()</span>移除数值相同的连续元素</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">list</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">back</span><span style="color:#999999;">()</span> 取尾部迭代器</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">list</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">erase</span><span style="color:#999999;">(</span>iterator<span style="color:#999999;"><span style="background-color:#ffffff;">)</span></span>删除一个元素，参数是迭代器，返回的是删除迭代器的下一个位置</code></span>
</pre> 
<p style="margin-left:.0001pt;text-align:left;"><strong>6.deque底层原理面试题</strong></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">deque</span><span style="color:#34495e;">的底层原理</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">deque</span><span style="color:#34495e;">是一个双向开口的连续线性空间（<strong>双端队列</strong>），在头尾两端进行元素的插入跟删除操作都有理想的时间复杂度。</span></span></p> 
<p style="margin-left:0cm;"><img alt="" height="712" src="https://images2.imgbox.com/94/c6/SI61dDOL_o.png" width="828"></p> 
<p></p> 
<p style="margin-left:0cm;"></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">2</span><span style="color:#34495e;">）什么情况下用</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">，什么情况下用</span><span style="color:#34495e;">list</span><span style="color:#34495e;">，什么情况下用</span><span style="color:#34495e;">deque</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">vector</span><span style="color:#34495e;">可以随机存储元素（即可以通过公式直接计算出元素地址，而不需要挨个查找），但在非尾部插入删除数据时，效率很低，适合对象简单，对象数量变化不大，随机访问频繁。除非必要，我们尽可能选择使用</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">而非</span><span style="color:#34495e;">deque</span><span style="color:#34495e;">，因为</span><span style="color:#34495e;">deque</span><span style="color:#34495e;">的迭代器比</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">迭代器复杂很多。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">list</span><span style="color:#34495e;">不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁，比如写多读少的场景。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">需要从首尾两端进行插入或删除操作的时候需要选择</span><span style="color:#34495e;">deque</span><span style="color:#34495e;">。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">3</span><span style="color:#34495e;">）</span><span style="color:#34495e;">deque</span><span style="color:#34495e;">的常用函数</span></strong></span></p> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><code><span style="color:#000000;">deque</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">push_back</span><span style="color:#999999;">(</span>elem<span style="color:#999999;"><span style="background-color:#ffffff;">)</span></span>在尾部加入一个数据。</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">deque</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">pop_back</span><span style="color:#999999;">()</span>删除尾部数据。</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">deque</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">push_front</span><span style="color:#999999;">(</span>elem<span style="color:#999999;"><span style="background-color:#ffffff;">)</span></span>在头部插入一个数据。</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">deque</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">pop_front</span><span style="color:#999999;">()</span>删除头部数据。</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">deque</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">size</span><span style="color:#999999;">()</span> 返回容器中实际数据的个数。</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">deque</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">at</span><span style="color:#999999;">(</span>idx<span style="color:#999999;"><span style="background-color:#ffffff;">)</span></span>传回索引idx所指的数据，如果idx越界，抛出out_of_range。</code></span></pre> 
<p style="margin-left:.0001pt;text-align:left;"><strong>7.vector怎么分配空间？</strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#34495e;">由于</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">的内存占用空间只增不减，比如你首先分配了</span><span style="color:#34495e;">10,000</span><span style="color:#34495e;">个字节，然后</span><span style="color:#34495e;">erase</span><span style="color:#34495e;">掉后面</span><span style="color:#34495e;">9,999</span><span style="color:#34495e;">个，留下一个有效元素，但是内存占用仍为</span><span style="color:#34495e;">10,000</span><span style="color:#34495e;">个。所有内存空间是在</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">析构时候才能被系统回收。</span><span style="color:#34495e;">empty()</span><span style="color:#34495e;">用来检测容器是否为空的，</span><span style="color:#34495e;">clear()</span><span style="color:#34495e;">可以清空所有元素。但是即使</span><span style="color:#34495e;">clear()</span><span style="color:#34495e;">，</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">所占用的内存空间依然如故，无法保证内存的回收。</span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">如果需要空间动态缩小，可以考虑使用</span><span style="color:#34495e;">deque</span><span style="color:#34495e;">。如果</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">，可以用</span><span style="color:#34495e;">swap()</span><span style="color:#34495e;">来帮助你释放内存。</span></span></p> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><span style="color:#dd4a68;">vector</span><span style="color:#999999;">(</span></span>Vec<span style="background-color:#ffffff;"><span style="color:#999999;">).</span><span style="color:#dd4a68;">swap</span><span style="color:#999999;">(</span></span>Vec<span style="background-color:#ffffff;"><span style="color:#999999;">);</span></span>//将Vec的内存清除； 
<span style="background-color:#ffffff;"><span style="color:#dd4a68;">vector</span><span style="color:#999999;">().</span><span style="color:#dd4a68;">swap</span><span style="color:#999999;">(</span></span>Vec<span style="background-color:#ffffff;"><span style="color:#999999;">);</span></span>//清空Vec的内存；</pre> 
<p style="margin-left:.0001pt;text-align:left;"><strong>8.如何在共享内存下使用STL标准库？</strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#34495e;">1) </span><span style="color:#34495e;">想像一下把</span><span style="color:#34495e;">STL</span><span style="color:#34495e;">容器，例如</span><span style="color:#34495e;">map, vector, list</span><span style="color:#34495e;">等等，放入共享内存中，</span><span style="color:#34495e;">IPC</span><span style="color:#34495e;">一旦有了这些强大的通用数据结构做辅助，无疑进程间通信的能力一下子强大了很多。</span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">我们没必要再为共享内存设计其他额外的数据结构，另外，</span><span style="color:#34495e;">STL</span><span style="color:#34495e;">的高度可扩展性将为</span><span style="color:#34495e;">IPC</span><span style="color:#34495e;">所驱使。</span><span style="color:#34495e;">STL</span><span style="color:#34495e;">容器被良好的封装，默认情况下有它们自己的内存管理方案。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">当一个元素被插入到一个</span><span style="color:#34495e;">STL</span><span style="color:#34495e;">列表</span><span style="color:#34495e;">(list)</span><span style="color:#34495e;">中时，列表容器自动为其分配内存，保存数据。考虑到要将</span><span style="color:#34495e;">STL</span><span style="color:#34495e;">容器放到共享内存中，而容器却自己在堆上分配内存。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">一个最笨拙的办法是在堆上构造</span><span style="color:#34495e;">STL</span><span style="color:#34495e;">容器，然后把容器复制到共享内存，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本是个不可能完成的任务。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">2) </span><span style="color:#34495e;">假设进程</span><span style="color:#34495e;">A</span><span style="color:#34495e;">在共享内存中放入了数个容器，进程</span><span style="color:#34495e;">B</span><span style="color:#34495e;">如何找到这些容器呢？</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">一个方法就是进程</span><span style="color:#34495e;">A</span><span style="color:#34495e;">把容器放在共享内存中的确定地址上（</span><span style="color:#34495e;">fixed offsets</span><span style="color:#34495e;">），则进程</span><span style="color:#34495e;">B</span><span style="color:#34495e;">可以从该已知地址上获取容器。另外一个改进点的办法是，进程</span><span style="color:#34495e;">A</span><span style="color:#34495e;">先在共享内存某块确定地址上放置一个</span><span style="color:#34495e;">map</span><span style="color:#34495e;">容器，然后进程</span><span style="color:#34495e;">A</span><span style="color:#34495e;">再创建其他容器，然后给其取个名字和地址一并保存到这个</span><span style="color:#34495e;">map</span><span style="color:#34495e;">容器里。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">进程</span><span style="color:#34495e;">B</span><span style="color:#34495e;">知道如何获取该保存了地址映射的</span><span style="color:#34495e;">map</span><span style="color:#34495e;">容器，然后同样再根据名字取得其他容器的地址。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>9.map的插入方式有几种？</strong></p> 
<p style="margin-left:.0001pt;text-align:left;">1) 用insert函数插入pair数据，</p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">mapStudent</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">insert</span><span style="color:#999999;">(</span><span style="color:#000000;">pair</span><span style="color:#9a6e3a;">&lt;</span><span style="color:#0077aa;">int</span><span style="color:#999999;">,</span><span style="color:#000000;"> string</span><span style="color:#9a6e3a;">&gt;</span><span style="color:#999999;">(</span><span style="color:#990055;">1</span><span style="color:#999999;">,</span> <span style="color:#669900;">"student_one"</span><span style="color:#999999;">));</span></p> 
<p style="margin-left:.0001pt;text-align:left;">2) 用insert函数插入value_type数据</p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">mapStudent</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">insert</span><span style="color:#999999;">(</span><span style="color:#000000;">map</span><span style="color:#9a6e3a;">&lt;</span><span style="color:#0077aa;">int</span><span style="color:#999999;">,</span><span style="color:#000000;"> string</span><span style="color:#9a6e3a;">&gt;::</span><span style="color:#000000;">value_type </span><span style="color:#999999;">(</span><span style="color:#990055;">1</span><span style="color:#999999;">,</span> <span style="color:#669900;">"student_one"</span><span style="color:#999999;">));</span></p> 
<p style="margin-left:.0001pt;text-align:left;">3) 在insert函数中使用make_pair()函数</p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">mapStudent</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">insert</span><span style="color:#999999;">(</span><span style="color:#dd4a68;">make_pair</span><span style="color:#999999;">(</span><span style="color:#990055;">1</span><span style="color:#999999;">,</span> <span style="color:#669900;">"student_one"</span><span style="color:#999999;">));</span></p> 
<p style="margin-left:.0001pt;text-align:left;">4) 用数组方式插入数据</p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">mapStudent</span><span style="color:#999999;">[</span><span style="color:#990055;">1</span><span style="color:#999999;">]</span> <span style="color:#9a6e3a;">=</span> <span style="color:#669900;">"student_one"</span><span style="color:#999999;">;</span></p> 
<p style="margin-left:.0001pt;text-align:left;">10. map 、set、multiset、multimap 底层原理及其相关面试题</p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">1</span><span style="color:#34495e;">）</span><span style="color:#34495e;">map </span><span style="color:#34495e;">、</span><span style="color:#34495e;">set</span><span style="color:#34495e;">、</span><span style="color:#34495e;">multiset</span><span style="color:#34495e;">、</span><span style="color:#34495e;">multimap</span><span style="color:#34495e;">的底层原理</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">map </span><span style="color:#34495e;">、</span><span style="color:#34495e;">set</span><span style="color:#34495e;">、</span><span style="color:#34495e;">multiset</span><span style="color:#34495e;">、</span><span style="color:#34495e;">multimap</span><span style="color:#34495e;">的底层实现都是<strong>红黑树</strong>，</span><span style="color:#34495e;">epoll</span><span style="color:#34495e;">模型的底层数据结构也是红黑树，</span><span style="color:#34495e;">linux</span><span style="color:#34495e;">系统中</span><span style="color:#34495e;">CFS</span><span style="color:#34495e;">进程调度算法，也用到红黑树。</span></span></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"><img alt="" height="542" src="https://images2.imgbox.com/0d/74/G9ob93y1_o.png" width="868"></p> 
<p></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">红黑树的特性：</span></span></p> 
<ol><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">每个结点或是红色或是黑色；</span></span></li><li><span style="background-color:#ffffff;"><span style="color:#34495e;">根结点是黑色；</span></span></li><li><span style="background-color:#ffffff;"><span style="color:#34495e;">每个叶结点是黑的；</span></span></li><li><span style="background-color:#ffffff;"><span style="color:#34495e;">如果一个结点是红的，则它的两个儿子均是黑色；</span></span></li><li><span style="background-color:#ffffff;"><span style="color:#34495e;">每个结点到其子孙结点的所有路径上包含相同数目的黑色结点。</span></span></li></ol> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">对于</span><span style="color:#34495e;">STL</span><span style="color:#34495e;">里的</span><span style="color:#34495e;">map</span><span style="color:#34495e;">容器，</span><span style="color:#34495e;">count</span><span style="color:#34495e;">方法与</span><span style="color:#34495e;">find</span><span style="color:#34495e;">方法，都可以用来判断一个</span><span style="color:#34495e;">key</span><span style="color:#34495e;">是否出现，</span><span style="color:#34495e;">mp.count(key) &gt; 0</span><span style="color:#34495e;">统计的是</span><span style="color:#34495e;">key</span><span style="color:#34495e;">出现的次数，因此只能为</span><span style="color:#34495e;">0/1</span><span style="color:#34495e;">，而</span><span style="color:#34495e;">mp.find(key) != mp.end()</span><span style="color:#34495e;">则表示</span><span style="color:#34495e;">key</span><span style="color:#34495e;">存在。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">2</span><span style="color:#34495e;">）</span><span style="color:#34495e;">map </span><span style="color:#34495e;">、</span><span style="color:#34495e;">set</span><span style="color:#34495e;">、</span><span style="color:#34495e;">multiset</span><span style="color:#34495e;">、</span><span style="color:#34495e;">multimap</span><span style="color:#34495e;">的特点</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">set</span><span style="color:#34495e;">和</span><span style="color:#34495e;">multiset</span><span style="color:#34495e;">会根据特定的排序准则自动将元素排序，</span><span style="color:#34495e;">set</span><span style="color:#34495e;">中元素不允许重复，</span><span style="color:#34495e;">multiset</span><span style="color:#34495e;">可以重复。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">map</span><span style="color:#34495e;">和</span><span style="color:#34495e;">multimap</span><span style="color:#34495e;">将</span><span style="color:#34495e;">key</span><span style="color:#34495e;">和</span><span style="color:#34495e;">value</span><span style="color:#34495e;">组成的</span><span style="color:#34495e;">pair</span><span style="color:#34495e;">作为元素，根据</span><span style="color:#34495e;">key</span><span style="color:#34495e;">的排序准则自动将元素排序（因为红黑树也是二叉搜索树，所以</span><span style="color:#34495e;">map</span><span style="color:#34495e;">默认是按</span><span style="color:#34495e;">key</span><span style="color:#34495e;">排序的），</span><span style="color:#34495e;">map</span><span style="color:#34495e;">中元素的</span><span style="color:#34495e;">key</span><span style="color:#34495e;">不允许重复，</span><span style="color:#34495e;">multimap</span><span style="color:#34495e;">可以重复。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">map</span><span style="color:#34495e;">和</span><span style="color:#34495e;">set</span><span style="color:#34495e;">的增删改查速度为都是</span><span style="color:#34495e;">logn</span><span style="color:#34495e;">，是比较高效的。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">3</span><span style="color:#34495e;">）为何</span><span style="color:#34495e;">map</span><span style="color:#34495e;">和</span><span style="color:#34495e;">set</span><span style="color:#34495e;">的插入删除效率比其他序列容器高，而且每次</span><span style="color:#34495e;">insert</span><span style="color:#34495e;">之后，以前保存的</span><span style="color:#34495e;">iterator</span><span style="color:#34495e;">不会失效？</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">因为存储的是结点，不需要内存拷贝和内存移动。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">因为插入操作只是结点指针换来换去，结点内存没有改变。而</span><span style="color:#34495e;">iterator</span><span style="color:#34495e;">就像指向结点的指针，内存没变，指向内存的指针也不会变。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">4</span><span style="color:#34495e;">）为何</span><span style="color:#34495e;">map</span><span style="color:#34495e;">和</span><span style="color:#34495e;">set</span><span style="color:#34495e;">不能像</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">一样有个</span><span style="color:#34495e;">reserve</span><span style="color:#34495e;">函数来预分配数据</span><span style="color:#34495e;">?</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">因为在</span><span style="color:#34495e;">map</span><span style="color:#34495e;">和</span><span style="color:#34495e;">set</span><span style="color:#34495e;">内部存储的已经不是元素本身了，而是包含元素的结点。也就是说</span><span style="color:#34495e;">map</span><span style="color:#34495e;">内部使用的</span><span style="color:#34495e;">Alloc</span><span style="color:#34495e;">并不是</span><span style="color:#34495e;">map&lt;Key, Data, Compare, Alloc&gt;</span><span style="color:#34495e;">声明的时候从参数中传入的</span><span style="color:#34495e;">Alloc</span><span style="color:#34495e;">。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">5</span><span style="color:#34495e;">）</span><span style="color:#34495e;">map </span><span style="color:#34495e;">、</span><span style="color:#34495e;">set</span><span style="color:#34495e;">、</span><span style="color:#34495e;">multiset</span><span style="color:#34495e;">、</span><span style="color:#34495e;">multimap</span><span style="color:#34495e;">的常用函数</span></strong></span></p> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><code><span style="color:#000000;">it map</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">begin</span><span style="color:#999999;">()</span></code><code> 返回指向容器起始位置的迭代器（iterator） </code></span></pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><code><span style="color:#000000;">it map</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">end</span><span style="color:#999999;">()</span>         </code><code><span style="color:#000000;">返回指向容器末尾位置的迭代器</span></code></span></pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><span style="color:#0077aa;">bool</span><code><span style="color:#000000;"> map</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">empty</span><span style="color:#999999;">()</span>      </code><code><span style="color:#000000;">若容器为空，则返回</span><span style="color:#990055;"><span style="background-color:#ffffff;">true</span></span>，否则<span style="color:#990055;"><span style="background-color:#ffffff;">false</span></span></code></span></pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><code><span style="color:#000000;">it map</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">find</span><span style="color:#999999;">(</span>k<span style="color:#999999;"><span style="background-color:#ffffff;">)</span></span>寻找键值为k的元素，并用返回其地址</code></span></pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><span style="color:#0077aa;">int</span></span> map<span style="background-color:#ffffff;"><span style="color:#999999;">.</span><span style="color:#dd4a68;">size</span><span style="color:#999999;">()</span></span>返回map中已存在元素的数量</pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><code><span style="color:#000000;">map</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">insert</span><span style="color:#999999;">({<!-- --></span><span style="color:#0077aa;">int</span><span style="color:#999999;">,</span>string<span style="color:#999999;"><span style="background-color:#ffffff;">})</span></span>插入元素</code></span><span style="background-color:#ffffff;"><span style="color:#0077aa;">for（</span></span>itor <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">=</span></span> map<span style="background-color:#ffffff;"><span style="color:#999999;">.</span><span style="color:#dd4a68;">begin</span><span style="color:#999999;">();</span></span> itor <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">!=</span></span> map<span style="background-color:#ffffff;"><span style="color:#999999;">.</span><span style="color:#dd4a68;">end</span><span style="color:#999999;">();)</span></span><span style="background-color:#ffffff;"><span style="color:#999999;">{<!-- --></span></span>   
<span style="background-color:#ffffff;"><span style="color:#0077aa;">        if</span></span> <span style="background-color:#ffffff;"><span style="color:#999999;">(</span></span>itor<span style="background-color:#ffffff;"><span style="color:#9a6e3a;">-&gt;</span></span>second <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">==</span></span>"target"<span style="color:#999999;">)
                </span> map<span style="background-color:#ffffff;"><span style="color:#999999;">.</span><span style="color:#dd4a68;">erase</span><span style="color:#999999;">(</span></span>itor<span style="background-color:#ffffff;"><span style="color:#9a6e3a;">++</span><span style="color:#999999;">)</span></span>;<span style="background-color:#ffffff;"><code> // erase之后，令当前迭代器指向其后继。  </code><span style="color:#0077aa;">        else</span></span>        
<span style="background-color:#ffffff;"><span style="color:#9a6e3a;">                ++</span></span>itor<span style="background-color:#ffffff;"><span style="color:#999999;">;</span></span>
<span style="background-color:#ffffff;"><span style="color:#999999;">}</span></span></pre> 
<p style="margin-left:.0001pt;text-align:left;"><strong> 11. unordered_map、unordered_set 底层原理及其相关面试题</strong></p> 
<h2 style="margin-left:0;text-align:justify;"><strong><span style="color:#34495e;">unordered_map</span><span style="color:#34495e;">、</span><span style="color:#34495e;">unordered_set </span><span style="color:#34495e;">底层原理及其相关面试题</span></strong></h2> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">1</span><span style="color:#34495e;">）</span><span style="color:#34495e;">unordered_map</span><span style="color:#34495e;">、</span><span style="color:#34495e;">unordered_set</span><span style="color:#34495e;">的底层原理</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">unordered_map</span><span style="color:#34495e;">的底层是一个防冗余的哈希表（采用除留余数法）。哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，时间复杂度为</span><span style="color:#34495e;">O(1)</span><span style="color:#34495e;">；而代价仅仅是消耗比较多的内存。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数（一般使用除留取余法），也叫做散列函数），使得每个元素的</span><span style="color:#34495e;">key</span><span style="color:#34495e;">都与一个函数值（即数组下标，</span><span style="color:#34495e;">hash</span><span style="color:#34495e;">值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照</span><span style="color:#34495e;">key</span><span style="color:#34495e;">为每一个元素</span><span style="color:#34495e;">“</span><span style="color:#34495e;">分类</span><span style="color:#34495e;">”</span><span style="color:#34495e;">，然后将这个元素存储在相应</span><span style="color:#34495e;">“</span><span style="color:#34495e;">类</span><span style="color:#34495e;">”</span><span style="color:#34495e;">所对应的地方，称为桶。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">但是，不能够保证每个元素的</span><span style="color:#34495e;">key</span><span style="color:#34495e;">与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了</span><span style="color:#34495e;">“</span><span style="color:#34495e;">冲突</span><span style="color:#34495e;">”</span><span style="color:#34495e;">，换句话说，就是把不同的元素分在了相同的</span><span style="color:#34495e;">“</span><span style="color:#34495e;">类</span><span style="color:#34495e;">”</span><span style="color:#34495e;">之中。</span> <span style="color:#34495e;">一般可采用拉链法解决冲突：</span></span></p> 
<p style="margin-left:0cm;"><img alt="" height="506" src="https://images2.imgbox.com/1d/ca/ptKCThpy_o.png" width="956"></p> 
<p></p> 
<p style="margin-left:0cm;"></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">2</span><span style="color:#34495e;">）哈希表的实现</span></strong></span></p> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><span style="color:#990055;">#</span><span style="color:#0077aa;">include</span> <span style="color:#669900;">&lt;iostream&gt;</span></span></pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><span style="color:#990055;">#</span><span style="color:#0077aa;">include</span> <span style="color:#669900;">&lt;vector&gt;</span></span></pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><span style="color:#990055;">#</span><span style="color:#0077aa;">include</span> <span style="color:#669900;">&lt;list&gt;</span></span></pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><span style="color:#990055;">#</span><span style="color:#0077aa;">include</span> <span style="color:#669900;">&lt;random&gt;</span></span></pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><span style="color:#990055;">#</span><span style="color:#0077aa;">include</span> <span style="color:#669900;">&lt;ctime&gt;</span></span></pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><span style="color:#0077aa;">using </span></span>namespace std<span style="background-color:#ffffff;"><span style="color:#999999;">;</span></span>
<span style="background-color:#ffffff;"><span style="color:#0077aa;">const </span></span>int hashsize <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">=</span></span>12<span style="color:#999999;">;</span><span style="background-color:#ffffff;">//定一个节点的结构体</span>
<span style="background-color:#ffffff;"><span style="color:#0077aa;">template</span></span>&lt;<span style="color:#0077aa;">typename</span> T<span style="background-color:#ffffff;"><span style="color:#999999;">,</span></span>typename U<span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&gt;</span></span>
<span style="background-color:#ffffff;"><span style="color:#0077aa;">struct </span></span>HashNode{
  T _key<span style="background-color:#ffffff;"><span style="color:#999999;">;</span></span><span style="background-color:#ffffff;"><code><span style="color:#000000;"> U _value</span><span style="color:#999999;"><span style="background-color:#ffffff;">;</span></span></code></span><span style="background-color:#ffffff;"><span style="color:#999999;">};</span></span>
<span style="background-color:#ffffff;">//使用拉链法实现哈希表类</span>
<span style="background-color:#ffffff;"><span style="color:#0077aa;">template</span></span>&lt;<span style="color:#0077aa;">typename</span> T<span style="background-color:#ffffff;"><span style="color:#999999;">,</span></span>typename U<span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&gt;</span></span>
<span style="background-color:#ffffff;"><span style="color:#0077aa;">class </span></span>HashTable<span style="background-color:#ffffff;"><span style="color:#999999;">{<!-- --></span></span>
<span style="background-color:#ffffff;"><span style="color:#0077aa;">public</span></span><span style="background-color:#ffffff;"><span style="color:#9a6e3a;">:</span></span><code>        <span style="background-color:#ffffff;"><span style="color:#dd4a68;">HashTable</span></span><span style="background-color:#ffffff;"><span style="color:#999999;">()</span></span><span style="background-color:#ffffff;"><span style="color:#9a6e3a;">;</span></span>       
        <span style="background-color:#ffffff;"><span style="color:#dd4a68;">vec</span></span><span style="background-color:#ffffff;"><span style="color:#999999;">(</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">hashsize</span></span><span style="background-color:#ffffff;"><span style="color:#999999;">);</span></span></code><code> <span style="color:#999999;">{}</span>//类中的容器需要通过构造函数来指定大小   </code><span style="background-color:#ffffff;"><span style="color:#9a6e3a;">          ~</span><span style="color:#dd4a68;">HashTable</span><span style="color:#999999;">()</span><span style="color:#999999;">{}
</span></span><span style="background-color:#ffffff;"><span style="color:#0077aa;">bool </span><span style="color:#dd4a68;">insert_data</span><span style="color:#999999;">(</span><span style="color:#0077aa;">const</span></span> T <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&amp;</span></span>key<span style="background-color:#ffffff;"><span style="color:#999999;">,</span></span> <span style="background-color:#ffffff;"><span style="color:#0077aa;">const</span></span> U <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&amp;</span></span>value<span style="background-color:#ffffff;"><span style="color:#999999;">);</span></span>  
<span style="background-color:#ffffff;"><span style="color:#0077aa;">int </span></span>hash<span style="color:#999999;">(</span><span style="color:#0077aa;">const</span> T <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&amp;</span></span>key<span style="background-color:#ffffff;"><span style="color:#999999;">);</span></span><span style="background-color:#ffffff;"><code><span style="color:#0077aa;"><span style="background-color:#ffffff;">bool </span></span><span style="color:#dd4a68;">hash_find</span><span style="color:#999999;">(</span><span style="color:#0077aa;">const</span> T <span style="color:#9a6e3a;"><span style="background-color:#ffffff;">&amp;</span></span>key<span style="color:#999999;"><span style="background-color:#ffffff;">);</span></span></code></span><span style="background-color:#ffffff;"><span style="color:#0077aa;">private</span><span style="color:#9a6e3a;">:</span></span></pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><code><span style="color:#000000;">    vector</span><span style="color:#9a6e3a;"><span style="background-color:#ffffff;">&lt;</span></span>list<span style="color:#9a6e3a;"><span style="background-color:#ffffff;">&lt;</span></span>HashNode<span style="color:#9a6e3a;"><span style="background-color:#ffffff;">&lt;</span></span>T<span style="color:#999999;"><span style="background-color:#ffffff;">,</span></span> U<span style="color:#9a6e3a;"><span style="background-color:#ffffff;">&gt;&gt;&gt;</span></span> vec<span style="color:#999999;">;</span>//将节点存储到容器中</code></span></pre> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><span style="color:#999999;">};</span></span>
<span style="background-color:#ffffff;">//哈希函数（除留取余）</span>
<span style="background-color:#ffffff;"><span style="color:#0077aa;">template</span></span>&lt;<span style="color:#0077aa;">typename</span>T<span style="background-color:#ffffff;"><span style="color:#999999;">,</span></span> <span style="background-color:#ffffff;"><span style="color:#0077aa;">typename</span></span> U<span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&gt;</span></span>
<span style="background-color:#ffffff;"><span style="color:#0077aa;">int</span></span> HashTable<span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&lt;</span></span>T<span style="background-color:#ffffff;"><span style="color:#999999;">,</span></span> U<span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&gt;::</span><span style="color:#dd4a68;">hash</span><span style="color:#999999;">(</span><span style="color:#0077aa;">const</span></span> T <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&amp;</span></span>key<span style="background-color:#ffffff;"><span style="color:#999999;">)</span></span>
<span style="background-color:#ffffff;"><span style="color:#999999;">{<!-- --></span></span>   
<span style="background-color:#ffffff;"><span style="color:#0077aa;">return</span></span> key <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">%</span></span> <span style="background-color:#ffffff;"><span style="color:#990055;">13</span><span style="color:#999999;">;</span></span>
<span style="background-color:#ffffff;"><span style="color:#999999;">}</span></span>
<span style="background-color:#ffffff;">//哈希查找</span>
<span style="background-color:#ffffff;"><span style="color:#0077aa;">template</span></span>&lt;<span style="color:#0077aa;">typename</span> T<span style="background-color:#ffffff;"><span style="color:#999999;">,</span></span> <span style="background-color:#ffffff;"><span style="color:#0077aa;">typename</span></span> U<span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&gt;</span></span>
<span style="background-color:#ffffff;"><span style="color:#0077aa;">bool</span></span> HashTable<span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&lt;</span></span>T<span style="background-color:#ffffff;"><span style="color:#999999;">,</span></span> U<span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&gt;::</span><span style="color:#dd4a68;">hash_find</span><span style="color:#999999;">(</span><span style="color:#0077aa;">const</span></span> T <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&amp;</span></span>key<span style="background-color:#ffffff;"><span style="color:#999999;">)</span></span>
<span style="background-color:#ffffff;"><span style="color:#999999;">{<!-- --></span></span><span style="background-color:#ffffff;"><code>    <span style="color:#0077aa;"><span style="background-color:#ffffff;">int</span></span> index <span style="color:#9a6e3a;"><span style="background-color:#ffffff;">=</span></span><span style="color:#dd4a68;">hash</span><span style="color:#999999;">(</span>key<span style="color:#999999;">);</span>//计算哈希值  
    <span style="color:#0077aa;"><span style="background-color:#ffffff;">for</span></span><span style="color:#999999;">(</span><span style="color:#0077aa;">auto</span> it <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">=</span></span> vec<span style="color:#999999;"><span style="background-color:#ffffff;">[</span></span>index<span style="color:#999999;">].</span><span style="color:#dd4a68;">begin</span><span style="color:#999999;">();</span> it <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">!=</span></span> vec<span style="color:#999999;"><span style="background-color:#ffffff;">[</span></span>index<span style="color:#999999;">].</span><span style="color:#dd4a68;">end</span><span style="color:#999999;">();</span> <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">++</span></span>it<span style="color:#999999;"><span style="background-color:#ffffff;">)</span></span><span style="color:#999999;"><span style="background-color:#ffffff;">{<!-- --></span></span>       </code><span style="color:#0077aa;">        if</span></span>(key <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">==</span></span> it <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">-&gt;</span></span> _key<span style="background-color:#ffffff;"><span style="color:#999999;">)</span>//如果找到则打印其关联值<code>        <span style="color:#999999;"><span style="background-color:#ffffff;">{
</span></span>                  cout<span style="color:#9a6e3a;"><span style="background-color:#ffffff;">&lt;&lt;</span></span> it<span style="color:#9a6e3a;"><span style="background-color:#ffffff;">-&gt;</span></span>_value <span style="color:#9a6e3a;"><span style="background-color:#ffffff;">&lt;&lt;</span></span> endl<span style="color:#999999;">;</span>//输出数据前应该确认是否包含相应类型                   <span style="color:#0077aa;"><span style="background-color:#ffffff;">return </span></span><span style="color:#990055;">true</span><span style="color:#999999;">;</span></code></span><span style="background-color:#ffffff;"><code>        <span style="color:#999999;"><span style="background-color:#ffffff;">}</span></span>       
 <span style="color:#999999;"><span style="background-color:#ffffff;">}</span></span><span style="color:#0077aa;"><span style="background-color:#ffffff;">      
 return </span></span><span style="color:#990055;">false</span><span style="color:#999999;">;</span></code></span><span style="background-color:#ffffff;"><span style="color:#999999;">}</span></span><span style="background-color:#ffffff;">//插入数据</span>
<span style="background-color:#ffffff;"><span style="color:#0077aa;">template</span></span>&lt;<span style="color:#0077aa;">typename</span> T<span style="background-color:#ffffff;"><span style="color:#999999;">,</span></span>typename U<span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&gt;</span></span>
<span style="background-color:#ffffff;"><span style="color:#0077aa;">bool</span></span>HashTable<span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&lt;</span></span>T<span style="background-color:#ffffff;"><span style="color:#999999;">,</span></span> U<span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&gt;::</span><span style="color:#dd4a68;">insert_data</span><span style="color:#999999;">(</span><span style="color:#0077aa;">const</span></span> T <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&amp;</span></span>key<span style="background-color:#ffffff;"><span style="color:#999999;">,</span></span> <span style="background-color:#ffffff;"><span style="color:#0077aa;">const</span></span> U <span style="background-color:#ffffff;"><span style="color:#9a6e3a;">&amp;</span></span>value<span style="background-color:#ffffff;"><span style="color:#999999;">){<!-- --></span><code>//初始化数据
HashNode<span style="color:#9a6e3a;"><span style="background-color:#ffffff;">&lt;</span></span>T<span style="background-color:#ffffff;"><span style="color:#999999;">,</span></span> U<span style="color:#9a6e3a;"><span style="background-color:#ffffff;">&gt;</span></span> node<span style="color:#999999;"><span style="background-color:#ffffff;">;
</span></span>node<span style="color:#999999;"><span style="background-color:#ffffff;">.</span></span>_key <span style="color:#9a6e3a;"><span style="background-color:#ffffff;">=</span></span> key<span style="color:#999999;"><span style="background-color:#ffffff;">;</span></span><span style="color:#000000;">node</span><span style="color:#999999;"><span style="background-color:#ffffff;">.</span></span>_value <span style="color:#9a6e3a;"><span style="background-color:#ffffff;">=</span></span> value<span style="color:#999999;"><span style="background-color:#ffffff;">;</span></span><span style="color:#0077aa;"><span style="background-color:#ffffff;">for</span></span><span style="color:#999999;">(</span><span style="color:#0077aa;">int</span> i <span style="color:#9a6e3a;"><span style="background-color:#ffffff;">=</span></span><span style="color:#990055;">0</span><span style="color:#999999;">;</span> i<span style="color:#9a6e3a;"><span style="background-color:#ffffff;">&lt;</span></span> hashsize<span style="background-color:#ffffff;"><span style="color:#999999;">;</span></span> <span style="color:#9a6e3a;"><span style="background-color:#ffffff;">++</span></span>i<span style="color:#999999;"><span style="background-color:#ffffff;">)</span></span><span style="background-color:#ffffff;"><span style="color:#999999;">{<!-- --></span></span>        
        
    <span style="color:#0077aa;"><span style="background-color:#ffffff;">if</span></span><span style="background-color:#ffffff;"><span style="color:#999999;">(</span></span>i <span style="color:#9a6e3a;"><span style="background-color:#ffffff;">==</span></span><span style="color:#dd4a68;">hash</span><span style="color:#999999;">(</span>key<span style="color:#999999;">))</span>//如果溢出则把相应的键值添加进链表        
    <span style="color:#999999;"><span style="background-color:#ffffff;">{
</span></span>            vec<span style="color:#999999;"><span style="background-color:#ffffff;">[</span></span>i<span style="background-color:#ffffff;"><span style="color:#999999;">].</span><span style="color:#dd4a68;">push_back</span><span style="color:#999999;">(</span></span>node<span style="color:#999999;"><span style="background-color:#ffffff;">);
</span></span>            <span style="background-color:#ffffff;"><span style="color:#0077aa;">return </span></span><span style="color:#990055;">true</span><span style="color:#999999;">;
     </span><span style="background-color:#ffffff;"><span style="color:#999999;">}</span></span></code></span><span style="background-color:#ffffff;"><code><span style="color:#999999;"><span style="background-color:#ffffff;">}</span></span></code></span><span style="background-color:#ffffff;"><span style="color:#999999;">}</span></span>
</pre> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">3</span><span style="color:#34495e;">）</span><span style="color:#34495e;">unordered_map </span><span style="color:#34495e;">与</span><span style="color:#34495e;">map</span><span style="color:#34495e;">的区别？使用场景？</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">构造函数：</span><span style="color:#34495e;">unordered_map </span><span style="color:#34495e;">需要</span><span style="color:#34495e;">hash</span><span style="color:#34495e;">函数，等于函数</span><span style="color:#34495e;">;map</span><span style="color:#34495e;">只需要比较函数</span><span style="color:#34495e;">(</span><span style="color:#34495e;">小于函数</span><span style="color:#34495e;">).</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">存储结构：</span><span style="color:#34495e;">unordered_map </span><span style="color:#34495e;">采用</span><span style="color:#34495e;">hash</span><span style="color:#34495e;">表存储，</span><span style="color:#34495e;">map</span><span style="color:#34495e;">一般采用红黑树</span><span style="color:#34495e;">(RB Tree) </span><span style="color:#34495e;">实现。因此其</span><span style="color:#34495e;">memory</span><span style="color:#34495e;">数据结构是不一样的。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">总体来说，</span><span style="color:#34495e;">unordered_map </span><span style="color:#34495e;">查找速度会比</span><span style="color:#34495e;">map</span><span style="color:#34495e;">快，而且查找速度基本和数据数据量大小，属于常数级别</span><span style="color:#34495e;">;</span><span style="color:#34495e;">而</span><span style="color:#34495e;">map</span><span style="color:#34495e;">的查找速度是</span><span style="color:#34495e;">log(n)</span><span style="color:#34495e;">级别。并不一定常数就比</span><span style="color:#34495e;">log(n)</span><span style="color:#34495e;">小，</span><span style="color:#34495e;">hash</span><span style="color:#34495e;">还有</span><span style="color:#34495e;">hash</span><span style="color:#34495e;">函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑</span><span style="color:#34495e;">unordered_map </span><span style="color:#34495e;">。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，</span><span style="color:#34495e;">unordered_map </span><span style="color:#34495e;">可能会让你陷入尴尬，特别是当你的</span><span style="color:#34495e;">unordered_map </span><span style="color:#34495e;">对象特别多时，你就更无法控制了，而且</span><span style="color:#34495e;">unordered_map </span><span style="color:#34495e;">的构造速度较慢。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">（</span><span style="color:#34495e;">4</span><span style="color:#34495e;">）</span><span style="color:#34495e;">unordered_map</span><span style="color:#34495e;">、</span><span style="color:#34495e;">unordered_set</span><span style="color:#34495e;">的常用函数</span></strong></span></p> 
<pre style="margin-left:.0001pt;"><span style="background-color:#ffffff;"><code><span style="color:#000000;">unordered_map</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">begin</span><span style="color:#999999;">()</span>返回指向容器起始位置的迭代器（iterator）</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">unordered_map</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">end</span><span style="color:#999999;">()</span>返回指向容器末尾位置的迭代器</code><code>unordered_map<span style="color:#999999;">.</span><span style="color:#dd4a68;">cbegin</span><span style="color:#999999;">()</span>返回指向容器起始位置的常迭代器（const_iterator） </code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">unordered_map</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">cend</span><span style="color:#999999;">()</span>返回指向容器末尾位置的常迭代器</code><code>unordered_map<span style="color:#999999;">.</span><span style="color:#dd4a68;">size</span><span style="color:#999999;">()</span>返回有效元素个数 </code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">unordered_map</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">insert</span><span style="color:#999999;">(</span>key<span style="color:#999999;"><span style="background-color:#ffffff;">)</span></span>插入元素</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">unordered_map</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">find</span><span style="color:#999999;">(</span>key<span style="color:#999999;"><span style="background-color:#ffffff;">)</span></span>查找元素，返回迭代器</code></span><span style="background-color:#ffffff;"><code><span style="color:#000000;">unordered_map</span><span style="color:#999999;">.</span><span style="color:#dd4a68;">count</span><span style="color:#999999;">(</span>key<span style="color:#999999;"><span style="background-color:#ffffff;">)</span></span>　返回匹配给定主键的元素的个数</code></span>
</pre> 
<p style="margin-left:.0001pt;text-align:left;"><strong>12. 迭代器的底层机制和失效的问题</strong></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">1</span><span style="color:#34495e;">、迭代器的底层原理</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">迭代器是连接容器和算法的一种重要桥梁，通过迭代器可以在不了解容器内部原理的情况下遍历容器。它的底层实现包含两个重要的部分：萃取技术和模板偏特化。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">萃取技术（</span><span style="color:#34495e;">traits</span><span style="color:#34495e;">）可以进行类型推导，根据不同类型可以执行不同的处理流程，比如容器是</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">，那么</span><span style="color:#34495e;">traits</span><span style="color:#34495e;">必须推导出其迭代器类型为随机访问迭代器，而</span><span style="color:#34495e;">list</span><span style="color:#34495e;">则为双向迭代器。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">例如</span><span style="color:#34495e;">STL</span><span style="color:#34495e;">算法库中的</span><span style="color:#34495e;">distance</span><span style="color:#34495e;">函数，</span><span style="color:#34495e;">distance</span><span style="color:#34495e;">函数接受两个迭代器参数，然后计算他们两者之间的距离。显然对于不同的迭代器计算效率差别很大。比如对于</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">容器来说，由于内存是连续分配的，因此指针直接相减即可获得两者的距离；而</span><span style="color:#34495e;">list</span><span style="color:#34495e;">容器是链式表，内存一般都不是连续分配，因此只能通过一级一级调用</span><span style="color:#34495e;">next()</span><span style="color:#34495e;">或其他函数，每调用一次再判断迭代器是否相等来计算距离。</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">迭代器计算</span><span style="color:#34495e;">distance</span><span style="color:#34495e;">的效率为</span><span style="color:#34495e;">O(1),</span><span style="color:#34495e;">而</span><span style="color:#34495e;">list</span><span style="color:#34495e;">则为</span><span style="color:#34495e;">O(n),n</span><span style="color:#34495e;">为距离的大小。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">使用萃取技术（</span><span style="color:#34495e;">traits</span><span style="color:#34495e;">）进行类型推导的过程中会使用到模板偏特化。模板偏特化可以用来推导参数，如果我们自定义了多个类型，除非我们把这些自定义类型的特化版本写出来，否则我们只能判断他们是内置类型，并不能判断他们具体属于是个类型。</span></span></p> 
<p></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">2</span><span style="color:#34495e;">、迭代器的种类</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">输入迭代器：是只读迭代器，在每个被遍历的位置上只能读取一次。例如上面</span><span style="color:#34495e;">find</span><span style="color:#34495e;">函数参数就是输入迭代器。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">输出迭代器：是只写迭代器，在每个被遍历的位置上只能被写一次。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">前向迭代器：兼具输入和输出迭代器的能力，但是它可以对同一个位置重复进行读和写。但它不支持</span><span style="color:#34495e;">operator–</span><span style="color:#34495e;">，所以只能向前移动。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">双向迭代器：很像前向迭代器，只是它向后移动和向前移动同样容易。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">随机访问迭代器：有双向迭代器的所有功能。而且，它还提供了</span><span style="color:#34495e;">“</span><span style="color:#34495e;">迭代器算术</span><span style="color:#34495e;">”</span><span style="color:#34495e;">，即在一步内可以向前或向后跳跃任意位置，</span> <span style="color:#34495e;">包含指针的所有操作，可进行随机访问，随意移动指定的步数。支持前面四种</span><span style="color:#34495e;">Iterator</span><span style="color:#34495e;">的所有操作，并另外支持</span><span style="color:#34495e;">it + n</span><span style="color:#34495e;">、</span><span style="color:#34495e;">it – n</span><span style="color:#34495e;">、</span><span style="color:#34495e;">it += n</span><span style="color:#34495e;">、</span><span style="color:#34495e;"> it -= n</span><span style="color:#34495e;">、</span><span style="color:#34495e;">it1 – it2</span><span style="color:#34495e;">和</span><span style="color:#34495e;">it[n]</span><span style="color:#34495e;">等操作。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">3</span><span style="color:#34495e;">、迭代器失效的问题</span></strong></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">（</span><span style="color:#34495e;">1</span><span style="color:#34495e;">）插入操作</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">对于</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">和</span><span style="color:#34495e;">string</span><span style="color:#34495e;">，如果容器内存被重新分配，</span><span style="color:#34495e;">iterators,pointers,references</span><span style="color:#34495e;">失效；如果没有重新分配，那么插入点之前的</span><span style="color:#34495e;">iterator</span><span style="color:#34495e;">有效，插入点之后的</span><span style="color:#34495e;">iterator</span><span style="color:#34495e;">失效；</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">对于</span><span style="color:#34495e;">deque</span><span style="color:#34495e;">，如果插入点位于除</span><span style="color:#34495e;">front</span><span style="color:#34495e;">和</span><span style="color:#34495e;">back</span><span style="color:#34495e;">的其它位置，</span><span style="color:#34495e;">iterators,pointers,references</span><span style="color:#34495e;">失效；当我们插入元素到</span><span style="color:#34495e;">front</span><span style="color:#34495e;">和</span><span style="color:#34495e;">back</span><span style="color:#34495e;">时，</span><span style="color:#34495e;">deque</span><span style="color:#34495e;">的迭代器失效，但</span><span style="color:#34495e;">reference</span><span style="color:#34495e;">和</span><span style="color:#34495e;">pointers</span><span style="color:#34495e;">有效；</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">对于</span><span style="color:#34495e;">list</span><span style="color:#34495e;">和</span><span style="color:#34495e;">forward_list</span><span style="color:#34495e;">，所有的</span><span style="color:#34495e;">iterator,pointer</span><span style="color:#34495e;">和</span><span style="color:#34495e;">refercnce</span><span style="color:#34495e;">有效。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">（</span><span style="color:#34495e;">2</span><span style="color:#34495e;">）删除操作</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">对于</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">和</span><span style="color:#34495e;">string</span><span style="color:#34495e;">，删除点之前的</span><span style="color:#34495e;">iterators,pointers,references</span><span style="color:#34495e;">有效；</span><span style="color:#34495e;">off-the-end</span><span style="color:#34495e;">迭代器总是失效的；</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">对于</span><span style="color:#34495e;">deque</span><span style="color:#34495e;">，如果删除点位于除</span><span style="color:#34495e;">front</span><span style="color:#34495e;">和</span><span style="color:#34495e;">back</span><span style="color:#34495e;">的其它位置，</span><span style="color:#34495e;">iterators,pointers,references</span><span style="color:#34495e;">失效；当我们插入元素到</span><span style="color:#34495e;">front</span><span style="color:#34495e;">和</span><span style="color:#34495e;">back</span><span style="color:#34495e;">时，</span><span style="color:#34495e;">off-the-end</span><span style="color:#34495e;">失效，其他的</span><span style="color:#34495e;">iterators,pointers,references</span><span style="color:#34495e;">有效；</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">对于</span><span style="color:#34495e;">list</span><span style="color:#34495e;">和</span><span style="color:#34495e;">forward_list</span><span style="color:#34495e;">，所有的</span><span style="color:#34495e;">iterator,pointer</span><span style="color:#34495e;">和</span><span style="color:#34495e;">refercnce</span><span style="color:#34495e;">有效。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">对于关联容器</span><span style="color:#34495e;">map</span><span style="color:#34495e;">来说，如果某一个元素已经被删除，那么其对应的迭代器就失效了，不应该再被使用，否则会导致程序无定义的行为。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"><br><strong> 13. 为什么vector的插入操作可能会导致迭代器失效？</strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">vector</span><span style="color:#34495e;">动态增加大小时，并不是在原空间后增加新的空间，而是以原大小的两倍在另外配置一片较大的新空间，然后将内容拷贝过来，并释放原来的空间。由于操作改变了空间，所以迭代器失效。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>14. vector的reserve()和resize()方法之间有什么区别？</strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">首先，</span><span style="color:#e83e8c;">vector</span><span style="color:#34495e;">的容量</span><span style="color:#e83e8c;">capacity()</span><span style="color:#34495e;">是指在不分配更多内存的情况下可以保存的最多元素个数，而</span><span style="color:#e83e8c;">vector</span><span style="color:#34495e;">的大小</span><span style="color:#e83e8c;">size()</span><span style="color:#34495e;">是指实际包含的元素个数；</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">其次，</span><span style="color:#e83e8c;">vector</span><span style="color:#34495e;">的</span><span style="color:#e83e8c;">reserve(n)</span><span style="color:#34495e;">方法只改变</span><span style="color:#e83e8c;">vector</span><span style="color:#34495e;">的容量，如果当前容量小于</span><span style="color:#e83e8c;">n</span><span style="color:#34495e;">，则重新分配内存空间，调整容量为</span><span style="color:#e83e8c;">n</span><span style="color:#34495e;">；如果当前容量大于等于</span><span style="color:#e83e8c;">n</span><span style="color:#34495e;">，则无操作；</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">最后，</span><span style="color:#e83e8c;">vector</span><span style="color:#34495e;">的</span><span style="color:#e83e8c;">resize(n)</span><span style="color:#34495e;">方法改变</span><span style="color:#e83e8c;">vector</span><span style="color:#34495e;">的大小，如果当前容量小于</span><span style="color:#e83e8c;">n</span><span style="color:#34495e;">，则调整容量为</span><span style="color:#e83e8c;">n</span><span style="color:#34495e;">，同时将其全部元素填充为初始值；如果当前容量大于等于</span><span style="color:#e83e8c;">n</span><span style="color:#34495e;">，则不调整容量，只将其前</span><span style="color:#e83e8c;">n</span><span style="color:#34495e;">个元素填充为初始值。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong> 15. 标准库中有哪些容器？分别有什么特点？</strong></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;">    <span style="color:#34495e;">标准库中的容器主要分为三类：顺序容器、关联容器、容器适配器。</span></span></p> 
<ul><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">顺序容器包括五种类型：</span></span> 
  <ul><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#e83e8c;">array&lt;T, N&gt;</span><span style="color:#34495e;">数组：固定大小数组，支持快速随机访问，但不能插入或删除元素；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#e83e8c;">vector&lt;T&gt;</span><span style="color:#34495e;">动态数组：支持快速随机访问，尾位插入和删除的速度很快；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#e83e8c;">deque&lt;T&gt;</span><span style="color:#34495e;">双向队列：支持快速随机访问，首尾位置插入和删除的速度很快；（可以看作是</span><span style="color:#e83e8c;">vector</span><span style="color:#34495e;">的增强版，与</span><span style="color:#e83e8c;">vector</span><span style="color:#34495e;">相比，可以快速地在首位插入和删除元素）</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#e83e8c;">list&lt;T&gt;</span><span style="color:#34495e;">双向链表：只支持双向顺序访问，任何位置插入和删除的速度都很快；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#e83e8c;">forward_list&lt;T&gt;</span><span style="color:#34495e;">单向链表：只支持单向顺序访问，任何位置插入和删除的速度都很快。</span></span></li></ul></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">关联容器包含两种类型：</span></span> 
  <ul><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">map</span><span style="color:#34495e;">容器：</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#e83e8c;">map&lt;K, T&gt;</span><span style="color:#34495e;">关联数组：用于保存关键字</span><span style="color:#34495e;">-</span><span style="color:#34495e;">值对；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#e83e8c;">multimap&lt;K, T&gt;</span><span style="color:#34495e;">：关键字可重复出现的</span><span style="color:#e83e8c;">map</span><span style="color:#34495e;">；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#e83e8c;">unordered_map&lt;K, T&gt;</span><span style="color:#34495e;">：用哈希函数组织的</span><span style="color:#e83e8c;">map</span><span style="color:#34495e;">；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#e83e8c;">unordered_multimap&lt;K, T&gt;</span><span style="color:#34495e;">：关键词可重复出现的</span><span style="color:#e83e8c;">unordered_map</span><span style="color:#34495e;">；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">set</span><span style="color:#34495e;">容器：</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#e83e8c;">set&lt;T&gt;</span><span style="color:#34495e;">：只保存关键字；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#e83e8c;">multiset&lt;T&gt;</span><span style="color:#34495e;">：关键字可重复出现的</span><span style="color:#e83e8c;">set</span><span style="color:#34495e;">；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#e83e8c;">unordered_set&lt;T&gt;</span><span style="color:#34495e;">：用哈希函数组织的</span><span style="color:#e83e8c;">set</span><span style="color:#34495e;">；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#e83e8c;">unordered_multiset&lt;T&gt;</span><span style="color:#34495e;">：关键词可重复出现的</span><span style="color:#e83e8c;">unordered_set</span><span style="color:#34495e;">；</span></span></li></ul></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">容器适配器包含三种类型：</span></span> 
  <ul><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#e83e8c;">stack&lt;T&gt;</span><span style="color:#34495e;">栈、</span><span style="color:#e83e8c;">queue&lt;T&gt;</span><span style="color:#34495e;">队列、</span><span style="color:#e83e8c;">priority_queue&lt;T&gt;</span><span style="color:#34495e;">优先队列。</span></span></li></ul></li></ul> 
<p style="margin-left:.0001pt;text-align:left;"><br><strong>16. 容器内部删除一个元素</strong></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">1) </span><span style="color:#34495e;">顺序容器（序列式容器，比如</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">、</span><span style="color:#34495e;">deque</span><span style="color:#34495e;">）</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">erase</span><span style="color:#34495e;">迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效</span><span style="color:#34495e;">(list</span><span style="color:#34495e;">除外</span><span style="color:#34495e;">)</span><span style="color:#34495e;">，所以不能使用</span><span style="color:#34495e;">erase(it++)</span><span style="color:#34495e;">的方式，但是</span><span style="color:#34495e;">erase</span><span style="color:#34495e;">的返回值是下一个有效迭代器；</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">It = c.erase(it);</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">2) </span><span style="color:#34495e;">关联容器</span><span style="color:#34495e;">(</span><span style="color:#34495e;">关联式容器，比如</span><span style="color:#34495e;">map</span><span style="color:#34495e;">、</span><span style="color:#34495e;">set</span><span style="color:#34495e;">、</span><span style="color:#34495e;">multimap</span><span style="color:#34495e;">、</span><span style="color:#34495e;">multiset</span><span style="color:#34495e;">等</span><span style="color:#34495e;">)</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">erase</span><span style="color:#34495e;">迭代器只是被删除元素的迭代器失效，但是返回值是</span><span style="color:#34495e;">void</span><span style="color:#34495e;">，所以要采用</span><span style="color:#34495e;">erase(it++)</span><span style="color:#34495e;">的方式删除迭代器；</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">c.erase(it++)</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>17. vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？</strong></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;">    <span style="color:#34495e;">1) </span><span style="color:#34495e;">通过下标访问</span><span style="color:#34495e;">vector</span><span style="color:#34495e;">中的元素时会做边界检查，但该处的实现方式要看具体</span><span style="color:#34495e;">IDE</span><span style="color:#34495e;">，不同</span><span style="color:#34495e;">IDE</span><span style="color:#34495e;">的实现方式不一样，确保不可访问越界地址。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">2) map</span><span style="color:#34495e;">的下标运算符</span><span style="color:#34495e;">[]</span><span style="color:#34495e;">的作用是：将</span><span style="color:#34495e;">key</span><span style="color:#34495e;">作为下标去执行查找，并返回相应的值；如果不存在这个</span><span style="color:#34495e;">key</span><span style="color:#34495e;">，就将一个具有该</span><span style="color:#34495e;">key</span><span style="color:#34495e;">和</span><span style="color:#34495e;">value</span><span style="color:#34495e;">的某人值插入这个</span><span style="color:#34495e;">map</span><span style="color:#34495e;">。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">3) erase()</span><span style="color:#34495e;">函数，只能删除内容，不能改变容量大小</span><span style="color:#34495e;">;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">erase</span><span style="color:#34495e;">成员函数，它删除了</span><span style="color:#34495e;">itVect</span><span style="color:#34495e;">迭代器指向的元素，并且返回要被删除的</span><span style="color:#34495e;">itVect</span><span style="color:#34495e;">之后的迭代器，迭代器相当于一个智能指针</span><span style="color:#34495e;">;clear()</span><span style="color:#34495e;">函数，只能清空内容，不能改变容量大小</span><span style="color:#34495e;">;</span><span style="color:#34495e;">如果要想在删除内容的同时释放内存，那么你可以选择</span><span style="color:#34495e;">deque</span><span style="color:#34495e;">容器。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><br><strong>18. map中[ ]与find的区别？</strong></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;">    <span style="color:#34495e;">1) map</span><span style="color:#34495e;">的下标运算符</span><span style="color:#34495e;">[ ]</span><span style="color:#34495e;">的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个</span><span style="color:#34495e;">map</span><span style="color:#34495e;">。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#34495e;">2) map</span><span style="color:#34495e;">的</span><span style="color:#34495e;">find</span><span style="color:#34495e;">函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>19. STL内存优化？</strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">STL</span><span style="color:#34495e;">内存管理使用二级内存配置器。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">(1) </span></strong><strong><span style="color:#34495e;">第一级配置器：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">第一级配置器以</span><span style="color:#34495e;">malloc()</span><span style="color:#34495e;">，</span><span style="color:#34495e;">free()</span><span style="color:#34495e;">，</span><span style="color:#34495e;">realloc()</span><span style="color:#34495e;">等</span><span style="color:#34495e;">C</span><span style="color:#34495e;">函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。一级空间配置器分配的是大于</span><span style="color:#34495e;">128</span><span style="color:#34495e;">字节的空间，如果分配不成功，调用句柄释放一部分内存，如果还不能分配成功，抛出异常。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">第一级配置器只是对</span><span style="color:#34495e;">malloc</span><span style="color:#34495e;">函数和</span><span style="color:#34495e;">free</span><span style="color:#34495e;">函数的简单封装，在</span><span style="color:#34495e;">allocate</span><span style="color:#34495e;">内调用</span><span style="color:#34495e;">malloc</span><span style="color:#34495e;">，在</span><span style="color:#34495e;">deallocate</span><span style="color:#34495e;">内调用</span><span style="color:#34495e;">free</span><span style="color:#34495e;">。同时第一级配置器的</span><span style="color:#34495e;">oom_malloc</span><span style="color:#34495e;">函数，用来处理</span><span style="color:#34495e;">malloc</span><span style="color:#34495e;">失败的情况。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="color:#34495e;">(2) </span></strong><strong><span style="color:#34495e;">第二级配置器：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">第一级配置器直接调用</span><span style="color:#34495e;">malloc</span><span style="color:#34495e;">和</span><span style="color:#34495e;">free</span><span style="color:#34495e;">带来了几个问题：</span></span></p> 
<ul><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">内存分配</span><span style="color:#34495e;">/</span><span style="color:#34495e;">释放的效率低</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">当配置大量的小内存块时，会导致内存碎片比较严重</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">配置内存时，需要额外的部分空间存储内存块信息，所以配置大量的小内存块时，还会导致额外内存负担</span></span></li></ul> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">如果分配的区块小于</span><span style="color:#34495e;">128bytes</span><span style="color:#34495e;">，则以内存池管理，第二级配置器维护了一个自由链表数组，每次需要分配内存时，直接从相应的链表上取出一个内存节点就完成工作，效率很高</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">自由链表数组：自由链表数组其实就是个指针数组，数组中的每个指针元素指向一个链表的起始节点。数组大小为</span><span style="color:#34495e;">16</span><span style="color:#34495e;">，即维护了</span><span style="color:#34495e;">16</span><span style="color:#34495e;">个链表，链表的每个节点就是实际的内存块，相同链表上的内存块大小都相同，不同链表的内存块大小不同，从</span><span style="color:#34495e;">8</span><span style="color:#34495e;">一直到</span><span style="color:#34495e;">128</span><span style="color:#34495e;">。如下所示，</span><span style="color:#34495e;">obj</span><span style="color:#34495e;">为链表上的节点，</span><span style="color:#34495e;">free_list</span><span style="color:#34495e;">就是链表数组。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">内存分配：</span><span style="color:#34495e;">allocate</span><span style="color:#34495e;">函数内先判断要分配的内存大小，若大于</span><span style="color:#34495e;">128</span><span style="color:#34495e;">字节，直接调用第一级配置器，否则根据要分配的内存大小从</span><span style="color:#34495e;">16</span><span style="color:#34495e;">个链表中选出一个链表，取出该链表的第一个节点。若相应的链表为空，则调用</span><span style="color:#34495e;">refill</span><span style="color:#34495e;">函数填充该链表。默认是取出</span><span style="color:#34495e;">20</span><span style="color:#34495e;">个数据块。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">填充链表</span><span style="color:#34495e;"> refill</span><span style="color:#34495e;">：若</span><span style="color:#34495e;">allocate</span><span style="color:#34495e;">函数内要取出节点的链表为空，则会调用</span><span style="color:#34495e;">refill</span><span style="color:#34495e;">函数填充该链表。</span><span style="color:#34495e;">refill</span><span style="color:#34495e;">函数内会先调用</span><span style="color:#34495e;">chunk_alloc</span><span style="color:#34495e;">函数从内存池分配一大块内存，该内存大小默认为</span><span style="color:#34495e;">20</span><span style="color:#34495e;">个链表节点大小，当内存池的内存也不足时，返回的内存块节点数目会不足</span><span style="color:#34495e;">20</span><span style="color:#34495e;">个。接着</span><span style="color:#34495e;">refill</span><span style="color:#34495e;">的工作就是将这一大块内存分成</span><span style="color:#34495e;">20</span><span style="color:#34495e;">份相同大小的内存块，并将各内存块连接起来形成一个链表。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">内存池：</span><span style="color:#34495e;">chunk_alloc</span><span style="color:#34495e;">函数内管理了一块内存池，当</span><span style="color:#34495e;">refill</span><span style="color:#34495e;">函数要填充链表时，就会调用</span><span style="color:#34495e;">chunk_alloc</span><span style="color:#34495e;">函数，从内存池取出相应的内存。</span></span></p> 
<ul><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">在</span><span style="color:#34495e;">chunk_alloc</span><span style="color:#34495e;">函数内首先判断内存池大小是否足够填充一个有</span><span style="color:#34495e;">20</span><span style="color:#34495e;">个节点的链表，若内存池足够大，则直接返回</span><span style="color:#34495e;">20</span><span style="color:#34495e;">个内存节点大小的内存块给</span><span style="color:#34495e;">refill</span><span style="color:#34495e;">；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">若内存池大小无法满足</span><span style="color:#34495e;">20</span><span style="color:#34495e;">个内存节点的大小，但至少满足</span><span style="color:#34495e;">1</span><span style="color:#34495e;">个内存节点，则直接返回相应的内存节点大小的内存块给</span><span style="color:#34495e;">refill</span><span style="color:#34495e;">；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">若内存池连</span><span style="color:#34495e;">1</span><span style="color:#34495e;">个内存节点大小的内存块都无法提供，则</span><span style="color:#34495e;">chunk_alloc</span><span style="color:#34495e;">函数会将内存池中那一点点的内存大小分配给其他合适的链表，然后去调用</span><span style="color:#34495e;">malloc</span><span style="color:#34495e;">函数分配的内存大小为所需的两倍。若</span><span style="color:#34495e;">malloc</span><span style="color:#34495e;">成功，则返回相应的内存大小给</span><span style="color:#34495e;">refill</span><span style="color:#34495e;">；若</span><span style="color:#34495e;">malloc</span><span style="color:#34495e;">失败，会先搜寻其他链表的可用的内存块，添加到内存池，然后递归调用</span><span style="color:#34495e;">chunk_alloc</span><span style="color:#34495e;">函数来分配内存，若其他链表也无内存块可用，则只能调用第一级空间配置器。</span></span></li></ul> 
<p style="margin-left:.0001pt;text-align:left;"><strong>20. 频繁对vector调用push_back()对性能的影响和原因？</strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#34495e;">在一个</span></span><span style="background-color:#ffffff;"><span style="color:#34495e;">vector</span></span><span style="background-color:#ffffff;"><span style="color:#34495e;">的尾部之外的任何位置添加元素，都需要重新移动元素。而且，向一个</span></span><span style="background-color:#ffffff;"><span style="color:#34495e;">vector</span></span><span style="background-color:#ffffff;"><span style="color:#34495e;">添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移到新的空间。</span></span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7bc04164410cd4dce89770a3b074fcee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决Loaded cuDNN version 8400 Could not load library cudnn_cnn_infer64_8.dll. 问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c48d6b00ee5fb61bd270af67993f1511/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vscode编辑器使用npm 进行依赖安装出现npm 不是内部和外部命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>