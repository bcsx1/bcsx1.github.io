<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>自己学习OGRE的笔记（1-5） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="自己学习OGRE的笔记（1-5）" />
<meta property="og:description" content="原文参考：http://lyme.blog.sohu.com/entry/1340641/#entry
感觉写的还不错，尤其是第5篇值得经常阅读。因为市面上大部分包括官方的教程都很浅显的教会你怎么用，感觉总有一点不确信的感觉。
自己学习OGRE的笔记1 分类： 日记 2007-06-01 22:27 OGRE的中文教学资源很少，所以打算自己写一点，不过首先声明我在这方面也差不多是菜鸟。本文主要是翻译和记录了Apress出版的Pro OGRE 3D Programming的一些重要部分，这本书的电子书我已经上传到CSDN中我的资源里，需要者自己去那里下载。
http://download.csdn.net/source/175364
OGRE基本设定入门
Ogre的渲染序列：
地形/世界物体(terrain and/or world geometry)，可移动物体(movable objects)，特效(effects)，界面(overlays)，然后是背景和空间盒(backgrounds and/or skyboxes)
Ogre支持的动画类型：
骨骼/蒙皮(skeletal)，变形(morph)，(pose)
其中蒙皮动画尚不支持IK解算，要抽取并转化为关键帧动画来实现，一般来说，Ogre的导入器会为你做这些。
Morph和Pose的区别在于Morph使用绝对坐标计算形变，而Pose使用单个点的轨迹计算形变。Morph和Pose不能混合使用，但是他们都能和skeletal混用。
使用Ogre之前的第一件事是创建一个root的场景对象(create an instance of root)。这些参数的命名类似于：
Root *root = new Root();
Root *root = new Root(&#34;plugins.cfg&#34;);
Root *root = new Root(&#34;plugins.cfg&#34;, &#34;ogre.cfg&#34;);
Root *root = new Root(&#34;plugins.cfg&#34;, &#34;ogre.cfg&#34;, &#34;ogre.log&#34;);
Root *root = new Root(&#34;&#34;, &#34;&#34;);
Ogre中的plugin指的是所有提供用户界面的代码模块，诸如SceneManager和RenderSystem等等。关于plugin的连接和定义方式：
# Define plugin folder
PluginFolder=.
# Define plugins
Plugin=RenderSystem_Direct3D9" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/1cb0a5b3ca0afb4645ba76fcdd5a21d2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-07-02T15:19:17+08:00" />
<meta property="article:modified_time" content="2013-07-02T15:19:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">自己学习OGRE的笔记（1-5）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>原文参考：<a href="http://lyme.blog.sohu.com/entry/1340641/#entry" rel="nofollow">http://lyme.blog.sohu.com/entry/1340641/#entry</a></p> 
<p>感觉写的还不错，尤其是第5篇值得经常阅读。因为市面上大部分包括官方的教程都很浅显的教会你怎么用，感觉总有一点不确信的感觉。</p> 
<p> </p> 
<div class="item-label"> 
 <span class="revoLeft"></span>  
</div> 
<h2 class="item-label"><span class="revoLeft">自己学习OGRE的笔记1</span></h2> 
<div class="item-body"> 
 <div class="item-title revoArtlabel"> 
  <span class="revoLeft">分类： <a href="http://lyme.blog.sohu.com/entry/1340641/" rel="nofollow"> 日记</a> </span> 
  <span class="revoRight">2007-06-01 22:27</span> 
 </div> 
 <div class="item-content" id="main-content"> 
  <p>    OGRE的中文教学资源很少，所以打算自己写一点，不过首先声明我在这方面也差不多是菜鸟。本文主要是翻译和记录了Apress出版的Pro OGRE 3D Programming的一些重要部分，这本书的电子书我已经上传到CSDN中我的资源里，需要者自己去那里下载。</p> 
  <p><a href="http://download.csdn.net/source/175364" target="_blank" rel="noopener noreferrer">http://download.csdn.net/source/175364</a></p> 
  <p><strong>OGRE基本设定入门</strong></p> 
  <p>Ogre的渲染序列：</p> 
  <p>    地形/世界物体(terrain and/or world geometry)，可移动物体(movable objects)，特效(effects)，界面(overlays)，然后是背景和空间盒(backgrounds and/or skyboxes)</p> 
  <p>Ogre支持的动画类型：</p> 
  <p>    骨骼/蒙皮(skeletal)，变形(morph)，(pose)</p> 
  <p>    其中蒙皮动画尚不支持IK解算，要抽取并转化为关键帧动画来实现，一般来说，Ogre的导入器会为你做这些。</p> 
  <p>    Morph和Pose的区别在于Morph使用绝对坐标计算形变，而Pose使用单个点的轨迹计算形变。Morph和Pose不能混合使用，但是他们都能和skeletal混用。</p> 
  <p>    使用Ogre之前的第一件事是创建一个root的场景对象(create an instance of root)。这些参数的命名类似于：</p> 
  <p align="left">Root *root = new Root();</p> 
  <p align="left">Root *root = new Root("plugins.cfg");</p> 
  <p align="left">Root *root = new Root("plugins.cfg", "ogre.cfg");</p> 
  <p align="left">Root *root = new Root("plugins.cfg", "ogre.cfg", "ogre.log");</p> 
  <p align="left">Root *root = new Root("", "");</p> 
  <p>    Ogre中的plugin指的是所有提供用户界面的代码模块，诸如SceneManager和RenderSystem等等。关于plugin的连接和定义方式：</p> 
  <p align="left"># Define plugin folder</p> 
  <p align="left">PluginFolder=.</p> 
  <p align="left"># Define plugins</p> 
  <p align="left">Plugin=RenderSystem_Direct3D9</p> 
  <p align="left">Plugin=RenderSystem_GL</p> 
  <p align="left">Plugin=Plugin_ParticleFX</p> 
  <p align="left">Plugin=Plugin_BSPSceneManager</p> 
  <p align="left">Plugin=Plugin_OctreeSceneManager</p> 
  <p>Plugin=Plugin_CgProgramManager</p> 
  <p align="left">    你可以在任何你想要的时刻调用它，并把命名提供给root constructor。如果你不设定这个参数(比如 Root *root = new Root();)，root会按默认名“plugins.cfg”在你的软件安装目录下寻找配置文件。如果你设定空的参数(比如 Root *root = new Root("", "");)，那么root将不载入配置文件，你将需要自己手动载入。</p> 
  <p align="left">    PluginFolder设定了插件的路径，你可以设定绝对路径，也可以设定相对路径。如果你不设定这个路径，在windows下它将在你当前程序的驱动盘下找，在linux下它将会在root文件夹里找。</p> 
  <p> </p> 
  <p>    调用默认配置对话框的方法是：</p> 
  <p align="left">Root *root = new Root();</p> 
  <p align="left">bool rtn = root-&gt;showConfigDialog();</p> 
  <p>    以上代码将产生ogre.cfg文件。如果要使用已经存在的ogre.cfg配置文件，可以使用以下代码：</p> 
  <p align="left">if (!root-&gt;restoreConfig())</p> 
  <p>root-&gt;showConfigDialog();</p> 
  <p>    你还可以使用以下代码来保存一个你自己命名的配置文件(比如说 myapp.cfg)：</p> 
  <p>root-&gt;saveConfig();</p> 
  <p>    Ogre log可以帮助你记录程序的出错信息，创建一个名为mylog.log的方法如下：</p> 
  <p align="left">// create an instance of LogManager prior to using LogManager::getSingleton()</p> 
  <p align="left">LogManager* logMgr = new LogManager;</p> 
  <p align="left">Log *log = LogManager::getSingleton().createLog("<strong>mylog.log</strong>", true, true, false);</p> 
  <p align="left">// third param is not used since we already created a log in the previous step</p> 
  <p>Root *root = new Root("", "");</p> 
  <p>    初始化Root的代码：</p> 
  <p align="left">root-&gt;initialise(true, "<strong>My Render Window</strong>");</p> 
  <p>RenderWindow *window = root-&gt;getAutoCreatedWindow();</p> 
  <p>    第一行是完成Root的初始化并且创建一个名为My Render Window的渲染窗口，其中第一个参数true是让Ogre自动创建一个渲染窗口。第二行创建了一个指向RenderWindow的指针。</p> 
  <p>    创建摄像机的代码如下：</p> 
  <p align="left">Camera *cam = sceneMgr-&gt;createCamera("MainCamera");</p> 
  <p align="left">cam-&gt;setNearClipDistance(5);</p> 
  <p align="left">cam-&gt;setFarClipDistance(1000);</p> 
  <p>cam-&gt;setAspectRatio(Real(1.333333));</p> 
  <p>    该代码第一行创建了一个摄像机和一个指向它的指针，第二和第三行设定了近切片和远切片的数值范围，最后一行定义了视图的比例，通常普通的显示器长和宽的比例是4:3，因此近似设为1.333333，当然宽屏的显示器应该设为1.6左右。关于近切片和远切片的说明：</p> 
  <p> A popular misconception is that clip planes are a cheap method to reduce the amount of “stuff” that a card has to render. While this certainly is a side effect of clip distance selection (and most modern cards support infinite far clip planes anyway), the primary reason for a particular set of clip plane distances is to maintain optimal depth buffer resolution. The depth buffer resolution is a direct function of the ratio between the far and near clip distances, and selecting distances that result in too coarse a resolution will invariably result in depth fighting. This phenomenon occurs when the depth-sorting algorithm on the GPU cannot tell which objects are “in front of” other objects. You end up with bits of objects that are at relative equivalent depths in the scene, rendering “through” each other. This occurs because the depth resolution is low enough that objects at slightly different depths were assigned the same depth value. The only solution in this case is to increase the depth precision, typically by altering the near plane distances (which give much more bang for your precision buck compared to altering the far clip distances).<strong> Google “depth fighting” for more.</strong></p> 
  <p align="left"><strong>    </strong>创建视口(viewport)的代码如下：</p> 
  <p align="left">Viewport *vp = window-&gt;addViewport(camera);</p> 
  <p align="left">vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</p> 
  <p align="left">colour Value(0,0,0)设定了视口的背景颜色为黑色，它是用RGB值表示的。</p> 
  <p align="left">    最简单的开始一个渲染循环的方法是从Root调用startRendering()函数：</p> 
  <p align="left">root-&gt;startRendering();</p> 
  <p align="left">    使用这个方法将使Ogre无止尽地渲染下去直到你手动关闭渲染窗口为止，一个备选的终止渲染的方法是调用Root::getSingleton().queueEndRendering()，但是典型的方法是在你的frame listener返回一个false的值。</p> 
  <p align="left">    使用frame listener是唯一的在使用startRendering()时调用你自己的代码的途径。创建并且增添一个frame listener到Root的代码如下：</p> 
  <p align="left">class myFrameListener : public FrameListener {<!-- --></p> 
  <p align="left">public:</p> 
  <p align="left">bool frameStarted (const FrameEvent &amp;evt);</p> 
  <p align="left">bool frameEnded (const FrameEvent &amp;evt);</p> 
  <p align="left">};</p> 
  <p align="left">bool myFrameListener::frameStarted(const FrameEvent &amp;evt) {<!-- --></p> 
  <p align="left">//你需要渲染的场景的代码段 really cool stuff to do before a frame is rendered</p> 
  <p align="left">return true;</p> 
  <p align="left">}</p> 
  <p align="left">bool myFrameListener::frameEnded(const FrameEvent &amp;evt) {<!-- --></p> 
  <p align="left">//你需要渲染的场景的代码段 really cool stuff to do after a frame is rendered</p> 
  <p align="left">return true;</p> 
  <p align="left">}</p> 
  <p align="left">Root *root = new Root();</p> 
  <p align="left">MyFrameListener myListener;</p> 
  <p align="left">// YOU HAVE TO ADD A FRAMELISTENER BEFORE YOU CALL startRendering()!!!</p> 
  <p align="left">root-&gt;addFrameListener(myListener);</p> 
  <p align="left">root-&gt;startRendering();</p> 
  <p align="left">    你还可以使用frameEnded()，但是这并不常用，使用它你可以在每个帧结束时做些内存清理工作。</p> 
  <p align="left">Typically during each frame, you process HID (Human Interface Device, such as keyboard, mouse, or joystick) input events. Depending on the particular event, you might cause a model in your scene to move and/or rotate, cause a camera to move or rotate, start a process for a player-character to put a sleeping hex on an NPC troll for 10 exp, or whatever. Regardless of what it is, it occurs during one or both of the <strong>FrameListener </strong>callback methods—usually during frameStarted(), because <strong>more than likely you will process changes to the scene before the scene is rendered, rather than after.</strong></p> 
  <p align="left"> </p> 
  <p align="left"><strong>OGRE进阶</strong></p> 
  <p align="left">    Ogre提供了两个函数来手动加载插件，代码如下：</p> 
  <p align="left"><strong>void </strong>loadPlugin(<strong>const </strong>String&amp; pluginName);</p> 
  <p align="left"><strong>void </strong>unloadPlugin(<strong>const </strong>String&amp; pluginName);</p> 
  <p align="left">    其中pluginName是实际的插件名称，例如“Plugin_ParticleFX”。在提供一个插件的名称时并不要求手动提供扩展，Ogre会自己检测并挂载任何可能的扩展(例如windows下面的.dll动态链接库等)。你当然可以自己实施这些挂载，但是你最好还是让Ogre来做这些，以免发生冲突。</p> 
  <p align="left">    关于debug与release两个版本的相同的dll文件或者runtime library文件加载错误会导致死机，详情请看：</p> 
  <p align="left">The “ms_singleton” assert occurs when your application loads a Debug and Release version of the same DLL at execution time. The reason is the nature of the singleton implementation in Ogre. Ogre creates the one-and-only single instance of each of its singleton classes in the <strong>Root </strong>constructor and access to them is via static member methods. This is all fine and good until your app loads the “opposite” DLL type at runtime, usually because of a plug-in mismatch (Debug plug-ins into a Release app or vice versa). This plug-in will in turn have been linked against the “opposite” OgreMain library, and when they are loaded, the operating system will load that opposite OgreMain library. The next time one of the singleton classes residing in OgreMain is called, the new singleton will try to create an instance of itself, detect that an instance already exists, and BANG! . . . instant assert.</p> 
  <p align="left">    一般地，为了避免上述情况发生，Ogre自己定义了不同的命名方式，比如在debug版的文件名称上都加上“_d”的后缀，例如“OgreMain_d.dll”。这将要求你使用条件宏来编译程序，代码如下：</p> 
  <p align="left">Root *root = new Root;</p> 
  <p align="left">#if defined(_DEBUG)</p> 
  <p align="left">root-&gt;loadPlugin("Plugin_ParticleFX_d.dll");</p> 
  <p align="left">#else</p> 
  <p align="left">root-&gt;loadPlugin("Plugin_ParticleFX.dll");</p> 
  <p align="left">#endif</p> 
  <p align="left">    Ogre主要的几个插件：</p> 
  <p align="left">Plugin_OctreeSceneManager</p> 
  <p align="left">Plugin_BSPSceneManager</p> 
  <p align="left">Plugin_CgProgramManager</p> 
  <p align="left">Plugin_ParticleFX</p> 
  <p align="left">RenderSystem_Direct3D9</p> 
  <p align="left">RenderSystem_GL</p> 
  <p align="left">    高级的调用Ogre Render的代码：</p> 
  <p align="left">// create a new Root without config files</p> 
  <p align="left">Root *root = new Root("", "");</p> 
  <p align="left">root-&gt;loadPlugin("RenderSystem_Direct3D9");</p> 
  <p align="left">root-&gt;loadPlugin("RenderSystem_GL");</p> 
  <p align="left">    以上代码同时调用了底层的DirectX和OpenGL两个库，由Ogre系统根据实际情况确定使用哪个库。Root系统还提供了一个函数来查看哪个渲染系统被载入并可用：</p> 
  <p align="left">RenderSystemList* getAvailableRenderers(<strong>void</strong>);</p> 
  <p align="left">    以下是Root提供的另外一些获取和操作渲染系统的信息的方法：</p> 
  <p align="left"><strong>void </strong>addRenderSystem(RenderSystem* newRend);</p> 
  <p align="left">RenderSystem* getRenderSystemByName(<strong>const </strong>String&amp; name);</p> 
  <p align="left"><strong>void </strong>setRenderSystem(RenderSystem* system);</p> 
  <p align="left">RenderSystem* getRenderSystem(<strong>void</strong>);</p> 
  <p align="left">    通常你使用setRenderSystem()的时候应该一起调用getAvailableRenderers()，来引导Ogre使用一个可用的底层库，并且通常这是提供给用户的选择。以下是实现这种方式的代码：</p> 
  <p align="left">// RenderSystemList is a std::vector</p> 
  <p align="left">RenderSystemList *rlist = root-&gt;getAvailableRenderers();</p> 
  <p align="left">RenderSystemList::iterator it = rList-&gt;begin();</p> 
  <p align="left">while (it != rList-&gt;end()) {<!-- --></p> 
  <p align="left">// Ogre strings are typedefs of std::string</p> 
  <p align="left">RenderSystem *rSys = *(it++);</p> 
  <p align="left">if (rSys-&gt;getName().find("OpenGL")) {<!-- --></p> 
  <p align="left">//将OpenGL设为可用 set the OpenGL render system for use</p> 
  <p align="left">root-&gt;setRenderSystem(rSys);</p> 
  <p align="left">break;</p> 
  <p align="left">}</p> 
  <p align="left">}</p> 
  <p align="left">// note that if OpenGL wasn't found, we haven't set a render system yet! This</p> 
  <p align="left">// will cause an exception in Ogre's startup.</p> 
  <p align="left">    以上的代码会自动在可用的底层库里搜索OpenGL的名字，并且默认将它设定为底层的支持库。以上代码只是一个示例，实际上你应该使用一个下拉表单列出你搜索到的渲染系统，并把用户所选择的设为Ogre的支撑环境。(原文：Most likely what you will do is populate a drop-down menu in your application’s GUI with the names of the available render systems as provided by getAvailableRenderers(), and then call setRenderSystem() with the user’s selection.)</p> 
  <p align="left">    手动挂载基于Ogre的应用程序的基本方式如下：</p> 
  <p align="left">#include "Ogre.h"</p> 
  <p align="left">// create a new Root without config files</p> 
  <p align="left">Root *root = new Root("", "");</p> 
  <p align="left"> </p> 
  <p align="left">// load the render system plug-ins</p> 
  <p align="left">root-&gt;loadPlugin("RenderSystem_Direct3D9");</p> 
  <p align="left">root-&gt;loadPlugin("RenderSystem_GL");</p> 
  <p align="left"> </p> 
  <p align="left">// pretend the user used some other mechanism to select the</p> 
  <p align="left">// OpenGL renderer</p> 
  <p align="left">String rName("OpenGL Rendering Subsystem");</p> 
  <p align="left">RenderSystemList *rList = root-&gt;getAvailableRenderers();</p> 
  <p align="left">RenderSystemList::iterator it = rList-&gt;begin();</p> 
  <p align="left">RenderSystem *rSys = 0;</p> 
  <p align="left"> </p> 
  <p align="left">while (it != rList-&gt;end()) {<!-- --></p> 
  <p align="left">rSys = *(it++);</p> 
  <p align="left">if (rSys-&gt;getName() == rName) {<!-- --></p> 
  <p align="left">// set this renderer and break out</p> 
  <p align="left">root-&gt;setRenderSystem(rSys);</p> 
  <p align="left">break;</p> 
  <p align="left">}</p> 
  <p align="left">}</p> 
  <p align="left">// end gracelessly if the preferred renderer is not available</p> 
  <p align="left">if (root-&gt;getRenderSystem() == NULL) {<!-- --></p> 
  <p align="left">delete root;</p> 
  <p align="left">return –1;</p> 
  <p align="left">}</p> 
  <p align="left"> </p> 
  <p align="left">// We can initialize Root here if we want. "false" tells Root NOT to create</p> 
  <p align="left">// a render window for us.</p> 
  <p align="left">root-&gt;initialise(false);</p> 
  <p align="left"> </p> 
  <p align="left">// set up the render window with all default params</p> 
  <p align="left">RenderWindow *window = rSys-&gt;createRenderWindow(</p> 
  <p align="left">"Manual Ogre Window", // window name</p> 
  <p align="left">800, // window width, in pixels</p> 
  <p align="left">600, // window height, in pixels</p> 
  <p align="left">false, // fullscreen or not</p> 
  <p align="left">0); // use defaults for all other values</p> 
  <p align="left">// from here you can set up your camera and viewports as normal</p> 
 </div> 
</div> 
<p> </p> 
<p> </p> 
<p> </p> 
<h2>自己学习OGRE的笔记2</h2> 
<p><span class="revoLeft">分类： <a href="http://lyme.blog.sohu.com/entry/1340641/" rel="nofollow"> 日记</a> </span><span class="revoRight">2007-07-11 22:19</span></p> 
<div class="item-content" id="main-content"> 
 <p>前一段日子忙着准备考试，没怎么学OGRE，只有这一点了，但是现在放假了，不管三七二十一我先逃回家，终于又可以继续学我喜欢的东西了。</p> 
 <p> </p> 
 <p>关于上文中"instance"的解释:</p> 
 <p>这里解释一下“instance”的涵义，我开始也不理解这个概念，从字面上解释，是实例或场合的意思。实际上，这个概念就像C++编程中类和对象的关系一样。instance是一组可渲染序列的集合。如果你还不理解，看一下一段典型的mental_ray渲染脚本：</p> 
 <p>verbose on</p> 
 <p>link "base.so"</p> 
 <p>$include &lt;base.mi&gt;</p> 
 <p>options "opt"</p> 
 <p>    samples -1  2</p> 
 <p>    contrast 0.1    0.1 0.1</p> 
 <p>    object space</p> 
 <p>end options</p> 
 <p> </p> 
 <p>camera "cam"</p> 
 <p>    frame 1</p> 
 <p>    output "rgb" "out.rgb"</p> 
 <p>    focal 50</p> 
 <p>aperture 44</p> 
 <p>aspect 1</p> 
 <p>    resolution 800 800</p> 
 <p>end camera</p> 
 <p> </p> 
 <p>instance "cam_inst" "cam"</p> 
 <p>    transform   0.7719  0.3042  -0.5582 0.0</p> 
 <p>                0.0000  0.8781  0.4785  0.0</p> 
 <p>                0.6357  -0.3693 0.6778  0.0</p> 
 <p>                0.0000  0.0000  -2.5000 1.0</p> 
 <p>end instance</p> 
 <p> </p> 
 <p>light "light1"</p> 
 <p>    "mib_light_point" (</p> 
 <p>    "color" 1   1   1,</p> 
 <p>    "factor"    0.75 )</p> 
 <p>    origin  0   0   0</p> 
 <p>end light</p> 
 <p> </p> 
 <p>instance "light1_inst" "light1"</p> 
 <p>    transform   1   0   0   0</p> 
 <p>                0   1   0   0</p> 
 <p>                0   0   1   0</p> 
 <p>                -2  -3  -2  1</p> 
 <p>end instance</p> 
 <p> </p> 
 <p>material "mtl"</p> 
 <p>    opaque</p> 
 <p>    "mib_illum_phong" (</p> 
 <p>        "ambient" 0.5   0.5 0.5,</p> 
 <p>        "diffuse" 0.7   0.7 0.7,</p> 
 <p>        "ambience" 0.3  0.3 0.3,</p> 
 <p>        "specular" 1.0  1.0 1.0,</p> 
 <p>        "exponent" 50,</p> 
 <p>        "mode" 1,</p> 
 <p>        "lights" ["light1_inst"]</p> 
 <p>    )</p> 
 <p>end material</p> 
 <p> </p> 
 <p>object "cube1"</p> 
 <p>    visible trace shadow</p> 
 <p>    tag 1</p> 
 <p>    group</p> 
 <p>        -0.5    -0.5    -0.5</p> 
 <p>        -0.5    -0.5    0.5</p> 
 <p>        -0.5    0.5     -0.5</p> 
 <p>        -0.5    0.5     0.5</p> 
 <p>        0.5     -0.5    -0.5</p> 
 <p>        0.5     -0.5    0.5</p> 
 <p>        0.5     0.5     -0.5</p> 
 <p>        0. 5    0.5     0.5</p> 
 <p>        v 0     v 1     v 2     v 3</p> 
 <p>        v 4     v 5     v 6     v 7</p> 
 <p>        p "mtl" 0   1   3   2</p> 
 <p>        p       1   5   7   3</p> 
 <p>        p       5   4   6   7</p> 
 <p>        p       4   0   2   6</p> 
 <p>        p       4   5   1   0</p> 
 <p>        p       2   3   7   6</p> 
 <p>    end group</p> 
 <p>end object</p> 
 <p> </p> 
 <p>instance "cube1_inst" "cube1"</p> 
 <p>    transform   1   0   0   0</p> 
 <p>                0   1   0   0</p> 
 <p>                0   0   1   0</p> 
 <p>                0   0   0   1</p> 
 <p>end instance</p> 
 <p> </p> 
 <p>instgroup "rootgrp"</p> 
 <p>    "cam_inst" "light1_inst" "cube1_inst"</p> 
 <p>    end instgroup</p> 
 <p>render "rootgrp" "cam_inst" "opt"</p> 
 <p>可以看出，该脚本也是建立了instance的实例(或者称之为对象)之后来执行渲染的。因此，我们姑且也可以这样来理解instance这个概念，可以说，在OGRE中，场景是以root为实例来建立的，而渲染序列则是以instance为实例来建立的。</p> 
 <p> </p> 
 <p>(接上文代码)</p> 
 <p align="left">我们不一定要原原本本地做上述代码中的所有的事，我们可以通过其他可编程的代码源来实施创建渲染窗口的调用(render window creation call)。</p> 
 <p align="left"> </p> 
 <p align="left">RenderWindow class是源于更普遍适用的类RenderTarget class的，后者是执行渲染面的普遍方式，在没有帧缓冲的渲染目标中很有用，比如说贴图。所有的RenderTarget instance都可以通过它们创建时的名字来存取，上例中creatRenderWindow()的第一个参数(已加粗)就是这个名字。以上API与更多有关的API请看OgreRenderSystem.h文件。</p> 
 <p align="left"> </p> 
 <p align="left">如果你想让渲染窗口定位在屏幕的左上角，并且在渲染窗口的标题栏使用一个与渲染窗口不同的名字，以及诸如此类的其他操作，你可以调用NameValuePairList类，该类是STL中map类的一个重定义类型(map是一种映射，更多的请参阅STL库)。</p> 
 <p align="left">NameValuePairList params;</p> 
 <p align="left">params["left"] = "0";</p> 
 <p align="left">params["top"] = 0;</p> 
 <p align="left">params["title"] = "Alternate Window Title";</p> 
 <p align="left">RenderWindow *window = rSys-&gt;createRenderWindow(</p> 
 <p align="left">"MainWindow", // RenderTarget name</p> 
 <p align="left">800, // window width, in pixels</p> 
 <p align="left">600, // window height, in pixels</p> 
 <p align="left">false, // windowed mode</p> 
 <p align="left">&amp;params); // supply the param values set above</p> 
 <p align="left">以上代码创建了一个名叫“MainWindow”的窗口并让它的标题栏显示为“Alternate Window Title”。</p> 
 <p align="left"> </p> 
 <p align="left">你也可以在任何其它窗口系统(例如Qt和wxWidgets)中嵌入Ogre的渲染窗口。RenderWindow中的getCustomAttribute()允许你为渲染窗口获得依赖于系统的窗口控制手柄。你也可以在父窗口中实施Ogre渲染窗口的嵌入，例如：</p> 
 <p align="left">// hWnd is a handle to an existing Win32 window(详见MSDN)</p> 
 <p align="left">// renderSystem points to an existing, initialized instance of D3D9RenderSystem</p> 
 <p align="left">NameValuePairList opts;</p> 
 <p align="left">opts["parentWindowHandle"] = StringConverter::toString(hWnd);</p> 
 <p align="left">// everything but "opts" is somewhat irrelevant in the context of an</p> 
 <p align="left">// explicitly parented window</p> 
 <p align="left">RenderWindow *window = renderSystem-&gt;createRenderWindow(</p> 
 <p align="left">"WindowName",</p> 
 <p align="left">800, 600,</p> 
 <p align="left">false, &amp;opts);</p> 
 <p align="left">该代码允许你将Ogre渲染窗口嵌入到一个已存在的窗口系统中。但是这样做将使得Ogre窗口的消息迂回传递，你必须管理好Ogre窗口的清理工作。</p> 
</div> 
<p> </p> 
<p> </p> 
<p> </p> 
<h2>自己学习OGRE的笔记3</h2> 
<div class="item-title revoArtlabel"> 
 <span class="revoLeft">分类： <a href="http://lyme.blog.sohu.com/entry/1340641/" rel="nofollow"> 日记</a> </span> 
 <span class="revoRight">2007-11-26 12:01</span> 
</div> 
<div class="item-content" id="main-content"> 
 <p>    学习有点紧张, 昨天晚上又看了点书, 把笔记贴出来~~</p> 
 <p>    另外, 发现OGRE中文终于有起色了, <a href="http://ogre3d.cn/" rel="nofollow">http://ogre3d.cn</a>网站已经完成了1.4.0的官方参考的翻译, 有兴趣的可以去看看. 不过个人觉得还是看APRESS的书比较好, 没有一本入门的书直接看MANUAL和API REF实在太痛苦了~~</p> 
 <p> </p> 
 <p align="left">在你使用一个场景管理器的实例之前，你必须先创建一个：</p> 
 <p align="left">SceneManager* sceneMgr = root-&gt;createSceneManager(ST_GENERIC, "MySceneManager");</p> 
 <p align="left">在OGRE装载他的插件之前，可供选择的插件有很多种实现，就像前面所说的那样。这些实现的代码会将它们自己注册为特殊的场景管理器：</p> 
 <p align="left"> </p> 
 <p align="left">·ST_GENERIC：最小的场景管理器的实现，没有为任何特殊的场景内容和结构作优化。对付简单的场景最合适（比如说那些程序的GUI）。</p> 
 <p align="left">·ST_INTERIOR：为渲染室内场景、闭合区域场景（close-quarter）、潜在的高密度场景（potentially high-density scene）优化的场景管理器的实现。</p> 
 <p align="left">·ST_EXTERIOR_CLOSE：为那些渲染部分可见的室外场景优化过的场景管理器实例，例如那些基于单页的多边形地形或者起伏地形。</p> 
 <p align="left">·ST_EXTERIOR_FAR：OGRE开发中的一个历史性失误，现在一般已经很少用到了。用ST_EXTERIOR_CLOSE或ST_EXTERIOR_REAL_FAR代替。</p> 
 <p align="left">·ST_EXTERIOR_REAL_FAR：这种场景管理器的实例一般适用于卷动的场景或场景结构。卷动的场景通常都十分巨大，甚至可能是整个未划分的场景。（Scene manager implementation typically suited for paged landscape or paged scene construction. Paged landscapes often are huge, possibly entire planets.）</p> 
 <p align="left">在前面所说的例子中我们创建了一个ST_GENERIC种类的场景管理器的实例。如果我们在QUAKE 3的级别上使用BSPScenManager（它是被注册为ST_INTERIOR类型的）的插件，我们应该使用ST_INTERIOR场景，并且如果我们想要通过使用TerrainSceneManager(TSM)插件创建一个基于有起伏的地形的场景，我们应该创建一个ST_EXTERIOR_CLOSE的场景管理器。ST_GENERRIC没有提供特殊的插件，但是如果载入了OctreeSceneManager（八叉树），它会接管ST_GENERIC的工作。</p> 
 <p align="left"> </p> 
 <p align="left">摄像机</p> 
 <p align="left">一个摄像机就像真实世界的模拟一样：它从一个特定的方向为你场景的每一帧“照相”（就是说它有一个位置点和一个方向）。它不是一个典型的可渲染的物体，所以即使你在场景中已经有了一个摄像机，这个摄像机也不会被渲染。摄像机既可以被连接到场景的节点上也可以存在于自由的空间中（which means you get to move them around manually if you want their position and/or orientation changed each frame）。就像所提到的那样，摄像机具有拥有一个近切片和一个远切片的视域（field of view）。</p> 
 <p align="left">我们假设你想要一个具有标准的4:3比例的区域，其近切片距离为5单位，原切片距离为1000单位，摄像机中心轴和上下界的角度皆为30度，下面的代码就创建了这样一个摄像机：</p> 
 <p align="left">// sceneMgr is an existing instance of a SceneManager implementation. We are</p> 
 <p align="left">// creating a camera named "MainCam" here.</p> 
 <p align="left">Camera *camera = sceneMgr-&gt;createCamera("MainCam");</p> 
 <p align="left">// normally you would calculate this from the size of the viewport</p> 
 <p align="left">camera-&gt;setAspectRatio(1.33333f);</p> 
 <p align="left">// 30 degrees will give more of a long, telescopic view</p> 
 <p align="left">camera-&gt;setFOVy(30.0f);</p> 
 <p align="left">camera-&gt;setNearClipDistance(5.0f);</p> 
 <p align="left">camera-&gt;setFarClipDistance(1000.0f);</p> 
 <p align="left"> </p> 
 <p align="left">渲染模式</p> 
 <p align="left">摄像机可以用三种不同模式中的一种来渲染场景：wireframe(线框图)，solid(实体图)，或者“points”(只有点被渲染)。</p> 
 <p align="left"> </p> 
 <p align="left">camera-&gt;setPolygonMode(PM_WIREFRAME);</p> 
 <p align="left">camera-&gt;setPolygonMode(PM_POINTS);</p> 
 <p align="left">camera-&gt;setPolygonMode(PM_SOLID);</p> 
 <p align="left">PolygonMode mode = camera-&gt;getPolygonMode();</p> 
 <p align="left"> </p> 
 <p align="left">模式设定在以后的动画中会继续强制执行，直到它被另一个调用改变为止（也就是说这不是一个单帧的设定）。默认的模式是PM_SOLID。</p> 
 <p align="left"> </p> 
 <p align="left">位置和变换</p> 
 <p align="left">一个摄像机是一个可以移动的物体，并享有MovableObject类中的所有的函数和方法。MovableObject最常见的功能是可以连接到场景中的一个节点并且伴随着可渲染的物体移动（“piggyback” the camera along with renderable objects）。你会有需要这么做，比如各种摄像机追踪镜头的技术。你会在后面的章节中看到各种第三人称摄影技术。现在，我们只讨论固定位置和方向的摄像机。</p> 
 <p align="left">// assume camera is a pointer to an existing, valid instance of "Camera"</p> 
 <p align="left">camera-&gt;setPosition(200, 10, 200);</p> 
 <p align="left">// you can also use a Vector3 to position the camera, useful for using the</p> 
 <p align="left">// position obtained from a scene node getter</p> 
 <p align="left">// camera-&gt;setPosition(Vector3(200, 10, 200));</p> 
 <p align="left">这段代码会把摄像机放置在绝对坐标（200，10，200）处。这和move()与moveRelative()方法是不同的，后面所说的这些方法分别是在世界坐标和本地坐标中针对当前位置移动物体。</p> 
 <p align="left">// camera is at world space 200, 10, 200 from before</p> 
 <p align="left">camera-&gt;move(10, 0, 0); // camera moves to 210, 10, 200</p> 
 <p align="left">camera-&gt;moveRelative(0, 0, 10); // camera moves to 210, 10, 210</p> 
 <p align="left">我们必须注意moveRelative()。因为它发生在本地坐标系中，这种移动的实施和摄像机当时的方向有关。在前面所述的例子中，我们假定摄像机是和主轴线对齐的，指向正Z轴方向。如果摄像机向右转了90度，例如，moveRelative(0,0,10)会把摄像机移到(220,10,200)的地方。</p> 
 <p align="left"> </p> 
 <p align="left">方向、指向和“面向”（Direction, Orientation, and ”Look-At”）</p> 
 <p align="left">OGRE提供了一系列丰富的方法来放置你的摄像机：</p> 
 <p align="left"> </p> 
 <p align="left"><strong>void </strong>setDirection(Real x, Real y, Real z);</p> 
 <p align="left"><strong>void </strong>setDirection(<strong>const </strong>Vector3&amp; vec);</p> 
 <p align="left">Vector3 getDirection(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left">Vector3 getUp(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left">Vector3 getRight(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left"><strong>void </strong>lookAt( <strong>const </strong>Vector3&amp; targetPoint );</p> 
 <p align="left"><strong>void </strong>lookAt(Real x, Real y, Real z);</p> 
 <p align="left"><strong>void </strong>roll(<strong>const </strong>Radian&amp; angle);</p> 
 <p align="left"><strong>void </strong>roll(Real degrees) { roll ( Angle(degrees) ); }</p> 
 <p align="left"><strong>void </strong>yaw(<strong>const </strong>Radian&amp; angle);</p> 
 <p align="left"><strong>void </strong>yaw(Real degrees) { yaw ( Angle(degrees) ); }</p> 
 <p align="left"><strong>void </strong>pitch(<strong>const </strong>Radian&amp; angle);</p> 
 <p align="left"><strong>void </strong>pitch(Real degrees) { pitch ( Angle(degrees) ); }</p> 
 <p align="left"><strong>void </strong>rotate(<strong>const </strong>Vector3&amp; axis, <strong>const </strong>Radian&amp; angle);</p> 
 <p align="left"><strong>void </strong>rotate(<strong>const </strong>Vector3&amp; axis, Real degrees) {<!-- --></p> 
 <p align="left">rotate ( axis, Angle(degrees) ); }</p> 
 <p align="left"><strong>void </strong>rotate(<strong>const </strong>Quaternion&amp; q);</p> 
 <p align="left"><strong>void </strong>setFixedYawAxis( <strong>bool </strong>useFixed, <strong>const </strong>Vector3&amp; fixedAxis =</p> 
 <p align="left"><strong>const </strong>Quaternion&amp; getOrientation(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left"><strong>void </strong>setOrientation(<strong>const </strong>Quaternion&amp; q);</p> 
 <p align="left"><strong>void </strong>setAutoTracking(<strong>bool </strong>enabled, SceneNode* target = 0,</p> 
 <p align="left"><strong>const </strong>Vector3&amp; offset = Vector3::ZERO);</p> 
 <p align="left"> </p> 
 <p align="left">这些方法的功能大多数从名字来看是显而易见(self-explanatory)的。roll(), yaw(), 和pitch()做的正好就是他们所描述的。setDirection()会让摄像机指向该向量定义的方向。rotate()会使摄像机沿着给定的坐标轴旋转一个角度。lookAt()是非常常用的，它可以使一个摄像机指向一个目标点或目标物体的中心，并且不需要用欧氏几何的方法去计算该指向的四元矩阵。最后，setFixedYawAxis()允许你打破摄像机自有的偏移轴的约束（break the camera free from its own yaw (Y) axis）。在第一人称射击游戏中，摄像机通常能够检视X-Z平面。正因如此，你希望的默认动作，是沿着摄像机本地坐标的Y轴偏移。但是，在飞行模拟游戏中，你希望能打破这种约束来创造一个完全自由的摄像机。</p> 
 <p align="left">setAutoTracking()是一个有趣的功能，如果你希望摄像机总是沿着场景中特定的一点。注意这和真正的第三人称视点的摄像机不同，因为那种摄像机通常不是面向一个特定点的，而是总是面向你的角色所看的方向的。第一个参数指出是否采用追踪，这在任何一帧开始渲染前都可以做，并且在被追踪前必须先删除这个节点。被追踪的节点是第二个参数，这个节点必须存在于这个方法被调用之前。这个参数只能在第一个参数是false的情况下定为NULL。如果被追踪的物体是巨大的并且不适合面向正中间来观察，你可以用第三个参数（偏移offset）来协调一下实际的视点，该参数在本地坐标中操作被追踪的节点。</p> 
 <p align="left">以下的方法可以用来获得摄像机实际方向的信息，注意把旋转操作和平移操作对被连接的节点的影响考虑在内：</p> 
 <p align="left"> </p> 
 <p align="left"><strong>const </strong>Quaternion&amp; getDerivedOrientation(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left"><strong>const </strong>Vector3&amp; getDerivedPosition(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left">Vector3 getDerivedDirection(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left">Vector3 getDerivedUp(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left">Vector3 getDerivedRight(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left"><strong>const </strong>Quaternion&amp; getRealOrientation(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left"><strong>const </strong>Vector3&amp; getRealPosition(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left">Vector3 getRealDirection(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left">Vector3 getRealUp(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left">Vector3 getRealRight(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left"> </p> 
 <p align="left">Real的方法返回的是世界坐标中的值，但是Derived返回的是在本地坐标中的值。</p> 
 <p align="left"> </p> 
 <p align="left">进阶摄像机功能</p> 
 <p align="left">OGRE通过setFrustumOffset()和setFocalLength()方法支持真实的渲染。例如，你可以通过水平地适配一个摄像机来模拟眼睛间的距离。这会在适配的摄像机中渲染出一个有微小角度区别的画面，以此产生真实的输出。当然，这种技术是高度专业化和细节很多的，但是它确被提供给这种需要的人。</p> 
 <p align="left">OGRE也允许你直接操作视点和法线的矩阵。这当然是更高级的话题了，回到我们先前所说的“只有在你确信知道你所做并且为何这么做的时候才做”上来，因为这些矩阵在你设定摄像机的时候就已经为你计算好了。下面的方法是用来操作view/projection的矩阵的：</p> 
 <p align="left"><strong>const </strong>Matrix4&amp; getProjectionMatrixRS(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left"><strong>const </strong>Matrix4&amp; getProjectionMatrixWithRSDepth(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left"><strong>const </strong>Matrix4&amp; getProjectionMatrix(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left"><strong>const </strong>Matrix4&amp; getViewMatrix(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left"><strong>void </strong>setCustomViewMatrix(<strong>bool </strong>enable,</p> 
 <p align="left"><strong>const </strong>Matrix4&amp; viewMatrix = Matrix4::IDENTITY);</p> 
 <p align="left"><strong>bool </strong>isCustomViewMatrixEnabled(<strong>void</strong>) <strong>const;</strong></p> 
 <p align="left"><strong>void </strong>setCustomProjectionMatrix(<strong>bool </strong> enable,</p> 
 <p align="left"><strong>const </strong>Matrix4&amp; projectionMatrix = Matrix4::IDENTITY);</p> 
 <p align="left"><strong>bool </strong>isCustomProjectionMatrixEnabled(<strong>void</strong>) <strong>const;</strong></p> 
 <p align="left"><strong> </strong></p> 
 <p align="left">列出的前两行代码返回渲染系统设定的法线矩阵。getProjectionMatrixRS()会返回渲染系统得本地坐标，而getProjectionMatrixWithRSDepth()会以OGRE本身的格式（右手坐标系的方式）返回矩阵。区别是深度值（depth value）会根据所用的渲染系统而覆盖[0,1]或[-1,1]的范围。你可以用调用getProjectionMatrix()来避免这些使其总是返回[-1,1]间的一个值。</p> 
</div> 
<p> </p> 
<p> </p> 
<p> </p> 
<h2>自己学习OGRE的笔记4</h2> 
<div class="item-title revoArtlabel"> 
 <span class="revoLeft">分类： <a href="http://lyme.blog.sohu.com/entry/1340641/" rel="nofollow"> 日记</a> </span> 
 <span class="revoRight">2007-11-26 21:33</span> 
</div> 
<div class="item-content" id="main-content"> 
 <p>    今天又看了点，逮到时间上网就再发点上来吧.</p> 
 <p>   </p> 
 <p align="left">当你设定了一个自定义的view或者projection矩阵，你必须意识到OGRE不再根据摄像机的移动或转向来更新矩阵数据。你必须在每次你移动它的数据源的时候手动更新这个矩阵。你可以用enable参数在setCustomViewMatrix()和setCustomProjectionMatrix()中开关自定义矩阵功能。当这个功能被关闭时，OGRE会像平常一样为你继续更新内部矩阵。</p> 
 <p align="left"> </p> 
 <p align="left">大多数时候，OGRE的LOD（level of detail）手柄控制得相当完美。可是，有些时候你需要越过它的默认设置，OGRE提供了这样的Camera方法来做这些：</p> 
 <p align="left"><strong>void</strong> setLodBias(Real factor = 1.0);</p> 
 <p align="left">Real getLodBias(<strong>void</strong>) <strong>const</strong>;</p> 
 <p align="left">setLodBias()其实不是一个固定的指令。场景中的元素可以忽略这条指令，making it more of a hint if LoD overrides are widespread in the scene or application。factor参数控制摄像机增减它渲染显示的细节。当其大于1.0时增加渲染细节，小于1.0时减少渲染细节。这在实施不需要全部细节的摄像机例如rear-view（这里可能是打印错误，不知道rear-view是什么东西）时很有用。</p> 
 <p align="left"> </p> 
 <p align="left">将全部场景的部分显示到屏幕上</p> 
 <p align="left">一个非常平常的需要，尤其在大量使用鼠标操作的程序中，就是将全部场景的部分按一定方式显示到屏幕上。摄像机的中心轴线和屏幕相交的点是一个特殊的点，也就是[0.5,0.5]那一点（在标准坐标系中）。如果你在屏幕上移动鼠标指针，你可能想要以摄像机为原点到鼠标所在位置定义一条线。这条线就是一条射线(ray)，它在getCameraToViewportRay()函数中返回：</p> 
 <p align="left">// x and y are in “normalized” (0.0 to 1.0) screen coordinates</p> 
 <p align="left">Ray getCameraToViewportRay(Real x, Real y) const;</p> 
 <p align="left">通过这条线，你可以通过场景管理器查询哪些物体和这条线相交。关于场景管理器的更详细的细节将在这本书的后面介绍。</p> 
 <p align="left"> </p> 
 <p align="left">视口(Viewport)</p> 
 <p align="left">一个Viewport的实例通过一个RenderWindow的实例获得，这种检索视口的方法使用Camera的实例作为长参数（and the method that retrieves the viewport takes an instance of Camera as the long parameter, 没怎么看明白）。这意味着单个的Camera实例可以驱动0个以上的Viewport对象。</p> 
 <p align="left">视口不使用ill效果就可以重叠。默认的，OGRE在渲染后一个视口中的物体时会对前一个视口的depth和color数据缓冲先进行清理，来避免depth-blending（指不同视口的不同深度数据的混淆）的错误。如果需要你可以有无数个摄像机和视口。使用多重摄像机和视口的一个通常的作用是在游戏中层叠缩放的窗口(“picture-in-picture” zoom windows in a game)。</p> 
 <p align="left"> </p> 
 <p align="left"><strong>Tip </strong>Something to keep in mind when considering viewports and camera zoom is that it is not enough simply to narrow the field of view on the camera to create a zoomed image. This is because Ogre will still be using the camera position to calculate level of detail for the zoom, and what you will find is that the objects in your zoom window will look terrible, since they will still be at the correct level of detail for their distance from the camera. Solution: when you zoom, move the camera closer to the zoom target, or use a secondary camera (which is required for picture-in-picture zooms), or use Camera::setLodBias() to increase the level of detail rendered.</p> 
 <p align="left"> </p> 
 <p align="left">大意是，考虑摄像机视口的缩放时不仅仅是缩放视口数据，OGRE使用摄像机位置来计算缩放所显示的细节，你在缩放后的窗口中看到的物体会严重变形，因为它们还在原先的距离上的level of detail上。解决方法是：当你进行缩放的时候，将摄像机移近被缩放的目标，或者使用另一个摄像机，或者使用Camera::setLodBias()来增加渲染细节。</p> 
 <p align="left"> </p> 
 <p align="left">视口有一个z-order，这个参数用来指出哪个视口的渲染结果会被另一个视口用到。高优先级的视口会被放到栈的上部。只有viewport可以占据一个给出的渲染窗口的z-order。例如，如果你有两个z-order 0上的视口，将会抛出一个异常。</p> 
 <p align="left">每个视口可以有一个独立的背景颜色。例如，你可以有一个在z-order 1下的覆盖整个窗口的主视口，它的背景色为黑色，和一个小一点的z-order 0上的视口，蓝色背景，如以下代码所示：</p> 
 <p align="left">// assume window is a valid pointer to an existing render window, and camera is</p> 
 <p align="left">// a valid pointer to an existing camera instance</p> 
 <p align="left">Viewport *vpTop, *vpBottom;</p> 
 <p align="left">// second parameter is z-order, remaining params are position and size, respectively</p> 
 <p align="left">vpBottom = window-&gt;addViewport(camera, 0);</p> 
 <p align="left">// create a smaller viewport on top, in the center, 25% of main vp size</p> 
 <p align="left">vpTop = window-&gt;addViewport(camera, 1,</p> 
 <p align="left">0.375f, 0.375f,</p> 
 <p align="left">0.25, 0.25);</p> 
 <p align="left">// set the background of the top window to blue (the default is black so we don't</p> 
 <p align="left">// need to set the bottom window explicitly)</p> 
 <p align="left">vpTop-&gt;setBackgroundColour(ColourValue(0.0f, 0.0f, 1.0f));</p> 
 <p align="left">// an alternate way to set the color is to use the manifest constant for blue</p> 
 <p align="left">// vpTop-&gt;setBackgroundColour(ColourValue::Blue);</p> 
 <p align="left"> </p> 
 <p align="left">我前面提到OGRE默认在每帧开始前清理depth和color数据缓冲。你可以独立操作这些设定，使用Viewport中的setClearEveryFrame()函数：</p> 
 <p align="left">// As mentioned, these both default to “true”. The flags are maskable; in other</p> 
 <p align="left">// words, setClearEveryFrame(true, FBT_COLOUR|FBT_DEPTH) is valid.</p> 
 <p align="left">vpTop-&gt;setClearEveryFrame(true, FBT_COLOUR);</p> 
 <p align="left">vpTop-&gt;setClearEveryFrame(false);</p> 
 <p align="left"> </p> 
 <p align="left">使用picture-in-picture式的视口时另一个需要考虑到的因素就是overlays覆盖物，这些overlays默认情况下在任何视口中都是可见的。这不是你在一个缩放窗口中想要的，所以你可以关闭overlay渲染。同样skyboxes和shadows也一样。</p> 
 <p align="left">vpTop-&gt;setOverlaysEnabled(false);</p> 
 <p align="left">vpTop-&gt;setSkiesEnabled(false);</p> 
 <p align="left">vpTop-&gt;setShadowEnabled(true);</p> 
 <p align="left"> </p> 
 <p align="left">你可以做更多更先进的操作，例如渲染序列并且使用一个per-viewport材质结构，本书以后会讲到这些。</p> 
 <p align="left"> </p> 
 <p align="left">主渲染循环(main rendering loop)</p> 
 <p align="left">典型的OGRE程序会按帧不间断地依次渲染。我们先前就知道调用这个渲染循环的方法：使用Root::startRendering()方法。但是，这种方法只是简单地开始一个小的渲染循环和调用另一个函数：renderOneFrame()。</p> 
 <p align="left">renderOneFrame()存在的理由，首先，你可能希望将ogre合并进一个程序或者模版中。其次，你可能需要重定义渲染方式。</p> 
 <p align="left">下面所示的代码被故意写到最简，它旨在向你演示你应该怎样在你的程序中手动设置渲染循环：</p> 
 <p align="left">bool keepRendering = true;</p> 
 <p align="left"> </p> 
 <p align="left">// Do all of the Ogre setup we've covered so far in this chapter: loading plug-ins,</p> 
 <p align="left">// creating render window and scene manager and camera and viewport, and putting</p> 
 <p align="left">// some stuff in our scene.</p> 
 <p align="left"> </p> 
 <p align="left">while (keepRendering)</p> 
 <p align="left">{<!-- --></p> 
 <p align="left">// process some network events into engine messages</p> 
 <p align="left">// process some input events into engine messages</p> 
 <p align="left">// update scene graph (manager) based on new messages</p> 
 <p align="left">// render the next frame based on the new scene manager state</p> 
 <p align="left">root-&gt;renderOneFrame();</p> 
 <p align="left"> </p> 
 <p align="left">// check to see if we should stop rendering</p> 
 <p align="left">// Note: NextMessageInQueue() is completely fictional and used here only</p> 
 <p align="left">// for purposes of illustration -- it does not exist in Ogre.</p> 
 <p align="left"> </p> 
 <p align="left">if (NextMessageInQueue() == QUIT)</p> 
 <p align="left">{<!-- --></p> 
 <p align="left">keepRendering = false;</p> 
 <p align="left">}</p> 
 <p align="left">}</p> 
 <p align="left"> </p> 
 <p align="left">// Do whatever cleanup your application needs</p> 
 <p align="left">// Then, shut down Ogre</p> 
 <p align="left">delete root;</p> 
 <p align="left"> </p> 
 <p align="left">不重要的，看renderOneFrame()函数的代码：</p> 
 <p align="left">Bool Root::renderOneFrame(void)</p> 
 <p align="left">{<!-- --></p> 
 <p align="left">    If(!_fireFrameStarted())</p> 
 <p align="left">        Return false;</p> 
 <p align="left"> </p> 
 <p align="left">    _updateAllRenderTargets();</p> 
 <p align="left">    Return _fireFrameEnded();</p> 
 <p align="left">}</p> 
 <p align="left"> </p> 
 <p align="left"> </p> 
 <p align="left"><strong>总结</strong></p> 
 <p align="left">在这一章中，学习了怎样初始化和设定Ogre程序，和各种可见的类(RenderWindow, Camera, Viewport)是怎样配合工作和显示你的场景的。在下一章中，我们将开始讲解真正的内容。</p> 
 <p align="left"> </p> 
 <p align="left"> </p> 
 <p align="left">这个星球上（可能在其它星球上也是）每个3D渲染库都使用一个场景图来组织它可渲染的项目。（原句：Every 3D rendering library on the planet (and even some on other planets) uses a scene graph to organize its renderable items. 搞笑~~） 这个scene graph通常都是为了更快地搜索和查询而优化过的。有时scene graph也被用作碰撞检测(collision detection，一种在场景中求交的运算)。有时候单个的scene graph也被用在程序中任何一个子系统上，包括音效和物理模拟系统。</p> 
 <p align="left"> </p> 
 <p align="left">在OGRE中你可以在同一场景中同时使用多个场景管理器。</p> 
 <p align="left"> </p> 
 <p align="left">一般来说，OGRE中的场景管理器有以下作用：</p> 
 <p align="left">·在场景中创建和放置可移动的物体、光源，和摄像机，并且有效地将它们注册到一个穿程图中(access them efficiently in a graph traversal)。</p> 
 <p align="left">·载入和装配世界坐标中的几何体（differentiated from movable entities in that world geometry is large, sprawling, and generally not movable）</p> 
 <p align="left">·执行场景序列并且提供这样问题的答案：哪些物体包含在以世界坐标系中某一点为中心的圆中？</p> 
 <p align="left">·拣选出不可见的物体和将可见的物体加入渲染序列中。</p> 
 <p align="left">·从当前渲染视图的透视图中依增加的距离组织和分类无向的光线。(Organizing and sorting (by increasing distance) nondirectional lights from the perspective of the current renderable)</p> 
 <p align="left">·设定和渲染场景中的阴影。</p> 
 <p align="left">·设定和渲染场景中的所有其它物体，比如说背景和Skyboxex</p> 
 <p align="left">·将这种组织后的目录传递给渲染系统</p> 
</div> 
<p> </p> 
<p> </p> 
<p> </p> 
<h2>自己学习OGRE的笔记5（值得好好看看）</h2> 
<div class="item-title revoArtlabel"> 
 <span class="revoLeft">分类： <a href="http://lyme.blog.sohu.com/entry/1340641/" rel="nofollow"> 日记</a> </span> 
 <span class="revoRight">2007-12-05 22:26</span> 
</div> 
<div class="item-content" id="main-content"> 
 <p>现在网上已经可以找到PRO OGRE 3D PROGRAMMING这本书的中文译本, 翻得还是挺不错的, 至少比直接看英文版舒服多了(ORZ....) 不管怎么说, 看中文版的进度快多了, 有些地方看不太懂的可以回英文的原书看一下. 总的来说, 没有STD的基础学OGRE还是很痛苦的, 还有, 想用OGRE写个象样的程序的话, 会点计算机图形学的基础还是很必要的, 要是写的程序用到的3D场景只是象仙剑3那个级别的话, 还是自己写个引擎好了, terrain的场景管理器对那样平面的地形实在是太浪费了, 你甚至用不上八叉树那种分割方式, 按我原先想的甚至只要简单的二维映射, 一句话, OGRE太复杂了, 很多东西理解不了, 尤其是低层优化时要用到的cg语言, 当真会了这些, 你已经完全可以自己写一个引擎了. </p> 
 <p>另外感叹一句, 那个传说中的CELayoutEditor的bug多得真是吓人啊~~~~~~而且CEGUI官方完全没有补正它的意思, 想找捷径还是不可取的, 自己动手, 丰衣足食.</p> 
 <p>我想加快时间拿个DEMO出来, 至于程序的其他部分以后再说吧...</p> 
 <p> </p> 
 <p>场景管理器的种类</p> 
 <p align="left">OGRE论坛上经常会有人这样提问：“为什么你们要强调‘场景种类’呢？为什么不直接把它们交给场景管理器呢？”原因是场景管理器是OGRE当成插件载入的，你可以为你的程序载入多个不同的场景管理器插件。</p> 
 <p align="left"> </p> 
 <p align="left"><strong>场景中物体的创建</strong></p> 
 <p align="left">场景管理器最平常的作用就是以各种方式创建物体，不管是可移动的还是不可移动的：光源，摄像机，实体，粒子系统，公告牌，等等，以及skybox，静态几何体，和载入地图。所有的存在于一个场景中的物体都被场景管理器管理。这就允许开发者在需要时自定义物体创建的方式及程序的行为。注意管理器管理所有被其创建的物体的生命周期：每种物体都提供了创建、选取、删除和删除所有的方法。所有由场景管理器创建的物体必须由相应的场景管理器来删除：换言之，退出了场景管理器猴你不能删除任何该场景中的指针。</p> 
 <p align="left"> </p> 
 <p align="left"><strong>Caution </strong>If you destroy a scene node with live (meaning referenced) content or data still attached, Ogre will not crash, but you will need to ensure that the objects that <strong>were </strong>attached to the node are properly disposed of to avoid memory leaks. You can manage the lifetime of scene nodes as you see fit, but you do have to exercise caution and due diligence with your godlike powers over the helpless scene nodes.</p> 
 <p align="left">注意：如果你删除一个正在被引用的节点，OGRE不会崩溃，但是你将需要确认连接到该节点的物体不会导致内存溢出。你可以按你认为合适的方式控制场景节点的生命周期，但是你必须以造物主般的负责精神来管理这些任你摆弄的场景节点。</p> 
 <p align="left"> </p> 
 <p align="left">了解三个主要的空间变换（移动、旋转、缩放）是通过场景节点来实施的，而不是具体的物体本身。换言之，是场景的节点在移动，而不是场景中的物体；场景中的物体只是个驾驭者。</p> 
 <p align="left"> </p> 
 <p align="left">场景查询</p> 
 <p align="left">场景管理器的第二大用处就是场景查询：ray queries, sphere(区域) queries, bounding-box(边界盒) queries, bounding-plane queries, and intersection(碰撞) queries.</p> 
 <p align="left">这些查询结果是实时更新的，是为诸如地形检测(terrain-clamping)之类的情形服务的。</p> 
 <p align="left"> </p> 
 <p align="left"><strong>Note </strong>Terrain clamping refers to the process of maintaining a constant distance (possibly zero) between an object and world geometry (usually outdoor terrain or landscapes). In order to do this, you need to know the height of the terrain directly underneath an object, and the simplest way to do that in Ogre is with a raycast (<strong>指直线的正投射</strong>) (ray scene query) pointing straight down, to obtain a world fragment. You can then get the world height of that fragment and set your object’s offset on that basis. This is a very common technique.</p> 
 <p align="left"> </p> 
 <p align="left"><strong>空间关系和三维转换 (Spatial Relationships and 3D Transforms)</strong></p> 
 <p align="left">那些初接触3D软件开发的人通常感到很难区分节点和content objects的关系，甚至是节点与节点间的关系。为了是他们易于理解，让我们看些实际的三维软件的例子吧。</p> 
 <p align="left"> </p> 
 <p align="left">空间关系</p> 
 <p align="left">当你回忆那些基本的三维算法的时候，你知道position(位置坐标), orientation(方向), 和scale(缩放比例)可以表达成一个特殊关系空间中的4×4的矩阵。这个关系空间被定义为 “一系列给定的坐标轴(in terms of a given set of coordinate axes)”。</p> 
 <p align="left"> </p> 
 <p><strong>静态几何体（Static Geometry）</strong></p> 
 <p>看起来似乎静态几何体是活动物体（Moveable Object）的反义词，但事实上也不全是：通常来说静态几何体会由很多不再活动的活动物体来构成。</p> 
 <p> </p> 
 <p>在这里需要要再次提到这个问题，现代的GPU更适合渲染少量巨大物体，而不是很多小几何片断。</p> 
 <p> </p> 
 <table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><strong>注意：</strong>因为这个原因，当在现在图形硬件上来测试3D应用程序性能时，光衡量渲染三角面数量的能力通常是没有意义的事情：比如当一百万个三角面捆绑成一个簇里能达到每秒300帧的渲染速度，在结构组织改变的时候，把这些三角形分布在一千个簇中（平均每簇一千个三角面），就可能会降低到30帧每秒这样的结果。所以在现代3D应用程序中可渲染三角面的数量已经不是衡量应用程序的唯一标准。</p> </td></tr></tbody></table> 
 <p> </p> 
 <p>所以通常而言，越多的三角面集中在一个簇中渲染，对提升你的应用程序效率越有利（当然，也不能盲目，很多时候还要考虑诸如图形硬件带宽吞吐量等诸多因素的影响。）</p> 
 <p> </p> 
 <p>可能在这里你会觉得把复杂的场景作为静态物体来处理可能是一个不错的注意，但事实也并非如此，在下面列出静态物体的几个缺点：</p> 
 <p> </p> 
 <p>·一般而言，巨大的静态物体需要在使用前被构建，通常这是一个缓慢的过程，所以不能在每一帧都执行。</p> 
 <p> </p> 
 <p>· 静态几何体将按着放入物体的材质来进行分类，并且把材质相同的集合体放置到同一个渲染设置当中（换句话说，也就是放到同一个簇中）。但这并不表示只要把一组几何体打包成一个静态物体就能神奇的把它们捆绑到一个渲染设置中：不同材质的物体仍然会被拆分成不同的簇中被渲染。所以这时候你需要在两种需求中进行折衷：是在一次调用中渲染最多的三角形还是最少的调用的次数（也就意味着决定在静态物体中放置多少不同的材质）。</p> 
 <p> </p> 
 <p>·在静态几何体中“静态”的含义是：一旦物体被放入静态几何体中，你就不能在单独移动它了。任何对静态几何体的世界变换都会应用到所有里面包含的物体上。这就好像放入咖啡中的方糖，你可以扔进去，但是再也捞不到它了。</p> 
 <p> </p> 
 <p>·通常来说静态几何体会比同样大小的活动物体占用更多的内存；这是因为对于活动物体来说，可以多个实体共享一个网格模型。而静态几何体会为每一个实体创建一个网格模型数据的拷贝。不过在这本书写作的时候，GPU的几何处理也正在发生变革，可能在这本书出版之后，硬件会支持更加优化静态几何体的处理方式。</p> 
 <p> </p> 
 <p>·就算在你的视野里（视截体）中看到了整个静态几何体的一小部分，甚至包括在你身后的整个数据都会传到图形硬件中渲染。假如你把场景中所有的植被都放到一个静态物体中，即使你只看到一颗小草，那么整个森林都会被渲染。</p> 
 <p>此外，在场景对静态几何体材质和模型的LoD（细节等级）处理中，会遵照整个静态场景最远的物体距离来设定整组物体的等级。这导致当距离改变的时候，整个静态物体的LoD都会有相同的改变。不过除了上面说的问题之外也有好的一面，场景管理器会通过空间分割算法把静态几何体分组，进而把那些没有在显示空间的静态几何体直接屏蔽到渲染队列之外。对于静态几何体的处理就和所有软件工程中所出现的问题一样，你必须为提高程序的性能而进行一系列设计上的折衷。</p> 
 <p align="left"> </p> 
 <p align="left"> </p> 
 <p align="left">具体例子见 第五章-〉通过例子了解场景管理器。。</p> 
 <p>virtual void chooseSceneManager(void)　//　为什么这里是virtual??</p> 
 <p>    {<!-- --></p> 
 <p>        // Create the SceneManager, in this case a generic one</p> 
 <p>        mSceneMgr = mRoot-&gt;createSceneManager(ST_GENERIC, "ExampleSMInstance");</p> 
 <p>    }</p> 
 <p>    virtual void createCamera(void)</p> 
 <p>    {<!-- --></p> 
 <p>        // Create the camera　看下代码中createCamera的返回值是什么型的！！</p> 
 <p>        mCamera = mSceneMgr-&gt;createCamera("PlayerCam");</p> 
 <p> </p> 
 <p>        // Position it at 500 in Z direction </p> 
 <p>        mCamera-&gt;setPosition(Vector3(0,0,500));</p> 
 <p>        // Look back along –Z　lookAt函数见前面所述</p> 
 <p>        mCamera-&gt;lookAt(Vector3(0,0,-300));</p> 
 <p>        mCamera-&gt;setNearClipDistance(5);</p> 
 <p>        mCamera-&gt;setFarClipDistance(1000);</p> 
 <p>// 原书的说明：在代码中，视截体的近截面被设置为5个世界单位；在本书前面提到过，在默认的情况下，Ogre把近截面的距离设置为100单位，远截面为1000 000单位。但是事实上这并不是一个好主意，为了确保深度缓存精度的细致，把远近界面调整为近似1000:1的比率会得到较好的效果。所以在代码5-1中的最后，我擅自增加了一行演示程序中没有的代码，把远截面的距离调整为1000（而不是默认的1000 000）。</p> 
 <p>    }</p> 
 <p align="left"> </p> 
 <p>void createScene(void)</p> 
 <p>{<!-- --></p> 
 <p>   // Set ambient light</p> 
 <p>   mSceneMgr-&gt;setAmbientLight(ColourValue(0.5, 0.5, 0.5));</p> 
 <p>   // Create a point light</p> 
 <p>   Light* l = mSceneMgr-&gt;createLight(“MainLight”);</p> 
 <p>   </p> 
 <p>   // Accept default settings: point light, white diffuse, just set position</p> 
 <p>   // NB I could attach the light to a SceneNode if I wanted it to move</p> 
 <p>   // automatically with other objects, but I don’t</p> 
 <p>   l-&gt;set Position(20,80,50);</p> 
 <p>   </p> 
 <p>   Entity * ent = mSceneMgr-&gt;createEntity(“head”, “ogrehead.mesh”);</p> 
 <p> </p> 
 <p>   // Set material loaded from Example.material</p> 
 <p>   Ent-&gt;setMaterialName(“Examples/EnvMappedRustySteel”);</p> 
 <p> </p> 
 <p>   // Add entity to the root scene node</p> 
 <p>   mSceneMgr-&gt;gerRootSceneNode()-&gt;createChildSceneNode()-&gt;attachObject(ent);</p> 
 <p>}</p> 
 <p align="left"> </p> 
 <p>场景节点在默认的情况下变换空间为父节点空间（TS_PARENT），所以在使用父节点空间变换的时候不需要额外的设置：</p> 
 <p> </p> 
 <table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p>mSceneNode-&gt;translate(100.0, 10.0, 0.0);</p> </td></tr></tbody></table> 
 <p> </p> 
 <p>但是如果需要在世界空间进行节点变换，就的通过下面的方法来调用：</p> 
 <p> </p> 
 <table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p>mSceneNode-&gt;translate(100.0, 10.0, 0.0, TS_WORLD);</p> </td></tr></tbody></table> 
 <p> </p> 
 <p>对于本体空间的变换也同样如此。下面表示将一个节点沿着它朝向的方向“向前”移动100个单位：</p> 
 <p> </p> 
 <table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p>mSceneNode-&gt;translate(0.0,0.0,100.0,TS_LOCAL);</p> </td></tr></tbody></table> 
 <p> </p> 
 <p>对于旋转场景节点而言，默认的变换空间为本地空间（TS_LOCAL）；如果你需要不同的旋转空间，必须明确的告知Ogre：</p> 
 <p> </p> 
 <table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p>// 对象绕自己的Y轴旋转一弧度，大约57角度 </p> <p>mSceneNode-&gt;yaw(Ogre::Radian(1.0));</p> <p> </p> <p>// 对象绕父节点的X轴旋转一弧度，大约57角度</p> <p>mSceneNode-&gt;pitch(Ogre::Radian(1.0), TS_PARENT);</p> <p> </p> <p>// 对象绕世界的Z轴旋转一弧度，大约57角度</p> <p>mSceneNode-&gt;roll(Ogre::Radian(1.0),TS_WORLD);</p> </td></tr></tbody></table> 
 <p> </p> 
 <p>缩放不需要关系空间；它在节点本身执行，同时影响节点的所有子节点。</p> 
 <p> </p> 
 <table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p>// 在X轴缩放两倍，其他轴不缩放</p> <p>mSceneNode-&gt;scale(2.0, 1.0, 1.0);</p> </td></tr></tbody></table> 
 <p> </p> 
 <p> </p> 
 <table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p>提示：如果你在缩放场景节点的时候，发现实体模型忽然产生了奇怪的变化。可能是因为法线也一同被缩放所致，因为光线计算会参照标准法线的数据，而缩放后的法线将会对计算产生相应的影响。解决的办法是通过在缩放后调用setNormaliseNormals()方法，不过这也会消耗一些执行效率。</p> </td></tr></tbody></table> 
 <p align="left"> </p> 
 <p><strong>载入世界地图</strong></p> 
 <p>至今为止的演示都是载入对象到一个空的世界。大多数应用程序，需要有一个“布景”来作为放置对象的场所：换句话说就是载入“世界地图”。Ogre的场景管理器提供一个可以方便的用来载入世界地图到场景中的方法。</p> 
 <p align="left"> </p> 
 <p><strong>基本室外场景</strong></p> 
 <p>在这里首先让我们看一下Terrain演示程序的代码</p> 
 <p>    void createScene(void)</p> 
 <p>{<!-- --></p> 
 <p>        // Set ambient light</p> 
 <p>        mSceneMgr-&gt;setAmbientLight(ColourValue(0.5, 0.5, 0.5));</p> 
 <p>        // Create a light</p> 
 <p>        Light* l = mSceneMgr-&gt;createLight("MainLight");</p> 
 <p>        </p> 
 <p>// Accept default settings: point light, white diffuse, just set position</p> 
 <p>        l-&gt;setPosition(20,80,50);</p> 
 <p> </p> 
 <p>        ColourValue fadeColour(0.93, 0.86, 0.76);</p> 
 <p>        mSceneMgr-&gt;setFog( FOG_LINEAR, fadeColour, .001, 500, 1000);</p> 
 <p>        mWindow-&gt;getViewport(0)-&gt;setBackgroundColour(fadeColour);</p> 
 <p> </p> 
 <p>        std::string terrain_cfg(“terrain.cfg”);</p> 
 <p>        mSceneMgr -&gt; setWorldGeometry(terrain_cfg);</p> 
 <p> </p> 
 <p>        // Infinite far plane?</p> 
 <p>        if (mRoot-&gt;getRenderSystem()-&gt;getCapabilities()-&gt;hasCapability(RSC_INFINITE_FAR_PLANE))</p> 
 <p>        {<!-- --></p> 
 <p>            mCamera-&gt;setFarClipDistance(0);</p> 
 <p>        </p> 
 <p>        // Define the required skyplane</p> 
 <p>        Plane plane;</p> 
 <p>        // 5000 world units from the camera</p> 
 <p>        plane.d = 5000;</p> 
 <p>        // Above the camera, facing down</p> 
 <p>        plane.normal = -Vector3::UNIT_Y;</p> 
 <p> </p> 
 <p>        // Set a nice viewpoint</p> 
 <p>        mCamera-&gt;setPosition(707,2500,528);</p> 
 <p>        mCamera-&gt;lookAt(0, 0, 0);</p> 
 <p>}</p> 
 <p align="left"> </p> 
 <p align="left">下面是OGRE.CFG：</p> 
 <p># The main world texture (if you wish the terrain manager to create a material for you)</p> 
 <p>WorldTexture=terrain_texture.jpg</p> 
 <p> </p> 
 <p># The detail texture (if you wish the terrain manager to create a material for you)</p> 
 <p>DetailTexture=terrain_detail.jpg</p> 
 <p> </p> 
 <p>#number of times the detail texture will tile in a terrain tile</p> 
 <p>DetailTile=3   // 这里又是什么？？</p> 
 <p> </p> 
 <p># Heightmap source</p> 
 <p>PageSource=Heightmap</p> 
 <p> </p> 
 <p># Heightmap-source specific settings</p> 
 <p>Heightmap.image=terrain.png</p> 
 <p> </p> 
 <p># If you use RAW, fill in the below too</p> 
 <p># RAW-specific setting - size (horizontal/vertical)</p> 
 <p>#Heightmap.raw.size=513</p> 
 <p># RAW-specific setting - bytes per pixel (1 = 8bit, 2=16bit)</p> 
 <p>#Heightmap.raw.bpp=2</p> 
 <p> </p> 
 <p># How large is a page of tiles (in vertices)? Must be (2^n)+1</p> 
 <p>PageSize=513   // 是什么？？</p> 
 <p> </p> 
 <p># How large is each tile? Must be (2^n)+1 and be smaller than PageSize</p> 
 <p>TileSize=65</p> 
 <p> </p> 
 <p># The maximum error allowed when determining which LOD to use</p> 
 <p>MaxPixelError=3</p> 
 <p> </p> 
 <p># The size of a terrain page, in world units</p> 
 <p>PageWorldX=1500</p> 
 <p>PageWorldZ=1500</p> 
 <p># Maximum height of the terrain </p> 
 <p>MaxHeight=100</p> 
 <p> </p> 
 <p># Upper LOD limit</p> 
 <p>MaxMipMapLevel=5</p> 
 <p> </p> 
 <p>#VertexNormals=yes</p> 
 <p>#VertexColors=yes</p> 
 <p>#UseTriStrips=yes</p> 
 <p> </p> 
 <p># Use vertex program to morph LODs, if available</p> 
 <p>VertexProgramMorph=yes</p> 
 <p> </p> 
 <p># The proportional distance range at which the LOD morph starts to take effect</p> 
 <p># This is as a proportion of the distance between the current LODs effective range,</p> 
 <p># and the effective range of the next lower LOD</p> 
 <p>LODMorphStart=0.2</p> 
 <p> </p> 
 <p># This following section is for if you want to provide your own terrain shading routine</p> 
 <p># Note that since you define your textures within the material this makes the </p> 
 <p># WorldTexture and DetailTexture settings redundant</p> 
 <p> </p> 
 <p># The name of the vertex program parameter you wish to bind the morph LOD factor to</p> 
 <p># this is 0 when there is no adjustment (highest) to 1 when the morph takes it completely</p> 
 <p># to the same position as the next lower LOD</p> 
 <p># USE THIS IF YOU USE HIGH-LEVEL VERTEX PROGRAMS WITH LOD MORPHING</p> 
 <p>#MorphLODFactorParamName=morphFactor</p> 
 <p> </p> 
 <p># The index of the vertex program parameter you wish to bind the morph LOD factor to</p> 
 <p># this is 0 when there is no adjustment (highest) to 1 when the morph takes it completely</p> 
 <p># to the same position as the next lower LOD</p> 
 <p># USE THIS IF YOU USE ASSEMBLER VERTEX PROGRAMS WITH LOD MORPHING</p> 
 <p>#MorphLODFactorParamIndex=4</p> 
 <p> </p> 
 <p># The name of the material you will define to shade the terrain</p> 
 <p>#CustomMaterialName=TestTerrainMaterial</p> 
</div> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4c055821f487d6b273b92aa898ae44dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">多媒体参数列表详解：</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f455997954a2088820ee3696a56d917/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GetOverlappedResult</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>