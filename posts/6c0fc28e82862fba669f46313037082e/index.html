<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux---进程 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux---进程" />
<meta property="og:description" content="@toc
操作系统 传统的计算机系统资源分为硬件资源和软件资源。硬件资源包括中央处理器，存储器，输入设备，输出设备等物理设备；软件资源是以文件形式保存在存储器上的成熟和数据等信息。
操作系统就是计算机系统资源的管理者。
如果你的计算机没有安装操作系统，那么你将面对的是0，1代码和一些难懂的机器指令，通过按钮或者按键来操作计算机，这样笨拙&#43;费时。安装操作系统之后，你面对的就不再是笨拙的裸机，而是操作便利，服务周到的操作系统，从而明显的改善了用户界面。
操作系统为了保证自己的安全，也为了保证给用户能够提供服务，就以接口的方式给用户提供调用的入口，来获取操作系统内部的数据。
这个接口是操作系统提供的用C语言实现的，自己内部的函数调用---系统调用
所有访问操作系统的行为，都只能通过系统调用完成，因为操作系统不会让你随意的去对自己进行更改。
所以，操作系统就是一个管理者，利用操作系统能够有效的组织和管理系统中的各种软硬件资源，合理的组织计算机系统工作的流程，控制程序的执行，并且向用户提供一个良好的工作环境和友好的接口。（程序猿通过暴露出的接口，开发出来各种软件供普通用户使用）。
那么操作系统是如何管理的呢？ 在学校中，我们就是最典型的被管理者，校长是管理者。管理者与被管理者是不需要见面的，查考勤情况的活肯定不是校长监督的吧。那么校长连A同学都不知道是谁，怎么管理好这么多同学呢？
其实只要校长拿到了学生的数据，就能进行管理，见不见面不是必须的，就算见面了，也是为了获取某同学的数据。管理的本质：是通过对数据的管理达到对人的管理。
但是不见面的情况下，校长是怎么知道A同学挂没挂科呢？这些数据都可以通过辅导员来拿到数据。
在这里，校长相当于操作系统，辅导员相当于驱动程序，学生相当于软硬件资源。所以操作系统要管理好软硬件资源是通过获取硬件的各种状态数据来进行管理，这个数据从驱动程序中获得。一个硬件不能用了，驱动程序把信息传递给操作系统，操作系统告知用户。
学校中的学生很多，他弄了一个excel表格，让辅导员按照这个表格获取学生的信息，辅导员获取完信息后，在把表格给校长，现在校长要找谁个子最高等信息，只需要遍历一遍表格即可。这个过程就是一个描述的过程。
但校长曾经是一个程序猿，他弄了一个结构体来实现这个表格。
struct student { char 学院[]; char 专业[]; ...... struct student *next; } struct student stu1 = {}; 每一个结构体对象里面存着学生的信息，通过next来对学生进行链接。
所以校长只要把这个学生链表管理好就行了。这样就将对学生的管理工作变成了对链表的增删查改。想找挂科超过3科的，直接遍历链表即可。填写学生信息的过程是描述过程，把学生通过节点链接起来的过程是组织的过程。
操作系统中，管理任何对象，最终就变成了对某种的数据结构的管理。操作系统管理的过程跟上面的例子一样：先描述在组织。
之前写通讯录之类管理系统，先把要存的信息写在结构体中，然后对这个结构体进行封装，这不就是先描述，在组织吗？
struct person { char name; int age; char telphone1; char telphone2; ... } struct contact { struct person[100]; int num; ... } 系统调用和库函数概念 操作系统不相信任何人，只会提供系统调用接口，如果你想简介的访问硬件或者打开文件之类的操作，是不能直接访问底层硬件，而是层层访问，以贯穿的形式。比如说printf函数，他是C标准函数，他的底层绝对要封装系统调用接口，所以C/C&#43;&#43;封装的库函数，和系统调用接口的关系，是上下层被调用的关系，而不是直接绕过系统调用接口直接访问的。
那么谁在上，谁在下呢？
库函数在上，系统调用接口在下，
在开发的角度，操作系统对外表现为一个整体，但是会暴露一部分接口，供程序猿开发使用，这部分由操作系统提供的接口，叫做系统调用 系统调用在使用上， 功能比较基础，对用户的要求也相对较高，所以，有些开发者可以对部分系统调用进行适度封装，从而形成了库，有了库，就很利于上层用户或者开发者进行二次开发 进程 一个已经加载到内存中的程序，叫做进程。
这些已经打开的软件，都是进程，对上面的某一个进程，右键结束任务，就杀死了某个进程。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/6c0fc28e82862fba669f46313037082e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-05T19:45:07+08:00" />
<meta property="article:modified_time" content="2023-11-05T19:45:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux---进程</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="ub95898f4">@<a href="%E8%BF%9B%E7%A8%8B" rel="nofollow">toc</a></p> 
<p id="u6c697b0e"></p> 
<h2 id="30d23ef4">操作系统</h2> 
<p id="u481f8b57"></p> 
<p id="ua23b90dd">传统的计算机系统资源分为硬件资源和软件资源。硬件资源包括中央处理器，存储器，输入设备，输出设备等物理设备；软件资源是以文件形式保存在存储器上的成熟和数据等信息。</p> 
<p id="u9f1637bc"></p> 
<p id="u6377dd59"><strong>操作系统就是计算机系统资源的管理者。</strong></p> 
<p id="ue56271e7"></p> 
<p id="u16b98b57">如果你的计算机没有安装操作系统，那么你将面对的是0，1代码和一些难懂的机器指令，通过按钮或者按键来操作计算机，这样笨拙+费时。安装操作系统之后，你面对的就不再是笨拙的裸机，而是操作便利，服务周到的操作系统，从而明显的改善了用户界面。</p> 
<p id="u3f5cd55e"></p> 
<p id="u0c0be7ac">操作系统为了保证自己的安全，也为了保证给用户能够提供服务，就以接口的方式给用户提供调用的入口，来获取操作系统内部的数据。</p> 
<p id="u6ade8135"></p> 
<p id="uc4d40c6a">这个接口是操作系统提供的用C语言实现的，自己内部的函数调用---系统调用</p> 
<p id="u5a54cb2d"></p> 
<p id="u32fb6d6a">所有访问操作系统的行为，都只能通过系统调用完成，因为操作系统不会让你随意的去对自己进行更改。</p> 
<p id="u9af590ee"></p> 
<p id="uf2ff649f">所以，操作系统就是一个管理者，利用操作系统能够<strong>有效的组织和管理系统中的各种软硬件资源，合理的组织计算机系统工作的流程，控制程序的执行，并且向用户提供一个良好的工作环境和友好的接口。</strong>（程序猿通过暴露出的接口，开发出来各种软件供普通用户使用）。</p> 
<p id="u6f54fb1f"></p> 
<h3 id="85d20e59">那么操作系统是如何管理的呢？</h3> 
<p id="u4fa45c40"></p> 
<p id="ub539e220">在学校中，我们就是最典型的被管理者，校长是管理者。管理者与被管理者是不需要见面的，查考勤情况的活肯定不是校长监督的吧。那么校长连A同学都不知道是谁，怎么管理好这么多同学呢？</p> 
<p id="u4367138d"></p> 
<p id="u3b996695">其实只要校长拿到了学生的数据，就能进行管理，见不见面不是必须的，就算见面了，也是为了获取某同学的数据。管理的本质：<strong>是通过对数据的管理达到对人的管理</strong>。</p> 
<p id="u867c5cc5"></p> 
<p id="u94b8a565">但是不见面的情况下，校长是怎么知道A同学挂没挂科呢？这些数据都可以通过辅导员来拿到数据。</p> 
<p id="u22ea9e52"></p> 
<p id="ue6b53642">在这里，校长相当于操作系统，辅导员相当于驱动程序，学生相当于软硬件资源。所以操作系统要管理好软硬件资源是通过获取硬件的各种状态数据来进行管理，这个数据从驱动程序中获得。一个硬件不能用了，驱动程序把信息传递给操作系统，操作系统告知用户。</p> 
<p id="u536e4e86"></p> 
<p id="ubed8854e">学校中的学生很多，他弄了一个excel表格，让辅导员按照这个表格获取学生的信息，辅导员获取完信息后，在把表格给校长，现在校长要找谁个子最高等信息，只需要遍历一遍表格即可。这个过程就是一个描述的过程。</p> 
<p id="ud7e62f79"></p> 
<p id="ufb6ebca5"></p> 
<p class="img-center"><img alt="" height="448" id="u73ba76ac" src="https://images2.imgbox.com/a1/f5/gjKGvULI_o.png" width="820"></p> 
<p id="u295c3bcc"></p> 
<p id="ued13220c">但校长曾经是一个程序猿，他弄了一个结构体来实现这个表格。</p> 
<p id="ud7fa06ec"></p> 
<pre id="b98a313a"><code>struct student
{
char 学院[];
char 专业[];
......
    struct student *next;
}

struct student stu1 = {};</code></pre> 
<p id="uc43f2b62"></p> 
<p id="uc12f9801">每一个结构体对象里面存着学生的信息，通过next来对学生进行链接。</p> 
<p id="u3b1e6d00"></p> 
<p id="u9f7ae343">所以校长只要把这个学生链表管理好就行了。这样就将对学生的管理工作变成了对链表的增删查改。想找挂科超过3科的，直接遍历链表即可。填写学生信息的过程是描述过程，把学生通过节点链接起来的过程是组织的过程。</p> 
<p id="uc5c80af5"></p> 
<p id="ue0313ab8"><strong>操作系统中，管理任何对象，最终就变成了对某种的数据结构的管理。操作系统管理的过程跟上面的例子一样：先描述在组织。</strong></p> 
<p id="u52141108"></p> 
<p id="uafdf9d03">之前写通讯录之类管理系统，先把要存的信息写在结构体中，然后对这个结构体进行封装，这不就是先描述，在组织吗？</p> 
<p id="ueb420b77"></p> 
<pre id="82d271f8"><code>struct person
{
char name;
int age;
char telphone1;
char telphone2;
...
}

struct contact
{
struct person[100];
int num;
...
}</code></pre> 
<p id="u7c68becc"></p> 
<h3 id="1389ef1d">系统调用和库函数概念</h3> 
<p id="u2fb12786"></p> 
<p id="u3c7edcfc">操作系统不相信任何人，只会提供系统调用接口，如果你想简介的访问硬件或者打开文件之类的操作，是不能直接访问底层硬件，而是层层访问，以贯穿的形式。比如说printf函数，他是C标准函数，他的底层绝对要封装系统调用接口，所以C/C++封装的库函数，和系统调用接口的关系，是上下层被调用的关系，而不是直接绕过系统调用接口直接访问的。</p> 
<p id="u3beb084a"></p> 
<p id="u6a624d2d">那么谁在上，谁在下呢？</p> 
<p id="u2e8cb1ce"></p> 
<p id="ua493778b">库函数在上，系统调用接口在下，</p> 
<hr id="lzyvL"> 
<ul><li id="u45b4b11c">在开发的角度，操作系统对外表现为一个整体，但是会暴露一部分接口，供程序猿开发使用，这部分由操作系统提供的接口，叫做系统调用</li></ul> 
<ul><li id="u4886e62f">系统调用在使用上， 功能比较基础，对用户的要求也相对较高，所以，有些开发者可以对部分系统调用进行适度封装，从而形成了库，有了库，就很利于上层用户或者开发者进行二次开发</li></ul> 
<p id="u580713ba"></p> 
<h2 id="f88522cf">进程</h2> 
<p id="u8c78b96b"></p> 
<p id="u01fe17ea"><strong>一个已经加载到内存中的程序，叫做进程。</strong></p> 
<p id="u93459db2"></p> 
<p id="ubaa2404b"></p> 
<p class="img-center"><img alt="" height="550" id="ud6306a81" src="https://images2.imgbox.com/43/cf/a5CK1Tpw_o.png" width="772"></p> 
<p id="u604d4bd8"></p> 
<p id="u7be56869">这些已经打开的软件，都是进程，对上面的某一个进程，右键结束任务，就杀死了某个进程。</p> 
<p id="ufac6cd7a"></p> 
<p id="u570d159d">在Linux中通过<code>ps ajx</code>可以查看所有的进程。</p> 
<p id="uf6ccf9b6"></p> 
<p id="uc4b3014a"></p> 
<p class="img-center"><img alt="" height="392" id="u6ebe2cb8" src="https://images2.imgbox.com/8b/2e/aR5NiEkA_o.png" width="846"></p> 
<p id="u7bc9baa6"></p> 
<p id="u86d09232">这些进程都有自己的名字和编号。</p> 
<p id="ue5e937f4"></p> 
<p id="u10c8a1e3"><code>top</code>命令，查看正在运行的进程。</p> 
<p id="u01a1b342"></p> 
<p id="u68395e21"></p> 
<p class="img-center"><img alt="" height="478" id="u0ec2ff3d" src="https://images2.imgbox.com/11/24/m9WYUW6S_o.png" width="841"></p> 
<p id="u405d6397"></p> 
<p id="u72d347a4">现在在Linux中写一段代码</p> 
<p id="u786a34ec"></p> 
<pre id="22ffc1a6"><code>#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

int main()
{
    while (true)
        {
            std::cout &lt;&lt; "This is a process." &lt;&lt; std::endl;
            sleep(1);
        }

    return 0;                                                       
}</code></pre> 
<p id="u0d061842"></p> 
<p id="uf8a428ff">在运行这段代码之后，输入指令查看进程。</p> 
<p id="ubf2d3a8e"></p> 
<p id="uf8de612e"></p> 
<p class="img-center"><img alt="" height="122" id="u2dc004fe" src="https://images2.imgbox.com/7b/32/fC9bHBlM_o.png" width="842"></p> 
<hr id="dpxwr"> 
<p id="udabeb4d2">一个名为proc的程序，是保存在磁盘当中的，在计算机开机的时候，操作系统一定是预先加载到内存中的。如果我想把proc运行，根据冯诺依曼结构，这个proc一定会先加载到内存中，是数据的部分，交给控制器；是二进制的部分交给运算器去执行。</p> 
<p id="ua44b03d0"></p> 
<p id="ud9563b2e">但是一个操作系统可以同时运行多个进程，那么操作系统中可能会存在刚打开的进程，正在运行的进程，即将结束的进程，所以操作系统要将这些进程进行管理起来。要想管理，得先让操作系统认识这些进程，也就是先描述起来，然后对这些进程进程管理，也就是组织。</p> 
<p id="uf2e59d5d"></p> 
<h3 id="4e623188">描述进程</h3> 
<p id="u59b4d54d"></p> 
<p id="u9e736424"><strong>任何一个进程在加载到内存的时候，形成真正的进程时，操作系统要先创建描述进程的结构体对象---PCB Process Ctrl Block(进程控制块)</strong></p> 
<p id="uce36d8f8"></p> 
<p id="u2ad6c851">那么PCB是什么呢？？</p> 
<p id="uf651a24e"></p> 
<p id="ud89b056f">要想认识某个事物，就要先知道它的属性，比如说，三边长度一样的封闭图形等。当属性堆积的够多的时候，这些属性集合起来，就是目标对象。</p> 
<p id="u160d2f59"></p> 
<p id="u1b5ae7f1"><strong>所以描述进程就是将最常用的属性放在一起。PCB就是进程属性的集合。</strong></p> 
<p id="u49144d3c"></p> 
<p id="u790cfb73"><strong>而进程就是PCB+程序和数据组成的。</strong></p> 
<p id="ua429d121"></p> 
<p id="ube4fc5a9">PCB的内容</p> 
<table id="218fe2cd"><tbody><tr><td> <p id="ub891a309">信息</p> </td><td> <p id="ub787bcf1">含义</p> </td></tr><tr><td> <p id="ue31e5ce4">进程标识符</p> </td><td> <p id="ud4d28f09">表明系统中的各个进程</p> </td></tr><tr><td> <p id="u597df874">状态</p> </td><td> <p id="ue1a1c284">说明进程当前的状态</p> </td></tr><tr><td> <p id="u17876003">位置信息</p> </td><td> <p id="u32ad3f4e">指名程序及数据在主存或外存的物理位置</p> </td></tr><tr><td> <p id="u64c5fd88">状态信息</p> </td><td> <p id="u7c5ae77c">参数，信号量，消息等</p> </td></tr><tr><td> <p id="u7ce09b54">队列指针</p> </td><td> <p id="u7b487360">链接同一状态的进程</p> </td></tr><tr><td> <p id="u4b408232">优先级</p> </td><td> <p id="uae2496a9">进程调度的依据</p> </td></tr><tr><td> <p id="u02bb4bc4">现场保护区</p> </td><td> <p id="uccced151">将处理机的现场保护到该区域，以便再次调度时能继续正确运行</p> </td></tr><tr><td> <p id="u7e972ab0">其他</p> </td><td> <p id="u3ce21654">因不同的系统而异</p> </td></tr></tbody></table> 
<hr id="ugu2c"> 
<p id="ua8e07a40">程序：程序部分描述了进程需要完成的功能。</p> 
<p id="u2f770c05"></p> 
<p id="u1b3e3942">数据：数据部分包括程序执行时所需的数据及工作区，该部分只能为一个进程所专用，是进程的可修改部分。</p> 
<hr id="rhR55"> 
<p id="uc6d74165"><strong>所以将程序加载到内存中，不光光是把代码和数据放到操作系统中，还会创建用来描述这个程序的PCB对象。</strong></p> 
<p id="u738c6f69"></p> 
<p id="u11797449">PCB中存在指针信息，用来找到自己的代码和数据。</p> 
<p id="ud782f51a"></p> 
<p id="u22177984">系统当中不会只有一个进程，会有多个进程。这些进程，加载到内存中，在创建PCB对象，PCB中存在指针，通过指针再将所有的进程的PCB链接在一块，在通过PCB中的指针，找到自己的代码和数据。这样在操作系统中，对进程的管理，就变成了对单链表进行增删查改！</p> 
<hr id="hlLXA"> 
<p id="u2acb32c6">上面所描述的，是所有操作系统的原理，但是具体的操作系统会有差别。</p> 
<p id="uaf7c774e"></p> 
<p id="uc8024102">那么Linux操作系统是怎么做的？</p> 
<p id="u5a6cf918"></p> 
<p id="ua71100b4">在Linux操作系统下的PCB是 <code>tack_struct</code></p> 
<p id="u52eceae7"></p> 
<p id="u70af2f90">tack_struct是Linux内核的一种数据结构，它会被装载到RAM(内存)里并且包含着进程的信息</p> 
<p id="ud1cc0e1a"></p> 
<p id="u31d5c74d"><strong>task_struct内容分类</strong></p> 
<p id="u72f3f071"></p> 
<p id="u82b214f4">跟上面的PCB的组成一样。</p> 
<hr id="vVPWW"> 
<p id="u6e45739d">PCB -&gt; tack_struct 结构体，里面包含进程的所有属性。</p> 
<p id="u465d08f3"></p> 
<p id="ufd35a9ca">Linux中如何组织进程，Linux内核中，最基本的组织进程tack_struct的方式是采用双向链表组织的。</p> 
<p id="u567e59e2"></p> 
<p id="ua478d45d">但这并不是存粹的双链表，可能task_struct中存在指针，指向一个队列，一棵树等其他数据结构中。Linux中数据结构的关系，一定是复杂的。</p> 
<p id="uabc1859e"></p> 
<p id="u15c111e9">对tack_struct的管理，就是放在某个组织的数据结构中，这个进程要等待，放在等待队列里，要运行，放在运行队列里，所以这个进程要怎么工作，就放在哪一个在组织的数据结构中。</p> 
<hr id="tPBhZ"> 
<p id="uc6a0b0b9"><code>ps ajx | head -1 &amp;&amp; ps ajx | grep ./proc</code>通过这个命令，就可以查看我们刚刚执行的那个名为proc的程序的进程</p> 
<p id="u1b99cd90"></p> 
<p id="ud89c6762"></p> 
<p class="img-center"><img alt="" height="106" id="ubafd1285" src="https://images2.imgbox.com/72/fc/wKMkNoxM_o.png" width="847"></p> 
<p id="u1e8eaa49"></p> 
<p id="u403fb172">也可以通过 proc去查看。<code>ls /proc</code></p> 
<p id="u0a69fafa"></p> 
<p id="u62eb6c48"></p> 
<p class="img-center"><img alt="" height="571" id="u84d10322" src="https://images2.imgbox.com/74/83/GedtWwiz_o.png" width="844"></p> 
<p id="ua789ffef"></p> 
<p id="u94ba1963">这个目录会在关机的时候，全部关闭，再开机的时候，再打开。</p> 
<p id="u25d41edf"></p> 
<p id="uee502a9c">这些蓝色的都是目录，在这里都是以PID(唯一标识符)的形式表示的</p> 
<p id="u90a18686"></p> 
<p id="ua7e51a8d">./proc的PID是9965，既然蓝色的是目录，说明就可以进入到这个目录中查看一些信息。</p> 
<p id="u25f68833"></p> 
<p id="uce843510"></p> 
<p class="img-center"><img alt="" height="239" id="ua2e4a8f6" src="https://images2.imgbox.com/b2/8d/ZJf0vup3_o.png" width="847"></p> 
<p id="u591511d0"></p> 
<p id="ucf6667d8">当我ctrl+c结束这个进程的时候，再次查看这个进程，就会找不到。如果再次启动这个进程，PID就会发生变化。</p> 
<p id="ue4d1528c"></p> 
<p id="ubd0245bf"></p> 
<p class="img-center"><img alt="" height="134" id="u0dbd2f35" src="https://images2.imgbox.com/4a/49/spdq3S8Y_o.png" width="841"></p> 
<p id="u453e9236"></p> 
<p id="ua29c1e76">第二个gerp.../proc的进程是grep ./proc的进程，因为进行过滤的时候系统创建出了这个进程。</p> 
<hr id="m3RSU"> 
<p id="u5f4394f6"></p> 
<p class="img-center"><img alt="" height="103" id="u91dc15ff" src="https://images2.imgbox.com/a0/b5/1ZeLb77x_o.png" width="855"></p> 
<p id="u55499d3a"></p> 
<p id="ufceddada">这个exe文件是一个链接文件，指向正在运行的名为proc的进程。</p> 
<p id="u885f07c3"></p> 
<p id="ua4b7ba3d">cwd是当前进程的工作目录。</p> 
<p id="u39084c8b"></p> 
<p id="u4b7b6b1b"></p> 
<p class="img-center"><img alt="" height="84" id="u20a48f54" src="https://images2.imgbox.com/55/39/n26wSbbN_o.png" width="846"></p> 
<hr id="i8s1H"> 
<p id="u33d3d0a0">再使用 <code>touch</code>命令的时候，直接再某一个目录上 <code>touch</code>为什么能够直接创建出文件，而不用先输入路径呢？因为再使用 <code>touch</code>命令的时候，系统自动创建进程，进程中的cwd会自动记录当前目录的路径。再创建的时候自动的把cwd拼接到要创建的文件名前面。 <code>cwd/FileName</code></p> 
<p id="u0fca85ec"></p> 
<h3 id="75e801a7">通过系统调用获取进程标识符</h3> 
<p id="u1fc16773"></p> 
<p id="u2fd236b6"></p> 
<p class="img-center"><img alt="" height="94" id="ubcadad3e" src="https://images2.imgbox.com/e8/bb/vnRC8T2C_o.png" width="848"></p> 
<p id="u3532dd54"></p> 
<p id="u2fd4f777">每个进程要被管理，就必须有一个唯一的标识符---PID</p> 
<p id="u4ecbce17"></p> 
<p id="u9564d025">COMMAND代表进程执行的时候，是什么命令。</p> 
<hr id="FIbqO"> 
<p id="ue9b29f9e">那么这个PID有什么命令呢？</p> 
<p id="uf4590476"></p> 
<p id="ud19543a9">现在我写了一个死循环</p> 
<p id="u37f0a4d0"></p> 
<p id="uf9a33594"></p> 
<p class="img-center"><img alt="" height="529" id="uc57408c8" src="https://images2.imgbox.com/87/a3/yGY4burl_o.png" width="716"></p> 
<p id="u783a0601"></p> 
<p id="u19b541df">代码再不停的打印Hello World，我通过命令查看这个进程的PID</p> 
<p id="u4d1d1dfe"></p> 
<p id="u4c9c321e"></p> 
<p class="img-center"><img alt="" height="85" id="uc2e39306" src="https://images2.imgbox.com/0e/09/uG3dYDzU_o.png" width="844"></p> 
<p id="uf1fb433f"></p> 
<p id="ua61481d6">然后现在我要杀死这个进程</p> 
<p id="u2cebd963"></p> 
<p id="u5057856a"><code>kill -9 PID</code></p> 
<p id="uc2acf866"></p> 
<p id="u6189d231"></p> 
<p class="img-center"><img alt="" height="140" id="u300fdea1" src="https://images2.imgbox.com/cb/d8/9ZP2wtAf_o.png" width="845"></p> 
<p id="ue84bcad7"></p> 
<p id="u726729ed">查到某个进程的PID，然后kill可以直接干掉。</p> 
<hr id="JJK5j"> 
<p id="u12a3e0e1">如何查询自己的PID呢？</p> 
<p id="uf21c9eca"></p> 
<p class="img-center"><img alt="" height="221" id="u570aae74" src="https://images2.imgbox.com/20/05/68hQrglH_o.png" width="856"></p> 
<p id="ub4fede30"></p> 
<p id="ubc420bf6"></p> 
<p id="u2cb85f45">通过getpid函数可以.</p> 
<p id="u125e7653"></p> 
<pre id="68cc893a"><code>#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

int main()
{
    while (true)
        {
            std::cout &lt;&lt; "I am " &lt;&lt; getpid() &lt;&lt; std::endl;
            std::cout &lt;&lt; "Parent am " &lt;&lt; getppid() &lt;&lt; std::endl;
        }
    return 0;
}</code></pre> 
<p id="u9e279e55"></p> 
<p id="ufe7bd9af"></p> 
<p class="img-center"><img alt="" height="156" id="ud25aa432" src="https://images2.imgbox.com/f0/4d/CwcFh9MY_o.png" width="762"></p> 
<p id="u70e011c8"></p> 
<p id="u343d38a2">PID是自己本身的，PPID是父进程的PID。</p> 
<p id="u3d7540f4"></p> 
<p class="img-center"><img alt="" height="322" id="ufe86c1fd" src="https://images2.imgbox.com/0a/7c/ANuvfw0Q_o.png" width="761"></p> 
<p id="ub8bd82b7"></p> 
<p id="u36f7d7b6"></p> 
<p id="u1bb50588">这个程序我执行了两次，PID一直在变，PPID却没有变化，这个PPID是什么呢？</p> 
<p id="u1b5d9657"></p> 
<p id="uc605e708"></p> 
<p class="img-center"><img alt="" height="84" id="uf99ec88a" src="https://images2.imgbox.com/15/d4/X0EVAlg0_o.png" width="844"></p> 
<p id="ub1bc8a3f"></p> 
<p id="ue635c33e">当我们执行程序的时候，bash会给我们创建进程。我们再命令行中输入的所有指令，都是bash进程的子进程。</p> 
<p id="ufd60175b"></p> 
<h3 id="dae70e64">通过系统调用创建进程-fork</h3> 
<p id="ua2bf5e9b"></p> 
<p id="ue35043b0">如果我们自己想创建进程，fork可以完成</p> 
<p id="ue0105dfd"></p> 
<p id="u81dea883"></p> 
<p class="img-center"><img alt="" height="326" id="u15cc905d" src="https://images2.imgbox.com/ee/9c/loOBNdFs_o.png" width="855"></p> 
<p id="ua496ce33"></p> 
<p id="u98fbba4a"></p> 
<p id="u3bcec385"></p> 
<p id="u1a3ff84b">根据这个返回值来看，这个函数有两个返回值？？</p> 
<p id="u4c8c990d"></p> 
<pre id="a9b2cfa1"><code>#include &lt;unistd.h&gt; 
#include &lt;stdio.h&gt; 

int main()
{
    printf("begin:This is a process. pid:%d,ppid:%d",getpid(),getppid());
    pid_t id = fork();
    if (id == 0)
    {
        while (true)
        {
            printf("This is a child process. pid:%d,ppid:%d",getpid(),getppid());        
            sleep(1);    
        }    
    }    
    else if (id &gt; 0)                                                    
    {    
        while (true)    
        {    
            printf("This is a person process. pid:%d,ppid:%d",getpid(),getppid());        
            sleep(1);    
        }    
    }    
    else    
    {    
        printf("error");
    }

     else 
     {
         std::cout &lt;&lt; "error" &lt;&lt; std::endl;
     }
     return 0;
}</code></pre> 
<p id="uc8ed9915"></p> 
<p id="ub14ab4bd">按照我们以前写的程序，只要第一个if条件满足，就不会再执行其他的分支语句了。</p> 
<p id="ud648f827"></p> 
<p class="img-center"><img alt="" height="477" id="yDXkD" src="https://images2.imgbox.com/11/c0/2SsKrbY5_o.png" width="842"></p> 
<p id="uf6547bae">这个代码再循环打印子进程和父进程中的内容，一份代码中跑了两个死循环，再之前是不可能实现的，但是有了fork就可以了，因为变成了两个进程--父进程和子进程。</p> 
<p id="ub4dd5993"></p> 
<p id="u745e63b2">父进程的pid是3870，子进程的ppid也是3870，说明这两个进程之间的关系是父子。</p> 
<p id="uad71cbfd"></p> 
<p id="u2969bc23">这个2592就是bash</p> 
<p id="uf1a34ee6"></p> 
<p class="img-center"><img alt="" height="85" id="uf598f946" src="https://images2.imgbox.com/5e/d5/tBgSMblg_o.png" width="845"></p> 
<p id="ua77f405c"></p> 
<p id="u091ff431">说明父进程是通过bash来创建的。</p> 
<p id="u7214461a"></p> 
<p id="u04846f56"><strong>上面的代码执行到fork的时候，创建出了子进程。</strong></p> 
<hr id="wiAKs"> 
<p id="u2c924dc7">代码是从上往下执行的，执行到fork函数的时候，整个代码就会变成两个执行流，一个进入到fork大于0的代码中，一个进入到fork==0的代码中。这是能跑两个代码的原因。</p> 
<hr id="xXDVP"> 
<p id="ue6476cda">为什么fork要给子进程返回0，给父进程返回子进程pid？</p> 
<p id="u4590e8eb"></p> 
<p id="u59281f63">一般而言，fork之后的代码父子共享。返回不同的返回值，是为了区分，让不同的执行流，执行不同的代码块。</p> 
<hr id="Nuuz3"> 
<p id="u20ef5cb6">一个函数是如何做到返回两次的？</p> 
<p id="u410d69ca"></p> 
<p id="uce6870ce">fork是一个函数，函数有自己的实现方法，它本身是在操作系统中，有自己的实现。</p> 
<p id="u5ad858be"></p> 
<p id="u2e300606"></p> 
<p class="img-center"><img alt="" height="808" id="u7d972cd9" src="https://images2.imgbox.com/e5/3f/XH8V3LkF_o.png" width="855"></p> 
<p id="ue09bef8c"></p> 
<p id="u7bff7484">return也是代码，父进程执行到return的时候会返回一次，子进程执行到return的时候也会返回一次，所以就返回了两次。</p> 
<hr id="zrJQO"> 
<p id="u5a7b9ea1">fork有两个返回值，那么一个id变量怎么会有两个值呢？</p> 
<p id="ubd041b86"></p> 
<p id="u6bda25dd">父进程在执行的时候，会有自己的代码和数据，这个代码是和子进程共享的，数据呢？父进程有自己的数据的，子进程也应该有自己的数据。进程之间是有独立性的，一个进程崩了，不会影响另一个进程。所以子进程要想办法把父进程的数据拷贝一份，拷贝一份各有各的数据，但是子进程也有可能不会对一些数据进行访问，没用的数据也进行拷贝，会造成浪费。子进程要访问父进程中的数据，可以对要修改的数据，进行拷贝，改多少申请多少空间，这种技术是数据层面的写时拷贝。如果没有更改，父子进程的代码和数据共享。</p> 
<hr id="Wmiqw"> 
<p id="uad509836">上面说过，进程=PCB+代码和数据。创建子进程就是系统中多了一个进程。父进程中的PCB存在指针指向代码和数据，而子进程中也会存在指针，指向代码和数据，父子进程中的代码是共享的。<strong>fork之后，父子进程代码共享，但是可以做不同的事情。</strong></p> 
<hr id="M3Xam"> 
<p id="uae19c6c9">fork之后，父子进程谁先运行呢？</p> 
<p id="ua5ebb01f"></p> 
<p id="ua48f78f4">这个是由<strong>调度器</strong>决定的。</p> 
<hr id="eqIhN"> 
<h4 id="fe290ad3">进程状态</h4> 
<hr id="Gw0fG"> 
<p id="u61858086">CPU只有一个的情况下，存在多个进程，这些进程要竞争CPU的资源，这些资源要合理的分配，所以CPU要维护一个运行队列(struct runqueue)，这些进程要想运行，要先链接到运行队列当中，因为PCB本来就是数据结构对象，运行队列中的头指针指向PCB，尾指针指向最后一个PCB。这个时候CPU要运行进程，直接在运行队列中找到一个进程放到CPU中运行即可。</p> 
<p id="ud0d3b0d5"></p> 
<p id="ue97b1829"><strong>凡是处于运行队列中的进程，都属于运行状态</strong></p> 
<p id="u48fc6d7c"></p> 
<p id="u6fe68301">当一个进程在运行时，则该进程处于运行态</p> 
<p id="u8b93e8bb"></p> 
<p id="ud381968c">这个时候你在创建一个进程，这个进程想要执行，链接在队列中即可。</p> 
<p id="ufae21122"></p> 
<p id="u9f38ffad">那么一个进程只要把自己放到CPU上开始运行了，是不是一直要执行完毕，才把自己放下来？</p> 
<p id="u42e91966"></p> 
<p id="u4b11195c">不是的，比如平常写代码的时候，我们写了一个死循环，但是其他程序还能正常运行。<strong>每一个进程都有一个叫做时间片的概念</strong>，一旦运行时间超过时间片，这个进程就会重新去排队，CPU运行新的进程，所以在一段时间内，所有进程代码都会被执行。也可以称为<strong>并发执行</strong>。</p> 
<p id="u72594f25"></p> 
<p class="img-center"><img alt="" height="400" id="u43abfb8c" src="https://images2.imgbox.com/0e/72/JBFTYyXJ_o.png" width="853"></p> 
<p id="u6f6308d7"></p> 
<hr id="S9weI"> 
<p id="ub9c5eeda">在操作系统中，底层存在各种各样的硬件。操作系统可以管理软硬件资源。这些硬件虽然都不同，但他们都可以用结构体对象来表示。</p> 
<p id="u2cfa4466"></p> 
<pre id="078997af"><code>struct dev
{
	int type;
	int status;
	struct task_struct *head;
	....
}</code></pre> 
<p id="u4a3929cd"></p> 
<p id="u3c4a756d">将这些结构体在链接起来，这样就可用数据结构来管理这些硬件了。</p> 
<p id="u1e91151f"></p> 
<p id="u81826b31">现在我们写了一个带 <code>std::cin</code>的程序，运行以后，设备要从键盘当中读取数据，但是这个时候我们不输入，此时这个进程就要等待从键盘上获取数据，那么这个队列就不能放在运行队列中，会放在等待队列(waitqueue)当中，直到从键盘上获取了数据。获取了数据之后，就会放到运行队列当中。</p> 
<p id="u3c0df071"></p> 
<p id="u52ec1803"><strong>所以这种在等待特定设备的进程，叫做阻塞状态。</strong></p> 
<p id="uc1f6d153"></p> 
<p id="u9a6475c7">一个进程正在等待某一件事发生(例如请求I/O等待I/O完成等)而暂时停止运行</p> 
<hr id="WOr1Y"> 
<p id="u9ab942f0">挂起是一个比较奇怪的概念。</p> 
<p id="u0180ae53"></p> 
<p id="u9569fec2">假如现在有一个设备叫做磁盘，如果今天有多个进程正在等待键盘资源，这时操作系统内部的内存资源严重不足了，操作系统会在保证正常的情况下，省出来内存资源，一些在等待队列当中的资源没有被CPU调用，这些进程处于空闲状态，此时操作系统会将这些进程的PCB保留，代码和数据会放到外设当中，这个过程叫做<strong>换出</strong>，PCB在等待队列中排队，等到这个进程就绪了，在把代码和数据从外设中拿出来，放到运行队列当中，这个过程叫做<strong>换入</strong>。<strong>其中一个进程只有PCB在，代码和数据被换出了，此时这个进程的状态就是挂起状态</strong>，这样就给以给操作系统省出资源。</p> 
<hr id="VqLbL"> 
<p id="u71a18563">Linux中的进程状态</p> 
<p id="u882c6c75"></p> 
<pre id="afaebfd3"><code>/*
* The task state array is a strange "bitmap" of
* reasons to sleep. Thus "running" is zero, and
* you can test for combinations of others with
* simple bit tests.
*/
static const char * const task_state_array[] = {
"R (running)", /* 0 */
"S (sleeping)", /* 1 */
"D (disk sleep)", /* 2 */
"T (stopped)", /* 4 */
"t (tracing stop)", /* 8 */
"X (dead)", /* 16 */
"Z (zombie)", /* 32 */
};</code></pre> 
<p id="ue5ec2e3f"></p> 
<ul><li id="u95e7faec">R运行状态（running） : 并不意味着进程一定在运行中，它表明进程要么是在运行中要么在运行队列里。</li></ul> 
<ul><li id="u338c4985">S睡眠状态（sleeping): 意味着进程在等待事件完成（这里的睡眠有时候也叫做可中断睡眠（interruptible sleep））。</li></ul> 
<ul><li id="u5ad27972">D磁盘休眠状态（Disk sleep）有时候也叫不可中断睡眠状态（uninterruptible sleep），在这个状态的进程通常会等待IO的结束。</li></ul> 
<ul><li id="u49735210">T停止状态（stopped）： 可以通过发送 SIGSTOP 信号给进程来停止（T）进程。这个被暂停的进程可以通过发送 SIGCONT 信号让进程继续运行。</li></ul> 
<ul><li id="u1c48b9c8">X死亡状态（dead）：这个状态只是一个返回状态，你不会在任务列表里看到这个状态</li></ul> 
<ul><li id="u204f4438">僵死状态（Zombies）是一个比较特殊的状态。当进程退出并且父进程没有读取到子进程退出的返回代码时就会产生僵尸进程。僵死进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码。所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程进入Z状态</li></ul> 
<hr id="LzgcG"> 
<p id="u7f92d444">下面我们创建一个名为myproc.cpp的文件。</p> 
<p id="u5725f88a"></p> 
<pre id="975441b5"><code>#include &lt;iostream&gt;    
#include &lt;unistd.h&gt;    
    
int main()    
{    
    while (true)    
    {    
        std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;    
        sleep(1);    
    }    
    
    return 0;                                                           
}</code></pre> 
<p id="u8af8ee2e"></p> 
<p id="u5fc0c3a9"></p> 
<p class="img-center"><img alt="" height="331" id="u0181885b" src="https://images2.imgbox.com/16/df/P43cJO9J_o.png" width="838"></p> 
<p id="ud04e3b2f"></p> 
<p id="u517c24be">运行这个进程之后在查看进程。</p> 
<p id="uef59f161"></p> 
<p class="img-center"><img alt="" height="82" id="u67ccf287" src="https://images2.imgbox.com/fa/20/z9feFflq_o.png" width="838"></p> 
<p id="uee4c900e"></p> 
<p id="u9e825ee4"></p> 
<p id="ud3ce1374">发现，这个进程是S状态，myproc不是在运行吗？为什么会是S状态。</p> 
<p id="u02167e9f"></p> 
<p id="u8ddcda54">现在把代码中的输出和sleep给去了。</p> 
<p id="ue6da3ceb"></p> 
<p id="uba424084"></p> 
<p class="img-center"><img alt="" height="55" id="udd0b7764" src="https://images2.imgbox.com/fd/df/ec5a58ip_o.png" width="847"></p> 
<p id="u88acd0d5"></p> 
<p id="u86d81c62">此时就变成了R状态。</p> 
<p id="ud7206922"></p> 
<p id="ued2315b6">第一次的代码带有 <code>std::cout</code> 看似代码一直在打印，其实是阻塞状态，当我把输出给去了，就变成了运行态(R)。</p> 
<p id="u0275d09c"></p> 
<p id="u00116213">R+的意思是前台运行，在运行的时候给 <code>./myproc</code>后面加上&amp; =&gt; <code>./myproc &amp;</code>就变成后台运行。</p> 
<hr id="Q3tnx"> 
<pre id="bfdbaf21"><code>#include &lt;iostream&gt;    
#include &lt;unistd.h&gt;    
    
int main()    
{    
    std::cout &lt;&lt; "cin&gt;&gt;:";                                                                                                                          
    int a = 0;    
    std::cin &gt;&gt; a;    
    std::cout &lt;&lt; "echo:" &lt;&lt; a &lt;&lt; std::endl;                         
    return 0;            
}</code></pre> 
<p id="u61b46d5e"></p> 
<p id="ue6a7c83e">在运行这个程序的时候，如果没有输入，界面就会一直卡在这里，等待着输入。</p> 
<p id="ud9b2d329"></p> 
<p id="u75326448"></p> 
<p class="img-center"><img alt="" height="158" id="u26294401" src="https://images2.imgbox.com/8b/16/npGmovHf_o.png" width="799"></p> 
<p id="u7774711b"></p> 
<p id="u20886d98">查看进程</p> 
<p id="u1360f33d"></p> 
<p id="uda06770e"></p> 
<p class="img-center"><img alt="" height="85" id="ucc5fd6ac" src="https://images2.imgbox.com/27/04/PpAGpZ20_o.png" width="853"></p> 
<p id="u250e3b21"></p> 
<p id="u784257c3">我并没有输入，所以这个进程一直在等待，直到获取到相应的资源后，才可以运行，这就是S状态。所谓的阻塞，就是在等待资源。</p> 
<p id="u911a25f7"></p> 
<p id="uc88e34c2"></p> 
<p class="img-center"><img alt="" height="240" id="u0830bcfc" src="https://images2.imgbox.com/65/25/AfRVsVEg_o.png" width="828"></p> 
<p id="u5ce36daa"></p> 
<p class="img-center"><img alt="" height="64" id="uc48004cc" src="https://images2.imgbox.com/e3/e9/WI8aXLcs_o.png" width="853"></p> 
<p id="u76eae3c4"></p> 
<p id="ubea36e4f"></p> 
<p id="u630133a1">当获取了资源后，就是R状态了。</p> 
<hr id="L4LwI"> 
<p id="ue5cc9cde">如果一个进程处于D状态，在Linux中也是阻塞状态，也是深度睡眠。</p> 
<p id="u107a3ba0"></p> 
<p id="ud5c1eef8">现在有一个进程，这个进程在向磁盘写入1G的数据，磁盘把数据接收后，存在某一区域，这个过程是要花时间的，在这期间，进程就要进行等待。完成这个操作后，磁盘向进程发起反馈，不管成功与否。那么在磁盘写入的时候，这个进程被操作系统强制干了，但是磁盘要向进程进行反馈的时候，却找不到进程了。这个数据若不重要，丢掉也无所谓；如果数据非常重要呢？丢失了就会造成大问题。所以让进程在等待磁盘写入完毕期间，这个进程不能被任何人干掉，不就行了。<strong>进程在等待磁盘写入期间，就是D状态---disk sleep</strong></p> 
<hr id="H4vAH"> 
<p id="u5f7e58e9">t状态被称为暂停状态。</p> 
<p id="uf27bbce4"></p> 
<pre id="5a20a2c7"><code>#include &lt;iostream&gt;    
#include &lt;unistd.h&gt;    
    
int main()    
{
    while (true)                                                        
    {                  
        std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;          
        sleep(1);        
    }                          
                                            
    return 0;                                               }</code></pre> 
<p id="u9db9cba9"></p> 
<p id="u227bb974">运行之后，进程处于S状态</p> 
<p id="uc0f4dc1d"></p> 
<p id="udd350ae7"></p> 
<p class="img-center"><img alt="" height="59" id="u03e18f7c" src="https://images2.imgbox.com/8f/99/VjC2ctJJ_o.png" width="850"></p> 
<p id="ud40eb807"></p> 
<p id="udd1e2fdc">通过kill -l可以查看更多的信号，之前用过kill -9 PID的命令用来杀死进程。</p> 
<p id="u0313677c"></p> 
<p id="u8a5918f4"></p> 
<p class="img-center"><img alt="" height="310" id="u6b810dc6" src="https://images2.imgbox.com/39/73/RtJkWXNR_o.png" width="844"></p> 
<p id="u9cc02af8"></p> 
<p id="udcbc25fb">18和19信号分别是继续和暂停信号。</p> 
<p id="u9cb8520f"></p> 
<p id="u75fad3c6"><code>kill -19 PID</code></p> 
<p id="uf8098ea1"></p> 
<p id="u27c96410"></p> 
<p class="img-center"><img alt="" height="300" id="u9854e843" src="https://images2.imgbox.com/8f/09/CeZXfh7B_o.png" width="846"></p> 
<p id="u8056c866"></p> 
<p id="u66a3bb13"></p> 
<p id="ub25b82cb"></p> 
<p id="u93f96762">在输入 <code>kill -18 PID</code></p> 
<p id="udbb0b2cf"></p> 
<p id="u881df7a7"></p> 
<p class="img-center"><img alt="" height="250" id="u2e81c49d" src="https://images2.imgbox.com/07/9a/GTxk4Gij_o.png" width="835"></p> 
<p id="ua6a6a1c9"></p> 
<p class="img-center"><img alt="" height="100" id="u420cbaa4" src="https://images2.imgbox.com/d5/95/avqoU55l_o.png" width="849"></p> 
<p id="u4c1d3d53"></p> 
<hr id="bDemN"> 
<p id="u30775e62">X是死亡状态。</p> 
<p id="u543b7c25"></p> 
<p id="u8e9a7f51">进程终止了，就要把资源进行回收，这只是一个返回状态，不会再任务列表里看到这个状态。</p> 
<hr id="XebFv"> 
<p id="u3a4dc8cd">Z状态也是僵尸状态。</p> 
<p id="u4c314bdc"></p> 
<p id="uc2edb836">一个进程死掉了，并不会直接进行回收，而是先将进程的退出信息维持一段时间，让关心这个进程的人知道结果和原因。维护信息的这个状态，是Z状态。</p> 
<p id="ucf1753b2"></p> 
<p id="u28fafb98">一个进程中，父进程最关心儿子进程的信息。如果父进程没有关心儿子进程，操作系统就会一直维持着儿子进程的信息。</p> 
<p id="ufc5652fe"></p> 
<pre id="6af0c0c4"><code>#include &lt;iostream&gt;    
#include &lt;unistd.h&gt;    
#include &lt;cstdlib&gt;

int main()    
{
   pid_t id = fork();

   if (id == 0)
   {
       int cnt = 5;
       while (cnt)
       {
        std::cout &lt;&lt; "我是子进程,pid " &lt;&lt; getpid() &lt;&lt; "ppid" &lt;&lt; getppid() &lt;&lt; std::endl;
        cnt--;
        sleep(1);
    
       }
       exit(0);
   }
   else 
   {
       while (true)
       {
           std::cout &lt;&lt; "我是父进程,pid" &lt;&lt; getpid() &lt;&lt; "ppid" &lt;&lt; getppid() &lt;&lt; std::endl;
           sleep(1);
       }
   }
    return 0;                                                           
}</code></pre> 
<p id="u6d47ed9a"></p> 
<p id="u7dc2f727">这个代码中，父进程并没有对子进程干任何事情，子进程结束之后，父进程就看着，啥也不干。</p> 
<p id="u208fc935"></p> 
<p id="u29afa8f0"></p> 
<p class="img-center"><img alt="" height="231" id="u270badad" src="https://images2.imgbox.com/06/93/nvviA9OZ_o.png" width="847"></p> 
<p id="u989d6a55"></p> 
<p id="uaae52616">当运行这个程序的时候，cnt为0前，一直是都是S状态，cnt为0后，父进程是S状态，子进程变成了Z状态，既僵尸状态。</p> 
<p id="udc8bee4c"></p> 
<p id="u2a997997">进程一般退出的时候，如果父进程没有主动回收子进程信息，子进程会一直让自己处于Z状态。进程的相关资源尤其是task_struct 结构体不能被释放。僵尸进程会一直占用自身资源。僵尸进程不予回收就会造成内存泄漏问题。</p> 
<p id="uf9896cda"></p> 
<p id="u2cdcefb6">那么我们把myproc给结束之后，为什么不会变成僵尸进程？因为bash会对myproc负责。爹只对儿子负责。</p> 
<p id="ue050cfd7"></p> 
<p id="u28621ae8"></p> 
<p class="img-center"><img alt="" height="89" id="u1b89dc71" src="https://images2.imgbox.com/e7/ae/uRhlaAp9_o.png" width="845"></p> 
<p id="u255c0251"></p> 
<p id="u988eb2fa">myproc结束，没有变成僵尸进程是因为bash会负责，那子进程为什么会没了？bash可不会对孙子负责。</p> 
<p id="ucc879483"></p> 
<p id="uabe58831">现在不让子进程退出，让父进程退出。</p> 
<p id="uf9917eb2"></p> 
<pre id="b6ab56cc"><code>#include &lt;iostream&gt;    
#include &lt;unistd.h&gt;    
#include &lt;cstdlib&gt;

int main()    
{
   pid_t id = fork();

   if (id == 0)
   {
       int cnt = 500;
       while (cnt)
       {
        std::cout &lt;&lt; "我是子进程,pid " &lt;&lt; getpid() &lt;&lt; "ppid" &lt;&lt; getppid() &lt;&lt; std::endl;
        cnt--;
        sleep(1);
    
       }
       exit(0);
   }
   else 
   {
       int cnt = 5;
       while (cnt)
       {
           std::cout &lt;&lt; "我是父进程,pid" &lt;&lt; getpid() &lt;&lt; "ppid" &lt;&lt; getppid() &lt;&lt; std::endl;
            cnt--;
           sleep(1);
       }
   }
    return 0;                                                           
}</code></pre> 
<p id="u1e8ba725"></p> 
<p id="u13e908e9"></p> 
<p class="img-center"><img alt="" height="196" id="u3c1c8a04" src="https://images2.imgbox.com/61/f6/iDZmtzfX_o.png" width="842"></p> 
<p id="u9d06f2df"></p> 
<p id="u1951df04">原来子进程的父进程的PID是15604，父进程退出之后，变成了1。</p> 
<p id="ue856a779"></p> 
<p class="img-center"><img alt="" height="118" id="u9ac3d1a4" src="https://images2.imgbox.com/bd/d8/4ADSUTwo_o.png" width="852"></p> 
<p id="u3f1f8eae"></p> 
<p id="ue74b0e7d"></p> 
<p id="u43a4b1f8">如果父进程先退出，子进程的父进程会被改变成1号进程(操作系统)</p> 
<p id="u51405d11"></p> 
<p id="u5bbde7ca"><strong>父进程是1号进程---孤儿进程</strong>，该进程被系统领养。</p> 
<p id="u1b2a8877"></p> 
<p id="udeba93cc">父进程结束了，孤儿进程退出后，它的信息就没有人关心了。只能有操作系统来领养。</p> 
<p id="u8c3e68be"></p> 
<p id="u3a019b16">所以上面子进程是僵尸进程，将父进程结束后，子进程由操作系统领养，所以子进程也会结束。</p> 
<hr id="NCgsP"> 
<p id="u41999e3f">僵尸进程的危害</p> 
<p id="u1058ae2e"></p> 
<p id="ubfd489bb">进程的退出状态必须被维持下去，因为他要告诉关心它的进程（父进程），你交给我的任务，我办的怎么样了。可父进程如果一直不读取，那子进程就一直处于Z状态。维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话说， Z状态一直不退出， PCB一直都要维护那一个父进程创建了很多子进程，就是不回收，就会造成内存资源的浪费。因为数据结构对象本身就要占用内存，想想C中定义一个结构体变量（对象），是要在内存的某个位置进行开辟空间。<strong>内存泄漏</strong></p> 
<p id="u9c18e40e"></p> 
<h3 id="59e9f4a7">进程优先级</h3> 
<p id="u83770adf"></p> 
<p id="ua6982ce3">cpu资源分配的先后顺序，就是指进程的优先权（priority）。优先权高的进程有优先执行权利。配置进程优先权对多任务环境的linux很有用，可能改善系统性能。还可以把进程运行到指定的CPU上，这样一来，把不重要的进程安排到某个CPU，可以大大改善系统整体性能</p> 
<hr id="XrMA9"> 
<p id="u6f515c27">优先级是对于资源的访问，谁先访问，谁后访问。就好比买饭的时候要排队，我们已经进入了餐厅，有吃饭的权限，排队就是决定谁先吃，谁后吃的问题。</p> 
<p id="ube2468ec"></p> 
<p id="u4eb2e0f4">为什么会有优先级呢？</p> 
<p id="u07137123"></p> 
<p id="ud5cede7d">学生在学校要吃饭，如果给每个学生配一个厨师，那就不需要在餐厅排队吃饭了。但学生这么多，不可能实现每个学生配一个厨师。一个系统中有好多进程，这些进程不可能都配一个CPU，且资源是有限的，所以这些进程就需要对CPU进行竞争。操作系统必须保证大家良性竞争，就要确认优先级。<strong>如果不保证良性竞争，那结果就是谁nb谁资源多，这样会造成一些进程长时间得不到CPU资源，该进程的代码长时间无法得到推进---该进程的饥饿问题</strong>。</p> 
<p id="u307ab10d"></p> 
<p id="u2208072a"><strong>当然不要去修改优先级，调度器会自己解决优先级的问题。</strong></p> 
<hr id="CqMSm"> 
<pre id="a886cd99"><code>#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

int main()
{
    while (true)
    {
        std::cout &lt;&lt; "This is a process." &lt;&lt; std::endl;
        sleep(1);
    }

    return 0;
}</code></pre> 
<p id="ua4376450"></p> 
<p id="u388cd916">运行之后查看进程 <code>ps -al</code></p> 
<p id="u678e10b6"></p> 
<p id="u9d845685"></p> 
<p class="img-center"><img alt="" height="88" id="ue3ba8005" src="https://images2.imgbox.com/36/5d/DyajUuwy_o.png" width="853"></p> 
<p id="u9ed26b8e"></p> 
<p id="u337e17b9">PRI就是优先级(priority)<br> NI就是nice值：进程优先级的修正数据。</p> 
<p id="u519e1cae"></p> 
<ul><li id="ua373c665">PRI也还是比较好理解的，即进程的优先级，或者通俗点说就是程序被CPU执行的先后顺序，此值越小进程的优先级别越高</li></ul> 
<ul><li id="u14c3ca7c">那NI呢?就是我们所要说的nice值了，其表示进程可被执行的优先级的修正数值</li></ul> 
<ul><li id="u735e5a19">PRI值越小越快被执行，那么加入nice值后，将会使得PRI变为： PRI(new)=PRI(old)+nice</li></ul> 
<ul><li id="u55236fa5">这样，当nice值为负值的时候，那么该程序将会优先级值将变小，即其优先级会变高，则其越快被执行所以，调整进程优先级，在Linux下，就是调整进程nice值</li></ul> 
<ul><li id="u3147d7f8">nice其取值范围是-20至19，一共40个级别</li></ul> 
<p id="ud9cdf9eb"></p> 
<p id="u6454a40e">Linux不会让你随便的调整优先级，所以nice值给出的有限制。</p> 
<p id="u5b85b21e"></p> 
<p id="u42719287"><strong>需要强调一点的是，进程的nice值不是进程的优先级，他们不是一个概念，但是进程nice值会影响到进程的优先级变化。可以理解nice值是进程优先级的修正修正数据</strong></p> 
<hr id="Ug1y3"> 
<p id="uf8d9937f">如何更改优先级呢？</p> 
<p id="u4ab3ab5b"></p> 
<p id="u8187a74a">top命令。</p> 
<p id="u9ab139d9"></p> 
<p id="u4f0c93b1">然后输入r</p> 
<p id="u5b9ca651"></p> 
<p id="ud9a17e82"></p> 
<p class="img-center"><img alt="" height="547" id="ue94e767e" src="https://images2.imgbox.com/cc/62/OEnhwtwG_o.png" width="831"></p> 
<p id="u00bccf9a"></p> 
<p id="u308d7216">在输入PID，</p> 
<p id="u62a76fa8"></p> 
<p id="u043915b1"></p> 
<p class="img-center"><img alt="" height="97" id="uf69df80c" src="https://images2.imgbox.com/55/18/H2K2vqi5_o.png" width="713"></p> 
<p id="u6e024366"></p> 
<p id="u8725b0ff">在输入新的nice值</p> 
<p id="u5eb6b170"></p> 
<p class="img-center"><img alt="" height="70" id="u3c14c0cb" src="https://images2.imgbox.com/bf/19/wt6U0xrX_o.png" width="865"></p> 
<p id="u09f4aedf"></p> 
<p id="ue139f036"></p> 
<p id="u782d6a5b">就可以完成修改了。</p> 
<p id="u7caa5502"></p> 
<p id="u388ff5d6">如果新的nice值不在ni的区间，系统会自动的找在区间内的最大值。</p> 
<hr id="euPWp"> 
<p id="uf0471ac7">那么操作系统是如何根据优先级开展的调度呢？</p> 
<p id="u083077d7"></p> 
<p id="ud7b6390f">通过<strong>位图。</strong>可以近乎O(1)的时间复杂度来调度。</p> 
<hr id="wiJty"> 
<h4 id="fd54e367">其他概念</h4> 
<p id="uec4e9a21"></p> 
<ul><li id="u339046bd">竞争性: 系统进程数目众多，而CPU资源只有少量，甚至1个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级</li></ul> 
<ul><li id="u08b21bc1">独立性: 多进程运行，需要独享各种资源，多进程运行期间互不干扰</li></ul> 
<ul><li id="u8c97c712">并行: 多个进程在多个CPU下分别，同时进行运行，这称之为并行</li></ul> 
<ul><li id="u40eb71b7">并发: 多个进程在一个CPU下采用进程切换的方式，在一段时间之内，让多个进程都得以推进，称之为并发</li></ul> 
<p id="ud9bff735"></p> 
<h3 id="3867e350">环境变量</h3> 
<p id="ue0cb8b0b"></p> 
<p id="u2b66c53b">环境变量(environment variables)一般是指在操作系统中用来指定操作系统运行环境的一些参数如：我们在编写C/C++代码的时候，在链接的时候，从来不知道我们的所链接的动态静态库在哪里，但是照样可以链接成功，生成可执行程序，原因就是有相关环境变量帮助编译器进行查找。环境变量通常具有某些特殊用途，还有在系统当中通常具有全局特性 。</p> 
<hr id="YK4Rj"> 
<p id="uece99299">我们写的代码，在编译后要运行的时候，需要带 <code>./</code>才能运行。而指令，则不需要带 <code>./</code>就可以运行？指令和我们写的代码，都在目录中，这些目录还有什么区别吗？</p> 
<p id="u6b6ed959"></p> 
<p id="u7ffc8cef"><strong>系统当中，针对于指令的搜索，Linux会提供一个环境变量PATH</strong>。</p> 
<p id="u2b607281"></p> 
<p id="u94aeafff">通过 <code>echo $PATH</code>可以打印环境变量</p> 
<p id="u5ab42492"></p> 
<p id="u95c542f6"></p> 
<p class="img-center"><img alt="" height="133" id="u0c7342fb" src="https://images2.imgbox.com/2c/9f/x5XqH7Bn_o.png" width="858"></p> 
<p id="u5138a280"></p> 
<p id="ud877a286">这些路径以冒号为分隔符，在执行指令的时候，系统会在上面的路径中，寻找指令。所以我们自己写的代码，只写文件名，系统在路径中搜索不到，也就无法运行了。</p> 
<p id="u85bfbd66"></p> 
<p id="u7a5d32df"></p> 
<p class="img-center"><img alt="" height="144" id="ue7e6f8e5" src="https://images2.imgbox.com/10/93/Aia8FQeR_o.png" width="835"></p> 
<p id="u70d0e7de"></p> 
<p id="ufb7326ba">那么，将这个proc的路径，添加到PATH中，是不是就可以输入名字运行代码了呢？</p> 
<p id="u1e71c083"></p> 
<p id="u7bbf0d39"></p> 
<p class="img-center"><img alt="" height="110" id="u7e1ca531" src="https://images2.imgbox.com/3d/d1/9CchL2wp_o.png" width="848"></p> 
<p id="u23a8324e"></p> 
<p id="ue8a4ef35">这样的写法是覆盖PATH，会将之前的路径都覆盖。在使用了之后绝大部分指令就不能运行了。因为系统找不到对应的路径。就算覆盖了，不用担心，PAHT会在启动的时候加载到内存，重启一下，就会恢复。</p> 
<p id="u5b4efee6"></p> 
<p id="u7c554dcb"></p> 
<p class="img-center"><img alt="" height="130" id="u98199221" src="https://images2.imgbox.com/41/0b/uF5yT4LL_o.png" width="853"></p> 
<p id="u549ba482"></p> 
<p id="ud94a818b">将路径添加到PATH后，就可以输名字，运行代码了。</p> 
<p id="u18770308"></p> 
<p id="ucea3d02a"></p> 
<p class="img-center"><img alt="" height="327" id="ude8835f5" src="https://images2.imgbox.com/ca/04/5E1RPAc3_o.png" width="847"></p> 
<hr id="zCT4c"> 
<p id="u32a7605f">输入 env可以查看环境变量。</p> 
<p id="u8c71806c"></p> 
<p id="ue4b0d0f7"></p> 
<p class="img-center"><img alt="" height="477" id="ue25a9891" src="https://images2.imgbox.com/f8/92/3aCCEUNR_o.png" width="849"></p> 
<p id="ub25f1362"></p> 
<p id="ue26364e0">我们在终端输入指令的时候，会自动的记录上一条输入的指令，这个记录的指令是有限制的，HISTSIZE就是能够记录的条数</p> 
<p id="u0e76d680"></p> 
<p id="u68b4e23f">USER代表的用户。</p> 
<p id="u24c7a382"></p> 
<p id="ue5a91fd5">PWD代表当前路径</p> 
<hr id="eVbnA"> 
<p id="u526515f9"></p> 
<p class="img-center"><img alt="" height="508" id="u0ad05712" src="https://images2.imgbox.com/a7/63/Cuhv3peS_o.png" width="838"></p> 
<p id="u4aeec643"></p> 
<p id="ua1e937d5"></p> 
<p id="ueecf28fb"></p> 
<p id="ufa5d8c8e">通过getenv函数可以获取环境变量。</p> 
<p id="u22cf3e64"></p> 
<pre id="e65586ce"><code>  #include &lt;iostream&gt;    
  #include &lt;string&gt;    
  #include &lt;stdlib.h&gt;    
      
  int main()    
  {    
      std::string who = getenv("USER");                                      
      
      if (who == "root")    
      {    
          std::cout &lt;&lt; "允许做任何事情" &lt;&lt; std::endl;    
      }    
      else    
      {    
          std::cout &lt;&lt; "你就一个普通用户，没有足够权限" &lt;&lt; std::endl;      }  
           
      return 0;  
  }</code></pre> 
<p id="u7b279947"></p> 
<p id="u02156405"></p> 
<p class="img-center"><img alt="" height="201" id="u494bb562" src="https://images2.imgbox.com/f9/c0/ThczHDaA_o.png" width="855"></p> 
<p id="ub8aa955a"></p> 
<p id="ud99489c3">环境变量是系统提供的一组name=value形式的变量，不同的环境变量有不同的用户，通常具有全局属性。</p> 
<p id="uf17932e8"></p> 
<h4 id="b787645d">命令行参数</h4> 
<p id="u46a9f294"></p> 
<p id="u065a55cd">在学C语言的时候，一些教材上main函数是带参数的。</p> 
<p id="uff16dfbf"></p> 
<pre id="fd2540bd"><code>int main(int argc, char *argv[])
{
	
}</code></pre> 
<p id="ubf2ec46b"></p> 
<p id="u4e182ff2">C/C++的main函数，是可以传参的，上面两个，就是参数。</p> 
<p id="u18b5c6d9"></p> 
<pre id="4f0f74ad"><code>#include &lt;stdlib.h&gt;      
#include &lt;stdio.h&gt;      
      
int main(int argc,char *argv[])      
{      
    for (int i = 0; i &lt; argc; i++)      
    {      
        printf("argv[%d]-&gt;%s",i,argv[i]);      
    }                                                                          
    return 0;                        
}</code></pre> 
<p id="uaaea271e"></p> 
<p id="u2c46e396"></p> 
<p class="img-center"><img alt="" height="1047" id="ub2a4a824" src="https://images2.imgbox.com/77/06/0zQsQFeF_o.png" width="838"></p> 
<p id="u112b4356"></p> 
<p id="ud9a23b34"></p> 
<p id="ub2e8a5c3"></p> 
<p id="u55c87cd3">当我们运行代码的时候， 你以为你输入的是 <code>./proc -a -b -c</code>，开始做命令行解释的时候，会把这个字符串打散成四个字符串，再将每个字符串的起始地址，保存在argv中，然后传递给main函数，argc中存数量，argv中存的字符串。</p> 
<p id="u55bd3744"></p> 
<p id="ufccd69e3">为什么要这么做呢？</p> 
<p id="u348ad498"></p> 
<pre id="6de6b277"><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        printf("Usage: %s -[a|b|c|d]\n",argv[0]);
    }
    
    if (strcmp(argv[1],"-a") == 0)
    {
        printf("aaa\n");
    }
    else if (strcmp(argv[1],"-b") == 0)
    {
        printf("bbb\n");
    }
    else if (strcmp(argv[1],"-c") == 0)
    {
        printf("ccc\n");
    }
    else if (strcmp(argv[1],"-d") == 0)
    {
        printf("ddd\n");
    }
    else 
    {
        printf("defaul\n");
    }

    return 0;
}</code></pre> 
<p id="u5e2b2051"></p> 
<p id="u63988542"></p> 
<p class="img-center"><img alt="" height="631" id="u66907abb" src="https://images2.imgbox.com/96/62/Bs0LYOPN_o.png" width="834"></p> 
<p id="u510af7f9"></p> 
<p id="uecd710b7">同一个指令，不同的选项，可以得到不同的结果。</p> 
<p id="uc54070da"></p> 
<p id="u3e6e1433">这样可以为指令，工具，软件等提供命令行选项的支持。比如 <code>ls -a,ps ajx</code>等。</p> 
<hr id="ZnmQS"> 
<p id="u1b6ab999">还可以带第三个参数---环境变量列表。</p> 
<p id="u455046c3"></p> 
<pre id="5b905c9e"><code>int main(int argc,char *argv[],char *env[])
{

}</code></pre> 
<p id="u3860e450"></p> 
<p class="img-center"><img alt="" height="791" id="u18f8be69" src="https://images2.imgbox.com/08/2e/I2I8GR4k_o.png" width="856"></p> 
<p id="udf7ecf36"></p> 
<p id="uef01d0d9"></p> 
<p id="ua0a62373"></p> 
<p id="uc83e134a"></p> 
<p id="u7da73b6d">我们所运行的进程，都是子进程，bash本身在启动的时候，会从操作系统的配置文件中读取环境变量信息，子进程会继承父进程交给我的环境变量。</p> 
<p id="u8f5f976b"></p> 
<p id="u29794220">怎么证明这件事？</p> 
<p id="u28179aaf"></p> 
<p id="u7a8d81d0"></p> 
<p class="img-center"><img alt="" height="153" id="u6f1ef4e5" src="https://images2.imgbox.com/78/89/bdDmYmMQ_o.png" width="852"></p> 
<p id="u79e73fcb"></p> 
<p id="u9986be9e">在命令行上这样搞，并不是环境变量，但确实存在。</p> 
<p id="u75758687"></p> 
<p class="img-center"><img alt="" height="160" id="u32850910" src="https://images2.imgbox.com/f2/37/Jjih9OaT_o.png" width="849"></p> 
<p id="u39b19451"></p> 
<p id="u1d586340"></p> 
<p id="u192ebfe6">这是本地变量。</p> 
<p id="ue8cba326"></p> 
<p id="uedd8c3c1">所谓的本地变量就是在命令行中定义变量。本地变量不会被继承<br> a = 1<br> b = 2<br> c = 3</p> 
<p id="u3c689d7a"></p> 
<p id="u8532b185">echo $a可以输出a。但如果敲一个代码看这个变量是无法找到的，echo却可以输出。</p> 
<p id="u56b6c997"></p> 
<p id="u7cc03372">两批命令：<br> 常规命令：通过创建子进程完成的。<br> 内建命令：bash不创建子进程，而是由自己亲自执行，类似于bash调用了自己写的，或者系统提供的函数。</p> 
<p id="u7dde8c3b"></p> 
<p id="ue5bb0946">set命令可以查看系统当中的所有变量。</p> 
<p id="u9e1fccc0"></p> 
<p id="u1f60e408">现在将这个变量定义为环境变量。</p> 
<p id="ua6a462a9"></p> 
<p class="img-center"><img alt="" height="189" id="u13ed55f8" src="https://images2.imgbox.com/01/6e/wSiAC6px_o.png" width="864"></p> 
<p id="u8b1ebd15"></p> 
<p id="u5dd248ec"></p> 
<p id="u5a5ceab7">只需要带个export将它导出即可。</p> 
<p id="u236d3206"></p> 
<p id="u42ff1ff1"></p> 
<p class="img-center"><img alt="" height="400" id="ubaf85ae5" src="https://images2.imgbox.com/35/6d/VJm464QE_o.png" width="844"></p> 
<p id="u147eb2d9"></p> 
<p id="u138d97c1">在运行代码后，发现，会继承。</p> 
<p id="u9653e71e"></p> 
<p id="u7cd64ab0"><code>unsert MY_VALUE</code>会取消环境变量。</p> 
<p id="u984f9c9a"></p> 
<p id="u75435406"></p> 
<p class="img-center"><img alt="" height="158" id="ufbc4f0f0" src="https://images2.imgbox.com/97/da/EjISbmnp_o.png" width="838"></p> 
<hr id="SSuxg"> 
<h2 id="g658Z">进程地址空间</h2> 
<p id="u34455105">在学习C/C++的时候经常提到这些空间，栈区，堆区，静态区等等，下面这张图也没少见到。</p> 
<p id="ue0ccff69"></p> 
<p class="img-center"><img alt="" height="682" id="u29a65f37" src="https://images2.imgbox.com/2f/15/maSoRdu2_o.png" width="766"></p> 
<pre id="Xo9t9"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


int g_val_1;
int g_val_2 = 100;

int main()
{
    printf("code addr: %p\n", main);
    const char* str = "Hello World";
    printf("read only string addr: %p\n", str);
    printf("init global value addr: %p\n", &amp;g_val_2);
    printf("uinit global value addr: %p\n", &amp;g_val_1);
    char *mem = (char*)malloc(100);
    printf("heap addr: %p\n", mem);
    printf("stack addr: %p\n", &amp;str);


    return 0;

}</code></pre> 
<p id="u55251aca">这是在Linux中敲的代码。</p> 
<p id="ua1d109f7"></p> 
<p class="img-center"><img alt="" height="217" id="ub5def928" src="https://images2.imgbox.com/a2/56/n7VG4rOK_o.png" width="622"></p> 
<p id="u1fa3f3ec">这是运行结果，通过结果来看，是符合上面画的图的。不同的数据类型存储在不同的地方。</p> 
<hr id="v2cRo"> 
<p id="u9d18ea63">栈区向下增长，堆区向上增长。</p> 
<p id="u4eb850ba"></p> 
<p class="img-center"><img alt="" height="928" id="u802b56df" src="https://images2.imgbox.com/40/3c/DS6Mp3nE_o.png" width="943"></p> 
<p id="u1463fe14">通过代码来验证上面的话。</p> 
<p id="u3489871b"></p> 
<p class="img-center"><img alt="" height="262" id="ufd500614" src="https://images2.imgbox.com/8a/01/cHbKJxdJ_o.png" width="508"></p> 
<p id="uad725973">看，堆区向上增长，栈区向下增长。</p> 
<hr id="bPhku"> 
<pre id="ZqLEW"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


int g_val = 1;

int main()
{
    pid_t id = fork();
    if (id == 0)
    {
        // 子进程
        while (1)
        {
            printf("i am child, pid: %d, ppid: %d, g_val: %d, &amp;g_val: %d\n", getpid(), getppid(), g_val, &amp;g_val);
            sleep(1);
        }
    }
    else 
    {

        while (1)
        {
            printf("i am parent, pid: %d, ppid: %d, g_val: %d, &amp;g_val: %d\n", getpid(), getppid(), g_val, &amp;g_val);
            sleep(1);
        }
    }

    return 0;

}
</code></pre> 
<p id="u7bbd9d6b"></p> 
<p class="img-center"><img alt="" height="283" id="uacc529d4" src="https://images2.imgbox.com/81/0d/X7hylYGP_o.png" width="1069"></p> 
<p id="u16e65b99">现在对代码进行一个小小的更改。</p> 
<p id="udfd24c6c"></p> 
<pre id="aQ7SM"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


int g_val = 1;

int main()
{
    pid_t id = fork();
    if (id == 0)
    {
        // 子进程
        int cnt = 5;
        while (1)
        {
            printf("i am child, pid: %d, ppid: %d, g_val: %d, &amp;g_val: %d\n", getpid(), getppid(), g_val, &amp;g_val);
            sleep(1);
            if (cnt) cnt--;
            else 
            {
                g_val = 200;
                printf("exchange g_val 1 -&gt; 200");
                cnt--;
            }
        }
    }
    else 
    {

        while (1)
        {
            printf("i am parent, pid: %d, ppid: %d, g_val: %d, &amp;g_val: %d\n", getpid(), getppid(), g_val, &amp;g_val);
            sleep(1);
        }
    }

    return 0;

}
</code></pre> 
<p id="uae206d45"></p> 
<p class="img-center"><img alt="" height="271" id="ufb90bc3f" src="https://images2.imgbox.com/e6/1d/Qdn81Sh0_o.png" width="1200"></p> 
<p id="u1fc7d3c7">在子进程中 g_val修改了，但是父进程中的却没有改变，确实，前面说过，不同的进程中数据不会有影响，但是看 g_val 的地址，父子进程都一样，地址都一样，值却不一样。</p> 
<p id="u6976d772"></p> 
<p id="ub82f0ad5">这里可以得出一个小结论：<strong>如果变量的地址是物理地址，不可能存在上面的现象。这个地址是线性地址&amp;&amp;虚拟地址,我们平常写的C/C++用的指针，指针里面的地址，全部都不是物理地址。</strong></p> 
<p id="u39e0f8a0"></p> 
<p id="u31ddfc60"><strong>当我们运行一个程序后，这个程序会变成一个进程，内核一定会为这个进程创建PCB，同时也会创建一个进程地址空间</strong>。就是上面画的图。</p> 
<p id="u2fcbde46">平常在写代码的时候，我们所用的空间就是全0~全F，进程地址空间是内核为进程创建的结构体对象，PCB里有指针指向该进程地址空间。通过一个页表(K-V的映射关系，K虚拟地址，V物理地址)的东西，这样就可以访问到物理地址了。</p> 
<p id="udb498c96">父进程在创建子进程的时候，也会创建PCB结构，会以父进程为模板，创建出来，当然，子进程也会有自己的东西。子进程和父进程有独立性，子进程会从父进程中拷贝进程地址空间，页表也会拷贝，所以子进程跟父进程一样，通过页表的映射关系，通过虚拟地址，可以找到相同的物理地址。所以父子进程就实现了代码共享，数据共享。</p> 
<p id="ue45f35fb"></p> 
<p id="u55bc7d6a">当子进程要数据进行修改的时候，会通过页表查地址，系统会发现，这个数据是和父进程共享的，系统就会重新为子进程分配一块空间，然后将修改后的变量放在这个新空间里，再将页表中虚拟地址所映射的物理地址进行一个更改。</p> 
<p id="u20d03476"><strong>先经过写时拷贝 --- 是由操作系统亲自完成的。</strong></p> 
<p id="u50885389"><strong>重新开辟空间，但是在这个过程中，左侧的虚拟地址是0感知的，不关心，不会影响它 g_val = 200。</strong></p> 
<h3 id="Z3vAg">地址空间是什么</h3> 
<p id="u41311351">你的地址总线排列组合形成地址范围[0, 2 ^ 32]</p> 
<p id="udbd1c7b4">地址空间就是在极端情况下，进程所能访问的地址边界情况。</p> 
<p id="ue863596d"></p> 
<p id="ue03bc355">在小学的时候，同桌之间闹矛盾了，一般会画个三八线，三八线左面是小胖的位置，右边是小花的位置，小花画的三八线的本质就是 区域划分。那么用计算机语言如何描述小胖越界的情况呢？ 所以 要有一个结构体来把这个空间给管理起来。</p> 
<pre id="TCIlD"><code>struct area
{
	int start;
	int end;
};

struct destop_area 
{
    struct area 小花;
	struct area 小胖;
};</code></pre> 
<p id="u52c78a75">小花说，你在越界，我就把三八线左移10cm。所谓的空间区域调整变大或者变小如何理解？</p> 
<pre id="fLjo8"><code>struct destop_area line_area = {<!-- -->{1, 50}, {51, 100}};
line_area.小胖.end -= 10;
line_area.小花.start -= 10;</code></pre> 
<p id="u29159b9f">这样，小胖的区域就小了10。</p> 
<p id="u7a8ca958">小胖能把自己的东西放在自己的空间内。</p> 
<p id="u45d2f46d">在范围内，连续的空间中，每一个最小单位都可以有地址，这个地址可以被小胖直接使用。</p> 
<p id="u6b76e2b7"><strong>所谓的进程地址空间，本质是一个描述进程可视范围的大小，进程空间内一定要存在各种区域划分，对线性地址进行start和end即可。</strong></p> 
<hr id="pHCTf"> 
<p id="uf6c7f2f6">每一个进程都有自己的进程地址空间，在创建一个进程后，也要创建进程地址空间结构体对象，和PCB类似，地址空间也要被操作系统管理： 先描述 后组织。</p> 
<pre id="TiwZX"><code>struct mm_struct
{
	long code_start;
	long code_end;

	long readonly_start;
	long readonly_end;

	long init_start;
	long init_end;

	long uninit_start, uninit_end;
	long heap_start, heap_end;
	long stack_start, stack_end;
};</code></pre> 
<hr id="cWiIO"> 
<p id="u601c1f9e">有一个身价十亿美金的富豪，有4个孩子，这四个孩子相互之间并不知道，富豪给四个孩子画了张大饼，孩子1要办工厂，往富豪要了5万美金。孩子2，3，4都往富豪要钱，他们都知道富豪有十个亿，只要自己要钱，富豪都会给，不管要了多少钱，他们都以为自己只是从富豪那里拿了一部分。等到富豪死了之后，四个孩子都以为自己会继承十个亿。</p> 
<p id="udbebd383">这里 富豪就是操作系统，四个孩子就是 一个一个的进程。每一个进程都被操作系统画了张大饼，这张饼就是进程地址空间。</p> 
<p id="uce8ac0ec">页表里面其实是有一个标志位，表示对应的代码和数据是否已经加载到内存。</p> 
<p id="ua1d7b29e">在访问数据的时候，操作系统识别到对应的数据没有加载到内存里，这个时候操作系统会触发一个概念---缺页中断。</p> 
<p id="u25e51163">当进程在被创建的时候，先创建内核数据结构，在加载对应的可执行程序。</p> 
<p id="ub80037ff">所以 为什么要有进程地址空间？</p> 
<ol><li id="uf2c22477">让进程以统一的视角看待内存。</li><li id="u61d1e350">增加进程虚拟地址空间可以让我们访问内存的时候，增加一个转换的过程，在这个转化的过程中，可以对我们的寻址请求进行审查，所以一旦异常访问，直接拦截，该请求不会到达物理内存，保护物理内存。</li><li id="u0ce503f6">因为有地址空间和页表的存在，将进程管理模块和内存管理模块进行耦合。</li></ol> 
<p id="u0559b012">现代操作系统几乎不做任何浪费空间和浪费时间的事情。</p> 
<p id="udbf7a1f3">从现阶段而言 进程 = 内核数据结构(task_struct， mm_struct， 页表) + 程序的代码和数据</p> 
<p id="ue50106ac"></p> 
<h2 id="QKZOR">进程控制</h2> 
<p id="ub0aef53f">一个进程中，父进程是要关心的。</p> 
<p id="u1ad076b8">平常我们写的代码，为什么要在结尾加上return 0;</p> 
<p id="u22a501e8">0 是进程的退出码，由父进程接收。可以用return 的不同返回值数字，表示不同的出错原因</p> 
<p id="ub7f497d6">main函数的返回值本质表示：进程运行完成时是否是正确的结果，如果不是，可以用不同的数字表示不同的出错原因。</p> 
<p id="ub3f21d40"></p> 
<p id="u66f4573a">在用命令行敲一个代码之后，成功运行后，输入</p> 
<pre id="rbxZC"><code>echo $?
保存最近一次进程退出的时候的退出码</code></pre> 
<p id="u7fc22cfc"></p> 
<p id="uaf2b9cc5">返回的这个数字，是让计算机看的。</p> 
<p id="u952bfbd5">在linux中，有接口可以查看这些错误码。</p> 
<p id="u5a3125de"></p> 
<p class="img-center"><img alt="" height="694" id="ud84ee0fd" src="https://images2.imgbox.com/19/65/Y2r1DsRq_o.png" width="1200"></p> 
<p id="u90fa08b0"></p> 
<pre id="XESa9"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
int g_val = 1;
int main()
{
    int i = 0;
    for (i = 0; i &lt; 200; i++)
    {
        printf("%d: %s\n", i, strerror(i));
    }
    return 0;
}
</code></pre> 
<p id="u6916a0ed"></p> 
<p class="img-center"><img alt="" height="340" id="u778b5b4e" src="https://images2.imgbox.com/4c/3f/GPq5YuwD_o.png" width="1087"></p> 
<p id="u3777ad7a">这是系统所提供的。</p> 
<hr id="izH9o"> 
<p id="udaaa3d1e"></p> 
<p class="img-center"><img alt="" height="112" id="u34d79c0d" src="https://images2.imgbox.com/2b/a8/tpdD39hr_o.png" width="904"></p> 
<p id="u0aef18e6">这个报错，不就是strerror中的2号退出码吗？这个进程粗错误了，返回不同的错误码，以此来上计算机识别，计算机只懂数字，不懂其他的。</p> 
<hr id="zy5MP"> 
<p id="ue6acf5ef">如果不想用系统中的退出码，也可以自己设计。</p> 
<hr id="gDVKf"> 
<p id="uc63af453">进程出了异常，本质是我们的进程收到了信号！</p> 
<p id="u057b90b9">现在我们写了一个死循环的进程，通过kill -9可以杀死该进程。</p> 
<p id="u9421543e"></p> 
<p class="img-center"><img alt="" height="76" id="uac4115c6" src="https://images2.imgbox.com/7c/a6/vweyMEbK_o.png" width="643"></p> 
<p id="uc2ab3edd"></p> 
<p class="img-center"><img alt="" height="214" id="u5f9ce2f7" src="https://images2.imgbox.com/8f/95/YwnrJHTJ_o.png" width="451"></p> 
<hr id="aSkRC"> 
<p id="u1b531519"></p> 
<p class="img-center"><img alt="" height="166" id="ub053cb76" src="https://images2.imgbox.com/4c/64/5m1RSHV2_o.png" width="712"></p> 
<p id="u1113eea6"></p> 
<p class="img-center"><img alt="" height="79" id="u2ff95d7d" src="https://images2.imgbox.com/7b/2e/QhgvPNf3_o.png" width="634"></p> 
<hr id="l5NW4"> 
<p id="u84fc50fb">之前我们写顺序表链表的时候，有时候会用exit来退出程序，其中exit(n)，这个n是数字，也是退出码。</p> 
<p id="ueac46383"></p> 
<p class="img-center"><img alt="" height="919" id="u1e832ab4" src="https://images2.imgbox.com/07/46/wzkvoT1g_o.png" width="904"></p> 
<p id="uc2c51fee"></p> 
<p class="img-center"><img alt="" height="349" id="u4de7ee50" src="https://images2.imgbox.com/01/50/q9LviKjw_o.png" width="640"></p> 
<p id="ua7ffd708">exit在任意地方被调用表示调用进程退出。</p> 
<p id="ud2dd156a">如果在show函数中用的是return，这代表的是该函数结束，并不是进程结束。</p> 
<hr id="Ce8YW"> 
<p id="u85a45466">有exit，return还有一个_exit，跟exit的区别是，_exit会直接结束进程，缓冲区的东西不在输出。exit在结束进程的时候，会把缓冲区的内存给输出。</p> 
<p id="ua0aeea2e">_exit()是系统调用接口，exit()先冲刷缓冲，关闭流等，在调用_exit()。</p> 
<p id="u0a62de45">我们的printf一定是先将数据写入缓冲区中，合适的时候，在进行刷新。</p> 
<h2 id="B8gAQ">进程等待</h2> 
<p id="u19154e6b"><strong>通过系统调用wait/waipid，来进行对子进程进行状态检测与回收的功能。</strong></p> 
<p id="u400534bd">之前说过，在子进程退出的时候，父进程却不管不问，就可能会造成僵尸进程的问题，进而造成内存泄漏。进程一旦变成僵尸进程，就无法被杀死，西药通过进程等待来杀掉他，进而解决内存泄漏的问题---这个问题必须解决。</p> 
<p id="u318309c1">我们要通过进程等待，获得子进程的退出情况---知道我布置给子进程的任务，他完成的怎么样了---可以关心，可以不关心---可选的。</p> 
<hr id="y3juI"> 
<pre id="MDCug"><code>#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
int main()
{
  pid_t id = fork();
  if (id &lt; 0)
  {
    perror("fork");
  }
  else if (id == 0) 
  {
    int cnt = 5;
    while (cnt)
    {
      std::cout &lt;&lt; "I am child, pid: " &lt;&lt; getpid() &lt;&lt; " ppid: " &lt;&lt; getppid() &lt;&lt; " cnt: " &lt;&lt; cnt &lt;&lt; std::endl;
      cnt--;
      sleep(1);
    }

    exit(0);
  }
  else 
  {
    while (1)
    {
      std::cout &lt;&lt; "I am parent, pid: " &lt;&lt; getpid() &lt;&lt; " ppid: " &lt;&lt; getppid() &lt;&lt; std::endl;
      sleep(1);
    }
  }

  return 0;
}
</code></pre> 
<p id="ucaf56b40">写了这样一个程序，可以看一下程序的前五秒情况和后面的情况。</p> 
<p id="u23e76701"></p> 
<p class="img-center"><img alt="" height="577" id="u08aa9802" src="https://images2.imgbox.com/e1/bf/7eQrvzWB_o.png" width="703"></p> 
<p class="img-center"><img alt="" height="367" id="u1957aaf6" src="https://images2.imgbox.com/d5/21/ksVMOEeT_o.png" width="1200"></p> 
<p id="u0568e9db">前五秒，子进程正常，之后子进程进入僵尸状态。</p> 
<hr id="oAe5B"> 
<p id="u26eaaf70">在写代码的时候，可能会出现让父进程等待子进程或者是让父进程通过一些办法来回收僵尸进程，可以通过wait和waitpid来解决这样的问题.</p> 
<p id="u2c42e00c">在linux中输入 man 2 wait可以查看</p> 
<p id="u97e3f2e0"></p> 
<p class="img-center"><img alt="" height="769" id="ubc2db9f2" src="https://images2.imgbox.com/41/35/V0cVI818_o.png" width="1200"></p> 
<pre id="RRS12"><code>#include&lt;sys/types.h&gt;
#include&lt;sys/wait.h&gt;
pid_t wait(int*status);
返回值：
成功返回被等待进程pid，失败返回-1。
参数：
输出型参数，获取子进程退出状态,不关心则可以设置成为NULL

调用了wait之后，就会阻塞自己，wait会自动的去分析子进程。如果找到了某个子进程
变成了僵尸进程，wait就会把它消灭。当然如果没有找到，就会一直等待。</code></pre> 
<hr id="UBD6r"> 
<pre id="t3LmH"><code>#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/types.h&gt;


int main()
{
  pid_t id = fork();
  if (id &lt; 0)
  {
    perror("fork");
  }
  else if (id == 0) 
  {
    int cnt = 5;
    while (cnt)
    {
      std::cout &lt;&lt; "I am child, pid: " &lt;&lt; getpid() &lt;&lt; " ppid: " &lt;&lt; getppid() &lt;&lt; " cnt: " &lt;&lt; cnt &lt;&lt; std::endl;
      cnt--;
      sleep(1);
    }

    exit(0);
  }
  else 
  {
    int cnt = 10;
    while (cnt)
    {
      std::cout &lt;&lt; "I am parent, pid: " &lt;&lt; getpid() &lt;&lt; " ppid: " &lt;&lt; getppid() &lt;&lt; std::endl;
      cnt--;
      sleep(1);
    }
    // 等待任意子进程退出。
    pid_t ret = wait(NULL);
    if (ret == id)
    {
      std::cout &lt;&lt; "wait success, ret: " &lt;&lt; ret &lt;&lt; std::endl;
    }

    sleep(5);
  }

  return 0;
}
</code></pre> 
<p id="ubbc018c1">对上面的代码进行了一个修改。</p> 
<p id="u3f35ebbe"></p> 
<p class="img-center"><img alt="" height="550" id="u84cea673" src="https://images2.imgbox.com/2e/0f/DfNd0MTz_o.png" width="973"></p> 
<p id="u686b85ae"></p> 
<p class="img-center"><img alt="" height="721" id="u07dca721" src="https://images2.imgbox.com/3f/37/TvuM9Gk3_o.png" width="1200"></p> 
<p id="u4b1439a6">修改后的代码把僵尸进程给回收了。</p> 
<hr id="rB5ww"> 
<p id="u2fdd2a8b">当然，上面的代码是针对任意子进程。</p> 
<p id="u06309bff">现在创建多个子进程</p> 
<pre id="QWdSN"><code>#include &lt;iostream&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;
#define N 10

void RunChild()
{
    int cnt = 5;
    while(cnt)
    {
        printf("I am Child Process, pid: %d, ppid:%d\n", getpid(), getppid());
        sleep(1);
        cnt--;
    }
}

int main()
{
  int i;
  for (i = 0; i &lt; N; i++)
  {
    pid_t id = fork();
    if (id == 0)
    {
      RunChild();
      exit(0);
    }
    std::cout &lt;&lt; "create child process: " &lt;&lt; id  &lt;&lt; " success " &lt;&lt; std::endl;
  }

  sleep(10);

  for (i = 0; i &lt; N ; i++)
  {
    pid_t id = wait(NULL);
    if (id &gt; 0)
    {
      std::cout &lt;&lt; "wait " &lt;&lt; id &lt;&lt; " success " &lt;&lt; std::endl;
    }
  }
  return 0;
}</code></pre> 
<p id="ub46b44cb"></p> 
<p class="img-center"><img alt="" height="919" id="u527329ec" src="https://images2.imgbox.com/e0/a3/tmpHx99T_o.png" width="1200"></p> 
<p id="ub6c612cc">创建了十个子进程，就等待十个子进程---循环等待。</p> 
<hr id="t3RSt"> 
<p id="u06e21d24">如果子进程不退出，父进程默认在wait的时候，调用这个系统调用的时候，也就不反回，默认叫做阻塞状态。</p> 
<pre id="Mta6q"><code>pid_ t waitpid(pid_t pid, int *status, int options);
返回值：
    当正常返回的时候waitpid返回收集到的子进程的进程ID；
    如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；
    如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；
参数：
    pid：
        Pid=-1,等待任一个子进程。与wait等效。
        Pid&gt;0.等待其进程ID与pid相等的子进程。
    status:
        WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）
        WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）
    options:
        WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进
        程的ID</code></pre> 
<hr id="SD7Dl"> 
<p id="uad362372">获取子进程的退出信息，是通过wait/waitpid中的statue参数来获得的。</p> 
<pre id="TlWhJ"><code>int status = 0;
//pid_t ret = wait(NULL);
//pid_t ret = waitpid(id, &amp;status, 0);</code></pre> 
<p id="u22e8fe44">如果说，父进程在等待子进程的时候，关心子进程，可以自己定义一个status变量，当我们调用的时候，操作系统会自动的把退出信息拷贝到status变量中。这样就能拿到子进程的退出信息。</p> 
<p id="u9a4b80e7"></p> 
<pre id="cM3a6"><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;iostream&gt;

#define N 10

void RunChild()
{
    int cnt = 5;
    while (cnt)
    {
        printf("I am Child Process, pid: %d, ppid:%d\n", getpid(), getppid());
        sleep(1);
        cnt--;
    }
}

int main()
{
    pid_t id = fork();
    if (id &lt; 0) {
        perror("fork");
        return 1;
    }
    else if (id == 0)
    {
        //int *p = NULL;
        // child
        int cnt = 1;
        while (cnt)
        {
            printf("I am child, pid:%d, ppid:%d, cnt: %d\n", getpid(), getppid(), cnt);
            cnt--;
            sleep(1);
            //*p = 100;
        }
        exit(1);
    }

       int  cnt = 5;
        while (cnt)
        {
            printf("I am father, pid:%d, ppid:%d, cnt: %d\n", getpid(), getppid(), cnt);
            cnt--;
            sleep(1);
        }

        int status = 0;

        pid_t ret = waitpid(id, &amp;status, 0);

        if (ret == id)
        {
            std::cout &lt;&lt; "wait success , ret: " &lt;&lt; ret &lt;&lt; " status: " &lt;&lt; status &lt;&lt; std::endl;

        }
        sleep(5);
    

    return 0;
}
</code></pre> 
<p id="u38e5328f">在输出结果之后，发现，status是 256，并不是子进程的退出码1 。</p> 
<hr id="AV6Cc"> 
<p id="uc1032e52">子进程在退出的时候一共有三种场景：代码运行完毕，结果正确/不正确，代码异常终止。</p> 
<p id="u8c57e7d0">父进程等待是想要获得子进程的哪些信息呢？1.子进程代码是否异常 2.没有异常，结果对吗？不对是因为什么，不同的退出码，表示不同的出错原因。</p> 
<p id="u23b68df3">这个status不单单是一个int，它要被划分为多个部分。</p> 
<p id="u36bb2b22"></p> 
<p class="img-center"><img alt="" height="601" id="u163d179f" src="https://images2.imgbox.com/c6/96/fCu5mnbw_o.png" width="889"></p> 
<p id="ufa7db8c7">int 有32位，我们只考虑它的低16位，其中低七位表示的是进程是否收到信号，次低8位表示退出码。这两个字段组合，就能把所有的情况包含。</p> 
<p id="uc61389cb">通过kill -l可以查看信号，一共有64个信号，所以我们可以通过终止信号来判断代码是否执行完毕，结果对不对就可以通过退出状态来判断结果对不对。</p> 
<hr id="w1cAO"> 
<pre id="WB5lx"><code>// 7F: 0111 1111
// printf("wait success, ret: %d, exit sig: %d, exit code: %d\n", ret, status&amp;0x7F, (status&gt;&gt;8)&amp;0xFF);</code></pre> 
<p id="u1f946946">添上上面的代码，就可以正确输出退出码了。</p> 
<p id="u39f3b76c"></p> 
<p class="img-center"><img alt="" height="280" id="u438bf0a7" src="https://images2.imgbox.com/25/79/TZ2O8RV6_o.png" width="985"></p> 
<hr id="RJOgQ"> 
<p id="uc6822e17">下面我们可以自己故意设定一些错误。</p> 
<pre id="tNh2a"><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

#define N 10

void RunChild()
{
    int cnt = 5;
    while (cnt)
    {
        printf("I am Child Process, pid: %d, ppid:%d\n", getpid(), getppid());
        sleep(1);
        cnt--;
    }
}

int main()
{
    pid_t id = fork();
    if (id &lt; 0) {
        perror("fork");
        return 1;
    }
    else if (id == 0)
    {
        //int *p = NULL;
        // child
        int cnt = 1;
        while (cnt)
        {
            printf("I am child, pid:%d, ppid:%d, cnt: %d\n", getpid(), getppid(), cnt);
            cnt--;
            sleep(1);
            //*p = 100;
        }
        int a = 10;
        a /= 0;
        exit(1);
    }

       int  cnt = 5;
        while (cnt)
        {
            printf("I am father, pid:%d, ppid:%d, cnt: %d\n", getpid(), getppid(), cnt);
            cnt--;
            sleep(1);
        }

        int status = 0;

        pid_t ret = waitpid(id, &amp;status, 0);

        if (ret == id)
        {
      
          printf("wait success, ret: %d, exit sig: %d, exit code: %d \n", ret, status&amp;0x7F, (status&gt;&gt;8)&amp;0xFF);
        sleep(5);
        }

    return 0;
}
</code></pre> 
<p id="uecd8d9d4"></p> 
<p class="img-center"><img alt="" height="253" id="u1dac8d8d" src="https://images2.imgbox.com/79/99/klGS25RW_o.png" width="934"></p> 
<p id="uc0b0ed1e">退出码就是8，在通过kill -l查看一下</p> 
<p id="ubb131575"></p> 
<p class="img-center"><img alt="" height="94" id="u9ebb58f2" src="https://images2.imgbox.com/94/9b/eEO5mZ7u_o.png" width="202"></p> 
<hr id="jTh6M"> 
<p id="u651baf53">子进程在退出的时候，会把退出信息保存在子进程PCB当中，对应的父进程就会去waitpid中读取子进程PCB的退出信息，如果检测到Z状态，就读取exit_code和exit _signal合成status返回。</p> 
<hr id="E1Z7Y"> 
<p id="u8da72ed1"><strong>非阻塞轮询</strong></p> 
<p id="u68bf6df8">比如说快该考试了，小张让小王去帮他复习一下操作系统这门课，小王说行啊，但现在不行，你得等会。然后小张就在楼下等着，等了三四分钟，小王没下来，打电话小王还在干其他事，陆陆续续打了十几个电话，小王终于下来了。你们两个相互看到了。</p> 
<p id="u1432e836">小王就是操作系统，每一次打电话就是检查的过程。在小王有其他事情的时候，你立马挂了电话，就是非阻塞，陆陆续续打电话的过程就是轮询。</p> 
<p id="uf8653120">停了几天，要考数据结构，小张还是找的小王复习，小张给小王打电话让帮它复习，小王答应了，准备挂电话的时候，小张说，电话别挂，见面了在挂电话。小王就是操作系统，小张就是用户，这种调用方式就是阻塞式调用。</p> 
<p id="u29fc42ca">在考试的时候，你还是找小王复习，你带了一本书和手机，在你等待小王的过程中，玩玩手机，看看书。听一段时间给小王打个电话问问什么时候下来。这就是非阻塞轮询 + 自己的事情。</p> 
<p id="ud5127be0"></p> 
<pre id="sah0O"><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

#define N 10

void RunChild()
{
    int cnt = 5;
    while (cnt)
    {
        printf("I am Child Process, pid: %d, ppid:%d\n", getpid(), getppid());
        sleep(1);
        cnt--;
    }
}

int main()
{

    pid_t id = fork();
    if (id &lt; 0) {
        perror("fork");
        return 1;
    }
    else if (id == 0)
    {
        //int *p = NULL;
        // child
        int cnt = 1;
        while (cnt)
        {
            printf("I am child, pid:%d, ppid:%d, cnt: %d\n", getpid(), getppid(), cnt);
            cnt--;
            sleep(1);
            //*p = 100;
        }
        exit(11);
    }
    else
    {

        int status = 0;

        while (1) { //轮询
            pid_t ret = waitpid(id, &amp;status, WNOHANG); //非阻塞
            if (ret &gt; 0)
            {

                if (WIFEXITED(status))
                {
                    printf("进程是正常跑完的, 退出码:%d\n", WEXITSTATUS(status));
                }
                else {
                    printf("进程出异常了\n");
                }
                break;
            }
            else if (ret &lt; 0)
            {
                printf("wait failed!\n");
                break;
            }
            else
            {
                printf("你好了没？子进程还没有退出，我在等等...\n");
                sleep(1);
            }
        }
    }

    return 12;
}</code></pre> 
<p id="ud2352e6a">这就是一个非阻塞轮询。</p> 
<p id="ud16f441e"></p> 
<p class="img-center"><img alt="" height="136" id="uda6afa4e" src="https://images2.imgbox.com/17/8e/M2z1CdtL_o.png" width="853"></p> 
<h2 id="oEyae">进程程序替换</h2> 
<h3 id="XCZE9">替换原理</h3> 
<p id="u59c774ac">用fork创建子进程后执行的是和父进程相同的程序，但有可能执行不同的代码分支，子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程所以调用exec前后该进程的id并未改变。</p> 
<p id="uc7b88bac"></p> 
<p id="u28d52172">通过 `man 3 exec`可以查看exec函数。</p> 
<p id="u4f3e3e84"></p> 
<p class="img-center"><img alt="" height="676" id="u3cc0a509" src="https://images2.imgbox.com/20/e2/hllHRBK1_o.png" width="1200"></p> 
<hr id="wdETU"> 
<h3 id="lTVeQ">单进程程序替换</h3> 
<p id="u22378e09"></p> 
<p class="img-center"><img alt="" height="73" id="uc4e0ae3b" src="https://images2.imgbox.com/91/fa/scr2N6TJ_o.png" width="1029"></p> 
<p id="ud0863f75">像这种后面带三个点的是可变参数，可以传递任意数量的参数，但最后一个参数要是NULL；</p> 
<pre id="Vt449"><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  printf("before: I an a process, pid: %d, ppod: %d\n", getpid(), getppid());

  execl("/usr/bin/ls", "ls", "-a", "-l", NULL); // 也可以换成其他指令，第一个参数是路径

  


  printf("after: I an a process, pid: %d, ppod: %d\n", getpid(), getppid());

  return 0;
}
</code></pre> 
<p id="u0ad74bef"></p> 
<p class="img-center"><img alt="" height="304" id="u4d005c18" src="https://images2.imgbox.com/88/57/U2bAkLRY_o.png" width="885"></p> 
<p id="u221e006a">这个代码在运行之后没有输出after。</p> 
<p id="u5fd72cce"></p> 
<p id="u5ddc40e1">前面说过，进程在创建之后，会有自己的PCB，进程地址空间，页表，物理内存。通过./运行这个程序的时候，会把数据加载到物理内存中，然后进程地址空间通过页表形成一个映射关系。在执行的过程中遇到了ls这个命令，这个时候，系统会做一件暴力的事情，直接拿ls的代码替换我自己的代码，用新的可执行程序替换旧的可执行程序，然后重新开始执行。这个过程就是 程序替换。</p> 
<hr id="VEskg"> 
<h3 id="r4fAz">多进程程序替换</h3> 
<pre id="DK4M9"><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/types.h&gt;


int main()
{
  pid_t id = fork();
  if (id == 0)
  {
    // 子进程
     printf("before: I an a process, pid: %d, ppod: %d\n", getpid(), getppid());
     execl("/usr/bin/ls", "ls", "-a", "-l", NULL);     
     printf("after: I an a process, pid: %d, ppod: %d\n", getpid(), getppid());
      exit(0);
  }

  pid_t ret = waitpid(id, NULL, 0);
  if (ret &gt; 0) printf("wait success, father mypid: %d, ret id: %d\n", getpid(), ret);
  return 0;
}</code></pre> 
<p id="u7327efcf"></p> 
<p class="img-center"><img alt="" height="304" id="u124946a2" src="https://images2.imgbox.com/e2/74/nuTwEqb3_o.png" width="870"></p> 
<p id="u3b002b9e">子进程执行到exec的时候，会不会影响到父进程呢？</p> 
<p id="u38492ed7">不会，因为有写时拷贝技术，以及进程之间数据相互独立的特性。</p> 
<hr id="b0wqb"> 
<p id="u8a078d2e">补充</p> 
<p id="u5440a54c">不管单进程程序替换还是多进程程序替换，相应进程中的after都没有打印出来。</p> 
<p id="udc36dd52">after位于execl之后，程序就被替换了，替换之后，就会重新执行新代码，也就是替换之后的代码，after已经被替换了，所以不会被执行，也不能被执行。</p> 
<ol><li id="u3b229042">现象： 程序替换成功之后，exec* 后续的代码不会被执行。失败之后，才可能执行后续代码。exec* 函数，只有失败返回值，没有成功返回值。</li><li id="ud476a916">小知识：Linux中形成的可执行程序，是有格式的，ELF，可执行程序的表头，可执行程序的入口地址。</li></ol> 
<p id="ue838839c"></p> 
<p id="ufb35c29f">exec系列的程序替换函数一共有七个。‘</p> 
<p id="u2f255f52"></p> 
<p class="img-center"><img alt="" height="604" id="u44f4c24e" src="https://images2.imgbox.com/3c/45/UJ7uezve_o.png" width="1200"></p> 
<p id="u0a216aea">execl 可以看作是 exec list，参数是一个一个的传递给函数的，名字中带l的就是一个一个的传，可变参数的。</p> 
<p id="u5baf9aa3">你要执行一个程序的第一件事情是什么---先找到这个程序。所以函数的参数第一个都是文件的全路径或者相对路径。找到这个程序之后，执行这个程序就是： 命令行怎么写，你就怎么传。</p> 
<p id="u6d5b3eed">execlp 可以看作是 execl PATH， execlp自己会在默认的PATH环境变量中直接查找。只需要写文件名字，系统会自动地去寻找文件。第一个参数是要找到的文件，后面的参数是要执行的指令。</p> 
<p id="u22da1dce"></p> 
<p class="img-center"><img alt="" height="463" id="u7ca9ff4a" src="https://images2.imgbox.com/93/69/fY8EbDN6_o.png" width="1139"></p> 
<p id="u3e18f1ad"></p> 
<p class="img-center"><img alt="" height="343" id="uf3d3c4b9" src="https://images2.imgbox.com/f0/6c/gkFMXuLT_o.png" width="947"></p> 
<p id="uebf72a0d">execv 可以看作是 exec vector，execv的第一个参数是路径，第二个参数是字符串指针数组。其实就是当我们在命令行输入ls -a -l变成了 一个指针数组的形式，必须以NULL结尾。</p> 
<p id="u39800ce9"></p> 
<p class="img-center"><img alt="" height="634" id="u1afae789" src="https://images2.imgbox.com/03/f8/T5ZdvmI2_o.png" width="1131"></p> 
<p id="u7a4daf24"></p> 
<p class="img-center"><img alt="" height="334" id="ub886b63b" src="https://images2.imgbox.com/7c/9b/wCJnuXrb_o.png" width="862"></p> 
<p id="u8450fdba">在单进程程序替换中，把新旧代码覆盖并加载到内存当中，exec函数承载的是一个加载器的效果。execv就是加载器，代码级别的加载器。</p> 
<p id="u80dc819e"></p> 
<p id="ua9a9cfd7">有了前面的基础，execvp是什么意思就好理解了。</p> 
<p id="ub319c3ba"></p> 
<p class="img-center"><img alt="" height="511" id="u9111c8a5" src="https://images2.imgbox.com/eb/5d/S99bmvLq_o.png" width="1135"></p> 
<p id="ua38fae7e"></p> 
<p class="img-center"><img alt="" height="346" id="u6b5ca432" src="https://images2.imgbox.com/fa/87/l6sIsM31_o.png" width="976"></p> 
<p id="ued8bdc9a"></p> 
<p id="ua96fa442">前面跳了一个execle现在来说， execl e，e可以看作是env，环境变量，我们在执行可执行程序的时候，可以传递我们自己的环境变量。</p> 
<p id="u550c06ee">编写了一个hello.cpp的文件，在proc.c中去调用这个程序。</p> 
<pre id="GdHnS"><code>#include &lt;iostream&gt;

int main(int argc, char *argv[])
{

  for (int i = 0; argv[i]; i++)
  {
    std::cout &lt;&lt; argv[i] &lt;&lt; " ";
  }
  std::cout &lt;&lt; std::endl;

  std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;
  std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;
  std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;
  std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;

  return 0;
}



#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/types.h&gt;


int main()
{
  pid_t id = fork();
  if (id == 0)
  {

    char *const myargv[] = {
      "hello",
      "-a",
      "-b",
      NULL
    };
    // 子进程
     printf("before: I an a process, pid: %d, ppod: %d\n", getpid(), getppid());
    
     execv("./hello",myargv);      
     printf("after: I an a process, pid: %d, ppod: %d\n", getpid(), getppid());
      exit(0);
  }

  pid_t ret = waitpid(id, NULL, 0);
  if (ret &gt; 0) printf("wait success, father mypid: %d, ret id: %d\n", getpid(), ret);
  return 0;
}

</code></pre> 
<p id="u8145b113"></p> 
<p class="img-center"><img alt="" height="280" id="u27af7989" src="https://images2.imgbox.com/59/60/KvUoG6zF_o.png" width="894"></p> 
<pre id="QUB7L"><code>先看一下makefile 文件的编写
.PHONY:all
all:proc hello
proc:proc.c
	gcc -o $@ $^ -std=c99 
hello:hello.cpp
	g++ -o $@ $^
.PHONY:clean
clean:
	rm -f proc hello
这样可以一次性的编译两个文件。</code></pre> 
<p id="u1bd45ada"></p> 
<p id="ubfd499ae">确实可以在proc中拿到信息。</p> 
<p id="u1d0d1892">现在在hello文件中添加上main函数的第三个参数，proc文件中代码不变。</p> 
<p id="u5bc2cc80"></p> 
<p class="img-center"><img alt="" height="1015" id="uc3798410" src="https://images2.imgbox.com/1c/a2/poHPiQYW_o.png" width="1200"></p> 
<p id="u8e91f8f2">环境变量是自动传递过去的。</p> 
<p id="uf0f18ab5">环境变量是什么时候传递过去的呢？？</p> 
<p id="u36e9f19b">首先，环境变量也是数据，当我么你创建子进程的时候，环境变量就已经被子进程继承下去，即便没有命令行参数，也可以拿到。</p> 
<p id="u9bc99f6d">所以程序替换的时候，环境变量信息不会被替换。所以想给子进程传递环境变量，应该怎么传递？</p> 
<ol><li id="u17bdbcb8">新增环境变量</li><li id="u7b892b0d">彻底替换</li></ol> 
<p id="u0478871a">可以直接在父进程的地址空间中直接putenv</p> 
<p id="u7e6611f3"></p> 
<p class="img-center"><img alt="" height="181" id="ue769b338" src="https://images2.imgbox.com/59/ba/i9FeSVl5_o.png" width="801"></p> 
<p id="u6d2642f5"></p> 
<p class="img-center"><img alt="" height="127" id="u7053f6b8" src="https://images2.imgbox.com/4e/47/CgJpuULD_o.png" width="943"></p> 
<p id="u3d77347c">在这里导入之后，跟系统中的环境变量没关系，不会出现在系统中。</p> 
<p id="ucf0eb2b0"></p> 
<p id="uf2d1a066">说了这么多，就是为了介绍execle的前置知识</p> 
<p id="u80ed17b0"></p> 
<p class="img-center"><img alt="" height="835" id="uefd9ccc9" src="https://images2.imgbox.com/62/88/pCPGzwdO_o.png" width="1137"></p> 
<p id="u578fb532"></p> 
<p class="img-center"><img alt="" height="409" id="u399652d4" src="https://images2.imgbox.com/aa/24/2Y4qfkTJ_o.png" width="1200"></p> 
<p id="u3a145841"></p> 
<p id="ua8c6d5dd">也可以传递自定义环境变量。</p> 
<p id="u12c59b88"></p> 
<p class="img-center"><img alt="" height="697" id="u66d71e84" src="https://images2.imgbox.com/c3/99/zx3jiyRp_o.png" width="1145"></p> 
<p id="u65f7719b"></p> 
<p class="img-center"><img alt="" height="376" id="ud13a5a08" src="https://images2.imgbox.com/b6/11/JFUABr0R_o.png" width="978"></p> 
<p id="u2e2fb201"></p> 
<p id="u87e147a1">当我们传递我们自定义的环境变量的时候，采用的策略是覆盖，而不是追加。</p> 
<hr id="xQnrF"> 
<h4 id="ycOMQ">命名理解</h4> 
<p id="u2753e3f9"><strong>命名理解</strong><br> 这些函数原型看起来很容易混,但只要掌握了规律就很好记。<br> l(list) : 表示参数采用列表<br> v(vector) : 参数用数组<br> p(path) : 有p自动搜索环境变量PATH<br> e(env) : 表示自己维护环境变量<br> 事实上,只有execve是真正的系统调用,其它五个函数最终都调用 execve,所以execve在man手册 第2节,其它函数在<br> man手册第3节。这些函数之间的关系如下图所示</p> 
<p id="u07155e2e"></p> 
<p class="img-center"><img alt="" height="592" id="u7124af7f" src="https://images2.imgbox.com/44/14/cmToH7WX_o.png" width="1200"></p> 
<hr id="eCKLB"> 
<pre id="KbaH9"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;fcntl.h&gt;



#define LEFT "["
#define RIGHT "]"
#define LABLE "#"
#define LINE_SIZE 1024
#define ARGC_SIZE 32
#define DELIM " "
#define EXIT_CODE 44

char myenv[LINE_SIZE];

int last_code = 0;
int quit = 0;
char pwd[LINE_SIZE];

extern char** environ;

const char* getusername()
{
  return getenv("USER");
}

const char* gethostname()
{
  return getenv("HOSTNAME");
}

void getpwd()
{
  getcwd(pwd,sizeof pwd);
}

void Interact(char *cline, int size)
{
  getpwd();
  printf(LEFT"%s@%s %s"RIGHT""LABLE" ", getusername(), gethostname(), pwd);
  char *s = fgets(cline, size, stdin);
  assert(s != NULL); 
  (void)s;


  cline[strlen(cline) - 1] = '\0';
}

int splistring(char* commandline,char *argv[])
{
  int i = 0;
  argv[i++] = strtok(commandline, DELIM);
  while (argv[i++] = strtok(NULL, DELIM)); 
  return i - 1;
}

int  buildCommand(char *_argv[], int _argc)
{

    if (_argc == 2 &amp;&amp; strcmp(_argv[0], "cd") == 0)
    {
      chdir(_argv[1]);
      getpwd();
      sprintf(getenv("PWD"), "PWD=%s", pwd);
      return 1;
    }
    
    else if (strcmp(_argv[0], "ls") == 0)
    {
      _argv[_argc++] = "--color";
      _argv[_argc] = NULL;
    }
    
    else if (_argc == 2 &amp;&amp; strcmp(_argv[0], "export") == 0)
    {
      if (strcmp(_argv[1], "$?") == 0)
      {
        printf("%d\n", last_code);
        last_code = 0;
      }
      strcpy(myenv, _argv[1]);
      putenv(myenv);
      return 1;
    }
    
    else if (_argc == 2 &amp;&amp; strcmp(_argv[0], "echo") == 0)
    {
      if (*_argv[1] == '$')
      {
        char *val = getenv(_argv[1] + 1);
        if (val) printf("%s\n", val);
      }
      else 
      {
        printf("%s\n", _argv[1]);
      }
      return 1;
    }

    return 0;
}

void NormalExcute(char *_argv[])
{
  pid_t id = fork();
  if (id &lt; 0) 
  {
    perror("fork error");
    return ;
  }
  else if (id == 0)
  {
    execvpe(_argv[0], _argv, environ);
    exit(EXIT_CODE);
  }
  else 
  {
    int status = 0;
    pid_t rid = waitpid(id, &amp;status, 0);
    if (rid == id)
    {
      last_code = WEXITSTATUS(status);
    }
  }
}

int main()
{
  char commandline[LINE_SIZE];
  char *argv[ARGC_SIZE];
  
  while (!quit)
  {
    Interact(commandline, sizeof (commandline));
    
    int argc = splistring(commandline, argv);
    if (argc == 0)
    {
      continue;
    }
    int n = buildCommand(argv, argc);  

    if (!n) NormalExcute(argv);

  //  for (int i = 0; argv[i]; i++) printf("[%d]: %s\n", i, argv[i]);
  //  printf("echo : %s\n", commandline);
  }
  return 0;
}
</code></pre> 
<p id="ub95898f4"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eb1842ac6f71ef53db27588c84c28951/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">正点原子嵌入式linux驱动开发——Linux 网络设备驱动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/71751a39c189a735b0094ad1fede6fc3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python---字符串中的查找方法--index()--括号里是要获取的字符串</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>