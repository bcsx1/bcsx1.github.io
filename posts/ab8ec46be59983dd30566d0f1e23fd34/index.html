<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Binder详解 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Binder详解" />
<meta property="og:description" content="深入分析AndroidBinder机制（远程对象访问）
介绍
Binder是什么？它可以叫作：IPC、RPC、线程迁移、远程对象访问，本文中理解它为远程对象访问更贴切些，简而言之就是一个进程能访问另一个进程中的对象，调用该对象的方法，就好像对象在自己的进程中一样，这种访问是同步的访问，当然Binder也能实现异步的通信。
Binder基于C/S架构：
Binder分为Java和C&#43;&#43;两套实现，分别用于Java应用和Native应用开发，Java Binder实际上也是基于C&#43;&#43; Binder的一个封装，因此本文只分析C&#43;&#43; Binder。
服务分为2种：Native Service、Android Service。
Native Service：是在系统init阶段通过init.rc脚本建立的服务，完全在C&#43;&#43;空间完成的服务。
Androids service：是系统二阶段（init2）初始化时建立的服务，是指在JVM空间完成的服务，虽然也要使用Navite上的框架，但是服务主体存在于Android空间，所有的Androids service都运行在一个进程中：systemsever进程。
实现原理
Binder本质上说就是一种数据传输方式，当通过服务代理调用服务对象的方法时，服务代理把参数序列化进行传输，服务对象反序列化取出参数，然后调用服务对象的方法。
进程间的通信是通过Android专门为Linux增加的一个设备（/dev/binder）来实现的。
本质上是使用了共享内存来进行通信，但该共享内存和我们平常理解会有一点不一样。
我们平常使用的共享内存是两个进程之间，即点到点的，如果有N个进程要两两通信而又不相互干扰，那么就必须有N*N个共享内存。Binder使用的共享内存是进程与binder设备之间，即binder做为一个中间者进行传递，类似会议电视的MCU。
使用了共享内存，在驱动中还是会有一次拷贝的，进程A向进程B传递数据时，数据会被驱动从进程A中拷贝到binder和进程B之间的共享内存中，然后进程B就可以直接读了。
通信过程：
所有要进行通信的进程都得打开/dev/binder设备
binder设备驱动会为每个进程分配一个数据结构binder_proc，每进程中的每个用到了binder通信的线程分配数据结构binder_thread。
binder设备驱动会为服务进程中的每个服务对象分配数据结构binder_node，它隶属于服务进程的binder_proc，是服务端相关的，binder_node中记录了服务对象在服务进程中的地址；会为客户进程中引用的每个服务分配binder_ref，是客户端相关的，binder_ref会指向客户进程引用的服务对象的binder_node。
binder设备驱动为客户进程引用的每个服务都会维护一个handle，它存在于binder_ref中（binder_ref.desc），它就像进程打开某个文件产生的文件描述符一样，进程每引用一个服务，就会分配一个最小未使用的整数作为handle。handle是客户进程相关的，多个进程引用同一个服务得到的handle并不是一样的。
当服务进程向ServiceManager注册服务时，会带上服务的名称字符串，驱动会为服务进程中的服务对象增加一个binder_node，归属于服务进程的binder_proc。
当把注册服务的请求发给ServiceManager时，ServiceManager也是服务对象的一个引用者，驱动会为ServiceManager增加一个binder_ref，指向服务对象的binder_node。驱动把binder_ref.desc（ServiceManager）作为handle返回给ServiceManager，ServiceManager保存此handle和服务名称字符串。
当客户进程向ServiceManager获取服务时，ServiceManager根据服务名称字符串找到服务对象在ServiceManager进程中的handle。在ServiceManager的应答的过程中，驱动根据此handle在ServiceManager进程的binder_proc找到对应的binder_ref，并根据它找到服务对象的binder_node。然后，驱动会为客户进程增加一个binder_ref，指向服务对象的binder_node，最后把binder_ref.desc（客户进程）作为handle返回给客户进程。
客户进程使用得到的handle向服务进程发起请求，驱动会在根据此handle在客户进程的binder_proc查找对应的binder_ref，并找到它指向的binder_node，并找到binder_node所属的binder_proc，最终驱动把请求放入服务进程的接收队列中。
服务进程收到请求后，从binder_node中找到服务对象的地址，然后调用该服务对象。所以，对于服务对象，在客户进程中表现出来的是handle，在服务进程中表现出来的是地址，驱动会对它们进行映射。
Binder框架
概览
框架的层次结构：
说明：
Bn代表服务端，Bp代表代理
ProcessState、IPCThreadState是进程、线程相关，是对Binder驱动的封装
Binder核心库又是对ProcessState、IPCThreadState的封装
C&#43;&#43; Binder框架是对Binder核心库和服务接口的封装
类关系图：
`
说明：绿色部分是用户编写应用程序需要实现的
IPCThreadState、ProcessState、Binder关系图：
对于Binder核心库：
IBinder：是一个接口，被BpBinder、Bbinder继承
BpBinder：客户端，内部有一个成员mHandle记录了远程服务对象的handle
BpRefBase：客户端，内部有一个成员指向BpBinder，采用的是Bridge设计模式，实际是是通过BpBinder来完成通信
Bbinder：服务端
对于C&#43;&#43; Binder框架：
Iinterface：主要是定义了asBinder()、纯虚函数onAsBinder()，asBinder()直接调用onAsBinder()，onAsBinder()分别在BnInterface、BpInterface中进行了实现，用于获取BnInterface、BpBinder的地址，即IInterface的作用是通过接口获取对应的Binder对象的本地地址/代理BpBinder的地址。
BpInterface&lt;XXX&gt;：是一个接口，一个模板类，是一个粘合类，即继承BpInterface&lt;XXX&gt;便等同于同时继承IXXX和BpRefBase。
BnInterface&lt;XXX&gt;：是一个接口，一个模板类，是一个粘合类
对于用户实现：
IXXX：是一个接口类，继承IInterface，定义服务的方法，即纯虚函数method_1()等，不能被实例化
BpXXX：是一个实现类，实现了IXXX中的纯虚函数，因为不是接口类，这个实现类不需要在接口中体现（即不需要在接口的头文件中体现，如：IMediaPlayer.h），它封装了IXXX的操作和BpBinder的操作；
BnXXX：仍是一个接口类，未实现IXXX中的纯虚函数，不能被实例化，需要一个真正工作的类来继承、实现它，这个类才是真正执行具体功能的类。BnXXX仅实现了虚函数onTransact()（在BBinder::transact()被调用）。
XXX：实现BnXXX，会有一个XXX::instantiate()函数来注册服务。
Binder驱动
源代码：
kernel\drivers\staging\android\binder.h
kernel\drivers\staging\android\binder.c
参见下文驱动源代码的分析
Binder Adapter
源代码：
frameworks\base\include\binder\IPCThreadState.h" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/ab8ec46be59983dd30566d0f1e23fd34/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-11-01T20:38:31+08:00" />
<meta property="article:modified_time" content="2013-11-01T20:38:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Binder详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:14px">深入分析<span style="font-family:Times New Roman">AndroidBinder</span>机制（远程对象访问）</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">介绍</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Binder</span>是什么？它可以叫作：<span style="background:yellow"><span style="font-family:Times New Roman">IPC</span></span><span style="background:yellow">、</span><span style="background:yellow"><span style="font-family:Times New Roman">RPC</span></span><span style="background:yellow">、线程迁移、远程对象访问</span>，本文中理解它为远程对象访问更贴切些，简而言之就是<span style="background:yellow">一个进程能访问另一个进程中的对象</span>，<span style="background:yellow">调用该对象的方法，就好像对象在自己的进程中一样，这种访问是同步的访问，当然</span><span style="background:yellow"><span style="font-family:Times New Roman">Binder</span></span><span style="background:yellow">也能实现异步的通信</span>。</p> 
<p><span style="font-family:Times New Roman; font-size:14px">Binder</span>基于<span style="font-family:Times New Roman">C/S</span>架构：</p> 
<p><img alt="" src="https://images2.imgbox.com/90/09/gvk4CSQm_o.png"></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Binder</span>分为<span style="font-family:Times New Roman">Java</span>和<span style="font-family:Times New Roman">C++</span>两套实现，分别用于<span style="font-family:Times New Roman">Java</span>应用和<span style="font-family:Times New Roman">Native</span>应用开发，<span style="font-family:Times New Roman">Java Binder</span>实际上也是基于<span style="font-family:Times New Roman">C++ Binder</span>的一个封装，因此本文只分析<span style="font-family:Times New Roman">C++ Binder</span>。</p> 
<p><span style="font-size:14px">服务分为<span style="font-family:Times New Roman">2</span>种：<span style="background:yellow"><span style="font-family:Times New Roman">Native Service</span></span><span style="background:yellow">、</span><span style="background:yellow"><span style="font-family:Times New Roman">Android Service</span></span><span style="background:yellow">。</span></span></p> 
<p><span style="font-size:14px"><span style="background:yellow"><span style="font-family:Times New Roman">Native Service</span></span><span style="background:yellow">：是在系统</span><span style="background:yellow"><span style="font-family:Times New Roman">init</span></span><span style="background:yellow">阶段通过</span><span style="background:yellow"><span style="font-family:Times New Roman">init.rc</span></span><span style="background:yellow">脚本建立的服务，完全在</span><span style="background:yellow"><span style="font-family:Times New Roman">C++</span></span><span style="background:yellow">空间完成的服务。</span></span></p> 
<p><span style="font-size:14px"><span style="background:yellow"><span style="font-family:Times New Roman">Androids service</span></span><span style="background:yellow">：是系统二阶段（</span><span style="background:yellow"><span style="font-family:Times New Roman">init2</span></span><span style="background:yellow">）初始化时建立的服务，是指在</span><span style="background:yellow"><span style="font-family:Times New Roman">JVM</span></span><span style="background:yellow">空间完成的服务，虽然也要使用</span><span style="background:yellow"><span style="font-family:Times New Roman">Navite</span></span><span style="background:yellow">上的框架，但是服务主体存在于</span><span style="background:yellow"><span style="font-family:Times New Roman">Android</span></span><span style="background:yellow">空间，所有的</span><span style="background:yellow"><span style="font-family:Times New Roman">Androids service</span></span><span style="background:yellow">都运行在一个进程中：</span><span style="background:yellow"><span style="font-family:Times New Roman">systemsever</span></span><span style="background:yellow">进程。</span></span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">实现原理</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Binder</span>本质上说就是一种<span style="background:yellow">数据传输</span>方式，当通过服务代理调用服务对象的方法时，服务代理把参数序列化进行传输，服务对象反序列化取出参数，然后调用服务对象的方法。</p> 
<p><span style="font-size:14px">进程间的通信是通过<span style="font-family:Times New Roman">Android</span>专门为<span style="font-family:Times New Roman">Linux</span><span style="background:yellow">增加的一个设备</span>（<span style="font-family:Times New Roman">/dev/binder</span>）来实现的。</span></p> 
<p><img alt="" src="https://images2.imgbox.com/7e/13/Wcc9QxLc_o.png"></p> 
<p><span style="font-size:14px">本质上是使用了<span style="background:yellow">共享内存来进行通信</span>，但该共享内存和我们平常理解会有一点不一样。</span></p> 
<p><span style="font-size:14px">我们平常使用的共享内存是两个进程之间，即点到点的，如果有<span style="font-family:Times New Roman">N</span>个进程要两两通信而又不相互干扰，那么就必须有<span style="font-family:Times New Roman">N*N</span>个共享内存。<span style="font-family:Times New Roman">Binder</span>使用的共享内存是进程与<span style="font-family:Times New Roman">binder</span>设备之间，即<span style="background:yellow"><span style="font-family:Times New Roman">binder</span></span><span style="background:yellow">做为一个中间者进行传递</span>，类似会议电视的<span style="font-family:Times New Roman">MCU</span>。</span></p> 
<p><span style="font-size:14px">使用了共享内存，在驱动中还是会有一次拷贝的，进程<span style="font-family:Times New Roman">A</span>向进程<span style="font-family:Times New Roman">B</span>传递数据时，<span style="background:yellow">数据会被驱动从进程</span><span style="background:yellow"><span style="font-family:Times New Roman">A</span></span><span style="background:yellow">中拷贝到</span><span style="background:yellow"><span style="font-family:Times New Roman">binder</span></span><span style="background:yellow">和进程</span><span style="background:yellow"><span style="font-family:Times New Roman">B</span></span><span style="background:yellow">之间的共享内存</span>中，然后进程<span style="font-family:Times New Roman">B</span>就可以直接读了。</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">通信过程：</span></p> 
<p><span style="font-size:14px">所有要进行通信的进程都得打开<span style="font-family:Times New Roman">/dev/binder</span>设备</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">binder</span>设备驱动会<span style="background:yellow">为每个进程分配一个数据结构</span><span style="background:yellow"><span style="font-family:Times New Roman">binder_proc</span></span>，每进程中的每个用到了<span style="font-family:Times New Roman">binder</span>通信的线程分配数据结构<span style="font-family:Times New Roman">binder_thread</span>。</p> 
<p><span style="font-family:Times New Roman; font-size:14px">binder</span>设备驱动会为服务进程中<span style="background:yellow">的每个服务对象分配数据结构</span><span style="background:yellow"><span style="font-family:Times New Roman">binder_node</span></span>，它隶属于服务进程的<span style="font-family:Times New Roman">binder_proc</span>，是服务端相关的，<span style="font-family:Times New Roman">binder_node</span>中记录了服务对象在服务进程中的地址；会为客户进程中引用的每个服务分配<span style="font-family:Times New Roman">binder_ref</span>，是客户端相关的，<span style="font-family:Times New Roman">binder_ref</span>会指向客户进程引用的服务对象的<span style="font-family:Times New Roman">binder_node</span>。</p> 
<p><span style="font-family:Times New Roman; font-size:14px">binder</span>设备驱动为客户进程引用的每个服务都会维护一个<span style="font-family:Times New Roman">handle</span>，它存在于<span style="font-family:Times New Roman">binder_ref</span>中（<span style="font-family:Times New Roman">binder_ref.desc</span>），它就像进程打开某个文件产生的文件描述符一样，进程每引用一个服务，就会分配一个最小未使用的整数作为<span style="font-family:Times New Roman">handle</span>。<span style="font-family:Times New Roman">handle</span>是客户进程相关的，多个进程引用同一个服务得到的<span style="font-family:Times New Roman">handle</span>并不是一样的。</p> 
<p><span style="font-size:14px">当服务进程向<span style="font-family:Times New Roman">ServiceManager</span>注册服务时，会带上服务的名称字符串，驱动会为服务进程中的服务对象增加一个<span style="font-family:Times New Roman">binder_node</span>，归属于服务进程的<span style="font-family:Times New Roman">binder_proc</span>。</span></p> 
<p><span style="font-size:14px">当把注册服务的请求发给<span style="font-family:Times New Roman">ServiceManager</span>时，<span style="font-family:Times New Roman">ServiceManager</span>也是服务对象的一个引用者，驱动会为<span style="font-family:Times New Roman">ServiceManager</span>增加一个<span style="font-family:Times New Roman">binder_ref</span>，指向服务对象的<span style="font-family:Times New Roman">binder_node</span>。驱动把<span style="font-family:Times New Roman">binder_ref.desc</span>（<span style="font-family:Times New Roman">ServiceManager</span>）作为<span style="font-family:Times New Roman">handle</span>返回给<span style="font-family:Times New Roman">ServiceManager</span>，<span style="font-family:Times New Roman">ServiceManager</span>保存此<span style="font-family:Times New Roman">handle</span>和服务名称字符串。</span></p> 
<p><span style="font-size:14px">当客户进程向<span style="font-family:Times New Roman">ServiceManager</span>获取服务时，<span style="font-family:Times New Roman">ServiceManager</span>根据服务名称字符串找到服务对象在<span style="font-family:Times New Roman">ServiceManager</span>进程中的<span style="font-family:Times New Roman">handle</span>。在<span style="font-family:Times New Roman">ServiceManager</span>的应答的过程中，驱动根据此<span style="font-family:Times New Roman">handle</span>在<span style="font-family:Times New Roman">ServiceManager</span>进程的<span style="font-family:Times New Roman">binder_proc</span>找到对应的<span style="font-family:Times New Roman">binder_ref</span>，并根据它找到服务对象的<span style="font-family:Times New Roman">binder_node</span>。然后，驱动会为客户进程增加一个<span style="font-family:Times New Roman">binder_ref</span>，指向服务对象的<span style="font-family:Times New Roman">binder_node</span>，最后把<span style="font-family:Times New Roman">binder_ref.desc</span>（客户进程）作为<span style="font-family:Times New Roman">handle</span>返回给客户进程。</span></p> 
<p><span style="font-size:14px">客户进程使用得到的<span style="font-family:Times New Roman">handle</span>向服务进程发起请求，驱动会在根据此<span style="font-family:Times New Roman">handle</span>在客户进程的<span style="font-family:Times New Roman">binder_proc</span>查找对应的<span style="font-family:Times New Roman">binder_ref</span>，并找到它指向的<span style="font-family:Times New Roman">binder_node</span>，并找到<span style="font-family:Times New Roman">binder_node</span>所属的<span style="font-family:Times New Roman">binder_proc</span>，最终驱动把请求放入服务进程的接收队列中。</span></p> 
<p><span style="font-size:14px">服务进程收到请求后，从<span style="font-family:Times New Roman">binder_node</span>中找到服务对象的地址，然后调用该服务对象。所以，对于服务对象，在客户进程中表现出来的是<span style="font-family:Times New Roman">handle</span>，在服务进程中表现出来的是地址，驱动会对它们进行映射。</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Binder</span>框架</p> 
<p><span style="font-size:14px">概览</span></p> 
<p><span style="font-size:14px">框架的层次结构：</span></p> 
<p><img alt="" src="https://images2.imgbox.com/6c/1f/X7WeZ4oU_o.png"></p> 
<p><span style="font-size:14px">说明：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Bn</span>代表服务端，<span style="font-family:Times New Roman">Bp</span>代表代理</p> 
<p><span style="font-family:Times New Roman; font-size:14px">ProcessState</span>、<span style="font-family:Times New Roman">IPCThreadState</span>是进程、线程相关，是对<span style="font-family:Times New Roman">Binder</span>驱动的封装</p> 
<p><span style="font-family:Times New Roman; font-size:14px">Binder</span>核心库又是对<span style="font-family:Times New Roman">ProcessState</span>、<span style="font-family:Times New Roman">IPCThreadState</span>的封装</p> 
<p><span style="font-family:Times New Roman; font-size:14px">C++ Binder</span>框架是对<span style="font-family:Times New Roman">Binder</span>核心库和服务接口的封装</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">类关系图：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">`</span></p> 
<p><span style="font-size:14px">说明：绿色部分是用户编写应用程序需要实现的</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">IPCThreadState</span>、<span style="font-family:Times New Roman">ProcessState</span>、<span style="font-family:Times New Roman">Binder</span>关系图：</p> 
<p></p> 
<p><span style="font-family:宋体; font-size:14px"> <img alt="" src="https://images2.imgbox.com/b7/65/P0UuyIAd_o.png"></span></p> 
<p><span style="font-size:14px">对于<span style="font-family:Times New Roman">Binder</span>核心库：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">IBinder</span>：是一个接口，被<span style="font-family:Times New Roman">BpBinder</span>、<span style="font-family:Times New Roman">Bbinder</span>继承</p> 
<p><span style="font-family:Times New Roman; font-size:14px">BpBinder</span>：客户端，内部有一个成员<span style="font-family:Times New Roman">mHandle</span>记录了远程服务对象的<span style="font-family:Times New Roman">handle</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">BpRefBase</span>：客户端，内部有一个成员指向<span style="font-family:Times New Roman">BpBinder</span>，采用的是<span style="font-family:Times New Roman">Bridge</span>设计模式，实际是是通过<span style="font-family:Times New Roman">BpBinder</span>来完成通信</p> 
<p><span style="font-family:Times New Roman; font-size:14px">Bbinder</span>：服务端</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">对于<span style="font-family:Times New Roman">C++ Binder</span>框架：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Iinterface</span>：主要是定义了<span style="font-family:Times New Roman">asBinder()</span>、纯虚函数<span style="font-family:Times New Roman">onAsBinder()</span>，<span style="font-family:Times New Roman">asBinder()</span>直接调用<span style="font-family:Times New Roman">onAsBinder()</span>，<span style="font-family:Times New Roman">onAsBinder()</span>分别在<span style="font-family:Times New Roman">BnInterface</span>、<span style="font-family:Times New Roman">BpInterface</span>中进行了实现，用于获取<span style="font-family:Times New Roman">BnInterface</span>、<span style="font-family:Times New Roman">BpBinder</span>的地址，即<span style="font-family:Times New Roman">IInterface</span>的作用是通过接口获取对应的<span style="font-family:Times New Roman">Binder</span>对象的本地地址<span style="font-family:Times New Roman">/</span>代理<span style="font-family:Times New Roman">BpBinder</span>的地址。</p> 
<p><span style="font-family:Times New Roman; font-size:14px">BpInterface&lt;XXX&gt;</span>：是一个接口，一个模板类，是一个粘合类，即继承<span style="font-family:Times New Roman">BpInterface&lt;XXX&gt;</span>便等同于同时继承<span style="font-family:Times New Roman">IXXX</span>和<span style="font-family:Times New Roman">BpRefBase</span>。</p> 
<p><span style="font-family:Times New Roman; font-size:14px">BnInterface&lt;XXX&gt;</span>：是一个接口，一个模板类，是一个粘合类</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">对于用户实现：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">IXXX</span>：是一个接口类，继承<span style="font-family:Times New Roman">IInterface</span>，定义服务的方法，即纯虚函数<span style="font-family:Times New Roman">method_1()</span>等，不能被实例化</p> 
<p><span style="font-family:Times New Roman; font-size:14px">BpXXX</span>：是一个实现类，实现了<span style="font-family:Times New Roman">IXXX</span>中的纯虚函数，因为不是接口类，这个实现类不需要在接口中体现（即不需要在接口的头文件中体现，如：<span style="font-family:Times New Roman">IMediaPlayer.h</span>），它封装了<span style="font-family:Times New Roman">IXXX</span>的操作和<span style="font-family:Times New Roman">BpBinder</span>的操作；</p> 
<p><span style="font-family:Times New Roman; font-size:14px">BnXXX</span>：仍是一个接口类，未实现<span style="font-family:Times New Roman">IXXX</span>中的纯虚函数，不能被实例化，需要一个真正工作的类来继承、实现它，这个类才是真正执行具体功能的类。<span style="font-family:Times New Roman">BnXXX</span>仅实现了虚函数<span style="font-family:Times New Roman">onTransact()</span>（在<span style="font-family:Times New Roman">BBinder::transact()</span>被调用）。</p> 
<p><span style="font-family:Times New Roman; font-size:14px">XXX</span>：实现<span style="font-family:Times New Roman">BnXXX</span>，会有一个<span style="font-family:Times New Roman">XXX::instantiate()</span>函数来注册服务。</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Binder</span>驱动</p> 
<p><span style="font-size:14px">源代码：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">kernel\drivers\staging\android\binder.h</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">kernel\drivers\staging\android\binder.c</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">参见下文驱动源代码的分析</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Binder Adapter</span></p> 
<p><span style="font-size:14px">源代码：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\include\binder\IPCThreadState.h</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\include\binder\ProcessState.h</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\libs\binder\IPCThreadState.cpp</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\libs\binder\ProcessState.cpp</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">ProcessState</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">一个进程只有一个<span style="font-family:Times New Roman">ProcessState</span>对象，主要用于打开<span style="font-family:Times New Roman">/dev/binder</span>，设置设备支持的最大线程数，进行内存映射，把<span style="font-family:Times New Roman">binder</span>设备文件的句柄保存在<span style="font-family:Times New Roman">mDriverFD</span>以供<span style="font-family:Times New Roman">IPCThreadState</span>使用。维护进程中所有的<span style="font-family:Times New Roman">Service</span>代理（<span style="font-family:Times New Roman">BpBinder</span>对象）和其对应的<span style="font-family:Times New Roman">handle</span>（<span style="font-family:Times New Roman">Binder</span>驱动为每个<span style="font-family:Times New Roman">Service</span>维护一个<span style="font-family:Times New Roman">handle</span>，对<span style="font-family:Times New Roman">handle</span>的操作封装在<span style="font-family:Times New Roman">ProcessState</span>中维护的<span style="font-family:Times New Roman">BpBinder</span>对象中）</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">ProcessState</span>是<span style="font-family:Times New Roman">singleton</span>模式，使用静态成员函数<span style="font-family:Times New Roman">ProcessState::self()</span>来构造。</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">构造函数：</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">ProcessState::ProcessState()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     mDriverFD(open_driver())  //</span>打开<span style="font-family:Times New Roman">binder</span>设备</p> <p><span style="font-family:Times New Roman; font-size:14px">        open("/dev/binder", O_RDWR);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">       ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);  //</span>最大线程数设为<span style="font-family:Times New Roman">15</span>，保存在<span style="font-family:Times New Roman">binder_proc.max_threads</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE |  MAP_NORESERVE, mDriverFD, 0); //</span>内存映射，只读，用于接收<span style="font-family:Times New Roman">transactions</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">ProcessState::getStrongProxyForHandle()</span></p> 
<p><span style="font-size:14px">作用：为<span style="font-family:Times New Roman">Service</span>的<span style="font-family:Times New Roman">handle</span>创建<span style="font-family:Times New Roman">BpBinder</span>对象。主要在<span style="font-family:Times New Roman">Parcel::readStrongBinder()</span>、<span style="font-family:Times New Roman">ProcessState::getContextObject()</span>中调用。</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t  handle)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     sp&lt;IBinder&gt; result;</span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">     AutoMutex _l(mLock);     //</span>互斥锁，在<span style="font-family:Times New Roman">ProcessState::expungeHandle()</span>也有调用</p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">// </span>查询<span style="font-family:Times New Roman">Service</span>代理对象列表，如果未代理对象未创建，将在列表中增加相应位置，以保存下面将要创建的代理对象</p> <p><span style="font-family:Times New Roman; font-size:14px">handle_entry* e = lookupHandleLocked(handle);</span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">     if (e != NULL) {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">         // 1</span>、<span style="font-family:Times New Roman">BpBinder</span>对象在创建时设置了<span style="font-family:Times New Roman">RefBase</span>标志：<span style="font-family:Times New Roman">OBJECT_LIFETIME_WEAK</span>。并且重写了<span style="font-family:Times New Roman">RefBase</span>的虚方法：<span style="font-family:Times New Roman">onFirstRef()</span>、<span style="font-family:Times New Roman">onLastStrongRef()</span>。</p> <p><span style="font-family:Times New Roman; font-size:14px">         // 2</span>、创建的<span style="font-family:Times New Roman">BpBinder</span>对象在该函数中，只是记录它的地址和它的引用记录的地址，未记录下它的强引用<span style="font-family:Times New Roman">/</span>弱引用</p> <p><span style="font-family:Times New Roman; font-size:14px">         // 3</span>、调用<span style="font-family:Times New Roman">attemptIncWeak()</span>是安全的，假设<span style="font-family:Times New Roman">BpBinder</span>对象因为弱引用计数减为<span style="font-family:Times New Roman">0</span>而调用<span style="font-family:Times New Roman">BpBinder</span>析构函数（参见：<span style="font-family:Times New Roman">RefBase::weakref_type::decWeak()</span>），该析构函数中要调用<span style="font-family:Times New Roman">ProcessState::expungeHandle()</span>，而<span style="font-family:Times New Roman">expungeHandle()</span>要获取本函数中相同的互斥锁<span style="font-family:Times New Roman">mLock</span>，然后把<span style="font-family:Times New Roman">e-&gt;binder</span>置为<span style="font-family:Times New Roman">NULL</span>。所以，如果下面的代码<span style="font-family:Times New Roman">e-&gt;binder</span>不为<span style="font-family:Times New Roman">NULL</span>，<span style="font-family:Times New Roman">expungeHandle()</span>也无法执行把它置成<span style="font-family:Times New Roman">NULL</span>，析构函数也就无法完成，对象的空间也不会释放，<span style="font-family:Times New Roman">e-&gt;refs</span>指向的空间就是有效的。但此时对象的引用计数可能为<span style="font-family:Times New Roman">0</span>，这样调用<span style="font-family:Times New Roman">attemptIncWeak()</span>会失败，当析构函数完成后，对象的空间会被释放，所以就要重新创建一个对象。</p> <p><span style="font-family:Times New Roman; font-size:14px">         IBinder* b = e-&gt;binder;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) { //</span>如果弱引用计数为<span style="font-family:Times New Roman">0</span>，则<span style="font-family:Times New Roman">attemptIncWeak()</span>返回失败</p> <p><span style="font-family:Times New Roman; font-size:14px">            b = new BpBinder(handle);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            e-&gt;binder = b;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            if (b) e-&gt;refs = b-&gt;getWeakRefs();   // e-&gt;refs</span>是<span style="font-family:Times New Roman">e-&gt;binder</span>的引用记录的地址</p> <p><span style="font-family:Times New Roman; font-size:14px">            result = b;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         } else {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">            // This little bit of nastyness  is to allow us to add a primary</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            // reference to the remote proxy  when this team doesn't have one</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            // but another team is sending  the handle to us.</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            result.force_set(b);     //</span>调用的是<span style="font-family:Times New Roman"> RefBase::forceIncStrong()</span>，其中会调用<span style="font-family:Times New Roman">BpBinder</span>重写的<span style="font-family:Times New Roman">onFirstRef()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            e-&gt;refs-&gt;decWeak(this);  //</span>抵消上面的<span style="font-family:Times New Roman">e-&gt;refs-&gt;attemptIncWeak()</span>的增加</p> <p><span style="font-family:Times New Roman; font-size:14px">         }</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     }</span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">     return result;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">ProcessState::startThreadPool()</span></p> 
<p><span style="font-size:14px">只启动一次，它直接调用<span style="font-family:Times New Roman">ProcessState::spawnPooledThread(true)</span>，创建<span style="font-family:Times New Roman">PoolThread</span>对象并调用<span style="font-family:Times New Roman">PoolThread::run()</span>（实际上就创建了一个线程，没看到线程池的概念），<span style="font-family:Times New Roman">PoolThread</span>继承自<span style="font-family:Times New Roman">Thread</span>，实际上调用的是<span style="font-family:Times New Roman">Thread::run()</span>，其中创建线程函数<span style="font-family:Times New Roman">_threadLoop()</span>，其中调用<span style="font-family:Times New Roman">PoolThread::threadLoop()</span>，其中调用<span style="font-family:Times New Roman">IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</span>，此处<span style="font-family:Times New Roman">mIsMain==true</span>，即表示进入<span style="font-family:Times New Roman">looper</span></span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">IPCThreadState</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">每个线程都有一个<span style="font-family:Times New Roman">IPCThreadState</span>对象，它有一个成员变量<span style="font-family:Times New Roman">mProcess</span>指向它所属的<span style="font-family:Times New Roman">ProcessState</span>对象，它主要负责<span style="font-family:Times New Roman">Binder</span>数据读写和命令处理，客户端调用<span style="font-family:Times New Roman">transact()</span>，服务端调用<span style="font-family:Times New Roman">joinThreadPool()</span>。</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">IPCThreadState</span>是<span style="font-family:Times New Roman">singleton</span>模式，使用静态成员函数<span style="font-family:Times New Roman">IPCThreadState::self()</span>来构造。</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">构造函数：</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">IPCThreadState::IPCThreadState()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     mProcess(ProcessState::self())</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     mMyThreadId(androidGetTid())       //</span>调用<span style="font-family:Times New Roman">gettid()</span>或<span style="font-family:Times New Roman">getpid()</span>，返回<span style="font-family:Times New Roman">pid_t</span>，所以线程也是当成轻量级里程看待的</p> <p><span style="font-family:Times New Roman; font-size:14px">     pthread_setspecific(gTLS, this);   //</span>设置线程私有数据，把<span style="font-family:Times New Roman">IPCThreadState</span>关联到全局静态变量<span style="font-family:Times New Roman">gTLS</span>（<span style="font-family:Times New Roman">Thread Local Storage</span>），而<span style="font-family:Times New Roman">gTLS</span>在<span style="font-family:Times New Roman">IPCThreadState::self()</span>中创建和获取，与<span style="font-family:Times New Roman">gTLS</span>关联的私有数据释放函数为<span style="font-family:Times New Roman">IPCThreadState::threadDestructor()</span>，当线程退出时调用该函数，其中又调用<span style="font-family:Times New Roman">ioctl(self-&gt;mProcess-&gt;mDriverFD,  BINDER_THREAD_EXIT, 0);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">transact()</span>：<span style="font-family:Times New Roman">BpBinder</span>实际上调用的是<span style="font-family:Times New Roman">IPCThreadState::transact()</span>，先调用<span style="font-family:Times New Roman">writeTransactionData()</span>构造数据，再调用<span style="font-family:Times New Roman">waitForResponse()</span>写入数据并等待应答</p> 
<p><span style="font-family:Times New Roman; font-size:14px">talkWithDriver()</span>：读取<span style="font-family:Times New Roman">/</span>写入，调用<span style="font-family:Times New Roman">ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</span>，把<span style="font-family:Times New Roman">IPCThreadState::mOut</span>（<span style="font-family:Times New Roman">Parcel</span>）中包含的<span style="font-family:Times New Roman">binder_transaction_data</span>封装成<span style="font-family:Times New Roman">binder_write_read</span>写到驱动，从驱动读取到的<span style="font-family:Times New Roman">binder_write_read</span>中包含的<span style="font-family:Times New Roman">binder_transaction_data</span>写到<span style="font-family:Times New Roman">IPCThreadState::mIn</span>（<span style="font-family:Times New Roman">Parcel</span>）</p> 
<p><span style="font-family:Times New Roman; font-size:14px">executeCommand()</span>：<span style="font-family:Times New Roman">BR_***</span>命令处理，对于<span style="font-family:Times New Roman">BR_TRANSACTION</span>，会调用<span style="font-family:Times New Roman">BBinder::transact()</span>。在<span style="font-family:Times New Roman">joinThreadPool()</span>、<span style="font-family:Times New Roman">waitForResponse()</span>中调用</p> 
<p><span style="font-family:Times New Roman; font-size:14px">joinThreadPool()</span>：循环结构，调用<span style="font-family:Times New Roman">talkWithDriver()</span>读取命令，然后调用<span style="font-family:Times New Roman">executeCommand()</span>处理。函数名为加入线程池，更准确地说是调用<span style="font-family:Times New Roman">binder_get_thread()</span>在进程的内核数据中分配了一个<span style="font-family:Times New Roman">binder_thread</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">writeTransactionData()</span>：把用户的<span style="font-family:Times New Roman">Parcel</span>先转换成<span style="font-family:Times New Roman">binder_transaction_data</span>，再把<span style="font-family:Times New Roman">binder_transaction_data</span>写入<span style="font-family:Times New Roman">IPCThreadState::mOut</span>（也是<span style="font-family:Times New Roman">Parcel</span>），仅用来构造<span style="font-family:Times New Roman">mOut</span>。在<span style="font-family:Times New Roman">transact()</span>、<span style="font-family:Times New Roman">sendReply()</span>中调用</p> 
<p><span style="font-family:Times New Roman; font-size:14px">waitForResponse()</span>：写入命令并等待应答，先调用<span style="font-family:Times New Roman">talkWithDriver()</span>写入<span style="font-family:Times New Roman">/</span>读取，然后再处理<span style="font-family:Times New Roman">BR_***</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Binder</span>核心库</p> 
<p><span style="font-size:14px">源代码：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\include\binder\Binder.h</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\include\binder\BpBinder.h</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\include\binder\IBinder.h</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\libs\binder\Binder.cpp</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\libs\binder\BpBinder.cpp</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">BpBinder</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">在<span style="font-family:Times New Roman">ProcessState::getStrongProxyForHandle()</span>创建，创建时会记录下<span style="font-family:Times New Roman">Service</span>的<span style="font-family:Times New Roman">handle</span>，并增加句柄的引用计数（<span style="font-family:Times New Roman">IPCThreadState::self()-&gt;incWeakHandle(handle);</span>）</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">构造函数</span></p> 
<p><span style="font-size:14px">参数为服务的<span style="font-family:Times New Roman">handle</span></span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">BpBinder::BpBinder(int32_t handle)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     : mHandle(handle)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     extendObjectLifetime(OBJECT_LIFETIME_WEAK); </span></p> <p><span style="font-family:Times New Roman; font-size:14px">     IPCThreadState::self()-&gt;incWeakHandle(handle); </span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:Times New Roman; font-size:14px">       IPCThreadState::incWeakHandle()</span>就是向驱动写入了一个<span style="font-family:Times New Roman">BC_INCREFS</span>命令。</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">BpBinder::transact()</span></p> 
<p><span style="font-size:14px">向服务端发送数据，实际上是调用<span style="font-family:Times New Roman">IPCThreadState::transact()</span>来实现。</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">BpBinder::transact()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">IPCThreadState::self()-&gt;transact(mHandle,...)     // mHandle</span>在<span style="font-family:Times New Roman">ProcessState::getStrongProxyForHandle()</span>创建<span style="font-family:Times New Roman">BpBinder</span>时设置</p> <p><span style="font-family:Times New Roman; font-size:14px">IPCThreadState::writeTransactionData(BC_TRANSACTION,...)    //</span>构造写入数据</p> <p><span style="font-family:Times New Roman; font-size:14px">            IPCThreadState::waitForResponse()                      //</span>写入命令并等待应答</p> <p><span style="font-family:Times New Roman; font-size:14px">                 IPCThreadState::talkWithDriver                       //</span>写入和读取</p> <p><span style="font-family:Times New Roman; font-size:14px">                  ioctl(mProcess-&gt;mDriverFD,  BINDER_WRITE_READ, &amp;bwr)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">              // </span> 处理<span style="font-family:Times New Roman">BR_REPLY,...</span>等命令</p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">BpRefBase</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">采用<span style="font-family:Times New Roman">Bridge</span>设计模式，它的构造函数中有一个参数<span style="font-family:Times New Roman">sp&lt;IBinder&gt;</span>，它有一个成员<span style="font-family:Times New Roman">mRemote</span>指向<span style="font-family:Times New Roman">BpBinder</span>，实际的通信工作是通过<span style="font-family:Times New Roman">BpBinder</span>来完成的。</span></p> 
<p><span style="font-size:14px">对于一个服务对象，在进程中只有一个<span style="font-family:Times New Roman">BpBinder</span>，但可以有多个<span style="font-family:Times New Roman">BpRefBase</span>引用这个<span style="font-family:Times New Roman">BpBinder</span></span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">构造函数</span></p> 
<p><span style="font-size:14px">参数为<span style="font-family:Times New Roman">BpBinder</span></span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">BpRefBase::BpRefBase(const sp&lt;IBinder&gt;&amp;  o)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     : mRemote(o.get()), mRefs(NULL), mState(0)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     if (mRemote) {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">         mRemote-&gt;incStrong(this);            // Removed on first IncStrong().</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         mRefs = mRemote-&gt;createWeak(this);   // Held for our entire lifetime.</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     }</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">BBinder</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">IPCThreadState</span>收到请求后，调用<span style="font-family:Times New Roman">IPCThreadState::executeCommand()</span>处理请求，其中会调用服务对象的<span style="font-family:Times New Roman">BBinder::transact()</span>方法，<span style="font-family:Times New Roman">BBinder::transact()</span>中又继续调用<span style="font-family:Times New Roman">BBinder</span>派生类<span style="font-family:Times New Roman">BnXXX</span>重写的<span style="font-family:Times New Roman">onTransact()</span>方法</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Parcel</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Parcel</span>顾名思义：邮包，即是应用程序通过<span style="font-family:Times New Roman">binder</span>通信所使用的数据容器。</p> 
<p><span style="font-size:14px">两个重要的函数：<span style="font-family:Times New Roman">Parcel::writeStrongBinder()</span>、<span style="font-family:Times New Roman">Parcel::readStrongBinder()</span>，它们中会调用<span style="font-family:Times New Roman">ProcessState::self()</span>打开设备</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Parcel::writeStrongBinder(constsp&lt;IBinder&gt;&amp; val)</span></p> 
<p><span style="font-size:14px">发送请求时，将<span style="font-family:Times New Roman">binder</span>信息写入<span style="font-family:Times New Roman">Parcel</span></span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">Parcel::writeStrongBinder()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">//</span>输入<span style="font-family:Times New Roman">BpBinder</span>或<span style="font-family:Times New Roman">BBinder</span>，构造<span style="font-family:Times New Roman">flat_binder_object</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     flat_binder_object obj;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     flatten_binder(ProcessState::self(), val, this);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         IBinder *local = binder-&gt;localBinder();         // localBinder()</span>被<span style="font-family:Times New Roman">IBinder</span>定义且实现（返回<span style="font-family:Times New Roman">NULL</span>），被<span style="font-family:Times New Roman">BBinder</span>重写（返回<span style="font-family:Times New Roman">this</span>）</p> <p><span style="font-family:Times New Roman; font-size:14px">         if (!local) {     //</span>参数是<span style="font-family:Times New Roman">BpBinder</span>，传递服务代理信息，客户端<span style="font-family:Times New Roman">A</span>把它得到的服务对象的<span style="font-family:Times New Roman">BpBinder</span>告诉客户端<span style="font-family:Times New Roman">B</span>，客户端<span style="font-family:Times New Roman">B</span>不查询<span style="font-family:Times New Roman">ServiceManager</span>也能使用服务，实现服务信息共享</p> <p><span style="font-family:Times New Roman; font-size:14px">            BpBinder *proxy = binder-&gt;remoteBinder();   // remoteBinder()</span>被<span style="font-family:Times New Roman">IBinder</span>定义且实现（返回<span style="font-family:Times New Roman">NULL</span>），被<span style="font-family:Times New Roman">BpBinder</span>重写（返回<span style="font-family:Times New Roman">this</span>）</p> <p><span style="font-family:Times New Roman; font-size:14px">            const int32_t handle = proxy ?  proxy-&gt;handle() : 0;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            obj.type = BINDER_TYPE_HANDLE;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            obj.handle = handle;     //</span>服务对象的<span style="font-family:Times New Roman">handle</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            obj.cookie = NULL;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         } else {          //</span>参数是<span style="font-family:Times New Roman">BBinder</span>，传递服务对象信息</p> <p><span style="font-family:Times New Roman; font-size:14px">            obj.type = BINDER_TYPE_BINDER;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            obj.binder = local-&gt;getWeakRefs();  //</span>服务对象的引用记录的地址</p> <p><span style="font-family:Times New Roman; font-size:14px">            obj.cookie = local;      //</span>服务对象的地址</p> <p><span style="font-family:Times New Roman; font-size:14px">         }</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         finish_flatten_binder()      //</span>把<span style="font-family:Times New Roman">flat_binder_object</span>写到<span style="font-family:Times New Roman">Parcel.mObjects</span>缓冲区，在驱动传输的过程中（<span style="font-family:Times New Roman">binder_transaction()</span>），为创建<span style="font-family:Times New Roman">binder_node</span>、<span style="font-family:Times New Roman">binder_ref</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            Parcel::writeObject()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Parcel::readStrongBinder()</span></p> 
<p><span style="font-size:14px">接收应答时，从<span style="font-family:Times New Roman">Parcel</span>取出<span style="font-family:Times New Roman">binder</span>信息</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">Parcel::readStrongBinder()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">//</span>返回<span style="font-family:Times New Roman">BpBinder</span>或<span style="font-family:Times New Roman">BBinder</span>，会把<span style="font-family:Times New Roman">handle</span>转换成<span style="font-family:Times New Roman">BpBinder</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     unflatten_binder(ProcessState::self(), *this, &amp;val);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         Parcel::readObject()              //</span>从<span style="font-family:Times New Roman">Parcel.mObjects</span>缓冲区读取<span style="font-family:Times New Roman">flat_binder_object</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         switch (flat-&gt;type) {             //</span>读取结构<span style="font-family:Times New Roman">  flat_binder_object</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            case BINDER_TYPE_BINDER:     //</span>客户端和服务在同一进程，返回<span style="font-family:Times New Roman">BBinder</span></p> <p><span style="font-family:Times New Roman; font-size:14px">                *out = static_cast&lt;IBinder*&gt;(flat-&gt;cookie);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            case BINDER_TYPE_HANDLE:     //</span>客户端和服务不在同一进程，返回<span style="font-family:Times New Roman">BpBinder</span></p> <p><span style="font-family:Times New Roman; font-size:14px">                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">C++ Binder</span>框架</p> 
<p><span style="font-size:14px">源代码：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\include\binder\IInterface.h</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\include\binder\Parcel.h</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\libs\binder\IInterface.cpp</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\libs\binder\Parcel.cpp</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">IInterface</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">IInterface::asBinder()</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">asBinder()</span>直接调用纯虚函数<span style="font-family:Times New Roman">IInterface::onAsBinder()</span>，<span style="font-family:Times New Roman">onAsBinder()</span>分别在<span style="font-family:Times New Roman">BnInterface</span>、<span style="font-family:Times New Roman">BpInterface</span>中进行了实现，用于获取<span style="font-family:Times New Roman">BnInterface</span>、<span style="font-family:Times New Roman">BpBinder</span>的地址，即<span style="font-family:Times New Roman">IInterface</span>的作用是通过接口获取对应的<span style="font-family:Times New Roman">Binder</span>对象的本地地址<span style="font-family:Times New Roman">/</span>代理<span style="font-family:Times New Roman">BpBinder</span>的地址</p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">sp&lt;IBinder&gt; IInterface::asBinder()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     return this ? onAsBinder() : NULL;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">template&lt;typename INTERFACE&gt;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">IBinder* BnInterface&lt;INTERFACE&gt;::onAsBinder()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     return this;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">template&lt;typename INTERFACE&gt;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">inline IBinder* BpInterface&lt;INTERFACE&gt;::onAsBinder()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     return remote();</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">BpInterface&lt;XXX&gt;</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">构造函数</span></p> 
<p><span style="font-size:14px">参数为<span style="font-family:Times New Roman">BpBinder</span></span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">template&lt;typename INTERFACE&gt;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">inline BpInterface&lt;INTERFACE&gt;::BpInterface(const  sp&lt;IBinder&gt;&amp; remote)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     : BpRefBase(remote)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">interface_cast&lt;XXX&gt;(constsp&lt;IBinder&gt;&amp; obj)</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">看名字就知道它是一个进行类型转换的函数，前面根据<span style="font-family:Times New Roman">handle</span>创建了<span style="font-family:Times New Roman">BpBinder</span>，进而创建了<span style="font-family:Times New Roman">BpBinder</span>，接下来就是要利用模板函数<span style="font-family:Times New Roman">interface_cast&lt;XXX&gt;()</span>根据<span style="font-family:Times New Roman">BpBinder</span>创建<span style="font-family:Times New Roman">BpXXX</span>。</span></p> 
<p><span style="font-size:14px">函数的参数可以是<span style="font-family:Times New Roman">BpBinder</span>或<span style="font-family:Times New Roman">BBinder</span>，返回的是<span style="font-family:Times New Roman">BpXXX</span>或<span style="font-family:Times New Roman">BnXXX</span>。</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">template&lt;typename INTERFACE&gt;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">inline sp&lt;INTERFACE&gt; interface_cast(const  sp&lt;IBinder&gt;&amp; obj)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     return INTERFACE::asInterface(obj);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:Times New Roman; font-size:14px">       </span>函数直接调用了<span style="font-family:Times New Roman">IXXX::asInterface()</span>，它是通过宏<span style="font-family:Times New Roman">DECLARE_META_INTERFACE</span>、<span style="font-family:Times New Roman">IMPLEMENT_META_INTERFACE</span>来声明和实现的。</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">DECLARE_META_INTERFACE</span>、<span style="font-family:Times New Roman">IMPLEMENT_META_INTERFACE</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">在<span style="font-family:Times New Roman">IXXX</span>类的声明中，调用<span style="font-family:Times New Roman">DECLARE_META_INTERFACE(XXX);</span>，在<span style="font-family:Times New Roman">IXXX</span>类的实现中，调用<span style="font-family:Times New Roman">IMPLEMENT_META_INTERFACE(XXX, "</span>接口名称<span style="font-family:Times New Roman">");</span></span></p> 
<p><span style="font-size:14px">其中关键的实现为：</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">#define  IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     ...</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(                \</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            const android::sp&lt;android::IBinder&gt;&amp;  obj)                   \</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     {                                                                    \</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         android::sp&lt;I##INTERFACE&gt; intr;                                 \</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         if (obj != NULL) {                                              \</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            intr = static_cast&lt;I##INTERFACE*&gt;(                          \</span></p> <p><span style="font-family:Times New Roman; font-size:14px">                obj-&gt;queryLocalInterface(                               \</span></p> <p><span style="font-family:Times New Roman; font-size:14px">                        I##INTERFACE::descriptor).get());               \</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            if (intr == NULL) {                                         \</span></p> <p><span style="font-family:Times New Roman; font-size:14px">                intr = new Bp##INTERFACE(obj);                          \</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            }                                                            \</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         }                                                               \</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         return intr;                                                     \</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     }                                                                    \</span></p> </td></tr></tbody></table> 
<p><span style="font-size:14px">注释：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">IBinder</span>定义并实现了虚函数<span style="font-family:Times New Roman">queryLocalInterface()</span>（为空函数直接返回<span style="font-family:Times New Roman">NULL</span>），<span style="font-family:Times New Roman">BpBinder</span>继承<span style="font-family:Times New Roman">IBinder</span>但未重写该虚函数，<span style="font-family:Times New Roman">BnInterface</span>继承<span style="font-family:Times New Roman">BBinder</span>继承<span style="font-family:Times New Roman">IBinder</span>，重写了该函数（<span style="font-family:Times New Roman">if (_descriptor ==INTERFACE::descriptor) return this;</span>），所以，如果<span style="font-family:Times New Roman">asInterface()</span>的参数为<span style="font-family:Times New Roman">BpBinder</span>，那么每次调用都会创建一个<span style="font-family:Times New Roman">BpXXX</span>，如果参数为<span style="font-family:Times New Roman">BBinder</span>，只是直接返回<span style="font-family:Times New Roman">BBinder</span>对象的地址，作用是在同一个进程中调用<span style="font-family:Times New Roman">Binder</span>将直接得到<span style="font-family:Times New Roman">BBinder</span>对象的地址。调用者无需要关心调用的对象是远程的还是本地的</p> 
<p><span style="font-size:14px">参数<span style="font-family:Times New Roman">NAME</span>只是接口的名字，无实质作用，和服务的名字不是一回事</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">实现服务</span></p> 
<p><span style="font-size:14px">参考代码：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\include\media\IMediaPlayerService.h</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmedia\IMediaPlayerService.cpp</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmediaplayerservice\MediaPlayerService.h</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmediaplayerservice\MediaPlayerService.cpp</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">编码</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">IXXX.h</span>：</p> 
<p><span style="font-size:14px">定义<span style="font-family:Times New Roman">class IXXX:public IInterface</span>：</span><br> <span style="font-size:14px">调用宏<span style="font-family:Times New Roman">DECLARE_META_INTERFACE(XXX);</span>；</span><br> <span style="font-size:14px">定义一系列接口用到的纯虚函数，如：<span style="font-family:Times New Roman">method_1()</span>、<span style="font-family:Times New Roman">method_2()</span></span></p> 
<p><span style="font-size:14px">定义<span style="font-family:Times New Roman">class BnXXX:public BnInterface&lt;IXXX&gt;</span>：</span><br> <span style="font-size:14px">重写<span style="font-family:Times New Roman">onTransact()</span></span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">IXXX.cpp</span>：</p> 
<p><span style="font-size:14px">定义<span style="font-family:Times New Roman">class BpXXX:public BpInterface&lt;IXXX&gt;</span>：</span><br> <span style="font-size:14px">构造函数中调用<span style="font-family:Times New Roman">BpInterface&lt;IXXX &gt;(impl)</span>；</span><br> <span style="font-size:14px">调用宏<span style="font-family:Times New Roman">IMPLEMENT_META_INTERFACE(XXX,"android.xxx.IXXX");</span>；</span><br> <span style="font-size:14px">实现接口的方法（其中调用<span style="font-family:Times New Roman">remote()-&gt;transact</span>）</span></p> 
<p><span style="font-size:14px">实现<span style="font-family:Times New Roman">BnXXX::onTransact()</span>：</span><br> <span style="font-size:14px">重写<span style="font-family:Times New Roman">onTransact()</span>，其中调用由<span style="font-family:Times New Roman">BnXXX</span>派生类<span style="font-family:Times New Roman">XXX</span>实现的接口方法</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">XXX.h</span>、<span style="font-family:Times New Roman">XXX.cpp</span>：</p> 
<p><span style="font-size:14px">定义</span><span style="font-family:Times New Roman; font-size:14px">class XXX:public BnXXX<br> </span>实现接口的方法</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">BpXXX</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">构造函数</span></p> 
<p><span style="font-size:14px">参数为<span style="font-family:Times New Roman">BpBinder</span>，<span style="font-family:Times New Roman">BpXXX</span>的构造函数中有一个参数<span style="font-family:Times New Roman">sp&lt;IBinder&gt;&amp; impl</span>，说明它采用了<span style="font-family:Times New Roman">Bridge</span>模式，<span style="font-family:Times New Roman">BpBinder</span>是它的实现。</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">BpXXX(const sp&lt;IBinder&gt;&amp; impl)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     : BpInterface&lt;IXXX&gt;(impl)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">BpXXX::method_1()</span></p> 
<p><span style="font-size:14px">该函数内不执行具体的操作，只是把请求发给服务端</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">virtual void method_1(int id)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     Parcel data, reply;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     data.writeInt32(id);  //</span>构造发送数据</p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">     remote()-&gt;transact(CMD_METHOD_1, data, &amp;reply);  // CMD_METHOD_1</span>是发送的命令</p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:Times New Roman; font-size:14px">BpXXX</span>继承<span style="font-family:Times New Roman">BpRefBase</span>，<span style="font-family:Times New Roman">BpRefBase</span>定义了成员函数<span style="font-family:Times New Roman">remote()</span>，该函数返回的实际上就是<span style="font-family:Times New Roman">BpBinder</span>，然后调用<span style="font-family:Times New Roman">BpBinder::transact()</span>发送数据</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">BnXXX</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">BnXXX::onTransact()</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">BnXXX::onTransact()</span>在<span style="font-family:Times New Roman">BBinder::transact()</span>中调用，它根据收到的命令，分别调用对应的方法。</p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">status_t BnXXX::onTransact(uint32_t code,  const Parcel&amp; data, Parcel* reply, uint32_t flags)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     switch(code) {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">         case CMD_METHOD_1: {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">            pid_t pid = data.readInt32();</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            rtn = method_1(pid);  //</span>调用的是<span style="font-family:Times New Roman">BnXXX</span>的派生类<span style="font-family:Times New Roman">XXX</span>实现的<span style="font-family:Times New Roman">method_1()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            reply-&gt;writeInt32(rtn);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         }</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     }</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}    </span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">XXX</span></p> 
<p><span style="font-size:14px">实现<span style="font-family:Times New Roman">XXX::method_1()</span></span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">ServiceManager</span></p> 
<p><span style="font-size:14px">源代码：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\cmds\servicemanager\*</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">服务进程向<span style="font-family:Times New Roman">ServiceManager</span>注册服务，客户进程向<span style="font-family:Times New Roman">ServiceManager</span>查询服务，从而得到访问服务对象的<span style="font-family:Times New Roman">handle</span>。</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">ServiceManager</span>维护服务名称字符串，它本身也是一个服务，调用<span style="font-family:Times New Roman">binder_become_context_manager()</span>变为“<span style="font-family:Times New Roman">Server</span>大总管”的服务，他对于其它进程来说，它的<span style="font-family:Times New Roman">handle</span>永远是<span style="font-family:Times New Roman">0</span>。它是第一个启动的服务，在<span style="font-family:Times New Roman">/init.rc</span>中启动。</p> 
<p><span style="font-family:Times New Roman; font-size:14px">ISericeManager</span>本地功能<span style="font-family:Times New Roman">BnServiceManager</span>并没有实现，本地功能实际上由<span style="font-family:Times New Roman">servicemanager</span>守护进程执行，而用户程序通过调用<span style="font-family:Times New Roman">BpServiceManager</span>来获得其他的服务。</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">ServiceManager</span>主程序代码</p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\cmds\servicemanager\service_manager.c</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">main()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     // </span>其中调用<span style="font-family:Times New Roman">binder_***()</span>函数位于<span style="font-family:Times New Roman">frameworks\base\cmds\servicemanager\binder.c</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     binder_open(128*1024);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         open("/dev/binder")         //</span>调用驱动的<span style="font-family:Times New Roman">binder_open()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         mmap()                      //</span>把<span style="font-family:Times New Roman">/dev/binder</span>映射到一个<span style="font-family:Times New Roman">128*1024</span>字节大小的内存</p> <p><span style="font-family:Times New Roman; font-size:14px">     binder_become_context_manager()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         ioctl(BINDER_SET_CONTEXT_MGR)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     binder_loop(bs, svcmgr_handler);  //</span>注册请求处理函数<span style="font-family:Times New Roman"> svcmgr_handler()                   </span></p> <p><span style="font-family:Times New Roman; font-size:14px">         binder_write()              //</span>写命令<span style="font-family:Times New Roman">BC_ENTER_LOOPER</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         // </span>开始循环</p> <p><span style="font-family:Times New Roman; font-size:14px">         ioctl(BINDER_WRITE_READ);  //</span>只是读取</p> <p><span style="font-family:Times New Roman; font-size:14px">         binder_parse()              //</span>调用<span style="font-family:Times New Roman">svcmgr_handler()</span>处理<span style="font-family:Times New Roman">BR_TRANSACTION,...</span>等命令，</p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">svcmgr_handler()</span></p> 
<p><span style="font-size:14px">请求处理函数</span></p> 
<p><span style="font-size:14px">对于客户端请求服务，返回的是<span style="font-family:Times New Roman">Service</span>的<span style="font-family:Times New Roman">handle</span>，<span style="font-family:Times New Roman">binder</span>类型是<span style="font-family:Times New Roman">BINDER_TYPE_HANDLE</span>，见函数<span style="font-family:Times New Roman">bio_put_ref()</span>，然后在驱动层<span style="font-family:Times New Roman">binder_thread_write() -&gt;binder_transaction()</span>会进行转换，如果请求的服务在同一进程里，则转换类型成<span style="font-family:Times New Roman">BINDER_TYPE_BINDER</span>，直接使用服务对象的地址，而不使用<span style="font-family:Times New Roman">handle</span>，这在<span style="font-family:Times New Roman">unflatten_binder()</span>中有体现。</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">获取<span style="font-family:Times New Roman">ServiceManager</span>服务代理</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">sp&lt;IServiceManager&gt;  defaultServiceManager()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     if (gDefaultServiceManager != NULL) return gDefaultServiceManager; //</span>单一实例</p> <p><span style="font-family:Times New Roman; font-size:14px">     </span></p> <p><span style="font-family:Times New Roman; font-size:14px">     {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">         AutoMutex _l(gDefaultServiceManagerLock);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         if (gDefaultServiceManager == NULL) {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">            gDefaultServiceManager =  interface_cast&lt;IServiceManager&gt;(   //</span>调用<span style="font-family:Times New Roman">interface_cast&lt;XXX&gt;</span>根据<span style="font-family:Times New Roman">BpBinder</span>生成<span style="font-family:Times New Roman">BpServiceManager</span></p> <p><span style="font-family:Times New Roman; font-size:14px">                ProcessState::self()-&gt;getContextObject(NULL));</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         }</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     }</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     </span></p> <p><span style="font-family:Times New Roman; font-size:14px">     return gDefaultServiceManager;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">sp&lt;IBinder&gt; ProcessState::getContextObject(const  sp&lt;IBinder&gt;&amp; caller)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     if (supportsProcesses()) {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">         return getStrongProxyForHandle(0);   //</span>调用<span style="font-family:Times New Roman">ProcessState::getStrongProxyForHandle()</span>创建<span style="font-family:Times New Roman">BpBinder</span>，<span style="font-family:Times New Roman">handle</span>为<span style="font-family:Times New Roman">0</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     } else {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">         return getContextObject(String16("default"), caller);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     }</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">注册服务</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">status_t BpServiceManager::addService(const  String16&amp; name, const sp&lt;IBinder&gt;&amp; service)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">//</span>参数<span style="font-family:Times New Roman">service</span>可以是<span style="font-family:Times New Roman">BpBinder</span>或<span style="font-family:Times New Roman">BBinder</span>，<span style="font-family:Times New Roman">binder</span>驱动会记录下对象的地址</p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     data.writeStrongBinder(service);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">查询服务</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">sp&lt;IBinder&gt; BpServiceManager::getService(const  String16&amp; name)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">//</span>函数返回<span style="font-family:Times New Roman">BpBinder</span>或<span style="font-family:Times New Roman">BBinder</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     BpServiceManager::checkService()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         reply.readStrongBinder()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">调用服务</span></p> 
<p><span style="font-size:14px">服务端</span></p> 
<p><span style="font-size:14px">服务端如何工作</span></p> 
<p><span style="font-size:14px">创建<span style="font-family:Times New Roman">ProcessState</span>对象，打开<span style="font-family:Times New Roman">/dev/binder</span>，映射好内存</span></p> 
<p><span style="font-size:14px">调用<span style="font-family:Times New Roman">defaultServiceManager()</span>创建<span style="font-family:Times New Roman">ServiceManager</span>的代理</span></p> 
<p><span style="font-size:14px">调用服务端类的方法<span style="font-family:Times New Roman">instantiate()</span>，创建服务端对象，并向<span style="font-family:Times New Roman">ServiceManager</span>注册</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">ProcessState::self()-&gt;startThreadPool();</span>，其中也会调用<span style="font-family:Times New Roman">IPCThreadState::joinThreadPool()</span>，参数是<span style="font-family:Times New Roman">true</span>，加上下面的，总共调用了<span style="font-family:Times New Roman">2</span>次</p> 
<p><span style="font-family:Times New Roman; font-size:14px">IPCThreadState::self()-&gt;joinThreadPool();</span>，参数默认也是<span style="font-family:Times New Roman">true</span>，进入服务的循环监听状态。（网上有人测试过把最后一句屏蔽掉，也能正常工作。但是难道主线程提出了，程序还能不退出吗？）</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">参考代码：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\mediaserver\main_mediaserver.cpp</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">int main(int argc, char** argv)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     sp&lt;ProcessState&gt; proc(ProcessState::self());</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     LOGI("ServiceManager: %p", sm.get());</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     AudioFlinger::instantiate();</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     MediaPlayerService::instantiate();</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     CameraService::instantiate();</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     AudioPolicyService::instantiate();</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     ProcessState::self()-&gt;startThreadPool();</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     IPCThreadState::self()-&gt;joinThreadPool();</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">void MediaPlayerService::instantiate() {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     defaultServiceManager()-&gt;addService(</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            String16("media.player"),  new MediaPlayerService());  //</span>注册时，要附上服务名称、服务对象的地址，服务对象的地址最终是记录在驱动中</p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">客户端</span></p> 
<p><span style="font-size:14px">客户端如何调用服务</span></p> 
<p><span style="font-size:14px">调用<span style="font-family:Times New Roman">defaultServiceManager()</span>创建<span style="font-family:Times New Roman">ServiceManager</span>的代理，其中会创建<span style="font-family:Times New Roman">ProcessState</span>对象</span></p> 
<p><span style="font-size:14px">调用<span style="font-family:Times New Roman">BpServiceManager::getService()</span>获取服务的<span style="font-family:Times New Roman">handle</span>，并生成对应的<span style="font-family:Times New Roman">BpBinder</span></span></p> 
<p><span style="font-size:14px">调用<span style="font-family:Times New Roman">BpBinder::linkToDeath()</span>，注册服务死亡的通知</span></p> 
<p><span style="font-size:14px">调用<span style="font-family:Times New Roman">interface_cast&lt;IXXX&gt;()</span>利用<span style="font-family:Times New Roman">BpBinder</span>生成<span style="font-family:Times New Roman">BpXXX</span></span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">参考代码：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\jni\android_media_MediaPlayer.cpp</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmedia\mediaplayer.cpp</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmedia\IMediaDeathNotifier.cpp</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\jni\android_media_MediaPlayer.cpp</span></p> <p><span style="font-family:Times New Roman; font-size:14px">android_media_MediaPlayer_setDataSourceAndHeaders()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     mp-&gt;setDataSource(</span></p> <p><span style="font-family:Times New Roman; font-size:14px">                String8(pathStr),</span></p> <p><span style="font-family:Times New Roman; font-size:14px">                headers ? &amp;headersVector :  NULL);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmedia\mediaplayer.cpp</span></p> <p><span style="font-family:Times New Roman; font-size:14px">status_t MediaPlayer::setDataSource(</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         const char *url, const KeyedVector&lt;String8, String8&gt; *headers)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     status_t err = BAD_VALUE;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         const sp&lt;IMediaPlayerService&gt;&amp; service(getMediaPlayerService());</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         if (service != 0) {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">            sp&lt;IMediaPlayer&gt; player(</span></p> <p><span style="font-family:Times New Roman; font-size:14px">                    service-&gt;create(getpid(),  this, url, headers, mAudioSessionId));</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            err = setDataSource(player);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         }</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     return err;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmedia\IMediaDeathNotifier.cpp</span></p> <p><span style="font-family:Times New Roman; font-size:14px">IMediaDeathNotifier::getMediaPlayerService()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     if (sMediaPlayerService.get() == 0) {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">         sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         sp&lt;IBinder&gt; binder;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         do {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">            binder = sm-&gt;getService(String16("media.player"));</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            if (binder != 0) {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">                break;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">             }</span></p> <p><span style="font-family:Times New Roman; font-size:14px">             usleep(500000); // 0.5 s</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         } while(true);</span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">         if (sDeathNotifier == NULL) {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">         sDeathNotifier = new DeathNotifier();</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     }</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     binder-&gt;linkToDeath(sDeathNotifier);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     }</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     return sMediaPlayerService;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">服务进阶</span></p> 
<p><span style="font-size:14px">异步方式</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Binder</span>默认是同步的，但有时我们也需要异步，比如广播通知，我们可以在发送的时候指定一个<span style="font-family:Times New Roman">ONE_WAY</span>标志，来实现异步</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">参考代码：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmedia\IMediaPlayerClient.cpp</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">BpMediaPlayerClient::notify(int msg, int  ext1, int ext2)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     Parcel data, reply;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     data.writeInterfaceToken(IMediaPlayerClient::getInterfaceDescriptor());</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     data.writeInt32(msg);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     data.writeInt32(ext1);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     data.writeInt32(ext2);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     remote()-&gt;transact(NOTIFY, data, &amp;reply, IBinder::FLAG_ONEWAY);  //</span>如果不设置最后一个参数，那么默认为<span style="font-family:Times New Roman">0</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">服务和客户端在同一进程</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">Binder</span>也可以用于服务端和客户端在同一进程的情况，这样客户端不用关心服务对象在哪里，不管它在哪，对于客户端来说，就像和自己同一进程中一样。</p> 
<p><span style="font-size:14px">实现原理：</span></p> 
<p><span style="font-size:14px">客户端首先向<span style="font-family:Times New Roman">ServiceManager</span>查询服务，<span style="font-family:Times New Roman">ServiceManager</span>不管服务在哪，一律返回的是服务在<span style="font-family:Times New Roman">ServiceManager</span>进程中的<span style="font-family:Times New Roman">handle</span>，当应答在驱动的传输过程中，驱动会判断并转换，如果在同一进程，那么返回给客户进程的将是服务对象的地址，而客户进程调用<span style="font-family:Times New Roman">BpServiceManager::getService()</span>返回的将是<span style="font-family:Times New Roman">BBinder</span>，然后客户进程再调用<span style="font-family:Times New Roman">interface_cast&lt;XXX&gt;()</span>，最终得到的是<span style="font-family:Times New Roman">BnXXX</span>。</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">参考代码：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">kernel\drivers\staging\android\binder.c</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">binder_transaction()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     switch (fp-&gt;type) {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     case BINDER_TYPE_HANDLE:  //</span>如果传输的<span style="font-family:Times New Roman">binder</span>对象的类型是<span style="font-family:Times New Roman">handle</span>，而不是地址</p> <p><span style="font-family:Times New Roman; font-size:14px">     case BINDER_TYPE_WEAK_HANDLE: {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">         struct binder_ref *ref = binder_get_ref(proc, fp-&gt;handle); //</span>在源进程的数据中找到对应的<span style="font-family:Times New Roman">binder_ref</span>，进而可以得到服务对象的<span style="font-family:Times New Roman">binder_node</span>和<span style="font-family:Times New Roman">binder_proc</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         if (ref-&gt;node-&gt;proc == target_proc) { //</span>传输的目的进程和服务对象在同一进程</p> <p><span style="font-family:Times New Roman; font-size:14px">            if (fp-&gt;type ==  BINDER_TYPE_HANDLE)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">                fp-&gt;type =  BINDER_TYPE_BINDER;  // binder</span>对象的类型转变为地址</p> <p><span style="font-family:Times New Roman; font-size:14px">            else</span></p> <p><span style="font-family:Times New Roman; font-size:14px">                fp-&gt;type = BINDER_TYPE_WEAK_BINDER;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            fp-&gt;binder = ref-&gt;node-&gt;ptr;  //</span>写入服务对象的地址</p> <p><span style="font-family:Times New Roman; font-size:14px">            fp-&gt;cookie = ref-&gt;node-&gt;cookie;  //</span>写入服务对象的地址</p> <p><span style="font-family:Times New Roman; font-size:14px">            binder_inc_node(ref-&gt;node, fp-&gt;type  == BINDER_TYPE_BINDER, 0, NULL);</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         } else {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">         }</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">客户端注册服务死亡通知</span></p> 
<p><span style="font-size:14px">由于不在同一进程内，当服务对象死亡后，客户进程需要知道这一点。</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">BpBinder</span>有一个成员函数<span style="font-family:Times New Roman">BpBinder::linkToDeath()</span>，还有一个成员变量<span style="font-family:Times New Roman">Vector&lt;Obituary&gt;*  mObituaries;</span>，它是<span style="font-family:Times New Roman">BpBinder::Obituary</span>的容器。</p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">BpBinder::linkToDeath()</span></p> 
<p><span style="font-size:14px">它有一个参数是<span style="font-family:Times New Roman">IBinder::DeathRecipient</span>死亡通知对象，<span style="font-family:Times New Roman">DeathRecipient</span>类只有一个虚方法<span style="font-family:Times New Roman">binderDied()</span>，要想得到死亡通知，就需要继承<span style="font-family:Times New Roman">DeathRecipient</span>，并重写<span style="font-family:Times New Roman">binderDied()</span>。</span></p> 
<p><span style="font-size:14px">函数的作用就是把死亡通知对象放入<span style="font-family:Times New Roman">BpBinder.mObituaries</span>容器中</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">BpBinder::linkToDeath(sp&lt;DeathRecipient&gt;&amp;  recipient, ...)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-size:14px">创建<span style="font-family:Times New Roman">BpBinder.mObitsSent</span>对象，它是<span style="font-family:Times New Roman">Obituary</span>的容器——只执行一次</span></p> <p><span style="font-size:14px">调用<span style="font-family:Times New Roman">IPCThreadState::requestDeathNotification() </span>向驱动写入命令<span style="font-family:Times New Roman">BC_REQUEST_DEATH_NOTIFICATION</span>，把<span style="font-family:Times New Roman"> BpBinder</span>对象的地址记录到驱动中<span style="font-family:Times New Roman">binder_ref.death.cookie</span>中，<span style="font-family:Times New Roman">binder_ref</span>是服务对象的引用。——只执行一次</span></p> <p><span style="font-size:14px">把参数<span style="font-family:Times New Roman">recipient</span>封装在一个临时变量<span style="font-family:Times New Roman">Obituary</span>对象</span></p> <p><span style="font-family:Times New Roman; font-size:14px">mObituaries-&gt;add(ob); </span>——把<span style="font-family:Times New Roman">Obituary</span>添加到<span style="font-family:Times New Roman">BpBinder.mObitsSent</span>中</p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:Times New Roman; font-size:14px">       </span></p> 
<p><span style="font-size:14px">当服务对象死亡后，将可以从驱动中读到消息，从驱动中的<span style="font-family:Times New Roman">binder_ref.death.cookie</span>取出<span style="font-family:Times New Roman">BpBinder</span>对象的地址，然后调用<span style="font-family:Times New Roman">BpBinder::sendObituary()</span>遍历<span style="font-family:Times New Roman">BpBinder.mObitsSent</span>所有的<span style="font-family:Times New Roman">Obituary</span>对象，调用<span style="font-family:Times New Roman">BpBinder::reportOneDeath()</span>从<span style="font-family:Times New Roman">Obituary</span>对象中获得<span style="font-family:Times New Roman">DeathRecipient</span>死亡通知对象，最后调用其<span style="font-family:Times New Roman">binderDied()</span>方法。</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">参考代码：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmedia\IMediaDeathNotifier.cpp</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">客户端<span style="font-family:Times New Roman">MeidaPlayer</span>继承了<span style="font-family:Times New Roman">IMediaDeathNotifier</span>，实现了纯虚函数<span style="font-family:Times New Roman">IMediaDeathNotifier::died()</span>，</span><a target="_blank" name="OLE_LINK2"></a><a target="_blank" name="OLE_LINK1"><span style="font-family:Times New Roman; font-size:14px">IMediaDeathNotifier</span></a><span style="font-size:14px">的构造函数会把<span style="font-family:Times New Roman">this</span>添加到<span style="font-family:Times New Roman">IMediaDeathNotifier::sObitRecipients</span>容器，当<span style="font-family:Times New Roman">IMediaDeathNotifier::DeathNotifier::binderDied()</span>被调用时，将遍历<span style="font-family:Times New Roman">IMediaDeathNotifier::sObitRecipients</span>容器中的对象，调用纯虚函数<span style="font-family:Times New Roman">IMediaDeathNotifier::died()</span>。</span></p> 
<p><span style="font-size:14px">所以，把获取服务的<span style="font-family:Times New Roman">BpBinder</span>的工作放到了<span style="font-family:Times New Roman">IMediaDeathNotifier</span>中实现，以便获取之后能注册死亡通知。</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">IMediaDeathNotifier::getMediaPlayerService()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">         sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            binder = sm-&gt;getService(String16("media.player"));</span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">         if (sDeathNotifier == NULL) { // IMediaDeathNotifier::sDeathNotifier</span>是静态成员</p> <p><span style="font-family:Times New Roman; font-size:14px">         sDeathNotifier = new DeathNotifier();   // IMediaDeathNotifier::DeathNotifier</span>继承<span style="font-family:Times New Roman">IBinder::DeathRecipient</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     }</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     binder-&gt;linkToDeath(sDeathNotifier);       // BpBinder::linkToDeath()</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">类关系图：</span></p> 
<p></p> 
<p><span style="font-family:宋体; font-size:14px"> <img alt="" src="https://images2.imgbox.com/01/b5/3nUGz0Z9_o.png"></span></p> 
<p><span style="font-size:14px">数据结构图：</span></p> 
<p><img alt="" src="https://images2.imgbox.com/00/16/mwDOlZUU_o.png"></p> 
<p><span style="font-size:14px">说明：虚线表示间接关联</span></p> 
<p><span style="font-size:14px">匿名（未注册）服务</span></p> 
<p><span style="font-size:14px">并不是所有的服务都需要注册的，客户端获取服务的方式有<span style="font-family:Times New Roman">3</span>种：</span></p> 
<p><span style="font-size:14px">服务端向提供一个名称向<span style="font-family:Times New Roman">ServiceManager</span>注册，客户端向<span style="font-family:Times New Roman">ServiceManager</span>查询服务。</span></p> 
<p><span style="font-size:14px">服务端把自己的<span style="font-family:Times New Roman">BBinder</span>信息发给客户端，客户端收到信息后，创建对应的<span style="font-family:Times New Roman">BpBinder</span>。</span></p> 
<p><span style="font-size:14px">客户端把自己得到的服务端的<span style="font-family:Times New Roman">BpBinder</span>信息传递给其它客户端，其它客户端收到后创建对应的<span style="font-family:Times New Roman">BpBinder</span>。</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">参考代码：</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmedia\mediaplayer.cpp</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmedia\IMediaPlayerClient.cpp</span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmediaplayerservice\MediaPlayerService.cpp</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">MediaPlayerService</span>本身并不完成播放的具体实现，它相当于播放器的一个管理者，其下可以创建多个播放器<span style="font-family:Times New Roman">BnMediaPlayer</span>对象，<span style="font-family:Times New Roman">MediaPlayerService::Client</span>会继承并实现<span style="font-family:Times New Roman">BnMediaPlayer</span>。</p> 
<p><span style="font-size:14px">当客户通过调用<span style="font-family:Times New Roman">BpMediaPlayerService::create()</span>向<span style="font-family:Times New Roman">MediaPlayerService</span>请求创建播放器时，<span style="font-family:Times New Roman">MediaPlayerService</span>会创建<span style="font-family:Times New Roman">MediaPlayerService::Client</span>，并把它的<span style="font-family:Times New Roman">binder</span>信息返回给客户进程，客户进程收到<span style="font-family:Times New Roman">binder</span>信息后，创建<span style="font-family:Times New Roman">BpMediaPlayer</span>对象。</span></p> 
<p><span style="font-size:14px">向<span style="font-family:Times New Roman">Parcel</span>写入和读取<span style="font-family:Times New Roman">binder</span>信息的操作是由<span style="font-family:Times New Roman">Parcel::writeStrongBinder()</span>、<span style="font-family:Times New Roman">Parcel::readStrongBinder()</span>，还用到了<span style="font-family:Times New Roman">IInterface::asBinder()</span>。具体请参见“第三章中的<span style="font-family:Times New Roman">Parcel</span>”。</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">逻辑关系图：</span></p> 
<p></p> 
<p><span style="font-family:宋体; font-size:14px"> <img alt="" src="https://images2.imgbox.com/d5/33/AJO8S76T_o.png"></span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">       </span>类关系图：</p> 
<p><span style="font-family:Times New Roman; font-size:14px"> <img alt="" src="https://images2.imgbox.com/e3/4a/1fMCxOLq_o.png"></span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmedia\mediaplayer.cpp</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">status_t MediaPlayer::setDataSource(</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         const char *url, const KeyedVector&lt;String8, String8&gt; *headers)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">         const sp&lt;IMediaPlayerService&gt;&amp; service(getMediaPlayerService());  //</span>创建<span style="font-family:Times New Roman">BpMediaPlayerService</span></p> <p><span style="font-family:Times New Roman; font-size:14px">            sp&lt;IMediaPlayer&gt; player(</span></p> <p><span style="font-family:Times New Roman; font-size:14px">                    service-&gt;create(getpid(),  this, url, headers, mAudioSessionId));   //</span>调用<span style="font-family:Times New Roman">BpMediaPlayerService::create()</span>，最后得到<span style="font-family:Times New Roman">BpMediaPlayer</span>。还传递了<span style="font-family:Times New Roman">this</span>指针，见“双向通信”</p> <p><span style="font-family:Times New Roman; font-size:14px">            err = setDataSource(player);  //</span>保存<span style="font-family:Times New Roman">BpMediaPlayer</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmedia\IMediaPlayerClient.cpp</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">virtual sp&lt;IMediaPlayer&gt;  BpMediaPlayerService::create(</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         pid_t pid, const sp&lt;IMediaPlayerClient&gt;&amp; client,...)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     Parcel data, reply;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     data.writeStrongBinder(client-&gt;asBinder());  //</span>见“双向通信”，传入<span style="font-family:Times New Roman">BnInterface&lt;MeidaPlayerClient&gt;</span>对象地址</p> <p><span style="font-family:Times New Roman; font-size:14px">     data.writeCString(url);</span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">     remote()-&gt;transact(CREATE_URL, data, &amp;reply);</span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">     return interface_cast&lt;IMediaPlayer&gt;(reply.readStrongBinder());  //</span>调用<span style="font-family:Times New Roman">Parcel:: readStrongBinder()</span>从服务端的应答中，取出<span style="font-family:Times New Roman">BpBinder</span>并生成<span style="font-family:Times New Roman">BpMediaPlayer</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> <p><span style="font-family:宋体; font-size:14px"> </span></p> <p><span style="font-family:Times New Roman; font-size:14px">status_t BnMediaPlayerService::onTransact(</span></p> <p><span style="font-family:Times New Roman; font-size:14px">     uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     switch(code) {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">         case CREATE_URL: {<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">            sp&lt;IMediaPlayerClient&gt;  client =</span></p> <p><span style="font-family:Times New Roman; font-size:14px">                interface_cast&lt;IMediaPlayerClient&gt;(data.readStrongBinder());  //</span>见“双向通信”</p> <p><span style="font-family:Times New Roman; font-size:14px">            sp&lt;IMediaPlayer&gt; player =  create(</span></p> <p><span style="font-family:Times New Roman; font-size:14px">                    pid, client, url,  numHeaders &gt; 0 ? &amp;headers : NULL, audioSessionId);</span></p> <p><span style="font-family:Times New Roman; font-size:14px"> //  </span>调用<span style="font-family:Times New Roman">MediaPlayerService::create()</span>。参数<span style="font-family:Times New Roman">client</span>为<span style="font-family:Times New Roman">BpMediaPlayerClient</span>对象，见“双向通信”</p> <p><span style="font-family:Times New Roman; font-size:14px">            reply-&gt;writeStrongBinder(player-&gt;asBinder());  //</span>写入<span style="font-family:Times New Roman">BnMediaPlayer</span>对象的<span style="font-family:Times New Roman">binder</span>信息</p> <p><span style="font-family:Times New Roman; font-size:14px">            return NO_ERROR;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">         } break;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-family:Times New Roman; font-size:14px">frameworks\base\media\libmediaplayerservice\MediaPlayerService.cpp</span></p> 
<p> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-family:Times New Roman; font-size:14px">sp&lt;IMediaPlayer&gt; MediaPlayerService::create(pid_t  pid, const sp&lt;IMediaPlayerClient&gt;&amp; client,…)</span></p> <p><span style="font-family:Times New Roman; font-size:14px">{<!-- --></span></p> <p><span style="font-family:Times New Roman; font-size:14px">     sp&lt;Client&gt; c = new Client(this, pid, connId, client,  audioSessionId); //</span>创建<span style="font-family:Times New Roman">MediaPlayerService::Client</span>对象。参数<span style="font-family:Times New Roman">client</span>用于记录下<span style="font-family:Times New Roman">BpMediaPlayerClient</span>对象，见“双向通信”</p> <p><span style="font-family:Times New Roman; font-size:14px">     return c;</span></p> <p><span style="font-family:Times New Roman; font-size:14px">}</span></p> </td></tr></tbody></table> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p><span style="font-size:14px">双向通信</span></p> 
<p><span style="font-size:14px">仍然以上节的内容为例，客户端主动调用<span style="font-family:Times New Roman">BnMediaPlayer</span>的服务，但同时也希望能接收服务对象的通知。实现方式就是客户端自身也作为一个服务，来给<span style="font-family:Times New Roman">BnMediaPlayer</span>对象调用，即双向服务。</span></p> 
<p><span style="font-size:14px">实现细节，请参考上节内容中的类关系图，<span style="font-family:Times New Roman">MediaPlayer</span>是客户端，同时又继承<span style="font-family:Times New Roman">BnMediaPlayerClient</span>作为一个服务端，来接收<span style="font-family:Times New Roman">BnMediaPlayer</span>对象的通知。</span></p> 
<p><span style="font-size:14px">当<span style="font-family:Times New Roman">MediaPlayer</span>调用<span style="font-family:Times New Roman">BpMediaPlayerService::create()</span>创建播放器时，也会将自己的<span style="font-family:Times New Roman">binder</span>信息写入到<span style="font-family:Times New Roman">Parcel</span>中，<span style="font-family:Times New Roman">BnMediaPlayer</span>对象收到请求后，从<span style="font-family:Times New Roman">Parcel</span>中取出<span style="font-family:Times New Roman">binder</span>信息并生成<span style="font-family:Times New Roman">BpMediaPlayerClient</span>，记录下来以供日后发布通信。</span></p> 
<p><span style="font-size:14px">也就是说明<span style="font-family:Times New Roman">MediaPlayerService</span>这个服务，由<span style="font-family:Times New Roman">3</span>个接口组成：<span style="font-family:Times New Roman">IMediaPlayerClient</span>、<span style="font-family:Times New Roman">IMediaPlayerService</span>、<span style="font-family:Times New Roman">IMediaPlayer</span>。</span></p> 
<p><span style="font-family:宋体; font-size:14px"> </span></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c1dffeb74c2af3c7a991338ae289557/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【php】获取http请求body数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/526c8299dc36eb4d12131709cf86c028/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">经验风险与结构风险</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>