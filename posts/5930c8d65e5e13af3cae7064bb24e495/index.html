<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构与算法】树和二叉树（头歌） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构与算法】树和二叉树（头歌）" />
<meta property="og:description" content="树和二叉树
第1关：二叉树的基本操作
任务描述
测试说明
代码
第2关：输出二叉树后序遍历的逆序
任务描述
测试说明 代码 第3关：按中序输出二叉树中的分支结点
任务描述
测试说明
代码
第4关：前序输出二叉树节点值与层次值
任务描述
测试说明
代码 第5关：求二叉树中结点个数
任务描述
测试说明
代码
第6关：求二叉树叶子结点数
任务描述
测试说明
代码 第7关：求二叉树的深度
任务描述
测试说明
代码 第8关：二叉树交换左右子树
任务描述
测试说明
代码 第9关：按中序遍历次序输出二叉树中度为1的结点
任务描述
测试说明
代码
第1关：二叉树的基本操作 任务描述 题目描述： 设计二叉树，能够对二叉树进行先序、中序、后序和层序遍历，遍历的操作为输出结点的值，设计主函数，输入一棵二叉树，按先序、中序、后序、层序的遍历顺序输出结点的值。二叉树的结点数不超过20。
测试说明 输入描述：输入数据只有一组, 二叉树的结点均为一个数字， 数据为 0 代表当前结点为空。输入结点的值按照二叉树的先序遍历顺序, 比如输入:1 2 4 0 0 5 0 0 3 0 6 0 0, 0 表示空,输入的数字之间由空格分隔。
1/ \2 3/ \ \4 5 6 输出描述：输出先序、中序、后序和层序遍历二叉树得到的序列，各占一行，同一行的数字之间由空格分隔。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/5930c8d65e5e13af3cae7064bb24e495/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-25T22:45:03+08:00" />
<meta property="article:modified_time" content="2023-11-25T22:45:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构与算法】树和二叉树（头歌）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>树和二叉树</strong></p> 
<p id="%E7%AC%AC1%E5%85%B3%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E7%AC%AC1%E5%85%B3%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" rel="nofollow">第1关：二叉树的基本操作</a></p> 
<p id="任务描述-toc" style="margin-left:80px;"><a href="#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0" rel="nofollow">任务描述</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E" rel="nofollow">测试说明</a></p> 
<p id="%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81" rel="nofollow">代码</a></p> 
<p id="%E7%AC%AC2%E5%85%B3%EF%BC%9A%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%80%86%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E7%AC%AC2%E5%85%B3%EF%BC%9A%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%80%86%E5%BA%8F" rel="nofollow">第2关：输出二叉树后序遍历的逆序</a></p> 
<p id="%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0" rel="nofollow">任务描述</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E%C2%A0-toc" style="margin-left:80px;"><a href="#%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E%C2%A0" rel="nofollow">测试说明 </a></p> 
<p id="%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow">代码 </a></p> 
<p id="%C2%A0%E7%AC%AC3%E5%85%B3%EF%BC%9A%E6%8C%89%E4%B8%AD%E5%BA%8F%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%86%E6%94%AF%E7%BB%93%E7%82%B9-toc" style="margin-left:0px;"><a href="#%C2%A0%E7%AC%AC3%E5%85%B3%EF%BC%9A%E6%8C%89%E4%B8%AD%E5%BA%8F%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%86%E6%94%AF%E7%BB%93%E7%82%B9" rel="nofollow"> 第3关：按中序输出二叉树中的分支结点</a></p> 
<p id="%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0" rel="nofollow">任务描述</a></p> 
<p id="测试说明-toc" style="margin-left:80px;"><a href="#%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E" rel="nofollow">测试说明</a></p> 
<p id="%C2%A0%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BB%A3%E7%A0%81" rel="nofollow"> 代码</a></p> 
<p id="%E7%AC%AC4%E5%85%B3%EF%BC%9A%E5%89%8D%E5%BA%8F%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E5%80%BC%E4%B8%8E%E5%B1%82%E6%AC%A1%E5%80%BC-toc" style="margin-left:0px;"><a href="#%E7%AC%AC4%E5%85%B3%EF%BC%9A%E5%89%8D%E5%BA%8F%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E5%80%BC%E4%B8%8E%E5%B1%82%E6%AC%A1%E5%80%BC" rel="nofollow">第4关：前序输出二叉树节点值与层次值</a></p> 
<p id="%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0" rel="nofollow">任务描述</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E" rel="nofollow">测试说明</a></p> 
<p id="%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow">代码 </a></p> 
<p id="%C2%A0%E7%AC%AC5%E5%85%B3%EF%BC%9A%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0-toc" style="margin-left:0px;"><a href="#%C2%A0%E7%AC%AC5%E5%85%B3%EF%BC%9A%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0" rel="nofollow"> 第5关：求二叉树中结点个数</a></p> 
<p id="%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0" rel="nofollow">任务描述</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E" rel="nofollow">测试说明</a></p> 
<p id="%C2%A0%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BB%A3%E7%A0%81" rel="nofollow"> 代码</a></p> 
<p id="%E7%AC%AC6%E5%85%B3%EF%BC%9A%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E7%AC%AC6%E5%85%B3%EF%BC%9A%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0" rel="nofollow">第6关：求二叉树叶子结点数</a></p> 
<p id="%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0" rel="nofollow">任务描述</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E" rel="nofollow">测试说明</a></p> 
<p id="%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow">代码 </a></p> 
<p id="%C2%A0%E7%AC%AC7%E5%85%B3%EF%BC%9A%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6-toc" style="margin-left:0px;"><a href="#%C2%A0%E7%AC%AC7%E5%85%B3%EF%BC%9A%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6" rel="nofollow"> 第7关：求二叉树的深度</a></p> 
<p id="%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0" rel="nofollow">任务描述</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E" rel="nofollow">测试说明</a></p> 
<p id="%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow">代码 </a></p> 
<p id="%E7%AC%AC8%E5%85%B3%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%A4%E6%8D%A2%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E7%AC%AC8%E5%85%B3%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%A4%E6%8D%A2%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91" rel="nofollow">第8关：二叉树交换左右子树</a></p> 
<p id="%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0" rel="nofollow">任务描述</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E" rel="nofollow">测试说明</a></p> 
<p id="%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow">代码 </a></p> 
<p id="%E7%AC%AC9%E5%85%B3%EF%BC%9A%E6%8C%89%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%AC%A1%E5%BA%8F%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%A6%E4%B8%BA1%E7%9A%84%E7%BB%93%E7%82%B9-toc" style="margin-left:0px;"><a href="#%E7%AC%AC9%E5%85%B3%EF%BC%9A%E6%8C%89%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%AC%A1%E5%BA%8F%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%A6%E4%B8%BA1%E7%9A%84%E7%BB%93%E7%82%B9" rel="nofollow">第9关：按中序遍历次序输出二叉树中度为1的结点</a></p> 
<p id="%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0" rel="nofollow">任务描述</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E" rel="nofollow">测试说明</a></p> 
<p id="%C2%A0%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BB%A3%E7%A0%81" rel="nofollow"> 代码</a></p> 
<h2 id="%E7%AC%AC1%E5%85%B3%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">第1关：二叉树的基本操作</h2> 
<h4 id="任务描述">任务描述</h4> 
<blockquote> 
 <p>题目描述： 设计二叉树，能够对二叉树进行先序、中序、后序和层序遍历，遍历的操作为输出结点的值，设计主函数，输入一棵二叉树，按先序、中序、后序、层序的遍历顺序输出结点的值。二叉树的结点数不超过20。</p> 
</blockquote> 
<h4 id="%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E">测试说明</h4> 
<blockquote> 
 <p><strong>输入描述</strong>：输入数据只有一组, 二叉树的结点均为一个数字， 数据为 0 代表当前结点为空。输入结点的值按照二叉树的先序遍历顺序, 比如输入:<code>1 2 4 0 0 5 0 0 3 0 6 0 0</code>, <code>0</code> 表示空,输入的数字之间由空格分隔。</p> 
 <ol><li><code>1</code></li><li><code>/ \</code></li><li><code>2 3</code></li><li><code>/ \ \</code></li><li><code>4 5 6</code></li></ol> 
 <p><strong>输出描述</strong>：输出先序、中序、后序和层序遍历二叉树得到的序列，各占一行，同一行的数字之间由空格分隔。</p> 
</blockquote> 
<p><strong>输入样例:</strong></p> 
<blockquote> 
 <p><code>1 2 4 0 0 5 0 0 3 0 6 0 0</code></p> 
</blockquote> 
<p><strong>输出样例: </strong></p> 
<blockquote> 
 <p><code>1 2 4 5 3 6</code></p> 
 <p><code>4 2 5 1 3 6</code></p> 
 <p><code>4 5 2 6 3 1</code></p> 
 <p><code>1 2 3 4 5 6</code></p> 
</blockquote> 
<h4 id="%E4%BB%A3%E7%A0%81"><strong>代码</strong></h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct BiNode {
    int data;
    struct BiNode *lchild, *rchild;
};

struct BiTree {
    struct BiNode *root;
};

void PreOrder(struct BiNode *bt) {
	//TODO：前序遍历递归算法
	//=========begin========
    if (bt == NULL)
    {
    	return;
	}
	else
	{
		printf("%d ", bt-&gt;data);
		PreOrder(bt-&gt;lchild);
		PreOrder(bt-&gt;rchild);
	}
	//==========end==========
}

void InOrder(struct BiNode *bt) {
	//TODO：中序遍历递归算法
	//=========begin========
    if (bt == NULL)
    {
    	return;
	}
	else
	{
		InOrder(bt-&gt;lchild);
		printf("%d ", bt-&gt;data);
		InOrder(bt-&gt;rchild);
	}    
	//==========end==========
}

void PostOrder(struct BiNode *bt) {
	//TODO：后序遍历递归算法
	//=========begin========
    if (bt == NULL)
    {
    	return;
	}
	else
	{
		PostOrder(bt-&gt;lchild);
		PostOrder(bt-&gt;rchild);
		printf("%d ", bt-&gt;data);
	}    
	//==========end==========
}

void LevelOrder(struct BiNode *root) {
	//TODO：层次序遍历
	//=========begin========
    int front = -1, rear = -1;
    struct BiNode *q;
    struct BiNode *Q[30];
    
    if (root == NULL)
    {
    	return;
	}
    
	Q[++rear] = root;
	
	while (front != rear)
	{
		q = Q[++front];
		printf("%d ", q-&gt;data);
		
		if (q-&gt;lchild != NULL)
		{
			Q[++rear] = q-&gt;lchild;
		}
		
		if (q-&gt;rchild != NULL)
		{
			Q[++rear] = q-&gt;rchild;
		}
	}
	//==========end==========
}

struct BiNode *Create(struct BiNode *bt) {
	//TODO：前序建立二叉树
	//=========begin========
    int num;
    
    scanf(" %d", &amp;num);
    
    if (num == 0)
    {
    	bt = NULL;
	}
	else
	{
		bt = (struct BiNode*)malloc(sizeof(struct BiNode));
		bt-&gt;data = num;
		bt-&gt;lchild = Create(bt-&gt;lchild);
		bt-&gt;rchild = Create(bt-&gt;rchild); 		
	}
    
    return bt;
	//==========end==========
}

void Release(struct BiNode *bt) {
	//TODO：销毁二叉树
	//=========begin========
    if (bt != NULL)
    {
    	Release(bt-&gt;lchild);
    	Release(bt-&gt;rchild);
    	free(bt);
	}
	//==========end==========
}

int main() {
    struct BiTree b;
    b.root = Create(b.root);
    PreOrder(b.root);
    printf("\n");
    InOrder(b.root);
    printf("\n");
    PostOrder(b.root);
    printf("\n");
    LevelOrder(b.root);
    Release(b.root);
    return 0;
}</code></pre> 
<h2 id="%E7%AC%AC2%E5%85%B3%EF%BC%9A%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%80%86%E5%BA%8F">第2关：输出二叉树后序遍历的逆序</h2> 
<h4 id="%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0">任务描述</h4> 
<blockquote> 
 <p>题目描述： 采用先序法建立一棵二叉树，设计输出二叉树后序遍历的逆序，二叉树的数据域类型为字符型，扩展二叉树的叶子结点用‘<code>#</code>’表示，要求可以输出多棵二叉树的后序遍历逆序，当二叉树为空时程序结束。</p> 
</blockquote> 
<h4 id="%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E%C2%A0">测试说明 </h4> 
<blockquote> 
 <p><strong>输入描述：</strong>循环输入多棵扩展二叉树的先序遍历序列，每棵树占一行，以回车结束，每棵二叉树中结点之间以空格隔开</p> 
 <p><strong>输出描述：</strong>输出各二叉树后序遍历逆序，每次输出后面都换行，当二叉树为空时，输出“<code>NULL</code>”，程序结束。</p> 
</blockquote> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p><code>A B # # C D # E # F # # G H # I K # # # # </code></p> 
 <p><code>A B D H # # I # # E J # # K # # C F L # # M # # G N # # O # # </code></p> 
 <p><code>#</code></p> 
</blockquote> 
<p><strong>输出样例：</strong></p> 
<blockquote> 
 <p><code>A C G H I K D E F B </code></p> 
 <p><code>A C G O N F M L B E K J D I H </code></p> 
 <p><code>NULL</code></p> 
</blockquote> 
<h4 id="%E4%BB%A3%E7%A0%81%C2%A0">代码 </h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct BiNode {
    char data;
    struct BiNode *lchild, *rchild;
};

struct BiTree {
    struct BiNode *root;
};

struct Stack{
	char data[100];
	int top;
};

void Init(struct Stack *s)
{
	s-&gt;top = -1;
}

void Push(struct Stack *s, char x)
{
	s-&gt;data[++s-&gt;top] = x;
}

char Pop(struct Stack *s)
{
	return s-&gt;data[s-&gt;top--];
}

void Print(struct Stack *s)
{
	while (s-&gt;top != -1)
	{
		printf("%c ", Pop(s));
	}
}

struct BiNode *Create(struct BiNode *bt) {
    char ch;
    scanf("%c ", &amp;ch);
    if (ch == '#')
        bt = NULL;
    else {
        bt = (struct BiNode *)malloc(sizeof(struct BiNode));
        bt-&gt;data = ch;
        bt-&gt;lchild = Create(bt-&gt;lchild);
        bt-&gt;rchild = Create(bt-&gt;rchild);
    }
    return bt;
}

void RePreOrder(struct BiNode *bt, struct Stack *s) {
	//ToDo 递归输出二叉树后序遍历的逆序
	//========begin======
    if (bt == NULL)
    {
    	return;
	}
    else
	{
		RePreOrder(bt-&gt;lchild, s);
		RePreOrder(bt-&gt;rchild, s);
		Push(s, bt-&gt;data);
	}
	//=========end=======
}

int Empty(struct BiTree *tree) {
	//ToDo 判断是否为空
	//========begin======
   	if (tree-&gt;root == NULL)
   	{
   		return 1;
	}
	else
	{
		return 0;
	}
	//=========end=======
}

int main() {
    while (1) {
        struct BiTree A;
        //ToDo 设计主函数 以满足题意
		//========begin======
       	struct Stack s;
	    
		A.root = Create(A.root);
        Init(&amp;s);
        
        if (Empty(&amp;A))
        {
        	printf("NULL");
        	break;
		}
        
        RePreOrder(A.root, &amp;s);
        Print(&amp;s);
		printf("\n");
		//=========end=======
    }
    
    return 0;
}</code></pre> 
<h2 id="%C2%A0%E7%AC%AC3%E5%85%B3%EF%BC%9A%E6%8C%89%E4%B8%AD%E5%BA%8F%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%86%E6%94%AF%E7%BB%93%E7%82%B9"> 第3关：按中序输出二叉树中的分支结点</h2> 
<h4>任务描述</h4> 
<blockquote> 
 <p>题目描述： 二叉树的结点数据域是字符型，空结点用‘<code>#</code>’表示，按前序遍历建立二叉树，按中序输出二叉树中所有的分支结点，以空格隔开。</p> 
</blockquote> 
<h4 id="测试说明">测试说明</h4> 
<blockquote> 
 <p><strong>输入描述</strong>： 输入二叉树的扩展二叉树的前序遍历序列。</p> 
 <p><strong>输出描述</strong>： 按中序输出二叉树中所有的分支结点，以空格隔开，最后一个结点后面有空格，占一行。</p> 
</blockquote> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p><code>AB#C##D##</code></p> 
</blockquote> 
<p><strong>输出样例：</strong></p> 
<blockquote> 
 <p><code>B A</code></p> 
</blockquote> 
<h4 id="%C2%A0%E4%BB%A3%E7%A0%81"> 代码</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct BiNode {
    char data;
    struct BiNode *lchild, *rchild;
};

struct BiTree {
    struct BiNode *root;
};

struct BiNode *Create(struct BiNode *bt) {
    char ch;
    scanf(" %c", &amp;ch);
    if (ch == '#')
        return NULL;
    else {
        bt = (struct BiNode *)malloc(sizeof(struct BiNode));
        bt-&gt;data = ch;
        bt-&gt;lchild = Create(bt-&gt;lchild);
        bt-&gt;rchild = Create(bt-&gt;rchild);
    }
    return bt;
}

void InOrder(struct BiNode *bt) {
	//ToDo 中序输出分支节点
	//========begin=======
    if (bt == NULL)
    {
    	return;
	}
	else
	{
		InOrder(bt-&gt;lchild);
		
		if (bt-&gt;lchild != NULL || bt-&gt;rchild != NULL)
		{
			printf("%c ", bt-&gt;data);
		}
		
		InOrder(bt-&gt;rchild);
	}
	//=========end========
}

int Empty(struct BiTree *tree) {
    if (tree-&gt;root == NULL)
        return 1;
    else
        return 0;
}

int main() {
    struct BiTree btree;
	//ToDo 设计主函数 以满足题目需求
	//========begin=======
    btree.root = Create(btree.root);
    
    InOrder(btree.root);
	//=========end========
    return 0;
}</code></pre> 
<h2 id="%E7%AC%AC4%E5%85%B3%EF%BC%9A%E5%89%8D%E5%BA%8F%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E5%80%BC%E4%B8%8E%E5%B1%82%E6%AC%A1%E5%80%BC">第4关：前序输出二叉树节点值与层次值</h2> 
<h4>任务描述</h4> 
<blockquote> 
 <p>本关任务：设二叉树采用二叉链表存放，该结点结构为<code>[lchild,data,level,rchild]</code>, 将二叉树中每个结点所在的层次值置入相应的 <code>level</code> 域，并按前序序列顺序输出每个结点的值和 <code>level</code> 值。</p> 
</blockquote> 
<h4>测试说明</h4> 
<blockquote> 
 <p><strong>输入样例1: </strong><code>A B H # # # D # I E # # #</code></p> 
 <p><strong>输出样例1:</strong> <code>A 1 B 2 H 3 D 2 I 3 E 4</code></p> 
 <p><strong>输入样例2:</strong> <code>A B # # C # #</code></p> 
 <p><strong>输出样例2: </strong><code>A 1 B 2 C 2</code></p> 
 <p><strong>输入样例3:</strong> <code>A B D # # E # # C # #</code></p> 
 <p><strong>输出样例3:</strong> <code>A 1 B 2 D 3 E 3 C 2 </code></p> 
</blockquote> 
<h4>代码 </h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct BiNode {
	char data;
	int level;
struct BiNode *lchild, *rchild;
};

struct BiTree {
	struct BiNode *root;
};

struct BiNode* Creat(struct BiNode* bt) {
	char ch;
	scanf(" %c", &amp;ch);
	if (ch == '#')
	return NULL;
	else {
	bt = (struct BiNode*)malloc(sizeof(struct BiNode));
	bt-&gt;data = ch;
	bt-&gt;lchild = Creat(bt-&gt;lchild);
	bt-&gt;rchild = Creat(bt-&gt;rchild);
}
	return bt;
}

void level(struct BiNode* bt, int l) {
	//TODO 将bt中level设置成当前层次值并打印、继续递归左右节点
	//=======begin======
	if (bt == NULL)
	{
		return;
	}
	else
	{
		printf("%c %d ", bt-&gt;data, l);
		level(bt-&gt;lchild, ++l);
		level(bt-&gt;rchild, l);
	}
	//========end=======
}

void preOrder(struct BiNode* bt) {
	if (bt != NULL) {
	preOrder(bt-&gt;lchild);
    if ((bt-&gt;lchild == NULL &amp;&amp; bt-&gt;rchild != NULL) || (bt-&gt;lchild != NULL &amp;&amp; bt-&gt;rchild == NULL)) {
        printf("%c ", bt-&gt;data);
    }
    preOrder(bt-&gt;rchild);
}
}

int Empty(struct BiTree* tree) {
	if (tree-&gt;root == NULL)
	return 1;
	else
	return 0;
}

int main() {
	struct BiTree btree;
	btree.root = Creat(btree.root);
	level(btree.root, 1);
	printf("\n");
	return 0;
}</code></pre> 
<h2 id="%C2%A0%E7%AC%AC5%E5%85%B3%EF%BC%9A%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0"> 第5关：求二叉树中结点个数</h2> 
<h4>任务描述</h4> 
<blockquote> 
 <p>题目描述： 建立一棵二叉树，用二叉链表存储二叉树，计算二叉树中包含的结点个数。</p> 
</blockquote> 
<h4>测试说明</h4> 
<blockquote> 
 <p><strong>输入描述：</strong> 输入的数据只有一组，是一棵二叉树的先序遍历序列，结点的值为一个小写字母，<code>＃</code>号表示空结点，如输入：<code>a b d e # # f # # # c # #</code>，数据之间空一个格，得到的二叉树如下。</p> 
 <p><strong>输出描述：</strong> 输出二叉树的结点个数，空树输出<code>NULL</code>。</p> 
</blockquote> 
<blockquote> 
 <p><strong>输入样例1： </strong><code>a b c # # # d e # # f # # </code> <strong>输出样例1</strong>： <code>6</code></p> 
 <p><strong>输入样例2：</strong> <code>#                </code><strong>输出样例2</strong>： <code>0</code></p> 
</blockquote> 
<h4> 代码</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Binode {
	char data;
	struct Binode* lchild;
	struct Binode* rchild;
};

struct Bitree {
	struct Binode* root;
};

struct Binode* Creat(struct Binode* bt) {
	char d;
	scanf(" %c", &amp;d);
	if (d == '#')
	bt = NULL;
	else {
	bt = (struct Binode*)malloc(sizeof(struct Binode));
	bt-&gt;data = d;
	bt-&gt;lchild = Creat(bt-&gt;lchild);
	bt-&gt;rchild = Creat(bt-&gt;rchild);
}
	return bt;
}

void Release(struct Binode* bt) {
	if (bt != NULL) {
	Release(bt-&gt;lchild);
	Release(bt-&gt;rchild);
	free(bt);
}
}

int Count(struct Binode* bt) {
	//ToDo 计算节点个数
	//=======begin======
	if (bt == NULL)
	{
		return 0;
	}
	
	return Count(bt-&gt;lchild) + Count(bt-&gt;rchild) + 1;
	//=======begin======
}

int main() {
	//ToDo 设计主函数 以满足题意需求
	//=======begin======
	struct Bitree btree;
	
	btree.root = Creat(btree.root);
	printf("%d", Count(btree.root));
	Release(btree.root);
	//=======begin======
}</code></pre> 
<h2 id="%E7%AC%AC6%E5%85%B3%EF%BC%9A%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0">第6关：求二叉树叶子结点数</h2> 
<h4>任务描述</h4> 
<blockquote> 
 <p>题目描述: 二叉树结点的数据类型是字符型，按先序遍历建立二叉树，求叶子结点的个数。</p> 
</blockquote> 
<h4>测试说明</h4> 
<blockquote> 
 <p><strong>输入描述</strong>: 输入扩展二叉树的先序遍历序列，其中空字符为“<code>#</code>”，以空格隔开.</p> 
 <p><strong>输出描述</strong>: 输出叶子结点的个数.</p> 
</blockquote> 
<p><strong>输入样例:</strong></p> 
<blockquote> 
 <p><code>A B D H # # # E # I # # C F J # # # G # #</code></p> 
</blockquote> 
<p><strong>输出样例:</strong></p> 
<blockquote> 
 <p><code>4</code></p> 
</blockquote> 
<h4>代码 </h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct BiNode {
	char data;
struct BiNode* lchild;
struct BiNode* rchild;
};

int j = 0;

struct BiNode* Creat(struct BiNode* bt) {
	//TODO：前序建立二叉树
	//========begin=======
	char ch;
	
	scanf(" %c", &amp;ch);
	
	if (ch == '#')
	{
		bt = NULL;
	}
	else
	{
		bt = (struct BiNode*)malloc(sizeof(struct BiNode));
		bt-&gt;data = ch;
		bt-&gt;lchild = Creat(bt-&gt;lchild);
		bt-&gt;rchild = Creat(bt-&gt;rchild);
	}
	
	return bt;
	//=========end========
}

void Release(struct BiNode* bt) {
	//TODO：后续销毁二叉树
	//========begin=======
	if (bt != NULL)
	{
		Release(bt-&gt;lchild);
		Release(bt-&gt;rchild);
		free(bt);
	}
	//=========end========
}

void Preorder(struct BiNode* bt) {
	//TODO：前序遍历求叶子结点数
	//========begin=======
	if (bt == NULL)
	{
		return;
	}
	else
	{
		if (bt-&gt;lchild == NULL &amp;&amp; bt-&gt;rchild == NULL)
		{
			j++;
		}
		
		Preorder(bt-&gt;lchild);
		Preorder(bt-&gt;rchild);		
	}
	//=========end========
}

int main() {
	struct BiNode* root = NULL;
	root = Creat(root);
	Preorder(root);
	printf("%d\n", j);
	Release(root);
	return 0;
}</code></pre> 
<h2 id="%C2%A0%E7%AC%AC7%E5%85%B3%EF%BC%9A%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"> 第7关：求二叉树的深度</h2> 
<h4>任务描述</h4> 
<blockquote> 
 <p>题目描述 采用先序法建立一棵二叉树，设计求该二叉树的深度，二叉树的数据域类型为字符型，扩展二叉树的叶子结点用‘<code>#</code>’表示，要求可以求多棵二叉树的深度，当二叉树的深度为 0 时程序结束。</p> 
</blockquote> 
<h4>测试说明</h4> 
<blockquote> 
 <p><strong>输入描述</strong>: 循环输入多棵扩展二叉树的先序遍历序列，每棵树占一行，以回车结束，每棵二叉树中结点之间以空格隔开.</p> 
 <p><strong>输出描述</strong>: 输出各二叉树的深度，每次输出后面都换行.</p> 
</blockquote> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p><code>A B # # C D # E # F # # G H # I K # # # # </code></p> 
 <p><code>A B D H # # I # # E J # # K # # C F L # # M # # G N # # O # # </code></p> 
 <p><code>#</code></p> 
</blockquote> 
<p><strong>输出样例：</strong></p> 
<blockquote> 
 <p><code>6</code></p> 
 <p><code>4</code></p> 
 <p><code>0</code></p> 
</blockquote> 
<h4>代码 </h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct BiNode {
	char data;
struct BiNode* lchild;
struct BiNode* rchild;
};

struct BiTree {
struct BiNode* root;
};

struct BiNode* Creat(struct BiNode* bt) {
	char ch;
	scanf(" %c", &amp;ch);
	if (ch == '#')
	bt = NULL;
	else {
	bt = (struct BiNode*)malloc(sizeof(struct BiNode));
	bt-&gt;data = ch;
	bt-&gt;lchild = Creat(bt-&gt;lchild);
	bt-&gt;rchild = Creat(bt-&gt;rchild);
}
	return bt;
}

int Depth(struct BiNode* bt) {
	//ToDo 递归求最大深度
	//========BEGIN=======
	if (bt == NULL)
	{
		return 0;
	}
	
	int left = Depth(bt-&gt;lchild);
	int right = Depth(bt-&gt;rchild);
	
	return left &gt; right ? (left+1) : (right+1);
	//=========END========
}

int main() {
	while (1) {
	struct BiTree A;
	//ToDo 设计主函数 以满足题意
	//========BEGIN=======
	A.root = Creat(A.root);
	
	printf("%d\n", Depth(A.root));	
	
	if (Depth(A.root) == 0)
	{
		break;
	}
	//=========END========
}
	return 0;
}</code></pre> 
<h2 id="%E7%AC%AC8%E5%85%B3%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%A4%E6%8D%A2%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91">第8关：二叉树交换左右子树</h2> 
<h4>任务描述</h4> 
<blockquote> 
 <p>本关任务：二叉树的结点数据域是字符型，空用‘<code>#</code>’表示，按前序遍历建立二叉树，交换二叉树中所有结点的左右子树，再前序遍历输出。</p> 
</blockquote> 
<h4>测试说明</h4> 
<blockquote> 
 <p><strong>输入样例1:</strong> <code>A B # # C # #</code>                                 <strong>输出样例1:</strong> <code>A C B </code></p> 
 <p><strong>输入样例2:</strong> <code>A B H # # # D C # # I E # # #</code>    <strong>输出样例2:</strong> <code>A D I E C B H </code></p> 
 <p><strong>输入样例3:</strong> <code>A B D # # E # # C # #</code>                   <strong>输出样例3</strong>: <code>A C B E D </code></p> 
</blockquote> 
<h4>代码 </h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct BiNode {
    char data;
    struct BiNode* lchild;
    struct BiNode* rchild;
};

struct BiNode* Creat(struct BiNode* bt) {
    char ch;
    scanf(" %c", &amp;ch);
    if (ch == '#')
        return NULL;
    else {
        bt = (struct BiNode*)malloc(sizeof(struct BiNode));
        bt-&gt;data = ch;
        bt-&gt;lchild = Creat(bt-&gt;lchild);
        bt-&gt;rchild = Creat(bt-&gt;rchild);
    }
    return bt;
}

void Change(struct BiNode* bt) {
	//TODO 交换左右子树 并将子树继续交换
	//==========begin=========
    if (bt == NULL)
    {
    	return;
	}
	else
	{
		struct BiNode* temp = bt-&gt;lchild;
		bt-&gt;lchild = bt-&gt;rchild;
		bt-&gt;rchild = temp;
		Change(bt-&gt;lchild);
		Change(bt-&gt;rchild);
	}
	//===========end==========
}

void Print(struct BiNode* bt) {
	printf("%c ", bt-&gt;data);
	if (bt-&gt;lchild != NULL)
		Print(bt-&gt;lchild);
	if (bt-&gt;rchild != NULL)
		Print(bt-&gt;rchild);
}

int Empty(struct BiNode* root) {
    if (root == NULL)
        return 1;
    else
        return 0;
}

int main() {
	struct BiNode* root = NULL;
	root = Creat(root);

	if (Empty(root))
		return 0;

	Change(root);
	Print(root);

	return 0;
}</code></pre> 
<h2 id="%E7%AC%AC9%E5%85%B3%EF%BC%9A%E6%8C%89%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%AC%A1%E5%BA%8F%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%A6%E4%B8%BA1%E7%9A%84%E7%BB%93%E7%82%B9">第9关：按中序遍历次序输出二叉树中度为1的结点</h2> 
<h4>任务描述</h4> 
<blockquote> 
 <p>本关任务：二叉树的结点数据域是字符型，空结点用‘<code>#</code>’表示，按前序遍历建立二叉树，按中序输出二叉树中度为 1 的结点。</p> 
</blockquote> 
<h4>测试说明</h4> 
<blockquote> 
 <p><strong>输入样例1:</strong> <code>A B H # # # D # I E # # # </code><strong>输出样例1:</strong> <code>B D I </code></p> 
 <p><strong>输入样例2:</strong> <code>A # B # #            </code><strong>输出样例2:</strong> <code>A </code></p> 
 <p><strong>输入样例3:</strong> <code>A B C D # # # # #       </code><strong>输出样例3:</strong> <code>C B A </code></p> 
</blockquote> 
<h4> 代码</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct BiNode {
    char data;
    struct BiNode *lchild;
    struct BiNode *rchild;
};

typedef struct BiNode BiNode;

/*前序建立二叉树*/
BiNode *createBiTree() {   
    char ch;
    scanf("%c ", &amp;ch);
    if (ch == '#') {
        return NULL;
    } else {
        BiNode *node = (BiNode *) malloc(sizeof(BiNode));
        node-&gt;data = ch;
        node-&gt;lchild = createBiTree();
        node-&gt;rchild = createBiTree();
        return node;
    }
}
void inOrderTraversal(BiNode *root) {
    /*按中序输出二叉树中度为1的结点*/
	/*=========begin========*/
    if (root == NULL)
    {
    	return;
	}
	else
	{
		inOrderTraversal(root-&gt;lchild);
		
		if ((root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild != NULL) || (root-&gt;lchild != NULL &amp;&amp; root-&gt;rchild == NULL))
		{
			printf("%c ", root-&gt;data);
		}
		
		inOrderTraversal(root-&gt;rchild);
	}
	/*==========end========*/
}

int main() {
    
    BiNode *root = createBiTree();    /*前序建立二叉树*/
    
    inOrderTraversal(root);           /*中序输出度为1的结点*/
    printf("\n");
    return 0;
}
</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f100afadf36737989344bb0ecced2fcb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">车载电子电器架构 ——电子电气架构设计方案概述</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1dc2eaf87ef65333e5f719076c58136/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32——USART串口协议</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>