<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java三年工作经验面试题整理《精华》 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java三年工作经验面试题整理《精华》" />
<meta property="og:description" content="JDK 和 JRE 有什么区别？
JDK：java 开发工具包，提供了 java 的开发环境和运行环境。
JRE：java 运行环境，为 java 的运行提供了所需环境。
JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具，如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。
== 和 equals 的区别是什么？
对于基本类型和引用类型 == 的作用效果是不同的：
基本类型：比较的是值是否相同； 引用类型：比较的是引用是否相同；
String x = &#34;string&#34;;
String y = &#34;string&#34;;
String z = new String(&#34;string&#34;);
System.out.println(x==y); // true
System.out.println(x==z); // false
System.out.println(x.equals(y)); // true
System.out.println(x.equals(z)); // true
两个对象的 hashCode()相同，equals()不一定 true。
在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。
final 在 java 中有什么作用？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/19b23c65acfef3fd63f30c2c14d32d58/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-09T10:49:59+08:00" />
<meta property="article:modified_time" content="2022-12-09T10:49:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java三年工作经验面试题整理《精华》</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">JDK 和 JRE 有什么区别</span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">JDK：java 开发工具包，提供了 java 的开发环境和运行环境。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">JRE：java 运行环境，为 java 的运行提供了所需环境。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">，</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">== 和 equals 的区别是什么？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">对于基本类型和引用类型 == 的作用效果是不同的</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">：</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">基本类型：比较的是值是否相同；</span></span>    </p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">引用类型：比较的是引用是否相同；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#333333;">String x = </span><span style="color:#dd1144;">"string"</span><span style="color:#333333;">;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#333333;">String y = </span><span style="color:#dd1144;">"string"</span><span style="color:#333333;">;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#333333;">String z = </span><span style="color:#ca7d37;">new</span><span style="color:#333333;"> String(</span><span style="color:#dd1144;">"string"</span><span style="color:#333333;">);</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#333333;">System.</span><span style="color:#ca7d37;">out</span><span style="color:#333333;">.println(x==y); </span><em><span style="color:#afafaf;"><em>// true</em></span></em></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#333333;">System.</span><span style="color:#ca7d37;">out</span><span style="color:#333333;">.println(x==z); </span><em><span style="color:#afafaf;"><em>// false</em></span></em></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#333333;">System.</span><span style="color:#ca7d37;">out</span><span style="color:#333333;">.println(x.</span><span style="color:#ca7d37;">equals</span><span style="color:#333333;">(y)); </span><em><span style="color:#afafaf;"><em>// true</em></span></em></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#333333;">System.</span><span style="color:#ca7d37;">out</span><span style="color:#333333;">.println(x.</span><span style="color:#ca7d37;">equals</span><span style="color:#333333;">(z)); </span><em><span style="color:#afafaf;"><em>// true</em></span></em></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;"><strong>两个对象的 hashCode()相同，equals()不一定 true</strong></span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;"><strong>。</strong></span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">final 在 java 中有什么作用？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">final 修饰的类叫最终类，该类不能被继承。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">final 修饰的方法不能被重写</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong> </strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">java 中的 Math.round(-1.5) 等于多少？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">String 属于基础的数据类型吗？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">java 中操作字符串都有哪些类？它们之间有什么区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">操作字符串的类有：String、StringBuffer、StringBuilder。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">String str="i"与 String str=new String("i")一样吗？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">如何将字符串反转？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">String 类的常用方法都有那些？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">indexOf()：返回指定字符的索引。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">charAt()：返回指定索引处的字符。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">replace()：字符串替换。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">trim()：去除字符串两端空白。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">split()：分割字符串，返回一个分割后的字符串数组。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">getBytes()：返回字符串的 byte 类型数组。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">length()：返回字符串长度。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">toLowerCase()：将字符串转成小写字母。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">toUpperCase()：将字符串转成大写字符。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">substring()：截取字符串。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">equals()：字符串比较。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">抽象类必须要有抽象方法吗？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">不需要，抽象类不一定非要有抽象方法。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">普通类和抽象类有哪些区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">普通类不能包含抽象方法，抽象类可以包含抽象方法。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">抽象类不能直接实例化，普通类可以直接实例化。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">抽象类能使用 final 修饰吗？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">接口和抽象类有什么区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">构造函数：抽象类可以有构造函数；接口不能有。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">java 中 IO 流分为几种？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">按功能来分：输入流（input）、输出流（output）。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">按类型来分：字节流和字符流。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">BIO、NIO、AIO 有什么区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">Files的常用方法都有哪些？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Files.exists()：检测文件路径是否存在。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Files.createFile()：创建文件。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Files.createDirectory()：创建文件夹。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Files.delete()：删除一个文件或目录。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Files.copy()：复制文件。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Files.move()：移动文件。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Files.size()：查看文件个数。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Files.read()：读取文件。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Files.write()：写入文件。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#1a1a1a;">Collection 和 Collections 有什么区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">HashMap 和 Hashtable 有什么区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">hashTable同步的，而HashMap是非同步的，效率上</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">比</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">hashTable要高。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">hashMap允许空键值，而hashTable不允许。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">如何决定使用 HashMap 还是 TreeMap？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下 HashMap 的实现原理？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下 HashSet 的实现原理？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">HashSet底层由HashMap实现</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">HashSet的值存放于HashMap的key上</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">HashMap的value统一为PRESENT</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">ArrayList 和 LinkedList 的区别是什么？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">如何实现数组和 List 之间的转换？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">List转换成为数组：调用ArrayList的toArray方法。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">数组转换成为List：调用Arrays的asList方法。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">ArrayList 和 Vector 的区别是什么？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 </span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">ArrayList比Vector快，它因为有同步，不会过载。 </span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">Array 和 ArrayList 有何区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Array可以容纳基本类型和对象，而ArrayList只能容纳对象。 </span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Array是指定大小的，而ArrayList大小</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">不</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">是固定的。 </span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">在 Queue 中 poll()和 remove()有什么区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">哪些集合类是线程安全的？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">statck：堆栈类，先进后出。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">hashtable：就比hashmap多了个线程安全。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">enumeration：枚举，相当于迭代器。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">并行和并发有什么区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">线程和进程的区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">守护线程是什么？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">创建线程有哪几种方式？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">①</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">继承Thread类创建线程类</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">创建Thread子类的实例，即创建了线程对象。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">调用线程对象的start()方法来启动该线程。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">②通过Runnable接口创建线程类</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">调用线程对象的start()方法来启动该线程。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">③通过Callable和Future创建线程</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">使用FutureTask对象作为Thread对象的target创建并启动新线程。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下 runnable 和 callable 有什么区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">线程有哪些状态？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">sleep() 和 wait() 有什么区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">notify()和 notifyAll()有什么区别？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">线程的 run()和 start()有什么区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">调</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">创建线程池有哪几种方式？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">①.newFixedThreadPool(int nThreads)</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">②. newCachedThreadPool()</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">③. newSingleThreadExecutor()</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">④. newScheduledThreadPool(int corePoolSize)</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">线程池中 submit()和 execute()方法有什么区别？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">接收的参数不一样</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">submit有返回值，而execute没有</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">submit方便Exception处理</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">在 java 程序中怎么保证多线程的运行安全？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">线程安全在三个方面体现：</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">多线程锁的升级原理是什么？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</span></span></p> 
<h2 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">偏向锁、轻量级锁和重量级锁对比</span></span></strong></strong></span></h2> 
<table cellspacing="0" style="margin-left:4.65pt;"><tbody><tr><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#4f4f4f;"><strong>锁类型</strong></span></strong></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#4f4f4f;"><strong>优点</strong></span></strong></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#4f4f4f;"><strong>缺点</strong></span></strong></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#4f4f4f;"><strong>适用场景</strong></span></strong></p> </td></tr><tr><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><span style="color:#4f4f4f;">偏向锁</span></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><span style="color:#4f4f4f;">加锁、解锁不需要额外资源消耗，效率较高</span></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><span style="color:#4f4f4f;">如果线程间存在锁竞争，会带来额外的解锁消耗</span></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><span style="color:#4f4f4f;">适用只有一个线程访问同步块的情景</span></p> </td></tr><tr><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><span style="color:#4f4f4f;">轻量级锁</span></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><span style="color:#4f4f4f;">竞争的线程不会阻塞，提高了程序响应速度</span></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><span style="color:#4f4f4f;">如果获取锁失败，会进入自旋消耗cpu</span></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><span style="color:#4f4f4f;">针对锁占用时间短，对响应时间比较敏感的情况</span></p> </td></tr><tr><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><span style="color:#4f4f4f;">重量级锁</span></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><span style="color:#4f4f4f;">线程竞争不使用自旋，不消耗cpu</span></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><span style="color:#4f4f4f;">线程会被阻塞，影响响应时间</span></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:left;"><span style="color:#4f4f4f;">锁占用时间较长，对吞吐量要求较高</span></p> </td></tr></tbody></table> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">什么是死锁？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">怎么防止死锁？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">死锁的四个必要条件：</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">ThreadLocal 是什么？有哪些使用场景？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下 synchronized 底层实现原理？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">普通同步方法，锁是当前实例对象</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">静态同步方法，锁是当前类的class对象</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">同步方法块，锁是括号里面的对象</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">synchronized 和 volatile 的区别是什么？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">volatile能实现变量的修改可见性</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">、</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">有序性</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">synchronized 和 Lock 有什么区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">synchronized 和 ReentrantLock 区别是什么？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： </span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 </span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">ReentrantLock可以获取各种锁的信息</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">ReentrantLock可以灵活地实现多路通知 </span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下 atomic 的原理？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">什么情况下需要序列化？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；</span></span><br><span style="background-color:#ffffff;"><span style="color:#222222;">b）当你想用套接字在网络上传送对象的时候；</span></span><br><span style="background-color:#ffffff;"><span style="color:#222222;">c）当你想通过RMI传输对象的时候；</span></span></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">动态代理是什么？有哪些应用？</span></span></strong></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#222222;">当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">动态代理的应用：</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Spring的AOP</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">加事务</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">加权限</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">加日志</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">怎么实现动态代理？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">深拷贝和浅拷贝区别是什么？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">session 和 cookie 有什么区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下 session 的工作原理？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">如果客户端禁止 cookie 能实现 session 还能用吗？</span></span></strong></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#222222;">不能，</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</span></span></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">throw 和 throws 的区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#222222;">throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。</span></span></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">final、finally、finalize 有什么区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。 </span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">常见的异常类有哪些？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">NullPointerException：当应用程序试图访问空对象时，则抛出该异常。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">SQLException：提供关于数据库访问错误或其他错误信息的异常。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 </span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 </span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">NoSuchMethodException：无法找到某一特定方法时，抛出该异常。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">UnsupportedOperationException：当不支持请求的操作时，抛出该异常。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">RuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">简述 tcp 和 udp的区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">TCP对系统资源要求较多，UDP对系统资源要求较少。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">tcp 为什么要三次握手，两次不行吗？为什么？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">OSI 的七层模型都有哪些？</span></span></strong></span></p> 
<h4 style="margin-left:0pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">应用层：网络服务与最终用户的一个接口。</span></span></strong></h4> 
<h4 style="margin-left:0pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">表示层：数据的表示、安全、压缩。</span></span></strong></h4> 
<h4 style="margin-left:0pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">会话层：建立、管理、终止会话。</span></span></strong></h4> 
<h4 style="margin-left:0pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">传输层：定义传输数据的协议端口号，以及流控和差错校验。</span></span></strong></h4> 
<h4 style="margin-left:0pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。</span></span></strong></h4> 
<h4 style="margin-left:0pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。</span></span></strong></h4> 
<h4 style="margin-left:0pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">物理层：建立、维护、断开物理连接。</span></span></strong></h4> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">get 和 post 请求有哪些区别？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">GET在浏览器回退时是无害的，而POST会再次提交请求。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">GET请求会被浏览器主动cache，而POST不会，除非手动设置。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">GET请求只能进行url编码，而POST支持多种编码方式。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">GET请求在URL中传送的参数是有长度限制的，而POST么有。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">GET参数通过URL传递，POST放在Request body中。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">如何实现跨域？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">方式</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">一</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">：JSONP跨域</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">方式</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">二</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">：CORS</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">解释一下什么是 aop？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">AOP是OOP的补充和完善。</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">解释一下什么是 ioc？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong> </strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">spring 常用的注入方式有哪些？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">构造方法注入</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">setter注入</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">基于注解的注入</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">spring 中的 bean 是线程安全的吗？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">spring 支持几种 bean 的作用域？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：</span></span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">session：对于每次HTTP Session，使用session定义的Bean</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">都将</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong> </strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">spring 自动装配 bean 有哪些方式？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">spring中bean装配有两种方式：</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">隐式的bean发现机制和自动装配</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">在java代码或者XML中进行显示配置</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">spring 事务实现方式有哪些？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">基于 TransactionProxyFactoryBean 的声明式事务管理</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">基于 @Transactional 的声明式事务管理</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">基于 Aspectj AOP 配置事务</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下 spring 的事务隔离？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">脏读：一个事务读到另一个事务未提交的更新数据。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。</span></span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<h2 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">幻读和不可重复读的区别?</span></span></strong></strong></span></h2> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">不可重复读</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">幻读</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">重点在于新增或者删除：在同一事务中，同样的条件,第一次和第二次读出来的记录数不一样。</span></span></span></p> 
<h3 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">MySQL如何解决不可重复读</span></span></strong></strong></span></h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">●</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">MySQL中，默认使用的事务隔离界别是可重复读，为了解决不可重复读问题，InnoDB采用了MVCC(多版本并发控制)【基于乐观锁】来解决！</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">●</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">MVCC(多版本并发控制)是利用在每条数据后面加了隐藏的两列（创建版本号和删除版本号），每个事务在开始的时候都会有一个递增的当前事务版本号！</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下 spring mvc 运行流程？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">1. 用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">2. DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；   </span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">3. DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(...)方法）</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">4.  提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 </span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">5.  Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；   </span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">6.  根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">7. ViewResolver 结合Model和View，来渲染视图； </span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">8. 将渲染结果返回给客户端。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">spring mvc 有哪些组件？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">Spring MVC的核心组件：</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">DispatcherServlet：中央控制器，把请求给转发到具体的控制类</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">Controller：具体处理请求的控制器</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">ModelAndView：服务层返回的数据和视图层的封装类</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">ViewResolver：视图解析器，解析具体的视图</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">@RequestMapping 的作用是什么？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">为什么要用 spring boot？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Spring Boot使编码变简单</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Spring Boot使配置变简单</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Spring Boot使部署变简单</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Spring Boot使监控变简单</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">spring boot 核心配置文件是什么？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">properties文件</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">yml文件</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">spring cloud 的核心组件有哪些？</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">服务发现——Netflix Eureka</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">客服端负载均衡——Netflix Ribbon</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">断路器——Netflix Hystrix</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">服务网关——Netflix Zuul</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">分布式配置——Spring Cloud Config</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#222222;">mybatis 中 #{}和 ${}的区别是什么？</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">#{}是预编译处理，${}是字符串替换；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Mybatis在处理${}时，就是把${}替换成变量的值；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">使用#{}可以有效的防止SQL注入，提高系统安全性。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">rabbitmq 的使用场景有哪些？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">跨系统的异步通信，所有需要异步交互的地方都可以使用消息队列。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">多个应用之间的松耦合的接口</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">应用内的同步变异步</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">rabbitmq 有哪些重要的角色？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">生产者、消费者和代理</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">rabbitmq 有哪些重要的组件？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">ConnectionFactory（连接管理器）</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Channel（信道）</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Exchange（交换器）</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Queue（队列）</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">RoutingKey（路由键）</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">BindingKey（绑定键）</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong> </strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">rabbitmq 的消息是怎么发送的？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">rabbitmq 怎么保证消息的稳定性？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">提供了事务的功能。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">通过将 channel 设置为 confirm（确认）模式。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">rabbitmq 怎么避免消息丢失？</span></span></strong></p> 
<p><strong><span style="background-color:#ffffff;"><span style="color:#222222;">消息持久化</span></span></strong></p> 
<p><strong><span style="background-color:#ffffff;"><span style="color:#222222;">ACK确认机制</span></span></strong></p> 
<p><strong><span style="background-color:#ffffff;"><span style="color:#222222;">设置集群镜像模式</span></span></strong></p> 
<p><strong><span style="background-color:#ffffff;"><span style="color:#222222;">消息补偿机制</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">要保证消息持久化成功的条件有哪些？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">声明队列必须设置持久化 durable 设置为 true.</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">消息已经到达持久化交换器。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">消息已经到达持久化队列。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">rabbitmq 持久化有什么缺点？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">持久化的缺</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">点</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">rabbitmq 有几种广播类型？</span></span></strong></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">三种广播模式：</span></span></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#222222;">fanout: 所有bind到此exchange的queue都可以接收消息（纯广播，绑定到RabbitMQ的接受者都能收到消息）；</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#222222;">direct: 通过routingKey和exchange决定的那个唯一的queue可以接收消息；</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#222222;">topic:所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息；</span></span></p> 
<p style="margin-left:0;text-align:left;"><strong> </strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">rabbitmq 怎么实现延迟消息队列？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</span></span></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">rabbitmq 集群有什么用？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">集群主要有以下两个用途：</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">高容量：集群可以承载更多的消息量。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">rabbitmq 节点的类型有哪些？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">磁盘节点：消息会存储到磁盘。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">rabbitmq 对集群节点停止顺序有要求吗？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#222222;">kafka 可以脱离 zookeeper 单独使用吗？为什么？</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">kafka 有几种数据保留的策略？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#222222;">什么情况会导致 kafka 运行变慢？</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">cpu 性能瓶颈</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">磁盘读写瓶颈</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">网络瓶颈</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">使用 kafka 集群需要注意什么？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#222222;">zookeeper 都有哪些功能？</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">集群管理：监控节点存活状态、运行请求等。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">zookeeper 有几种部署模式？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">有三种部署模式：单机部署</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">、</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">集群部署</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">、</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">伪集群部署</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#222222;">zookeeper 怎么保证主从节点的状态同步？</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">集群中为什么要有主节点？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#222222;">集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下 zookeeper 的通知机制？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">客户端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下 ACID 是什么？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#222222;">mysql 的内连接、左连接、右连接有什么区别？</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">mysql 索引是怎么实现的？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">怎么验证 mysql 的索引是否满足需求？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">显示查询使用了哪一种类型，从最好到最差依次是：</span></span><br><span style="background-color:#ffffff;"><span style="color:#222222;">System &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">一般来说，得保证查询到range级别，最好能到ref级别。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下 mysql 常用的引擎？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#222222;">说一下 mysql 的行锁和表锁？</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</span></span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下乐观锁和悲观锁？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">如何做 mysql 的性能优化？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">为搜索字段创建索引。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">避免使用 select *，列出需要查询的字段。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">尽量把字段设置为NOT NULL</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;">.</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">不要在where条件中使用左右两边都是%的like模糊查询</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">尽量不要使用in 和not in，会造成全表扫描</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">尽量不要使用or，会造成全表扫描</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">尽量不要在 where 子句中对字段进行表达式操作，这样也会造成全表扫描</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#222222;">redis 有哪些功能？</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">数据缓存功能</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">分布式锁的功能</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">支持数据持久化</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">支持事务</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">支持消息队列</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">redis 为什么是单线程的？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">什么是缓存穿透</span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">、</span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">缓存击穿、缓存雪崩</span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">？怎么解决？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">解决方案：</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">采用</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">布隆过滤器</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">接口校验</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">如果一个查询返回的数据为空</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">，</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">仍然</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。（一个key失效）</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">解决方案：根据key获取value值为空时，锁上，从数据库中load数据后再释放锁。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。（多个key失效）。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">解决方案：可以给缓存的过期时间加上一个随机值时间，使得每个 key 的过期时间分布开来，不会集中在同一时刻失效。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">redis 支持的数据类型有哪些？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#121212;">string、list、hash、set、zset。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#222222;"> 怎么保证缓存和数据库数据的一致性？</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">合理设置缓存的过期时间。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">redis 持久化有几种方式？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">RDB：指定的时间间隔能对你的数据进行快照存储。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">AOF：每一个收到的写命令都通过write函数追加到文件中。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">redis 怎么实现分布式锁？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">一般使用 setnx指令，只允许被一个程序占有，使用完调用 del 释放锁。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">Redis的过期策略：</span></span></strong></p> 
<p style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">定时过期</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">、</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">惰性过期</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">、定期过期。</span></span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">redis 淘汰策略有哪些？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">no-enviction（驱逐）：禁止驱逐数据。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">redis 常见的性能问题有哪些？该如何解决？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;"> 说一下 jvm 的主要组成部分？及其作用？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">类加载器</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">运行时数据区</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">执行引擎</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">本地库接口</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">组件的作用： 首先通过类加载器会把 Java 代码转换成字节码，运行时数据区再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">给</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">底层操作系统去执行，因此需要特定的命令解析器执行引擎，将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口来实现整个程序的功能。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#222222;">说一下 jvm 运行时数据区？</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">程序计数器</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">虚拟机栈</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">本地方法栈</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">堆</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">方法区</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下堆栈的区别？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">栈内存存储的是局部变量而堆内存存储的是实体；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">什么是双亲委派模型？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下类加载的执行过程？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">类加载分为以下 5 个步骤：</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">加载：根据查找路径找到相应的 class 文件然后导入；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">检查：检查加载的 class 文件的正确性；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">准备：给类中的静态变量分配内存空间；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">初始化：对静态变量和静态代码块执行初始化工作。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">怎么判断对象是否可以被回收？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">java 中都有哪些引用类型？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">强引用</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">软引用</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">弱引用</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">虚引用</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下 jvm 有哪些垃圾回收算法？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">标记-清除算法</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">标记-整理算法</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">复制算法</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">分代算法</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#222222;">新生代垃圾回收器和老生代垃圾回收器都有哪些？</span></strong><strong><span style="color:#222222;">有什么区别？</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">新生代回收器：Serial、ParNew、Parallel Scavenge</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">老年代回收器：Serial Old、Parallel Old、CMS</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">整堆回收器：G1</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;"> 简述分代垃圾回收器是怎么工作的？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">把 Eden + From Survivor 存活的对象放入 To Survivor 区；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">清空 Eden 和 From Survivor 分区；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">From Survivor 和 To Survivor 分区交换，每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">说一下 jvm 调优的工具？</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">jconsole：用于对 JVM 中的内存、线程和类等进行监控；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">常用的 jvm 调优的参数都有哪些？</span></span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">-Xms2g：初始化</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">堆</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">大小为 2g；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">-Xmx2g：堆最大内存为 2g；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">-XX:+PrintGC：开启打印 gc 信息；</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">-XX:+PrintGCDetails：打印 gc 详细信息。</span></span></p> 
<h2 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">spring中创建bean的三种方式：</span></span></strong></strong></span></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">通过默认无参</span></span><a href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95&amp;spm=1001.2101.3001.7020" title="构造方法">构造方法</a><span style="background-color:#ffffff;"><span style="color:#222222;">创建</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">使用静态工厂的方法创建对象</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">使用实例工厂的方法创建对象</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">；</span></span></p> 
<h2 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">Spring框架中Bean的创建过程：</span></span></strong></strong></span></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</span></span><br><span style="background-color:#ffffff;"><span style="color:#333333;">1. 实例化;</span></span><br><span style="background-color:#ffffff;"><span style="color:#333333;">2. 设置属性值;</span></span><br><span style="background-color:#ffffff;"><span style="color:#333333;">3. 如果实现了BeanNameAware接口,调用setBeanName设置Bean的ID或者Name;</span></span><br><span style="background-color:#ffffff;"><span style="color:#333333;">4. 如果实现BeanFactoryAware接口,调用setBeanFactory 设置BeanFactory;</span></span><br><span style="background-color:#ffffff;"><span style="color:#333333;">5. 如果实现ApplicationContextAware,调用setApplicationContext设置ApplicationContext</span></span><br><span style="background-color:#ffffff;"><span style="color:#333333;">6. 调用BeanPostProcessor的预先初始化方法;</span></span><br><span style="background-color:#ffffff;"><span style="color:#333333;">7. 调用InitializingBean的afterPropertiesSet()方法;</span></span><br><span style="background-color:#ffffff;"><span style="color:#333333;">8. 调用定制init-method方法；</span></span><br><span style="background-color:#ffffff;"><span style="color:#333333;">9. 调用BeanPostProcessor的后初始化方法;</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#333333;">10.对象销毁前调用destroy() 方法。</span></span></p> 
<h2 style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">我们要如何保证接口幂等性：</span></span></strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">insert前先select；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">加悲观锁；</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">加乐观锁：</span></span></strong></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">加唯一索引；</span></span></strong></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">建防重表；</span></span></strong></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">根据状态机；</span></span></strong></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">加</span></span><a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&amp;spm=1001.2101.3001.7020" title="分布式">分布式</a><span style="background-color:#ffffff;"><span style="color:#222222;">锁；</span></span></strong></span></p> 
<h2 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">RocketMQ实现原理：</span></span></strong></strong></span></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">RocketMQ由NameServer注册中心集群、Producer生产者集群、Consumer消费者集群和若干Broker（RocketMQ进程）组成</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Broker在启动的时候去向所有的NameServer注册，并保持长连接，每30s发送一次心跳；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费。</span></span></p> 
<h2 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">三大范式通俗解释：</span></span></strong></strong></span></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">第一范式（1NF）：字段不可分；</span></span><br><span style="background-color:#ffffff;"><span style="color:#222222;">第二范式（2NF）：有主键，非主键字段依赖主键；</span></span><br><span style="background-color:#ffffff;"><span style="color:#222222;">第三范式（3NF）：非主键字段不能相互依赖。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">RocketMQ消息零丢失方案总结</span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">：</span></span></strong></strong></span></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">生产者使用事务消息机制。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Broker配置同步刷盘+Dledger主从架构</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">消费者不要使用异步消费。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">整个MQ挂了之后准备降级方案</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">Spring传播行为</span></span></strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">REQUIRED：默认值，支持当前事务，如果没有事务会创建一个新的事务</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">SUPPORTS：支持当前事务，如果没有事务的话以非事务方式执行</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">MANDATORY：支持当前事务，如果没有事务抛出异常</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">REQUIRES_NEW：创建一个新的事务并挂起当前事务</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">NOT_SUPPORTED：以非事务方式执行，如果当前存在事务则将当前事务挂起</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">NEVER：以非事务方式进行，如果存在事务则抛出异常</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与REQUIRED类似的操作</span></span></p> 
<h2 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">Spring 事务失效的场景</span></span></strong></strong></span></h2> 
<ol><li style="text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">未被Spring管理</span></span></strong></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">数据库引擎不支持事务</span></span></strong></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">事务方法没有被public修饰</span></span></strong></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">方法使用final修饰</span></span></strong></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">同一类中方法调用</span></span></strong></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">未开启事务</span></span></strong></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">多线程调用</span></span></strong></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">错误的传播行为</span></span></strong></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">自己try...catch...掉了异常</span></span></strong></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">手动抛出了错误的异常</span></span></strong></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">嵌套事务回滚多了</span></span></strong></span></li></ol> 
<h3 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">Spring Boot启动流程</span></span></strong></strong></span></h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">1.首先从main找到run()方法，在执行run()方法之前new一个SpringApplication对象</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">2.进入run()方法，创建应用监听器SpringApplicationRunListeners开始监听</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">3.然后加载SpringBoot配置环境(ConfigurableEnvironment)，然后把配置环境(Environment)加入监听对象中</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">4.然后加载应用上下文(ConfigurableApplicationContext)</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">5.最后创建Spring容器，refreshContext(context)，实现starter自动化配置和bean的实例化等工作。</span></span></p> 
<h3 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">SpringBoot自动装配</span></span></strong></strong></span></h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">通过@EnableAutoConfiguration</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">注解在类路径的META-INF/spring.factories文件中找到所有的对应配置类，然后将这些自动配置类加载到spring容器中。</span></span></p> 
<h2 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">Nacos的高可用特性</span></span></strong></strong></span></h2> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">客户端重试</span></span></strong></span></h4> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">一致性协议 distro</span></span></strong></span></h4> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">本地缓存文件 Failover 机制</span></span></strong></span></h4> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">心跳同步服务</span></span></strong></span></h4> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">集群部署模式高可用</span></span></strong></span></h4> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">Nacos的注册中心原理</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">1.nocos客户端启动时会将当前服务的信息包含ip、端口号、服务名、集群名等信息封装为一个Instance对象，然后创建一个定时任务，每隔一段时间向Nacos服务器发送PUT请求并携带相关信息；</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">2.nacos服务器端在接收到心跳请求后，会去检查当前服务列表中有没有该实例，如果没有的话将当前服务实例重新注册，注册完成后立即开启一个异步任务，更新客户端实例的最后心跳时间，如果当前实例是非健康状态则将其改为健康状态。</span></span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">3.当服务端检测到服务异常,基于UDP协议推送更新；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">4.服务消费者即可调用了；</span></span></p> 
<h2 style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">nacos配置中心原理：</span></span></strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">配置动态刷新客户端有两种方式完成，客户端主动Pull拉取配置，Nacos Server主动Push配置数据；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Pull模式：nacos采用了长轮询机制实现，客户端发起一个Pull拉取配置请求，nacos server建立一个任务队列，返回配置数据给客户端；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">Push模式：当通过nacos dashboard或者nacos api修改了配置后，nacos检查pull任务队列，检查配置变更数据，返回给Pull请求最新配置。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">ConcurrentHashMap工作原理</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">底层数据结构：Synchronized + CAS +Node +红黑树，当执行put()操作：1.先判断Node数组有没有初始化，如果没有初始化先初始化initTable();</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">2.根据key进行hash操作，找到Node数组中的位置，如果不存在hash冲突，即该位置是null，直接用CAS插入;</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">3.如果存在hash冲突，就先对链表的头节点或者红黑树的头节点加synchronized锁</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">4.如果是链表，就遍历链表，如果key相同就执行覆盖操作，如果不同就将元素插入到链表的尾部， 并且在链表长度大于8， Node数组的长度超过64时，会将链表的转化为红黑树。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">5.如果是红黑树，就按照红黑树的结构进行插入。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">当执行get()操作</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">：get操作全程无锁。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">1.计算hash值，定位到Node数组中的位置</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">2.如果该位置为null，则直接返回null</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">3.如果该位置不为null，再判断该节点是红黑树节点还是链表节点</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">如果是红黑树节点，使用红黑树的查找方式来进行查找</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">如果是链表节点，遍历链表进行查找</span></span></p> 
<h2 style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">线程池拒绝策略</span></span></strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">AbortPolicy：丢弃任务并抛出 RejectedExecutionException 异常。（默认这种）</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">DiscardPolicy：丢弃任务，但是不抛出异常</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） 。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">CallerRunsPolicy：谁调用，谁处理。由调用线程（即提交任务给线程池的线程）处理该任务，如果线程池已经被shutdown则直接丢弃</span></span></p> 
<h2 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">线程池的七个核心参数</span></span></strong></strong></span></h2> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">corePoolSize </span></span><a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E6%B1%A0&amp;spm=1001.2101.3001.7020" title="线程池">线程池</a><span style="background-color:#ffffff;"><span style="color:#222222;">核心线程大小</span></span></span></h4> 
<h4 style="margin-left:0pt;text-align:left;"><strong><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">maximumPoolSize 线程池最大线程数量</span></span></span></strong></h4> 
<h4 style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">keepAliveTime 多余的空闲线程存活时间</span></span></h4> 
<h4 style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">unit 空闲线程存活时间单位</span></span></h4> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">workQueue 工作队列</span></span></strong></span></h4> 
<h4 style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">threadFactory 线程工厂</span></span></h4> 
<h4 style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">handler 拒绝策略</span></span></h4> 
<h2 style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">Spring的启动原理</span></span></strong></h2> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#222222;">第一步，首先会执行一些容器刷新前的准备工作,如设置容器启动时间、一些状态标志位等；</span></span></span></h4> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">第二步，创建容器对象；</span></span></strong></span></h4> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">第三步，准备Bean工厂；</span></span></strong></span></h4> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">第四步，为上下文初始化 MessageSource，即 国际化处理;</span></span></strong></span></h4> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">第五步，注册 Listener 监听器；</span></span></strong></span></h4> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">第六步，实例化所有非懒加载的单实例 Bean；</span></span></strong></span></h4> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#222222;">第七步，Spring容器完成刷新，发布事件；</span></span></strong></span></h4> 
<h2 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><span style="color:#222222;">OOM(内存溢出)造成原因及解决方案</span></span></strong></strong></span></h2> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">内存泄漏;</span></span></li><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">超大对象</span></span></li></ol> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">查看服务的进程是否存在;ps -ef | grep 服务名</span></span></li><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">生产对堆快照Heap dump;jmap -dump:format=b,file=/tmp/进程号_jmap_dump.hprof 进程号;</span></span></li><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">分析生成的堆快照;</span></span></li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a697e8f790670c838be43758ca0fc774/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">作为依赖库时，Package.json 重要字段总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43fe64cd96f3a5357b76a6b4f7f51b43/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络设备驱动</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>