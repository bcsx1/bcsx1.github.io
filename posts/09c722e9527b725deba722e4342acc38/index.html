<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android UI RecyclerView讲解 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android UI RecyclerView讲解" />
<meta property="og:description" content="前言 RecyclerView是Android 5.0之后推出的列表类控件，具有高度的解耦性和灵活性。通过使用合适的LayoutManager，可以实现ListView、横向ListView、GridView和瀑布流列表的效果。本文将对RecyclerView的相关知识点进行详细讲解。
基本用法 使用步骤 RecyclerView是支持库中的控件，因此在使用前需要先在build.gradle文件中添加依赖，如下：
implementation &#39;com.android.support:recyclerview-v7:26.0.0-beta1&#39; 注意： AndroidStudio在升级到3.0版本后，不再使用compile关键字引入依赖库，而改用implementation关键字。
配置好依赖后，就可以正式开始使用RecyclerView了。首先，提供列表项（Item）的布局文件，本例中命名为recycler_view_item.xml，代码如下：
&lt;LinearLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; android:orientation=&#34;vertical&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;wrap_content&#34; android:background=&#34;#f36c60&#34;&gt; &lt;TextView android:id=&#34;@&#43;id/text_view_recycler&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;wrap_content&#34; android:layout_marginTop=&#34;8dp&#34; android:layout_marginBottom=&#34;8dp&#34; android:textSize=&#34;16sp&#34; android:textColor=&#34;#fff&#34; android:gravity=&#34;center&#34;/&gt; &lt;/LinearLayout&gt; RecyclerView和ListView类似，都是借助Adapter访问数据源，因此还需要实现自己的适配器，示例代码如下：
public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt;{ private List&lt;String&gt; dataList;//数据源 private LayoutInflater inflater;//布局解析器 public RecyclerViewAdapter(List&lt;String&gt; dataList){ this.dataList = dataList; } @Override public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType) { if(inflater==null){//避免多次初始化 inflater=LayoutInflater.from(parent.getContext()); } View itemView=inflater.inflate(R.layout.recycler_view_item,parent,false); return new ViewHolder(itemView); } @Override public void onBindViewHolder(ViewHolder holder, int position){ final String itemContent=dataList." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/09c722e9527b725deba722e4342acc38/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-04T13:53:14+08:00" />
<meta property="article:modified_time" content="2018-04-04T13:53:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android UI RecyclerView讲解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="前言">前言</h3> 
<p>RecyclerView是Android 5.0之后推出的列表类控件，具有高度的解耦性和灵活性。通过使用合适的LayoutManager，可以实现ListView、横向ListView、GridView和瀑布流列表的效果。本文将对RecyclerView的相关知识点进行详细讲解。</p> 
<h3 id="基本用法">基本用法</h3> 
<h4 id="使用步骤">使用步骤</h4> 
<p>RecyclerView是支持库中的控件，因此在使用前需要先在<code>build.gradle</code>文件中添加依赖，如下：</p> 
<pre class="prettyprint"><code class=" hljs delphi"><span class="hljs-keyword">implementation</span> <span class="hljs-string">'com.android.support:recyclerview-v7:26.0.0-beta1'</span></code></pre> 
<p><strong>注意：</strong> AndroidStudio在升级到<code>3.0</code>版本后，不再使用<code>compile</code>关键字引入依赖库，而改用<code>implementation</code>关键字。</p> 
<p>配置好依赖后，就可以正式开始使用RecyclerView了。首先，提供列表项（Item）的布局文件，本例中命名为<code>recycler_view_item.xml</code>，代码如下：</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">LinearLayout</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attribute">android:orientation</span>=<span class="hljs-value">"vertical"</span>
    <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
    <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>
    <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"#f36c60"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-title">TextView
</span>        <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/text_view_recycler"</span>
        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>
        <span class="hljs-attribute">android:layout_marginTop</span>=<span class="hljs-value">"8dp"</span>
        <span class="hljs-attribute">android:layout_marginBottom</span>=<span class="hljs-value">"8dp"</span>
        <span class="hljs-attribute">android:textSize</span>=<span class="hljs-value">"16sp"</span>
        <span class="hljs-attribute">android:textColor</span>=<span class="hljs-value">"#fff"</span>
        <span class="hljs-attribute">android:gravity</span>=<span class="hljs-value">"center"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">LinearLayout</span>&gt;</span></code></pre> 
<p>RecyclerView和ListView类似，都是借助Adapter访问数据源，因此还需要实现自己的适配器，示例代码如下：</p> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecyclerViewAdapter</span> <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span>&lt;<span class="hljs-title">RecyclerViewAdapter</span>.<span class="hljs-title">ViewHolder</span>&gt;{<!-- --></span>
    <span class="hljs-keyword">private</span> List&lt;String&gt; dataList;<span class="hljs-comment">//数据源</span>
    <span class="hljs-keyword">private</span> LayoutInflater inflater;<span class="hljs-comment">//布局解析器</span>

    <span class="hljs-keyword">public</span> RecyclerViewAdapter(List&lt;String&gt; dataList){
        <span class="hljs-keyword">this</span>.dataList = dataList;
    }

    @Override
    <span class="hljs-keyword">public</span> ViewHolder onCreateViewHolder(ViewGroup parent,<span class="hljs-keyword">int</span> viewType) {
        <span class="hljs-keyword">if</span>(inflater==<span class="hljs-keyword">null</span>){<!-- --><span class="hljs-comment">//避免多次初始化</span>
            inflater=LayoutInflater.from(parent.getContext());
        }
        View itemView=inflater.inflate(R.layout.recycler_view_item,parent,<span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ViewHolder(itemView);
    }

    @Override
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onBindViewHolder(ViewHolder holder, <span class="hljs-keyword">int</span> position){
        <span class="hljs-keyword">final</span> String itemContent=dataList.get(position);
        holder.textView.setText(itemContent);
    }

    @Override
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> getItemCount() {
        <span class="hljs-keyword">return</span> dataList.size();
    }

    <span class="hljs-comment">//自定义ViewHolder</span>
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewHolder</span> <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span>{<!-- --></span>
        <span class="hljs-keyword">private</span> TextView textView;

        <span class="hljs-keyword">public</span> ViewHolder(View itemView) {
            <span class="hljs-keyword">super</span>(itemView);
            textView=itemView.findViewById(R.id.text_view_recycler);
        }
    }

}</code></pre> 
<p>可以看到，RecyclerViewAdapter继承自<code>RecyclerView.Adapter</code>，并通过继承<code>RecyclerView.ViewHolder</code>实现了静态类ViewHolder，这是为了充分利用RecyclerView的View复用机制。</p> 
<p>主要重写的方法有<code>onCreateViewHolder</code>、<code>onBindViewHolder</code>和<code>getItemCount</code>，分别用于创建ViewHolder、绑定数据和返回数据总数量。</p> 
<p>在为RecyclerView设置Adapter之前，我们先为RecyclerView设置合适的LayoutManager。LayoutManager用于管理列表项的排列方式，通过使用不同的LayoutManager，可以在不改变适配器的情况下随意改变列表排列方式，这也是RecyclerView得以解耦合的原因。示例代码如下：</p> 
<pre class="prettyprint"><code class=" hljs cs">LinearLayoutManager linearLayoutManager=<span class="hljs-keyword">new</span> LinearLayoutManager(<span class="hljs-keyword">this</span>);
linearLayoutManager.setOrientation(LinearLayoutManager.VERTICAL);<span class="hljs-comment">//设置为纵向排列</span>
recyclerView.setLayoutManager(linearLayoutManager);<span class="hljs-comment">//设置布局管理器</span></code></pre> 
<p>在本例中使用<code>LinearLayoutManager</code>。这是一个线性的布局管理器，可以设置为横向或纵向排列，选择为纵向排列其实就实现了ListView的效果。</p> 
<p>最后，再为RecyclerView设置好适配器就行了，示例代码如下：</p> 
<pre class="prettyprint"><code class=" hljs php"><span class="hljs-comment">//生成随机数据</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">List</span>&lt;String&gt; createDataList(){
    <span class="hljs-keyword">List</span>&lt;String&gt; <span class="hljs-keyword">list</span>=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    String[] rootArray={<!-- --><span class="hljs-string">"Java"</span>,<span class="hljs-string">"Android"</span>,<span class="hljs-string">"Swift"</span>,<span class="hljs-string">"Python"</span>,<span class="hljs-string">"Ruby"</span>};
    <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">60</span>;i++){
        <span class="hljs-keyword">list</span>.add(rootArray[i%rootArray.length]+i);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">list</span>;
}</code></pre> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-built_in">List</span><span class="hljs-subst">&lt;</span><span class="hljs-built_in">String</span><span class="hljs-subst">&gt;</span> dataList<span class="hljs-subst">=</span>createDataList();<span class="hljs-comment">//数据源</span>
RecyclerViewAdapter recyclerViewAdapter<span class="hljs-subst">=</span><span class="hljs-literal">new</span> RecyclerViewAdapter(dataList);
recyclerView<span class="hljs-built_in">.</span>setAdapter(recyclerViewAdapter);<span class="hljs-comment">//设置适配器</span></code></pre> 
<p>最后，总结一下RecyclerView的使用步骤：</p> 
<ol><li>准备列表项布局文件</li><li>实现适配器</li><li>为RecyclerView设置布局管理器</li><li>为RecyclerView设置适配器</li></ol> 
<p><strong>效果截图：</strong></p> 
<p><img src="https://images2.imgbox.com/73/83/J4c1RsgD_o.png" width="30%"></p> 
<h4 id="监听列表项的点击事件">监听列表项的点击事件</h4> 
<p>和ListView不同，RecyclerView并没有提供为列表项设置点击监听器的方法，因此我们需要自己去实现这一需求。</p> 
<p>首先，在Adapter类中定义一个内部接口，并将其作为Adapter的成员变量，以及实现相应的setter方法，代码如下：</p> 
<pre class="prettyprint"><code class=" hljs r"><span class="hljs-keyword">...</span>
private ItemClickListener itemClickListener;//列表项点击监听器

//为RecyclerView设置点击监听器
public void setItemClickListener(ItemClickListener itemClickListener) {
    this.itemClickListener = itemClickListener;
}

//自定义的点击监听器接口
public interface ItemClickListener{
    void onItemClick(String clickItem);//单击事件
    void onItemLongClick(String clickItem);//长按事件
}
<span class="hljs-keyword">...</span></code></pre> 
<p>之后，在<code>onBindViewHolder</code>方法中为列表项设置点击监听器，并调用<code>ItemClickListener</code>中相应的方法，代码如下：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span>(ViewHolder holder, <span class="hljs-keyword">int</span> position){
    ....
    <span class="hljs-comment">//为列表项设置点击监听</span>
    <span class="hljs-keyword">if</span>(itemClickListener!=<span class="hljs-keyword">null</span>){
        holder.itemView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span>(View v) {
                itemClickListener.onItemClick(itemContent);
            }
        });
        holder.itemView.setOnLongClickListener(<span class="hljs-keyword">new</span> View.OnLongClickListener() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onLongClick</span>(View v) {
                itemClickListener.onItemLongClick(itemContent);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            }
        });
    }
}</code></pre> 
<p>最后，只需要为RecyclerView设置相应的接口，就轻松地实现了监听列表项点击事件的需求，代码如下：</p> 
<pre class="prettyprint"><code class=" hljs java">recyclerViewAdapter.setItemClickListener(<span class="hljs-keyword">new</span> RecyclerViewAdapter.ItemClickListener() {
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemClick</span>(String clickItem) {
        Toast.makeText(RecyclerViewActivity.<span class="hljs-keyword">this</span>,<span class="hljs-string">"点击："</span>+clickItem,
                Toast.LENGTH_SHORT).show();
    }
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemLongClick</span>(String clickItem) {
        Toast.makeText(RecyclerViewActivity.<span class="hljs-keyword">this</span>,<span class="hljs-string">"长按："</span>+clickItem,
                Toast.LENGTH_SHORT).show();
    }
});</code></pre> 
<h4 id="使用不同的layoutmanager">使用不同的LayoutManager</h4> 
<p>在上面的例子中，我们使用LinearLayoutManager实现了类似ListView的效果。实际上，RecyclerView一共提供了三种LayoutManger，用于实现多种布局效果。下面简单介绍一下这几种布局管理器：</p> 
<ol><li><strong>LinearLayoutManager：</strong>线性布局管理器，有横向和纵向两种布局方向，可以通过<code>setOrientation</code>方法设置布局方向。</li><li><strong>GridLayoutManager：</strong>网格布局管理器，可以实现类似GridView的排列效果，属于LinearLayoutManager的子类。</li><li><strong>StaggeredGridLayoutManager：</strong>可以实现瀑布流的布局管理器。</li></ol> 
<p><strong>注意：</strong>如果要实现瀑布流式布局，要求Item的高度不同（纵向排列时），否则StaggeredGridLayoutManager的显示效果和GridLayoutManager相同。</p> 
<p><strong>GridLayoutManager使用示例：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs">GridLayoutManager gridLayoutManager=<span class="hljs-keyword">new</span> GridLayoutManager(RecyclerViewActivity.<span class="hljs-keyword">this</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//3列</span>
recyclerView.setLayoutManager(gridLayoutManager);</code></pre> 
<p><strong>效果截图：</strong></p> 
<p><img src="https://images2.imgbox.com/4c/6e/0xWlHy5Y_o.png" width="30%"></p> 
<p><strong>StaggeredGridLayoutManager使用示例：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//垂直排列、4列</span>
StaggeredGridLayoutManager staggeredGridLayoutManager=<span class="hljs-keyword">new</span> StaggeredGridLayoutManager(<span class="hljs-number">4</span>,StaggeredGridLayoutManager.VERTICAL);
recyclerView.setLayoutManager(staggeredGridLayoutManager);</code></pre> 
<p><strong>效果截图：</strong></p> 
<p><img src="https://images2.imgbox.com/62/c0/57VORpJl_o.png" width="30%"></p> 
<h3 id="相关方法">相关方法</h3> 
<h4 id="recyclerview">RecyclerView</h4> 
<p><strong>添加Item装饰器：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItemDecoration</span>(ItemDecoration decor);
<span class="hljs-comment">//index：指定位置</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItemDecoration</span>(ItemDecoration decor, <span class="hljs-keyword">int</span> index);</code></pre> 
<p><strong>判断RecyclerView是否在执行动画：</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnimating</span>();</code></pre> 
<p><strong>获取指定位置的ViewHolder：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> RecyclerView.ViewHolder <span class="hljs-title">findViewHolderForAdapterPosition</span>(<span class="hljs-keyword">int</span> position);
<span class="hljs-keyword">public</span> RecyclerView.ViewHolder <span class="hljs-title">findViewHolderForLayoutPosition</span>(<span class="hljs-keyword">int</span> position);</code></pre> 
<p>这两个方法都是返回指定位置的ViewHolder，如果指定位置的View还不存在，则会返回<code>null</code>。这两者的区别在于，<code>findViewHolderForAdapterPosition</code>以Adapter中的最新数据为基准，而<code>findViewHolderForLayoutPosition</code>以已布局的旧数据为基准。在数据源发生改变而这一改变还没有更新到RecyclerView中的这一小段时间里（16ms），两者的返回结果将不同。</p> 
<h4 id="linearlayoutmanager">LinearLayoutManager</h4> 
<p><strong>构造方法：</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//默认纵向排列</span>
<span class="hljs-keyword">public</span> <span class="hljs-title">LinearLayoutManager</span>(Context context);

<span class="hljs-comment">//orientation：布局方向（横向或纵向）</span>
<span class="hljs-comment">//reverseLayout：是否逆序排列</span>
<span class="hljs-keyword">public</span> <span class="hljs-title">LinearLayoutManager</span>(Context context, <span class="hljs-keyword">int</span> orientation, <span class="hljs-keyword">boolean</span> reverseLayout);</code></pre> 
<p>如果<code>reverseLayout</code>为true，那么列表将对数据源进行逆序排列。以纵向排列为例，列表将从底部开始依次加载数据，并且将首先显示列表末尾的内容而不是头部内容（感觉就像列表自动滑到了列表末尾）。</p> 
<p><strong>设置是否对数据逆序排列：</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setReverseLayout</span>(<span class="hljs-keyword">boolean</span> reverseLayout);</code></pre> 
<p><strong>设置布局方向：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//orientation：布局方向 可选值：[LinearLayoutManager.HORIZONTAL|LinearLayoutManager.VERTICAL]</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrientation</span>(<span class="hljs-keyword">int</span> orientation);</code></pre> 
<p><strong>设置是否优先展示列表尾部内容：</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStackFromEnd</span>(<span class="hljs-keyword">boolean</span> stackFromEnd);</code></pre> 
<p>以纵向排列为例，如果stackFromEnd设置为true，那么打开RecyclerView首先看到的就是最底部的内容，看起来就像是RecyclerView已经滚动到了最后一行；如果设置为false，就和默认状态一样，首先看到第一行的内容。</p> 
<p><strong>跳转到指定位置：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scrollToPosition</span>(<span class="hljs-keyword">int</span> position)；
//offset：偏移量
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scrollToPositionWithOffset</span>(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> offset)；</code></pre> 
<p><strong>注意：</strong>这两个方法都只保证指定位置的列表项可见，并不保证该列表项处于第一个可见位置。实际上，这两个方法都会尽量只滑动最小的距离。</p> 
<p><strong>平滑移动到指定位置：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//recyclerView：目标recyclerView</span>
<span class="hljs-comment">//state：可以传入null</span>
<span class="hljs-comment">//position：指定位置</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">smoothScrollToPosition</span>(RecyclerView recyclerView, RecyclerView.State state,<span class="hljs-keyword">int</span> position)</code></pre> 
<p>和<code>scrollToPosition</code>方法不同，这个方法可以实现平滑移动，因此移动过程不会显得那么突兀。</p> 
<p><strong>获取可见的列表项：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findFirstVisibleItemPosition</span>();<span class="hljs-comment">//获取第一个可见的列表项位置</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findFirstCompletelyVisibleItemPosition</span>();<span class="hljs-comment">//获取第一个完整可见的列表项位置</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLastVisibleItemPosition</span>();<span class="hljs-comment">//获取最后一个可见的列表项位置</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLastCompletelyVisibleItemPosition</span>();<span class="hljs-comment">//获取最后一个完整可见的列表项位置</span></code></pre> 
<h4 id="gridlayoutmanger">GridLayoutManger</h4> 
<p><strong>构造方法：</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//默认纵向排列</span>
<span class="hljs-comment">//spanCount：列数</span>
<span class="hljs-keyword">public</span> <span class="hljs-title">GridLayoutManager</span>(Context context, <span class="hljs-keyword">int</span> spanCount);

<span class="hljs-comment">//orientation：排列方向（横向或纵向）</span>
<span class="hljs-comment">//spanCount：行数或列数（取决于排列方向）</span>
<span class="hljs-comment">//reverseLayout：是否倒序排列</span>
<span class="hljs-keyword">public</span> <span class="hljs-title">GridLayoutManager</span>(Context context, <span class="hljs-keyword">int</span> spanCount, <span class="hljs-keyword">int</span> orientation,<span class="hljs-keyword">boolean</span> reverseLayout);</code></pre> 
<p><strong>注意：</strong>如果orientation为纵向，spanCount就代表列数；如果orientation为横向，spanCount就代表行数。</p> 
<p><strong>设置行数和列数：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSpanCount</span>(<span class="hljs-keyword">int</span> spanCount);</code></pre> 
<p><code>GridLayoutManger</code>是<code>LinearLayoutManager</code>的子类，因此继承了LinearLayoutManager的所有方法，这里不再赘述。不过要<strong>注意</strong>，GridLayoutManger并不支持<code>setStackFromEnd</code>方法。</p> 
<h4 id="staggeredgridlayoutmanager">StaggeredGridLayoutManager</h4> 
<p><strong>构造方法：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//orientation：排列方向（横向或纵向）</span>
<span class="hljs-comment">//spanCount：行数或列数（取决于排列方向）</span>
<span class="hljs-keyword">public</span> <span class="hljs-title">StaggeredGridLayoutManager</span>(<span class="hljs-keyword">int</span> spanCount, <span class="hljs-keyword">int</span> orientation)；</code></pre> 
<p><strong>注意：</strong>如果orientation为纵向，spanCount就代表列数；如果orientation为横向，spanCount就代表行数。</p> 
<p><strong>其他方法：</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrientation</span>(<span class="hljs-keyword">int</span> orientation);<span class="hljs-comment">//设置布局方向</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSpanCount</span>(<span class="hljs-keyword">int</span> spanCount);<span class="hljs-comment">//设置行数或列数</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setReverseLayout</span>(<span class="hljs-keyword">boolean</span> reverseLayout);<span class="hljs-comment">//设置是否对数据逆序排列</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scrollToPosition</span>(<span class="hljs-keyword">int</span> position)；//跳转到指定位置
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scrollToPositionWithOffset</span>(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> offset)；//带偏移量跳转到指定位置
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">smoothScrollToPosition</span>(RecyclerView recyclerView, RecyclerView.State state,<span class="hljs-keyword">int</span> position)//平滑移动到指定位置
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findFirstVisibleItemPosition</span>();<span class="hljs-comment">//获取第一个可见的列表项位置</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findFirstCompletelyVisibleItemPosition</span>();<span class="hljs-comment">//获取第一个完整可见的列表项位置</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLastVisibleItemPosition</span>();<span class="hljs-comment">//获取最后一个可见的列表项位置</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLastCompletelyVisibleItemPosition</span>();<span class="hljs-comment">//获取最后一个完整可见的列表项位置</span></code></pre> 
<h3 id="实现多布局列表包括列表头和列表尾">实现多布局列表（包括列表头和列表尾）</h3> 
<p>在实际开发中，列表项可能并不是只有一种布局方式。通过重写Adapter的<code>getItemViewType</code>方法，可以在不同的情形下构建合适的布局。此外，通过这种方式还可以为RecyclerView设置列表头和列表尾，这时只需要将列表头和列表尾视为两种独立的布局方式即可。在这里，将介绍如何实现一个简单的多布局列表，最终的效果如下：</p> 
<p><img src="https://images2.imgbox.com/81/0f/3faAZPvj_o.png" width="30%"></p> 
<h4 id="准备布局文件">准备布局文件</h4> 
<p>在本例中，主要有两种列表项，即标题项和内容项。因此，准备两个对应的布局文件，分别命名为<code>recycler_view_multi_title.xml</code>和<code>recycler_view_multi_item.xml</code>，代码如下：</p> 
<p><strong>recycler_view_multi_title.xml</strong></p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">LinearLayout</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attribute">android:orientation</span>=<span class="hljs-value">"vertical"</span>
    <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
    <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">TextView
</span>        <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/item_title"</span>
        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"wrap_content"</span>
        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>
        <span class="hljs-attribute">android:layout_margin</span>=<span class="hljs-value">"6dp"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">LinearLayout</span>&gt;</span></code></pre> 
<p><strong>recycler_view_multi_item.xml</strong></p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">LinearLayout</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attribute">android:orientation</span>=<span class="hljs-value">"horizontal"</span>
    <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
    <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>
    <span class="hljs-attribute">android:layout_marginTop</span>=<span class="hljs-value">"4dp"</span>
    <span class="hljs-attribute">android:layout_marginBottom</span>=<span class="hljs-value">"4dp"</span>
    <span class="hljs-attribute">android:gravity</span>=<span class="hljs-value">"center_vertical"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">ImageView
</span>        <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/item_image"</span>
        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"45dp"</span>
        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"45dp"</span>
        <span class="hljs-attribute">android:layout_marginLeft</span>=<span class="hljs-value">"8dp"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-title">TextView
</span>        <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/item_content"</span>
        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"wrap_content"</span>
        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>
        <span class="hljs-attribute">android:layout_marginLeft</span>=<span class="hljs-value">"8dp"</span>
        <span class="hljs-attribute">android:textAllCaps</span>=<span class="hljs-value">"false"</span>
        <span class="hljs-attribute">android:textSize</span>=<span class="hljs-value">"16sp"</span>
        <span class="hljs-attribute">android:textColor</span>=<span class="hljs-value">"#000000"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">LinearLayout</span>&gt;</span></code></pre> 
<p>此外，也为列表头和列表尾准备两个布局文件，本例中命名为<code>recycler_view_header.xml</code>和<code>recycler_view_footer.xml</code>，代码如下：</p> 
<p><strong>recycler_view_header.xml</strong></p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">LinearLayout</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attribute">android:orientation</span>=<span class="hljs-value">"vertical"</span>
    <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
    <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">TextView
</span>        <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/recycler_view_header"</span>
        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"wrap_content"</span>
        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>
        <span class="hljs-attribute">android:layout_marginLeft</span>=<span class="hljs-value">"16dp"</span>
        <span class="hljs-attribute">android:layout_marginBottom</span>=<span class="hljs-value">"8dp"</span>
        <span class="hljs-attribute">android:textSize</span>=<span class="hljs-value">"20sp"</span>
        <span class="hljs-attribute">android:text</span>=<span class="hljs-value">"HeaderView"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">LinearLayout</span>&gt;</span></code></pre> 
<p><strong>recycler_view_footer.xml</strong></p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">LinearLayout</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attribute">android:orientation</span>=<span class="hljs-value">"vertical"</span>
    <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
    <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">TextView
</span>        <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/recycler_view_footer"</span>
        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"wrap_content"</span>
        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>
        <span class="hljs-attribute">android:layout_marginLeft</span>=<span class="hljs-value">"16dp"</span>
        <span class="hljs-attribute">android:textSize</span>=<span class="hljs-value">"20sp"</span>
        <span class="hljs-attribute">android:text</span>=<span class="hljs-value">"FooterView"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">LinearLayout</span>&gt;</span></code></pre> 
<h4 id="准备实体类">准备实体类</h4> 
<p>对于不同的布局而言，应该使用不同的实体类。在本例中，有两种列表项，因此需要两个实体类。首先可以建立一个基类，本例中命名为<code>BaseMultiBean</code>，代码如下：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseMultiBean</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TYPE_TITLE=<span class="hljs-number">0</span>;<span class="hljs-comment">//标题项</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TYPE_ITEM=<span class="hljs-number">1</span>;<span class="hljs-comment">//内容项</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> type;<span class="hljs-comment">//类型</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getType</span>() {
        <span class="hljs-keyword">return</span> type;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setType</span>(<span class="hljs-keyword">int</span> type) {
        <span class="hljs-keyword">this</span>.type = type;
    }
}</code></pre> 
<p>可以看到，基类中主要是封装了实体的<strong>类型</strong>属性，这一属性将用于确定要使用的列表项布局。然后，再建立两个继承自基类的实体类，分别对应标题项和内容项，本例中命名为<code>TitleBean</code>和<code>ItemBean</code>，代码如下：</p> 
<p><strong>TitleBean</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TitleBean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMultiBean</span>{<!-- --></span>
    <span class="hljs-keyword">private</span> String title;

    <span class="hljs-keyword">public</span> <span class="hljs-title">TitleBean</span>(String title) {
        <span class="hljs-keyword">this</span>.title = title;
        <span class="hljs-keyword">this</span>.type=TYPE_TITLE;
    }
    <span class="hljs-keyword">public</span> String <span class="hljs-title">getTitle</span>() {
        <span class="hljs-keyword">return</span> title;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTitle</span>(String title) {
        <span class="hljs-keyword">this</span>.title = title;
    }
}</code></pre> 
<p><strong>ItemBean</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItemBean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMultiBean</span>{<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> imageRes;<span class="hljs-comment">//图片资源</span>
    <span class="hljs-keyword">private</span> String content;<span class="hljs-comment">//内容</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title">ItemBean</span>(<span class="hljs-keyword">int</span> imageRes, String content) {
        <span class="hljs-keyword">this</span>.imageRes = imageRes;
        <span class="hljs-keyword">this</span>.content = content;
        <span class="hljs-keyword">this</span>.type=TYPE_ITEM;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getImageRes</span>() {
        <span class="hljs-keyword">return</span> imageRes;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImageRes</span>(<span class="hljs-keyword">int</span> imageRes) {
        <span class="hljs-keyword">this</span>.imageRes = imageRes;
    }
    <span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span>() {
        <span class="hljs-keyword">return</span> content;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span>(String content) {
        <span class="hljs-keyword">this</span>.content = content;
    }
}</code></pre> 
<h4 id="创建适配器">创建适配器</h4> 
<p>有了布局和实体类，就可以开始着手创建适配器了，本例中命名为<code>StyleRecyclerViewAdapter</code>，代码如下：</p> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StyleRecyclerViewAdapter</span> <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span>&lt;<span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span>&gt;{<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TYPE_TITLE=<span class="hljs-number">0</span>;<span class="hljs-comment">//标题形式的列表项</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TYPE_CONTENT=<span class="hljs-number">1</span>;<span class="hljs-comment">//内容形式的列表项</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TYPE_HEADER=<span class="hljs-number">2</span>;<span class="hljs-comment">//列表头</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TYPE_FOOTER=<span class="hljs-number">3</span>;<span class="hljs-comment">//列表尾</span>

    <span class="hljs-keyword">private</span> View headerView;<span class="hljs-comment">//头部View</span>
    <span class="hljs-keyword">private</span> View footerView;<span class="hljs-comment">//尾部View</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> headerCount;<span class="hljs-comment">//头部View数量（0或1）</span>
    <span class="hljs-keyword">private</span> List&lt;BaseMultiBean&gt; dataList;<span class="hljs-comment">//数据源</span>

    <span class="hljs-keyword">private</span> LayoutInflater inflater;<span class="hljs-comment">//布局解析器</span>

    <span class="hljs-keyword">public</span> StyleRecyclerViewAdapter(List&lt;BaseMultiBean&gt; dataList) {
        <span class="hljs-keyword">this</span>.dataList = dataList;
    }

    @Override
    <span class="hljs-keyword">public</span> RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, <span class="hljs-keyword">int</span> viewType) {
        <span class="hljs-keyword">if</span>(inflater==<span class="hljs-keyword">null</span>){<!-- --><span class="hljs-comment">//只初始化一次</span>
            inflater=LayoutInflater.from(parent.getContext());
        }
        <span class="hljs-keyword">switch</span> (viewType){<!-- --><span class="hljs-comment">//根据布局类型创建合适的ViewHolder</span>
            <span class="hljs-keyword">case</span> TYPE_HEADER:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeaderFooterViewHolder(headerView);
            <span class="hljs-keyword">case</span> TYPE_FOOTER:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeaderFooterViewHolder(footerView);
            <span class="hljs-keyword">case</span> TYPE_TITLE:
                View titleView=inflater.inflate(R.layout.recycler_view_multi_title,parent,<span class="hljs-keyword">false</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TitleViewHolder(titleView);
            <span class="hljs-keyword">case</span> TYPE_CONTENT:
                View contentView=inflater.inflate(R.layout.recycler_view_multi_item,parent,<span class="hljs-keyword">false</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ContentViewHolder(contentView);
            <span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    @Override
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onBindViewHolder(RecyclerView.ViewHolder holder, <span class="hljs-keyword">int</span> position) {
        <span class="hljs-keyword">int</span> viewType=getItemViewType(position);
        <span class="hljs-keyword">if</span>(viewType==TYPE_TITLE){<!-- --><span class="hljs-comment">//为标题形式的列表项绑定数据</span>
            TitleBean titleBean= (TitleBean) getItem(position);
            TitleViewHolder titleViewHolder= (TitleViewHolder) holder;
            titleViewHolder.titleView.setText(titleBean.getTitle());
        }
        <span class="hljs-keyword">if</span>(viewType==TYPE_CONTENT){<!-- --><span class="hljs-comment">//为内容形式的列表项绑定数据</span>
            ItemBean itemBean= (ItemBean) getItem(position);
            ContentViewHolder contentViewHolder= (ContentViewHolder) holder;
            contentViewHolder.itemImageView.setImageResource(itemBean.getImageRes());
            contentViewHolder.itemContentView.setText(itemBean.getContent());
        }
    }

    @Override
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> getItemCount() {<!-- --><span class="hljs-comment">//计算列表项的真正数量</span>
        <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span>=dataList.size();
        <span class="hljs-keyword">if</span>(headerView!=<span class="hljs-keyword">null</span>){
            <span class="hljs-keyword">count</span>++;
        }
        <span class="hljs-keyword">if</span>(footerView!=<span class="hljs-keyword">null</span>){
            <span class="hljs-keyword">count</span>++;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>;<span class="hljs-comment">//返回列表头、列表尾和列表项的总数量</span>
    }

    @Override
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> getItemViewType(<span class="hljs-keyword">int</span> position) {
        <span class="hljs-keyword">if</span>(headerView!=<span class="hljs-keyword">null</span>&amp;&amp;position==<span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> TYPE_HEADER;
        }
        <span class="hljs-keyword">if</span>(footerView!=<span class="hljs-keyword">null</span>&amp;&amp;position==headerCount+dataList.size()){
            <span class="hljs-keyword">return</span> TYPE_FOOTER;
        }
        BaseMultiBean baseMultiBean=dataList.get(position-headerCount);
        <span class="hljs-keyword">return</span> baseMultiBean.getType();
    }

    <span class="hljs-comment">//设置列表头</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setHeaderView(View headerView){
        <span class="hljs-keyword">this</span>.headerView=headerView;
        headerCount=<span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">//移除列表头</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> removeHeaderView(){
        headerView=<span class="hljs-keyword">null</span>;
        headerCount=<span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">//设置列表尾</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setFooterView(View footerView){
        <span class="hljs-keyword">this</span>.footerView=footerView;
    }

    <span class="hljs-comment">//移除列表尾</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> removeFooterView(){
        footerView=<span class="hljs-keyword">null</span>;
    }

    <span class="hljs-comment">//获取数据源中的真实数据（避免HeaderView的影响）</span>
    <span class="hljs-keyword">private</span> BaseMultiBean getItem(<span class="hljs-keyword">int</span> position){
        <span class="hljs-keyword">return</span> dataList.get(position-headerCount);
    }

    <span class="hljs-comment">//内容Item的ViewHolder</span>
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContentViewHolder</span> <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span>{<!-- --></span>
        <span class="hljs-keyword">private</span> TextView itemContentView;
        <span class="hljs-keyword">private</span> ImageView itemImageView;
        <span class="hljs-keyword">public</span> ContentViewHolder(View itemView) {
            <span class="hljs-keyword">super</span>(itemView);
            itemContentView=itemView.findViewById(R.id.item_content);
            itemImageView=itemView.findViewById(R.id.item_image);
        }
    }

    <span class="hljs-comment">//标题Item的ViewHolder</span>
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TitleViewHolder</span> <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span>{<!-- --></span>
        <span class="hljs-keyword">private</span> TextView titleView;
        <span class="hljs-keyword">public</span> TitleViewHolder(View itemView) {
            <span class="hljs-keyword">super</span>(itemView);
            titleView=itemView.findViewById(R.id.item_title);
        }
    }

    <span class="hljs-comment">//头部和尾部布局的ViewHolder</span>
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeaderFooterViewHolder</span> <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span>{<!-- --></span>
        <span class="hljs-keyword">public</span> HeaderFooterViewHolder(View itemView) {
            <span class="hljs-keyword">super</span>(itemView);
        }
    }
}</code></pre> 
<p>可以看到，我们为标题形式的列表项、内容形式的列表项、列表头/尾分别定义了ViewHolder类，并在<code>onCreateViewHolder</code>方法中根据<code>viewType</code>返回对应的ViewHolder对象。而在<code>onBindViewHolder</code>方法中，则根据<code>viewType</code>的值进行数据绑定。</p> 
<p><strong>注意：</strong>在获取列表项对象时，要排除HeaderView对position的影响，即当HeaderView存在时让position减去1。</p> 
<h4 id="为recyclerview设置适配器">为RecyclerView设置适配器</h4> 
<p>完成前面的准备工作后，就可以着手为RecyclerView设置适配器了，代码如下：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">//初始化列表头和列表尾
headerView=LayoutInflater<span class="hljs-preprocessor">.from</span>(this)<span class="hljs-preprocessor">.inflate</span>(R<span class="hljs-preprocessor">.layout</span><span class="hljs-preprocessor">.recycler</span>_view_header,null)<span class="hljs-comment">;</span>
footerView=LayoutInflater<span class="hljs-preprocessor">.from</span>(this)<span class="hljs-preprocessor">.inflate</span>(R<span class="hljs-preprocessor">.layout</span><span class="hljs-preprocessor">.recycler</span>_view_footer,null)<span class="hljs-comment">;</span>

//初始化多布局的RecyclerView
List&lt;BaseMultiBean&gt; multiDataList=new ArrayList&lt;&gt;()<span class="hljs-comment">;</span>
multiDataList<span class="hljs-preprocessor">.add</span>(new TitleBean(<span class="hljs-string">"第一个区域"</span>))<span class="hljs-comment">;</span>
multiDataList<span class="hljs-preprocessor">.add</span>(new ItemBean(R<span class="hljs-preprocessor">.mipmap</span><span class="hljs-preprocessor">.ic</span>_launcher,<span class="hljs-string">"《小王子》"</span>))<span class="hljs-comment">;</span>
multiDataList<span class="hljs-preprocessor">.add</span>(new ItemBean(R<span class="hljs-preprocessor">.mipmap</span><span class="hljs-preprocessor">.ic</span>_launcher,<span class="hljs-string">"《狮子王》"</span>))<span class="hljs-comment">;</span>
multiDataList<span class="hljs-preprocessor">.add</span>(new TitleBean(<span class="hljs-string">"第二个区域"</span>))<span class="hljs-comment">;</span>
multiDataList<span class="hljs-preprocessor">.add</span>(new ItemBean(R<span class="hljs-preprocessor">.mipmap</span><span class="hljs-preprocessor">.ic</span>_launcher,<span class="hljs-string">"《资本论》"</span>))<span class="hljs-comment">;</span>
multiDataList<span class="hljs-preprocessor">.add</span>(new ItemBean(R<span class="hljs-preprocessor">.mipmap</span><span class="hljs-preprocessor">.ic</span>_launcher,<span class="hljs-string">"《三体》"</span>))<span class="hljs-comment">;</span>
multiDataList<span class="hljs-preprocessor">.add</span>(new ItemBean(R<span class="hljs-preprocessor">.mipmap</span><span class="hljs-preprocessor">.ic</span>_launcher,<span class="hljs-string">"《孤独的进化者》"</span>))<span class="hljs-comment">;</span>
styleRecyclerViewAdapter=new StyleRecyclerViewAdapter(multiDataList)<span class="hljs-comment">;</span>

//设置列表头和列表尾
styleRecyclerViewAdapter<span class="hljs-preprocessor">.setHeaderView</span>(headerView)<span class="hljs-comment">;</span>
styleRecyclerViewAdapter<span class="hljs-preprocessor">.setFooterView</span>(footerView)<span class="hljs-comment">;</span>

//设置布局管理器和适配器
LinearLayoutManager styleLayoutManager=new LinearLayoutManager(this)<span class="hljs-comment">;</span>
styleRecyclerView<span class="hljs-preprocessor">.setLayoutManager</span>(styleLayoutManager)<span class="hljs-comment">;</span>
styleRecyclerView<span class="hljs-preprocessor">.setAdapter</span>(styleRecyclerViewAdapter)<span class="hljs-comment">;</span>
</code></pre> 
<h4 id="完善列表头和列表尾">完善列表头和列表尾</h4> 
<p>上文介绍了添加列表头和列表尾的方法，但针对的只是垂直排列的<code>LinearLayoutManager</code>。如果使用GridLayoutManager或StaggeredGridLayoutManager，列表头/尾就会显示异常。因此针对这两种管理器，还需要使用额外的布局措施。</p> 
<p><strong>GridLayoutManager</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAttachedToRecyclerView</span>(RecyclerView recyclerView) {
    <span class="hljs-keyword">super</span>.onAttachedToRecyclerView(recyclerView);
    RecyclerView.LayoutManager layoutManager=recyclerView.getLayoutManager();

    <span class="hljs-comment">//针对网格型的布局管理器进行额外处理，避免头/尾布局显示异常</span>
    <span class="hljs-keyword">if</span>(layoutManager <span class="hljs-keyword">instanceof</span> GridLayoutManager){
        <span class="hljs-keyword">final</span> GridLayoutManager gridLayoutManager= (GridLayoutManager) layoutManager;
        <span class="hljs-keyword">final</span> GridLayoutManager.SpanSizeLookup spanSizeLookup=gridLayoutManager
                .getSpanSizeLookup();<span class="hljs-comment">//保存旧的布局方式</span>
        gridLayoutManager.setSpanSizeLookup(<span class="hljs-keyword">new</span> GridLayoutManager.SpanSizeLookup() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSpanSize</span>(<span class="hljs-keyword">int</span> position) {
                <span class="hljs-keyword">int</span> viewType=getItemViewType(position);
                <span class="hljs-keyword">if</span>(viewType==TYPE_HEADER||viewType==TYPE_FOOTER){
                    <span class="hljs-keyword">return</span> gridLayoutManager.getSpanCount();<span class="hljs-comment">//返回当前网格的列数（即让列表头/尾占据一行）</span>
                }
                <span class="hljs-keyword">return</span> spanSizeLookup.getSpanSize(position);
            }
        });
    }
}</code></pre> 
<p>针对GridLayoutManager，需要重写<code>RecyclerView.Adapter</code>的<code>onAttachedToRecyclerView</code>方法，并在显示列表头/尾的时候让其占据整行，就可以保证列表头/为尾正常显示。</p> 
<p><strong>StaggeredGridLayoutManager</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewAttachedToWindow</span>(RecyclerView.ViewHolder holder) {
    <span class="hljs-keyword">super</span>.onViewAttachedToWindow(holder);
    <span class="hljs-keyword">int</span> viewType=holder.getItemViewType();
    <span class="hljs-keyword">if</span>(viewType==TYPE_HEADER||viewType==TYPE_FOOTER){
        ViewGroup.LayoutParams layoutParams=holder.itemView.getLayoutParams();

        <span class="hljs-comment">//针对瀑布流式的布局管理器进行额外处理，避免头/尾布局显示异常</span>
        <span class="hljs-keyword">if</span>(layoutParams <span class="hljs-keyword">instanceof</span> StaggeredGridLayoutManager.LayoutParams){
            StaggeredGridLayoutManager.LayoutParams staggerLayoutParams=
                    (StaggeredGridLayoutManager.LayoutParams) layoutParams;
            staggerLayoutParams.setFullSpan(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//列表头/尾占据一行</span>
        }
    }
}</code></pre> 
<p>针对StaggeredGridLayoutManager，需要重写<code>RecyclerView.Adapter</code>的<code>onViewAttachedToWindow</code>方法，并在显示列表头/尾的时候让其占据整行，就可以保证列表头/为尾正常显示。</p> 
<h3 id="常用技巧">常用技巧</h3> 
<h4 id="实现局部刷新">实现局部刷新</h4> 
<p>除了使用<code>notifyDatasetChanged</code>方法通知整个列表刷新外，<code>RecyclerView.Adapter</code>还提供了多个局部刷新的方法，说明如下：</p> 
<p><strong>通知指定位置的Item已经改变：</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyItemChanged</span>(<span class="hljs-keyword">int</span> position);
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyItemChanged</span>(<span class="hljs-keyword">int</span> position, Object payload);</code></pre> 
<p>这里需要重点说明<code>payload</code>参数的作用，简单来说就是实现列表项的局部更新。在很多情况下，一个列表项中可能存在多个View，典型的例子如朋友圈中的一条动态，就有图片、头像、点赞、评论等多个组成部分。如果只是点赞数发生了变化，就没有必要更新整个列表项，而只需更新点赞区域即可。此时，只需要为<code>payload</code>传入一个<strong>不为null</strong>的参数，就可以做到局部更新。</p> 
<p>以上文介绍的多布局RecyclerView为例，我们来实现局部更新内容列表项的文字部分。首先，重写ViewHolder中的<code>onBindViewHolder(RecyclerView.ViewHolder holder,int position,List&lt;Object&gt; payloads)</code>方法，这个方法会在<code>onBindViewHolder(RecyclerView.ViewHolder holder, int position)</code>方法之前调用。示例代码如下：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//在这个方法中实现Item的局部更新（比如只更新ViewHolder中的一个View）</span>
<span class="hljs-annotation">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span>(RecyclerView.ViewHolder holder, <span class="hljs-keyword">int</span> position, List&lt;Object&gt; payloads) {
    <span class="hljs-keyword">if</span>(payloads.isEmpty()){<!-- --><span class="hljs-comment">//如果payloads为空，就调用默认实现</span>
        <span class="hljs-keyword">super</span>.onBindViewHolder(holder,position,payloads);
    }
    <span class="hljs-keyword">else</span>{<!-- --><span class="hljs-comment">//在payloads不为空的时候实现ViewHolder中的部分更新</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-string">"TYPE_CONTENT"</span>.equals(payloads.get(<span class="hljs-number">0</span>))){
            ContentViewHolder contentViewHolder= (ContentViewHolder) holder;
            ItemBean itemBean= (ItemBean) getItem(position);
            contentViewHolder.itemContentView.setText(itemBean.getContent());
        }
    }
}</code></pre> 
<p>这个方法中的payloads参数是一个<strong>不为null</strong>的List，里面就包含在<code>notifyItemChanged</code>方法中传入的payload参数。通过判断payloads是否为空，就知道是否需要进行局部更新了。</p> 
<p>随后，在代码中调用相应的notifyItemChanged方法，并传入payload参数，示例代码如下：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">ItemBean itemBean= (ItemBean) multiDataList<span class="hljs-preprocessor">.get</span>(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span>
itemBean<span class="hljs-preprocessor">.setContent</span>(<span class="hljs-string">"《通过局部更新获得的内容》"</span>)<span class="hljs-comment">;</span>
multiDataList<span class="hljs-preprocessor">.set</span>(<span class="hljs-number">2</span>,itemBean)<span class="hljs-comment">;</span>
//这里的payload用于标识要更新的列表项类型
styleRecyclerViewAdapter<span class="hljs-preprocessor">.notifyItemChanged</span>(<span class="hljs-number">3</span>,<span class="hljs-string">"TYPE_CONTENT"</span>)<span class="hljs-comment">;</span></code></pre> 
<p><strong>注意：</strong>如果不使用局部更新的方式，即使列表项中的图片并未发生改变，在刷新过程中图片区域依旧会出现短暂的闪烁现象，使用局部更新就可以解决这一问题。</p> 
<p><strong>普通刷新效果截图：</strong> <br> <img src="https://images2.imgbox.com/eb/98/KTdv0qp8_o.gif" width="30%"></p> 
<p><strong>局部更新效果截图：</strong> <br> <img src="https://images2.imgbox.com/61/86/kH5GachD_o.gif" width="30%"></p> 
<p><strong>通知指定范围内的Item已经改变：</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//itemCount：改变的Item数量</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyItemRangeChanged</span>(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount);
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyItemRangeChanged</span>(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount, Object payload);</code></pre> 
<p><code>payload</code>参数的作用上面已经说明了，这里不再赘述。</p> 
<p><strong>通知有新的数据插入：</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyItemInserted</span>(<span class="hljs-keyword">int</span> position);
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyItemRangeInserted</span>(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount);</code></pre> 
<p><strong>效果截图：</strong></p> 
<p><img src="https://images2.imgbox.com/5a/06/wwweqoWG_o.gif" width="30%"></p> 
<p><strong>通知有数据被移除：</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyItemRangeRemoved</span>(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount);
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyItemRemoved</span>(<span class="hljs-keyword">int</span> position);</code></pre> 
<p><strong>效果截图：</strong></p> 
<p><img src="https://images2.imgbox.com/ad/9a/tBBPaKIj_o.gif" width="30%"></p> 
<p><strong>通知有Item发生了移动：</strong></p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyItemMoved</span>(<span class="hljs-keyword">int</span> fromPosition, <span class="hljs-keyword">int</span> toPosition);</code></pre> 
<p>以上这些方法都只会对RecyclerView进行局部刷新，优化了运行效率，同时也会触发动画效果，大幅度改善了用户体验。</p> 
<p><strong>注意：</strong>以上这些局部刷新方法中的<code>position</code>位置参数应该传入正确的值，否则可能导致RecyclerView显示异常。</p> 
<h4 id="为列表项设置添加和删除动画">为列表项设置添加和删除动画</h4> 
<p>调用RecyclerView的<code>setItemAnimator</code>方法就可以设置动画效果，这个方法原型如下：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setItemAnimator</span>(ItemAnimator animator);</code></pre> 
<p>参数的类型是<code>RecyclerView.ItemAnimator</code>，系统已经提供了一个默认实现类<code>DefaultItemAnimator</code>，使用方式如下：</p> 
<pre class="prettyprint"><code class=" hljs cs">recyclerView.setItemAnimator(<span class="hljs-keyword">new</span> DefaultItemAnimator());<span class="hljs-comment">//设置默认的动画效果</span></code></pre> 
<p>除此之外，还可以通过继承<code>RecyclerView.ItemAnimator</code>实现自定义动画效果，这里推荐使用开源的动画库：</p> 
<blockquote> 
 <p><a href="https://github.com/wasabeef/recyclerview-animators">recyclerview-animators</a></p> 
</blockquote> 
<h4 id="为列表项设置分割线">为列表项设置分割线</h4> 
<p>RecyclerView中的列表项默认是没有分割线的，如果想要实现这一需求，就要通过继承<code>RecyclerView.ItemDecoration</code>这个抽象类实现我们自己的列表项装饰器。这个类需要实现的主要方法如下：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> ItemDecoration {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span>(Canvas c, RecyclerView parent, State state) {
        onDraw(c, parent);
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDrawOver</span>(Canvas c, RecyclerView parent, State state) {
        onDrawOver(c, parent);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getItemOffsets</span>(Rect outRect, View view, RecyclerView parent, State state) {
        getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(),
                parent);
    }
}</code></pre> 
<p><code>onDraw</code>方法会在绘制列表项之前调用，因此绘制的内容会在列表项之下；而<code>onDrawOver</code>会在绘制列表项之后调用，因此绘制的内容会在列表项之上（只可以用于实现角标等需求）；<code>getItemOffsets</code>方法可以通过<code>outRect.set()</code>的方式为列表项设置偏移量。</p> 
<p>这里推荐一个第三方的开源库：</p> 
<blockquote> 
 <p>列表项装饰器：<a href="https://github.com/dinuscxj/RecyclerItemDecoration">RecyclerItemDecoration</a></p> 
</blockquote> 
<p><strong>小提示：</strong>如果仅仅想要在列表项之间增加一些间隔，也可以简单地在Item的布局文件中设置<code>margin</code>属性，在一些简单的场景下这样做代价更小。</p> 
<h4 id="添加头部和尾部">添加头部和尾部</h4> 
<p>请参考上文：</p> 
<blockquote> 
 <p><strong>[实现多布局列表（包括列表头和列表尾）]</strong></p> 
</blockquote> 
<h4 id="设置emptyview">设置EmptyView</h4> 
<p>个人并不推荐通过重写RecyclerView的方式实现EmptyView，因此后续会写一篇博客介绍如何通过自定义View的方式实现一个通用的多状态布局（加载中、无数据、加载错误等）。</p> 
<blockquote> 
 <p>《Android 通过自定义View实现通用的多状态布局》（待填坑）</p> 
</blockquote> 
<p>这里先推荐两个简单的多布局开源库：</p> 
<blockquote> 
 <p><a href="https://github.com/czy1121/loadinglayout">loadinglayout</a> <br> <a href="https://github.com/Syehunter/MaterialPageStateLayout">MaterialPageStateLayout</a></p> 
</blockquote> 
<h4 id="监听滚动状态">监听滚动状态</h4> 
<p>监听滚动状态需要使用RecyclerView的<code>addOnScrollListener</code>方法，示例代码如下：</p> 
<pre class="prettyprint"><code class=" hljs java">recyclerView.addOnScrollListener(<span class="hljs-keyword">new</span> RecyclerView.OnScrollListener() {
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onScrollStateChanged</span>(RecyclerView recyclerView, <span class="hljs-keyword">int</span> newState) {
        <span class="hljs-comment">//滑动状态发生改变</span>
        <span class="hljs-comment">//newState的可能值：[SCROLL_STATE_IDLE|SCROLL_STATE_DRAGGING|SCROLL_STATE_SETTLING]</span>
    }
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onScrolled</span>(RecyclerView recyclerView, <span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy) {
        <span class="hljs-comment">//滑动过程中将反复触发</span>
        <span class="hljs-comment">//dx：水平方向的滑动距离</span>
        <span class="hljs-comment">//dy：垂直方向的滑动距离</span>
    }
});</code></pre> 
<p>onScrollStateChanged方法会在滑动状态发生改变时回调，newState有三种三种取值，含义如下：</p> 
<ol><li>SCROLL_STATE_IDLE：静止状态</li><li>SCROLL_STATE_DRAGGING：滑动状态（用户此时触碰着屏幕且在滑动）</li><li>SCROLL_STATE_SETTLING：惯性滑动状态（用户此时未触碰屏幕，RecyclerView借助上一次滑动的惯性滑动）</li></ol> 
<p>onScrolled方法会在滑动过程中将反复触发，dx和dy的含义如下：</p> 
<ol><li>dx：水平方向的滑动距离。如果dx大于0，代表手指向左滑动；如果dx小于0，代表手指向右滑动。如果RecyclerView是垂直布局（只能上下滑动），则dx始终为0。</li><li>dy：垂直方向的滑动距离。如果dy大于0，代表手指向上滑动；如果dy小于0，代表手指向下滑动。如果RecyclerView是水平布局（只能左右滑动），则dy始终为0。</li></ol> 
<p><strong>注意：</strong>如果可见列表项发生了变化，onScrolled方法也会回调，此时dx和dy都为0。</p> 
<h4 id="判断recyclerview是否已经滚动到底部或顶部">判断RecyclerView是否已经滚动到底部或顶部</h4> 
<p>需要使用的关键方法是<code>canScrollVertically</code>，该方法的原型如下：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//direction：传入正数代表是否还能向下滚动；传入负数代表是否还能向上滚动</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canScrollVertically</span>(<span class="hljs-keyword">int</span> direction);</code></pre> 
<p>比如调用recyclerView.canScrollVertically(1)，返回false就代表RecyclerView已经滚动到底部；调用recyclerView.canScrollVertically(-1)，返回false就表示RecyclerView已经滚动到顶部。</p> 
<p>同理，<code>canScrollHorizontally</code>用于判断RecyclerView是否已经滚动到最左端或最右端。</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//direction：传入正数代表是否还能向右滚动；传入负数代表是否还能向左滚动</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canScrollHorizontally</span>(<span class="hljs-keyword">int</span> direction);</code></pre> 
<p>比如调用recyclerView.canScrollHorizontally(1)，返回false就代表RecyclerView已经滚动到最右端；调用recyclerView.canScrollHorizontally(-1)，返回false就表示RecyclerView已经滚动到最左端。</p> 
<h3 id="更多博客">更多博客</h3> 
<blockquote> 
 <p><a href="http://blog.csdn.net/codingending/article/details/79512087">《Android UI ListView讲解》</a>：详细讲解ListView的使用和常用技巧。 <br> <a href="http://blog.csdn.net/CodingEnding/article/details/79518615">《 Android UI GridView讲解》</a>：详细讲解GridView的使用方法和常用技巧。 <br> <a href="http://blog.csdn.net/codingending/article/details/79478477">《 Android UI 常用控件讲解》</a>：包括CheckBox、RadioButton、ToggleButton、Switch、ProgressBar、SeekBar、RatingBar、Spinner、ImageButton。</p> 
</blockquote> 
<h3 id="demo下载地址">demo下载地址</h3> 
<blockquote> 
 <p><a href="https://github.com/CodingEnding/UISystemDemo">https://github.com/CodingEnding/UISystemDemo</a> [ 持续更新中 ]</p> 
</blockquote> 
<h3 id="相关的开源库">相关的开源库</h3> 
<blockquote> 
 <p>动画效果库：<a href="https://github.com/wasabeef/recyclerview-animators">recyclerview-animators</a> <br> 列表项装饰器：<a href="https://github.com/dinuscxj/RecyclerItemDecoration">RecyclerItemDecoration</a></p> 
</blockquote> 
<h3 id="参考资料">参考资料</h3> 
<blockquote> 
 <p><a href="https://blog.csdn.net/qq_26585943/article/details/73739427">https://blog.csdn.net/qq_26585943/article/details/73739427</a> <br> <a href="https://blog.csdn.net/lmj623565791/article/details/45059587">https://blog.csdn.net/lmj623565791/article/details/45059587</a> <br> <a href="https://stackoverflow.com/questions/33176336/need-an-example-about-recyclerview-adapter-notifyitemchangedint-position-objec" rel="nofollow">https://stackoverflow.com/questions/33176336/need-an-example-about-recyclerview-adapter-notifyitemchangedint-position-objec</a> <br> <a href="https://www.jianshu.com/p/ce347cf991db" rel="nofollow">https://www.jianshu.com/p/ce347cf991db</a></p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b2c814da39e8c38573659f83b9e56d11/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">浅尝flutter中的3D效果</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e3bea5dd21d0c4c66c54e7bbd7e69966/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">select标签设置multiple属性，如何获取值</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>