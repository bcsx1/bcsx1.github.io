<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>UE4 Actor生命周期 SpawnActor DestroyActor剖析 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="UE4 Actor生命周期 SpawnActor DestroyActor剖析" />
<meta property="og:description" content="原创文章，转载请注明出处。
AActor很重要，只要是我们世界大纲列表内的物体，全部都是AActor。
目录
第一部分，从编辑器点击Play开始分析World里面全部的Actor的Spawn流程，分析到调用BeginPlay结束
1&gt;下面从点击场景中的Play/PlayInEditor/Play In Standalone开始，代码执行的顺序，只是大致的。后续引擎版本变化可能会不同(猜测)。我从堆栈拷贝的代码，从下往上看。
2&gt;上面生成了熟悉的GameInstance，GameMode怎么生成出来的？
3&gt;上面生成了熟悉的GameInstance，那么GameMode怎么生成出来的？贴出堆栈的图
4&gt;那么场景中的Actor列表怎么个调用BeginPlay的流程呢？
1)会判断Actors列表是否已经被初始化过了。if( !AreActorsInitialized() )，看来这个方法会被调用多次
2)没有被初始化的时候呢，有下面的代码，下面的则就是真正的初始化部分了。跟进去看一看
3)对每个Actor上的全部组件进行初始化。上图，但是注意此时Actor的BeginPlay还没有执行。还没到Actor的BeginPlay，还在下头
4)ActorBeginPlay调用的位置如下
第二部分，从代码层面调用SpawnActor，对其做分析
1&gt;编码测试
2&gt;源码分析
1)SpawnActor源码分析
2）Actor-&gt;PostSpawnInitialize源码分析
3）void AActor::PostActorConstruction()源码分析这个里面会初始化Actor下面的组件， 主要是下面的代码调用的BeginPlay
4）void AActor::DispatchBeginPlay(bool bFromLevelStreaming)源码分析
第三部分，从代码层面调用DestroyActor，对其做分析
1&gt;编码测试
2&gt;源码分析
1) void AActor::Destroyed()源码分析
2) RouteEndPlay(EEndPlayReason::Destroyed)源码分析
第一部分，从编辑器点击Play开始分析World里面全部的Actor的Spawn流程，分析到调用BeginPlay结束 在剖析Actor生命周期之前，我跟了一下Editor和Standlone的代码，找到了场景中actor列表的初始化的地方。
1&gt;下面从点击场景中的Play/PlayInEditor/Play In Standalone开始，代码执行的顺序，只是大致的。后续引擎版本变化可能会不同(猜测)。我从堆栈拷贝的代码，从下往上看。 8 StartPlayInEditorGameInstance中调用了创建GameMode创建GameMode，这个是在GameInstance里面创建的 UGameInstance::CreateGameModeForURL(FURL InURL, UWorld * InWorld) UWorld::SetGameMode(const FURL &amp; InURL) 7 下面文章中还会接着介绍这个里面的代码 UGameInstance::StartPlayInEditorGameInstance(ULocalPlayer * LocalPlayer, const FGameInstancePIEParameters &amp; Params) 6 这个方法就是在创建GameInstance，并且有趣的是上面几个方法也是在这里面调用的 //在这个里面创建了GameMode,就是上面的代码 UEditorEngine::CreateInnerProcessPIEGameInstance(FRequestPlaySessionParams &amp; InParams, const FGameInstancePIEParameters &amp; InPIEParameters, int InPIEInstanceIndex) 5&gt; UEditorEngine::OnLoginPIEComplete_Deferred(int LocalUserNum, bool bWasSuccessful, FString ErrorString, FPieLoginStruct DataStruct) 4&gt;创建一个Editor新窗口的实例 UEditorEngine::CreateNewPlayInEditorInstance(FRequestPlaySessionParams &amp; InRequestParams, const bool bInDedicatedInstance, const EPlayNetMode InNetMode) 3&gt;拿PlayInEditor举例, 该方法中会判断一些条件，比如开着Matinee了，不让播放 UEditorEngine::StartPlayInEditorSession(FRequestPlaySessionParams &amp; InRequestParams) 2&gt;从StartQueuedPlaySessionRequest过来的，并且从这个方法里面判断是哪一种, 是Standalone?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f2ae202a6499eeddf5520ab50b90db50/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-08T09:59:40+08:00" />
<meta property="article:modified_time" content="2022-02-08T09:59:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">UE4 Actor生命周期 SpawnActor DestroyActor剖析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#f33b45;">原创文章，转载请注明出处。</span></p> 
<p></p> 
<p>AActor很重要，只要是我们世界大纲列表内的物体，全部都是AActor。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E4%BB%8E%E7%BC%96%E8%BE%91%E5%99%A8%E7%82%B9%E5%87%BBPlay%E5%BC%80%E5%A7%8B%E5%88%86%E6%9E%90World%E9%87%8C%E9%9D%A2%E5%85%A8%E9%83%A8%E7%9A%84Actor%E7%9A%84Spawn%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%88%86%E6%9E%90%E5%88%B0%E8%B0%83%E7%94%A8BeginPlay%E7%BB%93%E6%9D%9F-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E4%BB%8E%E7%BC%96%E8%BE%91%E5%99%A8%E7%82%B9%E5%87%BBPlay%E5%BC%80%E5%A7%8B%E5%88%86%E6%9E%90World%E9%87%8C%E9%9D%A2%E5%85%A8%E9%83%A8%E7%9A%84Actor%E7%9A%84Spawn%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%88%86%E6%9E%90%E5%88%B0%E8%B0%83%E7%94%A8BeginPlay%E7%BB%93%E6%9D%9F" rel="nofollow">第一部分，从编辑器点击Play开始分析World里面全部的Actor的Spawn流程，分析到调用BeginPlay结束</a></p> 
<p id="%E4%B8%8B%E9%9D%A2%E4%BB%8E%E7%82%B9%E5%87%BB%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84Play%2FPlayInEditor%2FPlay%20In%20Standalone%E5%BC%80%E5%A7%8B%EF%BC%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%A4%A7%E8%87%B4%E7%9A%84%E3%80%82%E5%90%8E%E7%BB%AD%E5%BC%95%E6%93%8E%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%B8%8D%E5%90%8C(%E7%8C%9C%E6%B5%8B)%E3%80%82%E6%88%91%E4%BB%8E%E5%A0%86%E6%A0%88%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BB%8E%E4%B8%8B%E5%BE%80%E4%B8%8A%E7%9C%8B%E3%80%82-toc" style="margin-left:40px;"><a href="#%E4%B8%8B%E9%9D%A2%E4%BB%8E%E7%82%B9%E5%87%BB%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84Play%2FPlayInEditor%2FPlay%20In%20Standalone%E5%BC%80%E5%A7%8B%EF%BC%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%A4%A7%E8%87%B4%E7%9A%84%E3%80%82%E5%90%8E%E7%BB%AD%E5%BC%95%E6%93%8E%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%B8%8D%E5%90%8C%28%E7%8C%9C%E6%B5%8B%29%E3%80%82%E6%88%91%E4%BB%8E%E5%A0%86%E6%A0%88%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BB%8E%E4%B8%8B%E5%BE%80%E4%B8%8A%E7%9C%8B%E3%80%82" rel="nofollow">1&gt;下面从点击场景中的Play/PlayInEditor/Play In Standalone开始，代码执行的顺序，只是大致的。后续引擎版本变化可能会不同(猜测)。我从堆栈拷贝的代码，从下往上看。</a></p> 
<p id="%E4%B8%8A%E9%9D%A2%E7%94%9F%E6%88%90%E4%BA%86%E7%86%9F%E6%82%89%E7%9A%84GameInstance%EF%BC%8CGameMode%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%B8%8A%E9%9D%A2%E7%94%9F%E6%88%90%E4%BA%86%E7%86%9F%E6%82%89%E7%9A%84GameInstance%EF%BC%8CGameMode%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F" rel="nofollow">2&gt;上面生成了熟悉的GameInstance，GameMode怎么生成出来的？</a></p> 
<p id="%E4%B8%8A%E9%9D%A2%E7%94%9F%E6%88%90%E4%BA%86%E7%86%9F%E6%82%89%E7%9A%84GameInstance%EF%BC%8C%E9%82%A3%E4%B9%88GameMode%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F%E8%B4%B4%E5%87%BA%E5%A0%86%E6%A0%88%E7%9A%84%E5%9B%BE-toc" style="margin-left:40px;"><a href="#%E4%B8%8A%E9%9D%A2%E7%94%9F%E6%88%90%E4%BA%86%E7%86%9F%E6%82%89%E7%9A%84GameInstance%EF%BC%8C%E9%82%A3%E4%B9%88GameMode%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F%E8%B4%B4%E5%87%BA%E5%A0%86%E6%A0%88%E7%9A%84%E5%9B%BE" rel="nofollow">3&gt;上面生成了熟悉的GameInstance，那么GameMode怎么生成出来的？贴出堆栈的图</a></p> 
<p id="%E9%82%A3%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84Actor%E5%88%97%E8%A1%A8%E6%80%8E%E4%B9%88%E4%B8%AA%E8%B0%83%E7%94%A8BeginPlay%E7%9A%84%E6%B5%81%E7%A8%8B%E5%91%A2%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E9%82%A3%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84Actor%E5%88%97%E8%A1%A8%E6%80%8E%E4%B9%88%E4%B8%AA%E8%B0%83%E7%94%A8BeginPlay%E7%9A%84%E6%B5%81%E7%A8%8B%E5%91%A2%EF%BC%9F" rel="nofollow">4&gt;那么场景中的Actor列表怎么个调用BeginPlay的流程呢？</a></p> 
<p id="%C2%A0%20%C2%A01%3E%E4%BC%9A%E5%88%A4%E6%96%ADActors%E5%88%97%E8%A1%A8%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E4%BA%86%E3%80%82if(%20!AreActorsInitialized()%20)%EF%BC%8C%E7%9C%8B%E6%9D%A5%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E4%BC%9A%E8%A2%AB%E8%B0%83%E7%94%A8%E5%A4%9A%E6%AC%A1-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A01%3E%E4%BC%9A%E5%88%A4%E6%96%ADActors%E5%88%97%E8%A1%A8%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E4%BA%86%E3%80%82if%28%20!AreActorsInitialized%28%29%20%29%EF%BC%8C%E7%9C%8B%E6%9D%A5%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E4%BC%9A%E8%A2%AB%E8%B0%83%E7%94%A8%E5%A4%9A%E6%AC%A1" rel="nofollow">   1)会判断Actors列表是否已经被初始化过了。if( !AreActorsInitialized() )，看来这个方法会被调用多次</a></p> 
<p id="%C2%A0%20%C2%A02%3E%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E5%80%99%E5%91%A2%EF%BC%8C%E6%9C%89%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%88%99%E5%B0%B1%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%83%A8%E5%88%86%E4%BA%86%E3%80%82%E8%B7%9F%E8%BF%9B%E5%8E%BB%E7%9C%8B%E4%B8%80%E7%9C%8B-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A02%3E%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E5%80%99%E5%91%A2%EF%BC%8C%E6%9C%89%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%88%99%E5%B0%B1%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%83%A8%E5%88%86%E4%BA%86%E3%80%82%E8%B7%9F%E8%BF%9B%E5%8E%BB%E7%9C%8B%E4%B8%80%E7%9C%8B" rel="nofollow">   2)没有被初始化的时候呢，有下面的代码，下面的则就是真正的初始化部分了。跟进去看一看</a></p> 
<p id="%C2%A0%20%C2%A0%203%3E%E5%AF%B9%E6%AF%8F%E4%B8%AAActor%E4%B8%8A%E7%9A%84%E5%85%A8%E9%83%A8%E7%BB%84%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%E4%B8%8A%E5%9B%BE%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B3%A8%E6%84%8F%E6%AD%A4%E6%97%B6Actor%E7%9A%84BeginPlay%E8%BF%98%E6%B2%A1%E6%9C%89%E6%89%A7%E8%A1%8C%E3%80%82%E8%BF%98%E6%B2%A1%E5%88%B0Actor%E7%9A%84BeginPlay%EF%BC%8C%E8%BF%98%E5%9C%A8%E4%B8%8B%E5%A4%B4-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%203%3E%E5%AF%B9%E6%AF%8F%E4%B8%AAActor%E4%B8%8A%E7%9A%84%E5%85%A8%E9%83%A8%E7%BB%84%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%E4%B8%8A%E5%9B%BE%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B3%A8%E6%84%8F%E6%AD%A4%E6%97%B6Actor%E7%9A%84BeginPlay%E8%BF%98%E6%B2%A1%E6%9C%89%E6%89%A7%E8%A1%8C%E3%80%82%E8%BF%98%E6%B2%A1%E5%88%B0Actor%E7%9A%84BeginPlay%EF%BC%8C%E8%BF%98%E5%9C%A8%E4%B8%8B%E5%A4%B4" rel="nofollow">    3)对每个Actor上的全部组件进行初始化。上图，但是注意此时Actor的BeginPlay还没有执行。还没到Actor的BeginPlay，还在下头</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A04%3EActorBeginPlay%E8%B0%83%E7%94%A8%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%A6%82%E4%B8%8B-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A04%3EActorBeginPlay%E8%B0%83%E7%94%A8%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%A6%82%E4%B8%8B" rel="nofollow">     4)ActorBeginPlay调用的位置如下</a></p> 
<p id="%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%8C%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E8%B0%83%E7%94%A8SpawnActor%EF%BC%8C%E5%AF%B9%E5%85%B6%E5%81%9A%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%8C%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E8%B0%83%E7%94%A8SpawnActor%EF%BC%8C%E5%AF%B9%E5%85%B6%E5%81%9A%E5%88%86%E6%9E%90" rel="nofollow">第二部分，从代码层面调用SpawnActor，对其做分析</a></p> 
<p id="1%3E%E7%BC%96%E7%A0%81%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#1%3E%E7%BC%96%E7%A0%81%E6%B5%8B%E8%AF%95" rel="nofollow">1&gt;编码测试</a></p> 
<p id="2%3E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#2%3E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" rel="nofollow">2&gt;源码分析</a></p> 
<p id="1)SpawnActor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#1%29SpawnActor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" rel="nofollow">1)SpawnActor源码分析</a></p> 
<p id="2%EF%BC%89Actor-%3EPostSpawnInitialize%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2%EF%BC%89Actor-%3EPostSpawnInitialize%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" rel="nofollow">2）Actor-&gt;PostSpawnInitialize源码分析</a></p> 
<p id="3%EF%BC%89void%20AActor%3A%3APostActorConstruction()%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA%E9%87%8C%E9%9D%A2%E4%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96Actor%E4%B8%8B%E9%9D%A2%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%20%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E7%9A%84BeginPlay-toc" style="margin-left:80px;"><a href="#3%EF%BC%89void%20AActor%3A%3APostActorConstruction%28%29%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA%E9%87%8C%E9%9D%A2%E4%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96Actor%E4%B8%8B%E9%9D%A2%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%20%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E7%9A%84BeginPlay" rel="nofollow">3）void AActor::PostActorConstruction()源码分析这个里面会初始化Actor下面的组件， 主要是下面的代码调用的BeginPlay</a></p> 
<p id="4%EF%BC%89void%20AActor%3A%3ADispatchBeginPlay(bool%20bFromLevelStreaming)%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#4%EF%BC%89void%20AActor%3A%3ADispatchBeginPlay%28bool%20bFromLevelStreaming%29%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" rel="nofollow">4）void AActor::DispatchBeginPlay(bool bFromLevelStreaming)源码分析</a></p> 
<p id="%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%8C%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E8%B0%83%E7%94%A8DestroyActor%EF%BC%8C%E5%AF%B9%E5%85%B6%E5%81%9A%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%8C%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E8%B0%83%E7%94%A8DestroyActor%EF%BC%8C%E5%AF%B9%E5%85%B6%E5%81%9A%E5%88%86%E6%9E%90" rel="nofollow">第三部分，从代码层面调用DestroyActor，对其做分析</a></p> 
<p style="margin-left:40px;"><a href="#1%3E%E7%BC%96%E7%A0%81%E6%B5%8B%E8%AF%95" rel="nofollow">1&gt;编码测试</a></p> 
<p style="margin-left:40px;"><a href="#2%3E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" rel="nofollow">2&gt;源码分析</a></p> 
<p id="2)%20void%20AActor%3A%3ADestroyed()%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2%29%20void%20AActor%3A%3ADestroyed%28%29%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" rel="nofollow">1) void AActor::Destroyed()源码分析</a></p> 
<p id="3)%20RouteEndPlay(EEndPlayReason%3A%3ADestroyed)%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#3%29%20RouteEndPlay%28EEndPlayReason%3A%3ADestroyed%29%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" rel="nofollow">2) RouteEndPlay(EEndPlayReason::Destroyed)源码分析</a></p> 
<hr id="hr-toc"> 
<p></p> 
<hr> 
<h2 id="%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E4%BB%8E%E7%BC%96%E8%BE%91%E5%99%A8%E7%82%B9%E5%87%BBPlay%E5%BC%80%E5%A7%8B%E5%88%86%E6%9E%90World%E9%87%8C%E9%9D%A2%E5%85%A8%E9%83%A8%E7%9A%84Actor%E7%9A%84Spawn%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%88%86%E6%9E%90%E5%88%B0%E8%B0%83%E7%94%A8BeginPlay%E7%BB%93%E6%9D%9F">第一部分，从编辑器点击Play开始分析World里面全部的Actor的Spawn流程，分析到调用BeginPlay结束</h2> 
<p>在剖析<span style="color:#f33b45;">Actor生命周期之前，我跟了一下Editor和Standlone的代码，找到了场景中actor列表的初始化的地方。</span></p> 
<h3 id="%E4%B8%8B%E9%9D%A2%E4%BB%8E%E7%82%B9%E5%87%BB%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84Play%2FPlayInEditor%2FPlay%20In%20Standalone%E5%BC%80%E5%A7%8B%EF%BC%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%A4%A7%E8%87%B4%E7%9A%84%E3%80%82%E5%90%8E%E7%BB%AD%E5%BC%95%E6%93%8E%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%B8%8D%E5%90%8C(%E7%8C%9C%E6%B5%8B)%E3%80%82%E6%88%91%E4%BB%8E%E5%A0%86%E6%A0%88%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BB%8E%E4%B8%8B%E5%BE%80%E4%B8%8A%E7%9C%8B%E3%80%82"><span style="color:#3399ea;"><strong>1&gt;下面从点击场景中的Play/PlayInEditor/Play In Standalone开始，代码执行的顺序，只是大致的。后续引擎版本变化可能会不同(猜测)。我从堆栈拷贝的代码，从下往上看。</strong></span></h3> 
<pre><code class="language-cpp">8 StartPlayInEditorGameInstance中调用了创建GameMode创建GameMode，这个是在GameInstance里面创建的
UGameInstance::CreateGameModeForURL(FURL InURL, UWorld * InWorld)
UWorld::SetGameMode(const FURL &amp; InURL)

7 下面文章中还会接着介绍这个里面的代码
UGameInstance::StartPlayInEditorGameInstance(ULocalPlayer * LocalPlayer, const FGameInstancePIEParameters &amp; Params)

6 这个方法就是在创建GameInstance，并且有趣的是上面几个方法也是在这里面调用的
//在这个里面创建了GameMode,就是上面的代码
UEditorEngine::CreateInnerProcessPIEGameInstance(FRequestPlaySessionParams &amp; InParams, const FGameInstancePIEParameters &amp; InPIEParameters, int InPIEInstanceIndex)

5&gt;
UEditorEngine::OnLoginPIEComplete_Deferred(int LocalUserNum, bool bWasSuccessful, FString ErrorString, FPieLoginStruct DataStruct)

4&gt;创建一个Editor新窗口的实例
UEditorEngine::CreateNewPlayInEditorInstance(FRequestPlaySessionParams &amp; InRequestParams, const bool bInDedicatedInstance, const EPlayNetMode InNetMode)

3&gt;拿PlayInEditor举例, 该方法中会判断一些条件，比如开着Matinee了，不让播放
UEditorEngine::StartPlayInEditorSession(FRequestPlaySessionParams &amp; InRequestParams) 

2&gt;从StartQueuedPlaySessionRequest过来的，并且从这个方法里面判断是哪一种, 是Standalone?还是Play/PlayInEditor?
UEditorEngine::StartQueuedPlaySessionRequestImpl()

1&gt;点击编辑器中的Play按钮的时候调用的
UEditorEngine::StartQueuedPlaySessionRequest()
</code></pre> 
<h3 id="%E4%B8%8A%E9%9D%A2%E7%94%9F%E6%88%90%E4%BA%86%E7%86%9F%E6%82%89%E7%9A%84GameInstance%EF%BC%8CGameMode%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F"><span style="color:#f33b45;"><strong>2&gt;上面生成了熟悉的GameInstance，GameMode怎么生成出来的？</strong></span></h3> 
<pre><code class="language-cpp">创建GameMode GetGameInstance()-&gt;CreateGameModeForURL
bool UWorld::SetGameMode(const FURL&amp; InURL)
{
	if( IsServer() &amp;&amp; !AuthorityGameMode )
	{
		AuthorityGameMode = GetGameInstance()-&gt;CreateGameModeForURL(InURL, this);
		if( AuthorityGameMode != NULL )
		{
			return true;
		}
		else
		{
			UE_LOG(LogWorld, Error, TEXT("Failed to spawn GameMode actor."));
			return false;
		}
	}

	return false;
}


创建GameMode的代码，可以发现其实这个平常我们在worldSetting里面对每一个umap设置的GameMode
就是在这被生成出来的。转定义就可以发现Settings-&gt;DefaultGameMode;是个TSubclassOf&lt;&gt;,
看到这是不是就知道咋回事了。
AGameModeBase* UGameInstance::CreateGameModeForURL(FURL InURL, UWorld* InWorld)
{
	省略了部分代码

	// Get the GameMode class. Start by using the default game type specified in the map's worldsettings.  It may be overridden by settings below.
	TSubclassOf&lt;AGameModeBase&gt; GameClass = Settings-&gt;DefaultGameMode;

	省略了部分代码

    最后其实看到这个GameMode呢也是被Spawn出来的一个Actor
	return World-&gt;SpawnActor&lt;AGameModeBase&gt;(GameClass, SpawnInfo);
}</code></pre> 
<h3 id="%E4%B8%8A%E9%9D%A2%E7%94%9F%E6%88%90%E4%BA%86%E7%86%9F%E6%82%89%E7%9A%84GameInstance%EF%BC%8C%E9%82%A3%E4%B9%88GameMode%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F%E8%B4%B4%E5%87%BA%E5%A0%86%E6%A0%88%E7%9A%84%E5%9B%BE"><span style="color:#f33b45;"><strong>3&gt;上面生成了熟悉的GameInstance，那么GameMode怎么生成出来的？</strong></span>贴出堆栈的图</h3> 
<p><img alt="" height="904" src="https://images2.imgbox.com/e1/c3/TR0DYDXZ_o.png" width="1200"></p> 
<p>接着UGameInstance::StartPlayInEditorGameInstance讲</p> 
<p>1&gt;生成GameInstance之后，在该函数中生成了GameMode</p> 
<p>2&gt;接着生成完GameMode之后呢，调用了PlayWorld-&gt;CreateAISystem(); 创建<span style="color:#3399ea;">AI系统</span></p> 
<p>3&gt;PlayWorld-&gt;InitializeActorsForPlay(URL); <span style="color:#3399ea;"><strong>主要讲一下这块，这个里头就是世界大纲里面所有的Actors的初始化</strong></span></p> 
<p>4&gt;FNavigationSystem::AddNavigationSystemToWorld <span style="color:#3399ea;">添加AI导航网格</span></p> 
<p><span style="color:#3399ea;"><strong>5&gt;PlayWorld-&gt;BeginPlay();场景中初始化时候的Actor的BeginPlay在这</strong></span></p> 
<h3 id="%E9%82%A3%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84Actor%E5%88%97%E8%A1%A8%E6%80%8E%E4%B9%88%E4%B8%AA%E8%B0%83%E7%94%A8BeginPlay%E7%9A%84%E6%B5%81%E7%A8%8B%E5%91%A2%EF%BC%9F"><span style="color:#f33b45;">4&gt;那么场景中的Actor列表怎么个调用BeginPlay的流程呢？</span></h3> 
<p><strong>在场景开始时候，对所有的Actor进行初始化 <span style="color:#3399ea;">UWorld::InitializeActorsForPlay</span></strong></p> 
<h4 id="%C2%A0%20%C2%A01%3E%E4%BC%9A%E5%88%A4%E6%96%ADActors%E5%88%97%E8%A1%A8%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E4%BA%86%E3%80%82if(%20!AreActorsInitialized()%20)%EF%BC%8C%E7%9C%8B%E6%9D%A5%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E4%BC%9A%E8%A2%AB%E8%B0%83%E7%94%A8%E5%A4%9A%E6%AC%A1"><strong>   1)</strong>会判断Actors列表是否已经被初始化过了。if( !AreActorsInitialized() )，看来这个方法会被调用多次</h4> 
<h4 id="%C2%A0%20%C2%A02%3E%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E5%80%99%E5%91%A2%EF%BC%8C%E6%9C%89%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%88%99%E5%B0%B1%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%83%A8%E5%88%86%E4%BA%86%E3%80%82%E8%B7%9F%E8%BF%9B%E5%8E%BB%E7%9C%8B%E4%B8%80%E7%9C%8B"><strong>   2)</strong>没有被初始化的时候呢，有下面的代码，下面的则就是真正的初始化部分了。跟进去看一看</h4> 
<pre><code class="language-cpp">// Route various initialization functions and set volumes.
for( int32 LevelIndex=0; LevelIndex&lt;Levels.Num(); LevelIndex++ )
{
	ULevel*	const Level = Levels[LevelIndex];
	Level-&gt;RouteActorInitialize();
}</code></pre> 
<h4 id="%C2%A0%20%C2%A0%203%3E%E5%AF%B9%E6%AF%8F%E4%B8%AAActor%E4%B8%8A%E7%9A%84%E5%85%A8%E9%83%A8%E7%BB%84%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%E4%B8%8A%E5%9B%BE%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B3%A8%E6%84%8F%E6%AD%A4%E6%97%B6Actor%E7%9A%84BeginPlay%E8%BF%98%E6%B2%A1%E6%9C%89%E6%89%A7%E8%A1%8C%E3%80%82%E8%BF%98%E6%B2%A1%E5%88%B0Actor%E7%9A%84BeginPlay%EF%BC%8C%E8%BF%98%E5%9C%A8%E4%B8%8B%E5%A4%B4"><strong>    3)对每个Actor上的全部组件进行初始化。上图，但是注意此时Actor的BeginPlay还没有执行。还没到Actor的BeginPlay，还在下头</strong></h4> 
<p><img alt="" height="904" src="https://images2.imgbox.com/e2/b3/dBdcCXkd_o.png" width="1081"></p> 
<p>AActor::InitializeComponents()-&gt; Actor中的初始化Actor上面的所有组件</p> 
<pre><code class="language-cpp">GetComponents获取到所有的组件 初始化他们
void AActor::InitializeComponents()
{
	QUICK_SCOPE_CYCLE_COUNTER(STAT_Actor_InitializeComponents);

	TInlineComponentArray&lt;UActorComponent*&gt; Components;
	GetComponents(Components);

	for (UActorComponent* ActorComp : Components)
	{
		if (ActorComp-&gt;IsRegistered())
		{
			if (ActorComp-&gt;bAutoActivate &amp;&amp; !ActorComp-&gt;IsActive())
			{
				ActorComp-&gt;Activate(true);
			}

			if (ActorComp-&gt;bWantsInitializeComponent &amp;&amp; !ActorComp-&gt;HasBeenInitialized())
			{
				// Broadcast the activation event since Activate occurs too early to fire a callback in a game
				ActorComp-&gt;InitializeComponent();
			}
		}
	}
}</code></pre> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A04%3EActorBeginPlay%E8%B0%83%E7%94%A8%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%A6%82%E4%B8%8B"><strong>     4)ActorBeginPlay调用的位置</strong>如下</h4> 
<p id="%E7%9C%9F%E6%AD%A3%E5%9C%BA%E6%99%AF%E4%B8%ADActorsBeginPlay%E7%9A%84%E6%B5%81%E7%A8%8B%E5%A6%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%A0%86%E6%A0%88%E5%9B%BE-%3EActorUWorld%E8%B0%83%E7%94%A8BeginPlay%2C%20%E5%86%8D%E5%88%B0WorldSetting%E4%B8%AD%EF%BC%8C%E5%AF%B9%E6%89%80%E6%9C%89%E7%9A%84Actors%E8%BF%9B%E8%A1%8CBeginPlay%E7%9A%84%E8%B0%83%E7%94%A8%E3%80%82%E6%9C%89%E5%85%B4%E8%B6%A3%E7%9A%84BeginPlay%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B9%9F%E5%BB%BA%E8%AE%AE%E7%9C%8B%E7%9C%8B%E3%80%82"><strong>     <span style="color:#3399ea;">真正场景中ActorsBeginPlay的流程如下面的堆栈图-&gt;Actor</span></strong><br><span style="color:#3399ea;"><strong>     UWorld调用BeginPlay, 再到</strong></span><span style="color:#f33b45;"><strong>WorldSetting</strong></span><span style="color:#3399ea;"><strong>中，对所有的Actors进行BeginPlay的调用。有兴趣的BeginPlay里面的代码也建议看看。</strong></span></p> 
<p><img alt="" height="702" src="https://images2.imgbox.com/dc/10/fSYHfu1R_o.png" width="1144"></p> 
<h2 id="%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%8C%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E8%B0%83%E7%94%A8SpawnActor%EF%BC%8C%E5%AF%B9%E5%85%B6%E5%81%9A%E5%88%86%E6%9E%90"><a href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E4%BB%8E%E7%BC%96%E8%BE%91%E5%99%A8%E7%82%B9%E5%87%BBPlay%E5%BC%80%E5%A7%8B%E5%88%86%E6%9E%90World%E9%87%8C%E9%9D%A2%E5%85%A8%E9%83%A8%E7%9A%84Actor%E7%9A%84Spawn%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%88%86%E6%9E%90%E5%88%B0%E8%B0%83%E7%94%A8BeginPlay%E7%BB%93%E6%9D%9F" rel="nofollow">第二部分</a>，从代码层面调用SpawnActor，对其做分析</h2> 
<h3 id="1%3E%E7%BC%96%E7%A0%81%E6%B5%8B%E8%AF%95">1&gt;编码测试</h3> 
<p>我在代码里面写了一个SpawnActor，跟进去看看</p> 
<pre><code class="language-cpp">我写的SpawnActor测试代码
void ABOCPLUSPLUSGameModeBase::BeginPlay()
{
	Super::BeginPlay();

	AActor* pActor = GWorld-&gt;SpawnActor(AActor::StaticClass());
	pActor-&gt;SetActorLocation(FVector::ZeroVector);
}</code></pre> 
<h3 id="2%3E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">2&gt;源码分析</h3> 
<p>下图是调用的堆栈</p> 
<p><img alt="" height="63" src="https://images2.imgbox.com/e6/65/PddicGew_o.png" width="978"></p> 
<p>下面是SpawnActor里面的实现，贴出来吧，代码比较多。我写点注释记录一下</p> 
<h4 id="1)SpawnActor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">1)SpawnActor源码分析</h4> 
<pre><code class="language-cpp">AActor* UWorld::SpawnActor( UClass* Class, FTransform const* UserTransformPtr, const FActorSpawnParameters&amp; SpawnParameters )
{
	SCOPE_CYCLE_COUNTER(STAT_SpawnActorTime);
	CSV_SCOPED_TIMING_STAT_EXCLUSIVE(ActorSpawning);

#if WITH_EDITORONLY_DATA
    判断当前的Level是否有值
	check( CurrentLevel ); 	
    //判断是不是在编辑器内，如果不是check会直接导致崩溃
	check(GIsEditor || (CurrentLevel == PersistentLevel));
#else
	ULevel* CurrentLevel = PersistentLevel;
#endif

	判断描述Actor信息类的Class是否是空的
	if( !Class )
	{
		UE_LOG(LogSpawn, Warning, TEXT("SpawnActor failed because no class was specified") );
		return NULL;
	}

	SCOPE_TIME_GUARD_NAMED_MS(TEXT("SpawnActor Of Type"), Class-&gt;GetFName(), 2);

#if ENABLE_SPAWNACTORTIMER
	FScopedSpawnActorTimer SpawnTimer(Class-&gt;GetFName(), SpawnParameters.bDeferConstruction ? ESpawnActorTimingType::SpawnActorDeferred : ESpawnActorTimingType::SpawnActorNonDeferred);
#endif
    判断Actor是不是被废弃的，废弃的不允许生成
	if( Class-&gt;HasAnyClassFlags(CLASS_Deprecated) )
	{
		UE_LOG(LogSpawn, Warning, TEXT("SpawnActor failed because class %s is deprecated"), *Class-&gt;GetName() );
		return NULL;
	}
    带有抽象反射信息的不允许生生
	if( Class-&gt;HasAnyClassFlags(CLASS_Abstract) )
	{
		UE_LOG(LogSpawn, Warning, TEXT("SpawnActor failed because class %s is abstract"), *Class-&gt;GetName() );
		return NULL;
	}
    必须为AActor类型
	else if( !Class-&gt;IsChildOf(AActor::StaticClass()) )
	{
		UE_LOG(LogSpawn, Warning, TEXT("SpawnActor failed because %s is not an actor class"), *Class-&gt;GetName() );
		return NULL;
	}
    判断类的模板信息是否正确
	else if (SpawnParameters.Template != NULL &amp;&amp; SpawnParameters.Template-&gt;GetClass() != Class)
	{
		UE_LOG(LogSpawn, Warning, TEXT("SpawnActor failed because template class (%s) does not match spawn class (%s)"), *SpawnParameters.Template-&gt;GetClass()-&gt;GetName(), *Class-&gt;GetName());
		if (!SpawnParameters.bNoFail)
		{
			return NULL;
		}
	}
判断类是否允许在构造函数中spawn，默认为false应该是。可以改成true。spawnInfo里头
	else if (bIsRunningConstructionScript &amp;&amp; !SpawnParameters.bAllowDuringConstructionScript)
	{
		UE_LOG(LogSpawn, Warning, TEXT("SpawnActor failed because we are running a ConstructionScript (%s)"), *Class-&gt;GetName() );
		return NULL;
	}
这个UWorld在被销毁过程中，同样也是不允许被Spawn的
	else if (bIsTearingDown)
	{
		UE_LOG(LogSpawn, Warning, TEXT("SpawnActor failed because we are in the process of tearing down the world"));
		return NULL;
	}
判断坐标信息是否是有效的，无效不能spawn
	else if (UserTransformPtr &amp;&amp; UserTransformPtr-&gt;ContainsNaN())
	{
		UE_LOG(LogSpawn, Warning, TEXT("SpawnActor failed because the given transform (%s) is invalid"), *(UserTransformPtr-&gt;ToString()));
		return NULL;
	}

	ULevel* LevelToSpawnIn = SpawnParameters.OverrideLevel;
	if (LevelToSpawnIn == NULL)
	{
		// Spawn in the same level as the owner if we have one. @warning: this relies on the outer of an actor being the level.
		LevelToSpawnIn = (SpawnParameters.Owner != NULL) ? CastChecked&lt;ULevel&gt;(SpawnParameters.Owner-&gt;GetOuter()) : CurrentLevel;
	}

    Actor的名称，就是在世界中叫啥名
	FName NewActorName = SpawnParameters.Name;
	AActor* Template = SpawnParameters.Template;

模板是否有效
	if( !Template )
	{
		// Use class's default actor as a template.
		Template = Class-&gt;GetDefaultObject&lt;AActor&gt;();
	}
	check(Template);

名字是否为空
	if (NewActorName.IsNone())
	{
		// If we are using a template object and haven't specified a name, create a name relative to the template, otherwise let the default object naming behavior in Stat
		if (!Template-&gt;HasAnyFlags(RF_ClassDefaultObject))
		{
			NewActorName = MakeUniqueObjectName(LevelToSpawnIn, Template-&gt;GetClass(), *Template-&gt;GetFName().GetPlainNameString());
		}
	}
	else if (StaticFindObjectFast(nullptr, LevelToSpawnIn, NewActorName))
	{
		// If the supplied name is already in use, then either fail in the requested manner or determine a new name to use if the caller indicates that's ok

		if (SpawnParameters.NameMode == FActorSpawnParameters::ESpawnActorNameMode::Requested)
		{
			NewActorName = MakeUniqueObjectName(LevelToSpawnIn, Template-&gt;GetClass(), *NewActorName.GetPlainNameString());
		}
		else
		{
			if (SpawnParameters.NameMode == FActorSpawnParameters::ESpawnActorNameMode::Required_Fatal)
			{
				UE_LOG(LogSpawn, Fatal, TEXT("An actor of name '%s' already exists in level '%s'."), *NewActorName.ToString(), *LevelToSpawnIn-&gt;GetFullName());
			}
			else if (SpawnParameters.NameMode == FActorSpawnParameters::ESpawnActorNameMode::Required_ErrorAndReturnNull)
			{
				UE_LOG(LogSpawn, Error, TEXT("An actor of name '%s' already exists in level '%s'."), *NewActorName.ToString(), *LevelToSpawnIn-&gt;GetFullName());
			}
			return nullptr;
		}
	}

	// See if we can spawn on ded.server/client only etc (check NeedsLoadForClient &amp; NeedsLoadForServer)
	if(!CanCreateInCurrentContext(Template))
	{
		UE_LOG(LogSpawn, Warning, TEXT("Unable to spawn class '%s' due to client/server context."), *Class-&gt;GetName() );
		return NULL;
	}

根据传入的Spawn参数，比如检测周围如果有碰撞信息了，碰撞重叠之后是否继续spawn？
	FTransform const UserTransform = UserTransformPtr ? *UserTransformPtr : FTransform::Identity;

	ESpawnActorCollisionHandlingMethod CollisionHandlingOverride = SpawnParameters.SpawnCollisionHandlingOverride;

	// "no fail" take preedence over collision handling settings that include fails
	if (SpawnParameters.bNoFail)
	{
		// maybe upgrade to disallow fail
		if (CollisionHandlingOverride == ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDontSpawnIfColliding)
		{
			CollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
		}
		else if (CollisionHandlingOverride == ESpawnActorCollisionHandlingMethod::DontSpawnIfColliding)
		{
			CollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
		}
	}

	// use override if set, else fall back to actor's preference
	ESpawnActorCollisionHandlingMethod const CollisionHandlingMethod = (CollisionHandlingOverride == ESpawnActorCollisionHandlingMethod::Undefined) ? Template-&gt;SpawnCollisionHandlingMethod : CollisionHandlingOverride;

	// see if we can avoid spawning altogether by checking native components
	// note: we can't handle all cases here, since we don't know the full component hierarchy until after the actor is spawned
	if (CollisionHandlingMethod == ESpawnActorCollisionHandlingMethod::DontSpawnIfColliding)
	{
		USceneComponent* const TemplateRootComponent = Template-&gt;GetRootComponent();

		// Note that we respect any initial transformation the root component may have from the CDO, so the final transform
		// might necessarily be exactly the passed-in UserTransform.
		FTransform const FinalRootComponentTransform =
			TemplateRootComponent
			? FTransform(TemplateRootComponent-&gt;GetRelativeRotation(), TemplateRootComponent-&gt;GetRelativeLocation(), TemplateRootComponent-&gt;GetRelativeScale3D()) * UserTransform
			: UserTransform;

		FVector const FinalRootLocation = FinalRootComponentTransform.GetLocation();
		FRotator const FinalRootRotation = FinalRootComponentTransform.Rotator();

		if (EncroachingBlockingGeometry(Template, FinalRootLocation, FinalRootRotation))
		{
			// a native component is colliding, that's enough to reject spawning
			UE_LOG(LogSpawn, Log, TEXT("SpawnActor failed because of collision at the spawn location [%s] for [%s]"), *FinalRootLocation.ToString(), *Class-&gt;GetName());
			return nullptr;
		}
	}

	真正的Spawn在这呢，其实发现很有趣，调用的就是NewObject。但是前期要进行上面那么多的检测
所以我们在对A类生成的时候，一定要调用SpawnActor。不能直接调用NewObject！
	AActor* const Actor = NewObject&lt;AActor&gt;(LevelToSpawnIn, Class, NewActorName, SpawnParameters.ObjectFlags, Template);

判断是否spawn成功了，内存是否申请成功
	check(Actor);

#if ENABLE_SPAWNACTORTIMER
	SpawnTimer.SetActorName(Actor-&gt;GetFName());
#endif

清除actor的名字如果编辑器模式下
#if WITH_EDITOR
	Actor-&gt;ClearActorLabel(); // Clear label on newly spawned actors
#endif // WITH_EDITOR

	if ( GUndo )
	{
		ModifyLevel( LevelToSpawnIn );
	}

在这将生成的actor就加到我们上面Level里面的Actors列表对象里面了。头文件里面是两个TArray
一个列表，一个GC用的
	LevelToSpawnIn-&gt;Actors.Add( Actor );
	LevelToSpawnIn-&gt;ActorsForGC.Add(Actor);

#if PERF_SHOW_MULTI_PAWN_SPAWN_FRAMES
	if( Cast&lt;APawn&gt;(Actor) )
	{
		FString PawnName = FString::Printf(TEXT("%d: %s"), ThisFramePawnSpawns.Num(), *Actor-&gt;GetPathName());
		ThisFramePawnSpawns.Add(PawnName);
	}
#endif

	// 赋值spawn信息
	Actor-&gt;SpawnCollisionHandlingMethod = CollisionHandlingMethod;

#if WITH_EDITOR
	if (SpawnParameters.bHideFromSceneOutliner)
	{
		FSetActorHiddenInSceneOutliner SetActorHidden(Actor);
	}
	Actor-&gt;bIsEditorPreviewActor = SpawnParameters.bTemporaryEditorActor;
#endif //WITH_EDITOR

主要在这里面进行的Actor里面的初始化
	Actor-&gt;PostSpawnInitialize(UserTransform, SpawnParameters.Owner, SpawnParameters.Instigator, SpawnParameters.IsRemoteOwned(), SpawnParameters.bNoFail, SpawnParameters.bDeferConstruction);

	if (Actor-&gt;IsPendingKill() &amp;&amp; !SpawnParameters.bNoFail)
	{
		UE_LOG(LogSpawn, Log, TEXT("SpawnActor failed because the spawned actor %s IsPendingKill"), *Actor-&gt;GetPathName());
		return NULL;
	}

	Actor-&gt;CheckDefaultSubobjects();

	// Broadcast notification of spawn
	OnActorSpawned.Broadcast(Actor);

#if WITH_EDITOR
	if (GIsEditor)
	{
		GEngine-&gt;BroadcastLevelActorAdded(Actor);
	}
#endif

	// Add this newly spawned actor to the network actor list. Do this after PostSpawnInitialize so that actor has "finished" spawning.
	AddNetworkActor( Actor );

	return Actor;
}</code></pre> 
<h4 id="2%EF%BC%89Actor-%3EPostSpawnInitialize%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">2）Actor-&gt;PostSpawnInitialize源码分析</h4> 
<p>先贴出堆栈，比较明了</p> 
<p><img alt="" height="700" src="https://images2.imgbox.com/93/af/rjp4zec2_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-cpp">void AActor::PostSpawnInitialize(FTransform const&amp; UserSpawnTransform, AActor* InOwner, APawn* InInstigator, bool bRemoteOwned, bool bNoFail, bool bDeferConstruction)
{
	
	UWorld* const World = GetWorld();
	bool const bActorsInitialized = World &amp;&amp; World-&gt;AreActorsInitialized();

	CreationTime = (World ? World-&gt;GetTimeSeconds() : 0.f);

	此处判断必须是由服务器创建的
	check(GetLocalRole() == ROLE_Authority);
	ExchangeNetRoles(bRemoteOwned);

设置拥有者
	SetOwner(InOwner);

设置谁导致的这个Actor的生成。这块比较绕。这样想就明白了了
我觉得UE4设置InOwner，InInstigator就是在射击游戏的原型上衍生出来的。
比如人拿枪，人开枪，枪发射子弹。假如子弹就是这个被生成的断点Actor
那么InOwner是谁？是抢，子弹属于枪的
那么InInstigator是谁？是人，人开枪才有了子弹。
当然怎么设置取决于我们
	SetInstigator(InInstigator);

坐标的处理。。。。
	USceneComponent* const SceneRootComponent = FixupNativeActorComponents(this);
	if (SceneRootComponent != nullptr)
	{
		check(SceneRootComponent-&gt;GetOwner() == this);

		// Determine if the native root component's archetype originates from a converted (nativized) Blueprint class.
		UObject* RootComponentArchetype = SceneRootComponent-&gt;GetArchetype();
		UClass* ArchetypeOwnerClass = RootComponentArchetype-&gt;GetOuter()-&gt;GetClass();
		if (UBlueprintGeneratedClass* ArchetypeOwnerClassAsBPGC = Cast&lt;UBlueprintGeneratedClass&gt;(ArchetypeOwnerClass))
		{
			// In this case, the Actor CDO is a non-nativized Blueprint class (e.g. a child class) and the component's archetype
			// is an instanced default subobject within the non-nativized Blueprint's CDO. If the owner class also has a nativized
			// parent class somewhere in its inheritance hierarchy, we must redirect the query by walking up the archetype chain.
			if (ArchetypeOwnerClassAsBPGC-&gt;bHasNativizedParent)
			{
				do 
				{
					RootComponentArchetype = RootComponentArchetype-&gt;GetArchetype();
					ArchetypeOwnerClass = RootComponentArchetype-&gt;GetOuter()-&gt;GetClass();
				} while (Cast&lt;UBlueprintGeneratedClass&gt;(ArchetypeOwnerClass) != nullptr);
			}
		}

		if (Cast&lt;UDynamicClass&gt;(ArchetypeOwnerClass) != nullptr)
		{
			// For native root components either belonging to or inherited from a converted (nativized) Blueprint class, we currently do not use
			// the transformation that's set on the root component in the CDO. The reason is that in the non-nativized case, we ignore the default
			// transform when we instance a Blueprint-owned scene component that will also become the root (see USCS_Node::ExecuteNodeOnActor; in
			// the case of dynamically-spawned Blueprint instances, 'bIsDefaultTransform' will be false, and the scale from the SCS node's template
			// will not be applied in that code path in that case). Once a Blueprint class is nativized, we no longer run through that code path
			// when we spawn new instances of that class dynamically, but for consistency, we need to keep the same transform as in the non-
			// nativized case. We used to ignore any non-default transform value set on the root component at cook (nativization) time, but that 
			// doesn't work because existing placements of the Blueprint component in a scene may rely on the value that's stored in the CDO,
			// and as a result the instance-specific override value doesn't get serialized out to the instance as a result of delta serialization.
			SceneRootComponent-&gt;SetWorldTransform(UserSpawnTransform);
		}
		else
		{
			// In the "normal" case we do respect any non-default transform value that the root component may have received from the archetype
			// that's owned by the native CDO, so the final transform might not always necessarily equate to the passed-in UserSpawnTransform.
			const FTransform RootTransform(SceneRootComponent-&gt;GetRelativeRotation(), SceneRootComponent-&gt;GetRelativeLocation(), SceneRootComponent-&gt;GetRelativeScale3D());
			const FTransform FinalRootComponentTransform = RootTransform * UserSpawnTransform;
			SceneRootComponent-&gt;SetWorldTransform(FinalRootComponentTransform);
		}
	}

	// Call OnComponentCreated on all default (native) components
	DispatchOnComponentsCreated(this);

	// Register the actor's default (native) components, but only if we have a native scene root. If we don't, it implies that there could be only non-scene components
	// at the native class level. In that case, if this is a Blueprint instance, we need to defer native registration until after SCS execution can establish a scene root.
	// Note: This API will also call PostRegisterAllComponents() on the actor instance. If deferred, PostRegisterAllComponents() won't be called until the root is set by SCS.
	bHasDeferredComponentRegistration = (SceneRootComponent == nullptr &amp;&amp; Cast&lt;UBlueprintGeneratedClass&gt;(GetClass()) != nullptr);

注册组件了。第一部分也出现过
	if (!bHasDeferredComponentRegistration)
	{
		RegisterAllComponents();
	}

#if WITH_EDITOR
	// When placing actors in the editor, init any random streams 
	if (!bActorsInitialized)
	{
		SeedAllRandomStreams();
	}
#endif

	看看有没有啥东西把我们给删了？
	if( IsPendingKill() &amp;&amp; !bNoFail )
	{
		return;
	}

	通知一下，我这个Actor已经spawn出来了。
	PostActorCreated();

	执行本地和BP构造脚本。
	if (!bDeferConstruction)
	{
        在这呢在这呢
		FinishSpawning(UserSpawnTransform, true);
	}
	else if (SceneRootComponent != nullptr)
	{
		// we have a native root component and are deferring construction, store our original UserSpawnTransform
		// so we can do the proper thing if the user passes in a different transform during FinishSpawning
		GSpawnActorDeferredTransformCache.Emplace(this, UserSpawnTransform);
	}
}</code></pre> 
<h4 id="3%EF%BC%89void%20AActor%3A%3APostActorConstruction()%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA%E9%87%8C%E9%9D%A2%E4%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96Actor%E4%B8%8B%E9%9D%A2%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%20%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E7%9A%84BeginPlay">3）void AActor::PostActorConstruction()源码分析<br> 这个里面会初始化Actor下面的组件， 主要是下面的代码调用的BeginPlay</h4> 
<pre><code class="language-cpp">if (bRunBeginPlay)
{
	SCOPE_CYCLE_COUNTER(STAT_ActorBeginPlay);
	DispatchBeginPlay();
}</code></pre> 
<pre><code class="language-cpp">void AActor::PostActorConstruction()
{
	UWorld* const World = GetWorld();
	bool const bActorsInitialized = World &amp;&amp; World-&gt;AreActorsInitialized();

	if (bActorsInitialized)
	{
		PreInitializeComponents();
	}

	// If this is dynamically spawned replicated actor, defer calls to BeginPlay and UpdateOverlaps until replicated properties are deserialized
	const bool bDeferBeginPlayAndUpdateOverlaps = (bExchangedRoles &amp;&amp; RemoteRole == ROLE_Authority) &amp;&amp; !GIsReinstancing;

	if (bActorsInitialized)
	{
		这个比较熟悉吧，初始化这个actor下的所有components
		InitializeComponents();

		// actor should have all of its components created and registered now, do any collision checking and handling that we need to do
		if (World)
		{
			switch (SpawnCollisionHandlingMethod)
			{
			case ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn:
			{
				// Try to find a spawn position
				FVector AdjustedLocation = GetActorLocation();
				FRotator AdjustedRotation = GetActorRotation();
				if (World-&gt;FindTeleportSpot(this, AdjustedLocation, AdjustedRotation))
				{
					SetActorLocationAndRotation(AdjustedLocation, AdjustedRotation, false, nullptr, ETeleportType::TeleportPhysics);
				}
			}
			break;
			case ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDontSpawnIfColliding:
			{
				// Try to find a spawn position			
				FVector AdjustedLocation = GetActorLocation();
				FRotator AdjustedRotation = GetActorRotation();
				if (World-&gt;FindTeleportSpot(this, AdjustedLocation, AdjustedRotation))
				{
					SetActorLocationAndRotation(AdjustedLocation, AdjustedRotation, false, nullptr, ETeleportType::TeleportPhysics);
				}
				else
				{
					UE_LOG(LogSpawn, Warning, TEXT("SpawnActor failed because of collision at the spawn location [%s] for [%s]"), *AdjustedLocation.ToString(), *GetClass()-&gt;GetName());
					Destroy();
				}
			}
			break;
			case ESpawnActorCollisionHandlingMethod::DontSpawnIfColliding:
				if (World-&gt;EncroachingBlockingGeometry(this, GetActorLocation(), GetActorRotation()))
				{
					UE_LOG(LogSpawn, Warning, TEXT("SpawnActor failed because of collision at the spawn location [%s] for [%s]"), *GetActorLocation().ToString(), *GetClass()-&gt;GetName());
					Destroy();
				}
				break;
			case ESpawnActorCollisionHandlingMethod::Undefined:
			case ESpawnActorCollisionHandlingMethod::AlwaysSpawn:
			default:
				// note we use "always spawn" as default, so treat undefined as that
				// nothing to do here, just proceed as normal
				break;
			}
		}

		if (!IsPendingKill())
		{
			PostInitializeComponents();
			if (!IsPendingKill())
			{
				if (!bActorInitialized)
				{
					UE_LOG(LogActor, Fatal, TEXT("%s failed to route PostInitializeComponents.  Please call Super::PostInitializeComponents() in your &lt;className&gt;::PostInitializeComponents() function. "), *GetFullName());
				}

				bool bRunBeginPlay = !bDeferBeginPlayAndUpdateOverlaps &amp;&amp; (BeginPlayCallDepth &gt; 0 || World-&gt;HasBegunPlay());
				if (bRunBeginPlay)
				{
					if (AActor* ParentActor = GetParentActor())
					{
						// Child Actors cannot run begin play until their parent has run
						bRunBeginPlay = (ParentActor-&gt;HasActorBegunPlay() || ParentActor-&gt;IsActorBeginningPlay());
					}
				}

#if WITH_EDITOR
				if (bRunBeginPlay &amp;&amp; bIsEditorPreviewActor)
				{
					bRunBeginPlay = false;
				}
#endif

重头戏在这呢，通知调用beginplay
				if (bRunBeginPlay)
				{
					SCOPE_CYCLE_COUNTER(STAT_ActorBeginPlay);
					DispatchBeginPlay();
				}
			}
		}
	}
	else
	{
		// Set IsPendingKill() to true so that when the initial undo record is made,
		// the actor will be treated as destroyed, in that undo an add will
		// actually work
		MarkPendingKill();
		Modify(false);
		ClearPendingKill();
	}
}</code></pre> 
<h4 id="4%EF%BC%89void%20AActor%3A%3ADispatchBeginPlay(bool%20bFromLevelStreaming)%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">4）void AActor::DispatchBeginPlay(bool bFromLevelStreaming)源码分析</h4> 
<p>到这一步其实就到了Beginplay真正的调用位置了</p> 
<pre><code class="language-cpp">void AActor::DispatchBeginPlay(bool bFromLevelStreaming)
{
	UWorld* World = (!HasActorBegunPlay() &amp;&amp; !IsPendingKill() ? GetWorld() : nullptr);

	if (World)
	{
		ensureMsgf(ActorHasBegunPlay == EActorBeginPlayState::HasNotBegunPlay, TEXT("BeginPlay was called on actor %s which was in state %d"), *GetPathName(), (int32)ActorHasBegunPlay);
		const uint32 CurrentCallDepth = BeginPlayCallDepth++;

		bActorBeginningPlayFromLevelStreaming = bFromLevelStreaming;
		ActorHasBegunPlay = EActorBeginPlayState::BeginningPlay;

||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
在这里调用的BeginPlay在这里调用的BeginPlay在这里调用的BeginPlay在这里调用的BeginPlay
		BeginPlay();
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

		ensure(BeginPlayCallDepth - 1 == CurrentCallDepth);
		BeginPlayCallDepth = CurrentCallDepth;

		if (bActorWantsDestroyDuringBeginPlay)
		{
			// Pass true for bNetForce as either it doesn't matter or it was true the first time to even 
			// get to the point we set bActorWantsDestroyDuringBeginPlay to true
			World-&gt;DestroyActor(this, true); 
		}
		
		if (!IsPendingKill())
		{
			// Initialize overlap state
			UpdateInitialOverlaps(bFromLevelStreaming);
		}

		bActorBeginningPlayFromLevelStreaming = false;
	}
}</code></pre> 
<h2 id="%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%8C%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E8%B0%83%E7%94%A8DestroyActor%EF%BC%8C%E5%AF%B9%E5%85%B6%E5%81%9A%E5%88%86%E6%9E%90">第三部分，从代码层面调用DestroyActor，对其做分析</h2> 
<h3>1&gt;编码测试</h3> 
<pre><code class="language-cpp">AActor* pActor = GWorld-&gt;SpawnActor(AActor::StaticClass());
	if (pActor)
	{
		pActor-&gt;SetActorLocation(FVector::ZeroVector);

代码中删除Actor的方式
		//GWorld-&gt;DestroyActor(pActor);
		pActor-&gt;Destroy();
	}
}</code></pre> 
<h3>2&gt;源码分析</h3> 
<pre><code class="language-cpp">bool UWorld::DestroyActor( AActor* ThisActor, bool bNetForce, bool bShouldModifyLevel )
{
	SCOPE_CYCLE_COUNTER(STAT_DestroyActor);
	CSV_SCOPED_TIMING_STAT_EXCLUSIVE(ActorDestroying);

判断Actor是否是有效的
	check(ThisActor);
	check(ThisActor-&gt;IsValidLowLevel());
	//UE_LOG(LogSpawn, Log,  "Destroy %s", *ThisActor-&gt;GetClass()-&gt;GetName() );

	SCOPE_CYCLE_UOBJECT(ThisActor, ThisActor);

	if (ThisActor-&gt;GetWorld() == NULL)
	{
		UE_LOG(LogSpawn, Warning, TEXT("Destroying %s, which doesn't have a valid world pointer"), *ThisActor-&gt;GetPathName());
	}

	如果已经在要删除的列表中，不往下处理
    if (ThisActor-&gt;IsPendingKillPending())
	{
		return true;
	}

	WorldSetting这个Actor是不允许被销毁的，请记住这一点
	// seamless travel and network games.
	if (GetWorldSettings() == ThisActor)
	{
		return false;
	}

	// In-game deletion rules.
	if( IsGameWorld() )
	{

		const bool bIsNetworkedActor = ThisActor-&gt;GetLocalRole() != ROLE_None;

		删除Actor是不允许从客户端进行删除的
		const bool bCanDestroyNetworkActor = ThisActor-&gt;GetLocalRole() == ROLE_Authority || bNetForce || ThisActor-&gt;bNetTemporary;
		if (bIsNetworkedActor &amp;&amp; !bCanDestroyNetworkActor)
		{
			return false;
		}

		const bool bCanDestroyNonNetworkActor = !!CVarAllowDestroyNonNetworkActors.GetValueOnAnyThread();
		if (!bIsNetworkedActor &amp;&amp; !bCanDestroyNonNetworkActor)
		{
			return false;
		}

		if (ThisActor-&gt;DestroyNetworkActorHandled())
		{
			// Network actor short circuited the destroy (network will cleanup properly)
			// Don't destroy PlayerControllers and BeaconClients
			return false;
		}

如果正在执行BeginPlay呢，那么在后续Begin完成之后再对其进行删除
		if (ThisActor-&gt;IsActorBeginningPlay())
		{
			FSetActorWantsDestroyDuringBeginPlay SetActorWantsDestroyDuringBeginPlay(ThisActor);
			return true;
		}
	}
	else
	{
		ThisActor-&gt;Modify();
	}

	// Prevent recursion
	FMarkActorIsBeingDestroyed MarkActorIsBeingDestroyed(ThisActor);

通知纹理流管理器这个Actor被删除了
	IStreamingManager::Get().NotifyActorDestroyed( ThisActor );

	这个里面会有很多的代码，在这里面进行删除
	ThisActor-&gt;Destroyed();

	将所有附加到这个Actor上面的Actor脱离
	TArray&lt;AActor*&gt; AttachedActors;
	ThisActor-&gt;GetAttachedActors(AttachedActors);

	if (AttachedActors.Num() &gt; 0)
	{
		TInlineComponentArray&lt;USceneComponent*&gt; SceneComponents;
		ThisActor-&gt;GetComponents(SceneComponents);

		for (TArray&lt; AActor* &gt;::TConstIterator AttachedActorIt(AttachedActors); AttachedActorIt; ++AttachedActorIt)
		{
			AActor* ChildActor = *AttachedActorIt;
			if (ChildActor != NULL)
			{
				for (USceneComponent* SceneComponent : SceneComponents)
				{
					ChildActor-&gt;DetachAllSceneComponents(SceneComponent, FDetachmentTransformRules::KeepWorldTransform);
				}
#if WITH_EDITOR
				if( GIsEditor )
				{
					GEngine-&gt;BroadcastLevelActorDetached(ChildActor, ThisActor);
				}
#endif
			}
		}
	}

	判断我们这个actor是否是attach到其他的actor下面了
	USceneComponent* RootComp = ThisActor-&gt;GetRootComponent();
	if( RootComp != nullptr &amp;&amp; RootComp-&gt;GetAttachParent() != nullptr)
	{
		AActor* OldParentActor = RootComp-&gt;GetAttachParent()-&gt;GetOwner();
		if (OldParentActor)
		{
			OldParentActor-&gt;Modify();
		}

从父节点上脱离
		ThisActor-&gt;DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);

#if WITH_EDITOR
		if( GIsEditor )
		{
			GEngine-&gt;BroadcastLevelActorDetached(ThisActor, OldParentActor);
		}
#endif
	}

	ThisActor-&gt;ClearComponentOverlaps();

	通知设置owner为空
	if( ThisActor-&gt;GetOwner() )
	{
		ThisActor-&gt;SetOwner(NULL);
	}

	ULevel* const ActorLevel = ThisActor-&gt;GetLevel();
	if (ActorLevel)
	{
		ActorLevel-&gt;CreateReplicatedDestructionInfo(ThisActor);
	}

	// Notify net drivers that this guy has been destroyed.
	if (FWorldContext* Context = GEngine-&gt;GetWorldContextFromWorld(this))
	{
		for (FNamedNetDriver&amp; Driver : Context-&gt;ActiveNetDrivers)
		{
			if (Driver.NetDriver != nullptr &amp;&amp; Driver.NetDriver-&gt;ShouldReplicateActor(ThisActor))
			{
				Driver.NetDriver-&gt;NotifyActorDestroyed(ThisActor);
			}
		}
	}
	else if (WorldType != EWorldType::Inactive &amp;&amp; !IsRunningCommandlet())
	{
		// Inactive worlds do not have a world context, otherwise only worlds in the middle of seamless travel should have no context,
		// and in that case, we shouldn't be destroying actors on them until they have become the current world (i.e. CopyWorldData has been called)
		UE_LOG(LogSpawn, Warning, TEXT("UWorld::DestroyActor: World has no context! World: %s, Actor: %s"), *GetName(), *ThisActor-&gt;GetPathName());
	}

	// Remove the actor from the actor list.
	RemoveActor( ThisActor, bShouldModifyLevel );

	// Invalidate the lighting cache in the Editor.  We need to check for GIsEditor as play has not begun in network game and objects get destroyed on switching levels
	if ( GIsEditor )
	{
		if (!IsGameWorld())
		{
			ThisActor-&gt;InvalidateLightingCache();
		}
		
#if WITH_EDITOR
		GEngine-&gt;BroadcastLevelActorDeleted(ThisActor);
#endif
	}
		
	清空这个actor上面的所有组件
	ThisActor-&gt;UnregisterAllComponents();

	将这个Actor和Actor上的所有组件标记为将要删除
	ThisActor-&gt;MarkPendingKill();
	ThisActor-&gt;MarkPackageDirty();
	ThisActor-&gt;MarkComponentsAsPendingKill();

	取消注册actor的tick函数
	const bool bRegisterTickFunctions = false;
	const bool bIncludeComponents = true;
	ThisActor-&gt;RegisterAllActorTickFunctions(bRegisterTickFunctions, bIncludeComponents);

	// Return success.
	return true;
}</code></pre> 
<h4 id="2)%20void%20AActor%3A%3ADestroyed()%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">1) void AActor::Destroyed()源码分析</h4> 
<pre><code class="language-cpp">void AActor::Destroyed()
{
	RouteEndPlay(EEndPlayReason::Destroyed);

告诉蓝图Destroyed了，这个就是蓝图中可覆盖的那个方法
	ReceiveDestroyed();
广播一下，其他地方可监听
	OnDestroyed.Broadcast(this);
}

</code></pre> 
<h4 id="3)%20RouteEndPlay(EEndPlayReason%3A%3ADestroyed)%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">2) RouteEndPlay(EEndPlayReason::Destroyed)源码分析</h4> 
<pre><code class="language-cpp">void AActor::RouteEndPlay(const EEndPlayReason::Type EndPlayReason)
{
	if (bActorInitialized)
	{
		if (ActorHasBegunPlay == EActorBeginPlayState::HasBegunPlay)
		{
调用EndPlay，并且也会通知Actor下面的所有组件也去EndPlay

			EndPlay(EndPlayReason);
		}

		// Behaviors specific to an actor being unloaded due to a streaming level removal
		if (EndPlayReason == EEndPlayReason::RemovedFromWorld)
		{
			ClearComponentOverlaps();

			bActorInitialized = false;
			if (UWorld* World = GetWorld())
			{
				World-&gt;RemoveNetworkActor(this);
			}
		}

		// Clear any ticking lifespan timers
		if (TimerHandle_LifeSpanExpired.IsValid())
		{
			SetLifeSpan(0.f);
		}
	}

	UninitializeComponents();
}</code></pre> 
<p></p> 
<p>文章到此结束。谢谢，有问题请指正。</p> 
<p><em><u><span style="color:#e579b6;">创作不易，大侠请留步… 动起可爱的双手，来个赞再走呗 &lt;(￣︶￣)&gt;</span></u></em></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/762231d77e333351e157dc7ac3637864/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">UE4随笔 Landscape动态Attach之后没有碰撞怎么解决？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/108c47fb1dfa4c914e834b8cc076ea94/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于获取设备的唯一设备ID，MAC地址 IOS/Android问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>