<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux——进程信号 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux——进程信号" />
<meta property="og:description" content="目录
0. 前言
1. 信号入门
1.1 生活角度的信号
1.2 技术应用角度的信号
1.3 注意信号
1.4 信号概念
1.5 用kill -l命令可以察看系统定义的信号列表
1.6 信号处理常见方式概览
2. 信号产生
2.1 通过终端按键产生信号
2.2 Core Dump核心转储
2.3 调用系统函数向进程发信号kill、raise
2.4 由软件条件产生信号alarm
2.5 硬件异常产生信号
2.6 wait\waitpid子进程状态码是否发生核心转储（进程控制补充core信号）
3. 捕捉信号初识
3.1 捕捉信号系统调用接口signal
3.2 定时器闹钟功能
3.3 模拟野指针异常（硬件异常）
3.4 总结
4. 深入内核及阻塞信号
4.1 信号其他相关常见概念
4.2 在内核中的表示
4.3 sigset_t
4.4 信号集操作函数
4.4.1 sigset_t 操作函数
4.4.2 sigprocmask
4.4.3 sigpending
4.5 操作案例分析
4.5.1 自定义捕捉所有信号？
4.5.2 观察block信号的pending信号集
4.5.3 阻塞所有信号？
5. 捕捉信号" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/9303fbfe5d51db27f245b407ad3dce6b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-17T11:58:10+08:00" />
<meta property="article:modified_time" content="2023-09-17T11:58:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux——进程信号</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="373" src="https://images2.imgbox.com/f1/6d/3Yxncwoi_o.png" width="657"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="0.%20%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#0.%20%E5%89%8D%E8%A8%80" rel="nofollow">0. 前言</a></p> 
<p id="1.%20%E4%BF%A1%E5%8F%B7%E5%85%A5%E9%97%A8-toc" style="margin-left:0px;"><a href="#1.%20%E4%BF%A1%E5%8F%B7%E5%85%A5%E9%97%A8" rel="nofollow">1. 信号入门</a></p> 
<p id="1.1%20%E7%94%9F%E6%B4%BB%E8%A7%92%E5%BA%A6%E7%9A%84%E4%BF%A1%E5%8F%B7-toc" style="margin-left:40px;"><a href="#1.1%20%E7%94%9F%E6%B4%BB%E8%A7%92%E5%BA%A6%E7%9A%84%E4%BF%A1%E5%8F%B7" rel="nofollow">1.1 生活角度的信号</a></p> 
<p id="1.2%20%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%E8%A7%92%E5%BA%A6%E7%9A%84%E4%BF%A1%E5%8F%B7-toc" style="margin-left:40px;"><a href="#1.2%20%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%E8%A7%92%E5%BA%A6%E7%9A%84%E4%BF%A1%E5%8F%B7" rel="nofollow">1.2 技术应用角度的信号</a></p> 
<p id="1.3%C2%A0%E6%B3%A8%E6%84%8F%E4%BF%A1%E5%8F%B7-toc" style="margin-left:40px;"><a href="#1.3%C2%A0%E6%B3%A8%E6%84%8F%E4%BF%A1%E5%8F%B7" rel="nofollow">1.3 注意信号</a></p> 
<p id="1.4%C2%A0%E4%BF%A1%E5%8F%B7%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.4%C2%A0%E4%BF%A1%E5%8F%B7%E6%A6%82%E5%BF%B5" rel="nofollow">1.4 信号概念</a></p> 
<p id="1.5%C2%A0%E7%94%A8kill%20-l%E5%91%BD%E4%BB%A4%E5%8F%AF%E4%BB%A5%E5%AF%9F%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%88%97%E8%A1%A8-toc" style="margin-left:40px;"><a href="#1.5%C2%A0%E7%94%A8kill%20-l%E5%91%BD%E4%BB%A4%E5%8F%AF%E4%BB%A5%E5%AF%9F%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%88%97%E8%A1%A8" rel="nofollow">1.5 用kill -l命令可以察看系统定义的信号列表</a></p> 
<p id="1.6%C2%A0%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F%E6%A6%82%E8%A7%88-toc" style="margin-left:40px;"><a href="#1.6%C2%A0%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F%E6%A6%82%E8%A7%88" rel="nofollow">1.6 信号处理常见方式概览</a></p> 
<p id="2.%20%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F-toc" style="margin-left:0px;"><a href="#2.%20%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F" rel="nofollow">2. 信号产生</a></p> 
<p id="2.1%C2%A0%E9%80%9A%E8%BF%87%E7%BB%88%E7%AB%AF%E6%8C%89%E9%94%AE%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7-toc" style="margin-left:40px;"><a href="#2.1%C2%A0%E9%80%9A%E8%BF%87%E7%BB%88%E7%AB%AF%E6%8C%89%E9%94%AE%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7" rel="nofollow">2.1 通过终端按键产生信号</a></p> 
<p id="2.2%C2%A0Core%20Dump%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8-toc" style="margin-left:40px;"><a href="#2.2%C2%A0Core%20Dump%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8" rel="nofollow">2.2 Core Dump核心转储</a></p> 
<p id="2.3%C2%A0%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E5%90%91%E8%BF%9B%E7%A8%8B%E5%8F%91%E4%BF%A1%E5%8F%B7kill%E3%80%81raise-toc" style="margin-left:40px;"><a href="#2.3%C2%A0%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E5%90%91%E8%BF%9B%E7%A8%8B%E5%8F%91%E4%BF%A1%E5%8F%B7kill%E3%80%81raise" rel="nofollow">2.3 调用系统函数向进程发信号kill、raise</a></p> 
<p id="2.4%C2%A0%E7%94%B1%E8%BD%AF%E4%BB%B6%E6%9D%A1%E4%BB%B6%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7alarm-toc" style="margin-left:40px;"><a href="#2.4%C2%A0%E7%94%B1%E8%BD%AF%E4%BB%B6%E6%9D%A1%E4%BB%B6%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7alarm" rel="nofollow">2.4 由软件条件产生信号alarm</a></p> 
<p id="2.5%C2%A0%E7%A1%AC%E4%BB%B6%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7-toc" style="margin-left:40px;"><a href="#2.5%C2%A0%E7%A1%AC%E4%BB%B6%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7" rel="nofollow">2.5 硬件异常产生信号</a></p> 
<p id="2.6%20wait%5Cwaitpid%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%A0%81%E6%98%AF%E5%90%A6%E5%8F%91%E7%94%9F%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8%EF%BC%88%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%A1%A5%E5%85%85core%E4%BF%A1%E5%8F%B7%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.6%20wait%5Cwaitpid%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%A0%81%E6%98%AF%E5%90%A6%E5%8F%91%E7%94%9F%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8%EF%BC%88%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%A1%A5%E5%85%85core%E4%BF%A1%E5%8F%B7%EF%BC%89" rel="nofollow">2.6 wait\waitpid子进程状态码是否发生核心转储（进程控制补充core信号）</a></p> 
<p id="3.%20%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7%E5%88%9D%E8%AF%86-toc" style="margin-left:0px;"><a href="#3.%20%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7%E5%88%9D%E8%AF%86" rel="nofollow">3. 捕捉信号初识</a></p> 
<p id="3.1%20%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3signal-toc" style="margin-left:40px;"><a href="#3.1%20%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3signal" rel="nofollow">3.1 捕捉信号系统调用接口signal</a></p> 
<p id="3.2%20%E5%AE%9A%E6%97%B6%E5%99%A8%E9%97%B9%E9%92%9F%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#3.2%20%E5%AE%9A%E6%97%B6%E5%99%A8%E9%97%B9%E9%92%9F%E5%8A%9F%E8%83%BD" rel="nofollow">3.2 定时器闹钟功能</a></p> 
<p id="3.3%C2%A0%E6%A8%A1%E6%8B%9F%E9%87%8E%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%EF%BC%88%E7%A1%AC%E4%BB%B6%E5%BC%82%E5%B8%B8%EF%BC%89-toc" style="margin-left:40px;"><a href="#3.3%C2%A0%E6%A8%A1%E6%8B%9F%E9%87%8E%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%EF%BC%88%E7%A1%AC%E4%BB%B6%E5%BC%82%E5%B8%B8%EF%BC%89" rel="nofollow">3.3 模拟野指针异常（硬件异常）</a></p> 
<p id="3.4%20%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#3.4%20%E6%80%BB%E7%BB%93" rel="nofollow">3.4 总结</a></p> 
<p id="4.%20%E6%B7%B1%E5%85%A5%E5%86%85%E6%A0%B8%E5%8F%8A%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7-toc" style="margin-left:0px;"><a href="#4.%20%E6%B7%B1%E5%85%A5%E5%86%85%E6%A0%B8%E5%8F%8A%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7" rel="nofollow">4. 深入内核及阻塞信号</a></p> 
<p id="4.1%20%E4%BF%A1%E5%8F%B7%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#4.1%20%E4%BF%A1%E5%8F%B7%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5" rel="nofollow">4.1 信号其他相关常见概念</a></p> 
<p id="4.2%C2%A0%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA-toc" style="margin-left:40px;"><a href="#4.2%C2%A0%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA" rel="nofollow">4.2 在内核中的表示</a></p> 
<p id="4.3%C2%A0sigset_t-toc" style="margin-left:40px;"><a href="#4.3%C2%A0sigset_t" rel="nofollow">4.3 sigset_t</a></p> 
<p id="4.4%20%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.4%20%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0" rel="nofollow">4.4 信号集操作函数</a></p> 
<p id="4.4.1%20sigset_t%20%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.4.1%20sigset_t%20%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0" rel="nofollow">4.4.1 sigset_t 操作函数</a></p> 
<p id="4.4.2%C2%A0sigprocmask-toc" style="margin-left:80px;"><a href="#4.4.2%C2%A0sigprocmask" rel="nofollow">4.4.2 sigprocmask</a></p> 
<p id="4.4.3%C2%A0sigpending-toc" style="margin-left:80px;"><a href="#4.4.3%C2%A0sigpending" rel="nofollow">4.4.3 sigpending</a></p> 
<p id="4.5%20%E6%93%8D%E4%BD%9C%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#4.5%20%E6%93%8D%E4%BD%9C%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90" rel="nofollow">4.5 操作案例分析</a></p> 
<p id="4.5.1%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8D%95%E6%8D%89%E6%89%80%E6%9C%89%E4%BF%A1%E5%8F%B7%EF%BC%9F-toc" style="margin-left:80px;"><a href="#4.5.1%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8D%95%E6%8D%89%E6%89%80%E6%9C%89%E4%BF%A1%E5%8F%B7%EF%BC%9F" rel="nofollow">4.5.1 自定义捕捉所有信号？</a></p> 
<p id="4.5.2%20%E8%A7%82%E5%AF%9Fblock%E4%BF%A1%E5%8F%B7%E7%9A%84pending%E4%BF%A1%E5%8F%B7%E9%9B%86-toc" style="margin-left:80px;"><a href="#4.5.2%20%E8%A7%82%E5%AF%9Fblock%E4%BF%A1%E5%8F%B7%E7%9A%84pending%E4%BF%A1%E5%8F%B7%E9%9B%86" rel="nofollow">4.5.2 观察block信号的pending信号集</a></p> 
<p id="4.5.3%C2%A0%E9%98%BB%E5%A1%9E%E6%89%80%E6%9C%89%E4%BF%A1%E5%8F%B7%EF%BC%9F-toc" style="margin-left:80px;"><a href="#4.5.3%C2%A0%E9%98%BB%E5%A1%9E%E6%89%80%E6%9C%89%E4%BF%A1%E5%8F%B7%EF%BC%9F" rel="nofollow">4.5.3 阻塞所有信号？</a></p> 
<p id="5.%20%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7-toc" style="margin-left:0px;"><a href="#5.%20%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7" rel="nofollow">5. 捕捉信号</a></p> 
<p id="5.1%C2%A0%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%8D%95%E6%8D%89-toc" style="margin-left:40px;"><a href="#5.1%C2%A0%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%8D%95%E6%8D%89" rel="nofollow">5.1 内核如何实现信号的捕捉</a></p> 
<p id="5.2%C2%A0sigaction-toc" style="margin-left:40px;"><a href="#5.2%C2%A0sigaction" rel="nofollow">5.2 sigaction</a></p> 
<p id="5.2.1%20struct%20sigaction%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:80px;"><a href="#5.2.1%20struct%20sigaction%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">5.2.1 struct sigaction内核结构体</a></p> 
<p id="5.2.2%20sa_handler-toc" style="margin-left:80px;"><a href="#5.2.2%20sa_handler" rel="nofollow">5.2.2 sa_handler</a></p> 
<p id="5.2.3%20sa_mask-toc" style="margin-left:80px;"><a href="#5.2.3%20sa_mask" rel="nofollow">5.2.3 sa_mask</a></p> 
<p id="5.2.4%20%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7%E8%BF%87%E7%A8%8B%E5%86%8D%E6%AC%A1%E6%8E%A5%E6%94%B6-toc" style="margin-left:80px;"><a href="#5.2.4%20%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7%E8%BF%87%E7%A8%8B%E5%86%8D%E6%AC%A1%E6%8E%A5%E6%94%B6" rel="nofollow">5.2.4 处理信号过程再次接收</a></p> 
<p id="5.3%20%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#5.3%20%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0" rel="nofollow">5.3 可重入函数</a></p> 
<p id="5.4%C2%A0volatile-toc" style="margin-left:40px;"><a href="#5.4%C2%A0volatile" rel="nofollow">5.4 volatile</a></p> 
<p id="6.%C2%A0SIGCHLD%E4%BF%A1%E5%8F%B7%20-%20%E9%80%89%E5%AD%A6%E4%BA%86%E8%A7%A3-toc" style="margin-left:0px;"><a href="#6.%C2%A0SIGCHLD%E4%BF%A1%E5%8F%B7%20-%20%E9%80%89%E5%AD%A6%E4%BA%86%E8%A7%A3" rel="nofollow">6. SIGCHLD信号 - 选学了解</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="0.%20%E5%89%8D%E8%A8%80">0. 前言</h2> 
<blockquote> 
 <p>信号量和信号并无关联，是两个完全不同的性质！</p> 
 <p>1. 掌握Linux信号的基本概念</p> 
 <p>2. 掌握信号产生的一般方式</p> 
 <p>3. 理解信号递达和阻塞的概念，原理。</p> 
 <p>4. 掌握信号捕捉的一般方式。</p> 
 <p>5. 重新了解可重入函数的概念。</p> 
 <p>6. 了解竞态条件的情景和处理方式</p> 
 <p>7. 了解SIGCHLD信号， 重新编写信号处理函数的一般处理机制</p> 
</blockquote> 
<h2 id="1.%20%E4%BF%A1%E5%8F%B7%E5%85%A5%E9%97%A8">1. 信号入门</h2> 
<h3 id="1.1%20%E7%94%9F%E6%B4%BB%E8%A7%92%E5%BA%A6%E7%9A%84%E4%BF%A1%E5%8F%B7">1.1 生活角度的信号</h3> 
<blockquote> 
 <ul><li>你在网上买了很多件商品，再等待不同商品快递的到来。但即便快递没有到来，你也知道快递来临时， 你该怎么处理快递。也就是你能“识别快递”</li><li>当快递员到了你楼下，你也收到快递到来的通知，但是你正在打游戏，需5min之后才能去取快递。那么在在这5min之内，你并没有下去去取快递，但是你是知道有快递到来了。也就是取快递的行为并不是一定要立即执行，可以理解成“在合适的时候去取”。</li><li>在收到通知，再到你拿到快递期间，是有一个时间窗口的，在这段时间，你并没有拿到快递，但是你知道有一个快递已经来了。本质上是你“记住了有一个快递要去取” 当你时间合适，顺利拿到快递之后，就要开始处理快递了。</li><li>而处理快递一般方式有三种：1. 执行默认动 作（幸福的打开快递，使用商品）2. 执行自定义动作（快递是零食，你要送给你你的女朋友）3. 忽略快递（快递拿上来之后，扔掉床头，继续开一把游戏）</li><li>快递到来的整个过程，对你来讲是异步的，你不能准确断定快递员什么时候给你打电话</li></ul> 
</blockquote> 
<h3 id="1.2%20%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%E8%A7%92%E5%BA%A6%E7%9A%84%E4%BF%A1%E5%8F%B7">1.2 技术应用角度的信号</h3> 
<blockquote> 
 <p>1. 用户输入命令,在Shell下启动一个前台进程。</p> 
 <p>        用户按下Ctrl-C ,这个键盘输入产生一个硬件中断，被OS获取，解释成信号，发送给目标前台进程 . 前台进程因为收到信号，进而引起进程退出</p> 
 <pre><code>[@localhost code_test]$ cat sig.c 
#include &lt;stdio.h&gt;
int main()
{
 while(1){
 printf("I am a process, I am waiting signal!\n");
 sleep(1);
 }
}
[@localhost code_test]$ ./sig 
I am a process, I am waiting signal!
I am a process, I am waiting signal!
I am a process, I am waiting signal!
^C
[@localhost code_test]$</code></pre> 
 <p>请将生活例子和 Ctrl-C 信号处理过程相结合，解释一下信号处理过程</p> 
 <p>进程就是你，操作系统就是快递员，信号就是快递</p> 
</blockquote> 
<h3 id="1.3%C2%A0%E6%B3%A8%E6%84%8F%E4%BF%A1%E5%8F%B7">1.3 注意信号</h3> 
<blockquote> 
 <ol><li>Ctrl-C 产生的信号只能发给前台进程。一个命令后面加个&amp;可以放到后台运行,这样Shell不必等待进程结束就可以接受新的命令,启动新的进程。</li><li>Shell可以同时运行一个前台进程和任意多个后台进程,只有前台进程才能接到像 Ctrl-C 这种控制键产生的信号。</li><li>前台进程在运行过程中用户随时可能按下 Ctrl-C 而产生一个信号,也就是说该进程的用户空间代码执行到任何地方都有可能收到 SIGINT 信号而终止,所以信号相对于进程的控制流程来说是异步 (Asynchronous)的。</li></ol> 
</blockquote> 
<h3 id="1.4%C2%A0%E4%BF%A1%E5%8F%B7%E6%A6%82%E5%BF%B5">1.4 信号概念</h3> 
<blockquote> 
 <p><strong>信号是进程之间事件异步通知的一种方式，属于软中断。</strong></p> 
 <p></p> 
 <ul><li>用户 or 操作系统通过发送一定的信号，通知进程，某些事件已经发生，你可以在后续进行处理！</li><li>进程要处理信号，且异步，因此再发送信号时，信号需要先被保存，其次进程需要具有识别信号的能力</li><li>凭什么进程能够“识别”信号？程序员一定在编写进程相关代码实现时，内部内置了识别、处理信号的相关内容</li><li>信号的产生的随机的，进程可能正在忙自己的事情，所以，信号的处理，不是立即处理的，而是临时记录对应的信号，方便后续处理 </li></ul> 
</blockquote> 
<h3 id="1.5%C2%A0%E7%94%A8kill%20-l%E5%91%BD%E4%BB%A4%E5%8F%AF%E4%BB%A5%E5%AF%9F%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%88%97%E8%A1%A8">1.5 用kill -l命令可以察看系统定义的信号列表</h3> 
<blockquote> 
 <p>每个信号都有一个编号和一个宏定义名称,这些宏定义可以在signal.h中找到</p> 
 <p>      </p> 
 <p class="img-center"><img alt="" height="241" src="https://images2.imgbox.com/0d/0e/QFq7WBne_o.png" width="618"></p> 
 <p>        例如其中有定义 #define SIGINT 2 编号34以上的是实时信号,本章只讨论编号34以下的信号,不讨论实时信号。这些信号各自在什么条件下产生,默认的处理动作是什么,在signal(7)中都有详细说明: man 7 signal</p> 
 <p class="img-center"><img alt="" height="442" src="https://images2.imgbox.com/29/30/nJ32QUfj_o.png" width="636"></p> 
</blockquote> 
<h3 id="1.6%C2%A0%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F%E6%A6%82%E8%A7%88">1.6 信号处理常见方式概览</h3> 
<blockquote> 
 <p>(sigaction函数稍后详细介绍),可选的处理动作有以下三种:</p> 
 <ol><li>忽略此信号。</li><li>执行该信号的默认处理动作。</li><li>提供一个信号处理函数,要求内核在处理该信号时切换到用户态执行这个处理函数,这种方式称为捕捉 (Catch)一个信号。</li></ol> 
</blockquote> 
<h2 id="2.%20%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F">2. 信号产生</h2> 
<blockquote> 
 <p>如何理解组合键变成信号？</p> 
 <p><strong>键盘的工作方式是通过中断方式进行的，因此能识别组合键</strong></p> 
 <p></p> 
 <p>如何理解信号被进程保存？</p> 
 <p><strong>信号异步处理，因此进程PCB内部必须要具有保存信号的相关数据结构（位图字段）</strong></p> 
 <p></p> 
 <p><strong>信号位图是在进程task_struct -&gt; 而</strong><strong>task_struct是内核数据结构 -&gt; 发送信号本质是由OS发送</strong></p> 
 <p><strong>信号发送的本质：OS向目标进程对应的task_struct中，修改对应的信号的数据结构，OS直接修改PCB中指定的位图结构，完成发送信号的过程</strong></p> 
</blockquote> 
<h3 id="2.1%C2%A0%E9%80%9A%E8%BF%87%E7%BB%88%E7%AB%AF%E6%8C%89%E9%94%AE%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7">2.1 通过终端按键产生信号</h3> 
<blockquote> 
 <p>SIGINT的默认处理动作是终止进程,SIGQUIT的默认处理动作是终止进程并且Core Dump,现在我们来验证一 下。Crtl + c 本质是向进程发送二号信号SIGINIT，Crtl + \ 本质是向进程发送三号信号SIGQUIT！</p> 
</blockquote> 
<h3 id="2.2%C2%A0Core%20Dump%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8">2.2 <strong>Core Dump核心转储</strong></h3> 
<blockquote> 
 <p>        首先解释什么是Core Dump。</p> 
 <p><strong>        当一个进程要异常终止时,可以选择把该进程在cpu的用户空间内存数据全部保存到磁盘上,文件名通常是core,这叫做Core Dump。（主要是为了调试）</strong><br>  </p> 
 <p>        进程异常终止通常是因为有Bug,比如非法内存访问导致段错误, 事后可以用调试器检查core文件以查清错误原因,这叫做<strong>Post-mortem Debug</strong>（事后调试）。一个进程允许 产生多大的core文件取决于进程的<strong>Resource Limit</strong>(这个信息保存 在PCB中)。默认是不允许产生core文件的, 因为core文件中可能包含用户密码等敏感信息,不安全。在开发调试阶段可以用ulimit命令改变这个限制,允许产生core文件。 首先用ulimit命令改变Shell进程的Resource Limit,允许core文件最大为1024K: $ ulimit -c 1024</p> 
 <p class="img-center"><img alt="" height="232" src="https://images2.imgbox.com/2f/4a/Gh7gfZ9U_o.png" width="632"></p> 
 <p>然后写一个死循环程序:</p> 
 <pre><code>#include&lt;iostream&gt;
#include&lt;unistd.h&gt;
using namespace std;

int main(){
    while(true){
        cout &lt;&lt; "hello Linux" &lt;&lt; endl;
        sleep(1);
    }
    return 0;
}</code></pre> 
 <p>前台运行这个程序,然后在终端键入Ctrl-C（ 貌似不行）或Ctrl-\（介个可以）:</p> 
 <p class="img-center"><img alt="" height="243" src="https://images2.imgbox.com/1c/71/JO8ejBpB_o.png" width="628"></p> 
 <p>ulimit命令改变了Shell进程的Resource Limit,test进程的PCB由Shell进程复制而来,所以也具 有和Shell进程相 同的Resource Limit值,这样就可以产生Core Dump了。 使用core文件：</p> 
 <pre><code>[customer@VM-4-10-centos 30lesson]$ ll
total 252
-rwxrwxr-x 1 customer customer   9016 Sep  1 17:19 a.out
-rw------- 1 customer customer 561152 Sep 13 21:56 core.23928
-rw-rw-r-- 1 customer customer    167 Sep  1 17:18 loop.cc
[customer@VM-4-10-centos 30lesson]$ gdb a.out 
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from /home/customer/LinuxLearn/second/30lesson/a.out...(no debugging symbols found)...done.
(gdb) core-file core.23928 
[New LWP 23928]
Core was generated by `./a.out'.
Program terminated with signal 3, Quit.
#0  0x00007fc63db389e0 in __nanosleep_nocancel () from /lib64/libc.so.6
Missing separate debuginfos, use: debuginfo-install glibc-2.17-326.el7_9.x86_64 libgcc-4.8.5-44.el7.x86_64
(gdb) 
</code></pre> 
 <p><strong>可以看出 Crtl + \ 是由于Program terminated with signal 3, Quit.</strong></p> 
 <p></p> 
 <p><strong>而信号详细介绍中，action标记了哪些信号会发生核心转储（core dump）</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="442" src="https://images2.imgbox.com/db/77/N2VYgp7c_o.png" width="636"></p> 
</blockquote> 
<h3 id="2.3%C2%A0%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E5%90%91%E8%BF%9B%E7%A8%8B%E5%8F%91%E4%BF%A1%E5%8F%B7kill%E3%80%81raise">2.3 调用系统函数向进程发信号kill、raise</h3> 
<blockquote> 
 <p>首先在后台执行死循环程序,然后用kill命令给它发SIGSEGV信号。</p> 
 <pre><code>[customer@VM-4-10-centos 30lesson]$ ps axj | grep "a.out"
 1687 25836 25836  1687 pts/0    25836 S+    1003   0:00 ./a.out
25371 25844 25843 25371 pts/4    25843 R+    1003   0:00 grep --color=auto a.out
[customer@VM-4-10-centos 30lesson]$ kill -SIGSEGV 25836
[customer@VM-4-10-centos 30lesson]$ ll
total 252
-rwxrwxr-x 1 customer customer   9016 Sep  1 17:19 a.out
-rw------- 1 customer customer 561152 Sep 13 22:04 core.25836
-rw-rw-r-- 1 customer customer    167 Sep  1 17:18 loop.cc
[customer@VM-4-10-centos 30lesson]$ 

--------------------------------------------------------------------------------

[customer@VM-4-10-centos 30lesson]$ ls
a.out  loop.cc
[customer@VM-4-10-centos 30lesson]$ ./a.out 
hello Linux
hello Linux
hello Linux
hello Linux
hello Linux
Segmentation fault (core dumped)
[customer@VM-4-10-centos 30lesson]$ </code></pre> 
 <p>        25836是a.out进程的id。之所以要再次回车才显示 Segmentation fault ,是因为在4568进程终止掉之前已经回到了Shell提示符等待用户输入下一条命令,Shell不希望Segmentation fault信息和用户的输入交错在一起,所以等用户输入命令之后才显示。</p> 
 <p>        指定发送某种信号的kill命令可以有多种写法,上面的命令还可以写成 kill -SIGSEGV 4568 或 kill -11 4568 , 11是信号SIGSEGV的编号。以往遇到的段错误都是由非法内存访问产生的,而这个程序本身没错, 给它发SIGSEGV也能产生段错误。</p> 
 <p></p> 
 <p><strong>Linux系统也提供了发送信号的系统调用接口：</strong></p> 
 <ol><li>kill命令是调用kill函数实现的。kill函数可以给一个指定的进程发送指定的信号。</li><li>raise函数可以给当前进程发送指定的信号(自己给自己发信号)。</li></ol> 
 <pre><code>#include &lt;signal.h&gt;
int kill(pid_t pid, int signo);
int raise(int signo);
这两个函数都是成功返回0,错误返回-1。</code></pre> 
 <p>     3. C标准库自己提供的，abort函数使当前进程接收到信号而异常终止</p> 
 <pre><code>#include &lt;stdlib.h&gt;
void abort(void);
就像exit函数一样,abort函数总是会成功的,所以没有返回值。</code></pre> 
</blockquote> 
<h3 id="2.4%C2%A0%E7%94%B1%E8%BD%AF%E4%BB%B6%E6%9D%A1%E4%BB%B6%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7alarm">2.4 由软件条件产生信号alarm</h3> 
<blockquote> 
 <p>管道，读端关闭，写端一直在写，写没有意义，此时OS会发送信号终止写端！</p> 
 <p><strong>SIGPIPE</strong>是一种由软件条件产生的信号,在“管道”中已经介绍过了。下面主要介绍alarm函数 和<strong>SIGALRM</strong>信号。</p> 
 <pre><code>#include &lt;unistd.h&gt;
unsigned int alarm(unsigned int seconds);

调用alarm函数可以设定一个闹钟,也就是告诉内核在seconds秒之后
给当前进程发SIGALRM信号, 该信号的默认处理动作是终止当前进程。</code></pre> 
 <p>        这个函数的返回值是0或者是以前设定的闹钟时间还余下的秒数。打个比方,某人要小睡一觉,设定闹钟为30分钟之后响,20分钟后被人吵醒了,还想多睡一会儿,于是重新设定闹钟为15分钟之后响,“以前设定的闹钟时间还余下的时间”就是10分钟。如果seconds值为0,表示取消以前设定的闹钟,函数的返回值仍然是以前设定的闹钟时间还余下的秒数！</p> 
 <p></p> 
 <p><strong>如何理解软件条件给进程发送信号：</strong></p> 
 <p>a. OS显示别到某种软件条件触发或者不满足</p> 
 <p>b. OS构建信号，发送指定的进程</p> 
</blockquote> 
<h3 id="2.5%C2%A0%E7%A1%AC%E4%BB%B6%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7">2.5 硬件异常产生信号</h3> 
<blockquote> 
 <p>        硬件异常被硬件以某种方式被硬件检测到并通知内核,然后内核向当前进程发送适当的信号。例如当前进程执行了除以0的指令,CPU的运算单元会产生异常,内核将这个异常解释为<strong>SIGFPE信号（浮点异常）</strong>发送给进程。再比如当前进程访问了非法内存地址,,MMU会产生异常,内核将这个异常解释为<strong>SIGSEGV信号（段错误）</strong>发送给进程。</p> 
 <p></p> 
 <p><strong>如何理解除零异常？</strong></p> 
 <p>1. 进行计算的是CPU运算器，是硬件</p> 
 <p>2. CPU内部是由寄存器的，（浮点数相关寄存器）还具有状态寄存器，有对应的状态标记位（位图），有对应的状态标记位，OS会自动进行检测溢出标记位！溢出标记位为1，OS识别到有溢出问题，提取PID，OS完成信号发送的过程，在合适时候，进行处理</p> 
 <p>3. 一旦出现硬件异常，进程一定会退出吗？不一定，默认是退出，可以捕捉，但是我们即便不退出，也做不了什么（会一直收到硬件异常信号，用户无法改变CPU状态寄存器）</p> 
 <p>4. 寄存器中的异常一直没有被解决，所以一直会收到信号</p> 
</blockquote> 
<h3 id="2.6%20wait%5Cwaitpid%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%A0%81%E6%98%AF%E5%90%A6%E5%8F%91%E7%94%9F%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8%EF%BC%88%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%A1%A5%E5%85%85core%E4%BF%A1%E5%8F%B7%EF%BC%89">2.6 wait\waitpid子进程状态码是否发生核心转储（进程控制补充core信号）</h3> 
<blockquote> 
 <ul><li>wait和waitpid，都有一个status参数，该参数是一个输出型参数，由操作系统填充</li><li>status不能简单的当作整形来看待，可以当作位图来看待，具体细节如下图（只研究status低16比特位）：</li></ul> 
 <p class="img-center"><img alt="" height="201" src="https://images2.imgbox.com/f4/ee/CYHZM7h0_o.png" width="624"></p> 
 <p>其中低16比特位，前8位表示退出状态，而退出异常一定产生了终止信号，后7位用于表示终止信号，第8位表示是否发生核心转储</p> 
 <p></p> 
 <p><strong>stdlib.h提供了宏函数计算退出码及终止信号值：</strong></p> 
 <p><strong>判断正常退出下，退出码：</strong></p> 
 <pre><code>       WIFEXITED(status)

       returns true if the child terminated normally, that is, 
       by calling exit(3) or _exit(2), or by returning from 
       main().


       WEXITSTATUS(status)

       returns  the  exit  status  of  the child.  This 
       consists of the least significant 8 bits of the status 
       argument that the child specified in a call to exit(3) 
       or _exit(2) or as  the  argument  for  a  return statement 
       in main().  This macro should be employed only if WIFEXITED 
       returned true.</code></pre> 
 <p><strong>判断信号退出下，产生的信号，及是否发生核心转储：</strong></p> 
 <pre><code>       WIFSIGNALED(status)
       returns true if the child process was terminated by 
       a signal.

       WTERMSIG(status)
       returns  the  number  of  the  signal that caused 
       the child process to terminate.  This macro should 
       be employed only if WIFSIGNALED returned true.

       WCOREDUMP(status)
       returns true if the child produced a core dump.  
       This macro should  be  employed  only  if  WIFSIGNALED
       returned true.  This macro is not specified in 
       POSIX.1-2001 and is not available on some UNIX implemen‐
       tations (e.g., AIX, SunOS).  Only use this enclosed in 
       #ifdef WCOREDUMP ... #endif.</code></pre> 
 <p>测试代码：</p> 
 <pre><code>#include &lt;iostream&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;cassert&gt;

int main()
{
    pid_t id = fork();
    assert(id != -1);
    if(id == 0){
        //子进程
        //sleep(100);
        int a = 100;
        // floating point exception -8 SIGFPE
        a /= 0;
        cout &lt;&lt; "running ... " &lt;&lt; endl;
        return 1;
    }
    int status;
    pid_t w = waitpid(id, &amp;status, 0);
    assert(w != -1);
    // WIFSIGNALEND 如果因为信号推出，返回true
    // WCOREDUMP 如果发生了核心转储，返回true 判断core dump == 1
    // WTERMSIG WIFSIGNALEND发生的情况下，判断终止信号
    if(WIFSIGNALED(status)){
        cout &lt;&lt; "kill signal : " &lt;&lt; WTERMSIG(status) &lt;&lt; endl;
        if(WCOREDUMP(status))
            cout &lt;&lt; "发生核心转储" &lt;&lt; endl;
    }else{
        cout &lt;&lt; "正常退出" &lt;&lt; endl;
    }
    return 0;
}</code></pre> 
 <p></p> 
</blockquote> 
<h2 id="3.%20%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7%E5%88%9D%E8%AF%86">3. 捕捉信号初识</h2> 
<blockquote> 
 <p>信号处理的常见方式：</p> 
 <p>1. 默认（进程自带的，程序员写好的逻辑）</p> 
 <p>2. 忽略（也是信号的一种处理方式）</p> 
 <p>3. 自定义动作（捕捉信号）</p> 
</blockquote> 
<h3 id="3.1%20%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3signal">3.1 捕捉信号系统调用接口signal</h3> 
<blockquote> 
 <p>信号是可以被自定义捕捉的，siganl函数就是来进行信号捕捉的</p> 
 <pre><code>NAME
       signal - ANSI C signal handling

SYNOPSIS
       #include &lt;signal.h&gt;

       typedef void (*sighandler_t)(int);

       sighandler_t signal(int signum, sighandler_t handler);
</code></pre> 
 <p>参数一：捕捉的信号         参数二：函数指针，用于替换捕捉后处理动作</p> 
 <p></p> 
 <pre><code>#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
void handler(int sig)
{
 printf("catch a sig : %d\n", sig);
}
int main()
{
 signal(2, handler); //信号是可以被自定义捕捉的，siganl函数就是来进行信号捕捉的
 while(1);
 return 0;
}
[customer@VM-4-10-centos 30lesson]$ ./sig 
^Ccatch a sig : 2
^Ccatch a sig : 2
^Ccatch a sig : 2
^Ccatch a sig : 2
^\Quit (core dumped)
[customer@VM-4-10-centos 30lesson]$</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="3.2%20%E5%AE%9A%E6%97%B6%E5%99%A8%E9%97%B9%E9%92%9F%E5%8A%9F%E8%83%BD">3.2 定时器闹钟功能</h3> 
<blockquote> 
 <pre><code>#include &lt;iostream&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;cassert&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;

using namespace std;
uint64_t count = 0;
typedef function&lt;void ()&gt; func;

vector&lt;func&gt; callbacks;

void showCount(){
    cout &lt;&lt; "Process catch a signal!\tpid : " &lt;&lt; getpid() &lt;&lt; "\tcount : "
         &lt;&lt; count &lt;&lt; endl;
}

void showLog(){
    cout &lt;&lt; "This is logging function! To do something..." &lt;&lt; endl;
}

void logUser(){
    if(fork() == 0){
        execl("/usr/bin/who", "who", nullptr);
        exit(1);
    }
    wait(nullptr);
}

void fflushData(){

}

void catchSignal(int signum)
{
    //exit(1);
    for(auto &amp;f : callbacks){
        f();
    }
    alarm(1);
}


int main()
{
    alarm(1);
    signal(SIGALRM, catchSignal);
    //定时任务：算力检测 、 打印日志 、 用户检测
    callbacks.push_back(showCount);
    callbacks.push_back(showLog);
    callbacks.push_back(logUser);
    // int count = 0;
    // 算力计算
    while (true)
    {
        count++;
        // cout &lt;&lt; "count : " &lt;&lt; count &lt;&lt; endl;
    }

    return 0;
} </code></pre> 
 <p><strong>IO效率低，尤其是带上网络，理解定时</strong></p> 
</blockquote> 
<h3 id="3.3%C2%A0%E6%A8%A1%E6%8B%9F%E9%87%8E%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%EF%BC%88%E7%A1%AC%E4%BB%B6%E5%BC%82%E5%B8%B8%EF%BC%89">3.3 模拟野指针异常（硬件异常）</h3> 
<blockquote> 
 <pre><code>//默认行为
[customer@VM-4-10-centos 30lesson]$ cat sig.c 
#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
void handler(int sig)
{
 printf("catch a sig : %d\n", sig);
}
int main()
{
 //signal(SIGSEGV, handler);
 sleep(1);
 int *p = NULL;
 *p = 100;
 while(1);
 return 0;
}
[customer@VM-4-10-centos 30lesson]$ ./sig 
Segmentation fault (core dumped)
[customer@VM-4-10-centos 30lesson]$


//捕捉行为
[customer@VM-4-10-centos 30lesson]$ cat sig.c 
#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
void handler(int sig)
{
 printf("catch a sig : %d\n", sig);
}
int main()
{
 //signal(SIGSEGV, handler);
 sleep(1);
 int *p = NULL;
 *p = 100;
 while(1);
 return 0;
}


[customer@VM-4-10-centos 30lesson]$ ./sig 
catch a sig : 11
catch a sig : 11
catch a sig : 11
catch a sig : 11
</code></pre> 
 <p><strong>如何理解野指针或者越界问题？</strong></p> 
 <p>1. 都必须通过地址，找到目标位置</p> 
 <p>2. 语言上得地址，全部都是虚拟地址</p> 
 <p>3. 将虚拟地址转为物理地址</p> 
 <p>4. 页表 + MMU（Memory Manage Unit，内存管理单元，硬件）</p> 
 <p>5. 野指针、越界，访问非法地址，在页表通过MMU转化的时候，一定会报错</p> 
 <p>MMU也具有寄存器，能通过页表，找到对应进程的PCB结构体，给对应进程发送信号！！！</p> 
 <p></p> 
 <p><strong>由此可以确认，我们在C/C++当中除零，内存越界等异常，在系统层面上，是被当成信号处理的。且硬件异常，即使捕捉，实际也不能做什么！</strong></p> 
</blockquote> 
<h3 id="3.4%20%E6%80%BB%E7%BB%93">3.4 总结</h3> 
<blockquote> 
 <ol><li>上面所说的所有信号产生，最终都要有OS来进行执行，为什么？OS是进程的管理者</li><li>信号的处理是否是立即处理的？在合适的时候</li><li>信号如果不是被立即处理，那么信号是否需要暂时被进程记录下来？记录在哪里最合适呢？需要，记录到进程对应PCNB结构体的信号位图上</li><li>一个进程在没有收到信号的时候，能否能知道，自己应该对合法信号作何处理呢？知道，程序员设计好的</li><li>如何理解OS向进程发送信号？能否描述一下完整的发送处理过程？OS根据信号编号，修改特定进程的信号位图</li></ol> 
 <p></p> 
 <p><strong>所有的信号，都有他的来源，但是最终全部都是被OS识别，解释，并发送的！</strong></p> 
</blockquote> 
<h2 id="4.%20%E6%B7%B1%E5%85%A5%E5%86%85%E6%A0%B8%E5%8F%8A%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7">4. 深入内核及阻塞信号</h2> 
<h3 id="4.1%20%E4%BF%A1%E5%8F%B7%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5">4.1 信号其他相关常见概念</h3> 
<blockquote> 
 <ol><li>实际执行信号的处理动作称为信号递达(Delivery)</li><li>信号从产生到递达之间的状态,称为信号未决(Pending)</li><li>进程可以选择阻塞 (Block )某个信号。</li><li>被阻塞的信号产生时将保持在未决状态,直到进程解除对此信号的阻塞,才执行递达的动作</li><li>注意,阻塞和忽略是不同的,只要信号被阻塞就不会递达,而忽略是在递达之后可选的一种处理动作。</li></ol> 
</blockquote> 
<h3 id="4.2%C2%A0%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA">4.2 在内核中的表示</h3> 
<blockquote> 
 <p>信号在内核中的表示示意图：</p> 
 <p class="img-center"><img alt="" height="206" src="https://images2.imgbox.com/c6/a5/4FEUCsNm_o.png" width="634"></p> 
 <ul><li>每个信号都有两个标志位分别表示阻塞(block)和未决(pending),还有一个函数指针表示处理动作。信号产生时,内核在进程控制块中设置该信号的未决标志,直到信号递达才清除该标志。在上图的例子中,SIGHUP信号未阻塞也未产生过,当它递达时执行默认处理动作。</li><li>SIGINT信号产生过,但正在被阻塞,所以暂时不能递达。虽然它的处理动作是忽略,但在没有解除阻塞之前不能忽略这个信号,因为进程仍有机会改变处理动作之后再解除阻塞。</li><li>SIGQUIT信号未产生过,一旦产生SIGQUIT信号将被阻塞,它的处理动作是用户自定义函数sighandler。 如果在进程解除对某信号的阻塞之前这种信号产生过多次,将如何处理?POSIX.1允许系统递送该信号一次或多次。Linux是这样实现的:常规信号在递达之前产生多次只计一次,而实时信号在递达之前产生多次可以依次放在一个队列里。</li></ul> 
 <pre><code>    信号编号signal
    底层实现 signal -&gt; block位图（记录信号是否阻塞）
    pending位图（记录接收信号） handler（哈希映射回调）
    
    sighandler_t signal(int signum, sighandler_t __handler);
    
    /* Fake signal functions.  */
    #define SIG_ERR	((__sighandler_t) -1)		/* Error return.  */
    #define SIG_DFL	((__sighandler_t) 0)		/* Default action.  */
    #define SIG_IGN	((__sighandler_t) 1)		/* Ignore signal.  */
    
         handler[signal] = __handler;
         if((int)handler[signal] == 0) //执行默认动作, done
         if(int)handler[signal] == 1) //执行忽略动作, done
         handler[signal]()</code></pre> 
 <p>block位图和pending位图一样，位图中的内容，代表的含义是对应的信号是否被阻塞！</p> 
</blockquote> 
<h3 id="4.3%C2%A0sigset_t">4.3 sigset_t</h3> 
<blockquote> 
 <p>从上图来看,<strong>每个信号只有一个bit的未决标志,非0即1</strong>,不记录该信号产生了多少次,阻塞标志也是这样表示的。 因此,<strong>未决和阻塞标志可以用相同的数据类型sigset_t来存储,sigset_t称为信号集</strong>,这个类型可以表示每个信号 的“有效”或“无效”状态,在阻塞信号集中“有效”和“无效”的含义是该信号是否被阻塞,而在未决信号集中“有 效”和“无效”的含义是该信号是否处于未决状态。</p> 
 <p></p> 
 <p><strong>阻塞信号集也叫做当前进程的信号屏蔽字(Signal Mask),这里的“屏蔽”应该理解为阻塞而不是忽略。 </strong></p> 
 <p></p> 
 <ul><li><strong>sigset_t -- 不允许用户自己操作 -- OS给我们提供了对应的操作位图的方法</strong></li><li><strong>sigset_t -- user是可以直接使用该类型 -- 和用内置类型 &amp;&amp; 自定义类型 没有任何差别</strong></li><li><strong>sigset_t -- 一定需要对应的系统接口，来完成对用的功能，其中系统接口需要的参数，可能就包含了sigset_t定义的对象或者变量</strong></li></ul> 
</blockquote> 
<h3 id="4.4%20%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">4.4 信号集操作函数</h3> 
<h4 id="4.4.1%20sigset_t%20%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">4.4.1 sigset_t 操作函数</h4> 
<blockquote> 
 <p>sigset_t类型对于每种信号用一个bit表示“有效”或“无效”状态</p> 
 <p><strong>        至于这个类型内部如何存储这些bit则依赖于系统实现,从使用者的角度是不必关心的,使用者只能调用以下函数来操作sigset_ t变量,而不应该对它的内部数据做任何解释</strong></p> 
 <p><strong>        </strong>比如用printf直接打印sigset_t变量是没有意义的</p> 
 <pre><code>#include &lt;signal.h&gt;
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset (sigset_t *set, int signo);
int sigdelset(sigset_t *set, int signo);
int sigismember（const sigset_t *set, int signo); </code></pre> 
 <ul><li>函数sigemptyset初始化set所指向的信号集,使其中所有信号的对应bit清零,表示该信号集不包含任何有效信号。</li><li>函数sigfillset初始化set所指向的信号集,使其中所有信号的对应bit置位,表示该信号集的有效信号包括系统支持的所有信号。</li><li>注意,在使用sigset_ t类型的变量之前,一定要调用sigemptyset或sigfillset做初始化,使信号集处于确定的状态。初始化sigset_t变量之后就可以在调用sigaddset和sigdelset在该信号集中添加或删除某种有效信号</li></ul> 
 <p>这四个函数都是成功返回0,出错返回-1。sigismember是一个布尔函数,用于判断一个信号集的有效信号中是否包含某种信号,若包含则返回1,不包含则返回0,出错返回-1。</p> 
</blockquote> 
<h4 id="4.4.2%C2%A0sigprocmask">4.4.2 sigprocmask</h4> 
<blockquote> 
 <p>调用函数sigprocmask可以<strong>读取或更改进程的信号屏蔽字(阻塞信号集)</strong>。</p> 
 <pre><code>#include &lt;signal.h&gt;
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); 
返回值:若成功则为0,若出错则为-1 
</code></pre> 
 <p>如果oldset是非空指针,则读取进程的当前信号屏蔽字通过oldset参数传出。如果set是非空指针,则更改进程的信号屏蔽字,参数how指示如何更改。如果oldset和set都是非空指针,则先将原来的信号屏蔽字备份到oldset里,然后 根据set和how参数更改信号屏蔽字。假设当前的信号屏蔽字为mask,下表说明了how参数的可选值。</p> 
 <p class="img-center"><img alt="" height="204" src="https://images2.imgbox.com/c7/2b/wnIXl08u_o.png" width="551"></p> 
 <p>如果调用sigprocmask解除了对当前若干个未决信号的阻塞,则在sigprocmask返回前,至少将其中一个信号递达。</p> 
</blockquote> 
<h4 id="4.4.3%C2%A0sigpending" style="background-color:transparent;">4.4.3 sigpending</h4> 
<blockquote> 
 <pre><code>NAME
       sigpending - examine pending signals

SYNOPSIS
       #include &lt;signal.h&gt;

       int sigpending(sigset_t *set);</code></pre> 
 <p><strong>读取当前进程的未决pending信号集</strong>,通过set参数传出。调用成功则返回0,出错则返回-1。</p> 
</blockquote> 
<h3 id="4.5%20%E6%93%8D%E4%BD%9C%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90">4.5 操作案例分析</h3> 
<h4 id="4.5.1%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8D%95%E6%8D%89%E6%89%80%E6%9C%89%E4%BF%A1%E5%8F%B7%EF%BC%9F">4.5.1 自定义捕捉所有信号？</h4> 
<blockquote> 
 <p>如果我们对所有的信号都进行了自定义捕捉 -- 我们是不是就写了一个不会被异常或者用户杀掉的进程？？可以吗？</p> 
 <pre><code>#include &lt;iostream&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cassert&gt;

using namespace std;

void catchSig(int signum){
    cout &lt;&lt; "获得了一个信号 :" &lt;&lt; signum &lt;&lt; endl;
    // switch (signum)
    // {
    // case SIGINT:
    //     break;
    
    // default:
    //     break;
    // }
}

int main(){
    for(int i = 1; i &lt; 31; ++i) signal(i, catchSig);
    while(true) sleep(1);
    return 0;
}</code></pre> 
 <p>sendSig.sh</p> 
 <pre><code>#！/bin/bash
i=1
id=$(pidof signal)
while [ $i -le 31 ]
do
    if [ $i -eq 9 ];then
        let i++
        continue
    fi
    if [ $i -eq 19 ];then
        let i++
        continue
    fi
    kill -$i $id
    echo "send signal: $i";
    let i++
    sleep 1
done</code></pre> 
 <p></p> 
 <p><strong>答案是：并不是，OS设计者已经考虑到了，普通信号集中9号信号SIGKILL、19号信号SIGSTOP、31号信号SIGSYS是无法被捕捉的</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="328" src="https://images2.imgbox.com/8d/d9/WVs7gnb8_o.png" width="623"></p> 
</blockquote> 
<h4 id="4.5.2%20%E8%A7%82%E5%AF%9Fblock%E4%BF%A1%E5%8F%B7%E7%9A%84pending%E4%BF%A1%E5%8F%B7%E9%9B%86">4.5.2 观察block信号的pending信号集</h4> 
<blockquote> 
 <p>如果我们将2号信号block，并且不断获取并打印当前进程的pending信号集，如果我们突然发送一个2号信号，就应该可以肉眼观察到pending信号集中，有一个比特位由 0 -&gt; 1</p> 
 <pre><code>#include &lt;iostream&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cassert&gt;

using namespace std;

static void showPending(sigset_t &amp;pending)
{
    for (int sig = 31; sig &gt;= 1; --sig)
    {
        if (sigismember(&amp;pending, sig))
        {
            cout &lt;&lt; "1";
        }
        else
        {
            cout &lt;&lt; "0";
        }
    }
    cout &lt;&lt; endl;
}

static void catchSignal(int signum)
{
    std::cout &lt;&lt; "Haved catch : signum 2" &lt;&lt; endl;
}

// 2号信号block，并且不断获取并打印当前进程的pending信号集
// 可有观察到pending信号集中，有一个比特位由 0 -&gt; 1
int main()
{
    // 方便测试 捕捉2号信号，不递达推出
    signal(2, catchSignal);
    // 1.定义信号集对象
    sigset_t set, oset;
    sigset_t pending;
    // 2.初始化信号集对象
    sigemptyset(&amp;set);
    sigemptyset(&amp;oset);
    sigemptyset(&amp;pending);
    // 3.添加2号block
    sigaddset(&amp;set, SIGINT);

    // 4.获取打印pending
    int count = 0;
    while (true)
    {
        if (count == 5)
        {
            cout &lt;&lt; "2 号信号恢复成功..." &lt;&lt; endl;
            int n = sigprocmask(SIG_SETMASK, &amp;oset, nullptr);
            assert(n == 0);
            (void)n;
        }
        if(count == 10 || count == 0){
            count = 0;
            cout &lt;&lt; "block 2 号信号成功...    pid = " &lt;&lt; getpid() &lt;&lt; endl;
            int n = sigprocmask(SIG_BLOCK, &amp;set, &amp;oset);
            assert(n == 0);
        }
        sleep(1);
        sigpending(&amp;pending);
        showPending(pending);
        count++;
    }
    return 0;
}</code></pre> 
 <p>测试结果如下：</p> 
 <p class="img-center"><img alt="" height="322" src="https://images2.imgbox.com/2e/2e/ymXqUcrB_o.png" width="625"></p> 
 <p><strong>可见2号信号被阻塞后，处于阻塞状态，但是信号会一直保存在未达信号pending位图中，一旦2号信号不再被阻塞，便会直接递达处理2号信号</strong></p> 
</blockquote> 
<h4 id="4.5.3%C2%A0%E9%98%BB%E5%A1%9E%E6%89%80%E6%9C%89%E4%BF%A1%E5%8F%B7%EF%BC%9F">4.5.3 阻塞所有信号？</h4> 
<blockquote> 
 <p>如果我们对所有的信号都进行block -- 我们是不是就写一个不会被异常或者用户杀掉的进程？？可以吗？</p> 
 <pre><code>#include &lt;iostream&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cassert&gt;

using namespace std;

static void blockSig(int signo){
    sigset_t bset;
    sigemptyset(&amp;bset);
    sigaddset(&amp;bset, signo);
    int n = sigprocmask(SIG_BLOCK, &amp;bset, nullptr);
    assert(n == 0);
    (void)n;
}

static void showPending(sigset_t &amp;pending)
{
    for (int sig = 31; sig &gt;= 1; --sig)
    {
        if (sigismember(&amp;pending, sig))
        {
            cout &lt;&lt; "1";
        }
        else
        {
            cout &lt;&lt; "0";
        }
    }
    cout &lt;&lt; endl;
}

int main(){

    for(int sig = 1; sig &lt;= 31; ++sig){
        blockSig(sig);
    }
    sigset_t pending;
   
    while(true){
        sigpending(&amp;pending);
        showPending(pending);
        sleep(1);
    }

    return 0;
}</code></pre> 
 <p>结果图：</p> 
 <p class="img-center"><img alt="" height="415" src="https://images2.imgbox.com/9a/d2/MoHwgnlM_o.png" width="626"></p> 
 <p><strong>结果分析：可见9号、19号、20号信号无法被阻塞！</strong></p> 
</blockquote> 
<h2 id="5.%20%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7">5. 捕捉信号</h2> 
<p class="img-center"><img alt="" height="469" src="https://images2.imgbox.com/32/3d/QkPedBg8_o.png" width="604"></p> 
<blockquote> 
 <p>信号产生之后，可能无法被立即处理，在合适的时候处理？</p> 
 <p><strong>1. 在合适的时候（是什么时候）？</strong></p> 
 <p>        信号相关的数据字段都是在进程PCB内部——内核范畴——内核状态——用户态（一定是在内核态中，<strong><span style="color:#faa572;">从内核态返回用户态的时候，进行信号检测和处理！</span></strong>）</p> 
 <p>        <strong>为什么会进入内核态？</strong>进行系统调用，缺陷陷阱异常等！</p> 
 <p>        <strong>怎么进入内核态？</strong>有一条汇编中断指令 int 0X80，陷入内核，内置在系统调用函数中！</p> 
 <p style="text-align:center;"><strong><span style="color:#e6b223;">参考文章：<a href="https://zhuanlan.zhihu.com/p/358731121#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E9%99%90%E5%88%B6" rel="nofollow" title="int 0x80 - 知乎 (zhihu.com)">int 0x80 - 知乎 (zhihu.com)</a></span></strong></p> 
 <p class="img-center"><img alt="" height="469" src="https://images2.imgbox.com/8d/6a/RW6h5cnd_o.png" width="600"></p> 
 <p>        用户态是一个受管控的状态，而内核态是一个操作系统执行自己代码的状态，内核态具备非常高的优先级！而每个进程都有3~4G的地址空间给内核使用，内核级页表被所有进程看到!</p> 
 <p>        <strong>可以执行进程切换的代码？<span style="color:#faa572;">操作系统内部具有一个context_switch等函数，然后当我们对应进程时间片到了，操作系统底层硬件发送时钟中断，操作系统通过正在执行进程的地址空间找到进程切换的函数，然后在该进程上下文进行切换，也会进行该进程上下文数据及CPU临时数据保存到该进程PCB当中，此时OS选择一个进程再上来！</span></strong></p> 
 <p>        <strong>凭什么有权利执行OS的代码？</strong>凭借是处于内核态还是用户态，CPU寄存器具有两套，一套可见，一套CPU不可见，自用，其中有CR3寄存器表示当前CPU的执行权限！</p> 
 <p></p> 
 <p><strong>2. 信号处理的整个流程？</strong></p> 
</blockquote> 
<h3 id="5.1%C2%A0%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%8D%95%E6%8D%89">5.1 内核如何实现信号的捕捉</h3> 
<blockquote> 
 <p>如果信号的处理动作是用户自定义函数,在信号递达时就调用这个函数,这称为捕捉信号。</p> 
 <p>        由于<strong>信号处理函数的代码是在用户空间的</strong>,处理过程比较复杂,举例如下:</p> 
 <ol><li>用户程序注册了SIGQUIT信号的处理函数sighandler。</li><li>当前正在执行main函数,这时发生中断或异常切换到内核态。</li><li>在中断处理完毕后要返回用户态的main函数之前检查到有信号 SIGQUIT递达。</li><li>内核决定返回用户态后不是恢复main函数的上下文继续执行,而是执行sighandler函 数,sighandler 和main函数使用不同的堆栈空间,它们之间不存在调用和被调用的关系,是两个独立的控制流程。</li><li>sighandler函数返回后自动执行特殊的系统调用sigreturn再次进入内核态。</li><li>如果没有新的信号要递达,这次再返回用户态就是恢复 main函数的上下文继续执行了。</li></ol> 
 <p class="img-center"><img alt="" height="344" src="https://images2.imgbox.com/05/f4/RJ9NuU06_o.png" width="631"></p> 
</blockquote> 
<h3 id="5.2%C2%A0sigaction" style="background-color:transparent;">5.2 sigaction</h3> 
<blockquote> 
 <p>sigaction - 检查更改信号动作（捕捉信号）</p> 
 <pre><code class="hljs">#include &lt;signal.h&gt;

       int sigaction(int signum, const struct sigaction *act,
                     struct sigaction *oldact);


RETURN VALUE
       sigaction() returns 0 on success; on error, -1 is returned
            , and errno is set to indicate the error.</code></pre> 
 <p>参数：捕捉信号编号，输入型参数（操作系统提供的结构体），输出型参数</p> 
</blockquote> 
<h4 id="5.2.1%20struct%20sigaction%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84%E4%BD%93">5.2.1 struct sigaction内核结构体</h4> 
<blockquote> 
 <p>struct sigaction成员：</p> 
 <pre><code class="hljs">           struct sigaction {
               void     (*sa_handler)(int); 
               //设置捕捉信号所对应的回调函数

               void     (*sa_sigaction)(int, siginfo_t *, void *);
               sigset_t   sa_mask;
               //
               int        sa_flags;
               void     (*sa_restorer)(void);
           };
</code></pre> 
 <p></p> 
</blockquote> 
<h4 id="5.2.2%20sa_handler">5.2.2 sa_handler</h4> 
<blockquote> 
 <p>捕捉信号：</p> 
 <pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

using namespace std;

void handler(int signum){
    cout &lt;&lt; "获取一个信号" &lt;&lt; endl;
}

int main(){
    // signal(2, SIG_IGN); // 设置忽略2号信号
    struct sigaction act, oact;
    act.sa_flags = 0;
    sigemptyset(&amp;act.sa_mask);
    act.sa_handler = handler;

    sigaction(2, &amp;act, &amp;oact);
    cout &lt;&lt; "default action : " &lt;&lt; (int)oact.sa_handler &lt;&lt; endl;

    while(true) sleep(1);
    return 0;
}</code></pre> 
 <p>运行结果，oact处理动作为默认：</p> 
 <pre><code class="hljs">[customer@VM-4-10-centos sigaction]$ ./mysignal 
default action : 0
^C获取一个信号
^C获取一个信号
^C获取一个信号
^\Quit</code></pre> 
 <p>将sa_handler赋值为常数SIG_IGN传给sigaction表示忽略信号,赋值为常数SIG_DFL表示执行系统默认动 作,赋值为一个函数指针表示用自定义函数捕捉信号,或者说向内核注册了一个信号处理函 数,该函数返回 值为void,可以带一个int参数,通过参数可以得知当前信号的编号,这样就可以用同一个函数处理多种信 号。显然,这也是一个回调函数,不是被main函数调用,而是被系统所调用。</p> 
</blockquote> 
<h4 id="5.2.3%20sa_mask" style="background-color:transparent;">5.2.3 sa_mask</h4> 
<blockquote> 
 <p>        处理信号的时候，执行自定义动作，如果在处理信号期间，又来了同样的信号，OS该怎么处理？</p> 
 <p>        OS如果在处理信号时，再次收到信号，此时再从自定义handler用户态转内核态再转用户态，不断接受信号，此时便会递归式！<span style="color:#faa572;"><strong>因此，为了避免这种情况，Linux在任何时刻，只能处理一层信号，不允许信号在被处理时，收到信号，再次处理</strong></span>！</p> 
 <p></p> 
 <p>        本质：为什么要有block？</p> 
 <p>       <strong> 当某个信号的处理函数被调用时,内核自动将当前信号加入进程的信号屏蔽字,当信号处理函数返回时自动恢复原来的信号屏蔽字,这样就保证了在处理某个信号时,如果这种信号再次产生,那么它会被阻塞到当前处理结束为止</strong>。</p> 
 <p>        如果在调用信号处理函数时,除了当前信号被自动屏蔽之外,还希望自动屏蔽另外一些信号,则用sa_mask字段说明这些需要额外屏蔽的信号,当信号处理函数返回时自动恢复原来的信号屏蔽字。</p> 
 <p>        在处理信号期间，接收到其他所设置sa_mask内的信号会被屏蔽，但是会保存在pending位图中，处理信号完成，自动恢复原来的信号屏蔽字，再次检测pending，进行信号处理</p> 
 <pre><code class="hljs">sigaddset(&amp;act.sa_mask, 3);
sigaddset(&amp;act.sa_mask, 4);</code></pre> 
 <p>sa_flags字段包含一些选项,本章的代码都 把sa_flags设为0,sa_sigaction是实时信号的处理函数</p> 
</blockquote> 
<h4 id="5.2.4%20%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7%E8%BF%87%E7%A8%8B%E5%86%8D%E6%AC%A1%E6%8E%A5%E6%94%B6">5.2.4 处理信号过程再次接收</h4> 
<blockquote> 
 <p>代码：</p> 
 <pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string&gt;

using namespace std;

void showSigset(sigset_t *pending)
{
    for (int i = 31; i &gt;= 1; --i)
    {
        if (sigismember(pending, i))
            cout &lt;&lt; "1";
        else
            cout &lt;&lt; "0";
    }
    cout &lt;&lt; endl;
}

void checkSigset(string logP, string logB)
{
    sigset_t pending, blocking;

    sigpending(&amp;pending);
    sigprocmask(0, nullptr, &amp;blocking);
    cout &lt;&lt; logP;
    showSigset(&amp;pending);

    cout &lt;&lt; logB;
    showSigset(&amp;blocking);
}

void handler(int signum)
{
    cout &lt;&lt; "获取一个信号" &lt;&lt; endl;
    // 处理期间，2号信号被设置为阻塞，再次收到，2号信号不会被处理

    int c = 3;
    while (true)
    {
        string logP = "pending  : ";
        string logB = "blocking : ";
        checkSigset(logP, logB);
        cout &lt;&lt; endl;
        c--;
        if (!c)
            break;
        sleep(1);
    }
    cout &lt;&lt; endl
         &lt;&lt; endl;
}

int main()
{
    // signal(2, SIG_IGN); // 设置忽略2号信号
    struct sigaction act, oact;
    act.sa_flags = 0;
    sigemptyset(&amp;act.sa_mask);
    act.sa_handler = handler;

    sigaction(2, &amp;act, &amp;oact);
    cout &lt;&lt; "default action : " &lt;&lt; (int)oact.sa_handler &lt;&lt; endl;

    string logAP = "处理信号 pending  : ";
    string logAB = "处理信号 blocking : ";

    while (true)
    {
        checkSigset(logAP, logAB);
        cout &lt;&lt; endl
             &lt;&lt; endl;
        sleep(1);
    }

    return 0;
}</code></pre> 
 <p>运行结果：</p> 
 <pre><code class="hljs">[customer@VM-4-10-centos sigaction]$ ./mysignal 
default action : 0
处理信号 pending  : 0000000000000000000000000000000
处理信号 blocking : 0000000000000000000000000000000


^C获取一个信号
pending  : 0000000000000000000000000000000
blocking : 0000000000000000000000000000010

pending  : 0000000000000000000000000000000
blocking : 0000000000000000000000000000010

^Cpending  : 0000000000000000000000000000010
blocking : 0000000000000000000000000000010



获取一个信号
pending  : 0000000000000000000000000000000
blocking : 0000000000000000000000000000010

pending  : 0000000000000000000000000000000
blocking : 0000000000000000000000000000010

pending  : 0000000000000000000000000000000
blocking : 0000000000000000000000000000010



处理信号 pending  : 0000000000000000000000000000000
处理信号 blocking : 0000000000000000000000000000000


^\Quit</code></pre> 
 <p><span style="color:#ad720d;"><strong>结论：观察可知</strong></span></p> 
 <ol><li>在获取信号时（信号未决），进行处理（信号递达），处理前会进行两个默认动作，首先将pending位图进行处理信号的位由1置为0，将block位图进行处理信号的位由0置为1！</li><li>在处理信号期间，再次接收到同样信号，会被保存到pending位图中，但是不会被递达</li><li>在上次处理完成后，将block位图中该信号由1置为0，再次处理pending位图中的信号（同样步骤）</li></ol> 
</blockquote> 
<h3 id="5.3%20%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0">5.3 可重入函数</h3> 
<blockquote> 
 <p>信号捕捉并没有创建新的进程或线程！</p> 
 <p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/37/55/DVkSHoqV_o.png" width="636"></p> 
 <ul><li>main函数调用insert函数向一个链表head中插入节点node1，插入操作分为两步,刚做完第一步的时候,因为硬件中断（时序问题）使进程切换到内核,再次回用户态之前检查到有信号待处理,于是切换到sighandler函数,sighandler也调用insert函数向同一个链表head中插入节点node2,插入操作的两步都做完之后从sighandler返回内核态,再次回到用户态就从main函数调用的insert函数中继续往下执行,先前做第一步之后被打断,现在继续做完第二步。</li><li>结果是,main函数和sighandler先后向链表中插入两个节点,而最后只有一个节点真正插入链表中了。 <strong>像上例这样,insert函数被不同的控制流程调用,有可能在第一次调用还没返回时就再次进入该函数,<span style="color:#0d0016;">这称为重入</span>,insert函数访问一个全局链表,有可能因为重入而造成错乱<span style="color:#ad720d;">,像这样的函数称为不可重入函数</span></strong>,反之, <strong>如果一个函数只访问自己的局部变量或参数,则称为<span style="color:#ad720d;">可重入(Reentrant) 函数</span></strong>。</li><li>想一下,为什么两个不同的控制流程调用同一个函数,访问它的同一个局部变量或参数就不会造成错乱?</li></ul> 
 <p><strong>可重入函数 vs 不可重入函数：</strong></p> 
 <p><strong>        是函数的一种特征，目前我们用的90%的函数，都是不可重入的！</strong></p> 
 <p></p> 
 <p><strong> 如果一个函数符合以下条件之一则是不可重入的:</strong></p> 
 <ol><li>调用了malloc或free,因为malloc也是用全局链表来管理堆的。</li><li>调用了标准I/O库函数。标准I/O库的很多实现都以不可重入的方式使用全局数据结构。</li></ol> 
</blockquote> 
<h3 id="5.4%C2%A0volatile">5.4 volatile</h3> 
<blockquote> 
 <p>该关键字在C当中，站在信号的角度重新理解一下</p> 
 <p>观察下面程序运行：</p> 
 <pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

using namespace std;

int flag = 0;

void changeFlag(int signum)
{
    cout &lt;&lt; "change flag : " &lt;&lt; flag;
    flag = 1;
    cout &lt;&lt; " -&gt; " &lt;&lt; flag &lt;&lt; endl;
}

int main()
{
    signal(2, changeFlag);
    while (!flag)
        ;
    cout &lt;&lt; "进程正常退出后 : " &lt;&lt; flag &lt;&lt; endl;
    return 0;
}
</code></pre> 
 <p>标准情况下，键入 CTRL-C ,2号信号被捕捉，执行自定义动作，修改 flag＝1 ， while 条件不满足,退出循 环，进程退出</p> 
 <p></p> 
 <p>编译器优化：g++ -o $@ $^ -std=c++11 -O3</p> 
 <p></p> 
 <p>运行结果：</p> 
 <pre><code class="hljs">[customer@VM-4-10-centos volatile]$ ./mysignal 
^Cchange flag : 0 -&gt; 1
^Cchange flag : 1 -&gt; 1
^Cchange flag : 1 -&gt; 1
^Cchange flag : 1 -&gt; 1
^\Quit</code></pre> 
 <p>        优化情况下，键入 CTRL-C ,2号信号被捕捉，执行自定义动作，修改 flag＝1 ，但是 while 条件依旧满足,进程继续运行！但是很明显flag肯定已经被修改了，但是为何循环依旧执行？</p> 
 <p>        很明显， while 循环检查的flag， 并不是内存中最新的flag，这就存在了数据二异性的问题。编译器在main函数中并未发现有更改flag的操作，因此 while 检测的flag被优化，放在了 CPU寄存器当中，此时内存中flag即使被更改，CPU寄存器也不为所动！</p> 
 <p>        如何解决呢？<span style="color:#ad720d;"><strong>很明显需要 volatile，告诉编译器该字段不可被优化，每次检测必须到内存中访问该数据，保持内存可见性</strong></span></p> 
 <pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

using namespace std;

volatile int flag = 0;

void changeFlag(int signum)
{
    cout &lt;&lt; "change flag : " &lt;&lt; flag;
    flag = 1;
    cout &lt;&lt; " -&gt; " &lt;&lt; flag &lt;&lt; endl;
}

int main()
{
    signal(2, changeFlag);
    while (!flag)
        ;
    cout &lt;&lt; "进程正常退出后 : " &lt;&lt; flag &lt;&lt; endl;
    return 0;
}
</code></pre> 
 <p>运行结果：</p> 
 <pre><code class="hljs">[customer@VM-4-10-centos volatile]$ ./mysignal 
^Cchange flag : 0 -&gt; 1
进程正常退出后 : 1</code></pre> 
 <p><span style="color:#ad720d;"><strong>volatile 作用：保持内存的可见性，告知编译器，被该关键字修饰的变量，不允许被优化，对该变量 的任何操作，都必须在真实的内存中进行操作</strong></span></p> 
</blockquote> 
<h2 id="6.%C2%A0SIGCHLD%E4%BF%A1%E5%8F%B7%20-%20%E9%80%89%E5%AD%A6%E4%BA%86%E8%A7%A3" style="background-color:transparent;">6. SIGCHLD信号 - 选学了解</h2> 
<blockquote> 
 <p>进程用wait和waitpid函数清理僵尸进程,父进程可以阻塞等待子进程结束,也可以非阻塞地查询是否有子进程结束等待清理(也就是轮询的方式)。</p> 
 <p>        采用第一种方式,父进程阻塞了就不能处理自己的工作了;</p> 
 <p>        采用第二种方式,父 进程在处理自己的工作的同时还要记得时不时地轮询一 下,程序实现复杂。</p> 
 <p>        其实,<span style="color:#ad720d;"><strong>子进程在终止时会给父进程发SIGCHLD信号,该信号的默认处理动作是忽略,</strong></span>父进程可以自定义SIGCHLD信号的处理函数，<strong>这样父进程只需专心处理自己的工作,不必关心子进程了,子进程终止时会通知父进程,父进程在信号处理函数中调用wait清理子进程即可。</strong></p> 
 <p><strong>        </strong></p> 
 <p>请编写一个程序完成以下功能:父进程fork出子进程,子进程调用exit(2)终止,父进程自定义SIGCHLD信号的处理函数, 在其中调用wait获得子进程的退出状态并打印。</p> 
 <pre><code class="hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

void handler(int sig)
{
    pid_t id;
    while ((id = waitpid(-1, NULL, WNOHANG)) &gt; 0)
    {
        printf("wait child success: %d\n", id);
    }
    printf("child is quit! father pid : %d\n", getpid());
}
int main()
{
    signal(SIGCHLD, handler);
    pid_t cid;
    if ((cid = fork()) == 0)
    { // child
        printf("child : %d\n", getpid());
        sleep(3);
        exit(1);
    }
    while (1)
    {
        printf("father proc is doing some thing!\n");
        sleep(1);
    }
    return 0;
}</code></pre> 
 <p>        事实上,由于UNIX 的历史原因,要想不产生僵尸进程还有另外一种办法:父进程调用sigaction将SIGCHLD的处理动作置为SIG_IGN,这样fork出来的子进程在终止时会自动清理掉,不会产生僵尸进程,也不会通知父进程。系统默认的忽略动作和用户用sigaction函数自定义的忽略通常是没有区别的,但这是一个特例。此方法对于Linux可用,但不保证在其它UNIX系统上都可用。</p> 
</blockquote> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f574f8045767706106d36a4c7137960/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Faunadb</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/78b3e9c5eb190fd37d901f5c19bae929/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot&#43;vue校园高校学习资料分享网站系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>