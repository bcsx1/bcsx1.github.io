<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从 0 到 1 搞一个 Compose Desktop 版本的天气应用（附源码） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从 0 到 1 搞一个 Compose Desktop 版本的天气应用（附源码）" />
<meta property="og:description" content="大家好，好久不见，今天带大家一起来玩下 Compose Desktop ，带大家从头到尾写一个桌面版的天气应用，并且打好包让别人也可以进行使用，废话不多说，先来看下最终的实现效果吧！
效果是不是挺好？哈哈哈！
其实作为一个安卓开发来说，当运行起第一个桌面版程序的时候内心突然感觉回到了最开始学习编程的时候，那种感觉就好像一个多年未见的老友对你说：久违了！特别是使用的技术还都是安卓开发的技术，只是有一些平台原因需要稍做修改的地方就能开发出一个完整的桌面版软件，内心还是非常激动，非常地有成就感，这种感觉太舒服了！
踩坑 缘起 Compose 为什么会搞 Compose Desktop，这还得从 Jetpack Compose 说起：Google 从 2017 年开始立项开搞 Compose 到第一个正式版本用了四年的时间，那么久的时间，投入了那么多的人力，以及后面投入了大量经费宣传，无一不在告诉安卓开发者 Compose 很重要，这也是之后安卓开发的新方向！所以当第一个 alpha 版本的 Compose 出现的时候我就坐不住了，立马加上依赖尝试了下！刚开始写的时候感觉有点奇怪，毕竟从之前的开发模式变为了全新的声明式开发，但写了不到一周就感受到了 Compose 的优势，编写起来太快了，动画实现起来也太简单了，声明式编程也太方便了。。。。
其实 Compose Desktop 出现的也很早，Jetpack Compose 出来没多久它也就出来了，有很多同行在 Compose Desktop 出来第一个 alpha 版本的时候就开始研究，不过由于我是做安卓开发的，日常工作也不会涉及到桌面开发，况且 Compose Desktop 是 Jetbrains 开发的，并不 Google 开发的，毕竟是模仿 Jetpack Compose 的，未来两边的 API 都有可能对应不上，所以也就一直没有关注。
但是到后来转折点来了，公众号：《Android 开发者》在 2022 年 11 月 30 日早上发了一篇文章，名为：“Jetpack 更新一览 | 2022 Android 开发者峰会”，这篇文章的前半部分没有什么新鲜感，因为这些库我也一直在用，也经常关注着新版本和新功能，但看到文章最后的时候，里面有一段话是这么写的：
我们一直在尝试使 Jetbrains 的 Kotlin 多平台移动版支持跨平台共享代码。我们针对 Android 和 iOS 应用推出了实验性的 Collection 预览版和 DataStore 库。期待您的反馈！您可以查看相关博文，了解更多内容。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3915509ab9965c36cc62954acdffc95c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-14T21:40:44+08:00" />
<meta property="article:modified_time" content="2022-12-14T21:40:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从 0 到 1 搞一个 Compose Desktop 版本的天气应用（附源码）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>大家好，好久不见，今天带大家一起来玩下 <code>Compose Desktop</code> ，带大家从头到尾写一个桌面版的天气应用，并且打好包让别人也可以进行使用，废话不多说，先来看下最终的实现效果吧！</p> 
<p><img src="https://images2.imgbox.com/66/19/Eznnj9Vk_o.gif" alt="QQ20221212-143238-HD.gif"></p> 
<p>效果是不是挺好？哈哈哈！</p> 
<p>其实作为一个安卓开发来说，当运行起第一个桌面版程序的时候内心突然感觉回到了最开始学习编程的时候，那种感觉就好像一个多年未见的老友对你说：久违了！特别是使用的技术还都是安卓开发的技术，只是有一些平台原因需要稍做修改的地方就能开发出一个完整的桌面版软件，内心还是非常激动，非常地有成就感，这种感觉太舒服了！</p> 
<h2><a id="_8"></a>踩坑</h2> 
<h3><a id="_Compose_11"></a>缘起 Compose</h3> 
<p>为什么会搞 <code>Compose Desktop</code>，这还得从 <code>Jetpack Compose</code> 说起：<code>Google</code> 从 2017 年开始立项开搞 <code>Compose</code> 到第一个正式版本用了四年的时间，那么久的时间，投入了那么多的人力，以及后面投入了大量经费宣传，无一不在告诉安卓开发者 <code>Compose</code> 很重要，这也是之后安卓开发的新方向！所以当第一个 <code>alpha</code> 版本的 <code>Compose</code> 出现的时候我就坐不住了，立马加上依赖尝试了下！刚开始写的时候感觉有点奇怪，毕竟从之前的开发模式变为了全新的声明式开发，但写了不到一周就感受到了 <code>Compose</code> 的优势，编写起来太快了，动画实现起来也太简单了，声明式编程也太方便了。。。。</p> 
<p>其实 <code>Compose Desktop</code> 出现的也很早，<code>Jetpack Compose</code> 出来没多久它也就出来了，有很多同行在 <code>Compose Desktop</code> 出来第一个 <code>alpha</code> 版本的时候就开始研究，不过由于我是做安卓开发的，日常工作也不会涉及到桌面开发，况且 <code>Compose Desktop</code> 是 <code>Jetbrains</code> 开发的，并不 <code>Google</code> 开发的，毕竟是模仿 <code>Jetpack Compose</code> 的，未来两边的 <code>API</code> 都有可能对应不上，所以也就一直没有关注。</p> 
<p>但是到后来转折点来了，公众号：《Android 开发者》在 2022 年 11 月 30 日早上发了一篇文章，名为：“<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F-B5tT0na5BnwqMbrA53GOg" rel="nofollow" title="https://mp.weixin.qq.com/s/-B5tT0na5BnwqMbrA53GOg">Jetpack 更新一览 | 2022 Android 开发者峰会</a>”，这篇文章的前半部分没有什么新鲜感，因为这些库我也一直在用，也经常关注着新版本和新功能，但看到文章最后的时候，里面有一段话是这么写的：</p> 
<blockquote> 
 <p>我们一直在尝试使 Jetbrains 的 Kotlin 多平台移动版支持跨平台共享代码。我们针对 Android 和 iOS 应用推出了实验性的 Collection 预览版和 DataStore 库。期待您的反馈！您可以查看相关博文，了解更多内容。</p> 
</blockquote> 
<p>这话说的，你们一直在尝试，<code>Jetpack Compose</code> 正式版都出来快一年半了！<code>Compose Desktop</code> 正式版也都一年多了！这么久怎么连点信都没有。。。不过好在现在有信了！<code>Google</code> 这也算放出了几个信号，也不知道我的理解是否正确😂：</p> 
<ol start="0"><li>他们也一直在关注 <code>Jetbrains</code> 的 <code>Compose Desktop</code></li><li>目前已经有两个 <code>Jetpack</code> 的库支持了 <code>Compose Desktop</code></li><li>后续也会将更多的 <code>Jetpack</code> 中的库支持 <code>Compose Desktop</code></li></ol> 
<h4><a id="_Flutter__28"></a>对标 Flutter ？</h4> 
<p><code>Flutter</code> 现在已经比较成熟了，它最大的优势就是跨平台，<code>Flutter</code> 虽然宣称的是原生的性能，一套代码多端实现，但其实对于跨平台来说一套代码并不能完全实现需求，肯定需要各种适配，只不过看框架适配的好与坏，<code>Compose Desktop</code> 也是如此，但 <code>Flutter</code> 的性能也只是媲美原生，而 <code>Compose</code> 就是原生啊！<code>Compose Desktop</code> 其实并不是和 <code>Flutter</code> 抢饭碗，它只是告诉广大安卓开发：你们并不需要学习安卓之外的东西就能开发各种设备上的应用！这也是 <code>Kotlin</code> 的辉煌，我个人认为这也是 <code>Jetbrains</code> 公司开发 <code>Compose Desktop</code> 的初衷。</p> 
<p>基于上面的分析，打开了 <code>Jetbrains</code> 的 <code>Compose Desktop</code> 的官网：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jetbrains.com%2Fzh-cn%2Flp%2Fcompose-desktop%2F" rel="nofollow" title="https://www.jetbrains.com/zh-cn/lp/compose-desktop/">www.jetbrains.com/zh-cn/lp/co…</a> ，也开始试着玩一玩桌面版的应用！</p> 
<h3><a id="_Compose_Desktop_34"></a>初探 Compose Desktop</h3> 
<p>我本来还想着使用 <code>Android Studio</code> 来使用 <code>Compose Desktop</code> 来着，结果打开 <code>Android Studio</code> 新建项目一看并没有找到创建 <code>Compose Desktop</code> 的入口，后来想想也对，<code>Android Studio</code> 嘛！本来就是为了构建 <code>Android</code> 项目的，并不是为了构建别的东西，对吧！（内心独白：可能是我自己没找到）</p> 
<p>那就使用 <code>IntelliJ Idea</code> 来看看吧，点击 New -&gt; Project 就会出现下面的页面：</p> 
<p><img src="https://images2.imgbox.com/9c/7d/iCJLtTYD_o.png" alt="image.png"></p> 
<p>选择 Kotlin 之后就可以看到右边有 <code>Compose Multiplatform</code> 的选项，里面有三种，第一种就是这段时间要搞的 <code>Compose Desktop</code> ，第二种就是多平台了，里面有 <code>Android</code> ，也有 <code>Compose Desktop</code> ，第三种是 <code>Compose Web</code> 。不得不说太强了！桌面、Web、移动端，<code>Compose</code> 一套搞定！目前 <code>IOS</code> 也支持了，不过这不是咱们要看的重点，还是来看 <code>Compose Desktop</code> 吧！接下来点击 Next ，之后选择配置项之后点击 Finish 后第一个 <code>Compose Desktop</code> 项目就创建好了！</p> 
<h4><a id="_45"></a>项目结构</h4> 
<p>接下来看下初始项目的结构吧：</p> 
<p><img src="https://images2.imgbox.com/1d/2e/Cx6sLV7D_o.png" alt="image.png"></p> 
<p>OK，有一个 Main.kt 文件，还有 build 和 settings 文件。下面咱们一个一个来看，先来看下 settings 文件吧：</p> 
<pre><code>pluginManagement {
    repositories {
        google()
        gradlePluginPortal()
        maven("https://maven.pkg.jetbrains.space/public/p/compose/dev")
    }
    
}
rootProject.name = "Demo"

</code></pre> 
<p>嗯，这个很简单，放了依赖的仓库地址，还有项目的名称。</p> 
<p>接下来再来看下 build 文件：</p> 
<pre><code>plugins {
    kotlin("jvm") version "1.5.31"
    id("org.jetbrains.compose") version "1.0.0"
}
​
dependencies {
    implementation(compose.desktop.currentOs)
}
​
tasks.withType&lt;KotlinCompile&gt; {
    kotlinOptions.jvmTarget = "11"
}
​
compose.desktop {
    application {
        mainClass = "MainKt"
        nativeDistributions {
            targetFormats(TargetFormat.Dmg, TargetFormat.Msi, TargetFormat.Deb)
            packageName = "Demo"
            packageVersion = "1.0.0"
        }
    }
}

</code></pre> 
<p>build 文件中稍微多点，分别是 plugins 、dependencies 、jvmTarget 和 application ，前几个就不过多介绍，因为安卓项目中都有，最后的 application 是这里独有的，其实这块就是对桌面项目的一些属性的配置，可以看到有包名和版本号等信息，这块在这里先不进行过多介绍，因为这块的内容很多，<code>Windows</code> 、<code>Mac</code> 、<code>Linux</code> 各个系统的配置都不太相同，在之后的文章中会着重来介绍，这里先跳过。</p> 
<h4><a id="_99"></a>初始代码</h4> 
<p>最后来看下 Main.kt 文件：</p> 
<pre><code>@Composable
@Preview
fun App() {
    var text by remember { mutableStateOf("Hello, World!") }
    MaterialTheme {
        Button(onClick = {
            text = "Hello, Desktop!"
        }) {
            Text(text)
        }
    }
}
​
fun main() = application {
    Window(onCloseRequest = ::exitApplication) {
        App()
    }
}

</code></pre> 
<p>代码并不多，而且很熟悉，但也有不认识的地方。可以看到这里出现了 <code>Java</code> 中熟悉的 <code>Main</code> 方法，然后里面调用了一个 <code>application</code> 方法，在其中有一个可组合项 <code>Window</code> ，在里面调用了 <code>App</code> 可组合项。</p> 
<h4><a id="Application_127"></a>Application</h4> 
<p>可组合项咱们都是非常了解的，这块不太清楚的其实就是 <code>application</code> 和 <code>Window</code> ，因为这两个在之前 <code>Jetpack Compose</code> 中都是没有的，下面咱们就先来看看 <code>application</code> ：</p> 
<pre><code>fun application(
    exitProcessOnExit: Boolean = true,
    content: @Composable ApplicationScope.() -&gt; Unit
) {
    val configureSwingGlobals = System.getProperty("compose.application.configure.swing.globals") == "true"
    if (configureSwingGlobals) {
        configureSwingGlobalsForCompose()
    }
    runBlocking {
        awaitApplication {
            content()
        }
    }
    if (exitProcessOnExit) {
        exitProcess(0)
    }
}

</code></pre> 
<p><code>application</code> 是 <code>Compose Desktop</code> 应用程序的入口点，这块需要注意的是：不要在这个函数中使用任何动画（例如，<code>withframamanos</code> 或 <code>animatefloatasstate</code> 等），因为底层的 <code>MonotonicFrameClock</code> 没有与任何显示同步，所以无法尽快地生成帧。</p> 
<p>方法一共接收两个参数，来分别看下：</p> 
<ul><li><strong>exitProcessOnExit</strong>：结束进程，默认为 true，在应用程序关闭后调用 <code>exitProcess(0)</code> ，<code>exitProcess</code> 加速进程退出（立即退出，而不是1-4秒）。如果为 false ，函数的执行将在应用程序退出后被解除阻塞（当最后一个窗口关闭，以及所有 LaunchedEffect 完成时）。</li><li><strong>content</strong>：放可组合项的，不做多介绍。</li></ul> 
<h4><a id="Window_159"></a>Window</h4> 
<p>下面再来看下可组合项 <code>Window</code> ：</p> 
<pre><code>@Composable
fun Window(
    onCloseRequest: () -&gt; Unit,
    state: WindowState = rememberWindowState(),
    visible: Boolean = true,
    title: String = "Untitled",
    icon: Painter? = null,
    undecorated: Boolean = false,
    transparent: Boolean = false,
    resizable: Boolean = true,
    enabled: Boolean = true,
    focusable: Boolean = true,
    alwaysOnTop: Boolean = false,
    onPreviewKeyEvent: (KeyEvent) -&gt; Boolean = { false },
    onKeyEvent: (KeyEvent) -&gt; Boolean = { false },
    content: @Composable FrameWindowScope.() -&gt; Unit
)

</code></pre> 
<p><code>Window</code> 的代码有点多，这块咱们先不关心里面的具体实现，先来看看都有哪些功能。在当前 <code>Compose</code> 中组合成平台窗口。当 <code>Window</code> 进入组合成时，将创建一个新的平台窗口并接收焦点。当 <code>Window</code> 离开合成时，<code>Window</code> 将被释放并关闭。<code>Window</code> 的参数有点多，咱们分别来看下：</p> 
<ul><li><strong>onCloseRequest</strong>：当用户关闭窗口时将被调用的回调函数</li><li><strong>state</strong>：用于控制或观察窗口状态的状态对象</li><li><strong>visible</strong>：是否对用户可见</li><li><strong>title</strong>：窗口的名称</li><li><strong>icon</strong>：窗口的图标（<strong>和应用图标不同，完全两码事</strong>）</li><li><strong>undecorated</strong>：禁用或启用此窗口的装饰</li><li><strong>transparent</strong>：禁用或启用窗口透明度，需要注意：只有在窗口未装饰时才应该设置透明度，否则将引发异常</li><li><strong>resizable</strong>：用户是否可以调整窗口的大小</li><li><strong>enabled</strong>：窗口是否能对输入事件作出反应</li><li><strong>focusable</strong>：窗口是否可以接收焦点</li><li><strong>alwaysOnTop</strong>：窗口是否在另一个窗口的顶部</li><li><strong>onPreviewKeyEvent</strong>：当用户与硬件键盘交互时调用此回调，它为聚焦组件的祖先提供了拦截<code>KeyEvent</code> 的机会</li><li><strong>onKeyEvent</strong>：当用户与硬件键盘交互时调用此回调。在实现此回调时，返回 true 以停止此事件的传播。如果返回 false，<code>KeyEvent</code> 将被发送给这个 <code>onKeyEvent</code> 的父事件。</li></ul> 
<h4><a id="_200"></a>第一次运行</h4> 
<p>OK，到现在位置初始项目中的内容大概都过了一遍，接下来运行看下效果吧！</p> 
<p>那么问题又来了，怎么运行呢。。。之前咱们运行安卓项目的时候都是点击 <code>Android Studio</code> 上方运行，但现在看下：</p> 
<p><img src="https://images2.imgbox.com/42/ac/kT2EYkAz_o.png" alt="image.png"></p> 
<p>没有了，灰着的！不用担心，不还有 main 函数呢嘛！直接运行 main 函数！</p> 
<p><img src="https://images2.imgbox.com/11/6c/1mfKMetO_o.png" alt="image.png"></p> 
<p>点击运行按钮看下：</p> 
<p><img src="https://images2.imgbox.com/f3/65/4AW4c2Li_o.png" alt="image.png"></p> 
<p>直接弹出了一个<code>Java</code> 程序，里面放着一个按钮，刚才咱们看可组合项 <code>Window</code> 的时候不是可以修改名字嘛，下面修改下看看！</p> 
<pre><code>fun main() = application {
    Window(onCloseRequest = ::exitApplication, title = "天青色等烟雨") {
        App()
    }
}

</code></pre> 
<p>改了下名字，第二次运行的时候可以点击 main 函数，也可以点击 <code>Idea</code> 的上方运行按钮了，因为刚才运行的记录已经被保存下来了！</p> 
<p><img src="https://images2.imgbox.com/af/1a/8KkRacfu_o.png" alt="image.png"></p> 
<p>OK，点击运行查看结果：</p> 
<p><img src="https://images2.imgbox.com/51/8a/rPsk4lgd_o.png" alt="image.png"></p> 
<p>没错，和想的一样！</p> 
<p>到现在为止已经可以使用咱们之前学习的 <code>Jetpack Compose</code> 知识来愉快的编程了！</p> 
<h3><a id="_239"></a>显示图片</h3> 
<p>刚还想的可以好好使用 <code>Compose</code> 来编写桌面程序来着，可我刚想显示一张图片就发现了问题！怎么显示？？？</p> 
<h4><a id="_244"></a>普通图片</h4> 
<p>在 <code>Jetpack Compose</code> 中显示图片不叫事，直接使用 <code>painterResource</code> 将图片资源传进去就可以了，但在 <code>Compose Desktop</code> 中该怎么办呢？</p> 
<p>先来看下 <code>Compose Desktop</code> 中的 <code>Image</code> ：</p> 
<pre><code>@Composable
fun Image(
    painter: Painter,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    alignment: Alignment = Alignment.Center,
    contentScale: ContentScale = ContentScale.Fit,
    alpha: Float = DefaultAlpha,
    colorFilter: ColorFilter? = null
) 

</code></pre> 
<p>可以看到和 <code>Jetpack Compose</code> 中是一致的，不同的就是如何在 <code>Compose Desktop</code> 中构建 <code>Painter</code> 。</p> 
<p>先来看一种构建的方式吧：</p> 
<pre><code>BitmapPainter(useResource(resourcePath, ::loadImageBitmap))

</code></pre> 
<p>这块的 <code>resourcePath</code> 指的是图片的路径，这个路径是如何定义的呢？还记得上面创建完项目的初始结构么？里面有一个 <code>resource</code> 文件夹，这个文件夹就是根目录，比如 <code>resource</code> 文件夹中有一张图片“icon.png”，要构建这张图片的 <code>Painter</code> 就可以使用如下代码：</p> 
<pre><code>BitmapPainter(useResource("icon.png", ::loadImageBitmap))

</code></pre> 
<p>当然可以在 <code>resource</code> 中创建不同的文件夹来存放不同的资源，图片也是一样的。</p> 
<p>简单解释下这行代码吧，虽然看着就一行，其实使用到了好几个函数，首先说下 <code>useResource</code> ，它的作用是将传入的文件路径打开为 <code>InputStream</code> ，而 <code>loadImageBitmap</code> 函数是将 <code>InputStream</code> 转为 <code>ImageBitmap</code> ，最后通过使用 <code>BitmapPainter</code> 才构建出一个 <code>Painter</code> 。</p> 
<p>光说不练假把式！来整一张图片试下吧！</p> 
<pre><code>Image(painter = BitmapPainter(useResource("image/icon.png", ::loadImageBitmap)),"Test")

</code></pre> 
<p>由于我将图片放到 <code>resource</code> 中的 <code>image</code> 文件夹中，所以这块的路径做了一些修改，再来看下图片的目录吧：</p> 
<p><img src="https://images2.imgbox.com/61/b8/B89KTJtD_o.png" alt="image.png"></p> 
<p>下面来运行看下效果！</p> 
<p><img src="https://images2.imgbox.com/ee/dc/gDtgI6Uj_o.png" alt="image.png"></p> 
<p>OK，没问题，图片展示出来了！又向成功迈进了一步！！！</p> 
<h4><a id="SVG__301"></a>SVG 图片？</h4> 
<p>咱们现在在安卓中使用的图片大多改为了 SVG 格式的，体积又小且清晰，接下来按照相同的方式试一下，先放一张 SVG 格式的图片到刚才创建的 <code>image</code> 文件夹中：</p> 
<p><img src="https://images2.imgbox.com/59/55/1pEGkRcj_o.png" alt="image.png"></p> 
<p>图片放好了，下面来修改下图片的路径：</p> 
<pre><code>Image(painter = BitmapPainter(useResource("image/ic_launcher.svg", ::loadImageBitmap)),"Test")

</code></pre> 
<p>再运行下程序！</p> 
<p><img src="https://images2.imgbox.com/c0/bd/RqooAV3e_o.png" alt="image.png"></p> 
<p>额。。。刚不是还好好的嘛！这改了个图片格式就不行了？来看下报错信息吧！</p> 
<pre><code>Exception in thread "AWT-EventQueue-0" java.lang.IllegalArgumentException: Failed to Image::makeFromEncoded
  at org.jetbrains.skia.Image$Companion.makeFromEncoded(Image.kt:139)
  at androidx.compose.ui.res.ImageResources_desktopKt.loadImageBitmap(ImageResources.desktop.kt:33)
  at MainKt$App$1.invoke(Main.kt:31)
  at MainKt$App$1.invoke(Main.kt:24)

</code></pre> 
<p>可以看到报了编码错误，这应该咋么搞？？？</p> 
<p><code>Compose Desktop</code> 早就为我们想到了：</p> 
<pre><code>useResource(resourcePath) { loadSvgPainter(it, Density(2f)) }

</code></pre> 
<p><code>Compose Desktop</code> 为我们提供了一个叫 <code>loadSvgPainter</code> 的函数，专门用来处理 SVG 图片，接下来使用下看看：</p> 
<pre><code>Image(painter = useResource("image/ic_launcher.svg") { loadSvgPainter(it, Density(2f)) },"Test")

</code></pre> 
<p>使用也很简单，运行看下效果吧：</p> 
<p><img src="https://images2.imgbox.com/b9/43/LsrBsxfo_o.png" alt="image.png"></p> 
<p>嗯，没问题，正常展示！为了方便大家在 <code>Compose Desktop</code> 中使用图片，我写了一个构建 <code>Painter</code> 的函数：</p> 
<pre><code>/**
 * 构建Painter，为了图片使用
 * 
 * @param resourcePath 图片路径
 */
fun buildPainter(resourcePath: String): Painter {
    val painter: Painter = if (resourcePath.endsWith(".svg")) {
        useResource(resourcePath) {
            loadSvgPainter(it, Density(2f))
        }
    } else if (resourcePath.endsWith(".png") || resourcePath.endsWith(".jpg") ||
        resourcePath.endsWith(".jpeg") || resourcePath.endsWith(".webp") ||
        resourcePath.endsWith(".PNG") || resourcePath.endsWith(".JPG") ||
        resourcePath.endsWith(".JPEG") || resourcePath.endsWith(".WEBP") || resourcePath.endsWith(".ICO")
    ) {
        BitmapPainter(useResource(resourcePath, ::loadImageBitmap))
    } else {
        throw IllegalArgumentException("resource is illegal argument")
    }
    return painter
}

</code></pre> 
<p>这里并没有列举全所有的图片的后缀，但咱们一般使用到的都列举了出来，如果有特殊需求的话大家可以自己加上需要的后缀即可。</p> 
<h4><a id="_378"></a>柳暗花明</h4> 
<p>上面的一堆都是自己犯傻。。。其实 <code>Compose Desktop</code> 中也可以直接使用 <code>painterResource</code> 来构建图片。</p> 
<pre><code>Image(
    painter = painterResource(getWeatherIcon(dailyBean.iconDay)), "",
)

</code></pre> 
<p><strong>哈哈哈，为什么要写上面的一大堆呢，是让大家体会下我当时写的时候的经历。。。（内心：我是不是太坏了，哈哈哈😂）</strong></p> 
<h4><a id="_391"></a>网络图片</h4> 
<p>在安卓中加载网络图片一般都会使用 <code>Glide</code> ，但 <code>Glide</code> 是依赖于安卓的，所以无法在 <code>Compose Desktop</code> 中使用，不过也没有必要，下面来看下如何在 <code>Compose Desktop</code> 中使用网络图片吧：</p> 
<pre><code>@Composable
fun &lt;T&gt; AsyncImage(
    load: suspend () -&gt; T,
    painterFor: @Composable (T) -&gt; Painter,
    contentDescription: String,
    modifier: Modifier = Modifier,
    contentScale: ContentScale = ContentScale.Fit,
) {
    val image: T? by produceState&lt;T?&gt;(null) {
        value = withContext(Dispatchers.IO) {
            try {
                load()
            } catch (e: IOException) {
                e.printStackTrace()
                null
            }
        }
    }
    if (image != null) {
        Image(
            painter = painterFor(image!!),
            contentDescription = contentDescription,
            contentScale = contentScale,
            modifier = modifier
        )
    }
}
​
/* 加载网络图片 */
​
fun loadImageBitmap(url: String): ImageBitmap =
    URL(url).openStream().buffered().use(::loadImageBitmap)
​
fun loadSvgPainter(url: String, density: Density): Painter =
    URL(url).openStream().buffered().use { loadSvgPainter(it, density) }
​
fun loadXmlImageVector(url: String, density: Density): ImageVector =
    URL(url).openStream().buffered().use { loadXmlImageVector(InputSource(it), density) }

</code></pre> 
<p>加载图片的方法有了，如何使用呢？</p> 
<pre><code>AsyncImage(
    load = { loadImageBitmap("https://www.wanandroid.com/blogimgs/42da12d8-de56-4439-b40c-eab66c227a4b.png") },
    painterFor = { BitmapPainter(it) },
    contentDescription = "Sample",
    modifier = Modifier.width(200.dp)
)

</code></pre> 
<p>使用并不难，将图片的网址放进去即可，下面来运行看下效果吧：</p> 
<p><img src="https://images2.imgbox.com/62/f5/kYVBbatV_o.png" alt="image.png"></p> 
<p>还不错，图片显示得也挺快，大家可以试试！</p> 
<h3><a id="Retrofit_455"></a>网络请求—Retrofit</h3> 
<p>咱们要编写的天气应用肯定是需要网络请求的，这个项目中使用的是和风天气的免费 API，但问题来了，在 <code>Compose Desktop</code> 中要如何使用网络请求呢？</p> 
<p>难道要使用 <code>HttpURLConnection</code> 原生进行请求么？这根本不像一个安卓开发的风格啊！就算不能使用 <code>Retrofit</code> ，最不济也得使用 <code>OKHttp</code> 啊！那。。。在 <code>Compose Desktop</code> 中能使用这些安卓中的网络请求框架么？</p> 
<p>答案是能！为什么不能？这些框架又没有依赖安卓中的一些特定东西！对吧？</p> 
<p>说干就干！第一步当然还是添加依赖：</p> 
<pre><code>dependencies {
    implementation(compose.desktop.currentOs)
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
    implementation("com.squareup.retrofit2:converter-gson:2.9.0")
}

</code></pre> 
<p>这代码是不是很熟悉？没错，在安卓项目中也是这么使用的啊！</p> 
<p>接下来和在安卓中的使用方法其实就是一样的了，协程也可以使用！</p> 
<pre><code>object ServiceCreator {
​
    // 开发版
    private const val BASE_URL = "https://devapi.qweather.com/v7/"
    private const val CONNECT_TIMEOUT = 30L
    private const val READ_TIMEOUT = 10L
​
    private fun create(url: String = BASE_URL): Retrofit {
        val okHttpClientBuilder = OkHttpClient().newBuilder().apply {
            connectTimeout(CONNECT_TIMEOUT, TimeUnit.SECONDS)
            readTimeout(READ_TIMEOUT, TimeUnit.SECONDS)
        }
​
        return RetrofitBuild(
            url = url,
            client = okHttpClientBuilder.build(),
            gsonFactory = GsonConverterFactory.create()
        ).retrofit
    }
​
    fun &lt;T&gt; create(service: Class&lt;T&gt;): T = create().create(service)
}

</code></pre> 
<p>先构建了一个 <code>Retrofit</code> 对象，然后创建一个接口：</p> 
<pre><code>interface CityWeatherService {
​
    /**
     * 实时天气
     *
     * @param key 用户认证key
     * @param location 需要查询地区的LocationID或以英文逗号分隔的经度,纬度坐标
     * @param lang 多语言设置，默认中文
     *
     * 实时温度、体感温度、风力风向、相对湿度、大气压强、降水量、能见度、露点温度、云量等数据。
     */
    @GET("weather/now")
    suspend fun getWeatherNow(
        @Query("key") key: String = WEATHER_KEY,
        @Query("location") location: String,
        @Query("lang") lang: String = Lang.ZH_HANS.code
    ): WeatherNowBean
​
}

</code></pre> 
<p>这个没什么说的，接下来再创建一个调用的中间层：</p> 
<pre><code>object PlayWeatherNetwork {
​
    private val cityWeatherService = ServiceCreator.create(CityWeatherService::class.java)
​
    suspend fun getWeatherNow(location: String): WeatherNowBean =
        cityWeatherService.getWeatherNow(location = location)
​
}

</code></pre> 
<p>OK，完事，最后调用下试试！</p> 
<pre><code>LaunchedEffect(text) {
    val weatherNow = PlayWeatherNetwork.getWeatherNow("CN101010100")
    println("weatherNow:$weatherNow")
}

</code></pre> 
<p>运行看结果！</p> 
<p>当然 <code>Window</code> 中显示还是刚才的截图，只不过这块打印出了网络请求的结果，来看下打印出的 Log 信息：</p> 
<pre><code>weatherNow:WeatherNowBean(fxLink=http://hfx.link/2ax1, code=200, refer=model.Refer@5a146688, now=NowBaseBean(vis=2, temp=3, obsTime=2022-12-12T15:56+08:00, icon=503, wind360=98, windDir=东风, pressure=1016, feelsLike=-3, cloud=0, precip=0.0, dew=-20, humidity=16, text=扬沙, windSpeed=11, windScale=2, city=null), updateTime=2022-12-12T16:02+08:00)

</code></pre> 
<p><code>WeatherNowBean</code> 就是网络请求的实体类，这块不做过多描述。</p> 
<p>通过这个小例子是为了告诉大家在 <code>Compose Desktop</code> 项目中也能使用咱们熟悉的 <code>Retrofit</code> ！大家知道这一点就够了！</p> 
<blockquote> 
 <p>这块我在写的时候还有一个小插曲，这块的实体类之前是直接复制和风天气开源项目中的，不是 <code>kotlin</code> 而是是 <code>java</code> 编写的，运行的时候就报错了，将实体类改为 <code>Kotlin</code> 后就能正常运行了。</p> 
</blockquote> 
<h3><a id="Jetpack__569"></a>Jetpack 库使用</h3> 
<p>刚才在上面提到了，我就是因为 <code>Google</code> 说 <code>Jetpack</code> 中的库之后会支持 <code>Compose Desktop</code> 才决定玩一玩 <code>Compose Desktop</code> 的，那肯定也要尝试使用下啊！</p> 
<p><code>Google</code> 目前只推出了两个库支持：<code>Collection</code> 和 <code>DataStore</code> ，<code>Collection</code> 目前使用不到，那就先来看看如何使用 <code>DataStore</code> 吧！</p> 
<p>第一步还是添加依赖：</p> 
<pre><code>dependencies {
    ......
    implementation("androidx.datastore:datastore-preferences-core:1.1.0-dev01")
}

</code></pre> 
<p>其实 <code>DataStore</code> 的使用方法和之前在安卓中没有什么区别，唯一的区别就是创建的时候，先来看下在安卓中是如何创建 <code>DataStore</code> 的吧：</p> 
<pre><code>val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = "settings")

</code></pre> 
<p>这里用到了 <code>Context</code> ，这就是安卓中独有的，<code>Java</code> 中并没有啊，<code>Kotlin</code> 中也没有啊！那应该如何创建呢？</p> 
<pre><code>val dataStores = PreferenceDataStoreFactory.create {
    File("${System.getProperty("user.home")}/playWeatherData.preferences_pb")
}

</code></pre> 
<p><code>DataStore</code> 早就为我们考虑到了，使用 <code>PreferenceDataStoreFactory</code> 中的 <code>create</code> 方法就可以创建 <code>DataStore</code> 了。这块需要说明下 <code>System.getProperty("user.home")</code> ，这个获取的是用户 <code>home</code> 的路径，这块踩坑踩了很久，搞了大半天！最开始使用的是 <code>user.dir</code> ，这是项目 <code>work</code> 的目录，但是如果使用 <code>user.dir</code> 的话打包运行的话就会报错，说<strong>无法进行读写</strong>，所以修改为了 <code>"user.home"</code> 。其实还有一点也会报错，这块文件的后缀名一定得是 <code>preferences_pb</code> ，如果不写或修改为别的就会报错。这块帮助大家避下坑吧！</p> 
<p>剩下的使用方法就和安卓中一摸一样了！大家如果没有使用过的话可以看下我之前写 <code>DataStore</code> 的一篇文章：<a href="https://juejin.cn/post/6965672958165516295" rel="nofollow" title="https://juejin.cn/post/6965672958165516295">再抱一抱DataStore</a> 。</p> 
<h2><a id="_606"></a>绘制</h2> 
<h3><a id="_609"></a>动画的使用</h3> 
<p>通过上面的 GIF 图可以看到项目中使用到了一些动画，效果还是非常不错的，其实实现起来非常简单！</p> 
<h4><a id="_614"></a>可见性动画</h4> 
<p>首先来看下可见性动画的使用，之前我写过一个专栏，里面专门说了下 <code>Compose</code> 中的动画的使用及原理，有兴趣的大家可以去看下：<a href="https://juejin.cn/column/7139822154668834829" rel="nofollow" title="https://juejin.cn/column/7139822154668834829">Compose 动画开发艺术探索</a> 。</p> 
<p>可见性动画在页面左边用到了，点击添加按钮出现搜索页面的时候就使用的是可见性动画，简单看下代码：</p> 
<pre><code>@Composable
fun LeftInformation() {
    var showSearch by rememberSaveable { mutableStateOf(false) }
    Box(
        Modifier.fillMaxHeight().width(300.dp).padding(end = 10.dp)
    ) {
        WeatherDetails(onAddClick = {
            showSearch = true
        })
​
        AnimatedVisibility(
            visible = showSearch,
            enter = slideInHorizontally(),
            exit = slideOutHorizontally()
        ) {
            SearchCity()
        }
    }
}

</code></pre> 
<p>可以看到这块在进入的时候使用了 <code>slideInHorizontally</code> 动画，顾名思义，就是水平滑动展开，退出的时候使用了 <code>slideOutHorizontally</code> ，就是水平滑动退出。</p> 
<p>实现效果这里就不展示了，就是文章左边的动画效果。</p> 
<h4><a id="_647"></a>无限重复动画</h4> 
<p>无限重复动画在左边展示天气信息的天气图标上用到了，这块的重复动画使用了两种，如果是晴天的话就修改 <code>Modifier.rotate</code> ，因为晴天是太阳，旋转的话好看一些，如果不是晴天的话旋转不好看，所以改为 <code>Modifier.offset</code> ，这样平移的话好看一些。来看下实现代码吧：</p> 
<pre><code>@Composable
private fun RotateWeatherIcon(icon: String) {
    val infiniteTransition = rememberInfiniteTransition()
    val modifier = if (icon == "100") {
        val rotate by infiniteTransition.animateFloat(
            initialValue = 0f,
            targetValue = 360f,
            animationSpec = infiniteRepeatable(
                animation = tween(3500, easing = LinearOutSlowInEasing),
                repeatMode = RepeatMode.Reverse
            )
        )
        Modifier.rotate(rotate)
    } else {
        val offsetX by infiniteTransition.animateValue(
            initialValue = (-30).dp, // 初始值
            targetValue = 30.dp, // 目标值
            typeConverter = TwoWayConverter(
                { AnimationVector1D(it.value) },
                { it.value.dp }), // 类型转换
            animationSpec = infiniteRepeatable(  // 动画规格!!!
                animation = tween(3500, easing = LinearOutSlowInEasing),
                repeatMode = RepeatMode.Reverse
            )
        )
        Modifier.offset(x = offsetX)
    }
    Image(
        painter = painterResource(getWeatherIcon(icon)),
        "",
        modifier = modifier.size(170.dp).padding(10.dp)
    )
}

</code></pre> 
<p>无限重复动画的使用方式也不难，在之前的章节中说过，感兴趣的可以去上面所说的专栏中查看，大家放心，<code>Jetpack Compose</code> 中动画的使用方式和 <code>Compose Desktop</code> 一致。</p> 
<h3><a id="_690"></a>空气质量</h3> 
<p>空气质量就是右边天气详情中的第一个模块，样子如下图所示：</p> 
<p><img src="https://images2.imgbox.com/3a/f6/coHFaGaa_o.png" alt="image.png"></p> 
<p>这块是一个 “自定义 View”，为什么要加引号呢？因为这是 <code>Compose</code> 啊，不是安卓的 <code>View</code> 系统😂。</p> 
<p>下面来看下这个 “自定义 View” 如何实现的吧！</p> 
<pre><code>@Composable
private fun AirQualityProgress(aqiValue: Int) {
    Canvas {
        drawLine(
            brush = Brush.linearGradient(
                0.0f to Color(red = 139, green = 195, blue = 74),
                0.1f to Color(red = 255, green = 239, blue = 59),
                0.2f to Color(red = 255, green = 152, blue = 0),
                0.3f to Color(red = 244, green = 67, blue = 54),
                0.4f to Color(red = 156, green = 39, blue = 176),
                1.0f to Color(red = 143, green = 0, blue = 0),
            ),
            start = Offset.Zero,
            end = Offset(size.width, 0f),
            strokeWidth = 20f,
            cap = StrokeCap.Round,
        )
        drawPoints(
            points = arrayListOf(
                Offset(size.width / 500 * aqiValue, 0f)
            ),
            pointMode = PointMode.Points,
            color = Color.White,
            strokeWidth = 20f,
            cap = StrokeCap.Round,
        )
    }
}

</code></pre> 
<p>因为我没有开发过桌面的应用，所以不太清楚在桌面程序中实现这样的一个控件需要写多少代码，我只开发过安卓，只能拿安卓原生 <code>View</code> 做对比，在安卓 <code>View</code> 中如果想实现这样的一个控件的话绝对不止这么一点代码。。。</p> 
<p>来简单解释下这个控件吧：在 <code>Compose</code> 中绘制需要使用可组合项 <code>Canvas</code> ，然后来绘制下面的那条线，线上的颜色是渐变的，在 <code>Compose</code> 中只需要使用 <code>Brush</code> 就可以实现渐变，也可以控制在不同的进度显示不同颜色，空气质量一般分为六个等级：优、良、轻度污染、中度污染、重度污染和严重污染，所以上面对应有六种颜色。最后算出当前的 AQI 值应该绘制的地方进行绘制即可。</p> 
<h3><a id="7__737"></a>7 日天气预报</h3> 
<p>24 小时天气预报中没有什么需要说的，一个 <code>LazyRow</code> 就实现了，就直接跳过了。</p> 
<p>接下来来看下 7 日天气预报，这里其实大部分也不难，但注意看右边的温度条，这是模仿苹果天气中的温度条实现的，下面来看下苹果的样子吧：</p> 
<p><img src="https://images2.imgbox.com/fb/3c/KKDNWSR8_o.png" alt="image.png"></p> 
<p>再来看下我模仿实现的效果：</p> 
<p><img src="https://images2.imgbox.com/00/e2/pjGluFI7_o.png" alt="image.png"></p> 
<p>不能说一模一样，只能说大差不离。</p> 
<p>在模仿苹果这个小彩条的时候刚开始就犯了难，这是啥意思啊。。。这条里面都代表着什么啊，也看不太懂，后来网上找了半天才知道。</p> 
<ul><li>小彩条的长度代表温差，彩条越长温差越大。</li><li>根据最近 10 天的温度，分别设置最高值和最低值。例如上面的苹果截图，近十天的最高温度为4度，则这组彩条最右端代表 4 度。 近十天最低温为 -12 度，那么这组彩条最左端就代表 -12 度。左右两端的极值不是固定不变的。</li><li>小白点代表了此时的温度。</li></ul> 
<p>搞明白这个小彩条的含义就好说了，来自定义下这个控件吧！</p> 
<pre><code>@Composable
private fun TemperatureChart(min: Int, max: Int, currentMin: Int, 
                             currentMax: Int, currentTemperature: Int = -100) {
    val currentMinColor: Color = getTemperatureColor(currentMin)
    val currentMaxColor: Color = getTemperatureColor(currentMax)
    // 计算周温差
    val num = max - min
    Canvas {
        // 绘制底条
        drawLine(
            color = Color.Gray,
            start = Offset.Zero,
            end = Offset(size.width, 0f),
            strokeWidth = 10f,
            cap = StrokeCap.Round,
        )
        // 绘制这一天的气温
        drawLine(
            brush = Brush.linearGradient(
                0.0f to currentMinColor,
                1.0f to currentMaxColor,
            ),
            start = Offset(size.width / num * (currentMin - min), 0f),
            end = Offset(size.width / num * (currentMax - min), 0f),
            strokeWidth = 10f,
            cap = StrokeCap.Round,
        )
        // 如果是当天，则绘制当前温度小白点
        if (currentTemperature &gt; -100) {
            drawPoints(
                points = arrayListOf(
                    Offset(size.width / num * (currentTemperature - min), 0f)
                ),
                pointMode = PointMode.Points,
                color = Color.White,
                strokeWidth = 10f,
                cap = StrokeCap.Round,
            )
        }
    }
}

</code></pre> 
<p>首先看下这个可组合项接收的几个参数：</p> 
<ul><li><strong>min</strong>：未来几天最低温度</li><li><strong>max</strong>：未来几天最高温度</li><li><strong>currentMin</strong>：当前绘制天的最低温度</li><li><strong>currentMax</strong>：当前绘制天的最高温度</li><li><strong>currentTemperature</strong>：当前天的当前温度</li></ul> 
<p>再简单说下函数内容，先计算下这几天的温差，然后绘制温度底条，再然后绘制温度条，这个温度条是渐变的，需要根据不同温度换不同颜色，最后判断是不是当天，如果是当天的就绘制当前温度的小白点。</p> 
<p>上面调用一个函数 <code>getTemperatureColor</code> ，这是为了计算不同温度的颜色的方法，来看下这个方法吧：</p> 
<pre><code>/**
 * 获取不同气温的颜色值，需要动态判断
 */
private fun getTemperatureColor(temperature: Int): Color {
    return if (temperature &lt; -20) {
        Color(red = 26, green = 92, blue = 249)
    } else if (temperature &lt; 30) {
        Color(red = 253, green = 138, blue = 11)
    } else {
        Color(red = 248, green = 60, blue = 30)
    }
}

</code></pre> 
<p>这块没有写全这些颜色，其实写了挺多，篇幅原因就不写了，大家能理解就好。</p> 
<h3><a id="_835"></a>太阳月亮</h3> 
<p>顾名思义，太阳月亮就是指的日出日落和月出月落，还是再来看下实现好的样式吧：</p> 
<p><img src="https://images2.imgbox.com/70/ac/zCjHXsRG_o.png" alt="image.png"></p> 
<p>根据日出日落和月出月落的时间来展示当前太阳和月亮的状态。由上面图大概可以看出，需要使用到贝塞尔曲线，由于只是一段曲线，所以使用二阶贝塞尔曲线就可以了。</p> 
<p>什么是贝塞尔曲线呢？来看下百度百科的描述吧：</p> 
<blockquote> 
 <p>贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由<a href="https://link.juejin.cn/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E7%25BA%25BF%25E6%25AE%25B5%2F8679802%3FfromModule%3Dlemma_inlink" rel="nofollow" title="https://baike.baidu.com/item/%E7%BA%BF%E6%AE%B5/8679802?fromModule=lemma_inlink">线段</a>与<a href="https://link.juejin.cn/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E8%258A%2582%25E7%2582%25B9%2F865052%3FfromModule%3Dlemma_inlink" rel="nofollow" title="https://baike.baidu.com/item/%E8%8A%82%E7%82%B9/865052?fromModule=lemma_inlink">节点</a>组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量<a href="https://link.juejin.cn/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E6%259B%25B2%25E7%25BA%25BF%2F12004395%3FfromModule%3Dlemma_inlink" rel="nofollow" title="https://baike.baidu.com/item/%E6%9B%B2%E7%BA%BF/12004395?fromModule=lemma_inlink">曲线</a>的。</p> 
</blockquote> 
<p>下面来简单看下二阶贝塞尔曲线的简单动画吧：</p> 
<p><img src="https://images2.imgbox.com/f0/ef/m9RGp0W5_o.gif" alt="二阶贝塞尔曲线.gif"></p> 
<p>二阶贝塞尔曲线的公式如下：</p> 
<blockquote> 
 <p><em>B</em>(<em>t</em>)=(1−_t_)2_P_0+2_t_(1−_t_)_P_1+_t_2_P_2,_t_∈[0,1]</p> 
</blockquote> 
<p>下面来看下在 <code>Compose</code> 中如何绘制二阶贝塞尔曲线吧：</p> 
<pre><code>Canvas {
    val path = Path()
    path.moveTo(0f, size.height)
    // 二阶贝塞尔曲线
    path.quadraticBezierTo(
        size.width / 2, -size.height,
        size.width, size.height
    )
​
    drawPath(
        path = path, color = Color(red = 255, green = 193, blue = 7, alpha = 255),
        style = Stroke(width = 3f)
    )
}

</code></pre> 
<p>可以看到在 <code>Compose</code> 使用 <code>Path</code> 的 <code>quadraticBezierTo</code> 函数来绘制二阶贝塞尔曲线，这块需要解释下，二阶贝塞尔曲线一共需要三个点，但 <code>quadraticBezierTo</code> 函数中只接收了两个点，那剩下一个点呢？其实 <code>Path</code> 先 <code>moveTo</code> 到的点就是第一个点，<code>quadraticBezierTo</code> 函数接收的第一个点是控制点，第二个参数是终点。绘制完后贝塞尔曲线后还要绘制曲线两边的圆点：</p> 
<pre><code>drawPoints(
    points = arrayListOf(
        Offset(0f, size.height),
        Offset(size.width, size.height)
    ),
    pointMode = PointMode.Points,
    color = Color(red = 255, green = 193, blue = 7, alpha = 255),
    strokeWidth = 20f,
    cap = StrokeCap.Round,
)

</code></pre> 
<p>绘制完贝塞尔曲线和圆点之后就该绘制太阳和月亮图标了，这块需要使用贝塞尔曲线的公式来计算点的坐标了。绘制点之前需要计算当前时间占太阳或月亮在天上的百分比：</p> 
<pre><code>fun getAccounted(rise: String, set: String, isSun: Boolean = true): Double {
    val calendar = Calendar.getInstance()
    val currentMills = calendar.timeInMillis
    calendar.set(Calendar.HOUR_OF_DAY, getHour(rise))
    calendar.set(Calendar.MINUTE, getMinute(rise))
    val riseMills = calendar.timeInMillis
    if (!isSun) {
        calendar.set(Calendar.DAY_OF_MONTH, calendar.get(Calendar.DAY_OF_MONTH) + 1)
    }
    calendar.set(Calendar.HOUR_OF_DAY, getHour(set))
    calendar.set(Calendar.MINUTE, getMinute(set))
    val setMills = calendar.timeInMillis
    val result = (currentMills - riseMills) / (setMills - riseMills).toDouble()
    return if (currentMills &lt; riseMills) 0.0 else if (result &gt; 1) 1.0 else result
}

</code></pre> 
<p>这块的代码不多，使用 <code>Calendar</code> 来获取当前毫秒值存下来，然后设置日出日落的小时分钟并记录下来毫秒值，最后进行计算即可。</p> 
<p>现在百分比也有了，只剩下计算贝塞尔曲线上的坐标点了，先来看下计算坐标点的公式吧：</p> 
<pre><code>P0（起始点） ， P1（控制点）， P2 （终点）
P0（x1,y1）,P2(x2,y2), P1(cx,cy)
val x = Math.pow(1-t, 2) * x1 + 2 * t * (1-t) * cx + Math.pow(t, 2) * x2
val y = Math.pow(1-t, 2) * y1 + 2 * t * (1-t) * cy + Math.pow(t, 2) * y2

</code></pre> 
<p>公式是固定的，只需要往里套点即可：</p> 
<pre><code>val x = (1.0 - sunResult).pow(2.0) * 0f + 2 * sunResult * (1 - sunResult) * (size.width / 2) + sunResult.pow(2.0) * size.width
​
val y = (1.0 - sunResult).pow(2.0) * size.height + 2 * sunResult * (1 - sunResult) * (-size.height) + sunResult.pow(2.0) * size.height

</code></pre> 
<p>计算出来贝塞尔曲线中的点后就该绘制月亮或太阳的图标了：</p> 
<pre><code>drawImage(
    image = sunImage,
    topLeft = Offset(
        x - sunImage.width / 2,
        x - sunImage.height / 2
    )
)

</code></pre> 
<p>这块的图片需要 <code>ImageBitmap</code> 格式，直接使用上一篇文章中的 <code>useResource</code> 即可生成。<code>drawImage</code> 中的 <code>topLeft</code> 参数表示左上角的坐标，默认的话时（0，0），但图片有宽高，所以需要减去宽高的一半，这样太阳和月亮的图标才能显示在正中间。</p> 
<h3><a id="_949"></a>跳转浏览器</h3> 
<p>在安卓中咱们可以使用 <code>WebView</code> 来展示网页，但是在桌面版的应用中就没有了，需要使用系统自带的浏览器，那使用 <code>Compose Desktop</code> 应该如何打开系统自带的浏览器呢？可以使用 <code>Desktop</code> 中的 <code>browse</code> 方法，下面是我写的一个扩展函数：</p> 
<pre><code>/**
 * 通过字符串打开系统默认浏览器
 */
fun String?.openBrowse() {
    if (this?.startsWith("http") == false &amp;&amp; !this.startsWith("https")) {
        throw IllegalArgumentException("this illegal argument exception")
    }
    try {
        val uri = URI.create(this ?: "https://www.baidu.com")
        // 获取当前系统桌面
        val dp = Desktop.getDesktop()
        // 判断系统桌面是否支持要执行的功能
        if (dp.isSupported(Desktop.Action.BROWSE)) {
            // 获取系统默认浏览器打开链接
            dp.browse(uri)
        }
    } catch (e: Exception) {
        println(e.message)
    }
}

</code></pre> 
<p>首先判断当前字符串前缀是否为 “http” 和 “https”，如果不是的话就证明这个字符串不是网络链接，就直接抛出异常，剩下代码中的注释写的已经比较全了，就不多说了。</p> 
<p>函数有了再来看下如何调用吧：</p> 
<pre><code>Row {
    Image(painter = painterResource("image/ic_launcher.svg"), "", modifier = Modifier.size(15.dp))
​
    Spacer(modifier = Modifier.width(5.dp))
​
    Text(text = "数据来自和风天气", fontSize = 12.sp, modifier = Modifier.clickable {
        fxLink.openBrowse()
    })
}

</code></pre> 
<p>很简单，直接调用即可。运行效果就不在这里进行展示了，大家可以下载代码运行看看。</p> 
<h3><a id="_997"></a>对话框</h3> 
<p>在安卓中对话框的使用场景实在是太多了，就不一一列举了，随便打开一个应用里面都有一堆对话框，那么在 <code>Compose Desktop</code> 中该如何弹出对话框呢？先来看下 <code>Dialog</code> 的函数定义吧：</p> 
<pre><code>@Composable
fun Dialog(
    onCloseRequest: () -&gt; Unit,
    state: DialogState = rememberDialogState(),
    visible: Boolean = true,
    title: String = "Untitled",
    icon: Painter? = null,
    undecorated: Boolean = false,
    transparent: Boolean = false,
    resizable: Boolean = true,
    enabled: Boolean = true,
    focusable: Boolean = true,
    onPreviewKeyEvent: ((KeyEvent) -&gt; Boolean) = { false },
    onKeyEvent: ((KeyEvent) -&gt; Boolean) = { false },
    content: @Composable DialogWindowScope.() -&gt; Unit
)

</code></pre> 
<p>看到这些参数眼熟么？和上一篇文章中提到的 <code>Window</code> 基本一致，不同的就是这块的 <code>state</code> 为 <code>DialogState</code> ，接下来看下 <code>DialogState</code> 吧：</p> 
<pre><code>interface DialogState {
    var position: WindowPosition
​
    var size: DpSize
}

</code></pre> 
<p>可以看到通过定义 <code>DialogState</code> 可以定义对话框的位置和大小，大小可以直接通过 <code>DpSize</code> 设置，位置的话通过 <code>WindowPosition</code> 来设置，但 <code>WindowPosition</code> 可以通过绝对位置和相对位置来设置位置：</p> 
<pre><code>// 绝对位置，绝对坐标
fun WindowPosition(x: Dp, y: Dp) = WindowPosition.Absolute(x, y)
​
// 相对位置
fun WindowPosition(alignment: Alignment) = WindowPosition.Aligned(alignment)

</code></pre> 
<p>可以看到对话框也可以设置标题和图标，剩下的参数都见过，就不过多介绍了。</p> 
<p>来看看在 <code>Compose Desktop</code> 中如何使用对话框吧：</p> 
<pre><code>val alertDialog = rememberSaveable { mutableStateOf(false) }
Dialog(
    onCloseRequest = { alertDialog.value = false }, visible = alertDialog.value,
    state = rememberDialogState(size = DpSize(300.dp, 200.dp)),
    title = "Weather", icon = buildPainter("image/ic_launcher.svg")
) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.padding(top = 20.dp)
    ) {
        Text(
            text = title,
            fontSize = 16.sp,
            maxLines = 1,
            fontWeight = FontWeight.Bold,
            color = MaterialTheme.colors.onSecondary,
            modifier = Modifier.padding(horizontal = 20.dp)
        )
    }
}

</code></pre> 
<p>代码中设置了下对话框的大小，对话框使用方式和 <code>Jetpack Compose</code> 基本一致，看下运行效果吧：</p> 
<p><img src="https://images2.imgbox.com/4f/9c/ms7hBmUP_o.png" alt="image.png"></p> 
<p>可以看到对话框使用很简单，有需要的可以在 <code>Dialog</code> 中添加一些别的可组合项进行使用。</p> 
<h3><a id="_PopopWindow_1078"></a>桌面的 PopopWindow</h3> 
<p>在安卓中咱们经常使用的 <code>PopopWindow</code> 如何在 <code>Compose Desktop</code> 中使用呢？</p> 
<p><code>Compose</code> 中可以直接使用 <code>Popup</code> 来构建类似于安卓中 <code>PopupWindow</code> 的弹框，但我试着直接使用了下 <code>Popup</code> ，不太好控制弹出的地方，所以我就想着有没有能更简单控制弹出位置的方法，仔细找了下，果然有！可以使用 <code>CursorDropdownMenu</code> ，它可以将 <code>Popup</code> 在鼠标点击的地方弹出。</p> 
<pre><code>@Composable
fun CursorDropdownMenu(
    expanded: Boolean,
    onDismissRequest: () -&gt; Unit,
    focusable: Boolean = true,
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -&gt; Unit
) {
    ......
        Popup(
            focusable = focusable,
            onDismissRequest = onDismissRequest,
            popupPositionProvider = rememberCursorPositionProvider(),
            onKeyEvent = {
                handlePopupOnKeyEvent(it, onDismissRequest, focusManager!!, inputModeManager!!)
            },
        )
    ......
}

</code></pre> 
<p>上面就是 <code>CursorDropdownMenu</code> 进行了一些删减的源码，可以看到里面也调用了 <code>Popup</code> 。</p> 
<p>接下来看下使用方式吧：</p> 
<pre><code>var showPopupWindow by remember { mutableStateOf(false) }
​
CursorDropdownMenu(
    showPopupWindow,
    onDismissRequest = { showPopupWindow = false },
    modifier = modifier.width(300.dp).padding(horizontal = 15.dp).padding(bottom = 10.dp)
) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically,
    ) {
        Text(
            text = data.titleDetails,
            fontSize = 15.sp,
            fontWeight = FontWeight.Bold,
            color = MaterialTheme.colors.onSecondary
        )
        IconButton(onClick = { showPopupWindow = false }) {
            Icon(Icons.Sharp.Close, "Close")
        }
    }
}

</code></pre> 
<p>其实使用方法和对话框是类似的，都是通过定义一个是否展开的变量，然后通过这个变量来确定当前弹框是否显示。</p> 
<p>下面来看下运行效果：</p> 
<p><img src="https://images2.imgbox.com/74/c0/G6CJILfb_o.png" alt="image.png"></p> 
<p>可以看到还是挺好看的，哈哈哈！</p> 
<h3><a id="_1147"></a>系统菜单</h3> 
<p>在 Mac 中右上角会显示应用的菜单，如下图所示：</p> 
<p><img src="https://images2.imgbox.com/07/ab/THrVBdjf_o.png" alt="image.png"></p> 
<p>别的应用有，我们当然也想要！那咱们的 <code>Compose Desktop</code> 应该如何展示呢？</p> 
<p>放心，<code>Jetbrains</code> 都为我们想到了！来看看如何使用吧！</p> 
<pre><code>Window(onCloseRequest = ::exitApplication, title = "天青色等烟雨") {
    MenuBar {
        Menu("文件", mnemonic = 'F') {
            Item("复制（假的）", onClick = { action = "Last action: Copy" }, shortcut = KeyShortcut(Key.C, ctrl = true))
            Item("粘贴（假的）", onClick = { action = "Last action: Paste" }, shortcut = KeyShortcut(Key.V, ctrl = true))
        }
        Menu("帮助", mnemonic = 'H') {
            Item("天气帮助", onClick = { action = "Last action: Help" })
        }
    }
    App()
}

</code></pre> 
<p>直接使用 <code>MenuBar</code> 就可以展示类似于上方图片中的菜单了，需要注意的是 <code>MenuBar</code> 需要 <code>FrameWindowScope</code> ，上一篇文章中所说 <code>Window</code> 的 <code>content</code> 就是 <code>FrameWindowScope</code> ，所以可以进行使用，要直接拿出来就不行了，如果想拿出来的话需要添加一个扩展函数：</p> 
<pre><code>private fun FrameWindowScope.DemoMenu() {
    MenuBar {
        Menu("文件", mnemonic = 'F') {
            Item("复制（假的）", onClick = { action = "Last action: Copy" }, shortcut = KeyShortcut(Key.C, ctrl = true))
            Item("粘贴（假的）", onClick = { action = "Last action: Paste" }, shortcut = KeyShortcut(Key.V, ctrl = true))
        }
        Menu("帮助", mnemonic = 'H') {
            Item("天气帮助", onClick = { action = "Last action: Help" })
        }
    }
}

</code></pre> 
<p>简单说下吧，先来看下 <code>Menu</code> 吧：</p> 
<pre><code>@Composable
fun Menu(
    text: String,
    mnemonic: Char? = null,
    enabled: Boolean = true,
    content: @Composable MenuScope.() -&gt; Unit
)

</code></pre> 
<p>函数参数并不多，只有 <code>mnemonic</code> 不太好理解，它对应于键盘上某个键的字符，当这个键和 Alt 被按下时菜单将打开。然后需要重点看下 <code>content</code> ，它的参数类型为 <code>MenuScope</code> ，那就来看下 <code>MenuScope</code> 中都能添加什么可组合项吧！</p> 
<pre><code>class MenuScope internal constructor(private val impl: MenuScopeImpl) {
​
    @Composable
    fun Menu()
  
    @Composable
    fun Separator() = impl.Separator()
​
    @Composable
    fun Item()
​
    @Composable
    fun CheckboxItem()
​
    @Composable
    fun RadioButtonItem()
}

</code></pre> 
<p>可以看到，还能再添加 <code>Menu</code> ，剩下可添加的还有 <code>Item</code> 、<code>Separator</code> 、<code>CheckboxItem</code> 和 <code>RadioButtonItem</code> ，故名思义，分别是条目、分隔符、复选框和单选框。</p> 
<p>废话不多说，运行看下效果吧！</p> 
<p><img src="https://images2.imgbox.com/a7/74/hTmrx5JP_o.png" alt="image.png"></p> 
<p>大家在使用的时候可以根据需求选择需要使用的可组合项来组合系统菜单。</p> 
<h3><a id="_1235"></a>托盘及通知</h3> 
<p>托盘是什么呢？在 <code>Mac</code> 中右上角展示的就是托盘，如下图所示；<code>Windows</code> 中在右下角。</p> 
<p><img src="https://images2.imgbox.com/0f/b4/q7TJZI8O_o.png" alt="image.png"></p> 
<h4><a id="_1242"></a>托盘</h4> 
<p>同样的，<code>Jetbrains</code> 也为我们想到了，使用方法也不难，直接来看下吧：</p> 
<pre><code>Tray(
    state = rememberTrayState(),
    icon = painterResource("image/launcher.png"),
    menu = {
        Item(
            "天气预报",
            onClick = {}
        )
        Separator()
        Item(
            "退出",
            onClick = {}
        )
    }
)

</code></pre> 
<p>在 <code>Compose Desktop</code> 中使用 <code>Tray</code> 来为应用添加系统托盘，这里的 <code>Menu</code> 其实和上面系统菜单中的 <code>Menu</code> 是一回事，所以上面所描述的 <code>Item</code> 、<code>Separator</code> 、<code>CheckboxItem</code> 和 <code>RadioButtonItem</code> 都可以进行使用。</p> 
<p>下面来运行看下实际效果吧：</p> 
<p><img src="https://images2.imgbox.com/0c/10/7cA5Avif_o.png" alt="image.png"></p> 
<p>这块还有一个小知识点，咱们有时候使用的一些工具其实都没有真正页面，只是在系统托盘中存在，<code>Tray</code> 也可以在没有窗口的情况下创建托盘应用程序：</p> 
<pre><code>fun main() = application {
    Tray(
        icon = painterResource("image/launcher.png"),
        menu = {
            Item(
                "退出",
                onClick = ::exitApplication
            )
        }
    )
}

</code></pre> 
<p>这样就可以创建出一个没有窗口的程序了。</p> 
<h4><a id="_1290"></a>通知</h4> 
<p>咱们还可以使用系统托盘，也就是 <code>Tray</code> 向用户发送通知。一共有 3 种类型的通知：</p> 
<ol start="0"><li>notify - 简单的通知</li><li>warn - 警告通知</li><li>Error - 错误通知</li></ol> 
<p>下面来看下使用方法：</p> 
<pre><code>val trayState = rememberTrayState()
val infoNotification = rememberNotification("天气预报", "明天的天气很好，建议出门遛弯", Notification.Type.Info)
​
Tray(
    state = trayState,
    icon = painterResource("image/launcher.png"),
    menu = {
        Item(
            "天气预报",
            onClick = {
                trayState.sendNotification(infoNotification)
            }
        )
        Separator()
        Item(
            "退出",
            onClick = {
                isOpen.value = false
            }
        )
    }
)

</code></pre> 
<p>使用起来很简单，先使用 <code>rememberNotification</code> 来构建出一个 <code>Notification</code> ，然后直接使用 <code>trayState</code> 中的 <code>sendNotification</code> 进行发送通知即可。</p> 
<p>我录制了一个完整的显示系统菜单、托盘以及通知的 GIF ，大家来看下效果吧。</p> 
<p><img src="https://images2.imgbox.com/35/79/3s9AoFod_o.gif" alt="菜单及通知.gif"></p> 
<h2><a id="_1332"></a>打包</h2> 
<p>代码写好了，该弄的动画也弄了，该请求的网络数据也请求了，该实现的效果也都实现好了，但是！！！咱们得打包出来啊！不打包出来别人如何使用呢？难道说别人想用你开发的桌面应用，结果你给他说你先下载一个 <code>IntelliJ Idae</code> ，然后下载下我的源码，之后把环境配置好，最后运行就可以了！如果下次再想用的时候再运行一次就好了！</p> 
<p>这说的是人话嘛😂，肯定不能这样，所以一定要打包！由于 <code>Compose Desktop</code> 不止可以运行在 <code>Mac</code> 中，还可以运行在 <code>Windows</code> 和 <code>Linux</code> 中，所以需要打多个包。那使用 <code>Compose Desktop</code> 应该如何打包呢？且听我慢慢道来！</p> 
<h3><a id="_1339"></a>基本用法</h3> 
<p>插件中的基本配置单元是一个 <code>application</code> ，<code>application</code> 是什么呢？在第一篇文章中也提到了，就是在 <code>build.gradle.kts</code> 文件中的代码，咱们再来看下：</p> 
<pre><code>compose.desktop {
    application {
        mainClass = "MainKt"
        nativeDistributions {
            targetFormats(TargetFormat.Dmg, TargetFormat.Msi, TargetFormat.Deb)
            packageName = "Demo"
            packageVersion = "1.0.0"
        }
    }
}

</code></pre> 
<p>一个 <code>application</code> 定义了一组最终二进制文件的共享配置。换句话说，<code>application</code> DSL 允许将一堆文件连同 JDK 分发包打包成一组各种格式（<code>.dmg</code>、<code>.deb</code>、<code>.msi</code>、<code>.exe</code>等）的压缩二进制安装程序。</p> 
<p>该插件创建以下任务：</p> 
<ul><li><code>package&lt;FormatName&gt;</code>（例如 <code>packageDmg</code> 或 <code>packageMsi</code>）用于将应用程序打包成相应的格式。<strong>这块需要注意的是，目前没有交叉编译支持，因此只能使用特定操作系统构建格式（例如，要构建<code>.dmg</code> 就必须使用 macOS）。默认情况下会跳过与当前操作系统不兼容的任务。</strong></li><li><code>packageDistributionForCurrentOS</code> 是一个<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdocs.gradle.org%2Fcurrent%2Fuserguide%2Fmore_about_tasks.html%23sec%3Alifecycle_tasks" rel="nofollow" title="https://docs.gradle.org/current/userguide/more_about_tasks.html#sec:lifecycle_tasks">生命周期</a>任务，聚合了应用程序的所有包任务。</li><li><code>packageUberJarForCurrentOS</code>用于创建单个 jar 文件，其中包含当前操作系统的所有依赖项。</li><li><code>run</code> 用于在本地运行应用程序。需要定义一个 <code>mainClass</code> 包含该 <code>main</code> 函数的类。请注意， <code>run</code> 将启动具有完整运行时的非打包 JVM 应用程序。这比创建具有最小运行时间的紧凑二进制映像更快、更容易调试。要运行最终的二进制图像，需要改用 <code>runDistributable</code> 。</li><li><code>createDistributable</code>用于在不创建安装程序的情况下创建预打包的应用程序映像和最终应用程序映像。</li><li><code>runDistributable</code> 用于运行预先打包的应用程序映像。</li><li>只有在脚本中使用 <code>block</code> 或 <code>property</code> 时才会创建任务。</li></ul> 
<p>光这么说其实有点懵，来一张图大家就明白我说的是什么了！</p> 
<p><img src="https://images2.imgbox.com/e3/91/Ek9eTRGp_o.png" alt="image.png"></p> 
<p>是不是有点恍然大明白的感觉！直接点击 <code>IntelliJ IDEA</code> 右侧边栏的 <code>Gradle</code> ，就会出现这个侧边栏，然后点击 <code>Task</code> 中的 <code>compose desktop</code> 就会出现上面描述的那些任务。</p> 
<h3><a id="_1376"></a>打包配置</h3> 
<p><code>Compose Desktop</code> 打包有很多的配置项，下面来分别看下。</p> 
<h4><a id="_JDK__1381"></a>配置包含的 JDK 模块</h4> 
<p>Gradle 插件使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fopenjdk.java.net%2Fjeps%2F282" rel="nofollow" title="https://openjdk.java.net/jeps/282">jlink</a> 通过仅包含必要的 JDK 模块来最小化可分发的大小。</p> 
<p>此时，Gradle 插件不会自动确定必要的 JDK 模块。未能提供必要的模块不会导致编译问题，但会导致在运行时出现 <code>ClassNotFoundException</code> 的错误。</p> 
<p>如果在运行打包的应用程序或任务时遇到 <code>ClassNotFoundException</code> ，可以使用DSL 方法<code>runDistributable</code> 来配置包含额外的 JDK 模块，需要使用 <code>modules</code> 来配置。</p> 
<p>可以通过手动或运行 <code>suggestModules</code> 任务来确定哪些模块是必需的。<code>suggestModules</code> 使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2F9%2Ftools%2Fjdeps.htm" rel="nofollow" title="https://docs.oracle.com/javase/9/tools/jdeps.htm">jdeps</a> 静态分析工具来确定可能缺少的模块。</p> 
<p>如果安装包的大小不重要的话，可以使用 <code>includeAllModules</code>DSL 属性简单地包括所有运行时模块作为替代。</p> 
<pre><code>compose.desktop {
    application {
        nativeDistributions {
            modules("java.sql")
            // alternatively: includeAllModules = true
        }
    }
}

</code></pre> 
<p>这块在我打包的时候搜了好久！最后在 <code>Issue</code> 中找到了解决方案！</p> 
<h4><a id="_1407"></a>可用格式</h4> 
<p>以下格式可用于支持的操作系统：</p> 
<ul><li><strong>macOS</strong> — <code>.dmg</code> ( <code>TargetFormat.Dmg</code>)、 <code>.pkg</code>( <code>TargetFormat.Pkg</code>)</li><li><strong>Windows</strong> — <code>.exe</code> ( <code>TargetFormat.Exe</code>)、 <code>.msi</code>( <code>TargetFormat.Msi</code>)</li><li><strong>Linux</strong> — <code>.deb</code> ( <code>TargetFormat.Deb</code>)、 <code>.rpm</code>( <code>TargetFormat.Rpm</code>)</li></ul> 
<h4><a id="_1415"></a>指定包版本</h4> 
<p>由于可以打多种不同的包，也有可能需要区分不同的版本，所以可以指定包的版本。如何指定的呢？来看代码：</p> 
<pre><code>compose.desktop {
    application {
        nativeDistributions {
            packageVersion = "1.0.0" 
            
            linux {
              packageVersion = "1.0.0" 
              debPackageVersion = "1.0.0" 
              rpmPackageVersion = "1.0.0" 
            }
            macOS {
              packageVersion = "1.1.0"
              dmgPackageVersion = "1.1.0" 
              pkgPackageVersion = "1.1.0" 
              
              packageBuildVersion = "1.1.0"
              dmgPackageBuildVersion = "1.1.0" 
              pkgPackageBuildVersion = "1.1.0" 
            }
            windows {
              packageVersion = "1.2.0"  
              msiPackageVersion = "1.2.0"
              exePackageVersion = "1.2.0" 
            }
        }
    }
}

</code></pre> 
<p>必须为本机分发包指定包版本，还可以使用以下 DSL 属性（按优先级降序排列）：</p> 
<ul><li><code>nativeDistributions.&lt;os&gt;.&lt;packageFormat&gt;PackageVersion</code> 指定单个包格式的版本；</li><li><code>nativeDistributions.&lt;os&gt;.packageVersion</code> 指定单个目标操作系统的版本；</li><li><code>nativeDistributions.packageVersion</code> 指定所有包的版本；</li></ul> 
<p>对于 macOS，还可以使用以下 DSL 属性指定构建版本（按优先级降序排列）：</p> 
<ul><li><code>nativeDistributions.macOS.&lt;packageFormat&gt;PackageBuildVersion</code> 指定单一包格式的构建版本；</li><li><code>nativeDistributions.macOS.packageBuildVersion</code> 为所有 macOS 包指定构建版本。</li></ul> 
<p>需要注意的是，版本必须遵循以下规则：</p> 
<ul><li> <p><code>dmg</code> 和 <code>pkg</code> ：格式为 MAJOR.MINOR.PATCH</p> <p>其中：<code>MAJOR</code>是一个 &gt; 0 的整数；<code>MINOR</code>是一个可选的非负整数；<code>PATCH</code>是一个可选的非负整数；</p> </li><li> <p><code>msi</code> 和 <code>exe</code> ：格式为 MAJOR.MINOR.BUILD</p> <p>其中：<code>MAJOR</code>是一个非负整数，最大值为255；<code>MINOR</code>是一个非负整数，最大值为255；<code>BUILD</code>是一个非负整数，最大值为65535；</p> </li><li> <p><code>rpm</code> ：版本不得包含<code>-</code>（破折号）字符。</p> </li><li> <p><code>deb</code> ：格式为 EPOCH:UPSTREAM_VERSION-DEBIAN_REVISION</p> <p>其中：<code>EPOCH</code>是一个可选的非负整数；<code>UPSTREAM_VERSION</code> 只包含字母数字和字符<code>.</code>, <code>+</code>, <code>-</code>, <code>~</code>，必须以数字开头；<code>DEBIAN_REVISION</code>是可选的，可能只包含字母数字和字符<code>.</code>, <code>+</code>, <code>~</code>。</p> </li></ul> 
<h4><a id="_JDK__1478"></a>自定义 JDK 版本</h4> 
<p>由于该插件使用<code>jpackage</code>，所以最低得使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fopenjdk.java.net%2Fprojects%2Fjdk%2F15%2F" rel="nofollow" title="https://openjdk.java.net/projects/jdk/15/">JDK 15</a>。</p> 
<ul><li><code>JAVA_HOME</code> 环境变量指向兼容的 JDK 版本。</li><li><code>javaHome</code> 通过 DSL 设置：</li></ul> 
<pre><code>compose.desktop {
    application {
        javaHome = System.getenv("JDK_15")
    }
}

</code></pre> 
<h4><a id="_1494"></a>自定义输出目录</h4> 
<p><code>Compose Desktop</code> 默认的打包路径在 /build/compose/binaries/main/app 中，如果想修改下打包路径的话，需要修改下配置：</p> 
<pre><code>compose.desktop {
    application {
        nativeDistributions {
            outputBaseDir.set(project.buildDir.resolve("customOutputDir"))
        }
    }
}

</code></pre> 
<h4><a id="_1509"></a>自定义基本数据</h4> 
<p>DSL 块中提供以下属性 <code>nativeDistributions</code>：</p> 
<ul><li><code>packageName</code> — 应用程序名称（默认值：Gradle 项目<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdocs.gradle.org%2Fcurrent%2Fjavadoc%2Forg%2Fgradle%2Fapi%2FProject.html%23getName--" rel="nofollow" title="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#getName--">名称</a>）；</li><li><code>version</code> — 应用程序的版本（默认值：Gradle 项目的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdocs.gradle.org%2Fcurrent%2Fjavadoc%2Forg%2Fgradle%2Fapi%2FProject.html%23getVersion--" rel="nofollow" title="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#getVersion--">版本</a>）；</li><li><code>description</code> — 应用程序的描述（默认值：无）；</li><li><code>copyright</code> — 应用程序的版权（默认值：无）；</li><li><code>vendor</code> — 应用程序的供应商（默认值：无）；</li><li><code>licenseFile</code> — 应用程序的许可证（默认值：无）。</li></ul> 
<pre><code>compose.desktop {
    application {
        nativeDistributions {
            packageName = "PlayWeather"
            version = "1.1.0"
            description = "PlayWeather"
            copyright = "© 2022 My Name. All rights reserved."
            vendor = "Example vendor"
            licenseFile.set(project.file("LICENSE.txt"))
        }
    }
}

</code></pre> 
<p>这块大家可以根据需求来定义这些数据，如不需要不写即可。</p> 
<h4><a id="_1538"></a>特定平台选项</h4> 
<p>需要使用相应的 DSL 块设置特定于平台的选项，使用方法就是上面 <code>maxOS</code> 、<code>windows</code> 、<code>linux</code> ，不同平台可配置的选项都不太一样！</p> 
<ul><li> <p><strong>所有平台</strong></p> 
  <ul><li><code>iconFile.set(File("PATH_TO_ICON"))</code>— 应用程序特定于平台的图标的路径。</li><li><code>packageVersion = "1.0.0"</code> — 特定于平台的包版本。</li><li><code>installationPath = "PATH_TO_INSTALL_DIR"</code> 默认安装目录的绝对或相对路径；在 Windows 上<code>dirChooser = true</code>，可用于启用在安装过程中自定义路径。</li></ul> </li><li> <p><strong>Linux</strong></p> 
  <ul><li><code>packageName = "custom-package-name"</code> 覆盖默认的应用程序名称；</li><li><code>debMaintainer = "maintainer@example.com"</code> — deb 包维护者的电子邮件；</li><li><code>menuGroup = "my-example-menu-group"</code>— 应用程序的菜单组；</li><li><code>appRelease = "1"</code>— rpm 包的发布值，或 deb 包的修订值；</li><li><code>appCategory = "CATEGORY"</code> — rpm 包的组值，或 deb 包的部分值；</li><li><code>rpmLicenseType = "TYPE_OF_LICENSE"</code>— rpm 包的一种许可证；</li><li><code>debPackageVersion = "DEB_VERSION"``Specifying package version</code> — 特定于 deb 的包版本；</li><li><code>rpmPackageVersion = "RPM_VERSION"``Specifying package version</code>— 特定于 rpm 的软件包版本；</li></ul> </li><li> <p><strong>MacOS</strong></p> 
  <ul><li> <p>bundleID — 唯一的应用标识符；</p> 
    <ul><li>只能包含字母数字字符 ( <code>A-Z</code>, <code>a-z</code>, <code>0-9</code>)、连字符 ( <code>-</code>) 和句点 ( <code>.</code>) 字符；</li><li><code>com.mycompany.myapp</code>建议使用反向 DNS 表示法（例如）；</li></ul> </li><li> <p><code>packageName</code> — 应用名称；</p> </li><li> <p><code>dockName</code>— 显示在菜单栏、“关于”菜单项、停靠栏等中的应用程序名称。<code>packageName</code> 等于默认情况下的名称；</p> </li><li> <p><code>signing</code>, <code>notarization</code>, <code>provisioningProfile</code>, 和<code>runtimeProvisioningProfile</code>— 详见<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FJetBrains%2Fcompose-jb%2Fblob%2Fmaster%2Ftutorials%2FSigning_and_notarization_on_macOS%2FREADME.md" rel="nofollow" title="https://github.com/JetBrains/compose-jb/blob/master/tutorials/Signing_and_notarization_on_macOS/README.md">相应教程</a>；</p> </li><li> <p><code>appStore = true</code> — 为 Apple App Store 构建和签名。至少需要 JDK 17；</p> </li><li> <p><code>appCategory</code> — Apple App Store 的应用类别。默认值是 <code>public.app-category.utilities</code> ；</p> </li><li> <p><code>entitlementsFile.set(File("PATH_TO_ENTITLEMENTS"))</code> — 包含签名时使用的权利的文件路径；</p> </li><li> <p><code>runtimeEntitlementsFile.set(File("PATH_TO_RUNTIME_ENTITLEMENTS"))</code> — 包含在签署 JVM 运行时时使用的权利的文件路径；</p> </li><li> <p><code>dmgPackageVersion = "DMG_VERSION"</code> — 一个特定于 dmg 的包版本（详见参考资料部分）；</p> </li><li> <p><code>pkgPackageVersion = "PKG_VERSION"</code> — 特定于 pkg 的包版本（详情请参阅参考资料部分）；</p> </li><li> <p><code>packageBuildVersion = "DMG_VERSION"</code> — 包构建版本（详见参考资料部分）；</p> </li><li> <p><code>dmgPackageBuildVersion = "DMG_VERSION"</code>— 特定于 dmg 的软件包构建版本（详情请参阅参考资料部分）；</p> </li><li> <p><code>pkgPackageBuildVersion = "PKG_VERSION"</code> — 特定于 pkg 的包构建版本；</p> </li><li> <p><code>infoPlist</code> — 链接到别的程序。</p> </li></ul> </li><li> <p><strong>Linux</strong></p> 
  <ul><li><code>console = true</code>为应用程序添加一个控制台启动器；</li><li><code>dirChooser = true</code> 允许在安装过程中自定义安装路径；</li><li><code>perUserInstall = true</code>允许在每个用户的基础上安装应用程序</li><li><code>menuGroup = "start-menu-group"</code> 将应用程序添加到指定的开始菜单组；</li><li><code>upgradeUuid = "UUID"</code> — 一个唯一的 ID，当更新的版本比安装的版本更新时，它使用户能够通过安装程序更新应用程序。对于单个应用程序，该值必须保持不变；</li><li><code>msiPackageVersion = "MSI_VERSION"</code> — 特定于 msi 的软件包版本；</li><li><code>exePackageVersion = "EXE_VERSION"</code> — 特定于 pkg 的包版本</li></ul> </li></ul> 
<h3><a id="_1599"></a>修改应用图标</h3> 
<p>这块为什么要单独拿出一大块来说呢？因为这个问题中困扰了我好久。。。所以才。。。。</p> 
<p>还记得之前文章中说了 <code>Window</code> 可组合项中可以设定 <code>Icon</code> 么，但当时说的时候专门说了此 <code>Icon</code> 并非应用程序的图标！因为应用程序图标需要以特定于操作系统的格式提供：</p> 
<ul><li><code>.icns</code> 对于 macOS</li><li><code>.ico</code> 适用于 Windows</li><li><code>.png</code> 对于 Linux</li></ul> 
<p>看下代码吧：</p> 
<pre><code>compose.desktop {
    application {
        nativeDistributions {
            macOS {
                iconFile.set(project.file("icon.icns"))
            }
            windows {
                iconFile.set(project.file("icon.ico"))
            }
            linux {
                iconFile.set(project.file("icon.png"))
            }
        }
    }
}

</code></pre> 
<p><code>Linux</code> 中的 <code>png</code> 格式的图片我们很常见，但是 <code>Mac</code> 和 <code>Windows</code> 中的格式是什么鬼。。。没见过啊！</p> 
<p>如果知道这两种文件格式的话大家直接跳过后面的部分即可，这里还需要注意的是这里的文件路径指的是项目根目录。</p> 
<h4><a id="ICNS__1635"></a>ICNS 文件</h4> 
<ol start="0"><li>什么是 <code>.icns</code> ?</li></ol> 
<p><code>.icns</code> 是苹果的 macOS 操作系统的 App 图标文件的扩展名，大家在 macOS 的 <code>Desktop 桌面</code>、<code>Finder 访达</code>、<code>Dock 程序坞</code> 等看到应用程序的外观就是由一个内置在此 App 内部的扩展名为<code>.icns</code>的文件实现的。</p> 
<p>可以通过鼠标“右键”点击 App - “显示包内容” - 进入 <code>Contents</code> 目录 - 进入<code>Resources</code> 目录，然后在目录下可以找到名为 <code>Appicon.icns</code> 或其他后缀为 <code>.icns</code> 的一个图标文件。</p> 
<ol start="2"><li>如何创建 <code>.icns</code> 扩展名的图标文件?</li></ol> 
<p>a. 准备一张图片，重命名为 <code>icon.png</code>，其他大小尺寸可以通过终端命令生成；</p> 
<p>b. 通过鼠标右键或者命令，创建一个名为 <code>icons.iconset</code> 的文件夹</p> 
<pre><code>mkdir icons.iconset

</code></pre> 
<p>c. 通过”终端“来快速创建各种不同尺寸要求的图片文件</p> 
<pre><code>sips -z 512 512 icon.png -o icons.iconset/icon_512x512.png

</code></pre> 
<p>d. ”终端“中运行下面的命令，就可以获得名为<code>icon.icns</code>的图标文件了</p> 
<pre><code>iconutil -c icns icons.iconset -o icon.icns

</code></pre> 
<p><strong>注意：<code>icon.png</code> 图片文件和 <code>icons.iconset</code> 文件夹要保存在同一级目录下，”终端“启动后切换到相同目录。</strong></p> 
<h4><a id="ICO__1670"></a>ICO 文件</h4> 
<p><code>ico</code> 文件是 <code>Windows</code> 系统的应用图标格式，我也不会制作，但找到了一个制作 <code>ico</code> 的网站：</p> 
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.butterpig.top%2Ficopro%2F" rel="nofollow" title="https://www.butterpig.top/icopro/">www.butterpig.top/icopro/</a></p> 
<p>需要的话可以进去制作。</p> 
<h3><a id="_1678"></a>混淆</h3> 
<p>从 <code>Compose Desktop</code> 1.2 版本开始，<code>Compose Gradle</code> 插件支持开箱即用的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.guardsquare.com%2Fproguard" rel="nofollow" title="https://www.guardsquare.com/proguard">ProGuard</a>。<code>ProGuard</code> 是一个众所周知的用于缩小和混淆的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FGuardsquare%2Fproguard" rel="nofollow" title="https://github.com/Guardsquare/proguard">开源工具</a><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.guardsquare.com%2F" rel="nofollow" title="https://www.guardsquare.com/">Guardsquare</a>。</p> 
<p>Gradle插件为每个对应的默认打包任务提供了发布任务：</p> 
<table><thead><tr><th>默认任务（没有 ProGuard）</th><th>发布任务（带 ProGuard）</th><th>描述</th></tr></thead><tbody><tr><td><code>createDistributable</code></td><td><code>createReleaseDistributable</code></td><td>使用捆绑的 JDK 和资源创建应用程序映像</td></tr><tr><td><code>runDistributable</code></td><td><code>runReleaseDistributable</code></td><td>使用捆绑的 JDK 和资源运行应用程序映像</td></tr><tr><td><code>run</code></td><td><code>runRelease</code></td><td><code>jar</code>使用 Gradle JDK运行非打包应用程序</td></tr><tr><td><code>package&lt;FORMAT_NAME&gt;</code></td><td><code>packageRelease&lt;FORMAT_NAME&gt;</code></td><td>将应用程序映像打包到<code>&lt;FORMAT_NAME&gt;</code>文件中</td></tr><tr><td><code>packageForCurrentOS</code></td><td><code>packageReleaseForCurrentOS</code></td><td>将应用程序映像打包成与当前操作系统兼容的格式</td></tr><tr><td><code>notarize&lt;FORMAT_NAME&gt;</code></td><td><code>notarizeRelease&lt;FORMAT_NAME&gt;</code></td><td>上传<code>&lt;FORMAT_NAME&gt;</code>用于公证的应用程序图像（仅限 macOS）</td></tr><tr><td><code>checkNotarizationStatus</code></td><td><code>checkReleaseNotarizationStatus</code></td><td>检查公证是否成功（仅限 macOS）</td></tr></tbody></table> 
<p>默认配置添加了一些 ProGuard 规则：</p> 
<ul><li>缩小应用程序图像，即删除未使用的类；</li><li><code>compose.desktop.application.mainClass</code> 用作入口点；</li><li><code>keep</code> 避免破坏 <code>Compose</code> 运行时的一些规则。</li></ul> 
<p>在许多情况下，获得缩小的 <code>Compose</code> 应用程序不需要任何额外的配置。但是，有时 <code>ProGuard</code> 可能无法跟踪字节码中的某些用法（例如，如果通过反射使用类，则可能会发生这种情况）。如果遇到仅在 <code>ProGuard</code> 处理后才会发生的问题，可能需要添加自定义规则。为此，通过 DSL 指定配置文件：</p> 
<pre><code>compose.desktop {
    application {
        buildTypes.release.proguard {
            configurationFiles.from(project.file("compose-desktop.pro"))
        }
    }
}

</code></pre> 
<p>可以参考 Guardsquare 关于 ProGuard 规则和配置选项的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.guardsquare.com%2Fmanual%2Fconfiguration%2Fusage" rel="nofollow" title="https://www.guardsquare.com/manual/configuration/usage">综合手册</a>。</p> 
<p>默认情况下禁用混淆。要启用它，请通过 Gradle DSL 设置以下属性：</p> 
<pre><code>compose.desktop {
    application {
        buildTypes.release.proguard {
            obfuscate.set(true)
        }
    }
}

</code></pre> 
<p>混淆需要根据需要使用了，如果需要控制包体积的话尽量还是打开，可以减小包体积，还会减小代码泄漏的可能性；反之打不打开都行！</p> 
<h3><a id="_1731"></a>实际操作</h3> 
<p>上面都是理论知识，咱们得实操啊！有基础知识之后实操就很简单了，先来看下 <code>build.gradle.kts</code> 中的配置项吧：</p> 
<pre><code>compose.desktop {
    application {
        mainClass = "MainKt"
        nativeDistributions {
            targetFormats(TargetFormat.Dmg, TargetFormat.Exe, TargetFormat.Msi, TargetFormat.Deb)
            packageName = "PlayWeather"
            packageVersion = "1.0.0"
            description = "Play Weather App"
            copyright = "© 2022 My Name. All rights reserved."
            vendor = "Lenovo"
            licenseFile.set(project.file("LICENSE.txt"))
            modules("java.instrument", "java.management", "java.naming", "java.sql", "jdk.unsupported")
​
            linux {
                packageVersion = "1.0.0"
                debPackageVersion = "1.0.0"
                rpmPackageVersion = "1.0.0"
                // 设置图标
                iconFile.set(project.file("launcher/icon.png"))
            }
            macOS {
                packageVersion = "1.1.0"
                dmgPackageVersion = "1.1.0"
                pkgPackageVersion = "1.1.0"
                dockName = "PlayWeather"
​
                packageBuildVersion = "1.1.0"
                dmgPackageBuildVersion = "1.1.0"
                pkgPackageBuildVersion = "1.1.0"
                // 设置图标
                iconFile.set(project.file("launcher/icon.icns"))
            }
            windows {
                packageVersion = "1.2.0"
                msiPackageVersion = "1.2.0"
                exePackageVersion = "1.2.0"
                // 设置图标
                iconFile.set(project.file("launcher/icon.ico"))
            }
        }
        buildTypes.release.proguard {
            obfuscate.set(false)
            configurationFiles.from(project.file("proguard-rules.pro"))
        }
    }
}

</code></pre> 
<p>这里的配置项就不多说了，上面都有过介绍，下面来打包吧！</p> 
<p><img src="https://images2.imgbox.com/48/55/9LyL28pU_o.png" alt="image.png"></p> 
<p>点击上图中蓝色箭头标注的进行打包，上面说过了，不能跨系统打包，<code>Mac</code> 只能打 <code>Mac</code> 中使用的包。。双击执行 <code>packageDmg</code> 任务：</p> 
<p><img src="https://images2.imgbox.com/93/5c/2iKEqIFR_o.png" alt="image.png"></p> 
<p>没问题的话大概会出现上图的样子，由于没有配置自定义包路径，所以还在默认文件中，按照上面所描述的路径进行查看：</p> 
<p><img src="https://images2.imgbox.com/db/37/dMbjsyfS_o.png" alt="image.png"></p> 
<p>复制文件路径，在访达中打开：</p> 
<p><img src="https://images2.imgbox.com/79/37/7HhCNHIk_o.png" alt="image.png"></p> 
<p>双击进行安装即可：</p> 
<p><img src="https://images2.imgbox.com/06/41/5pldFzN8_o.png" alt="image.png"></p> 
<p>然后在资源库中找到应用双击打开应该会遇到下面的错误：</p> 
<p><img src="https://images2.imgbox.com/81/c2/pkUI0j7C_o.png" alt="image.png"></p> 
<p>这时点击取消，然后打开设置 -&gt; 隐私与安全性，往下滑：</p> 
<p><img src="https://images2.imgbox.com/d3/ed/VIJTzZCA_o.png" alt="image.png"></p> 
<p>点击箭头标注的“仍要打开”按钮，会让你输入电脑的密码，输入完成后会弹出下面的对话框：</p> 
<p><img src="https://images2.imgbox.com/b0/6b/0jj7OenU_o.png" alt="image.png"></p> 
<p>点击打开，这时应用就能正常使用了。</p> 
<p><img src="https://images2.imgbox.com/64/f2/qjmgCV5R_o.png" alt="image.png"></p> 
<p>苹果端就不打 <code>release</code> 包了，还需要苹果的开发者账号那一大堆。。。目前先能正常在 <code>Mac</code> 中运行吧！</p> 
<h2><a id="_1824"></a>总结</h2> 
<p>本文从一个新建的 <code>Compose Desktop</code> 项目开始，列举了一些大家在开发过程中可能遇到的一些问题，提前帮助大家踩了踩坑，文中所有代码都在 <code>Github</code> 中，包括文章开始放的这回要编写的天气应用。</p> 
<p><code>Github</code> 地址：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fzhujiang521%2FPlayWeather%2Ftree%2Fdesktop" rel="nofollow" title="https://github.com/zhujiang521/PlayWeather/tree/desktop">github.com/zhujiang521…</a></p> 
<p>如果文中写的有误，欢迎在评论区提出，咱们一起探讨。</p> 
<p>文章如果能帮助到大家，哪怕是一点，我也非常高兴，先这样。</p> 
<p><em><strong>本文正在参加<a href="https://juejin.cn/post/7162096952883019783" rel="nofollow" title="https://juejin.cn/post/7162096952883019783">「金石计划 . 瓜分6万现金大奖」</a></strong></em></p> 
<p>本文转自 <a href="https://juejin.cn/post/7176875120839884860" rel="nofollow">https://juejin.cn/post/7176875120839884860</a>，如有侵权，请联系删除。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04d697efcbee64b0e7e2609be586d25b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python--数据结构分析】海伦一直使用在线交友网站寻找适合的交友对象，为了方便分析，她将交友数据存放在datingTestSet.csv文件中。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f0be25e404a9adeb8527500e091d1e96/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">KY267 对称平方数1</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>