<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>bpftrace参考指南 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="bpftrace参考指南" />
<meta property="og:description" content="目录 前言一、名词解释二、使用示范1. help2. Hello World3. One-Liners程序4. 列出可跟踪点5. 调试输出-d6. 输出详情7. 预处理选项8. 环境变量9. 其它选项 三、语法1. 程序结构{...}2. 过滤/.../3. 注释//, /**/4. 常量5. c结构体访问：-&gt;6. 结构体定义: struct7. 三元操作符 ?::8. 条件语句 if () {..} else {..}9. 循环语句unroll10. 自增、自减&#43;&#43;、--11. 数组访问[]12. 整形强转13. while循环14. 提前结束:return15. 元组（ ，） 四、探针类型1. kprobe/kretprobe2. uprobe/uretprobe3. tracepoint4. usdt5. profile6. interval7. software8. hardware 五、变量1. 内置变量2. 基本变量: @、$3. 关联数组@[ ]5. 时间戳nsecs6. 内核栈kstack7. 用户栈追踪ustack8. 位置参数 六、函数1. 内置函数2. printf():格式化打印3. time():打印时间4. join():打印字符串数组5. str():打印字符串6. ksym()7. usym()8. kaddr()9. uaddr()10. reg()11. buf(void *d, int len)12." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/ae16360d4eb051863734e42018f3ccd3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-29T13:38:13+08:00" />
<meta property="article:modified_time" content="2022-03-29T13:38:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">bpftrace参考指南</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_7" rel="nofollow">前言</a></li><li><a href="#_13" rel="nofollow">一、名词解释</a></li><li><a href="#_26" rel="nofollow">二、使用示范</a></li><li><ul><li><a href="#1_help_27" rel="nofollow">1. help</a></li><li><a href="#2_Hello_World_46" rel="nofollow">2. Hello World</a></li><li><a href="#3_OneLiners_53" rel="nofollow">3. One-Liners程序</a></li><li><a href="#4__62" rel="nofollow">4. 列出可跟踪点</a></li><li><a href="#5_d_95" rel="nofollow">5. 调试输出-d</a></li><li><a href="#6__110" rel="nofollow">6. 输出详情</a></li><li><a href="#7__132" rel="nofollow">7. 预处理选项</a></li><li><a href="#8__147" rel="nofollow">8. 环境变量</a></li><li><a href="#9__167" rel="nofollow">9. 其它选项</a></li></ul> 
  </li><li><a href="#_186" rel="nofollow">三、语法</a></li><li><ul><li><a href="#1__187" rel="nofollow">1. 程序结构{...}</a></li><li><a href="#2__196" rel="nofollow">2. 过滤/.../</a></li><li><a href="#3___205" rel="nofollow">3. 注释//, /**/</a></li><li><a href="#4__212" rel="nofollow">4. 常量</a></li><li><a href="#5_c_219" rel="nofollow">5. c结构体访问：-&gt;</a></li><li><a href="#6__struct_244" rel="nofollow">6. 结构体定义: struct</a></li><li><a href="#7___254" rel="nofollow">7. 三元操作符 ?::</a></li><li><a href="#8__if___else__264" rel="nofollow">8. 条件语句 if () {..} else {..}</a></li><li><a href="#9_unroll_275" rel="nofollow">9. 循环语句unroll</a></li><li><a href="#10__286" rel="nofollow">10. 自增、自减++、--</a></li><li><a href="#11__305" rel="nofollow">11. 数组访问[]</a></li><li><a href="#12__307" rel="nofollow">12. 整形强转</a></li><li><a href="#13_while_316" rel="nofollow">13. while循环</a></li><li><a href="#14_return_321" rel="nofollow">14. 提前结束:return</a></li><li><a href="#15___323" rel="nofollow">15. 元组（ ，）</a></li></ul> 
  </li><li><a href="#_328" rel="nofollow">四、探针类型</a></li><li><ul><li><a href="#1_kprobekretprobe_329" rel="nofollow">1. kprobe/kretprobe</a></li><li><a href="#2_uprobeuretprobe_384" rel="nofollow">2. uprobe/uretprobe</a></li><li><a href="#3_tracepoint_438" rel="nofollow">3. tracepoint</a></li><li><a href="#4_usdt_464" rel="nofollow">4. usdt</a></li><li><a href="#5_profile_493" rel="nofollow">5. profile</a></li><li><a href="#6_interval_511" rel="nofollow">6. interval</a></li><li><a href="#7_software_530" rel="nofollow">7. software</a></li><li><a href="#8_hardware_557" rel="nofollow">8. hardware</a></li></ul> 
  </li><li><a href="#_584" rel="nofollow">五、变量</a></li><li><ul><li><a href="#1__585" rel="nofollow">1. 内置变量</a></li><li><a href="#2___606" rel="nofollow">2. 基本变量: @、$</a></li><li><a href="#3___648" rel="nofollow">3. 关联数组@[ ]</a></li><li><a href="#5_nsecs_665" rel="nofollow">5. 时间戳nsecs</a></li><li><a href="#6_kstack_667" rel="nofollow">6. 内核栈kstack</a></li><li><a href="#7_ustack_732" rel="nofollow">7. 用户栈追踪ustack</a></li><li><a href="#8__748" rel="nofollow">8. 位置参数</a></li></ul> 
  </li><li><a href="#_774" rel="nofollow">六、函数</a></li><li><ul><li><a href="#1__775" rel="nofollow">1. 内置函数</a></li><li><a href="#2_printf_803" rel="nofollow">2. printf():格式化打印</a></li><li><a href="#3_time_818" rel="nofollow">3. time():打印时间</a></li><li><a href="#4_join_826" rel="nofollow">4. join():打印字符串数组</a></li><li><a href="#5_str_833" rel="nofollow">5. str():打印字符串</a></li><li><a href="#6_ksym_844" rel="nofollow">6. ksym()</a></li><li><a href="#7_usym_851" rel="nofollow">7. usym()</a></li><li><a href="#8_kaddr_859" rel="nofollow">8. kaddr()</a></li><li><a href="#9_uaddr_866" rel="nofollow">9. uaddr()</a></li><li><a href="#10_reg_882" rel="nofollow">10. reg()</a></li><li><a href="#11_bufvoid_d_int_len_889" rel="nofollow">11. buf(void *d, int len)</a></li><li><a href="#12_system_905" rel="nofollow">12. system()</a></li><li><a href="#13_exit_920" rel="nofollow">13. exit()</a></li><li><a href="#14_cgroupid_927" rel="nofollow">14. cgroupid()</a></li><li><a href="#15_ntop_944" rel="nofollow">15. ntop()</a></li><li><a href="#16_kstack_960" rel="nofollow">16. kstack()</a></li><li><a href="#17_ustack_973" rel="nofollow">17. ustack()：</a></li><li><a href="#18_cat_975" rel="nofollow">18. cat():查看文件内容</a></li><li><a href="#19_signal_984" rel="nofollow">19. signal():向当前进程发送一个信号</a></li><li><a href="#20_strncmp_992" rel="nofollow">20. strncmp():字符串比较</a></li><li><a href="#21_override_1003" rel="nofollow">21. override():重写返回值</a></li><li><a href="#22_sizeof_1015" rel="nofollow">22. sizeof()</a></li><li><a href="#23_print_1037" rel="nofollow">23. print()</a></li><li><a href="#24_strftime_1047" rel="nofollow">24. strftime():格式化时间戳</a></li><li><a href="#25_path_1068" rel="nofollow">25. path():返回完整路径</a></li><li><a href="#26_uptr_1089" rel="nofollow">26. uptr():注解用户地址</a></li><li><a href="#27_kptr_1102" rel="nofollow">27. kptr():注解内核地址</a></li><li><a href="#28_macaddrmac_1108" rel="nofollow">28. macaddr():将mac地址转为文本</a></li><li><a href="#29_cgroup_pathcgroupid_1118" rel="nofollow">29. cgroup_path():将cgroupid转为路径</a></li></ul> 
  </li><li><a href="#_1129" rel="nofollow">七、映射表操作函数</a></li><li><ul><li><a href="#1__1130" rel="nofollow">1. 内置函数</a></li><li><a href="#2_count_1144" rel="nofollow">2. count()</a></li><li><a href="#3_sum_1166" rel="nofollow">3. sum()</a></li><li><a href="#4_avg_1185" rel="nofollow">4. avg()</a></li><li><a href="#5_min_1203" rel="nofollow">5. min()</a></li><li><a href="#6_max_1222" rel="nofollow">6. max()</a></li><li><a href="#7_stats_1237" rel="nofollow">7. stats()</a></li><li><a href="#8_hist_1255" rel="nofollow">8. hist()</a></li><li><a href="#9_lhist_1277" rel="nofollow">9. lhist()</a></li><li><a href="#10_print_1295" rel="nofollow">10. print()</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_7"></a>前言</h2> 
<p>本文主要介绍bpftrace的使用及语法规则，主要内容来自于官网的文档，以及使用过程中遇到的一些问题；本文将不涉及ebpf概念、框架介绍等。</p> 
<hr> 
<h2><a id="_13"></a>一、名词解释</h2> 
<table><thead><tr><th>术语</th><th>简介</th></tr></thead><tbody><tr><td>BPF</td><td>伯克利数据包过滤器：最初开发用于优化数据包过滤器处理的核心技术（例如，tcpdump表达式）</td></tr><tr><td>eBPF</td><td>增强型BPF：一种扩展BPF的内核技术，它可以在任何事件上执行更通用的程序，如bpftrace程序，eBPF通常被称为BPF</td></tr><tr><td>probe</td><td>软件或硬件中的一种插装点，用于生成可执行bpftrace程序的事件</td></tr><tr><td>tracepoints</td><td>内核用于提供静态插桩点的技术</td></tr><tr><td>kprobes</td><td>内核用于进行函数动态追踪的技术</td></tr><tr><td>uprobes</td><td>内核用于动态追踪用户态函数调用的技术</td></tr><tr><td>USDT</td><td>用户程序自己定义的静态插桩点(User Statically-Defined Tracing)</td></tr><tr><td>BPF map</td><td>BPF的内存对象，bpftrace用它来创建一些高级对象</td></tr><tr><td>BTF</td><td>BPF类型格式：对与BPF程序/映射相关的调试信息进行编码的元数据格式。</td></tr></tbody></table> 
<h2><a id="_26"></a>二、使用示范</h2> 
<h3><a id="1_help_27"></a>1. help</h3> 
<p>使用bpftrace命令行输出帮助信息(bpftrace或bpftrace --help)</p> 
<pre><code># bpftrace
USAGE:
    bpftrace [options] filename
    bpftrace [options] -e 'program'

OPTIONS:
    -B MODE        output buffering mode ('line', 'full', or 'none')
    -d             debug info dry run
    -dd            verbose debug info dry run
    -e 'program'   execute this program
    -h             show this help message
    -I DIR         add the specified DIR to the search path for include files.
    --include FILE adds an implicit #include which is read before the source file is preprocessed.
    -l [search]    list probes
    ...
</code></pre> 
<h3><a id="2_Hello_World_46"></a>2. Hello World</h3> 
<p>注: bpftrace的执行(bpf程序的注入)需要root用户。</p> 
<pre><code>#bpftrace -e 'BEGIN { printf("hello world!\n"); }'
Attaching 1 probe...
hello world!
</code></pre> 
<h3><a id="3_OneLiners_53"></a>3. One-Liners程序</h3> 
<p>使用-e选项指定一个程序，用于构造单行程序，类似awk语法，下例打印了进入睡眠状态的进程:</p> 
<pre><code># bpftrace -e 'tracepoint:syscalls:sys_enter_nanosleep { printf("%s enter sleeping\n", comm); }'
Attaching 1 probe...
GoImcore enter sleeping
GoImcore enter sleeping
GoImcore enter sleeping
</code></pre> 
<h3><a id="4__62"></a>4. 列出可跟踪点</h3> 
<p>使用<code>-l</code>选项列出当前可用追踪点</p> 
<pre><code># bpftrace -l | more
software:alignment-faults:
software:bpf-output:
software:context-switches:
</code></pre> 
<p>可使用通配符进行查询</p> 
<pre><code># bpftrace -l '*sys_enter*' | more
tracepoint:syscalls:sys_enter_socket
tracepoint:syscalls:sys_enter_socketpair
tracepoint:syscalls:sys_enter_bind
tracepoint:syscalls:sys_enter_listen
</code></pre> 
<p>使用<code>-v</code>选项可以列出tracepoint类型跟踪点的参数</p> 
<pre><code># bpftrace -lv tracepoint:syscalls:sys_enter_shmctl
tracepoint:syscalls:sys_enter_shmctl
    int __syscall_nr;
    int shmid;
    int cmd;
    struct shmid_ds * buf;
</code></pre> 
<p><code>如果BTF可用</code>(内核选项CONFIG_DEBUG_INFO_BTF=y，查看有无/sys/kernel/btf/vmlinux验证),也可以查看结构体的定义，如：</p> 
<pre><code># bpftrace -lv "struct path"
struct path {
        struct vfsmount *mnt;
        struct dentry *dentry;
};
</code></pre> 
<h3><a id="5_d_95"></a>5. 调试输出-d</h3> 
<p>可以使用<code>-d</code>选项调试bpftrace程序，此时程序不会运行，可以使用```-dd``获得更多调试信息：</p> 
<pre><code># bpftrace -d -e 'tracepoint:syscalls:sys_enter_nanosleep { printf("%s enter sleeping\n", comm); }'
#include &lt;linux/types.h&gt;

Program
 tracepoint:syscalls:sys_enter_nanosleep
  call: printf
   string: %s enter sleeping\n
   builtin: comm

; ModuleID = 'bpftrace'
source_filename = "bpftrace"
</code></pre> 
<h3><a id="6__110"></a>6. 输出详情</h3> 
<p>使用<code>-v</code>选项获得更多程序运行时的信息:</p> 
<pre><code># bpftrace -v -e 'tracepoint:syscalls:sys_enter_nanosleep { printf("%s enter sleeping\n", comm); }'
Attaching 1 probe...

Program ID: 85
Bytecode: 
0: (bf) r6 = r1
1: (b7) r1 = 0
2: (7b) *(u64 *)(r10 -40) = r1
last_idx 2 first_idx 0
regs=2 stack=0 before 1: (b7) r1 = 0
3: (7b) *(u64 *)(r10 -32) = r1
4: (7b) *(u64 *)(r10 -24) = r1
5: (7b) *(u64 *)(r10 -16) = r1
6: (7b) *(u64 *)(r10 -8) = r1
7: (bf) r1 = r10
8: (07) r1 += -16
9: (b7) r2 = 16
...
</code></pre> 
<h3><a id="7__132"></a>7. 预处理选项</h3> 
<p>使用 <code>-I</code>选项帮助bpftrace程序寻找头文件位置(与gcc相似)，使用<code>--include</code>选项包含头文件，可多次使用：</p> 
<pre><code>#bpftrace -I /tmp/include test.bt

# bpftrace -e 'kprobe:vfs_open { printf("open path: %s\n", str(((struct path *)arg0)-&gt;dentry-&gt;d_name.name)); }'
stdin:1:45-66: ERROR: Unknown struct/union: 'struct path'
kprobe:vfs_open { printf("open path: %s\n", str(((struct path *)arg0)-&gt;dentry-&gt;d_name.name)); }
# bpftrace --include linux/path.h --include linux/dcache.h \
  -e 'kprobe:vfs_open { printf("open path: %s\n", str(((struct path *)arg0)-&gt;dentry-&gt;d_name.name)); }'
Attaching 1 probe...
open path: /
open path: status
open path: status
</code></pre> 
<h3><a id="8__147"></a>8. 环境变量</h3> 
<p>使用示例：</p> 
<pre><code># BPFTRACE_MAP_KEYS_MAX=1024 bpftrace -e 'tracepoint:syscalls:sys_enter_execve { printf("%s", comm); join(args-&gt;argv); }'
Attaching 1 probe...
</code></pre> 
<ol><li>BPFTRACE_STRLEN<br> 默认值64，使用str()获取BPF stack分配的字符串时返回的长度，当前可以设置的最大值为200，支持更大字符长度的问题仍在讨论中。</li><li>BPFTRACE_NO_CPP_DEMANGLE<br> 默认为0，默认启用了用户空间堆栈跟踪中的C++符号还原功能，将此环境变量设置为1，可以关闭此功能。</li><li>BPFTRACE_MAP_KEYS_MAX<br> 单个map中存储的最大key数量，默认4096。</li><li>BPFTRACE_MAX_PROBES<br> bpftrace程序支持attach的钩子数量，默认512。</li><li>BPFTRACE_CACHE_USER_SYMBOLS<br> 默认情况下bpftrace缓存符号的解析结果，如果ASLR没有开启(Address Space Layout Randomization)，仅仅跟踪一个程序的时候，开启此选项可以获得性能上的提升。</li><li>BPFTRACE_BTF<br> BTF文件的路径，默认为None</li><li>BPFTRACE_MAX_BPF_PROGS<br> bpftrace可构造的最大BPF程序数量，默认值为512.</li></ol> 
<h3><a id="9__167"></a>9. 其它选项</h3> 
<ol><li>使用<code>--version</code>获取版本信息</li><li>使用<code>--no-warnings</code>关闭警告</li><li>使用<code>-f</code>选项指定输出信息格式，比如json</li></ol> 
<pre><code># bpftrace -f json -e 'tracepoint:syscalls:sys_enter_nanosleep { printf("%s enter sleeping\n", comm); }'
{"type": "attached_probes", "data": {"probes": 1}}
{"type": "printf", "data": "GoImcore enter sleeping\n"}
{"type": "printf", "data": "GoImcore enter sleeping\n"}
</code></pre> 
<ol start="4"><li>使用<code>-o</code>输出到文本</li></ol> 
<pre><code># bpftrace -f json -o ./sleep.json -e 'tracepoint:syscalls:sys_enter_nanosleep { printf("%s enter sleeping\n", comm); }'
^C
# cat sleep.json 
{"type": "attached_probes", "data": {"probes": 1}}
{"type": "printf", "data": "GoImcore enter sleeping\n"}
{"type": "printf", "data": "GoImcore enter sleeping\n"}
</code></pre> 
<h2><a id="_186"></a>三、语法</h2> 
<h3><a id="1__187"></a>1. 程序结构{…}</h3> 
<p>格式：<code>probe[, probe, ...] /filter/ { action }</code><br> 一个bpftrace程序可以有多个动作块，可使用过滤器。</p> 
<pre><code># bpftrace -e 'kprobe:do_sys_open { printf("opening: %s\n", str(arg1)); }'
Attaching 1 probe...
opening: /proc/1804/cmdline
...
</code></pre> 
<h3><a id="2__196"></a>2. 过滤/…/</h3> 
<p>格式: <code>/filter/</code><br> 在探针之后添加过滤器，探针<code>仍然会触发</code>，在满足过滤条件之后才会执行动作。</p> 
<pre><code># bpftrace -e 'kprobe:vfs_read /comm == "bash"/ { printf("read %d bytes\n", arg2); }'
Attaching 1 probe...
read 256 bytes
read 728 bytes
</code></pre> 
<h3><a id="3___205"></a>3. 注释//, /**/</h3> 
<pre><code>// single-line comment
/*
 * multi-line comment
 */
</code></pre> 
<h3><a id="4__212"></a>4. 常量</h3> 
<p>支持整数、字符和字符串常量：</p> 
<pre><code># bpftrace -e 'BEGIN { printf("%lu %lu %lu", 1000000, 1e6, 1_000_000)}'
Attaching 1 probe...
1000000 1000000 1000000
</code></pre> 
<h3><a id="5_c_219"></a>5. c结构体访问：-&gt;</h3> 
<pre><code># bpftrace -e 'tracepoint:syscalls:sys_enter_openat { printf("%s %s\n", comm, str(args-&gt;filename)); }'
Attaching 1 probe...
Xorg /proc/1996/cmdline
</code></pre> 
<p>tracepoint类型的跟踪点可使用<code>args</code>参数中访问<code>filename</code>成员，通过<code>args-&gt;</code>格式；如果是kprobe类型跟踪点，则访问示例如下:</p> 
<pre><code># cat path.bt
#!/usr/bin/bpftrace
#include &lt;linux/path.h&gt;
#include &lt;linux/dcache.h&gt;

kprobe:vfs_open
{
	printf("open path: %s\n", str(((struct path *)arg0)-&gt;dentry-&gt;d_name.name));
}

# bpftrace path.bt
Attaching 1 probe...
open path: dev
open path: if_inet6
open path: retrans_time_ms
</code></pre> 
<p>使用了动态跟踪点对内核函数vfs_open进行了追踪，为了访问path和dentry结构，需要包含一些内核头文件。</p> 
<h3><a id="6__struct_244"></a>6. 结构体定义: struct</h3> 
<pre><code>// from fs/namei.c:
struct nameidata {
        struct path     path;
        struct qstr     last;
        // [...]
};
</code></pre> 
<p>一些情况下，内核的头文件包中没有包含需要的结构体，你可以在bpftrace工具中手动定义结构体。</p> 
<h3><a id="7___254"></a>7. 三元操作符 ?::</h3> 
<p>语法同C语言，如下：</p> 
<pre><code># bpftrace -e 'tracepoint:syscalls:sys_exit_read { @error[args-&gt;ret &lt; 0 ? - args-&gt;ret : 0] = count(); }'
Attaching 1 probe...
^C

@error[11]: 51
@error[0]: 1744
</code></pre> 
<h3><a id="8__if___else__264"></a>8. 条件语句 if () {…} else {…}</h3> 
<p>bpftrace条件语句中目前仅支持if/else，暂不支持else if:</p> 
<pre><code># bpftrace -e 'tracepoint:syscalls:sys_enter_read { @read = count(); if (args-&gt;count &gt; 1024) { @large = count(); } }'
Attaching 1 probe...
^C

@large: 240

@read: 1206
</code></pre> 
<h3><a id="9_unroll_275"></a>9. 循环语句unroll</h3> 
<p>使用unroll()对语句进行循环执行</p> 
<pre><code># bpftrace -e 'kprobe:do_nanosleep { $i = 1; unroll(5) { printf("i:%d\n", $i); $i = $i + 1; } }'
Attaching 1 probe...
i:1
i:2
i:3
i:4
i:5
</code></pre> 
<h3><a id="10__286"></a>10. 自增、自减++、–</h3> 
<p><code>++</code>和<code>--</code>可以用于maps或者变量的自增/自减，需要注意的是maps没有定义的话值会被隐式的初始化为0。变量需要初始化之后才能使用这些操作符。</p> 
<pre><code># bpftrace -e 'BEGIN { $x = 0; $x++; printf("x:%d\n", $x); }'
Attaching 1 probe...
x:1
# bpftrace -e 'k:vfs_read { @++ }'
Attaching 1 probe...
^C
@: 633
</code></pre> 
<p>带关键词的map:</p> 
<pre><code># bpftrace -e 'k:vfs_read { @[probe]++ }'
Attaching 1 probe...
^C

@[kprobe:vfs_read]: 131
</code></pre> 
<h3><a id="11__305"></a>11. 数组访问[]</h3> 
<p>可以使用数组操作符<code>[]</code>访问一维常量数组；</p> 
<h3><a id="12__307"></a>12. 整形强转</h3> 
<p>整形内部为uint64,可以强制修改为以下内置类型：<br> (u)int8,(u)int16,(u)int32,(u)int64:</p> 
<pre><code># bpftrace -e 'BEGIN { $x = 1&lt;&lt;16; printf("%d %d\n", (uint16)$x, $x); }'
Attaching 1 probe...
0 65536
</code></pre> 
<h3><a id="13_while_316"></a>13. while循环</h3> 
<p><code>内核版本&gt;=5.3</code>，bpftrace支持while循环，循环可以使用<code>continue</code>和<code>break</code>来操作：</p> 
<pre><code># bpftrace -e 'i:ms:100 { $i = 0; while ($i &lt;= 100) { printf("%d ", $i); $i++} exit(); }'
</code></pre> 
<h3><a id="14_return_321"></a>14. 提前结束:return</h3> 
<p><code>return</code>关键字用于提前结束probe，而<code>exit()</code>则用于退出bpftrace(包含一个或多个probe)。</p> 
<h3><a id="15___323"></a>15. 元组（ ，）</h3> 
<p>使用<code>.</code>+index来访问元组，元组一经定义就不可以改变，同样也需要高版本内核支持：</p> 
<pre><code># bpftrace -e 'BEGIN { $t = (1, 2, "string"); printf("%d %s\n", $t.1, $t.2); }'
</code></pre> 
<h2><a id="_328"></a>四、探针类型</h2> 
<h3><a id="1_kprobekretprobe_329"></a>1. kprobe/kretprobe</h3> 
<p>语法：</p> 
<pre><code>kprobe:function_name[ + offset]
kretprobe:function_name
</code></pre> 
<p>使用了内核的kprobe能力(https://www.kernel.org/doc/Documentation/kprobes.txt)，在进入函数时触发kprobe，函数退出时触发kretprobe。<br> 示例：</p> 
<pre><code># bpftrace -e 'kprobe:do_nanosleep { printf("%s enter sleep\n", comm); }'
Attaching 1 probe...
dockerd enter sleep
</code></pre> 
<p>也可以在probe函数内部使用偏移量：</p> 
<pre><code># gdb -q /usr/lib/debug/boot/vmlinux-`uname -r` --ex 'disassemble do_sys_open'
Reading symbols from /usr/lib/debug/boot/vmlinux-5.0.0-32-generic...done.
Dump of assembler code for function do_sys_open:
   0xffffffff812b2ed0 &lt;+0&gt;:     callq  0xffffffff81c01820 &lt;__fentry__&gt;
   0xffffffff812b2ed5 &lt;+5&gt;:     push   %rbp
   0xffffffff812b2ed6 &lt;+6&gt;:     mov    %rsp,%rbp
   0xffffffff812b2ed9 &lt;+9&gt;:     push   %r15
...
# bpftrace -e 'kprobe:do_sys_open+9 { printf("in here\n"); }'
Attaching 1 probe...
in here
...
</code></pre> 
<p>如果地址与指令边界和函数内的地址一致，则使用vmlinux（带调试符号）检查地址;如果bpftrace编译的时候使用了<code>ALLOW_UNSAFE_PROBE</code>选项，可以使用–unsafe选项来跳过此检查。<br> 对于probe类型探针，可以使用<code>argN</code>(从0开始)的方式来访问探测点参数，对于retprobe则使用retval来获取返回值。</p> 
<pre><code># bpftrace -e 'kprobe:do_sys_open { printf("open flags: %d\n", arg2); }'
Attaching 1 probe...
open flags: 557056
open flags: 32768
[...]
# bpftrace -e 'kretprobe:do_sys_open { printf("returned: %d\n", retval); }'
Attaching 1 probe...
returned: 8
[...]
</code></pre> 
<p>对于结构体的访问如下:</p> 
<pre><code># cat path.bt 
#!/usr/bin/bpftrace

#include &lt;linux/path.h&gt;
#include &lt;linux/dcache.h&gt;

kprobe:vfs_open
{
	printf("open path: %s\n", str(((struct path *)arg0)-&gt;dentry-&gt;d_name.name));
}
</code></pre> 
<p>当内核支持BTF时，甚至不需要包含结构体的头文件。</p> 
<h3><a id="2_uprobeuretprobe_384"></a>2. uprobe/uretprobe</h3> 
<p>语法</p> 
<pre><code>uprobe:library_name:function_name[+offset]
uprobe:library_name:address
uretprobe:library_name:function_name
</code></pre> 
<p>使用了内核的uprobe特性，可以用objdump或者bpftrace -l来获取探测点。</p> 
<pre><code># objdump -tT /bin/bash | grep readline
0000000000139220 g    DO .bss	0000000000000008  Base        rl_readline_state
00000000000c0b20 g    DF .text	0000000000000352  Base        readline_internal_char
00000000000bfe90 g    DF .text	000000000000019c  Base        readline_internal_setup
000000000008bf40 g    DF .text	000000000000009a  Base        posix_readline_initialize
# # bpftrace -l 'u:/bin/bash' | grep readline
uprobe:/bin/bash:initialize_readline
uprobe:/bin/bash:pcomp_set_readline_variables
uprobe:/bin/bash:posix_readline_initialize
uprobe:/bin/bash:readline
</code></pre> 
<p>uprobe也可以使用虚拟地址作为探测点：</p> 
<pre><code># objdump -tT /bin/bash | grep main
000000000002fe90 g    DF .text	000000000000199e  Base        main
# bpftrace -e 'uprobe:/bin/bash:0x2fe90 { printf("main called!\n"); }'
Attaching 1 probe...
</code></pre> 
<p>也可以使用探测点加上偏移的方式：</p> 
<pre><code># objdump -d /root/test
[...]
0000000000401132 &lt;foo&gt;:
  401132:	55                   	push   %rbp
  401133:	48 89 e5             	mov    %rsp,%rbp
  401136:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  40113a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  40113e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
[...]
# bpftrace -e 'u:/root/test:foo+4 {printf("in here\n");}'
Attaching 1 probe...
in here
in here
</code></pre> 
<p>地址的对齐会通过指令边界进行检查，如果不对齐，将会probe将会添加失败,如果bpftrace编译时使用了ALLOW_UNSAFE_PROBE选项，也可以使用–unsafe选项来跳过此检查。</p> 
<pre><code># bpftrace -e 'uprobe:/bin/bash:main+1 { printf("in here\n"); }'
Attaching 1 probe...
Could not add uprobe into middle of instruction: /bin/bash:main+1
# bpftrace -e 'uprobe:/bin/bash:main+1 { printf("in here\n"); } --unsafe'
Attaching 1 probe...
Unsafe uprobe in the middle of the instruction: /bin/bash:main+1
</code></pre> 
<p>使用–unsafe选项，还可以在任意地址上放置uprobes。当二进制文件被strip时，这可能会派上用场。</p> 
<h3><a id="3_tracepoint_438"></a>3. tracepoint</h3> 
<p>使用了内核的静态探测点，对于参数的访问方式为<code>args-&gt;</code></p> 
<pre><code># bpftrace -e 'tracepoint:syscalls:sys_enter_openat { printf("%s %s\n", comm, str(args-&gt;filename)); }'
Attaching 1 probe...
vmware-vmx /proc/meminfo
</code></pre> 
<p>每个跟踪点可用的成员可以在/sys目录下进行查看：</p> 
<pre><code># cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_openat/format
name: sys_enter_openat
ID: 622
format:
        field:unsigned short common_type;       offset:0;       size:2; signed:0;
        field:unsigned char common_flags;       offset:2;       size:1; signed:0;
        field:unsigned char common_preempt_count;       offset:3;       size:1; signed:0;
        field:int common_pid;   offset:4;       size:4; signed:1;

        field:int __syscall_nr; offset:8;       size:4; signed:1;
        field:int dfd;  offset:16;      size:8; signed:0;
        field:const char * filename;    offset:24;      size:8; signed:0;
        field:int flags;        offset:32;      size:8; signed:0;
        field:umode_t mode;     offset:40;      size:8; signed:0;

print fmt: "dfd: 0x%08lx, filename: 0x%08lx, flags: 0x%08lx, mode: 0x%08lx", ((unsigned long)(REC-&gt;dfd)), ((unsigned long)(REC-&gt;filename)), ((unsigned long)(REC-&gt;flags)), ((unsigned long)(REC-&gt;mode))
</code></pre> 
<h3><a id="4_usdt_464"></a>4. usdt</h3> 
<p>USDT(user-level statically defined tracing)，提供了用户空间版的跟踪点机制，linux对USDT的支持，最早来自于SytemTap项目的跟踪器；给用户程序添加USDT探针，有两种可选方式：<br> 1）使用systemtap-sdt-dev包提供的头文件和工具<br> 2）使用Facebook的Folly C++库</p> 
<p>为应用程序添加USDT后，可使用bpftrace对跟踪点进行探测，语法：</p> 
<pre><code>usdt:binary_path:probe_name
usdt:binary_path:[probe_namespace]:probe_name
usdt:library_path:probe_name
usdt:library_path:[probe_namespace]:probe_name
</code></pre> 
<p>如果探测名称是唯一的，也可以省略探测命名空间：</p> 
<pre><code># bpftrace -e 'usdt:/root/tick:loop { printf("hi\n"); }'
Attaching 1 probe...
hi
hi
hi
</code></pre> 
<p>参数使用<code>argN</code>进行访问：</p> 
<pre><code># bpftrace -e 'usdt:/root/tick:loop /arg1 &gt; 2/ { printf("%s: %d\n", str(arg0), arg1); }'
my string: 3
my string: 4
my string: 5
my string: 6
^C
</code></pre> 
<h3><a id="5_profile_493"></a>5. profile</h3> 
<p>使用profile进行事件采样:</p> 
<pre><code>profile:hz:rate
profile:s:rate
profile:ms:rate
profile:us:rate
</code></pre> 
<p>profile使用了perf_events能力，如：</p> 
<pre><code># bpftrace -e 'profile:hz:99 { @[tid] = count(); }'
Attaching 1 probe...
^C

@[1280]: 1
@[866]: 1
@[58278]: 1
</code></pre> 
<h3><a id="6_interval_511"></a>6. interval</h3> 
<p>语法：</p> 
<pre><code>interval:ms:rate
interval:s:rate
interval:us:rate
interval:hz:rate

</code></pre> 
<p>这只在一个CPU上启动，并可用于生成每间隔的输出，如每秒输出系统调用的数量:</p> 
<pre><code># bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @syscalls = count(); } interval:s:1 { print(@syscalls); clear(@syscalls); }'
Attaching 2 probes...
@syscalls: 18141

@syscalls: 34272

@syscalls: 48646
</code></pre> 
<h3><a id="7_software_530"></a>7. software</h3> 
<p>语法：</p> 
<pre><code>software:event_name:count
software:event_name:
</code></pre> 
<p>这些是Linux内核提供的预定义软件事件，通常通过perf实用程序进行跟踪。它们类似于跟踪点，但只有十几个，记录在perf_event_open（2）手册页中。事件名称如下：</p> 
<ul><li><strong>cpu-clock</strong>或<strong>cpu</strong>：报告CPU时钟，per-cpu的高分辨率定时器</li><li><strong>task-clock</strong>：指定正在运行的任务的时钟计数</li><li><strong>page-faults or faults</strong>：报告触发缺页异常的次数</li><li><strong>context-switches or cs</strong>：上下文切换，被报告为在内核发生的用户空间事件</li><li><strong>cpu-migrations</strong>：报告进程迁移CPU的次数</li><li><strong>minor-faults</strong>：报告小缺页中断（触发pagefault时，vma对应的地址空间存在disk中）的次数，不会上报磁盘I/O的情况</li><li><strong>major-faults</strong>：报告大缺页中断（触发pagefault时，vma对应的地址空间已经被内核加载到了Page Cache中）的次数</li><li><strong>alignment-faults</strong>：报告对齐异常的数量，某些架构支持，当发生未对齐的内存访问时触发</li><li><strong>emulation-faults</strong>：统计方针异常的数量，内核有时会捕获未实现的指令，并在用户空间模拟它们</li><li><strong>dummy</strong>：一个不重要的占位事件，允许在不需要计数事件的情况下收集此类记录</li><li><strong>bpf-output</strong><br> 下例对每一百个缺页异常的进程名称进行采样：</li></ul> 
<pre><code># bpftrace -e 'software:faults:100 { @[comm] = count(); }'
Attaching 1 probe...
^C

@[QThread]: 1
@[ping]: 1
</code></pre> 
<h3><a id="8_hardware_557"></a>8. hardware</h3> 
<p>语法：</p> 
<pre><code>hardware:event_name:count
hardware:event_name:
</code></pre> 
<p>Linux内核提供的预定义硬件事件，通常由perf实用程序跟踪。它们是使用性能监视计数器（PMC）实现的：处理器上的硬件资源。记录在perf_event_open（2）手册页(https://man7.org/linux/man-pages/man2/perf_event_open.2.html)中，事件名称如下：</p> 
<ul><li><strong>cpu-cycles or cycles</strong></li><li><strong>instructions</strong></li><li><strong>cache-references</strong></li><li><strong>cache-misses</strong></li><li><strong>branch-instructions or branches</strong></li><li><strong>branch-misses</strong></li><li><strong>bus-cycles</strong></li><li><strong>frontend-stalls</strong></li><li><strong>backend-stalls</strong></li><li><strong>ref-cycles</strong><br> 计数是探测器的触发器，它将为每个计数事件触发一次。如果未提供计数，则使用默认值。</li></ul> 
<pre><code># bpftrace -e 'hardware:cache-misses:1000000 { @[pid] = count(); }'
Attaching 1 probe...
^C

@[7679]: 1
@[2662]: 1
@[400842]: 1
</code></pre> 
<h2><a id="_584"></a>五、变量</h2> 
<h3><a id="1__585"></a>1. 内置变量</h3> 
<ul><li><strong>pid</strong> - 进程号(kernel tgid)</li><li><strong>tid</strong> - 线程号 (kernel pid)</li><li><strong>uid</strong> - 用户ID</li><li><strong>gid</strong> - 组ID</li><li><strong>nsecs</strong> - 纳秒时间戳</li><li><strong>elapsed</strong> - 自bpftrace初始化流逝的纳秒数</li><li><strong>cpu</strong> - 处理器编号</li><li><strong>comm</strong> - 进程名称</li><li><strong>kstack</strong> - 内核栈回溯</li><li><strong>ustack</strong> - 用户栈回溯</li><li><strong>arg0, arg1, …, argN</strong>. - 跟踪函数的参数</li><li><strong>sarg0, sarg1, …, sargN</strong>. - 跟踪函数的参数 (for programs that store arguments on the stack); assumed to be 64 bits wide</li><li><strong>retval</strong> - 被跟踪函数的返回值</li><li><strong>func</strong> - 被跟踪函数的名称</li><li><strong>probe</strong> - 跟踪点全名</li><li><strong>curtask</strong> - 当前的task_struct（u64）</li><li><strong>rand</strong> - 随机数(u32)</li><li><strong>cgroup</strong> - 当前进程的cgroup ID</li><li><strong>cpid</strong> - Child pid(u32)，仅<code>-c command</code>使用时有效</li><li><strong>$1, $2, …, $N, $#</strong>. bpftrace程序的入参变量</li></ul> 
<h3><a id="2___606"></a>2. 基本变量: @、$</h3> 
<pre><code>@全局变量
@线程局部变量[tid]
$临时变量
</code></pre> 
<p>2.1 全局变量</p> 
<pre><code># bpftrace -e 'BEGIN { @start = nsecs; }
    kprobe:do_nanosleep /@start != 0/ { printf("at %d ms: sleep\n", (nsecs - @start) / 1000000); }'
Attaching 2 probes...
at 42 ms: sleep
at 43 ms: sleep
at 314 ms: sleep
^C

@start: 601563424957305
</code></pre> 
<p>2.2 线程局部变量</p> 
<pre><code># bpftrace -e 'kprobe:do_nanosleep { @start[tid] = nsecs; }
    kretprobe:do_nanosleep /@start[tid] != 0/ {
        printf("slept for %d ms\n", (nsecs - @start[tid]) / 1000000); delete(@start[tid]); }'
Attaching 2 probes...
slept for 1000 ms
slept for 1000 ms
slept for 1000 ms
slept for 1009 ms
slept for 2002 ms
[...]
</code></pre> 
<p>2.3 临时变量<br> 如$delta</p> 
<pre><code># bpftrace -e 'kprobe:do_nanosleep { @start[tid] = nsecs; }
    kretprobe:do_nanosleep /@start[tid] != 0/ { $delta = nsecs - @start[tid];
        printf("slept for %d ms\n", $delta / 1000000); delete(@start[tid]); }'
Attaching 2 probes...
slept for 1000 ms
slept for 1000 ms
slept for 1000 ms
</code></pre> 
<h3><a id="3___648"></a>3. 关联数组@[ ]</h3> 
<p>语法：</p> 
<pre><code>@关联数组名[key_name] = value
@关联数组名[key_name, key_name2, ...] = value
</code></pre> 
<p>都是使用bpf map实现的，如@start[tid]</p> 
<pre><code># bpftrace -e 'kprobe:do_nanosleep { @start[tid] = nsecs; }
    kretprobe:do_nanosleep /@start[tid] != 0/ {
        printf("slept for %d ms\n", (nsecs - @start[tid]) / 1000000); delete(@start[tid]); }'
Attaching 2 probes...
slept for 1000 ms
slept for 1000 ms
slept for 1000 ms
[...]
</code></pre> 
<h3><a id="5_nsecs_665"></a>5. 时间戳nsecs</h3> 
<p>通过 bpf_ktime_get_ns()实现，如上例</p> 
<h3><a id="6_kstack_667"></a>6. 内核栈kstack</h3> 
<p>也可通过kstack()使用：</p> 
<pre><code># bpftrace -e 'kprobe:ip_output { @[kstack] = count(); }'
Attaching 1 probe...
^C

@[
    ip_output+1
    __ip_queue_xmit+378
    ip_queue_xmit+16
    __tcp_transmit_skb+1335
    __tcp_send_ack.part.0+203
    tcp_send_ack+28
    __tcp_ack_snd_check+60
    tcp_rcv_established+1426
    tcp_v4_do_rcv+320
    tcp_v4_rcv+3063
    ip_protocol_deliver_rcu+48
    ip_local_deliver_finish+72
    ip_local_deliver+115
    ip_rcv_finish+133
    ip_rcv+188
    __netif_receive_skb_one_core+135
    __netif_receive_skb+24
    netif_receive_skb_internal+69
    napi_gro_receive+255
    e1000_receive_skb+207
    e1000_clean_rx_irq+523
    e1000e_poll+122
    net_rx_action+314
    __softirqentry_text_start+225
    irq_exit+174
    do_IRQ+90
    ret_from_intr+0
    cpuidle_enter_state+197
    cpuidle_enter+46
    call_cpuidle+35
    do_idle+477
    cpu_startup_entry+32
    start_secondary+359
    secondary_startup_64+164
]: 1
@[
    ip_output+1
    __ip_queue_xmit+378
    ip_queue_xmit+16
    __tcp_transmit_skb+1335
    tcp_write_xmit+962
    __tcp_push_pending_frames+55
    tcp_push+253
    tcp_sendmsg_locked+3189
    tcp_sendmsg+45
    inet_sendmsg+67
    sock_sendmsg+94
    sock_write_iter+147
    new_sync_write+293
    __vfs_write+41
    vfs_write+185
    ksys_write+103
    __x64_sys_write+26
    do_syscall_64+87
    entry_SYSCALL_64_after_hwframe+68
]: 2
</code></pre> 
<h3><a id="7_ustack_732"></a>7. 用户栈追踪ustack</h3> 
<p>也可通过ustack（）使用：</p> 
<pre><code># bpftrace -e 'kprobe:do_sys_open { @[ustack] = count(); }'
Attaching 1 probe...
^C

@[
    __open64+212
    0x75746174732f3535
]: 1
@[
    __open64+212
    0x75746174732f3331
]: 1
</code></pre> 
<h3><a id="8__748"></a>8. 位置参数</h3> 
<p>格式: <code>$1,$2,...,$N,$#</code></p> 
<ul><li>bpftrace程序的位置参数，也称为命令行参数。如果参数（完全）是数字，则可以将其用作数字。否则必须在str（）调用中用作字符串。如果使用了未提供的参数，则数字上下文默认为零，字符串上下文默认为“”。位置参数也可以在探测参数中使用，并将被视为字符串参数。</li><li>如果在str（）中使用位置参数，它将被解释为指向实际给定字符串文字的指针，从而允许对其执行指针算术。只允许添加一个小于或等于所提供字符串长度的常数</li><li>这允许编写使用基本参数来更改其行为的脚本。如果开发的脚本需要更复杂的参数处理，那么它可能更适合bcc，bcc支持Python的argparse和完全自定义的参数处理。<br> 在一行程序中使用位置参数：</li></ul> 
<pre><code># bpftrace -e 'BEGIN { printf("I got %d, %s (%d args)\n", $1, str($2), $#); }' 42 "hello"
Attaching 1 probe...
I got 42, hello (2 args)
</code></pre> 
<p>在脚本中使用：</p> 
<pre><code>#!/usr/local/bin/bpftrace

BEGIN
{
	printf("Tracing block I/O sizes &gt; %d bytes\n", $1);
}

tracepoint:block:block_rq_issue
/args-&gt;bytes &gt; $1/
{
	@ = hist(args-&gt;bytes);
}
</code></pre> 
<h2><a id="_774"></a>六、函数</h2> 
<h3><a id="1__775"></a>1. 内置函数</h3> 
<ul><li><strong>printf(char *fmt, …)</strong> - 格式化打印</li><li><strong>time(char *fmt)</strong> - 格式化打印时间</li><li><strong>join(char *arr[] [, char *delim])</strong> - 打印字符串数组</li><li><strong>str(char *s [, int length])</strong> - 返回指向s的字符串指针</li><li><strong>ksym(void *p)</strong> - 解析内核地址</li><li><strong>usym(void *p)</strong>- 解析用户空间地址</li><li><strong>kaddr(char *name)</strong> - 解析内核符号</li><li><strong>uaddr(char *name)</strong> - 解析用户空间符号</li><li><strong>reg(char *name)</strong> - 返回存储在指定寄存器上的值</li><li><strong>system(char *fmt)</strong> - 执行系统命令</li><li><strong>exit()</strong> - 退出bpftrace</li><li><strong>cgroupid(char *path)</strong> - 解析cgroupID</li><li><strong>kstack([StackMode mode, ][int level])</strong> - 内核栈回溯</li><li><strong>ustack([StackMode mode, ][int level])</strong> - 用户栈回溯</li><li><strong>ntop([int af, ]int|char[4|16] addr)</strong> - 将ip地址转换为文本</li><li><strong>cat(char *filename)</strong> - 打印文件内容</li><li><strong>signal(char[] signal | u32 signal)</strong> - 给当前进程发送信号</li><li><strong>strncmp(char *s1, char *s2, int length)</strong> - 比较两个字符串的前n个字节</li><li><strong>override(u64 rc)</strong> - 重写返回值</li><li><strong>buf(void *d [, int length])</strong> - 返回d指向的16进制内容</li><li><strong>sizeof(…)</strong> - 返回一个类型或语句的尺寸Return size of a type or expression</li><li><strong>print(…)</strong> - 使用默认格式打印一个非map的值</li><li><strong>strftime(char *format, int nsecs)</strong> - 返回格式化的时间戳</li><li><strong>path(struct path *path)</strong> - 返回完整路径</li><li><strong>uptr(void *p)</strong> - 注释为用户空间指针</li><li><strong>kptr(void *p)</strong> - 注释为内核空间指针</li><li><strong>macaddr(char[6] addr)</strong> - 转换mac地址</li></ul> 
<h3><a id="2_printf_803"></a>2. printf():格式化打印</h3> 
<p>类似于C风格的打印函数：</p> 
<pre><code># bpftrace -e 'tracepoint:syscalls:sys_enter_execve { printf("%s called %s\n", comm, str(args-&gt;filename)); }'
Attaching 1 probe...
bash called /bin/ls
bash called /usr/bin/man
man called /apps/nflx-bash-utils/bin/preconv
man called /usr/local/sbin/preconv
man called /usr/local/bin/preconv
man called /usr/sbin/preconv
man called /usr/bin/preconv
man called /apps/nflx-bash-utils/bin/tbl
[...]
</code></pre> 
<h3><a id="3_time_818"></a>3. time():打印时间</h3> 
<p>使用指定格式打印时间，需要libc <code>strftime(3)</code>支持。<br> <mark>需要注意的是此时间打印的是用户空间程序处理时间队列的时间，而不是bpf程序调用时的时间</mark></p> 
<pre><code># bpftrace -e 'kprobe:do_nanosleep { time("%H:%M:%S\n"); }'
07:11:03
07:11:09
</code></pre> 
<h3><a id="4_join_826"></a>4. join():打印字符串数组</h3> 
<p>join()会将字符串数组与一个空格字符连接起来，并将其打印出来，以分隔符分隔。默认的分隔符（如果没有提供）是空格字符。当前版本不返回字符串，因此不能在printf（）中用作参数。</p> 
<pre><code># bpftrace -e 'tracepoint:syscalls:sys_enter_execve { join(args-&gt;argv); }'
Attaching 1 probe...
ls --color=auto
</code></pre> 
<h3><a id="5_str_833"></a>5. str():打印字符串</h3> 
<pre><code>str(char *s, [int length])
</code></pre> 
<p>返回字符串指针，length参数可选，用于限制s的长度；字符串默认长度为64，可使用<code>BPFTRACE_STRLEN</code>环境变量进行更改；</p> 
<pre><code># bpftrace -e 'tracepoint:syscalls:sys_enter_execve { printf("%s called %s\n", comm, str(args-&gt;filename)); }'
Attaching 1 probe...
bash called /bin/ls
bash called /usr/bin/man
</code></pre> 
<h3><a id="6_ksym_844"></a>6. ksym()</h3> 
<pre><code>bpftrace -e 'kprobe:do_nanosleep { printf("%s\n", ksym(reg("ip"))); }'
Attaching 1 probe...
do_nanosleep
do_nanosleep
</code></pre> 
<h3><a id="7_usym_851"></a>7. usym()</h3> 
<pre><code># bpftrace -e 'uprobe:/bin/bash:readline { printf("%s\n", usym(reg("ip"))); }'
Attaching 1 probe...
readline
readline
readline
</code></pre> 
<h3><a id="8_kaddr_859"></a>8. kaddr()</h3> 
<p>格式: <code>kaddr(const char *name)</code></p> 
<pre><code>bpftrace -e 'BEGIN { printf("%s\n", str(*kaddr("usbcore_name"))); }'
Attaching 1 probe...
usbcore
</code></pre> 
<h3><a id="9_uaddr_866"></a>9. uaddr()</h3> 
<p>uaddr函数返回指定符号的地址，在程序编译期间查找符号，不能动态使用。<br> 格式：</p> 
<ul><li>u64 *uaddr(符号名) (默认)</li><li>u64 *uaddr(符号名)</li><li>u32 *uaddr(符号名)</li><li>u16 *uaddr(符号名)</li><li>u8 *uaddr(符号名)<br> 支持的探针类型：u(ret)probe、USDT</li></ul> 
<pre><code># bpftrace -e 'uprobe:/bin/bash:readline { printf("PS1: %s\n", str(*uaddr("ps1_prompt"))); }'
Attaching 1 probe...
PS1: \[\e[34;1m\]\u@\h:\w&gt;\[\e[0m\]
PS1: \[\e[34;1m\]\u@\h:\w&gt;\[\e[0m\]
^C
</code></pre> 
<h3><a id="10_reg_882"></a>10. reg()</h3> 
<pre><code># bpftrace -e 'kprobe:tcp_sendmsg { @[ksym(reg("ip"))] = count(); }'
Attaching 1 probe...
^C
@[tcp_sendmsg]: 8
</code></pre> 
<h3><a id="11_bufvoid_d_int_len_889"></a>11. buf(void *d, int len)</h3> 
<p>返回一个十六进制字符串，由于缓冲区长度不可预测，因此总是需要长度参数来限制读取的字节数。默认最大读取字节数为64，也可使用BPFTRACE_STRLEN环境变量进行调整；<br> 如果字节数在[32, 126]之间，使用他们的ASCII字符进行输出，其余的字节使用16进制(如<code>\x00</code>)。</p> 
<pre><code># bpftrace -e 'tracepoint:syscalls:sys_enter_sendto
    { printf("Datagram bytes: %r\n", buf(args-&gt;buff, args-&gt;len)); }' -c 'ping 8.8.8.8 -c1'
Attaching 1 probe...
PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
Datagram bytes: \x08\x00+\xb9\x06b\x00\x01Aen^\x00\x00\x00\x00KM\x0c\x00\x00\x00\x00\x00\x10\x11
\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !"#$%&amp;'()*+,-./01234567
64 bytes from 8.8.8.8: icmp_seq=1 ttl=52 time=19.4 ms

--- 8.8.8.8 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 19.426/19.426/19.426/0.000 ms
</code></pre> 
<h3><a id="12_system_905"></a>12. system()</h3> 
<p>让bpftrace执行一个系统命令，此行为不安全，因此使用时需要指定<code>--unsafe</code>选项:</p> 
<pre><code># bpftrace --unsafe -e 'kprobe:do_nanosleep { system("ps -p %d\n", pid); }'
Attaching 1 probe...
  PID TTY          TIME CMD
 1339 ?        00:00:15 iscsid
  PID TTY          TIME CMD
 1339 ?        00:00:15 iscsid
  PID TTY          TIME CMD
 1518 ?        00:01:07 irqbalance
  PID TTY          TIME CMD
 1339 ?        00:00:15 iscsid
^C
</code></pre> 
<h3><a id="13_exit_920"></a>13. exit()</h3> 
<p>退出bpftrace，可以与interval间隔探针相结合，以记录特定持续时间内的统计信息：</p> 
<pre><code># bpftrace -e 'kprobe:do_sys_open { @opens=count(); } interval:s:1 { exit(); }'
Attaching 2 probes...
@opens: 46
</code></pre> 
<h3><a id="14_cgroupid_927"></a>14. cgroupid()</h3> 
<p>返回特定cgroup的cgroup ID，可与cgroup内置项组合，以过滤属于特定cgroup的任务，例如：</p> 
<pre><code># bpftrace -e 'tracepoint:syscalls:sys_enter_openat /cgroup == cgroupid("/sys/fs/cgroup/unified/mycg")/
    { printf("%s\n", str(args-&gt;filename)); }':
Attaching 1 probe...
/etc/ld.so.cache
/lib64/libc.so.6
/usr/lib/locale/locale-archive
/etc/shadow
^C
</code></pre> 
<p>另一个终端的行为如下:</p> 
<pre><code># echo $$ &gt; /sys/fs/cgroup/unified/mycg/cgroup.procs
# cat /etc/shadow
</code></pre> 
<h3><a id="15_ntop_944"></a>15. ntop()</h3> 
<pre><code>bpftrace -e 'tracepoint:tcp:tcp_set_state { printf("%s\n", ntop(args-&gt;daddr_v6)) }'
Attaching 1 probe...
::ffff:216.58.194.164
::ffff:216.58.194.164
::ffff:216.58.194.164
::ffff:216.58.194.164
::ffff:216.58.194.164
</code></pre> 
<pre><code>bpftrace -e '#include &lt;linux/socket.h&gt;
BEGIN { printf("%s\n", ntop(AF_INET, 0x0100007f));}'
127.0.0.1
^C
</code></pre> 
<h3><a id="16_kstack_960"></a>16. kstack()</h3> 
<p>同kstack关键字，可以选择输出格式和栈最大深度，如：</p> 
<pre><code># bpftrace -e 'kprobe:do_mmap { @[kstack(perf, 3)] = count(); }'
Attaching 1 probe...
[...]
@[
	ffffffffb4019501 do_mmap+1
	ffffffffb401700a sys_mmap_pgoff+266
	ffffffffb3e334eb sys_mmap+27

]: 22186
</code></pre> 
<h3><a id="17_ustack_973"></a>17. ustack()：</h3> 
<p>同ustack变量，<a href="https://editor.csdn.net/md?articleId=123382244#7_ustack_735" rel="nofollow">ustack变量</a></p> 
<h3><a id="18_cat_975"></a>18. cat():查看文件内容</h3> 
<p>可使用cat(文件名)查看文件内容，如：</p> 
<pre><code># bpftrace -e 'tracepoint:syscalls:sys_enter_sendmsg { printf("%s =&gt; ", comm);
    cat("/proc/%d/cmdline", pid); printf("\n") }'
Attaching 1 probe...
Gecko_IOThread =&gt; /usr/lib64/firefox/firefox
Gecko_IOThread =&gt; /usr/lib64/firefox/firefox
</code></pre> 
<h3><a id="19_signal_984"></a>19. signal():向当前进程发送一个信号</h3> 
<ul><li>内核版本&gt;=5.3</li><li>支持的探针类型：k(ret)probes,u(ret)probes,USDT,profile</li></ul> 
<pre><code># bpftrace  -e 'kprobe:__x64_sys_execve /comm == "bash"/ { signal(5); }' --unsafe
$ ls
Trace/breakpoint trap (core dumped)
</code></pre> 
<h3><a id="20_strncmp_992"></a>20. strncmp():字符串比较</h3> 
<p>同C语法格式，如果两个字符串的前n个字节相同，则返回0，否则返回非0：</p> 
<pre><code># bpftrace -e 't:syscalls:sys_enter_* /strncmp("mpv", comm, 3) == 0/ { @[comm, probe] = count() }'
Attaching 320 probes...
[...]
@[mpv/vo, tracepoint:syscalls:sys_enter_rt_sigaction]: 238
@[mpv:gdrv0, tracepoint:syscalls:sys_enter_futex]: 680
@[mpv/ao, tracepoint:syscalls:sys_enter_write]: 1022
@[mpv, tracepoint:syscalls:sys_enter_ioctl]: 2677
</code></pre> 
<h3><a id="21_override_1003"></a>21. override():重写返回值</h3> 
<ul><li>内核版本&gt;=4.16</li><li>探针类型: kprobes<br> 该特性需要内核配置了CONFIG_BPF_KPROBE_OVERRIDE选项，并且目标函数使用ALLOW_ERROR_INJECTION标签，bpftrace不测试被探测函数是否允许错误注入，而是测试是否无法将程序加载到内核。</li></ul> 
<pre><code>bpftrace -e 'k:__x64_sys_getuid /comm == "id"/ { override(2&lt;&lt;21); }' --unsafe -c id
uid=4194304 gid=0(root) euid=0(root) groups=0(root)
</code></pre> 
<pre><code>ioctl(PERF_EVENT_IOC_SET_BPF): Invalid argument
Error attaching probe: 'kprobe:vfs_read'
</code></pre> 
<h3><a id="22_sizeof_1015"></a>22. sizeof()</h3> 
<pre><code># bpftrace -e 'struct Foo { int x; char c; } BEGIN { printf("%d\n", sizeof(struct Foo)); }'
Attaching 1 probe...
8

# bpftrace -e 'struct Foo { int x; char c; } BEGIN { printf("%d\n", sizeof(((struct Foo)0).c)); }'
Attaching 1 probe...
1

# bpftrace -e 'BEGIN { printf("%d\n", sizeof(1 == 1)); }'
Attaching 1 probe...
8

# bpftrace -e 'BEGIN { printf("%d\n", sizeof(struct task_struct)); }'
Attaching 1 probe...
13120

# bpftrace -e 'BEGIN { $x = 3; printf("%d\n", sizeof($x)); }'
Attaching 1 probe...
8
</code></pre> 
<h3><a id="23_print_1037"></a>23. print()</h3> 
<p>使用print打印一个非map变量，如大多数的内置变量和局部变量：</p> 
<pre><code># bpftrace -e 'BEGIN { $t = (1, "string"); print(123); print($t); print(comm) }'
Attaching 1 probe...
123
(1, string)
bpftrace
^C
</code></pre> 
<h3><a id="24_strftime_1047"></a>24. strftime():格式化时间戳</h3> 
<p>语法:</p> 
<pre><code>strftime(const char *format, int nsecs)
</code></pre> 
<p>返回一个可使用printf打印的格式化时间戳，此时间戳的格式必须被strftime所支持(<code>并不是在内核bpf程序中返回，而是用户空间的时间</code>)。<code>nsecs</code>参数为自启动以来的纳秒数。</p> 
<pre><code># bpftrace -e 'i:s:1 { printf("%s\n", strftime("%H:%M:%S", nsecs)); }'
Attaching 1 probe...
13:11:22
13:11:23
13:11:24
13:11:25
13:11:26
^C

# bpftrace -e 'i:s:1 { printf("%s\n", strftime("%H:%M:%S:%f", nsecs)); }'
Attaching 1 probe...
15:22:24:104033
^C
</code></pre> 
<h3><a id="25_path_1068"></a>25. path():返回完整路径</h3> 
<p>格式：</p> 
<pre><code>path(struct path *path)
</code></pre> 
<pre><code># bpftrace  -e 'kfunc:filp_close { printf("%s\n", path(args-&gt;filp-&gt;f_path)); }'
Attaching 1 probe...
/proc/sys/net/ipv6/conf/eno2/disable_ipv6
/proc/sys/net/ipv6/conf/eno2/use_tempaddr
socket:[23276]
/proc/sys/net/ipv6/conf/eno2/disable_ipv6
socket:[17655]
/sys/devices/pci0000:00/0000:00:1c.5/0000:04:00.1/net/eno2/type
socket:[38745]
/proc/sys/net/ipv6/conf/eno2/disable_ipv6

# bpftrace  -e 'kretfunc:dentry_open { printf("%s\n", path(retval-&gt;f_path)); }'
Attaching 1 probe...
/dev/pts/1 -&gt; /dev/pts/1
</code></pre> 
<h3><a id="26_uptr_1089"></a>26. uptr():注解用户地址</h3> 
<p>格式：</p> 
<pre><code>uptr(void *p)
</code></pre> 
<p>将p注解为用户空间地址，bpftrace通常可以推断指针的地址空间，然而在某些情况下会推测失败。例如，处理用户空间指针（如const char__user*p）的内核函数。在这些情况下，需要对指针进行注释。</p> 
<pre><code># bpftrace -e 'kprobe:do_sys_open { printf("%s\n", str(uptr(arg1))) }'
Attaching 1 probe...
.
state
^C
</code></pre> 
<h3><a id="27_kptr_1102"></a>27. kptr():注解内核地址</h3> 
<p>格式：</p> 
<pre><code>kptr(void *p)
</code></pre> 
<p>类似于uptr，将p注解为内核态地址，通常只有在bpftrace错误地推断出指针地址空间的情况下需要。</p> 
<h3><a id="28_macaddrmac_1108"></a>28. macaddr():将mac地址转为文本</h3> 
<p>格式：</p> 
<pre><code>macaddr(char [6]addr)
</code></pre> 
<pre><code># bpftrace -e 'kprobe:arp_create { printf("SRC %s, DST %s\n", macaddr(sarg0), macaddr(sarg1)); }'
SRC 18:C0:4D:08:2E:BB, DST 74:83:C2:7F:8C:FF
^C
</code></pre> 
<h3><a id="29_cgroup_pathcgroupid_1118"></a>29. cgroup_path():将cgroupid转为路径</h3> 
<p>格式：</p> 
<pre><code>cgroup_path(int cgroupid, string filter)
</code></pre> 
<p>将给定的cgroup id转换为id出现在其中的每个cgroup层次结构的相应cgroup路径。因为转换是在用户空间中完成的，所以生成的对象只能用于打印。</p> 
<pre><code># bpftrace -e 'BEGIN { print(cgroup_path(5386)); }'
Attaching 1 probe...
unified:/user.slice/user-1000.slice/session-3.scope
</code></pre> 
<h2><a id="_1129"></a>七、映射表操作函数</h2> 
<h3><a id="1__1130"></a>1. 内置函数</h3> 
<ul><li><strong>count()</strong> - 统计函数调用次数</li><li><strong>sum(int n)</strong> - 求和</li><li><strong>avg(int n)</strong> - 求平均值</li><li><strong>min(int n)</strong> - 记录变量出现的最小值</li><li><strong>max(int n)</strong> - 记录变量出现的最大值</li><li><strong>stats(int n)</strong> - 返回变量出现的次数，平均值，总和</li><li><strong>hist(int n)</strong> -将值保存为直方图</li><li><strong>lhist(int n, int min, int max, int step)</strong> -将值保存为线性直方图</li><li><strong>delete(@x[key])</strong> - 从映射表中删除一个键值对</li><li><strong>print(@x[, top [, div]])</strong> - 打印映射表，可选top(只打印最高的top个)和div(将数值整除后再输出)参数</li><li><strong>print(value)</strong> - 打印一个变量</li><li><strong>clear(@x)</strong> - 删除映射表中全部键值对</li><li><strong>zero(@x)</strong> - 将全部值置为0</li></ul> 
<h3><a id="2_count_1144"></a>2. count()</h3> 
<p>格式：</p> 
<pre><code>@counter_name[optional_keys] = count()
</code></pre> 
<p>示例：</p> 
<pre><code># bpftrace -e 'kprobe:vfs_* { @vfs_op = count(); }'
Attaching 65 probes...
^C
@vfs_op: 7185
# bpftrace -e 'kprobe:vfs_read { @reads[comm] = count(); }'
Attaching 1 probe...
^C

@reads[sleep]: 4
@reads[bash]: 5
@reads[ls]: 7
@reads[snmp-pass]: 8
@reads[snmpd]: 14
@reads[sshd]: 14
</code></pre> 
<h3><a id="3_sum_1166"></a>3. sum()</h3> 
<p>格式</p> 
<pre><code>@counter_name[optional_keys] = sum(value)
</code></pre> 
<p>示例:</p> 
<pre><code># bpftrace -e 'kretprobe:vfs_read /retval &gt; 0/ { @bytes[comm] = sum(retval); }'
Attaching 1 probe...
^C

@bytes[bash]: 5
@bytes[sshd]: 1135
@bytes[systemd-journal]: 1699
@bytes[sleep]: 2496
@bytes[ls]: 4583
@bytes[snmpd]: 35549
@bytes[snmp-pass]: 55681
</code></pre> 
<h3><a id="4_avg_1185"></a>4. avg()</h3> 
<p>语法：</p> 
<pre><code>@counter_name[optional_keys] = avg(value)
</code></pre> 
<p>示例：</p> 
<pre><code># bpftrace -e 'kprobe:vfs_read { @bytes[comm] = avg(arg2); }'
Attaching 1 probe...
^C

@bytes[bash]: 1
@bytes[sleep]: 832
@bytes[ls]: 886
@bytes[snmpd]: 1706
@bytes[snmp-pass]: 8192
@bytes[sshd]: 16384
</code></pre> 
<h3><a id="5_min_1203"></a>5. min()</h3> 
<p>格式：</p> 
<pre><code>@counter_name[optional_keys] = min(value)
</code></pre> 
<p>示例：</p> 
<pre><code># bpftrace -e 'kprobe:vfs_read { @bytes[comm] = min(arg2); }'
Attaching 1 probe...
^C

@bytes[bash]: 1
@bytes[systemd-journal]: 8
@bytes[snmpd]: 64
@bytes[ls]: 832
@bytes[sleep]: 832
@bytes[snmp-pass]: 8192
@bytes[sshd]: 16384
</code></pre> 
<h3><a id="6_max_1222"></a>6. max()</h3> 
<p>格式：</p> 
<pre><code>@counter_name[optional_keys] = max(value)
</code></pre> 
<p>示例：</p> 
<pre><code># bpftrace -e 'kprobe:vfs_read { @bytes[comm] = max(arg2); }'
Attaching 1 probe...
^C

@bytes[bash]: 1
@bytes[systemd-journal]: 8
@bytes[sleep]: 832
</code></pre> 
<h3><a id="7_stats_1237"></a>7. stats()</h3> 
<p>格式：</p> 
<pre><code>@counter_name[optional_keys] = stats(value)
</code></pre> 
<p>示例：</p> 
<pre><code># bpftrace -e 'kprobe:vfs_read { @bytes[comm] = stats(arg2); }'
Attaching 1 probe...
^C

@bytes[bash]: count 7, average 1, total 7
@bytes[sleep]: count 5, average 832, total 4160
@bytes[ls]: count 7, average 886, total 6208
@bytes[snmpd]: count 18, average 1706, total 30718
@bytes[snmp-pass]: count 12, average 8192, total 98304
@bytes[sshd]: count 15, average 16384, total 245760
</code></pre> 
<h3><a id="8_hist_1255"></a>8. hist()</h3> 
<p>格式：</p> 
<pre><code>@histogram_name[optional_key] = hist(value)
</code></pre> 
<p>示例:</p> 
<pre><code># bpftrace -e 'kretprobe:vfs_read { @bytes = hist(retval); }'
Attaching 1 probe...
^C

@bytes:
(..., 0)             117 |@@@@@@@@@@@@                                        |
[0]                    5 |                                                    |
[1]                  325 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  |
[2, 4)                 6 |                                                    |
[4, 8)                 3 |                                                    |
[8, 16)              495 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[16, 32)              35 |@@@                                                 |
[32, 64)              25 |@@                                                  |
[64, 128)             21 |@@  
</code></pre> 
<h3><a id="9_lhist_1277"></a>9. lhist()</h3> 
<p>格式：</p> 
<pre><code>@histogram_name[optional_key] = lhist(value, min, max, step)
</code></pre> 
<p>示例：</p> 
<pre><code># bpftrace -e 'kretprobe:vfs_read { @bytes = lhist(retval, 0, 10000, 1000); }'
Attaching 1 probe...
^C

@bytes:
[0, 1000)            480 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[1000, 2000)          49 |@@@@@                                               |
[2000, 3000)          12 |@                                                   |
[3000, 4000)          39 |@@@@                                                |
[4000, 5000)         267 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@                        |
</code></pre> 
<h3><a id="10_print_1295"></a>10. print()</h3> 
<p>格式：</p> 
<pre><code>print(@map [, top [, divisor]])
</code></pre> 
<p>print()函数将打印映射表，类似于bpftrace结束时的自动打印。可以提供两个可选参数：一个是top number，这样只打印top number个数目；另一个是divisor，用于分割值。<br> 示例：</p> 
<pre><code># bpftrace -e 'kprobe:vfs_* { @[func] = count(); } END { print(@, 5); clear(@); }'
Attaching 54 probes...
^C
@[vfs_getattr]: 91
@[vfs_getattr_nosec]: 92
@[vfs_statx_fd]: 135
@[vfs_open]: 188
@[vfs_read]: 405
</code></pre> 
<p>最后使用clear来防止bpftrace结束是对映射表的自动打印。<br> 使用divisor的示例:</p> 
<pre><code>bpftrace -e 'kprobe:vfs_read { @start[tid] = nsecs; }
    kretprobe:vfs_read /@start[tid]/ {@ms[pid] = sum(nsecs - @start[tid]); delete(@start[tid]); }
    END { print(@ms, 0, 1000000); clear(@ms); clear(@start); }'
@ms[2429]: 0
@ms[7679]: 0
@ms[2662]: 1
@ms[7633]: 1
@ms[343161]: 1
@ms[58241]: 1
@ms[7727]: 8503
</code></pre> 
<hr> 
<p>原文: https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b248af691a36286246680d269b4ce54/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ping内网流程以及ARP，ICMP,IP报文格式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/76471a47047eb64bb25ada4cb52b5c64/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Feign远程调用服务时返回Null的情况</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>