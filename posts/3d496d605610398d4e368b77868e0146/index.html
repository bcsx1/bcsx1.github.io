<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>汇编语言程序设计（第二版） 刘慧婷 王庆生 主编 课后参考答案 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="汇编语言程序设计（第二版） 刘慧婷 王庆生 主编 课后参考答案" />
<meta property="og:description" content="汇编语言程序设计（第二版） 刘慧婷 王庆生 主编 课后参考答案 第一章 1.1 什么是机器语言？什么是汇编语言？简述汇编语言的特点。 机器语言就是用二进制编码组成的机器指令的集合和一组使用机器指令的规则。汇编语言是对机器指令中的操作码用英文单词的缩写描述，对操作数用标号、变量、常量描述。
汇编语言的特点：
（1）与机器有关：移植性差，但可直接控制硬件。
（2）程序效率高。
（3）局限性：受指令的限制，如考虑存储单元等。
（4）调试困难。
1.2 汇编程序与汇编源程序的区别是什么？ 汇编源程序是指用汇编语言编写的程序，而汇编程序特指将汇编源程序汇编成目标文件的编译程序。
1.3 把下列十进制数转换为二进制数和十六进制数。 （1）67 （2）34 （3）254 （4）123 答：（1）1000011,43 （2）100010， 22
（3）1111 1101，FE （4）111 1011，7B
1.4 把下列二进制数转换为十六进制数和十进制数。 (1)01101101 (2)10110010 (3)111111 答：（1）6D，109 （2）B2,178， （3）3F，63
1.5 作下列十六进制数的运算，并转换为十进制数校核。 (1)5A&#43;64 (2)86-49 (3)123-9A (4)43×2B 答：（1） BE （2）3D （3） 89 （4） B41
1.6 根据补码定义把下列十进制数表示为8位二进制补码。 (1) 64 (2) -24 答：（1）0100 0000 （2）[10011000]原=[1110 1000]补
第二章 2.1 简述计算机系统组成。 答：计算机由中央处理器CPU，存储器，输入系统，输出系统组成，由系统总线连接在一起。CPU包括运算器和控制器，运算器执行指令，控制器负责计算机的控制。存储器是计算机的记忆部件，以二进制形式存放程序和数据。输入输出系统包括大容量存储器，如硬盘，以及其他外设，如鼠标，键盘，显示器等。
2.2 简述16位机的各类寄存器的主要作用。 答：（1）数据寄存器：Ax，Bx，Cx，Dx； AX：作为累加器，是算术运算的主要寄存器。在乘除等指令中存放操作数，在I/O指令中使用它与外部设备传送信息。BX：当通用寄存器使用，在计算存储器地址时，作基址寄存器使用。CX：当通用寄存器使用，此外常用来保存计数值，当计数器使用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3d496d605610398d4e368b77868e0146/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-17T16:21:14+08:00" />
<meta property="article:modified_time" content="2019-11-17T16:21:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">汇编语言程序设计（第二版） 刘慧婷 王庆生 主编 课后参考答案</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_____0"></a>汇编语言程序设计（第二版） 刘慧婷 王庆生 主编 课后参考答案</h2> 
<h3><a id="_1"></a>第一章</h3> 
<h5><a id="11__2"></a>1.1 什么是机器语言？什么是汇编语言？简述汇编语言的特点。</h5> 
<p>机器语言就是用二进制编码组成的机器指令的集合和一组使用机器指令的规则。汇编语言是对机器指令中的操作码用英文单词的缩写描述，对操作数用标号、变量、常量描述。<br> 汇编语言的特点：<br> （1）与机器有关：移植性差，但可直接控制硬件。<br> （2）程序效率高。<br> （3）局限性：受指令的限制，如考虑存储单元等。<br> （4）调试困难。</p> 
<h5><a id="12__10"></a>1.2 汇编程序与汇编源程序的区别是什么？</h5> 
<p>汇编源程序是指用汇编语言编写的程序，而汇编程序特指将汇编源程序汇编成目标文件的编译程序。</p> 
<h5><a id="13__13"></a>1.3 把下列十进制数转换为二进制数和十六进制数。</h5> 
<pre><code>（1）67 （2）34 （3）254 （4）123
</code></pre> 
<p>答：（1）1000011,43 （2）100010， 22<br> （3）1111 1101，FE （4）111 1011，7B</p> 
<h5><a id="14__18"></a>1.4 把下列二进制数转换为十六进制数和十进制数。</h5> 
<pre><code>(1)01101101      (2)10110010      (3)111111
</code></pre> 
<p>答：（1）6D，109 （2）B2,178， （3）3F，63</p> 
<h5><a id="15__22"></a>1.5 作下列十六进制数的运算，并转换为十进制数校核。</h5> 
<pre><code>(1)5A+64      (2)86-49      (3)123-9A      (4)43×2B 
</code></pre> 
<p>答：（1） BE （2）3D （3） 89 （4） B41</p> 
<h5><a id="16_8_26"></a>1.6 根据补码定义把下列十进制数表示为8位二进制补码。</h5> 
<pre><code>(1) 64      (2) -24  
</code></pre> 
<p>答：（1）0100 0000 （2）[10011000]原=[1110 1000]补</p> 
<h3><a id="_30"></a>第二章</h3> 
<h5><a id="21__31"></a>2.1 简述计算机系统组成。</h5> 
<p>答：计算机由中央处理器CPU，存储器，输入系统，输出系统组成，由系统总线连接在一起。CPU包括运算器和控制器，运算器执行指令，控制器负责计算机的控制。存储器是计算机的记忆部件，以二进制形式存放程序和数据。输入输出系统包括大容量存储器，如硬盘，以及其他外设，如鼠标，键盘，显示器等。</p> 
<h5><a id="22_16_34"></a>2.2 简述16位机的各类寄存器的主要作用。</h5> 
<p>答：（1）数据寄存器：Ax，Bx，Cx，Dx； AX：作为累加器，是算术运算的主要寄存器。在乘除等指令中存放操作数，在I/O指令中使用它与外部设备传送信息。BX：当通用寄存器使用，在计算存储器地址时，作基址寄存器使用。CX：当通用寄存器使用，此外常用来保存计数值，当计数器使用。<br> DX：当通用寄存器使用，一般在作双字长运算时把DX和AX组合使用，对某些I/O操作，DX用来存放I/O的端口地址。<br> （2）地址寄存器：Sp，Bp，Si，Di<br> （3）段寄存器：Cs，Ds，Es，Ss；段寄存器的作用是专用于存储器寻址，用来直接或间接地存放段地址。<br> （4）专用寄存器：Ip，Flags；Ip寄存器专门存放下一条指令的地址，Flags标志寄存器，又称程序状态寄存器。它是存放条件码标志、控制标志和系统标志的寄存器。</p> 
<h5><a id="23__41"></a>2.3 写出每条汇编指令执行后相关寄存器的值。</h5> 
<p>Mov ax, 1345H ax=<strong><strong>1345H</strong></strong>_______<br> Mov ah, 24H ax=<strong><strong>2445H</strong></strong>_______<br> Mov al, 45H ax=<strong><strong>2445H</strong></strong>_______<br> Mov bx, 3412H bx=<strong><strong>3412H</strong></strong>_______<br> Mov al, bh ax=<strong><strong>2434H</strong></strong>_______</p> 
<h5><a id="241234200214300042FF000FFF_48"></a>2.4实模式下，写出段地址和偏移地址为1234:2002、1430:0042、FF00:0FFF的物理地址。</h5> 
<p>答：<br> 1234:2002=12340+2002=14342<br> 1430:0042=14300+0042=14342<br> FF00:0FFF=FF000+0FFF=FFFFF</p> 
<h5><a id="258FLAGSCFOF16FLAGSCFOF_54"></a>2.5下列各数均为十进制数，请采用8位二进制补码运算，并回答标志寄存器FLAGS中CF和OF的值，运算结果所代表的十进制数是多少？如果用16位二进制补码运算，其结果所代表的十进制数是多少？FLAGS中CF和OF的值呢？</h5> 
<p>(1)85+69 (2)85+(-69) (3)85-(-69) (4)85-(69)<br> 答：85=55H,69=45H,-69=BBH，<br> 8位二进制补码运算:<br> (1)85+69 =55H+45H=9AH=154, CF=0,OF=1<br> (2)85+(-69)=55H+BBH=10H=16,CF=1,OF=0<br> (3)85-(-69)=55H-BBH=9AH=154,CF=1,OF=1<br> (4)85-(69)=55H-45H=10H=16,CF=0,OF=0</p> 
<p>16位二进制补码运算:<br> 85=0055H,69=0045H,-69=0FFBBH，<br> (1)85+69 =0055H+0045H=009AH=154, CF=0,OF=0<br> (2)85+(-69)=0055H+0FFBBH=0010H=16,CF=1,OF=0<br> (3)85-(-69)=0055H-0FFBBH=009AH=154,CF=1,OF=0<br> (4)85-(69)=0055H-0045H=0010H=16,CF=0,OF=0</p> 
<h5><a id="26_0001HCPU____00010H_________________1000FH______________70"></a>2.6 给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围从____00010H_____________到____1000FH_____________。</h5> 
<h5><a id="27_20000HSASA__1001H________________2000H_________________72"></a>2.7 有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元，则SA应满足的条件是：最小为__1001H____________，最大为____2000H________________。</h5> 
<h5><a id="28_808652506H8086_74"></a>2.8 已知8086系统某存储单元物理地址为：52506H，你认为段基址的最大值、最小值分别是多少？8086微机最多可以有多少个不同的段基址</h5> 
<p>答：52506=50000+2506，=52500+0006，基地址最大为5250，最小为5000(4251).<br> 段地址取值范围：0000—FFFF。既65536个。</p> 
<h5><a id="2900100H00103H12H34H56H78H_78"></a>2.9从物理地址为00100H开始到00103H单元中顺序存放的数据为：12H，34H，56H，78H。请画出数据存放示意图，并回答以下问题：</h5> 
<p>(1)写出00101H字节单元的内容<br> (2)写出00102H字单元的内容<br> 答案：<br> (1)(00101)= 34H<br> (2)(00102)= 7856H</p> 
<h3><a id="_85"></a>第三章</h3> 
<h5><a id="31__86"></a>3.1 写出从汇编语言源程序的建立到产生可执行文件的步骤和上机操作命令。</h5> 
<p>答：(1)用编辑程序EDIT建立 .ASM源文件<br> (2)用汇编程序MASM把.ASM文件原文件汇编成.OBJ文件<br> (3)用连接程序LINK将.OBJ文件转换成.EXE文件<br> (4)在DOS下直接运行.EXE文件或在DEBUG下调试该.EXE文件</p> 
<h5><a id="32_LSTLST_92"></a>3.2 列表文件.LST是在什么阶段产生的？列表文件.LST中有哪些内容？</h5> 
<p>答：<em>.LST 在汇编得到</em>.obj的同时得到，列表文件报告了汇编过程中产生的很多有价值的参考信息。主要包括源程序和机器语言清单、指令和变量的偏移地址等等。</p> 
<h5><a id="33_MYPRG_95"></a>3.3 写出定义一个代码段的语句，段名为MYPRG。</h5> 
<p>答：MYPRG segment<br> assume cs: MYPRG<br> start:<br> MYPRG ends<br> End start</p> 
<h5><a id="34__102"></a>3.4 程序中用什么语句来结束程序的执行？用什么语句来表示程序的结束和指出程序执行的起点？</h5> 
<p>答：程序的结束：mov ah,4ch<br> int 21h<br> 程序的结束和指出执行的起点：End start</p> 
<h5><a id="35_EXE_107"></a>3.5 汇编语言源程序的文件扩展名是什么？把它改为.EXE扩展名后，可以认为是可执行程序吗？</h5> 
<p>答：源程序的文件扩展名为*.asm，改扩展名不可以执行。</p> 
<h5><a id="36_CYOUPRGASMDMYPRGMYPRGCYOUPRGYOUASMDMYPRGDOS_110"></a>3.6 列出子目录C:\YOUPRG下的扩展名为.ASM的所有文件，在D盘根目录下建立一个子目录MYPRG，并进入子目录MYPRG，再把C:\YOUPRG下的文件YOU.ASM复制到D:\MYPRG下。写出完成以上要求的DOS命令。</h5> 
<pre><code>答：(1)列出子目录：C:\YOUPRG&gt;dir *.asm
    (2)建立子目录：D:\&gt;MD MYPRG
    (3)复制: C:\YOUPRG&gt;copy YOU.asm D:\MYPRG
</code></pre> 
<h5><a id="37_DEBUG_115"></a>3.7 下图为DEBUG调入的可执行程序，回答以下问题：</h5> 
<p>(1)程序的起始物理地址是多少？结束地址是多少？<br> (2)CS寄存器的值是什么？<br> (3)程序的功能是什么？<br> (4)写出查看DS:0处内容的DEBUG命令。<br> (5)程序中2处的INT 21指令执行后有什么结果？<br> (6)如果要运行这个程序应该用什么DEBUG命令？<br> (7)DEBUG命令-T=0 4 之后，寄存器AX、DS、DX的值是多少？</p> 
<p>答：(1)0B630,0B63E<br> (2)0B63<br> (3)显示0B62:0000存储的字符串<br> (4)-d 0B62:0000<br> (5)第一处显示字符串，第二处结束程序<br> (6)-g<br> (7)(AX)=0962,(DS)=0B62,(DX)=0000</p> 
<h5><a id="38_DEBUG_137"></a>3.8 解释DEBUG程序中的如下调试命令。</h5> 
<ul><li>D , - E, - T, - G, - A , - R<br> 答：- D 显示内存内容 
  <ul><li>E 修改内存单元内容</li><li>T 跟踪命令</li><li>G 运行命令</li><li>A 汇编命令</li><li>R 查看或修改寄存器内容</li></ul> </li></ul> 
<h5><a id="39_DEBUGPROGEXE_146"></a>3.9 用DEBUG调入PROG.EXE后,若程序列出如下:</h5> 
<p>1234:0100 MOV BX, [4000]<br> 1234:0104 MOV AX, [BP]<br> 1234:0106 MOV AH, 1<br> 1234:0108 INT 21<br> 1234:010A MOV DL, AL<br> 1234:010C MOV AH, 2<br> 1234:010E INT 21<br> 1234:0110 RET<br> 列出上面程序的DEBUG命令是( )。<br> 寄存器CS的值为( ),第一条指令的物理地址为( )。<br> 如果要修改寄存器BX为1200H，应键入DEBUG命令( )。<br> 若要修改第二条指令中的BP为BX,应键入DEBUG命令( ) 。<br> 答：(1) U<br> (2) 1234H<br> (3) 12440H<br> (4) R BX<br> (5) A [0104]</p> 
<h5><a id="310WIN7_165"></a>3.10简述在WIN7系统中执行汇编的方法。</h5> 
<p>DosBox是一款在Windows系统运行DOS程序的环境模拟器。下载安装DosBox，运行该程序，出现DosBox运行界面，运行挂载命令mount，即可以将Dos程序放置在Windows环境下Dos模拟器中运行，其过程为挂载。</p> 
<h5><a id="311_DOSINT_21H_169"></a>3.11 简述DOS系统功能INT 21H调用方法。</h5> 
<p>答：(1)将调用功能的功能号存入AH寄存器。<br> (2)如必要，设置该调用功能的入口参数。<br> (3)执行INT 21H指令。<br> (4)如必要，按规定取得出口参数（返回参数）。</p> 
<h5><a id="312__DebugINT_21Ht_175"></a>3.12 Debug命令调试含有“INT 21H”命令的程序段时，如何实现单步执行，“-t”命令为何无法实现？</h5> 
<p>答：“INT 21H”指令是Dos的系统调用，如果使用“-t”跟踪，则进入DOS系统子程序。如果希望单步执行，可以通过P命令或“-g=x x+1”来实现。</p> 
<h5><a id="313_inspire_a_generation_178"></a>3.13 有主存数据段存放情况如下图所示，请写出代码，输出数据段的字符串“inspire a generation！”。</h5> 
<p>答： mov ax,145B<br> mov ds,ax<br> mov ah,09<br> mov dx,0<br> int 21h</p> 
<h3><a id="_186"></a>第四章</h3> 
<h5><a id="41___187"></a>4.1 何为段地址？何为有效地址？ 何为物理地址？</h5> 
<p>答：</p> 
<p>例如DS=6542H，指令mov ax,DS:[123A]； 123A为有效地址，6542H为段地址，65420H+0123AH=6665A即物理地址.</p> 
<h5><a id="42_array_192"></a>4.2 指出以下指令的寻址方式，array是变量。</h5> 
<p>(1)mov ax, 9<br> (2)mov byte ptr[bx],9<br> (3)mov bx,[di] (4)mov ax,bx<br> (5)mov [si+bx],9<br> (6)mov array[bx],cx<br> (7)mov ax, array+9<br> (8)mov ax, array[bx+di] 答： (1)立即数寻址<br> (2)寄存器间接寻址<br> (3)变址寻址<br> (4)寄存器寻址<br> (5)基址变址寻址<br> (6)相对基址寻址<br> (7)直接寻址<br> (8)相对基址变址寻址</p> 
<h5><a id="43_DS1200HSS4400H_BX463DHBP2006H_SI6A00HD4524HAXEA_208"></a>4.3 假定(DS)=1200H，(SS)=4400H, (BX)=463DH，(BP)=2006H, (SI)=6A00H，位移量D=4524H，以AX寄存器为目的操作数，试写出以下各种寻址方式下的传送指令，并确定源操作数的有效地址EA和物理地址。</h5> 
<p>(1)立即寻址<br> (2)直接寻址<br> (3)使用BX的寄存器寻址；无EA<br> (4)使用BX的间接寻址<br> (5)使用BP的寄存器相对寻址<br> (6)基址变址寻址<br> (7)相对基址变址寻址<br> 答：(1)操作数在指令中无EA<br> (2)直接寻址：EA=4524H，物理地址=DS：4524<br> (3)使用BX的寄存器寻址：无EA<br> (4)使用BX的间接寻址：EA=463DH，物理地址=DS：463D<br> (5)使用BP的寄存器相对寻址：MOV AX，[BP+4524]，EA=2006+4524，<br> 物理地址=SS：EA<br> (6)基址变址寻址： MOV AX，[BX+SI]，EA= BX+SI，物理地址=DS：EA<br> (7)相对基址变址寻址：MOV AX，[4524+BX+SI]，EA=4524+BX+SI，<br> 物理地址=DS：EA</p> 
<h5><a id="44_ARRAYARRAY24H5AX_226"></a>4.4 在数据段定义了ARRAY数组，其中依次存储了五个字数据，ARRAY的起始地址（第一个数据的地址）为24H,请用不同寻址方式的指令，把第5个字送AX寄存器,指令条数不限。</h5> 
<p>答：(1)直接寻址<br> MOV AX，ARRAY+8 或MOV AX，[ARRAY+8] (2)使用BX的间接寻址<br> LEA BX，ARRAY+8 ；MOV AX，[BX] (3)使用BX的寄存器相对寻址<br> LEA BX，ARRAY ；MOV AX，[BX+8] (4)基址变址寻址<br> LEA BX，ARRAY ； MOV SI，8 ； MOV AX，[BX+SI]</p> 
<h3><a id="_233"></a>第五章</h3> 
<h5><a id="51_OFCF_235"></a>5.1 溢出标志OF与进位标志CF有何作用和区别？</h5> 
<p>答：处理器对两个操作数进行运算时，按照无符号数求得结果，并相应设置进位标志CF；同时，根据是否超出有符号数的范围设置溢出标志OF。应该利用哪个标志，则由程序员来决定。也就是说，如果将参加运算的操作数认为是无符号数，就应该关心进位；认为是有符号数，则要注意是否溢出。</p> 
<h5><a id="52_AX__BXL1CMP_AX_BX__238"></a>5.2 有符号数比较大小,当AX &lt; BX时程序转向标号L1,若前导指令为CMP AX, BX，后续指令应为什么？若视为二个无符号数比较大小, 后续指令应为什么？</h5> 
<p>答：带符号数:JL L1, 无符号数:JB L1</p> 
<h5><a id="53_CMPTEST_241"></a>5.3 CMP和TEST指令与其他指令的不同之处在于什么？它们通常都紧跟着跳转指令，用在什么场合？</h5> 
<p>答：CMP和TESt指令分别执行减法和逻辑与操作，但不回送结果，只影响标志位，通常用以判断两个数的大小或者用以判断操作数的某些位是1或0。</p> 
<h5><a id="54_4CH_244"></a>5.4 除了用4CH号系统功能调用结束程序的执行并退出，还有哪些办法？</h5> 
<p>答：RET指令，INT 20H，但要正确使用。</p> 
<h5><a id="55_V_247"></a>5.5 V是变量，指出下列错误的指令，说出错误原因，并给出合适的修改。</h5> 
<p>(1) MOV AX，[DX]<br> (2) MOV DS，DATA<br> (3) MOV CS，AX<br> (4) MOV AX，DL<br> (5) PUSH AL<br> (6) ADD [BX]，[DI]<br> (7) LEA [BX]，V<br> (8) MOV [DX]，OFFSET V<br> (9) MOV [SI]，2<br> (10) MUL BX，CX<br> (11) DIV 5<br> (12) MOV BYTE[SI]，AX<br> (13) MOV AX，[SI+DI]<br> (14) SHR AX，4<br> (15) CMP 6，AX<br> (16) MOV [FFFF]，AX<br> (17) MOV AX，BX+4<br> (18) JMP FAR PRO<br> 答：(1) MOV AX，[BX]<br> (2) MOV DS，BX<br> (3) MOV ES，AX<br> (4) MOV AL，DL<br> (5) PUSH AX<br> (6) ADD [BX]，DI<br> (7) LEA BX，V<br> (8) MOV DX,OFFSET V<br> (9) MOV WORD PTR [SI]，AX<br> (10) MUL BX<br> (11) DIV BX<br> (12) MOV BYTE PTR [SI]，2<br> (13) MOV AX，[BX+SI]<br> (14) SHR AX，1<br> (15) CMP AX，6<br> (16) MOV [FFFE]，AX<br> (17) MOV AX，[BX+4]<br> (18) JMP FAR PTR PRO</p> 
<h5><a id="56_ARRAY44AX_285"></a>5.6 在数据段定义了ARRAY数组，其中依次存储了4个字数据，根据以下要求把第4个字送AX寄存器。</h5> 
<p>(1)直接寻址<br> (2)使用BX的间接寻址<br> (3)使用BX和 ARRAY的寄存器相对寻址<br> (4)基址变址寻址<br> (5)MOV以外的其它指令<br> 答：(1)直接寻址<br> MOV AX，ARRAY+6 或MOV AX，[ARRAY+6]<br> (2)使用BX的间接寻址<br> LEA BX，ARRAY+6 ；MOV AX，[BX]<br> (3)使用BX和 ARRAY的寄存器相对寻址<br> LEA BX，ARRAY ；MOV AX，[BX+6]<br> (4)基址变址寻址<br> LEA BX，ARRAY ； MOV SI，6 ； MOV AX，[BX+SI]<br> (5)MOV以外的其它指令<br> SUB AX，AX； ADD AX，[ARRAY+6]</p> 
<h5><a id="57_BXDICXDX__303"></a>5.7 画出数据在数据段中的存放情况，程序执行后，BX、DI、CX、DX寄存器中的内容是什么? 程序如下：</h5> 
<pre><code>data  segment
array  dw  20，30，40，20h，30h，-6
buff   db  ‘abcd$’
data  ends
code  segment
	  assume  cs:code,ds:data
start:
	  mov    ax, data
	  mov    ds, ax
			mov    bx, array+1
			mov    di, offset array
			mov    cx, [di+5]
			mov    dl, buff+3
			mov    ah, 4ch
			int    21h
code  ends
			end    start
</code></pre> 
<p>答： 14 00 1E 00 28 00 20 00 30 00 FA FF 61 62 63 64 $<br> (BX)=1E00H，(DI)=0000H，(CX)=2000H，(DX)=0064H</p> 
<h5><a id="58_DEBUGSP20HAXBXCXDXSIDIBPBXSP_324"></a>5.8 在DEBUG下设置(SP)=20H，设置AX、BX、CX、DX为不同值，把这四个寄存器内容依次压入堆栈，再从堆栈中依次弹出到SI、DI、BP、BX寄存器。写出一段程序实现上述操作，并画出每条入栈指令执行后SP和堆栈中数据的变化。</h5> 
<pre><code>答：
code segment
	 assume cs:code
start:
	  push AX
	  push BX
	  push CX
	  Push DX
	  Pop  SI
Pop  DI
Pop  BP
Pop  BX
Hlt
Code ends
	 End start
</code></pre> 
<h5><a id="59_7450HSFZFCFOF_342"></a>5.9 求出7450H与以下各十六进制数的和及差，并根据结果标出SF、ZF、CF、OF标志位的值。</h5> 
<p>(1) 1234H (2)5678H (3)9804H (4)E0A0H<br> 答： SF、ZF、CF、OF<br> (1)1234H+7450H， 1 0 0 1<br> (2)5678H+7450H， 1 0 0 1<br> (3)9804H+7450H， 0 0 1 0<br> (4)E0A0H+7450H， 0 0 1 0</p> 
<h5><a id="510_32XY16_350"></a>5.10 在数据段有32位的无符号数变量X,Y,按如下格式定义，其中‘？’请用数值代替，用16位指令按要求写出程序。</h5> 
<pre><code>   X    DW    ？，？
   Y    DW    ？，？
   Z    DW    ？，？，？，？
(1)Z=X+Y。
(2)Z=X-Y。
(3)Z=|X-Y|。
(4)Z=X×Y。
答：(1)X和Y两个字数据相加，和存放在Z中。
	 MOV  AX，X
	 MOV  DX，X+2
	 ADD  AX，Y
	 ADC  DX，Y+2
	 MOV  Z，AX
	 MOV  Z+2，DX
	(2)MOV  AX，X
	 MOV  DX，X+2
	 SUB  AX，Y
	 SBB  DX，Y+2
	 MOV  Z，AX
	 MOV  Z+2，DX
	(3)MOV  AX，X
	 MOV  DX，X+2
	 SUB  AX，Y
	 SBB  DX，Y+2
	 TEST AX,8000H
 JZ  Exit
 NOT AX
 NOT DX
 ADD DX,1
 ADC AX,0
 Exit: MOV  Z，AX
	 MOV  Z+2，DX
	(4)MOV  AX，X
	 MUL  Y
	 MOV  Z，AX
 MOV  Z+2，DX
	 MOV  AX，X+2
	 MUL  Y
	 ADD  Z+2,AX
	 ADC  DX,0
	 MOV  Z+4,DX
	 MOV  AX，X
	 MUL  Y+2
	 ADD  Z+4，AX
 ADC  DX,0
 MOV  Z+6,DX
		 MOV  AX，X+2
	 MUL  Y+2
	 ADD  Z+6,AX
	 ADC  DX,0
	 MOV  Z+8,DX
</code></pre> 
<h5><a id="511AX516_403"></a>5.11用移位指令为主实现对AX中的无符号数乘以5，不考虑乘积可能超出16位。</h5> 
<pre><code>答： MOV  DX，AX
MOV  CL，2
	 SHL  AX，CL
	 ADD  AX，DX
</code></pre> 
<h5><a id="512_AX516_409"></a>5.12 用移位指令为主实现对AX中的无符号数乘以5，考虑乘积可能超出16位的情况。</h5> 
<pre><code>答： MOV  DX,0
MOV  BX，AX
	 SHL  AX，1
	 ADC  DX,0
SHL  DX,1
SHL  AX，1
	 ADC  DX,0
	 ADD  AX，BX
	 ADC  DX,0
</code></pre> 
<h5><a id="513_AX015114_421"></a>5.13 把AX中的内容依次倒排序，即第0位移到第15位，第1位移到第14位，…。</h5> 
<pre><code>答：先设AX值
	Mov  di,0
	Mov  bx,0
	Mov si,1
	Mov cl,2
	Ror ax,1
K: Rol ax,cl
	Mov bx,ax
	And bx,si
	Add di,bx
	Shl,si,1
	Cmp si,0
	Jnz  k
	Mov ax,di
</code></pre> 
<h5><a id="514__437"></a>5.14 在数据段有如下定义：</h5> 
<pre><code>BUFF    DB  ‘ABCD$EFGHIJK$’
		  STR1    DB   12  DUP(?)
		  LEN     DB   ？
用串指令编写程序完成以下操作：
(1) 对字符串STR1全部置‘*’符。
(2) 从左到右把BUFF中的字符串传送到STR1。
(3) 从右到左把BUFF中的字符串传送到STR1。
(4) 比较BUFF与STR1两个字符串是否相等，如相等则DX=1，否则DX=0。
(5) 查找BUFF中有无字符$，把字符$出现的次数计入BX寄存器。
答：
(1) 
MOV  AX，DATA
MOV  DS，AX
MOV  AL，‘*’
LEA  DI，STR1
MOV  CX，STR1-BUFF
CLD
REP  STOSB  
(2) 
MOV  AX，DATA
MOV  DS，AX
MOV  ES，AX
CLD
LEA  SI，BUFF
LEA  DI，STR1
MOV  CX，STR1-BUFF
REP  MOVSB
(3) 
MOV  AX，DATA
MOV  DS，AX
MOV  ES，AX
STD
LEA  SI，STR1-1
LEA  DI，LEN-1
MOV  CX，STR1-BUFF
REP  MOVSB

(4)
MOV  AX，DATA
MOV  DS，AX
MOV  ES，AX
CLD
LEA  SI，BUFF
LEA  DI，STR1
MOV  CX，STR1-BUFF
REPE  CMPSB

(5) 
MOV  AX，DATA
MOV  ES，AX
MOV  BX，0
CLD
MOV  AL，‘$’
LEA  SI，BUFF
MOV  CX，STR1-BUFF
NEXT: REPNE  SCASB
JCXZ  NO-FOUND
INC  BX
JMP  NEXT
</code></pre> 
<h5><a id="515_AXBX_498"></a>5.15 对于给定的AX和BX的值，执行下列程序段，程序将转向哪里？</h5> 
<pre><code>ADD    AX, BX
	  JNO    L1
JNC    L2
SUB    AX，BX
JNC    L3
JNO    L4
JMP    L5
(1) AX=1234H，  BX=6789H
(2) AX=790EH，  BX=8831H
(3) AX=E002H，  BX=8086H
答：L1，L1，L5
</code></pre> 
<h5><a id="516_AXBXMAX_511"></a>5.16 下面不完整的程序段是比较AX和BX的值，把其中大的数送MAX变量。如果是无符号数，应如何填写指令？如果是有符号数，应如何填写指令？</h5> 
<pre><code>CMP    AX，BX
(             )   
MOV    MAX，AX
(            )
L1：MOV    MAX，BX  
L2：HLT   

答： JB  L1  
	 JMP  L2  
</code></pre> 
<h5><a id="517_AXCX_522"></a>5.17 在下列程序段的括号中分别填入如下指令，程序执行完后，AX、CX的内容是什么？</h5> 
<pre><code>(1) LOOP    L1
(2) LOOPE   L1
(3) LOOPNZ  L1
MOV    AX， 6
	  MOV    CX，3
L1：ROL    AX，CL
	TEST   AL，3
(        )

答：（1）AX=0C000H，CX=0000
   （2）AX=0003H，CX=0002
   （3）AX=0C000H，CX=0000
</code></pre> 
<h5><a id="518_AL0L01L11L2_536"></a>5.18 测试AL寄存器，如果最高位和最低位同时为0，则转L0，如果最高位和最低位只有一位为1，则转L1，如果最高位和最低位同时为1，则转L2。画出流程图，并编写程序段。</h5> 
<pre><code>答： 
Code segment
	 Assume cs:code
Start:
  
ROR  AL,1
AND  AL,3
JZ   L0
SUB  AL,3
JZ   L2
JMP  L1
L0：
	JMP Exit
L1：
	JMP Exit
L2：
Exit：hlt
code ends
	 end start
</code></pre> 
<h5><a id="519__558"></a>5.19 从键盘输入一个英文字母，显示输出其大写。画出流程图，并编写程序段。</h5> 
<pre><code>答：
Code segment
	 Assume cs:code
Start:
	 Mov ah,1
	 Int 21h
	 sub al,20h
	 mov dl,al
	 mov ah,2
	   int 21h
hlt
code ends
	 end start
</code></pre> 
<h5><a id="520_NNN_574"></a>5.20 从键盘输入一位数字N，显示输出N个N。画出流程图，并编写程序段。</h5> 
<pre><code>答：
CODE SEGMENT
ASSUME  CS:CODE
START:
MOV  AH,1
INT 21H
MOV  DL,AL
AND  AL, 0FH
MOV  CL,AL
MOV  CH,0
NEXT: MOV  AH,2
INT 21H
LOOP  NEXT
MOV  4CH
INT 21H
CODE ENDS
  END  START
</code></pre> 
<h5><a id="521_BCDABKJABKJAXAX_594"></a>5.21 在数据段有压缩的BCD码表示的十进制数，写出指令分别完成十进制加法A+B,K+J和减法A-B,K-J。结果放在AX,回答AX的内容。</h5> 
<pre><code>A  DB 65H,
B  DB 37H 
K  DB 98H
J  DB 69H
答：(1)    MOV Al,A
		   MOV Bl,B
		   ADD AL,BL
	 AAA
SUB AL,BL
	 DAS
	 (2)   MOV Al,K
		   MOV Bl,J
		   ADD AL,BL
	 AAA
SUB AL,BL
	 DAS
(1)A+B=9CH,AX=0102H.A-B=2EH,AX=0028H
(2)K+J=01H,AX=0107H.K-J=2FH,AX=0029H
</code></pre> 
<h5><a id="522_ARRAY_614"></a>5.22 用相对基址变址寻址方法求ARRAY行列式的值。</h5> 
<pre><code>ARRAY    DW  2，3，5
			 DW  1，4，6
			 DW  2，7，9
答：
	   data segment
		 Array dw 2,3,5
			   dw 1,4,6
			   dw 2,7,9
	   data ends
	   code segment
			assume cs:code,ds:data
	   start:
			mov ax,data
			mov ds,ax
			mov ax,0
			 mov bx,0fffah
		  a: mov si,0
			 add bx,6
 cmp bx,13
			 jg  d
		  
b: add ax,array[bx][si]
			 cmp si,3
			 jg  a
add si,2
			 jmp b
		  d: hlt
	 code ends
		  end start
</code></pre> 
<h3><a id="_645"></a>第六章</h3> 
<h5><a id="61__646"></a>6.1 画图说明下列数据定义语句所示内存空间的数据，并回答寄存器的值。</h5> 
<pre><code>ORG  0
ARRAY LABEL  BYTE
DA1  DW 2，9，14，3，315H，-6 
DA2  DB 7，‘ABCDEDFG’
LEN = $－DA2                      
ORG  100H
DA3  DW  DA4
DA4  DB  4  DUP(2 DUP(1,2,3),4)
。。。。。。
MOV  AL，ARRAY+2          （AL）=（    ）H
ADD  AL，DA2+1            （AL）=（    ）H
MOV  AX，DA2-DA1          （AX）=（    ）H
MOV  BL，LEN              （BL）=（    ）H
MOV  AX, DA3              （AX）=（    ）H
MOV  BX, TYPE  DA4        （BX）=（    ）H
MOV  BX, OFFSET  DA4      （BX）=（    ）H
MOV  CX, SIZE  DA4        （CX）=（    ）H
MOV  DX, LENGTH  DA4      （DX）=（    ）H
MOV  BX, WORD PTR  DA4    （BX）=（    ）H
MOV  BL, LEN  AND  0FH    （BL）=（    ）H
MOV  BL, LEN  GT  5       （BL）=（    ）H
MOV  AX, LEN  MOD 5       （AX）=（    ）H
答：
MOV  AL，ARRAY+2          （AL）=（ 09    ）H
ADD  AL，DA2+1            （AL）=（ 41    ）H
MOV  AX，DA2-DA1          （AX）=（ 000c  ）H
MOV  BL，LEN              （BL）=（  09   ）H
MOV  AX, DA3              （AX）=（ 0102  ）H
MOV  BX, TYPE  DA4        （BX）=（  0001 ）H
MOV  BX, OFFSET  DA4      （BX）=（  0102 ）H
MOV  CX, SIZE  DA4        （CX）=（  0004 ）H
MOV  DX, LENGTH  DA4      （DX）=（  0004 ）H
MOV  BX, WORD PTR  DA4    （BX）=（  0201 ）H
MOV  BL, LEN  AND  0FH    （BL）=（  09   ）H
MOV  BL, LEN  GT  5       （BL）=（  ff   ）H
MOV  AX, LEN  MOD 5       （AX）=（  0004 ）H
</code></pre> 
<h5><a id="62__684"></a>6.2 变量和标号有哪些区别？变量和标号有哪些属性？如何获取属性值？写出指令。</h5> 
<pre><code>答：变量是为指令提供的操作数，标号是为指令提供标识，都是为了在指令中引用。它们最主要的属性有：偏移属性，段属性，类型属性。例如：
MOV   BX， OFFSET  VAL ；取偏移属性
MOV   BX， SEG   VAL   ；取段属性
MOV   BX， TYPE  VAL   ；取类型属性
</code></pre> 
<h5><a id="63__690"></a>6.3 指令和伪指令的区别在哪里？伪指令可以出现在代码段吗？指令可以在数据段吗？</h5> 
<p>答：指令只能出现在代码段，定义数据的伪指令通常在数据段，伪指令在代码段两端也可，但不能在指令之间。</p> 
<h5><a id="64_09_693"></a>6.4 下面的程序能否输出字符0～9？如不能，应如何修改？</h5> 
<pre><code>CODE    SEGMENT
		ASSUME CS:CODE
		K=30H                
		J  DW  0
START:  MOV  DL, K
		MOV  AH, 2
		INT  21H 
		K=K+1     
		INC  J
		CMP  J, 10
		JNZ  START
		MOV  AH, 4CH
		INT  21H
CODE    ENDS
		END  START
答：通过汇编和连接可以运行，但程序真正意图是输出ASCII码为30H~39H的字符0~9，应作修改。
CODE    SEGMENT
		ASSUME CS:CODE
		K=30H                ；改为 K  DB  30H
		J  DW  0
START:  MOV  DL, K
		MOV  AH, 2
		INT  21H 
		K=K+1     ；K=K+1是伪指令，没生成代码，改为 INC  K 
		INC  J
		CMP  J, 10
		JNZ  START
		MOV  AH, 4CH
		INT  21H
CODE    ENDS
		END  START 
</code></pre> 
<h5><a id="65_16VXYR32XYR_727"></a>6.5 用16位指令编写完整程序，并上机调试，计算V=(X+Y)*R，其中所有变量均为32位变量，X、Y、R的具体数值由你自己确定，变量定义格式如下：</h5> 
<pre><code>	X    DW ?,?
	Y    DW  ?,?
	R    DW  ?,?
	V    DW 4 dup(?)
答：（32位指令）
data segment
x dw 1
y dw 2
r dw 3
v dw 4 dup(?)
data ends

code segment
assume cs:code,ds:data
.386p
start:
	mov ax,data
	mov ds,ax
	mov eax,x
	add eax,y
	mov ebx,r
	imul ebx
	mov v,eax
	mov v+4,edx
	mov dl,al
	add dl,30h
	mov ah,2
	int 21h
	mov ah,4ch
	int 21h
code ends
end start
</code></pre> 
<h5><a id="66_761"></a>6.6数据定义如下：执行下列指令，填写寄存器的值</h5> 
<pre><code>ARRAY  LABEL  BYTE
DA1  DW  2，9，14，3 
	  DA2  DB  7，‘ABCDEDF’
LEN = $－DA1                      
MOV  AL，ARRAY+2          （AL）=（      ）H
	  ADD  AL，DA2+1             （AL）=（     ）H
	  MOV  AX，DA2-DA1          （AX）=（     ）H
MOV  AX，DA1+1             （AX）=（    ）H
MOV  BL，LEN               （BL）=（     ）H

答：  MOV  AL，ARRAY+2          （AL）=（  09  ）H
	  ADD  AL，DA2+1             （AL）=（  41  ）H
	  MOV  AX，DA2-DA1          （AX）=（  0008 ）H
MOV  AX，DA1+1             （AX）=（ 0900  ）H
MOV  BL，LEN               （BL）=（  10   ）H
</code></pre> 
<h5><a id="67__779"></a>6.7 定义数据段，满足如下要求：</h5> 
<pre><code>（1）array为字符串变量：‘inspire a generation！’
（2）data1 为十六进制数：0FEDCBAH
（3）data2为二进制数：10101010B。
（4）data3为100个为零的字节变量。
（5）分配500个字的空间待用。
答： data segment 
		   Array db ‘inspire a generation!’
		   Data1 df  0fedcbah
		   Data2 db 10101010B
		   Data3 db 100 dup(0)
	   dw 500 dup(?)
data ends
</code></pre> 
<h5><a id="68__793"></a>6.8 假设程序中，数据段定义如下：</h5> 
<pre><code>  Data1 db 50 dup（？）
  Data2 dw 10 dup（0）
  Data3 dq  5 dup（2 dup（1,2））
</code></pre> 
<p>（1）用指令将数据段首地址放入数据段寄存器中。<br> （2）用一条指令将data2的第一个数据放入BX寄存器中。<br> （3）将数据段字节数放入CX寄存器。<br> 答：mov ax，data1 mov ds，ax<br> Mov bx，data2[0]<br> Mov cx, 50+10<em>2+20</em>8</p> 
<h5><a id="69_804"></a>6.9现有数据定义如下：</h5> 
<pre><code> Array1 dw  5 DUP（0）
 Array2 EQU BYTE PTR Array1
</code></pre> 
<p>请说明这两个变量之间的联系。<br> 答：当汇编后，PTR类型操作符使Array2具有Array1相同的段地址和偏移地址，但它的数据类型为字节型。</p> 
<h5><a id="610__810"></a>6.10 给出下列程序段汇编后的结果：</h5> 
<pre><code> Val1 EQU  6
 Val2 EQU  3
MOV BX,(Val1 LT 5) AND 20
MOV BX, (VAL2 GE 1) AND 30
MOV BX,(Val2  AND 5) OR (VAL1 GE 5)
MOV BX,(Val2 - VAL1) GE 5
答：MOV BX,0   MOV BX,30   MOV BX,FF   MOV BX,0
</code></pre> 
<h5><a id="611_819"></a>6.11设数据段定义如下：</h5> 
<pre><code>Data segment
   Org 20h
   Data1=4
   Data2=data1+25h
   Data3 db ‘123456’
		 Db 47h,48h
   Count EQU $-data1
  Data ends
回答下列问题：
（1）Data1的偏移地址是多少？     
（2）Count的值是多少？           
答：（1）0020h   （2）0024h
</code></pre> 
<h5><a id="612data1_833"></a>6.12现有一数据区data1，需对其进行按字和按字节访问，请问应如何进行设置？</h5> 
<p>答：可以利用“LABEL“标签进行设置，如：<br> Operator_b LABEL byte<br> Operator_w dw 100dup(0)<br> 其中按字节访问时采用Operator_b变量，按字访问时采用Operator_w变量。</p> 
<h5><a id="613PSPEXECOM_839"></a>6.13请问什么是PSP，EXE文件和COM文件有何区别？</h5> 
<p>答：PSP是程序段前缀。程序在执行前调入内存，由DOS确定装入的起始地址，建立PSP，接着再装入程序，其大小为256个字节。EXE文件和COM文件相比，COM文件只有一个段地址，由二进制代码组成，比EXE文件小，并且要求程序从偏移地址0100H单元开始，因为之前存放为PSP。</p> 
<h3><a id="_842"></a>第七章</h3> 
<h5><a id="71_3AL_843"></a>7.1 下列程序是在3个数中找出最小的数并放入AL，在括号中填入指令使其完整。</h5> 
<pre><code>	mov		al，x
	mov		bl，y
    mov		cl，z
	cmp 	al，bl
	(          )
xchg   al，bl
l1: cmp   al, cl
jle  l2
(          )
l2: ret
答：（1）jl  l1
   （2）xchg al,cl
</code></pre> 
<h5><a id="72__857"></a>7.2 数据段如下：</h5> 
<pre><code>data   segment
da1		db	1，2，‘abcd’   
count  = $-da1
			da2    db  9 dup(?)
data   ends
补充括号处的指令，使得程序把DA1数据区数据移到DA2数据区。
mov		ax，data
			mov    ds, ax
mov		es，(       )
mov		cx，(       )
			mov    si, (      )
			(         )
			(         )
答：      mov		es，( AX     )
mov		cx，( COUNT     )
			mov    si, ( OFFSET  DA1     )
			( MOV  DI, OFFSET  DA2        )
			( REP  MOVSB                )
</code></pre> 
<h5><a id="73_AXBXDEBUGDEBUG_878"></a>7.3 将AX和BX进行加、减、乘或除的运算，每种运算由用户从键盘上选择。程序中设置寄存器的值，或在DEBUG下设定寄存器值并在DEBUG下运行程序。</h5> 
<pre><code>答：code segment 
		assume cs:code 
main proc far
		push ds
		sub ax,ax
		push ax
		mov ah,1
		int 21h
		cmp al,31h   ;1加
		jz  ad
		cmp al,32h    ;2减
		jz  su
cmp al,33h   ;3乘
		jz  mu
		cmp al,34h    ;4除
		jz  di
	  ad:ADD AX,BX
		 JMP exit
	  su:SUB AX,BX
		 JMP exit
	  mu:MUL BX
		 JMP exit
	  d:DIV BX
	exit: 
		 ret
main  endp
code ends
end main
</code></pre> 
<h5><a id="74__908"></a>7.4 编写程序，从键盘接收一个小写字母，然后找出它的前导字符和后续字符，再按顺序显示这三个字母。</h5> 
<pre><code>答：code segment 
		assume cs:code 
main   proc far
		push ds
		sub ax,ax
		push ax
		mov ah,1
		int 21h
		cmp al,61h
		jb  exit
		cmp al,7ah
		ja  exit
mov bx,ax
sub al,1h    ;输出前一字符
mov dl,al
mov ah,2
int 21h
mov dl,bl    ；输出当前字符
mov ah,2
int 21h
add dl,1h    ;输出后一字符
mov ah,2
int 21h
   exit:ret
main  endp
code ends
end main
</code></pre> 
<h5><a id="75_LOOP123100AX_937"></a>7.5 分别用LOOP循环和条件转移指令实现1+2+3+……+100，并将结果存入AX。</h5> 
<pre><code>答：(1)code segment 
		assume cs:code 
main  proc  far
		push ds
		sub ax,ax
		push ax
		mov bx,1
mov ax,0
		mov cx，99
	   a:add ax,bx
		 inc bx
	   loop a
	exit:ret
code ends
end main

(2)code segment 
		assume cs:code 
main  proc  far
		push ds
		sub ax,ax
		push ax
		mov bx,1
mov ax,0
		mov cx，99
	   a:add ax,bx
		 inc bx
	   cmp bx,101
	   jnz a
exit:ret
main  endp
code ends
end main
</code></pre> 
<h5><a id="76__971"></a>7.6 打印下面图形。</h5> 
<pre><code>*
**
***
****
*****
******
答：code segment 
		assume cs:code 
main  proc  far
		push ds
		sub ax,ax
		push ax
		mov ax,1
	  a:mov cx,ax
	  b:mov ah,2
mov dl,’*’
int 21h
loop  b
cmp ax,6
jz exit
inc ax
mov ah,2
mov dl,13
int 21h
mov ah,2
mov dl,10
int 21h
jmp a
   exit:ret
code ends
end main
</code></pre> 
<h5><a id="77_AXBXAXBXDEBUG_1004"></a>7.7 将AX和BX进行加、减、乘或除的运算，每种运算由用户从键盘上选择。AX和BX可在DEBUG下设置。</h5> 
<pre><code>答：code segment 
		assume cs:code 
main proc far
		push ds
		sub ax,ax
		push ax
		mov ah,1
		int 21h
		cmp al,31h   ;1加
		jz  ad
		cmp al,32h    ;2减
		jz  su
cmp al,33h   ;3乘
		jz  mu
		cmp al,34h    ;4除
		jz  di
	  ad:ADD AX,BX
		 JMP exit
	  su:SUB AX,BX
		 JMP exit
	  mu:MUL BX
		 JMP exit
	  d:DIV BX
	exit: 
		 ret
main  endp
code ends
end main
</code></pre> 
<h5><a id="78_ARRAYARRAY_1034"></a>7.8 求已知带符号数字节数组ARRAY的平均值，ARRAY的首字节单元为数组元素的个数。</h5> 
<pre><code>答：
   data segment
	  ARRAY   db  5,01,12,23,45,F3
   data ends

code segment 
		assume cs:code 
start:  
mov ax,data
		mov ds，ax
		mov ax,0  
		mov cl,array 
		mov ch,0
		mov bl,cl
	   lea si,array+1
a:add al,array[si]
inc si
loop a
div bl
	 exit:mov  ah,4ch
		 int 21h
code ends
end start
</code></pre> 
<h5><a id="79_ARRAY6_1059"></a>7.9 编写程序，实现对无符号字数组ARRAY的6个元素从小到大排序。</h5> 
<pre><code>答: data  segment
	  array  dw 6,5,9,4,5,15,3  ;首地址单元6为元素个数
	data  ends
code  segment
	  assume cs:code,ds:data
start:
		mov   ax, data
		mov   ds, ax
		mov   di, array
k1:     mov   cx, di
		 mov   bx,0
k2:     mov   ax, array[bx]
		cmp   ax, array[bx+2]
		jl   next
		xchg ax,array[bx+2]
		mov array[bx],ax
next:   add  bx,2
		loop k2
		dec  di
		jnz  k1
	 mov   ah,4ch
		int   21h
code  ends
end   start
</code></pre> 
<h5><a id="710_SUM_1085"></a>7.10 数据段有两个等长的字数组，分别求出各自的元素之和，并存入元素后面的单元中，即横向相加。再求出两个数组的对应元素之和，并把和存入新数组SUM中，即纵向相加。</h5> 
<pre><code>答：data  segment
	  Array1  dw  3, 1,0,1,?     ；设简单数据,第一个为元素个数
	  Array2  dw  3,1,1,0,?
	  Array3  dw  3,3 dup (0)   ；存放array1,2的和
data  ends
code  segment
	  assume cs:code,ds:data
start:
		mov   ax, data
		mov   ds, ax
		mov   ax, 0
		lea   bx, array1+2
		mov   cx, array1
sumh1:  add   ax, [bx]
		add   bx,2
		loop  sumh1
		mov  [bx],ax
	  ;第二个数组累加
  mov   ax, 0
		lea   bx, array2+2
		mov   cx, array2
sumh2:  add   ax, [bx]
		add   bx,2
		loop  sumh2
		mov  [bx],ax
   lea   bx,2
mov   cx, array2
  sum3: mov   ax, array1[bx]
 add   ax, array2[bx]
		mov array3[bx],ax
 add   bx,2
		loop  sum3
exit:   mov   ah,4ch
		int   21h
code  ends
end   start
</code></pre> 
<h5><a id="711__YES_1123"></a>7.11 编写程序，比较两个从键盘输入的字符串是否相同，如果相同，则显示 ‘YES’,如果不同，则显示发现不同的字符位置。</h5> 
<pre><code>答：data  segment 
mess1   db     13,10, 'input string1:$'
mess2   db     13,10, 'input string2:$'
mess3   db     13,10, 'YES!$'
mess4   db     13,10, 'no match at $'

st1     label   byte
  max1  db      6
  act1  db      ?
  stok1 db      6 dup(?)

st2    label   byte
  max2   db      6
  act2   db      ?
  stok2  db      6 dup(?)
data  ends

code segment  
		assume cs:code, ds:data,es:data 
start:  mov ax,data
		mov ds,ax
		mov es,ax
		lea dx,mess1
		mov ah,09
		int 21h         ;qust1?
		lea dx,st1
		mov ah,0ah
		int 21h         ;ans1
		lea dx,mess2
		mov ah,09
		int 21h         ;qust2?
		lea dx,st2
		mov ah,0ah
		int 21h         ;ans2
		mov cl,act1
		mov dl,act2
		cmp cl,dl
		jnz nomatch
		mov ch,0
		lea si,stok1
		lea di,stok2
		repe cmpsb
		jnz nomatch
match:  lea dx,mess3
		mov ah,09
		int 21h
		jmp  exit
nomatch:
		lea dx,mess4
		mov ah,09
		int 21h
		sub di,offset stok2
		mov dx,di
		add dl,30h
		mov ah,2
		int 21h
exit:
		mov  ah,4ch
		int 21h        
code ends
	   end start 
</code></pre> 
<h5><a id="712_BUFFALBUFF_1186"></a>7.12 编写程序，从键盘输入一个字符串到BUFF，再输入一个字符到AL，在字符串BUFF中查找是否存在该字符，如果找到，显示发现的字符位置。</h5> 
<pre><code>答：
data  segment 
mess1   db     13,10, 'input string:$'
mess2   db     13,10, 'input a char:$'
mess3   db     13,10, 'found at $'
mess4   db     13,10, 'no found !$'

st1     label   byte
  max1  db      6
  act1  db      ?
  stok1 db      6 dup(?)

data  ends

code segment   para'code'
		assume cs:code, ds:data 
start:  mov ax,data
		mov ds,ax
		mov es,ax
		lea dx,mess1
		mov ah,09
		int 21h         ;qust1?
		lea dx,st1
		mov ah,0ah
		int 21h         ;ans1
		
		lea dx,mess2
		mov ah,09
		int 21h         ;qust2?
		
		mov ah,1
		int 21h         ;ans2
		lea di,stok1
		repne scasb
		jz match
nomatch:
		lea dx,mess4
		jmp exit
match:  lea dx,mess3

exit:
		mov ah,09
		int 21h
		sub di,offset stok1
		mov dx,di
		and dx,0fh
		add dl,30h
		mov ah,2
		int 21h
		mov ah,4ch
		int 21h        
code ends
	   end start 
</code></pre> 
<h5><a id="713_BUFF_1241"></a>7.13 编写程序，从键盘输入一个字符串到BUFF，并按相反顺序显示输出。</h5> 
<pre><code>答: 
data  segment 
mess1   db     13,10, 'input string:$'
mess2   db     13,10,'$'
st1     label   byte
  max1  db      6
  act1  db      ?
  stok1 db      6 dup(?)
data  ends

code segment   
		assume cs:code, ds:data 
start : mov ax,data
		mov ds,ax
		lea dx,mess1
		mov ah,09
		int 21h         
		lea dx,st1
		mov ah,0ah
		int 21h                 
		lea dx,mess2
		mov ah,09
		int 21h         
		mov cl,act1
		mov ch,0
		mov bx, offset stok1
		add bx, cx
 next:  dec bx
		mov dl, [bx]
		mov ah,2
		int 21h
		loop next
		mov  ah,4ch
		 int 21h       
code ends
	   end start
</code></pre> 
<h5><a id="714__1279"></a>7.14 编写程序，从键盘输入一个八位的二进制数，显示其十六进制数。</h5> 
<pre><code>答：code  segment
		assume cs:code
start:
		mov cx,8
		mov bl,0
next:   mov ah,1
		int 21h
		cmp al,30h
		jb  exit
		cmp al,31h
		ja  exit
		sub al,30h
		shl bl,1
		add bl,al
		loop next
		mov cl,4
		mov di,2
out1:   rol bl,cl
		mov dl,bl
		and dl,0fh
		add dl,30h
		cmp dl,39h
		jle dig
		add dl,7
dig:    mov ah,2
		int 21h
		dec di
		cmp di,0
		jnz out1 
exit:   mov   ah,4ch
		int   21h
code  ends
end   start
</code></pre> 
<h5><a id="715_ARRAYNNMAX_1314"></a>7.15 字数组ARRAY为有符号数，第一个单元为元素个数N，后面为N个元素，编写程序，求数组元素中的最大值，并把它放入MAX单元。</h5> 
<pre><code>答：data  segment
	  array  dw  5,9,4,5,15,3
	  max    dw  ?
data  ends
code  segment
	  assume cs:code,ds:data
start:
		mov   ax, data
		mov   ds, ax
		mov   cx, array
		lea   bx, array+2
		mov   ax, [bx]
		mov   max, ax
k1:     mov   ax, [bx]
		cmp   ax, max
		jl    next
		mov   max,ax
next:   add   bx,2
		loop   k1
		mov   ah,4ch
		int   21h
code  ends
end   start
</code></pre> 
<h5><a id="716_ARRAYNN_1339"></a>7.16 字数组ARRAY，第一个单元为元素个数N，后面为N个元素，编写程序，把零元素从数组中清除，移动元素位置并修改第一个单元(元素个数)。</h5> 
<pre><code>答：data  segment
	  array  dw  6,3,4,0,15,0,7
	  loca   dw  999        ；此单元地址为结束标记
data  ends
code  segment
	  assume cs:code,ds:data
start:
		mov   ax, data
		mov   ds, ax
		mov   cx, array
		lea   bx, array+2
next:   cmp   word ptr[bx],0
		jz    move
		add   bx,2
		dec   cx
		cmp   cx,0
		jnz   next
		jmp   exit
move:   dec   array
		mov   di,bx
mnext:
		cmp   di,offset loca
		ja    next
		mov   ax, [di+2]
		mov   [di],ax
		add   di,2
		cmp   di,offset loca
		jnb   next
		jmp   mnext
exit:   mov   ah,4ch
		int   21h
code  ends
end   start
</code></pre> 
<h3><a id="_1374"></a>第八章</h3> 
<h5><a id="81__1375"></a>8.1 过程定义如下，补充括号中的指令。</h5> 
<pre><code>code   segment
		assume	 cs:code
main   proc  far
(           )
(           )
(           )
…
…
…
ret
main    endp
code    ends
end   main
答：(  PUSH  DS         )
(  XOR  AX,AX       )
(  PUSH  AX         )
</code></pre> 
<h5><a id="82_TOSTOS_1393"></a>8.2 补充下列程序括号中的指令，使得程序对堆栈的操作全部利用程序中定义的TOS堆栈，并画出程序执行后堆栈TOS中的数据。</h5> 
<pre><code>data   segment
	   dw    100 dup(?)
  tos  label  word
data   ends
code   segment
		assume	 cs:code,ss:data
main   proc  far
(            )
(            )
(            )
push  ds
xor   ax， ax
push  ax
call  far ptr suba
… ；假定此处指令的地址为CS=3400h，IP=30h
…
…
code   ends
end   main
答：(  MOV  AX,DATA        )
(  MOV  SS,AX          )
(  LEA  SP,TOS         )
</code></pre> 
<h5><a id="83_BUFFALBUFF_1417"></a>8.3 主程序从键盘输入一个字符串到BUFF，再输入一个字符到AL，用子程序在字符串BUFF中查找是否存在该字符，如果找到，显示发现的字符位置。用寄存器传递要查找的字符。</h5> 
<pre><code>答：Data segment
BUFF1 db 16,?,16 dup(?),13,10,'$'
Data ends
Code segment
	 Assume cs:code,ds:data
Main proc far
Push ds
Xor ax,ax
Push ax
	  Mov ax,data
Mov ds,ax
Mov es,ax
Lea dx,BUFF1
Mov ah,10
Int 21h
mov ah,1
int 21h
Lea di,BUFF1+2
Mov cl,BUFF1+1
mov ch,0
Mov ah,0
Repne scasb
Jnz  ye
dec di
mov bx,di
Call BTH
Ye: ret
Main endp
BTH proc near
   mov cx,4
   s:rol bx,1
	 rol bx,1
	 rol bx,1
	 rol bx,1
	 mov al,bl
	 and al,0fh
	 add al,30h
	 cmp al,39h
	 jle d
	 add al,7
   d:mov dl,al
	 mov ah,2
	 int 21h
	 loop s
ret
BTH endp
Code ends
	 End main
</code></pre> 
<h5><a id="84__1467"></a>8.4 主程序从键盘输入一个八位的二进制数，对其作求补码操作，用子程序对求补后的值以二进制形式显示。(正数的补码=输入)</h5> 
<pre><code>答：Code segment
Assume cs:code
   Main proc far
	  Push ds
	  Xor ax,ax
	  Push ax
	  Mov bx,0
	  Mov cx,8
A:mov ah,1
  Int 21h
  Shl bx,1
Sub al,30h
Jz b     ；输入为0
INC bx   ;输入为1
B:loop a
Test bx,0080h
Jz   d
XOR bx,00FFh ;取反
INC bx
D:Call disp
Ret
Main endp
disp proc near
   mov cx,8
   shl bx,cl
 ls1:shl bx,1
	 jnc k30
	 mov dl,31h
 jmp outb
k30: mov dl,30h
outb:mov ah,2
	 int 21h
	 loop ls1
ret
disp endp
code ends
	 end main
</code></pre> 
<h5><a id="85_ABAB_1506"></a>8.5 主程序从键盘（连续）输入两个四位的十六进制数A和B，用子程序作十六进制计算A+B，并显示计算结果(二进制)。</h5> 
<pre><code>答：

data segment
   A dw ?
	B dw ?
data ends
Code segment
	 Assume cs:code,ds:data
Main proc far
	Push ds
	Xor ax,ax
	Push ax
	Mov  ax,data
   Mov ds,ax
   Call INH ;输入十六进制数到BX寄存器
	Mov A，bx
	Call INH ;输入十六进制数到BX寄存器
	Mov B,bx
	Call ad
	Ret
Main endp
INH proc near
		 mov   bx，0             ；初始化
mov   ch，4
		mov   cl，4
inchr： mov   ah，1             ；键盘输入
int   21h
cmp   al，30h           
jl    exit              ；非法输入
cmp   al，39h
jle   dig               ；输入是数字0～9
cmp   al，41h
jl    exit              ；非法输入
cmp   al，46h
jg    exit              ；非法输入
sub   al，37h           ；输入是大写a～f
jmp   ls4
dig： sub   al，30h
ls4： shl   bx，cl
add   bl，al
dec   ch
jnz   inchr
	  exit: ret
INH endp
Ad  proc near
Mov ax,a
Mov bx,b
Add bx,ax
Call disp
	Ret 
Ad endp
disp proc near
	 mov cx,16
ls1: shl bx,1
	 jnc l30
	 mov dl,31h
 jmp outb
l30; mov dl,30h
outb: mov ah,2
	  int 21h
	  loop ls1
	  ret
disp endp
Code ends 
	 End main
</code></pre> 
<h5><a id="86_NNMAX_1573"></a>8.6 某字数组为有符号数，第一个单元为元素个数N，后面为N个元素，编写通用子程序，求数组元素中的最大值，并把它放入MAX单元。</h5> 
<pre><code>答：MAX_p proc near
  Mov di,[bx]     ;个数地址
Mov si,[bx+2]   ;数组地址
Mov cx,[di]
Mov di,MAX
Xor ax,ax
Next:cmp di,[si]
	 Jg a
	 Mov di,[si]
   A: Add si,2
	 Loop next
 Mov MAX,di
ret
MAX_p endp

8.7 设有一个数组存放学生的成绩（0 ~ 100），编制一个子程序统计0 ~ 59分、60 ~ 69分、70 ~ 79分、80 ~ 89分、90 ~ 100分的人数，并分别存放到scoreE、scoreD、score C、score B及score A单元中。编写一个主程序与之配合使用。 
答：
data segment
Array db 6,9,65,78,68,86,93  ;6为学生人数，后面为6个成绩
ScoreE db ?
scoreD db ?
scoreC db ?
scoreB db ?
scoreA db ?
Data ends
Code segment
	 Assume cs:code,ds:data
Main proc far
Mov ax,data
Mov ds,ax
Mov cl,array
mov ch,0
Call class
Ret
Main endp
Class proc near
Lea si, array
next:
inc si
Mov bl, [si]
Cmp bl,60
Jl e
Cmp bl,70
Jl d
Cmp bl,80
Jl k
Cmp bl,90
Jl b
Mov dl, scoreA
Inc dl
Mov scoreA,dl
loop  next
jmp exit
B: Mov dl, scoreB
Inc dl
Mov scoreB,dl
loop next
jmp exit
k: Mov dl, scoreC
Inc dl
Mov scoreC,dl
loop next
jmp exit
D: Mov dl, scoreD
Inc dl
Mov scoreD,dl
loop next
jmp exit
E: Mov dl, scoreE
Inc dl
Mov scoreE,dl
loop next
jmp exit
exit:ret
class endp
Code ends
	 End main
</code></pre> 
<h5><a id="88__1652"></a>8.8 用多模块程序设计一个简单的计算器程序，实现整数的加减乘除。运算符可以为：+,-,*,/,=。</h5> 
<pre><code>答：
public  num1,num2,res
extrn   ad:far,su:far,mu:far,dv:far,el:far
data    segment
num1   db   ?
num2   db   ?
res    dw   ?
data    ends
code    segment
assume  cs:code,ds:data
main proc far 
push ds
sub  ax,ax
push ax
mov  ax,data             
mov  ds,ax
call DTOB
mov num1,bx
call DTOB
mov num2,bx
mov ah,1
int 21h
cmp dl,’+’
jz a
cmp dl,’-’
jz s
cmp dl,’*’
jz m
cmp dl,’/’
jz d
cmp dl,’=’
call el
jmp exit
		   a:call ad
			 jmp exit
		   s:call su
			 jmp exit
		   m:call mu
			 jmp exit
		   d:call dv
		exit:ret
main 	  endp
dtob        proc  near
mov  bx, 0
input:      mov  ah, 1                ；键盘输入
			int  21h
			sub  al, 30h              ；把ascii码转变为数值
jl  exit                  ；如不是数则退出
cmp  al, 9
jg  exit                  ；如不是数则退出
cbw                       ；扩展为字
xchg  ax,  bx             ；交换寄存器
mov  cx, 10
mul  cx                   ；a(n)= a(n-1)×10   
xchg  ax, bx              ；交换寄存器
add  bx,  ax              ；a(n)＝a(n)＋b(n)
jmp  input
exit:       ret
dtob        endp
code     ends
end main
；------------------
public  ad
extrn   num1:byte,num2:byte,res:word
code    segment
assume  cs:code
ad   proc  near
		mov ah,0
mov al,num1
add al,num2
adc ah,0
mov res,ax
		ret
order   endp
su   proc  near
		mov ah,0
mov al,num1
sub al,num2
sbb ah,0
mov res,ax
		ret
su   endp
mu   proc  near
mov al,num1
mul num2
mov res,ax
		ret
mu   endp
dv   proc  near
mov al,num1
div num2
mov res,ax
		ret
dv   endp
el   proc  near
mov al,num1
cmp al,num2
jz z
mov res,0FFFFH   ;不相等
jmp exit
		  z: mov res,0         ;相等
   exit:ret
el   endp
code    ends
end    
</code></pre> 
<h5><a id="89_9_1759"></a>8.9 从键盘输入姓名和电话号码，建立通讯录，通讯录的最大容量为9条记录，程序结束时无须保留通讯录，但程序运行时要保留通讯录信息。程序的人机界面和顺序要求如下：</h5> 
<pre><code>(1)提示信息INPUT NAME：(调用子程序INNAME录入姓名，序号自动产生)
(2)提示信息INPUT TELEPHONE NUMBER：(调用子程序INTELE录入电话号码)
(3)提示信息INPUT 序号：(调用子程序PRINT显示某人的姓名和电话号码，如果序号不存在，则提示信息 NO THIS NUMB )。
答：Inform struc
  Sn   db  ?
  Name db ‘??????’
  Telen  db  ‘???????????’
Inform ends
Data segment
   Array struc 9 dup(&lt;&gt;)
   Name db ‘INPUT NAME $’
   TEL  db  ‘INPUT TELEPHONE NUMBER $’
   number db   ‘INPUT SEQUENCE NUMBER $’
   err    db   ‘NO THIS NUMB $’
Data ends
code segment
	 assume cs:code,ds:data
main proc far
  push ds
  xor ax,ax
  push ax
 mov ax,data
mov ds,ax
mov cx,0
a:
  call inname
  call intele
  inc cx
  cmp cx,9
  jl a
call print
ret
main endp
inname proc near
push cx  
lea dx,name
  mov ah,9
  int 21h
  mov al, size array
 mul cl
 mov bx,ax
add bx,array
mov [bx].sn,cl
mov di,0
a:mov ah,1
   int 21h
   mov [bx].name[di],al
   inc di
   cmp di,6
   jl a
   pop cx
ret
inname endp
intele proc near
push cx  
lea dx,tel
  mov ah,9
  int 21h
 mov al, size array
 mul cl
 mov bx,ax
add bx,array
mov di,0
a:mov ah,1
   int 21h
   mov [bx].telen[di],al
   inc di
   cmp di,13
   jl a
   pop cx
ret
intele endp
print proc near
lea dx,number
  mov ah,9
  int 21h
mov ah,1
   int 21h
  cmp al,0
  jl ex
  cmp al,8
  jg ex
mov cl,al
  mov al, size array
  mul cl
  mov bx,ax
add bx,array
 mov dx,bx
 mov ah,9 
int 21h
mov dl,13
mov ah,2
 int 21h
mov dl,10
mov ah,2
int 21h
lea dx,[bx].telen
mov ah,9
int 21h
jmp r
ex: lea dx,err
	mov ah,9 
	int 21h
r:
ret
print endp
code ends
	 end main
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d73d7864df4bc1870d16cbccdf3d338a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python--查看函数帮助文档及快捷键使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cfcf75d0a7000e0c4d2fadf98892ca6b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">生信-使用NCBI进行目的基因的引物设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>