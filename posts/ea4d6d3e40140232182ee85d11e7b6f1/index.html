<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;面向对象（OOP）编程-多线程详解 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;面向对象（OOP）编程-多线程详解" />
<meta property="og:description" content="几乎所有的编程语言都会支持多线程、多线程是现代操作系统提高系统运行效率的一个重要的手段，在算力有限的情况下，多线程在编程方面有着重要的地位。在一般的编程语言面试中少不了对多线程的考察。本文希望能够全面的介绍并实现C&#43;&#43;中的多线程，为C&#43;&#43;多线程提供指导。
🎬个人简介：一个全栈工程师的升级之路！
📋个人专栏：C/C&#43;&#43;精进之路
🎀CSDN主页 发狂的小花
🌄人生秘诀：学习的本质就是极致重复!
目录
1 多线程介绍
1.1 线程与进程的区别
1.2 并行和并发的区别
1.3 多线程实例
1.3.1 无参线程的创建
1.3.2 有参线程的创建
1.3.3 线程的结束方式
1.4 互斥量(mutex)
1.4.1 互斥量类型
1.4.2 lock类
1.4.3 lock和unlock函数
1.4.4 std::mutex和lock、unlock的使用
1.4.5 lock_guard的使用
1.4.6 unique_lock 的使用
1.5 条件变量(condition_variable)
1.6 异步线程
1.6.1 std::future
1.6.2 std::shared_future
1.6.3 future 和 shared_future区别
1.7 原子操作（atomic）
1.8 线程池
1.8.1 线程池的优势
1 多线程介绍 要理解多线程需要理解线程和进程的区别。应用由程序和数据组成，程序中包括多个或者一个进程，进程中包括多个或者一个线程。进程的范围大于线程。
1.1 线程与进程的区别 进程是资源分配的最小单位，而线程是程序执行的最小单位。
也就是说，进程是系统中独立存在的程序关于某段时间内的动态变化过程，它拥有自己独立的地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段。
而线程则是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源。
进程和线程的生命周期也不同。进程的生命周期通常比线程长，因为线程是隶属于进程的，当进程被销毁时，线程也会随之被销毁。相反，线程可以被创建和销毁多次，只要进程还存在。
进程和线程分别属于不同的执行单元，所以他们之间的通信也有所差异。同一进程内的线程之间通信更加容易和高效，因为共享相同的地址空间和全局变量等资源。而不同进程之间的通信则通常需要借助特定的机制，如管道、信号量等。
1.2 并行和并发的区别 并发是指两个或更多的事件在同一时间段内发生，这些事件可能涉及到同一个实体，比如一个处理器。这意味着处理器在某一时刻会处理多个任务，但这些任务并不是真正同时运行的，而是通过快速切换来实现“同时执行”的效果。
并行则是指两个或者多个事件在同一时刻发生，这通常涉及到不同的实体，如多个处理器或多核的处理器。这意味着每个处理器或核心都在独立地执行不同的任务，而这些任务是真正同时运行的。
简单来说，并发关注的是任务的抽象调度，即多个任务如何分配到处理器并快速切换以实现“同时执行”的效果；而并行关注的是任务的实际执行，即多个任务如何在多个处理器上真正同时运行。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/ea4d6d3e40140232182ee85d11e7b6f1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-28T20:26:39+08:00" />
<meta property="article:modified_time" content="2023-12-28T20:26:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;面向对象（OOP）编程-多线程详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>几乎所有的编程语言都会支持多线程、多线程是现代操作系统提高系统运行效率的一个重要的手段，在算力有限的情况下，多线程在编程方面有着重要的地位。在一般的编程语言面试中少不了对多线程的考察。本文希望能够全面的介绍并实现C++中的多线程，为C++多线程提供指导。</p> 
</blockquote> 
<blockquote> 
 <p>🎬<a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B&amp;spm=1001.2101.3001.7020" title="个人简介">个人简介</a>：一个全栈工程师的升级之路！<br> 📋个人专栏：<a class="link-info" href="https://blog.csdn.net/m0_47324800/category_12475834.html?spm=1001.2014.3001.5482" title="C/C++精进之路">C/C++精进之路</a><br> 🎀CSDN主页 <a class="link-info" href="https://blog.csdn.net/m0_47324800?type=blog" title="发狂的小花">发狂的小花</a><br> 🌄人生秘诀：学习的本质就是极致重复!</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#1%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%8B%E7%BB%8D" rel="nofollow">1 多线程介绍</a></p> 
<p id="1.1%20%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#1.1%20%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">1.1 线程与进程的区别</a></p> 
<p id="1.2%20%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#1.2%20%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">1.2 并行和并发的区别</a></p> 
<p id="1.3%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E4%BE%8B-toc" style="margin-left:40px;"><a href="#1.3%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E4%BE%8B" rel="nofollow">1.3 多线程实例</a></p> 
<p id="1.3.1%20%E6%97%A0%E5%8F%82%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:80px;"><a href="#1.3.1%20%E6%97%A0%E5%8F%82%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">1.3.1 无参线程的创建</a></p> 
<p id="1.3.2%20%E6%9C%89%E5%8F%82%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:80px;"><a href="#1.3.2%20%E6%9C%89%E5%8F%82%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">1.3.2 有参线程的创建</a></p> 
<p id="1.3.3%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9D%9F%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#1.3.3%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9D%9F%E6%96%B9%E5%BC%8F" rel="nofollow">1.3.3 线程的结束方式</a></p> 
<p id="1.4%20%E4%BA%92%E6%96%A5%E9%87%8F(mutex)-toc" style="margin-left:40px;"><a href="#1.4%20%E4%BA%92%E6%96%A5%E9%87%8F%28mutex%29" rel="nofollow">1.4 互斥量(mutex)</a></p> 
<p id="1.4.1%20%E4%BA%92%E6%96%A5%E9%87%8F%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#1.4.1%20%E4%BA%92%E6%96%A5%E9%87%8F%E7%B1%BB%E5%9E%8B" rel="nofollow">1.4.1 互斥量类型</a></p> 
<p id="1.4.2%20lock%E7%B1%BB-toc" style="margin-left:80px;"><a href="#1.4.2%20lock%E7%B1%BB" rel="nofollow">1.4.2 lock类</a></p> 
<p id="1.4.3%20lock%E5%92%8Cunlock%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#1.4.3%20lock%E5%92%8Cunlock%E5%87%BD%E6%95%B0" rel="nofollow">1.4.3 lock和unlock函数</a></p> 
<p id="1.4.4%20std%3A%3Amutex%E5%92%8Clock%E3%80%81unlock%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.4.4%20std%3A%3Amutex%E5%92%8Clock%E3%80%81unlock%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">1.4.4 std::mutex和lock、unlock的使用</a></p> 
<p id="1.4.5%C2%A0lock_guard%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.4.5%C2%A0lock_guard%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">1.4.5 lock_guard的使用</a></p> 
<p id="1.4.6%C2%A0%C2%A0unique_lock%20%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.4.6%C2%A0%C2%A0unique_lock%20%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">1.4.6  unique_lock 的使用</a></p> 
<p id="1.5%20%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F(condition_variable)-toc" style="margin-left:40px;"><a href="#1.5%20%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%28condition_variable%29" rel="nofollow">1.5 条件变量(condition_variable)</a></p> 
<p id="1.6%20%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px;"><a href="#1.6%20%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B" rel="nofollow">1.6 异步线程</a></p> 
<p id="1.6.1%20std%3A%3Afuture-toc" style="margin-left:80px;"><a href="#1.6.1%20std%3A%3Afuture" rel="nofollow">1.6.1 std::future</a></p> 
<p id="1.6.2%20std%3A%3Ashared_future-toc" style="margin-left:80px;"><a href="#1.6.2%20std%3A%3Ashared_future" rel="nofollow">1.6.2 std::shared_future</a></p> 
<p id="1.6.3%20future%20%E5%92%8C%20shared_future%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#1.6.3%20future%20%E5%92%8C%20shared_future%E5%8C%BA%E5%88%AB" rel="nofollow">1.6.3 future 和 shared_future区别</a></p> 
<p id="1.7%20%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%88atomic%EF%BC%89-toc" style="margin-left:40px;"><a href="#1.7%20%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%88atomic%EF%BC%89" rel="nofollow">1.7 原子操作（atomic）</a></p> 
<p id="1.8%20%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:40px;"><a href="#1.8%20%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">1.8 线程池</a></p> 
<p id="1.8.1%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E5%8A%BF-toc" style="margin-left:80px;"><a href="#1.8.1%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E5%8A%BF" rel="nofollow">1.8.1 线程池的优势</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<p><img alt="" height="614" src="https://images2.imgbox.com/fe/ef/qMsVOodd_o.png" width="862"></p> 
<h2 id="1%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%8B%E7%BB%8D">1 多线程介绍</h2> 
<p>        要理解多线程需要理解线程和进程的区别。应用由程序和数据组成，程序中包括多个或者一个进程，进程中包括多个或者一个线程。进程的范围大于线程。</p> 
<p class="img-center"><img alt="" height="382" src="https://images2.imgbox.com/a5/33/SNhGClMa_o.png" width="592"></p> 
<h3 id="1.1%20%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">1.1 线程与进程的区别</h3> 
<p>        <strong>进程是资源分配的最小单位，而线程是程序执行的最小单位</strong>。</p> 
<p>        也就是说，进程是系统中独立存在的程序关于某段时间内的动态变化过程，它拥有自己独立的地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段。</p> 
<p>        <strong>而线程则是进程中的一个实体</strong>，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源。</p> 
<p>        进程和线程的生命周期也不同。进程的生命周期通常比线程长，因为线程是隶属于进程的，当进程被销毁时，线程也会随之被销毁。相反，线程可以被创建和销毁多次，只要进程还存在。</p> 
<p>        进程和线程分别属于不同的执行单元，所以他们之间的通信也有所差异。同一进程内的线程之间通信更加容易和高效，因为共享相同的地址空间和全局变量等资源。而不同进程之间的通信则通常需要借助特定的机制，如管道、信号量等。</p> 
<h3 id="1.2%20%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB">1.2 并行和并发的区别</h3> 
<p>        并发是指两个或更多的事件在<strong>同一时间段内发生</strong>，这些事件可能涉及到同一个实体，<strong>比如一个处理器</strong>。这意味着处理器在某一时刻会处理多个任务，但这些任务并不是真正同时运行的，而是通过快速切换来实现“同时执行”的效果。</p> 
<p>        并行则是指两个或者多个事件在<strong>同一时刻发生</strong>，这通常涉及到不同的实体，如多个处理器或多核的处理器。这意味着每个处理器或核心都在独立地执行不同的任务，而这些任务是真正同时运行的。</p> 
<p>        简单来说，并发关注的是任务的抽象调度，即多个任务如何分配到处理器并快速切换以实现“同时执行”的效果；而并行关注的是任务的实际执行，即多个任务如何在多个处理器上真正同时运行。</p> 
<h3 id="1.3%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E4%BE%8B">1.3 多线程实例</h3> 
<p>        多线程是实现并发的手段，将一个任务拆分为多个子任务使用多线程实现，以提高系统的运行效率，多线程实现的基础是指令流水线，通过指令并行完成并发。</p> 
<p>        std::thread类主要的成员函数如下：</p> 
<ol><li>std::thread()：默认构造函数，创建一个新线程对象。</li><li>std::thread(const std::thread&amp;)：拷贝构造函数，用另一个std::thread对象初始化新线程对象。</li><li>std::thread&amp; operator=(const std::thread&amp;)：赋值运算符，将一个std::thread对象的内容赋值给另一个std::thread对象。</li><li>~std::thread()：析构函数，释放由std::thread对象管理的资源。</li><li>void join()：等待线程执行完成。如果线程已经结束，则该函数立即返回。否则，它会阻塞当前线程，直到目标线程执行完毕。</li><li>void detach()：将线程与当前对象分离。分离后的线程独立运行，不再与当前对象关联。detach()函数不会阻塞当前线程，也不会等待目标线程执行完毕。</li><li>std::thread::id get_id()：获取线程的唯一标识符。这个标识符可以用于识别和跟踪线程。</li><li>bool joinable()：检查线程是否可以被join()函数阻塞。如果线程已经被分离，或者已经执行完毕，那么此函数返回false；否则返回true。</li><li>bool detached()：检查线程是否已经被分离。如果线程已经被分离，那么此函数返回true；否则返回false。</li><li>void swap(std::thread&amp; other)：交换两个std::thread对象的资源。这个函数通常用于在多线程环境中安全地交换两个std::thread对象的状态。</li></ol> 
<h4 id="1.3.1%20%E6%97%A0%E5%8F%82%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA">1.3.1 无参线程的创建</h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

int value = 0;


void handler_1()
{
    cout &lt;&lt; "Thread is created!" &lt;&lt; endl;
    for(int i = 0;i &lt; 10000;i++)
    {
        value++;
    }
}

int main (int argc, char *argv[])
{
    thread thd1 = thread(handler_1);
    cout &lt;&lt; "thd1 ID is: " &lt;&lt; thd1.get_id() &lt;&lt; endl;

    thread thd2 = thread(handler_1);

    
    cout &lt;&lt; "thd2 ID is: " &lt;&lt; thd2.get_id() &lt;&lt; endl; 

    thd1.join();
    thd2.join();

    
    cout &lt;&lt; "value: " &lt;&lt; value &lt;&lt; endl;

    return 0;
}</code></pre> 
<p>        运行结果：</p> 
<pre><code class="language-cpp">thd1 ID is: 140515887200000
Thread is created!
thd2 ID is: 140515878807296
Thread is created!
value: 19085</code></pre> 
<p>        上述代码中，没有自定义线程ID，因此线程ID使用默认的，可以通过<strong>thd1.get_id()</strong>来获取，分析结果，代码实际输出的value的值为19085，低于预期的20000，这是由于线程竞争导致的，此处应该加互斥量保护资源，下面会讲到。</p> 
<p>        为什么结果低于预期呢？因为两个线程在某一时刻可能获取到的值是一样的，这样，各自计算后得到的结果就一样，没有进行累加，所以会出现低于预期的结果。</p> 
<h4 id="1.3.2%20%E6%9C%89%E5%8F%82%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA">1.3.2 有参线程的创建</h4> 
<p>        线程参数的传递有值传递、引用传递（std::ref）、移动语义（右值引用）传递。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

int value = 0;


void handler_1(int i)
{
    cout &lt;&lt; "Thread " &lt;&lt; i &lt;&lt; " is created!" &lt;&lt; endl;
    for(int i = 0;i &lt; 10000;i++)
    {
        value++;
    }
}

void handler_2(int &amp; i)
{
    cout &lt;&lt; "Thread " &lt;&lt; i &lt;&lt; " is created!" &lt;&lt; endl;
    for(int i = 0;i &lt; 10000;i++)
    {
        value++;
    }
}

void handler_3(int &amp;&amp; i)
{
    cout &lt;&lt; "Thread " &lt;&lt; i &lt;&lt; " is created!" &lt;&lt; endl;
    for(int i = 0;i &lt; 10000;i++)
    {
        value++;
    }
}

int main (int argc, char *argv[])
{
    // 值传递
    int thID1 = 1;
    thread thd1 = thread(handler_1,thID1);
    cout &lt;&lt; "thd1 ID is: " &lt;&lt; thd1.get_id() &lt;&lt; endl;

    // 引用传递
    int thID2 = 2;
    thread thd2 = thread(handler_2,std::ref(thID2));
    cout &lt;&lt; "thd2 ID is: " &lt;&lt; thd2.get_id() &lt;&lt; endl; 

    // 移动语义
    int thID3 = 3;
    thread thd3 = thread(handler_3,std::move(thID3));
    cout &lt;&lt; "thd3 ID is: " &lt;&lt; thd3.get_id() &lt;&lt; endl; 

    thd1.join();
    thd2.join();
    thd3.join();

    cout &lt;&lt; "value: " &lt;&lt; value &lt;&lt; endl;

    return 0;
}</code></pre> 
<p>        运行结果：</p> 
<pre><code class="language-cpp">thd1 ID is: 139773455705856
Thread 1 is created!
thd2 ID is: 139773447313152
Thread 2 is created!
thd3 ID is: 139773438920448
Thread 3 is created!
value: 29995</code></pre> 
<p>        注意C++中没有提供直接线程的返回值，可以通过传递共享指针方式、封装类、或者使用furture和promise来达到得到线程返回值的方式。这点与C语言不同，C语言的线程可以直接返回值，然后利用thd.join(&amp;argv)中的 argv实现返回值类型的获取。可以参考我之前写的<a class="link-info" href="https://blog.csdn.net/m0_47324800/article/details/134311018" title="C语言多线程机制">C语言多线程机制</a></p> 
<h4 id="1.3.3%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9D%9F%E6%96%B9%E5%BC%8F">1.3.3 线程的结束方式</h4> 
<p>        线程的结束方式指的是线程的分离状态，分为分离线程（detach）和可汇合线程（join）。</p> 
<p>        <strong>分离线程（</strong>detach式）：主动结束，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。主线程不会等待子线程结束。如果主线程运行结束，程序则结束。</p> 
<p>        可汇合线程（join式）：等待启动的线程完成，才会继续往下执行。join后面的代码不会被执行，除非子线程结束。</p> 
<p><strong>        如果 std::thread 对象销毁之前还没有做出决定，程序就会终止。一般</strong>可以使用<strong>joinable</strong>判断是join模式还是detach模式。       </p> 
<p><strong>join式：</strong>（父线程等待子线程结束后，才执行后面的语句）</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

int value = 0;


int handler_1(int i)
{
    cout &lt;&lt; "Thread " &lt;&lt; i &lt;&lt; " is created!" &lt;&lt; endl;
    for(int i = 0;i &lt; 10000;i++)
    {
        value++;
    }

    return value;
}

int main (int argc, char *argv[])
{
    // 值传递
    int thID1 = 1;
    thread thd1 = thread(handler_1,thID1);
    cout &lt;&lt; "thd1 ID is: " &lt;&lt; thd1.get_id() &lt;&lt; endl;

    thd1.join();

    cout &lt;&lt; "value: " &lt;&lt; value &lt;&lt; endl;

    return 0;
}</code></pre> 
<p>        运行结果：<br>  </p> 
<pre><code class="language-cpp">Thread 1 is created!
thd1 ID is: 140115378468608
value: 10000</code></pre> 
<p><strong>detach式：</strong>（父线程不等待子线程结束就执行后面的语句）</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

int value = 0;


int handler_1(int i)
{
    cout &lt;&lt; "Thread " &lt;&lt; i &lt;&lt; " is created!" &lt;&lt; endl;
    for(int i = 0;i &lt; 10000;i++)
    {
        value++;
    }

    return value;
}

int main (int argc, char *argv[])
{
    // 值传递
    int thID1 = 1;
    thread thd1 = thread(handler_1,thID1);
    cout &lt;&lt; "thd1 ID is: " &lt;&lt; thd1.get_id() &lt;&lt; endl;

    thd1.detach();

    cout &lt;&lt; "value: " &lt;&lt; value &lt;&lt; endl;

    return 0;
}</code></pre> 
<p>        运行结果：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

int value = 0;


int handler_1(int i)
{
    cout &lt;&lt; "Thread " &lt;&lt; i &lt;&lt; " is created!" &lt;&lt; endl;
    for(int i = 0;i &lt; 10000;i++)
    {
        value++;
    }

    return value;
}

int main (int argc, char *argv[])
{
    // 值传递
    int thID1 = 1;
    thread thd1 = thread(handler_1,thID1);
    cout &lt;&lt; "thd1 ID is: " &lt;&lt; thd1.get_id() &lt;&lt; endl;

    thd1.detach();

    cout &lt;&lt; "value: " &lt;&lt; value &lt;&lt; endl;

    return 0;
}</code></pre> 
<p>        运行结果：</p> 
<pre><code class="language-cpp">Thread thd1 ID is: 1 is created!140537962235648

value: 2822</code></pre> 
<p>        1，线程是在thread对象被定义的时候开始执行的，而不是在调用join函数时才执行的，调用join函数只是阻塞等待线程结束并回收资源。</p> 
<p>        2，分离的线程（执行过detach的线程）会在调用它的线程结束或自己结束时释放资源。</p> 
<p>        3，没有执行<code>join</code>或<code>detach</code>的线程在程序结束时会引发异常</p> 
<h3 id="1.4%20%E4%BA%92%E6%96%A5%E9%87%8F(mutex)">1.4 互斥量(mutex)</h3> 
<h4 id="1.4.1%20%E4%BA%92%E6%96%A5%E9%87%8F%E7%B1%BB%E5%9E%8B">1.4.1 互斥量类型</h4> 
<p>        &lt;mutex&gt;中提供了多种互斥量的类，主要有4种，如下：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:490px;"><tbody><tr><td style="width:206px;">类型</td><td style="width:279px;">说明</td></tr><tr><td style="width:206px;">std::mutex</td><td style="width:279px;">基础的mutex类</td></tr><tr><td style="width:206px;">std::recursive_mutex</td><td style="width:279px;">递归mutex类</td></tr><tr><td style="width:206px;">std::time_mutex</td><td style="width:279px;">定时mutex类</td></tr><tr><td style="width:206px;">std::recursive_timed_mutex</td><td style="width:279px;">定时递归mutex类</td></tr></tbody></table> 
<h4 id="1.4.2%20lock%E7%B1%BB">1.4.2 lock类</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:563px;"><tbody><tr><td style="width:150px;">std::lock_guard</td><td style="width:409px;">创建即加锁，<strong>作用域结束自动析构并解锁</strong>，无需手工解锁<br><strong>不能中途解锁</strong>，必须等作用域结束才解锁<br> 不能复制</td></tr><tr><td style="width:150px;">std::unique_lock</td><td style="width:409px;">创建时可以不锁定（通过指定第二个参数为std::defer_lock），而在需要时再锁定<br><strong>可以随时加锁解锁</strong><br><strong>作用域规则同 lock_guard，析构时自动释放锁</strong><br> 不可复制，可移动<br> 条件变量需要该类型的锁作为参数（此时必须使用unique_lock）</td></tr></tbody></table> 
<p></p> 
<h4 id="1.4.3%20lock%E5%92%8Cunlock%E5%87%BD%E6%95%B0">1.4.3 lock和unlock函数</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:452px;"><tbody><tr><td style="width:106px;">std::lock()</td><td style="width:342px;">资源上锁</td></tr><tr><td style="width:106px;">std::unlock()</td><td style="width:342px;">资源上锁</td></tr><tr><td style="width:106px;">std::trylock()</td><td style="width:342px;"> <p>查看是否上锁，它有下列3种类情况：</p> <p>（1）未上锁返回false，并锁住；<br> （2）其他线程已经上锁，返回true；<br> （3）同一个线程已经对它上锁，将会产生死锁。</p> </td></tr><tr><td style="width:106px;">std::call_once()</td><td style="width:342px;">如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。</td></tr></tbody></table> 
<h4 id="1.4.4%20std%3A%3Amutex%E5%92%8Clock%E3%80%81unlock%E7%9A%84%E4%BD%BF%E7%94%A8">1.4.4 std::mutex和lock、unlock的使用</h4> 
<p>        C++的互斥量在 &lt;mutex&gt;中，互斥量也叫互斥锁。互斥锁是一种同步原语，用于保护共享资源，防止多个线程同时访问。当一个线程拥有互斥锁时，其他线程必须等待该线程释放锁才能访问共享资源。</p> 
<p>现在对1.3.1中的例子进行改进，如下：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

using namespace std;

std::mutex mtx;
int value = 0;


void handler_1()
{
    mtx.lock();
    cout &lt;&lt; "Thread is created!" &lt;&lt; endl;
    for(int i = 0;i &lt; 10000;i++)
    {
        value++;
    }
    mtx.unlock();
}

int main (int argc, char *argv[])
{
    thread thd1 = thread(handler_1);
    cout &lt;&lt; "thd1 ID is: " &lt;&lt; thd1.get_id() &lt;&lt; endl;

    thread thd2 = thread(handler_1);

    
    cout &lt;&lt; "thd2 ID is: " &lt;&lt; thd2.get_id() &lt;&lt; endl; 

    thd1.join();
    thd2.join();

    
    cout &lt;&lt; "value: " &lt;&lt; value &lt;&lt; endl;

    return 0;
}</code></pre> 
<p>        运行结果：</p> 
<pre><code class="language-cpp">Thread is created!thd1 ID is: 
139713576343296
thd2 ID is: 139713567950592
Thread is created!
value: 20000</code></pre> 
<p>       分析代码可知，此时无论执行多少次程序，value的值始终是20000。</p> 
<h4 id="1.4.5%C2%A0lock_guard%E7%9A%84%E4%BD%BF%E7%94%A8">1.4.5 lock_guard的使用</h4> 
<pre><code class="language-cpp">#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

int value = 0;
std::mutex mtx;  // protects g_i，用来保护g_i

void safe_increment()
{
    const std::lock_guard&lt;std::mutex&gt; lock(mtx);
    for (int i = 0;i &lt; 10000;i++)
    {
        ++value;
    }
    
    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; ": " &lt;&lt; value &lt;&lt; '\n';
    // mtx 自动解锁
}

int main()
{
	std::cout &lt;&lt; "main id: " &lt;&lt;std::this_thread::get_id()&lt;&lt;std::endl;
    std::cout &lt;&lt; "main: " &lt;&lt; value &lt;&lt; '\n';

    std::thread t1(safe_increment);
    std::thread t2(safe_increment);

    t1.join();
    t2.join();

    std::cout &lt;&lt; "main: " &lt;&lt; value &lt;&lt; '\n';
}</code></pre> 
<p>        运行结果：</p> 
<pre><code class="language-cpp">main id: 140587614791488
main: 0
140587596809984: 10000
140587588417280: 20000
main: 20000</code></pre> 
<h4 id="1.4.6%C2%A0%C2%A0unique_lock%20%E7%9A%84%E4%BD%BF%E7%94%A8">1.4.6  unique_lock 的使用</h4> 
<p>例子1：</p> 
<pre><code class="language-cpp">#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;
struct Person {
    explicit Person(int num) : num_things{num} {}

    int num_things;
    std::mutex m;
};

void handler(Person &amp;from, Person &amp;to, int num)
{
    // defer_lock表示暂时unlock，默认自动加锁
    std::unique_lock&lt;std::mutex&gt; lock1(from.m, std::defer_lock);
    std::unique_lock&lt;std::mutex&gt; lock2(to.m, std::defer_lock);

    //两个同时加锁
    std::lock(lock1, lock2);//或者使用lock1.lock()

    from.num_things -= num; // 90  95
    to.num_things += num;   // 60  55
    //作用域结束自动解锁,也可以使用lock1.unlock()手动解锁
}

int main()
{
    Person acc1(100);
    Person acc2(50);

    std::thread t1(handler, std::ref(acc1), std::ref(acc2), 10);
    std::thread t2(handler, std::ref(acc2), std::ref(acc1), 5);

    t1.join();
    t2.join();
    std::cout &lt;&lt; "acc1 num_things: " &lt;&lt; acc1.num_things &lt;&lt; std::endl;
    std::cout &lt;&lt; "acc2 num_things: " &lt;&lt; acc2.num_things &lt;&lt; std::endl;
}</code></pre> 
<p>        运行结果：</p> 
<pre><code class="language-cpp">acc1 num_things: 95
acc2 num_things: 55</code></pre> 
<p>例子2：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;mutex&gt;
using namespace std;
mutex m;

void handler1(int &amp; a)
{
    unique_lock&lt;mutex&gt; g1(m, defer_lock);   //始化了一个没有加锁的mutex
 
    g1.lock();  //手动加锁，注意，不是m.lock()
    cout &lt;&lt; "proc1函数正在改写a" &lt;&lt; endl;
    cout &lt;&lt; "proc1函数a为" &lt;&lt; a &lt;&lt; endl;
    a = a+2;
    cout &lt;&lt; "proc1函数a+2为" &lt;&lt; a &lt;&lt; endl;
    g1.unlock();    //临时解锁
    cout &lt;&lt; "尝试自动解锁" &lt;&lt; endl;
    g1.lock();
    cout &lt;&lt; "运行后自动解锁" &lt;&lt; endl;
}   //自动解锁
 
void handler2(int &amp; a)
{
    unique_lock&lt;mutex&gt; g2(m, try_to_lock);  //尝试加锁，但如果没有锁定成功，会立即返回，不会阻塞在那里
    cout &lt;&lt; "proc2函数正在改写a" &lt;&lt; endl;
    cout &lt;&lt; "proc2函数a为" &lt;&lt; a &lt;&lt; endl;
    a = a+1;
    cout &lt;&lt; "proc2函数a+1为" &lt;&lt; a &lt;&lt; endl;
}   //自动解锁
 
int main()
{
    int a = 0;
    thread t1(handler1, ref(a));
    thread t2(handler2, ref(a));
    t1.join();
    t2.join();

    cout &lt;&lt; "最后a: " &lt;&lt; a &lt;&lt; endl;
    return 0;
}</code></pre> 
<p>        unique_lock支持所有权的转移:</p> 
<pre><code class="language-cpp">mutex m;
{  
    unique_lock&lt;mutex&gt; T1(m,defer_lock);
    unique_lock&lt;mutex&gt; T2(move(T1));//所有权转移，此时由T2来管理互斥量m
    T2.lock();
    T2.unlock();
    T2.lock();
}</code></pre> 
<h3 id="1.5%20%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F(condition_variable)">1.5 条件变量(condition_variable)</h3> 
<p>C++条件变量是一种同步原语，用于在多线程编程中实现线程间的通信。它允许一个或多个线程等待某个条件成立，当条件成立时，唤醒等待的线程继续执行。</p> 
<p>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：</p> 
<p>1，一个线程等待条件变量的条件成立而挂起;</p> 
<p>2，另一个线程使条件成立（给出条件成立信号）。</p> 
<p><strong>condition_variable条件变量可以阻塞（wait、wait_for、wait_until）调用的线程直到使用（notify_one或notify_all）通知恢复为止</strong>。</p> 
<p>头文件&lt;condition_variable&gt;</p> 
<ul><li>condition_variable</li><li>​condition_variable_any</li></ul> 
<p>相同点：两者都能与std::mutex一起使用。</p> 
<p>不同点：前者仅限于与 std::mutex 一起工作，而后者可以和任何满足最低标准的互斥量一起工作，从而加上了_any的后缀。condition_variable_any会产生额外的开销。</p> 
<p>注意：</p> 
<p>1，一般只推荐使用condition_variable。除非对灵活性有硬性要求，才会考虑condition_variable_any。</p> 
<p>2，condition_variable必须结合unique_lock使用</p> 
<p>3，condition_variable是一个类，这个类既有构造函数也有析构函数，使用时需要构造对应condition_variable对象</p> 
<p><strong>例子1：（wait)</strong></p> 
<p>当前线程调用 wait() 后将被阻塞(此时当前线程应该获得了锁（mutex），不妨设获得锁 lck)，直到另外某个线程调用 notify_* 唤醒了当前线程。</p> 
<p>在线程被阻塞时，该函数会自动调用 lck.unlock() 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知(notified，通常是另外某个线程调用 notify_* 唤醒了当前线程)，wait()函数也是自动调用 lck.lock()，使得lck的状态和 wait 函数被调用时相同。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;

std::mutex mtx; // 互斥锁
std::condition_variable cv; // 条件变量
bool ready = false; // 全局标志位

void print_id(int id) {
    std::unique_lock&lt;std::mutex&gt; lck(mtx);
    while (!ready) { // 如果标志位为false，等待
        cv.wait(lck); // 释放锁并等待条件变量唤醒
    }
    // 打印线程ID
    std::cout &lt;&lt; "thread " &lt;&lt; id &lt;&lt; ' ' &lt;&lt; std::endl;
}

void go() {
    std::unique_lock&lt;std::mutex&gt; lck(mtx);
    ready = true; // 设置标志位为true
    cv.notify_all(); // 唤醒所有等待的线程
}

int main() {
    std::thread threads[10];
    for (int i = 0; i &lt; 10; ++i) {
        threads[i] = std::thread(print_id, i);
    }

    std::cout &lt;&lt; "10 threads ready to race...";
    go(); // 通知所有线程开始比赛

    for (auto&amp; th : threads) {
        th.join(); // 等待所有线程结束
    }

    return 0;
}</code></pre> 
<p>        运行结果：</p> 
<pre><code class="language-cpp">10 threads ready to race...thread 6 
thread 2 
thread 4 
thread 5 
thread 7 
thread 8 
thread 9 
thread 1 
thread 3 
thread 0 </code></pre> 
<p><strong>例子：(wait_for)</strong></p> 
<p>与std::condition_variable::wait() 类似，不过 wait_for可以指定一个时间段，在当前线程收到通知或者指定的时间 rel_time 超时之前，该线程都会处于阻塞状态。 而一旦超时或者收到了其他线程的通知，wait_for返回，剩下的处理步骤和 wait()类似。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;           // std::cout
#include &lt;thread&gt;             // std::thread
#include &lt;chrono&gt;             // std::chrono::seconds
#include &lt;mutex&gt;              // std::mutex, std::unique_lock
#include &lt;condition_variable&gt; // std::condition_variable, std::cv_status

std::condition_variable cv;

int value;

void read_value() {
  std::cin &gt;&gt; value;
  cv.notify_one();
}

int main ()
{
  std::cout &lt;&lt; "Please, enter an integer (I'll be printing dots): \n";
  std::thread th (read_value);

  std::mutex mtx;
  std::unique_lock&lt;std::mutex&gt; lck(mtx);
  while (cv.wait_for(lck,std::chrono::seconds(1))==std::cv_status::timeout) {
    std::cout &lt;&lt; '.' &lt;&lt; std::endl;
  }
  std::cout &lt;&lt; "You entered: " &lt;&lt; value &lt;&lt; '\n';

  th.join();

  return 0;
}</code></pre> 
<p>        运行结果：</p> 
<pre><code class="language-cpp">Please, enter an integer (I'll be printing dots): 
.
.
10
You entered: 10</code></pre> 
<h3 id="1.6%20%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B">1.6 异步线程</h3> 
<h4 id="1.6.1%20std%3A%3Afuture">1.6.1 std::future</h4> 
<p>C++中的异步线程可以通过<code>std::async</code>函数实现。<code>std::async</code>函数会创建一个新的线程来执行给定的可调用对象，并返回一个<code>std::future</code>对象，用于获取异步任务的结果。</p> 
<p>例子：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;chrono&gt;

int main() {
    // 创建一个异步任务，执行一个耗时的操作
    std::future&lt;int&gt; result = std::async(std::launch::async, []() {
        std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作
        return 42; // 返回结果
    });

    // 在等待异步任务完成的同时，可以执行其他操作
    std::cout &lt;&lt; "Doing something else..." &lt;&lt; std::endl;

    // 获取异步任务的结果
    int value = result.get();
    std::cout &lt;&lt; "Result: " &lt;&lt; value &lt;&lt; std::endl;

    return 0;
}
</code></pre> 
<h4 id="1.6.2%20std%3A%3Ashared_future">1.6.2 std::<code>shared_future</code></h4> 
<p><code>shared_future</code>是C++17中引入的一个异步线程库，它允许多个线程共享一个异步任务的结果。<code>shared_future</code>是一个模板类，可以用于存储任何类型的结果。它提供了一种机制，使得多个线程可以等待异步任务完成并获取其结果。</p> 
<p>使用<code>shared_future</code>的基本步骤如下：</p> 
<ol><li>创建一个异步任务，例如使用<code>std::async</code>函数。</li><li>将异步任务的结果存储在一个<code>shared_future</code>对象中。</li><li>在需要获取结果的线程中，调用<code>shared_future</code>对象的<code>wait()</code>方法等待异步任务完成。</li><li>调用<code>shared_future</code>对象的<code>get()</code>方法获取异步任务的结果。</li></ol> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;thread&gt;

int main() {
    // 创建一个异步任务，计算两个数的和
    std::future&lt;int&gt; result = std::async([]() {
        std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时操作
        return 42 + 84;
    });

    // 在主线程中等待异步任务完成
    result.wait();

    // 获取异步任务的结果
    int sum = result.get();

    std::cout &lt;&lt; "The sum is: " &lt;&lt; sum &lt;&lt; std::endl;

    return 0;
}
</code></pre> 
<h4 id="1.6.3%20future%20%E5%92%8C%20shared_future%E5%8C%BA%E5%88%AB">1.6.3 future 和 shared_future区别</h4> 
<p>future与shard_future的用途都是为了占位，但是两者有些许差别。future的get()成员函数是转移数据所有权；shared_future的get()成员函数是复制数据。</p> 
<p>future对象的get()只能调用一次；无法实现多个线程等待同一个异步线程，一旦其中一个线程获取了异步线程的返回值，其他线程就无法再次获取。<br> shared_future对象的get()可以调用多次；可以实现多个线程等待同一个异步线程，每个线程都可以获取异步线程的返回值。</p> 
<h3 id="1.7%20%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%88atomic%EF%BC%89">1.7 原子操作（atomic）</h3> 
<p>        C++ atomic是C++11标准库中提供的一种用于多线程编程的原子类型，它可以保证对某个变量的操作是原子性的，即不会被其他线程打断。</p> 
<p>C++ atomic类型提供了一些基本的原子操作，例如：</p> 
<ul><li>load：读取一个原子变量的值。</li><li>store：将一个值赋给一个原子变量。</li><li>compare_exchange_weak：比较并交换原子变量的值，如果当前值等于预期值，则将其设置为新值。</li><li>compare_exchange_strong：比较并交换原子变量的值，如果当前值等于预期值，则将其设置为新值，否则不进行任何操作。</li><li>fetch_add：将原子变量的值加1。</li><li>fetch_sub：将原子变量的值减1。</li><li>fetch_and：将原子变量的值与给定值按位与。</li><li>fetch_or：将原子变量的值与给定值按位或。</li><li>fetch_xor：将原子变量的值与给定值按位异或。</li></ul> 
<p>使用C++ atomic类型可以有效地避免多线程并发访问共享数据时出现的竞争条件和数据不一致的问题，并且不会。</p> 
<p>使用atomic的变量可以减少锁的使用，提高效率，并保证数据访问的一致性问题。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include "common.h"

namespace ATOMIC_DAY27
{
    /*
        C++中的atomic是用于实现原子操作的类模板，它位于头文件中。原子操作是指在多线程环境下，一个操作是不可分割的，不会被其他线程打断。
        atomic提供了一种简单、安全的方式来进行原子操作，避免了使用锁和互斥量等复杂的同步机制。

        atomic支持以下几种类型的数据：

        整数类型（如int、long、short、char等）
        指针类型
        用户自定义类型
    */

    std::atomic&lt;int&gt; count(0); // 定义一个原子整数变量count，初始值为0
    void increase() {
        for (int i = 0; i &lt; 10000; ++i) {
            count.fetch_add(1, std::memory_order_relaxed); // 以relaxed内存序增加count的值
        }
    }

};

namespace NORMAL_DAY27
{
    int count = 0;

    void increase() {
        for (int i = 0; i &lt; 10000; ++i) {
            count++;
        }
    }
};


int main() {

    {
        __LOG__("atomic");
        using namespace ATOMIC_DAY27;
        std::thread t1(increase); // 创建一个线程t1执行increase函数
        std::thread t2(increase); // 创建一个线程t2执行increase函数

        t1.join(); // 等待线程t1执行完毕
        t2.join(); // 等待线程t2执行完毕

        std::cout &lt;&lt; "count: " &lt;&lt; count &lt;&lt; std::endl; // 输出count的值
    }

    {
        __LOG__("normal");
        using namespace NORMAL_DAY27;
        std::thread t1(increase); // 创建一个线程t1执行increase函数
        std::thread t2(increase); // 创建一个线程t2执行increase函数

        t1.join(); // 等待线程t1执行完毕
        t2.join(); // 等待线程t2执行完毕

        std::cout &lt;&lt; "count: " &lt;&lt; count &lt;&lt; std::endl; // 输出count的值
    }


    return 0;
}
</code></pre> 
<p>        运行结果：</p> 
<p><img alt="" height="158" src="https://images2.imgbox.com/ae/7c/btgExUV0_o.png" width="339"></p> 
<p>        由结果分析可知，atomic的变量在不使用锁的情况下，保证了数据访问的一致性。</p> 
<h3 id="1.8%20%E7%BA%BF%E7%A8%8B%E6%B1%A0">1.8 线程池</h3> 
<p>        线程池是一种多线程处理形式，通常包含一组预先创建的线程和一个任务队列。在系统启动时，线程池会创建大量空闲的线程，并且一直存活着，等待新的任务到来。当有一个新的任务到来时，线程池中的一个线程会被选中来执行这个任务。任务完成后，该线程并不会被销毁，而是会继续留在线程池中，等待下一个任务的到来。</p> 
<p>        线程池内部主要由任务队列、一组线程以及一个管理者线程组成。其中，任务队列用于存放待执行的任务，线程组中的每个线程都负责执行任务队列中的任务，而管理者线程则负责管理工作队列和线程组。</p> 
<p>此外，需要注意的是，线程池是消费者生产者模型的其中之一，这里面的线程同步很重要，稍不注意就会造成死锁。主要用的是互斥锁mutex。</p> 
<p>使用线程池可以显著提高程序的性能。因为线程的创建和销毁需要消耗大量的系统资源，通过重复利用已创建的线程，可以大大减少这部分开销。此外，合理管理线程池中的线程数量也可以避免因线程过多而导致的资源竞争问题。</p> 
<h4 id="1.8.1%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E5%8A%BF">1.8.1 线程池的优势</h4> 
<ol><li> <p>降低资源消耗：通过重复利用已创建的线程，减少因线程创建和销毁造成的系统资源消耗。</p> </li><li> <p>提高响应速度：当任务到达时，线程池中已有空闲线程可以立即执行任务，无需等待线程的创建。</p> </li><li> <p>提高线程的可管理性：线程是稀缺资源，无限制地创建线程不仅会消耗系统资源，还可能降低系统的稳定性。使用线程池可以进行统一的分配、监控和调优，有效提升线程的管理效率。</p> </li><li> <p>实现某些与时间相关的功能：如定时任务，周期执行等。</p> </li><li> <p>隔离线程环境：一个线程专门执行耗时任务，另外一个线程执行响应要求高的任务。</p> </li></ol> 
<p></p> 
<blockquote> 
 <p>🌈我的分享结束了🌈<br> 如果我的分享也能对你有帮助，那就太好了！<br> 若有不足，还请大家多多指正，我们一起学习交流！<br> 📢未来的富豪们：点赞👍→收藏⭐→关注🔍<br> 感谢大家的观看和支持！最后，☺祝愿大家每天有钱赚！！！</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cac61b4e389de8b7506e9c1f6144dfb3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【新版Hi3559AV100 旗舰8K30 AI摄像机芯片】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f68caa8209fab6006d5ab0cd310d9c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">牛客网SQL训练4—SQL进阶挑战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>