<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;11 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;11" />
<meta property="og:description" content="C&#43;&#43;11简介 在2003年C标准委员会曾经提交了一份技术勘误表(简称TC1)，使得C03这个名字已经取代了C98称为C11之前的最新C标准名称。不过由于C03(TC1)主要是对C98标准中的漏洞进行修复，语言的核心部分则没有改动，因此人们习惯性的把两个标准合并称为C98/03标准。从C0x到C11，C标准10年磨一剑，第二个真正意义上的标准珊珊来迟。相比于C98/03，C11则带来了数量可观的变化，其中包含了约140个新特性，以及对C03标准中约600个缺陷的修正，这使得C11更像是从C98/03中孕育出的一种新语言。相比较而言，C&#43;&#43;11能更好地用于系统开发和库开发、语法更加泛华和简单化、更加稳定和安全，不仅功能更强大，而且能提升程序员的开发效率，公司实际项目开发中也用得比较多，所以我们要作为一个重点去学习。
小故事：
1998年是C标准委员会成立的第一年，本来计划以后每5年视实际需要更新一次标准，C国际标准委员会在研究C&#43;&#43; 03的下一个版本的时候，一开始计划是2007年发布，所以最初这个标准叫C&#43;&#43; 07。但是到06年的时候，官方觉得2007年肯定完不成C&#43;&#43; 07，而且官方觉得2008年可能也完不成。最后干脆叫C&#43;&#43; 0x。x的意思是不知道到底能在07还是08还是09年完成。结果2010年的时候也没完成，最后在2011年终于完成了C标准。所以最终定名为C11。
列表初始化{} 在C&#43;&#43;98中，标准允许使用花括号对数组或者结构体元素进行统一的列表初始值设定。
struct A { int a; } int main() { int arr[] = {1, 2}; A a = {1}; return 0; } C&#43;&#43;中定义了几种不同的初始化方式，现在我们要将一个int类型的变量a初始化为0.
int a = 0; int a = {0}; int a{0}; int a(0); int main() { int a = 0; int a1 = { 0 }; int a2{ 0 }; int a3(0); int arr[]{ 1,2,3 }; int arr1[5]{ 0 }; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; a1 &lt;&lt; endl; cout &lt;&lt; a2 &lt;&lt; endl; cout &lt;&lt; a3 &lt;&lt; endl; return 0; } 输出结果 0 0 0 0。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/657433f6e7daa506474f81184bfa66ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-14T15:04:27+08:00" />
<meta property="article:modified_time" content="2023-10-14T15:04:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;11</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="u7e27d9fa"></p> 
<p id="u0383f518"></p> 
<h2 id="e788b9b3">C++11简介</h2> 
<p id="u6acbfe46"></p> 
<p id="ub9a72785">在2003年C标准委员会曾经提交了一份技术勘误表(简称TC1)，使得C03这个名字已经取代了C98称为C11之前的最新C标准名称。不过由于C03(TC1)主要是对C98标准中的漏洞进行修复，语言的核心部分则没有改动，因此人们习惯性的把两个标准合并称为C98/03标准。从C0x到C11，C标准10年磨一剑，第二个真正意义上的标准珊珊来迟。相比于C98/03，C11则带来了数量可观的变化，其中包含了约140个新特性，以及对C03标准中约600个缺陷的修正，这使得C11更像是从C98/03中孕育出的一种新语言。相比较而言，C++11能更好地用于系统开发和库开发、语法更加泛华和简单化、更加稳定和安全，不仅功能更强大，而且能提升程序员的开发效率，公司实际项目开发中也用得比较多，所以我们要作为一个重点去学习。</p> 
<p id="ub7a73e82"></p> 
<p id="u639a8b74">小故事：<br> 1998年是C标准委员会成立的第一年，本来计划以后每5年视实际需要更新一次标准，C国际标准委员会在研究C++ 03的下一个版本的时候，一开始计划是2007年发布，所以最初这个标准叫C++ 07。但是到06年的时候，官方觉得2007年肯定完不成C++ 07，而且官方觉得2008年可能也完不成。最后干脆叫C++ 0x。x的意思是不知道到底能在07还是08还是09年完成。结果2010年的时候也没完成，最后在2011年终于完成了C标准。所以最终定名为C11。</p> 
<p id="u975448e3"></p> 
<h2 id="d5746193">列表初始化{}</h2> 
<p id="u1d97ef41"></p> 
<p id="ua4eb2476">在C++98中，标准允许使用花括号对数组或者结构体元素进行统一的列表初始值设定。</p> 
<p id="u80877aba"></p> 
<pre id="be459d22"><code>struct A
{
int a;
}

int main()
{
    int arr[] = {1, 2};
    A a = {1};
    return 0;
}</code></pre> 
<hr id="IMoeK"> 
<p id="u982a476d">C++中定义了几种不同的初始化方式，现在我们要将一个int类型的变量a初始化为0.</p> 
<p id="u848b8b55"></p> 
<pre id="565b924d"><code>int a = 0;
int a = {0};
int a{0};
int a(0);


int main()
{
    int a = 0;
    int a1 = { 0 };
    int a2{ 0 };
    int a3(0);
    int arr[]{ 1,2,3 };
    int arr1[5]{ 0 };

    cout &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; a1 &lt;&lt; endl;
    cout &lt;&lt; a2 &lt;&lt; endl;
    cout &lt;&lt; a3 &lt;&lt; endl;

    return 0;
}</code></pre> 
<p id="u5c389aa8"></p> 
<p id="u357d1668"><code>输出结果 0 0 0 0</code>。</p> 
<p id="uc34f2a06"></p> 
<p id="uf33f2856">C++11扩大了花括号括起的列表的适用范围，现在可以用于所有的内置类型和用户自定义的类型，使用初始化列表时，可以添加等号，也可以不添加。</p> 
<p id="u5965d4c8"></p> 
<p id="u0df41cc2">这种初始化方式称为列表初始化。</p> 
<hr id="sJW4o"> 
<p id="u51337b7b">创建对象的时候也可以使用列表初始化的方式来调用构造函数进行初始化。</p> 
<p id="u423d0e23"></p> 
<pre id="da8900e8"><code>class Date
{
public:
Date(int y, int m, int d)
:_y(y)
,_m(m)
,_d(d)
{
    cout &lt;&lt; "Date(int y, int m, int d)" &lt;&lt; endl;
}

private:
int _y;
int _m;
int _d;
};


int main()
{
    Date date(2023, 10, 8);
    Date time{2024, 10, 8};
    return 0;
}</code></pre> 
<p id="udbcfe2a1"></p> 
<h2 id="10e0c0d6"><code>std::initializer_list</code></h2> 
<p id="u248500c6"></p> 
<p id="u5283b8bf">有时候，我们不知道应该提前向某个函数传递几个参数，为了能够编写出能处理不同类型数量实参的参数，C++11新标准提供了两种主要的方式：如果所有的参数类型相同，可以传递一个名为 <code>initializer_list</code>的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板(暂时先不说)。</p> 
<p id="u1db90717"></p> 
<p id="ue5d6331a"><code>initializer_list</code>用于表示某种特定类型值的数组，它定义在同名的头文件当中。并且用法和vector类似。有size，begin，end等。。在定义 <code>initializer_list</code>的时候，必须指定模板类型。</p> 
<p id="ub7f7b37f"></p> 
<pre id="2093abea"><code>#include &lt;initializer_list&gt;
int main()
{
    initializer_list&lt;int&gt; il = { 1, 2, 3 };
    initializer_list&lt;int&gt; il1 = il;
    initializer_list&lt;int&gt;il2(il1);
    il.size();
    auto it = il.begin();
    auto ed = il.end();



    return 0;
}</code></pre> 
<p id="ub5c52d32"></p> 
<p id="ub16a05a0">和vector不一样的是 <code>initializer_list</code>对象中的元素永远是常量值，并且无法改变它对象中元素的值。</p> 
<p id="u045e520c"></p> 
<p class="img-center"><img alt="" height="222" id="uc5670311" src="https://images2.imgbox.com/9f/5b/44npHfZZ_o.png" width="481"></p> 
<p id="u06504b90"></p> 
<hr id="ZyLPP"> 
<h3 id="7efcb0ce">使用场景</h3> 
<p id="ucbb309a1"></p> 
<p id="u30f912bc"><code>initializer_list</code>一般是作为构造函数的参数，C++！1对STL中的不少容器增加 <code>initializer_list</code>作为参数的构造函数，这样初始化容器对象就方便了，也可以作为 <code>operator=的参数</code>，这样就可以用大括号赋值。</p> 
<p id="u65825b0c"></p> 
<p id="u5330ff4c"></p> 
<p class="img-center"><img alt="" height="248" id="ue97d43ea" src="https://images2.imgbox.com/d9/2d/4JDuXqXh_o.png" width="855"></p> 
<p id="u74553894"></p> 
<pre id="10596d3b"><code>#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
int main()
{
    vector&lt;int&gt; v = { 1,2, 3, 4 };
    list&lt;int&gt; lt = { 1, 2 };
    map&lt;string, string&gt; dict = { {"sort","排序"},{"insert","插入"} };

    return 0;
}</code></pre> 
<p id="udf27c2c2"></p> 
<h2 id="auto">auto</h2> 
<p id="ue90cf767"></p> 
<p id="ub1db0a5c">在C98中auto是一个存储类型的说明符，表明变量是局部自动存储类型，但是局部定义局部的变量默认就是自动存储类型，所以auto就没什么价值了。C11中废弃了auto原来的用法，可以让编译器自动分析表达式的类型。<strong>auto可以自动推导，这就很显然，auto定义的变量，一定要有初始值</strong>。</p> 
<p id="u68fc5724"></p> 
<pre id="4b2d42e3"><code>int i = 10;
auto a = &amp;i;
cout &lt;&lt; typeid(a).name() &lt;&lt; endl;</code></pre> 
<p id="u33f795ba"></p> 
<p id="ue52e0b5c"><code>输出：int *</code>。</p> 
<p id="uf98b7e2d"></p> 
<h2 id="decltype">decltype</h2> 
<p id="u733bdd58"></p> 
<p id="uc4d05bed">从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值进行初始化，C++11中引入了 <code>decltype</code>，它的作用是选择并返回操作数的数据类型，在这个过程中，编译器分析并得到它的类型，但是并不会实际计算表达式的值。</p> 
<p id="u7ccbea62"></p> 
<pre id="ce588f11"><code>template&lt;class T1, class T2&gt;
void F(T1 a, T2 b)
{
    decltype(a * b) ret;
    cout &lt;&lt; typeid(ret).name() &lt;&lt; endl;
}

int main()
{
    int x = 1;
    double y = 2.2;

    decltype(x * y) ret;
    decltype(&amp;x) p;
    cout &lt;&lt; typeid(ret).name() &lt;&lt; endl;
    cout &lt;&lt; typeid(p).name() &lt;&lt; endl;

    F(1, 'a');

    return 0;
}</code></pre> 
<p id="u0871c4d3"></p> 
<p id="uf2f031c3"></p> 
<p class="img-center"><img alt="" height="177" id="u3e31e632" src="https://images2.imgbox.com/8b/13/nrlGnQYc_o.png" width="370"></p> 
<p id="uf2f031c3"><code>typeid(var).name()</code>可以输出var的类型。如果var是引用类型则输出结果不会带  <code>&amp;</code>。</p> 
<hr id="GtauQ"> 
<pre id="e057db4d"><code>int i = 0;
int&amp; a = i;
// decltype((i)) e;
cout &lt;&lt; typeid(decltype((i))).name()&lt;&lt; endl;
cout &lt;&lt; typeid(decltype(a)).name() &lt;&lt; endl;</code></pre> 
<p id="uc166125e"></p> 
<p id="u1c844ccb">这个e会报错，因为 <strong>如果变量名上加上了一对括号，则得到的类型与不加括号时会有不同。如果使用的是不加括号的变量，则得到的结果就是表达式的类型，相反，加上括号得到的结果会是引用类型</strong>。</p> 
<p id="u86857702"></p> 
<p class="img-center"><img alt="" height="102" id="u7068ff5f" src="https://images2.imgbox.com/91/26/foCwZu3U_o.png" width="169"></p> 
<p id="u35bbcfe2"></p> 
<hr id="rkJeu"> 
<p id="u6cf07f86">如果 <code>decltype</code>中的内存是指针解引用，那么这个变量就是引用类型，必须初始化。</p> 
<p id="u8ea60736"></p> 
<p id="u3a10e674"></p> 
<p class="img-center"><img alt="" height="139" id="u69fffded" src="https://images2.imgbox.com/4d/9e/Ykx3bLum_o.png" width="679"></p> 
<p id="u0f411040"></p> 
<p id="u30560c5b">decltype((var))像这样得到的结果永远是引用。为单括号的时候，只有当var本身是一个引用的时候才是引用。</p> 
<p id="ud993d9f9"></p> 
<h2 id="nullptr">nullptr</h2> 
<p id="uf00a0872"></p> 
<p id="uf1d90724">在之前我们会用到名为NULL的预处理变量来给指针赋值，它的值是0，这样就可能会带来一些问题，因为0既能表示整形常量，也能表示指针常量。C++11中新增了 <code>nullptr</code>，用于表示空指针。</p> 
<p id="u151bef45"></p> 
<pre id="59b49af3"><code>#ifndef NULL
#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif
#endif</code></pre> 
<p id="u334b7f0b"></p> 
<h2 id="2d075a7c">范围for循环</h2> 
<p id="ud5810271"></p> 
<p id="ua6e69ce0">C++11中新增了一个范围for，这个东西非常的好用，如果你想对string中的每个字符做点什么事，范围for挺合适的。这种遍历语句会遍历给定序列中的每个元素。</p> 
<p id="ub969201a"></p> 
<pre id="191a24fc"><code>for (declaration : expression)
{
    statement
    }

    expression部分是一个对象，用于表示一个序列。
    declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为下一个变量。
其实就是用迭代器实现的。</code></pre> 
<p id="u6cf355c2"></p> 
<pre id="44808f02"><code>int main()
{
    string str = "hao hao xue xue xi";
    for (auto t : str)
        {
            cout &lt;&lt; t &lt;&lt; " " &lt;&lt; endl;
        }

    return 0;
}</code></pre> 
<p id="u6cf94edd"></p> 
<h2 id="776a97c8">左值引用和右值引用</h2> 
<p id="u128a377a"></p> 
<p id="ueb6e113c">左值是一个表示数据的表达式(如变量名或解引用的指针)，可以获取它的地址，可以对他赋值，左值可以出现在赋值符号的左边，右值不能出现在赋值符号的左边。定义时const修饰符后的左值，不能给他赋值，但是可以对他取地址。左值引用就是给左值的引用，给左值取别名。</p> 
<p id="u7a3e9132"></p> 
<pre id="57263da7"><code>int main()
{
    // 左值
    int* p = new int(0);
    int b = 1;
    const int c = 2;

    // 对上面左值的引用
    int*&amp; rp = p;
    int&amp; rb = b;
    const int&amp; rc = c;
    int&amp; pvalue = *p;

    return 0;
}</code></pre> 
<hr id="MojUN"> 
<p id="ua04025ea">右值也是一个表示数据的表达式，如字面常量，表达式返回值，函数返回值(这个不能是左值引用返回)等等，右值可以出现在赋值符号的右边，但是不能出现在赋值符号的左边，右值不能取地址。右值引用就是对右值的引用，给右值取别名。</p> 
<p id="u3b305cc5"></p> 
<p id="u9f336c0d">右值引用是通过 <code>&amp;&amp;</code>来完成的。</p> 
<p id="u7a339294"></p> 
<p id="u781c1e67">右值引用有一个重要的性质，只能绑定到一个将要销毁的对象，因此，我们可以自由的将一个右值引用的资源移动到另一个对象身上(后面会说什么意思)</p> 
<p id="ua97ad5ec"></p> 
<pre id="e04ea88c"><code>int main()
{
    double x = 1.1, y = 2.2;

    // 右值
    10;
    x + y;
    fmin(x, y);

    // 对右值的右值引用
    int&amp;&amp; rr1 = 10;
    double&amp;&amp; rr2 = x + y;
    double&amp;&amp; rr3 = fmin(x, y);

}</code></pre> 
<p id="u350a4bac"></p> 
<p id="u13e4baf5">需要注意的是右值不能取地址的，但是给右值取别名之后，会导致右值被存储到特定位置，且可以取到该位置的地址，也就是说，不可以对10取地址，但是rr1引用后，可以对rr1取地址，也可以修改rr1.如果不能修改rr1，可以用const引用。</p> 
<p id="u0859f177"></p> 
<pre id="9af473a3"><code>int main()
{

    int&amp;&amp; rr1 = 10;
    rr1 = 20;
    cout &lt;&lt; rr1 &lt;&lt; endl;

} // 输出 20；</code></pre> 
<p id="u9b7f7def"></p> 
<p id="ua824fd57">无论左值引用还是右值引用，都是给对象取别名。</p> 
<hr id="jRAFB"> 
<p id="u20ac80f5">左值</p> 
<p id="u92c54a96"></p> 
<p id="u7063a255">左值引用只能引用左值，不能引用右值，但是const左值既可以引用左值，也可以引用右值。</p> 
<p id="uff66832e"></p> 
<pre id="f88fabde"><code>int a = 10;
int&amp; ra = a;

int&amp;&amp; rra = 10;
const int&amp; ra1 = rra;</code></pre> 
<p id="ueae26354"></p> 
<p id="ua3fa2752">右值</p> 
<p id="u7ed59bc9"></p> 
<p id="u72447334">右值引用只能引用右值，不能引用左值，但是右值引用可以引用move以后的左值。</p> 
<p id="ueb02690b"></p> 
<p id="u110e0031">虽然不能将一个右值引用直接绑定到一个左值上，但是我们可以显示的将一个左值转换为对应的右值引用类型。通过调用一个move的新标准库函数来获得绑定到做之上的右值引用，此函数定义在头文件utility中。</p> 
<p id="u1d0080c8"></p> 
<p id="u6f37ebaa">move函数调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。应该使用std::move，避免潜在的名字冲突</p> 
<p id="u593a987c"></p> 
<pre id="57feda3e"><code>int main()
{
    int a = 10;
    int&amp;&amp; r = std::move(a); // 右值引用可以引用move以后的值
    cout &lt;&lt; r &lt;&lt; endl;
} // 输出 10</code></pre> 
<p id="u0339ab4b"></p> 
<h3 id="5f31724a">右值引用使用场景和意义</h3> 
<p id="u2909ac38"></p> 
<p id="uef2c79ea">上面说了左值引用和右值引用，那么为什么C++11还要提出右值引用呢？</p> 
<p id="ua7768c1a"></p> 
<p id="ubebe3042">如果我们用前面自己实现的string做题，在很多情况下，会发生对象拷贝(接收函数返回值，拷贝等)在某些情况下，这些对象拷贝后就会立刻销毁。如下面代码的情况，虽然编译器会进行优化，但是如果b非常的大，在拷贝的时候，也会减少性能。</p> 
<p id="ue0de864c"></p> 
<pre id="f9e125c3"><code>string func()
{
    string b;
    cin &gt;&gt; b;
    return b;
}

int main()
{
    string a = func();
    return 0;
}</code></pre> 
<p id="uf4b4a532"></p> 
<p id="ua6f956d9">提出右值引用后，我们可以 <strong>移动对象</strong>。</p> 
<p id="ueb044633"></p> 
<h4 id="a5337af3">移动构造函数</h4> 
<p id="u346156d5"></p> 
<p id="udf05a313">与拷贝构造函数类似，但移动构造函数是从对象中交换资源而不是拷贝资源，且第一个参数是该类类型的一个<strong>右值引用</strong>。但是也不能随便的交换资源，要保证所交换的对象处于 <strong>即将被销毁的，销毁该对象对整个程序没有影响的</strong>，在完成交换之后，源对象指向的就是即将被销毁的对象。在此过程中，并不会分配任何空间。而是会接管上面代码中 b的空间。这样就完成了对象的移动操作，此对象继续存在，将要销毁的对象继续销毁。</p> 
<p id="ude1ddc12"></p> 
<p id="u23211505">自己先造一个轮子，用库里的看不出来。</p> 
<p id="u590df242"></p> 
<pre id="21f69ab3"><code>using namespace std;
namespace haifan
{
    class string
    {
    public:
    typedef char* iterator;
    iterator begin()
    {
        return _str;
    }
    iterator end()
    {
        return _str + _size;
    }
    string(const char* str = "")
    :_size(strlen(str))
    , _capacity(_size)
    {
        //cout &lt;&lt; "string(char* str)" &lt;&lt; endl;
        _str = new char[_capacity + 1];
        strcpy(_str, str);
    }
    // s1.swap(s2)
    void swap(string&amp; s)
    {
        ::swap(_str, s._str);
        ::swap(_size, s._size);
        ::swap(_capacity, s._capacity);
    }
    // 拷贝构造
    string(const string&amp; s)
    :_str(nullptr)
    {
        cout &lt;&lt; "string(const string&amp; s) -- 深拷贝" &lt;&lt; endl;
        string tmp(s._str);
        swap(tmp);
    }
    // 赋值重载
    string&amp; operator=(const string&amp; s)
    {
        cout &lt;&lt; "string&amp; operator=(string s) -- 深拷贝" &lt;&lt; endl;
        string tmp(s);
        swap(tmp);
        return *this;
    }
    // 移动构造
    string(string&amp;&amp; s)
    :_str(nullptr)
    , _size(0)
    , _capacity(0)
    {
        cout &lt;&lt; "string(string&amp;&amp; s) -- 移动语义" &lt;&lt; endl;
        swap(s);
    }
    // 移动赋值
    string&amp; operator=(string&amp;&amp; s)
    {
        cout &lt;&lt; "string&amp; operator=(string&amp;&amp; s) -- 移动语义" &lt;&lt; endl;
        swap(s);
        return *this;
    }
    ~string()
    {
        delete[] _str;
        _str = nullptr;
    }
    char&amp; operator[](size_t pos)
    {
        assert(pos &lt; _size);
        return _str[pos];
    }
    void reserve(size_t n)
    {
        if (n &gt; _capacity)
        {
            char* tmp = new char[n + 1];
            strcpy(tmp, _str);
            delete[] _str;
            _str = tmp;
            _capacity = n;
        }
    }
    void push_back(char ch)
    {
        if (_size &gt;= _capacity)
        {
            size_t newcapacity = _capacity == 0 ? 4 : _capacity * 2;
            reserve(newcapacity);
        }

        _str[_size] = ch;
        ++_size;
        _str[_size] = '\0';
    }
    //string operator+=(char ch)
    string&amp; operator+=(char ch)
    {
        push_back(ch);
        return *this;
    }
    const char* c_str() const
    {
        return _str;
    }
    private:
    char* _str;
    size_t _size;
    size_t _capacity; // 不包含最后做标识的\0
};
}</code></pre> 
<p id="ua9ea013d"></p> 
<pre id="52c2f93e"><code>HaiFan::string func()
{
    HaiFan::string a = "aaaa";

    return a;
}

int main()
{
    HaiFan::string str = func();
    return 0;
}</code></pre> 
<p id="u7ca320c8"></p> 
<p id="u9216dedd">比如上面的代码，如果没有移动构造，程序运行的期间，执行的都是深拷贝，有了移动构造函数，就会大大的提高性能。</p> 
<p id="u17aa5689"></p> 
<p id="u59d9e9e8"></p> 
<p id="u9235d942"></p> 
<p class="img-center"><img alt="" height="144" id="ud680c6b0" src="https://images2.imgbox.com/3b/3c/YZDn0Ipf_o.png" width="682"></p> 
<h4 id="hdfe0">移动赋值运算符</h4> 
<p id="u5c51e5c6"></p> 
<p id="u6522fa47">如果说，我们要将一个非常大的对象(即将被销毁的)赋值给源对象，这会拉低性能，如果我们用右值引用，则可以直接将这两个对象的资源进行交换，这样就大大的提高了性能。</p> 
<p id="u4077f3e4"></p> 
<pre id="7c740462"><code>int main()
{
    HaiFan::string str;
    str = "aa";
    return 0;
}</code></pre> 
<p id="ue545da23"></p> 
<p id="uccd3820a"></p> 
<p id="ub9ed0252"></p> 
<p class="img-center"><img alt="" height="97" id="u06b4063f" src="https://images2.imgbox.com/08/a0/T5HKEwNU_o.png" width="846"></p> 
<h2 id="vbVdc">可变参数模板</h2> 
<p id="uba3b0fc3">一个可变参数模板就是一个接收可变参数的模板函数或模板类。刻板数目的参数被称为参数包。存在两种参数包：模板参数包，表示0个或多个模板参数。函数参数包，表示0个或多个函数参数。</p> 
<pre id="v4umO"><code>// Args是一个模板参数包，args是一个函数形参参数包
// 声明一个参数包Args...args，这个参数包中可以包含0到任意个模板参数。
template &lt;class ...Args&gt;
void ShowList(Args... args)
{}</code></pre> 
<pre id="M6Vyw"><code>template&lt;class T, class ...Args&gt;
void ShowList(T value, Args... args)
{
	cout &lt;&lt; sizeof...(args) &lt;&lt; endl; // 插件args中的参数个数
}

int main()
{
	ShowList(1); // 0
	ShowList(1,2); // 1
	ShowList(1,2,3); // 2
	ShowList(1,2,3,4); // 3
	return 0;
}</code></pre> 
<p id="u43a2515c">传递的参数和包里面的个数不一样是因为，value匹配的第一个参数。</p> 
<p id="u39f86946">如果args是一个可变参数，那我们可以对其直接进行一些操作吗？</p> 
<pre id="EglUR"><code>template&lt;class T, class ...Args&gt;
void ShowList(T value, Args... args)
{
	cout &lt;&lt; sizeof...(args) &lt;&lt; endl; // 插件args中的参数个数

	for (int i = 0; i &lt; sizeof...(args); i++)
	{
		cout &lt;&lt; args[i] &lt;&lt; endl;
	} // 报错信息  必须在上下文中扩展参数包
}</code></pre> 
<hr id="KbmxQ"> 
<h3 id="oiMzV">展开参数包的两种方式</h3> 
<pre id="NovsS"><code>template &lt;class T&gt;
void ShowList(T value)
{
	cout &lt;&lt; value &lt;&lt; " ";
	cout &lt;&lt; endl;
}

template&lt;class T, class ...Args&gt;
void ShowList(T value, Args... args)
{
	cout &lt;&lt; value &lt;&lt; " ";
	ShowList(args...);

}

int main()
{
	ShowList(1);
	ShowList(1,2);
	ShowList(1,2,3);
	ShowList(1,2,3,4);
	return 0;
}</code></pre> 
<p id="u46762102">要对参数包进行操作，可以通过递归展开参数包。</p> 
<pre id="RHoEm"><code>template&lt; class T&gt;
void PrintArg(T t)
{
	cout &lt;&lt; t &lt;&lt; " ";
}

template&lt;class ...Args&gt;
void CppPrint(Args... args)
{
	int a[] = { (PrintArg(args), 0)... };
	cout &lt;&lt; endl;
}

int main()
{
	CppPrint(1, 2, 3);
	return 0;
}</code></pre> 
<p id="u26fc3377">这样也可以展开参数包，通过数组，编译器会把后面的自动推出来，逗号表达式取得是最右面的值，利用0进行初始化。</p> 
<p id="u3b78eb15"></p> 
<p id="u92803a1c"></p> 
<p id="u3870116a"></p> 
<h2 id="fcCqX">完美转发</h2> 
<p id="u193c8882"></p> 
<p id="udac5ace1">模板中的 &amp;&amp; 万能引用</p> 
<p id="u198eb889"></p> 
<p id="ub16a6d98">模板中的&amp;&amp;不代表右值引用，而是万能引用，其既能接收左值又能接收右值。模板的万能引用只是提供了能够接收同时接收左值引用和右值引用的能力，但是引用类型的唯一作用就是限制了接收的类型，后续使用中都退化成了左值，我们希望能够在传递过程中保持它的左值或者右值的属性, 就需要用我们下面学习的完美转发</p> 
<p id="u02389b74"></p> 
<pre id="b02d512c"><code>void Fun(int&amp; x) { cout &lt;&lt; "左值引用" &lt;&lt; endl; }
void Fun(const int&amp; x) { cout &lt;&lt; "const 左值引用" &lt;&lt; endl; }
void Fun(int&amp;&amp; x) { cout &lt;&lt; "右值引用" &lt;&lt; endl; }
void Fun(const int&amp;&amp; x) { cout &lt;&lt; "const 右值引用" &lt;&lt; endl; }


// 万能引用 既可以接收左值，也可以接收右值
// 实参左值 他就是左值引用(引用折叠)
// 实参右值 他就是右值引用
template&lt;typename T&gt;
void PerfectForward(T&amp;&amp; t)
{
    Fun(t);
}
int main()
{
    PerfectForward(10); // 右值
    int a;
    PerfectForward(a); // 左值
    PerfectForward(std::move(a)); // 右值
    const int b = 8;
    PerfectForward(b); // const 左值
    PerfectForward(std::move(b)); // const 右值
    return 0;
}</code></pre> 
<p id="ub0d4dea5"></p> 
<p id="u10cbfea8"></p> 
<p class="img-center"><img alt="" height="247" id="u83bf2181" src="https://images2.imgbox.com/c7/f6/9dl1fY89_o.png" width="845"></p> 
<p id="ube243859"></p> 
<p id="ue116bcc7">在运行代码之后，全是左值引用。</p> 
<p id="u89b76c95"></p> 
<p id="ue75a152a">我们可以用库里面的一个函数 <strong>std::forward，当用于一个指向模板参数类型的右值引用函数参数T&amp;&amp;时，forward会保持实参类型的所有细节</strong>。</p> 
<p id="u4294f0f0"></p> 
<pre id="Clj9Z"><code>template&lt;typename T&gt;
void PerfectForward(T&amp;&amp; t)
{
    Fun(std::forward&lt;T&gt;(t));
}</code></pre> 
<p id="u14a98718"></p> 
<p id="ucbf97b1b">完美转发，t是左值引用，保持左值属性，t是右值引用，保持右值属性。</p> 
<p id="u9d5b6fdb"></p> 
<p id="u6457221c"></p> 
<p class="img-center"><img alt="" height="273" id="ud83782ae" src="https://images2.imgbox.com/ca/bb/z503mobh_o.png" width="667"></p> 
<p id="u4817c50f"></p> 
<h2 id="5c8f6b1e">STL中的一些变化</h2> 
<p id="ucb1ef42f"></p> 
<p class="img-center"><img alt="" height="538" id="u4ee1b465" src="https://images2.imgbox.com/88/10/fnDw1uas_o.png" width="841"></p> 
<p id="u9329c5a1"></p> 
<p id="ue11763f8">在C++11中新增了 <code>&lt;array&gt;, &lt;forward_list&gt;, &lt;unordered_map&gt;, &lt;unordered_set&gt;</code> 这几个新容器，但是实际最有用的是 <code>unordered_map/set</code>这两个容器，都是用哈希来实现的，查找等效率都是O(1)。</p> 
<p id="uc94347af"></p> 
<p id="u92ede0a9">如果我们在仔细的看，会发现基本每个容器中都增加了一些C++11的方法，但其实很多用的都比较少。比如提供了cbegin和cend方法返回const迭代器等等，但是实际意义并不大，因为begin和end也是可以返回const迭代器的，这些都属于锦上添花的操作。</p> 
<p id="u9c3b4ec7"></p> 
<p id="u2ed7b124">实际上C++11更新后，容器中增加的新方法最后用的接口插入接口函数的右值引用版本。</p> 
<p id="u6bccc7bb"></p> 
<p id="ud02f235c"></p> 
<p class="img-center"><img alt="" height="506" id="u939f05b7" src="https://images2.imgbox.com/1d/1e/dUoGw5gg_o.png" width="854"></p> 
<p id="ue721cb3d">平常我们用的 尾插push_back，在 vector&lt;pair&lt;int,int&gt;&gt; v的情况下，我们尾插需要先用make_pair构造，然后再插入，emplace_back利用参数包，直接完成构造。</p> 
<p id="ufad3d14c">有了右值引用版本，在某些情况下，可以大大的提升性能。</p> 
<p id="uaa6352de"></p> 
<h2 id="82c31419">lambda表达式</h2> 
<p id="u3c2e0a91"></p> 
<p id="u08e9c28f">如果我们要对某种自定义类型进行排序，直接用sort函数是不可以的，我们可以用仿函数解决，也可以用<strong>lambda</strong>表达式解决。</p> 
<pre id="kWD8i"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
struct Goods
{
	string _name; // 名字
	double _price; // 价格
	int _evaluate; // 评价
	Goods(const char* str, double price, int evaluate)
		:_name(str)
		, _price(price)
		, _evaluate(evaluate)
	{}
};
struct ComparePriceLess
{
	bool operator()(const Goods&amp; gl, const Goods&amp; gr)
	{
		return gl._price &lt; gr._price;
	}
};
struct ComparePriceGreater
{
	bool operator()(const Goods&amp; gl, const Goods&amp; gr)
	{
		return gl._price &gt; gr._price;
	}
};
int main()
{
	vector&lt;Goods&gt; v = { { "苹果", 2.1, 5 }, { "香蕉", 3, 4 }, { "橙子", 2.2,
	3 }, { "菠萝", 1.5, 4 } };
	sort(v.begin(), v.end(), [](const Goods&amp; g1, const Goods&amp; g2) {
		return g1._price &lt; g2._price; });
	sort(v.begin(), v.end(), [](const Goods&amp; g1, const Goods&amp; g2) {
		return g1._price &gt; g2._price; });
	sort(v.begin(), v.end(), [](const Goods&amp; g1, const Goods&amp; g2) {
		return g1._evaluate &lt; g2._evaluate; });
	sort(v.begin(), v.end(), [](const Goods&amp; g1, const Goods&amp; g2) {
		return g1._evaluate &gt; g2._evaluate; });
}</code></pre> 
<p id="u7aae4292">像这种自定义类型，如果要排序，每次比较的逻辑都不一样，这给程序猿带来了一些不便。</p> 
<p id="u3e512287"></p> 
<h3 id="yR16g">lambda表达式语法</h3> 
<p id="ud9384f28">书写格式 [capture-list](paramenters)mutable-&gt;return-type{statement}。</p> 
<ol><li id="uc393c449">lambda表达式各部分说明</li></ol> 
<p id="ub978cef9">[capture-list] 捕捉列表， 该列表总是出现在lambda函数的开始位置，编译器根据[]来判断接下来的代 码是否为lambda函数，捕捉列表能够捕捉上下文中的变量供lambda函数使用。</p> 
<p id="ueaf2e056">(parameters) 参数列表， 与普通函数的参数列表一致，如果不需要传递参数，则可以连同()一起省略</p> 
<p id="u4295bdcd">mutable 默认情况下，与普通函数总是一个const函数，mutable可以取消其常量性。使用该修饰 符时，参数列表不可以省略(即参数为空)。</p> 
<p id="udacbf2bc">-&gt;returntype 返回值类型。 用追踪返回类型形式声明函数的返回值类型， 没有返回值时此部分可省 略，返回值类型明确情况下，也可以省略，由编译器对返回类型进行推导。</p> 
<p id="u7aaa41be">{statement} 函数体。 在该函数体内，除了可以使用其参数外，还可以使用所有捕获到的变量。</p> 
<p id="u3d904a20"><strong>注意：在lambda函数定义中，参数列表和返回值类型都是可选部分，而捕捉列表和函数体可以为空。因此C++11中最简单的lambda函数为：[]{}，该lambda函数不能做任何事情。</strong></p> 
<p id="u70661dc2"><strong>lambda函数中可以调用其他函数吗？</strong></p> 
<pre id="H3j7O"><code>void func()
{
	cout &lt;&lt; "123" &lt;&lt; endl;
}

int main()
{
	int a = 0;
	int b = 2;

	// 全局的函数可以使用
	auto add = [](int x, int y)-&gt;int {func(); return x + y; };
	auto swap1 = [](int&amp; x, int&amp; y) {
		int c = x;
		x = y;
		y = c;
		add(x, y);
	};  // 局部的不可以使用

	
	return 0;
}</code></pre> 
<ol><li id="u40b621f8">捕捉列表说明</li></ol> 
<p id="uc5bf5a80">捕捉列表描述了上下文中哪些数据可以被lambda使用，以及使用的方式传值还是传引用。</p> 
<p id="u661953e7">[var] 表示值传递方式捕捉变量var</p> 
<p id="ue61e33cb">[=] 表示值传递方式捕获所有父作用域中的变量(包括this)</p> 
<p id="uf74351f0">[&amp;var] 表示引用传递捕捉变量var</p> 
<p id="ufb33f9d5">[&amp;] 表示引用传递捕捉所有父作用域的变量(包括this)</p> 
<p id="u9d1f696e">[this] 表示值传递方式捕捉当前的this指针</p> 
<p id="ud390ef14"><strong>auto add = [](int x, int y)-&gt;int {func(); return x + y; };</strong></p> 
<p id="u6fab25cf"><strong>注意： </strong></p> 
<p id="u6263a40c"><strong>父作用域指包含lambda函数的语句块</strong></p> 
<p id="u4256ca6e"><strong>语法上捕捉列表可由多个捕捉项组成，并以逗号分割</strong></p> 
<p id="u56000e0c"><strong>如 [=,&amp;a] 以引用传递的方式捕捉变量a和b，值传递的方式捕捉其他所有变量</strong></p> 
<p id="uf101f17e">捕捉列表不允许变量重复传递，否则就会导致编译错误</p> 
<p id="udd079489">[=, a] = 已经以值传递的方式捕捉了所有变量，捕捉a重复</p> 
<p id="u033ceda2">在块作用域以外的lambda函数捕获列表必须为空</p> 
<p id="u42592c6c">在块作用域中的lambda函数仅能捕捉父作用域中局部变量，捕捉任何非此作用域或者非局部变量都会导致编译错误</p> 
<p id="uf984e7c4">lambda表达式之间不能相互赋值，即使看起来类型相同</p> 
<pre id="iqZrb"><code>int main()
{
	int a = 1;
	int b = 2;

	//auto swap1 = [a, b]() {
	//	int c = 0;
	//	a = b;
	//	b = c;
	//}; // 这里会导致编译错误，这是因为捕获的变量是const属性
	auto swap1 = [a, b]() mutable {
		int c = 0;
		a = b;
		b = c;
	};
	cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl; 
	return 0;
} // 输出结果 1， 2</code></pre> 
<p id="u3587a62f">为什么在调用玩swap1函数之后结果却没有改变，这是因为捕获变量之后，是临时变量。不会影响外面的a和b。</p> 
<hr id="vGplK"> 
<p id="uf596408a">想要真正的改变a和b，我们可以用引用捕捉。</p> 
<pre id="WWK30"><code>	auto swap1 = [&amp;a, &amp;b]() mutable {
		int c = 0;
		a = b;
		b = c;
	};</code></pre> 
<p id="ud4f8720c">这里的&amp;可不是把地址取出来，而是引用的意思。</p> 
<hr id="NCCT8"> 
<pre id="NtnAn"><code>	auto swap1 = [&amp;]() mutable {
		cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b;
	}; // 输出结果 1， 2
	auto swap2 = [=]() mutable {
		cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b;
	}; // 输出结果 1， 2</code></pre> 
<hr id="l5C9X"> 
<p id="u186fbbbd">cosnt对象能不能被捕捉。</p> 
<pre id="MxDXG"><code>	int a = 1;
	int b = 2;
	const int c = 3;

	auto swap1 = [&amp;]() mutable {
		cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b;
		c++; // 报错，能被捕捉，但是不能修改
	}; // 输出结果 1， 2</code></pre> 
<hr id="TziLj"> 
<p id="uc4d1cc78">继上面说，要想在让函数调用局部变量中的函数，可以用捕捉列表捕捉局部函数，从而完成调用</p> 
<pre id="DNeee"><code>	auto add = [](int a, int b) { return a + b; };
	auto swap2 = [add, a, b]() mutable {
		cout &lt;&lt; add(a, b) &lt;&lt; endl;
	}; </code></pre> 
<h2 id="IVNCq">新的类功能</h2> 
<p id="u3fb55639">原来C++类中，有6个默认成员函数：</p> 
<p id="u40e25c1d"></p> 
<ol><li id="ud280f92a">构造函数</li><li id="u4575b7f5">析构函数</li><li id="ud2faa71b">拷贝构造函数</li><li id="ud0ef166d">拷贝赋值重载</li><li id="u0aef7c14">取地址重载</li><li id="uca4349b3">const 取地址重载<br> 最后重要的是前4个，后两个用处不大。默认成员函数就是我们不写编译器会生成一个默认的。<br> C++11 新增了两个：移动构造函数和移动赋值运算符重载。<br> 针对移动构造函数和移动赋值运算符重载有一些需要注意的点如下：<br> 如果你没有自己实现移动构造函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中的任<br> 意一个。那么编译器会自动生成一个默认移动构造。默认生成的移动构造函数，对于内置类<br> 型成员会执行逐成员按字节拷贝，自定义类型成员，则需要看这个成员是否实现移动构造，<br> 如果实现了就调用移动构造，没有实现就调用拷贝构造。<br> 如果你没有自己实现移动赋值重载函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中<br> 的任意一个，那么编译器会自动生成一个默认移动赋值。默认生成的移动构造函数，对于内<br> 置类型成员会执行逐成员按字节拷贝，自定义类型成员，则需要看这个成员是否实现移动赋<br> 值，如果实现了就调用移动赋值，没有实现就调用拷贝赋值。(默认移动赋值跟上面移动构造<br> 完全类似)<br> 如果你提供了移动构造或者移动赋值，编译器不会自动提供拷贝构造和拷贝赋值。</li></ol> 
<pre id="umx1A"><code>class Person
{
public:
    Person(const char* name = "", int age = 0)
        :_name(name)
        , _age(age)
    {}

    ~Person()
    {}

private:
    haifan::string _name;
    int _age;
};

int main()
{
    Person s1;
    Person s2 = s1;
    Person s3 = std::move(s1);
    //Person s4;
    //s4 = std::move(s2);

    return 0;
} // 用上面造的轮子，输出结果是 深拷贝，如果把Person析构函数注释掉，输出的是移动构造
// 	Person(Person&amp;&amp; p) = default; 定义了default关键字之后，编译器就不会在生成=default的那个
// 默认成员函数
//	Person(const Person&amp; p) = default; 再定义这个之后，可以让编译器强制的执行string中的移动构造
// 和移动赋值</code></pre> 
<h2 id="At63h">包装器</h2> 
<p id="u40a19484">function包装器也叫做适配器。C++中的function本质是一个类模板，也是一个包装器。</p> 
<p id="u2d371fcb">定义在头文件functional中。</p> 
<pre id="B21u7"><code>ret = func(x)
// 上面func可能是什么呢？那么func可能是函数名？函数指针？函数对象(仿函数对象)？也有可能
// 是lamber表达式对象？所以这些都是可调用的类型！如此丰富的类型，可能会导致模板的效率低下！
// 为什么呢？我们继续往下看</code></pre> 
<pre id="tJ3sD"><code>template&lt;class F, class T&gt;
T useF(F f, T x)
{
	static int count = 0;
	cout &lt;&lt; "count:" &lt;&lt; ++count &lt;&lt; endl;
	cout &lt;&lt; "count:" &lt;&lt; &amp;count &lt;&lt; endl;
	return f(x);
}
double f(double i)
{
	return i / 2;
}
struct Functor
{
	double operator()(double d)
	{
		return d / 3;
	}
};
int main()
{

	// 函数名
	cout &lt;&lt; useF(f, 11.11) &lt;&lt; endl;
	// 函数对象
	cout &lt;&lt; useF(Functor(), 11.11) &lt;&lt; endl;
	// lamber表达式
	cout &lt;&lt; useF([](double d)-&gt;double { return d / 4; }, 11.11) &lt;&lt; endl;
	return 0;
}</code></pre> 
<p id="u4f0e22ff">这个useF会被实例化成三份对象，导致模板效率低。</p> 
<hr id="UB1KP"> 
<p id="ua0da6b5c">包装器可以很好的解决这个问题。</p> 
<p id="ub0b4218f">function是一个模板，当创建一个具体的function类型时我们要提供该类型能够表示的对象的调用形式。如：</p> 
<pre id="IoyHg"><code>function&lt;int(int,int)&gt;
声明了一个funcion类，它可以接收两个int，返回一个int的可调用对象。

如：
function&lt;double(double)&gt; f1 = f; // 函数指针
function&lt;double(double)&gt; f2 = Functor(); // 函数对象类的对象
function&lt;double(double)&gt; f3 = [](double d) -&gt; double {return d / 4; }; // lambda</code></pre> 
<p id="ubd35b67a">通过f1，f2，f3可以完成调用。</p> 
<hr id="mkjk1"> 
<pre id="WxMO7"><code>int add(int a, int b)
{
	return a + b;
}

int sub(int a, int b)
{
	return a - b;
}

int div1(int a, int b)
{
	return a / b;
}

int mul(int a, int b)
{
	return a * b;
}

#include &lt;unordered_map&gt;

int main()
{

	map&lt;string, function&lt;int(int, int)&gt;&gt; m = {
		{"+", add},
		{"-", sub},
		{"/", div1},
		{"*", mul},
	};

	for (auto t : m)
	{
		cout &lt;&lt; t.second(1, 2) &lt;&lt; endl;
	}

	for (auto i = m.begin(); i != m.end(); i++)
	{
		cout &lt;&lt; i-&gt;second(1, 2) &lt;&lt; endl;
	}

	cout &lt;&lt; m["+"](1, 2) &lt;&lt; endl;
	cout &lt;&lt; m["-"](1, 2) &lt;&lt; endl;
	cout &lt;&lt; m["*"](1, 2) &lt;&lt; endl;
	cout &lt;&lt; m["/"](10, 5) &lt;&lt; endl;

	return 0;
}</code></pre> 
<p id="u05c5f378">在这个代码中，我们依次调用了m中存储的每个操作。在第一个调用中，我们获得的元素存放着一个指向add函数的指针，因此调用m["+"](10，5)实际上是使用该指针调用add，并传入10和5，接下来调用的m["-"]返回一个存放着std::minus&lt;int&gt;类型对象的funciton，我们将执行该对象的调用运算符。</p> 
<hr id="qz5pc"> 
<h3 id="WXLGX">函数重载和function</h3> 
<p id="ue8da985e">再有函数重载的时候，我们不能直接将重载函数的名字存入funciton类型的对象中。</p> 
<pre id="MmDNu"><code>int add(int a, int b)
{
	return a + b;
}

double add(double a, double b)
{
	return a + b;
}</code></pre> 
<p id="u96ccab55">这样就会报错，解决二义性的问题这一条途径是存储函数指针，而非函数的名字。</p> 
<pre id="LIQ9T"><code>	int (*fp)(int, int) = add;
	map&lt;string, function&lt;int(int, int)&gt;&gt; m = {
		{"+", fp},
		{"-", sub},
		{"/", div1},
		{"*", mul},
	};
	cout &lt;&lt; m["+"](1, 2) &lt;&lt; endl;</code></pre> 
<p id="ua50d4632">同样我们也能用lambda来消除二义性问题。</p> 
<h2 id="DKYo0">bind</h2> 
<p id="udd4bd660">对于偶尔用的函数，我们可以用lambda写，如果我们需要多次调用一个函数，通常应该定义一个函数，而不是靠lambda。</p> 
<p id="ued70f09c">bind函数定义再头文件functional中，是一个函数模板，可以将bind看作一个通用的函数适配器。它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。</p> 
<pre id="I5ti1"><code>调用bind的一般形式为
auto newCallable = bind(callable, arg_list);
其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给
顶的callable的参数。当我们调用newCallable的时候，newCallable会调用callable，并传递
给它arg_list中的参数。</code></pre> 
<p id="u48ee1eba"></p> 
<hr id="nsWJd"> 
<pre id="sRfUV"><code>function&lt;int(int, int)&gt; rAdd = bind(add, placeholders::_1, placeholders::_2);</code></pre> 
<p id="u47621ee0">像arg_list中会出现 placeholders::_1 这样的名字，意思是 add的第一个参数。_2就是第二个参数。</p> 
<p id="u1de86ab6">如果将他们调换位置。</p> 
<pre id="R3TpX"><code>function&lt;int(int, int)&gt; rAdd = bind(add,placeholders::_2， placeholders::_1);</code></pre> 
<p id="uf03ea9cb">_1还是第一个参数，_2还是第二个参数。</p> 
<pre id="S58Qb"><code>	function&lt;int(int, int)&gt; rAdd = bind(add, placeholders::_1, placeholders::_2);

	cout &lt;&lt; rAdd(1, 1) &lt;&lt; endl;</code></pre> 
<p id="ud3467795">placeholders是命名空间，这个命名空间又定义在std中。</p> 
<hr id="yOrUD"> 
<p id="u2b296a9d">现在有一个函数，有abc三个参数，给c传递固定值。</p> 
<pre id="EKuql"><code>int func(int a, int b, int c)
{
	return a * (b - c);
}

int main()
{
	
	function&lt;int(int, int)&gt; f = bind(func, placeholders::_1, placeholders::_2, 3);

	cout &lt;&lt; f(1, 10) &lt;&lt; endl;

	return 0;
}</code></pre> 
<p id="u309cac10">可以直接给c固定值。</p> 
<p id="ufb3a56b0"></p> 
<p id="u50f8a632">不管这个要传固定值的参数位于func形参列表中的哪一个位置，bind中都是要从_1开始写。</p> 
<pre id="lyDNB"><code>int func(int c, int a, int b)
{
	return a * (b - c);
}

int main()
{
	
	function&lt;int(int, int)&gt; f = bind(func, 3 ,placeholders::_1, placeholders::_2);

	cout &lt;&lt; f(1, 10) &lt;&lt; endl;

	return 0;
}</code></pre> 
<hr id="xPasc"> 
<p id="u7831ae71">上面绑定的都是普通的函数，如果要绑定类的成员函数呢？</p> 
<pre id="Q24PM"><code>class A
{
public:
	static int sub1(int a, int b)
	{
		return a - b;
	} // 用bind绑定静态的，只需要指定域即可。

	int sub2(int a, int b)
	{
		return a - b;
	} // 如果还是按照静态绑定一样，指定作用域，会报错。
	
}; 

int main()
{
	
	function&lt;int(int, int)&gt; f1 = bind(A::sub1, placeholders::_1, placeholders::_2);
	A a;
	function&lt;int(int, int)&gt; f2 = bind(&amp;A::sub2, &amp;a,placeholders::_1, placeholders::_2);
	//1.非静态的成员函数要加上&amp; 符号。
	//2. 非静态的应该是3个参数，还有一个this指针。这个参数也可以换成一个匿名对象
	return 0;
}</code></pre> 
<h2 id="MoMr0">智能指针</h2> 
<h3 id="W5VJB">概念</h3> 
<p id="u161d4c62">再C++中，动态内存管理是通过一对运算符来完成的，new再动态内存中为对象分配空间并返回一个指向该对象的指针，delete，接受一个动态对象的指针，销毁该对象，释放该对象与之关联的内存。</p> 
<p id="uc9ff362b">动态内存再管理的时候很容易出问题，有时候再写了大量的代码之后，可能会忘了释放内存，这就导致了内存泄漏，有时再尚有指针引用内存的情况下，我们就delete，在这种情况下就会产生引用非法内存的指针。在有了异常之后，动态内存管理变得更加不容易，有了catch，会直接不执行下面的代码，若下面的代码涉及到了释放内存等，这也会导致内存泄漏。</p> 
<p id="uac7fff35"></p> 
<p id="u67907dea">为了更容易的管理内存，C++11中给出了智能指针类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的智能指针有两种，区别在于管理底层指针的方式： shared_ptr 允许多个指针指向同一个对象; unique_ptr 则独占所指向的对象。标准库还定义了一个名为 weak_ptr的伴随类，他是一种弱引用，指向 shared_ptr 所管理的对象。这三种类型都定义在memory头文件中。</p> 
<hr id="KOBnB"> 
<p id="u2315e5b8">在C++98中，其实就已经引入了智能指针 auto_ptr&lt;T&gt;</p> 
<pre id="dhUUk"><code>#include &lt;iostream&gt;

using namespace std;

class A
{
public:
	A(int b)
		:a(b)
	{}

	~A()
	{
		cout &lt;&lt; "~A " &lt;&lt; this &lt;&lt; endl;
	}

private:
	int a;
};

int main()
{
	auto_ptr&lt;A&gt; ap1(new A(1));
	auto_ptr&lt;A&gt; ap2(new A(2));

	auto_ptr&lt;A&gt; ap3(ap1);

	return 0;
}</code></pre> 
<p id="u3389197b">这段代码在把ap1拷贝给ap3的时候，会做一件事情。</p> 
<p id="u7d206daa"></p> 
<p class="img-center"><img alt="" height="208" id="u94f7ef33" src="https://images2.imgbox.com/7d/47/qYh4Zd6M_o.png" width="514"></p> 
<p id="u7d206daa">如图所示，ap1变为empty，这是管理权转移，在拷贝的时候，会把被拷贝对象的资源管理权转移给拷贝对象，导致被拷贝对象悬空，访问就会出问题。</p> 
<p id="u6850e64c"></p> 
<p id="ude369e51">如果在拷贝代码的下一行添加上</p> 
<pre id="rIswe"><code>ap1-&gt;a++;
ap3-&gt;a++;</code></pre> 
<p id="u7f874dca">程序就会崩溃。</p> 
<p id="u3be73d03">不太建议使用auto_ptr</p> 
<hr id="zmTbn"> 
<p id="uda0aa46c">下面是一个简单的模拟实现</p> 
<pre id="nR9cy"><code>namespace haifan
{
    template &lt;class T&gt;
    class auto_ptr
    {
    public:
    auto_ptr(T* ptr)
    :_ptr(ptr)
    {}

    ~auto_ptr()
    {
        delete _ptr;
    }

    T&amp; operator* ()
    {
        return *_ptr;
    }

    T* operator-&gt; ()
    {
        return _ptr;
    }

    // 管理权转移
    auto_ptr(auto_ptr&lt;T&gt;&amp; ap)
    :_ptr(ap._ptr)
    {
        ap._ptr = nullptr;
    }

    private:
    T* _ptr;
};
}</code></pre> 
<p id="u293f6044"></p> 
<h3 id="mXxVF">RAII</h3> 
<p id="u64053bca">RAII（Resource Acquisition Is Initialization）是一种<strong>利用对象生命周期来控制程序资源</strong>（如内<br> 存、文件句柄、网络连接、互斥量等等）的简单技术。<br><strong>在对象构造时获取资源</strong>，接着控制对资源的访问使之在对象的生命周期内始终保持有效，<strong>最后在</strong><br><strong>对象析构的时候释放资源</strong>。借此，我们实际上把管理一份资源的责任托管给了一个对象。这种做<br> 法有两大好处：<br> 不需要显式地释放资源。<br> 采用这种方式，对象所需的资源在其生命期内始终保持有效</p> 
<p id="u97febdbc"></p> 
<h3 id="sNvZh">unique_ptr</h3> 
<p id="ucdc77eff">一个unqieu_ptr 拥有它所指向的对象，只能有一个unique_ptr指向一个给定对象。当该对象被销毁的时候，它所指向的对象也被销毁。</p> 
<p id="u071d290c">unique_ptr不支持普通的拷贝或者赋值操作。</p> 
<pre id="Gv6LQ"><code>unique_ptr&lt;string&gt; p1(new string("aaa"));
unique_ptr&lt;string&gt; p2(p1); // 错误，不支持拷贝
unique_ptr&lt;string&gt; p3;
p3 = p1; // 错误，不支持赋值</code></pre> 
<p id="u59b852c5">这个智能指针简单粗暴，拷贝有问题，ok，那你就别拷贝了。只让一个人使用。</p> 
<p id="ub240f650"></p> 
<pre id="pLnRr"><code>namespace haifan
{
	template &lt;class T&gt;
	class unique_ptr
	{
    public:
		unique_ptr(T* ptr)
			:_ptr(ptr)
		{}

		~unique_ptr()
		{
			delete _ptr;
		}

		T&amp; operator* ()
		{
			return *_ptr;
		}

		T* operator-&gt; ()
		{
			return _ptr;
		}
		// 防止拷贝和赋值
		unique_ptr(unique_ptr&lt;T&gt;&amp; ap) = delete;
		unique_ptr&lt;T&gt;&amp; operator=(unique_ptr&lt;T&gt;&amp; ap) = delete;
	private:
		T* _ptr;
	};
}</code></pre> 
<p id="u96b3c310">不让进行拷贝和赋值也是不行的，总有一些场景需要完成这两样操作。</p> 
<h3 id="uUpQQ">shared_ptr</h3> 
<pre id="Dfb9b"><code>	shared_ptr&lt;string&gt; sp1(new string("aaa"));
	shared_ptr&lt;string&gt; sp2(sp1);
	shared_ptr&lt;string&gt; sp3;
	sp3 = sp1;</code></pre> 
<p id="u23a72898">shared_ptr可以和别人同时管理同一块空间。</p> 
<p id="ud954ca4b"></p> 
<p id="u59a306f3">简单模拟实现</p> 
<pre id="vNmeM"><code>namespace haifan
{
	template &lt;class T&gt;
	class shared_ptr
	{
		shared_ptr(T* ptr)
			:_ptr(ptr)
			,_cnt(new int(1))
		{}

		~shared_ptr()
		{
			delete _ptr;
		}

		T&amp; operator* ()
		{
			return *_ptr;
		}

		T* operator-&gt; ()
		{
			return _ptr;
		}

		shared_ptr(shared_ptr&lt;T&gt;&amp; sp)
		{
			*_cnt++;
			_ptr = sp._ptr;
			_cnt = sp._cnt;
		}

		void destory()
		{
			if (--(*cnt) == 0);
			{
				delete _ptr;
				delete _cnt;
			}
		}


		shared_ptr&lt;T&gt;&amp; operator=(shared_ptr&lt;T&gt;&amp; sp)
		{
			if (_ptr != sp._ptr)
			{
				destory();
				_ptr = sp;
				_cnt = sp._cnt;
				(*_cnt)++;
			}
		}

	private:
		T* _ptr;
		int* _cnt;
	};

}</code></pre> 
<p id="ub57d98b9">shared_ptr的原理：是通过引用计数的方式来实现多个shared_ptr对象之间共享资源。</p> 
<p id="u2549c60c"></p> 
<ol><li id="ucbc072a0">shared_ptr在其内部，给每个资源都维护了着一份计数，用来记录该份资源被几个对象共<br> 享。</li><li id="u2d6c2d7d">在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减<br> 一。</li><li id="ud56accf7">如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源；</li><li id="u463e486b">如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对<br> 象就成野指针了</li></ol> 
<p id="u3470da87"></p> 
<h3 id="eoKmY">shared_ptr的循环引用</h3> 
<pre id="XXfpp"><code>struct Node
{
	int val;
	shared_ptr&lt;Node&gt; _next;
	shared_ptr&lt;Node&gt; _prev;

	Node()
	{
		cout &lt;&lt; "Node()" &lt;&lt; endl;
	}

	~Node()
	{
		cout &lt;&lt; "delete" &lt;&lt; endl;
	}

};

int main()
{
	shared_ptr&lt;Node&gt; sp1(new Node);
	shared_ptr&lt;Node&gt; sp2(new Node);

	sp1-&gt;_next = sp2;
	sp2-&gt;_prev = sp1;
}</code></pre> 
<p id="ub3058255">这个代码，看上去没任何问题，运行起来也没有任何问题，但是有最大的问题--内存泄漏。</p> 
<p id="udc0e35f9">代码输出结果 Node() Node()</p> 
<p id="u14b892f0">如果24行25行随便屏蔽一行，输出结果就变成 两个Node()和两个delete。</p> 
<p id="u0ccbd5c9">这是shared_ptr的循环引用</p> 
<p id="uc5fe53a5"></p> 
<p class="img-center"><img alt="" height="367" id="uc51b76a5" src="https://images2.imgbox.com/ef/25/zBvgJX4P_o.png" width="724"></p> 
<p id="u9bfe602c">_prev管着左边的节点，_next管着右边的节点。</p> 
<p id="u943e8f2a">什么时候_prev析构？ 右边节点析构时，_prev析构</p> 
<p id="u860b2752">什么时候_next析构？ 左边节点析构时，_next析构</p> 
<p id="udb004e89">左边节点什么时候析构？ _prev析构左边节点就析构</p> 
<p id="uc0917c28">唉，你看，这成套娃了。</p> 
<p id="u27bb7d5a">这就是循环引用。</p> 
<p id="u0ab9bcd2"></p> 
<p id="u926e6b55">既然有了问题，就要解决它</p> 
<h3 id="H2I0Q">weak_ptr</h3> 
<p id="u3345e865">这个智能指针是专门用来解决shared_ptr中的循环引用问题的。</p> 
<p id="ub452c110">weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr 的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr 指向对象，对象也还是会被释放，因此，weak_ptr的名字抓住了这种智能指针弱共享对象的特点。</p> 
<p id="u67a1a44f"></p> 
<pre id="U6a58"><code>struct Node
{
	int val;
	weak_ptr&lt;Node&gt; _next;
	weak_ptr&lt;Node&gt; _prev;

	Node()
	{
		cout &lt;&lt; "Node()" &lt;&lt; endl;
	}

	~Node()
	{
		cout &lt;&lt; "delete" &lt;&lt; endl;
	}

};

int main()
{
	shared_ptr&lt;Node&gt; sp1(new Node);
	shared_ptr&lt;Node&gt; sp2(new Node);

	sp1-&gt;_next = sp2;
	sp2-&gt;_prev = sp1;
}</code></pre> 
<p id="ue028eeb8"></p> 
<p class="img-center"><img alt="" height="160" id="uf809b93c" src="https://images2.imgbox.com/37/b1/syNQJOcG_o.png" width="799"></p> 
<p id="u58212cbf"></p> 
<p id="ucd4ad1e0">简单模拟实现</p> 
<pre id="RlnRh"><code>namespace haifan
{
	template &lt;class T&gt;
	class weak_ptr
	{
	public:
		weak_ptr
		(T* ptr)
			:_ptr(ptr)
			,_cnt(new int(1))
		{}

		weak_ptr(const shared_ptr&lt;T&gt;&amp; sp)
			:_ptr(sp._ptr)
		{}

		weak_ptr&lt;T&gt;&amp; operator= (const shared_ptr&lt;T&gt;&amp; sp)
		{
			_ptr = sp._ptr;
			return *this;
		}

		T&amp; operator* ()
		{
			return *_ptr;
		}

		T* operator-&gt; ()
		{
			return _ptr;
		}
	private:
		T* _ptr;

	};

}</code></pre> 
<p id="ue9edb49f"></p> 
<p id="ub535ec28"></p> 
<h3 id="jkaEO">定制删除器</h3> 
<p id="u5bf4bf32">上面介绍了智能指针，但是在我们写代码的时候，有时候会写出 new A[10]和 new A(1)这样的代码，如果是第二个，delete没问题，如果是第一个，应该是delete []。如果delete的类型不匹配，就会出现错误(shared_ptr的默认释放空间是delete不是delete[])。</p> 
<p id="u1c80592c">通过定制删除器就可以完成。</p> 
<p id="u8edb409b"></p> 
<p class="img-center"><img alt="" height="367" id="ue941ea29" src="https://images2.imgbox.com/64/8d/gQflOiyb_o.png" width="1063"></p> 
<p id="u513f6d46">D del 就是定制删除器。</p> 
<pre id="W1b69"><code>template&lt;class T&gt;
struct DeleteArray
{
	void operator() (T* ptr)
	{
		delete[] ptr;
	}
};

int main()
{
	shared_ptr&lt;Node&gt; sp1(new Node[10], DeleteArray&lt;Node&gt;());
	shared_ptr&lt;Node&gt; sp2((Node*)malloc(sizeof(Node)), [](Node* ptr) {
		free(ptr);
		});

}</code></pre> 
<p id="uaac71792"></p> 
<p id="ud3e7abc4"></p> 
<pre id="xR1hH"><code>#pragma once

#include &lt;functional&gt;

namespace haifan
{
    template &lt;class T&gt;
    class shared_ptr
    {
    shared_ptr(T* ptr = nullptr)
    :_ptr(ptr)
    , _cnt(new int(1))
    {}

    template &lt;class D&gt;
    shared_ptr(T* ptr, D del)
    :_ptr(ptr)
    ,_cnt(new int(1))
    ,_del(del)
    {}

    ~shared_ptr()
    {
        delete _ptr;
    }

    T&amp; operator* ()
    {
        return *_ptr;
    }

    T* operator-&gt; ()
    {
        return _ptr;
    }

    shared_ptr(shared_ptr&lt;T&gt;&amp; sp)
    {
        *_cnt++;
        _ptr = sp._ptr;
        _cnt = sp._cnt;
    }

    void destory()
    {
        if (--(*cnt) == 0);
        {
            delete _ptr;
            delete _cnt;
            _del(_ptr);
        }
    }


    shared_ptr&lt;T&gt;&amp; operator=(shared_ptr&lt;T&gt;&amp; sp)
    {
        if (_ptr != sp._ptr)
        {
            destory();
            _ptr = sp;
            _cnt = sp._cnt;
            (*_cnt)++;
        }
    }

    private:
    T* _ptr;
    int* _cnt;

    function&lt;void(T*)&gt; _del = [](T* ptr){delete ptr;};
};

}
}</code></pre> 
<h3 id="ncYuF">内存泄漏</h3> 
<p id="u95b3329d">什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内<br> 存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对<br> 该段内存的控制，因而造成了内存的浪费。<br> 内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现<br> 内存泄漏会导致响应越来越慢，最终卡死。</p> 
<p id="ubbc8c867">C/C++程序中一般我们关心两种方面的内存泄漏：<br><strong>堆内存泄漏(Heap leak)</strong><br> 堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一<br> 块内存，用完后必须通过调用相应的 free或者delete 删掉。假设程序的设计错误导致这部分<br> 内存没有被释放，那么以后这部分空间将无法再被使用，就会产生Heap Leak。<br><strong>系统资源泄漏</strong><br> 指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放<br> 掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。</p> 
<p id="u95287b83">如何检测内存泄漏（了解）<br> 在linux下内存泄漏检测：linux下几款内存泄漏检测工具<br> 在windows下使用第三方工具：VLD工具说明<br> 其他工具：内存泄漏工具比较<br> 2.4如何避免内存泄漏</p> 
<p id="ue6e4396c"></p> 
<ol><li id="u94cc59c9">工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps：<br> 这个理想状态。但是如果碰上异常时，就算注意释放了，还是可能会出问题。需要下一条智<br> 能指针来管理才有保证。</li><li id="ubbac4da3">采用RAII思想或者智能指针来管理资源。</li><li id="u38fc1cd7">有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。</li><li id="u970e0428">出问题了使用内存泄漏工具检测。ps：不过很多工具都不够靠谱，或者收费昂贵。</li></ol> 
<p id="uf7304473">总结一下:<br> 内存泄漏非常常见，解决方案分为两种：1、事前预防型。如智能指针等。2、事后查错型。如泄<br> 漏检测工具。</p> 
<p id="u9013b455"></p> 
<p id="u4682bc66"></p> 
<p id="u3ee1acb1"></p> 
<p id="ue96ecde2"></p> 
<p id="ud8939796"></p> 
<p id="u7ee8a230"></p> 
<p id="u6c30be21"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a82681caff8b8c7923bfadd6f983236b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C结构体内定义结构体，不能直接赋值。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/07f1307c41a9ca317bcb9af0b8460f86/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mybatis返回自增主键值</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>