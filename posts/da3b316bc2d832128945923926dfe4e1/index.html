<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【RabbitMQ】初识消息队列 MQ，基于 Docker 部署 RabbitMQ，探索 RabbitMQ 基本使用，了解常见的消息类型 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【RabbitMQ】初识消息队列 MQ，基于 Docker 部署 RabbitMQ，探索 RabbitMQ 基本使用，了解常见的消息类型" />
<meta property="og:description" content="文章目录 前言一、初识消息队列 MQ1.1 同步通信1.2 异步通信1.3 MQ 常见框架及其对比 二、初识 RabbitMQ2.1 什么是 RabbitMQ2.2 RabbitMQ 的结构 三、基于 Docker 部署 RabbitMQ四、常见的消息类型五、示例：在 Java 代码中通过 RabbitMQ 发送消息5.1 消息发布者5.2 消息消费者5.3 使用 RabbitMQ 的原生 Java 客户端操作消息队列存的问题 前言 一、初识消息队列 MQ 1.1 同步通信 同步通信是指发起请求后，调用者需要等待服务提供者的响应。
同步通信的例子 使用手机打电话就是一种同步通信，此时我们只能与一个妹子进行通话，但是如果有另外的妹子想要和自己通话，那么就会建立通话失败，想想确实是一件遗憾的事情。
同步通信在程序中的调用问题 比如，微服务间基于 Feign 实现远程调用，而这种调用方式就是一种同步通信，例如下面微服务之间的调用关系图：
通过这个图示，可以很好的展示在微服务中，同步通信存在的弊端：
用户通过手机端调用了支付服务，再目前这个架构中，其他的服务如订单服务、仓储服务、短信服务等等在支付服务中的调用代码都是线性关系，也就是说只有当支付功能完成后还需要调用其他的服务，调用完所有的微服务之后，支付服务才算完成。此时所有的微服务都是一个线性关系，因此用户支付所花费的时间就是所有微服务处理业务的时间总和了，此时带给用户的体验不佳不说，如果是面对高并发的场景，整个系统也很大可能会招架不住。此时由于所有微服务都是线性关系的，如果系统中的一个微服务宕机了，那么整个系统就会崩溃。如果要新增一个需求，即需要新增一个微服务，那么就会修改支付服务的代码，此时系统的耦合度较高。 因此，总体来说，同步调用存在如下问题：
耦合度高： 每次加入新的需求，都要修改原来的代码。性能下降： 调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用的时间之和。资源浪费： 调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源。级联失败： 如果服务提供者出现问题，所有调用方都会跟着出问题，如同多米诺骨牌一样，迅速导致整个微服务群故障。 但是对于同步通信来说也具有优点：
例如，它的时效性很强，就如电话通信一样，可以实时获取对方的消息。
1.2 异步通信 异步通信是指发起请求后，调用者不需要立即等待服务提供者的响应。
异步通信的例子 例如，通过微信发送信息就是一种一步通信，当收到了消息之后，我们才去看收到的消息。并且同时可以向多个妹子发消息，一个不回就换另一个发，总有一个回消息的。
异步通信的方案——事件驱动模式 异步通信常见实现就是事件驱动模式，即某个消息就绪了，再通知其他服务来处理，如下图所示，微服务的调用就采用了事件驱动的模式：
通过这个图示，可以很好的展示在微服务中，异步通信的优势：
用户通过手机端调用支付服务，支付功能完成后将支付成功的消息发送给Broker，此时反馈给用户的耗时也就是这两步的耗时之后，此时的时间就非常短了，带给用户的体验也更佳。
这里的 Broker代表的是消息中间件。在消息传递中，Broker 是一种常见的模式。消息中间件充当了消息的中心处理单元，它接收来自生产者的消息，将其存储在队列中，并将消息传递给消费者。这种模式有助于实现解耦、异步通信和提高系统的可伸缩性。
当 Broker 收到了支付成功的消息之后，立即向其他的订阅者通知自己收到了支付成功的消息，然后其他的微服务再向 Broker 获取这个消息来完成自己的业务。
此时各种微服务之间的依赖性大大降低了，如果一个微服务宕机了并不会对整个系统造成太大的影响，并且如果想要新增微服务的话也不需要改动其他微服务的代码，降低了耦合度。
另外，Broker 也起到了消息缓存的作用，如果突然产生了大量的消息，可以缓存到 Broker中，而不至于对其他微服务造成过大的压力。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/da3b316bc2d832128945923926dfe4e1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-04T13:50:20+08:00" />
<meta property="article:modified_time" content="2023-11-04T13:50:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【RabbitMQ】初识消息队列 MQ，基于 Docker 部署 RabbitMQ，探索 RabbitMQ 基本使用，了解常见的消息类型</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_5" rel="nofollow">前言</a></li><li><a href="#_MQ_7" rel="nofollow">一、初识消息队列 MQ</a></li><li><ul><li><a href="#11__9" rel="nofollow">1.1 同步通信</a></li><li><a href="#12__40" rel="nofollow">1.2 异步通信</a></li><li><a href="#13_MQ__76" rel="nofollow">1.3 MQ 常见框架及其对比</a></li></ul> 
  </li><li><a href="#_RabbitMQ_125" rel="nofollow">二、初识 RabbitMQ</a></li><li><ul><li><a href="#21__RabbitMQ_128" rel="nofollow">2.1 什么是 RabbitMQ</a></li><li><a href="#22_RabbitMQ__151" rel="nofollow">2.2 RabbitMQ 的结构</a></li></ul> 
  </li><li><a href="#_Docker__RabbitMQ_175" rel="nofollow">三、基于 Docker 部署 RabbitMQ</a></li><li><a href="#_235" rel="nofollow">四、常见的消息类型</a></li><li><a href="#_Java__RabbitMQ__271" rel="nofollow">五、示例：在 Java 代码中通过 RabbitMQ 发送消息</a></li><li><ul><li><a href="#51__272" rel="nofollow">5.1 消息发布者</a></li><li><a href="#52__332" rel="nofollow">5.2 消息消费者</a></li><li><a href="#53__RabbitMQ__Java__396" rel="nofollow">5.3 使用 RabbitMQ 的原生 Java 客户端操作消息队列存的问题</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_5"></a>前言</h2> 
<h2><a id="_MQ_7"></a>一、初识消息队列 MQ</h2> 
<h3><a id="11__9"></a>1.1 同步通信</h3> 
<p>同步通信是指发起请求后，调用者需要等待服务提供者的响应。</p> 
<blockquote> 
 <ol><li>同步通信的例子</li></ol> 
</blockquote> 
<p><img src="https://images2.imgbox.com/9a/33/CGNHC5Ax_o.png" alt=""><br> 使用手机打电话就是一种同步通信，此时我们只能与一个妹子进行通话，但是如果有另外的妹子想要和自己通话，那么就会建立通话失败，想想确实是一件遗憾的事情。</p> 
<blockquote> 
 <ol start="2"><li>同步通信在程序中的调用问题</li></ol> 
</blockquote> 
<p>比如，微服务间基于 Feign 实现远程调用，而这种调用方式就是一种同步通信，例如下面微服务之间的调用关系图：</p> 
<p><img src="https://images2.imgbox.com/e3/ba/6WBg6xXf_o.png" alt=""></p> 
<p><strong>通过这个图示，可以很好的展示在微服务中，同步通信存在的弊端：</strong></p> 
<ol><li>用户通过手机端调用了支付服务，再目前这个架构中，其他的服务如订单服务、仓储服务、短信服务等等在支付服务中的调用代码都是线性关系，也就是说只有当支付功能完成后还需要调用其他的服务，调用完所有的微服务之后，支付服务才算完成。</li><li>此时所有的微服务都是一个线性关系，因此用户支付所花费的时间就是所有微服务处理业务的时间总和了，此时带给用户的体验不佳不说，如果是面对高并发的场景，整个系统也很大可能会招架不住。</li><li>此时由于所有微服务都是线性关系的，如果系统中的一个微服务宕机了，那么整个系统就会崩溃。</li><li>如果要新增一个需求，即需要新增一个微服务，那么就会修改支付服务的代码，此时系统的耦合度较高。</li></ol> 
<p><strong>因此，总体来说，同步调用存在如下问题：</strong></p> 
<ol><li><strong>耦合度高：</strong> 每次加入新的需求，都要修改原来的代码。</li><li><strong>性能下降：</strong> 调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用的时间之和。</li><li><strong>资源浪费：</strong> 调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源。</li><li><strong>级联失败：</strong> 如果服务提供者出现问题，所有调用方都会跟着出问题，如同多米诺骨牌一样，迅速导致整个微服务群故障。</li></ol> 
<p><strong>但是对于同步通信来说也具有优点：</strong></p> 
<p>例如，它的时效性很强，就如电话通信一样，可以实时获取对方的消息。</p> 
<h3><a id="12__40"></a>1.2 异步通信</h3> 
<p>异步通信是指发起请求后，调用者不需要立即等待服务提供者的响应。</p> 
<blockquote> 
 <ol><li>异步通信的例子</li></ol> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e7/7c/UOMW7iOl_o.png" alt=""></p> 
<p>例如，通过微信发送信息就是一种一步通信，当收到了消息之后，我们才去看收到的消息。并且同时可以向多个妹子发消息，一个不回就换另一个发，总有一个回消息的。</p> 
<blockquote> 
 <ol start="2"><li>异步通信的方案——事件驱动模式</li></ol> 
</blockquote> 
<p>异步通信常见实现就是事件驱动模式，即某个消息就绪了，再通知其他服务来处理，如下图所示，微服务的调用就采用了事件驱动的模式：<br> <img src="https://images2.imgbox.com/97/bb/h71Sr3s1_o.png" alt=""></p> 
<p><strong>通过这个图示，可以很好的展示在微服务中，异步通信的优势：</strong></p> 
<ol><li> <p>用户通过手机端调用支付服务，支付功能完成后将支付成功的消息发送给<code>Broker</code>，此时反馈给用户的耗时也就是这两步的耗时之后，此时的时间就非常短了，带给用户的体验也更佳。</p> </li><li> <p>这里的 <code>Broker</code>代表的是消息中间件。在消息传递中，<code>Broker</code> 是一种常见的模式。消息中间件充当了消息的中心处理单元，它接收来自生产者的消息，将其存储在队列中，并将消息传递给消费者。这种模式有助于实现解耦、异步通信和提高系统的可伸缩性。</p> </li><li> <p>当 <code>Broker</code> 收到了支付成功的消息之后，立即向其他的订阅者通知自己收到了支付成功的消息，然后其他的微服务再向 <code>Broker</code> 获取这个消息来完成自己的业务。</p> </li><li> <p>此时各种微服务之间的依赖性大大降低了，如果一个微服务宕机了并不会对整个系统造成太大的影响，并且如果想要新增微服务的话也不需要改动其他微服务的代码，降低了耦合度。</p> </li><li> <p>另外，<code>Broker</code> 也起到了消息缓存的作用，如果突然产生了大量的消息，可以缓存到 <code>Broker</code>中，而不至于对其他微服务造成过大的压力。</p> </li></ol> 
<p><strong>因此，总体来说，异步通信具体如下的优点：</strong></p> 
<ol><li><strong>耦合度低：</strong> 利用中间件 <code>Broker</code> 对各个微服务实现了解耦，即使新增业务也不会对其他微服务造成影响。</li><li><strong>性能提升：</strong> 消息发布者只管将消息发送给中间件<code>Broker</code>，而无需关心其他微服务的执行。</li><li><strong>故障隔离：</strong> 由于耦合度降低，因此一个微服务发生了故障，不会对其他微服务造成影响。</li><li><strong>流量削峰：</strong> <code>Broker</code> 具有对消息的缓存作用，突然面对大量的并发的时候，可以起到缓冲作用。</li></ol> 
<p><strong>但是异步通信也具有如下的缺点：</strong></p> 
<ol><li>整个系统对消息中间件<code>Broker</code> 的可靠性依赖程度高，如果<code>Broker</code> 中间件异常了则会影响整个系统。</li><li>系统的架构更加复杂，业务没有明显的流程线，对业务管理追踪的难度大大提升。</li></ol> 
<h3><a id="13_MQ__76"></a>1.3 MQ 常见框架及其对比</h3> 
<p>MQ 是 “消息队列” 的缩写，它是一种在分布式系统中用于进行异步通信的技术。消息队列允许不同的软件组件或系统之间通过在消息队列中发送和接收消息来进行通信，而不需要直接连接彼此，在上述的事件驱动架构中，<code>Broker</code> 就是 MQ。</p> 
<p>在消息队列领域，有多种常见的框架，每个框架都有其优点和适用场景。一些常见的消息队列框架有：RabbitMQ、ActiveMQ、RocketMQ 和 Kafka 。它们都是消息中间件（Message Queue）系统，用于实现分布式系统中不同组件之间的异步通信。它们在设计和使用方面有一些区别，以下是它们的简要介绍：</p> 
<ol><li> <p><strong>RabbitMQ:</strong></p> 
  <ul><li><strong>特点：</strong> RabbitMQ 是一个开源的消息代理软件，实现了高级消息队列协议（AMQP）。</li><li><strong>设计理念：</strong> 设计简单、易于使用，支持广泛的消息传递模式，包括点对点、发布/订阅、请求/响应等。</li><li><strong>语言支持：</strong> 支持多种编程语言，如Java、Python、Ruby等。</li><li><strong>可靠性：</strong> 提供持久性消息、消息确认等机制，确保消息的可靠性传递。</li></ul> </li><li> <p><strong>ActiveMQ:</strong></p> 
  <ul><li><strong>特点：</strong> ActiveMQ 是一个开源的消息中间件，实现了Java Message Service（JMS）规范。</li><li><strong>设计理念：</strong> 面向Java应用，提供了丰富的API，支持多种消息传递模式和高级功能。</li><li><strong>语言支持：</strong> 主要支持Java，但也有一些其他语言的客户端。</li><li><strong>可靠性：</strong> 提供持久订阅、消息事务等功能，确保可靠性和一致性。</li></ul> </li><li> <p><strong>RocketMQ:</strong></p> 
  <ul><li><strong>特点：</strong> RocketMQ 是阿里巴巴开源的分布式消息中间件系统。</li><li><strong>设计理念：</strong> 设计为分布式、水平可扩展的系统，适用于大规模数据的处理。</li><li><strong>语言支持：</strong> 提供Java、C++、Python等多语言的客户端。</li><li><strong>可靠性：</strong> 支持多种消息传递模式，具备高可用性、高吞吐量和低延迟的特性。</li></ul> </li><li> <p><strong>Kafka:</strong></p> 
  <ul><li><strong>特点：</strong> Kafka 是由Apache软件基金会开发的分布式流处理平台，兼具消息队列和日志系统的功能。</li><li><strong>设计理念：</strong> 设计为高吞吐、持久性、可水平扩展的分布式系统，用于处理实时数据流。</li><li><strong>语言支持：</strong> 提供Java和Scala等语言的客户端。</li><li><strong>可靠性：</strong> 提供副本机制、持久性日志存储等特性，适用于大规模数据流的处理。</li></ul> </li></ol> 
<p><strong>如下表所示，总结了这四种消息队列在不同方面的差异：</strong></p> 
<table><thead><tr><th align="left">特性</th><th align="left">RabbitMQ</th><th align="left">ActiveMQ</th><th align="left">RocketMQ</th><th align="left">Kafka</th></tr></thead><tbody><tr><td align="left">公司/社区</td><td align="left">Rabbit</td><td align="left">Apache</td><td align="left">阿里</td><td align="left">Apache</td></tr><tr><td align="left">开发语言</td><td align="left">Erlang</td><td align="left">Java</td><td align="left">Java</td><td align="left">Scala&amp;Java</td></tr><tr><td align="left">协议支持</td><td align="left">AMQP, XMPP, SMTP, STOMP</td><td align="left">OpenWire, STOMP, REST, XMPP, AMQP</td><td align="left">自定义协议</td><td align="left">自定义协议</td></tr><tr><td align="left">可用性</td><td align="left">高</td><td align="left">一般</td><td align="left">高</td><td align="left">高</td></tr><tr><td align="left">单机吞吐量</td><td align="left">一般</td><td align="left">差</td><td align="left">高</td><td align="left">非常高</td></tr><tr><td align="left">消息延迟</td><td align="left">微秒级</td><td align="left">毫秒级</td><td align="left">毫秒级</td><td align="left">毫秒以内</td></tr><tr><td align="left">消息可靠性</td><td align="left">高</td><td align="left">一般</td><td align="left">高</td><td align="left">一般</td></tr></tbody></table> 
<p>这个表格展示了这四个消息队列框架的一些关键特性的对比。总体而言，选择其中一个消息中间件系统通常取决于具体的业务需求、系统架构以及性能要求。不同的系统可能更适合不同的消息中间件。</p> 
<h2><a id="_RabbitMQ_125"></a>二、初识 RabbitMQ</h2> 
<h3><a id="21__RabbitMQ_128"></a>2.1 什么是 RabbitMQ</h3> 
<p><strong>RabbitMQ</strong> 是一个开源的消息代理软件，实现了高级消息队列协议（AMQP）。它允许不同应用之间进行异步通信，并提供了一种有效的方式来处理分布式系统中的大量消息。</p> 
<p>官方网站：<a href="https://www.rabbitmq.com" rel="nofollow">https://www.rabbitmq.com</a></p> 
<p><strong>下面是 RabbitMQ 的一些关键特点：</strong></p> 
<ul><li> <p><strong>消息代理：</strong> RabbitMQ 充当消息代理，负责接收、存储和转发消息。</p> </li><li> <p><strong>消息队列：</strong> 通过消息队列实现消息的存储和传递，允许生产者将消息发送到队列，而消费者从队列中接收消息。</p> </li><li> <p><strong>消息模型：</strong> 支持多种消息传递模型，包括点对点、发布/订阅、请求/响应等。</p> </li><li> <p><strong>可靠性：</strong> 提供持久性消息、消息确认等机制，确保消息的可靠传递。</p> </li><li> <p><strong>灵活性：</strong> RabbitMQ 是高度可配置的，支持多种插件和扩展，可以适应不同的应用场景。</p> </li><li> <p><strong>跨平台：</strong> 支持多种操作系统，并提供多种语言的客户端，如 Java、Python、Ruby 等。</p> </li></ul> 
<p>RabbitMQ 的设计理念是简单、灵活、可靠，并且具有广泛的应用领域，从企业级应用到小型项目都能发挥其优势。通过使用 RabbitMQ，开发人员可以更轻松地实现分布式系统中的消息传递和解耦。</p> 
<h3><a id="22_RabbitMQ__151"></a>2.2 RabbitMQ 的结构</h3> 
<p>RabbitMQ 的整体结构如下图所示：</p> 
<p><img src="https://images2.imgbox.com/66/00/6n9pLhaz_o.png" alt="RabbitMQ Structure"></p> 
<p>在上图中，我们可以看到 RabbitMQ 的结构主要涉及以下几个核心概念：</p> 
<ul><li> <p><strong>Producer（生产者）：</strong> 生产者是消息的发送方，负责将消息发送到 RabbitMQ 服务器。</p> </li><li> <p><strong>Exchange（交换机）：</strong> 交换机接收来自生产者的消息，并将其路由到一个或多个队列。交换机有不同的类型，包括直连交换机（direct）、主题交换机（topic）、扇出交换机（fanout）等，用于定义消息的路由规则。</p> </li><li> <p><strong>Queue（队列）：</strong> 队列是消息的存储位置，生产者或交换机将消息发送到队列，而消费者则从队列中接收消息进行处理。</p> </li><li> <p><strong>Binding（绑定）：</strong> 绑定定义了 Exchange 和 Queue 之间的关系，指定消息如何从 Exchange 路由到特定的队列。绑定规则根据交换机的类型而异。</p> </li><li> <p><strong>Consumer（消费者）：</strong> 消费者是消息的接收方，负责从队列中获取消息并进行相应的处理。</p> </li><li> <p><strong>VirtualHost（虚拟主机）：</strong> 虚拟主机是逻辑上的隔离单位，每个虚拟主机都拥有自己的独立的用户、交换机、队列等资源，用于隔离不同应用或团队的消息流。</p> </li></ul> 
<p>RabbitMQ 的结构允许构建灵活的消息传递系统，支持多种消息传递模式和路由策略，使其适用于各种不同的应用场景。这种灵活性使得 RabbitMQ 成为分布式系统中常用的消息中间件。</p> 
<h2><a id="_Docker__RabbitMQ_175"></a>三、基于 Docker 部署 RabbitMQ</h2> 
<p>RabbitMQ的部署分为单机部署和集群部署，这里以单机部署为例。在 Centos7 虚拟机中使用 Docker 部署 RabbitMQ，以下是单例部署的步骤：</p> 
<ol><li> <p><strong>拉取 RabbitMQ 镜像</strong></p> <p>使用以下命令拉取带有管理插件的 RabbitMQ 镜像：</p> <pre><code class="prism language-sh"><span class="token function">docker</span> pull rabbitmq:3-management
</code></pre> </li></ol> 
<p><img src="https://images2.imgbox.com/74/75/UGqdZA0U_o.png" alt=""></p> 
<ol start="2"><li> <p><strong>启动 RabbitMQ 容器</strong></p> <p>执行以下命令启动 RabbitMQ 容器：</p> <pre><code class="prism language-sh"><span class="token function">docker</span> run <span class="token punctuation">\</span>
<span class="token parameter variable">-e</span> <span class="token assign-left variable">RABBITMQ_DEFAULT_USER</span><span class="token operator">=</span>yourname <span class="token punctuation">\</span>
<span class="token parameter variable">-e</span> <span class="token assign-left variable">RABBITMQ_DEFAULT_PASS</span><span class="token operator">=</span>yourpassword <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> mq-plugins:/plugins <span class="token punctuation">\</span>
<span class="token parameter variable">--name</span> mq <span class="token punctuation">\</span>
<span class="token parameter variable">--hostname</span> mq1 <span class="token punctuation">\</span>
<span class="token parameter variable">-p</span> <span class="token number">15672</span>:15672 <span class="token punctuation">\</span>
<span class="token parameter variable">-p</span> <span class="token number">5672</span>:5672 <span class="token punctuation">\</span>
<span class="token parameter variable">-d</span> <span class="token punctuation">\</span>
rabbitmq:3-management
</code></pre> 
  <ul><li><code>yourname</code>：自定义的 RabbitMQ 用户名。</li><li><code>yourpassword</code>：自定义的 RabbitMQ 密码。</li></ul> </li></ol> 
<p>例如：<br> <img src="https://images2.imgbox.com/2c/a7/gDmt4DF1_o.png" alt=""></p> 
<ol start="3"><li> <p><strong>访问 RabbitMQ 管理界面</strong></p> <p>启动成功后，通过浏览器访问 <code>宿主机IP:15672</code>，使用上述用户名和密码登录 RabbitMQ 管理界面。</p> </li></ol> 
<p><img src="https://images2.imgbox.com/4c/3e/04hg9KNc_o.png" alt=""></p> 
<p>在管理界面中，我们可以监控队列、交换机，查看连接、通道等信息。</p> 
<p><img src="https://images2.imgbox.com/e6/a5/6Y6wbolB_o.png" alt=""></p> 
<p>通过上述步骤，就完成了基于 Docker 的 RabbitMQ 单例部署。在实际生产环境中，可能还需要考虑持久化配置、集群部署等问题。</p> 
<h2><a id="_235"></a>四、常见的消息类型</h2> 
<p>RabbitMQ 提供了多种消息传递模型，常见的消息类型包括以下几种，对应 RabbitMQ 官方文档中的不同示例：</p> 
<ol><li> <p><strong>基本消息队列（BasicQueue）</strong><br> <img src="https://images2.imgbox.com/75/01/0r6pq9T1_o.png" alt="BasicQueue"></p> 
  <ul><li><strong>描述：</strong> 这是最简单的消息队列模型，一个生产者发送消息到队列，一个消费者从队列中接收并处理消息。</li></ul> </li><li> <p><strong>工作消息队列（WorkQueue）</strong></p> <p><img src="https://images2.imgbox.com/39/1b/qLKJRDWt_o.png" alt="WorkQueue"></p> 
  <ul><li><strong>描述：</strong> 多个消费者共享一个队列，生产者发送消息到队列，其中一个消费者接收并处理消息。适用于任务分发和负载均衡。</li></ul> </li><li> <p><strong>发布订阅（Publish、Subscribe）</strong></p> 
  <ul><li> <p><strong>广播（Fanout Exchange）</strong></p> <p><img src="https://images2.imgbox.com/88/9e/cYS5jK1A_o.png" alt="Fanout Exchange"></p> 
    <ul><li><strong>描述：</strong> 生产者将消息发送到交换机，交换机将消息广播到所有与之绑定的队列。每个队列都有自己的消费者。</li></ul> </li><li> <p><strong>路由（Direct Exchange）</strong></p> <p><img src="https://images2.imgbox.com/6b/28/O1hVB7hG_o.png" alt="Direct Exchange"></p> 
    <ul><li><strong>描述：</strong> 生产者发送带有指定路由键的消息到交换机，交换机根据路由键将消息路由到匹配的队列。每个队列有一个或多个消费者。</li></ul> </li><li> <p><strong>主题（Topic Exchange）</strong></p> <p><img src="https://images2.imgbox.com/5a/3f/Ce8JbhX0_o.png" alt="Topic Exchange"></p> 
    <ul><li><strong>描述：</strong> 类似于直连交换机，但是主题交换机允许使用通配符进行匹配，以实现更灵活的消息路由。</li></ul> </li></ul> </li></ol> 
<p>这些不同的消息类型满足了不同的应用场景需求，使 RabbitMQ 成为一个灵活而强大的消息中间件。通过选择合适的消息模型，开发人员可以更好地满足系统设计的要求。</p> 
<h2><a id="_Java__RabbitMQ__271"></a>五、示例：在 Java 代码中通过 RabbitMQ 发送消息</h2> 
<h3><a id="51__272"></a>5.1 消息发布者</h3> 
<p>以下是一个通过 Java 中单元测试的代码向 RabbitMQ 发送消息的示例。在这个示例中，我们使用 RabbitMQ 的 Java 客户端库来创建连接、通道，并发送消息到队列。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PublisherTest</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1.建立连接</span>
        <span class="token class-name">ConnectionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span>
        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"192.168.146.128"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        factory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 1.2.建立连接</span>
        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 2.创建通道Channel</span>
        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 3.创建队列</span>
        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>
        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 4.发送消息</span>
        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"Hello, RabbitMQ!"</span><span class="token punctuation">;</span>
        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> queueName<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送消息成功：【"</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 5.关闭通道和连接</span>
        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>对上述代码的说明：</p> 
<ol><li> <p><strong>建立连接：</strong> 使用 <code>ConnectionFactory</code> 创建连接，并设置 RabbitMQ 服务器的地址、端口号、用户名和密码。</p> </li><li> <p><strong>创建通道：</strong> 通过连接创建通道，大部分的 RabbitMQ 操作都是通过通道进行的。</p> </li><li> <p><strong>创建队列：</strong> 使用通道创建一个名为 <code>simple.queue</code> 的队列，如果该队列不存在则会被创建。</p> </li><li> <p><strong>发送消息：</strong> 使用 <code>basicPublish</code> 方法发送消息到指定的队列。在本例中，消息内容为 “Hello, RabbitMQ!”。</p> </li><li> <p><strong>关闭通道和连接：</strong> 释放资源，关闭通道和连接。</p> </li></ol> 
<p>然后运行这段代码：</p> 
<p><img src="https://images2.imgbox.com/02/89/2jBbwuoL_o.png" alt=""></p> 
<p>可以发现在 RabbitMQ 的管理页面就多了一个 <code>simple.queue</code> 的队列，并且其中有一条未消费的消息：</p> 
<p><img src="https://images2.imgbox.com/aa/60/b3aSGLoY_o.png" alt=""><br> 点击消息的名称，然后在点击获取消息，就可以看到具体的消息内容了。<br> <img src="https://images2.imgbox.com/5b/c3/KXkaPbUi_o.png" alt=""></p> 
<h3><a id="52__332"></a>5.2 消息消费者</h3> 
<p>以下是一个通过 Java中单元测试的代码实现的 RabbitMQ 消息消费者示例。在这个示例中，我们使用 RabbitMQ 的 Java 客户端库来创建连接、通道，并从队列中接收和处理消息。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsumerTest</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1.建立连接</span>
        <span class="token class-name">ConnectionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span>
        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"192.168.146.128"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        factory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 1.2.建立连接</span>
        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 2.创建通道Channel</span>
        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 3.创建队列</span>
        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>
        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 4.订阅消息</span>
        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span><span class="token class-name">String</span> consumerTag<span class="token punctuation">,</span> <span class="token class-name">Envelope</span> envelope<span class="token punctuation">,</span>
                                       <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span> properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 5.处理消息</span>
                <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到消息：【"</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待接收消息。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>对上述代码的说明：</p> 
<ol><li> <p><strong>建立连接：</strong> 使用 ConnectionFactory 创建连接，并设置 RabbitMQ 服务器的地址、端口号、用户名和密码。</p> </li><li> <p><strong>创建通道：</strong> 通过连接创建通道，大部分的 RabbitMQ 操作都是通过通道进行的。</p> </li><li> <p><strong>创建队列：</strong> 使用通道创建一个名为 simple.queue 的队列，如果该队列不存在则会被创建。</p> </li><li> <p><strong>订阅消息：</strong> 使用 basicConsume 方法订阅消息。在本例中，我们使用匿名内部类继承 DefaultConsumer 类，并重写 handleDelivery 方法来处理接收到的消息。</p> </li><li> <p><strong>处理消息：</strong> 在 handleDelivery 方法中，处理接收到的消息。在本例中，我们简单地打印出接收到的消息。</p> </li></ol> 
<p>运行这段代码，成功获取到了 <code>simple.queue</code> 队列中的消息：</p> 
<p><img src="https://images2.imgbox.com/7b/fa/BYpl5qDi_o.png" alt=""></p> 
<p>在 RabbitMQ 的管理页面中， <code>simple.queue</code> 队列中消费过的消息也被删除了：</p> 
<p><img src="https://images2.imgbox.com/06/85/9sZVX1DJ_o.png" alt=""></p> 
<h3><a id="53__RabbitMQ__Java__396"></a>5.3 使用 RabbitMQ 的原生 Java 客户端操作消息队列存的问题</h3> 
<p>通过上述对消息的发布和消费两个例子，发现了使用 RabbitMQ 的原生 Java 客户端操作消息队列存在一些问题，其中包括：</p> 
<ol><li> <p><strong>样板代码繁琐：</strong> 使用原生客户端需要编写很多样板代码，例如创建连接、通道，声明队列、交换机等。这使得代码显得冗长且容易出错。</p> </li><li> <p><strong>异常处理繁琐：</strong> 处理连接、通道等的异常，以及消息的手动确认（acknowledgment）等操作都需要额外的处理，增加了代码的复杂性。</p> </li><li> <p><strong>线程安全问题：</strong> RabbitMQ 的 Java 客户端不是线程安全的，因此需要确保在多线程环境中正确处理连接、通道的共享与释放。</p> </li><li> <p><strong>不便于整合：</strong> 如果项目使用了 Spring 框架，使用原生客户端可能不够方便与 Spring 进行整合。</p> </li></ol> 
<p>为了解决这些问题，可以使用 Spring AMQP（Spring 对 AMQP 协议的支持）来简化 RabbitMQ 操作。Spring AMQP 提供了更高级别的抽象，通过配置简化了连接、通道的创建，提供了更易用的消息发送和接收的方式，同时处理了很多底层细节。</p> 
<p>使用 Spring AMQP 可以极大地简化 RabbitMQ 相关的操作，提高代码的可维护性和可读性。Spring AMQP 还提供了一些其他特性，如事务管理、消息确认机制等，使得消息队列的操作更加健壮。</p> 
<p>关于 Spring AMQP 的使用，将在后续文章中进行展示。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/db77107067f1afe8c7c638d4ed2501a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">华硕B85M-E主板图解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fe1c23cdd7925bb7107e0562515e1249/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">google scholar 显示异常流量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>