<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32基于HAL库的IIC协议读取温湿度 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32基于HAL库的IIC协议读取温湿度" />
<meta property="og:description" content="目录
一、解决的问题
二、12C总线通信协议
1、什么是12C协议 ：
2、12C总线的物理层：
3、12C总线的协议层：
4、 I2C的两种方式——硬件I2C和软件I2C：
三、搭建STM32开发环境（HAL库环境）
四、 利用HAL库新建一个温湿度采集工程 五、完善keil工程
六、电路连接与运行结果展示
1、电路连接与配置： 2、烧录运行结果展示：
七、总结
八、参考资料 一、解决的问题 学习I2C总线通信协议，使用STM32F103完成基于I2C协议的AHT20温湿度传感器的数据采集，并将采集的温度-湿度值通过串口输出。具体任务：
1）解释什么是“软件I2C”和“硬件I2C”？ （阅读野火配套教材的第23章“I2C--读写EEPROM”原理章节）
2）阅读AHT20数据手册，编程实现：每隔2秒钟采集一次温湿度数据，并通过串口发送到上位机（win10）。
二、12C总线通信协议 1、什么是12C协议 ： I2C总线是一种双向的同步串行总线，它支持设备之间的短距离通信，经常用于处理器和一些外围设备之间的接口通信。I2C总线的标准通信速率是100Kbps，快速模式是400Kbps，高速模式支持3.4Mbps。I2C总线支持多设备的通信，而且各个设备之间的SCL和SDA线都是线与关系。I2C总线上扩展的器件的数量主要由电容负载来决定，其负载能力为400pF。I2C总线具有极低的电流消耗。
2、12C总线的物理层： I2C总线物理层由两根线组成：串行时钟线SCL、串行数据线SDA。由于这两根线都是开漏输出结构，因此必须都接上拉电阻到高电平，因此当总线处于空闲状态时，两根线都处于高电平状态。下图为I2C总线的物理层示意图：
它的物理层有如下特点：
(1) 它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯总线中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。
(2) 一个 I2C 总线只使用两条总线线路，一条双向串行数据线(SDA) ，一条串行时钟线(SCL)。数据线即用来表示数据，时钟线用于数据收发同步。
(3) 每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。
(4) 总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。
(5) 多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。
(6) 具有三种传输模式：标准模式传输速率为 100kbit/s ，快速模式为 400kbit/s ，高速模式下可达 3.4Mbit/s，但目前大多 I 2 C 设备尚不支持高速模式。
(7) 连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制 。 3、12C总线的协议层： I2C总线上的每一个设备都可以作为主设备或者从设备，而且每一个设备都会对应一个唯一的设备地址。通常的我们将CPU模块作为主设备，而挂接在总线上的其他设备作为从设备。I2C总线上的主设备与从设备之间以8字节为单位进行双向数据传输，并且每个单位后还须跟着一位ACK位。其中数据在SCL处于低电平时被放到SDA数据线上，在SCL处于高电平时进行数据的采样。下图是I2C总线8位数据传输协议时序图。：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c8bae5b025e215147228c45f18da8e22/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-09T09:36:22+08:00" />
<meta property="article:modified_time" content="2023-11-09T09:36:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32基于HAL库的IIC协议读取温湿度</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98" rel="nofollow">一、解决的问题</a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%8112C%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%8C%E3%80%8112C%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE" rel="nofollow">二、12C总线通信协议</a></p> 
<p id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF12C%E5%8D%8F%E8%AE%AE%20%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF12C%E5%8D%8F%E8%AE%AE%20%EF%BC%9A" rel="nofollow">1、什么是12C协议 ：</a></p> 
<p id="%C2%A02%E3%80%8112C%E6%80%BB%E7%BA%BF%E7%9A%84%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A02%E3%80%8112C%E6%80%BB%E7%BA%BF%E7%9A%84%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%9A" rel="nofollow"> 2、12C总线的物理层：</a></p> 
<p id="%C2%A03%E3%80%8112C%E6%80%BB%E7%BA%BF%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%B1%82%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A03%E3%80%8112C%E6%80%BB%E7%BA%BF%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%B1%82%EF%BC%9A" rel="nofollow"> 3、12C总线的协议层：</a></p> 
<p id="%C2%A04%E3%80%81%C2%A0I2C%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6I2C%E5%92%8C%E8%BD%AF%E4%BB%B6I2C%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A04%E3%80%81%C2%A0I2C%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6I2C%E5%92%8C%E8%BD%AF%E4%BB%B6I2C%EF%BC%9A" rel="nofollow"> 4、 I2C的两种方式——硬件I2C和软件I2C：</a></p> 
<p id="%C2%A0%E4%B8%89%E3%80%81%E6%90%AD%E5%BB%BASTM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%88HAL%E5%BA%93%E7%8E%AF%E5%A2%83%EF%BC%89-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%E3%80%81%E6%90%AD%E5%BB%BASTM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%88HAL%E5%BA%93%E7%8E%AF%E5%A2%83%EF%BC%89" rel="nofollow">三、搭建STM32开发环境（HAL库环境）</a></p> 
<p id="%E5%9B%9B%E3%80%81%C2%A0%E5%88%A9%E7%94%A8HAL%E5%BA%93%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%87%87%E9%9B%86%E5%B7%A5%E7%A8%8B%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%C2%A0%E5%88%A9%E7%94%A8HAL%E5%BA%93%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%87%87%E9%9B%86%E5%B7%A5%E7%A8%8B%C2%A0" rel="nofollow">四、 利用HAL库新建一个温湿度采集工程 </a></p> 
<p id="%C2%A0%E4%BA%94%E3%80%81%E5%AE%8C%E5%96%84keil%E5%B7%A5%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%94%E3%80%81%E5%AE%8C%E5%96%84keil%E5%B7%A5%E7%A8%8B" rel="nofollow"> 五、完善keil工程</a></p> 
<p id="%C2%A0%E5%85%AD%E3%80%81%E7%94%B5%E8%B7%AF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%85%AD%E3%80%81%E7%94%B5%E8%B7%AF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA" rel="nofollow"> 六、电路连接与运行结果展示</a></p> 
<p id="1%E3%80%81%E7%94%B5%E8%B7%AF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%85%8D%E7%BD%AE%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%94%B5%E8%B7%AF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%85%8D%E7%BD%AE%EF%BC%9A%C2%A0" rel="nofollow">1、电路连接与配置： </a></p> 
<p id="2%E3%80%81%E7%83%A7%E5%BD%95%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E7%83%A7%E5%BD%95%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA%EF%BC%9A" rel="nofollow">2、烧录运行结果展示：</a></p> 
<p id="%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">七、总结</a></p> 
<p id="%E5%85%AB%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%C2%A0" rel="nofollow">八、参考资料 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">一、解决的问题</h2> 
<p>       学习I2C总线通信协议，使用STM32F103完成基于I2C协议的AHT20温湿度传感器的数据采集，并将采集的温度-湿度值通过串口输出。具体任务：</p> 
<p>1）解释什么是“软件I2C”和“硬件I2C”？ （阅读野火配套教材的第23章“I2C--读写EEPROM”原理章节）</p> 
<p>2）阅读AHT20数据手册，编程实现：每隔2秒钟采集一次温湿度数据，并通过串口发送到上位机（win10）。</p> 
<h2 id="%C2%A0%E4%BA%8C%E3%80%8112C%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE">二、12C总线通信协议</h2> 
<h3 id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF12C%E5%8D%8F%E8%AE%AE%20%EF%BC%9A">1、什么是12C协议 ：</h3> 
<p>        I2C总线是一种双向的同步串行总线，它支持设备之间的短距离通信，经常用于处理器和一些外围设备之间的接口通信。I2C总线的标准通信速率是100Kbps，快速模式是400Kbps，高速模式支持3.4Mbps。I2C总线支持多设备的通信，而且各个设备之间的SCL和SDA线都是线与关系。I2C总线上扩展的器件的数量主要由电容负载来决定，其负载能力为400pF。I2C总线具有极低的电流消耗。</p> 
<h3 id="%C2%A02%E3%80%8112C%E6%80%BB%E7%BA%BF%E7%9A%84%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%9A"> 2、12C总线的物理层：</h3> 
<p>       I2C总线物理层由两根线组成：<strong>串行时钟线SCL</strong>、<strong>串行数据线SDA</strong>。由于这两根线都是开漏输出结构，因此必须都接<strong>上拉电阻</strong>到高电平，因此当总线处于空闲状态时，两根线都处于<strong>高电平状态</strong>。下图为I2C总线的物理层示意图：</p> 
<p><img alt="" height="265" src="https://images2.imgbox.com/ad/b8/6Sv0QmZZ_o.png" width="718"></p> 
<p>它的物理层有如下特点：<br> (1) 它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯总线中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。<br> (2) 一个 I2C 总线只使用两条总线线路，一条双向串行数据线(SDA) ，一条串行时钟线(SCL)。数据线即用来表示数据，时钟线用于数据收发同步。</p> 
<p>(3) 每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。<br> (4) 总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。<br> (5) 多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。<br> (6) 具有三种传输模式：标准模式传输速率为 100kbit/s ，快速模式为 400kbit/s ，高速模式下可达 3.4Mbit/s，但目前大多 I 2 C 设备尚不支持高速模式。<br> (7) 连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制 。 </p> 
<h3 id="%C2%A03%E3%80%8112C%E6%80%BB%E7%BA%BF%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%B1%82%EF%BC%9A"> 3、12C总线的协议层：</h3> 
<p>       I2C总线上的每一个设备都可以作为主设备或者从设备，而且每一个设备都会对应一个唯一的设备地址。通常的我们将CPU模块作为主设备，而挂接在总线上的其他设备作为从设备。I2C总线上的主设备与从设备之间以8字节为单位进行双向数据传输，并且每个单位后还须跟着一位ACK位。其中数据在SCL处于低电平时被放到SDA数据线上，在SCL处于高电平时进行数据的采样。下图是I2C总线8位数据传输协议时序图。：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/14/d4/k58VbZFv_o.png"></p> 
<p>        其实I2C也是支持10位地址空间的。对于10位地址的传输时序，需要2个地址帧完成地址的传输，其他和8位的传输协议相同。下图为10位地址传输时序图：</p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/9c/db/MJzNnkdH_o.png" width="847"></p> 
<p>       I2C 的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节。</p> 
<ul><li><strong>通讯的起始和停止信号：</strong></li></ul> 
<p>        当 SCL 线是高电平时 SDA 线从高电平向低电平切换，这个情况表示通讯的起始。当 SCL 是高电平时 SDA线由低电平向高电平切换，表示通讯的停止。起始和停止信号一般由主机产生。<img alt="" height="178" src="https://images2.imgbox.com/a3/b3/qjWsOSip_o.png" width="641"></p> 
<p></p> 
<ul><li><strong> 数据有效性</strong></li></ul> 
<p>        I2C使用 SDA信号线来传输数据，使用 SCL信号线进行数据同步。见图 24-6。SDA数据线在 SCL的每个时钟周期传输一位数据。传输时，SCL为高电平的时候 SDA表示的数据有效，即此时的SDA为高电平时表示数据“1”，为低电平时表示数据“0”。当SCL为低电平时，SDA的数据无效，一般在这个时候 SDA进行电平切换，为下一次表示数据做好准备。 </p> 
<p><img alt="" height="254" src="https://images2.imgbox.com/a6/ef/Ner7U7CN_o.png" width="500"></p> 
<p>每次数据传输都以字节为单位，每次传输的字节数不受限制。</p> 
<ul><li><strong>地址及数据方向 </strong></li></ul> 
<p>       12C 总线上的每个设备都有自己的独立地址，主机发起通讯时，通过 SDA 信号线发送设备地址(SLAVE_ADDRESS)来查找从机。I2C 协议规定设备地址可以是 7 位或 10 位，实际中 7 位的地址应用比较广泛。紧跟设备地址的一个数据位用来表示数据传输方向，它是 数据方向位(R/W)，第 8位或第 11位。数据方向位为“1”时表示主机由从机读数据，该位为“0”时表示主机向从机写数据.</p> 
<p><img alt="" height="200" src="https://images2.imgbox.com/d5/78/fa3SyexX_o.png" width="690"></p> 
<p>       读数据方向时，主机会释放对 SDA 信号线的控制，由从机控制 SDA 信号线，主机接收信号，写数据方向时，SDA由主机控制，从机接收信号。</p> 
<ul><li><strong>响应 </strong></li></ul> 
<p>        I2C 的数据和地址传输都带响应。响应包括“应答(ACK)”和“非应答(NACK)”两种信号。作为数据接收端时，当设备(无论主从机)接收到 I2C传输的一个字节数据或地址后，若希望对方继续发送数据，则需要向对方发送“应答(ACK)”信号，发送方会继续发送下一个数据；若接收端希望结束数据传输，则向对方发送“非应答(NACK)”信号，发送方接收到该信号后会产生一个停止信号，结束信号传输。 </p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/8e/c5/YeRfSgDd_o.png" width="737">       传输时主机产生时钟，在第 9 个时钟时，数据发送端会释放 SDA 的控制权，由数据接收端控制 SDA，若 SDA 为高电平，表示非应答信号(NACK)，低电平表示应答信号(ACK)</p> 
<h3 id="%C2%A04%E3%80%81%C2%A0I2C%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6I2C%E5%92%8C%E8%BD%AF%E4%BB%B6I2C%EF%BC%9A"> 4、 I2C的两种方式——硬件I2C和软件I2C：</h3> 
<ul><li><strong>硬件I2C</strong></li></ul> 
<p>        一块硬件电路，硬件I2C对应芯片上的I2C外设，有相应I2C驱动电路，其所使用的I2C管脚也是专用的，硬件（固件）I2C是直接调用内部寄存器进行配置直接利用 STM32 芯片中的硬件 I2C 外设。</p> 
<blockquote> 
 <p><code>硬件I2C的使用</code><br>        只要配置好对应的寄存器，外设就会产生标准串口协议的时序。在初始化好 I2C 外设后，只需要把某寄存器位置 1，此时外设就会控制对应的 SCL 及 SDA 线自动产生 I2C 起始信号，不需要内核直接控制引脚的电平。</p> 
</blockquote> 
<ul><li><strong>软件I2C</strong></li></ul> 
<p><strong>       软件IIC</strong> 软件IIC通信指的是用单片机的两个I/O端口模拟出来的IIC，用软件控制管脚状态以模拟I2C通信波形，软件模拟寄存器的工作方式。直接使用 CPU 内核按照 I2C 协议的要求控制 GPIO 输出高低电平，从而模拟I2C。</p> 
<blockquote> 
 <p><code>软件I2C的使用</code><br>        需要在控制产生 I2C 的起始信号时，控制作为 SCL 线的 GPIO 引脚输出高电平，然后控制作为 SDA 线的 GPIO 引脚在此期间完成由高电平至低电平的切换，最后再控制SCL 线切换为低电平，这样就输出了一个标准的 I2C 起始信号。</p> 
</blockquote> 
<ul><li><strong>两者的差别</strong></li></ul> 
<p>       硬件 I2C 直接使用外设来控制引脚，可以减轻 CPU 的负担。不过使用硬件I2C 时必须使用某些固定的引脚作为 SCL 和 SDA，软件模拟 I2C 则可以使用任意 GPIO 引脚，相对比较灵活。对于硬件I2C用法比较复杂，软件I2C的流程更清楚一些。如果要详细了解I2C的协议，使用软件I2C可能更好的理解这个过程。在使用I2C过程，硬件I2C可能通信更加快，更加稳定。</p> 
<blockquote> 
 <p><strong>注：本次实验通过软件I2C模拟实现！！！</strong></p> 
</blockquote> 
<h2 id="%C2%A0%E4%B8%89%E3%80%81%E6%90%AD%E5%BB%BASTM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%88HAL%E5%BA%93%E7%8E%AF%E5%A2%83%EF%BC%89">三、搭建STM32开发环境（HAL库环境）</h2> 
<p> 请参考我的这篇博客：<a href="https://blog.csdn.net/m0_63323712/article/details/133910039" title="STM32使用HAL库点亮流水灯-CSDN博客">STM32使用HAL库点亮流水灯-CSDN博客</a></p> 
<h2 id="%E5%9B%9B%E3%80%81%C2%A0%E5%88%A9%E7%94%A8HAL%E5%BA%93%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%87%87%E9%9B%86%E5%B7%A5%E7%A8%8B%C2%A0">四、 利用HAL库新建一个温湿度采集工程 </h2> 
<p>（1）打开STM32CubeMX，在主界面点击：ACCESS TO MCU SELECTOR:</p> 
<p><img alt="" height="866" src="https://images2.imgbox.com/52/db/15YfROYq_o.png" width="1200"></p> 
<p>（2）选择的单片机型号以及点击开始工程项目：  </p> 
<p><img alt="" height="1017" src="https://images2.imgbox.com/37/be/KyFA7h2i_o.png" width="1200"></p> 
<p> （3）配置时钟，进入上面的RCC，有两个时钟，一个是hse和lse，将hse那里设Crystal/Ceramic Resonator：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6c/24/10NWdl7m_o.png"></p> 
<p>（4）点击system core，进入SYS，在debug下选择serial wire： </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f3/05/MAiVoabn_o.png"></p> 
<p> （5）配置USART1，我们使用USART1进行数据传输：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/60/7d/klkoxe3V_o.png"></p> 
<p>（6）I2C配置： </p> 
<p><img alt="" src="https://images2.imgbox.com/57/1d/F3MEQYXz_o.png"><img alt="" src="https://images2.imgbox.com/7a/00/BMsSccuE_o.png"> （7）NIVC配置，如下图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5e/bd/2VsP08vd_o.png"></p> 
<p> （8）GPIO配置，配置PC13，如下图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/75/47/PSmM5tv6_o.png"></p> 
<p>（9）进入CLK Configuration (时钟配置)中，进行时钟配置 ：</p> 
<p><img alt="" height="1020" src="https://images2.imgbox.com/bd/ae/SnbsA2zn_o.png" width="1200"></p> 
<p>（10）进入Project Manager(工程管理)，进行工程设置点击生成工程与代码。注意：路径不能包含中文和空格，不然生成的工程文件无法在Keil中打开；</p> 
<p><img alt="" height="1025" src="https://images2.imgbox.com/44/c3/Bz37b9up_o.png" width="1200"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d9/e3/Y0S4ALrE_o.png"></p> 
<h2 id="%C2%A0%E4%BA%94%E3%80%81%E5%AE%8C%E5%96%84keil%E5%B7%A5%E7%A8%8B" style="background-color:transparent;"> 五、完善keil工程</h2> 
<p>（1） 去奥松官网下载AHT20芯片代码与芯片的相关信息介绍文档：<br><a href="http://www.aosong.com/class-36-2.html" rel="nofollow" title="http://www.aosong.com/class-36-2.html">http://www.aosong.com/class-36-2.html</a></p> 
<p>官方代码使用的是PB14,PB15引脚，需要修改引脚为PB6,PB7 才可以正常使用。</p> 
<p>（2）进入到下载的AHT20芯片代码文件夹中，复制如图所示两个C语言代码文件：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/db/61/MHNnX78o_o.png"></p> 
<p>（3）找到刚刚利用HAL库生成的工程文件，在其中找到Core文件夹下的Inc文件夹，并且进入其中 ，将AHT20-21_DEMO_V1_3.h复制在此Inc文件夹下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6b/fd/TtLCP3Nd_o.png"></p> 
<p>（4）找到刚刚利用HAL库生成的工程文件，在其中找到Core文件夹下的Src文件夹，并且进入其中 ，将AHT20-21_DEMO_V1_3.c复制在此Src文件夹下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/26/1f/D3iwptLZ_o.png"></p> 
<p>（5）进入到 keil5工程文件中，双击如图所示处进行添加AHT20-21_DEMO_V1_3.c文件：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/69/b7/h2dlczUq_o.png"></p> 
<p>接着在弹出的框中，按下图所示进行操作： </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/dc/62/mNsg3SKv_o.png"></p> 
<p>添加结果，可以看到已经成功添加进来了：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/56/8e/m4hvojR7_o.png"></p> 
<p>（6）双击打开main.c和AHT20-21_DEMO_V1_3.c文件，按下图所示进行操作同时打开AHT20-21_DEMO_V1_3.h头文件：</p> 
<p><img alt="" src="https://images2.imgbox.com/99/03/X01jBVim_o.png"></p> 
<p> （7）重写main.c文件代码，完整代码如下：</p> 
<pre><code>/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2022 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "dma.h"
#include "i2c.h"
#include "usart.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include&lt;stdio.h&gt;
#include "AHT20-21_DEMO_V1_3.h" 
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
int fputc(int ch,FILE *f)
{
    HAL_UART_Transmit(&amp;huart1,(uint8_t *)&amp;ch,1,0xFFFF);    
		//等待发送结束	
		while(__HAL_UART_GET_FLAG(&amp;huart1,UART_FLAG_TC)!=SET){
		}		

    return ch;
}
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */
	uint32_t CT_data[2]={0,0};
	volatile int  c1,t1;
	Delay_1ms(500);
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  
  MX_USART1_UART_Init();
  MX_DMA_Init();
  MX_I2C1_Init();	
  MX_USART1_UART_Init();
	
  /* USER CODE BEGIN 2 */
  AHT20_Init();
	Delay_1ms(500);

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
		//AHT20_Read_CTdata(CT_data);       //不经过CRC校验，直接读取AHT20的温度和湿度数据    推荐每隔大于1S读一次
		AHT20_Read_CTdata_crc(CT_data);  //crc校验后，读取AHT20的温度和湿度数据 
	

		c1 = CT_data[0]*1000/1024/1024;  //计算得到湿度值c1（放大了10倍）
		t1 = CT_data[1]*2000/1024/1024-500;//计算得到温度值t1（放大了10倍）
		printf("正在检测");
		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
		printf("\r\n");
		HAL_Delay(1000);
		printf("温度:%d%d.%d",t1/100,(t1/10)%10,t1%10);
		printf("湿度:%d%d.%d",c1/100,(c1/10)%10,c1%10);
		printf("\r\n");
		printf("等待");
		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
//		HAL_Delay(100);
//		printf(".");
		printf("\r\n");
		HAL_Delay(1000);
    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
</code></pre> 
<p>（8）修改AHT20-21_DEMO_V1_3.c代码，完整文件代码如下：</p> 
<pre><code>/*******************************************/
/*@版权所有：广州奥松电子有限公司          */
/*@作者：温湿度传感器事业部                */
/*@版本：V1.2                              */
/*******************************************/
//#include "main.h" 
#include "AHT20-21_DEMO_V1_3.h" 
#include "gpio.h"
#include "i2c.h"


void Delay_N10us(uint32_t t)//延时函数
{
  uint32_t k;

   while(t--)
  {
    for (k = 0; k &lt; 2; k++);//110
  }
}

void SensorDelay_us(uint32_t t)//延时函数
{
		
	for(t = t-2; t&gt;0; t--)
	{
		Delay_N10us(1);
	}
}

void Delay_4us(void)		//延时函数
{	
	Delay_N10us(1);
	Delay_N10us(1);
	Delay_N10us(1);
	Delay_N10us(1);
}
void Delay_5us(void)		//延时函数
{	
	Delay_N10us(1);
	Delay_N10us(1);
	Delay_N10us(1);
	Delay_N10us(1);
	Delay_N10us(1);

}

void Delay_1ms(uint32_t t)		//延时函数
{
   while(t--)
  {
    SensorDelay_us(1000);//延时1ms
  }
}


//void AHT20_Clock_Init(void)		//延时函数
//{
//	RCC_APB2PeriphClockCmd(CC_APB2Periph_GPIOB,ENABLE);
//}

void SDA_Pin_Output_High(void)   //将PB7配置为输出 ， 并设置为高电平， PB7作为I2C的SDA
{
	GPIO_InitTypeDef  GPIO_InitStruct;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;//推挽输出
	GPIO_InitStruct.Pin = GPIO_PIN_7;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
	HAL_GPIO_Init(GPIOB,&amp; GPIO_InitStruct);
	HAL_GPIO_WritePin(GPIOB,GPIO_PIN_7,GPIO_PIN_SET);
}

void SDA_Pin_Output_Low(void)  //将P7配置为输出  并设置为低电平
{
	GPIO_InitTypeDef  GPIO_InitStruct;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;//推挽输出
	GPIO_InitStruct.Pin = GPIO_PIN_7;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
	HAL_GPIO_Init(GPIOB,&amp; GPIO_InitStruct);
	HAL_GPIO_WritePin(GPIOB,GPIO_PIN_7,GPIO_PIN_RESET);
}

void SDA_Pin_IN_FLOATING(void)  //SDA配置为浮空输入
{
	GPIO_InitTypeDef  GPIO_InitStruct;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;//浮空
	GPIO_InitStruct.Pin = GPIO_PIN_7;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
	HAL_GPIO_Init( GPIOB,&amp;GPIO_InitStruct);
}


void SCL_Pin_Output_High(void) //SCL输出高电平，P14作为I2C的SCL
{
	HAL_GPIO_WritePin(GPIOB,GPIO_PIN_6,GPIO_PIN_SET);
}

void SCL_Pin_Output_Low(void) //SCL输出低电平
{
	HAL_GPIO_WritePin(GPIOB,GPIO_PIN_6,GPIO_PIN_RESET);
}

void Init_I2C_Sensor_Port(void) //初始化I2C接口,输出为高电平
{	
	GPIO_InitTypeDef  GPIO_InitStruct;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;//推挽输出
	GPIO_InitStruct.Pin = GPIO_PIN_7;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
	HAL_GPIO_Init(GPIOB,&amp; GPIO_InitStruct);
	HAL_GPIO_WritePin(GPIOB,GPIO_PIN_15,GPIO_PIN_SET);

	
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;//推挽输出
	GPIO_InitStruct.Pin = GPIO_PIN_6;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
	HAL_GPIO_Init(GPIOB,&amp; GPIO_InitStruct);
	HAL_GPIO_WritePin(GPIOB,GPIO_PIN_15,GPIO_PIN_SET);
	
}
void I2C_Start(void)		 //I2C主机发送START信号
{
	SDA_Pin_Output_High();
	SensorDelay_us(8);
	SCL_Pin_Output_High();
	SensorDelay_us(8);
	SDA_Pin_Output_Low();
	SensorDelay_us(8);
	SCL_Pin_Output_Low();
	SensorDelay_us(8);   
}


void AHT20_WR_Byte(uint8_t Byte) //往AHT20写一个字节
{
	uint8_t Data,N,i;	
	Data=Byte;
	i = 0x80;
	for(N=0;N&lt;8;N++)
	{
		SCL_Pin_Output_Low(); 
		Delay_4us();	
		if(i&amp;Data)
		{
			SDA_Pin_Output_High();
		}
		else
		{
			SDA_Pin_Output_Low();
		}	
			
    SCL_Pin_Output_High();
		Delay_4us();
		Data &lt;&lt;= 1;
		 
	}
	SCL_Pin_Output_Low();
	SensorDelay_us(8);   
	SDA_Pin_IN_FLOATING();
	SensorDelay_us(8);	
}	


uint8_t AHT20_RD_Byte(void)//从AHT20读取一个字节
{
		uint8_t Byte,i,a;
	Byte = 0;
	SCL_Pin_Output_Low();
	
	SDA_Pin_IN_FLOATING();
	SensorDelay_us(8);	
	
	for(i=0;i&lt;8;i++)
	{
    SCL_Pin_Output_High();
		
		Delay_5us();
		a=0;
		
		//if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_15)) a=1;
		if(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_7)) a=1;
		Byte = (Byte&lt;&lt;1)|a;
		
		//SCL_Pin_Output_Low();
		HAL_GPIO_WritePin(GPIOB,GPIO_PIN_6,GPIO_PIN_RESET);
		Delay_5us();
	}
  SDA_Pin_IN_FLOATING();
	SensorDelay_us(8);	
	return Byte;
}


uint8_t Receive_ACK(void)   //看AHT20是否有回复ACK
{
	uint16_t CNT;
	CNT = 0;
	SCL_Pin_Output_Low();	
	SDA_Pin_IN_FLOATING();
	SensorDelay_us(8);	
	SCL_Pin_Output_High();	
	SensorDelay_us(8);	
	while((HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_7))  &amp;&amp; CNT &lt; 100) 
	CNT++;
	if(CNT == 100)
	{
		return 0;
	}
 	SCL_Pin_Output_Low();	
	SensorDelay_us(8);	
	return 1;
}

void Send_ACK(void)		  //主机回复ACK信号
{
	SCL_Pin_Output_Low();	
	SensorDelay_us(8);	
	SDA_Pin_Output_Low();
	SensorDelay_us(8);	
	SCL_Pin_Output_High();	
	SensorDelay_us(8);
	SCL_Pin_Output_Low();	
	SensorDelay_us(8);
	SDA_Pin_IN_FLOATING();
	SensorDelay_us(8);
}

void Send_NOT_ACK(void)	//主机不回复ACK
{
	SCL_Pin_Output_Low();	
	SensorDelay_us(8);
	SDA_Pin_Output_High();
	SensorDelay_us(8);
	SCL_Pin_Output_High();	
	SensorDelay_us(8);		
	SCL_Pin_Output_Low();	
	SensorDelay_us(8);
    SDA_Pin_Output_Low();
	SensorDelay_us(8);
}

void Stop_I2C(void)	  //一条协议结束
{
	SDA_Pin_Output_Low();
	SensorDelay_us(8);
	SCL_Pin_Output_High();	
	SensorDelay_us(8);
	SDA_Pin_Output_High();
	SensorDelay_us(8);
}

uint8_t AHT20_Read_Status(void)//读取AHT20的状态寄存器
{

	uint8_t Byte_first;	
	I2C_Start();
	AHT20_WR_Byte(0x71);
	Receive_ACK();
	Byte_first = AHT20_RD_Byte();
	Send_NOT_ACK();
	Stop_I2C();
	return Byte_first;
}

uint8_t AHT20_Read_Cal_Enable(void)  //查询cal enable位有没有使能
{
	uint8_t val = 0;//ret = 0,
  val = AHT20_Read_Status();
	 if((val &amp; 0x68)==0x08)
		 return 1;
   else  return 0;
 }

void AHT20_SendAC(void) //向AHT20发送AC命令
{

	I2C_Start();
	AHT20_WR_Byte(0x70);
	Receive_ACK();
	AHT20_WR_Byte(0xac);//0xAC采集命令
	Receive_ACK();
	AHT20_WR_Byte(0x33);
	Receive_ACK();
	AHT20_WR_Byte(0x00);
	Receive_ACK();
	Stop_I2C();

}

//CRC校验类型：CRC8/MAXIM
//多项式：X8+X5+X4+1
//Poly：0011 0001  0x31
//高位放到后面就变成 1000 1100 0x8c
//C现实代码：
uint8_t Calc_CRC8(uint8_t *message,uint8_t Num)
{
	uint8_t i;
	uint8_t byte;
	uint8_t crc=0xFF;
  for(byte=0; byte&lt;Num; byte++)
  {
    crc^=(message[byte]);
    for(i=8;i&gt;0;--i)
    {
      if(crc&amp;0x80) crc=(crc&lt;&lt;1)^0x31;
      else crc=(crc&lt;&lt;1);
    }
  }
        return crc;
}

void AHT20_Read_CTdata(uint32_t *ct) //没有CRC校验，直接读取AHT20的温度和湿度数据
{
		volatile uint8_t  Byte_1th=0;
	volatile uint8_t  Byte_2th=0;
	volatile uint8_t  Byte_3th=0;
	volatile uint8_t  Byte_4th=0;
	volatile uint8_t  Byte_5th=0;
	volatile uint8_t  Byte_6th=0;
	 uint32_t RetuData = 0;
	uint16_t cnt = 0;
	AHT20_SendAC();//向AHT10发送AC命令
	Delay_1ms(80);//延时80ms左右	
    cnt = 0;
	while(((AHT20_Read_Status()&amp;0x80)==0x80))//直到状态bit[7]为0，表示为空闲状态，若为1，表示忙状态
	{
		SensorDelay_us(1508);
		if(cnt++&gt;=100)
		{
		 break;
		 }
	}
	I2C_Start();
	AHT20_WR_Byte(0x71);
	Receive_ACK();
	Byte_1th = AHT20_RD_Byte();//状态字，查询到状态为0x98,表示为忙状态，bit[7]为1；状态为0x1C，或者0x0C，或者0x08表示为空闲状态，bit[7]为0
	Send_ACK();
	Byte_2th = AHT20_RD_Byte();//湿度
	Send_ACK();
	Byte_3th = AHT20_RD_Byte();//湿度
	Send_ACK();
	Byte_4th = AHT20_RD_Byte();//湿度/温度
	Send_ACK();
	Byte_5th = AHT20_RD_Byte();//温度
	Send_ACK();
	Byte_6th = AHT20_RD_Byte();//温度
	Send_NOT_ACK();
	Stop_I2C();

	RetuData = (RetuData|Byte_2th)&lt;&lt;8;
	RetuData = (RetuData|Byte_3th)&lt;&lt;8;
	RetuData = (RetuData|Byte_4th);
	RetuData =RetuData &gt;&gt;4;
	ct[0] = RetuData;//湿度
	RetuData = 0;
	RetuData = (RetuData|Byte_4th)&lt;&lt;8;
	RetuData = (RetuData|Byte_5th)&lt;&lt;8;
	RetuData = (RetuData|Byte_6th);
	RetuData = RetuData&amp;0xfffff;
	ct[1] =RetuData; //温度

}


void AHT20_Read_CTdata_crc(uint32_t *ct) //CRC校验后，读取AHT20的温度和湿度数据
{
		volatile uint8_t  Byte_1th=0;
	volatile uint8_t  Byte_2th=0;
	volatile uint8_t  Byte_3th=0;
	volatile uint8_t  Byte_4th=0;
	volatile uint8_t  Byte_5th=0;
	volatile uint8_t  Byte_6th=0;
	volatile uint8_t  Byte_7th=0;
	 uint32_t RetuData = 0;
	 uint16_t cnt = 0;
	// uint8_t  CRCDATA=0;
	 uint8_t  CTDATA[6]={0};//用于CRC传递数组
	
	AHT20_SendAC();//向AHT10发送AC命令
	Delay_1ms(80);//延时80ms左右	
    cnt = 0;
	while(((AHT20_Read_Status()&amp;0x80)==0x80))//直到状态bit[7]为0，表示为空闲状态，若为1，表示忙状态
	{
		SensorDelay_us(1508);
		if(cnt++&gt;=100)
		{
		 break;
		}
	}
	
	I2C_Start();

	AHT20_WR_Byte(0x71);
	Receive_ACK();
	CTDATA[0]=Byte_1th = AHT20_RD_Byte();//状态字，查询到状态为0x98,表示为忙状态，bit[7]为1；状态为0x1C，或者0x0C，或者0x08表示为空闲状态，bit[7]为0
	Send_ACK();
	CTDATA[1]=Byte_2th = AHT20_RD_Byte();//湿度
	Send_ACK();
	CTDATA[2]=Byte_3th = AHT20_RD_Byte();//湿度
	Send_ACK();
	CTDATA[3]=Byte_4th = AHT20_RD_Byte();//湿度/温度
	Send_ACK();
	CTDATA[4]=Byte_5th = AHT20_RD_Byte();//温度
	Send_ACK();
	CTDATA[5]=Byte_6th = AHT20_RD_Byte();//温度
	Send_ACK();
	Byte_7th = AHT20_RD_Byte();//CRC数据
	Send_NOT_ACK();                           //注意: 最后是发送NAK
	Stop_I2C();
	
	if(Calc_CRC8(CTDATA,6)==Byte_7th)
	{
	RetuData = (RetuData|Byte_2th)&lt;&lt;8;
	RetuData = (RetuData|Byte_3th)&lt;&lt;8;
	RetuData = (RetuData|Byte_4th);
	RetuData =RetuData &gt;&gt;4;
	ct[0] = RetuData;//湿度
	RetuData = 0;
	RetuData = (RetuData|Byte_4th)&lt;&lt;8;
	RetuData = (RetuData|Byte_5th)&lt;&lt;8;
	RetuData = (RetuData|Byte_6th);
	RetuData = RetuData&amp;0xfffff;
	ct[1] =RetuData; //温度
		
	}
	else
	{
		ct[0]=0x00;
		ct[1]=0x00;//校验错误返回值，客户可以根据自己需要更改
	}//CRC数据
}


void AHT20_Init(void)   //初始化AHT20
{	
	Init_I2C_Sensor_Port();
	I2C_Start();
	AHT20_WR_Byte(0x70);
	Receive_ACK();
	AHT20_WR_Byte(0xa8);//0xA8进入NOR工作模式
	Receive_ACK();
	AHT20_WR_Byte(0x00);
	Receive_ACK();
	AHT20_WR_Byte(0x00);
	Receive_ACK();
	Stop_I2C();

	Delay_1ms(10);//延时10ms左右

	I2C_Start();
	AHT20_WR_Byte(0x70);
	Receive_ACK();
	AHT20_WR_Byte(0xbe);//0xBE初始化命令，AHT20的初始化命令是0xBE,   AHT10的初始化命令是0xE1
	Receive_ACK();
	AHT20_WR_Byte(0x08);//相关寄存器bit[3]置1，为校准输出
	Receive_ACK();
	AHT20_WR_Byte(0x00);
	Receive_ACK();
	Stop_I2C();
	Delay_1ms(10);//延时10ms左右
}
void JH_Reset_REG(uint8_t addr)
{
	
	uint8_t Byte_first,Byte_second,Byte_third;
	I2C_Start();
	AHT20_WR_Byte(0x70);//原来是0x70
	Receive_ACK();
	AHT20_WR_Byte(addr);
	Receive_ACK();
	AHT20_WR_Byte(0x00);
	Receive_ACK();
	AHT20_WR_Byte(0x00);
	Receive_ACK();
	Stop_I2C();

	Delay_1ms(5);//延时5ms左右
	I2C_Start();
	AHT20_WR_Byte(0x71);//
	Receive_ACK();
	Byte_first = AHT20_RD_Byte();
	Send_ACK();
	Byte_second = AHT20_RD_Byte();
	Send_ACK();
	Byte_third = AHT20_RD_Byte();
	Send_NOT_ACK();
	Stop_I2C();
	
  Delay_1ms(10);//延时10ms左右
	I2C_Start();
	AHT20_WR_Byte(0x70);///
	Receive_ACK();
	AHT20_WR_Byte(0xB0|addr);//寄存器命令
	Receive_ACK();
	AHT20_WR_Byte(Byte_second);
	Receive_ACK();
	AHT20_WR_Byte(Byte_third);
	Receive_ACK();
	Stop_I2C();
	
	Byte_second=0x00;
	Byte_third =0x00;
}

void AHT20_Start_Init(void)
{
	JH_Reset_REG(0x1b);
	JH_Reset_REG(0x1c);
	JH_Reset_REG(0x1e);
}
</code></pre> 
<p> （9）修改AHT20-21_DEMO_V1_3.h代码，完整文件代码如下：</p> 
<pre><code>#ifndef _AHT20_DEMO_
#define _AHT20_DEMO_

#include "main.h"  

void Delay_N10us(uint32_t t);//延时函数
void SensorDelay_us(uint32_t t);//延时函数
void Delay_4us(void);		//延时函数
void Delay_5us(void);		//延时函数
void Delay_1ms(uint32_t t);	
void AHT20_Clock_Init(void);		//延时函数
void SDA_Pin_Output_High(void)  ; //将PB15配置为输出 ， 并设置为高电平， PB15作为I2C的SDA
void SDA_Pin_Output_Low(void);  //将P15配置为输出  并设置为低电平
void SDA_Pin_IN_FLOATING(void);  //SDA配置为浮空输入
void SCL_Pin_Output_High(void); //SCL输出高电平，P14作为I2C的SCL
void SCL_Pin_Output_Low(void); //SCL输出低电平
void Init_I2C_Sensor_Port(void); //初始化I2C接口,输出为高电平
void I2C_Start(void);		 //I2C主机发送START信号
void AHT20_WR_Byte(uint8_t Byte); //往AHT20写一个字节
uint8_t AHT20_RD_Byte(void);//从AHT20读取一个字节
uint8_t Receive_ACK(void);   //看AHT20是否有回复ACK
void Send_ACK(void)	;	  //主机回复ACK信号
void Send_NOT_ACK(void);	//主机不回复ACK
void Stop_I2C(void);	  //一条协议结束
uint8_t AHT20_Read_Status(void);//读取AHT20的状态寄存器
uint8_t AHT20_Read_Cal_Enable(void);  //查询cal enable位有没有使能
void AHT20_SendAC(void); //向AHT20发送AC命令
uint8_t Calc_CRC8(uint8_t *message,uint8_t Num);
void AHT20_Read_CTdata(uint32_t *ct); //没有CRC校验，直接读取AHT20的温度和湿度数据
void AHT20_Read_CTdata_crc(uint32_t *ct); //CRC校验后，读取AHT20的温度和湿度数据
void AHT20_Init(void);   //初始化AHT20
void JH_Reset_REG(uint8_t addr);///重置寄存器
void AHT20_Start_Init(void);///上电初始化进入正常测量状态
#endif
</code></pre> 
<h2 id="%C2%A0%E5%85%AD%E3%80%81%E7%94%B5%E8%B7%AF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA"> 六、电路连接与运行结果展示</h2> 
<h3 id="1%E3%80%81%E7%94%B5%E8%B7%AF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%85%8D%E7%BD%AE%EF%BC%9A%C2%A0">1、电路连接与配置： </h3> 
<p>（1）温湿度采集模块AHT20与STM32的连接如下图所示： </p> 
<p><img alt="" height="359" src="https://images2.imgbox.com/04/03/vkGi3ejT_o.png" width="691"></p> 
<p>这里附上AHT20的引脚简介图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7a/e2/hGLKMOLq_o.jpg"></p> 
<p> （2）USB转TTL在电脑上的配置以及与STM32的连接参考我的这篇博客：</p> 
<p><a href="https://blog.csdn.net/m0_63323712/article/details/133973921" title="STM32使用HAL库中断控制串口通信-CSDN博客">STM32使用HAL库中断控制串口通信-CSDN博客</a></p> 
<p> （3）连接好的电路实物图如下所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a6/91/bDbQYbfz_o.jpg"></p> 
<h3 id="2%E3%80%81%E7%83%A7%E5%BD%95%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA%EF%BC%9A">2、烧录运行结果展示：</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f0/3d/qTBiEECs_o.gif"></p> 
<h2 id="%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93">七、总结</h2> 
<p>        通过本次实验，详细了解并且实践了I2C总线协议，以及AHT20温湿度传感器的使用，受益匪浅。I2C总线上允许连接多个微处理器以及各种外围设备，如存储器、LED及LCD驱动、A/D及D/A转换器等。为了保证数据可靠地传送，任一时刻总线只能由某一台主机控制，各微处理器应该在总线空闲时发送数据。</p> 
<p>       自己在每做一次STM32的实践或者实验，或者说每更一篇STM32的博客，都是在边学边做边进步的路上。希望阅读本文的你也也也是一样。 完！！！</p> 
<h2 id="%E5%85%AB%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%C2%A0">八、参考资料 </h2> 
<p>1、<a href="https://blog.csdn.net/qq_43279579/article/details/111597278" title="stm32通过I2C接口实现温湿度（AHT20）的采集_aht21能够检测室内温度-CSDN博客">stm32通过I2C接口实现温湿度（AHT20）的采集_aht21能够检测室内温度-CSDN博客</a></p> 
<p>2、 <a href="https://blog.csdn.net/qq_53088119/article/details/127886368?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169943576216800226583240%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169943576216800226583240&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-9-127886368-null-null.142%5Ev96%5Epc_search_result_base8&amp;utm_term=IIC%E5%8D%8F%E8%AE%AE%E8%AF%BB%E5%8F%96%E6%B8%A9%E6%B9%BF%E5%BA%A6%E6%95%B0%E6%8D%AE&amp;spm=1018.2226.3001.4187" title="STM32F103通过IIC协议实现温湿度（AHT20）的采集_aht20例程_Justinlevy的博客-CSDN博客">STM32F103通过IIC协议实现温湿度（AHT20）的采集_aht20例程_Justinlevy的博客-CSDN博客</a></p> 
<p>3、<a href="https://blog.csdn.net/qq_47281915/article/details/121438731" title="STM32F103基于I2C协议的AHT20温湿度传感器的数据采集_dht20程序_醉意丶千层梦的博客-CSDN博客">STM32F103基于I2C协议的AHT20温湿度传感器的数据采集_dht20程序_醉意丶千层梦的博客-CSDN博客</a> </p> 
<p>4、<a href="https://blog.csdn.net/qq_46467126/article/details/121436790?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169940703516800184160936%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=169940703516800184160936&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-121436790-null-null.nonecase&amp;utm_term=IIC&amp;spm=1018.2226.3001.4450" title="【精选】【嵌入式15】I2C总线通信协议及实操stm32通过I2C实现温湿度（AHT20）采集_xcom读取i2c_噗噗的罐子的博客-CSDN博客">【精选】【嵌入式15】I2C总线通信协议及实操stm32通过I2C实现温湿度（AHT20）采集_xcom读取i2c_噗噗的罐子的博客-CSDN博客</a> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8e5e495d58347daa74098a0fabbffe5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一名【合格】前端工程师的自检清单</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/91336f36e5c1fd258310dbb0300e9b3c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mybatis-Plus自动生成ID ，填充 创建时间和更新时间</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>