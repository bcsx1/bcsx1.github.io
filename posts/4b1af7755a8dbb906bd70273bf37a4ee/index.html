<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常见ANR问题解决办法 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="常见ANR问题解决办法" />
<meta property="og:description" content="ANR问题，相信是每位开发日常都会遇到的问题，对于这类问题的分析，按照官方的推荐，或网络博客的总结思路能解决一定的问题，但是多数时候大家的困惑就是应用本逻辑很简单，耗时很短或应用堆栈完全正常，或者或处于空闲状态，可系统为什么就认为接收者发生ANR了呢？下面将之前公司的一次内部分享开放出来，用几个实例从不同角度分析导致ANR产生的Root Case。也希望对大家以后分析该类问题有一定参考，不对的地方欢迎大家拍砖。
一 ANR分类 含如下几种类型：
广播ANR
Service ANR
ContentProvider ANR
Input ANR
面向系统：WatchDog
二 产生ANR原因 如下几种：
主线程耗时操作
主线程被其它线程Block
系统级响应阻塞
系统或进程自身可用内存紧张
CPU资源被抢占
对于这些ANR，先给大家的推荐一下大致分析思路和相关日志，通常发生ANR时，首先去查找对应Trace日志，看看主线程是否在处理该广播或被阻塞，如果发现上述现象，那么恭喜你，已经很接近答案了。但如果发现堆栈完全处于空闲状态，那么很不幸，就需要扩大参考面了，需要结合log日志进行分析，日志包括logcat, kernel日志，cpuinfo以及meminfo等，参考顺序从前向后。
1分析logcat思路：首先在日志中搜索（“anr in”，“low_memory”, “slow_operation”）等关键字，通过该类关键字主要是查看系统Cpu负载，如果是发现应用进程CPU明显过高，那么很有可能是该进程抢占CPU过多导致，系统调度不及时,误认为应用发生了超时行为。
2分析kernel思路：在此类日志中直接搜索lowmemorykiller, 如果存在则查看发生时间和ANR时间是否大致对应，相差无几的话，可以从该日志中看到操作系统层面当前内存情况，Free Memory说明的是空闲物理内存，File Free说明的则是文件Cache，也就是应用或系统从硬盘读取文件，使用结束后，kernel并没有这正释放这类内存，加以缓存，目的是为了下次读写过程加快速度。当然，发现Free和Other整体数值都偏低时，Kernel会进行一定程度的内存交换，导致整个系统卡顿。同时这类现象也会体现在log日志“slow_operation”中，即系统进程的调度也会收到影响。
3分析cpuinfo思路：这类日志一目了然，可以清晰的看到哪类进程CPU偏高，如果存在明显偏高进程，那么ANR和此进程抢占CPU有一定关系。当然，如发现Kswapd，emmc进程在top中，则说明遇到系统内存压力或文件IO开销。
4分析meminfo思路：分析该类日志，主要是看哪类应用或系统占用内存偏高，如果应用内存占用比较正常，系统也没有发生过度内存使用，那么则说明系统中缓存了大量进程，并没有及时释放导致系统整体内存偏低。
5综合分析当时系统环境，例如电量（低电可能会引起手机限频，限核等等），手机温度（温度过高也可能会引起限频），以及操作频率（例如执行monkey测试）等等；
上面说了这么多，下面结合实例进行分析：
实例一：主线程进行耗时操作，或被进程内其它线程阻塞 示例：
第一步 观察Trace 主线程堆栈，发现主线程在申请内存过程中被block，等待GC结束，但通过堆栈进一步发现其GC并没有发生在该线程，也就是说在其他线程在执行GC动作，而主线程在申请内存过程中需要等待GC完成，再进一步申请内存。
&#34;main&#34; prio=5 tid=1 WaitingForGcToComplete
native: #00 pc 0000000000019980 /system/lib64/libc.so (syscall&#43;28)
native: #01 pc 000000000013a62c /system/lib64/libart.so (_ZN3art17ConditionVariable4WaitEPNS_6ThreadE&#43;136)
native: #02 pc 0000000000237f14 /system/lib64/libart.so (_ZN3art2gc4Heap19WaitForGcToCompleteENS0_7GcCauseEPNS_6ThreadE&#43;1376)
native: #03 pc 000000000024798c /system/lib64/libart.so (_ZN3art2gc4Heap22AllocateInternalWithGcEPNS_6ThreadENS0_13AllocatorTypeEmPmS5_S5_PPNS_6mirror5ClassE&#43;168)
native: #04 pc 000000000050394c /system/lib64/libart." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/4b1af7755a8dbb906bd70273bf37a4ee/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-14T15:38:39+08:00" />
<meta property="article:modified_time" content="2023-03-14T15:38:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常见ANR问题解决办法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>ANR问题，相信是每位开发日常都会遇到的问题，对于这类问题的分析，按照官方的推荐，或网络博客的总结思路能解决一定的问题，但是多数时候大家的困惑就是应用本逻辑很简单，耗时很短或应用堆栈完全正常，或者或处于空闲状态，可系统为什么就认为接收者发生ANR了呢？下面将之前公司的一次内部分享开放出来，用几个实例从不同角度分析导致ANR产生的Root Case。也希望对大家以后分析该类问题有一定参考，不对的地方欢迎大家拍砖。</p> 
<h2><br> 一   ANR分类</h2> 
<p>含如下几种类型：</p> 
<p>          广播ANR</p> 
<p>          Service ANR</p> 
<p>          ContentProvider ANR</p> 
<p>          Input ANR</p> 
<p>面向系统：WatchDog</p> 
<h2>二 产生ANR原因</h2> 
<p>如下几种：</p> 
<p>         主线程耗时操作</p> 
<p>         主线程被其它线程Block</p> 
<p>         系统级响应阻塞</p> 
<p>         系统或进程自身可用内存紧张</p> 
<p>         CPU资源被抢占</p> 
<p>对于这些ANR，先给大家的推荐一下大致分析思路和相关日志，通常发生ANR时，首先去查找对应Trace日志，看看主线程是否在处理该广播或被阻塞，如果发现上述现象，那么恭喜你，已经很接近答案了。但如果发现堆栈完全处于空闲状态，那么很不幸，就需要扩大参考面了，需要结合log日志进行分析，日志包括logcat, kernel日志，cpuinfo以及meminfo等，参考顺序从前向后。</p> 
<p>1分析logcat思路：首先在日志中搜索（“anr in”，“low_memory”, “slow_operation”）等关键字，通过该类关键字主要是查看系统Cpu负载，如果是发现应用进程CPU明显过高，那么很有可能是该进程抢占CPU过多导致，系统调度不及时,误认为应用发生了超时行为。</p> 
<p>2分析kernel思路：在此类日志中直接搜索lowmemorykiller, 如果存在则查看发生时间和ANR时间是否大致对应，相差无几的话，可以从该日志中看到操作系统层面当前内存情况，Free Memory说明的是空闲物理内存，File Free说明的则是文件Cache，也就是应用或系统从硬盘读取文件，使用结束后，kernel并没有这正释放这类内存，加以缓存，目的是为了下次读写过程加快速度。当然，发现Free和Other整体数值都偏低时，Kernel会进行一定程度的内存交换，导致整个系统卡顿。同时这类现象也会体现在log日志“slow_operation”中，即系统进程的调度也会收到影响。</p> 
<p>3分析cpuinfo思路：这类日志一目了然，可以清晰的看到哪类进程CPU偏高，如果存在明显偏高进程，那么ANR和此进程抢占CPU有一定关系。当然，如发现Kswapd，emmc进程在top中，则说明遇到系统内存压力或文件IO开销。</p> 
<p>4分析meminfo思路：分析该类日志，主要是看哪类应用或系统占用内存偏高，如果应用内存占用比较正常，系统也没有发生过度内存使用，那么则说明系统中缓存了大量进程，并没有及时释放导致系统整体内存偏低。</p> 
<p>5综合分析当时系统环境，例如电量（低电可能会引起手机限频，限核等等），手机温度（温度过高也可能会引起限频），以及操作频率（例如执行monkey测试）等等；<br> 上面说了这么多，下面结合实例进行分析：</p> 
<p></p> 
<h2>实例一：主线程进行耗时操作，或被进程内其它线程阻塞</h2> 
<h3>示例：<br> 第一步</h3> 
<p>观察Trace 主线程堆栈，发现主线程在申请内存过程中被block，等待GC结束，但通过堆栈进一步发现其GC并没有发生在该线程，也就是说在其他线程在执行GC动作，而主线程在申请内存过程中需要等待GC完成，再进一步申请内存。</p> 
<p>"main" prio=5 tid=1 WaitingForGcToComplete</p> 
<p>  native: #00 pc 0000000000019980  /system/lib64/libc.so (syscall+28)<br>   native: #01 pc 000000000013a62c  /system/lib64/libart.so (_ZN3art17ConditionVariable4WaitEPNS_6ThreadE+136)<br>   native: #02 pc 0000000000237f14  /system/lib64/libart.so (_ZN3art2gc4Heap19WaitForGcToCompleteENS0_7GcCauseEPNS_6ThreadE+1376)<br>   native: #03 pc 000000000024798c  /system/lib64/libart.so (_ZN3art2gc4Heap22AllocateInternalWithGcEPNS_6ThreadENS0_13AllocatorTypeEmPmS5_S5_PPNS_6mirror5ClassE+168)<br>   native: #04 pc 000000000050394c  /system/lib64/libart.so (artAllocObjectFromCodeRosAlloc+1412)<br>   native: #05 pc 00000000001215d0  /system/lib64/libart.so (art_quick_alloc_object_rosalloc+64)<br>   native: #06 pc 00000000018e72f0  /system/framework/arm64/boot.oat (Java_android_widget_TextView__0003cinit_0003e__Landroid_content_Context_2Landroid_util_AttributeSet_2II+1156)<br>   at android.widget.TextView.&lt;init&gt;(TextView.java:727)<br>   at android.widget.TextView.&lt;init&gt;(TextView.java:682)<br>   at android.widget.TextView.&lt;init&gt;(TextView.java:678)<br>   at java.lang.reflect.Constructor.newInstance!(Native method)</p> 
<h3>第二步</h3> 
<p>再看看其它线程状态，进一步查找发现，下面任务正在执行GC</p> 
<p>"LeuiRunningState:Background" prio=5 tid=28 WaitingPerformingGc</p> 
<p>"AsyncTask #6" prio=5 tid=20 WaitingPerformingGc</p> 
<p>综上可以得出大致结论，Tid=28,20线程执行GC,导致主线程申请内存被Block.  但是进一步思考，应用GC是常有的事，但是为何这次需要这么长时间呢，带着疑问我们看看进程的内存使用情况：</p> 
<p>Total number of allocations 9887486</p> 
<p>Total bytes allocated 732MB</p> 
<p>Total bytes freed 476MB</p> 
<p>Free memory 5KB</p> 
<p>Free memory until GC 5KB</p> 
<p>Free memory until OOME 5KB</p> 
<p>Total memory 256MB</p> 
<p>Max memory 256MB</p> 
<p>上面发现，应用已使用256Mb, 距离OOM只有5K，内存对象超过998万个，也就是说GC过程需要扫描这些对象的巨大部分，导致耗时很久，另外内存距离OOM只有5kb，说明有内存泄漏，或内存使用不合理。</p> 
<p>综上，对于这个问题得出结论，应用进程内存存在泄漏或使用不当，导致GC时间过程，产生ANR.</p> 
<p></p> 
<h2>实例二：应用内部线程逻辑依赖关系导致超时，触发ANR</h2> 
<p>示例：</p> 
<h3><br> 第一步</h3> 
<p>观察Trace 主线程堆栈，发现主线程在Binder通信过程被Block.</p> 
<p>"main" prio=5 tid=1 Native<br>   | group="main" sCount=1 dsCount=0 obj=0x75f0eaa8 self=0x7fad046a00<br>   | sysTid=4298 nice=-6 cgrp=default sched=0/0 handle=0x7fb1d18fe8<br>   | state=S schedstat=( 79488910537 19985244611 169915 ) utm=6564 stm=1384 core=0 HZ=100<br>   | stack=0x7fc237c000-0x7fc237e000 stackSize=8MB<br>   | held mutexes=<br>   kernel: (couldn't read /proc/self/task/4298/stack)<br>   native: #00 pc 00000000000683d0  /system/lib64/libc.so (__ioctl+4)<br>   native: #01 pc 00000000000723f8  /system/lib64/libc.so (ioctl+100)<br>   native: #02 pc 000000000002d584  /system/lib64/libbinder.so (_ZN7android14IPCThreadState14talkWithDriverEb+164)<br>   native: #03 pc 000000000002e050  /system/lib64/libbinder.so (_ZN7android14IPCThreadState15waitForResponseEPNS_6ParcelEPi+104)<br>   native: #04 pc 000000000002e2c4  /system/lib64/libbinder.so (_ZN7android14IPCThreadState8transactEijRKNS_6ParcelEPS1_j+176)<br>   native: #05 pc 0000000000025654  /system/lib64/libbinder.so (_ZN7android8BpBinder8transactEjRKNS_6ParcelEPS1_j+64)<br>   native: #06 pc 00000000000e0928  /system/lib64/libandroid_runtime.so (???)<br>   native: #07 pc 000000000139ba24  /system/framework/arm64/boot.oat (Java_android_os_BinderProxy_transactNative__ILandroid_os_Parcel_2Landroid_os_Parcel_2I+200)<br>   at android.os.BinderProxy.transactNative(Native method)<br>   at android.os.BinderProxy.transact(Binder.java:503)<br>   at android.nfc.INfcAdapter$Stub$Proxy.setAppCallback(INfcAdapter.java:529)<br>   at android.nfc.NfcActivityManager.requestNfcServiceCallback(NfcActivityManager.java:339)<br>   at android.nfc.NfcActivityManager.setNdefPushMessageCallback(NfcActivityManager.java:309)</p> 
<h3>第二步</h3> 
<p>进一步查找此线程在和哪个进程进行通信，搜索关键字“setAppCallback”（Android命名习惯，客户端和服务端函数命名基本相同），在Nfc的Binder_3线程响应了客户端请求，但在处理过程中被线程1阻塞，顺着再看看线程1状态</p> 
<p>"Binder_3" prio=5 tid=17 Blocked</p> 
<p>  | group="main" sCount=1 dsCount=0 obj=0x12ddf0a0 self=0x7fa670f000</p> 
<p>  | sysTid=3183 nice=-6 cgrp=default sched=0/0 handle=0x7f93c30440</p> 
<p>  | state=S schedstat=( 3041465858 2637156615 16961 ) utm=168 stm=136 core=3 HZ=100</p> 
<p>  | stack=0x7f93b34000-0x7f93b36000 stackSize=1013KB</p> 
<p>  | held mutexes=</p> 
<p>  at com.android.nfc.P2pLinkManager.setNdefCallback(P2pLinkManager.java:420)</p> 
<p>  - waiting to lock &lt;0x0bed0520&gt; (a com.android.nfc.P2pLinkManager) held by thread 1</p> 
<p>  at com.android.nfc.NfcService$NfcAdapterService.setAppCallback(NfcService.java:1679)</p> 
<p>  at android.nfc.INfcAdapter$Stub.onTransact(INfcAdapter.java:178)</p> 
<p>  at android.os.Binder.execTransact(Binder.java:453)</p> 
<p>"main" prio=5 tid=1 Native<br>   | group="main" sCount=1 dsCount=0 obj=0x75f0eaa8 self=0x7fad046a00<br>   | sysTid=2706 nice=0 cgrp=default sched=0/0 handle=0x7fb1d18fe8<br>   | state=S schedstat=( 115355173189 36125520701 224819 ) utm=8594 stm=2941 core=0 HZ=100<br>   | stack=0x7fc237c000-0x7fc237e000 stackSize=8MB<br>   | held mutexes=<br>   kernel: (couldn't read /proc/self/task/2706/stack)<br>   native: #00 pc 00000000000683d0  /system/lib64/libc.so (__ioctl+4)<br>   native: #01 pc 00000000000723f8  /system/lib64/libc.so (ioctl+100)<br>   native: #02 pc 000000000002d584  /system/lib64/libbinder.so (_ZN7android14IPCThreadState14talkWithDriverEb+164)<br>   native: #03 pc 000000000002e050  /system/lib64/libbinder.so (_ZN7android14IPCThreadState15waitForResponseEPNS_6ParcelEPi+104)<br>   native: #04 pc 000000000002e2c4  /system/lib64/libbinder.so (_ZN7android14IPCThreadState8transactEijRKNS_6ParcelEPS1_j+176)<br>   native: #05 pc 0000000000025654  /system/lib64/libbinder.so (_ZN7android8BpBinder8transactEjRKNS_6ParcelEPS1_j+64)<br>   native: #06 pc 00000000000e0928  /system/lib64/libandroid_runtime.so (???)<br>   native: #07 pc 000000000139ba24  /system/framework/arm64/boot.oat (Java_android_os_BinderProxy_transactNative__ILandroid_os_Parcel_2Landroid_os_Parcel_2I+200)<br>   at android.os.BinderProxy.transactNative(Native method)<br>   at android.os.BinderProxy.transact(Binder.java:503)<br>   at android.nfc.IAppCallback$Stub$Proxy.createBeamShareData(IAppCallback.java:113)<br>   at com.android.nfc.P2pLinkManager.prepareMessageToSend(P2pLinkManager.java:558)<br>   - locked &lt;0x0bed0520&gt; (a com.android.nfc.P2pLinkManager)</p> 
<p>通过主线程，又发现正进程Binder通信，同时被block,搜索关键字“createBeamShareData”，发现又回到浏览器线程，Binder_6线程响应此请求，同时也处于Waiting状态</p> 
<p>"Binder_6" prio=5 tid=12 Waiting</p> 
<p>  | group="main" sCount=1 dsCount=0 obj=0x12c13a00 self=0x7f52850e00</p> 
<p>  | sysTid=23857 nice=0 cgrp=default sched=0/0 handle=0x7f694ff440</p> 
<p>  | state=S schedstat=( 705897380 828401158 3677 ) utm=45 stm=25 core=1 HZ=100</p> 
<p>  | stack=0x7f69403000-0x7f69405000 stackSize=1013KB</p> 
<p>  | held mutexes=</p> 
<p>  at java.lang.Object.wait!(Native method)</p> 
<p>  - waiting on &lt;0x08a80433&gt; (a java.lang.Object)</p> 
<p>  at java.lang.Thread.parkFor$(Thread.java:1220)</p> 
<p>  - locked &lt;0x08a80433&gt; (a java.lang.Object)</p> 
<p>  at sun.misc.Unsafe.park(Unsafe.java:299)</p> 
<p>  at java.util.concurrent.locks.LockSupport.park(LockSupport.java:158)</p> 
<p>  at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:810)</p> 
<p>  at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:970)</p> 
<p>  at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1278)</p> 
<p>  at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:203)</p> 
<p>  at com.android.browser.NfcHandler.createNdefMessage(NfcHandler.java:92)</p> 
<p>  at android.nfc.NfcActivityManager.createBeamShareData(NfcActivityManager.java:377)</p> 
<p>  at android.nfc.IAppCallback$Stub.onTransact(IAppCallback.java:53)</p> 
<p>  at android.os.Binder.execTransact(Binder.java:453)</p> 
<p>为什么Binder_6处于Waiting状态？这就需要大家结合Read the Fuck Code的精神研究逻辑了，事后发现此线程的事件放在了主线程执行，当执行完毕后接收通知，停止waiting.</p> 
<p>至此，我们找到了一条完整的链路，（浏览器主线程----&gt;NFC Binder_3----&gt;NFC主线程----&gt;浏览器 Binder_6----&gt;浏览器主线程），大家到此看到了根本原因，死锁！！！</p> 
<p>综上，对于这个问题得出结论，应用通信过程中发生死锁导致ANR，后面只需解锁即可。</p> 
<p>上面两类问题，相对简单，大家遇到时也多半能自行分析解决，下面两类涉及到较多系统或其它因素，问题比较隐晦，但是按照一定分析思路，静下来分析，多数时候还是能找到原因或给出优化方案的。</p> 
<p></p> 
<h2>实例三：系统内存过低，kernel进行内存交换过程会引起整个系统运行缓慢(卡顿)</h2> 
<p>示例：</p> 
<h3><br> 第一步</h3> 
<p>观察Trace 主线程堆栈，发现主线程处于Suspend状态；发生此类问题一般是两种情况，一种是进程自身过于繁忙，每次分配时间片都不够用，调度器强制把它置换成休眠了，另一种是系统比较繁忙，低优先级集成得不到时间片；带着这样的疑问，继续看：</p> 
<p>"main" prio=5 tid=1 Suspended</p> 
<p>  | group="main" sCount=1 dsCount=0 obj=0x745518a0 self=0x7f86254a00</p> 
<p>  | sysTid=21916 nice=0 cgrp=default sched=0/0 handle=0x7f8b30efc8</p> 
<p>  | state=S schedstat=( 311762801762 96254728754 409881 ) utm=25610 stm=5566 core=0 HZ=100</p> 
<p>  | stack=0x7fd023c000-0x7fd023e000 stackSize=8MB</p> 
<p>  | held mutexes=</p> 
<p>  at java.util.regex.Splitter.fastSplit(Splitter.java:73)</p> 
<p>  at java.lang.String.split(String.java:1410)</p> 
<p>  at java.lang.String.split(String.java:1392)</p> 
<p>  at android.content.res.theme.LeResourceHelper.getResName(LeResourceHelper.java:193)</p> 
<p>  at android.content.res.Resources.loadDrawable(Resources.java:2624)</p> 
<p>  at android.content.res.Resources.getDrawable(Resources.java:862)</p> 
<p>  at android.content.Context.getDrawable(Context.java:458)</p> 
<p>  at android.widget.ImageView.resolveUri(ImageView.java:813)</p> 
<p>这个时候可以看看应用逻辑是否会存在繁忙操作不停抢占时间片，另一方面可以看看对应日志，通过logcat发现如下信息，</p> 
<p>11-17 09:49:41.392  1532  1574 E ActivityManager: ANR in com.android.systemui</p> 
<p>11-17 09:49:41.392  1532  1574 E ActivityManager: PID: 21916</p> 
<p>11-17 09:49:41.392  1532  1574 E ActivityManager: Reason: Broadcast of Intent { act=android.intent.action.TIME_TICK flg=0x50000014 mCallingUid=1000 (has extras) }</p> 
<p>11-17 09:49:41.392  1532  1574 E ActivityManager: Load: 22.72 / 20.06 / 15.54  /分别对应1分钟/5分钟/15分钟/</p> 
<p>11-17 09:49:41.392  1532  1574 E ActivityManager: CPU usage from 3ms to 24033ms later:</p> 
<p>11-17 09:49:41.392  1532  1574 E ActivityManager:   60% 134/kswapd0: 0% user + 60% kernel</p> 
<p>11-17 09:49:41.392  1532  1574 E ActivityManager:   32% 1532/system_server: 7.4% user + 25% kernel / faults: 31214 minor 423 major</p> 
<p>系统整体负载很重，常规下负载在10左右；另外发现kswapdCPU占用率极高，通过这两项可以得到系统内存偏低，不停kill进程并发生内存交换，是不是这样的呢？我们再搜索一下其它关键字Slow operation：</p> 
<p>11-17 09:42:25.292  1532  1572 W ActivityManager: Slow operation: 2440ms so far, now at startProcess: returned from zygote!</p> 
<p>11-17 09:42:25.357  1532  1572 W ActivityManager: Slow operation: 2505ms so far, now at startProcess: done updating battery stats</p> 
<p>11-17 09:42:25.357  1532  1572 I am_proc_start: [0,30188,10088,com.letv.android.usagestats,service,com.letv.android.usagestats/.UsageStatsReportService]</p> 
<p>11-17 09:42:25.357  1532  1572 W ActivityManager: Slow operation: 2505ms so far, now at startProcess: building log message</p> 
<p>11-17 09:42:25.357  1532  1572 I ActivityManager: Start proc 30188:com.letv.android.usagestats/u0a88 for service com.letv.android.usagestats/.UsageStatsReportService</p> 
<p>11-17 09:42:25.357  1532  1572 W ActivityManager: Slow operation: 2505ms so far, now at startProcess: starting to update pids map</p> 
<p>11-17 09:42:25.357  1532  1572 W ActivityManager: Slow operation: 2505ms so far, now at startProcess: done updating pids map</p> 
<p>11-17 09:42:25.385  1532  1572 W ActivityManager: Slow operation: 2534ms so far, now at startProcess: done starting proc!</p> 
<p>发现普通系统函数执行一次就耗费了2S以上，足见系统卡顿。现在我们继续延着内存方向确认，看看meminfo日志吧</p> 
<p>Total PSS by process:</p> 
<p>  3441530 kB: com.android.mms (pid 2518 / activities)</p> 
<p>   229272 kB: mediaserver (pid 763)</p> 
<p>通过PSS发现，SMS进程内存占用超过3G！对，第一反应就是内存泄漏，普通应用甚至系统内存占用根本不可能达到这么多。如果大家有时间可以看看kernel日志，搜索lowmemoryKiller，发生问题时间内一定有大量的进程被kill.</p> 
<p>综上，对于这个问题得出结论，应用在Native层发生内存泄漏(不要问我为什么不是Java层发生这么多内存泄漏@@)。导致系统整体内存吃紧，又因为其本身Persist属性，具有很高优先级（-12），LMK不会将其Kill.只能不停Kill其它应用，并进程内存交换，类似问题参见XIIIM-8358</p> 
<p></p> 
<h2>实例四：Binder资源耗尽，导致通信请求难以及时响应</h2> 
<p>示例：</p> 
<p><br> 该类问题和内存过低相似，查看主线程堆栈基本正常</p> 
<p>"main" prio=5 tid=1 Native<br>   | group="main" sCount=1 dsCount=0 obj=0x76261710 self=0x7f82646a00<br>   | sysTid=3084 nice=0 cgrp=default sched=0/0 handle=0x7f874adfe8<br>   | state=S schedstat=( 83808100322 29188718104 264083 ) utm=5716 stm=2664 core=1 HZ=100<br>   | stack=0x7ff0f87000-0x7ff0f89000 stackSize=8MB<br>   | held mutexes=<br>   kernel: (couldn't read /proc/self/task/3084/stack)<br>   native: #00 pc 00000000000682e4  /system/lib64/libc.so (__epoll_pwait+8)<br>   native: #01 pc 000000000001f3a4  /system/lib64/libc.so (epoll_pwait+32)<br>   native: #02 pc 000000000001be88  /system/lib64/libutils.so (_ZN7android6Looper9pollInnerEi+144)<br>   native: #03 pc 000000000001c268  /system/lib64/libutils.so (_ZN7android6Looper8pollOnceEiPiS1_PPv+80)<br>   native: #04 pc 00000000000d3088  /system/lib64/libandroid_runtime.so (_ZN7android18NativeMessageQueue8pollOnceEP7_JNIEnvP8_jobjecti+48)<br>   native: #05 pc 000000000000554c  /system/framework/arm64/boot.oat (Java_android_os_MessageQueue_nativePollOnce__JI+144)<br>   at android.os.MessageQueue.nativePollOnce(Native method)<br>   at android.os.MessageQueue.next(MessageQueue.java:324)<br>   at android.os.Looper.loop(Looper.java:135)</p> 
<p>当处于这种状态时，我们直奔主题，分析log日志，按照logcat, kernel, cpuinfo, meminfo等依次分析：</p> 
<p>11-08 23:51:44.088  1514  1554 E ActivityManager: ANR in com.android.phone</p> 
<p>11-08 23:51:44.088  1514  1554 E ActivityManager: PID: 3084</p> 
<p>11-08 23:51:44.088  1514  1554 E ActivityManager: Reason: Broadcast of Intent { act=com.android.internal.telephony.data-restart-trysetup.default flg=0x10000014 mCallingUid=1001 (has extras) }</p> 
<p>11-08 23:51:44.088  1514  1554 E ActivityManager: Load: 9.92 / 9.81 / 10.02</p> 
<p>11-08 23:51:44.088  1514  1554 E ActivityManager: CPU usage from 0ms to 6497ms later:</p> 
<p>11-08 23:51:44.088  1514  1554 E ActivityManager:   108% 3084/com.android.phone: 101% user + 6.7% kernel / faults: 12120 minor 179 major</p> 
<p>11-08 23:51:44.088  1514  1554 E ActivityManager:   66% 1514/system_server: 16% user + 49% kernel / faults: 20836 minor 88 major</p> 
<p>11-08 23:51:44.088  1514  1554 E ActivityManager:   13% 13013/ca.bellmedia.cp24: 5.3% user + 8.4% kernel / faults: 3216 minor 39 major</p> 
<p>通过上面的log日志，发现发生ANR进程本身CPU占用比较高，再搜索"slow operation"，“low_memory” 等关键字，都没有出现在log日志中，而lowmemorykiller也以较合理的频率出现在dmesg日志中，所以基本排除是内存过低导致；所以下面延着CPU方向继续分析</p> 
<p>log日志无法找到更多线索，同时思考既然主线程状态正常，那么高cpu一定是其它线程引起的，那就反馈trace继续分析，查看phone进程的其它线程发现，几乎所有binder线程都处于waiting状态，只有Binder_2在工作：</p> 
<p>"Binder_1" prio=5 tid=40 TimedWaiting</p> 
<p>"Binder_3" prio=5 tid=40 TimedWaiting</p> 
<p>"Binder_4" prio=5 tid=40 TimedWaiting</p> 
<p>"Binder_5" prio=5 tid=39 TimedWaiting</p> 
<p>"Binder_6" prio=5 tid=40 TimedWaiting</p> 
<p>"Binder_7" prio=5 tid=40 TimedWaiting</p> 
<p>"Binder_8" prio=5 tid=40 TimedWaiting</p> 
<p>。。。。</p> 
<p>"Binder_2" prio=5 tid=8 Native</p> 
<p>  | group="main" sCount=1 dsCount=0 obj=0x12c9b0a0 self=0x7f7be14400<br>   | sysTid=3107 nice=0 cgrp=default sched=0/0 handle=0x7f8131d440<br>   | state=R schedstat=( 515275891171 40426859698 234033 ) utm=49200 stm=2327 core=2 HZ=100<br>   | stack=0x7f81221000-0x7f81223000 stackSize=1013KB<br>   | held mutexes=<br>   kernel: (couldn't read /proc/self/task/3107/stack)<br>   native: #00 pc 0000000000070f20  /system/lib64/libsqlite.so (???)<br>   native: #01 pc 000000000007420c  /system/lib64/libsqlite.so (sqlite3_step+652)<br>   native: #02 pc 00000000000ba4a4  /system/lib64/libandroid_runtime.so (???)<br>   native: #03 pc 00000000000ba514  /system/lib64/libandroid_runtime.so (???)<br>   native: #04 pc 00000000003bc578  /system/framework/arm64/boot.oat (Java_android_database_sqlite_SQLiteConnection_nativeExecuteForChangedRowCount__JJ+140)<br>   at android.database.sqlite.SQLiteConnection.nativeExecuteForChangedRowCount(Native method)<br>   at android.database.sqlite.SQLiteConnection.executeForChangedRowCount(SQLiteConnection.java:732)<br>   at android.database.sqlite.SQLiteSession.executeForChangedRowCount(SQLiteSession.java:754)<br>   at android.database.sqlite.SQLiteStatement.executeUpdateDelete(SQLiteStatement.java:64)<br>   at android.database.sqlite.SQLiteDatabase.delete(SQLiteDatabase.java:1499)<br>   at com.android.providers.telephony.SmsProvider.delete(SmsProvider.java:899)<br>   at android.content.ContentProvider$Transport.delete(ContentProvider.java:339)<br>   at android.content.ContentProviderNative.onTransact(ContentProviderNative.java:206)<br>   at android.os.Binder.execTransact(Binder.java:453)</p> 
<p>进一步分析该线程状态：state=R 说明其处于工作态。通过查看线程堆栈逻辑，发现正常情况下有log打印，借此再次返回到log日志，发现如下信息：</p> 
<p>11-08 23:51:14.512  3084  3289 W SQLiteConnectionPool: The connection pool for database '/data/user/0/com.android.providers.telephony/databases/mmssms.db' has been unable to grant a connection to thread 111 (Binder_3) with flags 0x1 for 30.000002 seconds.</p> 
<p>11-08 23:51:14.512  3084  3289 W SQLiteConnectionPool: Connections: 1 active, 0 idle, 0 available.</p> 
<p>11-08 23:51:14.512  3084  3289 W SQLiteConnectionPool:</p> 
<p>11-08 23:51:14.512  3084  3289 W SQLiteConnectionPool: Requests in progress:</p> 
<p>11-08 23:51:14.512  3084  3289 W SQLiteConnectionPool:   executeForChangedRowCount started 30008ms ago - running, sql="DELETE FROM sms WHERE (thread_id=2) AND (locked=0 AND date&lt;1452658564000)"</p> 
<p>11-08 23:51:14.513  3084  3613 W SQLiteConnectionPool: The connection pool for database '/data/user/0/com.android.providers.telephony/databases/mmssms.db' has been unable to grant a connection to thread 141 (Binder_5) with flags 0x1 for 30.009 seconds.</p> 
<p>11-08 23:51:14.513  3084  3613 W SQLiteConnectionPool: Connections: 1 active, 0 idle, 0 available.</p> 
<p>说明在Binder_3和Binder_6线程执行Sql之前，已经有其它线程执行时间超过30S仍未结束。继续搜集log发现，有15个Binder线程处于Waiting状态，而那个正在执行的则为Binder-2，耗时30S以上。</p> 
<p>综上了该进程高CPU的原因：Binder_2线程执行Sql操作时间过长，进一步引起其它所有Binder线程被block，导致系统广播发送无法及时通过Binder传递给主线程，误触发系统认为Phone进程处理广播超时。</p> 
<p></p> 
<h2>实例五：高CPU过度抢占时间片，导致其它应用或任务难以及时调度</h2> 
<p>示例：<br> 该类问题主线程多半是处于空闲或Suspend状态，后者表示系统分配的CPU时间片无法满足当前需要便被强行切换，而引起该类现象的要么是底层系统动作，要么是其它任务高优先级任务抢占CPU行为；</p> 
<p>"main" prio=5 tid=1 Suspended</p> 
<p>  | group="main" sCount=2 dsCount=0 obj=0x75285af8 self=0x7f87a46a00</p> 
<p>  | sysTid=9251 nice=-6 cgrp=default sched=0/0 handle=0x7f8c5f7fe8</p> 
<p>  | state=S schedstat=( 50580737351 8433337317 81975 ) utm=4561 stm=497 core=1 HZ=100</p> 
<p>  | stack=0x7ff8105000-0x7ff8107000 stackSize=8MB</p> 
<p>  | held mutexes=</p> 
<p>  at java.util.Arrays.checkOffsetAndCount(Arrays.java:1722)</p> 
<p>  at java.nio.CharBuffer.wrap(CharBuffer.java:90)</p> 
<p>  at java.nio.CharBuffer.wrap(CharBuffer.java:68)</p> 
<p>  at android.text.TextDirectionHeuristics$TextDirectionHeuristicImpl.isRtl(TextDirectionHeuristics.java:149)</p> 
<p>  at android.text.BoringLayout.isBoring(BoringLayout.java:477)</p> 
<p>  at android.widget.TextView.onMeasure(TextView.java:7096)</p> 
<p>  at android.view.View.measure(View.java:19138)</p> 
<p>  at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:6064)</p> 
<p>  at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1465)</p> 
<p>  at android.widget.LinearLayout.measureHorizontal(LinearLayout.java:1112)</p> 
<p>  at android.widget.LinearLayout.onMeasure(LinearLayout.java:632)</p> 
<p>  at android.view.View.measure(View.java:19138)</p> 
<p>当Trace上无法继续分析时，便需要分析日志了，搜索关键字“anr in”，发现</p> 
<p>11-26 11:47:16.514  1457  1490 E ActivityManager: ANR in com.android.browser (com.android.browser/.MainActivity)</p> 
<p>11-26 11:47:16.514  1457  1490 E ActivityManager: PID: 9251</p> 
<p>11-26 11:47:16.514  1457  1490 E ActivityManager: Reason: Input dispatching timed out (Waiting to send non-key event because the touched window has not finished processing certain input events that were delivered to it over 500.0ms ago.  Wait queue length: 10.  Wait queue head age: 8974.9ms.)</p> 
<p>11-26 11:47:16.514  1457  1490 E ActivityManager: Load: 10.97 / 10.71 / 10.0</p> 
<p>11-26 11:47:16.514  1457  1490 E ActivityManager: CPU usage from 0ms to 10480ms later:</p> 
<p>11-26 11:47:16.514  1457  1490 E ActivityManager:   114% 9251/com.android.browser: 65% user + 48% kernel / faults: 10870 minor 11 major</p> 
<p>11-26 11:47:16.514  1457  1490 E ActivityManager:   108% 1457/system_server: 33% user + 74% kernel / faults: 9584 minor 11 major</p> 
<p>浏览器自身CPU占用较高，至于System_server占用比较多，尤其是当大家看到“ CPU usage from 0ms to 10480ms later”已经kernel部分（74% kernel /）占用较多的情况下，不要再轻易怀疑是system_server高CPU导致，其高CPU的真正原因是需要dump各进程信息而已。</p> 
<p>顺着"ANR in"之前的日志，我们继续向上看，发现该应该进行了大量且频繁的GC操作</p> 
<p>11-26 11:47:05.204  1457  1467 I art     : Background partial concurrent mark sweep GC freed 842(578KB) AllocSpace objects, 455(85MB) LOS objects, 8% free, 169MB/185MB, paused 2.140ms total 245.072ms</p> 
<p>11-26 11:47:10.493  9251 31938 W art     : Suspending all threads took: 131.446ms</p> 
<p>11-26 11:47:10.598  9251 31938 W art     : Suspending all threads took: 88.134ms</p> 
<p>11-26 11:47:10.699  9251 31938 W art     : Suspending all threads took: 93.939ms</p> 
<p>11-26 11:47:10.795  9251 31938 W art     : Suspending all threads took: 75.051ms</p> 
<p>11-26 11:47:10.821  9251 31938 W art     : Suspending all threads took: 14.536ms</p> 
<p>11-26 11:47:10.956  9251 31938 W art     : Suspending all threads took: 114.243ms</p> 
<p>11-26 11:47:11.101  9251 31938 W art     : Suspending all threads took: 121.775ms</p> 
<p>11-26 11:47:11.254  9251 31938 W art     : Suspending all threads took: 93.763ms</p> 
<p>.....</p> 
<p>而根据GC类型（Background partial concurrent）来看，应该是有任务在不停的申请和使用大量内存，带着这样的想法，需要再此返回到Trace日志，分析相关线程状态，在大量的对比分析筛选之后，很幸运的发现了如下线程（该线程只有采集TraceView才会出现），并且处于R状态。对TraceView了解的同事都知道，该任务会引起关联进程非常大CPU消耗，并且异常卡顿（主线程得不到及时响应）。</p> 
<p>"Sampling Profiler" daemon prio=9 tid=162 Native</p> 
<p>  | group="system" sCount=1 dsCount=0 obj=0x13102220 self=0x7f5a82f800</p> 
<p>  | sysTid=31938 nice=-6 cgrp=default sched=0/0 handle=0x7f643ff440</p> 
<p>  | state=R schedstat=( 22112458218 4449717737 10001 ) utm=2021 stm=190 core=0 HZ=100</p> 
<p>综上找到了该进程高CPU的原因：采集TraceView线程需要申请大量内存不断触发进程内部GC，并且自身任务属于高耗时操作，从未导致主线程得不到及时调度和响应，触发ANR。</p> 
<p>实例六：日志不全，缺少Trace或其它日志，示例：<br> 遇到这类问题是比较郁闷的，这个时候智能拿现有的信息进行分析，尝试找出问题或改进方向，例如缺少Trace.但是其它日志相对齐全</p> 
<p>例如在event日志中找到了应用ANR的大概时间点：10-14 00:40:26.010650</p> 
<p>10-14 00:40:26.010650  1132  1172 I am_anr  : [0,19746,android.process.media,952680005,Broadcast of Intent { act=android.intent.action.MEDIA_SCANNER_SCAN_FILE dat=file:///sdcard/AutoSmoke_UI30/testSwitchLetvView_20161014_003533/1476376700108.png 在flg=0x10 cmp=com.android.providers.media/.MediaScannerReceiver }]</p> 
<p>在sys_log中发现ANR时进程CPU信息</p> 
<p>10-14 00:40:57.052274  1132  1172 E ANRManager: ANR in android.process.media, time=304722739<br> 10-14 00:40:57.052274  1132  1172 E ANRManager: Reason: Broadcast of Intent { act=android.intent.action.MEDIA_SCANNER_SCAN_FILE dat=file:///sdcard/AutoSmoke_UI30/testSwitchLetvView_20161014_003533/1476376700108.png flg=0x10 cmp=com.android.providers.media/.MediaScannerReceiver }<br> 10-14 00:40:57.052274  1132  1172 E ANRManager: Load: 37.88 / 25.54 / 20.22<br> 10-14 00:40:57.052274  1132  1172 E ANRManager: Android time :[2016-10-14 00:40:56.95] [304754.500]<br> 10-14 00:40:57.052274  1132  1172 E ANRManager: CPU usage from 17448ms to 0ms ago:<br> 10-14 00:40:57.052274  1132  1172 E ANRManager:   117% 19252/com.letv.android.letvlive: 80% user + 36% kernel / faults: 684 minor<br> 10-14 00:40:57.052274  1132  1172 E ANRManager:   110% 11620/mediaserver: 64% user + 45% kernel / faults: 23 minor<br> 10-14 00:40:57.052274  1132  1172 E ANRManager:   41% 378/logd: 19% user + 21% kernel / faults: 17 minor<br> 10-14 00:40:57.052274  1132  1172 E ANRManager:   22% 573/mobile_log_d: 17% user + 5.3% kernel / faults: 1123 minor<br> 10-14 00:40:57.052274  1132  1172 E ANRManager:   18% 19286/com.letv.android.letvlive:cde: 11% user + 6.9% kernel / faults: 6029 minor<br> 10-14 00:40:57.052274  1132  1172 E ANRManager:   18% 422/adbd: 2.1% user + 15% kernel / faults: 1722 minor<br> 10-14 00:40:57.052274  1132  1172 E ANRManager:   17% 18392/logcat: 7.4% user + 10% kernel</p> 
<p>从上面日志可以看到有两个进程CPU占用率偏高，且系统长时间CPU负载很重（Load: 37.88 / 25.54 / 20.22），尤其是ANR之前1分钟的负载达到37；由此我们可以大概率的猜测这次ANR事故是由CPU过高导致其它任务调度不及时导致，到底是不是呢？还是如其他同事认为的内存原因引起呢？下面我们继续看对应时间点的Kernel日志，关键字”lowmemorykiller“，得到如下信息：</p> 
<p>&lt;6&gt;[302600.931727]  (4)[10628:Cam@AuxSensorCo]lowmemorykiller: Killing 'android.browser' (28649), adj 18, score_adj 1000,</p> 
<p>&lt;6&gt;[302600.931727]    to free 72464kB on behalf of 'Cam@AuxSensorCo' (10628) because</p> 
<p>&lt;6&gt;[302600.931727]    cache 1000628kB is below limit 322560kB for oom_score_adj 0</p> 
<p>&lt;6&gt;[302600.931727]    Free memory is 235708kB above reserved</p> 
<p>&lt;6&gt;[303901.663086]  (6)[16560:Cam@AuxSensorCo]lowmemorykiller: Killing 'roid.emojistore' (15854), adj 18, score_adj 1000,</p> 
<p>&lt;6&gt;[303901.663086]    to free 75636kB on behalf of 'Cam@AuxSensorCo' (16560) because</p> 
<p>&lt;6&gt;[303901.663086]    cache 1292884kB is below limit 322560kB for oom_score_adj 0</p> 
<p>&lt;6&gt;[303901.663086]    Free memory is 285336kB above reserved</p> 
<p>&lt;6&gt;[302623.705248]  (2)[10970:Cam@AuxSensorCo]lowmemorykiller: Killing 'ews:pushservice' (6186), adj 13, score_adj 764,</p> 
<p>&lt;6&gt;[302623.705248]    to free 62140kB on behalf of 'Cam@AuxSensorCo' (10970) because</p> 
<p>&lt;6&gt;[302623.705248]    cache 992668kB is below limit 322560kB for oom_score_adj 0</p> 
<p>&lt;6&gt;[302623.705248]    Free memory is 81320kB above reserved</p> 
<p>cache项 ：为kernel端的文件缓存cache，为了提高IO访问速度，底层系统会有选择的缓存一些文件；</p> 
<p>limit： 内存（文件缓存）的最低内存限制322560kB，当内存和文件缓存同时低于这个阀值，LMK变开始寻找低优先级进程查杀。</p> 
<p>score_adj：从上层设置到kernel经过转换后的进程优先级，adj--&gt; score_adj; score_adj为1000，则说明被查杀的进程优先级很低。</p> 
<p>Free memory：当前空闲物理内存。</p> 
<p>[302623.705248]：Kernel开机时间戳</p> 
<p>通过以上日志分析可以得出结论：系统可用内存（Free+Cache）整体维持在1G左右，属于良好。查杀进程间隔时间较长，不会对系统负载带来太多开销。</p> 
<p>分析完以上日志，基本排除了内存问题引起的ANR，接下来再回到log日志，分析ANR高CPU进程的相关日志，看看能否有进一步挖掘。在log日志中，高亮进程PID(11620)，结果发现在很长一段时间内存，该进程有几十万的日志输出，此时心里或许有了希望，这么频繁的输出，且含有很多相同日志，那就说明该进程产生了大量循环，而大量循环也是高CPU的常见起因。</p> 
<p>10-14 00:40:46.035707 11620 19687 D MtkOmxVdecEx: [0xe1eb7800] RemoveInputBuf frm=0xe1eb8d70, omx=0xa3b9dfe0, i=5<br> 10-14 00:40:46.035791 11620 19687 D MtkOmxVdecEx: [0xe1eb7800] FB in (0xA3B9DFE0)<br> 10-14 00:40:46.036599 11620 11620 D MtkOmxMVAMgr: [0xb3cca9f0] [ION][FreeBuffer] entry=0xa3bcf3c0, va=0xd30d7000, pa=0x47600000,size=0x180000, srcFd=0xFFFFFFFF, fd=0xFFFFFFFF, bufHdr=0xA3B9CAE0<br> 10-14 00:40:46.037036 11620 11620 D MtkOmxVdecEx: [0xe1eb7800] RemoveInputBuf frm=0xe1eb8d28, omx=0xa3b9cae0, i=4<br> 10-14 00:40:46.037125 11620 11620 D MtkOmxVdecEx: [0xe1eb7800] FB in (0xA3B9CAE0)<br> 10-14 00:40:46.037907 11620 11655 D MtkOmxMVAMgr: [0xb3cca9f0] [ION][FreeBuffer] entry=0xabbfc4e0, va=0xd3557000, pa=0x47000000,size=0x180000, srcFd=0xFFFFFFFF, fd=0xFFFFFFFF, bufHdr=0xA3B9C0C0<br> 10-14 00:40:46.038281 11620 11655 D MtkOmxVdecEx: [0xe1eb7800] RemoveInputBuf frm=0xe1eb8ce0, omx=0xa3b9c0c0, i=3<br> 10-14 00:40:46.038364 11620 11655 D MtkOmxVdecEx: [0xe1eb7800] FB in (0xA3B9C0C0)<br> 10-14 00:40:46.039097 11620 11657 D MtkOmxMVAMgr: [0xb3cca9f0] [ION][FreeBuffer] entry=0xa3bcf240, va=0xd3f80000, pa=0x46c00000,size=0x180000, srcFd=0xFFFFFFFF, fd=0xFFFFFFFF, bufHdr=0xA3B9C120<br> 10-14 00:40:46.039734 11620 11657 D MtkOmxVdecEx: [0xe1eb7800] RemoveInputBuf frm=0xe1eb8c98, omx=0xa3b9c120, i=2<br> 10-14 00:40:46.039829 11620 11657 D MtkOmxVdecEx: [0xe1eb7800] FB in (0xA3B9C120)<br> 10-14 00:40:46.041510 11620 11653 D MtkOmxMVAMgr: [0xb3cca9f0] [ION][FreeBuffer] entry=0xa3bcf6f0, va=0xdb528000, pa=0x46600000,size=0x180000, srcFd=0xFFFFFFFF, fd=0xFFFFFFFF, bufHdr=0xA3B9DF20<br> 10-14 00:40:46.041966 11620 11653 D MtkOmxVdecEx: [0xe1eb7800] RemoveInputBuf frm=0xe1eb8c50, omx=0xa3b9df20, i=1<br> 10-14 00:40:46.042057 11620 11653 D MtkOmxVdecEx: [0xe1eb7800] FB in (0xA3B9DF20)<br> 10-14 00:40:46.043345 11620 11654 D MtkOmxMVAMgr: [0xb3cca9f0] [ION][FreeBuffer] entry=0xa3bcf120, va=0xdb828000, pa=0x43200000,size=0x180000, srcFd=0xFFFFFFFF, fd=0xFFFFFFFF, bufHdr=0xABBC4420<br> 10-14 00:40:46.043756 11620 11654 D MtkOmxVdecEx: [0xe1eb7800] RemoveInputBuf frm=0xe1eb8c08, omx=0xabbc4420, i=0<br> 10-14 00:40:46.043841 11620 11654 D MtkOmxVdecEx: [0xe1eb7800] FB in (0xABBC4420)<br> 10-14 00:40:46.044026 11620 11654 D MtkOmxVdecEx: [0xe1eb7800] MtkOmxVdec::FreeBuffer all input buffers have been freed!!! signal mInPortFreeDoneSem(1)</p> 
<p>至此，导出进一步结论，应用发生ANR主要是上面两个进程高CPU引起调度不及时。至于进程高CPU的进一步原因，则需要相关模块Owner结合日志进一步分析，论证。</p> 
<p>       通过以上6类ANR实例剖析，可以看出，除了正常Receiver处理耗时操作引起的ANR之外，也会有其它因素引发此类问题，例如总体内存偏低导致交换（kswap），CPU过高导致调度不及时，Binder资源被耗尽无法及时通讯等等，发生此类问题线索较为隐晦，需要大家汇总多个日志反复对比；但是好在这类问题发生时，系统都有关键log日志输出，可以利用关键字多角度深入分析，综合对比，这类问题多数时候是可以得出有效结论，并给出优化(解决)方案；对应日志确实不足的，只能借助于测试帮忙复现，并提供更多有效日志了。除此之外，也需要对相关系统知识有更多了解，例如LMK, 进程调能，Binder通信机制。方能在分析，解决此类问题过程中，有更多的参考和衡量。<br> ————————————————<br> 版权声明：本文为CSDN博主「周一的早上」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/qzh123456/article/details/78737791</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/324c2229efaedce6a4ee5031369d6fbc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于vivado（语言Verilog）的FPGA学习（2）——zedboard开机测试和程序烧写</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ca6c789b506b3570e5a0eeaf5ae46dd7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL 查询语句的执行顺序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>