<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软件开发的基本知识讲义 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软件开发的基本知识讲义" />
<meta property="og:description" content="软件开发的基本知识讲义
韩慧健
一、软件的概念
1、软件：是计算机系统中与硬件相互依存的部分，它包括程序、数据及相关文档的完整集合。其中
Ø 程序－是按照事先设计的功能和性能的要求执行的指令序列
Ø 数据－是使程序正常操纵信息的数据结构
Ø 文档－是程序开发、维护和使用有关的图文资料
2、软件分类（按功能划分）
Ø 系统软件：如操作系统、数据库管理系统、设备驱动程序等
Ø 支撑软件：协助用户开发软件的工具性软件，如微软可视化开发平台工具
Ø 应用软件：为特定目的服务的软件，如财务管理软件。
二、软件工程和软件开发
1、 软件工程
Ø 一系列完善的工程化原则。
软件工程是为经济地获得能够在实际机器上有效运行的可靠软件而建立和使用的一系列完善的工程化原则。
Ø 软件工程是开发、运行、维护和修复软件的系统方法。
1983年，IEEE（电气和电子工程师学会）作出定义，软件工程是开发、运行、维护和修复软件的系统方法。软件定义为：计算机程序、方法、规则、相关的文档资料以及在计算机上运行时所必须的数据。
Ø 主要思想是强调软件开发过程需要英语工程化的原则。
2、 软件的生存周期
按照软件工程的过程（plan, do,check, action）即软件规格说明、软件开发、软件确认，软件演进，进一步展开，软件的生存周期包括6个阶段
（1） 制定计划
（2） 需求分析
（3） 软件设计
（4） 程序编写
（5） 软件测试
（6） 运行和维护
3、 软件开发
开发阶段有三个相互关联的步骤组成，即设计、实现（编码）、测试。
三、各个阶段的目标和主要工作 制定计划
管理层面的内容。
Ø 制定待开发软件系统的总目标，给出它的功能、性能、可靠性以及接口等方面的要求；
Ø 研究完成该项软件任务的可行性，探讨解决问题的可能方案；
Ø 制定开发实施计划，可行性研究报告。
需求分析
对待开发软件提出的需求进行分析并给详细定义出
需求分析的目标：
Ø 是深入描述软件的功能和性能，确定软件设计的约束、软件同其它系统元素的接口细节，
Ø 分析阶段只确定软件系统要“做什么”，
Ø “怎么做’有后续的设计阶段完成。对算法的详细描述也是在设计阶段给出。
Ø 定义软件的其它有效性需求。
需求分析的任务：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f2b3f3c829d72b5194c4fa35f3f5fb78/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2006-01-19T14:24:00+08:00" />
<meta property="article:modified_time" content="2006-01-19T14:24:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软件开发的基本知识讲义</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body">
    
 <p align="center"><span lang="en-us"><b>软件开发的基本知识讲义</b><b></b></span></p> 
 <p align="center">韩慧健</p> 
 <p><b>一、软件的概念</b><b></b></p> 
 <p><b><span lang="en-us">1</span></b><b>、软件：</b>是计算机系统中与硬件相互依存的部分，它包括程序、数据及相关文档的完整集合。其中</p> 
 <p><span lang="en-us">Ø         程序－是按照事先设计的功能和性能的要求执行的指令序列</span></p> 
 <p><span lang="en-us">Ø         数据－是使程序正常操纵信息的数据结构</span></p> 
 <p><span lang="en-us">Ø         文档－是程序开发、维护和使用有关的图文资料</span></p> 
 <p><b><span lang="en-us">2</span></b><b>、软件分类（按功能划分）</b></p> 
 <p><span lang="en-us">Ø         系统软件：如操作系统、数据库管理系统、设备驱动程序等</span></p> 
 <p><span lang="en-us">Ø         支撑软件：协助用户开发软件的工具性软件，如微软可视化开发平台工具</span></p> 
 <p><span lang="en-us">Ø         应用软件：为特定目的服务的软件，如财务管理软件。</span></p> 
 <p><b>二、软件工程和软件开发</b><b></b></p> 
 <p><b><span lang="en-us">1、 </span></b><b>软件工程</b></p> 
 <p><span lang="en-us">Ø         一系列完善的工程化原则。</span></p> 
 <p>软件工程是为经济地获得能够在实际机器上有效运行的可靠软件而建立和使用的一系列完善的工程化原则。</p> 
 <p><span lang="en-us">Ø         软件工程是开发、运行、维护和修复软件的系统方法。</span></p> 
 <p><span lang="en-us">1983</span>年，<span lang="en-us">IEEE</span>（电气和电子工程师学会）作出定义，软件工程是开发、运行、维护和修复软件的系统方法。软件定义为：计算机程序、方法、规则、相关的文档资料以及在计算机上运行时所必须的数据。</p> 
 <p><span lang="en-us">Ø         主要思想是强调软件开发过程需要英语工程化的原则。</span></p> 
 <p><b><span lang="en-us">2、 </span></b><b>软件的生存周期</b></p> 
 <p>按照软件工程的过程（<span lang="en-us">plan, do,check, action</span>）即软件规格说明、软件开发、软件确认，软件演进，进一步展开，软件的生存周期包括<span lang="en-us">6</span>个阶段</p> 
 <p><span lang="en-us">（1）       制定计划</span></p> 
 <p><span lang="en-us">（2）       需求分析</span></p> 
 <p><span lang="en-us">（3）       软件设计</span></p> 
 <p><span lang="en-us">（4）       程序编写</span></p> 
 <p><span lang="en-us">（5）       软件测试</span></p> 
 <p><span lang="en-us">（6）       运行和维护</span></p> 
 <p><b><span lang="en-us">3、 </span></b><b>软件开发</b></p> 
 <p>开发阶段有三个相互关联的步骤组成，即设计、实现（编码）、测试。</p> 
 <p align="left"><b>三、各个阶段的目标和主要工作</b><b> </b></p> 
 <p><span lang="en-us"> </span></p> 
 <p><b>制定计划</b><b></b></p> 
 <p>管理层面的内容。</p> 
 <p><span lang="en-us">Ø         制定待开发软件系统的总目标，给出它的功能、性能、可靠性以及接口等方面的要求；</span></p> 
 <p><span lang="en-us">Ø         研究完成该项软件任务的可行性，探讨解决问题的可能方案；</span></p> 
 <p><span lang="en-us">Ø         制定开发实施计划，可行性研究报告。</span></p> 
 <p><b>需求分析</b><b></b></p> 
 <p>对待开发软件提出的需求进行分析并给详细定义出</p> 
 <p><b>需求分析的目标：</b></p> 
 <p><span lang="en-us">Ø         是深入描述软件的功能和性能，确定软件设计的约束、软件同其它系统元素的接口细节，</span></p> 
 <p><span lang="en-us">Ø         分析阶段只确定软件系统要“做什么”，</span></p> 
 <p><span lang="en-us">Ø         “怎么做<span lang="en-us">’</span>有后续的设计阶段完成。对算法的详细描述也是在设计阶段给出。</span></p> 
 <p><span lang="en-us">Ø         定义软件的其它有效性需求。</span></p> 
 <p><b>需求分析的任务：</b></p> 
 <p><span lang="en-us">Ø         通过与用户的合作，了解用户对待开发系统的要求；</span></p> 
 <p><span lang="en-us">Ø         根据用户的要求的系统所在的信息域的调查、分析，确定系统的逻辑模型；</span></p> 
 <p><span lang="en-us">Ø         对求解的问题做适当的分解，使之适合于计算机求解。</span></p> 
 <p><b>需求分析工作的内容：</b></p> 
 <p><b>数据建模：</b></p> 
 <p>包括<u><span lang="en-us">3</span></u><u>种相互关联的信息，即数据对象、描述对象的属性、描述对象间相互链接的关系。</u>用数据流图描述系统数据流的变换和流向，用数据词典定义数据流图中出现的数据流、数据文件、加工和处理，用判定表表示复杂条件和动作组合情况。</p> 
 <p><b>功能建模和数据流：</b></p> 
 <p><u>目标系统被表示成“输入信息－》目标系统－》输出信息”</u>，系统的功能体现在<b>核心数据变换</b>中。功能建模的思想就是用<b>抽象模型的概念</b>，按照软件内部数据传递、变换的关系，自顶向下逐层分解，直到找到满足功能要求的所有可实现的软件为止。功能建模表达数据的运动情况和数据流的变换。</p> 
 <p><b>行为建模：</b>给出需求分析方法的所有<b>操作原则</b>。描述系统或对象的状态、导致状态改变的事件，从而描述系统的行为。</p> 
 <p align="left"><b>软件设计</b><span lang="en-us">•</span>需求转换成体系结构，对每个模块具体描述。</p> 
 <p align="left"><span lang="en-us">Ø         <b>需求转换成体系结构，对每个模块具体描述</b>。</span></p> 
 <p><span lang="en-us"> </span></p> 
 <p><b>软件设计</b>是一个把软件需求变换为软件表示的过程。把已确定的各项需求转换成<u>相应的体系结构，</u>进而对<u>每个模块</u>需完成的工作进行<u>具体描述。</u>最初这个表示只是描述出可直接反映功能、数据、行为需求的软件的总框架，然后进一步细化，在此框架中填入细节，把它加工成程序细节上非常接近与源程序的软件表示。</p> 
 <p><span lang="en-us">Ø         <b>软件设计是解决<span lang="en-us">“</span></b><b>怎么做<span lang="en-us">“</span></b><b>的问题。</b></span></p> 
 <p><span lang="en-us"> </span></p> 
 <p>软件分析阶段已经完全弄清楚了软件的各种需求，<u>软件设计是解决“怎么做“的问题</u>。</p> 
 <p><span lang="en-us">Ø         <b>软件设计的内容</b></span></p> 
 <p>根据分析模型中用数据、功能、行为模型所表示的需求，采用相应设计方法进行概要设计（数据设计、体系结构设计、接口设计）和详细设计（过程设计）。</p> 
 <p><span lang="en-us">n         <b>概要设计：</b></span></p> 
 <p>将软件需求转化为<u>数据结构和软件的系统结构，并建立接口，建立整个系统的体系结构框架，并给出了系统中的全局数据结构和数据库接口、人－机接口，与其它的硬件、软件的接口。</u><u></u></p> 
 <p>此外还从系统全局的角度，考虑处理方式、运行方式、容错方式以及系统维护等方面的问题，奠定整个系统实现的基础，没有概要设计直接考虑程序设计，就不能从全局把握软件系统的结构和质量，容易造成程序结构划分不合理，导致系统处于一种不稳定的状态。<b>这个阶段应着重解决实现需求的程序模块划分问题。</b>（数据设计、体系结构设计、接口设计）</p> 
 <p><b>数据设计：</b></p> 
 <p>把需求中的对象和关系，以及数据词典中描述的详细数据内容转化为数据结构的定义。</p> 
 <p><b><u>数据设计的过程：</u></b></p> 
 <p><span lang="en-us">1</span>、为在需求分析阶段所确定的数据对象选择逻辑表示，需要对不同的结构进行算法分析，以便选择一个最有效的设计方案。</p> 
 <p><span lang="en-us">2</span>、确定对逻辑数据结构所必须的操作模块，以便限制或确定各个数据设计决策的影响范围。</p> 
 <p><b>数据设计的原则：</b></p> 
 <p><span lang="en-us">1</span>、考虑几种不同的数据方案，考虑给后期设计带来的影响</p> 
 <p><span lang="en-us">2</span>、确定所有的数据结构和每种数据结构上施加的操作</p> 
 <p><span lang="en-us">3</span>、应当建立一个数据词典。即表示数据项和控制项的特性，明确定义各种信息项。</p> 
 <p>比如</p> 
 <p>存折＝户名＋所号＋帐号＋开户日＋性质</p> 
 <p>户名＝<span lang="en-us">2{<!-- --></span>字母<span lang="en-us">}24 //</span>至少出现<span lang="en-us">2</span>个字母，最多出现<span lang="en-us">24</span>个</p> 
 <p>所号＝<span lang="en-us">’’&lt;?xml:namespace prefix = st1 /&gt;001”..”999”//</span>储蓄所编码规定为<span lang="en-us">3</span>位数</p> 
 <p>开户日＝年＋月＋日</p> 
 <p>性质＝<span lang="en-us">’1’..”6”//1</span>表示普通用户，<span lang="en-us">5</span>表示工资用户等等</p> 
 <p><span lang="en-us">4、  逐步细化方法应用于数据设计</span></p> 
 <p>底层数据的设计推迟到设计过程的后期，将逐步细化方法应用于数据设计，即需求分析阶段确定总体数据组织，概要设计阶段加以细化，详细设计阶段才规定具体细节。</p> 
 <p><span lang="en-us">5</span>、程序设计语言应当支持数据类型的定义和实现。</p> 
 <p><b><u>清晰的信息定义是软件开发成功的关键。</u></b><b><u></u></b></p> 
 <p align="center"><b>附</b><b><span lang="en-us">  </span></b><b>数据设计相关内容讲解</b><b></b></p> 
 <p>　　在计算机发展的初期，计算机主要用于数值计算，处理的是数值数据，而且数据量小，结构简单，形式统一。随着计算机技术的发展，计算机应用领域的扩大，越来越多的非数值数据需要处理，数据的概念也被大大推广，数字、字符、图像、声音都可属于数据的范畴。与数值数据相比，非数值数据的结构比较复杂，其计算机表示也比较麻烦。</p> 
 <p>　　只有对数据内部的结构关系以及数据在计算机内如何存储和操作进行深入的研究，才能设计出高效可靠的程序，实现对数据的有效处理。</p> 
 <p><b>　</b><b><span lang="en-us">1</span></b><b>、</b><b> </b><b>数学模型</b><b></b></p> 
 <p>　　用计算机解决一个实际问题，首先必须从具体问题抽象出一个适当的数学模型，用这个数学模型应能得出该问题的精确或近似解。然后确定数学模型的计算方法，根据问题的具体要求，可在已知的各种算法中选择一种合适的算法或另设计一种新的算法。接下来就是用某种程序设计语言为确定的算法编制计算机程序，同时准备好作为程序处理对象的各种数据。再接下来就开始程序的调试运行，用一些典型的数据和描述边界条件的数据对程序进行测试，以便发现和纠正程序中的错误，错误的纠正可能导致前面步骤的多次反复。最后，在程序调试达到所要求的质量标准之后，就可正式投入运行，最终在计算机上得出问题的解。</p> 
 <p>　　建立实际问题的数学模型是计算机应用必须首先进行的工作，也是一项很重要的工作。</p> 
 <p>　　常见的数学模型可分为数值计算和非数值计算两大类。许多实际问题数学抽象的结果是数学方程。这些数学方程可以用解析的方法求出精确解，或者用模拟的方法求出近似解。但是更多的实际问题无法用数学方程来描述，这些问题所求的不是某个数值，而是某种检索的结果，某种排列的状态，某种转换后的形式，某种设计的表示……这些问题的数学模型不是用数学方程，而是用一种<b>数据结构</b>来描述数据以及数据之间的相互关系。</p> 
 <p><b><span lang="en-us">2</span></b><b>、数据结构的概念</b><b></b></p> 
 <p>　　<b>数据</b>是对客观事物的名称、数量、特征、性质的描述形式（即编码），是计算机所能处理的一切符号的总称。数据既是计算机加工的对象，又是计算机的产品（计算结果）。例如，一个利用数值分析方法解代数方程的程序，其处理对象是整数和实数；一个编译程序或者文字处理程序的处理对象是字符串。因此，对计算机科学来讲，数据的含义很广泛，比如图形、图象、色彩和声音等都可以通过编码而归于数据的范畴。</p> 
 <p>　　一般，我们对那些单个的孤立的数据并不感兴趣，而着重研究由众多数据元素组成的数据集合，研究集合中数据元素之间存在怎样的内在联系，通常需要对数据和数据集合进行哪些运算（即对数据进行的处理），如何提高运算效率等等，这就引出了数据结构。</p> 
 <p>　　数据结构里包括一批数据，是数据的一个集合。这个集合中的每一个数据个体称为<b>数据元素</b>，它是数据的基本单位。一个数据元素又叫做一个<b>数据结点</b>，简称结点。</p> 
 <p>　　<b>数据类型</b>是指程序设计语言中所允许的变量的种类，也就是变量可以取的值和可以进行的运算的集合。可以把数据类型看成是在程序设计语言中已经实现了的数据结构。</p> 
 <p>　　一个数据元素可以是简单的，只有一个数据项，例如一个数，一个字符，一个名字等；也可以是复杂的，由若干数据项组成，一个数据结点由用来描述一个独立事物的名称、数量、特征、性质的一组相关信息组成。例如，在设计处理学生成绩问题的程序时，每个学生有关的数据项<span lang="en-us">(</span>域<span lang="en-us">)</span>构成一个数据结点，可能包括学生的姓名、学号、各科考试成绩等等，学号可以作为结点的关键字。在处理库存商品问题时，一个数据结点对应一种商品的相关数据项，包括商品编号和名称、规格、数量、生产厂家、单价、入库日期等，商品编号可以作为关键字。</p> 
 <p><b>数据结构</b>是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的存储结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法。<b><u></u></b></p> 
 <p><b>体系结构设计：</b></p> 
 <p><b>――定义软件系统中各主要成分之间的关系。</b></p> 
 <p>事实上，<u>软件总是有体系结构的</u>，不存在没有体系结构的软件。体系结构（<span lang="en-us">Architecture</span>）一词在英文里就是<span lang="en-us">"</span>建筑<span lang="en-us">"</span>的意思。把软件比作一座楼房，从整体上讲，是因为它有基础、主体和装饰，即操作系统之上的基础设施软件、实现计算逻辑的主体应用程序、方便使用的用户界面程序。从细节上来看每一个程序也是有结构的。</p> 
 <p><span lang="en-us">Ø         <u>结构化程序就是以语句组成模块，模块的聚集和嵌套形成层层调用的程序结构，也就是体系结构。</u><u></u></span></p> 
 <p><span lang="en-us">Ø         主要有三要素：<b>程序构件（模块）的层次结构</b>、<b>构件之间的交互方式</b>，及<b>数据的结构</b>。</span></p> 
 <p>虽然软件体系结构已经在软件工程领域中有着广泛的应用，但迄今为止还没有一个被大家所公认的定义。许多专家学者从不同角度和不同侧面对软件体系结构进行了刻画，</p> 
 <p><span lang="en-us">Ø         <u>软件设计的一个目标就是建立软件的体系结构表示。</u><u></u></span></p> 
 <p>体系结构经历了一个由低级到高级的发展过程，有数据流系统、调用－返回系统、独立构建系统、虚拟机等等。<u>我们用</u><u><span lang="en-us">C</span></u><u>语言编制的软件结构采用一种调用－返回式的。</u><u></u></p> 
 <p><span lang="en-us">Ø         解决了模块划分问题</span></p> 
 <p>软件体系结构不仅指定了系统的<b>组织结构和拓扑结构</b>，并且显示了系统需求和构成系统的元素之间的对应关系，提供了一些设计决策的基本原理</p> 
 <p><b>接口设计：</b></p> 
 <p><b>――</b>根据数据流图定义软件内部各成分之间、软件与其它协同系统之间以及软件与用户之间的交互机制。</p> 
 <p><span lang="en-us">n       <b>详细设计：</b><b></b></span></p> 
 <p>即过程设计（也叫<b>程序设计</b>），通过对结构表示进行细化，得到软件的<u>详细数据结构</u>和<u>算法</u>。要决定概要设计阶段每个模块的具体算法。</p> 
 <p><b>程序设计（过程设计）：</b></p> 
 <p><span lang="en-us">Ø         把结构成分转化为软件的过程性描述，满足在编码阶段能够根据过程性描述生成源程序代码。</span></p> 
 <p><span lang="en-us">Ø         程序设计的任务：需要对程序采用的算法的逻辑关系进行分析，设计出全部必要的过程细节，并给予清晰的表达，使之成为编码的依据。</span></p> 
 <p><span lang="en-us">Ø         程序设计不同于编码或编程。<b><u>设计不是编码，编码也不是设计</u>。</b></span></p> 
 <p><span lang="en-us">Ø         任何设计模型的抽象级别都比源代码要高，在编码阶段做的唯一设计决策就是<u>描述如何将过程设计转换为程序代码的小的实现细节</u>。相当于将一段汉语精确译成英语的过程。</span></p> 
 <p><span lang="en-us">Ø         程序设计要决定软件各个模块的实现算法，并精确地表达这些算法。</span></p> 
 <p>各个模块的算法涉及到软件的功能和算法的设计，精确表达这些算法涉及到算法的描述和表达工具。</p> 
 <p><b>四、结构化程序设计</b><b></b></p> 
 <p>为了有效地进行程序设计，不仅要掌握一门程序设计语言，还应该学会针对各类问题拟定出有效的解题方法和步骤——即算法设计。有了正确的算法，才能够编制程序。算法的好坏，决定了程序的优劣，因此，程序设计的核心任务之一就是设计算法。<b></b></p> 
 <p><b><span lang="en-us">（一）  </span></b><b>什么是算法？</b></p> 
 <p><b><span lang="en-us">1</span></b>算 法－程序的灵魂</p> 
 <p><span lang="en-us">Ø         <span lang="en-us"> </span>广义地讲<span lang="en-us">--</span>算法是为完成一项任务所应当遵照的一步一步的规则的、精确的、无歧义的描述，它的总步数是有限的。</span></p> 
 <p><span lang="en-us">Ø         狭义地讲<span lang="en-us">-- </span>算法是解决一个问题采取的方法和步骤的描述。</span></p> 
 <p>简单地说，算法就是解决问题的办法，是对特定问题求解步骤的详细描述。所谓计算机能执行是指一个算法能不断地被细化，最终能用计算机所能识别的命令来表达，进而被执行。所以，从计算机应用的角度来说，算法是用于求解某个特定问题的一些指令的集合。具体地说，我们用计算机所能实现的操作或指令，来描述问题的求解过程，（编码）我们就得到了这一特定问题的计算机算法。</p> 
 <p><span lang="en-us">Ø         算法解决的是<span lang="en-us">“</span>做什么<span lang="en-us">”</span>和<span lang="en-us">“</span>怎么做<span lang="en-us">”</span>的问题</span></p> 
 <p><span lang="en-us">Ø         算法是灵魂，数据结构是加工对象 ，语言是工具</span></p> 
 <p><span lang="en-us">Ø         计算机算法设计：设计出计算机解决具体问题的详细步骤，并且将全部的解题过程用某种计算机工具完整地描述出来。</span></p> 
 <p>随着应用问题求解的目标不同以及解决具体应用问题的基本思路的不同，算法设计的思路也不同，即算法设计的基本方法不同。</p> 
 <p><span lang="en-us">Ø         算法的分类：数值算法和非数值算法</span></p> 
 <p>数值算法解决的是数值计算问题，包括方程和方程组的求解，微分积分的计算等；</p> 
 <p>非数值算法解决的是计算机或日常生活中的信息调度和管理问题，包括信息的组织与管理、信息优选等。</p> 
 <p><span lang="en-us">Ø         程序<span lang="en-us">=</span>算法<span lang="en-us">+</span>数据结构</span></p> 
 <p>我们利用计算机解决各种问题，算法是至关重要的。没有算法或没有计算机算法，我们对要解决的问题就无从下手。</p> 
 <p>　　计算机解决问题不但要依赖于算法，而且会涉及到大批数据。数据的组织和存储会直接影响算法的实现方式和效率。</p> 
 <p>　　人们在处理复杂问题时，总要利用抽象这个思维工具。抽象是抓住问题的实质，而忽略问题的次要部分；注意事物的普遍规律，或共性的东西。</p> 
 <p>　　算法和数据结构是人们用计算机解题时所作的两种抽象：算法是从计算机的操作角度对解题过程的抽象；数据结构是从如何组织处理操作对象的角度进行的抽象。这两种抽象互相依赖、互相补充，最大限度地减低问题的复杂性。</p> 
 <p>　　在这两个方面的基础上，人们开发出运行效率较高的各种应用程序。因此，在—定意义上，人们认为：程序<span lang="en-us">=</span>算法<span lang="en-us">+</span>数据结构</p> 
 <p><span lang="en-us">Ø         程序设计<span lang="en-us">=</span>算法<span lang="en-us">+</span>数据结构<span lang="en-us">+</span>程序设计方法<span lang="en-us">+</span>程序设计开发工具</span></p> 
 <p>除了算法和数据结构之外，程序设计方法对程序设计也是重要的，它影响到程序设计的成败及程序设计质量。随着计算机解决的问题越来越复杂，计算机本身的运算速度越来越快，内存容量也越来越大，程序设计已决不是程序员个人技巧的“手工艺品”。程序设计要遵循一定的开发方法及思想，如结构化设计方法，模块化程序设计方法、自顶向下的逐步细化的方法、面向对象的程序设计方法等，要按照工程管理的方法去进行软件开发，即用软件工程的思想及方法去进行软件开发。所以可以进一步说：程序设计<span lang="en-us">=</span>算法<span lang="en-us">+</span>数据结构<span lang="en-us">+</span>程序设计方法<span lang="en-us">+</span>程序设计开发工具</p> 
 <p><b>（二）为什么程序需要控制？</b></p> 
 <p><span lang="en-us">Ø         有非常明确的预期，顺序的拟订步骤</span></p> 
 <p>生活中我们如果对整个事情的处理过程有非常明确的预期没有任何意外发生的话，就不需要任何判断，我们可以分为几个顺序的拟订步骤依次完成而达到目标。</p> 
 <p><span lang="en-us">Ø         如果没有确定的目标，需要给出判断条件来控制计算机去执行确定的任务，这就是为什么计算机有分枝的理由。</span></p> 
 <p>如果没有确定的目标，我们可能就发生的情况作出下一步行动的判断，如乘公共汽车到火车站，不知道公共汽车在哪里，到一个路口没找到，会到另一个路口找。</p> 
 <p>作为计算机在处理复杂而变化的问题时，由于它不能自己判断随即发生的情况而修改自己的行为，它只是按照人事先作出严谨的设计，给出判断条件来控制计算机去执行确定的任务，这就是为什么计算机有分枝的理由。分支就是就需要编程者事先估计到各种可能性的发生，让程序接下来有什么样的走向和选择，要求程序员要料事如神而不是程序料事如神，所以程序设计人员需要严谨的素质。</p> 
 <p><span lang="en-us">Ø         计算机擅长的是逻辑推理和计算，我们很多问题需要反反复复的重复工作才能解决，枯燥而浪费时间，计算机却能以极高的速度把人们从繁重的脑力劳动中解放出来。</span></p> 
 <p>无论是选择运行还是重复运行，都需要设计程序者实现对程序步骤进行判断控制，</p> 
 <p align="left">在结构化设计方法之前，这种控制流的转向是任意性的，用传统流程图表示（<span lang="en-us">p23</span>，图<span lang="en-us"> 2.13</span>）这种算法称为<span lang="en-us">BS</span>型算法</p> 
 <p><span lang="en-us"> </span></p> 
 <p><span lang="en-us"> </span></p> 
 <p>在程序语言中是用<span lang="en-us">GOTO</span>语句实现控制路径，</p> 
 <p>转向的任意性使得<span lang="en-us">GOTO</span>语句泛滥使用，程序路径复杂而混乱，难以理解算法的逻辑。</p> 
 <p>为了从程序的控制结构入手消除不适应的容易混乱的<span lang="en-us">GOTO</span>语句。</p> 
 <p><span lang="en-us">1965</span>年<span lang="en-us">E.W.Dijkstra</span>在一次会议上提出应该把<span lang="en-us">GOTO</span>语句从高级语言中去掉，</p> 
 <p><span lang="en-us">1966</span>年，<span lang="en-us">Bohra</span>和<span lang="en-us">jacopini</span>证明了任何单入口单出口没有死循环的程序都可以由三种基本的控制结构构造出来。这三种基本结构就是（<span lang="en-us">1</span>）顺序就构（<span lang="en-us">2</span>）选择结构（包括单选择<span lang="en-us">if…else</span>型和多选择<span lang="en-us">case</span>型）<span lang="en-us"> (3)</span>重复结构（包括当型<span lang="en-us">while ..do</span>型和直到型<span lang="en-us">do..while</span>型），使用这三种控制结构的程序叫结构化程序。</p> 
 <p><b>（三）、算法的描述</b></p> 
 <p>图形工具、表格工具、语言工具等<span lang="en-us">3</span>类</p> 
 <p><span lang="en-us">Ø         图形工具包括：程序流程图、<span lang="en-us">NS</span>图、<span lang="en-us">PAD</span>图、<span lang="en-us">HIPO</span>图（<span lang="en-us">Hierarchy plus input process output</span>）等</span></p> 
 <p><span lang="en-us">Ø         表格工具：判定表</span></p> 
 <p><span lang="en-us">Ø         语言工具：<span lang="en-us">PDL</span>（<span lang="en-us">program design language</span>）伪码、自然语言</span></p> 
 <p><span lang="en-us">1</span>、程序流程图</p> 
 <p>程序流程图描述程序中，控制流的情况，即程序中处理（指令）的执行顺序和执行序列所依赖的条件，有向线段（流线）表示的是控制流，从一个处理走到另一个处理。</p> 
 <p>程序流程图比较适合于汇编语言的编程。</p> 
 <p><b><u>流程图描述非结构化程序（传统程序流程图）</u></b></p> 
 <p>流程图独立于程序设计语言，直观、清晰、易于学习，但也有一些缺点，表示程序控制流程的箭头可以不受约束随意转移控制。</p> 
 <p>流程图中的符号（见幻灯片）</p> 
 <p><b><u>流程图描述结构化程序（结构化程序流程图）</u></b></p> 
 <p>为使流程图描述结构化程序，只使用以下五种控制结构。见幻灯片，举例从<span lang="en-us">10</span>个数中选出最大的数见幻灯片</p> 
 <p><span lang="en-us">2</span>、<span lang="en-us">N-S</span>图（盒图）</p> 
 <p>美国学者<span lang="en-us">Nassi</span>和<span lang="en-us">Shneiderman</span>提出，结构见幻灯片图，举例从<span lang="en-us">10</span>个数中选择最大的数，见幻灯片。</p> 
 <p><span lang="en-us">3、  代码表示法</span></p> 
 <p align="left">伪代码是介于自然语言和计算机语言之间的文字和符号来表示算法。如同一篇文章，自上而下地写下来，每一行或几行表示一个基本操作。用伪代码<b></b></p> 
 <p><span lang="en-us"> </span></p> 
 <p>不用图形符号，一般计算机语言中具有语句关键词可用英文表示，其它可用汉语或英语表示，总之便于书写和阅读为原则，用伪代码写算法一般没有固定的严格的语法要求，只要意思表达清楚，这是目前常用的方式，特别是学会<span lang="en-us">c</span>语言后，可以适当按照<span lang="en-us">c</span>语言的语法规则先概略描述，然后逐步细化描述，时间长了，能够训练自己达到“<span lang="en-us">Thinking in C</span>”的思维能力。</p> 
 <p align="left"><span lang="en-us">4</span>、计算机语言表示算法</p> 
 <p align="left">即程序编写（编码），已经不是<span lang="en-us">“</span>设计<span lang="en-us">”</span>的范围，而是实现的阶段，要严格遵循使用的计算机语言的语法规则，如用<span lang="en-us">C</span>语言编写程序要遵循<span lang="en-us">C</span>语言的语法规则，这些规则正是本课程的学习内容。</p> 
 <p><b>算法的描述方法综述（见幻灯片）</b><b></b></p> 
 <p><b><span lang="en-us"> </span></b></p> 
 <p><b>（四）、结构化程序设计</b></p> 
 <p></p> 
 <p align="left"><b><span lang="en-us">1</span></b><b>、结构化程序设计主要包括两方面：</b></p> 
 <p><span lang="en-us">(1) </span>在编写程序时，强调使用几种基本控制结构，通过组合嵌套，形成程序的控制结构。尽可能避免使用<span lang="en-us">GOTO</span>语句。</p> 
 <p><span lang="en-us">(2) </span>在程序设计过程中，尽量采用自顶向下和逐步细化的原则，由粗到细，一步步展开。</p> 
 <p>表现在详细设计和编码阶段，应当采取自顶向下、逐步求精的方法，把一个模块的功能逐步分解，细化为一系列具体的步骤，进而翻译成一系列用程序语言写成的程序。</p> 
 <p><u>对“自顶向下和逐步细化的原则，由粗到细，一步步展开”的理解</u><u></u></p> 
 <p align="left">对于程序的描述而言（无论是前面给出的日常生活实例中的非形式的“程序”，还是希</p> 
 <p align="left">望计算机去执行的程序），还有几个重要的问题值得提出：</p> 
 <p align="left">可以写在程序里的基本“指令”包括哪些？洗脸、查书目等是前面日常生活中的“程序”</p> 
 <p align="left">里的基本动作。在编写需要计算机去执行的程序时，其中的基本动作应该是计算机能完成的</p> 
 <p align="left">事项。例如，要写前面那样的二进制代码形式的程序，就需要按照具体计算机指令系统的规</p> 
 <p align="left">定写出一条条指令。用一种高级语言写程序时，同样必须基于这种语言所支持的基本功能（基</p> 
 <p align="left">本命令等等）。学习用高级语言写程序，一个最基本的方面就是了解语言所提供的基本功能，</p> 
 <p align="left">了解它们的描述形式和所完成的操作效果。</p> 
 <p align="left">对于描述程序的语言有什么要求？描述前面有关日常生活的“程序”时采用的是汉语，</p> 
 <p align="left">是我们日常用于人际交流的“自然语言”。自然语言词汇丰富，有极强的表达能力。但在许</p> 
 <p align="left">多地方要依赖于接受者的知识和常识。如果，要求孔子按照前面给出的程序到图书馆去借书，他不可能理解其中的动作，也无法执行它去把书借来。自然语言的描述常常很不精确，许多</p> 
 <p align="left">疏漏需要靠接受者用自己的知识去填补。这种情况可以大大提高信息的传递效率，但也带来</p> 
 <p align="left">误解的可能性。送给计算机使用的程序必须采用计算机能处理的记法形式，其描述工具（语</p> 
 <p align="left">言）必须是精确的，无歧义的。程序设计语言都必须满足这些要求。</p> 
 <p align="left"><b>一个程序可能在不同的层次上描述</b>。看看有关刷牙的例子。前面只用一个词描述这一动作。但如果仔细想想，刷牙也是一个很复杂的过程。例如，我们还可以进一步将其分解描述为取杯子、装水、取牙刷、挤牙膏、漱口、刷牙、清洗牙齿等一系列细节动作。还可以进一步将这一层面上的每个动作分解为一系列的肌肉伸缩动作。</p> 
 <p align="left">应当将程序的细节分解到哪个层次，<b>一方面要看程序语言所提供的基本功能</b>。<b>此外，程序的描述方式也要照顾到人的需要。</b>复杂的程序可能需要成千上万，甚至成百万或千万行高级语言代码。简单地在高级语言基本层面上描述程序同样会显得层次太低，使程序的意义难以把握，难以保证它能实现所预想功能，难以修改程序去满足新的需要，如此等等。因此，在开发复杂的程序时，我们需要提供更高的描述层次，将程序的功能在各个层次上分解描述。就像我们看到极长的一系列有关肌肉伸缩动作的描述，很难理解这里所做的是刷牙一样。随着程序变得越来越复杂，其组织结构问题也变得更加重要了。</p> 
 <p align="left">还是用一个生活中的例子来说明问题。对于学生早上起床后的活动，首先应该在很高的</p> 
 <p align="left">层次上描述，就像前面所给出的：</p> 
 <p align="left"><span lang="en-us">1</span>，起床；</p> 
 <p align="left"><span lang="en-us">2</span>，刷牙；</p> 
 <p align="left"><span lang="en-us">3</span>，洗脸；</p> 
 <p align="left"><span lang="en-us">4</span>，吃饭；</p> 
 <p align="left"><span lang="en-us">5</span>，早自习；</p> 
 <p align="left">这样就把一个复杂的程序分解成为若干相对简单一些的部分了。如果需要进一步细节化，那么我们就降到下一个细节层次，将一个高层动作分解为一系列低层的基本动作。例如，可能将“吃早饭”这一高层动作分解为下面动作序列：</p> 
 <p align="left"> </p> 
 <table cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td> 
     <div> 
      <p align="center">早起活动</p> 
     </div></td></tr></tbody></table> 
 <table cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td> 
     <div> 
      <p align="center">起床</p> 
     </div></td></tr></tbody></table> 
 <table cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td> 
     <div> 
      <p align="center">吃早饭</p> 
     </div></td></tr></tbody></table> 
 <table cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td> 
     <div> 
      <p align="center">洗脸</p> 
     </div></td></tr></tbody></table> 
 <table cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td> 
     <div> 
      <p align="center">刷牙</p> 
     </div></td></tr></tbody></table> 
 <table cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td> 
     <div> 
      <p align="center">早读</p> 
     </div></td></tr></tbody></table> 
 拿饭碗； 
 <p align="left">去食堂；</p> 
 <p align="left">排队买饭；</p> 
 <p align="left">吃饭；</p> 
 <p align="left">刷碗；</p> 
 <p align="left">离开食堂；</p> 
 <p align="left">必要时再做进一步分解。例如，将“排队买饭”分解为“排队、选饭、选菜、付款”等。在这种分解描述的过程中，我们还应该保留前面构造出的抽象描述的层次。这种层次结构不但有利于人们理解程序的细节过程，也有利于发现程序中的错误，还能使所得程序易于根据需要去修改。例如，学校的食堂改为快餐份饭，由于整个程序被按照分解为一些具有逻辑独立性的部分，修改起来也就更容易了。</p> 
 <p align="left">编程序时所需要掌握的恰恰就是这种工作方式。我们需要从问题的要求出发，从高层开</p> 
 <p align="left">始设计程序，并逐步分解程序功能。当将程序所需功能分解到一定的细节程度之后，就可以</p> 
 <p align="left">借助于程序语言的结构，描述程序工作中的细节步骤了。本书将不断讨论这方面的问题。在</p> 
 <p>学习程序设计的过程中，也必须学习分析和构造程序的正确方法。</p> 
 <p>具体的计算机程序细化举例见幻灯片</p> 
 <p align="left"><b><span lang="en-us">2</span></b><b>、结构化程序设计的主要原则</b></p> 
 <p align="left"><span lang="en-us">n         使用语言中的顺序、选择、重复等有限的基本控制结构表示程序逻辑。</span></p> 
 <p><span lang="en-us">n         选用的控制结构只准许有一个入口和一个出口。</span></p> 
 <p><span lang="en-us">n         程序语句组成容易识别的块，每块只有一个入口和一个出口。</span></p> 
 <p><span lang="en-us">n         复杂结构应该用基本控制结构进行组合嵌套来实现。</span></p> 
 <p align="left"><span lang="en-us">n         语言中没有的控制结构，可用一段等价的程序段模拟，但要求该程序段在整个系统中应前后一致。</span></p> 
 <p><span lang="en-us">n         严格控制<span lang="en-us">GOTO</span>语句，仅在下列情形才可使用：<span lang="en-us"><br></span>① 用一个非结构化的程序设计语言去实现一个结构化的构造。<span lang="en-us"><br></span>② 若不使用<span lang="en-us">GOTO</span>语句就会使程序功能模糊。<span lang="en-us"><br></span>③ 在某种可以改善而不是损害程序可读性的情况下</span></p> 
 <p><b>五、软件设计的原则</b><b></b></p> 
 <p><span lang="en-us">1</span>抽象化</p> 
 <p>在进行模块设计的时候可以有不同的抽象层次</p> 
 <p>（<span lang="en-us">1</span>）过程抽象</p> 
 <p>从系统定义到实现，每进展一步都可以看作对软件解决方案的抽象化过程的一次细化。在软件需求分析阶段，“问题所处环境为大家所熟悉的术语”来描述软件解决方法，然后到概要设计、详细设计，抽象层次逐步降低。</p> 
 <p>（<span lang="en-us">2</span>）数据抽象</p> 
 <p>与过程抽象一样可以在不同层次上描述数据对象的细节。</p> 
 <p>（<span lang="en-us">3</span>）控制抽象</p> 
 <p>控制抽象可以包含一个<b>程序控制机制</b>而无需规定内部细节，如操作系统中，采用同步信号的方式协调某些活动。</p> 
 <p><span lang="en-us">2</span>、自顶向下，逐步细化</p> 
 <p>这是<span lang="en-us">Niklaus Wirth</span>提出的设计策略，将软件体系结构按自顶向下的方式，对各个层次的过程细节和数据细节逐层细化，直到用程序设计语言的语句能够实现为止。</p> 
 <p><span lang="en-us">3</span>、模块化</p> 
 <p>软件系统的层次结构正是模块化的具体体现。就是说，整个软件被划分为若干单独命名和可编址的部分，成为模块。</p> 
 <p>对于一个大问题总体复杂，把它分解成为一些独立的小问题易于处理。但当模块数增加，模块间的联系就会加大。把模块连接起来的工作量就会加大，要寻找平衡。</p> 
 <p><span lang="en-us">4</span>、控制层次（程序结构）</p> 
 <p>往往用程序的层次结构来表示，位于最上层是顶层模块是主模块，下面的是下属模块，一层层分下去。</p> 
 <p><b>程序结构的深度</b>：程序结构的层次数，反映了程序结构的规模和复杂程度</p> 
 <p><b>程序结构的宽度</b>：同一层模块的最大模块个数</p> 
 <p><b>模块的扇入和扇出</b>：扇出表示一个模块直接调用其它模块的数目，扇入是一个给定模块有模块来调用它，多扇入的模块一般设计成公用模块。</p> 
 <p><span lang="en-us">5</span>、结构划分</p> 
 <p>程序结构可以按照水平方向或垂直方向进行划分。</p> 
 <p>水平方向划分按照主要的程序功能来定义模块结构的各个分支。<b>顶层模块</b>（<span lang="en-us">M</span>）作为控制模块，控制协调下面的功能模块之间的通信和运行，下级模块（<span lang="en-us">A</span>、<span lang="en-us">B</span>、<span lang="en-us">C</span>）简单的功能划分是建立：输入－》处理（数据变换）－》输出。</p> 
 <p><span lang="en-us">6</span>、数据结构</p> 
 <p>数据结构是数据之间逻辑关系的一种表示，数据结构设计应确定数据的组织、存取方式、信息的不同处理方法。数据结构的组织方式和复杂程度灵活多样，但典型的数据结构种类是有限的，它们是构成那些更复杂结构的基本构件。</p> 
 <p>（<span lang="en-us">1</span>）标量：最简单的一种数据结构，标量项就是单个的数据元素，入布尔量、整数、实数或字符串。可以通过名字对它们进行存储。</p> 
 <p>（<span lang="en-us">2</span>）顺序向量（一维数组）：若干个标量项组织成一个表或者连接成一个组，可以扩展为二维、三维、四维<span lang="en-us">…..n</span>维</p> 
 <p>（<span lang="en-us">3</span>）链表：是一种更灵活的数据结构，它把物理上不相邻的标量项、向量、或空间结构用指针链接起来。</p> 
 <p><span lang="en-us">(4)</span>组合数据结构：把上述的标量项、向量或<span lang="en-us">n</span>维空间可以构造结构体数据，也可以把各种数据结构用多重链表建立分层结构和网络结构。</p> 
 <p><span lang="en-us">7</span>、软件过程</p> 
 <p><span lang="en-us">Ø         就是模块内的详细设计过程，</span></p> 
 <p>程序结构描述了程序的控制层次关系，和各个部分的接口情况，这里着重描述各个模块的处理细节。</p> 
 <p><span lang="en-us">Ø         它也是层次化的。</span></p> 
 <p><span lang="en-us">8</span>、信息隐藏<b></b></p> 
 <p>如何分解一个软件才能得到最佳的模块组合，？需要了解信息隐藏。是指，每个模块的实现细节对于其它模块来说是隐藏的。所以有效的模块化是通过独立的模块来实现，就是模块之间数据上功能上没有太大的联系，衡量独立性的标准是模块间的耦合和内聚。</p> 
</div> 
<p>转载于:https://www.cnblogs.com/hanshap/archive/2006/01/19/SoftwareDevelopment.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dc0fb8ddbe3c205dfd1af0a6e446bc8a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GDB十分钟教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3f280690970023721194095e38adbdb4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux文件的安全与权限</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>