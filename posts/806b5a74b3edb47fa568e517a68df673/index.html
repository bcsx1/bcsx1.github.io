<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>蓝桥杯——2020第十一届C/C&#43;&#43;真题[省赛][B组] - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="蓝桥杯——2020第十一届C/C&#43;&#43;真题[省赛][B组]" />
<meta property="og:description" content="目录
门牌制作
既约分数
蛇形填数
七段码
跑步锻炼
回文日期
字串排序​
成绩统计
子串分值和
平面切分
门牌制作 思路:很简单,枚举每个数的每一位,看是否等于2，等于则&#43;&#43;；
代码
#include&lt;iostream&gt; using namespace std; int co; void check(int k) { while (k &gt; 0) { int m = k % 10; k /= 10; if (m == 2) { co&#43;&#43;; } } } int main() { for (int i = 1; i &lt;= 2020; i&#43;&#43;) { check(i); } cout &lt;&lt; co &lt;&lt; endl; return 0; } 答案:624 既约分数 思路: 这题就是考最大公约数,不过要细心,求出来最大公约数后,要*2,因为分子和分母可以互换,又是不同的情况,还有1/1,2/2,3/3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/806b5a74b3edb47fa568e517a68df673/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-02T17:17:49+08:00" />
<meta property="article:modified_time" content="2022-04-02T17:17:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">蓝桥杯——2020第十一届C/C&#43;&#43;真题[省赛][B组]</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E9%97%A8%E7%89%8C%E5%88%B6%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E9%97%A8%E7%89%8C%E5%88%B6%E4%BD%9C" rel="nofollow">门牌制作</a></p> 
<p id="%E6%97%A2%E7%BA%A6%E5%88%86%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E6%97%A2%E7%BA%A6%E5%88%86%E6%95%B0" rel="nofollow">既约分数</a></p> 
<p id="%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0" rel="nofollow">蛇形填数</a></p> 
<p id="%E4%B8%83%E6%AE%B5%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E6%AE%B5%E7%A0%81" rel="nofollow">七段码</a></p> 
<p id="%E8%B7%91%E6%AD%A5%E9%94%BB%E7%82%BC-toc" style="margin-left:0px;"><a href="#%E8%B7%91%E6%AD%A5%E9%94%BB%E7%82%BC" rel="nofollow">跑步锻炼</a></p> 
<p id="%C2%A0%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F" rel="nofollow"> 回文日期</a></p> 
<p id="%E5%AD%97%E4%B8%B2%E6%8E%92%E5%BA%8F%E2%80%8B-toc" style="margin-left:0px;"><a href="#%E5%AD%97%E4%B8%B2%E6%8E%92%E5%BA%8F%E2%80%8B" rel="nofollow">字串排序​</a></p> 
<p id="%E6%88%90%E7%BB%A9%E7%BB%9F%E8%AE%A1-toc" style="margin-left:0px;"><a href="#%E6%88%90%E7%BB%A9%E7%BB%9F%E8%AE%A1" rel="nofollow">成绩统计</a></p> 
<p id="%E5%AD%90%E4%B8%B2%E5%88%86%E5%80%BC%E5%92%8C-toc" style="margin-left:0px;"><a href="#%E5%AD%90%E4%B8%B2%E5%88%86%E5%80%BC%E5%92%8C" rel="nofollow">子串分值和</a></p> 
<p id="%E5%B9%B3%E9%9D%A2%E5%88%87%E5%88%86-toc" style="margin-left:0px;"><a href="#%E5%B9%B3%E9%9D%A2%E5%88%87%E5%88%86" rel="nofollow">平面切分</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E9%97%A8%E7%89%8C%E5%88%B6%E4%BD%9C"><a class="link-info" href="http://oj.ecustacm.cn/problem.php?id=1508" rel="nofollow" title="门牌制作">门牌制作</a></h2> 
<p><img alt="" height="463" src="https://images2.imgbox.com/65/71/I5ZLbyq2_o.png" width="1200"></p> 
<p>思路:很简单,枚举每个数的每一位,看是否等于2，等于则++；</p> 
<p>代码</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int co;
void check(int k)
{
	while (k &gt; 0)
	{
		int m = k % 10;
		k /= 10;
		if (m == 2)
		{
			co++;
		}
	}
}
int main()
{
	for (int i = 1; i &lt;= 2020; i++)
	{
		check(i);
	}
	cout &lt;&lt; co &lt;&lt; endl;
	return 0;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>答案:624 </strong></span></p> 
<h2 id="%E6%97%A2%E7%BA%A6%E5%88%86%E6%95%B0"><strong><span style="color:#0d0016;"><a class="link-info" href="http://oj.ecustacm.cn/problem.php?id=1509" rel="nofollow" title="既约分数">既约分数</a></span></strong></h2> 
<p><img alt="" height="430" src="https://images2.imgbox.com/67/4d/DXAtNex4_o.png" width="1200"></p> 
<p>思路: 这题就是考最大公约数,不过要细心,求出来最大公约数后,要*2,因为分子和分母可以互换,又是不同的情况,还有1/1,2/2,3/3....这样的要算为一种情况,所以求出来结果还要+1.</p> 
<p>代码</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int ants;
int gcd(int a, int b)
{
	/*return b ? gcd(b, a % b) : a;*/
	if (a%b == 0)return b;
	return gcd(b, a % b);
}
int main()
{
	for (int i = 1; i &lt;= 2020; i++)
	{
		for (int j = i+1; j &lt;= 2020; j++)
		{
			if (gcd(i, j) == 1)
			{
				ants++;
			}
			
		}
	}
	int sum = ants * 2 + 1;
	cout &lt;&lt;sum &lt;&lt; endl;
	return 0;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong> 答案:2481215</strong></span></p> 
<h2 id="%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0"><strong><span style="color:#0d0016;"><a class="link-info" href="http://oj.ecustacm.cn/problem.php?id=1510" rel="nofollow" title="蛇形填数">蛇形填数</a></span></strong></h2> 
<p><img alt="" height="590" src="https://images2.imgbox.com/82/2f/rRzyETeP_o.png" width="1200"></p> 
<p> 思路:这样的题就是找规律,对代码要求不高,多写几个就找出来了</p> 
<p><img alt="" height="343" src="https://images2.imgbox.com/79/02/9jBnEahe_o.png" width="719"></p> 
<p>代码:</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
	int n = 20, sum = 1;
	for (int i = 0; i &lt;n; i++)
	{
		sum += i * 4;
	}
	cout &lt;&lt; sum &lt;&lt; endl;
	return 0;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>答案:761 </strong></span></p> 
<h2 id="%E4%B8%83%E6%AE%B5%E7%A0%81"><strong><span style="color:#0d0016;"><a class="link-info" href="http://oj.ecustacm.cn/problem.php?id=1511" rel="nofollow" title="七段码">七段码</a></span></strong></h2> 
<p><img alt="" height="832" src="https://images2.imgbox.com/c4/a9/K6GTgSyd_o.png" width="1200"></p> 
<p>思路: <a href="https://so.csdn.net/so/search?q=dfs&amp;spm=1001.2101.3001.7020" title="DFS">DFS</a>搜索所有状态，判断每种状态可不可行。判断的方法是把每条灯管当作一个节点，编号，连边建图，对搜索出的亮灯方案使用并查集判断点亮的灯管是否在同一个集合。</p> 
<p>推荐一篇并查集的文章:<a href="https://zhuanlan.zhihu.com/p/93647900/" rel="nofollow" title="算法学习笔记(1) : 并查集 - 知乎">算法学习笔记(1) : 并查集 - 知乎</a></p> 
<p> 代码:</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

const int MAXN = 25;
int n = 7, ans = 0, path[MAXN], f[MAXN][MAXN], father[MAXN];

//查找 x 的祖先节点
int find(int x)
{
    if (x != father[x]) { //路径压缩
        return father[x] = find(father[x]);
    }
    return father[x];
}

void dfs(int u, int p, int m)
{
    if (u == m) {
        //初始化操作
        for (int i = 1; i &lt; MAXN; ++i) {
            father[i] = i;
        }
        //集合合并
        for (int i = 0; i &lt; m; ++i) {
            for (int j = i + 1; j &lt; m; ++j) {
                //存在边相连
                if (f[path[i]][path[j]] == 1) {
                    //path[i] 和 path[j] 合并成一个集合
                    father[find(path[i])] = find(father[path[j]]);
                }
            }
        }
        //查找最终是否为一个集合
        bool flag = false;
        for (int i = 0; i &lt; m - 1; ++i) {
            if (find(path[i]) != find(path[i + 1])) {
                flag = true;
                break;
            }
        }

        if (!flag) {
            ++ans;
        }
        return ;
    }
    for (int i = p; i &lt;= n; ++i) {
        path[u] = i;
        dfs(u + 1, i + 1, m);
    }
}

int main()
{
    memset(f, 0, sizeof(f));
    f[1][2] = f[2][1] = 1;
    f[1][6] = f[6][1] = 1;
    f[2][7] = f[7][2] = 1;
    f[6][7] = f[7][6] = 1;
    f[7][3] = f[3][7] = 1;
    f[7][5] = f[5][7] = 1;
    f[2][3] = f[3][2] = 1;
    f[3][4] = f[4][3] = 1;
    f[4][5] = f[5][4] = 1;
    f[5][6] = f[6][5] = 1;
    for (int i = 1; i &lt;= n; ++i) {
        dfs(0, 1, i);
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>答案:80 </strong></span></p> 
<h2 id="%E8%B7%91%E6%AD%A5%E9%94%BB%E7%82%BC"><strong><span style="color:#0d0016;"><a class="link-info" href="http://oj.ecustacm.cn/problem.php?id=1513" rel="nofollow" title="跑步锻炼">跑步锻炼</a></span></strong></h2> 
<p><img alt="" height="400" src="https://images2.imgbox.com/97/b5/kliuWvOV_o.png" width="1200"></p> 
<p>思路:经典的日期问题, 细心点写,注意瑞年的判断和每个月的月数,就没啥大问题。</p> 
<p>代码</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
//2000 1 1(星期六)-2020 10 1
/**/
int ants = 0;
int Month[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
int main()
{
	int year = 2000, month = 1, day = 1, weekday = 6;
	while (1)
	{
		ants += (weekday == 1 || day == 1) + 1;//判断是否是星期一或者是每个月月初
		if (year == 2020 &amp;&amp; month == 10 &amp;&amp; day == 1)//结束条件
		{
			break;
		}
		//星期循环，和天数增加
		day += 1;
		weekday = (weekday + 1) % 7;
		//判断是否是瑞年并且是二月份
		if (month == 2 &amp;&amp; (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0))
		{
			if (day &gt; Month[month] + 1)
			{
				day = 1;
				month += 1;
			}
		}
		else if (day &gt; Month[month])
		{
			day = 1;
			month += 1;
		}
		if (month == 13)
		{
			month = 1;
			year += 1;
		}

	}
	cout &lt;&lt; ants &lt;&lt; endl;
	return 0;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong> 答案:8879</strong></span></p> 
<h2 id="%C2%A0%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F"> <a class="link-info" href="http://oj.ecustacm.cn/problem.php?id=1518" rel="nofollow" title="回文日期">回文日期</a></h2> 
<p><img alt="" height="675" src="https://images2.imgbox.com/2c/4b/x3FQc3zw_o.png" width="1200"></p> 
<p> 输入样例</p> 
<pre><code class="language-cpp">2
20200202
20211203</code></pre> 
<p>输出样例</p> 
<pre><code class="language-cpp">20211202
21211212
20300302
21211212</code></pre> 
<p>思路: 这道题需要用字符串和数字之间的转换,然后判断一个日期是否是回文串,日期是否合法,在前面的基础上再判断是否是ABBABABA,对思维要求不高,基本都能想出来,就是代码量和操作有点繁琐.我们先练习下字符串和数字之间的来回转化，这个要掌握,竞赛中经常用到</p> 
<pre><code class="language-cpp">/*1.数字转换成字符串*/
	int num = 123;
	stringstream ss;
	ss &lt;&lt; num;
	string  s = ss.str();
	cout &lt;&lt; s &lt;&lt; endl;</code></pre> 
<pre><code class="language-cpp">    /*2.字符串转换成数字*/
	string s1 = "123";
	int num1 = atoi(s1.c_str());
     cout &lt;&lt; num1 &lt;&lt; endl;
	/*3.字符串转换成数字*/
	string s2 = "456";
	stringstream ss2;
	ss2 &lt;&lt; s2;
	int num2;
	ss2 &gt;&gt; num2;
	cout &lt;&lt; num2 &lt;&lt; endl;</code></pre> 
<p>代码</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;sstream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
/*如何判断一个日期是否是回文串
日期是否合法?
在1,2的基础上如何判断该日期是ABBA BABA型的回文日期?*/
//run[0]表示的是瑞年每个月的天数;run[1]表示的是非瑞年每个月的天数
int run[2][13] = { {0,31,29,31,30,31,30,31,31,30,31,30,31},{0,31,28,31,30,31,30,31,31,30,31,30,31} };
//2121 12 12      //长度为8
//0123 45 67下标  //if(s[1]!=s[6]) i=1,6=len-i--1;
bool fun(string s)//判断是否为回文日期
{
	for (int i = 0; i &lt; s.length(); i++)
	{
		if (s[i] != s[s.length() - i - 1])return false;
	}
	//判断日期是否合法
	int y = (s[0] - '0') * 1000 + (s[1] - '0') * 100 + (s[2] - '0') * 10 + (s[3] - '0');
	int m = (s[4] - '0') * 10 + (s[5] - '0');
	int d = (s[6] - '0') * 10 + (s[7] - '0');
	if (m &gt; 12)return false;
	int f = (y % 4 == 0 &amp;&amp; y % 100 != 0) || (y % 400 == 0)?0:1;
	if (d &gt; run[f][m])return false;
	return true;
}
bool fun2(string s)//判断是否为ABAB BABA型的回文日期
{
//ABAB BABA型的字符串只有两个不同的元素———&gt;set,求不同元素的个数
	set&lt;char&gt; st;
	for (int i = 0; i &lt; s.length(); i++)
	{
		st.insert(s[i]);
	}
	if (st.size() != 2)return false;
	//只有两个不同元素的回文日期的情况;
	/*
	* 1.AABB BBAA
	* 2.ABAB BABA
	* 3.ABAA AABA
	* 4.ABBB BBBA
	* 要得到2
	*/
	if (s[0] == s[1] || s[2] == s[3])return false;//直接排除
	return true;

}
int main()
{
	string s;
	cin &gt;&gt; s;
	stringstream tmp;
	tmp &lt;&lt; s;
	long long num;
	tmp &gt;&gt; num;
	int f1 = 0;//表示没有找到回文日期
	int f2 = 0;//表示没有找到ABAB BABA型的回文日期
	for (long long i = num+1; i &lt;= 89991231; i++)
	{
		if (f1 == 1 &amp;&amp; f2 == 1)break;//表示已经得到最后的结果
		//把日期先转换成字符串
		stringstream t2;
		t2 &lt;&lt; i;
		string S = t2.str();
		if (fun(S) == false)continue;//不是回文日期，跳过该循环
		//确保了字符串S是回文日期
		if (f1 == 0)
		{
			cout &lt;&lt; S &lt;&lt; endl;
			f1 = 1;
		}
		if (fun2(S) == true)//ABABBABA型的回文日期
		{
			cout &lt;&lt; S &lt;&lt; endl;
			f2 = 1;
		}
	}
	return 0;
}
</code></pre> 
<h2 id="%E5%AD%97%E4%B8%B2%E6%8E%92%E5%BA%8F%E2%80%8B"><a class="link-info" href="http://oj.ecustacm.cn/problem.php?id=1521" rel="nofollow" title="字串排序">字串排序</a><img alt="" height="727" src="https://images2.imgbox.com/40/52/e6kGpTvI_o.png" width="1200"><br>  </h2> 
<p><img alt="" height="539" src="https://images2.imgbox.com/5f/0f/UNRGLFMc_o.png" width="1200"></p> 
<p><img alt="" height="781" src="https://images2.imgbox.com/f0/49/mFHDkdE8_o.png" width="1200"></p> 
<p> 思路:这道题看的我迷迷瞪瞪,我在网上找了很多参考答案,给大家推荐一篇博客:</p> 
<p><a href="https://blog.csdn.net/weixin_46216553/article/details/115215457" title="蓝桥杯“字串排序“题解_Nervous_46216553的博客-CSDN博客_蓝桥杯字串排序">蓝桥杯“字串排序“题解_Nervous_46216553的博客-CSDN博客_蓝桥杯字串排序</a></p> 
<p><img alt="" height="471" src="https://images2.imgbox.com/04/e0/pQzVqssU_o.png" width="1086"></p> 
<p>代码:</p> 
<pre><code class="language-cpp">import java.util.Scanner;
public class Main {
	static int list[]={//存放后缀序列，这样插和删除很容易
		0,0,0,0,0,//注cccbba=1,2,3,0,……
		0,0,0,0,0,
		0,0,0,0,0,
		0,0,0,0,0,
		0,0,0,0,0,
		0
	};
	static int[] str=new int[300];//存放前缀序列
	static void reset() {//后缀序列清零
		int i=0;
		while(i&lt;26&amp;&amp;list[i]!=0) {
			list[i]=0;
			++i;
		}
	}
	static int getrnum() {//计算逆序数（分三步）
		int cnt=0;
		for(int i=0;str[i]!=0;++i) {//前缀的逆序数
			for(int j=i;str[j]!=0;++j) {
				if(str[i]&gt;str[j]) {
					++cnt;
				}
			}
		}
		for(int i=0;str[i]!=0;++i) {//前缀对后缀的逆序数
			for(int j=25;j&gt;=0;--j) {
				if(str[i]-'a'&gt;j) {
					cnt+=list[j];
				}
			}
		}
		int temp=0;
		for(int i=0;i&lt;26;++i) {//后缀的逆序数
			cnt+=temp*list[i];
			temp+=list[i];
		}
		return cnt;
	}
	static int getinc(int c) {//获得最大逆序增量（特殊步骤中代替求逆序数函数用来提速）（可以认为在数字符串里有多少非c(传入的参数)字符）(也就是插入c逆序数能增加多少)
		int i=0,cnt=0;
		while(str[i]!=0) {
			if(str[i]&gt;(c+'a')) {
				cnt++;
			}
			++i;
		}
		for(i=0;i&lt;26;++i) {
			if(i!=c) {
				cnt+=list[i];
			}
		}
		return cnt;
	}
	static void set() {//在后部序列中插入元素，保证逆序数最大
		int max=0,temp=0,index=0;
		for(int i=0;i&lt;26;++i) {
			list[i]++;
			if((temp=getinc(i))&gt;max) {//找出使逆序数增得最快的字符插入（这里比用增而直接记录逆序数不影响结果，但慢一些，数据10000左右要5秒左右，会超时的，不然我也不会编这么个对于的函数。。）
				index=i;
				max=temp;
			}
			list[i]--;
		}
		list[index]++;
	}
	static void getMaxStr(int l) {//获取前缀确定且长度确定的前提下的最大逆序数字串
		reset();
		for(int i=0;str[i]!=0;++i,--l);
		while(l&gt;0) {
			set();
			--l;
		}
	}
	static void printstr() {//打印目标字符串
		String Str="";
		int i=0;
		while(str[i]!=0) {
			Str+=(char)str[i];
			++i;
		}
		for(i=25;i&gt;=0;--i) {//这里其实没用，既然不执行也不会影响效率，留着吧，后缀最后是空的，但曾经存在过。。。
			for(int j=0;j&lt;list[i];++j) {
				Str+=(char)(i+'a');
			}
		}
		System.out.println(Str);
	}
	static void getans(int num,int l) {//l是字串长度
		for(int i=0;i&lt;l;++i) {
			for(int j=0;j&lt;26;++j) {//每个位从a开始试
				str[i]=j+'a';
				getMaxStr(l);//获取指定前缀最大逆字串
				if(getrnum()&gt;=num) {//超了就下一个
					break;
				}
			}
		}
	}
	public static void main(String[] args){//这了很简洁了
		int num;
		Scanner sc = new Scanner(System.in);
		num=sc.nextInt();//获取输入
		sc.close();
		int l=0;
		while(getrnum()&lt;num) {//获取最短字串长
			++l;
			getMaxStr(l);
		}
		getans(num,l);//获得目标字串
		printstr();//打印
	}
}
</code></pre> 
<h2 id="%E6%88%90%E7%BB%A9%E7%BB%9F%E8%AE%A1"><a class="link-info" href="http://oj.ecustacm.cn/problem.php?id=1522" rel="nofollow" title="成绩统计">成绩统计</a></h2> 
<p><img alt="" height="666" src="https://images2.imgbox.com/8b/81/sovhITs1_o.png" width="1200"></p> 
<p><img alt="" height="516" src="https://images2.imgbox.com/b3/7b/33aSSYLj_o.png" width="1200"></p> 
<p>我严重怀疑这个网站给的题目顺序不对,前面编程题越做越吃劲,怎么越往后越容易</p> 
<p>代码</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int main()
{
    double a = 0;
    double b = 0;
    double c;
    cin &gt;&gt; c;
    int n;
    for (int i = 0; i &lt; c; i++)
    {
        cin &gt;&gt; n;
        if (n &gt;= 60)
        {
            a++;
        }
        if (n &gt;= 85)
        {
            b++;
        }
 
    }
    int x =(a * 100.0)/c+0.5;
    int y =(b * 100.0)/c+0.5;
    cout &lt;&lt; x &lt;&lt; "%" &lt;&lt; endl &lt;&lt; y &lt;&lt; "%";
    return 0;
}</code></pre> 
<h2 id="%E5%AD%90%E4%B8%B2%E5%88%86%E5%80%BC%E5%92%8C"><a class="link-info" href="http://oj.ecustacm.cn/problem.php?id=1523" rel="nofollow" title="子串分值和">子串分值和</a></h2> 
<p><img alt="" height="540" src="https://images2.imgbox.com/79/76/UvYuSS8K_o.png" width="1200"></p> 
<p><img alt="" height="316" src="https://images2.imgbox.com/e0/de/KDRW5kaD_o.png" width="1200"></p> 
<p> 代码</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
int num[26]; //某字母在字符串中上一次出现的位置
int main() {
    string s;
    cin &gt;&gt; s;//ababc
    int len = s.size();//5
    memset(num, -1, sizeof(num));//初始化为-1
    LL ans = 0;
    for (int i = 0; i &lt; len; ++i) {
        ans += (LL)(i - num[s[i] - 'a']) * (len - i);
        num[s[i] - 'a'] = i;
    }
    printf("%lld\n", ans);
    return 0;
}
</code></pre> 
<h2 id="%E5%B9%B3%E9%9D%A2%E5%88%87%E5%88%86"><a class="link-info" href="http://oj.ecustacm.cn/problem.php?id=1524" rel="nofollow" title="平面切分">平面切分</a></h2> 
<p><img alt="" height="619" src="https://images2.imgbox.com/74/46/uDQIyCyf_o.png" width="1200"></p> 
<p><img alt="" height="393" src="https://images2.imgbox.com/0a/41/wb8q9af0_o.png" width="1200"></p> 
<p>思路:推荐博客<a href="https://blog.csdn.net/fa2000_12_16/article/details/115747540" title="蓝桥杯:平面切分_fa2000_12_16的博客-CSDN博客_蓝桥杯平面切分">蓝桥杯:平面切分_fa2000_12_16的博客-CSDN博客_蓝桥杯平面切分</a></p> 
<p>代码</p> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1005;

int main()
{
	int n;
	scanf("%d", &amp;n);
	int a, b;
	long double A[N], B[N];
	pair&lt;long double, long double&gt; p; 
	set&lt;pair&lt;long double, long double&gt; &gt; s;  //利用set自动去重功能筛选掉重边 
	for(int i = 0; i &lt; n; i++)
	{
		scanf("%d %d", &amp;a, &amp;b);
		p.first = a;
		p.second = b;
		s.insert(p);
	}
	int i = 0;  //将去重后的直线数据放回A,B数组 
	for(set&lt;pair&lt;long double, long double&gt; &gt;::iterator it = s.begin(); it != s.end(); it++, i++)
	{
		A[i] = it -&gt; first;
		B[i] = it -&gt; second;
	}
	long long ans = 2;  //初始情况当只有一条直线时，有两个平面 
	for(int i = 1; i &lt; s.size(); i++)  //从下标1开始，也就是第二条直线 
	{
		set&lt;pair&lt;long double, long double&gt; &gt; pos;  //记录第i条直线与先前的交点 
		for(int j = i-1; j &gt;= 0; j--)
		{
			int a1 = A[i], b1 = B[i];
			int a2 = A[j], b2 = B[j];
			if(a1 == a2)  //遇到平行线无交点，跳出 
				continue; 
			p.first = 1.0*(b2-b1)/(a1-a2);
			p.second = 1.0*a1*((b2-b1)/(a1-a2)) + b1;
			pos.insert(p); 
		}
		ans += pos.size() + 1;  //根据结论，每增加一条直线，对平面数的贡献值是其与先前直线的交点数（不重合）+1 
	} 
	printf("%d\n", ans);
	return 0;
}
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/26a7459a32dda3b91a51cf44f616a934/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第六章 C&#43;&#43;运算符重载（operator）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/76a4dda6c022871506c59d8e4910e8c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Neural Network 3 课程笔记翻译</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>