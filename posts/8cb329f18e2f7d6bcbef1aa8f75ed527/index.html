<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>论文阅读：（ICLR 2021） MULTIPLICATIVE FILTER NETWORKS - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="论文阅读：（ICLR 2021） MULTIPLICATIVE FILTER NETWORKS" />
<meta property="og:description" content="论文阅读：ICLR 2021 MULTIPLICATIVE FILTER NETWORKS Code：https://github.com/boschresearch/multiplicative-filter-networks
Paper: https://openreview.net/forum?id=OmtmcPkkhT
其他参考资料：知乎：论文解读 | Multiplicative Filter Networks
首先对文章做个简单机翻，在最后再对文章进行分析。
将该该代码运行，并写一份代码讲解:代码讲解就不弄了，查看了一下代码还是比较简单的，只有四个py文件。主要内容是MFNbased,FourierNet和GaborNet,代码也没啥问题，环境装完就能跑。 这两天再精读一遍理论部分：图像表示部分发现只要把预测图像的尺寸调大一些，网络的性能就会急剧下降并且难以学习，对学习率还是比较敏感的····· Abstract 深度神经网络常用于高维输入上近似函数，但最近的工作探索了神经网络作为低维但复杂信号的函数逼近的作用，例如使用像素坐标表示图像，求解微分方程或者神经辐射场等。成功的原因在于最近的方法使用了Sin激活函数或者傅里叶特征超过了简单了ReLU网络。在本文中，提出并证实了一个更为简单的函数逼近方法同样可以解决此类问题：乘性滤波器网络（multiplicative filter networks）。在此类网络中，避免了合成深度问题，简单的将输入与正弦或者Gabor小波相乘。这种表示方法有个显著的优势，即整个函数可以简单看做是傅里叶级数或Gabor基函数的线性函数逼近。尽管方法简单，但是与最近使用的ReLU激活和Sin激活的傅里叶特征相比，本文的方法大大超过或者匹配这些方法的性能。
1.Introduction 近年来工作关注隐神经表示，用一个连续的图像可以用函数表示为 f : R 2 → R 3 f:\R^2 \rightarrow \R^3 f:R2→R3 ，其中输入是图像的坐标输出是图像的RGB值。最近的研究表示需要使用Sin激活函数（SIREN），或者使用随机傅里叶特征输入ReLU网络才能使MLP适合这项任务。这两篇论文都证明了其方法远优于简单的ReLU网络，并且对于复杂函数有较高的保真度。但使用SIn激活或者使用傅里叶特征作为输入的优势很难表示，或者说尚不清晰。
然而，在这篇论文中，我们论证并实证地证明了一个可论证的更简单的函数类可以在这项任务上与这些先前提出的网络一样好，甚至更好。具体来说，我们提出了一种称为乘法滤波器网络(MFN)的架构。与传统的通过组合深度获得表示能力的多层网络不同，MFN只是简单地对网络的输入重复应用非线性滤波器(如正弦或Gabor小波函数)，然后将这些特征的线性函数相乘。这种表示的显著优点是，由于傅里叶和Gabor滤波器的乘法特性，整个函数最终只是输入的这些傅里叶或Gabor特性的线性函数(一个指数)。事实上，我们可以表达这些MFNs的精确线性形式，这可以使它们的分析比深度网络的分析简单得多，深度网络的非线性激活的组合使整个函数难以描述。
在这项工作中，我们表明，尽管这种简单，提出的网络往往表现相同或更好，比先前提出的SIREN或傅里叶特征网络。具体地说，我们将我们的方法与在SIREN和傅里叶特征论文中提出的精确基准中可比较的参数数量的网络上的方法进行比较。我们表明，当增加网络的深度或宽度时，MFNs可以获得更好的性能增量。尽管如此，我们还是强调这一点，特别是，与MFN相比，SIREN网络似乎保留了一些显著的优势，例如在表示函数及其梯度中偏向于更平滑的区域。然而，特别是考虑到mfn最终只是对应于一个低维函数的线性傅里叶或小波表示，我们认为它们应该被视为未来研究此类问题的标准基准，以表明典型深度网络的组成深度在哪些地方可以提出实质性的好处。
2. Background and related work 我们的方法与以前在傅里叶和小波变换、随机傅里叶特征和隐式神经表征方面的许多工作有关。我们将探讨以下领域之间的联系。
2.1 傅里叶和小波变换 利用傅立叶变换和小波变换等变换将时间或空间域信号转换到频率域已经成为图像处理、信号处理和计算机视觉许多发展的核心。特别是傅里叶变换及其各种形式在无数的应用中发现了用途，如光谱学、量子力学、信号处理。小波变换在多尺度分析中特别有用，在数据压缩中被发现特别有用，JPEG2000就是一个例子。
2.2 随机傅里叶特征 Rahimi &amp; Recht(2008)的一项开创性工作展示了傅里叶变换在机器学习中的应用。他们表明，简单地将原始数据集投影到随机的傅里叶基中，可以极大地提高模型的表达能力，因为它近似于内核计算。许多后续的工作应用傅里叶特征和变化，以提高机器学习算法在许多领域的性能，包括分类，回归，聚类，在线学习。
2.3 隐式神经表示 最近的一项工作是用神经网络参数化的连续函数来表示信号(而不是使用传统的离散表示)，这一工作越来越受欢迎。这种策略被用于表示不同的对象，比如图像，形状，场景和纹理。在这些应用中，通常使用带有多层感知器和ReLU激活函数的标准神经网络架构。最近，受到傅立叶变换在机器学习中的成功的激励，一些论文提出了将周期性非线性集成到网络中的架构变化。Mildenhall等人(2020年);Zhong等(2020);Tancik等人(2020)提出使用输入特征的正弦映射(Rahimi &amp; Recht, 2008)，使用位置编码和高斯随机分布中的映射。其他(Klocek等人，2019;Sitzmann等人，2020年)提出在多层感知器架构中使用正弦激活函数。这两种策略都被证明可以极大地提高许多对象表示任务的结果。
3. 乘性滤波网络 一个K层的深度网络 f : R n → R m f:\R^n \rightarrow \R^m f:Rn→Rm可以由递归式定义如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8cb329f18e2f7d6bcbef1aa8f75ed527/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-05T18:35:26+08:00" />
<meta property="article:modified_time" content="2022-06-05T18:35:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">论文阅读：（ICLR 2021） MULTIPLICATIVE FILTER NETWORKS</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="ICLR_2021_MULTIPLICATIVE_FILTER_NETWORKS_0"></a>论文阅读：ICLR 2021 MULTIPLICATIVE FILTER NETWORKS</h2> 
<p>Code：<a href="https://github.com/boschresearch/multiplicative-filter-networks">https://github.com/boschresearch/multiplicative-filter-networks</a><br> Paper: <a href="https://openreview.net/forum?id=OmtmcPkkhT" rel="nofollow">https://openreview.net/forum?id=OmtmcPkkhT</a><br> 其他参考资料：<a href="https://zhuanlan.zhihu.com/p/468365821" rel="nofollow">知乎：论文解读 | Multiplicative Filter Networks</a></p> 
<p>首先对文章做个简单机翻，在最后再对文章进行分析。</p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 将该该代码运行，并写一份代码讲解:代码讲解就不弄了，查看了一下代码还是比较简单的，只有四个py文件。主要内容是MFNbased,FourierNet和GaborNet,代码也没啥问题，环境装完就能跑。</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 这两天再精读一遍理论部分：图像表示部分发现只要把预测图像的尺寸调大一些，网络的性能就会急剧下降并且难以学习，对学习率还是比较敏感的·····</li></ul> 
 
<h3><a id="Abstract_16"></a>Abstract</h3> 
<p>深度神经网络常用于高维输入上近似函数，但最近的工作探索了神经网络作为低维但复杂信号的函数逼近的作用，例如使用像素坐标表示图像，求解微分方程或者神经辐射场等。成功的原因在于最近的方法使用了Sin激活函数或者傅里叶特征超过了简单了ReLU网络。在本文中，提出并证实了一个更为简单的函数逼近方法同样可以解决此类问题：乘性滤波器网络（multiplicative filter networks）。在此类网络中，避免了合成深度问题，简单的将输入与正弦或者Gabor小波相乘。这种表示方法有个显著的优势，即整个函数可以简单看做是傅里叶级数或Gabor基函数的线性函数逼近。尽管方法简单，但是与最近使用的ReLU激活和Sin激活的傅里叶特征相比，本文的方法大大超过或者匹配这些方法的性能。</p> 
<h3><a id="1Introduction_20"></a>1.Introduction</h3> 
<p>近年来工作关注隐神经表示，用一个连续的图像可以用函数表示为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         : 
        
        
        
          R 
         
        
          2 
         
        
       
         → 
        
        
        
          R 
         
        
          3 
         
        
       
      
        f:\R^2 \rightarrow \R^3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span> ，其中输入是图像的坐标输出是图像的RGB值。最近的研究表示需要使用Sin激活函数（SIREN），或者使用随机傅里叶特征输入ReLU网络才能使MLP适合这项任务。这两篇论文都证明了其方法远优于简单的ReLU网络，并且对于复杂函数有较高的保真度。但使用SIn激活或者使用傅里叶特征作为输入的优势很难表示，或者说尚不清晰。</p> 
<p>然而，在这篇论文中，我们论证并实证地证明了一个可论证的更简单的函数类可以在这项任务上与这些先前提出的网络一样好，甚至更好。具体来说，我们提出了一种称为乘法滤波器网络(MFN)的架构。与传统的通过组合深度获得表示能力的多层网络不同，MFN只是简单地对网络的输入重复应用非线性滤波器(如正弦或Gabor小波函数)，然后将这些特征的线性函数相乘。这种表示的显著优点是，由于傅里叶和Gabor滤波器的乘法特性，整个函数最终只是输入的这些傅里叶或Gabor特性的线性函数(一个指数)。事实上，我们可以表达这些MFNs的精确线性形式，这可以使它们的分析比深度网络的分析简单得多，深度网络的非线性激活的组合使整个函数难以描述。</p> 
<p>在这项工作中，我们表明，尽管这种简单，提出的网络往往表现相同或更好，比先前提出的SIREN或傅里叶特征网络。具体地说，我们将我们的方法与在SIREN和傅里叶特征论文中提出的精确基准中可比较的参数数量的网络上的方法进行比较。我们表明，当增加网络的深度或宽度时，MFNs可以获得更好的性能增量。尽管如此，我们还是强调这一点，特别是，与MFN相比，SIREN网络似乎保留了一些显著的优势，例如在表示函数及其梯度中偏向于更平滑的区域。然而，特别是考虑到mfn最终只是对应于一个低维函数的线性傅里叶或小波表示，我们认为它们应该被视为未来研究此类问题的标准基准，以表明典型深度网络的组成深度在哪些地方可以提出实质性的好处。</p> 
<h3><a id="2_Background_and_related_work_27"></a>2. Background and related work</h3> 
<p>我们的方法与以前在傅里叶和小波变换、随机傅里叶特征和隐式神经表征方面的许多工作有关。我们将探讨以下领域之间的联系。</p> 
<h4><a id="21__30"></a>2.1 傅里叶和小波变换</h4> 
<p>利用傅立叶变换和小波变换等变换将时间或空间域信号转换到频率域已经成为图像处理、信号处理和计算机视觉许多发展的核心。特别是傅里叶变换及其各种形式在无数的应用中发现了用途，如光谱学、量子力学、信号处理。小波变换在多尺度分析中特别有用，在数据压缩中被发现特别有用，JPEG2000就是一个例子。</p> 
<h4><a id="22__33"></a>2.2 随机傅里叶特征</h4> 
<p>Rahimi &amp; Recht(2008)的一项开创性工作展示了傅里叶变换在机器学习中的应用。他们表明，简单地将原始数据集投影到随机的傅里叶基中，可以极大地提高模型的表达能力，因为它近似于内核计算。许多后续的工作应用傅里叶特征和变化，以提高机器学习算法在许多领域的性能，包括分类，回归，聚类，在线学习。</p> 
<h4><a id="23__36"></a>2.3 隐式神经表示</h4> 
<p>最近的一项工作是用神经网络参数化的连续函数来表示信号(而不是使用传统的离散表示)，这一工作越来越受欢迎。这种策略被用于表示不同的对象，比如图像，形状，场景和纹理。在这些应用中，通常使用带有多层感知器和ReLU激活函数的标准神经网络架构。最近，受到傅立叶变换在机器学习中的成功的激励，一些论文提出了将周期性非线性集成到网络中的架构变化。Mildenhall等人(2020年);Zhong等(2020);Tancik等人(2020)提出使用输入特征的正弦映射(Rahimi &amp; Recht, 2008)，使用位置编码和高斯随机分布中的映射。其他(Klocek等人，2019;Sitzmann等人，2020年)提出在多层感知器架构中使用正弦激活函数。这两种策略都被证明可以极大地提高许多对象表示任务的结果。</p> 
<h3><a id="3__39"></a>3. 乘性滤波网络</h3> 
<p>一个K层的深度网络 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         : 
        
        
        
          R 
         
        
          n 
         
        
       
         → 
        
        
        
          R 
         
        
          m 
         
        
       
      
        f:\R^n \rightarrow \R^m 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68889em; vertical-align: 0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68889em; vertical-align: 0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span></span></span></span>可以由递归式定义如下：<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
         
         
           ( 
          
         
           1 
          
         
           ) 
          
         
        
       
         = 
        
       
         x 
        
       
      
        z^{(1)} =x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.888em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span><br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         z 
        
        
        
          ( 
         
        
          i 
         
        
          + 
         
        
          1 
         
        
          ) 
         
        
       
         = 
        
       
         σ 
        
       
         ( 
        
        
        
          W 
         
         
         
           ( 
          
         
           i 
          
         
           ) 
          
         
        
        
        
          z 
         
         
         
           ( 
          
         
           i 
          
         
           ) 
          
         
        
       
         + 
        
        
        
          b 
         
         
         
           ( 
          
         
           i 
          
         
           ) 
          
         
        
       
         ) 
        
       
         , 
        
       
         i 
        
       
         = 
        
       
         1 
        
       
         , 
        
       
         . 
        
       
         . 
        
       
         . 
        
       
         , 
        
       
         k 
        
       
         − 
        
       
         1 
        
       
      
        z{(i+1)} = \sigma (W^{(i)}z^{(i)}+b^{(i)}), i=1,...,k-1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.138em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.138em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span><br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
         = 
        
        
        
          W 
         
         
         
           ( 
          
         
           k 
          
         
           ) 
          
         
        
        
        
          z 
         
         
         
           ( 
          
         
           k 
          
         
           ) 
          
         
        
       
         + 
        
        
        
          b 
         
         
         
           ( 
          
         
           k 
          
         
           ) 
          
         
        
       
      
        f(x)=W^{(k)}z^{(k)}+b^{(k)} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.97133em; vertical-align: -0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.888em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span><br> 其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         σ 
        
       
      
        \sigma 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span></span></span></span></span>表示以元素方式应用的非线性，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         W 
        
       
      
        W 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         b 
        
       
      
        b 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span>表示各层的权重的偏差，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         z 
        
       
      
        z 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span></span></span></span></span>表示隐藏层单元。我们将这些网络称为组合深度网络，因为每个非线性都被组合地应用于前一个非线性的输出，以实现其表征复杂性。</p> 
<p>SIREN或傅里叶特征网络分别可以被视为该结构的简单特殊化。在SIREN网络中，我们使用正弦波σ(x) = sin(x)作为非线性，加上适当的权值初始化和输入比例。在傅立叶特征网络中，输入层被替换为<br> <img src="https://images2.imgbox.com/dc/7c/42QtA5y0_o.png" alt="在这里插入图片描述"><br> 其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Ω 
        
       
      
        \Omega 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Ω</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ϕ 
        
       
      
        \phi 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span></span>分别是随机变量矩阵和超参数，但是其非线性激活还是典型的ReLU，表示为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         σ 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
         = 
        
       
         R 
        
       
         e 
        
       
         L 
        
       
         U 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        \sigma(x)=ReLU(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right: 0.10903em;">U</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>。</p> 
<p>相比之下，我们提出的乘性滤波器网络使用了一种不同的递归，不会导致非线性函数的组合。具体来说，MFN是通过以下递归定义的<br> <img src="https://images2.imgbox.com/38/e5/WSMUgKEb_o.png" alt="在这里插入图片描述"><br> 这里<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ∘ 
        
       
      
        \circ 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.44445em; vertical-align: 0em;"></span><span class="mord">∘</span></span></span></span></span>表示elemenwise乘法，其他的跟上面一样。但是这里表示函数为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         g 
        
       
         : 
        
        
        
          R 
         
        
          n 
         
        
       
         → 
        
        
        
          R 
         
         
         
           d 
          
         
           i 
          
         
        
       
      
        g:\R^n \rightarrow \R^{d_i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68889em; vertical-align: 0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.849108em; vertical-align: 0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328086em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>是由参数作用并且表示为一个直接应用于输入的非线性滤波器。这里最重要的一点是，在这样的网络中，我们从不将一个非线性应用到先前一个非线性的输出上。网络的所有非线性都发生在g函数内;层z(i)在通过一个线性函数后，只需乘以输入的新过滤器。这导致了目前大多数多层网络所使用的一种相当不同的功能类型，事实上，我们基本上只是根据惯例将这种功能称为“网络”。</p> 
<p>我们现在提出两个实例的MFN，使用正弦或Gabor小波作为滤波器g;我们把这两个网络分别称为FOURIERNET和GABORNET。正如我们所示，傅立叶网或Gabor网表示的函数f的关键性质是，整个函数f也可以分别写成输入的正弦波和Gabor小波的线性组（虽然指数级的大量这样的特征，但当然也有一个高度减少的空间允许系数的指数项，因为只有一个多项式的参数数量来定义MFN）。因此，我们可以断言MFN实<br> 际上更像底层信号的(丰富的)傅立叶或小波表示，只是它恰好具有与深度网络类似的参数化(并且可以通过典型的梯度下降方法进行调整)。</p> 
<h4><a id="31__57"></a>3.1 乘性傅里叶网络</h4> 
<p>作为MFN的第一个实例，我们考虑使用一个简单的正弦滤波器</p> 
<p><img src="https://images2.imgbox.com/82/21/pNMx4CPv_o.png" alt="在这里插入图片描述"><br> 我们将这样的网络称为傅立叶网，因为正弦激活(具有任意相移，以相等地表示正弦或余弦函数)自然地对应于整个函数的傅立叶随机特征表示。与基于组合的网络相比，傅立叶网的一个直接和引人注目的特征是，它的输出可以直接看成是(指数级)的线性函数傅立叶基，由网络的参数决定一组低秩系数。这可以通过下面的定理来表达。</p> 
<p><img src="https://images2.imgbox.com/bd/4b/tmbRjxcf_o.png" alt="在这里插入图片描述">换句话说，傅立叶网将它的最终函数表示为传统傅里叶基的线性组合，就像“经典的”随机傅里叶特征一样。证明的关键在于两个傅里叶滤波器的参数<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         w 
        
       
         , 
        
       
         ϕ 
        
       
      
        w,\phi 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">ϕ</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         τ 
        
       
         , 
        
       
         ψ 
        
       
      
        \tau,\psi 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.1132em;">τ</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">ψ</span></span></span></span></span>，他们的elementwise乘积可以转化为相同类型滤波器的和。<br> <img src="https://images2.imgbox.com/8d/39/Jdk1d4Fp_o.png" alt="在这里插入图片描述"><br> （请注意，余弦可以表示为带有单独相位偏移的正弦）此外，检验证明还可以让我们计算出线性展开的精确系数，作为网络参数的函数。这在下面的推论中显示出来。<br> <img src="https://images2.imgbox.com/e0/2f/9LHtnWAh_o.png" alt="在这里插入图片描述"><br> 这个推论是通过检查附录中的证明得出的，注意到每一个附加的乘法层都创建正弦项中频率的正负组合，以及W中相应项的乘法。也就是傅立叶网的乘法“深度”允许它表示正弦函数的指数数量，但有一个约束，这些特征上的系数的实际数量是由一个主要由W矩阵中的系数组成的“低秩”张量给出的。这种扩展还建议使用一种方法来初始化特定于该网络的参数，这种方法可以根据网络大小适当伸缩。具体来说，W (i)是初始化的(通常是随机均匀或高斯函数，尽管这里有一个额外的比例因子，它取决于输入的相对比例)，我们应该将这些项除以根号k，以确保最终频率!t的方差与层数无关。</p> 
<h4><a id="32_Gabor_69"></a>3.2 乘性Gabor网络</h4> 
<p>纯傅里叶基的一个众所周知的缺陷是它们具有全局支持，因此可能难以表示更多的局部特征。这些基地的一个常见替代是使用Gabor滤波器捕捉频率和空间局部分量。具体来说，我们考虑<br> Gabor过滤器的形式:<br> <img src="https://images2.imgbox.com/28/79/QILXUgAs_o.png" alt="在这里插入图片描述"><br> 与傅立叶网一样，Gabor网络的一个引人注目的特征是，最终函数f可以表示为Gabor滤波器的线性组合。这是由以下定理得到的:<br> <img src="https://images2.imgbox.com/79/a5/SqSq0TY1_o.png" alt="在这里插入图片描述"><br> 证明在附录中给出，但基本过程与上面相同:使用的事实是，就像傅里叶滤波器一样，Gabor滤波器的乘积也是(另一组)Gabor滤波器的线性组合。同样地，我们也可以计算系数的显式形式对于这个线性基展开，显式形式在附录中给出。一个相关的问题是，我们如何选择γ和μ参数的初始化。<br> (后面这一段机翻都不想翻了，自己现在也不想看，后续补上)</p> 
<h3><a id="4_Experimental_Results_78"></a>4. Experimental Results</h3> 
<p>我们在广泛的表征任务上对mfn进行了测试，表明相对简单的MFNs改进了现有神经表示方法的性能。我们的实验集合来自于Sitzmann等人(2020年)和SIREN(图像表示、形状表示和微分方程实验)以及Tancik等人(2020年)中和傅里叶特征网络(高斯随机特征，我们称之为FF高斯特征)中提出的实验(图像泛化和3D逆绘制实验)。在每种情况下，我们将与原始实验中测试的一组模型进行比较(通常是SIREN或FF高斯，以及基本的ReLU MLP)。MFN的PyTorch实现<a href="https://github.com/boschresearch/multiplicative-filter-networks">Code</a>上可用:<br> ，关于超参数和培训规范的详细信息可以在附录中找到。</p> 
<h4><a id="41__82"></a>4.1 图像表示和生成</h4> 
<p><img src="https://images2.imgbox.com/3c/db/tOdVypZs_o.png" alt="在这里插入图片描述"><br> 特别是，<strong>fouernet和GABORNET都显示出比其他架构更快的初始收敛速度。</strong> 训练后的PSNRs(表1)表明，SIREN最终优于FOURIERNET，而在整个训练过程中，GABORNET仍然是最好的模型。<strong>事实上，在仅仅1000次训练迭代之后，gabornet的重建性能比其他所有训练时间长10倍的模型都要好。</strong><br> <img src="https://images2.imgbox.com/c1/72/7Ns6vY1t_o.png" alt="在这里插入图片描述"></p> 
<p>我们可以扩大上面的任务，通过在输入中添加第三个维度来表示视频:输出对应于输入(x;y;T)为(x;Y)在坐标系t。我们的目标是用这种方式来表示一个分辨率为512 × 512的300帧彩色视频，测试之前实验中使用的所有架构。如图1所示，SIREN和GABORNET最能再现原始视频的细节，如胡须和和眼睛的颜色。这反映在这些重构的PSNR(表1);<strong>SIREN性能最佳，PSNR超过30 dB，而gabornet重建在1 dB以内的SIREN和展示了比任何其他模型更低的帧变化。</strong></p> 
<p><img src="https://images2.imgbox.com/2f/54/SohTP1wQ_o.png" alt="在这里插入图片描述"></p> 
<p>除了表示图像之外，我们还演示了mfn能够将表示推广到看不见的像素。我们只使用25%的图像像素(宽度和高度维度上的每一个其他像素)训练网络，并使用完整的图像进行评估。我们将我们的方法的结果与Tancik等人(2020年)提出的两个数据集(自然图像和文本图像)上的傅里叶特征网络。采用峰值信噪比(peak信噪比，PSNR)指标来评估性能。从表2中我们可以看到，傅立叶网络和GABORNET都优于使用基本特征、位置编码和随机高斯特征的所有版本的傅立叶特征网络。</p> 
<h4><a id="42__96"></a>4.2 微分方程</h4> 
<p>在本节中，我们旨在解决由不同形式的梯度信息监督的函数的边值问题。我们首先关注泊松方程，其中我们演示了在两种情况下的图像重建，其中模型的监督分别由梯度和拉普拉斯算子带来。值得注意的是，该模型从来没有呈现真实的函数值。然后我们关注两个二阶微分方程，即<br> 亥姆霍兹方程和波动方程，其中我们求解波场，网络由已知的源函数监督。我们演示了使用梯度重建图像，并比较了傅立叶网和GABORNET与SIREN和ReLU MLP对泊松方程的性能。我们使用与(5)中(Sitzmann et al.， 2020)相同的损失函数。从图3a和3b可以看出，当网络分别在梯度和Laplacians监督下进行训练时，图像重建成功，而ReLU则非常失败。表3描述了每个方法在10000次迭代之后的损失，可以看到，在性能方面，GABORNET超过了其他基线。</p> 
<p>亥姆霍兹方程和波动方程与扩散和波的物理模型有关，并与傅里叶变换密切相关。因此，我们把注意力集中在描述亥姆霍兹方程上。我们的目标是求解波场，并比较傅里叶网与SIREN和ReLU MLP的GABORNET。为了适应复值解，网络被配置为输出两个值，可以解释为实部和虚部。我们使用与(Sitzmann等人，2020)中相同的损失函数(参见Sitzmann等人，2020)详情)。图4显示了放置在均匀传播速度介质中心的单个高斯源重构波前的幅值和相位。表3描述了每种方法在50000次迭代后的损失，并显示了GABORNET节拍傅立叶网和塞壬在性能方面，而，如之前所示(Sitzmann等人，2020年)，ReLU MLP惨败。有关网络和培训的细节在附录B.3中。</p> 
<h3><a id="5_Conclusion_103"></a>5. Conclusion</h3> 
<p>我们已经介绍了乘性滤波器网络(MFNs)，这是一类神经表示架构，它放弃了通常的网络深度组合概念，而采用类似的表示乘性操作。他们也承认一种自然的信号处理解释，比如在两个mfn实例中，傅立叶网(FOURIERNET)和Gabor小波网(Gabor)分别完全等价于正弦小波基和Gabor小波基的线性组合。在实验中，我们表明，尽管相对于其他为隐式表示而设计的深度架构而言，mfn非常简单，但在一系列表示任务上，MFN能够媲美或超越之前的SOTA水平。</p> 
<h3><a id="A_piece_of_my_mind_108"></a>A piece of my mind</h3> 
<ul><li>在图像上的客观评价指标远超SIREN，但是主观质量上看不出太大的区别，并且不太理解为何图像指标高但是视频指标如此低</li><li>根据知乎大佬的评论显示，讲MFN用于图像拟合上的效果也没有文章中说的那么好的效果，大部分情况下是与SIREN效果类似甚至更差的</li><li>用于视频表示应该有更好的方式，动手实现一下，如果效果还行将本文继续补充</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/47d6f0dae3226b44ac8f8fe04426312b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PICkits3调试功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d28980cd6da14c402b192f8733f45cc0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">unityHub登录不上，跳转界面空白刷新不出来</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>