<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a931e3f8f3aa9593ca6f4a59afd19125/" rel="bookmark">
			17【cocos2d-x 源码分析】:多分辨率支持的详细分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对应源码位置：cocos2d-x-3.3\cocos\platform\GLView 设计分辨率与屏幕分辨率 cocos2d-x中，进行游戏设计时使用逻辑上的设计分辨率，当具体游戏运行在物理机上时对应具体屏幕的分辨率，这就存在从设计分辨率到具体屏幕分辨率的适配问题，主要有一系列的适配策略，这里暂不列举，但就源码进行分析，一目了然。
//这里设置 设计分辨率的大小 并指定 设计分辨率的策略 void GLView::setDesignResolutionSize(float width, float height, ResolutionPolicy resolutionPolicy) { CCASSERT(resolutionPolicy != ResolutionPolicy::UNKNOWN, "should set resolutionPolicy"); if (width == 0.0f || height == 0.0f) { return; } //设置相应属性 _designResolutionSize.setSize(width, height); _resolutionPolicy = resolutionPolicy; //更新配置 关键部分· updateDesignResolutionSize(); } void GLView::updateDesignResolutionSize() { //_screenSize 是指实际对应的 物理屏幕宽高 //第一个if 是保证数据符合逻辑 if (_screenSize.width &gt; 0 &amp;&amp; _screenSize.height &gt; 0 &amp;&amp; _designResolutionSize.width &gt; 0 &amp;&amp; _designResolutionSize.height &gt; 0) {	//物理屏幕分辨率 与 设计分辨率 的缩放比 _scaleX = (float)_screenSize.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a931e3f8f3aa9593ca6f4a59afd19125/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e3cca4460c0785eb561dea559d4d2b4/" rel="bookmark">
			@ConditionalOnProperty的使用与原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、宏观理解 通过字面意思可以看出，它依据配置文件的内容作为条件。那么作为条件后，他又有什么用处呢？
点击这个注解，我们可以看出这是一个基于springboot自动化配置的注解，它作用于接口、类、枚举、注解、方法之上。
本文以下面这个方法为例，也是真实项目中的一个例子：基本使用很简单，增加注解并且配置name和havingValue属性
目的是针对不同的配置，注册不同的配置bean。
如下图所示
同时它还组合了注解@Conditional({OnPropertyCondition.class})，conditional注解是springframework的功能，内部只有一个属性那就是一个class文件数组。通过上图和下面的图示我们可以看出，springboot的ConditionalOnProperty其实是组合了@Conditional({OnPropertyCondition.class})，OnPropertyCondition.class究竟是什么，我们一起来看看。
二、OnPropertyCondition.class 下面我们来看看这个类究竟要干些什么，我们开始不必很细致的精读每一行代码，先做一个粗略的认知
@Order(-2147483608)表示这是一个比较高优先级的bean，他要先于其他的bean被初始化。这也于是这他的用途，根据配置初始化合适的bean。
@Order(-2147483608) class OnPropertyCondition extends SpringBootCondition { OnPropertyCondition() { } public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) { 。。。 } private List&lt;AnnotationAttributes&gt; annotationAttributesFromMultiValueMap(MultiValueMap&lt;String, Object&gt; multiValueMap) { 。。。 return annotationAttributes; } private ConditionOutcome determineOutcome(AnnotationAttributes annotationAttributes, PropertyResolver resolver) { 。。。 } private static class Spec { private final String prefix; private final String havingValue; private final String[] names; private final boolean matchIfMissing; Spec(AnnotationAttributes annotationAttributes) { 。。。 } private String[] getNames(Map&lt;String, Object&gt; annotationAttributes) { 。。。 } private void collectProperties(PropertyResolver resolver, List&lt;String&gt; missing, List&lt;String&gt; nonMatching) { 。。。 } private boolean isMatch(String value, String requiredValue) { 。。。 } public String toString() { 。。。 return result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e3cca4460c0785eb561dea559d4d2b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e0b463070b34e42a745aab41d553728/" rel="bookmark">
			《数据驱动 从方法到实践》之 数据驱动的环节 学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.内容简介 本书是从理论到实践的全面且细致的企业数据驱动指南，完整还原作者在百度大数据工作从零到一构建百度用户行为大数据处理平台的经历。详解大数据本质、理念与现状，围绕数据驱动四环节—采集、建模、分析、指标，深入浅出地讲述企业如何将数据驱动方案落地，并指出数据驱动的价值在于“数据驱动决策”、“数据驱动产品智能”。最后通过互联网金额、电子商务、企业服务、零售四大行业实践，从需求梳理、事件指标设计、数据接入阶段、实际应用四大阶段介绍数据驱动在不同领域的商业价值，全面展示大数据在各个领域内的应用情况与趋势展望。
2.大数据思维与数据驱动 1）大数据的本质：大数据思维指的是企业在数据化运营和管理过程中运用思维和方式。 2）数据驱动理念和现状 （1）数据驱动的价值
驱动决策驱动产品智能 （2）企业内部数据驱动现状
初创企业无法拿到更多的数据，需要凭直觉来决策“做一款什么样的产品”。当一家企业的产品开始被市场接纳，而实际工作中，企业在实现数据驱动的道路上，依旧困难重重。 3）大数据时代到来的条件 （1）数据采集能力增强
（2）数据处理能力增强
（3）数据意识的提升
3.数据驱动的环节 1）可以分成4个环节：数据采集、数据建模、数据分析和数据指标。 2）数据采集与埋点 （1）数据采集现状
困惑：如何采、采哪些、用什么手段
由于数据采集不完整，无法实现深度分析。
统计不准。
云模式的数据分析平台让不少企业有安全顾虑，不愿意将核心数据放到第三方平台上。
痛苦：埋点混乱，常现埋错、漏埋
无奈：数据团队和业务工程团队配合困难
（2）数据采集遵循法则
大：强调的是宏观的大。不只需要海量数据，还要从系统的角度考虑。
全：强调多种数据源。
细：要求把不同维度都采集下来。
时：强调时效性。
（3）科学的数据采集和埋点方式
可视化/全埋点（无埋点）：只要在页面上嵌入SDK，就可以采集页面上所有的点击行为，优势是： 可视化展示宏观指标，满足基本数据分析需求。技术门槛低，使用与部署较简单。用户友好性强。 无埋点（全埋点）缺陷 只能采用到用户交互数据，且适合标准化的采集，自定义属性的采集需要代码埋点来辅助。无埋点兼容性有限。不同工程师可能会给APP界面中相同的Button起不同的名称ID。无埋点是前端数据采集方式之一，因此具有前端埋点的天然缺陷，如数据采集不全面、传输时效性较差、数据可靠性无法保障等问题。 代码埋点分为前端代码埋点和后端代码埋点。 前端代码埋点类似于全埋点，都是前端嵌入SDK的方式，不同的是对于每一个关键行为，都需要调用SDK代码，将必要的事件名、属性字段等写入代码。后端代码埋点则将相关的事件、属性等通过后端模块调用SDK的方式发送给后台服务器。 全埋点VS代码埋点：如果仅仅为了看宏观数据，并没有精细化分析需求，并且是对客户端做分析，这时候全埋点是一种比较省事的选择。一旦企业有复杂的分析需求，就必须进行代码埋点，否则数据无法进行灵活下钻。前端埋点VS后端埋点： 产品运营初期，产品功能比较简单，可以采用前端埋点。有些行为没有和后端进行交互操作，如离线运行，就比较适合前端埋点。为保证核心数据的准确性，更推荐后端埋点。总的来说，“后端代码埋点”或“后端代码埋点+全埋点”适合有深度数据分析需求的企业。 （4）数据准确性
数据不准确的情况 网络异常统计口径不同代码质量问题无效请求 提升数据准确性的策略 采集关键行为，推荐后端埋点进行事件设计和明确统计口径需要具有完善的元数据管理和埋点管理通过多维分析能力快速定位异常 3）数据建模 （1）多维数据模型
数据立方体是多维数据模型的通俗叫法，主要由“维度”和“指标”两部分组成将用户数据按照时间细粒度汇聚，根据不同维度进行组合查询，所有报表需求都产生在这个基础上。 （2）多维事件模型
访问量模型：在传统Web时代，通常使用PV来衡量和分析一个产品的好坏。多维事件模型分成Event实体和User实体Event实体：描述了一个用户在某个时间点、某个地点以某种方式完成某个具体的事情User实体：每个user实体对应一个真实的用户，用distinct_id进行标识，描述用户的长期属性，并且通过distinct_id与这个用户所从事的行为，即Event进行关联。 4）数据分析方法 （1）行为事件分析
用来研究行为事件的发生对企业组织价值的影响以及影响程度。追踪或记录用户行为或业务过程，通过研究与事件发生关联的所有因素来挖掘用户行为事件背后的原因、交互影响等。行为事件分析涉及事件、维度和指标三个概念。在分析过程中，一般期望数据是实时采集并能够实时分析，而事件、维度和指标是可以灵活自定义的。行为分析法一般经过事件定义与选择、多维度下钻分析、解释与结论 事件定义与选择：事件描述一个用户在某时间点、某地点、以某种方式完成某个具体的事情。多维分析下钻分析：要支持下钻分析和精细化条件筛选，为企业回答变化趋势、维度对比等细分问题。解释与结论：对结果进行合理的理论解释，判断数据分析结果是否符合预期相符，如判断产品的细节优化是否提升了触发了用户数。 （2）漏斗分析
漏斗分析是反映用户的行为状态及从起点到终点各个阶段用户转化率情况的重要分析模型。被广泛应用于渠道来源分析、用户激活转化等日常数据运营中。特点和价值 监控用户在各个层级的转化情况多维度切分与呈现用户转化情况，成单瓶颈无处遁形不同属性的用户群体漏斗比较，从差异角度窥视优化思路 （3）留存分析
留存分析是一种用来分析用户参与情况和活跃程度的分析模型，考察进行初始行为的用户中，有多少人会进行后续行为。这是用来衡量产品对用户价值高低的重要方法。为什么要做留存分析 不能直接使用用户活跃百分比来代替留存分析，新老用户的活跃程度不一样，按初始行为时间分组的留存分析可以消除用户增长对用户参与数据带来的影响。可以将用户按注册时间分段查看，可以对比APP改版前后的留存率来效果。 特点与价值 留存率是判断产品价值最重要的标准，揭示了产品保留用户的能力。宏观把握用户生命周期长度及定位产品可改善之处。 场景：游戏行业提升活跃、留存 游戏的生命周期的时长差异和玩家的游戏黏度提现游戏的竞争力和盈利能力，玩家对游戏的直观感受、游戏难度曲线、游戏节奏的松弛、游戏福利等因素都能导致玩家流失，正确找到玩家流失的原因，是促进玩家活跃、挽留玩家的第一步。可以通过不同等级的用户在首次登陆后每周的留存分析来定位导致玩家流失的关键因素，并对流失严重的等级对应的用户的每个环节、具体场景进行深入追踪与分析。 对留存下来的用户的一些详细的基础信息，如对借款次数、借款金额、年龄等，通过接口次数和金额评估用户质量，通过年龄可以分析金融平台吸引的群体用户的年龄分布。 （4）分布分析
分布分析时用户在特定指标下的频次、总额等的归类展现，可以展示出单用户对产品的依赖程度。 分析客户在不同地区、不同时段购买的不同类型的产品数量、购买频次等，帮助运营人员了解当前的客户状态，以及客户的运转情况。如订单金额（100以下区间、100-20区间、200以上区间等）用户的分布情况。 特点与价值 挖掘用户分布规律，优化产品策略运营并持续产品生命力，增加客户回访率快速识别核心用户群体，资源配置有的放矢 电商行业常见的分布分析应用 电商用户的忠诚度如何、客单价情况如何等问题都可以通过分布分析快速诊断，如重复购买次数、客单价分布等均是常用的衡量忠诚度的指标。从用户行为日期查看的分析结论有如：用户每个月购买频次基本稳定在1~3次之间，3月份有波动。从用户不同性别、不同渠道、不同区域等分布查看是否有偏好 （5）点击分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e0b463070b34e42a745aab41d553728/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1912dc6219f36ad74d9e43b66d852fb/" rel="bookmark">
			Stream流处理list分组方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作中经常碰到list去重的问题，现在我简单分享一下我的处理方式。
@Data @Accessors(chain = true) @NoArgsConstructor @AllArgsConstructor class Student { /** * 姓名 */ private String name; /** * 年龄 */ private Integer age; /** * 性别，0和1 */ private Integer sex; /** * 描述 */ private String desc; /** * 班级id，1.2.3... */ private Integer classId; @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Student)) return false; Student student = (Student) o; return getName().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1912dc6219f36ad74d9e43b66d852fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab6228e54035019578d650801b9d9d2/" rel="bookmark">
			ctr预估之Wide&amp;Deep和DeepFM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写了两篇关于graph embedding的文章，这次换个主题，分享两个ctr预估算法。一个是Wide&amp;Deep，是谷歌16年提的算法《Wide &amp; Deep Learning for Recommender Systems》，链接https://arxiv.org/pdf/1606.07792.pdf，这个算法是用在谷歌应用商店做排序的。另外一个是DeepFM，来自于华为17年提出的《DeepFM: A Factorization-Machine based Neural Network for CTR Prediction》，链接https://arxiv.org/pdf/1703.04247.pdf，这个是华为用在应用商店做排序的。这两个算法既可以在广告中做ctr预估，也可以在推荐系统中做排序。
ctr预估算法中最经典的莫过于逻辑回归LR，优势是速度快，便于加特征，可解释。缺点也很明显，就是无法直接拟合高阶特征，无法做特征交叉，因此需要大量的人工特征工程和专家经验来做特征交叉。后来出现的因子分解机FM，可以解决二阶特征交叉问题，但是不能解决高阶特征交叉。比如年轻男性喜欢玩射击游戏，就包括&lt;年龄，性别，游戏&gt;3阶特征。最近几年随着深度学习的快速发展，工程师引入深度学习解决高阶特征交叉问题，并提出了一批算法，比如FNN，AFM，NFM，DeepCrossing以及Wide&amp;Deep和DeepFM等，私以为最后两篇文章比较经典。
最早看这两篇算法的时候，我的感觉是这两个算法有什么差别，不是一样的吗？最近重新细读了一遍，才理解其中的不同。先来介绍一下Wide&amp;Deep，模型结构如下图所示。所谓Wide&amp;Deep就是整个模型结构由wide部分和deep部分共同组成，图中左边是wide模型，一个逻辑回归，右边是deep模型。假设输入的都是类别特征，deep模型的输入是用one-hot表示的Sparse Features。比如，对手机型号这个特征而言，市面上可能存在数千个手机型号，但是每个用户只对应一个手机型号，那么这个稀疏向量有几千个维度，只有一个位置为1，其余位置为0。将每个特征以embedding表示，embedding是一个低维稠密向量。将高维稀疏特征，映射到对应的embedding上去，将所有特征的embedding水平拼接起来，生成图中的Dense Embeddings，最后通过若干层神经网络得到输出。将wide和deep部分组合起来，就是图中间的wide&amp;deep模型。
公式化表达如下所示。其中，b表示偏置bias， a ( l ) a^{(l)} a(l)表示deep模型最后一层输出，x表示原始的输入特征，注意还有一个 ϕ ( x ) \phi(x) ϕ(x)，这个是原始特征的特征交叉。原文中提到wide&amp;deep仍然需要做特征工程实现特征交叉，但是相比于原生的逻辑回归，只需要做少量的特征交叉，大大减少了特征工程的工作量，并且效果优于逻辑回归。原文对wide和deep模型的含义做了介绍，wide模型的特征交叉部分主要负责记忆功能，记住样本中出现过的特征交叉。deep部分有泛化功能，学习特征的embedding，泛化到那些未曾出现过的特征交叉。
y ^ w i d e _ d e e p = s i g m o i d ( w w i d e T ⋅ [ x , ϕ ( x ) ] + w d e e p T ⋅ a ( l ) + b ) \hat y_{wide\_deep}=sigmoid ( w_{wide}^T \cdot [x, \phi(x)] + w_{deep} ^T\cdot a^{(l)} + b) y^​wide_deep​=sigmoid(wwideT​⋅[x,ϕ(x)]+wdeepT​⋅a(l)+b)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bab6228e54035019578d650801b9d9d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28ab9e0785c79fc752d608da3552558d/" rel="bookmark">
			列表中的字典数据写入到csv表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 def writeData(): rows = self.info_list()	# 格式为 [{}] if not os.path.exists('userinfo.csv'): with open('userinfo.csv','a', newline='', encoding='utf-8') as f: headers = 'surname,firstName,contactPhoneNo,emailAddress,loginId,password' f.writelines(headers) f.writelines('\n') f.writelines("%s,%s,%s,%s,%s,%s" % (rows[0]["surname"],rows[0]["firstName"],rows[0]["contactPhoneNo"],rows[0]["emailAddress"],rows[0]["loginId"],rows[0]["password"],)) f.writelines('\n')	else: with open('userinfo.csv', 'a', newline='', encoding='utf-8') as f: f.writelines("%s,%s,%s,%s,%s,%s" % ( rows[0]["surname"], rows[0]["firstName"], rows[0]["contactPhoneNo"], rows[0]["emailAddress"], rows[0]["loginId"], rows[0]["password"],)) f.writelines('\n') if __name__ == "__main__": writeData() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54de9ae2f3da5da7724721deb3ceaf26/" rel="bookmark">
			C语言指针的使用、字符串和指针详解（详细、易懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言指针笔记 刚开始了解指针是从交换两个变量开始，但是总是断断续续地学，每次都在看交换两个变量的函数，上周在课上正式学了指针，看的时候感觉懂了，但是一上机就不知道指针怎么用、参数怎么传。于是想整理一下指针的学习笔记，再去做实验。
文中有错别字或其他错误的话记得给我留言哦~
什么是指针？怎么定义？ 指针是一个变量，其值为另一个变量的地址，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。定义指针的一般类型为：
&lt;类型&gt; *&lt;变量标识符&gt;，*&lt;变量标识符&gt;，...; 指针变量声明的例子：
int *px; float *q; 其中，定义变量px是一个指针，且是指向整型变量的指针变量；q是指向单精度型变量的指针变量。
怎么使用指针变量？ 指针变量跟其他变量一样，若要引用，则先要初始化或赋值。与指针有关的运算符有两个：
&amp;—取地址运算符*指针运算符 刚学指针的时候对这两个运算符很蒙，不知道该用哪个，怎么用。刚开始学不用搞那么复杂，举个简单的例子：
int a=10; int *p; p=&amp;a; printf("%d %d %p %p",a,*p,&amp;a,p); 结果是：
10 10 000000CB5D3FF654 000000CB5D3FF654
因为变量的地址是系统随机分配的，故每次运行地址都不一样，但是输出&amp;a和p是一个效果。a是一个普通变量，应该在前面加个"&amp;“才能取到a的地址，而p是一个指针变量，它存的就是a的地址，故前面不用取地址符”&amp;"。
对于取值还是取地址，为了方便记忆与理解，我是这样记的：
仅仅一个p的话，它的值就是a的地址，*p的话就是取到a的值10。
指针和数组的关系是什么？ 假设程序中有以下语句：
int a[20],*p; p=&amp;a[2]; 假设程序中有以下语句：
int a[20],*p; p=&amp;a[2]; 这里先把a[2]看成一个普通变量而不是数组，由上面的讲解假设程序中有以下语句：
int a[20],*p; p=&amp;a[2]; 这里先把a[2]看成一个普通变量而不是数组就好理解了。
C语言规定数组名代表数组首地址，即数组第一个元素的地址，一下两个语句是等价的：
int a[20],*p; p=a; p=&amp;a[0]; 注意：在程序运行过程中，一个数组所占用的存储区是不变的，因此数组名是一个常量，故只能引用数组名，而不能对其进行赋值。 如a=&amp;x;是非法的。通过数组名取地址前面不用"&amp;"，因为数组名本身就是一个地址，而通过元素取地址的话前面就要加"&amp;"。
a是常量，a++是非法的，但p是指针变量，p++是合法的。
int *p1,*p2; int a[20],k=5; p1=&amp;a[k]; p2=&amp;a[1]; p1+i ——表示&amp;a[k+i],即a[k+i]的地址
p1-i ——表示&amp;a[k-i],即a[k-i]的地址
p1-p2 ——表示k-1，即a[k]与a[1]之间相隔的元素个数
如何通过指针存取数组元素？ 已知数组名就是数组中第一个元素的地址，以下两个语句是等价的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54de9ae2f3da5da7724721deb3ceaf26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9871160f5a4834e1c8d8a52c8d65f81c/" rel="bookmark">
			DFT 幅频特性  直流分量乘1/N    谐波分量乘2/N
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文献：
李芳,曹长修.基于DFT的信号幅值谱分析[J].重庆工学院学报(自然科学版),2007(04):64-66.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f994a7da33bebc827369183d4a326a/" rel="bookmark">
			测试图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试图片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19edb76f9efbfc1cb1396699f8307e2/" rel="bookmark">
			构建超媒体驱动的RESTful Web服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章来源：https://spring.io/guides/gs/rest-hateoas/ 一、创建maven工程sprint-boot-hypermedia-driven，pom.xml文件依赖如下： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt; &lt;artifactId&gt;json-path&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 二、创建实体类Greeting.java package com.szcatic.entity; import org.springframework.hateoas.ResourceSupport; import com.fasterxml.jackson.annotation.JsonCreator; import com.fasterxml.jackson.annotation.JsonProperty; public class Greeting extends ResourceSupport { private final String content; /** * 注解@JsonCreator 表示Jackson如何创建这个POJO实例 * 注解@JsonProperty 清楚地标记了Jackson应该把什么属性放到构造参数里面 * @param content */ @JsonCreator public Greeting(@JsonProperty("content") String content) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d19edb76f9efbfc1cb1396699f8307e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a20abf0126a5e239741054b0d608eb6/" rel="bookmark">
			并发模型和并行编程模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、并发 １、并发性考虑的是同时发生的两个或者两个以上的活动。
2、并发处理有队列等候、唤醒、执行至少三个这样的步骤。
３、并发是宏观概念，在微观上它们都是序列被处理的，只不过资源不会在某一个上面被阻塞，一般都是通过时间进行轮转，所以在宏观上看多个几乎同时到达的请求同时被处理。
４、同一个时刻到达的请求也会根据优先级的不同，而后进入队列排队等候执行。
５、并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。
６、并发，是在同一个cpu上同时（不是真正的同时，而是看来是同时，因为cpu要在多个程序间切换）运行多个程序。
二、并行 １、并行性指的是以提高总体性能为明确目标，并行进行两个或者多个任务。
２、并发与并行是两个既相似而又不相同的概念：并发性，又称共行性，是指能处理多个同时性活动的能力；并行是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行，也亦是说并发事件之间不一定要同一时刻发生。
３、并行性指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。
４、并行，是每个cpu运行一个程序。
二、并行和并发的关系 １、并行程序必须具有并发性，但是并发程序并不一定需要具有并行性。
２、下面的图示展示了这种关系。
３、在网上看到了一片对于并行和并发的趣味解释，在这里分型给大家，以供理解：
打个比方。并发，就像一个人（cpu）喂2个孩子（程序），轮换着每人喂一口，表面上两个孩子都在吃饭。并行，就是2个人喂2个孩子，两个孩子也同时在吃饭。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd2c797a75f203be49e6ce97910e3d5e/" rel="bookmark">
			16【cocos2d-x 源码分析】:HttpClient 的详细分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对应源码位置：cocos2d-x-3.3\cocos\network\Http* HttpRequest的实现 typedef std::function&lt;void(HttpClient* client, HttpResponse* response)&gt; ccHttpRequestCallback; //(cocos2d::Ref::*SEL_HttpResponse) 代表cocos2d::Ref类的这种成员函数 typedef void (cocos2d::Ref::*SEL_HttpResponse)(HttpClient* client, HttpResponse* response); //一个类型转换而已 #define httpresponse_selector(_SELECTOR) (cocos2d::network::SEL_HttpResponse)(&amp;_SELECTOR) class CC_DLL HttpRequest : public Ref { public: //请求方式 enum class Type { GET, POST, PUT, DELETE, UNKNOWN, }; /** Constructor Because HttpRequest object will be used between UI thead and network thread, requestObj-&gt;autorelease() is forbidden to avoid crashes in AutoreleasePool new/retain/release still works, which means you need to release it manually Please refer to HttpRequestTest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd2c797a75f203be49e6ce97910e3d5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07a53bff376fe4bc300b80c9c5bbd731/" rel="bookmark">
			python selenium打开新窗口与多窗口切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# -*- coding: utf-8 -*- #------------------------------------------------------------------------------- # @Name: 33 # @Description: # @Author: springbocai # @Date: 2019/5/24 #------------------------------------------------------------------------------- import time from selenium import webdriver driver=webdriver.Firefox() driver.maximize_window() # 窗口最大化 driver.get('https://www.baidu.com') # 在当前浏览器中访问百度 # 新开一个窗口，通过执行new一个窗口 new='window.open("https://www.sogou.com");' driver.execute_script(new) print (driver.current_window_handle) # 输出当前窗口句柄（百度） handles = driver.window_handles # 获取当前窗口句柄集合（列表类型） print (handles) # 输出句柄集合 for handle in handles:# 切换窗口（切换到搜狗） if handle!=driver.current_window_handle: print ('switch to ',handle) driver.switch_to.window(handle) print (driver.current_window_handle) # 输出当前窗口句柄（搜狗） break time.sleep(2) driver.close() #关闭当前窗口（搜狗） time.sleep(2) driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07a53bff376fe4bc300b80c9c5bbd731/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48e20f4693fcb82f238834ebc1320b7/" rel="bookmark">
			使用ifstream读入统计单词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ifstream的特点是，只能识别空格，其他的符号不识别（也可以理解为他把其他的字符当做字母来处理），它一次读入时，将逗号、引号、等等符号和单词都一并读入。
这时我们需要将单词分离出来，有两种特殊情况需要考虑：
hello,world my name 考虑这个，有个逗号，ifstream会将其分割为 hello,world my name 共三个部分。跳到一个新的单词时，i等于0。在hello,world内部时，逗号不是字母。因此可以将这两种特殊的情况考虑进去。
当涉及到排序时，可以定义一个优先级队列priority_queue，定义cmp比较规则，则可以完成排序。
使用chs来保存缓存输入的单词，当需要将chs维护到whale中时，再进行维护。
#include&lt;cstdio&gt; #include&lt;fstream&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; typedef struct Food { int frequency; char word[20]; } Whale[13000]; struct cmp { bool operator () (const Food a,const Food b) const { return a.frequency &lt; b.frequency; } }; int current=0; int cur_food=0; char chs[20]; int chs_full = 0;//刚开始chs是空的 Whale whale; int save(char *chs) { int flag=false; for(int j=0; j&lt;cur_food; j++) { //比对一下，看看这个单词是否已经存在 if(strcmp(whale[j].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b48e20f4693fcb82f238834ebc1320b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d257eedacf51fba4f891cf3e0201050/" rel="bookmark">
			15.【cocos2d-x 源码分析】:localStorage的详细分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对应源码位置：cocos2d-x-3.3\cocos\storage\local-storage\localStorage localStorage 的接口 cocos2d-x提供了简单的本地数据存储的功能，其主要是由对sqlite的封装来实现。
//初始化 数据库 void CC_DLL localStorageInit( const std::string&amp; fullpath = ""); //释放数据库 void CC_DLL localStorageFree(); //存一个key-value void CC_DLL localStorageSetItem( const std::string&amp; key, const std::string&amp; value); //根据key获取value std::string CC_DLL localStorageGetItem( const std::string&amp; key ); //删除 key对应的 项 void CC_DLL localStorageRemoveItem( const std::string&amp; key ); localStorage 的接口的实现 //是否初始化的标志 static int _initialized = 0; static sqlite3 *_db; //查询 static sqlite3_stmt *_stmt_select; //删除 static sqlite3_stmt *_stmt_remove; //更新 static sqlite3_stmt *_stmt_update; //static表明 别处不能用 static void localStorageCreateTable() {	//创建 data表 两个属性 key为主键 const char *sql_createtable = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d257eedacf51fba4f891cf3e0201050/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d4d37cda40f3ff3abf44b5dfdbe6f13/" rel="bookmark">
			简单的三子棋（棋盘大小可变）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三子棋的逻辑：首先第一步：需要写出游戏菜单，判断是否需要进行游戏；第二步：对棋盘进行初始化 ，将棋盘初始化为空格；第三步：打印棋盘。接下来就开始下棋啦，首先玩家输入坐标进行下棋，进而电脑自动随机生成坐标进行下棋（需要注意防止所输入坐标已经被占用的现象）。最终就是判断输赢的函数咯，不过要注意的是一定不要忘了判断棋盘是否已满，如果棋盘满了就是平局啦。
具体代码如下：
函数声明：game.h
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; //定义棋盘的大小 #define ROW 3 #define COL 3 void InitBoard(char board[ROW][COL], int row, int col); //初始化棋盘 void DisplayBoard(char board[ROW][COL], int row, int col); //显示棋盘 void PlayerMove(char board[ROW][COL], int row, int col); //玩家走 void ComputerMove(char board[ROW][COL], int row, int col); //电脑走 int CheckWin(char board[ROW][COL], int row, int col); //判断输赢 函数定义：game.c
#define _CRT_SECURE_NO_WARNINGS 1 #include"game.h" void InitBoard(char board[ROW][COL], int row, int col) //初始化棋盘 { int i = 0; int j = 0; for (i = 0; i &lt; row; i++) { for (j = 0; j &lt; col; j++) { board[i][j] = ' '; } } } void DisplayBoard(char board[ROW][COL], int row, int col) //打印棋盘 { //打印数据 int i = 0; for (i = 0; i &lt; row; i++) { int j = 0; for (j = 0; j &lt; col; j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d4d37cda40f3ff3abf44b5dfdbe6f13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/491b978874d5d2d345391703b8317de8/" rel="bookmark">
			#if、#else、#endif、#elif、#ifdef、#ifndef的区别和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的条件编译 #if， #elif，#else，#endif，#ifdef、#ifndef
看名字就知道，跟我们平时用的if、elseif、else是 一样的，不同的是这里一定要记得 #endif。
#if　条件　1 代码　1 #elif 条件　2 代码　2 #else 代码段 n+1 #endif 意思跟我们平常写的代码一样，如果条件1成立，则编译代码1，如果条件二成立，则编译代码2，否则编译代码3.预编译指令中的这里的条件（表达式）与C语言本身的表达式基本一至如逻辑运算、算术运算、位运算等均可以在预编译指令中使用。C语言的代码是先编译再执行（OC/C++也是），预编译指令是在编译之前处理的，通过预编译进行宏替换、条件选择代码段，然后生成最后的待编译代码，最后进行编译。务必不能忘了#endif。 1.#if的使用 #if 表达式 代码 #endif if的后面接的是表达式，如果表达式成立，那么就会把代码编译进去，（注意：是编译进去，不是执行） 2.#if defined的使用 #if defined (宏) 代码. #endif 这个#if后面接的是一个宏，意思是前面的宏定义里面有没有定义这个宏，如果定义了，编译器就会编译中间的代码，如果没有定义，那就不会编译，不管这个宏定义的是什么东西，对不对等。
#ifdef的使用 ifdef的使用和#if defined()的用法是一样的。 ifndef又和#if !defined()的用法一样（取反的意思）。 虽然条件编译看着很简单，但是实现起来就比较复杂了，条件多的情况下#if 得套好几层。。。我用到的目前就这么多，更加高深的用法以后用到了再研究补充。
转自简书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/061c66cdc16ec151f9c6257e408e7d43/" rel="bookmark">
			海思Hi3798MV100机顶盒芯片介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi3798M V100是海思推出的专门针对OTT机顶盒市场的高性价比芯片方案。在码流兼容性、在线视频播放的流畅性、图像质量以及整机性能方面保持业界最好的用户体验。集成四核高性能处理器、内置NEON，其处理性能可以满足各种差异化的业务需求，支持Dolby和DTS音频处理。
支持H.265、H.264、AVS+、MVC、MPEG2、MPEG4、VC-1、VP6、VP8等多种格式的高清视频解码和高性能的H.264编码，可满足不断增长的多媒体播放、视频通信、多屏转码的需求。集成多核高性能2D/3D加速引擎，可为客户提供流畅的人机交互界面和丰富游戏体验。内置1路以太网、3路USB2.0、1路USB3.0等丰富外设接口，提供了灵活的连接方案。
主要特点
CPU 四核ARM Cortex A7，主频高达1.5GHz 集成多媒体加速引擎NEON 硬件JAVA 加速
集成硬件浮点协处理器
3D GPU 四核 Mali450 OpenGL ES 2.0/1.1/1.0 OpenVG 1.1，EGL
存储器控制接口
DDR3/3L 接口
−最大容量2GB −内存位宽32bit −最高频率可达800MHz/DDR1600 支持NAND Flash −支持SLC/MLC器件
−支持8bit数据位宽
−最大容量64GB −最大64bit ECC纠错
支持 EMMC/tSD/fSD Flash
HiVXE 视频解码
H.265 Main Profile@L5.0 High-tie H.264 BP/MP/HP@ level 5.0；
支持全高清3D视频(MVC格式)，支持蓝光导航
AVS 基准档次@级别 6.0，AVS-P16（AVS+）
MPEG1 MPEG2 SP@ML,MP@HL MPEG4 SP@L0-3，ASP@L0-5，GMC MPEG4 短头格式（H.263 baseline）
VC-1 SP@ML,MP@HL,AP@L0-3 VP6/8 支持 4K*2K@30fps解码
低延时解码
最大支持 4 路高清同时解码
图片解码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/061c66cdc16ec151f9c6257e408e7d43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a410a58185be15c916ee4d1eb474ae7/" rel="bookmark">
			InputAccessoryView &amp; InputView的使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 inputView和inputAccessoryView键盘的属性
inputView是键盘的主体部分，inputAccessoryView则相当于键盘上的工具栏。
话不多说，直接上码
下面是一个pick view显示取代键盘
- (UIView *)inputAccessoryView{ if (!inputAccessoryView) { inputAccessoryView = [[UIToolbar alloc] init]; inputAccessoryView.barStyle = UIBarStyleBlackTranslucent; inputAccessoryView.autoresizingMask = UIViewAutoresizingFlexibleHeight; [inputAccessoryView sizeToFit]; CGRect frame = inputAccessoryView.frame; frame.size.height = 30.0f; inputAccessoryView.frame = frame; UIBarButtonItem * doneBtn = [[UIBarButtonItem alloc]initWithTitle:LocalString(@"Done") style:UIBarButtonItemStyleDone target:self action:@selector(done:)]; [doneBtn setTintColor:[UIColor grayColor]]; UIBarButtonItem *flexibleSpaceLeft = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil]; NSArray *array = [NSArray arrayWithObjects:flexibleSpaceLeft, doneBtn, nil]; [inputAccessoryView setItems:array]; } return inputAccessoryView; } - (void)done:(id)sender { [selectTimeTextField resignFirstResponder]; [selectHoursTextField resignFirstResponder]; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5b6761bfe3ac775c22a95f3e51f9afd/" rel="bookmark">
			认真做擅长的事就能升职？你的专长可能会成为你的牢笼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		能力既是优势，也是毒品
朋友老李之前在报刊当编辑，文字功底扎实。后来单位不怎么景气，他就想着自己出来做自媒体。做了一年，一分钱没赚到，粉丝也只有几百个。
他向我吐槽，说自己老了，跟不上时代节奏了。问能不能参加我的私房课，学一学怎样写作变现。
我说，不用着急学课。你的语言表达其实没有问题，要做的，只是一些调整。
我发现他最大的问题，是仍在用传统媒体的写法写内容，甚至在格式上，都并没有“自媒体化”。
他的能力似乎停留在过去，依仗的，是过去的媒介环境、阅读习惯。然而，时代已经不同了，还沿用老规矩写文章，放到新媒体平台，传播数据往往惨不忍睹。
我告诉他：
“新媒体平台，文章跟以前不一样。
比方说，每段开头不用空两格；每段话写3—5句就可以。
你的一段，有十几行，放在手机上屏阅，读者会感觉很吃力，阅读疲倦就不愿意再往下读。
还有，新媒体时代，讲求的是新颖、快捷。多关注热点，在写自己的观点时，可将热点素材巧妙融入进去，会给文章加分……”
之后大概一个多月，老李高兴打来电话，说拿到了在自媒体的第一笔稿费。现在，他已经在各平台频频上稿。
樊登读书创始人樊登曾说，能力是优势，但能力同时也是陷阱。
职场中，有的人想拥有一项专长，一辈子指着手艺自给自足；有的人想先成为业务骨干，然后“工作优则仕”，成为管理者，带着团队，指挥下属干活。
不管是哪一类人，想拥有专长也好，想做到管理者也好，共同点是都很注重能力。
但正如老李那样，你有没有想过，你的能力或专长，有朝一日会成为你进步的阻碍大石？
全球50大管理思想家埃米尼亚·伊贝拉在她的书作《能力陷阱》中告诉我们：
我们总是很乐于去做那些我们擅长的事，于是就会一直去做，最终就使得我们会一直擅长那些事。做得越多，就越擅长，越擅长就越愿意去做。
这样的一个循环，能让我们在这方面获得更多的经验。
但这样的循环，也像毒品，在深深吸引住我们。
因为我们的快乐和自信都来源于此。它让我们陷入误区，让我们误以为，我们擅长的事就是最有价值的、且最重要的事。
换言之，能力强、专精于一项是好事，但从另一个角度来讲，也非常容易让我们陷入能力陷阱当中，以至于在其他方面无法突破。
那么，在通过职场小白这关之后，如何避免落入能力陷阱，同时还能在工作中继续获得通关秘籍呢？
重新定义你的工作，学会“领导思维” 人都会有思维定势，先前形成的知识、经验、习惯，会使人们形成认知的固定倾向。一个人的想法，所信仰的真理，认为需要优先考虑的事情都会直接影响他的行为。
要想避免能力陷阱，最好的方法就是让自己具备“领导思维”。
这种思维模式，是一种大众化的普适思维模式，并不仅仅只是管理者才应该具备。
总是低头拉车，会令我们一叶障目。而抬头看路，像领导者一样思考并付诸行动，才会使工作高效优质。
但具有领导思维并不是一件蹴而就的事，我们可以遵循“由外而内”原则，就着自己的工作，问自己三个问题。
001. 我所做的工作类型，是否令我满意？不满意的原因是什么？
002. 如果转换新角色或参与新活动能让我接触到不同的人，这些人有着与我不一样的世界观。我是否愿意去连接？
003. 当人受到新环境的挑战或接受外界新的刺激时，就会产生新的、很多的想法。重新审视自己，我是否有想法涌现，或者仅仅只是接受新环境、新刺激，就按着上级命令进行？
传统的“由内而外”原则，是先思索自身，想清楚后，再去行动。
但这三个问题，都是先从外部考虑，再结合到我们自身。
由外而内原则，能更容易令我们站到领导者的位置，去统观自己的职场全局，进而将能力最大化拓展，进而避免掉入埋头做事、最终只擅长一项专长的牢笼中。
避免掉入能力陷阱的三个策略 具备领导思维，成为领导者，像领导者一样思考 ，做领导做的事，从以下三个方面可以避免掉入能力陷阱。
第一、像桥梁一样去连接不同的人或组织
领导者有两种类型。一种是“中心型”，一种是“桥梁型”。
中心型领导就是常见的传统型领导者。他们的方法往往是设定一个清晰的目标；给每一位成员分派一个清晰的任务；管理团队内部动态以及规范；定期进行交流；关注团队成员的心理情况并给予他们认可。
而桥梁型的领导者并不会把时间花费在各种内部事务上。
相反，他们会作为团队内部与外界环境之间沟通的桥梁，因此他们的时间大多花在外部活动上。
他们在外走访，以确保团队能得到正确的信息和资源。
《我的我的经纪人》中，欧阳娜娜擅长搭配服装，想尝试这一类工作，杨天真就建议她来做实习生。
欧阳娜娜接到的任务，是给即将参加创造营的小哥哥们做好造型搭配，并且负责拍摄宣传硬照。
在这个工作中，欧阳娜娜完全可以一直只做一颗小螺丝钉，根据各个小哥哥的特点，只是发挥做艺人时积攒的审美能力，挑选好衣服即可。
又或者，她作为一个中心型的领导者，对小哥哥们进行一定的管理，借到服装，给他们编排好换衣服的程序，并且适当关注成员们的心理情况，做一做喜好调查等等，就可以了。
但欧阳娜娜很卓越地完成了任务。
她完全没有把自己局限在审美强、时尚感好、搭配佳的能力上，她不仅仅管理了内部团队，还连接了摄影师，借好了服装，跟小哥哥的经纪人开会沟通，再三确定对方想要的照片感觉。
这件事情里，她的能力边界一再拓宽，与各方的协调做得妥妥帖帖，得益于“桥梁型”领导者思维的运用。
第二：建立良好的人际关系网络
“你的收入是与你经常交往的五个人收入的平均额。”具有领导者思维的人，更会注重人际交往。
我的朋友剽悍一只猫在2016年时，想要采访100个牛人。
很多人都觉得他异想天开：你谁呀，牛人都很忙，凭什么接受你采访？
最开始时，他的采访成功率的确只有20%，但这个比例很快提升一半，后来能联系上的80%的人，都愿意接受他的采访。最终，他顺利完成了既定目标。
他告诉我，他没有话术，也没有技巧，无非做到了两个词：真诚、利他。
他在采访一个人前，一定会先靠近那个人，读他写的书、进入他的圈子、积极参与互动，建立初始链接。
比如采访作家雾满拦江，他天天跑到人家公众号留言、打赏、持续表达想采访的意愿，终于成功让对方注意到了他的存在，并最终被他的真诚与坚持所打动。
在采访知名生涯导师赵昂时，他上来说的第一句话是，我这几天专门读了您的书《人生拐角处》。我觉得您的书写得很好，我希望能帮您推推书，“冒死一荐”。
赵昂后来感慨，这样的人在职场上不会吃亏，因为他们总想着别人。开放和利他的心态，一定会赢来更多的支持。
当你正处在职场角色转变的过程中，在组织或团队外部建立并维持人际关系网络是非常重要的，它决定你是谁以及你会成为谁。
第三：跳出舒适区，朝不同的方向发展自己
现在社会需要的是多元复合能手，如果在某个领域有很好的驾驭能力，那可以尝试着走出这个熟悉的圈子，扩展自己的能力和素质，更重要的是从中发现更多的组织发展力量。
埃米尼亚·伊贝拉在书里举了一个自身经历的例子。
她之前在大学里教书，按照过去的正统教法，在课前花费大量时间一遍又一遍地备课，确保内容一清二楚。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5b6761bfe3ac775c22a95f3e51f9afd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5c8928a082ee1d3932b08f927b27802/" rel="bookmark">
			使用golang遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1, 版本控制，golang的版本控制目前基本上比java的版本控制落后几十年，这玩意根本就没有版本控制的概念， 完全一堆第三方方案来实现版本控制，即不好用，还漏洞百出。
2, 协程不是你想用就能用的。 golang的一个爆点就是协程， 确实使用协程简单方便， 一个go关键字就可以了。但是呢，一堆大坑。golang里面，只有有一个协程出现异常没有处理的情况， golang是直接终止进程，进程，进程。 一个消息的空指针异常就能让你整个进程挂掉。 我作为一个java程序员写golang代码，这点是我完全不能接受的。
并且对于大多数web程序而言，协程是体现不了任何的优势，因为大多数情况下，性能的瓶颈点都是数据库而不是内存运算。由于数据库连接数的限制，是没法发挥协程的优势。
3,泛型。这个不讨论，完全没有的玩意。
4, json转换。 golang的json转换比java的类库差太多太多，一个基本类型转换在golang的类库里面，完全不能实现， 比如一个字符串的数据“0”， 在golang里面是不能转换为数字类型的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a803f8a277e112bcbecc897bcbc740e/" rel="bookmark">
			图像单通道和三通道的解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单通道 俗称灰度图，每个像素点只能有一个值表示颜色，它的像素值在0到255之间，0是黑色，255表示白色，中间值是一些不同等级的灰色。（也有三通道灰度图，三个通道的值都是一样的）。
二、三通道图 每个像素点都有三个值表示，所以就是3通道。
例如RGB图片即为三通道图片，RGB色彩模式是工业界的一种颜色标准，是通过对红®、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。总之，每一个点由三个值表示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ccd07fdd1a5ec5a0838561a9bc07b6f/" rel="bookmark">
			Linux上VScode &#43; cmake &#43; gcc开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VScode + cmake + gcc 下载、安装vscode安装插件cmake文件结构vscode修改json文件编译、调试的过程 下载、安装 # cmake gcc 安装都很简单 # 只需要注意安装的版本就可以了 # 因为要做px4开发，我gcc的安装版本是 5.4.0 sudo apt-get install cmake sudo apt-get install gcc # vscode 安装过程有些繁琐 # 添加源 curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; microsoft.gpg sudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg sudo sh -c 'echo "deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main" &gt; /etc/apt/sources.list.d/vscode.list' # 更新安装 sudo apt-get update sudo apt-get install code vscode安装插件 vscode安装如下两个插件就够了：
分别在扩展商店中搜索c/c++和cmake，安装名字为c/c++和cmake的插件（只安装这两个即可，有一个cmake tools插件，我认为不太好用，进入vscode工作区时它会自动执行cmakelist，但是生成的文件和我直接执行cmake指令需要的文件不太相同，插件又无法修改执行的指令，索性就不用这个插件了）
C/C++cmake cmake文件结构 我经常用的文件工程结构如下：
-webbench：为工程文件夹
src：中存每个模块的源码include：中存放头文件debian：存放copyright等build：在此文件夹中构建工程，不污染源文件bin：生成的可执行文件在这个文件夹build.sh：cmake的脚本 上面一个CMakeLists.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ccd07fdd1a5ec5a0838561a9bc07b6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b336375cc23fe173b7464c759ea0719/" rel="bookmark">
			pytorch模型加载跑测试集和训练过程中跑测试集结果不一致的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天遇到个问题，保存训练完成的神经网络模型，来尝试跑了下测试集的结果，发现效果很差，和训练网络时跑测试集的结果不一样。查了些资料，发现是先eval()再测试数据的问题：
错误写法：
..... model = torch.load('model.pkl') model.eval() #先eval x = model.forward(a) #然后传递数据进行测试 ..... 正确写法：
..... model = torch.load('model.pkl') x = model.forward(a) model.eval() ..... 更正：一直忘了CSDN上的错误，误导了大家，抱歉
上面的方法其实有问题，当初测单个数据的时候正确了，我就发上来了。但是用佛如循环测大量数据的时候会出问题，例如：
错误写法：
model = torch.load('model.pkl') for i in range(1,100) a = load_data.. #导入数据 x = model.forward(a) model.eval() 正确写法是不需要model.eval():
model = torch.load('model.pkl') for i in range(1,100) a = load_data.. #导入数据 x = model.forward(a) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92356fd7c6fef18da63347ab55fec7ff/" rel="bookmark">
			推荐几个常用在线图工具(支持时序图、用例图、类图、活动图、组件图、状态图、对象图、部署图等。同时还支持非 UML 图的甘特图、架构图等)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐几个常用 ‘在线’ 图工具(支持时序图、用例图、类图、活动图、组件图、状态图、对象图、部署图等。同时还支持非 UML 图的甘特图、架构图等)
软件项目开发过程中经常需要 画流程图、接口时序图、框架图 等等。我们需要用工具来快速作图，作图工具用过 word vivso等桌面工具。现在更喜欢用在线的作图工具，原因：不需要安装软件，用浏览器就能快速作图，还能协调合作、备份等等。
我用的比较多的在线作图工具: processon , webchart , 语雀
processon 是拖拽图形作图webchart 和 语雀 作图是通过 代码 实现。 1 processon
https://www.processon.com
思维导图如下:
还有很多的模块可以选择
2 webchart
http://webchart.ihuhai.cn/index.html
这是个非常简洁的在线 ‘代码’ 作图工具 , 支持 时序图 和 流程图
时序图,如下:
流程图，如下:
在帮助里面有许多有用的示例。
3 语雀
https://www.yuque.com/yuque/help/editor-puml
语雀作图 集成了 PlantUML , Mermaid , Flowchart , Graphviz , Gantt ， 支持各种常见的作图，很棒。
时序图举例:
还有非常多的其他图，这里就不一一列举，自己看下就知道了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e01419becca4141b06bb75c7b5ffdb6/" rel="bookmark">
			Python UDP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器：
# -*- coding: utf-8 -*- import socket ''' 使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。 虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。 我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口 绑定端口和TCP一样，但是不需要调用listen()方法，而是直接接收来自任何客户端的数据 ''' # ipv4 SOCK_DGRAM指定了这个Socket的类型是UDP s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 绑定 客户端口和地址: s.bind(('127.0.0.1', 9999)) print 'Bind UDP on 9999...' while True: # 接收数据 自动阻塞 等待客户端请求: data, addr = s.recvfrom(1024) print 'Received from %s:%s.' % addr s.sendto('Hello, %s!' % data, addr) #recvfrom()方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用sendto()就可以把数据用UDP发给客户端。 客户端：
# -*- coding: utf-8 -*- import socket ''' 客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用connect()，直接通过sendto()给服务器发数据： ''' s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) for data in ['a', 'b', 'c']: # 发送数据: s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e01419becca4141b06bb75c7b5ffdb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d83e183878a68685f94b205fafb07abc/" rel="bookmark">
			(2) OSG库的入门编程----读取osgb模型并展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 OSG库的新手，学习的同时记录下一些基础的源代码块。比较简单的入门级编程， 作为新手迫切希望网络上的教程能对新手友好一些。
首先是最基本的读取模型并展示。
新建项目，配置好项目属性，引入必需的源文件，将以下代码放入main函数中即可运行。
//读取一个osgb模型并展示三维场景 //创建Viewer对象，场景浏览器 osg::ref_ptr&lt;osgViewer::Viewer&gt; viewer = new osgViewer::Viewer(); //创建场景组节点 osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group(); //创建一个节点,读取osgb osg::ref_ptr&lt;osg::Node&gt; node1 = osgDB::readNodeFile('文件名.osgb'); //添加到场景 root-&gt;addChild(node1.get()); //优化场景数据 osgUtil::Optimizer optimizer; optimizer.optimize(root.get()); //设置场景数据 viewer-&gt;setSceneData(root.get()); //初始化并创建窗口 viewer-&gt;realize(); //开始渲染 viewer-&gt;run(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20e95c59fd6c2724d9741af1e4dfc151/" rel="bookmark">
			Python实现递归求解两个数的最大公约数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、思路分析 求两个数的最大公约数，可以用欧几里得算法（辗转相除法。）其基于的定理是：两个数的最大公约数等于较小的那个数和这两个数相除的余数的最大公约数。
假设这两个数是a和b，其中，a大于b，a%b的值是r，那么a和b的最大公约数等于b和r的最大公约数。所以我们为了求出两个数的最大公约数，就要先用a和b取模（余数），再用b和模取模……一直循环下去。直到模为0，那么最后一次的除数就是最大公约数。所以我们就找到了递归的基线条件：模为0.
二、代码实现 def find_divisor(a,b): '''这个函数用来求两个正整数的最大公约数''' #下面的操作保证a永远是较大的数，这样对于我们传参的要求就低了，传入数字的大小顺序无所谓 if a&lt;b: a,b=b,a #下面是基线条件，当余数为0时，b就是最大公约数 if a%b==0: return b #不符合基线条件时，就要继续寻找最大公约数，但是参数要变成b和ab的余数，实现递归 else: return find_divisor(b,a%b) print(find_divisor(88,24)) 终端：8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0d4690da53c85e7d2be2f04110cbed/" rel="bookmark">
			安装 .NET Framework 3.5 Error 0x800f0950 in Windows 10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：常规方法一般为打开控制面板-&gt;程序-&gt;启用或关闭windows功能-&gt;选择3.5。这时，下载一会就报错了。
a) Press “Windows Logo” + “R” keys on the keyboard. b) Type “appwiz.cpl” in the “Run” command box and press “ENTER”. c) In the “Programs and Features” window, click on the link “Turn Windows features on or off”. d) Check if the “.NET Framework 3.5 (includes .NET 2.0 and 3.0)” option is available in it. 解决办法：打开搜索，很多人都出现这种问题，大部分采用离线安装的方法都成功了。我帮同学弄了很多次，但是昨天我自己的新电脑Windows 10 Home版一直停在进程上或提示无法定位”源“，还下载了好几个版本的win10，一直无法装上，今天打开电脑又试了一下结果成功了，记录一下这种玄学。
安装步骤：
1.MSDN下载的win10操作系统，对应版本号（可能报错 0x800F081F）
2.把source文件夹中的sxs文件夹拉出来，复制到你想用的盘下,我是D盘
3.win+x，管理员运行Windows PowerShell?（可能有时侯是dism的问题，这里我用的是dism.exe）
dism.exe /online /enable-feature /featurename:NetFX3 /Source:D:\sources\sxs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f0d4690da53c85e7d2be2f04110cbed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/005aa717c8ace863eb711e7b7747c305/" rel="bookmark">
			陀螺仪和加速度传感器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天找pid的资料突然找到了一个，然后发现了一个平衡车的教程，所以就记录了下来，方便以后看，下面有链接所以可以去看一下这个网站。
1. 加速度传感器 加速度传感器，有些人也叫它加速度计，你只要记住其实是一个东西两个名字而已。
加速度传感器，顾名思义，用于测量由地球引力作用或者物体运动所产生的加速度。
为了方便理解，我将加速度分为两种：由地球引力产生的重力加速度，只要地球还在，重力就不会消失；由物体运动产生的运功加速度，根据牛二定理，只要有外力作用，便产生加速度。加速度传感器测量的是这个加速度的总和。物体静止加速度计测量的就是重力加速度。
2.陀螺仪 陀螺仪，没错，它就只叫陀螺仪，没有其他名字。
陀螺仪，顾名思义，你猜不出它是干嘛的也很正常。但是，现在你要记住了，陀螺仪可以用来测量物体的旋转角速度。
我们小时候玩四驱车的时候，常说这个电机10000转每秒很牛逼，单位转/秒，那你怎么知道它10000转每秒，它这样写你就信了？如果我们有陀螺仪，把陀螺仪挂到电机轴上，那么陀螺仪测量的是旋转角速度，再除于三百六十度（一转）就可以知道这个电机转速了。实际上我们不会这样测转速-。 -，这里仅举个例子让你明白陀螺仪是干啥的。
陀螺仪利用了旋转坐标系中的物体会受到科里奥利力的原理。在陀螺仪中利用压电陶瓷做成振动单元，当旋转（陀螺仪）时会改变振动频率从而反映出物体旋转的角速度。
要获得角度，就需要对陀螺仪角速度进行积分Angle+ 。Angle是带有正负的，正值表示按正向旋转，负值表示按负向旋转。具体怎么定义正负方向，就得看你的运用了。
图5 MPU-6050方向正负示意图
由于从陀螺仪角速度获得角度信息，需要经过积分运算。如果角速度信号存在微小 的偏差和漂移，经过积分运算之后，变化形成积累误差。这个误差会随着时间延长逐步 增加，最终导致电路饱和，无法形成正确的角度信。如图6所示。
为什么要用加速度计和陀螺仪两个传感器？
似乎只需要加速度传感器就可以获得车模的倾角，再对此角度值进行微分便可以获得倾角速度。但在实际车体运行过程中，由于车体本身的摆动所产生的加速度会产生很大的干扰信号，它叠加在上述测量信号上使得输出信号无法准确反映车体的倾角，如图7所示。
图7 车体运动引起加速度信号波动
由于陀螺仪输出的是车体的角速度，不会受到车体运动的影响，因此该信号中噪声很小。车体的角度又是通过对角速度积分而得，这可进一步平滑信号，从而使得角度信号更加稳定。因此车模控制所需要的角度和角速度可以使用陀螺仪所得到的信号。
由于从陀螺仪角速度获得角度信息，需要经过积分运算。如果角速度信号存在微小的偏差和漂移，经过积分运算之后，变化形成积累误差。这个误差会随着时间延长逐步增加，最终导致电路饱和，无法形成正确的角度信号，如图8所示。
图8 陀螺仪积分误差
如何消除陀螺仪的累积误差呢？
一种简单的方法就是通过加速度传感器获得的角度信息对此进行校正。通过对比陀螺仪积分所得到的角度与重力加速度所得到的角度，使用它们之间的偏差改变陀螺仪的输出，从而积分的角度逐步跟踪到加速度传感器所得到的角度。
一言蔽之，陀螺仪噪声很小，角速度数据精准，通过积分得到角度，但是长期积分会产生累积误差，需要加速度传感器来校正此误差，获得正确的姿态数据。
转自：
https://miaowlabs.com/book/MWbalanced/why-accel-gyro.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98ff49eb1e4eef2cb485abc1d932bdff/" rel="bookmark">
			两轮差速底盘的运动模型分析：运动控制与里程计解算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb297c9419d4698829654dfe78bde56/" rel="bookmark">
			为什么前后端分离了，你比从前更痛苦？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：谢小呆
来源：my.oschina.net/xbl
一、你有没有遇到过：
前端代码刚写完，后端的接口又变了。
接口文档永远都是不对的。
测试工作永远只能临近上线才能开始。
二、为什么前后端分离了，你比从前更痛苦？
前后端分离早已经不是新闻，当真正分离之后确遇到了更多问题。要想解决现在的痛，就要知道痛的原因：
2.1、为什么接口会频繁变动？
设计之初没有想好。 这需要提高需求的理解能力和接口设计能力。
变动的成本较低。
德国有句谚语：“朝汤里吐口水。” 只有这样，才能让人们放弃那碗汤，停止不合理的行为。前后端同学坐在一起工作的时候效率会有提升，当后端同学接口变化时，只需要口头上通知一下即可，我们没有文档，我们很敏捷啊。没错，我们需要承认这样配合开发的效率会很高，但是频繁的变动会导致不断返工，造成了另一种浪费，这种浪费是可以被减少，甚至是被消除的。
2.2、为什么接口文档永远都是不对的？
接口文档在定接口时起到一定作用，写完接口就没有用了。后面接口的频繁变化，文档必定会永远落后于实际接口，维护文档的带来了一定的成本却没能带来价值。除非对外提供的接口，否则文档谁来看呢？没人看，用处又在哪？
有些公司干脆丢掉接口文档，说我们要拥抱敏捷。
所以接口文档落后的原因在于没有给我们带来价值。
2.3、为什么测试工作永远只能临近上线才能开始？
一个需求，后端开发 4 天，前端开发 4 天，联调 4 天，留给测试同学只有2天时间甚至更少，测不完只能带 bug 上线。
在开发阶段测试同学无法介入，接口在变，前端也在变， “提测” 之前只能喝茶，“提测” 之后又忙的要命。
自动化？想都别想，空有一身好本领，在 “拥抱变化” 之后只能手工测试。偶尔还要拉上前台美眉客串一下测试小妹。手工测试枯燥乏味，乏味的工作就容易出错，而且还不能快速重复，无法对测试过的功能快速回归。
三、怎么破？
解决以上问题要让接口文档发挥价值，提高变动接口的成本，测试尽早介入。
接口文档发挥出价值，就要赋予契约的意义，就如同签字画押谁也不许变，来约束我们只认契约不认人。
契约应该由前端同学来驱动，前后端共同协商。由于前端同学与 UX 接触比较紧密，更了解页面所需的数据以及整体的 User Journey，前端同学驱动会更加合理。
契约敲定之后要帮助我们生成 Mock Server（后面我们会介绍一个工具），前后端同学就要依照契约各自开发。Mock Server 可暂时替代后台服务，帮组前端开发，同时，测试同学也可以依照契约文档来编写测试脚本，使用 Mock Server 进行脚本验证。
当后端接口发生变化除了口头通知以外必须修改契约，前端同学和测试同学才能各自修改。如此一来修改契约的成本变高，人们在定契约时则会更加慎重，也会促使我们提高接口的设计能力。
看到图中没有 “联调” 的环节，并不是画错了，而是 “联调“ 不再是一项工作，在部署后只需要更改代理的配置即可。甚至使用现代前端框架（如，Vue 或者 React）只要在开发时配置一下，之后都不需要调整任何代码。
“提测” 呢？测试一直都在进行，也就不再有一个 ”提测“ 的环节，无论前后端任意一方完成开发，测试同学都可以进行测试。
理论终于扯完了，说起来容易做起来难啊，需要工具来帮助我们。接口描述的工具有很多，比较知名的 Swagger 和 Raml，我个人更倾向于 Raml 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cb297c9419d4698829654dfe78bde56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d35bef8860b9e77c9bf92f64210c12/" rel="bookmark">
			MYSQL  mysqldump的实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于MySQL的备份，可分为以下两种：
1. 冷备
2. 热备
其中，冷备，顾名思义，就是将数据库关掉，利用操作系统命令拷贝数据库相关文件。而热备指的是在线热备，即在不关闭数据库的情况下，对数据库进行备份。实际生产中基本上都是后者。
关于热备，也可分为两种方式：
1. 逻辑备份
2. 物理备份
对于前者，常用的工具是MySQL自带的mysqldump，对于后者，常用的工具是Percona提供的XtraBackup。
对于规模比较小，业务并不繁忙的数据库，一般都是选择mysqldump。
那么，mysqldump的备份原理是什么呢？
抛开源码不谈，其实我们可以通过打开general log，查看mysqldump全库备份时执行的命令来了解mysqldump背后的原理。
打开general log
mysql&gt; set global general_log=on; 其中，general log的存放路径可通过以下命令查看
mysql&gt; show variables like '%general_log_file%';
执行全库备份
# mysqldump --master-data=2 -R --single-transaction -A -phello &gt; 3306_20160518.sql
其中
--master-data指定为2指的是会在备份文件中生成CHANGE MASTER的注释。具体在本例中，指的是
-- CHANGE MASTER TO MASTER_LOG_FILE='mysql2-bin.000049', MASTER_LOG_POS=587; 如果该值设置为1，则生成的是CHANGE MASTER的命令，而不是注释。
-R 备份存储过程与函数
--single-transaction 获取InnoDB表的一致性备份。
-A 相当于--all-databases。
下面来看看general log中的内容
160518 11:00:59 14 Connect root@localhost on 14 Query /*!40100 SET @@SQL_MODE='' */ 14 Query /*!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6d35bef8860b9e77c9bf92f64210c12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a687a4353ff8e737b64b338cf452cd1a/" rel="bookmark">
			SpringCloud Sleuth 实现业务逻辑日志包含 Span 和 Trace信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 SpringCloud Sleuth是Spring Cloud的核心组件之一，实现了一种分布式链路跟踪的功能。在调用链层级很深的分布式系统中，为定位问题提供了很大便利。
Sleuth 大致的原理是自定义了一个拦截器：TraceFeignRequestInterceptor，该拦截器继承了 Feign 的拦截器接口：RequestInterceptor，所以在服务与服务直接调用时，可以进行一些埋点操作。比如在请求的head中存入具体的span信息，包括TraceId、SpanId。有两个问题：
1）在前置服务或者是数据聚合服务层面，一些对外的接口如何生成 Span 信息？
2）如何将生成的 TraceId 和 SpanId 打印到日志中？类似日志格式：
源码 问题一 ：在接口层面生成对应的 Span 信息，可以通过切面的方式实现。通过切面拦截所有的 Controller 接口，参数和返回结果也可以保存到 Span 中。如何实现呢？
在Sleuth中，Span的生成逻辑被封装在 DefaultTracer中，所以在切面中可以将该 bean 传入切面即可。
自定义配置：
@Configuration public class CustomerSleuthStreamAutoConfiguration { @Bean public CustomerTraceAspect customerTraceAspect(Tracer tracer) { return new CustomerTraceAspect(tracer); } } 切面逻辑：
@Aspect public class CustomerTraceAspect { private final Tracer tracer; public CustomerTraceAspect(Tracer tracer) { this.tracer = tracer; } @Pointcut("@within(org.springframework.web.bind.annotation.RestController) || @within(org.springframework.stereotype.Controller)") private void traceHandlerInterceptorPointcut() {} @Around("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a687a4353ff8e737b64b338cf452cd1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a01a0183d22c63547c117ad7794dfe7d/" rel="bookmark">
			Vue 获取div 的宽度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在template 某个元素中添加ref 属性。
之前使用ref 的style.width 就可以获取得到。
但今天在使用的时候突然不能获得了。
尝试了下面的方式即可：
在js 中获取这个 ref 的 “clientWidth” 属性
const eWidth = this.$refs.echartsWrapper.clientWidth 具体原因，占个坑先
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fe8786dcd746086b89e82170b7ba3b3/" rel="bookmark">
			java之迭代器模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迭代器模式 定义 在软件构建过程中，集合对象内部结构常常变化各异，但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种“透明遍历”也为同一种算法在多种集合对象上进行操作提供了可能。
迭代子(Iterator)模式又叫游标(Cursor)模式，是对象的行为模式。迭代子模式可以顺序地访问一个聚集中的元素而不必暴漏聚集的内部表象。
聚集 多个对象聚在一起形成的总体称之为聚集(Aggregate)，聚集对象是能够包容一组对象的容器对象。聚集依赖于聚集结构的抽象化，具有复杂化和多样性。数组就是最基本的聚集，也是其他的JAVA聚集对象的设计基础。
JAVA聚集对象是实现了共同的java.util.Collection接口的对象，是JAVA语言对聚集概念的直接支持。从1.2版开始，JAVA语言提供了很多种聚集，包括Vector、ArrayList、HashSet、HashMap、Hashtable等，这些都是JAVA聚集的例子。
类图 借用网上一张图，可参考
角色 抽象迭代子(Iterator)角色：此抽象角色定义出遍历元素所需的接口。
具体迭代子(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。
聚集(Aggregate)角色：此抽象角色给出创建迭代子(Iterator)对象的接口。
具体聚集(ConcreteAggregate)角色：实现了创建迭代子(Iterator)对象的接口，返回一个合适的具体迭代子实例。
客户端(Client)角色：持有对聚集及其迭代子对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。
示例 迭代器借口
public interface MyIterator { public Object previous(); public Object next(); public boolean hasNext(); public Object first(); } 具体迭代器实现类
public class MyIteratorImpl implements MyIterator { private MyCollection collection; private int position = -1; public MyIteratorImpl(MyCollection collection) { this.collection = collection; } @Override public Object previous() { if(--position &lt; 0){ System.err.println("无上一个元素"); return null; } return collection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fe8786dcd746086b89e82170b7ba3b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/529c156d42f008f42d7a288d846ccfaf/" rel="bookmark">
			Could not find com.android.tools.build:aapt2:3.3.1-5013011.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Could not find com.android.tools.build:aapt2:3.3.1-5013011.
Could not find com.android.tools.build:aapt2:3.3.1-5013011. Searched in the following locations: - file:/E:/Android/sdk/extras/m2repository/com/android/tools/build/aapt2/3.3.1-5013011/aapt2-3.3.1-5013011.pom - file:/E:/Android/sdk/extras/m2repository/com/android/tools/build/aapt2/3.3.1-5013011/aapt2-3.3.1-5013011-windows.jar - file:/E:/Android/sdk/extras/google/m2repository/com/android/tools/build/aapt2/3.3.1-5013011/aapt2-3.3.1-5013011.pom - file:/E:/Android/sdk/extras/google/m2repository/com/android/tools/build/aapt2/3.3.1-5013011/aapt2-3.3.1-5013011-windows.jar - file:/E:/Android/sdk/extras/android/m2repository/com/android/tools/build/aapt2/3.3.1-5013011/aapt2-3.3.1-5013011.pom - file:/E:/Android/sdk/extras/android/m2repository/com/android/tools/build/aapt2/3.3.1-5013011/aapt2-3.3.1-5013011-windows.jar - https://jcenter.bintray.com/com/android/tools/build/aapt2/3.3.1-5013011/aapt2-3.3.1-5013011.pom - https://jcenter.bintray.com/com/android/tools/build/aapt2/3.3.1-5013011/aapt2-3.3.1-5013011-windows.jar Required by: project :app 原因是AS版本升3.0后会报这个错
在你的bulid.gradle文件里面添加google()这句话
加入位置：Android大括号内
apply plugin: 'com.android.application' android { compileSdkVersion 25 defaultConfig { applicationId "com.will.bluetoothprinterdemo" minSdkVersion 16 targetSdkVersion 25 versionCode 1 versionName "1.0" } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } allprojects { repositories { jcenter() google()//新增这一行 } } } dependencies { implementation fileTree(dir: 'libs', include: ['*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/529c156d42f008f42d7a288d846ccfaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5d234debaf14bc295133e5385e1ebd1/" rel="bookmark">
			C# 实现DES加密解密（详解附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DES算法是一种最通用的对称密钥算法，因为算法本身是公开的，所以其安全性在于密钥的安全性。基于密钥的算法通常有两类：对称算法和公开密钥算法。对称算法的对称性体现在加密密钥能够从解密密钥推算出来，反之亦然。在大多数对称算法中，加解密的密钥是相同的，DES就是这样。可见，对称密钥算法的加解密密钥都是保密的。而公开密钥算法的加密密钥是公开的，解密密钥是保密的。
DES 加密算法的整体流程图如图1-6。
图1-6.DES加密流程图
因为在VS编译器中，WPF项目可以调用类库函数，所以实现des的加密解密较为简单。主要用到C#提供的以下三个类：
MemoryStream 内存流
DESCryptoServiceProvider 加密服务提供者类
CryptoStream 讲数据流连接到加密转换的流
具体函数如图1-7所示（加密函数传入参数是明文str和密钥sKey；解密函数传入参数是密文pToDecrypt和密钥sKey）：
class des { public static string EncryptString(string str, string sKey) { DESCryptoServiceProvider des = new DESCryptoServiceProvider(); byte[] inputByteArray = Encoding.Default.GetBytes(str); des.Key = ASCIIEncoding.ASCII.GetBytes(sKey);// 密匙 des.IV = ASCIIEncoding.ASCII.GetBytes(sKey);// 初始化向量 MemoryStream ms = new MemoryStream(); CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(), CryptoStreamMode.Write); cs.Write(inputByteArray, 0, inputByteArray.Length); cs.FlushFinalBlock(); var retB = Convert.ToBase64String(ms.ToArray()); return retB; } //解密 public static string DecryptString(string pToDecrypt, string sKey) { DESCryptoServiceProvider des = new DESCryptoServiceProvider(); byte[] inputByteArray = Convert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5d234debaf14bc295133e5385e1ebd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a0178ebb265d6ee897c9e0f8f63b5d/" rel="bookmark">
			程序员的一天是怎样过的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：互联网早班车
程序员的一天是怎样过的？
01
阿里系程序员一天的工作
1、早上8点到公司，看15分钟微博，做一天的计划。
2、10点开个晨会，然后工作到12点。
3、中午出去吃个饭+聊天，1点半回来。
4、晚上6点下班，公司吃免费的晚餐，然后加班到8点到9点。
5、锻炼半个小时身体，洗澡看看书，12点睡觉。
周日出去玩两天。 当然加班和早到是个人行为，公司的氛围还是不早到不加班的。
ps:周三参加团队组织的免费游泳，晚上7点半到9点半，正在犹豫周四参不参加免费的羽毛球…
最近996，九点上班九点下班一周6天，晚上到家洗完澡就11点了，到家往床上一滩，基本上面都废了除了周日出去玩一天。
02
google程序员一天的工作
1、9点到公司。输入6个不同的窗口密码，检查邮件。检查我在不同数据中心的几个部署任务的状态，然后接着昨天的工作。
2、9:30 – 10:15开始编码，给我所在的系统增加请求的功能。一直调试，直至正常运作，编写一到两个单元测试。处理代码变动列表。去拿当日的三瓶免费的无糖可乐。
3、10：15 – 11：00转到另外一个项目Git分支。查看同事给我所写代码的Review评论。仔细检查代码，并着手处理评论中所提问题。构建新版本，重新测试，重新修改代码，以确保代码看起来和运作都不错。提交修改后的变动列表，回应评论。
4、11：00 – 11：30 再次切换Git分支。安全起见，重构代码，然后启动一个需运行三小时的MapReduce任务，生成日志数据，来分析网络延迟。
5、11：30 – 12：00 视频会议。
12：00 – 12：35午餐，和同事一起逗乐，分享生活或工作中的故事。
12：35 – 14：00 – 返回办公桌。检查邮件。检查MapReduce的工作状态 – 基本完成一大半。回应上午已完成的代码Review的最新评论，然后提交代码。合并并清理Git分支。查看任务列表，决定接下来做什么事。
14：00 – 15：00 视频会议。
15：00 – 16：00 – 灌点红牛，保持能量，继续奋战剩余时间。MapReduce已经完成。生成（MapReduce的）结果数据图，并仔细凝视观察一会。分析结果为什么和预 期结果不一样，并编写新版本代码，来生成另外一套统计数据。在结束当日工作之前，尽可能把代码整理到可以启动另一个MapReduce。
16：00 – 17：00 – Whiskey Thursday！一群同事聚集到一块，喝苏格兰威士忌并弹吉他。（小编注：国外程序员的工作环境和氛围跟国内真是无法相比。）
17：00 – 收拾笔记本，回家。
17：30 – 20：00 – 晚餐，家庭时间直至儿子去睡觉。
20：00直至睡觉 – 如果晚上有事做，就做事。如果没事，就喝些鸡尾酒。
03
网易系程序员一天的工作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82a0178ebb265d6ee897c9e0f8f63b5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcde34faab0b481d0ac83c3abbf05cfe/" rel="bookmark">
			出现ImportError: cannot import name main的终极解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python3安装模块时出现以下错误
Traceback (most recent call last): File "/usr/local/bin/pip3", line 7, in &lt;module&gt; from pip import main ImportError: cannot import name 'main' 在网上找了各种解决办法，大多都是粘贴复制，还是没有解决问题，最后我的终极解决方案如下：
1、重新编译安装python3.6版本配置环境
[root@room9pc01 python3_pkg]# ls Python-3.6.7.tgz README [root@room9pc01 python3_pkg]# tar -xf Python-3.6.7 [root@room9pc01 python3_pkg]# cd Python-3.6.7/ [root@room9pc01 Python-3.6.7]# ./configure --prefix=/usr/local/ [root@room9pc01 Python-3.6.7]# make &amp;&amp; make install 2、官网下载pip（https://pypi.org/project/pip/#files）,重新安装pip
[root@room9pc01 zzg_pypkgs]# tar -xf pip-19.1.1.tar.gz [root@room9pc01 pip-19.1.1]# python3 setup.py install OK， 完美解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0dce4730fb085a682d70b1fc1163bc0/" rel="bookmark">
			google admob接入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在接入admob 的时候先导入jar
implementation 'com.google.android.gms:play-services-ads:17.2.0' implementation 'com.google.firebase:firebase-core:+' implementation 'com.google.firebase:firebase-messaging:+' 我在接入得时候只引用admob,发现并没有广告，最后看道firbase 也需要引用，因为和admob是联合使用得。（可能我没找到正确得使用方法），
然后在清单文件中
&lt;meta-data android:name="com.google.android.gms.ads.APPLICATION_ID" android:value=""/&gt; 添加引用appid，需要添加，没有添加会报错
然后就是开始接入广告。在接入得时候可以使用他们得测试id,直接使用线上得最后广告是不会返回了
public class MainActivity extends AppCompatActivity { private static final String TAG = "gcers"; private InterstitialAd mInterstitialAd; RelativeLayout relativeLayout; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //插屏广告 mInterstitialAd = new InterstitialAd(this); mInterstitialAd.setAdUnitId(""); mInterstitialAd.loadAd(new AdRequest.Builder().build()); handler.sendEmptyMessage(1); relativeLayout = findViewById(R.id.res); mInterstitialAd.setAdListener(new AdListener() { @Override public void onAdLoaded() { // Code to be executed when an ad finishes loading.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0dce4730fb085a682d70b1fc1163bc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb4553b01d7eb545437912b22d6ab575/" rel="bookmark">
			版权申诉指引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN社区做为开发者彼此分享和交换知识的 IT 资源共享平台，高度重视所有知识的产权保护，欢迎大家及时对侵权内容进行申诉/举报。
侵权申诉指引 版权申诉邮件标题：版权申诉 - 相关频道【下载/博客】- 申诉链接/内容
版权申诉内容应包括但不限于以下内容：
侵权链接/内容正版链接/内容/版权证明版权申诉/举报人（公司）申诉/举报人邮箱申诉/举报人联系电话 将版权申诉内容及有效证明文件的扫描件通过电子邮件方式发送至：copyright@csdn.net。
一旦收到符合上述要求之通知，我们将于1-2个工作日内处理，并回邮件告知您处理结果。
对于恶意申诉/举报用户，我们将严肃处理，锁定帐号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9145a97708f36c375dc3a30a393d345b/" rel="bookmark">
			font-style italic 和 oblique的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果展示
italic 显示一个斜体的字体样式 展示字体自身的倾斜样式，不是我们强加给字体的属性，而是字体自身的一种状态
oblique 显示一个倾斜的字体样式 用于自身没有斜体效果的字体，强制向右倾斜文字
就像变色龙变色和猫咪变色，变色龙的变色是本能，猫咪变色则需要借助外界颜料变身。
italic就是变色龙，oblique就是猫咪
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72b7f38bf1f0e76d80e56b79f5f2963a/" rel="bookmark">
			DANet：Dual Attention Network for Scene Segmentation论文解读和源代码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天为大家带来一篇CVPR2019的语义分割的一篇文章，我认为也是非常新颖的了。其中的对偶结构生成的attention map我认为很容易嵌入到其他网络中完成其他任务。
论文地址：here
官方源码：(基于pytorch)[https://github.com/junfu1115/DANet]
提出背景 当前的主流的语义分割网络应该就是空洞卷积和解码器这两个元素的组合。但这两个组件都是利用局部特征（因为卷积操作就是稀疏连接嘛，一次卷积能覆盖特征图全部的信息吗？当然不行啦，所以说是利用局部特征），作者提出两种模块，分别从分辨率维度（spatial）和通道维度来引入全局的信息，将局部特征和全局的依赖性自适应地整合到一起。
之前的一些方法，往往有两个问题。第一个是，如果某些目标受到光照，遮挡等因素不够显著，那么这些位置的预测结果很可能就被一些显著性的物体所影响了。第二个问题是，一张图像中很多物体的尺度是不一样的，占比不一样，那么不同尺度的特征应该被同等对待。作者通过自注意力机制从全局视野自适应地在整合任何尺度的相似的特征（没有明白的话，看下面的attention map的可视化应该就可以明白了）。作者认为局部特征对应的全局性的依赖是很重要的。
主要贡献 提出了一种新颖的对偶注意力网络，利用自注意力机制提高特征表示的判别性。位置注意力模块用于学习特征的空间依赖性，通道注意力模块用来学习通道之间的内部关联性。在cityscapes，PASCAL context，COCO stuff上实现了更好的性能 方法 如果给结构分类，我会把它分到空洞卷积那类中，因为没有解码器嘛。
backbone是ResNet，50或者101，都行，重点是融合空洞卷积核并删除了池化层的ResNet，其实就是现在流行的deeplab中使用的resnet结构了，注意resnet输出的特征图是原始尺寸的 1 8 \frac{1}{8} 81​倍。
之后分两路（当然这里的resnet是只用卷积层部分，去除全连接层的！），这两路都先进过一个卷积层，然后分别送到位置注意力模块和通道注意力模块中去。这两个模块就有点意思了。理解起来比较费力气的。
先看下位置注意力模块的具体结构。
位置注意力模块 PAM A就是模块的输入，它被分别送到三个卷积层中获得了B，C，D。这四个特征图都是一样大小的，都是 R C × H × W 的 R^{C\times H\times W}的 RC×H×W的。现在把B和C都reshape为 R C × N R^{C \times N} RC×N，其中 N = H × W N= H\times W N=H×W 。 然后将C的转置和B相乘，得到了 S ∈ R N × N S \in R^{N \times N} S∈RN×N，然后按行(axis=1)做softmax运算。见原文
s j i s_{ji} sji​就是第j行第i列的元素，它等于 B B B的第i列乘上 C C C的第J列的指数除以下面那串玩意，如果你耐心推导，就是把得到的S按列（axis = -1， 对于channel first形式）求softmax运算，再赋值给S。 s j i s_{ji} sji​代表着第i个位置的特征对第J个位置的影响，如果这两个位置恰好都是属于同一类的像素点，那么 s j i s_{ji} sji​就会产生很大的值，这样就会突出相似特征之间的联系，但其实为啥能这样我没看懂。再说一下， B i , B j B_i,B_j Bi​,Bj​其实都是 R 1 × C R^{1\times C} R1×C的，i和j都是遍历 1 , 2 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72b7f38bf1f0e76d80e56b79f5f2963a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e07605a681d691e0e46338b9b9d0fc6/" rel="bookmark">
			knn实战：如何对手写数字进行识别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Python 的 sklearn 工具包中有 KNN 算法。KNN 既可以做分类器，也可以做回归。
如果是做分类，你需要引用：
from sklearn.neighbors import KNeighborsClassifier 如果是做回归，你需要引用：
from sklearn.neighbors import KNeighborsRegressor 如何在 sklearn 中创建 KNN 分类器： 我们使用构造函数 KNeighborsClassifier(n_neighbors=5, weights=‘uniform’，algorithm=‘auto’, leaf_size=30)，这里有几个比较主要的参数：
n_neighbors 即 KNN 中的 K 值，代表的是邻居的数量。
k小过拟合，k大欠拟合；一般默认使用5
weights weights=uniform
代表所有邻居的权重相同 weights=distance
代表权重是距离的倒数，即与距离成反比自定义函数你可以自定义不同距离所对应的权重。 algorithm
algorithm=auto
根据数据的情况自动选择适合的算法，默认情况选择 auto algorithm=kd_tree
也叫作 KD 树，是多维空间的数据结构，方便对关键数据进行检索；不过 KD 树适用于维度少的情况，一般维数不超过 20，如果维数大于 20 之后，效率反而会下降； algorithm=ball_tree
也叫作球树，它和 KD 树一样都是多维空间的数据结果，不同于 KD 树，球树更适用于维度大的情况； algorithm=brute
也叫作暴力搜索，它和 KD 树不同的地方是在于采用的是线性扫描，，而不是通过构造树结构进行快速检索。 leaf_size
代表构造 KD 树或球树时的叶子数，默认是 30，调整 leaf_size 会影响到树的构造和搜索速度。 创建完 KNN 分类器之后，我们就可以输入训练集对它进行训练，这里我们使用 fit() 函数，传入训练集中的样本特征矩阵和分类标识，会自动得到训练好的 KNN 分类器。然后可以使用 predict() 函数来对结果进行预测，这里传入测试集的特征矩阵可以得到测试集的预测分类结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e07605a681d691e0e46338b9b9d0fc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a64b70067ec37bef11794a6b36c5da85/" rel="bookmark">
			迭代器的原理及源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 迭代器的原理及源码解析 A：迭代器原理 迭代器原理：迭代器是对集合进行遍历，而每一个集合内部的存储结构都是不同的，所以每一个集合存和取都是不一样，那么就需要在每一个类中定义hasNext()和next()方法，这样做是可以的，但是会让整个集合体系过于臃肿，迭代器是将这样的方法向上抽取出接口，然后在每个类的内部，定义自己迭代方式。这样做的好处有二：第一规定了整个集合体系的遍历方式都是hasNext()和next()方法；第二代码有底层内部实现。 B：迭代器源码解析 1.在eclipse中ctrl + shift + t找到ArrayList类2.ctrl+o查找iterator()方法3.查看返回值类型是new Itr(),说明Itr这个类实现Iterator接口4.查找Itr这个内部类,发现重写了Iterator中的所有抽象方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96af2681371d485f6536ae2255f60fc7/" rel="bookmark">
			迷你版的ARDUINO MEGA2560
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 传统的MEGA2560板： 2 迷你的MEGA2560: 特点：
嵌入版Mega 2560 CH340G / ATmega2560 - 兼容 Mega 2560主板。基于Atmel ATmega2560微控制器和USB-UART接口芯片CH340G构建。
电路板尺寸紧凑，尺寸为38x55mm。这是一个很好的解决方案，使您的最终项目在焊接原型板上。
主板功能类似于Arduino Mega 2560.它是嵌入式主板，但同样稳定，并采用原装芯片ATmega2560（16 MHz）。
该板使用芯片CH340G作为转换器UART-USB。当您在频率12Mhz工作时，提供稳定的数据交换结果（需要安装驱动程序到计算机）。
Mega PRO（嵌入式）2560 CH340G / ATmega2560 - 通过microUSB电缆连接到计算机（几乎适用于所有Android智能手机）。
您可以通过MicroUSB连接器为电路板供电或为插针供电。电压调节器（LDO）可以处理6V至9V（峰值18V）DC的输入电压。
输出电流为5V - 约800mA，3.3V - 约800mA（请注意，输入电压越高，输出电流越低）。这将为您的大部分初始项目提供可靠的动力。
3 接线图： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/525c9078741d5b91c875e5cc266ef6c8/" rel="bookmark">
			OpenGL.Shader：6-glDrawArraysInstanced / 内置变量gl_VertexID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenGL.Shader：6-glDrawArraysInstanced+内置变量gl_VertexID绘制自跟踪的《三块广告牌》 首先可以看看效果。这种效果可以从现在超火的《一起来捉妖》就能观察到。现在我们就来学习其中shader的知识。
首先这次模型和着色器程序的代码组织上和以前稍作一些改变，便于更好的理解学习。我们先来定义那堆绿草的模型代码GreeneryMgr.hpp
#pragma once #ifndef GREENERY_MGR_HPP #define GREENERY_MGR_HPP #include &lt;GLES3/gl3.h&gt; #include &lt;vector&gt; #include "../common/CELLMath.hpp" #include "../common/Camera3D.hpp" #include "../program/GreeneryShaderProgram.hpp" class GreeneryMgr { private: std::vector&lt;CELL::float3&gt; mGrassesPos; GLuint mTexGrasses; GLuint vbo; GreeneryShaderProgram _program; public: GreeneryMgr() {} ~GreeneryMgr() {} void init(GLuint tex) { mTexGrasses = tex; // 初始化着色器程序 _program.initialize(); // 每一棵小草堆的位置索引 for (float x = -3 ; x &lt; 6 ; x += 3) { for (float z = -3 ; z &lt; 6 ; z += 3) { if(x==0&amp;&amp;z==0) continue;// 留位置给中间的正方体 mGrassesPos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/525c9078741d5b91c875e5cc266ef6c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fc6e6327e8d96c9a15c312144a0f98f/" rel="bookmark">
			查询表单、修改数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询表单、修改数据
作者：吱韩菌
开发工具：Visual Studio 2015
撰写时间：2019-5-16
下面我们要做的是查询数据库中的表单数据，进行修改操作。
首先需要在控制器中写一个查询和修改的方法
myModel.SYS_Academe.Where(m =&gt; m.AcademeID == AcademeID).Single();
给mod声明变量，通过数据库模型中的学院表查询学院ID。
接下来需要给修改按钮绑定点击事件οnclick=”Update”。还需要给它封装一个方法。启动页面，点击“修改”按钮，查看id是否获取成功，当它弹出提示框时则id获取成功。
接下需要给Update一个修改的模态框，给这个模态框一个ID：modalUpdateAcademe
$("#modalUpdateAcademe").modal(); 通过点击“修改”按钮来弹出能执行修改操作的模态框。进入页面查看效果当它弹出模态框时则绑定成功。
通过get提交方法，/CollegeInfor/SelectAcademe 是获取路径。data是用来返回数据的，能够将数据返回到控制器。最后再启动页面，修改数据，看是否能够获取成功。
（注：以上代码图片来源于授课老师！！！仅供参考，感谢支持！）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f9d895abde4abd0da3af066648d6ff2/" rel="bookmark">
			UE4 SpawnActor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UPROPERTY(EditDefaultsOnly,Category="Player")
TSubclassOf&lt;ASWeapon&gt; StarterWeaponClass;
FActorSpawnParameters SpawnParams;
SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
if (StarterWeaponClass)
{
CurrentWeapon = GetWorld()-&gt;SpawnActor&lt;ASWeapon&gt;(StarterWeaponClass, FVector::ZeroVector, FRotator::ZeroRotator, SpawnParams);
}
if (CurrentWeapon)
{
CurrentWeapon-&gt;SetOwner(this);
CurrentWeapon-&gt;AttachToComponent((USceneComponent*)GetMesh(),FAttachmentTransformRules::SnapToTargetNotIncludingScale,"WeaponSocket");
}
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/478/">«</a>
	<span class="pagination__item pagination__item--current">479/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/480/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>