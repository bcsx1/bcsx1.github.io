<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e456c9478ca6a2fc7866b8a889979270/" rel="bookmark">
			安装ubuntu18.04&#43;win10双系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注意，最重要的一点，在磁盘分区之后下面会有一个为哪里安装grub的选项，这里一行要选择/这个主分区，否则在后面安装中会报无法安装grub的错误。u盘装系统要注意u盘格式与电脑引导格式相对应，比如我的电脑是uefi启动，u盘的格式就要设置成gpt格式，如果是传统启动模式，u盘就要设置成mbr格式，注意一一对应。分区时，gpt+uefi要设置efi分区，而mbr+传统启动要设置boot分区。安装之前要在电脑中将安全启动模式关闭。分区如果是在win10所在磁盘安装ubuntu，其实就不用设置efi，因为win10自带efi分区。安装时尽量不要联网，也不要去下载哪个影视相关配件，避免出错。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/766c6f57fc75076702a6c6d0aa2825af/" rel="bookmark">
			Protobuf通信协议详解：代码演示、详细原理介绍等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、概述
1.1前言
在移动互联网时代，手机流量、电量是最为有限的资源，而移动端的即时通讯应用无疑必须得直面这两点。
解决流量过大的基本方法就是使用高度压缩的通信协议，而数据压缩后流量减小带来的自然结果也就是省电：因为大数据量的传输必然需要更久的网络操作、数据序列化及反序列化操作，这些都是电量消耗过快的根源。
当前即时通讯应用中最热门的通信协议无疑就是Google的Protobuf了，基于它的优秀表现，微信和手机QQ这样的主流IM应用也早已在使用它。本文将详细介绍Protobuf的使用、原理等。
1.3Protobuf简介
什么是 Google Protocol Buffer？ 假如您在网上搜索，应该会得到类似这样的文字介绍：
Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。
Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API（即时通讯网注：Protobuf官方工程主页上显示的已支持的开发语言多达10种，分别有：C++、Java、Python、Objective-C、C#、JavaNano、JavaScript、Ruby、Go、PHP，基本上主流的语言都已支持，详见工程主页：https://github.com/52im/protobuf）。
或许您和我一样，在第一次看完这些介绍后还是不明白 Protobuf 究竟是什么，那么我想一个简单的例子应该比较有助于理解它。
2、一个简单的例子
2.1安装 Google Protocol Buffer
在网站 https://github.com/52im/protobuf 上可以下载 Protobuf 的源代码。然后解压编译安装便可以使用它了。
安装步骤如下所示：
tar -xzf protobuf-2.1.0.tar.gz cd protobuf-2.1.0 ./configure --prefix=$INSTALL_DIR make make check make install 2.2关于简单例子的描述
我打算使用 Protobuf 和 C++ 开发一个十分简单的例子程序。该程序由两部分组成。第一部分被称为 Writer，第二部分叫做 Reader。Writer 负责将一些结构化的数据写入一个磁盘文件，Reader 则负责从该磁盘文件中读取结构化数据并打印到屏幕上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/766c6f57fc75076702a6c6d0aa2825af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0da46a1b442ec99f6451c5e610bb5112/" rel="bookmark">
			智能优化算法应用：基于麻雀搜索算法PID参数优化 - 附代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能优化算法应用：基于麻雀搜索算法PID参数优化 - 附代码 文章目录 智能优化算法应用：基于麻雀搜索算法PID参数优化 - 附代码1.PID简介2.麻雀搜索算法简介3.适应度函数设计4.算法实验与结果5.参考文献：6.Matlab 代码 摘要：本文主要介绍如何用麻雀搜索算法进行PID参数的优化。 1.PID简介 PID（Proportion-Integration-Differentiation）控 制 器通过比例单元 P、积分单元 I和微分单元 D 的线性组合构成控制量来实现对被控对象的控制，主要适用于基本线性和动态特性不随时间变化的系统。不同的控制规律适用于不同的生产过程，必须合理选择相应的控制规律，否则PID控制器将达不到预期的控制效果当PID控制器采样周期较小时，可以将连续系统离散化，即以一阶差分代替微商，求和代替积分，矩形积分近似代替连续积分，得到如下差分方程：
Δ u ( t ) = K p Δ e ( k ) + K i Δ e ( k ) + K d Δ 2 e ( k ) (1) \Delta u(t)=K_p \Delta e(k) + K_i \Delta e(k) + K_d \Delta ^2e(k)\tag{1} Δu(t)=Kp​Δe(k)+Ki​Δe(k)+Kd​Δ2e(k)(1)
其中e为输入， K p K_p Kp​ 为比例系数， K i K_i Ki​ 为积分时间常数， K d K_d Kd​ 为微分时间常数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0da46a1b442ec99f6451c5e610bb5112/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c1847830209e85b5c14ef0ee946b4f/" rel="bookmark">
			Python - 非阻塞网络编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下内容基于python2.7。
（一）python非阻塞网络编程 非阻塞网络编程要求监听或等待接受不阻塞当前线程，如果资源没到就先跳过（其实是抛出IOError）继续执行后面的代码。
非阻塞监听：sock.setblocking(False)非阻塞接收：conn.setblocking(False) 示例：
服务端# coding: utf-8 import socket CONN_ADDR = ('127.0.0.1', 9999) conn_list = [] # 连接列表 sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 开启socket sock.setblocking(False) # 设置为非阻塞 sock.bind(CONN_ADDR) # 绑定IP和端口到套接字 sock.listen(5) # 监听，5表示客户端最大连接数 print('start listen') while True: try: conn, addr = sock.accept() # 被动接受TCP客户的连接，等待连接的到来，收不到时会报异常 print('connect by ', addr) conn_list.append(conn) conn.setblocking(False) # 设置非阻塞 except IOError: pass # 非阻塞connect时如果没有connect发起则抛出异常 tmp_list = [conn for conn in conn_list] for conn in tmp_list: try: data = conn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1c1847830209e85b5c14ef0ee946b4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3f0cc9c46ba5ed6bfac95dcd7c9d23a/" rel="bookmark">
			AWS-S3 图片上传-私有
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Component public class AwsConfig { public static String AWS_S3_ACCESS_KEY ; public static String AWS_S3_SECRET_KEY ; public static String BUCKET_NAME ; @Value("${awsS3AccessKey}") public void setAwss3AccessKey(String awss3AccessKey) { AwsConfig.AWS_S3_ACCESS_KEY = awss3AccessKey; } @Value("${awsS3SecretKey}") public void setAwsS3SecretKey(String awsS3SecretKey) { AwsConfig.AWS_S3_SECRET_KEY = awsS3SecretKey; } @Value("${bucketName}") public void setBucketName(String bucketName) { AwsConfig.BUCKET_NAME = bucketName; } } public class AwsClient { static Logger logger = LoggerFactory.getLogger(AwsClient.class); static AmazonS3 s3; static S3Object fullObject = null; static { ClientConfiguration config = new ClientConfiguration(); config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3f0cc9c46ba5ed6bfac95dcd7c9d23a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/758e06d8ec0df73de754277465828246/" rel="bookmark">
			微信电脑版文件怎么在手机上编辑_金山文档该怎么用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手机小程序
1 微信文件
金山文档可直接导入微信聊天里的文件（包括群），并且可以进行直接编辑修改并且分享，最关键的是，只要使用金山文档打开的文档，都可以永久保存，再也不用担心文件过期失效！”
1微信小程序打开金山文档，点击“微信文件”
2点击文件所在聊天记录的个人或者群，勾选所选文件前的“√”，并且点击确定
3可编辑修改分享文件（此时已经永久保存）
并且无论是手机分享给电脑，微信，QQ，TIM，甚至面对面，都可以做到一键即转发，快速方便。
在金山文档小程序，打开文档，点击右上角“分享”图标。
2
网页版 协同办公
在完成文章编辑后，选择“分享”将文件链接发给对方，链接权限设为“可编辑”
2对方打开稿件后，可以在文档中协同编辑或者直接修改和批注，并且你能实时看到修改内容
3如果审稿人不止一个，还可以在批注上做区分（还支持语音批注哦）。崩溃遇到修改半天后告诉你：“还是上次那个好”......没关系，还可将稿件还原为任一历史版本
3
提供大量免费模板
另外「金山文档」的400份高效模板，已经给大家安排上了！
▲ 高效实用模板库，统统免费
▲ 高颜值的工作周报，为职场加分
▲ 5 分钟搞定 1 周学习计划表
▲ 选取 3 个领域/技能修炼，和时间一起长跑
▲ 四个维度管理时间
①网页版：打开电脑复制链接：https://docs.wps.cn/，登录后选择右下角【新建】按钮；
或者
②微信小程序：点击下方小程序进入新建页面选择新建文字或新建表格即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6163490fcc527dc544c5fdbc9da1cbe1/" rel="bookmark">
			用Jcmd命令分析虚拟机Metaspace元空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用JDK 11时jcmd添加了一个新的诊断命令：jcmd:VM.metaspace 虚拟机元空间
此命令对于分析元空间消耗非常有用。因此，让我们深入研究并使用它来重新访问我们的小WildFly服务器，它可以从以前的文章中获得。我们描述了命令输出和选项，以及如何使用它来发现典型的浪费点。
虚拟机元空间，与JDK-8201572一起推出-由SAP和Red Hat提供-是jcmd的新增加。
与该集合中的其他诊断命令一样，您将其命名为：jcmd&lt;pid or process name&gt; 虚拟机元空间.
$ jcmd wildfly help VM.metaspace 17680: VM.metaspace Prints the statistics for the Metaspace Impact: Medium: Depends on number of classes loaded. Permission: java.lang.management.ManagementPermission(monitor) Syntax : VM.metaspace [options] Options: (options must be specified using the &lt;key&gt; or &lt;key&gt;=&lt;value&gt; syntax) basic : [optional] Prints a basic summary (does not need a safepoint). (BOOLEAN, false) show-loaders : [optional] Shows usage by class loader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6163490fcc527dc544c5fdbc9da1cbe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21346ddfebc3219fa58fb561ba09dbe1/" rel="bookmark">
			2020蓝桥杯省赛C/C&#43;&#43;B组(第二场)真题及解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 试题 A: 门牌制作题解 试题 B: 既约分数题解 试题 C: 蛇形填数题解 试题 D: 跑步锻炼题解 试题 E: 七段码题解 试题 F: 成绩统计题解 试题 G: 回文日期题解 试题 H: 子串分值和题解 试题 I: 平面切分题解 试题 J: 字串排序题解 试题 A: 门牌制作 【问题描述】
小蓝要为一条街的住户制作门牌号。
这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。
小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个字符 0，2 个字符 1，1 个字符 7。
请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2？
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。
题解 答案：624
#include &lt;iostream&gt; using namespace std; int main(){ int res = 0; for(int i=2; i&lt;=2020; i++){ int t = i; while(t){ if(t%10 == 2) res++; t /= 10; } } cout &lt;&lt; res; return 0; } 试题 B: 既约分数 【问题描述】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21346ddfebc3219fa58fb561ba09dbe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c60fbfe4e688aa95af17672a548ea662/" rel="bookmark">
			python 报错汇总【持续更新中....】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Variable encoder/embedding_encoder already exists, disallowed. 总结： 由于跑的翻译模型需要构建两个embed,一直报这个错误： InvalidArgumentError (see above for traceback): assertion failed: [All values in memory_sequence_length must greater than zero.] [Condition x &gt; 0 did not hold element-wise:] [x (source_seq_lengths:0) = ] [8 13 16...] 解决方式：
1. 增加 tf.get_variable_scope().reuse_variables() # 将在当前的variable_scope下，将变量设置为reuse = True
2. 先在main函数调用模型之前，加上 tf.reset_default_graph() tf.reset_default_graph() # 避免 Variable ./encoder/kernel already exists, disallowed. model = Seq2Seq(args,logger=logger, batch_size=args.batch_size, model_path=args.ckpt_path) 然后在报错的Seq2Seq model的embeding 函数里，加一个assert声明变量全称：
""" 建立词向量 """ with tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c60fbfe4e688aa95af17672a548ea662/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34fe217c4b6d54acd628cd9ca40b1bb3/" rel="bookmark">
			【matlab】利用matlab解二元一次方程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【matlab】利用matlab解二元一次方程，
例如上图这个方程组，想求出sin(fai),cos(fai)，可以把上面两个方程视为一组二元一次方程组，利用solve函数进行求解。
syms As23 Bs23 Cs23 As13 Bs13 Cs13 As33 Bs33 Cs33 X Y t1 c2 eqns=[([X,Y,1]*[As23;Bs23;Cs23])/([X,Y,1]*[As13;Bs13;Cs13])==t1,[X,Y,1]*[As33;Bs33;Cs33]==c2]; vars=[X,Y]; [solX,solY]=solve(eqns,vars) as23就是as(2,3)进行了简化
结果
% solX = % % -(Bs23*c2 - Bs23*Cs33 + Bs33*Cs23 + Bs13*Cs33*t1 - Bs33*Cs13*t1 - Bs13*c2*t1)/(As23*Bs33 - As33*Bs23 - As13*Bs33*t1 + As33*Bs13*t1) % % % solY = % % (As23*c2 - As23*Cs33 + As33*Cs23 + As13*Cs33*t1 - As33*Cs13*t1 - As13*c2*t1)/(As23*Bs33 - As33*Bs23 - As13*Bs33*t1 + As33*Bs13*t1) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c79ea6afde4187a528f5d9f2df0391d/" rel="bookmark">
			Leetcode 1631：最小体力消耗路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。
一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。
请你返回从左上角走到右下角的最小 体力消耗值 。
示例 1：
输入：heights = [[1,2,2],[3,8,2],[5,3,5]]
输出：2
解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。
这条路径比路径 [1,2,2,2,5] 更优，因为另一条路劲差值最大值为 3 。
示例 2：
输入：heights = [[1,2,3],[3,8,4],[5,3,5]]
输出：1
解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。
示例 3：
输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c79ea6afde4187a528f5d9f2df0391d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/402cfb54e307b15713e744252cdbd546/" rel="bookmark">
			Android工程师进阶34讲学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近发现一个技术提升的平台，很多课程对于技术提升都多有益处，很多是实际上的项目实战并对底层原理讲解透彻。前几个月已经学习完了《Android 工程师进阶 34 讲》，现在重学一遍并做些总结记录加深印象。学习的过程要符合遗忘曲线，当一些所学的知识遗忘时就是该重新复学的开始，这样真正学到的知识才能刻进大脑里变成自己的知识，把书读薄在运用到的时候“下笔如有神”。
一.程序运行时内存的分配： Java 虚拟机在执行 Java 程序的过程中，会把它所管理的内存划分为不同的数据区域。下面这张图描述了一个 HelloWorld.java 文件被 JVM 加载到内存中的过程：
计数器：主要记录当前线程执行的位置；虚拟机栈：JVM 是基于栈的解释器执行的，DVM 是基于寄存器解释器执行的。虚拟机栈的初衷是用来描述 Java 方法执行的内存模型，每个方法被执行的时候，JVM 都会在虚拟机栈中创建一个栈帧。而栈帧于支持虚拟机进行方法调用和方法执行的数据结构，每一个线程在执行某个方法时，都会为这个方法创建一个栈帧。栈帧包含局部变量表/操作数栈/动态链接/返回地址； 局部变量表：是变量值的存储空间，调用方法时传递的参数，以及在方法内部创建的局部变量都保存在局部变量表中；
操作数栈：是一个后入先出（LIFO）的栈，当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的。在方法执行的过程中，会有各种字节码指令被压入和弹出操作数栈；
动态链接：主要目的是为了支持方法调用过程中的动态连接；
返回地址：用来帮助当前方法恢复它的上层方法执行状态；
本地方法栈：与虚拟栈类似，用的于本地（native）方法；堆：存放的是实例对象；方法区：主要是存储已经被 JVM 加载的类信息（版本、字段、方法、接口）、常量、静态变量、即时编译器编译后的代码和数据。 二.GC 回收机制与分代回收策略： Java 语言开发者比 C 语言开发者幸福的地方就在于，我们不需要手动释放对象的内存，JVM 中的垃圾回收器（Garbage Collector）会为我们自动回收。
可达性分析：可达性分析算法是从离散数学中的图论引入的，JVM 把内存中所有的对象之间的引用关系看作一张图，通过一组名为”GC Root"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，最后通过判断对象的引用链是否可达来决定对象是否可以被回收： GC Root对象：在 Java 中，有以下几种对象可以作为 GC Root； 1.Java虚拟机栈（局部变量表）中引用的对象；
2.方法区中静态引用指向的对象；
3.仍处于存活状态的线程对象；
4.native方法中引用的JNI对象。
触发GC回收的情况： Allocation Failure：在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败，这时系统会触发一次 GC；
System.gc()：在应用层，Java 开发工程师可以主动调用此 API 来请求一次 GC。
垃圾回收算法：标记清除算法，复制算法，标记-压缩算法。JVM分代回收策略：Java 虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代，这就是 JVM 的内存分代策略。对于新创建的对象会在新生代中分配内存，此区域的对象生命周期一般较短。如果经过多次回收仍然存活下来，则将它们转移到老年代中。对象引用：强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)； 三.字节码层面分析 class 类文件结构: class文件的用处：Java 能够实现"一次编译，到处运行”，这其中 class 文件要占大部分功劳。为了让 Java 语言具有良好的跨平台能力，Java 独具匠心的提供了一种可以在所有平台上都能使用的一种中间代码——字节码类文件（.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/402cfb54e307b15713e744252cdbd546/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4477a5f217f34ab0feb689739f01f561/" rel="bookmark">
			【Pytorch】图像基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像基本操作 PIL.Image/numpy.ndarray与Tensor的相互转换归一化PIL.Image的缩放裁剪等操作 为了方便进行数据的操作，pytorch团队提供了一个torchvision.transforms包，我们可以用transforms进行以下操作：
PIL.Image/numpy.ndarray与Tensor的相互转化；归一化；对PIL.Image进行裁剪、缩放等操作。 通常，在使用torchvision.transforms，我们通常使用transforms.Compose将transforms组合在一起。
PIL.Image/numpy.ndarray与Tensor的相互转换 PIL.Image/numpy.ndarray转化为Tensor，常常用在训练模型阶段的数据读取，而Tensor转化为PIL.Image/numpy.ndarray则用在验证模型阶段的数据输出。
我们可以使用 transforms.ToTensor() 将 PIL.Image/numpy.ndarray 数据进转化为torch.FloadTensor，并归一化到[0, 1.0]：
取值范围为[0, 255]的PIL.Image，转换成形状为[C, H, W]，取值范围是[0, 1.0]的torch.FloadTensor；形状为[H, W, C]的numpy.ndarray，转换成形状为[C, H, W]，取值范围是[0, 1.0]的torch.FloadTensor。 而transforms.ToPILImage则是将Tensor转化为PIL.Image。如果，我们要将Tensor转化为numpy，只需要使用 .numpy() 即可。如下：
img_path = "./data/img_37.jpg" # transforms.ToTensor() transform1 = transforms.Compose([ transforms.ToTensor(), # range [0, 255] -&gt; [0.0,1.0] ] ) ##numpy.ndarray img = cv2.imread(img_path)# 读取图像 img1 = transform1(img) # 归一化到 [0.0,1.0] print("img1 = ",img1) # 转化为numpy.ndarray并显示 img_1 = img1.numpy()*255 img_1 = img_1.astype('uint8') img_1 = np.transpose(img_1, (1,2,0)) cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4477a5f217f34ab0feb689739f01f561/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89ffa39b735d3ad18efeecc6363c80a4/" rel="bookmark">
			微信小程序request请求封装, token失效刷新继续请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		let isRefreshing = true; // 请求锁 let pendings = []; // 请求列表 const pathArr = ['pages/buy-goods/index']; // 不需要登录的路径 function ajax(method, url, data, options = { needLogin: true }) { const app = getApp(); const apiUrl = app.globalData.url; const token = wx.getStorageSync("token"); const time = new Date(wx.getStorageSync("expiredAt")).getTime(); //过期时间 const newTime = Date.parse(new Date()); // 当前时间 const pages = getCurrentPages(); const router = pages[pages.length - 1]['route']; // 当前路由 if(pathArr.includes(router)) options.needLogin = false; // 当前路径是否需要登录 return new Promise((resolve, reject) =&gt; { // 需要登录 但是 token不存在 跳转登录 if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89ffa39b735d3ad18efeecc6363c80a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdee1d7a88bc9ce3c39ed3154d0e18a8/" rel="bookmark">
			替代数据surrogate data
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		替代数据surrogate data To my understanding, the purpose of surrogate data testing is to stir the original data, then to check if the coherence(or other connectivity measures) really exist, am I right?
AND; Yes generate synthetic signals and test them against original and see if the statistical significance still holds good.
If I am going to compare connectivity differences between two groups, what is the working flow?
ANS: interaction ANOVA would be a fairly well suited model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdee1d7a88bc9ce3c39ed3154d0e18a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bfcc2cb1b22a9811339af010513c327/" rel="bookmark">
			基于openflow的SDN技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SDN研究背景：逻辑控制和数据转发分离
软件定义网络(software-defined networking, 简称 SDN)技术 答：分离了网络的控制平台和数据平面，为研发网络新应用和未来互联网技术提供了一种新的解决方案。
2.路由器
a.传统的路由器：只能通过命令行接口(command-line interface，简称CLI)等方式对外开放少量功能，难以在阵势的网络中实验和部署新型网络体系结构和网络技术。
（传统的路由器，导致当前网络中大量部署的网络设备和网络协议也将在相当长一段时间内，延续现有的网络体系结构）
b.新型的路由器：（可编程虚拟化）为了解决现有的TCP/IP体系结构面临的诸多难题，世界各国已经大规模的开展未来互联网的研究，研究未来互联网体系结构首先考虑的是网络核心设备路由器的重新设计和部署，允许用户自定义路由器功能模块，实现适应未来互联网发展的新型协议功能。
3.SDN研究背景：逻辑控制与数据转发分离
1. 传统因特网把控制逻辑和数据转发紧耦合在网络设备上,导致网络控制平面管理复杂化,也使得网络控制层面新技术的更新和发展很难直接部署在现有网络上,灵活性和扩展性很难适应网络的飞速发展.
2. 网络的控制转发分离架构提出由专有设备来部署高层策略,网络设备在高层策略指导下进行数据转发,减少了网络设备 承载的诸多复杂功能,提高了网络新技术和新协议实现和部署的灵活性和可操作性
4. SDN典型的工作包括：ForCES、4D架构、RCP、SANE和Ethane
⑴ ForCES(forwarding and control element separation)----基于开发可编程思想的网络体系结构
①组成：将网络元素分为控制件(control element,简称CE)和转发件(forwarding element，FE)
②优点：用ForCES协议来实现各部件的协同和交互，以提高网络的可管控功能，增强网络部署的灵活性和有效性。
③缺点：主要研究工作在于理论创新和功能建模，并没有面向真实网络的部署和实践。
⑵ 4D架构(decision, dissemination,discovery,data)
①背景：针对当前网络的逻辑决策平面 和 分布式的硬件设备结合过紧的问题。于是Greenberg等人重新设计了互联网控制和管理结构。
②在4D架构下，决策平面通过全局网络视图做出网络控制决策，并直接下发到数据平面；
i.分发平面：在决策平面和路由器之间建立可靠的通信通道；
ii.发现平面：负责发现网络中的物理组件，并为决策平面提供构建网络视图的基本信息
iii.数据平面：实现数据转发功能
③ 优点：这种架构有助于实现健壮、安全的网络，便于对异构网络进行有效管理。
⑶ RCP(routing control platform)-----基于AS结构的逻辑中央平台
①背景：针对内部边界网关协议扩展性不强和容易造成协议不稳定、路由回路等缺点。 注：内部边界网关协议(internal border gateway protocol,简称iBGP)
②干了些啥： 部署路由控制服务器集中收集路由信息和AS内部拓扑结构信息，为AS范围内的路由器做出BGP路由决策。
③ 优缺点：通过实现的原型系统验证了控制转发分离建构的可行性，与4D架构的设计思想相比，RCP仅仅实现了BGP路由策略的集中管控，它在逻辑控制平面功能上还是有很大的拓展空间的。
⑷ SANE ---面向企业网的管理架构
①目标：主要是面向企业网的安全管理。
②干了写啥：在链路层和IP层之间定义了一个可以管理所有链接的保护层，所有路由和接入控制决策都通过这个保护层由一台逻辑中央服务器进行控制。
③优缺点：以安全控制为重点，还没有实现复杂的路由决策，同时也没有经过大规模的测试，实际部署起来还是比较困难的。
⑸ Ethane---面向企业网的管理架构
①在Ethane网络中，两个主要部件是：
I. 中央控制器： 实现网络主机认证、IP分配和产生交换机流表等基本功能，是整个网络的控制决策层。
II Ethane交换机：根据控制器部署的流表进行报文转发，是一个简单的、哑的数据转发单元。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bfcc2cb1b22a9811339af010513c327/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36d371574dc0c127aa30f37a9a1a0e81/" rel="bookmark">
			线性表顺序存储和链式存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入第1行是一个整数n，表示之后还有n行输入。
每行输入表示对线性表的一条操作指令，格式是“指令编号 参数1 参数2（如有）”。
指令编号为1，表示Insert操作，此时参数1为插入的元素值，参数2为所插入元素在线性表中的位序。
指令编号为2，表示Delete操作，此时只有一个参数，即待删除元素在线性表中的位序。
指令编号为3，表示Find操作，此时只有一个参数，即待查元素的值。
顺序存储:
#include &lt;iostream&gt; using namespace std; const int maxn = 1e4 + 1; struct Node { int data[maxn]; int last; }; typedef struct Node* List; List MakeEmpty() { List L = (struct Node*)malloc(sizeof(struct Node)); L-&gt;last = -1; return L; } void Insert(List L, int val, int sernum) { if (sernum&lt;1 || sernum&gt;L-&gt;last + 2) { //不合法 return; } for (int j = L-&gt;last; j &gt;= sernum - 1; j--) { L-&gt;data[j + 1] = L-&gt;data[j]; } L-&gt;data[sernum - 1] = val; L-&gt;last++; return; } void Delete(List L, int sernum) { if (sernum&lt;1 || sernum&gt;L-&gt;last + 1) { //不合法 return; } for (int j = sernum; j &lt;= L-&gt;last; j++) { L-&gt;data[j - 1] = L-&gt;data[j]; } L-&gt;last--; return; } int Find(List L, int val) { int i = 0; while (i &lt;= L-&gt;last &amp;&amp; L-&gt;data[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36d371574dc0c127aa30f37a9a1a0e81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d30dd827e7745eb345bc989c52ef9c9/" rel="bookmark">
			迈进前端(02) 前端三巨头之CSS(CSS简介与使用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迈进前端(02) 前端三巨头之CSS(CSS简介与使用) 古之立大事者，不惟有超世之才，亦必有坚忍不拔之志。——苏轼
写在前面 此篇博客介绍 CSS 的基本信息(包括概念和发展历史)，还有如何使用 CSS 样式以及 CSS 的语法结构。
通过本篇博客我们将可以对 CSS 的含义有个初步的理解，掌握 CSS 语法中最为基础核心的内容。这些内容也将成为后续我们编写 CSS 样式代码必备的内容。
博客大纲如下
CSS概述 什么是 CSS CSS 是个缩写形式，其全称为 Cascading Style Sheets，翻译成中文的含义为层叠样式表。CSS 是用来定义 HTML 元素显示的样式和布局方式，例如设置显示字体的颜色、大小等效果。
CSS 的出现真正做到了将网页样式和内容有效进行分离，其中 HTML 元素用于展示内容，CSS 用于定义样式。
浏览器的默认样式 如果创建一个 HTML 页面，定义一些 HTML 元素并且不定义任何 CSS 样式，然后使用不同的浏览器运行如上所述 HTML 页面，我们会发现不同浏览器显示的文本内容的字体样式是不同的。
会产生这样结果的原因在于，浏览器在解析 HTML 页面时会提供一个浏览器的默认样式，而不同的浏览器所提供的这个默认样式内容是不相同的。
我们通过 CSS 设置 HTML 页面的样式，会覆盖掉浏览器的默认样式，从而使得 HTML 页面在不同浏览器中运行时显示的效果是一样的。
CSS发展 1994年哈坤·利提出了CSS的最初建议和伯特·波斯一个合作设计CSS
1997年初，W3C内组织接管CSS的工作组 CSS的版本发展 CSS1——作为一项W3C推荐，发布于1996年12月17日。1999年1月11日被推荐重新修订CSS2——作为一项W3C推荐，发布于199年1月11日。添加了对媒介（打印机和听觉设备）和可下载字体的支持CSS3——计划将CSS划分为更小的模块 如何使用 CSS CSS 样式主要的应用场景是在 HTML 页面中，其作用就是为 HTML 页面设置在浏览器运行后的显示效果。而在 HTML 页面使用 CSS 样式具有三种方式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d30dd827e7745eb345bc989c52ef9c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7893e6a58f29528a6126d05497824a3/" rel="bookmark">
			网络扫描及安全评估实验实验报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		桂 林 理 工 大 学
实 验 报 告
实验名称 网络扫描及安全评估实验
一、实验目的：
1.掌握网络端口扫描器的使用方法，熟悉常见端口和其对应的服务程序，掌握发现系统漏洞的方法。 
2.掌握综合扫描及安全评估工具的使用方法，解进行简单系统漏洞入侵的方法，了解常见的网络和系统漏洞以及其安全防护方法。
二、实验环境：
1.实验室所有机器安装了Windows操作系统，并组成了一个 局域网，并且都安装了SuperScan端口扫描工具和流光Fluxay5综合扫描工具。
2.每两个学生为一组：互相进行端口扫描和综合扫描实验。
三、实验内容：
一、根据任务一的扫描结果，写出主机开放的端口类型和服务。同时写出尝试关闭或开放目标主机上的部分服务后重新扫描的新结果。
扫描结果：
A主机开放的端口：
结果1：
结果2：
利用TCP/IP筛选：网上邻居属性-本地连接属性-常规-internet协议 (TCP/IP) 属性-高级-选项-TCP/IP筛选-属性-TCP端口-只允许139，445，这样其他端口都被关闭了
关闭一些端口后：
扫描结果1：
扫描结果2：
端口关闭成功
二、根据任务二的扫描结果，记录被扫描方的用户列表、提供的服务、共享的目录和已经存在的漏洞，分析这些漏洞，写出是系统哪方面设置防范不合理造成的，写出解决措施。
（1）端口漏洞分析
主要是21、445、139端口
端口21：FTP端口，攻击者可能利用用户名和密码过于简单，甚至可以匿名登录到目标主机上，并上传木马或病毒进而控制目标主机
端口445：这个端口的开放使安装终端服务和全拼输入法的Windows2000服务器存在着远程登录并获得超级用户权限的严重漏洞
端口139：NEBIOS会话服务端口，主要用于Widows文件和打印机共享以及Unix中的Samba服务。139端口可以被攻击者利用，建立IPC连接入侵目标主机，获得主机的root权限并放置病毒或木马。
（2）FTP漏洞分析
在扫描结果中可以看到目标主机FTP可以匿名登录，我们直接利用流光提供的入侵菜单进行FTP登录
三、写出利用破解的用户ADMINISTRATOR对目标主机进行留后门入侵的详细步骤（包括各个步骤对应的使用的命令）
1.编写批处理文件hack.bat，文件中包含两个命令：1）建立一个新账号，2） 将新账号加入administrators组。
2.使用net命令与目标主机建立连接
3.将批处理文件hack.back拷贝至目标主机上。
4.通过计划任务使目标主机执行hack.bat文件。
5.断开所有IPC$连接。
6.通过采用新账号与目标主机建立连接来验证账号是否成功建立。
7.删除和目标主机的连接。
四、心得体会：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e4c66edd11a495cfd37826c93e022f/" rel="bookmark">
			2020ICPC·小米 网络选拔赛第一场
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先贴一份代码，之后再来写~~（咕）~~
A Intelligent Warehouse 三.代码实现 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int M = (int)2e5; const int N = (int)1e7; const double eps = 1e-9; const int inf = 0x3f3f3f3f; const ll mod = (ll)998244353; int n, a[M + 5]; int m, b[M + 5]; int cnt[N + 5]; int f[N + 5]; inline int read() { int x = 0, f = 1; char ch = getchar(); while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23e4c66edd11a495cfd37826c93e022f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7823e93cda410021ac08ad4864b987aa/" rel="bookmark">
			redis学习笔记--复制(Master/Slave)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复制 复制就是我们所说的主从复制，主服务器数据更新后根据配置和策略，自动同步到从服务器的master/slaver机制，Master以写为主，Slave以读为主，Redis使用默认的异步复制，其特点是低延迟和高性能。
配置从库(slave) 方式一：修改redis.conf配置文件
slaveof 主服务器IP 主库服务器port 方式二：使用slaveof 主服务器IP 主服务器port命令,但是每次主服务器断开都需要重新连接
查看复制信息 显示与复制相关的信息
info replication master 和 slave 的复制状态以及它们的复制偏移量，连接的 slaves 列表
role 常用3招 一主二仆 一个master两个slave 问题演示 1.切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制?
主服务器(master) set k1、k2、k3
从服务器(slave)配置复制功能
主服务器(master) set k4
从服务器(slave)复制了所有值
2.从机是否可以写？set可否？
从服务器set
结果：不可以，读写分离(主写从读) 3.主服务器shutdown后情况如何？从服务器是上位还是原地待命？
主服务器shutdown后，从服务器复制信息
结果：从服务器原地待命 4.主服务器又回来了后，主服务器新增记录，从服务器还能否顺利复制？
主服务器启动后，set k5
从服务器get k5
结果：成功 5.其中一台从服务器down后在重启情况如何？
注意上面是使用slaveof命令连接的主服务器，所以从服务器down之后，再次启动后是master，需要重新连接，除非配置进redis.conf，连接后它从头开始复制
薪火相传 上一个Slave可以是下一个slave的Master，slave同样可以接收其他slave的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力。
主服务器172.17.0.2
从服务器172.17.0.3，作为下一个slave的master
从服务器172.17.0.4
同样主服务器set k6，两台从从服务器都可以get k6。其次从服务器如果要写，将redis.conf中slave-read-only改为no。
反客为主 之前主服务器down掉，从服务器会一直等待主服务器，而在此期间如果从服务器执行slaveof no one命令会将此从服务器变为master，其他从服务器可以手动执行slaveof命令连上这个新的master。
哨兵模式(sentinel) Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：
监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。 Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7823e93cda410021ac08ad4864b987aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4bd7ea36c5e884adc68f716a29c8843/" rel="bookmark">
			LeetCode 1631. 最小体力消耗路径（DFS &#43; 二分查找）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 题目2. 解题 1. 题目 你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。
一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。
你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。
一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。
请你返回从左上角走到右下角的最小 体力消耗值 。
示例 1：
输入：heights = [[1,2,2],[3,8,2],[5,3,5]] 输出：2 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。 这条路径比路径 [1,2,2,2,5] 更优，因为另一条路劲差值最大值为 3 。 示例 2：
输入：heights = [[1,2,3],[3,8,4],[5,3,5]] 输出：1 解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。 示例 3：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4bd7ea36c5e884adc68f716a29c8843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6e737d4c638b86ef16aeda67ac795ef/" rel="bookmark">
			中台详解（下）-怎么搭建中台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：《中台详解系列》共分上下两篇，本文为下篇，总计约12000字，因为文中涉及知识体系较为广泛，建议预留30-50分钟进行阅读。阅读本文前建议阅读系列上篇——《中台详解（上）-什么是中台？》，点击下方链接即可阅读。
摘要：目前市场仅对“中台”和“平台”间的继承和发展关系有一定共识，“中台”的定义及建设规范尚未有明确定论。本系列文章旨在基于“以终为始”的思维模式，及“软件对现实世界建模”的基础条件，梳理传统软件“平台”所面临的问题，并以此为起点，结合经济学中专业化分工协作理论，为“中台”进行职能定义，再通过“中台”的职能定义给出“中台”建设的建议方案。
阿里云在提出“中台”战略后，仅在一定程度上给出了“数据中台”的建设规范，同时市面上关于“中台”的介绍性文章也都避而不谈“中台”的落地方案，想是仍未统一。本文中，我将主要介绍基于我个人对于“中台”的定义及在“中台”建设方面的经验，总结得出的“中台”总体建设建议方案，不过因为篇幅原因可能不会过于细致，也不会探讨“业务中台”、“数据中台”、“技术中台”在细节上的差别。相关内容主要包括以下几个章节：
如何划分“中台”“中台”领域内建模要点“中台”数据治理方案“中台”模块间建设顺序“中台”对外服务要点“中台”迭代要点“中台”对组织架构及其协作关系的影响 第一章：如何划分“中台” 要做“中台”，首先自然就是得梳理清楚可以有哪些“中台”。
1.1.原理说明： 我对于“中台”的划分方法是基于“以终为始”的原则及我个人对“中台”的定义总结的，其细则如下：
“中台”需要通过专业化分工来解决“软件平台间职能边界划分问题”，专业化分工的本质是一种分类规则，要想分类我们就先得梳理自己有哪些业务功能以及要做哪些业务功能。所有的软件及其背后的理论、原理、概念、技术都是为了解决业务问题而产生的，所以在梳理“自己有哪些业务功能以及要做哪些业务功能”之前，需要先梳理清楚业务目标，这可以帮助我们评估业务功能梳理及其他工作的合理性。“软件平台”的专业化职能分工所需采用的“能力专业化”的原则，有着“多同一不”的特点（上篇文章有说明），所以建议提炼业务功能中的实体作为后续业务功能“分类”的“锚点”。将业务功能转化为类图等直观可视的静态模型，可以有效降低思维难度。“中台”的构建需要在企业层面拉通。 1.2.方法选择：领域驱动设计 因为“中台”背负着解决“软件平台间职能边界划分问题”的使命，从这个角度出发，我认为最适合应用于“中台”职能边界梳理的方法是“领域驱动设计”，因为从“领域”这俩字就可以看出来，“领域驱动设计”是为定义职能边界而生的。
不过目前“领域驱动设计”的落地实施方案是由技术人员总结的，主要应用于某个既定领域内的建模，如果我们直接用来进行“中台”的“专业化分工”和“数据唯一性建模”可能不太行。所以针对“中台”的目标特征，我这里借助“领域驱动设计”思想，魔改了一套经验证可行的方案。大家可以简单了解一下。（由于“领域驱动设计”是基于面向对象思想衍生出来的一种建模方法，如果对于面向对象不太熟悉，可能不太看得懂，所以如果实在看不懂建议先跳过本段。）
1.3.人员分工：产品经理主导 基于前文的分析，“平台”间的职能边界划分需要遵循专业化分工原则，所以建议增设“业务架构师”岗主导相关工作，除技术“中台”外，包括“业务中台”、“数据中台”的职能边界划分工作均由产品经理担任“业务架构师”。
1.4.操作方案： 在用本方案进行“中台”划分时，我们大致需要经过两个阶段，共计8个步骤：
（1）第一阶段：
第1-3步为第一个阶段，是由“领域驱动设计”原落地方案中的“事件风暴”环节演变而来。分别为“企业全量业务目标分解”、“企业全量业务功能风暴”和“企业全量业务功能拓展”。
①目标：梳理清楚“中台”所需支持的业务功能边界。
②输出物：企业全量业务功能蓝图（ER图或类图）。
业务功能版图示例，图片来自网络
③具体流程：
1.第一步：企业全量业务目标分解。
（1）在进行业务目标分解时需要优先关心其在商业上的横向拓展。以下为我个人总结的几个拓展点：
上下游业务拓展：比如犀牛制造和菜鸟物流之于淘宝 。资源变现：比如滴滴搞外卖 。数据变现：比如抖音、微信的用户标签等 。流量变现：比如抖音、微信的引流服务等 。 （2）具体到某个业务线、或体系下，业务功能都是通过解决一个一个小问题再最终解决小问题背后的大问题的，所以这里业务目标最好是采用金字塔模型来进行梳理。以营销体系为例：
①营销的最终目标是“卖更多的东西”，其子目标可以分为“让更多人买东西”、“让人买更多东西”；
②“让更多人买东西”的子目标可以继续分为“拉新”、“给用户洗脑”、“推荐合适的商品”；“让人买更多东西”的子目标可以继续分为“给用户洗脑”、“推荐合适的商品”；
③ “给用户洗脑”的子目标又可以继续分为“提升品牌好感度”、“提升产品认知度”、“提升购物积极性”等…
虽然我们在“中台”设计过程中，业务目标划分的越细越好，不过业务子目标的分解也不是无限制的，最终状态的子目标会有着鲜明的场景化特征，大致可以用以下模型表示。比如：连锁零售商总部营销部门在“女性用户”“非首次”情况下通过“APP”购买“任意”商品时向其发放“肯德基10代金券”，以提高用户通过APP下单的积极性 。 2.第二步：企业全量业务功能风暴
即对照“业务目标金字塔模型”对已有业务功能进行梳理，输出已有全量业务功能版图。要求精确到实体，在操作本环节时，以下几点需要注意：
（1）前文说明“数据孤岛”问题时提到过关系数据的重要性，所以在进行已有全量业务功能版图梳理时，关系型实体或字段务必要梳理清楚，不能遗漏，比如订单触发积分发放的记录等。
（2）一般来说因为缺乏专业化职能分工设计，业务系统中会出现大量以下类型的临时方案：
人机交互型临时方案：比如业务场景没有定义好，在使用某服务时由人工录入服务的使用场景 。
在代码中埋数据的临时方案：比如某店铺的银行卡信息直接写死。 在进行业务功能风暴时，此类临时方案一定要还原成通用方案。
3.第三步：企业全量业务功能拓展
即对照“业务目标金字塔模型”，基于第二步中输出的已有全量业务功能版图，梳理未来还可能会有哪些业务功能。因为“中台”在应用时处于底层，会被很多上层业务系统集成，如果“中台”没有做好前瞻性设计，后续迭代风险会比较大。以下为我个人总结的几种拓展点：
（1）业务功能细化拓展：在数据层面表现为字段取值范围的增加，比如客户类型的枚举值从“个人客户”增加到“个人客户,机构客户”，即表示目标客户从个人客户拓展到了机构客户。另外抛开约束性校验和界面交互，所以软件的底层功能有且仅有对某实体某字段的增删改查，即每个实体天然有“字段数量*增删改查”个功能。
（2）业务功能闭环性拓展：这一项主要是基于面向对象中的组合思想进行的拓展，即解决某一问题时可能需要多个功能组合完成，我们据此判断缺失了哪个功能。比如要达成用户激励，光有积分发放是不行的，还得需要积分消费功能。
（3）业务功能依赖/约束性拓展：在数据层面表现为实体字段的增删改查需要从外部数据源取数或对外部数据源进行校验。比如物流单中商品信息就需要从商品模块获取，用户下单时需要对商品库存数量进行校验
（4）业务功能支撑性拓展：即为了让业务更好的开展而进行的业务功能拓展。比如为了提高打开某文章的概率，我们会开发阅读指定文章送积分的功能。
（5）业务功能纵向拓展：在数据层面表现为对实体及其属性、方法、实体间关系进行定义。比如设置积分的面值，进行用户操作权限授权等。
（6）业务功能解耦分化型拓展：在数据层面表现为实体的拆分。比如有些车企自建的整车商城，包含汽车交易及汽车物权管理两条业务线，为了保障业务灵活度，最好就是将整车交易单拆分为商品交易单和物权转让单。
经过上面一番猛如虎的操作后，正常来说我们应该可以得到一张比较全面的业务功能蓝图（ER图或类图），接下来我们将进入第二个阶段，开始“中台”的划分工作。
（2）第二阶段：
第4-8步为第二个阶段，是基于“领域驱动设计”原落地方案中的“聚合”概念拓展而来。分别为“关键属性定义”、“实体抽象合并”、“可复用业务定义”、“中台边界划分”和“中台边界修正”。
①目标：进行“中台”的专业化职能模块划分，并调优。
②输出物：“中台”产品架构图。
③具体流程：
4.第四步，关键属性定义。
每个业务都有很多附加功能，这使得这些业务对应的实体会有很多属性，但实际上每个实体都仅有少量的几个关键属性定义了“它是它”。实体的属性过多会对实体间的关系整理形成干扰，所以我们需要找出每个实体的关键属性。关于什么是核心属性，我这里举几个例子。
商品的核心属性：价格，关联物品或产品编码 。 权益的核心属性：标的物、抵扣规则及面值 。订单的核心属性：买卖双方、交易额、交易商品、成交数量、成交单价 。
5.第五步，实体抽象合并。
按照“多同一不”（上篇文章有说明）原则，我们需要根据某一个“模型、方法”是否服务于不同的“对象”来进行专业化分工。所以需要把相关实体进行抽象合并，保障各类实体的唯一性。因为我们在第四步“关键属性定义”中找到了各实体的关键属性，这一步就相对容易。这个环节有一点需要注意：
因为缺乏规范，可能明明相同的实体，但关键属性的命名却完全不一样，这可能导致将其分成了两个实体，所以在对实体关键属性定义时需要多检查几遍。 6.第六步，可复用业务定义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6e737d4c638b86ef16aeda67ac795ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d59445402e9ad1561a846a00ac0c0e5c/" rel="bookmark">
			js 封装时间戳转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步
建一个js文件放以下代码
export function formatDate(date, fmt) { if (/(y+)/.test(fmt)) { fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '') .substr(4 - RegExp.$1.length)); } let o = { 'M+': date.getMonth() + 1, 'd+': date.getDate(), 'h+': date.getHours(), 'm+': date.getMinutes(), 's+': date.getSeconds() }; for (let k in o) { if (new RegExp(`(${k})`).test(fmt)) { let str = o[k] + ''; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str)); } } return fmt; } 注意
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d59445402e9ad1561a846a00ac0c0e5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02f1a35888b3ac8574b3595cebabe428/" rel="bookmark">
			1024纪念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅以庆祝1024，各位道友程序员节快乐🦆
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b9e984e709dffc8ae8c49d8f7d636d/" rel="bookmark">
			用了这么多年分页PageHelper，才发现自己一直用错了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方蓝色字体，选择“标星公众号”
优质文章，第一时间送达 关注公众号后台回复pay或mall获取实战项目资料+视频 作者：臣不贰
blog.csdn.net/NOT_TWO_CHEN/article/details/109230267
一. 开发准备 1. 开发工具 IntelliJ IDEA 2020.2.3
2. 开发环境 Red Hat Open JDK 8u256
Apache Maven 3.6.3
3. 开发依赖 SpringBoot
“ &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 1234 ” MyBatis
“ &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; 12345 ” PageHelper
“ &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; 12345 ” 二. 技术文档 1. 基于SpringBoot SpringBoot 官方文档 https://spring.io/projects/spring-boot
SpringBoot 中文社区 https://springboot.io/
2. 基于MyBatis MyBatis 官方文档 https://mybatis.org/mybatis-3/zh/index.html
3. 集成PageHelper PageHelper 开源仓库 https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3b9e984e709dffc8ae8c49d8f7d636d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ec0cd4f0d0b85e299142766cdd6985/" rel="bookmark">
			推荐系统入门（三）：矩阵分解MF&amp;因子分解机FM（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐系统入门（三）：矩阵分解MF&amp;因子分解机FM（附代码） 目录 推荐系统入门（三）：矩阵分解MF&amp;因子分解机FM（附代码）一、 矩阵分解MF1. 隐含语义分析技术1.1 隐语义模型1.2 矩阵分解算法1.3 矩阵分解算法求解 2. Funk-SVD算法3. Bias SVD算法4. 编程实现思考 二、 因子分解机FM1. FM模型的引入1.1 逻辑回归模型及其缺点1.2 二阶交叉项的考虑及改进 2. FM公式的理解3. FM模型的应用4. 代码实践4.1 调包实现4.1.1 电影评分数据集实战4.1.2 分类任务实战 4.2 从零实现 思考 三、实战参考资料 相关系列笔记： 推荐系统入门（一）：概述 推荐系统入门（二）：协同过滤（附代码） 推荐系统入门（三）：矩阵分解MF&amp;因子分解机FM（附代码） 推荐系统入门（四）：Wide&amp;Deep（附代码） 推荐系统入门（五）：GBDT+LR（附代码） 推荐系统入门（六）：新闻推荐实践1（附代码） 推荐系统入门（七）：新闻推荐实践2（附代码） 推荐系统入门（八）：新闻推荐实践3（附代码） 推荐系统入门（九）：新闻推荐实践4（附代码） 推荐系统入门（十）：新闻推荐实践5（附代码） 一、 矩阵分解MF 矩阵分解(Matrix Factorization，MF)技术实际上就是把用户-项目评分矩阵分解为若干个部分的组合，它在 Netfilx公司举办的推荐系统大赛上得到了广泛的应用，基于矩阵分解的推荐算法本质上是一种基于模型的协同过滤推荐算法。
基于矩阵分解的推荐算法,实现简单，预测准确度高,扩展性强，在一定程度上缓解了数据的稀疏性问题，但可解释性差。
1. 隐含语义分析技术 随着用户和项目数量的急剧增长,用户和项目之间评分矩阵的维度也在在急剧增加。而由此带来的问题是计算用户与用户、项目与项目之间相似度矩阵的速度越来越慢，计算问题成为推荐系统的瓶颈。此外，随着评分矩阵越来越稀疏，推荐精度也会受到严重的影响。
对推荐系统研究过程中有很多人提出给用户或项目进行分类，但是根据传统的推荐算法很难真正发掘出用户用户潜在的兴趣度。为了解决这个问题研究人员提出从数据出发，自动找出项目的分类信息和用户的兴趣度信息。因此，隐含语义分析技术(Latent Variable Analysis） 就出现了。
隐语义模型（Latent Factor Model，LFM) 这个概念是由Netflix Prize冠军Koren在2006年提出的。隐语义模型使用一种替代的法则来发现潜在的主题或分类。隐含语义分析技术从诞生至今产生了很多著名的模型和算法。其中和该项技术相关且耳熟能详的名词有隐含主题模型(latent topic model)24、矩阵分解(matrix factorization)、pLSA、LDA 等。
协同过滤算法的特点就是完全没有利用到物品本身或者是用户自身的属性，仅仅利用了用户与物品的交互信息就可以实现推荐，是一个可解释性很强，非常直观的模型，但是也存在一些问题， 第一个就是处理稀疏矩阵的能力比较弱，所以为了使得协同过滤更好处理稀疏矩阵问题， 增强泛化能力， 从协同过滤中衍生出矩阵分解模型或者叫隐语义模型, 两者差不多说的一个意思，就是在协同过滤共现矩阵的基础上， 使用更稠密的隐向量表示用户和物品，挖掘用户和物品的隐含兴趣和隐含特征，在一定程度上弥补协同过滤模型处理稀疏矩阵能力不足的问题。
1.1 隐语义模型 隐语义模型最早在文本领域被提出，用于找到文本的隐含语义。在2006年， 被用于推荐中， 它的核心思想是通过隐含特征（latent factor）联系用户兴趣和物品（item）， 基于用户的行为找出潜在的主题和分类， 然后对item进行自动聚类，划分到不同类别/主题(用户的兴趣)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53ec0cd4f0d0b85e299142766cdd6985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7cbf5361ca8a2e820e88e467a39289a/" rel="bookmark">
			Python数据解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 lxml库
基本使用：我们可以用它来解析HTML代码，并且在解析html代码的时候，如果HTML代码不规范，它会自动进行补全。
test=''' &lt;div&gt; &lt;url&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;forth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/url&gt; &lt;/div&gt; ''' from lxml import etree html=etree.HTML(test) #初始化text 将字符串解析成HTML文档 result=etree.tostring(html).decode('utf-8') #按字符串序列化html。返回的是字节型，所以需要.decode('utf-8') print(result) 得到的结果：
&lt;html&gt;&lt;body&gt;&lt;div&gt; &lt;url&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;forth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/url&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 我们还可以从文件中读取html代码：
html=etree.parse('hello.html') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/499e2af7d7b3b369bda882ec815558d7/" rel="bookmark">
			springboot&#43;dubbo&#43;zk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot+dubbo+zk 注意
关于Curator连接Zookeeper对应版本
Versions The are currently two released versions of Curator, 2.x.x and 3.x.x: Curator 2.x.x - compatible with both ZooKeeper 3.4.x and ZooKeeper 3.5.x Curator 3.x.x - compatible only with ZooKeeper 3.5.x and includes support for new features such as dynamic reconfiguration, etc. 正文
目录结构 dubbo pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.gohb&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;dubbo_api&lt;/module&gt; &lt;module&gt;dubbo_provider&lt;/module&gt; &lt;module&gt;dubbo_consumer&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/499e2af7d7b3b369bda882ec815558d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a5f5ad592abaae6cda35a91a5f8ada6/" rel="bookmark">
			正整数的因子数和因子和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正整数的因子数和因子和 算术基本定理 对于一个正整数N，可分解成 N= p 1 a 1 p1^{a1} p1a1 p 2 a 2 p2^{a2} p2a2 p 3 a 3 p3^{a3} p3a3… p n a n pn^{an} pnan 那么正因数个数 num=(1+a1)(1+a2)…(1+an) 例如 24= 2 3 ∗ 3 2^3*3 23∗3
num=(3+1)*(1+1)=8
因数，2可以取0,1,2,3个，3可以取0,1个
搭配数4*2
正因数之和 由上知，每个因子大小即 p 1 b 1 p1^{b1} p1b1 p 2 b 2 p2^{b2} p2b2 p 3 b 3 p3^{b3} p3b3… p n b n pn^{bn} pnbn bn为取的pn的个数
bn可取0,1,2,3…an
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a5f5ad592abaae6cda35a91a5f8ada6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a1728cde3f1e3eabf7048b609b654d0/" rel="bookmark">
			libpng warning: iCCP: cHRM chunk does not match sRGB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		libpng warning: iCCP: cHRM chunk does not match sRGB
中文大致意思：警告，HRM和RGB不匹配
解决办法：把QQ输入法换成别的输入法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/980850422adf4be4c9f830d10782b8a9/" rel="bookmark">
			VS2019  cout输出到控制台窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设置 “项目 -&gt; 属性 -&gt; 生成事件 -&gt;后期生成事件 -&gt; 命令行” 中添加：
editbin /SUBSYSTEM:CONSOLE $(OutDir)\$(ProjectName).exe 如下图：
二、运行 一个控制台窗口输出调试信息，一个正常运行的软件界面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db5af8bf32f8f34a6a6b2961ff245e4/" rel="bookmark">
			【转载】堆排序算法（图解详细流程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堆排序的时间复杂度O(N*logN),额外空间复杂度O(1)，是一个不稳定性的排序
目录
一 准备知识
1.1 大根堆和小根堆
二 堆排序基本步骤
2.1 构造堆
2.2 固定最大值再构造堆
三 总结
四 代码
一 准备知识 堆的结构可以分为大根堆和小根堆，是一个完全二叉树，而堆排序是根据堆的这种数据结构设计的一种排序，下面先来看看什么是大根堆和小根堆
1.1 大根堆和小根堆 性质：每个结点的值都大于其左孩子和右孩子结点的值，称之为大根堆；每个结点的值都小于其左孩子和右孩子结点的值，称之为小根堆。如下图
我们对上面的图中每个数都进行了标记，上面的结构映射成数组就变成了下面这个样子
还有一个基本概念：查找数组中某个数的父结点和左右孩子结点，比如已知索引为i的数，那么
1.父结点索引：(i-1)/2（这里计算机中的除以2，省略掉小数）
2.左孩子索引：2*i+1
3.右孩子索引：2*i+2
所以上面两个数组可以脑补成堆结构，因为他们满足堆的定义性质：
大根堆：arr(i)&gt;arr(2*i+1) &amp;&amp; arr(i)&gt;arr(2*i+2)
小根堆：arr(i)&lt;arr(2*i+1) &amp;&amp; arr(i)&lt;arr(2*i+2)
二 堆排序基本步骤 基本思想：
1.首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端
2.将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为n-1
3.将剩余的n-1个数再构造成大根堆，再将顶端数与n-1位置的数交换，如此反复执行，便能得到有序数组
2.1 构造堆 将无序数组构造成一个大根堆（升序用大根堆，降序就用小根堆）
假设存在以下数组
主要思路：第一次保证0~0位置大根堆结构（废话），第二次保证0~1位置大根堆结构，第三次保证0~2位置大根堆结构...直到保证0~n-1位置大根堆结构（每次新插入的数据都与其父结点进行比较，如果插入的数比父结点大，则与父结点交换，否则一直向上交换，直到小于等于父结点，或者来到了顶端）
插入6的时候，6大于他的父结点3，即arr(1)&gt;arr(0)，则交换；此时，保证了0~1位置是大根堆结构，如下图：
(友情提示：待交换的数为蓝色，交换后的数为绿色)
插入8的时候，8大于其父结点6，即arr(2)&gt;arr(0),则交换；此时，保证了0~2位置是大根堆结构，如下图
插入5的时候，5大于其父结点3，则交换，交换之后，5又发现比8小，所以不交换；此时，保证了0~3位置大根堆结构，如下图 插入7的时候，7大于其父结点5，则交换，交换之后，7又发现比8小，所以不交换；此时整个数组已经是大根堆结构 2.2 固定最大值再构造堆 此时，我们已经得到一个大根堆，下面将顶端的数与最后一位数交换，然后将剩余的数再构造成一个大根堆
（友情提示：黑色的为固定好的数字，不再参与排序） 此时最大数8已经来到末尾，则固定不动，后面只需要对顶端的数据进行操作即可，拿顶端的数与其左右孩子较大的数进行比较，如果顶端的数大于其左右孩子较大的数，则停止，如果顶端的数小于其左右孩子较大的数，则交换，然后继续与下面的孩子进行比较
下图中，5的左右孩子中，左孩子7比右孩子6大，则5与7进行比较，发现5&lt;7，则交换；交换后，发现5已经大于他的左孩子，说明剩余的数已经构成大根堆，后面就是重复固定最大值，然后构造大根堆
如下图：顶端数7与末尾数3进行交换，固定好7，
剩余的数开始构造大根堆 ，然后顶端数与末尾数交换，固定最大值再构造大根堆，重复执行上面的操作，最终会得到有序数组
三 总结 到这里，大家应该对堆排序都有了自己的见解，我们对上面的流程总结下：
1、首先将无需数组构造成一个大根堆（新插入的数据与其父结点比较）
2、固定一个最大值，将剩余的数重新构造成一个大根堆，重复这样的过程
四 代码 代码中主要两个方法：
1、将待排序数组构造成一个大根堆（元素上升）
2、固定一个最大值，将剩余的数再构造成一个大根堆（元素下降）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2db5af8bf32f8f34a6a6b2961ff245e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f42c161bb488b2e0fcae47516647f51/" rel="bookmark">
			vs2019 下oracle proc配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、proc集成到vs2019二、proc配置中包含vs2019头文件三、设置demo.pc 属性四、源码 前言 pro*c/c++ 程序 从源码demo.pc 到可执行程序需要经过两次编译。第一次oracle 公司提供的proc编译 把demo.pc编译成 demo.c 或者demo.cpp ,第二次由vs中gcc编译器把demo.c编译链接成demo.exe执行文件 。所以需要在vs中集成proc编译相关配置，而第一次编译时，proc编译器要进行c/c++相关的语法 词法分析 ，也就需要告诉proc按哪个版本的vs相关的头文件进行生成demo.c文件，以便vs进行第二次编译
一、proc集成到vs2019 需要添加 :.proc.exe， precomp头文件目录和库文件目录 ，oci头文件和库文件目录 及precomp动态库
添加proc.exe 目录
默认安装Oracle时添加了环境变量，可以不用添加。工程项目右键–&gt;属性–&gt;配置属性–&gt; vc++目录–&gt;常规–&gt;可执行文件目录 头文件目录
工程项目右键–&gt;属性–&gt;配置属性–&gt; vc++目录–&gt;常规–&gt;包含目录
库目录
工程项目右键–&gt;属性–&gt;配置属性–&gt; vc++目录–&gt;常规–&gt;库目录
链接库
工程项目右键–&gt;属性–&gt;配置属性–&gt;连接器–&gt;输入–&gt;附加依赖项 添加orasql12.lib ,并把该库拷贝到项目路径下
二、proc配置中包含vs2019头文件 更改D:\app\oracle\product\12.2.0\dbhome_1\precomp\admin 下的 pcscfg.cfg配置文件 proc.exe 编译时需要vs相关头文件
三、设置demo.pc 属性 -. c文件
右键demo.pc 文件–&gt;属性–&gt;常规–&gt;项目类型–&gt;自定义生成工具 点击应用
自定义生成工具–&gt;命令行 ：proc demo.pc
自定义生成工具–&gt;输出 ：demo.c
.c++文件
右键demo.pc 文件–&gt;属性–&gt;常规–&gt;项目类型–&gt;自定义生成工具 点击应用
自定义生成工具–&gt;命令行 ：proc demo.pc parse=none code=cpp oname=demo.cpp
自定义生成工具–&gt;输出 ：demo.cpp
编译会报error C3861: “gets”: 找不到标识符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f42c161bb488b2e0fcae47516647f51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cced64443cc9f963eaa1cc36357227f2/" rel="bookmark">
			C&#43;&#43;的placement new
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.new new operator就是new操作符，不能被重载，假如A是一个类，那么A * a=new A;实际上执行如下3个过程。 （1）调用operator new分配内存，operator new (sizeof(A)) （2）调用构造函数生成类对象，A::A() （3）返回相应指针 事实上，分配内存这一操作就是由operator new(size_t)来完成的，如果类A重载了operator new，那么将调用A::operator new(size_t )，否则调用全局::operator new(size_t )，后者由C++默认提供。 二.operator new operator new是函数，分为三种形式（前2种不调用构造函数，这点区别于new operator）： void* operator new (std::size_t size) throw (std::bad_alloc); void* operator new (std::size_t size, const std::nothrow_t&amp; nothrow_constant) throw(); void* operator new (std::size_t size, void* ptr) throw(); 第一种分配size个字节的存储空间，并将对象类型进行内存对齐。如果成功，返回一个非空的指针指向首地址。失败抛出bad_alloc异常。 第二种在分配失败时不抛出异常，它返回一个NULL指针。 第三种是placement new版本，它本质上是对operator new的重载，定义于#include &lt;new&gt;中。它不分配内存，调用合适的构造函数在ptr所指的地方构造一个对象，之后返回实参指针ptr。 第一、第二个版本可以被用户重载，定义自己的版本，第三种placement new不可重载。 A* a = new A; //调用第一种 A* a = new(std::nothrow) A; //调用第二种 new (p)A(); //调用第三种 new (p)A()调用placement new之后，还会在p上调用A::A()，这里的p可以是堆中动态分配的内存，也可以是栈中缓冲。 下面是重载operator new的一个例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cced64443cc9f963eaa1cc36357227f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d4171da0c4c4e3851015e08c20936de/" rel="bookmark">
			智能文本处理利器文心（ERNIE），助您高效定制NLP模型！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，百度语义理解平台文心（ERNIE）迎来重磅升级。新增文本实体抽取任务，升级定制文本分类网络，并在训练能力、部署方式等方面进行了一系列改进，进一步提升了NLP模型开发效率，开发者可在零门槛AI开发平台EasyDL体验文心新功能。
文心（ERNIE）是依托百度深度学习平台飞桨打造的语义理解技术与平台，集先进的预训练模型、全面的NLP算法集、端到端开发套件和平台化服务于一体，为企业和开发者提供一整套NLP定制与应用能力。
文心（ERNIE）官网地址：
wenxin.baidu.com
为了让文心（ERNIE）的世界级技术突破转化为企业发展动能，在产业应用中发挥更大价值，文心还通过EasyDL平台提供了一整套简单高效的NLP开发能力。
EasyDL是百度大脑推出的零门槛AI开发平台，基于百度自主研发的深度学习平台飞桨，结合业界先进的工程服务技术打造，覆盖视觉与自然语言处理两大技术方向，支持一站式智能标注、模型训练、服务部署等全流程功能。开发者无须了解算法细节，最快5分钟即可上手定制模型。
图1：EasyDL文本处理开发服务全景图
截至目前，搭载文心的EasyDL文本处理能力调用量峰值超百万次，服务超千家合作伙伴，应用覆盖金融、安防、文创等多个领域，已助力众多企业迈出了智能化转型的关键一步。
此次文心在EasyDL文本处理功能上主要升级的功能如下：
新增文本实体抽取任务 “文本实体抽取”作为文本挖掘和信息抽取的核心任务，支持从海量信息源中抽取出特定的事实信息，是信息检索、智能问答、智能对话等人工智能应用的重要基础。
文心全新上线的“文本实体抽取“任务，可以满足对文本中的命名实体进行快速有效的识别，比如抽取金融类文本中的企业主体、交易信息等。为提升该项能力的易用性，文心还提供系列配套开发服务，助力开发者更便捷地去完成。
在线智能标注，节约成本：针对数据准备难题，文心发布了“文本实体抽取”任务的数据标注工具，支持在文本中直接划选进行标注，给标注人员带来极佳的标注体验和更高的标注效率。
图2：文本实体抽取智能标注示意图
两种训练方案，弹性选择：开发者根据数据量情况灵活选择训练方案。若您准备的数据量较少（少于1000条），使用“**高精度”**算法会获得更好的训练效果；若您准备的数据量较充足，则可以使用“**高性能”**算法来训练模型，训练时长短，预测性能快。
预置模型与网络，开发更易：平台专业版在模型配置中，可以选择效果更优的ERNIE预训练模型和对应的预置网络，并支持网络代码修改，从源码级别提升模型定制灵活性，极大释放专家们的创造力。
升级文本分类-单标签任务 “文本分类”可对文本内容进行自动分类和打标签。如在新闻推荐领域，《湖人大胜热火4-2夺第17座总冠军》属于体育类，《国家统计局4月CPI同比上涨3.3%》则属于经济类。
本次平台升级了文本分类（单标签任务）的模型网络，也提供高精度和高性能两种训练方案。基于平台提供的公开数据集（分类任务），使用“高精度”算法可得到90%以上的准确率；对于1W条以上的数据量，使用“高性能“算法可获得极致速度体验（通常15分钟左右可完成训练）。选择合理的训练方案，让模型训练达到事半功倍的效果。
提供更多高效开发能力 增加多机训练能力，加速模型训练
平台丰富了文本处理的多机训练能力，支持V100和P40两种GPU机型的训练方式，多个计算节点，加速模型训练；此外，平台还免费为每一位用户提供了50个小时的训练时长，0成本体验平台。
支持直接申请私有服务器部署，部署更快捷
此前，EasyDL文本处理已整合多种部署方式，包括弹性扩容的公有云API部署，通用设备端SDK与专项硬件适配SDK，本次优化还新增了模型本地私有服务器部署方式，可快速申请和获得所需的部署包，提供企业更多的AI落地方式选择。
图3：私有服务器部署入口
新增模型售卖与购买功能，节省成本提升效率
平台支持用户将训练好的“情感倾向分析”高精度算法模型发布到AI市场，供其他用户购买和再训练，开启模型交易新范式。您既可以作为模型的发布者，也可以是模型的购买者。对于已购买的模型，可以直接再训练和部署，大幅降低开发成本，并获得可预见的高精度模型效果。
图4：AI模型市场示意图
以上是本次升级带来的新增能力，欢迎点击“阅读原文”进入官网查看更多信息！深度学习背景下，实现NLP简单开发，就来EasyDL平台用文心！
未来，文心（ERNIE）将持续依托百度领先的技术实力，进一步释放AI技术的赋能效率，以更简单、普惠的方式进入NLP开发者世界，助力开发者创造更高商业价值。有合作意向的开发者/企业可通过文心（ERNIE）QQ群1097307223，联系我们~
EasyDL零门槛模型训练营 想了解强大文心（ERNIE）背后的技术原理？
想更进一步快速掌握NLP模型开发方法与技巧？
想线下和百度资深研发与各行业开发者深度沟通？
百度AI快车道【EasyDL零门槛模型训练营】来了，百度资深研发工程师详解NLP技术能力，从文心（ERNIE）技术解析到EasyDL实战演练，为你解读如何定制企业高精度NLP模型，并带来现场实操与面对面答疑解惑，带你三小时掌握EasyDL的NLP模型开发秘籍！
活动时间：10月24日（本周六）
活动地点：上海徐汇区复兴路1199号A座5层
11月7日，百度AI快车道【NLP技术专场】还将登陆“成都”，感兴趣的开发者也可扫描上方二维码提前报名！名额有限，快快报名吧！
百度自然语言处理（Natural Language Processing，NLP）以『理解语言，拥有智能，改变世界』为使命，研发自然语言处理核心技术，打造领先的技术平台和创新产品，服务全球用户，让复杂的世界更简单。!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbb1c934918f407adcced1e226b5edca/" rel="bookmark">
			OSS对象存储 STS Token 时长和个数限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Error code: InvalidParameter.DurationSeconds
Error message: The Min/Max value of DurationSeconds is 15min/1hr.
以上是一条有关STS token 的时长设置。最短15分钟，最长1小时。
相关函数 AssumeRoleRequest.setDurationSeconds(long)。那么这个long类型参数的设置范围就只能在 60*15L到60*60L范围。
同时，STS，一个主账号包括RAM子账号也只能同时存在100个，所以后台要自行维护token的量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8757846aeec2be5ec7186e5ef9e79136/" rel="bookmark">
			.net core3.1发布后生成了多余语言文件夹cs,de,es,fr...怎么去除,让发布后不在有这些文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 .net core3.1发布后生,生成上图红框里那些无用的文件夹,用下面的方式可以解决: 1.右键点击你的.net core项目web层,在点击[编辑项目文件] 2.找到&lt;PropertyGroup&gt;标记,在下面,添加 &lt;SatelliteResourceLanguages&gt;zh-Hans&lt;/SatelliteResourceLanguages&gt;,在发布,就不会出现那些语言文件夹了. 产生这些文件夹的原因是因为,包Microsoft.VisualStudio.Web.CodeGeneration.Design造成的. 给大家推荐一个微信小程序:面试一点通丨模拟面试 模拟笔试 收录了Java,C#,.net core,php等语言最新的面试题. 微信扫一扫即可免费使用,助你跳槽,升职,加薪成功. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c60f75004c5eed8005d9bba7a718a9a7/" rel="bookmark">
			不得了不得了，这款开源类库可以帮你简化每一行代码，服了服了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“黑铁时代”读者群里有个小伙伴感慨说，“Hutool 这款开源类库太厉害了，基本上该有该的工具类，它里面都有。”讲真的，我平常工作中也经常用 Hutool，它确实可以帮助我们简化每一行代码，使 Java 拥有函数式语言般的优雅，让 Java 语言变得“甜甜的”。
但是呢，群里还有一部分小伙伴表示还不知道这个开源类库，第一次听说。所以我决定写一篇文章普及下，毕竟好的轮子值得推荐啊。
Hutool 的作者在官网上说，Hutool 是 Hu+tool 的自造词（好像不用说，我们也能猜得到），“Hu”用来致敬他的“前任”公司，“tool”就是工具的意思，谐音就有意思了，“糊涂”，寓意追求“万事都作糊涂观，无所谓失，无所谓得”（一个开源类库，上升到了哲学的高度，作者厉害了）。
看了一下开发团队的一个成员介绍，一个 Java 后端工具的作者竟然爱前端、爱数码，爱美女，嗯嗯嗯，确实“难得糊涂”（手动狗头）。
就连向这个开源类库提交的 PR（pull request）规范都非常“病态化”（哈哈哈）：
废话就说到这，来吧，实操走起！
01、引入 Hutool Maven 项目只需要在 pom.xml 文件中添加以下依赖即可。
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.4.3&lt;/version&gt; &lt;/dependency&gt; Hutool 的设计思想是尽量减少重复的定义，让项目中的 util 包尽量少。一个好的轮子可以在很大程度上避免“复制粘贴”，从而节省我们开发人员对项目中公用类库和公用工具方法的封装时间。同时呢，成熟的开源库也可以最大限度的避免封装不完善带来的 bug。
就像作者在官网上说的那样：
以前，我们打开搜索引擎 -&gt; 搜“Java MD5 加密” -&gt; 打开某篇博客 -&gt; 复制粘贴 -&gt; 改改，变得好用些 有了 Hutool 以后呢，引入 Hutool -&gt; 直接 SecureUtil.md5()
Hutool 对不仅对 JDK 底层的文件、流、加密解密、转码、正则、线程、XML等做了封装，还提供了以下这些组件：
非常多，非常全面，鉴于此，我只挑选一些我喜欢的来介绍下（偷偷地告诉你，我就是想偷懒）。
02、类型转换 类型转换在 Java 开发中很常见，尤其是从 HttpRequest 中获取参数的时候，前端传递的是整形，但后端只能先获取到字符串，然后再调用 parseXXX() 方法进行转换，还要加上判空，很繁琐。
Hutool 的 Convert 类可以简化这个操作，可以将任意可能的类型转换为指定类型，同时第二个参数 defaultValue 可用于在转换失败时返回一个默认值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c60f75004c5eed8005d9bba7a718a9a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cfb597328f4a59fc4c46d19c5d6d274/" rel="bookmark">
			嵌入式算法4---正态分布过滤疏忽误差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测量系统中误差分为系统误差、随机误差、疏忽误差三种。系统误差一般是硬件精度或缺陷导致；随机误差是偶然产生，诸多外界因素微小变化共同导致，它服从统计规律的；疏忽误差则无规律可循，且明显和事实不符合。
疏忽误差的样本值偏离了总体的平均值，在样本足够多且服从正态分布的情况下，通过一系列数理统计算法过滤坏样本。
正态分布的68-95-99.7规则
均值到左一和右一个标准差之间的定积分值是68%
均值到左二和右二个标准差之间的定积分值是95%
均值到左三和右三个标准差之间的定积分值是99.7%
一般情况下认为，某个采样值与均值的差值大于3倍标准差，即可判定该采样值为坏样本。
#include "math.h" #define SAMPLE_NUM 100 int sample[SAMPLE_NUM];//假设已经采集的SAMPLE_NUM个样本已经缓存再数组 int average;//平均值 int standard;//标准差 int sample_num=SAMPLE_NUM;//有效的样本个数，初始是SAMPLE_NUM int filter(void) { int i,d; int low,high; int sum=0; for(i=0;i&lt;sample_num;i++) { sum+=sample[i]; } average=sum/SAMPLE_NUM;//平均值 //---------------------------------------------- for(i=0;i&lt;sample_num;i++) { d=sample[i]-average; sum=d*d+sum; } standard=sqrt(sum/SAMPLE_NUM);//标准差 //---------------------------------------------- //按99.7%的范围，合理的上限和下限是3倍的标准差 low=average-3*standard; high=average+3*standard; for(i=0;i&lt;sample_num;i++) { if((sample[i]&lt;low)||(sample[i]&gt;high)) { //坏样本 if(i&lt;sample_num-1) { sample[i]=sample[sample_num-1];//将最后一个样本前移覆盖坏样本 i--; } sample_num--; } } return sample_num;//剔除坏样本后剩下的有效样本数 } 通过正态分布的规则剔除异常样本，其前提是样本基数大。对于算法还可进一步改进，如果sample_num前后发生变化，表示sample[]样本发生了变化，可以再次递归执行过滤。
正态分布的规则不仅能过滤异常，对于控制监测也可应用，比如人体血压、心律检测，发现异常值则触发报警。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef74260f9f6c4f2000c630b8b17c3ca/" rel="bookmark">
			腾讯云服务器开放端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云服务器开放端口 腾讯云服务器默认是只开放部分端口，我们部署的服务需要监听一下80，8080等端口时，就需要自己设置安全策略，本文介绍如何设置腾讯云的安全组，开放需要的端口
步骤 点击腾讯云的控制台点击进入安全组菜单 点击进入安全组菜单，点击新建按钮，添加一个新的安全组，设置一些信息，点击确认
安全组添加一些策略 添加入站规则，配置了两个可以参考 开放了 22，80，443端口，一个开放了所有端口
添加出站规则，点击一键方通，开放所有端口
给服务器配置安全组 点击进入控制台实例菜单，找需要配置安全组的服务器，点击更多----&gt;安全组----&gt;
配置安全组----&gt;勾选刚刚添加的安全策略点击确认，完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9241870d1d84a66d6e7dfa97bf30c85d/" rel="bookmark">
			使用openmv实现识别任意物体（将opencv的xml模型转化为openmv的cascade模型并使用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此需求来源于我需要在openmv上做物体识别，但是openmv固件里面自带模型只有人脸（限正脸）和眼镜等等几个，如何使得openmv可以识别其他复杂物体?
我搜到了这篇文章（感谢原博主）：
OPENMV使用OPENCV的Haar Cascade的xml模型？
在这篇的指引下，我们可以在openmv的github仓库中发现，官方已经提供了将xml文件转换为cascade文件的python代码，在命令行中直接运行即可。
这里说明几个注意点：
文章中博主提到的python2版本才可以转换，目前已经不存在这个问题，本人python3.6，window10下，可以成功转换
转换过程中若有报错，则虽然在同目录下产生了cascade文件，但大概率是不能使用的，如果文件只有1kb，也大概率是不能使用的（说明没有数据嘛）
经过实践，xml文件源代码中，图片是20乘20 是能够成功转换并可用的必要不充分条件。也就是图片一定要20乘20，但20乘20的xml仍然有可能在转换过程中报错而使得模型不可用。
转换成功的cascade文件大小从10+k到100+k都有，这取决于xml的精度
下面附上一段简单的基于自转换文件识别人是否佩戴口罩的代码：（附带了一个串口发送识别物体坐标）
#by z5z5z5z56 2020.10 import sensor, time, image from pid import PID from pyb import UART #串口收发 #usart3 tx p4-----pb11 #usart3 rx p5-----pb10 uart = UART(3, 115200) uart.init(115200,bits=8,parity=None,stop=1)#8个数据位，一个停止位，无奇偶校验位 # Reset sensor sensor.reset() sensor.set_contrast(3)#设置相机图像对比度。-3至+3。 sensor.set_gainceiling(16)#设置相机图像增益上限。2, 4, 8, 16, 32, 64, 128。 # HQVGA and GRAYSCALE are the best for face tracking. sensor.set_framesize(sensor.HQVGA) sensor.set_pixformat(sensor.GRAYSCALE) #注意人脸识别只能用灰度图哦 # Load Haar Cascade加载Haar算子（识别目标的模型）保存到face_cascade # By default this will use all stages, lower satges is faster but less accurate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9241870d1d84a66d6e7dfa97bf30c85d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a51e56b925750910280d70ddfbfd689/" rel="bookmark">
			ehvierwer登录与不登录_《天涯明月刀手游》pc端手机端登录不进去如何解决 服务器已满快速解决方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读 天涯明月刀这款手游终于公测了，每个玩家都可以在这里创造属于自己的江湖世界，不同的人会有不同的旅程，所以想要拥有一段属于自己江湖旅程就一定不要错过天刀这款手游，不过这款游戏刚公测，有很多bug，不知道怎... 天涯明月刀这款手游终于公测了，每个玩家都可以在这里创造属于自己的江湖世界，不同的人会有不同的旅程，所以想要拥有一段属于自己江湖旅程就一定不要错过天刀这款手游，不过这款游戏刚公测，有很多bug，不知道怎么解决，很多玩家们都遇到了服务器已满的情况，这种bug怎么解决呢？快往下看吧！
服务器已满bug怎么解决 第一种情况，pc端遇到当前服务器已满，可前往推荐服务器哦！
如果我们遇到这种情况，应该是服务器里边的玩家太多了，官方优先让手机端的玩家先进去体验，然后才是pc端的玩家进去玩游戏。有一次九游小编在pc端遇到了这个问题，然后打开手机，用手机登录就很轻松的排进去了，根本不存在服务器已满的情况，其实就是官方为了给后边的服务器引流，让那些不想等待的人去新服玩。遇到这种情况的话我们等待就好了，有人下线的话我们就可以进去了。
第二种情况，手机端遇到遇到当前服务器已满，可前往推荐服务器哦！
九游小编遇到过这种情况，自己手机登录还是遇到这个页面，但是去别的服务器都可以进去，就是自己的号进不去自己玩的服务器。
然后朋友们都可以上线，就是自己上不去。
最后小编的解决方法是在登录界面挂着，挂了十几分钟以后再点登录就进去了。
小编总结了一下可能就是因为小编用小号玩的，官方判定小号不安全，信息异常，所以就不让登录了，甚至连预约礼包都不让领取。
后来九游小编用电脑挂了几个小时的小号qq，完善了资料，绑定了手机，更改了密码，才提升了账号的安全性，后来就没有遇到这种情况了。
九游小编总结 以上就是我们遇到了服务器已满的情况的解决方法了，小编看了看其他攻略，都说让玩家去别的服玩吧，这怎么可能呀，谁不想在人多的服务器玩呢，并且还在这里充钱了，所以各位玩家们还是看看小编的攻略吧，是有几率解决这个问题的，前期游戏的bug太多，无力吐槽。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ab53e2e3d7e095b8581062f48a42b4/" rel="bookmark">
			maven 常用指令集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven本质上是一个插件框架，并不执行任何具体的构建任务，它把所有这些任务都交给插件来完成。
作为开发利器的maven，为我们提供了十分丰富的命令，了解maven的命令行操作并熟练运用常见的maven命令还是十分必要的，即使譬如IDEA等工具给我提供了图形界面化工具，但其底层还是依靠maven命令来驱动的。因此，知其然，知其所以然，方能百战不殆。
Maven的命令格式如下： mvn [plugin-name]:[goal-name] 该命令的意思是：执行plugin-name插件的goal-name目标。
用户可以通过两种方式调用Maven插件的目标：
将插件目标与生命周期阶段lifecycle phase绑定，这样用户在命令行只是输入生命周期阶段而已，例如Maven默认将maven-compiler-plugin的compile目标与compile生命周期阶段绑定，因此命令mvn compile实际上是先定位到compile这一生命周期阶段，然后再根据绑定关系调用maven-compiler-plugin的compile目标。直接在命令行指定要执行的插件目标，例如mvnarchetype:generate就表示调用maven-archetype-plugin的generate目标，这种带冒号的调用方式与生命周期无关。 常用命令 命令描述mvn –version显示版本信息mvn clean清理项目生产的临时文件,一般是模块下的target目录mvn compile编译源代码，一般编译模块下的src/main/java目录mvn package项目打包工具,会在模块下的target目录生成jar或war等文件mvn test测试命令,或执行src/test/java/下junit的测试用例.mvn install将打包的jar/war文件复制到你的本地仓库中,供其他模块使用mvn deploy将打包的文件发布到远程参考,提供其他人员进行下载依赖mvn site生成项目相关信息的网站mvn eclipse:eclipse将项目转化为Eclipse项目mvn dependency:tree打印出项目的整个依赖树mvn archetype:generate创建Maven的普通java项目mvn tomcat:run在tomcat容器中运行web应用mvn jetty:run调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用 注意：运行maven命令的时候，首先需要定位到maven项目的目录，也就是项目的pom.xml文件所在的目录。否则，必以通过参数来指定项目的目录。
命令参数 上面列举的只是比较通用的命令，其实很多命令都可以携带参数以执行更精准的任务。
Maven命令可携带的参数类型如下：
1. -D 传入属性参数
比如命令：
mvn package -Dmaven.test.skip=true
以-D开头，将maven.test.skip的值设为true,就是告诉maven打包的时候跳过单元测试。同理，mvn deploy-Dmaven.test.skip=true代表部署项目并跳过单元测试。
2. -P 使用指定的Profile配置
比如项目开发需要有多个环境，一般为开发，测试，预发，正式4个环境，在pom.xml中的配置如下：
&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;qa&lt;/id&gt; &lt;properties&gt; &lt;env&gt;qa&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;pre&lt;/id&gt; &lt;properties&gt; &lt;env&gt;pre&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;env&gt;prod&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0ab53e2e3d7e095b8581062f48a42b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/655f37a71f460abff11db21133e075e4/" rel="bookmark">
			IntelliJ IDEA使用插件JRebel热部署(Mac和Windos都可以使用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IntelliJ IDEA使用插件JRebel热部署(Mac和Windos都可以使用 一、IDEA下载JRebel插件二、下载一个反向代理软件三、激活JRebel四、设置JRebel插件 一、IDEA下载JRebel插件 在Preference -&gt; Plugins处搜索下载后重启IDEA即可。
下载后一定要重启
二、下载一个反向代理软件 访问此 下载地址
windos用户下载 下载完双击就可以，先不要关闭
Mac用户下载
注意： Mac用户使用Safari下载，不要用Chrome，否则下载之后会把.dms后缀名去掉。
Mac用户启动反向代理软件
打开终端输入以下命令
#为该文件赋予可执行权限 chmod 777 '文件路径' # 执行该文件 $bash '文件路径' Tips：在Finder中选中反向代理工具文件后，按 Command + Option + C 即可复制文件路径；
文件路径名中请不要带空格，否则无法找到该文件。
运行工具后请不要关闭终端或使用 Control + C 中断执行
三、激活JRebel 在IDEA打开JRebel
我的已经破解了所以不一样，输入以下内容
#第一行输入 http://127.0.0.1:8888/d3545f42-7b88-4a77-a2da-5242c46d4bc2 第二行输入正确的邮箱格式，例如： test@123.com 提示：d3545f42-7b88-4a77-a2da-5242c46d4bc2为UUID,可以自己生成，并且必须是UUID才能通过验证，访问此网址获取 guid 并复制，也可以在百度搜索guid在线生成。
最后别忘了把JRebel设置为offline模式 点一下work offline，离线使用JRebel插件
四、设置JRebel插件 此时虽然安装好了JRebel并成功激活了，但是我们使用JRebel debug的时候，发现修改代码后，热部署不起作用。因为还需要设置两个地方
设置项目自动编译
设置 compiler.automake.allow.when.app.running
ctrl+shift+A 或者 help-&gt;find action…打开
搜索registry
找到 compiler.automake.allow.when.app.running 并✔
至此所有内容全部完成，如有问题欢迎留言交流！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ca9999dc1a9a4ac112d56415031ce40/" rel="bookmark">
			2020-CCPC秦皇岛赛区-A题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Greeting from Qinhuangdao 来源:ccpc 2020 女生赛(秦皇岛赛区）A题，测试平台PTA
题意： 给 r个红气球和 b 个蓝气球，从所有气球里面拿两个气球，都是红色的概率，用分数表示。
如果不可能拿到两个红色气球，输出 0/1 。
输入： 第一行一个 T表示测试组数。
之后每一行两个数字 r,b分别表示红蓝气球个数。
1≤T≤10
1≤r,b≤100
输出： "Case #x: y"格式输出答案，一行一个答案。
样例： 输入：
3 1 1 2 1 8 8 输出：
Case #1: 0/1 Case #2: 1/3 Case #3: 7/30 思路： 很友好的签到题呀⁝⁞⁝⁞ʕु•̫͡•ʔु☂⁝⁞⁝⁝
就是要注意约分哈。
公式就是
代码奉上：
#include&lt;bits/stdc++.h&gt; using namespace std; int main () { int t; scanf("%d",&amp;t); for(int o=1;o&lt;=t;o++) { int r; int b; scanf("%d%d",&amp;r,&amp;b); if(r&lt;2) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ca9999dc1a9a4ac112d56415031ce40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f873911725af9857a24634d9c10c144/" rel="bookmark">
			Android 9.0打开wifi时关闭热点流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因发现Android 9.0 会在打开wifi的时候去默认关闭热点，所以我们看下打开wifi的流程，和在哪里去关闭的热点
1 设置打开wifi会调用
frameworks\base\wifi\java\android\net\wifi\WifiManager.java
/** * Enable or disable Wi-Fi. * &lt;p&gt; * Applications must have the {@link android.Manifest.permission#CHANGE_WIFI_STATE} * permission to toggle wifi. * * @param enabled {@code true} to enable, {@code false} to disable. * @return {@code false} if the request cannot be satisfied; {@code true} indicates that wifi is * either already in the requested state, or in progress toward the requested state. * @throws {@link java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f873911725af9857a24634d9c10c144/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d090774a0eaecbe394fa23dcd468670/" rel="bookmark">
			nginx的事件处理worker_processes/worker_connections/worker_rlimit_nofile解释,查看cpu数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx事件处理模型 demo
events { use epoll; worker_connections 65535; multi_accept on; } worker_connections 下面有介紹multi_accept
告诉nginx收到一个新连·接通知后接受尽可能多的连接，默认是on，设置为on后，多个worker按串行方式来处理连接，也就是一个连接只有一个worker被唤醒，其他的处于休眠状态，设置为off后，多个worker按并行方式来处理连接，也就是一个连接会唤醒所有的worker，直到连接分配完毕，没有取得连接的继续休眠。当你的服务器连接数不多时，开启这个参数会让负载有一定的降低，但是当服务器的吞吐量很大时，为了效率，可以关闭这个参数。 开启高效传输模式 http { include mime.types; default_type application/octet-stream; …… sendfile on; tcp_nopush on; …… } Include mime.types ： 媒体类型,include 只是一个在当前文件中包含另一个文件内容的指令。default_type application/octet-stream ：默认媒体类型足够。sendfile on：开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。tcp_nopush on：必须在sendfile开启模式才有效，防止网路阻塞，积极的减少网络报文段的数量（将响应头和正文的开始部分一起发送，而不一个接一个的发送。） worker_processes worker_processes指令控制工作进程数：
worker_processes 1;
其默认值为1，这意味着NGINX只运行一个worker。 该值应根据可用内核数，磁盘，网络子系统，服务器负载等更改为最佳值。
一般设置为可用的(cpu)核心数。
或者，可以将其设置为auto。 这样nginx会自动根据核心数为生成对应数量的worker进程。
查看cpu数 lscpu cat /proc/cpuinfo | grep 'processor' | wc -l worker_connections 默认值为512.该指令设置单个worker进程最大打开的连接数
worker_rlimit_nofile 同时连接的数量受限于系统上可用的文件描述符的数量，因为每个套接字将打开一个文件描述符。 如果NGINX尝试打开比可用文件描述符更多的套接字，会发现error.log中出现Too many opened files的信息。
检查文件描述符(文件句柄数)
ulimit -a 文件资源限制的配置可以在/etc/security/limits.conf设置，针对root/user等各个用户或者*代表所有用户来设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d090774a0eaecbe394fa23dcd468670/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daceecbc0e832b18435334f2f3af5f4b/" rel="bookmark">
			实验2  用FFT对信号作频谱分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB R2020b v9.9.0 最新中文版（主文件和crack文件都要下载）
主文件：https://cloud.189.cn/t/URJNzqANVVZr (访问码:5glx)
crack文件：https://lanzoux.com/id738gtevbg
密码:yuzhu
IDM插件：https://lanzoux.com/iKndteqln2b
IDM下载器：https://lanzoux.com/iQn1vg9r4gh
提示：暂不提供百度网盘链接！
点我查看公众号网站！
Experiment 2 Spectral analysis using FFT
实验2 用FFT对信号作频谱分析
一、实验安全规则（本实验项目安全注意事项）
1.数字信号处理及DSP应用实验在计算机Matlab上用仿真方式完成，不需要硬件设备，请不要开启计算机桌台上的其它硬件设备；
2.实验可以一人一机单独完成，也可两人一机配合完成，不容许三人一机实验。
二、实验指导
1．实验目的
学习用FFT对连续信号和时域离散信号进行频谱分析（也称谱分析）的方法，了解可能出现的分析误差及其原因，以便正确应用FFT。 
2. 实验原理
用FFT对信号作频谱分析是学习数字信号处理的重要内容。 经常需要进行谱分析的信号是模拟信号和时域离散信号。 对信号进行谱分析的重要问题是频谱分辨率D和分析误差。 频谱分辨率直接和FFT的变换区间N有关， 因为FFT能够实现的频率分辨率是2π/N， 因此要求2π/N≤D。 可以根据此式选择FFT的变换区间N。 误差主要来自于用FFT作频谱分析时，得到的是离散谱，而信号（周期信号除外）是连续谱，只有当N较大时，离散谱的包络才能逼近于连续谱，因此N要适当选择大一些。
周期信号的频谱是离散谱，只有用整数倍周期的长度作FFT，得到的离散谱才能代表周期信号的频谱。 如果不知道信号周期，可以尽量选择信号的观察时间长一些。 对模拟信号进行谱分析时，首先要按照采样定理将其变成时域离散信号。如果是模拟周期信号，也应该选取整数倍周期的长度，经过采样后形成周期序列，按照周期序列的谱分析进行。
3. 实验内容、步骤及过程
(1) 复习DFT的定义、 性质和用DFT作谱分析的有关内容。
(2) 复习FFT算法原理与编程思想， 并对照DIT-FFT运算流图和程序框图， 读懂本实验提供的FFT子程序。
(3) 编制信号产生子程序， 产生典型信号供谱分析用。
(4) 编写主程序。
(5) 按实验内容要求， 上机实验， 并写出实验报告。
4.实验数据处理及结论
（1）实验结果截图上传学习通课程作业，对序列进行谱分析:
选择FFT的变换区间N为8和16的两种情况进行频谱分析。分别打印其幅频特性曲线，并进行对比、分析和讨论。 
（2）对周期序列进行谱分析
选择FFT的变换区间N为8和16的两种情况分别对以上序列进行频谱分析。分别打印其幅频特性曲线。并进行对比、分析和讨论。
（3）对模拟周期信号进行谱分析:
x6(t)=cos8πt+cos16πt+cos20πt
选择采样频率Fs=64 Hz，变换区间N=16，32，64的三种情况进行谱分析。分别打印其幅频特性，并进行分析和讨论。
思考题 (1) 在N=8时， x2(n)和x3(n)的幅频特性会相同吗?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daceecbc0e832b18435334f2f3af5f4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40b7fc328d6a2bd149eeced30d46274e/" rel="bookmark">
			关于快速排序的相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于快速排序的相关知识 快速排序主要由四步完成。
1、选择一个数
2、做partition操作
3、分别对左右两个小区间做相同处理
4、直到小区间有序为止
具体过程如下图所示：
代码操作如下
private static void quickSortInternal(long[] array, int lowIndex, int highIndex) { // 由于是闭区间，所以，区间内个个数需要加个 1 int size = highIndex - lowIndex + 1; if (size &lt;= 1) { return; } // 选择其中一个数（选最左边的） —— array[lowIndex] // 执行 partition，小的放左，大的放右 // keyIndex 是经过 partition 之后，选出来的数最终所在下标 int keyIndex = partition(array, lowIndex, highIndex); // 分别对左右区间进行相同的处理 —— 递归方法 quickSortInternal(array, lowIndex, keyIndex - 1); quickSortInternal(array, keyIndex + 1, highIndex); } 其中的partition操作主要有三种方式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40b7fc328d6a2bd149eeced30d46274e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/408/">«</a>
	<span class="pagination__item pagination__item--current">409/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/410/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>