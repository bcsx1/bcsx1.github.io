<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b297b2a1ef0435c7b238674a179dae68/" rel="bookmark">
			重庆旅游攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重庆旅游攻略 白天 鹅岭二厂 （1）地铁线路：
1号线鹅岭站
川美涂鸦一条街 （1）地铁线路：
黄桷坪正街
湖广会馆 3. 长江索道 需要预约
门票：单程20元，往返30元
4. 重庆动物园 5. 朝天门 三峡博物馆 需要预约
6. 李子坝（穿楼而过） （1）地铁线路：
2号线–李子坝站
（2）拍照项目：
吃轻轨 （3）拍照机位：
1.
2.6楼穿楼图书馆里面
3.
5.
6.
（4）图文路线–小红书收藏
参考视频：
https://www.bilibili.com/video/BV1Ds4y197H9/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=871d6bf079e0e1f9befc62eafed87009
2.https://www.bilibili.com/video/BV1G24y1c7fa/?spm_id_from=333.337.search-card.all.click&amp;vd_source=871d6bf079e0e1f9befc62eafed87009 7. 夜晚 1. 千厮门大桥（可以看到洪崖洞） 2. 解放碑 3. 洪崖洞 相关配置 查看重庆轻轨实时到站软件
查看重庆公交车实时到站软件
高德路线图中就可以查询
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79af1d4e98b0bd68309b3be92e5ce1de/" rel="bookmark">
			BFS深度理解与代码实现（Breadth First Search）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 BFS，即广度优先搜索，从字面意思理解就是广度撒网，不会有针对性，BFS是使用队列（queue，先进先出）来实现，它有一个孪生兄弟——DFS(深度优先搜索)，会向着某个方向一干到底，使用栈(Stack，先进后出)实现的。通过树状结构可以更方便我们理解，如下图所示：
其实大多数场景，我们用 DFS 的时候远远多于 BFS。如果我们使用 DFS/BFS 只是为了遍历一棵树、一张图上的所有结点的话， DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历，不过，有些场景是 DFS 做不到的，只能使用 BFS 遍历，比如「层序遍历」、「最短路径」。
本文的主要目是同时计算 多个目标点的 最短路径。
层次遍历大家可以自行搜索（简贴一张图，如下图所示）。
2、基本思想 BFS广度优先搜索是使用队列（queue，先进先出）来实现，整个过程也可以看做一个倒立的树形：
1、把根节点放到队列的末尾。
2、每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾(不需要排序，因为默认每次增加权重相同)。并把这个元素记为它下一级元素的前驱。
3、找到所要找的元素时结束程序。
4、如果遍历整个树还没有找到，结束程序。
有人会问，这与Dijkstra 算法好像没有区别啊？都可以解决最短路径问题啊？ 的确是这样，BFS可以看成是无权重的最短路径问题，所有遍历的节点不需要进行人工排序，插入普通队列队尾即排序成功；而Dijkstra 每次遍历的下一个节点带有权重（斜向移动和平向移动代价不一样，离障碍物距离不一样代价不一样），所以Dijkstra 一般使用优先队列来进行自动排序，从而保证每次取出的是最优节点。
知识扩展
1、DFS 可以理解为随机方向的一搜到底。
2、贪心算法（Greedy） 则是每次搜索只考虑扩展节点到目标点的代价值最小（其实是有目标朝向的DFS），搜索到的路径不一定是全局最优。
3、BFS 可以理解为均匀的广度搜索。
4、Dijkstra 则是每次搜索只考虑扩展节点到起点的最小代价（其实是有权重的BFS），搜索到的路径一定是全局最优。
5、Astar 则可以理解为 Dijkstra + Greedy ，扩展搜索时既具有方向性（Greedy，加速了搜索效率），又有次优性（Dijkstra保证了路径的优越性）。
3、核心代码 下面代码实现了，输入一张CV 二值地图，给定一个起点、若干个终点，输出若干组路径或者若干组代价值（可以用于代价排序）。具体流程是遍历整张地图（不是到达目标点就退出，如果是单目标点可以自行魔改），再反向回溯得到路径或者直接获取终点代价。
下面代码也可以通过魔改得到Dijkstra算法（open_list_ 使用优先队列）、Astar（增加启发式代价H），有兴趣可以尝试。
// bfs.hpp #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;opencv2/opencv.hpp&gt; #include &lt;queue&gt; #include &lt;unordered_map&gt; namespace bfs_search { enum NodeType { OBS = 0, FREE, OPEN, CLOSE }; struct Node { cv::Point point; int F; std::shared_ptr&lt;Node&gt; parent; Node(cv::Point _point = cv::Point(0, 0)) : point(_point), F(0), parent(nullptr) {} }; class BFS { public: // 传入二值地图 void setMap(const cv::Mat &amp;map); // 获取起点至各目标点的代价 void getPathCost(const cv::Point &amp;start, const std::vector&lt;cv::Point&gt; &amp;ends, std ::vector&lt;int&gt; paths_cost); // 获取起点至各目标点的路径 void findPath(const cv::Point &amp;start, const std::vector&lt;cv::Point&gt; &amp;ends, std::vector&lt;std::vector&lt;cv::Point&gt;&gt; &amp;paths); private: inline int point2index(cv::Point point) { return point.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79af1d4e98b0bd68309b3be92e5ce1de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7502f37682547c0f59c5276faa5966d3/" rel="bookmark">
			【ubuntu】 20.04 网络连接器图标不显示、有线未托管、设置界面中没有“网络”选项等问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 在工作中 Ubuntu 20.04 桌面版因挂机或不当操作，意外导致如下问题
1、 Ubuntu 网络连接图标消失
2、 有线未托管
上图中展示的是 有线 已连接 ，故障的显示 有线 未托管 或其他字符
3、 ”设置“ 中缺少”网络“选项
上图是设置界面，拥有“网络”选项，是正常的，即可以进行网络设置。故障的“设置”界面中不存在“网络”选项，即不能进行网络设置
4、 &lt;warn&gt; [1692771694.0556] Error: failed to open /run/network/ifstate 警告
上图是使用 sudo service network-manager status 查看信息时，信息中有&lt;warn&gt; [1692771694.0556] Error: failed to open /run/network/ifstate 警告
解决方案 方案一 新版的 Ubuntu 中使用 Netplan 管理网络设备及资源，而 netplan 却将网络管理权委托给了 NetworkManager 或 Systemd-networkd 。（更多可参考Ubuntu 20.4 没有/etc/network/interfaces，配置网络需用Netplan）
大多情况下是委托到 NetworkManager 来处理。
因此遇到 “Ubuntu 网络连接图标消失，或无法设置网络” 的问题，可以依次执行如下命令解决
xzbd@ubuntu:~$ sudo service network-manager stop xzbd@ubuntu:~$ sudo rm /var/lib/NetworkManager/NetworkManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7502f37682547c0f59c5276faa5966d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a11efe1de5a9ab33a7ecf76858ab49d5/" rel="bookmark">
			关于Toast在页面重复显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Toast在页面重复显示 频繁点击一个按钮，Toast会长时间的显示，切换页面后仍然显示，会让用户产生一种错觉：”感觉就像每个页面都有错误提示“，以至于放弃使用APP。虽说bug不大，但是给用户的体验确实不好。
解决此问题方法如下，直接贴出核心代码：
package com.yxl.tool.publics.util; import android.content.Context; import android.os.Handler; import android.widget.Toast; /** * Created by yxl on 2023/6/28 * Toast工具，解决Toast重复显示，非本页面显示 * Copyright (c) yxl-版权所有 */ public class ToastUtil { private static Toast mToast; private static final Handler mHandler = new Handler(Looper.getMainLooper()); private static final Runnable mRunnable = new Runnable() { @Override public void run() { mToast.cancel(); } }; public static void makeText(Context context, String string, int duration) { mHandler.removeCallbacks(mRunnable); if (mToast !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a11efe1de5a9ab33a7ecf76858ab49d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30e9e6ee8d771ef80739ad0cc6e6b49e/" rel="bookmark">
			Android应用中实现Google登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在Android应用中实现Google登录，需要进行以下步骤：
创建Google API控制台项目并启用身份验证。
在Google API控制台中为您的应用程序创建OAuth 2.0客户端ID。
将Google Play服务库添加到您的Android应用程序中。
在manifest.xml中添加Google服务配置。
在Activity中添加Google登录按钮，或使用Google登录API以编程方式实现登录流程。
以下是一个简单的示例：
在gradle中添加以下依赖：
implementation 'com.google.android.gms:play-services-auth:19.0.0' 在manifest.xml中添加以下配置：
&lt;meta-data android:name="com.google.android.gms.version" android:value="@integer/google_play_services_version" /&gt; 在Activity中添加以下代码：
GoogleSignInOptions gso = new GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN) .requestEmail() .build(); GoogleSignInClient mGoogleSignInClient = GoogleSignIn.getClient(this, gso); private void signIn() { Intent signInIntent = mGoogleSignInClient.getSignInIntent(); startActivityForResult(signInIntent, RC_SIGN_IN); } @Override public void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == RC_SIGN_IN) { Task&lt;GoogleSignInAccount&gt; task = GoogleSignIn.getSignedInAccountFromIntent(data); handleSignInResult(task); } } private void handleSignInResult(Task&lt;GoogleSignInAccount&gt; completedTask) { try { GoogleSignInAccount account = completedTask.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30e9e6ee8d771ef80739ad0cc6e6b49e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c82a1aac1cfeb7eeb802db6a9ddc3ada/" rel="bookmark">
			pytorch多进程处理数据的代码模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytorch多进程处理数据的代码模板 和单进程的主要区别：
增加初始化pytorch多进程的函数 “init_distributed_mode”dataloader的sampler需要设置是分布式sampler启动命令发生变化，需要以“python -m torch.distributed.launch --nproc_per_node=8 --master_port 11113”为开头 import argparse import functools import gc import logging import math import os import random import shutil from pathlib import Path import accelerate import datasets import numpy as np import torch import torch.nn.functional as F import torch.utils.checkpoint import transformers from accelerate import Accelerator from accelerate.logging import get_logger from accelerate.utils import ProjectConfiguration, set_seed from datasets import load_dataset from huggingface_hub import create_repo, upload_folder from packaging import version from torchvision import transforms from torchvision.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c82a1aac1cfeb7eeb802db6a9ddc3ada/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b823ce6bafc1f0b7fd77486a05a2e0fe/" rel="bookmark">
			UDS之浅谈19 服务-0x19 01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、服务概述二、报文1.请求报文定义2.肯定响应3.报文讲解3.1格式及内容3.2举例 19服务作用是允许外部诊断仪（Client）通过该服务读取存储在ECU芯片内的故障码（DTC）状态信息 一、服务概述 通过该服务诊断仪能够请求ECU中DTC状态与DTC状态掩码相匹配的故障码个数。简单来说就是通过状态掩码去读取DTC数量。
二、报文 1.请求报文定义 2.肯定响应 3.报文讲解 3.1格式及内容 发 送： 19 +01+DTCStatusMask（DTC状态掩码）
正响应： 59+01+DTCStatusAvailabilityMask+DTC格式+DTCCount
注：DTCStatusAvailabilityMask是ECU支持的状态掩码，不能根据请求中的DTC状态掩码变化，容易误解为要返回的ECU支持的状态掩码和请求中的状态掩码做与运算后的结果
3.2举例 DTCStatusMask：为0000 0001-&gt;01
DTCStatusAvailabilityMask：ECU支持的状态位1111 1111-&gt;FF
DTC格式：00（J2012-DATACF00）
ECU中存储的DTC状态如下：
DTC1：0010 1111
DTC2：0010 1111 DTC3：0010 1100
DTC4：0010 1110
例① 发送19 01 01
回复59 01 FF 00 00 02
如图：
回复中02，表明有2个DTC：
解析如下：
ECU中存储的DTC状态（DTC1、DTC2、DTC3、DTC4）和
ECU支持的状态位（DTCStatusMask：01）相与
DTC1：0010 1111 &amp;0000 0001-&gt;01
DTC2：0010 1111 &amp;0000 0001-&gt;01
DTC3：0010 1100 &amp;0000 0001-&gt;00
DTC4：0010 1110 &amp;0000 0001-&gt;00
从相与结果可以看出有两个非0结果，所以DTCCount为2
例 ② 发送19 01 02
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b823ce6bafc1f0b7fd77486a05a2e0fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d77c6d9c5f2026b5e1e48d69f1ba88/" rel="bookmark">
			Yolo框架大改 | 消耗极低的目标检测新框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用常规深度神经网络到脉冲神经网络转换方法应用于脉冲神经网络域时，性能下降的很多，深入分析后提出了可能的解释：一是来自逐层归一化的效率低，二是用于leaky-ReLU函数的负激活缺乏表示。
前言 在过去的十年中，深度神经网络(DNNs)在各种应用中表现出显著的性能。当我们试图解决更艰难和最新的问题时，对计算和电力资源的需求增加已经成为不可避免的。
Spiking neural networks(SNNs)作为第三代神经网络，由于其事件驱动（event-driven）和低功率特性，引起了广泛的兴趣。
然而，SNN很难训练，主要是因为它们的神经元复杂的动力学和不可微的尖峰操作。此外，它们的应用仅限于相对简单的任务，如图像分类。
在今天的分享中，作者研究了SNN在一个更具挑战性的回归问题（即对象检测)。通过深入分析，引入了两种新的方法：channel-wise normalization和signed neuron with imbalanced threshold，这两种方法都为深度SNN提供了快速的信息传输。因此，提出了第一个基于尖峰的目标检测模型，称为Spiking-YOLO。
新框架贡献 尽管SNN有很多好处，但目前仅能处理相对简单的任务，由于神经元复杂的动态性以及不可导的操作，暂时没有一个可扩展的训练方法。DNN-to-SNN是近期广泛的SNN训练方法，该方法将目标DNN转化成SNN的中间DNN网络进行训练，然后转成SNN并复用其训练的参数，在小数据集分类上能达到不错的性能，但是在大数据集上分类结果不太理想
论文打算使用DNN-to-SNN转化方法将SNN应用到更复杂的目标检测领域中，图片分类只需要选择分类就好，而目标检测则需要神经网络进行高度准确的数字预测，难很多。在深入分析后，论文实现YOLO的转换主要面临以下两个问题：
常用的SNN归一化方法过于低效，导致脉冲发射频率过低。由于SNN需要设定阈值进行脉冲发射，所以要对权值进行归一化，这样有利于阈值的设定，而常用的SNN归一化方法在目标检测中显得过于低效，后面会详细阐述在SNN领域，没有高效leaky-ReLU的实现，因为要将YOLO转换为SNN，YOLO中包含大量leaky-ReLU，这是很重要的结构，但目前还没有高效的转换方法 来自韩国的比较冷门或者前沿一点的文章，研究方向是脉冲神经网络（Spiking Neural Networks）与YOLO算法的融合，发现韩国人特别擅长对YOLO，SSD等算法进行魔改啊。
提出一种在深度SNN中能够进行快速精确信息传输的Spiking-YOLO算法。这是第一次将深度SNN成功应用于目标检测任务的工作；为深度SNN开发了一种成为逐通道归一化的精细归一化技术。所提出的方法使得在多个神经元中更高的发射率成为可能，这促成了快速并且精确的信息传输；提出了一种新颖的方法，其特点在于具有不平衡阈值的带符号神经元，这些神经元让SNNs中的leakyReLU得以实现。这给深度SNN应用于各种模型和应用创造了机会。 ​
新框架 Channel-wise data-based normalization
在SNN中，根据输入的幅度产生脉冲序列进行无损的内容传递是极为重要的。但在固定时间，激活过度或激活不足的神经元内将可能导致内容损失，这和临界电压Vth的设置有关。设置过高，神经元需要累积很长时间的电压才能发射脉冲，相反则会过多地发射脉冲。发射频率通常定义为N/T，N为T个timestep的脉冲发射总数，最大的发射率为100%，即每个timestep都发射脉冲：
为了防止神经元的激活过度和激活不足，权值和临界电压都需要精心地选择。为此，很多研究提出了归一化的方法，比如常用的Layer-wise normalization(layer-norm)。该方法通过该层的最大化激活值来归一化层的权值，如上公式，w和b为权重。
经过归一化后，神经元的输出就归一到[0,1],方便设定临界电压。由于最大激活值从训练集得到的，所以测试集和训练集需要有相同的分布，但论文实验发现这种常规的归一化方法在目标检测任务上会导致明显的性能下降。
基于数据的逐通道归一化
传统的脉冲神经网络中，需要确保神经元根据其输入大小产生脉冲序列，其中权值和阈值电压分别负责神经元激活的充足度和平衡度，这会导致要么欠激活要么过激活，从而使信息丢失和性能不佳。
作者深入分析并证明了细粒度的通道正则化可以通过极小的激活来提高神经元的发射率。换句话说，非常小的激活被正确归一化，将在更短的时间内准确地传输信息。文章认为通道正则化的应用可以带来更快更准确的深度SNN，这将使深度SNN应用于更高级机器学习问题成为可能。
上图展示了通过layer-norm后的各层每个channel的最大激活值，蓝色和红色的线分别为每层的平均激活值和最小激活值。可以看到每层的归一化后的激活值偏差较大，总体而言，layer-norm使得神经元的channel偏向激活不足，这在仅需选择分类的图片分类任务是不被察觉的，但对于需要预测准确值的检测任务的回归则不一样。比如传递0.7，则需要在10个timestep脉冲7次，0.007则需要在1000timestep脉冲7次。当tempstep本身就很少时，过低的发射率可能会因发射不到足够的脉冲而导致信息丢失。
Proposed normalization method
整个流程如下：
具体的逻辑如上图和算法，channel-wise的归一化方法能够消除激活值特别小的问题，即得到更高但合适的发射频率，在短时间内也能准确地传递信息。
Signed neuron featuring imbalanced threshold
具有不平衡阈值特征的带符号神经元
引入了一种具有不平衡阈值（即IBT）的带符号神经元，它不仅可以对正负激活进行解释，还可以对leakyReLU负激活值区域的渗漏项进行补偿。如下图所示，作者增加了另外一个Vth负责对负激活响应。
其中，具有IBT的带符号神经元的基本动力学公式如下所示。
通过使用上述具有IBT的带符号神经元，可以在SNN中使用leakyReLU，从而将各种DNN模型转换为广泛应用的SNN。
实验结果与评估 作者使用Tiny YOLO的实时目标检测模型，在脉冲神经网络中实现最大池化层和BN层。模型在PASCAL VOC2007和2012上训练，在PASCAL VOC2007上测试。所有代码基于Tensorflow Eager框架，在V100的GPU上进行实验。
文章通过实验的设计验证并分析了使用通道正则化和有符号神经元的IBT存在的用处。如下图所示，当通道正则化和有符号神经元都使用时，脉冲-YOLO能够达到51.61%的mAP，这个性能比较高了。
此外，逐层正则化的mAP仅仅46.98%，而通道正则化优势明显，收敛速度也更快。如果不使用本文提出的这两种方法，Spiking-YOLO无法检测目标，如果仅仅使用有符号神经元的话，mAP仅仅7.3%，这表明有符号神经元可以补偿leakyReLU的不足项，并且在解决深度SNN中这种高数值精度问题中起着关键作用。
在上图中，作者还在两种输出编码方案上进行了额外的对比实验，一种基于累计Vth，一种基于脉冲数量。实验结果表明基于Vth的输出编码方案在解释尖峰序列时将更精确，也体现出收敛更快的特点。
实验的目的是无损地将Tiny-YOLO的转移为SNN，结果如上图所示，使用channel-norm和IBT能有效地提升性能，且使用的timestep更少。
作者尝试了不同的解码方式，分别为膜电压Vmem和脉冲数Vmem/Vth，由于脉冲数的余数要舍弃，这会带来误差和信息损失，所以基于膜电压进行解压会更准确。
总结 在今天分享中，作者提出了Spiking-YOLO，第一个SNN模型，通过在non-trivial datasets、PASCALVOC和MSCO上获得与原始DNN相似的结果来成功地执行目标检测。
我认为，这项研究代表了解决深度SNN中更高级的机器学习问题的第一步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/602201ca6c7664216bb898b5db5ffdfc/" rel="bookmark">
			ElasticSearch学习5-- 使用RestClient查询文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查询基本步骤 1、创建SearchRequest对象
2、准备Request.source()，也就是DSL。
QueryBuilders来构建查询条件
传入Request.source() 的 query() 方法
3、发送请求，得到结果
4、解析结果（参考JSON结果，从外到内，逐层解析）
RestAPI中其中构建DSL是通过HighLevelRestClient中的resource()返回的SearchSourceBuilder来实现的，其中包含了查询、排序、分页、高亮等所有功能
SearchSourceBuilder 进行查询、排序、分页、高亮
RestAPI中其中构建查询条件的核心部分是由一个名为QueryBuilders的工具类提供的，其中包含了各种查询方法。
QueryBuilders 进行match_all /match /multi_match /term /range/boolmatch等查询
查询所有
@Test public void testMatchAll() throws IOException { //创建查询请求，指定要查询的索引库 SearchRequest request = new SearchRequest("case_management"); //构建查询条件，下边是所有查询 MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery(); //将查询条件赋值给查询语句 request.source().query(matchAllQueryBuilder); //进行查询 SearchResponse response = client.search(request, RequestOptions.DEFAULT); //对结果进行处理 SearchHits hits = response.getHits(); //返回结果列表 SearchHit[] hitsList = hits.getHits(); //总数 long totalHits = hits.getTotalHits(); System.out.println(totalHits); SearchHit documentFields = hitsList[0]; String json = documentFields.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/602201ca6c7664216bb898b5db5ffdfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42629d90d69229cd3c04a12249516610/" rel="bookmark">
			解决 quill Cannot import modules/imageResize. Are you sure it was registered?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个插件是在富文本编辑器中调整图片大小的,发现拉下来的依赖会报错,于是替换了nodejs版本,没有解决,但是用同时之前拉下来的,莫名其妙正常,后来经过尝试,发现删除demo和node_modules文件夹后正常.
删除后,不报错,正常了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4331c19f4f085b7d2c63741b276fa799/" rel="bookmark">
			基于 Axios 封装一个完美的双  token 无感刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户登录之后，会返回一个用户的标识，之后带上这个标识请求别的接口，就能识别出该用户。
标识登录状态的方案有两种： session 和 jwt。
session 是通过 cookie 返回一个 id，关联服务端内存里保存的 session 对象，请求时服务端取出 cookie 里 id 对应的 session 对象，就可以拿到用户信息。
jwt 不在服务端存储，会直接把用户信息放到 token 里返回，每次请求带上这个 token，服务端就能从中取出用户信息。
这个 token 一般是放在一个叫 authorization 的 header 里。
这两种方案一个服务端存储，通过 cookie 携带标识，一个在客户端存储，通过 header 携带标识。
session 的方案默认不支持分布式，因为是保存在一台服务器的内存的，另一台服务器没有。
jwt 的方案天然支持分布式，因为信息保存在 token 里，只要从中取出来就行。
所以 jwt 的方案用的还是很多的。
服务端把用户信息放入 token 里，设置一个过期时间，客户端请求的时候通过 authorization 的 header 携带 token，服务端验证通过，就可以从中取到用户信息。
但是这样有个问题：
token 是有过期时间的，比如 3 天，那过期后再访问就需要重新登录了。
这样体验并不好。
想想你在用某个 app 的时候，用着用着突然跳到登录页了，告诉你需要重新登录了。
是不是体验很差？
所以要加上续签机制，也就是延长 token 过期时间。
主流的方案是通过双 token，一个 access_token、一个 refresh_token。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4331c19f4f085b7d2c63741b276fa799/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f239cb27485ad031e42d1403882407d/" rel="bookmark">
			利用python爬虫技术获取网页HTML代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、代码
#1.获取页面 import requests link = "http://www.santostang.com"#定义link 为目标网页地址 #定义请求头的浏览器代理，伪装成浏览器 headers = {'User-Agent':'Mozilla/5.0 (Windows; U; Windows NT 6.1;en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'} r = requests.get(link,headers = headers)#请求页面 print(r.text)#获取页面代码 二、结果
获取的结果
三、知识点
requests.get()请求网页
参数：
1.url（请求的url地址，必需 ）
import requests url="http://www.baidu.com" resp=requests.get(url)#向url对应的服务器发送相应的get请求，获得对应的相应 。 2.header(设置请求头,可选）
#1.获取页面 import requests link = "http://www.santostang.com"#定义link 为目标网页地址 #定义请求头的浏览器代理，伪装成浏览器 headers = {'User-Agent':'Mozilla/5.0 (Windows; U; Windows NT 6.1;en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'} r = requests.get(link,headers = headers)#请求页面 3.params(设置查询参数，可选) params = {'key1': 'value1', 'key2': 'value2'} 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f239cb27485ad031e42d1403882407d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab78b62152c800b606e340ce19103237/" rel="bookmark">
			深度解读：chatGPT 3.5 (GPT-3.5语言模型)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT 3.5是OpenAI公司开发的一种自然语言处理模型，是在GPT（Generative Pre-trained Transformer）模型系列的基础上进行改进和升级而来的。GPT模型是使用无监督学习方式进行预训练的语言模型，在各种自然语言处理任务中表现出色。
ChatGPT 3.5相对于其前身GPT-3，在生成能力和对话交互方面有所提升，具备更好的上下文理解、生成控制和回复质量。GPT-3是当时最大的语言模型之一，包含了1.75万亿个参数，但仍存在一些限制，如对于长篇对话的处理不够准确，有时会出现过度生成的问题。
为了解决这些问题，OpenAI团队通过引入一种新的方法，即“文本块切分”，对GPT-3进行了改进，从而推出了ChatGPT 3.5。文本块切分是一种将对话分成较小的文本块的技术，然后逐块进行处理的方法。这使得ChatGPT 3.5更有效地处理长对话，并更好地理解整个上下文。因此，它能够生成更加连贯且有逻辑的回复。
此外，ChatGPT 3.5还具备更强大的生成控制能力，可以通过设置参数来控制生成回复的风格和内容。例如，可以调整生成回复的长度，以控制回复的详细程度；可以调整温度参数，以控制生成的多样性，从而影响回复的创造性；还可以使用抑制词参数，限制生成回复中某些特定词语的使用，以满足特定需求。
然而，正如所有模型都有其局限性一样，ChatGPT 3.5也存在一些挑战和限制。首先，它有时可能会生成不准确或不完全合乎逻辑的回复，特别是当输入的上下文不够清晰时。其次，由于是通过预训练而来，ChatGPT 3.5可能受到一些偏见和误导的影响，导致生成的回复可能带有一定的偏见或不准确性。
为了解决这些问题，OpenAI在ChatGPT 3.5中引入了一种新的策略，称为“安全提示”（safety prompts），旨在帮助用户对模型的输出进行更加精确和可控的引导。这些安全提示可以限制模型生成不准确或不适当的内容，从而提高生成回复的质量和准确性。
OpenAI的GPT-3.5语言模型是一个非常受欢迎的模型，因其强大的生成能力和广泛的应用领域而备受推崇。虽然具体的使用人数是未知的，但可以肯定的是，GPT-3.5的API接口受到了广泛的关注和使用。
OpenAI通过他们提供的API，使开发人员能够轻松地集成GPT-3.5模型到自己的应用程序、网站或服务中。这为开发人员提供了与模型进行交互的便捷方式，从而为用户提供智能的自然语言处理功能。
由于GPT-3.5的强大能力和广泛的应用领域，很多公司和开发者都开始使用它来开发各种人工智能应用，包括智能助手、客服机器人、自动回复系统等。这使得GPT-3.5的API接口成为当下最受欢迎和使用人数最多的语言模型API之一。
然而，需要注意的是，由于GPT-3.5是一个商业化的产品，使用它的API接口需要支付相应的费用。OpenAI提供了不同的计费计划和价格，以适应各种使用需求和预算。这也可能会影响到实际使用人数的数量。
总而言之，尽管具体的使用人数是未知的，但可以肯定的是，GPT-3.5的API接口受到了广泛的关注和使用。其强大的生成能力和广泛的应用领域使得它成为许多开发人员和公司实现智能自然语言处理的首选模型之一。国内的很多对话创作网站就是通过API接口实现通信的例如:heigpt.cn
总的来说，ChatGPT 3.5是OpenAI公司开发的一种强大的自然语言处理模型，具备更好的上下文理解能力、生成控制能力和回复质量，可以用于实现智能对话系统、客服机器人等多种自然语言处理任务。然而，在使用过程中，仍然需要注意模型的局限性和可能的偏见，以及通过适当的设置和控制来提高生成回复的准确性和适用性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50bf86af5689acafb4cea72492353b2d/" rel="bookmark">
			STM32HAL库串口接收不定长数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要想能够接收不定长数据前提是要开启串口接收中断，这个流程就正常配置就行，切记一定要记得打开串口接收中断！！！
HAL库我们不需要写中断服务函数，所有的操作都在中断回调函数里面进行。所以我们要实现这个功能就直接在usart.c里面写就行。我的大致思路是，我们只需要每次接收一个字符即可，然后判断是否接收到回车字符，如果没有接收到的话就将接收到的字符存储在数组中，直到接收到回车字符后输出数组里面的字符串。注意：数组大小决定不定长度的大小，不要传入的字符串大于数组空间，这样会导致单片机宕机，当然我在这个过程中添加了限位操作，只接收定义长度-1个字符串，即便字符串数据超过我们定义的长度也不会宕机而是输出接收定义长度-1个的字符串！
当然我们还需要在主函数里面调用一次接收一个字符的接收中断函数：
HAL_UART_Receive_IT(&amp;huart1,&amp;ch,1); void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { if(huart-&gt;Instance == USART1) { // printf("%c\r\n",ch);//以字符格式%c打印 //	HAL_GPIO_TogglePin(LED0_GPIO_Port,LED0_Pin); rx_buffer[rx_cnt]=ch;//将字符存入字符串数组中 if(ch=='\r')//判断是否是回车键传入 { rx_buffer[rx_cnt++]='\0';//添加字符串结束标准符 printf("%s\r\n",rx_buffer); HAL_GPIO_TogglePin(LED0_GPIO_Port,LED0_Pin); rx_cnt=0; HAL_UART_Receive_IT(&amp;huart1,&amp;ch,1); return; } rx_cnt++; rx_cnt = (rx_cnt &gt;= buflen-1) ? buflen-1 : rx_cnt;//限制最大输入长度，即字符串数组最大空间-1，要为字符串结束符留一位 HAL_UART_Receive_IT(&amp;huart1,&amp;ch,1); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d25ff8b968ab34d931344cc9e5694b0/" rel="bookmark">
			ECharts社区 合集整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ECharts社区 合集整理 1、PPChart2、YX-Chartlib3、isqqw4、makeapie5、Chart.Top 1、PPChart 网址：http://ppchart.com/#/
2、YX-Chartlib 网址：http://chartlib.datains.cn
3、isqqw 网址：https://www.isqqw.com/
4、makeapie 网址：https://www.makeapie.cn/echarts
5、Chart.Top 网址：http://chart.365api.cn/#/
持续更新…
&lt;/article&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4842f82a303744fbb4a25af29a338839/" rel="bookmark">
			[转]Linux下java包设置开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、添加启动脚本，位置任意
vim xxxx.sh #!/bin/sh cd /usr/local/java/ydServer/target #切换到jar包所在目录 pid=`ps -ef|grep 'xxxx.jar*'|grep -v grep|awk '{print $2}'` if [ -n "${pid}" ];then kill -9 ${pid} echo "Process ITSM killed!" #java 根据自己jdk路径填写, jar包写绝对路径 nohup java -Dfile.encoding=utf-8 -jar xxxx.jar &gt;/xxxx/xxxx.txt 2&gt;&amp;1 &amp; echo "Restart ITSM Success!" else nohup java -Dfile.encoding=utf-8 -jar xxxx.jar &gt;/xxxx/xxxx.txt 2&gt;&amp;1 &amp; echo "Start ITSM Success!" fi 2、授权脚本文件
chmod 777 xxx.sh 3、配置service文件
vim /etc/systemd/system/xxx.service [Unit] Description=xxx-service After=network.target [Service] Type=forking ExecStart=/xxx/xxxx.sh [Install] WantedBy=multi-user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4842f82a303744fbb4a25af29a338839/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/957461809bbae7bf3ed9611e78658d54/" rel="bookmark">
			Altium Designer导入元器件3D封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 AD用了也有几年了 ，一开始只是单独用于制版，没有别的用途，随着工龄的增长，需求的内容也是越来越多，逐渐接触了3D模型建立，结构设计，有时需要导入PCB 3D效果，发现PCB导出的大多数只有芯片和电阻电容，很多开关、端子等特殊封装的元器件没有3D模型，其实大部门模型也是导入的PCB封装和原理图，只是一直没有研究如何导入3D封装，趁着这次机会直接提升我的使用B格，在这里记录和分享给大家如何使用AD软件导入3D封装。
二、环境 AD22
嘉立创专业版网页版
window10
三、正文 1.获取3D封装 获取3D封装的方式有很多，但是想要获取的3D封装和PCB的封装匹配上，就得讲究一些方式了，这里我的方式是相对简单一些的，就是在立创商城下载新的元器件原理图和PCB封装，但是不能直接下载对应的3D封装的SLDPRT文件或STEP文件，需要在立创EDA专业版下载，下面是导出指定3D封装文件步骤。
1）首先登陆嘉立创EDA专业版，登陆上自己的账号，创建一个空的工程，直接进入PCB中
这里我以一个拨钮开关为例，在网页的左下角“库”选项点开，依次选择 器件→嘉立创EDA，然后输入在立创商城下载元器件封装的编码，能够搜索到唯一原件，在右下角预览图可以看见当前元器件库中有的封装文件（这里为什么不能直接导出这个元器件的3D封装，/(ㄒoㄒ)/~~）
在有3D封装的情况下，双击这个器件，将其拖入到PCB中，注意这里PCB只放一个器件。
然后点击左上角的 文件→导出→3D文件
点击导出，等待即可。（这里注意我使用的是Edge浏览器，QQ浏览器导出会卡死）
2）下载后我们会发现下载的文件是3D_PCB1_2023-08-29.step这种格式的文件，你以为这里就完事了，错，这才是第一步的一半，我有可能猜到为什么不能直接下3D封装SLDPRT文件了，第一人家凭什么白给你3D封装文件，第二人家凭什么给你SLDPRT文件，能让你下载STEP文件就不错了。
之后我们使用3D编辑软件，将导出的STEP文件修整一下，第一是去掉自带的电路板PCB，他这个相当于导出整个PCB，这个PCB只有一个元器件。第二就是要把问价另存为SLDPRT文件。这里我是用的是soildworks，现在流行使用什么360这那的有很多3D模型编辑软件。
上图分别是处理前后图片，很简单选择底板点击后，delete删除即可，之后文件另存为sldprt格式
至此，第一步算是完毕了，最后将这个文件保存到一个固定的归档位置吧
PS；这里说明一下，正常我们一直维护的是PCB的lib文件，这个3D封装导入后数据会存储在LIB里，之后这个封装的源文件更换路径或丢失也是没问题的，但是为了保存和管理规范，建议存储起来。
2.导入3D封装 这里我一开始尝试用AD9去使用，但是没有成功，有报错，可能是AD9版本太低了，所以后来我使用了AD22版本。
进入AD软件，在进入PCB库编辑模式（在PCB库右键edit），选择PCB Library，选择要导入3D封装的元器件，鼠标点击聚焦一下右侧元器件，按键盘快捷键P+B导入3D元件体，鼠标会出现十字，随便画一个图形，然后双击这个图形，在弹出的框中分别选择1，2，导入刚刚存储的SLDPRT文件。
选中之后会发现紫色的框消失了，他是根据3D模型自适应大小，到了其他坐标位置，缩小界面找一下，在拖拽到2D封装上面
PS： 我这个跑好远
xy位置放置好之后发现高度还差很多，此时双击这个3D模型，会弹出窗口，在窗口中修改height位置，直到元器件底部和2D封装基本贴合即可。
最后保存，PCB中已经导入的封装文件需要删除重新导入才可以有3D封装。
最后的最后，让我们一起期待官方退出极简的导出3D封装方式吧，会不会因为要推广EDA故意就不方便导出3D封装给我们用呢，用EDA也画过一些简单的板子，真的很不错的。如果有新人刚学习画板制版，还是建议先入坑EDA吧。
四、结语 最后的疑问，既然立创商城下载的封装和元器件号，在嘉立创EDA专业版中能搜索到并能下载对应的3D封装，那为什么没有一个专用的地方去把单独的元器件2D封装和3D封装供我们用户直接导出呢，这个系统录入肯定已经是匹配打包录入的，下载却要如此大费周章。如果嘉立创有这种功能，希望有人留言分享，嘿嘿嘿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa5bc9ad393f1b99be7fa57a03e5b6c1/" rel="bookmark">
			10-锁（synchronized和Lock）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.内置锁：synchronized（JVM中内置了）
1.1.synchronized基本用法
1.1.1.修饰静态方法（锁粒度太大，用得少）（不能修饰静态变量）
---&gt;PS：上述代码中synchronized是如何保证线程安全问题的？
1.1.2.修饰普通方法（锁粒度太大，用得少）
1.1.3.修饰代码块（最常用）
---&gt;PS：3种常用场景：
1.2.synchronized特性
1.2.1.互斥性/排他性
---&gt;PS：公平锁 VS 非公平锁
1.2.2.刷新内存
1.2.3.可重入性
1.3.synchronized实现原理
（面试必问）synchronized是如何实现的？
1.3.1.监视器
1.3.2.底层实现
1.3.3.执行流程
1.4.synchronized历史发展进程
2.可重入锁/手动锁：Lock（Lock是一个接口,通常所说的可重入锁是指Lock的一个实现子类ReentrantLock)
2.1.Lock实现步骤：
①创建锁对象Lock lock = new ReentrantLock();
②加锁lock.lock();
③释放锁lock.unlock();
---&gt;注意事项：
a.unlock()一定要放在finally里，否则可能导致锁资源永久占用问题。
b.lock()要放到try外（官方建议）或try中的首行（问题不大）。
2.2.Lock指定锁类型——公平锁和非公平锁
3.（面试必问）synchronized VS Lock（ReentrantLock）
①Lock 更灵活，有更多的方法，比如tryLock()。粒度可以更小（不明显）。
②Lock（接口级别）需要开发者手动操作锁（加/释放）；而 synchronized 是 JVM 层面提供的锁，自动进行加锁和释放锁操作，对于开发者是无感的。
③Lock 只能修饰代码块；而 synchronized 可以修饰普通方法、静态方法和代码块。
④锁类型不同：Lock 默认是非公平锁，但可以指定为公平锁；而 synchronized 只能是非公平锁。
⑤调用Lock和synchronized线程等待锁的状态不同：lock会变为WAITING；而synchronized会变为BLOCKED。
使用锁（最主要有以下2种）是Java中解决线程安全问题最主要的手段 。
1.内置锁：synchronized（JVM中内置了） 1.1.synchronized基本用法 1.1.1.修饰静态方法（锁粒度太大，用得少）（不能修饰静态变量） public class ThreadSynchronized { //变量 private static int number = 0; static class Counter{ //循环次数 private static int MAX_COUNT = 1000000; //++方法 public synchronized static void incr() { for (int i = 0; i &lt; MAX_COUNT; i++) { number++; } } //--方法 public synchronized static void decr() { for (int i = 0; i &lt; MAX_COUNT; i++) { number--; } } } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { Counter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa5bc9ad393f1b99be7fa57a03e5b6c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c10170773860cc8fffcf5ef81a2c12ba/" rel="bookmark">
			用数组方式创建二叉树--堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		满二叉树的节点个数 65,100,70,32,50,60
第一层1个节点，第二层2^1个节点，以此类推，总共有：
2^0+2^1+……2^h-2+2^h-1 个节点
完全二叉树的结点范围
完全二叉树也可能最后一层是满的，也可能最后一层只有一个：
所以完全二叉树的结点范围为:(2^(h-1),2^h-1);
小堆 大堆
二叉树的存储方式
逻辑存储方式就是我们画的树状图，物理存储就是数组
非完全二叉树不适合用数组存储，会造成空间浪费
既然是数组，那就有下标
通过父节点找子节点：
有了下标我们就可以通过找节点了，一个公式：
leftchild=parent*2+1;
right=parent*2+2；
同样的，可以逆推出来：
parent=(chid/2)-1;
代码：
#include"Heap.h" int main() { HP tr; HPInit(&amp;tr); int a[] = { 65,100,70,32,50,60 }; for (int i = 0; i&lt;sizeof(a) / sizeof(int); ++i) { HPpush(&amp;tr, a[i]); } return 0; } #pragma once #include&lt;stdio.h&gt; #include&lt;assert.h&gt; #include&lt;stdlib.h&gt; typedef int HPDatatype; typedef struct Heap { HPDatatype* a; int size; int HPcapacity; }HP; void HPInit(HP* hp); void HPDestry(HP* hp); void HPpush(HP* hp, HPDatatype x); #define _CRT_SECURE_NO_WARNINGS #include"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c10170773860cc8fffcf5ef81a2c12ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f29036127510c4388a3e2785f71f7dbc/" rel="bookmark">
			上线访问破万！阿里限产Kafka从实战到源码手册，不愧是业界最强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这段时间招聘季，收到不少关于 Kafka 的问题，确实 Kafka 近两年的行情，可谓是水涨船高了。
不谦虚地说，目前 Apache Kafka 被认为是整个消息引擎领域的执牛耳者，仅凭这一点就值得我们好好学习一下它。另外，从学习技术的角度而言，Kafka 也是很有亮点的。我们仅需要学习一套框架就能在实际业务系统中实现消息引擎应用、应用程序集成、分布式存储构建，甚至是流处理应用的开发与部署，听起来还是很超值的吧。
总之 Kafka 是个利器，值得一试！既然知道了为什么要学 Kafka，却还是有很多人无从下手，不知如何学习！在这分享这份Kafka从应用实战到源码进阶手册
限于文章篇幅原因，只能以截图的形式展示出来，有需要的小伙伴可以文末获取↓↓↓
目录概览 从这六个方面展开，包括 Kafka 入门、Kafka 基本使用、客户端详解、Kafka 原理介绍、Kafka 运维与监控以及高级 Kafka 应用。
内容节选 第一部分我会介绍消息引擎这类系统大致的原理和用途，以及作为优秀消息引擎代表的 Kafka 在这方面的表现。
第二部分则重点探讨Kafka 如何用于生产环境，特别是线上环境方案的制定。
在第三部分中我会陪你一起学习 Kafka 客户端的方方面面，既有生产者的实操讲解也有消费者的原理剖析，你一定不要错过。
第四部分会着重介绍 Kafka 最核心的设计原理，包括 Controller 的设计机制、请求处理全流程解析等。
第五部分则涵盖了 Kafka 运维与监控的内容，想获得高效运维 Kafka 集群以及有效监控 Kafka 的实战经验？必当倾囊相助！
最后一个部分我会简单介绍一下 Kafka 流处理组件 Kafka Streams 的实战应用，希望能让你认识一个不太一样的 Kafka。
​限于文章篇幅原因，就展示到这里了，有需要的小伙伴可以查看下方名片↓↓↓ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da6979d4afe299d107b3822fa6bc816/" rel="bookmark">
			小白到运维工程师自学之路 第八十集 （Jumpserver堡垒机管理）2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 5、登录普通用户进行测试 这里的操作和在linux系统中的终端操作一样 在Xshell中登录
创建一个普通文件
在web终端中查看
五、审计台 在审计台中可以看到服务器的各种详细操作
在这里可以看到哪个用户在哪个时间对服务器具体使用了什么命令，还可以看到录频回放。
查看传输文件的详细信息
中断当前终端
以上就是Jumpserver堡垒机管理的基本使用 如有错误欢迎各位大佬批评指正，我们共同进步 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe88e854dbc15104d86daf3e178e7a16/" rel="bookmark">
			AC&#43;AP 旁挂式连接配置（DHCP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实验拓扑图
二、配置步骤
1、 DHCP R1 配置
2、LSW1配置
3、LSW2配置
4、AC 配置 4、实验结果
一、实验拓扑图 实验拓扑图的DHCP服务器和AC都是旁挂式
二、配置步骤 1、 DHCP R1 配置 [R1]dhcp en [R1]ip pool vlan100 #创建vlan100的地址池 [R1-ip-pool-vlan100]network 192.168.100.0 mask 24 [R1-ip-pool-vlan100]gateway-list 192.168.100.254 [R1-ip-pool-vlan100]dns-list 114.114.114.114 [R1-ip-pool-vlan100]lease day 3 [R1]int g0/0/0 [R1-GigabitEthernet0/0/0]ip add 192.168.200.1 [R1-GigabitEthernet0/0/0]dhcp select global [R1]ip route-static 0.0.0.0 0 192.168.200.2 # 配置默认路由 [R1]ip pool vlan100 [R1-ip-pool-vlan100]option 43 sub-option 3 ascii 192.168.210.1 # 告诉该地址池中的设备对应的ac的ip地址为 192.168.210.1 2、LSW1配置 [SW1]dhcp en [SW1]vlan batch 100 200 210 [SW1]int vlan 200 [SW1-Vlanif200]ip add 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe88e854dbc15104d86daf3e178e7a16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/333b679f9b40d51e902e944bdc1d6f79/" rel="bookmark">
			Sql Server存储过程使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 SQL Server 中，存储过程是一种预编译的可重用的 SQL 代码块，可以用于执行特定任务。使用存储过程可以提高性能、安全性和代码重用性。以下是一些使用存储过程的技巧：
使用参数化查询：参数化查询可以帮助防止 SQL 注入攻击，并提高性能。 CREATE PROCEDURE GetEmployeesByDepartment @DepartmentId INT AS BEGIN SELECT * FROM Employees WHERE DepartmentId = @DepartmentId END 使用临时表：临时表可以在存储过程中使用，以便在多个步骤之间共享数据。 CREATE PROCEDURE GetEmployeesWithSalaryByDepartment @DepartmentId INT AS BEGIN -- 创建临时表 CREATE TABLE #EmployeesWithSalary (EmployeeId INT, Name NVARCHAR(50), Salary DECIMAL(18, 2)) -- 向临时表中插入数据 INSERT INTO #EmployeesWithSalary (EmployeeId, Name, Salary) SELECT e.EmployeeId, e.Name, e.Salary FROM Employees e JOIN Department d ON e.DepartmentId = d.DepartmentId AND d.DepartmentId = @DepartmentId -- 返回结果 SELECT * FROM #EmployeesWithSalary DROP TABLE #EmployeesWithSalary END 使用游标：游标允许您在存储过程中处理结果集的每一行。这对于处理大量数据非常有用。 CREATE PROCEDURE GetEmployeesWithSalaryByDepartmentUsingCursor @DepartmentId INT AS BEGIN DECLARE @EmployeeId INT, @Name NVARCHAR(50), @Salary DECIMAL(18, 2) DECLARE employee_cursor CURSOR FOR SELECT EmployeeId, Name, Salary FROM Employees e JOIN Department d ON e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/333b679f9b40d51e902e944bdc1d6f79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2bfce0735fe1c6f3b0694d8a3f08db3/" rel="bookmark">
			mac使用Transporter应用上传ipa
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前端开发使用uniapp 打包的ipa文件需要上传到AppStore:
如果时mac系统，可以选择使用Transporter应用上传ipa包到AppStore。如果是window系统，可以选择App Uploader上传（有免费次数限制，超过会收费）或者选择 香蕉云编（同样有免费次数限制） 以下介绍mac系统使用Transporter应用上传：
Transporter应用地址下载安装，启动应用。登录开发者账号，并把打包好的ipa文件拖到Transporter应用。点击上传，上传成功后约半个小时内，在 App Store Connect 新构建版本中选择上传的ipa应用。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e689790b775ec0313e1fa88525a050cc/" rel="bookmark">
			Yolov5移植树莓派实现目标检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务描述 通过机器视觉的方式实现对工件的识别，以树莓派作为上位机，根据不同的识别效果对下位机发出不同指令，控制整个机器的运转，流程如下：
数据集获取 这是老师发的零件，所以网上肯定没有直接能用的模型，不像口罩检测等有现成的数据集，所以我们需要自己去获取数据集。
由于我们的零件只有两个，如果我们想获取大量图片话，我们可以通过旋转的方式，我设置每张图片每旋转10度生成一张新的照片，这样没拍一张照片就可以生成36张照片，扩大了数据集的来源。
之后用labelImg对图片进行标注，这样我们就获取了大量的数据集和对应的标签txt文件，我按照test：train：val = 1:8:2的比例分配图片。这样我们的数据集就准备好了。
Yolov5 模型训练 由于yolov5创作者将模型代码开源，所有我们可以拿来直接用，只需要修改train和val的路径，需改成自己的，以及类别的数量，我这里分为两类，所以是2，标签名称就是对应的颜色，blue和red。
我选用的是yolov5s这个模型，模型更加轻便，检测速度更快，同样设置类别数量为2.准备好之后，我们就开始训练了，由于我是直接拿cpu来训练的，训练时长在5.7个小时左右，如果用GPU的话速度可以提高不少。
​
模型训练结果 ​
从图中我们可以看到，无论是准确率还是召回率都接近了100%,平均mAp达到0.995，说明模型的识别效果很好，对于我们的工件识别的任务能够很好的完成。
检测效果 从视频中我们可以看到，红色和蓝色的工件被识别出来，红色的打上red的标签，蓝色的打上blue的标签，数字代表精度，基本上在0.8以上，是一个比较理想的结果。
对视频进行逐帧检测，每一帧的识别效果都很好。这是模型在笔记本上运行的结果，到此我们的Yolov5模块就算告一段落，接下来的问题就是怎么让它在树莓派上完美运行起来。
树莓派环境搭建 这是我第一次接触树莓派，又是第一次接触Linux，所有遇到了很多问题，有时候一个问题都要一整天的时间才能够解决。
我将这个学习过程，以及遇到的各种疑难杂症都记录下来，发在了csdn上面，希望可以给你们带来帮助。链接如下：Yolov5移植树莓派4B问题总结 Raspberry Pi 4B树莓派学习笔记
我选用的环境是树莓派的64位操作系统，这样的好处是opencv的下载很方便，经过长时间的摸索，我发现Pytorch很难在32位操作系统上安装，即使安装成功也没办法运行。
所以我选择的是树莓派64位操作系统，安装了opencv和pytorch。
Yolov5 移值树莓派 ​
环境准备好之后就要进行Yolov5的移植，首先通过vncviewer与树莓派连接，这样我们通过电脑就能控制树莓派，这里出问题的可以看我上面两篇博客。
通过顶端的文件传输将训练好的pt模块传到树莓派上，用linux cd命令进入到yolo所在文件夹中，输入运行指令，python3 运行detect文件，权重文件就用我们刚刚传入的best.pt文件，source为0就是调用我们树莓派上安装的CSI摄像头。之后按回车就可以运行了。
树莓派检测效果 我们来看一下检测效果：左边是检测的环境，树莓派搭载csi摄像头获取图像，下面这张图片就是检测时的一张图片，
可以看到，红色的零件被识别出来打上了red的标签，蓝色的零件也被识别出来打上蓝色的标签，我们可以利用这两个标签给下位机发出不同的指令，完成指定的任务。
总结 项目主要是Yolov5进行目标检测，之后用树莓派作为上位机，将模型移植树莓派进行识别，控制下位机的运转。
过程中遇到数不尽的问题，有硬件上的，有软件上的，常常一个问题就是一天，这个过程是痛苦的，但好在结果是满意的。在检测的时候还发现Yolov5模型的识别速度确实有点慢，笔记本电脑都有点带不动，树莓派上更是卡顿，2-3秒才能检测一张图片。
后面优化方向有两个，一个是优化模型，采用yolo-lite模型，一个是优化方法采用opencv模板匹配的方式去识别，不涉及深度学习速度应该会快很多。
当然这是后话，人工智能还有很多地方我都没有学习，甚至都没有听过，现在还只是一个小白，继续加油吧！
版权声明：本文为CSDN博主「爱睡觉的咋」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：
https://blog.csdn.net/weixin_63866037/article/details/128427628
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbc54d5fdfef3cdd5fb53896b539f950/" rel="bookmark">
			Ubuntu进入不了图形化界面解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Ubuntu进入不了图形化界面解决方法 前言 加上今天这次，博主已经是遇到好几次Ubuntu图形化界面崩掉的情况,但是没有记录过解决过程，今天恰巧又遇到了，就来记录一下，别再傻乎乎的直接重装系统了哦。
部分导致进入不了图形化界面的问题 Ubuntu18.04对于deepinWine的微信有着很不好的兼容，一装还好用，但是一重启就崩掉动了一些系统文件，或者更换软件源链接删除了一些关键文件，导致重启崩掉
可以按照以下步骤尝试解决。 命令行能进否? 开机，如果看到类似
no boot ....... 不好意思，说明你的系统已经没了，找不到启动页了。这一部分如果有需要，以后在操作系统专栏可以进行讲解。
如果没有上述文字出现，那么我们继续下面的步骤
Ctrl + Alt + F1看是否能够进入命令行界面。
login: 出现上述登录提示，恭喜你，说明你的系统没有毛病，可能只是装了一些不该装的软件。
输入你的用户名，然后进入下面一行
Password: 输入你的密码，进入你的命令行界面，当然这是我从命令行截图的，当你登录以后也是如此界面。
安装图形化界面 sudo apt-get update sudo apt-get install ubuntu-desktop #安装乌班图桌面托管器 sudo apt-get install unity sudo apt-get install lightdm 这时候你会进入一个选择界面，选择lightdm或者gdm3，都可以。
然后
sudo service gdm3 start 更改默认开启方式 最后，要更改一下自己的默认开启方式
sudo systemctl set-default graphical.target 看到下面这句话，好了你就稳了，不虚，重启即可，
lin@quan:~$ reboot 走起。
选择你喜爱的桌面 当然，这个时候或许你有不少桌面可以选择，怎么选择呢？
注销掉你的账户，然后在登录的旁边有着一个小按钮，点一点就可以选择你原来安装的不同的图形化桌面管理器。
图片有些模糊，但是懂的都懂。
总结 小小总结一下，其实就是分几个步骤
确认自己的系统是否还在，如果不在，只能重装，如果在，继续第二步下载图形化界面，也就是下载桌面管理器，这个网上教程比较多设置默认开启模式（当然你也可以直接自信第三步直接尝试一下，只是博主么有这样尝试过，因此不能保证有啥风险存在） 其他学习分享系列 数据结构与算法系列 数据结构与算法之哈希表 数据结构与算法之跳跃表 数据结构与算法之字典树 数据结构与算法之2-3树 数据结构与算法之平衡二叉树 数据结构与算法之十大经典排序 数据结构与算法之二分查找三模板 Android学习系列 Android之Room学习 Android之自定义View学习(一) Android之自定义View学习(二) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6718d86f873af1aa529e261c664cb8ba/" rel="bookmark">
			基于 OV5640 摄像头理论知识讲解-成像和采样原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于OV2640/ OV5640 的图像采集显示系统系列文章目录：
（1）基于 OV5640 摄像头理论知识讲解-成像和采样原理
（2）基于 OV5640 摄像头理论知识讲解-数字接口和控制接口
（3）基于 OV5640 摄像头理论知识讲解-典型工作模式配置
（4）基于OV2640/ OV5640 的图像采集显示系统
文章目录 前言一、OV5640 摄像头介绍二、硬件电路说明三、CMOS 图像传感器成像原理 前言 基于 OV5640 摄像头理论知识讲解-成像和采样原理。-
提示：以下是本篇文章正文内容，下面案例可供参考
一、OV5640 摄像头介绍 OV5640_V5（ V5 是版本号，下面均以 OV5640 表示该产品）是芯路恒科技推出的一款高性能 500W 像素高清摄像头模块。该模块采用 OmniVision 公司生产的一颗 1/4 英寸CMOS QSXGA（ 25921944）图像传感器 OV5640，配合高质量的光学镜头及为实现更高性能而精心设计的 PCBA，使该模块拥有了尽可能高的成像质量。OV5640 模块的特点如下：
 1.4μm1.4μm 像素大小，并且使用 OmniBSI 技术以达到更高性能（高灵敏度、
低串扰和低噪声）
 自动图像控制功能：自动曝光（ AEC）、自动白平衡（ AWB）、自动消除灯光条纹、
 自动黑电平校准（ ABLC）和自动带通滤波器（ ABF）等。
 支持图像质量控制：色饱和度调节、色调调节、 gamma 校准、锐度和镜头校准等
 标准的 SCCB 接口，兼容 IIC 接口
 支持 RawRGB、 RGB(RGB565/RGB555/RGB444)、 CCIR656、 YUV(422/420)、 YCbCr
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6718d86f873af1aa529e261c664cb8ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f27f6e99cfb7feb023a247410a9c80c/" rel="bookmark">
			Optional方法和实战讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Optional 在Java中，Optional是一个用于解决空指针异常的类。它是一个容器对象，可以包含或者不包含非空值。Optional类的设计思想是将可能为空的值封装在一个对象中，并提供一系列的方法来对这个值进行操作，同时避免了空指针异常的发生。
使用Optional可以代替使用null来表示一个值不存在的情况，这样可以提供更加清晰和安全的代码。Optional类提供了许多方法来处理包含或者不包含值的情况，例如：
of(T value)：创建一个包含指定值的Optional对象，如果指定值为null，则抛出NullPointerException异常。ofNullable(T value)：创建一个包含指定值的Optional对象，如果指定值为null，则创建一个空的Optional对象。isEmpty()：判断Optional对象中是否不包含值。isPresent()：判断Optional对象中是否包含值。get()：获取Optional对象中的值，如果Optional为空，则抛出NoSuchElementException异常。orElse(T other)：获取Optional对象中的值，如果Optional为空，则返回指定的默认值。orElseGet(Supplier&lt;? extends T&gt; other)：获取Optional对象中的值，如果Optional为空，则调用指定的Supplier函数生成默认值。orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)：获取Optional对象中的值，如果Optional为空，则抛出指定的异常。 通过使用Optional类，我们可以更加规范地处理可能为空的值，避免了空指针异常，并使代码更加健壮和可读性更高。
Optional的来源 Java 中的 Optional 类是在 Java 8 中引入的。它的目的是用于解决空指针异常（NullPointerException）的问题。在旧版本的 Java 中，如果一个方法可能返回空值，那么只能使用 null 来表示，这就导致了很多空指针异常的问题。Optional 类的设计思想是将可能为空的值封装在一个对象中，并提供一系列的方法来对这个值进行操作，同时避免了空指针异常的发生。使用 Optional 类可以使代码更加健壮和可读性更高。通过使用 Optional 类，我们可以更加规范地处理可能为空的值，避免了空指针异常，并使代码更加健壮和可读性更高。 Optional方法详解 我们有一个测试对象类
class Dou{ private Integer id; private String name; } 创建Optional Optional.of(T t) : 创建一个 Optional 实例，t 必须非空(与map、flatMap配合使用) Optional&lt;Dou&gt; op = Optional.of(new Dou()); Optional.empty() : 创建一个空的 Optional 实例 Optional&lt;Dou&gt; op = Optional.empty(); Optional.ofNullable(T t)：t 可以为null (最常使用) Optional&lt;Dou&gt; op = Optional.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f27f6e99cfb7feb023a247410a9c80c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ce1288bd66c971c27d66c6e9caea4a0/" rel="bookmark">
			C# 使用Apollo开源的分布式配置中心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apollo是一个开源的分布式配置中心，它提供了多种语言的客户端SDK，包括C#。以下是一个简单的C#调用Apollo中间件的示例代码：
首先，你需要在你的项目中安装Apollo的C# SDK。你可以通过NuGet包管理器来安装，命令如下：
Install-Package apollo-client 然后，你可以使用以下代码来调用Apollo中间件：
using System; using System.Threading.Tasks; using apollo_client; using apollo_client.Config; using apollo_client.Http; namespace ApolloClientDemo { class Program { static async Task Main(string[] args) { // 创建配置对象 var config = new LocalConfig(); config.AppId = "your-app-id"; // 你的AppId config.MetaServerAddr = "http://your-apollo-server:8080"; // 你的Apollo服务器地址 // 创建Apollo客户端 var client = new DefaultApolloClient(config); // 获取配置信息 var key = "your-key"; // 你要获取的配置项的key var value = await client.GetValueAsync&lt;string&gt;("your-namespace", key); Console.WriteLine($"The value of '{key}' is: {value}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ce1288bd66c971c27d66c6e9caea4a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc51175b041d325db713db42662de6a/" rel="bookmark">
			使用VUE实现Excel导入导出功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vue中实现Excel导入导出功能，我们可以使用第三方库，如xlsx和file-saver。以下是一个简单的示例：
首先，你需要安装这两个库：
npm install xlsx file-saver --save 然后，你可以在你的Vue组件中使用这些库来实现Excel导入导出功能：
&lt;template&gt; &lt;div&gt; &lt;input type="file" @change="handleFileUpload"/&gt; &lt;button @click="exportToExcel"&gt;Export to Excel&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import XLSX from 'xlsx' import { saveAs } from 'file-saver' export default { data() { return { workbook: null, worksheet: null, rows: [], cols: [], } }, methods: { handleFileUpload(event) { const files = event.target.files; if (files.length &gt; 0) { const reader = new FileReader(); reader.onload = (e) =&gt; { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cc51175b041d325db713db42662de6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae88c10133e4e14b1625cbe2a50293e7/" rel="bookmark">
			C&#43;&#43; 十六进制字符串和短整型相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、十六进制字符串转短整型，包含大小端
short getShortFromHexStr(string hexStr, bool isBigEdian) { if (hexStr.length() != 4) { return 0; } string bigEdianStr = hexStr; // 先将小端字符串转大端字符串 if (!isBigEdian) { bigEdianStr = ""; // 按字节掉转顺序，例如 0A00--&gt;000A for (int i = hexStr.length() - 2; i &gt;= 0; i -= 2) { bigEdianStr += hexStr.substr(i, 2); } } return std::stoi(bigEdianStr, 0, 16); } 二、短整型 转十六进制字符串，包含大小端
string getHexStrFromShort(short data, bool isBigEdian) { int from = data; // short转16进制，最大是FFFF，即长度为4，多加一位用于数组结尾\0使用 char to[5]; itoa(from, to, 16); string tmp = to; string prefix0 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae88c10133e4e14b1625cbe2a50293e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e73325abb8139b6400095d7c686cee48/" rel="bookmark">
			VSCode&#43;gcc开发STM32教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux环境下STM32开发1.前言2.环境搭建3.编译烧录调试：4. 编译5. 烧录6. 调试 Linux环境下STM32开发 1.前言 最近在使用Keil开发STM32的时候总感觉代码写起来很很费劲，然后打算用vscode试试，刚开始用的是KeilAssitance这个插件，本质还是使用Keil进行配置，vscode写代码，体验了一下感觉还是不方便。后来想到了Linux，毕竟在写代码这方面，Linux的体验还是非常棒的。综合考虑加查资料，最终决定使用Linux+vscode+STN32CubeMX+gnu-arm编译工具+openocd烧录工具的方式进行stm32的开发，花了我好几天才搞好，期间学了vscode复习了一下makefile和cmake，还有linux。希望能给大家一些帮助。
下面这一段对我启发很大，在此记录一下，以下转自知乎：
工具链一般用gcc-arm-none-eabi，可以用包管理装，也可以到arm官网下，也可以自己编译，毕竟gnu源有这个配置。如果keil自带的armcc就比较缺乏调试工具。纯用命令行的话，cubemx可以生成makefile工程，改下编译器路径就能make，会生成bin文件。
用IDE的话，可以用eclipse，参考wiced sdk。可以用vscode，体验要优于sublime。网上搜搜怎么配环境，主要就是设置工具链的目录。烧录程序，如果烧的是bin的话需要一个烧录程序。用jlink的话可以用segger官网下的jlinkexe工具。用stlink的话可以用github上的stutils什么的。用cmsis-dap或者ft2232的话就只能配openocd了。如果想直接烧elf，那么就要先搭好gdb server或者jtag bridge之类的东西，比方说jlink的就是jlinkgdbserver，然后xxxx-gdb连上，用load命令下载。keil的axf没研究过怎么用。
调试的话可以用IDE，关键还是先搭好gdb server然后让IDE里的gdb连上它。剩下的体验就跟调自家程序那样了，只是这些IDE没有像keil那样的看外设寄存器之类的功能了。
工程模板已经上传至我的git仓库，欢迎star
2.环境搭建 安装ubuntu虚拟机，用vmware即可，教程自行搜索。硬盘最好分配30G以上。
除此之外也可以安装双系统，本人使用的是双系统，因为用虚拟机运行太多东西会很卡，安装参考：Win10安装Ubuntu18.04双系统，图文详解，全网最详细教程
第三种方法是使用WSL，WSL安装过程去百度即可
系统装好以后需要安装一些必要的软件
sudo apt-get update\ sudo apt-get upgrade\ sudo apt install gcc git vim -y 安装vscode Linux版，安装过程自行搜索。安装STM32CubeMX Linux版，去ST官网下载安装即可。安装gcc-arm-none-eabi编译工具，当执行CubeMX生成的makefile时会调用该编译工具链。
安装方法： 在线安装：sudo apt install gcc-arm-none-eabi，不推荐，因为在线安装的版本会缺少gdb调试工具。推荐下载工具包的方式下载工具包：参考这篇。我的是ubunut下载这个,国外网站下载比较慢，有网盘会员的可以用我分享的网盘链接：百度网盘链接
下载完成后tar -xvf arm-gnu-toolchain-12.2.rel1-x86_64-arm-none-eabi.tar.xz进行解压
解压完成后切换到解压目录下的bin目录下可以看到编译器arm-none-eabi-gcc，但是需要把编译器添加到环境变量中：
在添加环境变量之前最好把解压文件放到/usr/local目录，使用命令cp -r arm-gnu-toolchain-12.2.rel1-x86_64-arm-none-eabi的路径 /usr/local
vi /etc/profile
添加以下环境变量到配置文件中 export PATH=$PATH:/usr/local/arm-gnu-toolchain-12.2.rel1-x86_64-arm-none-eabi/bin export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/arm-gnu-toolchain-12.2.rel1-x86_64-arm-none-eabi/lib 然后更新一下环境变量
source /etc/profile
在终端输入arm-none再按两下tab，如果出现
说明配置成功
安装openocd,openocd是一个开源的烧录程序, 这个在线下载就可以sudo apt install openocd -y。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e73325abb8139b6400095d7c686cee48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f2669614e1e5eaa6753d46f779c29f8/" rel="bookmark">
			基于Dpabi的功能连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.预处理 这里预处理用Gretna软件进行，共分为以下几步：
（1）DICOM转NIfTI格式
(2)去除前10个时间点(Remove first 10 times points)：由于机器刚启动、被试刚躺进去也还需适应环境，导致刚开始扫描的数据很不稳定，所以一般需要删除前几个时间点。本文的数据删除了前10个时间点。
（3）时间点矫正(Slice timing)：磁共振图像是逐层扫描，每一层获得的时间不一致。由于我们需要对时间序列进行操作，所以需要做一个时间尺度的校正，以保证一个全脑所有的体素获取的时间一致。
（4）头部矫正(Realign)：被试再扫描过程中不可避免地会有头部运动，所以需要对数据进行头部矫正，将全部时间点的数据在空间上与第一个时间点采集的数据对齐。
（5）标准化(Normalize)：同VBM一样，其目的为把所研究的各个个体的脑结构磁共振图像标准化到一个相同的立体空间。本文使用EPI模板进行标准化，体素大小[3 3 3]。
（6）平滑(Smooth)：提高数据的信噪比，选用高斯平滑核，平滑核的大小一般选取体素大小的2-3倍，此处选择大小[8 8 8]。
（7）去线性漂移(Detrend)：由于机器的工作而升温或被试适应，随着时间的积累会存在一个线性趋势。
（8）回归协变量和删除时间点（Nuisance Covariates Regression &amp; Scrubbing）：采集的核磁信号里会混杂着生理噪声，白质，脑脊液信号。把数据回归协变量，便可以将这些信号排除掉。在回归协变量时，可以进一步去除头动的影响，删除头动过大的点。在去除协变量的时候就进行过，此处可不进行删除时间点。
（9）滤波(Filter)：带通滤波后的静息态fMRI信号具有重要的生理学意义。本文将数据做0.01-0.08Hz的带通滤波处理，去除了数据线性低频漂移和呼吸、心跳等高频噪声。
将上述操作直接拖入到右侧点击RUN即进行预处理。
最终会得到以下文件：
其中GretnaFunNIfTI文件夹中存放每一个被试预处理后的结果：
文件名的前缀表示特定的预处理：
选需要的预处理文件(.nii)格式进行功能连接。
2.功能连接 这里用Dpabi进行以某一种子点计算其与全脑的功能连接。
（1）按下图打开处理界面，因为已经用Gretna预处理过了，这里直接选择Blank。
(2) 点击Function Connectivity 、Extract ROI time course ，并且通过Define ROI选择需要以哪一个体素作为功能连接的种子点。
点击Sphere，输入种子点的X、Y、Z轴坐标以及半径。
点击Run即可，最后是在成的Results文件夹下存放功能连接的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b9c1a39307eb637e969c070697d70f9/" rel="bookmark">
			【ROS2机器人入门到实战】串口通信-接收实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6.串口通信-接收实验 写在前面 当前平台文章汇总地址：ROS2机器人从入门到实战获取完整教程及配套资料代码，请关注公众号&lt;鱼香ROS&gt;获取教程配套机器人开发平台：两驱版| 四驱版为方便交流，搭建了机器人技术问答社区：地址 fishros.org.cn 你好，我是爱吃鱼香ROS的小鱼。上一节我们完成了第一个Hello World工程，学习使用了串口模块的初始化和发送，本节我们再来一个串口接收小实验，把串口收发数据补齐。
一、检测并接收单个字符 1.1 代码编写 /** * @file demo01_read_byte.cpp * @author fishros@foxmail.com * @brief 初始化串口，当有数据过来的时候读取并将数据打印出来 * @version 0.1 * @date 2022-12-18 * * @copyright Copyright (c) 2022 * */ #include &lt;Arduino.h&gt; void setup() { // 初始化串口 Serial.begin(115200); } void loop() { // 判断是否有有效数据，返回值是有效数据的长度 if (Serial.available()) { // 读取一个数据 int c = Serial.read(); // -1 代表接收失败 if (c != -1) { // 以%c字符的格式输出接收的数据 Serial.printf("I receve %c\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b9c1a39307eb637e969c070697d70f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c063eb5f9897eb7017b82c0349fa74e/" rel="bookmark">
			实现excel导出最简单方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来记录一下导出excel的实现方式，导出的格式是xlsx的文件。
这里用到的是hutool的工具包，依赖如下：
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.3.5&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!--读取excel组件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; 导出代码如下：
@PostMapping(value = "download", consumes = APPLICATION_JSON_VALUE) public void download(@RequestBody QaLogPageVO pageVO, HttpServletResponse response) throws IOException { List&lt;QaLog&gt; list = service.list(); ExcelWriter writer = ExcelUtil.getWriter(true); //自定义标题别名 writer.addHeaderAlias("name", "姓名"); writer.addHeaderAlias("time", "提问时间"); writer.addHeaderAlias("model", "模型"); writer.addHeaderAlias("question", "问题"); writer.addHeaderAlias("answer", "答案"); writer.addHeaderAlias("source", "来源"); writer.addHeaderAlias("feedbackStatus", "反馈"); writer.addHeaderAlias("department", "部门"); // 默认的，未添加alias的属性也会写出，如果想只写出加了别名的字段，可以调用此方法排除之 writer.setOnlyAlias(true); String title = DateUtil.format(startTime,"yyyy-MM-dd HH:mm:ss") +"——"+ DateUtil.format(endTime,"yyyy-MM-dd HH:mm:ss"); // 合并单元格后的标题行，使用默认标题样式 writer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c063eb5f9897eb7017b82c0349fa74e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f68547f676878e3c47d91d9312b66d/" rel="bookmark">
			使用maven报错:org.apache.maven.cli.MavenCli
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea中maven配置显示无效的maven主目录，在前一个项目还可以正常使用，打开新项目就报错了。
解决方法：
环境变量——系统变量——path：将jdk、jre上移到最顶部即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcd299afc17f33e24ce2eb83b3188bed/" rel="bookmark">
			ChatGPT原理及源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT是一个基于Transformer模型的自然语言处理工具，其原理是利用大量的文本数据进行训练，从中学习语言的规则和模式，然后使用这些知识来生成新的语言。
具体来说，ChatGPT的训练过程分为两个阶段：前馈网络阶段和后馈网络阶段。在前馈网络阶段，ChatGPT使用Transformer模型来生成输入文本序列，其中包括自回归模型和注意力机制。自回归模型是一个递归神经网络，可以根据前面的文本预测下一个单词。注意力机制可以帮助模型更好地理解当前输入和上下文的关系。
在后馈网络阶段，ChatGPT将生成的输入序列作为输入，并通过全连接层和softmax函数生成输出序列。输出序列包括预测下一个单词和整个回答。
ChatGPT的源代码使用了Python编写，使用了TensorFlow和PyTorch等深度学习框架进行模型的实现和训练。代码的核心部分是使用了PyTorch中的torch.nn模块来实现Transformer模型，以及使用TensorFlow中的tf.data模块来处理和生成数据集。
具体实现过程中，还需要对文本进行分词、编码、对齐等预处理操作，以及对生成的文本进行评估和调整。
下面是一个简单的ChatGPT模型实现代码：
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.optim import Adam
import torch.utils.data as data
# 定义输入和输出
def input_ids(data, mask=None):
return torch.tensor(data['input_ids'], dtype=torch.long)
def masks(data, mask=None):
return torch.tensor(data['masks'], dtype=torch.long)
def attention_mask(data):
return torch.tensor(data['attention_mask'], dtype=torch.long)
def decode(data):
output = data['output'][:, :-1, :]
attention_mask = data['attention_mask']
max_length = data['max_length']
decoded = ''
word_count = 0
context = data['context']
hidden = data['hidden']
target = data['target']
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcd299afc17f33e24ce2eb83b3188bed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58504b017e1577cb7bd8d4655de3a627/" rel="bookmark">
			2023年 天府杯专题赛：2023 “ 室温超导&#43;可再生能源应用国赛预测模拟专题赛“ 室温超导材料在可再生能源传输中的应用研究完整思路代码解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		室温超导材料是近年来材料科学领域的一项重大突破，其具有在常温下实现 电流零电阻传输的能力，有望彻底改变电力输送和储存的方式。与此同时，可再 生能源（如太阳能、风能等）的利用正在不断发展，但由于其间歇性和不稳定性， 传输和储存仍然是一个挑战。本次竞赛旨在探讨如何将室温超导材料应用于可再 生能源传输中，实现高效、稳定的能量传输与储存。 题目要求： 假设某国家有多个可再生能源发电站点，分布在不同的地理位置。每个发电 站点产生的能量大小和时间段都有所不同。同时，假设已经研发出室温超导材料 LK-6，LK-66，LK-666，可以在常温下实现电流零电阻传输。 请参赛选手根据以下情景，进行数学建模和优化： 1. 给定多个可再生能源发电站点的位置、能量产生曲线和传输距离。 2. 给定室温超导材料的传输特性，包括传输效率、最大传输功率等。 3. 考虑电网传输的成本与效率，例如传输损耗、设备成本等因素。 4. 目标：优化可再生能源的传输和储存方案，使得总体能量损耗最小，传输 效率最高。 请选手们设计一个数学模型，回答以下问题：
Q1) 如何合理划分室温超导材料的传输路径，以最小化使总能量损耗? Q2) 在保证电网稳定运行的前提下，如何调整可再生能源的传输方案，以达到传输效率最大化? Q3) 考虑室温超导材料的生产成本和可再生能源发电成本，如何在经济效 益与环保效益之间进行权衡，制定综合优化策略? 请参赛选手们通过数学建模和优化方法，提出创新性的解决方案，并在解决 方案中充分考虑实际情况和可行性。下列是附表 1,2,3 的相关数据。
注 1:在这个表格中，"能量产生曲线" 列显示每个发电站点在不同时间段内 产生的能量大小。例如，发电站点 A 在时间段 1 产生 10 兆瓦的能量。 注 2：在这个表格中，"传输效率" 表示室温超导材料在传输过程中的能量损 失比例。例如，如果传输效率为 0.95，则表示在传输过程中有 5% 的能量损失。 注 3："最大传输功率" 表示在室温超导材料的限制下，能够传输的最大功率。 例如，如果最大传输功率为 50 兆瓦，则表示室温超导材料在一次传输中最多可 以传输 50 兆瓦的能量。 注 4："传输损耗" 表示在传输过程中由于室温超导材料特性等因素引起的能 量损耗。例如，如果传输损耗为 0.05，则表示在传输过程中有 5% 的能量损失。 注 5："生产成本" 表示生产室温超导材料所需的成本，以每兆瓦为单位计算。 例如，材料 LK-6 的生产成本为 100 万元/兆瓦。 注 6："
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58504b017e1577cb7bd8d4655de3a627/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7da110f144ff6cf32da172a0c7c578a5/" rel="bookmark">
			git 本地仓库关联到远程仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将本地仓库关联到远程仓库 方式一：远程仓库没有文件 第一步：
git init（初始化git仓库） 第二步：
git remote add 地址（设置remote地址） 第三步：
git add . （将所有变更提交到本地仓库） 第四步：
git commit -m '' （提交注释） 第五步：
git push（本地仓库推送到远程仓库） 方式二：远程仓库有文件 第一步：
git init（初始化git仓库） 第二步：
git remote add origin 地址（设置远程remote地址） 第三步：
git pull origin master（拉取远程仓库master的文件） 第四步：
git branch --set-upstream-to=origin/master master（将本地master设置为远程master分支） 第五步：
git add . （将所有变更提交到本地仓库） 第六步：
git commit -m '' （提交注释） 第七步： git push（本地仓库推送到远程仓库） 方式三：（推荐，感觉这种最简单） 第一步：　建一个文件夹，进入文件夹打开命令行工具；
第二步：
git clone 地址（克隆远程仓库） 第三步：
将项目文件复制到新建文件夹中
第四步：
git add .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7da110f144ff6cf32da172a0c7c578a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3dd088b1580c9fd9d712a93e551c830/" rel="bookmark">
			stm32之IIC协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要通过两个层面来讲：物理层、协议层。
IIC是一个同步半双工串行总线协议。
一、物理层（通信模型）
1、最早是飞利浦公司开发的这个协议，最早应用到其产品上去。
2、两线制（两根信号线）
其中SCL为时钟线，SDA为数据线。
3、挂载在IIC总线上的设备有主从之分，可以同时挂载多个主机和多个从机。
主机：通信的发起方。所有的通信皆由主机先来发起。
从机：和主机进行通信。实现数据的交互。
4、IIC通信中，每一个设备（不论是主机还是从机）都有唯一的ID。
那么问题来了，在同一根信号线上有那么多的设备挂载，既有主机也有从机，假设主机1想和从机2进行通信，该怎么实现呢。主机1如何精准的找到我想通信的从机呢？这就和设备的唯一的ID有关，主机1可以去信号线上广播想要通信的从机ID，如果对应ID的从机收到了主机1发起的请求，则发送一个应答信号传送给主机1，表示本从机设备收到了主机的通信请求，然后选择是否应答该请求，如果应答则表示同意通信，如果返回给主机1的是一个非应答信号则表示不想与主机1通信。而其他从设备虽然也能接收到主机1的请求，但因为ID不一样，所以无法与主机1通信。
同一时刻只能有一个主机和一个从机进行通信 假如在同一个时刻，多个主机同时发起总线请求，也就是说同一时刻多个主机想要占据总线的使用权。此时将会有一个总线仲裁机制来决定到底是哪一个主机能使用信号线进行通信，也就是最终会是谁占据总线的使用权。
总线仲裁机制使用的是线与特性（总线空闲电平状态为高电平），也就是说谁能先拉低总线谁就能得到总线的控制权限，如果两者都能拉低总线，那就看谁的时间更长，总有一个时刻会有一个主机最终获得线权。那么其他主机就会主动的让出总线的控制权限。
2.空闲电平状态为高电平。
在时钟线和数据线上都接了一个上拉电阻。其作用就在于使得IIC总线的空闲电平信号为高电平。这两个上拉电阻的必须要的。
所以我们在初始化配置GPIO的时候最好给其配置成开漏输出。因为开漏输出是无法自己输出一个高电平的（开漏输出只有低电平状态和高阻态），但是因为IIC设备是一定会接上拉电阻的，所以开漏输出模式下，空闲电平状态将会由上拉电阻来拉高。然而因为我们后面要使用GPIO口模拟的方式来实现IIC协议，所以在这里配置推挽也问题不大，因为在软件模拟的时候，总线的输出高输出低是由我们自己软件控制的。
3.IIC通信是高位先发，是以字节形式发送的（一次发8位）。
4.具有三种传输模式：标准模式传输速率为 100kbit/s ，快速模式为 400kbit/s ，高速模式下可达 3.4Mbit/s，但目前大多 I2C 设备尚不支持高速模式。
二、协议层
1、起始信号
起始信号是表示通信开始的信号，其表现为：在SCL时钟线为高电平期间，数据线产生一个由高到低的下降沿电平切换。
2、停止信号
起始信号是表示通信结束的信号，其表现为：在SCL时钟线为高电平期间，数据线产生一个由低到高的下降沿电平切换。
3、数据有效性
因为我们通过数据线发送的信号有高有低，所以在电平信号进行高低切换的过程当中，需要一定的时间，那么这时可以让此时的数据切换这段时间使得数据无效。在IIC里面，只有当时钟线为高电平的期间，数据才有效。时钟线为低电平的期间，数据是无效的。如果在数据切换期间读取数据有效，那么很可能会将切换电平信号识别成开始信号或结束信号。
4、应答信号
（1）应答
应答信号：表示一个肯定的回应。其表现为：在时钟线SCL高电平期间，数据线SDA维持一个稳定的低电平。
（2）非应答
非应答信号：表示一个否定的回应。其表现为：在时钟线SCL高电平期间，数据线SDA维持一个稳定的高电平，当然，有的时候，数据的接收方确实没有收到来自数据的发送方的信号，导致数据的接收方就没有理会数据的发送方，此时也属于非应答信号。所以非应答信号其实有好几种可能的情况。
注意：应答信号或非应答信号是谁发的，又是谁接收的呢？
这里需要特别注意一点，应答信号（非应答信号）是数据的接收方发出去的，并且由数据的发送方来接收的。这里要弄清楚一个概念，数据的接收方不等同于从设备，数据的发送方也不等同于主设备，因为数据的接收方可能是主设备也可能是从设备，同理，数据的发送方也一样，可能是主设备也可能是从设备，因为在数据的通信过程中，可能由主机向从机发
送数据，也可能由从机向主机发送数据（半双工通信，但通信的发起者都是主机）。当由主机向从机发送数据的时候，主机就是数据的发送方，从机就是数据的接收方，而当从机向主机发送数据的时候，从机就是数据的发送方，主机则变成了数据的接收方。所以，这里要特别注意，应答信号（非应答信号）是由数据的接收方发出去，并且由数据的发送方来接收的。
由于某种原因从机不对主机寻址信号应答时（如从机正在进行实时性的处理工作而无法接收总线上的数据），它必须将数据线置于高电平，而由主机产生一个终止信号以结束总线的数据传送。
如果从机对主机进行了应答，但在数据传送一段时间后无法继续接收更多的数据时，从机可以通过对无法接收的第一个数据字节的“非应答”通知主机，主机则应发出终止信号以结束数据的继续传送。
当主机接收数据时，它收到最后一个数据字节后，必须向从机发出一个结束传送的信号。这个信号是由对从机的“非应答”来实现的。然后，从机释放SDA线，以允许主机产生终止信号。
5、IIC时序生成方式
IIC时序可以通过软件模拟（即通过GPIO口模拟）的方式产生。
还可以通过硬件生成（通过配置IIC控制器来产生）IIC时序。
三、EEPROM（AT24Cxx）
最好是自己查看手册24C02。
AT24C01/02/04/08/16...是一个1K/2K/4K/8K/16K位串行CMOS，内部含有128/256/512/1024/2048个8位字节，AT24C01有一个8字节页写缓冲器，AT24C02/04/08/16有一个16字节页写缓冲器。该器件通过I2C总线接口进行操作，它有一个专门的写保护功能。
AT24C02器件地址为7位，高4位固定为1010，低3位由 A0/A1/A2信号线的电平决定。因为传输地址或数据是以字节为单位传送的，当传送地址时，器件地址占7位，还有最后一位（最低位R/W）用来选择读写方向，它与地址无关。
但在我们这块开发板上的是AT24C04，高4位固定为1010，低3位由 A0/A1/A2信号线的其中A0被数据地址位占用了，而原本的A0接入的是NC状态。具体的器件地址还是要看芯片原理图的接法。当P0接0时则表示对数据地址空间的0~255Bytes进行操作，当P0接1时表示对数据地址空间的256~511Bytes进行操作。
在原理图中，A2、A1均接地，包括接入NC状态的A0也接了地所以此时的设备地址为0xA0，如果加上读写位的话，写地址：0xA0，读地址：0xA1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6215c17aa6d63a72c8a9927c8aec988d/" rel="bookmark">
			vben 表格使用时间组件筛选条件用到fieldMapToTime
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4ef88fa2a1d123079fa31e779fab6e1/" rel="bookmark">
			Jumpserver堡垒机管理（安装和相关操作）-------从小白到大神之路之学习运维第89天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四阶段
时 间：2023年8月28日
参加人：全班人员
内 容：
Jumpserver堡垒机管理
目录
一、堡垒机简介
（一）运维常见背黑锅场景
（二）背黑锅的主要原因
（三）解决背黑锅的方法
二、Jumpserver简介
（一）支持的操作系统
（二）功能介绍
（三）Jumpserver组件说明
（四）Jumpserver功能说明
三、部署Jumpserver环境
（一）实验环境
四、Jumpserver配置应用
（一）系统设置
（二）创建资产
（三）同理添加资产，得到如下：
一、堡垒机简介 （一）运维常见背黑锅场景 1、由于不明身份用户利用远程运维通道攻击服务器造成业务系统出现异常：但是运维人员无法明确攻击来源，那么领导很生气、后果很严重。
2、只有张三能管理的服务器，被李四登录过并且做了违规操作：但是没有证据是李四登录的，那么张三只能背黑锅了。
3、运维人员不小心泄露了服务器的密码。一旦发生安全事故，那么后果不堪设想。
4、某服务器的重要数据被窃。但是数据文件无法挽回，那么面临的是无法估量的经济损失。
运维工作中由于远程登录来源身份不明、越权操作、密码泄露、数据被窃、违规操作等因素都可能会使运营的业务系统面临严重威胁，一旦发生事故，如果不能快速定位事故原因，运维人员往往就会背黑锅。
（二）背黑锅的主要原因 其实运维工作，出现各种问题是在所难免的不仅要有很好的分析处理能力，而且还要避免问题再次发生。
要清楚认识到出现问题的真实原因：
1、没有规范管理，人与服务器之间的界限不清晰；
2、没有实名机制，登录服务器前没有实名验证；
3、没有密码托管，服务器的密码太多，很难做到定期修改，自己保管怕丢失；
4、没有操作预警，对高危、敏感的操作无法做到事前防御；
5、没有传输控制，对重要服务器无法控制文件传输；
6、没有回溯过程，不能完整还原运维过程。
（三）解决背黑锅的方法 作为运维人员，如何摆脱以上背黑锅的尴尬局面呢？也许堡垒机是一个破解此局面的方法。
1、统一入口、规范管理
提供统一入口，所有运维人员只能登录堡垒机才能访问服务器，梳理“人与服务器”之间的关系，防止越权登录
2、利用手机APP动态口令等验证机制
采用手机APP动态口令、OTP动态令牌、USBKEY、短信口令等双因素身份实名鉴别机制防止密码被暴力破解，解决访问身份模糊的问题。
3、托管服务器密码，实现自动改密
通过堡垒机定期自动修改服务器的密码，解决手工修改密码、密码泄露和记住密码的烦恼。
1）可自动修改Windows、Linux、Unix、网络设备等操作系统的密码；
2）可以设置周期或指定时间执行改密任务；
3）可设定密码的复杂度、随机密码、指定密码、固定密码格式等；
4）可通过邮件、SFTP、FTP方式自动发送密码文件给管理员；
5）提供密码容错机制：改密前自动备份、备份失败不改密、改密后自动备份、自动恢复密码等。
4、事中控制，防止违规操作
作为运维人员，如何摆脱以上背黑锅的尴尬局面呢？也许堡垒机是一个破解此局面的必杀技。
1）通过命令控制策略，拦截高危、敏感的命令
2）通过命令审核策略，审批需要执行但又不能随意执行的命令
3）通过文件传输控制策略，防止数据、文件的泄露
5、精细化审计，追溯整个运维过程
堡垒机要做到文件记录、视频回放等精细化完整审计，快速定位运维过程：
1）不仅要对所有操作会话的在线监控、实时阻断、日志回放、起止时间、来源用户、来源地址、目标地址、协议、命令、操作(如对文件的上传、下载、删除、修改等操作等)等行为记录。
2）还要能保存SFTP/FTP/SCP/RDP/RZ/SZ传输的文件为上传恶意文件、拖库、窃取数据等危险行为起到了追踪依据。
二、Jumpserver简介 Jumpserver 是全球首款完全开源的堡垒机（跳板机），使用 GNU GPL v2.0 开源协议，是符合 4A(认证Authentication、授权Authorization、记账Accounting、审计Audit) 的专业运维审计系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4ef88fa2a1d123079fa31e779fab6e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b82354e8bdfcdb3451bad28a7ef8a61b/" rel="bookmark">
			【会议征稿】2023智能通信与网络国际学术会议（ICN 2023）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023智能通信与网络国际学术会议（ICN 2023）
2023 International Conference on Intelligent Communication and Networking (ICN2023)
2023智能通信与网络国际学术会议（ICN 2023）将于2023年11月10-12日在中国常州召开。ICN 2023将围绕智能通信与网络的最新研究领域，为来自国内外高等院校、科学研究所、企事业单位的专家、教授、学者、工程师等提供一个分享专业经验、扩大专业网络、展示研究成果的国际平台，以期推动该领域理论、技术在高校和企业的发展和应用，也为参会者建立业务或研究上的联系以及寻找未来事业上的全球合作伙伴。大会诚邀国内外高校、科研机构专家、学者，企业界人士及其他相关人员参会交流。
重要信息
大会官网：www.ic-icn.org（点击参会/投稿）
大会时间：2023年11月10-12日
大会地点：中国 ▪ 常州
接受/拒稿通知：投稿后1周内
收录检索：EI Compendex，Scopus
组织单位
主办单位：河海大学
指导单位：IEEE南京分会
承办单位：河海大学信息科学与工程学院
协办单位：深圳大学、IEEE天线与传播学会深圳分会、沈阳航空航天大学、AEIC学术交流中心、广东省艾思信息化学术交流研究院
会议出版
ICN 2023所有的投稿都必须经过2-3位组委会专家审稿，经过严格的审稿之后，最终所有录用的论文将由IEEE出版，见刊后由出版社提交至IEEE Xplore, EI, Scopus检索。
注意事项：
&amp; 已录用论文请及时注册，逾期注册，默认放弃发表。
&amp; 论文需按照会议论文模板排版，投稿需要提交WORD与PDF格式文件，且不得少于4页。。 &amp; 论文应具有学术或实用价值，且从未在国内外任何期刊或会议发表过。作者可通过CrossCheck, Turnitin(查重率低于30%)或其他查询系统自费查重。由文章重复率引起的出版社拒搞，作者需自行承担责任。确认学术造假的论文将不被出版，且公布在会议主页。
征稿主题
1- 机器学习，智能数据分析与数据挖掘 2- 智能通信 3- 人工智能技术与应用
4- 网络
5- 系统和自动化
6- 通信工程
7- 无线网络和系统
8- 其它相关主题
参会方式
1、作者参会：一篇录用文章允许一名作者免费参会；
2、主讲嘉宾：申请主题演讲，由组委会审核；
3、口头演讲：申请口头报告，时间为15分钟；
4、海报展示：申请海报展示，A1尺寸，彩色打印；
5、听众参会：不投稿仅参会，也可申请演讲及展示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38fea76bcc53a1ff96175c81e597f196/" rel="bookmark">
			Long类型和BigDecimal的除法运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务中碰到此问题，这两个类型的运算无法直接用运算符，需要借助封装类的方法：xxxValue（）
一、Long类型
Long a = 3L; Long b = 5L; String result = String.format("%.3f",(a.doubleValue() / b.doubleValue())); 使用String.format（）对结果保留三位小数，并用String类型的对象接收。
二、BigDecimal类型
BigDecimal a = new BigDecimal(3.55); BigDecimal b = new BigDecimal(5.55); String result = String.format("%.3f",(a.doubleValue() / b.doubleValue())); BigDecimal类型也一样，只是换了个类型而已。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68162034896520872502c4c6cd53fb51/" rel="bookmark">
			校招java实习生基础知识面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
写在前面的话
基础知识
J2SE
J2EE框架（可选，非强制）
db
网络
软能力
写在前面的话 校招生大多没什么项目经验，更多的看潜力。这个潜力怎么体现？
一般可以从下面几个方面来看：
a、学校：先来一轮初筛，是985还是211，毕竟是千军万马过独木桥。经过了高考/考研的洗礼，学校可以看出这个同学是否聪明，不过这种不是绝对的，但确实是参考因素之一。
b、学习成绩（gpa）：大学的学习成绩大多跟勤奋无关，但是可以反映候选人是否勤奋；学习成绩好的人，一般比较勤奋，学习能力和做事态度有保证。
c、基础知识：主要考察理论基础，包括深度和广度
d、项目经验&amp;实习经历：加分项，偏实践，从理论基础到实践可以反映候选人的技术热情。
ps，阿里2020年实习生开始要求有技术成果，比如一些acm得奖，修改了某些jar，或者在某一方面有亮点。真的是要求越来越高了~
基础知识 下面就来简单列一些我个人认为校招生应该掌握的基础知识。
J2SE
java编程语言有啥优点？JVM、JRE和JDK的关系？ 参考文章
java8中的新特性了解么？参考文章
Java有那些基本数据类型？基本数据类型存储在jvm的什么区域？一定存储在栈中的吗？参考文章
有哪些引用数据类型？引用数据类型存储在jvm哪里？
String是不是基本数据类型，他们有何区别？String s = new String(“xyz”); 产生几个对象？
参考文章
int a1 =1; int a2 =new Integer(1); public static final int a3 = 9; Integer b1= 127; Integer b2= 128; String c1 = "china"; String c2 = new String("china"); String、StringBuffer、StringBuilder的区别？如何选择？参考文章
用过哪些Object类的方法？参考文章
比如== 和 equals 的区别是什么？参考文章
如何理解hashCode 与 equals？ 参考文章 public static void main(String[] args) { int a = 2; int b = 2; Integer c = 2; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68162034896520872502c4c6cd53fb51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e198a9026af3d00d104dc6178fc74b15/" rel="bookmark">
			VMware 多开卡顿问题，优化速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		困扰很久的问题，双路 E5-2696 V2，开虚拟机卡卡卡，CPU核心100%跑满。
原来是360的问题，360自带的核晶引擎，会用到CPU硬件虚拟化功能，跟VMware冲突，造成虚拟机开多了就卡卡卡。
解决：卸载360或者关闭核晶引擎。
参考：https://bbs.360.cn/thread-15993127-1-1.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eded712fd885bc49df0e00bbf2f4250/" rel="bookmark">
			CSS实现白天/夜晚模式切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
功能介绍
示例
原理
代码 优化
总结
功能介绍 在网页设计和用户体验中，模式切换功能是一种常见的需求。模式切换可以为用户提供不同的界面外观和布局方案，以适应其个人偏好或特定环境。在这篇博客中，我们将探索如何使用纯CSS实现一个简单的模式切换效果，无需依赖JavaScript的运行。
示例 原理 通过复选框的选中状态和CSS选择器来控制开关按钮的显示效果。当复选框被选中时，通过选择器选中相邻的元素，然后应用相应的样式改变。常用于创建交互效果和状态切换控件的UI设计。
代码 &lt;template&gt; &lt;div&gt; &lt;input type="checkbox" id="modeCheckBox"&gt; &lt;div class="container"&gt; &lt;button&gt;&lt;label for="modeCheckBox"&gt;切换模式&lt;/label&gt;&lt;/button&gt; &lt;p&gt;123&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; #modeCheckBox { display: none; } .container { width: 100%; height: 600px; transition: all 1s; } #modeCheckBox:checked+.container { background: #000; color: #fff; } &lt;/style&gt; 在视图中，我们使用了一个&lt;input&gt;元素来实现复选框，它的id属性被设置为modeCheckBox。接着，我们创建了一个包含按钮和段落的容器，其外部包裹了复选框和容器本身。容器具有.container的类选择器，设置了宽度、高度和过渡效果。
在样式中，我们使用了display: none;来隐藏复选框，以便只使用自定义按钮进行模式切换。.container类选择器定义了容器的样式，包括宽度、高度和过渡效果。当复选框被选中时，通过使用#modeCheckBox:checked+.container选择器，我们可以改变容器的背景色和文字颜色，从而实现模式切换的效果。
优化 &lt;template&gt; &lt;div class="mode-toggle"&gt; &lt;input type="checkbox" id="modeCheckBox"&gt; &lt;label for="modeCheckBox" class="switch"&gt;&lt;/label&gt; &lt;div class="container"&gt; &lt;p&gt;这是一个示例文本。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eded712fd885bc49df0e00bbf2f4250/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50b278e816e66c8ab7fa9cc308c6c4b/" rel="bookmark">
			零一汽车黄泽铧：比冗余更重要的是，知道系统在实际工况中是怎么失效的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交流群 | 进“传感器群/滑板底盘群/汽车基础软件群/域控制器群”请扫描文末二维码，添加九章小助手，务必备注交流群名称 + 真实姓名 + 公司 + 职位（不备注无法通过好友验证）
作者 | 苏清涛
上周三，新能源商用车公司零一汽车在北京举办了一场媒体沟通会。
在CEO黄泽铧及联合创始人张红松分享了创业的心路历程及对行业的一些思考后，是将近2小时的媒体群访环节。本来，笔者还疑惑：“商用车这么不性感的东西，大家会有兴趣提问吗？有兴趣听吗？”但没想到的是，在那将近两个小时里，现场近20家媒体参与互动的热情都很高。
那场媒体沟通会上干货很多，笔者在此整理了跟无人驾驶相关的部分——
做算法出身的黄泽铧，为什么要造车？
黄泽铧说：
在相当长一段时间内，做无人驾驶的人都把关注点放在芯片、软件算法等AI侧的东西上，对车辆关注比较少，而我在图森期间跟好多家OEM合作过，然后发现，商用车无人驾驶最大的瓶颈不在AI板块，而在车辆。
全行业在无人驾驶的软件算法上面已经砸了太多钱了，到现在，软件已经趋于成熟了，但车辆还停留在很基础的水平上。比如，在无人驾驶后，如何以数字化的方式检测车辆的机械性故障？车辆在损坏后更换了几个零部件，会不会对无人驾驶系统的运行产生影响？这些问题，目前还是无解的。
可以说，车辆的水平严重落后于无人驾驶的开发。这些在本质上属于整车厂的工作，但传统的整车厂并不太了解无人驾驶对车辆的需求，所以其实很难做好。尤其是，现有的重卡，大多以集成为主，OEM更多关注的是如何低成本地把整车集成出来，对产品定义、软件这些并不关注。
公司为什么叫“零一”？
两位创始人黄泽铧跟张红松之前有过多次从0到1的、并做到第一梯队的经验。
黄泽铧：在图森期间，经历了研究员、技术带头人、工程副总裁几个阶段；先后负责过感知算法、全套算法、软件平台、软硬件平台。
张红松：在北汽福田戴姆勒期间，用7年时间，带领公司的重卡销量做到全国第五；在三一重工期间，仅用了3年时间，就带领团队超过第二梯队的玩家。
公司在过去的一年半里做了什么？
完成了两个定位于中短途运输的重型纯电动整车牵引平台：一个带线控，供给无人驾驶作为无人驾驶技术平台使用；另一个不带线控，面向那些仅需要新能源车的公司。
最关注的数据：车辆的故障情况
黄泽铧说：
当前，重卡上虽然搭载了T box等车联网系统，但主机厂并没有很好地分析和处理这些T-Box传回来的数据，甚至也没有掌握地到这些故障数据，因此，它的售后问题都是依靠服务站。这样，故障解决的效率很低。
针对这一问题，很多人想到的对策是设计个线控冗余，但冗余充其量只能确保发生故障之后不出致命事故，却不能从根本上避免或减少故障——冗余搞得很重，却仍然不知道车系统怎么失效的；更何况，冗余还存在导致冗余系统和主系统之间打架、从而导致可靠性降低的风险。
我们真正需要的并不是冗余，而是从统计学意义上搞清楚车辆在实际工况中是怎么出故障的。
零一在车辆的EE上带了整车预诊断系统、预测维护系统。
为了更方便地收集故障数据，零一在提供给一些非自动驾驶的客户的车上，也装了线控转向系统，并且没有向客户多收费。
成本控制能力：大概花了同行1/4的钱，
做到了一致的结果
张红松提到，造出前两款车，零一使用的资金大概只有同行的1/4。黄泽铧认为，如此大的成本节省，主要得益于张红松在供应链上的人脉积累和成本管控经验。
张红松说，在三一期间，他们已把成本理念融入到每个员工的骨子里。而在刚加入零一之后，他就开始训练团队的成本意识。
张红松举了个例子：
我们有一台车要从芜湖拉到长沙试验场做标定，运费将近1.5万。当时我就说：“你们对中国物流运价起码得有个基本的概念吧，每吨每公里几毛钱，就2毛钱吧？芜湖到长沙700公里，一辆车10吨，总共付1.5万，你算算，你的运费单价是多少，每吨公里都超过2块钱了。搞重卡的人，如果连个运费都算不明白，那你还搞什么重卡，是不是？”
张红松强调道：
成本竞争力永远是企业最基本最有效的竞争力，成本的控制要深入到骨髓。
END
交流群 | 进“传感器群/滑板底盘群/汽车基础软件群/域控制器群”请扫描上方二维码，添加九章小助手，务必备注交流群名称 + 真实姓名 + 公司 + 职位（不备注无法通过好友验证）
写在最后
关于投稿
如果您有兴趣给《九章智驾》投稿（“知识积累整理”类型文章），请扫描右方二维码，添加工作人员微信。
注：加微信时务必备注您的真实姓名、公司、现岗位，谢谢！
“知识积累”类稿件质量要求：
A：信息密度高于绝大多数券商的绝大多数报告，不低于《九章智驾》的平均水平；
B：信息要高度稀缺，需要80%以上的信息是在其他媒体上看不到的，如果基于公开信息，需有特别牛逼的独家观点才行。多谢理解与支持。
推荐阅读：
◆当“软件定义汽车”遇上“硬件拖软件的后腿”
◆自动驾驶合成数据科普一：不做真实数据的“颠覆者”，做“杠杆” ◆自动驾驶数据闭环系列之一：理想丰满，现实骨感
◆万字长文说清大模型在自动驾驶领域的应用
◆“去高精地图”跟“轻高精地图”有啥区别？落地的挑战又是啥？| 九章自动驾驶随笔之一
◆工程化能力，并非L4自动驾驶公司不可逾越的障碍 | 九章自动驾驶随笔之二
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e50b278e816e66c8ab7fa9cc308c6c4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8397ad78b4f7fc24f3e9dc85a04bd4/" rel="bookmark">
			NLP领域模型对抗攻击简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 Introduction NLP对抗攻击是人工智能对抗攻击的一个重要的组成部分，但是最近几年才逐渐开始兴起，究其原因在于NLP对抗攻击与传统computer vision或者audio对抗攻击有很大的不同，主要在于值空间的连续性（CV、audio）和离散性（NLP）。
如图为传统的一种对CV和audio模型的攻击方式：
如图，对CV与audio的攻击是在一张图片或一段录音中加入微小连续的扰动（如高斯噪声），在人眼或人耳不可识别的条件下使模型进行错误的分类。
以对CV模型攻击为例：
CV的 256 × 256 256 \times 256 256×256大小的图片像素值空间为 [ 0 , 255 ] 256 × 256 [0,255]^{256 \times 256} [0,255]256×256内的连续实数空间，对其添加扰动比较容易。
但是，如图
NLP领域中，数值是由一个一个的离散的token组成。因此对NLP模型进行处理时，需要先将离散的token转换为连续的vector，这样才能让NLP模型对其进行处理。因此，对NLP模型做攻击时，也只能处理离散的token。（连续的vector一般来说是在NLP模型内部生成的，因为无法做到对其加噪声）。
二、Evasion Attacks and Defenses 1. Introduction 在CV中，Evasion Attacks就是在图片中添加人眼不可见的噪声，使图片分类模型对其进行错误的分类。
如图：
对于原始图片，模型有57.7%的概率认为其是熊猫，但是在对其添加了人眼无法察觉到的噪声（连续值空间）后，模型有99.3%的概率认为其是长臂猿（分类错误）。
同样的，在NLP中，Evasion Attack指的是：对原始的句子进行修改，在对人类来说不改变语义的情况下使模型对修改过的句子进行错误的预测。
以情感分析为例，如图：
上图是一段影评，对于原始的句子，NLP模型认为其是负面的，但是在对film添加上一个s后，模型认为其是正面，这对人来说，是很难察觉的。
对NLP的Evasion Attack还有其他方面，比如修改句子，使翻译模型对其进行错误的翻译。这里不在进行赘述。
2. Four Ingredients in Evasion Attacks 以影评的情感分析为例，Evasion Attacks攻击的完整步骤（执行框架）为：
1 Goal，对既定的攻击模型和对抗样本指定攻击目标。
2 Transformation，对对抗样本进行相应的转换（添加扰动），在此过程中会产生很多可能的候选样本。
3 Constraints，根据设置的限制条件，对候选样本进行过滤。（比如，语法错误、人称错误或同义词变成反义词等等）
4 Search: 采取一些研究方法，在候选的样本中选择可以成功的使模型进行错误预测的样本作为最终的对抗样本。
Morris, J., Lifland, E., Yoo, J. Y., Grigsby, J.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb8397ad78b4f7fc24f3e9dc85a04bd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c58352686b2ae314dc2092cf8a74954/" rel="bookmark">
			超详细教程：如何在笔记本上run起大模型？没有GPU也可以！（Windows/Mac）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在笔记本上Run起大模型 好久不见的前言环境搭建Mac环境搭建conda环境python环境安装pytorch安装transformers Windows环境搭建conda环境 (可选)python环境 模型下载方式一：通过git下载方式二：直接通过文件链接下载方式三：通过huggingface官方提供的模型的下载工具snapshot_download进行下载。 模型加载Tokenizer加载执行推理结束语 好久不见的前言 好久没更新了，一是最近一直在研究生物医药大模型相关的内容，二是。相信不止是我，每一位工程师朋友都已经感受到大语言模型带给整个行业的颠覆性改变。最近身边就有不少的小伙伴入坑了大模型技术，而即使仍在观望的同学，也对大模型这一崭新的技术表达了深厚的兴趣。
但说到上手使用大模型，尤其是对于之前没有从事过相关工作的小伙伴来说，门槛是不低的。比如，大模型对基本硬件要求很高，没有大的内存和高性能的GPU就很难玩转，层出不穷的各种新技术和工具更是让人不知道从何入手。
因此，以最近刚刚发布的生物医药大模型——BioMedGPT为例，本教程提供了接触大模型技术的第一步，整理和介绍了在MacBook和Windows笔记本上如何从头开始跑起一个大模型，当然里面用到的技术也同样适用于对其他大模型进行操作。
接下来，我将从如何从零在MacBook和Windows笔记本配置隔离的运行环境，如何从HuggingFace上下载模型、加载模型，以及生成文本（执行推理）几个部分进行介绍。对于有python开发经验的伙伴们，可以选择性阅读。
环境搭建 Mac环境搭建 Mac配置
以本人所使用的MacBook Pro (13-inch, M1, 2020)为例
芯片：Apple M1
内存：16 GB
核总数：8（4性能和4能效）
系统：macOS Monterey，12.6.2
CPU架构：ARM64
conda环境 Anaconda是管理Python环境的强大工具,通过其可以创建、管理多个相互独立、隔离的Python环境，并在环境中安装、管理Python依赖。我们可以使用其免费、最小可用版本MiniConda。
可以在Miniconda ‒ conda documentation找到对应的下载链接和安装方式。
python环境 安装好miniconda以后，我们就可以创建一个Python环境,我们在这里创建了一个名为biomedgpt的python环境，并通过conda activate激活该环境。
conda create -n biomedgpt python=3.10 conda activate biomedgpt 为了运行BioMedGPT-LM-7B，我们需要安装pytorch和transformers。
安装pytorch Mac上安装Pytoch可以在pytorch官网上找到对应的命令。我们只需要按照下图所示选择对应的版本，然后使用官方给出的安装命令即可。pip install torch torchvision torchaudio
安装transformers Huggingface提供数以千计针对于各种任务的预训练模型，这些模型被广泛的应用于学术研究当中，transformers是Huggingface开源的一个NLP工具，方便使用者调用这些模型（包括训练、推理、量化等）。
大家可以根据自身的需要，选择适合自己的模型进行训练或微调，也可阅读api文档和源码， 快速开发新模型。我们可以通过pip或者conda直接安装transformers。
pip install transformers 如果pip安装很慢，可以指定清华或者阿里等国内镜像源，下面以清华源为例
pip install transformers -i https://pypi.tuna.tsinghua.edu.cn/simple Windows环境搭建 conda环境 (可选) conda提供了两个核心能力：一个是做环境隔离，一个是管理你的安装包。强烈推荐配置conda环境，它可以为你创建一个虚拟环境，最大限度地避免各种环境冲突。
访问 https://docs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c58352686b2ae314dc2092cf8a74954/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/95/">«</a>
	<span class="pagination__item pagination__item--current">96/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/97/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>