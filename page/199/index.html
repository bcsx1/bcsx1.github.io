<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6018ce39e6b9f68bf2497e624aee7c57/" rel="bookmark">
			mini-Imagenet处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于imagenet-1k 数据集太大，在验证模型方面耗时太久，特意研究了一下mini-Imagenet，用来代替imageNet-1K数据集快速验证模型。
2016年google DeepMind团队从Imagnet数据集中抽取的一小部分（大小约3GB）制作了Mini-Imagenet数据集，共有100个类别，每个类别都有600张图片，共60000张（都是.jpg结尾的文件），而且图像的大小并不是固定的。
下载好的目录结构如下：
├── mini-imagenet: 数据集根目录 ├── images: 所有的图片都存在这个文件夹中 ├── train.csv: 对应训练集的标签文件 38400 imgs ├── val.csv: 对应验证集的标签文件 9600 imgs └── test.csv: 对应测试集的标签文件 12000 imgs 有很多博客介绍了如何基于CSV文件进行构建数据集训练，这里我主要将其修改为Imagenet-1k 原始的文件夹形式，也就是一个文件夹对应一个类，方便使用ImageFolder进行读取。
按照常用8:2的比例划分为训练集和验证集，也就是训练集48000张imgs，验证集12000imgs
出于方便，直接采用了https://blog.csdn.net/qq_37541097/article/details/113027489这个博主生成的新的CSV训练和验证划分，也就是新生成的new_train.csv,new_val.csv
这里一并提供：
https://download.csdn.net/download/xiaoxiaomo_/87156448
下边主要介绍如何根据该CSV文件划分为原始的形式：
1.根据CSV读取train/val文件到train/val文件夹
这一步会得到train、val文件夹，里边包含各自的训练文件。
import pandas as pd import os #读取CSV文件，获取所有的img文件名称 test_csv = "/home/zhaogy/Workspace/Study/mini_imagenet/mini-Imagenet/new_train.csv" data=pd.read_csv(test_csv) #print(data,type(data)) test_filename = list(data["filename"].values) #print(test_filename) #print(len(test_filename)) dst = "./new_train/" #提前创建一个新的train文件夹，将CSV对应的train img 复制到文件夹中 for i,name in enumerate(test_filename): imgx = os.path.join("./mini-Imagenet/images",name) print(f"第{i}张图片已经copy完成") print(imgx) shutil.copy(imgx,dst) 得到类似于这样的文件夹
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6018ce39e6b9f68bf2497e624aee7c57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abfab44b5fb712469a09bb19698da64a/" rel="bookmark">
			【码极客精讲】c&#43;&#43;for循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家好，我是茶哥。
最近刷CSDN，看到有人提问for循环的问题。今天就给各位讲一下。
如果懒得看文本，直接看这个链接。
for循环：编程语言中一种循环语句,教育,高等教育,好看视频
要看文本的可以继续
for循环语法；
1.语句最简形式为：
for( ; ; )
2.一般形式为：
for（单次表达式;条件表达式;末尾循环体）
{
中间循环体；
}
for循环和while的功能比较 编辑 播报
一、循环的结构不同
for循环的表达式为：
for（单次表达式;条件表达式;末尾循环体）
{
中间循环体；
}
while循环的表达式为：while（表达式）{循环体}[5]
二、执行条件的判断方式不同
for循环执行末尾循环体后将再次进行条件判断，若条件还成立，则继续重复上述循环，当条件不成立时则跳出当下for循环。
while循环当满足条件时进入循环，进入循环后，当条件不满足时，执行完循环体内全部语句后再跳出，而不是立即跳出循环。
三、语法不同
for循环的语法为：for (变量 = 开始值;变量 &lt;= 结束值;变量 = 变量 + 步进值) {需执行的代码 }。
while循环的语法为：while (&lt;条件&gt;) {需执行的代码 }。
其中，break语句可以打破for循环 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/974fdbfbc901d4070b81a98cf9a51693/" rel="bookmark">
			Ubuntu18.04下安装autoware1.14.0及其demo展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、autoware简介 ROS系统有很多开源的工具包，可以通过选择不同的工具包实现，建图，定位，规划等节点，从而实现整体的自动驾驶技术。在这个过程和自己组装一台电脑是一样的，选用不同的显示器，键盘，硬盘，显卡，主板等就可以组合出一台电脑。这个过程是自由但是难度也比较大，而且不成体系。有没有一台组装好的电脑，集成了上面所有的标准配置呢，答案是有的。
Autoware是一个开源协作项目，其最早是由名古屋大学研究小组在加藤伸平教授(Prof. Shinpei Kato)的领导下于2015年8月正式发布。2015年12月下旬，加藤伸平教授创立了Tier IV，以维护Autoware并将其应用于真正的自动驾驶汽车。随着时间的流逝，Autoware已成为公认的开源项目。目前，由Autoware Foundation启动、发展和资助。
== 目前该基金会运营三个项目：Autoware.AI、Autoware.Auto和Autoware.IO. ==
Autoware.Al旨在为学者、开发者和学生提供一个开源的自动驾驶研发平台，是由Tier IV和东京大学的Shinpei Kato在2015年创立的Autoware项目发展而来；Autoware.Auto用于可认证的自动驾驶软件堆栈；而Autoware.IO则专注于车辆控制接口以及连接外部软件和硬件工具。
Autoware.AI是世界上第一个用于自动驾驶技术的“All-in-One”开源软件。它ROS1操作系统，并在Apache2.0许可下使用。主要包含以下模块：
定位（Localization ）：通过结合GNSS和IMU传感器的3D地图和3D地图、SLAM算法来实现定位。
检测（Detection ）：通过传感器融合算法和深度神经网络使用摄像机和激光雷达完成检测。
预测和规划（Prediction and Planning ）：基于概率机器人模型和基于规则的系统，部分还使用深度神经网络。
控制（Control）：Autoware向车辆输出的是速度和角速度的扭曲量。尽管控制量的主要部分通常位于车辆的线控控制器中，但这些是Control的一部分。
Autoware.Auto是Autoware的彻底重写，基于ROS2，应用一流的软件工程实践，包括PR审阅，PR构建，全面的文档，100％代码覆盖率，编码样式指南以及定义的开发和发布过程，所有这些均由开源社区管理。
它具有两个不同：
a）为不同的模块（消息和API）定义了清晰的接口
b）为确定性而设计的体系结构，以便可以在实时和开发机器上重现行为。
Autoware.IO 是 Autoware的接口项目，将通过专有软件和第三方库以可靠的方式扩展Autoware。 例如包括用于传感器的设备驱动程序，用于车辆线控以及用于SoC板的硬件相关程序。提供了具有统一的界面设计和测试框架的异构硬件参考平台，支持将成员公司的解决方案集成到支持Autoware.Auto和Autoware.AI软件平台上。
二、安装教程 参考：
https://blog.csdn.net/zhao5269/article/details/106827618
https://blog.csdn.net/weixin_42343975/article/details/124754154(此教程，安装engin的软链接处有错误)
https://blog.csdn.net/qq_34935373/article/details/120141905
github链接：
https://github.com/autowarefoundation/autoware
三、安装过程中的报错及解决 （1）https://blog.csdn.net/mao_hui_fei/article/details/117260278?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165907745316782391870420%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=165907745316782391870420&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_ecpm_v1~rank_v31_ecpm-1-117260278-null-null.142v35pc_search_v2&amp;utm_term=ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91autoware%E6%97%B6%EF%BC%8C%E6%98%BE%E7%A4%BAkitti_player.cpp%E6%8A%A5%E9%94%99&amp;spm=1018.2226.3001.4187
（2）https://blog.csdn.net/weixin_43569276/article/details/113748675?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2-113748675-blog-124754154.pc_relevant_multi_platform_featuressortv2dupreplace&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2-113748675-blog-124754154.pc_relevant_multi_platform_featuressortv2dupreplace&amp;utm_relevant_index=4
注：大部分报错与cuda、gcc、g++、cudnn等依赖的版本问题、链接问题有关。
四、demo运行与学习参考 参考：
（1）https://gitlab.com/autowarefoundation/autoware.ai/autoware/-/wikis/ROSBAG-Demo
（2）https://blog.csdn.net/r1141207831/article/details/100666532
（3）https://blog.csdn.net/zhao5269/article/details/106864985
（4）autoware入门教程-目录
参考官网上的demo展示操作步骤，总是不成功，因此，找到了一个可行的操作：
4.1 下载示例 3D 点云/矢量地图数据 wget http://db3.ertl.jp/autoware/sample_data/sample_moriyama_data.tar.gz 或者
wget https://autoware-ai.s3.us-east-2.amazonaws.com/sample_moriyama_data.tar.gz 4.2 下载ROSBAG格式下载示例数据 wget http://db3.ertl.jp/autoware/sample_data/sample_moriyama_150324.tar.gz 或者
wget https://autoware-ai.s3.us-east-2.amazonaws.com/sample_moriyama_150324.tar.gz 4.3 创建.autoware目录并在并提取demo所需数据 cd ~ mkdir .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/974fdbfbc901d4070b81a98cf9a51693/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/610db8ee73c7c419c3f38ed489ad0fe4/" rel="bookmark">
			pta mysql 题集（31-50）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10-31 sql-sample ​ select b1.stu_id,b1.stu_name,b1.class_name,b1.score from ( select a3.stu_id,a4.name as stu_name,a2.name as class_name,score from tb_score as a1,tb_class as a2,tb_student_class as a3,tb_student as a4 where a1.stu_id = a3.stu_id and a3.class_id = a2.id and a4.id = a3.stu_id ) as b1, ( select name,min(score) as mins from tb_score as a1,tb_class as a2,tb_student_class as a3 where a1.stu_id = a3.stu_id and a3.class_id = a2.id group by name ) as b2 where b1.class_name = b2.name and b1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/610db8ee73c7c419c3f38ed489ad0fe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61286014377e5d540cc716bdcc8ac5b0/" rel="bookmark">
			Ubuntu20.04 根目录扩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：win10，VMWare15
步骤：
1. 关机状态，在 VMWare 的虚拟机设置中，点击硬盘（SCSI）扩展磁盘容量；虚拟机开机状态是点不了扩展的；
2. 开机状态，非 root 用户下载 gparted，sudo apt-get install gparted；
3. win 键，搜索 gparted，/dev/sda5 分区挂载在 / 根目录下；/dev/sda5 后跟着 /dev/sda3；
紧挨着 /dev/sda5 的未分配分区是 /dev/sda3 的残存。之前 /dev/sda5 只有 30G，扩了 20G。
4. 右键 /dev/sda5 可以调整大小；
那个残存的 1M 都被合进去了。最后点击那个绿色的勾，应用全部操作。
5. /dev/sda5 后面的分区必须为“未分配”状态。
6. 可以用命令行 df -h 查看 /dev/sda5 的大小，是否扩容生效（需要重启一次 reboot）。
注意：
1. 如果在看其他教程修改了 fastab 文件，或者
2. 将新分区挂载到了 /home/yourname 目录下，可能会遇到登录循环问题。
解决：
1. 可以在登录界面按下 ctrl alt f2，进入 tty 终端模式，尝试还原之前的修改操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9deabfcabf4aa4fa0592c82ae034e4f0/" rel="bookmark">
			ROS环境下的串口通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、前言
2、内容
2.1 准备工作
2.1.1 连接外部USB设备
2.1.2 串口调试工具的下载
2.1.3 serial库的安装
2.2 代码部分
2.2.1 编写发布节点
2.2.2 编写发布节点
2.2.3 编辑checklists文件
2.2.4 编辑package.xml文件
2.2.5 编写launch文件
2.2.6 运行节点
3 可能的问题
引用
1、前言 最近项目中有一个需求，在ROS2的环境下，需要接受到两个topic，作出逻辑判断，通过串口发送特定报文到外接USB设备上。之前在论坛中找了好久没有类似的文章，因此在这里记录一下，同学们可以参考，其中如果有问题或者可以优化的地方，欢迎大家指正。
2、内容 2.1 准备工作 由于我使用的是ros2的humble版本，因此一下工作环境皆为ubuntu22.04版本以及ROS2的humble版本。该部分工作在代码编写之前就需要准备好。
2.1.1 连接外部USB设备 在调试之前建议链接USB设备，一并查看系统上是否有串口驱动，通常ubuntu系统已经集成了串口驱动：s541，可以通过以下命令行来查看：
lsmod | grep usbserial 出现一下类似情况说明驱动已经存在
此刻通过频繁插拔外界设备，之后通过下述命令进行判断该设备串口名称
dmesg| grep ttyU* 对话框中会弹出很多内容，找到频繁出现“conect”和“disconect”的便是我们想要的串口。
2.1.2 串口调试工具的下载 在此我们安装使用的是cutecom工具，安装命令见下：
sudo apt-get install cutecom 在使用时可以通过以下命令打开：
sudo cutecom 打开界面见下：
可以在setting部分进行串口参数的配置，这里的将要采用的配置为：9600 8 n 1。
2.1.3 serial库的安装 为了完成ros和外界设备的通讯，还需要安装serial库文件，由于ros2中没有集成serial库，因此需要自己下载源码进行编译安装。btw，ros中可以直接通过apt-get进行安装的，这个我会再写一份文章。
该库虽然是针对foxy的，但是在humble中也可以使用，通过一下进行clone和编译
mkdir serial git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9deabfcabf4aa4fa0592c82ae034e4f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46071ac143f1ad787ac217b444fe715f/" rel="bookmark">
			Linux进程相关命令之ps命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux ps命令用于显示当前进程 (process) 的状态信息使用者权限：所有用户 语法如下：
ps [选项] 选项详情： -a：显示所有终端机下执行的程序，除了阶段作业领导者之外。 a：显示现行终端机下的所有程序，包括其他用户的程序。 -A：显示所有程序。 -c：显示CLS和PRI栏位。 c：列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。 -C&lt;指令名称&gt;：指定执行指令的名称，并列出该指令的程序的状况。 -d：显示所有程序，但不包括阶段作业领导者的程序。 -e：此选项的效果和指定"A"选项相同。 e：列出程序时，显示每个程序所使用的环境变量。 -f：显示UID,PPIP,C与STIME栏位。 f：用ASCII字符显示树状结构，表达程序间的相互关系。 -g&lt;群组名称&gt;：此选项的效果和指定"-G"选项相同，当亦能使用阶段作业领导者的名称来指定。 g：显示现行终端机下的所有程序，包括群组领导者的程序。 -G&lt;群组识别码&gt;：列出属于该群组的程序的状况，也可使用群组名称来指定。 h：不显示标题列。 -H：显示树状结构，表示程序间的相互关系。 -j或j：采用工作控制的格式显示程序状况。 -l或l：采用详细的格式来显示程序状况。 L：列出栏位的相关信息。 -m或m：显示所有的执行绪。 n：以数字来表示USER和WCHAN栏位。 -N：显示所有的程序，除了执行ps指令终端机下的程序之外。 -p&lt;程序识别码&gt;：指定程序识别码，并列出该程序的状况。 p&lt;程序识别码&gt;：此选项的效果和指定"-p"选项相同，只在列表格式方面稍有差异。 r：只列出现行终端机正在执行中的程序。 -s&lt;阶段作业&gt;：指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。 s：采用程序信号的格式显示程序状况。 S：列出程序时，包括已中断的子程序资料。 -t&lt;终端机编号&gt;：指定终端机编号，并列出属于该终端机的程序的状况。 t&lt;终端机编号&gt;：此选项的效果和指定"-t"选项相同，只在列表格式方面稍有差异。 -T：显示现行终端机下的所有程序。 -u&lt;用户识别码&gt;：此选项的效果和指定"-U"选项相同。 u：以用户为主的格式来显示程序状况。 -U&lt;用户识别码&gt;：列出属于该用户的程序的状况，也可使用用户名称来指定。 U&lt;用户名称&gt;：列出属于该用户的程序的状况。 v：采用虚拟内存的格式显示程序状况。 -V或V：显示版本信息。 -w或w：采用宽阔的格式来显示程序状况。　x：显示所有程序，不以终端机来区分。 X：采用旧式的Linux i386登陆格式显示程序状况。 -y：配合选项"-l"使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位　。 -&lt;程序识别码&gt;：此选项的效果和指定"p"选项相同。 --cols&lt;每列字符数&gt;：设置每列的最大字符数。 --columns&lt;每列字符数&gt;：此选项的效果和指定"--cols"选项相同。 --cumulative：此选项的效果和指定"S"选项相同。 --deselect：此选项的效果和指定"-N"选项相同。 --forest：此选项的效果和指定"f"选项相同。 --headers：重复显示标题列。 --help：在线帮助。 --info：显示排错信息。 --lines&lt;显示列数&gt;：设置显示画面的列数。 --no-headers：此选项的效果和指定"h"选项相同，只在列表格式方面稍有差异。 --group&lt;群组名称&gt;：此选项的效果和指定"-G"选项相同。 --Group&lt;群组识别码&gt;：此选项的效果和指定"-G"选项相同。 --pid&lt;程序识别码&gt;：此选项的效果和指定"-p"选项相同。 --rows&lt;显示列数&gt;：此选项的效果和指定"--lines"选项相同。 --sid&lt;阶段作业&gt;：此选项的效果和指定"-s"选项相同。 --tty&lt;终端机编号&gt;：此选项的效果和指定"-t"选项相同。 --user&lt;用户名称&gt;：此选项的效果和指定"-U"选项相同。 --User&lt;用户识别码&gt;：此选项的效果和指定"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46071ac143f1ad787ac217b444fe715f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608f7e0df52961ab9d008b5a6ee4c94b/" rel="bookmark">
			SpringBoot项目上传图片（本地/OSS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot项目上传图片（本地/OSS） SpringBoot项目图片上传图片上传到本地upload.htmlcontroller运行 OSS对象存储UploadUtilcontrollerupload.html 可能会遇到的问题如何搭建spring boot项目如何使用Postman测试文件上传 SpringBoot项目图片上传 图片上传到本地 可参考视频：
【springboot上传图片的两种方式详解（本地/OSS对象存储）】 https://www.bilibili.com/video/BV1TK411Z7ad/?share_source=copy_web&amp;vd_source=7f0416c71bcbaf44e08ad58367e3f198
视频前十分钟是从0开始编写图片保存到本地，可以照着视频敲出来，不想看也可以直接复制我下面的代码
在Resources目录下有一个upload.html文件，和一个static文件夹，static下又有一个images文件夹，如下图
upload.html upload.html
这里主要就是一个form表单，用来提交数据，但是要注意的是我这个表单用了post和enctype=“multipart/form-data”，以及input的类型是file
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;上传图片&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="/uplaod" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file" value="请选择你要上传的图片"&gt; &lt;input type="submit" value="上传"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; controller UploadController
想直接看源码的同学可以跳过分析，往下滑
为了方便演示，我把业务都放在controller，，首先我们要先分析文件上传有几步
文件校验（包括但不限于，图片的大小、图片的类型、图片是否为空、上传的是否是文件等）
我这里只做了一个判空的校验，可以自己加需要的校验 if (file.isEmpty()) { return "图片上传失败"; } 将图片重命名，图片重命名又可分为以下几步
获取原来文件的后缀名，可以使用file.getOriginalFilename()获取原来的文件名
String originalFilename = file.getOriginalFilename(); //原来的图片名 生成一个随机的新文件名，这里可以使用UUID.randomUUID()
String uuid = UUID.randomUUID().toString().replace("-", ""); 把新名称和原后缀名拼接起来作为新的文件名
String fileName = uuid + ext; 把图片上传的指定的目录下，我们这里讲的是Resources，就以Resources为例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/608f7e0df52961ab9d008b5a6ee4c94b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b23f5b523dd3d3887cf18c5631f1a1e/" rel="bookmark">
			好玩Spring之@EnableAspectJAutoProxy解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言例子源码解读AnnotationAwareAspectJAutoProxyCreatorinvokeBeanFactoryPostProcessors(beanFactory)registerBeanPostProcessors(beanFactory) 前言 在Spring中，如果不在配置类中添加@EnableAspectJAutoProxy，那么所有切面注解是不生效的（springboot因为有自动配置，所以不需要开发人员手工配置@EnableAspectJAutoProxy）
例子 @Configuration @EnableAspectJAutoProxy @ComponentScan public class AppConfig { } @Aspect @Component public class LogAspects { @Pointcut("within(tzb.aop..*)") public void pointCut() { } @Before("pointCut()") public void logStart(JoinPoint joinPoint){ Object[] args = joinPoint.getArgs(); System.out.println(joinPoint.getSignature().getName()+" 运行。。。@Before "+ Arrays.asList(args)); } } 源码解读 下面，我们就来看下@EnableAspectJAutoProxy这个注解，究竟做了什么
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(AspectJAutoProxyRegistrar.class) public @interface EnableAspectJAutoProxy { boolean proxyTargetClass() default false; boolean exposeProxy() default false; } 看import里的代码
class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar { @Override public void registerBeanDefinitions( AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { AopConfigUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b23f5b523dd3d3887cf18c5631f1a1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1480ddaf9604082e5892601a9f7509c9/" rel="bookmark">
			python 安装pyspark_Python学习—PySpark环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PySpark环境搭建 一、基础环境准备1、Scala环境搭建1.1 下载1.2 安装1.3 添加环境变量1.4 测试环境 2、JDK环境搭建2.1 下载2.2 安装2.3 配置环境变量2.4 测试环境 3、Python环境准备4、Windows环境 二、Hadoop环境准备1、下载2、安装3、添加环境变量4、测试环境5、本地bin目录替换 三、spark环境准备1、下载2、安装3、添加环境变量4、测试环境 四、安装pyspark1、复制2、本地测试 PySpark是Python整合Spark的一个扩展包，可以使用Python进行Spark开发。而PySpark需要依赖Spark环境，Spark需要依赖Hadoop环境，而且，本地环境需要安装JDK和Scala。 一、基础环境准备 1、Scala环境搭建 1.1 下载 本文环境为2.11.8
Scala下载地址：https://www.scala-lang.org/download/all.html
1.2 安装 （1）若是下载了.msi格式的scala：
直接执行安装即可，后续环境变量可不配置，安装程序会自动配置好，直接1.4测试即可。
（2）若是下载了.zip格式的scala：
将下载好的包解压到本地环境中，比如D:\scala
还需执行1.3环境配置步骤，再执行1.4测试。
1.3 添加环境变量 新增系统变量：SCALA_HOME，值为本地scala安装路径，比如SCALA_HOME=D:\scala。
增加Path系统变量的值，为%SCALA_HOME%\bin
1.4 测试环境 打开命令行窗口，输入scala，出现如下界面表示安装成功。
2、JDK环境搭建 2.1 下载 本文环境为jdk1.8
jdk下载地址：http://www.oracle.com/technetwork/java/javase/downloads
2.2 安装 将下载好的包解压到本地环境中，比如D:\java
2.3 配置环境变量 新增系统变量：JAVA_HOME，值为本地scala安装路径，比如JAVA_HOME=D:\java\jdk1.8.0_352
增加Path系统变量的值，为%JAVA_HOME%\bin
2.4 测试环境 打开命令行窗口，输入java -version，出现如下界面表示安装成功。
3、Python环境准备 本文环境为Anaconda，版本为python 3.7。
4、Windows环境 本文的所有环境均搭建在本地，本地系统为windows10。
二、Hadoop环境准备 1、下载 本文为hadoop-2.8.5
Hadoop下载地址：https://archive.apache.org/dist/hadoop/common/
2、安装 将下载好的包解压到本地环境中，比如D:/Hadoop/hadoop-2.8.5
3、添加环境变量 新增系统变量：HADOOP_HOME，值为本地hadoop安装路径，比如HADOOP_HOME=D:\Hadoop\hadoop-2.8.5。
增加Path系统变量的值，为%HADOOP_HOME%\bin
4、测试环境 命令行中输入hadoop version出现版本信息，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1480ddaf9604082e5892601a9f7509c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce0d1fa98c5053f63b28253206611a12/" rel="bookmark">
			音乐推荐系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题描述如何解决系统设计评测指标推荐系统的用户画像运动音乐场景用户行为分析睡眠音乐场景用户行为分析治愈音乐场景用户行为分析其他音乐场景用户行为分析 问题描述 移动网络和数字多媒体技术的飞速发展促进了数字音乐产业的共享与广泛传播．对用户而言，在海量的音乐库中寻找个人喜欢的音乐需要花费大量的时间和精力。音乐推荐系统的目的是将用户从这项繁琐的工作中解脱出来，从而有效地提高用户体验，为音乐平台创造经济收益。使用基于协同过滤的经典推荐算法，如矩阵因子分解方法，其数据的来源是用户的历史交互数据。协同过滤的应用非常广泛，但同时也面临着数据稀疏和冷启动等问题，同时，由于协同过滤的模型所限，在特征提取方面存在着很多不足，从而会限制推荐系统的准确率。
如何解决 音乐作为一种艺术形式，吸引用户、与用户产生共鸣的因素有很多，其中最重要的就是音频本身的特征，如场景、语言、旋律、乐器、流派、歌词和音乐人等。因此，根据音频本身来进行推荐，推荐效果会更加精准。
音频内容本身包含着吸引用户的特征，如节奏、旋律和乐器等影响用户偏好的因素，因此，有效提取出对用户产生吸引的本质特征是重中之重。使用基于内容的推荐，通过音频处理方法(如离散傅里叶变换)等方法处理音频数据来提取特征，其中涉及一些常用的音乐特征参数，包括频率中心、短时平均能量、过零率、梅尔频率倒谱系数及带宽等。
系统设计 实现基于内容的音乐推荐主要分为以下四个部分：
(1)绘制用户画像，用户画像包括用户的年龄、性别、国籍、听歌偏好及与系统的交互信息等；
(2)将音乐embedding为相应的特征向量；
(3)按选定的推荐方法生成候选集；
(4)将用户画像、音乐的特征向量按照推荐方法建模，在候选集中以TopN的方式为用户推荐相似度高的音乐列表。
用户画像是用户信息的数据化，其目的是为了更加贴合用户的喜好和使用习惯，用户画像也与用户所处情境密切相关。为了更加准确地描绘出音乐作品，第一步需要提取尽可能多的会影响用户偏好的特征，使得推荐更加符合用户需求．音频形式可以通过卷积神经网络来提取特征，这部分就是特征工程，特征工程的目的就是将音频embedding为特征向量；第二步是生成候选集，这一步的目的在于简化处理问题的规模，在保证推荐效果的前提下减小计算量；第三步是排序，排序需要用到前两步的结果，利用用户画像及音频的特征向量作为排序的依据，以用户交互数据来训练回归模型．文献[28]提出了一种潜在因素模型，该模型通过滤波器组处理音频，滤波器通过卷积神经网络提取梅尔频谱系数。梅尔频谱系数是可以用于表示人的听觉效应的特征，基于梅尔频谱特征建模可以学习到潜在的与用户偏好相关的特征，并证明了使用潜在特征可以给出相比于协同过滤更加明确的推荐，而且在一定程度上克服了冷启动的问题．因此，梅尔频谱系数广泛应用于音频信息分析等领域口。文献[31]提出另外一种重要的音频特征—色度向量，可用于判断音阶，从而使推荐效果更加精准。
基于内容推荐的优势在于推荐的依据来源于物品的本身属性，可以有效地避免冷启动和长尾效应问题，推荐准确率也比传统的基于协同过滤算法的推荐系统高。但其面临着特征提取难度高、计算复杂、难以挖掘用户的潜在兴趣等问题。
评测指标 一般做法可以使用点击率、转化率、网站成交额和召回率度量推荐结果或者产生一个TopN推荐列表。这些评价指标本质上都是基于预测准确率。但是这样的系统的评测结构过于单一。针对这一问题，可以使用一些新的评测指标如新颖性以及惊喜度等．通过最优化其中一个评测指标，同时综合其他指标进行推荐，使得推荐效果更加符合用户需求。Celma曾提出流行度长尾尾部的音乐可能更加让用户觉得新颖。假设S表示用户集合，那么用户u的推荐列表的新颖性定义如下：
其中R是一个TopN函数，Ru，20表示把推荐列表中前20项推荐给用户u，popi表示对音乐偏好程度的预期。
文献提出用户需求还应包括意外和惊喜，并提出惊喜度以度量推荐者系统生成推荐列表的偶然性．惊喜度是指推荐结果与所使用的推荐方法得出的用户偏好不同，但用户对结果感到满意．一般通过Unserendipity来度量惊喜度，公式如下：
其中，cosSim(i，h)的值是指用户历史兴趣Hu。和新的推荐结果之间的平均相似度，表示推荐结果和用户历史兴趣的相似程度，相似程度越小，则推荐的惊喜度越大，Zhang等认为理想的推荐系统应模仿可信赖的朋友或专家的行为，并在此基础上提出了Aura- list推荐框架，在准确性、多样性、新颖性和偶然性等四个因素之间取得平衡。使用“偶然发现”的新颖性算法，演示了一种将偶然性、新颖性和多样性成功注人建议中的方法，同时限制了对准确性的影响．研究结果显示，Auralist框架对偶然性的重视提高了用户满意度。
推荐系统的用户画像 运动音乐场景用户行为分析 跑步和健身场景是绝对主流，不同运动偏好收听时长不同。在运动场景偏好上，跑步歌单渗透率高达49.9%。健身歌单也达到了43.0% ，而瑜伽歌单的渗透率则与前两者差距较大，仅有7.1%。具体分析用户的使用习惯可知.健身歌单的用户单次收听超3小时的占比达38.8%。跑步运动较为剧烈，因此超半数用户单次只收听1-2小时。而瑜伽运动由于其较为舒缓，单次收听在2-3小时区段内的人数较另外两个歌单更多。
男性更爱跑步歌单，瑜伽歌单受众群年龄更高。男性和女性在运动场景下的偏好有着明显的差异，男性更爱收听运动场景下的跑步歌单。而女性则偏好健身歌单。同时，在瑜伽歌单的用户分布上，女性愿意收听瑜伽歌单的比例明显要高于男性。在运动场景歌单用户年龄分布上，健身歌单和跑步歌单的用户群最多分布的年龄段是26-30岁，而瑜伽歌单的用户则更多分布在31-35岁之间。
在运动场景下用户最关注音乐的节奏感和舒适感。根据调研，对于运动场景用户而言，能够带来节奏能力是用户在选择场景音乐时最关注的因素.占比高达68.3%。同时，也有63.3%的用户认为运动场景音乐需要提供一个舒适的环境音乐 ，曲风符合当时心情，陪伴其运动过程从而提升运动效率。另外，由于运动健身场景的特殊性，用户对于操作简便、展现形式简单的需求度也比较高，达到了56.2%。
在进行有氧运动时爱听健身歌单，明显偏好节奏型音乐。在健身场景下，用户更偏好在进行有氧运动，热身放松等活动时收听健身场景音乐。对于所有的健身运动类型，能够给用户健身带来节奏感和能量，从而让用户在训练时更好的把握节奏感，是最受关注的因素，特别是对于Tebata、燃脂舞等强度较高的运动。除此之外，健身歌单用户认为音乐能够提供舒适环境音也是比较重要的一个因素，仅次于节奏感。
跑步场景用户最爱在独跑时收听，偏好舒适环境音类音乐。在跑步歌单的使用场景下，有69.6%的用户更偏好在单人独自跑步时收听音乐。而在多人合跑时使用跑步歌单的比例则下降至28.3%，可见在独自一人跑步时用户可能有更强的孤独感 ，因此更倾向于收听音乐陪伴。不同于健身场景的是，跑步作为一个相对比较舒缓的运动，大部分的跑步场景用户都认为音乐作为背景音能够提供舒适的环境音才是最重要的因素。
运动场景用户粘性高，偏好收藏与点赞的互动方式。在运动场景音乐的用户群中，单个用户听歌的频率往往较高，其中每天多次听歌的用户比例高达32.7%。用户平均每周听歌4-5次及以上的比例合计高达87.8% ，体现了整体.上运动歌单用户较高的粘性。在用户的互动习惯方面，整体上来看用户互动性较高，用户经常选择的互动方式最多的是收藏或点赞喜欢的音乐，比例分别为70.1%和65.0%。
睡眠音乐场景用户行为分析 睡眠场景用户偏好轻音乐，小众的脑波音乐受高薪人士偏爱。对于使用睡眠场景的用户而言，轻音乐内容形式(睡前助眠轻音、钢琴纯音乐、入眠音乐)更受欢迎。然而，在总体.上选择较少的Delta脑波及阿尔法脑波音乐，却更加受到高收入人群偏爱。脑波音乐作为一种比较新兴的音乐形式。在高收入人群中已经受到较多欢迎。未来，随着用户对脑波音乐的进一步认知，想必会有更多的用户接受这种音乐形式。
睡眠场景用户更期待音乐能提供平和的氛围。唾眠场景的用户更偏好于能够为其营造舒缓、平和的氛围感的音乐。调研中，有66.9%的用户都认为他们最看重的是睡眠场景音乐能用平顺的音色和节奏，让其进入最低活动状态，从而提升更好的睡眠质量这一点。 除此之外，也有64.5%的用户选择了希望睡眠场景音乐有舒缓作用。同时，也有较多用户偏好使用了自然采样的声音的音乐。
睡眠场景"强陪伴”属性，节假日入睡难更明显。睡眠场景下，用户粘性相较于更多用户每天多次收听的运动场景来说偏低，更多睡眠场景用户是每天收听一次。对于每天收听用户，单次使用时长也相对较长，有超40%用户表示单次使用3小时以上。调研发现，用户更偏好在夜间入睡前收听睡眠场景音乐， 21 : 00-24 : 00是最多用户收听的时段。而且在节假日，用户收听睡眠场景音乐的时段也会整体向后移动，节假日用户入睡难现象显著。
治愈音乐场景用户行为分析 疗愈场景用户最爱舒缓解压音乐，女性更信赖专业医生推荐。疗愈场景的用户总体.上来看，绝大多数用户都偏好舒缓解压类音乐，占比高达83.7%。且在总体上来看，女性更喜欢疗愈场景音乐，在疗愈场景具体的四种内容形式下，女性选择的比例都高于男性。专业医生推荐的疗愈音乐在总体上仅有59.4%的用户比较喜欢。但是，女性偏好.上明显高于男性，可见医生等专业人士的背书对女性来说有更大的作用。
用户最看重歌曲曲风轻松愉悦，更好达到解压作用。用户在选择疗愈场景音乐时最关注歌曲的曲风，其中用户最偏好的歌曲风格是轻松愉悦型，可以帮助其更好的达到解压作用。此外，温暖型的曲风，可以帮助用户舒缓情绪，也得到了较多用户选择。此外，歌单歌曲丰富性在疗愈场景下关注度高，达到63.5% ，作为对比，运动场景为54.8% ，唾眠场景为52% ，可以看出疗愈用户场景用户对歌单丰富性要求更高。
疗愈场景用户对内容质量最满意，女性对疗愈场景满意度高。依据疗愈场景下的用户反馈，用户最为满意的也是场景内容质量，达到4.29分，略低于睡眠场景下的用户满意度。具体来看，女性用户整体.上在五个指标维度给出5分满分的比例都要高于男性，特别是在场景内容时效性和场景内容作品题材两个指标上，男女性别之间给出的评分差距较大。
其他音乐场景用户行为分析 工作场景用户关注音乐是否让人静心，不同年龄偏好显差异。用户在工作场景之下收听音乐最关注的是音乐能够提供一个让人静心的氛围，从而可以不被外界所打扰。不同的年龄段对于工作场景下的音乐形式偏好有所不同， 46岁以上的用户明显偏好令人静心舒缓的音乐歌单;而对于26- 30岁的用户群体来说，他们最偏好的则是提神节奏型的歌单; 31-40岁年龄段的用户则都比较偏好可以提升专注度的音乐歌单。
车载场景下用户偏好自驾游音乐，看重歌曲能否带来轻松感。对于车载音乐场景音乐用户来说，大多数都更喜欢自驾游音乐相关歌单，此外也有60%以上的用户选择了驰骋音乐歌单和夜驾音乐歌单。在用户考量因素方面，用户最关注的因素是音乐歌单能否为用户带来轻松、舒畅的体验，从而舒缓堵车情况下的情绪，此外也有不少用户对歌曲能够扫清驾驶者的疲惫感，提升驾车专注度方面有所要求。
母婴场景用户最爱产后音乐，对其付费意愿较高。在母婴音乐场景之下，更多用户偏好产后音乐歌单，有超过70%的用户进行了选择。用户更看重母婴场景下的音乐是否能够帮助其调整情绪，使其拥有轻松愉快的心情。在付费意愿方面，产后音乐歌单也是拥有最多高付费意愿用户选择的一类，有高达62.8%的用户都表示非常愿意为产后音乐歌单付费，明显高于母婴场景下的其他歌单类型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f67b33209fdd6be7b10805f3aa331714/" rel="bookmark">
			QT 使用第三方库QtXlsx操作Excel表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直以来，都想学习一下C/C++如何操作excel表，在网上调研了一下，觉得使用C/C++去操作很麻烦，遂转向QT这边；QT有一个自带的类QAxObject，可以使用他去操作，但随着了解的深入，觉得他并不是很好，有很多其他缺陷(例如必须电脑安装了办公软件才可以进行操作等)，所以继续调研，终于找到了QT的一个第三方库可以很好的实现：QtXlsx. 目录
一、下载QtXlsx
二、QtXlsx源码嵌入QTCreator中使用
三、QtXlsx源码编译成为.lib库使用
1. 下载安装Perl
2. 编译QtXlsx
3. 在vs中使用
四、QtXlsx
1. 知识点
2. 使用公式
五、练手小demo
Github下载：https://github.com/dbzhang800/QtXlsxWriter
官方文档：http://qtxlsx.debao.me/
在Github下载后，可以直接添加到QtCreator项目中，也可以编译成lib库后再添加到VS中去使用。
一、下载QtXlsx 点击链接进入Github下载
下载解压后得到如下文件
二、QtXlsx源码嵌入QTCreator中使用 新建一个QTCreator窗体项目
将上图src文件夹拷贝到该项目路径中
之后双击项目中的.pro文件
将如下代码拷贝到.pro文件中
include(src/xlsx/qtxlsx.pri)
Ctrl + s 保存一下，就可以把QtXlsx源码模块加载进来啦！
可以在项目构造函数中添加如下代码进行测试：
#include "xlsxdocument.h" #include "xlsxchartsheet.h" #include "xlsxcellrange.h" #include "xlsxchart.h" #include "xlsxrichstring.h" #include "xlsxworkbook.h" QXlsx::Document xlsx; xlsx.write(1, 2, "Hello Qt!"); xlsx.write(2, 2, QString::fromLocal8Bit("中文")); xlsx.saveAs("Text.xlsx"); 编译运行后，就可以在项目路径看到程序创建的Text.xlsx文件，打开后就可以看到写入的 "Hello Qt!"和"中文".
三、QtXlsx源码编译成为.lib库使用 1. 下载安装Perl 下载安装：Perl
下载链接：https://strawberryperl.com/
注意，这个是一定要下载安装的，否则编译lib库会编译失败！！！ 下载后默认安装即可
2. 编译QtXlsx 打开下载的QtXlsx文件夹，双击打开.pro
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f67b33209fdd6be7b10805f3aa331714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e25be52cc7614bf0c7cf11276257a123/" rel="bookmark">
			SSH远程免密登录的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSH远程免密登录的两种方式 一、ssh远程登录操作1.先ping测试下看看网络是否通畅2.ssh 192.168.150.148 二、ssh免密登录方式一1.生成公钥、私钥2.拷贝公钥到目标服务器3.测试ssh免密登录 三、ssh免密登录方式二1.生成本机的公钥私钥2.打开本地公钥文件复制公钥信息3.将公钥存放到目标服务器的这个文件里：/root/.ssh/authorized_keys4.测试免密登录 服务器之间经常需要有一些跨服务器的操作，此时就需要我们在一台服务器上登录到另外一台服务器，若是人为操作时我们都可以每次输入密码进行远程登录，但要是程序需要跨服务器时，每次输入密码就不现实了，所以我们需要免密登录 一、ssh远程登录操作 这里先看看正常使用ssh连接其他服务器的操作。准备了两台服务器ip分别为：192.168.150.175、192.168.150.148。这里使用175登录148。
1.先ping测试下看看网络是否通畅 可以看到网络正常，可以ping通
2.ssh 192.168.150.148 然后操作ssh开始登录，此时就需要我们输入密码了，这个密码就是我们服务器root的密码了。
注意：若是第一次登录这台服务器会弹出一个问题：问你是否需要继续连接此服务器，输入yes即可。
正常输入密码后即可实现ssh登录了。
ssh登录这样就算ok了，但其实我们还是比较关心如何免密进行ssh登录。
二、ssh免密登录方式一 其实很简单，只需要三步即可：
1.生成公钥、私钥 ssh-keygen 执行该命令然后对于弹出提示直接三次回车即可。这个命令本质上就是生成公钥和私钥的。我们也无需为他们制定特殊的存放位置回车就是都用默认的即可。通过下面的图可以看出，公钥在/root/.ssh/id_rsa.pub，私钥在/root/.ssh/id_rsa
2.拷贝公钥到目标服务器 ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.150.148 使用这个命令可以把本机的公钥copy到192.168.150.148上，命令有点类似scp，所以这里也是需要输入密码的
3.测试ssh免密登录 ssh 192.168.150.148 如下图我们可以看到，无需输入密码，直接ssh就成功了
三、ssh免密登录方式二 认真看过第二种方式就会知道，第二种方式必须要知道服务器的密码，而且还是root密码，这个在工作中可能有点难度，所以我们真正使用这个方式比较靠谱吧。
1.生成本机的公钥私钥 这个与方式一里面的的第一步没有任何区别，执行下面的命令三次回车即可
ssh-keygen 2.打开本地公钥文件复制公钥信息 vim /root/.ssh/id_rsa.pub # 复制公钥信息，下面是笔者的公钥信息 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDtehroANIusfqfD7iCklRKsRnLB8PmlF8C76NWZqYWx017LrwGUogDquMpgfUt4JNMAPaOMvAzs6M97yiHpsn/SFWRDDsqdJ72z0K1wtnU6L3gjZ6yzy/of4f7C34CA2wehjMCEQ4PUgic2YCU1sxY0I/lEUA7cdEib5Mw/aoNJKBcVg/iwJh26YVB4+V3pUh77FK/xL9MqB6ZIaTqrzHk5+mTpRiQQKlwm6CD4XtKXXzn5+PPiPsGYpGQyat8wWVeGvqssvKK6vYzEILW6umeRekGLKZLG/jwBkf7RZMjwhs55CMSGM+/VK1FveGh5k2mz3zEOo39w03RjzFWIhqb root@bogon 3.将公钥存放到目标服务器的这个文件里：/root/.ssh/authorized_keys 什么？没有这个文件，那就在本地执行下下面这个命令
ssh localhost 这样本地就会产生这个文件了，然后我们将2里面拿到的公钥存放进来即可，注意若是该文件不为空，就换行新增本次的公钥就行，不要去覆盖别的公钥，不然会造成其他服务器登录这台服务器时免密失败。
4.测试免密登录 ssh 192.168.150.148 其实两种方式本质上没有区别，都是将公钥放到目标服务器上即可，一种采用scp的方式，一种是直接登录服务器放到对应文件里即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f82c4e371bb8dda0f2193b796d5b5c/" rel="bookmark">
			FTP工作原理及过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 FTP文件传输协议，使用两个端口，21端口为控制端口，20端口为数据连接端口，客户端连接FTP服务器首先会和服务器的21端口发起控制连接，控制连接在整个过程中是一直保持的；当有数据传输是会进行数据连接，数据传输完毕之后会断开数据连接。数据连接又分为主动模式PORT和被动模式PASV。
二、两种模式 1、主动模式 主动模式简单来说就是控制连接成功之后，客户端告诉服务器使用PORT模式进行数据传输，并且把自己用于数据传输的随机端口发送给服务器，等待服务器使用20端口随时来访。
首先客户端和服务器的21端口进行三次握手建立控制连接；输入账号密码登录FTP。
​
客户端发送PORT命令带上自己的IP和用于数据连接的端口，当有数据传输时，服务器使用20端口和客户端进行三次握手建立数据连接。
​ 2、被动模式 被动模式简单来说就是控制连接成功之后，客户端告诉服务器数据传输需要使用PASV模式，随后服务器发送自己用于数据传输的端口，等待客户端随时来访。
下图为控制连接和账号密码等数据包交互过程，首先客户端和服务器的21端口进行三次握手建立控制连接；然后客户端输入账号密码等信息。
响应代码：
220表示服务器准备就绪
​
331表示需要输入密码才可登录
​
230表示登陆成功，并且是登录因特网的，不是使用的代理
​
SYST报文表示返回服务器使用的操作系统表示返回服务器使用的操作系统。
​
CWD指令为更改访问目录，比如说点进去一个文件等
​
250表示已成功进入到切换目录。CWD指令完成
​
PWD请求包，表示请求返回当前路径，返回码257表示已返回当前路径信息
​
其他：
RETR: 下载文件。“RETR test.txt \r\n”：下载文件test.txt。
STOR: 上传文件。“STOR test.txt\r\n”：上传文件 test.txt。
QUIT: 关闭与服务器的连接。
从以上数据包可以看出FTP是明文传输。
需要进行数据读取或者传输的时候客户端会给服务器发送数据传输模式。下图为客户端给服务器发送请求包，数据包里显示客户端希望数据传输使用PASV模式，服务器收到之后将自己用于数据传输的端口发送给客户端，客户端的随机端口和服务器的数据传输端口进行三次握手后就可以进行数据交互了。
​
​ ​
还有一些其他的，可根据数据包里的内容显示就可以看出来了。每操作完成一次都会进行四次挥手断开数据连接。
3、主动模式和被动模式的区别 主动模式是客户端发送用于数据连接的随机端口给服务器，服务器主动去建立数据连接；被动模式是服务器发送用于数据连接的随机端口给客户端，客户端去建立数据连接。
三、NAT的环境 NAT是针对于TCP和UDP报文中的IP和端口的转换，NAT并不能转换应用层数据里边的字段。而FTP协议是由控制连接和数据连接组成的，在数据连接是建立成功与否是由控制连接中的的应用层载荷字段决定的。比如客户端向服务器发送PORT命令时会在应用层协议字段中带有自己的IP和端口，如果经过NAT，报文中的IP和端口是改变了，但是应用层字段里边的IP和端口不会改变，这时，服务器看到的IP和端口还是NAT前的地址，服务器会向这个NAT前的地址和端口发送三次握手请求，会导致数据连接失败，所以这个时候就需要ALG来改变应用层字段来解决。
ALG是什么？ ALG是应用层网关，开启ALG可以修改数据包中应用层的数据进行解析和做地址转换。
可支持多种应用层协议：FTP、H.323（包括RAS、H.225、H.245）、SIP、DNS、ILS、MSN/QQ、NBT、RTSP、SQLNET、TFTP等。
以FTP为例：
FTP客户端配置
​
AR1配置
AR1 &lt;Huawei&gt;system-view [Huawei]nat alg ftp enable [Huawei]interface GigabitEthernet 0/0/0 [Huawei-GigabitEthernet0/0/0]ip address 192.168.1.1 255.255.255.0 [Huawei-GigabitEthernet0/0/0]nat static global 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1f82c4e371bb8dda0f2193b796d5b5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/276738ee340bdf38606d2425cab92a2a/" rel="bookmark">
			JDBC和MyBatis的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDBC 1.JDBC概述 JDBC 就是使用Java语言操作关系型数据库的一套API
全称：( Java DataBase Connectivity ) Java 数据库连接
我们开发的同一套Java代码是无法操作不同的关系型数据库，因为每一个关系型数据库的底层实现细节都不一样。如果这样，问题就很大了，在公司中可以在开发阶段使用的是MySQL数据库，而上线时公司最终选用oracle数据库，我们就需要对代码进行大批量修改，这显然并不是我们想看到的。我们要做到的是同一套Java代码操作不同的关系型数据库，而此时sun公司就指定了一套标准接口（JDBC），JDBC中定义了所有操作关系型数据库的规则。众所周知接口是无法直接使用的，我们需要使用接口的实现类，而这套实现类（称之为：驱动）就由各自的数据库厂商给出。
各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发可随时替换底层数据库，访问数据库的Java代码基本不变 以后编写操作数据库的代码只需要面向JDBC（接口），操作哪儿个关系型数据库就需要导入该数据库的驱动包，如需要操作MySQL数据库，就需要再项目中导入MySQL数据库的驱动包。如下图就是MySQL驱动包
2.JDBC的代码步骤 创建工程，导入驱动jar包
注册驱动
Class.forName("com.mysql.jdbc.Driver"); 获取连接
Connection conn = DriverManager.getConnection(url, username, password); Java代码需要发送SQL给MySQL服务端，就需要先建立连接
定义SQL语句
String sql = “update…” ; 获取执行SQL对象
执行SQL语句需要SQL执行对象，而这个执行对象就是Statement对象
Statement stmt = conn.createStatement(); 执行SQL
stmt.executeUpdate(sql); 处理返回结果
释放资源
完整代码演示：
/** * JDBC快速入门 */ public class JDBCDemo { public static void main(String[] args) throws Exception { //1. 注册驱动 //Class.forName("com.mysql.jdbc.Driver"); //2. 获取连接 String url = "jdbc:mysql://127.0.0.1:3306/db1"; String username = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/276738ee340bdf38606d2425cab92a2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42bb5b83eec823929d43f8d1d352cc8a/" rel="bookmark">
			springboot导入Excel表格数据到MySQL数据库/从数据库导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入Excel表格数据到数据库/从数据库导出 SpringBoot-导入/导入ExcelApache POI实现导入功能校验Excel版本核心代码完整代码数据库表pom.xmlapplication.yamlspring boot启动类domainmapperserviceimpl controller页面 运行 实现导出功能 SpringBoot-导入/导入Excel 所谓导出，就是把数据库中表的数据导出到 excel文件中；导入，就是把 excel文件中的数据导入到数据库表中。这功能类似数据库的导入导出功能，只是区别在于这个操作者是普通用户，是在浏览器操作的，使用excel更易于阅读。
Apache POI Apache POI 是 Apache 软件基金会的开放源码函式库，POI 提供 API 给 Java 程序对 Microsoft Office 格式档案读和写的功能。
poi中关于excel的概念 Workbook（对应为一个excel）
Sheet（excel中的表）
Row（表中的行）
Column（表中的列）
Cell（表中的单元格，由行号和列号组成）
添加依赖 该段代码可在：下文完整代码——pom.xml中找到
&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 实现导入功能 将Excel中的数据导入MySQL数据库
这里为了方便操作数据库我集成了mybatis-plus
校验Excel版本 该段代码可在：下文完整代码——service——impl中找到
//校验上传的文件是否是Excel表格 if (!fileName.matches("^.+\\.(?i)(xls)$") &amp;&amp; !fileName.matches("^.+\\.(?i)(xlsx)$")) { throw new BusinessException(CommonCodeMsg.IMPORT_TYPE_INVALID); } boolean isExcel2003 = true; //判断Excel版本 if (fileName.matches("^.+\\.(?i)(xlsx)$")) { isExcel2003 = false; } InputStream is = null; Workbook wb = null; try { is = file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42bb5b83eec823929d43f8d1d352cc8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/237ead250bf14432f7125a932e17de47/" rel="bookmark">
			stm32-GPIO原理及代码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、输入
1模拟输入：
2输入上拉：
3输入下拉
4模拟输入
二、输出
1开漏输出
2推挽式输出
3推挽式复用功能
4开漏复用功能
三、GPIO端口初始化
代码注解：
复用时需要函数
失能函数：
输出模式：
四、相关配置函数stm32f10x_gpio.h
设置输出电平函数：
读取输出电平函数：
读取输入电平：
结构图：
我们从上往下看：
我们先看最上面的虚框：
一、输入 1模拟输入： I/O口走上路，此时上拉下拉电阻都未打开，直接走自己专属线路。它不过肖特基触发器，就代表他不能用简单的0，1表示。所以它是专属于AD的接口。
2输入上拉： 我们接通上拉电阻的开关，通过肖特基触发器。那么这个口由于上拉电阻那一路电路就默认高电平。
3输入下拉 同输入入上拉相同，我们只需稍作改动。将上拉改为下拉。那他就默认了低电平。
4模拟输入 我们想想我们不上拉，不下拉，不模拟输入。这个电路必然会很容易受到外界影响。
二、输出 我们先看一个细节，输入输出殊途同归最后到了一条线。也就是说，我们输出的同时一些输入点路的寄存器也可以用。
1开漏输出 也就是P-MOS屏蔽掉。N-MOS发挥作用（低电平有效P相反）也就是说他只可以输出低电平。除非电路外接上拉电阻。（通信使用iic之类） 2推挽式输出 两个mos管都有效，既可以输出高电平也可以输出低电平。 3推挽式复用功能 4开漏复用功能 这两个除了由片上外设控制外和普通的都一样。 我们将输入和输出写道一个结构体中。 我们得到代码： typedef enum { GPIO_Mode_AIN = 0x0, GPIO_Mode_IN_FLOATING = 0x04, GPIO_Mode_IPD = 0x28, GPIO_Mode_IPU = 0x48, GPIO_Mode_Out_OD = 0x14, GPIO_Mode_Out_PP = 0x10, GPIO_Mode_AF_OD = 0x1C, GPIO_Mode_AF_PP = 0x18 }GPIOMode_TypeDef; 日常使用我们只需调用即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/237ead250bf14432f7125a932e17de47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fed2ff4d2ca8ea649e3de84eaa83193c/" rel="bookmark">
			【数据库之postgreSQL】全文索引之飞快
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搜索是项非常重要的功能，所以像和solr和es这样的基于的工具变得很流行。但使用这些大规模“杀伤性”的搜索武器，需要额外的成本。有时候我们只想用下简单的搜索，但是关系型数据库的的like和in又太慢，更别提find_in_set()函数，任何在密集sql查询里面使用函数都是罪大恶极。
那么postgresql就是你的首选了，使用它的理由是
我们只需使用postgresql，不必安装其它的搜索引擎，就能支持良好的千万级搜索性能。使用其它的数据库（比如mysql），全文索引十分不稳定。
这里不再介绍什么是全文索引，请自行gg or dd
注意这里还有个坑：如果某个索引字段值为空，会导致索引失效，查不出数据。所以一定不能为null PostgreSQL 中的全文搜索 全文搜索(FTS) 允许对文档进行预处理并保存索引以供以后快速搜索和排名。请参阅官方文档（https://www.postgresql.org/docs/13/textsearch-intro.html），该文档非常完整，提供了理解和实施 FTS 所需的所有信息。
PG（Postgres）中 FTS 的主要构建块是：
tsvector，它代表一个可搜索的文档tsquery，这是针对文档执行的搜索查询 转换为文档类型 to_tsvector函数解析输入文本并将其转换为表示可搜索文档的搜索类型。说人话就是to_tsvector是PostgreSQL内置的一个分词函数，它可以将一段文本按照某种分词规则进行分词
SELECT to_tsvector('Java in a nutshell') 将输出以下内容：
"'java':1 'nutshel':4" 结果是准备被搜索的词位列表，停用词（“in”、“a”、“the”等）被删除
数字是文档中词位的位置：java:1从第 1 个位置开始，而nutshell:4从第 4 个位置开始（PostgreSQL目前并不支持中文分词，如果需要对中文分词，则需要安装中文分词器，现在最流行的是zhparser）
查询 to_tsquery函数解析输入文本并将其转换为表示查询的搜索类型。例如，用户想要搜索“java in a nutshell”：
SELECT to_tsquery('java &amp; in &amp; a &amp; nutshell'); 将给出以下内容
"'java' &amp; 'nutshel'" 结果是准备好被查询的列表
停用词（“in”、“a”、“the”等）被删除
运算法 @@ 运算符允许将查询与文档匹配并返回 true 或 false
/* true */ SELECT to_tsquery('java &amp; in &amp; a &amp; nutshell') @@ to_tsvector('Java in a nutshell'); 发现没有，其实到目前为止我们并没有建索引，而是通过to_tsquery转换来实现完成全文检索功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fed2ff4d2ca8ea649e3de84eaa83193c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4729212decc3730247d073c5d5b1fe47/" rel="bookmark">
			第八章 服务器端渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.1 初识服务器渲染 8.1.1客户端渲染和服务端渲染的区别 客户端渲染，即传统的单页面应用（SPA）模式，Vue.js构建的应用程序默认情况下是一个HTML模板页面，只有一个id为app的div根容器，然后通过webpack打包生成css、js等资源文件，浏览器加载、解析来渲染HTML
html仅仅作为静态文件，客户端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端，然后根据html上的JavaScript，生成DOM插入html
服务器端渲染，Vue进行服务器端渲染时，需要利用Node.js搭建一个服务器，并添加服务器端渲染的代码逻辑。使用webpack-dev-middleware中间件对更改的文件进行监控，使用webpack-hot-middleware中间件进行页面的热更新，使用vue-server-renderer插件来渲染服务器端打包的bundle文件到客户端。
服务器端渲染，是前后端不分离的模式，界面都是服务器端准备好的，浏览器只管请求就好了
服务端渲染相对于传统的SPA（单页面应用来说），主要有以下优势：
利于SEO
首屏渲染速度快
服务器端渲染的不足：
服务器端压力增加
涉及构建设置和部署的要求
8.1.2服务器端渲染的注意事项 1.版本要求
2.路由模式
hash模式中改变hash值不会重新加载页面
history模式利用history.pushStateAPI来完成URL跳转而无需重新加载页面
由于hash模式的路由提交不到服务器上，因此服务器端渲染的路由需要使用history模式
8.2服务器端渲染的简单实现 8.2.1创建vue-ssr项目 服务器端渲染的实现，通常有3种方式：
①手动进行项目的简单搭建
vue-server-renderer是Vue中处理服务器处理的一个模块，给Vue提供在Node.js服务器端渲染的功能
②使用Vue CLI3脚手架进行搭建
③利用一些成熟框架来搭建（如Nuxt.js）
8.2.2渲染vue实例 1.创建Vue实例
2.创建渲染器
3.将Vue实例渲染成html
8.2.3Express搭建SSR Express是一个基于Node.js平台的Web应用开发框架，用来快速开发Web应用
1.创建Express实例
2.读取模板
3.处理GET请求
4.将vue实例渲染为html并输出
8.2.4Koa搭建SSR Koa是一个基于Node.js平台的Web开发框架，致力于成为Web应用和API开发领域更富有表现力的技术框架
1.创建koa实例
2.读取模板
3.添加中间件处理所有请求
4.将vm渲染为html
8.3webpack搭建服务器端渲染 8.4Nuxt.js服务器端渲染框架 8.4.1创建Nuxt.js项目 Nuxt.js是一个基于Vue.js的轻量级应用框架，可用来创建服务端渲染应用，也可充当静态站点引擎生成静态站点应用，具有优雅的代码结构分层和热加载等特性
脚手架工具：create-nuxt-app
①确保已经安装好了node.js和vue-cli脚手架
②全局安装create-nuxt-app脚手架工具
npm install create-nuxt-app@2.9.x -g ③在项目存储目录下执行以下命令，创建项目
npx create-nuxt-app my-nuxt-demo ④在创建项目过程中，会询问选择哪个包管理器，在这里选择使用npm
⑤当询问选择哪个渲染模式，在这里选择使用SSR
⑥安装配置完成后，启动项目
cd my-nuxt-demo npm run dev 8.4.2页面和路由 在项目中，pages目录用来存放应用的路由及视图，目前该目录下有两个文件，分别是index.vue和README.md，当直接访问根路径"/"的时候，默认打开的是index.vue文件
Nuxt.js会根据目录结构自动生成对应的路由配置，将请求路径和pages目录下的文件名映射
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4729212decc3730247d073c5d5b1fe47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef6f4812d6f9e22f77f9e2dbd2f6b3a/" rel="bookmark">
			【每日一问】面试官：如何对数据库进行优化？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【每日一问】如何实现数据库的优化？ 要解决数据库的优化问题，可以从表结构优化、sql优化和索引优化三个方面考虑
一、表结构优化 首先，在业务场景合适的情况下，我们可以尽量更小的数据类型存储数据。为了减少连表查询，我们还可以适当添加冗余字段。也可以在表的一些字段上建立索引，优先考虑where、order by、group by使用到的字段。但是要考虑到索引失效的问题。还有就是建立的索引不宜过多，过多的索引反而会减低sql的查询效率 二、sql优化 尽量避免使用select *，避免出现全表扫描的情况，毕竟查询到不需要的字段，也是一种资源浪费。多表联查的时候，遵循小表在前，大表在后的原则。查询的时候，我们尽量把数据量小的字段放在前面，提高查询效率。当数据量大时，避免使用where 1=1的条件，避免全表扫描，可以使用动态sql进行优化。当我们进行连表查询的时候，可以使用表的别名，并把表的别名放在字段的前缀上，这样就可以减少sql解析的时间。尽量避免出现全表扫描的情况，比如使用了in/not in，or，或者对字段进行is null判断,模糊查询两边都用%括起来，例如'%小%'，就尽量不要使用。查询使用到了索引的时候，就要检查sql是否会命中索引，避免索引的失效。 三、索引优化 索引优化问题其实就相当于如何避免索引的失效问题
尽量避免在字段开头模糊查询，比如%A会导致数据库引擎放弃索引进行全表扫描。如果需要一定要在前面使用模糊查询，我们可以使用MySQL的内置函数INSTR(str,substr)来进行模糊匹配。尽量避免使用in/not in，这样会导致走全表扫描。针对连续的值，我们可以使用between来代替；如果是子查询，那么可以使用exists来代替。尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。可以使用union来代替or.尽量避免对字段进行is null判断，会导致数据库引擎放弃索引进行全表扫描。 可以给字段添加默认值0，对0值进行判断。尽量避免在索引列中运算查询条件不能用 !=不要再索引列上进行任何操作，比如计算，函数操作等字符串类型一定要加上引号，因为mysql数据库存在隐式转换。强制改变原有类型会导致查询不走索引。 大概从这些方面去回答，就可以直面面试官的“严刑拷打”喽~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21869f08f6441dee9e11159794b1f966/" rel="bookmark">
			2022_TIP_DSNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Boosting RGB-D Saliency Detection by Leveraging Unlabeled RGB Images 通过利用未标记的RGB图像来增强rgb-d显着性检测
1. 动机 1) 用于监督学习的像素级注释既昂贵又耗时。
2) 与RGB图像相比，成对的rgb-d图像更难以收集。
2. 解决方法 提出 Dual-Semi RGB-D Salient Object Detection Network（DS-Net），利用没有标记的RGB图像来增强 RGB-D 显著性检测。
第一步：设计了一个depth decoupling convolutional neural network (DDCNN)，包含两个分，depth estimation branch and a saliency detection branch.
1. depth estimation branch：由RGB-D 图像训练，然后用于估计所有未标记的RGB图像的伪深度图，以形成配对数据。
2. saliency detection branch：用于融合RGB特征和深度特征以预测rgb-d显著性。
第二步：将第一步中的DDCNN作为骨干网络，用于半监督的教师学生框架。
第三步：介绍了未标记数据的中间注意力和显著图的一致性损失（consistency loss ），以及标记数据的监督深度和显著性损失。
3. 网络框架 用带标记的数据训练深度分支，将得到的模型用于生成未标记的RGB图片的深度图， 3.1DDCNN 包含两个分支，depth estimation branch and a saliency detection branch。给定一对输入的rgb-d图像: 将RGB图像传递到编码器以生成RGB特征，深度图像送到另一个编码器提取深度特征。
在depth estimation branch 中，使用“Conv(3×3) → BN → ReLU → Conv(3×3)”的卷积块将每个RGB特征分解为两个特征：（1）用于估计深度图的深度感知特征，(2)用于预测显著性的深度消除特征。深度感知特征上采样到与相同大小，并应用“Conv(3×3) → Conv(1×1)”的卷积块串联在一起以预测深度图。此外，我们融合和来重建RGB特征，并计算重建损失来正则化解耦过程:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21869f08f6441dee9e11159794b1f966/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73ad983ac566669a39cd53ebd8f0f851/" rel="bookmark">
			static修饰的成员方法,变量及其初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.static修饰的成员变量 static修饰的成员变量，称为静态成员变量，静态成员变量最大的特性：不属于某个具体的对象，是所有对象所共享的。
【静态成员变量特性】
不属于某个具体的对象，是类的属性，所有对象共享的，不存储在某个对象的空间中既可以通过对象访问，也可以通过类名访问，但一般更推荐使用类名访问类变量存储在方法区当中生命周期伴随类的一生(即：随类的加载而创建，随类的卸载而销毁 2.static修饰的成员方法 static修饰的成员方法,成为静态方法,其也是不属于某个具体的对象,是所有对象共享的.
【静态成员方法特性】
不属于某个具体的对象,是类的属性,是所有对象共享的,不存在对象的空间中既可以通过对象访问,也可以通过类名访问,但是一般更推荐使用类名访问,体现其实类的属性 3.成员方法与静态成员变量一样储存在方法区中
4.生命周期伴随类的一生
package demo3; public class Demo3 { static String name; int age; public static void func(){ System.out.println("这是一个静态的成员方法"); } } class Demo99{ public static void main(String[] args) { Demo3 demo3=new Demo3(); Demo3.func();//使用类名来调用静态的成员方法 demo3.func();//使用对象的引用来调用静态的成员方法 demo3.name="yaoyao";//使用对象的引用对静态的成员变量进行赋值 Demo3.name="哈哈";//使用类名对静态成员变量进行赋值 System.out.println(demo3.name);//使用对象的引用来调用静态 //成员变量 System.out.println(Demo3.name);//使用类名来调用静态成员变量 } } 3. 如何对静态成员进行初始化 方法一:
在创建时进行初始化
方法二:
后续初始化
方法三:
用set方法进行初始化
方法四:
使用静态的代码块进行初始化
但是我发现使用非静态的代码块好像也可以对静态成员变量进行初始化
运行结果如图:(结果就是非静态的代码块覆盖掉了静态代码块所赋的值)
方法五:
在构造方法中初始化静态成员变量(仅仅是尝试)
运行结果:(目前根据运行结果来看是可以的)
应该还有很多方法来初始化我们的静态成员变量,我们可以不断尝试下… 🐾完…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741e2427e574a80da42564d7eff9fbce/" rel="bookmark">
			论文写作总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 此贴总结了我在闵帆老师的《论文写作》课程上学习到的一些论文写作的注意事项以及个人的课程心得体会。
一、浅谈论文写作 论文写作是我们研究生阶段不可或缺的一部分，大多数人都是为了达到毕业条件，当然还有小部分人是真的热爱科研，还不耽误拿奖学金，真好！本科的时候好像只写过毕业论文，用word写的。研究生就不能在用word写了，用LaTeX写！它可以解决多数格式问题，且每种期刊都会提供一个或多个格式文件。 Latex 源文件只需要进行少量改变，就可以获得完全不同的版面。上手之后才发现真香。才研一上学期，我的同门都在写第三篇论文了，而我才学了一点皮毛。果然，写论文要越早越好，本科阶段起步最好。应该抓住任何时间任何地点写论文。 二、论文开题 题目对于论文来说至关重要。如果说论文是孩子，那么题目就是他的名字。论文的题目必须要有吸引力，对于计算机方面论文而言，应该写出自己提出的新问题或新方法。 新问题应该有意义而且有挑战性， 新方法则应该高效或准确。题目中的术语和其它词汇应该在该领域内常用，不应该要求读者借助词典才能理解。长度最好控制在 40-60 个字母之间，越短表示创新性越高。尽量不使用 based on。使用 through，with 等来表示技术。 三、摘要 从中文的角度，"摘要"就是把论文重要的内容摘录出来； 从英文的角度, Abstract 就是把重要的内容抽取出来。它通常包括三个部分：已有工作的评述，本文工作的描述，实验结果。 有些期刊明确要求按照 Background, contribution, experiments 三个方面描述。按照闵老师的规划包括10句：
（1）问题及其重要性
（2）已有工作
（3）已有工作的局限性
（4）本文工作
（5） 本文方法的第 1 个技术/步骤/方面/优势/贡献
（6）本文方法的第 2 个技术/步骤/方面/优势/贡献
（7）本文方法的第 3 个技术/步骤/方面/优势/贡献
（8）实验设置
（9）实验结果
（10）提升 四、关键词 在现代搜索引擎 (包括词云) 开发之前，关键词是用于检索论文的一种重要的方式。 虽然现在人们可以进行全文检索，但关键词仍然很常用。关键词常被看作摘要的一种补充，一般需要 3–5 个关键词。关键词一般由 1–3 个单词构成，将关键词按照字母表排序。 有些期刊支持两类关键词
index term: 由期刊提供, 只能从投稿网站给定的列表选择
keywords: 作者自己按需写 五、引言 "引言"的本意是为论文作一些铺垫，然而， 在计算机英文论文中， Introduction 需要讲述完整的故事。 如果说摘要是电影 5 分钟宣传片的话, 引言就应该是整个的剧本。 很多审稿人在读完引言后，就有了基本 (80% 以上) 的判断。它可以遵循与摘要相同的节奏。我们可以把摘要中的每一句话扩展到引言中的一段。每段应有 5–10 句。这样，该段就有 50-150 个单词。如果相邻两段都太短， 应把它们合并到一起。如果某段太长，就应该拆分，或者直接减少文字。计算机领域 (特别是顶会) 流行在引言里面放 “开局一张图”。 如果采用这种风格， In this paper 之后就应该围绕该图进行解释。“一幅图胜过千言万语”， 该图可以帮助读者花最少的时间理解论文的主要内容。该图可以展现核心技术、算法框架、小的运行实例、效果对比等等。最后一段的“The rest of the paper is organized as follows”是独立的。 六、文献综述 每篇论文都应有文献综述，表示对前人工作的尊重，我们是站在巨人的肩头上当读者不清楚某些技术的细节时便于查阅。文献需要进行分门别类的介绍，便于读者理解你这项工作的位置。参考文献的引用一般仅仅是一种附属品，先写一个完整的句子，再把参考文献的引用加上去。不应将参考文献的引用作为句子的主语、宾语等。引用一次不要超过 3 篇，否则又是堆砌的感觉。不提倡全句引用。一定要多参考到最近的一些文章，如果审稿人只看到了你的参考都是太久远的内容，会认为你的文章没有可看性。同时也要多参考好的论文，例如被引的次数多的，作者的声望很高的那类论文。 七、符号系统与数学表达式 禁止使用Winword编写方程式并将其转换为latex，直接用Latex打。变量为斜体，常量和运算符为非斜体。在Latex中，使用$将确保这种格式所有方程式都应编号。换句话说，它们应该从\begin{equation}开始。当文本中的数学表达式过长时，应将其拆分为多个表达式。等式是句子的一部分，因此在它之后应该有逗号、半列或句点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/741e2427e574a80da42564d7eff9fbce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/665eaf45f9ce1aab6b29c32c2414cc9f/" rel="bookmark">
			C&#43;&#43; 实现机房预约系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档为黑马程序员C++课程记录笔记，课程链接：c++教程
文章目录 1.机房预约系统需求1.1 系统简介1.2 身份简介1.3 机房简介1.4 申请简介1.5 系统具体需求 2.创建项目2.1创建项目2.2 添加文件 3.创建主菜单3.1 菜单实现3.2 搭建接口 4.退出功能实现4.1 退出功能实现4.2 退出功能测试 5.创建身份类5.1 身份类的基类5.2 学生类5.2.1 功能分析5.2.2 类的创建 5.3 老师类5.3.1 功能分析5.3.2 类的创建5.4 管理员类5.4.1 功能分析5.4.2 类的创建 6.登录模块6.1 全局文件添加6.2 登录函数封装6.3 学生登录实现6.4 教师端的登录实现6.5 管理员登录实现 7.管理模块7.1 管理员登录和注销7.1.1 构造函数7.1.2 管理员子菜单7.1.3 菜单功能实现 7.2 添加账号7.2.1 添加功能实现7.2.2 去重操作7.2.2.1 读取信息7.2.2.2 去重函数封装7.2.2.3 添加去重操作7.2.2.4 Bug解决 7.3 显示账号7.3.1 显示功能实现7.3.2 测试 7.4 查看机房7.4.1 添加机房信息7.4.2 机房类创建7.4.3 初始化机房信息7.4.4 显示机房信息 7.5 清空预约7.5.1 清空功能实现 8.学生模块8.1 学生登录和注销8.1.1 构造函数8.1.2 管理员子菜单8.1.3 菜单功能实现8.1.4 接口对接 8.2 申请预约8.2.1 获取机房信息8.2.2 预约功能实现 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/665eaf45f9ce1aab6b29c32c2414cc9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9135ce753335c505dd97179cb5fec28/" rel="bookmark">
			用JavaScript写代码将硬盘序列号从16进制字符串转换为ASCII字符串，兼谈EditPlus和Edge浏览器对JavaScript脚本支持的一点差别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写的系统信息收集报告程序SysInfo的一个功能就是收集并报告系统中的硬盘序列号。在之前的测试中这项功能表现不错，但前两天用SysInfo收集一台电脑的信息时，显示的硬盘序列号与其它硬盘序列号读取程序显示的顺序不一样。于是着手对SysInfo的相关代码进行修改，由于读取到的硬盘序列号原始数据是一个16进制字符串，比如“20202020202020202020202039574d41374d5659”，我们首先要把这个16进制字符串转换成对应的ASCII，才好进一步做对比分析。
在这方面，直接用JavaScript应该是最方便的了。因为JavaScript提供了两个非常有用的函数：parseInt()和String.fromCharCode()。
一、parseInt()
首先说说parseInt()。
（一）功能：解析字符串并返回整数。
（二）语法：
parseInt(string, radix) （三）参数说明： 参数描述string必需。要解析的字符串。允许前导和尾随空格。radix 可选。代表要使用的数字系统的数字（从 2 到 36）。
如果 radix 参数被省略，JavaScript 假定如下：
如果字符串以 "0x" 开头，则基数为 16（十六进制）；
如果字符串以 "0" 开头，则基数为 8（八进制）（注：此特性已弃用）；
如果字符串以任何其他值开头，则基数为 10（十进制）。
注意：只返回字符串中的第一个数字！
（四）返回值：
类型描述number 返回一个整数。
如果第一个字符不能转换为数字，则返回 NaN。
二、String.fromCharCode()
（一）功能：可接受一个指定的 Unicode 值，然后返回一个字符串。
（二）语法：
String.fromCharCode(numX,numX,...,numX) （三）参数说明：
参数描述numX必需。一个或多个 Unicode 值，即要创建的字符串中的字符的 Unicode 编码。 （四）返回值：
类型描述String返回代表 Unicode 编码的字符。 为了方便使用，我用editplus设计了一web页面，在一个form中包括了四个部分：
一是输入待转换字符串的文本框；
二是选择待转换字符串的进制基数的radio，有2、8、10、16四个常用的选项，其中默认选定16进制；
三是输出转换后的ASCII的文本框；
四是实现转换功能的按钮。
代码如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="Generator" content="EditPlus®"&gt; &lt;meta name="Author" content=""&gt; &lt;meta name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9135ce753335c505dd97179cb5fec28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b1412a10df2be0ce81c0a45312f954f/" rel="bookmark">
			新版Cmder空格问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 新版Cmder空格问题解决 解决办法 搜了很多资料说: 把文件 cmder/vendor/clink.lua 文件中的 λ 字符换成别的
// 我的修改位置在51行 如果不是的话也一定就在附近几行 // 修改前 local lambda = "λ" // 修改后 local lambda = "&gt;&gt;" 然而我根本找不到local lambda这个变量，倒是找到了这个
if not prompt_lambSymbol then prompt_lambSymbol = "λ" end 然而改掉后没什么卵用
解决办法 config/cmder_prompt_config.lua
# 第22行 prompt_lambSymbol = "$" # 把原来的λ改掉了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7863c834462a59ce8e8114ea6afa8e54/" rel="bookmark">
			深聊性能测试，从入门到放弃之： Windows系统性能监控(二) 资源监控器介绍及使用。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源监控器介绍及使用 1、引言2、资源监视器2.1 打开方式2.2 基本介绍2.3 使用 3、总结 1、引言 小屌丝：鱼哥，我看了你这篇《Windows系统性能监控(一) 性能监视器介绍及使用》，让我学到了好多知识。
小鱼：嗯，我自己在写这篇文章的时候，也学到了好多。
小屌丝：是吗，你不都是知道了，咋还又学到了好多；
小鱼：这个很正常啊，你把你会的知识，重新以文字的形式输出出啦， 你就会发现， 你又有了更深的一层理解，甚至，你会发现，你以前理解的是不是不全呢？
小屌丝：额… 还有这层功效？？
小鱼：不仅是功效，还是疗效…
小屌丝：好吧，我只能说，知识的匮乏，加大了我与大佬之间的距离…
小鱼：大佬，那都是被摧残了无数次以后，依然"站立着"，依然坚持着自己最初的梦想，依然持续的奋斗着。
小屌丝：鱼哥，说的太好了， 太感动的…
小鱼：你确定 “敢动”？？
小屌丝：怎么不感动啊，呜呜呜… 感动的我鼻涕一把眼泪一把的…
小鱼：那这样你动一下，告诉我，啥赶脚。
小屌丝：…不敢动，不敢动…
只要小屌丝不敢动， 我们就来分享 Windows系统性能监控第二篇，资源监控器的学习。
同样，在进入到今天的主题前，先思考几个问题：
在你的知识库里，你觉得资源监控器是监控什么呢？打开资源监控器都有哪些方式呢？资源监控器与 性能监视器有什么区别?资源监视器与任务管理器有什么区别呢？ 带着这几个问题，我们就进入今天的分享。
2、资源监视器 2.1 打开方式 同样这里主要说两种：
1、快捷键：windows键+R键， 弹窗输入 resmon 即可打开
资源监视器 界面
2、搜索方式：搜索栏直接输入"资源监视器"，打开即可；
2.2 基本介绍 资源管理器，可以从以下几点来了解：
1、可以实时显示有关硬件（CPU、内存、磁盘和网络）及软件（文件句柄和模块）资源的使用情况。2、在Windows Vista及之后的操作系统中自带（在Windows Vista中，它是可靠性和性能监视器的一部分）。3、用户可以执行resmon.exe启动该程序（仅Windows Vista中为perfmon.exe）。4、大量利用了Windows 7引入的Windows事件跟踪（ETW）机制；计数器设置（事件跟踪会话）也被资源监视器用作提供日志。 [1] 2.3 使用 在资源监视器的页面，我们就可以看到 ，5个tab，如下：
概述：CPU、磁盘、网络、内存；
CPU：进程、服务、关联的句柄、关联的模块、视图；
内存：进程、物理内存、视图；
磁盘：磁盘活动进程、磁盘活动、存储、视图；
网络 ：网络活动进程、网络活动、TCP链接、侦听端口、视图；
所以，我们可以知道，在资源监视器中，我们可以得到这CPU、内存、磁盘、网络的信息情况。
3、总结 看到这里， 关于Windows系统自带的资源监控器的内容，就介绍的差不多了。
其实，Windows系统自带的性能监视器，还是有很强大的功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7863c834462a59ce8e8114ea6afa8e54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc807ba3880f19c05d93b14e464ec2d/" rel="bookmark">
			Hbase和Phoenix二级索引测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
生成测试数据
Phoenix创建映射表和视图
创建映射表
创建视图
其他操作
创建二级索引
测试二级索引
问题：
1、创建完二级索引之后，hbase新增数据，索引是否会自动创建
前言 本文主要测试Phoenix二级索引。
生成测试数据 之前的文章中详细的介绍了数据生成和导入hbase中的过程，详情请点击这里
Phoenix创建映射表和视图 创建映射表 #删除映射表时，hbase中的数据也会被删除 create table "test"("rowkey" varchar primary key,"cf"."2502" varchar,"cf"."2503" varchar,"cf"."2000" varchar,"cf"."VID" varchar,"cf"."VIN" varchar); 创建视图 #删除视图时，hbase中的数据不受影响 create view "test"("rowkey" varchar primary key,"cf"."2502" varchar,"cf"."2503" varchar,"cf"."2000" varchar,"cf"."VID" varchar,"cf"."VIN" varchar); 其他操作 #where条件查询 select * from "test" where VIN='LNPHDRAG4LVKEF9994'; #查看执行计划，如果出现FULL SCAN则没有走索引，属于全表扫描 explain select * from "dingzq" where VIN='LNPHDRAG4LVKEF9994'; 创建二级索引 create index "index_test" on "dingzq" ("cf"."VIN"); 执行之后可能会报如下错误：
Error: ERROR 1029 (42Y88): Mutable secondary indexes must have the hbase.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc807ba3880f19c05d93b14e464ec2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ae709da9a794bc4c9baa765796fb4e/" rel="bookmark">
			[Java] 什么是锁？什么是并发控制？线程安全又是什么？锁的本质是什么？如何实现一个锁？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言并发控制并发访问控制是什么？如何实现并发访问控制？并发访问控制 与 线程安全 锁是什么？1. 加锁操作2. 解锁操作锁状态是什么？ 如何实现一个锁？笔者相关博客连接结语 前言 多线程编程中，锁是最重要的一个概念，但也是最容易理解错误的概念之一，理解好锁和并发控制是掌握多线程编程的重中之重，笔者将用本文去讲解锁以及并发控制的本质，以及尝试去实现一个锁。
并发控制 在讲解锁之前，有必要先讲解其前置知识：并发控制。
并发控制，英：Concurrency Control，也被称为并发访问控制，英：Concurrency Access Control。
在多线程环境下，当多个线程同时访问共享数据（堆内存里的数据）时，因为线程缓存机制很容易发生数据错误。一个比较典型的例子就是多线程计数器。如下：
可以看到执行两次结果分别是 61011 和 57257，那么我们期待的结果很明显是100000。这就是不做并发访问控制的严重后果。
并发访问控制是什么？ 那么究竟如何理解并发访问控制呢？我们程序员有意识地主动地去控制多个线程去有序地访问共享数据的这么个处理呢被叫做并发访问控制。
如何实现并发访问控制？ 前面我们提到了并发访问控制的本质其实是程序员主动的控制多线程有序地访问共享数据。那么如何实现并发访问控制呢？答案很简单，就是 利用锁来实现 多个线程在时间线上有序地访问共享数据。
什么意思呢？试想一下一堆人不排队去枪盒饭和一个有人组织排队去领盒饭的区别。
不排队去抢盒饭是类比多线程不做并发访问控制（是并行的）。有人组织排队去领盒饭则是类比多线程做了并发访问控制，在盒饭这个资源的操作（是串行的）。 不难理解串行的效率是低于并行的，因为串行会有额外的排队（等待）开销的，要想保障数据的正确性，就得做并发访问控制，而做并发访问控制就不得不做串行处理，因此效率的降低是必不可少的代价。等于是用时间换取数据的正确性。
上面的例子我们提到了 有人组织排队（维持秩序），对应到我们程序里就是锁了，这个我们后面章节讲。
对于如何实现并发访问控制这个问题呢，也很简单了，就是当多个线程操作共享数据时一定要获取到锁（资格）才进行修改，否则就一直等待直到成功获取到锁，修改完成后释放锁（资格），让其他线程也能去获取锁去进行数据的操作。
并发访问控制 与 线程安全 线程安全其实是并发访问控制的一个产物，一旦我们的组件对其内部的数据做了 完善的（注意是完善的） 并发访问控制，那么我们可以说这个组件是 （多）线程安全 的
那么是不是做了并发访问控制就一定线程安全呢？答案是 不一定。如果组件的开发者对于共享数据的并发访问控制逻辑有漏洞，那么其也不能算是线程安全的。如下面的例子：
上面的代码呢，就是典型的做了并发访问控制（syncAdd方法），但又没完全做（add方法）。导致MutiThreadCounter组件并非是线程安全的。你可以在这里看到样例源码。
所以其实锁并不是真正意义上的锁，你锁了其他线程就真的无法操作数据了，而是抽象意义上的锁，你即使加锁了，开发者依然能够使用其他线程任意操作被锁保护的数据。线程安全的真谛是当开发者发现没有获取到锁时停止对数据的访问。所以不难想象锁是个类似符号一样的东西，只有修改了这个符号成功的线程才主动去修改线程则是锁工作的原理了（下面章节讲）
锁是什么？ 上面我们提到了，多线程需要做并发控制来保证线程安全。而做并发控制需要依赖一种工具，这个工具就叫锁。不难想象锁这个工具的最核心的两个功能如下：
加锁（Lock）解锁（Unlock） 下面我们分别介绍一下这两个操作的核心思想。
1. 加锁操作 加锁操作是一个并发操作，意味着通常需要考虑多个线程同时会执行加锁操作。而常规锁（特殊设计的锁除外）的设计是同一时间只能有一个线程成功获取到锁（也叫锁竞争成功）。
对于锁竞争成功的线程 锁这个工具类是直接返回 让线程能够继续执行指令。
对于锁竞争失败的线程 锁这个工具类是会阻塞当前线程 让线程卡在加锁的操作直到获取锁成功。
不难看出在这里锁工具类的职责就是帮我们去竞争锁以及在失败时阻塞线程（这是锁的开发者需要实现的）。
加锁成功这个在程序实现上也是非常简单，无非就是标记当前线程为锁的主人。比如JUC里大名鼎鼎的AQS里就有相关的标记某线程为主人的代码。
而线程阻塞的方式也很简单，有重量级的OS级别的实现也有轻量级的进程级别的实现。
OS级别的重量级实现是：OS支持线程休眠然后通过内核唤醒线程的方式来实现，就比如Java的内置锁的重量级锁模式（Java关键字 synchronized）进程级别的轻量级实现是：无限循环，直到获取锁成功。比如下面的截图里的for ( ; ; )，也是出自AQS类。 两种实现在锁持有时间上的不同场景下，有不同的表现，比如可以看出轻量级实现是会一直循环去尝试获取锁。这种情况下分配给线程的CPU时间片会全部用于执行锁获取代码，直到锁获取成功，这意味着较大的CPU使用率，这会使得在其他线程会长时间持有（占用）锁时，轻量级锁有明显的劣势。
而重量级锁与之相对，因为线程会休眠，休眠时是不会占用CPU资源的。但因为线程休眠到唤醒会有线程 上下文切换（Context Switch） 的开销，这个开销是比较昂贵的，通常是微秒（µs）级别的开销。如果不理解微秒级是多昂贵的开销的话，参考QPS 10万这个高性能指标，1秒10万请求，平均1个请求不超过10微秒。你就知道上下文切换有多昂贵了。所以如果锁持有时间很短的话是推荐使用无限循环这种实现方式，可以节省很多上下文切换的开销。Java里面内置锁有锁膨胀机制，会自动根据锁的使用情况去选择轻量级锁亦或是重量级锁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14ae709da9a794bc4c9baa765796fb4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/431ac5359109a71a7c81a6e25c6237ba/" rel="bookmark">
			基于STM32的温度控制系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：记录毕设
文章目录 前言一、任务书1.1设计(研究)目标:1.2设计(研究)内容: 二、代码思路三、硬件四、联系我们五、设计六、框图代码等资料喜欢请点赞哦！ 前言 基于STM32的温度控制系统，主控使用STM32F103ZET6，在正点原子的精英板上开发（本人也在野火板子上测试成功）。
一、任务书 1.1设计(研究)目标: 我们研究一种基于STM32的智能温度控制系统。该系统以STM32F103作为主控芯片﹐配备了PTC加热器、测温模块﹑等一系列模块。本文设计的温度控制系统主要目标是实现温度的设定值显示、实际值实时测量及显示，通过单片机连接的温度调节装置由软件与硬件电路配合来实现温度实时控制 ；显示可由软件控制在 LCD1602 中实现 ；比较采集温度与设定阈值的大小，然后进行循环控制调控，做出降温或升温处理 ；同时也可根据判断发出警报，用以提高系统的安全性。同时，单片机通过esp8266无线传输到手机上，以便管理人员查看。
1.2设计(研究)内容: 1、题目的意义;
2、各种传感器及设备的一般技术和特殊技术的学习:
3、通信以及控制器的技术要求;
4、总体方案的选型设计；
5、STM32单片机及其外围设备的软硬件系统的技术开发:
6、系统的调试和总体运行原理
7、其他设计内容;具体要求:
1、硬件要求1张1号以上的大图:
2、软件以流程图方式表示:
3、有调试的说明。
二、代码思路 打开定时器4，作为系统运行时间；
为了保证通讯：ESP8266每1S刷新一次；
三、硬件 ESP826601sPTC模块OLED按键蜂鸣器（板子自带）DS18B20测温模块 四、联系我们 承接stm32单片机、STC系列单片机设计、嵌入式。问题咨询联系QQ：2424644692我们在某宝有店铺噢~，搜店铺名：“晖亿科创” 五、设计 主控制器
主控制模块是由 STM32F103单片机最小系统构成，该控制器具有高性能、低成本、低功耗等特点，采用性能较高的ARMCortex-M3 的 32 位的 RISC 内核，工作频率是 72MHz，内部有高速存储器 ( 高达 128K 字节的闪存和 20K 字节的 SRAM)，丰富的增强型 I/O 端口和联接到两条 APB 总线的外设。数字温度测量模块
模拟信号在远距离传输过程中，由于所需引线较长，系统会产生误差补偿、多点切换及放大电路的零点误差等问题。此外，考虑到测量现场的电磁环境十分不确定，干扰信号可能比较强，模拟信号易受到干扰因素导致产生测量误差，影响测量的精度。因此，本系统采用一种抗干扰能力较强的新型数字温度传感器 DS18B20 来避免发生上述问题温度显示模块
显示模块主要用于显示状态以及温度值，本设计选用简单易用的 LCD1602。它是一种专门用来显示英文字母、阿拉伯数字、标点符号等的点阵型液晶模块，由 2*16 个 5X7 点阵字符位组成，每个点阵块都可以显示一个字符，每位点阵块之间有一个点距的间隔，两行之间也有间隔，起到了字符间距和行间距的作用。由于 LCD1602 所需电压为 5V，因此它与3.3V 的单片机连接需要将 STM32 设置为开漏输出，且连接 5V的上拉电阻提高电平温度控制模块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/431ac5359109a71a7c81a6e25c6237ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cfc289713df02d73c978874c2ff768c/" rel="bookmark">
			Visual Studio Code之xml编辑器安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 xml格式是普遍使用的数据文件格式，比较方便的一种编辑xml格式的方式是在VS Code中安装一个xml插件，在打开xml格式的文件时自动启用插件，这样就省的安装其他的软件了，毕竟对于程序员来说VS Code基本都要用的。
点击VS Code在左边的侧边栏中最后一个控件： 搜素xml，安装下图所示的插件： 安装结束后关闭VS Code，随便打开一个xml文件，如下图所示，软件自动启动xml的插件，此时就可以对xml文件进行各种编辑，很方便，插件也很小。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cdc85fa1fa7dc7dad9e332f1b04e393/" rel="bookmark">
			变换域去噪技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变换域去噪的基本思想是先将图像从空间域变换至某个变换域中，随后再对变换域中的稀疏进行处理，最后通过反变换回到原始空间域来达到去除噪声的目的。典型的方法有小波变换去噪和多尺度分析去噪。
1.小波变换去噪
小波变换去噪是将图像变换到小波域，利用图像和噪声在小波变换下的不同特性，对小波稀疏进行处理，通过最大限度地保留图像信号的系数而减少噪声系数来除去噪声。常见的小波去噪方法有模极大值法、系数相关法和系数收缩法等。
（1）模极大值法
模极大值重构方法利用信号与噪声的小波变换模极大值的不同特性，通过剔除那些幅度随尺度减小的噪声模极大值点，保留幅度随尺度增大的信号模极大值点，来除去噪声[1]。这类方法可以较好的去除白噪声和脉冲噪声，但是重构时需进行复杂的交替投影，容易造成重构信号的偏差。
（2）系数相关法
系数相关法是利用各尺度下小波系数的相关性来去除噪声的方法[2]。信号经小波变换之后，其小波系数在各尺度上具有很强的相关性，在边缘处的相关性更加明显，而噪声对应的小波系数没有这种相关性。根据这个规律，系数相关方法对系数进行区分和取舍，从粗尺度到细尺度逐步搜索信号的主要边缘，然后直接重构得到恢复信号。
（3）系数收缩法
该方法以信号能量为依据，认为信号的能量可由一小部分小波系数表示，信号对应的系数数目较少，且幅值较大，而噪声对应的系数是一致分布的，个数较多，但幅值小[3]。基于这个思想，该方法通过选取一个合适的阈值，对小波分解后各层系数进行阈值处理，来除去噪声。
阈值处理的方式有硬阈值和软阈值。硬阈值处理只保留较大的小波系数，将较小的小波系数置为0，这样只保留了部分细节信息，但容易产生伪吉布斯现象；软阈值处理将较小的小波系数置为0，对较大的小波系数向0作收缩，这样可以得到比较光滑的图像，但容易丢失边缘信息。小波系数收缩法计算速度快，被广泛使用。但是该方法的去噪效果依赖于阈值的选取，如果选择不当便容易将小的信号和噪声一起去除，造成失真。
2.多尺度分析去噪
多尺度几何分析利用图像自身结构的几何正则性，能很好地表示图像中的直线、曲线等高维奇异特征，从而客服了小波分析的不足。多尺度几何分析在保证较低均方误差的同时，实现了对图像数据的精简表示，表现出较强的去噪潜力。
参考文献：
[1] S.Mallat,W.L.Hwang.Singularity detection and processing with wavelets.IEEE Trans. Inform.Theory,1992,38(2):617-643
[2] Y.Xu,B.Weaver,D.Healy.Wavelet transform domain filters:a spatially selective noise filter ration technique.IEEE Trans.Image Process,1994,3(6):747-758
[3] D.L.Donoho.Denoising by soft thresholding.IEEE Trans.Inform.Theory,1995,41(3):613-627
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6567bd89e7b77bc9b67138c3664e7c7f/" rel="bookmark">
			mac下Neo4j｜jdk安装配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac下Neo4j｜jdk安装配置 一、Neoj4和jdk下载安装二、Neo4j启动 一、Neoj4和jdk下载安装 neo4j和jdk的版本号要对应，这里下载jdk版本为jdk11，neo4j为neo4j-community-4.4.15，测试可以使用。
下载链接：neoj4下载， jdk下载
1、neo4j
解压后将文件夹移动至访达中/usr/local路径下
2、jdk
官网注册账号就能下载，然后一直点击继续安装jdk
进入终端配置jdk
open -e .bash_profile JAVA_HOME= /Library/Java/JavaVirtualMachines/jdk-11.0.17.jdk/Contents/Home PATH=$JAVA_HOME/bin:$PATH:. CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:. export JAVA_HOME export PATH export CLASSPATH 出现对应版本号即配置成功
java -version 二、Neo4j启动 进入终端，启动neo4j
cd /usr/local/neo4j-community-4.4.15 ./bin/neo4j console 浏览器打开网址：http://localhost:7474/
登录neo4j，并修改密码
端口号：7687
账号：neo4j
密码：neo4j
control+c 直接退出neo4j
参考链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c68a44f491e31888435d72d20947dc61/" rel="bookmark">
			CTF入门密码题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：凯撒大帝拿着贝斯弹着歌曲跳过了2道栅栏 密码：PCTAZA2SLYPYN3GKMIJIPA2SSX====== 对于题目，一眼看出了几个关键字
┏—凯撒-&gt;凯撒加密
┝—贝斯-&gt;(base谐音)常见base，即64，32
┗—栅栏-&gt;栅栏编码（因为栅栏编码有传值需求，所以两道栅栏也就成为了关键词）
目前，对于这道题就基本解析完毕
凯撒解密下线解密网址：http://www.atoolbox.net/Tool.php?Id=778
base32编码网址
base64编码网址
栅栏编码网址
首先使用凯撒解密工具得到密文：MZQXWX2PIVMVK3DHJFGFMX2PPU====== 开始的时候使用base64解码，发现解不出来，然后就继续尝试base32解码，得到了密文：fa{_OEYUlgILV_O} 最后通过栅栏解码，字数2，解除flag： flag{I_LOVE_YOU} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a52015cdf254eb05249669208f1ac3ba/" rel="bookmark">
			Qt 控件之显示窗口部件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 控件之显示窗口部件 Qt Designer 显示窗口部件提供了10种显示小部件：
Label:标签Text Browser：文本浏览器Graphics View：图形视图Calendar Widget：日历LCD Number：液晶数字Progress Bar：进度条Horizontal Line：水平线Vertial Line：垂直线OpenGL Widget：开放式图形库工具QQuick Widget：嵌入式 QML 工具 下面将通过实例讲解每种显示窗口部件是如何使用，并能实现什么效果
1. QLabel QLabel 类提供一种用于文本或图像显示的小部件
以下实例实现的效果：显示一张图片
创建新项目，注意不勾选 “Generate form”，默认继承 QMainWindow 类按照如何在 Qt Creater 中添加资源文件一文中介绍的方法添加图片文件头文件 “mainwindow.h” 中具体代码如下 #ifndef MAINWINDOW_H #define MAINWINDOW_H #include &lt;QMainWindow&gt; #include &lt;QLabel&gt; class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); ~MainWindow(); private: /* 用一个 QLabel 对象用于显示字符串 */ QLabel *labelString; /* 用一个 QLabel 对象用于显示图像 */ QLabel *labelImage; }; #endif // MAINWINDOW_H 源文件 “mainwindow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a52015cdf254eb05249669208f1ac3ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6d2ef00dcc38b39292fb912f4cd3d54/" rel="bookmark">
			open3d学习系列之1读取深度图和彩色图生成点云数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		open3d学习系列之1读取深度图和彩色图生成点云数据 import pyrealsense2 as rs import numpy as np import cv2 import matplotlib.pyplot as plt import open3d as o3d # load image and depth from .png and .npz file img_f = 'abc.png' color_image = cv2.imread(img_f) cv2.imshow('img', color_image) cv2.waitKey(1) depth_image = np.load(img_f.replace('.png', '.npz'))['data'] o3d_color = o3d.geometry.Image(color_image) o3d_depth = o3d.geometry.Image(depth_image) rgbd_image = o3d.geometry.RGBDImage.create_from_color_and_depth(o3d_color, o3d_depth, depth_scale=1000.0, depth_trunc=1000.0) # 转换为open3d中的相机参数 pinhole_camera_intrinsic = o3d.camera.PinholeCameraIntrinsic( intrinsics.width, intrinsics.height, intrinsics.fx, intrinsics.fy, intrinsics.ppx, intrinsics.ppy ) # use open3d save to ply file tmp = o3d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6d2ef00dcc38b39292fb912f4cd3d54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5afc4c8182d8fb2285e50b7493a989f/" rel="bookmark">
			SVN报错 ：Unable to connect to a repository at URL 服务器积极拒绝访问 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：由于公司原SVN服务器准备停用，需要在新服务器上安装SVN，安装好之后连接SVN的时候提示Unable to connect to a repository at URL 以及 服务器积极拒绝访问。
我试过的方法：CSDN里的有关文章我都试过了还是不行
我试过的方法见此文章：https://blog.csdn.net/yyx3214/article/details/79552627
我自己出现的问题
1. 输入指令ps aux |grep svnserve如图看第一个SVN所在地址，找到对应的文件夹看SVN文件夹后有没有文件夹了，比如我之前一直报错是因为我的SVN地址原先是/home/svn/
2.输入指令kill -9 -ID上图root后面的数字ID（我是4362输入自己服务器所显示的ID不要输入我的ID噢）
3.输入指令svnserve -d -r /home/svn/odm 自己SVN所在的文件夹切记一定要到最后一个文件夹不然就会报跟标题一样的错误（不要直接复制我的噢！）
4.输入指令 ps aux |grep svnserve 查看下下图显示的SVN详细地址跟服务器目录一样即可
5.然后就可以愉快的登录SVN啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a8dd5f181dfa6aa0953168deba5cb0/" rel="bookmark">
			SG90舵机介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SG90舵机简介
SG90舵机是一种位置（角度）伺服的驱动器，适用于那些需要角度不断变化并可以保持的控制系统。在机器人机电控制系统中，舵机控制效果是性能的重要影响因素。舵机可以在微机电系统和航模中作为基本的输出执行机构，其简单的控制和输出使得单片机系统非常容易与之接口。
塑料齿轮SG90舵机 金属齿轮SG90舵机
SG90舵机应用
SG90舵机目前在高档遥控玩具，如航模、包括飞机模型、潜艇模型、遥控机器人中已经使用得比较普遍。
SG90舵机导线
SG90舵机上有三根线，分别是GND（棕色线）、VCC（红色线）和SIG（黄色线），也就是地线、电源线和信号线。
SG90舵机工作原理
控制信号由接收机的通道进入信号调制芯片，获得直流偏置电压。它内部有一个基准电路，产生周期为20ms，宽度为1.5ms 的基准信号，将获得的直流偏置电压与电位器的电压比较，获得电压差输出。最后，电压差的正负输出到电机驱动芯片决定电机的正反转。当电机转速一定时，通过级联减速齿轮带动电位器旋转，使得电压差为0，电机停止转动。当然我们可以不用去了解它的具体工作原理，知道它的控制原理就够了。就象我们使用晶体管一样，知道可以拿它来做开关管或放大管就行了，至于管内的电子具体怎么流动是可以完全不用去考虑的。
SG90舵机舵机的控制
舵机的控制一般需要一个20ms 左右的时基脉冲，该脉冲的高电平部分一般为0.5ms~2.5ms 范围内的角度控制脉冲部分。以180 度角度伺服为例，那么对应的控制关系是这样的：
0.5ms ---------- 0 度；
1.0ms ---------- 45 度；
1.5ms ---------- 90 度；
2.0ms ---------- 135 度；
2.5ms ---------- 180 度；
小型舵机的工作电压一般为4.8V 或6V，转速也不是很快，一般为0.22/60 度或0.18/60 度，所以假如你更改角度控制脉冲的宽度太快时，舵机可能反应不过来。如果需要更快速的反应，就需要更高的转速了。
SG90舵机舵机控制例程
/************************舵机控制************************* 单片机型号：STC15W4K56S4 选择单片机内部时钟，频率为22.1184M。
舵机信号线（橙色导线）接到单片机P2.1上。 ***********************************************************/
#include "stc15.h" //包含头文件stc15.h #define Dj_Left1 2 //舵机左转角度
#define Dj_Left2 3 //舵机左转角度
#define Dj_Left3 4 //舵机左转角度
#define Dj_Left4 5 //舵机左转角度
#define Dj_Middle 6 //舵机回到中间位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a8dd5f181dfa6aa0953168deba5cb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10b63f04efbaf64bc34bf7adfb5625e/" rel="bookmark">
			bitset常用方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，介绍 bitset是一个可以位数开很大的二进制类似数组一样的工具，可以进行一系列位运算等二进制运算，且操作性更强，可以用于标记数组，状态压缩等等
2.定义方法 //无初始值，全部为0 bitset&lt;N&gt;a1;//常数定义，注意，N必须是常数，不可以是变量，这里N已经用const修饰了，这个开了N位的二进制a，最低位0，最高位N-1,可以通过下标直接访问，如a1[0] //有初始值 bitset&lt;N&gt;a2(666);//初始值为666的二进制，高位不够补零 bitset&lt;N&gt;a3(string("1010010"));//初始值为字符串，高位不够补零 //字符串另一种写法 字符串是越右边的给二进制越低位，跟字符串自己的下标相反 string x = "1001010011101"; bitset&lt;N&gt;a4(x); bitset&lt;N&gt;a5(x, 2, 3);//从x的下标2开始，copy3位 cout &lt;&lt; a1 &lt;&lt; '\n' &lt;&lt; a2 &lt;&lt; '\n' &lt;&lt; a3 &lt;&lt; '\n' &lt;&lt; a4 &lt;&lt; '\n' &lt;&lt; a5; //位运算操作 a3 ^= a2; cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; a3; 3，常用函数 bitset&lt;N&gt;a; int k=6; //统计操作 a.count();//统计多少位是1 a.any();//有1位是1返回1 a.none();//全0返回1 a.size();//a的位数，即N //赋值操作 a.set();//全部置为1 a.set(k);//第k位置为1，即a[k]=1 a.reset();//全部置为0 a.reset(k);//k位置为0,a[k]=0 a.flip();//全部按位取反 a.flip(k);//k位取反，即a[k]^=1 //转换函数 string b=a.to_string();//转为字符串 ull a1=a.to_ullong();//转为ull unsigned ll a2=a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b10b63f04efbaf64bc34bf7adfb5625e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a8c96a56f979efcbc8cfe83bb2e5ae/" rel="bookmark">
			KY275 对称平方数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 KY275 对称平方数 for i in range(1,256): square = str(i*i) if square == square[::-1]: print(i) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0be25e404a9adeb8527500e091d1e96/" rel="bookmark">
			KY267 对称平方数1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 KY267 对称平方数1 for i in range(257): s = str(i*i) if s==s[::-1]: print(i) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3915509ab9965c36cc62954acdffc95c/" rel="bookmark">
			从 0 到 1 搞一个 Compose Desktop 版本的天气应用（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，好久不见，今天带大家一起来玩下 Compose Desktop ，带大家从头到尾写一个桌面版的天气应用，并且打好包让别人也可以进行使用，废话不多说，先来看下最终的实现效果吧！
效果是不是挺好？哈哈哈！
其实作为一个安卓开发来说，当运行起第一个桌面版程序的时候内心突然感觉回到了最开始学习编程的时候，那种感觉就好像一个多年未见的老友对你说：久违了！特别是使用的技术还都是安卓开发的技术，只是有一些平台原因需要稍做修改的地方就能开发出一个完整的桌面版软件，内心还是非常激动，非常地有成就感，这种感觉太舒服了！
踩坑 缘起 Compose 为什么会搞 Compose Desktop，这还得从 Jetpack Compose 说起：Google 从 2017 年开始立项开搞 Compose 到第一个正式版本用了四年的时间，那么久的时间，投入了那么多的人力，以及后面投入了大量经费宣传，无一不在告诉安卓开发者 Compose 很重要，这也是之后安卓开发的新方向！所以当第一个 alpha 版本的 Compose 出现的时候我就坐不住了，立马加上依赖尝试了下！刚开始写的时候感觉有点奇怪，毕竟从之前的开发模式变为了全新的声明式开发，但写了不到一周就感受到了 Compose 的优势，编写起来太快了，动画实现起来也太简单了，声明式编程也太方便了。。。。
其实 Compose Desktop 出现的也很早，Jetpack Compose 出来没多久它也就出来了，有很多同行在 Compose Desktop 出来第一个 alpha 版本的时候就开始研究，不过由于我是做安卓开发的，日常工作也不会涉及到桌面开发，况且 Compose Desktop 是 Jetbrains 开发的，并不 Google 开发的，毕竟是模仿 Jetpack Compose 的，未来两边的 API 都有可能对应不上，所以也就一直没有关注。
但是到后来转折点来了，公众号：《Android 开发者》在 2022 年 11 月 30 日早上发了一篇文章，名为：“Jetpack 更新一览 | 2022 Android 开发者峰会”，这篇文章的前半部分没有什么新鲜感，因为这些库我也一直在用，也经常关注着新版本和新功能，但看到文章最后的时候，里面有一段话是这么写的：
我们一直在尝试使 Jetbrains 的 Kotlin 多平台移动版支持跨平台共享代码。我们针对 Android 和 iOS 应用推出了实验性的 Collection 预览版和 DataStore 库。期待您的反馈！您可以查看相关博文，了解更多内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3915509ab9965c36cc62954acdffc95c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04d697efcbee64b0e7e2609be586d25b/" rel="bookmark">
			【Python--数据结构分析】海伦一直使用在线交友网站寻找适合的交友对象，为了方便分析，她将交友数据存放在datingTestSet.csv文件中。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import numpy as np import pandas as pd from pandas import Series,DataFrame #1.创建50*7的DataFrame对象，数据为[10,99]之间的随机整数， #列索引标签为字符a-g，将DataFrame对象保存到CSV文件中. data=np.random.randint(10,100,size=(50,7)) a=DataFrame(data,columns=['a','b','c','d','e','f','g']) print(a) a.to_csv('out.csv',mode='w',header=True,index=True) #2.海伦一直使用在线交友网站寻找适合的交友对象，为了方便分析，她将交友数据存放在datingTestSet.csv文件中 #(1)从文件中读取有效数据保存到DataFrame对象中，跳过所有文字解释行. #(2)列索引标签设为['flymiles','videogame','icecream','type']. a=pd.read_csv('e:\\data\\datingTestSet.csv',header=None,names=['flymiles','videogame','icecream','type'],skiprows=2) print(a) #(3)显示读取的前5条数据. print(a[:5]) #(4)显示所有type为largeDoses的数据. print(a.loc[a['type']=='largeDoses',:]) 1.创建50*7的DataFrame对象，数据为[10,99]之间的随机整数，列索引标签为字符a-g，将DataFrame对象保存到CSV文件中.【提示】使用NumPy的随机生成函数randint()生成数据。
2.海伦一直使用在线交友网站寻找适合的交友对象，为了方便分析，她将交友数据存放在datingTestSet.csv文件中。
(1)从文件中读取有效数据保存到DataFrame对象中，跳过所有文字解释行.
(2)列索引标签设为['flymiles','videogame','icecream','type'].
(3)显示读取的前5条数据.
(4)显示所有type为largeDoses的数据.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a03d892a19bb377d2c4ea7c4f07a29/" rel="bookmark">
			线索二叉树构建和遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线索二叉树 文章目录 线索二叉树引出线索解决方案(以中序线索树为例)引论:策略：问题1：♥ 对策 线索二叉树的节点类型定义线索化二叉树♥ 线索化算法♥ 建立中序线索二叉树的算法♥ 算法实现 遍历线索化二叉树引言:♥ 遍历思路(中序遍历举例)：♥ 实操遍历:♥ 实操框架♥ 代码实操 引出线索 什么是线索呢?
我们想把上面的左图的二叉树转换成右图的二叉树,就需要构造链式二叉树了,但是我们会发现,我们的链节点每个节点会有很多空指针, 我们能浪费这些空间吗? 这些空间还能被我们利用吗?
我们的任务就是构造二叉树,然后去遍历它,我们采用的是递归的方法构造,遍历的时候也是采取递归的算法遍历,这样很容易理解,但是同时我们也会发现–递归有的时候会拖慢进程,明明我这个节点在此处有空余指针可以存储下一个节点的信息,为什么不能利用起来呢? 这就引出了我们的下面的线索二叉树.
解决方案(以中序线索树为例) 引论: &gt;
我们知道遍历操作是非常常用的操作, 而在遍历操作中,我们接触过递归算法,非递归算法,很麻烦,操作很多的进行逐层遍历。此时我们就发现了空指针的浪费现象，我们能不能利用空闲的指针，去表示某种遍历的顺序。当我们给节点赋予某种遍历的特性，我们在遍历的时候就会非常方便了。我们就不用等递归返回到上一层，直接指向上一层要访问的节点即可。大大减轻了程序运行的复杂程度。
策略： •用空指针域按遍历顺序指向节点的前驱或后继。
首先我们看到的是每个链式节点都有左右指针，但是左右指针有的有孩子，有的没有孩子，所以我们就需要给节点的每个指针域进行标志，然后再赋予相应的指针。对于如何串联起来这颗二叉树呢？当然需要头指针了，我们来一个空的头指针进行标识，然后串联第一个遍历的节点和最后一个访问的节点。
每个节点，如果其左指针为空，则指向其前一个节点，其前一个节点的后继指针如果为空，则指向遍历的其后一个节点。
问题1： • 我们上面的思路和构图都有了， 下面我们开始构造了，但是如果去区别节点的指针指向是孩子，还是作为线索呢？
♥ 对策 我们可以对节点的数据结构进行重新构造,我们可以通过遍历的方式,来确定节点的左右指针是否为空。在遍历的过程中，就可以对其进行对应的赋值构造。
线索二叉树的节点类型定义 typedef struct node { ElemType data;	//定义数据域 int ltag,rtag;	//定义左右孩子的标志位,1为线索,0为有孩子 struct node *lchild;	//左指针 struct node *rchild;	//右指针 }TBTNode; 线索化二叉树 所谓线索化二叉树, 就是要通过遍历,将原来需要递归遍历的二叉树,变成能够利用指针快捷访问节点的过程.
我们上面已经构造了线索二叉树的节点,接下来,就是通过按照递归遍历(中序遍历为例)的方式,遍历一遍二叉树,这样我们就知道每个节点的对应信息是多少了,从而进行构建线索二叉树.
♥ 线索化算法 ​ ▪ 遍历二叉树,在遍历的过程中,检查当前节点的左、右指针域是否为空。如果为空，将它们改为指向前驱节点或后继节点的线索。
​ ▪ 创建一个头结点，并建立头节点与二叉树的根节点的线索；最后，建立最后一个节点与头结点之间的线索。
♥ 建立中序线索二叉树的算法 ​ ▪ CreaThread(b)算法: 是将以二叉链存储的二叉树b进行中序线索化,并返回线索化后头结点的指针root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00a03d892a19bb377d2c4ea7c4f07a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2290b5d7f96b64e6f8d02c4c04a0e551/" rel="bookmark">
			C语言实现——简版扫雷（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常分享：不管发生什么事，也不要憎恨这个时代！没被人表扬也无所谓，要有时刻保持微笑的坚强…只要向前走，肯定会有很多快乐的事，不断发生！ ————贝鲁梅尔
简版扫雷 前言一、扫雷分步讲解1.菜单和游戏框架的实现2.游戏的实现2.1棋盘初始化2.2打印棋盘2.3放置雷2.4排雷2.5雷的数量显示 二、两个拓展1.自动排空2.标记雷数 三、代码实现 前言 扫雷是大家小时候玩过的游戏吧，那么，当你学了二维数组，循环语句，判断语句之后，有没有想过自己敲代码来实现一下这个游戏呢？下面给大家介绍一下基本思路
扫雷，首先要有棋盘，有了棋盘肯定不要忘记初始化啊，初始化完成之后就是打印棋盘，然后在设置雷区，雷区要随即设置，这就又用到了前面用到过的rand函数，然后在把棋盘打印在屏幕上，最后在搞一个玩家输入，通过输入坐标来表示玩家想走的地方，最后就是判断输赢。怎么样，大概思路是不是很简单？看完这篇文章之后，自己来尝试一下吧！！
一、扫雷分步讲解 1.菜单和游戏框架的实现 玩游戏，肯定要有菜单吧，这样玩家才能开始或结束游戏，这个简单，直接上代码。
void menu() { printf("******************************\n"); printf("******1.play 0.exit*******\n"); printf("******************************\n"); printf("选择&gt;"); } 游戏要能循环玩，当玩家输入结束指令的时候才能结束，这个时候又用到了我们的老朋友do-while循环和stinch语句，这个循环和switch可以实现我们想要的游戏开始和游戏结束，所以这个循环和switch你掌握了吗？
代码实现：
void test() { int input = 0; do { menu(); scanf("%d", &amp;input); switch (input) { case 1: game(); break; case 0: break; default: printf("选择错误\n"); } } while (input != 0); } 这样，游戏大的框架就可以实现了。
2.游戏的实现 2.1棋盘初始化 在这里，我用了个game函数，从这个函数进入游戏，一定要学会用函数，这样可以使代码看着更加简洁，哪里有错误，直接去看对应的函数就行了。后面每个模块我都是使用的函数。
选择1进入game之后，我们要先创建两个二维数组，一个数组用来回显给玩家，一个数组用来存雷，不回显给玩家，为什么要用两个数组呢？其实不难想，我们肯定要让数组打印在屏幕上，只是一个数组，雷的位置不就会直接显示在屏幕上了吗？，数组不是覆盖，不可能说我把1覆盖在2上吧，所以在这里需要用两个数组。
注：在这里我们用的是宏，为了方便扩大棋盘，或者雷的数量，
#define ROW 9 #define COL 9 #define ROWS 11 #define COLS 11 这里为什么要用四个宏呢？因为玩家可不知道下标的概念，并且在扫雷的过程中，你要下的地方，要检测周围的地方是否有雷，如果你要下的地方是第一个位置呢？那么在检测周围的时候，是不是会造成数组的越界访问，所以要用4个宏，防止越界访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2290b5d7f96b64e6f8d02c4c04a0e551/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3469546340490160e998dbe47dc62cca/" rel="bookmark">
			C语言实现——三子棋（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一句很喜欢的话： 趁年轻，我偏要勉强。
三子棋 一 三子棋的基本思路二 三子棋分步讲解1.建立菜单2.设置循环框架3.打印棋盘 4.玩家移动5.电脑移动6.判断棋的情况 三 代码实现 当你学了二维数组，循环语句，判断语句后，就可以自己尝试做个简单的小游戏了，发挥自己的想象空间，大胆去敲代码，去实现你的想法
一 三子棋的基本思路 1.建立菜单，玩家可以选择玩游戏，或者退出游戏
2.设计循环玩游戏的基本框架，输入指令能退出游戏或开始游戏
3.打印棋盘
4.玩家移动
5.电脑移动
6.判断棋的情况（胜，负，平局）
二 三子棋分步讲解 1.建立菜单 建立菜单，我们可以自己定义一个函数，每次玩游戏都可以调用这个函数，打印出菜单，
让玩家进行选择。
void menu() { printf("*****************************\n"); printf("******** 1. play ******\n"); printf("******** 0. eixt ******\n"); printf("*****************************\n"); } 2.设置循环框架 想要重复玩游戏，肯定得用do—while循环，输入指定命令能够直接结束循环，输入开始命令也可以开始游戏，输入的不是菜单上的数字的话，也可以重新选择，在这里，我又用了个函数，这个函数是进入游戏的函数game()，下面会给大家讲。
void test() { srand((unsigned int)time(NULL));//这个代码为后面的电脑移动做铺垫。 int input = 0; do { menu(); printf("请选择:&gt;"); scanf("%d", &amp;input); switch (input) { case 1: game(); break; case 0: printf("退出游戏\n"); break; default: printf("选择错误\n"); break; } } while (input); } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3469546340490160e998dbe47dc62cca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b658123553d3fbf5c628d287488ef0e/" rel="bookmark">
			springboot thymeleaf遍历List集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： springboot项目,后端从数据库获取到数据集合返回前端页面，在页面中对数据进行遍历显示
代码实现： springboot一般集成thymeleaf模板引擎对集合数据进行展示渲染
导入springboot集成thymeleaf的两个依赖（这里用的是springboot父版本）
&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt; &lt;/dependency&gt; 页面编写
相关代码
&lt;!DOCTYPE html&gt; &lt;html lang="en" xmlns:th="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;遍历集合数据&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table align="center" border="1px" cellspacing="0" cellpadding="10px"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;部门id&lt;/th&gt; &lt;th&gt;部门名称&lt;/th&gt; &lt;th&gt;数据库&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each="dept,stat:${deptlist}"&gt; &lt;td th:text="${stat.count}"&gt;&lt;/td&gt; &lt;td th:text="${dept.deptno}"&gt;&lt;/td&gt; &lt;td th:text="${dept.dname}"&gt;&lt;/td&gt; &lt;td th:text="${dept.db_source}"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 效果图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c1dc5db66243c511a1ecb99d3fda47/" rel="bookmark">
			matlab 2022更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab 2022b
dictionary 对象 将唯一键映射到值以便快速查找
» 深度学习工具箱： 直接导入 PyTorch 模型；将模型导出到 TensorFlow
» Simulink: 将库浏览器停靠在模型中
MATLAB
.NET 引擎 API：从 .NET 应用程序调用 MATLAB
编译工具：创建和运行软件编译任务
App 性能：启动速度更快，图形交互的响应更快
Fuzzy Logic Toolbox - 使用更新后的模糊逻辑设计器以交互方式设计、分析和仿真模糊推理系统 (FIS)，包括二型系统
Computer Vision Toolbox
使用异常检测和分类方法自动化任务
代码生成、GPU 和第三方支持
OpenCV 接口：将 OpenCV 4.5.0 版项目与 MATLAB 集成
使用MATLAB Coder生成 C 和 C++ 代码：支持函数
为NVIDIA GPU Coder生成CUDA代码：支持函数
https://ww2.mathworks.cn/help/vision/release-notes.html
Curve Fitting Toolbox
Simulink：将曲线拟合器结果导出到 Simulink Lookup Table 模块
Instrument Control Toolbox
NI 向量信号收发机：为空口无线测试配置生成器并获取 IQ 数据，以及设计验证工作流
Statistics and Machine Learning Toolbox
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2c1dc5db66243c511a1ecb99d3fda47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebba1ead69e8811e8f2a73828855e1de/" rel="bookmark">
			MyBatis小认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ORM
ORM（Object/Relational Mapping），即对象关系映射，它完成面向对象的编程语言到关系数据库的映射。ORM 工具的唯一作用是：把持久化对象的保存、修改、删除等操作，转换成对数据库的操作。
ORM 基本映射关系：
（1）数据表映射类
（2）数据表的行映射对象（实例）
（3）数据表的列（字段）映射对象的属性
MyBatis 本是 apache 的一个开源项目 iBatis , 2010年这个项目由 apache software foundation 迁移到了 google code，并且改名为 MyBatis 。
MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及对结果集的检索封装。MyBatis 可以对配置和原生 Map 使用简单的 XML 或注解，将接口和 Java 的 POJO(Plain Old Java Objects,普通的 Java 对象)映射成数据库中的记录。
MyBatis 的主要思想是将程序中的大量 SQL 语句抽取出来，配置在配置文件中，以实现 SQL 的灵活配置。
MyBatis 并不完全是一种 ORM 框架，它的设计思想和 ORM 相似，只是它允许直接编写 SQL 语句，使得数据库访问更加灵活。因此，准确地说，MyBatis 提供了一种“半自动化”的 ORM 实现，是一种 "SQL Mapping" 框架。
2.MyBatis功能架构
API接口层：提供给外部使用的接口 API，开发人员通过这些本地 API 来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。
数据处理层：负责具体的 SQL 查找、SQL 解析、SQL 执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebba1ead69e8811e8f2a73828855e1de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb1d6f1f1b92c08f5d0395651ae6744/" rel="bookmark">
			Get和Post的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Http请求用得最多的两个，简单对比：
GET：在请求的URL地址后以?的形式带上交给服务器的数据，多个数据之间以&amp;进行分隔， 但数据容量通常不能超过2K，比如:http://xxx?username=…&amp;pawd=…这种就是GETPOST: 这个则可以在请求的实体内容中向服务器发送数据，传输没有数量限制提示：这两个玩意都是发送数据的，只是发送机制不一样，不要相信网上说的 "GET获得服务器数据，POST向服务器发送数据"!!另外GET安全性非常低，Post安全性较高， 但是执行效率却比Post方法好，一般查询的时候我们用GET，数据增删改的时候用POST！！ 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/198/">«</a>
	<span class="pagination__item pagination__item--current">199/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/200/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>