<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff9fbca449f1f6405a32f8e444406f31/" rel="bookmark">
			PTA - 数据库合集5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
10-234 按城市所属的省份统计省份下所有城市的人口
10-235 查询学生表所有学生记录（MSSQL）
10-236 查询学生表中部分信息(MSSQL)
10-237 查询学生表中的女生信息(MSSQL)
10-238 查询学生表中大于19岁的女生（MSSQL）
10-234 按城市所属的省份统计省份下所有城市的人口 分数 5
全屏浏览题目
切换布局
作者 admin
单位 杭州百腾教育科技有限公司
浙江省：杭州，宁波，温州
江苏省：苏州，南京，无锡
请写sql统计出浙江省和江苏省所有人口
提示：请使用SELECT语句作答。
表结构: create table city ( name varchar(20), population int ); 表样例 city表：
namepopulation杭州100温州100宁波100苏州100南京100无锡200 输出样例: namepopulation浙江300江苏400 SELECT name,SUM(population) population FROM( SELECT (CASE WHEN name='杭州' THEN '浙江' WHEN name='温州' THEN '浙江' WHEN name='宁波' THEN '浙江' WHEN name='苏州' THEN '江苏' WHEN name='南京' THEN '江苏' WHEN name='无锡' THEN '江苏' END) name,SUM(population) population FROM city GROUP BY name) a GROUP BY name 10-235 查询学生表所有学生记录（MSSQL） 分数 5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff9fbca449f1f6405a32f8e444406f31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/532571c3ee7a281af514d8c31183f6db/" rel="bookmark">
			7-2 一元多项式的乘法与加法运算（20分）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计函数分别求两个一元多项式的乘积与和。
输入格式: 输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。
输出格式: 输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。
输入样例: 4 3 4 -5 2 6 1 -2 0 3 5 20 -7 4 3 1 输出样例: 15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1 5 20 -4 4 -5 2 9 1 -2 0 使用数组表示多项式，P1[et] = ct; et是指数，ct是系数。
数组S[SIZE]计算两个多项式的和，相同的系数相加，不相同的系数另加。
数组M[SIZE*2]计算两个多项式其系数不为零的积，下标表示相乘后指数的相加。
#include&lt;bits/stdc++.h&gt; using namespace std; #define SIZE 2005 int main() { int n,m,ct,et,P1[SIZE]={},P2[SIZE]={},S[SIZE]={},M[SIZE*2]={}; bool flag = 0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/532571c3ee7a281af514d8c31183f6db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9852d4ef8582ca2212843092e3bba51/" rel="bookmark">
			unreal-c&#43;&#43;教程-第十一章:Unlua-SpawnActor并实现动态绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpawnActor并实现动态绑定 1. 背景介绍 腾讯的产品，牛逼是牛逼了，就是tutorials 有点一言难尽的意思，哎，慢慢吃吧，总得要有种文本脚本来写逻辑，蓝图不是给程序用的，这点大家还是要缕清一下.... 一般两个技术栈，腾讯用lua，网易用python，目前开源出来的是腾讯的Unlua，至于国外的，也有一些，但是...你都来csdn找资源了，我估计你也不咋 关注，那还是用腾讯的，至少有比较成熟的测试，bug会少很多，我会在后面对立面的一些核心功能的源码做一些解析 2. 如何调用SpawnActor Unlua的核心设计思路是什么呢: 是提供给蓝图的一个文本绑定的工具，也就是说，我们虽然是在写lua，但本质上是在写蓝图 那么，在建立这一条的共识上，我们想要利用lua去SpawnActor，则本质上就是去实例蓝图 2.1 SpawnActor的API 这里的xclass是SpawnActor的第一个参数，指定要生成的class
可以通过UE.UClass.Load()加载
注意我们获得引用的格式一般是：
Blueprint'/Game/UnLuaBP/Cube.Cube' 在lua中要加一个_C的后缀，从而去确定它是一个Class类型
后面的
表示的是它绑定的lua脚本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57302daba6678ce8d08fd9005ecb9b31/" rel="bookmark">
			MyBatis学习：动态SQL mapper.XML配置文件中＜sql＞标签和＜include＞标签的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、本篇博文的背景和目的 我本人正在学习MyBatis框架，在原先了解并且懵懵懂懂使用的基础上，开始系统正式的学习。阐述了MVC架构模式和三层架构，回顾了JDBC连接数据库，建立了使用MyBatis和MySQL的Maven项目，解释了STDOUT_LOGGING日志和手动提交事务，记录了MyBatis中#占位符的使用方法，回顾了MyBatis执行SQL语句的过程和使用到的一些重要类和接口，记录了将固定化的代码整合到一个工具类MyBatisUtil中，以减少代码量。记录了dao层接口的实现以及为什么要实现它。记录了MyBatis动态代理和使用动态代理的要求以及使用了动态代理生成的实现类。记录了MyBatis框架下传参的五种方法，占位符#和$，如何自定义别名，resultType属性的使用方法，如何处理数据库中列名和JAVA对象属性名不一致的情况，如何组装传递模糊查询的条件（一共有两种方式），动态SQL中&lt;if&gt;标签，&lt;where&gt;标签的使用。本篇博文记录&lt;sql&gt;标签的使用。
2、我的上一篇博文 我上一篇博文记录的是mapper.xml文件中&lt;foreach&gt;标签的使用，感兴趣的读者可以移步查阅，链接如下所示：
MyBatis学习：动态SQL中＜foreach＞标签的使用_你是我的日月星河的博客-CSDN博客https://blog.csdn.net/weixin_46281472/article/details/127176953
3、&lt;sql&gt;标签解决的问题和使用它的语法 sql标签表示一段sql代码， 可以是表名，几个字段，或者是 where条件等；
其实就是代码复用的一种方案。
使用方法（语法）：
1）首先就是 在 mapper文件中定义 sql代码片段， &lt;sql id=" 唯一的一个字符串 "&gt; 部分SQL语句 &lt;/sql&gt;
2）在其他的位置使用标签 &lt;include id=" 唯一的一个字符串"/&gt; 引用某一个代码片段 ，其实是
MyBatis将这个代码片段粘贴了过来；
或者应该说：&lt;sql&gt;标签是和&lt;include&gt;标签是必须结合一起使用的。
在一个mapper文件中，代码片段是可以有许多个的；
按照规范：&lt;sql&gt;&lt;/sql&gt;标签都放在mapper.xml文件的前面。
4、使用&lt;sql&gt;标签和&lt;include&gt;标签的代码（Maven项目） dao层方法代码：
//测试使用&lt;sql&gt;标签 List&lt;Student&gt; selectAll(); mapper.XML文件代码：
&lt;!-- 定义一个代码片段--&gt; &lt;sql id="selectStudent"&gt; select * from student &lt;/sql&gt; &lt;!--测试使用 sql标签和include标签--&gt; &lt;select id="selectAll" resultType="com.dcy.domain.Student"&gt; &lt;include refid="selectStudent"&gt;&lt;/include&gt; &lt;/select&gt; Main方法中测试代码如下：
package com.dcy; import com.dcy.dao.StudentDao; import com.dcy.domain.Student; import com.dcy.utils.MyBatisUtil; import org.apache.ibatis.session.SqlSession; import java.util.List; //测试使用&lt;sql&gt;标签和&lt;include&gt;标签 public class Starter05 { public static void main(String[] args) { SqlSession sqlSession = MyBatisUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57302daba6678ce8d08fd9005ecb9b31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c29632b9afe2df649b0ef66f50cac0f2/" rel="bookmark">
			[058量化交易]python获取新浪财经所有行情所有股票数据写入mongodb完整版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import random import pymongo import akshare as ak import json import time # 打开数据库 mongo_client = pymongo.MongoClient('mongodb://localhost:27017/') # 若没有Database 和Collection，则会自动创建 mongo_db = mongo_client['SinaData'] # mongo_client = pymongo.MongoClient('mongodb://localhost:27017/') # # 若没有Database 和Collection，则会自动创建 mongo_collection = mongo_db['SinaAllStockName'] def main(): try: stockNUm = 0 # 获取数据库下集合名称 result = mongo_db.list_collection_names(session=None) print(result) # 查询第一条 # print(mongo_collection.find_one()) # 查询所有数据 mydoc = mongo_collection.find() for x in mydoc: print('*************************') print(x) stockNUm = stockNUm + 1 if x['code'] in result: continue else: # 在量化投资研究中普遍采用后复权数据 新浪财经 stock_zh_a_daily_qfq_df = ak.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c29632b9afe2df649b0ef66f50cac0f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c90ed9182266705c1e4681a3c0635b/" rel="bookmark">
			pytroch冻结某些层的常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用迁移学习跑实验，遇到要将网络的部分层的参数固定住这一问题，经过多次尝试找到了常用的几种方法。
案例介绍 有两个网络串联训练（model、model1），现在想固定住model的网络参数，网络训练过程中只更新model1的权重。
其中model为仅包含两个卷积层的网络，model1为仅包含一个全连接层的简单网络。
model和model1代码如下：
import torch import torch.nn as nn from torch import optim # 定义两个包含两个卷积层，一个全连接层的简单网络 class Net(nn.Module): def __init__(self): super().__init__() self.conv1 = nn.Conv2d(3, 16, 3, 1, padding=1, bias=False) self.conv2 = nn.Conv2d(16, 16, 3, 1, padding=1, bias=False) # self.FC = nn.Linear(16*10*10, 20, bias=False) def forward(self, x): x = self.conv1(x) x = self.conv2(x) # x = self.FC(x.view(x.size(0), -1)) return x class Net1(nn.Module): def __init__(self): super().__init__() self.FC = nn.Linear(16*10*10, 20, bias=False) def forward(self, x): x = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12c90ed9182266705c1e4681a3c0635b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/982cbeeb94e8c72f764238d9cfa94dc7/" rel="bookmark">
			华为悦盒EC6018V9E线刷linux教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近一直想弄个NSA，奈何囊中羞涩，网上看啥都挺贵的。于是就把目光锁定在了在家角落里那个电视机顶盒，想着这东西不错啊，功耗还低。说干就干，看了一下盒子型号，华为悦盒ec6108v9e，心想着这盒子网上教程应该挺多吧，应该是轻轻松那种，但是翻遍了全网也没找到这个盒子的刷linux教程。
没办法，只能从芯片下手了，查了一下资料，这个盒子比较特殊，用的不是海思的芯片，用的是瑞芯微的RK3228芯片。于是查了一下，网上还真有一个国外大神的帖子详细的介绍了如何给这个芯片刷linux，并且竟然可以卡刷（对于我这样的菜鸟而言这实在是太令人感动了有木有），可惜不管试了多少次，换了几个刷机工具，都没有办法从U盘启动,这个盒子还没有还原按钮！本来都想放弃了，发现抽屉里面竟然有一根公对公USB线，那就试试线刷吧。还真刷成了。
一 、前期准备： windows系统（非必要）
ubuntu14系统 rkdeveloptool
loader文件
镜像文件
DriverAssitant驱动
AndroidTool_Release软件
（我是windows系统安装的ubuntu虚拟机，使用ubuntu14系统是因为用高版本的系统的时候编译rkdeveloptool总报错，直接用14方便。AndroidTool_Release我是用来切换MaskRom模式，本人敲命令比较渣，AndroidTool_Release可视化软件方便点（心理作用），其实用rkdeveloptool也可以切换，AndroidTool_Release完全可以不用）
打包好的资源链接：https://download.csdn.net/download/wp2341/86734938
二、 操作步骤： 1、安装驱动，解压缩DriverAssitant_v4.5驱动，将驱动安装好，AndroidTool_Release解压缩备用（如果不是Windows+虚拟机而直接是ubuntu系统的话可以跳过这一步）
2、打开linux系统，安装cmake。把rkdeveloptool复制到主目录中解压，进入到解压的目录依次执行：
sudo apt-get install libudev-dev libusb-1.0-0-dev dh-autoreconf autoreconf -i ./configure make make install 五行命令，不出错误的话系统会安装好rkdeveloptool工具，如果报错了的话请自行百度（本人用ubuntu14一遍过，不知道会有啥错误）
3、拆机：把前面两个垫片里面的螺丝拆下来，然后把壳子撬开，里面都是卡扣卡住的，大力出奇迹就好。
3、本盒子没有预装微动还原开关，但是预留了位置，如图所示将两个触点短接后将USB线插入靠近电源插口的USB接口和电脑USB接口，不出问题的话电脑会提示接入新硬件。linux可以使用lsusb命令查看一下新接入的硬件。（如果没有反应的话，八成是loader已经坏掉了，进不了loader模式了，可以从板子正面找到EMMCCLK触点，和GND短接可以直接进MaskRom模式）
4、打开AndroidTool_Release软件，点击高级功能，点进入MaskRom然后将设备连接至虚拟机。（如果软件显示发现MaskRom设备的话这一步就不需要了，如果是linux系统的话执行sudo rkdeveloptool rd 3 命令，报错忽略）
5、将镜像和loder复制到虚拟机上执行：
sudo rkdeveloptool db loader.bin sudo rkdeveloptool wl 0x0 image.img 两行命令，等待烧录完成重启盒子就可以了。
至此，EC6018V9E线刷linux结束，可以安装想要的软件啦（盒子系统不太稳定，动不动就卡死，喜欢折腾的可以多折腾几次完善系统，或者多在论坛上找几个镜像刷进去试试） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aaf94767e614d17c8e9caf4954e6814/" rel="bookmark">
			基于AlexNet的对抗样本攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景介绍
二、代码实现
1.代码的基本结构
第一部分：数据集的导入
第二部分：模型与优化器的选定，各类参数的设定
第三部分：cw攻击效果的训练
第四部分：攻击结果的可视化
2.cw攻击部分的代码呈现（注释很详细）
三、运行结果
1.先让模型针对mnist数据集进行识别训练，以得到相应权值
2.cw攻击效果展现
四、目前存在的问题
一、背景介绍 CW算法是一种基于优化的算法，它同时兼顾高攻击准确率和低对抗扰动的两个方面，达到真正意义上对抗样本的效果，即在模型分类出错的情况下，人眼不可查觉。
如果样本攻击成功就要满足两个条件：（1）对抗样本和对应的干净样本应该差距越小越好；（2）对抗样本应该使得模型分类错，且错的那一类的概率越高越好。由这两部分对应两个loss函数。
第一部分，rn对应着干净样本和对抗样本的差，把对抗样本映射到了tanh空间里面，使x可以在-inf到+inf做变换，有利于优化。也可以认为这种方法是一种平滑的梯度下降的方法，消除了在极端区域中陷入平缓而梯度消失的问题。
第二部分，公式中的Z(x)表示的是样本x通过模型未经过softmax的输出向量，对于干净的样本来说，这个向量的最大值对应的就是正确的类别（如果分类正确的话），现在我们将类别t（也就是我们最后想要攻击成的类别）所对应的逻辑值记为Z(An)t，将最大的值（对应类别不同于t）记为max{Z(An)i : i!=t }，如果通过优化使得max{Z(An)i : i!=t } - Z(An)t变小，攻击就离成功更近了。k是置信度，可以理解为，k越大，那么模型分错，且错成的那一类的概率越大。最后就是常数c,这是一个超参数，用来权衡两个loss之间的关系，在这个代码中通过二分查找来确定c值。
CW是一个基于优化的攻击，主要调节的参数是c和k。它的优点在于，可以调节置信度，生成的扰动小，可以破解很多的防御方法，缺点是很慢。
二、代码实现 1.代码的基本结构 第一部分：数据集的导入 1. 选定的mnist数据集，每次导入一种图片进行cw攻击
2. 图片大小 ：28x28 标签 ： 0~9
3. 初始图片信息为ndarry格式（28,28,3），经过各种操作（如转换为浮点型，resize高宽大小，transpose等），最终转换为可供模型读取的信息格式
第二部分：模型与优化器的选定，各类参数的设定 1. 我们使用的是alexnet模型和Adam优化器
2. 在进行攻击训练前，已经让alexnet模型针对mnist数据集进行识别的训练，得到了针对mnist数据集的权值
3. 各类参数的设定包括了最大迭代次数，学习率，二分查找最大迭代次数，c的初始值（c为超参数，可以简单理解为两个loss函数在最终loss值中所占比例），k值（置信度），均值，标准差等等
第三部分：cw攻击效果的训练 1. 最外层的循环为每次从数据集中导入一种图片，针对于每次导入的那张图片进行cw攻击
2. 紧接着的循环用于尝试不同的c值，通过二分法查找使得攻击效果最好的c值
3. 再内层的循环为针对一张图片的攻击效果的不断优化
（1）将当前噪声与原始样本叠加，形成攻击样本
（2）将攻击样本导入模型，得到梯度和结果
（3）根据模型检测的结果，计算两个loss函数值
loss1：用于挑选指定分类标签和剩下其他分类中概率最大者，计算两者之间的概率差
loss2：用于计算对抗样本和原始数据之间的距离
loss=c*loss1+loss2
（4）进行backward，并调用优化器进行优化。（每次循环前进行梯度清零操作）
第四部分：攻击结果的可视化 1. 设定了show函数，在每张图片完成cw攻击后，同时展示其原始样本，生成的对抗样本，及对应噪声。结果图已在后文展现。
2.cw攻击部分的代码呈现（注释很详细） import cv2 import torch import torchvision import numpy as np import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aaf94767e614d17c8e9caf4954e6814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/843ae275ca360801e304cec2fccd691b/" rel="bookmark">
			NNDL 实验五 前馈神经网络（2）自动梯度计算 &amp; 优化问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.3 自动梯度计算 虽然我们能够通过模块化的方式比较好地对神经网络进行组装，但是每个模块的梯度计算过程仍然十分繁琐且容易出错。在深度学习框架中，已经封装了自动梯度计算的功能，我们只需要聚焦模型架构，不再需要耗费精力进行计算梯度。
pytorch中的相应内容是什么？请简要介绍。
答：
不同于飞桨提供的paddle.nn.Layer类，在pytorch中是torch.nn.Module类，torch.nn是专门为神经网络设计的模块化接口，nn.Module是nn中十分重要的类。官方注释如下：
根据官方注释我们了解到Module类是所有神经网络模块的基类，Module可以以树形结构包含其他的Module。Module类中包含网络各层的定义及forward方法，下面介绍我们如何定义自已的网络：
需要继承nn.Module类，并实现forward方法；
一般把网络中具有可学习参数的层放在构造函数__init__()中；
不具有可学习参数的层(如ReLU)可在forward中使用nn.functional来代替；
只要在nn.Module的子类中定义了forward函数，利用Autograd自动实现反向求导。
4.3.1使用pytorch的预定义算子来重新实现二分类任务 import torch.nn as nn import torch.nn.functional as F import os import torch from abc import abstractmethod import math import numpy as np n_samples = 1000 X, y = make_moons(n_samples=n_samples, shuffle=True, noise=0.15) num_train = 640 num_dev = 160 num_test = 200 X_train, y_train = X[:num_train], y[:num_train] X_dev, y_dev = X[num_train:num_train + num_dev], y[num_train:num_train + num_dev] X_test, y_test = X[num_train + num_dev:], y[num_train + num_dev:] y_train = y_train.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/843ae275ca360801e304cec2fccd691b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d24eec60a17522917b840d8dcdc268/" rel="bookmark">
			Nacos 2.x.x: 初始设置；启动报错；或者出现No DataSource set，解决办法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nacos的初始设置，即解压后，目录如下：
先打开conf，打开 application.properties
把里面的这几行该取消注释的取消掉：
默认的连接用户名是nacos，密码也是nacos，报No DataSource set错误的，可以设置为root用户。
接下来新建数据库nacos_config， 全选复制nacos-mysql.sql（conf文件夹下的sql文件）的内容，新建查询运行。就会得到如下表：
到此就可以重新尝试连接，若没有问题，就可以用浏览器打开 localhost:8848/nacos
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed5d194eb054a1856e850a89e56dcf6/" rel="bookmark">
			C&#43;&#43;的数据类型——常量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.2 常量
2.2.2 数值常量
数值常量就是通常所说的常数。在C++中可以从字面形式区分数值类型。
1.整形常量（整数）的类型
通常有 int, short int, long int, unsigned int...通常整数的类型不同，它们值的范围也会所不同。
可见：
一个整形常量可以用3种不同的方式表示。
（1）十进制整数，在一个整常量后面加一个字面l或L（2）八进制整数，在常数的开头加一个数字0（3）十六进制整数，在常数的开头加一个数字0和一个英文字母X。
2.浮点数的表示方法
（1）十进制小数形式
如果在实数的数字之后加字母F或f，表示此数为单精度浮点数；如果加字母L或l，表示此数为长双精度数。
（2）指数形式（即浮点形式）
如3.14159可以表示为0.314159*10的一次方。
其一般形式为 数符 数字部分 指数部分 2.2.3 字符常量
1.普通的字符常量
用单撇号括起来的一个字符就是字符常量。如'a', '$', '&amp;'。1.字符常量只包含一个字符；2.字符常量区分大小写字母；3.撇号（'）是定界符，不属于字符常量的一部分。
2.转义字符常量
我们为了可以将电脑键盘上的“控制字符”在程序中表示，引入了一种特殊形式的字符常量，以
“ \ ” 开头的字符序列，叫做转义字符。
一些常见的转义字符及其含义：
同时转义字符在内存中占1个字符。 3.字符数据在内存中的储存形式及使用方法
字符数据是以ASCII码储存的
例子:
#include&lt;iostream&gt; using namespace std; int main() { int i,j; i='A'; j='B'; cout&lt;&lt;i&lt;&lt;'\t'&lt;&lt;j&lt;&lt;'\n'; return 0; } 运行结果：65 66
反之也是可以转化的，例子：
#include&lt;iostream&gt; using namespace std; int main() { char c1,c2; c1='a'; c2='b'; c1=c1-32; c2=c2-32; cout&lt;&lt;c1&lt;&lt;'\t'&lt;&lt;c2&lt;&lt;endl; return 0; } 运行结果：A B
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ed5d194eb054a1856e850a89e56dcf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/399423ff652ebb6a6701be7ec3202fc6/" rel="bookmark">
			Charles
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7128f5c48e6884e563ac266ecd0cf4c/" rel="bookmark">
			修复ijkplayer没有正确处理sps导致的MediaCodec解码失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		播放HLS时，部分TS分片的sps排列是：
0 0 0 1 9 240 0 0 0 1 103 。。。 0 0 0 1 104。。。
其对应的内容是：
0 0 0 1 9 240 ：表示AUD接着的 0 0 0 1 ：表示 start code接着的103 ：表示sps类型接着的就是sps的数据最后的0 0 0 1 104 ：104表示是pps数据接着的就是pps的数据 这里针对这种情况做了处理，提取出其中的sps数据给到MediaCodec，避免MediaCodec初始化失败。
需要这种视频链接的，我可以发出来，不过视频链接只有24小时有效。
issues如下：
android k0.8.4 某些手机播放视频有声音，无画面（即透明，非黑屏） #4177请教下Android播放视频只有声音没有画面？ #3544 ijkmedia/ijkplayer/android/pipeline/ffpipenode_android_mediacodec_vdec.c @@ -245,24 +245,23 @@ static int recreate_format_l(JNIEnv *env, IJKFF_Pipenode *node) SDL_AMediaFormat_setBuffer(opaque-&gt;input_aformat, "csd-0", convert_buffer, esds_size); free(convert_buffer); } else { //先只考虑h264的情况,H265这种情况我也没见过 if(opaque-&gt;avctx-&gt;codec_id == AV_CODEC_ID_H264 &amp;&amp; opaque-&gt;avctx-&gt;extradata_size &gt; 6){ //参考 https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7128f5c48e6884e563ac266ecd0cf4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ed1c7611ad50e4995dcf05cc2fbdb39/" rel="bookmark">
			Airtest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 airtest简介
2 airtestIDE
3 airtestIDE 辅助窗
4 airtestIDE 脚本录制
5 airtestIDE Poco辅助窗
6 总结
1 airtest简介 Ø Airtest 框架 Airtest 是一个基于python、跨平台的、 基于图像识别 的UI自动化测试框架，适用于游戏和App，支持平台有Windows、Android和iOS
Ø Poco 框架 Poco是一款 基于UI控件识别 的自动化测试框架，本质上也是python第三方库
Ø AirtestIDE AirtestIDE 是一款跨平台的 UI自动化测试编辑器 ，内置了Airtest和Poco的相关插件功能，能够使用它快速简单地编写 Airtest 和 Poco 代码
2 airtestIDE Airtest辅助窗：主要是用来生成airtest框架中的代码
Poco辅助窗：要是用来抓取元素信息的，并且可以生成Poco框架代码
Selenium Window：学习的过程，就还没用到是基于selenium语法的，在Selenium Window这个窗口中，可以对待测浏览器进行录制，自动生成基于selenium语法的自动化脚本。另外还提供了一些封装好的截图操作，比如airtest_touch等等
设备窗(右侧)：连接设备，如已连接则同步显示设备画面
脚本编辑窗(中上)：用来编写自动化代码
Log查看窗(中下)：代码不运行的时候用来显示Poco辅助窗选定元素后的所有信息；代码运行后显示程序运行时代码
3 airtestIDE 辅助窗 Touch:图片识别点击操作，点击‘touch’按钮，在手机屏幕上拖动选取点击的图片，在代码编辑窗会自动生成代码v – 点击位置，可以是一个 Template 图片实例，或是一个绝对坐标 (x, y)
Airtest封装的图像类
Swipe：在当前设备话画面上进行一次滑动操作/ v1 – 滑动的起点，可以是一个Template图片实例，或是绝对坐标 (x, y) v2 – 滑动的终点，可以是一个Template图片实例，或是绝对坐标 (x, y)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ed1c7611ad50e4995dcf05cc2fbdb39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a1ad510208dcd787ce22ec8003042c/" rel="bookmark">
			【秋招面试题】C&#43;&#43; 网络编程 面试题库（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、线程池的设计及作用
二、线程和进程的区别
三、C++ 设计模式
四、进程间的通讯方式
五、引用和指针的区别
六、构造函数和析构函数 七、深拷贝和浅拷贝
八、对多态的理解
九、数据结构有哪些
十、socket包安全
十一、new和malloc的区别
十二、epoll的 LT 和 ET 模式的理解
十三、TCP/UPD的区别
十四、三次握手和四次挥手
十五、socket的概念和特点
十六、gdb调试
十七、面向对象的理解
十八、虚函数的作用
十九、类和对象的关系 二十、IO复用，epoll和select的区别，opoll和selete的特点
二十一、客户端与服务器如何通信
二十二、堆和栈的区别
二十三、结构体和类的区别
二十四、STL中的vector如何实现
二十五、如何保证线程的安全
二十六、数组和链表的区别
二十七、boost库是否有了解
二十八、socket的工作模式，为什么选择socket
二十九、长连接和短连接
三十、socket中阻塞和非阻塞的区别
一、线程池的设计及作用 线程池的作用：
线程池是为了解决线程在程序中因频繁创建和销毁而消耗大量时间而存在的，即在程序开始正式任务之前，先创建出一些线程，这些线程在程序不会被销毁，而且程序在运行中也不会再去创建线程。这样在程序的运行期间就提高了效率。
线程池的设计思路：
先创建出一组线程，当有新任务进来时就从线程池中取出空闲线程处理任务，任务完成之后又重新放回去，当线程池中的所有线程都在任务时，只能等待有线程结束任务才能继续执行。
二、线程和进程的区别 根本区别：进程是操作系统资源分配的基本单位，而线程是CPU任务调度和执行的基本单位
在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）
内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。
包含关系：一个线程只能属于一个进程，但是一个进程可以拥有多个线程。多线程处理就是允许一个进程中在同一时刻执行多个任务。所以线程也被称为轻权进程或者轻量级进程。
三、C++ 设计模式 单例模式
概念：是指在内存中只会创建且仅创建一次对象的设计模式
优点： 1.保证一个类只有一个实例，并提供一个访问它的全局访问点，使得系统中只有唯一的一个对象实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例 2.由于在系统内存中只存在一个对象，因此可以节约系统资源、提高系统的性能。
缺点：
就是不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。
实现要点：
在类中，要构造一个实例，就必须调用类的构造函数，并且为了保证全局只有一个实例，
需防止在外部调用类的构造函数而构造实例，需要将构造函数的访问权限标记为private，
同时阻止拷贝创建对象时赋值拷贝对象，因此也将它们声明并权限标记为private；
另外，需要提供一个全局访问点，就需要在类中定义一个static函数，返回在类内部唯一构造的实例。
观察者模式
观察者模式定义了对象间的一对多依赖关系，让一个或多个观察者对象观察一个主题对象。当主题对象的状态发生变化时，系统能通知所有的依赖于此对象的观察者对象，从而使得观察者对象能够自动更新。
实现方式：
a） 角色抽象类（提供对观察者的添加，删除和通知功能）。
b） 角色具体类，实现a，维护一个c的集合（对角色抽象类的实现）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46a1ad510208dcd787ce22ec8003042c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f56d07d907906cd166066591648706/" rel="bookmark">
			为什么你学不会递归？谈谈我的经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天分享到计算机科学中一个基础又非常重要的概念 —— 递归。递归是计算机中特有的概念，你很难在现实世界中找到一个恰当的例子与之关联起来。因此，对于很多初学编程的人，一开始会很难理解。
那么，究竟什么是递归，我们为什么要使用递归？我们今天就围绕这两个问题展开。
学习路线图：
1. 什么是递归？ 递归（Recursion）是一种通过 “函数自己调用自己” 的方式，将问题重复地分解为同类子问题，并最终解决问题的编程技巧。
举个例子，要求一个数 nnn 的阶乘 n!=n∗(n−1)∗(n−2)∗…∗2∗1n! = n*(n-1)(n-2)…21n!=n∗(n−1)∗(n−2)∗…∗2∗1 ，有 2 种思考问题的思路：
递推（一般思维）： 我们从 111 开始，用 111 乘以 222 得到 2!2!2! 问题的解，用 333 乘以 2!2!2! 得到 3!3!3! 问题的解。依次类推，直到用 nnn 乘以 (n−1)!(n-1)!(n−1)! 得到原问题 n!n!n! 的解。这就是用递推解决问题，这是相对简单直接的思考方式；递归（计算机思维）： 我们把 n!n!n! 的问题拆分为一个 (n−1)!(n-1)!(n−1)! 的问题，如果我们知道 (n−1)!(n-1)!(n−1)! 的解，那么将它乘以 nnn 就可以得出 n!n!n! 的解。以此类推，我们将一个 (n−1)!(n-1)!(n−1)! 的问题拆分为同类型的规模更小的 (n−2)!(n-2)!(n−2)! 子问题，直到拆分到无法拆分，可以直接得出结果 1!1!1! 问题。此时，我们再沿着拆分问题的路径，反向地根据子问题的解求出原问题的解，最终得到原问题 n!n!n! 的结果。这就是用递归解决问题。 求 n!
从这个例子可以看出， 递归其实是在重复地做 2 件事：
1、自顶向下拆分问题： 从一个很难直接求出结果的、规模较大的原问题开始，逐渐向下拆分为规模较小的子问题（从 n!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56f56d07d907906cd166066591648706/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a34c95fb55176da029f210225c14aa9/" rel="bookmark">
			c&#43;&#43;线程池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.线程池用来干嘛 用户有任务需要执行，向任务队列中加入任务，线程池不断尝试从任务队列取出任务，执行任务。
2.代码 #ifndef PTHREAD_POOL_H #define PTHREAD_POOL_H #include &lt;queue&gt; #include &lt;pthread.h&gt; //线程池类 class pthreadPool { private: //任务 struct user_data { void *(*func)(void *); void *arg; }; //每个线程有一个work struct work { pthread_t pthread_id; bool is_working; user_data *user; pthreadPool *pool; }; public: //仅向用户提供的方法 pthreadPool(int max_pthread, int max_work); ~pthreadPool(); bool add_work(void *(*func)(void *), void *arg, int len); private: bool m_add_work(user_data *user); //线程运行函数不能有隐含this指针参数 static void *m_run(void *arg); void pthread_loop(work *my_work); private: int m_max_thread; int m_free_thread; int m_max_work; work *m_works; pthread_cond_t m_cond; pthread_mutex_t m_lock; //任务队列 std::queue&lt;user_data *&gt; m_queue; bool m_stop; }; #endif #include &lt;iostream&gt; #include &lt;string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a34c95fb55176da029f210225c14aa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59bddbbe5406636f6effc8c6ccb924ed/" rel="bookmark">
			Docker：有关centos镜像的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 无法更新软件源 问题描述：yum -y update 更新失败
解决办法：
将镜像从 mirror.centos.org 更改为 vault.centos.org
进入repos目录
cd /etc/yum.repos.d/ 修改内容 sed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/CentOS-* sed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' /etc/yum.repos.d/CentOS-* 生成缓存更新 yum makecache 执行更新 yum -y update clear命令不可用 dnf install ncurses -y 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd4b1968d14247bd30ca6e0f5b5a62fb/" rel="bookmark">
			抖音开放平台基础开发避坑指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 抖音小程序开发基础避坑 自定义组件路径，引用到具体的组件上 //相对路径引用到具体的组件上 "usingComponents": { "intro-box":"/component/test_title/test_title" } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b5b96e2d1a7227e2714141e252714f6/" rel="bookmark">
			（附源码）SSM学校旧书交易网站JAVA计算机毕业设计项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
3.1可行性分析
本文的设计的系统将会分别从经济的可行性，技术的可行性以及操作的可行性等方面进行全面的可行性的分析。
3.1.1经济可行性
本系统是学校旧书交易网站系统，面向的是电脑用户所以成本并不高，维护和调试只需个别成员参与，所以人力投入也很少。虽说人力和资金的投入不是很多，但是面临的增益是十分的可观尤其是从长远角度来看，所谓知识是无价的，而保管者需要面临很多困扰，而学校旧书交易网站系统很大程度上解决了这一问题，未来，需要投入到资源保管的人十分的少，不需要很多的人就够了，人少却又能保证信息的安全，那么对人员的资金就可以减少不少，并且工作人员并不会很辛苦。
使用的数据库是MySQL数据库，对于小型网站来讲是很低的成本，大大减少了空间，而原有的空间则可以用来处理别的事物。
3.1.2技术可行性
在技术方面也是完全可以做到的，目前所拥有的技术足以开发出一个完整的学校旧书交易网站系统。因为面向的对象较为单一，所以所需要的技术并不复杂，皆是学校内所学到的知识，而且所需要的工具也不是很复杂。使用Dreamweaver作为开发的平台，使用ssm编写页面和apache连接数据库，使用最简单的MySQL数据库，维护起来也是十分的容易，而本系统是基于B/S的结构创建的，也是比较简单明了的。所以从技术方面来讲也是可以实行的。
3.1.3操作可行性
本系统的开发，运用的是基础技术，面向的是单一群体，所以不会造成信息拥堵和崩溃的局面，所以运行时是可以较快的执行用户的命令的。而存在于页面的数据都会以表单的形式传送到数据库，所以不会造成混乱。
就目前而言，计算机普及的时代，学习维护和运用系统并不会很困难，所以人员方面是可以实行的，而且系统可以运用在不同的计算机上，所以这里也是可以运行的。
3.1.4 时间可行性
就时间而言，因为项目并不是很庞大，所以是可以在时间范围内完成的。但是需要好好把握时间的安排，因为本次毕业设计是单人的，所以需要自我监督和敦促，不能见异思迁，一定要先有一个明确的时间规划表。才能在有限的时间内完成本系统
3.1.5 法律可行性
本系统所用的技术和资源均是合法的，引用的部分都有注明，参考文献等也是合乎规定的，是属于个人的创作成果，没有涉及到危害他人的知识产权的行为
3.2需求分析
针对现存的问题和需要，通过功能需求的分析，特建立了数字化、信息化的学校旧书交易网站系统。
本系统主要包含了用户管理、商家管理、旧书类别管理、旧书信息管理、旧书购买管理、系统管理等多个功能。不同的权限对应相应的功能模块的需求，管理员权限的级别是最高的，所以所对应的需求是最多的。
3.3业务流程分析
总体业务流程：以管理员的身份在登录页面输入账号和密码，经过数据库身份验证，验证成功后登录系统主页，可以使用系统，管理系统等功能操作 。
3.4数据流程分析
数据流图的简称为DFD，是通过使用图形的方法对系统所具备的逻辑功能进行阐述，描述系统数据的流向和逻辑变换。由于该方法能将难以阐述的问题进行表述，因此被开发者广泛应用，是当前应用范围较为广泛的结构化系统分析方法。
零层数据流程是流程中最抽象的一层，它包括了登录管理、管理员功能管理和检索维护管理等功能模块，在登录模块使用到的数据存储有管理员账户信息文档、管理员信息文档，管理员功能管理模块需要的存储是管理员添加信息文档、查询信息文档、删除信息文档，检索维护是通过以上这些文档信息通过关键词进行搜索。
系统的1层数据流图如下图所示。
图3-1系统数据流图（1层）
2层为管理员操作后台数据流图，管理员可以分别通过添加、修改和删除来对系统管理员进行管理，如下图所示：
图3-2系统数据流图（2层）
第4章 系统设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b5b96e2d1a7227e2714141e252714f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2c02109d047f09fe7cd7ba0bccfdd57/" rel="bookmark">
			CSS媒体查询（含案例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是媒体查询
媒体查询基础
媒体类型
媒体特征规则
min-width与max-width（宽高）
朝向
复杂的媒体查询
与
或
非
实例
响应式导航栏
创建弹性布局
什么是媒体查询 随着移动设备的快速普及，用户不再只是通过传统的电脑系来浏览 Web 内容，越来越多的用户使用各种尺寸的手机、电脑或者其它设备来浏览 Web 内容，为了确保应用在不同设备中呈现美观的界面样式，让用户拥有一个良好的体验，这就需要用到媒体查询。
媒体查询是 CSS 最重要的功能之一，所谓媒体查询指的就是根据不同的媒体类型（设备类型）和条件来区分各种设备（例如：电脑、手机、平板电脑等），并为它们分别定制 CSS 样式。媒体查询能让 CSS 可以更精确的作用于不同的设备或同一设备的不同条件，让所有用户在不同的设备中都能得到很好的用户体验。
媒体查询基础 最简单的媒体查询语法如下：
@media media-type and (media-feature-rule) { /* CSS 样式 */ } 它由以下部分组成：
一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕）；一个媒体表达式，是一个被包含的 CSS 生效所需的规则或者测试；一组 CSS 规则，会在测试通过且媒体类型正确的时候应用。 媒体类型 你可以指定的媒体类型为：
all 所有设备print 打印机等设备screen 彩色屏幕（手机，电脑）speech 有声读物设备 下面的媒体查询将会在所有页面把 body 设定为只有 12pt 大小。
@media all { body { font-size: 12pt; } } 媒体特征规则 媒体特征规则指的是根据不同屏幕大小适配不同的css，比如在屏幕宽度大于或者小于某个大小或者恰好等于某个大小的时候应用我们规定的css样式。
一般来说，我们可以使用min-width、max-width和width媒体特征。通过设置这些特征，实现响应式布局，能够响应不同屏幕大小，给用户一个良好的使用体验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2c02109d047f09fe7cd7ba0bccfdd57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6ecd902ff982adce026718911391241/" rel="bookmark">
			Knife4j框架中的注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Knife4j是一款基于Swagger 2的在线API文档框架。
在Spring Boot中，使用此框架时，需要：
添加依赖
在配置文件（application.properties）中开启增强模式
编写配置类（代码相对固定，建议CV）
关于依赖的代码：
&lt;!-- Knife4j Spring Boot：在线API --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.9&lt;/version&gt; &lt;/dependency&gt; 关于开启增强模式，在application.properties中添加： # 开启Knife4j的增强模式 knife4j.enable=true 注意：以上代码适用于Spring Boot 2.6以下（不含2.6）版本！
关于Knife4j框架，还提供了一系列的注解，便于实现API文档的显示，包括：
@Api
@ApiOperation
@ApiOperationSupport
@ApiModelProperty
@ApiImplicitParam
@ApiImplicitParams
@ApiIgnore
@Api： 添加在控制器类上，配置其tags属性，用于指定模块名称，在指定的模块名称，可以使用数字编号作为名称的前缀，则多个管理模块将按照编号顺序来显示，例如：
@RestController @RequestMapping("/albums") @Api(tags = "03. 相册管理模块") public class AlbumController { @GetMapping("/test") public void test() {} } @ApiOperation： 添加在控制器类中处理请求的方法上，配置其value属性，用于指定业务接口名称，例如：
@ApiOperation("删除品牌") @PostMapping("/delete") public String delete(Long id) { } @ApiOperationSupport： 添加在控制器类中处理请求的方法上，配置其order属性，用于指定业务接口的排序编号，最终，同一个模块中的多个业务接口将按此编号升序排列，例如： @ApiOperation("删除品牌") @ApiOperationSupport(order = 200) @PostMapping("/delete") public String delete(Long id) { } @ApiModelProperty： 添加在POJO类的属性上，配置其value属性，用于指定请求参数的名称（说明），配置其required属性，用于指定“是否必须提交此请求参数”（仅用于显示，不具备检查功能），配置其example属性，用于指定“示例例”，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6ecd902ff982adce026718911391241/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba120118b817697297fceb3c8cd10cfc/" rel="bookmark">
			C&#43;&#43;3--构造函数、冒号语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、构造函数 1、为什么要有这个概念： 例如下面的代码，对于Table类，可以通过t.Set公有的方法给对象设置内容，但是如果每次创建对象都调用该方法设置信息，就会有点麻烦，那能否在对象创建时，就将信息设置进去？
而我们的需求是不通过对象去调用初始化对象的数据，我们希望当这个对象创建出来的时候，他就已经是具有一定的初始值的，
为解决完成对象的初始化问题，引出构造函数概念
class Table { public: void Set(); void Print(); private: int m_length; int m_width; int m_height; }; void Table::Set()//设置长宽高 { m_length = 120; m_width = 40; m_height = 80; } void Table::Print()//打印长宽高 { cout&lt;&lt;m_length&lt;&lt;" "&lt;&lt;m_width&lt;&lt;" "&lt;&lt;m_height&lt;&lt;endl; } void main() { Table t;//此代码一运行，对象t就已经被定义，但其属性没有确定，就存在一定问题 //t.Set(); t.Print();//没有运行Set，输出结果为随机值 } 运行结果：
2、构造函数 定义： 构造函数是一个特殊的成员函数，名字与类名相同，创建类类型对象时由编译器自动调用，保证每个数据成员都有一个合适的初始值，并且在对象的生命周期内只调用一次。
特性： 特殊的成员函数，函数名和类名相同，无返回类型，可以带参数（意味着可以重载）；
函数名与类名相同。
无返回值。
编译器自动调用对应的构造函数。
构造函数可以重载。
功能： 构造函数的功能是用来完成对象的初始化的，需要注意的一点是，虽然构造函数叫"构造"函数，但是构造函数并不是用来构造对象的，
特点： 在定义对象的时候，自动调用当前类的构造函数；
如果程序员没有定义构造函数，则类会提供一个默认的构造函数，给类中的数据成员分配空间（栈上的空间）。
遇到对象，要自动调用当前类的构造函数，调用构造函数的步骤：（基础，后续会扩充）
1、传参；
2、根据数据成员在类中的声明顺序开辟空间；
3、执行构造函数函数体；
使用示例： class Table { public: //如果程序员没有写，类会提供一个默认的构造函数，默认构造函数是无参数 Table(int l = 120,int w =40,int h= 80) //Table(int l,int w,int h)//会报错，要不改成无参，要不加值 { m_length = l; m_width = w; m_height = h; cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba120118b817697297fceb3c8cd10cfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4904aa122c9261316a98c007d15f12b/" rel="bookmark">
			拉普拉斯变形的原理解析和python代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 拉普拉斯变形是图形学处理mesh的常用方法，它假定mesh的顶点，在变化前后，顶点的拉普拉斯距离应该是一致的。
最常见的拉普拉斯矩阵的定义如下：
L = D − A = D ( I − D − 1 A ) L = D- A \\ =D(I - D^{-1}A) L=D−A=D(I−D−1A)
D是每个顶点的度，A是邻接矩阵。
假设有变形前的顶点为V，有L*V，将其拆解，可以发现就是求每个顶点 i i i的顶点位置减去相邻的顶点位置*(1/ d i d_i di​)。
L V i = V i − ∑ j ∈ N i 1 d i V j LV_i = V_i - \sum_{j\in N_i} \frac{1}{d_i}V_j LVi​=Vi​−j∈Ni​∑​di​1​Vj​
j是顶点i的邻接顶点索引。
因此，拉谱拉斯矩阵中保存了顶点的局部信息。顶点周围的关系通过这种方式记录下来。
另外，通常我们使用归一化的拉普拉斯矩阵，即 I − D − 1 A I - D^{-1}A I−D−1A，每一行之和为1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4904aa122c9261316a98c007d15f12b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9f5d2ad3dcd9d56c76ffa56b4c89d1a/" rel="bookmark">
			电脑版微信dat文件用什么软件打开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-4
一般来说，凡是说到微信电脑版的DAT文件，指的都是聊天过程中收发的图片，加密保存在电脑里。
这些文件正常情况下也只能在微信登录后，在微信里查看，因为微信加密的当然只有微信才能解密。
那有没有第三方工具可以解密它，让它不一定非要在微信里查看呢？
如果有的话，也就可以脱离微信而可以随意打开这些聊天图片了。
这样就有了本工具：《天才小网管DAT转JPG》
工具获取：
微信电脑版DAT图片格式转JPG格式工具（天才小网管DAT转JPG）-软件资源-天才小网管博客
以下介绍本工具用法
一、电脑微信文件夹存储位置
微信文件夹在电脑的储存位置一般在：C:\Users\CF\Documents\WeChat Files\微信号\FileStorage\File
打开文件夹步骤：
1、点击电脑版微信左下角“三杠”-“设置”
2、打开后点击【文件管理】，即可打开文件保存的位置，也可自行更改保存路径。
二、DAT文件所在位置
1、经过上一步后，电脑会打开一个文件夹，这个文件夹包含了这个微信号的所有产生的数据
2、双击【FileStorage】进去，可以看到一些文件夹，相关的解释在下图，主要看这几个就行，因为微信在2022年6月份更新后，有了新的存放位置，所以有分2022-06前后的说明
三、DAT文件批量转换为JPG
1、打开《天才小网管DAT转JPG》主程序
2，软件打开后，如果要转6月份后的文件，就在第一个格子选择到【MsgAttach】，然后再选择一个要转换的月份，然后再选择一个保存的文件夹，如下图：
3、如果要转的是6月份前的文件，第一个格子选择【Image】文件夹里的具体月份，然后再选择一个保存的文件夹，如下图：
4、最后点击“一键转换”，很快就可以转换好，电脑速度快的话，一秒钟转换30张图片不成问题
四、转换完成
1、以上转换完成后，可以在目标文件夹里看到转换好的图片
2、如果你需要清理DAT图片又怕清理了重要文件，可以人工筛选上面转出来的图片，留下重要图片，删除没用的图片，然后使用下面这个工具快速清理DAT文件，不影响在微信里查看它，具体用法在清理工具里有的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33d2f175603ef8cc14b95b51d2a98606/" rel="bookmark">
			uniapp 视频压缩插件 Ba-VideoCompressor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频压缩 Ba-VideoCompressor 简介（下载地址） Ba-VideoCompressor 是一款体积较小的uniapp视频压缩插件，附带简单的视频剪辑功能。
支持高、中、低三种质量快速压缩；支持自定义比特率、帧率压缩；支持监听压缩进度；支持改变播放速度；支持剪辑视频（开始时间、结束时间） 使用方法 引用 在 script 中引入组件
const videoCompressor = uni.requireNativePlugin('Ba-VideoCompressor') 示例 可在页面 script 中调用（示例参考，可根据自己业务和调用方法自行修改）
methods: { onCompress() { videoCompressor.compress({ //压缩 path: this.path, outputPath: this.outputPath, quality: this.quality, }, (res) =&gt; { console.log(res); this.path = ""; if (res.code = 2) {//code为2时，是监听处理进度 this.progress = res.progress+''; } else { uni.showToast({ title: res.msg, icon: "none", duration: 3000 }) } }); }, } 方法清单 名称说明onCompress视频压缩 onCompress 方法参数 视频压缩
属性名类型必填默认值说明pathStringtrue‘’原视频路径outputPathStringfalse‘/data/data/包名/compress/compress.mp4’视频输出路径，有默认值，可以不填qualityNumberfalse视频压缩质量，1：高 2：中 3：低bitrateNumberfalse输出视频比特率frameRateNumberfalse帧率widthNumberfalse视频宽度heightNumberfalse视频高度startTimeMsNumberfalse开始时间（用于剪辑视频，单位秒）endTimeMsNumberfalse结束时间（用于剪辑视频，单位秒）speedNumberfalse改变视频速率，用于快慢放（如：1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33d2f175603ef8cc14b95b51d2a98606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26e4f444eaa009f8cc22dc679df8c0e1/" rel="bookmark">
			常用的医学图像分割评价指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的图像分割评价指标非常多，论文中常用的指标包括像素准确率，交并比（IOU）,Dice系数，豪斯多夫距离，体积相关误差。
下面提到的所有案例都是二分类，标签中只有0和1
目录
一：像素准确率
二：交并比IOU
三： 骰子系数Dice
四：Hausdorff distance豪斯多夫距离
五：CPA-类别像素准确率
六：MPA-类别平均像素准确率
七：MIOU(平均交并比)
一：像素准确率 定义：它是图像中正确分类的像素百分比，即分类正确的像素占总像素的比例，用公式可以表述为
其中：
n代表类别总数，包括背景的话就是n+1。
为真实像素类别为i的像素被预测为类别i的总数量，也就是对于真实类别i的像素来说，分对的像素总数有多少。
真实像素类别为 i 的像素被预测为类别 j 的总数量， 换句话说，就是对于类别为 i 的像素来说，被错分成类别 j 的数量有多少.
TP为真阳性数，在标签中为阳性，在预测值中也为阳性的个数。
TN为真阴性数，在标签中为阴性，在预测值中也为阴性的个数。
FP为假阳性数，在标签中为阴性，在预测值中为阳性的个数。
FN为假阴性数，在标签中为阳性，在预测值中为阴性个数。
四者相加等于总像素数 TP+TN=正确分类的个数。
PA像素准确率有可以用两种方式来进行计算，如下图中的例子
在图中TP=3,TN=4,FN=2,FP=0,正确分类的像素数为7，总像素数为9。
但是这个指标不适用于类别不平衡的问题中，但是大多数医学图像分割都存在着类别不平衡的瓶颈问题！
二：交并比IOU Intersection-Over-Union（IOU），也被称为Jaccard指数，是语义分割中最常用的指标之一。
简单的说，IOU是预测分割和标签之间的重叠区域除以预测分割和标签之间的联合区域（两者的交集/两者的并集），如图所示，这个指标的范围是0-1（0-100%），其中0代表没有重叠区域（也就是说分割的效果特别差），1表示完全重叠的分割。其计算公式和示意图如下：
在上面的像素准确率的例子中，它的IOU计算公式如下：
三： 骰子系数Dice Dice系数定义为2倍的交集除以像素和，也叫F1 Score。Dice系数与IOU非常相似，它们是正相关的，其公式表示为：
可以看到Dice系数对应于IOU，分子和分母中的TP都取了2倍 。仍然使用上面那个例子，在这个例子中它的Dice为
四：Hausdorff distance豪斯多夫距离 HD用于分割指标，主要是用来度量边界的分割准确度。
HD是描述两组点集之间相似程度的一种度量，它是两个点集之间距离的一种定义形式：假设有两组集合A={a1,....,ap},B={b1,....bq}，则这两个点集之间的HD定义为：
H（A,B）=max(h(A,B),h(B,A))
其具体过程如下图所示：
1):取集合A中的一点a0,计算a0到集合B中所有点的距离，保留最短的距离d0
2）计算集合A中的另一点a1到集合B中所有点的距离，保留最短的距离为d1
3）比较所有的的距离{d0,d1....}选出最长的距离d1
这个最长的距离就是h，它是由A-&gt;B的单向豪斯多夫距离，记为h(A,B)。
同理也可以计算出B-&gt;A的单向豪斯多夫距离h(B,A).选出h(A,B)和h(B,A)中的最长距离。这个最长
距离就是A,B两个集合的双向豪斯多夫距离 在一般的医学图像分割任务当中，往往是HD越小代表模型的性能越好！
五：CPA-类别像素准确率 对应的是精准率，其主要含义在类别i的预测值中，真实属于i类的像素准确率。换句话说，模型对类别i的预测值有很多，其中有对有错，预测对的值占预测总的值的比例。
比如类1：P1=TP/(TP+FP)
六：MPA-类别平均像素准确率 即分别计算每个类被正确分类像素数的比例，也就是CPA然后再累加求平均。
七：MIOU(平均交并比) 模型对于每一类预测的结果和真实值的交集与并集的比值，求和再平均的结果
公式为（IOU正例+IOU反例）/2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/967e86e8a68c31787f7b6b5ec4456526/" rel="bookmark">
			深度学习----医学图像预处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知乎预处理概念https://www.zhihu.com/question/417508279/answer/1461278406 预处理是肝脏分割重要的一步，良好的预处理过程可以有效的提高分割的准度。
1.1窗口设置：窗宽和宽口水平 窗口设置是CT扫描的图像处理功能，有助于突出显示关键的解剖结构/发现，从而使图像解释尽可能容易。单位Hounsfield unites（HU）。其中，HU值越高，对象越密集。
调整窗口宽度：
增大窗口宽度将降低图像的对比度：随着窗口宽度的增加，将需要更大的密度变化来改变代表某个HU单位的灰色阴影。由于更多的结构看起来相似（尽管密度不同），因此会导致对比度下降。
减小窗口宽度将增加 图像的对比度： 随着窗口宽度的减小，密度的较小变化将导致研究图像的颜色发生变化。由于密度接近的结构将具有不同的灰色/白色/黑色阴影，因此将提供更高的对比度。 调整窗位：
增大窗位将降低图像的亮度： 随着窗口级别的增加，图像将变得更暗。这是因为随着级别的增加，将需要更高的HU值才能将密度表示为白色。
减小窗位将增加图像的亮度： 随着窗口级别的降低，图像将变得更亮。这是因为随着水平的降低，需要较低的HU值才能将密度表示为白色
肝脏窗口
视窗设定： （W：160，L：35）
优点：该窗口类似于腹部窗口，但是利用较窄的窗口来增加肝实质中的对比度（以便使肝脏病变的查找更容易）。
1.2使用Python对医学Dicom文件的预处理（含代码） 示例1：目录：1 导入相应的包 2 读取Dicom图像数据 3 设置CT图像的窗宽和窗位 4 获取Dicom图像的tag信息 5 结果保存及可视化。——Python代码 示例2：目录——链接
1.2.1 3D图像转2D图像--（偏间距--do what?):加调窗/窗位
import numpy as np import os # 用于遍历文件夹 import nibabel as nib # 用nibabel包打开nii文件 import imageio # 图像io center = 100 #肝脏的窗宽窗位 width = 140 # def get_pixel_hu(scan): # img = scan.pixel_array # img = img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/967e86e8a68c31787f7b6b5ec4456526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0549975617cc3f048ef3762dee214332/" rel="bookmark">
			伺服系统震动27问，全部问到点子上了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：伺服与运动控制
一、数控铣床，打开电源和系统，伺服电机嗡嗡响，响几分钟之后伺服电机会发热，调小刚性后不响了，但铣出来的圆不像圆，该怎样调？
应该是几台驱动器设置的增益不同，造成电机在不同的转速下自激。可以把待测的驱动器与参考驱动器的参数设置成一致再试一下。惯量比看了吗？增益是一方面，但也不要忽略了惯量。
二、伺服驱动器，通过调节三环PID控制伺服电机，噪音比较大，但电机并没有震动，载波频率是10KHZ，电流采样速度是0.1us一次，为什么？
噪音的原因：因为没有做输入脉冲滤波，所以才有那个噪音。
三、电机启动不起来而且噪声大振动大是什么原因？
1、 脱开载荷；
2、 用手盘动，确认灵活、无异常；
3、 空载启动实验；
4、 检查负载情况。
先看看是不是动平衡出了问题，这是电流声音，其次看电机轴承，最后是驱动器参数，多数是轴承松懈或坏。
四、电动机运行有异常噪音，什么原因和怎么处理？
1、当定子与转子相擦时，会产生刺耳的“嚓嚓”碰擦声，这多是轴承有故障引起的。应检查轴承，损坏者更新。如果轴承未坏，而发现轴承走内圈或外圈，可镶套或更换轴承与端盖。
2、电动机缺相运行，吼声特别大。可断电再合闸，看是否能再正常起动，如果不能起动，可能有一相熔丝断路。开关及接触器触头一相未接通也会发生缺相。
3、轴承严重缺油时，从轴承室能听到“咝咝”声。应清洗轴承，加新油。
4、风叶碰壳或有杂物，发出撞击声。应校正风叶，清除风叶周围的杂物。
5、笼型转子导条断裂或绕线转子绕组接头断开时，有时高时低的“嗡嗡”声，转速也变慢，电流增大，应检查处理。另外有些电动机转子和定子的长度配合不好，如定子长度比转子长度长得太多，或端盖轴承孔磨损过大，转子产生轴向窜动，也会产生“嗡嗡”的声音。
6、定子绕组首末端接线错误，有低沉的吼声，转速也下降，应检查叫正。
电机噪声很大，是什么原因？如何处理？
原因1：电机内轴承间隙大 处理：更换轴承。
原因2：转子扫堂 处理：重新修理定子、转子。
原因3：磁钢松动 处理方法：重新粘结磁钢。
原因4：电机机体偏转 处理：重新调整机体。
原因5：电机转向器表层氧化、烧蚀、油污凹凸不平、换向片松动 。处理：清洗换向器或焊牢换向片。
原因6：碳刷松动、碳刷架不正 处理：调整。
五、电机有噪声大，什么原因？怎么解决？
依据电机噪声发生的分歧方法,大致可把其噪声分为三大类:
①电磁噪声；②机械噪声；③空气动力噪声。
电磁噪声首要是由气隙磁场效果于定子铁芯的径向重量所发生的。它经过磁轭向别传播，使定子铁芯发生振动变形。其次是气隙磁场的切向重量，它与电磁转矩相反，使铁芯齿部分变形振动。当径向电磁力波与定子的固有频率接近时，就会惹起共振，使振动与噪声大大加强，甚至危及电机的使用寿命。
根据电磁噪声的成因，我们可采用下列办法降低电磁噪声。　⑴尽量采用正弦绕组，削减谐波成份；
⑵选择恰当的气隙磁密，不该太高，但过低又会影响资料的应用率；
⑶选择适宜的槽共同，防止呈现低次力波；
⑷采用转子斜槽，斜一个定子槽距；
⑸定、转子磁路对称平均，迭压严密；
⑹定、转子加工与装配，应留意它们的圆度与同轴度；
⑺留意避开它们的共振频率。
六、新买的电，就是电机和减速机连在一起的那种 SEW的，主要是靠 PLC和变频器控制，使用的转速很低，大约在25赫兹左右，感觉噪音很大，机械上的主动链轮和被动链轮的角度没有问题，电机底座固定的也很牢固，散热风扇和防护罩没有刮擦，爆闸也是松开的，但是一运转起来噪音非常的大，就好像小区里面变压器发出的声音，为什么？
那就是变频器驱动电机所特有的电磁噪音（吱吱的），没有办法消除掉，但可以减少一点，就是修改变频器参数：把那个载波频率加大一点，噪音就会小一点的。但是加大变频器的载波频率，会导致变频器发热。25赫兹左右低频原本很烦人，刮擦一般音频较高，底座固定的也很牢固要看什么底座，金属板声音会比较大，负载大声音会更大，用螺丝刀顶住耳朵仔细听听音源来自什么地方，要是安装没有什么问题，电机声音大往往是轴承不良，新的应该不至于，可能原本就是这样的，运行正常就行。另外就是控制问题。
七、伺服电机运转时有异响和发热是什么原因？
异响是电机的负载过重，电机的转矩小于负载所需转矩，而电机的堵转转矩大于负载所需转矩。发热就是电机的电流过大（一般发热很正常），若是很烫，或者堵转时间过长很容易烧毁电机（电机退磁）。直白说就是小马拉大车很费力，为了拉动小马就更加的费劲拉车，所以会发热（增加电流），拉车很费劲（异响）。异响是因为伺服电机轴承坏了，发热是电流大，实质是伺服电机为了克服电机轴震动而产生的异常大电流，估计电机坏了，需尽快处理，不然故障会扩大。
八、西门子伺服电机会嗡嗡响是什么问题？
伺服电机出现这种问题有多种原因，一是伺服电机编码器零位不准，也就是编码器零位漂移，二是驱动器刚性不足或参数有问题，三是伺服电机动力线接的可能有问题呀，伺服电机的动力线是不能搞错的，可调换几次看看。四是编码器安装问题或编码器自身有问题，需要认真检查，有同样的伺服电机和驱动器最好相互调换一下试试看。伺服电机有问题，最好找专业人士检修。系统与驱动器故障，电机本身故障；驱动器与实际进给系统的匹配未达到最佳值而引起的，通常只要通过驱动器的速度环增益与积分时间的调节即可进行消除，具体方法为：
1)根据驱动模块及电动机规格，对驱动器的调节器板的S2进行正确的电流调节器设定。
2)将速度调节器的积分时间Tn调节电位器(在驱动器正面)，逆时针调至极限(Tn≈39ms)。
3)将速度调节器的比例Kp调节电位器(在驱动器正面)，调整至中间位置(Kp≈7~10)。
4)在以上调整后，即可以消除伺服电动机的尖叫声，但此时动态特性较差，还须进行下一步调整。
5)顺时针慢慢旋转积分时间Tn调节电位器，减小积分时间，直到电动机出现振荡声。
6)逆时针稍稍旋转积分时间Tn调节电位器，使电动机振荡声恰好消除。
7)保留以上位置，并作好记录。
本机床经以上调整后，尖叫声即消除，机床恢复正常工作。
九、电机扫堂是什么原因？
电机扫堂就是电机的转子与定子绕组里的硅钢片发生摩擦，一般是轴承坏了，还有可能是轴承走外缘，端盖的轴承位置松动。也有可能是转子走内缘，转子上的轴承位置坏了。最小的一种可能是转子弯曲造成的。轴承磨损或者是轴承座松动会造成的转子偏心。
电机轴上支承圈磨损严重、转子铁心位移，或因其他原因使定子铁心位移，造成电机锥形转子与定子间隙太小发生扫膛。电机严禁“扫膛”，当发生扫膛后，应拆下支承圈进行更换，调整定子转子锥面之间的间隙使之均匀，或送修。
十、交流伺服电机在运行中会出现抖动的现象，问题需怎样解决？
E-1E：指检查不到遥控套准的实际值。
E-2E：指不能传送正常值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0549975617cc3f048ef3762dee214332/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45237a971b981c09dc6a84616bf9e8a/" rel="bookmark">
			有限交换环Z[i]/(a)、mZ[i]/nZ[i]的结构分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		32阶环Z[i]/(4+4i)的单个和2个生成元的真子环的子环ID分布I1I2：
Z[i]/(4+4i)=R32_-1:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,12,16,0,0],8,1,1,16,2,3,7,112,15,32,[1,3,4,4,12,8],[[2,4,16],[2,8,48],[4,2,16],[4,4,144],[4,8,192],[8,2,48],[8,4,192],[8,8,256]]
I1I2=[[1,1,1],[2,1,3],[4,2,4],[8,3,4],[16,7,4],[16,109,8]],[[2,1,3],[4,2,10],[4,4,3],[8,3,22],[8,16,12],[16,7,70],[16,109,92]]
Z[i]/([1+1i],4+4i)=R16_109:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,12,0,0],4,1,0,16,1,3,7,80,15,16,[1,3,4,0,8],[[2,4,16],[4,2,16],[4,4,144]]
I1I2=[[1,1,1],[2,1,3],[4,2,4]],[[2,1,3],[4,2,10],[4,4,3],[8,16,12]]
Z[i]/([2+2i,2],4+4i)=R8_16:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,4,0],4,1,0,8,1,3,7,48,7,8,[1,3,4,0],[[4,4,16]]
I1I2=[[1,1,1],[2,1,3],[4,2,4]],[[2,1,3],[4,2,10],[4,4,3]]
72阶环Z[i]/(6+6i)的单个和2个生成元的真子环的子环ID分布I1I2:
R72_-1:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,8,4,24,0,0,32,0,0,0,0],12,1,1,40,4,1,3,340,39,72,[1,1,2,4,2,2,6,8,6,4,24,12],[[2,
2,4],[2,4,12],[2,6,32],[2,12,96],[3,3,64],[3,6,192],[3,12,256],[4,2,12],[4,4,16],[4,6,96],[4,12,128],[6,2,32],[6,3,192],
[6,4,96],[6,6,576],[6,12,768],[12,2,96],[12,3,256],[12,4,128],[12,6,768],[12,12,1024]]
I1I2=[[1,1,1],[2,1,1],[3,2,2],[4,3,2],[4,5,2],[6,2,2],[8,22,2],[9,11,6],[12,0,8],[18,11,6],[24,-1,4],[36,-1,24]],[[2,1,1],[3,2,3],[4,3,5],[4,5,5],[6,2,11],[8,22,17],[9,11,33],[12,0,92],[18,11,105],[24,-1,142],[36,-1,852]]
80阶环Z[i]/(4+8i)的单个和2个生成元的真子环的子环ID分布I1I2:
R80_-1:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,12,4,0,12,0,48,0,0],20,1,1,48,4,3,3,432,47,80,[1,3,2,4,6,12,4,8,24,16],[[2,4,32],
[2,20,128],[4,2,32],[4,4,144],[4,10,128],[4,20,576],[5,5,16],[5,10,48],[5,20,192],[10,4,128],[10,5,48],[10,10,144],[10,2
0,576],[20,2,128],[20,4,576],[20,5,192],[20,10,576],[20,20,2304]]
I1I2=[[1,1,1],[2,1,3],[4,3,2],[5,2,4],[8,21,2],[8,24,4],[10,2,12],[16,105,4],[20,-1,8],[40,-1,24]],[[2,1,3],[4,3,5],[4,4,3],[5,2,10],[8,21,17],[8,24,22],[10,2,102],[16,105,70],[20,-1,212],[40,-1,996]]
Z[i]/([4i,2+2i],8+8i)=R16_117:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,12,0,0],4,1,0,16,1,7,15,192,15,16,[1,3,4,8,0],[[4,4,64]]
I1I2=[[1,1,1],[2,1,3],[4,1,4],[8,23,8]],[[2,1,3],[4,1,10],[4,4,3],[8,5,12],[8,23,44]]
范数不超过25的高斯整数共有121个。
第1个高斯整数(0,0)=0范数为0不是高斯素数
第2个高斯整数(1,0)=1范数为1不是高斯素数
R1_1:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1],1,1,1,0,1,0,0,1,0,1,[1],[]
第3个高斯整数(0,1)=范数为1不是高斯素数
R1_1:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1],1,1,1,0,1,0,0,1,0,1,[1],[]
第4个高斯整数(-1,0)=-1范数为1不是高斯素数
R1_1:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1],1,1,1,0,1,0,0,1,0,1,[1],[]
第5个高斯整数(0,-1)=范数为1不是高斯素数
R1_1:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1],1,1,1,0,1,0,0,1,0,1,[1],[]
第6个高斯整数(1,1)=1+1i范数为2是高斯素数
R2_2:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,1],2,1,1,1,2,0,0,3,0,2,[1,1],[[2,2,1]]
第7个高斯整数(-1,1)=-1+1i范数为2是高斯素数
R2_2:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,1],2,1,1,1,2,0,0,3,0,2,[1,1],[[2,2,1]]
第8个高斯整数(-1,-1)=-1-1i范数为2是高斯素数
R2_2:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,1],2,1,1,1,2,0,0,3,0,2,[1,1],[[2,2,1]]
第9个高斯整数(1,-1)=1-1i范数为2是高斯素数
R2_2:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,1],2,1,1,1,2,0,0,3,0,2,[1,1],[[2,2,1]]
第10个高斯整数(2,0)=2范数为4不是高斯素数
R4_9:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,0],2,1,1,2,2,1,1,8,1,4,[1,2,1],[[2,2,8]]
第11个高斯整数(0,2)=范数为4不是高斯素数
R4_9:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,0],2,1,1,2,2,1,1,8,1,4,[1,2,1],[[2,2,8]]
第12个高斯整数(-2,0)=-2范数为4不是高斯素数
R4_9:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,0],2,1,1,2,2,1,1,8,1,4,[1,2,1],[[2,2,8]]
第13个高斯整数(0,-2)=范数为4不是高斯素数
R4_9:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,0],2,1,1,2,2,1,1,8,1,4,[1,2,1],[[2,2,8]]
第14个高斯整数(2,1)=2+1i范数为5是高斯素数
R5_2:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,4],5,1,1,1,2,0,0,9,0,5,[1,4],[[5,5,16]]
第15个高斯整数(1,2)=1+2i范数为5是高斯素数
R5_2:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,4],5,1,1,1,2,0,0,9,0,5,[1,4],[[5,5,16]]
第16个高斯整数(-1,2)=-1+2i范数为5是高斯素数
R5_2:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,4],5,1,1,1,2,0,0,9,0,5,[1,4],[[5,5,16]]
第17个高斯整数(-2,1)=-2+1i范数为5是高斯素数
R5_2:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,4],5,1,1,1,2,0,0,9,0,5,[1,4],[[5,5,16]]
第18个高斯整数(-2,-1)=-2-1i范数为5是高斯素数
R5_2:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,4],5,1,1,1,2,0,0,9,0,5,[1,4],[[5,5,16]]
第19个高斯整数(-1,-2)=-1-2i范数为5是高斯素数
R5_2:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,4],5,1,1,1,2,0,0,9,0,5,[1,4],[[5,5,16]]
第20个高斯整数(1,-2)=1-2i范数为5是高斯素数
R5_2:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,4],5,1,1,1,2,0,0,9,0,5,[1,4],[[5,5,16]]
第21个高斯整数(2,-1)=2-1i范数为5是高斯素数
R5_2:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,4],5,1,1,1,2,0,0,9,0,5,[1,4],[[5,5,16]]
第22个高斯整数(2,2)=2+2i范数为8不是高斯素数
R8_22:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,4,0],4,1,1,4,2,1,3,20,3,8,[1,1,4,2],[[2,2,4],[2,4,12],[4,2,12],[4,4,16]]
第23个高斯整数(-2,2)=-2+2i范数为8不是高斯素数
R8_22:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,4,0],4,1,1,4,2,1,3,20,3,8,[1,1,4,2],[[2,2,4],[2,4,12],[4,2,12],[4,4,16]]
第24个高斯整数(-2,-2)=-2-2i范数为8不是高斯素数
R8_22:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,4,0],4,1,1,4,2,1,3,20,3,8,[1,1,4,2],[[2,2,4],[2,4,12],[4,2,12],[4,4,16]]
第25个高斯整数(2,-2)=2-2i范数为8不是高斯素数
R8_22:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,4,0],4,1,1,4,2,1,3,20,3,8,[1,1,4,2],[[2,2,4],[2,4,12],[4,2,12],[4,4,16]]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d45237a971b981c09dc6a84616bf9e8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/800fcccc45cef0505f8bf47583c25814/" rel="bookmark">
			思科路由器基本配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN话题挑战赛第2期https://marketing.csdn.net/p/7b6697fd9dd3795a268d1a6f2fe75012
参赛话题：学习笔记https://activity.csdn.net/creatActivity?id=10213
目录
一、用户模式
二、特权模式
三、全局模式 (global config mode)
四、子模式 (sub-mode)
（1）接口模式（interface mode)
（2）线路模式 (line mode)
（3）路由模式（router mode)
五、Setup模式*
六、ROMMON模式*
七、Router工作模式转换实例
八、配置命令
1.命名路由器
2.设置enable密码
3.配置控制台密码
4.配置VTY密码
5.启用SSH
6.配置串行口
7.配置以太口
九、整体配置命令的切换
十、配置登录提示信息
十一、解决命令输错后的域名查找
十二、show命令
十三、保存、删除、查看配置文件
1.保存配置文件
2.删除配置文件
3.查看配置文件
*简写命令是在命令唯一的前提下才行
一、用户模式 (user mode) "&gt;" 可以做一些简单的查询 二、特权模式 privilgede mode) "#" 进入方法：在用户模式下，输入enable(en)即可进入，disable(dis)即可退出 三、全局模式 (global config mode) "router(config)#" 在特权模式下输入：config t即可进入 四、子模式 (sub-mode) （1）接口模式（interface mode) router(config-if)#
（2）线路模式 (line mode) router（config-line)#
（3）路由模式（router mode) router(config-router)#
五、Setup模式* 在控制台提供了交互式的对话，帮助新的用户创建初次的基本配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/800fcccc45cef0505f8bf47583c25814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/794caa2af38b5940f8e988875238fcc5/" rel="bookmark">
			运算符和表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逗号运算符和逗号表达式
C语言中“，”也是一种运算符，其功能是把多个表达式连接起来组成一个表达式，称为逗号表达式。逗号表达式的一般格式为：
表达式1，表达式2，…，表达式n
（1）逗号表达式的执行顺序是：从左到右依次计算每个表达式的值，并把最后一个表达式的值作为整个逗号表达式的值。
如对于表达式“a=4,b=5,c=a+b”，首先计算a=4的值，结果为4，在计算b的值，结果为5，最后计算c=a+b的值，结果为9，则整个逗号表达式的值为9，该表达式执行完后，a=4,b=5,c=9.
（2）逗号运算符是双目运算符，其优先级最低，是左结合的。
（3）并非所有出现逗号地方都为逗号表达式，如在变量说明语句中，以及函数表达式中逗号只是用作各变量之间的分隔符。
逗号表达式应用示例
#include&lt;stdio.h&gt; int main() { int i,j=7; float k=5; i=(j=j+2,j/k); printf("i=%d\n",i); return 0; } 运行结果为：
i=1
求字节数运算符
运算符sizeof用于计算数据类型所占的字节数，它是一个单目运算符，优先级高于双目运算符，其一般格式如下：
（1）sizeof(表达式)或sizeof表达式
（2）sizeof（数据类型名）
不同数据类型字节数示例：
#include&lt;stdio.h&gt; int main() { printf("char类型占%d字节\n",sizeof(char)); printf("short int类型占%d字节\n",sizeof(short int)); printf("int类型占%d字节\n",sizeof(int)); printf("float类型占%d字节\n",sizeof(float)); printf("double类型占%d字节\n",sizeof(double)); return 0; } 运行结果：
char类型占1字节
short int类型占2字节
int类型占4字节
float类型占4字节
double类型占8字节
求字节数运算符示例：
#include&lt;stdio.h&gt; int main() { int a,b; a=sizeof(3+5.0); b=sizeof 3+5.0; printf("%d,%d,%d\n",a,b,sizeof("china")); return 0; } 运行结果：
8,9,6
说明：执行语句“a=sizeof(3+5.0);”时，先计算出3+5.0的结果为double型的8.0，然后再对其求字节数，结果为8。执行语句“b=sizeof3+5.0;”时，由于sizeof运算符的优先级高于+运算符，因此计算sizeof3，其值为4，然后计算4+5.0=9.0，赋值给int型的变量b时，b=9。“china”是字符串，其字节数为字符串的长度加1字节，增加的这个字节用于存放字符串的结束符‘\0’。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc1c2fa82f63b2dd1b418dada622ae1/" rel="bookmark">
			ubuntu desktop 20.04安装和优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu desktop 20.04安装和优化 安装常用软件安装性能优化`tuned`安装火焰截图ubuntu实时显示网速和gpu卸载网速显示器 主题优化点击图标最小化关闭/最小化/最大化切换到左上角修改切换工作区的快捷键 安装`exfat`支持支持空格预览安装unar压缩工具视频播放ubuntu20.04安装libinput-gestures实现三指上下滑动切换工作区从git仓库编译并安装libinput-gestures确保libinput-tools和xdotool已安装：确保当前用户在输入组中具有读取触摸板设备的权限：开启自动启动： ubuntu20.04配置python开发环境1.安装python3.x的解释器环境2.安装ifconfig支持ssl源配置测试开发环境PYcharm的依赖包 Ubuntu安装LibreOffice中文包Ubuntu指定home子目录 先更换国内源
安装常用软件 # 安装最新版ssh和git apt install ssh git -y # 安装zhcon以支持命令行下中文显示 sudo apt install zhcon -y # 安装zsh sudo apt install zsh autojump fasd -y # 安装preload预载 sudo apt install preload -y # 安装proxychains sudo apt install proxychains dnsutils -y # 卸载默认的gnome-terminal终端--非必须 sudo apt autoremove gnome-terminal --purge -y # 安装terminator新终端 sudo apt install terminator -y # 安装axel多线程下载 sudo apt install wget axel curl -y # 安装md编辑器typora sudo apt install typora 安装性能优化tuned 用于监视和自适应调整系统设备
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fc1c2fa82f63b2dd1b418dada622ae1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18875d5dc3a7ee3718fee597bd283139/" rel="bookmark">
			proxy_cfw全局代理_浏览器代理配置(chromium based(edge)/firefox/IDM)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 无须sstap等软件实现虚拟网卡代理reference配置步骤service Modetun Mode 检查启用情况edge 浏览器内部代理配置插件Proxy firefoxIDM代理小结 无须sstap等软件实现虚拟网卡代理 在较的版本中,您可以直接下载TUN Mode开启tun而无须更多的配置即可以使用TUN (更多细节可以参看CFW官网) reference cfw(lbyczf.com)TUN 模式 | cfw (lbyczf.com) 配置步骤 service Mode 先下载并启用service Mode(会自动重启应用,该过程一般不会太久(10s) tun Mode 下载并启用tun Mode
检查启用情况 能够使得Ping 走代理
wget也可
edge 浏览器内部代理配置 插件Proxy SmartProxy - Microsoft Edge Addons firefox 火狐浏览器自带作用域代理 IDM代理 小结 通过上述设置,就不必总是打开系统代理,可以更加灵活 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f562846e894273da4509f51b57c328/" rel="bookmark">
			Java实现万年历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果如图 完整代码 public static void calanderSuccess() { Scanner sca = new Scanner(System.in); System.out.println("实现万年历效果"); System.out.println("**********欢迎使用万年历**********" + '\n'); System.out.print("请选择年份:(必须要是个正常年份哦!)"); int year = sca.nextInt(); System.out.print("请选择月份:"); if (year &lt;= 0) { System.out.println("请重新输入年份"); } else { int month = sca.nextInt(); if (month &lt;= 0 || month &gt; 12) { System.out.print("请重新输入月份"); } else { int moon=month; month = Judgeonth(month, year); System.out.println("这个月有" + month + "天"); // System.out.println("没思路,不写了"); int yuday = month / 7; int week = month % 5; int century = year / 100; int lst_year=year%100; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0f562846e894273da4509f51b57c328/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01b0755dfd0d388af313e6b273fc7d6b/" rel="bookmark">
			MySQL事务高频面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是事务 对于一个事务，要么事务内的SQL全部执行，要么都不执行
2、事务的四个特征 原子性
原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。
begin transaction; update account set money = money-100 where name = 'Brooks'; update account set money = money+100 where name = 'Cherry'; commit transaction; 一致性
数据库总是从一个一致性状态转换到另一个一致性状态。(事务按照预期生效，数据的状态是预期的状态)。举个例子：张三给李四转了100块钱，张三扣了100元，李四获得100元，数据状态是正确的为一致性，否者张三转帐了，李四却没有收到，数据错误，就没有达到一致性，
隔离性
事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
持久性
一旦事务提交，则所做的修改就会永久保存在数据库中。无论什么情况数据也不会丢失。
3、MySQL四种隔离级别 读未提交 Read Uncommitted
在这个级别下，事务中的修改，即使没有提交，对其他事物也是可见的。可能会导致脏读，不可重复或幻读。
读提交 Read Committed
一个事务从开始到提交之前，所做的任何修改都是对其他事物不可见的。可能会发生幻读，不可重复读。
Repeatable Read （MySQL默认隔离级别）
保证了同一个事物中多次读取同样的记录的结果是一致的，可能会发生幻读，InnoDB通过MVVC多并发版本控制来解决幻读问题。
串行化 Serializable
最高隔离级别。强制事物串行执行。避免幻读问题。SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超市和锁竞争问题。
4、什么是脏读，幻读，不可重复读？ 脏读 Dirty Read （读未提交数据）
当事务A正在访问一个数据并进行了修改，但这种修改还没有提交到数据库中，此时事务B也访问到了这个数据，并且使用了这个数据。由于这个数据是还没有提交的数据，那么事务B读取的这个数据是“脏数据”，那么之后的操作都是不正确的。这种情况常发生于转账与取款操作中。
幻读 Phantom Read （前后多次读取，数据总量不一致）
当事务A执行读取操作时，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就想产生了幻觉一样，平白无故多了几条数据，称为幻读。
不可重复读 Unrepeatable Read （前后多次读取，数据内容不一致）
事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读
5、事务是如何实现的？ 首先让我们先来了解一下什么是事务日志
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01b0755dfd0d388af313e6b273fc7d6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce2f7ab7f8b17142d5fdadbf36dbb30/" rel="bookmark">
			HBase2.x（十五）Phoenix 二级索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 二级索引配置文件全局索引（global index）包含索引（covered index）本地索引（local index） 二级索引配置文件 添加如下配置到 HBase 的 HRegionserver 节点的 hbase-site.xml。
&lt;!-- phoenix regionserver 配置参数--&gt; &lt;property&gt; &lt;name&gt;hbase.regionserver.wal.codec&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hbase.regionserver.wal.IndexedWALEditCodec&lt;/value&gt; &lt;/property&gt; 全局索引（global index） Global Index 是默认的索引格式，创建全局索引时，会在 HBase 中建立一张新表。也就是说索引数据和数据表是存放在不同的表中的，因此全局索引适用于多读少写的业务场景。
写数据的时候会消耗大量开销，因为索引表也要更新，而索引表是分布在不同的数据节点上的，跨节点的数据传输带来了较大的性能消耗。在读数据的时候 Phoenix 会选择索引表来降低查询消耗的时间。
创建单个字段的全局索引。
CREATE INDEX my_index ON my_table (my_col); #例如 create index my_index on student1(age); #删除索引 DROP INDEX my_index ON my_table #例如 drop index my_index on student1; 查看二级索引是否有效，可以使用 explainPlan 执行计划，有二级索引之后会变成范围扫描
explain select id,name from student1 where age = 10; 如果想查询的字段不是索引字段的话索引表不会被使用，也就是说不会带来查询速度的提升。
例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ce2f7ab7f8b17142d5fdadbf36dbb30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d5b862a9f4acea40616d3d51d88285/" rel="bookmark">
			PTA 10-49 查询学生表中部分信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题目要求编写SQL语句，
检索出 stu 表中学生的学号、姓名、性别.
注意：性别为'1'时显示‘男’，性别为‘0’时显示 ‘女’。
表结构: 请在这里写定义表结构的SQL语句。例如：
CREATE TABLE `stu` ( `sno` char(4) NOT NULL, `sname` char(8) NOT NULL, `sex` tinyint(1) DEFAULT NULL, `mno` char(2) DEFAULT NULL, `birdate` datetime DEFAULT NULL, `memo` text, PRIMARY KEY (`sno`) ); 表样例 请在这里给出上述表结构对应的表样例。例如
stu表：
输出样例: 请在这里给出输出样例。例如：
select sno,sname,case sex when sex = 1 then '男' else '女' end as sex from stu ; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4167e7dbd55ceaaf6a7212c07e57235e/" rel="bookmark">
			Linux下gdb调试方法(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Linux下gdb介绍：
虽然 Linux系统下，读者编写 C/C++代码的IDE可以自由选择，但调试生成的 C/C++ 程序一定是直接或者间接使用gdb调试器。调试是开发流程中一个非常重要的环节，因此，对于从事 Linux C/C++ 的开发人员，熟练使用gdb 调试是一项基本要求。
2. Linux下C代码的编译：
gdb调试器的主要功能，就是监控程序的执行流程。Linux发行版中，经常使用gcc编译 C、C++ 程序。但需要注意的是，仅使用 gcc（或 g++）命令编译生成的可执行文件，是无法借助gdb进行调试的。
gcc编译器的优化选项：
gcc编译器支持 -O（等于同 -O1，优化生成的目标文件）和 -g 一起参与编译。GCC 编译过程对进行优化的程度可分为 5 个等级，分别为 O0~O4，O0 表示不优化（默认选项），从 O1 ~ O4 优化级别越来越高，O4 最高。
所谓优化，例如省略掉代码中从未使用过的变量、直接将常量表达式用结果值代替等等，这些操作会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。
而相对于 -O -g 选项，对 GDB 调试器更友好的是 -Og 选项，-Og 对代码所做的优化程序介于 O0 ~ O1 之间，真正可做到“在保持快速编译和良好调试体验的同时，提供较为合理的优化级别”。
(1) 不带调试信息的代码的编译：
Linux下一般编译C/C++代码时，编译命令为gcc debug_test1.c -o debug_test1，则生成的debug_test1即为可运行程序，该程序是不带调试信息的程序。
(2) 带调试信息的代码的编译：
如果我们需要对生成的可执行程序进行gdb调试，则在编译时需要加上-g选项，加上-g选项即向编译器表明，该程序需要编译成可以gdb调试的代码，加上编译信息，生成的执行文件是带调式信息的程序（比如各行代码所在的行号、包含程序中所有变量名称的列表（又称为符号表）等），生成的可执行程序文件大小也会变大。
终端输入编译命令：gcc -g debug_test1.c -o debug_test1
如果通过Makefile文件进行编译，则在Makefile文件中 -o 编译时添加 -g选项即可。
3. Linux下gdb调试方法
(1) 判断Linux系统是否安装gdb:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4167e7dbd55ceaaf6a7212c07e57235e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b52ac333a108e0e0299a6bfeb0f81869/" rel="bookmark">
			dpdk-19.11 中 rte_mempool_create 与 rte_pktmbuf_pool_create 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言mempool_ops 抽象rte_mempool_create_emptyrte_mempool_create VS rte_pktmbuf_pool_create 接口dpdk 使用 dpaa 网卡其它类似行为总结 前言 dpdk-16.04 中，使用 rte_mempool_create 与 rte_pktmbuf_pool_create 都可以创建出支持多生产者与多消费者的 pktmbuf pool。
rte_mempool_create 创建 pktmbuf pool 示例代码如下：
pool = rte_mempool_create("MBUF_POOL", nb_mbuf_per_pool, MBUF_SIZE, MBUF_CACHE_SIZE, sizeof(struct rte_pktmbuf_pool_private), rte_pktmbuf_pool_init, NULL, rte_pktmbuf_init, NULL, rte_socket_id(), 0); rte_pktmbuf_pool_create 创建 pktmbuf pool 示例代码如下：
test_params-&gt;mbuf_pool = rte_pktmbuf_pool_create("MBUF_POOL", nb_mbuf_per_pool, MBUF_CACHE_SIZE, 0, RTE_MBUF_DEFAULT_BUF_SIZE, rte_socket_id()); rte_pktmbuf_pool_create 只能创建多生产者与多消费者的 pktmbuf pool，使用 rte_mempool_create 却可以创建诸如单生产者与单消费者的 pktmbuf pool。
尽管低版本有这样的行为，在高版本这两个接口却会有不同的行为。当 dpdk 程序从低版本向高版本迁移时，混用这两个接口在一些场景会有潜在的问题，且从编码角度不容易发现， 本文将描述一个相关的问题案例。
mempool_ops 抽象 dpdk 高版本对 mempool 进一步抽象，引入了 rte_mempool_ops 来实例化不同功能的 mempool 操作方法。在新的实现中，每一个 mempool 都要被绑定到一个 rte_mempool_ops 函数表上，这个函数表可以由用户指定，也可以隐藏在 mempool 创建的过程中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b52ac333a108e0e0299a6bfeb0f81869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9329c66f98625a4729c40e28b981cb16/" rel="bookmark">
			华为ensp模拟校园网/企业网实例（XX学校网络设计与实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.网络需求分析
1.1 功能需求分析
1.2 技术需求分析
1.3 网络安全需求分析
2.校园局域网设计
2.1 拓扑图
2.2 IP 规划和 VLAN 划分
2.3 核心层设备配置
2.3.2 ospf配置
2.3.3 ACL访问控制配置
2.4 汇聚层设备配置
2.4.2 ospf及开销修改配置
2.4.3 vrrp配置
2.4.4 dhcp地址池配置
2.4.5 mstp生成树配置
2.5 接入层配置
2.5.1 接口配置
2.6 防火墙及NAT配置
2.7 校园网服务器配置 3 设备选型
3.1 设备选型原则
3.2 核心层交换机选型
3.3 接入层交换机
3.4 防火墙选择
4 网络测试
1.网络需求分析 1.1 功能需求分析 校园网与 Internet 相连， 师生可以通过互联网获取资源与信息。实现在校园网内部的文件传输共享。实现学校教师、行政的无纸化办公。 1.2 技术需求分析 IP规划：校园网络的特点是终端数量十分庞大。按照不同的职能划分不同的网络区域， IP 规划要适当。服务器：校园网中的服务器需要 24 小时开机，因此需要有专用的服务器机房站点，并有专业的运维人员看护。网络需要具有较高的冗余性，避免出现单点故障。校园网络的 ISP 接入选择要合适，根据在校人数和校园服务购买一定的 IP 数量和多条的链路带宽。由于校园网内流量较大，需求划分相应VLAN，来划分广播域，节省网络带宽。并且实现流量的负载均衡。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9329c66f98625a4729c40e28b981cb16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e6d3d4d7add6cbf1022a68170ee0511/" rel="bookmark">
			Apache2.4 配置解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 (一) httpd.conf服务器根目录服务监听端口加载动态共享对象服务运行权限联系方式和服务器名系统目录访问权限网站目录访问权限默认访问文件禁止访问文件定义日志格式文件/目录重定向CGI配置MIME类型与文件处理定义错误响应其他配置 (二) httpd-ssl.conf(三) httpd-vhosts.conf(四) .htaccess 基于XAMPP Version 8.1.6中Apache的默认配置，对常用配置项进行解析说明： httpd.conf是Apache服务器的主配置文件，Apache的绝大多数功能都在此文件配置，httpd-ssl.conf、httpd-vhosts.conf等作为模块化功能配置文件，在httpd.conf中以Include形式添加，以简化主配置文件，同时便于对模块化功能进行配置。
(一) httpd.conf Windows下默认路径：%install_path%\xampp\apache\conf\httpd.conf，具体配置指令解释可参考 Apache官方文档 📖
注意以下几点：
默认的相对路径为服务器根目录，如当服务器根目录为"/usr/local/apache2"时，“logs/access_log"就等同于”/usr/local/apache2/logs/access_log"，为避免混淆，建议始终使用绝对路径进行配置注意文件路径必须使用正斜杠而不是反斜杠，如 “c:/apache”，而不是"c:\apache"，且不要在目录路径的末尾添加斜杠配置命令和XML标签英文字符大小写不敏感 服务器根目录 # 定义服务器根目录，也是默认安装目录 # 是保存服务器配置文件、日志和错误信息的目录，注意与网站根目录区分开 Define SRVROOT "C:/xampp/apache" ServerRoot "C:/xampp/apache" 服务监听端口 # 定义服务监听端口 # 可通过绑定监听端口的IP避免本机所有IP地址同时开启监听，如 Listen &lt;IP&gt;:80 # Listen 80 或 Listen 0.0.0.0:80 或 Listen *:80 代表本机所有IP都开启端口监听 # Listen 127.0.0.1:80 或 Listen localhost:80 代表只在本地环回地址上监听端口，这样服务就只能从本地访问 Listen 80 加载动态共享对象 # 加载动态共享对象(DSO)模块，这里省略注释掉的模块 # 已编译的DSO模块存放在Apache安装目录下的modules目录中 # DSO类似于动态链接库，用于在程序运行时动态加载功能模块的代码 LoadModule access_compat_module modules/mod_access_compat.so LoadModule actions_module modules/mod_actions.so LoadModule alias_module modules/mod_alias.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e6d3d4d7add6cbf1022a68170ee0511/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c99545182900feec7e8c049725baaa9/" rel="bookmark">
			STM32移植时printf串口打印中文乱码，mark一下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32移植后，使用printf进行串口打印，中文显示乱码：
移植时是先新建.txt文档，复制完代码后改为.c文件，查找相关资料，得知.c文件为“UTF-8”编码，需要将编码格式改成ANSI格式。
1，先将程序文件（.c/.h文件）用记事本打开，选择菜单栏的“文件”--“另存为...”，将编码格式改为“ANSI”，覆盖原来的程序文件。
2，将程序工程重新编译后重新烧录程序，printf打印中文可以正常显示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44951b6821a2773038d417279c2e8294/" rel="bookmark">
			7-176 数列求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分数 10
全屏浏览题目
切换布局
作者 唐艳琴
单位 中国人民解放军陆军工程大学
编程计算， sn=(1-1/2)+(1/3-1/4)+...+(1/(2n-1)-1/(2n))，结果保留两位小数。
输入格式: 输入整数n值。
输出格式: 输出sn值。
输入样例: 1 输出样例: 0.50 代码如下：
#include &lt;stdio.h&gt; int main() { double s=0,b; int i,n,a; scanf("%d", &amp;n); n=n*2; for(i=1;i&lt;=n;i++) { a=i; if(i%2!=0) { b=i; } else { b=-i; } s=s+1/b; } printf("%.2lf",s); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec66af475d96d32f772cdfe2b137937/" rel="bookmark">
			[C语言]do while循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天连写两个blog，感觉状态不错。
把do while循环语句写完，那循环语句的大头算是结束了。
下面进入主题
do while的语法 do
循环语句；
while（表达式）；
下面举个例子
#include &lt;stdio.h&gt; int main() { int i = 10; do { printf("%d\n", i); }while(i&lt;10); return 0; } 我说这个代码要是能运行起来的话，那么该语句的作用特点其实就大致知道了
do while语句的特点 循环至少执行一次，使用的场景有限，所以不是经常使用。 在该语句中，是先执行代码，后进入while表达式 do while语句中的break和continue 其实大体上是和前面两个循环语句用法是一致滴！
作者想摆烂了，因为发现，其实do while语句在我现在这个阶段似乎用处并不大。所以，等到后期我能够发现do while语句对我有大用处，或者对其有新的认识和发现再来补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b8382c0cc3de642417ec0722114a4c2/" rel="bookmark">
			[C语言]for语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面发布的内容中，我们已经详细讲述过了一种循环语句，即while语句，今天再来与大家分享一下for语句。
for语句的语法 for（exp1；exp2；epx3）
循环语句；
其中，exp1为初始化部分，exp2为判断部分，epx3为调整部分
下面我们用while循环和for循环都打出同一种代码来比较一下
Q：打印1-10的数字
1.while循环
#include&lt;stdio.h&gt; int main() { int a = 0; while(a&lt;10) { printf("%d\n",a); a++; } return 0; } 2.for循环
#include&lt;stdio.h&gt; int main() { int a =0; for(a=0;a&lt;10;a++) { printf("%d\n",a); } return 0; } 这样，两个代码段一对比，我们就能明显的看出差别。在while语句中，初始化，判断，调整三部分分布较远，如果想要调整的话比较麻烦（与for循环相比），而for循环呢，可以直接在（）中进行调整，比较方便。
tip
个人建议，若要使用for循环，在判断部分的变量取值最好使用前闭后开的样式。
例如：
int a; for(a=0;a&lt;10;a++); 和
int a; for(a=0;a&lt;=9;a++); 两个代码段表达的意思相同，都是a循环10次，可是在第一种开区间的表示中，我们可以明显看出循环次数，即a&lt;10中的10是有意义的。
for循环中的break和continue for循环中的break和continue其实和while循环中的相差无几。在for循环中，只要遇到了break，就跳出循环；遇到continue，就跳过后面的代码，直接进入下一次循环。
一些for循环的变种 其实，在for循环中，exp1,即判断部分可省略，但是不建议初学者省略，容易导致一些问题。
下面我给大家举例
int main() { int i = 0; int j = 0; for (; i &lt; 10; i++) { for (; j &lt; 10; j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b8382c0cc3de642417ec0722114a4c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77e771f36c3ae3a4a52645239d5ec972/" rel="bookmark">
			sklearn中SVM的可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文代码参考博主twilight0402的文章
关于sklearn中SVM使用的文章很多，但其可视化部分往往给出代码但解释通常都不是很详细，本文主要对sklearn训练SVM后的可视化过程进行阐述，故对SVM的使用不做赘述，可以参考其他文章。
1.导入数据：本文使用sklearn中的moon、circle生成数据
import numpy as np from sklearn import svm, datasets from sklearn.pipeline import Pipeline from sklearn.preprocessing import StandardScaler import matplotlib.pyplot as plt # 生成弯月形数据 Data = datasets.make_moons(n_samples=100, noise=0.2, random_state=11) # # 生成环形数据 # Data = datasets.make_circles(n_samples=100, noise=0.1, factor=0.1, random_state=11) X = Data[0] # 特征 (100, 2) y = Data[1] # 标签，0或1 (100,) 2.构造SVM模型：参考文章，这里使用pipeline构造包含数据归一化和SVM的模型
def creatSVM(kernel='rbf', C=10, gamma=10): """ :param kernel: SVM使用的核函数，本文以rbf核为例，常用于处理分线性分类问题 :param C: 目标函数惩罚项系数 :param gamma: rbf核函数参数。实际训练模型时C和gamma需要调参 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77e771f36c3ae3a4a52645239d5ec972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd20196dc6e53762ec95b9646da09da0/" rel="bookmark">
			实例渲染(Instanced Rendering)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Instanced Rendering 实例渲染 Introduction 介绍 Qt Quick 3D supports instancing of Model objects. Instancing refers to a technique where one object is rendered multiple times with a single draw call. (For example the OpenGL function glDrawElementsInstanced.)
​Qt Quick 3D支持模型对象的实例化。实例化是指使用一个绘制调用多次渲染一个对象的技术。（例如，OpenGL函数glDrawElementsInstanced。）
Instancing allows duplicating a model with variations. In contrast to using a Repeater3D, the model and its graphics resources are only allocated once. The rendering of the duplicated instances is done at a low level by the GPU.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd20196dc6e53762ec95b9646da09da0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707ce8094804644789c2dbb635aab4cf/" rel="bookmark">
			实训十六：交换机多实例生成树配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的 1、 了解 MSTP 生成树协议的作用。
2、 熟悉 MSTP 生成树协议的配置。
二、应用环境 1、为了解决二层网络冗余环路产生的广播风暴，引入 STP 解决了上述问题。
2、STP 存在收敛慢，临时失去连通性等缺陷，为了弥补 STP 的不足，引入了 RSTP。但是上述二者都没有解决链路负载分担得问题。因此又有了 MSTP 生成树协议，不仅能够解决广播风暴的问题，同时实现了负载均衡的功能。
三、实验设备 1、 DCN-CS6200 交换机 2 台
2、 DCN-S4600 交换机 1 台
3、 Console 线 1-2 根
4、 直通网线 4-8 根
四、实验拓扑 小提示：端口不一定非得按我的来，也可以自己随便插。
五、实验要求 网线连接
IP设置
六、实验步骤 第一步：设备恢复出厂设置，做初始配置。
交换机 A CS6200-28X-EI# CS6200-28X-EI#config CS6200-28X-EI(config)#hostname switchA switchA(config)#vlan 10 switchA(config-vlan10)#exit switchA(config)#vlan 20 switchA(config-vlan20)#exit switchA(config)#interface vlan 10 switchA(config-if-vlan10)#ip address 192.168.10.1 255.255.255.0 switchA(config-if-vlan10)#exit switchA(config)#interface vlan 20 switchA(config-if-vlan20)# switchA(config-if-vlan20)#ip address 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707ce8094804644789c2dbb635aab4cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f4d7491b5055c7739458d3b6386c39/" rel="bookmark">
			编程题－算法－中等－leetcode－739. 每日温度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程题－算法－中等－leetcode－739. 每日温度 1、题目：每日温度2.1 方式一2.1 方式二： 1、题目：每日温度 2、编程解答
看到题目，可以想到用一个双向队列来记录对应的温度和下标值。然后遍历温度temperatures，当遍历的温度值(temp)比队首元素的温度(firstTempInQue)高，则可以得到队首元素的结果。
如果当前温度值（temp）比队首元素的温度（firstTempInQue）低，则将其放到队首。
2.1 方式一 方式一比较好理解，自定义类Node和队列，进行解答
class Node { int temperature; int index; public Node(int tmp, int idx) { this.temperature = tmp; this.index = idx; } } class Solution { public int[] dailyTemperatures(int[] temperatures) { int[] res = new int[temperatures.length]; Deque&lt;Node&gt; queue = new LinkedList&lt;&gt;(); for (int i=0; i&lt;temperatures.length; i++) { Node node = new Node(temperatures[i], i); // 如果队列非空，且对首元素温度低于当前遍历的温度值，则找到队首对应的结果 while (!queue.isEmpty() &amp;&amp; queue.peekFirst().temperature&lt;node.temperature) { Node firstNode = queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9f4d7491b5055c7739458d3b6386c39/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/226/">«</a>
	<span class="pagination__item pagination__item--current">227/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/228/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>