<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cb83efbf9a6a76c7b70ed33495d0409/" rel="bookmark">
			C语言-指针变量作为函数参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指针变量作为函数参数 函数的参数类型不仅仅是整型，浮点型，字符型也可以是指针类型，它的作用是将一个变量的地址传到另外一个函数中，常见的是传数组的首地址。
文章目录 指针变量作为函数参数一、示例1二、示例2三、示例3 提示：以下是本篇文章正文内容，下面案例可供参考
一、示例1 #include&lt;stdio.h&gt; void swap(int *p1,int *p2);//函数的声明 int main() { int a,b; int *m,*n; printf("please enter a and b:"); scanf("%d,%d",&amp;a,&amp;b); m = &amp;a; n = &amp;b; if(a&lt;b) swap(m,n); printf("max = %d,min = %d",a,b); } void swap(int *p1,int *p2) { int temp; temp = *p1; *p1 = *p2; *p2 = temp; } 程序分析：
swap是用户自己定义的函数，其作用是交换两个变量a和b的值，swap函数中的两个形参p1和p2是指针变量。程序运行时，先执行main函数，输入a和b的值（例如输入5和9）。然后将a和b的地址赋给int*类型的m和n。使m指向a，n指向b。
接着执行if函数，由于a&lt;b，执行swap函数，指针变量m将&amp;a传给p1，n将&amp;b传给p2，此时p1和p2分别指向a和b。
接着执行swap函数体，交换*p1和*p2的值，即a和b的值互换。
函数调用结束后，形参p1和p2释放，最后在main函数中输出的a和b的值已经是交换过的。
注意：注意*p1和*p2的值是如何实现的
如果改为如下就有问题
void swap(int *p1,int *p2) { int *temp; *temp = *p1; p1 = *p2; p2 = *temp; } p1就是a，是整型变量。而temp是指针变量temp所指向的变量。但由于没有给temp赋值，因此temp中并无确定的值（它的值是不可遇见的），所以temp所指向的单元也是不可预见的。对*temp赋值就是向一个未知的存储单元赋值，而这个未知的存储单元中可能存储一个有用的数据，这样有可能会破坏系统的正常工作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cb83efbf9a6a76c7b70ed33495d0409/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dae0efcb89579b5859ff2594b142f31/" rel="bookmark">
			Ubuntu: 搭建 NFS 服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. 测试环境3. NFS 服务器搭建3.1 安装 NFS 服务3.2 导出 NFS 共享目录3.3 重启 NFS 服务 4. 客户端连接 NFS 服务端5. VMware + Ubuntu6. Linux 内核 NFS 支持 1. 前言 限于作者能力水平，本文可能存在谬误，因此而给读者带来的损失，作者不做任何承诺。
2. 测试环境 服务端：Ubuntu 16.04.6 LTS 客户端：ARM 开发板 3. NFS 服务器搭建 3.1 安装 NFS 服务 sudo apt install nfs-kernel-server portmap 3.2 导出 NFS 共享目录 mkdir /home/XXX/nfs-shared 编辑配置文件到处目录 /home/XXX/nfs-shared ：
sudo vim /etc/exports 在文件 /etc/exports 添加如下内容：
/home/XXX/nfs-shared *(rw,sync,no_root_squash) 保存 /etc/exports 并退出 vim ，然后运行命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dae0efcb89579b5859ff2594b142f31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d10d1bae59e2058ae970cb9df74184a/" rel="bookmark">
			pyCM3安装过程的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装版本。
安装pyMC3==3.11.0， 一定要装theano-pymc，而不是theano
2.AttributeError: module 'numpy' has no attribute 'bool'.
将numpy降级到：pip install numpy==1.23.1
3.AttributeError: module 'numpy.distutils.__config__' has no attribute 'blas_opt_info'
将numpy降级到：pip install numpy==1.21.6
4.AttributeError: 'TheanoConfigParser' object has no attribute 'gcc__cxxflags'
删除卸载所有theano， pip install theano-pymc==1.1.0
5.ImportError: DLL load failed while importing mf6917bb35eaa79d4a20c20b9dc13c0435e656b1bdb67265fed3d06258ff43ef9: 找不到指定的模块。
降级theano-pymc，pip install theano-pymc==1.1.2
降级pymc3，pip install pymc3==3.11.2
6. RuntimeError: An attempt has been made to start a new process before the
current process has finished its bootstrapping phase.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d10d1bae59e2058ae970cb9df74184a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5033cc0b237ce6a9280a79c153fd6fd7/" rel="bookmark">
			input单选框和复选框改变自带的颜色和背景色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单选框：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box { width: 300px; height: 300px; margin: 100px auto; } input[type="radio"]::before { position: relative; content: ""; top: -1px; left: -1px; width: 17px; height: 17px; display: block; border-radius: 50%; background-color: #fff; border: 1px solid #6b4bff; z-index: 5; } input[type="radio"]:checked::after { position: relative; content: ""; bottom: 15px; left: 4px; width: 9px; height: 9px; display: block; border-radius: 50%; visibility: visible; background-color: #6b4bff; z-index: 6; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5033cc0b237ce6a9280a79c153fd6fd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/217282864e7f0580118544a9ce9852de/" rel="bookmark">
			SQL之CASE WHEN函数语句多条件下使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对CASE WHEN函数语句，实现简单CASE函数和CASE搜索函数两种格式。
同时配合 SUM以及COUNT方法的使用
1、CASE 的两种格式： 简单CASE函数和CASE搜索函数
**简单CASE函数** CASE 条件参数名称 WHEN 参数值1 THEN '显示值1' WHEN 参数值2 THEN '显示值2' ... ELSE '显示其他值' END **CASE搜索函数** CASE WHEN 条件参数名称 = '参数值1' THEN '显示值1' WHEN 条件参数名称 = '参数值2' THEN '显示值2' ... ELSE '显示其他值' END 两种格式示例：
状态：state
订单号：orderId
**简单CASE函数** SELECT orderId, CASE state WHEN 1 THEN '启动' WHEN 2 THEN '关闭' ELSE '未知状态' END AS statusName FROM t_table **CASE搜索函数** SELECT orderId, CASE WHEN state = '1' THEN '启动' WHEN state = '2' THEN '关闭' ELSE '未知状态' END AS stateName FROM t_table 这两种格式式，可以实现相同的功能。但是简单CASE函数和CASE搜索函数相比，功能方面会有些限制，比如写判断式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/217282864e7f0580118544a9ce9852de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04f76607c31a228025befc27431d4ec9/" rel="bookmark">
			Rethinking Local Perception in Lightweight Vision Transformer阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. 模型的特点2. 模型结构3. AttnConv4. 局部感知的不同方式 前言 来自清华大学的团队于2023年4月份提出的一篇论文，主要介绍了一种轻量级vision transformer架构——CloFormer，用以处理移动端的图像任务。
作者从频域编码的角度认为，现有的轻量级视觉Transformer中，大多数方法都只关注设计稀疏注意力，来有效地处理低频全局信息，而使用相对简单的方法处理高频局部信息。很少有方法尝试结合共享和上下文感知权重的优势来处理高频局部信息。
模型引入了AttnConv，将普通卷积运算中的全局共享权重和注意力操作中的上下文感知权重结合起来，相比于Transformer能够更好地捕捉高频的局部信息，相比于传统卷积操作能够更好地处理图像中不同位置的关系。
1. 模型的特点 CloFormer采用两分支的结构。
局部分支中，AttnConv利用深度可分离卷积（depth-wise Convolution），其具有共享权重来提取局部特征。然后，利用上下文感知权重来增强局部特征。与以前通过局部自注意力生成上下文感知权重的方法不同，AttnConv使用门控机制生成上下文感知权重，引入了更强的非线性。
全局分支中，使用传统的注意力操作帮助模型捕捉低频的全局信息，但对K和V进行了下采样来减少参数量。
最后使用一种简单的方法来融合局部分支和全局分支的输出。
总结一下本文的创新点：
AttnConv两分支结构效果不错 我感兴趣的点：
结合卷积，增强Transformer的局部感知能力，以适应伪装视觉感知任务中局部细节信息的感知。轻量级Transformer。 2. 模型结构 模型整体结构如下图所示。
CloFormer包含四个stage，每个stage由Clo Block和ConvFFN组成。
首先将输入图像通过conv stem得到token，stem由四个卷积层组成，每个卷积层的步距分别是2，2，1，1。然后通过四个stage提取分层特征。最后利用全局平均池化和全连接层来生成预测。
ConvFFN
用ConvFFN取代普通的FFN，将局部信息融入到FFN过程中。ConvFFN与普通的FFN之间的主要区别在于，ConvFFN在GeLU激活之后采用深度可分离卷积（Depth-wise Conv），这使ConvFFN能够聚合局部信息。由于使用了深度可分离卷积，ConvFFN可以直接下采样，而不需要引入PatchMerge模块。
CloFormer使用两种类型的ConvFFN。第一种是直接利用跳跃连接的In-Stage ConvFFN。另一种是两个stage的ConvFFN，在其跳跃连接中，分别利用DWConv和Full-Connected Layer对输入信息进行下采样和升维。
Clo block
Clo block由一个局部分支和一个全局分支组成。
如下图所示，在全局分支中，首先对K和V进行下采样，然后对Q、K、V执行传统注意力过程，以提取低频全局信息
X g l o b a l = A t t e n t i o n ( Q g , P o o l ( K g ) , P o o l ( V g ) ) X_{global}=Attention(Q_g,Pool(K_g),Pool(V_g)) Xglobal​=Attention(Qg​,Pool(Kg​),Pool(Vg​))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04f76607c31a228025befc27431d4ec9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39de883fc0303adcef04283d278af443/" rel="bookmark">
			虚拟化技术和模拟器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 phrase-20230509080235 虚拟化技术和模拟器
1 模拟器概念 链接: https://simple.wikipedia.org/wiki/Emulator
2 虚拟化概念 链接: https://simple.wikipedia.org/wiki/Virtualization
3 虚拟化技术和模拟器 虚拟化技术的重要体现是虚拟机，虚拟化层对硬件管理和抽象，虚拟机是二进制（cpu）直接执行模拟器的目标是让软件在不同平台兼容，是将翻译后二进制（cpu）执行模拟器也可以归类虚拟化技术这个范畴里 4 参考资料 Wikpedia 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3903f7e702b53accf0ba99d261e80fea/" rel="bookmark">
			git 拉取代码提示输入密码解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司用的gitlab，在项目拉取(git clone)和更新(git pull)的时候，每次都提示输入用户名密码，不胜其烦，解决方法如下：
# 首先 git config --global credential.helper store # 然后 git push origin your-branch 这时候会提示你输入用户名和密码，继续输入，下次再次执行git clone/push/pull的时候就不会在提示了。
原文地址： https://www.ngxcode.com/archives/134.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a5d280a810a848551b7261b3fc3ef92/" rel="bookmark">
			学习Vue第二天，VSCode再次运行项目报错：npm ERR! enoent ENOENT: no such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于运行Vue项目时报错：npm ERR! enoent ENOENT的解决办法 报错内容：
PS E:\Vue\_vue_base\_0507_vue_demo&gt; npm run dev npm ERR! code ENOENT npm ERR! syscall open npm ERR! path E:\Vue\_vue_base\_0507_vue_demo/package.json npm ERR! errno -4058 npm ERR! enoent ENOENT: no such file or directory, open 'E:\Vue\_vue_base\_0507_vue_demo\package.json' npm ERR! enoent This is related to npm not being able to find a file. npm ERR! enoent npm ERR! A complete log of this run can be found in: C:\Users\addyli\AppData\Local\npm-cache\_logs\2023-05-08T15_03_06_817Z-debug-0.log 解决办法 再终端上输入：cd 项目名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a5d280a810a848551b7261b3fc3ef92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c67f3a47992a85e2cd5e2f5c4eaef6/" rel="bookmark">
			PHP-时间格式化显示(刚刚、几分钟前、几小时前、昨天等)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://www.ngxcode.com/archives/279.html
相信很多小伙伴在平常上网的时候，经常会在一些网站和APP上看到文章日期处显示：刚刚、几分钟前、几小时前，昨天 12:00、前天 13:30 等时间展现方式，不得不说这样的展现方式粘在用户体验的角度上来看，还是非常舒适的。
相比直接显示生硬的年月日及时间点的，反而让人陷入了时间计算的一个盲区，对于微博、评论及新闻资讯类的文章列表，直接显示日期的方式展现体验显然有些格格不入了。
下面就让我们一起来看下时间格式化的实现方式吧：
&lt;?php /** * 文章时间格式化 * @param int|string $time 时间戳|日期 * @param bool $isYear 是否显示年份 * @return string */ function formatTime($time, $isYear = false) { if(!$time) { return ''; } if (!is_numeric($time)) { $time_new = strtotime($time); if (!$time_new) { return $time; } else { $time = $time_new; } } $now = time(); if(($dur = $now - $time) &lt;= 600) { $time = '刚刚'; } elseif (date('Ymd', $now) == date('Ymd', $time)) { if(($dur = $now - $time) &lt; 3600) { $temp = floor($dur/60); if($temp == 60) { $time = '1小时前'; } else { $time = $temp .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0c67f3a47992a85e2cd5e2f5c4eaef6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc8f9effa463b748729e8c392468b608/" rel="bookmark">
			函数小结1-（库函数与自定义函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
函数是什么？
C语言中函数的分类
库函数
什么是库函数呢？
为什么会有库函数呢？
C语言常用的库函数
使用库函数的方法（查询工具的使用）
自定义函数
自定义函与库函数的区别：
函数的组成：
函数是什么？ 维基百科中对函数的定义：子程序
在计算机科学中，子程序（英语：Subroutine,procedure,function,routine,method,subprogram,callable unit）,是一个大型程序中的某部分代码，由一个或多个语句块组成。它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。一般会输入参数并有返回值，提供对过程的封装和细节的隐藏。这些代码通常被集成为软件库 C语言中函数的分类 C语言函数分为两种：
1.库函数
2.自定义函数
库函数 什么是库函数呢？ 一般是指编译器提供的可在c源程序中调用的函数。可分为两类，一类是C语言标准规定的库函数，一类是编译器特定的库函数。由于版权原因，库函数的源代码一般是不可见的，但在头文件你可以看到它对外的接口。
为什么会有库函数呢？ 在开发的过程中每个程序员都可能用的到，为了支持可移植性和提高程序的效率，所以C语言的基础库中提供了一系列类似的库函数，方便程序员进行软件开发。
C语言常用的库函数 C语言常用的库函数有：
IO函数字符串操作函数内存操作函数时间/日期函数数学函数其他函数 *特别注意，使用库函数，必须包含#include对应的头文件
使用库函数的方法（查询工具的使用） 在知道了有库函数这个工具，那我们怎么使用库函数呢？在这里，我已经提前为函数知识点总结做了铺垫，请移步：http://t.csdn.cn/U5A7I
在这里面有3种查询工具以及使用方法。
自定义函数 介绍完库函数，接下来我要来介绍自定义函数了。为什么有了库函数，还要有自定义函数呢？这里我们要知道库函数不是万能的，并不能实现所有的功能。往往还是需要程序员来做点事情的，所以更为重要的是自定义函数。
自定义函与库函数的区别： 相同点：自定义函数和库函数一样，有函数名，返回值类型，函数参数类型。
不同点：不一样的是自定义函数都是我们自己设计的。这也给了程序员一个很大的发挥空间。
函数的组成： ret_type fun_name(para1,...) { statement;//语句项 } ret_type—返回参数类型，例如：int、char、float、double、long、long long、void...
如果这里没有规定函数返回类型，编译器默认返回int类型。例如：
fun_name() { statement; } fun_name—自定义函数名称。
这里有一些小提示：
1.自定义函数与库函数的命名空间是相互独立的，因此可以使用相同的名称。不过，为了避免混淆和错误使用，请尽量避免使用相同的名称。自定义函数的名称不能与关键字重名。
2.在编程语言中，关键字是预先定义的标识符，用于指示编译器或解释器执行特定操作或识别语言中的特定元素。因此，如果使用关键字作为自定义函数的名称，则可能导致语法错误或其他问题。
para1—函数参数。可以是void,int,char,short,整型数组，字符数组...,还可以是（v1,v2...）这样的组合...
函数传参时如果没有给函数传参，那么编译器默认是void类型。例如：
函数参数可以有或者没有，也可以是任意多个，但是建议函数参数不要太多，参数太多容易导致传参混乱，也尽量不要使用全局变量（公司一般这样做，避免混乱以及代码的维护。蓝桥杯等比赛无太多规范要求。）
statement—语句项。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/352748781c8eaa133051e4aa9e66e394/" rel="bookmark">
			qt5&#43;opencv4调用摄像头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mainwindow.h
#ifndef MAINWINDOW_H #define MAINWINDOW_H #include &lt;QMainWindow&gt; #include &lt;QLabel&gt; #include &lt;QImage&gt; class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); // 用于设置当前帧的函数 void setFrame(const QImage &amp;frame); private: // 显示图像的控件 QLabel *imageLabel; }; #endif // MAINWINDOW_H mainwindow.cpp
#include "mainwindow.h" MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { // 创建 QLabel 控件并添加到窗口中 imageLabel = new QLabel(this); imageLabel-&gt;setAlignment(Qt::AlignCenter); setCentralWidget(imageLabel); } void MainWindow::setFrame(const QImage &amp;frame) { // 将图像居中显示在我们的 QLabel 控件中 imageLabel-&gt;setPixmap(QPixmap::fromImage(frame).scaled(imageLabel-&gt;size(), Qt::KeepAspectRatio, Qt::FastTransformation)); } main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/352748781c8eaa133051e4aa9e66e394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b91232415a2a46e19b20c5d1b19c18a5/" rel="bookmark">
			如何使用Azure构建Web应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Azure是一个云平台，提供了各种云服务，包括Web应用程序的构建和部署。在本教程中，我们将介绍如何使用Azure构建Web应用程序。
1. 注册Azure账户
如果您还没有Azure账户，您需要先注册一个。您可以在 https://azure.microsoft.com/zh-cn/free/ 上注册一个免费的Azure账户。
2. 创建Web应用程序
登录Azure管理门户，点击“创建资源”按钮，选择“Web 应用程序”。
在“Web 应用程序”页面中，填写所需的信息，如应用程序名称、订阅、资源组、操作系统等。
选择“应用服务计划/位置”，创建一个新的应用服务计划。选择一个位置并确定大小。选择“确定”以完成设置。
在“Web 应用程序”页面中，选择“创建”以创建Web应用程序。
3. 部署Web应用程序
要将Web应用程序部署到Azure，您需要使用Visual Studio Code和Azure扩展。在Visual Studio Code中安装Azure扩展。
在Visual Studio Code中打开项目，并使用Azure扩展将其发布到Azure。
在Visual Studio Code的侧边栏中，打开“Azure”扩展，选择“Web 应用程序”选项卡，右键单击已创建的Web应用程序，并选择“部署到Web应用程序”。
在“配置 Web应用程序”页面中，填写所需的信息，如订阅、资源组、Web应用程序名称、操作系统等。
选择“部署”，等待几分钟，直到部署完成。
4. 查看Web应用程序
完成部署后，您可以在Azure管理门户中找到您的Web应用程序。在“Web 应用程序”页面中，您可以查看应用程序的URL，测试是否成功部署。
5. 配置自定义域名
如果您想要使用自定义域名来访问您的Web应用程序，您可以在Azure中配置自定义域名。
在Azure管理门户中打开已创建的Web应用程序，选择“自定义域名”选项卡，输入您的域名，并选择“验证”以验证您的域名。
一旦验证成功，您可以在您的域名注册商处将域名指向您的Web应用程序。
总结
在本教程中，我们介绍了如何使用Azure构建Web应用程序。首先，您需要注册Azure账户并创建一个Web应用程序。然后，使用Visual Studio Code和Azure扩展将Web应用程序发布到Azure。最后，您可以在Azure管理门户中查看和测试您的Web应用程序，或者配置自定义域名。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b18ca901416f6eb58d65f7cb13fdc9c/" rel="bookmark">
			FSPNet阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. 模型的特点2. Transformer 编码器3. 非局部token增强模块（NL-TEM）4. 特征收缩解码器（FSD） 前言 目前，一些工作已尝试使用Transformer解决伪装目标检测问题，并且性能良好。这些方法要么采用Transformer作为特征解码的网络组件，要么利用现成的vision Transformer作为特征编码器的backbone。通过对这些方法的深入分析，作者发现现有技术存在两个主要问题：
Transformer backbone的局部特征建模效果较差。全局语义和局部特征在伪装目标检测任务中都起着至关重要的作用。然而，大多数基于Transformer的方法缺乏局部区域内信息交换的局部性机制。特征聚合在解码器中的局限性。现有的解码器（图a-d）往往直接融合具有显著信息差异的特征（例如，具有丰富细节的低级特征和具有语义的高级特征），这往往会丢弃一些不明显但是有价值的线索，或者引入噪声，导致预测不准确。这对从微弱线索中识别伪装目标的任务来说是一个巨大打击。 为解决上述两个问题，作者提出了一种基于Transformer的特征收缩金字塔网络FSPNet。通过逐步缩小来获取伪装目标的局部性增强的全局表示，来达到分层解码相邻的transformer特征的目的，从而在编码器和解码器中挖掘和积累丰富的伪装目标局部线索和全局语义，实现准确、完整的伪装目标分割。
具体地说，为了补充Transformer编码器中的局部特征建模，作者提出了一个非局部token增强模块（NL-TEM），该模块利用非本地机制来交互相邻的相似token，并探索token内基于图的高层关系来增强局部表示。
此外，作者还设计了一个具有相邻交互模块（AIMs）的特征收缩编码器（FSD），通过一个逐层收缩金字塔结构将相邻的Transformer特征成对地聚集起来，以尽可能多地积累微小但有效的细节和语义。
总结贡献如下：
提出非局部token增强模块（NL-TEM），用于token之间和token内部的特征交互和探索，以补偿Transformer的局部建模。利用相邻交互模块（AIM）设计了一种特征收缩解码器（FSD），通过逐步收缩来更好的聚合相邻Transformer特征之间的伪装目标线索，实现伪装目标检测实现了优越的性能 1. 模型的特点 模型整体结构如下所示。
2. Transformer 编码器 a）序列化
受Swin-Transformer的启发，给定图像 I ∈ R C × H × W I \in \mathbb R^{C \times H \times W} I∈RC×H×W，首先将其分割成一系列不重叠的图像patch，patch大小为（s,s），其中C、H、W分别表示图片的通道数、高度和宽度，且实验中s=16。
然后将图像patch投影成patch embedding的一维序列 T 0 ∈ R l × d T^0 \in \mathbb R^{l \times d} T0∈Rl×d，其中 l = H W s 2 l=\frac{HW}{s^2} l=s2HW​为序列长度， d = s 2 ⋅ C d=s^2 \cdot C d=s2⋅C是embedding维数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b18ca901416f6eb58d65f7cb13fdc9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d75204a0b167a716cb2bcbdec82430/" rel="bookmark">
			BOOST库的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 参加工作的时候需要用到boost库来处理图形，因此想写一下某些函数的使用方法，于人于己都方便。但是由于个人能力有限，所以有一些地方理解的较为片面还清多多谅解。如果能对你有所帮助，那就再好不过了。（注：英文目录后没带中文解释的都是还未探索的）
boost库的使用方法 前言Access Functions（访问方法）get（获得点的坐标）set（设置坐标）设置点的坐标设置线段设置矩形 exterior_ringinterior_rings Adapted modelsC arrayC++11 Array ContainerBoost.ArrayBoost.FusionBoost.TupleBoost.PolygonBoost.RangeMacro's for adaption Algorithms（算法部分）area（面积计算）assignappendazimuth（方位角计算）buffercentroid（质心计算）clear（清除）closest_pointsconvertconvex_hull（最小凸多边形）correct（纠正图形）covered_by（覆盖检测）crosses（交叉检测）densify（增加点的密度）difference（计算两个几何图形的差）discrete_frechet_distancediscrete_hausdorff_distancedisjoint（检查两个几何图形是否不相交）distance（计算两个几何图形之间的距离）envelopeequals（相等判断）expandfor_eachintersection（计算两个几何图形的交点）intersectsis_emptyis_simpleis_validlengthline_interpolate（计算直线上固定距离的点）makenum_geometriesnum_interior_ringsnum_pointsnum_segmentsoverlaps（检查两个几何图形是否重叠）perimeter（求周长）relaterelationreverse（改变几何体的顺逆时针）simplifysym_differencetouches（检查图形是否存在接触点）touches (检测是否自交)touches (检查两个几何图形是否至少有一个接触点) transformunion_（叠加两个几何图形）unique（计算几何图形的最小集合）within（检查第一个几何体是否完全在第二个几何体内部） Arithmetic（计算部分）add_pointadd_valueassign_pointassign_valuecross_productcross_productdivide_pointdivide_valuedot_productmultiply_pointmultiply_valuesubtract_pointsubtract_value Concepts（概念部分）Point Concept（点的概念）Linestring ConceptPolygon ConceptMultiPoint ConceptMultiLinestring ConceptMultiPolygon ConceptBox ConceptRing ConceptSegment Concept Constantsmin_cornermax_corner Coordinate Systemscs::cartesiancs::sphericalcs::spherical_equatorialcs::geographic Core Metafunctions（核心元函数）closurecoordinate_systemcoordinate_typecs_tagdegreedimensioninterior_typepoint_orderpoint_typeradianring_typetagtag_cast DE-9IMEnumerationsExceptionsIO (input/output)IteratorsModelsSpatial IndexesSRSStrategiesstrategy::transform::rotate_transformer（直角坐标系下的旋转） Views Access Functions（访问方法） get（获得点的坐标） 下面为我经常使用的点坐标的获得方法 #include &lt;iostream&gt; #include &lt;boost/geometry.hpp&gt; #include &lt;boost/geometry/geometries/point_xy.hpp&gt; namespace bg = boost::geometry; int main() { bg::model::d2::point_xy&lt;double&gt; point(1, 2);//初始化pointd的坐标为(1.0,2.0) double x = bg::get&lt;0&gt;(point); double y = bg::get&lt;1&gt;(point); std::cout &lt;&lt; "x=" &lt;&lt; x &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26d75204a0b167a716cb2bcbdec82430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b543d3d3f3e51d07627398ffcc17bdf4/" rel="bookmark">
			Python指定路径式——自动删除文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 该项目为工作中的一点小插曲：
由于设备使用相机拍照所保留的照片太多太多，时间长了电脑的硬盘（2T）都不够存图片，可这些检测的图片据说还得保留个七年，所以折中想了个法子，就是将图片文件夹中OK和NG的分开，并且只保留NG的，OK的全删除，这样便省下许多空间存储图片。
遇到的问题难点：
1.从csv表格中筛选出机检为true（OK）的SN；
2.将筛选出的SN保存到指定路径下的另一个表格中；
3.找到对应的（需要删除的OKSN）图片的日期路径；
4.删除文件夹；
是啊，看起来没啥太难的
但是做起来后又发现许多小问题，比如：
先假设是从“2021年11月11日.csv”这个表格中筛选出的SN
然后假设从类似以下图片这种路径寻找文件夹
问题描述： 1.如何指定获取指定的列上的内容？
2.当指定列上的内容出现空值或没有内容时怎么处理才不会报错？
3.如何设定存放筛选后的表格名为“2021年11月11日筛选记录.csv”？
4.需删除文件夹时，如何找到“图片”目录下的“2021年11月11日”的文件夹？
5.找到指定的SN文件夹后，应该如何先遍历删除指定SN文件夹目录下的子文件？
逻辑思路 以下为逻辑思路：
程序代码 以下为程序代码：
import os #引入操作系统模块 import shutil #用于复制和粘贴文件 import csv #用于生成CSV表格 Image_path = 'E:\\图片' History_path2 = 'E:\\历史记录' for root_1, dirs_1, files_1 in os.walk(History_path2): print("先输出历史记录的子目录\n") break for root_2, dirs_2, files_2 in os.walk(Image_path): print("先输出图片的子目录\n") break def reader_SN( Save_the_SN): #Save_the_SN 是指要打开的表格名，不能传入一个路径 OK_SN_numder = 0 column_list = [] with open(Save_the_SN, encoding="utf-8") as f: #难道只能打开一个表格，而不能打开一个路径下的表格？？？ reader = csv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b543d3d3f3e51d07627398ffcc17bdf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b73d6f6ed6907fc75017194965bd2c7b/" rel="bookmark">
			Python语音增强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 音频时域波形具有以下特征：音调，响度，质量。我们在进行数据增强时，最好只做一些小改动，使得增强数据和源数据存在较小差异即可，切记不能改变原有数据的结构，不然将产生“脏数据”，通过对音频数据进行数据增强，能有助于我们的模型避免过度拟合并变得更加通用。
经过实验发现对声波的以下改变是有用的：Noise addition(增加噪音)、Add reverb(增加混响)、Time shifting(时移)、Pitch shifting(改变音调)和Time stretching(时间拉伸)。
本文需要使用的python库：
matplotlib：绘制图像librosa：音频数据处理numpy：矩阵数据处理 常见的失真有：
加性声学噪声：加性噪声与期望信号不相干，平稳加性噪声(背景环境声音、嗡嗡声、功放噪音)，非平稳加性噪声(媒体干扰、非期望语音干扰和一些电子干扰)声学混响：多径反射引起的叠加效应(与期望信号相关)卷积信道效应：导致不均匀或带宽限制响应，为了去除信道脉冲响应，做信道均衡时对通信信道没有有效建模非线性失真：信号输入时不适当的增益，常出现与幅度限制、麦克风功放等加性宽带电子噪声电器干扰编码失真：比如压缩编码录音仪器引起的失真：麦克风频率响应不足 先画出原始语音数据的语谱图和波形图:
import librosa import numpy as np import matplotlib.pyplot as plt plt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签 plt.rcParams['axes.unicode_minus'] = False # 用来正常显示符号 fs = 16000 wav_data, _ = librosa.load("/home/gxli/lgx/Data/gather_crop/clean1/2148_farend.wav", sr=fs, mono=True) # ########### 画图 plt.subplot(2, 2, 1) plt.title("语谱图", fontsize=15) plt.specgram(wav_data, Fs=16000, scale_by_freq=True, sides='default', cmap="jet") plt.xlabel('秒/s', fontsize=15) plt.ylabel('频率/Hz', fontsize=15) plt.subplot(2, 2, 2) plt.title("波形图", fontsize=15) time = np.arange(0, len(wav_data)) * (1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b73d6f6ed6907fc75017194965bd2c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f52a05ccf2bb1ef2aebd7489b753e010/" rel="bookmark">
			在Ubuntu安装软件时，显示“E:无法定位软件包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在安装can-utils时，使用了命令sudo apt install can-utils，提示“E:无法定位软件包…"，也不明白为啥报这个错，命名我的是linux系统呀，哪来的E盘
经过各种尝试，从网上找来的解决方法
cd /etc/apt #自己备份一下sources.list文件，防止自己改坏了 sudo vi sources.list 在文件最后添加deb http://archive.ubuntu.com/ubuntu/ trusty main universe restricted multiverse sudo apt-get update 执行完上面的操作后，再执行sudo apt install can-utils，一切就回复正常了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec6b02140a279046e1e895538eff2996/" rel="bookmark">
			用vue实现增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、some(回调函数（item，index）) ⽅法测试数组中是不是⾄少有1个元素通过了被提供的函数测 试。它返回的是⼀个Boolean类型的值
2、find() ⽅法返回数组中满⾜提供的测试函数的第⼀个元素的值。否则返回 undefined。
3、 splice() ⽅法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被 修改的内容。此⽅法会改变原数组。
4、 includes() ⽅法⽤于判断⼀个字符串是否包含在另⼀个字符串中，根据情况返回 true 或 false。
5、 filter() ⽅法创建⼀个新数组, 其包含通过所提供函数实现的测试的所有元素。
6、indexOf()⽅法返回在数组中可以找到⼀个给定元素的第⼀个索引，如果不存在，则返回-1。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 引入所需的库--&gt; &lt;script src="../vue-2.4.0.js"&gt;&lt;/script&gt; &lt;script src="../jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script src="../bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="../bootstrap/css/bootstrap.min.css"&gt; &lt;style&gt; .gg{ padding: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!-- 版心 --&gt; &lt;div class="container"&gt; &lt;div class="modal " id="modal-id"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec6b02140a279046e1e895538eff2996/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72562ef2f1547b15242f2afac62c8c6f/" rel="bookmark">
			在conda环境下安装cudnn和cudatoolkit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 您可以使用以下命令在 conda 环境中安装 CUDA Toolkit 11.2.1：
conda install cudatoolkit=11.2.1 请注意，您需要确保您的计算机具有支持 CUDA 的 NVIDIA GPU，并且已安装了相应的驱动程序。此外，您需要使用与 CUDA 版本兼容的 cuDNN 版本。
cuDNN 通常不是通过 conda 安装的。官方推荐的安装方法是从 NVIDIA 官网下载 cuDNN 的安装包，并按照说明进行安装。
尽管如此，您仍然可以在 conda-forge 频道中找到 cuDNN 的第三方包。您可以使用以下命令尝试安装：
conda install -c conda-forge cudnn 请注意，这些第三方包可能不受 NVIDIA 官方支持，因此在使用它们时可能会遇到一些问题。
如果您想安装 cuDNN 8.1.0，可以使用以下命令：
conda install -c conda-forge cudnn=8.1.0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5088a5f031460475aa0cea74c1bdb62/" rel="bookmark">
			HTTP协议详解 简单易懂超详细整理版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议，是万维网通信的基础。
那么什么是超文本呢？
超文本指的是HTML，css，JavaScript和图片等，HTTP的出现是为了接收和发布HTML页面，经过不断的发展也可以用于接收一些音频，视频，文件等内容。
包含内容 请求与响应模式、报文、端口号、URL、特性、状态码（大分类和小分类）、请求头字段（user-agent、content-type、gzip、encoding)
请求响应模式 HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准。通常，由HTTP客户端发起一个请求（浏览器、爬虫等），创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息。
请求响应报文 请求方法、URL、协议版本、connection、content-Type、都会在后面讲到。其中，最后一行内容实体的name=那一串是我们告诉服务端要请求的数据，Content-Length则是它的长度（正好16字符）。
除了图上所示的，协议还有类似Cookie、User-Agent:的内容。其中，user-agent代表请问的客户端信息，可以根据其内容，服务端区分手机、PC端，以优化显示效果和反爬虫机制（如果我们做爬虫，可能要注意这个，防止被反爬虫机制屏蔽）等。
若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;
响应报文 HTTP 协议的 8 种请求类型介绍 HTTP 协议中共定义了八种方法或者叫“动作”来表明对 Request-URI 指定的资源的不同操作方式，具体介绍如下：
OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*'的请求来测试服务器的功能性。HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。GET：向特定的资源发出请求。POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。PUT：向指定资源位置上传其最新内容。DELETE：请求服务器删除 Request-URI 所标识的资源。TRACE：回显服务器收到的请求，主要用于测试或诊断。CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 get 和 post，其他请求方式也都可以通过这两种方式间接的来实现。
状态码分类 常见的HTTP状态码： 200 - 请求成功
301 - 资源（网页等）被永久转移到其它URL
302-临时移动 以后客户端应该继续使用原URL
305-必须使用代理访问
400-语法错误 服务器无法理解
401-要求身份认证
403-拒绝 服务器端理解需求 但是拒绝执行
404 - 请求的资源（网页等）不存在
405-客户端请求中的方法被禁止
500 - 内部服务器错误
MIME Type与Content-type 简单来说 content-type是类型key，MIME TYPE是那些标准化的类型value
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5088a5f031460475aa0cea74c1bdb62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73391217c3f394a3904e0dbfec0144d8/" rel="bookmark">
			SSM框架搭建（IDEA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、新建一个Maven项目 打开IDEA软件，File-&gt;New-&gt;Project -&gt;Maven-&gt;Create from archetype
在src下面的main文件夹上右击，New-&gt;Directory，新建一个Java目录和一个resources，test目录
然后在Java目录上右键，Mark Directory as -&gt; Sources Root
接着在resources目录上右键，Mark Directory as -&gt; Resources Root
接着在test目录上右键，Mark Directory as -&gt; Test Sources Root
然后就是下面这样
创建controller、entity、mapper、service四个package
二、配置文件 打开该项目的pom.xml文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;health_perservation&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;health_perservation Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;spring.version&gt;5.2.5.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.5.1&lt;/mybatis.version&gt; &lt;mybatis.spring.version&gt;1.3.1&lt;/mybatis.spring.version&gt; &lt;mybatis.paginator.version&gt;1.2.15&lt;/mybatis.paginator.version&gt; &lt;mysql.version&gt;8.0.17&lt;/mysql.version&gt; &lt;slf4j.version&gt;1.6.4&lt;/slf4j.version&gt; &lt;druid.version&gt;1.1.12&lt;/druid.version&gt; &lt;pagehelper.version&gt;5.1.2&lt;/pagehelper.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;servlet-api.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73391217c3f394a3904e0dbfec0144d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dd05c049a987a4395321cbe2004c4b3/" rel="bookmark">
			洛谷入门级p1425小鱼的有用时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小鱼的游泳时间
题目描述
伦敦奥运会要到了，小鱼在拼命练习游泳准备参加游泳比赛，可怜的小鱼并不知道鱼类是不能参加人类的奥运会的。
这一天，小鱼给自己的游泳时间做了精确的计时（本题中的计时都按 24 小时制计算），它发现自己从 a 时 b 分一直游泳到当天的 c 时 d 分，请你帮小鱼计算一下，它这天一共游了多少时间呢？
小鱼游的好辛苦呀，你可不要算错了哦。
输入格式
一行内输入四个整数，以空格隔开，分别表示题目中的 a, b, c, d。
输出格式
一行内输出两个整数 e 和 f，用空格间隔，依次表示小鱼这天一共游了多少小时多少分钟。其中表示分钟的整数 f 应该小于 60。
样例 #1
样例输入 #1
12 50 19 10
样例输出 #1
6 20
代码：#include &lt;stdio.h&gt;
int main(){
int a;//小鱼开始游泳的小时整点 int b;//小鱼开始游泳的分钟整点
int c;//小鱼结束游泳的小时整点 int d;//小鱼结束游泳的小时整点 int e;//小鱼最终游泳的小时 int f;//小鱼最终游泳的分钟 scanf("%d %d %d %d",&amp;a,&amp;b,&amp;c,&amp;d);
int x;//x表示小鱼游泳的总时常 x = ((c*60)+d) - ((a*60)+b);
e = x / 60;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dd05c049a987a4395321cbe2004c4b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/992abeecdf23e410e39c2fb0c2d083fd/" rel="bookmark">
			基于mybatis进行批量更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis是一种基于Java的持久层框架，提供了一种优雅的方式来进行数据库操作。对于批量更新数据操作，MyBatis 提供了两种方法：使用 foreach 标签和 batch 执行器。
使用 foreach 标签 使用 foreach 标签时，需要编写 SQL 语句，使用 ${} 或 #{} 占位符传递参数。示例：
&lt;update id="batchUpdate" parameterType="java.util.List"&gt; &lt;foreach collection="list" item="item" index="index" separator=";"&gt; UPDATE user SET name=#{item.name}, age=#{item.age} WHERE id=#{item.id} &lt;/foreach&gt; &lt;/update&gt; id：SQL 语句的标识符。parameterType：传递给 SQL 语句的参数类型。collection：传递给 SQL 语句的集合。item：集合中的元素对象。index：集合元素的下标。separator：SQL 语句的分隔符。 使用 batch 执行器 MyBatis 还提供了一个特殊的执行器 batch，它可以执行批量更新操作。示例：
SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH); try { Mapper mapper = sqlSession.getMapper(Mapper.class); for (User user : userList) { mapper.updateUser(user); } sqlSession.commit(); } finally { sqlSession.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/992abeecdf23e410e39c2fb0c2d083fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36d67efeb535015f8c14ea01ecdcf04/" rel="bookmark">
			pycharm远程调试服务器时出现errno2--No such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、先跟着这个教程来
https://zhuanlan.zhihu.com/p/259683970
2、依旧出现errno2的话关注以下两部分
一、看Tools——development——configuration
特别：此处的Mappings路径，需要和下述路径一致
二、看File——Settings——Project Interpreter
特别：此处的Mappings路径，需要和上面提及的路径一致
至此便能成功运行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6242049f541a034df47c42a490c986bb/" rel="bookmark">
			uniapp使用uview的垂直分类，双向联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp使用uview的垂直分类 &lt;template&gt; &lt;view class="u-wrap"&gt; &lt;view class="u-menu-wrap"&gt; &lt;scroll-view scroll-y scroll-with-animation class="u-tab-view menu-scroll-view" :scroll-top="scrollTop" :scroll-into-view="itemId"&gt; &lt;view v-for="(item, index) in tabbar" :key="index" class="u-tab-item" :class="[current == index ? 'u-tab-item-active' : '']" @tap.stop="swichMenu(index)"&gt; &lt;text class="u-line-1"&gt;{{ item.name }}&lt;/text&gt; &lt;/view&gt; &lt;/scroll-view&gt; &lt;scroll-view :scroll-top="scrollRightTop" scroll-y scroll-with-animation class="right-box" @scroll="rightScroll"&gt; &lt;view class="page-view"&gt; &lt;view class="class-item" :id="'item' + index" v-for="(item, index) in tabbar" :key="index"&gt; &lt;view class="item-title"&gt; &lt;text&gt;{{ item.name }}&lt;/text&gt; &lt;/view&gt; &lt;view class="item-container"&gt; &lt;view class="thumb-box" v-for="(item1, index1) in item.children" :key="index1"&gt; &lt;u-image class="item-menu-image" :src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6242049f541a034df47c42a490c986bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/106150838b3634471b46df3fc0a65d77/" rel="bookmark">
			Android --- 一篇带你搞懂CTS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		·什么是CTS
CTS全称Compatibility Test Suite兼容性测试工具，为了保证开发的应用在所有兼容Android的设备上正常运行，并保证一致的用户体验，Google制定了CTS来确保设备运行的Android系统全面兼容Android规范，Google也提供了一份兼容性标准文档（Compatibility Definition Document,CDD）。当电子产品开发现来，并定制了自己的Android系统后，必须要通过最新的CTS检测，以保证标准的android application能运行在该平台上。通过了CTS验证，需要将测试报告提交给Google，以取得android market的认证。CTS是一款 通过命令行操作的工具。目前CTS没有提供windows版本，只能在Linux下测试。
·CTS工具下载地址
不同android版本的工具下载地址：
https://source.android.google.cn/docs/compatibility/cts/downloads?hl=zh-cn
如果要进行media压力测试，下载CTS 媒体文件后，在终端执行以下命令，将media文件copy到设备里。
./copy_images.sh ./copy_media.sh ·CTS怎么进行测试
①配置设备
连接 WiFi（有的测试需要v6网络） Display-&gt;Sleep-&gt;30min（设置休眠时间为30分钟） Security &amp; location-&gt;Screen lock-&gt;None（设置屏幕锁为无） System-&gt;About phone-&gt;Build number（打开开发者模式） 进入开发者模式，打开Stay awake，打开USB调试 开启location 语言设置为English-US（必须是英文，其他语言不行） 设置完成，回到主页，清空后台应用 ②使用测试工具
在/android-cts-10_r15-linux_x86-arm/android-cts/tools路径下的终端执行（注意这个测试工具所在的路径不能有中文！！！）：
整包测（测试的时间比较长，大约需要四天左右）：
run cts 按模块测：
run cts -m module名 单条case测试：
run cts -m module名 -t case名 ·CTS结果怎么查看
①在测试终端就可以查看测试结果
②用浏览器打开/android-cts-10_r15-linux_x86-arm/android-cts/results/2023.04.26_15.55.26/test_result.html
其中/2023.04.26_15.55.26/是每次测试的时间，根据测试时间可以打开某一次的测试结果
·如何查看测试的log
打开/android-cts-10_r15-linux_x86-arm/android-cts/logs/2023.04.26_14.26.07/inv_6131858263139540011/
同理其中/2023.04.26_15.55.26/是每次测试的时间，根据测试时间可以打开某一次的测试结果
·CTS的修改技巧
①首先先使用设备进行一遍测试，有的错误可能使用最新版本进行测试即可pass
②根据case名在项目的代码中搜索此条case的测试内容
举例：测试的命令：run cts -m CtsWindowManagerDeviceTestCases -t android.server.wm.PinnedStackTests#testPinnedStackWithDockedStack
那就在项目中的代码搜索testPinnedStackWithDockedStack（PinnedStackTests类中）
注意：由于使用的是谷歌官方的工具，本地项目中CTS的代码会有差异，只能作为参考来看，其中的报错行数不能完全相同。
③那由于存在以上问题，在修改的过程想要加一些log输出一些信息来辅助修改怎么办呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/106150838b3634471b46df3fc0a65d77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e88bb33d9c9ae06e707010a988aa09f/" rel="bookmark">
			定时清理文件脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定时清理文件 编写一个bat脚本。新建一个文本文档（txt文件），在里面输入@echo offdel /f /s /q E:\temp\*.*，E代表E盘，temp是E盘下的需要清理的文件夹，运行脚本后，就是清理E:\temp文件夹下的文件。 @echo off del /f /s /q E:\temp\*.* 将文本文档保存后，并将后缀名txt改成bat，可以双击测试下，如果指定路径（E:\temp）下的文件全部删除了说明脚本没问题。
设置定时任务自动清理文件，依次打开“控制面板——系统和安全——计划任务”。
选择“任务计划程序库——创建计划程序库”。
输入基本任务名称，点击下一页。
设置触发时间，点击下一页。
设置触发器开始时间，点击下一页。
选择启动程序，点击下一页。
输入bat脚本文件的路径，点击下一页。
完成创建。
如果每天执行一次间隔时间太长了，继续往下看。 二、设置间隔时间 找到创建的计划程序库，右击选择属性。
选择触发器，编辑触发器。
选中重复任务间隔，其中可设置5分钟、10分钟、15分钟、30分钟、1小时，持续时间选择无期限，确定即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b98a653dcaae402f2b89cc2a3f2dfd0/" rel="bookmark">
			cryptography库编写DSA算法的签名与验签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cryptography库编写DSA算法的签名与验签 库版本
cryptography==2.9 # -*- coding:utf-8 -*- import base64 import os from cryptography import x509 from cryptography.exceptions import InvalidSignature from cryptography.hazmat.backends import default_backend from cryptography.hazmat.primitives import hashes, serialization from cryptography.hazmat.primitives.serialization import pkcs12 class DSAUtil(object): """ 主要用于读取私钥证书为pfx格式与公钥证书为cer格式， """ def __init__(self, private_key_path, public_key_path, pwd=''): self._private_key_content = open(private_key_path, 'rb').read() if private_key_path else b"" self._public_key_path = open(public_key_path, 'rb').read() if public_key_path else b"" self.pwd = pwd def sign(self, unsigned_string): # 获取pem证书私钥 key, cert, _ = pkcs12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b98a653dcaae402f2b89cc2a3f2dfd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eb51f68bf6c0edf01dc9cbc68609742/" rel="bookmark">
			【信息系统项目管理师】概要和框架-2023年5月7日总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还有20天考试，记录下这二十天的学习内容。
今天之前4月4日到4月13日五天修炼看了一半，看到了项目风险管理，云里雾里看了个大概。
听野人老师的课从第一章跟着到了第十章，听一会儿就走神，听一会儿就走神。
改变思路，不看视频了，只看讲义，不懂再看视频。
因为3月份出了第四版，所以都以第四版为主，虽然同时买了一堆书，但剩余时间不多，以野人老师讲义一本通为主，包含综合知识一本通，计算案例背诵一本通，还有论文一本通，前几天刚打印，那时论文一本通还没出，打印的论文讲义，今天看群里有了，明天整理下论文一本通和真题相关考前冲刺材料一起打印下。
如果照着看视频思路基本就不用考了，铁定陈。
于是改思路，今天先梳理了下思维导图，也没画，就是把第四版教材目录跟着抄了一遍，做了简单调整，大体对信息系统项目管理师有了个框架理解，不至于像以前摸不着头脑，看完了，听完了啥也不知道。
以目前理解，考试内容大致分为以下几块，
第一部分，1-5章，IT计算机基础知识，宏观的有第一章信息化发展，第二张信息技术发展，讲了大环境新技术及国家战略；技术方面讲了信息系统治理，管理和工程；这部分基本就是上午选择题综合知识考
第二部分，6-21章，项目管理，包括项目立项到项目结束的各个环节，各种细节，作为一名小项目的项目经理，好多都是与自己及项目有关，虽然不一定管理那么细，但都有，麻雀虽小五脏俱全。其中的中带你就是项目管理的10大知识领域，每个知识领域有多个过程，每个过程有自己的ITO,也就是I（输入），T（工具和技术），O（输出），个人观点就是通过基于输入内容用什么工具和技术，最终输出什么成果，比如项目整合管理的制定项目章程，用立项管理文件等内容输入，经过专家判断、会议等多种方式，最终输出项目章程；
第三部分，其他，组织通用管理、治理，法律法规规范，英语；法律法规到了我的领域了，组织通用是啥还不知道，了解了后面再讲；
上午一门，综合知识，单选题，75分，45分通过；
下午两门，案例和论文，
案例包含问答和计算，老师说计算都对了基本就过了，同样45/75过；
论文，基本锁定10大，2000字以上，45分过。
今天的总结就是梳理完整体的逻辑框架，大框架完成，看完第一章，第六章，第七章的综合知识教材。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e3fbb6690e3476076b1c06aa5a9ca6b/" rel="bookmark">
			路径规划与轨迹规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		轨迹规划是基于路径规划的结果进行的，两者是相互关联的但又不完全相同。
在机器人运动控制中，路径规划通常指的是寻找移动物体从一个起始姿态到达目标姿态所需经过的离散路点的路径。它的目的是确定一系列离散点的线性起点和终点，而不需要考虑如何让机器人实际上运动。
轨迹规划则是指在已经规划好的路径基础上，通过调整速度、加速度、角速度和角加速度等参数产生平滑的轨迹，使得机器人能够顺利地按照规划好的路径运动。轨迹规划与路径规划不同，它需要确定连续时间段内的移动姿态和动力学参数，并且必须考虑机器人的动力学限制和运动状态的连续性。
路径规划和轨迹规划是互相依存的，二者也有一定的区别。路径规划通常应用于离散运动系统中，而轨迹规划通常应用于连续运动系统中。在进行机器人运动控制时，需要先通过路径规划得到一条可行路径，然后再通过轨迹规划将其转换为精确的运动轨迹，并交由机器人系统控制器进行执行。
路径规划和轨迹规划都有多种算法，下面列举了常见的一些：
路径规划算法：最短路径算法、A算法、Dijkstra算法、RRT（随机快速探索树）算法、PRM（概率路线映射）算法、FMT（快速优化最短路径搜索）算法等。
轨迹规划算法：样条插值法、小波变换法、多项式拟合法、优化控制法等。其中，优化控制法包括经典方法如PID控制、LQR控制以及逆向动力学等模型预测控制。
这些算法各具优缺点，在不同的应用场景下选择不同的算法能够有效地提高路径和轨迹规划的效率和精度。同时，也需要根据实际情况进行适当的修改或组合，以满足特定的需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ec8b77187099f109aebe6440c0f727/" rel="bookmark">
			大数据技术之HBase（二）HBase原理简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、HBase定义 1.1 HBase定义 HBase 是一种分布式、可扩展、支持海量数据存储的 NoSQL 数据库非结构化数据存储的数据库，基于列的模式存储。利用Hadoop HDFS作为其文件存储系统，写入性能很强，读取性能较差。利用Hadoop MapReduce来处理HBase中的海量数据，利用Zookeeper作为协同服务。
关系型数据库存储数据是以表格的形式存储，非关系型数据库是以&lt;k,v&gt;进行存储。通过&lt;k,v&gt;进行存储，当在用key读取value的时候，效率更高，速度更快，使用起来更灵活。
划重点： HBase是基于列存储的，主要用来存储非结构化和半结构化的松散数据，适合大数据的实时查询； 利用 HDFS作为其文件存储系统； 利用 MapReduce来处理 HBase中的海量数据； 利用 Zookeeper作为其分布式协同服务； HDFS只支持追加写，不支持随机写，不太适合做大量的随机读应用
HBASE却特别适合随机的读写。
1.2 HBase数据模型 用户将数据行存储在带标签的表中，数据行具有可排序的键和任意数量的列，该表存储稀疏。
HBase关于数据的关键在于：稀疏、分布式、多维、排序的映射map。其中映射map指代非关系型数据库的key-value结构。
释义： 稀疏：对比关系型数据库，关系型数据库是一个表格，表格在底层存储的时候要求比较高，每一行每一列都需要预留对应的存储空间。当数据量比较大、列比较多时，存在大量的空值，使用关系型数据库就会造成存储空间的浪费。 使用非关系型数据库就会节省对应的空间。如果某一行某一列为空，可以不存数据，在空间的使用上就会比较节省。 分布式：海量数据保存在多台机器上。 持久化：将内存中的对象存储在数据库中，或者存储在磁盘文件中。 排序：无序的数据当想要查找时，需要遍历整张表。排序的数据可以按照特定算法进行读取。如二分法查找。 映射：由行键、列键、时间戳作为key，映射中的每个值都是一个未解释（经过序列化，无法用UTF-8编码）的字节数组。 1.2.1 基础模型 Name Space
命名空间，类似于关系型数据库的 DatabBase 概念，每个命名空间下有多个表。HBase 有两个自带的命名空间，分别是 hbase 和 default，hbase 中存放的是 HBase 内置的表， default 表是用户默认使用的命名空间。
Table
类似于关系型数据库的表概念。不同的是，HBase 定义表时只需要声明列族即可，不需要声明具体的列。这意味着，往 HBase 写入数据时，字段可以动态、按需指定。因此，和关系型数据库相比，HBase 能够轻松应对字段变更的场景。
Row
HBase 表中的每行数据都由一个 RowKey 和多个 Column(列)组成，数据是按照 RowKey 的字典顺序存储的，并且查询数据时只能根据 RowKey 进行检索，所以 RowKey 的设计十分重要。
HBase框架不能写SQL，只能根据RowKey去读取数据。 Column
HBase 中的每个列都由 Column Family(列族)和 Column Qualifier(列限定符)进行限定，例如 info:name，info:age。建表时，只需指明列族，而列限定符无需预先定义 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64ec8b77187099f109aebe6440c0f727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f9425386ed76a5ae4dcd5a8ee23456/" rel="bookmark">
			pytorch scatter方法 在后向传播中遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
r=x_windows.scatter(dim=1,index=topk_index,src=attn_windows) topk_index的shape为[2, 32, 1, 1, 1]attn_windows的shape为[2, 32, 7, 7, 96]x_windows的shape为[2, 64, 7, 7, 96] 该方法的作用是将attn_windows放回原来的位置中。
模型训练过程中，前向传播过程不会报错，但是反向传播过程会报下面错误
RuntimeError: Function ScatterBackward0 returned an invalid gradient at index 1 - got [2, 32, 1, 1, 1] but expected shape compatible with [2, 32, 7, 7, 96] 解决方法：
将topk_index的shape变成和attn_windows一样。
思考 其实这种问题解决起来并不难，但是在寻找报错代码段时花费了很长时间，因为错误出现在反向传播过程中，错误位置提示并不多。
其实关键点在ScatterBackward0,如果了解反向传播的函数很容易想到问题出现在scatter方法上。
ScatterBackward0 是 PyTorch 中的一个函数，用于在反向传播时计算张量的梯度。具体来说，它是 PyTorch 中的 Scatter 操作的反向传播实现之一。
类似的还有：AddBackward0 是 PyTorch 中用于实现张量加法操作的反向传播函数之一。
在 PyTorch 中，每个张量操作都有对应的反向传播函数，用于计算该操作对输入张量的导数，并将导数传递回计算图中的其他节点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce21e3e723b992d80a49f453f9d71e17/" rel="bookmark">
			朴素贝叶斯中文分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		朴素贝叶斯中文分类 朴素贝叶斯分类算法是基于概率的分类算法，实现思路相当简单，但是在某些情况下分类效果却十分理想，因此将介绍基于朴素贝叶斯分类算法实现中文分类的过程。
内容包括朴素贝叶斯分类算法概述、机器学习库sklearn及案例实现——朴素贝叶斯中文分类。
朴素贝叶斯分类算法 概述 朴素贝叶斯分类算法是在所有相关概率均已知的前提下，对未知类别的数据计算出最优类别标签的算法。因此，概率是朴素贝叶斯分类算法运行的基础，特别是随机变量的先验概率、条件概率及联合概率。
贝叶斯公式可以灵活应用在未知事物的分类当中，只要知道相应事件的概率，就可以计算出某一个事物属于某一个分类的概率。
一所学校里面有60%的学生为男生，40%的学生为女生。
已知男生总是穿裤子，女生则一半穿裤子，一半穿裙子。
假设走在该校园中遇到一位穿裤子的学生，请计算该学生为女生的概率。
该问题是一个已经知道结果，且知道相应概率，推测导致该结果的原因的典型问题，其中除了明显给出的数据P(Boy)=60%和P(Girl)=40%，还隐含着一些已知的数据，如穿裤子的男生概率P(Pants|Boy)=100%，穿裤子与穿裙子的女生概率为P(Pants|Girl)=P(Skirt|Girl)=50%，现分析如下。
设该学校的总人数为N，则有：
(1)男生中穿裤子的人数为N×P(Boy)×P(Pants|Boy)=N×60%×100%；
(2)女生中穿裤子的人数为N×P(Girl)×P(Pants|Girl)=N×40%×50%；
(3)穿裤子的总人数为N×P(Boy)×P(Pants|Boy)+N×P(Girl)×P(Pants|Girl)。
我们的目的是求出P(Girl|Pants)，即：
将各数据代入式
同理
把相关数据代入式，可计算出P(Boy|Pants)=0.75。
那到底应该把该学生预测为男生还是女生呢？
从以上计算可看出，该学生为男生的概率要大于女生，因此可以大胆预测该学生为男生。
将以上问题一般化：当在该校园当中遇到一位穿裤子的学生时，可以计算出该学生为男生或女生的概率，概率大的则作为最终的决策结果，男生或女生可以理解为分类，即将穿裤子的学生分类为男生或女生两个类别，这就是贝叶斯分类器的理论基础。
应用 朴素贝叶斯可以用来过滤垃圾文本，如识别垃圾邮件、检测社区评论信息等；也可以用在情感判别方面，如微博的褒贬情绪、电商评论信息的情感判断等；还可以用在文本分类方面，如新闻文档的自动识别等。
机器学习库sklearn sklearn（全称为scikit-learn）是在numpy、scipy、matplotlib等数据科学工具包基础上构建的Python机器学习库，包括数据集获取、数据预处理、模型构建与验证、特征选择、分类、回归、聚类、降维等机器学习的多个方面，功能十分强大，是Python机器学习的首选库。
sklearn获取数据 为了快速便捷地搭建机器学习任务，sklearn库提供了多个经典的数据集，目前所提供的数据集主要针对分类与回归两个任务。要使用sklearn提供的数据集，首先要导入数据集模块datasets，语法为from sklearn import datasets，该模块可以使用“load_”开头的函数加载一些数据集，如：
(1)load_breast_cancer()，加载乳腺癌数据集，特征为连续数值，标签为0或1，可用于二分类任务；
(2)load_iris()，加载鸢尾花数据集，特征为连续数值，标签为0、1、2，各类样本数量均衡（均为50个），可用于三分类任务；
(3)load_wine()，红酒数据集，特征为连续数值，可用于三分类任务，各类样本数稍有区别；
(4)load_digits()，手写数字数据集，包含0～9共10个标签，各类样本数均衡，特征是离散数值；
(5)load_boston()，波士顿房价数据集，特征为连续数值，常用于回归任务。
还可以使用“make_”开头的函数自定义数据集，以及使用“fetch_”开头的函数额外下载数据集，为更多的学习任务提供便利。
sklearn数据预处理 在使用sklearn构建机器学习模型时，需要对输入数据的格式进行处理以满足模型输入对数据的要求，一般要处理成numpy的array格式或pandas的dataframe格式。此时，往往需要进行数据的预处理，包括将数据集当中字符串类型的标签转化为离散值，当各个特征数值量纲不同时要去除量纲，当特征数值差别较大时要进行标准化等。为此，sklearn提供了常用的数据预处理功能，包含在sklearn的preprocessing模块当中，简单举例如下：
(1)MinMaxScaler，最大最小值归一化，主要用于去除量纲，适用于数据有明显的跨度，且数据较为正常，不存在严重异常值的处理场景；
(2)StandardScaler，数据的标准化处理，将数据处理成符合标准正态分布的标准数据，同样可用于去除量纲，对于存在极大或极小值的情况尤为适用；
(3)Binarizer，二值化处理，可将连续特征值转化为离散值；
(4)OneHotEncoder，独热编码，经典的编码方式，可将离散标签转化为使用“0”或“1”构成的一系列二进制数值；
(5)Ordinary，数值编码方式，可用于将标签转化为常规数值。
sklearn构建模型 使用sklearn构建模型是十分方便的，因为其提供了丰富的机器学习算法，主要为分类和回归两个大类型。可以使用sklearn构建五种模型：
(1)线性模型，线性回归或逻辑回归，前者用于线性回归分析，后者通过线性回归拟合对数概率来实现二分类；
(2)K近邻模型，不需要进行训练，通过测试样本周围的多个样本判断类别或拟合数值结果；
(3)支持向量机模型，最经典的机器学习模型，通过最大化间隔寻找最佳的分类边界；
(4)朴素贝叶斯模型，基于贝叶斯公式，通过训练模型来拟合出数据集特征的概率分布，并计算出测试集可能属于的类别的概率，将概率最大的类别作为最终预测结果，是纯粹依据概率完成分类任务的模型；
(5)决策树模型，是强大的机器学习模型，模型的训练过程主要包括特征选择、数据划分、模型剪枝三个步骤，主要包括三个算法，分别是ID3、C4.5和CART。
(1)～(3)和(5)既可以用在分类任务上，也可以用在回归任务当中，但是朴素贝叶斯模型只能用于分类任务。
案例实现——朴素贝叶斯中文分类 使用sklearn构建朴素贝叶斯模型，完成对四种类型文本的分类，并实现对未来文档的分类预测。
案例目标 (1)理解文本分类数据的处理思路。
(2)理解朴素贝叶斯工作原理。
(3)掌握使用sklearn模块构建朴素贝叶斯模型的方法。
案例环境 jiebascikit-learn stop_word文件夹存放的是停用词文件stopword.txt。停用词是一些使用非常普遍的词语，对文档分析作用不大，如你、我、他、它、的、了等，一般在文档分析之前需要将停用词去除。可将停用词保存在一个文件中，当需要时读取。
train_data文件夹存放的是训练文本数据。
test_data文件夹存储的是测试数据。不管是训练数据还是测试数据，都是一些新闻数据，每条数据都包含了新闻类型和新闻标题，新闻类型包含财经类、娱乐类、健康类和体育类四种类型，数据以“—”分隔，左边为新闻类型，右边为新闻标题。
案例步骤 (1)text_classification.py构建文本分类模型；
# coding=utf-8 import os import jieba import joblib from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce21e3e723b992d80a49f453f9d71e17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b789e25344f3988d48af9ffecefbcf5/" rel="bookmark">
			电容等效模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、电容等效模型
二、电容阻抗及自谐振频率计算
三、电容ESR过大过小分析
前言 在硬件电路设计中，电容基本是不可或缺的，主要运用在滤波、储能、RC延时、缓冲电路中，在电容选型时，理解电容的等效模型是一个大前提，下面主要就电容的等效模型进行讲解。
一、电容等效模型 电容等效模型电路如下：
电容等效为电容C+电阻ESR+电感ESL。
ESR的大小主要取决于频率、容值、温度（影响电容的精度）、精度、封装，具体可见下图：
二、电容阻抗及自谐振频率计算 电容阻抗：
电感阻抗：
当Xc=XL时，即是电容的自谐振频率，算出来是：
当f&lt;f0时，电容呈现容性；
当f&gt;f0时，电容呈现感性；
当f=f0时，阻抗最小，为R（ESR）；
可参考下图：
三、电容ESR过大过小分析 1）当ESR过大
a、ESR过大，则电容的阻抗相对较大，工作时发热更严重，功耗更大；
b、产生较大RIPPLE，造成噪声；
2）当ESR过小
a、电源滤波电容，ESR太小，引起较强电流尖峰，对开关电源有损害；
对此，LDO电路一般会规定ESR的范围，防止出现振荡类问题等。
四、总结 理解电容的等效模型对电容选型、电路设计或者电源完整性有重大意义。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4592f1411fbcbd35b98e56277cee85b5/" rel="bookmark">
			知识图谱实战应用3-知识图谱中的电影推荐算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是微学AI，今天给大家讲一下知识图谱中的电影推荐算法。主要利用奇异值分解（SVD）算法进行应用。
一、奇异值分解（SVD）
SVD（奇异值分解）是一种常见的线性代数算法，用于将一个矩阵分解为三个矩阵的乘积。原来SVD的主要应用领域包括图像处理、信号处理、信息检索等。
给定一个矩阵A，SVD将其分解为U、S和V三个矩阵的乘积，可以表示为，其中U和V都是正交矩阵，S是一个对角矩阵，其中对角线上的元素称为奇异值。SVD可以将原始矩阵A分解成多个低秩矩阵的乘积，从而对高维数据进行降维和特征提取，例如图片的主题识别、用户偏好和相关性分析等应用。在推荐系统中，SVD可以用于处理稀疏用户-电影评分矩阵，通过分解矩阵来预测用户对未评分电影的喜好程度，并提供个性化的推荐列表。
举一个例子说明：一个矩阵是如何进行奇异值分解的。矩阵A定义为：
二、利用SVD实现推荐算法
一个基于SVD的知识图谱的电影推荐算法的步骤：
构建知识图谱：为电影库中的每个电影创建一个节点，并为它们之间的相似关系创建有向边。相似性可以通过计算两个电影的共同观众数、评分差异、演员、导演、电影流派等因素来衡量。
推导用户向量：对于每个用户，基于他们观看的电影和对应的评分来构建一个向量，包括每个电影的得分或者未评分。
使用SVD分解用户向量：对于每个用户向量，我们可以应用SVD将其分解为三个独立的矩阵：U、S和V。
进行矩阵近似：基于SVD分解的结果，我们可以使用矩阵近似来填充用户未评分的电影得分。这可以通过将U、S和V乘起来得到一个新的矩阵。
应用SVD重构矩阵产生推荐列表：基于相似性衡量，我们可以根据计算出的矩阵来推荐给用户可能感兴趣的电影。我们可以将所有电影的向量与用户向量进行相似性计算，然后在最相似的电影中选择最高得分的电影作为推荐。
通过这个基于知识图谱和SVD的推荐算法，我们可以为每个用户提供个性化的电影推荐。这种方法不仅可以优化推荐系统的效率，而且可以结合许多不同的信息源来提高推荐的准确性和多样性。
三、代码实现部分
import pandas as pd from surprise import Dataset, Reader from surprise import SVD from surprise.model_selection import train_test_split # 读取数据 data = pd.read_csv('ratings.csv') 读取数据文件 ratings.csv，这个数据是整理好的，也可以从知识图谱中获取用户给某个电影id的评分，数据表格结构：
userIdmovieIdrating123.51293.5224252.4314.5322.4453.44203.5533.3523.7613.9623.66293.56224.5 获取数据集：
# 设置reader reader = Reader(rating_scale=(0, 5)) # 加载数据集 dataset = Dataset.load_from_df(data[['userId', 'movieId', 'rating']], reader) # 划分数据集 trainset, testset = train_test_split(dataset, test_size=0.2) # 训练模型 algo = SVD() algo.fit(trainset) # 预测评分 predictions = algo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4592f1411fbcbd35b98e56277cee85b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e41b0d6edb40e84e23f90f6953f101ec/" rel="bookmark">
			Python机器学习入门 -- 支持向量机学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、支持向量机简介二、支持向量机的数学原理1. 距离解算2. 目标函数3. 约束下的优化求解4. 软间隔优化5. 核函数变换 三、Python实现支持向量机1. 惩罚力度对比2. 高斯核函数3. 非线性SVM 总结 前言 大部分传统的机器学习算法都可以实现分类任务，但这些模型关注的是将不同类别的数据分得开就行，也就是说它们的核心思想是让整个模型分类出错的损失越小越好。刚刚好有一种机器学习模型，它不仅关注分类能不能将不同类别的数据完全分得开，还关注分类得到的决策边界的间隔能不能最大化，即离该决策边界每个类别最近的数据点的距离能不能更远，这就是我们今天的主角 - - 支持向量机。
一、支持向量机简介 支持向量机（support vector machines, SVM）是一种二分类模型，它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；SVM还包括核变换，这使它成为实质上的非线性分类器。SVM的的学习策略就是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题。SVM的的学习算法就是求解凸二次规划的最优化算法。
二、支持向量机的数学原理 支持向量机，从名字上来看它是由支持向量（Support Vectors）形成决策边界的一种模型，这里的支持向量是一种特殊的数据点，是所在类别数据中离决策平面最近的一些数据点，支撑起整个决策平面，有点像团队中骨干，他们支撑起整个团队的发展和未来。支持向量的个数与模型的复杂度成正比
1. 距离解算 与其他分类模型类似的是，支持向量机中我们用点到决策面的距离作为优化因子，我们以三维空间中的点到决策平面的距离计算原理推广到高维空间中
设决策平面方程为
w T x ′ + b = 0 w^{T}x' + b = 0 wTx′+b=0
取任一数据点 x x x ，设决策平面的法向量为 w w w ，我们在决策平面上随便取一点 x ′ x' x′ ，则 x x ′ xx' xx′ 两点间的向量为 x − x ′ x - x' x−x′，将向量 x − x ′ x - x' x−x′ 与法向量 w w w 作点乘可以算出向量 x − x ′ x - x' x−x′ 在法向量 w w w 上投影的长度（即点到平面距离）与法向量 w w w 模的长度的乘积，再除以法向量 w w w 模的长度得到点到平面距离，代入决策平面的方程消掉 x ′ x' x′
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e41b0d6edb40e84e23f90f6953f101ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b67911656ef5d18c4ae36cb6741b7965/" rel="bookmark">
			Makefile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基本规则 目标:依赖 目标:要生成的目标文件
(tab)命令 依赖:目标文件由那些文件生成
命令:通过执行该命令由依赖文件生成目标
举例 :
add.o:add.c
gcc -c add.c -o add.c (1)其他规则 目标的时间必须晚于依赖条件的时间,否则更新目标依赖条件如果不存在 , 则去找新的规则产生依赖ALL:指定makefile的终极目标 , 否则make命令只会执行第一个目标 (2)当某一个cpp文件被修改,编译器如何知道 目标文件是通过依赖文件生成的 , 所以目标文件生成时间晚于依赖文件 ; 所以make的时候依次将目标文件和依赖文件时间进行对比 , 如果依赖文件的修改时间 &gt; 目标文件说明依赖文件被修改了, 就需要重新生成目标文件
(3)补充 推荐先编译成 .o文件,最后再进行链接 : 当某一个文件改变,我们只需要重新生成那一个 .o目标文件 , 再链接起来 ,剩下的文件就不需要重新编译 , 提高效率.如果某个目标的依赖文件被修改了, make会重新生成该目标,执行对应命令 ;否则该目标不会被重新生成 (4)make原理 make会在当前目录下找名字为“Makefile”或“makefile”的文件。如果找到，它会找文件当中的第一个目标文件，在上面的例子中，它会找到mytest这个文件，并把这个文件作为最终的目标文件。如果mytest文件不存在，或是mytest所依赖的后面的test.o文件和main.o文件的文件修改时间比mytest文件新，那么它就会执行后面的依赖方法来生成mytest文件。如果mytest所依赖的test.o文件不存在，那么make会在Makefile文件中寻找目标为test.o文件的依赖关系，如果找到则再根据其依赖方法生成test.o文件（类似于堆栈的过程）。当然，你的test.c文件和main.c文件是存在的，于是make会生成test.o文件和main.o文件，然后再用test.o文件和main.o文件生成最终的mytest文件。make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在寻找的过程中，如果出现错误，例如最后被依赖的文件找不到，那么make就会直接退出，并报错。 2.Makefile函数 (1) src = $(wildcard *.c) 将当前目录下所有的后缀为 .c的文件赋值给src , 将文件名组成列表, 赋值给src相当于取出某一后缀的所有文件 (2) obj = $(patsubst %.cpp, %.o, $(src)) %是通配符, 匹配字符串把src变量里所有后缀为 .cpp 的文件替换成 .o将参数3中包含参数1的部分,替换为参数2 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b67911656ef5d18c4ae36cb6741b7965/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a89a7914c4a25ec5f1ecadbc60f491a0/" rel="bookmark">
			图嵌入表示学习—Graph Embeddings
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Embedding Entire Graphs 一、图嵌入向量基本概念 与Node Embeddings不同，Graph Embeddings是对整个图或子图进行编码而忽略其中的节点。应用场景包括异常检测或分子有毒检测。
二、对Node Embeddings求和或求和后平均 如图，首先对图/子图中的节点进行图嵌入向量表示（ z u \mathbb{z}_u zu​），之后将嵌入向量求和（或对求和向量再平均）得到图/子图的嵌入向量。
注意：该方法虽然很简单，但是效果很好。
三、创建超节点 如图，在原图的基础上对图/子图增加一个超节点，该超节点与图/子图的所有节点均建立连接。之后利用Node Embeddings的方法求得该节点的嵌入向量，该嵌入向量就是图/子图的嵌入向量。
四、匿名随机游走 1、匿名随机游走方法： 匿名随机游走，只记忆节点出现的时间而不关心具体的节点。
如图，在A、B、C、D、E和F节点组成的子图中：
第一次游走的节点次序为：A、B、C、B、C。A是第一个访问的节点标记为1，B是第二个访问的节点标记为2，C是第三个访问的节点标记为3，除此之外没有其他节点。此时，匿名随机游走路径为：1、2、3、2、3；
第二次游走的节点次序为：C、D、B、D、B。C是第一个访问的节点标记为1，D是第二个访问的节点标记为2，B是第三个访问的节点标记为3，除此之外没有其他节点。此时，匿名随机游走路径为：1、2、3、2、3；
从两次行走中可以看出，虽然两次行走的路径不同，但是其匿名行走路径是相同的。只记忆节点出现的时间而不关心具体的节点。
从图中可以看出，对于不同长度的匿名随机游走序列，其行走路径数量呈指数级爆炸增长。
其中，长度为3的路径次数计算如图：
2、使用匿名随机游走进行图嵌入编码 对于图/子图，进行固定长度的匿名随机游走，并记录每个行走序列的次数（或出现概率），将其记录为向量，该向量即为图的嵌入向量。如图：
随机游走的长度 l l l是一个超参数，对于选定的 l l l，应该对图/子图采样多少次是一个值得思考的问题，如图：
为了保证采样的健壮性，使采样的分布误差保持在 [ ε , δ ] [\varepsilon,\delta ] [ε,δ]之间，对于选定长度 l l l，计算得到随机游走序列的个数为$\eta （查表或自己计算），得到采样次数 （查表或自己计算），得到采样次数 （查表或自己计算），得到采样次数m$为：
m = ⌈ 2 ε 2 ( l o g ( 2 η − 2 ) − l o g ( δ ) ) ⌉ m=\left \lceil \frac{2}{\varepsilon ^2} \left ( log \left ( 2^\eta - 2 \right ) - log(\delta ) \right ) \right \rceil m=⌈ε22​(log(2η−2)−log(δ))⌉
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a89a7914c4a25ec5f1ecadbc60f491a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bed1b6a9adae8f3cc9d4a4cd4508c3e/" rel="bookmark">
			Java面试题——数据库的优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据库优化是指通过对数据库系统进行适当的配置和监控，以及对数据库设计、查询和操作等方面进行优化，从而提高数据库系统的性能、可用性和可扩展性。具体来说，可以从以下几个方面入手进行数据库优化：
数据库设计优化：包括表结构设计、索引设计、分区设计、对存储引擎的优化、对存储的优化、对内存的优化等方面。例如，合理地设计表结构可以避免数据冗余和重复，提高数据访问效率；创建适当的索引可以加快数据检索速度；使用分区技术可以提高数据存储和查询效率。
查询优化：包括 SQL 语句的编写、索引的选择和使用、查询计划的优化等方面。例如，在编写 SQL 语句时应该尽量避免使用子查询和联合查询等复杂语句；在选择索引时应该根据实际需求和数据特征来进行选择；在优化查询计划时可以使用 Explain Plan 等工具来定位问题，以便进行针对性优化。
数据库参数优化：包括缓存大小、线程池大小、日志设置等方面。例如，调整缓存大小可以提高数据访问效率；调整线程池大小可以避免线程阻塞和资源浪费；设置正确的日志级别可以降低系统负载和存储压力。
数据库监控和调优：包括性能指标的收集、阈值的设置、故障排查等方面。例如，使用监控工具可以实时监测数据库系统的运行状态；设置合理的性能指标可以及时发现和解决问题；进行故障排查时应该使用科学的方法和工具，避免盲目调整或者误操作。
代码优化：包括应用程序的设计和编码等方面。例如，在应用程序中应该尽量避免频繁访问数据库，合理地使用缓存和批处理技术可以提高数据访问效率；合理使用事务可以确保数据一致性和可靠性；避免使用过于复杂的算法和逻辑可以降低系统负载和卡顿。
需要注意的是，数据库优化是一个持续不断的过程，需要根据实际需求和环境变化来进行调整和改进。在优化数据库时，应该充分了解和掌握相关的知识和技术，同时也需要结合实践经验和业务需求来进行优化。
*下面针对查询优化具体有：
（1）基本写法的优化：
少使用select * ，尽量用具体的字段。对条件来说等号之类两边的字段类型要相同，字符串不加引号索引会失效。尽量少使用order by 对于多个字段需要排序可使用组合索引。对于group by 需要先过滤后分组。在查询时减少使用null，对字段有多个null可设默认值。少使用like%，需要使用like时尽量将%放在字段的之后。where 后面少使用函数或者算法运算。去重的distinct j尽量少使用distinct * ，可选择几个关键字段。不要五张以上的表联查。 （2）替换优化：
1.不要使用not in 和&lt;&gt; ，这样会破坏索引，可以使用 not exists 代替 not in ，&lt;&gt; 可以分为两个条件&lt; 或 &gt;.
2.使用连接join 代替子查询。
（3）建立使用合适索引：
1.对于高频筛选字段可以适当的建立索引。
2.一个表的索引最好不好超过五个，多了会影响插入和修改。
3.使用组合索引时要遵守最左原则。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed89a5e18b3d312e83d12b9bbf081cc6/" rel="bookmark">
			FeedBack Network for Image super Resolution阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. 模型结构与反馈机制2. 课程学习策略与损失函数 前言 CVPR2019的一篇论文。
保证网络深度的同时，为了减少网络的参数量，通常使用循环的结构。但是，大多具有循环结构的网络都是以前馈的方式共享信息，这样前一层无法从后一层访问有用的信息。
生物学中，连接大脑皮层视觉区域的反馈连接可以将反应信号从高阶区域传递到低阶区域。受其启发，利用反馈机制将高级信息传回前一层，并细化低级编码特征。
借鉴CVPR2017论文Feedback Network的思路，提出了一种新的图像超分辨率网络，即超分辨率反馈网络（Super-Resolution Feedback Network, SRFBN）。本质上是一个带有反馈块（FB）的RNN。FB由多组上下采样层和密集的跳跃连接构成。
如下图所示，每次迭代时的输出都会流入下一次迭代以控制输入。
为了确保每次迭代的输出包含HR图像的信息，用损失函数监督训练过程中的每次迭代。反馈方案的原理是，粗糙SR图像的信息可以帮助LR图像重建更好的SR图像。
总结，论文的主要工作有以下三点：
提出了一种采用反馈机制的图像超分辨率反馈网络。这种带有反馈连接的循环结构有较强的早期重建能力，且需要的参数较少。提出了反馈块（FB）。不仅有效地处理反馈信息流，而且通过上下采样层和密集的跳跃连接丰富高层表示。基于课程学习的训练策略。根据重构难度对训练样本进行排序，使网络由易到难逐步学习。 感兴趣的地方：
反馈机制如何发挥作用课程学习的训练方法，如何对训练样本进行排序损失函数的设计 1. 模型结构与反馈机制 高级信息可以引导LR图像更好地恢复SR图像。有三个不可缺少的部分加强反馈方案。
每次迭代计算损失，迫使网络在每次迭代时重建SR图像，从而允许隐藏状态携带高层信息的概念。使用递归结构，以实现迭代过程。在每次迭代时提供LR输入，以确保低层信息的可用性。 网络整体结构如下图所示，蓝色箭头表示反馈连接，绿色箭头表示全局残差跳跃连接。
网络可以展开为T次迭代，从1到T。为了使每次迭代带有输出的概念，将每次迭代的输出计算损失。每次迭代的网络包含三个部分：LR特征提取块（LRFB）、反馈块（FB）、重构块（RB）。
FB的结构如下所示。
使用Conv(1,m)对 F i n t F_{in}^t Fint​和 F o u t t − 1 F_{out}^{t-1} Foutt−1​进行连接和压缩，通过反馈信息 F o u t t − 1 F_{out}^{t-1} Foutt−1​来细化输入特征 F i n t F_{in}^t Fint​，产生细化后的输入特征 L 0 t L_0^t L0t​。
L 0 t = C 0 ( [ F o u t t − 1 , F i n t ] ) L_0^t=C_0([F_{out}^{t-1},F_{in}^{t}]) L0t​=C0​([Foutt−1​,Fint​])
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed89a5e18b3d312e83d12b9bbf081cc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e17e614f6cb644d12313b0330e8de7a/" rel="bookmark">
			U-Net结构改进：双交叉注意力模块（DCA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. 模型的特点2. 基于多尺度编码器的Patch Embedding3. 通道交叉注意力（CCA）4. 空间交叉注意力（SCA） 前言 本文由迈阿密大学的研究团队于2023年3月30日发表，提出了双交叉注意力模块（Dual Cross-Attention , DCA），其目标是在轻微的参数和复杂性增加的情况下改进U-Net及其变体，能够简单而有效地增强u-net结构中的跳跃连接（skip-connection）。
DCA通过按顺序捕获多尺度编码器特征之间的通道和空间依赖关系来解决编码器特征和解码器特征之间的语义差距。
首先，通道交叉注意（CCA）通过利用多尺度编码器特征的跨通道token的交叉注意提取全局通道依赖关系。然后，空间交叉注意（SCA）模块进行交叉注意操作，来捕获跨空间令牌的空间依赖性。最后，将这些细粒度的编码器特征上采样并连接到相应的解码器部分，形成skip-connection方案。 传统的U-Net改进方法，例如残差和循环连接等存在以下缺陷：
卷积的局部性无法捕获不同特征之间的长距离依赖关系。skip-connection在简单地连接编码器和解码器特征时引起的语义差距。 受到顺序双重注意力和通道交叉注意力的启发，提出了双交叉注意力模块（DCA），有效提取多尺度编码器特征之间的通道和空间依赖，以解决语义差距问题。
1. 模型的特点 模型大致示意如下。DCA模块的结构不受编码器stage数量的影响，给定n+1个多尺度编码器stage，DCA将前n个stage的特征层作为输入，产生增强表示，并将它们连接到相应的n个解码器stage。
如下图所示，DCA可以分为两个主要阶段，三个步骤：
第一阶段由多尺度patch embedding模块组成，以获得编码器Token。第二阶段，在这些编码器token上使用通道交叉注意（CCA）和空间交叉注意（SCA）模块来实现DCA，以捕获长距离依赖关系。最后，使用层归一化和GeLU对这些token进行序列化和上采样，将它们连接到解码器对应部分。 2. 基于多尺度编码器的Patch Embedding 首先从n个多尺度编码器stage中提取Patch。
给定n个不同尺度的编码器stage， E i ∈ R C i × H 2 i − 1 × W 2 i − 1 E_i \in \mathbb R^{C_i \times \frac{H}{2^{i-1}} \times \frac{W}{2^{i-1}}} Ei​∈RCi​×2i−1H​×2i−1W​，并且块大小 P i S = P S 2 i − 1 P_i^S=\frac{P^S}{2^{i-1}} PiS​=2i−1PS​，其中 i = 1 , 2 , … , n i=1,2,\ldots,n i=1,2,…,n。使用大小和步长为 P i S P_i^S PiS​的平均池化来提取patch，并在展平的2维patch上使用 1 × 1 1 \times 1 1×1深度可分离卷积来进行映射。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e17e614f6cb644d12313b0330e8de7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f572058d2b2d86a341bef440d9fd1e23/" rel="bookmark">
			rsync数据同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介认识原理特点 二、ssh模式三、daemon 模式1.服务启动方式2.配置详解3.服务端配置 测试数据实时同步 一、简介 认识 Rsync是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。rsync使用所谓的"Rsync算法"来使本地和远程两个主机之间的文件达到同步，这个算法只传递两个文件的不同部分，而不是每次都整份传递，因此速度很快。
原理 Rsync本来是用于替代rcp的一个工具，目前由sync.samba.org维护，所以rsync.conf文件格式类似于samba的主配置文件。
Rsync可以通过rsh或ssh使用，也能以daemon的形式运行，在以daemon形式运行时Rsync server会打开一个873端口，等待客户端链接。
连接时，Rsync server会检查口令是否相符，若通过口令查核，则可以开始文件传输。第一次连通完成时，会把整个文件传输一次，以后就只需进行增量备份。
特点 可以镜像保存整个目录数和文件系统；可以很容易做到保持原来文件的权限、时间、软硬链接等；无需特殊权限即可安装；优化的流程，文件传输效率高；可以使用rsh、ssh等方式来传输文件，当然也可以通过直接的socket连接；支持匿名传输； 二、ssh模式 本地IP：192.168.122.188
本地间传输：
rsync -av src/ dest/ //将src目录下所有文件同步至dest下
rsync -av src dest/ //将src目录包括自己整个同步至dest
rsync -avR src/ dest/ //将src目录包括自己同步至dest，等同于src不加/的状态
局域网间同步：
rsync -av src/ 192.168.122.122:/data //同步目录下文件到远程目录
rsync -av 192.168.122.122:/data/ src/ //同步远程文件到本地
rsync -av src 192.168.122.122:/data //同步整个目录
rsync -av —delete src/ 192.168.122.122:/data //从目标文件里面删除无关文件
局域网指定用户同步
rsync -av src ‘-e ssh -l root’ 192.168.122.122:/data
rsync -av 192.168.122.122:/data/ ‘-e ssh -l root -p 22’ dest/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f572058d2b2d86a341bef440d9fd1e23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ae008138a7d0a64fa7bec63c1b05a8/" rel="bookmark">
			微信小程序实现下拉筛选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不多说直接上代码
1、WXML代码：
&lt;view class="container"&gt; &lt;view class="goods-type"&gt; &lt;view class="select-content"&gt; &lt;view class="select-border" bindtap="showSelectBox"&gt; &lt;text&gt;{{chooseItem}}&lt;/text&gt; &lt;text class="arrow"&gt;&lt;/text&gt; &lt;/view&gt; &lt;view class="select-box" wx:if="{{selectBox}}"&gt; &lt;view class="select-item" bindtap="chooseSelectItem" data-name="分类一"&gt;分类一&lt;/view&gt; &lt;view class="select-item" bindtap="chooseSelectItem" data-name="分类二"&gt;分类二&lt;/view&gt; &lt;view class="select-item" bindtap="chooseSelectItem" data-name="分类三"&gt;分类三&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 2、 WXSS代码：
.container { width: 100%; min-height: 100vh; background-color: rgba(238, 239, 241, 1) } .goods-type { height: 80rpx; background-color: #fff; padding: 0 20rpx; } .select-content { position: relative } .select-border { width: calc(50% - 20rpx); height: 60rpx; display: flex; align-items: center; justify-content: space-between; border: 1px solid #f55095; padding: 0 10rpx } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ae008138a7d0a64fa7bec63c1b05a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a20646f53712b5fe1589dbb578605d44/" rel="bookmark">
			28.window的定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定时器。
Window有两种定时器，一种叫轮循定时器，即定时器不会停止，一直循环运行。第二种叫延时定时器，只会执行一次就不再执行。
1.延时定时器 window.settimeout 一般window会省略。
书写样式为window.settimeout(fn,1000);
其中fn为函数，1000为时间单位毫秒。
在Js的世界中，1000为1000毫秒，也就是一秒。
例如:&lt;script&gt;
window.settimeout(funtion ()
{console.log('我在一秒种之后执行')},1000）
&lt;script&gt;
这个时候，就会在一秒钟之后，执行一次函数就结束了。
2.轮循定时器 window.setinterval 一般省略window
书写样式为window.setinterval(fn,1000);
例如:&lt;script&gt;
window.setinterval(funtion ()
{console.log('我在一秒种之后执行')},1000）
&lt;script&gt;
这时，就会在一秒钟之后，循环执行函数。
3.轮循定时器开启后需要关闭。
关闭轮循定时器window.clearinterval;同样window可省略
首先，关闭定时器得先给被关闭的定时器一个变量var
例如:&lt;script&gt;
Var timer = window.setinterval(funtion ()
{console.log('我在一秒种之后执行')},1000）
*上面为轮循定时器的代码我们给他命名timer*
*下面为关闭轮循定时器的代码*
Settimeout(fuction (){window.clearinterval(time);},3000);
&lt;script&gt;
此时轮循定时器会执行三次后被关闭不在执行。
4.延时定时器也可以被关闭。
关闭延时定时器window.cleartimeout;同样window可省略
同样的，首先的得给予被关闭的延时定时器一个变量var
例如:&lt;script&gt;
Var timer = window.setimeout(funtion ()
{alert(1);}1000）
*上面为轮循定时器的代码我们给他命名timer*
*下面为关闭延时定时器的代码*
Settimeout(funtion (){window.clearinterval(time);},3000);
&lt;script&gt;
此时，延时定时器将会被关闭，需要注意的是关闭延时定时器的代码时间需要在执行延时定时器之前才行，不然会关闭不了，延时定时器已经先运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30e0d2c1f58130ac69258c61ec50e9cf/" rel="bookmark">
			leetcode：234.回文链表（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：内容包括-题目，代码实现，大致思路，代码解读
题目： 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。
示例 1：
输入：head = [1,2,2,1]
输出：true
示例 2：
输入：head = [1,2]
输出：false
来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/palindrome-linked-list
代码实现： //找中间结点 struct ListNode*FindMid(struct ListNode*head) { struct ListNode* slow = head; struct ListNode* fast = head; while (fast &amp;&amp; fast-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } return slow; } //翻转后半段链表 struct ListNode* reverse(struct ListNode*head) { struct ListNode* prev = NULL; struct ListNode* cur = head; while (cur) { struct ListNode* next = cur-&gt;next; cur-&gt;next = prev; prev = cur; cur = next; if (next) { next = next-&gt;next; } } return prev; } bool isPalindrome(struct ListNode* head) { struct ListNode* mid = FindMid(head); struct ListNode* rmid = reverse(mid); while (rmid) { if (head-&gt;val == rmid-&gt;val) { head = head-&gt;next; rmid = rmid-&gt;next; } else { return false; } } return true; } 大致思路： 1 翻转后半段链表：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30e0d2c1f58130ac69258c61ec50e9cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f259c17dc4738bf6cf9e57a3902fdcc3/" rel="bookmark">
			【C&#43;&#43;】引用的基本概念和使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、什么是引用二、引用的特性1.引用必须进行初始化2.引用一旦引用一个实体后就不能再引用其它实体3.一个实体可以有多个引用4.常量引用 三、引用的使用场景1.做参数2.做返回值 四、引用和指针的区别1.语法层面2.底层实现3.其它不同点 总结 前言 本文将会介绍C++相对于C语言引入的一个新语法引用。–文章主要从引用的概念、引用使用的场景以及引用和指针的区别三个方面进行介绍。
一、什么是引用 引用就像我们给朋友取外号一样，张三是他的真名而狗蛋是给他取的小名。当我们喊张三或者狗蛋时这个人都会回应，引用也是如此。
引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。
语法：类型&amp; 引用变量名(为实体名取的别名) = 实体名
#include &lt;iostream&gt; using namespace std; int main() { int a = 0; //b成为了a的别名，对b的赋值，加减等各种运算也会对a进行相应的改变 int&amp; b = a; //输出a和b两个变量的地址，可以看到是相同的，说明两个变量共用一块空间 cout &lt;&lt; &amp;b &lt;&lt; endl; cout &lt;&lt; &amp;a &lt;&lt; endl; return 0; } 注意！引用类型必须和引用实体必须是同种类型的
二、引用的特性 1.引用必须进行初始化 #include &lt;iostream&gt; using namespace std; int main() { int a = 0; //int&amp; b;此处编译器会报错，引用必须初始化 int&amp; b = a; return 0; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f259c17dc4738bf6cf9e57a3902fdcc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db2e94928d82a44b586c489de808d08f/" rel="bookmark">
			初识C语言（1）来创建一个项目吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以Visual Studio 2022编译器为例。
第一步，打开VS，点击“创建新项目”。
第二步，选择项目模板，直接选“空项目”
第三步，设置项目名称、存储路径。
点击“创建”，一个项目即创建完成。
第四步，在解决方案资源管理器（快捷键Ctrl+Alt+L)中找到“源文件”，单击。
PS:解决方案资源管理器在“视图”一栏中找。（第一次安装VS的话解决方案资源管理器在初始界面就是打开的。如果不小心关掉了不要简单粗暴地卸载重装！！！如果之前把资源管理器关了，重装的VS界面不是第一次安装时的初始化的界面，会和电脑上之前安装的VS的界面一致。通俗点说就是这么做是没用的QAQ）
第五步，选择“添加”、“新建项”。
第六步（马上就成啦），选择“C++”文件，设置文件名和文件路径。
划重点！！！
使用C语言编译，文件尾为".c"。
使用 C++语言编译，文件尾为”.cpp"。
如果文件类型设置错误了（比如在“.cpp”结尾的文件里用C语言写程序），就算代码没有错误编译器会报错的QAQ（你猜这个坑我踩过多少次）
大功告成！（撒花）（放炮）（鼓掌） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8ef1c55d90ba409d7851b0c550374d/" rel="bookmark">
			ssh登录远程主机，让远程主机执行脚本文件，并传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ssh登录远程主机，让远程主机执行脚本文件，并传参cat ssh2.sh | ssh hadoop102 "bash -s" 用该命令时需要向ssh2.sh传入参数，该怎么办方法一 方法二 ssh登录远程主机，让远程主机执行脚本文件，并传参 该问题就是：
用下面这条命令时需要向ssh2.sh传入参数，该怎么办
cat ssh2.sh | ssh hadoop102 "bash -s" cat ssh2.sh | ssh hadoop102 “bash -s” 用该命令时需要向ssh2.sh传入参数，该怎么办 方法一 如果只考虑向ssh2.sh传入参数：
可以在命令行中使用管道符号和echo命令将参数传递给ssh2.sh脚本，然后使用ssh命令将脚本传输到远程服务器并执行。具体的实现方式如下：
echo "param1 param2" | ssh hadoop102 "bash -s" &lt; ssh2.sh 在上面的命令中，使用echo命令将参数"param1"和"param2"传递给ssh2.sh脚本，然后使用ssh命令将脚本传输到远程服务器hadoop102并执行。在脚本中，可以使用$1和$2等变量来获取传递的参数。
例如，如果ssh2.sh脚本内容如下：
#!/bin/bash echo "The first parameter is: $1" echo "The second parameter is: $2" 那么在执行上面的命令时，远程服务器会输出以下内容：
The first parameter is: param1 The second parameter is: param2 总之，通过使用管道符号和echo命令将参数传递给脚本，并在脚本中使用$1、$2等变量来获取参数，可以实现在执行远程脚本时传递参数的功能。
方法二 在命令行中直接传入参数:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d8ef1c55d90ba409d7851b0c550374d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0084d8c00f67f0338e15b56b053c4a9f/" rel="bookmark">
			HC-05蓝牙模块 教学及问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		器材： 杜邦线 公母 公公 母母
HC-05 蓝牙模块 （有按键， 无按键选一种就行）
建议选有按键版本，方便后续调试
USB - TTL串口调试工具 （请用带保护的的版本，若接线的时候接反可能会烧坏电脑）非必须品，但可以非常方便的调试您的蓝牙模块）
接线
HC05
串口
RX
RX
TX
TX
GND
GND
+5V
VCC
ps：若接3v有可能电压不足导致无法通讯
下载串口调试工具（不一定要这一款，任意一款就行）
手机蓝牙调试APP （任意一款，免费的就行）
等连接完线路，将串口工具插入电脑进行调试 有几点请注意：
1. 串口号确认是插入串口调试工具的串口（在设备管理器里可以查看，一般只会有你插入的串口会有显示，若插入了其他单片机可能会有多个com显示请注意区分）
2. HC05的官方AT波特率是38400，用于设置各种属性使用。其他波特率可用于接受和发送数据。
3. 要选择发送新行，因为对于蓝牙来说识别到\r\n来确定是否结束。若不发送新行会导致at指令失败
4. 在进入调试模式时蓝牙是不接收和发送数据的
5. 若您已经连接了蓝牙，AT模式也会失败
6.如果部分指令没有反应可以按住key键（HC-05上面那个按钮的时候输入at指令）
这时您可以输入AT来查看蓝牙是否正常了
若您接收到OK，说明AT指令正常（有按键的蓝牙模块请按一下按钮进入at模式，如果您不确定是否处于at模式就点一次测一次）若没有任何反应 有可能的是蓝牙模块坏了
等您设置完蓝牙模块就可以进行通讯了，（有按键的按键退出）使用APP查找到您的HC-05蓝牙模块 找到后点击connect 连接模块，如果您设置了密码就输入密码就好，
找到write的servers 后可以写入数据在电脑端的串口调试工具会显示，请注意您的波特率是否正确，若不一致会乱码或无输出。
在notify里可以看到电脑端发过来的数据，同样需要注意波特率的问题。
调试完后您就可以插入您的单片机中进行通讯了。
如果您还有什么疑问请在评论区询问，感谢
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/143/">«</a>
	<span class="pagination__item pagination__item--current">144/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/145/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>