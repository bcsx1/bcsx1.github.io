<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba59725a19292e05507395767f12e4ec/" rel="bookmark">
			计算机组成 | 超详细 数的表示与编码 进制转换 原码 补码 反码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 进制/编码转换1.1 不同进制之间转换1. 二进制转十进制2. 十进制转二进制3. 八进制转十进制4. 十进制转八进制5. 十六进制转十进制6. 十进制转十六进制7 二进制转八进制8 二进制转十六进制 1.2 不同编码之间转换 2 字符编码表示2.1 小数表示2.1.1 定点表示2.1.2 浮点表示 2.2 汉字编码 本节主要是计算机中数的表示和编码部分 1 进制/编码转换 1.1 不同进制之间转换 1. 二进制转十进制 原理：
整数部分和上述相同
小数部分每位乘以2的负幂次，然后求和。
例子：二进制数 110.101 转换为十进制：
整数部分： 1 × 2 2 + 1 × 2 1 = 4 + 2 = 6 1 \times 2^2 + 1 \times 2^1 = 4 + 2 = 6 1×22+1×21=4+2=6
小数部分： 1 × 2 − 1 + 0 × 2 − 2 + 1 × 2 − 3 = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba59725a19292e05507395767f12e4ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb9f348a99520cc4a361919d74492767/" rel="bookmark">
			nginx tcp代理特别说明（解决项目中telnet端口打不开的问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题现象 telnet虚拟ip的端口打开慢，导致打不开
解决办法 调整配置文件
正确配置文件如下
user nginx; worker_processes 20; error_log /var/log/nginx/error.log notice; pid /var/run/nginx.pid; events { worker_connections 102400; } http { include mime.types; default_type application/octet-stream; sendfile on; # 限制文件上传大小 client_max_body_size 1024m; keepalive_timeout 65; upstream backend { server 10.160.91.253:8082; } server { listen 8082; server_name localhost; # listen 8161; # server_name localhost; location / { proxy_pass http://backend; } # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb9f348a99520cc4a361919d74492767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d961d880aa9e5fe66673dbb0c3fa6e07/" rel="bookmark">
			AIGC系统ChatGPT系统源码，Midjourney绘画，GPT语音对话&#43;ChatFile文档对话总结&#43;DALL-E3文生图&#43;思维导图一站式解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 SparkAi创作系统是基于ChatGPT进行开发的Ai智能问答系统和Midjourney绘画系统，支持OpenAI-GPT全模型+国内AI全模型。本期针对源码系统整体测试下来非常完美，可以说SparkAi是目前国内一款的ChatGPT对接OpenAI软件系统。那么如何搭建部署AI创作ChatGPT？小编这里写一个详细图文教程吧！支持GPT-4-Turbo模型、支持DALL-E3文生图，支持最新GPT-4-Turbo模型、GPT-4-1106-Preview多模态模型。支持GPT-4图片对话能力上传图片并识图理解对话，ChatFile文档对话总结。
《SparkAi系统详情及搭建部署文档》:
https://www.yuque.com/yuqueyonghutq9yt2/egy0d0/ah9sq89lgl6b7s4w
①新增OpenAI的TTS语音对话功能
支持电脑PC浏览器和手机端使用（调整用户端语音交互，语音输入则语音回复，文本输入则文本回复）
​
②ChatFile文档对话总结 ​
③DALL-E3文生图（支持直接对话绘画）
​
④新增已支持GPT-4图片对话能力
（上传图片并识图理解对话）
1.1AI模型提问 1.2人工智能AI绘画 新增Midjourney局部重绘（Vary Region）在线编辑功能
新增支持MJ最新V6 Beta绘画模型（V6 Beta模型：能够处理更长的提示词，人物效果更加真实，构图、色调、光影更加细腻）
手机端页面：
1.1 程序核心功能 SparkAi系统现已支持 OpenAI GPT全模型 + 国内AI全模型 + 绘画池系统 + OpenAI TTS语音对话功能 + 文档对话总结功能！
AI提问：程序已支持GPT3.5，GPT4.0提问、OpenAIGPT全模型+国内AI全模型、支持GPT联网提问已支持OpenAIGPT全模型+国内AI全模型，已支持国内AI模型 百度文心一言、微软Azure、阿里云通义千问模型、清华智谱AIChatGLM、科大讯飞星火大模型、腾讯混元大模型等ChatFile文档上传对话功能以及总结对话新增知识库接入（对接百度千帆知识库），用户端动态显示知识库插件并通过插件的方式选择与知识库对话，可自定义训练内容回答和文档总结，上传文档作为知识库内容用于特定场景对话回答，比如企业文化规章制度、产品说明文档、客服等等各行业知识库等新增支持MJ最新V6 Beta绘画模型（V6 Beta模型：能够处理更长的提示词，人物效果更加真实，构图、色调、光影更加细腻）AI绘画：Midjourney绘画（全自定义调参）、Midjourney以图生图、Dall-E3绘画支持最新GPT-4多模态模型、OpenAI GPT-4-Turbo-With-Vision-128K模型已支持GPT-4图片对话能力（上传图片并识图理解对话）可同时支持5张图同时上传对话对话插件系统，后续逐步增加插件功能，扩展AI能力新增KEY支持单独配置消耗费率，比如GPT4-32K比GPT4成本更高应该消耗更多的额度次数微信公众号+邮箱+手机号注册登录一键智能思维导图生成应用广场，支持用户前台自定义添加私密或共享AI绘画广场（画廊）邀请+代理分销模式、用户每日签到功能、会话记录同步保存支持对接微信官方支付、易支付、码支付、虎皮椒支付等，自定义聚合会员套餐其他核心功能、后续其他免费版本功能更新 1.2 更新日志 【V4.3.0】更新功能（2023.12.26号更新） 新增用户端聊天对话插件：ChatFile文档上传对话功能以及总结对话优化TTS请求api支持三方中转代理接口新增支持MJ最新V6 Beta绘画模型（V6 Beta模型：能够处理更长的提示词，人物效果更加真实，构图、色调、光影更加细腻）调整对话请求超时机制，避免插件调用时间太长报错（DallE-3聊天绘画），如何配置请看部署文档其他优化 二、系统模块演示 快速体验 官方演示站：
系统用户端：https://ai.sparkaigf.com管理后端：https://ai.sparkaigf.com/sparkai/admin测试账号密码：admin 123456 三、系统功能模块 3.1ChatGPT模型提问 GPT联网提问提问
3.2Prompt应用 3.2.1Prompt应用 3.2.2自定义Prompt应用 支持用户自定义Prompt应用
3.3 支持Midjourney绘画 支持同步官方图片重新生成指令
同步官方 Vary 指令 单张图片对比加强 Vary(Strong) | Vary(Subtle)
同步官方 Zoom 指令 单张图片无限缩放 Zoom out 2x | Zoom out 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d961d880aa9e5fe66673dbb0c3fa6e07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f32fb6cba434ded4bba2187e29ce8a7/" rel="bookmark">
			在使用微软系统远程mstsc时发送ctrl&#43;alt&#43;del快捷键调用任务管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用系统远程工具远程的时候，当界面没显示任务栏和界面白屏的时候，需要打开任务管理器
按下Ctrl+Alt+End，就相当于在远程的机器上按下了Ctrl+Alt+Delete，这样就可以调用任务管理器了
打开了任务管理器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67886be6313d10c364696d5b72bf155e/" rel="bookmark">
			日志记录、跟踪和指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的新书《Android App开发入门与实战》已于2020年8月由人民邮电出版社出版，欢迎购买。点击进入详情
日志记录、跟踪和指标是系统可观察性的三大支柱。 下图显示了它们的定义和典型架构。
记录 日志记录系统中的离散事件。例如，我们可以将传入请求或对数据库的访问记录为事件。它的音量最高。 ELK（Elastic-Logstash-Kibana）堆栈常用于构建日志分析平台。我们经常定义标准化的日志格式供不同团队实施，以便我们在海量日志中搜索时可以利用关键字。
追踪 跟踪通常是请求范围的。例如，用户请求经过API网关、负载均衡器、服务A、服务B和数据库，这些都可以在跟踪系统中可视化。当我们尝试识别系统中的瓶颈时，这非常有用。我们使用 OpenTelemetry 来展示典型的架构，它将 3 个支柱统一在一个框架中。
指标 指标通常是来自系统的可聚合信息。例如，服务QPS、API响应能力、服务延迟等。原始数据记录在InfluxDB等时序数据库中。 Prometheus 提取数据并根据预定义的警报规则转换数据。然后，数据被发送到 Grafana 进行显示或发送到警报管理器，然后警报管理器发送电子邮件、短信或 Slack 通知或警报。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44220af4950d700aa9c4d299614f4f04/" rel="bookmark">
			（2023，3D NeRF，无图像变分分数蒸馏，单步扩散）SwiftBrush：具有变分分数蒸馏的一步文本到图像扩散模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SwiftBrush : One-Step Text-to-Image Diffusion Model with Variational Score Distillation
公众：EDPJ（添加 VX：CV_EDPJ 或直接进 Q 交流群：922230617 获取资料）
目录
0. 摘要
1. 方法
1.1 基础
1.2 SwiftBrush
2. 结果
3. 未来工作
S. 总结
S.1 主要贡献
S.2 方法
0. 摘要 尽管文本到图像扩散模型能够从文本提示生成高分辨率和多样化的图像，但通常会受到缓慢的迭代采样过程的困扰。模型蒸馏是加速这些模型的最有效方法之一。然而，先前的蒸馏方法在要求大量图像进行训练时未能保留生成质量，这些图像可以来自真实数据，也可以是由教师模型合成生成的。针对这一限制，我们提出了一种新颖的无图像蒸馏方案，名为 SwiftBrush。从文本到 3D 合成中汲取灵感，该方法通过专用损失从 2D 文本到图像扩散先验获取与输入提示对齐的 3D 神经辐射场（Neural Radiance Fields，NeRF），而无需使用任何 3D 真实数据。我们的方法重新利用相同的损失，将经过预训练的多步文本到图像模型蒸馏到一个只需单一推理步骤就能生成高保真图像的学生网络。尽管模型简单，但我们的模型是第一个能够一步生成与 Stable Diffusion 相媲美质量的文本到图像生成器之一，而无需依赖任何训练图像数据。值得注意的是，SwiftBrush 在 COCO-30K 基准测试中取得了 16.67 的 FID 分数和 0.29 的 CLIP 分数，实现了有竞争力的结果，甚至在某些方面超越了现有的最先进蒸馏技术。
1. 方法 1.1 基础 分数蒸馏采样 (Score Distillation Sampling，SDS) 是一种用于预训练扩散模型的蒸馏技术，有效地应用于 3D 生成 [17, 26, 42]。它利用预训练的文本到图像扩散模型，该模型从文本条件 y 中预测扩散噪声，表示为 ϵ_ψ(x_t, t, y)。该方法优化一个由 θ 参数化的单一 3D NeRF，使其与给定的文本提示对齐。给定摄像机参数 c，使用可微分渲染函数 g(·, c) 从 3D NeRF 对摄像机视图 c 的图像进行渲染。在这里，利用渲染后的图像 g(θ, c) 优化权重 θ，通过一个损失函数的梯度可以近似表示为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44220af4950d700aa9c4d299614f4f04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ced828d89964fa9bac81e9bacd1756/" rel="bookmark">
			Ps：八大混合模式及其在色彩渲染上的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在所有的图层混合模式中，有八种比较特别。
特别之处在于，其它的混合模式在修改图层的“不透明度”或“填充”时，效果是一样的。
而这八种混合模式使用“填充”比使用“不透明度”可带来更好的效果，有时甚至可以说是惊艳。
提示：
要了解“不透明度”与“填充”的异同，请在公众号内搜索“不透明度与填充”。
这八种混合模式是：
1、颜色加深 Color Burn
2、线性加深 Linear Burn
3、颜色减淡 Color Dodge
4、线性减淡（添加） Linear Dodge(Add)
5、亮光 Vivid Light
6、线性光 Linear Light
7、实色混合 Hard Mix
8、差值 Difference
◆ ◆ ◆
渲染色彩的两种方法
方法一：纯色调整图层法
1、新建纯色调整图层，选择一种颜色。
2、更改图层混合模式为上述八种之一。
3、调整图层的“填充”值。
4、如果所选颜色不合适，可更改纯色调整图层的颜色，此时可直接看到效果。
还可以通过更改“图层样式”对话框中的“混合颜色带”，以指定色彩影响的范围。
方法二：空白图层法
1、新建空白图层。
2、用白色、黑色或某种颜色画笔涂抹相关区域。
3、更改图层的混合模式为上述八种之一。
4、调整图层的“填充”值。
或者，在“图层样式”对话框中，取消勾选“透明形状图层”，并调整“填充不透明度”，如下图所示。
◆ ◆ ◆
八种混合模式的运用说明
增强暗部颜色
颜色加深模式和线性加深模式都会使得画面整体变暗。
颜色加深模式多用于图层混合后产生强烈的暗部颜色的情况。
相对于颜色加深模式，线性加深模式下的暗部细节更丰富。
增强亮部颜色
颜色减淡和线性减淡（添加）都会使得画面整体变亮。
颜色减淡模式同颜色加深模式一样，也是一种张扬色彩的模式。
即使是用灰图层（或纯白）作为混合色与彩色图像混合，也会增加色彩的饱和度。因此，常用于需要增加饱和度的场合。
相对于线性减淡（添加）模式，颜色减淡模式在亮部的饱和度更高。
增强颜色对比
亮光、线性光和实色混合三种混合模式皆会使得画面产生强烈的对比。
亮光模式是颜色加深和颜色减淡二者的组合，具有使图像明暗反差增大且颜色趋向饱和的特点。
线性光模式也常用于纠正色调不匀的图像。 需要最强冲击力效果及高饱和效果时，可考虑使用实色混合模式。
为亮部或暗部上色
当纯色填充图层使用差值混合模式时，应更多考虑选择的纯色是偏暗还是偏亮。
较亮的纯色可以用来为图像的暗部区域上色，较暗的纯色可以用来为图像的亮部区域上色。
亮部区域的颜色将变为是暗纯色的互补色，比如纯色填充为暗蓝色，则亮部区域渲染上黄色，如上图所示。
而暗部区域则会受亮纯色的直接影响。
“点赞有美意，赞赏是鼓励”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebe8b8a8490124b5c402d7648ff8e997/" rel="bookmark">
			2024年，找算法岗有多难？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下方卡片，关注“CVer”公众号
AI/CV重磅干货，第一时间送达
2024年求职大礼包！最大的AI求职群的元旦节福利活动来了！在此赠送10张30元优惠券！快抢入群，努力备战2024年找工作！
距离2024年春招(补招)不足3个月！
距离2025届校招提前批不足7个月！
距离2025届秋招不足8个月！
Amusi 想问你一句：你准备好了吗？刷题了吗？实习了吗？打比赛了吗？发顶会了吗？对于2025届的同学，硬刚算法，还是转开发岗？大家要尽快确定好！并尽快开始准备，因为年后，招聘节奏就快起来了，时间是不等人的！我觉得今年应届相较于去年，整体求职是回暖的，而且薪资整体是继续上涨的（自驾、大模型、AIGC相关岗位薪资非常可观）。
如果你是明年找工作（实习/校招/社招），想了解到最新的招聘信息和求职攻略， Amusi 推荐大家加入AI算法岗&amp;开发岗求职群，目前已汇集近 5500 人。群里今年2024届不管坚持算法或者转开发的同学基本都找到了工作。
AI算法岗和开发岗求职群介绍
AI算法岗和开发岗求职群（知识星球） 是一个面向全体学生和算法工程师/研究员的求职交流平台。旨在分享 AI算法岗和开发岗的校招/社招准备攻略、面试题库、面试经验、Offer选择、内推机会、学习路线、求职答疑和海量学习资料等内容。
涉及深度学习，机器学习，计算机视觉，图像处理，自然语言处理，SLAM，大数据，数据分析，自动驾驶，机器人，推荐系统，C/C++和Python等方向。
求职群里既有2023届、2024届和往届求职的大佬/学生，也有刚入学的学生（大一/大二/研一等），还有很多公司里的技术大牛、研究员和算法工程师。目前星球的成员已经超过5000人！
我Amusi 每天都会在求职群里发帖/交流，回答问题，分享面试题，分享面试心得，分享内推信息，分享学习资料等。划重点！星球分享的资料和问答已经超过5000条！
注：因为星球里人蛮多的，所以建议大家匿名提问，防止"隐私泄露"
▲扫码，进群！
求职群（部分内容精选）
群主和嘉宾既有2024届/2023届和往届参与秋招拿到算法Offer，也有已经毕业工作多年的算法研究员/工程师。涵盖Apple、谷歌、Facebook、亚马逊、微软、NVIDIA、Uber、IBM、AnyVision、腾讯、阿里巴巴、百度、字节跳动、美团、拼多多、京东、快手、商汤、旷视、依图、云从、滴滴、OPPO、VIVO、华为、小米、大疆、平安科技和文远知行等上百家企业。
面向对象
全体学生和算法工程师/研究员、软件开发程序员，特别是 2024年（即2025届-2026届-2027届）找工作/实习的人群（研一/研二/大二-大四等），也强烈推荐刚入学的学生以及有考虑跳槽的工程师，早点为找工作做准备，锻炼刷题意识和能力。
海量面试经验/面试题
深度学习面试宝典是 Amusi 整理的一个AI算法岗面试题库，累计900+个问题与解答。涉及的领域众多，具体如下。同时求职群里每周都会更新很多面经，方便查漏补缺！
海量校招/实习/社招内推
群里已分享数百个2024届校招内推机会（涵盖BAT/头条/京东/美团等公司），还有大量日常实习内推：
提问交流
如果你在学习、找工作、跳槽、职场、Offer选择等领域遇到问题，都可以在星球里向我提问！我知必答！
资源分享
涵盖刷题指南（LeetCode/剑指Offer）、学习路线、优质AI课程推荐、面试题、面试心得、知识重点分享、实战项目等内容
Offer比较与选择
招聘高峰期（提前批/秋招/春招），几乎每天星球里都会有人来咨询Offer选择性问题，或者转行问题，比如：AAA 和 BBB 哪个公司的Offer更好？
加入求职群(知识星球)方式
价格：199元（每天仅4毛钱） 立减30！特惠仅169元
时长：一年（从你加入的时刻算起）
加入方式：扫码下方二维码，或者点击阅读原文，即可进入AI算法求职群（知识星球）
建议：进群后，推荐下载知识星球APP使用，同时也可使用小程序或者知识星球公众号进行使用，可以发帖/提问/交流/回答，并可以快速访问群里的资源。
希望这个群可以让你少走一些弯路
扫码进群
如果喜欢招聘/面经/内推，麻烦给个在看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eafa71b7264262f2cd6e02f0afc1d3f/" rel="bookmark">
			惋惜！年仅34岁！顶尖985博士英年早逝，导师发文悼念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 点击下方卡片，关注“CVer”公众号
AI/CV重磅干货，第一时间送达
点击进入—&gt;【视觉和Transformer】微信交流群
扫码加入CVer学术星球，可以获得最新顶会/顶刊上的论文idea和CV从入门到精通资料，以及最前沿项目和应用！发论文搞科研，强烈推荐！
12月27日，中国人民大学公共管理学院教授，博士生导师，公共财政与公共政策研究所副所长孙玉栋教授在其个人微信公众号发文，悼念其年仅34岁的弟子庞伟。庞伟去世前微信的签名处还写着“2024年脱单2025年结婚2026年生俩娃。”
据孙教授介绍，庞伟是2012级的硕士，2016级的博士，师徒相识已经有13个年头，是个“不笑不说话、乐于助人、很仁义很坦诚的孩子”。庞伟硕士毕业工作2年后又继续在其门下读博，非常爱钻研，读博期间，发表了16篇高水平的学术论文，还获得了人大的研究生拔尖人才计划的资助。
原本博士毕业后准备做一名大学老师，但在最后的一个环节被拒之门外。在不得已的情况下，庞伟又进站做了两年的博士后。博士后出站后，终于进入了大学做了老师，而且在第一年就拿了教育部的社科基金项目。虽然有挫折，但生活正朝着美好的方向发展，庞伟对未来充满了期待和美好的规划，他微信的签名处还写着“2024年脱单2025年结婚2026年生俩娃。”而生命却戛然而止，年仅34岁。
庞同学太优秀了，真的太可惜。
科研人员的健康状况也再次引起关注。在当前非升即走，内卷的科研界，各种精神压力，加班，熬夜已经是家常便饭。
比如熬夜，早在2007年，国际癌症研究机构（IARC）就把熬夜（包括昼夜节律打乱的轮班工作）定义为2A类致癌物。
近日发表在国际顶刊CELL上的一项研究得出结论：熬夜4天，死亡率达80%！
具体的，在短短4天内，“熬夜”的成年小鼠中有80%死亡，死亡时间在睡眠剥夺开始后的72-96小时不等。在死亡之前，这些小鼠表现出平衡能力的丧失，以及对轻触刺激的反应极小或几乎没有。
科研是一场持久战，不要熬夜，注意休息，懂得放松，保重自己！
版权声明
本文转载自：来源：木东的家园、梅斯医学等，版权属于原作者，仅用于学术分享
CVPR / ICCV 2023论文和代码下载
后台回复：CVPR2023，即可下载CVPR 2023论文和代码开源的论文合集
后台回复：ICCV2023，即可下载ICCV 2023论文和代码开源的论文合集 计算机视觉和Transformer交流群成立 扫描下方二维码，或者添加微信：CVer444，即可添加CVer小助手微信，便可申请加入CVer-计算机视觉或者Transformer 微信交流群。另外其他垂直方向已涵盖：目标检测、图像分割、目标跟踪、人脸检测&amp;识别、OCR、姿态估计、超分辨率、SLAM、医疗影像、Re-ID、GAN、NAS、深度估计、自动驾驶、强化学习、车道线检测、模型剪枝&amp;压缩、去噪、去雾、去雨、风格迁移、遥感图像、行为识别、视频理解、图像融合、图像检索、论文投稿&amp;交流、PyTorch、TensorFlow和Transformer、NeRF等。 一定要备注：研究方向+地点+学校/公司+昵称（如目标检测或者Transformer+上海+上交+卡卡），根据格式备注，可更快被通过且邀请进群 ▲扫码或加微信号: CVer444，进交流群 CVer计算机视觉（知识星球）来了！想要了解最新最快最好的CV/DL/AI论文速递、优质实战项目、AI行业前沿、从入门到精通学习教程等资料，欢迎扫描下方二维码，加入CVer计算机视觉（知识星球），已汇集近万人！ ▲扫码加入星球学习 ▲点击上方卡片，关注CVer公众号 整理不易，请点赞和在看 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/227b85c399d28a1710f1c1c051916f80/" rel="bookmark">
			英伟达RTX 4090D特供版显卡正式发布！售价12999元！性能略微降低
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下方卡片，关注“CVer”公众号
AI/CV重磅干货，第一时间送达
点击进入—&gt;【视觉和Transformer】微信交流群
扫码加入CVer学术星球，可以获得最新顶会/顶刊上的论文idea和CV从入门到精通资料，以及最前沿项目和应用！发论文搞科研，强烈推荐！
转载自：机器之心
性能与原版 RTX 4090 类似，但降低了一些 AI 运算能力。
美国对 AI 计算卡的禁令，终于影响到了普通消费者。
本周四，英伟达正式发布了国内特供版高端消费级显卡 ——GeForce RTX 4090D。
GeForce RTX 4090D 是一款符合美国出口规定的 RTX 4090 新品，配备 14592 个 CUDA 核心、24GB GDDR6X 内存、384 位宽内存总线、425W 额定功耗，定价与 RTX 4090 相同，均为 12999 元（约合 1828 美元）。
为了符合美国出口管制的新规定，与 RTX 4090 相比，RTX 4090D 的一些计算能力指标被削减了，主要改动围绕 CUDA 核心。
相比「标准版」显卡，RTX 4090D 的 CUDA 核心数减少了 12.8%，从 16384 个减少到 14592 个（128 个 SM 减少到 114 个 SM），与此同时，功耗也从 450W 减少到 425W，减少了 5.9%。在此之外，两者之间的所有其他核心规格保持不变，包括 384 位宽总线、24GB GDDR6X 内存和 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/227b85c399d28a1710f1c1c051916f80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85bba03cb287b28a60235abf7810c579/" rel="bookmark">
			【蓝桥杯】比赛大纲整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		枚举[1-3] 排序 （1）冒泡排序[2] （2）选择排序[3] （3）插入排序[3] 搜索(bfs, dfs)[1-5] 贪心[1-5] 模拟[1-3] 二分[2-5] DP(普通一维问题)[3-5] 高精度[1-5] 数据结构 （1）栈[2-4]； （2）队列[2-5] （3）链表 [2-5] 数学 （1）初等数论[3-5] 排序 （1）归并排序[4-5] （2）快速排序[4-5] （3）桶排序[4] （4）堆排序[4] （5）基数排序[4~5] 搜索 （1）剪枝[4-6] （2）双向 BFS[5-6] （3）记忆化搜索[5] （4）迭代加深搜索[5-6] （5）启发式搜索[7] DP （1）背包 DP[4-6] （2）树形 DP[4-6] （3）状压 DP[5-6] （4）数位 DP[5-6] （5）DP 的常见优化[7] 字符串 （1）哈希[4-5] （2）kmp[4-6] （3）manacher[4-6] 15.图论 （1）欧拉回路[5-7] （2）最小生成树[5-7] （3）单源最短路及差分约束系统[5-7] （4）拓扑序列[5-7] （5）二分图匹配[7] （6）图的连通性问题（割点、桥、强连通分量）[7] （7）DFS 序[5-7] （8）最近共同祖先[5-7] 数学 （1）排列组合[5-6] （2）二项式定理[6] （3）容斥原理[6-7] （4）模意义下的逆元[5] （5）矩阵运算[6-7] （6）高斯消元[7] 数据结构 （1）ST 表[5-6] （2）堆[5-6] （3）树状数组[5-6] （4）线段树[6-7] （5）Trie 树[5-7] （6）并查集[5-6] （7）平衡树(利用系统自带的标准库实现简单平衡树)[5-7] 其他 （1）基础计算和基本位置关系判定[6-7] （2）概率论[7+] （3）博弈论[7+] 枚举[1-3] 排序 冒泡排序[2] （2）选择排序[3] （3）插入排序[3] 搜索(bfs, dfs)[1-5] 贪心[1-5] 模拟[1-3] 二分[2-5] DP(普通一维问题)[3-5] 高精度[1-5] 数据结构 栈[2-4]； 队列[2-5] 链表 [2-5] 数学 初等数论[3-5] 排序 归并排序[4-5] 快速排序[4-5] 桶排序[4] 堆排序[4] 基数排序[4~5] 搜索 剪枝[4-6] 双向 BFS[5-6] 记忆化搜索[5] 迭代加深搜索[5-6] 启发式搜索[7] DP 背包 DP[4-6] 树形 DP[4-6] 状压 DP[5-6] 数位 DP[5-6] DP 的常见优化[7] 字符串 哈希[4-5] kmp[4-6] manacher[4-6] 15.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85bba03cb287b28a60235abf7810c579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cddae489c4dc2795aff412abb8b209df/" rel="bookmark">
			一篇文章掌握系统架构的演变和常见微服务框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言
一、系统架构的演变
1、单体应用架构
优点：
缺点：
2、垂直应用架构
优点：
缺点：
3、分布式SOA架构
3.1 什么是SOA
3.2 SOA架构
优点：
缺点：
4、微服务架构
优点：
缺点：
5、SOA与微服务的关系
SOA（ Service Oriented Architecture ）
微服务架构
6、常见微服务框架
6.1 Spring Cloud
主要功能
主要组件
6.2 Spring Cloud Alibaba
主要功能
主要组件
二、总结
前言 随着互联网的发展，网站应用的规模不断扩大，常规的应用架构已无法应对，分布式服务架构以及
微服务架构势在必行，急需一个治理系统确保架构有条不紊的演进。
一、系统架构的演变 1、单体应用架构 Web应用程序发展的早期，大部分web工程(包含前端页面，web层代码，service层代码，dao层代码)是将所有的功能模块，打包到一起并放在一个web容器中运行。
比如搭建一个电商系统：客户下订单，商品展示，用户管理。这种将所有功能都部署在一个web容器中运行的系统就叫做单体架构。
优点： 所有的功能集成在一个项目工程中。
项目架构简单，前期开发成本低，周期短，小型项目的首选。
缺点： 全部功能集成在一个工程中，对于大型项目不易开发、扩展及维护。
系统性能扩展只能通过扩展集群结点，成本高、有瓶颈。
技术栈受限。
2、垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。
优点： 项目架构简单，前期开发成本低，周期短，小型项目的首选。
通过垂直拆分，原来的单体项目不至于无限扩大。
不同的项目可采用不同的技术。
缺点： 全部功能集成在一个工程中，对于大型项目不易开发、扩展及维护。
系统性能扩展只能通过扩展集群结点，成本高、有瓶颈。
3、分布式SOA架构 3.1 什么是SOA SOA 全称为 Service-Oriented Architecture，即面向服务的架构。它可以根据需求通过网络对松散耦合的粗粒度应用组件(服务)进行分布式部署、组合和使用。一个服务通常以独立的形式存在于操作系统进程中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cddae489c4dc2795aff412abb8b209df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/026281994a47e7841c6e5a4c7e7fbe30/" rel="bookmark">
			【Java 进阶篇】深入浅出 Jedis 连接池与工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
在现代的软件开发中，高效地与数据存储系统进行交互是至关重要的。而对于 Redis 这样的高性能键值存储系统，连接池成为了一个不可或缺的工具。本文将围绕 Jedis 连接池及其工具类展开详细解说，让我们一起揭开连接池的神秘面纱。
走进 Redis 与 Jedis Redis，一个强大的内存数据库，以其高性能、支持丰富数据结构和灵活应用而受到开发者的喜爱。而 Jedis，是 Redis 的 Java 客户端，为 Java 开发者提供了便捷的操作接口。
在开始之前，请确保你的项目中已引入 Jedis 依赖。你可以在 Maven 项目的 pom.xml 文件中添加如下依赖：
&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/dependency&gt; 好了，让我们开始探讨 Jedis 连接池的奇妙之旅吧！
什么是连接池？ 在传统的数据库交互中，每次需要与数据库建立连接时都会进行网络通信，这是一个相对昂贵的过程。连接池的出现就是为了解决这个问题。连接池通过在应用程序启动时创建一些连接并将它们保存在池中，当需要与数据库进行通信时，应用程序就可以从连接池中获取一个连接，而不是每次都重新创建连接。
这样做有很多好处，比如减少连接创建和销毁的开销、提高性能、防止连接泄漏等。而 Jedis 连接池则是为了更好地与 Redis 服务器进行通信而设计的。
Jedis 连接池的基本使用 1. 创建 Jedis 连接池 在 Jedis 中，通过 JedisPool 类来创建连接池。以下是一个简单的例子：
import redis.clients.jedis.JedisPool; import redis.clients.jedis.JedisPoolConfig; public class JedisPoolExample { public static void main(String[] args) { // 配置连接池 JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/026281994a47e7841c6e5a4c7e7fbe30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b0de6bfb895fd7908102fa5dd3bf1a5/" rel="bookmark">
			【Java 进阶篇】Redis 缓存优化：提升应用性能的不二选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代的软件开发中，性能一直是开发者们追求的目标之一。对于数据库访问频繁、数据读取较慢的场景，使用缓存是提升性能的有效手段之一。而 Redis 作为一款高性能的内存数据库，被广泛用作缓存工具。本文将围绕 Redis 缓存优化进行详解，为你揭示如何通过优化缓存提升应用性能的奥秘。
缓存的魅力 缓存，就像是一位贴心的助手，可以加速应用程序的许多操作。它通过将一些计算结果或者数据库查询结果保存在快速访问的地方，使得后续相同的请求可以更快地获取到数据，减轻数据库的压力。在这个过程中，Redis 这个“魔法盒子”就成了许多开发者心中的明星。
Redis 缓存基础 在使用 Redis 缓存之前，我们需要先理解 Redis 的基本概念和基础操作。Redis 是一款基于内存的键值存储系统，它提供了多种数据结构，如字符串、哈希、列表、集合、有序集合等。这些数据结构为我们提供了灵活的缓存选择。
字符串缓存 首先，我们来看一个简单的字符串缓存示例：
import redis.clients.jedis.Jedis; public class RedisStringCacheExample { public static void main(String[] args) { // 连接到本地的 Redis 服务器 Jedis jedis = new Jedis("localhost", 6379); System.out.println("连接成功"); // 缓存数据 jedis.set("username:1001", "Alice"); jedis.set("username:1002", "Bob"); // 从缓存中获取数据 String user1 = jedis.get("username:1001"); String user2 = jedis.get("username:1002"); // 打印结果 System.out.println("用户1001：" + user1); System.out.println("用户1002：" + user2); // 关闭连接 jedis.close(); } } 在这个示例中，我们使用了 Redis 的字符串数据结构。通过 set 方法缓存了两个用户的用户名，然后通过 get 方法从缓存中获取了这些数据。这是一个简单而直观的缓存例子。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b0de6bfb895fd7908102fa5dd3bf1a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23cb074642f99003919007dd996b78f3/" rel="bookmark">
			day3双指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入一字符串，然后将该字符串中的单词分割开来
#include &lt;iostream&gt; #include &lt;string.h&gt; using namespace std; int main() { char str[1000]; gets(str); int n=strlen(str); for(int i=0;i&lt;n;i++){ int j=i; while(str[j]!=' '&amp;&amp;j&lt;n) j++; for(int k=i;k&lt;j;k++) cout &lt;&lt; str[k]; cout &lt;&lt; endl; i=j; } return 0; } //有的C++编译器已无法编译gets,可用Dev++运行该代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e23e87e2a652e01940928024ff459c0/" rel="bookmark">
			CSS3学习之01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		box-sizing:
border-box：width是整体的大小
content-box：width是内容区大小
flex box弹性布局
弹性布局子元素通常在同一行内显示。
flex-direction：布局内子元素的排列方式
row：默认从左到右
row-reverse：从右到左
column：从上到下
column-reverse：从下到上
justify-content属性
内容对齐：把弹性元素沿着弹性容器的主轴线对齐。
fiex-start-默认值-左对齐
flex-end-右对齐
center：居中
space-between：左右对齐
space-around：均分
align-items
flex-start：
flex-wrap：指定弹性盒子的子元素换行方式
nowrap：默认，弹性容器为单行，该情况下弹性子项可能会溢出容器
wrap：多行，溢出的部分会放置到新行
wrap-reverse：反转
initial
inherit
flex：指定子元素如何分配空间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb86b477d2d1ab3178c43370d565ff78/" rel="bookmark">
			【kafka】Kafka 日志留存策略、清理策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 上一篇文章：【kafka】kafka日志文件清理策略
转载：关于 Kafka 日志留存策略的讨论
关于 Kafka 日志留存 (log retention) 策略的介绍，网上已有很多文章。不过目前其策略已然发生了一些变化，故本文针对较新版本的 Kafka 做一次统一的讨论。如果没有显式说明，本文一律以 Kafka 1.0.0 作为分析对象。
所谓日志留存策略，就是 Kafka 保存 topic 数据的规则，我将按照以下几个方面分别介绍留存策略：
留存策略类型 留存机制及其工作原理 2.一、留存策略类型 目前，与日志留存方式相关的策略类型主要有两种：delete 和 compact。这两种留存方式的机制完全不同。本文主要讨论针对 delete 类型的留存策略。用户可以通过设置 broker 端参数 log.cleanup.policy 来指定集群上所有 topic 默认的策略类型。另外也可以通过 topic 级别参数 cleanup.policy 来为某些 topic 设置不同于默认值的策略类型。当前 log.cleanup.policy 参数的默认值是 [delete,compact]，这是一个 list 类型的参数，表示集群上所有 topic 会同时开启 delete 和 compact 两种留存策略 —— 这是 0.10.1.0 新引入的功能，在 0.10.1.0 之前，该参数只能两选一，不能同时兼顾，但在实际使用中很多用户都抱怨 compact 类型的 topic 存在过期 key 消息未删除的情况，故社区修改了该参数配置，允许一个 topic 同时开启两种留存策略。
再次强调下， 本文只讨论 delete 类型的留存策略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb86b477d2d1ab3178c43370d565ff78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2b365961f4fd87b34a1705ecb846f49/" rel="bookmark">
			机器学习距离度量方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 机器学习中为什么要度量距离？ 机器学习算法中，经常需要 判断两个样本之间是否相似 ，比如KNN，K-means，推荐算法中的协同过滤等等，常用的套路是 将相似的判断转换成距离的计算 ，距离近的样本相似程度高，距离远的相似程度低。所以度量距离是很多算法中的关键步骤。
KNN算法中要求数据的所有特征都用数值表示。若在数据特征中存在非数值类型，必须采用手段将其进行量化为数值。
比如样本特征中包含有颜色（红、绿、蓝）一项，颜色之间没有距离可言，可通过将颜色转化为 灰度值来实现距离计算 。
每个特征都用数值表示，样本之间就可以计算出彼此的距离来
接下来介绍几种距离度量方法
2. 欧式距离 3. 曼哈顿距离 4. 切比雪夫距离 国际象棋棋盘上二个位置间的切比雪夫距离是指王要从一个位置移至另一个位置需要走的步数。(王可以往斜前或斜后方向移动一格)
5. 闵式距离 闵氏距离不是一种距离，而是一组距离的定义，是对多个距离度量公式的概括性的表述。
其中p是一个变参数：
当 p=1 时，就是曼哈顿距离；
当 p=2 时，就是欧氏距离；
当 p→∞ 时，就是切比雪夫距离。
根据 p 的不同，闵氏距离可以表示某一类/种的距离。
6. 小结 欧式距离、曼哈顿距离、切比雪夫距离是最常用的距离
闵式距离是一组距离的度量，当 p = 1 时代表曼哈顿距离，当 p = 2 时代表欧式距离，当 p = ∞ 时代表切比雪夫距离
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb031a2c52ab77950e6095fd5cfe6b91/" rel="bookmark">
			基于yolov2深度学习网络的血细胞检测算法matlab仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.算法运行效果图预览
2.算法运行软件版本
3.部分核心程序
4.算法理论概述
4.1YOLOv2算法原理
4.2 YOLOv2网络结构
4.3 血细胞检测算法实现
数据集准备
数据预处理
网络训练
模型评估与优化
5.算法完整程序工程
1.算法运行效果图预览 2.算法运行软件版本 MATLAB2022a
3.部分核心程序 ......................................................................... load yolov2.mat% 加载训练好的目标检测器 img_size= [224,224]; imgPath = 'test/'; % 图像库路径 imgDir = dir([imgPath '*.jpeg']); % 遍历所有jpg格式文件 cnt = 0; for i = 1:64 % 遍历结构体就可以一一处理图片了 i if mod(i,16)==1 figure end cnt = cnt+1; subplot(4,4,cnt); img = imread([imgPath imgDir(i).name]); %读取每张图片 I = imresize(img,img_size(1:2)); [bboxes,scores] = detect(detector,I,'Threshold',0.15); if ~isempty(bboxes) % 如果检测到目标 [Vs,Is] = max(scores); I = insertObjectAnnotation(I,'rectangle',bboxes(Is,:),Vs,LineWidth=3);% 在图像上绘制检测结果 end subplot(4,4,cnt); imshow(I, []); % 显示带有检测结果的图像 pause(0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb031a2c52ab77950e6095fd5cfe6b91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc8afd99d978db7fef80b5487057606a/" rel="bookmark">
			基于huffman编解码的图像压缩算法matlab仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.算法运行效果图预览
2.算法运行软件版本
3.部分核心程序
4.算法理论概述
4.1 Huffman编码算法步骤
4.2 Huffman编码的数学原理
4.3 基于Huffman编解码的图像压缩
5.算法完整程序工程
1.算法运行效果图预览 2.算法运行软件版本 matlab2022a
3.部分核心程序 ......................................................................... for ij = 1:size(I0,3) I = I0(:,:,ij); [m,n] = size(I); % 将当前通道的图像展平为一维向量 Ivect = I(:); % 获取当前通道的唯一像素值和它们的频率 symb = single(unique(Ivect)); cnts = hist(Ivect, symb); Probs = double(cnts) ./ sum(cnts); % 计算Huffman编码字典和平均长度 [dictionary,Lens(ij)] = func_huffdict(symb,Probs); % 对当前通道的图像进行Huffman编码 Ienc = func_huffencode(symb,dictionary,Ivect); % 对Huffman编码进行解码，得到无损压缩后的像素值 Idec = func_huffdecode(symb,dictionary,Ienc); % 将解码后的一维向量重塑为二维图像 Iout(:,:,ij) = reshape(Idec,m,[]); end % 将无损压缩后的图像保存为JPEG格式 imwrite(Iout,'cmps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc8afd99d978db7fef80b5487057606a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fe5231ed6ab6f4ea5136649351f7076/" rel="bookmark">
			【GIT操作】git如何合并多个commit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【GIT操作】如何合并多个commit 场景 在单个分支中有着多次commit，并push到了远程分支上。假设分支的commit如下图，一共有5次commit。
1 2 3 4 5 计划将第二次commit至第五次commit合并成一个commit。合并效果，如下图。
1 5' 操作步骤 通过git bash工具交互式操作。
查询commit的commitID
git log --oneline --oneline参数，代表将每个commit压缩成一行，只显示commitID和commit message的第一行。
d5ace53 第5次commit 25d5ae5 第4次commit 73c98f9 第3次commit a50f132 第2次commit d5d1335 第1次commit 变基到第一次commit，开启交互式操作。
git rebase -i d5d1335 -i参数，代表展开交互界面
pick a50f132 第2次commit pick 73c98f9 第3次commit pick 25d5ae5 第4次commit pick d5ace53 第5次commit # Rebase d5d1335..d5ace53 onto d5d1335 (4 command) # # Commands: # p, pick &lt;commit&gt; = use commit # r, reword &lt;commit&gt; = use commit, but edit the commit message # e, edit &lt;commit&gt; = use commit, but stop for amending # s, squash &lt;commit&gt; = use commit, but meld into previous commit # f, fixup [-C | -c] &lt;commit&gt; = like "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fe5231ed6ab6f4ea5136649351f7076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d5e86465d9d60e3c8561d040b5bd4f6/" rel="bookmark">
			机器学习（二） -- 数据预处理（更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 未完待续……
目录
系列文章目录
前言
一、数值分析简介
二、内容
前言 tips：这里只是总结，不是教程哈。
“***”开头的是给好奇心重的宝宝看的，其实不太重要可以跳过。
此处以下所有内容均为暂定，因为我还没找到一个好的，让小白（我自己）也能容易理解（更系统、嗯应该是宏观）的讲解顺序与方式。
第一文主要简述了一下机器学习大致有哪些东西（当然远远不止这些），对大体框架有了一定了解。接着我们根据机器学习的流程一步步来学习吧，掐掉其他不太用得上我们的步骤，精练起来就4步（数据预处理，特征工程，训练模型，模型评估），其中训练模型则是我们的重头戏，基本上所有算法也都是这一步，so，这个最后写，先把其他三个讲了，然后，在结合这三步来进行算法的学习，兴许会好点（个人拙见）。
一、概述 还是先拿出咱们的老朋友，机器学习的流程图。
咱们这主要将数据预处理，而要进行机器学习首先需要数据，然后才能对数据进行预处理。
实际一点讲：数据清理、数据集成、数据变换、数据规约都是数据预处理的主要步骤，但是这四个没有严格意义上的先后顺序，在实际应用时并非全部会被使用（可能一个也不用，比如后面我们直接调用官方的iris包，但在实际自己获得的数据集中就会有各种各样的问题，视情况而定）
二、数据获取 获取数据途径多种多样，（括号内为废话：按理来讲，当今世界数据就是财富，一般而言别人的数据是不可能透露给你的，如果你和我一样还是个学生，可能可以从老师那里拿到数据），我们学习一般使用的是公开的数据集，如下为sklearn数据集（也是需要先安装sklearn库的哈）
（iris为例）（load*与fetch*的差别是，fetch还需要从网上下载，而load已经在datasets中了，也就是安装好sklearn就可以直接使用）
from sklearn.datasets import load_iris iris = load_iris() 这样就获取到一个数据集了，但是我们还不知道这个数据集的其他性质。load*函数和feth*函数返回的数据类型是 datasets.base.Bunch，本质上是一个 dict，它的键值对可用通过对象的属性方式访问。（我用IDE的是Jupyter Notebook）
主要包含以下属性：
DESCR数据描述feature_names特征名target_names标签名data特征数据数组target标签数组filename真实的文件地址frame特殊返回值 1、DESCR print(data.DESCR) 从数据集描述中我们可以得到大量信息，150条数据，4个属性，分为3类等等
2、feature_names print(iris.feature_names) 4个属性（特征）分别是花萼长度、花萼宽度、花瓣长度和花瓣宽度。
3、target_names print(iris.target_names) 3种分类为三鸢尾、变色鸢尾、维吉尼亚鸢尾（好吧，这个不重要）
4、data print(iris.data) 5、target print(iris.target) （刚好150条，你们快数数，坏笑QvQ）
6、***filename 导入的数据的绝对路径文件名
7、***frame 特殊返回值，其实用不到。
8、绘图查看 在平面上只好展示二维属性对应样本的分类，想看其他属性对应样本的分类对比，更换feature1、feature2的数即可。
import numpy as np import matplotlib.pyplot as plt import pandas as pd plt.rcParams['font.sans-serif'] = 'SimHei' # 设置字体为SimHei # 显示中文 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d5e86465d9d60e3c8561d040b5bd4f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6dd0b76f17f16c86629f1fbd31d0db0/" rel="bookmark">
			[足式机器人]Part2 Dr. CAN学习笔记-自动控制原理Ch1-6根轨迹Root locus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅供学习使用
本文参考：
B站：DR_CAN
Dr. CAN学习笔记-自动控制原理Ch1-6根轨迹Root locus 1. 根的作用2. 手绘技巧3. 分离点/汇合点&amp;根轨迹的几何性质 1. 根的作用 G ( s ) = s + 3 s 2 + 2 s + 4 G\left( s \right) =\frac{s+3}{s^2+2s+4} G(s)=s2+2s+4s+3​
Matlab可绘制 riocus(g)
掌握根的变化规律 ， 设计控制器，补偿器 ： Compentator Lead Lag…
根 —— 极点
一阶系统
二阶系统
三阶系统
2. 手绘技巧 Matlab可以精确绘制——手绘——掌握根的变化规律——设计控制器
根轨迹的基本形式
根轨迹研究的是： 当 K K K从0到 + ∞ +\infty +∞时，闭环系统根（极点）位置的变化规律
1 + K G ( s ) = 0 , G ( s ) = N ( s ) D ( s ) = ( s − z 1 ) ( s − z 2 ) ⋯ ( s − z m ) ( s − p 1 ) ( s − p 2 ) ⋯ ( s − p n ) 1+KG\left( s \right) =0,G\left( s \right) =\frac{N\left( s \right)}{D\left( s \right)}=\frac{\left( s-z_1 \right) \left( s-z_2 \right) \cdots \left( s-z_{\mathrm{m}} \right)}{\left( s-p_1 \right) \left( s-p_2 \right) \cdots \left( s-p_{\mathrm{n}} \right)} 1+KG(s)=0,G(s)=D(s)N(s)​=(s−p1​)(s−p2​)⋯(s−pn​)(s−z1​)(s−z2​)⋯(s−zm​)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6dd0b76f17f16c86629f1fbd31d0db0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b58878e659d9fd7bea1182d38c1e5196/" rel="bookmark">
			Docker搭建kafka集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker搭建kafka集群 kafka概念 broker：消息中间件处理节点，一个broker就是一个kafka节点，一个或者多个broker就组成了一个kafka集群topic：kafka根据topic对消息进行归类，发布到kafka集群的每个消息，都要指定一个topicproducer：消息生产者，向broker发送消息的客户端consumer：消息消费者，从broker读取消息的客户端 kafka特性描述 生产者将消息发送给broker，broker会将消息保存在本地的日志文件中消息的保存是有序的，通过offset偏移量来描述消息的有序性消费者消费消息时，也是通过offset来描述当前要消费的那条消息的位置 消息相关 如果多个消费者在同一个消费者组中，那么只有一个消费者可以收到订阅topic中的消息，换言之，同一个消费组中只有一个消费者能收到一个topic中的消息多播消息：不同的消费组订阅同一个topic，不同的消费组中只有一个消费者能收到消息，实际上也是多个消费组中的多个消费者收到了消息 Controller、Rebalance、HW Controller Kafka集群中的broker在zk中创建节点的时候，会有一个临时节点序号，序号最小的节点，会被当做集群的controller，负责管理集群中的所有分区和副本的状态当某个分区的leader副本出现故障，由控制器负责为该分区选举新的leader副本当检测到某个分区的ISR集合发生变化的时候，由控制器负责通知所有的broker更新其元数据信息当使用kafka-topic.sh脚本为某个topic增加分区数量的时候，同样还是由控制器负责让新分区被其它节点感知到 Rebalance 前提是消费者没有指定分区进行消费，当消费组中的消费者或者分区关系发生变化的时候，就会触发rebalance机制，这个机制会调整消费者消费哪个分区在触发rebalance机制之前，消费者消费哪个分区有三种策略： range：通过公示来计算某个消费者消费哪个分区轮询：所有消费者轮着消费sticky：在触发了rebalance后，在消费者消费的原分区不变的基础上进行调整 HW和LEO LEO是某个副本最后消息的消息位置（log-end-offset）HW是已完成同步的位置，消息在写入broker时，且每个broker都完成了这条消息的同步后，hw才会变化，这之前，消费者是消费不到这条消息的，同步完成后，HW调整后，消费者才能消费这条消息，这样做是为了方式消息丢失 kafka消息积压问题 消息积压问题的出现：消息的消费者的消费速度远远赶不上生产者生产消息的速度，导致kafka中有大量的数据没有被消费，随着没有被消费的消息越来越多，消费者寻址的性能越来越差，最后导致整个kafka对外提供的服务的性能越来越差，从而造成其它服务的访问速度很慢，造成服务雪崩。消息积压的解决方案： 在这个消费者中，使用多线程，充分利用机器的性能进行消费消息；
创建多个消费组，多个消费者，部署到其它机器上，一起消费，提高消费者消费消息的速度；创建一个消费者，该消费者在kafka另建一个主题，配上多个分区，多个分区再配上多个消费者，该消费者poll下来的消息，直接转发到新的主题上，使用多个消费者消费新主题的消息–该方法不常用 Docker 搭建kafka集群 docker下载kafka镜像 docker search kafka docker pull bitnami/kafka 启动3个kafka节点，组成集群 docker run -d --name kafka1 --network mynetwork \ -p 9092:9092 \ --env KAFKA_BROKER_ID=0 \ --env KAFKA_ZOOKEEPER_CONNECT=192.168.228.2:2181,92.168.228.3:2181,92.168.228.4:2181 \ --env KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.228.5:9092 \ --env KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 bitnami/kafka docker run -d --name kafka2 --network mynetwork \ -p 9093:9092 \ --env KAFKA_BROKER_ID=1 \ --env KAFKA_ZOOKEEPER_CONNECT=192.168.228.2:2181,92.168.228.3:2181,92.168.228.4:2181 \ --env KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b58878e659d9fd7bea1182d38c1e5196/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b29679dac1f628af8d8d713b19dc06/" rel="bookmark">
			网工实验笔记：SNMP的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验需求 理解SNMP的原理掌握SNMP的配置方法 二、实验拓扑 实验拓扑如图所示：
三、实验步骤 步骤1：cloud1的配置，Cloud1的配置，使用windows系统的虚拟网卡桥接到eNSP模拟器
第一步：双击“云”图标，打开“云配置界面”，如图所示：
第二步：创建UDP端口，在“绑定信息”中选择UDP，然后点击增加，配置如图所示：
第三步：根据已创建的端口信息，配置端口映射，在“”绑定信息中选择“host-only”,点击增加，在“端口映射设置”中“入端口编号”选择1，“出端口编号“选择2，然后勾选”双向通信“，点击”增加“，如图所示：
【技术要点】
通过以上操作，可以让eNSP中的路由器与读者电脑上的软件进行通过。
步骤2：配置路由器R1的IP地址
&lt;Huawei&gt;system-view [Huawei]undo info-center enable [Huawei]sysname R1
[R1]interface e0/0/0
[R1-Ethernet0/0/0]ip address 192.168.56.2 24
[R1-Ethernet0/0/0]undo shutdown [R1-Ethernet0/0/0]quit
步骤3：开启SNMP
[R1]snmp-agent //使能SNMP代理功能
[R1]snmp-agent community read hcia //读的密码设置为hcia
[R1]snmp-agent community write hcip //写的密码设置为hcia
[R1]snmp-agent sys-info version v1 //配置SNMP的版本
四、实验调试 1、配置用户参数，操作步骤如图所示：
2、查询路由器的名字
第一步：点击MIB Tree-iso-org-dod-internet-mgmt-system，然后找到sysName，操作步骤如图所示：
第二步：发送get请求，点击右键，双击“Get“，操作如图所示：
3、查询接口IP地址，操作步骤如图所示：
【技术要点】SNMP客户端工具MIB Browser介绍
SNMP客户端工具MIB Browser全名iReasoning MIB Browser，是一个功能强大、易于使用的MIB管理工具，支持Windows,Linux,MACOS等多种平台。它通过SNMP协议管理网络设备，它可以加载标准的和私有的MIB。本实验只介绍了它的基本使用方法，如果读者想进行深一步的学习请访问官网http://ireasoning.com/
更多实验拓扑资料，可领取
实验拓扑（部分示意）
关注+点赞后，文章底部找我领取！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec1d6596032549f76151461f33efbd4/" rel="bookmark">
			一篇文章深入认识微服务SpringCloud和Dubbo的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、SpringCloud是什么 SpringCloud, 基于SpringBoot提供了一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件，除了基于NetFlix的开源组件做高度抽象封装之外，还有一些选型中立的开源组件。
SpringCloud是目前国内使用最广泛的微服务框架。
SpringCloud官网地址：Spring Cloud。
SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。
其中常见的组件包括：
1.SpringCloud优点 SpringCloud利用SpringBoot的开发便利性，巧妙地简化了分布式系统基础设施的开发，SpringCloud为开发人员提供了快速构建分布式系统的一些工具，包括配置管理，服务发现，断路器，路由，微代理，事件总线，全局锁，决策竞选，分布式会话等等，他们都可以用SpringBoot的开发风格做到一键启动和部署。
SpringBoot并没有重复造轮子，它只是将目前各家公司开发的比较成熟，经得起实际考研的服务框架组合起来，通过SpringBoot风格进行再封装，屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂，易部署和易维护的分布式系统开发工具包。
SpringCloud是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶。
2.SpringCloud缺点 Spring Cloud因其涵盖的内容非常广泛，因此对于很多初学者来说就像被专业名词轰炸了一样， 入门的难度也就大大提高了。 同时， 中文文档与资料的匮乏，以及官方文档的内容对于使用描述并不够细致等问题， 也直接提升了使用者的学习门槛。
2、SpringCloud和SpringBoot关系 SpringBoot专注于快速方便的开发单个个体微服务。
SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供：配置管理，服务发现，断路器，路由，微代理，事件总线，全局锁，决策竞选，分布式会话等等集成服务。
SpringBoot可以离开SpringClooud独立使用，开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系。
SpringBoot专注于快速、方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架。
3、Dubbo和SpringCloud对比 对比DubboSpringCloud服务注册中心服务注册中心Spring Cloud Netfilx Eureka服务调用方式RPCREST API服务监控Dubbo-monitorSpring Boot Admin断路器不完善Spring Cloud Netflix Hystrix服务网关无Spring Cloud Netflix Zuul分布式配置无Spring Cloud Config服务跟踪无Spring Cloud Sleuth消息总线无Spring Cloud Bus数据流无Spring Cloud Stream批量任务无Spring Cloud Task 1.最大区别 SpringCloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式。
严格来说，这两种方式各有优劣。虽然从一定程度上来说，SpringCloud 牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适。
2.品牌机与组装机的区别 很明显，Spring Cloud的功能比Dubbo更加强大，涵盖面更广，而且作为Spring的全家桶项目，它也能够与Spring Framework、Spring Boot、Spring Data、Spring Batch等其他Spring项目完美融合，这些对于微服务而言是至关重要的。
使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一名高手，那这些都不是问题；而Spring Cloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但是如果要在使用非原装组件外的东西，就需要对其基础有足够的了解。
3.社区支持与更新力度 最为重要的是，Dubbo停止了5年左右的更新，虽然2017.7重启了。对于技术发展的新需求，需要由开发者自行拓展升级（比如当当网弄出了DubboX），这对于很多想要采用微服务架构的中小软件组织，显然是不太合适的，中小公司没有这么强大的技术能力去修改Dubbo源码+周边的一整套解决方案，并不是每一个公司都有阿里的大牛+真实的线上生产环境测试过。
4.总结 解决的问题域不一样：Dubbo的定位是一款RPC框架，Spring Cloud的目标是微服务架构下的一站式解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fb1b9867a9d5fd8fa6215bb36ca2375/" rel="bookmark">
			【数据结构】快速排序(4种方式实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：前面我们学习了几种相对比较简单的排序，今天我们要一起学习的是快速排序，我们将通过四种方式来模拟实现快排。
💖 博主CSDN主页:卫卫卫的个人主页 💞
👉 专栏分类:数据结构 👈
💯代码仓库:卫卫周大胖的学习日记💫
💪关注博主和博主一起学习!一起努力！
C语言算法-快速排序 什么是快速排序 任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。
快速排序之hoare版 hoare思想 1.首先我们选定一个基准值，通常是数组中的第一个元素。
2. 定义俩个指针，一个left一个right分别在数组的最左边和最右边。
3. 我们让右指针先走，如果比我们定义的基准值小就停下来。
4. 右指针走完我们在让左指针走，如果比我们定义的基准值小也停下来。
5. 在俩个指针都停下来的时候把它们的值进行交换，以此反复循环直到俩个指针相遇，我们把基准值和它们的值进行交换。
6. 最终这一趟下来我们会得到如下图一样的数据，基准值左边的都比基准值小，右边的都比基准值大。
7. 我们把这一趟走完后在重新分为左右俩个部分的数据，在用此方法以此往复即可实现一个有序数组。
代码思路：刚刚我们用那个思想可以实现一次的排序过程，可是排完一次那剩下的怎么排呢？我们可以把这个问题拆成许多个小问题(如下图所示)，因此我们可以采用递归的思想来实现它。
代码实现:
void QuickSort1(int* a,int begin, int end)//快速排序 -- hoare { int right = end; int left = begin; int key = begin; if (begin &gt;= end) { return; } while (left &lt; right) { while (a[right] &gt;= a[key] &amp;&amp; right &gt;left) { right--; } while (a[left] &lt;= a[key] &amp;&amp; right &gt; left) { left++; } Swap(&amp;a[right], &amp;a[left]); } Swap(&amp;a[key], &amp;a[left]); key = left; QuickSort1(a, begin, left - 1);//左边 QuickSort1(a, key+1, end);//右边 } 测试函数:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fb1b9867a9d5fd8fa6215bb36ca2375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8d48fedb4f0e664084c3e9899a4e8d5/" rel="bookmark">
			昇腾910平台安装驱动、固件、CANN toolkit、pytorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文使用的昇腾910平台操作系统是openEuler，之前没了解过，不过暂时感觉用起来和centOS差不多。系统架构是ARM，安装包基本都是带aarch64字样，注意和x86_64区别开，别下错了。
安装依赖 cmake 通过yum安装的cmake版本较老，需要源代码安装
wget https://cmake.org/files/v3.21/cmake-3.21.3.tar.gz tar -zxvf cmake-3.21.3.tar.gz cd cmake-3.21.3 ./bootstrap gmake -j16 sudo gmake install anaconda 使用系统自带的python3也可以，不过anaconda的虚拟环境我用习惯了，感觉很方便。
在https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ 直接找最新的版本。我用的是https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2023.09-0-Linux-aarch64.sh
安装完别忘记把环境变量加入.bashrc文件。
其它依赖 yum install -y gcc gcc-c++ make cmake unzip zlib-devel libffi-devel openssl-devel pciutils net-tools sqlite-devel lapack-devel gcc-gfortran 卸载旧的驱动、固件、CANN toolkit 卸载驱动 cd /usr/local/Ascend/driver/script bash uninstall.sh 卸载固件 cd /usr/local/Ascend/firmware/script bash uninstall.sh 卸载nnae cd /usr/local/Ascend/nnae/6.3.RC1/script bash uninstall.sh 卸载ascend-toolkit cd /usr/local/Ascend/ascend-toolkit/ bash cann_uninstall.sh /ascend-toolkit文件夹下可能安装了多个版本，用下面的命令找一下这些版本脚本位置，都卸载干净：
find . -type f -name "cann_uninstall.sh" 安装驱动和固件 下载链接 https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8d48fedb4f0e664084c3e9899a4e8d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e079168fbc3fe743631fe1d4b4363ee/" rel="bookmark">
			Jetson Orin安装riva以及llamaspeak，使用 Riva ASR/TTS 与 Llama 进行实时交谈，大语言模型成功运行笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NVIDIA 的综合语音 AI 工具包 RIVA 可以处理这种情况。此外，RIVA 可以构建应用程序，在本地设备（如 NVIDIA Jetson）上处理所有这些内容。
RIVA 是一个综合性库，包括：
自动语音识别 （ASR）文本转语音合成 （TTS）神经机器翻译 （NMT）（语言到语言的翻译，例如英语到西班牙语）自然语言处理 （NLP） 服务的集合，例如命名实体识别 （NER）、标点符号和意图分类。 RIVA 在运行 JetPack 5 及更高版本的 Jetson Orin 和 Xavier 系列处理器上运行。在视频中，我们使用的是Jetson Orin模组和国产载板,usb免驱声卡和麦克风耳机。
riva和ngc的安装和测试 安装 通常，我们不涵盖演练安装。然而，这已经足够具有挑战性了，值得写这篇文章。RIVA 目前处于 Jetsons 的测试阶段（表示为 ARM64 或嵌入在 NVIDIA 文档中的多个位置）。您可能会发现，随着时间的流逝，某些方向会发生变化。
话虽如此，如果您是初学者，这可能有点困难。我们假设您正在关注视频。所以我尽可能的多写一些步骤。
RIVA 快速入门指南 您需要遵循 RIVA 快速入门指南。您应该能够按照操作，从“嵌入式”部分开始。您需要访问 NVIDIA NGC。NVIDIA NGC 是 NVIDIA AI 的仓库。NGC 需要一个免费的开发者帐户。NVIDIA有几个关于设置帐户和获取开发者密钥的视频：
注册 NGC 并生成 API 密钥NGC 配置集演练 NGC CLI 入门 — ngc-cli documentation (nvidia.com)
ARM64 Linux Install The NGC CLI binary for ARM64 is supported on Ubuntu 18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e079168fbc3fe743631fe1d4b4363ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d0abb84ed19f69e99831aa5a9a1e0a/" rel="bookmark">
			Video面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Video面试题 video标签的作用是什么？
答案：&lt;video&gt;标签用于在网页上嵌入视频内容，让用户可以直接在网页上播放视频。 如何在网页上嵌入视频？
答案：可以使用&lt;video&gt;标签，并设置src属性指向视频文件的URL，如：&lt;video src="video.mp4"&gt;&lt;/video&gt;。 video标签的常用属性有哪些？
答案：常用属性包括src（视频文件的URL）、controls（显示视频控制条）、autoplay（自动播放视频）、loop（循环播放视频）等。 如何控制视频的播放和暂停？
答案：可以使用JavaScript来控制视频的播放和暂停，通过play()方法来播放视频，pause()方法来暂停视频。 video标签支持哪些视频格式？
答案：&lt;video&gt;标签支持多种视频格式，包括MP4、WebM、Ogg等，可以通过提供多个不同格式的视频源来增加兼容性。 如何在视频播放时显示自定义的控制条？
答案：可以通过使用controls属性来显示默认的控制条，或者自定义控制条，使用JavaScript操作视频的播放、暂停、音量等功能。 如何实现视频的自动播放？
答案：可以在&lt;video&gt;标签中添加autoplay属性，如：&lt;video src="video.mp4" autoplay&gt;&lt;/video&gt;，视频将在加载完成后自动播放。 如何监听视频的播放事件？
答案：可以使用JavaScript的addEventListener方法，监听play事件来捕捉视频的播放动作，如：video.addEventListener('play', function() { // 播放事件处理逻辑 })。 如何设置视频的尺寸和样式？
答案：可以使用CSS来设置视频的尺寸和样式，通过设置width和height属性来指定视频的宽度和高度，或者使用CSS选择器选择&lt;video&gt;标签来设置样式。 如何在视频播放结束后执行某个操作？
答案：可以监听视频的ended事件，当视频播放结束时触发相应的操作，如：video.addEventListener('ended', function() { // 播放结束后的操作逻辑 })。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c2005269c490993b2958c9b45be1c4/" rel="bookmark">
			CSS3的面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS3中的盒模型与CSS2中的盒模型有何区别？
答案：CSS2中的盒模型将元素的宽度（width）定义为内容区域的宽度，而CSS3中的盒模型将元素的宽度包括了内边距（padding）、边框（border）和外边距（margin）。 解释一下CSS3中的选择器级别以及它们的优先级顺序。
答案：CSS3中的选择器级别包括：元素选择器、类选择器、ID选择器、属性选择器、伪类选择器和伪元素选择器。它们的优先级顺序是：ID选择器 &gt; 类选择器、属性选择器和伪类选择器 &gt; 元素选择器 &gt; 伪元素选择器。 请列出至少五个CSS3中常用的动画属性，并简要说明它们的作用。
答案：常用的CSS3动画属性包括：animation-name（指定动画名称）、animation-duration（指定动画持续时间）、animation-delay（指定动画延迟时间）、animation-iteration-count（指定动画循环次数）、animation-timing-function（指定动画的时间函数）等。这些属性可以用来创建各种动画效果。 如何使用CSS3实现圆角效果？请提供相关代码示例。
答案：可以使用border-radius属性来实现圆角效果。例如，border-radius: 10px;会将元素的四个角都设置为半径为10px的圆角。 请解释一下CSS3中的渐变（gradient）是如何工作的，以及它的应用场景。
答案：CSS3中的渐变可以通过linear-gradient()或radial-gradient()函数来创建。它可以用来在背景、边框等元素上创建平滑过渡的颜色效果。渐变常用于创建按钮、背景图像、文本效果等。 如何使用CSS3实现多列布局？请提供一个简单的示例。
答案：可以使用column-count和column-width属性来实现多列布局。例如，column-count: 2;将元素分为两列，column-width: 200px;将每一列的宽度设置为200px。 CSS3中的媒体查询（media query）是什么？它的作用是什么？
答案：媒体查询是CSS3中的一种功能，它允许根据设备屏幕的特征（如宽度、高度、方向等）来应用不同的样式。媒体查询可以用于响应式设计，使网页在不同设备上显示不同的布局和样式。 解释一下CSS3中的伪类和伪元素的区别，并举例说明它们的使用场景。
答案：CSS3中的伪类（pseudo-class）用于选择元素的特定状态或位置，如:hover、:active等。而伪元素（pseudo-element）用于在元素的某个部分插入内容，如::before、::after等。例如，可以使用:hover伪类选择鼠标悬停在元素上时的样式，使用::before伪元素在元素前插入内容。 CSS3中的变形（transform）属性可以实现哪些效果？请列举几个常见的变形效果并给出相应的代码示例。
答案：transform属性可以用于实现平移（translate()）、旋转（rotate()）、缩放（scale()）、倾斜（skew()）等效果。例如，transform: translate(50px, 50px);会将元素沿X轴和Y轴平移50px的距离。 请简要介绍CSS3中的Flexbox布局，并提供一个简单的Flexbox布局示例。
答案：Flexbox是CSS3中的一种弹性盒子布局模型，通过display: flex;将容器设为弹性布局，可以方便地实现自适应的、灵活的布局。以下是一个简单的Flexbox布局示例： &lt;div class="container"&gt; &lt;div class="item"&gt;Item 1&lt;/div&gt; &lt;div class="item"&gt;Item 2&lt;/div&gt; &lt;div class="item"&gt;Item 3&lt;/div&gt; &lt;/div&gt; .container { display: flex; justify-content: space-around; } .item { flex: 1; } 上述代码将容器内的三个元素平均分配空间，并在容器中水平居中显示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94a150cc149986e5ae7375db04bd67e9/" rel="bookmark">
			机器视觉【1】相机的成像(畸变)模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零、前言 很久没写文章，简单唠一唠。
不知道巧合还是蜀道同归，部门领导设定了些研究课题，用于公司部门员工的超前发展，该课题是“2D to 3D的三维重建”，这一块刚好是我个人看中的一个大方向，所以就有了这一系列的文章。其实我还发现不少同学是没搞清楚 什么是 机器视觉？机器视觉和图像处理的区别是什么？又有什么关联？我们来看看文心一言是怎么说的。
机器视觉是人工智能的一个分支，它利用机器代替人眼来做测量和判断。机器视觉系统通过机器视觉产品（即图像摄取装置，分CMOS和CCD两种）将被摄取目标转换成图像信号，传送给专用的图像处理系统，得到被摄目标的形态信息，根据像素分布和亮度、颜色等信息，转变成数字化信号。图像系统对这些信号进行各种运算来抽取目标的特征，进而根据判别的结果来控制现场的设备动作。机器视觉系统综合了光学、机械、电子、计算机软硬件等多方面技术，涉及到计算机、图像处理、模式识别、人工智能、信号处理、光机电一体化等多个领域。
图像处理（image processing）是一种用计算机对图像进行分析，以达到所需结果的技术。它也被称为影像处理。图像处理技术的主要内容包括图像压缩、增强复原、匹配描等。它的应用范围非常广泛，包括测绘学、大气科学、天文学、美图、使图像提高辨识等。此外，基于光学理论的处理方法依然占有重要的地位。图像处理是信号处理的子类，另外与计算机科学、人工智能等领域也有密切的关系。当前大多数的图像均是以数字形式存储，因而图像处理很多情况下指数字图像处理。图像属于二维信号，和一维信号相比，它有自己特殊的一面，处理的方式和角度也有所不同。
图像处理和机器视觉是紧密相关的两个领域。
图像处理是对图像进行各种操作，包括图像的增强、滤波、修复等，目的是让图像更美观、更易于分析。而机器视觉则是让机器能够像人类一样通过摄像头等设备来感知和理解图像的过程，它可以用来识别物体、检测运动、测量距离等。
在机器视觉中，图像处理技术被广泛应用。例如，在人脸识别过程中，首先需要对图像进行处理，提取出人脸的特征，然后再通过比对来判断是否为同一个人。这个过程中，图像处理技术起到了至关重要的作用。同时，图像处理也可以为机器视觉提供一些基础工具，如边缘检测、图像分割等技术，这些都有助于机器视觉系统更好地理解图像。
总的来说，图像处理是机器视觉的一个重要组成部分，为其提供了必要的技术手段和方法。同时，二者又各自独立，分别具有其独特的广泛应用领域。
一、成像原理——针孔相机模型 这一章主要介绍的是相机的成像原理，以及它的数学模型是如何建立的。在这个过程中我们需要了解相关坐标系的定义，以及一些畸变成像的相关内容。接下里正常进入学习环节。
相机的作用是什么？是拍照（废话）换成专业的术语就是 对三维世界进行2D的投影变换。 对于成像之后的图片，我们是不能从图像中获取其真实的信息。譬如上图的球，在图像中我们是不知道真实的球体究竟有多大，距离有多远。
那么我们能否从2D图像中恢复三维世界的模型，从而推断其近似的真实信息？答案是可以通过多视角的方式去推算，譬如双目立体视觉就很好的进行测距计算。那么如何通过摄像机拍出的二维照片，精确的恢复三维信息？这就需要先对相机的成像过程进行数学建模，用严谨的数学表达式来描述整个成像过程。
首先从镜头入手一步步的理解整个成像。一般的镜头都是通过很多层凹凸透镜的堆叠，来以修改外部光的光路进入到摄像机，但在分析镜头的过程我们一般可以等效以上的一个模型，这是一张初中物理很经典ppt，其描述了凸透镜对光路折射汇聚的特点。其中经过物体点和凸透镜光心的光线是不会改变方向，那么如果要理解整个世界中的一点到2D图像的成像点的时候，我们可以用这一简单的光线去做等效，来简化整个成像过程。
但是这个成像过程是基于一些假设的，就是说还存在一些问题点，假设成像点没有像素差；不考虑景深，能够在成像面上投影出清晰的图像。最终发现 这个成像过程 和 小孔成像的原理是一致的，因此我们可以把简化后的相机成像模型称之为针孔相机模型。
现在我们对世界的物体点 到成像的过程做了一个简化模型，下一步讨论 要如何计算世界中的物体点对应成像面上的坐标位置。
二、坐标系转换 （汇总图）
这里通过一张总图，介绍成像过程中涉及到一些坐标系，以及它们的关联。
世界坐标系：
以被测物体上的点作为参考，定义的绝对坐标系。坐标标记方式为Ow（Xw，Yw，Zw），也有把世界坐标系和相机坐标系定义重合为同一个坐标系上。相机坐标系：
以相机光心为坐标原点，主光轴上 物体方朝焦点方向为z轴，平行于Censor平面的两条垂直边分别为x和y轴。坐标记为（Xc，Yc，Zc）图像坐标系：
以主光轴与sensor的交点为坐标原点，平行于sensor平面的两条垂直边分别为x和y轴，坐标纪为（x，y）这个平面是建立在实际成像面上的，是个二维坐标系像素坐标系：
平行于sensor的虚拟成像平面，左上角顶点为原点xy轴都平行于图像平面，以像素为单位，坐标标记为（u，v）。 这里说说虚拟成像面和实际成像面的概念，虚拟成像面到光心的距离 等于 实际成像面与光心之间的距离，两个相互平面，经光心原点对称。为什么要定义虚拟成像面？对于世界坐标系中的一点P，它在实际成像面上的像点是Pr，在虚拟成像面上的像点是Pv，可以看到真实物体点在实际成像面是方向相反的（即倒立成像）但是在虚拟成像面的方向与真实世界坐标系就是一致的。所以在进行坐标换算的时候，方向问题就可以暂时不用去考虑了。那么讨论图像坐标系 和 像素坐标系的关系，就不难发现其实两个坐标系是一个偏移+倍率缩放的变换。
世界坐标系→相机坐标系 第一步是最简单的一步，世界坐标系转换到相机坐标系，两者其实就一个刚体变换，在上面也介绍了两者甚至可以是重合的，在实际计算两者互换的时候，搞清楚R和T的转换。详情可以到以前的文章了解矩阵的几何变换 相机坐标系→图像坐标系 第二步就是相机坐标系变换到图像坐标系，相机到图像的变换其实就是 小孔成像的物理模型，其中的数学道理其实就是两个相似三角形成正比。
即 X’ / X = f / Z
X' 是图像坐标系的横轴；X 是相机坐标系的横轴；
f 是镜头的焦距；Z就是物体像点在相机坐标系的距离；
上述給出了数学表达式，然后再转换为齐次矩阵的表达方式，到这一步还没啥特别难的部分。
图像坐标系→像素坐标系 最后一步就是图像到像素的转换，上面也提到了，实际成像面（图像）到虚拟成像面（像素）其实是一个图像数字化的过程，它们是一个倍率和偏移的操作。用数学式表达如下
dx，dy：表示图像单个像素的宽高，单位为mm/pixel
(cx, cy)：表示图像中心点的像素坐标。即主光轴与sensor平面的交点。一般在设备制作CCD转换就会有标注。没有的话，也可以通过后期标定。
整合：世界坐标系→像素坐标系 整个转换过程如上图，该公式应该是从右往左依次解读，世界物体点通过刚体变换，通过小孔成像的原理处理后，再经过图像数字化的倍率和偏移，最终得到屏幕的像素点。我们把跟相机相关的变量合并称为内参，RT刚体变换称为外参，这就是往后需要介绍的参数标定。
可以看到它其实是一个线性变换的过程，这是一个理想化的成像过程，但实际情况并不可能有这样理想的成像过程，最普遍的在sensor的制造过程中，由于镜头的畸变，dx和dy会有偏差并不完成一致成正比。接下来看看在有畸变的情况下要如何处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94a150cc149986e5ae7375db04bd67e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e000bca088f75149269639f9f85122a7/" rel="bookmark">
			攻防技术-单包攻击防范：扫描、畸形、特殊（HCIP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单包攻击类型介绍 一、扫描窥探攻击 1、地址扫描攻击防范 攻击介绍 运用ping程序探测目标地址，确定目标系统是否存活。也可使用TCP/UDP报文对目标系统发起探测（如TCP ping）。 防御方法 检测进入防火墙的ICMP、TCP和UDP报文，根据源IP地址获取统计表项的索引，如果目的IP地址与前一报文的IP地址不同，则将表项中的总报文个数增加1。如果在一定时间内报文的个数达到设置的阑值，记录日志，并根据配置决定是否将源IP地址自动加入黑名单。 2、端口扫描攻击防范 攻击介绍 Port Scan攻击通常使用一些软件，向大范围主机的各个TCP/UDP端口发起连接，根据应答报文判断主机是否使用这些端口提供服务。 防御方法 检测进入防火墙的TCP报文或UDP报文，根据源IP地址获取统计表项的索引，如果目的端口与前一报文不同，将表项中的报文个数增1。如果报文的个数超过设置的闯值，记录日志，并根据配置决定是否将源IP地址加入黑名单。 二、畸形报文攻击 1、SUMRF攻击防范 攻击介绍 Smurf攻击方法是发送ICMP请求，该请求包的目标地址设置为受害网络的广播地址，源地址为服务器地址。该网络的所有主机都回应此ICMP请求，回应报文全部发往服务器，导致服务器不能正常提供服务。 防御方法 检查ICMP应答请求包的目的地址是否为子网广播地址或子网的网络地址，如果是，则直接拒绝，并将攻击记录到日志。 2、LAND攻击防范 攻击介绍 把TCP 的源地址和目标地址都设置成某一个受害者的IP地址。这将导致受害者向它自己的地址发送SYN-ACK消息，结果这个地址又发回ACK消息并创建一个空连接，占用系统资源或使目的主机崩溃。 防御方法 对每一个的IP报文进行检测，若其源地址与目的地址相同，或者源地址为环回地址（127.0.0.1），则直接拒绝，并将攻击记录到日志。 3、Fraggle攻击防范 攻击介绍 Fraggle类似于Smurf攻击，使用UDP应答消息而非ICMP。UDP端口7（ECHO）和端口19（Chargen）在收到UDP报文后，会产生大量无用的应答报文，占满网络带宽。 防御方法 检查进入防火墙的UDP报文，若目的端口号为7或19，则直接拒绝，并将攻击记录到日志，否则允许通过。 4、IP Fragment攻击 攻击介绍 IP报文中有几个字段与分片有关：DF位、MF位、Fragment offsetLength 。如果上述字段的值出现矛盾，而设备处理不当，会对设备造成一定的影响，甚至瘫痪。 防御方法 检查IP报文中与分片有关的字段（DF位、MF位、片偏置量、总长度）是否有以下矛盾，若发现含有以下矛盾，则丢弃。将攻击记录到日志： DF位为1，而MF位也为1或Fragment Offset不为0。DF位为0，而Fragment Offset + Length &gt; 65535。 DF不要分片、MF要分片偏移量。
5、IP Spoofing攻击防范 攻击介绍 为了获得访问权，或隐藏入侵者的身份信息，入侵者生成带有伪造源地址的报文，并使用该伪造源地址访问攻击目标，进行扫描、窥探等预备攻击。 防御方法 检测每个接口流入的IP报文的源地址与目的地址，并对报文的源地址反查路由表，入接口与以该IP地址为目的地址的最佳出接口不相同的IP报文被视为IP Spoofing攻击，将被拒绝，并进行日志记录。 一台主机X去访问Y，正常路由器收到报文是根据目的路由去查路由表，也就是路由表中查去往Y的路由，不关心去往源X的，启用了IP Spoofing防护之后，X去往Y的路由从Eth1口收到后，不但会查路由表去往Y怎么走，还会反向查询路由表去往X是否是从Eth1口学到，如果X路由是从其他接口学到或者是根本没有X路由就会把这个访问干掉。
6、Ping of Death攻击 攻击介绍 IP报文的长度字段为16位，即IP报文的最大长度为65535 B。Ping of Death利用一些长度超大的ICMP报文对系统进行攻击。
防御方法 检测ICMP请求报文长度是否超过65535 B，若超过，则丢弃报文并记录日志。
7、TCP Flag攻击 攻击介绍 TCP报文包含6个标志位：URG、ACK、PSH、RST、SYN、FIN ，（最经典的标志位：ACK、RST、SYN、FIN）不同的系统对这些标志位组合的应答是不同的，可用于操作系统探测。 防御方法 检查TCP报文的各个标志位，若出现以下任意一种情况，直接丢弃该报0文并记录日志 6个标志位全为1或6个标志位全为0。SYN和FIN位同时为1；SYN和RST同时为1。FIN和URQ同时为1，RST和FIN同时为1。 8、Teardrop攻击 攻击介绍 利用在TCP/IP堆栈中信任IP碎片报文头所包含的信息实现。 防御方法 缓存分片信息，每一个源地址、目的地址、分片ID相同的为一组，最大支持缓存10000组分片信息。 9、WinNuke攻击范围 攻击介绍 WinNuke攻击通常向装有Windows系统的特定目标的NetBIOS端口（139）发送000B（out-of-band）数据包，引起一个NetBIOS片断重叠，致使已与其他主机建立连接的目标主机崩溃。还有一种是IGMP分片报文，一般情况下，IGMP报文是不会分片的，所以，不少系统对IGMP分片报文的处理有问题。 防御方法 WinNuke攻击1：检测数据包目的端口是否为139，并且检查TCP-URG位是否被设0置。WinNuke攻击2：检测进入的IGMP报文是否为分片报文，如果是分片报文，则直接丢弃。 三、特殊报文攻击 1、超大ICMP报文攻击防范 攻击介绍 超大ICMP报文攻击是指利用长度超大的ICMP报文对目标系统进行攻击。对于有些系统，在接收到超大ICMP报文后，由于处理不当，会造成系统崩溃、死机或重启。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e000bca088f75149269639f9f85122a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c422fe1c26c442488bf8f6ab3d1c45a0/" rel="bookmark">
			Docker详解与部署微服务实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2013年发布至今， Docker 一直广受瞩目，被认为可能会改变软件行业。 但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？今天就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。
1. Docker详解 1.1 Docker简介 Docker是一个开源的容器化平台，可以帮助开发者将应用程序和其依赖的环境打包成一个可移植、可部署的容器。Docker的主要目标是通过容器化技术实现应用程序的快速部署、可移植性和可扩展性，从而简化应用程序的开发、测试和部署过程。
容器化是一种虚拟化技术，它通过在操作系统层面隔离应用程序和其依赖的运行环境，使得应用程序可以在一个独立的、封闭的环境中运行，而不受底层操作系统和硬件的影响。与传统的虚拟机相比，容器化具有以下优势：
轻量级: 容器与宿主机共享操作系统内核，因此容器本身非常轻量级，启动和停止速度快，资源占用少。可移植性: 容器可以在任何支持相应容器运行时的系统上运行，无需关注底层操作系统的差异，提供了高度的可移植性。快速部署: 容器化应用程序可以通过简单的操作进行打包、分发和部署，减少了部署过程的复杂性和时间成本。弹性扩展: 可以根据应用程序的需求快速创建、启动和停止容器实例，实现应用程序的弹性扩展和负载均衡。环境隔离: 每个容器都具有独立的运行环境，容器之间相互隔离，不会相互干扰，提供了更好的安全性和稳定性。 docker和传统虚拟机区别
虚拟机是一个主机模拟出多个主机，需要先拥有独立的系统。传统虚拟机，利用hypervisor，模拟出独立的硬件和系统，在此之上创建应用。docker 是在主机系统中建立多个应用及配套环境，把应用及配套环境独立打包成一个单位，是进程级的隔离。
1.2 Docker架构 Docker daemon（ Docker守护进程） Docker daemon是一个运行在宿主机（ DOCKER-HOST）的后台进程。可通过 Docker客户端与之通信。
Client（ Docker客户端） Docker客户端是 Docker的用户界面，它可以接受用户命令和配置标识，并与 Docker daemon通信。图中， docker build等都是 Docker的相关命令。
Images（ Docker镜像） Docker镜像是一个只读模板，它包含创建 Docker容器的说明。它和系统安装光盘有点像，使用系统安装光盘可以安装系统，同理，使用Docker镜像可以运行 Docker镜像中的程序。
Container（容器） 容器是镜像的可运行实例。镜像和容器的关系有点类似于面向对象中，类和对象的关系。可通过 Docker API或者 CLI命令来启停、移动、删除容器。
Registry Docker Registry是一个集中存储与分发镜像的服务。构建完 Docker镜像后，就可在当前宿主机上运行。但如果想要在其他机器上运行这个镜像，就需要手动复制。此时可借助 Docker Registry来避免镜像的手动复制。
一个 Docker Registry可包含多个 Docker仓库，每个仓库可包含多个镜像标签，每个标签对应一个 Docker镜像。这跟 Maven的仓库有点类似，如果把 Docker Registry比作 Maven仓库的话，那么 Docker仓库就可理解为某jar包的路径，而镜像标签则可理解为jar包的版本号。
Docker Registry可分为公有Docker Registry和私有Docker Registry。 最常⽤的Docker Registry莫过于官方的Docker Hub， 这也是默认的Docker Registry。 Docker Hub上存放着大量优秀的镜像， 我们可使用Docker命令下载并使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c422fe1c26c442488bf8f6ab3d1c45a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e522d6362537ceb86ddf9f67e2662e2/" rel="bookmark">
			3d导入模型怎样显示原本材质---模大狮模型网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在导入3D模型时保留原本的材质，您可以尝试以下方法：
导入前检查文件格式：确保您所使用的3D软件支持导入模型的文件格式。不同的软件对文件格式的支持有所差异，选择正确的文件格式可以更好地保留原始材质。
使用正确的材质库：在导入模型之前，检查您的3D软件是否具有正确的材质库。某些软件可能提供常用的材质库，您可以从中选择与模型原始材质相匹配的材质。
导入前的准备工作：在导入模型之前，确保您已经收集了模型所需的所有纹理、贴图和材质文件。将这些文件与模型文件放置在同一文件夹中，并确保文件路径正确。
适配材质：如果导入后发现模型的材质与原始材质不匹配，您可以手动调整材质属性，例如颜色、反射率、光泽度等，以尽量接近原始材质的效果。
材质映射：在导入过程中，您可以尝试使用模型的 UV 映射信息来重新映射纹理和贴图。通过正确映射纹理，可以更好地保留原始模型的材质效果。
调整光照和环境：在导入后，您可能需要调整场景的光照和环境设置，以使模型的材质效果更好地展现出来。尝试添加适当的光源，并调整材质的反射和折射属性，以获得更真实的效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/274039c83dfec91003e3f5278fdb6cc0/" rel="bookmark">
			攻防技术1-网络攻击（HCIP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、网络攻击方式分类
1、被动攻击：
2、主动攻击：
3、中间人攻击：
二、网络攻击报文类型分类：
1、流量型攻击
2、单包攻击
三、流量型攻击防范技术
1、DNS Request Flood攻击
攻击原理
DNS交互过程
2、TCP类报文攻击防御
TCP三次握手
四次挥手手：两次FIN交换
4、SYN Flood攻击（DOS）
SYN Flood攻击抵御方法——首包丢弃（面对虚假源）
SYN Flood攻击抵御方法——源认证（面对虚假源）
SYN Flood攻击抵御方法——源认证（真实源）
SYN-ACK Flood攻击原理与防御原理
攻击原理
防御原理
5、ACK Flood攻击与防御原理
攻击原理
防御原理
Anti-DDoS设备防御方式
严格模式
基本模式
6、FIN/RST Flood攻击与防御原理
攻击原理
防御原理
四、抗DDOS攻击
1、华为的Anti-DDOS产品
2、Anti-DDOS三大单元
3、流量清洗原理
（1）、首包丢弃（适合支持重传的协议-应对虚假源）
一、网络攻击方式分类 1、被动攻击： 被动攻击：通过抓包获取信息，攻击不安全的协议。
2、主动攻击： DOS：造成大量请求，消耗完服务器资源。篡改攻击：本来是直接访问服务器，现在要过中间人进行转发，转发过程中被篡改。假冒攻击：伪造身份去获取信息，通过跨站脚本等手段获取你网站的Cookie。 3、中间人攻击： 中间人攻击：成为中间人的方式有DHCP和ARP
DHCP：架设DHCP服务器，发送错误的地址信息，网关指向我。ARP：修改去往互联往和返回互联网流量。 二、网络攻击报文类型分类： 1、流量型攻击 网络层攻击：ARP、DHCP、DOS应用层攻击：Web 2、单包攻击 畸形报文攻击特殊报文攻击扫描窥探攻击 三、流量型攻击防范技术 1、DNS Request Flood攻击 攻击原理 针对缓存服务器的攻击 针对缓存服务器的攻击是指攻击者直接或间接向DNS缓存服务器发送大量不存在的域名解析请求，导致DNS缓存服务器不停向授权服务器发送解析请求，最终导致DNS缓存服务器超载，影响正常业务的攻击。针对授权服务器的攻击 针对授权服务器的攻击是指攻击者直接或间接向DNS授权服务器发送大量不存在的子域名请求，致使DNS授权服务器严重超载，无法继续响应正常用户的DNS请求，从而达到攻击的目的攻击。DNS Request Flood攻击源可能是虚假源，也可能是真实源。针对不同类型的攻击源，采取的防御方式也不同。 DNS交互过程 2、TCP类报文攻击防御 TCP正常建立连接和断开连接的过程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/274039c83dfec91003e3f5278fdb6cc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8265752d756db2e58ecd77a9d499b2db/" rel="bookmark">
			matlab中如何将视频保存成图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用MATLAB将视频的每一帧保存成一幅图像，并自动命名。本文方法简单，容易学习。
首先，读入视频。代码如下：
mov = VideoReader('xxxxxx.avi'); % 将xxxxxx.avi读入MATLAB中，并用名为mov的结构体保存 fnum = mov.NumberOfFrames; % 获取视频帧数 接下来，我们要写一个循环来将视频的每一帧保存成.png格式的图片。代码如下：
% 将第i帧写入到xxx文件夹内"img_000x.png"图片中 imgOrder=0; % 图片按顺序编号 for i = 1:3:fnum % i从1到fnum, step=3 Img=read(mov,i); % 读取第i帧；每次读取一帧可防止内存不足 imwrite(Img,['xxx/img_',sprintf('%04d',imgOrder),'.png']) % 将第i帧写入到xxx文件夹内"img_000j.png"图片, j=imgOrder imgOrder=imgOrder+1; end 程序运行结束后，会在xxx文件夹中生成fnum/step张图片，每一张图片对应视频中相应的一帧。
如果需要做一些预处理，如选取感兴趣区域ROI、下采样等，可以通过修改倒数第二句话实现：
imwrite(Img,['xxx/img_',sprintf('%04d',imgOrder),'.png']); % 假设每一帧的原始大小为：1920*1080(宽*高) --&gt; imwrite(Img(51:950,151:1550,:),['xxx/img_',sprintf('%04d',imgOrder),'.png']); % 选取ROI，保存的图像大小为：1400*900 --&gt; imwrite(Img(51:2:950,151:2:1550,:),['xxx/img_',sprintf('%04d',imgOrder),'.png']); % 选取ROI并下采样，保存的图像大小为：700*450 相关文档：
基于帧间差分法提取视频前景目标的matlab程序
help VideoReader
VIDEOREADER Create a multimedia reader object.
OBJ = VIDEOREADER(FILENAME) constructs a multimedia reader object, OBJ, that can read in video data from a multimedia file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8265752d756db2e58ecd77a9d499b2db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecef5cddbad9d7e5e27ef26cc71c5abc/" rel="bookmark">
			c&#43;&#43; 类成员变量 初始化赋值 多种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 class Okex { public: int poolSize; int poolSize1; int poolSize2; } 1
Okex::Okex() { poolSize = 10; poolSize1 = 15; poolSize2 = 100; } 2
Okex::Okex() { initPoolSizes(); } void Okex::initPoolSizes() { poolSize = 10; poolSize1 = 15; poolSize2 = 100; } 3
Okex::Okex(int size1 = 10, int size2 = 15, int size3 = 100) { poolSize = size1; poolSize1 = size2; poolSize2 = size3; } 4
Okex::Okex() : poolSize(10),poolSize1(15),poolSize2(100) { } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/167fcc83beb31a694246a2d798607124/" rel="bookmark">
			【Maven】＜scope＞provided＜/scope＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Maven中，“provided”是一个常用的依赖范围，它表示某个依赖项在编译和测试阶段是必需的，但在运行时则由外部环境提供，不需要包含在最终的项目包中。下面是对Maven scope “provided”的详细解释：
编译和测试阶段可用：当一个依赖项的scope被设置为“provided”时，这意味着在编译项目代码和执行测试时，这个依赖项是可用的。这意味着你可以在代码中自由地使用这个依赖提供的类和方法。运行时不包括：尽管在编译和测试阶段这个依赖项是可用的，但在打包最终的项目包（如WAR或JAR）时，它不会被包含在其中。这是因为通常“provided”依赖由运行时环境（如应用服务器或JDK）提供。与容器集成：在许多情况下，“provided”范围的依赖项是由应用运行的容器（如Web服务器或应用服务器）提供的。这意味着当应用程序部署到容器中时，这些依赖项将由容器自动提供，而不需要在应用程序的部署包中包含它们。特定用途的依赖项：一些工具和库，如Lombok，通常被设置为“provided”范围，因为它们主要用于编译时提供功能（如自动生成代码），而在运行时则不再需要。与“compile”范围的差异：“provided”范围与“compile”范围的主要区别在于运行时行为。当一个依赖项的scope被设置为“compile”时，它将在编译和运行时都可用，并包含在最终的项目包中。而“provided”范围的依赖项仅在编译和测试阶段需要，运行时不包括。 &lt;scope&gt; 被设置为 provided 是因为它主要是一个编译时工具，用来生成样板代码，如 getter、setter 方法等。一旦代码被编译，Lombok 的工作就完成了，运行时不再需要它。因此，在打包应用时，不需要将其包含在其中，因为它在运行时不是必需的。这就是为什么通常将其 scope 设置为 provided。
在运行时勾选↓↓↓↓↓↓
类似的，还有其他几种依赖范围：
compile（默认）：这是默认的依赖范围，表示该依赖在编译、运行时都可用，并且会被包含在项目的最终包中。runtime：与“compile”范围类似，但在运行时可用，但不会在编译时包含依赖。这意味着编译时可以使用该依赖提供的类和方法，但在运行时需要确保该依赖可用。test：仅在测试阶段可用，用于包含测试所需的依赖。这些依赖项不会包含在最终的项目包中。system：与“provided”范围类似，表示该依赖在编译和测试阶段是必需的，但在运行时需要由外部系统提供。与“provided”不同的是，“system”范围的依赖项需要显式指定系统的路径。optional：当一个依赖项的scope被设置为“optional”时，表示该依赖不是必需的，可以在使用时忽略。这对于那些可选的组件或与其他依赖无关的组件非常有用。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c718a5fe9a52d947101249d012ce01e/" rel="bookmark">
			es修改mapping映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Elasticsearch中，一旦一个字段被创建，它的数据类型通常是固定的，不能直接修改。这是因为Elasticsearch是基于倒排索引的，字段的数据类型在创建索引时确定，并且与索引的结构相关联。
然而，如果确实需要更改字段的数据类型，可以采取以下几种方法：
重新创建索引：这是最直接的方法。可以删除现有的索引，然后创建一个新的索引，并在创建时定义正确的字段类型。使用映射更新：尽管你不能直接修改现有字段的类型，但你可以添加一个新字段并更新映射，然后将数据复制到新字段。之后，你可以删除旧字段。 1、创建中间索引
PUT my_index_1 2、创建mapping映射
PUT /my_index_1 { "mapping":{ "info":{ "properties":{ "id":{"type":"keyword"} } } } } 3、向中间索引备份源索引数据
POST _reindex { "source":{ "index":"my_index" }, "dest":{ "index":"my_index_1" } } 确认是否copy过去
GET my_index_1 4、删除旧索引
DELETE my_index 5、新建同名新索引及映射（同上）
6、从中间索引中还原数据（同上）
7、删除中间索引
DELETE my_index_1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9283152f19532f0ad188f321cf43f08/" rel="bookmark">
			Miniconda 与 Anaconda 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Miniconda 与 Anaconda 的区别 包含的包:
Anaconda: 是一个较大的发行版，预装了大量的科学计算和数据分析相关的 Python 包。Miniconda: 更轻量级，只包含 Conda、Python 和它们的依赖，以及少量常用包。 安装体积:
由于预装了许多包，Anaconda 的安装体积比 Miniconda 大很多。 灵活性:
Miniconda 提供了更大的灵活性，因为你可以只安装需要的包，从而使环境保持轻量。Anaconda 则适合那些希望一站式安装所有数据科学需要的包的用户。 为什么在 Miniconda 环境中工作，而在 Anaconda 环境中出现问题 不同的包版本:
由于 Anaconda 和 Miniconda 可能安装了不同版本的包，这可能导致在一个环境中代码运行正常，而在另一个环境中出现问题。版本差异可能影响包的功能和接口。 依赖管理:
在不同的环境中，相同的包可能会因为依赖不同的子包版本而有不同的行为。Conda 环境的隔离特性意味着即使是相同的包，在不同环境下也可能表现不同。 环境配置:
Anaconda 和 Miniconda 的环境配置可能略有不同，比如环境变量、路径设置等。 解决建议 检查包版本：确认你在 Miniconda 和 Anaconda 环境中使用的是相同版本的 Python 和其他相关包。创建相同的环境：尝试在 Anaconda 环境中创建一个与 Miniconda 相同的环境（使用相同的包和版本）。环境隔离：确保在清洁的环境中测试代码，以排除环境配置导致的问题。 总的来说，这个问题更可能是由于 Python 代码中的逻辑错误或包版本不兼容问题导致的，而不是由于使用了 Anaconda 或 Miniconda。检查和比较两个环境中的包版本可能会帮助你找到问题的根源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7726a258c49a76854db4ae3583f1f8f/" rel="bookmark">
			2核2G3M服务器上传速度多少？以阿里云和腾讯云为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2核2G3M服务器上传速度多少？上传是按10M带宽算，上传速度是1280KB/秒，即1.25M/秒；下载速度按3M带宽计算，下载速度是384KB/秒。本文是以阿里云为例的，阿里云服务器当公网带宽小于10M及10M以下时，上传带宽提供不低于10M的带宽值。
阿里云和腾讯云2核2G3M服务器价格很优惠，不到百元：
阿里云活动 https://t.aliyun.com/U/bLynLC腾讯云活动 https://curl.qcloud.com/oRMoSucP 阿腾云atengyun.com分享云服务器公网带宽上传和下载速度对照表：
宽带兆数实际下载速度峰值上传带宽速度峰值1M宽带128KB/秒10M上传带宽，上传速度是1280KB/秒，即1.25M/秒2M宽带2*128=256KB/秒1280KB/秒（1.25M/秒）3M宽带3*128=384KB/秒1280KB/秒（1.25M/秒）4M宽带4*128=512KB/秒1280KB/秒（1.25M/秒）5M宽带5*128=640KB/秒1280KB/秒（1.25M/秒）6M宽带6*128=768KB/秒1280KB/秒（1.25M/秒）7M宽带7*128=896KB/秒1280KB/秒（1.25M/秒）8M宽带8*128=1024KB/S=1M/秒1280KB/秒（1.25M/秒）9M宽带9*128=1152KB/秒=1.125M/秒1280KB/秒（1.25M/秒）10M宽带10*128=1280KB/秒=1.25M/秒1280KB/秒（1.25M/秒）20M宽带20*128=2560KB/秒=2.5M/秒大于10M提供等额的上传带宽，上传2.5M/秒50兆宽带50*128=6400KB/秒=6.25M/秒6.25M/秒100兆宽带100*128=12800KB/秒=12.5M/秒12.5M/秒200兆宽带200*128=25600KB/秒=25M/秒25M/秒N兆宽带N*128，以此类推 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fcd450f6006f688359192beb69947db/" rel="bookmark">
			穷举vs暴搜vs深搜vs回溯vs剪枝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 欢迎来到Cefler的博客😁
🕌博客主页：那个传说中的man的主页
🏠个人专栏：题目解析
🌎推荐文章：题目大解析（3）
目录 👉🏻全排列 👉🏻全排列 原题链接：全排列
mycode:
class Solution { public: vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; path; bool check[7];//检查该位置是否被用过了，true说明被用过了 void dfs(vector&lt;int&gt;&amp; nums) { if(nums.size()==path.size())//说明此时已经组成一个序列了 { ret.push_back(path); return; } for(int i = 0;i&lt;nums.size();i++) { if(check[i]==false)//此时还没被用过 { path.push_back(nums[i]); check[i] = true; dfs(nums); //回溯清空现场，将dfs下层插入的元素pop掉 path.pop_back(); check[i] = false; } } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { dfs(nums); return ret; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c93420f114dc97c8efb9f86877fa27eb/" rel="bookmark">
			OpenHarmony之系统调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 对于运行L0系统的硬件一般是mcu，资源有限，L0系统没有区分内核态和用户态，所有的代码都在内核态运行，所以不需要系统调用
L2系统用的是Linux内核，所以系统调用跟Linux Kernel的是一样的。
所以我们主要来看看L1系统中系统调用机制的是怎么实现的。
后面的分析基于如下版本：
OpenHarmony v3.3.2musl v1.2.0 L1系统调用 对于运行L1系统的硬件一般集成了MMU，而且CPU有特权级别状态（状态寄存器的某些位），可以实现进程之间的隔离、内核态和用户态的隔离。系统调用就是在有内核态和用户态隔离的操作系统上，用户态进程访问内核态资源的一种方式
用户态c库 通常我们的应用不会直接调用系统调用，而是通过c库的库函数来间接调用。
OpenHarmony上层使用的C库是musl libc， c库的一些函数接口调到最下面就是系统调用接口了。
通过third_party/musl/src/internal/syscall.h文件中，各种宏的展开，最终都会变成类似与__syscall3等这样的函数（后面可能跟着不同的数字，代表传递参数的个数），而 musl libc 对于这些函数在不同硬件架构上有着不同的实现，这里以arm为例，
代码路径：third_party/musl/arch/arm/syscall_arch.h
主要代码：
#define __asm_syscall(...) do { \ __asm__ __volatile__ ( "svc 0" \ : "=r"(r0) : __VA_ARGS__ : "memory"); \ return r0; \ } while (0) #endif 这里调用了SVC指令触发一个“特权调用”异常，并传递一些参数，这样会触发内核去处理该中断。
内核态中断处理 SVC中断后，内核就会去处理该中断。
中断异常处理的入口是在汇编代码：kernel/liteos_a/arch/arm/arm/src/los_hw_exc.S
SVC异常处理函数入口：_osExceptSwiHdl，
最终会调用到所有系统调用的统一入口, 这里就是C代码实现了:OsArmA32SyscallHandle(kernel/liteos_a/syscall/los_syscall.c)
这里会根据系统调用号来查找对应的系统调用处理函数（syscall_lookup.h 中定义了对应的处理函数），然后通过这些处理函数和传递过来的参数，由此完成真正系统调用的过程，这里就不再一一分析了。
总结 本篇只是记录了一下OpenHarmony的L1系统系统调用实现的大致流程，梳理下整个脉络。
整个流程大致如下：
应用程序 --&gt; c库函数 (musl libc) --&gt; 系统调用 --&gt; 触发`SVC`中断 --&gt; 内核态SVC异常处理函数 --&gt; 系统调用具体实现及返回 这里也不列举例子了，具体的可以自己去撸下代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c93420f114dc97c8efb9f86877fa27eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495b51f4aa16f6b63c378409d06d02ec/" rel="bookmark">
			【消息中间件】Rabbitmq消息可靠性、持久化机制、各种消费
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文作者：我辈李想
版权声明：文章原创，转载时请务必加上原文超链接、作者信息和本声明。
文章目录 前言一、常见用法1.消息可靠性2.持久化机制3.消息积压批量消费：增加 prefetch 的数量,提高单次连接的消息数并发消费：多部署几台消费者实例 4.重复消费 二、其他1.队列存在大量unacked数据2.重试连接：建立连接3.rabbitmq心跳连接4.重试连接：消费ack确认前连接异常断开时 前言 一、常见用法 1.消息可靠性 RabbitMQ 提供了多种机制来确保消息的可靠性，以防止消息丢失或被意外删除。以下是几种提高消息可靠性的方法：
持久化消息（Durable Message）：在发布消息时，将消息的 deliveryMode 设置为 2，即可将消息设置为持久化消息。持久化消息会将消息写入磁盘，即使 RabbitMQ 服务器重启，消息也不会丢失。
持久化队列（Durable Queue）：创建队列时，将队列的 durable 参数设置为 true，即可创建一个持久化队列。持久化队列会将队列的元数据和消息都存储在磁盘上，即使消息队列服务器重启，队列的元数据和消息仍然可以恢复。
确认模式（Publisher Confirms）：使用确认模式可以确保消息被成功发送到 RabbitMQ 服务器，并得到确认。通过在信道上使用 channel.confirmSelect() 启用确认模式，然后通过 channel.waitForConfirms() 方法来等待服务器的确认。
事务模式（Transactions）：使用事务模式可以保证消息的原子性，要么全部发送成功，要么全部失败。通过在信道上使用 channel.txSelect() 开启事务模式，在发送消息后使用 channel.txCommit() 提交事务，或使用 channel.txRollback() 进行回滚。
消费者应答（Consumer Acknowledgement）：在消费者接收和处理消息后，必须发送确认应答给 RabbitMQ 服务器。通过使用 channel.basicAck() 方法发送确认应答，以告知服务器消息已经成功处理。
通过使用上述机制，可以在 RabbitMQ 中实现消息的可靠性传输和处理，以防止消息的丢失和重复传递。
这里有篇博客，大家可以看看。
2.持久化机制 在RabbitMQ中，消息持久化是一种机制，可以确保消息在服务器宕机或重启之后不丢失。默认情况下，RabbitMQ的消息是存储在内存中的，如果服务器宕机，则会导致消息的丢失。要实现消息的持久化，可以采取以下步骤：
创建一个持久化的交换机（Exchange）：
在定义交换机时，将其durable参数设置为true，例如：
channel.exchangeDeclare("exchange_name", "direct", true); 创建一个持久化的队列（Queue）：
在定义队列时，将其durable参数设置为true，例如：
channel.queueDeclare("queue_name", true, false, false, null); 将持久化的队列与交换机进行绑定：
使用队列和交换机的bind方法进行绑定，例如：
channel.queueBind("queue_name", "exchange_name", "routing_key"); 发布持久化的消息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495b51f4aa16f6b63c378409d06d02ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f10991af7758762cc84c173be390e87a/" rel="bookmark">
			信号与线性系统翻转课堂笔记16——离散LTI系统的各类响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信号与线性系统翻转课堂笔记16——离散LTI系统的各类响应 The Flipped Classroom16 of Signals and Linear Systems 对应教材：《信号与线性系统分析（第五版）》高等教育出版社，吴大正著
一、要点 （1，重点）离散LTI系统的单位序列响应（单位响应）的概念，掌握利用时域方法求单位序列响应；
（2）了解阶跃响应及其与单位序列响应的关系；
（3，重点）离散LTI系统的零状态响应与单位序列响应、系统激励之间的关系（卷积和）；
（4，重点）卷积和的计算；
（5）卷积和的性质；
（6）利用卷积和求系统的零状态响应。
二、问题与解答 （*1）什么是离散LTI系统的单位序列响应h(k)？离散系统激励、单位序列响应和零状态响应之间是什么关系？简述教材中对此关系的推导思路（教材式3.3-1、3.3-2、3.3-3），并说明推导中用到了系统的那些性质。
（2）求解习题3.10 (a)。
（*3）求解习题3.11 (1),(2),(3)，总结求两个有限长序列卷积和，卷积和的非零区间如何确定。
（4）已知某信号f(k)=(1-0.5^(k-1))ε(k-1)，如何将其表示为(…)ε(k)的形式？（提示：ε(k-1)=ε(k)-δ(k)）
（*5）离散LTI系统的阶跃响应g(k)如何定义？离散系统的阶跃响应和单位序列响应之间是何种关系（提示：δ(k)=ε(k)-ε(k-1)）？基于这种关系，求解习题3.15。
（*6）求解习题3.22，总结：由多个子系统构成的复合离散LTI系统，复合系统的单位序列响应与各子系统单位序列响应的关系。
1、离散LTI系统的激励、单位响应和零状态响应 什么是离散LTI系统的单位序列响应h(k)？离散系统激励、单位序列响应和零状态响应之间是什么关系？简述教材中对此关系的推导思路（教材式3.3-1、3.3-2、3.3-3），并说明推导中用到了系统的那些性质。
①单位序列响应是指当LTI系统的激励为单位序列△（k）时，系统的零状态响应。
②零状态响应=激励*系统单位序列响应
③
性质：线性系统的齐次性、时不变系统的移位不变性、系统的零状态线性性质。
2、由系统框图求系统单位响应 求解习题3.10 (a)。
3、有限长序列卷积和 求解习题3.11 (1),(2),(3)，总结求两个有限长序列卷积和，卷积和的非零区间如何确定。
总结：若f_1 (k),f_2 (k)非零区间分别为[a,b],[c,d]，则f_1 (k)*f_2 (k)非零区间为[a+c,b+d]
4、涉及ε(k-1)的计算 已知某信号f(k)=(1-0.5^(k-1))ε(k-1)，如何将其表示为(…)ε(k)的形式？（提示：ε(k-1)=ε(k)-δ(k)）
5、离散LTI系统的阶跃响应 离散LTI系统的阶跃响应g(k)如何定义？离散系统的阶跃响应和单位序列响应之间是何种关系（提示：δ(k)=ε(k)-ε(k-1)）？基于这种关系，求解习题3.15。
6、复合系统的单位序列响应 求解习题3.22，总结：由多个子系统构成的复合离散LTI系统，复合系统的单位序列响应与各子系统单位序列响应的关系。
三、反思总结 暂无
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c744bdda165fec636c140cb6e61823b/" rel="bookmark">
			借贷协议 Tonka Finance：铭文资产流动性的新破局者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“Tonka Finance 是铭文赛道中首个借贷协议，它正在为铭文资产赋予捕获流动性的能力，并为其构建全新的金融场景。”
在 2023 年的 1 月，比特币 Ordinals 协议被推出后，包括 BRC20，Ordinals 等在内的系列铭文资产在包括比特币等在内的生态中掀起了一轮狂潮。尤其是在包括 Binance 在内的系列 CEX 上线了 ORDI、SATS 等头部铭文资产后，在百倍、千倍涨幅效应下铭文资产不断被贴上“造富”标签，这也进一步加速了铭文赛道 FOMO 情绪的上扬，并一扫市场长期处于熊市下的阴霾。
铭文赛道的火爆，也被称为新一轮“DeFi Summer”，一些链的链上活动不断达到极值。
从 Dune 数据上看，截止到 12 月 24 日，Ordinals 协议铭文铸造的累计费用收入达 4,864.665 枚 BTC，约合 21.3 亿美元，铸造铭文总量达到达到了 5100 万枚（仅比特币链上）。除了比特币链上外，铭文热潮也在其他链上不断蔓延。
数据来源：une.com/dgtl_assets/bitcoin-ordinals-analysis
据 The Block 数据，Avalanche 链上12月 13 日至 18 日期间，链上铭文铸造与转移消耗的 Gas 费高达 1380 万美元，处理了超 6100 万笔铭文相关交易，仅次于 BNB Chain（7700 万笔）和 Polygon（1.61 亿笔交易）。同时，过去几周主要的 EVM 链上，95%的交易活动都为铭文铭刻。
链上交易成本也在随着链上行为的上升而上升，比特币 Layer1 最高峰时的最低确认 Gas 超过了 800 s/vb，突破三年内的最高 Gas。除了比特币网络外，以低费用、高效率著称的一众 EVM 兼容链的交易成本也不断飙升，比如 Avalanche 网络 Gas 费用已飙升至平均5494Gas（41美元），较正常水平 25 Gas上涨超过 200 倍，Polygon 链上 Gas 也曾达到了 1700 gwei。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c744bdda165fec636c140cb6e61823b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82f7a7ba23273c7943910cdbe202dac4/" rel="bookmark">
			linux C 线程池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：linux C 线程池
链接：https://blog.csdn.net/llzhang_fly/article/details/116140236
目录 线程池是什么为什么要使用线程池线程池基本原理一个线程池主要包括以下几个组成部分应用实例其他博文 线程池是什么 线程池就好比水龙头的水流入一个较大的水池，当需要水的时候，5个人挑着扁担，每个人同时可以去打10桶水（各自打各自的2通水，互不影响），然后挑着就走。如果没有水池，那么每个人都需要在从水龙头上接自己的2桶水，谁先到水就先打水，这样打水的效率极低，5个人都需要排队打10桶水。
所以：线程池，顾名思义就是由多个线程组成的“水池”，当有任务需要执行时，由空闲线程进行处理，若没有任务，则线程处于休眠等待的状态。
为什么要使用线程池 如果一个应用程序需要频繁创建、销毁线程，而任务执行的时间又非常短，这样线程创建和销毁的带来的开销就不容忽视，这时也是线程池该出场的机会了；
如果线程创建和销毁时间相比任务执行时间可以忽略不计，则没有必要使用线程池。
比如线程池有3个线程，那调用线程池的程序中，至少会有几个线程呢？
至少会有4个线程，因为主进程也是一个线程。
线程池基本原理 在传统服务器结构中，常是有一个总的监听线程(listen函数)监听有没有新的用户连接服务器, 每当有一个新用户进入，服务器就开启一个新的线程用户处理这个用户的数据包。这个线程只服务于这个用户，当用户与服务器端关闭连接以后，服务器端销毁这个线程。然而频繁地开辟与销毁线程极大地占用了系统的资源。而且在大量用户的情况下，系统为了开辟和销毁线程将浪费大量的时间和资源。
线程池提供了一个解决外部大量用户与服务器有限资源的矛盾，线程池和传统的一个用户对应一 个线程的处理方法不同，它的基本思想就是在程序开始时就提前在内存中开辟一些线程，线程的数目是固定的，他们独自形成一个类，屏蔽了对外的操作，而服务器只需要将数据包交给线程池就可以了。当有新的客户请求到达时，不是新创建一个线程为其服务，而是从“池子”中选择一个空闲的线程为新的客户请求服务，服务完毕后，线程进入空闲线程池中。如果没有线程空闲的话, 就将数据包暂时积累 , 等待线程池内有线程空闲以后再进行处理。通过对多个任务重用已经存在的线程对象 , 降低了对线程对象创建和销毁的开销。当客户请求时 , 线程对象已经存在 , 可以提高请求的响应时间 , 从而整体地提高了系统服务的表现。
另一种线程池描述
大多数的网络服务器，包括Web服务器都具有一个特点，就是单位时间内必须处理数目巨大的连接请求，但是处理时间却是比较短的。在传统的多线程服务器模型中是这样实现的：一旦有个请求到达，就创建一个新的线程，由该线程执行任务，任务执行完毕之后，线程就退出。这就是"即时创建，即时销毁"的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数非常频繁，那么服务器就将处于一个不停的创建线程和销毁线程的状态。这笔开销是不可忽略的，尤其是线程执行的时间非常非常短的情况。
线程池就是为了解决上述问题的，它的实现原理是这样的：在应用程序启动之后，就马上创建一定数量的线程，放入空闲的队列中。这些线程都是处于阻塞状态，这些线程只占一点内存，不占用CPU。当任务到来后，线程池将选择一个空闲的线程，将任务传入此线程中运行。当所有的线程都处在处理任务的时候，线程池将自动创建一定的数量的新线程，用于处理更多的任务。执行任务完成之后线程并不退出，而是继续在线程池中等待下一次任务。当大部分线程处于阻塞状态时，线程池将自动销毁一部分的线程，回收系统资源。
一个线程池主要包括以下几个组成部分 1）线程管理器：用于创建并管理线程池。
2）工作线程：线程池中实际执行任务的线程。在初始化线程时会预先创建好固定数目的线程在池中，这些初始化的线程一般处于空闲状态，一般不占用CPU，占用较小的内存空间。
3）任务接口：每个任务必须实现的接口，当线程池的任务队列中有可执行任务时，被空闲的工作线程调去执行（线程的闲与忙是通过互斥量实现的，跟前面文章中的设置标志位差不多），把任务抽象出来形成接口，可以做到线程池与具体的任务无关。
4）任务队列：用来存放没有处理的任务，提供一种缓冲机制，实现这种结构有好几种方法，常用的是队列，主要运用先进先出原理，另外一种是链表之类的数据结构，可以动态的为它分配内存空间，应用中比较灵活，下文中就是用到的链表。
在Linux系统下用C语言创建的一个线程池的步骤：
1） 线程池会维护一个任务链表(每个CThread_worker结构就是一个任务)。
2） pool_init()函数预先创建好max_thread_num个线程，每个线程执thread_routine ()函数。该函数中
while (pool-&gt;cur_queue_size == 0) { pthread_cond_wait (&amp;(pool-&gt;queue_ready),&amp;(pool-&gt;queue_lock)); } 表示如果任务链表中没有任务，则该线程出于阻塞等待状态。否则从队列中取出任务并执行。
3） pool_add_worker()函数向线程池的任务链表中加入一个任务，加入后通过调用pthread_cond_signal (&amp;(pool-&gt;queue_ready))唤醒一个出于阻塞状态的线程(如果有的话)。
4） pool_destroy ()函数用于销毁线程池，线程池任务链表中的任务不会再被执行，但是正在运行的线程会一直把任务运行完后再退出。
应用实例 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;pthread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82f7a7ba23273c7943910cdbe202dac4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04cd4ef5f7384a5b817bd16e78affa9e/" rel="bookmark">
			新药(化药)注册申报资料都包含哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新药的注册申报是新药上市前的重要步骤,其流程可以简单概括为①前期准备→②申报材料准备→③递交注册申请→④审评和审批→⑤监管和跟踪。本文将着重介绍新药(化药)注册申报的一般流程和主要环节(附流程图)。(关于新药注册申报成功率和耗费时间问题写到最后)
①前期准备
在开始新药注册申报之前，研发机构需要进行充分的前期准备工作。这包括对新药的研究和开发，包括药物化学、药理学、毒理学、药代动力学等方面的研究。同时，还需要进行临床试验的设计和实施，以获取新药在人体内的安全性和有效性数据。此外，还需要准备相关的申报材料，包括药物说明书、药物质量标准等。
②申报材料准备
在准备申报材料时，需要按照国家药品监督管理局（NMPA）的要求进行，包括《药品注册管理办法》等相关法规和规范。申报材料需要包括新药的化学结构、药理学特性、药代动力学、毒理学、临床试验数据等信息。此外，还需要提供药物的质量标准、生产工艺等相关内容。
③递交注册申请
一旦申报材料准备完毕，研发机构需要将申请材料递交给国家药品监督管理局进行注册申请。递交注册申请时，需要填写相关的表格和申请表，并缴纳相应的费用。同时，还需要提供申请材料的电子版和纸质版。
④审评和审批
递交注册申请后，国家药品监督管理局将对申请材料进行审评和审批。审评的目的是评估新药的安全性、有效性和质量，判断是否符合上市的条件。审评过程包括对申请材料的审核、临床试验数据的分析和评估等。审评的结果将决定是否批准新药上市。
⑤监管和跟踪
一旦新药获得批准上市，国家药品监督管理局将对其进行监管和跟踪。监管的内容包括对生产企业的质量管理体系的审核和监督、对药物的质量和安全性进行抽样检验等。同时，还需要对药物的不良反应和临床使用情况进行监测和报告。
注意上述内容仅基于近段国内新药(化药)药品注册申报流程整理，而国内药品注册申报政策调整变化原因，在新药注册申报过程中遇到的本文未涉及内容，请及时跟当局相关管理部门沟通交流后，再确定相应解决方案。
最后说下在了解某个药品注册申报成功率和所耗费时间的问题，最好的方法就是通过调研相似药物在全球的研发进展情况，可以使用药物研发分析工具进行高效的分析预测，如下图：
截图来源：药融云-全球药物研发数据库
截图来源：药融云-恩美曲妥珠单抗（上市时间轴&amp;研发状态）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b0e80d3a2fc26bc855f47f61b3d7288/" rel="bookmark">
			uniapp路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、路由登记 uni-app页面路由为框架统一管理，开发者需要在pages.json里配置每个路由页面的路径及页面样式。
类似小程序在 app.json 中配置页面路由一样。
所以 uni-app 的路由用法与 Vue Router 不同，如仍希望采用 Vue Router 方式管理路由，可在插件市场搜索 Vue-Router。
uni-app 通过 pages 节点配置应用由哪些页面组成，pages 节点接收一个数组，数组每个项都是一个对象，其属性值如下：
path： String类型，用于配置页面路径style： Object类型，用于配置页面窗口表现，配置项参考uniapp中pageStyleneedLogin：Boolean类型 默认false，表示是否需要登录才可访问 pages.json文件中 页面路由部分 代码示意 如下 👇：
{ "pages": [ { "path": "pages/index/index", "style": { ... } }, { "path": "pages/login/login", "style": { ... } } ] } 新建页面
点击文件夹 =》右键选择新建页面
点击新建页面后出现如下弹框：
新建页面的名称新建页面的文件类型是vue文件还是nvue文件还是两者都有是否创建同名目录，默认开启就是说默认他会给你先新建一个目录然后里面再放新建的页面文件新建页面的文件位置 一般情况下不会动这里，除非你一开始点新建页面的时候点错父级文件夹了选择模板，有很多个模板可以通过点击5的选择模板区域右侧预览模板，从而选择自己需要的合适模板。如果这里面都没有你想要的模板你还可以点击8左侧去插件市场选择模板，当然可以点击8右侧自定义模板是否要在pages.json中注册，默认是注册的，但如果你新建的页面是个组件的话这里可以取消创建，点击按钮就会按照你选择的条件新建一个页面。 2、路由跳转 uni-app 有两种页面路由跳转方式：使用navigator组件跳转、调用API跳转。
tips:
页面返回时会自动关闭 loading 及 toast, modal 及 actionSheet 不会自动关闭。页面关闭时，只是销毁了页面实例，未完成的网络请求、计时器等副作用需开发者自行处理。 2.1 使用navigator组件跳转 该组件类似HTML中的&lt;a&gt;组件，但只能跳转本地页面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b0e80d3a2fc26bc855f47f61b3d7288/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/">«</a>
	<span class="pagination__item pagination__item--current">2/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/3/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>