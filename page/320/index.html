<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e76f063caf2362d5632338b680edb9e6/" rel="bookmark">
			交叉熵损失函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、交叉熵损失函数含义
二、交叉熵损失函数定义为：​
三、交叉熵损失函数计算案例
一、交叉熵损失函数含义 交叉熵是一个信息论中的概念，它原来是用来估算平均编码长度的。给定两个
概率分布p和q，通过q来表示p的交叉熵为
交叉熵刻画的是两个概率分布之间的距离， p代表正确答案， q代表的是预测值，
交叉熵越小，两个概率的分布约接近
二、交叉熵损失函数定义为：
其中： 𝒚𝒊为标签值， 𝑦𝑖′为预值测
三、交叉熵损失函数计算案例 假设有一个3分类问题，某个样例的正确答案是（1， 0， 0）
甲模型经过softmax回归之后的预测答案是（0.5， 0.2， 0.3）
乙模型经过softmax回归之后的预测答案是（0.7， 0.1， 0.2）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80ae6cfa5ddc4f1791ed44f333f99d36/" rel="bookmark">
			线性代数代码实现（七）求解线性方程组（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
上次博客，我写了一篇关于定义矩阵除法并且代码的文章。矩阵除法或许用处不大，不过在那一篇文章中，我认为比较好的一点是告诉了大家一种计算方法，即：若矩阵 已知且可逆，矩阵 已知，并且 ，求解矩阵 B 。我认为这种初等行变换的方法还是挺好的。
在本篇文章中，我和大家探讨一下线性代数里面一个重要的知识——线性方程组及其解法。
一、线性代数知识回顾：
我们先探讨一下二元一次方程组的解法：
相信这个解法大家已经很熟悉了，将第一个式子的 -2 倍加到第二个式子上，就可以消掉第二个式子中的 x 了，然后第二个式子就只剩下 y 一个未知数了，就可以轻松解出 y ，然后将 y 代入第一个式子，就可以轻松解出 x ，到此，二元一次方程组求解完成。
从几何意义上看，这两个方程对应着二维平面上的两条直线，并且这两条直线交于一点（1,1），因此有唯一解。
有人可能会想到，不是所有的二元一次方程组都有解，因此我们看一看下面的例子： 大家看到，这个这个将第二个式子中两个未知数都化没了，并且观察这个方程组可知，它有无数解，其实容易看到，第二个式子就是第一个式子的 2 倍，实际上，这两个式子是等价的，第二个式子所描述的信息完全可以用第一个式子描述，也就是说这个方程组中 “有效方程” 的个数为 1 ，而只靠一个式子无法固定两个未知数，因此方程组有无数解。
从几何意义上看，这两个式子就是二维平面中的两个直线，而这两个直线是重合的，也就是说，两个直线相交的点有无数个，即：方程组有无数解。
那么，二元一次方程组有没有可能无解呢？看看下面的例子：
可以看到，消元后，第二个方程变为了一个不可能成立的式子。容易看出，这两个方程是矛盾的，因此是无解的。
从几何意义上看，这两个二维平面上的直线平行且不重合，没有交点，因此无解。
从上面二元一次方程组的回顾中，我们可以将方程组推广到 n 维情形：
同样按照上面的消元方法，不过这次稍微复杂，首先消去第 2 个到第 n 个方程的未知数 然后消去第 3 个到第 n 个方程的未知数 ，以此类推，直到消去最后一个方程的未知数 ，然后自下而上，先求出 ，代入倒数第二个方程，求出 ，代入倒数第三个方程，依次类推，便可求出方程组的解。大家仔细看看消元的过程，是不是和初等行变换十分像，我们其实可以将上述方程组这样表示：
设 上述方程组可以表示为：
为了表示方便，我们引入增广矩阵：
当我们对未知数规定书写顺序，那么增广矩阵就和线性方程组就 一 一 对应了，对方程组进行消元就等价于对增广矩阵 进行初等行变换，方程组的有效方程的个数就等于增广矩阵的秩，也等于系数矩阵的秩，也就是说，如果系数矩阵满秩，那么方程组有唯一解。当系数矩阵不满秩时，若没有矛盾方程出现，则方程组有无数解，若有矛盾方程出现，则方程组无解。
从几何意义来看，这 n 个方程组相当于 n 维空间中 n 个 n-1 维的平面。n 个平面交于一点等价于方程组中的 “有效方程” 的个数为 n ，等价于系数矩阵 满秩，等价于增广矩阵 的秩为 n ，等价于方程组有唯一解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80ae6cfa5ddc4f1791ed44f333f99d36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47aead7c0f3ef9560fa7960dbefd9ec4/" rel="bookmark">
			Array王锐力作：osg与PhysX结合系列内容——第5节 角色动画效果（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		〖Array王锐大神力作〗osg与PhysX结合系列内容——角色动画效果（下） 角色动作的过渡切换角色动画高级技巧构建测试场景并运行数据驱动的角色运动 角色动作的过渡切换 我们在研究下一步的高级角色动作之前，先看一下ozz的角色运动更新机制，这样也可以为我们后续“魔改”这个引擎的内部逻辑打下更好的基础。
ozz的动画更新流程主要分为下面四个步骤：
动画数据的采样：即根据上一帧到这一帧的时间间隔，计算动画应该经过的时间，进而从关键帧插值解算出每个关节点的局部坐标。多个动画的融合：将多个动画采样的结果按照独立的权重，融合在一起，得到最终叠加后每个关节点的局部坐标。这个步骤对于角色动画的过渡效果实现是至关重要的。骨骼数据的更新：将之前解算得到的角色动画关节点的局部坐标，匹配到实际角色的骨骼上，并计算得到骨骼坐标系（“世界”坐标系）下每个关节的实际位置矩阵。蒙皮和模型网格的更新：根据每个关节位置的变化，以及关节与模型各顶点之间的权重关系（即蒙皮），计算每个顶点更新后的位置坐标，以及法线结果，更新到模型网格上。 ozz将这套流程中的每个步骤都封装成独立的工作线程，也就是一个独立的Job。ozz自己负责每个Job的并行执行和效率效果，而各个步骤之间输入和输出的中间数据，我们随时都可以介入修改或者替换，这也使得ozz成为了一个非常灵活而且强大的中间件工具。
角色动画高级技巧 如图所示就是整个ozz系统大致的工作流程。注意SoA的含义是“Struct of Array”，在这里也就是一组关节数据的意思。
ozz允许多个动画被同时载入和采样，然后将它们计算的结果融合到一起。当然，每个动画应当有不同的权重值设置。一般来说，所有动画的权重之和不应该超过1.0，否则可能会有一些奇怪的结果出现。
从工作流程图中可以看出，每个动画都会用到一个独立的SamplingJob采样器，它会在动画数据的时间线上选择一个时刻，并计算该时刻对应的各关节位置姿态数值。
每个采样器输出的位置姿态结果，合并到BlendingJob中，按照不同的权重混合，就可以得到介于两个动画效果之间的一组新的位置姿态值。
采样器的权重值即可以全局设置，也可以根据每个关节来独立设置，因此可以实现精准的动画融合策略。
我们先来考虑全局权重设置的典型应用场景：假设有两个动画采样器，分别对应于“站立”（idle）和“走路”（walking）。
从站立姿态切换到走路姿态，或者反之的时候。如果直接切换，那么骨骼关节肯定会从当前的位置姿态突变到一个新的姿态。这个过程显得比较突兀，有必要加入一个合理的过渡过程。
考虑从站立姿态切换到走路姿态，过渡时间为0.5s。那么所谓的过渡实质上就是：idle采样器的权重值从1到0，而walking采样器的权重值从0到1。每个时刻t的动画融合结果应该是：
sampler[idle] * (1.0 - t / 0.5) +sampler[walking] * (t / 0.5)，其中t∈[0, 0.5] 实现的过渡过程如视频所示。在osgPhysX中这一切都是通过select()和seek()函数结合动画和权重参数配合完成，此处不再赘述。
角色动画效果-part1
简单的方法，无疑能够让我们的动画系统增色不少。那么下一步我们再看看有没有更高级的动画技巧可用。
1、分部融合（Partial Blend）
考虑两个动画采样器，例如“走路”（walking）和“手枪瞄准”（pistol_aiming），它们各自有独立完整的动画流程，直接融合在一起肯定是不伦不类的。但是在实际应用中显然存在着这样一类需求：角色没有持枪的时候双手下垂，跑步的时候则是摆臂姿势；但是如果角色同时持枪瞄准，则无论站立还是跑步的时候，都需要做出举枪瞄准的手势，虽然这个时候角色下半身的运动姿态通常是不变的。如果为所有“持枪”和“未持枪”的动作都制作两套动画，那么无疑是一种资源的浪费。因此，前文提出的“根据每个关节来独立设置权重”的方案在这里就非常有价值了。我们可以设置walking采样器中，所有脊柱（spine）之下的关节的独立权重都是1.0，而脊柱之上的关节权重都是0.0；同理，pistol_aiming采样器中，脊柱之下的关节权重都是0.0，而脊柱之上的关节权重是1.0，从而得到这种融合的效果，如视频所示。 角色动画效果-part2
osgPhysX中通过selectPartial()函数来实现这类复杂的权重设置。 2、附属物品（Attachment）
附属物品，顾名思义就是随着人体某个关节运动的物品。例如拿在手中的手枪和棍棒，或者别在腰间的腰带，手机，抑或头上戴的帽子和脖子上绕着的披风。附属物品的设计可以复杂（例如柔体，衣物，或者和多个关节关联）也可以简单，不过它们都需要一个最基本的信息，就是被附属的关节在当前时刻的位置和姿态。这个位置姿态矩阵属于角色自身的模型坐标系，也就是以角色根节点为原点的坐标系统。以Mixamo的角色为例，角色模型坐标系的原点位于站立姿态时双脚在地面的中心点，Y+方向为角色向上的方向，Z+方向为角色向前的方向。如视频所示，osgPhysX提供了专门的封装函数getModelSpaceJointMatrix()来实时获取任何关节的模型坐标系矩阵，注意一定要在update()和update*IK()之后再执行这个函数，否则得到的矩阵值可能不是最新的。 角色动画效果-part3
3、反向运动学（IK）
反向运动学，简单来说就是通过子骨骼关节的目标位置姿态来反推算上级父关节的位置姿态。这样得到的结果可能有多个，但是我们可以添加更多的约束条件来更精准的结果。IK算法有很多的分支，例如Unreal中的TwoBoneIK，FABRIK，CCDIK等。ozz本身实现了TwoBoneIK（定义三个关节为一组，通过末端关节的运动推算前两个关节）和AimIK（定义一组多个关节和权重，通过末端点的运动位置和方向，推算各个关节的位置姿态）。osgPhysX中通过updateAimIK()和updateTwoBoneIK()两个函数来封装ozz的IK功能，如视频所示，因为部分参数设置和调优的问题，在某些角度IK肯定还是存在变形，但是大多数情况下已经可以用于具体的应用需求了。 角色动画效果-part4
构建测试场景并运行 我们在osgPhysX/tests/character_animation_test.cpp中实现了上述所有的动画功能，这样至少能够让我们的系统看起来像是一个高级游戏角色引擎的原型了。
程序代码中，首先通过loadAnimations()加载所有的预设动画：这些动画都来自于mixamo，并保存到osgPhysX/utils/ozz/tools/data目录下，我们将所有的动画ozz文件都保存到执行程序目录中的一个子文件夹animations中，并且将skeleton和mesh的ozz文件放在执行目录下。
程序运行时，可以通过PageUp/PageDown来切换显示不同的动画效果，每次切换中间已经做了0.5秒的过渡。
可以通过Home键来显示PartialBlend的效果，即当前动画效果与持枪效果的叠加；按End键恢复正常状态。
可以通过Insert/Delete键来显隐IK效果，并通过数字键0-4切换不同的IK部位（头/手/脚）跟随鼠标运动。
按Tab键之后，角色会始终手持一个圆柱体（用来演示Attachment功能），无论他在什么动画状态下。
更多的动画功能，就有待读者去挖掘了，下一章我们还是回归物理引擎比较好。
数据驱动的角色运动 因为ozz的存在，我们完全有可能通过外部输入的骨骼数据来驱动一个动画角色。只要能够提供每个关节在角色模型坐标系下的位置和姿态数据，就可以通过外部的数据来驱动角色的实时肢体运动。
这里所说的外部数据包括但不限于Microsoft Kinect，运动捕捉设备，或者一些比较新的AI运动预测算法（例如OpenPose+3dbaseline）等。对于osgPhysX而言，只需要逐帧通过setModelSpaceJointMatrix()来设置关节数据；另一种方案是只采集头部，双手和双脚的IK数据，然后推算中间的关节姿态。不过相关的实现案例，暂时并不属于本教程所关注的内容。
至此，我们花了巨大的篇幅，在实现和讲解物理引擎的同时，重新塑造了基于osg的角色动画系统，并且让它有了完整的工作流程（从Mixamo到ozz，再到osg中显示），以及支持多种常用的角色动画技巧（动画过渡，动作叠加，附属物，IK等）。
也许后续我们会将这个角色动画系统从osgPhysX中独立出来，单独开源和加以改造应用；又或者有感兴趣的朋友可以加入到osgPhysX的贡献工作中，或者单独摘出这部分代码进行魔改，将角色系统调优和发扬光大。不过截至目前，它还只是一个独立的类（osgPhysicsUtils::PlayerAnimation），以及一个独立的例子罢了。
更多的可能性，就随着这个教程的延续（不过我们下一章会开始一个全新的话题），以及随着时间，慢慢发酵吧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d15dd67db9777e9cf0fe49678041a0a/" rel="bookmark">
			研究一下exp, ln, pow的数值计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		研究一下exp, ln, pow的数值计算 pow计算exp的算法泰勒级数展开快速算法进一步减少尾数利用双精度表达提高运算效率实验 ln(x)计算实验 参考 pow计算 a b = e l n a b = e b ∗ l n a a^b=e^{ln\ a^b}=e^{b*ln\ a} ab=eln ab=eb∗ln a所以任意指数都可以有自然指数和对数来求得。
exp的算法 形如 y = e x y=e^x y=ex的指数函数用底层实现，最直接的是泰勒逼近，然后找到一篇国内的paper指数函数e^x的快速计算方法，分析下来感觉不错，记录一下
泰勒级数展开 e x e^x ex的泰勒展开为： e x = 1 + x 1 ! + x 2 2 ! + x 3 3 ! + x 4 4 ！ + . . . . e^x=1+\frac{x}{1!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d15dd67db9777e9cf0fe49678041a0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eea254dfdef26a21c0081cb3a218248/" rel="bookmark">
			电脑文件夹需要权限才能删除怎么处理？（已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件夹无法删除是一件比较棘手的事情，不知道大家是怎么解决的呢？本文来为大家详细讲解，电脑文件需要权限才能删除的处理方法。
方法一：获得权限 很多时候因为权限的问题无法删除电脑文件夹，这种情况下对应的解决方案也很简单。
删除文件夹时，删除的前面有一个权限的小图标，是权限不够的提示，也可以证明我们的权限被更改过，在权限编辑的窗口，我们的权限一定不是完全控制的，否则我们就可以将其删除。
选中想要删除的目标文件夹，右击，单击【属性】，再点击上方，进入【编辑】，依次点击【添加】，右击【高级】【立即查找】【Adminstrators】【确定】。然后勾选权限中所有选项【允许】，确定后删除文件即可。
方法二：结束进行中的程序 为了保护文件夹的完整性，其他程序占用文件时，我们是不能删除文件所在的文件夹的。
此时，打开任务管理器，右键单击，结束程序，我们就可以删除文件夹了。
文件夹无法删除的情况就介绍到这里。关于电脑操作中其它一些无法删除文件的情况，在这里就不赘述了。
另外，发生了误删了文件，回收站也不能还原该文件的情况也不用焦急，在没有写入新的数据，覆盖新的文件的情况下，我们可以通过第三方数据恢复软件完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/527611461fae4f4b09c5bc3c2b4f7ef8/" rel="bookmark">
			腾讯汤道生：上云赋智的终极价值是服务于人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		11月3日至4日，2021腾讯数字生态大会在武汉正式举办。云智能专场上，腾讯高级执行副总裁、云与智慧产业事业群CEO汤道生通过《上云赋智，塑造新生产力》主题演讲，围绕服务理念、实践案例、战略架构等维度，对外分享了腾讯通过构建“服务于人”的智能应用和产品，助力产业数字化发展的经验和理念，并正式公布了腾讯云智能的战略架构。
腾讯高级执行副总裁、云与智慧产业事业群CEO 汤道生
“数字世界和物理世界正在无缝衔接，以人工智能、大数据、云计算为代表的数字技术，逐渐深入我们生产生活的毛细血管，推动各行各业数字化转型，迎来新的发展机遇。”汤道生表示，智能化转型是数字化转型的必经之路，在行业普遍上云的背景下，AI已经成为产业互联网中新的需求增长点。
汤道生认为，无论是“终端智能”还是“云上智能”，上云赋智的终极价值还是“服务于人”。而管理者、生产者、开发者和用户这四类人群对AI的核心需求，就是决策、协作、创新和服务这四大能力。为满足以上需求，腾讯云智能在助力建设产业互联网的过程中，也做了相应部署和丰富实践。
以管理者的决策需求为例，在腾讯云智能TI平台训练、推理和发布的20余种城市管理算法的助力下，上海松江区的“一网统管”城运中心能够对占道堆物、交通违章、垃圾违规堆放等场景进行7*24小时推算决策和精准识别，算法准确度达90%。
谈及腾讯云智能的战略架构时，汤道生表示，通过在腾讯产业互联网的不断实践，腾讯云智能已经完成了从“单点智能”到“全局智能”的升级，未来将依托人工智能、大数据、云计算和物联网的云智能架构，通过智能底座层、智能平台层、产品和服务层及智能生态层向各行业输出贴合客户产业场景需求的智能综合解决方案。
汤道生表示，腾讯云智能不仅要成为各行业塑造竞争优势新生产力的生产工具，更要让人们工作更高效、生活更幸福、体验更美好，为人们带来新的启发和认知，帮助人们探索世界和创造未来。
以下是演讲全文：
尊敬的各位嘉宾、媒体朋友和线上的观众朋友们：
大家上午好！欢迎来到腾讯数字生态大会云智能专场。近年来，全社会对人工智能的期待逐步从热炒到回归理性，与实体经济的融合创新成为大势所趋。正如今年的大会主题“数实融合，绽放新机”，数字世界和物理世界正在无缝衔接，以人工智能、大数据、云计算为代表的数字技术，逐渐深入我们生产生活的毛细血管，推动各行各业数字化转型，迎来新的发展机遇。
在数字化的过程中，智能化转型是必经之路，上云赋智早已成为行业共识。2020年第一季度到2021年第一季度，中国的用云量指数增长了57%。在行业上云的基础上，AI作为产业互联网的中央处理器，成为新的需求增长点。
但无论是“终端智能”还是“云上智能”，上云赋智的终极价值还是“服务于人”。
数字技术需要深刻洞察每个角色在数字化转型中的需求。在底层技术上，构建服务于人的应用，帮助企业和组织实现数字化转型的目标。
在当前阶段，产业互联网核心考验的是对人的理解、连接人的能力和不断迭代优化的应用实践。对于管理者、生产者、开发者和用户这四类人群来说，核心需要的是决策、协作、创新和服务四大能力。基于此，腾讯云智能也做了相应部署和丰富实践。
首先，面向管理者提供“智能驾驶舱”，助决策者发现新机会、提升组织效能。传统的城市管理巡检效率低，消耗人力大，且存在覆盖范围小，违规事件发现不及时等痛点。上海松江区的“一网统管”城运中心，基于腾讯云TI平台，训练、推理和发布20余种城市管理算法，可识别出占道堆物、交通违章、垃圾违规堆放等。算法准确度达90%，实现了7*24小时推演决策，可应对市容市貌、安全生产、社区治理等问题，提升民众生活品质。
其次，面向生产者提供人机协同的环境，助生产者更好地完成工作，增效提质。作为领先的金属注射成型的零件生厂商，上海富驰高科的质检工人，长期面临高难度的质检要求，且长时间劳动造成的疲劳容易带来漏检。在部署了腾讯云智能质检产品后，客户的质检速度提高了十倍，首次达到业界0漏检，节省千万成本。
再次，面向开发者提供完善的开发平台和工具，助开发者降低开放门槛，简单易用。目前，腾讯云智能已经开放了超过300项AI原子能力。腾讯云智能大数据ES为B站提供日志分析场景全托管服务，助力开发人员零运维投入、开箱即用；同时，精准分析游戏各生命周期状态，助力游戏运营人员提升决策效率和质量。
最后，面向C端用户提供全方位的连接服务，助用户真正实现智慧生活。电器消费者在购买智能设备后，因配网难、操作繁琐、学习门槛高等原因并未激活，智能设备往往沦为“哑设备”。基于此，我们推出了腾讯连连小程序，用户可通过微信扫一扫极速配网，兼容不同品牌的智能终端，帮助用户激活沉睡设备，轻松实现全屋智能。目前，腾讯连连已接入超过3亿台各行业物联网设备，服务可用性达99%。
在过去腾讯产业互联网的实践中，我们已经完成了腾讯云智能的总体布局。通过AI与云的深度融合，大大降低AI开发和使用门槛，让客户实现高效开发、按需使用，从而满足客户在新型应用场景下，综合复杂、多层次的计算需求。
这里，我也向大家正式介绍一下腾讯云智能的战略架构情况。我们从数据这一核心要素资源出发，以数据采集、传输、存储和计算的全流程视角，综合应用人工智能、大数据、云计算和物联网等技术，完成了从“单点智能”到“全局智能”的升级。
依托人工智能、大数据、云计算和物联网的云智能架构，贴合客户的产业场景需求，输出面向各行业的智能综合解决方案。
在基础底座层，我们提供了领先的算力、丰富的存储等资源，依托腾讯云在存储、数据库、云原生、服务器和网络计算的积累，为客户提供稳定可靠、性能优异的服务。
在智能平台层，我们为行业开发者提供了一站式平台服务，包括AI、物联网和大数据三大平台。AI开发平台可以组合数据源、组件、算法、模型和评估模块，支持公有云访问、私有云和专有云部署；物联网平台，为各行业设备制造商、方案商及应用开发商，提供一站式智能设备服务，日均处理设备消息量超数十亿，支持百万级设备并发接入；大数据平台，打通了通用大数据开发、数据治理涉及到的所有环节。腾讯云不仅已经成为国内算力最强的云厂商，同时也是日实时计算量最大的公司。
在产品和服务层，我们将AI原子能力，封装成标准化的服务，让用户实现即插即用。我们提供了包括语音、图像等标准化的AI能力，数字虚拟人、对话机器人等人机交互服务，企业画像、神盾联邦计算等云大数据SaaS产品，以及面向C端用户的腾讯连连小程序。
在智能生态层，我们聚焦消费互联网、产业互联网及可持续社会价值创新三大方向，面向金融、工业、教育、医疗等各行业提供了超过90种全套智能化解决方案。
在我国经济提速换挡的关键时期，腾讯将始终坚持“产业数字化助手”定位，与合作伙伴共建数字生态共同体，助力产业数字化发展，助力中国数字化建设。
当然，腾讯云智能不仅仅是数字化工具，为各行业塑造竞争优势的新生产力，更要让人们工作更高效、生活更幸福、体验更美好，为人们带来新的启发和认知，帮助人们探索世界和创造未来。
谢谢大家！
点击此处了解更多腾讯云AI产品解决方案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a270ed293ddce90e302079b1a3e6acb6/" rel="bookmark">
			集信达总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 系统设计1. 在集信达平台为什么要拆分出api服务server服务manager服务三个服务？这三个服务分别对应了什么功能？ 数据库相关2. 集信达平台有哪些数据库表数据库表，其中通道和签名表，通道和模板表是什么关系？写出至少5张表3. 提供通道id，签名id，如何查询出通道和签名对应的通道 业务相关4. api服务最终将数据保存在了哪里？B5. 简单介绍api服务的业务逻辑？6. manager工程为什么最后要往redis里发送消息 技术7. 编写的sdk如何集成到别人的系统中去？8. 手写单例模式 建议设计成 饿汉式/枚举/holder内部类方式得一半分 懒汉式+DCL+voliate 满分9. filter,interceptor,controllerAdvice,aspect,controller的执行顺序 只考虑拦截方向10. springAOP中的通知类型11. 项目中为什么要搭建这样的一个短信中台12. 反射原理13. 接口和抽象类的区别14. 定时短信的实现逻辑15. 项目中使用的策略模式？并给出使用策略模式的理由？ 系统设计 1. 在集信达平台为什么要拆分出api服务server服务manager服务三个服务？这三个服务分别对应了什么功能？ 答：因为需要采用分布式设计需要拆分成3个服务，采用单体架构需要拓展的服务会包含manager后台管理功能，而manager没有并发和大数据量不需要横向拓展需要单独抽离
api服务和server服务的业务复杂度不同，api服务仅仅对请求的数据做校验，server服务是真正发送http请求到短信服务商的，承载的数据压力不同，需要单独抽离成两个服务
数据库相关 2. 集信达平台有哪些数据库表数据库表，其中通道和签名表，通道和模板表是什么关系？写出至少5张表 1）黑名单表black_list 2）通道表config 3）通道签名中间表config_signature 4）通道模板中间表config_template 5）签名表signature 6）模板表template 7）人工表manual_process 8）接入平台表platform 9）接收日志表receive_log 10）发送日志表receive_log 11）定时发送任务表timing_push 3. 提供通道id，签名id，如何查询出通道和签名对应的通道 SELECT c.* FROM config c LEFT JOIN config_template ct ON c.id = ct.config_id LEFT JOIN config_signature cs ON c.id = cs.config_id WHERE c.is_active = 1 AND c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a270ed293ddce90e302079b1a3e6acb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de0c5fe921a0018b6aa29def5d9a4b87/" rel="bookmark">
			java四舍五入保留小数位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四舍五入保留两位小数 方法① BigDecimal b = new BigDecimal(double d); double value = b.setScale(2, BigDecimal.ROUND_HELF_UP).doubleValue(); 方法② String df = new DecimalFormat("#.00"); String value = df.format(double d); 方法③ String value = String.format("%.2f", double d); //%:小数点前任意位数，2:小数点后两位，f:浮点型 方法④ double value = Math.round(double d * 100) * 0.01d; //0.01d:小数点后位数（四舍五入） BigDecimal八种模式 类型注释ROUND_UP绝对值最大的方向舍入，非0即进位ROUND_DOWN绝对值最小的方向输入，舍弃全部ROUND_CEILING正数入，负数舍（Math.round()使用此模式）ROUND_FLOOR正数舍，负数入ROUND_HALF_UP四舍五入ROUND_HALF_DOWN五舍六入ROUND_HAIL_EVEN银行家舍入法(四舍六入，五前为奇数入否则舍)ROUND_UNNECESSARY断言请求的操作具有精确的结果，因此不需要舍入。 ROUND_UP：多余位置非0进位 ROUND_UP正数：1.24
ROUND_UP负数：-1.24
ROUND_DOWN：舍弃多余的 ROUND_DOWN正数：1.23
ROUND_DOWN负数：-1.23
ROUND_CEILING：趋向最大值 ROUND_CEILING正数：1.24
ROUND_CEILING负数：-1.23
ROUND_FLOOR：趋向最小值 ROUND_FLOOR正数：1.23
ROUND_FLOOR负数：-1.24
ROUND_HALF_UP：四舍五入 ROUND_HALF_UP正数：1.24
ROUND_HALF_UP负数：-1.24
ROUND_HALF_UP正数：1.23
ROUND_HALF_UP负数：-1.23
ROUND_HALF_DOWN：五舍六入（保留小数时和ROUND_HALF_UP结果相同） ROUND_HALF_DOWN正数：1.24
ROUND_HALF_DOWN负数：-1.24
ROUND_HALF_DOWN正数：1.1235
ROUND_HALF_DOWN负数：-1.1235
ROUND_HALF_DOWN正数：10.0
ROUND_HALF_DOWN负数：-10.0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de0c5fe921a0018b6aa29def5d9a4b87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c07418a7707683da6a1a78ac214137e1/" rel="bookmark">
			matlab的textscan与textread区别（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：【转】matlab的textscan与textread区别 - 小新新的蜡笔 - 博客园 最近工程中用到matlab处理文件，用到textread，找到作者的总结，进行摘录，侵删。 1，基本语法
textscan的基本语法是：
C = textscan(fid, 'format')
C = textscan(fid, 'format', N)
其中fid为fopen命令返回的文件标识符，这也是和textread的最大不同之处，需要注意的一点是，fid类似一个指针，其指向的位置会随着textscan的操作而改变，每读取一次数据，它的位置就会指向你已经读过的那个数据的后面。format实际上就是一个字符串变量，表示读取数据及数据转换的规则。N为按照读取格式format读取的次数。
textread的基本语法是：
[A,B,C,…] = textread（filename,format）
[A,B,C,…] = textread（filename,format,N）
其中filename就是文件名， format就是要读取的格式，A,B,C就是从文件中读取到的数据。
必须严格遵守用法不可出现data=textread(filename,format,N)的形式
其中括号里面变量的个数必须和format中定义的个数相同。 如果每N行相同格式的数据，可采用[A,B,C,…] = textread（filename,format,N）的语法，读取N次。
2，两者的区别
可以看出这个两个函数最大的区别就是：textread不用先fopen那个文件，适用于格式统一的txt文件的一次性大批量读取。而使用textscan函数之前需要先用fopen函数打开要读取的文件并返回句柄fid。
其次textread读取某个文件后，下次再用textread读取这个文件时，还是会从文件头开始读取。而textscan函数每次读完数据后，其对应的句柄fid都是指向接下来要读数据的地方，类似于C函数中的文件读取指针，这样更方便于读取文本时的精确控制。
再次，textscan函数可以将多组数据读到一个元胞矩阵中，而textread函数只能将数据分别读取到不同的向量中。比如一个含有10行3列浮点数的文件，textscan函数可以将之读取到一个变量名A下 A=textscan(fid, '%f%f%f'), 而使用textread函数必须将之读入到三个变量名中 [A,B,C] = textread（filename,'%f%f%f'）。
3，几个方便的语法
假设文件myfile.txt 中的内容如下
Sally Type1 12.34 45 Yes
Joe Type2 23.54 60 No
Bill Type1 34.90 12 No
3.1将其分别使用textread 和textscan读出：
[data1 data2 data3 data4 data5] = textread('myfile.txt','%s%s%f%d%s');使用textread函数分别将数据按照格式读入到data1—data5中。然后可使用赋值语句data=[data1 data2 data3 data4 data5 data6]生成一个二维数组data。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c07418a7707683da6a1a78ac214137e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cbb4d551369c47b1280a5cab5372cb0/" rel="bookmark">
			用XAMPP搭建本地：Web服务器，访问服务器，下载服务器。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用XAMPP搭建本地：Web服务器，访问服务器，下载服务器。 首先需要下载XAMPP，链接为：XAMPP下载地址，XAMPP中文网。
下载完成后进行安装，直接一键点到底。
一、如何确定我们安装完成了？ 找到安装目录，然后点击运行。
接着测试我们是否启动成功，打开浏览器，输入：localhost然后回车；也可以直接点击按钮Admin，如果成功会提示下边的样子。
接着测试我们是否启动成功，打开浏览器，输入：localhost然后回车；也可以直接点击按钮Admin，如果成功会提示下边的样子。
如何才能访问我们自己的文件？ 首先找到我们使用的Apache文件路径，然后找到他里边的dashboard文件夹，接着创建属于我们自己的文件夹（任意名字都行）我这里是：download文件夹。 接着在下边创建我们自己的文件te文本，内容为“xiaohei create server is succeed.”。
然后我们在服务器尝试访问。
那么有的需求是我们要再移动端进行访问，在怎么办？简单，让小黑教你，嘿嘿嘿嘿嘿！
我们把localhost改为自己的IP地址即可！
什么，还需要https访问？ 那好办，直接加上hppts://就好了
上结果！
三、怎么才能下载我们自己的文件？ 首先打开安装目录，并且找到下边apache\conf目录下的httpd.conf文件 。使用文本编辑器(Notepad++ || Sublime)打开，搜索(Ctrl + F)关键字：DocumentRoot，找到下边图片所显示的位置。
接着在这个位置的下边，写几句命令行，内容是如下所示。 &lt;Directory "D:/XAMPP_Files/htdocs/download"&gt; Header set Content-Type "application/octet-stream" &lt;/Directory&gt; 这就是所谓的设置访问头（如果描述不对，还请大家指出，我会做出更正。），使得该文件下边的内容全部以流的形式输出。
保存文件，然后在定义的路径下边放置需要被下载的内容，这里演示是小黑自己创建了一个文本。输入下载链接，如果是移动端访问，记得加https://或hppt://，然后是自己的服务器IP地址，加自定义的路径名 + 文件名.后缀名。例如小黑自己的：https://192.168.24.87/download/text.txt。然后下载。 那手机上小黑就不再展示了，测试后得出结果都是一样的。
四、需要注意哪些问题？ 移动端在访问时，一定要和电脑是同一网段内。下载时文件后缀名一定要带着，没有后缀名当然可以不带。如果还是不行，记得查看一下端口号，如何查看？
a. 还是打开安装目录下apache\conf目录下的httpd.conf文件。
b. 搜索(Ctrl + F)关键字：Listen，然后找到如下图所示，改为自己的端口号。 目前，别的服务器我还没有尝试，待我需要时我会去尝试的！
希望大家：点赞，留言，关注咯~ 😘😘😘😘 唠家常 小黑的今日分享结束啦，小伙伴们你们get到了么，你们有没有更好的办法呢，可以评论区留言分享，也可以加小黑的QQ：841298494，大家一起进步 今日无推荐 客官，看完get之后记得点赞哟！小伙伴你还想要别的知识？好的呀，分享给你们😄小黑的杂货铺，想要什么都有，客官不进来喝杯茶么？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c33f6acfccebc14e624504b0cf97a2/" rel="bookmark">
			本地测试微信登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载软件ngrok 下载地址：ngrok - secure introspectable tunnels to localhost
具体操作：Windows 下 配置 ngrok ngrok使用教程_冷秋月的专栏-CSDN博客_ngrok
二、修改本地hosts文件 这里显示的是window的路径，打开hosts文件,添加映射: 本地ip-&gt;测试域名
三、申请微信测试号 微信公众平台接口测试账号申请，输入生成的本地url地址
四、获取code 1.找到对应微信url地址（网页开发为例）： https://open.weixin.qq.com/connect/oauth2/authorize?appid=xxxxxx&amp;redirect_uri=http%3A%2F%2Fxxx.xxx.cn&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE 2.微信开发者工具，选择公众号网页
3.输入对应并请求url地址后，可获取到code值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/592286c9b3cef3084368974aaa961b27/" rel="bookmark">
			多线程交替打印ABC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 使用三个线程，1,2,3，分别负责打印A,B,C，打印10次。
分析 分析锁的获取和释放和通知，线程堵塞
方式1，使用ReentrantLock 使用ReentrantLock(true)公平锁，再设置操作的标志位current(A,B,C)，当current和当前线程负责打印的字段相同，执行操作，否则释放锁，执行完，释放锁，代码如下：
public class PrintABCTask extends Thread { private static ReentrantLock lock = new ReentrantLock(true); private static String current = "A"; /** * 私有字段 */ private String value; public PrintABCTask(String name, String value) { super(name); this.value = value; } @Override public void run() { for (int i = 0; i &lt; 10; ) { lock.lock(); // 条件判断通过while，而不是if，但是用if通常好像也没出现过问题 while (current.equalsIgnoreCase(value)) { System.out.printf("%s:%s\t", getName(), value); current = next(current); i++; } lock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/592286c9b3cef3084368974aaa961b27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77952236972ef066a9f188eac4251d3b/" rel="bookmark">
			电气器件系列三十：伺服电机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：
伺服电机可以控制速度，位置精度非常准确，可以将电压信号转化为转矩和转速以驱动控制对象。伺服电机转子转速受输入信号控制，并能快速反应，在自动控制系统中，用作执行元件，且具有机电时间常数小、线性度高等特性，可把所收到的电信号转换成电动机轴上的角位移或角速度输出。
分类：
【浅谈】伺服电机的分类与特性 - 知乎
原理：
伺服电机工作原理
伺服电动机的工作原理及作用
伺服电机的作用是驱动控制对象。被控对象的转距和转速受信号电压控制，信号电压的大小和极性改变时，电机的转动速度和方向也跟着变化。
伺服电动机分类
交流伺服电动机和直流伺服电动机。
一、交流伺服电动机
原理与两相交流异步电机相同，定子上装有两个绕组—励磁绕组和控制绕组。
励磁绕组和控制绕组在空间相隔90°。
1、接线：
励磁绕组的接线 控制绕组的接线
励磁绕组中串联电容C的目的是为了产生两相旋转磁场。
适当选择电容的大小，可使通入两个绕组的电流相位差接近90°，因此便产生旋转磁场，在旋转磁场的作用下，转子便转动起来。
例：选择电容，可使交流伺服电机电路中的电压电流的相量关系如图所示。
控制绕组的接线
控制电压
与电源电压
两者频率相同，相位相同或反相。
工作时两个绕组中产生的电流
和
的相位差近90°，因此便产生旋转磁场。在旋转磁场的作用下，转子转动起来。
2、交流伺服电动机的特点：
1）U2= 0 时，转子停止。
这时，虽然U2 =0V，U1仍存在，似乎成单相运行状态，但和单相异步机不同。若单相电机启动运行后，出现单相后仍转。伺服电机不同，单相电压时设备不能转。
原因：交流伺服电机 R2设计得较大。所以在U2=0时，交流伺服电机的T=f(s)曲线如下页图：
交流伺服电动机的T=f(s)曲线（U2=0时）
当U2=0V时，脉动磁场分成的正反向旋转磁场产生的转距T'、T" 的合成转矩T与单相异步机不同。合成转矩的方向与旋转方向相反，所以电机在U2=0V时，能立即停止，体现了控制信号的作用(有控制电压时转动，无控制电压时不转)，以免失控。
（2）交流伺服电机R2设计得较大，使Sm&gt;1，Tst大，启动迅速，稳定运行范围大。
（3）控制电压U2大小变化时，转子转速相应变化，转速与电压U2成正比。U2的极性改变时，转子的转向改变。
交流伺服电动机的机械特性曲线( U1=const )
3、应用
交流伺服电机的输出功率一般为0.1-100W，电源频率分50Hz、400Hz等多种。它的应用很广泛，如用在自动控制、温度自动记录等系统中。
二、直流伺服电动机
1、结构：与直流电动机基本相同。为减小转动惯量做得细长一些。
2、工作原理：与直流电动机相同。
3、供电方式：他励。励磁绕组和电枢由两个独立电源供电：
U1为励磁电压，U2为电枢电压。
直流伺服电机的机械特性公式与他励直流电机一样：
4、机械特性曲线
由机械特性可知：
(1)U1（即磁通￠）不变时，一定的负载下，U2↑,n↑。
(2)U2=0时，电机立即停转。
反转：电枢电压的极性改变，电机反转。
5、应用：
直流伺服电机的特性较交流伺服电机硬。经常用在功率稍大的系统中，它的输出功率一般为1-600W。它的用途很多，如随动系统中的位置控制等。
注意区别于步进电机：
伺服电机与步进电机的性能比较
步进电机作为一种开环控制的系统，和现代数字控制技术有着本质的联系。在国内的数字控制系统中，步进电机的应用十分广泛。随着全数字式交流伺服系统的出现，交流伺服电机也越来越多地应用于数字控制系统中。为了适应数字控制的发展趋势，运动控制系统中大多采用步进电机或全数字式交流伺服电机作为执行电动机。虽然两者在控制方式上相似（脉冲串和方向信号），但在使用性能和应用场合上存在着较大的差异。现就二者的使用性能作一比较。
一、控制精度不同
两相混合式步进电机步距角一般为 1.8°、0.9°，五相混合式步进电机步距角一般为0.72 °、0.36°。也有一些高性能的步进电机通过细分后步距角更小。如三洋公司（SANYO DENKI）生产的二相混合式步进电机其步距角可通过拨码开关设置为1.8°、0.9°、0.72°、0.36°、0.18°、0.09°、0.072°、0.036°，兼容了两相和五相混合式步进电机的步距角。
交流伺服电机的控制精度由电机轴后端的旋转编码器保证。以三洋全数字式交流伺服电机为例，对于带标准2000线编码器的电机而言，由于驱动器内部采用了四倍频技术，其脉冲当量为360°/8000=0.045°。对于带17位编码器的电机而言，驱动器每接收131072个脉冲电机转一圈，即其脉冲当量为360°/131072=0.0027466°，是步距角为1.8°的步进电机的脉冲当量的1/655。
二、低频特性不同
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77952236972ef066a9f188eac4251d3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b5bb1d7185611e3cc5302835c7c4aa/" rel="bookmark">
			【pyinstaller打包pyqt5编写的项目为exe（脱离环境可运行）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
下载pyinstaller库
0、pyinstaller语句介绍
1、单个py文件打包成exe
1)只有py文件
假设只有一个py文件：pyinstaller -F xxx.py
加上图标：pyinstaller -F xxx.py -i xxx.ico
取消命令行窗口:pyinstaller -F -w xxx.py -i xxx.ico
2) 不但有py文件，还有其他格式的文件
进入项目所在根目录
运行得到spec文件：pyi-makespec main.py
修改 spec文件
执行 pyinstaller -F main.spec命令
2、多个py文件打包成exe
1）方法一：pyinstaller直接运行得到
2）方法二：多步骤进行
（1）使用命令行窗口进入项目的根目录
（2）在改目录下执行pyi-makespec main.py（main.py是你的主入口文件）
（3）修改main.spec文件
（4）执行 pyinstaller -F main.spec命令
（5）在dist/main文件夹里面点击.exe文件
3、携带非py文件打包exe
1）同上述方法二所述
2）方法一+移动data文件夹
4、一些经验和技巧
5、参考链接
下载pyinstaller库 pip install pyinstaller
我这里是使用清华的镜像下载的，因为直接使用 pip install 速度会慢一点，使用国内的镜像网站那速度可蹭蹭的快啊。
pip install -i http://pypi.douban.com/simple/ pyinstaller 0、pyinstaller语句介绍 pyinstaller -F -w -i xxx.ico xxx.py -p x:\...\site_packages
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24b5bb1d7185611e3cc5302835c7c4aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1086195e10ca3edd941448c560b4d82b/" rel="bookmark">
			什么是分片上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分片上传 一、了解分片上传1.简单上传的缺点及问题这样做有什么问题？ 1.什么是分片上传？解决上面简单上传的问题 我们最终确定对于大文件的上传采用分片上传的模式进行上传，那么我们该如何实现分片上传？ 一、了解分片上传 1.简单上传的缺点及问题 由于我们上传的文件都不是大文件，如果我们上传文件的话，由于我们的文件是通过MultipartFile类上传
如果通过MultipartFile类进行上传文件如果文件太大了会报错
"message": "Maximum upload size exceeded; nested exception is java.lang.IllegalStateException: org.apache.tomcat.util.http.fileupload.FileUploadBase$FileSizeLimitExceededException: The field file exceeds its maximum permitted size of 1048576 bytes.", 默认情况下MultipartFile的上传大小是1M，如果文件超过1M就会报错
下策就是通过修改配置
server: port: 8080 spring: servlet: multipart: #max-file-size: 5MB #是设置单个文件的大小, #max-request-size: 5MB #设置单次请求的文件的总大小 #######如果不想限制上传文件的大小 将 max-file-size 和 max-request-size都设置成 -1###### max-file-size: -1 #是设置单个文件的大小, max-request-size: -1 #设置单次请求的文件的总大小 这样做有什么问题？ 1）当我们的文件特别大的时候，上传是不是需要很长的时间啊，这么长时间的长连接，如果网络波动了呢？中间网络断开了呢？
在这么长时间的过程中如果出现不稳定的情况，本次上传的所有内容就全部失败了，又要重新上传
2）大文件上传的过程中，如何实现暂停上传的功能，比如我要暂停10分钟时间把网络资源空闲出来给别的服务，那么暂停后的继续上传如何实现？
3）上传速度无法显著提升，单线程上传
1.什么是分片上传？ 分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（我们称之为Part）来进行分别上传，
上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件。
分片上传不仅可以避免因网络环境不好导致的一直需要从文件起始位置还是上传的问题，
还能使用多线程对不同分块数据进行并发发送，提高发送效率，降低发送时间。
简单的说：无论什么文件都是字符串组成的字节码文件，不同的软件可以识别不同的字节码文件，我们上传的时候将这些字节码文件
按照一定的大小进行分块，将一个大的文件拆分成陆陆续续的小文件将这些小文件，通过多线程的方式进行上传，从而达到性能的提升
解决上面简单上传的问题 大文件网络波动：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1086195e10ca3edd941448c560b4d82b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a669adca05265513abbceb298d3be2ff/" rel="bookmark">
			git clone的时候直接加上用户名和密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般拉取线上代码的先
1.git clone
2.在输入用户名
3.输入密码
等三步操作,这样子太麻烦了
直接一步操作 git clone http://用户名:密码@地址 例子
如果你用户叫123xxx 密码是mypassword 地址是git.xxx.com/www.git
git clone http://123xxx:mypassword@git.xxx.com/www.git 注明： 如果用户名是邮箱 会执行报错： fatal: unable to access 'http://abc@qq.com:abc123456@git.xxx.com/www.git/': Couldn't resolve host 'qq.com:abc123456@git.xxx.com' 报错原因是因为用户名包含了@符号，所以需求要把@转码一下
&lt;?php $userame='abc@qq.com'; echo urlencode($userame); ?&gt; abc%40qq.com @符号转码后变成了%40，所以只需在clone时将username变为abc%40qq.com即可，再次执行就ok了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f26a886f0233cce9f6515ba24696a771/" rel="bookmark">
			setsebool命令详解与SELinux管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		setsebool命令详解与SELinux管理 setsebool命令详解与SELinux管理 nginx报错failed (13: Permission denied) while connecting to upstream 二、执行下面的命令
setsebool -P httpd_can_network_connect 1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e46b0055db04787730f8e8020a1d0b40/" rel="bookmark">
			SPWM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SPWM产生是由一个调制波和载波进行比较得到的。所谓的SPWM信号就是在目标周期内，PWM的占空比按照正弦规律变化；即SPWM的调制波为正弦信号。其软件设计流程图，如下：
载波：常常选取三角波，主要分为两种，等腰三角波和锯齿波；其中锯齿波又分为增减两种；将三角波离散化，正好对应单片机中定时器的计数方式：递增、递减以及增减（在我用过的单片机中都有这三种方式，在ST系列等大多数单片机都将PWM和定时器合在一起描述，通过数据手册可以看出STM32的定时器十分强大，有PWM通道、正交编码器通道、输入捕获通道等等，而TI的TMS320系列，将多种外设分离出来，它的定时器只有定时中断功能，而PWM等外设模块是单独出来的），但是不管怎么样，在单片机中，三角载波的产生通常是基于计数方式得到的（当然也有其他方式，也可以使用数组存放载波数据）；
调制波：这个就优秀了，我们最终的PWM的占空比就是靠它决定的（在逆变器中它还决定输出正弦交流电的频率），调制波可以是一条直线、也可以是正弦信号、也可以是别的什么样式的信号；当它是一条直线时，由他产生的PWM信号的占空比就只会同时变化，一点也不圆润。。。如果它是正弦信号，看图。嗯，这就比较润了。。。
我们看图说话，令载波的幅值不变（废话，闲的啊，在数字系统中修改载波幅值，就是在修改定时器的周期。），改变PWM的占空比，就只能去修改调制波的幅值。在逆变器调压方式之一，修改调制波的幅值；当然也可以，改变输入端直流电压，从而改变输出交流电压。如果想修改，逆变器输出的交流电频率，就只能去调节正弦调制波的频率。
基本原理就是面积等效原理，即冲量相等而形状不同的窄脉冲加在具有惯性的环节上时，其效果基本相同 。
换句话说就是通过一系列形状不同的窄脉冲信号，相对应时间的积分相等(面积相等)，其最终效果相同；
所以SPWM就是输入一段幅值相等的脉冲序列去等效正弦波，因此输出为高的脉冲时间宽度基本上呈正弦规律变化；
这里通常使用的采样方法是：自然采样法和规则采样法；
自然采样法
自然采样法是用需要调制的正弦波与载波锯齿波的交点，
来确定最终PWM脉冲所需要输出的时间宽度，最终由此生成SPWM波；
具体如下图所示，这里会对局部①部分进行简单分析，下面进一步介绍；
SPWM波形
局部①的情况如下图所示；简单分析一下整个图形的情况；
锯齿波和调制正弦波的交点为A和B；
因此A点所需时间为T1，B点所需时间为T2；
所以在该周期内，PWM所需要的脉冲时间宽度Ton满足：
最终结论就是，只要求出A点和B点位置，就可以求出；
自然采样法
这里对于求解A，B位置的推导不做介绍，但是计算量比较大，因此在微处理器中进行运算会占用大量资源，下面再介绍另一种优化的采样方法：规则采样法。
规则采样法
根据载波PWM的电压极性，一般可以分为单极性SPWM和双极性SPWM；下面进一步介绍；
单极性
单极性SPWM在正弦波的正版周期，PWM只有一种极性，在正弦波的负半周期，PWM同样只有一种极性，但是与正半周期恰恰相反，具体如下图所示；
下面取正弦波的正半周期的情况进行分析；
单极性SPWM
正弦波的正半周期整体如下所示；由图中我们可以知道以下几点；
载波PWM的周期为T；
线段BO为当前这个等腰三角形的垂线；
线段BO与正弦曲线 相较于点A；
所以在该周期内，PWM所需要的脉冲时间宽度Ton满足：
单极性正半周期
具体的推导过程如下：
第一步：由于O点的位置比较好确认，因此，线段
第二步：这里载波锯齿波的最大幅值为1，因此线段
第三步：根据初中学过的相似三角形定理，满足：
最终简化得到：
这里对载波的幅值做了归一化处理，如果锯齿波的最大值为，正弦波的幅值最大为，则;
双极性
只要符合面积等效原理，PWM还可以是双极性的，具体如下图所示；这种调制方式叫双极性SPWM，在实际应用中更为广泛。
双极性SPWM
如何编写程序
上面讲到这里PWM的时间满足：
其中为正弦波幅值，为载波锯齿波幅值；
那么下面以STM32为例，介绍以下如何进行程序编写；
首先得先STM32是如何产生PWM？
通过数据手册可以知道，STM32通过TIM输出PWM，这里有几个寄存器；
计数寄存器：CNT
比较寄存器：CCR（决定了占空比，决定了脉冲宽度）
自动重装寄存器：AAR（决定了PWM的周期）
可能这么说，还是云里雾里的，先看下图；
STM32的PWM产生原理
STM32中PWM的模式有普通的PWM，和中央对齐的PWM，上图使用的就是中央对齐PWM；
产生PWM的过程可以分为以下几个过程；
第一步：配置好TIM，通常时基和ARR都会配置好，这时候PWM的周期就已经被设定好了，另外时基决定了CNT计数寄存器增加一次技术所需的时间；
第二步：刚开始，CNTCCR之后，PWM输出为高电平；
第三步：当CNT的值等于AAR之后，CNT开始减少，同理CNTCCR，PWM输出为高电平；
第四步：循环上述三个步骤；
程序中如何实现？
从上述STM32产生PWM的过程中不难发现，满足；
上一节推导的公式如下：
结合①式和②式，可以得到：
上面公式中用CCR表示CCR寄存器中的值，ARR表示ARR寄存器中的值；
最后需要做的三件事
计算出ARR，一般配置TIM定时器的时候能在数据手册找到公式；
调制比，也就是的系数；
根据③式生成正弦表，然后查表（实时计算因为涉及到较多运算量，所以利用查表，空间换时间，提高效率），利用PWM的事件去触发中断，更新下一次CCR的值；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e46b0055db04787730f8e8020a1d0b40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6568aa86bb3c0f0e8b5f1ed4ba75db09/" rel="bookmark">
			Vue Canvas 实现电子签名 手写板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码
&lt;template&gt; &lt;section class="signature"&gt; &lt;div class="signatureBox"&gt; &lt;div class="canvasBox" ref="canvasHW"&gt; &lt;canvas ref="canvasF" @touchstart='touchStart' @touchmove='touchMove' @touchend='touchEnd' @mousedown="mouseDown" @mousemove="mouseMove" @mouseup="mouseUp"&gt;&lt;/canvas&gt; &lt;div class="btnBox"&gt; &lt;div&gt;&lt;span @click="overwrite"&gt;重写&lt;/span&gt;&lt;/div&gt; &lt;div&gt;&lt;span @click="commit"&gt;提交签名&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;img class="imgCanvas" :src="imgUrl" alt="绘制的签名"&gt; &lt;/div&gt; &lt;/section&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { stageInfo: '', imgUrl: '', client: {}, points: [], canvasTxt: null, startX: 0, startY: 0, moveY: 0, moveX: 0, endY: 0, endX: 0, w: null, h: null, isDown: false, // isViewAutograph: this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6568aa86bb3c0f0e8b5f1ed4ba75db09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84f527be1e95b6455f5d364c86c3b6c1/" rel="bookmark">
			Android studio 单元测试无法运行的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android studio 单元测试无法运行的问题解决
今天新换了笔记本，安装好环境后，发现项目的单元测试无法通过，报错信息如下：
java.lang.NoClassDefFoundError: jdk/internal/reflect/GeneratedSerializationConstructorAccessor1 问题原因：AS安装后默认jdk是Android default jdk,如果本地的jdk和as默认的不一致就会导致无法单元测试
解决办法：
打开project structure -》sdk location -&gt; jdk location was moved to Gradke setting -&gt; gradle jdk 选择本地环境变量配置的版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fbc7144774747b4455f19f8ad568267/" rel="bookmark">
			spring-cloud微服务，网关与swagger
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		严格统一流量入口，不让Swagger前端绕过网关直接访问后端微服务的接口；(改代码麻烦)
直接改nginx转发了
不严格统一流量入口，让Swagger前端绕过网关直接访问后端微服务的接口；
原文在网关实现合并多个微服务Swagger接口文档的详细步骤 - 云+社区 - 腾讯云 在网关实现合并多个微服务Swagger接口文档的详细步骤 2021-05-11阅读 6130
由于微服务的划分，使用Swagger生成的接口文档也随之拆散，前端同事不得不把每个微服务的接口文档保存为浏览器标签，方便快速切换。在引入网关之后我们想改善这个问题，统一多个微服务接口文档的入口，最好不需要将每个微服务暴露到外网，能够统一配置是否开启接口文档功能，也不需要为接口文档配置路由规则。
WebFlux整合Swagger 基于Spring Cloud Gateway开发微服务网关的前提是我们已经了解了响应式编程，并且会使用Project Reactor、WebFlux提供的API。而在网关项目中整合Swagger实际就是在WebFlux项目中整合Swagger。
首先是在项目中添加Swagger相关依赖，注意选择版本号。
由于我们项目使用的Spring Boot版本号是2.3.0.RELEASE，因此我们选择的Swagger版本号为2.10.x。
&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-spring-webflux&lt;/artifactId&gt; &lt;version&gt;2.10.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.10.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.10.5&lt;/version&gt; &lt;/dependency&gt; 接着需要为WebFlux添加静态资源文件访问路径映射，即添加ResourceWebHandler。
@EnableSwagger2WebFlux @Configuration public class WebfluxConfiguration implements WebFluxConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler("/swagger-ui.html**") .addResourceLocations("classpath:/META-INF/resources/"); registry.addResourceHandler("/webjars/**") .addResourceLocations("classpath:/META-INF/resources/webjars/"); } } 到此为止，我们只是为一个WebFlux项目配置了Swagger功能，现在打开浏览器访问/swagger-ui.html#/看到的只是Swagger为网关项目生成的接口文档。
合并多个微服务Swagger接口文档 方案一（笔者从一些博客看到的） 在网关项目中自定义SwaggerResourcesProvider替换Swagger提供的。
自定义SwaggerResourcesProvider实现SwaggerResourcesProvider接口的get方法，方法可返回多个SwaggerResource，每个SwaggerResource对应每个微服务，我们可以过滤掉网关自身的，代码如下。
@Primary @Profile({"dev", "test"}) // 仅本地测试、测试环境开启 @Component public class GatewaySwaggerResourcesProvider implements SwaggerResourcesProvider{ @Override public List&lt;SwaggerResource&gt; get() { List&lt;SwaggerResource&gt; swaggerResources = new ArrayList&lt;&gt;(); routeProperties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fbc7144774747b4455f19f8ad568267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4b381931ce2f678525a556afad6cce5/" rel="bookmark">
			华为云迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 迁移 迁移：将x86架构的物理机或者虚拟机迁移到华为的私有云上或者虚拟化平台上，主要是为了提高资源利用率，降低能耗，集中管理 迁移原则：迁移风险，迁移影响，业务复杂，中断时间 迁移方式：文件级，块级 迁移场景：p2v，v2v，华为云平台内部的迁移 迁移特点：迁移的效率高，自动化，兼容性，无license并发两台，可行性检测 windwos块级原理： windows块级打快照：三次 迁移流程规划：调研（迁移数据量，业务情况，可行性评估），制作方案，迁移演练，测试，交付 端口限制：8899，7443，22，445，80，8443 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b09335f713ecd94b44c8cc12c9f44be5/" rel="bookmark">
			leetcode练习——动态规划（不同路径）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
官方解法：https://leetcode-cn.com/problems/unique-paths/solution/bu-tong-lu-jing-by-leetcode-solution-hzjf/
解法一：动态规划
（40ms/14.9MB）
class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: f = [[1] * n] + [[1] + [0] * (n - 1) for _ in range(m - 1)] print(f) for i in range(1, m): for j in range(1, n): f[i][j] = f[i - 1][j] + f[i][j - 1] return f[m - 1][n - 1] 优化1：空间复杂度 O(2n)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b09335f713ecd94b44c8cc12c9f44be5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f484ebda5786b4861520441e4453a3/" rel="bookmark">
			c&#43;&#43;——std::swap的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		std::swap的源码实现如下：
template&lt;typename T&gt; void swap(T &amp;a,T &amp;b) noexcept { T temp = std::move(a); a = std::move(b); b = std::move(temp); } std::swap是基于std::move语义实现的，关于std::move的介绍可以参考：c++11总结03——右值引用_www_dong的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a11d21d339588bf982f2fe83853a0764/" rel="bookmark">
			2021-11-03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Quartus学习笔记
1.将元件设为顶层
2.创建系统自带的rom元件时，要注意和自己的mif文件所定义的一样
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df4870aa6015eebb585c87cbde000144/" rel="bookmark">
			pytorch每次分类结果都不同，有细微差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了许多大神的经验，做一个总结：
验证测试集的时候开启model.eval() 。设置随机种子。pytorch框架中模型加载器dataLoader的属性“shuffle”置为“False”。 如果想看 具体原因 和 简单实现 可以继续往下看：
验证测试的时候开启model.eval() 。因为可能你的模型中含有 BatchNormalization（批归一化）或 Dropout（舍弃），如果未设置模型为eval模式，则验证时会根据每次的batch调整或Dropout还是随机去掉某些神经元，这不符合我们的要求。如果设置模型为eval后，Batch会设置全部数据的均值，Dropout会全部放开，不会随机率舍弃神经元。简单代码如下： for epoch in num_epoch: model.train() ....具体训练的代码.... model.eval() ....具体验证的代码.... 设置随机种子。众所周知，种子会影响每次随机数的取值，而我们的程序中不可避免会用到一些随机数，可能我们自己都不知道哪里用到了。所以最好设置种子一样把。 seed = 0 # 设置一个种子，确保可以复现 torch.manual_seed(seed) torch.cuda.manual_seed(seed) torch.cuda.manual_seed_all(seed) # if you are using multi-GPU. np.random.seed(seed) # Numpy module. random.seed(seed) # Python random module. torch.manual_seed(seed) torch.backends.cudnn.benchmark = False torch.backends.cudnn.deterministic = True ———————————————— 版权声明：本文为CSDN博主「ASR_THU」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/zongza/article/details/90908609 pytorch框架中模型加载器dataLoader的属性“shuffle”置为“False”。亲身经历过这个问题。看知乎有大神提到有可能是每次测试数据不一样导致分类结果有细微差异，我才想到dataLoader。 # 我把我的一个程序中用到的dataLoader拿出来当例子 dataLoader = torch.utils.data.DataLoader( dataset=dataset, batch_size=batch_size, shuffle=False, # 为了能复现结果，我将shuffle设置为False pin_memory=pin_memory, num_workers=workers ) 我们总是站在巨人的肩膀上。感激各位前辈和领路人的指引。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df4870aa6015eebb585c87cbde000144/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f00bce0c12f841925ffd307f4c99ea7/" rel="bookmark">
			[AcWing]803. 区间合并（C&#43;&#43;实现）区间合并模板题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[AcWing]803. 区间合并（C++实现）区间合并模板题 1. 题目2. 读题（需要重点注意的东西）3. 解法4. 可能有帮助的前置习题5. 所用到的数据结构与算法思想6. 总结 1. 题目 2. 读题（需要重点注意的东西） 初步思路：
------------------------------------------------------代码实现思路-----------------------------------------------------------
读取各个区间存放在segs中；对segs排序，合并区间，将合并的区间存放在res中；返回res.size()得到合并后的区间数。 合并区间模板
① 输入的区间在维护的区间内；ed = ed;
② 输入的区间和维护的区间有交集； ed = seg.second;
综合①②得到 ed = max(ed,seg.second);
③ 完全没有交集，将当前维护的区间添加到res中，然后取下一个区间进行维护。
3. 解法 ---------------------------------------------------解法---------------------------------------------------
#include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; typedef pair&lt;int,int&gt; PII; vector&lt;PII&gt; res,segs; // segs用于存放原区间，res存放合并后的区间 int n; vector&lt;PII&gt; merge(vector&lt;PII&gt; &amp;segs){ sort(segs.begin(),segs.end()); int st = -2e9, ed = -2e9; for(auto seg : segs){ if(seg.first &gt; ed){ if(st !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f00bce0c12f841925ffd307f4c99ea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e224123fe501e04133bb813eaf21fa79/" rel="bookmark">
			字符串的BF算法（堆分配）——严蔚敏版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机教材《数据结构（C语言版）》——严蔚敏教授编写的，我根据此书中串的那章内容及思想方法，敲了BF算法的代码，如下：
#include&lt;stdio.h&gt; #include&lt;string&gt; #include&lt;stdlib.h&gt; #pragma warning(disable:4996) #define ERROR 0 #define OVERFLOW 0 #define OK 1 typedef int Status; typedef struct { char* data; int length; }HString; //对串进行赋值操作 Status strAssign(HString&amp; T, char* chrs) { //释放掉T中的原数据 if (T.data) { free(T.data); T.length = 0; } //定义一个temp数组用来接收chrs的元素 char* temp = chrs; int len = 0; while (*temp) { len++; temp++; } //当chrs是一个空的数组后，进行下列操作 if (len == 0) { T.data = NULL; T.length = len; return 0; } //如果不为空，分配内存空间 else { T.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e224123fe501e04133bb813eaf21fa79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db0ee8e66a802aee7018baa6554edb25/" rel="bookmark">
			web-worker在vue中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装vue-worker npm install vue-worker
安装worker-loader npm install worker-loader
vue.config.js中添加如下配置
module.exports = { devServer: { open: true, port: 3003, }, lintOnSave: false, //关闭eslint警告 chainWebpack: config =&gt; { config.module.rule('worker').test(/\.worker\.js$/).use('worker-loader').loader('worker-loader').options({ inline: 'fallback' }).end(); config.module.rule('js').exclude.add(/\.worker\.js$/); config.output.globalObject("this"); }, } 添加子线程文件test.worker.js
onmessage = function (event) { console.log("接收到主线程发来的消息", event); let para = JSON.parse(event.data); countDown(para) } function countDown() { for (let i = 0; i &lt; 10; i++) { postMessage({ value: i }); } } worker使用
&lt;script&gt; import testWorker from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db0ee8e66a802aee7018baa6554edb25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c55048aec6a55c0579a942a552e8e96c/" rel="bookmark">
			rtsp推流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
参考：RTMP、RTSP推流 · 大专栏 # 导入opencv import cv2 as cv import subprocess as sp rtspUrl = 'rtsp://localhost/test' #将处理后的帧传入管道推流到该地址 def face_detect_demo(img): gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY) face_detect = cv.CascadeClassifier('haarcascade_frontalface_alt2.xml') # 主要是调整参数 face = face_detect.detectMultiScale(gray) for x, y, w, h in face: cv.rectangle(img, (x, y), (x+w, y+h), color=(0, 0, 255), thickness=2) # 读取实时流 cap = cv.VideoCapture('rtsp://192.168.1.118/190647.sdp') #此处写easypusher在easydarwin的播放地址 # 视频属性 size = (int(cap.get(cv.CAP_PROP_FRAME_WIDTH)), int(cap.get(cv.CAP_PROP_FRAME_HEIGHT))) sizeStr = str(size[0]) + 'x' + str(size[1]) fps = cap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c55048aec6a55c0579a942a552e8e96c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd575764cfc278e8f6cbd1e8fbb54f8b/" rel="bookmark">
			二叉树的相关算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、二叉树的结点表示
if(p-&gt;lchild != NULL &amp;&amp; p-&gt;rchild != NULL)//度为2的结点，左右孩子同时不空 if((p-&gt;lchild == NULL &amp;&amp; p-&gt;rchild != NULL) || (p-&gt;lchild != NULL &amp;&amp; p-&gt;rchild == NULL))//度为1的结点，左孩子不为空，或者右孩子不为空 if(p-&gt;lchild == NULL &amp;&amp; p-&gt;rchild == NULL)//度为0的结点，两个孩子都为空 1、二叉树的先序遍历递归与非递归
void preorder(BiTree T) { if(T != NULL) { visit(); preorder(T-&gt;lchild); preorder(T-&gt;rchild); } } //一直入栈往左走，到头出栈掉个头 void preorder(BiTree T) { InitStack(S); p = T: while(p != NULL || !StackEmpty(S)) { if(p !=NULL) { printf(p-&gt;data); push(S,p); p = p-&gt;lchild; } else { pop(S,p); p = p-&gt;rchild; } } } 2、二叉树的中序遍历
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd575764cfc278e8f6cbd1e8fbb54f8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44110abd2f2f02c817e627fe878b2560/" rel="bookmark">
			秒杀系统学习笔记（编程不良人）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		秒杀系统学习笔记 秒杀场景 电商抢购限量商品买演唱会门票或者票抢座12306… 保护措施 乐观锁和悲观锁令牌桶限流Redis缓存消息队列异步处理订单… 防止超卖 业务分析 创建数据库 -- ---------------------------- -- Table structure for stock -- ---------------------------- DROP TABLE IF EXISTS `stock`; CREATE TABLE `stock` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(50) NOT NULL DEFAULT '' COMMENT '名称', `count` int(11) NOT NULL COMMENT '库存', `sale` int(11) NOT NULL COMMENT '已售', `version` int(11) NOT NULL COMMENT '乐观锁，版本号', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- ---------------------------- -- Table structure for stock_order -- ---------------------------- DROP TABLE IF EXISTS `stock_order`; CREATE TABLE `stock_order` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `sid` int(11) NOT NULL COMMENT '库存ID', `name` varchar(30) NOT NULL DEFAULT '' COMMENT '商品名称', `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 编写代码 Controller层 @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44110abd2f2f02c817e627fe878b2560/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b728b808bd25b9a60e03ffcfe54b4f3/" rel="bookmark">
			关于使用cmd控台进入Anaconda Prompt环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 解决此方法可实现在python中执行各种操作，由于只能引用os。
具体实现 在cmd中输入conda.bat activate 执行此命令为激活base环境，也可使用 conda.bat activate env_1加上具体环境名称。
conda.bat activate 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7535ec084350d4b1c463bd4a1d489d95/" rel="bookmark">
			JavaSE基础问答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.面向对象和面向过程的区别？ 面向过程：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消 耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等 一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特 性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性 能比面向过程低。 2.Java 语言有哪些特点? 面向对象（封装，继承，多态）；平台无关性（ Java 虚拟机实现平台无关性）；可靠性；安全性；支持多线程;支持网络编程；编译与解释并存； 3.请解释什么是JVM、JDK、JRE ？ JVM
Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows， Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。
首先，JVM 类加载器首先加载字节码文件；然后，通过解释器逐行解释执行；（这种方式的执行速度会相对比较慢）因为，有些方法和代码块是经常需要被调用的（热点代码），所以后面引进了 JIT 编译器；JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。Java 是编译与解释共存的语言 JDK
JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器 （javac）和工具（如javadoc和jdb）。它能够创建和编译程序。JRE
JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机 （JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。 4.什么是字节码?采用字节码的好处是什么? 在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。 Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特 点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种 不同操作系统的计算机上运行。
5.Oracle JDK 和 OpenJDK 有什么区别？ Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次;OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不 是完全开源的；Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK， 因为它经过了彻底的测试和稳定。在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支 持来获取最新版本；Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7535ec084350d4b1c463bd4a1d489d95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410ae3319038dae3a308360b9cab96ea/" rel="bookmark">
			git rebase相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅做记录，方便翻 git rebase 命令：https://www.yiibai.com/git/git_rebase.html
git rebase 之后直接 git push 不成功：https://blog.csdn.net/ManyPeng/article/details/81095744
git rebase -i：https://juejin.cn/post/6844903600976576519
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/113c359f8034423f69a6dfc2f98149a7/" rel="bookmark">
			pandas表合并——按指定列合并两个表里同样名称的行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在处理观测站气象数据时，遇到了需要将两个表的数据整理到一起的问题，两个表的数据结构如下：
现在需要将两个表按第一列‘Sta_ID’拼接，将第二个表中‘Sta_ID’值与第一个表相同的行拼接到同一行，效果如下：
需要的库基本有pandas，xlrd，xlwt这几个，首先使用pandas.read_excel(）将数据分别读入pandas。
A = pd.read_excel('E:\\MODIS\\MCD19A2\\AOD_Max.xls', sheet_name='AOD_Max') # 读取 excel B = pd.read_excel('E:\\MODIS\\MCD19A2\\AOD_Max.xls', sheet_name='Station_Max', index_col=0) 下一步进行合并，使用pandas.concat()函数实现，关于concat()函数具体的解释可以参考：
https://blog.csdn.net/mr_hhh/article/details/79488445
但是这里有个问题，需要设置索引列为‘Sta_ID’这一列，如果默认索引为这一列，由于该列有重复项，在执行concat()函数时会报错
InvalidIndexError: Reindexing only valid with uniquely valued Index objects’
为解决这个问题，将表A读入时采用默认索引，然后用drop_duplicates()函数删掉重复的行。注意：我的数据B表没有重复项要去除，所以读的时候直接默认索引列为‘Sta_ID’了。
X = A.drop_duplicates(subset=['Sta_ID']) 这里我在测试的时候发现，如果把返回值还给A（如A.drop_duplicates(subset=['Sta_ID'])和A=A.drop_duplicates(subset=['Sta_ID'])），那A是没有变化的，所以把这个值给了X，就可以实现了。
drop_duplicates()函数参考
https://blog.csdn.net/Disany/article/details/82689948
现在需要把删除重复项的表X的索引列改为‘Sta_ID’列：
X = X.set_index('Sta_ID') 最后完成拼接：
merge = pd.concat([X, B], axis=1, join='inner') 完整程序如下：
import pandas as pd # 从excel导入表 A = pd.read_excel('E:\\MODIS\\MCD19A2\\AOD_Max.xls', sheet_name='AOD_Max') # 读取 excel B = pd.read_excel('E:\\MODIS\\MCD19A2\\AOD_Max.xls', sheet_name='Station_Max', index_col=0) # 去除重复行 X = A.drop_duplicates(subset=['Sta_ID']) # 更换索引列 X = X.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/113c359f8034423f69a6dfc2f98149a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24da20f13beea9decef0bbe704ffd9a8/" rel="bookmark">
			[AcWing]802. 区间和（C&#43;&#43;实现）区间和模板题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[AcWing]802. 区间和（C++实现）区间和模板题 1. 题目2. 读题（需要重点注意的东西）3. 解法4. 可能有帮助的前置习题5. 所用到的数据结构与算法思想6. 总结 1. 题目 2. 读题（需要重点注意的东西） 初步思路：
x的范围在-10^9 到 10^9之间，而n,m 在1 到 10^5之间，有着值域大而数值稀疏的特性。是典型的离散化特征。离散化是指将离散的数据，映射到下标为0，1，2，3，4，5…的数组中，然后通过一个函数，输入区间的左端点 l 和右端点 r ，得到映射后的下标 Kl 和 Kr，然后通过前缀和输出区间和 s[Kr] - s[Kl-1];
------------------------------------------------------代码实现思路-----------------------------------------------------------
读取数据{x,c}存放在add，将x存放在alls数组中；读取l,r存放在query，将l、r存放在alls数组中；对alls数组进行排序和去重；
将离散数组中的数据依次加到a[ ]中；由a[ ]得到前缀和数组s[ ]；对每一个询问对[l , r]，用find函数找到Kl和Kr,输出s[Kr] - s[Kl - 1]。 3. 解法 注：
a[N]：用于存放离散数据的值，即将原离散数组映射到数组a中s[N]：是 a[N] 的前缀和；vector&lt; int &gt; all：用于问题中原离散数组出现过的所有位置；vector&lt; PII &gt; add：用于存放一个数对{x, c}，表示在离散数据原数组中的位置 x 处加上c；vector&lt; PII &gt; query：用于存放一个数对{l, r}，表示一个询问对(题目要求返回 l 到 r 之间的区间和)；find(int x)函数作用：输入一个映射前的位置x，得到映射后的位置；vector::iterator unique(vector &amp;a)函数作用：对给定的vector去重。（iterator ，迭代器，详见 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24da20f13beea9decef0bbe704ffd9a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeabc0bf8169c9c33f6c7546ab466930/" rel="bookmark">
			IAR平台下移植FreeRTOS，切换C&#43;&#43;语言的编译问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用IAR开发时，在STM32F4上面移植FreeRTOS时发现，添加完成包含C++源文件时，将IAR语言切换到C++时，编译报错特别多，常见的之类类型转换都好处理，直接强制转换就好了。但是还有一些函数未定义的问题，比较难处理，尤其是有些文件引用了“portasm.s”这个汇编文件里面的函数，在工程编译最后的链接阶段,总会报错某某函数未定义。这篇文章记录一下处理流程，仅供参考。
情况介绍： 一开始在IAR上面移植，切换C++报错时，以为自己移植的过程有问题，所以直接将FreeRTOS里面的F407 Demo工程拿过来测试
项目路径为：FreeRTOSv202107.00\FreeRTOS\Demo\CORTEX_M4F_STM32F407ZG-SK
测试工程是近期直接在FreeRTOS官网上下载的。
问题描述： 官方工程使用IAR8.20打开后，直接编译，没有任何问题
Total number of errors: 0 Total number of warnings: 0 切换语言为C++，重新编译
报错，现阶段主要是指针类型转换的问题
找到报错点，一个个改完即可，如下
有“=”号进行赋值的语句直接强制类型转换就可以了，里面还有几处是宏定义里面报错的，如
直接修改宏定义即可
类型转换问题修改完成之后，重新编译此时的报错主要是引用的函数未定义
Error[Li005]: no definition for “vPortEnableVFP()”
Error[Li005]: no definition for “vPortStartFirstTask()”
Error[Li005]: no definition for “vRegTestClearFlopRegistersToParameterValue(unsigned long)”
Error[Li005]: no definition for “ulRegTestCheckFlopRegistersContainParameterValue(unsigned long)”
Error[Li005]: no definition for “vRegTest2Task(void *)”
Error[Li005]: no definition for “vRegTest1Task(void *)”
主要是上述几个函数，在链接的时候报错未定义，处理既然是链接阶段，那就直接看下.map文件。这是前两个报错的函数，后面几个可以在map文件里找到，主要在portasm.s 和RegTest.s这两个汇编文件里面。可以判断map文件里面都有相关的函数生成了，只是在连接的时候没有被正确识别。
问题分析： 既然知道问题在哪里，那一般怎么操作呢，Google一下，百度一下，基本上也就处理好了，但是不太好找到一些有效的处理办法。
比如这篇文章《IAR报错处理》，里面提到了函数vPortEnableVFP()和vPortStartFirstTask()未定义，是因为portasm.s文件没有添加到工程里面，上述问题显然不是这个原因。
或者这篇文章Creating a FreeRTOS Static Library，面提到了在C++环境下，C风格的文件在引用时需要做好声明，以便编译器在编译的过程中自动切换。
其他相关度较高的文章就不再列举了，所描述的问题处理方式不太适用当前情况，可以自行查阅。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeabc0bf8169c9c33f6c7546ab466930/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/100c7be111cb078a2b3c3a964f2329be/" rel="bookmark">
			SpringBoot系列之完整项目创建(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作：
昨天已经搭建好的基础
目的：前后端分离工程的数据校验和全局异常处理 1.数据校验： 1.引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; 2.测试例子创建 @Data @ApiModel(value = "用户表单") public class UserForm implements Serializable { @NotBlank(message = "姓名不能为空") @ApiModelProperty(value = "用户姓名") private String name; } 3.使用 @Validated可更换为@Valid，Spring做了兼容；但是@Valid不支持分组校验
@PostMapping("/save") public String save(@Validated @RequestBody UserForm form){ stringRedisTemplate.opsForValue().set("key","redisson"); return "save ok"; } 4.结果 数据返回结果：
后端结果：
前端看到的结果并不是我们想给他的，所以接下来做一个公共的响应结果集和设计对应的异常处理
2.异常处理 1.定义响应结果的编码枚举 /** * @Author: ChenTaoTao * @Date: 2021/11/3 10:22 * @Describe: */ @Getter public enum ResponseEnum { OK(200,true,"ok"), PARAM_ERR(400,false,"请求参数有误"), ERR(500,false,"服务器错误"); private Integer code; private Boolean status; private String msg; ResponseEnum(Integer code, Boolean status,String msg){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/100c7be111cb078a2b3c3a964f2329be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f18619430e66fcd31a13964596113183/" rel="bookmark">
			日常Harbor运维镜像-持续更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程拉取 docker pull mysql:5.7 docker pull java:8-jre docker pull redis:alpine docker pull sonatype/nexus3:latest docker pull jenkinsci/blueocean docker pull portainer/portainer docker pull httpd docker pull rabbitmq:3-management docker pull rancher/server:stable docker pull zookeeper docker pull traefik:latest 重打标签 docker tag redis:alpine 192.168.0.243/library/redis:alpine docker tag java:8-jre 192.168.0.243/library/java:8-jre docker tag mysql:5.7 192.168.0.243/library/mysql:5.7 docker tag docker.io/sonatype/nexus3:latest 192.168.0.243/library/nexus3:latest docker tag jenkinsci/blueocean 192.168.0.243/library/jenkinsci/blueocean:latest docker tag portainer/portainer 192.168.0.243/library/portainer:latest docker tag httpd:latest 192.168.0.243/library/httpd:latest docker tag rabbitmq:3-management 192.168.0.243/library/rabbitmq:3-management docker tag rancher/server:stable 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f18619430e66fcd31a13964596113183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33299fca71025e429f212cd8c70cd7c/" rel="bookmark">
			C语言数据结构学习笔记(12)-线索二叉树的创建和遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*
线索二叉树
输出结果：
ABDF##G###C#E##
中序遍历：F D G B A C E
中序遍历逆序：E C A B G D F
请按任意键继续. . .
*/
# include &lt;stdio.h&gt;
# include &lt;stdlib.h&gt;
typedef enum {Link, Thread} PointerTag;//Link为0表示指向左右孩子结点,Thread为1表示设置前驱或后继结点
# define ElemType char
typedef struct BiThrNode{
ElemType data;
struct BiThrNode *lchild, *rchild;
PointerTag lTag, rTag;
}BiThrNode, *BiThrTree;
BiThrTree pre;//定义全局变量始终指向前一个访问的结点
void CreateBiThrTree(BiThrTree * proot);//创建线索二叉树
void InOrderThreading(BiThrTree root, BiThrTree * H);//中序线索化二叉树并加入头结点
void InThreading(BiThrTree p);//中序线索化二叉树
void InOrderTree(BiThrTree H);//中序遍历二叉树
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d33299fca71025e429f212cd8c70cd7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1eca00b4c48a3f5a5ee71487ed62591/" rel="bookmark">
			eslint&#43;vscode格式化代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode安装eslint插件
全局安装eslint npm i -g eslint eslint --init #//js项目根目录运行，按照提示选择 项目根目录创建三个文件,然后执行npm install
.editorconfig root = true [*] end_of_line = lf insert_final_newline = true [*.{js,json}] charset = utf-8 indent_style = space indent_size = 2 end_of_line = lf insert_final_newline = true trim_trailing_whitespace = true .eslintrc.js
module.exports = { env: { browser: true, commonjs: true, es2020: true }, extends: [ 'standard' ], parserOptions: { ecmaVersion: 11 }, plugins: [ ], rules: { 'no-useless-constructor': 0 } } package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1eca00b4c48a3f5a5ee71487ed62591/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93c1b39bd3ed7854323e83dd8f87fbd/" rel="bookmark">
			git中出现Could not resolve hostname github: Name or service not known问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在准备使用git pull命令从远程仓库中拉取代码或本地写好代码准备使用git push命令推送代码至远程仓库时可能会突然出现这个问题
碰到这种问题时本人总结出几种解决方案供大家参考
解决方案一
登录Github，把原来的密钥删除，重新生成一个
解决方案二
将本地的git用户名删除
删除了以后重新使用git命令时就会要求你登录
git config --system --unset credential.helper
解决方案三
进入控制面板在windows凭证管理中找到你远程仓库地址下对应的域名对它进行编辑账号密码(如果找不到可以新建一条)
解决方案四
可能是因为系统中存在多个用户账号导致错误，可以尝试为当前项目重新配置用户账号
git config --local user.name 'xxx'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7400490b28f9fcbbc2165a39cb1b5c3f/" rel="bookmark">
			vue基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		v-if 和 v-show的区别 在切换 v-if 块时，Vue.js 有一个局部编译/卸载过程，因为 v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。
相比之下，v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。
一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换v-show较好，如果在运行时条件不大可能改变v-if较好。
v-if是动态添加，当值为 false 时，是完全移除该元素，即 dom 树中不存在该元素。(销毁与重建)
v-show 仅是隐藏 / 显示，值为 false 时，该元素依旧存在于 dom 树中。若其原有样式设置了 display: none 则会导致其无法正常显示。
computed(计算属性) vs methods(方法 ) 在vue.js中，有methods和computed两种方式来动态当作方法来用的。
1.首先最明显的不同 就是调用的时候，methods要加上（）
2.我们可以使用 methods 来替代 computed，效果上两个都是一样的，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。 而使用 methods ，在重新渲染的时候，函数总会重新调用执行。
computed(计算属性) vs watch(侦听器) computed(计算属性) 写在computed中
写起来像一个方法，用起来像一个属性（本质就是一个属性）
注意点：
只要跟计算属性相关的数据发生了改变，计算属性就会重新计算， 不相关的值发生变化，不会重新计算计算属性
一定要有返回值(return)
什么时候使用计算属性
根据已知data中的值，生成一个额外的新值，且新值还要跟着data中的值变化而变化
computed里面的计算属性名不能和data中的属性名重名
watch(侦听器) 可以通过watch监听一个属性值的变化，只要值发生了变化，就会调用watch的一些方法
watch是vm的一个配置项
监听的属性按照一个方法的格式来写
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7400490b28f9fcbbc2165a39cb1b5c3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/043670d6d581126d55f7f3186af349dc/" rel="bookmark">
			解决NodeJS使用mongoose包连接mongodb，其表名会自动复数的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天遇到了一个问题 nodeJs使用mongoose包链接mongodb时，数据表中一直有数据，但是，总是查询不到任何数据。
我们都知道 mongoose会给数据集合自动加上s
例如下方示例
const mongoose = require('mongoose') module.exports = mongoose.model('cart', mongoose.Schema({ user_id: String, good_id: String, num: Number, create_time: { type: Number, default: Date.now() }, status: { type: Number, default: 1 } })) 我们创建一个购物车表，如果忘了加s时，它会自动加上s为carts并创建该集合，这对我们来说很友好。
但是当我们创建一个双S结尾的集合，比如地址表用address命名时，它则会给你加上es
使其从 address &gt;&gt;&gt;&gt;&gt; ​​​​​​​addresses
这就很surprised了。
mongoose自动加复数的这个功能有利也有弊，权衡再三，我选择自己管理表名。
经过我查询资料所知，其实这个创表有三个参数，这第三个参数就会被用作mongoDB的表名，
这样写的话，MongoDB创建的表就是cart，就连复数都消失了。
当然，表名还是要加复数的，这里只是举例而已。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb1dae3bb86cff2df65a564176f6858/" rel="bookmark">
			springboot项目实现 redis缓存穿透，雪崩，击穿模拟与解决方案演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 用户获取数据的过程传统传统系统的问题为什么直接请求数据库会很慢 引入redis缓存引入redis带来的常见问题缓存穿透场景模拟步骤 解决方案解决方案模拟演示——使用布隆过滤器进行非法数据拦截布隆过滤器简介使用谷歌的布隆过滤器 缓存雪崩场景模拟解决解决方案模拟演示——使用加锁 缓存击穿场景模拟解决方案解决方案模拟——加锁 用户获取数据的过程 传统 没有缓存，直接请求数据库。
现在也有很多内部系统，教务系统等等都是这样的
传统系统的问题 最明显的问题就是: 慢！。
大家没发现我们学校的抢课系统每次都很慢吗？我猜大概率就是没用缓存，或者说服务做得不好，再或者代码写得有问题等等。
为什么直接请求数据库会很慢 大家需要知道一个知识：
请求速度：HTTP &gt; &gt; &gt; IO流 &gt; &gt; &gt; redis缓存 &gt; &gt; &gt; java缓存mysql 数据库对于高并发来说天然支持不好，mysql 单机支撑到 2000QPS 也开始容易报警了查一次数据库会耗时很多，一旦当数据请求量过大和高并发来了的时候，数据库就挺不住了，就会一直执行select语句，直接崩掉。这就抢课系统会很慢的原因！ 引入redis缓存 所以我们需要redis， 因为它高性能，高并发
凡事有利也有弊
引入redis带来的常见问题 缓存穿透，雪崩，击穿
缓存穿透 含义：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，导致数据库崩溃的现象为什么会有用户请求没有的数据呢？这种情况一般都是黑客攻击请求每次都“视缓存于无物”，直接查询数据库，这种恶意攻击场景的缓存穿透就会直接把数据库给打死。
场景模拟 步骤 为了安全，利用hashMap模拟数据库 /** * HashMap模拟数据库数据 */ private static Map&lt;Long, DataObject&gt; dbDataList = new HashMap&lt;&gt;(); /** * 初始化数据库，值为1~10000 */ @PostConstruct private void initData() { for (long i = 1; i &lt;= maxIdnum; i++) { //addToBloomFilter(String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdb1dae3bb86cff2df65a564176f6858/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f7602156903b065eb428b36c73cb00d/" rel="bookmark">
			IC卡 M1卡 各个扇区 控制块 密码 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该内容由部分转载和部分自己见解。整理出来方便小白和自己后期使用。
M1卡介绍
这次我们主要介绍的是非接触式IC卡。M1卡就是非接触式IC卡中应用最广泛的卡。M1卡就是Mifare非接触式感应卡，M1卡数据保存期为10年，可改写10万次，读无限次。无电源，自带天线，工作频率为13.56MHZ.M1卡内含加密控制逻辑和通讯逻辑电路。M1卡主要有两种，一种是S50和一种是S70。主要应用：门禁、考勤、会议签到、身份识别、物流、工业自动化、各种会员卡、如售饭、地铁、公交代币卡、俱乐部等电子消费、电子门票、动物识别、目标跟踪、洗衣管理、各种一卡通等等。
M1卡存储空间
M1卡分为16个扇区，每个扇区为4块，每块16个字节,以块为存取单位。每个扇区的块0、块1、块2为数据块，可用于存储数据。而每个扇区的块3为控制块，包括密码keyA，存取控制，密码keyB。存取控制的作用是控制对应扇区记录的读写权限与keyA和keyB的关系。由于每个扇区都有独立的key和存取控制，因此M1卡可以做到一卡多用互不干扰。
每一张M1卡的0扇区0块都称作绝对地址块，这一串是在卡片出厂时厂商赋予的，代表着这张卡独立的身份识别信息。绝对地址块的内容已被固化，无法更改。
M1卡控制位计算
以下为控制位的结构，前6位为密钥A，中间4位存取控制，后6位密钥B。
例如 A1A2A3A4A5 FF078069 B1B2B3B4B5
密码A 控制位 密码B
字节0-5 字节6-9 字节10-15
4位控制位中前3位是真实的控制位，第4位是备用控制位，一般用不上，因此我们可以只分析前3位。
三个控制位以正和反两种形式存在于存取控制字节中，决定了该块的访问权限。1个字节等于8个比特，而一个扇区有4个块，每个块有3个控制位，以下是控制位以比特形式的结构图，_b表示取反存储，这边用红色字体已标出。
以FF078069默认控制位为例，我们将FF078069的16进制转化为2进制如下：
FF=11 1 1 1 1 1 1；07= 0 0 0 0 0 1 1 1；80=1 0 0 0 0 0 0 0 ；69=忽略
将以上的2进制数填入表格：
将取反的数再次取反以获得原来的控制位：
存取控制中每个块都的三个控制位定义如下，同时填入上表数据：
块0，块1，块2控制位均是000，存取控制权限可对应以下表：
块3控制位001，存取控制对应如下表：
可见块0，块1，块2通过密钥A或者密钥B认证后可读，可写，可进行加值和减值操作。块3密钥A不可读，但可通过认证密钥A或B修改。验证密钥A或者密钥B后，可读可改写存取控制。验证密钥A或者密钥B后，可读可改写B密码。
综上，存取控制FF078069极不安全，我们可以自定义存取控制进行修改，只要利用上述步骤将想要的控制位列出逆向推回去即可。
M1卡认证原理
这里介绍M1卡的认证原理即三轮认证。三轮认证是保障M1卡安全的重要手段，整个过程采用Crypto-1算法加密。以下是三轮认证的过程。
1. 读写器指定要访问的区，向卡发送身份验证请求，并选择密钥A或B。
2. 卡从位块读取密钥和存取控制条件。然后，卡向读写器发送明文4字节随机数Nt。（第一轮）
3. 读写器利用密钥和随机数Nt计算生成一个新随机数Nr，并将两个随机数一起加密为8个字节的数据发送给卡片。（第二轮）。
4. 卡解密得到Nt与Nr，验证Nt，若通过再一次加密Nr并发送给读卡器（第三轮）。
5. 读写器解密得到Nr，验证通过。
三轮认证在其原理上是可靠的，但是外国研究人员发现了该算法伪随机数生成的漏洞，使得加解密所用到的伪随机数可被正确预测，从而逆向计算出了三轮认证中的扇区密钥。该漏洞的利用在后面会讲到。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecad71a9d0eff125ad5794b819b29df3/" rel="bookmark">
			Android10 SystemUI系统手势导航
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Android10 源码编译相关问题 2、Android10 系统进程Zygote启动 3、Android10 系统进程SystemServer 4、Android10 launcher启动流程 5、Android10 系统发送开机广播时机 6、Android10 AppComponentFactory源码梳理 7、Android10 InputManagerService事件输入输出 8、Android10 InputManagerService本地实现 9、Android10 SystemUI系统手势导航 从Android9开始，android系统就添加了系统导航手势，对于现在高版本的手机，有些系统默认就是开启导航手势的，有些还是沿用以前导航栏，但是也是可以在设置中开启导航手势，导航栏会自动消失，这篇文章主要讲解的是系统导航收拾是如何实现的。
对于系统导航手势的实现，android10还是在SystemUI中实现的，在以后的版本中可能就是在Launcher3中，SystemUI是一个系统应用，在SystemServer中启动，先来看下是如何启动的：
private static void startSystemUi(Context context, WindowManagerService windowManager) { Intent intent = new Intent(); intent.setComponent(new ComponentName("com.android.systemui", "com.android.systemui.SystemUIService")); intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING); //Slog.d(TAG, "Starting service: " + intent); context.startServiceAsUser(intent, UserHandle.SYSTEM); windowManager.onSystemUiStarted(); } 通过开启SystemUIService服务来拉起SystemUI，这里就直接来看下SystemUIService：
public class SystemUIService extends Service { @Override public void onCreate() { super.onCreate(); ((SystemUIApplication) getApplication()).startServicesIfNeeded(); ... ... } } 没做啥，就是继续调用SystemUIApplication.startServicesIfNeeded()，在说这个方法前，可以先了解下Android10 AppComponentFactory源码梳理，这里先来看下Manifest中对application的配置：
&lt;application android:name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecad71a9d0eff125ad5794b819b29df3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c9ed12d37e4322358c4c85302e31bd/" rel="bookmark">
			keil如何进行软件仿真，以及如何查看变量的实时值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开工程，点击魔术棒选择芯片和晶振，如下图
2.在Debug里面选择选择Use Simulator-使用软件仿真，勾选上Run to main()
3.点击红色的d符号，即可以进入仿真界面
下面介绍工具条的含义
1：复位，按下该按钮后，代码会重新从头开始执行。
2：执行到断点处，按按钮用来快速执行到断点处。
3：停止运行，程序执行的时候变为有效，可以使程序停止下来进入到单步调试状态。
4：执行进去，该按钮用来实现执行到某个函数里面去的功能，在没有函数的情况下等同于执行过去按钮。
5：执行过去，在碰到有函数的地方，通过该按钮就可以单步执行过这个函数，而不进入这个函数单步执行。
6：执行出去，该按钮是进入了函数单步调试的时候，有时候可能不必再执行该函数的剩余部分了，通过该按钮就直接一步执行完函数余下的部分，并跳出函数回到函数被调用的位置。
7：执行到光标处：该按钮可以迅速使程序运行到光标处，与执行到断点处按钮功能类似。
8：汇编窗口，通过该按钮可以查看汇编代码，这对分析程序很有用。
9：堆栈局部变量窗口，通过该按钮可以显示Call Stack+Locals窗口，显示当前函数的局部变量及其值，方便查看。
10：观察窗口，MDK5提供2个观察窗口(下拉选择)，该按钮按下则弹出一个显示变量的窗口。输入想观察的变量或表达式，即可查看其值，是很常用的调试窗口。
11:内存查看窗口，MDK5提供4个内存查看窗口，按下按钮，则弹出一个内存查看窗口，可以在里面输入要查看的内存地址，然后观察这一片内存的变化情况。
12：串口打印窗口，MDK5提供4个串口打印窗口。按下该按钮，则弹出一个类似串口调试助手界面的窗口，用来显示从串口打印出来的内容。
13：逻辑分析窗口，该图标下面有3个选项，一般用第一个，也就是逻辑分析窗口。通过SETUP按钮新建一些IO口，于是可以观察这些IO的电平变化情况，并以多种形式显示出来，比较直观。
14：系统查看窗口，该按钮可以提供各种外设寄存器的查看窗口(通过下拉选择)，选择对应外设即可调出该外设的相关寄存器表，并显示这些寄存器的值，方便查看设置是否正确。
4.如果需要查看变量的值，只需要进入软件仿真界面，然后双击要观察的变量，右键选择 Add “i” to Watch1
如下图，右键点击变量，可以看到Hexadecimal Display被勾选了，这意味着变量以16进制的格式显示，想要让变量以10进制的方式显示，只需要将勾去掉即可。
5.局部变量在全速运行过程中观察不到，只有程序暂停时才能看到局部变量值。
想要在全速运行时就能看到局部变量值的变化有两种方法。
方法一：将局部变量声明为volatile类型
如下图：vu16类型 就是volatile unsigned short int类型。
方法二：将局部变量改为全局变量，这样全速运行时也能看到变量值变化。
如下图，可以看到变量i j k在main()函数外面。
进入仿真之后，要选择view菜单下的 periodic window update，然后点击全速运行，也可以看到变量的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e45ec139458bd90aa34c8d633410ec22/" rel="bookmark">
			Matlab project1 phase 2&amp;3 - Minimum Snap/Jerk and A* Algorithm ＜Experiment recording＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Preface:This article is written for a nifty girl who I cherish.
Catalogue (0)Minimum Snap/Jerk Trajectory Generation(0.0)TheoryHandle problemMethodOn droneProblem definationProblem sloving (0.1)codes (1)A* algorithm(1.0)Description(1.1)coding with matlab(1.2)codes (2)More things(2.0)Minimum polynomial degree(2.1)Polynomial Trajectories - corridor(2.2)Polynomial Trajectories - divide time(2.3)Polynomial Trajectories - Closed form (3)Reference (0)Minimum Snap/Jerk Trajectory Generation (0.0)Theory Handle problem 空间中有少量路径点，试图构建一条连续的路径，这条路径经过我们所给的少数路径点，使得无人机能够平滑地飞过这个路径
Method 多项式有很好的特性，比如计算方便（可以用矩阵表示），可拟合高阶曲线，所以多项式拟合路径；考虑到路径可能很复杂，如果整个路径用一个多项式表示，那么就会使得拟合路径的多项式阶数很高，并且不能处理闭环路径；所以我们采用每个路径点之间用一个多项式拟合；并且为了使得拟合曲线满足函数的“不可一对多”，我们拟合的是一个参数方程，其自变量为时间 On drone 在无人机中，我们往往考虑要是得最小化加加速度(jerk)或者最小化加加加速度(snap)
其中最小化速度(jerk)保证了无人机飞行路径最短最小化加加速度(jerk)保证了无人机飞行的稳定性（因为加加速度与无人机pitch，roll轴的角速度成真比）加加加速度(snap)保证了无人机的耗能最小（因为） Problem defination Target：最小化加加速度(jerk)或者加加加速度(snap)
Constraints：对初始结束位置速度加速度的约束，对位置点的约束，对连续的约束
这个可以转换为一个二次规划的问题，在Matlab中通过quadprog函数对其进行求解
quadprg:
x = q u a d p r o g ( H , f , A , b , A e q , b e q , l b , u b ) x = quadprog(H,f,A,b,Aeq,beq,lb,ub) x=quadprog(H,f,A,b,Aeq,beq,lb,ub)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e45ec139458bd90aa34c8d633410ec22/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/319/">«</a>
	<span class="pagination__item pagination__item--current">320/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/321/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>